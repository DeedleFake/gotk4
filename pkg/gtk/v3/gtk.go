// Code generated by girgen. DO NOT EDIT.

package gtk

import (
"runtime"
"unsafe"

"github.com/diamondburned/gotk4/core/gerror"
"github.com/diamondburned/gotk4/core/gextras"
"github.com/diamondburned/gotk4/pkg/cairo"
"github.com/diamondburned/gotk4/pkg/gdk/v3"
"github.com/diamondburned/gotk4/pkg/gdkpixbuf/v2"
"github.com/diamondburned/gotk4/pkg/gio/v2"
"github.com/diamondburned/gotk4/pkg/glib/v2"
"github.com/diamondburned/gotk4/pkg/pango"
externglib "github.com/gotk3/gotk3/glib"
)


// #cgo pkg-config: gtk+-3.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
import "C"

func init() {
  externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
      {T: externglib.Type(C.gtk_align_get_type()), F: marshalAlign},
      {T: externglib.Type(C.gtk_arrow_placement_get_type()), F: marshalArrowPlacement},
      {T: externglib.Type(C.gtk_arrow_type_get_type()), F: marshalArrowType},
      {T: externglib.Type(C.gtk_assistant_page_type_get_type()), F: marshalAssistantPageType},
      {T: externglib.Type(C.gtk_baseline_position_get_type()), F: marshalBaselinePosition},
      {T: externglib.Type(C.gtk_border_style_get_type()), F: marshalBorderStyle},
      {T: externglib.Type(C.gtk_builder_error_get_type()), F: marshalBuilderError},
      {T: externglib.Type(C.gtk_button_box_style_get_type()), F: marshalButtonBoxStyle},
      {T: externglib.Type(C.gtk_button_role_get_type()), F: marshalButtonRole},
      {T: externglib.Type(C.gtk_buttons_type_get_type()), F: marshalButtonsType},
      {T: externglib.Type(C.gtk_cell_renderer_accel_mode_get_type()), F: marshalCellRendererAccelMode},
      {T: externglib.Type(C.gtk_cell_renderer_mode_get_type()), F: marshalCellRendererMode},
      {T: externglib.Type(C.gtk_corner_type_get_type()), F: marshalCornerType},
      {T: externglib.Type(C.gtk_css_provider_error_get_type()), F: marshalCSSProviderError},
      {T: externglib.Type(C.gtk_css_section_type_get_type()), F: marshalCSSSectionType},
      {T: externglib.Type(C.gtk_delete_type_get_type()), F: marshalDeleteType},
      {T: externglib.Type(C.gtk_direction_type_get_type()), F: marshalDirectionType},
      {T: externglib.Type(C.gtk_drag_result_get_type()), F: marshalDragResult},
      {T: externglib.Type(C.gtk_entry_icon_position_get_type()), F: marshalEntryIconPosition},
      {T: externglib.Type(C.gtk_event_sequence_state_get_type()), F: marshalEventSequenceState},
      {T: externglib.Type(C.gtk_expander_style_get_type()), F: marshalExpanderStyle},
      {T: externglib.Type(C.gtk_file_chooser_action_get_type()), F: marshalFileChooserAction},
      {T: externglib.Type(C.gtk_file_chooser_confirmation_get_type()), F: marshalFileChooserConfirmation},
      {T: externglib.Type(C.gtk_file_chooser_error_get_type()), F: marshalFileChooserError},
      {T: externglib.Type(C.gtk_im_preedit_style_get_type()), F: marshalIMPreeditStyle},
      {T: externglib.Type(C.gtk_im_status_style_get_type()), F: marshalIMStatusStyle},
      {T: externglib.Type(C.gtk_icon_size_get_type()), F: marshalIconSize},
      {T: externglib.Type(C.gtk_icon_theme_error_get_type()), F: marshalIconThemeError},
      {T: externglib.Type(C.gtk_icon_view_drop_position_get_type()), F: marshalIconViewDropPosition},
      {T: externglib.Type(C.gtk_image_type_get_type()), F: marshalImageType},
      {T: externglib.Type(C.gtk_input_purpose_get_type()), F: marshalInputPurpose},
      {T: externglib.Type(C.gtk_justification_get_type()), F: marshalJustification},
      {T: externglib.Type(C.gtk_level_bar_mode_get_type()), F: marshalLevelBarMode},
      {T: externglib.Type(C.gtk_license_get_type()), F: marshalLicense},
      {T: externglib.Type(C.gtk_menu_direction_type_get_type()), F: marshalMenuDirectionType},
      {T: externglib.Type(C.gtk_message_type_get_type()), F: marshalMessageType},
      {T: externglib.Type(C.gtk_movement_step_get_type()), F: marshalMovementStep},
      {T: externglib.Type(C.gtk_notebook_tab_get_type()), F: marshalNotebookTab},
      {T: externglib.Type(C.gtk_number_up_layout_get_type()), F: marshalNumberUpLayout},
      {T: externglib.Type(C.gtk_orientation_get_type()), F: marshalOrientation},
      {T: externglib.Type(C.gtk_pack_direction_get_type()), F: marshalPackDirection},
      {T: externglib.Type(C.gtk_pack_type_get_type()), F: marshalPackType},
      {T: externglib.Type(C.gtk_pad_action_type_get_type()), F: marshalPadActionType},
      {T: externglib.Type(C.gtk_page_orientation_get_type()), F: marshalPageOrientation},
      {T: externglib.Type(C.gtk_page_set_get_type()), F: marshalPageSet},
      {T: externglib.Type(C.gtk_pan_direction_get_type()), F: marshalPanDirection},
      {T: externglib.Type(C.gtk_path_priority_type_get_type()), F: marshalPathPriorityType},
      {T: externglib.Type(C.gtk_path_type_get_type()), F: marshalPathType},
      {T: externglib.Type(C.gtk_policy_type_get_type()), F: marshalPolicyType},
      {T: externglib.Type(C.gtk_popover_constraint_get_type()), F: marshalPopoverConstraint},
      {T: externglib.Type(C.gtk_position_type_get_type()), F: marshalPositionType},
      {T: externglib.Type(C.gtk_print_duplex_get_type()), F: marshalPrintDuplex},
      {T: externglib.Type(C.gtk_print_error_get_type()), F: marshalPrintError},
      {T: externglib.Type(C.gtk_print_operation_action_get_type()), F: marshalPrintOperationAction},
      {T: externglib.Type(C.gtk_print_operation_result_get_type()), F: marshalPrintOperationResult},
      {T: externglib.Type(C.gtk_print_pages_get_type()), F: marshalPrintPages},
      {T: externglib.Type(C.gtk_print_quality_get_type()), F: marshalPrintQuality},
      {T: externglib.Type(C.gtk_print_status_get_type()), F: marshalPrintStatus},
      {T: externglib.Type(C.gtk_propagation_phase_get_type()), F: marshalPropagationPhase},
      {T: externglib.Type(C.gtk_rc_token_type_get_type()), F: marshalRCTokenType},
      {T: externglib.Type(C.gtk_recent_chooser_error_get_type()), F: marshalRecentChooserError},
      {T: externglib.Type(C.gtk_recent_manager_error_get_type()), F: marshalRecentManagerError},
      {T: externglib.Type(C.gtk_recent_sort_type_get_type()), F: marshalRecentSortType},
      {T: externglib.Type(C.gtk_relief_style_get_type()), F: marshalReliefStyle},
      {T: externglib.Type(C.gtk_resize_mode_get_type()), F: marshalResizeMode},
      {T: externglib.Type(C.gtk_response_type_get_type()), F: marshalResponseType},
      {T: externglib.Type(C.gtk_revealer_transition_type_get_type()), F: marshalRevealerTransitionType},
      {T: externglib.Type(C.gtk_scroll_step_get_type()), F: marshalScrollStep},
      {T: externglib.Type(C.gtk_scroll_type_get_type()), F: marshalScrollType},
      {T: externglib.Type(C.gtk_scrollable_policy_get_type()), F: marshalScrollablePolicy},
      {T: externglib.Type(C.gtk_selection_mode_get_type()), F: marshalSelectionMode},
      {T: externglib.Type(C.gtk_sensitivity_type_get_type()), F: marshalSensitivityType},
      {T: externglib.Type(C.gtk_shadow_type_get_type()), F: marshalShadowType},
      {T: externglib.Type(C.gtk_shortcut_type_get_type()), F: marshalShortcutType},
      {T: externglib.Type(C.gtk_size_group_mode_get_type()), F: marshalSizeGroupMode},
      {T: externglib.Type(C.gtk_size_request_mode_get_type()), F: marshalSizeRequestMode},
      {T: externglib.Type(C.gtk_sort_type_get_type()), F: marshalSortType},
      {T: externglib.Type(C.gtk_spin_button_update_policy_get_type()), F: marshalSpinButtonUpdatePolicy},
      {T: externglib.Type(C.gtk_spin_type_get_type()), F: marshalSpinType},
      {T: externglib.Type(C.gtk_stack_transition_type_get_type()), F: marshalStackTransitionType},
      {T: externglib.Type(C.gtk_state_type_get_type()), F: marshalStateType},
      {T: externglib.Type(C.gtk_text_buffer_target_info_get_type()), F: marshalTextBufferTargetInfo},
      {T: externglib.Type(C.gtk_text_direction_get_type()), F: marshalTextDirection},
      {T: externglib.Type(C.gtk_text_extend_selection_get_type()), F: marshalTextExtendSelection},
      {T: externglib.Type(C.gtk_text_view_layer_get_type()), F: marshalTextViewLayer},
      {T: externglib.Type(C.gtk_text_window_type_get_type()), F: marshalTextWindowType},
      {T: externglib.Type(C.gtk_toolbar_space_style_get_type()), F: marshalToolbarSpaceStyle},
      {T: externglib.Type(C.gtk_toolbar_style_get_type()), F: marshalToolbarStyle},
      {T: externglib.Type(C.gtk_tree_view_column_sizing_get_type()), F: marshalTreeViewColumnSizing},
      {T: externglib.Type(C.gtk_tree_view_drop_position_get_type()), F: marshalTreeViewDropPosition},
      {T: externglib.Type(C.gtk_tree_view_grid_lines_get_type()), F: marshalTreeViewGridLines},
      {T: externglib.Type(C.gtk_unit_get_type()), F: marshalUnit},
      {T: externglib.Type(C.gtk_widget_help_type_get_type()), F: marshalWidgetHelpType},
      {T: externglib.Type(C.gtk_window_position_get_type()), F: marshalWindowPosition},
      {T: externglib.Type(C.gtk_window_type_get_type()), F: marshalWindowType},
      {T: externglib.Type(C.gtk_wrap_mode_get_type()), F: marshalWrapMode},
      {T: externglib.Type(C.gtk_accel_flags_get_type()), F: marshalAccelFlags},
      {T: externglib.Type(C.gtk_application_inhibit_flags_get_type()), F: marshalApplicationInhibitFlags},
      {T: externglib.Type(C.gtk_attach_options_get_type()), F: marshalAttachOptions},
      {T: externglib.Type(C.gtk_calendar_display_options_get_type()), F: marshalCalendarDisplayOptions},
      {T: externglib.Type(C.gtk_cell_renderer_state_get_type()), F: marshalCellRendererState},
      {T: externglib.Type(C.gtk_debug_flag_get_type()), F: marshalDebugFlag},
      {T: externglib.Type(C.gtk_dest_defaults_get_type()), F: marshalDestDefaults},
      {T: externglib.Type(C.gtk_dialog_flags_get_type()), F: marshalDialogFlags},
      {T: externglib.Type(C.gtk_event_controller_scroll_flags_get_type()), F: marshalEventControllerScrollFlags},
      {T: externglib.Type(C.gtk_file_filter_flags_get_type()), F: marshalFileFilterFlags},
      {T: externglib.Type(C.gtk_font_chooser_level_get_type()), F: marshalFontChooserLevel},
      {T: externglib.Type(C.gtk_icon_lookup_flags_get_type()), F: marshalIconLookupFlags},
      {T: externglib.Type(C.gtk_input_hints_get_type()), F: marshalInputHints},
      {T: externglib.Type(C.gtk_junction_sides_get_type()), F: marshalJunctionSides},
      {T: externglib.Type(C.gtk_places_open_flags_get_type()), F: marshalPlacesOpenFlags},
      {T: externglib.Type(C.gtk_rc_flags_get_type()), F: marshalRCFlags},
      {T: externglib.Type(C.gtk_recent_filter_flags_get_type()), F: marshalRecentFilterFlags},
      {T: externglib.Type(C.gtk_region_flags_get_type()), F: marshalRegionFlags},
      {T: externglib.Type(C.gtk_state_flags_get_type()), F: marshalStateFlags},
      {T: externglib.Type(C.gtk_style_context_print_flags_get_type()), F: marshalStyleContextPrintFlags},
      {T: externglib.Type(C.gtk_target_flags_get_type()), F: marshalTargetFlags},
      {T: externglib.Type(C.gtk_text_search_flags_get_type()), F: marshalTextSearchFlags},
      {T: externglib.Type(C.gtk_tool_palette_drag_targets_get_type()), F: marshalToolPaletteDragTargets},
      {T: externglib.Type(C.gtk_tree_model_flags_get_type()), F: marshalTreeModelFlags},
      {T: externglib.Type(C.gtk_ui_manager_item_type_get_type()), F: marshalUIManagerItemType},
      {T: externglib.Type(C.gtk_actionable_get_type()), F: marshalActionable},
      {T: externglib.Type(C.gtk_activatable_get_type()), F: marshalActivatable},
      {T: externglib.Type(C.gtk_app_chooser_get_type()), F: marshalAppChooser},
      {T: externglib.Type(C.gtk_buildable_get_type()), F: marshalBuildable},
      {T: externglib.Type(C.gtk_cell_accessible_parent_get_type()), F: marshalCellAccessibleParent},
      {T: externglib.Type(C.gtk_cell_editable_get_type()), F: marshalCellEditable},
      {T: externglib.Type(C.gtk_cell_layout_get_type()), F: marshalCellLayout},
      {T: externglib.Type(C.gtk_color_chooser_get_type()), F: marshalColorChooser},
      {T: externglib.Type(C.gtk_editable_get_type()), F: marshalEditable},
      {T: externglib.Type(C.gtk_file_chooser_get_type()), F: marshalFileChooser},
      {T: externglib.Type(C.gtk_font_chooser_get_type()), F: marshalFontChooser},
      {T: externglib.Type(C.gtk_orientable_get_type()), F: marshalOrientable},
      {T: externglib.Type(C.gtk_print_operation_preview_get_type()), F: marshalPrintOperationPreview},
      {T: externglib.Type(C.gtk_recent_chooser_get_type()), F: marshalRecentChooser},
      {T: externglib.Type(C.gtk_scrollable_get_type()), F: marshalScrollable},
      {T: externglib.Type(C.gtk_style_provider_get_type()), F: marshalStyleProvider},
      {T: externglib.Type(C.gtk_tool_shell_get_type()), F: marshalToolShell},
      {T: externglib.Type(C.gtk_tree_drag_dest_get_type()), F: marshalTreeDragDest},
      {T: externglib.Type(C.gtk_tree_drag_source_get_type()), F: marshalTreeDragSource},
      {T: externglib.Type(C.gtk_tree_model_get_type()), F: marshalTreeModel},
      {T: externglib.Type(C.gtk_tree_sortable_get_type()), F: marshalTreeSortable},
      {T: externglib.Type(C.gtk_about_dialog_get_type()), F: marshalAboutDialog},
      {T: externglib.Type(C.gtk_accel_group_get_type()), F: marshalAccelGroup},
      {T: externglib.Type(C.gtk_accel_label_get_type()), F: marshalAccelLabel},
      {T: externglib.Type(C.gtk_accel_map_get_type()), F: marshalAccelMap},
      {T: externglib.Type(C.gtk_action_get_type()), F: marshalAction},
      {T: externglib.Type(C.gtk_action_bar_get_type()), F: marshalActionBar},
      {T: externglib.Type(C.gtk_action_group_get_type()), F: marshalActionGroup},
      {T: externglib.Type(C.gtk_adjustment_get_type()), F: marshalAdjustment},
      {T: externglib.Type(C.gtk_alignment_get_type()), F: marshalAlignment},
      {T: externglib.Type(C.gtk_app_chooser_button_get_type()), F: marshalAppChooserButton},
      {T: externglib.Type(C.gtk_app_chooser_dialog_get_type()), F: marshalAppChooserDialog},
      {T: externglib.Type(C.gtk_app_chooser_widget_get_type()), F: marshalAppChooserWidget},
      {T: externglib.Type(C.gtk_application_get_type()), F: marshalApplication},
      {T: externglib.Type(C.gtk_application_window_get_type()), F: marshalApplicationWindow},
      {T: externglib.Type(C.gtk_arrow_get_type()), F: marshalArrow},
      {T: externglib.Type(C.gtk_aspect_frame_get_type()), F: marshalAspectFrame},
      {T: externglib.Type(C.gtk_assistant_get_type()), F: marshalAssistant},
      {T: externglib.Type(C.gtk_bin_get_type()), F: marshalBin},
      {T: externglib.Type(C.gtk_box_get_type()), F: marshalBox},
      {T: externglib.Type(C.gtk_builder_get_type()), F: marshalBuilder},
      {T: externglib.Type(C.gtk_button_get_type()), F: marshalButton},
      {T: externglib.Type(C.gtk_button_box_get_type()), F: marshalButtonBox},
      {T: externglib.Type(C.gtk_calendar_get_type()), F: marshalCalendar},
      {T: externglib.Type(C.gtk_cell_area_get_type()), F: marshalCellArea},
      {T: externglib.Type(C.gtk_cell_area_box_get_type()), F: marshalCellAreaBox},
      {T: externglib.Type(C.gtk_cell_area_context_get_type()), F: marshalCellAreaContext},
      {T: externglib.Type(C.gtk_cell_renderer_get_type()), F: marshalCellRenderer},
      {T: externglib.Type(C.gtk_cell_renderer_accel_get_type()), F: marshalCellRendererAccel},
      {T: externglib.Type(C.gtk_cell_renderer_combo_get_type()), F: marshalCellRendererCombo},
      {T: externglib.Type(C.gtk_cell_renderer_pixbuf_get_type()), F: marshalCellRendererPixbuf},
      {T: externglib.Type(C.gtk_cell_renderer_progress_get_type()), F: marshalCellRendererProgress},
      {T: externglib.Type(C.gtk_cell_renderer_spin_get_type()), F: marshalCellRendererSpin},
      {T: externglib.Type(C.gtk_cell_renderer_spinner_get_type()), F: marshalCellRendererSpinner},
      {T: externglib.Type(C.gtk_cell_renderer_text_get_type()), F: marshalCellRendererText},
      {T: externglib.Type(C.gtk_cell_renderer_toggle_get_type()), F: marshalCellRendererToggle},
      {T: externglib.Type(C.gtk_cell_view_get_type()), F: marshalCellView},
      {T: externglib.Type(C.gtk_check_button_get_type()), F: marshalCheckButton},
      {T: externglib.Type(C.gtk_check_menu_item_get_type()), F: marshalCheckMenuItem},
      {T: externglib.Type(C.gtk_clipboard_get_type()), F: marshalClipboard},
      {T: externglib.Type(C.gtk_color_button_get_type()), F: marshalColorButton},
      {T: externglib.Type(C.gtk_color_chooser_dialog_get_type()), F: marshalColorChooserDialog},
      {T: externglib.Type(C.gtk_color_chooser_widget_get_type()), F: marshalColorChooserWidget},
      {T: externglib.Type(C.gtk_color_selection_get_type()), F: marshalColorSelection},
      {T: externglib.Type(C.gtk_color_selection_dialog_get_type()), F: marshalColorSelectionDialog},
      {T: externglib.Type(C.gtk_combo_box_get_type()), F: marshalComboBox},
      {T: externglib.Type(C.gtk_combo_box_text_get_type()), F: marshalComboBoxText},
      {T: externglib.Type(C.gtk_container_get_type()), F: marshalContainer},
      {T: externglib.Type(C.gtk_css_provider_get_type()), F: marshalCSSProvider},
      {T: externglib.Type(C.gtk_dialog_get_type()), F: marshalDialog},
      {T: externglib.Type(C.gtk_drawing_area_get_type()), F: marshalDrawingArea},
      {T: externglib.Type(C.gtk_entry_get_type()), F: marshalEntry},
      {T: externglib.Type(C.gtk_entry_buffer_get_type()), F: marshalEntryBuffer},
      {T: externglib.Type(C.gtk_entry_completion_get_type()), F: marshalEntryCompletion},
      {T: externglib.Type(C.gtk_event_box_get_type()), F: marshalEventBox},
      {T: externglib.Type(C.gtk_event_controller_get_type()), F: marshalEventController},
      {T: externglib.Type(C.gtk_event_controller_key_get_type()), F: marshalEventControllerKey},
      {T: externglib.Type(C.gtk_event_controller_motion_get_type()), F: marshalEventControllerMotion},
      {T: externglib.Type(C.gtk_event_controller_scroll_get_type()), F: marshalEventControllerScroll},
      {T: externglib.Type(C.gtk_expander_get_type()), F: marshalExpander},
      {T: externglib.Type(C.gtk_file_chooser_button_get_type()), F: marshalFileChooserButton},
      {T: externglib.Type(C.gtk_file_chooser_dialog_get_type()), F: marshalFileChooserDialog},
      {T: externglib.Type(C.gtk_file_chooser_native_get_type()), F: marshalFileChooserNative},
      {T: externglib.Type(C.gtk_file_chooser_widget_get_type()), F: marshalFileChooserWidget},
      {T: externglib.Type(C.gtk_file_filter_get_type()), F: marshalFileFilter},
      {T: externglib.Type(C.gtk_fixed_get_type()), F: marshalFixed},
      {T: externglib.Type(C.gtk_flow_box_get_type()), F: marshalFlowBox},
      {T: externglib.Type(C.gtk_flow_box_child_get_type()), F: marshalFlowBoxChild},
      {T: externglib.Type(C.gtk_font_button_get_type()), F: marshalFontButton},
      {T: externglib.Type(C.gtk_font_chooser_dialog_get_type()), F: marshalFontChooserDialog},
      {T: externglib.Type(C.gtk_font_chooser_widget_get_type()), F: marshalFontChooserWidget},
      {T: externglib.Type(C.gtk_font_selection_get_type()), F: marshalFontSelection},
      {T: externglib.Type(C.gtk_font_selection_dialog_get_type()), F: marshalFontSelectionDialog},
      {T: externglib.Type(C.gtk_frame_get_type()), F: marshalFrame},
      {T: externglib.Type(C.gtk_gl_area_get_type()), F: marshalGLArea},
      {T: externglib.Type(C.gtk_gesture_get_type()), F: marshalGesture},
      {T: externglib.Type(C.gtk_gesture_drag_get_type()), F: marshalGestureDrag},
      {T: externglib.Type(C.gtk_gesture_long_press_get_type()), F: marshalGestureLongPress},
      {T: externglib.Type(C.gtk_gesture_multi_press_get_type()), F: marshalGestureMultiPress},
      {T: externglib.Type(C.gtk_gesture_pan_get_type()), F: marshalGesturePan},
      {T: externglib.Type(C.gtk_gesture_rotate_get_type()), F: marshalGestureRotate},
      {T: externglib.Type(C.gtk_gesture_single_get_type()), F: marshalGestureSingle},
      {T: externglib.Type(C.gtk_gesture_stylus_get_type()), F: marshalGestureStylus},
      {T: externglib.Type(C.gtk_gesture_swipe_get_type()), F: marshalGestureSwipe},
      {T: externglib.Type(C.gtk_gesture_zoom_get_type()), F: marshalGestureZoom},
      {T: externglib.Type(C.gtk_grid_get_type()), F: marshalGrid},
      {T: externglib.Type(C.gtk_hbox_get_type()), F: marshalHBox},
      {T: externglib.Type(C.gtk_hbutton_box_get_type()), F: marshalHButtonBox},
      {T: externglib.Type(C.gtk_hpaned_get_type()), F: marshalHPaned},
      {T: externglib.Type(C.gtk_hsv_get_type()), F: marshalHSV},
      {T: externglib.Type(C.gtk_hscale_get_type()), F: marshalHScale},
      {T: externglib.Type(C.gtk_hscrollbar_get_type()), F: marshalHScrollbar},
      {T: externglib.Type(C.gtk_hseparator_get_type()), F: marshalHSeparator},
      {T: externglib.Type(C.gtk_handle_box_get_type()), F: marshalHandleBox},
      {T: externglib.Type(C.gtk_header_bar_get_type()), F: marshalHeaderBar},
      {T: externglib.Type(C.gtk_im_context_get_type()), F: marshalIMContext},
      {T: externglib.Type(C.gtk_im_context_simple_get_type()), F: marshalIMContextSimple},
      {T: externglib.Type(C.gtk_im_multicontext_get_type()), F: marshalIMMulticontext},
      {T: externglib.Type(C.gtk_icon_factory_get_type()), F: marshalIconFactory},
      {T: externglib.Type(C.gtk_icon_info_get_type()), F: marshalIconInfo},
      {T: externglib.Type(C.gtk_icon_theme_get_type()), F: marshalIconTheme},
      {T: externglib.Type(C.gtk_icon_view_get_type()), F: marshalIconView},
      {T: externglib.Type(C.gtk_image_get_type()), F: marshalImage},
      {T: externglib.Type(C.gtk_image_menu_item_get_type()), F: marshalImageMenuItem},
      {T: externglib.Type(C.gtk_info_bar_get_type()), F: marshalInfoBar},
      {T: externglib.Type(C.gtk_invisible_get_type()), F: marshalInvisible},
      {T: externglib.Type(C.gtk_label_get_type()), F: marshalLabel},
      {T: externglib.Type(C.gtk_layout_get_type()), F: marshalLayout},
      {T: externglib.Type(C.gtk_level_bar_get_type()), F: marshalLevelBar},
      {T: externglib.Type(C.gtk_link_button_get_type()), F: marshalLinkButton},
      {T: externglib.Type(C.gtk_list_box_get_type()), F: marshalListBox},
      {T: externglib.Type(C.gtk_list_box_row_get_type()), F: marshalListBoxRow},
      {T: externglib.Type(C.gtk_list_store_get_type()), F: marshalListStore},
      {T: externglib.Type(C.gtk_lock_button_get_type()), F: marshalLockButton},
      {T: externglib.Type(C.gtk_menu_get_type()), F: marshalMenu},
      {T: externglib.Type(C.gtk_menu_bar_get_type()), F: marshalMenuBar},
      {T: externglib.Type(C.gtk_menu_button_get_type()), F: marshalMenuButton},
      {T: externglib.Type(C.gtk_menu_item_get_type()), F: marshalMenuItem},
      {T: externglib.Type(C.gtk_menu_shell_get_type()), F: marshalMenuShell},
      {T: externglib.Type(C.gtk_menu_tool_button_get_type()), F: marshalMenuToolButton},
      {T: externglib.Type(C.gtk_message_dialog_get_type()), F: marshalMessageDialog},
      {T: externglib.Type(C.gtk_misc_get_type()), F: marshalMisc},
      {T: externglib.Type(C.gtk_model_button_get_type()), F: marshalModelButton},
      {T: externglib.Type(C.gtk_mount_operation_get_type()), F: marshalMountOperation},
      {T: externglib.Type(C.gtk_native_dialog_get_type()), F: marshalNativeDialog},
      {T: externglib.Type(C.gtk_notebook_get_type()), F: marshalNotebook},
      {T: externglib.Type(C.gtk_numerable_icon_get_type()), F: marshalNumerableIcon},
      {T: externglib.Type(C.gtk_offscreen_window_get_type()), F: marshalOffscreenWindow},
      {T: externglib.Type(C.gtk_overlay_get_type()), F: marshalOverlay},
      {T: externglib.Type(C.gtk_pad_controller_get_type()), F: marshalPadController},
      {T: externglib.Type(C.gtk_page_setup_get_type()), F: marshalPageSetup},
      {T: externglib.Type(C.gtk_paned_get_type()), F: marshalPaned},
      {T: externglib.Type(C.gtk_places_sidebar_get_type()), F: marshalPlacesSidebar},
      {T: externglib.Type(C.gtk_plug_get_type()), F: marshalPlug},
      {T: externglib.Type(C.gtk_popover_get_type()), F: marshalPopover},
      {T: externglib.Type(C.gtk_popover_menu_get_type()), F: marshalPopoverMenu},
      {T: externglib.Type(C.gtk_print_context_get_type()), F: marshalPrintContext},
      {T: externglib.Type(C.gtk_print_operation_get_type()), F: marshalPrintOperation},
      {T: externglib.Type(C.gtk_print_settings_get_type()), F: marshalPrintSettings},
      {T: externglib.Type(C.gtk_progress_bar_get_type()), F: marshalProgressBar},
      {T: externglib.Type(C.gtk_radio_action_get_type()), F: marshalRadioAction},
      {T: externglib.Type(C.gtk_radio_button_get_type()), F: marshalRadioButton},
      {T: externglib.Type(C.gtk_radio_menu_item_get_type()), F: marshalRadioMenuItem},
      {T: externglib.Type(C.gtk_radio_tool_button_get_type()), F: marshalRadioToolButton},
      {T: externglib.Type(C.gtk_range_get_type()), F: marshalRange},
      {T: externglib.Type(C.gtk_rc_style_get_type()), F: marshalRCStyle},
      {T: externglib.Type(C.gtk_recent_action_get_type()), F: marshalRecentAction},
      {T: externglib.Type(C.gtk_recent_chooser_dialog_get_type()), F: marshalRecentChooserDialog},
      {T: externglib.Type(C.gtk_recent_chooser_menu_get_type()), F: marshalRecentChooserMenu},
      {T: externglib.Type(C.gtk_recent_chooser_widget_get_type()), F: marshalRecentChooserWidget},
      {T: externglib.Type(C.gtk_recent_filter_get_type()), F: marshalRecentFilter},
      {T: externglib.Type(C.gtk_recent_manager_get_type()), F: marshalRecentManager},
      {T: externglib.Type(C.gtk_revealer_get_type()), F: marshalRevealer},
      {T: externglib.Type(C.gtk_scale_get_type()), F: marshalScale},
      {T: externglib.Type(C.gtk_scale_button_get_type()), F: marshalScaleButton},
      {T: externglib.Type(C.gtk_scrollbar_get_type()), F: marshalScrollbar},
      {T: externglib.Type(C.gtk_scrolled_window_get_type()), F: marshalScrolledWindow},
      {T: externglib.Type(C.gtk_search_bar_get_type()), F: marshalSearchBar},
      {T: externglib.Type(C.gtk_search_entry_get_type()), F: marshalSearchEntry},
      {T: externglib.Type(C.gtk_separator_get_type()), F: marshalSeparator},
      {T: externglib.Type(C.gtk_separator_menu_item_get_type()), F: marshalSeparatorMenuItem},
      {T: externglib.Type(C.gtk_separator_tool_item_get_type()), F: marshalSeparatorToolItem},
      {T: externglib.Type(C.gtk_settings_get_type()), F: marshalSettings},
      {T: externglib.Type(C.gtk_shortcut_label_get_type()), F: marshalShortcutLabel},
      {T: externglib.Type(C.gtk_shortcuts_group_get_type()), F: marshalShortcutsGroup},
      {T: externglib.Type(C.gtk_shortcuts_section_get_type()), F: marshalShortcutsSection},
      {T: externglib.Type(C.gtk_shortcuts_shortcut_get_type()), F: marshalShortcutsShortcut},
      {T: externglib.Type(C.gtk_shortcuts_window_get_type()), F: marshalShortcutsWindow},
      {T: externglib.Type(C.gtk_size_group_get_type()), F: marshalSizeGroup},
      {T: externglib.Type(C.gtk_socket_get_type()), F: marshalSocket},
      {T: externglib.Type(C.gtk_spin_button_get_type()), F: marshalSpinButton},
      {T: externglib.Type(C.gtk_spinner_get_type()), F: marshalSpinner},
      {T: externglib.Type(C.gtk_stack_get_type()), F: marshalStack},
      {T: externglib.Type(C.gtk_stack_sidebar_get_type()), F: marshalStackSidebar},
      {T: externglib.Type(C.gtk_stack_switcher_get_type()), F: marshalStackSwitcher},
      {T: externglib.Type(C.gtk_status_icon_get_type()), F: marshalStatusIcon},
      {T: externglib.Type(C.gtk_statusbar_get_type()), F: marshalStatusbar},
      {T: externglib.Type(C.gtk_style_get_type()), F: marshalStyle},
      {T: externglib.Type(C.gtk_style_context_get_type()), F: marshalStyleContext},
      {T: externglib.Type(C.gtk_style_properties_get_type()), F: marshalStyleProperties},
      {T: externglib.Type(C.gtk_switch_get_type()), F: marshalSwitch},
      {T: externglib.Type(C.gtk_table_get_type()), F: marshalTable},
      {T: externglib.Type(C.gtk_tearoff_menu_item_get_type()), F: marshalTearoffMenuItem},
      {T: externglib.Type(C.gtk_text_buffer_get_type()), F: marshalTextBuffer},
      {T: externglib.Type(C.gtk_text_child_anchor_get_type()), F: marshalTextChildAnchor},
      {T: externglib.Type(C.gtk_text_mark_get_type()), F: marshalTextMark},
      {T: externglib.Type(C.gtk_text_tag_get_type()), F: marshalTextTag},
      {T: externglib.Type(C.gtk_text_tag_table_get_type()), F: marshalTextTagTable},
      {T: externglib.Type(C.gtk_text_view_get_type()), F: marshalTextView},
      {T: externglib.Type(C.gtk_theming_engine_get_type()), F: marshalThemingEngine},
      {T: externglib.Type(C.gtk_toggle_action_get_type()), F: marshalToggleAction},
      {T: externglib.Type(C.gtk_toggle_button_get_type()), F: marshalToggleButton},
      {T: externglib.Type(C.gtk_toggle_tool_button_get_type()), F: marshalToggleToolButton},
      {T: externglib.Type(C.gtk_tool_button_get_type()), F: marshalToolButton},
      {T: externglib.Type(C.gtk_tool_item_get_type()), F: marshalToolItem},
      {T: externglib.Type(C.gtk_tool_item_group_get_type()), F: marshalToolItemGroup},
      {T: externglib.Type(C.gtk_tool_palette_get_type()), F: marshalToolPalette},
      {T: externglib.Type(C.gtk_toolbar_get_type()), F: marshalToolbar},
      {T: externglib.Type(C.gtk_tooltip_get_type()), F: marshalTooltip},
      {T: externglib.Type(C.gtk_tree_model_filter_get_type()), F: marshalTreeModelFilter},
      {T: externglib.Type(C.gtk_tree_model_sort_get_type()), F: marshalTreeModelSort},
      {T: externglib.Type(C.gtk_tree_selection_get_type()), F: marshalTreeSelection},
      {T: externglib.Type(C.gtk_tree_store_get_type()), F: marshalTreeStore},
      {T: externglib.Type(C.gtk_tree_view_get_type()), F: marshalTreeView},
      {T: externglib.Type(C.gtk_tree_view_column_get_type()), F: marshalTreeViewColumn},
      {T: externglib.Type(C.gtk_ui_manager_get_type()), F: marshalUIManager},
      {T: externglib.Type(C.gtk_vbox_get_type()), F: marshalVBox},
      {T: externglib.Type(C.gtk_vbutton_box_get_type()), F: marshalVButtonBox},
      {T: externglib.Type(C.gtk_vpaned_get_type()), F: marshalVPaned},
      {T: externglib.Type(C.gtk_vscale_get_type()), F: marshalVScale},
      {T: externglib.Type(C.gtk_vscrollbar_get_type()), F: marshalVScrollbar},
      {T: externglib.Type(C.gtk_vseparator_get_type()), F: marshalVSeparator},
      {T: externglib.Type(C.gtk_viewport_get_type()), F: marshalViewport},
      {T: externglib.Type(C.gtk_volume_button_get_type()), F: marshalVolumeButton},
      {T: externglib.Type(C.gtk_widget_get_type()), F: marshalWidget},
      {T: externglib.Type(C.gtk_window_get_type()), F: marshalWindow},
      {T: externglib.Type(C.gtk_window_group_get_type()), F: marshalWindowGroup},
      {T: externglib.Type(C.gtk_border_get_type()), F: marshalBorder},
      {T: externglib.Type(C.gtk_css_section_get_type()), F: marshalCSSSection},
      {T: externglib.Type(C.gtk_gradient_get_type()), F: marshalGradient},
      {T: externglib.Type(C.gtk_icon_set_get_type()), F: marshalIconSet},
      {T: externglib.Type(C.gtk_icon_source_get_type()), F: marshalIconSource},
      {T: externglib.Type(C.gtk_paper_size_get_type()), F: marshalPaperSize},
      {T: externglib.Type(C.gtk_recent_info_get_type()), F: marshalRecentInfo},
      {T: externglib.Type(C.gtk_requisition_get_type()), F: marshalRequisition},
      {T: externglib.Type(C.gtk_selection_data_get_type()), F: marshalSelectionData},
      {T: externglib.Type(C.gtk_symbolic_color_get_type()), F: marshalSymbolicColor},
      {T: externglib.Type(C.gtk_target_entry_get_type()), F: marshalTargetEntry},
      {T: externglib.Type(C.gtk_target_list_get_type()), F: marshalTargetList},
      {T: externglib.Type(C.gtk_text_attributes_get_type()), F: marshalTextAttributes},
      {T: externglib.Type(C.gtk_text_iter_get_type()), F: marshalTextIter},
      {T: externglib.Type(C.gtk_tree_iter_get_type()), F: marshalTreeIter},
      {T: externglib.Type(C.gtk_tree_path_get_type()), F: marshalTreePath},
      {T: externglib.Type(C.gtk_tree_row_reference_get_type()), F: marshalTreeRowReference},
      {T: externglib.Type(C.gtk_widget_path_get_type()), F: marshalWidgetPath},
  })
}


	
	// Allocation: a Allocation-struct of a widget represents region which has been
// allocated to the widget by its parent. It is a subregion of its parents
// allocation. See [GtkWidget’s geometry management
// section][geometry-management] for more information.
	type Allocation = gdk.Rectangle


	
	
	type Stock = string


	

	// Align controls how a widget deals with extra space in a single (x or y)
// dimension.
// 
// Alignment only matters if the widget receives a “too large” allocation, for
// example if you packed the widget with the Widget:expand flag inside a Box,
// then the widget might get extra space. If you have for example a 16x16 icon
// inside a 32x32 space, the icon could be scaled and stretched, it could be
// centered, or it could be positioned to one side of the space.
// 
// Note that in horizontal context @GTK_ALIGN_START and @GTK_ALIGN_END are
// interpreted relative to text direction.
// 
// GTK_ALIGN_BASELINE support for it is optional for containers and widgets, and
// it is only supported for vertical alignment. When its not supported by a
// child or a container it is treated as @GTK_ALIGN_FILL.
	type Align int

	const (
			// AlignFill: stretch to fill all space if possible, center if no meaningful
	// way to stretch
		AlignFill Align = 0
			// AlignStart: snap to left or top side, leaving space on right or bottom
		AlignStart Align = 1
			// AlignEnd: snap to right or bottom side, leaving space on left or top
		AlignEnd Align = 2
			// AlignCenter: center natural width of widget inside the allocation
		AlignCenter Align = 3
			// AlignBaseline: align the widget according to the baseline. Since 3.10.
		AlignBaseline Align = 4
		)

	
	func marshalAlign(p uintptr) (interface{}, error) {
		return Align(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// ArrowPlacement: used to specify the placement of scroll arrows in scrolling
// menus.
	type ArrowPlacement int

	const (
			// ArrowPlacementBoth: place one arrow on each end of the menu.
		ArrowPlacementBoth ArrowPlacement = 0
			// ArrowPlacementStart: place both arrows at the top of the menu.
		ArrowPlacementStart ArrowPlacement = 1
			// ArrowPlacementEnd: place both arrows at the bottom of the menu.
		ArrowPlacementEnd ArrowPlacement = 2
		)

	
	func marshalArrowPlacement(p uintptr) (interface{}, error) {
		return ArrowPlacement(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// ArrowType: used to indicate the direction in which an arrow should point.
	type ArrowType int

	const (
			// ArrowTypeUp represents an upward pointing arrow.
		ArrowTypeUp ArrowType = 0
			// ArrowTypeDown represents a downward pointing arrow.
		ArrowTypeDown ArrowType = 1
			// ArrowTypeLeft represents a left pointing arrow.
		ArrowTypeLeft ArrowType = 2
			// ArrowTypeRight represents a right pointing arrow.
		ArrowTypeRight ArrowType = 3
			// ArrowTypeNone: no arrow. Since 2.10.
		ArrowTypeNone ArrowType = 4
		)

	
	func marshalArrowType(p uintptr) (interface{}, error) {
		return ArrowType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// AssistantPageType: an enum for determining the page role inside the
// Assistant. It's used to handle buttons sensitivity and visibility.
// 
// Note that an assistant needs to end its page flow with a page of type
// GTK_ASSISTANT_PAGE_CONFIRM, GTK_ASSISTANT_PAGE_SUMMARY or
// GTK_ASSISTANT_PAGE_PROGRESS to be correct.
// 
// The Cancel button will only be shown if the page isn’t “committed”. See
// gtk_assistant_commit() for details.
	type AssistantPageType int

	const (
			// AssistantPageTypeContent: the page has regular contents. Both the Back
	// and forward buttons will be shown.
		AssistantPageTypeContent AssistantPageType = 0
			// AssistantPageTypeIntro: the page contains an introduction to the
	// assistant task. Only the Forward button will be shown if there is a next
	// page.
		AssistantPageTypeIntro AssistantPageType = 1
			// AssistantPageTypeConfirm: the page lets the user confirm or deny the
	// changes. The Back and Apply buttons will be shown.
		AssistantPageTypeConfirm AssistantPageType = 2
			// AssistantPageTypeSummary: the page informs the user of the changes done.
	// Only the Close button will be shown.
		AssistantPageTypeSummary AssistantPageType = 3
			// AssistantPageTypeProgress: used for tasks that take a long time to
	// complete, blocks the assistant until the page is marked as complete. Only
	// the back button will be shown.
		AssistantPageTypeProgress AssistantPageType = 4
			// AssistantPageTypeCustom: used for when other page types are not
	// appropriate. No buttons will be shown, and the application must add its
	// own buttons through gtk_assistant_add_action_widget().
		AssistantPageTypeCustom AssistantPageType = 5
		)

	
	func marshalAssistantPageType(p uintptr) (interface{}, error) {
		return AssistantPageType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// BaselinePosition: whenever a container has some form of natural row it may
// align children in that row along a common typographical baseline. If the
// amount of verical space in the row is taller than the total requested height
// of the baseline-aligned children then it can use a BaselinePosition to select
// where to put the baseline inside the extra availible space.
	type BaselinePosition int

	const (
			// BaselinePositionTop: align the baseline at the top
		BaselinePositionTop BaselinePosition = 0
			// BaselinePositionCenter: center the baseline
		BaselinePositionCenter BaselinePosition = 1
			// BaselinePositionBottom: align the baseline at the bottom
		BaselinePositionBottom BaselinePosition = 2
		)

	
	func marshalBaselinePosition(p uintptr) (interface{}, error) {
		return BaselinePosition(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// BorderStyle describes how the border of a UI element should be rendered.
	type BorderStyle int

	const (
			// BorderStyleNone: no visible border
		BorderStyleNone BorderStyle = 0
			// BorderStyleSolid: a single line segment
		BorderStyleSolid BorderStyle = 1
			// BorderStyleInset looks as if the content is sunken into the canvas
		BorderStyleInset BorderStyle = 2
			// BorderStyleOutset looks as if the content is coming out of the canvas
		BorderStyleOutset BorderStyle = 3
			// BorderStyleHidden: same as @GTK_BORDER_STYLE_NONE
		BorderStyleHidden BorderStyle = 4
			// BorderStyleDotted: a series of round dots
		BorderStyleDotted BorderStyle = 5
			// BorderStyleDashed: a series of square-ended dashes
		BorderStyleDashed BorderStyle = 6
			// BorderStyleDouble: two parallel lines with some space between them
		BorderStyleDouble BorderStyle = 7
			// BorderStyleGroove looks as if it were carved in the canvas
		BorderStyleGroove BorderStyle = 8
			// BorderStyleRidge looks as if it were coming out of the canvas
		BorderStyleRidge BorderStyle = 9
		)

	
	func marshalBorderStyle(p uintptr) (interface{}, error) {
		return BorderStyle(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// BuilderError: error codes that identify various errors that can occur while
// using Builder.
	type BuilderError int

	const (
			// BuilderErrorInvalidTypeFunction: a type-func attribute didn’t name a
	// function that returns a #GType.
		BuilderErrorInvalidTypeFunction BuilderError = 0
			// BuilderErrorUnhandledTag: the input contained a tag that Builder can’t
	// handle.
		BuilderErrorUnhandledTag BuilderError = 1
			// BuilderErrorMissingAttribute: an attribute that is required by Builder
	// was missing.
		BuilderErrorMissingAttribute BuilderError = 2
			// BuilderErrorInvalidAttribute: Builder found an attribute that it doesn’t
	// understand.
		BuilderErrorInvalidAttribute BuilderError = 3
			// BuilderErrorInvalidTag: Builder found a tag that it doesn’t understand.
		BuilderErrorInvalidTag BuilderError = 4
			// BuilderErrorMissingPropertyValue: a required property value was missing.
		BuilderErrorMissingPropertyValue BuilderError = 5
			// BuilderErrorInvalidValue: Builder couldn’t parse some attribute value.
		BuilderErrorInvalidValue BuilderError = 6
			// BuilderErrorVersionMismatch: the input file requires a newer version of
	// GTK+.
		BuilderErrorVersionMismatch BuilderError = 7
			// BuilderErrorDuplicateID: an object id occurred twice.
		BuilderErrorDuplicateID BuilderError = 8
			// BuilderErrorObjectTypeRefused: a specified object type is of the same
	// type or derived from the type of the composite class being extended with
	// builder XML.
		BuilderErrorObjectTypeRefused BuilderError = 9
			// BuilderErrorTemplateMismatch: the wrong type was specified in a composite
	// class’s template XML
		BuilderErrorTemplateMismatch BuilderError = 10
			// BuilderErrorInvalidProperty: the specified property is unknown for the
	// object class.
		BuilderErrorInvalidProperty BuilderError = 11
			// BuilderErrorInvalidSignal: the specified signal is unknown for the object
	// class.
		BuilderErrorInvalidSignal BuilderError = 12
			// BuilderErrorInvalidID: an object id is unknown
		BuilderErrorInvalidID BuilderError = 13
		)

	
	func marshalBuilderError(p uintptr) (interface{}, error) {
		return BuilderError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// ButtonBoxStyle: used to dictate the style that a ButtonBox uses to layout the
// buttons it contains.
	type ButtonBoxStyle int

	const (
			// ButtonBoxStyleSpread buttons are evenly spread across the box.
		ButtonBoxStyleSpread ButtonBoxStyle = 1
			// ButtonBoxStyleEdge buttons are placed at the edges of the box.
		ButtonBoxStyleEdge ButtonBoxStyle = 2
			// ButtonBoxStyleStart buttons are grouped towards the start of the box, (on
	// the left for a HBox, or the top for a VBox).
		ButtonBoxStyleStart ButtonBoxStyle = 3
			// ButtonBoxStyleEnd buttons are grouped towards the end of the box, (on the
	// right for a HBox, or the bottom for a VBox).
		ButtonBoxStyleEnd ButtonBoxStyle = 4
			// ButtonBoxStyleCenter buttons are centered in the box. Since 2.12.
		ButtonBoxStyleCenter ButtonBoxStyle = 5
			// ButtonBoxStyleExpand buttons expand to fill the box. This entails giving
	// buttons a "linked" appearance, making button sizes homogeneous, and
	// setting spacing to 0 (same as calling gtk_box_set_homogeneous() and
	// gtk_box_set_spacing() manually). Since 3.12.
		ButtonBoxStyleExpand ButtonBoxStyle = 6
		)

	
	func marshalButtonBoxStyle(p uintptr) (interface{}, error) {
		return ButtonBoxStyle(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// ButtonRole: the role specifies the desired appearance of a ModelButton.
	type ButtonRole int

	const (
			// ButtonRoleNormal: a plain button
		ButtonRoleNormal ButtonRole = 0
			// ButtonRoleCheck: a check button
		ButtonRoleCheck ButtonRole = 1
			// ButtonRoleRadio: a radio button
		ButtonRoleRadio ButtonRole = 2
		)

	
	func marshalButtonRole(p uintptr) (interface{}, error) {
		return ButtonRole(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// ButtonsType: prebuilt sets of buttons for the dialog. If none of these
// choices are appropriate, simply use GTK_BUTTONS_NONE then call
// gtk_dialog_add_buttons().
// 
// > Please note that GTK_BUTTONS_OK, GTK_BUTTONS_YES_NO > and
// GTK_BUTTONS_OK_CANCEL are discouraged by the > GNOME Human Interface
// Guidelines (http://library.gnome.org/devel/hig-book/stable/).
	type ButtonsType int

	const (
			// ButtonsTypeNone: no buttons at all
		ButtonsTypeNone ButtonsType = 0
			// ButtonsTypeOk: an OK button
		ButtonsTypeOk ButtonsType = 1
			// ButtonsTypeClose: a Close button
		ButtonsTypeClose ButtonsType = 2
			// ButtonsTypeCancel: a Cancel button
		ButtonsTypeCancel ButtonsType = 3
			// ButtonsTypeYesNo yes and No buttons
		ButtonsTypeYesNo ButtonsType = 4
			// ButtonsTypeOkCancel: OK and Cancel buttons
		ButtonsTypeOkCancel ButtonsType = 5
		)

	
	func marshalButtonsType(p uintptr) (interface{}, error) {
		return ButtonsType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// CellRendererAccelMode determines if the edited accelerators are GTK+
// accelerators. If they are, consumed modifiers are suppressed, only
// accelerators accepted by GTK+ are allowed, and the accelerators are rendered
// in the same way as they are in menus.
	type CellRendererAccelMode int

	const (
			// CellRendererAccelModeGTK: GTK+ accelerators mode
		CellRendererAccelModeGTK CellRendererAccelMode = 0
			// CellRendererAccelModeOther: other accelerator mode
		CellRendererAccelModeOther CellRendererAccelMode = 1
		)

	
	func marshalCellRendererAccelMode(p uintptr) (interface{}, error) {
		return CellRendererAccelMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// CellRendererMode identifies how the user can interact with a particular cell.
	type CellRendererMode int

	const (
			// CellRendererModeInert: the cell is just for display and cannot be
	// interacted with. Note that this doesn’t mean that eg. the row being drawn
	// can’t be selected -- just that a particular element of it cannot be
	// individually modified.
		CellRendererModeInert CellRendererMode = 0
			// CellRendererModeActivatable: the cell can be clicked.
		CellRendererModeActivatable CellRendererMode = 1
			// CellRendererModeEditable: the cell can be edited or otherwise modified.
		CellRendererModeEditable CellRendererMode = 2
		)

	
	func marshalCellRendererMode(p uintptr) (interface{}, error) {
		return CellRendererMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// CornerType specifies which corner a child widget should be placed in when
// packed into a ScrolledWindow. This is effectively the opposite of where the
// scroll bars are placed.
	type CornerType int

	const (
			// CornerTypeTopLeft: place the scrollbars on the right and bottom of the
	// widget (default behaviour).
		CornerTypeTopLeft CornerType = 0
			// CornerTypeBottomLeft: place the scrollbars on the top and right of the
	// widget.
		CornerTypeBottomLeft CornerType = 1
			// CornerTypeTopRight: place the scrollbars on the left and bottom of the
	// widget.
		CornerTypeTopRight CornerType = 2
			// CornerTypeBottomRight: place the scrollbars on the top and left of the
	// widget.
		CornerTypeBottomRight CornerType = 3
		)

	
	func marshalCornerType(p uintptr) (interface{}, error) {
		return CornerType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// CSSProviderError: error codes for GTK_CSS_PROVIDER_ERROR.
	type CSSProviderError int

	const (
			// CSSProviderErrorFailed: failed.
		CSSProviderErrorFailed CSSProviderError = 0
			// CSSProviderErrorSyntax: syntax error.
		CSSProviderErrorSyntax CSSProviderError = 1
			// CSSProviderErrorImport: import error.
		CSSProviderErrorImport CSSProviderError = 2
			// CSSProviderErrorName: name error.
		CSSProviderErrorName CSSProviderError = 3
			// CSSProviderErrorDeprecated: deprecation error.
		CSSProviderErrorDeprecated CSSProviderError = 4
			// CSSProviderErrorUnknownValue: unknown value.
		CSSProviderErrorUnknownValue CSSProviderError = 5
		)

	
	func marshalCSSProviderError(p uintptr) (interface{}, error) {
		return CSSProviderError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// CSSSectionType: the different types of sections indicate parts of a CSS
// document as parsed by GTK’s CSS parser. They are oriented towards the CSS
// Grammar (http://www.w3.org/TR/CSS21/grammar.html), but may contain
// extensions.
// 
// More types might be added in the future as the parser incorporates more
// features.
	type CSSSectionType int

	const (
			// CSSSectionTypeDocument: the section describes a complete document. This
	// section time is the only one where gtk_css_section_get_parent() might
	// return nil.
		CSSSectionTypeDocument CSSSectionType = 0
			// CSSSectionTypeImport: the section defines an import rule.
		CSSSectionTypeImport CSSSectionType = 1
			// CSSSectionTypeColorDefinition: the section defines a color. This is a GTK
	// extension to CSS.
		CSSSectionTypeColorDefinition CSSSectionType = 2
			// CSSSectionTypeBindingSet: the section defines a binding set. This is a
	// GTK extension to CSS.
		CSSSectionTypeBindingSet CSSSectionType = 3
			// CSSSectionTypeRuleset: the section defines a CSS ruleset.
		CSSSectionTypeRuleset CSSSectionType = 4
			// CSSSectionTypeSelector: the section defines a CSS selector.
		CSSSectionTypeSelector CSSSectionType = 5
			// CSSSectionTypeDeclaration: the section defines the declaration of a CSS
	// variable.
		CSSSectionTypeDeclaration CSSSectionType = 6
			// CSSSectionTypeValue: the section defines the value of a CSS declaration.
		CSSSectionTypeValue CSSSectionType = 7
			// CSSSectionTypeKeyframes: the section defines keyframes. See [CSS
	// Animations](http://dev.w3.org/csswg/css3-animations/#keyframes) for
	// details. Since 3.6
		CSSSectionTypeKeyframes CSSSectionType = 8
		)

	
	func marshalCSSSectionType(p uintptr) (interface{}, error) {
		return CSSSectionType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// DeleteType: see also: Entry::delete-from-cursor.
	type DeleteType int

	const (
			// DeleteTypeChars: delete characters.
		DeleteTypeChars DeleteType = 0
			// DeleteTypeWordEnds: delete only the portion of the word to the left/right
	// of cursor if we’re in the middle of a word.
		DeleteTypeWordEnds DeleteType = 1
			// DeleteTypeWords: delete words.
		DeleteTypeWords DeleteType = 2
			// DeleteTypeDisplayLines: delete display-lines. Display-lines refers to the
	// visible lines, with respect to to the current line breaks. As opposed to
	// paragraphs, which are defined by line breaks in the input.
		DeleteTypeDisplayLines DeleteType = 3
			// DeleteTypeDisplayLineEnds: delete only the portion of the display-line to
	// the left/right of cursor.
		DeleteTypeDisplayLineEnds DeleteType = 4
			// DeleteTypeParagraphEnds: delete to the end of the paragraph. Like C-k in
	// Emacs (or its reverse).
		DeleteTypeParagraphEnds DeleteType = 5
			// DeleteTypeParagraphs: delete entire line. Like C-k in pico.
		DeleteTypeParagraphs DeleteType = 6
			// DeleteTypeWhitespace: delete only whitespace. Like M-\ in Emacs.
		DeleteTypeWhitespace DeleteType = 7
		)

	
	func marshalDeleteType(p uintptr) (interface{}, error) {
		return DeleteType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// DirectionType focus movement types.
	type DirectionType int

	const (
			// DirectionTypeTabForward: move forward.
		DirectionTypeTabForward DirectionType = 0
			// DirectionTypeTabBackward: move backward.
		DirectionTypeTabBackward DirectionType = 1
			// DirectionTypeUp: move up.
		DirectionTypeUp DirectionType = 2
			// DirectionTypeDown: move down.
		DirectionTypeDown DirectionType = 3
			// DirectionTypeLeft: move left.
		DirectionTypeLeft DirectionType = 4
			// DirectionTypeRight: move right.
		DirectionTypeRight DirectionType = 5
		)

	
	func marshalDirectionType(p uintptr) (interface{}, error) {
		return DirectionType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// DragResult gives an indication why a drag operation failed. The value can by
// obtained by connecting to the Widget::drag-failed signal.
	type DragResult int

	const (
			// DragResultSuccess: the drag operation was successful.
		DragResultSuccess DragResult = 0
			// DragResultNoTarget: no suitable drag target.
		DragResultNoTarget DragResult = 1
			// DragResultUserCancelled: the user cancelled the drag operation.
		DragResultUserCancelled DragResult = 2
			// DragResultTimeoutExpired: the drag operation timed out.
		DragResultTimeoutExpired DragResult = 3
			// DragResultGrabBroken: the pointer or keyboard grab used for the drag
	// operation was broken.
		DragResultGrabBroken DragResult = 4
			// DragResultError: the drag operation failed due to some unspecified error.
		DragResultError DragResult = 5
		)

	
	func marshalDragResult(p uintptr) (interface{}, error) {
		return DragResult(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// EntryIconPosition specifies the side of the entry at which an icon is placed.
	type EntryIconPosition int

	const (
			// EntryIconPositionPrimary: at the beginning of the entry (depending on the
	// text direction).
		EntryIconPositionPrimary EntryIconPosition = 0
			// EntryIconPositionSecondary: at the end of the entry (depending on the
	// text direction).
		EntryIconPositionSecondary EntryIconPosition = 1
		)

	
	func marshalEntryIconPosition(p uintptr) (interface{}, error) {
		return EntryIconPosition(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// EventSequenceState describes the state of a EventSequence in a Gesture.
	type EventSequenceState int

	const (
			// EventSequenceStateNone: the sequence is handled, but not grabbed.
		EventSequenceStateNone EventSequenceState = 0
			// EventSequenceStateClaimed: the sequence is handled and grabbed.
		EventSequenceStateClaimed EventSequenceState = 1
			// EventSequenceStateDenied: the sequence is denied.
		EventSequenceStateDenied EventSequenceState = 2
		)

	
	func marshalEventSequenceState(p uintptr) (interface{}, error) {
		return EventSequenceState(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// ExpanderStyle: used to specify the style of the expanders drawn by a
// TreeView.
	type ExpanderStyle int

	const (
			// ExpanderStyleCollapsed: the style used for a collapsed subtree.
		ExpanderStyleCollapsed ExpanderStyle = 0
			// ExpanderStyleSemiCollapsed: intermediate style used during animation.
		ExpanderStyleSemiCollapsed ExpanderStyle = 1
			// ExpanderStyleSemiExpanded: intermediate style used during animation.
		ExpanderStyleSemiExpanded ExpanderStyle = 2
			// ExpanderStyleExpanded: the style used for an expanded subtree.
		ExpanderStyleExpanded ExpanderStyle = 3
		)

	
	func marshalExpanderStyle(p uintptr) (interface{}, error) {
		return ExpanderStyle(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// FileChooserAction describes whether a FileChooser is being used to open
// existing files or to save to a possibly new file.
	type FileChooserAction int

	const (
			// FileChooserActionOpen indicates open mode. The file chooser will only let
	// the user pick an existing file.
		FileChooserActionOpen FileChooserAction = 0
			// FileChooserActionSave indicates save mode. The file chooser will let the
	// user pick an existing file, or type in a new filename.
		FileChooserActionSave FileChooserAction = 1
			// FileChooserActionSelectFolder indicates an Open mode for selecting
	// folders. The file chooser will let the user pick an existing folder.
		FileChooserActionSelectFolder FileChooserAction = 2
			// FileChooserActionCreateFolder indicates a mode for creating a new folder.
	// The file chooser will let the user name an existing or new folder.
		FileChooserActionCreateFolder FileChooserAction = 3
		)

	
	func marshalFileChooserAction(p uintptr) (interface{}, error) {
		return FileChooserAction(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// FileChooserConfirmation: used as a return value of handlers for the
// FileChooser::confirm-overwrite signal of a FileChooser. This value determines
// whether the file chooser will present the stock confirmation dialog, accept
// the user’s choice of a filename, or let the user choose another filename.
	type FileChooserConfirmation int

	const (
			// FileChooserConfirmationConfirm: the file chooser will present its stock
	// dialog to confirm about overwriting an existing file.
		FileChooserConfirmationConfirm FileChooserConfirmation = 0
			// FileChooserConfirmationAcceptFilename: the file chooser will terminate
	// and accept the user’s choice of a file name.
		FileChooserConfirmationAcceptFilename FileChooserConfirmation = 1
			// FileChooserConfirmationSelectAgain: the file chooser will continue
	// running, so as to let the user select another file name.
		FileChooserConfirmationSelectAgain FileChooserConfirmation = 2
		)

	
	func marshalFileChooserConfirmation(p uintptr) (interface{}, error) {
		return FileChooserConfirmation(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// FileChooserError: these identify the various errors that can occur while
// calling FileChooser functions.
	type FileChooserError int

	const (
			// FileChooserErrorNonexistent indicates that a file does not exist.
		FileChooserErrorNonexistent FileChooserError = 0
			// FileChooserErrorBadFilename indicates a malformed filename.
		FileChooserErrorBadFilename FileChooserError = 1
			// FileChooserErrorAlreadyExists indicates a duplicate path (e.g. when
	// adding a bookmark).
		FileChooserErrorAlreadyExists FileChooserError = 2
			// FileChooserErrorIncompleteHostname indicates an incomplete hostname (e.g.
	// "http://foo" without a slash after that).
		FileChooserErrorIncompleteHostname FileChooserError = 3
		)

	
	func marshalFileChooserError(p uintptr) (interface{}, error) {
		return FileChooserError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// IMPreeditStyle: style for input method preedit. See also
// Settings:gtk-im-preedit-style
	type IMPreeditStyle int

	const (
			// IMPreeditStyleNothing: deprecated
		IMPreeditStyleNothing IMPreeditStyle = 0
			// IMPreeditStyleCallback: deprecated
		IMPreeditStyleCallback IMPreeditStyle = 1
			// IMPreeditStyleNone: deprecated
		IMPreeditStyleNone IMPreeditStyle = 2
		)

	
	func marshalIMPreeditStyle(p uintptr) (interface{}, error) {
		return IMPreeditStyle(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// IMStatusStyle: style for input method status. See also
// Settings:gtk-im-status-style
	type IMStatusStyle int

	const (
			// IMStatusStyleNothing: deprecated
		IMStatusStyleNothing IMStatusStyle = 0
			// IMStatusStyleCallback: deprecated
		IMStatusStyleCallback IMStatusStyle = 1
			// IMStatusStyleNone: deprecated
		IMStatusStyleNone IMStatusStyle = 2
		)

	
	func marshalIMStatusStyle(p uintptr) (interface{}, error) {
		return IMStatusStyle(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// IconSize: built-in stock icon sizes.
	type IconSize int

	const (
			// IconSizeInvalid: invalid size.
		IconSizeInvalid IconSize = 0
			// IconSizeMenu: size appropriate for menus (16px).
		IconSizeMenu IconSize = 1
			// IconSizeSmallToolbar: size appropriate for small toolbars (16px).
		IconSizeSmallToolbar IconSize = 2
			// IconSizeLargeToolbar: size appropriate for large toolbars (24px)
		IconSizeLargeToolbar IconSize = 3
			// IconSizeButton: size appropriate for buttons (16px)
		IconSizeButton IconSize = 4
			// IconSizeDnd: size appropriate for drag and drop (32px)
		IconSizeDnd IconSize = 5
			// IconSizeDialog: size appropriate for dialogs (48px)
		IconSizeDialog IconSize = 6
		)

	
	func marshalIconSize(p uintptr) (interface{}, error) {
		return IconSize(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// IconThemeError: error codes for GtkIconTheme operations.
	type IconThemeError int

	const (
			// IconThemeErrorNotFound: the icon specified does not exist in the theme
		IconThemeErrorNotFound IconThemeError = 0
			// IconThemeErrorFailed: an unspecified error occurred.
		IconThemeErrorFailed IconThemeError = 1
		)

	
	func marshalIconThemeError(p uintptr) (interface{}, error) {
		return IconThemeError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// IconViewDropPosition: an enum for determining where a dropped item goes.
	type IconViewDropPosition int

	const (
			// IconViewDropPositionNoDrop: no drop possible
		IconViewDropPositionNoDrop IconViewDropPosition = 0
			// IconViewDropPositionDropInto: dropped item replaces the item
		IconViewDropPositionDropInto IconViewDropPosition = 1
			// IconViewDropPositionDropLeft: droppped item is inserted to the left
		IconViewDropPositionDropLeft IconViewDropPosition = 2
			// IconViewDropPositionDropRight: dropped item is inserted to the right
		IconViewDropPositionDropRight IconViewDropPosition = 3
			// IconViewDropPositionDropAbove: dropped item is inserted above
		IconViewDropPositionDropAbove IconViewDropPosition = 4
			// IconViewDropPositionDropBelow: dropped item is inserted below
		IconViewDropPositionDropBelow IconViewDropPosition = 5
		)

	
	func marshalIconViewDropPosition(p uintptr) (interface{}, error) {
		return IconViewDropPosition(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// ImageType describes the image data representation used by a Image. If you
// want to get the image from the widget, you can only get the currently-stored
// representation. e.g. if the gtk_image_get_storage_type() returns
// K_IMAGE_PIXBUF, then you can call gtk_image_get_pixbuf() but not
// gtk_image_get_stock(). For empty images, you can request any storage type
// (call any of the "get" functions), but they will all return nil values.
	type ImageType int

	const (
			// ImageTypeEmpty: there is no image displayed by the widget
		ImageTypeEmpty ImageType = 0
			// ImageTypePixbuf: the widget contains a Pixbuf
		ImageTypePixbuf ImageType = 1
			// ImageTypeStock: the widget contains a [stock item name][gtkstock]
		ImageTypeStock ImageType = 2
			// ImageTypeIconSet: the widget contains a IconSet
		ImageTypeIconSet ImageType = 3
			// ImageTypeAnimation: the widget contains a PixbufAnimation
		ImageTypeAnimation ImageType = 4
			// ImageTypeIconName: the widget contains a named icon. This image type was
	// added in GTK+ 2.6
		ImageTypeIconName ImageType = 5
			// ImageTypeGIcon: the widget contains a #GIcon. This image type was added
	// in GTK+ 2.14
		ImageTypeGIcon ImageType = 6
			// ImageTypeSurface: the widget contains a #cairo_surface_t. This image type
	// was added in GTK+ 3.10
		ImageTypeSurface ImageType = 7
		)

	
	func marshalImageType(p uintptr) (interface{}, error) {
		return ImageType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// InputPurpose describes primary purpose of the input widget. This information
// is useful for on-screen keyboards and similar input methods to decide which
// keys should be presented to the user.
// 
// Note that the purpose is not meant to impose a totally strict rule about
// allowed characters, and does not replace input validation. It is fine for an
// on-screen keyboard to let the user override the character set restriction
// that is expressed by the purpose. The application is expected to validate the
// entry contents, even if it specified a purpose.
// 
// The difference between @GTK_INPUT_PURPOSE_DIGITS and
// @GTK_INPUT_PURPOSE_NUMBER is that the former accepts only digits while the
// latter also some punctuation (like commas or points, plus, minus) and “e” or
// “E” as in 3.14E+000.
// 
// This enumeration may be extended in the future; input methods should
// interpret unknown values as “free form”.
	type InputPurpose int

	const (
			// InputPurposeFreeForm: allow any character
		InputPurposeFreeForm InputPurpose = 0
			// InputPurposeAlpha: allow only alphabetic characters
		InputPurposeAlpha InputPurpose = 1
			// InputPurposeDigits: allow only digits
		InputPurposeDigits InputPurpose = 2
			// InputPurposeNumber: edited field expects numbers
		InputPurposeNumber InputPurpose = 3
			// InputPurposePhone: edited field expects phone number
		InputPurposePhone InputPurpose = 4
			// InputPurposeURL: edited field expects URL
		InputPurposeURL InputPurpose = 5
			// InputPurposeEmail: edited field expects email address
		InputPurposeEmail InputPurpose = 6
			// InputPurposeName: edited field expects the name of a person
		InputPurposeName InputPurpose = 7
			// InputPurposePassword: like @GTK_INPUT_PURPOSE_FREE_FORM, but characters
	// are hidden
		InputPurposePassword InputPurpose = 8
			// InputPurposePin: like @GTK_INPUT_PURPOSE_DIGITS, but characters are
	// hidden
		InputPurposePin InputPurpose = 9
			// InputPurposeTerminal: allow any character, in addition to control codes
		InputPurposeTerminal InputPurpose = 10
		)

	
	func marshalInputPurpose(p uintptr) (interface{}, error) {
		return InputPurpose(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// Justification: used for justifying the text inside a Label widget. (See also
// Alignment).
	type Justification int

	const (
			// JustificationLeft: the text is placed at the left edge of the label.
		JustificationLeft Justification = 0
			// JustificationRight: the text is placed at the right edge of the label.
		JustificationRight Justification = 1
			// JustificationCenter: the text is placed in the center of the label.
		JustificationCenter Justification = 2
			// JustificationFill: the text is placed is distributed across the label.
		JustificationFill Justification = 3
		)

	
	func marshalJustification(p uintptr) (interface{}, error) {
		return Justification(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// LevelBarMode describes how LevelBar contents should be rendered. Note that
// this enumeration could be extended with additional modes in the future.
	type LevelBarMode int

	const (
			// LevelBarModeContinuous: the bar has a continuous mode
		LevelBarModeContinuous LevelBarMode = 0
			// LevelBarModeDiscrete: the bar has a discrete mode
		LevelBarModeDiscrete LevelBarMode = 1
		)

	
	func marshalLevelBarMode(p uintptr) (interface{}, error) {
		return LevelBarMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// License: the type of license for an application.
// 
// This enumeration can be expanded at later date.
	type License int

	const (
			// LicenseUnknown: no license specified
		LicenseUnknown License = 0
			// LicenseCustom: a license text is going to be specified by the developer
		LicenseCustom License = 1
			// LicenseGPL20: the GNU General Public License, version 2.0 or later
		LicenseGPL20 License = 2
			// LicenseGPL30: the GNU General Public License, version 3.0 or later
		LicenseGPL30 License = 3
			// LicenseLGPL21: the GNU Lesser General Public License, version 2.1 or
	// later
		LicenseLGPL21 License = 4
			// LicenseLGPL30: the GNU Lesser General Public License, version 3.0 or
	// later
		LicenseLGPL30 License = 5
			// LicenseBSD: the BSD standard license
		LicenseBSD License = 6
			// LicenseMITX11: the MIT/X11 standard license
		LicenseMITX11 License = 7
			// LicenseArtistic: the Artistic License, version 2.0
		LicenseArtistic License = 8
			// LicenseGPL20Only: the GNU General Public License, version 2.0 only. Since
	// 3.12.
		LicenseGPL20Only License = 9
			// LicenseGPL30Only: the GNU General Public License, version 3.0 only. Since
	// 3.12.
		LicenseGPL30Only License = 10
			// LicenseLGPL21Only: the GNU Lesser General Public License, version 2.1
	// only. Since 3.12.
		LicenseLGPL21Only License = 11
			// LicenseLGPL30Only: the GNU Lesser General Public License, version 3.0
	// only. Since 3.12.
		LicenseLGPL30Only License = 12
			// LicenseAGPL30: the GNU Affero General Public License, version 3.0 or
	// later. Since: 3.22.
		LicenseAGPL30 License = 13
			// LicenseAGPL30Only: the GNU Affero General Public License, version 3.0
	// only. Since: 3.22.27.
		LicenseAGPL30Only License = 14
			// LicenseBSD3: the 3-clause BSD licence. Since: 3.24.20.
		LicenseBSD3 License = 15
			// LicenseApache20: the Apache License, version 2.0. Since: 3.24.20.
		LicenseApache20 License = 16
			// LicenseMPL20: the Mozilla Public License, version 2.0. Since: 3.24.20.
		LicenseMPL20 License = 17
		)

	
	func marshalLicense(p uintptr) (interface{}, error) {
		return License(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// MenuDirectionType: an enumeration representing directional movements within a
// menu.
	type MenuDirectionType int

	const (
			// MenuDirectionTypeParent: to the parent menu shell
		MenuDirectionTypeParent MenuDirectionType = 0
			// MenuDirectionTypeChild: to the submenu, if any, associated with the item
		MenuDirectionTypeChild MenuDirectionType = 1
			// MenuDirectionTypeNext: to the next menu item
		MenuDirectionTypeNext MenuDirectionType = 2
			// MenuDirectionTypePrev: to the previous menu item
		MenuDirectionTypePrev MenuDirectionType = 3
		)

	
	func marshalMenuDirectionType(p uintptr) (interface{}, error) {
		return MenuDirectionType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// MessageType: the type of message being displayed in the dialog.
	type MessageType int

	const (
			// MessageTypeInfo: informational message
		MessageTypeInfo MessageType = 0
			// MessageTypeWarning: non-fatal warning message
		MessageTypeWarning MessageType = 1
			// MessageTypeQuestion: question requiring a choice
		MessageTypeQuestion MessageType = 2
			// MessageTypeError: fatal error message
		MessageTypeError MessageType = 3
			// MessageTypeOther: none of the above
		MessageTypeOther MessageType = 4
		)

	
	func marshalMessageType(p uintptr) (interface{}, error) {
		return MessageType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	
	type MovementStep int

	const (
			// MovementStepLogicalPositions: move forward or back by graphemes
		MovementStepLogicalPositions MovementStep = 0
			// MovementStepVisualPositions: move left or right by graphemes
		MovementStepVisualPositions MovementStep = 1
			// MovementStepWords: move forward or back by words
		MovementStepWords MovementStep = 2
			// MovementStepDisplayLines: move up or down lines (wrapped lines)
		MovementStepDisplayLines MovementStep = 3
			// MovementStepDisplayLineEnds: move to either end of a line
		MovementStepDisplayLineEnds MovementStep = 4
			// MovementStepParagraphs: move up or down paragraphs (newline-ended lines)
		MovementStepParagraphs MovementStep = 5
			// MovementStepParagraphEnds: move to either end of a paragraph
		MovementStepParagraphEnds MovementStep = 6
			// MovementStepPages: move by pages
		MovementStepPages MovementStep = 7
			// MovementStepBufferEnds: move to ends of the buffer
		MovementStepBufferEnds MovementStep = 8
			// MovementStepHorizontalPages: move horizontally by pages
		MovementStepHorizontalPages MovementStep = 9
		)

	
	func marshalMovementStep(p uintptr) (interface{}, error) {
		return MovementStep(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	
	type NotebookTab int

	const (
		NotebookTabFirst NotebookTab = 0
		NotebookTabLast NotebookTab = 1
		)

	
	func marshalNotebookTab(p uintptr) (interface{}, error) {
		return NotebookTab(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// NumberUpLayout: used to determine the layout of pages on a sheet when
// printing multiple pages per sheet.
	type NumberUpLayout int

	const (
			// NumberUpLayoutLrtb: ! (layout-lrtb.png)
		NumberUpLayoutLrtb NumberUpLayout = 0
			// NumberUpLayoutLrbt: ! (layout-lrbt.png)
		NumberUpLayoutLrbt NumberUpLayout = 1
			// NumberUpLayoutRltb: ! (layout-rltb.png)
		NumberUpLayoutRltb NumberUpLayout = 2
			// NumberUpLayoutRlbt: ! (layout-rlbt.png)
		NumberUpLayoutRlbt NumberUpLayout = 3
			// NumberUpLayoutTblr: ! (layout-tblr.png)
		NumberUpLayoutTblr NumberUpLayout = 4
			// NumberUpLayoutTbrl: ! (layout-tbrl.png)
		NumberUpLayoutTbrl NumberUpLayout = 5
			// NumberUpLayoutBtlr: ! (layout-btlr.png)
		NumberUpLayoutBtlr NumberUpLayout = 6
			// NumberUpLayoutBtrl: ! (layout-btrl.png)
		NumberUpLayoutBtrl NumberUpLayout = 7
		)

	
	func marshalNumberUpLayout(p uintptr) (interface{}, error) {
		return NumberUpLayout(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// Orientation represents the orientation of widgets and other objects which can
// be switched between horizontal and vertical orientation on the fly, like
// Toolbar or GesturePan.
	type Orientation int

	const (
			// OrientationHorizontal: the element is in horizontal orientation.
		OrientationHorizontal Orientation = 0
			// OrientationVertical: the element is in vertical orientation.
		OrientationVertical Orientation = 1
		)

	
	func marshalOrientation(p uintptr) (interface{}, error) {
		return Orientation(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// PackDirection determines how widgets should be packed inside menubars and
// menuitems contained in menubars.
	type PackDirection int

	const (
			// PackDirectionLTR widgets are packed left-to-right
		PackDirectionLTR PackDirection = 0
			// PackDirectionRTL widgets are packed right-to-left
		PackDirectionRTL PackDirection = 1
			// PackDirectionTtb widgets are packed top-to-bottom
		PackDirectionTtb PackDirection = 2
			// PackDirectionBtt widgets are packed bottom-to-top
		PackDirectionBtt PackDirection = 3
		)

	
	func marshalPackDirection(p uintptr) (interface{}, error) {
		return PackDirection(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// PackType represents the packing location Box children. (See: VBox, HBox, and
// ButtonBox).
	type PackType int

	const (
			// PackTypeStart: the child is packed into the start of the box
		PackTypeStart PackType = 0
			// PackTypeEnd: the child is packed into the end of the box
		PackTypeEnd PackType = 1
		)

	
	func marshalPackType(p uintptr) (interface{}, error) {
		return PackType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// PadActionType: the type of a pad action.
	type PadActionType int

	const (
			// PadActionTypeButton: action is triggered by a pad button
		PadActionTypeButton PadActionType = 0
			// PadActionTypeRing: action is triggered by a pad ring
		PadActionTypeRing PadActionType = 1
			// PadActionTypeStrip: action is triggered by a pad strip
		PadActionTypeStrip PadActionType = 2
		)

	
	func marshalPadActionType(p uintptr) (interface{}, error) {
		return PadActionType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// PageOrientation: see also gtk_print_settings_set_orientation().
	type PageOrientation int

	const (
			// PageOrientationPortrait: portrait mode.
		PageOrientationPortrait PageOrientation = 0
			// PageOrientationLandscape: landscape mode.
		PageOrientationLandscape PageOrientation = 1
			// PageOrientationReversePortrait: reverse portrait mode.
		PageOrientationReversePortrait PageOrientation = 2
			// PageOrientationReverseLandscape: reverse landscape mode.
		PageOrientationReverseLandscape PageOrientation = 3
		)

	
	func marshalPageOrientation(p uintptr) (interface{}, error) {
		return PageOrientation(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// PageSet: see also gtk_print_job_set_page_set().
	type PageSet int

	const (
			// PageSetAll: all pages.
		PageSetAll PageSet = 0
			// PageSetEven: even pages.
		PageSetEven PageSet = 1
			// PageSetOdd: odd pages.
		PageSetOdd PageSet = 2
		)

	
	func marshalPageSet(p uintptr) (interface{}, error) {
		return PageSet(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// PanDirection describes the panning direction of a GesturePan
	type PanDirection int

	const (
			// PanDirectionLeft: panned towards the left
		PanDirectionLeft PanDirection = 0
			// PanDirectionRight: panned towards the right
		PanDirectionRight PanDirection = 1
			// PanDirectionUp: panned upwards
		PanDirectionUp PanDirection = 2
			// PanDirectionDown: panned downwards
		PanDirectionDown PanDirection = 3
		)

	
	func marshalPanDirection(p uintptr) (interface{}, error) {
		return PanDirection(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// PathPriorityType priorities for path lookups. See also
// gtk_binding_set_add_path().
	type PathPriorityType int

	const (
			// PathPriorityTypeLowest: deprecated
		PathPriorityTypeLowest PathPriorityType = 0
			// PathPriorityTypeGTK: deprecated
		PathPriorityTypeGTK PathPriorityType = 4
			// PathPriorityTypeApplication: deprecated
		PathPriorityTypeApplication PathPriorityType = 8
			// PathPriorityTypeTheme: deprecated
		PathPriorityTypeTheme PathPriorityType = 10
			// PathPriorityTypeRC: deprecated
		PathPriorityTypeRC PathPriorityType = 12
			// PathPriorityTypeHighest: deprecated
		PathPriorityTypeHighest PathPriorityType = 15
		)

	
	func marshalPathPriorityType(p uintptr) (interface{}, error) {
		return PathPriorityType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// PathType: widget path types. See also gtk_binding_set_add_path().
	type PathType int

	const (
			// PathTypeWidget: deprecated
		PathTypeWidget PathType = 0
			// PathTypeWidgetClass: deprecated
		PathTypeWidgetClass PathType = 1
			// PathTypeClass: deprecated
		PathTypeClass PathType = 2
		)

	
	func marshalPathType(p uintptr) (interface{}, error) {
		return PathType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// PolicyType determines how the size should be computed to achieve the one of
// the visibility mode for the scrollbars.
	type PolicyType int

	const (
			// PolicyTypeAlways: the scrollbar is always visible. The view size is
	// independent of the content.
		PolicyTypeAlways PolicyType = 0
			// PolicyTypeAutomatic: the scrollbar will appear and disappear as
	// necessary. For example, when all of a TreeView can not be seen.
		PolicyTypeAutomatic PolicyType = 1
			// PolicyTypeNever: the scrollbar should never appear. In this mode the
	// content determines the size.
		PolicyTypeNever PolicyType = 2
			// PolicyTypeExternal: don't show a scrollbar, but don't force the size to
	// follow the content. This can be used e.g. to make multiple scrolled
	// windows share a scrollbar. Since: 3.16
		PolicyTypeExternal PolicyType = 3
		)

	
	func marshalPolicyType(p uintptr) (interface{}, error) {
		return PolicyType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// PopoverConstraint describes constraints to positioning of popovers. More
// values may be added to this enumeration in the future.
	type PopoverConstraint int

	const (
			// PopoverConstraintNone: don't constrain the popover position beyond what
	// is imposed by the implementation
		PopoverConstraintNone PopoverConstraint = 0
			// PopoverConstraintWindow: constrain the popover to the boundaries of the
	// window that it is attached to
		PopoverConstraintWindow PopoverConstraint = 1
		)

	
	func marshalPopoverConstraint(p uintptr) (interface{}, error) {
		return PopoverConstraint(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// PositionType describes which edge of a widget a certain feature is positioned
// at, e.g. the tabs of a Notebook, the handle of a HandleBox or the label of a
// Scale.
	type PositionType int

	const (
			// PositionTypeLeft: the feature is at the left edge.
		PositionTypeLeft PositionType = 0
			// PositionTypeRight: the feature is at the right edge.
		PositionTypeRight PositionType = 1
			// PositionTypeTop: the feature is at the top edge.
		PositionTypeTop PositionType = 2
			// PositionTypeBottom: the feature is at the bottom edge.
		PositionTypeBottom PositionType = 3
		)

	
	func marshalPositionType(p uintptr) (interface{}, error) {
		return PositionType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// PrintDuplex: see also gtk_print_settings_set_duplex().
	type PrintDuplex int

	const (
			// PrintDuplexSimplex: no duplex.
		PrintDuplexSimplex PrintDuplex = 0
			// PrintDuplexHorizontal: horizontal duplex.
		PrintDuplexHorizontal PrintDuplex = 1
			// PrintDuplexVertical: vertical duplex.
		PrintDuplexVertical PrintDuplex = 2
		)

	
	func marshalPrintDuplex(p uintptr) (interface{}, error) {
		return PrintDuplex(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// PrintError: error codes that identify various errors that can occur while
// using the GTK+ printing support.
	type PrintError int

	const (
			// PrintErrorGeneral: an unspecified error occurred.
		PrintErrorGeneral PrintError = 0
			// PrintErrorInternalError: an internal error occurred.
		PrintErrorInternalError PrintError = 1
			// PrintErrorNOMEM: a memory allocation failed.
		PrintErrorNOMEM PrintError = 2
			// PrintErrorInvalidFile: an error occurred while loading a page setup or
	// paper size from a key file.
		PrintErrorInvalidFile PrintError = 3
		)

	
	func marshalPrintError(p uintptr) (interface{}, error) {
		return PrintError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// PrintOperationAction: the @action parameter to gtk_print_operation_run()
// determines what action the print operation should perform.
	type PrintOperationAction int

	const (
			// PrintOperationActionPrintDialog: show the print dialog.
		PrintOperationActionPrintDialog PrintOperationAction = 0
			// PrintOperationActionPrint: start to print without showing the print
	// dialog, based on the current print settings.
		PrintOperationActionPrint PrintOperationAction = 1
			// PrintOperationActionPreview: show the print preview.
		PrintOperationActionPreview PrintOperationAction = 2
			// PrintOperationActionExport: export to a file. This requires the
	// export-filename property to be set.
		PrintOperationActionExport PrintOperationAction = 3
		)

	
	func marshalPrintOperationAction(p uintptr) (interface{}, error) {
		return PrintOperationAction(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// PrintOperationResult: a value of this type is returned by
// gtk_print_operation_run().
	type PrintOperationResult int

	const (
			// PrintOperationResultError: an error has occurred.
		PrintOperationResultError PrintOperationResult = 0
			// PrintOperationResultApply: the print settings should be stored.
		PrintOperationResultApply PrintOperationResult = 1
			// PrintOperationResultCancel: the print operation has been canceled, the
	// print settings should not be stored.
		PrintOperationResultCancel PrintOperationResult = 2
			// PrintOperationResultInProgress: the print operation is not complete yet.
	// This value will only be returned when running asynchronously.
		PrintOperationResultInProgress PrintOperationResult = 3
		)

	
	func marshalPrintOperationResult(p uintptr) (interface{}, error) {
		return PrintOperationResult(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// PrintPages: see also gtk_print_job_set_pages()
	type PrintPages int

	const (
			// PrintPagesAll: all pages.
		PrintPagesAll PrintPages = 0
			// PrintPagesCurrent: current page.
		PrintPagesCurrent PrintPages = 1
			// PrintPagesRanges: range of pages.
		PrintPagesRanges PrintPages = 2
			// PrintPagesSelection: selected pages.
		PrintPagesSelection PrintPages = 3
		)

	
	func marshalPrintPages(p uintptr) (interface{}, error) {
		return PrintPages(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// PrintQuality: see also gtk_print_settings_set_quality().
	type PrintQuality int

	const (
			// PrintQualityLow: low quality.
		PrintQualityLow PrintQuality = 0
			// PrintQualityNormal: normal quality.
		PrintQualityNormal PrintQuality = 1
			// PrintQualityHigh: high quality.
		PrintQualityHigh PrintQuality = 2
			// PrintQualityDraft: draft quality.
		PrintQualityDraft PrintQuality = 3
		)

	
	func marshalPrintQuality(p uintptr) (interface{}, error) {
		return PrintQuality(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// PrintStatus: the status gives a rough indication of the completion of a
// running print operation.
	type PrintStatus int

	const (
			// PrintStatusInitial: the printing has not started yet; this status is set
	// initially, and while the print dialog is shown.
		PrintStatusInitial PrintStatus = 0
			// PrintStatusPreparing: this status is set while the begin-print signal is
	// emitted and during pagination.
		PrintStatusPreparing PrintStatus = 1
			// PrintStatusGeneratingData: this status is set while the pages are being
	// rendered.
		PrintStatusGeneratingData PrintStatus = 2
			// PrintStatusSendingData: the print job is being sent off to the printer.
		PrintStatusSendingData PrintStatus = 3
			// PrintStatusPending: the print job has been sent to the printer, but is
	// not printed for some reason, e.g. the printer may be stopped.
		PrintStatusPending PrintStatus = 4
			// PrintStatusPendingIssue: some problem has occurred during printing, e.g.
	// a paper jam.
		PrintStatusPendingIssue PrintStatus = 5
			// PrintStatusPrinting: the printer is processing the print job.
		PrintStatusPrinting PrintStatus = 6
			// PrintStatusFinished: the printing has been completed successfully.
		PrintStatusFinished PrintStatus = 7
			// PrintStatusFinishedAborted: the printing has been aborted.
		PrintStatusFinishedAborted PrintStatus = 8
		)

	
	func marshalPrintStatus(p uintptr) (interface{}, error) {
		return PrintStatus(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// PropagationPhase describes the stage at which events are fed into a
// EventController.
	type PropagationPhase int

	const (
			// PropagationPhaseNone events are not delivered automatically. Those can be
	// manually fed through gtk_event_controller_handle_event(). This should
	// only be used when full control about when, or whether the controller
	// handles the event is needed.
		PropagationPhaseNone PropagationPhase = 0
			// PropagationPhaseCapture events are delivered in the capture phase. The
	// capture phase happens before the bubble phase, runs from the toplevel
	// down to the event widget. This option should only be used on containers
	// that might possibly handle events before their children do.
		PropagationPhaseCapture PropagationPhase = 1
			// PropagationPhaseBubble events are delivered in the bubble phase. The
	// bubble phase happens after the capture phase, and before the default
	// handlers are run. This phase runs from the event widget, up to the
	// toplevel.
		PropagationPhaseBubble PropagationPhase = 2
			// PropagationPhaseTarget events are delivered in the default widget event
	// handlers, note that widget implementations must chain up on button,
	// motion, touch and grab broken handlers for controllers in this phase to
	// be run.
		PropagationPhaseTarget PropagationPhase = 3
		)

	
	func marshalPropagationPhase(p uintptr) (interface{}, error) {
		return PropagationPhase(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// RCTokenType: the RcTokenType enumeration represents the tokens in the RC
// file. It is exposed so that theme engines can reuse these tokens when parsing
// the theme-engine specific portions of a RC file.
	type RCTokenType int

	const (
			// RCTokenTypeInvalid: deprecated
		RCTokenTypeInvalid RCTokenType = 270
			// RCTokenTypeInclude: deprecated
		RCTokenTypeInclude RCTokenType = 271
			// RCTokenTypeNormal: deprecated
		RCTokenTypeNormal RCTokenType = 272
			// RCTokenTypeActive: deprecated
		RCTokenTypeActive RCTokenType = 273
			// RCTokenTypePrelight: deprecated
		RCTokenTypePrelight RCTokenType = 274
			// RCTokenTypeSelected: deprecated
		RCTokenTypeSelected RCTokenType = 275
			// RCTokenTypeInsensitive: deprecated
		RCTokenTypeInsensitive RCTokenType = 276
			// RCTokenTypeFg: deprecated
		RCTokenTypeFg RCTokenType = 277
			// RCTokenTypeBg: deprecated
		RCTokenTypeBg RCTokenType = 278
			// RCTokenTypeText: deprecated
		RCTokenTypeText RCTokenType = 279
			// RCTokenTypeBase: deprecated
		RCTokenTypeBase RCTokenType = 280
			// RCTokenTypeXthickness: deprecated
		RCTokenTypeXthickness RCTokenType = 281
			// RCTokenTypeYthickness: deprecated
		RCTokenTypeYthickness RCTokenType = 282
			// RCTokenTypeFont: deprecated
		RCTokenTypeFont RCTokenType = 283
			// RCTokenTypeFontset: deprecated
		RCTokenTypeFontset RCTokenType = 284
			// RCTokenTypeFontName: deprecated
		RCTokenTypeFontName RCTokenType = 285
			// RCTokenTypeBgPixmap: deprecated
		RCTokenTypeBgPixmap RCTokenType = 286
			// RCTokenTypePixmapPath: deprecated
		RCTokenTypePixmapPath RCTokenType = 287
			// RCTokenTypeStyle: deprecated
		RCTokenTypeStyle RCTokenType = 288
			// RCTokenTypeBinding: deprecated
		RCTokenTypeBinding RCTokenType = 289
			// RCTokenTypeBind: deprecated
		RCTokenTypeBind RCTokenType = 290
			// RCTokenTypeWidget: deprecated
		RCTokenTypeWidget RCTokenType = 291
			// RCTokenTypeWidgetClass: deprecated
		RCTokenTypeWidgetClass RCTokenType = 292
			// RCTokenTypeClass: deprecated
		RCTokenTypeClass RCTokenType = 293
			// RCTokenTypeLowest: deprecated
		RCTokenTypeLowest RCTokenType = 294
			// RCTokenTypeGTK: deprecated
		RCTokenTypeGTK RCTokenType = 295
			// RCTokenTypeApplication: deprecated
		RCTokenTypeApplication RCTokenType = 296
			// RCTokenTypeTheme: deprecated
		RCTokenTypeTheme RCTokenType = 297
			// RCTokenTypeRC: deprecated
		RCTokenTypeRC RCTokenType = 298
			// RCTokenTypeHighest: deprecated
		RCTokenTypeHighest RCTokenType = 299
			// RCTokenTypeEngine: deprecated
		RCTokenTypeEngine RCTokenType = 300
			// RCTokenTypeModulePath: deprecated
		RCTokenTypeModulePath RCTokenType = 301
			// RCTokenTypeImModulePath: deprecated
		RCTokenTypeImModulePath RCTokenType = 302
			// RCTokenTypeImModuleFile: deprecated
		RCTokenTypeImModuleFile RCTokenType = 303
			// RCTokenTypeStock: deprecated
		RCTokenTypeStock RCTokenType = 304
			// RCTokenTypeLTR: deprecated
		RCTokenTypeLTR RCTokenType = 305
			// RCTokenTypeRTL: deprecated
		RCTokenTypeRTL RCTokenType = 306
			// RCTokenTypeColor: deprecated
		RCTokenTypeColor RCTokenType = 307
			// RCTokenTypeUnbind: deprecated
		RCTokenTypeUnbind RCTokenType = 308
			// RCTokenTypeLast: deprecated
		RCTokenTypeLast RCTokenType = 309
		)

	
	func marshalRCTokenType(p uintptr) (interface{}, error) {
		return RCTokenType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// RecentChooserError: these identify the various errors that can occur while
// calling RecentChooser functions.
	type RecentChooserError int

	const (
			// RecentChooserErrorNotFound indicates that a file does not exist
		RecentChooserErrorNotFound RecentChooserError = 0
			// RecentChooserErrorInvalidURI indicates a malformed URI
		RecentChooserErrorInvalidURI RecentChooserError = 1
		)

	
	func marshalRecentChooserError(p uintptr) (interface{}, error) {
		return RecentChooserError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// RecentManagerError: error codes for RecentManager operations
	type RecentManagerError int

	const (
			// RecentManagerErrorNotFound: the URI specified does not exists in the
	// recently used resources list.
		RecentManagerErrorNotFound RecentManagerError = 0
			// RecentManagerErrorInvalidURI: the URI specified is not valid.
		RecentManagerErrorInvalidURI RecentManagerError = 1
			// RecentManagerErrorInvalidEncoding: the supplied string is not UTF-8
	// encoded.
		RecentManagerErrorInvalidEncoding RecentManagerError = 2
			// RecentManagerErrorNotRegistered: no application has registered the
	// specified item.
		RecentManagerErrorNotRegistered RecentManagerError = 3
			// RecentManagerErrorRead: failure while reading the recently used resources
	// file.
		RecentManagerErrorRead RecentManagerError = 4
			// RecentManagerErrorWrite: failure while writing the recently used
	// resources file.
		RecentManagerErrorWrite RecentManagerError = 5
			// RecentManagerErrorUnknown: unspecified error.
		RecentManagerErrorUnknown RecentManagerError = 6
		)

	
	func marshalRecentManagerError(p uintptr) (interface{}, error) {
		return RecentManagerError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// RecentSortType: used to specify the sorting method to be applyed to the
// recently used resource list.
	type RecentSortType int

	const (
			// RecentSortTypeNone: do not sort the returned list of recently used
	// resources.
		RecentSortTypeNone RecentSortType = 0
			// RecentSortTypeMru: sort the returned list with the most recently used
	// items first.
		RecentSortTypeMru RecentSortType = 1
			// RecentSortTypeLru: sort the returned list with the least recently used
	// items first.
		RecentSortTypeLru RecentSortType = 2
			// RecentSortTypeCustom: sort the returned list using a custom sorting
	// function passed using gtk_recent_chooser_set_sort_func().
		RecentSortTypeCustom RecentSortType = 3
		)

	
	func marshalRecentSortType(p uintptr) (interface{}, error) {
		return RecentSortType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// ReliefStyle: indicated the relief to be drawn around a Button.
	type ReliefStyle int

	const (
			// ReliefStyleNormal: draw a normal relief.
		ReliefStyleNormal ReliefStyle = 0
			// ReliefStyleHalf: a half relief. Deprecated in 3.14, does the same as
	// @GTK_RELIEF_NORMAL
		ReliefStyleHalf ReliefStyle = 1
			// ReliefStyleNone: no relief.
		ReliefStyleNone ReliefStyle = 2
		)

	
	func marshalReliefStyle(p uintptr) (interface{}, error) {
		return ReliefStyle(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	
	type ResizeMode int

	const (
			// ResizeModeParent pass resize request to the parent
		ResizeModeParent ResizeMode = 0
			// ResizeModeQueue: queue resizes on this widget
		ResizeModeQueue ResizeMode = 1
			// ResizeModeImmediate: resize immediately. Deprecated.
		ResizeModeImmediate ResizeMode = 2
		)

	
	func marshalResizeMode(p uintptr) (interface{}, error) {
		return ResizeMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// ResponseType: predefined values for use as response ids in
// gtk_dialog_add_button(). All predefined values are negative; GTK+ leaves
// values of 0 or greater for application-defined response ids.
	type ResponseType int

	const (
			// ResponseTypeNone: returned if an action widget has no response id, or if
	// the dialog gets programmatically hidden or destroyed
		ResponseTypeNone ResponseType = -1
			// ResponseTypeReject: generic response id, not used by GTK+ dialogs
		ResponseTypeReject ResponseType = -2
			// ResponseTypeAccept: generic response id, not used by GTK+ dialogs
		ResponseTypeAccept ResponseType = -3
			// ResponseTypeDeleteEvent: returned if the dialog is deleted
		ResponseTypeDeleteEvent ResponseType = -4
			// ResponseTypeOk: returned by OK buttons in GTK+ dialogs
		ResponseTypeOk ResponseType = -5
			// ResponseTypeCancel: returned by Cancel buttons in GTK+ dialogs
		ResponseTypeCancel ResponseType = -6
			// ResponseTypeClose: returned by Close buttons in GTK+ dialogs
		ResponseTypeClose ResponseType = -7
			// ResponseTypeYes: returned by Yes buttons in GTK+ dialogs
		ResponseTypeYes ResponseType = -8
			// ResponseTypeNo: returned by No buttons in GTK+ dialogs
		ResponseTypeNo ResponseType = -9
			// ResponseTypeApply: returned by Apply buttons in GTK+ dialogs
		ResponseTypeApply ResponseType = -10
			// ResponseTypeHelp: returned by Help buttons in GTK+ dialogs
		ResponseTypeHelp ResponseType = -11
		)

	
	func marshalResponseType(p uintptr) (interface{}, error) {
		return ResponseType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// RevealerTransitionType: these enumeration values describe the possible
// transitions when the child of a Revealer widget is shown or hidden.
	type RevealerTransitionType int

	const (
			// RevealerTransitionTypeNone: no transition
		RevealerTransitionTypeNone RevealerTransitionType = 0
			// RevealerTransitionTypeCrossfade: fade in
		RevealerTransitionTypeCrossfade RevealerTransitionType = 1
			// RevealerTransitionTypeSlideRight: slide in from the left
		RevealerTransitionTypeSlideRight RevealerTransitionType = 2
			// RevealerTransitionTypeSlideLeft: slide in from the right
		RevealerTransitionTypeSlideLeft RevealerTransitionType = 3
			// RevealerTransitionTypeSlideUp: slide in from the bottom
		RevealerTransitionTypeSlideUp RevealerTransitionType = 4
			// RevealerTransitionTypeSlideDown: slide in from the top
		RevealerTransitionTypeSlideDown RevealerTransitionType = 5
		)

	
	func marshalRevealerTransitionType(p uintptr) (interface{}, error) {
		return RevealerTransitionType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	
	type ScrollStep int

	const (
			// ScrollStepSteps: scroll in steps.
		ScrollStepSteps ScrollStep = 0
			// ScrollStepPages: scroll by pages.
		ScrollStepPages ScrollStep = 1
			// ScrollStepEnds: scroll to ends.
		ScrollStepEnds ScrollStep = 2
			// ScrollStepHorizontalSteps: scroll in horizontal steps.
		ScrollStepHorizontalSteps ScrollStep = 3
			// ScrollStepHorizontalPages: scroll by horizontal pages.
		ScrollStepHorizontalPages ScrollStep = 4
			// ScrollStepHorizontalEnds: scroll to the horizontal ends.
		ScrollStepHorizontalEnds ScrollStep = 5
		)

	
	func marshalScrollStep(p uintptr) (interface{}, error) {
		return ScrollStep(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// ScrollType: scrolling types.
	type ScrollType int

	const (
			// ScrollTypeNone: no scrolling.
		ScrollTypeNone ScrollType = 0
			// ScrollTypeJump: jump to new location.
		ScrollTypeJump ScrollType = 1
			// ScrollTypeStepBackward: step backward.
		ScrollTypeStepBackward ScrollType = 2
			// ScrollTypeStepForward: step forward.
		ScrollTypeStepForward ScrollType = 3
			// ScrollTypePageBackward: page backward.
		ScrollTypePageBackward ScrollType = 4
			// ScrollTypePageForward: page forward.
		ScrollTypePageForward ScrollType = 5
			// ScrollTypeStepUp: step up.
		ScrollTypeStepUp ScrollType = 6
			// ScrollTypeStepDown: step down.
		ScrollTypeStepDown ScrollType = 7
			// ScrollTypePageUp: page up.
		ScrollTypePageUp ScrollType = 8
			// ScrollTypePageDown: page down.
		ScrollTypePageDown ScrollType = 9
			// ScrollTypeStepLeft: step to the left.
		ScrollTypeStepLeft ScrollType = 10
			// ScrollTypeStepRight: step to the right.
		ScrollTypeStepRight ScrollType = 11
			// ScrollTypePageLeft: page to the left.
		ScrollTypePageLeft ScrollType = 12
			// ScrollTypePageRight: page to the right.
		ScrollTypePageRight ScrollType = 13
			// ScrollTypeStart: scroll to start.
		ScrollTypeStart ScrollType = 14
			// ScrollTypeEnd: scroll to end.
		ScrollTypeEnd ScrollType = 15
		)

	
	func marshalScrollType(p uintptr) (interface{}, error) {
		return ScrollType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// ScrollablePolicy defines the policy to be used in a scrollable widget when
// updating the scrolled window adjustments in a given orientation.
	type ScrollablePolicy int

	const (
			// ScrollablePolicyMinimum: scrollable adjustments are based on the minimum
	// size
		ScrollablePolicyMinimum ScrollablePolicy = 0
			// ScrollablePolicyNatural: scrollable adjustments are based on the natural
	// size
		ScrollablePolicyNatural ScrollablePolicy = 1
		)

	
	func marshalScrollablePolicy(p uintptr) (interface{}, error) {
		return ScrollablePolicy(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// SelectionMode: used to control what selections users are allowed to make.
	type SelectionMode int

	const (
			// SelectionModeNone: no selection is possible.
		SelectionModeNone SelectionMode = 0
			// SelectionModeSingle: zero or one element may be selected.
		SelectionModeSingle SelectionMode = 1
			// SelectionModeBrowse: exactly one element is selected. In some
	// circumstances, such as initially or during a search operation, it’s
	// possible for no element to be selected with GTK_SELECTION_BROWSE. What is
	// really enforced is that the user can’t deselect a currently selected
	// element except by selecting another element.
		SelectionModeBrowse SelectionMode = 2
			// SelectionModeMultiple: any number of elements may be selected. The Ctrl
	// key may be used to enlarge the selection, and Shift key to select between
	// the focus and the child pointed to. Some widgets may also allow
	// Click-drag to select a range of elements.
		SelectionModeMultiple SelectionMode = 3
		)

	
	func marshalSelectionMode(p uintptr) (interface{}, error) {
		return SelectionMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// SensitivityType determines how GTK+ handles the sensitivity of stepper arrows
// at the end of range widgets.
	type SensitivityType int

	const (
			// SensitivityTypeAuto: the arrow is made insensitive if the thumb is at the
	// end
		SensitivityTypeAuto SensitivityType = 0
			// SensitivityTypeOn: the arrow is always sensitive
		SensitivityTypeOn SensitivityType = 1
			// SensitivityTypeOff: the arrow is always insensitive
		SensitivityTypeOff SensitivityType = 2
		)

	
	func marshalSensitivityType(p uintptr) (interface{}, error) {
		return SensitivityType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// ShadowType: used to change the appearance of an outline typically provided by
// a Frame.
// 
// Note that many themes do not differentiate the appearance of the various
// shadow types: Either their is no visible shadow (@GTK_SHADOW_NONE), or there
// is (any other value).
	type ShadowType int

	const (
			// ShadowTypeNone: no outline.
		ShadowTypeNone ShadowType = 0
			// ShadowTypeIn: the outline is bevelled inwards.
		ShadowTypeIn ShadowType = 1
			// ShadowTypeOut: the outline is bevelled outwards like a button.
		ShadowTypeOut ShadowType = 2
			// ShadowTypeEtchedIn: the outline has a sunken 3d appearance.
		ShadowTypeEtchedIn ShadowType = 3
			// ShadowTypeEtchedOut: the outline has a raised 3d appearance.
		ShadowTypeEtchedOut ShadowType = 4
		)

	
	func marshalShadowType(p uintptr) (interface{}, error) {
		return ShadowType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// ShortcutType: gtkShortcutType specifies the kind of shortcut that is being
// described. More values may be added to this enumeration over time.
	type ShortcutType int

	const (
			// ShortcutTypeAccelerator: the shortcut is a keyboard accelerator. The
	// ShortcutsShortcut:accelerator property will be used.
		ShortcutTypeAccelerator ShortcutType = 0
			// ShortcutTypeGesturePinch: the shortcut is a pinch gesture. GTK+ provides
	// an icon and subtitle.
		ShortcutTypeGesturePinch ShortcutType = 1
			// ShortcutTypeGestureStretch: the shortcut is a stretch gesture. GTK+
	// provides an icon and subtitle.
		ShortcutTypeGestureStretch ShortcutType = 2
			// ShortcutTypeGestureRotateClockwise: the shortcut is a clockwise rotation
	// gesture. GTK+ provides an icon and subtitle.
		ShortcutTypeGestureRotateClockwise ShortcutType = 3
			// ShortcutTypeGestureRotateCounterclockwise: the shortcut is a
	// counterclockwise rotation gesture. GTK+ provides an icon and subtitle.
		ShortcutTypeGestureRotateCounterclockwise ShortcutType = 4
			// ShortcutTypeGestureTwoFingerSwipeLeft: the shortcut is a two-finger swipe
	// gesture. GTK+ provides an icon and subtitle.
		ShortcutTypeGestureTwoFingerSwipeLeft ShortcutType = 5
			// ShortcutTypeGestureTwoFingerSwipeRight: the shortcut is a two-finger
	// swipe gesture. GTK+ provides an icon and subtitle.
		ShortcutTypeGestureTwoFingerSwipeRight ShortcutType = 6
			// ShortcutTypeGesture: the shortcut is a gesture. The
	// ShortcutsShortcut:icon property will be used.
		ShortcutTypeGesture ShortcutType = 7
		)

	
	func marshalShortcutType(p uintptr) (interface{}, error) {
		return ShortcutType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// SizeGroupMode: the mode of the size group determines the directions in which
// the size group affects the requested sizes of its component widgets.
	type SizeGroupMode int

	const (
			// SizeGroupModeNone: group has no effect
		SizeGroupModeNone SizeGroupMode = 0
			// SizeGroupModeHorizontal: group affects horizontal requisition
		SizeGroupModeHorizontal SizeGroupMode = 1
			// SizeGroupModeVertical: group affects vertical requisition
		SizeGroupModeVertical SizeGroupMode = 2
			// SizeGroupModeBoth: group affects both horizontal and vertical requisition
		SizeGroupModeBoth SizeGroupMode = 3
		)

	
	func marshalSizeGroupMode(p uintptr) (interface{}, error) {
		return SizeGroupMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// SizeRequestMode specifies a preference for height-for-width or
// width-for-height geometry management.
	type SizeRequestMode int

	const (
			// SizeRequestModeHeightForWidth: prefer height-for-width geometry
	// management
		SizeRequestModeHeightForWidth SizeRequestMode = 0
			// SizeRequestModeWidthForHeight: prefer width-for-height geometry
	// management
		SizeRequestModeWidthForHeight SizeRequestMode = 1
			// SizeRequestModeConstantSize: don’t trade height-for-width or
	// width-for-height
		SizeRequestModeConstantSize SizeRequestMode = 2
		)

	
	func marshalSizeRequestMode(p uintptr) (interface{}, error) {
		return SizeRequestMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// SortType determines the direction of a sort.
	type SortType int

	const (
			// SortTypeAscending: sorting is in ascending order.
		SortTypeAscending SortType = 0
			// SortTypeDescending: sorting is in descending order.
		SortTypeDescending SortType = 1
		)

	
	func marshalSortType(p uintptr) (interface{}, error) {
		return SortType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// SpinButtonUpdatePolicy: the spin button update policy determines whether the
// spin button displays values even if they are outside the bounds of its
// adjustment. See gtk_spin_button_set_update_policy().
	type SpinButtonUpdatePolicy int

	const (
			// SpinButtonUpdatePolicyAlways: when refreshing your SpinButton, the value
	// is always displayed
		SpinButtonUpdatePolicyAlways SpinButtonUpdatePolicy = 0
			// SpinButtonUpdatePolicyIfValid: when refreshing your SpinButton, the value
	// is only displayed if it is valid within the bounds of the spin button's
	// adjustment
		SpinButtonUpdatePolicyIfValid SpinButtonUpdatePolicy = 1
		)

	
	func marshalSpinButtonUpdatePolicy(p uintptr) (interface{}, error) {
		return SpinButtonUpdatePolicy(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// SpinType: the values of the GtkSpinType enumeration are used to specify the
// change to make in gtk_spin_button_spin().
	type SpinType int

	const (
			// SpinTypeStepForward: increment by the adjustments step increment.
		SpinTypeStepForward SpinType = 0
			// SpinTypeStepBackward: decrement by the adjustments step increment.
		SpinTypeStepBackward SpinType = 1
			// SpinTypePageForward: increment by the adjustments page increment.
		SpinTypePageForward SpinType = 2
			// SpinTypePageBackward: decrement by the adjustments page increment.
		SpinTypePageBackward SpinType = 3
			// SpinTypeHome: go to the adjustments lower bound.
		SpinTypeHome SpinType = 4
			// SpinTypeEnd: go to the adjustments upper bound.
		SpinTypeEnd SpinType = 5
			// SpinTypeUserDefined: change by a specified amount.
		SpinTypeUserDefined SpinType = 6
		)

	
	func marshalSpinType(p uintptr) (interface{}, error) {
		return SpinType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// StackTransitionType: these enumeration values describe the possible
// transitions between pages in a Stack widget.
// 
// New values may be added to this enumeration over time.
	type StackTransitionType int

	const (
			// StackTransitionTypeNone: no transition
		StackTransitionTypeNone StackTransitionType = 0
			// StackTransitionTypeCrossfade: a cross-fade
		StackTransitionTypeCrossfade StackTransitionType = 1
			// StackTransitionTypeSlideRight: slide from left to right
		StackTransitionTypeSlideRight StackTransitionType = 2
			// StackTransitionTypeSlideLeft: slide from right to left
		StackTransitionTypeSlideLeft StackTransitionType = 3
			// StackTransitionTypeSlideUp: slide from bottom up
		StackTransitionTypeSlideUp StackTransitionType = 4
			// StackTransitionTypeSlideDown: slide from top down
		StackTransitionTypeSlideDown StackTransitionType = 5
			// StackTransitionTypeSlideLeftRight: slide from left or right according to
	// the children order
		StackTransitionTypeSlideLeftRight StackTransitionType = 6
			// StackTransitionTypeSlideUpDown: slide from top down or bottom up
	// according to the order
		StackTransitionTypeSlideUpDown StackTransitionType = 7
			// StackTransitionTypeOverUp: cover the old page by sliding up. Since 3.12
		StackTransitionTypeOverUp StackTransitionType = 8
			// StackTransitionTypeOverDown: cover the old page by sliding down. Since:
	// 3.12
		StackTransitionTypeOverDown StackTransitionType = 9
			// StackTransitionTypeOverLeft: cover the old page by sliding to the left.
	// Since: 3.12
		StackTransitionTypeOverLeft StackTransitionType = 10
			// StackTransitionTypeOverRight: cover the old page by sliding to the right.
	// Since: 3.12
		StackTransitionTypeOverRight StackTransitionType = 11
			// StackTransitionTypeUnderUp: uncover the new page by sliding up. Since
	// 3.12
		StackTransitionTypeUnderUp StackTransitionType = 12
			// StackTransitionTypeUnderDown: uncover the new page by sliding down.
	// Since: 3.12
		StackTransitionTypeUnderDown StackTransitionType = 13
			// StackTransitionTypeUnderLeft: uncover the new page by sliding to the
	// left. Since: 3.12
		StackTransitionTypeUnderLeft StackTransitionType = 14
			// StackTransitionTypeUnderRight: uncover the new page by sliding to the
	// right. Since: 3.12
		StackTransitionTypeUnderRight StackTransitionType = 15
			// StackTransitionTypeOverUpDown: cover the old page sliding up or uncover
	// the new page sliding down, according to order. Since: 3.12
		StackTransitionTypeOverUpDown StackTransitionType = 16
			// StackTransitionTypeOverDownUp: cover the old page sliding down or uncover
	// the new page sliding up, according to order. Since: 3.14
		StackTransitionTypeOverDownUp StackTransitionType = 17
			// StackTransitionTypeOverLeftRight: cover the old page sliding left or
	// uncover the new page sliding right, according to order. Since: 3.14
		StackTransitionTypeOverLeftRight StackTransitionType = 18
			// StackTransitionTypeOverRightLeft: cover the old page sliding right or
	// uncover the new page sliding left, according to order. Since: 3.14
		StackTransitionTypeOverRightLeft StackTransitionType = 19
		)

	
	func marshalStackTransitionType(p uintptr) (interface{}, error) {
		return StackTransitionType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// StateType: this type indicates the current state of a widget; the state
// determines how the widget is drawn. The StateType enumeration is also used to
// identify different colors in a Style for drawing, so states can be used for
// subparts of a widget as well as entire widgets.
	type StateType int

	const (
			// StateTypeNormal: state during normal operation.
		StateTypeNormal StateType = 0
			// StateTypeActive: state of a currently active widget, such as a depressed
	// button.
		StateTypeActive StateType = 1
			// StateTypePrelight: state indicating that the mouse pointer is over the
	// widget and the widget will respond to mouse clicks.
		StateTypePrelight StateType = 2
			// StateTypeSelected: state of a selected item, such the selected row in a
	// list.
		StateTypeSelected StateType = 3
			// StateTypeInsensitive: state indicating that the widget is unresponsive to
	// user actions.
		StateTypeInsensitive StateType = 4
			// StateTypeInconsistent: the widget is inconsistent, such as checkbuttons
	// or radiobuttons that aren’t either set to true nor false, or buttons
	// requiring the user attention.
		StateTypeInconsistent StateType = 5
			// StateTypeFocused: the widget has the keyboard focus.
		StateTypeFocused StateType = 6
		)

	
	func marshalStateType(p uintptr) (interface{}, error) {
		return StateType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// TextBufferTargetInfo: these values are used as “info” for the targets
// contained in the lists returned by gtk_text_buffer_get_copy_target_list() and
// gtk_text_buffer_get_paste_target_list().
// 
// The values counts down from `-1` to avoid clashes with application added drag
// destinations which usually start at 0.
	type TextBufferTargetInfo int

	const (
			// TextBufferTargetInfoBufferContents: buffer contents
		TextBufferTargetInfoBufferContents TextBufferTargetInfo = -1
			// TextBufferTargetInfoRichText: rich text
		TextBufferTargetInfoRichText TextBufferTargetInfo = -2
			// TextBufferTargetInfoText: text
		TextBufferTargetInfoText TextBufferTargetInfo = -3
		)

	
	func marshalTextBufferTargetInfo(p uintptr) (interface{}, error) {
		return TextBufferTargetInfo(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// TextDirection: reading directions for text.
	type TextDirection int

	const (
			// TextDirectionNone: no direction.
		TextDirectionNone TextDirection = 0
			// TextDirectionLTR: left to right text direction.
		TextDirectionLTR TextDirection = 1
			// TextDirectionRTL: right to left text direction.
		TextDirectionRTL TextDirection = 2
		)

	
	func marshalTextDirection(p uintptr) (interface{}, error) {
		return TextDirection(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// TextExtendSelection: granularity types that extend the text selection. Use
// the TextView::extend-selection signal to customize the selection.
	type TextExtendSelection int

	const (
			// TextExtendSelectionWord selects the current word. It is triggered by a
	// double-click for example.
		TextExtendSelectionWord TextExtendSelection = 0
			// TextExtendSelectionLine selects the current line. It is triggered by a
	// triple-click for example.
		TextExtendSelectionLine TextExtendSelection = 1
		)

	
	func marshalTextExtendSelection(p uintptr) (interface{}, error) {
		return TextExtendSelection(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// TextViewLayer: used to reference the layers of TextView for the purpose of
// customized drawing with the ::draw_layer vfunc.
	type TextViewLayer int

	const (
			// TextViewLayerBelow: old deprecated layer, use
	// GTK_TEXT_VIEW_LAYER_BELOW_TEXT instead
		TextViewLayerBelow TextViewLayer = 0
			// TextViewLayerAbove: old deprecated layer, use
	// GTK_TEXT_VIEW_LAYER_ABOVE_TEXT instead
		TextViewLayerAbove TextViewLayer = 1
			// TextViewLayerBelowText: the layer rendered below the text (but above the
	// background). Since: 3.20
		TextViewLayerBelowText TextViewLayer = 2
			// TextViewLayerAboveText: the layer rendered above the text. Since: 3.20
		TextViewLayerAboveText TextViewLayer = 3
		)

	
	func marshalTextViewLayer(p uintptr) (interface{}, error) {
		return TextViewLayer(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// TextWindowType: used to reference the parts of TextView.
	type TextWindowType int

	const (
			// TextWindowTypePrivate: invalid value, used as a marker
		TextWindowTypePrivate TextWindowType = 0
			// TextWindowTypeWidget: window that floats over scrolling areas.
		TextWindowTypeWidget TextWindowType = 1
			// TextWindowTypeText: scrollable text window.
		TextWindowTypeText TextWindowType = 2
			// TextWindowTypeLeft: left side border window.
		TextWindowTypeLeft TextWindowType = 3
			// TextWindowTypeRight: right side border window.
		TextWindowTypeRight TextWindowType = 4
			// TextWindowTypeTop: top border window.
		TextWindowTypeTop TextWindowType = 5
			// TextWindowTypeBottom: bottom border window.
		TextWindowTypeBottom TextWindowType = 6
		)

	
	func marshalTextWindowType(p uintptr) (interface{}, error) {
		return TextWindowType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// ToolbarSpaceStyle: whether spacers are vertical lines or just blank.
	type ToolbarSpaceStyle int

	const (
			// ToolbarSpaceStyleEmpty: use blank spacers.
		ToolbarSpaceStyleEmpty ToolbarSpaceStyle = 0
			// ToolbarSpaceStyleLine: use vertical lines for spacers.
		ToolbarSpaceStyleLine ToolbarSpaceStyle = 1
		)

	
	func marshalToolbarSpaceStyle(p uintptr) (interface{}, error) {
		return ToolbarSpaceStyle(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// ToolbarStyle: used to customize the appearance of a Toolbar. Note that
// setting the toolbar style overrides the user’s preferences for the default
// toolbar style. Note that if the button has only a label set and
// GTK_TOOLBAR_ICONS is used, the label will be visible, and vice versa.
	type ToolbarStyle int

	const (
			// ToolbarStyleIcons buttons display only icons in the toolbar.
		ToolbarStyleIcons ToolbarStyle = 0
			// ToolbarStyleText buttons display only text labels in the toolbar.
		ToolbarStyleText ToolbarStyle = 1
			// ToolbarStyleBoth buttons display text and icons in the toolbar.
		ToolbarStyleBoth ToolbarStyle = 2
			// ToolbarStyleBothHoriz buttons display icons and text alongside each
	// other, rather than vertically stacked
		ToolbarStyleBothHoriz ToolbarStyle = 3
		)

	
	func marshalToolbarStyle(p uintptr) (interface{}, error) {
		return ToolbarStyle(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// TreeViewColumnSizing: the sizing method the column uses to determine its
// width. Please note that @GTK_TREE_VIEW_COLUMN_AUTOSIZE are inefficient for
// large views, and can make columns appear choppy.
	type TreeViewColumnSizing int

	const (
			// TreeViewColumnSizingGrowOnly columns only get bigger in reaction to
	// changes in the model
		TreeViewColumnSizingGrowOnly TreeViewColumnSizing = 0
			// TreeViewColumnSizingAutosize columns resize to be the optimal size
	// everytime the model changes.
		TreeViewColumnSizingAutosize TreeViewColumnSizing = 1
			// TreeViewColumnSizingFixed columns are a fixed numbers of pixels wide.
		TreeViewColumnSizingFixed TreeViewColumnSizing = 2
		)

	
	func marshalTreeViewColumnSizing(p uintptr) (interface{}, error) {
		return TreeViewColumnSizing(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// TreeViewDropPosition: an enum for determining where a dropped row goes.
	type TreeViewDropPosition int

	const (
			// TreeViewDropPositionBefore: dropped row is inserted before
		TreeViewDropPositionBefore TreeViewDropPosition = 0
			// TreeViewDropPositionAfter: dropped row is inserted after
		TreeViewDropPositionAfter TreeViewDropPosition = 1
			// TreeViewDropPositionIntoOrBefore: dropped row becomes a child or is
	// inserted before
		TreeViewDropPositionIntoOrBefore TreeViewDropPosition = 2
			// TreeViewDropPositionIntoOrAfter: dropped row becomes a child or is
	// inserted after
		TreeViewDropPositionIntoOrAfter TreeViewDropPosition = 3
		)

	
	func marshalTreeViewDropPosition(p uintptr) (interface{}, error) {
		return TreeViewDropPosition(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// TreeViewGridLines: used to indicate which grid lines to draw in a tree view.
	type TreeViewGridLines int

	const (
			// TreeViewGridLinesNone: no grid lines.
		TreeViewGridLinesNone TreeViewGridLines = 0
			// TreeViewGridLinesHorizontal: horizontal grid lines.
		TreeViewGridLinesHorizontal TreeViewGridLines = 1
			// TreeViewGridLinesVertical: vertical grid lines.
		TreeViewGridLinesVertical TreeViewGridLines = 2
			// TreeViewGridLinesBoth: horizontal and vertical grid lines.
		TreeViewGridLinesBoth TreeViewGridLines = 3
		)

	
	func marshalTreeViewGridLines(p uintptr) (interface{}, error) {
		return TreeViewGridLines(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// Unit: see also gtk_print_settings_set_paper_width().
	type Unit int

	const (
			// UnitNone: no units.
		UnitNone Unit = 0
			// UnitPoints dimensions in points.
		UnitPoints Unit = 1
			// UnitInch dimensions in inches.
		UnitInch Unit = 2
			// UnitMm dimensions in millimeters
		UnitMm Unit = 3
		)

	
	func marshalUnit(p uintptr) (interface{}, error) {
		return Unit(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// WidgetHelpType kinds of widget-specific help. Used by the ::show-help signal.
	type WidgetHelpType int

	const (
			// WidgetHelpTypeTooltip: tooltip.
		WidgetHelpTypeTooltip WidgetHelpType = 0
			// WidgetHelpTypeWhatsThis what’s this.
		WidgetHelpTypeWhatsThis WidgetHelpType = 1
		)

	
	func marshalWidgetHelpType(p uintptr) (interface{}, error) {
		return WidgetHelpType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// WindowPosition: window placement can be influenced using this enumeration.
// Note that using K_WIN_POS_CENTER_ALWAYS is almost always a bad idea. It won’t
// necessarily work well with all window managers or on all windowing systems.
	type WindowPosition int

	const (
			// WindowPositionNone: no influence is made on placement.
		WindowPositionNone WindowPosition = 0
			// WindowPositionCenter windows should be placed in the center of the
	// screen.
		WindowPositionCenter WindowPosition = 1
			// WindowPositionMouse windows should be placed at the current mouse
	// position.
		WindowPositionMouse WindowPosition = 2
			// WindowPositionCenterAlways: keep window centered as it changes size, etc.
		WindowPositionCenterAlways WindowPosition = 3
			// WindowPositionCenterOnParent: center the window on its transient parent
	// (see gtk_window_set_transient_for()).
		WindowPositionCenterOnParent WindowPosition = 4
		)

	
	func marshalWindowPosition(p uintptr) (interface{}, error) {
		return WindowPosition(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// WindowType: a Window can be one of these types. Most things you’d consider a
// “window” should have type K_WINDOW_TOPLEVEL; windows with this type are
// managed by the window manager and have a frame by default (call
// gtk_window_set_decorated() to toggle the frame). Windows with type
// K_WINDOW_POPUP are ignored by the window manager; window manager keybindings
// won’t work on them, the window manager won’t decorate the window with a
// frame, many GTK+ features that rely on the window manager will not work (e.g.
// resize grips and maximization/minimization). K_WINDOW_POPUP is used to
// implement widgets such as Menu or tooltips that you normally don’t think of
// as windows per se. Nearly all windows should be K_WINDOW_TOPLEVEL. In
// particular, do not use K_WINDOW_POPUP just to turn off the window borders;
// use gtk_window_set_decorated() for that.
	type WindowType int

	const (
			// WindowTypeToplevel: a regular window, such as a dialog.
		WindowTypeToplevel WindowType = 0
			// WindowTypePopup: a special window such as a tooltip.
		WindowTypePopup WindowType = 1
		)

	
	func marshalWindowType(p uintptr) (interface{}, error) {
		return WindowType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// WrapMode describes a type of line wrapping.
	type WrapMode int

	const (
			// WrapModeNone: do not wrap lines; just make the text area wider
		WrapModeNone WrapMode = 0
			// WrapModeChar: wrap text, breaking lines anywhere the cursor can appear
	// (between characters, usually - if you want to be technical, between
	// graphemes, see pango_get_log_attrs())
		WrapModeChar WrapMode = 1
			// WrapModeWord: wrap text, breaking lines in between words
		WrapModeWord WrapMode = 2
			// WrapModeWordChar: wrap text, breaking lines in between words, or if that
	// is not enough, also between graphemes
		WrapModeWordChar WrapMode = 3
		)

	
	func marshalWrapMode(p uintptr) (interface{}, error) {
		return WrapMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// AccelFlags: accelerator flags used with gtk_accel_group_connect().
	type AccelFlags int

	const (
			// AccelFlagsVisible: accelerator is visible
		AccelFlagsVisible AccelFlags = 1
			// AccelFlagsLocked: accelerator not removable
		AccelFlagsLocked AccelFlags = 2
			// AccelFlagsMask: mask
		AccelFlagsMask AccelFlags = 7
		)

	
	func marshalAccelFlags(p uintptr) (interface{}, error) {
		return AccelFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// ApplicationInhibitFlags types of user actions that may be blocked by
// gtk_application_inhibit().
	type ApplicationInhibitFlags int

	const (
			// ApplicationInhibitFlagsLogout: inhibit ending the user session by logging
	// out or by shutting down the computer
		ApplicationInhibitFlagsLogout ApplicationInhibitFlags = 1
			// ApplicationInhibitFlagsSwitch: inhibit user switching
		ApplicationInhibitFlagsSwitch ApplicationInhibitFlags = 2
			// ApplicationInhibitFlagsSuspend: inhibit suspending the session or
	// computer
		ApplicationInhibitFlagsSuspend ApplicationInhibitFlags = 4
			// ApplicationInhibitFlagsIdle: inhibit the session being marked as idle
	// (and possibly locked)
		ApplicationInhibitFlagsIdle ApplicationInhibitFlags = 8
		)

	
	func marshalApplicationInhibitFlags(p uintptr) (interface{}, error) {
		return ApplicationInhibitFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// AttachOptions denotes the expansion properties that a widget will have when
// it (or its parent) is resized.
	type AttachOptions int

	const (
			// AttachOptionsExpand: the widget should expand to take up any extra space
	// in its container that has been allocated.
		AttachOptionsExpand AttachOptions = 1
			// AttachOptionsShrink: the widget should shrink as and when possible.
		AttachOptionsShrink AttachOptions = 2
			// AttachOptionsFill: the widget should fill the space allocated to it.
		AttachOptionsFill AttachOptions = 4
		)

	
	func marshalAttachOptions(p uintptr) (interface{}, error) {
		return AttachOptions(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// CalendarDisplayOptions: these options can be used to influence the display
// and behaviour of a Calendar.
	type CalendarDisplayOptions int

	const (
			// CalendarDisplayOptionsShowHeading specifies that the month and year
	// should be displayed.
		CalendarDisplayOptionsShowHeading CalendarDisplayOptions = 1
			// CalendarDisplayOptionsShowDayNames specifies that three letter day
	// descriptions should be present.
		CalendarDisplayOptionsShowDayNames CalendarDisplayOptions = 2
			// CalendarDisplayOptionsNoMonthChange prevents the user from switching
	// months with the calendar.
		CalendarDisplayOptionsNoMonthChange CalendarDisplayOptions = 4
			// CalendarDisplayOptionsShowWeekNumbers displays each week numbers of the
	// current year, down the left side of the calendar.
		CalendarDisplayOptionsShowWeekNumbers CalendarDisplayOptions = 8
			// CalendarDisplayOptionsShowDetails: just show an indicator, not the full
	// details text when details are provided. See
	// gtk_calendar_set_detail_func().
		CalendarDisplayOptionsShowDetails CalendarDisplayOptions = 32
		)

	
	func marshalCalendarDisplayOptions(p uintptr) (interface{}, error) {
		return CalendarDisplayOptions(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// CellRendererState tells how a cell is to be rendered.
	type CellRendererState int

	const (
			// CellRendererStateSelected: the cell is currently selected, and probably
	// has a selection colored background to render to.
		CellRendererStateSelected CellRendererState = 1
			// CellRendererStatePrelit: the mouse is hovering over the cell.
		CellRendererStatePrelit CellRendererState = 2
			// CellRendererStateInsensitive: the cell is drawn in an insensitive manner
		CellRendererStateInsensitive CellRendererState = 4
			// CellRendererStateSorted: the cell is in a sorted row
		CellRendererStateSorted CellRendererState = 8
			// CellRendererStateFocused: the cell is in the focus row.
		CellRendererStateFocused CellRendererState = 16
			// CellRendererStateExpandable: the cell is in a row that can be expanded.
	// Since 3.4
		CellRendererStateExpandable CellRendererState = 32
			// CellRendererStateExpanded: the cell is in a row that is expanded. Since
	// 3.4
		CellRendererStateExpanded CellRendererState = 64
		)

	
	func marshalCellRendererState(p uintptr) (interface{}, error) {
		return CellRendererState(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	
	type DebugFlag int

	const (
		DebugFlagMisc DebugFlag = 1
		DebugFlagPlugsocket DebugFlag = 2
		DebugFlagText DebugFlag = 4
		DebugFlagTree DebugFlag = 8
		DebugFlagUpdates DebugFlag = 16
		DebugFlagKeybindings DebugFlag = 32
		DebugFlagMultihead DebugFlag = 64
		DebugFlagModules DebugFlag = 128
		DebugFlagGeometry DebugFlag = 256
		DebugFlagIcontheme DebugFlag = 512
		DebugFlagPrinting DebugFlag = 1024
		DebugFlagBuilder DebugFlag = 2048
		DebugFlagSizeRequest DebugFlag = 4096
		DebugFlagNoCSSCache DebugFlag = 8192
		DebugFlagBaselines DebugFlag = 16384
		DebugFlagPixelCache DebugFlag = 32768
		DebugFlagNoPixelCache DebugFlag = 65536
		DebugFlagInteractive DebugFlag = 131072
		DebugFlagTouchscreen DebugFlag = 262144
		DebugFlagActions DebugFlag = 524288
		DebugFlagResize DebugFlag = 1048576
		DebugFlagLayout DebugFlag = 2097152
		)

	
	func marshalDebugFlag(p uintptr) (interface{}, error) {
		return DebugFlag(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// DestDefaults: the DestDefaults enumeration specifies the various types of
// action that will be taken on behalf of the user for a drag destination site.
	type DestDefaults int

	const (
			// DestDefaultsMotion: if set for a widget, GTK+, during a drag over this
	// widget will check if the drag matches this widget’s list of possible
	// targets and actions. GTK+ will then call gdk_drag_status() as
	// appropriate.
		DestDefaultsMotion DestDefaults = 1
			// DestDefaultsHighlight: if set for a widget, GTK+ will draw a highlight on
	// this widget as long as a drag is over this widget and the widget drag
	// format and action are acceptable.
		DestDefaultsHighlight DestDefaults = 2
			// DestDefaultsDrop: if set for a widget, when a drop occurs, GTK+ will will
	// check if the drag matches this widget’s list of possible targets and
	// actions. If so, GTK+ will call gtk_drag_get_data() on behalf of the
	// widget. Whether or not the drop is successful, GTK+ will call
	// gtk_drag_finish(). If the action was a move, then if the drag was
	// successful, then true will be passed for the @delete parameter to
	// gtk_drag_finish().
		DestDefaultsDrop DestDefaults = 4
			// DestDefaultsAll: if set, specifies that all default actions should be
	// taken.
		DestDefaultsAll DestDefaults = 7
		)

	
	func marshalDestDefaults(p uintptr) (interface{}, error) {
		return DestDefaults(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// DialogFlags flags used to influence dialog construction.
	type DialogFlags int

	const (
			// DialogFlagsModal: make the constructed dialog modal, see
	// gtk_window_set_modal()
		DialogFlagsModal DialogFlags = 1
			// DialogFlagsDestroyWithParent: destroy the dialog when its parent is
	// destroyed, see gtk_window_set_destroy_with_parent()
		DialogFlagsDestroyWithParent DialogFlags = 2
			// DialogFlagsUseHeaderBar: create dialog with actions in header bar instead
	// of action area. Since 3.12.
		DialogFlagsUseHeaderBar DialogFlags = 4
		)

	
	func marshalDialogFlags(p uintptr) (interface{}, error) {
		return DialogFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// EventControllerScrollFlags describes the behavior of a EventControllerScroll.
	type EventControllerScrollFlags int

	const (
			// EventControllerScrollFlagsNone: don't emit scroll.
		EventControllerScrollFlagsNone EventControllerScrollFlags = 0
			// EventControllerScrollFlagsVertical: emit scroll with vertical deltas.
		EventControllerScrollFlagsVertical EventControllerScrollFlags = 1
			// EventControllerScrollFlagsHorizontal: emit scroll with horizontal deltas.
		EventControllerScrollFlagsHorizontal EventControllerScrollFlags = 2
			// EventControllerScrollFlagsDiscrete: only emit deltas that are multiples
	// of 1.
		EventControllerScrollFlagsDiscrete EventControllerScrollFlags = 4
			// EventControllerScrollFlagsKinetic: emit EventControllerScroll::decelerate
	// after continuous scroll finishes.
		EventControllerScrollFlagsKinetic EventControllerScrollFlags = 8
			// EventControllerScrollFlagsBothAxes: emit scroll on both axes.
		EventControllerScrollFlagsBothAxes EventControllerScrollFlags = 3
		)

	
	func marshalEventControllerScrollFlags(p uintptr) (interface{}, error) {
		return EventControllerScrollFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// FileFilterFlags: these flags indicate what parts of a FileFilterInfo struct
// are filled or need to be filled.
	type FileFilterFlags int

	const (
			// FileFilterFlagsFilename: the filename of the file being tested
		FileFilterFlagsFilename FileFilterFlags = 1
			// FileFilterFlagsURI: the URI for the file being tested
		FileFilterFlagsURI FileFilterFlags = 2
			// FileFilterFlagsDisplayName: the string that will be used to display the
	// file in the file chooser
		FileFilterFlagsDisplayName FileFilterFlags = 4
			// FileFilterFlagsMIMEType: the mime type of the file
		FileFilterFlagsMIMEType FileFilterFlags = 8
		)

	
	func marshalFileFilterFlags(p uintptr) (interface{}, error) {
		return FileFilterFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// FontChooserLevel: this enumeration specifies the granularity of font
// selection that is desired in a font chooser.
// 
// This enumeration may be extended in the future; applications should ignore
// unknown values.
	type FontChooserLevel int

	const (
			// FontChooserLevelFamily: allow selecting a font family
		FontChooserLevelFamily FontChooserLevel = 0
			// FontChooserLevelStyle: allow selecting a specific font face
		FontChooserLevelStyle FontChooserLevel = 1
			// FontChooserLevelSize: allow selecting a specific font size
		FontChooserLevelSize FontChooserLevel = 2
		FontChooserLevelVariations FontChooserLevel = 4
			// FontChooserLevelFeatures: allow selecting specific OpenType font features
		FontChooserLevelFeatures FontChooserLevel = 8
		)

	
	func marshalFontChooserLevel(p uintptr) (interface{}, error) {
		return FontChooserLevel(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// IconLookupFlags: used to specify options for gtk_icon_theme_lookup_icon()
	type IconLookupFlags int

	const (
			// IconLookupFlagsNoSvg: never get SVG icons, even if gdk-pixbuf supports
	// them. Cannot be used together with GTK_ICON_LOOKUP_FORCE_SVG.
		IconLookupFlagsNoSvg IconLookupFlags = 1
			// IconLookupFlagsForceSvg: get SVG icons, even if gdk-pixbuf doesn’t
	// support them. Cannot be used together with GTK_ICON_LOOKUP_NO_SVG.
		IconLookupFlagsForceSvg IconLookupFlags = 2
			// IconLookupFlagsUseBuiltin: when passed to gtk_icon_theme_lookup_icon()
	// includes builtin icons as well as files. For a builtin icon,
	// gtk_icon_info_get_filename() is nil and you need to call
	// gtk_icon_info_get_builtin_pixbuf().
		IconLookupFlagsUseBuiltin IconLookupFlags = 4
			// IconLookupFlagsGenericFallback: try to shorten icon name at '-'
	// characters before looking at inherited themes. This flag is only
	// supported in functions that take a single icon name. For more general
	// fallback, see gtk_icon_theme_choose_icon(). Since 2.12.
		IconLookupFlagsGenericFallback IconLookupFlags = 8
			// IconLookupFlagsForceSize always get the icon scaled to the requested
	// size. Since 2.14.
		IconLookupFlagsForceSize IconLookupFlags = 16
			// IconLookupFlagsForceRegular: try to always load regular icons, even when
	// symbolic icon names are given. Since 3.14.
		IconLookupFlagsForceRegular IconLookupFlags = 32
			// IconLookupFlagsForceSymbolic: try to always load symbolic icons, even
	// when regular icon names are given. Since 3.14.
		IconLookupFlagsForceSymbolic IconLookupFlags = 64
			// IconLookupFlagsDirLTR: try to load a variant of the icon for
	// left-to-right text direction. Since 3.14.
		IconLookupFlagsDirLTR IconLookupFlags = 128
			// IconLookupFlagsDirRTL: try to load a variant of the icon for
	// right-to-left text direction. Since 3.14.
		IconLookupFlagsDirRTL IconLookupFlags = 256
		)

	
	func marshalIconLookupFlags(p uintptr) (interface{}, error) {
		return IconLookupFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// InputHints describes hints that might be taken into account by input methods
// or applications. Note that input methods may already tailor their behaviour
// according to the InputPurpose of the entry.
// 
// Some common sense is expected when using these flags - mixing
// @GTK_INPUT_HINT_LOWERCASE with any of the uppercase hints makes no sense.
// 
// This enumeration may be extended in the future; input methods should ignore
// unknown values.
	type InputHints int

	const (
			// InputHintsNone: no special behaviour suggested
		InputHintsNone InputHints = 0
			// InputHintsSpellcheck: suggest checking for typos
		InputHintsSpellcheck InputHints = 1
			// InputHintsNoSpellcheck: suggest not checking for typos
		InputHintsNoSpellcheck InputHints = 2
			// InputHintsWordCompletion: suggest word completion
		InputHintsWordCompletion InputHints = 4
			// InputHintsLowercase: suggest to convert all text to lowercase
		InputHintsLowercase InputHints = 8
			// InputHintsUppercaseChars: suggest to capitalize all text
		InputHintsUppercaseChars InputHints = 16
			// InputHintsUppercaseWords: suggest to capitalize the first character of
	// each word
		InputHintsUppercaseWords InputHints = 32
			// InputHintsUppercaseSentences: suggest to capitalize the first word of
	// each sentence
		InputHintsUppercaseSentences InputHints = 64
			// InputHintsInhibitOsk: suggest to not show an onscreen keyboard (e.g for a
	// calculator that already has all the keys).
		InputHintsInhibitOsk InputHints = 128
			// InputHintsVerticalWriting: the text is vertical. Since 3.18
		InputHintsVerticalWriting InputHints = 256
			// InputHintsEmoji: suggest offering Emoji support. Since 3.22.20
		InputHintsEmoji InputHints = 512
			// InputHintsNoEmoji: suggest not offering Emoji support. Since 3.22.20
		InputHintsNoEmoji InputHints = 1024
		)

	
	func marshalInputHints(p uintptr) (interface{}, error) {
		return InputHints(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// JunctionSides describes how a rendered element connects to adjacent elements.
	type JunctionSides int

	const (
			// JunctionSidesNone: no junctions.
		JunctionSidesNone JunctionSides = 0
			// JunctionSidesCornerTopleft: element connects on the top-left corner.
		JunctionSidesCornerTopleft JunctionSides = 1
			// JunctionSidesCornerTopright: element connects on the top-right corner.
		JunctionSidesCornerTopright JunctionSides = 2
			// JunctionSidesCornerBottomleft: element connects on the bottom-left
	// corner.
		JunctionSidesCornerBottomleft JunctionSides = 4
			// JunctionSidesCornerBottomright: element connects on the bottom-right
	// corner.
		JunctionSidesCornerBottomright JunctionSides = 8
			// JunctionSidesTop: element connects on the top side.
		JunctionSidesTop JunctionSides = 3
			// JunctionSidesBottom: element connects on the bottom side.
		JunctionSidesBottom JunctionSides = 12
			// JunctionSidesLeft: element connects on the left side.
		JunctionSidesLeft JunctionSides = 5
			// JunctionSidesRight: element connects on the right side.
		JunctionSidesRight JunctionSides = 10
		)

	
	func marshalJunctionSides(p uintptr) (interface{}, error) {
		return JunctionSides(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// PlacesOpenFlags: these flags serve two purposes. First, the application can
// call gtk_places_sidebar_set_open_flags() using these flags as a bitmask. This
// tells the sidebar that the application is able to open folders selected from
// the sidebar in various ways, for example, in new tabs or in new windows in
// addition to the normal mode.
// 
// Second, when one of these values gets passed back to the application in the
// PlacesSidebar::open-location signal, it means that the application should
// open the selected location in the normal way, in a new tab, or in a new
// window. The sidebar takes care of determining the desired way to open the
// location, based on the modifier keys that the user is pressing at the time
// the selection is made.
// 
// If the application never calls gtk_places_sidebar_set_open_flags(), then the
// sidebar will only use K_PLACES_OPEN_NORMAL in the
// PlacesSidebar::open-location signal. This is the default mode of operation.
	type PlacesOpenFlags int

	const (
			// PlacesOpenFlagsNormal: this is the default mode that PlacesSidebar uses
	// if no other flags are specified. It indicates that the calling
	// application should open the selected location in the normal way, for
	// example, in the folder view beside the sidebar.
		PlacesOpenFlagsNormal PlacesOpenFlags = 1
			// PlacesOpenFlagsNewTab: when passed to
	// gtk_places_sidebar_set_open_flags(), this indicates that the application
	// can open folders selected from the sidebar in new tabs. This value will
	// be passed to the PlacesSidebar::open-location signal when the user
	// selects that a location be opened in a new tab instead of in the standard
	// fashion.
		PlacesOpenFlagsNewTab PlacesOpenFlags = 2
			// PlacesOpenFlagsNewWindow: similar to @GTK_PLACES_OPEN_NEW_TAB, but
	// indicates that the application can open folders in new windows.
		PlacesOpenFlagsNewWindow PlacesOpenFlags = 4
		)

	
	func marshalPlacesOpenFlags(p uintptr) (interface{}, error) {
		return PlacesOpenFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// RCFlags: deprecated
	type RCFlags int

	const (
			// RCFlagsFg: deprecated
		RCFlagsFg RCFlags = 1
			// RCFlagsBg: deprecated
		RCFlagsBg RCFlags = 2
			// RCFlagsText: deprecated
		RCFlagsText RCFlags = 4
			// RCFlagsBase: deprecated
		RCFlagsBase RCFlags = 8
		)

	
	func marshalRCFlags(p uintptr) (interface{}, error) {
		return RCFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// RecentFilterFlags: these flags indicate what parts of a RecentFilterInfo
// struct are filled or need to be filled.
	type RecentFilterFlags int

	const (
			// RecentFilterFlagsURI: the URI of the file being tested
		RecentFilterFlagsURI RecentFilterFlags = 1
			// RecentFilterFlagsDisplayName: the string that will be used to display the
	// file in the recent chooser
		RecentFilterFlagsDisplayName RecentFilterFlags = 2
			// RecentFilterFlagsMIMEType: the mime type of the file
		RecentFilterFlagsMIMEType RecentFilterFlags = 4
			// RecentFilterFlagsApplication: the list of applications that have
	// registered the file
		RecentFilterFlagsApplication RecentFilterFlags = 8
			// RecentFilterFlagsGroup: the groups to which the file belongs to
		RecentFilterFlagsGroup RecentFilterFlags = 16
			// RecentFilterFlagsAge: the number of days elapsed since the file has been
	// registered
		RecentFilterFlagsAge RecentFilterFlags = 32
		)

	
	func marshalRecentFilterFlags(p uintptr) (interface{}, error) {
		return RecentFilterFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// RegionFlags describes a region within a widget.
	type RegionFlags int

	const (
			// RegionFlagsEven: region has an even number within a set.
		RegionFlagsEven RegionFlags = 1
			// RegionFlagsOdd: region has an odd number within a set.
		RegionFlagsOdd RegionFlags = 2
			// RegionFlagsFirst: region is the first one within a set.
		RegionFlagsFirst RegionFlags = 4
			// RegionFlagsLast: region is the last one within a set.
		RegionFlagsLast RegionFlags = 8
			// RegionFlagsOnly: region is the only one within a set.
		RegionFlagsOnly RegionFlags = 16
			// RegionFlagsSorted: region is part of a sorted area.
		RegionFlagsSorted RegionFlags = 32
		)

	
	func marshalRegionFlags(p uintptr) (interface{}, error) {
		return RegionFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// StateFlags describes a widget state. Widget states are used to match the
// widget against CSS pseudo-classes. Note that GTK extends the regular CSS
// classes and sometimes uses different names.
	type StateFlags int

	const (
			// StateFlagsNormal: state during normal operation.
		StateFlagsNormal StateFlags = 0
			// StateFlagsActive: widget is active.
		StateFlagsActive StateFlags = 1
			// StateFlagsPrelight: widget has a mouse pointer over it.
		StateFlagsPrelight StateFlags = 2
			// StateFlagsSelected: widget is selected.
		StateFlagsSelected StateFlags = 4
			// StateFlagsInsensitive: widget is insensitive.
		StateFlagsInsensitive StateFlags = 8
			// StateFlagsInconsistent: widget is inconsistent.
		StateFlagsInconsistent StateFlags = 16
			// StateFlagsFocused: widget has the keyboard focus.
		StateFlagsFocused StateFlags = 32
			// StateFlagsBackdrop: widget is in a background toplevel window.
		StateFlagsBackdrop StateFlags = 64
			// StateFlagsDirLTR: widget is in left-to-right text direction. Since 3.8
		StateFlagsDirLTR StateFlags = 128
			// StateFlagsDirRTL: widget is in right-to-left text direction. Since 3.8
		StateFlagsDirRTL StateFlags = 256
			// StateFlagsLink: widget is a link. Since 3.12
		StateFlagsLink StateFlags = 512
			// StateFlagsVisited: the location the widget points to has already been
	// visited. Since 3.12
		StateFlagsVisited StateFlags = 1024
			// StateFlagsChecked: widget is checked. Since 3.14
		StateFlagsChecked StateFlags = 2048
			// StateFlagsDropActive: widget is highlighted as a drop target for DND.
	// Since 3.20
		StateFlagsDropActive StateFlags = 4096
		)

	
	func marshalStateFlags(p uintptr) (interface{}, error) {
		return StateFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// StyleContextPrintFlags flags that modify the behavior of
// gtk_style_context_to_string(). New values may be added to this enumeration.
	type StyleContextPrintFlags int

	const (
		StyleContextPrintFlagsNone StyleContextPrintFlags = 0
			// StyleContextPrintFlagsRecurse: print the entire tree of CSS nodes
	// starting at the style context's node
		StyleContextPrintFlagsRecurse StyleContextPrintFlags = 1
			// StyleContextPrintFlagsShowStyle: show the values of the CSS properties
	// for each node
		StyleContextPrintFlagsShowStyle StyleContextPrintFlags = 2
		)

	
	func marshalStyleContextPrintFlags(p uintptr) (interface{}, error) {
		return StyleContextPrintFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// TargetFlags: the TargetFlags enumeration is used to specify constraints on a
// TargetEntry.
	type TargetFlags int

	const (
			// TargetFlagsSameApp: if this is set, the target will only be selected for
	// drags within a single application.
		TargetFlagsSameApp TargetFlags = 1
			// TargetFlagsSameWidget: if this is set, the target will only be selected
	// for drags within a single widget.
		TargetFlagsSameWidget TargetFlags = 2
			// TargetFlagsOtherApp: if this is set, the target will not be selected for
	// drags within a single application.
		TargetFlagsOtherApp TargetFlags = 4
			// TargetFlagsOtherWidget: if this is set, the target will not be selected
	// for drags withing a single widget.
		TargetFlagsOtherWidget TargetFlags = 8
		)

	
	func marshalTargetFlags(p uintptr) (interface{}, error) {
		return TargetFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// TextSearchFlags flags affecting how a search is done.
// 
// If neither K_TEXT_SEARCH_VISIBLE_ONLY nor K_TEXT_SEARCH_TEXT_ONLY are
// enabled, the match must be exact; the special 0xFFFC character will match
// embedded pixbufs or child widgets.
	type TextSearchFlags int

	const (
			// TextSearchFlagsVisibleOnly: search only visible data. A search match may
	// have invisible text interspersed.
		TextSearchFlagsVisibleOnly TextSearchFlags = 1
			// TextSearchFlagsTextOnly: search only text. A match may have pixbufs or
	// child widgets mixed inside the matched range.
		TextSearchFlagsTextOnly TextSearchFlags = 2
			// TextSearchFlagsCaseInsensitive: the text will be matched regardless of
	// what case it is in.
		TextSearchFlagsCaseInsensitive TextSearchFlags = 4
		)

	
	func marshalTextSearchFlags(p uintptr) (interface{}, error) {
		return TextSearchFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// ToolPaletteDragTargets flags used to specify the supported drag targets.
	type ToolPaletteDragTargets int

	const (
			// ToolPaletteDragTargetsItems: support drag of items.
		ToolPaletteDragTargetsItems ToolPaletteDragTargets = 1
			// ToolPaletteDragTargetsGroups: support drag of groups.
		ToolPaletteDragTargetsGroups ToolPaletteDragTargets = 2
		)

	
	func marshalToolPaletteDragTargets(p uintptr) (interface{}, error) {
		return ToolPaletteDragTargets(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// TreeModelFlags: these flags indicate various properties of a TreeModel.
// 
// They are returned by gtk_tree_model_get_flags(), and must be static for the
// lifetime of the object. A more complete description of
// K_TREE_MODEL_ITERS_PERSIST can be found in the overview of this section.
	type TreeModelFlags int

	const (
			// TreeModelFlagsItersPersist iterators survive all signals emitted by the
	// tree
		TreeModelFlagsItersPersist TreeModelFlags = 1
			// TreeModelFlagsListOnly: the model is a list only, and never has children
		TreeModelFlagsListOnly TreeModelFlags = 2
		)

	
	func marshalTreeModelFlags(p uintptr) (interface{}, error) {
		return TreeModelFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// UIManagerItemType: these enumeration values are used by
// gtk_ui_manager_add_ui() to determine what UI element to create.
	type UIManagerItemType int

	const (
			// UIManagerItemTypeAuto: pick the type of the UI element according to
	// context.
		UIManagerItemTypeAuto UIManagerItemType = 0
			// UIManagerItemTypeMenubar: create a menubar.
		UIManagerItemTypeMenubar UIManagerItemType = 1
			// UIManagerItemTypeMenu: create a menu.
		UIManagerItemTypeMenu UIManagerItemType = 2
			// UIManagerItemTypeToolbar: create a toolbar.
		UIManagerItemTypeToolbar UIManagerItemType = 4
			// UIManagerItemTypePlaceholder: insert a placeholder.
		UIManagerItemTypePlaceholder UIManagerItemType = 8
			// UIManagerItemTypePopup: create a popup menu.
		UIManagerItemTypePopup UIManagerItemType = 16
			// UIManagerItemTypeMenuitem: create a menuitem.
		UIManagerItemTypeMenuitem UIManagerItemType = 32
			// UIManagerItemTypeToolitem: create a toolitem.
		UIManagerItemTypeToolitem UIManagerItemType = 64
			// UIManagerItemTypeSeparator: create a separator.
		UIManagerItemTypeSeparator UIManagerItemType = 128
			// UIManagerItemTypeAccelerator: install an accelerator.
		UIManagerItemTypeAccelerator UIManagerItemType = 256
			// UIManagerItemTypePopupWithAccels: same as GTK_UI_MANAGER_POPUP, but the
	// actions’ accelerators are shown.
		UIManagerItemTypePopupWithAccels UIManagerItemType = 512
		)

	
	func marshalUIManagerItemType(p uintptr) (interface{}, error) {
		return UIManagerItemType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	// AccelGroupsActivate finds the first accelerator in any AccelGroup attached to
// @object that matches @accel_key and @accel_mods, and activates that
// accelerator.
	func AccelGroupsActivate(object **externglib.Object, accelKey uint, accelMods gdk.ModifierType) bool {
var _arg1 *C.GObject // out
var _arg2 C.guint // out
var _arg3 C.GdkModifierType // out
var _cret C.gboolean // in

_arg1 = (*C.GObject)(unsafe.Pointer(object.Native()))
_arg2 = (C.guint)(accelKey)
_arg3 = (C.GdkModifierType)(accelMods)

_cret = C.gtk_accel_groups_activate(_arg1, _arg2, _arg3)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}


	// AcceleratorGetDefaultModMask gets the modifier mask.
// 
// The modifier mask determines which modifiers are considered significant for
// keyboard accelerators. See gtk_accelerator_set_default_mod_mask().
	func AcceleratorGetDefaultModMask() gdk.ModifierType {
var _cret C.GdkModifierType // in

_cret = C.gtk_accelerator_get_default_mod_mask()


var _modifierType gdk.ModifierType // out

_modifierType = gdk.ModifierType(_cret)

return _modifierType
}


	// AcceleratorGetLabel converts an accelerator keyval and modifier mask into a
// string which can be used to represent the accelerator to the user.
	func AcceleratorGetLabel(acceleratorKey uint, acceleratorMods gdk.ModifierType) string {
var _arg1 C.guint // out
var _arg2 C.GdkModifierType // out
var _cret *C.gchar // in

_arg1 = (C.guint)(acceleratorKey)
_arg2 = (C.GdkModifierType)(acceleratorMods)

_cret = C.gtk_accelerator_get_label(_arg1, _arg2)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}


	// AcceleratorGetLabelWithKeycode converts an accelerator keyval and modifier
// mask into a (possibly translated) string that can be displayed to a user,
// similarly to gtk_accelerator_get_label(), but handling keycodes.
// 
// This is only useful for system-level components, applications should use
// gtk_accelerator_parse() instead.
	func AcceleratorGetLabelWithKeycode(display gdk.DisplayClass, acceleratorKey uint, keycode uint, acceleratorMods gdk.ModifierType) string {
var _arg1 *C.GdkDisplay // out
var _arg2 C.guint // out
var _arg3 C.guint // out
var _arg4 C.GdkModifierType // out
var _cret *C.gchar // in

_arg1 = (*C.GdkDisplay)(unsafe.Pointer(display.Native()))
_arg2 = (C.guint)(acceleratorKey)
_arg3 = (C.guint)(keycode)
_arg4 = (C.GdkModifierType)(acceleratorMods)

_cret = C.gtk_accelerator_get_label_with_keycode(_arg1, _arg2, _arg3, _arg4)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}


	// AcceleratorName converts an accelerator keyval and modifier mask into a
// string parseable by gtk_accelerator_parse(). For example, if you pass in
// K_KEY_q and K_CONTROL_MASK, this function returns “<Control>q”.
// 
// If you need to display accelerators in the user interface, see
// gtk_accelerator_get_label().
	func AcceleratorName(acceleratorKey uint, acceleratorMods gdk.ModifierType) string {
var _arg1 C.guint // out
var _arg2 C.GdkModifierType // out
var _cret *C.gchar // in

_arg1 = (C.guint)(acceleratorKey)
_arg2 = (C.GdkModifierType)(acceleratorMods)

_cret = C.gtk_accelerator_name(_arg1, _arg2)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}


	// AcceleratorNameWithKeycode converts an accelerator keyval and modifier mask
// into a string parseable by gtk_accelerator_parse_with_keycode(), similarly to
// gtk_accelerator_name() but handling keycodes. This is only useful for
// system-level components, applications should use gtk_accelerator_parse()
// instead.
	func AcceleratorNameWithKeycode(display gdk.DisplayClass, acceleratorKey uint, keycode uint, acceleratorMods gdk.ModifierType) string {
var _arg1 *C.GdkDisplay // out
var _arg2 C.guint // out
var _arg3 C.guint // out
var _arg4 C.GdkModifierType // out
var _cret *C.gchar // in

_arg1 = (*C.GdkDisplay)(unsafe.Pointer(display.Native()))
_arg2 = (C.guint)(acceleratorKey)
_arg3 = (C.guint)(keycode)
_arg4 = (C.GdkModifierType)(acceleratorMods)

_cret = C.gtk_accelerator_name_with_keycode(_arg1, _arg2, _arg3, _arg4)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}


	// AcceleratorParse parses a string representing an accelerator. The format
// looks like “<Control>a” or “<Shift><Alt>F1” or “<Release>z” (the last one is
// for key release).
// 
// The parser is fairly liberal and allows lower or upper case, and also
// abbreviations such as “<Ctl>” and “<Ctrl>”. Key names are parsed using
// gdk_keyval_from_name(). For character keys the name is not the symbol, but
// the lowercase name, e.g. one would use “<Ctrl>minus” instead of “<Ctrl>-”.
// 
// If the parse fails, @accelerator_key and @accelerator_mods will be set to 0
// (zero).
	func AcceleratorParse(accelerator string) (uint, gdk.ModifierType) {
var _arg1 *C.gchar // out
var _arg2 C.guint // in
var _arg3 C.GdkModifierType // in

_arg1 = (*C.gchar)(C.CString(accelerator))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_accelerator_parse(_arg1, &_arg2, &_arg3)

var _acceleratorKey uint // out
var _acceleratorMods gdk.ModifierType // out

_acceleratorKey = (uint)(_arg2)
_acceleratorMods = gdk.ModifierType(_arg3)

return _acceleratorKey, _acceleratorMods
}


	// AcceleratorParseWithKeycode parses a string representing an accelerator,
// similarly to gtk_accelerator_parse() but handles keycodes as well. This is
// only useful for system-level components, applications should use
// gtk_accelerator_parse() instead.
// 
// If @accelerator_codes is given and the result stored in it is non-nil, the
// result must be freed with g_free().
// 
// If a keycode is present in the accelerator and no @accelerator_codes is
// given, the parse will fail.
// 
// If the parse fails, @accelerator_key, @accelerator_mods and
// @accelerator_codes will be set to 0 (zero).
	func AcceleratorParseWithKeycode(accelerator string) (uint, []uint, gdk.ModifierType) {
var _arg1 *C.gchar // out
var _arg2 C.guint // in
var _arg3 *C.guint
var _arg4 C.GdkModifierType // in

_arg1 = (*C.gchar)(C.CString(accelerator))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_accelerator_parse_with_keycode(_arg1, &_arg2, &_arg3, &_arg4)

var _acceleratorKey uint // out
var _acceleratorCodes []uint
var _acceleratorMods gdk.ModifierType // out

_acceleratorKey = (uint)(_arg2)
{
var i int
var z C.guint
for p := _arg3; *p != z; p = &unsafe.Slice(p, i+1)[i] {
  i++
}

src := unsafe.Slice(_arg3, i)
_acceleratorCodes = make([]uint, i)
for i := range src {
_acceleratorCodes[i] = (uint)(src[i])
}
}
_acceleratorMods = gdk.ModifierType(_arg4)

return _acceleratorKey, _acceleratorCodes, _acceleratorMods
}


	// AcceleratorSetDefaultModMask sets the modifiers that will be considered
// significant for keyboard accelerators. The default mod mask depends on the
// GDK backend in use, but will typically include K_CONTROL_MASK | K_SHIFT_MASK
// | K_MOD1_MASK | K_SUPER_MASK | K_HYPER_MASK | K_META_MASK. In other words,
// Control, Shift, Alt, Super, Hyper and Meta. Other modifiers will by default
// be ignored by AccelGroup.
// 
// You must include at least the three modifiers Control, Shift and Alt in any
// value you pass to this function.
// 
// The default mod mask should be changed on application startup, before using
// any accelerator groups.
	func AcceleratorSetDefaultModMask(defaultModMask gdk.ModifierType)  {
var _arg1 C.GdkModifierType // out

_arg1 = (C.GdkModifierType)(defaultModMask)

C.gtk_accelerator_set_default_mod_mask(_arg1)
}


	// AcceleratorValid determines whether a given keyval and modifier mask
// constitute a valid keyboard accelerator. For example, the K_KEY_a keyval plus
// K_CONTROL_MASK is valid - this is a “Ctrl+a” accelerator. But, you can't, for
// instance, use the K_KEY_Control_L keyval as an accelerator.
	func AcceleratorValid(keyval uint, modifiers gdk.ModifierType) bool {
var _arg1 C.guint // out
var _arg2 C.GdkModifierType // out
var _cret C.gboolean // in

_arg1 = (C.guint)(keyval)
_arg2 = (C.GdkModifierType)(modifiers)

_cret = C.gtk_accelerator_valid(_arg1, _arg2)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}


	// AlternativeDialogButtonOrder returns true if dialogs are expected to use an
// alternative button order on the screen @screen. See
// gtk_dialog_set_alternative_button_order() for more details about alternative
// button order.
// 
// If you need to use this function, you should probably connect to the
// ::notify:gtk-alternative-button-order signal on the Settings object
// associated to @screen, in order to be notified if the button order setting
// changes.
	func AlternativeDialogButtonOrder(screen gdk.ScreenClass) bool {
var _arg1 *C.GdkScreen // out
var _cret C.gboolean // in

_arg1 = (*C.GdkScreen)(unsafe.Pointer(screen.Native()))

_cret = C.gtk_alternative_dialog_button_order(_arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}


	// BindingsActivate: find a key binding matching @keyval and @modifiers and
// activate the binding on @object.
	func BindingsActivate(object **externglib.Object, keyval uint, modifiers gdk.ModifierType) bool {
var _arg1 *C.GObject // out
var _arg2 C.guint // out
var _arg3 C.GdkModifierType // out
var _cret C.gboolean // in

_arg1 = (*C.GObject)(unsafe.Pointer(object.Native()))
_arg2 = (C.guint)(keyval)
_arg3 = (C.GdkModifierType)(modifiers)

_cret = C.gtk_bindings_activate(_arg1, _arg2, _arg3)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}


	// BindingsActivateEvent looks up key bindings for @object to find one matching
// @event, and if one was found, activate it.
	func BindingsActivateEvent(object **externglib.Object, event *gdk.EventKey) bool {
var _arg1 *C.GObject // out
var _arg2 *C.GdkEventKey // out
var _cret C.gboolean // in

_arg1 = (*C.GObject)(unsafe.Pointer(object.Native()))
_arg2 = (*C.GdkEventKey)(unsafe.Pointer(event.Native()))

_cret = C.gtk_bindings_activate_event(_arg1, _arg2)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}


	// CairoShouldDrawWindow: this function is supposed to be called in Widget::draw
// implementations for widgets that support multiple windows. @cr must be
// untransformed from invoking of the draw function. This function will return
// true if the contents of the given @window are supposed to be drawn and false
// otherwise. Note that when the drawing was not initiated by the windowing
// system this function will return true for all windows, so you need to draw
// the bottommost window first. Also, do not use “else if” statements to check
// which window should be drawn.
	func CairoShouldDrawWindow(cr *cairo.Context, window gdk.WindowClass) bool {
var _arg1 *C.cairo_t // out
var _arg2 *C.GdkWindow // out
var _cret C.gboolean // in

_arg1 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
_arg2 = (*C.GdkWindow)(unsafe.Pointer(window.Native()))

_cret = C.gtk_cairo_should_draw_window(_arg1, _arg2)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}


	// CairoTransformToWindow transforms the given cairo context @cr that from
// @widget-relative coordinates to @window-relative coordinates. If the
// @widget’s window is not an ancestor of @window, no modification will be
// applied.
// 
// This is the inverse to the transformation GTK applies when preparing an
// expose event to be emitted with the Widget::draw signal. It is intended to
// help porting multiwindow widgets from GTK+ 2 to the rendering architecture of
// GTK+ 3.
	func CairoTransformToWindow(cr *cairo.Context, widget WidgetClass, window gdk.WindowClass)  {
var _arg1 *C.cairo_t // out
var _arg2 *C.GtkWidget // out
var _arg3 *C.GdkWindow // out

_arg1 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
_arg2 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg3 = (*C.GdkWindow)(unsafe.Pointer(window.Native()))

C.gtk_cairo_transform_to_window(_arg1, _arg2, _arg3)
}


	// CheckVersion checks that the GTK+ library in use is compatible with the given
// version. Generally you would pass in the constants K_MAJOR_VERSION,
// K_MINOR_VERSION, K_MICRO_VERSION as the three arguments to this function;
// that produces a check that the library in use is compatible with the version
// of GTK+ the application or module was compiled against.
// 
// Compatibility is defined by two things: first the version of the running
// library is newer than the version
// @required_major.required_minor.@required_micro. Second the running library
// must be binary compatible with the version
// @required_major.required_minor.@required_micro (same major version.)
// 
// This function is primarily for GTK+ modules; the module can call this
// function to check that it wasn’t loaded into an incompatible version of GTK+.
// However, such a check isn’t completely reliable, since the module may be
// linked against an old version of GTK+ and calling the old version of
// gtk_check_version(), but still get loaded into an application using a newer
// version of GTK+.
	func CheckVersion(requiredMajor uint, requiredMinor uint, requiredMicro uint) string {
var _arg1 C.guint // out
var _arg2 C.guint // out
var _arg3 C.guint // out
var _cret *C.gchar // in

_arg1 = (C.guint)(requiredMajor)
_arg2 = (C.guint)(requiredMinor)
_arg3 = (C.guint)(requiredMicro)

_cret = C.gtk_check_version(_arg1, _arg2, _arg3)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}


	// DeviceGrabAdd adds a GTK+ grab on @device, so all the events on @device and
// its associated pointer or keyboard (if any) are delivered to @widget. If the
// @block_others parameter is true, any other devices will be unable to interact
// with @widget during the grab.
	func DeviceGrabAdd(widget WidgetClass, device gdk.DeviceClass, blockOthers bool)  {
var _arg1 *C.GtkWidget // out
var _arg2 *C.GdkDevice // out
var _arg3 C.gboolean // out

_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg2 = (*C.GdkDevice)(unsafe.Pointer(device.Native()))
if blockOthers { _arg3 = C.TRUE }

C.gtk_device_grab_add(_arg1, _arg2, _arg3)
}


	// DeviceGrabRemove removes a device grab from the given widget.
// 
// You have to pair calls to gtk_device_grab_add() and gtk_device_grab_remove().
	func DeviceGrabRemove(widget WidgetClass, device gdk.DeviceClass)  {
var _arg1 *C.GtkWidget // out
var _arg2 *C.GdkDevice // out

_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg2 = (*C.GdkDevice)(unsafe.Pointer(device.Native()))

C.gtk_device_grab_remove(_arg1, _arg2)
}


	// DisableSetlocale prevents gtk_init(), gtk_init_check(), gtk_init_with_args()
// and gtk_parse_args() from automatically calling `setlocale (LC_ALL, "")`. You
// would want to use this function if you wanted to set the locale for your
// program to something other than the user’s locale, or if you wanted to set
// different values for different locale categories.
// 
// Most programs should not need to call this function.
	func DisableSetlocale()  {
C.gtk_disable_setlocale()
}


	// DistributeNaturalAllocation distributes @extra_space to child @sizes by
// bringing smaller children up to natural size first.
// 
// The remaining space will be added to the @minimum_size member of the
// GtkRequestedSize struct. If all sizes reach their natural size then the
// remaining space is returned.
	func DistributeNaturalAllocation(extraSpace int, nRequestedSizes uint, sizes *RequestedSize) int {
var _arg1 C.gint // out
var _arg2 C.guint // out
var _arg3 *C.GtkRequestedSize // out
var _cret C.gint // in

_arg1 = (C.gint)(extraSpace)
_arg2 = (C.guint)(nRequestedSizes)
_arg3 = (*C.GtkRequestedSize)(unsafe.Pointer(sizes.Native()))

_cret = C.gtk_distribute_natural_allocation(_arg1, _arg2, _arg3)


var _gint int // out

_gint = (int)(_cret)

return _gint
}


	// DragCancel cancels an ongoing drag operation on the source side.
// 
// If you want to be able to cancel a drag operation in this way, you need to
// keep a pointer to the drag context, either from an explicit call to
// gtk_drag_begin_with_coordinates(), or by connecting to Widget::drag-begin.
// 
// If @context does not refer to an ongoing drag operation, this function does
// nothing.
// 
// If a drag is cancelled in this way, the @result argument of
// Widget::drag-failed is set to @GTK_DRAG_RESULT_ERROR.
	func DragCancel(context gdk.DragContextClass)  {
var _arg1 *C.GdkDragContext // out

_arg1 = (*C.GdkDragContext)(unsafe.Pointer(context.Native()))

C.gtk_drag_cancel(_arg1)
}


	// DragFinish informs the drag source that the drop is finished, and that the
// data of the drag will no longer be required.
	func DragFinish(context gdk.DragContextClass, success bool, del bool, time_ uint32)  {
var _arg1 *C.GdkDragContext // out
var _arg2 C.gboolean // out
var _arg3 C.gboolean // out
var _arg4 C.guint32 // out

_arg1 = (*C.GdkDragContext)(unsafe.Pointer(context.Native()))
if success { _arg2 = C.TRUE }
if del { _arg3 = C.TRUE }
_arg4 = (C.guint32)(time_)

C.gtk_drag_finish(_arg1, _arg2, _arg3, _arg4)
}


	// DragGetSourceWidget determines the source widget for a drag.
	func DragGetSourceWidget(context gdk.DragContextClass) Widget {
var _arg1 *C.GdkDragContext // out
var _cret *C.GtkWidget // in

_arg1 = (*C.GdkDragContext)(unsafe.Pointer(context.Native()))

_cret = C.gtk_drag_get_source_widget(_arg1)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}


	// DragSetIconDefault sets the icon for a particular drag to the default icon.
	func DragSetIconDefault(context gdk.DragContextClass)  {
var _arg1 *C.GdkDragContext // out

_arg1 = (*C.GdkDragContext)(unsafe.Pointer(context.Native()))

C.gtk_drag_set_icon_default(_arg1)
}


	// DragSetIconGIcon sets the icon for a given drag from the given @icon. See the
// documentation for gtk_drag_set_icon_name() for more details about using icons
// in drag and drop.
	func DragSetIconGIcon(context gdk.DragContextClass, icon gio.Icon, hotX int, hotY int)  {
var _arg1 *C.GdkDragContext // out
var _arg2 *C.GIcon // out
var _arg3 C.gint // out
var _arg4 C.gint // out

_arg1 = (*C.GdkDragContext)(unsafe.Pointer(context.Native()))
_arg2 = (*C.GIcon)(unsafe.Pointer(icon.Native()))
_arg3 = (C.gint)(hotX)
_arg4 = (C.gint)(hotY)

C.gtk_drag_set_icon_gicon(_arg1, _arg2, _arg3, _arg4)
}


	// DragSetIconName sets the icon for a given drag from a named themed icon. See
// the docs for IconTheme for more details. Note that the size of the icon
// depends on the icon theme (the icon is loaded at the symbolic size
// K_ICON_SIZE_DND), thus @hot_x and @hot_y have to be used with care.
	func DragSetIconName(context gdk.DragContextClass, iconName string, hotX int, hotY int)  {
var _arg1 *C.GdkDragContext // out
var _arg2 *C.gchar // out
var _arg3 C.gint // out
var _arg4 C.gint // out

_arg1 = (*C.GdkDragContext)(unsafe.Pointer(context.Native()))
_arg2 = (*C.gchar)(C.CString(iconName))
defer C.free(unsafe.Pointer(_arg2))
_arg3 = (C.gint)(hotX)
_arg4 = (C.gint)(hotY)

C.gtk_drag_set_icon_name(_arg1, _arg2, _arg3, _arg4)
}


	// DragSetIconPixbuf sets @pixbuf as the icon for a given drag.
	func DragSetIconPixbuf(context gdk.DragContextClass, pixbuf gdkpixbuf.PixbufClass, hotX int, hotY int)  {
var _arg1 *C.GdkDragContext // out
var _arg2 *C.GdkPixbuf // out
var _arg3 C.gint // out
var _arg4 C.gint // out

_arg1 = (*C.GdkDragContext)(unsafe.Pointer(context.Native()))
_arg2 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))
_arg3 = (C.gint)(hotX)
_arg4 = (C.gint)(hotY)

C.gtk_drag_set_icon_pixbuf(_arg1, _arg2, _arg3, _arg4)
}


	// DragSetIconStock sets the icon for a given drag from a stock ID.
	func DragSetIconStock(context gdk.DragContextClass, stockId string, hotX int, hotY int)  {
var _arg1 *C.GdkDragContext // out
var _arg2 *C.gchar // out
var _arg3 C.gint // out
var _arg4 C.gint // out

_arg1 = (*C.GdkDragContext)(unsafe.Pointer(context.Native()))
_arg2 = (*C.gchar)(C.CString(stockId))
defer C.free(unsafe.Pointer(_arg2))
_arg3 = (C.gint)(hotX)
_arg4 = (C.gint)(hotY)

C.gtk_drag_set_icon_stock(_arg1, _arg2, _arg3, _arg4)
}


	// DragSetIconSurface sets @surface as the icon for a given drag. GTK+ retains
// references for the arguments, and will release them when they are no longer
// needed.
// 
// To position the surface relative to the mouse, use
// cairo_surface_set_device_offset() on @surface. The mouse cursor will be
// positioned at the (0,0) coordinate of the surface.
	func DragSetIconSurface(context gdk.DragContextClass, surface *cairo.Surface)  {
var _arg1 *C.GdkDragContext // out
var _arg2 *C.cairo_surface_t // out

_arg1 = (*C.GdkDragContext)(unsafe.Pointer(context.Native()))
_arg2 = (*C.cairo_surface_t)(unsafe.Pointer(surface.Native()))

C.gtk_drag_set_icon_surface(_arg1, _arg2)
}


	// DragSetIconWidget changes the icon for drag operation to a given widget. GTK+
// will not destroy the widget, so if you don’t want it to persist, you should
// connect to the “drag-end” signal and destroy it yourself.
	func DragSetIconWidget(context gdk.DragContextClass, widget WidgetClass, hotX int, hotY int)  {
var _arg1 *C.GdkDragContext // out
var _arg2 *C.GtkWidget // out
var _arg3 C.gint // out
var _arg4 C.gint // out

_arg1 = (*C.GdkDragContext)(unsafe.Pointer(context.Native()))
_arg2 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg3 = (C.gint)(hotX)
_arg4 = (C.gint)(hotY)

C.gtk_drag_set_icon_widget(_arg1, _arg2, _arg3, _arg4)
}


	// DrawInsertionCursor draws a text caret on @cr at @location. This is not a
// style function but merely a convenience function for drawing the standard
// cursor shape.
	func DrawInsertionCursor(widget WidgetClass, cr *cairo.Context, location *gdk.Rectangle, isPrimary bool, direction TextDirection, drawArrow bool)  {
var _arg1 *C.GtkWidget // out
var _arg2 *C.cairo_t // out
var _arg3 *C.GdkRectangle // out
var _arg4 C.gboolean // out
var _arg5 C.GtkTextDirection // out
var _arg6 C.gboolean // out

_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
_arg3 = (*C.GdkRectangle)(unsafe.Pointer(location.Native()))
if isPrimary { _arg4 = C.TRUE }
_arg5 = (C.GtkTextDirection)(direction)
if drawArrow { _arg6 = C.TRUE }

C.gtk_draw_insertion_cursor(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
}


	// EventsPending checks if any events are pending.
// 
// This can be used to update the UI and invoke timeouts etc. while doing some
// time intensive computation.
// 
// Updating the UI during a long computation
// 
//     // computation going on...
// 
//     while (gtk_events_pending ())
//       gtk_main_iteration ();
// 
//     // ...computation continued
	func EventsPending() bool {
var _cret C.gboolean // in

_cret = C.gtk_events_pending()


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}


	// False: analogical to gtk_true(), this function does nothing but always
// returns false.
	func False() bool {
var _cret C.gboolean // in

_cret = C.gtk_false()


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}


	// GetBinaryAge returns the binary age as passed to `libtool` when building the
// GTK+ library the process is running against. If `libtool` means nothing to
// you, don't worry about it.
	func GetBinaryAge() uint {
var _cret C.guint // in

_cret = C.gtk_get_binary_age()


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}


	// GetCurrentEventDevice: if there is a current event and it has a device,
// return that device, otherwise return nil.
	func GetCurrentEventDevice() gdk.Device {
var _cret *C.GdkDevice // in

_cret = C.gtk_get_current_event_device()


var _device gdk.Device // out

_device = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Device)

return _device
}


	// GetCurrentEventState: if there is a current event and it has a state field,
// place that state field in @state and return true, otherwise return false.
	func GetCurrentEventState() (gdk.ModifierType, bool) {
var _arg1 C.GdkModifierType // in
var _cret C.gboolean // in

_cret = C.gtk_get_current_event_state(&_arg1)


var _state gdk.ModifierType // out
var _ok bool // out

_state = gdk.ModifierType(_arg1)
if _cret != 0 { _ok = true }

return _state, _ok
}


	// GetCurrentEventTime: if there is a current event and it has a timestamp,
// return that timestamp, otherwise return GDK_CURRENT_TIME.
	func GetCurrentEventTime() uint32 {
var _cret C.guint32 // in

_cret = C.gtk_get_current_event_time()


var _guint32 uint32 // out

_guint32 = (uint32)(_cret)

return _guint32
}


	// GetDebugFlags returns the GTK+ debug flags.
// 
// This function is intended for GTK+ modules that want to adjust their debug
// output based on GTK+ debug flags.
	func GetDebugFlags() uint {
var _cret C.guint // in

_cret = C.gtk_get_debug_flags()


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}


	// GetDefaultLanguage returns the Language for the default language currently in
// effect. (Note that this can change over the life of an application.) The
// default language is derived from the current locale. It determines, for
// example, whether GTK+ uses the right-to-left or left-to-right text direction.
// 
// This function is equivalent to pango_language_get_default(). See that
// function for details.
	func GetDefaultLanguage() *pango.Language {
var _cret *C.PangoLanguage // in

_cret = C.gtk_get_default_language()


var _language *pango.Language // out

_language = *(**pango.Language)(unsafe.Pointer(&_cret))

return _language
}


	// GetInterfaceAge returns the interface age as passed to `libtool` when
// building the GTK+ library the process is running against. If `libtool` means
// nothing to you, don't worry about it.
	func GetInterfaceAge() uint {
var _cret C.guint // in

_cret = C.gtk_get_interface_age()


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}


	// GetLocaleDirection: get the direction of the current locale. This is the
// expected reading direction for text and UI.
// 
// This function depends on the current locale being set with setlocale() and
// will default to setting the GTK_TEXT_DIR_LTR direction otherwise.
// GTK_TEXT_DIR_NONE will never be returned.
// 
// GTK+ sets the default text direction according to the locale during
// gtk_init(), and you should normally use gtk_widget_get_direction() or
// gtk_widget_get_default_direction() to obtain the current direcion.
// 
// This function is only needed rare cases when the locale is changed after GTK+
// has already been initialized. In this case, you can use it to update the
// default text direction as follows:
// 
//    setlocale (LC_ALL, new_locale);
//    direction = gtk_get_locale_direction ();
//    gtk_widget_set_default_direction (direction);
	func GetLocaleDirection() TextDirection {
var _cret C.GtkTextDirection // in

_cret = C.gtk_get_locale_direction()


var _textDirection TextDirection // out

_textDirection = TextDirection(_cret)

return _textDirection
}


	// GetMajorVersion returns the major version number of the GTK+ library. (e.g.
// in GTK+ version 3.1.5 this is 3.)
// 
// This function is in the library, so it represents the GTK+ library your code
// is running against. Contrast with the K_MAJOR_VERSION macro, which represents
// the major version of the GTK+ headers you have included when compiling your
// code.
	func GetMajorVersion() uint {
var _cret C.guint // in

_cret = C.gtk_get_major_version()


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}


	// GetMicroVersion returns the micro version number of the GTK+ library. (e.g.
// in GTK+ version 3.1.5 this is 5.)
// 
// This function is in the library, so it represents the GTK+ library your code
// is are running against. Contrast with the K_MICRO_VERSION macro, which
// represents the micro version of the GTK+ headers you have included when
// compiling your code.
	func GetMicroVersion() uint {
var _cret C.guint // in

_cret = C.gtk_get_micro_version()


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}


	// GetMinorVersion returns the minor version number of the GTK+ library. (e.g.
// in GTK+ version 3.1.5 this is 1.)
// 
// This function is in the library, so it represents the GTK+ library your code
// is are running against. Contrast with the K_MINOR_VERSION macro, which
// represents the minor version of the GTK+ headers you have included when
// compiling your code.
	func GetMinorVersion() uint {
var _cret C.guint // in

_cret = C.gtk_get_minor_version()


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}


	// GetOptionGroup returns a Group for the commandline arguments recognized by
// GTK+ and GDK.
// 
// You should add this group to your Context with g_option_context_add_group(),
// if you are using g_option_context_parse() to parse your commandline
// arguments.
	func GetOptionGroup(openDefaultDisplay bool) *glib.OptionGroup {
var _arg1 C.gboolean // out
var _cret *C.GOptionGroup // in

if openDefaultDisplay { _arg1 = C.TRUE }

_cret = C.gtk_get_option_group(_arg1)


var _optionGroup *glib.OptionGroup // out

_optionGroup = *(**glib.OptionGroup)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_optionGroup, func(v *glib.OptionGroup) {
  C.free(unsafe.Pointer(v.Native()))
})

return _optionGroup
}


	// GrabGetCurrent queries the current grab of the default window group.
	func GrabGetCurrent() Widget {
var _cret *C.GtkWidget // in

_cret = C.gtk_grab_get_current()


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}


	// KeySnooperRemove removes the key snooper function with the given id.
	func KeySnooperRemove(snooperHandlerId uint)  {
var _arg1 C.guint // out

_arg1 = (C.guint)(snooperHandlerId)

C.gtk_key_snooper_remove(_arg1)
}


	// Main runs the main loop until gtk_main_quit() is called.
// 
// You can nest calls to gtk_main(). In that case gtk_main_quit() will make the
// innermost invocation of the main loop return.
	func Main()  {
C.gtk_main()
}


	// MainIteration runs a single iteration of the mainloop.
// 
// If no events are waiting to be processed GTK+ will block until the next event
// is noticed. If you don’t want to block look at gtk_main_iteration_do() or
// check if any events are pending with gtk_events_pending() first.
	func MainIteration() bool {
var _cret C.gboolean // in

_cret = C.gtk_main_iteration()


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}


	// MainIterationDo runs a single iteration of the mainloop. If no events are
// available either return or block depending on the value of @blocking.
	func MainIterationDo(blocking bool) bool {
var _arg1 C.gboolean // out
var _cret C.gboolean // in

if blocking { _arg1 = C.TRUE }

_cret = C.gtk_main_iteration_do(_arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}


	// MainLevel asks for the current nesting level of the main loop.
	func MainLevel() uint {
var _cret C.guint // in

_cret = C.gtk_main_level()


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}


	// MainQuit makes the innermost invocation of the main loop return when it
// regains control.
	func MainQuit()  {
C.gtk_main_quit()
}


	// PaintArrow draws an arrow in the given rectangle on @cr using the given
// parameters. @arrow_type determines the direction of the arrow.
	func PaintArrow(style StyleClass, cr *cairo.Context, stateType StateType, shadowType ShadowType, widget WidgetClass, detail string, arrowType ArrowType, fill bool, x int, y int, width int, height int)  {
var _arg1 *C.GtkStyle // out
var _arg2 *C.cairo_t // out
var _arg3 C.GtkStateType // out
var _arg4 C.GtkShadowType // out
var _arg5 *C.GtkWidget // out
var _arg6 *C.gchar // out
var _arg7 C.GtkArrowType // out
var _arg8 C.gboolean // out
var _arg9 C.gint // out
var _arg10 C.gint // out
var _arg11 C.gint // out
var _arg12 C.gint // out

_arg1 = (*C.GtkStyle)(unsafe.Pointer(style.Native()))
_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
_arg3 = (C.GtkStateType)(stateType)
_arg4 = (C.GtkShadowType)(shadowType)
_arg5 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg6 = (*C.gchar)(C.CString(detail))
defer C.free(unsafe.Pointer(_arg6))
_arg7 = (C.GtkArrowType)(arrowType)
if fill { _arg8 = C.TRUE }
_arg9 = (C.gint)(x)
_arg10 = (C.gint)(y)
_arg11 = (C.gint)(width)
_arg12 = (C.gint)(height)

C.gtk_paint_arrow(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, _arg10, _arg11, _arg12)
}


	// PaintBox draws a box on @cr with the given parameters.
	func PaintBox(style StyleClass, cr *cairo.Context, stateType StateType, shadowType ShadowType, widget WidgetClass, detail string, x int, y int, width int, height int)  {
var _arg1 *C.GtkStyle // out
var _arg2 *C.cairo_t // out
var _arg3 C.GtkStateType // out
var _arg4 C.GtkShadowType // out
var _arg5 *C.GtkWidget // out
var _arg6 *C.gchar // out
var _arg7 C.gint // out
var _arg8 C.gint // out
var _arg9 C.gint // out
var _arg10 C.gint // out

_arg1 = (*C.GtkStyle)(unsafe.Pointer(style.Native()))
_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
_arg3 = (C.GtkStateType)(stateType)
_arg4 = (C.GtkShadowType)(shadowType)
_arg5 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg6 = (*C.gchar)(C.CString(detail))
defer C.free(unsafe.Pointer(_arg6))
_arg7 = (C.gint)(x)
_arg8 = (C.gint)(y)
_arg9 = (C.gint)(width)
_arg10 = (C.gint)(height)

C.gtk_paint_box(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, _arg10)
}


	// PaintBoxGap draws a box in @cr using the given style and state and shadow
// type, leaving a gap in one side.
	func PaintBoxGap(style StyleClass, cr *cairo.Context, stateType StateType, shadowType ShadowType, widget WidgetClass, detail string, x int, y int, width int, height int, gapSide PositionType, gapX int, gapWidth int)  {
var _arg1 *C.GtkStyle // out
var _arg2 *C.cairo_t // out
var _arg3 C.GtkStateType // out
var _arg4 C.GtkShadowType // out
var _arg5 *C.GtkWidget // out
var _arg6 *C.gchar // out
var _arg7 C.gint // out
var _arg8 C.gint // out
var _arg9 C.gint // out
var _arg10 C.gint // out
var _arg11 C.GtkPositionType // out
var _arg12 C.gint // out
var _arg13 C.gint // out

_arg1 = (*C.GtkStyle)(unsafe.Pointer(style.Native()))
_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
_arg3 = (C.GtkStateType)(stateType)
_arg4 = (C.GtkShadowType)(shadowType)
_arg5 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg6 = (*C.gchar)(C.CString(detail))
defer C.free(unsafe.Pointer(_arg6))
_arg7 = (C.gint)(x)
_arg8 = (C.gint)(y)
_arg9 = (C.gint)(width)
_arg10 = (C.gint)(height)
_arg11 = (C.GtkPositionType)(gapSide)
_arg12 = (C.gint)(gapX)
_arg13 = (C.gint)(gapWidth)

C.gtk_paint_box_gap(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, _arg10, _arg11, _arg12, _arg13)
}


	// PaintCheck draws a check button indicator in the given rectangle on @cr with
// the given parameters.
	func PaintCheck(style StyleClass, cr *cairo.Context, stateType StateType, shadowType ShadowType, widget WidgetClass, detail string, x int, y int, width int, height int)  {
var _arg1 *C.GtkStyle // out
var _arg2 *C.cairo_t // out
var _arg3 C.GtkStateType // out
var _arg4 C.GtkShadowType // out
var _arg5 *C.GtkWidget // out
var _arg6 *C.gchar // out
var _arg7 C.gint // out
var _arg8 C.gint // out
var _arg9 C.gint // out
var _arg10 C.gint // out

_arg1 = (*C.GtkStyle)(unsafe.Pointer(style.Native()))
_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
_arg3 = (C.GtkStateType)(stateType)
_arg4 = (C.GtkShadowType)(shadowType)
_arg5 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg6 = (*C.gchar)(C.CString(detail))
defer C.free(unsafe.Pointer(_arg6))
_arg7 = (C.gint)(x)
_arg8 = (C.gint)(y)
_arg9 = (C.gint)(width)
_arg10 = (C.gint)(height)

C.gtk_paint_check(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, _arg10)
}


	// PaintDiamond draws a diamond in the given rectangle on @window using the
// given parameters.
	func PaintDiamond(style StyleClass, cr *cairo.Context, stateType StateType, shadowType ShadowType, widget WidgetClass, detail string, x int, y int, width int, height int)  {
var _arg1 *C.GtkStyle // out
var _arg2 *C.cairo_t // out
var _arg3 C.GtkStateType // out
var _arg4 C.GtkShadowType // out
var _arg5 *C.GtkWidget // out
var _arg6 *C.gchar // out
var _arg7 C.gint // out
var _arg8 C.gint // out
var _arg9 C.gint // out
var _arg10 C.gint // out

_arg1 = (*C.GtkStyle)(unsafe.Pointer(style.Native()))
_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
_arg3 = (C.GtkStateType)(stateType)
_arg4 = (C.GtkShadowType)(shadowType)
_arg5 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg6 = (*C.gchar)(C.CString(detail))
defer C.free(unsafe.Pointer(_arg6))
_arg7 = (C.gint)(x)
_arg8 = (C.gint)(y)
_arg9 = (C.gint)(width)
_arg10 = (C.gint)(height)

C.gtk_paint_diamond(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, _arg10)
}


	// PaintExpander draws an expander as used in TreeView. @x and @y specify the
// center the expander. The size of the expander is determined by the
// “expander-size” style property of @widget. (If widget is not specified or
// doesn’t have an “expander-size” property, an unspecified default size will be
// used, since the caller doesn't have sufficient information to position the
// expander, this is likely not useful.) The expander is expander_size pixels
// tall in the collapsed position and expander_size pixels wide in the expanded
// position.
	func PaintExpander(style StyleClass, cr *cairo.Context, stateType StateType, widget WidgetClass, detail string, x int, y int, expanderStyle ExpanderStyle)  {
var _arg1 *C.GtkStyle // out
var _arg2 *C.cairo_t // out
var _arg3 C.GtkStateType // out
var _arg4 *C.GtkWidget // out
var _arg5 *C.gchar // out
var _arg6 C.gint // out
var _arg7 C.gint // out
var _arg8 C.GtkExpanderStyle // out

_arg1 = (*C.GtkStyle)(unsafe.Pointer(style.Native()))
_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
_arg3 = (C.GtkStateType)(stateType)
_arg4 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg5 = (*C.gchar)(C.CString(detail))
defer C.free(unsafe.Pointer(_arg5))
_arg6 = (C.gint)(x)
_arg7 = (C.gint)(y)
_arg8 = (C.GtkExpanderStyle)(expanderStyle)

C.gtk_paint_expander(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8)
}


	// PaintExtension draws an extension, i.e. a notebook tab.
	func PaintExtension(style StyleClass, cr *cairo.Context, stateType StateType, shadowType ShadowType, widget WidgetClass, detail string, x int, y int, width int, height int, gapSide PositionType)  {
var _arg1 *C.GtkStyle // out
var _arg2 *C.cairo_t // out
var _arg3 C.GtkStateType // out
var _arg4 C.GtkShadowType // out
var _arg5 *C.GtkWidget // out
var _arg6 *C.gchar // out
var _arg7 C.gint // out
var _arg8 C.gint // out
var _arg9 C.gint // out
var _arg10 C.gint // out
var _arg11 C.GtkPositionType // out

_arg1 = (*C.GtkStyle)(unsafe.Pointer(style.Native()))
_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
_arg3 = (C.GtkStateType)(stateType)
_arg4 = (C.GtkShadowType)(shadowType)
_arg5 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg6 = (*C.gchar)(C.CString(detail))
defer C.free(unsafe.Pointer(_arg6))
_arg7 = (C.gint)(x)
_arg8 = (C.gint)(y)
_arg9 = (C.gint)(width)
_arg10 = (C.gint)(height)
_arg11 = (C.GtkPositionType)(gapSide)

C.gtk_paint_extension(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, _arg10, _arg11)
}


	// PaintFlatBox draws a flat box on @cr with the given parameters.
	func PaintFlatBox(style StyleClass, cr *cairo.Context, stateType StateType, shadowType ShadowType, widget WidgetClass, detail string, x int, y int, width int, height int)  {
var _arg1 *C.GtkStyle // out
var _arg2 *C.cairo_t // out
var _arg3 C.GtkStateType // out
var _arg4 C.GtkShadowType // out
var _arg5 *C.GtkWidget // out
var _arg6 *C.gchar // out
var _arg7 C.gint // out
var _arg8 C.gint // out
var _arg9 C.gint // out
var _arg10 C.gint // out

_arg1 = (*C.GtkStyle)(unsafe.Pointer(style.Native()))
_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
_arg3 = (C.GtkStateType)(stateType)
_arg4 = (C.GtkShadowType)(shadowType)
_arg5 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg6 = (*C.gchar)(C.CString(detail))
defer C.free(unsafe.Pointer(_arg6))
_arg7 = (C.gint)(x)
_arg8 = (C.gint)(y)
_arg9 = (C.gint)(width)
_arg10 = (C.gint)(height)

C.gtk_paint_flat_box(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, _arg10)
}


	// PaintFocus draws a focus indicator around the given rectangle on @cr using
// the given style.
	func PaintFocus(style StyleClass, cr *cairo.Context, stateType StateType, widget WidgetClass, detail string, x int, y int, width int, height int)  {
var _arg1 *C.GtkStyle // out
var _arg2 *C.cairo_t // out
var _arg3 C.GtkStateType // out
var _arg4 *C.GtkWidget // out
var _arg5 *C.gchar // out
var _arg6 C.gint // out
var _arg7 C.gint // out
var _arg8 C.gint // out
var _arg9 C.gint // out

_arg1 = (*C.GtkStyle)(unsafe.Pointer(style.Native()))
_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
_arg3 = (C.GtkStateType)(stateType)
_arg4 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg5 = (*C.gchar)(C.CString(detail))
defer C.free(unsafe.Pointer(_arg5))
_arg6 = (C.gint)(x)
_arg7 = (C.gint)(y)
_arg8 = (C.gint)(width)
_arg9 = (C.gint)(height)

C.gtk_paint_focus(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9)
}


	// PaintHandle draws a handle as used in HandleBox and Paned.
	func PaintHandle(style StyleClass, cr *cairo.Context, stateType StateType, shadowType ShadowType, widget WidgetClass, detail string, x int, y int, width int, height int, orientation Orientation)  {
var _arg1 *C.GtkStyle // out
var _arg2 *C.cairo_t // out
var _arg3 C.GtkStateType // out
var _arg4 C.GtkShadowType // out
var _arg5 *C.GtkWidget // out
var _arg6 *C.gchar // out
var _arg7 C.gint // out
var _arg8 C.gint // out
var _arg9 C.gint // out
var _arg10 C.gint // out
var _arg11 C.GtkOrientation // out

_arg1 = (*C.GtkStyle)(unsafe.Pointer(style.Native()))
_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
_arg3 = (C.GtkStateType)(stateType)
_arg4 = (C.GtkShadowType)(shadowType)
_arg5 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg6 = (*C.gchar)(C.CString(detail))
defer C.free(unsafe.Pointer(_arg6))
_arg7 = (C.gint)(x)
_arg8 = (C.gint)(y)
_arg9 = (C.gint)(width)
_arg10 = (C.gint)(height)
_arg11 = (C.GtkOrientation)(orientation)

C.gtk_paint_handle(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, _arg10, _arg11)
}


	// PaintHline draws a horizontal line from (@x1, @y) to (@x2, @y) in @cr using
// the given style and state.
	func PaintHline(style StyleClass, cr *cairo.Context, stateType StateType, widget WidgetClass, detail string, x1 int, x2 int, y int)  {
var _arg1 *C.GtkStyle // out
var _arg2 *C.cairo_t // out
var _arg3 C.GtkStateType // out
var _arg4 *C.GtkWidget // out
var _arg5 *C.gchar // out
var _arg6 C.gint // out
var _arg7 C.gint // out
var _arg8 C.gint // out

_arg1 = (*C.GtkStyle)(unsafe.Pointer(style.Native()))
_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
_arg3 = (C.GtkStateType)(stateType)
_arg4 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg5 = (*C.gchar)(C.CString(detail))
defer C.free(unsafe.Pointer(_arg5))
_arg6 = (C.gint)(x1)
_arg7 = (C.gint)(x2)
_arg8 = (C.gint)(y)

C.gtk_paint_hline(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8)
}


	// PaintLayout draws a layout on @cr using the given parameters.
	func PaintLayout(style StyleClass, cr *cairo.Context, stateType StateType, useText bool, widget WidgetClass, detail string, x int, y int, layout pango.LayoutClass)  {
var _arg1 *C.GtkStyle // out
var _arg2 *C.cairo_t // out
var _arg3 C.GtkStateType // out
var _arg4 C.gboolean // out
var _arg5 *C.GtkWidget // out
var _arg6 *C.gchar // out
var _arg7 C.gint // out
var _arg8 C.gint // out
var _arg9 *C.PangoLayout // out

_arg1 = (*C.GtkStyle)(unsafe.Pointer(style.Native()))
_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
_arg3 = (C.GtkStateType)(stateType)
if useText { _arg4 = C.TRUE }
_arg5 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg6 = (*C.gchar)(C.CString(detail))
defer C.free(unsafe.Pointer(_arg6))
_arg7 = (C.gint)(x)
_arg8 = (C.gint)(y)
_arg9 = (*C.PangoLayout)(unsafe.Pointer(layout.Native()))

C.gtk_paint_layout(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9)
}


	// PaintOption draws a radio button indicator in the given rectangle on @cr with
// the given parameters.
	func PaintOption(style StyleClass, cr *cairo.Context, stateType StateType, shadowType ShadowType, widget WidgetClass, detail string, x int, y int, width int, height int)  {
var _arg1 *C.GtkStyle // out
var _arg2 *C.cairo_t // out
var _arg3 C.GtkStateType // out
var _arg4 C.GtkShadowType // out
var _arg5 *C.GtkWidget // out
var _arg6 *C.gchar // out
var _arg7 C.gint // out
var _arg8 C.gint // out
var _arg9 C.gint // out
var _arg10 C.gint // out

_arg1 = (*C.GtkStyle)(unsafe.Pointer(style.Native()))
_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
_arg3 = (C.GtkStateType)(stateType)
_arg4 = (C.GtkShadowType)(shadowType)
_arg5 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg6 = (*C.gchar)(C.CString(detail))
defer C.free(unsafe.Pointer(_arg6))
_arg7 = (C.gint)(x)
_arg8 = (C.gint)(y)
_arg9 = (C.gint)(width)
_arg10 = (C.gint)(height)

C.gtk_paint_option(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, _arg10)
}


	// PaintResizeGrip draws a resize grip in the given rectangle on @cr using the
// given parameters.
	func PaintResizeGrip(style StyleClass, cr *cairo.Context, stateType StateType, widget WidgetClass, detail string, edge gdk.WindowEdge, x int, y int, width int, height int)  {
var _arg1 *C.GtkStyle // out
var _arg2 *C.cairo_t // out
var _arg3 C.GtkStateType // out
var _arg4 *C.GtkWidget // out
var _arg5 *C.gchar // out
var _arg6 C.GdkWindowEdge // out
var _arg7 C.gint // out
var _arg8 C.gint // out
var _arg9 C.gint // out
var _arg10 C.gint // out

_arg1 = (*C.GtkStyle)(unsafe.Pointer(style.Native()))
_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
_arg3 = (C.GtkStateType)(stateType)
_arg4 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg5 = (*C.gchar)(C.CString(detail))
defer C.free(unsafe.Pointer(_arg5))
_arg6 = (C.GdkWindowEdge)(edge)
_arg7 = (C.gint)(x)
_arg8 = (C.gint)(y)
_arg9 = (C.gint)(width)
_arg10 = (C.gint)(height)

C.gtk_paint_resize_grip(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, _arg10)
}


	// PaintShadow draws a shadow around the given rectangle in @cr using the given
// style and state and shadow type.
	func PaintShadow(style StyleClass, cr *cairo.Context, stateType StateType, shadowType ShadowType, widget WidgetClass, detail string, x int, y int, width int, height int)  {
var _arg1 *C.GtkStyle // out
var _arg2 *C.cairo_t // out
var _arg3 C.GtkStateType // out
var _arg4 C.GtkShadowType // out
var _arg5 *C.GtkWidget // out
var _arg6 *C.gchar // out
var _arg7 C.gint // out
var _arg8 C.gint // out
var _arg9 C.gint // out
var _arg10 C.gint // out

_arg1 = (*C.GtkStyle)(unsafe.Pointer(style.Native()))
_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
_arg3 = (C.GtkStateType)(stateType)
_arg4 = (C.GtkShadowType)(shadowType)
_arg5 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg6 = (*C.gchar)(C.CString(detail))
defer C.free(unsafe.Pointer(_arg6))
_arg7 = (C.gint)(x)
_arg8 = (C.gint)(y)
_arg9 = (C.gint)(width)
_arg10 = (C.gint)(height)

C.gtk_paint_shadow(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, _arg10)
}


	// PaintShadowGap draws a shadow around the given rectangle in @cr using the
// given style and state and shadow type, leaving a gap in one side.
	func PaintShadowGap(style StyleClass, cr *cairo.Context, stateType StateType, shadowType ShadowType, widget WidgetClass, detail string, x int, y int, width int, height int, gapSide PositionType, gapX int, gapWidth int)  {
var _arg1 *C.GtkStyle // out
var _arg2 *C.cairo_t // out
var _arg3 C.GtkStateType // out
var _arg4 C.GtkShadowType // out
var _arg5 *C.GtkWidget // out
var _arg6 *C.gchar // out
var _arg7 C.gint // out
var _arg8 C.gint // out
var _arg9 C.gint // out
var _arg10 C.gint // out
var _arg11 C.GtkPositionType // out
var _arg12 C.gint // out
var _arg13 C.gint // out

_arg1 = (*C.GtkStyle)(unsafe.Pointer(style.Native()))
_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
_arg3 = (C.GtkStateType)(stateType)
_arg4 = (C.GtkShadowType)(shadowType)
_arg5 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg6 = (*C.gchar)(C.CString(detail))
defer C.free(unsafe.Pointer(_arg6))
_arg7 = (C.gint)(x)
_arg8 = (C.gint)(y)
_arg9 = (C.gint)(width)
_arg10 = (C.gint)(height)
_arg11 = (C.GtkPositionType)(gapSide)
_arg12 = (C.gint)(gapX)
_arg13 = (C.gint)(gapWidth)

C.gtk_paint_shadow_gap(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, _arg10, _arg11, _arg12, _arg13)
}


	// PaintSlider draws a slider in the given rectangle on @cr using the given
// style and orientation.
	func PaintSlider(style StyleClass, cr *cairo.Context, stateType StateType, shadowType ShadowType, widget WidgetClass, detail string, x int, y int, width int, height int, orientation Orientation)  {
var _arg1 *C.GtkStyle // out
var _arg2 *C.cairo_t // out
var _arg3 C.GtkStateType // out
var _arg4 C.GtkShadowType // out
var _arg5 *C.GtkWidget // out
var _arg6 *C.gchar // out
var _arg7 C.gint // out
var _arg8 C.gint // out
var _arg9 C.gint // out
var _arg10 C.gint // out
var _arg11 C.GtkOrientation // out

_arg1 = (*C.GtkStyle)(unsafe.Pointer(style.Native()))
_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
_arg3 = (C.GtkStateType)(stateType)
_arg4 = (C.GtkShadowType)(shadowType)
_arg5 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg6 = (*C.gchar)(C.CString(detail))
defer C.free(unsafe.Pointer(_arg6))
_arg7 = (C.gint)(x)
_arg8 = (C.gint)(y)
_arg9 = (C.gint)(width)
_arg10 = (C.gint)(height)
_arg11 = (C.GtkOrientation)(orientation)

C.gtk_paint_slider(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, _arg10, _arg11)
}


	// PaintSpinner draws a spinner on @window using the given parameters.
	func PaintSpinner(style StyleClass, cr *cairo.Context, stateType StateType, widget WidgetClass, detail string, step uint, x int, y int, width int, height int)  {
var _arg1 *C.GtkStyle // out
var _arg2 *C.cairo_t // out
var _arg3 C.GtkStateType // out
var _arg4 *C.GtkWidget // out
var _arg5 *C.gchar // out
var _arg6 C.guint // out
var _arg7 C.gint // out
var _arg8 C.gint // out
var _arg9 C.gint // out
var _arg10 C.gint // out

_arg1 = (*C.GtkStyle)(unsafe.Pointer(style.Native()))
_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
_arg3 = (C.GtkStateType)(stateType)
_arg4 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg5 = (*C.gchar)(C.CString(detail))
defer C.free(unsafe.Pointer(_arg5))
_arg6 = (C.guint)(step)
_arg7 = (C.gint)(x)
_arg8 = (C.gint)(y)
_arg9 = (C.gint)(width)
_arg10 = (C.gint)(height)

C.gtk_paint_spinner(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, _arg10)
}


	// PaintTab draws an option menu tab (i.e. the up and down pointing arrows) in
// the given rectangle on @cr using the given parameters.
	func PaintTab(style StyleClass, cr *cairo.Context, stateType StateType, shadowType ShadowType, widget WidgetClass, detail string, x int, y int, width int, height int)  {
var _arg1 *C.GtkStyle // out
var _arg2 *C.cairo_t // out
var _arg3 C.GtkStateType // out
var _arg4 C.GtkShadowType // out
var _arg5 *C.GtkWidget // out
var _arg6 *C.gchar // out
var _arg7 C.gint // out
var _arg8 C.gint // out
var _arg9 C.gint // out
var _arg10 C.gint // out

_arg1 = (*C.GtkStyle)(unsafe.Pointer(style.Native()))
_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
_arg3 = (C.GtkStateType)(stateType)
_arg4 = (C.GtkShadowType)(shadowType)
_arg5 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg6 = (*C.gchar)(C.CString(detail))
defer C.free(unsafe.Pointer(_arg6))
_arg7 = (C.gint)(x)
_arg8 = (C.gint)(y)
_arg9 = (C.gint)(width)
_arg10 = (C.gint)(height)

C.gtk_paint_tab(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, _arg10)
}


	// PaintVline draws a vertical line from (@x, @y1_) to (@x, @y2_) in @cr using
// the given style and state.
	func PaintVline(style StyleClass, cr *cairo.Context, stateType StateType, widget WidgetClass, detail string, y1 int, y2 int, x int)  {
var _arg1 *C.GtkStyle // out
var _arg2 *C.cairo_t // out
var _arg3 C.GtkStateType // out
var _arg4 *C.GtkWidget // out
var _arg5 *C.gchar // out
var _arg6 C.gint // out
var _arg7 C.gint // out
var _arg8 C.gint // out

_arg1 = (*C.GtkStyle)(unsafe.Pointer(style.Native()))
_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
_arg3 = (C.GtkStateType)(stateType)
_arg4 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg5 = (*C.gchar)(C.CString(detail))
defer C.free(unsafe.Pointer(_arg5))
_arg6 = (C.gint)(y1)
_arg7 = (C.gint)(y2)
_arg8 = (C.gint)(x)

C.gtk_paint_vline(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8)
}


	// PrintRunPageSetupDialog runs a page setup dialog, letting the user modify the
// values from @page_setup. If the user cancels the dialog, the returned
// PageSetup is identical to the passed in @page_setup, otherwise it contains
// the modifications done in the dialog.
// 
// Note that this function may use a recursive mainloop to show the page setup
// dialog. See gtk_print_run_page_setup_dialog_async() if this is a problem.
	func PrintRunPageSetupDialog(parent WindowClass, pageSetup PageSetupClass, settings PrintSettingsClass) PageSetup {
var _arg1 *C.GtkWindow // out
var _arg2 *C.GtkPageSetup // out
var _arg3 *C.GtkPrintSettings // out
var _cret *C.GtkPageSetup // in

_arg1 = (*C.GtkWindow)(unsafe.Pointer(parent.Native()))
_arg2 = (*C.GtkPageSetup)(unsafe.Pointer(pageSetup.Native()))
_arg3 = (*C.GtkPrintSettings)(unsafe.Pointer(settings.Native()))

_cret = C.gtk_print_run_page_setup_dialog(_arg1, _arg2, _arg3)


var _pageSetup PageSetup // out

_pageSetup = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(PageSetup)

return _pageSetup
}


	// RCAddDefaultFile adds a file to the list of files to be parsed at the end of
// gtk_init().
	func RCAddDefaultFile(filename string)  {
var _arg1 *C.gchar // out

_arg1 = (*C.gchar)(C.CString(filename))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_rc_add_default_file(_arg1)
}


	// RCFindModuleInPath searches for a theme engine in the GTK+ search path. This
// function is not useful for applications and should not be used.
	func RCFindModuleInPath(moduleFile string) string {
var _arg1 *C.gchar // out
var _cret *C.gchar // in

_arg1 = (*C.gchar)(C.CString(moduleFile))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_rc_find_module_in_path(_arg1)


var _filename string // out

_filename = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _filename
}


	// RCFindPixmapInPath looks up a file in pixmap path for the specified Settings.
// If the file is not found, it outputs a warning message using g_warning() and
// returns nil.
	func RCFindPixmapInPath(settings SettingsClass, scanner *glib.Scanner, pixmapFile string) string {
var _arg1 *C.GtkSettings // out
var _arg2 *C.GScanner // out
var _arg3 *C.gchar // out
var _cret *C.gchar // in

_arg1 = (*C.GtkSettings)(unsafe.Pointer(settings.Native()))
_arg2 = (*C.GScanner)(unsafe.Pointer(scanner.Native()))
_arg3 = (*C.gchar)(C.CString(pixmapFile))
defer C.free(unsafe.Pointer(_arg3))

_cret = C.gtk_rc_find_pixmap_in_path(_arg1, _arg2, _arg3)


var _filename string // out

_filename = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _filename
}


	// RCGetDefaultFiles retrieves the current list of RC files that will be parsed
// at the end of gtk_init().
	func RCGetDefaultFiles() []string {
var _cret **C.gchar

_cret = C.gtk_rc_get_default_files()


var _filenames []string

{
var i int
var z *C.gchar
for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
  i++
}

src := unsafe.Slice(_cret, i)
_filenames = make([]string, i)
for i := range src {
_filenames[i] = C.GoString(src[i])
}
}

return _filenames
}


	// RCGetImModuleFile obtains the path to the IM modules file. See the
// documentation of the `GTK_IM_MODULE_FILE` environment variable for more
// details.
	func RCGetImModuleFile() string {
var _cret *C.gchar // in

_cret = C.gtk_rc_get_im_module_file()


var _filename string // out

_filename = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _filename
}


	// RCGetImModulePath obtains the path in which to look for IM modules. See the
// documentation of the `GTK_PATH` environment variable for more details about
// looking up modules. This function is useful solely for utilities supplied
// with GTK+ and should not be used by applications under normal circumstances.
	func RCGetImModulePath() string {
var _cret *C.gchar // in

_cret = C.gtk_rc_get_im_module_path()


var _filename string // out

_filename = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _filename
}


	// RCGetModuleDir returns a directory in which GTK+ looks for theme engines. For
// full information about the search for theme engines, see the docs for
// `GTK_PATH` in [Running GTK+ Applications][gtk-running].
	func RCGetModuleDir() string {
var _cret *C.gchar // in

_cret = C.gtk_rc_get_module_dir()


var _filename string // out

_filename = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _filename
}


	// RCGetStyle finds all matching RC styles for a given widget, composites them
// together, and then creates a Style representing the composite appearance.
// (GTK+ actually keeps a cache of previously created styles, so a new style may
// not be created.)
	func RCGetStyle(widget WidgetClass) Style {
var _arg1 *C.GtkWidget // out
var _cret *C.GtkStyle // in

_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

_cret = C.gtk_rc_get_style(_arg1)


var _style Style // out

_style = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Style)

return _style
}


	// RCGetStyleByPaths creates up a Style from styles defined in a RC file by
// providing the raw components used in matching. This function may be useful
// when creating pseudo-widgets that should be themed like widgets but don’t
// actually have corresponding GTK+ widgets. An example of this would be items
// inside a GNOME canvas widget.
// 
// The action of gtk_rc_get_style() is similar to:
// 
//    gtk_widget_path (widget, NULL, &path, NULL);
//    gtk_widget_class_path (widget, NULL, &class_path, NULL);
//    gtk_rc_get_style_by_paths (gtk_widget_get_settings (widget),
//                               path, class_path,
//                               G_OBJECT_TYPE (widget));
	func RCGetStyleByPaths(settings SettingsClass, widgetPath string, classPath string, typ externglib.Type) Style {
var _arg1 *C.GtkSettings // out
var _arg2 *C.char // out
var _arg3 *C.char // out
var _arg4 C.GType // out
var _cret *C.GtkStyle // in

_arg1 = (*C.GtkSettings)(unsafe.Pointer(settings.Native()))
_arg2 = (*C.char)(C.CString(widgetPath))
defer C.free(unsafe.Pointer(_arg2))
_arg3 = (*C.char)(C.CString(classPath))
defer C.free(unsafe.Pointer(_arg3))
_arg4 = C.GType(typ)

_cret = C.gtk_rc_get_style_by_paths(_arg1, _arg2, _arg3, _arg4)


var _style Style // out

_style = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Style)

return _style
}


	// RCGetThemeDir returns the standard directory in which themes should be
// installed. (GTK+ does not actually use this directory itself.)
	func RCGetThemeDir() string {
var _cret *C.gchar // in

_cret = C.gtk_rc_get_theme_dir()


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}


	// RCParse parses a given resource file.
	func RCParse(filename string)  {
var _arg1 *C.gchar // out

_arg1 = (*C.gchar)(C.CString(filename))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_rc_parse(_arg1)
}


	// RCParseColor parses a color in the format expected in a RC file.
// 
// Note that theme engines should use gtk_rc_parse_color_full() in order to
// support symbolic colors.
	func RCParseColor(scanner *glib.Scanner) (gdk.Color, uint) {
var _arg1 *C.GScanner // out
var _color gdk.Color
var _cret C.guint // in

_arg1 = (*C.GScanner)(unsafe.Pointer(scanner.Native()))

_cret = C.gtk_rc_parse_color(_arg1, (*C.GdkColor)(unsafe.Pointer(&_color)))



var _guint uint // out


_guint = (uint)(_cret)

return _color, _guint
}


	// RCParseColorFull parses a color in the format expected in a RC file. If
// @style is not nil, it will be consulted to resolve references to symbolic
// colors.
	func RCParseColorFull(scanner *glib.Scanner, style RCStyleClass) (gdk.Color, uint) {
var _arg1 *C.GScanner // out
var _arg2 *C.GtkRcStyle // out
var _color gdk.Color
var _cret C.guint // in

_arg1 = (*C.GScanner)(unsafe.Pointer(scanner.Native()))
_arg2 = (*C.GtkRcStyle)(unsafe.Pointer(style.Native()))

_cret = C.gtk_rc_parse_color_full(_arg1, _arg2, (*C.GdkColor)(unsafe.Pointer(&_color)))



var _guint uint // out


_guint = (uint)(_cret)

return _color, _guint
}


	// RCParsePriority parses a PathPriorityType variable from the format expected
// in a RC file.
	func RCParsePriority(scanner *glib.Scanner, priority *PathPriorityType) uint {
var _arg1 *C.GScanner // out
var _arg2 *C.GtkPathPriorityType // out
var _cret C.guint // in

_arg1 = (*C.GScanner)(unsafe.Pointer(scanner.Native()))
_arg2 = (*C.GtkPathPriorityType)(unsafe.Pointer(priority))

_cret = C.gtk_rc_parse_priority(_arg1, _arg2)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}


	// RCParseState parses a StateType variable from the format expected in a RC
// file.
	func RCParseState(scanner *glib.Scanner) (StateType, uint) {
var _arg1 *C.GScanner // out
var _arg2 C.GtkStateType // in
var _cret C.guint // in

_arg1 = (*C.GScanner)(unsafe.Pointer(scanner.Native()))

_cret = C.gtk_rc_parse_state(_arg1, &_arg2)


var _state StateType // out
var _guint uint // out

_state = StateType(_arg2)
_guint = (uint)(_cret)

return _state, _guint
}


	// RCParseString parses resource information directly from a string.
	func RCParseString(rcString string)  {
var _arg1 *C.gchar // out

_arg1 = (*C.gchar)(C.CString(rcString))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_rc_parse_string(_arg1)
}


	// RCReparseAll: if the modification time on any previously read file for the
// default Settings has changed, discard all style information and then reread
// all previously read RC files.
	func RCReparseAll() bool {
var _cret C.gboolean // in

_cret = C.gtk_rc_reparse_all()


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}


	// RCReparseAllForSettings: if the modification time on any previously read file
// for the given Settings has changed, discard all style information and then
// reread all previously read RC files.
	func RCReparseAllForSettings(settings SettingsClass, forceLoad bool) bool {
var _arg1 *C.GtkSettings // out
var _arg2 C.gboolean // out
var _cret C.gboolean // in

_arg1 = (*C.GtkSettings)(unsafe.Pointer(settings.Native()))
if forceLoad { _arg2 = C.TRUE }

_cret = C.gtk_rc_reparse_all_for_settings(_arg1, _arg2)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}


	// RCResetStyles: this function recomputes the styles for all widgets that use a
// particular Settings object. (There is one Settings object per Screen, see
// gtk_settings_get_for_screen()); It is useful when some global parameter has
// changed that affects the appearance of all widgets, because when a widget
// gets a new style, it will both redraw and recompute any cached information
// about its appearance. As an example, it is used when the default font size
// set by the operating system changes. Note that this function doesn’t affect
// widgets that have a style set explicitly on them with gtk_widget_set_style().
	func RCResetStyles(settings SettingsClass)  {
var _arg1 *C.GtkSettings // out

_arg1 = (*C.GtkSettings)(unsafe.Pointer(settings.Native()))

C.gtk_rc_reset_styles(_arg1)
}


	// RCSetDefaultFiles sets the list of files that GTK+ will read at the end of
// gtk_init().
	func RCSetDefaultFiles(filenames []string)  {
var _arg1 **C.gchar

_arg1 = (**C.gchar)(C.malloc(C.ulong(len(filenames)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
defer C.free(unsafe.Pointer(_arg1))
{
out := unsafe.Slice(_arg1, len(filenames))
for i := range filenames {
out[i] = (*C.gchar)(C.CString(filenames[i]))
defer C.free(unsafe.Pointer(out[i]))
}
}

C.gtk_rc_set_default_files(_arg1)
}


	// RenderActivity renders an activity indicator (such as in Spinner). The state
// GTK_STATE_FLAG_CHECKED determines whether there is activity going on.
	func RenderActivity(context StyleContextClass, cr *cairo.Context, x float64, y float64, width float64, height float64)  {
var _arg1 *C.GtkStyleContext // out
var _arg2 *C.cairo_t // out
var _arg3 C.gdouble // out
var _arg4 C.gdouble // out
var _arg5 C.gdouble // out
var _arg6 C.gdouble // out

_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))
_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
_arg3 = (C.gdouble)(x)
_arg4 = (C.gdouble)(y)
_arg5 = (C.gdouble)(width)
_arg6 = (C.gdouble)(height)

C.gtk_render_activity(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
}


	// RenderArrow renders an arrow pointing to @angle.
// 
// Typical arrow rendering at 0, 1⁄2 π;, π; and 3⁄2 π:
// 
// ! (arrows.png)
	func RenderArrow(context StyleContextClass, cr *cairo.Context, angle float64, x float64, y float64, size float64)  {
var _arg1 *C.GtkStyleContext // out
var _arg2 *C.cairo_t // out
var _arg3 C.gdouble // out
var _arg4 C.gdouble // out
var _arg5 C.gdouble // out
var _arg6 C.gdouble // out

_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))
_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
_arg3 = (C.gdouble)(angle)
_arg4 = (C.gdouble)(x)
_arg5 = (C.gdouble)(y)
_arg6 = (C.gdouble)(size)

C.gtk_render_arrow(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
}


	// RenderBackground renders the background of an element.
// 
// Typical background rendering, showing the effect of `background-image`,
// `border-width` and `border-radius`:
// 
// ! (background.png)
	func RenderBackground(context StyleContextClass, cr *cairo.Context, x float64, y float64, width float64, height float64)  {
var _arg1 *C.GtkStyleContext // out
var _arg2 *C.cairo_t // out
var _arg3 C.gdouble // out
var _arg4 C.gdouble // out
var _arg5 C.gdouble // out
var _arg6 C.gdouble // out

_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))
_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
_arg3 = (C.gdouble)(x)
_arg4 = (C.gdouble)(y)
_arg5 = (C.gdouble)(width)
_arg6 = (C.gdouble)(height)

C.gtk_render_background(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
}


	// RenderBackgroundGetClip returns the area that will be affected (i.e. drawn
// to) when calling gtk_render_background() for the given @context and
// rectangle.
	func RenderBackgroundGetClip(context StyleContextClass, x float64, y float64, width float64, height float64) gdk.Rectangle {
var _arg1 *C.GtkStyleContext // out
var _arg2 C.gdouble // out
var _arg3 C.gdouble // out
var _arg4 C.gdouble // out
var _arg5 C.gdouble // out
var _outClip gdk.Rectangle

_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))
_arg2 = (C.gdouble)(x)
_arg3 = (C.gdouble)(y)
_arg4 = (C.gdouble)(width)
_arg5 = (C.gdouble)(height)

C.gtk_render_background_get_clip(_arg1, _arg2, _arg3, _arg4, _arg5, (*C.GdkRectangle)(unsafe.Pointer(&_outClip)))





return _outClip
}


	// RenderCheck renders a checkmark (as in a CheckButton).
// 
// The GTK_STATE_FLAG_CHECKED state determines whether the check is on or off,
// and GTK_STATE_FLAG_INCONSISTENT determines whether it should be marked as
// undefined.
// 
// Typical checkmark rendering:
// 
// ! (checks.png)
	func RenderCheck(context StyleContextClass, cr *cairo.Context, x float64, y float64, width float64, height float64)  {
var _arg1 *C.GtkStyleContext // out
var _arg2 *C.cairo_t // out
var _arg3 C.gdouble // out
var _arg4 C.gdouble // out
var _arg5 C.gdouble // out
var _arg6 C.gdouble // out

_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))
_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
_arg3 = (C.gdouble)(x)
_arg4 = (C.gdouble)(y)
_arg5 = (C.gdouble)(width)
_arg6 = (C.gdouble)(height)

C.gtk_render_check(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
}


	// RenderExpander renders an expander (as used in TreeView and Expander) in the
// area defined by @x, @y, @width, @height. The state GTK_STATE_FLAG_CHECKED
// determines whether the expander is collapsed or expanded.
// 
// Typical expander rendering:
// 
// ! (expanders.png)
	func RenderExpander(context StyleContextClass, cr *cairo.Context, x float64, y float64, width float64, height float64)  {
var _arg1 *C.GtkStyleContext // out
var _arg2 *C.cairo_t // out
var _arg3 C.gdouble // out
var _arg4 C.gdouble // out
var _arg5 C.gdouble // out
var _arg6 C.gdouble // out

_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))
_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
_arg3 = (C.gdouble)(x)
_arg4 = (C.gdouble)(y)
_arg5 = (C.gdouble)(width)
_arg6 = (C.gdouble)(height)

C.gtk_render_expander(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
}


	// RenderExtension renders a extension (as in a Notebook tab) in the rectangle
// defined by @x, @y, @width, @height. The side where the extension connects to
// is defined by @gap_side.
// 
// Typical extension rendering:
// 
// ! (extensions.png)
	func RenderExtension(context StyleContextClass, cr *cairo.Context, x float64, y float64, width float64, height float64, gapSide PositionType)  {
var _arg1 *C.GtkStyleContext // out
var _arg2 *C.cairo_t // out
var _arg3 C.gdouble // out
var _arg4 C.gdouble // out
var _arg5 C.gdouble // out
var _arg6 C.gdouble // out
var _arg7 C.GtkPositionType // out

_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))
_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
_arg3 = (C.gdouble)(x)
_arg4 = (C.gdouble)(y)
_arg5 = (C.gdouble)(width)
_arg6 = (C.gdouble)(height)
_arg7 = (C.GtkPositionType)(gapSide)

C.gtk_render_extension(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7)
}


	// RenderFocus renders a focus indicator on the rectangle determined by @x, @y,
// @width, @height.
// 
// Typical focus rendering:
// 
// ! (focus.png)
	func RenderFocus(context StyleContextClass, cr *cairo.Context, x float64, y float64, width float64, height float64)  {
var _arg1 *C.GtkStyleContext // out
var _arg2 *C.cairo_t // out
var _arg3 C.gdouble // out
var _arg4 C.gdouble // out
var _arg5 C.gdouble // out
var _arg6 C.gdouble // out

_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))
_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
_arg3 = (C.gdouble)(x)
_arg4 = (C.gdouble)(y)
_arg5 = (C.gdouble)(width)
_arg6 = (C.gdouble)(height)

C.gtk_render_focus(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
}


	// RenderFrame renders a frame around the rectangle defined by @x, @y, @width,
// @height.
// 
// Examples of frame rendering, showing the effect of `border-image`,
// `border-color`, `border-width`, `border-radius` and junctions:
// 
// ! (frames.png)
	func RenderFrame(context StyleContextClass, cr *cairo.Context, x float64, y float64, width float64, height float64)  {
var _arg1 *C.GtkStyleContext // out
var _arg2 *C.cairo_t // out
var _arg3 C.gdouble // out
var _arg4 C.gdouble // out
var _arg5 C.gdouble // out
var _arg6 C.gdouble // out

_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))
_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
_arg3 = (C.gdouble)(x)
_arg4 = (C.gdouble)(y)
_arg5 = (C.gdouble)(width)
_arg6 = (C.gdouble)(height)

C.gtk_render_frame(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
}


	// RenderFrameGap renders a frame around the rectangle defined by (@x, @y,
// @width, @height), leaving a gap on one side. @xy0_gap and @xy1_gap will mean
// X coordinates for GTK_POS_TOP and GTK_POS_BOTTOM gap sides, and Y coordinates
// for GTK_POS_LEFT and GTK_POS_RIGHT.
// 
// Typical rendering of a frame with a gap:
// 
// ! (frame-gap.png)
	func RenderFrameGap(context StyleContextClass, cr *cairo.Context, x float64, y float64, width float64, height float64, gapSide PositionType, xy0Gap float64, xy1Gap float64)  {
var _arg1 *C.GtkStyleContext // out
var _arg2 *C.cairo_t // out
var _arg3 C.gdouble // out
var _arg4 C.gdouble // out
var _arg5 C.gdouble // out
var _arg6 C.gdouble // out
var _arg7 C.GtkPositionType // out
var _arg8 C.gdouble // out
var _arg9 C.gdouble // out

_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))
_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
_arg3 = (C.gdouble)(x)
_arg4 = (C.gdouble)(y)
_arg5 = (C.gdouble)(width)
_arg6 = (C.gdouble)(height)
_arg7 = (C.GtkPositionType)(gapSide)
_arg8 = (C.gdouble)(xy0Gap)
_arg9 = (C.gdouble)(xy1Gap)

C.gtk_render_frame_gap(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9)
}


	// RenderHandle renders a handle (as in HandleBox, Paned and Window’s resize
// grip), in the rectangle determined by @x, @y, @width, @height.
// 
// Handles rendered for the paned and grip classes:
// 
// ! (handles.png)
	func RenderHandle(context StyleContextClass, cr *cairo.Context, x float64, y float64, width float64, height float64)  {
var _arg1 *C.GtkStyleContext // out
var _arg2 *C.cairo_t // out
var _arg3 C.gdouble // out
var _arg4 C.gdouble // out
var _arg5 C.gdouble // out
var _arg6 C.gdouble // out

_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))
_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
_arg3 = (C.gdouble)(x)
_arg4 = (C.gdouble)(y)
_arg5 = (C.gdouble)(width)
_arg6 = (C.gdouble)(height)

C.gtk_render_handle(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
}


	// RenderIcon renders the icon in @pixbuf at the specified @x and @y
// coordinates.
// 
// This function will render the icon in @pixbuf at exactly its size, regardless
// of scaling factors, which may not be appropriate when drawing on displays
// with high pixel densities.
// 
// You probably want to use gtk_render_icon_surface() instead, if you already
// have a Cairo surface.
	func RenderIcon(context StyleContextClass, cr *cairo.Context, pixbuf gdkpixbuf.PixbufClass, x float64, y float64)  {
var _arg1 *C.GtkStyleContext // out
var _arg2 *C.cairo_t // out
var _arg3 *C.GdkPixbuf // out
var _arg4 C.gdouble // out
var _arg5 C.gdouble // out

_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))
_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
_arg3 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))
_arg4 = (C.gdouble)(x)
_arg5 = (C.gdouble)(y)

C.gtk_render_icon(_arg1, _arg2, _arg3, _arg4, _arg5)
}


	// RenderIconPixbuf renders the icon specified by @source at the given @size,
// returning the result in a pixbuf.
	func RenderIconPixbuf(context StyleContextClass, source *IconSource, size int) gdkpixbuf.Pixbuf {
var _arg1 *C.GtkStyleContext // out
var _arg2 *C.GtkIconSource // out
var _arg3 C.GtkIconSize // out
var _cret *C.GdkPixbuf // in

_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))
_arg2 = (*C.GtkIconSource)(unsafe.Pointer(source.Native()))
_arg3 = (C.GtkIconSize)(size)

_cret = C.gtk_render_icon_pixbuf(_arg1, _arg2, _arg3)


var _pixbuf gdkpixbuf.Pixbuf // out

_pixbuf = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gdkpixbuf.Pixbuf)

return _pixbuf
}


	// RenderIconSurface renders the icon in @surface at the specified @x and @y
// coordinates.
	func RenderIconSurface(context StyleContextClass, cr *cairo.Context, surface *cairo.Surface, x float64, y float64)  {
var _arg1 *C.GtkStyleContext // out
var _arg2 *C.cairo_t // out
var _arg3 *C.cairo_surface_t // out
var _arg4 C.gdouble // out
var _arg5 C.gdouble // out

_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))
_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
_arg3 = (*C.cairo_surface_t)(unsafe.Pointer(surface.Native()))
_arg4 = (C.gdouble)(x)
_arg5 = (C.gdouble)(y)

C.gtk_render_icon_surface(_arg1, _arg2, _arg3, _arg4, _arg5)
}


	// RenderInsertionCursor draws a text caret on @cr at the specified index of
// @layout.
	func RenderInsertionCursor(context StyleContextClass, cr *cairo.Context, x float64, y float64, layout pango.LayoutClass, index int, direction pango.Direction)  {
var _arg1 *C.GtkStyleContext // out
var _arg2 *C.cairo_t // out
var _arg3 C.gdouble // out
var _arg4 C.gdouble // out
var _arg5 *C.PangoLayout // out
var _arg6 C.int // out
var _arg7 C.PangoDirection // out

_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))
_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
_arg3 = (C.gdouble)(x)
_arg4 = (C.gdouble)(y)
_arg5 = (*C.PangoLayout)(unsafe.Pointer(layout.Native()))
_arg6 = (C.int)(index)
_arg7 = (C.PangoDirection)(direction)

C.gtk_render_insertion_cursor(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7)
}


	// RenderLayout renders @layout on the coordinates @x, @y
	func RenderLayout(context StyleContextClass, cr *cairo.Context, x float64, y float64, layout pango.LayoutClass)  {
var _arg1 *C.GtkStyleContext // out
var _arg2 *C.cairo_t // out
var _arg3 C.gdouble // out
var _arg4 C.gdouble // out
var _arg5 *C.PangoLayout // out

_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))
_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
_arg3 = (C.gdouble)(x)
_arg4 = (C.gdouble)(y)
_arg5 = (*C.PangoLayout)(unsafe.Pointer(layout.Native()))

C.gtk_render_layout(_arg1, _arg2, _arg3, _arg4, _arg5)
}


	// RenderLine renders a line from (x0, y0) to (x1, y1).
	func RenderLine(context StyleContextClass, cr *cairo.Context, x0 float64, y0 float64, x1 float64, y1 float64)  {
var _arg1 *C.GtkStyleContext // out
var _arg2 *C.cairo_t // out
var _arg3 C.gdouble // out
var _arg4 C.gdouble // out
var _arg5 C.gdouble // out
var _arg6 C.gdouble // out

_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))
_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
_arg3 = (C.gdouble)(x0)
_arg4 = (C.gdouble)(y0)
_arg5 = (C.gdouble)(x1)
_arg6 = (C.gdouble)(y1)

C.gtk_render_line(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
}


	// RenderOption renders an option mark (as in a RadioButton), the
// GTK_STATE_FLAG_CHECKED state will determine whether the option is on or off,
// and GTK_STATE_FLAG_INCONSISTENT whether it should be marked as undefined.
// 
// Typical option mark rendering:
// 
// ! (options.png)
	func RenderOption(context StyleContextClass, cr *cairo.Context, x float64, y float64, width float64, height float64)  {
var _arg1 *C.GtkStyleContext // out
var _arg2 *C.cairo_t // out
var _arg3 C.gdouble // out
var _arg4 C.gdouble // out
var _arg5 C.gdouble // out
var _arg6 C.gdouble // out

_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))
_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
_arg3 = (C.gdouble)(x)
_arg4 = (C.gdouble)(y)
_arg5 = (C.gdouble)(width)
_arg6 = (C.gdouble)(height)

C.gtk_render_option(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
}


	// RenderSlider renders a slider (as in Scale) in the rectangle defined by @x,
// @y, @width, @height. @orientation defines whether the slider is vertical or
// horizontal.
// 
// Typical slider rendering:
// 
// ! (sliders.png)
	func RenderSlider(context StyleContextClass, cr *cairo.Context, x float64, y float64, width float64, height float64, orientation Orientation)  {
var _arg1 *C.GtkStyleContext // out
var _arg2 *C.cairo_t // out
var _arg3 C.gdouble // out
var _arg4 C.gdouble // out
var _arg5 C.gdouble // out
var _arg6 C.gdouble // out
var _arg7 C.GtkOrientation // out

_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))
_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
_arg3 = (C.gdouble)(x)
_arg4 = (C.gdouble)(y)
_arg5 = (C.gdouble)(width)
_arg6 = (C.gdouble)(height)
_arg7 = (C.GtkOrientation)(orientation)

C.gtk_render_slider(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7)
}


	// RGBToHSV converts a color from RGB space to HSV.
// 
// Input values must be in the [0.0, 1.0] range; output values will be in the
// same range.
	func RGBToHSV(r float64, g float64, b float64) (h float64, s float64, v float64) {
var _arg1 C.gdouble // out
var _arg2 C.gdouble // out
var _arg3 C.gdouble // out
var _arg4 C.gdouble // in
var _arg5 C.gdouble // in
var _arg6 C.gdouble // in

_arg1 = (C.gdouble)(r)
_arg2 = (C.gdouble)(g)
_arg3 = (C.gdouble)(b)

C.gtk_rgb_to_hsv(_arg1, _arg2, _arg3, &_arg4, &_arg5, &_arg6)

var _h float64 // out
var _s float64 // out
var _v float64 // out

_h = (float64)(_arg4)
_s = (float64)(_arg5)
_v = (float64)(_arg6)

return _h, _s, _v
}


	// SelectionAddTarget appends a specified target to the list of supported
// targets for a given widget and selection.
	func SelectionAddTarget(widget WidgetClass, selection *gdk.Atom, target *gdk.Atom, info uint)  {
var _arg1 *C.GtkWidget // out
var _arg2 C.GdkAtom // out
var _arg3 C.GdkAtom // out
var _arg4 C.guint // out

_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg2 = (C.GdkAtom)(unsafe.Pointer(selection.Native()))
_arg3 = (C.GdkAtom)(unsafe.Pointer(target.Native()))
_arg4 = (C.guint)(info)

C.gtk_selection_add_target(_arg1, _arg2, _arg3, _arg4)
}


	// SelectionAddTargets prepends a table of targets to the list of supported
// targets for a given widget and selection.
	func SelectionAddTargets(widget WidgetClass, selection *gdk.Atom, targets []TargetEntry)  {
var _arg1 *C.GtkWidget // out
var _arg2 C.GdkAtom // out
var _arg3 *C.GtkTargetEntry
var _arg4 C.guint

_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg2 = (C.GdkAtom)(unsafe.Pointer(selection.Native()))
_arg4 = C.guint(len(targets))
_arg3 = (*C.GtkTargetEntry)(unsafe.Pointer(&targets[0]))

C.gtk_selection_add_targets(_arg1, _arg2, _arg3, _arg4)
}


	// SelectionClearTargets: remove all targets registered for the given selection
// for the widget.
	func SelectionClearTargets(widget WidgetClass, selection *gdk.Atom)  {
var _arg1 *C.GtkWidget // out
var _arg2 C.GdkAtom // out

_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg2 = (C.GdkAtom)(unsafe.Pointer(selection.Native()))

C.gtk_selection_clear_targets(_arg1, _arg2)
}


	// SelectionConvert requests the contents of a selection. When received, a
// “selection-received” signal will be generated.
	func SelectionConvert(widget WidgetClass, selection *gdk.Atom, target *gdk.Atom, time_ uint32) bool {
var _arg1 *C.GtkWidget // out
var _arg2 C.GdkAtom // out
var _arg3 C.GdkAtom // out
var _arg4 C.guint32 // out
var _cret C.gboolean // in

_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg2 = (C.GdkAtom)(unsafe.Pointer(selection.Native()))
_arg3 = (C.GdkAtom)(unsafe.Pointer(target.Native()))
_arg4 = (C.guint32)(time_)

_cret = C.gtk_selection_convert(_arg1, _arg2, _arg3, _arg4)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}


	// SelectionOwnerSet claims ownership of a given selection for a particular
// widget, or, if @widget is nil, release ownership of the selection.
	func SelectionOwnerSet(widget WidgetClass, selection *gdk.Atom, time_ uint32) bool {
var _arg1 *C.GtkWidget // out
var _arg2 C.GdkAtom // out
var _arg3 C.guint32 // out
var _cret C.gboolean // in

_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg2 = (C.GdkAtom)(unsafe.Pointer(selection.Native()))
_arg3 = (C.guint32)(time_)

_cret = C.gtk_selection_owner_set(_arg1, _arg2, _arg3)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}


	// SelectionOwnerSetForDisplay: claim ownership of a given selection for a
// particular widget, or, if @widget is nil, release ownership of the selection.
	func SelectionOwnerSetForDisplay(display gdk.DisplayClass, widget WidgetClass, selection *gdk.Atom, time_ uint32) bool {
var _arg1 *C.GdkDisplay // out
var _arg2 *C.GtkWidget // out
var _arg3 C.GdkAtom // out
var _arg4 C.guint32 // out
var _cret C.gboolean // in

_arg1 = (*C.GdkDisplay)(unsafe.Pointer(display.Native()))
_arg2 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg3 = (C.GdkAtom)(unsafe.Pointer(selection.Native()))
_arg4 = (C.guint32)(time_)

_cret = C.gtk_selection_owner_set_for_display(_arg1, _arg2, _arg3, _arg4)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}


	// SelectionRemoveAll removes all handlers and unsets ownership of all
// selections for a widget. Called when widget is being destroyed. This function
// will not generally be called by applications.
	func SelectionRemoveAll(widget WidgetClass)  {
var _arg1 *C.GtkWidget // out

_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

C.gtk_selection_remove_all(_arg1)
}


	// SetDebugFlags sets the GTK+ debug flags.
	func SetDebugFlags(flags uint)  {
var _arg1 C.guint // out

_arg1 = (C.guint)(flags)

C.gtk_set_debug_flags(_arg1)
}


	// ShowURI: a convenience function for launching the default application to show
// the uri. Like gtk_show_uri_on_window(), but takes a screen as transient
// parent instead of a window.
// 
// Note that this function is deprecated as it does not pass the necessary
// information for helpers to parent their dialog properly, when run from
// sandboxed applications for example.
	func ShowURI(screen gdk.ScreenClass, uri string, timestamp uint32) error {
var _arg1 *C.GdkScreen // out
var _arg2 *C.gchar // out
var _arg3 C.guint32 // out
var _cerr *C.GError // in

_arg1 = (*C.GdkScreen)(unsafe.Pointer(screen.Native()))
_arg2 = (*C.gchar)(C.CString(uri))
defer C.free(unsafe.Pointer(_arg2))
_arg3 = (C.guint32)(timestamp)

C.gtk_show_uri(_arg1, _arg2, _arg3, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}


	// ShowURIOnWindow: this is a convenience function for launching the default
// application to show the uri. The uri must be of a form understood by GIO
// (i.e. you need to install gvfs to get support for uri schemes such as http://
// or ftp://, as only local files are handled by GIO itself). Typical examples
// are - `file:///home/gnome/pict.jpg` - `http://www.gnome.org` -
// `mailto:me@gnome.org`
// 
// Ideally the timestamp is taken from the event triggering the gtk_show_uri()
// call. If timestamp is not known you can take GDK_CURRENT_TIME.
// 
// This is the recommended call to be used as it passes information necessary
// for sandbox helpers to parent their dialogs properly.
	func ShowURIOnWindow(parent WindowClass, uri string, timestamp uint32) error {
var _arg1 *C.GtkWindow // out
var _arg2 *C.char // out
var _arg3 C.guint32 // out
var _cerr *C.GError // in

_arg1 = (*C.GtkWindow)(unsafe.Pointer(parent.Native()))
_arg2 = (*C.char)(C.CString(uri))
defer C.free(unsafe.Pointer(_arg2))
_arg3 = (C.guint32)(timestamp)

C.gtk_show_uri_on_window(_arg1, _arg2, _arg3, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}


	// StockAdd registers each of the stock items in @items. If an item already
// exists with the same stock ID as one of the @items, the old item gets
// replaced. The stock items are copied, so GTK+ does not hold any pointer into
// @items and @items can be freed. Use gtk_stock_add_static() if @items is
// persistent and GTK+ need not copy the array.
	func StockAdd(items []StockItem)  {
var _arg1 *C.GtkStockItem
var _arg2 C.guint

_arg2 = C.guint(len(items))
_arg1 = (*C.GtkStockItem)(unsafe.Pointer(&items[0]))

C.gtk_stock_add(_arg1, _arg2)
}


	// StockAddStatic: same as gtk_stock_add(), but doesn’t copy @items, so @items
// must persist until application exit.
	func StockAddStatic(items []StockItem)  {
var _arg1 *C.GtkStockItem
var _arg2 C.guint

_arg2 = C.guint(len(items))
_arg1 = (*C.GtkStockItem)(unsafe.Pointer(&items[0]))

C.gtk_stock_add_static(_arg1, _arg2)
}


	// StockLookup fills @item with the registered values for @stock_id, returning
// true if @stock_id was known.
	func StockLookup(stockId string) (StockItem, bool) {
var _arg1 *C.gchar // out
var _item StockItem
var _cret C.gboolean // in

_arg1 = (*C.gchar)(C.CString(stockId))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_stock_lookup(_arg1, (*C.GtkStockItem)(unsafe.Pointer(&_item)))



var _ok bool // out


if _cret != 0 { _ok = true }

return _item, _ok
}


	// TargetTableFree: this function frees a target table as returned by
// gtk_target_table_new_from_list()
	func TargetTableFree(targets []TargetEntry)  {
var _arg1 *C.GtkTargetEntry
var _arg2 C.gint

_arg2 = C.gint(len(targets))
_arg1 = (*C.GtkTargetEntry)(unsafe.Pointer(&targets[0]))

C.gtk_target_table_free(_arg1, _arg2)
}


	// TargetsIncludeImage determines if any of the targets in @targets can be used
// to provide a Pixbuf.
	func TargetsIncludeImage(targets []*gdk.Atom, writable bool) bool {
var _arg1 *C.GdkAtom
var _arg2 C.gint
var _arg3 C.gboolean // out
var _cret C.gboolean // in

_arg2 = C.gint(len(targets))
_arg1 = (*C.GdkAtom)(unsafe.Pointer(&targets[0]))
if writable { _arg3 = C.TRUE }

_cret = C.gtk_targets_include_image(_arg1, _arg2, _arg3)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}


	// TargetsIncludeRichText determines if any of the targets in @targets can be
// used to provide rich text.
	func TargetsIncludeRichText(targets []*gdk.Atom, buffer TextBufferClass) bool {
var _arg1 *C.GdkAtom
var _arg2 C.gint
var _arg3 *C.GtkTextBuffer // out
var _cret C.gboolean // in

_arg2 = C.gint(len(targets))
_arg1 = (*C.GdkAtom)(unsafe.Pointer(&targets[0]))
_arg3 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))

_cret = C.gtk_targets_include_rich_text(_arg1, _arg2, _arg3)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}


	// TargetsIncludeText determines if any of the targets in @targets can be used
// to provide text.
	func TargetsIncludeText(targets []*gdk.Atom) bool {
var _arg1 *C.GdkAtom
var _arg2 C.gint
var _cret C.gboolean // in

_arg2 = C.gint(len(targets))
_arg1 = (*C.GdkAtom)(unsafe.Pointer(&targets[0]))

_cret = C.gtk_targets_include_text(_arg1, _arg2)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}


	// TargetsIncludeURI determines if any of the targets in @targets can be used to
// provide an uri list.
	func TargetsIncludeURI(targets []*gdk.Atom) bool {
var _arg1 *C.GdkAtom
var _arg2 C.gint
var _cret C.gboolean // in

_arg2 = C.gint(len(targets))
_arg1 = (*C.GdkAtom)(unsafe.Pointer(&targets[0]))

_cret = C.gtk_targets_include_uri(_arg1, _arg2)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}


	// TestCreateSimpleWindow: create a simple window with window title
// @window_title and text contents @dialog_text. The window will quit any
// running gtk_main()-loop when destroyed, and it will automatically be
// destroyed upon test function teardown.
	func TestCreateSimpleWindow(windowTitle string, dialogText string) Widget {
var _arg1 *C.gchar // out
var _arg2 *C.gchar // out
var _cret *C.GtkWidget // in

_arg1 = (*C.gchar)(C.CString(windowTitle))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.gchar)(C.CString(dialogText))
defer C.free(unsafe.Pointer(_arg2))

_cret = C.gtk_test_create_simple_window(_arg1, _arg2)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}


	// TestFindLabel: this function will search @widget and all its descendants for
// a GtkLabel widget with a text string matching @label_pattern. The
// @label_pattern may contain asterisks “*” and question marks “?” as
// placeholders, g_pattern_match() is used for the matching. Note that locales
// other than "C“ tend to alter (translate” label strings, so this function is
// genrally only useful in test programs with predetermined locales, see
// gtk_test_init() for more details.
	func TestFindLabel(widget WidgetClass, labelPattern string) Widget {
var _arg1 *C.GtkWidget // out
var _arg2 *C.gchar // out
var _cret *C.GtkWidget // in

_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg2 = (*C.gchar)(C.CString(labelPattern))
defer C.free(unsafe.Pointer(_arg2))

_cret = C.gtk_test_find_label(_arg1, _arg2)


var _ret Widget // out

_ret = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _ret
}


	// TestFindSibling: this function will search siblings of @base_widget and
// siblings of its ancestors for all widgets matching @widget_type. Of the
// matching widgets, the one that is geometrically closest to @base_widget will
// be returned. The general purpose of this function is to find the most likely
// “action” widget, relative to another labeling widget. Such as finding a
// button or text entry widget, given its corresponding label widget.
	func TestFindSibling(baseWidget WidgetClass, widgetType externglib.Type) Widget {
var _arg1 *C.GtkWidget // out
var _arg2 C.GType // out
var _cret *C.GtkWidget // in

_arg1 = (*C.GtkWidget)(unsafe.Pointer(baseWidget.Native()))
_arg2 = C.GType(widgetType)

_cret = C.gtk_test_find_sibling(_arg1, _arg2)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}


	// TestFindWidget: this function will search the descendants of @widget for a
// widget of type @widget_type that has a label matching @label_pattern next to
// it. This is most useful for automated GUI testing, e.g. to find the “OK”
// button in a dialog and synthesize clicks on it. However see
// gtk_test_find_label(), gtk_test_find_sibling() and gtk_test_widget_click()
// for possible caveats involving the search of such widgets and synthesizing
// widget events.
	func TestFindWidget(widget WidgetClass, labelPattern string, widgetType externglib.Type) Widget {
var _arg1 *C.GtkWidget // out
var _arg2 *C.gchar // out
var _arg3 C.GType // out
var _cret *C.GtkWidget // in

_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg2 = (*C.gchar)(C.CString(labelPattern))
defer C.free(unsafe.Pointer(_arg2))
_arg3 = C.GType(widgetType)

_cret = C.gtk_test_find_widget(_arg1, _arg2, _arg3)


var _ret Widget // out

_ret = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _ret
}


	// TestRegisterAllTypes: force registration of all core Gtk+ and Gdk object
// types. This allowes to refer to any of those object types via
// g_type_from_name() after calling this function.
	func TestRegisterAllTypes()  {
C.gtk_test_register_all_types()
}


	// TestSliderGetValue: retrive the literal adjustment value for GtkRange based
// widgets and spin buttons. Note that the value returned by this function is
// anything between the lower and upper bounds of the adjustment belonging to
// @widget, and is not a percentage as passed in to gtk_test_slider_set_perc().
	func TestSliderGetValue(widget WidgetClass) float64 {
var _arg1 *C.GtkWidget // out
var _cret C.double // in

_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

_cret = C.gtk_test_slider_get_value(_arg1)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}


	// TestSliderSetPerc: this function will adjust the slider position of all
// GtkRange based widgets, such as scrollbars or scales, it’ll also adjust spin
// buttons. The adjustment value of these widgets is set to a value between the
// lower and upper limits, according to the @percentage argument.
	func TestSliderSetPerc(widget WidgetClass, percentage float64)  {
var _arg1 *C.GtkWidget // out
var _arg2 C.double // out

_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg2 = (C.double)(percentage)

C.gtk_test_slider_set_perc(_arg1, _arg2)
}


	// TestSpinButtonClick: this function will generate a @button click in the
// upwards or downwards spin button arrow areas, usually leading to an increase
// or decrease of spin button’s value.
	func TestSpinButtonClick(spinner SpinButtonClass, button uint, upwards bool) bool {
var _arg1 *C.GtkSpinButton // out
var _arg2 C.guint // out
var _arg3 C.gboolean // out
var _cret C.gboolean // in

_arg1 = (*C.GtkSpinButton)(unsafe.Pointer(spinner.Native()))
_arg2 = (C.guint)(button)
if upwards { _arg3 = C.TRUE }

_cret = C.gtk_test_spin_button_click(_arg1, _arg2, _arg3)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}


	// TestTextGet: retrive the text string of @widget if it is a GtkLabel,
// GtkEditable (entry and text widgets) or GtkTextView.
	func TestTextGet(widget WidgetClass) string {
var _arg1 *C.GtkWidget // out
var _cret *C.gchar // in

_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

_cret = C.gtk_test_text_get(_arg1)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}


	// TestTextSet: set the text string of @widget to @string if it is a GtkLabel,
// GtkEditable (entry and text widgets) or GtkTextView.
	func TestTextSet(widget WidgetClass, _string string)  {
var _arg1 *C.GtkWidget // out
var _arg2 *C.gchar // out

_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg2 = (*C.gchar)(C.CString(_string))
defer C.free(unsafe.Pointer(_arg2))

C.gtk_test_text_set(_arg1, _arg2)
}


	// TestWidgetClick: this function will generate a @button click (button press
// and button release event) in the middle of the first GdkWindow found that
// belongs to @widget. For windowless widgets like Button (which returns false
// from gtk_widget_get_has_window()), this will often be an input-only event
// window. For other widgets, this is usually widget->window. Certain caveats
// should be considered when using this function, in particular because the
// mouse pointer is warped to the button click location, see
// gdk_test_simulate_button() for details.
	func TestWidgetClick(widget WidgetClass, button uint, modifiers gdk.ModifierType) bool {
var _arg1 *C.GtkWidget // out
var _arg2 C.guint // out
var _arg3 C.GdkModifierType // out
var _cret C.gboolean // in

_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg2 = (C.guint)(button)
_arg3 = (C.GdkModifierType)(modifiers)

_cret = C.gtk_test_widget_click(_arg1, _arg2, _arg3)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}


	// TestWidgetSendKey: this function will generate keyboard press and release
// events in the middle of the first GdkWindow found that belongs to @widget.
// For windowless widgets like Button (which returns false from
// gtk_widget_get_has_window()), this will often be an input-only event window.
// For other widgets, this is usually widget->window. Certain caveats should be
// considered when using this function, in particular because the mouse pointer
// is warped to the key press location, see gdk_test_simulate_key() for details.
	func TestWidgetSendKey(widget WidgetClass, keyval uint, modifiers gdk.ModifierType) bool {
var _arg1 *C.GtkWidget // out
var _arg2 C.guint // out
var _arg3 C.GdkModifierType // out
var _cret C.gboolean // in

_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg2 = (C.guint)(keyval)
_arg3 = (C.GdkModifierType)(modifiers)

_cret = C.gtk_test_widget_send_key(_arg1, _arg2, _arg3)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}


	// TestWidgetWaitForDraw enters the main loop and waits for @widget to be
// “drawn”. In this context that means it waits for the frame clock of @widget
// to have run a full styling, layout and drawing cycle.
// 
// This function is intended to be used for syncing with actions that depend on
// @widget relayouting or on interaction with the display server.
	func TestWidgetWaitForDraw(widget WidgetClass)  {
var _arg1 *C.GtkWidget // out

_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

C.gtk_test_widget_wait_for_draw(_arg1)
}


	// TreeGetRowDragData obtains a @tree_model and @path from selection data of
// target type GTK_TREE_MODEL_ROW. Normally called from a drag_data_received
// handler. This function can only be used if @selection_data originates from
// the same process that’s calling this function, because a pointer to the tree
// model is being passed around. If you aren’t in the same process, then you'll
// get memory corruption. In the TreeDragDest drag_data_received handler, you
// can assume that selection data of type GTK_TREE_MODEL_ROW is in from the
// current process. The returned path must be freed with gtk_tree_path_free().
	func TreeGetRowDragData(selectionData *SelectionData) (TreeModel, *TreePath, bool) {
var _arg1 *C.GtkSelectionData // out
var _arg2 *C.GtkTreeModel // in
var _path *TreePath
var _cret C.gboolean // in

_arg1 = (*C.GtkSelectionData)(unsafe.Pointer(selectionData.Native()))

_cret = C.gtk_tree_get_row_drag_data(_arg1, &_arg2, (**C.GtkTreePath)(unsafe.Pointer(&_path)))


var _treeModel TreeModel // out

var _ok bool // out

_treeModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_arg2))).(TreeModel)

if _cret != 0 { _ok = true }

return _treeModel, _path, _ok
}


	// TreeSetRowDragData sets selection data of target type GTK_TREE_MODEL_ROW.
// Normally used in a drag_data_get handler.
	func TreeSetRowDragData(selectionData *SelectionData, treeModel TreeModel, path *TreePath) bool {
var _arg1 *C.GtkSelectionData // out
var _arg2 *C.GtkTreeModel // out
var _arg3 *C.GtkTreePath // out
var _cret C.gboolean // in

_arg1 = (*C.GtkSelectionData)(unsafe.Pointer(selectionData.Native()))
_arg2 = (*C.GtkTreeModel)(unsafe.Pointer(treeModel.Native()))
_arg3 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

_cret = C.gtk_tree_set_row_drag_data(_arg1, _arg2, _arg3)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}


	// True: all this function does it to return true.
// 
// This can be useful for example if you want to inhibit the deletion of a
// window. Of course you should not do this as the user expects a reaction from
// clicking the close icon of the window...
// 
// A persistent window
// 
//    #include <gtk/gtk.h>
// 
//    int
//    main (int argc, char **argv)
//    {
//      GtkWidget *win, *but;
//      const char *text = "Close yourself. I mean it!";
// 
//      gtk_init (&argc, &argv);
// 
//      win = gtk_window_new (GTK_WINDOW_TOPLEVEL);
//      g_signal_connect (win,
//                        "delete-event",
//                        G_CALLBACK (gtk_true),
//                        NULL);
//      g_signal_connect (win, "destroy",
//                        G_CALLBACK (gtk_main_quit),
//                        NULL);
// 
//      but = gtk_button_new_with_label (text);
//      g_signal_connect_swapped (but, "clicked",
//                                G_CALLBACK (gtk_object_destroy),
//                                win);
//      gtk_container_add (GTK_CONTAINER (win), but);
// 
//      gtk_widget_show_all (win);
// 
//      gtk_main ();
// 
//      return 0;
//    }
	func True() bool {
var _cret C.gboolean // in

_cret = C.gtk_true()


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}


	
	// ActionableInterface contains virtual methods for Actionable, or
	// methods that can be overridden.
	type ActionableInterface interface {
		gextras.Objector

			// ActionName gets the action name for @actionable.
	// 
	// See gtk_actionable_set_action_name() for more information.
		ActionName() string
			// ActionTargetValue gets the current target value of @actionable.
	// 
	// See gtk_actionable_set_action_target_value() for more information.
		ActionTargetValue() *glib.Variant
			// SetActionName specifies the name of the action with which this widget
	// should be associated. If @action_name is nil then the widget will be
	// unassociated from any previous action.
	// 
	// Usually this function is used when the widget is located (or will be
	// located) within the hierarchy of a ApplicationWindow.
	// 
	// Names are of the form “win.save” or “app.quit” for actions on the
	// containing ApplicationWindow or its associated Application, respectively.
	// This is the same form used for actions in the #GMenu associated with the
	// window.
		SetActionName(actionName string) 
			// SetActionTargetValue sets the target value of an actionable widget.
	// 
	// If @target_value is nil then the target value is unset.
	// 
	// The target value has two purposes. First, it is used as the parameter to
	// activation of the action associated with the Actionable widget. Second,
	// it is used to determine if the widget should be rendered as “active” —
	// the widget is active if the state is equal to the given target.
	// 
	// Consider the example of associating a set of buttons with a #GAction with
	// string state in a typical “radio button” situation. Each button will be
	// associated with the same action, but with a different target value for
	// that action. Clicking on a particular button will activate the action
	// with the target of that button, which will typically cause the action’s
	// state to change to that value. Since the action’s state is now equal to
	// the target value of the button, the button will now be rendered as active
	// (and the other buttons, with different targets, rendered inactive).
		SetActionTargetValue(targetValue *glib.Variant) 
		
	}
	

	// Actionable: this interface provides a convenient way of associating widgets
// with actions on a ApplicationWindow or Application.
// 
// It primarily consists of two properties: Actionable:action-name and
// Actionable:action-target. There are also some convenience APIs for setting
// these properties.
// 
// The action will be looked up in action groups that are found among the
// widgets ancestors. Most commonly, these will be the actions with the “win.”
// or “app.” prefix that are associated with the ApplicationWindow or
// Application, but other action groups that are added with
// gtk_widget_insert_action_group() will be consulted as well.
	type Actionable struct {
		Widget
		
	}

	
	func marshalActionable(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return {Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
} map[github.com/gotk3/gotk3/glib:externglib]}, nil
	}
	

	
	// ActionName gets the action name for @actionable.
// 
// See gtk_actionable_set_action_name() for more information.
	func (a Actionable) ActionName() string {
var _arg0 *C.GtkActionable // out
var _cret *C.gchar // in

_arg0 = (*C.GtkActionable)(unsafe.Pointer(a.Native()))

_cret = C.gtk_actionable_get_action_name(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// ActionTargetValue gets the current target value of @actionable.
// 
// See gtk_actionable_set_action_target_value() for more information.
	func (a Actionable) ActionTargetValue() *glib.Variant {
var _arg0 *C.GtkActionable // out
var _cret *C.GVariant // in

_arg0 = (*C.GtkActionable)(unsafe.Pointer(a.Native()))

_cret = C.gtk_actionable_get_action_target_value(_arg0)


var _variant *glib.Variant // out

_variant = *(**glib.Variant)(unsafe.Pointer(&_cret))

return _variant
}
	
	// SetActionName specifies the name of the action with which this widget should
// be associated. If @action_name is nil then the widget will be unassociated
// from any previous action.
// 
// Usually this function is used when the widget is located (or will be located)
// within the hierarchy of a ApplicationWindow.
// 
// Names are of the form “win.save” or “app.quit” for actions on the containing
// ApplicationWindow or its associated Application, respectively. This is the
// same form used for actions in the #GMenu associated with the window.
	func (a Actionable) SetActionName(actionName string)  {
var _arg0 *C.GtkActionable // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkActionable)(unsafe.Pointer(a.Native()))
_arg1 = (*C.gchar)(C.CString(actionName))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_actionable_set_action_name(_arg0, _arg1)
}
	
	// SetActionTargetValue sets the target value of an actionable widget.
// 
// If @target_value is nil then the target value is unset.
// 
// The target value has two purposes. First, it is used as the parameter to
// activation of the action associated with the Actionable widget. Second, it is
// used to determine if the widget should be rendered as “active” — the widget
// is active if the state is equal to the given target.
// 
// Consider the example of associating a set of buttons with a #GAction with
// string state in a typical “radio button” situation. Each button will be
// associated with the same action, but with a different target value for that
// action. Clicking on a particular button will activate the action with the
// target of that button, which will typically cause the action’s state to
// change to that value. Since the action’s state is now equal to the target
// value of the button, the button will now be rendered as active (and the other
// buttons, with different targets, rendered inactive).
	func (a Actionable) SetActionTargetValue(targetValue *glib.Variant)  {
var _arg0 *C.GtkActionable // out
var _arg1 *C.GVariant // out

_arg0 = (*C.GtkActionable)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GVariant)(unsafe.Pointer(targetValue.Native()))

C.gtk_actionable_set_action_target_value(_arg0, _arg1)
}
	
	// SetDetailedActionName sets the action-name and associated string target value
// of an actionable widget.
// 
// @detailed_action_name is a string in the format accepted by
// g_action_parse_detailed_name().
// 
// (Note that prior to version 3.22.25, this function is only usable for actions
// with a simple "s" target, and @detailed_action_name must be of the form
// `"action::target"` where `action` is the action name and `target` is the
// string to use as the target.)
	func (a Actionable) SetDetailedActionName(detailedActionName string)  {
var _arg0 *C.GtkActionable // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkActionable)(unsafe.Pointer(a.Native()))
_arg1 = (*C.gchar)(C.CString(detailedActionName))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_actionable_set_detailed_action_name(_arg0, _arg1)
}
	


	
	// ActivatableInterface contains virtual methods for Activatable, or
	// methods that can be overridden.
	type ActivatableInterface interface {
		gextras.Objector

			// SyncActionProperties: this is called to update the activatable
	// completely, this is called internally when the Activatable:related-action
	// property is set or unset and by the implementing class when
	// Activatable:use-action-appearance changes.
		SyncActionProperties(action ActionClass) 
		
		Update(action ActionClass, propertyName string) 
		
	}
	

	// Activatable: activatable widgets can be connected to a Action and reflects
// the state of its action. A Activatable can also provide feedback through its
// action, as they are responsible for activating their related actions.
// 
// 
// Implementing GtkActivatable
// 
// When extending a class that is already Activatable; it is only necessary to
// implement the Activatable->sync_action_properties() and Activatable->update()
// methods and chain up to the parent implementation, however when introducing a
// new Activatable class; the Activatable:related-action and
// Activatable:use-action-appearance properties need to be handled by the
// implementor. Handling these properties is mostly a matter of installing the
// action pointer and boolean flag on your instance, and calling
// gtk_activatable_do_set_related_action() and
// gtk_activatable_sync_action_properties() at the appropriate times.
// 
// A class fragment implementing Activatable
// 
// 
//    enum {
//    ...
// 
//    PROP_ACTIVATABLE_RELATED_ACTION,
//    PROP_ACTIVATABLE_USE_ACTION_APPEARANCE
//    }
// 
//    struct _FooBarPrivate
//    {
// 
//      ...
// 
//      GtkAction      *action;
//      gboolean        use_action_appearance;
//    };
// 
//    ...
// 
//    static void foo_bar_activatable_interface_init         (GtkActivatableIface  *iface);
//    static void foo_bar_activatable_update                 (GtkActivatable       *activatable,
//    						           GtkAction            *action,
//    						           const gchar          *property_name);
//    static void foo_bar_activatable_sync_action_properties (GtkActivatable       *activatable,
//    						           GtkAction            *action);
//    ...
// 
// 
//    static void
//    foo_bar_class_init (FooBarClass *klass)
//    {
// 
//      ...
// 
//      g_object_class_override_property (gobject_class, PROP_ACTIVATABLE_RELATED_ACTION, "related-action");
//      g_object_class_override_property (gobject_class, PROP_ACTIVATABLE_USE_ACTION_APPEARANCE, "use-action-appearance");
// 
//      ...
//    }
// 
// 
//    static void
//    foo_bar_activatable_interface_init (GtkActivatableIface  *iface)
//    {
//      iface->update = foo_bar_activatable_update;
//      iface->sync_action_properties = foo_bar_activatable_sync_action_properties;
//    }
// 
//    ... Break the reference using gtk_activatable_do_set_related_action()...
// 
//    static void
//    foo_bar_dispose (GObject *object)
//    {
//      FooBar *bar = FOO_BAR (object);
//      FooBarPrivate *priv = FOO_BAR_GET_PRIVATE (bar);
// 
//      ...
// 
//      if (priv->action)
//        {
//          gtk_activatable_do_set_related_action (GTK_ACTIVATABLE (bar), NULL);
//          priv->action = NULL;
//        }
//      G_OBJECT_CLASS (foo_bar_parent_class)->dispose (object);
//    }
// 
//    ... Handle the “related-action” and “use-action-appearance” properties ...
// 
//    static void
//    foo_bar_set_property (GObject         *object,
//                          guint            prop_id,
//                          const GValue    *value,
//                          GParamSpec      *pspec)
//    {
//      FooBar *bar = FOO_BAR (object);
//      FooBarPrivate *priv = FOO_BAR_GET_PRIVATE (bar);
// 
//      switch (prop_id)
//        {
// 
//          ...
// 
//        case PROP_ACTIVATABLE_RELATED_ACTION:
//          foo_bar_set_related_action (bar, g_value_get_object (value));
//          break;
//        case PROP_ACTIVATABLE_USE_ACTION_APPEARANCE:
//          foo_bar_set_use_action_appearance (bar, g_value_get_boolean (value));
//          break;
//        default:
//          G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
//          break;
//        }
//    }
// 
//    static void
//    foo_bar_get_property (GObject         *object,
//                             guint            prop_id,
//                             GValue          *value,
//                             GParamSpec      *pspec)
//    {
//      FooBar *bar = FOO_BAR (object);
//      FooBarPrivate *priv = FOO_BAR_GET_PRIVATE (bar);
// 
//      switch (prop_id)
//        {
// 
//          ...
// 
//        case PROP_ACTIVATABLE_RELATED_ACTION:
//          g_value_set_object (value, priv->action);
//          break;
//        case PROP_ACTIVATABLE_USE_ACTION_APPEARANCE:
//          g_value_set_boolean (value, priv->use_action_appearance);
//          break;
//        default:
//          G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
//          break;
//        }
//    }
// 
// 
//    static void
//    foo_bar_set_use_action_appearance (FooBar   *bar,
//    				   gboolean  use_appearance)
//    {
//      FooBarPrivate *priv = FOO_BAR_GET_PRIVATE (bar);
// 
//      if (priv->use_action_appearance != use_appearance)
//        {
//          priv->use_action_appearance = use_appearance;
//          
//          gtk_activatable_sync_action_properties (GTK_ACTIVATABLE (bar), priv->action);
//        }
//    }
// 
//    ... call gtk_activatable_do_set_related_action() and then assign the action pointer,
//    no need to reference the action here since gtk_activatable_do_set_related_action() already
//    holds a reference here for you...
//    static void
//    foo_bar_set_related_action (FooBar    *bar,
//    			    GtkAction *action)
//    {
//      FooBarPrivate *priv = FOO_BAR_GET_PRIVATE (bar);
// 
//      if (priv->action == action)
//        return;
// 
//      gtk_activatable_do_set_related_action (GTK_ACTIVATABLE (bar), action);
// 
//      priv->action = action;
//    }
// 
//    ... Selectively reset and update activatable depending on the use-action-appearance property ...
//    static void
//    gtk_button_activatable_sync_action_properties (GtkActivatable       *activatable,
//    		                                  GtkAction            *action)
//    {
//      GtkButtonPrivate *priv = GTK_BUTTON_GET_PRIVATE (activatable);
// 
//      if (!action)
//        return;
// 
//      if (gtk_action_is_visible (action))
//        gtk_widget_show (GTK_WIDGET (activatable));
//      else
//        gtk_widget_hide (GTK_WIDGET (activatable));
//      
//      gtk_widget_set_sensitive (GTK_WIDGET (activatable), gtk_action_is_sensitive (action));
// 
//      ...
//      
//      if (priv->use_action_appearance)
//        {
//          if (gtk_action_get_stock_id (action))
//    	foo_bar_set_stock (button, gtk_action_get_stock_id (action));
//          else if (gtk_action_get_label (action))
//    	foo_bar_set_label (button, gtk_action_get_label (action));
// 
//          ...
// 
//        }
//    }
// 
//    static void
//    foo_bar_activatable_update (GtkActivatable       *activatable,
//    			       GtkAction            *action,
//    			       const gchar          *property_name)
//    {
//      FooBarPrivate *priv = FOO_BAR_GET_PRIVATE (activatable);
// 
//      if (strcmp (property_name, "visible") == 0)
//        {
//          if (gtk_action_is_visible (action))
//    	gtk_widget_show (GTK_WIDGET (activatable));
//          else
//    	gtk_widget_hide (GTK_WIDGET (activatable));
//        }
//      else if (strcmp (property_name, "sensitive") == 0)
//        gtk_widget_set_sensitive (GTK_WIDGET (activatable), gtk_action_is_sensitive (action));
// 
//      ...
// 
//      if (!priv->use_action_appearance)
//        return;
// 
//      if (strcmp (property_name, "stock-id") == 0)
//        foo_bar_set_stock (button, gtk_action_get_stock_id (action));
//      else if (strcmp (property_name, "label") == 0)
//        foo_bar_set_label (button, gtk_action_get_label (action));
// 
//      ...
//    }
	type Activatable struct {
		**externglib.Object
		
	}

	
	func marshalActivatable(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return {Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
} map[github.com/gotk3/gotk3/glib:externglib]}, nil
	}
	

	
	// DoSetRelatedAction: this is a utility function for Activatable implementors.
// 
// When implementing Activatable you must call this when handling changes of the
// Activatable:related-action, and you must also use this to break references in
// #GObject->dispose().
// 
// This function adds a reference to the currently set related action for you,
// it also makes sure the Activatable->update() method is called when the
// related Action properties change and registers to the action’s proxy list.
// 
// > Be careful to call this before setting the local > copy of the Action
// property, since this function uses > gtk_activatable_get_related_action() to
// retrieve the > previous action.
	func (a Activatable) DoSetRelatedAction(action ActionClass)  {
var _arg0 *C.GtkActivatable // out
var _arg1 *C.GtkAction // out

_arg0 = (*C.GtkActivatable)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkAction)(unsafe.Pointer(action.Native()))

C.gtk_activatable_do_set_related_action(_arg0, _arg1)
}
	
	// RelatedAction gets the related Action for @activatable.
	func (a Activatable) RelatedAction() Action {
var _arg0 *C.GtkActivatable // out
var _cret *C.GtkAction // in

_arg0 = (*C.GtkActivatable)(unsafe.Pointer(a.Native()))

_cret = C.gtk_activatable_get_related_action(_arg0)


var _action Action // out

_action = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Action)

return _action
}
	
	// UseActionAppearance gets whether this activatable should reset its layout and
// appearance when setting the related action or when the action changes
// appearance.
	func (a Activatable) UseActionAppearance() bool {
var _arg0 *C.GtkActivatable // out
var _cret C.gboolean // in

_arg0 = (*C.GtkActivatable)(unsafe.Pointer(a.Native()))

_cret = C.gtk_activatable_get_use_action_appearance(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetRelatedAction sets the related action on the @activatable object.
// 
// > Activatable implementors need to handle the Activatable:related-action >
// property and call gtk_activatable_do_set_related_action() when it changes.
	func (a Activatable) SetRelatedAction(action ActionClass)  {
var _arg0 *C.GtkActivatable // out
var _arg1 *C.GtkAction // out

_arg0 = (*C.GtkActivatable)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkAction)(unsafe.Pointer(action.Native()))

C.gtk_activatable_set_related_action(_arg0, _arg1)
}
	
	// SetUseActionAppearance sets whether this activatable should reset its layout
// and appearance when setting the related action or when the action changes
// appearance
// 
// > Activatable implementors need to handle the >
// Activatable:use-action-appearance property and call >
// gtk_activatable_sync_action_properties() to update @activatable > if needed.
	func (a Activatable) SetUseActionAppearance(useAppearance bool)  {
var _arg0 *C.GtkActivatable // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkActivatable)(unsafe.Pointer(a.Native()))
if useAppearance { _arg1 = C.TRUE }

C.gtk_activatable_set_use_action_appearance(_arg0, _arg1)
}
	
	// SyncActionProperties: this is called to update the activatable completely,
// this is called internally when the Activatable:related-action property is set
// or unset and by the implementing class when Activatable:use-action-appearance
// changes.
	func (a Activatable) SyncActionProperties(action ActionClass)  {
var _arg0 *C.GtkActivatable // out
var _arg1 *C.GtkAction // out

_arg0 = (*C.GtkActivatable)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkAction)(unsafe.Pointer(action.Native()))

C.gtk_activatable_sync_action_properties(_arg0, _arg1)
}
	


	

	// AppChooser is an interface that can be implemented by widgets which allow the
// user to choose an application (typically for the purpose of opening a file).
// The main objects that implement this interface are AppChooserWidget,
// AppChooserDialog and AppChooserButton.
// 
// Applications are represented by GIO Info objects here. GIO has a concept of
// recommended and fallback applications for a given content type. Recommended
// applications are those that claim to handle the content type itself, while
// fallback also includes applications that handle a more generic content type.
// GIO also knows the default and last-used application for a given content
// type. The AppChooserWidget provides detailed control over whether the shown
// list of applications should include default, recommended or fallback
// applications.
// 
// To obtain the application that has been selected in a AppChooser, use
// gtk_app_chooser_get_app_info().
	type AppChooser struct {
		Widget
		
	}

	
	func marshalAppChooser(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return {AppChooser{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
} map[github.com/gotk3/gotk3/glib:externglib]}, nil
	}
	

	
	// AppInfo returns the currently selected application.
	func (s AppChooser) AppInfo() gio.AppInfo {
var _arg0 *C.GtkAppChooser // out
var _cret *C.GAppInfo // in

_arg0 = (*C.GtkAppChooser)(unsafe.Pointer(s.Native()))

_cret = C.gtk_app_chooser_get_app_info(_arg0)


var _appInfo gio.AppInfo // out

_appInfo = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gio.AppInfo)

return _appInfo
}
	
	// ContentType returns the current value of the AppChooser:content-type
// property.
	func (s AppChooser) ContentType() string {
var _arg0 *C.GtkAppChooser // out
var _cret *C.gchar // in

_arg0 = (*C.GtkAppChooser)(unsafe.Pointer(s.Native()))

_cret = C.gtk_app_chooser_get_content_type(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// Refresh reloads the list of applications.
	func (s AppChooser) Refresh()  {
var _arg0 *C.GtkAppChooser // out

_arg0 = (*C.GtkAppChooser)(unsafe.Pointer(s.Native()))

C.gtk_app_chooser_refresh(_arg0)
}
	


	
	// BuildableInterface contains virtual methods for Buildable, or
	// methods that can be overridden.
	type BuildableInterface interface {
		gextras.Objector

			// AddChild adds a child to @buildable. @type is an optional string
	// describing how the child should be added.
		AddChild(builder BuilderClass, child **externglib.Object, typ string) 
			// ConstructChild constructs a child of @buildable with the name @name.
	// 
	// Builder calls this function if a “constructor” has been specified in the
	// UI definition.
		ConstructChild(builder BuilderClass, name string) **externglib.Object
			// InternalChild: get the internal child called @childname of the @buildable
	// object.
		InternalChild(builder BuilderClass, childname string) **externglib.Object
			// Name gets the name of the @buildable object.
	// 
	// Builder sets the name based on the [GtkBuilder UI definition][BUILDER-UI]
	// used to construct the @buildable.
		Name() string
			// ParserFinished: called when the builder finishes the parsing of a
	// [GtkBuilder UI definition][BUILDER-UI]. Note that this will be called
	// once for each time gtk_builder_add_from_file() or
	// gtk_builder_add_from_string() is called on a builder.
		ParserFinished(builder BuilderClass) 
			// SetBuildableProperty sets the property name @name to @value on the
	// @buildable object.
		SetBuildableProperty(builder BuilderClass, name string, value **externglib.Value) 
			// SetName sets the name of the @buildable object.
		SetName(name string) 
		
	}
	

	// Buildable: gtkBuildable allows objects to extend and customize their
// deserialization from [GtkBuilder UI descriptions][BUILDER-UI]. The interface
// includes methods for setting names and properties of objects, parsing custom
// tags and constructing child objects.
// 
// The GtkBuildable interface is implemented by all widgets and many of the
// non-widget objects that are provided by GTK+. The main user of this interface
// is Builder. There should be very little need for applications to call any of
// these functions directly.
// 
// An object only needs to implement this interface if it needs to extend the
// Builder format or run any extra routines at deserialization time.
	type Buildable struct {
		**externglib.Object
		
	}

	
	func marshalBuildable(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return {Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
} map[github.com/gotk3/gotk3/glib:externglib]}, nil
	}
	

	
	// AddChild adds a child to @buildable. @type is an optional string describing
// how the child should be added.
	func (b Buildable) AddChild(builder BuilderClass, child **externglib.Object, typ string)  {
var _arg0 *C.GtkBuildable // out
var _arg1 *C.GtkBuilder // out
var _arg2 *C.GObject // out
var _arg3 *C.gchar // out

_arg0 = (*C.GtkBuildable)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkBuilder)(unsafe.Pointer(builder.Native()))
_arg2 = (*C.GObject)(unsafe.Pointer(child.Native()))
_arg3 = (*C.gchar)(C.CString(typ))
defer C.free(unsafe.Pointer(_arg3))

C.gtk_buildable_add_child(_arg0, _arg1, _arg2, _arg3)
}
	
	// ConstructChild constructs a child of @buildable with the name @name.
// 
// Builder calls this function if a “constructor” has been specified in the UI
// definition.
	func (b Buildable) ConstructChild(builder BuilderClass, name string) **externglib.Object {
var _arg0 *C.GtkBuildable // out
var _arg1 *C.GtkBuilder // out
var _arg2 *C.gchar // out
var _cret *C.GObject // in

_arg0 = (*C.GtkBuildable)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkBuilder)(unsafe.Pointer(builder.Native()))
_arg2 = (*C.gchar)(C.CString(name))
defer C.free(unsafe.Pointer(_arg2))

_cret = C.gtk_buildable_construct_child(_arg0, _arg1, _arg2)


var _object **externglib.Object // out

_object = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(**externglib.Object)

return _object
}
	
	// InternalChild: get the internal child called @childname of the @buildable
// object.
	func (b Buildable) InternalChild(builder BuilderClass, childname string) **externglib.Object {
var _arg0 *C.GtkBuildable // out
var _arg1 *C.GtkBuilder // out
var _arg2 *C.gchar // out
var _cret *C.GObject // in

_arg0 = (*C.GtkBuildable)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkBuilder)(unsafe.Pointer(builder.Native()))
_arg2 = (*C.gchar)(C.CString(childname))
defer C.free(unsafe.Pointer(_arg2))

_cret = C.gtk_buildable_get_internal_child(_arg0, _arg1, _arg2)


var _object **externglib.Object // out

_object = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(**externglib.Object)

return _object
}
	
	// Name gets the name of the @buildable object.
// 
// Builder sets the name based on the [GtkBuilder UI definition][BUILDER-UI]
// used to construct the @buildable.
	func (b Buildable) Name() string {
var _arg0 *C.GtkBuildable // out
var _cret *C.gchar // in

_arg0 = (*C.GtkBuildable)(unsafe.Pointer(b.Native()))

_cret = C.gtk_buildable_get_name(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// ParserFinished: called when the builder finishes the parsing of a [GtkBuilder
// UI definition][BUILDER-UI]. Note that this will be called once for each time
// gtk_builder_add_from_file() or gtk_builder_add_from_string() is called on a
// builder.
	func (b Buildable) ParserFinished(builder BuilderClass)  {
var _arg0 *C.GtkBuildable // out
var _arg1 *C.GtkBuilder // out

_arg0 = (*C.GtkBuildable)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkBuilder)(unsafe.Pointer(builder.Native()))

C.gtk_buildable_parser_finished(_arg0, _arg1)
}
	
	// SetBuildableProperty sets the property name @name to @value on the @buildable
// object.
	func (b Buildable) SetBuildableProperty(builder BuilderClass, name string, value **externglib.Value)  {
var _arg0 *C.GtkBuildable // out
var _arg1 *C.GtkBuilder // out
var _arg2 *C.gchar // out
var _arg3 *C.GValue // out

_arg0 = (*C.GtkBuildable)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkBuilder)(unsafe.Pointer(builder.Native()))
_arg2 = (*C.gchar)(C.CString(name))
defer C.free(unsafe.Pointer(_arg2))
_arg3 = (*C.GValue)(value.GValue)

C.gtk_buildable_set_buildable_property(_arg0, _arg1, _arg2, _arg3)
}
	
	// SetName sets the name of the @buildable object.
	func (b Buildable) SetName(name string)  {
var _arg0 *C.GtkBuildable // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkBuildable)(unsafe.Pointer(b.Native()))
_arg1 = (*C.gchar)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_buildable_set_name(_arg0, _arg1)
}
	


	
	// CellAccessibleParentInterface contains virtual methods for CellAccessibleParent, or
	// methods that can be overridden.
	type CellAccessibleParentInterface interface {
		gextras.Objector

		
		Activate(cell CellAccessibleClass) 
		
		Edit(cell CellAccessibleClass) 
		
		ExpandCollapse(cell CellAccessibleClass) 
		
		CellArea(cell CellAccessibleClass) gdk.Rectangle
		
		CellPosition(cell CellAccessibleClass) (row int, column int)
		
		ChildIndex(cell CellAccessibleClass) int
		
		RendererState(cell CellAccessibleClass) CellRendererState
		
		GrabFocus(cell CellAccessibleClass) bool
		
	}
	

	
	type CellAccessibleParent struct {
		**externglib.Object
		
	}

	
	func marshalCellAccessibleParent(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return {CellAccessibleParent{
Object: &externglib.Object{externglib.ToGObject(obj)},
} map[github.com/gotk3/gotk3/glib:externglib]}, nil
	}
	

	
	
	func (p CellAccessibleParent) Activate(cell CellAccessibleClass)  {
var _arg0 *C.GtkCellAccessibleParent // out
var _arg1 *C.GtkCellAccessible // out

_arg0 = (*C.GtkCellAccessibleParent)(unsafe.Pointer(p.Native()))
_arg1 = (*C.GtkCellAccessible)(unsafe.Pointer(cell.Native()))

C.gtk_cell_accessible_parent_activate(_arg0, _arg1)
}
	
	
	func (p CellAccessibleParent) Edit(cell CellAccessibleClass)  {
var _arg0 *C.GtkCellAccessibleParent // out
var _arg1 *C.GtkCellAccessible // out

_arg0 = (*C.GtkCellAccessibleParent)(unsafe.Pointer(p.Native()))
_arg1 = (*C.GtkCellAccessible)(unsafe.Pointer(cell.Native()))

C.gtk_cell_accessible_parent_edit(_arg0, _arg1)
}
	
	
	func (p CellAccessibleParent) ExpandCollapse(cell CellAccessibleClass)  {
var _arg0 *C.GtkCellAccessibleParent // out
var _arg1 *C.GtkCellAccessible // out

_arg0 = (*C.GtkCellAccessibleParent)(unsafe.Pointer(p.Native()))
_arg1 = (*C.GtkCellAccessible)(unsafe.Pointer(cell.Native()))

C.gtk_cell_accessible_parent_expand_collapse(_arg0, _arg1)
}
	
	
	func (p CellAccessibleParent) CellArea(cell CellAccessibleClass) gdk.Rectangle {
var _arg0 *C.GtkCellAccessibleParent // out
var _arg1 *C.GtkCellAccessible // out
var _cellRect gdk.Rectangle

_arg0 = (*C.GtkCellAccessibleParent)(unsafe.Pointer(p.Native()))
_arg1 = (*C.GtkCellAccessible)(unsafe.Pointer(cell.Native()))

C.gtk_cell_accessible_parent_get_cell_area(_arg0, _arg1, (*C.GdkRectangle)(unsafe.Pointer(&_cellRect)))





return _cellRect
}
	
	
	func (p CellAccessibleParent) CellPosition(cell CellAccessibleClass) (row int, column int) {
var _arg0 *C.GtkCellAccessibleParent // out
var _arg1 *C.GtkCellAccessible // out
var _arg2 C.gint // in
var _arg3 C.gint // in

_arg0 = (*C.GtkCellAccessibleParent)(unsafe.Pointer(p.Native()))
_arg1 = (*C.GtkCellAccessible)(unsafe.Pointer(cell.Native()))

C.gtk_cell_accessible_parent_get_cell_position(_arg0, _arg1, &_arg2, &_arg3)

var _row int // out
var _column int // out

_row = (int)(_arg2)
_column = (int)(_arg3)

return _row, _column
}
	
	
	func (p CellAccessibleParent) ChildIndex(cell CellAccessibleClass) int {
var _arg0 *C.GtkCellAccessibleParent // out
var _arg1 *C.GtkCellAccessible // out
var _cret C.int // in

_arg0 = (*C.GtkCellAccessibleParent)(unsafe.Pointer(p.Native()))
_arg1 = (*C.GtkCellAccessible)(unsafe.Pointer(cell.Native()))

_cret = C.gtk_cell_accessible_parent_get_child_index(_arg0, _arg1)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	
	func (p CellAccessibleParent) RendererState(cell CellAccessibleClass) CellRendererState {
var _arg0 *C.GtkCellAccessibleParent // out
var _arg1 *C.GtkCellAccessible // out
var _cret C.GtkCellRendererState // in

_arg0 = (*C.GtkCellAccessibleParent)(unsafe.Pointer(p.Native()))
_arg1 = (*C.GtkCellAccessible)(unsafe.Pointer(cell.Native()))

_cret = C.gtk_cell_accessible_parent_get_renderer_state(_arg0, _arg1)


var _cellRendererState CellRendererState // out

_cellRendererState = CellRendererState(_cret)

return _cellRendererState
}
	
	
	func (p CellAccessibleParent) GrabFocus(cell CellAccessibleClass) bool {
var _arg0 *C.GtkCellAccessibleParent // out
var _arg1 *C.GtkCellAccessible // out
var _cret C.gboolean // in

_arg0 = (*C.GtkCellAccessibleParent)(unsafe.Pointer(p.Native()))
_arg1 = (*C.GtkCellAccessible)(unsafe.Pointer(cell.Native()))

_cret = C.gtk_cell_accessible_parent_grab_focus(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	


	
	// CellEditableInterface contains virtual methods for CellEditable, or
	// methods that can be overridden.
	type CellEditableInterface interface {
		gextras.Objector

			// EditingDone emits the CellEditable::editing-done signal.
		EditingDone() 
			// RemoveWidget emits the CellEditable::remove-widget signal.
		RemoveWidget() 
		
	}
	

	// CellEditable: the CellEditable interface must be implemented for widgets to
// be usable to edit the contents of a TreeView cell. It provides a way to
// specify how temporary widgets should be configured for editing, get the new
// value, etc.
	type CellEditable struct {
		Widget
		
	}

	
	func marshalCellEditable(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return {CellEditable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
} map[github.com/gotk3/gotk3/glib:externglib]}, nil
	}
	

	
	// EditingDone emits the CellEditable::editing-done signal.
	func (c CellEditable) EditingDone()  {
var _arg0 *C.GtkCellEditable // out

_arg0 = (*C.GtkCellEditable)(unsafe.Pointer(c.Native()))

C.gtk_cell_editable_editing_done(_arg0)
}
	
	// RemoveWidget emits the CellEditable::remove-widget signal.
	func (c CellEditable) RemoveWidget()  {
var _arg0 *C.GtkCellEditable // out

_arg0 = (*C.GtkCellEditable)(unsafe.Pointer(c.Native()))

C.gtk_cell_editable_remove_widget(_arg0)
}
	


	
	// CellLayoutInterface contains virtual methods for CellLayout, or
	// methods that can be overridden.
	type CellLayoutInterface interface {
		gextras.Objector

			// AddAttribute adds an attribute mapping to the list in @cell_layout.
	// 
	// The @column is the column of the model to get a value from, and the
	// @attribute is the parameter on @cell to be set from the value. So for
	// example if column 2 of the model contains strings, you could have the
	// “text” attribute of a CellRendererText get its values from column 2.
		AddAttribute(cell CellRendererClass, attribute string, column int) 
			// Clear unsets all the mappings on all renderers on @cell_layout and
	// removes all renderers from @cell_layout.
		Clear() 
			// ClearAttributes clears all existing attributes previously set with
	// gtk_cell_layout_set_attributes().
		ClearAttributes(cell CellRendererClass) 
			// Area returns the underlying CellArea which might be @cell_layout if
	// called on a CellArea or might be nil if no CellArea is used by
	// @cell_layout.
		Area() CellArea
			// PackEnd adds the @cell to the end of @cell_layout. If @expand is false,
	// then the @cell is allocated no more space than it needs. Any unused space
	// is divided evenly between cells for which @expand is true.
	// 
	// Note that reusing the same cell renderer is not supported.
		PackEnd(cell CellRendererClass, expand bool) 
			// PackStart packs the @cell into the beginning of @cell_layout. If @expand
	// is false, then the @cell is allocated no more space than it needs. Any
	// unused space is divided evenly between cells for which @expand is true.
	// 
	// Note that reusing the same cell renderer is not supported.
		PackStart(cell CellRendererClass, expand bool) 
			// Reorder re-inserts @cell at @position.
	// 
	// Note that @cell has already to be packed into @cell_layout for this to
	// function properly.
		Reorder(cell CellRendererClass, position int) 
		
	}
	

	// CellLayout is an interface to be implemented by all objects which want to
// provide a TreeViewColumn like API for packing cells, setting attributes and
// data funcs.
// 
// One of the notable features provided by implementations of GtkCellLayout are
// attributes. Attributes let you set the properties in flexible ways. They can
// just be set to constant values like regular properties. But they can also be
// mapped to a column of the underlying tree model with
// gtk_cell_layout_set_attributes(), which means that the value of the attribute
// can change from cell to cell as they are rendered by the cell renderer.
// Finally, it is possible to specify a function with
// gtk_cell_layout_set_cell_data_func() that is called to determine the value of
// the attribute for each cell that is rendered.
// 
// 
// GtkCellLayouts as GtkBuildable
// 
// Implementations of GtkCellLayout which also implement the GtkBuildable
// interface (CellView, IconView, ComboBox, EntryCompletion, TreeViewColumn)
// accept GtkCellRenderer objects as <child> elements in UI definitions. They
// support a custom <attributes> element for their children, which can contain
// multiple <attribute> elements. Each <attribute> element has a name attribute
// which specifies a property of the cell renderer; the content of the element
// is the attribute value.
// 
// This is an example of a UI definition fragment specifying attributes:
// 
//    <object class="GtkCellView">
//      <child>
//        <object class="GtkCellRendererText"/>
//        <attributes>
//          <attribute name="text">0</attribute>
//        </attributes>
//      </child>"
//    </object>
// 
// Furthermore for implementations of GtkCellLayout that use a CellArea to lay
// out cells (all GtkCellLayouts in GTK+ use a GtkCellArea) [cell
// properties][cell-properties] can also be defined in the format by specifying
// the custom <cell-packing> attribute which can contain multiple <property>
// elements defined in the normal way.
// 
// Here is a UI definition fragment specifying cell properties:
// 
//    <object class="GtkTreeViewColumn">
//      <child>
//        <object class="GtkCellRendererText"/>
//        <cell-packing>
//          <property name="align">True</property>
//          <property name="expand">False</property>
//        </cell-packing>
//      </child>"
//    </object>
// 
// 
// Subclassing GtkCellLayout implementations
// 
// When subclassing a widget that implements CellLayout like IconView or
// ComboBox, there are some considerations related to the fact that these
// widgets internally use a CellArea. The cell area is exposed as a
// construct-only property by these widgets. This means that it is possible to
// e.g. do
// 
//    static void
//    my_combo_box_init (MyComboBox *b)
//    {
//      GtkCellRenderer *cell;
// 
//      cell = gtk_cell_renderer_pixbuf_new ();
//      // The following call causes the default cell area for combo boxes,
//      // a GtkCellAreaBox, to be instantiated
//      gtk_cell_layout_pack_start (GTK_CELL_LAYOUT (b), cell, FALSE);
//      ...
//    }
// 
//    GtkWidget *
//    my_combo_box_new (GtkCellArea *area)
//    {
//      // This call is going to cause a warning about area being ignored
//      return g_object_new (MY_TYPE_COMBO_BOX, "cell-area", area, NULL);
//    }
// 
// If supporting alternative cell areas with your derived widget is not
// important, then this does not have to concern you. If you want to support
// alternative cell areas, you can do so by moving the problematic calls out of
// init() and into a constructor() for your class.
	type CellLayout struct {
		**externglib.Object
		
	}

	
	func marshalCellLayout(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return {CellLayout{
Object: &externglib.Object{externglib.ToGObject(obj)},
} map[github.com/gotk3/gotk3/glib:externglib]}, nil
	}
	

	
	// AddAttribute adds an attribute mapping to the list in @cell_layout.
// 
// The @column is the column of the model to get a value from, and the
// @attribute is the parameter on @cell to be set from the value. So for example
// if column 2 of the model contains strings, you could have the “text”
// attribute of a CellRendererText get its values from column 2.
	func (c CellLayout) AddAttribute(cell CellRendererClass, attribute string, column int)  {
var _arg0 *C.GtkCellLayout // out
var _arg1 *C.GtkCellRenderer // out
var _arg2 *C.gchar // out
var _arg3 C.gint // out

_arg0 = (*C.GtkCellLayout)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(cell.Native()))
_arg2 = (*C.gchar)(C.CString(attribute))
defer C.free(unsafe.Pointer(_arg2))
_arg3 = (C.gint)(column)

C.gtk_cell_layout_add_attribute(_arg0, _arg1, _arg2, _arg3)
}
	
	// Clear unsets all the mappings on all renderers on @cell_layout and removes
// all renderers from @cell_layout.
	func (c CellLayout) Clear()  {
var _arg0 *C.GtkCellLayout // out

_arg0 = (*C.GtkCellLayout)(unsafe.Pointer(c.Native()))

C.gtk_cell_layout_clear(_arg0)
}
	
	// ClearAttributes clears all existing attributes previously set with
// gtk_cell_layout_set_attributes().
	func (c CellLayout) ClearAttributes(cell CellRendererClass)  {
var _arg0 *C.GtkCellLayout // out
var _arg1 *C.GtkCellRenderer // out

_arg0 = (*C.GtkCellLayout)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(cell.Native()))

C.gtk_cell_layout_clear_attributes(_arg0, _arg1)
}
	
	// Area returns the underlying CellArea which might be @cell_layout if called on
// a CellArea or might be nil if no CellArea is used by @cell_layout.
	func (c CellLayout) Area() CellArea {
var _arg0 *C.GtkCellLayout // out
var _cret *C.GtkCellArea // in

_arg0 = (*C.GtkCellLayout)(unsafe.Pointer(c.Native()))

_cret = C.gtk_cell_layout_get_area(_arg0)


var _cellArea CellArea // out

_cellArea = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(CellArea)

return _cellArea
}
	
	// PackEnd adds the @cell to the end of @cell_layout. If @expand is false, then
// the @cell is allocated no more space than it needs. Any unused space is
// divided evenly between cells for which @expand is true.
// 
// Note that reusing the same cell renderer is not supported.
	func (c CellLayout) PackEnd(cell CellRendererClass, expand bool)  {
var _arg0 *C.GtkCellLayout // out
var _arg1 *C.GtkCellRenderer // out
var _arg2 C.gboolean // out

_arg0 = (*C.GtkCellLayout)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(cell.Native()))
if expand { _arg2 = C.TRUE }

C.gtk_cell_layout_pack_end(_arg0, _arg1, _arg2)
}
	
	// PackStart packs the @cell into the beginning of @cell_layout. If @expand is
// false, then the @cell is allocated no more space than it needs. Any unused
// space is divided evenly between cells for which @expand is true.
// 
// Note that reusing the same cell renderer is not supported.
	func (c CellLayout) PackStart(cell CellRendererClass, expand bool)  {
var _arg0 *C.GtkCellLayout // out
var _arg1 *C.GtkCellRenderer // out
var _arg2 C.gboolean // out

_arg0 = (*C.GtkCellLayout)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(cell.Native()))
if expand { _arg2 = C.TRUE }

C.gtk_cell_layout_pack_start(_arg0, _arg1, _arg2)
}
	
	// Reorder re-inserts @cell at @position.
// 
// Note that @cell has already to be packed into @cell_layout for this to
// function properly.
	func (c CellLayout) Reorder(cell CellRendererClass, position int)  {
var _arg0 *C.GtkCellLayout // out
var _arg1 *C.GtkCellRenderer // out
var _arg2 C.gint // out

_arg0 = (*C.GtkCellLayout)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(cell.Native()))
_arg2 = (C.gint)(position)

C.gtk_cell_layout_reorder(_arg0, _arg1, _arg2)
}
	


	
	// ColorChooserInterface contains virtual methods for ColorChooser, or
	// methods that can be overridden.
	type ColorChooserInterface interface {
		gextras.Objector

			// AddPalette adds a palette to the color chooser. If @orientation is
	// horizontal, the colors are grouped in rows, with @colors_per_line colors
	// in each row. If @horizontal is false, the colors are grouped in columns
	// instead.
	// 
	// The default color palette of ColorChooserWidget has 27 colors, organized
	// in columns of 3 colors. The default gray palette has 9 grays in a single
	// row.
	// 
	// The layout of the color chooser widget works best when the palettes have
	// 9-10 columns.
	// 
	// Calling this function for the first time has the side effect of removing
	// the default color and gray palettes from the color chooser.
	// 
	// If @colors is nil, removes all previously added palettes.
		AddPalette(orientation Orientation, colorsPerLine int, colors []gdk.RGBA) 
		
		ColorActivated(color *gdk.RGBA) 
			// RGBA gets the currently-selected color.
		RGBA() gdk.RGBA
			// SetRGBA sets the color.
		SetRGBA(color *gdk.RGBA) 
		
	}
	

	// ColorChooser is an interface that is implemented by widgets for choosing
// colors. Depending on the situation, colors may be allowed to have alpha
// (translucency).
// 
// In GTK+, the main widgets that implement this interface are
// ColorChooserWidget, ColorChooserDialog and ColorButton.
	type ColorChooser struct {
		**externglib.Object
		
	}

	
	func marshalColorChooser(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return {ColorChooser{
Object: &externglib.Object{externglib.ToGObject(obj)},
} map[github.com/gotk3/gotk3/glib:externglib]}, nil
	}
	

	
	// AddPalette adds a palette to the color chooser. If @orientation is
// horizontal, the colors are grouped in rows, with @colors_per_line colors in
// each row. If @horizontal is false, the colors are grouped in columns instead.
// 
// The default color palette of ColorChooserWidget has 27 colors, organized in
// columns of 3 colors. The default gray palette has 9 grays in a single row.
// 
// The layout of the color chooser widget works best when the palettes have 9-10
// columns.
// 
// Calling this function for the first time has the side effect of removing the
// default color and gray palettes from the color chooser.
// 
// If @colors is nil, removes all previously added palettes.
	func (c ColorChooser) AddPalette(orientation Orientation, colorsPerLine int, colors []gdk.RGBA)  {
var _arg0 *C.GtkColorChooser // out
var _arg1 C.GtkOrientation // out
var _arg2 C.gint // out
var _arg4 *C.GdkRGBA
var _arg3 C.gint

_arg0 = (*C.GtkColorChooser)(unsafe.Pointer(c.Native()))
_arg1 = (C.GtkOrientation)(orientation)
_arg2 = (C.gint)(colorsPerLine)
_arg3 = C.gint(len(colors))
_arg4 = (*C.GdkRGBA)(unsafe.Pointer(&colors[0]))

C.gtk_color_chooser_add_palette(_arg0, _arg1, _arg2, _arg3, _arg4)
}
	
	// RGBA gets the currently-selected color.
	func (c ColorChooser) RGBA() gdk.RGBA {
var _arg0 *C.GtkColorChooser // out
var _color gdk.RGBA

_arg0 = (*C.GtkColorChooser)(unsafe.Pointer(c.Native()))

C.gtk_color_chooser_get_rgba(_arg0, (*C.GdkRGBA)(unsafe.Pointer(&_color)))





return _color
}
	
	// UseAlpha returns whether the color chooser shows the alpha channel.
	func (c ColorChooser) UseAlpha() bool {
var _arg0 *C.GtkColorChooser // out
var _cret C.gboolean // in

_arg0 = (*C.GtkColorChooser)(unsafe.Pointer(c.Native()))

_cret = C.gtk_color_chooser_get_use_alpha(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetRGBA sets the color.
	func (c ColorChooser) SetRGBA(color *gdk.RGBA)  {
var _arg0 *C.GtkColorChooser // out
var _arg1 *C.GdkRGBA // out

_arg0 = (*C.GtkColorChooser)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GdkRGBA)(unsafe.Pointer(color.Native()))

C.gtk_color_chooser_set_rgba(_arg0, _arg1)
}
	
	// SetUseAlpha sets whether or not the color chooser should use the alpha
// channel.
	func (c ColorChooser) SetUseAlpha(useAlpha bool)  {
var _arg0 *C.GtkColorChooser // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkColorChooser)(unsafe.Pointer(c.Native()))
if useAlpha { _arg1 = C.TRUE }

C.gtk_color_chooser_set_use_alpha(_arg0, _arg1)
}
	


	
	// EditableInterface contains virtual methods for Editable, or
	// methods that can be overridden.
	type EditableInterface interface {
		gextras.Objector

		
		Changed() 
			// DeleteText deletes a sequence of characters. The characters that are
	// deleted are those characters at positions from @start_pos up to, but not
	// including @end_pos. If @end_pos is negative, then the characters deleted
	// are those from @start_pos to the end of the text.
	// 
	// Note that the positions are specified in characters, not bytes.
		DeleteText(startPos int, endPos int) 
			// DoDeleteText deletes a sequence of characters. The characters that are
	// deleted are those characters at positions from @start_pos up to, but not
	// including @end_pos. If @end_pos is negative, then the characters deleted
	// are those from @start_pos to the end of the text.
	// 
	// Note that the positions are specified in characters, not bytes.
		DoDeleteText(startPos int, endPos int) 
			// Chars retrieves a sequence of characters. The characters that are
	// retrieved are those characters at positions from @start_pos up to, but
	// not including @end_pos. If @end_pos is negative, then the characters
	// retrieved are those characters from @start_pos to the end of the text.
	// 
	// Note that positions are specified in characters, not bytes.
		Chars(startPos int, endPos int) string
			// Position retrieves the current position of the cursor relative to the
	// start of the content of the editable.
	// 
	// Note that this position is in characters, not in bytes.
		Position() int
			// SelectionBounds retrieves the selection bound of the editable. start_pos
	// will be filled with the start of the selection and @end_pos with end. If
	// no text was selected both will be identical and false will be returned.
	// 
	// Note that positions are specified in characters, not bytes.
		SelectionBounds() (startPos int, endPos int, ok bool)
			// SetPosition sets the cursor position in the editable to the given value.
	// 
	// The cursor is displayed before the character with the given (base 0)
	// index in the contents of the editable. The value must be less than or
	// equal to the number of characters in the editable. A value of -1
	// indicates that the position should be set after the last character of the
	// editable. Note that @position is in characters, not in bytes.
		SetPosition(position int) 
			// SetSelectionBounds selects a region of text. The characters that are
	// selected are those characters at positions from @start_pos up to, but not
	// including @end_pos. If @end_pos is negative, then the characters selected
	// are those characters from @start_pos to the end of the text.
	// 
	// Note that positions are specified in characters, not bytes.
		SetSelectionBounds(startPos int, endPos int) 
		
	}
	

	// Editable: the Editable interface is an interface which should be implemented
// by text editing widgets, such as Entry and SpinButton. It contains functions
// for generically manipulating an editable widget, a large number of action
// signals used for key bindings, and several signals that an application can
// connect to to modify the behavior of a widget.
// 
// As an example of the latter usage, by connecting the following handler to
// Editable::insert-text, an application can convert all entry into a widget
// into uppercase.
// 
// Forcing entry to uppercase.
// 
//    #include <ctype.h>;
// 
//    void
//    insert_text_handler (GtkEditable *editable,
//                         const gchar *text,
//                         gint         length,
//                         gint        *position,
//                         gpointer     data)
//    {
//      gchar *result = g_utf8_strup (text, length);
// 
//      g_signal_handlers_block_by_func (editable,
//                                   (gpointer) insert_text_handler, data);
//      gtk_editable_insert_text (editable, result, length, position);
//      g_signal_handlers_unblock_by_func (editable,
//                                         (gpointer) insert_text_handler, data);
// 
//      g_signal_stop_emission_by_name (editable, "insert_text");
// 
//      g_free (result);
//    }
	type Editable struct {
		**externglib.Object
		
	}

	
	func marshalEditable(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return {Editable{
Object: &externglib.Object{externglib.ToGObject(obj)},
} map[github.com/gotk3/gotk3/glib:externglib]}, nil
	}
	

	
	// CopyClipboard copies the contents of the currently selected content in the
// editable and puts it on the clipboard.
	func (e Editable) CopyClipboard()  {
var _arg0 *C.GtkEditable // out

_arg0 = (*C.GtkEditable)(unsafe.Pointer(e.Native()))

C.gtk_editable_copy_clipboard(_arg0)
}
	
	// CutClipboard removes the contents of the currently selected content in the
// editable and puts it on the clipboard.
	func (e Editable) CutClipboard()  {
var _arg0 *C.GtkEditable // out

_arg0 = (*C.GtkEditable)(unsafe.Pointer(e.Native()))

C.gtk_editable_cut_clipboard(_arg0)
}
	
	// DeleteSelection deletes the currently selected text of the editable. This
// call doesn’t do anything if there is no selected text.
	func (e Editable) DeleteSelection()  {
var _arg0 *C.GtkEditable // out

_arg0 = (*C.GtkEditable)(unsafe.Pointer(e.Native()))

C.gtk_editable_delete_selection(_arg0)
}
	
	// DeleteText deletes a sequence of characters. The characters that are deleted
// are those characters at positions from @start_pos up to, but not including
// @end_pos. If @end_pos is negative, then the characters deleted are those from
// @start_pos to the end of the text.
// 
// Note that the positions are specified in characters, not bytes.
	func (e Editable) DeleteText(startPos int, endPos int)  {
var _arg0 *C.GtkEditable // out
var _arg1 C.gint // out
var _arg2 C.gint // out

_arg0 = (*C.GtkEditable)(unsafe.Pointer(e.Native()))
_arg1 = (C.gint)(startPos)
_arg2 = (C.gint)(endPos)

C.gtk_editable_delete_text(_arg0, _arg1, _arg2)
}
	
	// Chars retrieves a sequence of characters. The characters that are retrieved
// are those characters at positions from @start_pos up to, but not including
// @end_pos. If @end_pos is negative, then the characters retrieved are those
// characters from @start_pos to the end of the text.
// 
// Note that positions are specified in characters, not bytes.
	func (e Editable) Chars(startPos int, endPos int) string {
var _arg0 *C.GtkEditable // out
var _arg1 C.gint // out
var _arg2 C.gint // out
var _cret *C.gchar // in

_arg0 = (*C.GtkEditable)(unsafe.Pointer(e.Native()))
_arg1 = (C.gint)(startPos)
_arg2 = (C.gint)(endPos)

_cret = C.gtk_editable_get_chars(_arg0, _arg1, _arg2)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// Editable retrieves whether @editable is editable. See
// gtk_editable_set_editable().
	func (e Editable) Editable() bool {
var _arg0 *C.GtkEditable // out
var _cret C.gboolean // in

_arg0 = (*C.GtkEditable)(unsafe.Pointer(e.Native()))

_cret = C.gtk_editable_get_editable(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Position retrieves the current position of the cursor relative to the start
// of the content of the editable.
// 
// Note that this position is in characters, not in bytes.
	func (e Editable) Position() int {
var _arg0 *C.GtkEditable // out
var _cret C.gint // in

_arg0 = (*C.GtkEditable)(unsafe.Pointer(e.Native()))

_cret = C.gtk_editable_get_position(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// SelectionBounds retrieves the selection bound of the editable. start_pos will
// be filled with the start of the selection and @end_pos with end. If no text
// was selected both will be identical and false will be returned.
// 
// Note that positions are specified in characters, not bytes.
	func (e Editable) SelectionBounds() (startPos int, endPos int, ok bool) {
var _arg0 *C.GtkEditable // out
var _arg1 C.gint // in
var _arg2 C.gint // in
var _cret C.gboolean // in

_arg0 = (*C.GtkEditable)(unsafe.Pointer(e.Native()))

_cret = C.gtk_editable_get_selection_bounds(_arg0, &_arg1, &_arg2)


var _startPos int // out
var _endPos int // out
var _ok bool // out

_startPos = (int)(_arg1)
_endPos = (int)(_arg2)
if _cret != 0 { _ok = true }

return _startPos, _endPos, _ok
}
	
	// PasteClipboard pastes the content of the clipboard to the current position of
// the cursor in the editable.
	func (e Editable) PasteClipboard()  {
var _arg0 *C.GtkEditable // out

_arg0 = (*C.GtkEditable)(unsafe.Pointer(e.Native()))

C.gtk_editable_paste_clipboard(_arg0)
}
	
	// SelectRegion selects a region of text. The characters that are selected are
// those characters at positions from @start_pos up to, but not including
// @end_pos. If @end_pos is negative, then the characters selected are those
// characters from @start_pos to the end of the text.
// 
// Note that positions are specified in characters, not bytes.
	func (e Editable) SelectRegion(startPos int, endPos int)  {
var _arg0 *C.GtkEditable // out
var _arg1 C.gint // out
var _arg2 C.gint // out

_arg0 = (*C.GtkEditable)(unsafe.Pointer(e.Native()))
_arg1 = (C.gint)(startPos)
_arg2 = (C.gint)(endPos)

C.gtk_editable_select_region(_arg0, _arg1, _arg2)
}
	
	// SetEditable determines if the user can edit the text in the editable widget
// or not.
	func (e Editable) SetEditable(isEditable bool)  {
var _arg0 *C.GtkEditable // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkEditable)(unsafe.Pointer(e.Native()))
if isEditable { _arg1 = C.TRUE }

C.gtk_editable_set_editable(_arg0, _arg1)
}
	
	// SetPosition sets the cursor position in the editable to the given value.
// 
// The cursor is displayed before the character with the given (base 0) index in
// the contents of the editable. The value must be less than or equal to the
// number of characters in the editable. A value of -1 indicates that the
// position should be set after the last character of the editable. Note that
// @position is in characters, not in bytes.
	func (e Editable) SetPosition(position int)  {
var _arg0 *C.GtkEditable // out
var _arg1 C.gint // out

_arg0 = (*C.GtkEditable)(unsafe.Pointer(e.Native()))
_arg1 = (C.gint)(position)

C.gtk_editable_set_position(_arg0, _arg1)
}
	


	

	// FileChooser is an interface that can be implemented by file selection
// widgets. In GTK+, the main objects that implement this interface are
// FileChooserWidget, FileChooserDialog, and FileChooserButton. You do not need
// to write an object that implements the FileChooser interface unless you are
// trying to adapt an existing file selector to expose a standard programming
// interface.
// 
// FileChooser allows for shortcuts to various places in the filesystem. In the
// default implementation these are displayed in the left pane. It may be a bit
// confusing at first that these shortcuts come from various sources and in
// various flavours, so lets explain the terminology here:
// 
// - Bookmarks: are created by the user, by dragging folders from the right pane
// to the left pane, or by using the “Add”. Bookmarks can be renamed and deleted
// by the user.
// 
// - Shortcuts: can be provided by the application. For example, a Paint program
// may want to add a shortcut for a Clipart folder. Shortcuts cannot be modified
// by the user.
// 
// - Volumes: are provided by the underlying filesystem abstraction. They are
// the “roots” of the filesystem.
// 
// 
// File Names and Encodings
// 
// When the user is finished selecting files in a FileChooser, your program can
// get the selected names either as filenames or as URIs. For URIs, the normal
// escaping rules are applied if the URI contains non-ASCII characters. However,
// filenames are always returned in the character set specified by the
// `G_FILENAME_ENCODING` environment variable. Please see the GLib documentation
// for more details about this variable.
// 
// This means that while you can pass the result of
// gtk_file_chooser_get_filename() to g_open() or g_fopen(), you may not be able
// to directly set it as the text of a Label widget unless you convert it first
// to UTF-8, which all GTK+ widgets expect. You should use g_filename_to_utf8()
// to convert filenames into strings that can be passed to GTK+ widgets.
// 
// 
// Adding a Preview Widget
// 
// You can add a custom preview widget to a file chooser and then get
// notification about when the preview needs to be updated. To install a preview
// widget, use gtk_file_chooser_set_preview_widget(). Then, connect to the
// FileChooser::update-preview signal to get notified when you need to update
// the contents of the preview.
// 
// Your callback should use gtk_file_chooser_get_preview_filename() to see what
// needs previewing. Once you have generated the preview for the corresponding
// file, you must call gtk_file_chooser_set_preview_widget_active() with a
// boolean flag that indicates whether your callback could successfully generate
// a preview.
// 
// Example: Using a Preview Widget
// 
// 
//      GtkWidget *toggle;
// 
//      ...
// 
//      toggle = gtk_check_button_new_with_label ("Open file read-only");
//      gtk_widget_show (toggle);
//      gtk_file_chooser_set_extra_widget (my_file_chooser, toggle);
//    }
// 
// If you want to set more than one extra widget in the file chooser, you can a
// container such as a Box or a Grid and include your widgets in it. Then, set
// the container as the whole extra widget.
	type FileChooser struct {
		**externglib.Object
		
	}

	
	func marshalFileChooser(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return {FileChooser{
Object: &externglib.Object{externglib.ToGObject(obj)},
} map[github.com/gotk3/gotk3/glib:externglib]}, nil
	}
	

	
	// AddChoice adds a 'choice' to the file chooser. This is typically implemented
// as a combobox or, for boolean choices, as a checkbutton. You can select a
// value using gtk_file_chooser_set_choice() before the dialog is shown, and you
// can obtain the user-selected value in the ::response signal handler using
// gtk_file_chooser_get_choice().
// 
// Compare gtk_file_chooser_set_extra_widget().
	func (c FileChooser) AddChoice(id string, label string, options []string, optionLabels []string)  {
var _arg0 *C.GtkFileChooser // out
var _arg1 *C.char // out
var _arg2 *C.char // out
var _arg3 **C.char
var _arg4 **C.char

_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
_arg1 = (*C.char)(C.CString(id))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.char)(C.CString(label))
defer C.free(unsafe.Pointer(_arg2))
_arg3 = (**C.char)(C.malloc(C.ulong(len(options)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
defer C.free(unsafe.Pointer(_arg3))
{
out := unsafe.Slice(_arg3, len(options))
for i := range options {
out[i] = (*C.char)(C.CString(options[i]))
defer C.free(unsafe.Pointer(out[i]))
}
}
_arg4 = (**C.char)(C.malloc(C.ulong(len(optionLabels)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
defer C.free(unsafe.Pointer(_arg4))
{
out := unsafe.Slice(_arg4, len(optionLabels))
for i := range optionLabels {
out[i] = (*C.char)(C.CString(optionLabels[i]))
defer C.free(unsafe.Pointer(out[i]))
}
}

C.gtk_file_chooser_add_choice(_arg0, _arg1, _arg2, _arg3, _arg4)
}
	
	// AddFilter adds @filter to the list of filters that the user can select
// between. When a filter is selected, only files that are passed by that filter
// are displayed.
// 
// Note that the @chooser takes ownership of the filter, so you have to ref and
// sink it if you want to keep a reference.
	func (c FileChooser) AddFilter(filter FileFilterClass)  {
var _arg0 *C.GtkFileChooser // out
var _arg1 *C.GtkFileFilter // out

_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GtkFileFilter)(unsafe.Pointer(filter.Native()))

C.gtk_file_chooser_add_filter(_arg0, _arg1)
}
	
	// AddShortcutFolder adds a folder to be displayed with the shortcut folders in
// a file chooser. Note that shortcut folders do not get saved, as they are
// provided by the application. For example, you can use this to add a
// “/usr/share/mydrawprogram/Clipart” folder to the volume list.
	func (c FileChooser) AddShortcutFolder(folder string) error {
var _arg0 *C.GtkFileChooser // out
var _arg1 *C.char // out
var _cerr *C.GError // in

_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
_arg1 = (*C.char)(C.CString(folder))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_file_chooser_add_shortcut_folder(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// AddShortcutFolderURI adds a folder URI to be displayed with the shortcut
// folders in a file chooser. Note that shortcut folders do not get saved, as
// they are provided by the application. For example, you can use this to add a
// “file:///usr/share/mydrawprogram/Clipart” folder to the volume list.
	func (c FileChooser) AddShortcutFolderURI(uri string) error {
var _arg0 *C.GtkFileChooser // out
var _arg1 *C.char // out
var _cerr *C.GError // in

_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
_arg1 = (*C.char)(C.CString(uri))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_file_chooser_add_shortcut_folder_uri(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// Action gets the type of operation that the file chooser is performing; see
// gtk_file_chooser_set_action().
	func (c FileChooser) Action() FileChooserAction {
var _arg0 *C.GtkFileChooser // out
var _cret C.GtkFileChooserAction // in

_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

_cret = C.gtk_file_chooser_get_action(_arg0)


var _fileChooserAction FileChooserAction // out

_fileChooserAction = FileChooserAction(_cret)

return _fileChooserAction
}
	
	// Choice gets the currently selected option in the 'choice' with the given ID.
	func (c FileChooser) Choice(id string) string {
var _arg0 *C.GtkFileChooser // out
var _arg1 *C.char // out
var _cret *C.char // in

_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
_arg1 = (*C.char)(C.CString(id))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_file_chooser_get_choice(_arg0, _arg1)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// CreateFolders gets whether file choser will offer to create new folders. See
// gtk_file_chooser_set_create_folders().
	func (c FileChooser) CreateFolders() bool {
var _arg0 *C.GtkFileChooser // out
var _cret C.gboolean // in

_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

_cret = C.gtk_file_chooser_get_create_folders(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// CurrentFolder gets the current folder of @chooser as a local filename. See
// gtk_file_chooser_set_current_folder().
// 
// Note that this is the folder that the file chooser is currently displaying
// (e.g. "/home/username/Documents"), which is not the same as the
// currently-selected folder if the chooser is in
// GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER mode (e.g.
// "/home/username/Documents/selected-folder/". To get the currently-selected
// folder in that mode, use gtk_file_chooser_get_uri() as the usual way to get
// the selection.
	func (c FileChooser) CurrentFolder() string {
var _arg0 *C.GtkFileChooser // out
var _cret *C.gchar // in

_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

_cret = C.gtk_file_chooser_get_current_folder(_arg0)


var _filename string // out

_filename = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _filename
}
	
	// CurrentFolderFile gets the current folder of @chooser as #GFile. See
// gtk_file_chooser_get_current_folder_uri().
	func (c FileChooser) CurrentFolderFile() gio.File {
var _arg0 *C.GtkFileChooser // out
var _cret *C.GFile // in

_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

_cret = C.gtk_file_chooser_get_current_folder_file(_arg0)


var _file gio.File // out

_file = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gio.File)

return _file
}
	
	// CurrentFolderURI gets the current folder of @chooser as an URI. See
// gtk_file_chooser_set_current_folder_uri().
// 
// Note that this is the folder that the file chooser is currently displaying
// (e.g. "file:///home/username/Documents"), which is not the same as the
// currently-selected folder if the chooser is in
// GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER mode (e.g.
// "file:///home/username/Documents/selected-folder/". To get the
// currently-selected folder in that mode, use gtk_file_chooser_get_uri() as the
// usual way to get the selection.
	func (c FileChooser) CurrentFolderURI() string {
var _arg0 *C.GtkFileChooser // out
var _cret *C.gchar // in

_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

_cret = C.gtk_file_chooser_get_current_folder_uri(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// CurrentName gets the current name in the file selector, as entered by the
// user in the text entry for “Name”.
// 
// This is meant to be used in save dialogs, to get the currently typed filename
// when the file itself does not exist yet. For example, an application that
// adds a custom extra widget to the file chooser for “file format” may want to
// change the extension of the typed filename based on the chosen format, say,
// from “.jpg” to “.png”.
	func (c FileChooser) CurrentName() string {
var _arg0 *C.GtkFileChooser // out
var _cret *C.gchar // in

_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

_cret = C.gtk_file_chooser_get_current_name(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// DoOverwriteConfirmation queries whether a file chooser is set to confirm for
// overwriting when the user types a file name that already exists.
	func (c FileChooser) DoOverwriteConfirmation() bool {
var _arg0 *C.GtkFileChooser // out
var _cret C.gboolean // in

_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

_cret = C.gtk_file_chooser_get_do_overwrite_confirmation(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ExtraWidget gets the current extra widget; see
// gtk_file_chooser_set_extra_widget().
	func (c FileChooser) ExtraWidget() Widget {
var _arg0 *C.GtkFileChooser // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

_cret = C.gtk_file_chooser_get_extra_widget(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// File gets the #GFile for the currently selected file in the file selector. If
// multiple files are selected, one of the files will be returned at random.
// 
// If the file chooser is in folder mode, this function returns the selected
// folder.
	func (c FileChooser) File() gio.File {
var _arg0 *C.GtkFileChooser // out
var _cret *C.GFile // in

_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

_cret = C.gtk_file_chooser_get_file(_arg0)


var _file gio.File // out

_file = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gio.File)

return _file
}
	
	// Filename gets the filename for the currently selected file in the file
// selector. The filename is returned as an absolute path. If multiple files are
// selected, one of the filenames will be returned at random.
// 
// If the file chooser is in folder mode, this function returns the selected
// folder.
	func (c FileChooser) Filename() string {
var _arg0 *C.GtkFileChooser // out
var _cret *C.gchar // in

_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

_cret = C.gtk_file_chooser_get_filename(_arg0)


var _filename string // out

_filename = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _filename
}
	
	// Filter gets the current filter; see gtk_file_chooser_set_filter().
	func (c FileChooser) Filter() FileFilter {
var _arg0 *C.GtkFileChooser // out
var _cret *C.GtkFileFilter // in

_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

_cret = C.gtk_file_chooser_get_filter(_arg0)


var _fileFilter FileFilter // out

_fileFilter = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(FileFilter)

return _fileFilter
}
	
	// LocalOnly gets whether only local files can be selected in the file selector.
// See gtk_file_chooser_set_local_only()
	func (c FileChooser) LocalOnly() bool {
var _arg0 *C.GtkFileChooser // out
var _cret C.gboolean // in

_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

_cret = C.gtk_file_chooser_get_local_only(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// PreviewFile gets the #GFile that should be previewed in a custom preview
// Internal function, see gtk_file_chooser_get_preview_uri().
	func (c FileChooser) PreviewFile() gio.File {
var _arg0 *C.GtkFileChooser // out
var _cret *C.GFile // in

_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

_cret = C.gtk_file_chooser_get_preview_file(_arg0)


var _file gio.File // out

_file = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gio.File)

return _file
}
	
	// PreviewFilename gets the filename that should be previewed in a custom
// preview widget. See gtk_file_chooser_set_preview_widget().
	func (c FileChooser) PreviewFilename() string {
var _arg0 *C.GtkFileChooser // out
var _cret *C.char // in

_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

_cret = C.gtk_file_chooser_get_preview_filename(_arg0)


var _filename string // out

_filename = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _filename
}
	
	// PreviewURI gets the URI that should be previewed in a custom preview widget.
// See gtk_file_chooser_set_preview_widget().
	func (c FileChooser) PreviewURI() string {
var _arg0 *C.GtkFileChooser // out
var _cret *C.char // in

_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

_cret = C.gtk_file_chooser_get_preview_uri(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// PreviewWidget gets the current preview widget; see
// gtk_file_chooser_set_preview_widget().
	func (c FileChooser) PreviewWidget() Widget {
var _arg0 *C.GtkFileChooser // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

_cret = C.gtk_file_chooser_get_preview_widget(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// PreviewWidgetActive gets whether the preview widget set by
// gtk_file_chooser_set_preview_widget() should be shown for the current
// filename. See gtk_file_chooser_set_preview_widget_active().
	func (c FileChooser) PreviewWidgetActive() bool {
var _arg0 *C.GtkFileChooser // out
var _cret C.gboolean // in

_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

_cret = C.gtk_file_chooser_get_preview_widget_active(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SelectMultiple gets whether multiple files can be selected in the file
// selector. See gtk_file_chooser_set_select_multiple().
	func (c FileChooser) SelectMultiple() bool {
var _arg0 *C.GtkFileChooser // out
var _cret C.gboolean // in

_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

_cret = C.gtk_file_chooser_get_select_multiple(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ShowHidden gets whether hidden files and folders are displayed in the file
// selector. See gtk_file_chooser_set_show_hidden().
	func (c FileChooser) ShowHidden() bool {
var _arg0 *C.GtkFileChooser // out
var _cret C.gboolean // in

_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

_cret = C.gtk_file_chooser_get_show_hidden(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// URI gets the URI for the currently selected file in the file selector. If
// multiple files are selected, one of the filenames will be returned at random.
// 
// If the file chooser is in folder mode, this function returns the selected
// folder.
	func (c FileChooser) URI() string {
var _arg0 *C.GtkFileChooser // out
var _cret *C.gchar // in

_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

_cret = C.gtk_file_chooser_get_uri(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// UsePreviewLabel gets whether a stock label should be drawn with the name of
// the previewed file. See gtk_file_chooser_set_use_preview_label().
	func (c FileChooser) UsePreviewLabel() bool {
var _arg0 *C.GtkFileChooser // out
var _cret C.gboolean // in

_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

_cret = C.gtk_file_chooser_get_use_preview_label(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// RemoveChoice removes a 'choice' that has been added with
// gtk_file_chooser_add_choice().
	func (c FileChooser) RemoveChoice(id string)  {
var _arg0 *C.GtkFileChooser // out
var _arg1 *C.char // out

_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
_arg1 = (*C.char)(C.CString(id))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_file_chooser_remove_choice(_arg0, _arg1)
}
	
	// RemoveFilter removes @filter from the list of filters that the user can
// select between.
	func (c FileChooser) RemoveFilter(filter FileFilterClass)  {
var _arg0 *C.GtkFileChooser // out
var _arg1 *C.GtkFileFilter // out

_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GtkFileFilter)(unsafe.Pointer(filter.Native()))

C.gtk_file_chooser_remove_filter(_arg0, _arg1)
}
	
	// RemoveShortcutFolder removes a folder from a file chooser’s list of shortcut
// folders.
	func (c FileChooser) RemoveShortcutFolder(folder string) error {
var _arg0 *C.GtkFileChooser // out
var _arg1 *C.char // out
var _cerr *C.GError // in

_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
_arg1 = (*C.char)(C.CString(folder))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_file_chooser_remove_shortcut_folder(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// RemoveShortcutFolderURI removes a folder URI from a file chooser’s list of
// shortcut folders.
	func (c FileChooser) RemoveShortcutFolderURI(uri string) error {
var _arg0 *C.GtkFileChooser // out
var _arg1 *C.char // out
var _cerr *C.GError // in

_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
_arg1 = (*C.char)(C.CString(uri))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_file_chooser_remove_shortcut_folder_uri(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// SelectAll selects all the files in the current folder of a file chooser.
	func (c FileChooser) SelectAll()  {
var _arg0 *C.GtkFileChooser // out

_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

C.gtk_file_chooser_select_all(_arg0)
}
	
	// SelectFile selects the file referred to by @file. An internal function. See
// _gtk_file_chooser_select_uri().
	func (c FileChooser) SelectFile(file gio.File) error {
var _arg0 *C.GtkFileChooser // out
var _arg1 *C.GFile // out
var _cerr *C.GError // in

_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GFile)(unsafe.Pointer(file.Native()))

C.gtk_file_chooser_select_file(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// SelectFilename selects a filename. If the file name isn’t in the current
// folder of @chooser, then the current folder of @chooser will be changed to
// the folder containing @filename.
	func (c FileChooser) SelectFilename(filename string) bool {
var _arg0 *C.GtkFileChooser // out
var _arg1 *C.char // out
var _cret C.gboolean // in

_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
_arg1 = (*C.char)(C.CString(filename))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_file_chooser_select_filename(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SelectURI selects the file to by @uri. If the URI doesn’t refer to a file in
// the current folder of @chooser, then the current folder of @chooser will be
// changed to the folder containing @filename.
	func (c FileChooser) SelectURI(uri string) bool {
var _arg0 *C.GtkFileChooser // out
var _arg1 *C.char // out
var _cret C.gboolean // in

_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
_arg1 = (*C.char)(C.CString(uri))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_file_chooser_select_uri(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetAction sets the type of operation that the chooser is performing; the user
// interface is adapted to suit the selected action. For example, an option to
// create a new folder might be shown if the action is
// GTK_FILE_CHOOSER_ACTION_SAVE but not if the action is
// GTK_FILE_CHOOSER_ACTION_OPEN.
	func (c FileChooser) SetAction(action FileChooserAction)  {
var _arg0 *C.GtkFileChooser // out
var _arg1 C.GtkFileChooserAction // out

_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
_arg1 = (C.GtkFileChooserAction)(action)

C.gtk_file_chooser_set_action(_arg0, _arg1)
}
	
	// SetChoice selects an option in a 'choice' that has been added with
// gtk_file_chooser_add_choice(). For a boolean choice, the possible options are
// "true" and "false".
	func (c FileChooser) SetChoice(id string, option string)  {
var _arg0 *C.GtkFileChooser // out
var _arg1 *C.char // out
var _arg2 *C.char // out

_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
_arg1 = (*C.char)(C.CString(id))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.char)(C.CString(option))
defer C.free(unsafe.Pointer(_arg2))

C.gtk_file_chooser_set_choice(_arg0, _arg1, _arg2)
}
	
	// SetCreateFolders sets whether file choser will offer to create new folders.
// This is only relevant if the action is not set to be
// GTK_FILE_CHOOSER_ACTION_OPEN.
	func (c FileChooser) SetCreateFolders(createFolders bool)  {
var _arg0 *C.GtkFileChooser // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
if createFolders { _arg1 = C.TRUE }

C.gtk_file_chooser_set_create_folders(_arg0, _arg1)
}
	
	// SetCurrentFolder sets the current folder for @chooser from a local filename.
// The user will be shown the full contents of the current folder, plus user
// interface elements for navigating to other folders.
// 
// In general, you should not use this function. See the [section on setting up
// a file chooser dialog][gtkfilechooserdialog-setting-up] for the rationale
// behind this.
	func (c FileChooser) SetCurrentFolder(filename string) bool {
var _arg0 *C.GtkFileChooser // out
var _arg1 *C.gchar // out
var _cret C.gboolean // in

_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
_arg1 = (*C.gchar)(C.CString(filename))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_file_chooser_set_current_folder(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetCurrentFolderFile sets the current folder for @chooser from a #GFile.
// Internal function, see gtk_file_chooser_set_current_folder_uri().
	func (c FileChooser) SetCurrentFolderFile(file gio.File) error {
var _arg0 *C.GtkFileChooser // out
var _arg1 *C.GFile // out
var _cerr *C.GError // in

_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GFile)(unsafe.Pointer(file.Native()))

C.gtk_file_chooser_set_current_folder_file(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// SetCurrentFolderURI sets the current folder for @chooser from an URI. The
// user will be shown the full contents of the current folder, plus user
// interface elements for navigating to other folders.
// 
// In general, you should not use this function. See the [section on setting up
// a file chooser dialog][gtkfilechooserdialog-setting-up] for the rationale
// behind this.
	func (c FileChooser) SetCurrentFolderURI(uri string) bool {
var _arg0 *C.GtkFileChooser // out
var _arg1 *C.gchar // out
var _cret C.gboolean // in

_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
_arg1 = (*C.gchar)(C.CString(uri))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_file_chooser_set_current_folder_uri(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetCurrentName sets the current name in the file selector, as if entered by
// the user. Note that the name passed in here is a UTF-8 string rather than a
// filename. This function is meant for such uses as a suggested name in a “Save
// As...” dialog. You can pass “Untitled.doc” or a similarly suitable suggestion
// for the @name.
// 
// If you want to preselect a particular existing file, you should use
// gtk_file_chooser_set_filename() or gtk_file_chooser_set_uri() instead. Please
// see the documentation for those functions for an example of using
// gtk_file_chooser_set_current_name() as well.
	func (c FileChooser) SetCurrentName(name string)  {
var _arg0 *C.GtkFileChooser // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
_arg1 = (*C.gchar)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_file_chooser_set_current_name(_arg0, _arg1)
}
	
	// SetDoOverwriteConfirmation sets whether a file chooser in
// GTK_FILE_CHOOSER_ACTION_SAVE mode will present a confirmation dialog if the
// user types a file name that already exists. This is false by default.
// 
// If set to true, the @chooser will emit the FileChooser::confirm-overwrite
// signal when appropriate.
// 
// If all you need is the stock confirmation dialog, set this property to true.
// You can override the way confirmation is done by actually handling the
// FileChooser::confirm-overwrite signal; please refer to its documentation for
// the details.
	func (c FileChooser) SetDoOverwriteConfirmation(doOverwriteConfirmation bool)  {
var _arg0 *C.GtkFileChooser // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
if doOverwriteConfirmation { _arg1 = C.TRUE }

C.gtk_file_chooser_set_do_overwrite_confirmation(_arg0, _arg1)
}
	
	// SetExtraWidget sets an application-supplied widget to provide extra options
// to the user.
	func (c FileChooser) SetExtraWidget(extraWidget WidgetClass)  {
var _arg0 *C.GtkFileChooser // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(extraWidget.Native()))

C.gtk_file_chooser_set_extra_widget(_arg0, _arg1)
}
	
	// SetFile sets @file as the current filename for the file chooser, by changing
// to the file’s parent folder and actually selecting the file in list. If the
// @chooser is in GTK_FILE_CHOOSER_ACTION_SAVE mode, the file’s base name will
// also appear in the dialog’s file name entry.
// 
// If the file name isn’t in the current folder of @chooser, then the current
// folder of @chooser will be changed to the folder containing @filename. This
// is equivalent to a sequence of gtk_file_chooser_unselect_all() followed by
// gtk_file_chooser_select_filename().
// 
// Note that the file must exist, or nothing will be done except for the
// directory change.
// 
// If you are implementing a save dialog, you should use this function if you
// already have a file name to which the user may save; for example, when the
// user opens an existing file and then does Save As... If you don’t have a file
// name already — for example, if the user just created a new file and is saving
// it for the first time, do not call this function. Instead, use something
// similar to this:
// 
//    if (document_is_new)
//      {
//        // the user just created a new document
//        gtk_file_chooser_set_current_folder_file (chooser, default_file_for_saving);
//        gtk_file_chooser_set_current_name (chooser, "Untitled document");
//      }
//    else
//      {
//        // the user edited an existing document
//        gtk_file_chooser_set_file (chooser, existing_file);
//      }
	func (c FileChooser) SetFile(file gio.File) error {
var _arg0 *C.GtkFileChooser // out
var _arg1 *C.GFile // out
var _cerr *C.GError // in

_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GFile)(unsafe.Pointer(file.Native()))

C.gtk_file_chooser_set_file(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// SetFilename sets @filename as the current filename for the file chooser, by
// changing to the file’s parent folder and actually selecting the file in list;
// all other files will be unselected. If the @chooser is in
// GTK_FILE_CHOOSER_ACTION_SAVE mode, the file’s base name will also appear in
// the dialog’s file name entry.
// 
// Note that the file must exist, or nothing will be done except for the
// directory change.
// 
// You should use this function only when implementing a save dialog for which
// you already have a file name to which the user may save. For example, when
// the user opens an existing file and then does Save As... to save a copy or a
// modified version. If you don’t have a file name already — for example, if the
// user just created a new file and is saving it for the first time, do not call
// this function. Instead, use something similar to this:
// 
//    if (document_is_new)
//      {
//        // the user just created a new document
//        gtk_file_chooser_set_current_name (chooser, "Untitled document");
//      }
//    else
//      {
//        // the user edited an existing document
//        gtk_file_chooser_set_filename (chooser, existing_filename);
//      }
// 
// In the first case, the file chooser will present the user with useful
// suggestions as to where to save his new file. In the second case, the file’s
// existing location is already known, so the file chooser will use it.
	func (c FileChooser) SetFilename(filename string) bool {
var _arg0 *C.GtkFileChooser // out
var _arg1 *C.char // out
var _cret C.gboolean // in

_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
_arg1 = (*C.char)(C.CString(filename))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_file_chooser_set_filename(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetFilter sets the current filter; only the files that pass the filter will
// be displayed. If the user-selectable list of filters is non-empty, then the
// filter should be one of the filters in that list. Setting the current filter
// when the list of filters is empty is useful if you want to restrict the
// displayed set of files without letting the user change it.
	func (c FileChooser) SetFilter(filter FileFilterClass)  {
var _arg0 *C.GtkFileChooser // out
var _arg1 *C.GtkFileFilter // out

_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GtkFileFilter)(unsafe.Pointer(filter.Native()))

C.gtk_file_chooser_set_filter(_arg0, _arg1)
}
	
	// SetLocalOnly sets whether only local files can be selected in the file
// selector. If @local_only is true (the default), then the selected file or
// files are guaranteed to be accessible through the operating systems native
// file system and therefore the application only needs to worry about the
// filename functions in FileChooser, like gtk_file_chooser_get_filename(),
// rather than the URI functions like gtk_file_chooser_get_uri(),
// 
// On some systems non-native files may still be available using the native
// filesystem via a userspace filesystem (FUSE).
	func (c FileChooser) SetLocalOnly(localOnly bool)  {
var _arg0 *C.GtkFileChooser // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
if localOnly { _arg1 = C.TRUE }

C.gtk_file_chooser_set_local_only(_arg0, _arg1)
}
	
	// SetPreviewWidget sets an application-supplied widget to use to display a
// custom preview of the currently selected file. To implement a preview, after
// setting the preview widget, you connect to the FileChooser::update-preview
// signal, and call gtk_file_chooser_get_preview_filename() or
// gtk_file_chooser_get_preview_uri() on each change. If you can display a
// preview of the new file, update your widget and set the preview active using
// gtk_file_chooser_set_preview_widget_active(). Otherwise, set the preview
// inactive.
// 
// When there is no application-supplied preview widget, or the
// application-supplied preview widget is not active, the file chooser will
// display no preview at all.
	func (c FileChooser) SetPreviewWidget(previewWidget WidgetClass)  {
var _arg0 *C.GtkFileChooser // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(previewWidget.Native()))

C.gtk_file_chooser_set_preview_widget(_arg0, _arg1)
}
	
	// SetPreviewWidgetActive sets whether the preview widget set by
// gtk_file_chooser_set_preview_widget() should be shown for the current
// filename. When @active is set to false, the file chooser may display an
// internally generated preview of the current file or it may display no preview
// at all. See gtk_file_chooser_set_preview_widget() for more details.
	func (c FileChooser) SetPreviewWidgetActive(active bool)  {
var _arg0 *C.GtkFileChooser // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
if active { _arg1 = C.TRUE }

C.gtk_file_chooser_set_preview_widget_active(_arg0, _arg1)
}
	
	// SetSelectMultiple sets whether multiple files can be selected in the file
// selector. This is only relevant if the action is set to be
// GTK_FILE_CHOOSER_ACTION_OPEN or GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER.
	func (c FileChooser) SetSelectMultiple(selectMultiple bool)  {
var _arg0 *C.GtkFileChooser // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
if selectMultiple { _arg1 = C.TRUE }

C.gtk_file_chooser_set_select_multiple(_arg0, _arg1)
}
	
	// SetShowHidden sets whether hidden files and folders are displayed in the file
// selector.
	func (c FileChooser) SetShowHidden(showHidden bool)  {
var _arg0 *C.GtkFileChooser // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
if showHidden { _arg1 = C.TRUE }

C.gtk_file_chooser_set_show_hidden(_arg0, _arg1)
}
	
	// SetURI sets the file referred to by @uri as the current file for the file
// chooser, by changing to the URI’s parent folder and actually selecting the
// URI in the list. If the @chooser is GTK_FILE_CHOOSER_ACTION_SAVE mode, the
// URI’s base name will also appear in the dialog’s file name entry.
// 
// Note that the URI must exist, or nothing will be done except for the
// directory change.
// 
// You should use this function only when implementing a save dialog for which
// you already have a file name to which the user may save. For example, when
// the user opens an existing file and then does Save As... to save a copy or a
// modified version. If you don’t have a file name already — for example, if the
// user just created a new file and is saving it for the first time, do not call
// this function. Instead, use something similar to this:
// 
//    if (document_is_new)
//      {
//        // the user just created a new document
//        gtk_file_chooser_set_current_name (chooser, "Untitled document");
//      }
//    else
//      {
//        // the user edited an existing document
//        gtk_file_chooser_set_uri (chooser, existing_uri);
//      }
// 
// In the first case, the file chooser will present the user with useful
// suggestions as to where to save his new file. In the second case, the file’s
// existing location is already known, so the file chooser will use it.
	func (c FileChooser) SetURI(uri string) bool {
var _arg0 *C.GtkFileChooser // out
var _arg1 *C.char // out
var _cret C.gboolean // in

_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
_arg1 = (*C.char)(C.CString(uri))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_file_chooser_set_uri(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetUsePreviewLabel sets whether the file chooser should display a stock label
// with the name of the file that is being previewed; the default is true.
// Applications that want to draw the whole preview area themselves should set
// this to false and display the name themselves in their preview widget.
// 
// See also: gtk_file_chooser_set_preview_widget()
	func (c FileChooser) SetUsePreviewLabel(useLabel bool)  {
var _arg0 *C.GtkFileChooser // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
if useLabel { _arg1 = C.TRUE }

C.gtk_file_chooser_set_use_preview_label(_arg0, _arg1)
}
	
	// UnselectAll unselects all the files in the current folder of a file chooser.
	func (c FileChooser) UnselectAll()  {
var _arg0 *C.GtkFileChooser // out

_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

C.gtk_file_chooser_unselect_all(_arg0)
}
	
	// UnselectFile unselects the file referred to by @file. If the file is not in
// the current directory, does not exist, or is otherwise not currently
// selected, does nothing.
	func (c FileChooser) UnselectFile(file gio.File)  {
var _arg0 *C.GtkFileChooser // out
var _arg1 *C.GFile // out

_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GFile)(unsafe.Pointer(file.Native()))

C.gtk_file_chooser_unselect_file(_arg0, _arg1)
}
	
	// UnselectFilename unselects a currently selected filename. If the filename is
// not in the current directory, does not exist, or is otherwise not currently
// selected, does nothing.
	func (c FileChooser) UnselectFilename(filename string)  {
var _arg0 *C.GtkFileChooser // out
var _arg1 *C.char // out

_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
_arg1 = (*C.char)(C.CString(filename))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_file_chooser_unselect_filename(_arg0, _arg1)
}
	
	// UnselectURI unselects the file referred to by @uri. If the file is not in the
// current directory, does not exist, or is otherwise not currently selected,
// does nothing.
	func (c FileChooser) UnselectURI(uri string)  {
var _arg0 *C.GtkFileChooser // out
var _arg1 *C.char // out

_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
_arg1 = (*C.char)(C.CString(uri))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_file_chooser_unselect_uri(_arg0, _arg1)
}
	


	
	// FontChooserInterface contains virtual methods for FontChooser, or
	// methods that can be overridden.
	type FontChooserInterface interface {
		gextras.Objector

		
		FontActivated(fontname string) 
			// FontFace gets the FontFace representing the selected font group details
	// (i.e. family, slant, weight, width, etc).
	// 
	// If the selected font is not installed, returns nil.
		FontFace() pango.FontFace
			// FontFamily gets the FontFamily representing the selected font family.
	// Font families are a collection of font faces.
	// 
	// If the selected font is not installed, returns nil.
		FontFamily() pango.FontFamily
			// FontMap gets the custom font map of this font chooser widget, or nil if
	// it does not have one.
		FontMap() pango.FontMap
			// FontSize: the selected font size.
		FontSize() int
			// SetFontMap sets a custom font map to use for this font chooser widget. A
	// custom font map can be used to present application-specific fonts instead
	// of or in addition to the normal system fonts.
	// 
	//    FcConfig *config;
	//    PangoFontMap *fontmap;
	// 
	//    config = FcInitLoadConfigAndFonts ();
	//    FcConfigAppFontAddFile (config, my_app_font_file);
	// 
	//    fontmap = pango_cairo_font_map_new_for_font_type (CAIRO_FONT_TYPE_FT);
	//    pango_fc_font_map_set_config (PANGO_FC_FONT_MAP (fontmap), config);
	// 
	//    gtk_font_chooser_set_font_map (font_chooser, fontmap);
	// 
	// Note that other GTK+ widgets will only be able to use the
	// application-specific font if it is present in the font map they use:
	// 
	//    context = gtk_widget_get_pango_context (label);
	//    pango_context_set_font_map (context, fontmap);
		SetFontMap(fontmap pango.FontMapClass) 
		
	}
	

	// FontChooser is an interface that can be implemented by widgets displaying the
// list of fonts. In GTK+, the main objects that implement this interface are
// FontChooserWidget, FontChooserDialog and FontButton. The GtkFontChooser
// interface has been introducted in GTK+ 3.2.
	type FontChooser struct {
		**externglib.Object
		
	}

	
	func marshalFontChooser(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return {FontChooser{
Object: &externglib.Object{externglib.ToGObject(obj)},
} map[github.com/gotk3/gotk3/glib:externglib]}, nil
	}
	

	
	// Font gets the currently-selected font name.
// 
// Note that this can be a different string than what you set with
// gtk_font_chooser_set_font(), as the font chooser widget may normalize font
// names and thus return a string with a different structure. For example,
// “Helvetica Italic Bold 12” could be normalized to “Helvetica Bold Italic 12”.
// 
// Use pango_font_description_equal() if you want to compare two font
// descriptions.
	func (f FontChooser) Font() string {
var _arg0 *C.GtkFontChooser // out
var _cret *C.gchar // in

_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(f.Native()))

_cret = C.gtk_font_chooser_get_font(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// FontDesc gets the currently-selected font.
// 
// Note that this can be a different string than what you set with
// gtk_font_chooser_set_font(), as the font chooser widget may normalize font
// names and thus return a string with a different structure. For example,
// “Helvetica Italic Bold 12” could be normalized to “Helvetica Bold Italic 12”.
// 
// Use pango_font_description_equal() if you want to compare two font
// descriptions.
	func (f FontChooser) FontDesc() *pango.FontDescription {
var _arg0 *C.GtkFontChooser // out
var _cret *C.PangoFontDescription // in

_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(f.Native()))

_cret = C.gtk_font_chooser_get_font_desc(_arg0)


var _fontDescription *pango.FontDescription // out

_fontDescription = *(**pango.FontDescription)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_fontDescription, func(v *pango.FontDescription) {
  C.free(unsafe.Pointer(v.Native()))
})

return _fontDescription
}
	
	// FontFace gets the FontFace representing the selected font group details (i.e.
// family, slant, weight, width, etc).
// 
// If the selected font is not installed, returns nil.
	func (f FontChooser) FontFace() pango.FontFace {
var _arg0 *C.GtkFontChooser // out
var _cret *C.PangoFontFace // in

_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(f.Native()))

_cret = C.gtk_font_chooser_get_font_face(_arg0)


var _fontFace pango.FontFace // out

_fontFace = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(pango.FontFace)

return _fontFace
}
	
	// FontFamily gets the FontFamily representing the selected font family. Font
// families are a collection of font faces.
// 
// If the selected font is not installed, returns nil.
	func (f FontChooser) FontFamily() pango.FontFamily {
var _arg0 *C.GtkFontChooser // out
var _cret *C.PangoFontFamily // in

_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(f.Native()))

_cret = C.gtk_font_chooser_get_font_family(_arg0)


var _fontFamily pango.FontFamily // out

_fontFamily = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(pango.FontFamily)

return _fontFamily
}
	
	// FontFeatures gets the currently-selected font features.
	func (f FontChooser) FontFeatures() string {
var _arg0 *C.GtkFontChooser // out
var _cret *C.char // in

_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(f.Native()))

_cret = C.gtk_font_chooser_get_font_features(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// FontMap gets the custom font map of this font chooser widget, or nil if it
// does not have one.
	func (f FontChooser) FontMap() pango.FontMap {
var _arg0 *C.GtkFontChooser // out
var _cret *C.PangoFontMap // in

_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(f.Native()))

_cret = C.gtk_font_chooser_get_font_map(_arg0)


var _fontMap pango.FontMap // out

_fontMap = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(pango.FontMap)

return _fontMap
}
	
	// FontSize: the selected font size.
	func (f FontChooser) FontSize() int {
var _arg0 *C.GtkFontChooser // out
var _cret C.gint // in

_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(f.Native()))

_cret = C.gtk_font_chooser_get_font_size(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Language gets the language that is used for font features.
	func (f FontChooser) Language() string {
var _arg0 *C.GtkFontChooser // out
var _cret *C.char // in

_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(f.Native()))

_cret = C.gtk_font_chooser_get_language(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// Level returns the current level of granularity for selecting fonts.
	func (f FontChooser) Level() FontChooserLevel {
var _arg0 *C.GtkFontChooser // out
var _cret C.GtkFontChooserLevel // in

_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(f.Native()))

_cret = C.gtk_font_chooser_get_level(_arg0)


var _fontChooserLevel FontChooserLevel // out

_fontChooserLevel = FontChooserLevel(_cret)

return _fontChooserLevel
}
	
	// PreviewText gets the text displayed in the preview area.
	func (f FontChooser) PreviewText() string {
var _arg0 *C.GtkFontChooser // out
var _cret *C.gchar // in

_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(f.Native()))

_cret = C.gtk_font_chooser_get_preview_text(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// ShowPreviewEntry returns whether the preview entry is shown or not.
	func (f FontChooser) ShowPreviewEntry() bool {
var _arg0 *C.GtkFontChooser // out
var _cret C.gboolean // in

_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(f.Native()))

_cret = C.gtk_font_chooser_get_show_preview_entry(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetFont sets the currently-selected font.
	func (f FontChooser) SetFont(fontname string)  {
var _arg0 *C.GtkFontChooser // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(f.Native()))
_arg1 = (*C.gchar)(C.CString(fontname))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_font_chooser_set_font(_arg0, _arg1)
}
	
	// SetFontDesc sets the currently-selected font from @font_desc.
	func (f FontChooser) SetFontDesc(fontDesc *pango.FontDescription)  {
var _arg0 *C.GtkFontChooser // out
var _arg1 *C.PangoFontDescription // out

_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(f.Native()))
_arg1 = (*C.PangoFontDescription)(unsafe.Pointer(fontDesc.Native()))

C.gtk_font_chooser_set_font_desc(_arg0, _arg1)
}
	
	// SetFontMap sets a custom font map to use for this font chooser widget. A
// custom font map can be used to present application-specific fonts instead of
// or in addition to the normal system fonts.
// 
//    FcConfig *config;
//    PangoFontMap *fontmap;
// 
//    config = FcInitLoadConfigAndFonts ();
//    FcConfigAppFontAddFile (config, my_app_font_file);
// 
//    fontmap = pango_cairo_font_map_new_for_font_type (CAIRO_FONT_TYPE_FT);
//    pango_fc_font_map_set_config (PANGO_FC_FONT_MAP (fontmap), config);
// 
//    gtk_font_chooser_set_font_map (font_chooser, fontmap);
// 
// Note that other GTK+ widgets will only be able to use the
// application-specific font if it is present in the font map they use:
// 
//    context = gtk_widget_get_pango_context (label);
//    pango_context_set_font_map (context, fontmap);
	func (f FontChooser) SetFontMap(fontmap pango.FontMapClass)  {
var _arg0 *C.GtkFontChooser // out
var _arg1 *C.PangoFontMap // out

_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(f.Native()))
_arg1 = (*C.PangoFontMap)(unsafe.Pointer(fontmap.Native()))

C.gtk_font_chooser_set_font_map(_arg0, _arg1)
}
	
	// SetLanguage sets the language to use for font features.
	func (f FontChooser) SetLanguage(language string)  {
var _arg0 *C.GtkFontChooser // out
var _arg1 *C.char // out

_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(f.Native()))
_arg1 = (*C.char)(C.CString(language))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_font_chooser_set_language(_arg0, _arg1)
}
	
	// SetLevel sets the desired level of granularity for selecting fonts.
	func (f FontChooser) SetLevel(level FontChooserLevel)  {
var _arg0 *C.GtkFontChooser // out
var _arg1 C.GtkFontChooserLevel // out

_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(f.Native()))
_arg1 = (C.GtkFontChooserLevel)(level)

C.gtk_font_chooser_set_level(_arg0, _arg1)
}
	
	// SetPreviewText sets the text displayed in the preview area. The @text is used
// to show how the selected font looks.
	func (f FontChooser) SetPreviewText(text string)  {
var _arg0 *C.GtkFontChooser // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(f.Native()))
_arg1 = (*C.gchar)(C.CString(text))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_font_chooser_set_preview_text(_arg0, _arg1)
}
	
	// SetShowPreviewEntry shows or hides the editable preview entry.
	func (f FontChooser) SetShowPreviewEntry(showPreviewEntry bool)  {
var _arg0 *C.GtkFontChooser // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(f.Native()))
if showPreviewEntry { _arg1 = C.TRUE }

C.gtk_font_chooser_set_show_preview_entry(_arg0, _arg1)
}
	


	

	// Orientable: the Orientable interface is implemented by all widgets that can
// be oriented horizontally or vertically. Historically, such widgets have been
// realized as subclasses of a common base class (e.g Box/HBox/VBox or
// Scale/HScale/VScale). Orientable is more flexible in that it allows the
// orientation to be changed at runtime, allowing the widgets to “flip”.
// 
// Orientable was introduced in GTK+ 2.16.
	type Orientable struct {
		**externglib.Object
		
	}

	
	func marshalOrientable(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return {Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
} map[github.com/gotk3/gotk3/glib:externglib]}, nil
	}
	

	
	// Orientation retrieves the orientation of the @orientable.
	func (o Orientable) Orientation() Orientation {
var _arg0 *C.GtkOrientable // out
var _cret C.GtkOrientation // in

_arg0 = (*C.GtkOrientable)(unsafe.Pointer(o.Native()))

_cret = C.gtk_orientable_get_orientation(_arg0)


var _orientation Orientation // out

_orientation = Orientation(_cret)

return _orientation
}
	
	// SetOrientation sets the orientation of the @orientable.
	func (o Orientable) SetOrientation(orientation Orientation)  {
var _arg0 *C.GtkOrientable // out
var _arg1 C.GtkOrientation // out

_arg0 = (*C.GtkOrientable)(unsafe.Pointer(o.Native()))
_arg1 = (C.GtkOrientation)(orientation)

C.gtk_orientable_set_orientation(_arg0, _arg1)
}
	


	
	// PrintOperationPreviewInterface contains virtual methods for PrintOperationPreview, or
	// methods that can be overridden.
	type PrintOperationPreviewInterface interface {
		gextras.Objector

			// EndPreview ends a preview.
	// 
	// This function must be called to finish a custom print preview.
		EndPreview() 
		
		GotPageSize(context PrintContextClass, pageSetup PageSetupClass) 
			// IsSelected returns whether the given page is included in the set of pages
	// that have been selected for printing.
		IsSelected(pageNr int) bool
		
		Ready(context PrintContextClass) 
			// RenderPage renders a page to the preview, using the print context that
	// was passed to the PrintOperation::preview handler together with @preview.
	// 
	// A custom iprint preview should use this function in its ::expose handler
	// to render the currently selected page.
	// 
	// Note that this function requires a suitable cairo context to be
	// associated with the print context.
		RenderPage(pageNr int) 
		
	}
	

	
	type PrintOperationPreview struct {
		**externglib.Object
		
	}

	
	func marshalPrintOperationPreview(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return {PrintOperationPreview{
Object: &externglib.Object{externglib.ToGObject(obj)},
} map[github.com/gotk3/gotk3/glib:externglib]}, nil
	}
	

	
	// EndPreview ends a preview.
// 
// This function must be called to finish a custom print preview.
	func (p PrintOperationPreview) EndPreview()  {
var _arg0 *C.GtkPrintOperationPreview // out

_arg0 = (*C.GtkPrintOperationPreview)(unsafe.Pointer(p.Native()))

C.gtk_print_operation_preview_end_preview(_arg0)
}
	
	// IsSelected returns whether the given page is included in the set of pages
// that have been selected for printing.
	func (p PrintOperationPreview) IsSelected(pageNr int) bool {
var _arg0 *C.GtkPrintOperationPreview // out
var _arg1 C.gint // out
var _cret C.gboolean // in

_arg0 = (*C.GtkPrintOperationPreview)(unsafe.Pointer(p.Native()))
_arg1 = (C.gint)(pageNr)

_cret = C.gtk_print_operation_preview_is_selected(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// RenderPage renders a page to the preview, using the print context that was
// passed to the PrintOperation::preview handler together with @preview.
// 
// A custom iprint preview should use this function in its ::expose handler to
// render the currently selected page.
// 
// Note that this function requires a suitable cairo context to be associated
// with the print context.
	func (p PrintOperationPreview) RenderPage(pageNr int)  {
var _arg0 *C.GtkPrintOperationPreview // out
var _arg1 C.gint // out

_arg0 = (*C.GtkPrintOperationPreview)(unsafe.Pointer(p.Native()))
_arg1 = (C.gint)(pageNr)

C.gtk_print_operation_preview_render_page(_arg0, _arg1)
}
	


	
	// RecentChooserInterface contains virtual methods for RecentChooser, or
	// methods that can be overridden.
	type RecentChooserInterface interface {
		gextras.Objector

			// AddFilter adds @filter to the list of RecentFilter objects held by
	// @chooser.
	// 
	// If no previous filter objects were defined, this function will call
	// gtk_recent_chooser_set_filter().
		AddFilter(filter RecentFilterClass) 
			// CurrentURI gets the URI currently selected by @chooser.
		CurrentURI() string
		
		ItemActivated() 
			// RemoveFilter removes @filter from the list of RecentFilter objects held
	// by @chooser.
		RemoveFilter(filter RecentFilterClass) 
			// SelectAll selects all the items inside @chooser, if the @chooser supports
	// multiple selection.
		SelectAll() 
			// SelectURI selects @uri inside @chooser.
		SelectURI(uri string) error
		
		SelectionChanged() 
			// SetCurrentURI sets @uri as the current URI for @chooser.
		SetCurrentURI(uri string) error
			// UnselectAll unselects all the items inside @chooser.
		UnselectAll() 
			// UnselectURI unselects @uri inside @chooser.
		UnselectURI(uri string) 
		
	}
	

	// RecentChooser is an interface that can be implemented by widgets displaying
// the list of recently used files. In GTK+, the main objects that implement
// this interface are RecentChooserWidget, RecentChooserDialog and
// RecentChooserMenu.
// 
// Recently used files are supported since GTK+ 2.10.
	type RecentChooser struct {
		**externglib.Object
		
	}

	
	func marshalRecentChooser(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return {RecentChooser{
Object: &externglib.Object{externglib.ToGObject(obj)},
} map[github.com/gotk3/gotk3/glib:externglib]}, nil
	}
	

	
	// AddFilter adds @filter to the list of RecentFilter objects held by @chooser.
// 
// If no previous filter objects were defined, this function will call
// gtk_recent_chooser_set_filter().
	func (c RecentChooser) AddFilter(filter RecentFilterClass)  {
var _arg0 *C.GtkRecentChooser // out
var _arg1 *C.GtkRecentFilter // out

_arg0 = (*C.GtkRecentChooser)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GtkRecentFilter)(unsafe.Pointer(filter.Native()))

C.gtk_recent_chooser_add_filter(_arg0, _arg1)
}
	
	// CurrentItem gets the RecentInfo currently selected by @chooser.
	func (c RecentChooser) CurrentItem() *RecentInfo {
var _arg0 *C.GtkRecentChooser // out
var _cret *C.GtkRecentInfo // in

_arg0 = (*C.GtkRecentChooser)(unsafe.Pointer(c.Native()))

_cret = C.gtk_recent_chooser_get_current_item(_arg0)


var _recentInfo *RecentInfo // out

_recentInfo = *(**RecentInfo)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_recentInfo, func(v *RecentInfo) {
  C.free(unsafe.Pointer(v.Native()))
})

return _recentInfo
}
	
	// CurrentURI gets the URI currently selected by @chooser.
	func (c RecentChooser) CurrentURI() string {
var _arg0 *C.GtkRecentChooser // out
var _cret *C.gchar // in

_arg0 = (*C.GtkRecentChooser)(unsafe.Pointer(c.Native()))

_cret = C.gtk_recent_chooser_get_current_uri(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// Filter gets the RecentFilter object currently used by @chooser to affect the
// display of the recently used resources.
	func (c RecentChooser) Filter() RecentFilter {
var _arg0 *C.GtkRecentChooser // out
var _cret *C.GtkRecentFilter // in

_arg0 = (*C.GtkRecentChooser)(unsafe.Pointer(c.Native()))

_cret = C.gtk_recent_chooser_get_filter(_arg0)


var _recentFilter RecentFilter // out

_recentFilter = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(RecentFilter)

return _recentFilter
}
	
	// Limit gets the number of items returned by gtk_recent_chooser_get_items() and
// gtk_recent_chooser_get_uris().
	func (c RecentChooser) Limit() int {
var _arg0 *C.GtkRecentChooser // out
var _cret C.gint // in

_arg0 = (*C.GtkRecentChooser)(unsafe.Pointer(c.Native()))

_cret = C.gtk_recent_chooser_get_limit(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// LocalOnly gets whether only local resources should be shown in the recently
// used resources selector. See gtk_recent_chooser_set_local_only()
	func (c RecentChooser) LocalOnly() bool {
var _arg0 *C.GtkRecentChooser // out
var _cret C.gboolean // in

_arg0 = (*C.GtkRecentChooser)(unsafe.Pointer(c.Native()))

_cret = C.gtk_recent_chooser_get_local_only(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SelectMultiple gets whether @chooser can select multiple items.
	func (c RecentChooser) SelectMultiple() bool {
var _arg0 *C.GtkRecentChooser // out
var _cret C.gboolean // in

_arg0 = (*C.GtkRecentChooser)(unsafe.Pointer(c.Native()))

_cret = C.gtk_recent_chooser_get_select_multiple(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ShowIcons retrieves whether @chooser should show an icon near the resource.
	func (c RecentChooser) ShowIcons() bool {
var _arg0 *C.GtkRecentChooser // out
var _cret C.gboolean // in

_arg0 = (*C.GtkRecentChooser)(unsafe.Pointer(c.Native()))

_cret = C.gtk_recent_chooser_get_show_icons(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ShowNotFound retrieves whether @chooser should show the recently used
// resources that were not found.
	func (c RecentChooser) ShowNotFound() bool {
var _arg0 *C.GtkRecentChooser // out
var _cret C.gboolean // in

_arg0 = (*C.GtkRecentChooser)(unsafe.Pointer(c.Native()))

_cret = C.gtk_recent_chooser_get_show_not_found(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ShowPrivate returns whether @chooser should display recently used resources
// registered as private.
	func (c RecentChooser) ShowPrivate() bool {
var _arg0 *C.GtkRecentChooser // out
var _cret C.gboolean // in

_arg0 = (*C.GtkRecentChooser)(unsafe.Pointer(c.Native()))

_cret = C.gtk_recent_chooser_get_show_private(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ShowTips gets whether @chooser should display tooltips containing the full
// path of a recently user resource.
	func (c RecentChooser) ShowTips() bool {
var _arg0 *C.GtkRecentChooser // out
var _cret C.gboolean // in

_arg0 = (*C.GtkRecentChooser)(unsafe.Pointer(c.Native()))

_cret = C.gtk_recent_chooser_get_show_tips(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SortType gets the value set by gtk_recent_chooser_set_sort_type().
	func (c RecentChooser) SortType() RecentSortType {
var _arg0 *C.GtkRecentChooser // out
var _cret C.GtkRecentSortType // in

_arg0 = (*C.GtkRecentChooser)(unsafe.Pointer(c.Native()))

_cret = C.gtk_recent_chooser_get_sort_type(_arg0)


var _recentSortType RecentSortType // out

_recentSortType = RecentSortType(_cret)

return _recentSortType
}
	
	// RemoveFilter removes @filter from the list of RecentFilter objects held by
// @chooser.
	func (c RecentChooser) RemoveFilter(filter RecentFilterClass)  {
var _arg0 *C.GtkRecentChooser // out
var _arg1 *C.GtkRecentFilter // out

_arg0 = (*C.GtkRecentChooser)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GtkRecentFilter)(unsafe.Pointer(filter.Native()))

C.gtk_recent_chooser_remove_filter(_arg0, _arg1)
}
	
	// SelectAll selects all the items inside @chooser, if the @chooser supports
// multiple selection.
	func (c RecentChooser) SelectAll()  {
var _arg0 *C.GtkRecentChooser // out

_arg0 = (*C.GtkRecentChooser)(unsafe.Pointer(c.Native()))

C.gtk_recent_chooser_select_all(_arg0)
}
	
	// SelectURI selects @uri inside @chooser.
	func (c RecentChooser) SelectURI(uri string) error {
var _arg0 *C.GtkRecentChooser // out
var _arg1 *C.gchar // out
var _cerr *C.GError // in

_arg0 = (*C.GtkRecentChooser)(unsafe.Pointer(c.Native()))
_arg1 = (*C.gchar)(C.CString(uri))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_recent_chooser_select_uri(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// SetCurrentURI sets @uri as the current URI for @chooser.
	func (c RecentChooser) SetCurrentURI(uri string) error {
var _arg0 *C.GtkRecentChooser // out
var _arg1 *C.gchar // out
var _cerr *C.GError // in

_arg0 = (*C.GtkRecentChooser)(unsafe.Pointer(c.Native()))
_arg1 = (*C.gchar)(C.CString(uri))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_recent_chooser_set_current_uri(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// SetFilter sets @filter as the current RecentFilter object used by @chooser to
// affect the displayed recently used resources.
	func (c RecentChooser) SetFilter(filter RecentFilterClass)  {
var _arg0 *C.GtkRecentChooser // out
var _arg1 *C.GtkRecentFilter // out

_arg0 = (*C.GtkRecentChooser)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GtkRecentFilter)(unsafe.Pointer(filter.Native()))

C.gtk_recent_chooser_set_filter(_arg0, _arg1)
}
	
	// SetLimit sets the number of items that should be returned by
// gtk_recent_chooser_get_items() and gtk_recent_chooser_get_uris().
	func (c RecentChooser) SetLimit(limit int)  {
var _arg0 *C.GtkRecentChooser // out
var _arg1 C.gint // out

_arg0 = (*C.GtkRecentChooser)(unsafe.Pointer(c.Native()))
_arg1 = (C.gint)(limit)

C.gtk_recent_chooser_set_limit(_arg0, _arg1)
}
	
	// SetLocalOnly sets whether only local resources, that is resources using the
// file:// URI scheme, should be shown in the recently used resources selector.
// If @local_only is true (the default) then the shown resources are guaranteed
// to be accessible through the operating system native file system.
	func (c RecentChooser) SetLocalOnly(localOnly bool)  {
var _arg0 *C.GtkRecentChooser // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkRecentChooser)(unsafe.Pointer(c.Native()))
if localOnly { _arg1 = C.TRUE }

C.gtk_recent_chooser_set_local_only(_arg0, _arg1)
}
	
	// SetSelectMultiple sets whether @chooser can select multiple items.
	func (c RecentChooser) SetSelectMultiple(selectMultiple bool)  {
var _arg0 *C.GtkRecentChooser // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkRecentChooser)(unsafe.Pointer(c.Native()))
if selectMultiple { _arg1 = C.TRUE }

C.gtk_recent_chooser_set_select_multiple(_arg0, _arg1)
}
	
	// SetShowIcons sets whether @chooser should show an icon near the resource when
// displaying it.
	func (c RecentChooser) SetShowIcons(showIcons bool)  {
var _arg0 *C.GtkRecentChooser // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkRecentChooser)(unsafe.Pointer(c.Native()))
if showIcons { _arg1 = C.TRUE }

C.gtk_recent_chooser_set_show_icons(_arg0, _arg1)
}
	
	// SetShowNotFound sets whether @chooser should display the recently used
// resources that it didn’t find. This only applies to local resources.
	func (c RecentChooser) SetShowNotFound(showNotFound bool)  {
var _arg0 *C.GtkRecentChooser // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkRecentChooser)(unsafe.Pointer(c.Native()))
if showNotFound { _arg1 = C.TRUE }

C.gtk_recent_chooser_set_show_not_found(_arg0, _arg1)
}
	
	// SetShowPrivate: whether to show recently used resources marked registered as
// private.
	func (c RecentChooser) SetShowPrivate(showPrivate bool)  {
var _arg0 *C.GtkRecentChooser // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkRecentChooser)(unsafe.Pointer(c.Native()))
if showPrivate { _arg1 = C.TRUE }

C.gtk_recent_chooser_set_show_private(_arg0, _arg1)
}
	
	// SetShowTips sets whether to show a tooltips containing the full path of each
// recently used resource in a RecentChooser widget.
	func (c RecentChooser) SetShowTips(showTips bool)  {
var _arg0 *C.GtkRecentChooser // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkRecentChooser)(unsafe.Pointer(c.Native()))
if showTips { _arg1 = C.TRUE }

C.gtk_recent_chooser_set_show_tips(_arg0, _arg1)
}
	
	// SetSortType changes the sorting order of the recently used resources list
// displayed by @chooser.
	func (c RecentChooser) SetSortType(sortType RecentSortType)  {
var _arg0 *C.GtkRecentChooser // out
var _arg1 C.GtkRecentSortType // out

_arg0 = (*C.GtkRecentChooser)(unsafe.Pointer(c.Native()))
_arg1 = (C.GtkRecentSortType)(sortType)

C.gtk_recent_chooser_set_sort_type(_arg0, _arg1)
}
	
	// UnselectAll unselects all the items inside @chooser.
	func (c RecentChooser) UnselectAll()  {
var _arg0 *C.GtkRecentChooser // out

_arg0 = (*C.GtkRecentChooser)(unsafe.Pointer(c.Native()))

C.gtk_recent_chooser_unselect_all(_arg0)
}
	
	// UnselectURI unselects @uri inside @chooser.
	func (c RecentChooser) UnselectURI(uri string)  {
var _arg0 *C.GtkRecentChooser // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkRecentChooser)(unsafe.Pointer(c.Native()))
_arg1 = (*C.gchar)(C.CString(uri))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_recent_chooser_unselect_uri(_arg0, _arg1)
}
	


	
	// ScrollableInterface contains virtual methods for Scrollable, or
	// methods that can be overridden.
	type ScrollableInterface interface {
		gextras.Objector

			// Border returns the size of a non-scrolling border around the outside of
	// the scrollable. An example for this would be treeview headers. GTK+ can
	// use this information to display overlayed graphics, like the overshoot
	// indication, at the right position.
		Border() (Border, bool)
		
	}
	

	// Scrollable is an interface that is implemented by widgets with native
// scrolling ability.
// 
// To implement this interface you should override the Scrollable:hadjustment
// and Scrollable:vadjustment properties.
// 
// 
// Creating a scrollable widget
// 
// All scrollable widgets should do the following.
// 
// - When a parent widget sets the scrollable child widget’s adjustments, the
// widget should populate the adjustments’ Adjustment:lower, Adjustment:upper,
// Adjustment:step-increment, Adjustment:page-increment and Adjustment:page-size
// properties and connect to the Adjustment::value-changed signal.
// 
// - Because its preferred size is the size for a fully expanded widget, the
// scrollable widget must be able to cope with underallocations. This means that
// it must accept any value passed to its WidgetClass.size_allocate() function.
// 
// - When the parent allocates space to the scrollable child widget, the widget
// should update the adjustments’ properties with new values.
// 
// - When any of the adjustments emits the Adjustment::value-changed signal, the
// scrollable widget should scroll its contents.
	type Scrollable struct {
		**externglib.Object
		
	}

	
	func marshalScrollable(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return {Scrollable{
Object: &externglib.Object{externglib.ToGObject(obj)},
} map[github.com/gotk3/gotk3/glib:externglib]}, nil
	}
	

	
	// Border returns the size of a non-scrolling border around the outside of the
// scrollable. An example for this would be treeview headers. GTK+ can use this
// information to display overlayed graphics, like the overshoot indication, at
// the right position.
	func (s Scrollable) Border() (Border, bool) {
var _arg0 *C.GtkScrollable // out
var _border Border
var _cret C.gboolean // in

_arg0 = (*C.GtkScrollable)(unsafe.Pointer(s.Native()))

_cret = C.gtk_scrollable_get_border(_arg0, (*C.GtkBorder)(unsafe.Pointer(&_border)))



var _ok bool // out


if _cret != 0 { _ok = true }

return _border, _ok
}
	
	// HAdjustment retrieves the Adjustment used for horizontal scrolling.
	func (s Scrollable) HAdjustment() Adjustment {
var _arg0 *C.GtkScrollable // out
var _cret *C.GtkAdjustment // in

_arg0 = (*C.GtkScrollable)(unsafe.Pointer(s.Native()))

_cret = C.gtk_scrollable_get_hadjustment(_arg0)


var _adjustment Adjustment // out

_adjustment = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Adjustment)

return _adjustment
}
	
	// HScrollPolicy gets the horizontal ScrollablePolicy.
	func (s Scrollable) HScrollPolicy() ScrollablePolicy {
var _arg0 *C.GtkScrollable // out
var _cret C.GtkScrollablePolicy // in

_arg0 = (*C.GtkScrollable)(unsafe.Pointer(s.Native()))

_cret = C.gtk_scrollable_get_hscroll_policy(_arg0)


var _scrollablePolicy ScrollablePolicy // out

_scrollablePolicy = ScrollablePolicy(_cret)

return _scrollablePolicy
}
	
	// VAdjustment retrieves the Adjustment used for vertical scrolling.
	func (s Scrollable) VAdjustment() Adjustment {
var _arg0 *C.GtkScrollable // out
var _cret *C.GtkAdjustment // in

_arg0 = (*C.GtkScrollable)(unsafe.Pointer(s.Native()))

_cret = C.gtk_scrollable_get_vadjustment(_arg0)


var _adjustment Adjustment // out

_adjustment = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Adjustment)

return _adjustment
}
	
	// VScrollPolicy gets the vertical ScrollablePolicy.
	func (s Scrollable) VScrollPolicy() ScrollablePolicy {
var _arg0 *C.GtkScrollable // out
var _cret C.GtkScrollablePolicy // in

_arg0 = (*C.GtkScrollable)(unsafe.Pointer(s.Native()))

_cret = C.gtk_scrollable_get_vscroll_policy(_arg0)


var _scrollablePolicy ScrollablePolicy // out

_scrollablePolicy = ScrollablePolicy(_cret)

return _scrollablePolicy
}
	
	// SetHAdjustment sets the horizontal adjustment of the Scrollable.
	func (s Scrollable) SetHAdjustment(hadjustment AdjustmentClass)  {
var _arg0 *C.GtkScrollable // out
var _arg1 *C.GtkAdjustment // out

_arg0 = (*C.GtkScrollable)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(hadjustment.Native()))

C.gtk_scrollable_set_hadjustment(_arg0, _arg1)
}
	
	// SetHScrollPolicy sets the ScrollablePolicy to determine whether horizontal
// scrolling should start below the minimum width or below the natural width.
	func (s Scrollable) SetHScrollPolicy(policy ScrollablePolicy)  {
var _arg0 *C.GtkScrollable // out
var _arg1 C.GtkScrollablePolicy // out

_arg0 = (*C.GtkScrollable)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkScrollablePolicy)(policy)

C.gtk_scrollable_set_hscroll_policy(_arg0, _arg1)
}
	
	// SetVAdjustment sets the vertical adjustment of the Scrollable.
	func (s Scrollable) SetVAdjustment(vadjustment AdjustmentClass)  {
var _arg0 *C.GtkScrollable // out
var _arg1 *C.GtkAdjustment // out

_arg0 = (*C.GtkScrollable)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(vadjustment.Native()))

C.gtk_scrollable_set_vadjustment(_arg0, _arg1)
}
	
	// SetVScrollPolicy sets the ScrollablePolicy to determine whether vertical
// scrolling should start below the minimum height or below the natural height.
	func (s Scrollable) SetVScrollPolicy(policy ScrollablePolicy)  {
var _arg0 *C.GtkScrollable // out
var _arg1 C.GtkScrollablePolicy // out

_arg0 = (*C.GtkScrollable)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkScrollablePolicy)(policy)

C.gtk_scrollable_set_vscroll_policy(_arg0, _arg1)
}
	


	
	// StyleProviderInterface contains virtual methods for StyleProvider, or
	// methods that can be overridden.
	type StyleProviderInterface interface {
		gextras.Objector

			// IconFactory returns the IconFactory defined to be in use for @path, or
	// nil if none is defined.
		IconFactory(path *WidgetPath) IconFactory
			// Style returns the style settings affecting a widget defined by @path, or
	// nil if @provider doesn’t contemplate styling @path.
		Style(path *WidgetPath) StyleProperties
		
	}
	

	// StyleProvider: gtkStyleProvider is an interface used to provide style
// information to a StyleContext. See gtk_style_context_add_provider() and
// gtk_style_context_add_provider_for_screen().
	type StyleProvider struct {
		**externglib.Object
		
	}

	
	func marshalStyleProvider(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return {StyleProvider{
Object: &externglib.Object{externglib.ToGObject(obj)},
} map[github.com/gotk3/gotk3/glib:externglib]}, nil
	}
	

	
	// IconFactory returns the IconFactory defined to be in use for @path, or nil if
// none is defined.
	func (p StyleProvider) IconFactory(path *WidgetPath) IconFactory {
var _arg0 *C.GtkStyleProvider // out
var _arg1 *C.GtkWidgetPath // out
var _cret *C.GtkIconFactory // in

_arg0 = (*C.GtkStyleProvider)(unsafe.Pointer(p.Native()))
_arg1 = (*C.GtkWidgetPath)(unsafe.Pointer(path.Native()))

_cret = C.gtk_style_provider_get_icon_factory(_arg0, _arg1)


var _iconFactory IconFactory // out

_iconFactory = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(IconFactory)

return _iconFactory
}
	
	// Style returns the style settings affecting a widget defined by @path, or nil
// if @provider doesn’t contemplate styling @path.
	func (p StyleProvider) Style(path *WidgetPath) StyleProperties {
var _arg0 *C.GtkStyleProvider // out
var _arg1 *C.GtkWidgetPath // out
var _cret *C.GtkStyleProperties // in

_arg0 = (*C.GtkStyleProvider)(unsafe.Pointer(p.Native()))
_arg1 = (*C.GtkWidgetPath)(unsafe.Pointer(path.Native()))

_cret = C.gtk_style_provider_get_style(_arg0, _arg1)


var _styleProperties StyleProperties // out

_styleProperties = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(StyleProperties)

return _styleProperties
}
	


	
	// ToolShellInterface contains virtual methods for ToolShell, or
	// methods that can be overridden.
	type ToolShellInterface interface {
		gextras.Objector

			// EllipsizeMode retrieves the current ellipsize mode for the tool shell.
	// Tool items must not call this function directly, but rely on
	// gtk_tool_item_get_ellipsize_mode() instead.
		EllipsizeMode() pango.EllipsizeMode
		
		IconSize() IconSize
			// Orientation retrieves the current orientation for the tool shell. Tool
	// items must not call this function directly, but rely on
	// gtk_tool_item_get_orientation() instead.
		Orientation() Orientation
			// ReliefStyle returns the relief style of buttons on @shell. Tool items
	// must not call this function directly, but rely on
	// gtk_tool_item_get_relief_style() instead.
		ReliefStyle() ReliefStyle
			// Style retrieves whether the tool shell has text, icons, or both. Tool
	// items must not call this function directly, but rely on
	// gtk_tool_item_get_toolbar_style() instead.
		Style() ToolbarStyle
			// TextAlignment retrieves the current text alignment for the tool shell.
	// Tool items must not call this function directly, but rely on
	// gtk_tool_item_get_text_alignment() instead.
		TextAlignment() float32
			// TextOrientation retrieves the current text orientation for the tool
	// shell. Tool items must not call this function directly, but rely on
	// gtk_tool_item_get_text_orientation() instead.
		TextOrientation() Orientation
			// TextSizeGroup retrieves the current text size group for the tool shell.
	// Tool items must not call this function directly, but rely on
	// gtk_tool_item_get_text_size_group() instead.
		TextSizeGroup() SizeGroup
			// RebuildMenu: calling this function signals the tool shell that the
	// overflow menu item for tool items have changed. If there is an overflow
	// menu and if it is visible when this function it called, the menu will be
	// rebuilt.
	// 
	// Tool items must not call this function directly, but rely on
	// gtk_tool_item_rebuild_menu() instead.
		RebuildMenu() 
		
	}
	

	// ToolShell: the ToolShell interface allows container widgets to provide
// additional information when embedding ToolItem widgets.
	type ToolShell struct {
		Widget
		
	}

	
	func marshalToolShell(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return {ToolShell{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
} map[github.com/gotk3/gotk3/glib:externglib]}, nil
	}
	

	
	// EllipsizeMode retrieves the current ellipsize mode for the tool shell. Tool
// items must not call this function directly, but rely on
// gtk_tool_item_get_ellipsize_mode() instead.
	func (s ToolShell) EllipsizeMode() pango.EllipsizeMode {
var _arg0 *C.GtkToolShell // out
var _cret C.PangoEllipsizeMode // in

_arg0 = (*C.GtkToolShell)(unsafe.Pointer(s.Native()))

_cret = C.gtk_tool_shell_get_ellipsize_mode(_arg0)


var _ellipsizeMode pango.EllipsizeMode // out

_ellipsizeMode = pango.EllipsizeMode(_cret)

return _ellipsizeMode
}
	
	// IconSize retrieves the icon size for the tool shell. Tool items must not call
// this function directly, but rely on gtk_tool_item_get_icon_size() instead.
	func (s ToolShell) IconSize() int {
var _arg0 *C.GtkToolShell // out
var _cret C.GtkIconSize // in

_arg0 = (*C.GtkToolShell)(unsafe.Pointer(s.Native()))

_cret = C.gtk_tool_shell_get_icon_size(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Orientation retrieves the current orientation for the tool shell. Tool items
// must not call this function directly, but rely on
// gtk_tool_item_get_orientation() instead.
	func (s ToolShell) Orientation() Orientation {
var _arg0 *C.GtkToolShell // out
var _cret C.GtkOrientation // in

_arg0 = (*C.GtkToolShell)(unsafe.Pointer(s.Native()))

_cret = C.gtk_tool_shell_get_orientation(_arg0)


var _orientation Orientation // out

_orientation = Orientation(_cret)

return _orientation
}
	
	// ReliefStyle returns the relief style of buttons on @shell. Tool items must
// not call this function directly, but rely on gtk_tool_item_get_relief_style()
// instead.
	func (s ToolShell) ReliefStyle() ReliefStyle {
var _arg0 *C.GtkToolShell // out
var _cret C.GtkReliefStyle // in

_arg0 = (*C.GtkToolShell)(unsafe.Pointer(s.Native()))

_cret = C.gtk_tool_shell_get_relief_style(_arg0)


var _reliefStyle ReliefStyle // out

_reliefStyle = ReliefStyle(_cret)

return _reliefStyle
}
	
	// Style retrieves whether the tool shell has text, icons, or both. Tool items
// must not call this function directly, but rely on
// gtk_tool_item_get_toolbar_style() instead.
	func (s ToolShell) Style() ToolbarStyle {
var _arg0 *C.GtkToolShell // out
var _cret C.GtkToolbarStyle // in

_arg0 = (*C.GtkToolShell)(unsafe.Pointer(s.Native()))

_cret = C.gtk_tool_shell_get_style(_arg0)


var _toolbarStyle ToolbarStyle // out

_toolbarStyle = ToolbarStyle(_cret)

return _toolbarStyle
}
	
	// TextAlignment retrieves the current text alignment for the tool shell. Tool
// items must not call this function directly, but rely on
// gtk_tool_item_get_text_alignment() instead.
	func (s ToolShell) TextAlignment() float32 {
var _arg0 *C.GtkToolShell // out
var _cret C.gfloat // in

_arg0 = (*C.GtkToolShell)(unsafe.Pointer(s.Native()))

_cret = C.gtk_tool_shell_get_text_alignment(_arg0)


var _gfloat float32 // out

_gfloat = (float32)(_cret)

return _gfloat
}
	
	// TextOrientation retrieves the current text orientation for the tool shell.
// Tool items must not call this function directly, but rely on
// gtk_tool_item_get_text_orientation() instead.
	func (s ToolShell) TextOrientation() Orientation {
var _arg0 *C.GtkToolShell // out
var _cret C.GtkOrientation // in

_arg0 = (*C.GtkToolShell)(unsafe.Pointer(s.Native()))

_cret = C.gtk_tool_shell_get_text_orientation(_arg0)


var _orientation Orientation // out

_orientation = Orientation(_cret)

return _orientation
}
	
	// TextSizeGroup retrieves the current text size group for the tool shell. Tool
// items must not call this function directly, but rely on
// gtk_tool_item_get_text_size_group() instead.
	func (s ToolShell) TextSizeGroup() SizeGroup {
var _arg0 *C.GtkToolShell // out
var _cret *C.GtkSizeGroup // in

_arg0 = (*C.GtkToolShell)(unsafe.Pointer(s.Native()))

_cret = C.gtk_tool_shell_get_text_size_group(_arg0)


var _sizeGroup SizeGroup // out

_sizeGroup = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(SizeGroup)

return _sizeGroup
}
	
	// RebuildMenu: calling this function signals the tool shell that the overflow
// menu item for tool items have changed. If there is an overflow menu and if it
// is visible when this function it called, the menu will be rebuilt.
// 
// Tool items must not call this function directly, but rely on
// gtk_tool_item_rebuild_menu() instead.
	func (s ToolShell) RebuildMenu()  {
var _arg0 *C.GtkToolShell // out

_arg0 = (*C.GtkToolShell)(unsafe.Pointer(s.Native()))

C.gtk_tool_shell_rebuild_menu(_arg0)
}
	


	
	// TreeDragDestInterface contains virtual methods for TreeDragDest, or
	// methods that can be overridden.
	type TreeDragDestInterface interface {
		gextras.Objector

			// DragDataReceived asks the TreeDragDest to insert a row before the path
	// @dest, deriving the contents of the row from @selection_data. If @dest is
	// outside the tree so that inserting before it is impossible, false will be
	// returned. Also, false may be returned if the new row is not created for
	// some model-specific reason. Should robustly handle a @dest no longer
	// found in the model!
		DragDataReceived(dest *TreePath, selectionData *SelectionData) bool
			// RowDropPossible determines whether a drop is possible before the given
	// @dest_path, at the same depth as @dest_path. i.e., can we drop the data
	// in @selection_data at that location. @dest_path does not have to exist;
	// the return value will almost certainly be false if the parent of
	// @dest_path doesn’t exist, though.
		RowDropPossible(destPath *TreePath, selectionData *SelectionData) bool
		
	}
	

	
	type TreeDragDest struct {
		**externglib.Object
		
	}

	
	func marshalTreeDragDest(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return {TreeDragDest{
Object: &externglib.Object{externglib.ToGObject(obj)},
} map[github.com/gotk3/gotk3/glib:externglib]}, nil
	}
	

	
	// DragDataReceived asks the TreeDragDest to insert a row before the path @dest,
// deriving the contents of the row from @selection_data. If @dest is outside
// the tree so that inserting before it is impossible, false will be returned.
// Also, false may be returned if the new row is not created for some
// model-specific reason. Should robustly handle a @dest no longer found in the
// model!
	func (d TreeDragDest) DragDataReceived(dest *TreePath, selectionData *SelectionData) bool {
var _arg0 *C.GtkTreeDragDest // out
var _arg1 *C.GtkTreePath // out
var _arg2 *C.GtkSelectionData // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeDragDest)(unsafe.Pointer(d.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(dest.Native()))
_arg2 = (*C.GtkSelectionData)(unsafe.Pointer(selectionData.Native()))

_cret = C.gtk_tree_drag_dest_drag_data_received(_arg0, _arg1, _arg2)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// RowDropPossible determines whether a drop is possible before the given
// @dest_path, at the same depth as @dest_path. i.e., can we drop the data in
// @selection_data at that location. @dest_path does not have to exist; the
// return value will almost certainly be false if the parent of @dest_path
// doesn’t exist, though.
	func (d TreeDragDest) RowDropPossible(destPath *TreePath, selectionData *SelectionData) bool {
var _arg0 *C.GtkTreeDragDest // out
var _arg1 *C.GtkTreePath // out
var _arg2 *C.GtkSelectionData // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeDragDest)(unsafe.Pointer(d.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(destPath.Native()))
_arg2 = (*C.GtkSelectionData)(unsafe.Pointer(selectionData.Native()))

_cret = C.gtk_tree_drag_dest_row_drop_possible(_arg0, _arg1, _arg2)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	


	
	// TreeDragSourceInterface contains virtual methods for TreeDragSource, or
	// methods that can be overridden.
	type TreeDragSourceInterface interface {
		gextras.Objector

			// DragDataDelete asks the TreeDragSource to delete the row at @path,
	// because it was moved somewhere else via drag-and-drop. Returns false if
	// the deletion fails because @path no longer exists, or for some
	// model-specific reason. Should robustly handle a @path no longer found in
	// the model!
		DragDataDelete(path *TreePath) bool
			// DragDataGet asks the TreeDragSource to fill in @selection_data with a
	// representation of the row at @path. @selection_data->target gives the
	// required type of the data. Should robustly handle a @path no longer found
	// in the model!
		DragDataGet(path *TreePath, selectionData *SelectionData) bool
			// RowDraggable asks the TreeDragSource whether a particular row can be used
	// as the source of a DND operation. If the source doesn’t implement this
	// interface, the row is assumed draggable.
		RowDraggable(path *TreePath) bool
		
	}
	

	
	type TreeDragSource struct {
		**externglib.Object
		
	}

	
	func marshalTreeDragSource(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return {TreeDragSource{
Object: &externglib.Object{externglib.ToGObject(obj)},
} map[github.com/gotk3/gotk3/glib:externglib]}, nil
	}
	

	
	// DragDataDelete asks the TreeDragSource to delete the row at @path, because it
// was moved somewhere else via drag-and-drop. Returns false if the deletion
// fails because @path no longer exists, or for some model-specific reason.
// Should robustly handle a @path no longer found in the model!
	func (d TreeDragSource) DragDataDelete(path *TreePath) bool {
var _arg0 *C.GtkTreeDragSource // out
var _arg1 *C.GtkTreePath // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeDragSource)(unsafe.Pointer(d.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

_cret = C.gtk_tree_drag_source_drag_data_delete(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// DragDataGet asks the TreeDragSource to fill in @selection_data with a
// representation of the row at @path. @selection_data->target gives the
// required type of the data. Should robustly handle a @path no longer found in
// the model!
	func (d TreeDragSource) DragDataGet(path *TreePath, selectionData *SelectionData) bool {
var _arg0 *C.GtkTreeDragSource // out
var _arg1 *C.GtkTreePath // out
var _arg2 *C.GtkSelectionData // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeDragSource)(unsafe.Pointer(d.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
_arg2 = (*C.GtkSelectionData)(unsafe.Pointer(selectionData.Native()))

_cret = C.gtk_tree_drag_source_drag_data_get(_arg0, _arg1, _arg2)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// RowDraggable asks the TreeDragSource whether a particular row can be used as
// the source of a DND operation. If the source doesn’t implement this
// interface, the row is assumed draggable.
	func (d TreeDragSource) RowDraggable(path *TreePath) bool {
var _arg0 *C.GtkTreeDragSource // out
var _arg1 *C.GtkTreePath // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeDragSource)(unsafe.Pointer(d.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

_cret = C.gtk_tree_drag_source_row_draggable(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	


	
	// TreeModelInterface contains virtual methods for TreeModel, or
	// methods that can be overridden.
	type TreeModelInterface interface {
		gextras.Objector

			// ColumnType returns the type of the column.
		ColumnType(index_ int) externglib.Type
			// Flags returns a set of flags supported by this interface.
	// 
	// The flags are a bitwise combination of TreeModelFlags. The flags
	// supported should not change during the lifetime of the @tree_model.
		Flags() TreeModelFlags
			// Iter sets @iter to a valid iterator pointing to @path. If @path does not
	// exist, @iter is set to an invalid iterator and false is returned.
		Iter(path *TreePath) (TreeIter, bool)
			// NColumns returns the number of columns supported by @tree_model.
		NColumns() int
			// Path returns a newly-created TreePath-struct referenced by @iter.
	// 
	// This path should be freed with gtk_tree_path_free().
		Path(iter *TreeIter) *TreePath
			// Value initializes and sets @value to that at @column.
	// 
	// When done with @value, g_value_unset() needs to be called to free any
	// allocated memory.
		Value(iter *TreeIter, column int) *externglib.Value
			// IterChildren sets @iter to point to the first child of @parent.
	// 
	// If @parent has no children, false is returned and @iter is set to be
	// invalid. @parent will remain a valid node after this function has been
	// called.
	// 
	// If @parent is nil returns the first node, equivalent to
	// `gtk_tree_model_get_iter_first (tree_model, iter);`
		IterChildren(parent *TreeIter) (TreeIter, bool)
			// IterHasChild returns true if @iter has children, false otherwise.
		IterHasChild(iter *TreeIter) bool
			// IterNChildren returns the number of children that @iter has.
	// 
	// As a special case, if @iter is nil, then the number of toplevel nodes is
	// returned.
		IterNChildren(iter *TreeIter) int
			// IterNext sets @iter to point to the node following it at the current
	// level.
	// 
	// If there is no next @iter, false is returned and @iter is set to be
	// invalid.
		IterNext(iter *TreeIter) bool
			// IterNthChild sets @iter to be the child of @parent, using the given
	// index.
	// 
	// The first index is 0. If @n is too big, or @parent has no children, @iter
	// is set to an invalid iterator and false is returned. @parent will remain
	// a valid node after this function has been called. As a special case, if
	// @parent is nil, then the @n-th root node is set.
		IterNthChild(parent *TreeIter, n int) (TreeIter, bool)
			// IterParent sets @iter to be the parent of @child.
	// 
	// If @child is at the toplevel, and doesn’t have a parent, then @iter is
	// set to an invalid iterator and false is returned. @child will remain a
	// valid node after this function has been called.
	// 
	// @iter will be initialized before the lookup is performed, so @child and
	// @iter cannot point to the same memory location.
		IterParent(child *TreeIter) (TreeIter, bool)
			// IterPrevious sets @iter to point to the previous node at the current
	// level.
	// 
	// If there is no previous @iter, false is returned and @iter is set to be
	// invalid.
		IterPrevious(iter *TreeIter) bool
			// RefNode lets the tree ref the node.
	// 
	// This is an optional method for models to implement. To be more specific,
	// models may ignore this call as it exists primarily for performance
	// reasons.
	// 
	// This function is primarily meant as a way for views to let caching models
	// know when nodes are being displayed (and hence, whether or not to cache
	// that node). Being displayed means a node is in an expanded branch,
	// regardless of whether the node is currently visible in the viewport. For
	// example, a file-system based model would not want to keep the entire
	// file-hierarchy in memory, just the sections that are currently being
	// displayed by every current view.
	// 
	// A model should be expected to be able to get an iter independent of its
	// reffed state.
		RefNode(iter *TreeIter) 
			// RowChanged emits the TreeModel::row-changed signal on @tree_model.
		RowChanged(path *TreePath, iter *TreeIter) 
			// RowDeleted emits the TreeModel::row-deleted signal on @tree_model.
	// 
	// This should be called by models after a row has been removed. The
	// location pointed to by @path should be the location that the row
	// previously was at. It may not be a valid location anymore.
	// 
	// Nodes that are deleted are not unreffed, this means that any outstanding
	// references on the deleted node should not be released.
		RowDeleted(path *TreePath) 
			// RowHasChildToggled emits the TreeModel::row-has-child-toggled signal on
	// @tree_model. This should be called by models after the child state of a
	// node changes.
		RowHasChildToggled(path *TreePath, iter *TreeIter) 
			// RowInserted emits the TreeModel::row-inserted signal on @tree_model.
		RowInserted(path *TreePath, iter *TreeIter) 
			// UnrefNode lets the tree unref the node.
	// 
	// This is an optional method for models to implement. To be more specific,
	// models may ignore this call as it exists primarily for performance
	// reasons. For more information on what this means, see
	// gtk_tree_model_ref_node().
	// 
	// Please note that nodes that are deleted are not unreffed.
		UnrefNode(iter *TreeIter) 
		
	}
	

	// TreeModel: the TreeModel interface defines a generic tree interface for use
// by the TreeView widget. It is an abstract interface, and is designed to be
// usable with any appropriate data structure. The programmer just has to
// implement this interface on their own data type for it to be viewable by a
// TreeView widget.
// 
// The model is represented as a hierarchical tree of strongly-typed, columned
// data. In other words, the model can be seen as a tree where every node has
// different values depending on which column is being queried. The type of data
// found in a column is determined by using the GType system (ie. TYPE_INT,
// K_TYPE_BUTTON, TYPE_POINTER, etc). The types are homogeneous per column
// across all nodes. It is important to note that this interface only provides a
// way of examining a model and observing changes. The implementation of each
// individual model decides how and if changes are made.
// 
// In order to make life simpler for programmers who do not need to write their
// own specialized model, two generic models are provided — the TreeStore and
// the ListStore. To use these, the developer simply pushes data into these
// models as necessary. These models provide the data structure as well as all
// appropriate tree interfaces. As a result, implementing drag and drop,
// sorting, and storing data is trivial. For the vast majority of trees and
// lists, these two models are sufficient.
// 
// Models are accessed on a node/column level of granularity. One can query for
// the value of a model at a certain node and a certain column on that node.
// There are two structures used to reference a particular node in a model. They
// are the TreePath-struct and the TreeIter-struct (“iter” is short for
// iterator). Most of the interface consists of operations on a TreeIter-struct.
// 
// A path is essentially a potential node. It is a location on a model that may
// or may not actually correspond to a node on a specific model. The
// TreePath-struct can be converted into either an array of unsigned integers or
// a string. The string form is a list of numbers separated by a colon. Each
// number refers to the offset at that level. Thus, the path `0` refers to the
// root node and the path `2:4` refers to the fifth child of the third node.
// 
// By contrast, a TreeIter-struct is a reference to a specific node on a
// specific model. It is a generic struct with an integer and three generic
// pointers. These are filled in by the model in a model-specific way. One can
// convert a path to an iterator by calling gtk_tree_model_get_iter(). These
// iterators are the primary way of accessing a model and are similar to the
// iterators used by TextBuffer. They are generally statically allocated on the
// stack and only used for a short time. The model interface defines a set of
// operations using them for navigating the model.
// 
// It is expected that models fill in the iterator with private data. For
// example, the ListStore model, which is internally a simple linked list,
// stores a list node in one of the pointers. The TreeModelSort stores an array
// and an offset in two of the pointers. Additionally, there is an integer
// field. This field is generally filled with a unique stamp per model. This
// stamp is for catching errors resulting from using invalid iterators with a
// model.
// 
// The lifecycle of an iterator can be a little confusing at first. Iterators
// are expected to always be valid for as long as the model is unchanged (and
// doesn’t emit a signal). The model is considered to own all outstanding
// iterators and nothing needs to be done to free them from the user’s point of
// view. Additionally, some models guarantee that an iterator is valid for as
// long as the node it refers to is valid (most notably the TreeStore and
// ListStore). Although generally uninteresting, as one always has to allow for
// the case where iterators do not persist beyond a signal, some very important
// performance enhancements were made in the sort model. As a result, the
// K_TREE_MODEL_ITERS_PERSIST flag was added to indicate this behavior.
// 
// To help show some common operation of a model, some examples are provided.
// The first example shows three ways of getting the iter at the location
// `3:2:5`. While the first method shown is easier, the second is much more
// common, as you often get paths from callbacks.
// 
// Acquiring a TreeIter-struct
// 
//    enum
//    {
//      STRING_COLUMN,
//      INT_COLUMN,
//      N_COLUMNS
//    };
// 
//    ...
// 
//    GtkTreeModel *list_store;
//    GtkTreeIter iter;
//    gboolean valid;
//    gint row_count = 0;
// 
//    // make a new list_store
//    list_store = gtk_list_store_new (N_COLUMNS,
//                                     G_TYPE_STRING,
//                                     G_TYPE_INT);
// 
//    // Fill the list store with data
//    populate_model (list_store);
// 
//    // Get the first iter in the list, check it is valid and walk
//    // through the list, reading each row.
// 
//    valid = gtk_tree_model_get_iter_first (list_store,
//                                           &iter);
//    while (valid)
//     {
//       gchar *str_data;
//       gint   int_data;
// 
//       // Make sure you terminate calls to gtk_tree_model_get() with a “-1” value
//       gtk_tree_model_get (list_store, &iter,
//                           STRING_COLUMN, &str_data,
//                           INT_COLUMN, &int_data,
//                           -1);
// 
//       // Do something with the data
//       g_print ("Row d: (s,d)\n",
//                row_count, str_data, int_data);
//       g_free (str_data);
// 
//       valid = gtk_tree_model_iter_next (list_store,
//                                         &iter);
//       row_count++;
//     }
// 
// The TreeModel interface contains two methods for reference counting:
// gtk_tree_model_ref_node() and gtk_tree_model_unref_node(). These two methods
// are optional to implement. The reference counting is meant as a way for views
// to let models know when nodes are being displayed. TreeView will take a
// reference on a node when it is visible, which means the node is either in the
// toplevel or expanded. Being displayed does not mean that the node is
// currently directly visible to the user in the viewport. Based on this
// reference counting scheme a caching model, for example, can decide whether or
// not to cache a node based on the reference count. A file-system based model
// would not want to keep the entire file hierarchy in memory, but just the
// folders that are currently expanded in every current view.
// 
// When working with reference counting, the following rules must be taken into
// account:
// 
// - Never take a reference on a node without owning a reference on its parent.
// This means that all parent nodes of a referenced node must be referenced as
// well.
// 
// - Outstanding references on a deleted node are not released. This is not
// possible because the node has already been deleted by the time the
// row-deleted signal is received.
// 
// - Models are not obligated to emit a signal on rows of which none of its
// siblings are referenced. To phrase this differently, signals are only
// required for levels in which nodes are referenced. For the root level
// however, signals must be emitted at all times (however the root level is
// always referenced when any view is attached).
	type TreeModel struct {
		**externglib.Object
		
	}

	
	func marshalTreeModel(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return {TreeModel{
Object: &externglib.Object{externglib.ToGObject(obj)},
} map[github.com/gotk3/gotk3/glib:externglib]}, nil
	}
	

	
	// NewFilter creates a new TreeModel, with @child_model as the child_model and
// @root as the virtual root.
	func (c TreeModel) NewFilter(root *TreePath) TreeModel {
var _arg0 *C.GtkTreeModel // out
var _arg1 *C.GtkTreePath // out
var _cret *C.GtkTreeModel // in

_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(root.Native()))

_cret = C.gtk_tree_model_filter_new(_arg0, _arg1)


var _treeModel TreeModel // out

_treeModel = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(TreeModel)

return _treeModel
}
	
	// ColumnType returns the type of the column.
	func (t TreeModel) ColumnType(index_ int) externglib.Type {
var _arg0 *C.GtkTreeModel // out
var _arg1 C.gint // out
var _cret C.GType // in

_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
_arg1 = (C.gint)(index_)

_cret = C.gtk_tree_model_get_column_type(_arg0, _arg1)


var _gType externglib.Type // out

_gType = externglib.Type(_cret)

return _gType
}
	
	// Flags returns a set of flags supported by this interface.
// 
// The flags are a bitwise combination of TreeModelFlags. The flags supported
// should not change during the lifetime of the @tree_model.
	func (t TreeModel) Flags() TreeModelFlags {
var _arg0 *C.GtkTreeModel // out
var _cret C.GtkTreeModelFlags // in

_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_model_get_flags(_arg0)


var _treeModelFlags TreeModelFlags // out

_treeModelFlags = TreeModelFlags(_cret)

return _treeModelFlags
}
	
	// Iter sets @iter to a valid iterator pointing to @path. If @path does not
// exist, @iter is set to an invalid iterator and false is returned.
	func (t TreeModel) Iter(path *TreePath) (TreeIter, bool) {
var _arg0 *C.GtkTreeModel // out
var _iter TreeIter
var _arg2 *C.GtkTreePath // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
_arg2 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

_cret = C.gtk_tree_model_get_iter(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_iter)), _arg2)



var _ok bool // out


if _cret != 0 { _ok = true }

return _iter, _ok
}
	
	// IterFirst initializes @iter with the first iterator in the tree (the one at
// the path "0") and returns true. Returns false if the tree is empty.
	func (t TreeModel) IterFirst() (TreeIter, bool) {
var _arg0 *C.GtkTreeModel // out
var _iter TreeIter
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_model_get_iter_first(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_iter)))



var _ok bool // out


if _cret != 0 { _ok = true }

return _iter, _ok
}
	
	// IterFromString sets @iter to a valid iterator pointing to @path_string, if it
// exists. Otherwise, @iter is left invalid and false is returned.
	func (t TreeModel) IterFromString(pathString string) (TreeIter, bool) {
var _arg0 *C.GtkTreeModel // out
var _iter TreeIter
var _arg2 *C.gchar // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
_arg2 = (*C.gchar)(C.CString(pathString))
defer C.free(unsafe.Pointer(_arg2))

_cret = C.gtk_tree_model_get_iter_from_string(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_iter)), _arg2)



var _ok bool // out


if _cret != 0 { _ok = true }

return _iter, _ok
}
	
	// NColumns returns the number of columns supported by @tree_model.
	func (t TreeModel) NColumns() int {
var _arg0 *C.GtkTreeModel // out
var _cret C.gint // in

_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_model_get_n_columns(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Path returns a newly-created TreePath-struct referenced by @iter.
// 
// This path should be freed with gtk_tree_path_free().
	func (t TreeModel) Path(iter *TreeIter) *TreePath {
var _arg0 *C.GtkTreeModel // out
var _arg1 *C.GtkTreeIter // out
var _cret *C.GtkTreePath // in

_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

_cret = C.gtk_tree_model_get_path(_arg0, _arg1)


var _treePath *TreePath // out

_treePath = *(**TreePath)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_treePath, func(v *TreePath) {
  C.free(unsafe.Pointer(v.Native()))
})

return _treePath
}
	
	// StringFromIter generates a string representation of the iter.
// 
// This string is a “:” separated list of numbers. For example, “4:10:0:3” would
// be an acceptable return value for this string.
	func (t TreeModel) StringFromIter(iter *TreeIter) string {
var _arg0 *C.GtkTreeModel // out
var _arg1 *C.GtkTreeIter // out
var _cret *C.gchar // in

_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

_cret = C.gtk_tree_model_get_string_from_iter(_arg0, _arg1)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// Value initializes and sets @value to that at @column.
// 
// When done with @value, g_value_unset() needs to be called to free any
// allocated memory.
	func (t TreeModel) Value(iter *TreeIter, column int) *externglib.Value {
var _arg0 *C.GtkTreeModel // out
var _arg1 *C.GtkTreeIter // out
var _arg2 C.gint // out
var _arg3 C.GValue // in

_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))
_arg2 = (C.gint)(column)

C.gtk_tree_model_get_value(_arg0, _arg1, _arg2, &_arg3)

var _value *externglib.Value // out

_value = externglib.ValueFromNative(unsafe.Pointer(_arg3))

return _value
}
	
	// IterChildren sets @iter to point to the first child of @parent.
// 
// If @parent has no children, false is returned and @iter is set to be invalid.
// @parent will remain a valid node after this function has been called.
// 
// If @parent is nil returns the first node, equivalent to
// `gtk_tree_model_get_iter_first (tree_model, iter);`
	func (t TreeModel) IterChildren(parent *TreeIter) (TreeIter, bool) {
var _arg0 *C.GtkTreeModel // out
var _iter TreeIter
var _arg2 *C.GtkTreeIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(parent.Native()))

_cret = C.gtk_tree_model_iter_children(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_iter)), _arg2)



var _ok bool // out


if _cret != 0 { _ok = true }

return _iter, _ok
}
	
	// IterHasChild returns true if @iter has children, false otherwise.
	func (t TreeModel) IterHasChild(iter *TreeIter) bool {
var _arg0 *C.GtkTreeModel // out
var _arg1 *C.GtkTreeIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

_cret = C.gtk_tree_model_iter_has_child(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IterNChildren returns the number of children that @iter has.
// 
// As a special case, if @iter is nil, then the number of toplevel nodes is
// returned.
	func (t TreeModel) IterNChildren(iter *TreeIter) int {
var _arg0 *C.GtkTreeModel // out
var _arg1 *C.GtkTreeIter // out
var _cret C.gint // in

_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

_cret = C.gtk_tree_model_iter_n_children(_arg0, _arg1)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// IterNext sets @iter to point to the node following it at the current level.
// 
// If there is no next @iter, false is returned and @iter is set to be invalid.
	func (t TreeModel) IterNext(iter *TreeIter) bool {
var _arg0 *C.GtkTreeModel // out
var _arg1 *C.GtkTreeIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

_cret = C.gtk_tree_model_iter_next(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IterNthChild sets @iter to be the child of @parent, using the given index.
// 
// The first index is 0. If @n is too big, or @parent has no children, @iter is
// set to an invalid iterator and false is returned. @parent will remain a valid
// node after this function has been called. As a special case, if @parent is
// nil, then the @n-th root node is set.
	func (t TreeModel) IterNthChild(parent *TreeIter, n int) (TreeIter, bool) {
var _arg0 *C.GtkTreeModel // out
var _iter TreeIter
var _arg2 *C.GtkTreeIter // out
var _arg3 C.gint // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(parent.Native()))
_arg3 = (C.gint)(n)

_cret = C.gtk_tree_model_iter_nth_child(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_iter)), _arg2, _arg3)



var _ok bool // out


if _cret != 0 { _ok = true }

return _iter, _ok
}
	
	// IterParent sets @iter to be the parent of @child.
// 
// If @child is at the toplevel, and doesn’t have a parent, then @iter is set to
// an invalid iterator and false is returned. @child will remain a valid node
// after this function has been called.
// 
// @iter will be initialized before the lookup is performed, so @child and @iter
// cannot point to the same memory location.
	func (t TreeModel) IterParent(child *TreeIter) (TreeIter, bool) {
var _arg0 *C.GtkTreeModel // out
var _iter TreeIter
var _arg2 *C.GtkTreeIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(child.Native()))

_cret = C.gtk_tree_model_iter_parent(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_iter)), _arg2)



var _ok bool // out


if _cret != 0 { _ok = true }

return _iter, _ok
}
	
	// IterPrevious sets @iter to point to the previous node at the current level.
// 
// If there is no previous @iter, false is returned and @iter is set to be
// invalid.
	func (t TreeModel) IterPrevious(iter *TreeIter) bool {
var _arg0 *C.GtkTreeModel // out
var _arg1 *C.GtkTreeIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

_cret = C.gtk_tree_model_iter_previous(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// RefNode lets the tree ref the node.
// 
// This is an optional method for models to implement. To be more specific,
// models may ignore this call as it exists primarily for performance reasons.
// 
// This function is primarily meant as a way for views to let caching models
// know when nodes are being displayed (and hence, whether or not to cache that
// node). Being displayed means a node is in an expanded branch, regardless of
// whether the node is currently visible in the viewport. For example, a
// file-system based model would not want to keep the entire file-hierarchy in
// memory, just the sections that are currently being displayed by every current
// view.
// 
// A model should be expected to be able to get an iter independent of its
// reffed state.
	func (t TreeModel) RefNode(iter *TreeIter)  {
var _arg0 *C.GtkTreeModel // out
var _arg1 *C.GtkTreeIter // out

_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

C.gtk_tree_model_ref_node(_arg0, _arg1)
}
	
	// RowChanged emits the TreeModel::row-changed signal on @tree_model.
	func (t TreeModel) RowChanged(path *TreePath, iter *TreeIter)  {
var _arg0 *C.GtkTreeModel // out
var _arg1 *C.GtkTreePath // out
var _arg2 *C.GtkTreeIter // out

_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

C.gtk_tree_model_row_changed(_arg0, _arg1, _arg2)
}
	
	// RowDeleted emits the TreeModel::row-deleted signal on @tree_model.
// 
// This should be called by models after a row has been removed. The location
// pointed to by @path should be the location that the row previously was at. It
// may not be a valid location anymore.
// 
// Nodes that are deleted are not unreffed, this means that any outstanding
// references on the deleted node should not be released.
	func (t TreeModel) RowDeleted(path *TreePath)  {
var _arg0 *C.GtkTreeModel // out
var _arg1 *C.GtkTreePath // out

_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

C.gtk_tree_model_row_deleted(_arg0, _arg1)
}
	
	// RowHasChildToggled emits the TreeModel::row-has-child-toggled signal on
// @tree_model. This should be called by models after the child state of a node
// changes.
	func (t TreeModel) RowHasChildToggled(path *TreePath, iter *TreeIter)  {
var _arg0 *C.GtkTreeModel // out
var _arg1 *C.GtkTreePath // out
var _arg2 *C.GtkTreeIter // out

_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

C.gtk_tree_model_row_has_child_toggled(_arg0, _arg1, _arg2)
}
	
	// RowInserted emits the TreeModel::row-inserted signal on @tree_model.
	func (t TreeModel) RowInserted(path *TreePath, iter *TreeIter)  {
var _arg0 *C.GtkTreeModel // out
var _arg1 *C.GtkTreePath // out
var _arg2 *C.GtkTreeIter // out

_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

C.gtk_tree_model_row_inserted(_arg0, _arg1, _arg2)
}
	
	// RowsReorderedWithLength emits the TreeModel::rows-reordered signal on
// @tree_model.
// 
// This should be called by models when their rows have been reordered.
	func (t TreeModel) RowsReorderedWithLength(path *TreePath, iter *TreeIter, newOrder []int)  {
var _arg0 *C.GtkTreeModel // out
var _arg1 *C.GtkTreePath // out
var _arg2 *C.GtkTreeIter // out
var _arg3 *C.gint
var _arg4 C.gint

_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))
_arg4 = C.gint(len(newOrder))
_arg3 = (*C.gint)(unsafe.Pointer(&newOrder[0]))

C.gtk_tree_model_rows_reordered_with_length(_arg0, _arg1, _arg2, _arg3, _arg4)
}
	
	// UnrefNode lets the tree unref the node.
// 
// This is an optional method for models to implement. To be more specific,
// models may ignore this call as it exists primarily for performance reasons.
// For more information on what this means, see gtk_tree_model_ref_node().
// 
// Please note that nodes that are deleted are not unreffed.
	func (t TreeModel) UnrefNode(iter *TreeIter)  {
var _arg0 *C.GtkTreeModel // out
var _arg1 *C.GtkTreeIter // out

_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

C.gtk_tree_model_unref_node(_arg0, _arg1)
}
	


	
	// TreeSortableInterface contains virtual methods for TreeSortable, or
	// methods that can be overridden.
	type TreeSortableInterface interface {
		gextras.Objector

			// SortColumnID fills in @sort_column_id and @order with the current sort
	// column and the order. It returns true unless the @sort_column_id is
	// GTK_TREE_SORTABLE_DEFAULT_SORT_COLUMN_ID or
	// GTK_TREE_SORTABLE_UNSORTED_SORT_COLUMN_ID.
		SortColumnID() (int, SortType, bool)
			// HasDefaultSortFunc returns true if the model has a default sort function.
	// This is used primarily by GtkTreeViewColumns in order to determine if a
	// model can go back to the default state, or not.
		HasDefaultSortFunc() bool
			// SetSortColumnID sets the current sort column to be @sort_column_id. The
	// @sortable will resort itself to reflect this change, after emitting a
	// TreeSortable::sort-column-changed signal. @sort_column_id may either be a
	// regular column id, or one of the following special values:
	// 
	// - GTK_TREE_SORTABLE_DEFAULT_SORT_COLUMN_ID: the default sort function
	// will be used, if it is set
	// 
	// - GTK_TREE_SORTABLE_UNSORTED_SORT_COLUMN_ID: no sorting will occur
		SetSortColumnID(sortColumnId int, order SortType) 
			// SortColumnChanged emits a TreeSortable::sort-column-changed signal on
	// @sortable.
		SortColumnChanged() 
		
	}
	

	// TreeSortable is an interface to be implemented by tree models which support
// sorting. The TreeView uses the methods provided by this interface to sort the
// model.
	type TreeSortable struct {
		TreeModel
		
	}

	
	func marshalTreeSortable(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return {TreeSortable{
TreeModel: TreeModel{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
} map[github.com/gotk3/gotk3/glib:externglib]}, nil
	}
	

	
	// SortColumnID fills in @sort_column_id and @order with the current sort column
// and the order. It returns true unless the @sort_column_id is
// GTK_TREE_SORTABLE_DEFAULT_SORT_COLUMN_ID or
// GTK_TREE_SORTABLE_UNSORTED_SORT_COLUMN_ID.
	func (s TreeSortable) SortColumnID() (int, SortType, bool) {
var _arg0 *C.GtkTreeSortable // out
var _arg1 C.gint // in
var _arg2 C.GtkSortType // in
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeSortable)(unsafe.Pointer(s.Native()))

_cret = C.gtk_tree_sortable_get_sort_column_id(_arg0, &_arg1, &_arg2)


var _sortColumnId int // out
var _order SortType // out
var _ok bool // out

_sortColumnId = (int)(_arg1)
_order = SortType(_arg2)
if _cret != 0 { _ok = true }

return _sortColumnId, _order, _ok
}
	
	// HasDefaultSortFunc returns true if the model has a default sort function.
// This is used primarily by GtkTreeViewColumns in order to determine if a model
// can go back to the default state, or not.
	func (s TreeSortable) HasDefaultSortFunc() bool {
var _arg0 *C.GtkTreeSortable // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeSortable)(unsafe.Pointer(s.Native()))

_cret = C.gtk_tree_sortable_has_default_sort_func(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetSortColumnID sets the current sort column to be @sort_column_id. The
// @sortable will resort itself to reflect this change, after emitting a
// TreeSortable::sort-column-changed signal. @sort_column_id may either be a
// regular column id, or one of the following special values:
// 
// - GTK_TREE_SORTABLE_DEFAULT_SORT_COLUMN_ID: the default sort function will be
// used, if it is set
// 
// - GTK_TREE_SORTABLE_UNSORTED_SORT_COLUMN_ID: no sorting will occur
	func (s TreeSortable) SetSortColumnID(sortColumnId int, order SortType)  {
var _arg0 *C.GtkTreeSortable // out
var _arg1 C.gint // out
var _arg2 C.GtkSortType // out

_arg0 = (*C.GtkTreeSortable)(unsafe.Pointer(s.Native()))
_arg1 = (C.gint)(sortColumnId)
_arg2 = (C.GtkSortType)(order)

C.gtk_tree_sortable_set_sort_column_id(_arg0, _arg1, _arg2)
}
	
	// SortColumnChanged emits a TreeSortable::sort-column-changed signal on
// @sortable.
	func (s TreeSortable) SortColumnChanged()  {
var _arg0 *C.GtkTreeSortable // out

_arg0 = (*C.GtkTreeSortable)(unsafe.Pointer(s.Native()))

C.gtk_tree_sortable_sort_column_changed(_arg0)
}
	


	// AboutDialog: the GtkAboutDialog offers a simple way to display information
// about a program like its logo, name, copyright, website and license. It is
// also possible to give credits to the authors, documenters, translators and
// artists who have worked on the program. An about dialog is typically opened
// when the user selects the `About` option from the `Help` menu. All parts of
// the dialog are optional.
// 
// About dialogs often contain links and email addresses. GtkAboutDialog
// displays these as clickable links. By default, it calls
// gtk_show_uri_on_window() when a user clicks one. The behaviour can be
// overridden with the AboutDialog::activate-link signal.
// 
// To specify a person with an email address, use a string like "Edgar Allan Poe
// <edgar\@poe.com>". To specify a website with a title, use a string like "GTK+
// team http://www.gtk.org".
// 
// To make constructing a GtkAboutDialog as convenient as possible, you can use
// the function gtk_show_about_dialog() which constructs and shows a dialog and
// keeps it around so that it can be shown again.
// 
// Note that GTK+ sets a default title of `_("About s")` on the dialog window
// (where \s is replaced by the name of the application, but in order to ensure
// proper translation of the title, applications should set the title property
// explicitly when constructing a GtkAboutDialog, as shown in the following
// example:
// 
//    GdkPixbuf *example_logo = gdk_pixbuf_new_from_file ("./logo.png", NULL);
//    gtk_show_about_dialog (NULL,
//                           "program-name", "ExampleCode",
//                           "logo", example_logo,
//                           "title", _("About ExampleCode"),
//                           NULL);
// 
// It is also possible to show a AboutDialog like any other Dialog, e.g. using
// gtk_dialog_run(). In this case, you might need to know that the “Close”
// button returns the K_RESPONSE_CANCEL response id.
	type AboutDialog struct {
		Dialog
		Buildable
		
	}

	// AboutDialogClass is an interface that the AboutDialog class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type AboutDialogClass interface {
		gextras.Objector
		_aboutDialog()
	}

	func (AboutDialog) _aboutDialog() {}

	
	func marshalAboutDialog(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapAboutDialog(obj), nil
	}
	

	
	// NewAboutDialog creates a new AboutDialog.
	func NewAboutDialog() AboutDialog {
var _cret *C.GtkWidget // in

_cret = C.gtk_about_dialog_new()


var _aboutDialog AboutDialog // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_aboutDialog = AboutDialog{
Dialog: Dialog{
Window: Window{
Bin: Bin{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _aboutDialog
}
	

	
	// AddCreditSection creates a new section in the Credits page.
	func (a AboutDialog) AddCreditSection(sectionName string, people []string)  {
var _arg0 *C.GtkAboutDialog // out
var _arg1 *C.gchar // out
var _arg2 **C.gchar

_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
_arg1 = (*C.gchar)(C.CString(sectionName))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (**C.gchar)(C.malloc(C.ulong(len(people)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
defer C.free(unsafe.Pointer(_arg2))
{
out := unsafe.Slice(_arg2, len(people))
for i := range people {
out[i] = (*C.gchar)(C.CString(people[i]))
defer C.free(unsafe.Pointer(out[i]))
}
}

C.gtk_about_dialog_add_credit_section(_arg0, _arg1, _arg2)
}
	
	// Artists returns the string which are displayed in the artists tab of the
// secondary credits dialog.
	func (a AboutDialog) Artists() []string {
var _arg0 *C.GtkAboutDialog // out
var _cret **C.gchar

_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

_cret = C.gtk_about_dialog_get_artists(_arg0)


var _utf8s []string

{
var i int
var z *C.gchar
for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
  i++
}

src := unsafe.Slice(_cret, i)
_utf8s = make([]string, i)
for i := range src {
_utf8s[i] = C.GoString(src[i])
}
}

return _utf8s
}
	
	// Authors returns the string which are displayed in the authors tab of the
// secondary credits dialog.
	func (a AboutDialog) Authors() []string {
var _arg0 *C.GtkAboutDialog // out
var _cret **C.gchar

_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

_cret = C.gtk_about_dialog_get_authors(_arg0)


var _utf8s []string

{
var i int
var z *C.gchar
for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
  i++
}

src := unsafe.Slice(_cret, i)
_utf8s = make([]string, i)
for i := range src {
_utf8s[i] = C.GoString(src[i])
}
}

return _utf8s
}
	
	// Comments returns the comments string.
	func (a AboutDialog) Comments() string {
var _arg0 *C.GtkAboutDialog // out
var _cret *C.gchar // in

_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

_cret = C.gtk_about_dialog_get_comments(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Copyright returns the copyright string.
	func (a AboutDialog) Copyright() string {
var _arg0 *C.GtkAboutDialog // out
var _cret *C.gchar // in

_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

_cret = C.gtk_about_dialog_get_copyright(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Documenters returns the string which are displayed in the documenters tab of
// the secondary credits dialog.
	func (a AboutDialog) Documenters() []string {
var _arg0 *C.GtkAboutDialog // out
var _cret **C.gchar

_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

_cret = C.gtk_about_dialog_get_documenters(_arg0)


var _utf8s []string

{
var i int
var z *C.gchar
for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
  i++
}

src := unsafe.Slice(_cret, i)
_utf8s = make([]string, i)
for i := range src {
_utf8s[i] = C.GoString(src[i])
}
}

return _utf8s
}
	
	// License returns the license information.
	func (a AboutDialog) License() string {
var _arg0 *C.GtkAboutDialog // out
var _cret *C.gchar // in

_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

_cret = C.gtk_about_dialog_get_license(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// LicenseType retrieves the license set using
// gtk_about_dialog_set_license_type()
	func (a AboutDialog) LicenseType() License {
var _arg0 *C.GtkAboutDialog // out
var _cret C.GtkLicense // in

_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

_cret = C.gtk_about_dialog_get_license_type(_arg0)


var _license License // out

_license = License(_cret)

return _license
}
	
	// Logo returns the pixbuf displayed as logo in the about dialog.
	func (a AboutDialog) Logo() gdkpixbuf.Pixbuf {
var _arg0 *C.GtkAboutDialog // out
var _cret *C.GdkPixbuf // in

_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

_cret = C.gtk_about_dialog_get_logo(_arg0)


var _pixbuf gdkpixbuf.Pixbuf // out

_pixbuf = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdkpixbuf.Pixbuf)

return _pixbuf
}
	
	// LogoIconName returns the icon name displayed as logo in the about dialog.
	func (a AboutDialog) LogoIconName() string {
var _arg0 *C.GtkAboutDialog // out
var _cret *C.gchar // in

_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

_cret = C.gtk_about_dialog_get_logo_icon_name(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// ProgramName returns the program name displayed in the about dialog.
	func (a AboutDialog) ProgramName() string {
var _arg0 *C.GtkAboutDialog // out
var _cret *C.gchar // in

_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

_cret = C.gtk_about_dialog_get_program_name(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// TranslatorCredits returns the translator credits string which is displayed in
// the translators tab of the secondary credits dialog.
	func (a AboutDialog) TranslatorCredits() string {
var _arg0 *C.GtkAboutDialog // out
var _cret *C.gchar // in

_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

_cret = C.gtk_about_dialog_get_translator_credits(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Version returns the version string.
	func (a AboutDialog) Version() string {
var _arg0 *C.GtkAboutDialog // out
var _cret *C.gchar // in

_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

_cret = C.gtk_about_dialog_get_version(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Website returns the website URL.
	func (a AboutDialog) Website() string {
var _arg0 *C.GtkAboutDialog // out
var _cret *C.gchar // in

_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

_cret = C.gtk_about_dialog_get_website(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// WebsiteLabel returns the label used for the website link.
	func (a AboutDialog) WebsiteLabel() string {
var _arg0 *C.GtkAboutDialog // out
var _cret *C.gchar // in

_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

_cret = C.gtk_about_dialog_get_website_label(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// WrapLicense returns whether the license text in @about is automatically
// wrapped.
	func (a AboutDialog) WrapLicense() bool {
var _arg0 *C.GtkAboutDialog // out
var _cret C.gboolean // in

_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

_cret = C.gtk_about_dialog_get_wrap_license(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetArtists sets the strings which are displayed in the artists tab of the
// secondary credits dialog.
	func (a AboutDialog) SetArtists(artists []string)  {
var _arg0 *C.GtkAboutDialog // out
var _arg1 **C.gchar

_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
_arg1 = (**C.gchar)(C.malloc(C.ulong(len(artists)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
defer C.free(unsafe.Pointer(_arg1))
{
out := unsafe.Slice(_arg1, len(artists))
for i := range artists {
out[i] = (*C.gchar)(C.CString(artists[i]))
defer C.free(unsafe.Pointer(out[i]))
}
}

C.gtk_about_dialog_set_artists(_arg0, _arg1)
}
	
	// SetAuthors sets the strings which are displayed in the authors tab of the
// secondary credits dialog.
	func (a AboutDialog) SetAuthors(authors []string)  {
var _arg0 *C.GtkAboutDialog // out
var _arg1 **C.gchar

_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
_arg1 = (**C.gchar)(C.malloc(C.ulong(len(authors)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
defer C.free(unsafe.Pointer(_arg1))
{
out := unsafe.Slice(_arg1, len(authors))
for i := range authors {
out[i] = (*C.gchar)(C.CString(authors[i]))
defer C.free(unsafe.Pointer(out[i]))
}
}

C.gtk_about_dialog_set_authors(_arg0, _arg1)
}
	
	// SetComments sets the comments string to display in the about dialog. This
// should be a short string of one or two lines.
	func (a AboutDialog) SetComments(comments string)  {
var _arg0 *C.GtkAboutDialog // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
_arg1 = (*C.gchar)(C.CString(comments))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_about_dialog_set_comments(_arg0, _arg1)
}
	
	// SetCopyright sets the copyright string to display in the about dialog. This
// should be a short string of one or two lines.
	func (a AboutDialog) SetCopyright(copyright string)  {
var _arg0 *C.GtkAboutDialog // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
_arg1 = (*C.gchar)(C.CString(copyright))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_about_dialog_set_copyright(_arg0, _arg1)
}
	
	// SetDocumenters sets the strings which are displayed in the documenters tab of
// the secondary credits dialog.
	func (a AboutDialog) SetDocumenters(documenters []string)  {
var _arg0 *C.GtkAboutDialog // out
var _arg1 **C.gchar

_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
_arg1 = (**C.gchar)(C.malloc(C.ulong(len(documenters)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
defer C.free(unsafe.Pointer(_arg1))
{
out := unsafe.Slice(_arg1, len(documenters))
for i := range documenters {
out[i] = (*C.gchar)(C.CString(documenters[i]))
defer C.free(unsafe.Pointer(out[i]))
}
}

C.gtk_about_dialog_set_documenters(_arg0, _arg1)
}
	
	// SetLicense sets the license information to be displayed in the secondary
// license dialog. If @license is nil, the license button is hidden.
	func (a AboutDialog) SetLicense(license string)  {
var _arg0 *C.GtkAboutDialog // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
_arg1 = (*C.gchar)(C.CString(license))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_about_dialog_set_license(_arg0, _arg1)
}
	
	// SetLicenseType sets the license of the application showing the @about dialog
// from a list of known licenses.
// 
// This function overrides the license set using gtk_about_dialog_set_license().
	func (a AboutDialog) SetLicenseType(licenseType License)  {
var _arg0 *C.GtkAboutDialog // out
var _arg1 C.GtkLicense // out

_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
_arg1 = (C.GtkLicense)(licenseType)

C.gtk_about_dialog_set_license_type(_arg0, _arg1)
}
	
	// SetLogo sets the pixbuf to be displayed as logo in the about dialog. If it is
// nil, the default window icon set with gtk_window_set_default_icon() will be
// used.
	func (a AboutDialog) SetLogo(logo gdkpixbuf.PixbufClass)  {
var _arg0 *C.GtkAboutDialog // out
var _arg1 *C.GdkPixbuf // out

_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GdkPixbuf)(unsafe.Pointer(logo.Native()))

C.gtk_about_dialog_set_logo(_arg0, _arg1)
}
	
	// SetLogoIconName sets the pixbuf to be displayed as logo in the about dialog.
// If it is nil, the default window icon set with gtk_window_set_default_icon()
// will be used.
	func (a AboutDialog) SetLogoIconName(iconName string)  {
var _arg0 *C.GtkAboutDialog // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
_arg1 = (*C.gchar)(C.CString(iconName))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_about_dialog_set_logo_icon_name(_arg0, _arg1)
}
	
	// SetProgramName sets the name to display in the about dialog. If this is not
// set, it defaults to g_get_application_name().
	func (a AboutDialog) SetProgramName(name string)  {
var _arg0 *C.GtkAboutDialog // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
_arg1 = (*C.gchar)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_about_dialog_set_program_name(_arg0, _arg1)
}
	
	// SetTranslatorCredits sets the translator credits string which is displayed in
// the translators tab of the secondary credits dialog.
// 
// The intended use for this string is to display the translator of the language
// which is currently used in the user interface. Using gettext(), a simple way
// to achieve that is to mark the string for translation:
// 
//    GtkWidget *about = gtk_about_dialog_new ();
//    gtk_about_dialog_set_translator_credits (GTK_ABOUT_DIALOG (about),
//                                             _("translator-credits"));
// 
// It is a good idea to use the customary msgid “translator-credits” for this
// purpose, since translators will already know the purpose of that msgid, and
// since AboutDialog will detect if “translator-credits” is untranslated and
// hide the tab.
	func (a AboutDialog) SetTranslatorCredits(translatorCredits string)  {
var _arg0 *C.GtkAboutDialog // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
_arg1 = (*C.gchar)(C.CString(translatorCredits))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_about_dialog_set_translator_credits(_arg0, _arg1)
}
	
	// SetVersion sets the version string to display in the about dialog.
	func (a AboutDialog) SetVersion(version string)  {
var _arg0 *C.GtkAboutDialog // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
_arg1 = (*C.gchar)(C.CString(version))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_about_dialog_set_version(_arg0, _arg1)
}
	
	// SetWebsite sets the URL to use for the website link.
	func (a AboutDialog) SetWebsite(website string)  {
var _arg0 *C.GtkAboutDialog // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
_arg1 = (*C.gchar)(C.CString(website))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_about_dialog_set_website(_arg0, _arg1)
}
	
	// SetWebsiteLabel sets the label to be used for the website link.
	func (a AboutDialog) SetWebsiteLabel(websiteLabel string)  {
var _arg0 *C.GtkAboutDialog // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
_arg1 = (*C.gchar)(C.CString(websiteLabel))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_about_dialog_set_website_label(_arg0, _arg1)
}
	
	// SetWrapLicense sets whether the license text in @about is automatically
// wrapped.
	func (a AboutDialog) SetWrapLicense(wrapLicense bool)  {
var _arg0 *C.GtkAboutDialog // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
if wrapLicense { _arg1 = C.TRUE }

C.gtk_about_dialog_set_wrap_license(_arg0, _arg1)
}
	


	// AccelGroup: a AccelGroup represents a group of keyboard accelerators,
// typically attached to a toplevel Window (with gtk_window_add_accel_group()).
// Usually you won’t need to create a AccelGroup directly; instead, when using
// UIManager, GTK+ automatically sets up the accelerators for your menus in the
// ui manager’s AccelGroup.
// 
// Note that “accelerators” are different from “mnemonics”. Accelerators are
// shortcuts for activating a menu item; they appear alongside the menu item
// they’re a shortcut for. For example “Ctrl+Q” might appear alongside the
// “Quit” menu item. Mnemonics are shortcuts for GUI elements such as text
// entries or buttons; they appear as underlined characters. See
// gtk_label_new_with_mnemonic(). Menu items can have both accelerators and
// mnemonics, of course.
	type AccelGroup struct {
		**externglib.Object
		
	}

	// AccelGroupClass is an interface that the AccelGroup class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type AccelGroupClass interface {
		gextras.Objector
		_accelGroup()
	}

	func (AccelGroup) _accelGroup() {}

	
	func marshalAccelGroup(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapAccelGroup(obj), nil
	}
	

	
	// NewAccelGroup creates a new AccelGroup.
	func NewAccelGroup() AccelGroup {
var _cret *C.GtkAccelGroup // in

_cret = C.gtk_accel_group_new()


var _accelGroup AccelGroup // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_accelGroup = AccelGroup{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}

return _accelGroup
}
	

	
	// DisconnectKey removes an accelerator previously installed through
// gtk_accel_group_connect().
	func (a AccelGroup) DisconnectKey(accelKey uint, accelMods gdk.ModifierType) bool {
var _arg0 *C.GtkAccelGroup // out
var _arg1 C.guint // out
var _arg2 C.GdkModifierType // out
var _cret C.gboolean // in

_arg0 = (*C.GtkAccelGroup)(unsafe.Pointer(a.Native()))
_arg1 = (C.guint)(accelKey)
_arg2 = (C.GdkModifierType)(accelMods)

_cret = C.gtk_accel_group_disconnect_key(_arg0, _arg1, _arg2)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsLocked locks are added and removed using gtk_accel_group_lock() and
// gtk_accel_group_unlock().
	func (a AccelGroup) IsLocked() bool {
var _arg0 *C.GtkAccelGroup // out
var _cret C.gboolean // in

_arg0 = (*C.GtkAccelGroup)(unsafe.Pointer(a.Native()))

_cret = C.gtk_accel_group_get_is_locked(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ModifierMask gets a ModifierType representing the mask for this @accel_group.
// For example, K_CONTROL_MASK, K_SHIFT_MASK, etc.
	func (a AccelGroup) ModifierMask() gdk.ModifierType {
var _arg0 *C.GtkAccelGroup // out
var _cret C.GdkModifierType // in

_arg0 = (*C.GtkAccelGroup)(unsafe.Pointer(a.Native()))

_cret = C.gtk_accel_group_get_modifier_mask(_arg0)


var _modifierType gdk.ModifierType // out

_modifierType = gdk.ModifierType(_cret)

return _modifierType
}
	
	// Lock locks the given accelerator group.
// 
// Locking an acelerator group prevents the accelerators contained within it to
// be changed during runtime. Refer to gtk_accel_map_change_entry() about
// runtime accelerator changes.
// 
// If called more than once, @accel_group remains locked until
// gtk_accel_group_unlock() has been called an equivalent number of times.
	func (a AccelGroup) Lock()  {
var _arg0 *C.GtkAccelGroup // out

_arg0 = (*C.GtkAccelGroup)(unsafe.Pointer(a.Native()))

C.gtk_accel_group_lock(_arg0)
}
	
	// Unlock undoes the last call to gtk_accel_group_lock() on this @accel_group.
	func (a AccelGroup) Unlock()  {
var _arg0 *C.GtkAccelGroup // out

_arg0 = (*C.GtkAccelGroup)(unsafe.Pointer(a.Native()))

C.gtk_accel_group_unlock(_arg0)
}
	


	// AccelLabel: the AccelLabel widget is a subclass of Label that also displays
// an accelerator key on the right of the label text, e.g. “Ctrl+S”. It is
// commonly used in menus to show the keyboard short-cuts for commands.
// 
// The accelerator key to display is typically not set explicitly (although it
// can be, with gtk_accel_label_set_accel()). Instead, the AccelLabel displays
// the accelerators which have been added to a particular widget. This widget is
// set by calling gtk_accel_label_set_accel_widget().
// 
// For example, a MenuItem widget may have an accelerator added to emit the
// “activate” signal when the “Ctrl+S” key combination is pressed. A AccelLabel
// is created and added to the MenuItem, and gtk_accel_label_set_accel_widget()
// is called with the MenuItem as the second argument. The AccelLabel will now
// display “Ctrl+S” after its label.
// 
// Note that creating a MenuItem with gtk_menu_item_new_with_label() (or one of
// the similar functions for CheckMenuItem and RadioMenuItem) automatically adds
// a AccelLabel to the MenuItem and calls gtk_accel_label_set_accel_widget() to
// set it up for you.
// 
// A AccelLabel will only display accelerators which have GTK_ACCEL_VISIBLE set
// (see AccelFlags). A AccelLabel can display multiple accelerators and even
// signal names, though it is almost always used to display just one accelerator
// key.
// 
// Creating a simple menu item with an accelerator key.
// 
//    label
//    ╰── accelerator
// 
// Like Label, GtkAccelLabel has a main CSS node with the name label. It adds a
// subnode with name accelerator.
	type AccelLabel struct {
		Label
		Buildable
		
	}

	// AccelLabelClass is an interface that the AccelLabel class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type AccelLabelClass interface {
		gextras.Objector
		_accelLabel()
	}

	func (AccelLabel) _accelLabel() {}

	
	func marshalAccelLabel(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapAccelLabel(obj), nil
	}
	

	
	// NewAccelLabel creates a new AccelLabel.
	func NewAccelLabel(_string string) AccelLabel {
var _arg1 *C.gchar // out
var _cret *C.GtkWidget // in

_arg1 = (*C.gchar)(C.CString(_string))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_accel_label_new(_arg1)


var _accelLabel AccelLabel // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_accelLabel = AccelLabel{
Label: Label{
Misc: Misc{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _accelLabel
}
	

	
	// Accel gets the keyval and modifier mask set with gtk_accel_label_set_accel().
	func (a AccelLabel) Accel() (uint, gdk.ModifierType) {
var _arg0 *C.GtkAccelLabel // out
var _arg1 C.guint // in
var _arg2 C.GdkModifierType // in

_arg0 = (*C.GtkAccelLabel)(unsafe.Pointer(a.Native()))

C.gtk_accel_label_get_accel(_arg0, &_arg1, &_arg2)

var _acceleratorKey uint // out
var _acceleratorMods gdk.ModifierType // out

_acceleratorKey = (uint)(_arg1)
_acceleratorMods = gdk.ModifierType(_arg2)

return _acceleratorKey, _acceleratorMods
}
	
	// AccelWidget fetches the widget monitored by this accelerator label. See
// gtk_accel_label_set_accel_widget().
	func (a AccelLabel) AccelWidget() Widget {
var _arg0 *C.GtkAccelLabel // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkAccelLabel)(unsafe.Pointer(a.Native()))

_cret = C.gtk_accel_label_get_accel_widget(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// AccelWidth returns the width needed to display the accelerator key(s). This
// is used by menus to align all of the MenuItem widgets, and shouldn't be
// needed by applications.
	func (a AccelLabel) AccelWidth() uint {
var _arg0 *C.GtkAccelLabel // out
var _cret C.guint // in

_arg0 = (*C.GtkAccelLabel)(unsafe.Pointer(a.Native()))

_cret = C.gtk_accel_label_get_accel_width(_arg0)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// Refetch recreates the string representing the accelerator keys. This should
// not be needed since the string is automatically updated whenever accelerators
// are added or removed from the associated widget.
	func (a AccelLabel) Refetch() bool {
var _arg0 *C.GtkAccelLabel // out
var _cret C.gboolean // in

_arg0 = (*C.GtkAccelLabel)(unsafe.Pointer(a.Native()))

_cret = C.gtk_accel_label_refetch(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetAccel: manually sets a keyval and modifier mask as the accelerator
// rendered by @accel_label.
// 
// If a keyval and modifier are explicitly set then these values are used
// regardless of any associated accel closure or widget.
// 
// Providing an @accelerator_key of 0 removes the manual setting.
	func (a AccelLabel) SetAccel(acceleratorKey uint, acceleratorMods gdk.ModifierType)  {
var _arg0 *C.GtkAccelLabel // out
var _arg1 C.guint // out
var _arg2 C.GdkModifierType // out

_arg0 = (*C.GtkAccelLabel)(unsafe.Pointer(a.Native()))
_arg1 = (C.guint)(acceleratorKey)
_arg2 = (C.GdkModifierType)(acceleratorMods)

C.gtk_accel_label_set_accel(_arg0, _arg1, _arg2)
}
	
	// SetAccelWidget sets the widget to be monitored by this accelerator label.
// Passing nil for @accel_widget will dissociate @accel_label from its current
// widget, if any.
	func (a AccelLabel) SetAccelWidget(accelWidget WidgetClass)  {
var _arg0 *C.GtkAccelLabel // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkAccelLabel)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(accelWidget.Native()))

C.gtk_accel_label_set_accel_widget(_arg0, _arg1)
}
	


	// AccelMap: accelerator maps are used to define runtime configurable
// accelerators. Functions for manipulating them are are usually used by higher
// level convenience mechanisms like UIManager and are thus considered
// “low-level”. You’ll want to use them if you’re manually creating menus that
// should have user-configurable accelerators.
// 
// An accelerator is uniquely defined by: - accelerator path - accelerator key -
// accelerator modifiers
// 
// The accelerator path must consist of
// “<WINDOWTYPE>/Category1/Category2/.../Action”, where WINDOWTYPE should be a
// unique application-specific identifier that corresponds to the kind of window
// the accelerator is being used in, e.g. “Gimp-Image”, “Abiword-Document” or
// “Gnumeric-Settings”. The “Category1/.../Action” portion is most appropriately
// chosen by the action the accelerator triggers, i.e. for accelerators on menu
// items, choose the item’s menu path, e.g. “File/Save As”, “Image/View/Zoom” or
// “Edit/Select All”. So a full valid accelerator path may look like:
// “<Gimp-Toolbox>/File/Dialogs/Tool Options...”.
// 
// All accelerators are stored inside one global AccelMap that can be obtained
// using gtk_accel_map_get(). See [Monitoring changes][monitoring-changes] for
// additional details.
// 
// 
// Manipulating accelerators
// 
// New accelerators can be added using gtk_accel_map_add_entry(). To search for
// specific accelerator, use gtk_accel_map_lookup_entry(). Modifications of
// existing accelerators should be done using gtk_accel_map_change_entry().
// 
// In order to avoid having some accelerators changed, they can be locked using
// gtk_accel_map_lock_path(). Unlocking is done using
// gtk_accel_map_unlock_path().
// 
// 
// Saving and loading accelerator maps
// 
// Accelerator maps can be saved to and loaded from some external resource. For
// simple saving and loading from file, gtk_accel_map_save() and
// gtk_accel_map_load() are provided. Saving and loading can also be done by
// providing file descriptor to gtk_accel_map_save_fd() and
// gtk_accel_map_load_fd().
// 
// 
// Monitoring changes
// 
// AccelMap object is only useful for monitoring changes of accelerators. By
// connecting to AccelMap::changed signal, one can monitor changes of all
// accelerators. It is also possible to monitor only single accelerator path by
// using it as a detail of the AccelMap::changed signal.
	type AccelMap struct {
		**externglib.Object
		
	}

	// AccelMapClass is an interface that the AccelMap class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type AccelMapClass interface {
		gextras.Objector
		_accelMap()
	}

	func (AccelMap) _accelMap() {}

	
	func marshalAccelMap(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapAccelMap(obj), nil
	}
	

	

	


	// Action: > In GTK+ 3.10, GtkAction has been deprecated. Use #GAction >
// instead, and associate actions with Actionable widgets. Use > Model for
// creating menus with gtk_menu_new_from_model().
// 
// Actions represent operations that the user can be perform, along with some
// information how it should be presented in the interface. Each action provides
// methods to create icons, menu items and toolbar items representing itself.
// 
// As well as the callback that is called when the action gets activated, the
// following also gets associated with the action:
// 
// - a name (not translated, for path lookup)
// 
// - a label (translated, for display)
// 
// - an accelerator
// 
// - whether label indicates a stock id
// 
// - a tooltip (optional, translated)
// 
// - a toolbar label (optional, shorter than label)
// 
//    The action will also have some state information:
// 
// - visible (shown/hidden)
// 
// - sensitive (enabled/disabled)
// 
// Apart from regular actions, there are [toggle actions][GtkToggleAction],
// which can be toggled between two states and [radio actions][GtkRadioAction],
// of which only one in a group can be in the “active” state. Other actions can
// be implemented as Action subclasses.
// 
// Each action can have one or more proxy widgets. To act as an action proxy,
// widget needs to implement Activatable interface. Proxies mirror the state of
// the action and should change when the action’s state changes. Properties that
// are always mirrored by proxies are Action:sensitive and Action:visible.
// Action:gicon, Action:icon-name, Action:label, Action:short-label and
// Action:stock-id properties are only mirorred if proxy widget has
// Activatable:use-action-appearance property set to true.
// 
// When the proxy is activated, it should activate its action.
	type Action struct {
		**externglib.Object
		Buildable
		
	}

	// ActionClass is an interface that the Action class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ActionClass interface {
		gextras.Objector
		_action()
	}

	func (Action) _action() {}

	
	func marshalAction(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapAction(obj), nil
	}
	

	
	// NewAction creates a new Action object. To add the action to a ActionGroup and
// set the accelerator for the action, call
// gtk_action_group_add_action_with_accel(). See the [UI Definition
// section][XML-UI] for information on allowed action names.
	func NewAction(name string, label string, tooltip string, stockId string) Action {
var _arg1 *C.gchar // out
var _arg2 *C.gchar // out
var _arg3 *C.gchar // out
var _arg4 *C.gchar // out
var _cret *C.GtkAction // in

_arg1 = (*C.gchar)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.gchar)(C.CString(label))
defer C.free(unsafe.Pointer(_arg2))
_arg3 = (*C.gchar)(C.CString(tooltip))
defer C.free(unsafe.Pointer(_arg3))
_arg4 = (*C.gchar)(C.CString(stockId))
defer C.free(unsafe.Pointer(_arg4))

_cret = C.gtk_action_new(_arg1, _arg2, _arg3, _arg4)


var _action Action // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_action = Action{
Object: &externglib.Object{externglib.ToGObject(obj)},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _action
}
	

	
	// Activate emits the “activate” signal on the specified action, if it isn't
// insensitive. This gets called by the proxy widgets when they get activated.
// 
// It can also be used to manually activate an action.
	func (a Action) Activate()  {
var _arg0 *C.GtkAction // out

_arg0 = (*C.GtkAction)(unsafe.Pointer(a.Native()))

C.gtk_action_activate(_arg0)
}
	
	// BlockActivate: disable activation signals from the action
// 
// This is needed when updating the state of your proxy Activatable widget could
// result in calling gtk_action_activate(), this is a convenience function to
// avoid recursing in those cases (updating toggle state for instance).
	func (a Action) BlockActivate()  {
var _arg0 *C.GtkAction // out

_arg0 = (*C.GtkAction)(unsafe.Pointer(a.Native()))

C.gtk_action_block_activate(_arg0)
}
	
	// ConnectAccelerator installs the accelerator for @action if @action has an
// accel path and group. See gtk_action_set_accel_path() and
// gtk_action_set_accel_group()
// 
// Since multiple proxies may independently trigger the installation of the
// accelerator, the @action counts the number of times this function has been
// called and doesn’t remove the accelerator until
// gtk_action_disconnect_accelerator() has been called as many times.
	func (a Action) ConnectAccelerator()  {
var _arg0 *C.GtkAction // out

_arg0 = (*C.GtkAction)(unsafe.Pointer(a.Native()))

C.gtk_action_connect_accelerator(_arg0)
}
	
	// CreateIcon: this function is intended for use by action implementations to
// create icons displayed in the proxy widgets.
	func (a Action) CreateIcon(iconSize int) Widget {
var _arg0 *C.GtkAction // out
var _arg1 C.GtkIconSize // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkAction)(unsafe.Pointer(a.Native()))
_arg1 = (C.GtkIconSize)(iconSize)

_cret = C.gtk_action_create_icon(_arg0, _arg1)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// CreateMenu: if @action provides a Menu widget as a submenu for the menu item
// or the toolbar item it creates, this function returns an instance of that
// menu.
	func (a Action) CreateMenu() Widget {
var _arg0 *C.GtkAction // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkAction)(unsafe.Pointer(a.Native()))

_cret = C.gtk_action_create_menu(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// CreateMenuItem creates a menu item widget that proxies for the given action.
	func (a Action) CreateMenuItem() Widget {
var _arg0 *C.GtkAction // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkAction)(unsafe.Pointer(a.Native()))

_cret = C.gtk_action_create_menu_item(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// CreateToolItem creates a toolbar item widget that proxies for the given
// action.
	func (a Action) CreateToolItem() Widget {
var _arg0 *C.GtkAction // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkAction)(unsafe.Pointer(a.Native()))

_cret = C.gtk_action_create_tool_item(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// DisconnectAccelerator undoes the effect of one call to
// gtk_action_connect_accelerator().
	func (a Action) DisconnectAccelerator()  {
var _arg0 *C.GtkAction // out

_arg0 = (*C.GtkAction)(unsafe.Pointer(a.Native()))

C.gtk_action_disconnect_accelerator(_arg0)
}
	
	// AccelPath returns the accel path for this action.
	func (a Action) AccelPath() string {
var _arg0 *C.GtkAction // out
var _cret *C.gchar // in

_arg0 = (*C.GtkAction)(unsafe.Pointer(a.Native()))

_cret = C.gtk_action_get_accel_path(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// AlwaysShowImage returns whether @action's menu item proxies will always show
// their image, if available.
	func (a Action) AlwaysShowImage() bool {
var _arg0 *C.GtkAction // out
var _cret C.gboolean // in

_arg0 = (*C.GtkAction)(unsafe.Pointer(a.Native()))

_cret = C.gtk_action_get_always_show_image(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// GIcon gets the gicon of @action.
	func (a Action) GIcon() gio.Icon {
var _arg0 *C.GtkAction // out
var _cret *C.GIcon // in

_arg0 = (*C.GtkAction)(unsafe.Pointer(a.Native()))

_cret = C.gtk_action_get_gicon(_arg0)


var _icon gio.Icon // out

_icon = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.Icon)

return _icon
}
	
	// IconName gets the icon name of @action.
	func (a Action) IconName() string {
var _arg0 *C.GtkAction // out
var _cret *C.gchar // in

_arg0 = (*C.GtkAction)(unsafe.Pointer(a.Native()))

_cret = C.gtk_action_get_icon_name(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// IsImportant checks whether @action is important or not
	func (a Action) IsImportant() bool {
var _arg0 *C.GtkAction // out
var _cret C.gboolean // in

_arg0 = (*C.GtkAction)(unsafe.Pointer(a.Native()))

_cret = C.gtk_action_get_is_important(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Label gets the label text of @action.
	func (a Action) Label() string {
var _arg0 *C.GtkAction // out
var _cret *C.gchar // in

_arg0 = (*C.GtkAction)(unsafe.Pointer(a.Native()))

_cret = C.gtk_action_get_label(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Name returns the name of the action.
	func (a Action) Name() string {
var _arg0 *C.GtkAction // out
var _cret *C.gchar // in

_arg0 = (*C.GtkAction)(unsafe.Pointer(a.Native()))

_cret = C.gtk_action_get_name(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Sensitive returns whether the action itself is sensitive. Note that this
// doesn’t necessarily mean effective sensitivity. See gtk_action_is_sensitive()
// for that.
	func (a Action) Sensitive() bool {
var _arg0 *C.GtkAction // out
var _cret C.gboolean // in

_arg0 = (*C.GtkAction)(unsafe.Pointer(a.Native()))

_cret = C.gtk_action_get_sensitive(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ShortLabel gets the short label text of @action.
	func (a Action) ShortLabel() string {
var _arg0 *C.GtkAction // out
var _cret *C.gchar // in

_arg0 = (*C.GtkAction)(unsafe.Pointer(a.Native()))

_cret = C.gtk_action_get_short_label(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// StockID gets the stock id of @action.
	func (a Action) StockID() string {
var _arg0 *C.GtkAction // out
var _cret *C.gchar // in

_arg0 = (*C.GtkAction)(unsafe.Pointer(a.Native()))

_cret = C.gtk_action_get_stock_id(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Tooltip gets the tooltip text of @action.
	func (a Action) Tooltip() string {
var _arg0 *C.GtkAction // out
var _cret *C.gchar // in

_arg0 = (*C.GtkAction)(unsafe.Pointer(a.Native()))

_cret = C.gtk_action_get_tooltip(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Visible returns whether the action itself is visible. Note that this doesn’t
// necessarily mean effective visibility. See gtk_action_is_sensitive() for
// that.
	func (a Action) Visible() bool {
var _arg0 *C.GtkAction // out
var _cret C.gboolean // in

_arg0 = (*C.GtkAction)(unsafe.Pointer(a.Native()))

_cret = C.gtk_action_get_visible(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// VisibleHorizontal checks whether @action is visible when horizontal
	func (a Action) VisibleHorizontal() bool {
var _arg0 *C.GtkAction // out
var _cret C.gboolean // in

_arg0 = (*C.GtkAction)(unsafe.Pointer(a.Native()))

_cret = C.gtk_action_get_visible_horizontal(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// VisibleVertical checks whether @action is visible when horizontal
	func (a Action) VisibleVertical() bool {
var _arg0 *C.GtkAction // out
var _cret C.gboolean // in

_arg0 = (*C.GtkAction)(unsafe.Pointer(a.Native()))

_cret = C.gtk_action_get_visible_vertical(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsSensitive returns whether the action is effectively sensitive.
	func (a Action) IsSensitive() bool {
var _arg0 *C.GtkAction // out
var _cret C.gboolean // in

_arg0 = (*C.GtkAction)(unsafe.Pointer(a.Native()))

_cret = C.gtk_action_is_sensitive(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsVisible returns whether the action is effectively visible.
	func (a Action) IsVisible() bool {
var _arg0 *C.GtkAction // out
var _cret C.gboolean // in

_arg0 = (*C.GtkAction)(unsafe.Pointer(a.Native()))

_cret = C.gtk_action_is_visible(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetAccelGroup sets the AccelGroup in which the accelerator for this action
// will be installed.
	func (a Action) SetAccelGroup(accelGroup AccelGroupClass)  {
var _arg0 *C.GtkAction // out
var _arg1 *C.GtkAccelGroup // out

_arg0 = (*C.GtkAction)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkAccelGroup)(unsafe.Pointer(accelGroup.Native()))

C.gtk_action_set_accel_group(_arg0, _arg1)
}
	
	// SetAccelPath sets the accel path for this action. All proxy widgets
// associated with the action will have this accel path, so that their
// accelerators are consistent.
// 
// Note that @accel_path string will be stored in a #GQuark. Therefore, if you
// pass a static string, you can save some memory by interning it first with
// g_intern_static_string().
	func (a Action) SetAccelPath(accelPath string)  {
var _arg0 *C.GtkAction // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkAction)(unsafe.Pointer(a.Native()))
_arg1 = (*C.gchar)(C.CString(accelPath))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_action_set_accel_path(_arg0, _arg1)
}
	
	// SetAlwaysShowImage sets whether @action's menu item proxies will ignore the
// Settings:gtk-menu-images setting and always show their image, if available.
// 
// Use this if the menu item would be useless or hard to use without their
// image.
	func (a Action) SetAlwaysShowImage(alwaysShow bool)  {
var _arg0 *C.GtkAction // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkAction)(unsafe.Pointer(a.Native()))
if alwaysShow { _arg1 = C.TRUE }

C.gtk_action_set_always_show_image(_arg0, _arg1)
}
	
	// SetGIcon sets the icon of @action.
	func (a Action) SetGIcon(icon gio.Icon)  {
var _arg0 *C.GtkAction // out
var _arg1 *C.GIcon // out

_arg0 = (*C.GtkAction)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GIcon)(unsafe.Pointer(icon.Native()))

C.gtk_action_set_gicon(_arg0, _arg1)
}
	
	// SetIconName sets the icon name on @action
	func (a Action) SetIconName(iconName string)  {
var _arg0 *C.GtkAction // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkAction)(unsafe.Pointer(a.Native()))
_arg1 = (*C.gchar)(C.CString(iconName))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_action_set_icon_name(_arg0, _arg1)
}
	
	// SetIsImportant sets whether the action is important, this attribute is used
// primarily by toolbar items to decide whether to show a label or not.
	func (a Action) SetIsImportant(isImportant bool)  {
var _arg0 *C.GtkAction // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkAction)(unsafe.Pointer(a.Native()))
if isImportant { _arg1 = C.TRUE }

C.gtk_action_set_is_important(_arg0, _arg1)
}
	
	// SetLabel sets the label of @action.
	func (a Action) SetLabel(label string)  {
var _arg0 *C.GtkAction // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkAction)(unsafe.Pointer(a.Native()))
_arg1 = (*C.gchar)(C.CString(label))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_action_set_label(_arg0, _arg1)
}
	
	// SetSensitive sets the :sensitive property of the action to @sensitive. Note
// that this doesn’t necessarily mean effective sensitivity. See
// gtk_action_is_sensitive() for that.
	func (a Action) SetSensitive(sensitive bool)  {
var _arg0 *C.GtkAction // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkAction)(unsafe.Pointer(a.Native()))
if sensitive { _arg1 = C.TRUE }

C.gtk_action_set_sensitive(_arg0, _arg1)
}
	
	// SetShortLabel sets a shorter label text on @action.
	func (a Action) SetShortLabel(shortLabel string)  {
var _arg0 *C.GtkAction // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkAction)(unsafe.Pointer(a.Native()))
_arg1 = (*C.gchar)(C.CString(shortLabel))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_action_set_short_label(_arg0, _arg1)
}
	
	// SetStockID sets the stock id on @action
	func (a Action) SetStockID(stockId string)  {
var _arg0 *C.GtkAction // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkAction)(unsafe.Pointer(a.Native()))
_arg1 = (*C.gchar)(C.CString(stockId))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_action_set_stock_id(_arg0, _arg1)
}
	
	// SetTooltip sets the tooltip text on @action
	func (a Action) SetTooltip(tooltip string)  {
var _arg0 *C.GtkAction // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkAction)(unsafe.Pointer(a.Native()))
_arg1 = (*C.gchar)(C.CString(tooltip))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_action_set_tooltip(_arg0, _arg1)
}
	
	// SetVisible sets the :visible property of the action to @visible. Note that
// this doesn’t necessarily mean effective visibility. See
// gtk_action_is_visible() for that.
	func (a Action) SetVisible(visible bool)  {
var _arg0 *C.GtkAction // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkAction)(unsafe.Pointer(a.Native()))
if visible { _arg1 = C.TRUE }

C.gtk_action_set_visible(_arg0, _arg1)
}
	
	// SetVisibleHorizontal sets whether @action is visible when horizontal
	func (a Action) SetVisibleHorizontal(visibleHorizontal bool)  {
var _arg0 *C.GtkAction // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkAction)(unsafe.Pointer(a.Native()))
if visibleHorizontal { _arg1 = C.TRUE }

C.gtk_action_set_visible_horizontal(_arg0, _arg1)
}
	
	// SetVisibleVertical sets whether @action is visible when vertical
	func (a Action) SetVisibleVertical(visibleVertical bool)  {
var _arg0 *C.GtkAction // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkAction)(unsafe.Pointer(a.Native()))
if visibleVertical { _arg1 = C.TRUE }

C.gtk_action_set_visible_vertical(_arg0, _arg1)
}
	
	// UnblockActivate: reenable activation signals from the action
	func (a Action) UnblockActivate()  {
var _arg0 *C.GtkAction // out

_arg0 = (*C.GtkAction)(unsafe.Pointer(a.Native()))

C.gtk_action_unblock_activate(_arg0)
}
	


	// ActionBar: gtkActionBar is designed to present contextual actions. It is
// expected to be displayed below the content and expand horizontally to fill
// the area.
// 
// It allows placing children at the start or the end. In addition, it contains
// an internal centered box which is centered with respect to the full width of
// the box, even if the children at either side take up different amounts of
// space.
// 
// 
// CSS nodes
// 
// GtkActionBar has a single CSS node with name actionbar.
	type ActionBar struct {
		Bin
		Buildable
		
	}

	// ActionBarClass is an interface that the ActionBar class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ActionBarClass interface {
		gextras.Objector
		_actionBar()
	}

	func (ActionBar) _actionBar() {}

	
	func marshalActionBar(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapActionBar(obj), nil
	}
	

	
	// NewActionBar creates a new ActionBar widget.
	func NewActionBar() ActionBar {
var _cret *C.GtkWidget // in

_cret = C.gtk_action_bar_new()


var _actionBar ActionBar // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_actionBar = ActionBar{
Bin: Bin{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _actionBar
}
	

	
	// CenterWidget retrieves the center bar widget of the bar.
	func (a ActionBar) CenterWidget() Widget {
var _arg0 *C.GtkActionBar // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkActionBar)(unsafe.Pointer(a.Native()))

_cret = C.gtk_action_bar_get_center_widget(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// PackEnd adds @child to @action_bar, packed with reference to the end of the
// @action_bar.
	func (a ActionBar) PackEnd(child WidgetClass)  {
var _arg0 *C.GtkActionBar // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkActionBar)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

C.gtk_action_bar_pack_end(_arg0, _arg1)
}
	
	// PackStart adds @child to @action_bar, packed with reference to the start of
// the @action_bar.
	func (a ActionBar) PackStart(child WidgetClass)  {
var _arg0 *C.GtkActionBar // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkActionBar)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

C.gtk_action_bar_pack_start(_arg0, _arg1)
}
	
	// SetCenterWidget sets the center widget for the ActionBar.
	func (a ActionBar) SetCenterWidget(centerWidget WidgetClass)  {
var _arg0 *C.GtkActionBar // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkActionBar)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(centerWidget.Native()))

C.gtk_action_bar_set_center_widget(_arg0, _arg1)
}
	


	// ActionGroup actions are organised into groups. An action group is essentially
// a map from names to Action objects.
// 
// All actions that would make sense to use in a particular context should be in
// a single group. Multiple action groups may be used for a particular user
// interface. In fact, it is expected that most nontrivial applications will
// make use of multiple groups. For example, in an application that can edit
// multiple documents, one group holding global actions (e.g. quit, about, new),
// and one group per document holding actions that act on that document (eg.
// save, cut/copy/paste, etc). Each window’s menus would be constructed from a
// combination of two action groups.
// 
// 
// Accelerators
// 
// Accelerators are handled by the GTK+ accelerator map. All actions are
// assigned an accelerator path (which normally has the form
// `<Actions>/group-name/action-name`) and a shortcut is associated with this
// accelerator path. All menuitems and toolitems take on this accelerator path.
// The GTK+ accelerator map code makes sure that the correct shortcut is
// displayed next to the menu item.
// 
// 
// GtkActionGroup as GtkBuildable
// 
// The ActionGroup implementation of the Buildable interface accepts Action
// objects as <child> elements in UI definitions.
// 
// Note that it is probably more common to define actions and action groups in
// the code, since they are directly related to what the code can do.
// 
// The GtkActionGroup implementation of the GtkBuildable interface supports a
// custom <accelerator> element, which has attributes named “key“ and
// “modifiers“ and allows to specify accelerators. This is similar to the
// <accelerator> element of Widget, the main difference is that it doesn’t allow
// you to specify a signal.
// 
// A Dialog UI definition fragment. ##
// 
//    <object class="GtkActionGroup" id="actiongroup">
//      <child>
//          <object class="GtkAction" id="About">
//              <property name="name">About</property>
//              <property name="stock_id">gtk-about</property>
//              <signal handler="about_activate" name="activate"/>
//          </object>
//          <accelerator key="F1" modifiers="GDK_CONTROL_MASK | GDK_SHIFT_MASK"/>
//      </child>
//    </object>
	type ActionGroup struct {
		**externglib.Object
		Buildable
		
	}

	// ActionGroupClass is an interface that the ActionGroup class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ActionGroupClass interface {
		gextras.Objector
		_actionGroup()
	}

	func (ActionGroup) _actionGroup() {}

	
	func marshalActionGroup(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapActionGroup(obj), nil
	}
	

	
	// NewActionGroup creates a new ActionGroup object. The name of the action group
// is used when associating [keybindings][Action-Accel] with the actions.
	func NewActionGroup(name string) ActionGroup {
var _arg1 *C.gchar // out
var _cret *C.GtkActionGroup // in

_arg1 = (*C.gchar)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_action_group_new(_arg1)


var _actionGroup ActionGroup // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_actionGroup = ActionGroup{
Object: &externglib.Object{externglib.ToGObject(obj)},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _actionGroup
}
	

	
	// AddAction adds an action object to the action group. Note that this function
// does not set up the accel path of the action, which can lead to problems if a
// user tries to modify the accelerator of a menuitem associated with the
// action. Therefore you must either set the accel path yourself with
// gtk_action_set_accel_path(), or use `gtk_action_group_add_action_with_accel
// (..., NULL)`.
	func (a ActionGroup) AddAction(action ActionClass)  {
var _arg0 *C.GtkActionGroup // out
var _arg1 *C.GtkAction // out

_arg0 = (*C.GtkActionGroup)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkAction)(unsafe.Pointer(action.Native()))

C.gtk_action_group_add_action(_arg0, _arg1)
}
	
	// AddActionWithAccel adds an action object to the action group and sets up the
// accelerator.
// 
// If @accelerator is nil, attempts to use the accelerator associated with the
// stock_id of the action.
// 
// Accel paths are set to `<Actions>/group-name/action-name`.
	func (a ActionGroup) AddActionWithAccel(action ActionClass, accelerator string)  {
var _arg0 *C.GtkActionGroup // out
var _arg1 *C.GtkAction // out
var _arg2 *C.gchar // out

_arg0 = (*C.GtkActionGroup)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkAction)(unsafe.Pointer(action.Native()))
_arg2 = (*C.gchar)(C.CString(accelerator))
defer C.free(unsafe.Pointer(_arg2))

C.gtk_action_group_add_action_with_accel(_arg0, _arg1, _arg2)
}
	
	// AccelGroup gets the accelerator group.
	func (a ActionGroup) AccelGroup() AccelGroup {
var _arg0 *C.GtkActionGroup // out
var _cret *C.GtkAccelGroup // in

_arg0 = (*C.GtkActionGroup)(unsafe.Pointer(a.Native()))

_cret = C.gtk_action_group_get_accel_group(_arg0)


var _accelGroup AccelGroup // out

_accelGroup = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(AccelGroup)

return _accelGroup
}
	
	// Action looks up an action in the action group by name.
	func (a ActionGroup) Action(actionName string) Action {
var _arg0 *C.GtkActionGroup // out
var _arg1 *C.gchar // out
var _cret *C.GtkAction // in

_arg0 = (*C.GtkActionGroup)(unsafe.Pointer(a.Native()))
_arg1 = (*C.gchar)(C.CString(actionName))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_action_group_get_action(_arg0, _arg1)


var _action Action // out

_action = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Action)

return _action
}
	
	// Name gets the name of the action group.
	func (a ActionGroup) Name() string {
var _arg0 *C.GtkActionGroup // out
var _cret *C.gchar // in

_arg0 = (*C.GtkActionGroup)(unsafe.Pointer(a.Native()))

_cret = C.gtk_action_group_get_name(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Sensitive returns true if the group is sensitive. The constituent actions can
// only be logically sensitive (see gtk_action_is_sensitive()) if they are
// sensitive (see gtk_action_get_sensitive()) and their group is sensitive.
	func (a ActionGroup) Sensitive() bool {
var _arg0 *C.GtkActionGroup // out
var _cret C.gboolean // in

_arg0 = (*C.GtkActionGroup)(unsafe.Pointer(a.Native()))

_cret = C.gtk_action_group_get_sensitive(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Visible returns true if the group is visible. The constituent actions can
// only be logically visible (see gtk_action_is_visible()) if they are visible
// (see gtk_action_get_visible()) and their group is visible.
	func (a ActionGroup) Visible() bool {
var _arg0 *C.GtkActionGroup // out
var _cret C.gboolean // in

_arg0 = (*C.GtkActionGroup)(unsafe.Pointer(a.Native()))

_cret = C.gtk_action_group_get_visible(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// RemoveAction removes an action object from the action group.
	func (a ActionGroup) RemoveAction(action ActionClass)  {
var _arg0 *C.GtkActionGroup // out
var _arg1 *C.GtkAction // out

_arg0 = (*C.GtkActionGroup)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkAction)(unsafe.Pointer(action.Native()))

C.gtk_action_group_remove_action(_arg0, _arg1)
}
	
	// SetAccelGroup sets the accelerator group to be used by every action in this
// group.
	func (a ActionGroup) SetAccelGroup(accelGroup AccelGroupClass)  {
var _arg0 *C.GtkActionGroup // out
var _arg1 *C.GtkAccelGroup // out

_arg0 = (*C.GtkActionGroup)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkAccelGroup)(unsafe.Pointer(accelGroup.Native()))

C.gtk_action_group_set_accel_group(_arg0, _arg1)
}
	
	// SetSensitive changes the sensitivity of @action_group
	func (a ActionGroup) SetSensitive(sensitive bool)  {
var _arg0 *C.GtkActionGroup // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkActionGroup)(unsafe.Pointer(a.Native()))
if sensitive { _arg1 = C.TRUE }

C.gtk_action_group_set_sensitive(_arg0, _arg1)
}
	
	// SetTranslationDomain sets the translation domain and uses g_dgettext() for
// translating the @label and @tooltip of ActionEntrys added by
// gtk_action_group_add_actions().
// 
// If you’re not using gettext() for localization, see
// gtk_action_group_set_translate_func().
	func (a ActionGroup) SetTranslationDomain(domain string)  {
var _arg0 *C.GtkActionGroup // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkActionGroup)(unsafe.Pointer(a.Native()))
_arg1 = (*C.gchar)(C.CString(domain))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_action_group_set_translation_domain(_arg0, _arg1)
}
	
	// SetVisible changes the visible of @action_group.
	func (a ActionGroup) SetVisible(visible bool)  {
var _arg0 *C.GtkActionGroup // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkActionGroup)(unsafe.Pointer(a.Native()))
if visible { _arg1 = C.TRUE }

C.gtk_action_group_set_visible(_arg0, _arg1)
}
	
	// TranslateString translates a string using the function set with
// gtk_action_group_set_translate_func(). This is mainly intended for language
// bindings.
	func (a ActionGroup) TranslateString(_string string) string {
var _arg0 *C.GtkActionGroup // out
var _arg1 *C.gchar // out
var _cret *C.gchar // in

_arg0 = (*C.GtkActionGroup)(unsafe.Pointer(a.Native()))
_arg1 = (*C.gchar)(C.CString(_string))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_action_group_translate_string(_arg0, _arg1)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	


	// Adjustment: the Adjustment object represents a value which has an associated
// lower and upper bound, together with step and page increments, and a page
// size. It is used within several GTK+ widgets, including SpinButton, Viewport,
// and Range (which is a base class for Scrollbar and Scale).
// 
// The Adjustment object does not update the value itself. Instead it is left up
// to the owner of the Adjustment to control the value.
	type Adjustment struct {
		externglib.InitiallyUnowned
		
	}

	// AdjustmentClass is an interface that the Adjustment class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type AdjustmentClass interface {
		gextras.Objector
		_adjustment()
	}

	func (Adjustment) _adjustment() {}

	
	func marshalAdjustment(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapAdjustment(obj), nil
	}
	

	
	// NewAdjustment creates a new Adjustment.
	func NewAdjustment(value float64, lower float64, upper float64, stepIncrement float64, pageIncrement float64, pageSize float64) Adjustment {
var _arg1 C.gdouble // out
var _arg2 C.gdouble // out
var _arg3 C.gdouble // out
var _arg4 C.gdouble // out
var _arg5 C.gdouble // out
var _arg6 C.gdouble // out
var _cret *C.GtkAdjustment // in

_arg1 = (C.gdouble)(value)
_arg2 = (C.gdouble)(lower)
_arg3 = (C.gdouble)(upper)
_arg4 = (C.gdouble)(stepIncrement)
_arg5 = (C.gdouble)(pageIncrement)
_arg6 = (C.gdouble)(pageSize)

_cret = C.gtk_adjustment_new(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)


var _adjustment Adjustment // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_adjustment = Adjustment{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _adjustment
}
	

	
	// Changed emits a Adjustment::changed signal from the Adjustment. This is
// typically called by the owner of the Adjustment after it has changed any of
// the Adjustment properties other than the value.
	func (a Adjustment) Changed()  {
var _arg0 *C.GtkAdjustment // out

_arg0 = (*C.GtkAdjustment)(unsafe.Pointer(a.Native()))

C.gtk_adjustment_changed(_arg0)
}
	
	// ClampPage updates the Adjustment:value property to ensure that the range
// between @lower and @upper is in the current page (i.e. between
// Adjustment:value and Adjustment:value + Adjustment:page-size). If the range
// is larger than the page size, then only the start of it will be in the
// current page.
// 
// A Adjustment::value-changed signal will be emitted if the value is changed.
	func (a Adjustment) ClampPage(lower float64, upper float64)  {
var _arg0 *C.GtkAdjustment // out
var _arg1 C.gdouble // out
var _arg2 C.gdouble // out

_arg0 = (*C.GtkAdjustment)(unsafe.Pointer(a.Native()))
_arg1 = (C.gdouble)(lower)
_arg2 = (C.gdouble)(upper)

C.gtk_adjustment_clamp_page(_arg0, _arg1, _arg2)
}
	
	// Configure sets all properties of the adjustment at once.
// 
// Use this function to avoid multiple emissions of the Adjustment::changed
// signal. See gtk_adjustment_set_lower() for an alternative way of compressing
// multiple emissions of Adjustment::changed into one.
	func (a Adjustment) Configure(value float64, lower float64, upper float64, stepIncrement float64, pageIncrement float64, pageSize float64)  {
var _arg0 *C.GtkAdjustment // out
var _arg1 C.gdouble // out
var _arg2 C.gdouble // out
var _arg3 C.gdouble // out
var _arg4 C.gdouble // out
var _arg5 C.gdouble // out
var _arg6 C.gdouble // out

_arg0 = (*C.GtkAdjustment)(unsafe.Pointer(a.Native()))
_arg1 = (C.gdouble)(value)
_arg2 = (C.gdouble)(lower)
_arg3 = (C.gdouble)(upper)
_arg4 = (C.gdouble)(stepIncrement)
_arg5 = (C.gdouble)(pageIncrement)
_arg6 = (C.gdouble)(pageSize)

C.gtk_adjustment_configure(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
}
	
	// Lower retrieves the minimum value of the adjustment.
	func (a Adjustment) Lower() float64 {
var _arg0 *C.GtkAdjustment // out
var _cret C.gdouble // in

_arg0 = (*C.GtkAdjustment)(unsafe.Pointer(a.Native()))

_cret = C.gtk_adjustment_get_lower(_arg0)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// MinimumIncrement gets the smaller of step increment and page increment.
	func (a Adjustment) MinimumIncrement() float64 {
var _arg0 *C.GtkAdjustment // out
var _cret C.gdouble // in

_arg0 = (*C.GtkAdjustment)(unsafe.Pointer(a.Native()))

_cret = C.gtk_adjustment_get_minimum_increment(_arg0)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// PageIncrement retrieves the page increment of the adjustment.
	func (a Adjustment) PageIncrement() float64 {
var _arg0 *C.GtkAdjustment // out
var _cret C.gdouble // in

_arg0 = (*C.GtkAdjustment)(unsafe.Pointer(a.Native()))

_cret = C.gtk_adjustment_get_page_increment(_arg0)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// PageSize retrieves the page size of the adjustment.
	func (a Adjustment) PageSize() float64 {
var _arg0 *C.GtkAdjustment // out
var _cret C.gdouble // in

_arg0 = (*C.GtkAdjustment)(unsafe.Pointer(a.Native()))

_cret = C.gtk_adjustment_get_page_size(_arg0)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// StepIncrement retrieves the step increment of the adjustment.
	func (a Adjustment) StepIncrement() float64 {
var _arg0 *C.GtkAdjustment // out
var _cret C.gdouble // in

_arg0 = (*C.GtkAdjustment)(unsafe.Pointer(a.Native()))

_cret = C.gtk_adjustment_get_step_increment(_arg0)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// Upper retrieves the maximum value of the adjustment.
	func (a Adjustment) Upper() float64 {
var _arg0 *C.GtkAdjustment // out
var _cret C.gdouble // in

_arg0 = (*C.GtkAdjustment)(unsafe.Pointer(a.Native()))

_cret = C.gtk_adjustment_get_upper(_arg0)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// Value gets the current value of the adjustment. See
// gtk_adjustment_set_value().
	func (a Adjustment) Value() float64 {
var _arg0 *C.GtkAdjustment // out
var _cret C.gdouble // in

_arg0 = (*C.GtkAdjustment)(unsafe.Pointer(a.Native()))

_cret = C.gtk_adjustment_get_value(_arg0)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// SetLower sets the minimum value of the adjustment.
// 
// When setting multiple adjustment properties via their individual setters,
// multiple Adjustment::changed signals will be emitted. However, since the
// emission of the Adjustment::changed signal is tied to the emission of the
// #GObject::notify signals of the changed properties, it’s possible to compress
// the Adjustment::changed signals into one by calling g_object_freeze_notify()
// and g_object_thaw_notify() around the calls to the individual setters.
// 
// Alternatively, using a single g_object_set() for all the properties to
// change, or using gtk_adjustment_configure() has the same effect of
// compressing Adjustment::changed emissions.
	func (a Adjustment) SetLower(lower float64)  {
var _arg0 *C.GtkAdjustment // out
var _arg1 C.gdouble // out

_arg0 = (*C.GtkAdjustment)(unsafe.Pointer(a.Native()))
_arg1 = (C.gdouble)(lower)

C.gtk_adjustment_set_lower(_arg0, _arg1)
}
	
	// SetPageIncrement sets the page increment of the adjustment.
// 
// See gtk_adjustment_set_lower() about how to compress multiple emissions of
// the Adjustment::changed signal when setting multiple adjustment properties.
	func (a Adjustment) SetPageIncrement(pageIncrement float64)  {
var _arg0 *C.GtkAdjustment // out
var _arg1 C.gdouble // out

_arg0 = (*C.GtkAdjustment)(unsafe.Pointer(a.Native()))
_arg1 = (C.gdouble)(pageIncrement)

C.gtk_adjustment_set_page_increment(_arg0, _arg1)
}
	
	// SetPageSize sets the page size of the adjustment.
// 
// See gtk_adjustment_set_lower() about how to compress multiple emissions of
// the GtkAdjustment::changed signal when setting multiple adjustment
// properties.
	func (a Adjustment) SetPageSize(pageSize float64)  {
var _arg0 *C.GtkAdjustment // out
var _arg1 C.gdouble // out

_arg0 = (*C.GtkAdjustment)(unsafe.Pointer(a.Native()))
_arg1 = (C.gdouble)(pageSize)

C.gtk_adjustment_set_page_size(_arg0, _arg1)
}
	
	// SetStepIncrement sets the step increment of the adjustment.
// 
// See gtk_adjustment_set_lower() about how to compress multiple emissions of
// the Adjustment::changed signal when setting multiple adjustment properties.
	func (a Adjustment) SetStepIncrement(stepIncrement float64)  {
var _arg0 *C.GtkAdjustment // out
var _arg1 C.gdouble // out

_arg0 = (*C.GtkAdjustment)(unsafe.Pointer(a.Native()))
_arg1 = (C.gdouble)(stepIncrement)

C.gtk_adjustment_set_step_increment(_arg0, _arg1)
}
	
	// SetUpper sets the maximum value of the adjustment.
// 
// Note that values will be restricted by `upper - page-size` if the page-size
// property is nonzero.
// 
// See gtk_adjustment_set_lower() about how to compress multiple emissions of
// the Adjustment::changed signal when setting multiple adjustment properties.
	func (a Adjustment) SetUpper(upper float64)  {
var _arg0 *C.GtkAdjustment // out
var _arg1 C.gdouble // out

_arg0 = (*C.GtkAdjustment)(unsafe.Pointer(a.Native()))
_arg1 = (C.gdouble)(upper)

C.gtk_adjustment_set_upper(_arg0, _arg1)
}
	
	// SetValue sets the Adjustment value. The value is clamped to lie between
// Adjustment:lower and Adjustment:upper.
// 
// Note that for adjustments which are used in a Scrollbar, the effective range
// of allowed values goes from Adjustment:lower to Adjustment:upper -
// Adjustment:page-size.
	func (a Adjustment) SetValue(value float64)  {
var _arg0 *C.GtkAdjustment // out
var _arg1 C.gdouble // out

_arg0 = (*C.GtkAdjustment)(unsafe.Pointer(a.Native()))
_arg1 = (C.gdouble)(value)

C.gtk_adjustment_set_value(_arg0, _arg1)
}
	
	// ValueChanged emits a Adjustment::value-changed signal from the Adjustment.
// This is typically called by the owner of the Adjustment after it has changed
// the Adjustment:value property.
	func (a Adjustment) ValueChanged()  {
var _arg0 *C.GtkAdjustment // out

_arg0 = (*C.GtkAdjustment)(unsafe.Pointer(a.Native()))

C.gtk_adjustment_value_changed(_arg0)
}
	


	// Alignment: the Alignment widget controls the alignment and size of its child
// widget. It has four settings: xscale, yscale, xalign, and yalign.
// 
// The scale settings are used to specify how much the child widget should
// expand to fill the space allocated to the Alignment. The values can range
// from 0 (meaning the child doesn’t expand at all) to 1 (meaning the child
// expands to fill all of the available space).
// 
// The align settings are used to place the child widget within the available
// area. The values range from 0 (top or left) to 1 (bottom or right). Of
// course, if the scale settings are both set to 1, the alignment settings have
// no effect.
// 
// GtkAlignment has been deprecated in 3.14 and should not be used in
// newly-written code. The desired effect can be achieved by using the
// Widget:halign, Widget:valign and Widget:margin properties on the child
// widget.
	type Alignment struct {
		Bin
		Buildable
		
	}

	// AlignmentClass is an interface that the Alignment class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type AlignmentClass interface {
		gextras.Objector
		_alignment()
	}

	func (Alignment) _alignment() {}

	
	func marshalAlignment(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapAlignment(obj), nil
	}
	

	
	// NewAlignment creates a new Alignment.
	func NewAlignment(xalign float32, yalign float32, xscale float32, yscale float32) Alignment {
var _arg1 C.gfloat // out
var _arg2 C.gfloat // out
var _arg3 C.gfloat // out
var _arg4 C.gfloat // out
var _cret *C.GtkWidget // in

_arg1 = (C.gfloat)(xalign)
_arg2 = (C.gfloat)(yalign)
_arg3 = (C.gfloat)(xscale)
_arg4 = (C.gfloat)(yscale)

_cret = C.gtk_alignment_new(_arg1, _arg2, _arg3, _arg4)


var _alignment Alignment // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_alignment = Alignment{
Bin: Bin{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _alignment
}
	

	
	// Padding gets the padding on the different sides of the widget. See
// gtk_alignment_set_padding ().
	func (a Alignment) Padding() (paddingTop uint, paddingBottom uint, paddingLeft uint, paddingRight uint) {
var _arg0 *C.GtkAlignment // out
var _arg1 C.guint // in
var _arg2 C.guint // in
var _arg3 C.guint // in
var _arg4 C.guint // in

_arg0 = (*C.GtkAlignment)(unsafe.Pointer(a.Native()))

C.gtk_alignment_get_padding(_arg0, &_arg1, &_arg2, &_arg3, &_arg4)

var _paddingTop uint // out
var _paddingBottom uint // out
var _paddingLeft uint // out
var _paddingRight uint // out

_paddingTop = (uint)(_arg1)
_paddingBottom = (uint)(_arg2)
_paddingLeft = (uint)(_arg3)
_paddingRight = (uint)(_arg4)

return _paddingTop, _paddingBottom, _paddingLeft, _paddingRight
}
	
	// Set sets the Alignment values.
	func (a Alignment) Set(xalign float32, yalign float32, xscale float32, yscale float32)  {
var _arg0 *C.GtkAlignment // out
var _arg1 C.gfloat // out
var _arg2 C.gfloat // out
var _arg3 C.gfloat // out
var _arg4 C.gfloat // out

_arg0 = (*C.GtkAlignment)(unsafe.Pointer(a.Native()))
_arg1 = (C.gfloat)(xalign)
_arg2 = (C.gfloat)(yalign)
_arg3 = (C.gfloat)(xscale)
_arg4 = (C.gfloat)(yscale)

C.gtk_alignment_set(_arg0, _arg1, _arg2, _arg3, _arg4)
}
	
	// SetPadding sets the padding on the different sides of the widget. The padding
// adds blank space to the sides of the widget. For instance, this can be used
// to indent the child widget towards the right by adding padding on the left.
	func (a Alignment) SetPadding(paddingTop uint, paddingBottom uint, paddingLeft uint, paddingRight uint)  {
var _arg0 *C.GtkAlignment // out
var _arg1 C.guint // out
var _arg2 C.guint // out
var _arg3 C.guint // out
var _arg4 C.guint // out

_arg0 = (*C.GtkAlignment)(unsafe.Pointer(a.Native()))
_arg1 = (C.guint)(paddingTop)
_arg2 = (C.guint)(paddingBottom)
_arg3 = (C.guint)(paddingLeft)
_arg4 = (C.guint)(paddingRight)

C.gtk_alignment_set_padding(_arg0, _arg1, _arg2, _arg3, _arg4)
}
	


	// AppChooserButton: the AppChooserButton is a widget that lets the user select
// an application. It implements the AppChooser interface.
// 
// Initially, a AppChooserButton selects the first application in its list,
// which will either be the most-recently used application or, if
// AppChooserButton:show-default-item is true, the default application.
// 
// The list of applications shown in a AppChooserButton includes the recommended
// applications for the given content type. When
// AppChooserButton:show-default-item is set, the default application is also
// included. To let the user chooser other applications, you can set the
// AppChooserButton:show-dialog-item property, which allows to open a full
// AppChooserDialog.
// 
// It is possible to add custom items to the list, using
// gtk_app_chooser_button_append_custom_item(). These items cause the
// AppChooserButton::custom-item-activated signal to be emitted when they are
// selected.
// 
// To track changes in the selected application, use the ComboBox::changed
// signal.
	type AppChooserButton struct {
		ComboBox
		AppChooser
		Buildable
		CellEditable
		CellLayout
		
	}

	// AppChooserButtonClass is an interface that the AppChooserButton class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type AppChooserButtonClass interface {
		gextras.Objector
		_appChooserButton()
	}

	func (AppChooserButton) _appChooserButton() {}

	
	func marshalAppChooserButton(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapAppChooserButton(obj), nil
	}
	

	
	// NewAppChooserButton creates a new AppChooserButton for applications that can
// handle content of the given type.
	func NewAppChooserButton(contentType string) AppChooserButton {
var _arg1 *C.gchar // out
var _cret *C.GtkWidget // in

_arg1 = (*C.gchar)(C.CString(contentType))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_app_chooser_button_new(_arg1)


var _appChooserButton AppChooserButton // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_appChooserButton = AppChooserButton{
ComboBox: ComboBox{
Bin: Bin{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
CellEditable: CellEditable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
CellLayout: CellLayout{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
AppChooser: AppChooser{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
CellEditable: CellEditable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
CellLayout: CellLayout{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _appChooserButton
}
	

	
	// AppendCustomItem appends a custom item to the list of applications that is
// shown in the popup; the item name must be unique per-widget. Clients can use
// the provided name as a detail for the AppChooserButton::custom-item-activated
// signal, to add a callback for the activation of a particular custom item in
// the list. See also gtk_app_chooser_button_append_separator().
	func (s AppChooserButton) AppendCustomItem(name string, label string, icon gio.Icon)  {
var _arg0 *C.GtkAppChooserButton // out
var _arg1 *C.gchar // out
var _arg2 *C.gchar // out
var _arg3 *C.GIcon // out

_arg0 = (*C.GtkAppChooserButton)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.gchar)(C.CString(label))
defer C.free(unsafe.Pointer(_arg2))
_arg3 = (*C.GIcon)(unsafe.Pointer(icon.Native()))

C.gtk_app_chooser_button_append_custom_item(_arg0, _arg1, _arg2, _arg3)
}
	
	// AppendSeparator appends a separator to the list of applications that is shown
// in the popup.
	func (s AppChooserButton) AppendSeparator()  {
var _arg0 *C.GtkAppChooserButton // out

_arg0 = (*C.GtkAppChooserButton)(unsafe.Pointer(s.Native()))

C.gtk_app_chooser_button_append_separator(_arg0)
}
	
	// Heading returns the text to display at the top of the dialog.
	func (s AppChooserButton) Heading() string {
var _arg0 *C.GtkAppChooserButton // out
var _cret *C.gchar // in

_arg0 = (*C.GtkAppChooserButton)(unsafe.Pointer(s.Native()))

_cret = C.gtk_app_chooser_button_get_heading(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// ShowDefaultItem returns the current value of the
// AppChooserButton:show-default-item property.
	func (s AppChooserButton) ShowDefaultItem() bool {
var _arg0 *C.GtkAppChooserButton // out
var _cret C.gboolean // in

_arg0 = (*C.GtkAppChooserButton)(unsafe.Pointer(s.Native()))

_cret = C.gtk_app_chooser_button_get_show_default_item(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ShowDialogItem returns the current value of the
// AppChooserButton:show-dialog-item property.
	func (s AppChooserButton) ShowDialogItem() bool {
var _arg0 *C.GtkAppChooserButton // out
var _cret C.gboolean // in

_arg0 = (*C.GtkAppChooserButton)(unsafe.Pointer(s.Native()))

_cret = C.gtk_app_chooser_button_get_show_dialog_item(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetActiveCustomItem selects a custom item previously added with
// gtk_app_chooser_button_append_custom_item().
// 
// Use gtk_app_chooser_refresh() to bring the selection to its initial state.
	func (s AppChooserButton) SetActiveCustomItem(name string)  {
var _arg0 *C.GtkAppChooserButton // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkAppChooserButton)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_app_chooser_button_set_active_custom_item(_arg0, _arg1)
}
	
	// SetHeading sets the text to display at the top of the dialog. If the heading
// is not set, the dialog displays a default text.
	func (s AppChooserButton) SetHeading(heading string)  {
var _arg0 *C.GtkAppChooserButton // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkAppChooserButton)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(heading))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_app_chooser_button_set_heading(_arg0, _arg1)
}
	
	// SetShowDefaultItem sets whether the dropdown menu of this button should show
// the default application for the given content type at top.
	func (s AppChooserButton) SetShowDefaultItem(setting bool)  {
var _arg0 *C.GtkAppChooserButton // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkAppChooserButton)(unsafe.Pointer(s.Native()))
if setting { _arg1 = C.TRUE }

C.gtk_app_chooser_button_set_show_default_item(_arg0, _arg1)
}
	
	// SetShowDialogItem sets whether the dropdown menu of this button should show
// an entry to trigger a AppChooserDialog.
	func (s AppChooserButton) SetShowDialogItem(setting bool)  {
var _arg0 *C.GtkAppChooserButton // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkAppChooserButton)(unsafe.Pointer(s.Native()))
if setting { _arg1 = C.TRUE }

C.gtk_app_chooser_button_set_show_dialog_item(_arg0, _arg1)
}
	


	// AppChooserDialog shows a AppChooserWidget inside a Dialog.
// 
// Note that AppChooserDialog does not have any interesting methods of its own.
// Instead, you should get the embedded AppChooserWidget using
// gtk_app_chooser_dialog_get_widget() and call its methods if the generic
// AppChooser interface is not sufficient for your needs.
// 
// To set the heading that is shown above the AppChooserWidget, use
// gtk_app_chooser_dialog_set_heading().
	type AppChooserDialog struct {
		Dialog
		AppChooser
		Buildable
		
	}

	// AppChooserDialogClass is an interface that the AppChooserDialog class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type AppChooserDialogClass interface {
		gextras.Objector
		_appChooserDialog()
	}

	func (AppChooserDialog) _appChooserDialog() {}

	
	func marshalAppChooserDialog(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapAppChooserDialog(obj), nil
	}
	

	
	// NewAppChooserDialog creates a new AppChooserDialog for the provided #GFile,
// to allow the user to select an application for it.
	func NewAppChooserDialog(parent WindowClass, flags DialogFlags, file gio.File) AppChooserDialog {
var _arg1 *C.GtkWindow // out
var _arg2 C.GtkDialogFlags // out
var _arg3 *C.GFile // out
var _cret *C.GtkWidget // in

_arg1 = (*C.GtkWindow)(unsafe.Pointer(parent.Native()))
_arg2 = (C.GtkDialogFlags)(flags)
_arg3 = (*C.GFile)(unsafe.Pointer(file.Native()))

_cret = C.gtk_app_chooser_dialog_new(_arg1, _arg2, _arg3)


var _appChooserDialog AppChooserDialog // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_appChooserDialog = AppChooserDialog{
Dialog: Dialog{
Window: Window{
Bin: Bin{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
AppChooser: AppChooser{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _appChooserDialog
}
	
	// NewAppChooserDialogForContentType creates a new AppChooserDialog for the
// provided content type, to allow the user to select an application for it.
	func NewAppChooserDialogForContentType(parent WindowClass, flags DialogFlags, contentType string) AppChooserDialog {
var _arg1 *C.GtkWindow // out
var _arg2 C.GtkDialogFlags // out
var _arg3 *C.gchar // out
var _cret *C.GtkWidget // in

_arg1 = (*C.GtkWindow)(unsafe.Pointer(parent.Native()))
_arg2 = (C.GtkDialogFlags)(flags)
_arg3 = (*C.gchar)(C.CString(contentType))
defer C.free(unsafe.Pointer(_arg3))

_cret = C.gtk_app_chooser_dialog_new_for_content_type(_arg1, _arg2, _arg3)


var _appChooserDialog AppChooserDialog // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_appChooserDialog = AppChooserDialog{
Dialog: Dialog{
Window: Window{
Bin: Bin{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
AppChooser: AppChooser{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _appChooserDialog
}
	

	
	// Heading returns the text to display at the top of the dialog.
	func (s AppChooserDialog) Heading() string {
var _arg0 *C.GtkAppChooserDialog // out
var _cret *C.gchar // in

_arg0 = (*C.GtkAppChooserDialog)(unsafe.Pointer(s.Native()))

_cret = C.gtk_app_chooser_dialog_get_heading(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Widget returns the AppChooserWidget of this dialog.
	func (s AppChooserDialog) Widget() Widget {
var _arg0 *C.GtkAppChooserDialog // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkAppChooserDialog)(unsafe.Pointer(s.Native()))

_cret = C.gtk_app_chooser_dialog_get_widget(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// SetHeading sets the text to display at the top of the dialog. If the heading
// is not set, the dialog displays a default text.
	func (s AppChooserDialog) SetHeading(heading string)  {
var _arg0 *C.GtkAppChooserDialog // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkAppChooserDialog)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(heading))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_app_chooser_dialog_set_heading(_arg0, _arg1)
}
	


	// AppChooserWidget is a widget for selecting applications. It is the main
// building block for AppChooserDialog. Most applications only need to use the
// latter; but you can use this widget as part of a larger widget if you have
// special needs.
// 
// AppChooserWidget offers detailed control over what applications are shown,
// using the AppChooserWidget:show-default, AppChooserWidget:show-recommended,
// AppChooserWidget:show-fallback, AppChooserWidget:show-other and
// AppChooserWidget:show-all properties. See the AppChooser documentation for
// more information about these groups of applications.
// 
// To keep track of the selected application, use the
// AppChooserWidget::application-selected and
// AppChooserWidget::application-activated signals.
// 
// 
// CSS nodes
// 
// GtkAppChooserWidget has a single CSS node with name appchooser.
	type AppChooserWidget struct {
		Box
		AppChooser
		Buildable
		Orientable
		
	}

	// AppChooserWidgetClass is an interface that the AppChooserWidget class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type AppChooserWidgetClass interface {
		gextras.Objector
		_appChooserWidget()
	}

	func (AppChooserWidget) _appChooserWidget() {}

	
	func marshalAppChooserWidget(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapAppChooserWidget(obj), nil
	}
	

	
	// NewAppChooserWidget creates a new AppChooserWidget for applications that can
// handle content of the given type.
	func NewAppChooserWidget(contentType string) AppChooserWidget {
var _arg1 *C.gchar // out
var _cret *C.GtkWidget // in

_arg1 = (*C.gchar)(C.CString(contentType))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_app_chooser_widget_new(_arg1)


var _appChooserWidget AppChooserWidget // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_appChooserWidget = AppChooserWidget{
Box: Box{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
AppChooser: AppChooser{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _appChooserWidget
}
	

	
	// DefaultText returns the text that is shown if there are not applications that
// can handle the content type.
	func (s AppChooserWidget) DefaultText() string {
var _arg0 *C.GtkAppChooserWidget // out
var _cret *C.gchar // in

_arg0 = (*C.GtkAppChooserWidget)(unsafe.Pointer(s.Native()))

_cret = C.gtk_app_chooser_widget_get_default_text(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// ShowAll returns the current value of the AppChooserWidget:show-all property.
	func (s AppChooserWidget) ShowAll() bool {
var _arg0 *C.GtkAppChooserWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkAppChooserWidget)(unsafe.Pointer(s.Native()))

_cret = C.gtk_app_chooser_widget_get_show_all(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ShowDefault returns the current value of the AppChooserWidget:show-default
// property.
	func (s AppChooserWidget) ShowDefault() bool {
var _arg0 *C.GtkAppChooserWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkAppChooserWidget)(unsafe.Pointer(s.Native()))

_cret = C.gtk_app_chooser_widget_get_show_default(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ShowFallback returns the current value of the AppChooserWidget:show-fallback
// property.
	func (s AppChooserWidget) ShowFallback() bool {
var _arg0 *C.GtkAppChooserWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkAppChooserWidget)(unsafe.Pointer(s.Native()))

_cret = C.gtk_app_chooser_widget_get_show_fallback(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ShowOther returns the current value of the AppChooserWidget:show-other
// property.
	func (s AppChooserWidget) ShowOther() bool {
var _arg0 *C.GtkAppChooserWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkAppChooserWidget)(unsafe.Pointer(s.Native()))

_cret = C.gtk_app_chooser_widget_get_show_other(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ShowRecommended returns the current value of the
// AppChooserWidget:show-recommended property.
	func (s AppChooserWidget) ShowRecommended() bool {
var _arg0 *C.GtkAppChooserWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkAppChooserWidget)(unsafe.Pointer(s.Native()))

_cret = C.gtk_app_chooser_widget_get_show_recommended(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetDefaultText sets the text that is shown if there are not applications that
// can handle the content type.
	func (s AppChooserWidget) SetDefaultText(text string)  {
var _arg0 *C.GtkAppChooserWidget // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkAppChooserWidget)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(text))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_app_chooser_widget_set_default_text(_arg0, _arg1)
}
	
	// SetShowAll sets whether the app chooser should show all applications in a
// flat list.
	func (s AppChooserWidget) SetShowAll(setting bool)  {
var _arg0 *C.GtkAppChooserWidget // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkAppChooserWidget)(unsafe.Pointer(s.Native()))
if setting { _arg1 = C.TRUE }

C.gtk_app_chooser_widget_set_show_all(_arg0, _arg1)
}
	
	// SetShowDefault sets whether the app chooser should show the default handler
// for the content type in a separate section.
	func (s AppChooserWidget) SetShowDefault(setting bool)  {
var _arg0 *C.GtkAppChooserWidget // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkAppChooserWidget)(unsafe.Pointer(s.Native()))
if setting { _arg1 = C.TRUE }

C.gtk_app_chooser_widget_set_show_default(_arg0, _arg1)
}
	
	// SetShowFallback sets whether the app chooser should show related applications
// for the content type in a separate section.
	func (s AppChooserWidget) SetShowFallback(setting bool)  {
var _arg0 *C.GtkAppChooserWidget // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkAppChooserWidget)(unsafe.Pointer(s.Native()))
if setting { _arg1 = C.TRUE }

C.gtk_app_chooser_widget_set_show_fallback(_arg0, _arg1)
}
	
	// SetShowOther sets whether the app chooser should show applications which are
// unrelated to the content type.
	func (s AppChooserWidget) SetShowOther(setting bool)  {
var _arg0 *C.GtkAppChooserWidget // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkAppChooserWidget)(unsafe.Pointer(s.Native()))
if setting { _arg1 = C.TRUE }

C.gtk_app_chooser_widget_set_show_other(_arg0, _arg1)
}
	
	// SetShowRecommended sets whether the app chooser should show recommended
// applications for the content type in a separate section.
	func (s AppChooserWidget) SetShowRecommended(setting bool)  {
var _arg0 *C.GtkAppChooserWidget // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkAppChooserWidget)(unsafe.Pointer(s.Native()))
if setting { _arg1 = C.TRUE }

C.gtk_app_chooser_widget_set_show_recommended(_arg0, _arg1)
}
	


	// Application is a class that handles many important aspects of a GTK+
// application in a convenient fashion, without enforcing a one-size-fits-all
// application model.
// 
// Currently, GtkApplication handles GTK+ initialization, application
// uniqueness, session management, provides some basic scriptability and desktop
// shell integration by exporting actions and menus and manages a list of
// toplevel windows whose life-cycle is automatically tied to the life-cycle of
// your application.
// 
// While GtkApplication works fine with plain Windows, it is recommended to use
// it together with ApplicationWindow.
// 
// When GDK threads are enabled, GtkApplication will acquire the GDK lock when
// invoking actions that arrive from other processes. The GDK lock is not
// touched for local action invocations. In order to have actions invoked in a
// predictable context it is therefore recommended that the GDK lock be held
// while invoking actions locally with g_action_group_activate_action(). The
// same applies to actions associated with ApplicationWindow and to the
// “activate” and “open” #GApplication methods.
// 
// 
// Automatic resources
// 
// Application will automatically load menus from the Builder resource located
// at "gtk/menus.ui", relative to the application's resource base path (see
// g_application_set_resource_base_path()). The menu with the ID "app-menu" is
// taken as the application's app menu and the menu with the ID "menubar" is
// taken as the application's menubar. Additional menus (most interesting
// submenus) can be named and accessed via gtk_application_get_menu_by_id()
// which allows for dynamic population of a part of the menu structure.
// 
// If the resources "gtk/menus-appmenu.ui" or "gtk/menus-traditional.ui" are
// present then these files will be used in preference, depending on the value
// of gtk_application_prefers_app_menu(). If the resource "gtk/menus-common.ui"
// is present it will be loaded as well. This is useful for storing items that
// are referenced from both "gtk/menus-appmenu.ui" and
// "gtk/menus-traditional.ui".
// 
// It is also possible to provide the menus manually using
// gtk_application_set_app_menu() and gtk_application_set_menubar().
// 
// Application will also automatically setup an icon search path for the default
// icon theme by appending "icons" to the resource base path. This allows your
// application to easily store its icons as resources. See
// gtk_icon_theme_add_resource_path() for more information.
// 
// If there is a resource located at "gtk/help-overlay.ui" which defines a
// ShortcutsWindow with ID "help_overlay" then GtkApplication associates an
// instance of this shortcuts window with each ApplicationWindow and sets up
// keyboard accelerators (Control-F1 and Control-?) to open it. To create a menu
// item that displays the shortcuts window, associate the item with the action
// win.show-help-overlay.
// 
// 
// A simple application
// 
// A simple example
// (https://git.gnome.org/browse/gtk+/tree/examples/bp/bloatpad.c)
// 
// GtkApplication optionally registers with a session manager of the users
// session (if you set the Application:register-session property) and offers
// various functionality related to the session life-cycle.
// 
// An application can block various ways to end the session with the
// gtk_application_inhibit() function. Typical use cases for this kind of
// inhibiting are long-running, uninterruptible operations, such as burning a CD
// or performing a disk backup. The session manager may not honor the inhibitor,
// but it can be expected to inform the user about the negative consequences of
// ending the session while inhibitors are present.
// 
// 
// See Also
// 
// HowDoI: Using GtkApplication (https://wiki.gnome.org/HowDoI/GtkApplication),
// Getting Started with GTK+: Basics
// (https://developer.gnome.org/gtk3/stable/gtk-getting-started.html#id-1.2.3.3)
	type Application struct {
		gio.Application
		gio.ActionGroup
		gio.ActionMap
		
	}

	// ApplicationClass is an interface that the Application class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ApplicationClass interface {
		gextras.Objector
		_application()
	}

	func (Application) _application() {}

	
	func marshalApplication(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapApplication(obj), nil
	}
	

	
	// NewApplication creates a new Application instance.
// 
// When using Application, it is not necessary to call gtk_init() manually. It
// is called as soon as the application gets registered as the primary instance.
// 
// Concretely, gtk_init() is called in the default handler for the
// #GApplication::startup signal. Therefore, Application subclasses should chain
// up in their #GApplication::startup handler before using any GTK+ API.
// 
// Note that commandline arguments are not passed to gtk_init(). All GTK+
// functionality that is available via commandline arguments can also be
// achieved by setting suitable environment variables such as `G_DEBUG`, so this
// should not be a big problem. If you absolutely must support GTK+ commandline
// arguments, you can explicitly call gtk_init() before creating the application
// instance.
// 
// If non-nil, the application ID must be valid. See
// g_application_id_is_valid().
// 
// If no application ID is given then some features (most notably application
// uniqueness) will be disabled. A null application ID is only allowed with GTK+
// 3.6 or later.
	func NewApplication(applicationId string, flags gio.ApplicationFlags) Application {
var _arg1 *C.gchar // out
var _arg2 C.GApplicationFlags // out
var _cret *C.GtkApplication // in

_arg1 = (*C.gchar)(C.CString(applicationId))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.GApplicationFlags)(flags)

_cret = C.gtk_application_new(_arg1, _arg2)


var _application Application // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_application = Application{
Application: gio.Application{
Object: &externglib.Object{externglib.ToGObject(obj)},
ActionGroup: ActionGroup{
Object: &externglib.Object{externglib.ToGObject(obj)},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
ActionGroup: gio.ActionGroup{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ActionMap: gio.ActionMap{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _application
}
	

	
	// AddAccelerator installs an accelerator that will cause the named action to be
// activated when the key combination specificed by @accelerator is pressed.
// 
// @accelerator must be a string that can be parsed by gtk_accelerator_parse(),
// e.g. "<Primary>q" or “<Control><Alt>p”.
// 
// @action_name must be the name of an action as it would be used in the app
// menu, i.e. actions that have been added to the application are referred to
// with an “app.” prefix, and window-specific actions with a “win.” prefix.
// 
// GtkApplication also extracts accelerators out of “accel” attributes in the
// Models passed to gtk_application_set_app_menu() and
// gtk_application_set_menubar(), which is usually more convenient than calling
// this function for each accelerator.
	func (a Application) AddAccelerator(accelerator string, actionName string, parameter *glib.Variant)  {
var _arg0 *C.GtkApplication // out
var _arg1 *C.gchar // out
var _arg2 *C.gchar // out
var _arg3 *C.GVariant // out

_arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))
_arg1 = (*C.gchar)(C.CString(accelerator))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.gchar)(C.CString(actionName))
defer C.free(unsafe.Pointer(_arg2))
_arg3 = (*C.GVariant)(unsafe.Pointer(parameter.Native()))

C.gtk_application_add_accelerator(_arg0, _arg1, _arg2, _arg3)
}
	
	// AddWindow adds a window to @application.
// 
// This call can only happen after the @application has started; typically, you
// should add new application windows in response to the emission of the
// #GApplication::activate signal.
// 
// This call is equivalent to setting the Window:application property of @window
// to @application.
// 
// Normally, the connection between the application and the window will remain
// until the window is destroyed, but you can explicitly remove it with
// gtk_application_remove_window().
// 
// GTK+ will keep the @application running as long as it has any windows.
	func (a Application) AddWindow(window WindowClass)  {
var _arg0 *C.GtkApplication // out
var _arg1 *C.GtkWindow // out

_arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

C.gtk_application_add_window(_arg0, _arg1)
}
	
	// AccelsForAction gets the accelerators that are currently associated with the
// given action.
	func (a Application) AccelsForAction(detailedActionName string) []string {
var _arg0 *C.GtkApplication // out
var _arg1 *C.gchar // out
var _cret **C.gchar

_arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))
_arg1 = (*C.gchar)(C.CString(detailedActionName))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_application_get_accels_for_action(_arg0, _arg1)


var _utf8s []string

{
var i int
var z *C.gchar
for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
  i++
}

src := unsafe.Slice(_cret, i)
_utf8s = make([]string, i)
for i := range src {
_utf8s[i] = C.GoString(src[i])
defer C.free(unsafe.Pointer(src[i]))
}
}

return _utf8s
}
	
	// ActionsForAccel returns the list of actions (possibly empty) that @accel maps
// to. Each item in the list is a detailed action name in the usual form.
// 
// This might be useful to discover if an accel already exists in order to
// prevent installation of a conflicting accelerator (from an accelerator editor
// or a plugin system, for example). Note that having more than one action per
// accelerator may not be a bad thing and might make sense in cases where the
// actions never appear in the same context.
// 
// In case there are no actions for a given accelerator, an empty array is
// returned. nil is never returned.
// 
// It is a programmer error to pass an invalid accelerator string. If you are
// unsure, check it with gtk_accelerator_parse() first.
	func (a Application) ActionsForAccel(accel string) []string {
var _arg0 *C.GtkApplication // out
var _arg1 *C.gchar // out
var _cret **C.gchar

_arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))
_arg1 = (*C.gchar)(C.CString(accel))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_application_get_actions_for_accel(_arg0, _arg1)


var _utf8s []string

{
var i int
var z *C.gchar
for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
  i++
}

src := unsafe.Slice(_cret, i)
_utf8s = make([]string, i)
for i := range src {
_utf8s[i] = C.GoString(src[i])
defer C.free(unsafe.Pointer(src[i]))
}
}

return _utf8s
}
	
	// ActiveWindow gets the “active” window for the application.
// 
// The active window is the one that was most recently focused (within the
// application). This window may not have the focus at the moment if another
// application has it — this is just the most recently-focused window within
// this application.
	func (a Application) ActiveWindow() Window {
var _arg0 *C.GtkApplication // out
var _cret *C.GtkWindow // in

_arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))

_cret = C.gtk_application_get_active_window(_arg0)


var _window Window // out

_window = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Window)

return _window
}
	
	// AppMenu returns the menu model that has been set with
// gtk_application_set_app_menu().
	func (a Application) AppMenu() gio.MenuModel {
var _arg0 *C.GtkApplication // out
var _cret *C.GMenuModel // in

_arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))

_cret = C.gtk_application_get_app_menu(_arg0)


var _menuModel gio.MenuModel // out

_menuModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.MenuModel)

return _menuModel
}
	
	// MenuByID gets a menu from automatically loaded resources. See [Automatic
// resources][automatic-resources] for more information.
	func (a Application) MenuByID(id string) gio.Menu {
var _arg0 *C.GtkApplication // out
var _arg1 *C.gchar // out
var _cret *C.GMenu // in

_arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))
_arg1 = (*C.gchar)(C.CString(id))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_application_get_menu_by_id(_arg0, _arg1)


var _menu gio.Menu // out

_menu = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.Menu)

return _menu
}
	
	// Menubar returns the menu model that has been set with
// gtk_application_set_menubar().
	func (a Application) Menubar() gio.MenuModel {
var _arg0 *C.GtkApplication // out
var _cret *C.GMenuModel // in

_arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))

_cret = C.gtk_application_get_menubar(_arg0)


var _menuModel gio.MenuModel // out

_menuModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.MenuModel)

return _menuModel
}
	
	// WindowByID returns the ApplicationWindow with the given ID.
// 
// The ID of a ApplicationWindow can be retrieved with
// gtk_application_window_get_id().
	func (a Application) WindowByID(id uint) Window {
var _arg0 *C.GtkApplication // out
var _arg1 C.guint // out
var _cret *C.GtkWindow // in

_arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))
_arg1 = (C.guint)(id)

_cret = C.gtk_application_get_window_by_id(_arg0, _arg1)


var _window Window // out

_window = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Window)

return _window
}
	
	// Inhibit: inform the session manager that certain types of actions should be
// inhibited. This is not guaranteed to work on all platforms and for all types
// of actions.
// 
// Applications should invoke this method when they begin an operation that
// should not be interrupted, such as creating a CD or DVD. The types of actions
// that may be blocked are specified by the @flags parameter. When the
// application completes the operation it should call
// gtk_application_uninhibit() to remove the inhibitor. Note that an application
// can have multiple inhibitors, and all of them must be individually removed.
// Inhibitors are also cleared when the application exits.
// 
// Applications should not expect that they will always be able to block the
// action. In most cases, users will be given the option to force the action to
// take place.
// 
// Reasons should be short and to the point.
// 
// If @window is given, the session manager may point the user to this window to
// find out more about why the action is inhibited.
	func (a Application) Inhibit(window WindowClass, flags ApplicationInhibitFlags, reason string) uint {
var _arg0 *C.GtkApplication // out
var _arg1 *C.GtkWindow // out
var _arg2 C.GtkApplicationInhibitFlags // out
var _arg3 *C.gchar // out
var _cret C.guint // in

_arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
_arg2 = (C.GtkApplicationInhibitFlags)(flags)
_arg3 = (*C.gchar)(C.CString(reason))
defer C.free(unsafe.Pointer(_arg3))

_cret = C.gtk_application_inhibit(_arg0, _arg1, _arg2, _arg3)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// IsInhibited determines if any of the actions specified in @flags are
// currently inhibited (possibly by another application).
// 
// Note that this information may not be available (for example when the
// application is running in a sandbox).
	func (a Application) IsInhibited(flags ApplicationInhibitFlags) bool {
var _arg0 *C.GtkApplication // out
var _arg1 C.GtkApplicationInhibitFlags // out
var _cret C.gboolean // in

_arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))
_arg1 = (C.GtkApplicationInhibitFlags)(flags)

_cret = C.gtk_application_is_inhibited(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ListActionDescriptions lists the detailed action names which have associated
// accelerators. See gtk_application_set_accels_for_action().
	func (a Application) ListActionDescriptions() []string {
var _arg0 *C.GtkApplication // out
var _cret **C.gchar

_arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))

_cret = C.gtk_application_list_action_descriptions(_arg0)


var _utf8s []string

{
var i int
var z *C.gchar
for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
  i++
}

src := unsafe.Slice(_cret, i)
_utf8s = make([]string, i)
for i := range src {
_utf8s[i] = C.GoString(src[i])
defer C.free(unsafe.Pointer(src[i]))
}
}

return _utf8s
}
	
	// PrefersAppMenu determines if the desktop environment in which the application
// is running would prefer an application menu be shown.
// 
// If this function returns true then the application should call
// gtk_application_set_app_menu() with the contents of an application menu,
// which will be shown by the desktop environment. If it returns false then you
// should consider using an alternate approach, such as a menubar.
// 
// The value returned by this function is purely advisory and you are free to
// ignore it. If you call gtk_application_set_app_menu() even if the desktop
// environment doesn't support app menus, then a fallback will be provided.
// 
// Applications are similarly free not to set an app menu even if the desktop
// environment wants to show one. In that case, a fallback will also be created
// by the desktop environment (GNOME, for example, uses a menu with only a
// "Quit" item in it).
// 
// The value returned by this function never changes. Once it returns a
// particular value, it is guaranteed to always return the same value.
// 
// You may only call this function after the application has been registered and
// after the base startup handler has run. You're most likely to want to use
// this from your own startup handler. It may also make sense to consult this
// function while constructing UI (in activate, open or an action activation
// handler) in order to determine if you should show a gear menu or not.
// 
// This function will return false on Mac OS and a default app menu will be
// created automatically with the "usual" contents of that menu typical to most
// Mac OS applications. If you call gtk_application_set_app_menu() anyway, then
// this menu will be replaced with your own.
	func (a Application) PrefersAppMenu() bool {
var _arg0 *C.GtkApplication // out
var _cret C.gboolean // in

_arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))

_cret = C.gtk_application_prefers_app_menu(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// RemoveAccelerator removes an accelerator that has been previously added with
// gtk_application_add_accelerator().
	func (a Application) RemoveAccelerator(actionName string, parameter *glib.Variant)  {
var _arg0 *C.GtkApplication // out
var _arg1 *C.gchar // out
var _arg2 *C.GVariant // out

_arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))
_arg1 = (*C.gchar)(C.CString(actionName))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.GVariant)(unsafe.Pointer(parameter.Native()))

C.gtk_application_remove_accelerator(_arg0, _arg1, _arg2)
}
	
	// RemoveWindow: remove a window from @application.
// 
// If @window belongs to @application then this call is equivalent to setting
// the Window:application property of @window to nil.
// 
// The application may stop running as a result of a call to this function.
	func (a Application) RemoveWindow(window WindowClass)  {
var _arg0 *C.GtkApplication // out
var _arg1 *C.GtkWindow // out

_arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

C.gtk_application_remove_window(_arg0, _arg1)
}
	
	// SetAccelsForAction sets zero or more keyboard accelerators that will trigger
// the given action. The first item in @accels will be the primary accelerator,
// which may be displayed in the UI.
// 
// To remove all accelerators for an action, use an empty, zero-terminated array
// for @accels.
// 
// For the @detailed_action_name, see g_action_parse_detailed_name() and
// g_action_print_detailed_name().
	func (a Application) SetAccelsForAction(detailedActionName string, accels []string)  {
var _arg0 *C.GtkApplication // out
var _arg1 *C.gchar // out
var _arg2 **C.gchar

_arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))
_arg1 = (*C.gchar)(C.CString(detailedActionName))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (**C.gchar)(C.malloc(C.ulong(len(accels)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
defer C.free(unsafe.Pointer(_arg2))
{
out := unsafe.Slice(_arg2, len(accels))
for i := range accels {
out[i] = (*C.gchar)(C.CString(accels[i]))
defer C.free(unsafe.Pointer(out[i]))
}
}

C.gtk_application_set_accels_for_action(_arg0, _arg1, _arg2)
}
	
	// SetAppMenu sets or unsets the application menu for @application.
// 
// This can only be done in the primary instance of the application, after it
// has been registered. #GApplication::startup is a good place to call this.
// 
// The application menu is a single menu containing items that typically impact
// the application as a whole, rather than acting on a specific window or
// document. For example, you would expect to see “Preferences” or “Quit” in an
// application menu, but not “Save” or “Print”.
// 
// If supported, the application menu will be rendered by the desktop
// environment.
// 
// Use the base Map interface to add actions, to respond to the user selecting
// these menu items.
	func (a Application) SetAppMenu(appMenu gio.MenuModelClass)  {
var _arg0 *C.GtkApplication // out
var _arg1 *C.GMenuModel // out

_arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GMenuModel)(unsafe.Pointer(appMenu.Native()))

C.gtk_application_set_app_menu(_arg0, _arg1)
}
	
	// SetMenubar sets or unsets the menubar for windows of @application.
// 
// This is a menubar in the traditional sense.
// 
// This can only be done in the primary instance of the application, after it
// has been registered. #GApplication::startup is a good place to call this.
// 
// Depending on the desktop environment, this may appear at the top of each
// window, or at the top of the screen. In some environments, if both the
// application menu and the menubar are set, the application menu will be
// presented as if it were the first item of the menubar. Other environments
// treat the two as completely separate — for example, the application menu may
// be rendered by the desktop shell while the menubar (if set) remains in each
// individual window.
// 
// Use the base Map interface to add actions, to respond to the user selecting
// these menu items.
	func (a Application) SetMenubar(menubar gio.MenuModelClass)  {
var _arg0 *C.GtkApplication // out
var _arg1 *C.GMenuModel // out

_arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GMenuModel)(unsafe.Pointer(menubar.Native()))

C.gtk_application_set_menubar(_arg0, _arg1)
}
	
	// Uninhibit removes an inhibitor that has been established with
// gtk_application_inhibit(). Inhibitors are also cleared when the application
// exits.
	func (a Application) Uninhibit(cookie uint)  {
var _arg0 *C.GtkApplication // out
var _arg1 C.guint // out

_arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))
_arg1 = (C.guint)(cookie)

C.gtk_application_uninhibit(_arg0, _arg1)
}
	


	// ApplicationWindow is a Window subclass that offers some extra functionality
// for better integration with Application features. Notably, it can handle both
// the application menu as well as the menubar. See
// gtk_application_set_app_menu() and gtk_application_set_menubar().
// 
// This class implements the Group and Map interfaces, to let you add
// window-specific actions that will be exported by the associated Application,
// together with its application-wide actions. Window-specific actions are
// prefixed with the “win.” prefix and application-wide actions are prefixed
// with the “app.” prefix. Actions must be addressed with the prefixed name when
// referring to them from a Model.
// 
// Note that widgets that are placed inside a ApplicationWindow can also
// activate these actions, if they implement the Actionable interface.
// 
// As with Application, the GDK lock will be acquired when processing actions
// arriving from other processes and should therefore be held when activating
// actions locally (if GDK threads are enabled).
// 
// The settings Settings:gtk-shell-shows-app-menu and
// Settings:gtk-shell-shows-menubar tell GTK+ whether the desktop environment is
// showing the application menu and menubar models outside the application as
// part of the desktop shell. For instance, on OS X, both menus will be
// displayed remotely; on Windows neither will be. gnome-shell (starting with
// version 3.4) will display the application menu, but not the menubar.
// 
// If the desktop environment does not display the menubar, then
// ApplicationWindow will automatically show a MenuBar for it. This behaviour
// can be overridden with the ApplicationWindow:show-menubar property. If the
// desktop environment does not display the application menu, then it will
// automatically be included in the menubar or in the windows client-side
// decorations.
// 
// A GtkApplicationWindow with a menubar
// 
//    GtkApplication *app = gtk_application_new ("org.gtk.test", 0);
// 
//    GtkBuilder *builder = gtk_builder_new_from_string (
//        "<interface>"
//        "  <menu id='menubar'>"
//        "    <submenu label='_Edit'>"
//        "      <item label='_Copy' action='win.copy'/>"
//        "      <item label='_Paste' action='win.paste'/>"
//        "    </submenu>"
//        "  </menu>"
//        "</interface>",
//        -1);
// 
//    GMenuModel *menubar = G_MENU_MODEL (gtk_builder_get_object (builder,
//                                                                "menubar"));
//    gtk_application_set_menubar (GTK_APPLICATION (app), menubar);
//    g_object_unref (builder);
// 
//    // ...
// 
//    GtkWidget *window = gtk_application_window_new (app);
// 
// 
// Handling fallback yourself
// 
// A simple example (https://git.gnome.org/browse/gtk+/tree/examples/sunny.c)
// 
// The XML format understood by Builder for Model consists of a toplevel
// `<menu>` element, which contains one or more `<item>` elements. Each `<item>`
// element contains `<attribute>` and `<link>` elements with a mandatory name
// attribute. `<link>` elements have the same content model as `<menu>`. Instead
// of `<link name="submenu>` or `<link name="section">`, you can use `<submenu>`
// or `<section>` elements.
// 
// Attribute values can be translated using gettext, like other Builder content.
// `<attribute>` elements can be marked for translation with a
// `translatable="yes"` attribute. It is also possible to specify message
// context and translator comments, using the context and comments attributes.
// To make use of this, the Builder must have been given the gettext domain to
// use.
// 
// The following attributes are used when constructing menu items: - "label": a
// user-visible string to display - "action": the prefixed name of the action to
// trigger - "target": the parameter to use when activating the action - "icon"
// and "verb-icon": names of icons that may be displayed - "submenu-action":
// name of an action that may be used to determine if a submenu can be opened -
// "hidden-when": a string used to determine when the item will be hidden.
// Possible values include "action-disabled", "action-missing", "macos-menubar".
// 
// The following attributes are used when constructing sections: - "label": a
// user-visible string to use as section heading - "display-hint": a string used
// to determine special formatting for the section. Possible values include
// "horizontal-buttons". - "text-direction": a string used to determine the
// TextDirection to use when "display-hint" is set to "horizontal-buttons".
// Possible values include "rtl", "ltr", and "none".
// 
// The following attributes are used when constructing submenus: - "label": a
// user-visible string to display - "icon": icon name to display
	type ApplicationWindow struct {
		Window
		gio.ActionGroup
		gio.ActionMap
		Buildable
		
	}

	// ApplicationWindowClass is an interface that the ApplicationWindow class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ApplicationWindowClass interface {
		gextras.Objector
		_applicationWindow()
	}

	func (ApplicationWindow) _applicationWindow() {}

	
	func marshalApplicationWindow(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapApplicationWindow(obj), nil
	}
	

	
	// NewApplicationWindow creates a new ApplicationWindow.
	func NewApplicationWindow(application ApplicationClass) ApplicationWindow {
var _arg1 *C.GtkApplication // out
var _cret *C.GtkWidget // in

_arg1 = (*C.GtkApplication)(unsafe.Pointer(application.Native()))

_cret = C.gtk_application_window_new(_arg1)


var _applicationWindow ApplicationWindow // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_applicationWindow = ApplicationWindow{
Window: Window{
Bin: Bin{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
ActionGroup: gio.ActionGroup{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ActionMap: gio.ActionMap{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _applicationWindow
}
	

	
	// HelpOverlay gets the ShortcutsWindow that has been set up with a prior call
// to gtk_application_window_set_help_overlay().
	func (w ApplicationWindow) HelpOverlay() ShortcutsWindow {
var _arg0 *C.GtkApplicationWindow // out
var _cret *C.GtkShortcutsWindow // in

_arg0 = (*C.GtkApplicationWindow)(unsafe.Pointer(w.Native()))

_cret = C.gtk_application_window_get_help_overlay(_arg0)


var _shortcutsWindow ShortcutsWindow // out

_shortcutsWindow = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(ShortcutsWindow)

return _shortcutsWindow
}
	
	// ID returns the unique ID of the window. If the window has not yet been added
// to a Application, returns `0`.
	func (w ApplicationWindow) ID() uint {
var _arg0 *C.GtkApplicationWindow // out
var _cret C.guint // in

_arg0 = (*C.GtkApplicationWindow)(unsafe.Pointer(w.Native()))

_cret = C.gtk_application_window_get_id(_arg0)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// ShowMenubar returns whether the window will display a menubar for the app
// menu and menubar as needed.
	func (w ApplicationWindow) ShowMenubar() bool {
var _arg0 *C.GtkApplicationWindow // out
var _cret C.gboolean // in

_arg0 = (*C.GtkApplicationWindow)(unsafe.Pointer(w.Native()))

_cret = C.gtk_application_window_get_show_menubar(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetHelpOverlay associates a shortcuts window with the application window, and
// sets up an action with the name win.show-help-overlay to present it.
// 
// @window takes resposibility for destroying @help_overlay.
	func (w ApplicationWindow) SetHelpOverlay(helpOverlay ShortcutsWindowClass)  {
var _arg0 *C.GtkApplicationWindow // out
var _arg1 *C.GtkShortcutsWindow // out

_arg0 = (*C.GtkApplicationWindow)(unsafe.Pointer(w.Native()))
_arg1 = (*C.GtkShortcutsWindow)(unsafe.Pointer(helpOverlay.Native()))

C.gtk_application_window_set_help_overlay(_arg0, _arg1)
}
	
	// SetShowMenubar sets whether the window will display a menubar for the app
// menu and menubar as needed.
	func (w ApplicationWindow) SetShowMenubar(showMenubar bool)  {
var _arg0 *C.GtkApplicationWindow // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkApplicationWindow)(unsafe.Pointer(w.Native()))
if showMenubar { _arg1 = C.TRUE }

C.gtk_application_window_set_show_menubar(_arg0, _arg1)
}
	


	// Arrow: gtkArrow should be used to draw simple arrows that need to point in
// one of the four cardinal directions (up, down, left, or right). The style of
// the arrow can be one of shadow in, shadow out, etched in, or etched out. Note
// that these directions and style types may be amended in versions of GTK+ to
// come.
// 
// GtkArrow will fill any space alloted to it, but since it is inherited from
// Misc, it can be padded and/or aligned, to fill exactly the space the
// programmer desires.
// 
// Arrows are created with a call to gtk_arrow_new(). The direction or style of
// an arrow can be changed after creation by using gtk_arrow_set().
// 
// GtkArrow has been deprecated; you can simply use a Image with a suitable icon
// name, such as “pan-down-symbolic“. When replacing GtkArrow by an image, pay
// attention to the fact that GtkArrow is doing automatic flipping between
// K_ARROW_LEFT and K_ARROW_RIGHT, depending on the text direction. To get the
// same effect with an image, use the icon names “pan-start-symbolic“ and
// “pan-end-symbolic“, which react to the text direction.
	type Arrow struct {
		Misc
		Buildable
		
	}

	// ArrowClass is an interface that the Arrow class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ArrowClass interface {
		gextras.Objector
		_arrow()
	}

	func (Arrow) _arrow() {}

	
	func marshalArrow(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapArrow(obj), nil
	}
	

	
	// NewArrow creates a new Arrow widget.
	func NewArrow(arrowType ArrowType, shadowType ShadowType) Arrow {
var _arg1 C.GtkArrowType // out
var _arg2 C.GtkShadowType // out
var _cret *C.GtkWidget // in

_arg1 = (C.GtkArrowType)(arrowType)
_arg2 = (C.GtkShadowType)(shadowType)

_cret = C.gtk_arrow_new(_arg1, _arg2)


var _arrow Arrow // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_arrow = Arrow{
Misc: Misc{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _arrow
}
	

	
	// Set sets the direction and style of the Arrow, @arrow.
	func (a Arrow) Set(arrowType ArrowType, shadowType ShadowType)  {
var _arg0 *C.GtkArrow // out
var _arg1 C.GtkArrowType // out
var _arg2 C.GtkShadowType // out

_arg0 = (*C.GtkArrow)(unsafe.Pointer(a.Native()))
_arg1 = (C.GtkArrowType)(arrowType)
_arg2 = (C.GtkShadowType)(shadowType)

C.gtk_arrow_set(_arg0, _arg1, _arg2)
}
	


	// AspectFrame: the AspectFrame is useful when you want pack a widget so that it
// can resize but always retains the same aspect ratio. For instance, one might
// be drawing a small preview of a larger image. AspectFrame derives from Frame,
// so it can draw a label and a frame around the child. The frame will be
// “shrink-wrapped” to the size of the child.
// 
// 
// CSS nodes
// 
// GtkAspectFrame uses a CSS node with name frame.
	type AspectFrame struct {
		Frame
		Buildable
		
	}

	// AspectFrameClass is an interface that the AspectFrame class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type AspectFrameClass interface {
		gextras.Objector
		_aspectFrame()
	}

	func (AspectFrame) _aspectFrame() {}

	
	func marshalAspectFrame(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapAspectFrame(obj), nil
	}
	

	
	// NewAspectFrame: create a new AspectFrame.
	func NewAspectFrame(label string, xalign float32, yalign float32, ratio float32, obeyChild bool) AspectFrame {
var _arg1 *C.gchar // out
var _arg2 C.gfloat // out
var _arg3 C.gfloat // out
var _arg4 C.gfloat // out
var _arg5 C.gboolean // out
var _cret *C.GtkWidget // in

_arg1 = (*C.gchar)(C.CString(label))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.gfloat)(xalign)
_arg3 = (C.gfloat)(yalign)
_arg4 = (C.gfloat)(ratio)
if obeyChild { _arg5 = C.TRUE }

_cret = C.gtk_aspect_frame_new(_arg1, _arg2, _arg3, _arg4, _arg5)


var _aspectFrame AspectFrame // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_aspectFrame = AspectFrame{
Frame: Frame{
Bin: Bin{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _aspectFrame
}
	

	
	// Set: set parameters for an existing AspectFrame.
	func (a AspectFrame) Set(xalign float32, yalign float32, ratio float32, obeyChild bool)  {
var _arg0 *C.GtkAspectFrame // out
var _arg1 C.gfloat // out
var _arg2 C.gfloat // out
var _arg3 C.gfloat // out
var _arg4 C.gboolean // out

_arg0 = (*C.GtkAspectFrame)(unsafe.Pointer(a.Native()))
_arg1 = (C.gfloat)(xalign)
_arg2 = (C.gfloat)(yalign)
_arg3 = (C.gfloat)(ratio)
if obeyChild { _arg4 = C.TRUE }

C.gtk_aspect_frame_set(_arg0, _arg1, _arg2, _arg3, _arg4)
}
	


	// Assistant: a Assistant is a widget used to represent a generally complex
// operation splitted in several steps, guiding the user through its pages and
// controlling the page flow to collect the necessary data.
// 
// The design of GtkAssistant is that it controls what buttons to show and to
// make sensitive, based on what it knows about the page sequence and the
// [type][GtkAssistantPageType] of each page, in addition to state information
// like the page [completion][gtk-assistant-set-page-complete] and
// [committed][gtk-assistant-commit] status.
// 
// If you have a case that doesn’t quite fit in Assistants way of handling
// buttons, you can use the K_ASSISTANT_PAGE_CUSTOM page type and handle buttons
// yourself.
// 
// 
// GtkAssistant as GtkBuildable
// 
// The GtkAssistant implementation of the Buildable interface exposes the
// @action_area as internal children with the name “action_area”.
// 
// To add pages to an assistant in Builder, simply add it as a child to the
// GtkAssistant object, and set its child properties as necessary.
// 
// 
// CSS nodes
// 
// GtkAssistant has a single CSS node with the name assistant.
	type Assistant struct {
		Window
		Buildable
		
	}

	// AssistantClass is an interface that the Assistant class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type AssistantClass interface {
		gextras.Objector
		_assistant()
	}

	func (Assistant) _assistant() {}

	
	func marshalAssistant(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapAssistant(obj), nil
	}
	

	
	// NewAssistant creates a new Assistant.
	func NewAssistant() Assistant {
var _cret *C.GtkWidget // in

_cret = C.gtk_assistant_new()


var _assistant Assistant // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_assistant = Assistant{
Window: Window{
Bin: Bin{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _assistant
}
	

	
	// AddActionWidget adds a widget to the action area of a Assistant.
	func (a Assistant) AddActionWidget(child WidgetClass)  {
var _arg0 *C.GtkAssistant // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

C.gtk_assistant_add_action_widget(_arg0, _arg1)
}
	
	// AppendPage appends a page to the @assistant.
	func (a Assistant) AppendPage(page WidgetClass) int {
var _arg0 *C.GtkAssistant // out
var _arg1 *C.GtkWidget // out
var _cret C.gint // in

_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(page.Native()))

_cret = C.gtk_assistant_append_page(_arg0, _arg1)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Commit erases the visited page history so the back button is not shown on the
// current page, and removes the cancel button from subsequent pages.
// 
// Use this when the information provided up to the current page is hereafter
// deemed permanent and cannot be modified or undone. For example, showing a
// progress page to track a long-running, unreversible operation after the user
// has clicked apply on a confirmation page.
	func (a Assistant) Commit()  {
var _arg0 *C.GtkAssistant // out

_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))

C.gtk_assistant_commit(_arg0)
}
	
	// CurrentPage returns the page number of the current page.
	func (a Assistant) CurrentPage() int {
var _arg0 *C.GtkAssistant // out
var _cret C.gint // in

_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))

_cret = C.gtk_assistant_get_current_page(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// NPages returns the number of pages in the @assistant
	func (a Assistant) NPages() int {
var _arg0 *C.GtkAssistant // out
var _cret C.gint // in

_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))

_cret = C.gtk_assistant_get_n_pages(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// NthPage returns the child widget contained in page number @page_num.
	func (a Assistant) NthPage(pageNum int) Widget {
var _arg0 *C.GtkAssistant // out
var _arg1 C.gint // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
_arg1 = (C.gint)(pageNum)

_cret = C.gtk_assistant_get_nth_page(_arg0, _arg1)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// PageComplete gets whether @page is complete.
	func (a Assistant) PageComplete(page WidgetClass) bool {
var _arg0 *C.GtkAssistant // out
var _arg1 *C.GtkWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(page.Native()))

_cret = C.gtk_assistant_get_page_complete(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// PageHasPadding gets whether page has padding.
	func (a Assistant) PageHasPadding(page WidgetClass) bool {
var _arg0 *C.GtkAssistant // out
var _arg1 *C.GtkWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(page.Native()))

_cret = C.gtk_assistant_get_page_has_padding(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// PageHeaderImage gets the header image for @page.
	func (a Assistant) PageHeaderImage(page WidgetClass) gdkpixbuf.Pixbuf {
var _arg0 *C.GtkAssistant // out
var _arg1 *C.GtkWidget // out
var _cret *C.GdkPixbuf // in

_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(page.Native()))

_cret = C.gtk_assistant_get_page_header_image(_arg0, _arg1)


var _pixbuf gdkpixbuf.Pixbuf // out

_pixbuf = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdkpixbuf.Pixbuf)

return _pixbuf
}
	
	// PageSideImage gets the side image for @page.
	func (a Assistant) PageSideImage(page WidgetClass) gdkpixbuf.Pixbuf {
var _arg0 *C.GtkAssistant // out
var _arg1 *C.GtkWidget // out
var _cret *C.GdkPixbuf // in

_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(page.Native()))

_cret = C.gtk_assistant_get_page_side_image(_arg0, _arg1)


var _pixbuf gdkpixbuf.Pixbuf // out

_pixbuf = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdkpixbuf.Pixbuf)

return _pixbuf
}
	
	// PageTitle gets the title for @page.
	func (a Assistant) PageTitle(page WidgetClass) string {
var _arg0 *C.GtkAssistant // out
var _arg1 *C.GtkWidget // out
var _cret *C.gchar // in

_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(page.Native()))

_cret = C.gtk_assistant_get_page_title(_arg0, _arg1)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// PageType gets the page type of @page.
	func (a Assistant) PageType(page WidgetClass) AssistantPageType {
var _arg0 *C.GtkAssistant // out
var _arg1 *C.GtkWidget // out
var _cret C.GtkAssistantPageType // in

_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(page.Native()))

_cret = C.gtk_assistant_get_page_type(_arg0, _arg1)


var _assistantPageType AssistantPageType // out

_assistantPageType = AssistantPageType(_cret)

return _assistantPageType
}
	
	// InsertPage inserts a page in the @assistant at a given position.
	func (a Assistant) InsertPage(page WidgetClass, position int) int {
var _arg0 *C.GtkAssistant // out
var _arg1 *C.GtkWidget // out
var _arg2 C.gint // out
var _cret C.gint // in

_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(page.Native()))
_arg2 = (C.gint)(position)

_cret = C.gtk_assistant_insert_page(_arg0, _arg1, _arg2)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// NextPage: navigate to the next page.
// 
// It is a programming error to call this function when there is no next page.
// 
// This function is for use when creating pages of the K_ASSISTANT_PAGE_CUSTOM
// type.
	func (a Assistant) NextPage()  {
var _arg0 *C.GtkAssistant // out

_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))

C.gtk_assistant_next_page(_arg0)
}
	
	// PrependPage prepends a page to the @assistant.
	func (a Assistant) PrependPage(page WidgetClass) int {
var _arg0 *C.GtkAssistant // out
var _arg1 *C.GtkWidget // out
var _cret C.gint // in

_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(page.Native()))

_cret = C.gtk_assistant_prepend_page(_arg0, _arg1)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// PreviousPage: navigate to the previous visited page.
// 
// It is a programming error to call this function when no previous page is
// available.
// 
// This function is for use when creating pages of the K_ASSISTANT_PAGE_CUSTOM
// type.
	func (a Assistant) PreviousPage()  {
var _arg0 *C.GtkAssistant // out

_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))

C.gtk_assistant_previous_page(_arg0)
}
	
	// RemoveActionWidget removes a widget from the action area of a Assistant.
	func (a Assistant) RemoveActionWidget(child WidgetClass)  {
var _arg0 *C.GtkAssistant // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

C.gtk_assistant_remove_action_widget(_arg0, _arg1)
}
	
	// RemovePage removes the @page_num’s page from @assistant.
	func (a Assistant) RemovePage(pageNum int)  {
var _arg0 *C.GtkAssistant // out
var _arg1 C.gint // out

_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
_arg1 = (C.gint)(pageNum)

C.gtk_assistant_remove_page(_arg0, _arg1)
}
	
	// SetCurrentPage switches the page to @page_num.
// 
// Note that this will only be necessary in custom buttons, as the @assistant
// flow can be set with gtk_assistant_set_forward_page_func().
	func (a Assistant) SetCurrentPage(pageNum int)  {
var _arg0 *C.GtkAssistant // out
var _arg1 C.gint // out

_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
_arg1 = (C.gint)(pageNum)

C.gtk_assistant_set_current_page(_arg0, _arg1)
}
	
	// SetPageComplete sets whether @page contents are complete.
// 
// This will make @assistant update the buttons state to be able to continue the
// task.
	func (a Assistant) SetPageComplete(page WidgetClass, complete bool)  {
var _arg0 *C.GtkAssistant // out
var _arg1 *C.GtkWidget // out
var _arg2 C.gboolean // out

_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(page.Native()))
if complete { _arg2 = C.TRUE }

C.gtk_assistant_set_page_complete(_arg0, _arg1, _arg2)
}
	
	// SetPageHasPadding sets whether the assistant is adding padding around the
// page.
	func (a Assistant) SetPageHasPadding(page WidgetClass, hasPadding bool)  {
var _arg0 *C.GtkAssistant // out
var _arg1 *C.GtkWidget // out
var _arg2 C.gboolean // out

_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(page.Native()))
if hasPadding { _arg2 = C.TRUE }

C.gtk_assistant_set_page_has_padding(_arg0, _arg1, _arg2)
}
	
	// SetPageHeaderImage sets a header image for @page.
	func (a Assistant) SetPageHeaderImage(page WidgetClass, pixbuf gdkpixbuf.PixbufClass)  {
var _arg0 *C.GtkAssistant // out
var _arg1 *C.GtkWidget // out
var _arg2 *C.GdkPixbuf // out

_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(page.Native()))
_arg2 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))

C.gtk_assistant_set_page_header_image(_arg0, _arg1, _arg2)
}
	
	// SetPageSideImage sets a side image for @page.
// 
// This image used to be displayed in the side area of the assistant when @page
// is the current page.
	func (a Assistant) SetPageSideImage(page WidgetClass, pixbuf gdkpixbuf.PixbufClass)  {
var _arg0 *C.GtkAssistant // out
var _arg1 *C.GtkWidget // out
var _arg2 *C.GdkPixbuf // out

_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(page.Native()))
_arg2 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))

C.gtk_assistant_set_page_side_image(_arg0, _arg1, _arg2)
}
	
	// SetPageTitle sets a title for @page.
// 
// The title is displayed in the header area of the assistant when @page is the
// current page.
	func (a Assistant) SetPageTitle(page WidgetClass, title string)  {
var _arg0 *C.GtkAssistant // out
var _arg1 *C.GtkWidget // out
var _arg2 *C.gchar // out

_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(page.Native()))
_arg2 = (*C.gchar)(C.CString(title))
defer C.free(unsafe.Pointer(_arg2))

C.gtk_assistant_set_page_title(_arg0, _arg1, _arg2)
}
	
	// SetPageType sets the page type for @page.
// 
// The page type determines the page behavior in the @assistant.
	func (a Assistant) SetPageType(page WidgetClass, typ AssistantPageType)  {
var _arg0 *C.GtkAssistant // out
var _arg1 *C.GtkWidget // out
var _arg2 C.GtkAssistantPageType // out

_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(page.Native()))
_arg2 = (C.GtkAssistantPageType)(typ)

C.gtk_assistant_set_page_type(_arg0, _arg1, _arg2)
}
	
	// UpdateButtonsState forces @assistant to recompute the buttons state.
// 
// GTK+ automatically takes care of this in most situations, e.g. when the user
// goes to a different page, or when the visibility or completeness of a page
// changes.
// 
// One situation where it can be necessary to call this function is when
// changing a value on the current page affects the future page flow of the
// assistant.
	func (a Assistant) UpdateButtonsState()  {
var _arg0 *C.GtkAssistant // out

_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))

C.gtk_assistant_update_buttons_state(_arg0)
}
	


	// Bin: the Bin widget is a container with just one child. It is not very useful
// itself, but it is useful for deriving subclasses, since it provides common
// code needed for handling a single child widget.
// 
// Many GTK+ widgets are subclasses of Bin, including Window, Button, Frame,
// HandleBox or ScrolledWindow.
	type Bin struct {
		Container
		Buildable
		
	}

	// BinClass is an interface that the Bin class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type BinClass interface {
		gextras.Objector
		_bin()
	}

	func (Bin) _bin() {}

	
	func marshalBin(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapBin(obj), nil
	}
	

	

	
	// Child gets the child of the Bin, or nil if the bin contains no child widget.
// The returned widget does not have a reference added, so you do not need to
// unref it.
	func (b Bin) Child() Widget {
var _arg0 *C.GtkBin // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkBin)(unsafe.Pointer(b.Native()))

_cret = C.gtk_bin_get_child(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	


	// Box: the GtkBox widget arranges child widgets into a single row or column,
// depending upon the value of its Orientable:orientation property. Within the
// other dimension, all children are allocated the same size. Of course, the
// Widget:halign and Widget:valign properties can be used on the children to
// influence their allocation.
// 
// GtkBox uses a notion of packing. Packing refers to adding widgets with
// reference to a particular position in a Container. For a GtkBox, there are
// two reference positions: the start and the end of the box. For a vertical
// Box, the start is defined as the top of the box and the end is defined as the
// bottom. For a horizontal Box the start is defined as the left side and the
// end is defined as the right side.
// 
// Use repeated calls to gtk_box_pack_start() to pack widgets into a GtkBox from
// start to end. Use gtk_box_pack_end() to add widgets from end to start. You
// may intersperse these calls and add widgets from both ends of the same
// GtkBox.
// 
// Because GtkBox is a Container, you may also use gtk_container_add() to insert
// widgets into the box, and they will be packed with the default values for
// expand and fill child properties. Use gtk_container_remove() to remove
// widgets from the GtkBox.
// 
// Use gtk_box_set_homogeneous() to specify whether or not all children of the
// GtkBox are forced to get the same amount of space.
// 
// Use gtk_box_set_spacing() to determine how much space will be minimally
// placed between all children in the GtkBox. Note that spacing is added between
// the children, while padding added by gtk_box_pack_start() or
// gtk_box_pack_end() is added on either side of the widget it belongs to.
// 
// Use gtk_box_reorder_child() to move a GtkBox child to a different place in
// the box.
// 
// Use gtk_box_set_child_packing() to reset the expand, fill and padding child
// properties. Use gtk_box_query_child_packing() to query these fields.
// 
// 
// CSS nodes
// 
// GtkBox uses a single CSS node with name box.
// 
// In horizontal orientation, the nodes of the children are always arranged from
// left to right. So :first-child will always select the leftmost child,
// regardless of text direction.
	type Box struct {
		Container
		Buildable
		Orientable
		
	}

	// BoxClass is an interface that the Box class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type BoxClass interface {
		gextras.Objector
		_box()
	}

	func (Box) _box() {}

	
	func marshalBox(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapBox(obj), nil
	}
	

	
	// NewBox creates a new Box.
	func NewBox(orientation Orientation, spacing int) Box {
var _arg1 C.GtkOrientation // out
var _arg2 C.gint // out
var _cret *C.GtkWidget // in

_arg1 = (C.GtkOrientation)(orientation)
_arg2 = (C.gint)(spacing)

_cret = C.gtk_box_new(_arg1, _arg2)


var _box Box // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_box = Box{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _box
}
	

	
	// BaselinePosition gets the value set by gtk_box_set_baseline_position().
	func (b Box) BaselinePosition() BaselinePosition {
var _arg0 *C.GtkBox // out
var _cret C.GtkBaselinePosition // in

_arg0 = (*C.GtkBox)(unsafe.Pointer(b.Native()))

_cret = C.gtk_box_get_baseline_position(_arg0)


var _baselinePosition BaselinePosition // out

_baselinePosition = BaselinePosition(_cret)

return _baselinePosition
}
	
	// CenterWidget retrieves the center widget of the box.
	func (b Box) CenterWidget() Widget {
var _arg0 *C.GtkBox // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkBox)(unsafe.Pointer(b.Native()))

_cret = C.gtk_box_get_center_widget(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// Homogeneous returns whether the box is homogeneous (all children are the same
// size). See gtk_box_set_homogeneous().
	func (b Box) Homogeneous() bool {
var _arg0 *C.GtkBox // out
var _cret C.gboolean // in

_arg0 = (*C.GtkBox)(unsafe.Pointer(b.Native()))

_cret = C.gtk_box_get_homogeneous(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Spacing gets the value set by gtk_box_set_spacing().
	func (b Box) Spacing() int {
var _arg0 *C.GtkBox // out
var _cret C.gint // in

_arg0 = (*C.GtkBox)(unsafe.Pointer(b.Native()))

_cret = C.gtk_box_get_spacing(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// PackEnd adds @child to @box, packed with reference to the end of @box. The
// @child is packed after (away from end of) any other child packed with
// reference to the end of @box.
	func (b Box) PackEnd(child WidgetClass, expand bool, fill bool, padding uint)  {
var _arg0 *C.GtkBox // out
var _arg1 *C.GtkWidget // out
var _arg2 C.gboolean // out
var _arg3 C.gboolean // out
var _arg4 C.guint // out

_arg0 = (*C.GtkBox)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
if expand { _arg2 = C.TRUE }
if fill { _arg3 = C.TRUE }
_arg4 = (C.guint)(padding)

C.gtk_box_pack_end(_arg0, _arg1, _arg2, _arg3, _arg4)
}
	
	// PackStart adds @child to @box, packed with reference to the start of @box.
// The @child is packed after any other child packed with reference to the start
// of @box.
	func (b Box) PackStart(child WidgetClass, expand bool, fill bool, padding uint)  {
var _arg0 *C.GtkBox // out
var _arg1 *C.GtkWidget // out
var _arg2 C.gboolean // out
var _arg3 C.gboolean // out
var _arg4 C.guint // out

_arg0 = (*C.GtkBox)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
if expand { _arg2 = C.TRUE }
if fill { _arg3 = C.TRUE }
_arg4 = (C.guint)(padding)

C.gtk_box_pack_start(_arg0, _arg1, _arg2, _arg3, _arg4)
}
	
	// QueryChildPacking obtains information about how @child is packed into @box.
	func (b Box) QueryChildPacking(child WidgetClass) (expand bool, fill bool, padding uint, packType PackType) {
var _arg0 *C.GtkBox // out
var _arg1 *C.GtkWidget // out
var _arg2 C.gboolean // in
var _arg3 C.gboolean // in
var _arg4 C.guint // in
var _arg5 C.GtkPackType // in

_arg0 = (*C.GtkBox)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

C.gtk_box_query_child_packing(_arg0, _arg1, &_arg2, &_arg3, &_arg4, &_arg5)

var _expand bool // out
var _fill bool // out
var _padding uint // out
var _packType PackType // out

if _arg2 { _expand = true }
if _arg3 { _fill = true }
_padding = (uint)(_arg4)
_packType = PackType(_arg5)

return _expand, _fill, _padding, _packType
}
	
	// ReorderChild moves @child to a new @position in the list of @box children.
// The list contains widgets packed K_PACK_START as well as widgets packed
// K_PACK_END, in the order that these widgets were added to @box.
// 
// A widget’s position in the @box children list determines where the widget is
// packed into @box. A child widget at some position in the list will be packed
// just after all other widgets of the same packing type that appear earlier in
// the list.
	func (b Box) ReorderChild(child WidgetClass, position int)  {
var _arg0 *C.GtkBox // out
var _arg1 *C.GtkWidget // out
var _arg2 C.gint // out

_arg0 = (*C.GtkBox)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
_arg2 = (C.gint)(position)

C.gtk_box_reorder_child(_arg0, _arg1, _arg2)
}
	
	// SetBaselinePosition sets the baseline position of a box. This affects only
// horizontal boxes with at least one baseline aligned child. If there is more
// vertical space available than requested, and the baseline is not allocated by
// the parent then @position is used to allocate the baseline wrt the extra
// space available.
	func (b Box) SetBaselinePosition(position BaselinePosition)  {
var _arg0 *C.GtkBox // out
var _arg1 C.GtkBaselinePosition // out

_arg0 = (*C.GtkBox)(unsafe.Pointer(b.Native()))
_arg1 = (C.GtkBaselinePosition)(position)

C.gtk_box_set_baseline_position(_arg0, _arg1)
}
	
	// SetCenterWidget sets a center widget; that is a child widget that will be
// centered with respect to the full width of the box, even if the children at
// either side take up different amounts of space.
	func (b Box) SetCenterWidget(widget WidgetClass)  {
var _arg0 *C.GtkBox // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkBox)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

C.gtk_box_set_center_widget(_arg0, _arg1)
}
	
	// SetChildPacking sets the way @child is packed into @box.
	func (b Box) SetChildPacking(child WidgetClass, expand bool, fill bool, padding uint, packType PackType)  {
var _arg0 *C.GtkBox // out
var _arg1 *C.GtkWidget // out
var _arg2 C.gboolean // out
var _arg3 C.gboolean // out
var _arg4 C.guint // out
var _arg5 C.GtkPackType // out

_arg0 = (*C.GtkBox)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
if expand { _arg2 = C.TRUE }
if fill { _arg3 = C.TRUE }
_arg4 = (C.guint)(padding)
_arg5 = (C.GtkPackType)(packType)

C.gtk_box_set_child_packing(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
}
	
	// SetHomogeneous sets the Box:homogeneous property of @box, controlling whether
// or not all children of @box are given equal space in the box.
	func (b Box) SetHomogeneous(homogeneous bool)  {
var _arg0 *C.GtkBox // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkBox)(unsafe.Pointer(b.Native()))
if homogeneous { _arg1 = C.TRUE }

C.gtk_box_set_homogeneous(_arg0, _arg1)
}
	
	// SetSpacing sets the Box:spacing property of @box, which is the number of
// pixels to place between children of @box.
	func (b Box) SetSpacing(spacing int)  {
var _arg0 *C.GtkBox // out
var _arg1 C.gint // out

_arg0 = (*C.GtkBox)(unsafe.Pointer(b.Native()))
_arg1 = (C.gint)(spacing)

C.gtk_box_set_spacing(_arg0, _arg1)
}
	


	// Builder: a GtkBuilder is an auxiliary object that reads textual descriptions
// of a user interface and instantiates the described objects. To create a
// GtkBuilder from a user interface description, call
// gtk_builder_new_from_file(), gtk_builder_new_from_resource() or
// gtk_builder_new_from_string().
// 
// In the (unusual) case that you want to add user interface descriptions from
// multiple sources to the same GtkBuilder you can call gtk_builder_new() to get
// an empty builder and populate it by (multiple) calls to
// gtk_builder_add_from_file(), gtk_builder_add_from_resource() or
// gtk_builder_add_from_string().
// 
// A GtkBuilder holds a reference to all objects that it has constructed and
// drops these references when it is finalized. This finalization can cause the
// destruction of non-widget objects or widgets which are not contained in a
// toplevel window. For toplevel windows constructed by a builder, it is the
// responsibility of the user to call gtk_widget_destroy() to get rid of them
// and all the widgets they contain.
// 
// The functions gtk_builder_get_object() and gtk_builder_get_objects() can be
// used to access the widgets in the interface by the names assigned to them
// inside the UI description. Toplevel windows returned by these functions will
// stay around until the user explicitly destroys them with
// gtk_widget_destroy(). Other widgets will either be part of a larger hierarchy
// constructed by the builder (in which case you should not have to worry about
// their lifecycle), or without a parent, in which case they have to be added to
// some container to make use of them. Non-widget objects need to be reffed with
// g_object_ref() to keep them beyond the lifespan of the builder.
// 
// The function gtk_builder_connect_signals() and variants thereof can be used
// to connect handlers to the named signals in the description.
// 
// 
// GtkBuilder UI Definitions
// 
// GtkBuilder parses textual descriptions of user interfaces which are specified
// in an XML format which can be roughly described by the RELAX NG schema below.
// We refer to these descriptions as “GtkBuilder UI definitions” or just “UI
// definitions” if the context is clear. Do not confuse GtkBuilder UI
// Definitions with [GtkUIManager UI Definitions][XML-UI], which are more
// limited in scope. It is common to use `.ui` as the filename extension for
// files containing GtkBuilder UI definitions.
// 
// RELAX NG Compact Syntax
// (https://gitlab.gnome.org/GNOME/gtk/-/blob/gtk-3-24/gtk/gtkbuilder.rnc)
// 
// The toplevel element is <interface>. It optionally takes a “domain”
// attribute, which will make the builder look for translated strings using
// dgettext() in the domain specified. This can also be done by calling
// gtk_builder_set_translation_domain() on the builder. Objects are described by
// <object> elements, which can contain <property> elements to set properties,
// <signal> elements which connect signals to handlers, and <child> elements,
// which describe child objects (most often widgets inside a container, but also
// e.g. actions in an action group, or columns in a tree model). A <child>
// element contains an <object> element which describes the child object. The
// target toolkit version(s) are described by <requires> elements, the “lib”
// attribute specifies the widget library in question (currently the only
// supported value is “gtk+”) and the “version” attribute specifies the target
// version in the form “<major>.<minor>”. The builder will error out if the
// version requirements are not met.
// 
// Typically, the specific kind of object represented by an <object> element is
// specified by the “class” attribute. If the type has not been loaded yet, GTK+
// tries to find the get_type() function from the class name by applying
// heuristics. This works in most cases, but if necessary, it is possible to
// specify the name of the get_type() function explictly with the "type-func"
// attribute. As a special case, GtkBuilder allows to use an object that has
// been constructed by a UIManager in another part of the UI definition by
// specifying the id of the UIManager in the “constructor” attribute and the
// name of the object in the “id” attribute.
// 
// Objects may be given a name with the “id” attribute, which allows the
// application to retrieve them from the builder with gtk_builder_get_object().
// An id is also necessary to use the object as property value in other parts of
// the UI definition. GTK+ reserves ids starting and ending with ___ (3
// underscores) for its own purposes.
// 
// Setting properties of objects is pretty straightforward with the <property>
// element: the “name” attribute specifies the name of the property, and the
// content of the element specifies the value. If the “translatable” attribute
// is set to a true value, GTK+ uses gettext() (or dgettext() if the builder has
// a translation domain set) to find a translation for the value. This happens
// before the value is parsed, so it can be used for properties of any type, but
// it is probably most useful for string properties. It is also possible to
// specify a context to disambiguate short strings, and comments which may help
// the translators.
// 
// GtkBuilder can parse textual representations for the most common property
// types: characters, strings, integers, floating-point numbers, booleans
// (strings like “TRUE”, “t”, “yes”, “y”, “1” are interpreted as true, strings
// like “FALSE”, “f”, “no”, “n”, “0” are interpreted as false), enumerations
// (can be specified by their name, nick or integer value), flags (can be
// specified by their name, nick, integer value, optionally combined with “|”,
// e.g. “GTK_VISIBLE|GTK_REALIZED”) and colors (in a format understood by
// gdk_rgba_parse()).
// 
// GVariants can be specified in the format understood by g_variant_parse(), and
// pixbufs can be specified as a filename of an image file to load.
// 
// Objects can be referred to by their name and by default refer to objects
// declared in the local xml fragment and objects exposed via
// gtk_builder_expose_object(). In general, GtkBuilder allows forward references
// to objects — declared in the local xml; an object doesn’t have to be
// constructed before it can be referred to. The exception to this rule is that
// an object has to be constructed before it can be used as the value of a
// construct-only property.
// 
// It is also possible to bind a property value to another object's property
// value using the attributes "bind-source" to specify the source object of the
// binding, "bind-property" to specify the source property and optionally
// "bind-flags" to specify the binding flags. Internally builder implements this
// using GBinding objects. For more information see g_object_bind_property()
// 
// Signal handlers are set up with the <signal> element. The “name” attribute
// specifies the name of the signal, and the “handler” attribute specifies the
// function to connect to the signal. By default, GTK+ tries to find the handler
// using g_module_symbol(), but this can be changed by passing a custom
// BuilderConnectFunc to gtk_builder_connect_signals_full(). The remaining
// attributes, “after”, “swapped” and “object”, have the same meaning as the
// corresponding parameters of the g_signal_connect_object() or
// g_signal_connect_data() functions. A “last_modification_time” attribute is
// also allowed, but it does not have a meaning to the builder.
// 
// Sometimes it is necessary to refer to widgets which have implicitly been
// constructed by GTK+ as part of a composite widget, to set properties on them
// or to add further children (e.g. the @vbox of a Dialog). This can be achieved
// by setting the “internal-child” property of the <child> element to a true
// value. Note that GtkBuilder still requires an <object> element for the
// internal child, even if it has already been constructed.
// 
// A number of widgets have different places where a child can be added (e.g.
// tabs vs. page content in notebooks). This can be reflected in a UI definition
// by specifying the “type” attribute on a <child> The possible values for the
// “type” attribute are described in the sections describing the widget-specific
// portions of UI definitions.
// 
// A GtkBuilder UI Definition
// 
//    <interface>
//      <object class="GtkDialog" id="dialog1">
//        <child internal-child="vbox">
//          <object class="GtkBox" id="vbox1">
//            <property name="border-width">10</property>
//            <child internal-child="action_area">
//              <object class="GtkButtonBox" id="hbuttonbox1">
//                <property name="border-width">20</property>
//                <child>
//                  <object class="GtkButton" id="ok_button">
//                    <property name="label">gtk-ok</property>
//                    <property name="use-stock">TRUE</property>
//                    <signal name="clicked" handler="ok_button_clicked"/>
//                  </object>
//                </child>
//              </object>
//            </child>
//          </object>
//        </child>
//      </object>
//    </interface>
// 
// Beyond this general structure, several object classes define their own XML
// DTD fragments for filling in the ANY placeholders in the DTD above. Note that
// a custom element in a <child> element gets parsed by the custom tag handler
// of the parent object, while a custom element in an <object> element gets
// parsed by the custom tag handler of the object.
// 
// These XML fragments are explained in the documentation of the respective
// objects.
// 
// Additionally, since 3.10 a special <template> tag has been added to the
// format allowing one to define a widget class’s components. See the [GtkWidget
// documentation][composite-templates] for details.
	type Builder struct {
		**externglib.Object
		
	}

	// BuilderClass is an interface that the Builder class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type BuilderClass interface {
		gextras.Objector
		_builder()
	}

	func (Builder) _builder() {}

	
	func marshalBuilder(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapBuilder(obj), nil
	}
	

	
	// NewBuilder creates a new empty builder object.
// 
// This function is only useful if you intend to make multiple calls to
// gtk_builder_add_from_file(), gtk_builder_add_from_resource() or
// gtk_builder_add_from_string() in order to merge multiple UI descriptions into
// a single builder.
// 
// Most users will probably want to use gtk_builder_new_from_file(),
// gtk_builder_new_from_resource() or gtk_builder_new_from_string().
	func NewBuilder() Builder {
var _cret *C.GtkBuilder // in

_cret = C.gtk_builder_new()


var _builder Builder // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_builder = Builder{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}

return _builder
}
	
	// NewBuilderFromFile builds the [GtkBuilder UI definition][BUILDER-UI] in the
// file @filename.
// 
// If there is an error opening the file or parsing the description then the
// program will be aborted. You should only ever attempt to parse user interface
// descriptions that are shipped as part of your program.
	func NewBuilderFromFile(filename string) Builder {
var _arg1 *C.gchar // out
var _cret *C.GtkBuilder // in

_arg1 = (*C.gchar)(C.CString(filename))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_builder_new_from_file(_arg1)


var _builder Builder // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_builder = Builder{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}

return _builder
}
	
	// NewBuilderFromResource builds the [GtkBuilder UI definition][BUILDER-UI] at
// @resource_path.
// 
// If there is an error locating the resource or parsing the description, then
// the program will be aborted.
	func NewBuilderFromResource(resourcePath string) Builder {
var _arg1 *C.gchar // out
var _cret *C.GtkBuilder // in

_arg1 = (*C.gchar)(C.CString(resourcePath))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_builder_new_from_resource(_arg1)


var _builder Builder // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_builder = Builder{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}

return _builder
}
	
	// NewBuilderFromString builds the user interface described by @string (in the
// [GtkBuilder UI definition][BUILDER-UI] format).
// 
// If @string is nil-terminated, then @length should be -1. If @length is not
// -1, then it is the length of @string.
// 
// If there is an error parsing @string then the program will be aborted. You
// should not attempt to parse user interface description from untrusted
// sources.
	func NewBuilderFromString(_string string, length int) Builder {
var _arg1 *C.gchar // out
var _arg2 C.gssize // out
var _cret *C.GtkBuilder // in

_arg1 = (*C.gchar)(C.CString(_string))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.gssize)(length)

_cret = C.gtk_builder_new_from_string(_arg1, _arg2)


var _builder Builder // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_builder = Builder{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}

return _builder
}
	

	
	// AddFromFile parses a file containing a [GtkBuilder UI definition][BUILDER-UI]
// and merges it with the current contents of @builder.
// 
// Most users will probably want to use gtk_builder_new_from_file().
// 
// If an error occurs, 0 will be returned and @error will be assigned a #GError
// from the K_BUILDER_ERROR, MARKUP_ERROR or FILE_ERROR domain.
// 
// It’s not really reasonable to attempt to handle failures of this call. You
// should not use this function with untrusted files (ie: files that are not
// part of your application). Broken Builder files can easily crash your
// program, and it’s possible that memory was leaked leading up to the reported
// failure. The only reasonable thing to do when an error is detected is to call
// g_error().
	func (b Builder) AddFromFile(filename string) (uint, error) {
var _arg0 *C.GtkBuilder // out
var _arg1 *C.gchar // out
var _cret C.guint // in
var _cerr *C.GError // in

_arg0 = (*C.GtkBuilder)(unsafe.Pointer(b.Native()))
_arg1 = (*C.gchar)(C.CString(filename))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_builder_add_from_file(_arg0, _arg1, &_cerr)


var _guint uint // out
var _goerr error // out

_guint = (uint)(_cret)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _guint, _goerr
}
	
	// AddFromResource parses a resource file containing a [GtkBuilder UI
// definition][BUILDER-UI] and merges it with the current contents of @builder.
// 
// Most users will probably want to use gtk_builder_new_from_resource().
// 
// If an error occurs, 0 will be returned and @error will be assigned a #GError
// from the K_BUILDER_ERROR, MARKUP_ERROR or RESOURCE_ERROR domain.
// 
// It’s not really reasonable to attempt to handle failures of this call. The
// only reasonable thing to do when an error is detected is to call g_error().
	func (b Builder) AddFromResource(resourcePath string) (uint, error) {
var _arg0 *C.GtkBuilder // out
var _arg1 *C.gchar // out
var _cret C.guint // in
var _cerr *C.GError // in

_arg0 = (*C.GtkBuilder)(unsafe.Pointer(b.Native()))
_arg1 = (*C.gchar)(C.CString(resourcePath))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_builder_add_from_resource(_arg0, _arg1, &_cerr)


var _guint uint // out
var _goerr error // out

_guint = (uint)(_cret)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _guint, _goerr
}
	
	// AddFromString parses a string containing a [GtkBuilder UI
// definition][BUILDER-UI] and merges it with the current contents of @builder.
// 
// Most users will probably want to use gtk_builder_new_from_string().
// 
// Upon errors 0 will be returned and @error will be assigned a #GError from the
// K_BUILDER_ERROR, MARKUP_ERROR or VARIANT_PARSE_ERROR domain.
// 
// It’s not really reasonable to attempt to handle failures of this call. The
// only reasonable thing to do when an error is detected is to call g_error().
	func (b Builder) AddFromString(buffer string, length uint) (uint, error) {
var _arg0 *C.GtkBuilder // out
var _arg1 *C.gchar // out
var _arg2 C.gsize // out
var _cret C.guint // in
var _cerr *C.GError // in

_arg0 = (*C.GtkBuilder)(unsafe.Pointer(b.Native()))
_arg1 = (*C.gchar)(C.CString(buffer))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.gsize)(length)

_cret = C.gtk_builder_add_from_string(_arg0, _arg1, _arg2, &_cerr)


var _guint uint // out
var _goerr error // out

_guint = (uint)(_cret)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _guint, _goerr
}
	
	// AddObjectsFromFile parses a file containing a [GtkBuilder UI
// definition][BUILDER-UI] building only the requested objects and merges them
// with the current contents of @builder.
// 
// Upon errors 0 will be returned and @error will be assigned a #GError from the
// K_BUILDER_ERROR, MARKUP_ERROR or FILE_ERROR domain.
// 
// If you are adding an object that depends on an object that is not its child
// (for instance a TreeView that depends on its TreeModel), you have to
// explicitly list all of them in @object_ids.
	func (b Builder) AddObjectsFromFile(filename string, objectIds []string) (uint, error) {
var _arg0 *C.GtkBuilder // out
var _arg1 *C.gchar // out
var _arg2 **C.gchar
var _cret C.guint // in
var _cerr *C.GError // in

_arg0 = (*C.GtkBuilder)(unsafe.Pointer(b.Native()))
_arg1 = (*C.gchar)(C.CString(filename))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (**C.gchar)(C.malloc(C.ulong(len(objectIds)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
defer C.free(unsafe.Pointer(_arg2))
{
out := unsafe.Slice(_arg2, len(objectIds))
for i := range objectIds {
out[i] = (*C.gchar)(C.CString(objectIds[i]))
defer C.free(unsafe.Pointer(out[i]))
}
}

_cret = C.gtk_builder_add_objects_from_file(_arg0, _arg1, _arg2, &_cerr)


var _guint uint // out
var _goerr error // out

_guint = (uint)(_cret)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _guint, _goerr
}
	
	// AddObjectsFromResource parses a resource file containing a [GtkBuilder UI
// definition][BUILDER-UI] building only the requested objects and merges them
// with the current contents of @builder.
// 
// Upon errors 0 will be returned and @error will be assigned a #GError from the
// K_BUILDER_ERROR, MARKUP_ERROR or RESOURCE_ERROR domain.
// 
// If you are adding an object that depends on an object that is not its child
// (for instance a TreeView that depends on its TreeModel), you have to
// explicitly list all of them in @object_ids.
	func (b Builder) AddObjectsFromResource(resourcePath string, objectIds []string) (uint, error) {
var _arg0 *C.GtkBuilder // out
var _arg1 *C.gchar // out
var _arg2 **C.gchar
var _cret C.guint // in
var _cerr *C.GError // in

_arg0 = (*C.GtkBuilder)(unsafe.Pointer(b.Native()))
_arg1 = (*C.gchar)(C.CString(resourcePath))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (**C.gchar)(C.malloc(C.ulong(len(objectIds)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
defer C.free(unsafe.Pointer(_arg2))
{
out := unsafe.Slice(_arg2, len(objectIds))
for i := range objectIds {
out[i] = (*C.gchar)(C.CString(objectIds[i]))
defer C.free(unsafe.Pointer(out[i]))
}
}

_cret = C.gtk_builder_add_objects_from_resource(_arg0, _arg1, _arg2, &_cerr)


var _guint uint // out
var _goerr error // out

_guint = (uint)(_cret)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _guint, _goerr
}
	
	// AddObjectsFromString parses a string containing a [GtkBuilder UI
// definition][BUILDER-UI] building only the requested objects and merges them
// with the current contents of @builder.
// 
// Upon errors 0 will be returned and @error will be assigned a #GError from the
// K_BUILDER_ERROR or MARKUP_ERROR domain.
// 
// If you are adding an object that depends on an object that is not its child
// (for instance a TreeView that depends on its TreeModel), you have to
// explicitly list all of them in @object_ids.
	func (b Builder) AddObjectsFromString(buffer string, length uint, objectIds []string) (uint, error) {
var _arg0 *C.GtkBuilder // out
var _arg1 *C.gchar // out
var _arg2 C.gsize // out
var _arg3 **C.gchar
var _cret C.guint // in
var _cerr *C.GError // in

_arg0 = (*C.GtkBuilder)(unsafe.Pointer(b.Native()))
_arg1 = (*C.gchar)(C.CString(buffer))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.gsize)(length)
_arg3 = (**C.gchar)(C.malloc(C.ulong(len(objectIds)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
defer C.free(unsafe.Pointer(_arg3))
{
out := unsafe.Slice(_arg3, len(objectIds))
for i := range objectIds {
out[i] = (*C.gchar)(C.CString(objectIds[i]))
defer C.free(unsafe.Pointer(out[i]))
}
}

_cret = C.gtk_builder_add_objects_from_string(_arg0, _arg1, _arg2, _arg3, &_cerr)


var _guint uint // out
var _goerr error // out

_guint = (uint)(_cret)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _guint, _goerr
}
	
	// ExposeObject: add @object to the @builder object pool so it can be referenced
// just like any other object built by builder.
	func (b Builder) ExposeObject(name string, object **externglib.Object)  {
var _arg0 *C.GtkBuilder // out
var _arg1 *C.gchar // out
var _arg2 *C.GObject // out

_arg0 = (*C.GtkBuilder)(unsafe.Pointer(b.Native()))
_arg1 = (*C.gchar)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.GObject)(unsafe.Pointer(object.Native()))

C.gtk_builder_expose_object(_arg0, _arg1, _arg2)
}
	
	// ExtendWithTemplate: main private entry point for building composite container
// components from template XML.
// 
// This is exported purely to let gtk-builder-tool validate templates,
// applications have no need to call this function.
	func (b Builder) ExtendWithTemplate(widget WidgetClass, templateType externglib.Type, buffer string, length uint) (uint, error) {
var _arg0 *C.GtkBuilder // out
var _arg1 *C.GtkWidget // out
var _arg2 C.GType // out
var _arg3 *C.gchar // out
var _arg4 C.gsize // out
var _cret C.guint // in
var _cerr *C.GError // in

_arg0 = (*C.GtkBuilder)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg2 = C.GType(templateType)
_arg3 = (*C.gchar)(C.CString(buffer))
defer C.free(unsafe.Pointer(_arg3))
_arg4 = (C.gsize)(length)

_cret = C.gtk_builder_extend_with_template(_arg0, _arg1, _arg2, _arg3, _arg4, &_cerr)


var _guint uint // out
var _goerr error // out

_guint = (uint)(_cret)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _guint, _goerr
}
	
	// Application gets the Application associated with the builder.
// 
// The Application is used for creating action proxies as requested from XML
// that the builder is loading.
// 
// By default, the builder uses the default application: the one from
// g_application_get_default(). If you want to use another application for
// constructing proxies, use gtk_builder_set_application().
	func (b Builder) Application() Application {
var _arg0 *C.GtkBuilder // out
var _cret *C.GtkApplication // in

_arg0 = (*C.GtkBuilder)(unsafe.Pointer(b.Native()))

_cret = C.gtk_builder_get_application(_arg0)


var _application Application // out

_application = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Application)

return _application
}
	
	// Object gets the object named @name. Note that this function does not
// increment the reference count of the returned object.
	func (b Builder) Object(name string) **externglib.Object {
var _arg0 *C.GtkBuilder // out
var _arg1 *C.gchar // out
var _cret *C.GObject // in

_arg0 = (*C.GtkBuilder)(unsafe.Pointer(b.Native()))
_arg1 = (*C.gchar)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_builder_get_object(_arg0, _arg1)


var _object **externglib.Object // out

_object = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(**externglib.Object)

return _object
}
	
	// TranslationDomain gets the translation domain of @builder.
	func (b Builder) TranslationDomain() string {
var _arg0 *C.GtkBuilder // out
var _cret *C.gchar // in

_arg0 = (*C.GtkBuilder)(unsafe.Pointer(b.Native()))

_cret = C.gtk_builder_get_translation_domain(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// TypeFromName looks up a type by name, using the virtual function that Builder
// has for that purpose. This is mainly used when implementing the Buildable
// interface on a type.
	func (b Builder) TypeFromName(typeName string) externglib.Type {
var _arg0 *C.GtkBuilder // out
var _arg1 *C.char // out
var _cret C.GType // in

_arg0 = (*C.GtkBuilder)(unsafe.Pointer(b.Native()))
_arg1 = (*C.char)(C.CString(typeName))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_builder_get_type_from_name(_arg0, _arg1)


var _gType externglib.Type // out

_gType = externglib.Type(_cret)

return _gType
}
	
	// SetApplication sets the application associated with @builder.
// 
// You only need this function if there is more than one #GApplication in your
// process. @application cannot be nil.
	func (b Builder) SetApplication(application ApplicationClass)  {
var _arg0 *C.GtkBuilder // out
var _arg1 *C.GtkApplication // out

_arg0 = (*C.GtkBuilder)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkApplication)(unsafe.Pointer(application.Native()))

C.gtk_builder_set_application(_arg0, _arg1)
}
	
	// SetTranslationDomain sets the translation domain of @builder. See
// Builder:translation-domain.
	func (b Builder) SetTranslationDomain(domain string)  {
var _arg0 *C.GtkBuilder // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkBuilder)(unsafe.Pointer(b.Native()))
_arg1 = (*C.gchar)(C.CString(domain))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_builder_set_translation_domain(_arg0, _arg1)
}
	
	// ValueFromStringType: like gtk_builder_value_from_string(), this function
// demarshals a value from a string, but takes a #GType instead of Spec. This
// function calls g_value_init() on the @value argument, so it need not be
// initialised beforehand.
// 
// Upon errors false will be returned and @error will be assigned a #GError from
// the K_BUILDER_ERROR domain.
	func (b Builder) ValueFromStringType(typ externglib.Type, _string string) (*externglib.Value, error) {
var _arg0 *C.GtkBuilder // out
var _arg1 C.GType // out
var _arg2 *C.gchar // out
var _arg3 C.GValue // in
var _cerr *C.GError // in

_arg0 = (*C.GtkBuilder)(unsafe.Pointer(b.Native()))
_arg1 = C.GType(typ)
_arg2 = (*C.gchar)(C.CString(_string))
defer C.free(unsafe.Pointer(_arg2))

C.gtk_builder_value_from_string_type(_arg0, _arg1, _arg2, &_arg3, &_cerr)

var _value *externglib.Value // out
var _goerr error // out

_value = externglib.ValueFromNative(unsafe.Pointer(_arg3))
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _value, _goerr
}
	


	// Button: the Button widget is generally used to trigger a callback function
// that is called when the button is pressed. The various signals and how to use
// them are outlined below.
// 
// The Button widget can hold any valid child widget. That is, it can hold
// almost any other standard Widget. The most commonly used child is the Label.
// 
// 
// CSS nodes
// 
// GtkButton has a single CSS node with name button. The node will get the style
// classes .image-button or .text-button, if the content is just an image or
// label, respectively. It may also receive the .flat style class.
// 
// Other style classes that are commonly used with GtkButton include
// .suggested-action and .destructive-action. In special cases, buttons can be
// made round by adding the .circular style class.
// 
// Button-like widgets like ToggleButton, MenuButton, VolumeButton, LockButton,
// ColorButton, FontButton or FileChooserButton use style classes such as
// .toggle, .popup, .scale, .lock, .color, .font, .file to differentiate
// themselves from a plain GtkButton.
	type Button struct {
		Bin
		Actionable
		Activatable
		Buildable
		
	}

	// ButtonClass is an interface that the Button class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ButtonClass interface {
		gextras.Objector
		_button()
	}

	func (Button) _button() {}

	
	func marshalButton(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapButton(obj), nil
	}
	

	
	// NewButton creates a new Button widget. To add a child widget to the button,
// use gtk_container_add().
	func NewButton() Button {
var _cret *C.GtkWidget // in

_cret = C.gtk_button_new()


var _button Button // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_button = Button{
Bin: Bin{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _button
}
	
	// NewButtonFromIconName creates a new button containing an icon from the
// current icon theme.
// 
// If the icon name isn’t known, a “broken image” icon will be displayed
// instead. If the current icon theme is changed, the icon will be updated
// appropriately.
// 
// This function is a convenience wrapper around gtk_button_new() and
// gtk_button_set_image().
	func NewButtonFromIconName(iconName string, size int) Button {
var _arg1 *C.gchar // out
var _arg2 C.GtkIconSize // out
var _cret *C.GtkWidget // in

_arg1 = (*C.gchar)(C.CString(iconName))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.GtkIconSize)(size)

_cret = C.gtk_button_new_from_icon_name(_arg1, _arg2)


var _button Button // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_button = Button{
Bin: Bin{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _button
}
	
	// NewButtonFromStock creates a new Button containing the image and text from a
// [stock item][gtkstock]. Some stock ids have preprocessor macros like
// K_STOCK_OK and K_STOCK_APPLY.
// 
// If @stock_id is unknown, then it will be treated as a mnemonic label (as for
// gtk_button_new_with_mnemonic()).
	func NewButtonFromStock(stockId string) Button {
var _arg1 *C.gchar // out
var _cret *C.GtkWidget // in

_arg1 = (*C.gchar)(C.CString(stockId))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_button_new_from_stock(_arg1)


var _button Button // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_button = Button{
Bin: Bin{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _button
}
	
	// NewButtonWithLabel creates a Button widget with a Label child containing the
// given text.
	func NewButtonWithLabel(label string) Button {
var _arg1 *C.gchar // out
var _cret *C.GtkWidget // in

_arg1 = (*C.gchar)(C.CString(label))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_button_new_with_label(_arg1)


var _button Button // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_button = Button{
Bin: Bin{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _button
}
	
	// NewButtonWithMnemonic creates a new Button containing a label. If characters
// in @label are preceded by an underscore, they are underlined. If you need a
// literal underscore character in a label, use “__” (two underscores). The
// first underlined character represents a keyboard accelerator called a
// mnemonic. Pressing Alt and that key activates the button.
	func NewButtonWithMnemonic(label string) Button {
var _arg1 *C.gchar // out
var _cret *C.GtkWidget // in

_arg1 = (*C.gchar)(C.CString(label))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_button_new_with_mnemonic(_arg1)


var _button Button // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_button = Button{
Bin: Bin{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _button
}
	

	
	// Clicked emits a Button::clicked signal to the given Button.
	func (b Button) Clicked()  {
var _arg0 *C.GtkButton // out

_arg0 = (*C.GtkButton)(unsafe.Pointer(b.Native()))

C.gtk_button_clicked(_arg0)
}
	
	// Enter emits a Button::enter signal to the given Button.
	func (b Button) Enter()  {
var _arg0 *C.GtkButton // out

_arg0 = (*C.GtkButton)(unsafe.Pointer(b.Native()))

C.gtk_button_enter(_arg0)
}
	
	// Alignment gets the alignment of the child in the button.
	func (b Button) Alignment() (xalign float32, yalign float32) {
var _arg0 *C.GtkButton // out
var _arg1 C.gfloat // in
var _arg2 C.gfloat // in

_arg0 = (*C.GtkButton)(unsafe.Pointer(b.Native()))

C.gtk_button_get_alignment(_arg0, &_arg1, &_arg2)

var _xalign float32 // out
var _yalign float32 // out

_xalign = (float32)(_arg1)
_yalign = (float32)(_arg2)

return _xalign, _yalign
}
	
	// AlwaysShowImage returns whether the button will ignore the
// Settings:gtk-button-images setting and always show the image, if available.
	func (b Button) AlwaysShowImage() bool {
var _arg0 *C.GtkButton // out
var _cret C.gboolean // in

_arg0 = (*C.GtkButton)(unsafe.Pointer(b.Native()))

_cret = C.gtk_button_get_always_show_image(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// EventWindow returns the button’s event window if it is realized, nil
// otherwise. This function should be rarely needed.
	func (b Button) EventWindow() gdk.Window {
var _arg0 *C.GtkButton // out
var _cret *C.GdkWindow // in

_arg0 = (*C.GtkButton)(unsafe.Pointer(b.Native()))

_cret = C.gtk_button_get_event_window(_arg0)


var _window gdk.Window // out

_window = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Window)

return _window
}
	
	// FocusOnClick returns whether the button grabs focus when it is clicked with
// the mouse. See gtk_button_set_focus_on_click().
	func (b Button) FocusOnClick() bool {
var _arg0 *C.GtkButton // out
var _cret C.gboolean // in

_arg0 = (*C.GtkButton)(unsafe.Pointer(b.Native()))

_cret = C.gtk_button_get_focus_on_click(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Image gets the widget that is currenty set as the image of @button. This may
// have been explicitly set by gtk_button_set_image() or constructed by
// gtk_button_new_from_stock().
	func (b Button) Image() Widget {
var _arg0 *C.GtkButton // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkButton)(unsafe.Pointer(b.Native()))

_cret = C.gtk_button_get_image(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// ImagePosition gets the position of the image relative to the text inside the
// button.
	func (b Button) ImagePosition() PositionType {
var _arg0 *C.GtkButton // out
var _cret C.GtkPositionType // in

_arg0 = (*C.GtkButton)(unsafe.Pointer(b.Native()))

_cret = C.gtk_button_get_image_position(_arg0)


var _positionType PositionType // out

_positionType = PositionType(_cret)

return _positionType
}
	
	// Label fetches the text from the label of the button, as set by
// gtk_button_set_label(). If the label text has not been set the return value
// will be nil. This will be the case if you create an empty button with
// gtk_button_new() to use as a container.
	func (b Button) Label() string {
var _arg0 *C.GtkButton // out
var _cret *C.gchar // in

_arg0 = (*C.GtkButton)(unsafe.Pointer(b.Native()))

_cret = C.gtk_button_get_label(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Relief returns the current relief style of the given Button.
	func (b Button) Relief() ReliefStyle {
var _arg0 *C.GtkButton // out
var _cret C.GtkReliefStyle // in

_arg0 = (*C.GtkButton)(unsafe.Pointer(b.Native()))

_cret = C.gtk_button_get_relief(_arg0)


var _reliefStyle ReliefStyle // out

_reliefStyle = ReliefStyle(_cret)

return _reliefStyle
}
	
	// UseStock returns whether the button label is a stock item.
	func (b Button) UseStock() bool {
var _arg0 *C.GtkButton // out
var _cret C.gboolean // in

_arg0 = (*C.GtkButton)(unsafe.Pointer(b.Native()))

_cret = C.gtk_button_get_use_stock(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// UseUnderline returns whether an embedded underline in the button label
// indicates a mnemonic. See gtk_button_set_use_underline ().
	func (b Button) UseUnderline() bool {
var _arg0 *C.GtkButton // out
var _cret C.gboolean // in

_arg0 = (*C.GtkButton)(unsafe.Pointer(b.Native()))

_cret = C.gtk_button_get_use_underline(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Leave emits a Button::leave signal to the given Button.
	func (b Button) Leave()  {
var _arg0 *C.GtkButton // out

_arg0 = (*C.GtkButton)(unsafe.Pointer(b.Native()))

C.gtk_button_leave(_arg0)
}
	
	// Pressed emits a Button::pressed signal to the given Button.
	func (b Button) Pressed()  {
var _arg0 *C.GtkButton // out

_arg0 = (*C.GtkButton)(unsafe.Pointer(b.Native()))

C.gtk_button_pressed(_arg0)
}
	
	// Released emits a Button::released signal to the given Button.
	func (b Button) Released()  {
var _arg0 *C.GtkButton // out

_arg0 = (*C.GtkButton)(unsafe.Pointer(b.Native()))

C.gtk_button_released(_arg0)
}
	
	// SetAlignment sets the alignment of the child. This property has no effect
// unless the child is a Misc or a Alignment.
	func (b Button) SetAlignment(xalign float32, yalign float32)  {
var _arg0 *C.GtkButton // out
var _arg1 C.gfloat // out
var _arg2 C.gfloat // out

_arg0 = (*C.GtkButton)(unsafe.Pointer(b.Native()))
_arg1 = (C.gfloat)(xalign)
_arg2 = (C.gfloat)(yalign)

C.gtk_button_set_alignment(_arg0, _arg1, _arg2)
}
	
	// SetAlwaysShowImage: if true, the button will ignore the
// Settings:gtk-button-images setting and always show the image, if available.
// 
// Use this property if the button would be useless or hard to use without the
// image.
	func (b Button) SetAlwaysShowImage(alwaysShow bool)  {
var _arg0 *C.GtkButton // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkButton)(unsafe.Pointer(b.Native()))
if alwaysShow { _arg1 = C.TRUE }

C.gtk_button_set_always_show_image(_arg0, _arg1)
}
	
	// SetFocusOnClick sets whether the button will grab focus when it is clicked
// with the mouse. Making mouse clicks not grab focus is useful in places like
// toolbars where you don’t want the keyboard focus removed from the main area
// of the application.
	func (b Button) SetFocusOnClick(focusOnClick bool)  {
var _arg0 *C.GtkButton // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkButton)(unsafe.Pointer(b.Native()))
if focusOnClick { _arg1 = C.TRUE }

C.gtk_button_set_focus_on_click(_arg0, _arg1)
}
	
	// SetImage: set the image of @button to the given widget. The image will be
// displayed if the label text is nil or if Button:always-show-image is true.
// You don’t have to call gtk_widget_show() on @image yourself.
	func (b Button) SetImage(image WidgetClass)  {
var _arg0 *C.GtkButton // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkButton)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(image.Native()))

C.gtk_button_set_image(_arg0, _arg1)
}
	
	// SetImagePosition sets the position of the image relative to the text inside
// the button.
	func (b Button) SetImagePosition(position PositionType)  {
var _arg0 *C.GtkButton // out
var _arg1 C.GtkPositionType // out

_arg0 = (*C.GtkButton)(unsafe.Pointer(b.Native()))
_arg1 = (C.GtkPositionType)(position)

C.gtk_button_set_image_position(_arg0, _arg1)
}
	
	// SetLabel sets the text of the label of the button to @str. This text is also
// used to select the stock item if gtk_button_set_use_stock() is used.
// 
// This will also clear any previously set labels.
	func (b Button) SetLabel(label string)  {
var _arg0 *C.GtkButton // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkButton)(unsafe.Pointer(b.Native()))
_arg1 = (*C.gchar)(C.CString(label))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_button_set_label(_arg0, _arg1)
}
	
	// SetRelief sets the relief style of the edges of the given Button widget. Two
// styles exist, GTK_RELIEF_NORMAL and GTK_RELIEF_NONE. The default style is, as
// one can guess, GTK_RELIEF_NORMAL. The deprecated value GTK_RELIEF_HALF
// behaves the same as GTK_RELIEF_NORMAL.
	func (b Button) SetRelief(relief ReliefStyle)  {
var _arg0 *C.GtkButton // out
var _arg1 C.GtkReliefStyle // out

_arg0 = (*C.GtkButton)(unsafe.Pointer(b.Native()))
_arg1 = (C.GtkReliefStyle)(relief)

C.gtk_button_set_relief(_arg0, _arg1)
}
	
	// SetUseStock: if true, the label set on the button is used as a stock id to
// select the stock item for the button.
	func (b Button) SetUseStock(useStock bool)  {
var _arg0 *C.GtkButton // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkButton)(unsafe.Pointer(b.Native()))
if useStock { _arg1 = C.TRUE }

C.gtk_button_set_use_stock(_arg0, _arg1)
}
	
	// SetUseUnderline: if true, an underline in the text of the button label
// indicates the next character should be used for the mnemonic accelerator key.
	func (b Button) SetUseUnderline(useUnderline bool)  {
var _arg0 *C.GtkButton // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkButton)(unsafe.Pointer(b.Native()))
if useUnderline { _arg1 = C.TRUE }

C.gtk_button_set_use_underline(_arg0, _arg1)
}
	


	
	type ButtonBox struct {
		Box
		Buildable
		Orientable
		
	}

	// ButtonBoxClass is an interface that the ButtonBox class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ButtonBoxClass interface {
		gextras.Objector
		_buttonBox()
	}

	func (ButtonBox) _buttonBox() {}

	
	func marshalButtonBox(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapButtonBox(obj), nil
	}
	

	
	// NewButtonBox creates a new ButtonBox.
	func NewButtonBox(orientation Orientation) ButtonBox {
var _arg1 C.GtkOrientation // out
var _cret *C.GtkWidget // in

_arg1 = (C.GtkOrientation)(orientation)

_cret = C.gtk_button_box_new(_arg1)


var _buttonBox ButtonBox // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_buttonBox = ButtonBox{
Box: Box{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _buttonBox
}
	

	
	// ChildNonHomogeneous returns whether the child is exempted from homogenous
// sizing.
	func (w ButtonBox) ChildNonHomogeneous(child WidgetClass) bool {
var _arg0 *C.GtkButtonBox // out
var _arg1 *C.GtkWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkButtonBox)(unsafe.Pointer(w.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

_cret = C.gtk_button_box_get_child_non_homogeneous(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ChildSecondary returns whether @child should appear in a secondary group of
// children.
	func (w ButtonBox) ChildSecondary(child WidgetClass) bool {
var _arg0 *C.GtkButtonBox // out
var _arg1 *C.GtkWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkButtonBox)(unsafe.Pointer(w.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

_cret = C.gtk_button_box_get_child_secondary(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Layout retrieves the method being used to arrange the buttons in a button
// box.
	func (w ButtonBox) Layout() ButtonBoxStyle {
var _arg0 *C.GtkButtonBox // out
var _cret C.GtkButtonBoxStyle // in

_arg0 = (*C.GtkButtonBox)(unsafe.Pointer(w.Native()))

_cret = C.gtk_button_box_get_layout(_arg0)


var _buttonBoxStyle ButtonBoxStyle // out

_buttonBoxStyle = ButtonBoxStyle(_cret)

return _buttonBoxStyle
}
	
	// SetChildNonHomogeneous sets whether the child is exempted from homogeous
// sizing.
	func (w ButtonBox) SetChildNonHomogeneous(child WidgetClass, nonHomogeneous bool)  {
var _arg0 *C.GtkButtonBox // out
var _arg1 *C.GtkWidget // out
var _arg2 C.gboolean // out

_arg0 = (*C.GtkButtonBox)(unsafe.Pointer(w.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
if nonHomogeneous { _arg2 = C.TRUE }

C.gtk_button_box_set_child_non_homogeneous(_arg0, _arg1, _arg2)
}
	
	// SetChildSecondary sets whether @child should appear in a secondary group of
// children. A typical use of a secondary child is the help button in a dialog.
// 
// This group appears after the other children if the style is
// GTK_BUTTONBOX_START, GTK_BUTTONBOX_SPREAD or GTK_BUTTONBOX_EDGE, and before
// the other children if the style is GTK_BUTTONBOX_END. For horizontal button
// boxes, the definition of before/after depends on direction of the widget (see
// gtk_widget_set_direction()). If the style is GTK_BUTTONBOX_START or
// GTK_BUTTONBOX_END, then the secondary children are aligned at the other end
// of the button box from the main children. For the other styles, they appear
// immediately next to the main children.
	func (w ButtonBox) SetChildSecondary(child WidgetClass, isSecondary bool)  {
var _arg0 *C.GtkButtonBox // out
var _arg1 *C.GtkWidget // out
var _arg2 C.gboolean // out

_arg0 = (*C.GtkButtonBox)(unsafe.Pointer(w.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
if isSecondary { _arg2 = C.TRUE }

C.gtk_button_box_set_child_secondary(_arg0, _arg1, _arg2)
}
	
	// SetLayout changes the way buttons are arranged in their container.
	func (w ButtonBox) SetLayout(layoutStyle ButtonBoxStyle)  {
var _arg0 *C.GtkButtonBox // out
var _arg1 C.GtkButtonBoxStyle // out

_arg0 = (*C.GtkButtonBox)(unsafe.Pointer(w.Native()))
_arg1 = (C.GtkButtonBoxStyle)(layoutStyle)

C.gtk_button_box_set_layout(_arg0, _arg1)
}
	


	// Calendar is a widget that displays a Gregorian calendar, one month at a time.
// It can be created with gtk_calendar_new().
// 
// The month and year currently displayed can be altered with
// gtk_calendar_select_month(). The exact day can be selected from the displayed
// month using gtk_calendar_select_day().
// 
// To place a visual marker on a particular day, use gtk_calendar_mark_day() and
// to remove the marker, gtk_calendar_unmark_day(). Alternative, all marks can
// be cleared with gtk_calendar_clear_marks().
// 
// The way in which the calendar itself is displayed can be altered using
// gtk_calendar_set_display_options().
// 
// The selected date can be retrieved from a Calendar using
// gtk_calendar_get_date().
// 
// Users should be aware that, although the Gregorian calendar is the legal
// calendar in most countries, it was adopted progressively between 1582 and
// 1929. Display before these dates is likely to be historically incorrect.
	type Calendar struct {
		Widget
		Buildable
		
	}

	// CalendarClass is an interface that the Calendar class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type CalendarClass interface {
		gextras.Objector
		_calendar()
	}

	func (Calendar) _calendar() {}

	
	func marshalCalendar(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapCalendar(obj), nil
	}
	

	
	// NewCalendar creates a new calendar, with the current date being selected.
	func NewCalendar() Calendar {
var _cret *C.GtkWidget // in

_cret = C.gtk_calendar_new()


var _calendar Calendar // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_calendar = Calendar{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _calendar
}
	

	
	// ClearMarks: remove all visual markers.
	func (c Calendar) ClearMarks()  {
var _arg0 *C.GtkCalendar // out

_arg0 = (*C.GtkCalendar)(unsafe.Pointer(c.Native()))

C.gtk_calendar_clear_marks(_arg0)
}
	
	// Date obtains the selected date from a Calendar.
	func (c Calendar) Date() (year uint, month uint, day uint) {
var _arg0 *C.GtkCalendar // out
var _arg1 C.guint // in
var _arg2 C.guint // in
var _arg3 C.guint // in

_arg0 = (*C.GtkCalendar)(unsafe.Pointer(c.Native()))

C.gtk_calendar_get_date(_arg0, &_arg1, &_arg2, &_arg3)

var _year uint // out
var _month uint // out
var _day uint // out

_year = (uint)(_arg1)
_month = (uint)(_arg2)
_day = (uint)(_arg3)

return _year, _month, _day
}
	
	// DayIsMarked returns if the @day of the @calendar is already marked.
	func (c Calendar) DayIsMarked(day uint) bool {
var _arg0 *C.GtkCalendar // out
var _arg1 C.guint // out
var _cret C.gboolean // in

_arg0 = (*C.GtkCalendar)(unsafe.Pointer(c.Native()))
_arg1 = (C.guint)(day)

_cret = C.gtk_calendar_get_day_is_marked(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// DetailHeightRows queries the height of detail cells, in rows. See
// Calendar:detail-width-chars.
	func (c Calendar) DetailHeightRows() int {
var _arg0 *C.GtkCalendar // out
var _cret C.gint // in

_arg0 = (*C.GtkCalendar)(unsafe.Pointer(c.Native()))

_cret = C.gtk_calendar_get_detail_height_rows(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// DetailWidthChars queries the width of detail cells, in characters. See
// Calendar:detail-width-chars.
	func (c Calendar) DetailWidthChars() int {
var _arg0 *C.GtkCalendar // out
var _cret C.gint // in

_arg0 = (*C.GtkCalendar)(unsafe.Pointer(c.Native()))

_cret = C.gtk_calendar_get_detail_width_chars(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// DisplayOptions returns the current display options of @calendar.
	func (c Calendar) DisplayOptions() CalendarDisplayOptions {
var _arg0 *C.GtkCalendar // out
var _cret C.GtkCalendarDisplayOptions // in

_arg0 = (*C.GtkCalendar)(unsafe.Pointer(c.Native()))

_cret = C.gtk_calendar_get_display_options(_arg0)


var _calendarDisplayOptions CalendarDisplayOptions // out

_calendarDisplayOptions = CalendarDisplayOptions(_cret)

return _calendarDisplayOptions
}
	
	// MarkDay places a visual marker on a particular day.
	func (c Calendar) MarkDay(day uint)  {
var _arg0 *C.GtkCalendar // out
var _arg1 C.guint // out

_arg0 = (*C.GtkCalendar)(unsafe.Pointer(c.Native()))
_arg1 = (C.guint)(day)

C.gtk_calendar_mark_day(_arg0, _arg1)
}
	
	// SelectDay selects a day from the current month.
	func (c Calendar) SelectDay(day uint)  {
var _arg0 *C.GtkCalendar // out
var _arg1 C.guint // out

_arg0 = (*C.GtkCalendar)(unsafe.Pointer(c.Native()))
_arg1 = (C.guint)(day)

C.gtk_calendar_select_day(_arg0, _arg1)
}
	
	// SelectMonth shifts the calendar to a different month.
	func (c Calendar) SelectMonth(month uint, year uint)  {
var _arg0 *C.GtkCalendar // out
var _arg1 C.guint // out
var _arg2 C.guint // out

_arg0 = (*C.GtkCalendar)(unsafe.Pointer(c.Native()))
_arg1 = (C.guint)(month)
_arg2 = (C.guint)(year)

C.gtk_calendar_select_month(_arg0, _arg1, _arg2)
}
	
	// SetDetailHeightRows updates the height of detail cells. See
// Calendar:detail-height-rows.
	func (c Calendar) SetDetailHeightRows(rows int)  {
var _arg0 *C.GtkCalendar // out
var _arg1 C.gint // out

_arg0 = (*C.GtkCalendar)(unsafe.Pointer(c.Native()))
_arg1 = (C.gint)(rows)

C.gtk_calendar_set_detail_height_rows(_arg0, _arg1)
}
	
	// SetDetailWidthChars updates the width of detail cells. See
// Calendar:detail-width-chars.
	func (c Calendar) SetDetailWidthChars(chars int)  {
var _arg0 *C.GtkCalendar // out
var _arg1 C.gint // out

_arg0 = (*C.GtkCalendar)(unsafe.Pointer(c.Native()))
_arg1 = (C.gint)(chars)

C.gtk_calendar_set_detail_width_chars(_arg0, _arg1)
}
	
	// SetDisplayOptions sets display options (whether to display the heading and
// the month headings).
	func (c Calendar) SetDisplayOptions(flags CalendarDisplayOptions)  {
var _arg0 *C.GtkCalendar // out
var _arg1 C.GtkCalendarDisplayOptions // out

_arg0 = (*C.GtkCalendar)(unsafe.Pointer(c.Native()))
_arg1 = (C.GtkCalendarDisplayOptions)(flags)

C.gtk_calendar_set_display_options(_arg0, _arg1)
}
	
	// UnmarkDay removes the visual marker from a particular day.
	func (c Calendar) UnmarkDay(day uint)  {
var _arg0 *C.GtkCalendar // out
var _arg1 C.guint // out

_arg0 = (*C.GtkCalendar)(unsafe.Pointer(c.Native()))
_arg1 = (C.guint)(day)

C.gtk_calendar_unmark_day(_arg0, _arg1)
}
	


	// CellArea: the CellArea is an abstract class for CellLayout widgets (also
// referred to as "layouting widgets") to interface with an arbitrary number of
// CellRenderers and interact with the user for a given TreeModel row.
// 
// The cell area handles events, focus navigation, drawing and size requests and
// allocations for a given row of data.
// 
// Usually users dont have to interact with the CellArea directly unless they
// are implementing a cell-layouting widget themselves.
// 
// 
// Requesting area sizes
// 
// As outlined in [GtkWidget’s geometry management
// section][geometry-management], GTK+ uses a height-for-width geometry
// management system to compute the sizes of widgets and user interfaces.
// CellArea uses the same semantics to calculate the size of an area for an
// arbitrary number of TreeModel rows.
// 
// When requesting the size of a cell area one needs to calculate the size for a
// handful of rows, and this will be done differently by different layouting
// widgets. For instance a TreeViewColumn always lines up the areas from top to
// bottom while a IconView on the other hand might enforce that all areas
// received the same width and wrap the areas around, requesting height for more
// cell areas when allocated less width.
// 
// It’s also important for areas to maintain some cell alignments with areas
// rendered for adjacent rows (cells can appear “columnized” inside an area even
// when the size of cells are different in each row). For this reason the
// CellArea uses a CellAreaContext object to store the alignments and sizes
// along the way (as well as the overall largest minimum and natural size for
// all the rows which have been calculated with the said context).
// 
// The CellAreaContext is an opaque object specific to the CellArea which
// created it (see gtk_cell_area_create_context()). The owning cell-layouting
// widget can create as many contexts as it wishes to calculate sizes of rows
// which should receive the same size in at least one orientation (horizontally
// or vertically), However, it’s important that the same CellAreaContext which
// was used to request the sizes for a given TreeModel row be used when
// rendering or processing events for that row.
// 
// In order to request the width of all the rows at the root level of a
// TreeModel one would do the following:
// 
//    static gboolean
//    foo_focus (GtkWidget       *widget,
//               GtkDirectionType direction)
//    {
//      Foo        *foo  = FOO (widget);
//      FooPrivate *priv = foo->priv;
//      gint        focus_row;
//      gboolean    have_focus = FALSE;
// 
//      focus_row = priv->focus_row;
// 
//      if (!gtk_widget_has_focus (widget))
//        gtk_widget_grab_focus (widget);
// 
//      valid = gtk_tree_model_iter_nth_child (priv->model, &iter, NULL, priv->focus_row);
//      while (valid)
//        {
//          gtk_cell_area_apply_attributes (priv->area, priv->model, &iter, FALSE, FALSE);
// 
//          if (gtk_cell_area_focus (priv->area, direction))
//            {
//               priv->focus_row = focus_row;
//               have_focus = TRUE;
//               break;
//            }
//          else
//            {
//              if (direction == GTK_DIR_RIGHT ||
//                  direction == GTK_DIR_LEFT)
//                break;
//              else if (direction == GTK_DIR_UP ||
//                       direction == GTK_DIR_TAB_BACKWARD)
//               {
//                  if (focus_row == 0)
//                    break;
//                  else
//                   {
//                      focus_row--;
//                      valid = gtk_tree_model_iter_nth_child (priv->model, &iter, NULL, focus_row);
//                   }
//                }
//              else
//                {
//                  if (focus_row == last_row)
//                    break;
//                  else
//                    {
//                      focus_row++;
//                      valid = gtk_tree_model_iter_next (priv->model, &iter);
//                    }
//                }
//            }
//        }
//        return have_focus;
//    }
// 
// Note that the layouting widget is responsible for matching the
// GtkDirectionType values to the way it lays out its cells.
// 
// 
// Cell Properties
// 
// The CellArea introduces cell properties for CellRenderers in very much the
// same way that Container introduces [child properties][child-properties] for
// Widgets. This provides some general interfaces for defining the relationship
// cell areas have with their cells. For instance in a CellAreaBox a cell might
// “expand” and receive extra space when the area is allocated more than its
// full natural request, or a cell might be configured to “align” with adjacent
// rows which were requested and rendered with the same CellAreaContext.
// 
// Use gtk_cell_area_class_install_cell_property() to install cell properties
// for a cell area class and gtk_cell_area_class_find_cell_property() or
// gtk_cell_area_class_list_cell_properties() to get information about existing
// cell properties.
// 
// To set the value of a cell property, use gtk_cell_area_cell_set_property(),
// gtk_cell_area_cell_set() or gtk_cell_area_cell_set_valist(). To obtain the
// value of a cell property, use gtk_cell_area_cell_get_property(),
// gtk_cell_area_cell_get() or gtk_cell_area_cell_get_valist().
	type CellArea struct {
		externglib.InitiallyUnowned
		Buildable
		CellLayout
		
	}

	// CellAreaClass is an interface that the CellArea class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type CellAreaClass interface {
		gextras.Objector
		_cellArea()
	}

	func (CellArea) _cellArea() {}

	
	func marshalCellArea(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapCellArea(obj), nil
	}
	

	

	
	// Activate activates @area, usually by activating the currently focused cell,
// however some subclasses which embed widgets in the area can also activate a
// widget if it currently has the focus.
	func (a CellArea) Activate(context CellAreaContextClass, widget WidgetClass, cellArea *gdk.Rectangle, flags CellRendererState, editOnly bool) bool {
var _arg0 *C.GtkCellArea // out
var _arg1 *C.GtkCellAreaContext // out
var _arg2 *C.GtkWidget // out
var _arg3 *C.GdkRectangle // out
var _arg4 C.GtkCellRendererState // out
var _arg5 C.gboolean // out
var _cret C.gboolean // in

_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkCellAreaContext)(unsafe.Pointer(context.Native()))
_arg2 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg3 = (*C.GdkRectangle)(unsafe.Pointer(cellArea.Native()))
_arg4 = (C.GtkCellRendererState)(flags)
if editOnly { _arg5 = C.TRUE }

_cret = C.gtk_cell_area_activate(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Add adds @renderer to @area with the default child cell properties.
	func (a CellArea) Add(renderer CellRendererClass)  {
var _arg0 *C.GtkCellArea // out
var _arg1 *C.GtkCellRenderer // out

_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))

C.gtk_cell_area_add(_arg0, _arg1)
}
	
	// AddFocusSibling adds @sibling to @renderer’s focusable area, focus will be
// drawn around @renderer and all of its siblings if @renderer can focus for a
// given row.
// 
// Events handled by focus siblings can also activate the given focusable
// @renderer.
	func (a CellArea) AddFocusSibling(renderer CellRendererClass, sibling CellRendererClass)  {
var _arg0 *C.GtkCellArea // out
var _arg1 *C.GtkCellRenderer // out
var _arg2 *C.GtkCellRenderer // out

_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))
_arg2 = (*C.GtkCellRenderer)(unsafe.Pointer(sibling.Native()))

C.gtk_cell_area_add_focus_sibling(_arg0, _arg1, _arg2)
}
	
	// ApplyAttributes applies any connected attributes to the renderers in @area by
// pulling the values from @tree_model.
	func (a CellArea) ApplyAttributes(treeModel TreeModel, iter *TreeIter, isExpander bool, isExpanded bool)  {
var _arg0 *C.GtkCellArea // out
var _arg1 *C.GtkTreeModel // out
var _arg2 *C.GtkTreeIter // out
var _arg3 C.gboolean // out
var _arg4 C.gboolean // out

_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkTreeModel)(unsafe.Pointer(treeModel.Native()))
_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))
if isExpander { _arg3 = C.TRUE }
if isExpanded { _arg4 = C.TRUE }

C.gtk_cell_area_apply_attributes(_arg0, _arg1, _arg2, _arg3, _arg4)
}
	
	// AttributeConnect connects an @attribute to apply values from @column for the
// TreeModel in use.
	func (a CellArea) AttributeConnect(renderer CellRendererClass, attribute string, column int)  {
var _arg0 *C.GtkCellArea // out
var _arg1 *C.GtkCellRenderer // out
var _arg2 *C.gchar // out
var _arg3 C.gint // out

_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))
_arg2 = (*C.gchar)(C.CString(attribute))
defer C.free(unsafe.Pointer(_arg2))
_arg3 = (C.gint)(column)

C.gtk_cell_area_attribute_connect(_arg0, _arg1, _arg2, _arg3)
}
	
	// AttributeDisconnect disconnects @attribute for the @renderer in @area so that
// attribute will no longer be updated with values from the model.
	func (a CellArea) AttributeDisconnect(renderer CellRendererClass, attribute string)  {
var _arg0 *C.GtkCellArea // out
var _arg1 *C.GtkCellRenderer // out
var _arg2 *C.gchar // out

_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))
_arg2 = (*C.gchar)(C.CString(attribute))
defer C.free(unsafe.Pointer(_arg2))

C.gtk_cell_area_attribute_disconnect(_arg0, _arg1, _arg2)
}
	
	// AttributeGetColumn returns the model column that an attribute has been mapped
// to, or -1 if the attribute is not mapped.
	func (a CellArea) AttributeGetColumn(renderer CellRendererClass, attribute string) int {
var _arg0 *C.GtkCellArea // out
var _arg1 *C.GtkCellRenderer // out
var _arg2 *C.gchar // out
var _cret C.gint // in

_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))
_arg2 = (*C.gchar)(C.CString(attribute))
defer C.free(unsafe.Pointer(_arg2))

_cret = C.gtk_cell_area_attribute_get_column(_arg0, _arg1, _arg2)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// CellGetProperty gets the value of a cell property for @renderer in @area.
	func (a CellArea) CellGetProperty(renderer CellRendererClass, propertyName string, value **externglib.Value)  {
var _arg0 *C.GtkCellArea // out
var _arg1 *C.GtkCellRenderer // out
var _arg2 *C.gchar // out
var _arg3 *C.GValue // out

_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))
_arg2 = (*C.gchar)(C.CString(propertyName))
defer C.free(unsafe.Pointer(_arg2))
_arg3 = (*C.GValue)(value.GValue)

C.gtk_cell_area_cell_get_property(_arg0, _arg1, _arg2, _arg3)
}
	
	// CellSetProperty sets a cell property for @renderer in @area.
	func (a CellArea) CellSetProperty(renderer CellRendererClass, propertyName string, value **externglib.Value)  {
var _arg0 *C.GtkCellArea // out
var _arg1 *C.GtkCellRenderer // out
var _arg2 *C.gchar // out
var _arg3 *C.GValue // out

_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))
_arg2 = (*C.gchar)(C.CString(propertyName))
defer C.free(unsafe.Pointer(_arg2))
_arg3 = (*C.GValue)(value.GValue)

C.gtk_cell_area_cell_set_property(_arg0, _arg1, _arg2, _arg3)
}
	
	// CopyContext: this is sometimes needed for cases where rows need to share
// alignments in one orientation but may be separately grouped in the opposing
// orientation.
// 
// For instance, IconView creates all icons (rows) to have the same width and
// the cells theirin to have the same horizontal alignments. However each row of
// icons may have a separate collective height. IconView uses this to request
// the heights of each row based on a context which was already used to request
// all the row widths that are to be displayed.
	func (a CellArea) CopyContext(context CellAreaContextClass) CellAreaContext {
var _arg0 *C.GtkCellArea // out
var _arg1 *C.GtkCellAreaContext // out
var _cret *C.GtkCellAreaContext // in

_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkCellAreaContext)(unsafe.Pointer(context.Native()))

_cret = C.gtk_cell_area_copy_context(_arg0, _arg1)


var _cellAreaContext CellAreaContext // out

_cellAreaContext = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(CellAreaContext)

return _cellAreaContext
}
	
	// CreateContext creates a CellAreaContext to be used with @area for all
// purposes. CellAreaContext stores geometry information for rows for which it
// was operated on, it is important to use the same context for the same row of
// data at all times (i.e. one should render and handle events with the same
// CellAreaContext which was used to request the size of those rows of data).
	func (a CellArea) CreateContext() CellAreaContext {
var _arg0 *C.GtkCellArea // out
var _cret *C.GtkCellAreaContext // in

_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))

_cret = C.gtk_cell_area_create_context(_arg0)


var _cellAreaContext CellAreaContext // out

_cellAreaContext = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(CellAreaContext)

return _cellAreaContext
}
	
	// Focus: this should be called by the @area’s owning layout widget when focus
// is to be passed to @area, or moved within @area for a given @direction and
// row data.
// 
// Implementing CellArea classes should implement this method to receive and
// navigate focus in its own way particular to how it lays out cells.
	func (a CellArea) Focus(direction DirectionType) bool {
var _arg0 *C.GtkCellArea // out
var _arg1 C.GtkDirectionType // out
var _cret C.gboolean // in

_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
_arg1 = (C.GtkDirectionType)(direction)

_cret = C.gtk_cell_area_focus(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// CellAllocation derives the allocation of @renderer inside @area if @area were
// to be renderered in @cell_area.
	func (a CellArea) CellAllocation(context CellAreaContextClass, widget WidgetClass, renderer CellRendererClass, cellArea *gdk.Rectangle) gdk.Rectangle {
var _arg0 *C.GtkCellArea // out
var _arg1 *C.GtkCellAreaContext // out
var _arg2 *C.GtkWidget // out
var _arg3 *C.GtkCellRenderer // out
var _arg4 *C.GdkRectangle // out
var _allocation gdk.Rectangle

_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkCellAreaContext)(unsafe.Pointer(context.Native()))
_arg2 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg3 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))
_arg4 = (*C.GdkRectangle)(unsafe.Pointer(cellArea.Native()))

C.gtk_cell_area_get_cell_allocation(_arg0, _arg1, _arg2, _arg3, _arg4, (*C.GdkRectangle)(unsafe.Pointer(&_allocation)))





return _allocation
}
	
	// CellAtPosition gets the CellRenderer at @x and @y coordinates inside @area
// and optionally returns the full cell allocation for it inside @cell_area.
	func (a CellArea) CellAtPosition(context CellAreaContextClass, widget WidgetClass, cellArea *gdk.Rectangle, x int, y int) (gdk.Rectangle, CellRenderer) {
var _arg0 *C.GtkCellArea // out
var _arg1 *C.GtkCellAreaContext // out
var _arg2 *C.GtkWidget // out
var _arg3 *C.GdkRectangle // out
var _arg4 C.gint // out
var _arg5 C.gint // out
var _allocArea gdk.Rectangle
var _cret *C.GtkCellRenderer // in

_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkCellAreaContext)(unsafe.Pointer(context.Native()))
_arg2 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg3 = (*C.GdkRectangle)(unsafe.Pointer(cellArea.Native()))
_arg4 = (C.gint)(x)
_arg5 = (C.gint)(y)

_cret = C.gtk_cell_area_get_cell_at_position(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, (*C.GdkRectangle)(unsafe.Pointer(&_allocArea)))



var _cellRenderer CellRenderer // out


_cellRenderer = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(CellRenderer)

return _allocArea, _cellRenderer
}
	
	// CurrentPathString gets the current TreePath string for the currently applied
// TreeIter, this is implicitly updated when gtk_cell_area_apply_attributes() is
// called and can be used to interact with renderers from CellArea subclasses.
	func (a CellArea) CurrentPathString() string {
var _arg0 *C.GtkCellArea // out
var _cret *C.gchar // in

_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))

_cret = C.gtk_cell_area_get_current_path_string(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// EditWidget gets the CellEditable widget currently used to edit the currently
// edited cell.
	func (a CellArea) EditWidget() CellEditable {
var _arg0 *C.GtkCellArea // out
var _cret *C.GtkCellEditable // in

_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))

_cret = C.gtk_cell_area_get_edit_widget(_arg0)


var _cellEditable CellEditable // out

_cellEditable = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(CellEditable)

return _cellEditable
}
	
	// EditedCell gets the CellRenderer in @area that is currently being edited.
	func (a CellArea) EditedCell() CellRenderer {
var _arg0 *C.GtkCellArea // out
var _cret *C.GtkCellRenderer // in

_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))

_cret = C.gtk_cell_area_get_edited_cell(_arg0)


var _cellRenderer CellRenderer // out

_cellRenderer = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(CellRenderer)

return _cellRenderer
}
	
	// FocusCell retrieves the currently focused cell for @area
	func (a CellArea) FocusCell() CellRenderer {
var _arg0 *C.GtkCellArea // out
var _cret *C.GtkCellRenderer // in

_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))

_cret = C.gtk_cell_area_get_focus_cell(_arg0)


var _cellRenderer CellRenderer // out

_cellRenderer = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(CellRenderer)

return _cellRenderer
}
	
	// FocusFromSibling gets the CellRenderer which is expected to be focusable for
// which @renderer is, or may be a sibling.
// 
// This is handy for CellArea subclasses when handling events, after determining
// the renderer at the event location it can then chose to activate the focus
// cell for which the event cell may have been a sibling.
	func (a CellArea) FocusFromSibling(renderer CellRendererClass) CellRenderer {
var _arg0 *C.GtkCellArea // out
var _arg1 *C.GtkCellRenderer // out
var _cret *C.GtkCellRenderer // in

_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))

_cret = C.gtk_cell_area_get_focus_from_sibling(_arg0, _arg1)


var _cellRenderer CellRenderer // out

_cellRenderer = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(CellRenderer)

return _cellRenderer
}
	
	// PreferredHeight retrieves a cell area’s initial minimum and natural height.
// 
// @area will store some geometrical information in @context along the way; when
// requesting sizes over an arbitrary number of rows, it’s not important to
// check the @minimum_height and @natural_height of this call but rather to
// consult gtk_cell_area_context_get_preferred_height() after a series of
// requests.
	func (a CellArea) PreferredHeight(context CellAreaContextClass, widget WidgetClass) (minimumHeight int, naturalHeight int) {
var _arg0 *C.GtkCellArea // out
var _arg1 *C.GtkCellAreaContext // out
var _arg2 *C.GtkWidget // out
var _arg3 C.gint // in
var _arg4 C.gint // in

_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkCellAreaContext)(unsafe.Pointer(context.Native()))
_arg2 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

C.gtk_cell_area_get_preferred_height(_arg0, _arg1, _arg2, &_arg3, &_arg4)

var _minimumHeight int // out
var _naturalHeight int // out

_minimumHeight = (int)(_arg3)
_naturalHeight = (int)(_arg4)

return _minimumHeight, _naturalHeight
}
	
	// PreferredHeightForWidth retrieves a cell area’s minimum and natural height if
// it would be given the specified @width.
// 
// @area stores some geometrical information in @context along the way while
// calling gtk_cell_area_get_preferred_width(). It’s important to perform a
// series of gtk_cell_area_get_preferred_width() requests with @context first
// and then call gtk_cell_area_get_preferred_height_for_width() on each cell
// area individually to get the height for width of each fully requested row.
// 
// If at some point, the width of a single row changes, it should be requested
// with gtk_cell_area_get_preferred_width() again and then the full width of the
// requested rows checked again with
// gtk_cell_area_context_get_preferred_width().
	func (a CellArea) PreferredHeightForWidth(context CellAreaContextClass, widget WidgetClass, width int) (minimumHeight int, naturalHeight int) {
var _arg0 *C.GtkCellArea // out
var _arg1 *C.GtkCellAreaContext // out
var _arg2 *C.GtkWidget // out
var _arg3 C.gint // out
var _arg4 C.gint // in
var _arg5 C.gint // in

_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkCellAreaContext)(unsafe.Pointer(context.Native()))
_arg2 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg3 = (C.gint)(width)

C.gtk_cell_area_get_preferred_height_for_width(_arg0, _arg1, _arg2, _arg3, &_arg4, &_arg5)

var _minimumHeight int // out
var _naturalHeight int // out

_minimumHeight = (int)(_arg4)
_naturalHeight = (int)(_arg5)

return _minimumHeight, _naturalHeight
}
	
	// PreferredWidth retrieves a cell area’s initial minimum and natural width.
// 
// @area will store some geometrical information in @context along the way; when
// requesting sizes over an arbitrary number of rows, it’s not important to
// check the @minimum_width and @natural_width of this call but rather to
// consult gtk_cell_area_context_get_preferred_width() after a series of
// requests.
	func (a CellArea) PreferredWidth(context CellAreaContextClass, widget WidgetClass) (minimumWidth int, naturalWidth int) {
var _arg0 *C.GtkCellArea // out
var _arg1 *C.GtkCellAreaContext // out
var _arg2 *C.GtkWidget // out
var _arg3 C.gint // in
var _arg4 C.gint // in

_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkCellAreaContext)(unsafe.Pointer(context.Native()))
_arg2 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

C.gtk_cell_area_get_preferred_width(_arg0, _arg1, _arg2, &_arg3, &_arg4)

var _minimumWidth int // out
var _naturalWidth int // out

_minimumWidth = (int)(_arg3)
_naturalWidth = (int)(_arg4)

return _minimumWidth, _naturalWidth
}
	
	// PreferredWidthForHeight retrieves a cell area’s minimum and natural width if
// it would be given the specified @height.
// 
// @area stores some geometrical information in @context along the way while
// calling gtk_cell_area_get_preferred_height(). It’s important to perform a
// series of gtk_cell_area_get_preferred_height() requests with @context first
// and then call gtk_cell_area_get_preferred_width_for_height() on each cell
// area individually to get the height for width of each fully requested row.
// 
// If at some point, the height of a single row changes, it should be requested
// with gtk_cell_area_get_preferred_height() again and then the full height of
// the requested rows checked again with
// gtk_cell_area_context_get_preferred_height().
	func (a CellArea) PreferredWidthForHeight(context CellAreaContextClass, widget WidgetClass, height int) (minimumWidth int, naturalWidth int) {
var _arg0 *C.GtkCellArea // out
var _arg1 *C.GtkCellAreaContext // out
var _arg2 *C.GtkWidget // out
var _arg3 C.gint // out
var _arg4 C.gint // in
var _arg5 C.gint // in

_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkCellAreaContext)(unsafe.Pointer(context.Native()))
_arg2 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg3 = (C.gint)(height)

C.gtk_cell_area_get_preferred_width_for_height(_arg0, _arg1, _arg2, _arg3, &_arg4, &_arg5)

var _minimumWidth int // out
var _naturalWidth int // out

_minimumWidth = (int)(_arg4)
_naturalWidth = (int)(_arg5)

return _minimumWidth, _naturalWidth
}
	
	// RequestMode gets whether the area prefers a height-for-width layout or a
// width-for-height layout.
	func (a CellArea) RequestMode() SizeRequestMode {
var _arg0 *C.GtkCellArea // out
var _cret C.GtkSizeRequestMode // in

_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))

_cret = C.gtk_cell_area_get_request_mode(_arg0)


var _sizeRequestMode SizeRequestMode // out

_sizeRequestMode = SizeRequestMode(_cret)

return _sizeRequestMode
}
	
	// HasRenderer checks if @area contains @renderer.
	func (a CellArea) HasRenderer(renderer CellRendererClass) bool {
var _arg0 *C.GtkCellArea // out
var _arg1 *C.GtkCellRenderer // out
var _cret C.gboolean // in

_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))

_cret = C.gtk_cell_area_has_renderer(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// InnerCellArea: this is a convenience function for CellArea implementations to
// get the inner area where a given CellRenderer will be rendered. It removes
// any padding previously added by gtk_cell_area_request_renderer().
	func (a CellArea) InnerCellArea(widget WidgetClass, cellArea *gdk.Rectangle) gdk.Rectangle {
var _arg0 *C.GtkCellArea // out
var _arg1 *C.GtkWidget // out
var _arg2 *C.GdkRectangle // out
var _innerArea gdk.Rectangle

_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg2 = (*C.GdkRectangle)(unsafe.Pointer(cellArea.Native()))

C.gtk_cell_area_inner_cell_area(_arg0, _arg1, _arg2, (*C.GdkRectangle)(unsafe.Pointer(&_innerArea)))





return _innerArea
}
	
	// IsActivatable returns whether the area can do anything when activated, after
// applying new attributes to @area.
	func (a CellArea) IsActivatable() bool {
var _arg0 *C.GtkCellArea // out
var _cret C.gboolean // in

_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))

_cret = C.gtk_cell_area_is_activatable(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsFocusSibling returns whether @sibling is one of @renderer’s focus siblings
// (see gtk_cell_area_add_focus_sibling()).
	func (a CellArea) IsFocusSibling(renderer CellRendererClass, sibling CellRendererClass) bool {
var _arg0 *C.GtkCellArea // out
var _arg1 *C.GtkCellRenderer // out
var _arg2 *C.GtkCellRenderer // out
var _cret C.gboolean // in

_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))
_arg2 = (*C.GtkCellRenderer)(unsafe.Pointer(sibling.Native()))

_cret = C.gtk_cell_area_is_focus_sibling(_arg0, _arg1, _arg2)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Remove removes @renderer from @area.
	func (a CellArea) Remove(renderer CellRendererClass)  {
var _arg0 *C.GtkCellArea // out
var _arg1 *C.GtkCellRenderer // out

_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))

C.gtk_cell_area_remove(_arg0, _arg1)
}
	
	// RemoveFocusSibling removes @sibling from @renderer’s focus sibling list (see
// gtk_cell_area_add_focus_sibling()).
	func (a CellArea) RemoveFocusSibling(renderer CellRendererClass, sibling CellRendererClass)  {
var _arg0 *C.GtkCellArea // out
var _arg1 *C.GtkCellRenderer // out
var _arg2 *C.GtkCellRenderer // out

_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))
_arg2 = (*C.GtkCellRenderer)(unsafe.Pointer(sibling.Native()))

C.gtk_cell_area_remove_focus_sibling(_arg0, _arg1, _arg2)
}
	
	// Render renders @area’s cells according to @area’s layout onto @widget at the
// given coordinates.
	func (a CellArea) Render(context CellAreaContextClass, widget WidgetClass, cr *cairo.Context, backgroundArea *gdk.Rectangle, cellArea *gdk.Rectangle, flags CellRendererState, paintFocus bool)  {
var _arg0 *C.GtkCellArea // out
var _arg1 *C.GtkCellAreaContext // out
var _arg2 *C.GtkWidget // out
var _arg3 *C.cairo_t // out
var _arg4 *C.GdkRectangle // out
var _arg5 *C.GdkRectangle // out
var _arg6 C.GtkCellRendererState // out
var _arg7 C.gboolean // out

_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkCellAreaContext)(unsafe.Pointer(context.Native()))
_arg2 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg3 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
_arg4 = (*C.GdkRectangle)(unsafe.Pointer(backgroundArea.Native()))
_arg5 = (*C.GdkRectangle)(unsafe.Pointer(cellArea.Native()))
_arg6 = (C.GtkCellRendererState)(flags)
if paintFocus { _arg7 = C.TRUE }

C.gtk_cell_area_render(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7)
}
	
	// RequestRenderer: this is a convenience function for CellArea implementations
// to request size for cell renderers. It’s important to use this function to
// request size and then use gtk_cell_area_inner_cell_area() at render and event
// time since this function will add padding around the cell for focus painting.
	func (a CellArea) RequestRenderer(renderer CellRendererClass, orientation Orientation, widget WidgetClass, forSize int) (minimumSize int, naturalSize int) {
var _arg0 *C.GtkCellArea // out
var _arg1 *C.GtkCellRenderer // out
var _arg2 C.GtkOrientation // out
var _arg3 *C.GtkWidget // out
var _arg4 C.gint // out
var _arg5 C.gint // in
var _arg6 C.gint // in

_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))
_arg2 = (C.GtkOrientation)(orientation)
_arg3 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg4 = (C.gint)(forSize)

C.gtk_cell_area_request_renderer(_arg0, _arg1, _arg2, _arg3, _arg4, &_arg5, &_arg6)

var _minimumSize int // out
var _naturalSize int // out

_minimumSize = (int)(_arg5)
_naturalSize = (int)(_arg6)

return _minimumSize, _naturalSize
}
	
	// SetFocusCell: explicitly sets the currently focused cell to @renderer.
// 
// This is generally called by implementations of CellAreaClass.focus() or
// CellAreaClass.event(), however it can also be used to implement functions
// such as gtk_tree_view_set_cursor_on_cell().
	func (a CellArea) SetFocusCell(renderer CellRendererClass)  {
var _arg0 *C.GtkCellArea // out
var _arg1 *C.GtkCellRenderer // out

_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))

C.gtk_cell_area_set_focus_cell(_arg0, _arg1)
}
	
	// StopEditing: explicitly stops the editing of the currently edited cell.
// 
// If @canceled is true, the currently edited cell renderer will emit the
// ::editing-canceled signal, otherwise the the ::editing-done signal will be
// emitted on the current edit widget.
// 
// See gtk_cell_area_get_edited_cell() and gtk_cell_area_get_edit_widget().
	func (a CellArea) StopEditing(canceled bool)  {
var _arg0 *C.GtkCellArea // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
if canceled { _arg1 = C.TRUE }

C.gtk_cell_area_stop_editing(_arg0, _arg1)
}
	


	// CellAreaBox: the CellAreaBox renders cell renderers into a row or a column
// depending on its Orientation.
// 
// GtkCellAreaBox uses a notion of packing. Packing refers to adding cell
// renderers with reference to a particular position in a CellAreaBox. There are
// two reference positions: the start and the end of the box. When the
// CellAreaBox is oriented in the GTK_ORIENTATION_VERTICAL orientation, the
// start is defined as the top of the box and the end is defined as the bottom.
// In the GTK_ORIENTATION_HORIZONTAL orientation start is defined as the left
// side and the end is defined as the right side.
// 
// Alignments of CellRenderers rendered in adjacent rows can be configured by
// configuring the CellAreaBox align child cell property with
// gtk_cell_area_cell_set_property() or by specifying the "align" argument to
// gtk_cell_area_box_pack_start() and gtk_cell_area_box_pack_end().
	type CellAreaBox struct {
		CellArea
		Buildable
		CellLayout
		Orientable
		
	}

	// CellAreaBoxClass is an interface that the CellAreaBox class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type CellAreaBoxClass interface {
		gextras.Objector
		_cellAreaBox()
	}

	func (CellAreaBox) _cellAreaBox() {}

	
	func marshalCellAreaBox(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapCellAreaBox(obj), nil
	}
	

	
	// NewCellAreaBox creates a new CellAreaBox.
	func NewCellAreaBox() CellAreaBox {
var _cret *C.GtkCellArea // in

_cret = C.gtk_cell_area_box_new()


var _cellAreaBox CellAreaBox // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_cellAreaBox = CellAreaBox{
CellArea: CellArea{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
CellLayout: CellLayout{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
CellLayout: CellLayout{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _cellAreaBox
}
	

	
	// Spacing gets the spacing added between cell renderers.
	func (b CellAreaBox) Spacing() int {
var _arg0 *C.GtkCellAreaBox // out
var _cret C.gint // in

_arg0 = (*C.GtkCellAreaBox)(unsafe.Pointer(b.Native()))

_cret = C.gtk_cell_area_box_get_spacing(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// PackEnd adds @renderer to @box, packed with reference to the end of @box.
// 
// The @renderer is packed after (away from end of) any other CellRenderer
// packed with reference to the end of @box.
	func (b CellAreaBox) PackEnd(renderer CellRendererClass, expand bool, align bool, fixed bool)  {
var _arg0 *C.GtkCellAreaBox // out
var _arg1 *C.GtkCellRenderer // out
var _arg2 C.gboolean // out
var _arg3 C.gboolean // out
var _arg4 C.gboolean // out

_arg0 = (*C.GtkCellAreaBox)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))
if expand { _arg2 = C.TRUE }
if align { _arg3 = C.TRUE }
if fixed { _arg4 = C.TRUE }

C.gtk_cell_area_box_pack_end(_arg0, _arg1, _arg2, _arg3, _arg4)
}
	
	// PackStart adds @renderer to @box, packed with reference to the start of @box.
// 
// The @renderer is packed after any other CellRenderer packed with reference to
// the start of @box.
	func (b CellAreaBox) PackStart(renderer CellRendererClass, expand bool, align bool, fixed bool)  {
var _arg0 *C.GtkCellAreaBox // out
var _arg1 *C.GtkCellRenderer // out
var _arg2 C.gboolean // out
var _arg3 C.gboolean // out
var _arg4 C.gboolean // out

_arg0 = (*C.GtkCellAreaBox)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))
if expand { _arg2 = C.TRUE }
if align { _arg3 = C.TRUE }
if fixed { _arg4 = C.TRUE }

C.gtk_cell_area_box_pack_start(_arg0, _arg1, _arg2, _arg3, _arg4)
}
	
	// SetSpacing sets the spacing to add between cell renderers in @box.
	func (b CellAreaBox) SetSpacing(spacing int)  {
var _arg0 *C.GtkCellAreaBox // out
var _arg1 C.gint // out

_arg0 = (*C.GtkCellAreaBox)(unsafe.Pointer(b.Native()))
_arg1 = (C.gint)(spacing)

C.gtk_cell_area_box_set_spacing(_arg0, _arg1)
}
	


	// CellAreaContext: the CellAreaContext object is created by a given CellArea
// implementation via its CellAreaClass.create_context() virtual method and is
// used to store cell sizes and alignments for a series of TreeModel rows that
// are requested and rendered in the same context.
// 
// CellLayout widgets can create any number of contexts in which to request and
// render groups of data rows. However, it’s important that the same context
// which was used to request sizes for a given TreeModel row also be used for
// the same row when calling other CellArea APIs such as gtk_cell_area_render()
// and gtk_cell_area_event().
	type CellAreaContext struct {
		**externglib.Object
		
	}

	// CellAreaContextClass is an interface that the CellAreaContext class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type CellAreaContextClass interface {
		gextras.Objector
		_cellAreaContext()
	}

	func (CellAreaContext) _cellAreaContext() {}

	
	func marshalCellAreaContext(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapCellAreaContext(obj), nil
	}
	

	

	
	// Allocate allocates a width and/or a height for all rows which are to be
// rendered with @context.
// 
// Usually allocation is performed only horizontally or sometimes vertically
// since a group of rows are usually rendered side by side vertically or
// horizontally and share either the same width or the same height. Sometimes
// they are allocated in both horizontal and vertical orientations producing a
// homogeneous effect of the rows. This is generally the case for TreeView when
// TreeView:fixed-height-mode is enabled.
// 
// Since 3.0
	func (c CellAreaContext) Allocate(width int, height int)  {
var _arg0 *C.GtkCellAreaContext // out
var _arg1 C.gint // out
var _arg2 C.gint // out

_arg0 = (*C.GtkCellAreaContext)(unsafe.Pointer(c.Native()))
_arg1 = (C.gint)(width)
_arg2 = (C.gint)(height)

C.gtk_cell_area_context_allocate(_arg0, _arg1, _arg2)
}
	
	// Allocation fetches the current allocation size for @context.
// 
// If the context was not allocated in width or height, or if the context was
// recently reset with gtk_cell_area_context_reset(), the returned value will be
// -1.
	func (c CellAreaContext) Allocation() (width int, height int) {
var _arg0 *C.GtkCellAreaContext // out
var _arg1 C.gint // in
var _arg2 C.gint // in

_arg0 = (*C.GtkCellAreaContext)(unsafe.Pointer(c.Native()))

C.gtk_cell_area_context_get_allocation(_arg0, &_arg1, &_arg2)

var _width int // out
var _height int // out

_width = (int)(_arg1)
_height = (int)(_arg2)

return _width, _height
}
	
	// Area fetches the CellArea this @context was created by.
// 
// This is generally unneeded by layouting widgets; however, it is important for
// the context implementation itself to fetch information about the area it is
// being used for.
// 
// For instance at CellAreaContextClass.allocate() time it’s important to know
// details about any cell spacing that the CellArea is configured with in order
// to compute a proper allocation.
	func (c CellAreaContext) Area() CellArea {
var _arg0 *C.GtkCellAreaContext // out
var _cret *C.GtkCellArea // in

_arg0 = (*C.GtkCellAreaContext)(unsafe.Pointer(c.Native()))

_cret = C.gtk_cell_area_context_get_area(_arg0)


var _cellArea CellArea // out

_cellArea = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(CellArea)

return _cellArea
}
	
	// PreferredHeight gets the accumulative preferred height for all rows which
// have been requested with this context.
// 
// After gtk_cell_area_context_reset() is called and/or before ever requesting
// the size of a CellArea, the returned values are 0.
	func (c CellAreaContext) PreferredHeight() (minimumHeight int, naturalHeight int) {
var _arg0 *C.GtkCellAreaContext // out
var _arg1 C.gint // in
var _arg2 C.gint // in

_arg0 = (*C.GtkCellAreaContext)(unsafe.Pointer(c.Native()))

C.gtk_cell_area_context_get_preferred_height(_arg0, &_arg1, &_arg2)

var _minimumHeight int // out
var _naturalHeight int // out

_minimumHeight = (int)(_arg1)
_naturalHeight = (int)(_arg2)

return _minimumHeight, _naturalHeight
}
	
	// PreferredHeightForWidth gets the accumulative preferred height for @width for
// all rows which have been requested for the same said @width with this
// context.
// 
// After gtk_cell_area_context_reset() is called and/or before ever requesting
// the size of a CellArea, the returned values are -1.
	func (c CellAreaContext) PreferredHeightForWidth(width int) (minimumHeight int, naturalHeight int) {
var _arg0 *C.GtkCellAreaContext // out
var _arg1 C.gint // out
var _arg2 C.gint // in
var _arg3 C.gint // in

_arg0 = (*C.GtkCellAreaContext)(unsafe.Pointer(c.Native()))
_arg1 = (C.gint)(width)

C.gtk_cell_area_context_get_preferred_height_for_width(_arg0, _arg1, &_arg2, &_arg3)

var _minimumHeight int // out
var _naturalHeight int // out

_minimumHeight = (int)(_arg2)
_naturalHeight = (int)(_arg3)

return _minimumHeight, _naturalHeight
}
	
	// PreferredWidth gets the accumulative preferred width for all rows which have
// been requested with this context.
// 
// After gtk_cell_area_context_reset() is called and/or before ever requesting
// the size of a CellArea, the returned values are 0.
	func (c CellAreaContext) PreferredWidth() (minimumWidth int, naturalWidth int) {
var _arg0 *C.GtkCellAreaContext // out
var _arg1 C.gint // in
var _arg2 C.gint // in

_arg0 = (*C.GtkCellAreaContext)(unsafe.Pointer(c.Native()))

C.gtk_cell_area_context_get_preferred_width(_arg0, &_arg1, &_arg2)

var _minimumWidth int // out
var _naturalWidth int // out

_minimumWidth = (int)(_arg1)
_naturalWidth = (int)(_arg2)

return _minimumWidth, _naturalWidth
}
	
	// PreferredWidthForHeight gets the accumulative preferred width for @height for
// all rows which have been requested for the same said @height with this
// context.
// 
// After gtk_cell_area_context_reset() is called and/or before ever requesting
// the size of a CellArea, the returned values are -1.
	func (c CellAreaContext) PreferredWidthForHeight(height int) (minimumWidth int, naturalWidth int) {
var _arg0 *C.GtkCellAreaContext // out
var _arg1 C.gint // out
var _arg2 C.gint // in
var _arg3 C.gint // in

_arg0 = (*C.GtkCellAreaContext)(unsafe.Pointer(c.Native()))
_arg1 = (C.gint)(height)

C.gtk_cell_area_context_get_preferred_width_for_height(_arg0, _arg1, &_arg2, &_arg3)

var _minimumWidth int // out
var _naturalWidth int // out

_minimumWidth = (int)(_arg2)
_naturalWidth = (int)(_arg3)

return _minimumWidth, _naturalWidth
}
	
	// PushPreferredHeight causes the minimum and/or natural height to grow if the
// new proposed sizes exceed the current minimum and natural height.
// 
// This is used by CellAreaContext implementations during the request process
// over a series of TreeModel rows to progressively push the requested height
// over a series of gtk_cell_area_get_preferred_height() requests.
	func (c CellAreaContext) PushPreferredHeight(minimumHeight int, naturalHeight int)  {
var _arg0 *C.GtkCellAreaContext // out
var _arg1 C.gint // out
var _arg2 C.gint // out

_arg0 = (*C.GtkCellAreaContext)(unsafe.Pointer(c.Native()))
_arg1 = (C.gint)(minimumHeight)
_arg2 = (C.gint)(naturalHeight)

C.gtk_cell_area_context_push_preferred_height(_arg0, _arg1, _arg2)
}
	
	// PushPreferredWidth causes the minimum and/or natural width to grow if the new
// proposed sizes exceed the current minimum and natural width.
// 
// This is used by CellAreaContext implementations during the request process
// over a series of TreeModel rows to progressively push the requested width
// over a series of gtk_cell_area_get_preferred_width() requests.
	func (c CellAreaContext) PushPreferredWidth(minimumWidth int, naturalWidth int)  {
var _arg0 *C.GtkCellAreaContext // out
var _arg1 C.gint // out
var _arg2 C.gint // out

_arg0 = (*C.GtkCellAreaContext)(unsafe.Pointer(c.Native()))
_arg1 = (C.gint)(minimumWidth)
_arg2 = (C.gint)(naturalWidth)

C.gtk_cell_area_context_push_preferred_width(_arg0, _arg1, _arg2)
}
	
	// Reset resets any previously cached request and allocation data.
// 
// When underlying TreeModel data changes its important to reset the context if
// the content size is allowed to shrink. If the content size is only allowed to
// grow (this is usually an option for views rendering large data stores as a
// measure of optimization), then only the row that changed or was inserted
// needs to be (re)requested with gtk_cell_area_get_preferred_width().
// 
// When the new overall size of the context requires that the allocated size
// changes (or whenever this allocation changes at all), the variable row sizes
// need to be re-requested for every row.
// 
// For instance, if the rows are displayed all with the same width from top to
// bottom then a change in the allocated width necessitates a recalculation of
// all the displayed row heights using
// gtk_cell_area_get_preferred_height_for_width().
// 
// Since 3.0
	func (c CellAreaContext) Reset()  {
var _arg0 *C.GtkCellAreaContext // out

_arg0 = (*C.GtkCellAreaContext)(unsafe.Pointer(c.Native()))

C.gtk_cell_area_context_reset(_arg0)
}
	


	// CellRenderer: the CellRenderer is a base class of a set of objects used for
// rendering a cell to a #cairo_t. These objects are used primarily by the
// TreeView widget, though they aren’t tied to them in any specific way. It is
// worth noting that CellRenderer is not a Widget and cannot be treated as such.
// 
// The primary use of a CellRenderer is for drawing a certain graphical elements
// on a #cairo_t. Typically, one cell renderer is used to draw many cells on the
// screen. To this extent, it isn’t expected that a CellRenderer keep any
// permanent state around. Instead, any state is set just prior to use using
// #GObjects property system. Then, the cell is measured using
// gtk_cell_renderer_get_size(). Finally, the cell is rendered in the correct
// location using gtk_cell_renderer_render().
// 
// There are a number of rules that must be followed when writing a new
// CellRenderer. First and foremost, it’s important that a certain set of
// properties will always yield a cell renderer of the same size, barring a
// Style change. The CellRenderer also has a number of generic properties that
// are expected to be honored by all children.
// 
// Beyond merely rendering a cell, cell renderers can optionally provide active
// user interface elements. A cell renderer can be “activatable” like
// CellRendererToggle, which toggles when it gets activated by a mouse click, or
// it can be “editable” like CellRendererText, which allows the user to edit the
// text using a widget implementing the CellEditable interface, e.g. Entry. To
// make a cell renderer activatable or editable, you have to implement the
// CellRendererClass.activate or CellRendererClass.start_editing virtual
// functions, respectively.
// 
// Many properties of CellRenderer and its subclasses have a corresponding “set”
// property, e.g. “cell-background-set” corresponds to “cell-background”. These
// “set” properties reflect whether a property has been set or not. You should
// not set them independently.
	type CellRenderer struct {
		externglib.InitiallyUnowned
		
	}

	// CellRendererClass is an interface that the CellRenderer class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type CellRendererClass interface {
		gextras.Objector
		_cellRenderer()
	}

	func (CellRenderer) _cellRenderer() {}

	
	func marshalCellRenderer(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapCellRenderer(obj), nil
	}
	

	

	
	// AlignedArea gets the aligned area used by @cell inside @cell_area. Used for
// finding the appropriate edit and focus rectangle.
	func (c CellRenderer) AlignedArea(widget WidgetClass, flags CellRendererState, cellArea *gdk.Rectangle) gdk.Rectangle {
var _arg0 *C.GtkCellRenderer // out
var _arg1 *C.GtkWidget // out
var _arg2 C.GtkCellRendererState // out
var _arg3 *C.GdkRectangle // out
var _alignedArea gdk.Rectangle

_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg2 = (C.GtkCellRendererState)(flags)
_arg3 = (*C.GdkRectangle)(unsafe.Pointer(cellArea.Native()))

C.gtk_cell_renderer_get_aligned_area(_arg0, _arg1, _arg2, _arg3, (*C.GdkRectangle)(unsafe.Pointer(&_alignedArea)))





return _alignedArea
}
	
	// Alignment fills in @xalign and @yalign with the appropriate values of @cell.
	func (c CellRenderer) Alignment() (xalign float32, yalign float32) {
var _arg0 *C.GtkCellRenderer // out
var _arg1 C.gfloat // in
var _arg2 C.gfloat // in

_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))

C.gtk_cell_renderer_get_alignment(_arg0, &_arg1, &_arg2)

var _xalign float32 // out
var _yalign float32 // out

_xalign = (float32)(_arg1)
_yalign = (float32)(_arg2)

return _xalign, _yalign
}
	
	// FixedSize fills in @width and @height with the appropriate size of @cell.
	func (c CellRenderer) FixedSize() (width int, height int) {
var _arg0 *C.GtkCellRenderer // out
var _arg1 C.gint // in
var _arg2 C.gint // in

_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))

C.gtk_cell_renderer_get_fixed_size(_arg0, &_arg1, &_arg2)

var _width int // out
var _height int // out

_width = (int)(_arg1)
_height = (int)(_arg2)

return _width, _height
}
	
	// Padding fills in @xpad and @ypad with the appropriate values of @cell.
	func (c CellRenderer) Padding() (xpad int, ypad int) {
var _arg0 *C.GtkCellRenderer // out
var _arg1 C.gint // in
var _arg2 C.gint // in

_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))

C.gtk_cell_renderer_get_padding(_arg0, &_arg1, &_arg2)

var _xpad int // out
var _ypad int // out

_xpad = (int)(_arg1)
_ypad = (int)(_arg2)

return _xpad, _ypad
}
	
	// PreferredHeight retreives a renderer’s natural size when rendered to @widget.
	func (c CellRenderer) PreferredHeight(widget WidgetClass) (minimumSize int, naturalSize int) {
var _arg0 *C.GtkCellRenderer // out
var _arg1 *C.GtkWidget // out
var _arg2 C.gint // in
var _arg3 C.gint // in

_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

C.gtk_cell_renderer_get_preferred_height(_arg0, _arg1, &_arg2, &_arg3)

var _minimumSize int // out
var _naturalSize int // out

_minimumSize = (int)(_arg2)
_naturalSize = (int)(_arg3)

return _minimumSize, _naturalSize
}
	
	// PreferredHeightForWidth retreives a cell renderers’s minimum and natural
// height if it were rendered to @widget with the specified @width.
	func (c CellRenderer) PreferredHeightForWidth(widget WidgetClass, width int) (minimumHeight int, naturalHeight int) {
var _arg0 *C.GtkCellRenderer // out
var _arg1 *C.GtkWidget // out
var _arg2 C.gint // out
var _arg3 C.gint // in
var _arg4 C.gint // in

_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg2 = (C.gint)(width)

C.gtk_cell_renderer_get_preferred_height_for_width(_arg0, _arg1, _arg2, &_arg3, &_arg4)

var _minimumHeight int // out
var _naturalHeight int // out

_minimumHeight = (int)(_arg3)
_naturalHeight = (int)(_arg4)

return _minimumHeight, _naturalHeight
}
	
	// PreferredSize retrieves the minimum and natural size of a cell taking into
// account the widget’s preference for height-for-width management.
	func (c CellRenderer) PreferredSize(widget WidgetClass) (minimumSize Requisition, naturalSize Requisition) {
var _arg0 *C.GtkCellRenderer // out
var _arg1 *C.GtkWidget // out
var _minimumSize Requisition
var _naturalSize Requisition

_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

C.gtk_cell_renderer_get_preferred_size(_arg0, _arg1, (*C.GtkRequisition)(unsafe.Pointer(&_minimumSize)), (*C.GtkRequisition)(unsafe.Pointer(&_naturalSize)))







return _minimumSize, _naturalSize
}
	
	// PreferredWidth retreives a renderer’s natural size when rendered to @widget.
	func (c CellRenderer) PreferredWidth(widget WidgetClass) (minimumSize int, naturalSize int) {
var _arg0 *C.GtkCellRenderer // out
var _arg1 *C.GtkWidget // out
var _arg2 C.gint // in
var _arg3 C.gint // in

_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

C.gtk_cell_renderer_get_preferred_width(_arg0, _arg1, &_arg2, &_arg3)

var _minimumSize int // out
var _naturalSize int // out

_minimumSize = (int)(_arg2)
_naturalSize = (int)(_arg3)

return _minimumSize, _naturalSize
}
	
	// PreferredWidthForHeight retreives a cell renderers’s minimum and natural
// width if it were rendered to @widget with the specified @height.
	func (c CellRenderer) PreferredWidthForHeight(widget WidgetClass, height int) (minimumWidth int, naturalWidth int) {
var _arg0 *C.GtkCellRenderer // out
var _arg1 *C.GtkWidget // out
var _arg2 C.gint // out
var _arg3 C.gint // in
var _arg4 C.gint // in

_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg2 = (C.gint)(height)

C.gtk_cell_renderer_get_preferred_width_for_height(_arg0, _arg1, _arg2, &_arg3, &_arg4)

var _minimumWidth int // out
var _naturalWidth int // out

_minimumWidth = (int)(_arg3)
_naturalWidth = (int)(_arg4)

return _minimumWidth, _naturalWidth
}
	
	// RequestMode gets whether the cell renderer prefers a height-for-width layout
// or a width-for-height layout.
	func (c CellRenderer) RequestMode() SizeRequestMode {
var _arg0 *C.GtkCellRenderer // out
var _cret C.GtkSizeRequestMode // in

_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))

_cret = C.gtk_cell_renderer_get_request_mode(_arg0)


var _sizeRequestMode SizeRequestMode // out

_sizeRequestMode = SizeRequestMode(_cret)

return _sizeRequestMode
}
	
	// Sensitive returns the cell renderer’s sensitivity.
	func (c CellRenderer) Sensitive() bool {
var _arg0 *C.GtkCellRenderer // out
var _cret C.gboolean // in

_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))

_cret = C.gtk_cell_renderer_get_sensitive(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Size obtains the width and height needed to render the cell. Used by view
// widgets to determine the appropriate size for the cell_area passed to
// gtk_cell_renderer_render(). If @cell_area is not nil, fills in the x and y
// offsets (if set) of the cell relative to this location.
// 
// Please note that the values set in @width and @height, as well as those in
// @x_offset and @y_offset are inclusive of the xpad and ypad properties.
	func (c CellRenderer) Size(widget WidgetClass, cellArea *gdk.Rectangle) (xOffset int, yOffset int, width int, height int) {
var _arg0 *C.GtkCellRenderer // out
var _arg1 *C.GtkWidget // out
var _arg2 *C.GdkRectangle // out
var _arg3 C.gint // in
var _arg4 C.gint // in
var _arg5 C.gint // in
var _arg6 C.gint // in

_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg2 = (*C.GdkRectangle)(unsafe.Pointer(cellArea.Native()))

C.gtk_cell_renderer_get_size(_arg0, _arg1, _arg2, &_arg3, &_arg4, &_arg5, &_arg6)

var _xOffset int // out
var _yOffset int // out
var _width int // out
var _height int // out

_xOffset = (int)(_arg3)
_yOffset = (int)(_arg4)
_width = (int)(_arg5)
_height = (int)(_arg6)

return _xOffset, _yOffset, _width, _height
}
	
	// State translates the cell renderer state to StateFlags, based on the cell
// renderer and widget sensitivity, and the given CellRendererState.
	func (c CellRenderer) State(widget WidgetClass, cellState CellRendererState) StateFlags {
var _arg0 *C.GtkCellRenderer // out
var _arg1 *C.GtkWidget // out
var _arg2 C.GtkCellRendererState // out
var _cret C.GtkStateFlags // in

_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg2 = (C.GtkCellRendererState)(cellState)

_cret = C.gtk_cell_renderer_get_state(_arg0, _arg1, _arg2)


var _stateFlags StateFlags // out

_stateFlags = StateFlags(_cret)

return _stateFlags
}
	
	// Visible returns the cell renderer’s visibility.
	func (c CellRenderer) Visible() bool {
var _arg0 *C.GtkCellRenderer // out
var _cret C.gboolean // in

_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))

_cret = C.gtk_cell_renderer_get_visible(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsActivatable checks whether the cell renderer can do something when
// activated.
	func (c CellRenderer) IsActivatable() bool {
var _arg0 *C.GtkCellRenderer // out
var _cret C.gboolean // in

_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))

_cret = C.gtk_cell_renderer_is_activatable(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Render invokes the virtual render function of the CellRenderer. The three
// passed-in rectangles are areas in @cr. Most renderers will draw within
// @cell_area; the xalign, yalign, xpad, and ypad fields of the CellRenderer
// should be honored with respect to @cell_area. @background_area includes the
// blank space around the cell, and also the area containing the tree expander;
// so the @background_area rectangles for all cells tile to cover the entire
// @window.
	func (c CellRenderer) Render(cr *cairo.Context, widget WidgetClass, backgroundArea *gdk.Rectangle, cellArea *gdk.Rectangle, flags CellRendererState)  {
var _arg0 *C.GtkCellRenderer // out
var _arg1 *C.cairo_t // out
var _arg2 *C.GtkWidget // out
var _arg3 *C.GdkRectangle // out
var _arg4 *C.GdkRectangle // out
var _arg5 C.GtkCellRendererState // out

_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))
_arg1 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
_arg2 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg3 = (*C.GdkRectangle)(unsafe.Pointer(backgroundArea.Native()))
_arg4 = (*C.GdkRectangle)(unsafe.Pointer(cellArea.Native()))
_arg5 = (C.GtkCellRendererState)(flags)

C.gtk_cell_renderer_render(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
}
	
	// SetAlignment sets the renderer’s alignment within its available space.
	func (c CellRenderer) SetAlignment(xalign float32, yalign float32)  {
var _arg0 *C.GtkCellRenderer // out
var _arg1 C.gfloat // out
var _arg2 C.gfloat // out

_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))
_arg1 = (C.gfloat)(xalign)
_arg2 = (C.gfloat)(yalign)

C.gtk_cell_renderer_set_alignment(_arg0, _arg1, _arg2)
}
	
	// SetFixedSize sets the renderer size to be explicit, independent of the
// properties set.
	func (c CellRenderer) SetFixedSize(width int, height int)  {
var _arg0 *C.GtkCellRenderer // out
var _arg1 C.gint // out
var _arg2 C.gint // out

_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))
_arg1 = (C.gint)(width)
_arg2 = (C.gint)(height)

C.gtk_cell_renderer_set_fixed_size(_arg0, _arg1, _arg2)
}
	
	// SetPadding sets the renderer’s padding.
	func (c CellRenderer) SetPadding(xpad int, ypad int)  {
var _arg0 *C.GtkCellRenderer // out
var _arg1 C.gint // out
var _arg2 C.gint // out

_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))
_arg1 = (C.gint)(xpad)
_arg2 = (C.gint)(ypad)

C.gtk_cell_renderer_set_padding(_arg0, _arg1, _arg2)
}
	
	// SetSensitive sets the cell renderer’s sensitivity.
	func (c CellRenderer) SetSensitive(sensitive bool)  {
var _arg0 *C.GtkCellRenderer // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))
if sensitive { _arg1 = C.TRUE }

C.gtk_cell_renderer_set_sensitive(_arg0, _arg1)
}
	
	// SetVisible sets the cell renderer’s visibility.
	func (c CellRenderer) SetVisible(visible bool)  {
var _arg0 *C.GtkCellRenderer // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))
if visible { _arg1 = C.TRUE }

C.gtk_cell_renderer_set_visible(_arg0, _arg1)
}
	
	// StopEditing informs the cell renderer that the editing is stopped. If
// @canceled is true, the cell renderer will emit the
// CellRenderer::editing-canceled signal.
// 
// This function should be called by cell renderer implementations in response
// to the CellEditable::editing-done signal of CellEditable.
	func (c CellRenderer) StopEditing(canceled bool)  {
var _arg0 *C.GtkCellRenderer // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))
if canceled { _arg1 = C.TRUE }

C.gtk_cell_renderer_stop_editing(_arg0, _arg1)
}
	


	// CellRendererAccel displays a keyboard accelerator (i.e. a key combination
// like `Control + a`). If the cell renderer is editable, the accelerator can be
// changed by simply typing the new combination.
// 
// The CellRendererAccel cell renderer was added in GTK+ 2.10.
	type CellRendererAccel struct {
		CellRendererText
		
	}

	// CellRendererAccelClass is an interface that the CellRendererAccel class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type CellRendererAccelClass interface {
		gextras.Objector
		_cellRendererAccel()
	}

	func (CellRendererAccel) _cellRendererAccel() {}

	
	func marshalCellRendererAccel(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapCellRendererAccel(obj), nil
	}
	

	
	// NewCellRendererAccel creates a new CellRendererAccel.
	func NewCellRendererAccel() CellRendererAccel {
var _cret *C.GtkCellRenderer // in

_cret = C.gtk_cell_renderer_accel_new()


var _cellRendererAccel CellRendererAccel // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_cellRendererAccel = CellRendererAccel{
CellRendererText: CellRendererText{
CellRenderer: CellRenderer{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
}
}

return _cellRendererAccel
}
	

	


	// CellRendererCombo renders text in a cell like CellRendererText from which it
// is derived. But while CellRendererText offers a simple entry to edit the
// text, CellRendererCombo offers a ComboBox widget to edit the text. The values
// to display in the combo box are taken from the tree model specified in the
// CellRendererCombo:model property.
// 
// The combo cell renderer takes care of adding a text cell renderer to the
// combo box and sets it to display the column specified by its
// CellRendererCombo:text-column property. Further properties of the combo box
// can be set in a handler for the CellRenderer::editing-started signal.
// 
// The CellRendererCombo cell renderer was added in GTK+ 2.6.
	type CellRendererCombo struct {
		CellRendererText
		
	}

	// CellRendererComboClass is an interface that the CellRendererCombo class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type CellRendererComboClass interface {
		gextras.Objector
		_cellRendererCombo()
	}

	func (CellRendererCombo) _cellRendererCombo() {}

	
	func marshalCellRendererCombo(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapCellRendererCombo(obj), nil
	}
	

	
	// NewCellRendererCombo creates a new CellRendererCombo. Adjust how text is
// drawn using object properties. Object properties can be set globally (with
// g_object_set()). Also, with TreeViewColumn, you can bind a property to a
// value in a TreeModel. For example, you can bind the “text” property on the
// cell renderer to a string value in the model, thus rendering a different
// string in each row of the TreeView.
	func NewCellRendererCombo() CellRendererCombo {
var _cret *C.GtkCellRenderer // in

_cret = C.gtk_cell_renderer_combo_new()


var _cellRendererCombo CellRendererCombo // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_cellRendererCombo = CellRendererCombo{
CellRendererText: CellRendererText{
CellRenderer: CellRenderer{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
}
}

return _cellRendererCombo
}
	

	


	// CellRendererPixbuf: a CellRendererPixbuf can be used to render an image in a
// cell. It allows to render either a given Pixbuf (set via the
// CellRendererPixbuf:pixbuf property) or a named icon (set via the
// CellRendererPixbuf:icon-name property).
// 
// To support the tree view, CellRendererPixbuf also supports rendering two
// alternative pixbufs, when the CellRenderer:is-expander property is true. If
// the CellRenderer:is-expanded property is true and the
// CellRendererPixbuf:pixbuf-expander-open property is set to a pixbuf, it
// renders that pixbuf, if the CellRenderer:is-expanded property is false and
// the CellRendererPixbuf:pixbuf-expander-closed property is set to a pixbuf, it
// renders that one.
	type CellRendererPixbuf struct {
		CellRenderer
		
	}

	// CellRendererPixbufClass is an interface that the CellRendererPixbuf class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type CellRendererPixbufClass interface {
		gextras.Objector
		_cellRendererPixbuf()
	}

	func (CellRendererPixbuf) _cellRendererPixbuf() {}

	
	func marshalCellRendererPixbuf(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapCellRendererPixbuf(obj), nil
	}
	

	
	// NewCellRendererPixbuf creates a new CellRendererPixbuf. Adjust rendering
// parameters using object properties. Object properties can be set globally
// (with g_object_set()). Also, with TreeViewColumn, you can bind a property to
// a value in a TreeModel. For example, you can bind the “pixbuf” property on
// the cell renderer to a pixbuf value in the model, thus rendering a different
// image in each row of the TreeView.
	func NewCellRendererPixbuf() CellRendererPixbuf {
var _cret *C.GtkCellRenderer // in

_cret = C.gtk_cell_renderer_pixbuf_new()


var _cellRendererPixbuf CellRendererPixbuf // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_cellRendererPixbuf = CellRendererPixbuf{
CellRenderer: CellRenderer{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
}
}

return _cellRendererPixbuf
}
	

	


	// CellRendererProgress renders a numeric value as a progress par in a cell.
// Additionally, it can display a text on top of the progress bar.
// 
// The CellRendererProgress cell renderer was added in GTK+ 2.6.
	type CellRendererProgress struct {
		CellRenderer
		Orientable
		
	}

	// CellRendererProgressClass is an interface that the CellRendererProgress class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type CellRendererProgressClass interface {
		gextras.Objector
		_cellRendererProgress()
	}

	func (CellRendererProgress) _cellRendererProgress() {}

	
	func marshalCellRendererProgress(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapCellRendererProgress(obj), nil
	}
	

	
	// NewCellRendererProgress creates a new CellRendererProgress.
	func NewCellRendererProgress() CellRendererProgress {
var _cret *C.GtkCellRenderer // in

_cret = C.gtk_cell_renderer_progress_new()


var _cellRendererProgress CellRendererProgress // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_cellRendererProgress = CellRendererProgress{
CellRenderer: CellRenderer{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _cellRendererProgress
}
	

	


	// CellRendererSpin renders text in a cell like CellRendererText from which it
// is derived. But while CellRendererText offers a simple entry to edit the
// text, CellRendererSpin offers a SpinButton widget. Of course, that means that
// the text has to be parseable as a floating point number.
// 
// The range of the spinbutton is taken from the adjustment property of the cell
// renderer, which can be set explicitly or mapped to a column in the tree
// model, like all properties of cell renders. CellRendererSpin also has
// properties for the CellRendererSpin:climb-rate and the number of
// CellRendererSpin:digits to display. Other SpinButton properties can be set in
// a handler for the CellRenderer::editing-started signal.
// 
// The CellRendererSpin cell renderer was added in GTK+ 2.10.
	type CellRendererSpin struct {
		CellRendererText
		
	}

	// CellRendererSpinClass is an interface that the CellRendererSpin class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type CellRendererSpinClass interface {
		gextras.Objector
		_cellRendererSpin()
	}

	func (CellRendererSpin) _cellRendererSpin() {}

	
	func marshalCellRendererSpin(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapCellRendererSpin(obj), nil
	}
	

	
	// NewCellRendererSpin creates a new CellRendererSpin.
	func NewCellRendererSpin() CellRendererSpin {
var _cret *C.GtkCellRenderer // in

_cret = C.gtk_cell_renderer_spin_new()


var _cellRendererSpin CellRendererSpin // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_cellRendererSpin = CellRendererSpin{
CellRendererText: CellRendererText{
CellRenderer: CellRenderer{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
}
}

return _cellRendererSpin
}
	

	


	// CellRendererSpinner: gtkCellRendererSpinner renders a spinning animation in a
// cell, very similar to Spinner. It can often be used as an alternative to a
// CellRendererProgress for displaying indefinite activity, instead of actual
// progress.
// 
// To start the animation in a cell, set the CellRendererSpinner:active property
// to true and increment the CellRendererSpinner:pulse property at regular
// intervals. The usual way to set the cell renderer properties for each cell is
// to bind them to columns in your tree model using e.g.
// gtk_tree_view_column_add_attribute().
	type CellRendererSpinner struct {
		CellRenderer
		
	}

	// CellRendererSpinnerClass is an interface that the CellRendererSpinner class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type CellRendererSpinnerClass interface {
		gextras.Objector
		_cellRendererSpinner()
	}

	func (CellRendererSpinner) _cellRendererSpinner() {}

	
	func marshalCellRendererSpinner(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapCellRendererSpinner(obj), nil
	}
	

	
	// NewCellRendererSpinner returns a new cell renderer which will show a spinner
// to indicate activity.
	func NewCellRendererSpinner() CellRendererSpinner {
var _cret *C.GtkCellRenderer // in

_cret = C.gtk_cell_renderer_spinner_new()


var _cellRendererSpinner CellRendererSpinner // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_cellRendererSpinner = CellRendererSpinner{
CellRenderer: CellRenderer{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
}
}

return _cellRendererSpinner
}
	

	


	// CellRendererText: a CellRendererText renders a given text in its cell, using
// the font, color and style information provided by its properties. The text
// will be ellipsized if it is too long and the CellRendererText:ellipsize
// property allows it.
// 
// If the CellRenderer:mode is GTK_CELL_RENDERER_MODE_EDITABLE, the
// CellRendererText allows to edit its text using an entry.
	type CellRendererText struct {
		CellRenderer
		
	}

	// CellRendererTextClass is an interface that the CellRendererText class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type CellRendererTextClass interface {
		gextras.Objector
		_cellRendererText()
	}

	func (CellRendererText) _cellRendererText() {}

	
	func marshalCellRendererText(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapCellRendererText(obj), nil
	}
	

	
	// NewCellRendererText creates a new CellRendererText. Adjust how text is drawn
// using object properties. Object properties can be set globally (with
// g_object_set()). Also, with TreeViewColumn, you can bind a property to a
// value in a TreeModel. For example, you can bind the “text” property on the
// cell renderer to a string value in the model, thus rendering a different
// string in each row of the TreeView
	func NewCellRendererText() CellRendererText {
var _cret *C.GtkCellRenderer // in

_cret = C.gtk_cell_renderer_text_new()


var _cellRendererText CellRendererText // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_cellRendererText = CellRendererText{
CellRenderer: CellRenderer{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
}
}

return _cellRendererText
}
	

	
	// SetFixedHeightFromFont sets the height of a renderer to explicitly be
// determined by the “font” and “y_pad” property set on it. Further changes in
// these properties do not affect the height, so they must be accompanied by a
// subsequent call to this function. Using this function is unflexible, and
// should really only be used if calculating the size of a cell is too slow (ie,
// a massive number of cells displayed). If @number_of_rows is -1, then the
// fixed height is unset, and the height is determined by the properties again.
	func (r CellRendererText) SetFixedHeightFromFont(numberOfRows int)  {
var _arg0 *C.GtkCellRendererText // out
var _arg1 C.gint // out

_arg0 = (*C.GtkCellRendererText)(unsafe.Pointer(r.Native()))
_arg1 = (C.gint)(numberOfRows)

C.gtk_cell_renderer_text_set_fixed_height_from_font(_arg0, _arg1)
}
	


	// CellRendererToggle renders a toggle button in a cell. The button is drawn as
// a radio or a checkbutton, depending on the CellRendererToggle:radio property.
// When activated, it emits the CellRendererToggle::toggled signal.
	type CellRendererToggle struct {
		CellRenderer
		
	}

	// CellRendererToggleClass is an interface that the CellRendererToggle class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type CellRendererToggleClass interface {
		gextras.Objector
		_cellRendererToggle()
	}

	func (CellRendererToggle) _cellRendererToggle() {}

	
	func marshalCellRendererToggle(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapCellRendererToggle(obj), nil
	}
	

	
	// NewCellRendererToggle creates a new CellRendererToggle. Adjust rendering
// parameters using object properties. Object properties can be set globally
// (with g_object_set()). Also, with TreeViewColumn, you can bind a property to
// a value in a TreeModel. For example, you can bind the “active” property on
// the cell renderer to a boolean value in the model, thus causing the check
// button to reflect the state of the model.
	func NewCellRendererToggle() CellRendererToggle {
var _cret *C.GtkCellRenderer // in

_cret = C.gtk_cell_renderer_toggle_new()


var _cellRendererToggle CellRendererToggle // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_cellRendererToggle = CellRendererToggle{
CellRenderer: CellRenderer{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
}
}

return _cellRendererToggle
}
	

	
	// Activatable returns whether the cell renderer is activatable. See
// gtk_cell_renderer_toggle_set_activatable().
	func (t CellRendererToggle) Activatable() bool {
var _arg0 *C.GtkCellRendererToggle // out
var _cret C.gboolean // in

_arg0 = (*C.GtkCellRendererToggle)(unsafe.Pointer(t.Native()))

_cret = C.gtk_cell_renderer_toggle_get_activatable(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Active returns whether the cell renderer is active. See
// gtk_cell_renderer_toggle_set_active().
	func (t CellRendererToggle) Active() bool {
var _arg0 *C.GtkCellRendererToggle // out
var _cret C.gboolean // in

_arg0 = (*C.GtkCellRendererToggle)(unsafe.Pointer(t.Native()))

_cret = C.gtk_cell_renderer_toggle_get_active(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Radio returns whether we’re rendering radio toggles rather than checkboxes.
	func (t CellRendererToggle) Radio() bool {
var _arg0 *C.GtkCellRendererToggle // out
var _cret C.gboolean // in

_arg0 = (*C.GtkCellRendererToggle)(unsafe.Pointer(t.Native()))

_cret = C.gtk_cell_renderer_toggle_get_radio(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetActivatable makes the cell renderer activatable.
	func (t CellRendererToggle) SetActivatable(setting bool)  {
var _arg0 *C.GtkCellRendererToggle // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkCellRendererToggle)(unsafe.Pointer(t.Native()))
if setting { _arg1 = C.TRUE }

C.gtk_cell_renderer_toggle_set_activatable(_arg0, _arg1)
}
	
	// SetActive activates or deactivates a cell renderer.
	func (t CellRendererToggle) SetActive(setting bool)  {
var _arg0 *C.GtkCellRendererToggle // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkCellRendererToggle)(unsafe.Pointer(t.Native()))
if setting { _arg1 = C.TRUE }

C.gtk_cell_renderer_toggle_set_active(_arg0, _arg1)
}
	
	// SetRadio: if @radio is true, the cell renderer renders a radio toggle (i.e. a
// toggle in a group of mutually-exclusive toggles). If false, it renders a
// check toggle (a standalone boolean option). This can be set globally for the
// cell renderer, or changed just before rendering each cell in the model (for
// TreeView, you set up a per-row setting using TreeViewColumn to associate
// model columns with cell renderer properties).
	func (t CellRendererToggle) SetRadio(radio bool)  {
var _arg0 *C.GtkCellRendererToggle // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkCellRendererToggle)(unsafe.Pointer(t.Native()))
if radio { _arg1 = C.TRUE }

C.gtk_cell_renderer_toggle_set_radio(_arg0, _arg1)
}
	


	// CellView: a CellView displays a single row of a TreeModel using a CellArea
// and CellAreaContext. A CellAreaContext can be provided to the CellView at
// construction time in order to keep the cellview in context of a group of cell
// views, this ensures that the renderers displayed will be properly aligned
// with eachother (like the aligned cells in the menus of ComboBox).
// 
// CellView is Orientable in order to decide in which orientation the underlying
// CellAreaContext should be allocated. Taking the ComboBox menu as an example,
// cellviews should be oriented horizontally if the menus are listed
// top-to-bottom and thus all share the same width but may have separate
// individual heights (left-to-right menus should be allocated vertically since
// they all share the same height but may have variable widths).
// 
// 
// CSS nodes
// 
// GtkCellView has a single CSS node with name cellview.
	type CellView struct {
		Widget
		Buildable
		CellLayout
		Orientable
		
	}

	// CellViewClass is an interface that the CellView class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type CellViewClass interface {
		gextras.Objector
		_cellView()
	}

	func (CellView) _cellView() {}

	
	func marshalCellView(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapCellView(obj), nil
	}
	

	
	// NewCellView creates a new CellView widget.
	func NewCellView() CellView {
var _cret *C.GtkWidget // in

_cret = C.gtk_cell_view_new()


var _cellView CellView // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_cellView = CellView{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
CellLayout: CellLayout{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _cellView
}
	
	// NewCellViewWithContext creates a new CellView widget with a specific CellArea
// to layout cells and a specific CellAreaContext.
// 
// Specifying the same context for a handfull of cells lets the underlying area
// synchronize the geometry for those cells, in this way alignments with
// cellviews for other rows are possible.
	func NewCellViewWithContext(area CellAreaClass, context CellAreaContextClass) CellView {
var _arg1 *C.GtkCellArea // out
var _arg2 *C.GtkCellAreaContext // out
var _cret *C.GtkWidget // in

_arg1 = (*C.GtkCellArea)(unsafe.Pointer(area.Native()))
_arg2 = (*C.GtkCellAreaContext)(unsafe.Pointer(context.Native()))

_cret = C.gtk_cell_view_new_with_context(_arg1, _arg2)


var _cellView CellView // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_cellView = CellView{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
CellLayout: CellLayout{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _cellView
}
	
	// NewCellViewWithMarkup creates a new CellView widget, adds a CellRendererText
// to it, and makes it show @markup. The text can be marked up with the [Pango
// text markup language][PangoMarkupFormat].
	func NewCellViewWithMarkup(markup string) CellView {
var _arg1 *C.gchar // out
var _cret *C.GtkWidget // in

_arg1 = (*C.gchar)(C.CString(markup))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_cell_view_new_with_markup(_arg1)


var _cellView CellView // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_cellView = CellView{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
CellLayout: CellLayout{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _cellView
}
	
	// NewCellViewWithPixbuf creates a new CellView widget, adds a
// CellRendererPixbuf to it, and makes it show @pixbuf.
	func NewCellViewWithPixbuf(pixbuf gdkpixbuf.PixbufClass) CellView {
var _arg1 *C.GdkPixbuf // out
var _cret *C.GtkWidget // in

_arg1 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))

_cret = C.gtk_cell_view_new_with_pixbuf(_arg1)


var _cellView CellView // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_cellView = CellView{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
CellLayout: CellLayout{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _cellView
}
	
	// NewCellViewWithText creates a new CellView widget, adds a CellRendererText to
// it, and makes it show @text.
	func NewCellViewWithText(text string) CellView {
var _arg1 *C.gchar // out
var _cret *C.GtkWidget // in

_arg1 = (*C.gchar)(C.CString(text))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_cell_view_new_with_text(_arg1)


var _cellView CellView // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_cellView = CellView{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
CellLayout: CellLayout{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _cellView
}
	

	
	// DisplayedRow returns a TreePath referring to the currently displayed row. If
// no row is currently displayed, nil is returned.
	func (c CellView) DisplayedRow() *TreePath {
var _arg0 *C.GtkCellView // out
var _cret *C.GtkTreePath // in

_arg0 = (*C.GtkCellView)(unsafe.Pointer(c.Native()))

_cret = C.gtk_cell_view_get_displayed_row(_arg0)


var _treePath *TreePath // out

_treePath = *(**TreePath)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_treePath, func(v *TreePath) {
  C.free(unsafe.Pointer(v.Native()))
})

return _treePath
}
	
	// DrawSensitive gets whether @cell_view is configured to draw all of its cells
// in a sensitive state.
	func (c CellView) DrawSensitive() bool {
var _arg0 *C.GtkCellView // out
var _cret C.gboolean // in

_arg0 = (*C.GtkCellView)(unsafe.Pointer(c.Native()))

_cret = C.gtk_cell_view_get_draw_sensitive(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// FitModel gets whether @cell_view is configured to request space to fit the
// entire TreeModel.
	func (c CellView) FitModel() bool {
var _arg0 *C.GtkCellView // out
var _cret C.gboolean // in

_arg0 = (*C.GtkCellView)(unsafe.Pointer(c.Native()))

_cret = C.gtk_cell_view_get_fit_model(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Model returns the model for @cell_view. If no model is used nil is returned.
	func (c CellView) Model() TreeModel {
var _arg0 *C.GtkCellView // out
var _cret *C.GtkTreeModel // in

_arg0 = (*C.GtkCellView)(unsafe.Pointer(c.Native()))

_cret = C.gtk_cell_view_get_model(_arg0)


var _treeModel TreeModel // out

_treeModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TreeModel)

return _treeModel
}
	
	// SizeOfRow sets @requisition to the size needed by @cell_view to display the
// model row pointed to by @path.
	func (c CellView) SizeOfRow(path *TreePath) (Requisition, bool) {
var _arg0 *C.GtkCellView // out
var _arg1 *C.GtkTreePath // out
var _requisition Requisition
var _cret C.gboolean // in

_arg0 = (*C.GtkCellView)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

_cret = C.gtk_cell_view_get_size_of_row(_arg0, _arg1, (*C.GtkRequisition)(unsafe.Pointer(&_requisition)))



var _ok bool // out


if _cret != 0 { _ok = true }

return _requisition, _ok
}
	
	// SetBackgroundColor sets the background color of @view.
	func (c CellView) SetBackgroundColor(color *gdk.Color)  {
var _arg0 *C.GtkCellView // out
var _arg1 *C.GdkColor // out

_arg0 = (*C.GtkCellView)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GdkColor)(unsafe.Pointer(color.Native()))

C.gtk_cell_view_set_background_color(_arg0, _arg1)
}
	
	// SetBackgroundRGBA sets the background color of @cell_view.
	func (c CellView) SetBackgroundRGBA(rgba *gdk.RGBA)  {
var _arg0 *C.GtkCellView // out
var _arg1 *C.GdkRGBA // out

_arg0 = (*C.GtkCellView)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GdkRGBA)(unsafe.Pointer(rgba.Native()))

C.gtk_cell_view_set_background_rgba(_arg0, _arg1)
}
	
	// SetDisplayedRow sets the row of the model that is currently displayed by the
// CellView. If the path is unset, then the contents of the cellview “stick” at
// their last value; this is not normally a desired result, but may be a needed
// intermediate state if say, the model for the CellView becomes temporarily
// empty.
	func (c CellView) SetDisplayedRow(path *TreePath)  {
var _arg0 *C.GtkCellView // out
var _arg1 *C.GtkTreePath // out

_arg0 = (*C.GtkCellView)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

C.gtk_cell_view_set_displayed_row(_arg0, _arg1)
}
	
	// SetDrawSensitive sets whether @cell_view should draw all of its cells in a
// sensitive state, this is used by ComboBox menus to ensure that rows with
// insensitive cells that contain children appear sensitive in the parent menu
// item.
	func (c CellView) SetDrawSensitive(drawSensitive bool)  {
var _arg0 *C.GtkCellView // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkCellView)(unsafe.Pointer(c.Native()))
if drawSensitive { _arg1 = C.TRUE }

C.gtk_cell_view_set_draw_sensitive(_arg0, _arg1)
}
	
	// SetFitModel sets whether @cell_view should request space to fit the entire
// TreeModel.
// 
// This is used by ComboBox to ensure that the cell view displayed on the combo
// box’s button always gets enough space and does not resize when selection
// changes.
	func (c CellView) SetFitModel(fitModel bool)  {
var _arg0 *C.GtkCellView // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkCellView)(unsafe.Pointer(c.Native()))
if fitModel { _arg1 = C.TRUE }

C.gtk_cell_view_set_fit_model(_arg0, _arg1)
}
	
	// SetModel sets the model for @cell_view. If @cell_view already has a model
// set, it will remove it before setting the new model. If @model is nil, then
// it will unset the old model.
	func (c CellView) SetModel(model TreeModel)  {
var _arg0 *C.GtkCellView // out
var _arg1 *C.GtkTreeModel // out

_arg0 = (*C.GtkCellView)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GtkTreeModel)(unsafe.Pointer(model.Native()))

C.gtk_cell_view_set_model(_arg0, _arg1)
}
	


	// CheckButton: a CheckButton places a discrete ToggleButton next to a widget,
// (usually a Label). See the section on ToggleButton widgets for more
// information about toggle/check buttons.
// 
// The important signal ( ToggleButton::toggled ) is also inherited from
// ToggleButton.
// 
// CSS nodes
// 
//    button.check
//    ├── check
//    ╰── <child>
// 
// A GtkCheckButton without indicator changes the name of its main node to
// button and adds a .check style class to it. The subnode is invisible in this
// case.
	type CheckButton struct {
		ToggleButton
		Actionable
		Activatable
		Buildable
		
	}

	// CheckButtonClass is an interface that the CheckButton class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type CheckButtonClass interface {
		gextras.Objector
		_checkButton()
	}

	func (CheckButton) _checkButton() {}

	
	func marshalCheckButton(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapCheckButton(obj), nil
	}
	

	
	// NewCheckButton creates a new CheckButton.
	func NewCheckButton() CheckButton {
var _cret *C.GtkWidget // in

_cret = C.gtk_check_button_new()


var _checkButton CheckButton // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_checkButton = CheckButton{
ToggleButton: ToggleButton{
Button: Button{
Bin: Bin{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _checkButton
}
	
	// NewCheckButtonWithLabel creates a new CheckButton with a Label to the right
// of it.
	func NewCheckButtonWithLabel(label string) CheckButton {
var _arg1 *C.gchar // out
var _cret *C.GtkWidget // in

_arg1 = (*C.gchar)(C.CString(label))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_check_button_new_with_label(_arg1)


var _checkButton CheckButton // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_checkButton = CheckButton{
ToggleButton: ToggleButton{
Button: Button{
Bin: Bin{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _checkButton
}
	
	// NewCheckButtonWithMnemonic creates a new CheckButton containing a label. The
// label will be created using gtk_label_new_with_mnemonic(), so underscores in
// @label indicate the mnemonic for the check button.
	func NewCheckButtonWithMnemonic(label string) CheckButton {
var _arg1 *C.gchar // out
var _cret *C.GtkWidget // in

_arg1 = (*C.gchar)(C.CString(label))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_check_button_new_with_mnemonic(_arg1)


var _checkButton CheckButton // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_checkButton = CheckButton{
ToggleButton: ToggleButton{
Button: Button{
Bin: Bin{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _checkButton
}
	

	


	// CheckMenuItem: a CheckMenuItem is a menu item that maintains the state of a
// boolean value in addition to a MenuItem usual role in activating application
// code.
// 
// A check box indicating the state of the boolean value is displayed at the
// left side of the MenuItem. Activating the MenuItem toggles the value.
// 
// CSS nodes
// 
//    menuitem
//    ├── check.left
//    ╰── <child>
// 
// GtkCheckMenuItem has a main CSS node with name menuitem, and a subnode with
// name check, which gets the .left or .right style class.
	type CheckMenuItem struct {
		MenuItem
		Actionable
		Activatable
		Buildable
		
	}

	// CheckMenuItemClass is an interface that the CheckMenuItem class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type CheckMenuItemClass interface {
		gextras.Objector
		_checkMenuItem()
	}

	func (CheckMenuItem) _checkMenuItem() {}

	
	func marshalCheckMenuItem(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapCheckMenuItem(obj), nil
	}
	

	
	// NewCheckMenuItem creates a new CheckMenuItem.
	func NewCheckMenuItem() CheckMenuItem {
var _cret *C.GtkWidget // in

_cret = C.gtk_check_menu_item_new()


var _checkMenuItem CheckMenuItem // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_checkMenuItem = CheckMenuItem{
MenuItem: MenuItem{
Bin: Bin{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _checkMenuItem
}
	
	// NewCheckMenuItemWithLabel creates a new CheckMenuItem with a label.
	func NewCheckMenuItemWithLabel(label string) CheckMenuItem {
var _arg1 *C.gchar // out
var _cret *C.GtkWidget // in

_arg1 = (*C.gchar)(C.CString(label))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_check_menu_item_new_with_label(_arg1)


var _checkMenuItem CheckMenuItem // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_checkMenuItem = CheckMenuItem{
MenuItem: MenuItem{
Bin: Bin{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _checkMenuItem
}
	
	// NewCheckMenuItemWithMnemonic creates a new CheckMenuItem containing a label.
// The label will be created using gtk_label_new_with_mnemonic(), so underscores
// in @label indicate the mnemonic for the menu item.
	func NewCheckMenuItemWithMnemonic(label string) CheckMenuItem {
var _arg1 *C.gchar // out
var _cret *C.GtkWidget // in

_arg1 = (*C.gchar)(C.CString(label))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_check_menu_item_new_with_mnemonic(_arg1)


var _checkMenuItem CheckMenuItem // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_checkMenuItem = CheckMenuItem{
MenuItem: MenuItem{
Bin: Bin{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _checkMenuItem
}
	

	
	// Active returns whether the check menu item is active. See
// gtk_check_menu_item_set_active ().
	func (c CheckMenuItem) Active() bool {
var _arg0 *C.GtkCheckMenuItem // out
var _cret C.gboolean // in

_arg0 = (*C.GtkCheckMenuItem)(unsafe.Pointer(c.Native()))

_cret = C.gtk_check_menu_item_get_active(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// DrawAsRadio returns whether @check_menu_item looks like a RadioMenuItem
	func (c CheckMenuItem) DrawAsRadio() bool {
var _arg0 *C.GtkCheckMenuItem // out
var _cret C.gboolean // in

_arg0 = (*C.GtkCheckMenuItem)(unsafe.Pointer(c.Native()))

_cret = C.gtk_check_menu_item_get_draw_as_radio(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Inconsistent retrieves the value set by
// gtk_check_menu_item_set_inconsistent().
	func (c CheckMenuItem) Inconsistent() bool {
var _arg0 *C.GtkCheckMenuItem // out
var _cret C.gboolean // in

_arg0 = (*C.GtkCheckMenuItem)(unsafe.Pointer(c.Native()))

_cret = C.gtk_check_menu_item_get_inconsistent(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetActive sets the active state of the menu item’s check box.
	func (c CheckMenuItem) SetActive(isActive bool)  {
var _arg0 *C.GtkCheckMenuItem // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkCheckMenuItem)(unsafe.Pointer(c.Native()))
if isActive { _arg1 = C.TRUE }

C.gtk_check_menu_item_set_active(_arg0, _arg1)
}
	
	// SetDrawAsRadio sets whether @check_menu_item is drawn like a RadioMenuItem
	func (c CheckMenuItem) SetDrawAsRadio(drawAsRadio bool)  {
var _arg0 *C.GtkCheckMenuItem // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkCheckMenuItem)(unsafe.Pointer(c.Native()))
if drawAsRadio { _arg1 = C.TRUE }

C.gtk_check_menu_item_set_draw_as_radio(_arg0, _arg1)
}
	
	// SetInconsistent: if the user has selected a range of elements (such as some
// text or spreadsheet cells) that are affected by a boolean setting, and the
// current values in that range are inconsistent, you may want to display the
// check in an “in between” state. This function turns on “in between” display.
// Normally you would turn off the inconsistent state again if the user
// explicitly selects a setting. This has to be done manually,
// gtk_check_menu_item_set_inconsistent() only affects visual appearance, it
// doesn’t affect the semantics of the widget.
	func (c CheckMenuItem) SetInconsistent(setting bool)  {
var _arg0 *C.GtkCheckMenuItem // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkCheckMenuItem)(unsafe.Pointer(c.Native()))
if setting { _arg1 = C.TRUE }

C.gtk_check_menu_item_set_inconsistent(_arg0, _arg1)
}
	
	// Toggled emits the CheckMenuItem::toggled signal.
	func (c CheckMenuItem) Toggled()  {
var _arg0 *C.GtkCheckMenuItem // out

_arg0 = (*C.GtkCheckMenuItem)(unsafe.Pointer(c.Native()))

C.gtk_check_menu_item_toggled(_arg0)
}
	


	// Clipboard: the Clipboard object represents a clipboard of data shared between
// different processes or between different widgets in the same process. Each
// clipboard is identified by a name encoded as a Atom. (Conversion to and from
// strings can be done with gdk_atom_intern() and gdk_atom_name().) The default
// clipboard corresponds to the “CLIPBOARD” atom; another commonly used
// clipboard is the “PRIMARY” clipboard, which, in X, traditionally contains the
// currently selected text.
// 
// To support having a number of different formats on the clipboard at the same
// time, the clipboard mechanism allows providing callbacks instead of the
// actual data. When you set the contents of the clipboard, you can either
// supply the data directly (via functions like gtk_clipboard_set_text()), or
// you can supply a callback to be called at a later time when the data is
// needed (via gtk_clipboard_set_with_data() or gtk_clipboard_set_with_owner().)
// Providing a callback also avoids having to make copies of the data when it is
// not needed.
// 
// gtk_clipboard_set_with_data() and gtk_clipboard_set_with_owner() are quite
// similar; the choice between the two depends mostly on which is more
// convenient in a particular situation. The former is most useful when you want
// to have a blob of data with callbacks to convert it into the various data
// types that you advertise. When the @clear_func you provided is called, you
// simply free the data blob. The latter is more useful when the contents of
// clipboard reflect the internal state of a #GObject (As an example, for the
// PRIMARY clipboard, when an entry widget provides the clipboard’s contents the
// contents are simply the text within the selected region.) If the contents
// change, the entry widget can call gtk_clipboard_set_with_owner() to update
// the timestamp for clipboard ownership, without having to worry about
// @clear_func being called.
// 
// Requesting the data from the clipboard is essentially asynchronous. If the
// contents of the clipboard are provided within the same process, then a direct
// function call will be made to retrieve the data, but if they are provided by
// another process, then the data needs to be retrieved from the other process,
// which may take some time. To avoid blocking the user interface, the call to
// request the selection, gtk_clipboard_request_contents() takes a callback that
// will be called when the contents are received (or when the request fails.) If
// you don’t want to deal with providing a separate callback, you can also use
// gtk_clipboard_wait_for_contents(). What this does is run the GLib main loop
// recursively waiting for the contents. This can simplify the code flow, but
// you still have to be aware that other callbacks in your program can be called
// while this recursive mainloop is running.
// 
// Along with the functions to get the clipboard contents as an arbitrary data
// chunk, there are also functions to retrieve it as text,
// gtk_clipboard_request_text() and gtk_clipboard_wait_for_text(). These
// functions take care of determining which formats are advertised by the
// clipboard provider, asking for the clipboard in the best available format and
// converting the results into the UTF-8 encoding. (The standard form for
// representing strings in GTK+.)
	type Clipboard struct {
		**externglib.Object
		
	}

	// ClipboardClass is an interface that the Clipboard class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ClipboardClass interface {
		gextras.Objector
		_clipboard()
	}

	func (Clipboard) _clipboard() {}

	
	func marshalClipboard(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapClipboard(obj), nil
	}
	

	

	
	// Clear clears the contents of the clipboard. Generally this should only be
// called between the time you call gtk_clipboard_set_with_owner() or
// gtk_clipboard_set_with_data(), and when the @clear_func you supplied is
// called. Otherwise, the clipboard may be owned by someone else.
	func (c Clipboard) Clear()  {
var _arg0 *C.GtkClipboard // out

_arg0 = (*C.GtkClipboard)(unsafe.Pointer(c.Native()))

C.gtk_clipboard_clear(_arg0)
}
	
	// Display gets the Display associated with @clipboard
	func (c Clipboard) Display() gdk.Display {
var _arg0 *C.GtkClipboard // out
var _cret *C.GdkDisplay // in

_arg0 = (*C.GtkClipboard)(unsafe.Pointer(c.Native()))

_cret = C.gtk_clipboard_get_display(_arg0)


var _display gdk.Display // out

_display = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Display)

return _display
}
	
	// Owner: if the clipboard contents callbacks were set with
// gtk_clipboard_set_with_owner(), and the gtk_clipboard_set_with_data() or
// gtk_clipboard_clear() has not subsequently called, returns the owner set by
// gtk_clipboard_set_with_owner().
	func (c Clipboard) Owner() **externglib.Object {
var _arg0 *C.GtkClipboard // out
var _cret *C.GObject // in

_arg0 = (*C.GtkClipboard)(unsafe.Pointer(c.Native()))

_cret = C.gtk_clipboard_get_owner(_arg0)


var _object **externglib.Object // out

_object = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(**externglib.Object)

return _object
}
	
	// SetCanStore hints that the clipboard data should be stored somewhere when the
// application exits or when gtk_clipboard_store () is called.
// 
// This value is reset when the clipboard owner changes. Where the clipboard
// data is stored is platform dependent, see gdk_display_store_clipboard () for
// more information.
	func (c Clipboard) SetCanStore(targets []TargetEntry)  {
var _arg0 *C.GtkClipboard // out
var _arg1 *C.GtkTargetEntry
var _arg2 C.gint

_arg0 = (*C.GtkClipboard)(unsafe.Pointer(c.Native()))
_arg2 = C.gint(len(targets))
_arg1 = (*C.GtkTargetEntry)(unsafe.Pointer(&targets[0]))

C.gtk_clipboard_set_can_store(_arg0, _arg1, _arg2)
}
	
	// SetImage sets the contents of the clipboard to the given Pixbuf. GTK+ will
// take responsibility for responding for requests for the image, and for
// converting the image into the requested format.
	func (c Clipboard) SetImage(pixbuf gdkpixbuf.PixbufClass)  {
var _arg0 *C.GtkClipboard // out
var _arg1 *C.GdkPixbuf // out

_arg0 = (*C.GtkClipboard)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))

C.gtk_clipboard_set_image(_arg0, _arg1)
}
	
	// SetText sets the contents of the clipboard to the given UTF-8 string. GTK+
// will make a copy of the text and take responsibility for responding for
// requests for the text, and for converting the text into the requested format.
	func (c Clipboard) SetText(text string, len int)  {
var _arg0 *C.GtkClipboard // out
var _arg1 *C.gchar // out
var _arg2 C.gint // out

_arg0 = (*C.GtkClipboard)(unsafe.Pointer(c.Native()))
_arg1 = (*C.gchar)(C.CString(text))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.gint)(len)

C.gtk_clipboard_set_text(_arg0, _arg1, _arg2)
}
	
	// Store stores the current clipboard data somewhere so that it will stay around
// after the application has quit.
	func (c Clipboard) Store()  {
var _arg0 *C.GtkClipboard // out

_arg0 = (*C.GtkClipboard)(unsafe.Pointer(c.Native()))

C.gtk_clipboard_store(_arg0)
}
	
	// WaitForContents requests the contents of the clipboard using the given
// target. This function waits for the data to be received using the main loop,
// so events, timeouts, etc, may be dispatched during the wait.
	func (c Clipboard) WaitForContents(target *gdk.Atom) *SelectionData {
var _arg0 *C.GtkClipboard // out
var _arg1 C.GdkAtom // out
var _cret *C.GtkSelectionData // in

_arg0 = (*C.GtkClipboard)(unsafe.Pointer(c.Native()))
_arg1 = (C.GdkAtom)(unsafe.Pointer(target.Native()))

_cret = C.gtk_clipboard_wait_for_contents(_arg0, _arg1)


var _selectionData *SelectionData // out

_selectionData = *(**SelectionData)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_selectionData, func(v *SelectionData) {
  C.free(unsafe.Pointer(v.Native()))
})

return _selectionData
}
	
	// WaitForImage requests the contents of the clipboard as image and converts the
// result to a Pixbuf. This function waits for the data to be received using the
// main loop, so events, timeouts, etc, may be dispatched during the wait.
	func (c Clipboard) WaitForImage() gdkpixbuf.Pixbuf {
var _arg0 *C.GtkClipboard // out
var _cret *C.GdkPixbuf // in

_arg0 = (*C.GtkClipboard)(unsafe.Pointer(c.Native()))

_cret = C.gtk_clipboard_wait_for_image(_arg0)


var _pixbuf gdkpixbuf.Pixbuf // out

_pixbuf = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gdkpixbuf.Pixbuf)

return _pixbuf
}
	
	// WaitForTargets returns a list of targets that are present on the clipboard,
// or nil if there aren’t any targets available. The returned list must be freed
// with g_free(). This function waits for the data to be received using the main
// loop, so events, timeouts, etc, may be dispatched during the wait.
	func (c Clipboard) WaitForTargets() ([]gdk.Atom, bool) {
var _arg0 *C.GtkClipboard // out
var _arg1 *C.GdkAtom
var _arg2 C.gint // in
var _cret C.gboolean // in

_arg0 = (*C.GtkClipboard)(unsafe.Pointer(c.Native()))

_cret = C.gtk_clipboard_wait_for_targets(_arg0, &_arg1, &_arg2)


var _targets []gdk.Atom
var _ok bool // out

_targets = unsafe.Slice((*gdk.Atom)(unsafe.Pointer(_arg1)), _arg2)
runtime.SetFinalizer(&_targets, func(v *[]gdk.Atom) {
  C.free(unsafe.Pointer(&(*v)[0]))
})
if _cret != 0 { _ok = true }

return _targets, _ok
}
	
	// WaitForText requests the contents of the clipboard as text and converts the
// result to UTF-8 if necessary. This function waits for the data to be received
// using the main loop, so events, timeouts, etc, may be dispatched during the
// wait.
	func (c Clipboard) WaitForText() string {
var _arg0 *C.GtkClipboard // out
var _cret *C.gchar // in

_arg0 = (*C.GtkClipboard)(unsafe.Pointer(c.Native()))

_cret = C.gtk_clipboard_wait_for_text(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// WaitForUris requests the contents of the clipboard as URIs. This function
// waits for the data to be received using the main loop, so events, timeouts,
// etc, may be dispatched during the wait.
	func (c Clipboard) WaitForUris() []string {
var _arg0 *C.GtkClipboard // out
var _cret **C.gchar

_arg0 = (*C.GtkClipboard)(unsafe.Pointer(c.Native()))

_cret = C.gtk_clipboard_wait_for_uris(_arg0)


var _utf8s []string

{
var i int
var z *C.gchar
for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
  i++
}

src := unsafe.Slice(_cret, i)
_utf8s = make([]string, i)
for i := range src {
_utf8s[i] = C.GoString(src[i])
defer C.free(unsafe.Pointer(src[i]))
}
}

return _utf8s
}
	
	// WaitIsImageAvailable: test to see if there is an image available to be pasted
// This is done by requesting the TARGETS atom and checking if it contains any
// of the supported image targets. This function waits for the data to be
// received using the main loop, so events, timeouts, etc, may be dispatched
// during the wait.
// 
// This function is a little faster than calling gtk_clipboard_wait_for_image()
// since it doesn’t need to retrieve the actual image data.
	func (c Clipboard) WaitIsImageAvailable() bool {
var _arg0 *C.GtkClipboard // out
var _cret C.gboolean // in

_arg0 = (*C.GtkClipboard)(unsafe.Pointer(c.Native()))

_cret = C.gtk_clipboard_wait_is_image_available(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// WaitIsRichTextAvailable: test to see if there is rich text available to be
// pasted This is done by requesting the TARGETS atom and checking if it
// contains any of the supported rich text targets. This function waits for the
// data to be received using the main loop, so events, timeouts, etc, may be
// dispatched during the wait.
// 
// This function is a little faster than calling
// gtk_clipboard_wait_for_rich_text() since it doesn’t need to retrieve the
// actual text.
	func (c Clipboard) WaitIsRichTextAvailable(buffer TextBufferClass) bool {
var _arg0 *C.GtkClipboard // out
var _arg1 *C.GtkTextBuffer // out
var _cret C.gboolean // in

_arg0 = (*C.GtkClipboard)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))

_cret = C.gtk_clipboard_wait_is_rich_text_available(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// WaitIsTargetAvailable checks if a clipboard supports pasting data of a given
// type. This function can be used to determine if a “Paste” menu item should be
// insensitive or not.
// 
// If you want to see if there’s text available on the clipboard, use
// gtk_clipboard_wait_is_text_available () instead.
	func (c Clipboard) WaitIsTargetAvailable(target *gdk.Atom) bool {
var _arg0 *C.GtkClipboard // out
var _arg1 C.GdkAtom // out
var _cret C.gboolean // in

_arg0 = (*C.GtkClipboard)(unsafe.Pointer(c.Native()))
_arg1 = (C.GdkAtom)(unsafe.Pointer(target.Native()))

_cret = C.gtk_clipboard_wait_is_target_available(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// WaitIsTextAvailable: test to see if there is text available to be pasted This
// is done by requesting the TARGETS atom and checking if it contains any of the
// supported text targets. This function waits for the data to be received using
// the main loop, so events, timeouts, etc, may be dispatched during the wait.
// 
// This function is a little faster than calling gtk_clipboard_wait_for_text()
// since it doesn’t need to retrieve the actual text.
	func (c Clipboard) WaitIsTextAvailable() bool {
var _arg0 *C.GtkClipboard // out
var _cret C.gboolean // in

_arg0 = (*C.GtkClipboard)(unsafe.Pointer(c.Native()))

_cret = C.gtk_clipboard_wait_is_text_available(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// WaitIsUrisAvailable: test to see if there is a list of URIs available to be
// pasted This is done by requesting the TARGETS atom and checking if it
// contains the URI targets. This function waits for the data to be received
// using the main loop, so events, timeouts, etc, may be dispatched during the
// wait.
// 
// This function is a little faster than calling gtk_clipboard_wait_for_uris()
// since it doesn’t need to retrieve the actual URI data.
	func (c Clipboard) WaitIsUrisAvailable() bool {
var _arg0 *C.GtkClipboard // out
var _cret C.gboolean // in

_arg0 = (*C.GtkClipboard)(unsafe.Pointer(c.Native()))

_cret = C.gtk_clipboard_wait_is_uris_available(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	


	// ColorButton: the ColorButton is a button which displays the currently
// selected color and allows to open a color selection dialog to change the
// color. It is suitable widget for selecting a color in a preference dialog.
// 
// 
// CSS nodes
// 
// GtkColorButton has a single CSS node with name button. To differentiate it
// from a plain Button, it gets the .color style class.
	type ColorButton struct {
		Button
		Actionable
		Activatable
		Buildable
		ColorChooser
		
	}

	// ColorButtonClass is an interface that the ColorButton class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ColorButtonClass interface {
		gextras.Objector
		_colorButton()
	}

	func (ColorButton) _colorButton() {}

	
	func marshalColorButton(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapColorButton(obj), nil
	}
	

	
	// NewColorButton creates a new color button.
// 
// This returns a widget in the form of a small button containing a swatch
// representing the current selected color. When the button is clicked, a
// color-selection dialog will open, allowing the user to select a color. The
// swatch will be updated to reflect the new color when the user finishes.
	func NewColorButton() ColorButton {
var _cret *C.GtkWidget // in

_cret = C.gtk_color_button_new()


var _colorButton ColorButton // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_colorButton = ColorButton{
Button: Button{
Bin: Bin{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ColorChooser: ColorChooser{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _colorButton
}
	
	// NewColorButtonWithColor creates a new color button.
	func NewColorButtonWithColor(color *gdk.Color) ColorButton {
var _arg1 *C.GdkColor // out
var _cret *C.GtkWidget // in

_arg1 = (*C.GdkColor)(unsafe.Pointer(color.Native()))

_cret = C.gtk_color_button_new_with_color(_arg1)


var _colorButton ColorButton // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_colorButton = ColorButton{
Button: Button{
Bin: Bin{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ColorChooser: ColorChooser{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _colorButton
}
	
	// NewColorButtonWithRGBA creates a new color button.
	func NewColorButtonWithRGBA(rgba *gdk.RGBA) ColorButton {
var _arg1 *C.GdkRGBA // out
var _cret *C.GtkWidget // in

_arg1 = (*C.GdkRGBA)(unsafe.Pointer(rgba.Native()))

_cret = C.gtk_color_button_new_with_rgba(_arg1)


var _colorButton ColorButton // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_colorButton = ColorButton{
Button: Button{
Bin: Bin{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ColorChooser: ColorChooser{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _colorButton
}
	

	
	// Alpha returns the current alpha value.
	func (b ColorButton) Alpha() uint16 {
var _arg0 *C.GtkColorButton // out
var _cret C.guint16 // in

_arg0 = (*C.GtkColorButton)(unsafe.Pointer(b.Native()))

_cret = C.gtk_color_button_get_alpha(_arg0)


var _guint16 uint16 // out

_guint16 = (uint16)(_cret)

return _guint16
}
	
	// Color sets @color to be the current color in the ColorButton widget.
	func (b ColorButton) Color() gdk.Color {
var _arg0 *C.GtkColorButton // out
var _color gdk.Color

_arg0 = (*C.GtkColorButton)(unsafe.Pointer(b.Native()))

C.gtk_color_button_get_color(_arg0, (*C.GdkColor)(unsafe.Pointer(&_color)))





return _color
}
	
	// Title gets the title of the color selection dialog.
	func (b ColorButton) Title() string {
var _arg0 *C.GtkColorButton // out
var _cret *C.gchar // in

_arg0 = (*C.GtkColorButton)(unsafe.Pointer(b.Native()))

_cret = C.gtk_color_button_get_title(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// UseAlpha does the color selection dialog use the alpha channel ?
	func (b ColorButton) UseAlpha() bool {
var _arg0 *C.GtkColorButton // out
var _cret C.gboolean // in

_arg0 = (*C.GtkColorButton)(unsafe.Pointer(b.Native()))

_cret = C.gtk_color_button_get_use_alpha(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetAlpha sets the current opacity to be @alpha.
	func (b ColorButton) SetAlpha(alpha uint16)  {
var _arg0 *C.GtkColorButton // out
var _arg1 C.guint16 // out

_arg0 = (*C.GtkColorButton)(unsafe.Pointer(b.Native()))
_arg1 = (C.guint16)(alpha)

C.gtk_color_button_set_alpha(_arg0, _arg1)
}
	
	// SetColor sets the current color to be @color.
	func (b ColorButton) SetColor(color *gdk.Color)  {
var _arg0 *C.GtkColorButton // out
var _arg1 *C.GdkColor // out

_arg0 = (*C.GtkColorButton)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GdkColor)(unsafe.Pointer(color.Native()))

C.gtk_color_button_set_color(_arg0, _arg1)
}
	
	// SetTitle sets the title for the color selection dialog.
	func (b ColorButton) SetTitle(title string)  {
var _arg0 *C.GtkColorButton // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkColorButton)(unsafe.Pointer(b.Native()))
_arg1 = (*C.gchar)(C.CString(title))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_color_button_set_title(_arg0, _arg1)
}
	
	// SetUseAlpha sets whether or not the color button should use the alpha
// channel.
	func (b ColorButton) SetUseAlpha(useAlpha bool)  {
var _arg0 *C.GtkColorButton // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkColorButton)(unsafe.Pointer(b.Native()))
if useAlpha { _arg1 = C.TRUE }

C.gtk_color_button_set_use_alpha(_arg0, _arg1)
}
	


	// ColorChooserDialog: the ColorChooserDialog widget is a dialog for choosing a
// color. It implements the ColorChooser interface.
	type ColorChooserDialog struct {
		Dialog
		Buildable
		ColorChooser
		
	}

	// ColorChooserDialogClass is an interface that the ColorChooserDialog class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ColorChooserDialogClass interface {
		gextras.Objector
		_colorChooserDialog()
	}

	func (ColorChooserDialog) _colorChooserDialog() {}

	
	func marshalColorChooserDialog(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapColorChooserDialog(obj), nil
	}
	

	
	// NewColorChooserDialog creates a new ColorChooserDialog.
	func NewColorChooserDialog(title string, parent WindowClass) ColorChooserDialog {
var _arg1 *C.gchar // out
var _arg2 *C.GtkWindow // out
var _cret *C.GtkWidget // in

_arg1 = (*C.gchar)(C.CString(title))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.GtkWindow)(unsafe.Pointer(parent.Native()))

_cret = C.gtk_color_chooser_dialog_new(_arg1, _arg2)


var _colorChooserDialog ColorChooserDialog // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_colorChooserDialog = ColorChooserDialog{
Dialog: Dialog{
Window: Window{
Bin: Bin{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ColorChooser: ColorChooser{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _colorChooserDialog
}
	

	


	// ColorChooserWidget: the ColorChooserWidget widget lets the user select a
// color. By default, the chooser presents a predefined palette of colors, plus
// a small number of settable custom colors. It is also possible to select a
// different color with the single-color editor. To enter the single-color
// editing mode, use the context menu of any color of the palette, or use the
// '+' button to add a new custom color.
// 
// The chooser automatically remembers the last selection, as well as custom
// colors.
// 
// To change the initially selected color, use gtk_color_chooser_set_rgba(). To
// get the selected color use gtk_color_chooser_get_rgba().
// 
// The ColorChooserWidget is used in the ColorChooserDialog to provide a dialog
// for selecting colors.
// 
// 
// CSS names
// 
// GtkColorChooserWidget has a single CSS node with name colorchooser.
	type ColorChooserWidget struct {
		Box
		Buildable
		ColorChooser
		Orientable
		
	}

	// ColorChooserWidgetClass is an interface that the ColorChooserWidget class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ColorChooserWidgetClass interface {
		gextras.Objector
		_colorChooserWidget()
	}

	func (ColorChooserWidget) _colorChooserWidget() {}

	
	func marshalColorChooserWidget(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapColorChooserWidget(obj), nil
	}
	

	
	// NewColorChooserWidget creates a new ColorChooserWidget.
	func NewColorChooserWidget() ColorChooserWidget {
var _cret *C.GtkWidget // in

_cret = C.gtk_color_chooser_widget_new()


var _colorChooserWidget ColorChooserWidget // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_colorChooserWidget = ColorChooserWidget{
Box: Box{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ColorChooser: ColorChooser{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _colorChooserWidget
}
	

	


	
	type ColorSelection struct {
		Box
		Buildable
		Orientable
		
	}

	// ColorSelectionClass is an interface that the ColorSelection class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ColorSelectionClass interface {
		gextras.Objector
		_colorSelection()
	}

	func (ColorSelection) _colorSelection() {}

	
	func marshalColorSelection(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapColorSelection(obj), nil
	}
	

	
	// NewColorSelection creates a new GtkColorSelection.
	func NewColorSelection() ColorSelection {
var _cret *C.GtkWidget // in

_cret = C.gtk_color_selection_new()


var _colorSelection ColorSelection // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_colorSelection = ColorSelection{
Box: Box{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _colorSelection
}
	

	
	// CurrentAlpha returns the current alpha value.
	func (c ColorSelection) CurrentAlpha() uint16 {
var _arg0 *C.GtkColorSelection // out
var _cret C.guint16 // in

_arg0 = (*C.GtkColorSelection)(unsafe.Pointer(c.Native()))

_cret = C.gtk_color_selection_get_current_alpha(_arg0)


var _guint16 uint16 // out

_guint16 = (uint16)(_cret)

return _guint16
}
	
	// CurrentColor sets @color to be the current color in the GtkColorSelection
// widget.
	func (c ColorSelection) CurrentColor() gdk.Color {
var _arg0 *C.GtkColorSelection // out
var _color gdk.Color

_arg0 = (*C.GtkColorSelection)(unsafe.Pointer(c.Native()))

C.gtk_color_selection_get_current_color(_arg0, (*C.GdkColor)(unsafe.Pointer(&_color)))





return _color
}
	
	// CurrentRGBA sets @rgba to be the current color in the GtkColorSelection
// widget.
	func (c ColorSelection) CurrentRGBA() gdk.RGBA {
var _arg0 *C.GtkColorSelection // out
var _rgba gdk.RGBA

_arg0 = (*C.GtkColorSelection)(unsafe.Pointer(c.Native()))

C.gtk_color_selection_get_current_rgba(_arg0, (*C.GdkRGBA)(unsafe.Pointer(&_rgba)))





return _rgba
}
	
	// HasOpacityControl determines whether the colorsel has an opacity control.
	func (c ColorSelection) HasOpacityControl() bool {
var _arg0 *C.GtkColorSelection // out
var _cret C.gboolean // in

_arg0 = (*C.GtkColorSelection)(unsafe.Pointer(c.Native()))

_cret = C.gtk_color_selection_get_has_opacity_control(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// HasPalette determines whether the color selector has a color palette.
	func (c ColorSelection) HasPalette() bool {
var _arg0 *C.GtkColorSelection // out
var _cret C.gboolean // in

_arg0 = (*C.GtkColorSelection)(unsafe.Pointer(c.Native()))

_cret = C.gtk_color_selection_get_has_palette(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// PreviousAlpha returns the previous alpha value.
	func (c ColorSelection) PreviousAlpha() uint16 {
var _arg0 *C.GtkColorSelection // out
var _cret C.guint16 // in

_arg0 = (*C.GtkColorSelection)(unsafe.Pointer(c.Native()))

_cret = C.gtk_color_selection_get_previous_alpha(_arg0)


var _guint16 uint16 // out

_guint16 = (uint16)(_cret)

return _guint16
}
	
	// PreviousColor fills @color in with the original color value.
	func (c ColorSelection) PreviousColor() gdk.Color {
var _arg0 *C.GtkColorSelection // out
var _color gdk.Color

_arg0 = (*C.GtkColorSelection)(unsafe.Pointer(c.Native()))

C.gtk_color_selection_get_previous_color(_arg0, (*C.GdkColor)(unsafe.Pointer(&_color)))





return _color
}
	
	// PreviousRGBA fills @rgba in with the original color value.
	func (c ColorSelection) PreviousRGBA() gdk.RGBA {
var _arg0 *C.GtkColorSelection // out
var _rgba gdk.RGBA

_arg0 = (*C.GtkColorSelection)(unsafe.Pointer(c.Native()))

C.gtk_color_selection_get_previous_rgba(_arg0, (*C.GdkRGBA)(unsafe.Pointer(&_rgba)))





return _rgba
}
	
	// IsAdjusting gets the current state of the @colorsel.
	func (c ColorSelection) IsAdjusting() bool {
var _arg0 *C.GtkColorSelection // out
var _cret C.gboolean // in

_arg0 = (*C.GtkColorSelection)(unsafe.Pointer(c.Native()))

_cret = C.gtk_color_selection_is_adjusting(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetCurrentAlpha sets the current opacity to be @alpha.
// 
// The first time this is called, it will also set the original opacity to be
// @alpha too.
	func (c ColorSelection) SetCurrentAlpha(alpha uint16)  {
var _arg0 *C.GtkColorSelection // out
var _arg1 C.guint16 // out

_arg0 = (*C.GtkColorSelection)(unsafe.Pointer(c.Native()))
_arg1 = (C.guint16)(alpha)

C.gtk_color_selection_set_current_alpha(_arg0, _arg1)
}
	
	// SetCurrentColor sets the current color to be @color.
// 
// The first time this is called, it will also set the original color to be
// @color too.
	func (c ColorSelection) SetCurrentColor(color *gdk.Color)  {
var _arg0 *C.GtkColorSelection // out
var _arg1 *C.GdkColor // out

_arg0 = (*C.GtkColorSelection)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GdkColor)(unsafe.Pointer(color.Native()))

C.gtk_color_selection_set_current_color(_arg0, _arg1)
}
	
	// SetCurrentRGBA sets the current color to be @rgba.
// 
// The first time this is called, it will also set the original color to be
// @rgba too.
	func (c ColorSelection) SetCurrentRGBA(rgba *gdk.RGBA)  {
var _arg0 *C.GtkColorSelection // out
var _arg1 *C.GdkRGBA // out

_arg0 = (*C.GtkColorSelection)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GdkRGBA)(unsafe.Pointer(rgba.Native()))

C.gtk_color_selection_set_current_rgba(_arg0, _arg1)
}
	
	// SetHasOpacityControl sets the @colorsel to use or not use opacity.
	func (c ColorSelection) SetHasOpacityControl(hasOpacity bool)  {
var _arg0 *C.GtkColorSelection // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkColorSelection)(unsafe.Pointer(c.Native()))
if hasOpacity { _arg1 = C.TRUE }

C.gtk_color_selection_set_has_opacity_control(_arg0, _arg1)
}
	
	// SetHasPalette shows and hides the palette based upon the value of
// @has_palette.
	func (c ColorSelection) SetHasPalette(hasPalette bool)  {
var _arg0 *C.GtkColorSelection // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkColorSelection)(unsafe.Pointer(c.Native()))
if hasPalette { _arg1 = C.TRUE }

C.gtk_color_selection_set_has_palette(_arg0, _arg1)
}
	
	// SetPreviousAlpha sets the “previous” alpha to be @alpha.
// 
// This function should be called with some hesitations, as it might seem
// confusing to have that alpha change.
	func (c ColorSelection) SetPreviousAlpha(alpha uint16)  {
var _arg0 *C.GtkColorSelection // out
var _arg1 C.guint16 // out

_arg0 = (*C.GtkColorSelection)(unsafe.Pointer(c.Native()))
_arg1 = (C.guint16)(alpha)

C.gtk_color_selection_set_previous_alpha(_arg0, _arg1)
}
	
	// SetPreviousColor sets the “previous” color to be @color.
// 
// This function should be called with some hesitations, as it might seem
// confusing to have that color change. Calling
// gtk_color_selection_set_current_color() will also set this color the first
// time it is called.
	func (c ColorSelection) SetPreviousColor(color *gdk.Color)  {
var _arg0 *C.GtkColorSelection // out
var _arg1 *C.GdkColor // out

_arg0 = (*C.GtkColorSelection)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GdkColor)(unsafe.Pointer(color.Native()))

C.gtk_color_selection_set_previous_color(_arg0, _arg1)
}
	
	// SetPreviousRGBA sets the “previous” color to be @rgba.
// 
// This function should be called with some hesitations, as it might seem
// confusing to have that color change. Calling
// gtk_color_selection_set_current_rgba() will also set this color the first
// time it is called.
	func (c ColorSelection) SetPreviousRGBA(rgba *gdk.RGBA)  {
var _arg0 *C.GtkColorSelection // out
var _arg1 *C.GdkRGBA // out

_arg0 = (*C.GtkColorSelection)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GdkRGBA)(unsafe.Pointer(rgba.Native()))

C.gtk_color_selection_set_previous_rgba(_arg0, _arg1)
}
	


	
	type ColorSelectionDialog struct {
		Dialog
		Buildable
		
	}

	// ColorSelectionDialogClass is an interface that the ColorSelectionDialog class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ColorSelectionDialogClass interface {
		gextras.Objector
		_colorSelectionDialog()
	}

	func (ColorSelectionDialog) _colorSelectionDialog() {}

	
	func marshalColorSelectionDialog(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapColorSelectionDialog(obj), nil
	}
	

	
	// NewColorSelectionDialog creates a new ColorSelectionDialog.
	func NewColorSelectionDialog(title string) ColorSelectionDialog {
var _arg1 *C.gchar // out
var _cret *C.GtkWidget // in

_arg1 = (*C.gchar)(C.CString(title))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_color_selection_dialog_new(_arg1)


var _colorSelectionDialog ColorSelectionDialog // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_colorSelectionDialog = ColorSelectionDialog{
Dialog: Dialog{
Window: Window{
Bin: Bin{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _colorSelectionDialog
}
	

	
	// ColorSelection retrieves the ColorSelection widget embedded in the dialog.
	func (c ColorSelectionDialog) ColorSelection() Widget {
var _arg0 *C.GtkColorSelectionDialog // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkColorSelectionDialog)(unsafe.Pointer(c.Native()))

_cret = C.gtk_color_selection_dialog_get_color_selection(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	


	// ComboBox: a GtkComboBox is a widget that allows the user to choose from a
// list of valid choices. The GtkComboBox displays the selected choice. When
// activated, the GtkComboBox displays a popup which allows the user to make a
// new choice. The style in which the selected value is displayed, and the style
// of the popup is determined by the current theme. It may be similar to a
// Windows-style combo box.
// 
// The GtkComboBox uses the model-view pattern; the list of valid choices is
// specified in the form of a tree model, and the display of the choices can be
// adapted to the data in the model by using cell renderers, as you would in a
// tree view. This is possible since GtkComboBox implements the CellLayout
// interface. The tree model holding the valid choices is not restricted to a
// flat list, it can be a real tree, and the popup will reflect the tree
// structure.
// 
// To allow the user to enter values not in the model, the “has-entry” property
// allows the GtkComboBox to contain a Entry. This entry can be accessed by
// calling gtk_bin_get_child() on the combo box.
// 
// For a simple list of textual choices, the model-view API of GtkComboBox can
// be a bit overwhelming. In this case, ComboBoxText offers a simple
// alternative. Both GtkComboBox and ComboBoxText can contain an entry.
// 
// CSS nodes
// 
//    combobox
//    ├── box.linked
//    │   ├── entry.combo
//    │   ╰── button.combo
//    │       ╰── box
//    │           ╰── arrow
//    ╰── window.popup
// 
// A GtkComboBox with an entry has a single CSS node with name combobox. It
// contains a box with the .linked class. That box contains an entry and a
// button, both with the .combo class added. The button also contains another
// node with name arrow.
	type ComboBox struct {
		Bin
		Buildable
		CellEditable
		CellLayout
		
	}

	// ComboBoxClass is an interface that the ComboBox class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ComboBoxClass interface {
		gextras.Objector
		_comboBox()
	}

	func (ComboBox) _comboBox() {}

	
	func marshalComboBox(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapComboBox(obj), nil
	}
	

	
	// NewComboBox creates a new empty ComboBox.
	func NewComboBox() ComboBox {
var _cret *C.GtkWidget // in

_cret = C.gtk_combo_box_new()


var _comboBox ComboBox // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_comboBox = ComboBox{
Bin: Bin{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
CellEditable: CellEditable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
CellLayout: CellLayout{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _comboBox
}
	
	// NewComboBoxWithArea creates a new empty ComboBox using @area to layout cells.
	func NewComboBoxWithArea(area CellAreaClass) ComboBox {
var _arg1 *C.GtkCellArea // out
var _cret *C.GtkWidget // in

_arg1 = (*C.GtkCellArea)(unsafe.Pointer(area.Native()))

_cret = C.gtk_combo_box_new_with_area(_arg1)


var _comboBox ComboBox // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_comboBox = ComboBox{
Bin: Bin{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
CellEditable: CellEditable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
CellLayout: CellLayout{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _comboBox
}
	
	// NewComboBoxWithAreaAndEntry creates a new empty ComboBox with an entry.
// 
// The new combo box will use @area to layout cells.
	func NewComboBoxWithAreaAndEntry(area CellAreaClass) ComboBox {
var _arg1 *C.GtkCellArea // out
var _cret *C.GtkWidget // in

_arg1 = (*C.GtkCellArea)(unsafe.Pointer(area.Native()))

_cret = C.gtk_combo_box_new_with_area_and_entry(_arg1)


var _comboBox ComboBox // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_comboBox = ComboBox{
Bin: Bin{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
CellEditable: CellEditable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
CellLayout: CellLayout{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _comboBox
}
	
	// NewComboBoxWithEntry creates a new empty ComboBox with an entry.
	func NewComboBoxWithEntry() ComboBox {
var _cret *C.GtkWidget // in

_cret = C.gtk_combo_box_new_with_entry()


var _comboBox ComboBox // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_comboBox = ComboBox{
Bin: Bin{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
CellEditable: CellEditable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
CellLayout: CellLayout{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _comboBox
}
	
	// NewComboBoxWithModel creates a new ComboBox with the model initialized to
// @model.
	func NewComboBoxWithModel(model TreeModel) ComboBox {
var _arg1 *C.GtkTreeModel // out
var _cret *C.GtkWidget // in

_arg1 = (*C.GtkTreeModel)(unsafe.Pointer(model.Native()))

_cret = C.gtk_combo_box_new_with_model(_arg1)


var _comboBox ComboBox // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_comboBox = ComboBox{
Bin: Bin{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
CellEditable: CellEditable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
CellLayout: CellLayout{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _comboBox
}
	
	// NewComboBoxWithModelAndEntry creates a new empty ComboBox with an entry and
// with the model initialized to @model.
	func NewComboBoxWithModelAndEntry(model TreeModel) ComboBox {
var _arg1 *C.GtkTreeModel // out
var _cret *C.GtkWidget // in

_arg1 = (*C.GtkTreeModel)(unsafe.Pointer(model.Native()))

_cret = C.gtk_combo_box_new_with_model_and_entry(_arg1)


var _comboBox ComboBox // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_comboBox = ComboBox{
Bin: Bin{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
CellEditable: CellEditable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
CellLayout: CellLayout{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _comboBox
}
	

	
	// Active returns the index of the currently active item, or -1 if there’s no
// active item. If the model is a non-flat treemodel, and the active item is not
// an immediate child of the root of the tree, this function returns
// `gtk_tree_path_get_indices (path)[0]`, where `path` is the TreePath of the
// active item.
	func (c ComboBox) Active() int {
var _arg0 *C.GtkComboBox // out
var _cret C.gint // in

_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))

_cret = C.gtk_combo_box_get_active(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// ActiveID returns the ID of the active row of @combo_box. This value is taken
// from the active row and the column specified by the ComboBox:id-column
// property of @combo_box (see gtk_combo_box_set_id_column()).
// 
// The returned value is an interned string which means that you can compare the
// pointer by value to other interned strings and that you must not free it.
// 
// If the ComboBox:id-column property of @combo_box is not set, or if no row is
// active, or if the active row has a nil ID value, then nil is returned.
	func (c ComboBox) ActiveID() string {
var _arg0 *C.GtkComboBox // out
var _cret *C.gchar // in

_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))

_cret = C.gtk_combo_box_get_active_id(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// ActiveIter sets @iter to point to the currently active item, if any item is
// active. Otherwise, @iter is left unchanged.
	func (c ComboBox) ActiveIter() (TreeIter, bool) {
var _arg0 *C.GtkComboBox // out
var _iter TreeIter
var _cret C.gboolean // in

_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))

_cret = C.gtk_combo_box_get_active_iter(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_iter)))



var _ok bool // out


if _cret != 0 { _ok = true }

return _iter, _ok
}
	
	// AddTearoffs gets the current value of the :add-tearoffs property.
	func (c ComboBox) AddTearoffs() bool {
var _arg0 *C.GtkComboBox // out
var _cret C.gboolean // in

_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))

_cret = C.gtk_combo_box_get_add_tearoffs(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ButtonSensitivity returns whether the combo box sets the dropdown button
// sensitive or not when there are no items in the model.
	func (c ComboBox) ButtonSensitivity() SensitivityType {
var _arg0 *C.GtkComboBox // out
var _cret C.GtkSensitivityType // in

_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))

_cret = C.gtk_combo_box_get_button_sensitivity(_arg0)


var _sensitivityType SensitivityType // out

_sensitivityType = SensitivityType(_cret)

return _sensitivityType
}
	
	// ColumnSpanColumn returns the column with column span information for
// @combo_box.
	func (c ComboBox) ColumnSpanColumn() int {
var _arg0 *C.GtkComboBox // out
var _cret C.gint // in

_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))

_cret = C.gtk_combo_box_get_column_span_column(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// EntryTextColumn returns the column which @combo_box is using to get the
// strings from to display in the internal entry.
	func (c ComboBox) EntryTextColumn() int {
var _arg0 *C.GtkComboBox // out
var _cret C.gint // in

_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))

_cret = C.gtk_combo_box_get_entry_text_column(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// FocusOnClick returns whether the combo box grabs focus when it is clicked
// with the mouse. See gtk_combo_box_set_focus_on_click().
	func (c ComboBox) FocusOnClick() bool {
var _arg0 *C.GtkComboBox // out
var _cret C.gboolean // in

_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))

_cret = C.gtk_combo_box_get_focus_on_click(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// HasEntry returns whether the combo box has an entry.
	func (c ComboBox) HasEntry() bool {
var _arg0 *C.GtkComboBox // out
var _cret C.gboolean // in

_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))

_cret = C.gtk_combo_box_get_has_entry(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IDColumn returns the column which @combo_box is using to get string IDs for
// values from.
	func (c ComboBox) IDColumn() int {
var _arg0 *C.GtkComboBox // out
var _cret C.gint // in

_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))

_cret = C.gtk_combo_box_get_id_column(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Model returns the TreeModel which is acting as data source for @combo_box.
	func (c ComboBox) Model() TreeModel {
var _arg0 *C.GtkComboBox // out
var _cret *C.GtkTreeModel // in

_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))

_cret = C.gtk_combo_box_get_model(_arg0)


var _treeModel TreeModel // out

_treeModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TreeModel)

return _treeModel
}
	
	// PopupFixedWidth gets whether the popup uses a fixed width matching the
// allocated width of the combo box.
	func (c ComboBox) PopupFixedWidth() bool {
var _arg0 *C.GtkComboBox // out
var _cret C.gboolean // in

_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))

_cret = C.gtk_combo_box_get_popup_fixed_width(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// RowSpanColumn returns the column with row span information for @combo_box.
	func (c ComboBox) RowSpanColumn() int {
var _arg0 *C.GtkComboBox // out
var _cret C.gint // in

_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))

_cret = C.gtk_combo_box_get_row_span_column(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Title gets the current title of the menu in tearoff mode. See
// gtk_combo_box_set_add_tearoffs().
	func (c ComboBox) Title() string {
var _arg0 *C.GtkComboBox // out
var _cret *C.gchar // in

_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))

_cret = C.gtk_combo_box_get_title(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// WrapWidth returns the wrap width which is used to determine the number of
// columns for the popup menu. If the wrap width is larger than 1, the combo box
// is in table mode.
	func (c ComboBox) WrapWidth() int {
var _arg0 *C.GtkComboBox // out
var _cret C.gint // in

_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))

_cret = C.gtk_combo_box_get_wrap_width(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Popdown hides the menu or dropdown list of @combo_box.
// 
// This function is mostly intended for use by accessibility technologies;
// applications should have little use for it.
	func (c ComboBox) Popdown()  {
var _arg0 *C.GtkComboBox // out

_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))

C.gtk_combo_box_popdown(_arg0)
}
	
	// Popup pops up the menu or dropdown list of @combo_box.
// 
// This function is mostly intended for use by accessibility technologies;
// applications should have little use for it.
// 
// Before calling this, @combo_box must be mapped, or nothing will happen.
	func (c ComboBox) Popup()  {
var _arg0 *C.GtkComboBox // out

_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))

C.gtk_combo_box_popup(_arg0)
}
	
	// PopupForDevice pops up the menu or dropdown list of @combo_box, the popup
// window will be grabbed so only @device and its associated pointer/keyboard
// are the only Devices able to send events to it.
	func (c ComboBox) PopupForDevice(device gdk.DeviceClass)  {
var _arg0 *C.GtkComboBox // out
var _arg1 *C.GdkDevice // out

_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GdkDevice)(unsafe.Pointer(device.Native()))

C.gtk_combo_box_popup_for_device(_arg0, _arg1)
}
	
	// SetActive sets the active item of @combo_box to be the item at @index.
	func (c ComboBox) SetActive(index_ int)  {
var _arg0 *C.GtkComboBox // out
var _arg1 C.gint // out

_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))
_arg1 = (C.gint)(index_)

C.gtk_combo_box_set_active(_arg0, _arg1)
}
	
	// SetActiveID changes the active row of @combo_box to the one that has an ID
// equal to @active_id, or unsets the active row if @active_id is nil. Rows
// having a nil ID string cannot be made active by this function.
// 
// If the ComboBox:id-column property of @combo_box is unset or if no row has
// the given ID then the function does nothing and returns false.
	func (c ComboBox) SetActiveID(activeId string) bool {
var _arg0 *C.GtkComboBox // out
var _arg1 *C.gchar // out
var _cret C.gboolean // in

_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))
_arg1 = (*C.gchar)(C.CString(activeId))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_combo_box_set_active_id(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetActiveIter sets the current active item to be the one referenced by @iter,
// or unsets the active item if @iter is nil.
	func (c ComboBox) SetActiveIter(iter *TreeIter)  {
var _arg0 *C.GtkComboBox // out
var _arg1 *C.GtkTreeIter // out

_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

C.gtk_combo_box_set_active_iter(_arg0, _arg1)
}
	
	// SetAddTearoffs sets whether the popup menu should have a tearoff menu item.
	func (c ComboBox) SetAddTearoffs(addTearoffs bool)  {
var _arg0 *C.GtkComboBox // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))
if addTearoffs { _arg1 = C.TRUE }

C.gtk_combo_box_set_add_tearoffs(_arg0, _arg1)
}
	
	// SetButtonSensitivity sets whether the dropdown button of the combo box should
// be always sensitive (GTK_SENSITIVITY_ON), never sensitive
// (GTK_SENSITIVITY_OFF) or only if there is at least one item to display
// (GTK_SENSITIVITY_AUTO).
	func (c ComboBox) SetButtonSensitivity(sensitivity SensitivityType)  {
var _arg0 *C.GtkComboBox // out
var _arg1 C.GtkSensitivityType // out

_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))
_arg1 = (C.GtkSensitivityType)(sensitivity)

C.gtk_combo_box_set_button_sensitivity(_arg0, _arg1)
}
	
	// SetColumnSpanColumn sets the column with column span information for
// @combo_box to be @column_span. The column span column contains integers which
// indicate how many columns an item should span.
	func (c ComboBox) SetColumnSpanColumn(columnSpan int)  {
var _arg0 *C.GtkComboBox // out
var _arg1 C.gint // out

_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))
_arg1 = (C.gint)(columnSpan)

C.gtk_combo_box_set_column_span_column(_arg0, _arg1)
}
	
	// SetEntryTextColumn sets the model column which @combo_box should use to get
// strings from to be @text_column. The column @text_column in the model of
// @combo_box must be of type G_TYPE_STRING.
// 
// This is only relevant if @combo_box has been created with ComboBox:has-entry
// as true.
	func (c ComboBox) SetEntryTextColumn(textColumn int)  {
var _arg0 *C.GtkComboBox // out
var _arg1 C.gint // out

_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))
_arg1 = (C.gint)(textColumn)

C.gtk_combo_box_set_entry_text_column(_arg0, _arg1)
}
	
	// SetFocusOnClick sets whether the combo box will grab focus when it is clicked
// with the mouse. Making mouse clicks not grab focus is useful in places like
// toolbars where you don’t want the keyboard focus removed from the main area
// of the application.
	func (c ComboBox) SetFocusOnClick(focusOnClick bool)  {
var _arg0 *C.GtkComboBox // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))
if focusOnClick { _arg1 = C.TRUE }

C.gtk_combo_box_set_focus_on_click(_arg0, _arg1)
}
	
	// SetIDColumn sets the model column which @combo_box should use to get string
// IDs for values from. The column @id_column in the model of @combo_box must be
// of type G_TYPE_STRING.
	func (c ComboBox) SetIDColumn(idColumn int)  {
var _arg0 *C.GtkComboBox // out
var _arg1 C.gint // out

_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))
_arg1 = (C.gint)(idColumn)

C.gtk_combo_box_set_id_column(_arg0, _arg1)
}
	
	// SetModel sets the model used by @combo_box to be @model. Will unset a
// previously set model (if applicable). If model is nil, then it will unset the
// model.
// 
// Note that this function does not clear the cell renderers, you have to call
// gtk_cell_layout_clear() yourself if you need to set up different cell
// renderers for the new model.
	func (c ComboBox) SetModel(model TreeModel)  {
var _arg0 *C.GtkComboBox // out
var _arg1 *C.GtkTreeModel // out

_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GtkTreeModel)(unsafe.Pointer(model.Native()))

C.gtk_combo_box_set_model(_arg0, _arg1)
}
	
	// SetPopupFixedWidth specifies whether the popup’s width should be a fixed
// width matching the allocated width of the combo box.
	func (c ComboBox) SetPopupFixedWidth(fixed bool)  {
var _arg0 *C.GtkComboBox // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))
if fixed { _arg1 = C.TRUE }

C.gtk_combo_box_set_popup_fixed_width(_arg0, _arg1)
}
	
	// SetRowSpanColumn sets the column with row span information for @combo_box to
// be @row_span. The row span column contains integers which indicate how many
// rows an item should span.
	func (c ComboBox) SetRowSpanColumn(rowSpan int)  {
var _arg0 *C.GtkComboBox // out
var _arg1 C.gint // out

_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))
_arg1 = (C.gint)(rowSpan)

C.gtk_combo_box_set_row_span_column(_arg0, _arg1)
}
	
	// SetTitle sets the menu’s title in tearoff mode.
	func (c ComboBox) SetTitle(title string)  {
var _arg0 *C.GtkComboBox // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))
_arg1 = (*C.gchar)(C.CString(title))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_combo_box_set_title(_arg0, _arg1)
}
	
	// SetWrapWidth sets the wrap width of @combo_box to be @width. The wrap width
// is basically the preferred number of columns when you want the popup to be
// layed out in a table.
	func (c ComboBox) SetWrapWidth(width int)  {
var _arg0 *C.GtkComboBox // out
var _arg1 C.gint // out

_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))
_arg1 = (C.gint)(width)

C.gtk_combo_box_set_wrap_width(_arg0, _arg1)
}
	


	// ComboBoxText: a GtkComboBoxText is a simple variant of ComboBox that hides
// the model-view complexity for simple text-only use cases.
// 
// To create a GtkComboBoxText, use gtk_combo_box_text_new() or
// gtk_combo_box_text_new_with_entry().
// 
// You can add items to a GtkComboBoxText with gtk_combo_box_text_append_text(),
// gtk_combo_box_text_insert_text() or gtk_combo_box_text_prepend_text() and
// remove options with gtk_combo_box_text_remove().
// 
// If the GtkComboBoxText contains an entry (via the “has-entry” property), its
// contents can be retrieved using gtk_combo_box_text_get_active_text(). The
// entry itself can be accessed by calling gtk_bin_get_child() on the combo box.
// 
// You should not call gtk_combo_box_set_model() or attempt to pack more cells
// into this combo box via its GtkCellLayout interface.
// 
// 
// GtkComboBoxText as GtkBuildable
// 
// The GtkComboBoxText implementation of the GtkBuildable interface supports
// adding items directly using the <items> element and specifying <item>
// elements for each item. Each <item> element can specify the “id”
// corresponding to the appended text and also supports the regular translation
// attributes “translatable”, “context” and “comments”.
// 
// Here is a UI definition fragment specifying GtkComboBoxText items:
// 
//    <object class="GtkComboBoxText">
//      <items>
//        <item translatable="yes" id="factory">Factory</item>
//        <item translatable="yes" id="home">Home</item>
//        <item translatable="yes" id="subway">Subway</item>
//      </items>
//    </object>
// 
// CSS nodes
// 
//    combobox
//    ╰── box.linked
//        ├── entry.combo
//        ├── button.combo
//        ╰── window.popup
// 
// GtkComboBoxText has a single CSS node with name combobox. It adds the style
// class .combo to the main CSS nodes of its entry and button children, and the
// .linked class to the node of its internal box.
	type ComboBoxText struct {
		ComboBox
		Buildable
		CellEditable
		CellLayout
		
	}

	// ComboBoxTextClass is an interface that the ComboBoxText class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ComboBoxTextClass interface {
		gextras.Objector
		_comboBoxText()
	}

	func (ComboBoxText) _comboBoxText() {}

	
	func marshalComboBoxText(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapComboBoxText(obj), nil
	}
	

	
	// NewComboBoxText creates a new ComboBoxText, which is a ComboBox just
// displaying strings.
	func NewComboBoxText() ComboBoxText {
var _cret *C.GtkWidget // in

_cret = C.gtk_combo_box_text_new()


var _comboBoxText ComboBoxText // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_comboBoxText = ComboBoxText{
ComboBox: ComboBox{
Bin: Bin{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
CellEditable: CellEditable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
CellLayout: CellLayout{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
CellEditable: CellEditable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
CellLayout: CellLayout{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _comboBoxText
}
	
	// NewComboBoxTextWithEntry creates a new ComboBoxText, which is a ComboBox just
// displaying strings. The combo box created by this function has an entry.
	func NewComboBoxTextWithEntry() ComboBoxText {
var _cret *C.GtkWidget // in

_cret = C.gtk_combo_box_text_new_with_entry()


var _comboBoxText ComboBoxText // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_comboBoxText = ComboBoxText{
ComboBox: ComboBox{
Bin: Bin{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
CellEditable: CellEditable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
CellLayout: CellLayout{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
CellEditable: CellEditable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
CellLayout: CellLayout{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _comboBoxText
}
	

	
	// Append appends @text to the list of strings stored in @combo_box. If @id is
// non-nil then it is used as the ID of the row.
// 
// This is the same as calling gtk_combo_box_text_insert() with a position of
// -1.
	func (c ComboBoxText) Append(id string, text string)  {
var _arg0 *C.GtkComboBoxText // out
var _arg1 *C.gchar // out
var _arg2 *C.gchar // out

_arg0 = (*C.GtkComboBoxText)(unsafe.Pointer(c.Native()))
_arg1 = (*C.gchar)(C.CString(id))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.gchar)(C.CString(text))
defer C.free(unsafe.Pointer(_arg2))

C.gtk_combo_box_text_append(_arg0, _arg1, _arg2)
}
	
	// AppendText appends @text to the list of strings stored in @combo_box.
// 
// This is the same as calling gtk_combo_box_text_insert_text() with a position
// of -1.
	func (c ComboBoxText) AppendText(text string)  {
var _arg0 *C.GtkComboBoxText // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkComboBoxText)(unsafe.Pointer(c.Native()))
_arg1 = (*C.gchar)(C.CString(text))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_combo_box_text_append_text(_arg0, _arg1)
}
	
	// ActiveText returns the currently active string in @combo_box, or nil if none
// is selected. If @combo_box contains an entry, this function will return its
// contents (which will not necessarily be an item from the list).
	func (c ComboBoxText) ActiveText() string {
var _arg0 *C.GtkComboBoxText // out
var _cret *C.gchar // in

_arg0 = (*C.GtkComboBoxText)(unsafe.Pointer(c.Native()))

_cret = C.gtk_combo_box_text_get_active_text(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// Insert inserts @text at @position in the list of strings stored in
// @combo_box. If @id is non-nil then it is used as the ID of the row. See
// ComboBox:id-column.
// 
// If @position is negative then @text is appended.
	func (c ComboBoxText) Insert(position int, id string, text string)  {
var _arg0 *C.GtkComboBoxText // out
var _arg1 C.gint // out
var _arg2 *C.gchar // out
var _arg3 *C.gchar // out

_arg0 = (*C.GtkComboBoxText)(unsafe.Pointer(c.Native()))
_arg1 = (C.gint)(position)
_arg2 = (*C.gchar)(C.CString(id))
defer C.free(unsafe.Pointer(_arg2))
_arg3 = (*C.gchar)(C.CString(text))
defer C.free(unsafe.Pointer(_arg3))

C.gtk_combo_box_text_insert(_arg0, _arg1, _arg2, _arg3)
}
	
	// InsertText inserts @text at @position in the list of strings stored in
// @combo_box.
// 
// If @position is negative then @text is appended.
// 
// This is the same as calling gtk_combo_box_text_insert() with a nil ID string.
	func (c ComboBoxText) InsertText(position int, text string)  {
var _arg0 *C.GtkComboBoxText // out
var _arg1 C.gint // out
var _arg2 *C.gchar // out

_arg0 = (*C.GtkComboBoxText)(unsafe.Pointer(c.Native()))
_arg1 = (C.gint)(position)
_arg2 = (*C.gchar)(C.CString(text))
defer C.free(unsafe.Pointer(_arg2))

C.gtk_combo_box_text_insert_text(_arg0, _arg1, _arg2)
}
	
	// Prepend prepends @text to the list of strings stored in @combo_box. If @id is
// non-nil then it is used as the ID of the row.
// 
// This is the same as calling gtk_combo_box_text_insert() with a position of 0.
	func (c ComboBoxText) Prepend(id string, text string)  {
var _arg0 *C.GtkComboBoxText // out
var _arg1 *C.gchar // out
var _arg2 *C.gchar // out

_arg0 = (*C.GtkComboBoxText)(unsafe.Pointer(c.Native()))
_arg1 = (*C.gchar)(C.CString(id))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.gchar)(C.CString(text))
defer C.free(unsafe.Pointer(_arg2))

C.gtk_combo_box_text_prepend(_arg0, _arg1, _arg2)
}
	
	// PrependText prepends @text to the list of strings stored in @combo_box.
// 
// This is the same as calling gtk_combo_box_text_insert_text() with a position
// of 0.
	func (c ComboBoxText) PrependText(text string)  {
var _arg0 *C.GtkComboBoxText // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkComboBoxText)(unsafe.Pointer(c.Native()))
_arg1 = (*C.gchar)(C.CString(text))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_combo_box_text_prepend_text(_arg0, _arg1)
}
	
	// Remove removes the string at @position from @combo_box.
	func (c ComboBoxText) Remove(position int)  {
var _arg0 *C.GtkComboBoxText // out
var _arg1 C.gint // out

_arg0 = (*C.GtkComboBoxText)(unsafe.Pointer(c.Native()))
_arg1 = (C.gint)(position)

C.gtk_combo_box_text_remove(_arg0, _arg1)
}
	
	// RemoveAll removes all the text entries from the combo box.
	func (c ComboBoxText) RemoveAll()  {
var _arg0 *C.GtkComboBoxText // out

_arg0 = (*C.GtkComboBoxText)(unsafe.Pointer(c.Native()))

C.gtk_combo_box_text_remove_all(_arg0)
}
	


	// Container: a GTK+ user interface is constructed by nesting widgets inside
// widgets. Container widgets are the inner nodes in the resulting tree of
// widgets: they contain other widgets. So, for example, you might have a Window
// containing a Frame containing a Label. If you wanted an image instead of a
// textual label inside the frame, you might replace the Label widget with a
// Image widget.
// 
// There are two major kinds of container widgets in GTK+. Both are subclasses
// of the abstract GtkContainer base class.
// 
// The first type of container widget has a single child widget and derives from
// Bin. These containers are decorators, which add some kind of functionality to
// the child. For example, a Button makes its child into a clickable button; a
// Frame draws a frame around its child and a Window places its child widget
// inside a top-level window.
// 
// The second type of container can have more than one child; its purpose is to
// manage layout. This means that these containers assign sizes and positions to
// their children. For example, a HBox arranges its children in a horizontal
// row, and a Grid arranges the widgets it contains in a two-dimensional grid.
// 
// For implementations of Container the virtual method ContainerClass.forall()
// is always required, since it's used for drawing and other internal operations
// on the children. If the Container implementation expect to have non internal
// children it's needed to implement both ContainerClass.add() and
// ContainerClass.remove(). If the GtkContainer implementation has internal
// children, they should be added with gtk_widget_set_parent() on init() and
// removed with gtk_widget_unparent() in the WidgetClass.destroy()
// implementation. See more about implementing custom widgets at
// https://wiki.gnome.org/HowDoI/CustomWidgets
// 
// 
// Height for width geometry management
// 
// GTK+ uses a height-for-width (and width-for-height) geometry management
// system. Height-for-width means that a widget can change how much vertical
// space it needs, depending on the amount of horizontal space that it is given
// (and similar for width-for-height).
// 
// There are some things to keep in mind when implementing container widgets
// that make use of GTK+’s height for width geometry management system. First,
// it’s important to note that a container must prioritize one of its
// dimensions, that is to say that a widget or container can only have a
// SizeRequestMode that is GTK_SIZE_REQUEST_HEIGHT_FOR_WIDTH or
// GTK_SIZE_REQUEST_WIDTH_FOR_HEIGHT. However, every widget and container must
// be able to respond to the APIs for both dimensions, i.e. even if a widget has
// a request mode that is height-for-width, it is possible that its parent will
// request its sizes using the width-for-height APIs.
// 
// To ensure that everything works properly, here are some guidelines to follow
// when implementing height-for-width (or width-for-height) containers.
// 
// Each request mode involves 2 virtual methods. Height-for-width apis run
// through gtk_widget_get_preferred_width() and then through
// gtk_widget_get_preferred_height_for_width(). When handling requests in the
// opposite SizeRequestMode it is important that every widget request at least
// enough space to display all of its content at all times.
// 
// When gtk_widget_get_preferred_height() is called on a container that is
// height-for-width, the container must return the height for its minimum width.
// This is easily achieved by simply calling the reverse apis implemented for
// itself as follows:
// 
//    static void
//    foo_container_get_preferred_width_for_height (GtkWidget *widget,
//                                                  gint for_height,
//                                                  gint *min_width,
//                                                  gint *nat_width)
//    {
//       if (i_am_in_height_for_width_mode)
//         {
//           GTK_WIDGET_GET_CLASS (widget)->get_preferred_width (widget,
//                                                               min_width,
//                                                               nat_width);
//         }
//       else
//         {
//           ... execute the real width-for-height request here based on
//           the required width of the children collectively if the
//           container were to be allocated the said height ...
//         }
//    }
// 
// Height for width requests are generally implemented in terms of a virtual
// allocation of widgets in the input orientation. Assuming an height-for-width
// request mode, a container would implement the
// get_preferred_height_for_width() virtual function by first calling
// gtk_widget_get_preferred_width() for each of its children.
// 
// For each potential group of children that are lined up horizontally, the
// values returned by gtk_widget_get_preferred_width() should be collected in an
// array of RequestedSize structures. Any child spacing should be removed from
// the input @for_width and then the collective size should be allocated using
// the gtk_distribute_natural_allocation() convenience function.
// 
// The container will then move on to request the preferred height for each
// child by using gtk_widget_get_preferred_height_for_width() and using the
// sizes stored in the RequestedSize array.
// 
// To allocate a height-for-width container, it’s again important to consider
// that a container must prioritize one dimension over the other. So if a
// container is a height-for-width container it must first allocate all widgets
// horizontally using a RequestedSize array and
// gtk_distribute_natural_allocation() and then add any extra space (if and
// where appropriate) for the widget to expand.
// 
// After adding all the expand space, the container assumes it was allocated
// sufficient height to fit all of its content. At this time, the container must
// use the total horizontal sizes of each widget to request the height-for-width
// of each of its children and store the requests in a RequestedSize array for
// any widgets that stack vertically (for tabular containers this can be
// generalized into the heights and widths of rows and columns). The vertical
// space must then again be distributed using
// gtk_distribute_natural_allocation() while this time considering the allocated
// height of the widget minus any vertical spacing that the container adds. Then
// vertical expand space should be added where appropriate and available and the
// container should go on to actually allocating the child widgets.
// 
// See [GtkWidget’s geometry management section][geometry-management] to learn
// more about implementing height-for-width geometry management for widgets.
// 
// 
// Child properties
// 
// GtkContainer introduces child properties. These are object properties that
// are not specific to either the container or the contained widget, but rather
// to their relation. Typical examples of child properties are the position or
// pack-type of a widget which is contained in a Box.
// 
// Use gtk_container_class_install_child_property() to install child properties
// for a container class and gtk_container_class_find_child_property() or
// gtk_container_class_list_child_properties() to get information about existing
// child properties.
// 
// To set the value of a child property, use gtk_container_child_set_property(),
// gtk_container_child_set() or gtk_container_child_set_valist(). To obtain the
// value of a child property, use gtk_container_child_get_property(),
// gtk_container_child_get() or gtk_container_child_get_valist(). To emit
// notification about child property changes, use gtk_widget_child_notify().
// 
// 
// GtkContainer as GtkBuildable
// 
// The GtkContainer implementation of the GtkBuildable interface supports a
// <packing> element for children, which can contain multiple <property>
// elements that specify child properties for the child.
// 
// Since 2.16, child properties can also be marked as translatable using the
// same “translatable”, “comments” and “context” attributes that are used for
// regular properties.
// 
// Since 3.16, containers can have a <focus-chain> element containing multiple
// <widget> elements, one for each child that should be added to the focus
// chain. The ”name” attribute gives the id of the widget.
// 
// An example of these properties in UI definitions:
// 
//    <object class="GtkBox">
//      <child>
//        <object class="GtkEntry" id="entry1"/>
//        <packing>
//          <property name="pack-type">start</property>
//        </packing>
//      </child>
//      <child>
//        <object class="GtkEntry" id="entry2"/>
//      </child>
//      <focus-chain>
//        <widget name="entry1"/>
//        <widget name="entry2"/>
//      </focus-chain>
//    </object>
	type Container struct {
		Widget
		Buildable
		
	}

	// ContainerClass is an interface that the Container class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ContainerClass interface {
		gextras.Objector
		_container()
	}

	func (Container) _container() {}

	
	func marshalContainer(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapContainer(obj), nil
	}
	

	

	
	// Add adds @widget to @container. Typically used for simple containers such as
// Window, Frame, or Button; for more complicated layout containers such as Box
// or Grid, this function will pick default packing parameters that may not be
// correct. So consider functions such as gtk_box_pack_start() and
// gtk_grid_attach() as an alternative to gtk_container_add() in those cases. A
// widget may be added to only one container at a time; you can’t place the same
// widget inside two different containers.
// 
// Note that some containers, such as ScrolledWindow or ListBox, may add
// intermediate children between the added widget and the container.
	func (c Container) Add(widget WidgetClass)  {
var _arg0 *C.GtkContainer // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkContainer)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

C.gtk_container_add(_arg0, _arg1)
}
	
	
	func (c Container) CheckResize()  {
var _arg0 *C.GtkContainer // out

_arg0 = (*C.GtkContainer)(unsafe.Pointer(c.Native()))

C.gtk_container_check_resize(_arg0)
}
	
	// ChildGetProperty gets the value of a child property for @child and
// @container.
	func (c Container) ChildGetProperty(child WidgetClass, propertyName string, value **externglib.Value)  {
var _arg0 *C.GtkContainer // out
var _arg1 *C.GtkWidget // out
var _arg2 *C.gchar // out
var _arg3 *C.GValue // out

_arg0 = (*C.GtkContainer)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
_arg2 = (*C.gchar)(C.CString(propertyName))
defer C.free(unsafe.Pointer(_arg2))
_arg3 = (*C.GValue)(value.GValue)

C.gtk_container_child_get_property(_arg0, _arg1, _arg2, _arg3)
}
	
	// ChildNotify emits a Widget::child-notify signal for the [child
// property][child-properties] @child_property on the child.
// 
// This is an analogue of g_object_notify() for child properties.
// 
// Also see gtk_widget_child_notify().
	func (c Container) ChildNotify(child WidgetClass, childProperty string)  {
var _arg0 *C.GtkContainer // out
var _arg1 *C.GtkWidget // out
var _arg2 *C.gchar // out

_arg0 = (*C.GtkContainer)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
_arg2 = (*C.gchar)(C.CString(childProperty))
defer C.free(unsafe.Pointer(_arg2))

C.gtk_container_child_notify(_arg0, _arg1, _arg2)
}
	
	// ChildSetProperty sets a child property for @child and @container.
	func (c Container) ChildSetProperty(child WidgetClass, propertyName string, value **externglib.Value)  {
var _arg0 *C.GtkContainer // out
var _arg1 *C.GtkWidget // out
var _arg2 *C.gchar // out
var _arg3 *C.GValue // out

_arg0 = (*C.GtkContainer)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
_arg2 = (*C.gchar)(C.CString(propertyName))
defer C.free(unsafe.Pointer(_arg2))
_arg3 = (*C.GValue)(value.GValue)

C.gtk_container_child_set_property(_arg0, _arg1, _arg2, _arg3)
}
	
	// ChildType returns the type of the children supported by the container.
// 
// Note that this may return G_TYPE_NONE to indicate that no more children can
// be added, e.g. for a Paned which already has two children.
	func (c Container) ChildType() externglib.Type {
var _arg0 *C.GtkContainer // out
var _cret C.GType // in

_arg0 = (*C.GtkContainer)(unsafe.Pointer(c.Native()))

_cret = C.gtk_container_child_type(_arg0)


var _gType externglib.Type // out

_gType = externglib.Type(_cret)

return _gType
}
	
	// BorderWidth retrieves the border width of the container. See
// gtk_container_set_border_width().
	func (c Container) BorderWidth() uint {
var _arg0 *C.GtkContainer // out
var _cret C.guint // in

_arg0 = (*C.GtkContainer)(unsafe.Pointer(c.Native()))

_cret = C.gtk_container_get_border_width(_arg0)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// FocusChild returns the current focus child widget inside @container. This is
// not the currently focused widget. That can be obtained by calling
// gtk_window_get_focus().
	func (c Container) FocusChild() Widget {
var _arg0 *C.GtkContainer // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkContainer)(unsafe.Pointer(c.Native()))

_cret = C.gtk_container_get_focus_child(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// FocusHAdjustment retrieves the horizontal focus adjustment for the container.
// See gtk_container_set_focus_hadjustment ().
	func (c Container) FocusHAdjustment() Adjustment {
var _arg0 *C.GtkContainer // out
var _cret *C.GtkAdjustment // in

_arg0 = (*C.GtkContainer)(unsafe.Pointer(c.Native()))

_cret = C.gtk_container_get_focus_hadjustment(_arg0)


var _adjustment Adjustment // out

_adjustment = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Adjustment)

return _adjustment
}
	
	// FocusVAdjustment retrieves the vertical focus adjustment for the container.
// See gtk_container_set_focus_vadjustment().
	func (c Container) FocusVAdjustment() Adjustment {
var _arg0 *C.GtkContainer // out
var _cret *C.GtkAdjustment // in

_arg0 = (*C.GtkContainer)(unsafe.Pointer(c.Native()))

_cret = C.gtk_container_get_focus_vadjustment(_arg0)


var _adjustment Adjustment // out

_adjustment = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Adjustment)

return _adjustment
}
	
	// PathForChild returns a newly created widget path representing all the widget
// hierarchy from the toplevel down to and including @child.
	func (c Container) PathForChild(child WidgetClass) *WidgetPath {
var _arg0 *C.GtkContainer // out
var _arg1 *C.GtkWidget // out
var _cret *C.GtkWidgetPath // in

_arg0 = (*C.GtkContainer)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

_cret = C.gtk_container_get_path_for_child(_arg0, _arg1)


var _widgetPath *WidgetPath // out

_widgetPath = *(**WidgetPath)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_widgetPath, func(v *WidgetPath) {
  C.free(unsafe.Pointer(v.Native()))
})

return _widgetPath
}
	
	// ResizeMode returns the resize mode for the container. See
// gtk_container_set_resize_mode ().
	func (c Container) ResizeMode() ResizeMode {
var _arg0 *C.GtkContainer // out
var _cret C.GtkResizeMode // in

_arg0 = (*C.GtkContainer)(unsafe.Pointer(c.Native()))

_cret = C.gtk_container_get_resize_mode(_arg0)


var _resizeMode ResizeMode // out

_resizeMode = ResizeMode(_cret)

return _resizeMode
}
	
	// PropagateDraw: when a container receives a call to the draw function, it must
// send synthetic Widget::draw calls to all children that don’t have their own
// Windows. This function provides a convenient way of doing this. A container,
// when it receives a call to its Widget::draw function, calls
// gtk_container_propagate_draw() once for each child, passing in the @cr the
// container received.
// 
// gtk_container_propagate_draw() takes care of translating the origin of @cr,
// and deciding whether the draw needs to be sent to the child. It is a
// convenient and optimized way of getting the same effect as calling
// gtk_widget_draw() on the child directly.
// 
// In most cases, a container can simply either inherit the Widget::draw
// implementation from Container, or do some drawing and then chain to the
// ::draw implementation from Container.
	func (c Container) PropagateDraw(child WidgetClass, cr *cairo.Context)  {
var _arg0 *C.GtkContainer // out
var _arg1 *C.GtkWidget // out
var _arg2 *C.cairo_t // out

_arg0 = (*C.GtkContainer)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))

C.gtk_container_propagate_draw(_arg0, _arg1, _arg2)
}
	
	// Remove removes @widget from @container. @widget must be inside @container.
// Note that @container will own a reference to @widget, and that this may be
// the last reference held; so removing a widget from its container can destroy
// that widget. If you want to use @widget again, you need to add a reference to
// it before removing it from a container, using g_object_ref(). If you don’t
// want to use @widget again it’s usually more efficient to simply destroy it
// directly using gtk_widget_destroy() since this will remove it from the
// container and help break any circular reference count cycles.
	func (c Container) Remove(widget WidgetClass)  {
var _arg0 *C.GtkContainer // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkContainer)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

C.gtk_container_remove(_arg0, _arg1)
}
	
	
	func (c Container) ResizeChildren()  {
var _arg0 *C.GtkContainer // out

_arg0 = (*C.GtkContainer)(unsafe.Pointer(c.Native()))

C.gtk_container_resize_children(_arg0)
}
	
	// SetBorderWidth sets the border width of the container.
// 
// The border width of a container is the amount of space to leave around the
// outside of the container. The only exception to this is Window; because
// toplevel windows can’t leave space outside, they leave the space inside. The
// border is added on all sides of the container. To add space to only one side,
// use a specific Widget:margin property on the child widget, for example
// Widget:margin-top.
	func (c Container) SetBorderWidth(borderWidth uint)  {
var _arg0 *C.GtkContainer // out
var _arg1 C.guint // out

_arg0 = (*C.GtkContainer)(unsafe.Pointer(c.Native()))
_arg1 = (C.guint)(borderWidth)

C.gtk_container_set_border_width(_arg0, _arg1)
}
	
	// SetFocusChild: sets, or unsets if @child is nil, the focused child of
// @container.
// 
// This function emits the GtkContainer::set_focus_child signal of @container.
// Implementations of Container can override the default behaviour by overriding
// the class closure of this signal.
// 
// This is function is mostly meant to be used by widgets. Applications can use
// gtk_widget_grab_focus() to manually set the focus to a specific widget.
	func (c Container) SetFocusChild(child WidgetClass)  {
var _arg0 *C.GtkContainer // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkContainer)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

C.gtk_container_set_focus_child(_arg0, _arg1)
}
	
	// SetFocusHAdjustment hooks up an adjustment to focus handling in a container,
// so when a child of the container is focused, the adjustment is scrolled to
// show that widget. This function sets the horizontal alignment. See
// gtk_scrolled_window_get_hadjustment() for a typical way of obtaining the
// adjustment and gtk_container_set_focus_vadjustment() for setting the vertical
// adjustment.
// 
// The adjustments have to be in pixel units and in the same coordinate system
// as the allocation for immediate children of the container.
	func (c Container) SetFocusHAdjustment(adjustment AdjustmentClass)  {
var _arg0 *C.GtkContainer // out
var _arg1 *C.GtkAdjustment // out

_arg0 = (*C.GtkContainer)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(adjustment.Native()))

C.gtk_container_set_focus_hadjustment(_arg0, _arg1)
}
	
	// SetFocusVAdjustment hooks up an adjustment to focus handling in a container,
// so when a child of the container is focused, the adjustment is scrolled to
// show that widget. This function sets the vertical alignment. See
// gtk_scrolled_window_get_vadjustment() for a typical way of obtaining the
// adjustment and gtk_container_set_focus_hadjustment() for setting the
// horizontal adjustment.
// 
// The adjustments have to be in pixel units and in the same coordinate system
// as the allocation for immediate children of the container.
	func (c Container) SetFocusVAdjustment(adjustment AdjustmentClass)  {
var _arg0 *C.GtkContainer // out
var _arg1 *C.GtkAdjustment // out

_arg0 = (*C.GtkContainer)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(adjustment.Native()))

C.gtk_container_set_focus_vadjustment(_arg0, _arg1)
}
	
	// SetReallocateRedraws sets the @reallocate_redraws flag of the container to
// the given value.
// 
// Containers requesting reallocation redraws get automatically redrawn if any
// of their children changed allocation.
	func (c Container) SetReallocateRedraws(needsRedraws bool)  {
var _arg0 *C.GtkContainer // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkContainer)(unsafe.Pointer(c.Native()))
if needsRedraws { _arg1 = C.TRUE }

C.gtk_container_set_reallocate_redraws(_arg0, _arg1)
}
	
	// SetResizeMode sets the resize mode for the container.
// 
// The resize mode of a container determines whether a resize request will be
// passed to the container’s parent, queued for later execution or executed
// immediately.
	func (c Container) SetResizeMode(resizeMode ResizeMode)  {
var _arg0 *C.GtkContainer // out
var _arg1 C.GtkResizeMode // out

_arg0 = (*C.GtkContainer)(unsafe.Pointer(c.Native()))
_arg1 = (C.GtkResizeMode)(resizeMode)

C.gtk_container_set_resize_mode(_arg0, _arg1)
}
	
	// UnsetFocusChain removes a focus chain explicitly set with
// gtk_container_set_focus_chain().
	func (c Container) UnsetFocusChain()  {
var _arg0 *C.GtkContainer // out

_arg0 = (*C.GtkContainer)(unsafe.Pointer(c.Native()))

C.gtk_container_unset_focus_chain(_arg0)
}
	


	// CSSProvider: gtkCssProvider is an object implementing the StyleProvider
// interface. It is able to parse [CSS-like][css-overview] input in order to
// style widgets.
// 
// An application can make GTK+ parse a specific CSS style sheet by calling
// gtk_css_provider_load_from_file() or gtk_css_provider_load_from_resource()
// and adding the provider with gtk_style_context_add_provider() or
// gtk_style_context_add_provider_for_screen().
// 
// In addition, certain files will be read when GTK+ is initialized. First, the
// file `$XDG_CONFIG_HOME/gtk-3.0/gtk.css` is loaded if it exists. Then, GTK+
// loads the first existing file among
// `XDG_DATA_HOME/themes/THEME/gtk-VERSION/gtk.css`,
// `$HOME/.themes/THEME/gtk-VERSION/gtk.css`,
// `$XDG_DATA_DIRS/themes/THEME/gtk-VERSION/gtk.css` and
// `DATADIR/share/themes/THEME/gtk-VERSION/gtk.css`, where `THEME` is the name
// of the current theme (see the Settings:gtk-theme-name setting), `DATADIR` is
// the prefix configured when GTK+ was compiled (unless overridden by the
// `GTK_DATA_PREFIX` environment variable), and `VERSION` is the GTK+ version
// number. If no file is found for the current version, GTK+ tries older
// versions all the way back to 3.0.
// 
// In the same way, GTK+ tries to load a gtk-keys.css file for the current key
// theme, as defined by Settings:gtk-key-theme-name.
	type CSSProvider struct {
		**externglib.Object
		StyleProvider
		
	}

	// CSSProviderClass is an interface that the CSSProvider class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type CSSProviderClass interface {
		gextras.Objector
		_cssProvider()
	}

	func (CSSProvider) _cssProvider() {}

	
	func marshalCSSProvider(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapCSSProvider(obj), nil
	}
	

	
	// NewCSSProvider returns a newly created CssProvider.
	func NewCSSProvider() CSSProvider {
var _cret *C.GtkCssProvider // in

_cret = C.gtk_css_provider_new()


var _cssProvider CSSProvider // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_cssProvider = CSSProvider{
Object: &externglib.Object{externglib.ToGObject(obj)},
StyleProvider: StyleProvider{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _cssProvider
}
	

	
	// LoadFromData loads @data into @css_provider, and by doing so clears any
// previously loaded information.
	func (c CSSProvider) LoadFromData(data []byte) error {
var _arg0 *C.GtkCssProvider // out
var _arg1 *C.gchar
var _arg2 C.gssize
var _cerr *C.GError // in

_arg0 = (*C.GtkCssProvider)(unsafe.Pointer(c.Native()))
_arg2 = C.gssize(len(data))
_arg1 = (*C.gchar)(unsafe.Pointer(&data[0]))

C.gtk_css_provider_load_from_data(_arg0, _arg1, _arg2, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// LoadFromFile loads the data contained in @file into @css_provider, making it
// clear any previously loaded information.
	func (c CSSProvider) LoadFromFile(file gio.File) error {
var _arg0 *C.GtkCssProvider // out
var _arg1 *C.GFile // out
var _cerr *C.GError // in

_arg0 = (*C.GtkCssProvider)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GFile)(unsafe.Pointer(file.Native()))

C.gtk_css_provider_load_from_file(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// LoadFromPath loads the data contained in @path into @css_provider, making it
// clear any previously loaded information.
	func (c CSSProvider) LoadFromPath(path string) error {
var _arg0 *C.GtkCssProvider // out
var _arg1 *C.gchar // out
var _cerr *C.GError // in

_arg0 = (*C.GtkCssProvider)(unsafe.Pointer(c.Native()))
_arg1 = (*C.gchar)(C.CString(path))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_css_provider_load_from_path(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// LoadFromResource loads the data contained in the resource at @resource_path
// into the CssProvider, clearing any previously loaded information.
// 
// To track errors while loading CSS, connect to the CssProvider::parsing-error
// signal.
	func (c CSSProvider) LoadFromResource(resourcePath string)  {
var _arg0 *C.GtkCssProvider // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkCssProvider)(unsafe.Pointer(c.Native()))
_arg1 = (*C.gchar)(C.CString(resourcePath))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_css_provider_load_from_resource(_arg0, _arg1)
}
	
	// String converts the @provider into a string representation in CSS format.
// 
// Using gtk_css_provider_load_from_data() with the return value from this
// function on a new provider created with gtk_css_provider_new() will basically
// create a duplicate of this @provider.
	func (p CSSProvider) String() string {
var _arg0 *C.GtkCssProvider // out
var _cret *C.char // in

_arg0 = (*C.GtkCssProvider)(unsafe.Pointer(p.Native()))

_cret = C.gtk_css_provider_to_string(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	


	// Dialog: dialog boxes are a convenient way to prompt the user for a small
// amount of input, e.g. to display a message, ask a question, or anything else
// that does not require extensive effort on the user’s part.
// 
// GTK+ treats a dialog as a window split vertically. The top section is a VBox,
// and is where widgets such as a Label or a Entry should be packed. The bottom
// area is known as the “action area”. This is generally used for packing
// buttons into the dialog which may perform functions such as cancel, ok, or
// apply.
// 
// Dialog boxes are created with a call to gtk_dialog_new() or
// gtk_dialog_new_with_buttons(). gtk_dialog_new_with_buttons() is recommended;
// it allows you to set the dialog title, some convenient flags, and add simple
// buttons.
// 
// If “dialog” is a newly created dialog, the two primary areas of the window
// can be accessed through gtk_dialog_get_content_area() and
// gtk_dialog_get_action_area(), as can be seen from the example below.
// 
// A “modal” dialog (that is, one which freezes the rest of the application from
// user input), can be created by calling gtk_window_set_modal() on the dialog.
// Use the GTK_WINDOW() macro to cast the widget returned from gtk_dialog_new()
// into a Window. When using gtk_dialog_new_with_buttons() you can also pass the
// K_DIALOG_MODAL flag to make a dialog modal.
// 
// If you add buttons to Dialog using gtk_dialog_new_with_buttons(),
// gtk_dialog_add_button(), gtk_dialog_add_buttons(), or
// gtk_dialog_add_action_widget(), clicking the button will emit a signal called
// Dialog::response with a response ID that you specified. GTK+ will never
// assign a meaning to positive response IDs; these are entirely user-defined.
// But for convenience, you can use the response IDs in the ResponseType
// enumeration (these all have values less than zero). If a dialog receives a
// delete event, the Dialog::response signal will be emitted with a response ID
// of K_RESPONSE_DELETE_EVENT.
// 
// If you want to block waiting for a dialog to return before returning control
// flow to your code, you can call gtk_dialog_run(). This function enters a
// recursive main loop and waits for the user to respond to the dialog,
// returning the response ID corresponding to the button the user clicked.
// 
// For the simple dialog in the following example, in reality you’d probably use
// MessageDialog to save yourself some effort. But you’d need to create the
// dialog contents manually if you had more than a simple message in the dialog.
// 
// An example for simple GtkDialog usage:
// 
//    // Function to open a dialog box with a message
//    void
//    quick_message (GtkWindow *parent, gchar *message)
//    {
//     GtkWidget *dialog, *label, *content_area;
//     GtkDialogFlags flags;
// 
//     // Create the widgets
//     flags = GTK_DIALOG_DESTROY_WITH_PARENT;
//     dialog = gtk_dialog_new_with_buttons ("Message",
//                                           parent,
//                                           flags,
//                                           _("_OK"),
//                                           GTK_RESPONSE_NONE,
//                                           NULL);
//     content_area = gtk_dialog_get_content_area (GTK_DIALOG (dialog));
//     label = gtk_label_new (message);
// 
//     // Ensure that the dialog box is destroyed when the user responds
// 
//     g_signal_connect_swapped (dialog,
//                               "response",
//                               G_CALLBACK (gtk_widget_destroy),
//                               dialog);
// 
//     // Add the label, and show everything we’ve added
// 
//     gtk_container_add (GTK_CONTAINER (content_area), label);
//     gtk_widget_show_all (dialog);
//    }
// 
// 
// GtkDialog as GtkBuildable
// 
// The GtkDialog implementation of the Buildable interface exposes the @vbox and
// @action_area as internal children with the names “vbox” and “action_area”.
// 
// GtkDialog supports a custom <action-widgets> element, which can contain
// multiple <action-widget> elements. The “response” attribute specifies a
// numeric response, and the content of the element is the id of widget (which
// should be a child of the dialogs @action_area). To mark a response as
// default, set the “default“ attribute of the <action-widget> element to true.
// 
// GtkDialog supports adding action widgets by specifying “action“ as the “type“
// attribute of a <child> element. The widget will be added either to the action
// area or the headerbar of the dialog, depending on the “use-header-bar“
// property. The response id has to be associated with the action widget using
// the <action-widgets> element.
// 
// An example of a Dialog UI definition fragment:
// 
//    <object class="GtkDialog" id="dialog1">
//      <child type="action">
//        <object class="GtkButton" id="button_cancel"/>
//      </child>
//      <child type="action">
//        <object class="GtkButton" id="button_ok">
//          <property name="can-default">True</property>
//        </object>
//      </child>
//      <action-widgets>
//        <action-widget response="cancel">button_cancel</action-widget>
//        <action-widget response="ok" default="true">button_ok</action-widget>
//      </action-widgets>
//    </object>
	type Dialog struct {
		Window
		Buildable
		
	}

	// DialogClass is an interface that the Dialog class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type DialogClass interface {
		gextras.Objector
		_dialog()
	}

	func (Dialog) _dialog() {}

	
	func marshalDialog(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapDialog(obj), nil
	}
	

	
	// NewDialog creates a new dialog box.
// 
// Widgets should not be packed into this Window directly, but into the @vbox
// and @action_area, as described above.
	func NewDialog() Dialog {
var _cret *C.GtkWidget // in

_cret = C.gtk_dialog_new()


var _dialog Dialog // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_dialog = Dialog{
Window: Window{
Bin: Bin{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _dialog
}
	

	
	// AddActionWidget adds an activatable widget to the action area of a Dialog,
// connecting a signal handler that will emit the Dialog::response signal on the
// dialog when the widget is activated. The widget is appended to the end of the
// dialog’s action area. If you want to add a non-activatable widget, simply
// pack it into the @action_area field of the Dialog struct.
	func (d Dialog) AddActionWidget(child WidgetClass, responseId int)  {
var _arg0 *C.GtkDialog // out
var _arg1 *C.GtkWidget // out
var _arg2 C.gint // out

_arg0 = (*C.GtkDialog)(unsafe.Pointer(d.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
_arg2 = (C.gint)(responseId)

C.gtk_dialog_add_action_widget(_arg0, _arg1, _arg2)
}
	
	// AddButton adds a button with the given text and sets things up so that
// clicking the button will emit the Dialog::response signal with the given
// @response_id. The button is appended to the end of the dialog’s action area.
// The button widget is returned, but usually you don’t need it.
	func (d Dialog) AddButton(buttonText string, responseId int) Widget {
var _arg0 *C.GtkDialog // out
var _arg1 *C.gchar // out
var _arg2 C.gint // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkDialog)(unsafe.Pointer(d.Native()))
_arg1 = (*C.gchar)(C.CString(buttonText))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.gint)(responseId)

_cret = C.gtk_dialog_add_button(_arg0, _arg1, _arg2)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// ActionArea returns the action area of @dialog.
	func (d Dialog) ActionArea() Box {
var _arg0 *C.GtkDialog // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkDialog)(unsafe.Pointer(d.Native()))

_cret = C.gtk_dialog_get_action_area(_arg0)


var _box Box // out

_box = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Box)

return _box
}
	
	// ContentArea returns the content area of @dialog.
	func (d Dialog) ContentArea() Box {
var _arg0 *C.GtkDialog // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkDialog)(unsafe.Pointer(d.Native()))

_cret = C.gtk_dialog_get_content_area(_arg0)


var _box Box // out

_box = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Box)

return _box
}
	
	// HeaderBar returns the header bar of @dialog. Note that the headerbar is only
// used by the dialog if the Dialog:use-header-bar property is true.
	func (d Dialog) HeaderBar() HeaderBar {
var _arg0 *C.GtkDialog // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkDialog)(unsafe.Pointer(d.Native()))

_cret = C.gtk_dialog_get_header_bar(_arg0)


var _headerBar HeaderBar // out

_headerBar = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(HeaderBar)

return _headerBar
}
	
	// ResponseForWidget gets the response id of a widget in the action area of a
// dialog.
	func (d Dialog) ResponseForWidget(widget WidgetClass) int {
var _arg0 *C.GtkDialog // out
var _arg1 *C.GtkWidget // out
var _cret C.gint // in

_arg0 = (*C.GtkDialog)(unsafe.Pointer(d.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

_cret = C.gtk_dialog_get_response_for_widget(_arg0, _arg1)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// WidgetForResponse gets the widget button that uses the given response ID in
// the action area of a dialog.
	func (d Dialog) WidgetForResponse(responseId int) Widget {
var _arg0 *C.GtkDialog // out
var _arg1 C.gint // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkDialog)(unsafe.Pointer(d.Native()))
_arg1 = (C.gint)(responseId)

_cret = C.gtk_dialog_get_widget_for_response(_arg0, _arg1)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// Response emits the Dialog::response signal with the given response ID. Used
// to indicate that the user has responded to the dialog in some way; typically
// either you or gtk_dialog_run() will be monitoring the ::response signal and
// take appropriate action.
	func (d Dialog) Response(responseId int)  {
var _arg0 *C.GtkDialog // out
var _arg1 C.gint // out

_arg0 = (*C.GtkDialog)(unsafe.Pointer(d.Native()))
_arg1 = (C.gint)(responseId)

C.gtk_dialog_response(_arg0, _arg1)
}
	
	// Run blocks in a recursive main loop until the @dialog either emits the
// Dialog::response signal, or is destroyed. If the dialog is destroyed during
// the call to gtk_dialog_run(), gtk_dialog_run() returns K_RESPONSE_NONE.
// Otherwise, it returns the response ID from the ::response signal emission.
// 
// Before entering the recursive main loop, gtk_dialog_run() calls
// gtk_widget_show() on the dialog for you. Note that you still need to show any
// children of the dialog yourself.
// 
// During gtk_dialog_run(), the default behavior of Widget::delete-event is
// disabled; if the dialog receives ::delete_event, it will not be destroyed as
// windows usually are, and gtk_dialog_run() will return
// K_RESPONSE_DELETE_EVENT. Also, during gtk_dialog_run() the dialog will be
// modal. You can force gtk_dialog_run() to return at any time by calling
// gtk_dialog_response() to emit the ::response signal. Destroying the dialog
// during gtk_dialog_run() is a very bad idea, because your post-run code won’t
// know whether the dialog was destroyed or not.
// 
// After gtk_dialog_run() returns, you are responsible for hiding or destroying
// the dialog if you wish to do so.
// 
// Typical usage of this function might be:
// 
//      GtkWidget *dialog = gtk_dialog_new ();
//      // Set up dialog...
// 
//      int result = gtk_dialog_run (GTK_DIALOG (dialog));
//      switch (result)
//        {
//          case GTK_RESPONSE_ACCEPT:
//             // do_application_specific_something ();
//             break;
//          default:
//             // do_nothing_since_dialog_was_cancelled ();
//             break;
//        }
//      gtk_widget_destroy (dialog);
// 
// Note that even though the recursive main loop gives the effect of a modal
// dialog (it prevents the user from interacting with other windows in the same
// window group while the dialog is run), callbacks such as timeouts, IO channel
// watches, DND drops, etc, will be triggered during a gtk_dialog_run() call.
	func (d Dialog) Run() int {
var _arg0 *C.GtkDialog // out
var _cret C.gint // in

_arg0 = (*C.GtkDialog)(unsafe.Pointer(d.Native()))

_cret = C.gtk_dialog_run(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// SetAlternativeButtonOrderFromArray sets an alternative button order. If the
// Settings:gtk-alternative-button-order setting is set to true, the dialog
// buttons are reordered according to the order of the response ids in
// @new_order.
// 
// See gtk_dialog_set_alternative_button_order() for more information.
// 
// This function is for use by language bindings.
	func (d Dialog) SetAlternativeButtonOrderFromArray(newOrder []int)  {
var _arg0 *C.GtkDialog // out
var _arg2 *C.gint
var _arg1 C.gint

_arg0 = (*C.GtkDialog)(unsafe.Pointer(d.Native()))
_arg1 = C.gint(len(newOrder))
_arg2 = (*C.gint)(unsafe.Pointer(&newOrder[0]))

C.gtk_dialog_set_alternative_button_order_from_array(_arg0, _arg1, _arg2)
}
	
	// SetDefaultResponse sets the last widget in the dialog’s action area with the
// given @response_id as the default widget for the dialog. Pressing “Enter”
// normally activates the default widget.
	func (d Dialog) SetDefaultResponse(responseId int)  {
var _arg0 *C.GtkDialog // out
var _arg1 C.gint // out

_arg0 = (*C.GtkDialog)(unsafe.Pointer(d.Native()))
_arg1 = (C.gint)(responseId)

C.gtk_dialog_set_default_response(_arg0, _arg1)
}
	
	// SetResponseSensitive calls `gtk_widget_set_sensitive (widget, @setting)` for
// each widget in the dialog’s action area with the given @response_id. A
// convenient way to sensitize/desensitize dialog buttons.
	func (d Dialog) SetResponseSensitive(responseId int, setting bool)  {
var _arg0 *C.GtkDialog // out
var _arg1 C.gint // out
var _arg2 C.gboolean // out

_arg0 = (*C.GtkDialog)(unsafe.Pointer(d.Native()))
_arg1 = (C.gint)(responseId)
if setting { _arg2 = C.TRUE }

C.gtk_dialog_set_response_sensitive(_arg0, _arg1, _arg2)
}
	


	// DrawingArea: the DrawingArea widget is used for creating custom user
// interface elements. It’s essentially a blank widget; you can draw on it.
// After creating a drawing area, the application may want to connect to:
// 
// - Mouse and button press signals to respond to input from the user. (Use
// gtk_widget_add_events() to enable events you wish to receive.)
// 
// - The Widget::realize signal to take any necessary actions when the widget is
// instantiated on a particular display. (Create GDK resources in response to
// this signal.)
// 
// - The Widget::size-allocate signal to take any necessary actions when the
// widget changes size.
// 
// - The Widget::draw signal to handle redrawing the contents of the widget.
// 
// The following code portion demonstrates using a drawing area to display a
// circle in the normal widget foreground color.
// 
// Note that GDK automatically clears the exposed area before sending the expose
// event, and that drawing is implicitly clipped to the exposed area. If you
// want to have a theme-provided background, you need to call
// gtk_render_background() in your ::draw method.
// 
// Simple GtkDrawingArea usage
// 
//    gboolean
//    draw_callback (GtkWidget *widget, cairo_t *cr, gpointer data)
//    {
//      guint width, height;
//      GdkRGBA color;
//      GtkStyleContext *context;
// 
//      context = gtk_widget_get_style_context (widget);
// 
//      width = gtk_widget_get_allocated_width (widget);
//      height = gtk_widget_get_allocated_height (widget);
// 
//      gtk_render_background (context, cr, 0, 0, width, height);
// 
//      cairo_arc (cr,
//                 width / 2.0, height / 2.0,
//                 MIN (width, height) / 2.0,
//                 0, 2 * G_PI);
// 
//      gtk_style_context_get_color (context,
//                                   gtk_style_context_get_state (context),
//                                   &color);
//      gdk_cairo_set_source_rgba (cr, &color);
// 
//      cairo_fill (cr);
// 
//     return FALSE;
//    }
//    [...]
//      GtkWidget *drawing_area = gtk_drawing_area_new ();
//      gtk_widget_set_size_request (drawing_area, 100, 100);
//      g_signal_connect (G_OBJECT (drawing_area), "draw",
//                        G_CALLBACK (draw_callback), NULL);
// 
// Draw signals are normally delivered when a drawing area first comes onscreen,
// or when it’s covered by another window and then uncovered. You can also force
// an expose event by adding to the “damage region” of the drawing area’s
// window; gtk_widget_queue_draw_area() and gdk_window_invalidate_rect() are
// equally good ways to do this. You’ll then get a draw signal for the invalid
// region.
// 
// The available routines for drawing are documented on the [GDK Drawing
// Primitives][gdk3-Cairo-Interaction] page and the cairo documentation.
// 
// To receive mouse events on a drawing area, you will need to enable them with
// gtk_widget_add_events(). To receive keyboard events, you will need to set the
// “can-focus” property on the drawing area, and you should probably draw some
// user-visible indication that the drawing area is focused. Use
// gtk_widget_has_focus() in your expose event handler to decide whether to draw
// the focus indicator. See gtk_render_focus() for one way to draw focus.
	type DrawingArea struct {
		Widget
		Buildable
		
	}

	// DrawingAreaClass is an interface that the DrawingArea class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type DrawingAreaClass interface {
		gextras.Objector
		_drawingArea()
	}

	func (DrawingArea) _drawingArea() {}

	
	func marshalDrawingArea(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapDrawingArea(obj), nil
	}
	

	
	// NewDrawingArea creates a new drawing area.
	func NewDrawingArea() DrawingArea {
var _cret *C.GtkWidget // in

_cret = C.gtk_drawing_area_new()


var _drawingArea DrawingArea // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_drawingArea = DrawingArea{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _drawingArea
}
	

	


	// Entry: the Entry widget is a single line text entry widget. A fairly large
// set of key bindings are supported by default. If the entered text is longer
// than the allocation of the widget, the widget will scroll so that the cursor
// position is visible.
// 
// When using an entry for passwords and other sensitive information, it can be
// put into “password mode” using gtk_entry_set_visibility(). In this mode,
// entered text is displayed using a “invisible” character. By default, GTK+
// picks the best invisible character that is available in the current font, but
// it can be changed with gtk_entry_set_invisible_char(). Since 2.16, GTK+
// displays a warning when Caps Lock or input methods might interfere with
// entering text in a password entry. The warning can be turned off with the
// Entry:caps-lock-warning property.
// 
// Since 2.16, GtkEntry has the ability to display progress or activity
// information behind the text. To make an entry display such information, use
// gtk_entry_set_progress_fraction() or gtk_entry_set_progress_pulse_step().
// 
// Additionally, GtkEntry can show icons at either side of the entry. These
// icons can be activatable by clicking, can be set up as drag source and can
// have tooltips. To add an icon, use gtk_entry_set_icon_from_gicon() or one of
// the various other functions that set an icon from a stock id, an icon name or
// a pixbuf. To trigger an action when the user clicks an icon, connect to the
// Entry::icon-press signal. To allow DND operations from an icon, use
// gtk_entry_set_icon_drag_source(). To set a tooltip on an icon, use
// gtk_entry_set_icon_tooltip_text() or the corresponding function for markup.
// 
// Note that functionality or information that is only available by clicking on
// an icon in an entry may not be accessible at all to users which are not able
// to use a mouse or other pointing device. It is therefore recommended that any
// such functionality should also be available by other means, e.g. via the
// context menu of the entry.
// 
// CSS nodes
// 
//    entry[.read-only][.flat][.warning][.error]
//    ├── image.left
//    ├── image.right
//    ├── undershoot.left
//    ├── undershoot.right
//    ├── [selection]
//    ├── [progress[.pulse]]
//    ╰── [window.popup]
// 
// GtkEntry has a main node with the name entry. Depending on the properties of
// the entry, the style classes .read-only and .flat may appear. The style
// classes .warning and .error may also be used with entries.
// 
// When the entry shows icons, it adds subnodes with the name image and the
// style class .left or .right, depending on where the icon appears.
// 
// When the entry has a selection, it adds a subnode with the name selection.
// 
// When the entry shows progress, it adds a subnode with the name progress. The
// node has the style class .pulse when the shown progress is pulsing.
// 
// The CSS node for a context menu is added as a subnode below entry as well.
// 
// The undershoot nodes are used to draw the underflow indication when content
// is scrolled out of view. These nodes get the .left and .right style classes
// added depending on where the indication is drawn.
// 
// When touch is used and touch selection handles are shown, they are using CSS
// nodes with name cursor-handle. They get the .top or .bottom style class
// depending on where they are shown in relation to the selection. If there is
// just a single handle for the text cursor, it gets the style class
// .insertion-cursor.
	type Entry struct {
		Widget
		Buildable
		CellEditable
		Editable
		
	}

	// EntryClass is an interface that the Entry class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type EntryClass interface {
		gextras.Objector
		_entry()
	}

	func (Entry) _entry() {}

	
	func marshalEntry(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapEntry(obj), nil
	}
	

	
	// NewEntry creates a new entry.
	func NewEntry() Entry {
var _cret *C.GtkWidget // in

_cret = C.gtk_entry_new()


var _entry Entry // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_entry = Entry{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
CellEditable: CellEditable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Editable: Editable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _entry
}
	
	// NewEntryWithBuffer creates a new entry with the specified text buffer.
	func NewEntryWithBuffer(buffer EntryBufferClass) Entry {
var _arg1 *C.GtkEntryBuffer // out
var _cret *C.GtkWidget // in

_arg1 = (*C.GtkEntryBuffer)(unsafe.Pointer(buffer.Native()))

_cret = C.gtk_entry_new_with_buffer(_arg1)


var _entry Entry // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_entry = Entry{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
CellEditable: CellEditable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Editable: Editable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _entry
}
	

	
	// ActivatesDefault retrieves the value set by
// gtk_entry_set_activates_default().
	func (e Entry) ActivatesDefault() bool {
var _arg0 *C.GtkEntry // out
var _cret C.gboolean // in

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

_cret = C.gtk_entry_get_activates_default(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Alignment gets the value set by gtk_entry_set_alignment().
	func (e Entry) Alignment() float32 {
var _arg0 *C.GtkEntry // out
var _cret C.gfloat // in

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

_cret = C.gtk_entry_get_alignment(_arg0)


var _gfloat float32 // out

_gfloat = (float32)(_cret)

return _gfloat
}
	
	// Attributes gets the attribute list that was set on the entry using
// gtk_entry_set_attributes(), if any.
	func (e Entry) Attributes() *pango.AttrList {
var _arg0 *C.GtkEntry // out
var _cret *C.PangoAttrList // in

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

_cret = C.gtk_entry_get_attributes(_arg0)


var _attrList *pango.AttrList // out

_attrList = *(**pango.AttrList)(unsafe.Pointer(&_cret))

return _attrList
}
	
	// Buffer: get the EntryBuffer object which holds the text for this widget.
	func (e Entry) Buffer() EntryBuffer {
var _arg0 *C.GtkEntry // out
var _cret *C.GtkEntryBuffer // in

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

_cret = C.gtk_entry_get_buffer(_arg0)


var _entryBuffer EntryBuffer // out

_entryBuffer = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(EntryBuffer)

return _entryBuffer
}
	
	// Completion returns the auxiliary completion object currently in use by
// @entry.
	func (e Entry) Completion() EntryCompletion {
var _arg0 *C.GtkEntry // out
var _cret *C.GtkEntryCompletion // in

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

_cret = C.gtk_entry_get_completion(_arg0)


var _entryCompletion EntryCompletion // out

_entryCompletion = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(EntryCompletion)

return _entryCompletion
}
	
	// CurrentIconDragSource returns the index of the icon which is the source of
// the current DND operation, or -1.
// 
// This function is meant to be used in a Widget::drag-data-get callback.
	func (e Entry) CurrentIconDragSource() int {
var _arg0 *C.GtkEntry // out
var _cret C.gint // in

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

_cret = C.gtk_entry_get_current_icon_drag_source(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// CursorHAdjustment retrieves the horizontal cursor adjustment for the entry.
// See gtk_entry_set_cursor_hadjustment().
	func (e Entry) CursorHAdjustment() Adjustment {
var _arg0 *C.GtkEntry // out
var _cret *C.GtkAdjustment // in

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

_cret = C.gtk_entry_get_cursor_hadjustment(_arg0)


var _adjustment Adjustment // out

_adjustment = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Adjustment)

return _adjustment
}
	
	// HasFrame gets the value set by gtk_entry_set_has_frame().
	func (e Entry) HasFrame() bool {
var _arg0 *C.GtkEntry // out
var _cret C.gboolean // in

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

_cret = C.gtk_entry_get_has_frame(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IconActivatable returns whether the icon is activatable.
	func (e Entry) IconActivatable(iconPos EntryIconPosition) bool {
var _arg0 *C.GtkEntry // out
var _arg1 C.GtkEntryIconPosition // out
var _cret C.gboolean // in

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
_arg1 = (C.GtkEntryIconPosition)(iconPos)

_cret = C.gtk_entry_get_icon_activatable(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IconArea gets the area where entry’s icon at @icon_pos is drawn. This
// function is useful when drawing something to the entry in a draw callback.
// 
// If the entry is not realized or has no icon at the given position, @icon_area
// is filled with zeros. Otherwise, @icon_area will be filled with the icon’s
// allocation, relative to @entry’s allocation.
// 
// See also gtk_entry_get_text_area()
	func (e Entry) IconArea(iconPos EntryIconPosition) gdk.Rectangle {
var _arg0 *C.GtkEntry // out
var _arg1 C.GtkEntryIconPosition // out
var _iconArea gdk.Rectangle

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
_arg1 = (C.GtkEntryIconPosition)(iconPos)

C.gtk_entry_get_icon_area(_arg0, _arg1, (*C.GdkRectangle)(unsafe.Pointer(&_iconArea)))





return _iconArea
}
	
	// IconAtPos finds the icon at the given position and return its index. The
// position’s coordinates are relative to the @entry’s top left corner. If @x,
// @y doesn’t lie inside an icon, -1 is returned. This function is intended for
// use in a Widget::query-tooltip signal handler.
	func (e Entry) IconAtPos(x int, y int) int {
var _arg0 *C.GtkEntry // out
var _arg1 C.gint // out
var _arg2 C.gint // out
var _cret C.gint // in

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
_arg1 = (C.gint)(x)
_arg2 = (C.gint)(y)

_cret = C.gtk_entry_get_icon_at_pos(_arg0, _arg1, _arg2)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// IconGIcon retrieves the #GIcon used for the icon, or nil if there is no icon
// or if the icon was set by some other method (e.g., by stock, pixbuf, or icon
// name).
	func (e Entry) IconGIcon(iconPos EntryIconPosition) gio.Icon {
var _arg0 *C.GtkEntry // out
var _arg1 C.GtkEntryIconPosition // out
var _cret *C.GIcon // in

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
_arg1 = (C.GtkEntryIconPosition)(iconPos)

_cret = C.gtk_entry_get_icon_gicon(_arg0, _arg1)


var _icon gio.Icon // out

_icon = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.Icon)

return _icon
}
	
	// IconName retrieves the icon name used for the icon, or nil if there is no
// icon or if the icon was set by some other method (e.g., by pixbuf, stock or
// gicon).
	func (e Entry) IconName(iconPos EntryIconPosition) string {
var _arg0 *C.GtkEntry // out
var _arg1 C.GtkEntryIconPosition // out
var _cret *C.gchar // in

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
_arg1 = (C.GtkEntryIconPosition)(iconPos)

_cret = C.gtk_entry_get_icon_name(_arg0, _arg1)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// IconPixbuf retrieves the image used for the icon.
// 
// Unlike the other methods of setting and getting icon data, this method will
// work regardless of whether the icon was set using a Pixbuf, a #GIcon, a stock
// item, or an icon name.
	func (e Entry) IconPixbuf(iconPos EntryIconPosition) gdkpixbuf.Pixbuf {
var _arg0 *C.GtkEntry // out
var _arg1 C.GtkEntryIconPosition // out
var _cret *C.GdkPixbuf // in

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
_arg1 = (C.GtkEntryIconPosition)(iconPos)

_cret = C.gtk_entry_get_icon_pixbuf(_arg0, _arg1)


var _pixbuf gdkpixbuf.Pixbuf // out

_pixbuf = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdkpixbuf.Pixbuf)

return _pixbuf
}
	
	// IconSensitive returns whether the icon appears sensitive or insensitive.
	func (e Entry) IconSensitive(iconPos EntryIconPosition) bool {
var _arg0 *C.GtkEntry // out
var _arg1 C.GtkEntryIconPosition // out
var _cret C.gboolean // in

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
_arg1 = (C.GtkEntryIconPosition)(iconPos)

_cret = C.gtk_entry_get_icon_sensitive(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IconStock retrieves the stock id used for the icon, or nil if there is no
// icon or if the icon was set by some other method (e.g., by pixbuf, icon name
// or gicon).
	func (e Entry) IconStock(iconPos EntryIconPosition) string {
var _arg0 *C.GtkEntry // out
var _arg1 C.GtkEntryIconPosition // out
var _cret *C.gchar // in

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
_arg1 = (C.GtkEntryIconPosition)(iconPos)

_cret = C.gtk_entry_get_icon_stock(_arg0, _arg1)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// IconStorageType gets the type of representation being used by the icon to
// store image data. If the icon has no image data, the return value will be
// GTK_IMAGE_EMPTY.
	func (e Entry) IconStorageType(iconPos EntryIconPosition) ImageType {
var _arg0 *C.GtkEntry // out
var _arg1 C.GtkEntryIconPosition // out
var _cret C.GtkImageType // in

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
_arg1 = (C.GtkEntryIconPosition)(iconPos)

_cret = C.gtk_entry_get_icon_storage_type(_arg0, _arg1)


var _imageType ImageType // out

_imageType = ImageType(_cret)

return _imageType
}
	
	// IconTooltipMarkup gets the contents of the tooltip on the icon at the
// specified position in @entry.
	func (e Entry) IconTooltipMarkup(iconPos EntryIconPosition) string {
var _arg0 *C.GtkEntry // out
var _arg1 C.GtkEntryIconPosition // out
var _cret *C.gchar // in

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
_arg1 = (C.GtkEntryIconPosition)(iconPos)

_cret = C.gtk_entry_get_icon_tooltip_markup(_arg0, _arg1)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// IconTooltipText gets the contents of the tooltip on the icon at the specified
// position in @entry.
	func (e Entry) IconTooltipText(iconPos EntryIconPosition) string {
var _arg0 *C.GtkEntry // out
var _arg1 C.GtkEntryIconPosition // out
var _cret *C.gchar // in

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
_arg1 = (C.GtkEntryIconPosition)(iconPos)

_cret = C.gtk_entry_get_icon_tooltip_text(_arg0, _arg1)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// InnerBorder: this function returns the entry’s Entry:inner-border property.
// See gtk_entry_set_inner_border() for more information.
	func (e Entry) InnerBorder() *Border {
var _arg0 *C.GtkEntry // out
var _cret *C.GtkBorder // in

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

_cret = C.gtk_entry_get_inner_border(_arg0)


var _border *Border // out

_border = *(**Border)(unsafe.Pointer(&_cret))

return _border
}
	
	// InputHints gets the value of the Entry:input-hints property.
	func (e Entry) InputHints() InputHints {
var _arg0 *C.GtkEntry // out
var _cret C.GtkInputHints // in

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

_cret = C.gtk_entry_get_input_hints(_arg0)


var _inputHints InputHints // out

_inputHints = InputHints(_cret)

return _inputHints
}
	
	// InputPurpose gets the value of the Entry:input-purpose property.
	func (e Entry) InputPurpose() InputPurpose {
var _arg0 *C.GtkEntry // out
var _cret C.GtkInputPurpose // in

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

_cret = C.gtk_entry_get_input_purpose(_arg0)


var _inputPurpose InputPurpose // out

_inputPurpose = InputPurpose(_cret)

return _inputPurpose
}
	
	// InvisibleChar retrieves the character displayed in place of the real
// characters for entries with visibility set to false. See
// gtk_entry_set_invisible_char().
	func (e Entry) InvisibleChar() uint32 {
var _arg0 *C.GtkEntry // out
var _cret C.gunichar // in

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

_cret = C.gtk_entry_get_invisible_char(_arg0)


var _gunichar uint32 // out

_gunichar = (uint32)(_cret)

return _gunichar
}
	
	// Layout gets the Layout used to display the entry. The layout is useful to
// e.g. convert text positions to pixel positions, in combination with
// gtk_entry_get_layout_offsets(). The returned layout is owned by the entry and
// must not be modified or freed by the caller.
// 
// Keep in mind that the layout text may contain a preedit string, so
// gtk_entry_layout_index_to_text_index() and
// gtk_entry_text_index_to_layout_index() are needed to convert byte indices in
// the layout to byte indices in the entry contents.
	func (e Entry) Layout() pango.Layout {
var _arg0 *C.GtkEntry // out
var _cret *C.PangoLayout // in

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

_cret = C.gtk_entry_get_layout(_arg0)


var _layout pango.Layout // out

_layout = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(pango.Layout)

return _layout
}
	
	// LayoutOffsets obtains the position of the Layout used to render text in the
// entry, in widget coordinates. Useful if you want to line up the text in an
// entry with some other text, e.g. when using the entry to implement editable
// cells in a sheet widget.
// 
// Also useful to convert mouse events into coordinates inside the Layout, e.g.
// to take some action if some part of the entry text is clicked.
// 
// Note that as the user scrolls around in the entry the offsets will change;
// you’ll need to connect to the “notify::scroll-offset” signal to track this.
// Remember when using the Layout functions you need to convert to and from
// pixels using PANGO_PIXELS() or NGO_SCALE.
// 
// Keep in mind that the layout text may contain a preedit string, so
// gtk_entry_layout_index_to_text_index() and
// gtk_entry_text_index_to_layout_index() are needed to convert byte indices in
// the layout to byte indices in the entry contents.
	func (e Entry) LayoutOffsets() (x int, y int) {
var _arg0 *C.GtkEntry // out
var _arg1 C.gint // in
var _arg2 C.gint // in

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

C.gtk_entry_get_layout_offsets(_arg0, &_arg1, &_arg2)

var _x int // out
var _y int // out

_x = (int)(_arg1)
_y = (int)(_arg2)

return _x, _y
}
	
	// MaxLength retrieves the maximum allowed length of the text in @entry. See
// gtk_entry_set_max_length().
// 
// This is equivalent to getting @entry's EntryBuffer and calling
// gtk_entry_buffer_get_max_length() on it.
	func (e Entry) MaxLength() int {
var _arg0 *C.GtkEntry // out
var _cret C.gint // in

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

_cret = C.gtk_entry_get_max_length(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// MaxWidthChars retrieves the desired maximum width of @entry, in characters.
// See gtk_entry_set_max_width_chars().
	func (e Entry) MaxWidthChars() int {
var _arg0 *C.GtkEntry // out
var _cret C.gint // in

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

_cret = C.gtk_entry_get_max_width_chars(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// OverwriteMode gets the value set by gtk_entry_set_overwrite_mode().
	func (e Entry) OverwriteMode() bool {
var _arg0 *C.GtkEntry // out
var _cret C.gboolean // in

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

_cret = C.gtk_entry_get_overwrite_mode(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// PlaceholderText retrieves the text that will be displayed when @entry is
// empty and unfocused
	func (e Entry) PlaceholderText() string {
var _arg0 *C.GtkEntry // out
var _cret *C.gchar // in

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

_cret = C.gtk_entry_get_placeholder_text(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// ProgressFraction returns the current fraction of the task that’s been
// completed. See gtk_entry_set_progress_fraction().
	func (e Entry) ProgressFraction() float64 {
var _arg0 *C.GtkEntry // out
var _cret C.gdouble // in

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

_cret = C.gtk_entry_get_progress_fraction(_arg0)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// ProgressPulseStep retrieves the pulse step set with
// gtk_entry_set_progress_pulse_step().
	func (e Entry) ProgressPulseStep() float64 {
var _arg0 *C.GtkEntry // out
var _cret C.gdouble // in

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

_cret = C.gtk_entry_get_progress_pulse_step(_arg0)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// Tabs gets the tabstops that were set on the entry using gtk_entry_set_tabs(),
// if any.
	func (e Entry) Tabs() *pango.TabArray {
var _arg0 *C.GtkEntry // out
var _cret *C.PangoTabArray // in

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

_cret = C.gtk_entry_get_tabs(_arg0)


var _tabArray *pango.TabArray // out

_tabArray = *(**pango.TabArray)(unsafe.Pointer(&_cret))

return _tabArray
}
	
	// Text retrieves the contents of the entry widget. See also
// gtk_editable_get_chars().
// 
// This is equivalent to getting @entry's EntryBuffer and calling
// gtk_entry_buffer_get_text() on it.
	func (e Entry) Text() string {
var _arg0 *C.GtkEntry // out
var _cret *C.gchar // in

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

_cret = C.gtk_entry_get_text(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// TextArea gets the area where the entry’s text is drawn. This function is
// useful when drawing something to the entry in a draw callback.
// 
// If the entry is not realized, @text_area is filled with zeros.
// 
// See also gtk_entry_get_icon_area().
	func (e Entry) TextArea() gdk.Rectangle {
var _arg0 *C.GtkEntry // out
var _textArea gdk.Rectangle

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

C.gtk_entry_get_text_area(_arg0, (*C.GdkRectangle)(unsafe.Pointer(&_textArea)))





return _textArea
}
	
	// TextLength retrieves the current length of the text in @entry.
// 
// This is equivalent to getting @entry's EntryBuffer and calling
// gtk_entry_buffer_get_length() on it.
	func (e Entry) TextLength() uint16 {
var _arg0 *C.GtkEntry // out
var _cret C.guint16 // in

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

_cret = C.gtk_entry_get_text_length(_arg0)


var _guint16 uint16 // out

_guint16 = (uint16)(_cret)

return _guint16
}
	
	// Visibility retrieves whether the text in @entry is visible. See
// gtk_entry_set_visibility().
	func (e Entry) Visibility() bool {
var _arg0 *C.GtkEntry // out
var _cret C.gboolean // in

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

_cret = C.gtk_entry_get_visibility(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// WidthChars gets the value set by gtk_entry_set_width_chars().
	func (e Entry) WidthChars() int {
var _arg0 *C.GtkEntry // out
var _cret C.gint // in

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

_cret = C.gtk_entry_get_width_chars(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// GrabFocusWithoutSelecting causes @entry to have keyboard focus.
// 
// It behaves like gtk_widget_grab_focus(), except that it doesn't select the
// contents of the entry. You only want to call this on some special entries
// which the user usually doesn't want to replace all text in, such as
// search-as-you-type entries.
	func (e Entry) GrabFocusWithoutSelecting()  {
var _arg0 *C.GtkEntry // out

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

C.gtk_entry_grab_focus_without_selecting(_arg0)
}
	
	// ImContextFilterKeypress: allow the Entry input method to internally handle
// key press and release events. If this function returns true, then no further
// processing should be done for this key event. See
// gtk_im_context_filter_keypress().
// 
// Note that you are expected to call this function from your handler when
// overriding key event handling. This is needed in the case when you need to
// insert your own key handling between the input method and the default key
// event handling of the Entry. See gtk_text_view_reset_im_context() for an
// example of use.
	func (e Entry) ImContextFilterKeypress(event *gdk.EventKey) bool {
var _arg0 *C.GtkEntry // out
var _arg1 *C.GdkEventKey // out
var _cret C.gboolean // in

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
_arg1 = (*C.GdkEventKey)(unsafe.Pointer(event.Native()))

_cret = C.gtk_entry_im_context_filter_keypress(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// LayoutIndexToTextIndex converts from a position in the entry’s Layout
// (returned by gtk_entry_get_layout()) to a position in the entry contents
// (returned by gtk_entry_get_text()).
	func (e Entry) LayoutIndexToTextIndex(layoutIndex int) int {
var _arg0 *C.GtkEntry // out
var _arg1 C.gint // out
var _cret C.gint // in

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
_arg1 = (C.gint)(layoutIndex)

_cret = C.gtk_entry_layout_index_to_text_index(_arg0, _arg1)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// ProgressPulse indicates that some progress is made, but you don’t know how
// much. Causes the entry’s progress indicator to enter “activity mode,” where a
// block bounces back and forth. Each call to gtk_entry_progress_pulse() causes
// the block to move by a little bit (the amount of movement per pulse is
// determined by gtk_entry_set_progress_pulse_step()).
	func (e Entry) ProgressPulse()  {
var _arg0 *C.GtkEntry // out

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

C.gtk_entry_progress_pulse(_arg0)
}
	
	// ResetImContext: reset the input method context of the entry if needed.
// 
// This can be necessary in the case where modifying the buffer would confuse
// on-going input method behavior.
	func (e Entry) ResetImContext()  {
var _arg0 *C.GtkEntry // out

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

C.gtk_entry_reset_im_context(_arg0)
}
	
	// SetActivatesDefault: if @setting is true, pressing Enter in the @entry will
// activate the default widget for the window containing the entry. This usually
// means that the dialog box containing the entry will be closed, since the
// default widget is usually one of the dialog buttons.
// 
// (For experts: if @setting is true, the entry calls
// gtk_window_activate_default() on the window containing the entry, in the
// default handler for the Entry::activate signal.)
	func (e Entry) SetActivatesDefault(setting bool)  {
var _arg0 *C.GtkEntry // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
if setting { _arg1 = C.TRUE }

C.gtk_entry_set_activates_default(_arg0, _arg1)
}
	
	// SetAlignment sets the alignment for the contents of the entry. This controls
// the horizontal positioning of the contents when the displayed text is shorter
// than the width of the entry.
	func (e Entry) SetAlignment(xalign float32)  {
var _arg0 *C.GtkEntry // out
var _arg1 C.gfloat // out

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
_arg1 = (C.gfloat)(xalign)

C.gtk_entry_set_alignment(_arg0, _arg1)
}
	
	// SetAttributes sets a AttrList; the attributes in the list are applied to the
// entry text.
	func (e Entry) SetAttributes(attrs *pango.AttrList)  {
var _arg0 *C.GtkEntry // out
var _arg1 *C.PangoAttrList // out

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
_arg1 = (*C.PangoAttrList)(unsafe.Pointer(attrs.Native()))

C.gtk_entry_set_attributes(_arg0, _arg1)
}
	
	// SetBuffer: set the EntryBuffer object which holds the text for this widget.
	func (e Entry) SetBuffer(buffer EntryBufferClass)  {
var _arg0 *C.GtkEntry // out
var _arg1 *C.GtkEntryBuffer // out

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
_arg1 = (*C.GtkEntryBuffer)(unsafe.Pointer(buffer.Native()))

C.gtk_entry_set_buffer(_arg0, _arg1)
}
	
	// SetCompletion sets @completion to be the auxiliary completion object to use
// with @entry. All further configuration of the completion mechanism is done on
// @completion using the EntryCompletion API. Completion is disabled if
// @completion is set to nil.
	func (e Entry) SetCompletion(completion EntryCompletionClass)  {
var _arg0 *C.GtkEntry // out
var _arg1 *C.GtkEntryCompletion // out

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
_arg1 = (*C.GtkEntryCompletion)(unsafe.Pointer(completion.Native()))

C.gtk_entry_set_completion(_arg0, _arg1)
}
	
	// SetCursorHAdjustment hooks up an adjustment to the cursor position in an
// entry, so that when the cursor is moved, the adjustment is scrolled to show
// that position. See gtk_scrolled_window_get_hadjustment() for a typical way of
// obtaining the adjustment.
// 
// The adjustment has to be in pixel units and in the same coordinate system as
// the entry.
	func (e Entry) SetCursorHAdjustment(adjustment AdjustmentClass)  {
var _arg0 *C.GtkEntry // out
var _arg1 *C.GtkAdjustment // out

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(adjustment.Native()))

C.gtk_entry_set_cursor_hadjustment(_arg0, _arg1)
}
	
	// SetHasFrame sets whether the entry has a beveled frame around it.
	func (e Entry) SetHasFrame(setting bool)  {
var _arg0 *C.GtkEntry // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
if setting { _arg1 = C.TRUE }

C.gtk_entry_set_has_frame(_arg0, _arg1)
}
	
	// SetIconActivatable sets whether the icon is activatable.
	func (e Entry) SetIconActivatable(iconPos EntryIconPosition, activatable bool)  {
var _arg0 *C.GtkEntry // out
var _arg1 C.GtkEntryIconPosition // out
var _arg2 C.gboolean // out

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
_arg1 = (C.GtkEntryIconPosition)(iconPos)
if activatable { _arg2 = C.TRUE }

C.gtk_entry_set_icon_activatable(_arg0, _arg1, _arg2)
}
	
	// SetIconDragSource sets up the icon at the given position so that GTK+ will
// start a drag operation when the user clicks and drags the icon.
// 
// To handle the drag operation, you need to connect to the usual
// Widget::drag-data-get (or possibly Widget::drag-data-delete) signal, and use
// gtk_entry_get_current_icon_drag_source() in your signal handler to find out
// if the drag was started from an icon.
// 
// By default, GTK+ uses the icon as the drag icon. You can use the
// Widget::drag-begin signal to set a different icon. Note that you have to use
// g_signal_connect_after() to ensure that your signal handler gets executed
// after the default handler.
	func (e Entry) SetIconDragSource(iconPos EntryIconPosition, targetList *TargetList, actions gdk.DragAction)  {
var _arg0 *C.GtkEntry // out
var _arg1 C.GtkEntryIconPosition // out
var _arg2 *C.GtkTargetList // out
var _arg3 C.GdkDragAction // out

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
_arg1 = (C.GtkEntryIconPosition)(iconPos)
_arg2 = (*C.GtkTargetList)(unsafe.Pointer(targetList.Native()))
_arg3 = (C.GdkDragAction)(actions)

C.gtk_entry_set_icon_drag_source(_arg0, _arg1, _arg2, _arg3)
}
	
	// SetIconFromGIcon sets the icon shown in the entry at the specified position
// from the current icon theme. If the icon isn’t known, a “broken image” icon
// will be displayed instead.
// 
// If @icon is nil, no icon will be shown in the specified position.
	func (e Entry) SetIconFromGIcon(iconPos EntryIconPosition, icon gio.Icon)  {
var _arg0 *C.GtkEntry // out
var _arg1 C.GtkEntryIconPosition // out
var _arg2 *C.GIcon // out

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
_arg1 = (C.GtkEntryIconPosition)(iconPos)
_arg2 = (*C.GIcon)(unsafe.Pointer(icon.Native()))

C.gtk_entry_set_icon_from_gicon(_arg0, _arg1, _arg2)
}
	
	// SetIconFromIconName sets the icon shown in the entry at the specified
// position from the current icon theme.
// 
// If the icon name isn’t known, a “broken image” icon will be displayed
// instead.
// 
// If @icon_name is nil, no icon will be shown in the specified position.
	func (e Entry) SetIconFromIconName(iconPos EntryIconPosition, iconName string)  {
var _arg0 *C.GtkEntry // out
var _arg1 C.GtkEntryIconPosition // out
var _arg2 *C.gchar // out

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
_arg1 = (C.GtkEntryIconPosition)(iconPos)
_arg2 = (*C.gchar)(C.CString(iconName))
defer C.free(unsafe.Pointer(_arg2))

C.gtk_entry_set_icon_from_icon_name(_arg0, _arg1, _arg2)
}
	
	// SetIconFromPixbuf sets the icon shown in the specified position using a
// pixbuf.
// 
// If @pixbuf is nil, no icon will be shown in the specified position.
	func (e Entry) SetIconFromPixbuf(iconPos EntryIconPosition, pixbuf gdkpixbuf.PixbufClass)  {
var _arg0 *C.GtkEntry // out
var _arg1 C.GtkEntryIconPosition // out
var _arg2 *C.GdkPixbuf // out

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
_arg1 = (C.GtkEntryIconPosition)(iconPos)
_arg2 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))

C.gtk_entry_set_icon_from_pixbuf(_arg0, _arg1, _arg2)
}
	
	// SetIconFromStock sets the icon shown in the entry at the specified position
// from a stock image.
// 
// If @stock_id is nil, no icon will be shown in the specified position.
	func (e Entry) SetIconFromStock(iconPos EntryIconPosition, stockId string)  {
var _arg0 *C.GtkEntry // out
var _arg1 C.GtkEntryIconPosition // out
var _arg2 *C.gchar // out

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
_arg1 = (C.GtkEntryIconPosition)(iconPos)
_arg2 = (*C.gchar)(C.CString(stockId))
defer C.free(unsafe.Pointer(_arg2))

C.gtk_entry_set_icon_from_stock(_arg0, _arg1, _arg2)
}
	
	// SetIconSensitive sets the sensitivity for the specified icon.
	func (e Entry) SetIconSensitive(iconPos EntryIconPosition, sensitive bool)  {
var _arg0 *C.GtkEntry // out
var _arg1 C.GtkEntryIconPosition // out
var _arg2 C.gboolean // out

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
_arg1 = (C.GtkEntryIconPosition)(iconPos)
if sensitive { _arg2 = C.TRUE }

C.gtk_entry_set_icon_sensitive(_arg0, _arg1, _arg2)
}
	
	// SetIconTooltipMarkup sets @tooltip as the contents of the tooltip for the
// icon at the specified position. @tooltip is assumed to be marked up with the
// [Pango text markup language][PangoMarkupFormat].
// 
// Use nil for @tooltip to remove an existing tooltip.
// 
// See also gtk_widget_set_tooltip_markup() and
// gtk_entry_set_icon_tooltip_text().
	func (e Entry) SetIconTooltipMarkup(iconPos EntryIconPosition, tooltip string)  {
var _arg0 *C.GtkEntry // out
var _arg1 C.GtkEntryIconPosition // out
var _arg2 *C.gchar // out

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
_arg1 = (C.GtkEntryIconPosition)(iconPos)
_arg2 = (*C.gchar)(C.CString(tooltip))
defer C.free(unsafe.Pointer(_arg2))

C.gtk_entry_set_icon_tooltip_markup(_arg0, _arg1, _arg2)
}
	
	// SetIconTooltipText sets @tooltip as the contents of the tooltip for the icon
// at the specified position.
// 
// Use nil for @tooltip to remove an existing tooltip.
// 
// See also gtk_widget_set_tooltip_text() and
// gtk_entry_set_icon_tooltip_markup().
// 
// If you unset the widget tooltip via gtk_widget_set_tooltip_text() or
// gtk_widget_set_tooltip_markup(), this sets GtkWidget:has-tooltip to false,
// which suppresses icon tooltips too. You can resolve this by then calling
// gtk_widget_set_has_tooltip() to set GtkWidget:has-tooltip back to true, or
// setting at least one non-empty tooltip on any icon achieves the same result.
	func (e Entry) SetIconTooltipText(iconPos EntryIconPosition, tooltip string)  {
var _arg0 *C.GtkEntry // out
var _arg1 C.GtkEntryIconPosition // out
var _arg2 *C.gchar // out

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
_arg1 = (C.GtkEntryIconPosition)(iconPos)
_arg2 = (*C.gchar)(C.CString(tooltip))
defer C.free(unsafe.Pointer(_arg2))

C.gtk_entry_set_icon_tooltip_text(_arg0, _arg1, _arg2)
}
	
	// SetInnerBorder sets entry’s inner-border property to @border, or clears it if
// nil is passed. The inner-border is the area around the entry’s text, but
// inside its frame.
// 
// If set, this property overrides the inner-border style property. Overriding
// the style-provided border is useful when you want to do in-place editing of
// some text in a canvas or list widget, where pixel-exact positioning of the
// entry is important.
	func (e Entry) SetInnerBorder(border *Border)  {
var _arg0 *C.GtkEntry // out
var _arg1 *C.GtkBorder // out

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
_arg1 = (*C.GtkBorder)(unsafe.Pointer(border.Native()))

C.gtk_entry_set_inner_border(_arg0, _arg1)
}
	
	// SetInputHints sets the Entry:input-hints property, which allows input methods
// to fine-tune their behaviour.
	func (e Entry) SetInputHints(hints InputHints)  {
var _arg0 *C.GtkEntry // out
var _arg1 C.GtkInputHints // out

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
_arg1 = (C.GtkInputHints)(hints)

C.gtk_entry_set_input_hints(_arg0, _arg1)
}
	
	// SetInputPurpose sets the Entry:input-purpose property which can be used by
// on-screen keyboards and other input methods to adjust their behaviour.
	func (e Entry) SetInputPurpose(purpose InputPurpose)  {
var _arg0 *C.GtkEntry // out
var _arg1 C.GtkInputPurpose // out

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
_arg1 = (C.GtkInputPurpose)(purpose)

C.gtk_entry_set_input_purpose(_arg0, _arg1)
}
	
	// SetInvisibleChar sets the character to use in place of the actual text when
// gtk_entry_set_visibility() has been called to set text visibility to false.
// i.e. this is the character used in “password mode” to show the user how many
// characters have been typed. By default, GTK+ picks the best invisible char
// available in the current font. If you set the invisible char to 0, then the
// user will get no feedback at all; there will be no text on the screen as they
// type.
	func (e Entry) SetInvisibleChar(ch uint32)  {
var _arg0 *C.GtkEntry // out
var _arg1 C.gunichar // out

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
_arg1 = (C.gunichar)(ch)

C.gtk_entry_set_invisible_char(_arg0, _arg1)
}
	
	// SetMaxLength sets the maximum allowed length of the contents of the widget.
// If the current contents are longer than the given length, then they will be
// truncated to fit.
// 
// This is equivalent to getting @entry's EntryBuffer and calling
// gtk_entry_buffer_set_max_length() on it. ]|
	func (e Entry) SetMaxLength(max int)  {
var _arg0 *C.GtkEntry // out
var _arg1 C.gint // out

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
_arg1 = (C.gint)(max)

C.gtk_entry_set_max_length(_arg0, _arg1)
}
	
	// SetMaxWidthChars sets the desired maximum width in characters of @entry.
	func (e Entry) SetMaxWidthChars(nChars int)  {
var _arg0 *C.GtkEntry // out
var _arg1 C.gint // out

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
_arg1 = (C.gint)(nChars)

C.gtk_entry_set_max_width_chars(_arg0, _arg1)
}
	
	// SetOverwriteMode sets whether the text is overwritten when typing in the
// Entry.
	func (e Entry) SetOverwriteMode(overwrite bool)  {
var _arg0 *C.GtkEntry // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
if overwrite { _arg1 = C.TRUE }

C.gtk_entry_set_overwrite_mode(_arg0, _arg1)
}
	
	// SetPlaceholderText sets text to be displayed in @entry when it is empty and
// unfocused. This can be used to give a visual hint of the expected contents of
// the Entry.
// 
// Note that since the placeholder text gets removed when the entry received
// focus, using this feature is a bit problematic if the entry is given the
// initial focus in a window. Sometimes this can be worked around by delaying
// the initial focus setting until the first key event arrives.
	func (e Entry) SetPlaceholderText(text string)  {
var _arg0 *C.GtkEntry // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
_arg1 = (*C.gchar)(C.CString(text))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_entry_set_placeholder_text(_arg0, _arg1)
}
	
	// SetProgressFraction causes the entry’s progress indicator to “fill in” the
// given fraction of the bar. The fraction should be between 0.0 and 1.0,
// inclusive.
	func (e Entry) SetProgressFraction(fraction float64)  {
var _arg0 *C.GtkEntry // out
var _arg1 C.gdouble // out

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
_arg1 = (C.gdouble)(fraction)

C.gtk_entry_set_progress_fraction(_arg0, _arg1)
}
	
	// SetProgressPulseStep sets the fraction of total entry width to move the
// progress bouncing block for each call to gtk_entry_progress_pulse().
	func (e Entry) SetProgressPulseStep(fraction float64)  {
var _arg0 *C.GtkEntry // out
var _arg1 C.gdouble // out

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
_arg1 = (C.gdouble)(fraction)

C.gtk_entry_set_progress_pulse_step(_arg0, _arg1)
}
	
	// SetTabs sets a TabArray; the tabstops in the array are applied to the entry
// text.
	func (e Entry) SetTabs(tabs *pango.TabArray)  {
var _arg0 *C.GtkEntry // out
var _arg1 *C.PangoTabArray // out

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
_arg1 = (*C.PangoTabArray)(unsafe.Pointer(tabs.Native()))

C.gtk_entry_set_tabs(_arg0, _arg1)
}
	
	// SetText sets the text in the widget to the given value, replacing the current
// contents.
// 
// See gtk_entry_buffer_set_text().
	func (e Entry) SetText(text string)  {
var _arg0 *C.GtkEntry // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
_arg1 = (*C.gchar)(C.CString(text))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_entry_set_text(_arg0, _arg1)
}
	
	// SetVisibility sets whether the contents of the entry are visible or not. When
// visibility is set to false, characters are displayed as the invisible char,
// and will also appear that way when the text in the entry widget is copied
// elsewhere.
// 
// By default, GTK+ picks the best invisible character available in the current
// font, but it can be changed with gtk_entry_set_invisible_char().
// 
// Note that you probably want to set Entry:input-purpose to
// GTK_INPUT_PURPOSE_PASSWORD or GTK_INPUT_PURPOSE_PIN to inform input methods
// about the purpose of this entry, in addition to setting visibility to false.
	func (e Entry) SetVisibility(visible bool)  {
var _arg0 *C.GtkEntry // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
if visible { _arg1 = C.TRUE }

C.gtk_entry_set_visibility(_arg0, _arg1)
}
	
	// SetWidthChars changes the size request of the entry to be about the right
// size for @n_chars characters. Note that it changes the size request, the size
// can still be affected by how you pack the widget into containers. If @n_chars
// is -1, the size reverts to the default entry size.
	func (e Entry) SetWidthChars(nChars int)  {
var _arg0 *C.GtkEntry // out
var _arg1 C.gint // out

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
_arg1 = (C.gint)(nChars)

C.gtk_entry_set_width_chars(_arg0, _arg1)
}
	
	// TextIndexToLayoutIndex converts from a position in the entry contents
// (returned by gtk_entry_get_text()) to a position in the entry’s Layout
// (returned by gtk_entry_get_layout(), with text retrieved via
// pango_layout_get_text()).
	func (e Entry) TextIndexToLayoutIndex(textIndex int) int {
var _arg0 *C.GtkEntry // out
var _arg1 C.gint // out
var _cret C.gint // in

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
_arg1 = (C.gint)(textIndex)

_cret = C.gtk_entry_text_index_to_layout_index(_arg0, _arg1)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// UnsetInvisibleChar unsets the invisible char previously set with
// gtk_entry_set_invisible_char(). So that the default invisible char is used
// again.
	func (e Entry) UnsetInvisibleChar()  {
var _arg0 *C.GtkEntry // out

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

C.gtk_entry_unset_invisible_char(_arg0)
}
	


	// EntryBuffer: the EntryBuffer class contains the actual text displayed in a
// Entry widget.
// 
// A single EntryBuffer object can be shared by multiple Entry widgets which
// will then share the same text content, but not the cursor position,
// visibility attributes, icon etc.
// 
// EntryBuffer may be derived from. Such a derived class might allow text to be
// stored in an alternate location, such as non-pageable memory, useful in the
// case of important passwords. Or a derived class could integrate with an
// application’s concept of undo/redo.
	type EntryBuffer struct {
		**externglib.Object
		
	}

	// EntryBufferClass is an interface that the EntryBuffer class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type EntryBufferClass interface {
		gextras.Objector
		_entryBuffer()
	}

	func (EntryBuffer) _entryBuffer() {}

	
	func marshalEntryBuffer(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapEntryBuffer(obj), nil
	}
	

	
	// NewEntryBuffer: create a new GtkEntryBuffer object.
// 
// Optionally, specify initial text to set in the buffer.
	func NewEntryBuffer(initialChars string, nInitialChars int) EntryBuffer {
var _arg1 *C.gchar // out
var _arg2 C.gint // out
var _cret *C.GtkEntryBuffer // in

_arg1 = (*C.gchar)(C.CString(initialChars))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.gint)(nInitialChars)

_cret = C.gtk_entry_buffer_new(_arg1, _arg2)


var _entryBuffer EntryBuffer // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_entryBuffer = EntryBuffer{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}

return _entryBuffer
}
	

	
	// DeleteText deletes a sequence of characters from the buffer. @n_chars
// characters are deleted starting at @position. If @n_chars is negative, then
// all characters until the end of the text are deleted.
// 
// If @position or @n_chars are out of bounds, then they are coerced to sane
// values.
// 
// Note that the positions are specified in characters, not bytes.
	func (b EntryBuffer) DeleteText(position uint, nChars int) uint {
var _arg0 *C.GtkEntryBuffer // out
var _arg1 C.guint // out
var _arg2 C.gint // out
var _cret C.guint // in

_arg0 = (*C.GtkEntryBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (C.guint)(position)
_arg2 = (C.gint)(nChars)

_cret = C.gtk_entry_buffer_delete_text(_arg0, _arg1, _arg2)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// EmitDeletedText: used when subclassing EntryBuffer
	func (b EntryBuffer) EmitDeletedText(position uint, nChars uint)  {
var _arg0 *C.GtkEntryBuffer // out
var _arg1 C.guint // out
var _arg2 C.guint // out

_arg0 = (*C.GtkEntryBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (C.guint)(position)
_arg2 = (C.guint)(nChars)

C.gtk_entry_buffer_emit_deleted_text(_arg0, _arg1, _arg2)
}
	
	// EmitInsertedText: used when subclassing EntryBuffer
	func (b EntryBuffer) EmitInsertedText(position uint, chars string, nChars uint)  {
var _arg0 *C.GtkEntryBuffer // out
var _arg1 C.guint // out
var _arg2 *C.gchar // out
var _arg3 C.guint // out

_arg0 = (*C.GtkEntryBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (C.guint)(position)
_arg2 = (*C.gchar)(C.CString(chars))
defer C.free(unsafe.Pointer(_arg2))
_arg3 = (C.guint)(nChars)

C.gtk_entry_buffer_emit_inserted_text(_arg0, _arg1, _arg2, _arg3)
}
	
	// Bytes retrieves the length in bytes of the buffer. See
// gtk_entry_buffer_get_length().
	func (b EntryBuffer) Bytes() uint {
var _arg0 *C.GtkEntryBuffer // out
var _cret C.gsize // in

_arg0 = (*C.GtkEntryBuffer)(unsafe.Pointer(b.Native()))

_cret = C.gtk_entry_buffer_get_bytes(_arg0)


var _gsize uint // out

_gsize = (uint)(_cret)

return _gsize
}
	
	// Length retrieves the length in characters of the buffer.
	func (b EntryBuffer) Length() uint {
var _arg0 *C.GtkEntryBuffer // out
var _cret C.guint // in

_arg0 = (*C.GtkEntryBuffer)(unsafe.Pointer(b.Native()))

_cret = C.gtk_entry_buffer_get_length(_arg0)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// MaxLength retrieves the maximum allowed length of the text in @buffer. See
// gtk_entry_buffer_set_max_length().
	func (b EntryBuffer) MaxLength() int {
var _arg0 *C.GtkEntryBuffer // out
var _cret C.gint // in

_arg0 = (*C.GtkEntryBuffer)(unsafe.Pointer(b.Native()))

_cret = C.gtk_entry_buffer_get_max_length(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Text retrieves the contents of the buffer.
// 
// The memory pointer returned by this call will not change unless this object
// emits a signal, or is finalized.
	func (b EntryBuffer) Text() string {
var _arg0 *C.GtkEntryBuffer // out
var _cret *C.gchar // in

_arg0 = (*C.GtkEntryBuffer)(unsafe.Pointer(b.Native()))

_cret = C.gtk_entry_buffer_get_text(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// InsertText inserts @n_chars characters of @chars into the contents of the
// buffer, at position @position.
// 
// If @n_chars is negative, then characters from chars will be inserted until a
// null-terminator is found. If @position or @n_chars are out of bounds, or the
// maximum buffer text length is exceeded, then they are coerced to sane values.
// 
// Note that the position and length are in characters, not in bytes.
	func (b EntryBuffer) InsertText(position uint, chars string, nChars int) uint {
var _arg0 *C.GtkEntryBuffer // out
var _arg1 C.guint // out
var _arg2 *C.gchar // out
var _arg3 C.gint // out
var _cret C.guint // in

_arg0 = (*C.GtkEntryBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (C.guint)(position)
_arg2 = (*C.gchar)(C.CString(chars))
defer C.free(unsafe.Pointer(_arg2))
_arg3 = (C.gint)(nChars)

_cret = C.gtk_entry_buffer_insert_text(_arg0, _arg1, _arg2, _arg3)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// SetMaxLength sets the maximum allowed length of the contents of the buffer.
// If the current contents are longer than the given length, then they will be
// truncated to fit.
	func (b EntryBuffer) SetMaxLength(maxLength int)  {
var _arg0 *C.GtkEntryBuffer // out
var _arg1 C.gint // out

_arg0 = (*C.GtkEntryBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (C.gint)(maxLength)

C.gtk_entry_buffer_set_max_length(_arg0, _arg1)
}
	
	// SetText sets the text in the buffer.
// 
// This is roughly equivalent to calling gtk_entry_buffer_delete_text() and
// gtk_entry_buffer_insert_text().
// 
// Note that @n_chars is in characters, not in bytes.
	func (b EntryBuffer) SetText(chars string, nChars int)  {
var _arg0 *C.GtkEntryBuffer // out
var _arg1 *C.gchar // out
var _arg2 C.gint // out

_arg0 = (*C.GtkEntryBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (*C.gchar)(C.CString(chars))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.gint)(nChars)

C.gtk_entry_buffer_set_text(_arg0, _arg1, _arg2)
}
	


	// EntryCompletion is an auxiliary object to be used in conjunction with Entry
// to provide the completion functionality. It implements the CellLayout
// interface, to allow the user to add extra cells to the TreeView with
// completion matches.
// 
// “Completion functionality” means that when the user modifies the text in the
// entry, EntryCompletion checks which rows in the model match the current
// content of the entry, and displays a list of matches. By default, the
// matching is done by comparing the entry text case-insensitively against the
// text column of the model (see gtk_entry_completion_set_text_column()), but
// this can be overridden with a custom match function (see
// gtk_entry_completion_set_match_func()).
// 
// When the user selects a completion, the content of the entry is updated. By
// default, the content of the entry is replaced by the text column of the
// model, but this can be overridden by connecting to the
// EntryCompletion::match-selected signal and updating the entry in the signal
// handler. Note that you should return true from the signal handler to suppress
// the default behaviour.
// 
// To add completion functionality to an entry, use gtk_entry_set_completion().
// 
// In addition to regular completion matches, which will be inserted into the
// entry when they are selected, EntryCompletion also allows to display
// “actions” in the popup window. Their appearance is similar to menuitems, to
// differentiate them clearly from completion strings. When an action is
// selected, the EntryCompletion::action-activated signal is emitted.
// 
// GtkEntryCompletion uses a TreeModelFilter model to represent the subset of
// the entire model that is currently matching. While the GtkEntryCompletion
// signals EntryCompletion::match-selected and EntryCompletion::cursor-on-match
// take the original model and an iter pointing to that model as arguments,
// other callbacks and signals (such as CellLayoutDataFuncs or
// CellArea::apply-attributes) will generally take the filter model as argument.
// As long as you are only calling gtk_tree_model_get(), this will make no
// difference to you. If for some reason, you need the original model, use
// gtk_tree_model_filter_get_model(). Don’t forget to use
// gtk_tree_model_filter_convert_iter_to_child_iter() to obtain a matching iter.
	type EntryCompletion struct {
		**externglib.Object
		Buildable
		CellLayout
		
	}

	// EntryCompletionClass is an interface that the EntryCompletion class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type EntryCompletionClass interface {
		gextras.Objector
		_entryCompletion()
	}

	func (EntryCompletion) _entryCompletion() {}

	
	func marshalEntryCompletion(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapEntryCompletion(obj), nil
	}
	

	
	// NewEntryCompletion creates a new EntryCompletion object.
	func NewEntryCompletion() EntryCompletion {
var _cret *C.GtkEntryCompletion // in

_cret = C.gtk_entry_completion_new()


var _entryCompletion EntryCompletion // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_entryCompletion = EntryCompletion{
Object: &externglib.Object{externglib.ToGObject(obj)},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
CellLayout: CellLayout{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _entryCompletion
}
	
	// NewEntryCompletionWithArea creates a new EntryCompletion object using the
// specified @area to layout cells in the underlying TreeViewColumn for the
// drop-down menu.
	func NewEntryCompletionWithArea(area CellAreaClass) EntryCompletion {
var _arg1 *C.GtkCellArea // out
var _cret *C.GtkEntryCompletion // in

_arg1 = (*C.GtkCellArea)(unsafe.Pointer(area.Native()))

_cret = C.gtk_entry_completion_new_with_area(_arg1)


var _entryCompletion EntryCompletion // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_entryCompletion = EntryCompletion{
Object: &externglib.Object{externglib.ToGObject(obj)},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
CellLayout: CellLayout{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _entryCompletion
}
	

	
	// Complete requests a completion operation, or in other words a refiltering of
// the current list with completions, using the current key. The completion list
// view will be updated accordingly.
	func (c EntryCompletion) Complete()  {
var _arg0 *C.GtkEntryCompletion // out

_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))

C.gtk_entry_completion_complete(_arg0)
}
	
	// ComputePrefix computes the common prefix that is shared by all rows in
// @completion that start with @key. If no row matches @key, nil will be
// returned. Note that a text column must have been set for this function to
// work, see gtk_entry_completion_set_text_column() for details.
	func (c EntryCompletion) ComputePrefix(key string) string {
var _arg0 *C.GtkEntryCompletion // out
var _arg1 *C.char // out
var _cret *C.gchar // in

_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))
_arg1 = (*C.char)(C.CString(key))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_entry_completion_compute_prefix(_arg0, _arg1)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// DeleteAction deletes the action at @index_ from @completion’s action list.
// 
// Note that @index_ is a relative position and the position of an action may
// have changed since it was inserted.
	func (c EntryCompletion) DeleteAction(index_ int)  {
var _arg0 *C.GtkEntryCompletion // out
var _arg1 C.gint // out

_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))
_arg1 = (C.gint)(index_)

C.gtk_entry_completion_delete_action(_arg0, _arg1)
}
	
	// CompletionPrefix: get the original text entered by the user that triggered
// the completion or nil if there’s no completion ongoing.
	func (c EntryCompletion) CompletionPrefix() string {
var _arg0 *C.GtkEntryCompletion // out
var _cret *C.gchar // in

_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))

_cret = C.gtk_entry_completion_get_completion_prefix(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Entry gets the entry @completion has been attached to.
	func (c EntryCompletion) Entry() Widget {
var _arg0 *C.GtkEntryCompletion // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))

_cret = C.gtk_entry_completion_get_entry(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// InlineCompletion returns whether the common prefix of the possible
// completions should be automatically inserted in the entry.
	func (c EntryCompletion) InlineCompletion() bool {
var _arg0 *C.GtkEntryCompletion // out
var _cret C.gboolean // in

_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))

_cret = C.gtk_entry_completion_get_inline_completion(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// InlineSelection returns true if inline-selection mode is turned on.
	func (c EntryCompletion) InlineSelection() bool {
var _arg0 *C.GtkEntryCompletion // out
var _cret C.gboolean // in

_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))

_cret = C.gtk_entry_completion_get_inline_selection(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// MinimumKeyLength returns the minimum key length as set for @completion.
	func (c EntryCompletion) MinimumKeyLength() int {
var _arg0 *C.GtkEntryCompletion // out
var _cret C.gint // in

_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))

_cret = C.gtk_entry_completion_get_minimum_key_length(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Model returns the model the EntryCompletion is using as data source. Returns
// nil if the model is unset.
	func (c EntryCompletion) Model() TreeModel {
var _arg0 *C.GtkEntryCompletion // out
var _cret *C.GtkTreeModel // in

_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))

_cret = C.gtk_entry_completion_get_model(_arg0)


var _treeModel TreeModel // out

_treeModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TreeModel)

return _treeModel
}
	
	// PopupCompletion returns whether the completions should be presented in a
// popup window.
	func (c EntryCompletion) PopupCompletion() bool {
var _arg0 *C.GtkEntryCompletion // out
var _cret C.gboolean // in

_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))

_cret = C.gtk_entry_completion_get_popup_completion(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// PopupSetWidth returns whether the completion popup window will be resized to
// the width of the entry.
	func (c EntryCompletion) PopupSetWidth() bool {
var _arg0 *C.GtkEntryCompletion // out
var _cret C.gboolean // in

_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))

_cret = C.gtk_entry_completion_get_popup_set_width(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// PopupSingleMatch returns whether the completion popup window will appear even
// if there is only a single match.
	func (c EntryCompletion) PopupSingleMatch() bool {
var _arg0 *C.GtkEntryCompletion // out
var _cret C.gboolean // in

_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))

_cret = C.gtk_entry_completion_get_popup_single_match(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// TextColumn returns the column in the model of @completion to get strings
// from.
	func (c EntryCompletion) TextColumn() int {
var _arg0 *C.GtkEntryCompletion // out
var _cret C.gint // in

_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))

_cret = C.gtk_entry_completion_get_text_column(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// InsertActionMarkup inserts an action in @completion’s action item list at
// position @index_ with markup @markup.
	func (c EntryCompletion) InsertActionMarkup(index_ int, markup string)  {
var _arg0 *C.GtkEntryCompletion // out
var _arg1 C.gint // out
var _arg2 *C.gchar // out

_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))
_arg1 = (C.gint)(index_)
_arg2 = (*C.gchar)(C.CString(markup))
defer C.free(unsafe.Pointer(_arg2))

C.gtk_entry_completion_insert_action_markup(_arg0, _arg1, _arg2)
}
	
	// InsertActionText inserts an action in @completion’s action item list at
// position @index_ with text @text. If you want the action item to have markup,
// use gtk_entry_completion_insert_action_markup().
// 
// Note that @index_ is a relative position in the list of actions and the
// position of an action can change when deleting a different action.
	func (c EntryCompletion) InsertActionText(index_ int, text string)  {
var _arg0 *C.GtkEntryCompletion // out
var _arg1 C.gint // out
var _arg2 *C.gchar // out

_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))
_arg1 = (C.gint)(index_)
_arg2 = (*C.gchar)(C.CString(text))
defer C.free(unsafe.Pointer(_arg2))

C.gtk_entry_completion_insert_action_text(_arg0, _arg1, _arg2)
}
	
	// InsertPrefix requests a prefix insertion.
	func (c EntryCompletion) InsertPrefix()  {
var _arg0 *C.GtkEntryCompletion // out

_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))

C.gtk_entry_completion_insert_prefix(_arg0)
}
	
	// SetInlineCompletion sets whether the common prefix of the possible
// completions should be automatically inserted in the entry.
	func (c EntryCompletion) SetInlineCompletion(inlineCompletion bool)  {
var _arg0 *C.GtkEntryCompletion // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))
if inlineCompletion { _arg1 = C.TRUE }

C.gtk_entry_completion_set_inline_completion(_arg0, _arg1)
}
	
	// SetInlineSelection sets whether it is possible to cycle through the possible
// completions inside the entry.
	func (c EntryCompletion) SetInlineSelection(inlineSelection bool)  {
var _arg0 *C.GtkEntryCompletion // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))
if inlineSelection { _arg1 = C.TRUE }

C.gtk_entry_completion_set_inline_selection(_arg0, _arg1)
}
	
	// SetMinimumKeyLength requires the length of the search key for @completion to
// be at least @length. This is useful for long lists, where completing using a
// small key takes a lot of time and will come up with meaningless results
// anyway (ie, a too large dataset).
	func (c EntryCompletion) SetMinimumKeyLength(length int)  {
var _arg0 *C.GtkEntryCompletion // out
var _arg1 C.gint // out

_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))
_arg1 = (C.gint)(length)

C.gtk_entry_completion_set_minimum_key_length(_arg0, _arg1)
}
	
	// SetModel sets the model for a EntryCompletion. If @completion already has a
// model set, it will remove it before setting the new model. If model is nil,
// then it will unset the model.
	func (c EntryCompletion) SetModel(model TreeModel)  {
var _arg0 *C.GtkEntryCompletion // out
var _arg1 *C.GtkTreeModel // out

_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GtkTreeModel)(unsafe.Pointer(model.Native()))

C.gtk_entry_completion_set_model(_arg0, _arg1)
}
	
	// SetPopupCompletion sets whether the completions should be presented in a
// popup window.
	func (c EntryCompletion) SetPopupCompletion(popupCompletion bool)  {
var _arg0 *C.GtkEntryCompletion // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))
if popupCompletion { _arg1 = C.TRUE }

C.gtk_entry_completion_set_popup_completion(_arg0, _arg1)
}
	
	// SetPopupSetWidth sets whether the completion popup window will be resized to
// be the same width as the entry.
	func (c EntryCompletion) SetPopupSetWidth(popupSetWidth bool)  {
var _arg0 *C.GtkEntryCompletion // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))
if popupSetWidth { _arg1 = C.TRUE }

C.gtk_entry_completion_set_popup_set_width(_arg0, _arg1)
}
	
	// SetPopupSingleMatch sets whether the completion popup window will appear even
// if there is only a single match. You may want to set this to false if you are
// using [inline completion][GtkEntryCompletion--inline-completion].
	func (c EntryCompletion) SetPopupSingleMatch(popupSingleMatch bool)  {
var _arg0 *C.GtkEntryCompletion // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))
if popupSingleMatch { _arg1 = C.TRUE }

C.gtk_entry_completion_set_popup_single_match(_arg0, _arg1)
}
	
	// SetTextColumn: convenience function for setting up the most used case of this
// code: a completion list with just strings. This function will set up
// @completion to have a list displaying all (and just) strings in the
// completion list, and to get those strings from @column in the model of
// @completion.
// 
// This functions creates and adds a CellRendererText for the selected column.
// If you need to set the text column, but don't want the cell renderer, use
// g_object_set() to set the EntryCompletion:text-column property directly.
	func (c EntryCompletion) SetTextColumn(column int)  {
var _arg0 *C.GtkEntryCompletion // out
var _arg1 C.gint // out

_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))
_arg1 = (C.gint)(column)

C.gtk_entry_completion_set_text_column(_arg0, _arg1)
}
	


	// EventBox: the EventBox widget is a subclass of Bin which also has its own
// window. It is useful since it allows you to catch events for widgets which do
// not have their own window.
	type EventBox struct {
		Bin
		Buildable
		
	}

	// EventBoxClass is an interface that the EventBox class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type EventBoxClass interface {
		gextras.Objector
		_eventBox()
	}

	func (EventBox) _eventBox() {}

	
	func marshalEventBox(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapEventBox(obj), nil
	}
	

	
	// NewEventBox creates a new EventBox.
	func NewEventBox() EventBox {
var _cret *C.GtkWidget // in

_cret = C.gtk_event_box_new()


var _eventBox EventBox // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_eventBox = EventBox{
Bin: Bin{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _eventBox
}
	

	
	// AboveChild returns whether the event box window is above or below the windows
// of its child. See gtk_event_box_set_above_child() for details.
	func (e EventBox) AboveChild() bool {
var _arg0 *C.GtkEventBox // out
var _cret C.gboolean // in

_arg0 = (*C.GtkEventBox)(unsafe.Pointer(e.Native()))

_cret = C.gtk_event_box_get_above_child(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// VisibleWindow returns whether the event box has a visible window. See
// gtk_event_box_set_visible_window() for details.
	func (e EventBox) VisibleWindow() bool {
var _arg0 *C.GtkEventBox // out
var _cret C.gboolean // in

_arg0 = (*C.GtkEventBox)(unsafe.Pointer(e.Native()))

_cret = C.gtk_event_box_get_visible_window(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetAboveChild: set whether the event box window is positioned above the
// windows of its child, as opposed to below it. If the window is above, all
// events inside the event box will go to the event box. If the window is below,
// events in windows of child widgets will first got to that widget, and then to
// its parents.
// 
// The default is to keep the window below the child.
	func (e EventBox) SetAboveChild(aboveChild bool)  {
var _arg0 *C.GtkEventBox // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkEventBox)(unsafe.Pointer(e.Native()))
if aboveChild { _arg1 = C.TRUE }

C.gtk_event_box_set_above_child(_arg0, _arg1)
}
	
	// SetVisibleWindow: set whether the event box uses a visible or invisible child
// window. The default is to use visible windows.
// 
// In an invisible window event box, the window that the event box creates is a
// GDK_INPUT_ONLY window, which means that it is invisible and only serves to
// receive events.
// 
// A visible window event box creates a visible (GDK_INPUT_OUTPUT) window that
// acts as the parent window for all the widgets contained in the event box.
// 
// You should generally make your event box invisible if you just want to trap
// events. Creating a visible window may cause artifacts that are visible to the
// user, especially if the user is using a theme with gradients or pixmaps.
// 
// The main reason to create a non input-only event box is if you want to set
// the background to a different color or draw on it.
// 
// There is one unexpected issue for an invisible event box that has its window
// below the child. (See gtk_event_box_set_above_child().) Since the input-only
// window is not an ancestor window of any windows that descendent widgets of
// the event box create, events on these windows aren’t propagated up by the
// windowing system, but only by GTK+. The practical effect of this is if an
// event isn’t in the event mask for the descendant window (see
// gtk_widget_add_events()), it won’t be received by the event box.
// 
// This problem doesn’t occur for visible event boxes, because in that case, the
// event box window is actually the ancestor of the descendant windows, not just
// at the same place on the screen.
	func (e EventBox) SetVisibleWindow(visibleWindow bool)  {
var _arg0 *C.GtkEventBox // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkEventBox)(unsafe.Pointer(e.Native()))
if visibleWindow { _arg1 = C.TRUE }

C.gtk_event_box_set_visible_window(_arg0, _arg1)
}
	


	// EventController is a base, low-level implementation for event controllers.
// Those react to a series of Events, and possibly trigger actions as a
// consequence of those.
	type EventController struct {
		**externglib.Object
		
	}

	// EventControllerClass is an interface that the EventController class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type EventControllerClass interface {
		gextras.Objector
		_eventController()
	}

	func (EventController) _eventController() {}

	
	func marshalEventController(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapEventController(obj), nil
	}
	

	

	
	// PropagationPhase gets the propagation phase at which @controller handles
// events.
	func (c EventController) PropagationPhase() PropagationPhase {
var _arg0 *C.GtkEventController // out
var _cret C.GtkPropagationPhase // in

_arg0 = (*C.GtkEventController)(unsafe.Pointer(c.Native()))

_cret = C.gtk_event_controller_get_propagation_phase(_arg0)


var _propagationPhase PropagationPhase // out

_propagationPhase = PropagationPhase(_cret)

return _propagationPhase
}
	
	// Widget returns the Widget this controller relates to.
	func (c EventController) Widget() Widget {
var _arg0 *C.GtkEventController // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkEventController)(unsafe.Pointer(c.Native()))

_cret = C.gtk_event_controller_get_widget(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// Reset resets the @controller to a clean state. Every interaction the
// controller did through EventController::handle-event will be dropped at this
// point.
	func (c EventController) Reset()  {
var _arg0 *C.GtkEventController // out

_arg0 = (*C.GtkEventController)(unsafe.Pointer(c.Native()))

C.gtk_event_controller_reset(_arg0)
}
	
	// SetPropagationPhase sets the propagation phase at which a controller handles
// events.
// 
// If @phase is GTK_PHASE_NONE, no automatic event handling will be performed,
// but other additional gesture maintenance will. In that phase, the events can
// be managed by calling gtk_event_controller_handle_event().
	func (c EventController) SetPropagationPhase(phase PropagationPhase)  {
var _arg0 *C.GtkEventController // out
var _arg1 C.GtkPropagationPhase // out

_arg0 = (*C.GtkEventController)(unsafe.Pointer(c.Native()))
_arg1 = (C.GtkPropagationPhase)(phase)

C.gtk_event_controller_set_propagation_phase(_arg0, _arg1)
}
	


	// EventControllerKey is an event controller meant for situations where you need
// access to key events.
// 
// This object was added in 3.24.
	type EventControllerKey struct {
		EventController
		
	}

	// EventControllerKeyClass is an interface that the EventControllerKey class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type EventControllerKeyClass interface {
		gextras.Objector
		_eventControllerKey()
	}

	func (EventControllerKey) _eventControllerKey() {}

	
	func marshalEventControllerKey(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapEventControllerKey(obj), nil
	}
	

	
	
	func NewEventControllerKey(widget WidgetClass) EventControllerKey {
var _arg1 *C.GtkWidget // out
var _cret *C.GtkEventController // in

_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

_cret = C.gtk_event_controller_key_new(_arg1)


var _eventControllerKey EventControllerKey // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_eventControllerKey = EventControllerKey{
EventController: EventController{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _eventControllerKey
}
	

	
	
	func (c EventControllerKey) Forward(widget WidgetClass) bool {
var _arg0 *C.GtkEventControllerKey // out
var _arg1 *C.GtkWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkEventControllerKey)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

_cret = C.gtk_event_controller_key_forward(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	
	func (c EventControllerKey) Group() uint {
var _arg0 *C.GtkEventControllerKey // out
var _cret C.guint // in

_arg0 = (*C.GtkEventControllerKey)(unsafe.Pointer(c.Native()))

_cret = C.gtk_event_controller_key_get_group(_arg0)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// ImContext gets the IM context of a key controller.
	func (c EventControllerKey) ImContext() IMContext {
var _arg0 *C.GtkEventControllerKey // out
var _cret *C.GtkIMContext // in

_arg0 = (*C.GtkEventControllerKey)(unsafe.Pointer(c.Native()))

_cret = C.gtk_event_controller_key_get_im_context(_arg0)


var _imContext IMContext // out

_imContext = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(IMContext)

return _imContext
}
	
	
	func (c EventControllerKey) SetImContext(imContext IMContextClass)  {
var _arg0 *C.GtkEventControllerKey // out
var _arg1 *C.GtkIMContext // out

_arg0 = (*C.GtkEventControllerKey)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GtkIMContext)(unsafe.Pointer(imContext.Native()))

C.gtk_event_controller_key_set_im_context(_arg0, _arg1)
}
	


	// EventControllerMotion is an event controller meant for situations where you
// need to track the position of the pointer.
// 
// This object was added in 3.24.
	type EventControllerMotion struct {
		EventController
		
	}

	// EventControllerMotionClass is an interface that the EventControllerMotion class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type EventControllerMotionClass interface {
		gextras.Objector
		_eventControllerMotion()
	}

	func (EventControllerMotion) _eventControllerMotion() {}

	
	func marshalEventControllerMotion(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapEventControllerMotion(obj), nil
	}
	

	
	// NewEventControllerMotion creates a new event controller that will handle
// motion events for the given @widget.
	func NewEventControllerMotion(widget WidgetClass) EventControllerMotion {
var _arg1 *C.GtkWidget // out
var _cret *C.GtkEventController // in

_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

_cret = C.gtk_event_controller_motion_new(_arg1)


var _eventControllerMotion EventControllerMotion // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_eventControllerMotion = EventControllerMotion{
EventController: EventController{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _eventControllerMotion
}
	

	


	// EventControllerScroll is an event controller meant to handle scroll events
// from mice and touchpads. It is capable of handling both discrete and
// continuous scroll events, abstracting them both on the
// EventControllerScroll::scroll signal (deltas in the discrete case are
// multiples of 1).
// 
// In the case of continuous scroll events, EventControllerScroll encloses all
// EventControllerScroll::scroll events between two
// EventControllerScroll::scroll-begin and EventControllerScroll::scroll-end
// signals.
// 
// The behavior of the event controller can be modified by the flags given at
// creation time, or modified at a later point through
// gtk_event_controller_scroll_set_flags() (e.g. because the scrolling
// conditions of the widget changed).
// 
// The controller can be set up to emit motion for either/both vertical and
// horizontal scroll events through K_EVENT_CONTROLLER_SCROLL_VERTICAL,
// K_EVENT_CONTROLLER_SCROLL_HORIZONTAL and K_EVENT_CONTROLLER_SCROLL_BOTH. If
// any axis is disabled, the respective EventControllerScroll::scroll delta will
// be 0. Vertical scroll events will be translated to horizontal motion for the
// devices incapable of horizontal scrolling.
// 
// The event controller can also be forced to emit discrete events on all
// devices through K_EVENT_CONTROLLER_SCROLL_DISCRETE. This can be used to
// implement discrete actions triggered through scroll events (e.g. switching
// across combobox options).
// 
// The K_EVENT_CONTROLLER_SCROLL_KINETIC flag toggles the emission of the
// EventControllerScroll::decelerate signal, emitted at the end of scrolling
// with two X/Y velocity arguments that are consistent with the motion that was
// received.
// 
// This object was added in 3.24.
	type EventControllerScroll struct {
		EventController
		
	}

	// EventControllerScrollClass is an interface that the EventControllerScroll class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type EventControllerScrollClass interface {
		gextras.Objector
		_eventControllerScroll()
	}

	func (EventControllerScroll) _eventControllerScroll() {}

	
	func marshalEventControllerScroll(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapEventControllerScroll(obj), nil
	}
	

	
	// NewEventControllerScroll creates a new event controller that will handle
// scroll events for the given @widget.
	func NewEventControllerScroll(widget WidgetClass, flags EventControllerScrollFlags) EventControllerScroll {
var _arg1 *C.GtkWidget // out
var _arg2 C.GtkEventControllerScrollFlags // out
var _cret *C.GtkEventController // in

_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg2 = (C.GtkEventControllerScrollFlags)(flags)

_cret = C.gtk_event_controller_scroll_new(_arg1, _arg2)


var _eventControllerScroll EventControllerScroll // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_eventControllerScroll = EventControllerScroll{
EventController: EventController{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _eventControllerScroll
}
	

	
	// Flags gets the flags conditioning the scroll controller behavior.
	func (c EventControllerScroll) Flags() EventControllerScrollFlags {
var _arg0 *C.GtkEventControllerScroll // out
var _cret C.GtkEventControllerScrollFlags // in

_arg0 = (*C.GtkEventControllerScroll)(unsafe.Pointer(c.Native()))

_cret = C.gtk_event_controller_scroll_get_flags(_arg0)


var _eventControllerScrollFlags EventControllerScrollFlags // out

_eventControllerScrollFlags = EventControllerScrollFlags(_cret)

return _eventControllerScrollFlags
}
	
	// SetFlags sets the flags conditioning scroll controller behavior.
	func (c EventControllerScroll) SetFlags(flags EventControllerScrollFlags)  {
var _arg0 *C.GtkEventControllerScroll // out
var _arg1 C.GtkEventControllerScrollFlags // out

_arg0 = (*C.GtkEventControllerScroll)(unsafe.Pointer(c.Native()))
_arg1 = (C.GtkEventControllerScrollFlags)(flags)

C.gtk_event_controller_scroll_set_flags(_arg0, _arg1)
}
	


	// Expander: a Expander allows the user to hide or show its child by clicking on
// an expander triangle similar to the triangles used in a TreeView.
// 
// Normally you use an expander as you would use any other descendant of Bin;
// you create the child widget and use gtk_container_add() to add it to the
// expander. When the expander is toggled, it will take care of showing and
// hiding the child automatically.
// 
// 
// Special Usage
// 
// There are situations in which you may prefer to show and hide the expanded
// widget yourself, such as when you want to actually create the widget at
// expansion time. In this case, create a Expander but do not add a child to it.
// The expander widget has an Expander:expanded property which can be used to
// monitor its expansion state. You should watch this property with a signal
// connection as follows:
// 
//    expander
//    ├── title
//    │   ├── arrow
//    │   ╰── <label widget>
//    ╰── <child>
// 
// GtkExpander has three CSS nodes, the main node with the name expander, a
// subnode with name title and node below it with name arrow. The arrow of an
// expander that is showing its child gets the :checked pseudoclass added to it.
	type Expander struct {
		Bin
		Buildable
		
	}

	// ExpanderClass is an interface that the Expander class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ExpanderClass interface {
		gextras.Objector
		_expander()
	}

	func (Expander) _expander() {}

	
	func marshalExpander(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapExpander(obj), nil
	}
	

	
	// NewExpander creates a new expander using @label as the text of the label.
	func NewExpander(label string) Expander {
var _arg1 *C.gchar // out
var _cret *C.GtkWidget // in

_arg1 = (*C.gchar)(C.CString(label))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_expander_new(_arg1)


var _expander Expander // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_expander = Expander{
Bin: Bin{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _expander
}
	
	// NewExpanderWithMnemonic creates a new expander using @label as the text of
// the label. If characters in @label are preceded by an underscore, they are
// underlined. If you need a literal underscore character in a label, use “__”
// (two underscores). The first underlined character represents a keyboard
// accelerator called a mnemonic. Pressing Alt and that key activates the
// button.
	func NewExpanderWithMnemonic(label string) Expander {
var _arg1 *C.gchar // out
var _cret *C.GtkWidget // in

_arg1 = (*C.gchar)(C.CString(label))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_expander_new_with_mnemonic(_arg1)


var _expander Expander // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_expander = Expander{
Bin: Bin{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _expander
}
	

	
	// Expanded queries a Expander and returns its current state. Returns true if
// the child widget is revealed.
// 
// See gtk_expander_set_expanded().
	func (e Expander) Expanded() bool {
var _arg0 *C.GtkExpander // out
var _cret C.gboolean // in

_arg0 = (*C.GtkExpander)(unsafe.Pointer(e.Native()))

_cret = C.gtk_expander_get_expanded(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Label fetches the text from a label widget including any embedded underlines
// indicating mnemonics and Pango markup, as set by gtk_expander_set_label(). If
// the label text has not been set the return value will be nil. This will be
// the case if you create an empty button with gtk_button_new() to use as a
// container.
// 
// Note that this function behaved differently in versions prior to 2.14 and
// used to return the label text stripped of embedded underlines indicating
// mnemonics and Pango markup. This problem can be avoided by fetching the label
// text directly from the label widget.
	func (e Expander) Label() string {
var _arg0 *C.GtkExpander // out
var _cret *C.gchar // in

_arg0 = (*C.GtkExpander)(unsafe.Pointer(e.Native()))

_cret = C.gtk_expander_get_label(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// LabelFill returns whether the label widget will fill all available horizontal
// space allocated to @expander.
	func (e Expander) LabelFill() bool {
var _arg0 *C.GtkExpander // out
var _cret C.gboolean // in

_arg0 = (*C.GtkExpander)(unsafe.Pointer(e.Native()))

_cret = C.gtk_expander_get_label_fill(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// LabelWidget retrieves the label widget for the frame. See
// gtk_expander_set_label_widget().
	func (e Expander) LabelWidget() Widget {
var _arg0 *C.GtkExpander // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkExpander)(unsafe.Pointer(e.Native()))

_cret = C.gtk_expander_get_label_widget(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// ResizeToplevel returns whether the expander will resize the toplevel widget
// containing the expander upon resizing and collpasing.
	func (e Expander) ResizeToplevel() bool {
var _arg0 *C.GtkExpander // out
var _cret C.gboolean // in

_arg0 = (*C.GtkExpander)(unsafe.Pointer(e.Native()))

_cret = C.gtk_expander_get_resize_toplevel(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Spacing gets the value set by gtk_expander_set_spacing().
	func (e Expander) Spacing() int {
var _arg0 *C.GtkExpander // out
var _cret C.gint // in

_arg0 = (*C.GtkExpander)(unsafe.Pointer(e.Native()))

_cret = C.gtk_expander_get_spacing(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// UseMarkup returns whether the label’s text is interpreted as marked up with
// the [Pango text markup language][PangoMarkupFormat]. See
// gtk_expander_set_use_markup().
	func (e Expander) UseMarkup() bool {
var _arg0 *C.GtkExpander // out
var _cret C.gboolean // in

_arg0 = (*C.GtkExpander)(unsafe.Pointer(e.Native()))

_cret = C.gtk_expander_get_use_markup(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// UseUnderline returns whether an embedded underline in the expander label
// indicates a mnemonic. See gtk_expander_set_use_underline().
	func (e Expander) UseUnderline() bool {
var _arg0 *C.GtkExpander // out
var _cret C.gboolean // in

_arg0 = (*C.GtkExpander)(unsafe.Pointer(e.Native()))

_cret = C.gtk_expander_get_use_underline(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetExpanded sets the state of the expander. Set to true, if you want the
// child widget to be revealed, and false if you want the child widget to be
// hidden.
	func (e Expander) SetExpanded(expanded bool)  {
var _arg0 *C.GtkExpander // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkExpander)(unsafe.Pointer(e.Native()))
if expanded { _arg1 = C.TRUE }

C.gtk_expander_set_expanded(_arg0, _arg1)
}
	
	// SetLabel sets the text of the label of the expander to @label.
// 
// This will also clear any previously set labels.
	func (e Expander) SetLabel(label string)  {
var _arg0 *C.GtkExpander // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkExpander)(unsafe.Pointer(e.Native()))
_arg1 = (*C.gchar)(C.CString(label))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_expander_set_label(_arg0, _arg1)
}
	
	// SetLabelFill sets whether the label widget should fill all available
// horizontal space allocated to @expander.
// 
// Note that this function has no effect since 3.20.
	func (e Expander) SetLabelFill(labelFill bool)  {
var _arg0 *C.GtkExpander // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkExpander)(unsafe.Pointer(e.Native()))
if labelFill { _arg1 = C.TRUE }

C.gtk_expander_set_label_fill(_arg0, _arg1)
}
	
	// SetLabelWidget: set the label widget for the expander. This is the widget
// that will appear embedded alongside the expander arrow.
	func (e Expander) SetLabelWidget(labelWidget WidgetClass)  {
var _arg0 *C.GtkExpander // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkExpander)(unsafe.Pointer(e.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(labelWidget.Native()))

C.gtk_expander_set_label_widget(_arg0, _arg1)
}
	
	// SetResizeToplevel sets whether the expander will resize the toplevel widget
// containing the expander upon resizing and collpasing.
	func (e Expander) SetResizeToplevel(resizeToplevel bool)  {
var _arg0 *C.GtkExpander // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkExpander)(unsafe.Pointer(e.Native()))
if resizeToplevel { _arg1 = C.TRUE }

C.gtk_expander_set_resize_toplevel(_arg0, _arg1)
}
	
	// SetSpacing sets the spacing field of @expander, which is the number of pixels
// to place between expander and the child.
	func (e Expander) SetSpacing(spacing int)  {
var _arg0 *C.GtkExpander // out
var _arg1 C.gint // out

_arg0 = (*C.GtkExpander)(unsafe.Pointer(e.Native()))
_arg1 = (C.gint)(spacing)

C.gtk_expander_set_spacing(_arg0, _arg1)
}
	
	// SetUseMarkup sets whether the text of the label contains markup in [Pango’s
// text markup language][PangoMarkupFormat]. See gtk_label_set_markup().
	func (e Expander) SetUseMarkup(useMarkup bool)  {
var _arg0 *C.GtkExpander // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkExpander)(unsafe.Pointer(e.Native()))
if useMarkup { _arg1 = C.TRUE }

C.gtk_expander_set_use_markup(_arg0, _arg1)
}
	
	// SetUseUnderline: if true, an underline in the text of the expander label
// indicates the next character should be used for the mnemonic accelerator key.
	func (e Expander) SetUseUnderline(useUnderline bool)  {
var _arg0 *C.GtkExpander // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkExpander)(unsafe.Pointer(e.Native()))
if useUnderline { _arg1 = C.TRUE }

C.gtk_expander_set_use_underline(_arg0, _arg1)
}
	


	// FileChooserButton: the FileChooserButton is a widget that lets the user
// select a file. It implements the FileChooser interface. Visually, it is a
// file name with a button to bring up a FileChooserDialog. The user can then
// use that dialog to change the file associated with that button. This widget
// does not support setting the FileChooser:select-multiple property to true.
// 
// Create a button to let the user select a file in /etc
// 
//    {
//      GtkWidget *button;
// 
//      button = gtk_file_chooser_button_new (_("Select a file"),
//                                            GTK_FILE_CHOOSER_ACTION_OPEN);
//      gtk_file_chooser_set_current_folder (GTK_FILE_CHOOSER (button),
//                                           "/etc");
//    }
// 
// The FileChooserButton supports the FileChooserActions
// GTK_FILE_CHOOSER_ACTION_OPEN and GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER.
// 
// > The FileChooserButton will ellipsize the label, and will thus > request
// little horizontal space. To give the button more space, > you should call
// gtk_widget_get_preferred_size(), > gtk_file_chooser_button_set_width_chars(),
// or pack the button in > such a way that other interface elements give space
// to the > widget.
// 
// 
// CSS nodes
// 
// GtkFileChooserButton has a CSS node with name “filechooserbutton”, containing
// a subnode for the internal button with name “button” and style class “.file”.
	type FileChooserButton struct {
		Box
		Buildable
		FileChooser
		Orientable
		
	}

	// FileChooserButtonClass is an interface that the FileChooserButton class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type FileChooserButtonClass interface {
		gextras.Objector
		_fileChooserButton()
	}

	func (FileChooserButton) _fileChooserButton() {}

	
	func marshalFileChooserButton(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapFileChooserButton(obj), nil
	}
	

	
	// NewFileChooserButton creates a new file-selecting button widget.
	func NewFileChooserButton(title string, action FileChooserAction) FileChooserButton {
var _arg1 *C.gchar // out
var _arg2 C.GtkFileChooserAction // out
var _cret *C.GtkWidget // in

_arg1 = (*C.gchar)(C.CString(title))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.GtkFileChooserAction)(action)

_cret = C.gtk_file_chooser_button_new(_arg1, _arg2)


var _fileChooserButton FileChooserButton // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_fileChooserButton = FileChooserButton{
Box: Box{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
FileChooser: FileChooser{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _fileChooserButton
}
	
	// NewFileChooserButtonWithDialog creates a FileChooserButton widget which uses
// @dialog as its file-picking window.
// 
// Note that @dialog must be a Dialog (or subclass) which implements the
// FileChooser interface and must not have GTK_DIALOG_DESTROY_WITH_PARENT set.
// 
// Also note that the dialog needs to have its confirmative button added with
// response GTK_RESPONSE_ACCEPT or GTK_RESPONSE_OK in order for the button to
// take over the file selected in the dialog.
	func NewFileChooserButtonWithDialog(dialog DialogClass) FileChooserButton {
var _arg1 *C.GtkWidget // out
var _cret *C.GtkWidget // in

_arg1 = (*C.GtkWidget)(unsafe.Pointer(dialog.Native()))

_cret = C.gtk_file_chooser_button_new_with_dialog(_arg1)


var _fileChooserButton FileChooserButton // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_fileChooserButton = FileChooserButton{
Box: Box{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
FileChooser: FileChooser{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _fileChooserButton
}
	

	
	// FocusOnClick returns whether the button grabs focus when it is clicked with
// the mouse. See gtk_file_chooser_button_set_focus_on_click().
	func (b FileChooserButton) FocusOnClick() bool {
var _arg0 *C.GtkFileChooserButton // out
var _cret C.gboolean // in

_arg0 = (*C.GtkFileChooserButton)(unsafe.Pointer(b.Native()))

_cret = C.gtk_file_chooser_button_get_focus_on_click(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Title retrieves the title of the browse dialog used by @button. The returned
// value should not be modified or freed.
	func (b FileChooserButton) Title() string {
var _arg0 *C.GtkFileChooserButton // out
var _cret *C.gchar // in

_arg0 = (*C.GtkFileChooserButton)(unsafe.Pointer(b.Native()))

_cret = C.gtk_file_chooser_button_get_title(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// WidthChars retrieves the width in characters of the @button widget’s entry
// and/or label.
	func (b FileChooserButton) WidthChars() int {
var _arg0 *C.GtkFileChooserButton // out
var _cret C.gint // in

_arg0 = (*C.GtkFileChooserButton)(unsafe.Pointer(b.Native()))

_cret = C.gtk_file_chooser_button_get_width_chars(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// SetFocusOnClick sets whether the button will grab focus when it is clicked
// with the mouse. Making mouse clicks not grab focus is useful in places like
// toolbars where you don’t want the keyboard focus removed from the main area
// of the application.
	func (b FileChooserButton) SetFocusOnClick(focusOnClick bool)  {
var _arg0 *C.GtkFileChooserButton // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkFileChooserButton)(unsafe.Pointer(b.Native()))
if focusOnClick { _arg1 = C.TRUE }

C.gtk_file_chooser_button_set_focus_on_click(_arg0, _arg1)
}
	
	// SetTitle modifies the @title of the browse dialog used by @button.
	func (b FileChooserButton) SetTitle(title string)  {
var _arg0 *C.GtkFileChooserButton // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkFileChooserButton)(unsafe.Pointer(b.Native()))
_arg1 = (*C.gchar)(C.CString(title))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_file_chooser_button_set_title(_arg0, _arg1)
}
	
	// SetWidthChars sets the width (in characters) that @button will use to
// @n_chars.
	func (b FileChooserButton) SetWidthChars(nChars int)  {
var _arg0 *C.GtkFileChooserButton // out
var _arg1 C.gint // out

_arg0 = (*C.GtkFileChooserButton)(unsafe.Pointer(b.Native()))
_arg1 = (C.gint)(nChars)

C.gtk_file_chooser_button_set_width_chars(_arg0, _arg1)
}
	


	// FileChooserDialog is a dialog box suitable for use with “File/Open” or
// “File/Save as” commands. This widget works by putting a FileChooserWidget
// inside a Dialog. It exposes the FileChooser interface, so you can use all of
// the FileChooser functions on the file chooser dialog as well as those for
// Dialog.
// 
// Note that FileChooserDialog does not have any methods of its own. Instead,
// you should use the functions that work on a FileChooser.
// 
// If you want to integrate well with the platform you should use the
// FileChooserNative API, which will use a platform-specific dialog if available
// and fall back to GtkFileChooserDialog otherwise.
// 
// 
// Typical usage
// 
// In the simplest of cases, you can the following code to use FileChooserDialog
// to select a file for opening:
// 
//    GtkWidget *dialog;
//    GtkFileChooserAction action = GTK_FILE_CHOOSER_ACTION_OPEN;
//    gint res;
// 
//    dialog = gtk_file_chooser_dialog_new ("Open File",
//                                          parent_window,
//                                          action,
//                                          _("_Cancel"),
//                                          GTK_RESPONSE_CANCEL,
//                                          _("_Open"),
//                                          GTK_RESPONSE_ACCEPT,
//                                          NULL);
// 
//    res = gtk_dialog_run (GTK_DIALOG (dialog));
//    if (res == GTK_RESPONSE_ACCEPT)
//      {
//        char *filename;
//        GtkFileChooser *chooser = GTK_FILE_CHOOSER (dialog);
//        filename = gtk_file_chooser_get_filename (chooser);
//        open_file (filename);
//        g_free (filename);
//      }
// 
//    gtk_widget_destroy (dialog);
// 
// To use a dialog for saving, you can use this:
// 
//    GtkWidget *dialog;
//    GtkFileChooser *chooser;
//    GtkFileChooserAction action = GTK_FILE_CHOOSER_ACTION_SAVE;
//    gint res;
// 
//    dialog = gtk_file_chooser_dialog_new ("Save File",
//                                          parent_window,
//                                          action,
//                                          _("_Cancel"),
//                                          GTK_RESPONSE_CANCEL,
//                                          _("_Save"),
//                                          GTK_RESPONSE_ACCEPT,
//                                          NULL);
//    chooser = GTK_FILE_CHOOSER (dialog);
// 
//    gtk_file_chooser_set_do_overwrite_confirmation (chooser, TRUE);
// 
//    if (user_edited_a_new_document)
//      gtk_file_chooser_set_current_name (chooser,
//                                         _("Untitled document"));
//    else
//      gtk_file_chooser_set_filename (chooser,
//                                     existing_filename);
// 
//    res = gtk_dialog_run (GTK_DIALOG (dialog));
//    if (res == GTK_RESPONSE_ACCEPT)
//      {
//        char *filename;
// 
//        filename = gtk_file_chooser_get_filename (chooser);
//        save_to_file (filename);
//        g_free (filename);
//      }
// 
//    gtk_widget_destroy (dialog);
// 
// 
// Setting up a file chooser dialog
// 
// There are various cases in which you may need to use a FileChooserDialog:
// 
// - To select a file for opening. Use K_FILE_CHOOSER_ACTION_OPEN.
// 
// - To save a file for the first time. Use K_FILE_CHOOSER_ACTION_SAVE, and
// suggest a name such as “Untitled” with gtk_file_chooser_set_current_name().
// 
// - To save a file under a different name. Use K_FILE_CHOOSER_ACTION_SAVE, and
// set the existing filename with gtk_file_chooser_set_filename().
// 
// - To choose a folder instead of a file. Use
// K_FILE_CHOOSER_ACTION_SELECT_FOLDER.
// 
// Note that old versions of the file chooser’s documentation suggested using
// gtk_file_chooser_set_current_folder() in various situations, with the
// intention of letting the application suggest a reasonable default folder.
// This is no longer considered to be a good policy, as now the file chooser is
// able to make good suggestions on its own. In general, you should only cause
// the file chooser to show a specific folder when it is appropriate to use
// gtk_file_chooser_set_filename(), i.e. when you are doing a Save As command
// and you already have a file saved somewhere.
// 
// 
// Response Codes
// 
// FileChooserDialog inherits from Dialog, so buttons that go in its action area
// have response codes such as K_RESPONSE_ACCEPT and K_RESPONSE_CANCEL. For
// example, you could call gtk_file_chooser_dialog_new() as follows:
// 
//    GtkWidget *dialog;
//    GtkFileChooserAction action = GTK_FILE_CHOOSER_ACTION_OPEN;
// 
//    dialog = gtk_file_chooser_dialog_new ("Open File",
//                                          parent_window,
//                                          action,
//                                          _("_Cancel"),
//                                          GTK_RESPONSE_CANCEL,
//                                          _("_Open"),
//                                          GTK_RESPONSE_ACCEPT,
//                                          NULL);
// 
// This will create buttons for “Cancel” and “Open” that use stock response
// identifiers from ResponseType. For most dialog boxes you can use your own
// custom response codes rather than the ones in ResponseType, but
// FileChooserDialog assumes that its “accept”-type action, e.g. an “Open” or
// “Save” button, will have one of the following response codes:
// 
// - K_RESPONSE_ACCEPT - K_RESPONSE_OK - K_RESPONSE_YES - K_RESPONSE_APPLY
// 
// This is because FileChooserDialog must intercept responses and switch to
// folders if appropriate, rather than letting the dialog terminate — the
// implementation uses these known response codes to know which responses can be
// blocked if appropriate.
// 
// To summarize, make sure you use a [stock response
// code][gtkfilechooserdialog-responses] when you use FileChooserDialog to
// ensure proper operation.
	type FileChooserDialog struct {
		Dialog
		Buildable
		FileChooser
		
	}

	// FileChooserDialogClass is an interface that the FileChooserDialog class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type FileChooserDialogClass interface {
		gextras.Objector
		_fileChooserDialog()
	}

	func (FileChooserDialog) _fileChooserDialog() {}

	
	func marshalFileChooserDialog(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapFileChooserDialog(obj), nil
	}
	

	

	


	// FileChooserNative is an abstraction of a dialog box suitable for use with
// “File/Open” or “File/Save as” commands. By default, this just uses a
// FileChooserDialog to implement the actual dialog. However, on certain
// platforms, such as Windows and macOS, the native platform file chooser is
// used instead. When the application is running in a sandboxed environment
// without direct filesystem access (such as Flatpak), FileChooserNative may
// call the proper APIs (portals) to let the user choose a file and make it
// available to the application.
// 
// While the API of FileChooserNative closely mirrors FileChooserDialog, the
// main difference is that there is no access to any Window or Widget for the
// dialog. This is required, as there may not be one in the case of a platform
// native dialog. Showing, hiding and running the dialog is handled by the
// NativeDialog functions.
// 
// 
// Typical usage
// 
// In the simplest of cases, you can the following code to use FileChooserDialog
// to select a file for opening:
// 
//    GtkFileChooserNative *native;
//    GtkFileChooserAction action = GTK_FILE_CHOOSER_ACTION_OPEN;
//    gint res;
// 
//    native = gtk_file_chooser_native_new ("Open File",
//                                          parent_window,
//                                          action,
//                                          "_Open",
//                                          "_Cancel");
// 
//    res = gtk_native_dialog_run (GTK_NATIVE_DIALOG (native));
//    if (res == GTK_RESPONSE_ACCEPT)
//      {
//        char *filename;
//        GtkFileChooser *chooser = GTK_FILE_CHOOSER (native);
//        filename = gtk_file_chooser_get_filename (chooser);
//        open_file (filename);
//        g_free (filename);
//      }
// 
//    g_object_unref (native);
// 
// To use a dialog for saving, you can use this:
// 
//    GtkFileChooserNative *native;
//    GtkFileChooser *chooser;
//    GtkFileChooserAction action = GTK_FILE_CHOOSER_ACTION_SAVE;
//    gint res;
// 
//    native = gtk_file_chooser_native_new ("Save File",
//                                          parent_window,
//                                          action,
//                                          "_Save",
//                                          "_Cancel");
//    chooser = GTK_FILE_CHOOSER (native);
// 
//    gtk_file_chooser_set_do_overwrite_confirmation (chooser, TRUE);
// 
//    if (user_edited_a_new_document)
//      gtk_file_chooser_set_current_name (chooser,
//                                         _("Untitled document"));
//    else
//      gtk_file_chooser_set_filename (chooser,
//                                     existing_filename);
// 
//    res = gtk_native_dialog_run (GTK_NATIVE_DIALOG (native));
//    if (res == GTK_RESPONSE_ACCEPT)
//      {
//        char *filename;
// 
//        filename = gtk_file_chooser_get_filename (chooser);
//        save_to_file (filename);
//        g_free (filename);
//      }
// 
//    g_object_unref (native);
// 
// For more information on how to best set up a file dialog, see
// FileChooserDialog.
// 
// 
// Response Codes
// 
// FileChooserNative inherits from NativeDialog, which means it will return
// K_RESPONSE_ACCEPT if the user accepted, and K_RESPONSE_CANCEL if he pressed
// cancel. It can also return K_RESPONSE_DELETE_EVENT if the window was
// unexpectedly closed.
// 
// Differences from FileChooserDialog ##
// {#gtkfilechooserdialognative-differences}
// 
// There are a few things in the GtkFileChooser API that are not possible to use
// with FileChooserNative, as such use would prohibit the use of a native
// dialog.
// 
// There is no support for the signals that are emitted when the user navigates
// in the dialog, including: * FileChooser::current-folder-changed *
// FileChooser::selection-changed * FileChooser::file-activated *
// FileChooser::confirm-overwrite
// 
// You can also not use the methods that directly control user navigation: *
// gtk_file_chooser_unselect_filename() * gtk_file_chooser_select_all() *
// gtk_file_chooser_unselect_all()
// 
// If you need any of the above you will have to use FileChooserDialog directly.
// 
// No operations that change the the dialog work while the dialog is visible.
// Set all the properties that are required before showing the dialog.
// 
// 
// Win32 details
// 
// On windows the IFileDialog implementation (added in Windows Vista) is used.
// It supports many of the features that FileChooserDialog does, but there are
// some things it does not handle:
// 
// * Extra widgets added with gtk_file_chooser_set_extra_widget().
// 
// * Use of custom previews by connecting to FileChooser::update-preview.
// 
// * Any FileFilter added using a mimetype or custom filter.
// 
// If any of these features are used the regular FileChooserDialog will be used
// in place of the native one.
// 
// 
// Portal details
// 
// When the org.freedesktop.portal.FileChooser portal is available on the
// session bus, it is used to bring up an out-of-process file chooser. Depending
// on the kind of session the application is running in, this may or may not be
// a GTK+ file chooser. In this situation, the following things are not
// supported and will be silently ignored:
// 
// * Extra widgets added with gtk_file_chooser_set_extra_widget().
// 
// * Use of custom previews by connecting to FileChooser::update-preview.
// 
// * Any FileFilter added with a custom filter.
// 
// macOS details
// 
// On macOS the NSSavePanel and NSOpenPanel classes are used to provide native
// file chooser dialogs. Some features provided by FileChooserDialog are not
// supported:
// 
// * Extra widgets added with gtk_file_chooser_set_extra_widget(), unless the
// widget is an instance of GtkLabel, in which case the label text will be used
// to set the NSSavePanel message instance property.
// 
// * Use of custom previews by connecting to FileChooser::update-preview.
// 
// * Any FileFilter added with a custom filter.
// 
// * Shortcut folders.
	type FileChooserNative struct {
		NativeDialog
		FileChooser
		
	}

	// FileChooserNativeClass is an interface that the FileChooserNative class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type FileChooserNativeClass interface {
		gextras.Objector
		_fileChooserNative()
	}

	func (FileChooserNative) _fileChooserNative() {}

	
	func marshalFileChooserNative(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapFileChooserNative(obj), nil
	}
	

	
	// NewFileChooserNative creates a new FileChooserNative.
	func NewFileChooserNative(title string, parent WindowClass, action FileChooserAction, acceptLabel string, cancelLabel string) FileChooserNative {
var _arg1 *C.gchar // out
var _arg2 *C.GtkWindow // out
var _arg3 C.GtkFileChooserAction // out
var _arg4 *C.gchar // out
var _arg5 *C.gchar // out
var _cret *C.GtkFileChooserNative // in

_arg1 = (*C.gchar)(C.CString(title))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.GtkWindow)(unsafe.Pointer(parent.Native()))
_arg3 = (C.GtkFileChooserAction)(action)
_arg4 = (*C.gchar)(C.CString(acceptLabel))
defer C.free(unsafe.Pointer(_arg4))
_arg5 = (*C.gchar)(C.CString(cancelLabel))
defer C.free(unsafe.Pointer(_arg5))

_cret = C.gtk_file_chooser_native_new(_arg1, _arg2, _arg3, _arg4, _arg5)


var _fileChooserNative FileChooserNative // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_fileChooserNative = FileChooserNative{
NativeDialog: NativeDialog{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
FileChooser: FileChooser{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _fileChooserNative
}
	

	
	// AcceptLabel retrieves the custom label text for the accept button.
	func (s FileChooserNative) AcceptLabel() string {
var _arg0 *C.GtkFileChooserNative // out
var _cret *C.char // in

_arg0 = (*C.GtkFileChooserNative)(unsafe.Pointer(s.Native()))

_cret = C.gtk_file_chooser_native_get_accept_label(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// CancelLabel retrieves the custom label text for the cancel button.
	func (s FileChooserNative) CancelLabel() string {
var _arg0 *C.GtkFileChooserNative // out
var _cret *C.char // in

_arg0 = (*C.GtkFileChooserNative)(unsafe.Pointer(s.Native()))

_cret = C.gtk_file_chooser_native_get_cancel_label(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// SetAcceptLabel sets the custom label text for the accept button.
// 
// If characters in @label are preceded by an underscore, they are underlined.
// If you need a literal underscore character in a label, use “__” (two
// underscores). The first underlined character represents a keyboard
// accelerator called a mnemonic. Pressing Alt and that key activates the
// button.
	func (s FileChooserNative) SetAcceptLabel(acceptLabel string)  {
var _arg0 *C.GtkFileChooserNative // out
var _arg1 *C.char // out

_arg0 = (*C.GtkFileChooserNative)(unsafe.Pointer(s.Native()))
_arg1 = (*C.char)(C.CString(acceptLabel))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_file_chooser_native_set_accept_label(_arg0, _arg1)
}
	
	// SetCancelLabel sets the custom label text for the cancel button.
// 
// If characters in @label are preceded by an underscore, they are underlined.
// If you need a literal underscore character in a label, use “__” (two
// underscores). The first underlined character represents a keyboard
// accelerator called a mnemonic. Pressing Alt and that key activates the
// button.
	func (s FileChooserNative) SetCancelLabel(cancelLabel string)  {
var _arg0 *C.GtkFileChooserNative // out
var _arg1 *C.char // out

_arg0 = (*C.GtkFileChooserNative)(unsafe.Pointer(s.Native()))
_arg1 = (*C.char)(C.CString(cancelLabel))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_file_chooser_native_set_cancel_label(_arg0, _arg1)
}
	


	// FileChooserWidget is a widget for choosing files. It exposes the FileChooser
// interface, and you should use the methods of this interface to interact with
// the widget.
// 
// 
// CSS nodes
// 
// GtkFileChooserWidget has a single CSS node with name filechooser.
	type FileChooserWidget struct {
		Box
		Buildable
		FileChooser
		Orientable
		
	}

	// FileChooserWidgetClass is an interface that the FileChooserWidget class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type FileChooserWidgetClass interface {
		gextras.Objector
		_fileChooserWidget()
	}

	func (FileChooserWidget) _fileChooserWidget() {}

	
	func marshalFileChooserWidget(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapFileChooserWidget(obj), nil
	}
	

	
	// NewFileChooserWidget creates a new FileChooserWidget. This is a file chooser
// widget that can be embedded in custom windows, and it is the same widget that
// is used by FileChooserDialog.
	func NewFileChooserWidget(action FileChooserAction) FileChooserWidget {
var _arg1 C.GtkFileChooserAction // out
var _cret *C.GtkWidget // in

_arg1 = (C.GtkFileChooserAction)(action)

_cret = C.gtk_file_chooser_widget_new(_arg1)


var _fileChooserWidget FileChooserWidget // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_fileChooserWidget = FileChooserWidget{
Box: Box{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
FileChooser: FileChooser{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _fileChooserWidget
}
	

	


	// FileFilter: a GtkFileFilter can be used to restrict the files being shown in
// a FileChooser. Files can be filtered based on their name (with
// gtk_file_filter_add_pattern()), on their mime type (with
// gtk_file_filter_add_mime_type()), or by a custom filter function (with
// gtk_file_filter_add_custom()).
// 
// Filtering by mime types handles aliasing and subclassing of mime types; e.g.
// a filter for text/plain also matches a file with mime type application/rtf,
// since application/rtf is a subclass of text/plain. Note that FileFilter
// allows wildcards for the subtype of a mime type, so you can e.g. filter for
// image/\*.
// 
// Normally, filters are used by adding them to a FileChooser, see
// gtk_file_chooser_add_filter(), but it is also possible to manually use a
// filter on a file with gtk_file_filter_filter().
// 
// 
// GtkFileFilter as GtkBuildable
// 
// The GtkFileFilter implementation of the GtkBuildable interface supports
// adding rules using the <mime-types>, <patterns> and <applications> elements
// and listing the rules within. Specifying a <mime-type> or <pattern> has the
// same effect as as calling gtk_file_filter_add_mime_type() or
// gtk_file_filter_add_pattern().
// 
// An example of a UI definition fragment specifying GtkFileFilter rules:
// 
//    <object class="GtkFileFilter">
//      <mime-types>
//        <mime-type>text/plain</mime-type>
//        <mime-type>image/ *</mime-type>
//      </mime-types>
//      <patterns>
//        <pattern>*.txt</pattern>
//        <pattern>*.png</pattern>
//      </patterns>
//    </object>
	type FileFilter struct {
		externglib.InitiallyUnowned
		Buildable
		
	}

	// FileFilterClass is an interface that the FileFilter class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type FileFilterClass interface {
		gextras.Objector
		_fileFilter()
	}

	func (FileFilter) _fileFilter() {}

	
	func marshalFileFilter(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapFileFilter(obj), nil
	}
	

	
	// NewFileFilter creates a new FileFilter with no rules added to it. Such a
// filter doesn’t accept any files, so is not particularly useful until you add
// rules with gtk_file_filter_add_mime_type(), gtk_file_filter_add_pattern(), or
// gtk_file_filter_add_custom(). To create a filter that accepts any file, use:
// 
//    GtkFileFilter *filter = gtk_file_filter_new ();
//    gtk_file_filter_add_pattern (filter, "*");
	func NewFileFilter() FileFilter {
var _cret *C.GtkFileFilter // in

_cret = C.gtk_file_filter_new()


var _fileFilter FileFilter // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_fileFilter = FileFilter{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _fileFilter
}
	
	// NewFileFilterFromGVariant: deserialize a file filter from an a{sv} variant in
// the format produced by gtk_file_filter_to_gvariant().
	func NewFileFilterFromGVariant(variant *glib.Variant) FileFilter {
var _arg1 *C.GVariant // out
var _cret *C.GtkFileFilter // in

_arg1 = (*C.GVariant)(unsafe.Pointer(variant.Native()))

_cret = C.gtk_file_filter_new_from_gvariant(_arg1)


var _fileFilter FileFilter // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_fileFilter = FileFilter{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _fileFilter
}
	

	
	// AddMIMEType adds a rule allowing a given mime type to @filter.
	func (f FileFilter) AddMIMEType(mimeType string)  {
var _arg0 *C.GtkFileFilter // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkFileFilter)(unsafe.Pointer(f.Native()))
_arg1 = (*C.gchar)(C.CString(mimeType))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_file_filter_add_mime_type(_arg0, _arg1)
}
	
	// AddPattern adds a rule allowing a shell style glob to a filter.
	func (f FileFilter) AddPattern(pattern string)  {
var _arg0 *C.GtkFileFilter // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkFileFilter)(unsafe.Pointer(f.Native()))
_arg1 = (*C.gchar)(C.CString(pattern))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_file_filter_add_pattern(_arg0, _arg1)
}
	
	// AddPixbufFormats adds a rule allowing image files in the formats supported by
// GdkPixbuf.
	func (f FileFilter) AddPixbufFormats()  {
var _arg0 *C.GtkFileFilter // out

_arg0 = (*C.GtkFileFilter)(unsafe.Pointer(f.Native()))

C.gtk_file_filter_add_pixbuf_formats(_arg0)
}
	
	// Filter tests whether a file should be displayed according to @filter. The
// FileFilterInfo @filter_info should include the fields returned from
// gtk_file_filter_get_needed().
// 
// This function will not typically be used by applications; it is intended
// principally for use in the implementation of FileChooser.
	func (f FileFilter) Filter(filterInfo *FileFilterInfo) bool {
var _arg0 *C.GtkFileFilter // out
var _arg1 *C.GtkFileFilterInfo // out
var _cret C.gboolean // in

_arg0 = (*C.GtkFileFilter)(unsafe.Pointer(f.Native()))
_arg1 = (*C.GtkFileFilterInfo)(unsafe.Pointer(filterInfo.Native()))

_cret = C.gtk_file_filter_filter(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Name gets the human-readable name for the filter. See
// gtk_file_filter_set_name().
	func (f FileFilter) Name() string {
var _arg0 *C.GtkFileFilter // out
var _cret *C.gchar // in

_arg0 = (*C.GtkFileFilter)(unsafe.Pointer(f.Native()))

_cret = C.gtk_file_filter_get_name(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Needed gets the fields that need to be filled in for the FileFilterInfo
// passed to gtk_file_filter_filter()
// 
// This function will not typically be used by applications; it is intended
// principally for use in the implementation of FileChooser.
	func (f FileFilter) Needed() FileFilterFlags {
var _arg0 *C.GtkFileFilter // out
var _cret C.GtkFileFilterFlags // in

_arg0 = (*C.GtkFileFilter)(unsafe.Pointer(f.Native()))

_cret = C.gtk_file_filter_get_needed(_arg0)


var _fileFilterFlags FileFilterFlags // out

_fileFilterFlags = FileFilterFlags(_cret)

return _fileFilterFlags
}
	
	// SetName sets the human-readable name of the filter; this is the string that
// will be displayed in the file selector user interface if there is a
// selectable list of filters.
	func (f FileFilter) SetName(name string)  {
var _arg0 *C.GtkFileFilter // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkFileFilter)(unsafe.Pointer(f.Native()))
_arg1 = (*C.gchar)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_file_filter_set_name(_arg0, _arg1)
}
	
	// ToGVariant: serialize a file filter to an a{sv} variant.
	func (f FileFilter) ToGVariant() *glib.Variant {
var _arg0 *C.GtkFileFilter // out
var _cret *C.GVariant // in

_arg0 = (*C.GtkFileFilter)(unsafe.Pointer(f.Native()))

_cret = C.gtk_file_filter_to_gvariant(_arg0)


var _variant *glib.Variant // out

_variant = *(**glib.Variant)(unsafe.Pointer(&_cret))

return _variant
}
	


	// Fixed: the Fixed widget is a container which can place child widgets at fixed
// positions and with fixed sizes, given in pixels. Fixed performs no automatic
// layout management.
// 
// For most applications, you should not use this container! It keeps you from
// having to learn about the other GTK+ containers, but it results in broken
// applications. With Fixed, the following things will result in truncated text,
// overlapping widgets, and other display bugs:
// 
// - Themes, which may change widget sizes.
// 
// - Fonts other than the one you used to write the app will of course change
// the size of widgets containing text; keep in mind that users may use a larger
// font because of difficulty reading the default, or they may be using a
// different OS that provides different fonts.
// 
// - Translation of text into other languages changes its size. Also, display of
// non-English text will use a different font in many cases.
// 
// In addition, Fixed does not pay attention to text direction and thus may
// produce unwanted results if your app is run under right-to-left languages
// such as Hebrew or Arabic. That is: normally GTK+ will order containers
// appropriately for the text direction, e.g. to put labels to the right of the
// thing they label when using an RTL language, but it can’t do that with Fixed.
// So if you need to reorder widgets depending on the text direction, you would
// need to manually detect it and adjust child positions accordingly.
// 
// Finally, fixed positioning makes it kind of annoying to add/remove GUI
// elements, since you have to reposition all the other elements. This is a
// long-term maintenance problem for your application.
// 
// If you know none of these things are an issue for your application, and
// prefer the simplicity of Fixed, by all means use the widget. But you should
// be aware of the tradeoffs.
// 
// See also Layout, which shares the ability to perform fixed positioning of
// child widgets and additionally adds custom drawing and scrollability.
	type Fixed struct {
		Container
		Buildable
		
	}

	// FixedClass is an interface that the Fixed class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type FixedClass interface {
		gextras.Objector
		_fixed()
	}

	func (Fixed) _fixed() {}

	
	func marshalFixed(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapFixed(obj), nil
	}
	

	
	// NewFixed creates a new Fixed.
	func NewFixed() Fixed {
var _cret *C.GtkWidget // in

_cret = C.gtk_fixed_new()


var _fixed Fixed // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_fixed = Fixed{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _fixed
}
	

	
	// Move moves a child of a Fixed container to the given position.
	func (f Fixed) Move(widget WidgetClass, x int, y int)  {
var _arg0 *C.GtkFixed // out
var _arg1 *C.GtkWidget // out
var _arg2 C.gint // out
var _arg3 C.gint // out

_arg0 = (*C.GtkFixed)(unsafe.Pointer(f.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg2 = (C.gint)(x)
_arg3 = (C.gint)(y)

C.gtk_fixed_move(_arg0, _arg1, _arg2, _arg3)
}
	
	// Put adds a widget to a Fixed container at the given position.
	func (f Fixed) Put(widget WidgetClass, x int, y int)  {
var _arg0 *C.GtkFixed // out
var _arg1 *C.GtkWidget // out
var _arg2 C.gint // out
var _arg3 C.gint // out

_arg0 = (*C.GtkFixed)(unsafe.Pointer(f.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg2 = (C.gint)(x)
_arg3 = (C.gint)(y)

C.gtk_fixed_put(_arg0, _arg1, _arg2, _arg3)
}
	


	// FlowBox: a GtkFlowBox positions child widgets in sequence according to its
// orientation.
// 
// For instance, with the horizontal orientation, the widgets will be arranged
// from left to right, starting a new row under the previous row when necessary.
// Reducing the width in this case will require more rows, so a larger height
// will be requested.
// 
// Likewise, with the vertical orientation, the widgets will be arranged from
// top to bottom, starting a new column to the right when necessary. Reducing
// the height will require more columns, so a larger width will be requested.
// 
// The size request of a GtkFlowBox alone may not be what you expect; if you
// need to be able to shrink it along both axes and dynamically reflow its
// children, you may have to wrap it in a ScrolledWindow to enable that.
// 
// The children of a GtkFlowBox can be dynamically sorted and filtered.
// 
// Although a GtkFlowBox must have only FlowBoxChild children, you can add any
// kind of widget to it via gtk_container_add(), and a GtkFlowBoxChild widget
// will automatically be inserted between the box and the widget.
// 
// Also see ListBox.
// 
// GtkFlowBox was added in GTK+ 3.12.
// 
// CSS nodes
// 
//    flowbox
//    ├── flowboxchild
//    │   ╰── <child>
//    ├── flowboxchild
//    │   ╰── <child>
//    ┊
//    ╰── [rubberband]
// 
// GtkFlowBox uses a single CSS node with name flowbox. GtkFlowBoxChild uses a
// single CSS node with name flowboxchild. For rubberband selection, a subnode
// with name rubberband is used.
	type FlowBox struct {
		Container
		Buildable
		Orientable
		
	}

	// FlowBoxClass is an interface that the FlowBox class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type FlowBoxClass interface {
		gextras.Objector
		_flowBox()
	}

	func (FlowBox) _flowBox() {}

	
	func marshalFlowBox(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapFlowBox(obj), nil
	}
	

	
	// NewFlowBox creates a GtkFlowBox.
	func NewFlowBox() FlowBox {
var _cret *C.GtkWidget // in

_cret = C.gtk_flow_box_new()


var _flowBox FlowBox // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_flowBox = FlowBox{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _flowBox
}
	

	
	// ActivateOnSingleClick returns whether children activate on single clicks.
	func (b FlowBox) ActivateOnSingleClick() bool {
var _arg0 *C.GtkFlowBox // out
var _cret C.gboolean // in

_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))

_cret = C.gtk_flow_box_get_activate_on_single_click(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ChildAtIndex gets the nth child in the @box.
	func (b FlowBox) ChildAtIndex(idx int) FlowBoxChild {
var _arg0 *C.GtkFlowBox // out
var _arg1 C.gint // out
var _cret *C.GtkFlowBoxChild // in

_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
_arg1 = (C.gint)(idx)

_cret = C.gtk_flow_box_get_child_at_index(_arg0, _arg1)


var _flowBoxChild FlowBoxChild // out

_flowBoxChild = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(FlowBoxChild)

return _flowBoxChild
}
	
	// ChildAtPos gets the child in the (@x, @y) position.
	func (b FlowBox) ChildAtPos(x int, y int) FlowBoxChild {
var _arg0 *C.GtkFlowBox // out
var _arg1 C.gint // out
var _arg2 C.gint // out
var _cret *C.GtkFlowBoxChild // in

_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
_arg1 = (C.gint)(x)
_arg2 = (C.gint)(y)

_cret = C.gtk_flow_box_get_child_at_pos(_arg0, _arg1, _arg2)


var _flowBoxChild FlowBoxChild // out

_flowBoxChild = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(FlowBoxChild)

return _flowBoxChild
}
	
	// ColumnSpacing gets the horizontal spacing.
	func (b FlowBox) ColumnSpacing() uint {
var _arg0 *C.GtkFlowBox // out
var _cret C.guint // in

_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))

_cret = C.gtk_flow_box_get_column_spacing(_arg0)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// Homogeneous returns whether the box is homogeneous (all children are the same
// size). See gtk_box_set_homogeneous().
	func (b FlowBox) Homogeneous() bool {
var _arg0 *C.GtkFlowBox // out
var _cret C.gboolean // in

_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))

_cret = C.gtk_flow_box_get_homogeneous(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// MaxChildrenPerLine gets the maximum number of children per line.
	func (b FlowBox) MaxChildrenPerLine() uint {
var _arg0 *C.GtkFlowBox // out
var _cret C.guint // in

_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))

_cret = C.gtk_flow_box_get_max_children_per_line(_arg0)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// MinChildrenPerLine gets the minimum number of children per line.
	func (b FlowBox) MinChildrenPerLine() uint {
var _arg0 *C.GtkFlowBox // out
var _cret C.guint // in

_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))

_cret = C.gtk_flow_box_get_min_children_per_line(_arg0)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// RowSpacing gets the vertical spacing.
	func (b FlowBox) RowSpacing() uint {
var _arg0 *C.GtkFlowBox // out
var _cret C.guint // in

_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))

_cret = C.gtk_flow_box_get_row_spacing(_arg0)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// SelectionMode gets the selection mode of @box.
	func (b FlowBox) SelectionMode() SelectionMode {
var _arg0 *C.GtkFlowBox // out
var _cret C.GtkSelectionMode // in

_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))

_cret = C.gtk_flow_box_get_selection_mode(_arg0)


var _selectionMode SelectionMode // out

_selectionMode = SelectionMode(_cret)

return _selectionMode
}
	
	// Insert inserts the @widget into @box at @position.
// 
// If a sort function is set, the widget will actually be inserted at the
// calculated position and this function has the same effect as
// gtk_container_add().
// 
// If @position is -1, or larger than the total number of children in the @box,
// then the @widget will be appended to the end.
	func (b FlowBox) Insert(widget WidgetClass, position int)  {
var _arg0 *C.GtkFlowBox // out
var _arg1 *C.GtkWidget // out
var _arg2 C.gint // out

_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg2 = (C.gint)(position)

C.gtk_flow_box_insert(_arg0, _arg1, _arg2)
}
	
	// InvalidateFilter updates the filtering for all children.
// 
// Call this function when the result of the filter function on the @box is
// changed due ot an external factor. For instance, this would be used if the
// filter function just looked for a specific search term, and the entry with
// the string has changed.
	func (b FlowBox) InvalidateFilter()  {
var _arg0 *C.GtkFlowBox // out

_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))

C.gtk_flow_box_invalidate_filter(_arg0)
}
	
	// InvalidateSort updates the sorting for all children.
// 
// Call this when the result of the sort function on @box is changed due to an
// external factor.
	func (b FlowBox) InvalidateSort()  {
var _arg0 *C.GtkFlowBox // out

_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))

C.gtk_flow_box_invalidate_sort(_arg0)
}
	
	// SelectAll: select all children of @box, if the selection mode allows it.
	func (b FlowBox) SelectAll()  {
var _arg0 *C.GtkFlowBox // out

_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))

C.gtk_flow_box_select_all(_arg0)
}
	
	// SelectChild selects a single child of @box, if the selection mode allows it.
	func (b FlowBox) SelectChild(child FlowBoxChildClass)  {
var _arg0 *C.GtkFlowBox // out
var _arg1 *C.GtkFlowBoxChild // out

_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkFlowBoxChild)(unsafe.Pointer(child.Native()))

C.gtk_flow_box_select_child(_arg0, _arg1)
}
	
	// SetActivateOnSingleClick: if @single is true, children will be activated when
// you click on them, otherwise you need to double-click.
	func (b FlowBox) SetActivateOnSingleClick(single bool)  {
var _arg0 *C.GtkFlowBox // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
if single { _arg1 = C.TRUE }

C.gtk_flow_box_set_activate_on_single_click(_arg0, _arg1)
}
	
	// SetColumnSpacing sets the horizontal space to add between children. See the
// FlowBox:column-spacing property.
	func (b FlowBox) SetColumnSpacing(spacing uint)  {
var _arg0 *C.GtkFlowBox // out
var _arg1 C.guint // out

_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
_arg1 = (C.guint)(spacing)

C.gtk_flow_box_set_column_spacing(_arg0, _arg1)
}
	
	// SetHAdjustment hooks up an adjustment to focus handling in @box. The
// adjustment is also used for autoscrolling during rubberband selection. See
// gtk_scrolled_window_get_hadjustment() for a typical way of obtaining the
// adjustment, and gtk_flow_box_set_vadjustment()for setting the vertical
// adjustment.
// 
// The adjustments have to be in pixel units and in the same coordinate system
// as the allocation for immediate children of the box.
	func (b FlowBox) SetHAdjustment(adjustment AdjustmentClass)  {
var _arg0 *C.GtkFlowBox // out
var _arg1 *C.GtkAdjustment // out

_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(adjustment.Native()))

C.gtk_flow_box_set_hadjustment(_arg0, _arg1)
}
	
	// SetHomogeneous sets the FlowBox:homogeneous property of @box, controlling
// whether or not all children of @box are given equal space in the box.
	func (b FlowBox) SetHomogeneous(homogeneous bool)  {
var _arg0 *C.GtkFlowBox // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
if homogeneous { _arg1 = C.TRUE }

C.gtk_flow_box_set_homogeneous(_arg0, _arg1)
}
	
	// SetMaxChildrenPerLine sets the maximum number of children to request and
// allocate space for in @box’s orientation.
// 
// Setting the maximum number of children per line limits the overall natural
// size request to be no more than @n_children children long in the given
// orientation.
	func (b FlowBox) SetMaxChildrenPerLine(nChildren uint)  {
var _arg0 *C.GtkFlowBox // out
var _arg1 C.guint // out

_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
_arg1 = (C.guint)(nChildren)

C.gtk_flow_box_set_max_children_per_line(_arg0, _arg1)
}
	
	// SetMinChildrenPerLine sets the minimum number of children to line up in
// @box’s orientation before flowing.
	func (b FlowBox) SetMinChildrenPerLine(nChildren uint)  {
var _arg0 *C.GtkFlowBox // out
var _arg1 C.guint // out

_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
_arg1 = (C.guint)(nChildren)

C.gtk_flow_box_set_min_children_per_line(_arg0, _arg1)
}
	
	// SetRowSpacing sets the vertical space to add between children. See the
// FlowBox:row-spacing property.
	func (b FlowBox) SetRowSpacing(spacing uint)  {
var _arg0 *C.GtkFlowBox // out
var _arg1 C.guint // out

_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
_arg1 = (C.guint)(spacing)

C.gtk_flow_box_set_row_spacing(_arg0, _arg1)
}
	
	// SetSelectionMode sets how selection works in @box. See SelectionMode for
// details.
	func (b FlowBox) SetSelectionMode(mode SelectionMode)  {
var _arg0 *C.GtkFlowBox // out
var _arg1 C.GtkSelectionMode // out

_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
_arg1 = (C.GtkSelectionMode)(mode)

C.gtk_flow_box_set_selection_mode(_arg0, _arg1)
}
	
	// SetVAdjustment hooks up an adjustment to focus handling in @box. The
// adjustment is also used for autoscrolling during rubberband selection. See
// gtk_scrolled_window_get_vadjustment() for a typical way of obtaining the
// adjustment, and gtk_flow_box_set_hadjustment()for setting the horizontal
// adjustment.
// 
// The adjustments have to be in pixel units and in the same coordinate system
// as the allocation for immediate children of the box.
	func (b FlowBox) SetVAdjustment(adjustment AdjustmentClass)  {
var _arg0 *C.GtkFlowBox // out
var _arg1 *C.GtkAdjustment // out

_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(adjustment.Native()))

C.gtk_flow_box_set_vadjustment(_arg0, _arg1)
}
	
	// UnselectAll: unselect all children of @box, if the selection mode allows it.
	func (b FlowBox) UnselectAll()  {
var _arg0 *C.GtkFlowBox // out

_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))

C.gtk_flow_box_unselect_all(_arg0)
}
	
	// UnselectChild unselects a single child of @box, if the selection mode allows
// it.
	func (b FlowBox) UnselectChild(child FlowBoxChildClass)  {
var _arg0 *C.GtkFlowBox // out
var _arg1 *C.GtkFlowBoxChild // out

_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkFlowBoxChild)(unsafe.Pointer(child.Native()))

C.gtk_flow_box_unselect_child(_arg0, _arg1)
}
	


	
	type FlowBoxChild struct {
		Bin
		Buildable
		
	}

	// FlowBoxChildClass is an interface that the FlowBoxChild class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type FlowBoxChildClass interface {
		gextras.Objector
		_flowBoxChild()
	}

	func (FlowBoxChild) _flowBoxChild() {}

	
	func marshalFlowBoxChild(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapFlowBoxChild(obj), nil
	}
	

	
	// NewFlowBoxChild creates a new FlowBoxChild, to be used as a child of a
// FlowBox.
	func NewFlowBoxChild() FlowBoxChild {
var _cret *C.GtkWidget // in

_cret = C.gtk_flow_box_child_new()


var _flowBoxChild FlowBoxChild // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_flowBoxChild = FlowBoxChild{
Bin: Bin{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _flowBoxChild
}
	

	
	// Changed marks @child as changed, causing any state that depends on this to be
// updated. This affects sorting and filtering.
// 
// Note that calls to this method must be in sync with the data used for the
// sorting and filtering functions. For instance, if the list is mirroring some
// external data set, and *two* children changed in the external data set when
// you call gtk_flow_box_child_changed() on the first child, the sort function
// must only read the new data for the first of the two changed children,
// otherwise the resorting of the children will be wrong.
// 
// This generally means that if you don’t fully control the data model, you have
// to duplicate the data that affects the sorting and filtering functions into
// the widgets themselves. Another alternative is to call
// gtk_flow_box_invalidate_sort() on any model change, but that is more
// expensive.
	func (c FlowBoxChild) Changed()  {
var _arg0 *C.GtkFlowBoxChild // out

_arg0 = (*C.GtkFlowBoxChild)(unsafe.Pointer(c.Native()))

C.gtk_flow_box_child_changed(_arg0)
}
	
	// Index gets the current index of the @child in its FlowBox container.
	func (c FlowBoxChild) Index() int {
var _arg0 *C.GtkFlowBoxChild // out
var _cret C.gint // in

_arg0 = (*C.GtkFlowBoxChild)(unsafe.Pointer(c.Native()))

_cret = C.gtk_flow_box_child_get_index(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// IsSelected returns whether the @child is currently selected in its FlowBox
// container.
	func (c FlowBoxChild) IsSelected() bool {
var _arg0 *C.GtkFlowBoxChild // out
var _cret C.gboolean // in

_arg0 = (*C.GtkFlowBoxChild)(unsafe.Pointer(c.Native()))

_cret = C.gtk_flow_box_child_is_selected(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	


	// FontButton: the FontButton is a button which displays the currently selected
// font an allows to open a font chooser dialog to change the font. It is
// suitable widget for selecting a font in a preference dialog.
// 
// 
// CSS nodes
// 
// GtkFontButton has a single CSS node with name button and style class .font.
	type FontButton struct {
		Button
		Actionable
		Activatable
		Buildable
		FontChooser
		
	}

	// FontButtonClass is an interface that the FontButton class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type FontButtonClass interface {
		gextras.Objector
		_fontButton()
	}

	func (FontButton) _fontButton() {}

	
	func marshalFontButton(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapFontButton(obj), nil
	}
	

	
	// NewFontButton creates a new font picker widget.
	func NewFontButton() FontButton {
var _cret *C.GtkWidget // in

_cret = C.gtk_font_button_new()


var _fontButton FontButton // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_fontButton = FontButton{
Button: Button{
Bin: Bin{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
FontChooser: FontChooser{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _fontButton
}
	
	// NewFontButtonWithFont creates a new font picker widget.
	func NewFontButtonWithFont(fontname string) FontButton {
var _arg1 *C.gchar // out
var _cret *C.GtkWidget // in

_arg1 = (*C.gchar)(C.CString(fontname))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_font_button_new_with_font(_arg1)


var _fontButton FontButton // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_fontButton = FontButton{
Button: Button{
Bin: Bin{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
FontChooser: FontChooser{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _fontButton
}
	

	
	// FontName retrieves the name of the currently selected font. This name
// includes style and size information as well. If you want to render something
// with the font, use this string with pango_font_description_from_string() . If
// you’re interested in peeking certain values (family name, style, size,
// weight) just query these properties from the FontDescription object.
	func (f FontButton) FontName() string {
var _arg0 *C.GtkFontButton // out
var _cret *C.gchar // in

_arg0 = (*C.GtkFontButton)(unsafe.Pointer(f.Native()))

_cret = C.gtk_font_button_get_font_name(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// ShowSize returns whether the font size will be shown in the label.
	func (f FontButton) ShowSize() bool {
var _arg0 *C.GtkFontButton // out
var _cret C.gboolean // in

_arg0 = (*C.GtkFontButton)(unsafe.Pointer(f.Native()))

_cret = C.gtk_font_button_get_show_size(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ShowStyle returns whether the name of the font style will be shown in the
// label.
	func (f FontButton) ShowStyle() bool {
var _arg0 *C.GtkFontButton // out
var _cret C.gboolean // in

_arg0 = (*C.GtkFontButton)(unsafe.Pointer(f.Native()))

_cret = C.gtk_font_button_get_show_style(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Title retrieves the title of the font chooser dialog.
	func (f FontButton) Title() string {
var _arg0 *C.GtkFontButton // out
var _cret *C.gchar // in

_arg0 = (*C.GtkFontButton)(unsafe.Pointer(f.Native()))

_cret = C.gtk_font_button_get_title(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// UseFont returns whether the selected font is used in the label.
	func (f FontButton) UseFont() bool {
var _arg0 *C.GtkFontButton // out
var _cret C.gboolean // in

_arg0 = (*C.GtkFontButton)(unsafe.Pointer(f.Native()))

_cret = C.gtk_font_button_get_use_font(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// UseSize returns whether the selected size is used in the label.
	func (f FontButton) UseSize() bool {
var _arg0 *C.GtkFontButton // out
var _cret C.gboolean // in

_arg0 = (*C.GtkFontButton)(unsafe.Pointer(f.Native()))

_cret = C.gtk_font_button_get_use_size(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetFontName sets or updates the currently-displayed font in font picker
// dialog.
	func (f FontButton) SetFontName(fontname string) bool {
var _arg0 *C.GtkFontButton // out
var _arg1 *C.gchar // out
var _cret C.gboolean // in

_arg0 = (*C.GtkFontButton)(unsafe.Pointer(f.Native()))
_arg1 = (*C.gchar)(C.CString(fontname))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_font_button_set_font_name(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetShowSize: if @show_size is true, the font size will be displayed along
// with the name of the selected font.
	func (f FontButton) SetShowSize(showSize bool)  {
var _arg0 *C.GtkFontButton // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkFontButton)(unsafe.Pointer(f.Native()))
if showSize { _arg1 = C.TRUE }

C.gtk_font_button_set_show_size(_arg0, _arg1)
}
	
	// SetShowStyle: if @show_style is true, the font style will be displayed along
// with name of the selected font.
	func (f FontButton) SetShowStyle(showStyle bool)  {
var _arg0 *C.GtkFontButton // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkFontButton)(unsafe.Pointer(f.Native()))
if showStyle { _arg1 = C.TRUE }

C.gtk_font_button_set_show_style(_arg0, _arg1)
}
	
	// SetTitle sets the title for the font chooser dialog.
	func (f FontButton) SetTitle(title string)  {
var _arg0 *C.GtkFontButton // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkFontButton)(unsafe.Pointer(f.Native()))
_arg1 = (*C.gchar)(C.CString(title))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_font_button_set_title(_arg0, _arg1)
}
	
	// SetUseFont: if @use_font is true, the font name will be written using the
// selected font.
	func (f FontButton) SetUseFont(useFont bool)  {
var _arg0 *C.GtkFontButton // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkFontButton)(unsafe.Pointer(f.Native()))
if useFont { _arg1 = C.TRUE }

C.gtk_font_button_set_use_font(_arg0, _arg1)
}
	
	// SetUseSize: if @use_size is true, the font name will be written using the
// selected size.
	func (f FontButton) SetUseSize(useSize bool)  {
var _arg0 *C.GtkFontButton // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkFontButton)(unsafe.Pointer(f.Native()))
if useSize { _arg1 = C.TRUE }

C.gtk_font_button_set_use_size(_arg0, _arg1)
}
	


	// FontChooserDialog: the FontChooserDialog widget is a dialog for selecting a
// font. It implements the FontChooser interface.
// 
// 
// GtkFontChooserDialog as GtkBuildable
// 
// The GtkFontChooserDialog implementation of the Buildable interface exposes
// the buttons with the names “select_button” and “cancel_button”.
	type FontChooserDialog struct {
		Dialog
		Buildable
		FontChooser
		
	}

	// FontChooserDialogClass is an interface that the FontChooserDialog class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type FontChooserDialogClass interface {
		gextras.Objector
		_fontChooserDialog()
	}

	func (FontChooserDialog) _fontChooserDialog() {}

	
	func marshalFontChooserDialog(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapFontChooserDialog(obj), nil
	}
	

	
	// NewFontChooserDialog creates a new FontChooserDialog.
	func NewFontChooserDialog(title string, parent WindowClass) FontChooserDialog {
var _arg1 *C.gchar // out
var _arg2 *C.GtkWindow // out
var _cret *C.GtkWidget // in

_arg1 = (*C.gchar)(C.CString(title))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.GtkWindow)(unsafe.Pointer(parent.Native()))

_cret = C.gtk_font_chooser_dialog_new(_arg1, _arg2)


var _fontChooserDialog FontChooserDialog // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_fontChooserDialog = FontChooserDialog{
Dialog: Dialog{
Window: Window{
Bin: Bin{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
FontChooser: FontChooser{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _fontChooserDialog
}
	

	


	// FontChooserWidget: the FontChooserWidget widget lists the available fonts,
// styles and sizes, allowing the user to select a font. It is used in the
// FontChooserDialog widget to provide a dialog box for selecting fonts.
// 
// To set the font which is initially selected, use gtk_font_chooser_set_font()
// or gtk_font_chooser_set_font_desc().
// 
// To get the selected font use gtk_font_chooser_get_font() or
// gtk_font_chooser_get_font_desc().
// 
// To change the text which is shown in the preview area, use
// gtk_font_chooser_set_preview_text().
// 
// 
// CSS nodes
// 
// GtkFontChooserWidget has a single CSS node with name fontchooser.
	type FontChooserWidget struct {
		Box
		Buildable
		FontChooser
		Orientable
		
	}

	// FontChooserWidgetClass is an interface that the FontChooserWidget class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type FontChooserWidgetClass interface {
		gextras.Objector
		_fontChooserWidget()
	}

	func (FontChooserWidget) _fontChooserWidget() {}

	
	func marshalFontChooserWidget(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapFontChooserWidget(obj), nil
	}
	

	
	// NewFontChooserWidget creates a new FontChooserWidget.
	func NewFontChooserWidget() FontChooserWidget {
var _cret *C.GtkWidget // in

_cret = C.gtk_font_chooser_widget_new()


var _fontChooserWidget FontChooserWidget // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_fontChooserWidget = FontChooserWidget{
Box: Box{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
FontChooser: FontChooser{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _fontChooserWidget
}
	

	


	
	type FontSelection struct {
		Box
		Buildable
		Orientable
		
	}

	// FontSelectionClass is an interface that the FontSelection class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type FontSelectionClass interface {
		gextras.Objector
		_fontSelection()
	}

	func (FontSelection) _fontSelection() {}

	
	func marshalFontSelection(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapFontSelection(obj), nil
	}
	

	
	// NewFontSelection creates a new FontSelection.
	func NewFontSelection() FontSelection {
var _cret *C.GtkWidget // in

_cret = C.gtk_font_selection_new()


var _fontSelection FontSelection // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_fontSelection = FontSelection{
Box: Box{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _fontSelection
}
	

	
	// Face gets the FontFace representing the selected font group details (i.e.
// family, slant, weight, width, etc).
	func (f FontSelection) Face() pango.FontFace {
var _arg0 *C.GtkFontSelection // out
var _cret *C.PangoFontFace // in

_arg0 = (*C.GtkFontSelection)(unsafe.Pointer(f.Native()))

_cret = C.gtk_font_selection_get_face(_arg0)


var _fontFace pango.FontFace // out

_fontFace = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(pango.FontFace)

return _fontFace
}
	
	// FaceList: this returns the TreeView which lists all styles available for the
// selected font. For example, “Regular”, “Bold”, etc.
	func (f FontSelection) FaceList() Widget {
var _arg0 *C.GtkFontSelection // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkFontSelection)(unsafe.Pointer(f.Native()))

_cret = C.gtk_font_selection_get_face_list(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// Family gets the FontFamily representing the selected font family.
	func (f FontSelection) Family() pango.FontFamily {
var _arg0 *C.GtkFontSelection // out
var _cret *C.PangoFontFamily // in

_arg0 = (*C.GtkFontSelection)(unsafe.Pointer(f.Native()))

_cret = C.gtk_font_selection_get_family(_arg0)


var _fontFamily pango.FontFamily // out

_fontFamily = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(pango.FontFamily)

return _fontFamily
}
	
	// FamilyList: this returns the TreeView that lists font families, for example,
// “Sans”, “Serif”, etc.
	func (f FontSelection) FamilyList() Widget {
var _arg0 *C.GtkFontSelection // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkFontSelection)(unsafe.Pointer(f.Native()))

_cret = C.gtk_font_selection_get_family_list(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// FontName gets the currently-selected font name.
// 
// Note that this can be a different string than what you set with
// gtk_font_selection_set_font_name(), as the font selection widget may
// normalize font names and thus return a string with a different structure. For
// example, “Helvetica Italic Bold 12” could be normalized to “Helvetica Bold
// Italic 12”. Use pango_font_description_equal() if you want to compare two
// font descriptions.
	func (f FontSelection) FontName() string {
var _arg0 *C.GtkFontSelection // out
var _cret *C.gchar // in

_arg0 = (*C.GtkFontSelection)(unsafe.Pointer(f.Native()))

_cret = C.gtk_font_selection_get_font_name(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// PreviewEntry: this returns the Entry used to display the font as a preview.
	func (f FontSelection) PreviewEntry() Widget {
var _arg0 *C.GtkFontSelection // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkFontSelection)(unsafe.Pointer(f.Native()))

_cret = C.gtk_font_selection_get_preview_entry(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// PreviewText gets the text displayed in the preview area.
	func (f FontSelection) PreviewText() string {
var _arg0 *C.GtkFontSelection // out
var _cret *C.gchar // in

_arg0 = (*C.GtkFontSelection)(unsafe.Pointer(f.Native()))

_cret = C.gtk_font_selection_get_preview_text(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Size: the selected font size.
	func (f FontSelection) Size() int {
var _arg0 *C.GtkFontSelection // out
var _cret C.gint // in

_arg0 = (*C.GtkFontSelection)(unsafe.Pointer(f.Native()))

_cret = C.gtk_font_selection_get_size(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// SizeEntry: this returns the Entry used to allow the user to edit the font
// number manually instead of selecting it from the list of font sizes.
	func (f FontSelection) SizeEntry() Widget {
var _arg0 *C.GtkFontSelection // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkFontSelection)(unsafe.Pointer(f.Native()))

_cret = C.gtk_font_selection_get_size_entry(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// SizeList: this returns the TreeView used to list font sizes.
	func (f FontSelection) SizeList() Widget {
var _arg0 *C.GtkFontSelection // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkFontSelection)(unsafe.Pointer(f.Native()))

_cret = C.gtk_font_selection_get_size_list(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// SetFontName sets the currently-selected font.
// 
// Note that the @fontsel needs to know the screen in which it will appear for
// this to work; this can be guaranteed by simply making sure that the @fontsel
// is inserted in a toplevel window before you call this function.
	func (f FontSelection) SetFontName(fontname string) bool {
var _arg0 *C.GtkFontSelection // out
var _arg1 *C.gchar // out
var _cret C.gboolean // in

_arg0 = (*C.GtkFontSelection)(unsafe.Pointer(f.Native()))
_arg1 = (*C.gchar)(C.CString(fontname))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_font_selection_set_font_name(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetPreviewText sets the text displayed in the preview area. The @text is used
// to show how the selected font looks.
	func (f FontSelection) SetPreviewText(text string)  {
var _arg0 *C.GtkFontSelection // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkFontSelection)(unsafe.Pointer(f.Native()))
_arg1 = (*C.gchar)(C.CString(text))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_font_selection_set_preview_text(_arg0, _arg1)
}
	


	
	type FontSelectionDialog struct {
		Dialog
		Buildable
		
	}

	// FontSelectionDialogClass is an interface that the FontSelectionDialog class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type FontSelectionDialogClass interface {
		gextras.Objector
		_fontSelectionDialog()
	}

	func (FontSelectionDialog) _fontSelectionDialog() {}

	
	func marshalFontSelectionDialog(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapFontSelectionDialog(obj), nil
	}
	

	
	// NewFontSelectionDialog creates a new FontSelectionDialog.
	func NewFontSelectionDialog(title string) FontSelectionDialog {
var _arg1 *C.gchar // out
var _cret *C.GtkWidget // in

_arg1 = (*C.gchar)(C.CString(title))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_font_selection_dialog_new(_arg1)


var _fontSelectionDialog FontSelectionDialog // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_fontSelectionDialog = FontSelectionDialog{
Dialog: Dialog{
Window: Window{
Bin: Bin{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _fontSelectionDialog
}
	

	
	// CancelButton gets the “Cancel” button.
	func (f FontSelectionDialog) CancelButton() Widget {
var _arg0 *C.GtkFontSelectionDialog // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkFontSelectionDialog)(unsafe.Pointer(f.Native()))

_cret = C.gtk_font_selection_dialog_get_cancel_button(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// FontName gets the currently-selected font name.
// 
// Note that this can be a different string than what you set with
// gtk_font_selection_dialog_set_font_name(), as the font selection widget may
// normalize font names and thus return a string with a different structure. For
// example, “Helvetica Italic Bold 12” could be normalized to “Helvetica Bold
// Italic 12”. Use pango_font_description_equal() if you want to compare two
// font descriptions.
	func (f FontSelectionDialog) FontName() string {
var _arg0 *C.GtkFontSelectionDialog // out
var _cret *C.gchar // in

_arg0 = (*C.GtkFontSelectionDialog)(unsafe.Pointer(f.Native()))

_cret = C.gtk_font_selection_dialog_get_font_name(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// FontSelection retrieves the FontSelection widget embedded in the dialog.
	func (f FontSelectionDialog) FontSelection() Widget {
var _arg0 *C.GtkFontSelectionDialog // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkFontSelectionDialog)(unsafe.Pointer(f.Native()))

_cret = C.gtk_font_selection_dialog_get_font_selection(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// OkButton gets the “OK” button.
	func (f FontSelectionDialog) OkButton() Widget {
var _arg0 *C.GtkFontSelectionDialog // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkFontSelectionDialog)(unsafe.Pointer(f.Native()))

_cret = C.gtk_font_selection_dialog_get_ok_button(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// PreviewText gets the text displayed in the preview area.
	func (f FontSelectionDialog) PreviewText() string {
var _arg0 *C.GtkFontSelectionDialog // out
var _cret *C.gchar // in

_arg0 = (*C.GtkFontSelectionDialog)(unsafe.Pointer(f.Native()))

_cret = C.gtk_font_selection_dialog_get_preview_text(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// SetFontName sets the currently selected font.
	func (f FontSelectionDialog) SetFontName(fontname string) bool {
var _arg0 *C.GtkFontSelectionDialog // out
var _arg1 *C.gchar // out
var _cret C.gboolean // in

_arg0 = (*C.GtkFontSelectionDialog)(unsafe.Pointer(f.Native()))
_arg1 = (*C.gchar)(C.CString(fontname))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_font_selection_dialog_set_font_name(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetPreviewText sets the text displayed in the preview area.
	func (f FontSelectionDialog) SetPreviewText(text string)  {
var _arg0 *C.GtkFontSelectionDialog // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkFontSelectionDialog)(unsafe.Pointer(f.Native()))
_arg1 = (*C.gchar)(C.CString(text))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_font_selection_dialog_set_preview_text(_arg0, _arg1)
}
	


	// Frame: the frame widget is a bin that surrounds its child with a decorative
// frame and an optional label. If present, the label is drawn in a gap in the
// top side of the frame. The position of the label can be controlled with
// gtk_frame_set_label_align().
// 
// 
// GtkFrame as GtkBuildable
// 
// The GtkFrame implementation of the GtkBuildable interface supports placing a
// child in the label position by specifying “label” as the “type” attribute of
// a <child> element. A normal content child can be specified without specifying
// a <child> type attribute.
// 
// An example of a UI definition fragment with GtkFrame:
// 
//    <object class="GtkFrame">
//      <child type="label">
//        <object class="GtkLabel" id="frame-label"/>
//      </child>
//      <child>
//        <object class="GtkEntry" id="frame-content"/>
//      </child>
//    </object>
// 
// CSS nodes
// 
//    frame
//    ├── border[.flat]
//    ├── <label widget>
//    ╰── <child>
// 
// GtkFrame has a main CSS node named “frame” and a subnode named “border”. The
// “border” node is used to draw the visible border. You can set the appearance
// of the border using CSS properties like “border-style” on the “border” node.
// 
// The border node can be given the style class “.flat”, which is used by themes
// to disable drawing of the border. To do this from code, call
// gtk_frame_set_shadow_type() with GTK_SHADOW_NONE to add the “.flat” class or
// any other shadow type to remove it.
	type Frame struct {
		Bin
		Buildable
		
	}

	// FrameClass is an interface that the Frame class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type FrameClass interface {
		gextras.Objector
		_frame()
	}

	func (Frame) _frame() {}

	
	func marshalFrame(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapFrame(obj), nil
	}
	

	
	// NewFrame creates a new Frame, with optional label @label. If @label is nil,
// the label is omitted.
	func NewFrame(label string) Frame {
var _arg1 *C.gchar // out
var _cret *C.GtkWidget // in

_arg1 = (*C.gchar)(C.CString(label))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_frame_new(_arg1)


var _frame Frame // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_frame = Frame{
Bin: Bin{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _frame
}
	

	
	// Label: if the frame’s label widget is a Label, returns the text in the label
// widget. (The frame will have a Label for the label widget if a non-nil
// argument was passed to gtk_frame_new().)
	func (f Frame) Label() string {
var _arg0 *C.GtkFrame // out
var _cret *C.gchar // in

_arg0 = (*C.GtkFrame)(unsafe.Pointer(f.Native()))

_cret = C.gtk_frame_get_label(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// LabelAlign retrieves the X and Y alignment of the frame’s label. See
// gtk_frame_set_label_align().
	func (f Frame) LabelAlign() (xalign float32, yalign float32) {
var _arg0 *C.GtkFrame // out
var _arg1 C.gfloat // in
var _arg2 C.gfloat // in

_arg0 = (*C.GtkFrame)(unsafe.Pointer(f.Native()))

C.gtk_frame_get_label_align(_arg0, &_arg1, &_arg2)

var _xalign float32 // out
var _yalign float32 // out

_xalign = (float32)(_arg1)
_yalign = (float32)(_arg2)

return _xalign, _yalign
}
	
	// LabelWidget retrieves the label widget for the frame. See
// gtk_frame_set_label_widget().
	func (f Frame) LabelWidget() Widget {
var _arg0 *C.GtkFrame // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkFrame)(unsafe.Pointer(f.Native()))

_cret = C.gtk_frame_get_label_widget(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// ShadowType retrieves the shadow type of the frame. See
// gtk_frame_set_shadow_type().
	func (f Frame) ShadowType() ShadowType {
var _arg0 *C.GtkFrame // out
var _cret C.GtkShadowType // in

_arg0 = (*C.GtkFrame)(unsafe.Pointer(f.Native()))

_cret = C.gtk_frame_get_shadow_type(_arg0)


var _shadowType ShadowType // out

_shadowType = ShadowType(_cret)

return _shadowType
}
	
	// SetLabel removes the current Frame:label-widget. If @label is not nil,
// creates a new Label with that text and adds it as the Frame:label-widget.
	func (f Frame) SetLabel(label string)  {
var _arg0 *C.GtkFrame // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkFrame)(unsafe.Pointer(f.Native()))
_arg1 = (*C.gchar)(C.CString(label))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_frame_set_label(_arg0, _arg1)
}
	
	// SetLabelAlign sets the alignment of the frame widget’s label. The default
// values for a newly created frame are 0.0 and 0.5.
	func (f Frame) SetLabelAlign(xalign float32, yalign float32)  {
var _arg0 *C.GtkFrame // out
var _arg1 C.gfloat // out
var _arg2 C.gfloat // out

_arg0 = (*C.GtkFrame)(unsafe.Pointer(f.Native()))
_arg1 = (C.gfloat)(xalign)
_arg2 = (C.gfloat)(yalign)

C.gtk_frame_set_label_align(_arg0, _arg1, _arg2)
}
	
	// SetLabelWidget sets the Frame:label-widget for the frame. This is the widget
// that will appear embedded in the top edge of the frame as a title.
	func (f Frame) SetLabelWidget(labelWidget WidgetClass)  {
var _arg0 *C.GtkFrame // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkFrame)(unsafe.Pointer(f.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(labelWidget.Native()))

C.gtk_frame_set_label_widget(_arg0, _arg1)
}
	
	// SetShadowType sets the Frame:shadow-type for @frame, i.e. whether it is drawn
// without (GTK_SHADOW_NONE) or with (other values) a visible border. Values
// other than GTK_SHADOW_NONE are treated identically by GtkFrame. The chosen
// type is applied by removing or adding the .flat class to the CSS node named
// border.
	func (f Frame) SetShadowType(typ ShadowType)  {
var _arg0 *C.GtkFrame // out
var _arg1 C.GtkShadowType // out

_arg0 = (*C.GtkFrame)(unsafe.Pointer(f.Native()))
_arg1 = (C.GtkShadowType)(typ)

C.gtk_frame_set_shadow_type(_arg0, _arg1)
}
	


	// GLArea is a widget that allows drawing with OpenGL.
// 
// GLArea sets up its own GLContext for the window it creates, and creates a
// custom GL framebuffer that the widget will do GL rendering onto. It also
// ensures that this framebuffer is the default GL rendering target when
// rendering.
// 
// In order to draw, you have to connect to the GLArea::render signal, or
// subclass GLArea and override the @GtkGLAreaClass.render() virtual function.
// 
// The GLArea widget ensures that the GLContext is associated with the widget's
// drawing area, and it is kept updated when the size and position of the
// drawing area changes.
// 
// Drawing with GtkGLArea ##
// 
// The simplest way to draw using OpenGL commands in a GLArea is to create a
// widget instance and connect to the GLArea::render signal:
// 
//      static void
//      on_realize (GtkGLarea *area)
//      {
//        // We need to make the context current if we want to
//        // call GL API
//        gtk_gl_area_make_current (area);
// 
//        // If there were errors during the initialization or
//        // when trying to make the context current, this
//        // function will return a #GError for you to catch
//        if (gtk_gl_area_get_error (area) != NULL)
//          return;
// 
//        // You can also use gtk_gl_area_set_error() in order
//        // to show eventual initialization errors on the
//        // GtkGLArea widget itself
//        GError *internal_error = NULL;
//        init_buffer_objects (&error);
//        if (error != NULL)
//          {
//            gtk_gl_area_set_error (area, error);
//            g_error_free (error);
//            return;
//          }
// 
//        init_shaders (&error);
//        if (error != NULL)
//          {
//            gtk_gl_area_set_error (area, error);
//            g_error_free (error);
//            return;
//          }
//      }
// 
// If you need to change the options for creating the GLContext you should use
// the GLArea::create-context signal.
	type GLArea struct {
		Widget
		Buildable
		
	}

	// GLAreaClass is an interface that the GLArea class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type GLAreaClass interface {
		gextras.Objector
		_glArea()
	}

	func (GLArea) _glArea() {}

	
	func marshalGLArea(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapGLArea(obj), nil
	}
	

	
	// NewGLArea creates a new GLArea widget.
	func NewGLArea() GLArea {
var _cret *C.GtkWidget // in

_cret = C.gtk_gl_area_new()


var _glArea GLArea // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_glArea = GLArea{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _glArea
}
	

	
	// AttachBuffers ensures that the @area framebuffer object is made the current
// draw and read target, and that all the required buffers for the @area are
// created and bound to the frambuffer.
// 
// This function is automatically called before emitting the GLArea::render
// signal, and doesn't normally need to be called by application code.
	func (a GLArea) AttachBuffers()  {
var _arg0 *C.GtkGLArea // out

_arg0 = (*C.GtkGLArea)(unsafe.Pointer(a.Native()))

C.gtk_gl_area_attach_buffers(_arg0)
}
	
	// AutoRender returns whether the area is in auto render mode or not.
	func (a GLArea) AutoRender() bool {
var _arg0 *C.GtkGLArea // out
var _cret C.gboolean // in

_arg0 = (*C.GtkGLArea)(unsafe.Pointer(a.Native()))

_cret = C.gtk_gl_area_get_auto_render(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Context retrieves the GLContext used by @area.
	func (a GLArea) Context() gdk.GLContext {
var _arg0 *C.GtkGLArea // out
var _cret *C.GdkGLContext // in

_arg0 = (*C.GtkGLArea)(unsafe.Pointer(a.Native()))

_cret = C.gtk_gl_area_get_context(_arg0)


var _glContext gdk.GLContext // out

_glContext = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.GLContext)

return _glContext
}
	
	// Error gets the current error set on the @area.
	func (a GLArea) Error() error {
var _arg0 *C.GtkGLArea // out
var _cret *C.GError // in

_arg0 = (*C.GtkGLArea)(unsafe.Pointer(a.Native()))

_cret = C.gtk_gl_area_get_error(_arg0)


var _err error // out

_err = gerror.Take(unsafe.Pointer(_cret))

return _err
}
	
	// HasAlpha returns whether the area has an alpha component.
	func (a GLArea) HasAlpha() bool {
var _arg0 *C.GtkGLArea // out
var _cret C.gboolean // in

_arg0 = (*C.GtkGLArea)(unsafe.Pointer(a.Native()))

_cret = C.gtk_gl_area_get_has_alpha(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// HasDepthBuffer returns whether the area has a depth buffer.
	func (a GLArea) HasDepthBuffer() bool {
var _arg0 *C.GtkGLArea // out
var _cret C.gboolean // in

_arg0 = (*C.GtkGLArea)(unsafe.Pointer(a.Native()))

_cret = C.gtk_gl_area_get_has_depth_buffer(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// HasStencilBuffer returns whether the area has a stencil buffer.
	func (a GLArea) HasStencilBuffer() bool {
var _arg0 *C.GtkGLArea // out
var _cret C.gboolean // in

_arg0 = (*C.GtkGLArea)(unsafe.Pointer(a.Native()))

_cret = C.gtk_gl_area_get_has_stencil_buffer(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// RequiredVersion retrieves the required version of OpenGL set using
// gtk_gl_area_set_required_version().
	func (a GLArea) RequiredVersion() (major int, minor int) {
var _arg0 *C.GtkGLArea // out
var _arg1 C.gint // in
var _arg2 C.gint // in

_arg0 = (*C.GtkGLArea)(unsafe.Pointer(a.Native()))

C.gtk_gl_area_get_required_version(_arg0, &_arg1, &_arg2)

var _major int // out
var _minor int // out

_major = (int)(_arg1)
_minor = (int)(_arg2)

return _major, _minor
}
	
	// UseES retrieves the value set by gtk_gl_area_set_use_es().
	func (a GLArea) UseES() bool {
var _arg0 *C.GtkGLArea // out
var _cret C.gboolean // in

_arg0 = (*C.GtkGLArea)(unsafe.Pointer(a.Native()))

_cret = C.gtk_gl_area_get_use_es(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// MakeCurrent ensures that the GLContext used by @area is associated with the
// GLArea.
// 
// This function is automatically called before emitting the GLArea::render
// signal, and doesn't normally need to be called by application code.
	func (a GLArea) MakeCurrent()  {
var _arg0 *C.GtkGLArea // out

_arg0 = (*C.GtkGLArea)(unsafe.Pointer(a.Native()))

C.gtk_gl_area_make_current(_arg0)
}
	
	// QueueRender marks the currently rendered data (if any) as invalid, and queues
// a redraw of the widget, ensuring that the GLArea::render signal is emitted
// during the draw.
// 
// This is only needed when the gtk_gl_area_set_auto_render() has been called
// with a false value. The default behaviour is to emit GLArea::render on each
// draw.
	func (a GLArea) QueueRender()  {
var _arg0 *C.GtkGLArea // out

_arg0 = (*C.GtkGLArea)(unsafe.Pointer(a.Native()))

C.gtk_gl_area_queue_render(_arg0)
}
	
	// SetAutoRender: if @auto_render is true the GLArea::render signal will be
// emitted every time the widget draws. This is the default and is useful if
// drawing the widget is faster.
// 
// If @auto_render is false the data from previous rendering is kept around and
// will be used for drawing the widget the next time, unless the window is
// resized. In order to force a rendering gtk_gl_area_queue_render() must be
// called. This mode is useful when the scene changes seldomly, but takes a long
// time to redraw.
	func (a GLArea) SetAutoRender(autoRender bool)  {
var _arg0 *C.GtkGLArea // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkGLArea)(unsafe.Pointer(a.Native()))
if autoRender { _arg1 = C.TRUE }

C.gtk_gl_area_set_auto_render(_arg0, _arg1)
}
	
	// SetError sets an error on the area which will be shown instead of the GL
// rendering. This is useful in the GLArea::create-context signal if GL context
// creation fails.
	func (a GLArea) SetError(err error)  {
var _arg0 *C.GtkGLArea // out
var _arg1 *C.GError // out

_arg0 = (*C.GtkGLArea)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GError)(gerror.New(unsafe.Pointer(err)))
defer C.g_error_free(_arg1)

C.gtk_gl_area_set_error(_arg0, _arg1)
}
	
	// SetHasAlpha: if @has_alpha is true the buffer allocated by the widget will
// have an alpha channel component, and when rendering to the window the result
// will be composited over whatever is below the widget.
// 
// If @has_alpha is false there will be no alpha channel, and the buffer will
// fully replace anything below the widget.
	func (a GLArea) SetHasAlpha(hasAlpha bool)  {
var _arg0 *C.GtkGLArea // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkGLArea)(unsafe.Pointer(a.Native()))
if hasAlpha { _arg1 = C.TRUE }

C.gtk_gl_area_set_has_alpha(_arg0, _arg1)
}
	
	// SetHasDepthBuffer: if @has_depth_buffer is true the widget will allocate and
// enable a depth buffer for the target framebuffer. Otherwise there will be
// none.
	func (a GLArea) SetHasDepthBuffer(hasDepthBuffer bool)  {
var _arg0 *C.GtkGLArea // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkGLArea)(unsafe.Pointer(a.Native()))
if hasDepthBuffer { _arg1 = C.TRUE }

C.gtk_gl_area_set_has_depth_buffer(_arg0, _arg1)
}
	
	// SetHasStencilBuffer: if @has_stencil_buffer is true the widget will allocate
// and enable a stencil buffer for the target framebuffer. Otherwise there will
// be none.
	func (a GLArea) SetHasStencilBuffer(hasStencilBuffer bool)  {
var _arg0 *C.GtkGLArea // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkGLArea)(unsafe.Pointer(a.Native()))
if hasStencilBuffer { _arg1 = C.TRUE }

C.gtk_gl_area_set_has_stencil_buffer(_arg0, _arg1)
}
	
	// SetRequiredVersion sets the required version of OpenGL to be used when
// creating the context for the widget.
// 
// This function must be called before the area has been realized.
	func (a GLArea) SetRequiredVersion(major int, minor int)  {
var _arg0 *C.GtkGLArea // out
var _arg1 C.gint // out
var _arg2 C.gint // out

_arg0 = (*C.GtkGLArea)(unsafe.Pointer(a.Native()))
_arg1 = (C.gint)(major)
_arg2 = (C.gint)(minor)

C.gtk_gl_area_set_required_version(_arg0, _arg1, _arg2)
}
	
	// SetUseES sets whether the @area should create an OpenGL or an OpenGL ES
// context.
// 
// You should check the capabilities of the GLContext before drawing with either
// API.
	func (a GLArea) SetUseES(useEs bool)  {
var _arg0 *C.GtkGLArea // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkGLArea)(unsafe.Pointer(a.Native()))
if useEs { _arg1 = C.TRUE }

C.gtk_gl_area_set_use_es(_arg0, _arg1)
}
	


	// Gesture is the base object for gesture recognition, although this object is
// quite generalized to serve as a base for multi-touch gestures, it is suitable
// to implement single-touch and pointer-based gestures (using the special nil
// EventSequence value for these).
// 
// The number of touches that a Gesture need to be recognized is controlled by
// the Gesture:n-points property, if a gesture is keeping track of less or more
// than that number of sequences, it won't check wether the gesture is
// recognized.
// 
// As soon as the gesture has the expected number of touches, the gesture will
// run the Gesture::check signal regularly on input events until the gesture is
// recognized, the criteria to consider a gesture as "recognized" is left to
// Gesture subclasses.
// 
// A recognized gesture will then emit the following signals: - Gesture::begin
// when the gesture is recognized. - A number of Gesture::update, whenever an
// input event is processed. - Gesture::end when the gesture is no longer
// recognized.
// 
// 
// Event propagation
// 
// In order to receive events, a gesture needs to either set a propagation phase
// through gtk_event_controller_set_propagation_phase(), or feed those manually
// through gtk_event_controller_handle_event().
// 
// In the capture phase, events are propagated from the toplevel down to the
// target widget, and gestures that are attached to containers above the widget
// get a chance to interact with the event before it reaches the target.
// 
// After the capture phase, GTK+ emits the traditional
// Widget::button-press-event, Widget::button-release-event,
// Widget::touch-event, etc signals. Gestures with the GTK_PHASE_TARGET phase
// are fed events from the default Widget::event handlers.
// 
// In the bubble phase, events are propagated up from the target widget to the
// toplevel, and gestures that are attached to containers above the widget get a
// chance to interact with events that have not been handled yet.
// 
// 
// States of a sequence
// 
// Whenever input interaction happens, a single event may trigger a cascade of
// Gestures, both across the parents of the widget receiving the event and in
// parallel within an individual widget. It is a responsibility of the widgets
// using those gestures to set the state of touch sequences accordingly in order
// to enable cooperation of gestures around the EventSequences triggering those.
// 
// Within a widget, gestures can be grouped through gtk_gesture_group(), grouped
// gestures synchronize the state of sequences, so calling
// gtk_gesture_set_sequence_state() on one will effectively propagate the state
// throughout the group.
// 
// By default, all sequences start out in the K_EVENT_SEQUENCE_NONE state,
// sequences in this state trigger the gesture event handler, but event
// propagation will continue unstopped by gestures.
// 
// If a sequence enters into the K_EVENT_SEQUENCE_DENIED state, the gesture
// group will effectively ignore the sequence, letting events go unstopped
// through the gesture, but the "slot" will still remain occupied while the
// touch is active.
// 
// If a sequence enters in the K_EVENT_SEQUENCE_CLAIMED state, the gesture group
// will grab all interaction on the sequence, by: - Setting the same sequence to
// K_EVENT_SEQUENCE_DENIED on every other gesture group within the widget, and
// every gesture on parent widgets in the propagation chain. - calling
// Gesture::cancel on every gesture in widgets underneath in the propagation
// chain. - Stopping event propagation after the gesture group handles the
// event.
// 
// Note: if a sequence is set early to K_EVENT_SEQUENCE_CLAIMED on
// K_TOUCH_BEGIN/K_BUTTON_PRESS (so those events are captured before reaching
// the event widget, this implies K_PHASE_CAPTURE), one similar event will
// emulated if the sequence changes to K_EVENT_SEQUENCE_DENIED. This way event
// coherence is preserved before event propagation is unstopped again.
// 
// Sequence states can't be changed freely, see gtk_gesture_set_sequence_state()
// to know about the possible lifetimes of a EventSequence.
// 
// 
// Touchpad gestures
// 
// On the platforms that support it, Gesture will handle transparently touchpad
// gesture events. The only precautions users of Gesture should do to enable
// this support are: - Enabling GDK_TOUCHPAD_GESTURE_MASK on their Windows - If
// the gesture has GTK_PHASE_NONE, ensuring events of type GDK_TOUCHPAD_SWIPE
// and GDK_TOUCHPAD_PINCH are handled by the Gesture
	type Gesture struct {
		EventController
		
	}

	// GestureClass is an interface that the Gesture class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type GestureClass interface {
		gextras.Objector
		_gesture()
	}

	func (Gesture) _gesture() {}

	
	func marshalGesture(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapGesture(obj), nil
	}
	

	

	
	// BoundingBox: if there are touch sequences being currently handled by
// @gesture, this function returns true and fills in @rect with the bounding box
// containing all active touches. Otherwise, false will be returned.
// 
// Note: This function will yield unexpected results on touchpad gestures. Since
// there is no correlation between physical and pixel distances, these will look
// as if constrained in an infinitely small area, @rect width and height will
// thus be 0 regardless of the number of touchpoints.
	func (g Gesture) BoundingBox() (gdk.Rectangle, bool) {
var _arg0 *C.GtkGesture // out
var _rect gdk.Rectangle
var _cret C.gboolean // in

_arg0 = (*C.GtkGesture)(unsafe.Pointer(g.Native()))

_cret = C.gtk_gesture_get_bounding_box(_arg0, (*C.GdkRectangle)(unsafe.Pointer(&_rect)))



var _ok bool // out


if _cret != 0 { _ok = true }

return _rect, _ok
}
	
	// BoundingBoxCenter: if there are touch sequences being currently handled by
// @gesture, this function returns true and fills in @x and @y with the center
// of the bounding box containing all active touches. Otherwise, false will be
// returned.
	func (g Gesture) BoundingBoxCenter() (x float64, y float64, ok bool) {
var _arg0 *C.GtkGesture // out
var _arg1 C.gdouble // in
var _arg2 C.gdouble // in
var _cret C.gboolean // in

_arg0 = (*C.GtkGesture)(unsafe.Pointer(g.Native()))

_cret = C.gtk_gesture_get_bounding_box_center(_arg0, &_arg1, &_arg2)


var _x float64 // out
var _y float64 // out
var _ok bool // out

_x = (float64)(_arg1)
_y = (float64)(_arg2)
if _cret != 0 { _ok = true }

return _x, _y, _ok
}
	
	// Device returns the master Device that is currently operating on @gesture, or
// nil if the gesture is not being interacted.
	func (g Gesture) Device() gdk.Device {
var _arg0 *C.GtkGesture // out
var _cret *C.GdkDevice // in

_arg0 = (*C.GtkGesture)(unsafe.Pointer(g.Native()))

_cret = C.gtk_gesture_get_device(_arg0)


var _device gdk.Device // out

_device = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Device)

return _device
}
	
	// LastUpdatedSequence returns the EventSequence that was last updated on
// @gesture.
	func (g Gesture) LastUpdatedSequence() *gdk.EventSequence {
var _arg0 *C.GtkGesture // out
var _cret *C.GdkEventSequence // in

_arg0 = (*C.GtkGesture)(unsafe.Pointer(g.Native()))

_cret = C.gtk_gesture_get_last_updated_sequence(_arg0)


var _eventSequence *gdk.EventSequence // out

_eventSequence = *(**gdk.EventSequence)(unsafe.Pointer(&_cret))

return _eventSequence
}
	
	// Point: if @sequence is currently being interpreted by @gesture, this function
// returns true and fills in @x and @y with the last coordinates stored for that
// event sequence. The coordinates are always relative to the widget allocation.
	func (g Gesture) Point(sequence *gdk.EventSequence) (x float64, y float64, ok bool) {
var _arg0 *C.GtkGesture // out
var _arg1 *C.GdkEventSequence // out
var _arg2 C.gdouble // in
var _arg3 C.gdouble // in
var _cret C.gboolean // in

_arg0 = (*C.GtkGesture)(unsafe.Pointer(g.Native()))
_arg1 = (*C.GdkEventSequence)(unsafe.Pointer(sequence.Native()))

_cret = C.gtk_gesture_get_point(_arg0, _arg1, &_arg2, &_arg3)


var _x float64 // out
var _y float64 // out
var _ok bool // out

_x = (float64)(_arg2)
_y = (float64)(_arg3)
if _cret != 0 { _ok = true }

return _x, _y, _ok
}
	
	// SequenceState returns the @sequence state, as seen by @gesture.
	func (g Gesture) SequenceState(sequence *gdk.EventSequence) EventSequenceState {
var _arg0 *C.GtkGesture // out
var _arg1 *C.GdkEventSequence // out
var _cret C.GtkEventSequenceState // in

_arg0 = (*C.GtkGesture)(unsafe.Pointer(g.Native()))
_arg1 = (*C.GdkEventSequence)(unsafe.Pointer(sequence.Native()))

_cret = C.gtk_gesture_get_sequence_state(_arg0, _arg1)


var _eventSequenceState EventSequenceState // out

_eventSequenceState = EventSequenceState(_cret)

return _eventSequenceState
}
	
	// Window returns the user-defined window that receives the events handled by
// @gesture. See gtk_gesture_set_window() for more information.
	func (g Gesture) Window() gdk.Window {
var _arg0 *C.GtkGesture // out
var _cret *C.GdkWindow // in

_arg0 = (*C.GtkGesture)(unsafe.Pointer(g.Native()))

_cret = C.gtk_gesture_get_window(_arg0)


var _window gdk.Window // out

_window = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Window)

return _window
}
	
	// Group adds @gesture to the same group than @group_gesture. Gestures are by
// default isolated in their own groups.
// 
// When gestures are grouped, the state of EventSequences is kept in sync for
// all of those, so calling gtk_gesture_set_sequence_state(), on one will
// transfer the same value to the others.
// 
// Groups also perform an "implicit grabbing" of sequences, if a EventSequence
// state is set to K_EVENT_SEQUENCE_CLAIMED on one group, every other gesture
// group attached to the same Widget will switch the state for that sequence to
// K_EVENT_SEQUENCE_DENIED.
	func (g Gesture) Group(gesture GestureClass)  {
var _arg0 *C.GtkGesture // out
var _arg1 *C.GtkGesture // out

_arg0 = (*C.GtkGesture)(unsafe.Pointer(g.Native()))
_arg1 = (*C.GtkGesture)(unsafe.Pointer(gesture.Native()))

C.gtk_gesture_group(_arg0, _arg1)
}
	
	// HandlesSequence returns true if @gesture is currently handling events
// corresponding to @sequence.
	func (g Gesture) HandlesSequence(sequence *gdk.EventSequence) bool {
var _arg0 *C.GtkGesture // out
var _arg1 *C.GdkEventSequence // out
var _cret C.gboolean // in

_arg0 = (*C.GtkGesture)(unsafe.Pointer(g.Native()))
_arg1 = (*C.GdkEventSequence)(unsafe.Pointer(sequence.Native()))

_cret = C.gtk_gesture_handles_sequence(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsActive returns true if the gesture is currently active. A gesture is active
// meanwhile there are touch sequences interacting with it.
	func (g Gesture) IsActive() bool {
var _arg0 *C.GtkGesture // out
var _cret C.gboolean // in

_arg0 = (*C.GtkGesture)(unsafe.Pointer(g.Native()))

_cret = C.gtk_gesture_is_active(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsGroupedWith returns true if both gestures pertain to the same group.
	func (g Gesture) IsGroupedWith(other GestureClass) bool {
var _arg0 *C.GtkGesture // out
var _arg1 *C.GtkGesture // out
var _cret C.gboolean // in

_arg0 = (*C.GtkGesture)(unsafe.Pointer(g.Native()))
_arg1 = (*C.GtkGesture)(unsafe.Pointer(other.Native()))

_cret = C.gtk_gesture_is_grouped_with(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsRecognized returns true if the gesture is currently recognized. A gesture
// is recognized if there are as many interacting touch sequences as required by
// @gesture, and Gesture::check returned true for the sequences being currently
// interpreted.
	func (g Gesture) IsRecognized() bool {
var _arg0 *C.GtkGesture // out
var _cret C.gboolean // in

_arg0 = (*C.GtkGesture)(unsafe.Pointer(g.Native()))

_cret = C.gtk_gesture_is_recognized(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetSequenceState sets the state of @sequence in @gesture. Sequences start in
// state K_EVENT_SEQUENCE_NONE, and whenever they change state, they can never
// go back to that state. Likewise, sequences in state K_EVENT_SEQUENCE_DENIED
// cannot turn back to a not denied state. With these rules, the lifetime of an
// event sequence is constrained to the next four:
// 
// * None * None → Denied * None → Claimed * None → Claimed → Denied
// 
// Note: Due to event handling ordering, it may be unsafe to set the state on
// another gesture within a Gesture::begin signal handler, as the callback might
// be executed before the other gesture knows about the sequence. A safe way to
// perform this could be:
// 
//    static void
//    first_gesture_begin_cb (GtkGesture       *first_gesture,
//                            GdkEventSequence *sequence,
//                            gpointer          user_data)
//    {
//      gtk_gesture_set_sequence_state (first_gesture, sequence, GTK_EVENT_SEQUENCE_CLAIMED);
//      gtk_gesture_set_sequence_state (second_gesture, sequence, GTK_EVENT_SEQUENCE_DENIED);
//    }
// 
//    static void
//    second_gesture_begin_cb (GtkGesture       *second_gesture,
//                             GdkEventSequence *sequence,
//                             gpointer          user_data)
//    {
//      if (gtk_gesture_get_sequence_state (first_gesture, sequence) == GTK_EVENT_SEQUENCE_CLAIMED)
//        gtk_gesture_set_sequence_state (second_gesture, sequence, GTK_EVENT_SEQUENCE_DENIED);
//    }
// 
// If both gestures are in the same group, just set the state on the gesture
// emitting the event, the sequence will be already be initialized to the
// group's global state when the second gesture processes the event.
	func (g Gesture) SetSequenceState(sequence *gdk.EventSequence, state EventSequenceState) bool {
var _arg0 *C.GtkGesture // out
var _arg1 *C.GdkEventSequence // out
var _arg2 C.GtkEventSequenceState // out
var _cret C.gboolean // in

_arg0 = (*C.GtkGesture)(unsafe.Pointer(g.Native()))
_arg1 = (*C.GdkEventSequence)(unsafe.Pointer(sequence.Native()))
_arg2 = (C.GtkEventSequenceState)(state)

_cret = C.gtk_gesture_set_sequence_state(_arg0, _arg1, _arg2)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetState sets the state of all sequences that @gesture is currently
// interacting with. See gtk_gesture_set_sequence_state() for more details on
// sequence states.
	func (g Gesture) SetState(state EventSequenceState) bool {
var _arg0 *C.GtkGesture // out
var _arg1 C.GtkEventSequenceState // out
var _cret C.gboolean // in

_arg0 = (*C.GtkGesture)(unsafe.Pointer(g.Native()))
_arg1 = (C.GtkEventSequenceState)(state)

_cret = C.gtk_gesture_set_state(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetWindow sets a specific window to receive events about, so @gesture will
// effectively handle only events targeting @window, or a child of it. @window
// must pertain to gtk_event_controller_get_widget().
	func (g Gesture) SetWindow(window gdk.WindowClass)  {
var _arg0 *C.GtkGesture // out
var _arg1 *C.GdkWindow // out

_arg0 = (*C.GtkGesture)(unsafe.Pointer(g.Native()))
_arg1 = (*C.GdkWindow)(unsafe.Pointer(window.Native()))

C.gtk_gesture_set_window(_arg0, _arg1)
}
	
	// Ungroup separates @gesture into an isolated group.
	func (g Gesture) Ungroup()  {
var _arg0 *C.GtkGesture // out

_arg0 = (*C.GtkGesture)(unsafe.Pointer(g.Native()))

C.gtk_gesture_ungroup(_arg0)
}
	


	// GestureDrag is a Gesture implementation that recognizes drag operations. The
// drag operation itself can be tracked throught the GestureDrag::drag-begin,
// GestureDrag::drag-update and GestureDrag::drag-end signals, or the relevant
// coordinates be extracted through gtk_gesture_drag_get_offset() and
// gtk_gesture_drag_get_start_point().
	type GestureDrag struct {
		GestureSingle
		
	}

	// GestureDragClass is an interface that the GestureDrag class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type GestureDragClass interface {
		gextras.Objector
		_gestureDrag()
	}

	func (GestureDrag) _gestureDrag() {}

	
	func marshalGestureDrag(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapGestureDrag(obj), nil
	}
	

	
	// NewGestureDrag returns a newly created Gesture that recognizes drags.
	func NewGestureDrag(widget WidgetClass) GestureDrag {
var _arg1 *C.GtkWidget // out
var _cret *C.GtkGesture // in

_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

_cret = C.gtk_gesture_drag_new(_arg1)


var _gestureDrag GestureDrag // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_gestureDrag = GestureDrag{
GestureSingle: GestureSingle{
Gesture: Gesture{
EventController: EventController{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
}
}

return _gestureDrag
}
	

	
	// Offset: if the @gesture is active, this function returns true and fills in @x
// and @y with the coordinates of the current point, as an offset to the
// starting drag point.
	func (g GestureDrag) Offset() (x float64, y float64, ok bool) {
var _arg0 *C.GtkGestureDrag // out
var _arg1 C.gdouble // in
var _arg2 C.gdouble // in
var _cret C.gboolean // in

_arg0 = (*C.GtkGestureDrag)(unsafe.Pointer(g.Native()))

_cret = C.gtk_gesture_drag_get_offset(_arg0, &_arg1, &_arg2)


var _x float64 // out
var _y float64 // out
var _ok bool // out

_x = (float64)(_arg1)
_y = (float64)(_arg2)
if _cret != 0 { _ok = true }

return _x, _y, _ok
}
	
	// StartPoint: if the @gesture is active, this function returns true and fills
// in @x and @y with the drag start coordinates, in window-relative coordinates.
	func (g GestureDrag) StartPoint() (x float64, y float64, ok bool) {
var _arg0 *C.GtkGestureDrag // out
var _arg1 C.gdouble // in
var _arg2 C.gdouble // in
var _cret C.gboolean // in

_arg0 = (*C.GtkGestureDrag)(unsafe.Pointer(g.Native()))

_cret = C.gtk_gesture_drag_get_start_point(_arg0, &_arg1, &_arg2)


var _x float64 // out
var _y float64 // out
var _ok bool // out

_x = (float64)(_arg1)
_y = (float64)(_arg2)
if _cret != 0 { _ok = true }

return _x, _y, _ok
}
	


	// GestureLongPress is a Gesture implementation able to recognize long presses,
// triggering the GestureLongPress::pressed after the timeout is exceeded.
// 
// If the touchpoint is lifted before the timeout passes, or if it drifts too
// far of the initial press point, the GestureLongPress::cancelled signal will
// be emitted.
	type GestureLongPress struct {
		GestureSingle
		
	}

	// GestureLongPressClass is an interface that the GestureLongPress class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type GestureLongPressClass interface {
		gextras.Objector
		_gestureLongPress()
	}

	func (GestureLongPress) _gestureLongPress() {}

	
	func marshalGestureLongPress(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapGestureLongPress(obj), nil
	}
	

	
	// NewGestureLongPress returns a newly created Gesture that recognizes long
// presses.
	func NewGestureLongPress(widget WidgetClass) GestureLongPress {
var _arg1 *C.GtkWidget // out
var _cret *C.GtkGesture // in

_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

_cret = C.gtk_gesture_long_press_new(_arg1)


var _gestureLongPress GestureLongPress // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_gestureLongPress = GestureLongPress{
GestureSingle: GestureSingle{
Gesture: Gesture{
EventController: EventController{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
}
}

return _gestureLongPress
}
	

	


	// GestureMultiPress is a Gesture implementation able to recognize multiple
// clicks on a nearby zone, which can be listened for through the
// GestureMultiPress::pressed signal. Whenever time or distance between clicks
// exceed the GTK+ defaults, GestureMultiPress::stopped is emitted, and the
// click counter is reset.
// 
// Callers may also restrict the area that is considered valid for a >1
// touch/button press through gtk_gesture_multi_press_set_area(), so any click
// happening outside that area is considered to be a first click of its own.
	type GestureMultiPress struct {
		GestureSingle
		
	}

	// GestureMultiPressClass is an interface that the GestureMultiPress class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type GestureMultiPressClass interface {
		gextras.Objector
		_gestureMultiPress()
	}

	func (GestureMultiPress) _gestureMultiPress() {}

	
	func marshalGestureMultiPress(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapGestureMultiPress(obj), nil
	}
	

	
	// NewGestureMultiPress returns a newly created Gesture that recognizes single
// and multiple presses.
	func NewGestureMultiPress(widget WidgetClass) GestureMultiPress {
var _arg1 *C.GtkWidget // out
var _cret *C.GtkGesture // in

_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

_cret = C.gtk_gesture_multi_press_new(_arg1)


var _gestureMultiPress GestureMultiPress // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_gestureMultiPress = GestureMultiPress{
GestureSingle: GestureSingle{
Gesture: Gesture{
EventController: EventController{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
}
}

return _gestureMultiPress
}
	

	
	// Area: if an area was set through gtk_gesture_multi_press_set_area(), this
// function will return true and fill in @rect with the press area. See
// gtk_gesture_multi_press_set_area() for more details on what the press area
// represents.
	func (g GestureMultiPress) Area() (gdk.Rectangle, bool) {
var _arg0 *C.GtkGestureMultiPress // out
var _rect gdk.Rectangle
var _cret C.gboolean // in

_arg0 = (*C.GtkGestureMultiPress)(unsafe.Pointer(g.Native()))

_cret = C.gtk_gesture_multi_press_get_area(_arg0, (*C.GdkRectangle)(unsafe.Pointer(&_rect)))



var _ok bool // out


if _cret != 0 { _ok = true }

return _rect, _ok
}
	
	// SetArea: if @rect is non-nil, the press area will be checked to be confined
// within the rectangle, otherwise the button count will be reset so the press
// is seen as being the first one. If @rect is nil, the area will be reset to an
// unrestricted state.
// 
// Note: The rectangle is only used to determine whether any non-first click
// falls within the expected area. This is not akin to an input shape.
	func (g GestureMultiPress) SetArea(rect *gdk.Rectangle)  {
var _arg0 *C.GtkGestureMultiPress // out
var _arg1 *C.GdkRectangle // out

_arg0 = (*C.GtkGestureMultiPress)(unsafe.Pointer(g.Native()))
_arg1 = (*C.GdkRectangle)(unsafe.Pointer(rect.Native()))

C.gtk_gesture_multi_press_set_area(_arg0, _arg1)
}
	


	// GesturePan is a Gesture implementation able to recognize pan gestures, those
// are drags that are locked to happen along one axis. The axis that a
// GesturePan handles is defined at construct time, and can be changed through
// gtk_gesture_pan_set_orientation().
// 
// When the gesture starts to be recognized, GesturePan will attempt to
// determine as early as possible whether the sequence is moving in the expected
// direction, and denying the sequence if this does not happen.
// 
// Once a panning gesture along the expected axis is recognized, the
// GesturePan::pan signal will be emitted as input events are received,
// containing the offset in the given axis.
	type GesturePan struct {
		GestureDrag
		
	}

	// GesturePanClass is an interface that the GesturePan class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type GesturePanClass interface {
		gextras.Objector
		_gesturePan()
	}

	func (GesturePan) _gesturePan() {}

	
	func marshalGesturePan(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapGesturePan(obj), nil
	}
	

	
	// NewGesturePan returns a newly created Gesture that recognizes pan gestures.
	func NewGesturePan(widget WidgetClass, orientation Orientation) GesturePan {
var _arg1 *C.GtkWidget // out
var _arg2 C.GtkOrientation // out
var _cret *C.GtkGesture // in

_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg2 = (C.GtkOrientation)(orientation)

_cret = C.gtk_gesture_pan_new(_arg1, _arg2)


var _gesturePan GesturePan // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_gesturePan = GesturePan{
GestureDrag: GestureDrag{
GestureSingle: GestureSingle{
Gesture: Gesture{
EventController: EventController{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
},
}
}

return _gesturePan
}
	

	
	// Orientation returns the orientation of the pan gestures that this @gesture
// expects.
	func (g GesturePan) Orientation() Orientation {
var _arg0 *C.GtkGesturePan // out
var _cret C.GtkOrientation // in

_arg0 = (*C.GtkGesturePan)(unsafe.Pointer(g.Native()))

_cret = C.gtk_gesture_pan_get_orientation(_arg0)


var _orientation Orientation // out

_orientation = Orientation(_cret)

return _orientation
}
	
	// SetOrientation sets the orientation to be expected on pan gestures.
	func (g GesturePan) SetOrientation(orientation Orientation)  {
var _arg0 *C.GtkGesturePan // out
var _arg1 C.GtkOrientation // out

_arg0 = (*C.GtkGesturePan)(unsafe.Pointer(g.Native()))
_arg1 = (C.GtkOrientation)(orientation)

C.gtk_gesture_pan_set_orientation(_arg0, _arg1)
}
	


	// GestureRotate is a Gesture implementation able to recognize 2-finger
// rotations, whenever the angle between both handled sequences changes, the
// GestureRotate::angle-changed signal is emitted.
	type GestureRotate struct {
		Gesture
		
	}

	// GestureRotateClass is an interface that the GestureRotate class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type GestureRotateClass interface {
		gextras.Objector
		_gestureRotate()
	}

	func (GestureRotate) _gestureRotate() {}

	
	func marshalGestureRotate(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapGestureRotate(obj), nil
	}
	

	
	// NewGestureRotate returns a newly created Gesture that recognizes 2-touch
// rotation gestures.
	func NewGestureRotate(widget WidgetClass) GestureRotate {
var _arg1 *C.GtkWidget // out
var _cret *C.GtkGesture // in

_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

_cret = C.gtk_gesture_rotate_new(_arg1)


var _gestureRotate GestureRotate // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_gestureRotate = GestureRotate{
Gesture: Gesture{
EventController: EventController{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
}
}

return _gestureRotate
}
	

	
	// AngleDelta: if @gesture is active, this function returns the angle difference
// in radians since the gesture was first recognized. If @gesture is not active,
// 0 is returned.
	func (g GestureRotate) AngleDelta() float64 {
var _arg0 *C.GtkGestureRotate // out
var _cret C.gdouble // in

_arg0 = (*C.GtkGestureRotate)(unsafe.Pointer(g.Native()))

_cret = C.gtk_gesture_rotate_get_angle_delta(_arg0)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	


	// GestureSingle is a subclass of Gesture, optimized (although not restricted)
// for dealing with mouse and single-touch gestures. Under interaction, these
// gestures stick to the first interacting sequence, which is accessible through
// gtk_gesture_single_get_current_sequence() while the gesture is being
// interacted with.
// 
// By default gestures react to both GDK_BUTTON_PRIMARY and touch events,
// gtk_gesture_single_set_touch_only() can be used to change the touch behavior.
// Callers may also specify a different mouse button number to interact with
// through gtk_gesture_single_set_button(), or react to any mouse button by
// setting 0. While the gesture is active, the button being currently pressed
// can be known through gtk_gesture_single_get_current_button().
	type GestureSingle struct {
		Gesture
		
	}

	// GestureSingleClass is an interface that the GestureSingle class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type GestureSingleClass interface {
		gextras.Objector
		_gestureSingle()
	}

	func (GestureSingle) _gestureSingle() {}

	
	func marshalGestureSingle(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapGestureSingle(obj), nil
	}
	

	

	
	// Button returns the button number @gesture listens for, or 0 if @gesture
// reacts to any button press.
	func (g GestureSingle) Button() uint {
var _arg0 *C.GtkGestureSingle // out
var _cret C.guint // in

_arg0 = (*C.GtkGestureSingle)(unsafe.Pointer(g.Native()))

_cret = C.gtk_gesture_single_get_button(_arg0)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// CurrentButton returns the button number currently interacting with @gesture,
// or 0 if there is none.
	func (g GestureSingle) CurrentButton() uint {
var _arg0 *C.GtkGestureSingle // out
var _cret C.guint // in

_arg0 = (*C.GtkGestureSingle)(unsafe.Pointer(g.Native()))

_cret = C.gtk_gesture_single_get_current_button(_arg0)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// CurrentSequence returns the event sequence currently interacting with
// @gesture. This is only meaningful if gtk_gesture_is_active() returns true.
	func (g GestureSingle) CurrentSequence() *gdk.EventSequence {
var _arg0 *C.GtkGestureSingle // out
var _cret *C.GdkEventSequence // in

_arg0 = (*C.GtkGestureSingle)(unsafe.Pointer(g.Native()))

_cret = C.gtk_gesture_single_get_current_sequence(_arg0)


var _eventSequence *gdk.EventSequence // out

_eventSequence = *(**gdk.EventSequence)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_eventSequence, func(v *gdk.EventSequence) {
  C.free(unsafe.Pointer(v.Native()))
})

return _eventSequence
}
	
	// Exclusive gets whether a gesture is exclusive. For more information, see
// gtk_gesture_single_set_exclusive().
	func (g GestureSingle) Exclusive() bool {
var _arg0 *C.GtkGestureSingle // out
var _cret C.gboolean // in

_arg0 = (*C.GtkGestureSingle)(unsafe.Pointer(g.Native()))

_cret = C.gtk_gesture_single_get_exclusive(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// TouchOnly returns true if the gesture is only triggered by touch events.
	func (g GestureSingle) TouchOnly() bool {
var _arg0 *C.GtkGestureSingle // out
var _cret C.gboolean // in

_arg0 = (*C.GtkGestureSingle)(unsafe.Pointer(g.Native()))

_cret = C.gtk_gesture_single_get_touch_only(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetButton sets the button number @gesture listens to. If non-0, every button
// press from a different button number will be ignored. Touch events implicitly
// match with button 1.
	func (g GestureSingle) SetButton(button uint)  {
var _arg0 *C.GtkGestureSingle // out
var _arg1 C.guint // out

_arg0 = (*C.GtkGestureSingle)(unsafe.Pointer(g.Native()))
_arg1 = (C.guint)(button)

C.gtk_gesture_single_set_button(_arg0, _arg1)
}
	
	// SetExclusive sets whether @gesture is exclusive. An exclusive gesture will
// only handle pointer and "pointer emulated" touch events, so at any given
// time, there is only one sequence able to interact with those.
	func (g GestureSingle) SetExclusive(exclusive bool)  {
var _arg0 *C.GtkGestureSingle // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkGestureSingle)(unsafe.Pointer(g.Native()))
if exclusive { _arg1 = C.TRUE }

C.gtk_gesture_single_set_exclusive(_arg0, _arg1)
}
	
	// SetTouchOnly: if @touch_only is true, @gesture will only handle events of
// type K_TOUCH_BEGIN, K_TOUCH_UPDATE or K_TOUCH_END. If false, mouse events
// will be handled too.
	func (g GestureSingle) SetTouchOnly(touchOnly bool)  {
var _arg0 *C.GtkGestureSingle // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkGestureSingle)(unsafe.Pointer(g.Native()))
if touchOnly { _arg1 = C.TRUE }

C.gtk_gesture_single_set_touch_only(_arg0, _arg1)
}
	


	// GestureStylus is a Gesture implementation specific to stylus input. The
// provided signals just provide the basic information
	type GestureStylus struct {
		GestureSingle
		
	}

	// GestureStylusClass is an interface that the GestureStylus class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type GestureStylusClass interface {
		gextras.Objector
		_gestureStylus()
	}

	func (GestureStylus) _gestureStylus() {}

	
	func marshalGestureStylus(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapGestureStylus(obj), nil
	}
	

	
	// NewGestureStylus creates a new GestureStylus.
	func NewGestureStylus(widget WidgetClass) GestureStylus {
var _arg1 *C.GtkWidget // out
var _cret *C.GtkGesture // in

_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

_cret = C.gtk_gesture_stylus_new(_arg1)


var _gestureStylus GestureStylus // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_gestureStylus = GestureStylus{
GestureSingle: GestureSingle{
Gesture: Gesture{
EventController: EventController{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
}
}

return _gestureStylus
}
	

	
	// Axis returns the current value for the requested @axis. This function must be
// called from either the GestureStylus:down, GestureStylus:motion,
// GestureStylus:up or GestureStylus:proximity signals.
	func (g GestureStylus) Axis(axis gdk.AxisUse) (float64, bool) {
var _arg0 *C.GtkGestureStylus // out
var _arg1 C.GdkAxisUse // out
var _arg2 C.gdouble // in
var _cret C.gboolean // in

_arg0 = (*C.GtkGestureStylus)(unsafe.Pointer(g.Native()))
_arg1 = (C.GdkAxisUse)(axis)

_cret = C.gtk_gesture_stylus_get_axis(_arg0, _arg1, &_arg2)


var _value float64 // out
var _ok bool // out

_value = (float64)(_arg2)
if _cret != 0 { _ok = true }

return _value, _ok
}
	
	// DeviceTool returns the DeviceTool currently driving input through this
// gesture. This function must be called from either the GestureStylus::down,
// GestureStylus::motion, GestureStylus::up or GestureStylus::proximity signal
// handlers.
	func (g GestureStylus) DeviceTool() gdk.DeviceTool {
var _arg0 *C.GtkGestureStylus // out
var _cret *C.GdkDeviceTool // in

_arg0 = (*C.GtkGestureStylus)(unsafe.Pointer(g.Native()))

_cret = C.gtk_gesture_stylus_get_device_tool(_arg0)


var _deviceTool gdk.DeviceTool // out

_deviceTool = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.DeviceTool)

return _deviceTool
}
	


	// GestureSwipe is a Gesture implementation able to recognize swipes, after a
// press/move/.../move/release sequence happens, the GestureSwipe::swipe signal
// will be emitted, providing the velocity and directionality of the sequence at
// the time it was lifted.
// 
// If the velocity is desired in intermediate points,
// gtk_gesture_swipe_get_velocity() can be called on eg. a Gesture::update
// handler.
// 
// All velocities are reported in pixels/sec units.
	type GestureSwipe struct {
		GestureSingle
		
	}

	// GestureSwipeClass is an interface that the GestureSwipe class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type GestureSwipeClass interface {
		gextras.Objector
		_gestureSwipe()
	}

	func (GestureSwipe) _gestureSwipe() {}

	
	func marshalGestureSwipe(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapGestureSwipe(obj), nil
	}
	

	
	// NewGestureSwipe returns a newly created Gesture that recognizes swipes.
	func NewGestureSwipe(widget WidgetClass) GestureSwipe {
var _arg1 *C.GtkWidget // out
var _cret *C.GtkGesture // in

_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

_cret = C.gtk_gesture_swipe_new(_arg1)


var _gestureSwipe GestureSwipe // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_gestureSwipe = GestureSwipe{
GestureSingle: GestureSingle{
Gesture: Gesture{
EventController: EventController{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
}
}

return _gestureSwipe
}
	

	
	// Velocity: if the gesture is recognized, this function returns true and fill
// in @velocity_x and @velocity_y with the recorded velocity, as per the last
// event(s) processed.
	func (g GestureSwipe) Velocity() (velocityX float64, velocityY float64, ok bool) {
var _arg0 *C.GtkGestureSwipe // out
var _arg1 C.gdouble // in
var _arg2 C.gdouble // in
var _cret C.gboolean // in

_arg0 = (*C.GtkGestureSwipe)(unsafe.Pointer(g.Native()))

_cret = C.gtk_gesture_swipe_get_velocity(_arg0, &_arg1, &_arg2)


var _velocityX float64 // out
var _velocityY float64 // out
var _ok bool // out

_velocityX = (float64)(_arg1)
_velocityY = (float64)(_arg2)
if _cret != 0 { _ok = true }

return _velocityX, _velocityY, _ok
}
	


	// GestureZoom is a Gesture implementation able to recognize pinch/zoom
// gestures, whenever the distance between both tracked sequences changes, the
// GestureZoom::scale-changed signal is emitted to report the scale factor.
	type GestureZoom struct {
		Gesture
		
	}

	// GestureZoomClass is an interface that the GestureZoom class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type GestureZoomClass interface {
		gextras.Objector
		_gestureZoom()
	}

	func (GestureZoom) _gestureZoom() {}

	
	func marshalGestureZoom(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapGestureZoom(obj), nil
	}
	

	
	// NewGestureZoom returns a newly created Gesture that recognizes zoom in/out
// gestures (usually known as pinch/zoom).
	func NewGestureZoom(widget WidgetClass) GestureZoom {
var _arg1 *C.GtkWidget // out
var _cret *C.GtkGesture // in

_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

_cret = C.gtk_gesture_zoom_new(_arg1)


var _gestureZoom GestureZoom // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_gestureZoom = GestureZoom{
Gesture: Gesture{
EventController: EventController{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
}
}

return _gestureZoom
}
	

	
	// ScaleDelta: if @gesture is active, this function returns the zooming
// difference since the gesture was recognized (hence the starting point is
// considered 1:1). If @gesture is not active, 1 is returned.
	func (g GestureZoom) ScaleDelta() float64 {
var _arg0 *C.GtkGestureZoom // out
var _cret C.gdouble // in

_arg0 = (*C.GtkGestureZoom)(unsafe.Pointer(g.Native()))

_cret = C.gtk_gesture_zoom_get_scale_delta(_arg0)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	


	// Grid: gtkGrid is a container which arranges its child widgets in rows and
// columns, with arbitrary positions and horizontal/vertical spans.
// 
// Children are added using gtk_grid_attach(). They can span multiple rows or
// columns. It is also possible to add a child next to an existing child, using
// gtk_grid_attach_next_to(). The behaviour of GtkGrid when several children
// occupy the same grid cell is undefined.
// 
// GtkGrid can be used like a Box by just using gtk_container_add(), which will
// place children next to each other in the direction determined by the
// Orientable:orientation property. However, if all you want is a single row or
// column, then Box is the preferred widget.
// 
// 
// CSS nodes
// 
// GtkGrid uses a single CSS node with name grid.
	type Grid struct {
		Container
		Buildable
		Orientable
		
	}

	// GridClass is an interface that the Grid class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type GridClass interface {
		gextras.Objector
		_grid()
	}

	func (Grid) _grid() {}

	
	func marshalGrid(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapGrid(obj), nil
	}
	

	
	// NewGrid creates a new grid widget.
	func NewGrid() Grid {
var _cret *C.GtkWidget // in

_cret = C.gtk_grid_new()


var _grid Grid // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_grid = Grid{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _grid
}
	

	
	// Attach adds a widget to the grid.
// 
// The position of @child is determined by @left and @top. The number of “cells”
// that @child will occupy is determined by @width and @height.
	func (g Grid) Attach(child WidgetClass, left int, top int, width int, height int)  {
var _arg0 *C.GtkGrid // out
var _arg1 *C.GtkWidget // out
var _arg2 C.gint // out
var _arg3 C.gint // out
var _arg4 C.gint // out
var _arg5 C.gint // out

_arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
_arg2 = (C.gint)(left)
_arg3 = (C.gint)(top)
_arg4 = (C.gint)(width)
_arg5 = (C.gint)(height)

C.gtk_grid_attach(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
}
	
	// AttachNextTo adds a widget to the grid.
// 
// The widget is placed next to @sibling, on the side determined by @side. When
// @sibling is nil, the widget is placed in row (for left or right placement) or
// column 0 (for top or bottom placement), at the end indicated by @side.
// 
// Attaching widgets labeled [1], [2], [3] with @sibling == nil and @side ==
// GTK_POS_LEFT yields a layout of [3][2][1].
	func (g Grid) AttachNextTo(child WidgetClass, sibling WidgetClass, side PositionType, width int, height int)  {
var _arg0 *C.GtkGrid // out
var _arg1 *C.GtkWidget // out
var _arg2 *C.GtkWidget // out
var _arg3 C.GtkPositionType // out
var _arg4 C.gint // out
var _arg5 C.gint // out

_arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
_arg2 = (*C.GtkWidget)(unsafe.Pointer(sibling.Native()))
_arg3 = (C.GtkPositionType)(side)
_arg4 = (C.gint)(width)
_arg5 = (C.gint)(height)

C.gtk_grid_attach_next_to(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
}
	
	// BaselineRow returns which row defines the global baseline of @grid.
	func (g Grid) BaselineRow() int {
var _arg0 *C.GtkGrid // out
var _cret C.gint // in

_arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))

_cret = C.gtk_grid_get_baseline_row(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// ChildAt gets the child of @grid whose area covers the grid cell whose upper
// left corner is at @left, @top.
	func (g Grid) ChildAt(left int, top int) Widget {
var _arg0 *C.GtkGrid // out
var _arg1 C.gint // out
var _arg2 C.gint // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))
_arg1 = (C.gint)(left)
_arg2 = (C.gint)(top)

_cret = C.gtk_grid_get_child_at(_arg0, _arg1, _arg2)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// ColumnHomogeneous returns whether all columns of @grid have the same width.
	func (g Grid) ColumnHomogeneous() bool {
var _arg0 *C.GtkGrid // out
var _cret C.gboolean // in

_arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))

_cret = C.gtk_grid_get_column_homogeneous(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ColumnSpacing returns the amount of space between the columns of @grid.
	func (g Grid) ColumnSpacing() uint {
var _arg0 *C.GtkGrid // out
var _cret C.guint // in

_arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))

_cret = C.gtk_grid_get_column_spacing(_arg0)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// RowBaselinePosition returns the baseline position of @row as set by
// gtk_grid_set_row_baseline_position() or the default value
// GTK_BASELINE_POSITION_CENTER.
	func (g Grid) RowBaselinePosition(row int) BaselinePosition {
var _arg0 *C.GtkGrid // out
var _arg1 C.gint // out
var _cret C.GtkBaselinePosition // in

_arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))
_arg1 = (C.gint)(row)

_cret = C.gtk_grid_get_row_baseline_position(_arg0, _arg1)


var _baselinePosition BaselinePosition // out

_baselinePosition = BaselinePosition(_cret)

return _baselinePosition
}
	
	// RowHomogeneous returns whether all rows of @grid have the same height.
	func (g Grid) RowHomogeneous() bool {
var _arg0 *C.GtkGrid // out
var _cret C.gboolean // in

_arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))

_cret = C.gtk_grid_get_row_homogeneous(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// RowSpacing returns the amount of space between the rows of @grid.
	func (g Grid) RowSpacing() uint {
var _arg0 *C.GtkGrid // out
var _cret C.guint // in

_arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))

_cret = C.gtk_grid_get_row_spacing(_arg0)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// InsertColumn inserts a column at the specified position.
// 
// Children which are attached at or to the right of this position are moved one
// column to the right. Children which span across this position are grown to
// span the new column.
	func (g Grid) InsertColumn(position int)  {
var _arg0 *C.GtkGrid // out
var _arg1 C.gint // out

_arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))
_arg1 = (C.gint)(position)

C.gtk_grid_insert_column(_arg0, _arg1)
}
	
	// InsertNextTo inserts a row or column at the specified position.
// 
// The new row or column is placed next to @sibling, on the side determined by
// @side. If @side is GTK_POS_TOP or GTK_POS_BOTTOM, a row is inserted. If @side
// is GTK_POS_LEFT of GTK_POS_RIGHT, a column is inserted.
	func (g Grid) InsertNextTo(sibling WidgetClass, side PositionType)  {
var _arg0 *C.GtkGrid // out
var _arg1 *C.GtkWidget // out
var _arg2 C.GtkPositionType // out

_arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(sibling.Native()))
_arg2 = (C.GtkPositionType)(side)

C.gtk_grid_insert_next_to(_arg0, _arg1, _arg2)
}
	
	// InsertRow inserts a row at the specified position.
// 
// Children which are attached at or below this position are moved one row down.
// Children which span across this position are grown to span the new row.
	func (g Grid) InsertRow(position int)  {
var _arg0 *C.GtkGrid // out
var _arg1 C.gint // out

_arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))
_arg1 = (C.gint)(position)

C.gtk_grid_insert_row(_arg0, _arg1)
}
	
	// RemoveColumn removes a column from the grid.
// 
// Children that are placed in this column are removed, spanning children that
// overlap this column have their width reduced by one, and children after the
// column are moved to the left.
	func (g Grid) RemoveColumn(position int)  {
var _arg0 *C.GtkGrid // out
var _arg1 C.gint // out

_arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))
_arg1 = (C.gint)(position)

C.gtk_grid_remove_column(_arg0, _arg1)
}
	
	// RemoveRow removes a row from the grid.
// 
// Children that are placed in this row are removed, spanning children that
// overlap this row have their height reduced by one, and children below the row
// are moved up.
	func (g Grid) RemoveRow(position int)  {
var _arg0 *C.GtkGrid // out
var _arg1 C.gint // out

_arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))
_arg1 = (C.gint)(position)

C.gtk_grid_remove_row(_arg0, _arg1)
}
	
	// SetBaselineRow sets which row defines the global baseline for the entire
// grid. Each row in the grid can have its own local baseline, but only one of
// those is global, meaning it will be the baseline in the parent of the @grid.
	func (g Grid) SetBaselineRow(row int)  {
var _arg0 *C.GtkGrid // out
var _arg1 C.gint // out

_arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))
_arg1 = (C.gint)(row)

C.gtk_grid_set_baseline_row(_arg0, _arg1)
}
	
	// SetColumnHomogeneous sets whether all columns of @grid will have the same
// width.
	func (g Grid) SetColumnHomogeneous(homogeneous bool)  {
var _arg0 *C.GtkGrid // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))
if homogeneous { _arg1 = C.TRUE }

C.gtk_grid_set_column_homogeneous(_arg0, _arg1)
}
	
	// SetColumnSpacing sets the amount of space between columns of @grid.
	func (g Grid) SetColumnSpacing(spacing uint)  {
var _arg0 *C.GtkGrid // out
var _arg1 C.guint // out

_arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))
_arg1 = (C.guint)(spacing)

C.gtk_grid_set_column_spacing(_arg0, _arg1)
}
	
	// SetRowBaselinePosition sets how the baseline should be positioned on @row of
// the grid, in case that row is assigned more space than is requested.
	func (g Grid) SetRowBaselinePosition(row int, pos BaselinePosition)  {
var _arg0 *C.GtkGrid // out
var _arg1 C.gint // out
var _arg2 C.GtkBaselinePosition // out

_arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))
_arg1 = (C.gint)(row)
_arg2 = (C.GtkBaselinePosition)(pos)

C.gtk_grid_set_row_baseline_position(_arg0, _arg1, _arg2)
}
	
	// SetRowHomogeneous sets whether all rows of @grid will have the same height.
	func (g Grid) SetRowHomogeneous(homogeneous bool)  {
var _arg0 *C.GtkGrid // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))
if homogeneous { _arg1 = C.TRUE }

C.gtk_grid_set_row_homogeneous(_arg0, _arg1)
}
	
	// SetRowSpacing sets the amount of space between rows of @grid.
	func (g Grid) SetRowSpacing(spacing uint)  {
var _arg0 *C.GtkGrid // out
var _arg1 C.guint // out

_arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))
_arg1 = (C.guint)(spacing)

C.gtk_grid_set_row_spacing(_arg0, _arg1)
}
	


	// HBox is a container that organizes child widgets into a single row.
// 
// Use the Box packing interface to determine the arrangement, spacing, width,
// and alignment of HBox children.
// 
// All children are allocated the same height.
// 
// GtkHBox has been deprecated. You can use Box instead, which is a very quick
// and easy change. If you have derived your own classes from GtkHBox, you can
// simply change the inheritance to derive directly from Box. No further changes
// are needed, since the default value of the Orientable:orientation property is
// GTK_ORIENTATION_HORIZONTAL.
// 
// If you have a grid-like layout composed of nested boxes, and you don’t need
// first-child or last-child styling, the recommendation is to switch to Grid.
// For more information about migrating to Grid, see [Migrating from other
// containers to GtkGrid][gtk-migrating-GtkGrid].
	type HBox struct {
		Box
		Buildable
		Orientable
		
	}

	// HBoxClass is an interface that the HBox class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type HBoxClass interface {
		gextras.Objector
		_hBox()
	}

	func (HBox) _hBox() {}

	
	func marshalHBox(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapHBox(obj), nil
	}
	

	
	// NewHBox creates a new HBox.
	func NewHBox(homogeneous bool, spacing int) HBox {
var _arg1 C.gboolean // out
var _arg2 C.gint // out
var _cret *C.GtkWidget // in

if homogeneous { _arg1 = C.TRUE }
_arg2 = (C.gint)(spacing)

_cret = C.gtk_hbox_new(_arg1, _arg2)


var _hBox HBox // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_hBox = HBox{
Box: Box{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _hBox
}
	

	


	
	type HButtonBox struct {
		ButtonBox
		Buildable
		Orientable
		
	}

	// HButtonBoxClass is an interface that the HButtonBox class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type HButtonBoxClass interface {
		gextras.Objector
		_hButtonBox()
	}

	func (HButtonBox) _hButtonBox() {}

	
	func marshalHButtonBox(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapHButtonBox(obj), nil
	}
	

	
	// NewHButtonBox creates a new horizontal button box.
	func NewHButtonBox() HButtonBox {
var _cret *C.GtkWidget // in

_cret = C.gtk_hbutton_box_new()


var _hButtonBox HButtonBox // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_hButtonBox = HButtonBox{
ButtonBox: ButtonBox{
Box: Box{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _hButtonBox
}
	

	


	// HPaned: the HPaned widget is a container widget with two children arranged
// horizontally. The division between the two panes is adjustable by the user by
// dragging a handle. See Paned for details.
// 
// GtkHPaned has been deprecated, use Paned instead.
	type HPaned struct {
		Paned
		Buildable
		Orientable
		
	}

	// HPanedClass is an interface that the HPaned class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type HPanedClass interface {
		gextras.Objector
		_hPaned()
	}

	func (HPaned) _hPaned() {}

	
	func marshalHPaned(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapHPaned(obj), nil
	}
	

	
	// NewHPaned: create a new HPaned
	func NewHPaned() HPaned {
var _cret *C.GtkWidget // in

_cret = C.gtk_hpaned_new()


var _hPaned HPaned // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_hPaned = HPaned{
Paned: Paned{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _hPaned
}
	

	


	// HSV is the “color wheel” part of a complete color selector widget. It allows
// to select a color by determining its HSV components in an intuitive way.
// Moving the selection around the outer ring changes the hue, and moving the
// selection point inside the inner triangle changes value and saturation.
// 
// HSV has been deprecated together with ColorSelection, where it was used.
	type HSV struct {
		Widget
		Buildable
		
	}

	// HSVClass is an interface that the HSV class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type HSVClass interface {
		gextras.Objector
		_hsV()
	}

	func (HSV) _hsV() {}

	
	func marshalHSV(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapHSV(obj), nil
	}
	

	
	// NewHSV creates a new HSV color selector.
	func NewHSV() HSV {
var _cret *C.GtkWidget // in

_cret = C.gtk_hsv_new()


var _hsV HSV // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_hsV = HSV{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _hsV
}
	

	
	// Color queries the current color in an HSV color selector. Returned values
// will be in the [0.0, 1.0] range.
	func (h HSV) Color() (h float64, s float64, v float64) {
var _arg0 *C.GtkHSV // out
var _arg1 C.gdouble // in
var _arg2 C.gdouble // in
var _arg3 C.gdouble // in

_arg0 = (*C.GtkHSV)(unsafe.Pointer(h.Native()))

C.gtk_hsv_get_color(_arg0, &_arg1, &_arg2, &_arg3)

var _h float64 // out
var _s float64 // out
var _v float64 // out

_h = (float64)(_arg1)
_s = (float64)(_arg2)
_v = (float64)(_arg3)

return _h, _s, _v
}
	
	// Metrics queries the size and ring width of an HSV color selector.
	func (h HSV) Metrics() (size int, ringWidth int) {
var _arg0 *C.GtkHSV // out
var _arg1 C.gint // in
var _arg2 C.gint // in

_arg0 = (*C.GtkHSV)(unsafe.Pointer(h.Native()))

C.gtk_hsv_get_metrics(_arg0, &_arg1, &_arg2)

var _size int // out
var _ringWidth int // out

_size = (int)(_arg1)
_ringWidth = (int)(_arg2)

return _size, _ringWidth
}
	
	// IsAdjusting: an HSV color selector can be said to be adjusting if multiple
// rapid changes are being made to its value, for example, when the user is
// adjusting the value with the mouse. This function queries whether the HSV
// color selector is being adjusted or not.
	func (h HSV) IsAdjusting() bool {
var _arg0 *C.GtkHSV // out
var _cret C.gboolean // in

_arg0 = (*C.GtkHSV)(unsafe.Pointer(h.Native()))

_cret = C.gtk_hsv_is_adjusting(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetColor sets the current color in an HSV color selector. Color component
// values must be in the [0.0, 1.0] range.
	func (h HSV) SetColor(h float64, s float64, v float64)  {
var _arg0 *C.GtkHSV // out
var _arg1 C.double // out
var _arg2 C.double // out
var _arg3 C.double // out

_arg0 = (*C.GtkHSV)(unsafe.Pointer(h.Native()))
_arg1 = (C.double)(h)
_arg2 = (C.double)(s)
_arg3 = (C.double)(v)

C.gtk_hsv_set_color(_arg0, _arg1, _arg2, _arg3)
}
	
	// SetMetrics sets the size and ring width of an HSV color selector.
	func (h HSV) SetMetrics(size int, ringWidth int)  {
var _arg0 *C.GtkHSV // out
var _arg1 C.gint // out
var _arg2 C.gint // out

_arg0 = (*C.GtkHSV)(unsafe.Pointer(h.Native()))
_arg1 = (C.gint)(size)
_arg2 = (C.gint)(ringWidth)

C.gtk_hsv_set_metrics(_arg0, _arg1, _arg2)
}
	


	// HScale: the HScale widget is used to allow the user to select a value using a
// horizontal slider. To create one, use gtk_hscale_new_with_range().
// 
// The position to show the current value, and the number of decimal places
// shown can be set using the parent Scale class’s functions.
// 
// GtkHScale has been deprecated, use Scale instead.
	type HScale struct {
		Scale
		Buildable
		Orientable
		
	}

	// HScaleClass is an interface that the HScale class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type HScaleClass interface {
		gextras.Objector
		_hScale()
	}

	func (HScale) _hScale() {}

	
	func marshalHScale(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapHScale(obj), nil
	}
	

	
	// NewHScale creates a new HScale.
	func NewHScale(adjustment AdjustmentClass) HScale {
var _arg1 *C.GtkAdjustment // out
var _cret *C.GtkWidget // in

_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(adjustment.Native()))

_cret = C.gtk_hscale_new(_arg1)


var _hScale HScale // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_hScale = HScale{
Scale: Scale{
Range: Range{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _hScale
}
	
	// NewHScaleWithRange creates a new horizontal scale widget that lets the user
// input a number between @min and @max (including @min and @max) with the
// increment @step. @step must be nonzero; it’s the distance the slider moves
// when using the arrow keys to adjust the scale value.
// 
// Note that the way in which the precision is derived works best if @step is a
// power of ten. If the resulting precision is not suitable for your needs, use
// gtk_scale_set_digits() to correct it.
	func NewHScaleWithRange(min float64, max float64, step float64) HScale {
var _arg1 C.gdouble // out
var _arg2 C.gdouble // out
var _arg3 C.gdouble // out
var _cret *C.GtkWidget // in

_arg1 = (C.gdouble)(min)
_arg2 = (C.gdouble)(max)
_arg3 = (C.gdouble)(step)

_cret = C.gtk_hscale_new_with_range(_arg1, _arg2, _arg3)


var _hScale HScale // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_hScale = HScale{
Scale: Scale{
Range: Range{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _hScale
}
	

	


	// HScrollbar: the HScrollbar widget is a widget arranged horizontally creating
// a scrollbar. See Scrollbar for details on scrollbars. Adjustment pointers may
// be added to handle the adjustment of the scrollbar or it may be left nil in
// which case one will be created for you. See Scrollbar for a description of
// what the fields in an adjustment represent for a scrollbar.
// 
// GtkHScrollbar has been deprecated, use Scrollbar instead.
	type HScrollbar struct {
		Scrollbar
		Buildable
		Orientable
		
	}

	// HScrollbarClass is an interface that the HScrollbar class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type HScrollbarClass interface {
		gextras.Objector
		_hScrollbar()
	}

	func (HScrollbar) _hScrollbar() {}

	
	func marshalHScrollbar(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapHScrollbar(obj), nil
	}
	

	
	// NewHScrollbar creates a new horizontal scrollbar.
	func NewHScrollbar(adjustment AdjustmentClass) HScrollbar {
var _arg1 *C.GtkAdjustment // out
var _cret *C.GtkWidget // in

_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(adjustment.Native()))

_cret = C.gtk_hscrollbar_new(_arg1)


var _hScrollbar HScrollbar // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_hScrollbar = HScrollbar{
Scrollbar: Scrollbar{
Range: Range{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _hScrollbar
}
	

	


	// HSeparator: the HSeparator widget is a horizontal separator, used to group
// the widgets within a window. It displays a horizontal line with a shadow to
// make it appear sunken into the interface.
// 
// > The HSeparator widget is not used as a separator within menus. > To create
// a separator in a menu create an empty SeparatorMenuItem > widget using
// gtk_separator_menu_item_new() and add it to the menu with >
// gtk_menu_shell_append().
// 
// GtkHSeparator has been deprecated, use Separator instead.
	type HSeparator struct {
		Separator
		Buildable
		Orientable
		
	}

	// HSeparatorClass is an interface that the HSeparator class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type HSeparatorClass interface {
		gextras.Objector
		_hSeparator()
	}

	func (HSeparator) _hSeparator() {}

	
	func marshalHSeparator(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapHSeparator(obj), nil
	}
	

	
	// NewHSeparator creates a new HSeparator.
	func NewHSeparator() HSeparator {
var _cret *C.GtkWidget // in

_cret = C.gtk_hseparator_new()


var _hSeparator HSeparator // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_hSeparator = HSeparator{
Separator: Separator{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _hSeparator
}
	

	


	// HandleBox: the HandleBox widget allows a portion of a window to be "torn
// off". It is a bin widget which displays its child and a handle that the user
// can drag to tear off a separate window (the “float window”) containing the
// child widget. A thin “ghost” is drawn in the original location of the
// handlebox. By dragging the separate window back to its original location, it
// can be reattached.
// 
// When reattaching, the ghost and float window, must be aligned along one of
// the edges, the “snap edge”. This either can be specified by the application
// programmer explicitly, or GTK+ will pick a reasonable default based on the
// handle position.
// 
// To make detaching and reattaching the handlebox as minimally confusing as
// possible to the user, it is important to set the snap edge so that the snap
// edge does not move when the handlebox is deattached. For instance, if the
// handlebox is packed at the bottom of a VBox, then when the handlebox is
// detached, the bottom edge of the handlebox's allocation will remain fixed as
// the height of the handlebox shrinks, so the snap edge should be set to
// GTK_POS_BOTTOM.
// 
// > HandleBox has been deprecated. It is very specialized, lacks features > to
// make it useful and most importantly does not fit well into modern >
// application design. Do not use it. There is no replacement.
	type HandleBox struct {
		Bin
		Buildable
		
	}

	// HandleBoxClass is an interface that the HandleBox class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type HandleBoxClass interface {
		gextras.Objector
		_handleBox()
	}

	func (HandleBox) _handleBox() {}

	
	func marshalHandleBox(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapHandleBox(obj), nil
	}
	

	
	// NewHandleBox: create a new handle box.
	func NewHandleBox() HandleBox {
var _cret *C.GtkWidget // in

_cret = C.gtk_handle_box_new()


var _handleBox HandleBox // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_handleBox = HandleBox{
Bin: Bin{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _handleBox
}
	

	
	// ChildDetached: whether the handlebox’s child is currently detached.
	func (h HandleBox) ChildDetached() bool {
var _arg0 *C.GtkHandleBox // out
var _cret C.gboolean // in

_arg0 = (*C.GtkHandleBox)(unsafe.Pointer(h.Native()))

_cret = C.gtk_handle_box_get_child_detached(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// HandlePosition gets the handle position of the handle box. See
// gtk_handle_box_set_handle_position().
	func (h HandleBox) HandlePosition() PositionType {
var _arg0 *C.GtkHandleBox // out
var _cret C.GtkPositionType // in

_arg0 = (*C.GtkHandleBox)(unsafe.Pointer(h.Native()))

_cret = C.gtk_handle_box_get_handle_position(_arg0)


var _positionType PositionType // out

_positionType = PositionType(_cret)

return _positionType
}
	
	// ShadowType gets the type of shadow drawn around the handle box. See
// gtk_handle_box_set_shadow_type().
	func (h HandleBox) ShadowType() ShadowType {
var _arg0 *C.GtkHandleBox // out
var _cret C.GtkShadowType // in

_arg0 = (*C.GtkHandleBox)(unsafe.Pointer(h.Native()))

_cret = C.gtk_handle_box_get_shadow_type(_arg0)


var _shadowType ShadowType // out

_shadowType = ShadowType(_cret)

return _shadowType
}
	
	// SnapEdge gets the edge used for determining reattachment of the handle box.
// See gtk_handle_box_set_snap_edge().
	func (h HandleBox) SnapEdge() PositionType {
var _arg0 *C.GtkHandleBox // out
var _cret C.GtkPositionType // in

_arg0 = (*C.GtkHandleBox)(unsafe.Pointer(h.Native()))

_cret = C.gtk_handle_box_get_snap_edge(_arg0)


var _positionType PositionType // out

_positionType = PositionType(_cret)

return _positionType
}
	
	// SetHandlePosition sets the side of the handlebox where the handle is drawn.
	func (h HandleBox) SetHandlePosition(position PositionType)  {
var _arg0 *C.GtkHandleBox // out
var _arg1 C.GtkPositionType // out

_arg0 = (*C.GtkHandleBox)(unsafe.Pointer(h.Native()))
_arg1 = (C.GtkPositionType)(position)

C.gtk_handle_box_set_handle_position(_arg0, _arg1)
}
	
	// SetShadowType sets the type of shadow to be drawn around the border of the
// handle box.
	func (h HandleBox) SetShadowType(typ ShadowType)  {
var _arg0 *C.GtkHandleBox // out
var _arg1 C.GtkShadowType // out

_arg0 = (*C.GtkHandleBox)(unsafe.Pointer(h.Native()))
_arg1 = (C.GtkShadowType)(typ)

C.gtk_handle_box_set_shadow_type(_arg0, _arg1)
}
	
	// SetSnapEdge sets the snap edge of a handlebox. The snap edge is the edge of
// the detached child that must be aligned with the corresponding edge of the
// “ghost” left behind when the child was detached to reattach the torn-off
// window. Usually, the snap edge should be chosen so that it stays in the same
// place on the screen when the handlebox is torn off.
// 
// If the snap edge is not set, then an appropriate value will be guessed from
// the handle position. If the handle position is GTK_POS_RIGHT or GTK_POS_LEFT,
// then the snap edge will be GTK_POS_TOP, otherwise it will be GTK_POS_LEFT.
	func (h HandleBox) SetSnapEdge(edge PositionType)  {
var _arg0 *C.GtkHandleBox // out
var _arg1 C.GtkPositionType // out

_arg0 = (*C.GtkHandleBox)(unsafe.Pointer(h.Native()))
_arg1 = (C.GtkPositionType)(edge)

C.gtk_handle_box_set_snap_edge(_arg0, _arg1)
}
	


	// HeaderBar: gtkHeaderBar is similar to a horizontal Box. It allows children to
// be placed at the start or the end. In addition, it allows a title and
// subtitle to be displayed. The title will be centered with respect to the
// width of the box, even if the children at either side take up different
// amounts of space. The height of the titlebar will be set to provide
// sufficient space for the subtitle, even if none is currently set. If a
// subtitle is not needed, the space reservation can be turned off with
// gtk_header_bar_set_has_subtitle().
// 
// GtkHeaderBar can add typical window frame controls, such as minimize,
// maximize and close buttons, or the window icon.
// 
// For these reasons, GtkHeaderBar is the natural choice for use as the custom
// titlebar widget of a Window (see gtk_window_set_titlebar()), as it gives
// features typical of titlebars while allowing the addition of child widgets.
	type HeaderBar struct {
		Container
		Buildable
		
	}

	// HeaderBarClass is an interface that the HeaderBar class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type HeaderBarClass interface {
		gextras.Objector
		_headerBar()
	}

	func (HeaderBar) _headerBar() {}

	
	func marshalHeaderBar(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapHeaderBar(obj), nil
	}
	

	
	// NewHeaderBar creates a new HeaderBar widget.
	func NewHeaderBar() HeaderBar {
var _cret *C.GtkWidget // in

_cret = C.gtk_header_bar_new()


var _headerBar HeaderBar // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_headerBar = HeaderBar{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _headerBar
}
	

	
	// CustomTitle retrieves the custom title widget of the header. See
// gtk_header_bar_set_custom_title().
	func (b HeaderBar) CustomTitle() Widget {
var _arg0 *C.GtkHeaderBar // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkHeaderBar)(unsafe.Pointer(b.Native()))

_cret = C.gtk_header_bar_get_custom_title(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// DecorationLayout gets the decoration layout set with
// gtk_header_bar_set_decoration_layout().
	func (b HeaderBar) DecorationLayout() string {
var _arg0 *C.GtkHeaderBar // out
var _cret *C.gchar // in

_arg0 = (*C.GtkHeaderBar)(unsafe.Pointer(b.Native()))

_cret = C.gtk_header_bar_get_decoration_layout(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// HasSubtitle retrieves whether the header bar reserves space for a subtitle,
// regardless if one is currently set or not.
	func (b HeaderBar) HasSubtitle() bool {
var _arg0 *C.GtkHeaderBar // out
var _cret C.gboolean // in

_arg0 = (*C.GtkHeaderBar)(unsafe.Pointer(b.Native()))

_cret = C.gtk_header_bar_get_has_subtitle(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ShowCloseButton returns whether this header bar shows the standard window
// decorations.
	func (b HeaderBar) ShowCloseButton() bool {
var _arg0 *C.GtkHeaderBar // out
var _cret C.gboolean // in

_arg0 = (*C.GtkHeaderBar)(unsafe.Pointer(b.Native()))

_cret = C.gtk_header_bar_get_show_close_button(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Subtitle retrieves the subtitle of the header. See
// gtk_header_bar_set_subtitle().
	func (b HeaderBar) Subtitle() string {
var _arg0 *C.GtkHeaderBar // out
var _cret *C.gchar // in

_arg0 = (*C.GtkHeaderBar)(unsafe.Pointer(b.Native()))

_cret = C.gtk_header_bar_get_subtitle(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Title retrieves the title of the header. See gtk_header_bar_set_title().
	func (b HeaderBar) Title() string {
var _arg0 *C.GtkHeaderBar // out
var _cret *C.gchar // in

_arg0 = (*C.GtkHeaderBar)(unsafe.Pointer(b.Native()))

_cret = C.gtk_header_bar_get_title(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// PackEnd adds @child to @bar, packed with reference to the end of the @bar.
	func (b HeaderBar) PackEnd(child WidgetClass)  {
var _arg0 *C.GtkHeaderBar // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkHeaderBar)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

C.gtk_header_bar_pack_end(_arg0, _arg1)
}
	
	// PackStart adds @child to @bar, packed with reference to the start of the
// @bar.
	func (b HeaderBar) PackStart(child WidgetClass)  {
var _arg0 *C.GtkHeaderBar // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkHeaderBar)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

C.gtk_header_bar_pack_start(_arg0, _arg1)
}
	
	// SetCustomTitle sets a custom title for the HeaderBar.
// 
// The title should help a user identify the current view. This supersedes any
// title set by gtk_header_bar_set_title() or gtk_header_bar_set_subtitle(). To
// achieve the same style as the builtin title and subtitle, use the “title” and
// “subtitle” style classes.
// 
// You should set the custom title to nil, for the header title label to be
// visible again.
	func (b HeaderBar) SetCustomTitle(titleWidget WidgetClass)  {
var _arg0 *C.GtkHeaderBar // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkHeaderBar)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(titleWidget.Native()))

C.gtk_header_bar_set_custom_title(_arg0, _arg1)
}
	
	// SetDecorationLayout sets the decoration layout for this header bar,
// overriding the Settings:gtk-decoration-layout setting.
// 
// There can be valid reasons for overriding the setting, such as a header bar
// design that does not allow for buttons to take room on the right, or only
// offers room for a single close button. Split header bars are another example
// for overriding the setting.
// 
// The format of the string is button names, separated by commas. A colon
// separates the buttons that should appear on the left from those on the right.
// Recognized button names are minimize, maximize, close, icon (the window icon)
// and menu (a menu button for the fallback app menu).
// 
// For example, “menu:minimize,maximize,close” specifies a menu on the left, and
// minimize, maximize and close buttons on the right.
	func (b HeaderBar) SetDecorationLayout(layout string)  {
var _arg0 *C.GtkHeaderBar // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkHeaderBar)(unsafe.Pointer(b.Native()))
_arg1 = (*C.gchar)(C.CString(layout))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_header_bar_set_decoration_layout(_arg0, _arg1)
}
	
	// SetHasSubtitle sets whether the header bar should reserve space for a
// subtitle, even if none is currently set.
	func (b HeaderBar) SetHasSubtitle(setting bool)  {
var _arg0 *C.GtkHeaderBar // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkHeaderBar)(unsafe.Pointer(b.Native()))
if setting { _arg1 = C.TRUE }

C.gtk_header_bar_set_has_subtitle(_arg0, _arg1)
}
	
	// SetShowCloseButton sets whether this header bar shows the standard window
// decorations, including close, maximize, and minimize.
	func (b HeaderBar) SetShowCloseButton(setting bool)  {
var _arg0 *C.GtkHeaderBar // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkHeaderBar)(unsafe.Pointer(b.Native()))
if setting { _arg1 = C.TRUE }

C.gtk_header_bar_set_show_close_button(_arg0, _arg1)
}
	
	// SetSubtitle sets the subtitle of the HeaderBar. The title should give a user
// an additional detail to help him identify the current view.
// 
// Note that GtkHeaderBar by default reserves room for the subtitle, even if
// none is currently set. If this is not desired, set the HeaderBar:has-subtitle
// property to false.
	func (b HeaderBar) SetSubtitle(subtitle string)  {
var _arg0 *C.GtkHeaderBar // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkHeaderBar)(unsafe.Pointer(b.Native()))
_arg1 = (*C.gchar)(C.CString(subtitle))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_header_bar_set_subtitle(_arg0, _arg1)
}
	
	// SetTitle sets the title of the HeaderBar. The title should help a user
// identify the current view. A good title should not include the application
// name.
	func (b HeaderBar) SetTitle(title string)  {
var _arg0 *C.GtkHeaderBar // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkHeaderBar)(unsafe.Pointer(b.Native()))
_arg1 = (*C.gchar)(C.CString(title))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_header_bar_set_title(_arg0, _arg1)
}
	


	// IMContext defines the interface for GTK+ input methods. An input method is
// used by GTK+ text input widgets like Entry to map from key events to Unicode
// character strings.
// 
// The default input method can be set programmatically via the
// Settings:gtk-im-module GtkSettings property. Alternatively, you may set the
// GTK_IM_MODULE environment variable as documented in [Running GTK+
// Applications][gtk-running].
// 
// The Entry Entry:im-module and TextView TextView:im-module properties may also
// be used to set input methods for specific widget instances. For instance, a
// certain entry widget might be expected to contain certain characters which
// would be easier to input with a certain input method.
// 
// An input method may consume multiple key events in sequence and finally
// output the composed result. This is called preediting, and an input method
// may provide feedback about this process by displaying the intermediate
// composition states as preedit text. For instance, the default GTK+ input
// method implements the input of arbitrary Unicode code points by holding down
// the Control and Shift keys and then typing “U” followed by the hexadecimal
// digits of the code point. When releasing the Control and Shift keys,
// preediting ends and the character is inserted as text. Ctrl+Shift+u20AC for
// example results in the € sign.
// 
// Additional input methods can be made available for use by GTK+ widgets as
// loadable modules. An input method module is a small shared library which
// implements a subclass of IMContext or IMContextSimple and exports these four
// functions:
// 
//    GtkIMContext * im_module_create(const gchar *context_id);
// 
// This function should return a pointer to a newly created instance of the
// IMContext subclass identified by @context_id. The context ID is the same as
// specified in the IMContextInfo array returned by im_module_list().
// 
// After a new loadable input method module has been installed on the system,
// the configuration file `gtk.immodules` needs to be regenerated by
// [gtk-query-immodules-3.0][gtk-query-immodules-3.0], in order for the new
// input method to become available to GTK+ applications.
	type IMContext struct {
		**externglib.Object
		
	}

	// IMContextClass is an interface that the IMContext class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type IMContextClass interface {
		gextras.Objector
		_imContext()
	}

	func (IMContext) _imContext() {}

	
	func marshalIMContext(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapIMContext(obj), nil
	}
	

	

	
	// DeleteSurrounding asks the widget that the input context is attached to to
// delete characters around the cursor position by emitting the
// GtkIMContext::delete_surrounding signal. Note that @offset and @n_chars are
// in characters not in bytes which differs from the usage other places in
// IMContext.
// 
// In order to use this function, you should first call
// gtk_im_context_get_surrounding() to get the current context, and call this
// function immediately afterwards to make sure that you know what you are
// deleting. You should also account for the fact that even if the signal was
// handled, the input context might not have deleted all the characters that
// were requested to be deleted.
// 
// This function is used by an input method that wants to make subsitutions in
// the existing text in response to new input. It is not useful for
// applications.
	func (c IMContext) DeleteSurrounding(offset int, nChars int) bool {
var _arg0 *C.GtkIMContext // out
var _arg1 C.gint // out
var _arg2 C.gint // out
var _cret C.gboolean // in

_arg0 = (*C.GtkIMContext)(unsafe.Pointer(c.Native()))
_arg1 = (C.gint)(offset)
_arg2 = (C.gint)(nChars)

_cret = C.gtk_im_context_delete_surrounding(_arg0, _arg1, _arg2)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// FilterKeypress: allow an input method to internally handle key press and
// release events. If this function returns true, then no further processing
// should be done for this key event.
	func (c IMContext) FilterKeypress(event *gdk.EventKey) bool {
var _arg0 *C.GtkIMContext // out
var _arg1 *C.GdkEventKey // out
var _cret C.gboolean // in

_arg0 = (*C.GtkIMContext)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GdkEventKey)(unsafe.Pointer(event.Native()))

_cret = C.gtk_im_context_filter_keypress(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// FocusIn: notify the input method that the widget to which this input context
// corresponds has gained focus. The input method may, for example, change the
// displayed feedback to reflect this change.
	func (c IMContext) FocusIn()  {
var _arg0 *C.GtkIMContext // out

_arg0 = (*C.GtkIMContext)(unsafe.Pointer(c.Native()))

C.gtk_im_context_focus_in(_arg0)
}
	
	// FocusOut: notify the input method that the widget to which this input context
// corresponds has lost focus. The input method may, for example, change the
// displayed feedback or reset the contexts state to reflect this change.
	func (c IMContext) FocusOut()  {
var _arg0 *C.GtkIMContext // out

_arg0 = (*C.GtkIMContext)(unsafe.Pointer(c.Native()))

C.gtk_im_context_focus_out(_arg0)
}
	
	// PreeditString: retrieve the current preedit string for the input context, and
// a list of attributes to apply to the string. This string should be displayed
// inserted at the insertion point.
	func (c IMContext) PreeditString() (string, *pango.AttrList, int) {
var _arg0 *C.GtkIMContext // out
var _arg1 *C.gchar // in
var _attrs *pango.AttrList
var _arg3 C.gint // in

_arg0 = (*C.GtkIMContext)(unsafe.Pointer(c.Native()))

C.gtk_im_context_get_preedit_string(_arg0, &_arg1, (**C.PangoAttrList)(unsafe.Pointer(&_attrs)), &_arg3)

var _str string // out

var _cursorPos int // out

_str = C.GoString(_arg1)
defer C.free(unsafe.Pointer(_arg1))

_cursorPos = (int)(_arg3)

return _str, _attrs, _cursorPos
}
	
	// Surrounding retrieves context around the insertion point. Input methods
// typically want context in order to constrain input text based on existing
// text; this is important for languages such as Thai where only some sequences
// of characters are allowed.
// 
// This function is implemented by emitting the
// GtkIMContext::retrieve_surrounding signal on the input method; in response to
// this signal, a widget should provide as much context as is available, up to
// an entire paragraph, by calling gtk_im_context_set_surrounding(). Note that
// there is no obligation for a widget to respond to the ::retrieve_surrounding
// signal, so input methods must be prepared to function without context.
	func (c IMContext) Surrounding() (string, int, bool) {
var _arg0 *C.GtkIMContext // out
var _arg1 *C.gchar // in
var _arg2 C.gint // in
var _cret C.gboolean // in

_arg0 = (*C.GtkIMContext)(unsafe.Pointer(c.Native()))

_cret = C.gtk_im_context_get_surrounding(_arg0, &_arg1, &_arg2)


var _text string // out
var _cursorIndex int // out
var _ok bool // out

_text = C.GoString(_arg1)
defer C.free(unsafe.Pointer(_arg1))
_cursorIndex = (int)(_arg2)
if _cret != 0 { _ok = true }

return _text, _cursorIndex, _ok
}
	
	// Reset: notify the input method that a change such as a change in cursor
// position has been made. This will typically cause the input method to clear
// the preedit state.
	func (c IMContext) Reset()  {
var _arg0 *C.GtkIMContext // out

_arg0 = (*C.GtkIMContext)(unsafe.Pointer(c.Native()))

C.gtk_im_context_reset(_arg0)
}
	
	// SetClientWindow: set the client window for the input context; this is the
// Window in which the input appears. This window is used in order to correctly
// position status windows, and may also be used for purposes internal to the
// input method.
	func (c IMContext) SetClientWindow(window gdk.WindowClass)  {
var _arg0 *C.GtkIMContext // out
var _arg1 *C.GdkWindow // out

_arg0 = (*C.GtkIMContext)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GdkWindow)(unsafe.Pointer(window.Native()))

C.gtk_im_context_set_client_window(_arg0, _arg1)
}
	
	// SetCursorLocation: notify the input method that a change in cursor position
// has been made. The location is relative to the client window.
	func (c IMContext) SetCursorLocation(area *gdk.Rectangle)  {
var _arg0 *C.GtkIMContext // out
var _arg1 *C.GdkRectangle // out

_arg0 = (*C.GtkIMContext)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GdkRectangle)(unsafe.Pointer(area.Native()))

C.gtk_im_context_set_cursor_location(_arg0, _arg1)
}
	
	// SetSurrounding sets surrounding context around the insertion point and
// preedit string. This function is expected to be called in response to the
// GtkIMContext::retrieve_surrounding signal, and will likely have no effect if
// called at other times.
	func (c IMContext) SetSurrounding(text string, len int, cursorIndex int)  {
var _arg0 *C.GtkIMContext // out
var _arg1 *C.gchar // out
var _arg2 C.gint // out
var _arg3 C.gint // out

_arg0 = (*C.GtkIMContext)(unsafe.Pointer(c.Native()))
_arg1 = (*C.gchar)(C.CString(text))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.gint)(len)
_arg3 = (C.gint)(cursorIndex)

C.gtk_im_context_set_surrounding(_arg0, _arg1, _arg2, _arg3)
}
	
	// SetUsePreedit sets whether the IM context should use the preedit string to
// display feedback. If @use_preedit is FALSE (default is TRUE), then the IM
// context may use some other method to display feedback, such as displaying it
// in a child of the root window.
	func (c IMContext) SetUsePreedit(usePreedit bool)  {
var _arg0 *C.GtkIMContext // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkIMContext)(unsafe.Pointer(c.Native()))
if usePreedit { _arg1 = C.TRUE }

C.gtk_im_context_set_use_preedit(_arg0, _arg1)
}
	


	// IMContextSimple: gtkIMContextSimple is a simple input method context
// supporting table-based input methods. It has a built-in table of compose
// sequences that is derived from the X11 Compose files.
// 
// GtkIMContextSimple reads additional compose sequences from the first of the
// following files that is found: ~/.config/gtk-3.0/Compose, ~/.XCompose,
// /usr/share/X11/locale/$locale/Compose (for locales that have a nontrivial
// Compose file). The syntax of these files is described in the Compose(5)
// manual page.
// 
// 
// Unicode characters
// 
// GtkIMContextSimple also supports numeric entry of Unicode characters by
// typing Ctrl-Shift-u, followed by a hexadecimal Unicode codepoint. For
// example, Ctrl-Shift-u 1 2 3 Enter yields U+0123 LATIN SMALL LETTER G WITH
// CEDILLA, i.e. ģ.
	type IMContextSimple struct {
		IMContext
		
	}

	// IMContextSimpleClass is an interface that the IMContextSimple class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type IMContextSimpleClass interface {
		gextras.Objector
		_imContextSimple()
	}

	func (IMContextSimple) _imContextSimple() {}

	
	func marshalIMContextSimple(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapIMContextSimple(obj), nil
	}
	

	
	// NewIMContextSimple creates a new IMContextSimple.
	func NewIMContextSimple() IMContextSimple {
var _cret *C.GtkIMContext // in

_cret = C.gtk_im_context_simple_new()


var _imContextSimple IMContextSimple // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_imContextSimple = IMContextSimple{
IMContext: IMContext{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _imContextSimple
}
	

	
	// AddComposeFile adds an additional table from the X11 compose file.
	func (c IMContextSimple) AddComposeFile(composeFile string)  {
var _arg0 *C.GtkIMContextSimple // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkIMContextSimple)(unsafe.Pointer(c.Native()))
_arg1 = (*C.gchar)(C.CString(composeFile))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_im_context_simple_add_compose_file(_arg0, _arg1)
}
	


	
	type IMMulticontext struct {
		IMContext
		
	}

	// IMMulticontextClass is an interface that the IMMulticontext class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type IMMulticontextClass interface {
		gextras.Objector
		_imMulticontext()
	}

	func (IMMulticontext) _imMulticontext() {}

	
	func marshalIMMulticontext(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapIMMulticontext(obj), nil
	}
	

	
	// NewIMMulticontext creates a new IMMulticontext.
	func NewIMMulticontext() IMMulticontext {
var _cret *C.GtkIMContext // in

_cret = C.gtk_im_multicontext_new()


var _imMulticontext IMMulticontext // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_imMulticontext = IMMulticontext{
IMContext: IMContext{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _imMulticontext
}
	

	
	// AppendMenuitems: add menuitems for various available input methods to a menu;
// the menuitems, when selected, will switch the input method for the context
// and the global default input method.
	func (c IMMulticontext) AppendMenuitems(menushell MenuShellClass)  {
var _arg0 *C.GtkIMMulticontext // out
var _arg1 *C.GtkMenuShell // out

_arg0 = (*C.GtkIMMulticontext)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GtkMenuShell)(unsafe.Pointer(menushell.Native()))

C.gtk_im_multicontext_append_menuitems(_arg0, _arg1)
}
	
	// ContextID gets the id of the currently active slave of the @context.
	func (c IMMulticontext) ContextID() string {
var _arg0 *C.GtkIMMulticontext // out
var _cret *C.char // in

_arg0 = (*C.GtkIMMulticontext)(unsafe.Pointer(c.Native()))

_cret = C.gtk_im_multicontext_get_context_id(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// SetContextID sets the context id for @context.
// 
// This causes the currently active slave of @context to be replaced by the
// slave corresponding to the new context id.
	func (c IMMulticontext) SetContextID(contextId string)  {
var _arg0 *C.GtkIMMulticontext // out
var _arg1 *C.char // out

_arg0 = (*C.GtkIMMulticontext)(unsafe.Pointer(c.Native()))
_arg1 = (*C.char)(C.CString(contextId))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_im_multicontext_set_context_id(_arg0, _arg1)
}
	


	// IconFactory: an icon factory manages a collection of IconSet; a IconSet
// manages a set of variants of a particular icon (i.e. a IconSet contains
// variants for different sizes and widget states). Icons in an icon factory are
// named by a stock ID, which is a simple string identifying the icon. Each
// Style has a list of IconFactory derived from the current theme; those icon
// factories are consulted first when searching for an icon. If the theme
// doesn’t set a particular icon, GTK+ looks for the icon in a list of default
// icon factories, maintained by gtk_icon_factory_add_default() and
// gtk_icon_factory_remove_default(). Applications with icons should add a
// default icon factory with their icons, which will allow themes to override
// the icons for the application.
// 
// To display an icon, always use gtk_style_lookup_icon_set() on the widget that
// will display the icon, or the convenience function gtk_widget_render_icon().
// These functions take the theme into account when looking up the icon to use
// for a given stock ID.
// 
// 
// GtkIconFactory as GtkBuildable
// 
// GtkIconFactory supports a custom <sources> element, which can contain
// multiple <source> elements. The following attributes are allowed:
// 
// - stock-id
// 
//    The stock id of the source, a string. This attribute is
//    mandatory
// 
// - filename
// 
//    The filename of the source, a string.  This attribute is
//    optional
// 
// - icon-name
// 
//    The icon name for the source, a string.  This attribute is
//    optional.
// 
// - size
// 
//    Size of the icon, a IconSize enum value.  This attribute is
//    optional.
// 
// - direction
// 
//    Direction of the source, a TextDirection enum value.  This
//    attribute is optional.
// 
// - state
// 
//    State of the source, a StateType enum value.  This
//    attribute is optional.
// 
// A IconFactory UI definition fragment. ##
// 
//    <object class="GtkIconFactory" id="iconfactory1">
//      <sources>
//        <source stock-id="apple-red" filename="apple-red.png"/>
//      </sources>
//    </object>
//    <object class="GtkWindow" id="window1">
//      <child>
//        <object class="GtkButton" id="apple_button">
//          <property name="label">apple-red</property>
//          <property name="use-stock">True</property>
//        </object>
//      </child>
//    </object>
	type IconFactory struct {
		**externglib.Object
		Buildable
		
	}

	// IconFactoryClass is an interface that the IconFactory class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type IconFactoryClass interface {
		gextras.Objector
		_iconFactory()
	}

	func (IconFactory) _iconFactory() {}

	
	func marshalIconFactory(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapIconFactory(obj), nil
	}
	

	
	// NewIconFactory creates a new IconFactory. An icon factory manages a
// collection of IconSets; a IconSet manages a set of variants of a particular
// icon (i.e. a IconSet contains variants for different sizes and widget
// states). Icons in an icon factory are named by a stock ID, which is a simple
// string identifying the icon. Each Style has a list of IconFactorys derived
// from the current theme; those icon factories are consulted first when
// searching for an icon. If the theme doesn’t set a particular icon, GTK+ looks
// for the icon in a list of default icon factories, maintained by
// gtk_icon_factory_add_default() and gtk_icon_factory_remove_default().
// Applications with icons should add a default icon factory with their icons,
// which will allow themes to override the icons for the application.
	func NewIconFactory() IconFactory {
var _cret *C.GtkIconFactory // in

_cret = C.gtk_icon_factory_new()


var _iconFactory IconFactory // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_iconFactory = IconFactory{
Object: &externglib.Object{externglib.ToGObject(obj)},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _iconFactory
}
	

	
	// Add adds the given @icon_set to the icon factory, under the name @stock_id.
// @stock_id should be namespaced for your application, e.g.
// “myapp-whatever-icon”. Normally applications create a IconFactory, then add
// it to the list of default factories with gtk_icon_factory_add_default(). Then
// they pass the @stock_id to widgets such as Image to display the icon. Themes
// can provide an icon with the same name (such as "myapp-whatever-icon") to
// override your application’s default icons. If an icon already existed in
// @factory for @stock_id, it is unreferenced and replaced with the new
// @icon_set.
	func (f IconFactory) Add(stockId string, iconSet *IconSet)  {
var _arg0 *C.GtkIconFactory // out
var _arg1 *C.gchar // out
var _arg2 *C.GtkIconSet // out

_arg0 = (*C.GtkIconFactory)(unsafe.Pointer(f.Native()))
_arg1 = (*C.gchar)(C.CString(stockId))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.GtkIconSet)(unsafe.Pointer(iconSet.Native()))

C.gtk_icon_factory_add(_arg0, _arg1, _arg2)
}
	
	// AddDefault adds an icon factory to the list of icon factories searched by
// gtk_style_lookup_icon_set(). This means that, for example,
// gtk_image_new_from_stock() will be able to find icons in @factory. There will
// normally be an icon factory added for each library or application that comes
// with icons. The default icon factories can be overridden by themes.
	func (f IconFactory) AddDefault()  {
var _arg0 *C.GtkIconFactory // out

_arg0 = (*C.GtkIconFactory)(unsafe.Pointer(f.Native()))

C.gtk_icon_factory_add_default(_arg0)
}
	
	// Lookup looks up @stock_id in the icon factory, returning an icon set if
// found, otherwise nil. For display to the user, you should use
// gtk_style_lookup_icon_set() on the Style for the widget that will display the
// icon, instead of using this function directly, so that themes are taken into
// account.
	func (f IconFactory) Lookup(stockId string) *IconSet {
var _arg0 *C.GtkIconFactory // out
var _arg1 *C.gchar // out
var _cret *C.GtkIconSet // in

_arg0 = (*C.GtkIconFactory)(unsafe.Pointer(f.Native()))
_arg1 = (*C.gchar)(C.CString(stockId))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_icon_factory_lookup(_arg0, _arg1)


var _iconSet *IconSet // out

_iconSet = *(**IconSet)(unsafe.Pointer(&_cret))

return _iconSet
}
	
	// RemoveDefault removes an icon factory from the list of default icon
// factories. Not normally used; you might use it for a library that can be
// unloaded or shut down.
	func (f IconFactory) RemoveDefault()  {
var _arg0 *C.GtkIconFactory // out

_arg0 = (*C.GtkIconFactory)(unsafe.Pointer(f.Native()))

C.gtk_icon_factory_remove_default(_arg0)
}
	


	// IconInfo contains information found when looking up an icon in an icon theme.
	type IconInfo struct {
		**externglib.Object
		
	}

	// IconInfoClass is an interface that the IconInfo class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type IconInfoClass interface {
		gextras.Objector
		_iconInfo()
	}

	func (IconInfo) _iconInfo() {}

	
	func marshalIconInfo(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapIconInfo(obj), nil
	}
	

	
	// NewIconInfoForPixbuf creates a IconInfo for a Pixbuf.
	func NewIconInfoForPixbuf(iconTheme IconThemeClass, pixbuf gdkpixbuf.PixbufClass) IconInfo {
var _arg1 *C.GtkIconTheme // out
var _arg2 *C.GdkPixbuf // out
var _cret *C.GtkIconInfo // in

_arg1 = (*C.GtkIconTheme)(unsafe.Pointer(iconTheme.Native()))
_arg2 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))

_cret = C.gtk_icon_info_new_for_pixbuf(_arg1, _arg2)


var _iconInfo IconInfo // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_iconInfo = IconInfo{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}

return _iconInfo
}
	

	
	// AttachPoints: this function is deprecated and always returns false.
	func (i IconInfo) AttachPoints() ([]gdk.Point, bool) {
var _arg0 *C.GtkIconInfo // out
var _arg1 *C.GdkPoint
var _arg2 C.gint // in
var _cret C.gboolean // in

_arg0 = (*C.GtkIconInfo)(unsafe.Pointer(i.Native()))

_cret = C.gtk_icon_info_get_attach_points(_arg0, &_arg1, &_arg2)


var _points []gdk.Point
var _ok bool // out

_points = unsafe.Slice((*gdk.Point)(unsafe.Pointer(_arg1)), _arg2)
runtime.SetFinalizer(&_points, func(v *[]gdk.Point) {
  C.free(unsafe.Pointer(&(*v)[0]))
})
if _cret != 0 { _ok = true }

return _points, _ok
}
	
	// BaseScale gets the base scale for the icon. The base scale is a scale for the
// icon that was specified by the icon theme creator. For instance an icon drawn
// for a high-dpi screen with window scale 2 for a base size of 32 will be 64
// pixels tall and have a base scale of 2.
	func (i IconInfo) BaseScale() int {
var _arg0 *C.GtkIconInfo // out
var _cret C.gint // in

_arg0 = (*C.GtkIconInfo)(unsafe.Pointer(i.Native()))

_cret = C.gtk_icon_info_get_base_scale(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// BaseSize gets the base size for the icon. The base size is a size for the
// icon that was specified by the icon theme creator. This may be different than
// the actual size of image; an example of this is small emblem icons that can
// be attached to a larger icon. These icons will be given the same base size as
// the larger icons to which they are attached.
// 
// Note that for scaled icons the base size does not include the base scale.
	func (i IconInfo) BaseSize() int {
var _arg0 *C.GtkIconInfo // out
var _cret C.gint // in

_arg0 = (*C.GtkIconInfo)(unsafe.Pointer(i.Native()))

_cret = C.gtk_icon_info_get_base_size(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// BuiltinPixbuf gets the built-in image for this icon, if any. To allow GTK+ to
// use built in icon images, you must pass the GTK_ICON_LOOKUP_USE_BUILTIN to
// gtk_icon_theme_lookup_icon().
	func (i IconInfo) BuiltinPixbuf() gdkpixbuf.Pixbuf {
var _arg0 *C.GtkIconInfo // out
var _cret *C.GdkPixbuf // in

_arg0 = (*C.GtkIconInfo)(unsafe.Pointer(i.Native()))

_cret = C.gtk_icon_info_get_builtin_pixbuf(_arg0)


var _pixbuf gdkpixbuf.Pixbuf // out

_pixbuf = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdkpixbuf.Pixbuf)

return _pixbuf
}
	
	// DisplayName: this function is deprecated and always returns nil.
	func (i IconInfo) DisplayName() string {
var _arg0 *C.GtkIconInfo // out
var _cret *C.gchar // in

_arg0 = (*C.GtkIconInfo)(unsafe.Pointer(i.Native()))

_cret = C.gtk_icon_info_get_display_name(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// EmbeddedRect: this function is deprecated and always returns false.
	func (i IconInfo) EmbeddedRect() (gdk.Rectangle, bool) {
var _arg0 *C.GtkIconInfo // out
var _rectangle gdk.Rectangle
var _cret C.gboolean // in

_arg0 = (*C.GtkIconInfo)(unsafe.Pointer(i.Native()))

_cret = C.gtk_icon_info_get_embedded_rect(_arg0, (*C.GdkRectangle)(unsafe.Pointer(&_rectangle)))



var _ok bool // out


if _cret != 0 { _ok = true }

return _rectangle, _ok
}
	
	// Filename gets the filename for the icon. If the GTK_ICON_LOOKUP_USE_BUILTIN
// flag was passed to gtk_icon_theme_lookup_icon(), there may be no filename if
// a builtin icon is returned; in this case, you should use
// gtk_icon_info_get_builtin_pixbuf().
	func (i IconInfo) Filename() string {
var _arg0 *C.GtkIconInfo // out
var _cret *C.gchar // in

_arg0 = (*C.GtkIconInfo)(unsafe.Pointer(i.Native()))

_cret = C.gtk_icon_info_get_filename(_arg0)


var _filename string // out

_filename = C.GoString(_cret)

return _filename
}
	
	// IsSymbolic checks if the icon is symbolic or not. This currently uses only
// the file name and not the file contents for determining this. This behaviour
// may change in the future.
	func (i IconInfo) IsSymbolic() bool {
var _arg0 *C.GtkIconInfo // out
var _cret C.gboolean // in

_arg0 = (*C.GtkIconInfo)(unsafe.Pointer(i.Native()))

_cret = C.gtk_icon_info_is_symbolic(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// LoadIcon renders an icon previously looked up in an icon theme using
// gtk_icon_theme_lookup_icon(); the size will be based on the size passed to
// gtk_icon_theme_lookup_icon(). Note that the resulting pixbuf may not be
// exactly this size; an icon theme may have icons that differ slightly from
// their nominal sizes, and in addition GTK+ will avoid scaling icons that it
// considers sufficiently close to the requested size or for which the source
// image would have to be scaled up too far. (This maintains sharpness.). This
// behaviour can be changed by passing the GTK_ICON_LOOKUP_FORCE_SIZE flag when
// obtaining the IconInfo. If this flag has been specified, the pixbuf returned
// by this function will be scaled to the exact size.
	func (i IconInfo) LoadIcon() (gdkpixbuf.Pixbuf, error) {
var _arg0 *C.GtkIconInfo // out
var _cret *C.GdkPixbuf // in
var _cerr *C.GError // in

_arg0 = (*C.GtkIconInfo)(unsafe.Pointer(i.Native()))

_cret = C.gtk_icon_info_load_icon(_arg0, &_cerr)


var _pixbuf gdkpixbuf.Pixbuf // out
var _goerr error // out

_pixbuf = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gdkpixbuf.Pixbuf)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _pixbuf, _goerr
}
	
	// LoadIconFinish finishes an async icon load, see
// gtk_icon_info_load_icon_async().
	func (i IconInfo) LoadIconFinish(res gio.AsyncResult) (gdkpixbuf.Pixbuf, error) {
var _arg0 *C.GtkIconInfo // out
var _arg1 *C.GAsyncResult // out
var _cret *C.GdkPixbuf // in
var _cerr *C.GError // in

_arg0 = (*C.GtkIconInfo)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

_cret = C.gtk_icon_info_load_icon_finish(_arg0, _arg1, &_cerr)


var _pixbuf gdkpixbuf.Pixbuf // out
var _goerr error // out

_pixbuf = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gdkpixbuf.Pixbuf)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _pixbuf, _goerr
}
	
	// LoadSurface renders an icon previously looked up in an icon theme using
// gtk_icon_theme_lookup_icon(); the size will be based on the size passed to
// gtk_icon_theme_lookup_icon(). Note that the resulting surface may not be
// exactly this size; an icon theme may have icons that differ slightly from
// their nominal sizes, and in addition GTK+ will avoid scaling icons that it
// considers sufficiently close to the requested size or for which the source
// image would have to be scaled up too far. (This maintains sharpness.). This
// behaviour can be changed by passing the GTK_ICON_LOOKUP_FORCE_SIZE flag when
// obtaining the IconInfo. If this flag has been specified, the pixbuf returned
// by this function will be scaled to the exact size.
	func (i IconInfo) LoadSurface(forWindow gdk.WindowClass) (*cairo.Surface, error) {
var _arg0 *C.GtkIconInfo // out
var _arg1 *C.GdkWindow // out
var _cret *C.cairo_surface_t // in
var _cerr *C.GError // in

_arg0 = (*C.GtkIconInfo)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GdkWindow)(unsafe.Pointer(forWindow.Native()))

_cret = C.gtk_icon_info_load_surface(_arg0, _arg1, &_cerr)


var _surface *cairo.Surface // out
var _goerr error // out

_surface = *(**cairo.Surface)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_surface, func(v *cairo.Surface) {
  C.free(unsafe.Pointer(v.Native()))
})
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _surface, _goerr
}
	
	// LoadSymbolic loads an icon, modifying it to match the system colours for the
// foreground, success, warning and error colors provided. If the icon is not a
// symbolic one, the function will return the result from
// gtk_icon_info_load_icon().
// 
// This allows loading symbolic icons that will match the system theme.
// 
// Unless you are implementing a widget, you will want to use
// g_themed_icon_new_with_default_fallbacks() to load the icon.
// 
// As implementation details, the icon loaded needs to be of SVG type, contain
// the “symbolic” term as the last component of the icon name, and use the “fg”,
// “success”, “warning” and “error” CSS styles in the SVG file itself.
// 
// See the Symbolic Icons Specification
// (http://www.freedesktop.org/wiki/SymbolicIcons) for more information about
// symbolic icons.
	func (i IconInfo) LoadSymbolic(fg *gdk.RGBA, successColor *gdk.RGBA, warningColor *gdk.RGBA, errorColor *gdk.RGBA) (bool, gdkpixbuf.Pixbuf, error) {
var _arg0 *C.GtkIconInfo // out
var _arg1 *C.GdkRGBA // out
var _arg2 *C.GdkRGBA // out
var _arg3 *C.GdkRGBA // out
var _arg4 *C.GdkRGBA // out
var _arg5 C.gboolean // in
var _cret *C.GdkPixbuf // in
var _cerr *C.GError // in

_arg0 = (*C.GtkIconInfo)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GdkRGBA)(unsafe.Pointer(fg.Native()))
_arg2 = (*C.GdkRGBA)(unsafe.Pointer(successColor.Native()))
_arg3 = (*C.GdkRGBA)(unsafe.Pointer(warningColor.Native()))
_arg4 = (*C.GdkRGBA)(unsafe.Pointer(errorColor.Native()))

_cret = C.gtk_icon_info_load_symbolic(_arg0, _arg1, _arg2, _arg3, _arg4, &_arg5, &_cerr)


var _wasSymbolic bool // out
var _pixbuf gdkpixbuf.Pixbuf // out
var _goerr error // out

if _arg5 { _wasSymbolic = true }
_pixbuf = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gdkpixbuf.Pixbuf)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _wasSymbolic, _pixbuf, _goerr
}
	
	// LoadSymbolicFinish finishes an async icon load, see
// gtk_icon_info_load_symbolic_async().
	func (i IconInfo) LoadSymbolicFinish(res gio.AsyncResult) (bool, gdkpixbuf.Pixbuf, error) {
var _arg0 *C.GtkIconInfo // out
var _arg1 *C.GAsyncResult // out
var _arg2 C.gboolean // in
var _cret *C.GdkPixbuf // in
var _cerr *C.GError // in

_arg0 = (*C.GtkIconInfo)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

_cret = C.gtk_icon_info_load_symbolic_finish(_arg0, _arg1, &_arg2, &_cerr)


var _wasSymbolic bool // out
var _pixbuf gdkpixbuf.Pixbuf // out
var _goerr error // out

if _arg2 { _wasSymbolic = true }
_pixbuf = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gdkpixbuf.Pixbuf)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _wasSymbolic, _pixbuf, _goerr
}
	
	// LoadSymbolicForContext loads an icon, modifying it to match the system colors
// for the foreground, success, warning and error colors provided. If the icon
// is not a symbolic one, the function will return the result from
// gtk_icon_info_load_icon(). This function uses the regular foreground color
// and the symbolic colors with the names “success_color”, “warning_color” and
// “error_color” from the context.
// 
// This allows loading symbolic icons that will match the system theme.
// 
// See gtk_icon_info_load_symbolic() for more details.
	func (i IconInfo) LoadSymbolicForContext(context StyleContextClass) (bool, gdkpixbuf.Pixbuf, error) {
var _arg0 *C.GtkIconInfo // out
var _arg1 *C.GtkStyleContext // out
var _arg2 C.gboolean // in
var _cret *C.GdkPixbuf // in
var _cerr *C.GError // in

_arg0 = (*C.GtkIconInfo)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))

_cret = C.gtk_icon_info_load_symbolic_for_context(_arg0, _arg1, &_arg2, &_cerr)


var _wasSymbolic bool // out
var _pixbuf gdkpixbuf.Pixbuf // out
var _goerr error // out

if _arg2 { _wasSymbolic = true }
_pixbuf = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gdkpixbuf.Pixbuf)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _wasSymbolic, _pixbuf, _goerr
}
	
	// LoadSymbolicForContextFinish finishes an async icon load, see
// gtk_icon_info_load_symbolic_for_context_async().
	func (i IconInfo) LoadSymbolicForContextFinish(res gio.AsyncResult) (bool, gdkpixbuf.Pixbuf, error) {
var _arg0 *C.GtkIconInfo // out
var _arg1 *C.GAsyncResult // out
var _arg2 C.gboolean // in
var _cret *C.GdkPixbuf // in
var _cerr *C.GError // in

_arg0 = (*C.GtkIconInfo)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

_cret = C.gtk_icon_info_load_symbolic_for_context_finish(_arg0, _arg1, &_arg2, &_cerr)


var _wasSymbolic bool // out
var _pixbuf gdkpixbuf.Pixbuf // out
var _goerr error // out

if _arg2 { _wasSymbolic = true }
_pixbuf = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gdkpixbuf.Pixbuf)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _wasSymbolic, _pixbuf, _goerr
}
	
	// LoadSymbolicForStyle loads an icon, modifying it to match the system colours
// for the foreground, success, warning and error colors provided. If the icon
// is not a symbolic one, the function will return the result from
// gtk_icon_info_load_icon().
// 
// This allows loading symbolic icons that will match the system theme.
// 
// See gtk_icon_info_load_symbolic() for more details.
	func (i IconInfo) LoadSymbolicForStyle(style StyleClass, state StateType) (bool, gdkpixbuf.Pixbuf, error) {
var _arg0 *C.GtkIconInfo // out
var _arg1 *C.GtkStyle // out
var _arg2 C.GtkStateType // out
var _arg3 C.gboolean // in
var _cret *C.GdkPixbuf // in
var _cerr *C.GError // in

_arg0 = (*C.GtkIconInfo)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GtkStyle)(unsafe.Pointer(style.Native()))
_arg2 = (C.GtkStateType)(state)

_cret = C.gtk_icon_info_load_symbolic_for_style(_arg0, _arg1, _arg2, &_arg3, &_cerr)


var _wasSymbolic bool // out
var _pixbuf gdkpixbuf.Pixbuf // out
var _goerr error // out

if _arg3 { _wasSymbolic = true }
_pixbuf = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gdkpixbuf.Pixbuf)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _wasSymbolic, _pixbuf, _goerr
}
	
	// SetRawCoordinates sets whether the coordinates returned by
// gtk_icon_info_get_embedded_rect() and gtk_icon_info_get_attach_points()
// should be returned in their original form as specified in the icon theme,
// instead of scaled appropriately for the pixbuf returned by
// gtk_icon_info_load_icon().
// 
// Raw coordinates are somewhat strange; they are specified to be with respect
// to the unscaled pixmap for PNG and XPM icons, but for SVG icons, they are in
// a 1000x1000 coordinate space that is scaled to the final size of the icon.
// You can determine if the icon is an SVG icon by using
// gtk_icon_info_get_filename(), and seeing if it is non-nil and ends in “.svg”.
// 
// This function is provided primarily to allow compatibility wrappers for older
// API's, and is not expected to be useful for applications.
	func (i IconInfo) SetRawCoordinates(rawCoordinates bool)  {
var _arg0 *C.GtkIconInfo // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkIconInfo)(unsafe.Pointer(i.Native()))
if rawCoordinates { _arg1 = C.TRUE }

C.gtk_icon_info_set_raw_coordinates(_arg0, _arg1)
}
	


	// IconTheme provides a facility for looking up icons by name and size. The main
// reason for using a name rather than simply providing a filename is to allow
// different icons to be used depending on what “icon theme” is selected by the
// user. The operation of icon themes on Linux and Unix follows the Icon Theme
// Specification (http://www.freedesktop.org/Standards/icon-theme-spec) There is
// a fallback icon theme, named `hicolor`, where applications should install
// their icons, but additional icon themes can be installed as operating system
// vendors and users choose.
// 
// Named icons are similar to the deprecated [Stock Items][gtkstock], and the
// distinction between the two may be a bit confusing. A few things to keep in
// mind:
// 
// - Stock images usually are used in conjunction with [Stock Items][gtkstock],
// such as GTK_STOCK_OK or GTK_STOCK_OPEN. Named icons are easier to set up and
// therefore are more useful for new icons that an application wants to add,
// such as application icons or window icons.
// 
// - Stock images can only be loaded at the symbolic sizes defined by the
// IconSize enumeration, or by custom sizes defined by gtk_icon_size_register(),
// while named icons are more flexible and any pixel size can be specified.
// 
// - Because stock images are closely tied to stock items, and thus to actions
// in the user interface, stock images may come in multiple variants for
// different widget states or writing directions.
// 
// A good rule of thumb is that if there is a stock image for what you want to
// use, use it, otherwise use a named icon. It turns out that internally stock
// images are generally defined in terms of one or more named icons. (An example
// of the more than one case is icons that depend on writing direction;
// GTK_STOCK_GO_FORWARD uses the two themed icons “gtk-stock-go-forward-ltr” and
// “gtk-stock-go-forward-rtl”.)
// 
// In many cases, named themes are used indirectly, via Image or stock items,
// rather than directly, but looking up icons directly is also simple. The
// IconTheme object acts as a database of all the icons in the current theme.
// You can create new IconTheme objects, but it’s much more efficient to use the
// standard icon theme for the Screen so that the icon information is shared
// with other people looking up icons.
// 
//    GError *error = NULL;
//    GtkIconTheme *icon_theme;
//    GdkPixbuf *pixbuf;
// 
//    icon_theme = gtk_icon_theme_get_default ();
//    pixbuf = gtk_icon_theme_load_icon (icon_theme,
//                                       "my-icon-name", // icon name
//                                       48, // icon size
//                                       0,  // flags
//                                       &error);
//    if (!pixbuf)
//      {
//        g_warning ("Couldn’t load icon: s", error->message);
//        g_error_free (error);
//      }
//    else
//      {
//        // Use the pixbuf
//        g_object_unref (pixbuf);
//      }
	type IconTheme struct {
		**externglib.Object
		
	}

	// IconThemeClass is an interface that the IconTheme class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type IconThemeClass interface {
		gextras.Objector
		_iconTheme()
	}

	func (IconTheme) _iconTheme() {}

	
	func marshalIconTheme(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapIconTheme(obj), nil
	}
	

	
	// NewIconTheme creates a new icon theme object. Icon theme objects are used to
// lookup up an icon by name in a particular icon theme. Usually, you’ll want to
// use gtk_icon_theme_get_default() or gtk_icon_theme_get_for_screen() rather
// than creating a new icon theme object for scratch.
	func NewIconTheme() IconTheme {
var _cret *C.GtkIconTheme // in

_cret = C.gtk_icon_theme_new()


var _iconTheme IconTheme // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_iconTheme = IconTheme{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}

return _iconTheme
}
	

	
	// AddResourcePath adds a resource path that will be looked at when looking for
// icons, similar to search paths.
// 
// This function should be used to make application-specific icons available as
// part of the icon theme.
// 
// The resources are considered as part of the hicolor icon theme and must be
// located in subdirectories that are defined in the hicolor icon theme, such as
// `@path/16x16/actions/run.png`. Icons that are directly placed in the resource
// path instead of a subdirectory are also considered as ultimate fallback.
	func (i IconTheme) AddResourcePath(path string)  {
var _arg0 *C.GtkIconTheme // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(i.Native()))
_arg1 = (*C.gchar)(C.CString(path))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_icon_theme_add_resource_path(_arg0, _arg1)
}
	
	// AppendSearchPath appends a directory to the search path. See
// gtk_icon_theme_set_search_path().
	func (i IconTheme) AppendSearchPath(path string)  {
var _arg0 *C.GtkIconTheme // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(i.Native()))
_arg1 = (*C.gchar)(C.CString(path))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_icon_theme_append_search_path(_arg0, _arg1)
}
	
	// ChooseIcon looks up a named icon and returns a IconInfo containing
// information such as the filename of the icon. The icon can then be rendered
// into a pixbuf using gtk_icon_info_load_icon(). (gtk_icon_theme_load_icon()
// combines these two steps if all you need is the pixbuf.)
// 
// If @icon_names contains more than one name, this function tries them all in
// the given order before falling back to inherited icon themes.
	func (i IconTheme) ChooseIcon(iconNames []string, size int, flags IconLookupFlags) IconInfo {
var _arg0 *C.GtkIconTheme // out
var _arg1 **C.gchar
var _arg2 C.gint // out
var _arg3 C.GtkIconLookupFlags // out
var _cret *C.GtkIconInfo // in

_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(i.Native()))
_arg1 = (**C.gchar)(C.malloc(C.ulong(len(iconNames)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
defer C.free(unsafe.Pointer(_arg1))
{
out := unsafe.Slice(_arg1, len(iconNames))
for i := range iconNames {
out[i] = (*C.gchar)(C.CString(iconNames[i]))
defer C.free(unsafe.Pointer(out[i]))
}
}
_arg2 = (C.gint)(size)
_arg3 = (C.GtkIconLookupFlags)(flags)

_cret = C.gtk_icon_theme_choose_icon(_arg0, _arg1, _arg2, _arg3)


var _iconInfo IconInfo // out

_iconInfo = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(IconInfo)

return _iconInfo
}
	
	// ChooseIconForScale looks up a named icon for a particular window scale and
// returns a IconInfo containing information such as the filename of the icon.
// The icon can then be rendered into a pixbuf using gtk_icon_info_load_icon().
// (gtk_icon_theme_load_icon() combines these two steps if all you need is the
// pixbuf.)
// 
// If @icon_names contains more than one name, this function tries them all in
// the given order before falling back to inherited icon themes.
	func (i IconTheme) ChooseIconForScale(iconNames []string, size int, scale int, flags IconLookupFlags) IconInfo {
var _arg0 *C.GtkIconTheme // out
var _arg1 **C.gchar
var _arg2 C.gint // out
var _arg3 C.gint // out
var _arg4 C.GtkIconLookupFlags // out
var _cret *C.GtkIconInfo // in

_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(i.Native()))
_arg1 = (**C.gchar)(C.malloc(C.ulong(len(iconNames)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
defer C.free(unsafe.Pointer(_arg1))
{
out := unsafe.Slice(_arg1, len(iconNames))
for i := range iconNames {
out[i] = (*C.gchar)(C.CString(iconNames[i]))
defer C.free(unsafe.Pointer(out[i]))
}
}
_arg2 = (C.gint)(size)
_arg3 = (C.gint)(scale)
_arg4 = (C.GtkIconLookupFlags)(flags)

_cret = C.gtk_icon_theme_choose_icon_for_scale(_arg0, _arg1, _arg2, _arg3, _arg4)


var _iconInfo IconInfo // out

_iconInfo = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(IconInfo)

return _iconInfo
}
	
	// ExampleIconName gets the name of an icon that is representative of the
// current theme (for instance, to use when presenting a list of themes to the
// user.)
	func (i IconTheme) ExampleIconName() string {
var _arg0 *C.GtkIconTheme // out
var _cret *C.char // in

_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(i.Native()))

_cret = C.gtk_icon_theme_get_example_icon_name(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// IconSizes returns an array of integers describing the sizes at which the icon
// is available without scaling. A size of -1 means that the icon is available
// in a scalable format. The array is zero-terminated.
	func (i IconTheme) IconSizes(iconName string) []int {
var _arg0 *C.GtkIconTheme // out
var _arg1 *C.gchar // out
var _cret *C.gint

_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(i.Native()))
_arg1 = (*C.gchar)(C.CString(iconName))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_icon_theme_get_icon_sizes(_arg0, _arg1)


var _gints []int

{
var i int
var z C.gint
for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
  i++
}

src := unsafe.Slice(_cret, i)
_gints = make([]int, i)
for i := range src {
_gints[i] = (int)(src[i])
}
}

return _gints
}
	
	// SearchPath gets the current search path. See
// gtk_icon_theme_set_search_path().
	func (i IconTheme) SearchPath() []string {
var _arg0 *C.GtkIconTheme // out
var _arg1 **C.gchar
var _arg2 C.gint // in

_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(i.Native()))

C.gtk_icon_theme_get_search_path(_arg0, &_arg1, &_arg2)

var _path []string

{
src := unsafe.Slice(_arg1, _arg2)
defer C.free(unsafe.Pointer(_arg1))
_path = make([]string, _arg2)
for i := 0; i < int(_arg2); i++ {
_path[i] = C.GoString(src[i])
defer C.free(unsafe.Pointer(src[i]))
}
}

return _path
}
	
	// HasIcon checks whether an icon theme includes an icon for a particular name.
	func (i IconTheme) HasIcon(iconName string) bool {
var _arg0 *C.GtkIconTheme // out
var _arg1 *C.gchar // out
var _cret C.gboolean // in

_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(i.Native()))
_arg1 = (*C.gchar)(C.CString(iconName))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_icon_theme_has_icon(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// LoadIcon looks up an icon in an icon theme, scales it to the given size and
// renders it into a pixbuf. This is a convenience function; if more details
// about the icon are needed, use gtk_icon_theme_lookup_icon() followed by
// gtk_icon_info_load_icon().
// 
// Note that you probably want to listen for icon theme changes and update the
// icon. This is usually done by connecting to the GtkWidget::style-set signal.
// If for some reason you do not want to update the icon when the icon theme
// changes, you should consider using gdk_pixbuf_copy() to make a private copy
// of the pixbuf returned by this function. Otherwise GTK+ may need to keep the
// old icon theme loaded, which would be a waste of memory.
	func (i IconTheme) LoadIcon(iconName string, size int, flags IconLookupFlags) (gdkpixbuf.Pixbuf, error) {
var _arg0 *C.GtkIconTheme // out
var _arg1 *C.gchar // out
var _arg2 C.gint // out
var _arg3 C.GtkIconLookupFlags // out
var _cret *C.GdkPixbuf // in
var _cerr *C.GError // in

_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(i.Native()))
_arg1 = (*C.gchar)(C.CString(iconName))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.gint)(size)
_arg3 = (C.GtkIconLookupFlags)(flags)

_cret = C.gtk_icon_theme_load_icon(_arg0, _arg1, _arg2, _arg3, &_cerr)


var _pixbuf gdkpixbuf.Pixbuf // out
var _goerr error // out

_pixbuf = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gdkpixbuf.Pixbuf)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _pixbuf, _goerr
}
	
	// LoadIconForScale looks up an icon in an icon theme for a particular window
// scale, scales it to the given size and renders it into a pixbuf. This is a
// convenience function; if more details about the icon are needed, use
// gtk_icon_theme_lookup_icon() followed by gtk_icon_info_load_icon().
// 
// Note that you probably want to listen for icon theme changes and update the
// icon. This is usually done by connecting to the GtkWidget::style-set signal.
// If for some reason you do not want to update the icon when the icon theme
// changes, you should consider using gdk_pixbuf_copy() to make a private copy
// of the pixbuf returned by this function. Otherwise GTK+ may need to keep the
// old icon theme loaded, which would be a waste of memory.
	func (i IconTheme) LoadIconForScale(iconName string, size int, scale int, flags IconLookupFlags) (gdkpixbuf.Pixbuf, error) {
var _arg0 *C.GtkIconTheme // out
var _arg1 *C.gchar // out
var _arg2 C.gint // out
var _arg3 C.gint // out
var _arg4 C.GtkIconLookupFlags // out
var _cret *C.GdkPixbuf // in
var _cerr *C.GError // in

_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(i.Native()))
_arg1 = (*C.gchar)(C.CString(iconName))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.gint)(size)
_arg3 = (C.gint)(scale)
_arg4 = (C.GtkIconLookupFlags)(flags)

_cret = C.gtk_icon_theme_load_icon_for_scale(_arg0, _arg1, _arg2, _arg3, _arg4, &_cerr)


var _pixbuf gdkpixbuf.Pixbuf // out
var _goerr error // out

_pixbuf = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gdkpixbuf.Pixbuf)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _pixbuf, _goerr
}
	
	// LoadSurface looks up an icon in an icon theme for a particular window scale,
// scales it to the given size and renders it into a cairo surface. This is a
// convenience function; if more details about the icon are needed, use
// gtk_icon_theme_lookup_icon() followed by gtk_icon_info_load_surface().
// 
// Note that you probably want to listen for icon theme changes and update the
// icon. This is usually done by connecting to the GtkWidget::style-set signal.
	func (i IconTheme) LoadSurface(iconName string, size int, scale int, forWindow gdk.WindowClass, flags IconLookupFlags) (*cairo.Surface, error) {
var _arg0 *C.GtkIconTheme // out
var _arg1 *C.gchar // out
var _arg2 C.gint // out
var _arg3 C.gint // out
var _arg4 *C.GdkWindow // out
var _arg5 C.GtkIconLookupFlags // out
var _cret *C.cairo_surface_t // in
var _cerr *C.GError // in

_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(i.Native()))
_arg1 = (*C.gchar)(C.CString(iconName))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.gint)(size)
_arg3 = (C.gint)(scale)
_arg4 = (*C.GdkWindow)(unsafe.Pointer(forWindow.Native()))
_arg5 = (C.GtkIconLookupFlags)(flags)

_cret = C.gtk_icon_theme_load_surface(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, &_cerr)


var _surface *cairo.Surface // out
var _goerr error // out

_surface = *(**cairo.Surface)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_surface, func(v *cairo.Surface) {
  C.free(unsafe.Pointer(v.Native()))
})
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _surface, _goerr
}
	
	// LookupByGIcon looks up an icon and returns a IconInfo containing information
// such as the filename of the icon. The icon can then be rendered into a pixbuf
// using gtk_icon_info_load_icon().
// 
// When rendering on displays with high pixel densities you should not use a
// @size multiplied by the scaling factor returned by functions like
// gdk_window_get_scale_factor(). Instead, you should use
// gtk_icon_theme_lookup_by_gicon_for_scale(), as the assets loaded for a given
// scaling factor may be different.
	func (i IconTheme) LookupByGIcon(icon gio.Icon, size int, flags IconLookupFlags) IconInfo {
var _arg0 *C.GtkIconTheme // out
var _arg1 *C.GIcon // out
var _arg2 C.gint // out
var _arg3 C.GtkIconLookupFlags // out
var _cret *C.GtkIconInfo // in

_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GIcon)(unsafe.Pointer(icon.Native()))
_arg2 = (C.gint)(size)
_arg3 = (C.GtkIconLookupFlags)(flags)

_cret = C.gtk_icon_theme_lookup_by_gicon(_arg0, _arg1, _arg2, _arg3)


var _iconInfo IconInfo // out

_iconInfo = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(IconInfo)

return _iconInfo
}
	
	// LookupByGIconForScale looks up an icon and returns a IconInfo containing
// information such as the filename of the icon. The icon can then be rendered
// into a pixbuf using gtk_icon_info_load_icon().
	func (i IconTheme) LookupByGIconForScale(icon gio.Icon, size int, scale int, flags IconLookupFlags) IconInfo {
var _arg0 *C.GtkIconTheme // out
var _arg1 *C.GIcon // out
var _arg2 C.gint // out
var _arg3 C.gint // out
var _arg4 C.GtkIconLookupFlags // out
var _cret *C.GtkIconInfo // in

_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GIcon)(unsafe.Pointer(icon.Native()))
_arg2 = (C.gint)(size)
_arg3 = (C.gint)(scale)
_arg4 = (C.GtkIconLookupFlags)(flags)

_cret = C.gtk_icon_theme_lookup_by_gicon_for_scale(_arg0, _arg1, _arg2, _arg3, _arg4)


var _iconInfo IconInfo // out

_iconInfo = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(IconInfo)

return _iconInfo
}
	
	// LookupIcon looks up a named icon and returns a IconInfo containing
// information such as the filename of the icon. The icon can then be rendered
// into a pixbuf using gtk_icon_info_load_icon(). (gtk_icon_theme_load_icon()
// combines these two steps if all you need is the pixbuf.)
// 
// When rendering on displays with high pixel densities you should not use a
// @size multiplied by the scaling factor returned by functions like
// gdk_window_get_scale_factor(). Instead, you should use
// gtk_icon_theme_lookup_icon_for_scale(), as the assets loaded for a given
// scaling factor may be different.
	func (i IconTheme) LookupIcon(iconName string, size int, flags IconLookupFlags) IconInfo {
var _arg0 *C.GtkIconTheme // out
var _arg1 *C.gchar // out
var _arg2 C.gint // out
var _arg3 C.GtkIconLookupFlags // out
var _cret *C.GtkIconInfo // in

_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(i.Native()))
_arg1 = (*C.gchar)(C.CString(iconName))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.gint)(size)
_arg3 = (C.GtkIconLookupFlags)(flags)

_cret = C.gtk_icon_theme_lookup_icon(_arg0, _arg1, _arg2, _arg3)


var _iconInfo IconInfo // out

_iconInfo = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(IconInfo)

return _iconInfo
}
	
	// LookupIconForScale looks up a named icon for a particular window scale and
// returns a IconInfo containing information such as the filename of the icon.
// The icon can then be rendered into a pixbuf using gtk_icon_info_load_icon().
// (gtk_icon_theme_load_icon() combines these two steps if all you need is the
// pixbuf.)
	func (i IconTheme) LookupIconForScale(iconName string, size int, scale int, flags IconLookupFlags) IconInfo {
var _arg0 *C.GtkIconTheme // out
var _arg1 *C.gchar // out
var _arg2 C.gint // out
var _arg3 C.gint // out
var _arg4 C.GtkIconLookupFlags // out
var _cret *C.GtkIconInfo // in

_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(i.Native()))
_arg1 = (*C.gchar)(C.CString(iconName))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.gint)(size)
_arg3 = (C.gint)(scale)
_arg4 = (C.GtkIconLookupFlags)(flags)

_cret = C.gtk_icon_theme_lookup_icon_for_scale(_arg0, _arg1, _arg2, _arg3, _arg4)


var _iconInfo IconInfo // out

_iconInfo = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(IconInfo)

return _iconInfo
}
	
	// PrependSearchPath prepends a directory to the search path. See
// gtk_icon_theme_set_search_path().
	func (i IconTheme) PrependSearchPath(path string)  {
var _arg0 *C.GtkIconTheme // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(i.Native()))
_arg1 = (*C.gchar)(C.CString(path))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_icon_theme_prepend_search_path(_arg0, _arg1)
}
	
	// RescanIfNeeded checks to see if the icon theme has changed; if it has, any
// currently cached information is discarded and will be reloaded next time
// @icon_theme is accessed.
	func (i IconTheme) RescanIfNeeded() bool {
var _arg0 *C.GtkIconTheme // out
var _cret C.gboolean // in

_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(i.Native()))

_cret = C.gtk_icon_theme_rescan_if_needed(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetCustomTheme sets the name of the icon theme that the IconTheme object uses
// overriding system configuration. This function cannot be called on the icon
// theme objects returned from gtk_icon_theme_get_default() and
// gtk_icon_theme_get_for_screen().
	func (i IconTheme) SetCustomTheme(themeName string)  {
var _arg0 *C.GtkIconTheme // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(i.Native()))
_arg1 = (*C.gchar)(C.CString(themeName))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_icon_theme_set_custom_theme(_arg0, _arg1)
}
	
	// SetScreen sets the screen for an icon theme; the screen is used to track the
// user’s currently configured icon theme, which might be different for
// different screens.
	func (i IconTheme) SetScreen(screen gdk.ScreenClass)  {
var _arg0 *C.GtkIconTheme // out
var _arg1 *C.GdkScreen // out

_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GdkScreen)(unsafe.Pointer(screen.Native()))

C.gtk_icon_theme_set_screen(_arg0, _arg1)
}
	
	// SetSearchPath sets the search path for the icon theme object. When looking
// for an icon theme, GTK+ will search for a subdirectory of one or more of the
// directories in @path with the same name as the icon theme containing an
// index.theme file. (Themes from multiple of the path elements are combined to
// allow themes to be extended by adding icons in the user’s home directory.)
// 
// In addition if an icon found isn’t found either in the current icon theme or
// the default icon theme, and an image file with the right name is found
// directly in one of the elements of @path, then that image will be used for
// the icon name. (This is legacy feature, and new icons should be put into the
// fallback icon theme, which is called hicolor, rather than directly on the
// icon path.)
	func (i IconTheme) SetSearchPath(path []string)  {
var _arg0 *C.GtkIconTheme // out
var _arg1 **C.gchar
var _arg2 C.gint

_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(i.Native()))
_arg2 = C.gint(len(path))
_arg1 = (**C.gchar)(C.malloc(C.ulong(len(path)) * C.ulong(unsafe.Sizeof(uint(0)))))
defer C.free(unsafe.Pointer(_arg1))
{
out := unsafe.Slice(_arg1, len(path))
for i := range path {
out[i] = (*C.gchar)(C.CString(path[i]))
defer C.free(unsafe.Pointer(out[i]))
}
}

C.gtk_icon_theme_set_search_path(_arg0, _arg1, _arg2)
}
	


	// IconView provides an alternative view on a TreeModel. It displays the model
// as a grid of icons with labels. Like TreeView, it allows to select one or
// multiple items (depending on the selection mode, see
// gtk_icon_view_set_selection_mode()). In addition to selection with the arrow
// keys, IconView supports rubberband selection, which is controlled by dragging
// the pointer.
// 
// Note that if the tree model is backed by an actual tree store (as opposed to
// a flat list where the mapping to icons is obvious), IconView will only
// display the first level of the tree and ignore the tree’s branches.
// 
// CSS nodes
// 
//    iconview.view
//    ╰── [rubberband]
// 
// GtkIconView has a single CSS node with name iconview and style class .view.
// For rubberband selection, a subnode with name rubberband is used.
	type IconView struct {
		Container
		Buildable
		CellLayout
		Scrollable
		
	}

	// IconViewClass is an interface that the IconView class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type IconViewClass interface {
		gextras.Objector
		_iconView()
	}

	func (IconView) _iconView() {}

	
	func marshalIconView(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapIconView(obj), nil
	}
	

	
	// NewIconView creates a new IconView widget
	func NewIconView() IconView {
var _cret *C.GtkWidget // in

_cret = C.gtk_icon_view_new()


var _iconView IconView // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_iconView = IconView{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
CellLayout: CellLayout{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Scrollable: Scrollable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _iconView
}
	
	// NewIconViewWithArea creates a new IconView widget using the specified @area
// to layout cells inside the icons.
	func NewIconViewWithArea(area CellAreaClass) IconView {
var _arg1 *C.GtkCellArea // out
var _cret *C.GtkWidget // in

_arg1 = (*C.GtkCellArea)(unsafe.Pointer(area.Native()))

_cret = C.gtk_icon_view_new_with_area(_arg1)


var _iconView IconView // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_iconView = IconView{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
CellLayout: CellLayout{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Scrollable: Scrollable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _iconView
}
	
	// NewIconViewWithModel creates a new IconView widget with the model @model.
	func NewIconViewWithModel(model TreeModel) IconView {
var _arg1 *C.GtkTreeModel // out
var _cret *C.GtkWidget // in

_arg1 = (*C.GtkTreeModel)(unsafe.Pointer(model.Native()))

_cret = C.gtk_icon_view_new_with_model(_arg1)


var _iconView IconView // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_iconView = IconView{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
CellLayout: CellLayout{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Scrollable: Scrollable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _iconView
}
	

	
	// ConvertWidgetToBinWindowCoords converts widget coordinates to coordinates for
// the bin_window, as expected by e.g. gtk_icon_view_get_path_at_pos().
	func (i IconView) ConvertWidgetToBinWindowCoords(wx int, wy int) (bx int, by int) {
var _arg0 *C.GtkIconView // out
var _arg1 C.gint // out
var _arg2 C.gint // out
var _arg3 C.gint // in
var _arg4 C.gint // in

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
_arg1 = (C.gint)(wx)
_arg2 = (C.gint)(wy)

C.gtk_icon_view_convert_widget_to_bin_window_coords(_arg0, _arg1, _arg2, &_arg3, &_arg4)

var _bx int // out
var _by int // out

_bx = (int)(_arg3)
_by = (int)(_arg4)

return _bx, _by
}
	
	// CreateDragIcon creates a #cairo_surface_t representation of the item at
// @path. This image is used for a drag icon.
	func (i IconView) CreateDragIcon(path *TreePath) *cairo.Surface {
var _arg0 *C.GtkIconView // out
var _arg1 *C.GtkTreePath // out
var _cret *C.cairo_surface_t // in

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

_cret = C.gtk_icon_view_create_drag_icon(_arg0, _arg1)


var _surface *cairo.Surface // out

_surface = *(**cairo.Surface)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_surface, func(v *cairo.Surface) {
  C.free(unsafe.Pointer(v.Native()))
})

return _surface
}
	
	// EnableModelDragDest turns @icon_view into a drop destination for automatic
// DND. Calling this method sets IconView:reorderable to false.
	func (i IconView) EnableModelDragDest(targets []TargetEntry, actions gdk.DragAction)  {
var _arg0 *C.GtkIconView // out
var _arg1 *C.GtkTargetEntry
var _arg2 C.gint
var _arg3 C.GdkDragAction // out

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
_arg2 = C.gint(len(targets))
_arg1 = (*C.GtkTargetEntry)(unsafe.Pointer(&targets[0]))
_arg3 = (C.GdkDragAction)(actions)

C.gtk_icon_view_enable_model_drag_dest(_arg0, _arg1, _arg2, _arg3)
}
	
	// EnableModelDragSource turns @icon_view into a drag source for automatic DND.
// Calling this method sets IconView:reorderable to false.
	func (i IconView) EnableModelDragSource(startButtonMask gdk.ModifierType, targets []TargetEntry, actions gdk.DragAction)  {
var _arg0 *C.GtkIconView // out
var _arg1 C.GdkModifierType // out
var _arg2 *C.GtkTargetEntry
var _arg3 C.gint
var _arg4 C.GdkDragAction // out

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
_arg1 = (C.GdkModifierType)(startButtonMask)
_arg3 = C.gint(len(targets))
_arg2 = (*C.GtkTargetEntry)(unsafe.Pointer(&targets[0]))
_arg4 = (C.GdkDragAction)(actions)

C.gtk_icon_view_enable_model_drag_source(_arg0, _arg1, _arg2, _arg3, _arg4)
}
	
	// ActivateOnSingleClick gets the setting set by
// gtk_icon_view_set_activate_on_single_click().
	func (i IconView) ActivateOnSingleClick() bool {
var _arg0 *C.GtkIconView // out
var _cret C.gboolean // in

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

_cret = C.gtk_icon_view_get_activate_on_single_click(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// CellRect fills the bounding rectangle in widget coordinates for the cell
// specified by @path and @cell. If @cell is nil the main cell area is used.
// 
// This function is only valid if @icon_view is realized.
	func (i IconView) CellRect(path *TreePath, cell CellRendererClass) (gdk.Rectangle, bool) {
var _arg0 *C.GtkIconView // out
var _arg1 *C.GtkTreePath // out
var _arg2 *C.GtkCellRenderer // out
var _rect gdk.Rectangle
var _cret C.gboolean // in

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
_arg2 = (*C.GtkCellRenderer)(unsafe.Pointer(cell.Native()))

_cret = C.gtk_icon_view_get_cell_rect(_arg0, _arg1, _arg2, (*C.GdkRectangle)(unsafe.Pointer(&_rect)))



var _ok bool // out


if _cret != 0 { _ok = true }

return _rect, _ok
}
	
	// ColumnSpacing returns the value of the ::column-spacing property.
	func (i IconView) ColumnSpacing() int {
var _arg0 *C.GtkIconView // out
var _cret C.gint // in

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

_cret = C.gtk_icon_view_get_column_spacing(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Columns returns the value of the ::columns property.
	func (i IconView) Columns() int {
var _arg0 *C.GtkIconView // out
var _cret C.gint // in

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

_cret = C.gtk_icon_view_get_columns(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Cursor fills in @path and @cell with the current cursor path and cell. If the
// cursor isn’t currently set, then *@path will be nil. If no cell currently has
// focus, then *@cell will be nil.
// 
// The returned TreePath must be freed with gtk_tree_path_free().
	func (i IconView) Cursor() (*TreePath, CellRenderer, bool) {
var _arg0 *C.GtkIconView // out
var _path *TreePath
var _arg2 *C.GtkCellRenderer // in
var _cret C.gboolean // in

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

_cret = C.gtk_icon_view_get_cursor(_arg0, (**C.GtkTreePath)(unsafe.Pointer(&_path)), &_arg2)



var _cell CellRenderer // out
var _ok bool // out


_cell = gextras.CastObject(externglib.Take(unsafe.Pointer(_arg2))).(CellRenderer)
if _cret != 0 { _ok = true }

return _path, _cell, _ok
}
	
	// DestItemAtPos determines the destination item for a given position.
	func (i IconView) DestItemAtPos(dragX int, dragY int) (*TreePath, IconViewDropPosition, bool) {
var _arg0 *C.GtkIconView // out
var _arg1 C.gint // out
var _arg2 C.gint // out
var _path *TreePath
var _arg4 C.GtkIconViewDropPosition // in
var _cret C.gboolean // in

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
_arg1 = (C.gint)(dragX)
_arg2 = (C.gint)(dragY)

_cret = C.gtk_icon_view_get_dest_item_at_pos(_arg0, _arg1, _arg2, (**C.GtkTreePath)(unsafe.Pointer(&_path)), &_arg4)



var _pos IconViewDropPosition // out
var _ok bool // out


_pos = IconViewDropPosition(_arg4)
if _cret != 0 { _ok = true }

return _path, _pos, _ok
}
	
	// DragDestItem gets information about the item that is highlighted for
// feedback.
	func (i IconView) DragDestItem() (*TreePath, IconViewDropPosition) {
var _arg0 *C.GtkIconView // out
var _path *TreePath
var _arg2 C.GtkIconViewDropPosition // in

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

C.gtk_icon_view_get_drag_dest_item(_arg0, (**C.GtkTreePath)(unsafe.Pointer(&_path)), &_arg2)


var _pos IconViewDropPosition // out


_pos = IconViewDropPosition(_arg2)

return _path, _pos
}
	
	// ItemAtPos finds the path at the point (@x, @y), relative to bin_window
// coordinates. In contrast to gtk_icon_view_get_path_at_pos(), this function
// also obtains the cell at the specified position. The returned path should be
// freed with gtk_tree_path_free(). See
// gtk_icon_view_convert_widget_to_bin_window_coords() for converting widget
// coordinates to bin_window coordinates.
	func (i IconView) ItemAtPos(x int, y int) (*TreePath, CellRenderer, bool) {
var _arg0 *C.GtkIconView // out
var _arg1 C.gint // out
var _arg2 C.gint // out
var _path *TreePath
var _arg4 *C.GtkCellRenderer // in
var _cret C.gboolean // in

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
_arg1 = (C.gint)(x)
_arg2 = (C.gint)(y)

_cret = C.gtk_icon_view_get_item_at_pos(_arg0, _arg1, _arg2, (**C.GtkTreePath)(unsafe.Pointer(&_path)), &_arg4)



var _cell CellRenderer // out
var _ok bool // out


_cell = gextras.CastObject(externglib.Take(unsafe.Pointer(_arg4))).(CellRenderer)
if _cret != 0 { _ok = true }

return _path, _cell, _ok
}
	
	// ItemColumn gets the column in which the item @path is currently displayed.
// Column numbers start at 0.
	func (i IconView) ItemColumn(path *TreePath) int {
var _arg0 *C.GtkIconView // out
var _arg1 *C.GtkTreePath // out
var _cret C.gint // in

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

_cret = C.gtk_icon_view_get_item_column(_arg0, _arg1)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// ItemOrientation returns the value of the ::item-orientation property which
// determines whether the labels are drawn beside the icons instead of below.
	func (i IconView) ItemOrientation() Orientation {
var _arg0 *C.GtkIconView // out
var _cret C.GtkOrientation // in

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

_cret = C.gtk_icon_view_get_item_orientation(_arg0)


var _orientation Orientation // out

_orientation = Orientation(_cret)

return _orientation
}
	
	// ItemPadding returns the value of the ::item-padding property.
	func (i IconView) ItemPadding() int {
var _arg0 *C.GtkIconView // out
var _cret C.gint // in

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

_cret = C.gtk_icon_view_get_item_padding(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// ItemRow gets the row in which the item @path is currently displayed. Row
// numbers start at 0.
	func (i IconView) ItemRow(path *TreePath) int {
var _arg0 *C.GtkIconView // out
var _arg1 *C.GtkTreePath // out
var _cret C.gint // in

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

_cret = C.gtk_icon_view_get_item_row(_arg0, _arg1)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// ItemWidth returns the value of the ::item-width property.
	func (i IconView) ItemWidth() int {
var _arg0 *C.GtkIconView // out
var _cret C.gint // in

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

_cret = C.gtk_icon_view_get_item_width(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Margin returns the value of the ::margin property.
	func (i IconView) Margin() int {
var _arg0 *C.GtkIconView // out
var _cret C.gint // in

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

_cret = C.gtk_icon_view_get_margin(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// MarkupColumn returns the column with markup text for @icon_view.
	func (i IconView) MarkupColumn() int {
var _arg0 *C.GtkIconView // out
var _cret C.gint // in

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

_cret = C.gtk_icon_view_get_markup_column(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Model returns the model the IconView is based on. Returns nil if the model is
// unset.
	func (i IconView) Model() TreeModel {
var _arg0 *C.GtkIconView // out
var _cret *C.GtkTreeModel // in

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

_cret = C.gtk_icon_view_get_model(_arg0)


var _treeModel TreeModel // out

_treeModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TreeModel)

return _treeModel
}
	
	// PathAtPos finds the path at the point (@x, @y), relative to bin_window
// coordinates. See gtk_icon_view_get_item_at_pos(), if you are also interested
// in the cell at the specified position. See
// gtk_icon_view_convert_widget_to_bin_window_coords() for converting widget
// coordinates to bin_window coordinates.
	func (i IconView) PathAtPos(x int, y int) *TreePath {
var _arg0 *C.GtkIconView // out
var _arg1 C.gint // out
var _arg2 C.gint // out
var _cret *C.GtkTreePath // in

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
_arg1 = (C.gint)(x)
_arg2 = (C.gint)(y)

_cret = C.gtk_icon_view_get_path_at_pos(_arg0, _arg1, _arg2)


var _treePath *TreePath // out

_treePath = *(**TreePath)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_treePath, func(v *TreePath) {
  C.free(unsafe.Pointer(v.Native()))
})

return _treePath
}
	
	// PixbufColumn returns the column with pixbufs for @icon_view.
	func (i IconView) PixbufColumn() int {
var _arg0 *C.GtkIconView // out
var _cret C.gint // in

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

_cret = C.gtk_icon_view_get_pixbuf_column(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Reorderable retrieves whether the user can reorder the list via
// drag-and-drop. See gtk_icon_view_set_reorderable().
	func (i IconView) Reorderable() bool {
var _arg0 *C.GtkIconView // out
var _cret C.gboolean // in

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

_cret = C.gtk_icon_view_get_reorderable(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// RowSpacing returns the value of the ::row-spacing property.
	func (i IconView) RowSpacing() int {
var _arg0 *C.GtkIconView // out
var _cret C.gint // in

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

_cret = C.gtk_icon_view_get_row_spacing(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// SelectionMode gets the selection mode of the @icon_view.
	func (i IconView) SelectionMode() SelectionMode {
var _arg0 *C.GtkIconView // out
var _cret C.GtkSelectionMode // in

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

_cret = C.gtk_icon_view_get_selection_mode(_arg0)


var _selectionMode SelectionMode // out

_selectionMode = SelectionMode(_cret)

return _selectionMode
}
	
	// Spacing returns the value of the ::spacing property.
	func (i IconView) Spacing() int {
var _arg0 *C.GtkIconView // out
var _cret C.gint // in

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

_cret = C.gtk_icon_view_get_spacing(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// TextColumn returns the column with text for @icon_view.
	func (i IconView) TextColumn() int {
var _arg0 *C.GtkIconView // out
var _cret C.gint // in

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

_cret = C.gtk_icon_view_get_text_column(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// TooltipColumn returns the column of @icon_view’s model which is being used
// for displaying tooltips on @icon_view’s rows.
	func (i IconView) TooltipColumn() int {
var _arg0 *C.GtkIconView // out
var _cret C.gint // in

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

_cret = C.gtk_icon_view_get_tooltip_column(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// VisibleRange sets @start_path and @end_path to be the first and last visible
// path. Note that there may be invisible paths in between.
// 
// Both paths should be freed with gtk_tree_path_free() after use.
	func (i IconView) VisibleRange() (startPath *TreePath, endPath *TreePath, ok bool) {
var _arg0 *C.GtkIconView // out
var _startPath *TreePath
var _endPath *TreePath
var _cret C.gboolean // in

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

_cret = C.gtk_icon_view_get_visible_range(_arg0, (**C.GtkTreePath)(unsafe.Pointer(&_startPath)), (**C.GtkTreePath)(unsafe.Pointer(&_endPath)))




var _ok bool // out



if _cret != 0 { _ok = true }

return _startPath, _endPath, _ok
}
	
	// ItemActivated activates the item determined by @path.
	func (i IconView) ItemActivated(path *TreePath)  {
var _arg0 *C.GtkIconView // out
var _arg1 *C.GtkTreePath // out

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

C.gtk_icon_view_item_activated(_arg0, _arg1)
}
	
	// PathIsSelected returns true if the icon pointed to by @path is currently
// selected. If @path does not point to a valid location, false is returned.
	func (i IconView) PathIsSelected(path *TreePath) bool {
var _arg0 *C.GtkIconView // out
var _arg1 *C.GtkTreePath // out
var _cret C.gboolean // in

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

_cret = C.gtk_icon_view_path_is_selected(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ScrollToPath moves the alignments of @icon_view to the position specified by
// @path. @row_align determines where the row is placed, and @col_align
// determines where @column is placed. Both are expected to be between 0.0 and
// 1.0. 0.0 means left/top alignment, 1.0 means right/bottom alignment, 0.5
// means center.
// 
// If @use_align is false, then the alignment arguments are ignored, and the
// tree does the minimum amount of work to scroll the item onto the screen. This
// means that the item will be scrolled to the edge closest to its current
// position. If the item is currently visible on the screen, nothing is done.
// 
// This function only works if the model is set, and @path is a valid row on the
// model. If the model changes before the @icon_view is realized, the centered
// path will be modified to reflect this change.
	func (i IconView) ScrollToPath(path *TreePath, useAlign bool, rowAlign float32, colAlign float32)  {
var _arg0 *C.GtkIconView // out
var _arg1 *C.GtkTreePath // out
var _arg2 C.gboolean // out
var _arg3 C.gfloat // out
var _arg4 C.gfloat // out

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
if useAlign { _arg2 = C.TRUE }
_arg3 = (C.gfloat)(rowAlign)
_arg4 = (C.gfloat)(colAlign)

C.gtk_icon_view_scroll_to_path(_arg0, _arg1, _arg2, _arg3, _arg4)
}
	
	// SelectAll selects all the icons. @icon_view must has its selection mode set
// to K_SELECTION_MULTIPLE.
	func (i IconView) SelectAll()  {
var _arg0 *C.GtkIconView // out

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

C.gtk_icon_view_select_all(_arg0)
}
	
	// SelectPath selects the row at @path.
	func (i IconView) SelectPath(path *TreePath)  {
var _arg0 *C.GtkIconView // out
var _arg1 *C.GtkTreePath // out

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

C.gtk_icon_view_select_path(_arg0, _arg1)
}
	
	// SetActivateOnSingleClick causes the IconView::item-activated signal to be
// emitted on a single click instead of a double click.
	func (i IconView) SetActivateOnSingleClick(single bool)  {
var _arg0 *C.GtkIconView // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
if single { _arg1 = C.TRUE }

C.gtk_icon_view_set_activate_on_single_click(_arg0, _arg1)
}
	
	// SetColumnSpacing sets the ::column-spacing property which specifies the space
// which is inserted between the columns of the icon view.
	func (i IconView) SetColumnSpacing(columnSpacing int)  {
var _arg0 *C.GtkIconView // out
var _arg1 C.gint // out

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
_arg1 = (C.gint)(columnSpacing)

C.gtk_icon_view_set_column_spacing(_arg0, _arg1)
}
	
	// SetColumns sets the ::columns property which determines in how many columns
// the icons are arranged. If @columns is -1, the number of columns will be
// chosen automatically to fill the available area.
	func (i IconView) SetColumns(columns int)  {
var _arg0 *C.GtkIconView // out
var _arg1 C.gint // out

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
_arg1 = (C.gint)(columns)

C.gtk_icon_view_set_columns(_arg0, _arg1)
}
	
	// SetCursor sets the current keyboard focus to be at @path, and selects it.
// This is useful when you want to focus the user’s attention on a particular
// item. If @cell is not nil, then focus is given to the cell specified by it.
// Additionally, if @start_editing is true, then editing should be started in
// the specified cell.
// 
// This function is often followed by `gtk_widget_grab_focus (icon_view)` in
// order to give keyboard focus to the widget. Please note that editing can only
// happen when the widget is realized.
	func (i IconView) SetCursor(path *TreePath, cell CellRendererClass, startEditing bool)  {
var _arg0 *C.GtkIconView // out
var _arg1 *C.GtkTreePath // out
var _arg2 *C.GtkCellRenderer // out
var _arg3 C.gboolean // out

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
_arg2 = (*C.GtkCellRenderer)(unsafe.Pointer(cell.Native()))
if startEditing { _arg3 = C.TRUE }

C.gtk_icon_view_set_cursor(_arg0, _arg1, _arg2, _arg3)
}
	
	// SetDragDestItem sets the item that is highlighted for feedback.
	func (i IconView) SetDragDestItem(path *TreePath, pos IconViewDropPosition)  {
var _arg0 *C.GtkIconView // out
var _arg1 *C.GtkTreePath // out
var _arg2 C.GtkIconViewDropPosition // out

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
_arg2 = (C.GtkIconViewDropPosition)(pos)

C.gtk_icon_view_set_drag_dest_item(_arg0, _arg1, _arg2)
}
	
	// SetItemOrientation sets the ::item-orientation property which determines
// whether the labels are drawn beside the icons instead of below.
	func (i IconView) SetItemOrientation(orientation Orientation)  {
var _arg0 *C.GtkIconView // out
var _arg1 C.GtkOrientation // out

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
_arg1 = (C.GtkOrientation)(orientation)

C.gtk_icon_view_set_item_orientation(_arg0, _arg1)
}
	
	// SetItemPadding sets the IconView:item-padding property which specifies the
// padding around each of the icon view’s items.
	func (i IconView) SetItemPadding(itemPadding int)  {
var _arg0 *C.GtkIconView // out
var _arg1 C.gint // out

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
_arg1 = (C.gint)(itemPadding)

C.gtk_icon_view_set_item_padding(_arg0, _arg1)
}
	
	// SetItemWidth sets the ::item-width property which specifies the width to use
// for each item. If it is set to -1, the icon view will automatically determine
// a suitable item size.
	func (i IconView) SetItemWidth(itemWidth int)  {
var _arg0 *C.GtkIconView // out
var _arg1 C.gint // out

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
_arg1 = (C.gint)(itemWidth)

C.gtk_icon_view_set_item_width(_arg0, _arg1)
}
	
	// SetMargin sets the ::margin property which specifies the space which is
// inserted at the top, bottom, left and right of the icon view.
	func (i IconView) SetMargin(margin int)  {
var _arg0 *C.GtkIconView // out
var _arg1 C.gint // out

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
_arg1 = (C.gint)(margin)

C.gtk_icon_view_set_margin(_arg0, _arg1)
}
	
	// SetMarkupColumn sets the column with markup information for @icon_view to be
// @column. The markup column must be of type TYPE_STRING. If the markup column
// is set to something, it overrides the text column set by
// gtk_icon_view_set_text_column().
	func (i IconView) SetMarkupColumn(column int)  {
var _arg0 *C.GtkIconView // out
var _arg1 C.gint // out

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
_arg1 = (C.gint)(column)

C.gtk_icon_view_set_markup_column(_arg0, _arg1)
}
	
	// SetModel sets the model for a IconView. If the @icon_view already has a model
// set, it will remove it before setting the new model. If @model is nil, then
// it will unset the old model.
	func (i IconView) SetModel(model TreeModel)  {
var _arg0 *C.GtkIconView // out
var _arg1 *C.GtkTreeModel // out

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GtkTreeModel)(unsafe.Pointer(model.Native()))

C.gtk_icon_view_set_model(_arg0, _arg1)
}
	
	// SetPixbufColumn sets the column with pixbufs for @icon_view to be @column.
// The pixbuf column must be of type K_TYPE_PIXBUF
	func (i IconView) SetPixbufColumn(column int)  {
var _arg0 *C.GtkIconView // out
var _arg1 C.gint // out

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
_arg1 = (C.gint)(column)

C.gtk_icon_view_set_pixbuf_column(_arg0, _arg1)
}
	
	// SetReorderable: this function is a convenience function to allow you to
// reorder models that support the TreeDragSourceIface and the
// TreeDragDestIface. Both TreeStore and ListStore support these. If
// @reorderable is true, then the user can reorder the model by dragging and
// dropping rows. The developer can listen to these changes by connecting to the
// model's row_inserted and row_deleted signals. The reordering is implemented
// by setting up the icon view as a drag source and destination. Therefore, drag
// and drop can not be used in a reorderable view for any other purpose.
// 
// This function does not give you any degree of control over the order -- any
// reordering is allowed. If more control is needed, you should probably handle
// drag and drop manually.
	func (i IconView) SetReorderable(reorderable bool)  {
var _arg0 *C.GtkIconView // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
if reorderable { _arg1 = C.TRUE }

C.gtk_icon_view_set_reorderable(_arg0, _arg1)
}
	
	// SetRowSpacing sets the ::row-spacing property which specifies the space which
// is inserted between the rows of the icon view.
	func (i IconView) SetRowSpacing(rowSpacing int)  {
var _arg0 *C.GtkIconView // out
var _arg1 C.gint // out

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
_arg1 = (C.gint)(rowSpacing)

C.gtk_icon_view_set_row_spacing(_arg0, _arg1)
}
	
	// SetSelectionMode sets the selection mode of the @icon_view.
	func (i IconView) SetSelectionMode(mode SelectionMode)  {
var _arg0 *C.GtkIconView // out
var _arg1 C.GtkSelectionMode // out

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
_arg1 = (C.GtkSelectionMode)(mode)

C.gtk_icon_view_set_selection_mode(_arg0, _arg1)
}
	
	// SetSpacing sets the ::spacing property which specifies the space which is
// inserted between the cells (i.e. the icon and the text) of an item.
	func (i IconView) SetSpacing(spacing int)  {
var _arg0 *C.GtkIconView // out
var _arg1 C.gint // out

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
_arg1 = (C.gint)(spacing)

C.gtk_icon_view_set_spacing(_arg0, _arg1)
}
	
	// SetTextColumn sets the column with text for @icon_view to be @column. The
// text column must be of type TYPE_STRING.
	func (i IconView) SetTextColumn(column int)  {
var _arg0 *C.GtkIconView // out
var _arg1 C.gint // out

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
_arg1 = (C.gint)(column)

C.gtk_icon_view_set_text_column(_arg0, _arg1)
}
	
	// SetTooltipCell sets the tip area of @tooltip to the area which @cell occupies
// in the item pointed to by @path. See also gtk_tooltip_set_tip_area().
// 
// See also gtk_icon_view_set_tooltip_column() for a simpler alternative.
	func (i IconView) SetTooltipCell(tooltip TooltipClass, path *TreePath, cell CellRendererClass)  {
var _arg0 *C.GtkIconView // out
var _arg1 *C.GtkTooltip // out
var _arg2 *C.GtkTreePath // out
var _arg3 *C.GtkCellRenderer // out

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GtkTooltip)(unsafe.Pointer(tooltip.Native()))
_arg2 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
_arg3 = (*C.GtkCellRenderer)(unsafe.Pointer(cell.Native()))

C.gtk_icon_view_set_tooltip_cell(_arg0, _arg1, _arg2, _arg3)
}
	
	// SetTooltipColumn: if you only plan to have simple (text-only) tooltips on
// full items, you can use this function to have IconView handle these
// automatically for you. @column should be set to the column in @icon_view’s
// model containing the tooltip texts, or -1 to disable this feature.
// 
// When enabled, Widget:has-tooltip will be set to true and @icon_view will
// connect a Widget::query-tooltip signal handler.
// 
// Note that the signal handler sets the text with gtk_tooltip_set_markup(), so
// &, <, etc have to be escaped in the text.
	func (i IconView) SetTooltipColumn(column int)  {
var _arg0 *C.GtkIconView // out
var _arg1 C.gint // out

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
_arg1 = (C.gint)(column)

C.gtk_icon_view_set_tooltip_column(_arg0, _arg1)
}
	
	// SetTooltipItem sets the tip area of @tooltip to be the area covered by the
// item at @path. See also gtk_icon_view_set_tooltip_column() for a simpler
// alternative. See also gtk_tooltip_set_tip_area().
	func (i IconView) SetTooltipItem(tooltip TooltipClass, path *TreePath)  {
var _arg0 *C.GtkIconView // out
var _arg1 *C.GtkTooltip // out
var _arg2 *C.GtkTreePath // out

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GtkTooltip)(unsafe.Pointer(tooltip.Native()))
_arg2 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

C.gtk_icon_view_set_tooltip_item(_arg0, _arg1, _arg2)
}
	
	// UnselectAll unselects all the icons.
	func (i IconView) UnselectAll()  {
var _arg0 *C.GtkIconView // out

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

C.gtk_icon_view_unselect_all(_arg0)
}
	
	// UnselectPath unselects the row at @path.
	func (i IconView) UnselectPath(path *TreePath)  {
var _arg0 *C.GtkIconView // out
var _arg1 *C.GtkTreePath // out

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

C.gtk_icon_view_unselect_path(_arg0, _arg1)
}
	
	// UnsetModelDragDest undoes the effect of
// gtk_icon_view_enable_model_drag_dest(). Calling this method sets
// IconView:reorderable to false.
	func (i IconView) UnsetModelDragDest()  {
var _arg0 *C.GtkIconView // out

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

C.gtk_icon_view_unset_model_drag_dest(_arg0)
}
	
	// UnsetModelDragSource undoes the effect of
// gtk_icon_view_enable_model_drag_source(). Calling this method sets
// IconView:reorderable to false.
	func (i IconView) UnsetModelDragSource()  {
var _arg0 *C.GtkIconView // out

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

C.gtk_icon_view_unset_model_drag_source(_arg0)
}
	


	// Image: the Image widget displays an image. Various kinds of object can be
// displayed as an image; most typically, you would load a Pixbuf ("pixel
// buffer") from a file, and then display that. There’s a convenience function
// to do this, gtk_image_new_from_file(), used as follows:
// 
//      static gboolean
//      button_press_callback (GtkWidget      *event_box,
//                             GdkEventButton *event,
//                             gpointer        data)
//      {
//        g_print ("Event box clicked at coordinates f,f\n",
//                 event->x, event->y);
// 
//        // Returning TRUE means we handled the event, so the signal
//        // emission should be stopped (don’t call any further callbacks
//        // that may be connected). Return FALSE to continue invoking callbacks.
//        return TRUE;
//      }
// 
//      static GtkWidget*
//      create_image (void)
//      {
//        GtkWidget *image;
//        GtkWidget *event_box;
// 
//        image = gtk_image_new_from_file ("myfile.png");
// 
//        event_box = gtk_event_box_new ();
// 
//        gtk_container_add (GTK_CONTAINER (event_box), image);
// 
//        g_signal_connect (G_OBJECT (event_box),
//                          "button_press_event",
//                          G_CALLBACK (button_press_callback),
//                          image);
// 
//        return image;
//      }
// 
// When handling events on the event box, keep in mind that coordinates in the
// image may be different from event box coordinates due to the alignment and
// padding settings on the image (see Misc). The simplest way to solve this is
// to set the alignment to 0.0 (left/top), and set the padding to zero. Then the
// origin of the image will be the same as the origin of the event box.
// 
// Sometimes an application will want to avoid depending on external data files,
// such as image files. GTK+ comes with a program to avoid this, called
// “gdk-pixbuf-csource”. This library allows you to convert an image into a C
// variable declaration, which can then be loaded into a Pixbuf using
// gdk_pixbuf_new_from_inline().
// 
// 
// CSS nodes
// 
// GtkImage has a single CSS node with the name image. The style classes may
// appear on image CSS nodes: .icon-dropshadow, .lowres-icon.
	type Image struct {
		Misc
		Buildable
		
	}

	// ImageClass is an interface that the Image class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ImageClass interface {
		gextras.Objector
		_image()
	}

	func (Image) _image() {}

	
	func marshalImage(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapImage(obj), nil
	}
	

	
	// NewImage creates a new empty Image widget.
	func NewImage() Image {
var _cret *C.GtkWidget // in

_cret = C.gtk_image_new()


var _image Image // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_image = Image{
Misc: Misc{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _image
}
	
	// NewImageFromAnimation creates a Image displaying the given animation. The
// Image does not assume a reference to the animation; you still need to unref
// it if you own references. Image will add its own reference rather than
// adopting yours.
// 
// Note that the animation frames are shown using a timeout with
// PRIORITY_DEFAULT. When using animations to indicate busyness, keep in mind
// that the animation will only be shown if the main loop is not busy with
// something that has a higher priority.
	func NewImageFromAnimation(animation gdkpixbuf.PixbufAnimationClass) Image {
var _arg1 *C.GdkPixbufAnimation // out
var _cret *C.GtkWidget // in

_arg1 = (*C.GdkPixbufAnimation)(unsafe.Pointer(animation.Native()))

_cret = C.gtk_image_new_from_animation(_arg1)


var _image Image // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_image = Image{
Misc: Misc{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _image
}
	
	// NewImageFromFile creates a new Image displaying the file @filename. If the
// file isn’t found or can’t be loaded, the resulting Image will display a
// “broken image” icon. This function never returns nil, it always returns a
// valid Image widget.
// 
// If the file contains an animation, the image will contain an animation.
// 
// If you need to detect failures to load the file, use
// gdk_pixbuf_new_from_file() to load the file yourself, then create the Image
// from the pixbuf. (Or for animations, use
// gdk_pixbuf_animation_new_from_file()).
// 
// The storage type (gtk_image_get_storage_type()) of the returned image is not
// defined, it will be whatever is appropriate for displaying the file.
	func NewImageFromFile(filename string) Image {
var _arg1 *C.gchar // out
var _cret *C.GtkWidget // in

_arg1 = (*C.gchar)(C.CString(filename))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_image_new_from_file(_arg1)


var _image Image // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_image = Image{
Misc: Misc{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _image
}
	
	// NewImageFromGIcon creates a Image displaying an icon from the current icon
// theme. If the icon name isn’t known, a “broken image” icon will be displayed
// instead. If the current icon theme is changed, the icon will be updated
// appropriately.
	func NewImageFromGIcon(icon gio.Icon, size int) Image {
var _arg1 *C.GIcon // out
var _arg2 C.GtkIconSize // out
var _cret *C.GtkWidget // in

_arg1 = (*C.GIcon)(unsafe.Pointer(icon.Native()))
_arg2 = (C.GtkIconSize)(size)

_cret = C.gtk_image_new_from_gicon(_arg1, _arg2)


var _image Image // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_image = Image{
Misc: Misc{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _image
}
	
	// NewImageFromIconName creates a Image displaying an icon from the current icon
// theme. If the icon name isn’t known, a “broken image” icon will be displayed
// instead. If the current icon theme is changed, the icon will be updated
// appropriately.
	func NewImageFromIconName(iconName string, size int) Image {
var _arg1 *C.gchar // out
var _arg2 C.GtkIconSize // out
var _cret *C.GtkWidget // in

_arg1 = (*C.gchar)(C.CString(iconName))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.GtkIconSize)(size)

_cret = C.gtk_image_new_from_icon_name(_arg1, _arg2)


var _image Image // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_image = Image{
Misc: Misc{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _image
}
	
	// NewImageFromIconSet creates a Image displaying an icon set. Sample stock
// sizes are K_ICON_SIZE_MENU, K_ICON_SIZE_SMALL_TOOLBAR. Instead of using this
// function, usually it’s better to create a IconFactory, put your icon sets in
// the icon factory, add the icon factory to the list of default factories with
// gtk_icon_factory_add_default(), and then use gtk_image_new_from_stock(). This
// will allow themes to override the icon you ship with your application.
// 
// The Image does not assume a reference to the icon set; you still need to
// unref it if you own references. Image will add its own reference rather than
// adopting yours.
	func NewImageFromIconSet(iconSet *IconSet, size int) Image {
var _arg1 *C.GtkIconSet // out
var _arg2 C.GtkIconSize // out
var _cret *C.GtkWidget // in

_arg1 = (*C.GtkIconSet)(unsafe.Pointer(iconSet.Native()))
_arg2 = (C.GtkIconSize)(size)

_cret = C.gtk_image_new_from_icon_set(_arg1, _arg2)


var _image Image // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_image = Image{
Misc: Misc{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _image
}
	
	// NewImageFromPixbuf creates a new Image displaying @pixbuf. The Image does not
// assume a reference to the pixbuf; you still need to unref it if you own
// references. Image will add its own reference rather than adopting yours.
// 
// Note that this function just creates an Image from the pixbuf. The Image
// created will not react to state changes. Should you want that, you should use
// gtk_image_new_from_icon_name().
	func NewImageFromPixbuf(pixbuf gdkpixbuf.PixbufClass) Image {
var _arg1 *C.GdkPixbuf // out
var _cret *C.GtkWidget // in

_arg1 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))

_cret = C.gtk_image_new_from_pixbuf(_arg1)


var _image Image // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_image = Image{
Misc: Misc{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _image
}
	
	// NewImageFromResource creates a new Image displaying the resource file
// @resource_path. If the file isn’t found or can’t be loaded, the resulting
// Image will display a “broken image” icon. This function never returns nil, it
// always returns a valid Image widget.
// 
// If the file contains an animation, the image will contain an animation.
// 
// If you need to detect failures to load the file, use
// gdk_pixbuf_new_from_file() to load the file yourself, then create the Image
// from the pixbuf. (Or for animations, use
// gdk_pixbuf_animation_new_from_file()).
// 
// The storage type (gtk_image_get_storage_type()) of the returned image is not
// defined, it will be whatever is appropriate for displaying the file.
	func NewImageFromResource(resourcePath string) Image {
var _arg1 *C.gchar // out
var _cret *C.GtkWidget // in

_arg1 = (*C.gchar)(C.CString(resourcePath))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_image_new_from_resource(_arg1)


var _image Image // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_image = Image{
Misc: Misc{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _image
}
	
	// NewImageFromStock creates a Image displaying a stock icon. Sample stock icon
// names are K_STOCK_OPEN, K_STOCK_QUIT. Sample stock sizes are
// K_ICON_SIZE_MENU, K_ICON_SIZE_SMALL_TOOLBAR. If the stock icon name isn’t
// known, the image will be empty. You can register your own stock icon names,
// see gtk_icon_factory_add_default() and gtk_icon_factory_add().
	func NewImageFromStock(stockId string, size int) Image {
var _arg1 *C.gchar // out
var _arg2 C.GtkIconSize // out
var _cret *C.GtkWidget // in

_arg1 = (*C.gchar)(C.CString(stockId))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.GtkIconSize)(size)

_cret = C.gtk_image_new_from_stock(_arg1, _arg2)


var _image Image // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_image = Image{
Misc: Misc{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _image
}
	
	// NewImageFromSurface creates a new Image displaying @surface. The Image does
// not assume a reference to the surface; you still need to unref it if you own
// references. Image will add its own reference rather than adopting yours.
	func NewImageFromSurface(surface *cairo.Surface) Image {
var _arg1 *C.cairo_surface_t // out
var _cret *C.GtkWidget // in

_arg1 = (*C.cairo_surface_t)(unsafe.Pointer(surface.Native()))

_cret = C.gtk_image_new_from_surface(_arg1)


var _image Image // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_image = Image{
Misc: Misc{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _image
}
	

	
	// Clear resets the image to be empty.
	func (i Image) Clear()  {
var _arg0 *C.GtkImage // out

_arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))

C.gtk_image_clear(_arg0)
}
	
	// Animation gets the PixbufAnimation being displayed by the Image. The storage
// type of the image must be GTK_IMAGE_EMPTY or GTK_IMAGE_ANIMATION (see
// gtk_image_get_storage_type()). The caller of this function does not own a
// reference to the returned animation.
	func (i Image) Animation() gdkpixbuf.PixbufAnimation {
var _arg0 *C.GtkImage // out
var _cret *C.GdkPixbufAnimation // in

_arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))

_cret = C.gtk_image_get_animation(_arg0)


var _pixbufAnimation gdkpixbuf.PixbufAnimation // out

_pixbufAnimation = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdkpixbuf.PixbufAnimation)

return _pixbufAnimation
}
	
	// GIcon gets the #GIcon and size being displayed by the Image. The storage type
// of the image must be GTK_IMAGE_EMPTY or GTK_IMAGE_GICON (see
// gtk_image_get_storage_type()). The caller of this function does not own a
// reference to the returned #GIcon.
	func (i Image) GIcon() (gio.Icon, int) {
var _arg0 *C.GtkImage // out
var _arg1 *C.GIcon // in
var _arg2 C.GtkIconSize // in

_arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))

C.gtk_image_get_gicon(_arg0, &_arg1, &_arg2)

var _gicon gio.Icon // out
var _size int // out

_gicon = gextras.CastObject(externglib.Take(unsafe.Pointer(_arg1))).(gio.Icon)
_size = (int)(_arg2)

return _gicon, _size
}
	
	// IconName gets the icon name and size being displayed by the Image. The
// storage type of the image must be GTK_IMAGE_EMPTY or GTK_IMAGE_ICON_NAME (see
// gtk_image_get_storage_type()). The returned string is owned by the Image and
// should not be freed.
	func (i Image) IconName() (string, int) {
var _arg0 *C.GtkImage // out
var _arg1 *C.gchar // in
var _arg2 C.GtkIconSize // in

_arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))

C.gtk_image_get_icon_name(_arg0, &_arg1, &_arg2)

var _iconName string // out
var _size int // out

_iconName = C.GoString(_arg1)
_size = (int)(_arg2)

return _iconName, _size
}
	
	// IconSet gets the icon set and size being displayed by the Image. The storage
// type of the image must be GTK_IMAGE_EMPTY or GTK_IMAGE_ICON_SET (see
// gtk_image_get_storage_type()).
	func (i Image) IconSet() (*IconSet, int) {
var _arg0 *C.GtkImage // out
var _arg1 *C.GtkIconSet // in
var _arg2 C.GtkIconSize // in

_arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))

C.gtk_image_get_icon_set(_arg0, &_arg1, &_arg2)

var _iconSet *IconSet // out
var _size int // out

_iconSet = *(**IconSet)(unsafe.Pointer(&_arg1))
_size = (int)(_arg2)

return _iconSet, _size
}
	
	// Pixbuf gets the Pixbuf being displayed by the Image. The storage type of the
// image must be GTK_IMAGE_EMPTY or GTK_IMAGE_PIXBUF (see
// gtk_image_get_storage_type()). The caller of this function does not own a
// reference to the returned pixbuf.
	func (i Image) Pixbuf() gdkpixbuf.Pixbuf {
var _arg0 *C.GtkImage // out
var _cret *C.GdkPixbuf // in

_arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))

_cret = C.gtk_image_get_pixbuf(_arg0)


var _pixbuf gdkpixbuf.Pixbuf // out

_pixbuf = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdkpixbuf.Pixbuf)

return _pixbuf
}
	
	// PixelSize gets the pixel size used for named icons.
	func (i Image) PixelSize() int {
var _arg0 *C.GtkImage // out
var _cret C.gint // in

_arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))

_cret = C.gtk_image_get_pixel_size(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Stock gets the stock icon name and size being displayed by the Image. The
// storage type of the image must be GTK_IMAGE_EMPTY or GTK_IMAGE_STOCK (see
// gtk_image_get_storage_type()). The returned string is owned by the Image and
// should not be freed.
	func (i Image) Stock() (string, int) {
var _arg0 *C.GtkImage // out
var _arg1 *C.gchar // in
var _arg2 C.GtkIconSize // in

_arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))

C.gtk_image_get_stock(_arg0, &_arg1, &_arg2)

var _stockId string // out
var _size int // out

_stockId = C.GoString(_arg1)
_size = (int)(_arg2)

return _stockId, _size
}
	
	// StorageType gets the type of representation being used by the Image to store
// image data. If the Image has no image data, the return value will be
// GTK_IMAGE_EMPTY.
	func (i Image) StorageType() ImageType {
var _arg0 *C.GtkImage // out
var _cret C.GtkImageType // in

_arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))

_cret = C.gtk_image_get_storage_type(_arg0)


var _imageType ImageType // out

_imageType = ImageType(_cret)

return _imageType
}
	
	// SetFromAnimation causes the Image to display the given animation (or display
// nothing, if you set the animation to nil).
	func (i Image) SetFromAnimation(animation gdkpixbuf.PixbufAnimationClass)  {
var _arg0 *C.GtkImage // out
var _arg1 *C.GdkPixbufAnimation // out

_arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GdkPixbufAnimation)(unsafe.Pointer(animation.Native()))

C.gtk_image_set_from_animation(_arg0, _arg1)
}
	
	// SetFromFile: see gtk_image_new_from_file() for details.
	func (i Image) SetFromFile(filename string)  {
var _arg0 *C.GtkImage // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))
_arg1 = (*C.gchar)(C.CString(filename))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_image_set_from_file(_arg0, _arg1)
}
	
	// SetFromGIcon: see gtk_image_new_from_gicon() for details.
	func (i Image) SetFromGIcon(icon gio.Icon, size int)  {
var _arg0 *C.GtkImage // out
var _arg1 *C.GIcon // out
var _arg2 C.GtkIconSize // out

_arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GIcon)(unsafe.Pointer(icon.Native()))
_arg2 = (C.GtkIconSize)(size)

C.gtk_image_set_from_gicon(_arg0, _arg1, _arg2)
}
	
	// SetFromIconName: see gtk_image_new_from_icon_name() for details.
	func (i Image) SetFromIconName(iconName string, size int)  {
var _arg0 *C.GtkImage // out
var _arg1 *C.gchar // out
var _arg2 C.GtkIconSize // out

_arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))
_arg1 = (*C.gchar)(C.CString(iconName))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.GtkIconSize)(size)

C.gtk_image_set_from_icon_name(_arg0, _arg1, _arg2)
}
	
	// SetFromIconSet: see gtk_image_new_from_icon_set() for details.
	func (i Image) SetFromIconSet(iconSet *IconSet, size int)  {
var _arg0 *C.GtkImage // out
var _arg1 *C.GtkIconSet // out
var _arg2 C.GtkIconSize // out

_arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GtkIconSet)(unsafe.Pointer(iconSet.Native()))
_arg2 = (C.GtkIconSize)(size)

C.gtk_image_set_from_icon_set(_arg0, _arg1, _arg2)
}
	
	// SetFromPixbuf: see gtk_image_new_from_pixbuf() for details.
	func (i Image) SetFromPixbuf(pixbuf gdkpixbuf.PixbufClass)  {
var _arg0 *C.GtkImage // out
var _arg1 *C.GdkPixbuf // out

_arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))

C.gtk_image_set_from_pixbuf(_arg0, _arg1)
}
	
	// SetFromResource: see gtk_image_new_from_resource() for details.
	func (i Image) SetFromResource(resourcePath string)  {
var _arg0 *C.GtkImage // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))
_arg1 = (*C.gchar)(C.CString(resourcePath))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_image_set_from_resource(_arg0, _arg1)
}
	
	// SetFromStock: see gtk_image_new_from_stock() for details.
	func (i Image) SetFromStock(stockId string, size int)  {
var _arg0 *C.GtkImage // out
var _arg1 *C.gchar // out
var _arg2 C.GtkIconSize // out

_arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))
_arg1 = (*C.gchar)(C.CString(stockId))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.GtkIconSize)(size)

C.gtk_image_set_from_stock(_arg0, _arg1, _arg2)
}
	
	// SetFromSurface: see gtk_image_new_from_surface() for details.
	func (i Image) SetFromSurface(surface *cairo.Surface)  {
var _arg0 *C.GtkImage // out
var _arg1 *C.cairo_surface_t // out

_arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))
_arg1 = (*C.cairo_surface_t)(unsafe.Pointer(surface.Native()))

C.gtk_image_set_from_surface(_arg0, _arg1)
}
	
	// SetPixelSize sets the pixel size to use for named icons. If the pixel size is
// set to a value != -1, it is used instead of the icon size set by
// gtk_image_set_from_icon_name().
	func (i Image) SetPixelSize(pixelSize int)  {
var _arg0 *C.GtkImage // out
var _arg1 C.gint // out

_arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))
_arg1 = (C.gint)(pixelSize)

C.gtk_image_set_pixel_size(_arg0, _arg1)
}
	


	// ImageMenuItem: a GtkImageMenuItem is a menu item which has an icon next to
// the text label.
// 
// This is functionally equivalent to:
// 
//      GtkWidget *box = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 6);
//      GtkWidget *icon = gtk_image_new_from_icon_name ("folder-music-symbolic", GTK_ICON_SIZE_MENU);
//      GtkWidget *label = gtk_accel_label_new ("Music");
//      GtkWidget *menu_item = gtk_menu_item_new ();
//      GtkAccelGroup *accel_group = gtk_accel_group_new ();
// 
//      gtk_container_add (GTK_CONTAINER (box), icon);
// 
//      gtk_label_set_use_underline (GTK_LABEL (label), TRUE);
//      gtk_label_set_xalign (GTK_LABEL (label), 0.0);
// 
//      gtk_widget_add_accelerator (menu_item, "activate", accel_group,
//                                  GDK_KEY_m, GDK_CONTROL_MASK, GTK_ACCEL_VISIBLE);
//      gtk_accel_label_set_accel_widget (GTK_ACCEL_LABEL (label), menu_item);
// 
//      gtk_box_pack_end (GTK_BOX (box), label, TRUE, TRUE, 0);
// 
//      gtk_container_add (GTK_CONTAINER (menu_item), box);
// 
//      gtk_widget_show_all (menu_item);
	type ImageMenuItem struct {
		MenuItem
		Actionable
		Activatable
		Buildable
		
	}

	// ImageMenuItemClass is an interface that the ImageMenuItem class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ImageMenuItemClass interface {
		gextras.Objector
		_imageMenuItem()
	}

	func (ImageMenuItem) _imageMenuItem() {}

	
	func marshalImageMenuItem(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapImageMenuItem(obj), nil
	}
	

	
	// NewImageMenuItem creates a new ImageMenuItem with an empty label.
	func NewImageMenuItem() ImageMenuItem {
var _cret *C.GtkWidget // in

_cret = C.gtk_image_menu_item_new()


var _imageMenuItem ImageMenuItem // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_imageMenuItem = ImageMenuItem{
MenuItem: MenuItem{
Bin: Bin{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _imageMenuItem
}
	
	// NewImageMenuItemFromStock creates a new ImageMenuItem containing the image
// and text from a stock item. Some stock ids have preprocessor macros like
// K_STOCK_OK and K_STOCK_APPLY.
// 
// If you want this menu item to have changeable accelerators, then pass in nil
// for accel_group. Next call gtk_menu_item_set_accel_path() with an appropriate
// path for the menu item, use gtk_stock_lookup() to look up the standard
// accelerator for the stock item, and if one is found, call
// gtk_accel_map_add_entry() to register it.
	func NewImageMenuItemFromStock(stockId string, accelGroup AccelGroupClass) ImageMenuItem {
var _arg1 *C.gchar // out
var _arg2 *C.GtkAccelGroup // out
var _cret *C.GtkWidget // in

_arg1 = (*C.gchar)(C.CString(stockId))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.GtkAccelGroup)(unsafe.Pointer(accelGroup.Native()))

_cret = C.gtk_image_menu_item_new_from_stock(_arg1, _arg2)


var _imageMenuItem ImageMenuItem // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_imageMenuItem = ImageMenuItem{
MenuItem: MenuItem{
Bin: Bin{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _imageMenuItem
}
	
	// NewImageMenuItemWithLabel creates a new ImageMenuItem containing a label.
	func NewImageMenuItemWithLabel(label string) ImageMenuItem {
var _arg1 *C.gchar // out
var _cret *C.GtkWidget // in

_arg1 = (*C.gchar)(C.CString(label))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_image_menu_item_new_with_label(_arg1)


var _imageMenuItem ImageMenuItem // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_imageMenuItem = ImageMenuItem{
MenuItem: MenuItem{
Bin: Bin{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _imageMenuItem
}
	
	// NewImageMenuItemWithMnemonic creates a new ImageMenuItem containing a label.
// The label will be created using gtk_label_new_with_mnemonic(), so underscores
// in @label indicate the mnemonic for the menu item.
	func NewImageMenuItemWithMnemonic(label string) ImageMenuItem {
var _arg1 *C.gchar // out
var _cret *C.GtkWidget // in

_arg1 = (*C.gchar)(C.CString(label))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_image_menu_item_new_with_mnemonic(_arg1)


var _imageMenuItem ImageMenuItem // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_imageMenuItem = ImageMenuItem{
MenuItem: MenuItem{
Bin: Bin{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _imageMenuItem
}
	

	
	// AlwaysShowImage returns whether the menu item will ignore the
// Settings:gtk-menu-images setting and always show the image, if available.
	func (i ImageMenuItem) AlwaysShowImage() bool {
var _arg0 *C.GtkImageMenuItem // out
var _cret C.gboolean // in

_arg0 = (*C.GtkImageMenuItem)(unsafe.Pointer(i.Native()))

_cret = C.gtk_image_menu_item_get_always_show_image(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Image gets the widget that is currently set as the image of @image_menu_item.
// See gtk_image_menu_item_set_image().
	func (i ImageMenuItem) Image() Widget {
var _arg0 *C.GtkImageMenuItem // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkImageMenuItem)(unsafe.Pointer(i.Native()))

_cret = C.gtk_image_menu_item_get_image(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// UseStock checks whether the label set in the menuitem is used as a stock id
// to select the stock item for the item.
	func (i ImageMenuItem) UseStock() bool {
var _arg0 *C.GtkImageMenuItem // out
var _cret C.gboolean // in

_arg0 = (*C.GtkImageMenuItem)(unsafe.Pointer(i.Native()))

_cret = C.gtk_image_menu_item_get_use_stock(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetAccelGroup specifies an @accel_group to add the menu items accelerator to
// (this only applies to stock items so a stock item must already be set, make
// sure to call gtk_image_menu_item_set_use_stock() and
// gtk_menu_item_set_label() with a valid stock item first).
// 
// If you want this menu item to have changeable accelerators then you shouldnt
// need this (see gtk_image_menu_item_new_from_stock()).
	func (i ImageMenuItem) SetAccelGroup(accelGroup AccelGroupClass)  {
var _arg0 *C.GtkImageMenuItem // out
var _arg1 *C.GtkAccelGroup // out

_arg0 = (*C.GtkImageMenuItem)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GtkAccelGroup)(unsafe.Pointer(accelGroup.Native()))

C.gtk_image_menu_item_set_accel_group(_arg0, _arg1)
}
	
	// SetAlwaysShowImage: if true, the menu item will ignore the
// Settings:gtk-menu-images setting and always show the image, if available.
// 
// Use this property if the menuitem would be useless or hard to use without the
// image.
	func (i ImageMenuItem) SetAlwaysShowImage(alwaysShow bool)  {
var _arg0 *C.GtkImageMenuItem // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkImageMenuItem)(unsafe.Pointer(i.Native()))
if alwaysShow { _arg1 = C.TRUE }

C.gtk_image_menu_item_set_always_show_image(_arg0, _arg1)
}
	
	// SetImage sets the image of @image_menu_item to the given widget. Note that it
// depends on the show-menu-images setting whether the image will be displayed
// or not.
	func (i ImageMenuItem) SetImage(image WidgetClass)  {
var _arg0 *C.GtkImageMenuItem // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkImageMenuItem)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(image.Native()))

C.gtk_image_menu_item_set_image(_arg0, _arg1)
}
	
	// SetUseStock: if true, the label set in the menuitem is used as a stock id to
// select the stock item for the item.
	func (i ImageMenuItem) SetUseStock(useStock bool)  {
var _arg0 *C.GtkImageMenuItem // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkImageMenuItem)(unsafe.Pointer(i.Native()))
if useStock { _arg1 = C.TRUE }

C.gtk_image_menu_item_set_use_stock(_arg0, _arg1)
}
	


	// InfoBar is a widget that can be used to show messages to the user without
// showing a dialog. It is often temporarily shown at the top or bottom of a
// document. In contrast to Dialog, which has a action area at the bottom,
// InfoBar has an action area at the side.
// 
// The API of InfoBar is very similar to Dialog, allowing you to add buttons to
// the action area with gtk_info_bar_add_button() or
// gtk_info_bar_new_with_buttons(). The sensitivity of action widgets can be
// controlled with gtk_info_bar_set_response_sensitive(). To add widgets to the
// main content area of a InfoBar, use gtk_info_bar_get_content_area() and add
// your widgets to the container.
// 
// Similar to MessageDialog, the contents of a InfoBar can by classified as
// error message, warning, informational message, etc, by using
// gtk_info_bar_set_message_type(). GTK+ may use the message type to determine
// how the message is displayed.
// 
// A simple example for using a InfoBar:
// 
//    GtkWidget *widget, *message_label, *content_area;
//    GtkWidget *grid;
//    GtkInfoBar *bar;
// 
//    // set up info bar
//    widget = gtk_info_bar_new ();
//    bar = GTK_INFO_BAR (widget);
//    grid = gtk_grid_new ();
// 
//    gtk_widget_set_no_show_all (widget, TRUE);
//    message_label = gtk_label_new ("");
//    content_area = gtk_info_bar_get_content_area (bar);
//    gtk_container_add (GTK_CONTAINER (content_area),
//                       message_label);
//    gtk_info_bar_add_button (bar,
//                             _("_OK"),
//                             GTK_RESPONSE_OK);
//    g_signal_connect (bar,
//                      "response",
//                      G_CALLBACK (gtk_widget_hide),
//                      NULL);
//    gtk_grid_attach (GTK_GRID (grid),
//                     widget,
//                     0, 2, 1, 1);
// 
//    // ...
// 
//    // show an error message
//    gtk_label_set_text (GTK_LABEL (message_label), "An error occurred!");
//    gtk_info_bar_set_message_type (bar,
//                                   GTK_MESSAGE_ERROR);
//    gtk_widget_show (bar);
// 
// 
// GtkInfoBar as GtkBuildable
// 
// The GtkInfoBar implementation of the GtkBuildable interface exposes the
// content area and action area as internal children with the names
// “content_area” and “action_area”.
// 
// GtkInfoBar supports a custom <action-widgets> element, which can contain
// multiple <action-widget> elements. The “response” attribute specifies a
// numeric response, and the content of the element is the id of widget (which
// should be a child of the dialogs @action_area).
// 
// 
// CSS nodes
// 
// GtkInfoBar has a single CSS node with name infobar. The node may get one of
// the style classes .info, .warning, .error or .question, depending on the
// message type.
	type InfoBar struct {
		Box
		Buildable
		Orientable
		
	}

	// InfoBarClass is an interface that the InfoBar class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type InfoBarClass interface {
		gextras.Objector
		_infoBar()
	}

	func (InfoBar) _infoBar() {}

	
	func marshalInfoBar(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapInfoBar(obj), nil
	}
	

	
	// NewInfoBar creates a new InfoBar object.
	func NewInfoBar() InfoBar {
var _cret *C.GtkWidget // in

_cret = C.gtk_info_bar_new()


var _infoBar InfoBar // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_infoBar = InfoBar{
Box: Box{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _infoBar
}
	

	
	// AddActionWidget: add an activatable widget to the action area of a InfoBar,
// connecting a signal handler that will emit the InfoBar::response signal on
// the message area when the widget is activated. The widget is appended to the
// end of the message areas action area.
	func (i InfoBar) AddActionWidget(child WidgetClass, responseId int)  {
var _arg0 *C.GtkInfoBar // out
var _arg1 *C.GtkWidget // out
var _arg2 C.gint // out

_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
_arg2 = (C.gint)(responseId)

C.gtk_info_bar_add_action_widget(_arg0, _arg1, _arg2)
}
	
	// AddButton adds a button with the given text and sets things up so that
// clicking the button will emit the “response” signal with the given
// response_id. The button is appended to the end of the info bars's action
// area. The button widget is returned, but usually you don't need it.
	func (i InfoBar) AddButton(buttonText string, responseId int) Button {
var _arg0 *C.GtkInfoBar // out
var _arg1 *C.gchar // out
var _arg2 C.gint // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))
_arg1 = (*C.gchar)(C.CString(buttonText))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.gint)(responseId)

_cret = C.gtk_info_bar_add_button(_arg0, _arg1, _arg2)


var _button Button // out

_button = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Button)

return _button
}
	
	// ActionArea returns the action area of @info_bar.
	func (i InfoBar) ActionArea() Box {
var _arg0 *C.GtkInfoBar // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))

_cret = C.gtk_info_bar_get_action_area(_arg0)


var _box Box // out

_box = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Box)

return _box
}
	
	// ContentArea returns the content area of @info_bar.
	func (i InfoBar) ContentArea() Box {
var _arg0 *C.GtkInfoBar // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))

_cret = C.gtk_info_bar_get_content_area(_arg0)


var _box Box // out

_box = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Box)

return _box
}
	
	// MessageType returns the message type of the message area.
	func (i InfoBar) MessageType() MessageType {
var _arg0 *C.GtkInfoBar // out
var _cret C.GtkMessageType // in

_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))

_cret = C.gtk_info_bar_get_message_type(_arg0)


var _messageType MessageType // out

_messageType = MessageType(_cret)

return _messageType
}
	
	
	func (i InfoBar) Revealed() bool {
var _arg0 *C.GtkInfoBar // out
var _cret C.gboolean // in

_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))

_cret = C.gtk_info_bar_get_revealed(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ShowCloseButton returns whether the widget will display a standard close
// button.
	func (i InfoBar) ShowCloseButton() bool {
var _arg0 *C.GtkInfoBar // out
var _cret C.gboolean // in

_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))

_cret = C.gtk_info_bar_get_show_close_button(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Response emits the “response” signal with the given @response_id.
	func (i InfoBar) Response(responseId int)  {
var _arg0 *C.GtkInfoBar // out
var _arg1 C.gint // out

_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))
_arg1 = (C.gint)(responseId)

C.gtk_info_bar_response(_arg0, _arg1)
}
	
	// SetDefaultResponse sets the last widget in the info bar’s action area with
// the given response_id as the default widget for the dialog. Pressing “Enter”
// normally activates the default widget.
// 
// Note that this function currently requires @info_bar to be added to a widget
// hierarchy.
	func (i InfoBar) SetDefaultResponse(responseId int)  {
var _arg0 *C.GtkInfoBar // out
var _arg1 C.gint // out

_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))
_arg1 = (C.gint)(responseId)

C.gtk_info_bar_set_default_response(_arg0, _arg1)
}
	
	// SetMessageType sets the message type of the message area.
// 
// GTK+ uses this type to determine how the message is displayed.
	func (i InfoBar) SetMessageType(messageType MessageType)  {
var _arg0 *C.GtkInfoBar // out
var _arg1 C.GtkMessageType // out

_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))
_arg1 = (C.GtkMessageType)(messageType)

C.gtk_info_bar_set_message_type(_arg0, _arg1)
}
	
	// SetResponseSensitive calls gtk_widget_set_sensitive (widget, setting) for
// each widget in the info bars’s action area with the given response_id. A
// convenient way to sensitize/desensitize dialog buttons.
	func (i InfoBar) SetResponseSensitive(responseId int, setting bool)  {
var _arg0 *C.GtkInfoBar // out
var _arg1 C.gint // out
var _arg2 C.gboolean // out

_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))
_arg1 = (C.gint)(responseId)
if setting { _arg2 = C.TRUE }

C.gtk_info_bar_set_response_sensitive(_arg0, _arg1, _arg2)
}
	
	// SetRevealed sets the GtkInfoBar:revealed property to @revealed. This will
// cause @info_bar to show up with a slide-in transition.
// 
// Note that this property does not automatically show @info_bar and thus won’t
// have any effect if it is invisible.
	func (i InfoBar) SetRevealed(revealed bool)  {
var _arg0 *C.GtkInfoBar // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))
if revealed { _arg1 = C.TRUE }

C.gtk_info_bar_set_revealed(_arg0, _arg1)
}
	
	// SetShowCloseButton: if true, a standard close button is shown. When clicked
// it emits the response GTK_RESPONSE_CLOSE.
	func (i InfoBar) SetShowCloseButton(setting bool)  {
var _arg0 *C.GtkInfoBar // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))
if setting { _arg1 = C.TRUE }

C.gtk_info_bar_set_show_close_button(_arg0, _arg1)
}
	


	// Invisible: the Invisible widget is used internally in GTK+, and is probably
// not very useful for application developers.
// 
// It is used for reliable pointer grabs and selection handling in the code for
// drag-and-drop.
	type Invisible struct {
		Widget
		Buildable
		
	}

	// InvisibleClass is an interface that the Invisible class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type InvisibleClass interface {
		gextras.Objector
		_invisible()
	}

	func (Invisible) _invisible() {}

	
	func marshalInvisible(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapInvisible(obj), nil
	}
	

	
	// NewInvisible creates a new Invisible.
	func NewInvisible() Invisible {
var _cret *C.GtkWidget // in

_cret = C.gtk_invisible_new()


var _invisible Invisible // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_invisible = Invisible{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _invisible
}
	
	// NewInvisibleForScreen creates a new Invisible object for a specified screen
	func NewInvisibleForScreen(screen gdk.ScreenClass) Invisible {
var _arg1 *C.GdkScreen // out
var _cret *C.GtkWidget // in

_arg1 = (*C.GdkScreen)(unsafe.Pointer(screen.Native()))

_cret = C.gtk_invisible_new_for_screen(_arg1)


var _invisible Invisible // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_invisible = Invisible{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _invisible
}
	

	
	// Screen returns the Screen object associated with @invisible
	func (i Invisible) Screen() gdk.Screen {
var _arg0 *C.GtkInvisible // out
var _cret *C.GdkScreen // in

_arg0 = (*C.GtkInvisible)(unsafe.Pointer(i.Native()))

_cret = C.gtk_invisible_get_screen(_arg0)


var _screen gdk.Screen // out

_screen = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Screen)

return _screen
}
	
	// SetScreen sets the Screen where the Invisible object will be displayed.
	func (i Invisible) SetScreen(screen gdk.ScreenClass)  {
var _arg0 *C.GtkInvisible // out
var _arg1 *C.GdkScreen // out

_arg0 = (*C.GtkInvisible)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GdkScreen)(unsafe.Pointer(screen.Native()))

C.gtk_invisible_set_screen(_arg0, _arg1)
}
	


	// Label: the Label widget displays a small amount of text. As the name implies,
// most labels are used to label another widget such as a Button, a MenuItem, or
// a ComboBox.
// 
// CSS nodes
// 
//    const gchar *text =
//    "Go to the"
//    "<a href=\"http://www.gtk.org title=\"&lt;i&gt;Our&lt;/i&gt; website\">"
//    "GTK+ website</a> for more...";
//    GtkWidget *label = gtk_label_new (NULL);
//    gtk_label_set_markup (GTK_LABEL (label), text);
// 
// It is possible to implement custom handling for links and their tooltips with
// the Label::activate-link signal and the gtk_label_get_current_uri() function.
	type Label struct {
		Misc
		Buildable
		
	}

	// LabelClass is an interface that the Label class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type LabelClass interface {
		gextras.Objector
		_label()
	}

	func (Label) _label() {}

	
	func marshalLabel(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapLabel(obj), nil
	}
	

	
	// NewLabel creates a new label with the given text inside it. You can pass nil
// to get an empty label widget.
	func NewLabel(str string) Label {
var _arg1 *C.gchar // out
var _cret *C.GtkWidget // in

_arg1 = (*C.gchar)(C.CString(str))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_label_new(_arg1)


var _label Label // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_label = Label{
Misc: Misc{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _label
}
	
	// NewLabelWithMnemonic creates a new Label, containing the text in @str.
// 
// If characters in @str are preceded by an underscore, they are underlined. If
// you need a literal underscore character in a label, use '__' (two
// underscores). The first underlined character represents a keyboard
// accelerator called a mnemonic. The mnemonic key can be used to activate
// another widget, chosen automatically, or explicitly using
// gtk_label_set_mnemonic_widget().
// 
// If gtk_label_set_mnemonic_widget() is not called, then the first activatable
// ancestor of the Label will be chosen as the mnemonic widget. For instance, if
// the label is inside a button or menu item, the button or menu item will
// automatically become the mnemonic widget and be activated by the mnemonic.
	func NewLabelWithMnemonic(str string) Label {
var _arg1 *C.gchar // out
var _cret *C.GtkWidget // in

_arg1 = (*C.gchar)(C.CString(str))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_label_new_with_mnemonic(_arg1)


var _label Label // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_label = Label{
Misc: Misc{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _label
}
	

	
	// Angle gets the angle of rotation for the label. See gtk_label_set_angle().
	func (l Label) Angle() float64 {
var _arg0 *C.GtkLabel // out
var _cret C.gdouble // in

_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))

_cret = C.gtk_label_get_angle(_arg0)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// Attributes gets the attribute list that was set on the label using
// gtk_label_set_attributes(), if any. This function does not reflect attributes
// that come from the labels markup (see gtk_label_set_markup()). If you want to
// get the effective attributes for the label, use pango_layout_get_attribute
// (gtk_label_get_layout (label)).
	func (l Label) Attributes() *pango.AttrList {
var _arg0 *C.GtkLabel // out
var _cret *C.PangoAttrList // in

_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))

_cret = C.gtk_label_get_attributes(_arg0)


var _attrList *pango.AttrList // out

_attrList = *(**pango.AttrList)(unsafe.Pointer(&_cret))

return _attrList
}
	
	// CurrentURI returns the URI for the currently active link in the label. The
// active link is the one under the mouse pointer or, in a selectable label, the
// link in which the text cursor is currently positioned.
// 
// This function is intended for use in a Label::activate-link handler or for
// use in a Widget::query-tooltip handler.
	func (l Label) CurrentURI() string {
var _arg0 *C.GtkLabel // out
var _cret *C.gchar // in

_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))

_cret = C.gtk_label_get_current_uri(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Ellipsize returns the ellipsizing position of the label. See
// gtk_label_set_ellipsize().
	func (l Label) Ellipsize() pango.EllipsizeMode {
var _arg0 *C.GtkLabel // out
var _cret C.PangoEllipsizeMode // in

_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))

_cret = C.gtk_label_get_ellipsize(_arg0)


var _ellipsizeMode pango.EllipsizeMode // out

_ellipsizeMode = pango.EllipsizeMode(_cret)

return _ellipsizeMode
}
	
	// Justify returns the justification of the label. See gtk_label_set_justify().
	func (l Label) Justify() Justification {
var _arg0 *C.GtkLabel // out
var _cret C.GtkJustification // in

_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))

_cret = C.gtk_label_get_justify(_arg0)


var _justification Justification // out

_justification = Justification(_cret)

return _justification
}
	
	// Label fetches the text from a label widget including any embedded underlines
// indicating mnemonics and Pango markup. (See gtk_label_get_text()).
	func (l Label) Label() string {
var _arg0 *C.GtkLabel // out
var _cret *C.gchar // in

_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))

_cret = C.gtk_label_get_label(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Layout gets the Layout used to display the label. The layout is useful to
// e.g. convert text positions to pixel positions, in combination with
// gtk_label_get_layout_offsets(). The returned layout is owned by the @label so
// need not be freed by the caller. The @label is free to recreate its layout at
// any time, so it should be considered read-only.
	func (l Label) Layout() pango.Layout {
var _arg0 *C.GtkLabel // out
var _cret *C.PangoLayout // in

_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))

_cret = C.gtk_label_get_layout(_arg0)


var _layout pango.Layout // out

_layout = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(pango.Layout)

return _layout
}
	
	// LayoutOffsets obtains the coordinates where the label will draw the Layout
// representing the text in the label; useful to convert mouse events into
// coordinates inside the Layout, e.g. to take some action if some part of the
// label is clicked. Of course you will need to create a EventBox to receive the
// events, and pack the label inside it, since labels are windowless (they
// return false from gtk_widget_get_has_window()). Remember when using the
// Layout functions you need to convert to and from pixels using PANGO_PIXELS()
// or NGO_SCALE.
	func (l Label) LayoutOffsets() (x int, y int) {
var _arg0 *C.GtkLabel // out
var _arg1 C.gint // in
var _arg2 C.gint // in

_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))

C.gtk_label_get_layout_offsets(_arg0, &_arg1, &_arg2)

var _x int // out
var _y int // out

_x = (int)(_arg1)
_y = (int)(_arg2)

return _x, _y
}
	
	// LineWrap returns whether lines in the label are automatically wrapped. See
// gtk_label_set_line_wrap().
	func (l Label) LineWrap() bool {
var _arg0 *C.GtkLabel // out
var _cret C.gboolean // in

_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))

_cret = C.gtk_label_get_line_wrap(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// LineWrapMode returns line wrap mode used by the label. See
// gtk_label_set_line_wrap_mode().
	func (l Label) LineWrapMode() pango.WrapMode {
var _arg0 *C.GtkLabel // out
var _cret C.PangoWrapMode // in

_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))

_cret = C.gtk_label_get_line_wrap_mode(_arg0)


var _wrapMode pango.WrapMode // out

_wrapMode = pango.WrapMode(_cret)

return _wrapMode
}
	
	// Lines gets the number of lines to which an ellipsized, wrapping label should
// be limited. See gtk_label_set_lines().
	func (l Label) Lines() int {
var _arg0 *C.GtkLabel // out
var _cret C.gint // in

_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))

_cret = C.gtk_label_get_lines(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// MaxWidthChars retrieves the desired maximum width of @label, in characters.
// See gtk_label_set_width_chars().
	func (l Label) MaxWidthChars() int {
var _arg0 *C.GtkLabel // out
var _cret C.gint // in

_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))

_cret = C.gtk_label_get_max_width_chars(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// MnemonicKeyval: if the label has been set so that it has an mnemonic key this
// function returns the keyval used for the mnemonic accelerator. If there is no
// mnemonic set up it returns K_KEY_VoidSymbol.
	func (l Label) MnemonicKeyval() uint {
var _arg0 *C.GtkLabel // out
var _cret C.guint // in

_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))

_cret = C.gtk_label_get_mnemonic_keyval(_arg0)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// MnemonicWidget retrieves the target of the mnemonic (keyboard shortcut) of
// this label. See gtk_label_set_mnemonic_widget().
	func (l Label) MnemonicWidget() Widget {
var _arg0 *C.GtkLabel // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))

_cret = C.gtk_label_get_mnemonic_widget(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// Selectable gets the value set by gtk_label_set_selectable().
	func (l Label) Selectable() bool {
var _arg0 *C.GtkLabel // out
var _cret C.gboolean // in

_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))

_cret = C.gtk_label_get_selectable(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SelectionBounds gets the selected range of characters in the label, returning
// true if there’s a selection.
	func (l Label) SelectionBounds() (start int, end int, ok bool) {
var _arg0 *C.GtkLabel // out
var _arg1 C.gint // in
var _arg2 C.gint // in
var _cret C.gboolean // in

_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))

_cret = C.gtk_label_get_selection_bounds(_arg0, &_arg1, &_arg2)


var _start int // out
var _end int // out
var _ok bool // out

_start = (int)(_arg1)
_end = (int)(_arg2)
if _cret != 0 { _ok = true }

return _start, _end, _ok
}
	
	// SingleLineMode returns whether the label is in single line mode.
	func (l Label) SingleLineMode() bool {
var _arg0 *C.GtkLabel // out
var _cret C.gboolean // in

_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))

_cret = C.gtk_label_get_single_line_mode(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Text fetches the text from a label widget, as displayed on the screen. This
// does not include any embedded underlines indicating mnemonics or Pango
// markup. (See gtk_label_get_label())
	func (l Label) Text() string {
var _arg0 *C.GtkLabel // out
var _cret *C.gchar // in

_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))

_cret = C.gtk_label_get_text(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// TrackVisitedLinks returns whether the label is currently keeping track of
// clicked links.
	func (l Label) TrackVisitedLinks() bool {
var _arg0 *C.GtkLabel // out
var _cret C.gboolean // in

_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))

_cret = C.gtk_label_get_track_visited_links(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// UseMarkup returns whether the label’s text is interpreted as marked up with
// the [Pango text markup language][PangoMarkupFormat]. See
// gtk_label_set_use_markup ().
	func (l Label) UseMarkup() bool {
var _arg0 *C.GtkLabel // out
var _cret C.gboolean // in

_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))

_cret = C.gtk_label_get_use_markup(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// UseUnderline returns whether an embedded underline in the label indicates a
// mnemonic. See gtk_label_set_use_underline().
	func (l Label) UseUnderline() bool {
var _arg0 *C.GtkLabel // out
var _cret C.gboolean // in

_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))

_cret = C.gtk_label_get_use_underline(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// WidthChars retrieves the desired width of @label, in characters. See
// gtk_label_set_width_chars().
	func (l Label) WidthChars() int {
var _arg0 *C.GtkLabel // out
var _cret C.gint // in

_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))

_cret = C.gtk_label_get_width_chars(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Xalign gets the Label:xalign property for @label.
	func (l Label) Xalign() float32 {
var _arg0 *C.GtkLabel // out
var _cret C.gfloat // in

_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))

_cret = C.gtk_label_get_xalign(_arg0)


var _gfloat float32 // out

_gfloat = (float32)(_cret)

return _gfloat
}
	
	// Yalign gets the Label:yalign property for @label.
	func (l Label) Yalign() float32 {
var _arg0 *C.GtkLabel // out
var _cret C.gfloat // in

_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))

_cret = C.gtk_label_get_yalign(_arg0)


var _gfloat float32 // out

_gfloat = (float32)(_cret)

return _gfloat
}
	
	// SelectRegion selects a range of characters in the label, if the label is
// selectable. See gtk_label_set_selectable(). If the label is not selectable,
// this function has no effect. If @start_offset or @end_offset are -1, then the
// end of the label will be substituted.
	func (l Label) SelectRegion(startOffset int, endOffset int)  {
var _arg0 *C.GtkLabel // out
var _arg1 C.gint // out
var _arg2 C.gint // out

_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))
_arg1 = (C.gint)(startOffset)
_arg2 = (C.gint)(endOffset)

C.gtk_label_select_region(_arg0, _arg1, _arg2)
}
	
	// SetAngle sets the angle of rotation for the label. An angle of 90 reads from
// from bottom to top, an angle of 270, from top to bottom. The angle setting
// for the label is ignored if the label is selectable, wrapped, or ellipsized.
	func (l Label) SetAngle(angle float64)  {
var _arg0 *C.GtkLabel // out
var _arg1 C.gdouble // out

_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))
_arg1 = (C.gdouble)(angle)

C.gtk_label_set_angle(_arg0, _arg1)
}
	
	// SetAttributes sets a AttrList; the attributes in the list are applied to the
// label text.
// 
// The attributes set with this function will be applied and merged with any
// other attributes previously effected by way of the Label:use-underline or
// Label:use-markup properties. While it is not recommended to mix markup
// strings with manually set attributes, if you must; know that the attributes
// will be applied to the label after the markup string is parsed.
	func (l Label) SetAttributes(attrs *pango.AttrList)  {
var _arg0 *C.GtkLabel // out
var _arg1 *C.PangoAttrList // out

_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))
_arg1 = (*C.PangoAttrList)(unsafe.Pointer(attrs.Native()))

C.gtk_label_set_attributes(_arg0, _arg1)
}
	
	// SetEllipsize sets the mode used to ellipsize (add an ellipsis: "...") to the
// text if there is not enough space to render the entire string.
	func (l Label) SetEllipsize(mode pango.EllipsizeMode)  {
var _arg0 *C.GtkLabel // out
var _arg1 C.PangoEllipsizeMode // out

_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))
_arg1 = (C.PangoEllipsizeMode)(mode)

C.gtk_label_set_ellipsize(_arg0, _arg1)
}
	
	// SetJustify sets the alignment of the lines in the text of the label relative
// to each other. GTK_JUSTIFY_LEFT is the default value when the widget is first
// created with gtk_label_new(). If you instead want to set the alignment of the
// label as a whole, use gtk_widget_set_halign() instead.
// gtk_label_set_justify() has no effect on labels containing only a single
// line.
	func (l Label) SetJustify(jtype Justification)  {
var _arg0 *C.GtkLabel // out
var _arg1 C.GtkJustification // out

_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))
_arg1 = (C.GtkJustification)(jtype)

C.gtk_label_set_justify(_arg0, _arg1)
}
	
	// SetLabel sets the text of the label. The label is interpreted as including
// embedded underlines and/or Pango markup depending on the values of the
// Label:use-underline and Label:use-markup properties.
	func (l Label) SetLabel(str string)  {
var _arg0 *C.GtkLabel // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))
_arg1 = (*C.gchar)(C.CString(str))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_label_set_label(_arg0, _arg1)
}
	
	// SetLineWrap toggles line wrapping within the Label widget. true makes it
// break lines if text exceeds the widget’s size. false lets the text get cut
// off by the edge of the widget if it exceeds the widget size.
// 
// Note that setting line wrapping to true does not make the label wrap at its
// parent container’s width, because GTK+ widgets conceptually can’t make their
// requisition depend on the parent container’s size. For a label that wraps at
// a specific position, set the label’s width using
// gtk_widget_set_size_request().
	func (l Label) SetLineWrap(wrap bool)  {
var _arg0 *C.GtkLabel // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))
if wrap { _arg1 = C.TRUE }

C.gtk_label_set_line_wrap(_arg0, _arg1)
}
	
	// SetLineWrapMode: if line wrapping is on (see gtk_label_set_line_wrap()) this
// controls how the line wrapping is done. The default is PANGO_WRAP_WORD which
// means wrap on word boundaries.
	func (l Label) SetLineWrapMode(wrapMode pango.WrapMode)  {
var _arg0 *C.GtkLabel // out
var _arg1 C.PangoWrapMode // out

_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))
_arg1 = (C.PangoWrapMode)(wrapMode)

C.gtk_label_set_line_wrap_mode(_arg0, _arg1)
}
	
	// SetLines sets the number of lines to which an ellipsized, wrapping label
// should be limited. This has no effect if the label is not wrapping or
// ellipsized. Set this to -1 if you don’t want to limit the number of lines.
	func (l Label) SetLines(lines int)  {
var _arg0 *C.GtkLabel // out
var _arg1 C.gint // out

_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))
_arg1 = (C.gint)(lines)

C.gtk_label_set_lines(_arg0, _arg1)
}
	
	// SetMarkup parses @str which is marked up with the [Pango text markup
// language][PangoMarkupFormat], setting the label’s text and attribute list
// based on the parse results.
// 
// If the @str is external data, you may need to escape it with
// g_markup_escape_text() or g_markup_printf_escaped():
// 
//    GtkWidget *label = gtk_label_new (NULL);
//    const char *str = "some text";
//    const char *format = "<span style=\"italic\">\s</span>";
//    char *markup;
// 
//    markup = g_markup_printf_escaped (format, str);
//    gtk_label_set_markup (GTK_LABEL (label), markup);
//    g_free (markup);
// 
// This function will set the Label:use-markup property to true as a side
// effect.
// 
// If you set the label contents using the Label:label property you should also
// ensure that you set the Label:use-markup property accordingly.
// 
// See also: gtk_label_set_text()
	func (l Label) SetMarkup(str string)  {
var _arg0 *C.GtkLabel // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))
_arg1 = (*C.gchar)(C.CString(str))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_label_set_markup(_arg0, _arg1)
}
	
	// SetMarkupWithMnemonic parses @str which is marked up with the [Pango text
// markup language][PangoMarkupFormat], setting the label’s text and attribute
// list based on the parse results. If characters in @str are preceded by an
// underscore, they are underlined indicating that they represent a keyboard
// accelerator called a mnemonic.
// 
// The mnemonic key can be used to activate another widget, chosen
// automatically, or explicitly using gtk_label_set_mnemonic_widget().
	func (l Label) SetMarkupWithMnemonic(str string)  {
var _arg0 *C.GtkLabel // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))
_arg1 = (*C.gchar)(C.CString(str))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_label_set_markup_with_mnemonic(_arg0, _arg1)
}
	
	// SetMaxWidthChars sets the desired maximum width in characters of @label to
// @n_chars.
	func (l Label) SetMaxWidthChars(nChars int)  {
var _arg0 *C.GtkLabel // out
var _arg1 C.gint // out

_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))
_arg1 = (C.gint)(nChars)

C.gtk_label_set_max_width_chars(_arg0, _arg1)
}
	
	// SetMnemonicWidget: if the label has been set so that it has an mnemonic key
// (using i.e. gtk_label_set_markup_with_mnemonic(),
// gtk_label_set_text_with_mnemonic(), gtk_label_new_with_mnemonic() or the
// “use_underline” property) the label can be associated with a widget that is
// the target of the mnemonic. When the label is inside a widget (like a Button
// or a Notebook tab) it is automatically associated with the correct widget,
// but sometimes (i.e. when the target is a Entry next to the label) you need to
// set it explicitly using this function.
// 
// The target widget will be accelerated by emitting the
// GtkWidget::mnemonic-activate signal on it. The default handler for this
// signal will activate the widget if there are no mnemonic collisions and
// toggle focus between the colliding widgets otherwise.
	func (l Label) SetMnemonicWidget(widget WidgetClass)  {
var _arg0 *C.GtkLabel // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

C.gtk_label_set_mnemonic_widget(_arg0, _arg1)
}
	
	// SetPattern: the pattern of underlines you want under the existing text within
// the Label widget. For example if the current text of the label says
// “FooBarBaz” passing a pattern of “___ ___” will underline “Foo” and “Baz” but
// not “Bar”.
	func (l Label) SetPattern(pattern string)  {
var _arg0 *C.GtkLabel // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))
_arg1 = (*C.gchar)(C.CString(pattern))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_label_set_pattern(_arg0, _arg1)
}
	
	// SetSelectable: selectable labels allow the user to select text from the
// label, for copy-and-paste.
	func (l Label) SetSelectable(setting bool)  {
var _arg0 *C.GtkLabel // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))
if setting { _arg1 = C.TRUE }

C.gtk_label_set_selectable(_arg0, _arg1)
}
	
	// SetSingleLineMode sets whether the label is in single line mode.
	func (l Label) SetSingleLineMode(singleLineMode bool)  {
var _arg0 *C.GtkLabel // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))
if singleLineMode { _arg1 = C.TRUE }

C.gtk_label_set_single_line_mode(_arg0, _arg1)
}
	
	// SetText sets the text within the Label widget. It overwrites any text that
// was there before.
// 
// This function will clear any previously set mnemonic accelerators, and set
// the Label:use-underline property to false as a side effect.
// 
// This function will set the Label:use-markup property to false as a side
// effect.
// 
// See also: gtk_label_set_markup()
	func (l Label) SetText(str string)  {
var _arg0 *C.GtkLabel // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))
_arg1 = (*C.gchar)(C.CString(str))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_label_set_text(_arg0, _arg1)
}
	
	// SetTextWithMnemonic sets the label’s text from the string @str. If characters
// in @str are preceded by an underscore, they are underlined indicating that
// they represent a keyboard accelerator called a mnemonic. The mnemonic key can
// be used to activate another widget, chosen automatically, or explicitly using
// gtk_label_set_mnemonic_widget().
	func (l Label) SetTextWithMnemonic(str string)  {
var _arg0 *C.GtkLabel // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))
_arg1 = (*C.gchar)(C.CString(str))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_label_set_text_with_mnemonic(_arg0, _arg1)
}
	
	// SetTrackVisitedLinks sets whether the label should keep track of clicked
// links (and use a different color for them).
	func (l Label) SetTrackVisitedLinks(trackLinks bool)  {
var _arg0 *C.GtkLabel // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))
if trackLinks { _arg1 = C.TRUE }

C.gtk_label_set_track_visited_links(_arg0, _arg1)
}
	
	// SetUseMarkup sets whether the text of the label contains markup in [Pango’s
// text markup language][PangoMarkupFormat]. See gtk_label_set_markup().
	func (l Label) SetUseMarkup(setting bool)  {
var _arg0 *C.GtkLabel // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))
if setting { _arg1 = C.TRUE }

C.gtk_label_set_use_markup(_arg0, _arg1)
}
	
	// SetUseUnderline: if true, an underline in the text indicates the next
// character should be used for the mnemonic accelerator key.
	func (l Label) SetUseUnderline(setting bool)  {
var _arg0 *C.GtkLabel // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))
if setting { _arg1 = C.TRUE }

C.gtk_label_set_use_underline(_arg0, _arg1)
}
	
	// SetWidthChars sets the desired width in characters of @label to @n_chars.
	func (l Label) SetWidthChars(nChars int)  {
var _arg0 *C.GtkLabel // out
var _arg1 C.gint // out

_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))
_arg1 = (C.gint)(nChars)

C.gtk_label_set_width_chars(_arg0, _arg1)
}
	
	// SetXalign sets the Label:xalign property for @label.
	func (l Label) SetXalign(xalign float32)  {
var _arg0 *C.GtkLabel // out
var _arg1 C.gfloat // out

_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))
_arg1 = (C.gfloat)(xalign)

C.gtk_label_set_xalign(_arg0, _arg1)
}
	
	// SetYalign sets the Label:yalign property for @label.
	func (l Label) SetYalign(yalign float32)  {
var _arg0 *C.GtkLabel // out
var _arg1 C.gfloat // out

_arg0 = (*C.GtkLabel)(unsafe.Pointer(l.Native()))
_arg1 = (C.gfloat)(yalign)

C.gtk_label_set_yalign(_arg0, _arg1)
}
	


	// Layout is similar to DrawingArea in that it’s a “blank slate” and doesn’t do
// anything except paint a blank background by default. It’s different in that
// it supports scrolling natively due to implementing Scrollable, and can
// contain child widgets since it’s a Container.
// 
// If you just want to draw, a DrawingArea is a better choice since it has lower
// overhead. If you just need to position child widgets at specific points, then
// Fixed provides that functionality on its own.
// 
// When handling expose events on a Layout, you must draw to the Window returned
// by gtk_layout_get_bin_window(), rather than to the one returned by
// gtk_widget_get_window() as you would for a DrawingArea.
	type Layout struct {
		Container
		Buildable
		Scrollable
		
	}

	// LayoutClass is an interface that the Layout class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type LayoutClass interface {
		gextras.Objector
		_layout()
	}

	func (Layout) _layout() {}

	
	func marshalLayout(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapLayout(obj), nil
	}
	

	
	// NewLayout creates a new Layout. Unless you have a specific adjustment you’d
// like the layout to use for scrolling, pass nil for @hadjustment and
// @vadjustment.
	func NewLayout(hadjustment AdjustmentClass, vadjustment AdjustmentClass) Layout {
var _arg1 *C.GtkAdjustment // out
var _arg2 *C.GtkAdjustment // out
var _cret *C.GtkWidget // in

_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(hadjustment.Native()))
_arg2 = (*C.GtkAdjustment)(unsafe.Pointer(vadjustment.Native()))

_cret = C.gtk_layout_new(_arg1, _arg2)


var _layout Layout // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_layout = Layout{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Scrollable: Scrollable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _layout
}
	

	
	// BinWindow: retrieve the bin window of the layout used for drawing operations.
	func (l Layout) BinWindow() gdk.Window {
var _arg0 *C.GtkLayout // out
var _cret *C.GdkWindow // in

_arg0 = (*C.GtkLayout)(unsafe.Pointer(l.Native()))

_cret = C.gtk_layout_get_bin_window(_arg0)


var _window gdk.Window // out

_window = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Window)

return _window
}
	
	// HAdjustment: this function should only be called after the layout has been
// placed in a ScrolledWindow or otherwise configured for scrolling. It returns
// the Adjustment used for communication between the horizontal scrollbar and
// @layout.
// 
// See ScrolledWindow, Scrollbar, Adjustment for details.
	func (l Layout) HAdjustment() Adjustment {
var _arg0 *C.GtkLayout // out
var _cret *C.GtkAdjustment // in

_arg0 = (*C.GtkLayout)(unsafe.Pointer(l.Native()))

_cret = C.gtk_layout_get_hadjustment(_arg0)


var _adjustment Adjustment // out

_adjustment = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Adjustment)

return _adjustment
}
	
	// Size gets the size that has been set on the layout, and that determines the
// total extents of the layout’s scrollbar area. See gtk_layout_set_size ().
	func (l Layout) Size() (width uint, height uint) {
var _arg0 *C.GtkLayout // out
var _arg1 C.guint // in
var _arg2 C.guint // in

_arg0 = (*C.GtkLayout)(unsafe.Pointer(l.Native()))

C.gtk_layout_get_size(_arg0, &_arg1, &_arg2)

var _width uint // out
var _height uint // out

_width = (uint)(_arg1)
_height = (uint)(_arg2)

return _width, _height
}
	
	// VAdjustment: this function should only be called after the layout has been
// placed in a ScrolledWindow or otherwise configured for scrolling. It returns
// the Adjustment used for communication between the vertical scrollbar and
// @layout.
// 
// See ScrolledWindow, Scrollbar, Adjustment for details.
	func (l Layout) VAdjustment() Adjustment {
var _arg0 *C.GtkLayout // out
var _cret *C.GtkAdjustment // in

_arg0 = (*C.GtkLayout)(unsafe.Pointer(l.Native()))

_cret = C.gtk_layout_get_vadjustment(_arg0)


var _adjustment Adjustment // out

_adjustment = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Adjustment)

return _adjustment
}
	
	// Move moves a current child of @layout to a new position.
	func (l Layout) Move(childWidget WidgetClass, x int, y int)  {
var _arg0 *C.GtkLayout // out
var _arg1 *C.GtkWidget // out
var _arg2 C.gint // out
var _arg3 C.gint // out

_arg0 = (*C.GtkLayout)(unsafe.Pointer(l.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(childWidget.Native()))
_arg2 = (C.gint)(x)
_arg3 = (C.gint)(y)

C.gtk_layout_move(_arg0, _arg1, _arg2, _arg3)
}
	
	// Put adds @child_widget to @layout, at position (@x,@y). @layout becomes the
// new parent container of @child_widget.
	func (l Layout) Put(childWidget WidgetClass, x int, y int)  {
var _arg0 *C.GtkLayout // out
var _arg1 *C.GtkWidget // out
var _arg2 C.gint // out
var _arg3 C.gint // out

_arg0 = (*C.GtkLayout)(unsafe.Pointer(l.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(childWidget.Native()))
_arg2 = (C.gint)(x)
_arg3 = (C.gint)(y)

C.gtk_layout_put(_arg0, _arg1, _arg2, _arg3)
}
	
	// SetHAdjustment sets the horizontal scroll adjustment for the layout.
// 
// See ScrolledWindow, Scrollbar, Adjustment for details.
	func (l Layout) SetHAdjustment(adjustment AdjustmentClass)  {
var _arg0 *C.GtkLayout // out
var _arg1 *C.GtkAdjustment // out

_arg0 = (*C.GtkLayout)(unsafe.Pointer(l.Native()))
_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(adjustment.Native()))

C.gtk_layout_set_hadjustment(_arg0, _arg1)
}
	
	// SetSize sets the size of the scrollable area of the layout.
	func (l Layout) SetSize(width uint, height uint)  {
var _arg0 *C.GtkLayout // out
var _arg1 C.guint // out
var _arg2 C.guint // out

_arg0 = (*C.GtkLayout)(unsafe.Pointer(l.Native()))
_arg1 = (C.guint)(width)
_arg2 = (C.guint)(height)

C.gtk_layout_set_size(_arg0, _arg1, _arg2)
}
	
	// SetVAdjustment sets the vertical scroll adjustment for the layout.
// 
// See ScrolledWindow, Scrollbar, Adjustment for details.
	func (l Layout) SetVAdjustment(adjustment AdjustmentClass)  {
var _arg0 *C.GtkLayout // out
var _arg1 *C.GtkAdjustment // out

_arg0 = (*C.GtkLayout)(unsafe.Pointer(l.Native()))
_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(adjustment.Native()))

C.gtk_layout_set_vadjustment(_arg0, _arg1)
}
	


	// LevelBar: the LevelBar is a bar widget that can be used as a level indicator.
// Typical use cases are displaying the strength of a password, or showing the
// charge level of a battery.
// 
// Use gtk_level_bar_set_value() to set the current value, and
// gtk_level_bar_add_offset_value() to set the value offsets at which the bar
// will be considered in a different state. GTK will add a few offsets by
// default on the level bar: K_LEVEL_BAR_OFFSET_LOW, K_LEVEL_BAR_OFFSET_HIGH and
// K_LEVEL_BAR_OFFSET_FULL, with values 0.25, 0.75 and 1.0 respectively.
// 
// Note that it is your responsibility to update preexisting offsets when
// changing the minimum or maximum value. GTK+ will simply clamp them to the new
// range.
// 
// Adding a custom offset on the bar
// 
//    levelbar[.discrete]
//    ╰── trough
//        ├── block.filled.level-name
//        ┊
//        ├── block.empty
//        ┊
// 
// GtkLevelBar has a main CSS node with name levelbar and one of the style
// classes .discrete or .continuous and a subnode with name trough. Below the
// trough node are a number of nodes with name block and style class .filled or
// .empty. In continuous mode, there is exactly one node of each, in discrete
// mode, the number of filled and unfilled nodes corresponds to blocks that are
// drawn. The block.filled nodes also get a style class .level-name
// corresponding to the level for the current value.
// 
// In horizontal orientation, the nodes are always arranged from left to right,
// regardless of text direction.
	type LevelBar struct {
		Widget
		Buildable
		Orientable
		
	}

	// LevelBarClass is an interface that the LevelBar class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type LevelBarClass interface {
		gextras.Objector
		_levelBar()
	}

	func (LevelBar) _levelBar() {}

	
	func marshalLevelBar(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapLevelBar(obj), nil
	}
	

	
	// NewLevelBar creates a new LevelBar.
	func NewLevelBar() LevelBar {
var _cret *C.GtkWidget // in

_cret = C.gtk_level_bar_new()


var _levelBar LevelBar // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_levelBar = LevelBar{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _levelBar
}
	
	// NewLevelBarForInterval: utility constructor that creates a new LevelBar for
// the specified interval.
	func NewLevelBarForInterval(minValue float64, maxValue float64) LevelBar {
var _arg1 C.gdouble // out
var _arg2 C.gdouble // out
var _cret *C.GtkWidget // in

_arg1 = (C.gdouble)(minValue)
_arg2 = (C.gdouble)(maxValue)

_cret = C.gtk_level_bar_new_for_interval(_arg1, _arg2)


var _levelBar LevelBar // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_levelBar = LevelBar{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _levelBar
}
	

	
	// AddOffsetValue adds a new offset marker on @self at the position specified by
// @value. When the bar value is in the interval topped by @value (or between
// @value and LevelBar:max-value in case the offset is the last one on the bar)
// a style class named `level-`@name will be applied when rendering the level
// bar fill. If another offset marker named @name exists, its value will be
// replaced by @value.
	func (s LevelBar) AddOffsetValue(name string, value float64)  {
var _arg0 *C.GtkLevelBar // out
var _arg1 *C.gchar // out
var _arg2 C.gdouble // out

_arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.gdouble)(value)

C.gtk_level_bar_add_offset_value(_arg0, _arg1, _arg2)
}
	
	// Inverted: return the value of the LevelBar:inverted property.
	func (s LevelBar) Inverted() bool {
var _arg0 *C.GtkLevelBar // out
var _cret C.gboolean // in

_arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))

_cret = C.gtk_level_bar_get_inverted(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// MaxValue returns the value of the LevelBar:max-value property.
	func (s LevelBar) MaxValue() float64 {
var _arg0 *C.GtkLevelBar // out
var _cret C.gdouble // in

_arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))

_cret = C.gtk_level_bar_get_max_value(_arg0)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// MinValue returns the value of the LevelBar:min-value property.
	func (s LevelBar) MinValue() float64 {
var _arg0 *C.GtkLevelBar // out
var _cret C.gdouble // in

_arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))

_cret = C.gtk_level_bar_get_min_value(_arg0)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// Mode returns the value of the LevelBar:mode property.
	func (s LevelBar) Mode() LevelBarMode {
var _arg0 *C.GtkLevelBar // out
var _cret C.GtkLevelBarMode // in

_arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))

_cret = C.gtk_level_bar_get_mode(_arg0)


var _levelBarMode LevelBarMode // out

_levelBarMode = LevelBarMode(_cret)

return _levelBarMode
}
	
	// OffsetValue fetches the value specified for the offset marker @name in @self,
// returning true in case an offset named @name was found.
	func (s LevelBar) OffsetValue(name string) (float64, bool) {
var _arg0 *C.GtkLevelBar // out
var _arg1 *C.gchar // out
var _arg2 C.gdouble // in
var _cret C.gboolean // in

_arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_level_bar_get_offset_value(_arg0, _arg1, &_arg2)


var _value float64 // out
var _ok bool // out

_value = (float64)(_arg2)
if _cret != 0 { _ok = true }

return _value, _ok
}
	
	// Value returns the value of the LevelBar:value property.
	func (s LevelBar) Value() float64 {
var _arg0 *C.GtkLevelBar // out
var _cret C.gdouble // in

_arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))

_cret = C.gtk_level_bar_get_value(_arg0)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// RemoveOffsetValue removes an offset marker previously added with
// gtk_level_bar_add_offset_value().
	func (s LevelBar) RemoveOffsetValue(name string)  {
var _arg0 *C.GtkLevelBar // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_level_bar_remove_offset_value(_arg0, _arg1)
}
	
	// SetInverted sets the value of the LevelBar:inverted property.
	func (s LevelBar) SetInverted(inverted bool)  {
var _arg0 *C.GtkLevelBar // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))
if inverted { _arg1 = C.TRUE }

C.gtk_level_bar_set_inverted(_arg0, _arg1)
}
	
	// SetMaxValue sets the value of the LevelBar:max-value property.
// 
// You probably want to update preexisting level offsets after calling this
// function.
	func (s LevelBar) SetMaxValue(value float64)  {
var _arg0 *C.GtkLevelBar // out
var _arg1 C.gdouble // out

_arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))
_arg1 = (C.gdouble)(value)

C.gtk_level_bar_set_max_value(_arg0, _arg1)
}
	
	// SetMinValue sets the value of the LevelBar:min-value property.
// 
// You probably want to update preexisting level offsets after calling this
// function.
	func (s LevelBar) SetMinValue(value float64)  {
var _arg0 *C.GtkLevelBar // out
var _arg1 C.gdouble // out

_arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))
_arg1 = (C.gdouble)(value)

C.gtk_level_bar_set_min_value(_arg0, _arg1)
}
	
	// SetMode sets the value of the LevelBar:mode property.
	func (s LevelBar) SetMode(mode LevelBarMode)  {
var _arg0 *C.GtkLevelBar // out
var _arg1 C.GtkLevelBarMode // out

_arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkLevelBarMode)(mode)

C.gtk_level_bar_set_mode(_arg0, _arg1)
}
	
	// SetValue sets the value of the LevelBar:value property.
	func (s LevelBar) SetValue(value float64)  {
var _arg0 *C.GtkLevelBar // out
var _arg1 C.gdouble // out

_arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))
_arg1 = (C.gdouble)(value)

C.gtk_level_bar_set_value(_arg0, _arg1)
}
	


	// LinkButton: a GtkLinkButton is a Button with a hyperlink, similar to the one
// used by web browsers, which triggers an action when clicked. It is useful to
// show quick links to resources.
// 
// A link button is created by calling either gtk_link_button_new() or
// gtk_link_button_new_with_label(). If using the former, the URI you pass to
// the constructor is used as a label for the widget.
// 
// The URI bound to a GtkLinkButton can be set specifically using
// gtk_link_button_set_uri(), and retrieved using gtk_link_button_get_uri().
// 
// By default, GtkLinkButton calls gtk_show_uri_on_window() when the button is
// clicked. This behaviour can be overridden by connecting to the
// LinkButton::activate-link signal and returning true from the signal handler.
// 
// 
// CSS nodes
// 
// GtkLinkButton has a single CSS node with name button. To differentiate it
// from a plain Button, it gets the .link style class.
	type LinkButton struct {
		Button
		Actionable
		Activatable
		Buildable
		
	}

	// LinkButtonClass is an interface that the LinkButton class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type LinkButtonClass interface {
		gextras.Objector
		_linkButton()
	}

	func (LinkButton) _linkButton() {}

	
	func marshalLinkButton(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapLinkButton(obj), nil
	}
	

	
	// NewLinkButton creates a new LinkButton with the URI as its text.
	func NewLinkButton(uri string) LinkButton {
var _arg1 *C.gchar // out
var _cret *C.GtkWidget // in

_arg1 = (*C.gchar)(C.CString(uri))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_link_button_new(_arg1)


var _linkButton LinkButton // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_linkButton = LinkButton{
Button: Button{
Bin: Bin{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _linkButton
}
	
	// NewLinkButtonWithLabel creates a new LinkButton containing a label.
	func NewLinkButtonWithLabel(uri string, label string) LinkButton {
var _arg1 *C.gchar // out
var _arg2 *C.gchar // out
var _cret *C.GtkWidget // in

_arg1 = (*C.gchar)(C.CString(uri))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.gchar)(C.CString(label))
defer C.free(unsafe.Pointer(_arg2))

_cret = C.gtk_link_button_new_with_label(_arg1, _arg2)


var _linkButton LinkButton // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_linkButton = LinkButton{
Button: Button{
Bin: Bin{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _linkButton
}
	

	
	// URI retrieves the URI set using gtk_link_button_set_uri().
	func (l LinkButton) URI() string {
var _arg0 *C.GtkLinkButton // out
var _cret *C.gchar // in

_arg0 = (*C.GtkLinkButton)(unsafe.Pointer(l.Native()))

_cret = C.gtk_link_button_get_uri(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Visited retrieves the “visited” state of the URI where the LinkButton points.
// The button becomes visited when it is clicked. If the URI is changed on the
// button, the “visited” state is unset again.
// 
// The state may also be changed using gtk_link_button_set_visited().
	func (l LinkButton) Visited() bool {
var _arg0 *C.GtkLinkButton // out
var _cret C.gboolean // in

_arg0 = (*C.GtkLinkButton)(unsafe.Pointer(l.Native()))

_cret = C.gtk_link_button_get_visited(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetURI sets @uri as the URI where the LinkButton points. As a side-effect
// this unsets the “visited” state of the button.
	func (l LinkButton) SetURI(uri string)  {
var _arg0 *C.GtkLinkButton // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkLinkButton)(unsafe.Pointer(l.Native()))
_arg1 = (*C.gchar)(C.CString(uri))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_link_button_set_uri(_arg0, _arg1)
}
	
	// SetVisited sets the “visited” state of the URI where the LinkButton points.
// See gtk_link_button_get_visited() for more details.
	func (l LinkButton) SetVisited(visited bool)  {
var _arg0 *C.GtkLinkButton // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkLinkButton)(unsafe.Pointer(l.Native()))
if visited { _arg1 = C.TRUE }

C.gtk_link_button_set_visited(_arg0, _arg1)
}
	


	// ListBox: a GtkListBox is a vertical container that contains GtkListBoxRow
// children. These rows can by dynamically sorted and filtered, and headers can
// be added dynamically depending on the row content. It also allows keyboard
// and mouse navigation and selection like a typical list.
// 
// Using GtkListBox is often an alternative to TreeView, especially when the
// list contents has a more complicated layout than what is allowed by a
// CellRenderer, or when the contents is interactive (i.e. has a button in it).
// 
// Although a ListBox must have only ListBoxRow children you can add any kind of
// widget to it via gtk_container_add(), and a ListBoxRow widget will
// automatically be inserted between the list and the widget.
// 
// ListBoxRows can be marked as activatable or selectable. If a row is
// activatable, ListBox::row-activated will be emitted for it when the user
// tries to activate it. If it is selectable, the row will be marked as selected
// when the user tries to select it.
// 
// The GtkListBox widget was added in GTK+ 3.10.
// 
// 
// GtkListBox as GtkBuildable
// 
// The GtkListBox implementation of the Buildable interface supports setting a
// child as the placeholder by specifying “placeholder” as the “type” attribute
// of a <child> element. See gtk_list_box_set_placeholder() for info.
// 
// CSS nodes
// 
//    list
//    ╰── row[.activatable]
// 
// GtkListBox uses a single CSS node named list. Each GtkListBoxRow uses a
// single CSS node named row. The row nodes get the .activatable style class
// added when appropriate.
	type ListBox struct {
		Container
		Buildable
		
	}

	// ListBoxClass is an interface that the ListBox class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ListBoxClass interface {
		gextras.Objector
		_listBox()
	}

	func (ListBox) _listBox() {}

	
	func marshalListBox(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapListBox(obj), nil
	}
	

	
	// NewListBox creates a new ListBox container.
	func NewListBox() ListBox {
var _cret *C.GtkWidget // in

_cret = C.gtk_list_box_new()


var _listBox ListBox // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_listBox = ListBox{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _listBox
}
	

	
	// DragHighlightRow: this is a helper function for implementing DnD onto a
// ListBox. The passed in @row will be highlighted via gtk_drag_highlight(), and
// any previously highlighted row will be unhighlighted.
// 
// The row will also be unhighlighted when the widget gets a drag leave event.
	func (b ListBox) DragHighlightRow(row ListBoxRowClass)  {
var _arg0 *C.GtkListBox // out
var _arg1 *C.GtkListBoxRow // out

_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkListBoxRow)(unsafe.Pointer(row.Native()))

C.gtk_list_box_drag_highlight_row(_arg0, _arg1)
}
	
	// DragUnhighlightRow: if a row has previously been highlighted via
// gtk_list_box_drag_highlight_row() it will have the highlight removed.
	func (b ListBox) DragUnhighlightRow()  {
var _arg0 *C.GtkListBox // out

_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))

C.gtk_list_box_drag_unhighlight_row(_arg0)
}
	
	// ActivateOnSingleClick returns whether rows activate on single clicks.
	func (b ListBox) ActivateOnSingleClick() bool {
var _arg0 *C.GtkListBox // out
var _cret C.gboolean // in

_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))

_cret = C.gtk_list_box_get_activate_on_single_click(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Adjustment gets the adjustment (if any) that the widget uses to for vertical
// scrolling.
	func (b ListBox) Adjustment() Adjustment {
var _arg0 *C.GtkListBox // out
var _cret *C.GtkAdjustment // in

_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))

_cret = C.gtk_list_box_get_adjustment(_arg0)


var _adjustment Adjustment // out

_adjustment = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Adjustment)

return _adjustment
}
	
	// RowAtIndex gets the n-th child in the list (not counting headers). If @_index
// is negative or larger than the number of items in the list, nil is returned.
	func (b ListBox) RowAtIndex(index_ int) ListBoxRow {
var _arg0 *C.GtkListBox // out
var _arg1 C.gint // out
var _cret *C.GtkListBoxRow // in

_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))
_arg1 = (C.gint)(index_)

_cret = C.gtk_list_box_get_row_at_index(_arg0, _arg1)


var _listBoxRow ListBoxRow // out

_listBoxRow = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(ListBoxRow)

return _listBoxRow
}
	
	// RowAtY gets the row at the @y position.
	func (b ListBox) RowAtY(y int) ListBoxRow {
var _arg0 *C.GtkListBox // out
var _arg1 C.gint // out
var _cret *C.GtkListBoxRow // in

_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))
_arg1 = (C.gint)(y)

_cret = C.gtk_list_box_get_row_at_y(_arg0, _arg1)


var _listBoxRow ListBoxRow // out

_listBoxRow = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(ListBoxRow)

return _listBoxRow
}
	
	// SelectedRow gets the selected row.
// 
// Note that the box may allow multiple selection, in which case you should use
// gtk_list_box_selected_foreach() to find all selected rows.
	func (b ListBox) SelectedRow() ListBoxRow {
var _arg0 *C.GtkListBox // out
var _cret *C.GtkListBoxRow // in

_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))

_cret = C.gtk_list_box_get_selected_row(_arg0)


var _listBoxRow ListBoxRow // out

_listBoxRow = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(ListBoxRow)

return _listBoxRow
}
	
	// SelectionMode gets the selection mode of the listbox.
	func (b ListBox) SelectionMode() SelectionMode {
var _arg0 *C.GtkListBox // out
var _cret C.GtkSelectionMode // in

_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))

_cret = C.gtk_list_box_get_selection_mode(_arg0)


var _selectionMode SelectionMode // out

_selectionMode = SelectionMode(_cret)

return _selectionMode
}
	
	// Insert: insert the @child into the @box at @position. If a sort function is
// set, the widget will actually be inserted at the calculated position and this
// function has the same effect of gtk_container_add().
// 
// If @position is -1, or larger than the total number of items in the @box,
// then the @child will be appended to the end.
	func (b ListBox) Insert(child WidgetClass, position int)  {
var _arg0 *C.GtkListBox // out
var _arg1 *C.GtkWidget // out
var _arg2 C.gint // out

_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
_arg2 = (C.gint)(position)

C.gtk_list_box_insert(_arg0, _arg1, _arg2)
}
	
	// InvalidateFilter: update the filtering for all rows. Call this when result of
// the filter function on the @box is changed due to an external factor. For
// instance, this would be used if the filter function just looked for a
// specific search string and the entry with the search string has changed.
	func (b ListBox) InvalidateFilter()  {
var _arg0 *C.GtkListBox // out

_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))

C.gtk_list_box_invalidate_filter(_arg0)
}
	
	// InvalidateHeaders: update the separators for all rows. Call this when result
// of the header function on the @box is changed due to an external factor.
	func (b ListBox) InvalidateHeaders()  {
var _arg0 *C.GtkListBox // out

_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))

C.gtk_list_box_invalidate_headers(_arg0)
}
	
	// InvalidateSort: update the sorting for all rows. Call this when result of the
// sort function on the @box is changed due to an external factor.
	func (b ListBox) InvalidateSort()  {
var _arg0 *C.GtkListBox // out

_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))

C.gtk_list_box_invalidate_sort(_arg0)
}
	
	// Prepend: prepend a widget to the list. If a sort function is set, the widget
// will actually be inserted at the calculated position and this function has
// the same effect of gtk_container_add().
	func (b ListBox) Prepend(child WidgetClass)  {
var _arg0 *C.GtkListBox // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

C.gtk_list_box_prepend(_arg0, _arg1)
}
	
	// SelectAll: select all children of @box, if the selection mode allows it.
	func (b ListBox) SelectAll()  {
var _arg0 *C.GtkListBox // out

_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))

C.gtk_list_box_select_all(_arg0)
}
	
	// SelectRow: make @row the currently selected row.
	func (b ListBox) SelectRow(row ListBoxRowClass)  {
var _arg0 *C.GtkListBox // out
var _arg1 *C.GtkListBoxRow // out

_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkListBoxRow)(unsafe.Pointer(row.Native()))

C.gtk_list_box_select_row(_arg0, _arg1)
}
	
	// SetActivateOnSingleClick: if @single is true, rows will be activated when you
// click on them, otherwise you need to double-click.
	func (b ListBox) SetActivateOnSingleClick(single bool)  {
var _arg0 *C.GtkListBox // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))
if single { _arg1 = C.TRUE }

C.gtk_list_box_set_activate_on_single_click(_arg0, _arg1)
}
	
	// SetAdjustment sets the adjustment (if any) that the widget uses to for
// vertical scrolling. For instance, this is used to get the page size for
// PageUp/Down key handling.
// 
// In the normal case when the @box is packed inside a ScrolledWindow the
// adjustment from that will be picked up automatically, so there is no need to
// manually do that.
	func (b ListBox) SetAdjustment(adjustment AdjustmentClass)  {
var _arg0 *C.GtkListBox // out
var _arg1 *C.GtkAdjustment // out

_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(adjustment.Native()))

C.gtk_list_box_set_adjustment(_arg0, _arg1)
}
	
	// SetPlaceholder sets the placeholder widget that is shown in the list when it
// doesn't display any visible children.
	func (b ListBox) SetPlaceholder(placeholder WidgetClass)  {
var _arg0 *C.GtkListBox // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(placeholder.Native()))

C.gtk_list_box_set_placeholder(_arg0, _arg1)
}
	
	// SetSelectionMode sets how selection works in the listbox. See SelectionMode
// for details.
	func (b ListBox) SetSelectionMode(mode SelectionMode)  {
var _arg0 *C.GtkListBox // out
var _arg1 C.GtkSelectionMode // out

_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))
_arg1 = (C.GtkSelectionMode)(mode)

C.gtk_list_box_set_selection_mode(_arg0, _arg1)
}
	
	// UnselectAll: unselect all children of @box, if the selection mode allows it.
	func (b ListBox) UnselectAll()  {
var _arg0 *C.GtkListBox // out

_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))

C.gtk_list_box_unselect_all(_arg0)
}
	
	// UnselectRow unselects a single row of @box, if the selection mode allows it.
	func (b ListBox) UnselectRow(row ListBoxRowClass)  {
var _arg0 *C.GtkListBox // out
var _arg1 *C.GtkListBoxRow // out

_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkListBoxRow)(unsafe.Pointer(row.Native()))

C.gtk_list_box_unselect_row(_arg0, _arg1)
}
	


	
	type ListBoxRow struct {
		Bin
		Actionable
		Buildable
		
	}

	// ListBoxRowClass is an interface that the ListBoxRow class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ListBoxRowClass interface {
		gextras.Objector
		_listBoxRow()
	}

	func (ListBoxRow) _listBoxRow() {}

	
	func marshalListBoxRow(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapListBoxRow(obj), nil
	}
	

	
	// NewListBoxRow creates a new ListBoxRow, to be used as a child of a ListBox.
	func NewListBoxRow() ListBoxRow {
var _cret *C.GtkWidget // in

_cret = C.gtk_list_box_row_new()


var _listBoxRow ListBoxRow // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_listBoxRow = ListBoxRow{
Bin: Bin{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _listBoxRow
}
	

	
	// Changed marks @row as changed, causing any state that depends on this to be
// updated. This affects sorting, filtering and headers.
// 
// Note that calls to this method must be in sync with the data used for the row
// functions. For instance, if the list is mirroring some external data set, and
// *two* rows changed in the external data set then when you call
// gtk_list_box_row_changed() on the first row the sort function must only read
// the new data for the first of the two changed rows, otherwise the resorting
// of the rows will be wrong.
// 
// This generally means that if you don’t fully control the data model you have
// to duplicate the data that affects the listbox row functions into the row
// widgets themselves. Another alternative is to call
// gtk_list_box_invalidate_sort() on any model change, but that is more
// expensive.
	func (r ListBoxRow) Changed()  {
var _arg0 *C.GtkListBoxRow // out

_arg0 = (*C.GtkListBoxRow)(unsafe.Pointer(r.Native()))

C.gtk_list_box_row_changed(_arg0)
}
	
	// Activatable gets the value of the ListBoxRow:activatable property for this
// row.
	func (r ListBoxRow) Activatable() bool {
var _arg0 *C.GtkListBoxRow // out
var _cret C.gboolean // in

_arg0 = (*C.GtkListBoxRow)(unsafe.Pointer(r.Native()))

_cret = C.gtk_list_box_row_get_activatable(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Header returns the current header of the @row. This can be used in a
// ListBoxUpdateHeaderFunc to see if there is a header set already, and if so to
// update the state of it.
	func (r ListBoxRow) Header() Widget {
var _arg0 *C.GtkListBoxRow // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkListBoxRow)(unsafe.Pointer(r.Native()))

_cret = C.gtk_list_box_row_get_header(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// Index gets the current index of the @row in its ListBox container.
	func (r ListBoxRow) Index() int {
var _arg0 *C.GtkListBoxRow // out
var _cret C.gint // in

_arg0 = (*C.GtkListBoxRow)(unsafe.Pointer(r.Native()))

_cret = C.gtk_list_box_row_get_index(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Selectable gets the value of the ListBoxRow:selectable property for this row.
	func (r ListBoxRow) Selectable() bool {
var _arg0 *C.GtkListBoxRow // out
var _cret C.gboolean // in

_arg0 = (*C.GtkListBoxRow)(unsafe.Pointer(r.Native()))

_cret = C.gtk_list_box_row_get_selectable(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsSelected returns whether the child is currently selected in its ListBox
// container.
	func (r ListBoxRow) IsSelected() bool {
var _arg0 *C.GtkListBoxRow // out
var _cret C.gboolean // in

_arg0 = (*C.GtkListBoxRow)(unsafe.Pointer(r.Native()))

_cret = C.gtk_list_box_row_is_selected(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetActivatable: set the ListBoxRow:activatable property for this row.
	func (r ListBoxRow) SetActivatable(activatable bool)  {
var _arg0 *C.GtkListBoxRow // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkListBoxRow)(unsafe.Pointer(r.Native()))
if activatable { _arg1 = C.TRUE }

C.gtk_list_box_row_set_activatable(_arg0, _arg1)
}
	
	// SetHeader sets the current header of the @row. This is only allowed to be
// called from a ListBoxUpdateHeaderFunc. It will replace any existing header in
// the row, and be shown in front of the row in the listbox.
	func (r ListBoxRow) SetHeader(header WidgetClass)  {
var _arg0 *C.GtkListBoxRow // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkListBoxRow)(unsafe.Pointer(r.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(header.Native()))

C.gtk_list_box_row_set_header(_arg0, _arg1)
}
	
	// SetSelectable: set the ListBoxRow:selectable property for this row.
	func (r ListBoxRow) SetSelectable(selectable bool)  {
var _arg0 *C.GtkListBoxRow // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkListBoxRow)(unsafe.Pointer(r.Native()))
if selectable { _arg1 = C.TRUE }

C.gtk_list_box_row_set_selectable(_arg0, _arg1)
}
	


	// ListStore: the ListStore object is a list model for use with a TreeView
// widget. It implements the TreeModel interface, and consequentialy, can use
// all of the methods available there. It also implements the TreeSortable
// interface so it can be sorted by the view. Finally, it also implements the
// tree [drag and drop][gtk3-GtkTreeView-drag-and-drop] interfaces.
// 
// The ListStore can accept most GObject types as a column type, though it can’t
// accept all custom types. Internally, it will keep a copy of data passed in
// (such as a string or a boxed pointer). Columns that accept #GObjects are
// handled a little differently. The ListStore will keep a reference to the
// object instead of copying the value. As a result, if the object is modified,
// it is up to the application writer to call gtk_tree_model_row_changed() to
// emit the TreeModel::row_changed signal. This most commonly affects lists with
// Pixbufs stored.
// 
// An example for creating a simple list store:
// 
//    <object class="GtkListStore">
//      <columns>
//        <column type="gchararray"/>
//        <column type="gchararray"/>
//        <column type="gint"/>
//      </columns>
//      <data>
//        <row>
//          <col id="0">John</col>
//          <col id="1">Doe</col>
//          <col id="2">25</col>
//        </row>
//        <row>
//          <col id="0">Johan</col>
//          <col id="1">Dahlin</col>
//          <col id="2">50</col>
//        </row>
//      </data>
//    </object>
	type ListStore struct {
		**externglib.Object
		Buildable
		TreeDragDest
		TreeDragSource
		TreeModel
		TreeSortable
		
	}

	// ListStoreClass is an interface that the ListStore class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ListStoreClass interface {
		gextras.Objector
		_listStore()
	}

	func (ListStore) _listStore() {}

	
	func marshalListStore(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapListStore(obj), nil
	}
	

	
	// NewListStoreV: non-vararg creation function. Used primarily by language
// bindings.
	func NewListStoreV(types []externglib.Type) ListStore {
var _arg2 *C.GType
var _arg1 C.gint
var _cret *C.GtkListStore // in

_arg1 = C.gint(len(types))
_arg2 = (*C.GType)(C.malloc(C.ulong(len(types)) * C.ulong(C.sizeof_GType)))
defer C.free(unsafe.Pointer(_arg2))
{
out := unsafe.Slice(_arg2, len(types))
for i := range types {
out[i] = C.GType(types[i])
}
}

_cret = C.gtk_list_store_newv(_arg1, _arg2)


var _listStore ListStore // out

_listStore = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(ListStore)

return _listStore
}
	

	
	// Append appends a new row to @list_store. @iter will be changed to point to
// this new row. The row will be empty after this function is called. To fill in
// values, you need to call gtk_list_store_set() or gtk_list_store_set_value().
	func (l ListStore) Append() TreeIter {
var _arg0 *C.GtkListStore // out
var _iter TreeIter

_arg0 = (*C.GtkListStore)(unsafe.Pointer(l.Native()))

C.gtk_list_store_append(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_iter)))





return _iter
}
	
	// Clear removes all rows from the list store.
	func (l ListStore) Clear()  {
var _arg0 *C.GtkListStore // out

_arg0 = (*C.GtkListStore)(unsafe.Pointer(l.Native()))

C.gtk_list_store_clear(_arg0)
}
	
	// Insert creates a new row at @position. @iter will be changed to point to this
// new row. If @position is -1 or is larger than the number of rows on the list,
// then the new row will be appended to the list. The row will be empty after
// this function is called. To fill in values, you need to call
// gtk_list_store_set() or gtk_list_store_set_value().
	func (l ListStore) Insert(position int) TreeIter {
var _arg0 *C.GtkListStore // out
var _iter TreeIter
var _arg2 C.gint // out

_arg0 = (*C.GtkListStore)(unsafe.Pointer(l.Native()))
_arg2 = (C.gint)(position)

C.gtk_list_store_insert(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_iter)), _arg2)





return _iter
}
	
	// InsertAfter inserts a new row after @sibling. If @sibling is nil, then the
// row will be prepended to the beginning of the list. @iter will be changed to
// point to this new row. The row will be empty after this function is called.
// To fill in values, you need to call gtk_list_store_set() or
// gtk_list_store_set_value().
	func (l ListStore) InsertAfter(sibling *TreeIter) TreeIter {
var _arg0 *C.GtkListStore // out
var _iter TreeIter
var _arg2 *C.GtkTreeIter // out

_arg0 = (*C.GtkListStore)(unsafe.Pointer(l.Native()))
_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(sibling.Native()))

C.gtk_list_store_insert_after(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_iter)), _arg2)





return _iter
}
	
	// InsertBefore inserts a new row before @sibling. If @sibling is nil, then the
// row will be appended to the end of the list. @iter will be changed to point
// to this new row. The row will be empty after this function is called. To fill
// in values, you need to call gtk_list_store_set() or
// gtk_list_store_set_value().
	func (l ListStore) InsertBefore(sibling *TreeIter) TreeIter {
var _arg0 *C.GtkListStore // out
var _iter TreeIter
var _arg2 *C.GtkTreeIter // out

_arg0 = (*C.GtkListStore)(unsafe.Pointer(l.Native()))
_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(sibling.Native()))

C.gtk_list_store_insert_before(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_iter)), _arg2)





return _iter
}
	
	// InsertWithValuesv: a variant of gtk_list_store_insert_with_values() which
// takes the columns and values as two arrays, instead of varargs. This function
// is mainly intended for language-bindings.
	func (l ListStore) InsertWithValuesv(position int, columns []int, values []**externglib.Value) TreeIter {
var _arg0 *C.GtkListStore // out
var _iter TreeIter
var _arg2 C.gint // out
var _arg3 *C.gint
var _arg5 C.gint
var _arg4 *C.GValue
var _arg5 C.gint

_arg0 = (*C.GtkListStore)(unsafe.Pointer(l.Native()))
_arg2 = (C.gint)(position)
_arg5 = C.gint(len(columns))
_arg3 = (*C.gint)(unsafe.Pointer(&columns[0]))
_arg5 = C.gint(len(values))
_arg4 = (*C.GValue)(C.malloc(C.ulong(len(values)) * C.ulong(C.sizeof_GValue)))
defer C.free(unsafe.Pointer(_arg4))
{
out := unsafe.Slice(_arg4, len(values))
for i := range values {
out[i] = (*C.GValue)(values[i].GValue)
}
}

C.gtk_list_store_insert_with_valuesv(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_iter)), _arg2, _arg3, _arg4, _arg5)





return _iter
}
	
	// IterIsValid: > This function is slow. Only use it for debugging and/or
// testing > purposes.
// 
// Checks if the given iter is a valid iter for this ListStore.
	func (l ListStore) IterIsValid(iter *TreeIter) bool {
var _arg0 *C.GtkListStore // out
var _arg1 *C.GtkTreeIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkListStore)(unsafe.Pointer(l.Native()))
_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

_cret = C.gtk_list_store_iter_is_valid(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// MoveAfter moves @iter in @store to the position after @position. Note that
// this function only works with unsorted stores. If @position is nil, @iter
// will be moved to the start of the list.
	func (s ListStore) MoveAfter(iter *TreeIter, position *TreeIter)  {
var _arg0 *C.GtkListStore // out
var _arg1 *C.GtkTreeIter // out
var _arg2 *C.GtkTreeIter // out

_arg0 = (*C.GtkListStore)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))
_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(position.Native()))

C.gtk_list_store_move_after(_arg0, _arg1, _arg2)
}
	
	// MoveBefore moves @iter in @store to the position before @position. Note that
// this function only works with unsorted stores. If @position is nil, @iter
// will be moved to the end of the list.
	func (s ListStore) MoveBefore(iter *TreeIter, position *TreeIter)  {
var _arg0 *C.GtkListStore // out
var _arg1 *C.GtkTreeIter // out
var _arg2 *C.GtkTreeIter // out

_arg0 = (*C.GtkListStore)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))
_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(position.Native()))

C.gtk_list_store_move_before(_arg0, _arg1, _arg2)
}
	
	// Prepend prepends a new row to @list_store. @iter will be changed to point to
// this new row. The row will be empty after this function is called. To fill in
// values, you need to call gtk_list_store_set() or gtk_list_store_set_value().
	func (l ListStore) Prepend() TreeIter {
var _arg0 *C.GtkListStore // out
var _iter TreeIter

_arg0 = (*C.GtkListStore)(unsafe.Pointer(l.Native()))

C.gtk_list_store_prepend(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_iter)))





return _iter
}
	
	// Remove removes the given row from the list store. After being removed, @iter
// is set to be the next valid row, or invalidated if it pointed to the last row
// in @list_store.
	func (l ListStore) Remove(iter *TreeIter) bool {
var _arg0 *C.GtkListStore // out
var _arg1 *C.GtkTreeIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkListStore)(unsafe.Pointer(l.Native()))
_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

_cret = C.gtk_list_store_remove(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Reorder reorders @store to follow the order indicated by @new_order. Note
// that this function only works with unsorted stores.
	func (s ListStore) Reorder(newOrder []int)  {
var _arg0 *C.GtkListStore // out
var _arg1 *C.gint

_arg0 = (*C.GtkListStore)(unsafe.Pointer(s.Native()))
{
var zero int
newOrder = append(newOrder, zero)
}
_arg1 = (*C.gint)(unsafe.Pointer(&newOrder[0]))

C.gtk_list_store_reorder(_arg0, _arg1)
}
	
	// SetColumnTypes: this function is meant primarily for #GObjects that inherit
// from ListStore, and should only be used when constructing a new ListStore. It
// will not function after a row has been added, or a method on the TreeModel
// interface is called.
	func (l ListStore) SetColumnTypes(types []externglib.Type)  {
var _arg0 *C.GtkListStore // out
var _arg2 *C.GType
var _arg1 C.gint

_arg0 = (*C.GtkListStore)(unsafe.Pointer(l.Native()))
_arg1 = C.gint(len(types))
_arg2 = (*C.GType)(C.malloc(C.ulong(len(types)) * C.ulong(C.sizeof_GType)))
defer C.free(unsafe.Pointer(_arg2))
{
out := unsafe.Slice(_arg2, len(types))
for i := range types {
out[i] = C.GType(types[i])
}
}

C.gtk_list_store_set_column_types(_arg0, _arg1, _arg2)
}
	
	// SetValue sets the data in the cell specified by @iter and @column. The type
// of @value must be convertible to the type of the column.
	func (l ListStore) SetValue(iter *TreeIter, column int, value **externglib.Value)  {
var _arg0 *C.GtkListStore // out
var _arg1 *C.GtkTreeIter // out
var _arg2 C.gint // out
var _arg3 *C.GValue // out

_arg0 = (*C.GtkListStore)(unsafe.Pointer(l.Native()))
_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))
_arg2 = (C.gint)(column)
_arg3 = (*C.GValue)(value.GValue)

C.gtk_list_store_set_value(_arg0, _arg1, _arg2, _arg3)
}
	
	// SetValuesv: a variant of gtk_list_store_set_valist() which takes the columns
// and values as two arrays, instead of varargs. This function is mainly
// intended for language-bindings and in case the number of columns to change is
// not known until run-time.
	func (l ListStore) SetValuesv(iter *TreeIter, columns []int, values []**externglib.Value)  {
var _arg0 *C.GtkListStore // out
var _arg1 *C.GtkTreeIter // out
var _arg2 *C.gint
var _arg4 C.gint
var _arg3 *C.GValue
var _arg4 C.gint

_arg0 = (*C.GtkListStore)(unsafe.Pointer(l.Native()))
_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))
_arg4 = C.gint(len(columns))
_arg2 = (*C.gint)(unsafe.Pointer(&columns[0]))
_arg4 = C.gint(len(values))
_arg3 = (*C.GValue)(C.malloc(C.ulong(len(values)) * C.ulong(C.sizeof_GValue)))
defer C.free(unsafe.Pointer(_arg3))
{
out := unsafe.Slice(_arg3, len(values))
for i := range values {
out[i] = (*C.GValue)(values[i].GValue)
}
}

C.gtk_list_store_set_valuesv(_arg0, _arg1, _arg2, _arg3, _arg4)
}
	
	// Swap swaps @a and @b in @store. Note that this function only works with
// unsorted stores.
	func (s ListStore) Swap(a *TreeIter, b *TreeIter)  {
var _arg0 *C.GtkListStore // out
var _arg1 *C.GtkTreeIter // out
var _arg2 *C.GtkTreeIter // out

_arg0 = (*C.GtkListStore)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(a.Native()))
_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(b.Native()))

C.gtk_list_store_swap(_arg0, _arg1, _arg2)
}
	


	// LockButton: gtkLockButton is a widget that can be used in control panels or
// preference dialogs to allow users to obtain and revoke authorizations needed
// to operate the controls. The required authorization is represented by a
// #GPermission object. Concrete implementations of #GPermission may use
// PolicyKit or some other authorization framework. To obtain a PolicyKit-based
// #GPermission, use polkit_permission_new().
// 
// If the user is not currently allowed to perform the action, but can obtain
// the permission, the widget looks like this:
// 
// ! (lockbutton-locked.png)
// 
// and the user can click the button to request the permission. Depending on the
// platform, this may pop up an authentication dialog or ask the user to
// authenticate in some other way. Once the user has obtained the permission,
// the widget changes to this:
// 
// ! (lockbutton-unlocked.png)
// 
// and the permission can be dropped again by clicking the button. If the user
// is not able to obtain the permission at all, the widget looks like this:
// 
// ! (lockbutton-sorry.png)
// 
// If the user has the permission and cannot drop it, the button is hidden.
// 
// The text (and tooltips) that are shown in the various cases can be adjusted
// with the LockButton:text-lock, LockButton:text-unlock,
// LockButton:tooltip-lock, LockButton:tooltip-unlock and
// LockButton:tooltip-not-authorized properties.
	type LockButton struct {
		Button
		Actionable
		Activatable
		Buildable
		
	}

	// LockButtonClass is an interface that the LockButton class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type LockButtonClass interface {
		gextras.Objector
		_lockButton()
	}

	func (LockButton) _lockButton() {}

	
	func marshalLockButton(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapLockButton(obj), nil
	}
	

	
	// NewLockButton creates a new lock button which reflects the @permission.
	func NewLockButton(permission gio.PermissionClass) LockButton {
var _arg1 *C.GPermission // out
var _cret *C.GtkWidget // in

_arg1 = (*C.GPermission)(unsafe.Pointer(permission.Native()))

_cret = C.gtk_lock_button_new(_arg1)


var _lockButton LockButton // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_lockButton = LockButton{
Button: Button{
Bin: Bin{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _lockButton
}
	

	
	// Permission obtains the #GPermission object that controls @button.
	func (b LockButton) Permission() gio.Permission {
var _arg0 *C.GtkLockButton // out
var _cret *C.GPermission // in

_arg0 = (*C.GtkLockButton)(unsafe.Pointer(b.Native()))

_cret = C.gtk_lock_button_get_permission(_arg0)


var _permission gio.Permission // out

_permission = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.Permission)

return _permission
}
	
	// SetPermission sets the #GPermission object that controls @button.
	func (b LockButton) SetPermission(permission gio.PermissionClass)  {
var _arg0 *C.GtkLockButton // out
var _arg1 *C.GPermission // out

_arg0 = (*C.GtkLockButton)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GPermission)(unsafe.Pointer(permission.Native()))

C.gtk_lock_button_set_permission(_arg0, _arg1)
}
	


	// Menu: a Menu is a MenuShell that implements a drop down menu consisting of a
// list of MenuItem objects which can be navigated and activated by the user to
// perform application functions.
// 
// A Menu is most commonly dropped down by activating a MenuItem in a MenuBar or
// popped up by activating a MenuItem in another Menu.
// 
// A Menu can also be popped up by activating a ComboBox. Other composite
// widgets such as the Notebook can pop up a Menu as well.
// 
// Applications can display a Menu as a popup menu by calling the
// gtk_menu_popup() function. The example below shows how an application can pop
// up a menu when the 3rd mouse button is pressed.
// 
// Connecting the popup signal handler.
// 
//    menu
//    ├── arrow.top
//    ├── <child>
//    ┊
//    ├── <child>
//    ╰── arrow.bottom
// 
// The main CSS node of GtkMenu has name menu, and there are two subnodes with
// name arrow, for scrolling menu arrows. These subnodes get the .top and
// .bottom style classes.
	type Menu struct {
		MenuShell
		Buildable
		
	}

	// MenuClass is an interface that the Menu class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type MenuClass interface {
		gextras.Objector
		_menu()
	}

	func (Menu) _menu() {}

	
	func marshalMenu(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapMenu(obj), nil
	}
	

	
	// NewMenu creates a new Menu
	func NewMenu() Menu {
var _cret *C.GtkWidget // in

_cret = C.gtk_menu_new()


var _menu Menu // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_menu = Menu{
MenuShell: MenuShell{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _menu
}
	
	// NewMenuFromModel creates a Menu and populates it with menu items and submenus
// according to @model.
// 
// The created menu items are connected to actions found in the
// ApplicationWindow to which the menu belongs - typically by means of being
// attached to a widget (see gtk_menu_attach_to_widget()) that is contained
// within the ApplicationWindows widget hierarchy.
// 
// Actions can also be added using gtk_widget_insert_action_group() on the
// menu's attach widget or on any of its parent widgets.
	func NewMenuFromModel(model gio.MenuModelClass) Menu {
var _arg1 *C.GMenuModel // out
var _cret *C.GtkWidget // in

_arg1 = (*C.GMenuModel)(unsafe.Pointer(model.Native()))

_cret = C.gtk_menu_new_from_model(_arg1)


var _menu Menu // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_menu = Menu{
MenuShell: MenuShell{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _menu
}
	

	
	// Attach adds a new MenuItem to a (table) menu. The number of “cells” that an
// item will occupy is specified by @left_attach, @right_attach, @top_attach and
// @bottom_attach. These each represent the leftmost, rightmost, uppermost and
// lower column and row numbers of the table. (Columns and rows are indexed from
// zero).
// 
// Note that this function is not related to gtk_menu_detach().
	func (m Menu) Attach(child WidgetClass, leftAttach uint, rightAttach uint, topAttach uint, bottomAttach uint)  {
var _arg0 *C.GtkMenu // out
var _arg1 *C.GtkWidget // out
var _arg2 C.guint // out
var _arg3 C.guint // out
var _arg4 C.guint // out
var _arg5 C.guint // out

_arg0 = (*C.GtkMenu)(unsafe.Pointer(m.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
_arg2 = (C.guint)(leftAttach)
_arg3 = (C.guint)(rightAttach)
_arg4 = (C.guint)(topAttach)
_arg5 = (C.guint)(bottomAttach)

C.gtk_menu_attach(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
}
	
	// Detach detaches the menu from the widget to which it had been attached. This
// function will call the callback function, @detacher, provided when the
// gtk_menu_attach_to_widget() function was called.
	func (m Menu) Detach()  {
var _arg0 *C.GtkMenu // out

_arg0 = (*C.GtkMenu)(unsafe.Pointer(m.Native()))

C.gtk_menu_detach(_arg0)
}
	
	// AccelGroup gets the AccelGroup which holds global accelerators for the menu.
// See gtk_menu_set_accel_group().
	func (m Menu) AccelGroup() AccelGroup {
var _arg0 *C.GtkMenu // out
var _cret *C.GtkAccelGroup // in

_arg0 = (*C.GtkMenu)(unsafe.Pointer(m.Native()))

_cret = C.gtk_menu_get_accel_group(_arg0)


var _accelGroup AccelGroup // out

_accelGroup = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(AccelGroup)

return _accelGroup
}
	
	// AccelPath retrieves the accelerator path set on the menu.
	func (m Menu) AccelPath() string {
var _arg0 *C.GtkMenu // out
var _cret *C.gchar // in

_arg0 = (*C.GtkMenu)(unsafe.Pointer(m.Native()))

_cret = C.gtk_menu_get_accel_path(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Active returns the selected menu item from the menu. This is used by the
// ComboBox.
	func (m Menu) Active() Widget {
var _arg0 *C.GtkMenu // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkMenu)(unsafe.Pointer(m.Native()))

_cret = C.gtk_menu_get_active(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// AttachWidget returns the Widget that the menu is attached to.
	func (m Menu) AttachWidget() Widget {
var _arg0 *C.GtkMenu // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkMenu)(unsafe.Pointer(m.Native()))

_cret = C.gtk_menu_get_attach_widget(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// Monitor retrieves the number of the monitor on which to show the menu.
	func (m Menu) Monitor() int {
var _arg0 *C.GtkMenu // out
var _cret C.gint // in

_arg0 = (*C.GtkMenu)(unsafe.Pointer(m.Native()))

_cret = C.gtk_menu_get_monitor(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// ReserveToggleSize returns whether the menu reserves space for toggles and
// icons, regardless of their actual presence.
	func (m Menu) ReserveToggleSize() bool {
var _arg0 *C.GtkMenu // out
var _cret C.gboolean // in

_arg0 = (*C.GtkMenu)(unsafe.Pointer(m.Native()))

_cret = C.gtk_menu_get_reserve_toggle_size(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// TearoffState returns whether the menu is torn off. See
// gtk_menu_set_tearoff_state().
	func (m Menu) TearoffState() bool {
var _arg0 *C.GtkMenu // out
var _cret C.gboolean // in

_arg0 = (*C.GtkMenu)(unsafe.Pointer(m.Native()))

_cret = C.gtk_menu_get_tearoff_state(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Title returns the title of the menu. See gtk_menu_set_title().
	func (m Menu) Title() string {
var _arg0 *C.GtkMenu // out
var _cret *C.gchar // in

_arg0 = (*C.GtkMenu)(unsafe.Pointer(m.Native()))

_cret = C.gtk_menu_get_title(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// PlaceOnMonitor places @menu on the given monitor.
	func (m Menu) PlaceOnMonitor(monitor gdk.MonitorClass)  {
var _arg0 *C.GtkMenu // out
var _arg1 *C.GdkMonitor // out

_arg0 = (*C.GtkMenu)(unsafe.Pointer(m.Native()))
_arg1 = (*C.GdkMonitor)(unsafe.Pointer(monitor.Native()))

C.gtk_menu_place_on_monitor(_arg0, _arg1)
}
	
	// Popdown removes the menu from the screen.
	func (m Menu) Popdown()  {
var _arg0 *C.GtkMenu // out

_arg0 = (*C.GtkMenu)(unsafe.Pointer(m.Native()))

C.gtk_menu_popdown(_arg0)
}
	
	// ReorderChild moves @child to a new @position in the list of @menu children.
	func (m Menu) ReorderChild(child WidgetClass, position int)  {
var _arg0 *C.GtkMenu // out
var _arg1 *C.GtkWidget // out
var _arg2 C.gint // out

_arg0 = (*C.GtkMenu)(unsafe.Pointer(m.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
_arg2 = (C.gint)(position)

C.gtk_menu_reorder_child(_arg0, _arg1, _arg2)
}
	
	// Reposition repositions the menu according to its position function.
	func (m Menu) Reposition()  {
var _arg0 *C.GtkMenu // out

_arg0 = (*C.GtkMenu)(unsafe.Pointer(m.Native()))

C.gtk_menu_reposition(_arg0)
}
	
	// SetAccelGroup: set the AccelGroup which holds global accelerators for the
// menu. This accelerator group needs to also be added to all windows that this
// menu is being used in with gtk_window_add_accel_group(), in order for those
// windows to support all the accelerators contained in this group.
	func (m Menu) SetAccelGroup(accelGroup AccelGroupClass)  {
var _arg0 *C.GtkMenu // out
var _arg1 *C.GtkAccelGroup // out

_arg0 = (*C.GtkMenu)(unsafe.Pointer(m.Native()))
_arg1 = (*C.GtkAccelGroup)(unsafe.Pointer(accelGroup.Native()))

C.gtk_menu_set_accel_group(_arg0, _arg1)
}
	
	// SetAccelPath sets an accelerator path for this menu from which accelerator
// paths for its immediate children, its menu items, can be constructed. The
// main purpose of this function is to spare the programmer the inconvenience of
// having to call gtk_menu_item_set_accel_path() on each menu item that should
// support runtime user changable accelerators. Instead, by just calling
// gtk_menu_set_accel_path() on their parent, each menu item of this menu, that
// contains a label describing its purpose, automatically gets an accel path
// assigned.
// 
// For example, a menu containing menu items “New” and “Exit”, will, after
// `gtk_menu_set_accel_path (menu, "<Gnumeric-Sheet>/File");` has been called,
// assign its items the accel paths: `"<Gnumeric-Sheet>/File/New"` and
// `"<Gnumeric-Sheet>/File/Exit"`.
// 
// Assigning accel paths to menu items then enables the user to change their
// accelerators at runtime. More details about accelerator paths and their
// default setups can be found at gtk_accel_map_add_entry().
// 
// Note that @accel_path string will be stored in a #GQuark. Therefore, if you
// pass a static string, you can save some memory by interning it first with
// g_intern_static_string().
	func (m Menu) SetAccelPath(accelPath string)  {
var _arg0 *C.GtkMenu // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkMenu)(unsafe.Pointer(m.Native()))
_arg1 = (*C.gchar)(C.CString(accelPath))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_menu_set_accel_path(_arg0, _arg1)
}
	
	// SetActive selects the specified menu item within the menu. This is used by
// the ComboBox and should not be used by anyone else.
	func (m Menu) SetActive(index uint)  {
var _arg0 *C.GtkMenu // out
var _arg1 C.guint // out

_arg0 = (*C.GtkMenu)(unsafe.Pointer(m.Native()))
_arg1 = (C.guint)(index)

C.gtk_menu_set_active(_arg0, _arg1)
}
	
	// SetMonitor informs GTK+ on which monitor a menu should be popped up. See
// gdk_monitor_get_geometry().
// 
// This function should be called from a MenuPositionFunc if the menu should not
// appear on the same monitor as the pointer. This information can’t be reliably
// inferred from the coordinates returned by a MenuPositionFunc, since, for very
// long menus, these coordinates may extend beyond the monitor boundaries or
// even the screen boundaries.
	func (m Menu) SetMonitor(monitorNum int)  {
var _arg0 *C.GtkMenu // out
var _arg1 C.gint // out

_arg0 = (*C.GtkMenu)(unsafe.Pointer(m.Native()))
_arg1 = (C.gint)(monitorNum)

C.gtk_menu_set_monitor(_arg0, _arg1)
}
	
	// SetReserveToggleSize sets whether the menu should reserve space for drawing
// toggles or icons, regardless of their actual presence.
	func (m Menu) SetReserveToggleSize(reserveToggleSize bool)  {
var _arg0 *C.GtkMenu // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkMenu)(unsafe.Pointer(m.Native()))
if reserveToggleSize { _arg1 = C.TRUE }

C.gtk_menu_set_reserve_toggle_size(_arg0, _arg1)
}
	
	// SetScreen sets the Screen on which the menu will be displayed.
	func (m Menu) SetScreen(screen gdk.ScreenClass)  {
var _arg0 *C.GtkMenu // out
var _arg1 *C.GdkScreen // out

_arg0 = (*C.GtkMenu)(unsafe.Pointer(m.Native()))
_arg1 = (*C.GdkScreen)(unsafe.Pointer(screen.Native()))

C.gtk_menu_set_screen(_arg0, _arg1)
}
	
	// SetTearoffState changes the tearoff state of the menu. A menu is normally
// displayed as drop down menu which persists as long as the menu is active. It
// can also be displayed as a tearoff menu which persists until it is closed or
// reattached.
	func (m Menu) SetTearoffState(tornOff bool)  {
var _arg0 *C.GtkMenu // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkMenu)(unsafe.Pointer(m.Native()))
if tornOff { _arg1 = C.TRUE }

C.gtk_menu_set_tearoff_state(_arg0, _arg1)
}
	
	// SetTitle sets the title string for the menu.
// 
// The title is displayed when the menu is shown as a tearoff menu. If @title is
// nil, the menu will see if it is attached to a parent menu item, and if so it
// will try to use the same text as that menu item’s label.
	func (m Menu) SetTitle(title string)  {
var _arg0 *C.GtkMenu // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkMenu)(unsafe.Pointer(m.Native()))
_arg1 = (*C.gchar)(C.CString(title))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_menu_set_title(_arg0, _arg1)
}
	


	// MenuBar: the MenuBar is a subclass of MenuShell which contains one or more
// MenuItems. The result is a standard menu bar which can hold many menu items.
// 
// 
// CSS nodes
// 
// GtkMenuBar has a single CSS node with name menubar.
	type MenuBar struct {
		MenuShell
		Buildable
		
	}

	// MenuBarClass is an interface that the MenuBar class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type MenuBarClass interface {
		gextras.Objector
		_menuBar()
	}

	func (MenuBar) _menuBar() {}

	
	func marshalMenuBar(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapMenuBar(obj), nil
	}
	

	
	// NewMenuBar creates a new MenuBar
	func NewMenuBar() MenuBar {
var _cret *C.GtkWidget // in

_cret = C.gtk_menu_bar_new()


var _menuBar MenuBar // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_menuBar = MenuBar{
MenuShell: MenuShell{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _menuBar
}
	
	// NewMenuBarFromModel creates a new MenuBar and populates it with menu items
// and submenus according to @model.
// 
// The created menu items are connected to actions found in the
// ApplicationWindow to which the menu bar belongs - typically by means of being
// contained within the ApplicationWindows widget hierarchy.
	func NewMenuBarFromModel(model gio.MenuModelClass) MenuBar {
var _arg1 *C.GMenuModel // out
var _cret *C.GtkWidget // in

_arg1 = (*C.GMenuModel)(unsafe.Pointer(model.Native()))

_cret = C.gtk_menu_bar_new_from_model(_arg1)


var _menuBar MenuBar // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_menuBar = MenuBar{
MenuShell: MenuShell{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _menuBar
}
	

	
	// ChildPackDirection retrieves the current child pack direction of the menubar.
// See gtk_menu_bar_set_child_pack_direction().
	func (m MenuBar) ChildPackDirection() PackDirection {
var _arg0 *C.GtkMenuBar // out
var _cret C.GtkPackDirection // in

_arg0 = (*C.GtkMenuBar)(unsafe.Pointer(m.Native()))

_cret = C.gtk_menu_bar_get_child_pack_direction(_arg0)


var _packDirection PackDirection // out

_packDirection = PackDirection(_cret)

return _packDirection
}
	
	// PackDirection retrieves the current pack direction of the menubar. See
// gtk_menu_bar_set_pack_direction().
	func (m MenuBar) PackDirection() PackDirection {
var _arg0 *C.GtkMenuBar // out
var _cret C.GtkPackDirection // in

_arg0 = (*C.GtkMenuBar)(unsafe.Pointer(m.Native()))

_cret = C.gtk_menu_bar_get_pack_direction(_arg0)


var _packDirection PackDirection // out

_packDirection = PackDirection(_cret)

return _packDirection
}
	
	// SetChildPackDirection sets how widgets should be packed inside the children
// of a menubar.
	func (m MenuBar) SetChildPackDirection(childPackDir PackDirection)  {
var _arg0 *C.GtkMenuBar // out
var _arg1 C.GtkPackDirection // out

_arg0 = (*C.GtkMenuBar)(unsafe.Pointer(m.Native()))
_arg1 = (C.GtkPackDirection)(childPackDir)

C.gtk_menu_bar_set_child_pack_direction(_arg0, _arg1)
}
	
	// SetPackDirection sets how items should be packed inside a menubar.
	func (m MenuBar) SetPackDirection(packDir PackDirection)  {
var _arg0 *C.GtkMenuBar // out
var _arg1 C.GtkPackDirection // out

_arg0 = (*C.GtkMenuBar)(unsafe.Pointer(m.Native()))
_arg1 = (C.GtkPackDirection)(packDir)

C.gtk_menu_bar_set_pack_direction(_arg0, _arg1)
}
	


	// MenuButton: the MenuButton widget is used to display a popup when clicked on.
// This popup can be provided either as a Menu, a Popover or an abstract Model.
// 
// The MenuButton widget can hold any valid child widget. That is, it can hold
// almost any other standard Widget. The most commonly used child is Image. If
// no widget is explicitely added to the MenuButton, a Image is automatically
// created, using an arrow image oriented according to MenuButton:direction or
// the generic “open-menu-symbolic” icon if the direction is not set.
// 
// The positioning of the popup is determined by the MenuButton:direction
// property of the menu button.
// 
// For menus, the Widget:halign and Widget:valign properties of the menu are
// also taken into account. For example, when the direction is GTK_ARROW_DOWN
// and the horizontal alignment is GTK_ALIGN_START, the menu will be positioned
// below the button, with the starting edge (depending on the text direction) of
// the menu aligned with the starting edge of the button. If there is not enough
// space below the button, the menu is popped up above the button instead. If
// the alignment would move part of the menu offscreen, it is “pushed in”.
// 
// Direction = Down
// 
// - halign = start
// 
//    ! (down-start.png)
// 
// - halign = center
// 
//    ! (down-center.png)
// 
// - halign = end
// 
//    ! (down-end.png)
// 
// Direction = Up
// 
// - halign = start
// 
//    ! (up-start.png)
// 
// - halign = center
// 
//    ! (up-center.png)
// 
// - halign = end
// 
//    ! (up-end.png)
// 
// Direction = Left
// 
// - valign = start
// 
//    ! (left-start.png)
// 
// - valign = center
// 
//    ! (left-center.png)
// 
// - valign = end
// 
//    ! (left-end.png)
// 
// Direction = Right
// 
// - valign = start
// 
//    ! (right-start.png)
// 
// - valign = center
// 
//    ! (right-center.png)
// 
// - valign = end
// 
//    ! (right-end.png)
// 
// 
// CSS nodes
// 
// GtkMenuButton has a single CSS node with name button. To differentiate it
// from a plain Button, it gets the .popup style class.
	type MenuButton struct {
		ToggleButton
		Actionable
		Activatable
		Buildable
		
	}

	// MenuButtonClass is an interface that the MenuButton class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type MenuButtonClass interface {
		gextras.Objector
		_menuButton()
	}

	func (MenuButton) _menuButton() {}

	
	func marshalMenuButton(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapMenuButton(obj), nil
	}
	

	
	// NewMenuButton creates a new MenuButton widget with downwards-pointing arrow
// as the only child. You can replace the child widget with another Widget
// should you wish to.
	func NewMenuButton() MenuButton {
var _cret *C.GtkWidget // in

_cret = C.gtk_menu_button_new()


var _menuButton MenuButton // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_menuButton = MenuButton{
ToggleButton: ToggleButton{
Button: Button{
Bin: Bin{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _menuButton
}
	

	
	// AlignWidget returns the parent Widget to use to line up with menu.
	func (m MenuButton) AlignWidget() Widget {
var _arg0 *C.GtkMenuButton // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))

_cret = C.gtk_menu_button_get_align_widget(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// Direction returns the direction the popup will be pointing at when popped up.
	func (m MenuButton) Direction() ArrowType {
var _arg0 *C.GtkMenuButton // out
var _cret C.GtkArrowType // in

_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))

_cret = C.gtk_menu_button_get_direction(_arg0)


var _arrowType ArrowType // out

_arrowType = ArrowType(_cret)

return _arrowType
}
	
	// MenuModel returns the Model used to generate the popup.
	func (m MenuButton) MenuModel() gio.MenuModel {
var _arg0 *C.GtkMenuButton // out
var _cret *C.GMenuModel // in

_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))

_cret = C.gtk_menu_button_get_menu_model(_arg0)


var _menuModel gio.MenuModel // out

_menuModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.MenuModel)

return _menuModel
}
	
	// Popover returns the Popover that pops out of the button. If the button is not
// using a Popover, this function returns nil.
	func (m MenuButton) Popover() Popover {
var _arg0 *C.GtkMenuButton // out
var _cret *C.GtkPopover // in

_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))

_cret = C.gtk_menu_button_get_popover(_arg0)


var _popover Popover // out

_popover = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Popover)

return _popover
}
	
	// Popup returns the Menu that pops out of the button. If the button does not
// use a Menu, this function returns nil.
	func (m MenuButton) Popup() Menu {
var _arg0 *C.GtkMenuButton // out
var _cret *C.GtkMenu // in

_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))

_cret = C.gtk_menu_button_get_popup(_arg0)


var _menu Menu // out

_menu = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Menu)

return _menu
}
	
	// UsePopover returns whether a Popover or a Menu will be constructed from the
// menu model.
	func (m MenuButton) UsePopover() bool {
var _arg0 *C.GtkMenuButton // out
var _cret C.gboolean // in

_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))

_cret = C.gtk_menu_button_get_use_popover(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetAlignWidget sets the Widget to use to line the menu with when popped up.
// Note that the @align_widget must contain the MenuButton itself.
// 
// Setting it to nil means that the menu will be aligned with the button itself.
// 
// Note that this property is only used with menus currently, and not for
// popovers.
	func (m MenuButton) SetAlignWidget(alignWidget WidgetClass)  {
var _arg0 *C.GtkMenuButton // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(alignWidget.Native()))

C.gtk_menu_button_set_align_widget(_arg0, _arg1)
}
	
	// SetDirection sets the direction in which the popup will be popped up, as well
// as changing the arrow’s direction. The child will not be changed to an arrow
// if it was customized.
// 
// If the does not fit in the available space in the given direction, GTK+ will
// its best to keep it inside the screen and fully visible.
// 
// If you pass GTK_ARROW_NONE for a @direction, the popup will behave as if you
// passed GTK_ARROW_DOWN (although you won’t see any arrows).
	func (m MenuButton) SetDirection(direction ArrowType)  {
var _arg0 *C.GtkMenuButton // out
var _arg1 C.GtkArrowType // out

_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))
_arg1 = (C.GtkArrowType)(direction)

C.gtk_menu_button_set_direction(_arg0, _arg1)
}
	
	// SetMenuModel sets the Model from which the popup will be constructed, or nil
// to dissociate any existing menu model and disable the button.
// 
// Depending on the value of MenuButton:use-popover, either a Menu will be
// created with gtk_menu_new_from_model(), or a Popover with
// gtk_popover_new_from_model(). In either case, actions will be connected as
// documented for these functions.
// 
// If MenuButton:popup or MenuButton:popover are already set, those widgets are
// dissociated from the @menu_button, and those properties are set to nil.
	func (m MenuButton) SetMenuModel(menuModel gio.MenuModelClass)  {
var _arg0 *C.GtkMenuButton // out
var _arg1 *C.GMenuModel // out

_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))
_arg1 = (*C.GMenuModel)(unsafe.Pointer(menuModel.Native()))

C.gtk_menu_button_set_menu_model(_arg0, _arg1)
}
	
	// SetPopover sets the Popover that will be popped up when the @menu_button is
// clicked, or nil to dissociate any existing popover and disable the button.
// 
// If MenuButton:menu-model or MenuButton:popup are set, those objects are
// dissociated from the @menu_button, and those properties are set to nil.
	func (m MenuButton) SetPopover(popover WidgetClass)  {
var _arg0 *C.GtkMenuButton // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(popover.Native()))

C.gtk_menu_button_set_popover(_arg0, _arg1)
}
	
	// SetPopup sets the Menu that will be popped up when the @menu_button is
// clicked, or nil to dissociate any existing menu and disable the button.
// 
// If MenuButton:menu-model or MenuButton:popover are set, those objects are
// dissociated from the @menu_button, and those properties are set to nil.
	func (m MenuButton) SetPopup(menu WidgetClass)  {
var _arg0 *C.GtkMenuButton // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(menu.Native()))

C.gtk_menu_button_set_popup(_arg0, _arg1)
}
	
	// SetUsePopover sets whether to construct a Popover instead of Menu when
// gtk_menu_button_set_menu_model() is called. Note that this property is only
// consulted when a new menu model is set.
	func (m MenuButton) SetUsePopover(usePopover bool)  {
var _arg0 *C.GtkMenuButton // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))
if usePopover { _arg1 = C.TRUE }

C.gtk_menu_button_set_use_popover(_arg0, _arg1)
}
	


	// MenuItem: the MenuItem widget and the derived widgets are the only valid
// children for menus. Their function is to correctly handle highlighting,
// alignment, events and submenus.
// 
// As a GtkMenuItem derives from Bin it can hold any valid child widget,
// although only a few are really useful.
// 
// By default, a GtkMenuItem sets a AccelLabel as its child. GtkMenuItem has
// direct functions to set the label and its mnemonic. For more advanced label
// settings, you can fetch the child widget from the GtkBin.
// 
// An example for setting markup and accelerator on a MenuItem:
// 
//    menuitem
//    ├── <child>
//    ╰── [arrow.right]
// 
// GtkMenuItem has a single CSS node with name menuitem. If the menuitem has a
// submenu, it gets another CSS node with name arrow, which has the .left or
// .right style class.
	type MenuItem struct {
		Bin
		Actionable
		Activatable
		Buildable
		
	}

	// MenuItemClass is an interface that the MenuItem class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type MenuItemClass interface {
		gextras.Objector
		_menuItem()
	}

	func (MenuItem) _menuItem() {}

	
	func marshalMenuItem(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapMenuItem(obj), nil
	}
	

	
	// NewMenuItem creates a new MenuItem.
	func NewMenuItem() MenuItem {
var _cret *C.GtkWidget // in

_cret = C.gtk_menu_item_new()


var _menuItem MenuItem // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_menuItem = MenuItem{
Bin: Bin{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _menuItem
}
	
	// NewMenuItemWithLabel creates a new MenuItem whose child is a Label.
	func NewMenuItemWithLabel(label string) MenuItem {
var _arg1 *C.gchar // out
var _cret *C.GtkWidget // in

_arg1 = (*C.gchar)(C.CString(label))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_menu_item_new_with_label(_arg1)


var _menuItem MenuItem // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_menuItem = MenuItem{
Bin: Bin{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _menuItem
}
	
	// NewMenuItemWithMnemonic creates a new MenuItem containing a label.
// 
// The label will be created using gtk_label_new_with_mnemonic(), so underscores
// in @label indicate the mnemonic for the menu item.
	func NewMenuItemWithMnemonic(label string) MenuItem {
var _arg1 *C.gchar // out
var _cret *C.GtkWidget // in

_arg1 = (*C.gchar)(C.CString(label))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_menu_item_new_with_mnemonic(_arg1)


var _menuItem MenuItem // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_menuItem = MenuItem{
Bin: Bin{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _menuItem
}
	

	
	// Activate emits the MenuItem::activate signal on the given item
	func (m MenuItem) Activate()  {
var _arg0 *C.GtkMenuItem // out

_arg0 = (*C.GtkMenuItem)(unsafe.Pointer(m.Native()))

C.gtk_menu_item_activate(_arg0)
}
	
	// Deselect emits the MenuItem::deselect signal on the given item.
	func (m MenuItem) Deselect()  {
var _arg0 *C.GtkMenuItem // out

_arg0 = (*C.GtkMenuItem)(unsafe.Pointer(m.Native()))

C.gtk_menu_item_deselect(_arg0)
}
	
	// AccelPath: retrieve the accelerator path that was previously set on
// @menu_item.
// 
// See gtk_menu_item_set_accel_path() for details.
	func (m MenuItem) AccelPath() string {
var _arg0 *C.GtkMenuItem // out
var _cret *C.gchar // in

_arg0 = (*C.GtkMenuItem)(unsafe.Pointer(m.Native()))

_cret = C.gtk_menu_item_get_accel_path(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Label sets @text on the @menu_item label
	func (m MenuItem) Label() string {
var _arg0 *C.GtkMenuItem // out
var _cret *C.gchar // in

_arg0 = (*C.GtkMenuItem)(unsafe.Pointer(m.Native()))

_cret = C.gtk_menu_item_get_label(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// ReserveIndicator returns whether the @menu_item reserves space for the
// submenu indicator, regardless if it has a submenu or not.
	func (m MenuItem) ReserveIndicator() bool {
var _arg0 *C.GtkMenuItem // out
var _cret C.gboolean // in

_arg0 = (*C.GtkMenuItem)(unsafe.Pointer(m.Native()))

_cret = C.gtk_menu_item_get_reserve_indicator(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// RightJustified gets whether the menu item appears justified at the right side
// of the menu bar.
	func (m MenuItem) RightJustified() bool {
var _arg0 *C.GtkMenuItem // out
var _cret C.gboolean // in

_arg0 = (*C.GtkMenuItem)(unsafe.Pointer(m.Native()))

_cret = C.gtk_menu_item_get_right_justified(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Submenu gets the submenu underneath this menu item, if any. See
// gtk_menu_item_set_submenu().
	func (m MenuItem) Submenu() Widget {
var _arg0 *C.GtkMenuItem // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkMenuItem)(unsafe.Pointer(m.Native()))

_cret = C.gtk_menu_item_get_submenu(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// UseUnderline checks if an underline in the text indicates the next character
// should be used for the mnemonic accelerator key.
	func (m MenuItem) UseUnderline() bool {
var _arg0 *C.GtkMenuItem // out
var _cret C.gboolean // in

_arg0 = (*C.GtkMenuItem)(unsafe.Pointer(m.Native()))

_cret = C.gtk_menu_item_get_use_underline(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Select emits the MenuItem::select signal on the given item.
	func (m MenuItem) Select()  {
var _arg0 *C.GtkMenuItem // out

_arg0 = (*C.GtkMenuItem)(unsafe.Pointer(m.Native()))

C.gtk_menu_item_select(_arg0)
}
	
	// SetAccelPath: set the accelerator path on @menu_item, through which runtime
// changes of the menu item’s accelerator caused by the user can be identified
// and saved to persistent storage (see gtk_accel_map_save() on this). To set up
// a default accelerator for this menu item, call gtk_accel_map_add_entry() with
// the same @accel_path. See also gtk_accel_map_add_entry() on the specifics of
// accelerator paths, and gtk_menu_set_accel_path() for a more convenient
// variant of this function.
// 
// This function is basically a convenience wrapper that handles calling
// gtk_widget_set_accel_path() with the appropriate accelerator group for the
// menu item.
// 
// Note that you do need to set an accelerator on the parent menu with
// gtk_menu_set_accel_group() for this to work.
// 
// Note that @accel_path string will be stored in a #GQuark. Therefore, if you
// pass a static string, you can save some memory by interning it first with
// g_intern_static_string().
	func (m MenuItem) SetAccelPath(accelPath string)  {
var _arg0 *C.GtkMenuItem // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkMenuItem)(unsafe.Pointer(m.Native()))
_arg1 = (*C.gchar)(C.CString(accelPath))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_menu_item_set_accel_path(_arg0, _arg1)
}
	
	// SetLabel sets @text on the @menu_item label
	func (m MenuItem) SetLabel(label string)  {
var _arg0 *C.GtkMenuItem // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkMenuItem)(unsafe.Pointer(m.Native()))
_arg1 = (*C.gchar)(C.CString(label))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_menu_item_set_label(_arg0, _arg1)
}
	
	// SetReserveIndicator sets whether the @menu_item should reserve space for the
// submenu indicator, regardless if it actually has a submenu or not.
// 
// There should be little need for applications to call this functions.
	func (m MenuItem) SetReserveIndicator(reserve bool)  {
var _arg0 *C.GtkMenuItem // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkMenuItem)(unsafe.Pointer(m.Native()))
if reserve { _arg1 = C.TRUE }

C.gtk_menu_item_set_reserve_indicator(_arg0, _arg1)
}
	
	// SetRightJustified sets whether the menu item appears justified at the right
// side of a menu bar. This was traditionally done for “Help” menu items, but is
// now considered a bad idea. (If the widget layout is reversed for a
// right-to-left language like Hebrew or Arabic, right-justified-menu-items
// appear at the left.)
	func (m MenuItem) SetRightJustified(rightJustified bool)  {
var _arg0 *C.GtkMenuItem // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkMenuItem)(unsafe.Pointer(m.Native()))
if rightJustified { _arg1 = C.TRUE }

C.gtk_menu_item_set_right_justified(_arg0, _arg1)
}
	
	// SetSubmenu sets or replaces the menu item’s submenu, or removes it when a nil
// submenu is passed.
	func (m MenuItem) SetSubmenu(submenu MenuClass)  {
var _arg0 *C.GtkMenuItem // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkMenuItem)(unsafe.Pointer(m.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(submenu.Native()))

C.gtk_menu_item_set_submenu(_arg0, _arg1)
}
	
	// SetUseUnderline: if true, an underline in the text indicates the next
// character should be used for the mnemonic accelerator key.
	func (m MenuItem) SetUseUnderline(setting bool)  {
var _arg0 *C.GtkMenuItem // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkMenuItem)(unsafe.Pointer(m.Native()))
if setting { _arg1 = C.TRUE }

C.gtk_menu_item_set_use_underline(_arg0, _arg1)
}
	
	// ToggleSizeAllocate emits the MenuItem::toggle-size-allocate signal on the
// given item.
	func (m MenuItem) ToggleSizeAllocate(allocation int)  {
var _arg0 *C.GtkMenuItem // out
var _arg1 C.gint // out

_arg0 = (*C.GtkMenuItem)(unsafe.Pointer(m.Native()))
_arg1 = (C.gint)(allocation)

C.gtk_menu_item_toggle_size_allocate(_arg0, _arg1)
}
	


	// MenuShell: a MenuShell is the abstract base class used to derive the Menu and
// MenuBar subclasses.
// 
// A MenuShell is a container of MenuItem objects arranged in a list which can
// be navigated, selected, and activated by the user to perform application
// functions. A MenuItem can have a submenu associated with it, allowing for
// nested hierarchical menus.
// 
// 
// Terminology
// 
// A menu item can be “selected”, this means that it is displayed in the
// prelight state, and if it has a submenu, that submenu will be popped up.
// 
// A menu is “active” when it is visible onscreen and the user is selecting from
// it. A menubar is not active until the user clicks on one of its menuitems.
// When a menu is active, passing the mouse over a submenu will pop it up.
// 
// There is also is a concept of the current menu and a current menu item. The
// current menu item is the selected menu item that is furthest down in the
// hierarchy. (Every active menu shell does not necessarily contain a selected
// menu item, but if it does, then the parent menu shell must also contain a
// selected menu item.) The current menu is the menu that contains the current
// menu item. It will always have a GTK grab and receive all key presses.
	type MenuShell struct {
		Container
		Buildable
		
	}

	// MenuShellClass is an interface that the MenuShell class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type MenuShellClass interface {
		gextras.Objector
		_menuShell()
	}

	func (MenuShell) _menuShell() {}

	
	func marshalMenuShell(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapMenuShell(obj), nil
	}
	

	

	
	// ActivateItem activates the menu item within the menu shell.
	func (m MenuShell) ActivateItem(menuItem WidgetClass, forceDeactivate bool)  {
var _arg0 *C.GtkMenuShell // out
var _arg1 *C.GtkWidget // out
var _arg2 C.gboolean // out

_arg0 = (*C.GtkMenuShell)(unsafe.Pointer(m.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(menuItem.Native()))
if forceDeactivate { _arg2 = C.TRUE }

C.gtk_menu_shell_activate_item(_arg0, _arg1, _arg2)
}
	
	// Append adds a new MenuItem to the end of the menu shell's item list.
	func (m MenuShell) Append(child MenuItemClass)  {
var _arg0 *C.GtkMenuShell // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkMenuShell)(unsafe.Pointer(m.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

C.gtk_menu_shell_append(_arg0, _arg1)
}
	
	// BindModel establishes a binding between a MenuShell and a Model.
// 
// The contents of @shell are removed and then refilled with menu items
// according to @model. When @model changes, @shell is updated. Calling this
// function twice on @shell with different @model will cause the first binding
// to be replaced with a binding to the new model. If @model is nil then any
// previous binding is undone and all children are removed.
// 
// @with_separators determines if toplevel items (eg: sections) have separators
// inserted between them. This is typically desired for menus but doesn’t make
// sense for menubars.
// 
// If @action_namespace is non-nil then the effect is as if all actions
// mentioned in the @model have their names prefixed with the namespace, plus a
// dot. For example, if the action “quit” is mentioned and @action_namespace is
// “app” then the effective action name is “app.quit”.
// 
// This function uses Actionable to define the action name and target values on
// the created menu items. If you want to use an action group other than “app”
// and “win”, or if you want to use a MenuShell outside of a ApplicationWindow,
// then you will need to attach your own action group to the widget hierarchy
// using gtk_widget_insert_action_group(). As an example, if you created a group
// with a “quit” action and inserted it with the name “mygroup” then you would
// use the action name “mygroup.quit” in your Model.
// 
// For most cases you are probably better off using gtk_menu_new_from_model() or
// gtk_menu_bar_new_from_model() or just directly passing the Model to
// gtk_application_set_app_menu() or gtk_application_set_menubar().
	func (m MenuShell) BindModel(model gio.MenuModelClass, actionNamespace string, withSeparators bool)  {
var _arg0 *C.GtkMenuShell // out
var _arg1 *C.GMenuModel // out
var _arg2 *C.gchar // out
var _arg3 C.gboolean // out

_arg0 = (*C.GtkMenuShell)(unsafe.Pointer(m.Native()))
_arg1 = (*C.GMenuModel)(unsafe.Pointer(model.Native()))
_arg2 = (*C.gchar)(C.CString(actionNamespace))
defer C.free(unsafe.Pointer(_arg2))
if withSeparators { _arg3 = C.TRUE }

C.gtk_menu_shell_bind_model(_arg0, _arg1, _arg2, _arg3)
}
	
	// Cancel cancels the selection within the menu shell.
	func (m MenuShell) Cancel()  {
var _arg0 *C.GtkMenuShell // out

_arg0 = (*C.GtkMenuShell)(unsafe.Pointer(m.Native()))

C.gtk_menu_shell_cancel(_arg0)
}
	
	// Deactivate deactivates the menu shell.
// 
// Typically this results in the menu shell being erased from the screen.
	func (m MenuShell) Deactivate()  {
var _arg0 *C.GtkMenuShell // out

_arg0 = (*C.GtkMenuShell)(unsafe.Pointer(m.Native()))

C.gtk_menu_shell_deactivate(_arg0)
}
	
	// Deselect deselects the currently selected item from the menu shell, if any.
	func (m MenuShell) Deselect()  {
var _arg0 *C.GtkMenuShell // out

_arg0 = (*C.GtkMenuShell)(unsafe.Pointer(m.Native()))

C.gtk_menu_shell_deselect(_arg0)
}
	
	// ParentShell gets the parent menu shell.
// 
// The parent menu shell of a submenu is the Menu or MenuBar from which it was
// opened up.
	func (m MenuShell) ParentShell() Widget {
var _arg0 *C.GtkMenuShell // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkMenuShell)(unsafe.Pointer(m.Native()))

_cret = C.gtk_menu_shell_get_parent_shell(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// SelectedItem gets the currently selected item.
	func (m MenuShell) SelectedItem() Widget {
var _arg0 *C.GtkMenuShell // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkMenuShell)(unsafe.Pointer(m.Native()))

_cret = C.gtk_menu_shell_get_selected_item(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// TakeFocus returns true if the menu shell will take the keyboard focus on
// popup.
	func (m MenuShell) TakeFocus() bool {
var _arg0 *C.GtkMenuShell // out
var _cret C.gboolean // in

_arg0 = (*C.GtkMenuShell)(unsafe.Pointer(m.Native()))

_cret = C.gtk_menu_shell_get_take_focus(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Insert adds a new MenuItem to the menu shell’s item list at the position
// indicated by @position.
	func (m MenuShell) Insert(child WidgetClass, position int)  {
var _arg0 *C.GtkMenuShell // out
var _arg1 *C.GtkWidget // out
var _arg2 C.gint // out

_arg0 = (*C.GtkMenuShell)(unsafe.Pointer(m.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
_arg2 = (C.gint)(position)

C.gtk_menu_shell_insert(_arg0, _arg1, _arg2)
}
	
	// Prepend adds a new MenuItem to the beginning of the menu shell's item list.
	func (m MenuShell) Prepend(child WidgetClass)  {
var _arg0 *C.GtkMenuShell // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkMenuShell)(unsafe.Pointer(m.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

C.gtk_menu_shell_prepend(_arg0, _arg1)
}
	
	// SelectFirst: select the first visible or selectable child of the menu shell;
// don’t select tearoff items unless the only item is a tearoff item.
	func (m MenuShell) SelectFirst(searchSensitive bool)  {
var _arg0 *C.GtkMenuShell // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkMenuShell)(unsafe.Pointer(m.Native()))
if searchSensitive { _arg1 = C.TRUE }

C.gtk_menu_shell_select_first(_arg0, _arg1)
}
	
	// SelectItem selects the menu item from the menu shell.
	func (m MenuShell) SelectItem(menuItem WidgetClass)  {
var _arg0 *C.GtkMenuShell // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkMenuShell)(unsafe.Pointer(m.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(menuItem.Native()))

C.gtk_menu_shell_select_item(_arg0, _arg1)
}
	
	// SetTakeFocus: if @take_focus is true (the default) the menu shell will take
// the keyboard focus so that it will receive all keyboard events which is
// needed to enable keyboard navigation in menus.
// 
// Setting @take_focus to false is useful only for special applications like
// virtual keyboard implementations which should not take keyboard focus.
// 
// The @take_focus state of a menu or menu bar is automatically propagated to
// submenus whenever a submenu is popped up, so you don’t have to worry about
// recursively setting it for your entire menu hierarchy. Only when
// programmatically picking a submenu and popping it up manually, the
// @take_focus property of the submenu needs to be set explicitly.
// 
// Note that setting it to false has side-effects:
// 
// If the focus is in some other app, it keeps the focus and keynav in the menu
// doesn’t work. Consequently, keynav on the menu will only work if the focus is
// on some toplevel owned by the onscreen keyboard.
// 
// To avoid confusing the user, menus with @take_focus set to false should not
// display mnemonics or accelerators, since it cannot be guaranteed that they
// will work.
// 
// See also gdk_keyboard_grab()
	func (m MenuShell) SetTakeFocus(takeFocus bool)  {
var _arg0 *C.GtkMenuShell // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkMenuShell)(unsafe.Pointer(m.Native()))
if takeFocus { _arg1 = C.TRUE }

C.gtk_menu_shell_set_take_focus(_arg0, _arg1)
}
	


	// MenuToolButton: a MenuToolButton is a ToolItem that contains a button and a
// small additional button with an arrow. When clicked, the arrow button pops up
// a dropdown menu.
// 
// Use gtk_menu_tool_button_new() to create a new MenuToolButton.
// 
// 
// GtkMenuToolButton as GtkBuildable
// 
// The GtkMenuToolButton implementation of the GtkBuildable interface supports
// adding a menu by specifying “menu” as the “type” attribute of a <child>
// element.
// 
// An example for a UI definition fragment with menus:
// 
//    <object class="GtkMenuToolButton">
//      <child type="menu">
//        <object class="GtkMenu"/>
//      </child>
//    </object>
	type MenuToolButton struct {
		ToolButton
		Actionable
		Activatable
		Buildable
		
	}

	// MenuToolButtonClass is an interface that the MenuToolButton class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type MenuToolButtonClass interface {
		gextras.Objector
		_menuToolButton()
	}

	func (MenuToolButton) _menuToolButton() {}

	
	func marshalMenuToolButton(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapMenuToolButton(obj), nil
	}
	

	
	// NewMenuToolButton creates a new MenuToolButton using @icon_widget as icon and
// @label as label.
	func NewMenuToolButton(iconWidget WidgetClass, label string) MenuToolButton {
var _arg1 *C.GtkWidget // out
var _arg2 *C.gchar // out
var _cret *C.GtkToolItem // in

_arg1 = (*C.GtkWidget)(unsafe.Pointer(iconWidget.Native()))
_arg2 = (*C.gchar)(C.CString(label))
defer C.free(unsafe.Pointer(_arg2))

_cret = C.gtk_menu_tool_button_new(_arg1, _arg2)


var _menuToolButton MenuToolButton // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_menuToolButton = MenuToolButton{
ToolButton: ToolButton{
ToolItem: ToolItem{
Bin: Bin{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _menuToolButton
}
	
	// NewMenuToolButtonFromStock creates a new MenuToolButton. The new
// MenuToolButton will contain an icon and label from the stock item indicated
// by @stock_id.
	func NewMenuToolButtonFromStock(stockId string) MenuToolButton {
var _arg1 *C.gchar // out
var _cret *C.GtkToolItem // in

_arg1 = (*C.gchar)(C.CString(stockId))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_menu_tool_button_new_from_stock(_arg1)


var _menuToolButton MenuToolButton // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_menuToolButton = MenuToolButton{
ToolButton: ToolButton{
ToolItem: ToolItem{
Bin: Bin{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _menuToolButton
}
	

	
	// Menu gets the Menu associated with MenuToolButton.
	func (b MenuToolButton) Menu() Widget {
var _arg0 *C.GtkMenuToolButton // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkMenuToolButton)(unsafe.Pointer(b.Native()))

_cret = C.gtk_menu_tool_button_get_menu(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// SetArrowTooltipMarkup sets the tooltip markup text to be used as tooltip for
// the arrow button which pops up the menu. See gtk_tool_item_set_tooltip_text()
// for setting a tooltip on the whole MenuToolButton.
	func (b MenuToolButton) SetArrowTooltipMarkup(markup string)  {
var _arg0 *C.GtkMenuToolButton // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkMenuToolButton)(unsafe.Pointer(b.Native()))
_arg1 = (*C.gchar)(C.CString(markup))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_menu_tool_button_set_arrow_tooltip_markup(_arg0, _arg1)
}
	
	// SetArrowTooltipText sets the tooltip text to be used as tooltip for the arrow
// button which pops up the menu. See gtk_tool_item_set_tooltip_text() for
// setting a tooltip on the whole MenuToolButton.
	func (b MenuToolButton) SetArrowTooltipText(text string)  {
var _arg0 *C.GtkMenuToolButton // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkMenuToolButton)(unsafe.Pointer(b.Native()))
_arg1 = (*C.gchar)(C.CString(text))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_menu_tool_button_set_arrow_tooltip_text(_arg0, _arg1)
}
	
	// SetMenu sets the Menu that is popped up when the user clicks on the arrow. If
// @menu is NULL, the arrow button becomes insensitive.
	func (b MenuToolButton) SetMenu(menu WidgetClass)  {
var _arg0 *C.GtkMenuToolButton // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkMenuToolButton)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(menu.Native()))

C.gtk_menu_tool_button_set_menu(_arg0, _arg1)
}
	


	// MessageDialog presents a dialog with some message text. It’s simply a
// convenience widget; you could construct the equivalent of MessageDialog from
// Dialog without too much effort, but MessageDialog saves typing.
// 
// One difference from Dialog is that MessageDialog sets the
// Window:skip-taskbar-hint property to true, so that the dialog is hidden from
// the taskbar by default.
// 
// The easiest way to do a modal message dialog is to use gtk_dialog_run(),
// though you can also pass in the GTK_DIALOG_MODAL flag, gtk_dialog_run()
// automatically makes the dialog modal and waits for the user to respond to it.
// gtk_dialog_run() returns when any dialog button is clicked.
// 
// An example for using a modal dialog:
// 
//     GtkDialogFlags flags = GTK_DIALOG_DESTROY_WITH_PARENT;
//     dialog = gtk_message_dialog_new (parent_window,
//                                      flags,
//                                      GTK_MESSAGE_ERROR,
//                                      GTK_BUTTONS_CLOSE,
//                                      "Error reading “s”: s",
//                                      filename,
//                                      g_strerror (errno));
// 
//     // Destroy the dialog when the user responds to it
//     // (e.g. clicks a button)
// 
//     g_signal_connect_swapped (dialog, "response",
//                               G_CALLBACK (gtk_widget_destroy),
//                               dialog);
// 
// 
// GtkMessageDialog as GtkBuildable
// 
// The GtkMessageDialog implementation of the GtkBuildable interface exposes the
// message area as an internal child with the name “message_area”.
	type MessageDialog struct {
		Dialog
		Buildable
		
	}

	// MessageDialogClass is an interface that the MessageDialog class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type MessageDialogClass interface {
		gextras.Objector
		_messageDialog()
	}

	func (MessageDialog) _messageDialog() {}

	
	func marshalMessageDialog(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapMessageDialog(obj), nil
	}
	

	

	
	// Image gets the dialog’s image.
	func (d MessageDialog) Image() Widget {
var _arg0 *C.GtkMessageDialog // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkMessageDialog)(unsafe.Pointer(d.Native()))

_cret = C.gtk_message_dialog_get_image(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// MessageArea returns the message area of the dialog. This is the box where the
// dialog’s primary and secondary labels are packed. You can add your own extra
// content to that box and it will appear below those labels. See
// gtk_dialog_get_content_area() for the corresponding function in the parent
// Dialog.
	func (m MessageDialog) MessageArea() Widget {
var _arg0 *C.GtkMessageDialog // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkMessageDialog)(unsafe.Pointer(m.Native()))

_cret = C.gtk_message_dialog_get_message_area(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// SetImage sets the dialog’s image to @image.
	func (d MessageDialog) SetImage(image WidgetClass)  {
var _arg0 *C.GtkMessageDialog // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkMessageDialog)(unsafe.Pointer(d.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(image.Native()))

C.gtk_message_dialog_set_image(_arg0, _arg1)
}
	
	// SetMarkup sets the text of the message dialog to be @str, which is marked up
// with the [Pango text markup language][PangoMarkupFormat].
	func (m MessageDialog) SetMarkup(str string)  {
var _arg0 *C.GtkMessageDialog // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkMessageDialog)(unsafe.Pointer(m.Native()))
_arg1 = (*C.gchar)(C.CString(str))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_message_dialog_set_markup(_arg0, _arg1)
}
	


	// Misc: the Misc widget is an abstract widget which is not useful itself, but
// is used to derive subclasses which have alignment and padding attributes.
// 
// The horizontal and vertical padding attributes allows extra space to be added
// around the widget.
// 
// The horizontal and vertical alignment attributes enable the widget to be
// positioned within its allocated area. Note that if the widget is added to a
// container in such a way that it expands automatically to fill its allocated
// area, the alignment settings will not alter the widget's position.
// 
// Note that the desired effect can in most cases be achieved by using the
// Widget:halign, Widget:valign and Widget:margin properties on the child
// widget, so GtkMisc should not be used in new code. To reflect this fact, all
// Misc API has been deprecated.
	type Misc struct {
		Widget
		Buildable
		
	}

	// MiscClass is an interface that the Misc class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type MiscClass interface {
		gextras.Objector
		_misc()
	}

	func (Misc) _misc() {}

	
	func marshalMisc(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapMisc(obj), nil
	}
	

	

	
	// Alignment gets the X and Y alignment of the widget within its allocation. See
// gtk_misc_set_alignment().
	func (m Misc) Alignment() (xalign float32, yalign float32) {
var _arg0 *C.GtkMisc // out
var _arg1 C.gfloat // in
var _arg2 C.gfloat // in

_arg0 = (*C.GtkMisc)(unsafe.Pointer(m.Native()))

C.gtk_misc_get_alignment(_arg0, &_arg1, &_arg2)

var _xalign float32 // out
var _yalign float32 // out

_xalign = (float32)(_arg1)
_yalign = (float32)(_arg2)

return _xalign, _yalign
}
	
	// Padding gets the padding in the X and Y directions of the widget. See
// gtk_misc_set_padding().
	func (m Misc) Padding() (xpad int, ypad int) {
var _arg0 *C.GtkMisc // out
var _arg1 C.gint // in
var _arg2 C.gint // in

_arg0 = (*C.GtkMisc)(unsafe.Pointer(m.Native()))

C.gtk_misc_get_padding(_arg0, &_arg1, &_arg2)

var _xpad int // out
var _ypad int // out

_xpad = (int)(_arg1)
_ypad = (int)(_arg2)

return _xpad, _ypad
}
	
	// SetAlignment sets the alignment of the widget.
	func (m Misc) SetAlignment(xalign float32, yalign float32)  {
var _arg0 *C.GtkMisc // out
var _arg1 C.gfloat // out
var _arg2 C.gfloat // out

_arg0 = (*C.GtkMisc)(unsafe.Pointer(m.Native()))
_arg1 = (C.gfloat)(xalign)
_arg2 = (C.gfloat)(yalign)

C.gtk_misc_set_alignment(_arg0, _arg1, _arg2)
}
	
	// SetPadding sets the amount of space to add around the widget.
	func (m Misc) SetPadding(xpad int, ypad int)  {
var _arg0 *C.GtkMisc // out
var _arg1 C.gint // out
var _arg2 C.gint // out

_arg0 = (*C.GtkMisc)(unsafe.Pointer(m.Native()))
_arg1 = (C.gint)(xpad)
_arg2 = (C.gint)(ypad)

C.gtk_misc_set_padding(_arg0, _arg1, _arg2)
}
	


	// ModelButton: gtkModelButton is a button class that can use a #GAction as its
// model. In contrast to ToggleButton or RadioButton, which can also be backed
// by a #GAction via the Actionable:action-name property, GtkModelButton will
// adapt its appearance according to the kind of action it is backed by, and
// appear either as a plain, check or radio button.
// 
// Model buttons are used when popovers from a menu model with
// gtk_popover_new_from_model(); they can also be used manually in a
// PopoverMenu.
// 
// When the action is specified via the Actionable:action-name and
// Actionable:action-target properties, the role of the button (i.e. whether it
// is a plain, check or radio button) is determined by the type of the action
// and doesn't have to be explicitly specified with the ModelButton:role
// property.
// 
// The content of the button is specified by the ModelButton:text and
// ModelButton:icon properties.
// 
// The appearance of model buttons can be influenced with the
// ModelButton:centered and ModelButton:iconic properties.
// 
// Model buttons have built-in support for submenus in PopoverMenu. To make a
// GtkModelButton that opens a submenu when activated, set the
// ModelButton:menu-name property. To make a button that goes back to the parent
// menu, you should set the ModelButton:inverted property to place the submenu
// indicator at the opposite side.
// 
// Example
// 
//    <object class="GtkPopoverMenu">
//      <child>
//        <object class="GtkBox">
//          <property name="visible">True</property>
//          <property name="margin">10</property>
//          <child>
//            <object class="GtkModelButton">
//              <property name="visible">True</property>
//              <property name="action-name">view.cut</property>
//              <property name="text" translatable="yes">Cut</property>
//            </object>
//          </child>
//          <child>
//            <object class="GtkModelButton">
//              <property name="visible">True</property>
//              <property name="action-name">view.copy</property>
//              <property name="text" translatable="yes">Copy</property>
//            </object>
//          </child>
//          <child>
//            <object class="GtkModelButton">
//              <property name="visible">True</property>
//              <property name="action-name">view.paste</property>
//              <property name="text" translatable="yes">Paste</property>
//            </object>
//          </child>
//        </object>
//      </child>
//    </object>
// 
// CSS nodes
// 
//    button.model
//    ├── <child>
//    ╰── check
// 
// Iconic model buttons (see ModelButton:iconic) change the name of their main
// node to button and add a .model style class to it. The indicator subnode is
// invisible in this case.
	type ModelButton struct {
		Button
		Actionable
		Activatable
		Buildable
		
	}

	// ModelButtonClass is an interface that the ModelButton class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ModelButtonClass interface {
		gextras.Objector
		_modelButton()
	}

	func (ModelButton) _modelButton() {}

	
	func marshalModelButton(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapModelButton(obj), nil
	}
	

	
	// NewModelButton creates a new GtkModelButton.
	func NewModelButton() ModelButton {
var _cret *C.GtkWidget // in

_cret = C.gtk_model_button_new()


var _modelButton ModelButton // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_modelButton = ModelButton{
Button: Button{
Bin: Bin{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _modelButton
}
	

	


	// MountOperation: this should not be accessed directly. Use the accessor
// functions below.
	type MountOperation struct {
		gio.MountOperation
		
	}

	// MountOperationClass is an interface that the MountOperation class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type MountOperationClass interface {
		gextras.Objector
		_mountOperation()
	}

	func (MountOperation) _mountOperation() {}

	
	func marshalMountOperation(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapMountOperation(obj), nil
	}
	

	
	// NewMountOperation creates a new MountOperation
	func NewMountOperation(parent WindowClass) MountOperation {
var _arg1 *C.GtkWindow // out
var _cret *C.GMountOperation // in

_arg1 = (*C.GtkWindow)(unsafe.Pointer(parent.Native()))

_cret = C.gtk_mount_operation_new(_arg1)


var _mountOperation MountOperation // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_mountOperation = MountOperation{
MountOperation: gio.MountOperation{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _mountOperation
}
	

	
	// Parent gets the transient parent used by the MountOperation
	func (o MountOperation) Parent() Window {
var _arg0 *C.GtkMountOperation // out
var _cret *C.GtkWindow // in

_arg0 = (*C.GtkMountOperation)(unsafe.Pointer(o.Native()))

_cret = C.gtk_mount_operation_get_parent(_arg0)


var _window Window // out

_window = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Window)

return _window
}
	
	// Screen gets the screen on which windows of the MountOperation will be shown.
	func (o MountOperation) Screen() gdk.Screen {
var _arg0 *C.GtkMountOperation // out
var _cret *C.GdkScreen // in

_arg0 = (*C.GtkMountOperation)(unsafe.Pointer(o.Native()))

_cret = C.gtk_mount_operation_get_screen(_arg0)


var _screen gdk.Screen // out

_screen = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Screen)

return _screen
}
	
	// IsShowing returns whether the MountOperation is currently displaying a
// window.
	func (o MountOperation) IsShowing() bool {
var _arg0 *C.GtkMountOperation // out
var _cret C.gboolean // in

_arg0 = (*C.GtkMountOperation)(unsafe.Pointer(o.Native()))

_cret = C.gtk_mount_operation_is_showing(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetParent sets the transient parent for windows shown by the MountOperation.
	func (o MountOperation) SetParent(parent WindowClass)  {
var _arg0 *C.GtkMountOperation // out
var _arg1 *C.GtkWindow // out

_arg0 = (*C.GtkMountOperation)(unsafe.Pointer(o.Native()))
_arg1 = (*C.GtkWindow)(unsafe.Pointer(parent.Native()))

C.gtk_mount_operation_set_parent(_arg0, _arg1)
}
	
	// SetScreen sets the screen to show windows of the MountOperation on.
	func (o MountOperation) SetScreen(screen gdk.ScreenClass)  {
var _arg0 *C.GtkMountOperation // out
var _arg1 *C.GdkScreen // out

_arg0 = (*C.GtkMountOperation)(unsafe.Pointer(o.Native()))
_arg1 = (*C.GdkScreen)(unsafe.Pointer(screen.Native()))

C.gtk_mount_operation_set_screen(_arg0, _arg1)
}
	


	// NativeDialog: native dialogs are platform dialogs that don't use Dialog or
// Window. They are used in order to integrate better with a platform, by
// looking the same as other native applications and supporting platform
// specific features.
// 
// The Dialog functions cannot be used on such objects, but we need a similar
// API in order to drive them. The NativeDialog object is an API that allows you
// to do this. It allows you to set various common properties on the dialog, as
// well as show and hide it and get a NativeDialog::response signal when the
// user finished with the dialog.
// 
// There is also a gtk_native_dialog_run() helper that makes it easy to run any
// native dialog in a modal way with a recursive mainloop, similar to
// gtk_dialog_run().
	type NativeDialog struct {
		**externglib.Object
		
	}

	// NativeDialogClass is an interface that the NativeDialog class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type NativeDialogClass interface {
		gextras.Objector
		_nativeDialog()
	}

	func (NativeDialog) _nativeDialog() {}

	
	func marshalNativeDialog(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapNativeDialog(obj), nil
	}
	

	

	
	// Destroy destroys a dialog.
// 
// When a dialog is destroyed, it will break any references it holds to other
// objects. If it is visible it will be hidden and any underlying window system
// resources will be destroyed.
// 
// Note that this does not release any reference to the object (as opposed to
// destroying a GtkWindow) because there is no reference from the windowing
// system to the NativeDialog.
	func (s NativeDialog) Destroy()  {
var _arg0 *C.GtkNativeDialog // out

_arg0 = (*C.GtkNativeDialog)(unsafe.Pointer(s.Native()))

C.gtk_native_dialog_destroy(_arg0)
}
	
	// Modal returns whether the dialog is modal. See gtk_native_dialog_set_modal().
	func (s NativeDialog) Modal() bool {
var _arg0 *C.GtkNativeDialog // out
var _cret C.gboolean // in

_arg0 = (*C.GtkNativeDialog)(unsafe.Pointer(s.Native()))

_cret = C.gtk_native_dialog_get_modal(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Title gets the title of the NativeDialog.
	func (s NativeDialog) Title() string {
var _arg0 *C.GtkNativeDialog // out
var _cret *C.char // in

_arg0 = (*C.GtkNativeDialog)(unsafe.Pointer(s.Native()))

_cret = C.gtk_native_dialog_get_title(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// TransientFor fetches the transient parent for this window. See
// gtk_native_dialog_set_transient_for().
	func (s NativeDialog) TransientFor() Window {
var _arg0 *C.GtkNativeDialog // out
var _cret *C.GtkWindow // in

_arg0 = (*C.GtkNativeDialog)(unsafe.Pointer(s.Native()))

_cret = C.gtk_native_dialog_get_transient_for(_arg0)


var _window Window // out

_window = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Window)

return _window
}
	
	// Visible determines whether the dialog is visible.
	func (s NativeDialog) Visible() bool {
var _arg0 *C.GtkNativeDialog // out
var _cret C.gboolean // in

_arg0 = (*C.GtkNativeDialog)(unsafe.Pointer(s.Native()))

_cret = C.gtk_native_dialog_get_visible(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Hide hides the dialog if it is visilbe, aborting any interaction. Once this
// is called the NativeDialog::response signal will not be emitted until after
// the next call to gtk_native_dialog_show().
// 
// If the dialog is not visible this does nothing.
	func (s NativeDialog) Hide()  {
var _arg0 *C.GtkNativeDialog // out

_arg0 = (*C.GtkNativeDialog)(unsafe.Pointer(s.Native()))

C.gtk_native_dialog_hide(_arg0)
}
	
	// Run blocks in a recursive main loop until @self emits the
// NativeDialog::response signal. It then returns the response ID from the
// ::response signal emission.
// 
// Before entering the recursive main loop, gtk_native_dialog_run() calls
// gtk_native_dialog_show() on the dialog for you.
// 
// After gtk_native_dialog_run() returns, then dialog will be hidden.
// 
// Typical usage of this function might be:
// 
//    gint result = gtk_native_dialog_run (GTK_NATIVE_DIALOG (dialog));
//    switch (result)
//      {
//        case GTK_RESPONSE_ACCEPT:
//           do_application_specific_something ();
//           break;
//        default:
//           do_nothing_since_dialog_was_cancelled ();
//           break;
//      }
//    g_object_unref (dialog);
// 
// Note that even though the recursive main loop gives the effect of a modal
// dialog (it prevents the user from interacting with other windows in the same
// window group while the dialog is run), callbacks such as timeouts, IO channel
// watches, DND drops, etc, will be triggered during a gtk_native_dialog_run()
// call.
	func (s NativeDialog) Run() int {
var _arg0 *C.GtkNativeDialog // out
var _cret C.gint // in

_arg0 = (*C.GtkNativeDialog)(unsafe.Pointer(s.Native()))

_cret = C.gtk_native_dialog_run(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// SetModal sets a dialog modal or non-modal. Modal dialogs prevent interaction
// with other windows in the same application. To keep modal dialogs on top of
// main application windows, use gtk_native_dialog_set_transient_for() to make
// the dialog transient for the parent; most [window managers][gtk-X11-arch]
// will then disallow lowering the dialog below the parent.
	func (s NativeDialog) SetModal(modal bool)  {
var _arg0 *C.GtkNativeDialog // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkNativeDialog)(unsafe.Pointer(s.Native()))
if modal { _arg1 = C.TRUE }

C.gtk_native_dialog_set_modal(_arg0, _arg1)
}
	
	// SetTitle sets the title of the NativeDialog.
	func (s NativeDialog) SetTitle(title string)  {
var _arg0 *C.GtkNativeDialog // out
var _arg1 *C.char // out

_arg0 = (*C.GtkNativeDialog)(unsafe.Pointer(s.Native()))
_arg1 = (*C.char)(C.CString(title))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_native_dialog_set_title(_arg0, _arg1)
}
	
	// SetTransientFor: dialog windows should be set transient for the main
// application window they were spawned from. This allows [window
// managers][gtk-X11-arch] to e.g. keep the dialog on top of the main window, or
// center the dialog over the main window.
// 
// Passing nil for @parent unsets the current transient window.
	func (s NativeDialog) SetTransientFor(parent WindowClass)  {
var _arg0 *C.GtkNativeDialog // out
var _arg1 *C.GtkWindow // out

_arg0 = (*C.GtkNativeDialog)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkWindow)(unsafe.Pointer(parent.Native()))

C.gtk_native_dialog_set_transient_for(_arg0, _arg1)
}
	
	// Show shows the dialog on the display, allowing the user to interact with it.
// When the user accepts the state of the dialog the dialog will be
// automatically hidden and the NativeDialog::response signal will be emitted.
// 
// Multiple calls while the dialog is visible will be ignored.
	func (s NativeDialog) Show()  {
var _arg0 *C.GtkNativeDialog // out

_arg0 = (*C.GtkNativeDialog)(unsafe.Pointer(s.Native()))

C.gtk_native_dialog_show(_arg0)
}
	


	// Notebook: the Notebook widget is a Container whose children are pages that
// can be switched between using tab labels along one edge.
// 
// There are many configuration options for GtkNotebook. Among other things, you
// can choose on which edge the tabs appear (see gtk_notebook_set_tab_pos()),
// whether, if there are too many tabs to fit the notebook should be made bigger
// or scrolling arrows added (see gtk_notebook_set_scrollable()), and whether
// there will be a popup menu allowing the users to switch pages. (see
// gtk_notebook_popup_enable(), gtk_notebook_popup_disable())
// 
// 
// GtkNotebook as GtkBuildable
// 
// The GtkNotebook implementation of the Buildable interface supports placing
// children into tabs by specifying “tab” as the “type” attribute of a <child>
// element. Note that the content of the tab must be created before the tab can
// be filled. A tab child can be specified without specifying a <child> type
// attribute.
// 
// To add a child widget in the notebooks action area, specify "action-start" or
// “action-end” as the “type” attribute of the <child> element.
// 
// An example of a UI definition fragment with GtkNotebook:
// 
//    <object class="GtkNotebook">
//      <child>
//        <object class="GtkLabel" id="notebook-content">
//          <property name="label">Content</property>
//        </object>
//      </child>
//      <child type="tab">
//        <object class="GtkLabel" id="notebook-tab">
//          <property name="label">Tab</property>
//        </object>
//      </child>
//    </object>
// 
// CSS nodes
// 
//    notebook
//    ├── header.top
//    │   ├── [<action widget>]
//    │   ├── tabs
//    │   │   ├── [arrow]
//    │   │   ├── tab
//    │   │   │   ╰── <tab label>
//    ┊   ┊   ┊
//    │   │   ├── tab[.reorderable-page]
//    │   │   │   ╰── <tab label>
//    │   │   ╰── [arrow]
//    │   ╰── [<action widget>]
//    │
//    ╰── stack
//        ├── <child>
//        ┊
//        ╰── <child>
// 
// GtkNotebook has a main CSS node with name notebook, a subnode with name
// header and below that a subnode with name tabs which contains one subnode per
// tab with name tab.
// 
// If action widgets are present, their CSS nodes are placed next to the tabs
// node. If the notebook is scrollable, CSS nodes with name arrow are placed as
// first and last child of the tabs node.
// 
// The main node gets the .frame style class when the notebook has a border (see
// gtk_notebook_set_show_border()).
// 
// The header node gets one of the style class .top, .bottom, .left or .right,
// depending on where the tabs are placed. For reorderable pages, the tab node
// gets the .reorderable-page class.
// 
// A tab node gets the .dnd style class while it is moved with drag-and-drop.
// 
// The nodes are always arranged from left-to-right, regarldess of text
// direction.
	type Notebook struct {
		Container
		Buildable
		
	}

	// NotebookClass is an interface that the Notebook class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type NotebookClass interface {
		gextras.Objector
		_notebook()
	}

	func (Notebook) _notebook() {}

	
	func marshalNotebook(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapNotebook(obj), nil
	}
	

	
	// NewNotebook creates a new Notebook widget with no pages.
	func NewNotebook() Notebook {
var _cret *C.GtkWidget // in

_cret = C.gtk_notebook_new()


var _notebook Notebook // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_notebook = Notebook{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _notebook
}
	

	
	// AppendPage appends a page to @notebook.
	func (n Notebook) AppendPage(child WidgetClass, tabLabel WidgetClass) int {
var _arg0 *C.GtkNotebook // out
var _arg1 *C.GtkWidget // out
var _arg2 *C.GtkWidget // out
var _cret C.gint // in

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
_arg2 = (*C.GtkWidget)(unsafe.Pointer(tabLabel.Native()))

_cret = C.gtk_notebook_append_page(_arg0, _arg1, _arg2)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// AppendPageMenu appends a page to @notebook, specifying the widget to use as
// the label in the popup menu.
	func (n Notebook) AppendPageMenu(child WidgetClass, tabLabel WidgetClass, menuLabel WidgetClass) int {
var _arg0 *C.GtkNotebook // out
var _arg1 *C.GtkWidget // out
var _arg2 *C.GtkWidget // out
var _arg3 *C.GtkWidget // out
var _cret C.gint // in

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
_arg2 = (*C.GtkWidget)(unsafe.Pointer(tabLabel.Native()))
_arg3 = (*C.GtkWidget)(unsafe.Pointer(menuLabel.Native()))

_cret = C.gtk_notebook_append_page_menu(_arg0, _arg1, _arg2, _arg3)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// DetachTab removes the child from the notebook.
// 
// This function is very similar to gtk_container_remove(), but additionally
// informs the notebook that the removal is happening as part of a tab DND
// operation, which should not be cancelled.
	func (n Notebook) DetachTab(child WidgetClass)  {
var _arg0 *C.GtkNotebook // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

C.gtk_notebook_detach_tab(_arg0, _arg1)
}
	
	// ActionWidget gets one of the action widgets. See
// gtk_notebook_set_action_widget().
	func (n Notebook) ActionWidget(packType PackType) Widget {
var _arg0 *C.GtkNotebook // out
var _arg1 C.GtkPackType // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
_arg1 = (C.GtkPackType)(packType)

_cret = C.gtk_notebook_get_action_widget(_arg0, _arg1)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// CurrentPage returns the page number of the current page.
	func (n Notebook) CurrentPage() int {
var _arg0 *C.GtkNotebook // out
var _cret C.gint // in

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))

_cret = C.gtk_notebook_get_current_page(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// GroupName gets the current group name for @notebook.
	func (n Notebook) GroupName() string {
var _arg0 *C.GtkNotebook // out
var _cret *C.gchar // in

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))

_cret = C.gtk_notebook_get_group_name(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// MenuLabel retrieves the menu label widget of the page containing @child.
	func (n Notebook) MenuLabel(child WidgetClass) Widget {
var _arg0 *C.GtkNotebook // out
var _arg1 *C.GtkWidget // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

_cret = C.gtk_notebook_get_menu_label(_arg0, _arg1)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// MenuLabelText retrieves the text of the menu label for the page containing
// @child.
	func (n Notebook) MenuLabelText(child WidgetClass) string {
var _arg0 *C.GtkNotebook // out
var _arg1 *C.GtkWidget // out
var _cret *C.gchar // in

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

_cret = C.gtk_notebook_get_menu_label_text(_arg0, _arg1)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// NPages gets the number of pages in a notebook.
	func (n Notebook) NPages() int {
var _arg0 *C.GtkNotebook // out
var _cret C.gint // in

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))

_cret = C.gtk_notebook_get_n_pages(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// NthPage returns the child widget contained in page number @page_num.
	func (n Notebook) NthPage(pageNum int) Widget {
var _arg0 *C.GtkNotebook // out
var _arg1 C.gint // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
_arg1 = (C.gint)(pageNum)

_cret = C.gtk_notebook_get_nth_page(_arg0, _arg1)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// Scrollable returns whether the tab label area has arrows for scrolling. See
// gtk_notebook_set_scrollable().
	func (n Notebook) Scrollable() bool {
var _arg0 *C.GtkNotebook // out
var _cret C.gboolean // in

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))

_cret = C.gtk_notebook_get_scrollable(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ShowBorder returns whether a bevel will be drawn around the notebook pages.
// See gtk_notebook_set_show_border().
	func (n Notebook) ShowBorder() bool {
var _arg0 *C.GtkNotebook // out
var _cret C.gboolean // in

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))

_cret = C.gtk_notebook_get_show_border(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ShowTabs returns whether the tabs of the notebook are shown. See
// gtk_notebook_set_show_tabs().
	func (n Notebook) ShowTabs() bool {
var _arg0 *C.GtkNotebook // out
var _cret C.gboolean // in

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))

_cret = C.gtk_notebook_get_show_tabs(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// TabDetachable returns whether the tab contents can be detached from
// @notebook.
	func (n Notebook) TabDetachable(child WidgetClass) bool {
var _arg0 *C.GtkNotebook // out
var _arg1 *C.GtkWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

_cret = C.gtk_notebook_get_tab_detachable(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// TabHborder returns the horizontal width of a tab border.
	func (n Notebook) TabHborder() uint16 {
var _arg0 *C.GtkNotebook // out
var _cret C.guint16 // in

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))

_cret = C.gtk_notebook_get_tab_hborder(_arg0)


var _guint16 uint16 // out

_guint16 = (uint16)(_cret)

return _guint16
}
	
	// TabLabel returns the tab label widget for the page @child. nil is returned if
// @child is not in @notebook or if no tab label has specifically been set for
// @child.
	func (n Notebook) TabLabel(child WidgetClass) Widget {
var _arg0 *C.GtkNotebook // out
var _arg1 *C.GtkWidget // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

_cret = C.gtk_notebook_get_tab_label(_arg0, _arg1)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// TabLabelText retrieves the text of the tab label for the page containing
// @child.
	func (n Notebook) TabLabelText(child WidgetClass) string {
var _arg0 *C.GtkNotebook // out
var _arg1 *C.GtkWidget // out
var _cret *C.gchar // in

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

_cret = C.gtk_notebook_get_tab_label_text(_arg0, _arg1)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// TabPos gets the edge at which the tabs for switching pages in the notebook
// are drawn.
	func (n Notebook) TabPos() PositionType {
var _arg0 *C.GtkNotebook // out
var _cret C.GtkPositionType // in

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))

_cret = C.gtk_notebook_get_tab_pos(_arg0)


var _positionType PositionType // out

_positionType = PositionType(_cret)

return _positionType
}
	
	// TabReorderable gets whether the tab can be reordered via drag and drop or
// not.
	func (n Notebook) TabReorderable(child WidgetClass) bool {
var _arg0 *C.GtkNotebook // out
var _arg1 *C.GtkWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

_cret = C.gtk_notebook_get_tab_reorderable(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// TabVborder returns the vertical width of a tab border.
	func (n Notebook) TabVborder() uint16 {
var _arg0 *C.GtkNotebook // out
var _cret C.guint16 // in

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))

_cret = C.gtk_notebook_get_tab_vborder(_arg0)


var _guint16 uint16 // out

_guint16 = (uint16)(_cret)

return _guint16
}
	
	// InsertPage: insert a page into @notebook at the given position.
	func (n Notebook) InsertPage(child WidgetClass, tabLabel WidgetClass, position int) int {
var _arg0 *C.GtkNotebook // out
var _arg1 *C.GtkWidget // out
var _arg2 *C.GtkWidget // out
var _arg3 C.gint // out
var _cret C.gint // in

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
_arg2 = (*C.GtkWidget)(unsafe.Pointer(tabLabel.Native()))
_arg3 = (C.gint)(position)

_cret = C.gtk_notebook_insert_page(_arg0, _arg1, _arg2, _arg3)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// InsertPageMenu: insert a page into @notebook at the given position,
// specifying the widget to use as the label in the popup menu.
	func (n Notebook) InsertPageMenu(child WidgetClass, tabLabel WidgetClass, menuLabel WidgetClass, position int) int {
var _arg0 *C.GtkNotebook // out
var _arg1 *C.GtkWidget // out
var _arg2 *C.GtkWidget // out
var _arg3 *C.GtkWidget // out
var _arg4 C.gint // out
var _cret C.gint // in

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
_arg2 = (*C.GtkWidget)(unsafe.Pointer(tabLabel.Native()))
_arg3 = (*C.GtkWidget)(unsafe.Pointer(menuLabel.Native()))
_arg4 = (C.gint)(position)

_cret = C.gtk_notebook_insert_page_menu(_arg0, _arg1, _arg2, _arg3, _arg4)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// NextPage switches to the next page. Nothing happens if the current page is
// the last page.
	func (n Notebook) NextPage()  {
var _arg0 *C.GtkNotebook // out

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))

C.gtk_notebook_next_page(_arg0)
}
	
	// PageNum finds the index of the page which contains the given child widget.
	func (n Notebook) PageNum(child WidgetClass) int {
var _arg0 *C.GtkNotebook // out
var _arg1 *C.GtkWidget // out
var _cret C.gint // in

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

_cret = C.gtk_notebook_page_num(_arg0, _arg1)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// PopupDisable disables the popup menu.
	func (n Notebook) PopupDisable()  {
var _arg0 *C.GtkNotebook // out

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))

C.gtk_notebook_popup_disable(_arg0)
}
	
	// PopupEnable enables the popup menu: if the user clicks with the right mouse
// button on the tab labels, a menu with all the pages will be popped up.
	func (n Notebook) PopupEnable()  {
var _arg0 *C.GtkNotebook // out

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))

C.gtk_notebook_popup_enable(_arg0)
}
	
	// PrependPage prepends a page to @notebook.
	func (n Notebook) PrependPage(child WidgetClass, tabLabel WidgetClass) int {
var _arg0 *C.GtkNotebook // out
var _arg1 *C.GtkWidget // out
var _arg2 *C.GtkWidget // out
var _cret C.gint // in

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
_arg2 = (*C.GtkWidget)(unsafe.Pointer(tabLabel.Native()))

_cret = C.gtk_notebook_prepend_page(_arg0, _arg1, _arg2)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// PrependPageMenu prepends a page to @notebook, specifying the widget to use as
// the label in the popup menu.
	func (n Notebook) PrependPageMenu(child WidgetClass, tabLabel WidgetClass, menuLabel WidgetClass) int {
var _arg0 *C.GtkNotebook // out
var _arg1 *C.GtkWidget // out
var _arg2 *C.GtkWidget // out
var _arg3 *C.GtkWidget // out
var _cret C.gint // in

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
_arg2 = (*C.GtkWidget)(unsafe.Pointer(tabLabel.Native()))
_arg3 = (*C.GtkWidget)(unsafe.Pointer(menuLabel.Native()))

_cret = C.gtk_notebook_prepend_page_menu(_arg0, _arg1, _arg2, _arg3)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// PrevPage switches to the previous page. Nothing happens if the current page
// is the first page.
	func (n Notebook) PrevPage()  {
var _arg0 *C.GtkNotebook // out

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))

C.gtk_notebook_prev_page(_arg0)
}
	
	// RemovePage removes a page from the notebook given its index in the notebook.
	func (n Notebook) RemovePage(pageNum int)  {
var _arg0 *C.GtkNotebook // out
var _arg1 C.gint // out

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
_arg1 = (C.gint)(pageNum)

C.gtk_notebook_remove_page(_arg0, _arg1)
}
	
	// ReorderChild reorders the page containing @child, so that it appears in
// position @position. If @position is greater than or equal to the number of
// children in the list or negative, @child will be moved to the end of the
// list.
	func (n Notebook) ReorderChild(child WidgetClass, position int)  {
var _arg0 *C.GtkNotebook // out
var _arg1 *C.GtkWidget // out
var _arg2 C.gint // out

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
_arg2 = (C.gint)(position)

C.gtk_notebook_reorder_child(_arg0, _arg1, _arg2)
}
	
	// SetActionWidget sets @widget as one of the action widgets. Depending on the
// pack type the widget will be placed before or after the tabs. You can use a
// Box if you need to pack more than one widget on the same side.
// 
// Note that action widgets are “internal” children of the notebook and thus not
// included in the list returned from gtk_container_foreach().
	func (n Notebook) SetActionWidget(widget WidgetClass, packType PackType)  {
var _arg0 *C.GtkNotebook // out
var _arg1 *C.GtkWidget // out
var _arg2 C.GtkPackType // out

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg2 = (C.GtkPackType)(packType)

C.gtk_notebook_set_action_widget(_arg0, _arg1, _arg2)
}
	
	// SetCurrentPage switches to the page number @page_num.
// 
// Note that due to historical reasons, GtkNotebook refuses to switch to a page
// unless the child widget is visible. Therefore, it is recommended to show
// child widgets before adding them to a notebook.
	func (n Notebook) SetCurrentPage(pageNum int)  {
var _arg0 *C.GtkNotebook // out
var _arg1 C.gint // out

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
_arg1 = (C.gint)(pageNum)

C.gtk_notebook_set_current_page(_arg0, _arg1)
}
	
	// SetGroupName sets a group name for @notebook.
// 
// Notebooks with the same name will be able to exchange tabs via drag and drop.
// A notebook with a nil group name will not be able to exchange tabs with any
// other notebook.
	func (n Notebook) SetGroupName(groupName string)  {
var _arg0 *C.GtkNotebook // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
_arg1 = (*C.gchar)(C.CString(groupName))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_notebook_set_group_name(_arg0, _arg1)
}
	
	// SetMenuLabel changes the menu label for the page containing @child.
	func (n Notebook) SetMenuLabel(child WidgetClass, menuLabel WidgetClass)  {
var _arg0 *C.GtkNotebook // out
var _arg1 *C.GtkWidget // out
var _arg2 *C.GtkWidget // out

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
_arg2 = (*C.GtkWidget)(unsafe.Pointer(menuLabel.Native()))

C.gtk_notebook_set_menu_label(_arg0, _arg1, _arg2)
}
	
	// SetMenuLabelText creates a new label and sets it as the menu label of @child.
	func (n Notebook) SetMenuLabelText(child WidgetClass, menuText string)  {
var _arg0 *C.GtkNotebook // out
var _arg1 *C.GtkWidget // out
var _arg2 *C.gchar // out

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
_arg2 = (*C.gchar)(C.CString(menuText))
defer C.free(unsafe.Pointer(_arg2))

C.gtk_notebook_set_menu_label_text(_arg0, _arg1, _arg2)
}
	
	// SetScrollable sets whether the tab label area will have arrows for scrolling
// if there are too many tabs to fit in the area.
	func (n Notebook) SetScrollable(scrollable bool)  {
var _arg0 *C.GtkNotebook // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
if scrollable { _arg1 = C.TRUE }

C.gtk_notebook_set_scrollable(_arg0, _arg1)
}
	
	// SetShowBorder sets whether a bevel will be drawn around the notebook pages.
// This only has a visual effect when the tabs are not shown. See
// gtk_notebook_set_show_tabs().
	func (n Notebook) SetShowBorder(showBorder bool)  {
var _arg0 *C.GtkNotebook // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
if showBorder { _arg1 = C.TRUE }

C.gtk_notebook_set_show_border(_arg0, _arg1)
}
	
	// SetShowTabs sets whether to show the tabs for the notebook or not.
	func (n Notebook) SetShowTabs(showTabs bool)  {
var _arg0 *C.GtkNotebook // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
if showTabs { _arg1 = C.TRUE }

C.gtk_notebook_set_show_tabs(_arg0, _arg1)
}
	
	// SetTabDetachable sets whether the tab can be detached from @notebook to
// another notebook or widget.
// 
// Note that 2 notebooks must share a common group identificator (see
// gtk_notebook_set_group_name()) to allow automatic tabs interchange between
// them.
// 
// If you want a widget to interact with a notebook through DnD (i.e.: accept
// dragged tabs from it) it must be set as a drop destination and accept the
// target “GTK_NOTEBOOK_TAB”. The notebook will fill the selection with a
// GtkWidget** pointing to the child widget that corresponds to the dropped tab.
// 
// Note that you should use gtk_notebook_detach_tab() instead of
// gtk_container_remove() if you want to remove the tab from the source notebook
// as part of accepting a drop. Otherwise, the source notebook will think that
// the dragged tab was removed from underneath the ongoing drag operation, and
// will initiate a drag cancel animation.
// 
//     static void
//     on_drag_data_received (GtkWidget        *widget,
//                            GdkDragContext   *context,
//                            gint              x,
//                            gint              y,
//                            GtkSelectionData *data,
//                            guint             info,
//                            guint             time,
//                            gpointer          user_data)
//     {
//       GtkWidget *notebook;
//       GtkWidget **child;
// 
//       notebook = gtk_drag_get_source_widget (context);
//       child = (void*) gtk_selection_data_get_data (data);
// 
//       // process_widget (*child);
// 
//       gtk_notebook_detach_tab (GTK_NOTEBOOK (notebook), *child);
//     }
// 
// If you want a notebook to accept drags from other widgets, you will have to
// set your own DnD code to do it.
	func (n Notebook) SetTabDetachable(child WidgetClass, detachable bool)  {
var _arg0 *C.GtkNotebook // out
var _arg1 *C.GtkWidget // out
var _arg2 C.gboolean // out

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
if detachable { _arg2 = C.TRUE }

C.gtk_notebook_set_tab_detachable(_arg0, _arg1, _arg2)
}
	
	// SetTabLabel changes the tab label for @child. If nil is specified for
// @tab_label, then the page will have the label “page N”.
	func (n Notebook) SetTabLabel(child WidgetClass, tabLabel WidgetClass)  {
var _arg0 *C.GtkNotebook // out
var _arg1 *C.GtkWidget // out
var _arg2 *C.GtkWidget // out

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
_arg2 = (*C.GtkWidget)(unsafe.Pointer(tabLabel.Native()))

C.gtk_notebook_set_tab_label(_arg0, _arg1, _arg2)
}
	
	// SetTabLabelText creates a new label and sets it as the tab label for the page
// containing @child.
	func (n Notebook) SetTabLabelText(child WidgetClass, tabText string)  {
var _arg0 *C.GtkNotebook // out
var _arg1 *C.GtkWidget // out
var _arg2 *C.gchar // out

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
_arg2 = (*C.gchar)(C.CString(tabText))
defer C.free(unsafe.Pointer(_arg2))

C.gtk_notebook_set_tab_label_text(_arg0, _arg1, _arg2)
}
	
	// SetTabPos sets the edge at which the tabs for switching pages in the notebook
// are drawn.
	func (n Notebook) SetTabPos(pos PositionType)  {
var _arg0 *C.GtkNotebook // out
var _arg1 C.GtkPositionType // out

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
_arg1 = (C.GtkPositionType)(pos)

C.gtk_notebook_set_tab_pos(_arg0, _arg1)
}
	
	// SetTabReorderable sets whether the notebook tab can be reordered via drag and
// drop or not.
	func (n Notebook) SetTabReorderable(child WidgetClass, reorderable bool)  {
var _arg0 *C.GtkNotebook // out
var _arg1 *C.GtkWidget // out
var _arg2 C.gboolean // out

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
if reorderable { _arg2 = C.TRUE }

C.gtk_notebook_set_tab_reorderable(_arg0, _arg1, _arg2)
}
	


	// NumerableIcon: gtkNumerableIcon is a subclass of Icon that can show a number
// or short string as an emblem. The number can be overlayed on top of another
// emblem, if desired.
// 
// It supports theming by taking font and color information from a provided
// StyleContext; see gtk_numerable_icon_set_style_context().
// 
// Typical numerable icons: ! (numerableicon.png) ! (numerableicon2.png)
	type NumerableIcon struct {
		gio.EmblemedIcon
		gio.Icon
		
	}

	// NumerableIconClass is an interface that the NumerableIcon class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type NumerableIconClass interface {
		gextras.Objector
		_numerableIcon()
	}

	func (NumerableIcon) _numerableIcon() {}

	
	func marshalNumerableIcon(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapNumerableIcon(obj), nil
	}
	

	

	
	// BackgroundGIcon returns the #GIcon that was set as the base background image,
// or nil if there’s none. The caller of this function does not own a reference
// to the returned #GIcon.
	func (s NumerableIcon) BackgroundGIcon() gio.Icon {
var _arg0 *C.GtkNumerableIcon // out
var _cret *C.GIcon // in

_arg0 = (*C.GtkNumerableIcon)(unsafe.Pointer(s.Native()))

_cret = C.gtk_numerable_icon_get_background_gicon(_arg0)


var _icon gio.Icon // out

_icon = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.Icon)

return _icon
}
	
	// BackgroundIconName returns the icon name used as the base background image,
// or nil if there’s none.
	func (s NumerableIcon) BackgroundIconName() string {
var _arg0 *C.GtkNumerableIcon // out
var _cret *C.gchar // in

_arg0 = (*C.GtkNumerableIcon)(unsafe.Pointer(s.Native()))

_cret = C.gtk_numerable_icon_get_background_icon_name(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Count returns the value currently displayed by @self.
	func (s NumerableIcon) Count() int {
var _arg0 *C.GtkNumerableIcon // out
var _cret C.gint // in

_arg0 = (*C.GtkNumerableIcon)(unsafe.Pointer(s.Native()))

_cret = C.gtk_numerable_icon_get_count(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Label returns the currently displayed label of the icon, or nil.
	func (s NumerableIcon) Label() string {
var _arg0 *C.GtkNumerableIcon // out
var _cret *C.gchar // in

_arg0 = (*C.GtkNumerableIcon)(unsafe.Pointer(s.Native()))

_cret = C.gtk_numerable_icon_get_label(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// StyleContext returns the StyleContext used by the icon for theming, or nil if
// there’s none.
	func (s NumerableIcon) StyleContext() StyleContext {
var _arg0 *C.GtkNumerableIcon // out
var _cret *C.GtkStyleContext // in

_arg0 = (*C.GtkNumerableIcon)(unsafe.Pointer(s.Native()))

_cret = C.gtk_numerable_icon_get_style_context(_arg0)


var _styleContext StyleContext // out

_styleContext = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(StyleContext)

return _styleContext
}
	
	// SetBackgroundGIcon updates the icon to use @icon as the base background
// image. If @icon is nil, @self will go back using style information or default
// theming for its background image.
// 
// If this method is called and an icon name was already set as background for
// the icon, @icon will be used, i.e. the last method called between
// gtk_numerable_icon_set_background_gicon() and
// gtk_numerable_icon_set_background_icon_name() has always priority.
	func (s NumerableIcon) SetBackgroundGIcon(icon gio.Icon)  {
var _arg0 *C.GtkNumerableIcon // out
var _arg1 *C.GIcon // out

_arg0 = (*C.GtkNumerableIcon)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GIcon)(unsafe.Pointer(icon.Native()))

C.gtk_numerable_icon_set_background_gicon(_arg0, _arg1)
}
	
	// SetBackgroundIconName updates the icon to use the icon named @icon_name from
// the current icon theme as the base background image. If @icon_name is nil,
// @self will go back using style information or default theming for its
// background image.
// 
// If this method is called and a #GIcon was already set as background for the
// icon, @icon_name will be used, i.e. the last method called between
// gtk_numerable_icon_set_background_icon_name() and
// gtk_numerable_icon_set_background_gicon() has always priority.
	func (s NumerableIcon) SetBackgroundIconName(iconName string)  {
var _arg0 *C.GtkNumerableIcon // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkNumerableIcon)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(iconName))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_numerable_icon_set_background_icon_name(_arg0, _arg1)
}
	
	// SetCount sets the currently displayed value of @self to @count.
// 
// The numeric value is always clamped to make it two digits, i.e. between -99
// and 99. Setting a count of zero removes the emblem. If this method is called,
// and a label was already set on the icon, it will automatically be reset to
// nil before rendering the number, i.e. the last method called between
// gtk_numerable_icon_set_count() and gtk_numerable_icon_set_label() has always
// priority.
	func (s NumerableIcon) SetCount(count int)  {
var _arg0 *C.GtkNumerableIcon // out
var _arg1 C.gint // out

_arg0 = (*C.GtkNumerableIcon)(unsafe.Pointer(s.Native()))
_arg1 = (C.gint)(count)

C.gtk_numerable_icon_set_count(_arg0, _arg1)
}
	
	// SetLabel sets the currently displayed value of @self to the string in @label.
// Setting an empty label removes the emblem.
// 
// Note that this is meant for displaying short labels, such as roman numbers,
// or single letters. For roman numbers, consider using the Unicode characters
// U+2160 - U+217F. Strings longer than two characters will likely not be
// rendered very well.
// 
// If this method is called, and a number was already set on the icon, it will
// automatically be reset to zero before rendering the label, i.e. the last
// method called between gtk_numerable_icon_set_label() and
// gtk_numerable_icon_set_count() has always priority.
	func (s NumerableIcon) SetLabel(label string)  {
var _arg0 *C.GtkNumerableIcon // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkNumerableIcon)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(label))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_numerable_icon_set_label(_arg0, _arg1)
}
	
	// SetStyleContext updates the icon to fetch theme information from the given
// StyleContext.
	func (s NumerableIcon) SetStyleContext(style StyleContextClass)  {
var _arg0 *C.GtkNumerableIcon // out
var _arg1 *C.GtkStyleContext // out

_arg0 = (*C.GtkNumerableIcon)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(style.Native()))

C.gtk_numerable_icon_set_style_context(_arg0, _arg1)
}
	


	// OffscreenWindow: gtkOffscreenWindow is strictly intended to be used for
// obtaining snapshots of widgets that are not part of a normal widget
// hierarchy. Since OffscreenWindow is a toplevel widget you cannot obtain
// snapshots of a full window with it since you cannot pack a toplevel widget in
// another toplevel.
// 
// The idea is to take a widget and manually set the state of it, add it to a
// GtkOffscreenWindow and then retrieve the snapshot as a #cairo_surface_t or
// Pixbuf.
// 
// GtkOffscreenWindow derives from Window only as an implementation detail.
// Applications should not use any API specific to Window to operate on this
// object. It should be treated as a Bin that has no parent widget.
// 
// When contained offscreen widgets are redrawn, GtkOffscreenWindow will emit a
// Widget::damage-event signal.
	type OffscreenWindow struct {
		Window
		Buildable
		
	}

	// OffscreenWindowClass is an interface that the OffscreenWindow class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type OffscreenWindowClass interface {
		gextras.Objector
		_offscreenWindow()
	}

	func (OffscreenWindow) _offscreenWindow() {}

	
	func marshalOffscreenWindow(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapOffscreenWindow(obj), nil
	}
	

	
	// NewOffscreenWindow creates a toplevel container widget that is used to
// retrieve snapshots of widgets without showing them on the screen.
	func NewOffscreenWindow() OffscreenWindow {
var _cret *C.GtkWidget // in

_cret = C.gtk_offscreen_window_new()


var _offscreenWindow OffscreenWindow // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_offscreenWindow = OffscreenWindow{
Window: Window{
Bin: Bin{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _offscreenWindow
}
	

	
	// Pixbuf retrieves a snapshot of the contained widget in the form of a Pixbuf.
// This is a new pixbuf with a reference count of 1, and the application should
// unreference it once it is no longer needed.
	func (o OffscreenWindow) Pixbuf() gdkpixbuf.Pixbuf {
var _arg0 *C.GtkOffscreenWindow // out
var _cret *C.GdkPixbuf // in

_arg0 = (*C.GtkOffscreenWindow)(unsafe.Pointer(o.Native()))

_cret = C.gtk_offscreen_window_get_pixbuf(_arg0)


var _pixbuf gdkpixbuf.Pixbuf // out

_pixbuf = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gdkpixbuf.Pixbuf)

return _pixbuf
}
	
	// Surface retrieves a snapshot of the contained widget in the form of a
// #cairo_surface_t. If you need to keep this around over window resizes then
// you should add a reference to it.
	func (o OffscreenWindow) Surface() *cairo.Surface {
var _arg0 *C.GtkOffscreenWindow // out
var _cret *C.cairo_surface_t // in

_arg0 = (*C.GtkOffscreenWindow)(unsafe.Pointer(o.Native()))

_cret = C.gtk_offscreen_window_get_surface(_arg0)


var _surface *cairo.Surface // out

_surface = *(**cairo.Surface)(unsafe.Pointer(&_cret))

return _surface
}
	


	// Overlay: gtkOverlay is a container which contains a single main child, on top
// of which it can place “overlay” widgets. The position of each overlay widget
// is determined by its Widget:halign and Widget:valign properties. E.g. a
// widget with both alignments set to GTK_ALIGN_START will be placed at the top
// left corner of the GtkOverlay container, whereas an overlay with halign set
// to GTK_ALIGN_CENTER and valign set to GTK_ALIGN_END will be placed a the
// bottom edge of the GtkOverlay, horizontally centered. The position can be
// adjusted by setting the margin properties of the child to non-zero values.
// 
// More complicated placement of overlays is possible by connecting to the
// Overlay::get-child-position signal.
// 
// An overlay’s minimum and natural sizes are those of its main child. The sizes
// of overlay children are not considered when measuring these preferred sizes.
// 
// 
// GtkOverlay as GtkBuildable
// 
// The GtkOverlay implementation of the GtkBuildable interface supports placing
// a child as an overlay by specifying “overlay” as the “type” attribute of a
// `<child>` element.
// 
// 
// CSS nodes
// 
// GtkOverlay has a single CSS node with the name “overlay”. Overlay children
// whose alignments cause them to be positioned at an edge get the style classes
// “.left”, “.right”, “.top”, and/or “.bottom” according to their position.
	type Overlay struct {
		Bin
		Buildable
		
	}

	// OverlayClass is an interface that the Overlay class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type OverlayClass interface {
		gextras.Objector
		_overlay()
	}

	func (Overlay) _overlay() {}

	
	func marshalOverlay(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapOverlay(obj), nil
	}
	

	
	// NewOverlay creates a new Overlay.
	func NewOverlay() Overlay {
var _cret *C.GtkWidget // in

_cret = C.gtk_overlay_new()


var _overlay Overlay // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_overlay = Overlay{
Bin: Bin{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _overlay
}
	

	
	// AddOverlay adds @widget to @overlay.
// 
// The widget will be stacked on top of the main widget added with
// gtk_container_add().
// 
// The position at which @widget is placed is determined from its Widget:halign
// and Widget:valign properties.
	func (o Overlay) AddOverlay(widget WidgetClass)  {
var _arg0 *C.GtkOverlay // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkOverlay)(unsafe.Pointer(o.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

C.gtk_overlay_add_overlay(_arg0, _arg1)
}
	
	// OverlayPassThrough: convenience function to get the value of the
// Overlay:pass-through child property for @widget.
	func (o Overlay) OverlayPassThrough(widget WidgetClass) bool {
var _arg0 *C.GtkOverlay // out
var _arg1 *C.GtkWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkOverlay)(unsafe.Pointer(o.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

_cret = C.gtk_overlay_get_overlay_pass_through(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ReorderOverlay moves @child to a new @index in the list of @overlay children.
// The list contains overlays in the order that these were added to @overlay by
// default. See also Overlay:index.
// 
// A widget’s index in the @overlay children list determines which order the
// children are drawn if they overlap. The first child is drawn at the bottom.
// It also affects the default focus chain order.
	func (o Overlay) ReorderOverlay(child WidgetClass, index_ int)  {
var _arg0 *C.GtkOverlay // out
var _arg1 *C.GtkWidget // out
var _arg2 C.int // out

_arg0 = (*C.GtkOverlay)(unsafe.Pointer(o.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
_arg2 = (C.int)(index_)

C.gtk_overlay_reorder_overlay(_arg0, _arg1, _arg2)
}
	
	// SetOverlayPassThrough: convenience function to set the value of the
// Overlay:pass-through child property for @widget.
	func (o Overlay) SetOverlayPassThrough(widget WidgetClass, passThrough bool)  {
var _arg0 *C.GtkOverlay // out
var _arg1 *C.GtkWidget // out
var _arg2 C.gboolean // out

_arg0 = (*C.GtkOverlay)(unsafe.Pointer(o.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
if passThrough { _arg2 = C.TRUE }

C.gtk_overlay_set_overlay_pass_through(_arg0, _arg1, _arg2)
}
	


	// PadController is an event controller for the pads found in drawing tablets
// (The collection of buttons and tactile sensors often found around the
// stylus-sensitive area).
// 
// These buttons and sensors have no implicit meaning, and by default they
// perform no action, this event controller is provided to map those to #GAction
// objects, thus letting the application give those a more semantic meaning.
// 
// Buttons and sensors are not constrained to triggering a single action, some
// GDK_SOURCE_TABLET_PAD devices feature multiple "modes", all these input
// elements have one current mode, which may determine the final action being
// triggered. Pad devices often divide buttons and sensors into groups, all
// elements in a group share the same current mode, but different groups may
// have different modes. See gdk_device_pad_get_n_groups() and
// gdk_device_pad_get_group_n_modes().
// 
// Each of the actions that a given button/strip/ring performs for a given mode
// is defined by PadActionEntry, it contains an action name that will be looked
// up in the given Group and activated whenever the specified input element and
// mode are triggered.
// 
// A simple example of PadController usage, assigning button 1 in all modes and
// pad devices to an "invert-selection" action:
// 
//      GtkPadActionEntry *pad_actions[] = {
//        { GTK_PAD_ACTION_BUTTON, 1, -1, "Invert selection", "pad-actions.invert-selection" },
//        …
//      };
// 
//      …
//      action_group = g_simple_action_group_new ();
//      action = g_simple_action_new ("pad-actions.invert-selection", NULL);
//      g_signal_connect (action, "activate", on_invert_selection_activated, NULL);
//      g_action_map_add_action (G_ACTION_MAP (action_group), action);
//      …
//      pad_controller = gtk_pad_controller_new (window, action_group, NULL);
// 
// The actions belonging to rings/strips will be activated with a parameter of
// type G_VARIANT_TYPE_DOUBLE bearing the value of the given axis, it is
// required that those are made stateful and accepting this Type.
	type PadController struct {
		EventController
		
	}

	// PadControllerClass is an interface that the PadController class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type PadControllerClass interface {
		gextras.Objector
		_padController()
	}

	func (PadController) _padController() {}

	
	func marshalPadController(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapPadController(obj), nil
	}
	

	
	// NewPadController creates a new PadController that will associate events from
// @pad to actions. A nil pad may be provided so the controller manages all pad
// devices generically, it is discouraged to mix PadController objects with nil
// and non-nil @pad argument on the same @window, as execution order is not
// guaranteed.
// 
// The PadController is created with no mapped actions. In order to map pad
// events to actions, use gtk_pad_controller_set_action_entries() or
// gtk_pad_controller_set_action().
	func NewPadController(window WindowClass, group gio.ActionGroup, pad gdk.DeviceClass) PadController {
var _arg1 *C.GtkWindow // out
var _arg2 *C.GActionGroup // out
var _arg3 *C.GdkDevice // out
var _cret *C.GtkPadController // in

_arg1 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
_arg2 = (*C.GActionGroup)(unsafe.Pointer(group.Native()))
_arg3 = (*C.GdkDevice)(unsafe.Pointer(pad.Native()))

_cret = C.gtk_pad_controller_new(_arg1, _arg2, _arg3)


var _padController PadController // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_padController = PadController{
EventController: EventController{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _padController
}
	

	
	// SetAction adds an individual action to @controller. This action will only be
// activated if the given button/ring/strip number in @index is interacted while
// the current mode is @mode. -1 may be used for simple cases, so the action is
// triggered on all modes.
// 
// The given @label should be considered user-visible, so internationalization
// rules apply. Some windowing systems may be able to use those for user
// feedback.
	func (c PadController) SetAction(typ PadActionType, index int, mode int, label string, actionName string)  {
var _arg0 *C.GtkPadController // out
var _arg1 C.GtkPadActionType // out
var _arg2 C.gint // out
var _arg3 C.gint // out
var _arg4 *C.gchar // out
var _arg5 *C.gchar // out

_arg0 = (*C.GtkPadController)(unsafe.Pointer(c.Native()))
_arg1 = (C.GtkPadActionType)(typ)
_arg2 = (C.gint)(index)
_arg3 = (C.gint)(mode)
_arg4 = (*C.gchar)(C.CString(label))
defer C.free(unsafe.Pointer(_arg4))
_arg5 = (*C.gchar)(C.CString(actionName))
defer C.free(unsafe.Pointer(_arg5))

C.gtk_pad_controller_set_action(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
}
	
	// SetActionEntries: this is a convenience function to add a group of action
// entries on @controller. See PadActionEntry and
// gtk_pad_controller_set_action().
	func (c PadController) SetActionEntries(entries []PadActionEntry)  {
var _arg0 *C.GtkPadController // out
var _arg1 *C.GtkPadActionEntry
var _arg2 C.gint

_arg0 = (*C.GtkPadController)(unsafe.Pointer(c.Native()))
_arg2 = C.gint(len(entries))
_arg1 = (*C.GtkPadActionEntry)(unsafe.Pointer(&entries[0]))

C.gtk_pad_controller_set_action_entries(_arg0, _arg1, _arg2)
}
	


	// PageSetup: a GtkPageSetup object stores the page size, orientation and
// margins. The idea is that you can get one of these from the page setup dialog
// and then pass it to the PrintOperation when printing. The benefit of
// splitting this out of the PrintSettings is that these affect the actual
// layout of the page, and thus need to be set long before user prints.
// 
// 
// Margins
// 
// The margins specified in this object are the “print margins”, i.e. the parts
// of the page that the printer cannot print on. These are different from the
// layout margins that a word processor uses; they are typically used to
// determine the minimal size for the layout margins.
// 
// To obtain a PageSetup use gtk_page_setup_new() to get the defaults, or use
// gtk_print_run_page_setup_dialog() to show the page setup dialog and receive
// the resulting page setup.
// 
// A page setup dialog
// 
//    static GtkPrintSettings *settings = NULL;
//    static GtkPageSetup *page_setup = NULL;
// 
//    static void
//    do_page_setup (void)
//    {
//      GtkPageSetup *new_page_setup;
// 
//      if (settings == NULL)
//        settings = gtk_print_settings_new ();
// 
//      new_page_setup = gtk_print_run_page_setup_dialog (GTK_WINDOW (main_window),
//                                                        page_setup, settings);
// 
//      if (page_setup)
//        g_object_unref (page_setup);
// 
//      page_setup = new_page_setup;
//    }
// 
// Printing support was added in GTK+ 2.10.
	type PageSetup struct {
		**externglib.Object
		
	}

	// PageSetupClass is an interface that the PageSetup class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type PageSetupClass interface {
		gextras.Objector
		_pageSetup()
	}

	func (PageSetup) _pageSetup() {}

	
	func marshalPageSetup(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapPageSetup(obj), nil
	}
	

	
	// NewPageSetup creates a new PageSetup.
	func NewPageSetup() PageSetup {
var _cret *C.GtkPageSetup // in

_cret = C.gtk_page_setup_new()


var _pageSetup PageSetup // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_pageSetup = PageSetup{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}

return _pageSetup
}
	
	// NewPageSetupFromFile reads the page setup from the file @file_name. Returns a
// new PageSetup object with the restored page setup, or nil if an error
// occurred. See gtk_page_setup_to_file().
	func NewPageSetupFromFile(fileName string) (PageSetup, error) {
var _arg1 *C.gchar // out
var _cret *C.GtkPageSetup // in
var _cerr *C.GError // in

_arg1 = (*C.gchar)(C.CString(fileName))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_page_setup_new_from_file(_arg1, &_cerr)


var _pageSetup PageSetup // out
var _goerr error // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_pageSetup = PageSetup{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _pageSetup, _goerr
}
	
	// NewPageSetupFromGVariant: desrialize a page setup from an a{sv} variant in
// the format produced by gtk_page_setup_to_gvariant().
	func NewPageSetupFromGVariant(variant *glib.Variant) PageSetup {
var _arg1 *C.GVariant // out
var _cret *C.GtkPageSetup // in

_arg1 = (*C.GVariant)(unsafe.Pointer(variant.Native()))

_cret = C.gtk_page_setup_new_from_gvariant(_arg1)


var _pageSetup PageSetup // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_pageSetup = PageSetup{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}

return _pageSetup
}
	
	// NewPageSetupFromKeyFile reads the page setup from the group @group_name in
// the key file @key_file. Returns a new PageSetup object with the restored page
// setup, or nil if an error occurred.
	func NewPageSetupFromKeyFile(keyFile *glib.KeyFile, groupName string) (PageSetup, error) {
var _arg1 *C.GKeyFile // out
var _arg2 *C.gchar // out
var _cret *C.GtkPageSetup // in
var _cerr *C.GError // in

_arg1 = (*C.GKeyFile)(unsafe.Pointer(keyFile.Native()))
_arg2 = (*C.gchar)(C.CString(groupName))
defer C.free(unsafe.Pointer(_arg2))

_cret = C.gtk_page_setup_new_from_key_file(_arg1, _arg2, &_cerr)


var _pageSetup PageSetup // out
var _goerr error // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_pageSetup = PageSetup{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _pageSetup, _goerr
}
	

	
	// Copy copies a PageSetup.
	func (o PageSetup) Copy() PageSetup {
var _arg0 *C.GtkPageSetup // out
var _cret *C.GtkPageSetup // in

_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(o.Native()))

_cret = C.gtk_page_setup_copy(_arg0)


var _pageSetup PageSetup // out

_pageSetup = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(PageSetup)

return _pageSetup
}
	
	// BottomMargin gets the bottom margin in units of @unit.
	func (s PageSetup) BottomMargin(unit Unit) float64 {
var _arg0 *C.GtkPageSetup // out
var _arg1 C.GtkUnit // out
var _cret C.gdouble // in

_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkUnit)(unit)

_cret = C.gtk_page_setup_get_bottom_margin(_arg0, _arg1)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// LeftMargin gets the left margin in units of @unit.
	func (s PageSetup) LeftMargin(unit Unit) float64 {
var _arg0 *C.GtkPageSetup // out
var _arg1 C.GtkUnit // out
var _cret C.gdouble // in

_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkUnit)(unit)

_cret = C.gtk_page_setup_get_left_margin(_arg0, _arg1)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// Orientation gets the page orientation of the PageSetup.
	func (s PageSetup) Orientation() PageOrientation {
var _arg0 *C.GtkPageSetup // out
var _cret C.GtkPageOrientation // in

_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))

_cret = C.gtk_page_setup_get_orientation(_arg0)


var _pageOrientation PageOrientation // out

_pageOrientation = PageOrientation(_cret)

return _pageOrientation
}
	
	// PageHeight returns the page height in units of @unit.
// 
// Note that this function takes orientation and margins into consideration. See
// gtk_page_setup_get_paper_height().
	func (s PageSetup) PageHeight(unit Unit) float64 {
var _arg0 *C.GtkPageSetup // out
var _arg1 C.GtkUnit // out
var _cret C.gdouble // in

_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkUnit)(unit)

_cret = C.gtk_page_setup_get_page_height(_arg0, _arg1)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// PageWidth returns the page width in units of @unit.
// 
// Note that this function takes orientation and margins into consideration. See
// gtk_page_setup_get_paper_width().
	func (s PageSetup) PageWidth(unit Unit) float64 {
var _arg0 *C.GtkPageSetup // out
var _arg1 C.GtkUnit // out
var _cret C.gdouble // in

_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkUnit)(unit)

_cret = C.gtk_page_setup_get_page_width(_arg0, _arg1)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// PaperHeight returns the paper height in units of @unit.
// 
// Note that this function takes orientation, but not margins into
// consideration. See gtk_page_setup_get_page_height().
	func (s PageSetup) PaperHeight(unit Unit) float64 {
var _arg0 *C.GtkPageSetup // out
var _arg1 C.GtkUnit // out
var _cret C.gdouble // in

_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkUnit)(unit)

_cret = C.gtk_page_setup_get_paper_height(_arg0, _arg1)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// PaperSize gets the paper size of the PageSetup.
	func (s PageSetup) PaperSize() *PaperSize {
var _arg0 *C.GtkPageSetup // out
var _cret *C.GtkPaperSize // in

_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))

_cret = C.gtk_page_setup_get_paper_size(_arg0)


var _paperSize *PaperSize // out

_paperSize = *(**PaperSize)(unsafe.Pointer(&_cret))

return _paperSize
}
	
	// PaperWidth returns the paper width in units of @unit.
// 
// Note that this function takes orientation, but not margins into
// consideration. See gtk_page_setup_get_page_width().
	func (s PageSetup) PaperWidth(unit Unit) float64 {
var _arg0 *C.GtkPageSetup // out
var _arg1 C.GtkUnit // out
var _cret C.gdouble // in

_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkUnit)(unit)

_cret = C.gtk_page_setup_get_paper_width(_arg0, _arg1)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// RightMargin gets the right margin in units of @unit.
	func (s PageSetup) RightMargin(unit Unit) float64 {
var _arg0 *C.GtkPageSetup // out
var _arg1 C.GtkUnit // out
var _cret C.gdouble // in

_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkUnit)(unit)

_cret = C.gtk_page_setup_get_right_margin(_arg0, _arg1)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// TopMargin gets the top margin in units of @unit.
	func (s PageSetup) TopMargin(unit Unit) float64 {
var _arg0 *C.GtkPageSetup // out
var _arg1 C.GtkUnit // out
var _cret C.gdouble // in

_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkUnit)(unit)

_cret = C.gtk_page_setup_get_top_margin(_arg0, _arg1)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// LoadFile reads the page setup from the file @file_name. See
// gtk_page_setup_to_file().
	func (s PageSetup) LoadFile(fileName string) error {
var _arg0 *C.GtkPageSetup // out
var _arg1 *C.char // out
var _cerr *C.GError // in

_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
_arg1 = (*C.char)(C.CString(fileName))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_page_setup_load_file(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// LoadKeyFile reads the page setup from the group @group_name in the key file
// @key_file.
	func (s PageSetup) LoadKeyFile(keyFile *glib.KeyFile, groupName string) error {
var _arg0 *C.GtkPageSetup // out
var _arg1 *C.GKeyFile // out
var _arg2 *C.gchar // out
var _cerr *C.GError // in

_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GKeyFile)(unsafe.Pointer(keyFile.Native()))
_arg2 = (*C.gchar)(C.CString(groupName))
defer C.free(unsafe.Pointer(_arg2))

C.gtk_page_setup_load_key_file(_arg0, _arg1, _arg2, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// SetBottomMargin sets the bottom margin of the PageSetup.
	func (s PageSetup) SetBottomMargin(margin float64, unit Unit)  {
var _arg0 *C.GtkPageSetup // out
var _arg1 C.gdouble // out
var _arg2 C.GtkUnit // out

_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
_arg1 = (C.gdouble)(margin)
_arg2 = (C.GtkUnit)(unit)

C.gtk_page_setup_set_bottom_margin(_arg0, _arg1, _arg2)
}
	
	// SetLeftMargin sets the left margin of the PageSetup.
	func (s PageSetup) SetLeftMargin(margin float64, unit Unit)  {
var _arg0 *C.GtkPageSetup // out
var _arg1 C.gdouble // out
var _arg2 C.GtkUnit // out

_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
_arg1 = (C.gdouble)(margin)
_arg2 = (C.GtkUnit)(unit)

C.gtk_page_setup_set_left_margin(_arg0, _arg1, _arg2)
}
	
	// SetOrientation sets the page orientation of the PageSetup.
	func (s PageSetup) SetOrientation(orientation PageOrientation)  {
var _arg0 *C.GtkPageSetup // out
var _arg1 C.GtkPageOrientation // out

_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkPageOrientation)(orientation)

C.gtk_page_setup_set_orientation(_arg0, _arg1)
}
	
	// SetPaperSize sets the paper size of the PageSetup without changing the
// margins. See gtk_page_setup_set_paper_size_and_default_margins().
	func (s PageSetup) SetPaperSize(size *PaperSize)  {
var _arg0 *C.GtkPageSetup // out
var _arg1 *C.GtkPaperSize // out

_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkPaperSize)(unsafe.Pointer(size.Native()))

C.gtk_page_setup_set_paper_size(_arg0, _arg1)
}
	
	// SetPaperSizeAndDefaultMargins sets the paper size of the PageSetup and
// modifies the margins according to the new paper size.
	func (s PageSetup) SetPaperSizeAndDefaultMargins(size *PaperSize)  {
var _arg0 *C.GtkPageSetup // out
var _arg1 *C.GtkPaperSize // out

_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkPaperSize)(unsafe.Pointer(size.Native()))

C.gtk_page_setup_set_paper_size_and_default_margins(_arg0, _arg1)
}
	
	// SetRightMargin sets the right margin of the PageSetup.
	func (s PageSetup) SetRightMargin(margin float64, unit Unit)  {
var _arg0 *C.GtkPageSetup // out
var _arg1 C.gdouble // out
var _arg2 C.GtkUnit // out

_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
_arg1 = (C.gdouble)(margin)
_arg2 = (C.GtkUnit)(unit)

C.gtk_page_setup_set_right_margin(_arg0, _arg1, _arg2)
}
	
	// SetTopMargin sets the top margin of the PageSetup.
	func (s PageSetup) SetTopMargin(margin float64, unit Unit)  {
var _arg0 *C.GtkPageSetup // out
var _arg1 C.gdouble // out
var _arg2 C.GtkUnit // out

_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
_arg1 = (C.gdouble)(margin)
_arg2 = (C.GtkUnit)(unit)

C.gtk_page_setup_set_top_margin(_arg0, _arg1, _arg2)
}
	
	// ToFile: this function saves the information from @setup to @file_name.
	func (s PageSetup) ToFile(fileName string) error {
var _arg0 *C.GtkPageSetup // out
var _arg1 *C.char // out
var _cerr *C.GError // in

_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
_arg1 = (*C.char)(C.CString(fileName))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_page_setup_to_file(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// ToGVariant: serialize page setup to an a{sv} variant.
	func (s PageSetup) ToGVariant() *glib.Variant {
var _arg0 *C.GtkPageSetup // out
var _cret *C.GVariant // in

_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))

_cret = C.gtk_page_setup_to_gvariant(_arg0)


var _variant *glib.Variant // out

_variant = *(**glib.Variant)(unsafe.Pointer(&_cret))

return _variant
}
	
	// ToKeyFile: this function adds the page setup from @setup to @key_file.
	func (s PageSetup) ToKeyFile(keyFile *glib.KeyFile, groupName string)  {
var _arg0 *C.GtkPageSetup // out
var _arg1 *C.GKeyFile // out
var _arg2 *C.gchar // out

_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GKeyFile)(unsafe.Pointer(keyFile.Native()))
_arg2 = (*C.gchar)(C.CString(groupName))
defer C.free(unsafe.Pointer(_arg2))

C.gtk_page_setup_to_key_file(_arg0, _arg1, _arg2)
}
	


	// Paned has two panes, arranged either horizontally or vertically. The division
// between the two panes is adjustable by the user by dragging a handle.
// 
// Child widgets are added to the panes of the widget with gtk_paned_pack1() and
// gtk_paned_pack2(). The division between the two children is set by default
// from the size requests of the children, but it can be adjusted by the user.
// 
// A paned widget draws a separator between the two child widgets and a small
// handle that the user can drag to adjust the division. It does not draw any
// relief around the children or around the separator. (The space in which the
// separator is called the gutter.) Often, it is useful to put each child inside
// a Frame with the shadow type set to GTK_SHADOW_IN so that the gutter appears
// as a ridge. No separator is drawn if one of the children is missing.
// 
// Each child has two options that can be set, @resize and @shrink. If @resize
// is true, then when the Paned is resized, that child will expand or shrink
// along with the paned widget. If @shrink is true, then that child can be made
// smaller than its requisition by the user. Setting @shrink to false allows the
// application to set a minimum size. If @resize is false for both children,
// then this is treated as if @resize is true for both children.
// 
// The application can set the position of the slider as if it were set by the
// user, by calling gtk_paned_set_position().
// 
// CSS nodes
// 
//    GtkWidget *hpaned = gtk_paned_new (GTK_ORIENTATION_HORIZONTAL);
//    GtkWidget *frame1 = gtk_frame_new (NULL);
//    GtkWidget *frame2 = gtk_frame_new (NULL);
//    gtk_frame_set_shadow_type (GTK_FRAME (frame1), GTK_SHADOW_IN);
//    gtk_frame_set_shadow_type (GTK_FRAME (frame2), GTK_SHADOW_IN);
// 
//    gtk_widget_set_size_request (hpaned, 200, -1);
// 
//    gtk_paned_pack1 (GTK_PANED (hpaned), frame1, TRUE, FALSE);
//    gtk_widget_set_size_request (frame1, 50, -1);
// 
//    gtk_paned_pack2 (GTK_PANED (hpaned), frame2, FALSE, FALSE);
//    gtk_widget_set_size_request (frame2, 50, -1);
	type Paned struct {
		Container
		Buildable
		Orientable
		
	}

	// PanedClass is an interface that the Paned class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type PanedClass interface {
		gextras.Objector
		_paned()
	}

	func (Paned) _paned() {}

	
	func marshalPaned(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapPaned(obj), nil
	}
	

	
	// NewPaned creates a new Paned widget.
	func NewPaned(orientation Orientation) Paned {
var _arg1 C.GtkOrientation // out
var _cret *C.GtkWidget // in

_arg1 = (C.GtkOrientation)(orientation)

_cret = C.gtk_paned_new(_arg1)


var _paned Paned // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_paned = Paned{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _paned
}
	

	
	// Add1 adds a child to the top or left pane with default parameters. This is
// equivalent to `gtk_paned_pack1 (paned, child, FALSE, TRUE)`.
	func (p Paned) Add1(child WidgetClass)  {
var _arg0 *C.GtkPaned // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkPaned)(unsafe.Pointer(p.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

C.gtk_paned_add1(_arg0, _arg1)
}
	
	// Add2 adds a child to the bottom or right pane with default parameters. This
// is equivalent to `gtk_paned_pack2 (paned, child, TRUE, TRUE)`.
	func (p Paned) Add2(child WidgetClass)  {
var _arg0 *C.GtkPaned // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkPaned)(unsafe.Pointer(p.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

C.gtk_paned_add2(_arg0, _arg1)
}
	
	// Child1 obtains the first child of the paned widget.
	func (p Paned) Child1() Widget {
var _arg0 *C.GtkPaned // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkPaned)(unsafe.Pointer(p.Native()))

_cret = C.gtk_paned_get_child1(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// Child2 obtains the second child of the paned widget.
	func (p Paned) Child2() Widget {
var _arg0 *C.GtkPaned // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkPaned)(unsafe.Pointer(p.Native()))

_cret = C.gtk_paned_get_child2(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// HandleWindow returns the Window of the handle. This function is useful when
// handling button or motion events because it enables the callback to
// distinguish between the window of the paned, a child and the handle.
	func (p Paned) HandleWindow() gdk.Window {
var _arg0 *C.GtkPaned // out
var _cret *C.GdkWindow // in

_arg0 = (*C.GtkPaned)(unsafe.Pointer(p.Native()))

_cret = C.gtk_paned_get_handle_window(_arg0)


var _window gdk.Window // out

_window = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Window)

return _window
}
	
	// Position obtains the position of the divider between the two panes.
	func (p Paned) Position() int {
var _arg0 *C.GtkPaned // out
var _cret C.gint // in

_arg0 = (*C.GtkPaned)(unsafe.Pointer(p.Native()))

_cret = C.gtk_paned_get_position(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// WideHandle gets the Paned:wide-handle property.
	func (p Paned) WideHandle() bool {
var _arg0 *C.GtkPaned // out
var _cret C.gboolean // in

_arg0 = (*C.GtkPaned)(unsafe.Pointer(p.Native()))

_cret = C.gtk_paned_get_wide_handle(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Pack1 adds a child to the top or left pane.
	func (p Paned) Pack1(child WidgetClass, resize bool, shrink bool)  {
var _arg0 *C.GtkPaned // out
var _arg1 *C.GtkWidget // out
var _arg2 C.gboolean // out
var _arg3 C.gboolean // out

_arg0 = (*C.GtkPaned)(unsafe.Pointer(p.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
if resize { _arg2 = C.TRUE }
if shrink { _arg3 = C.TRUE }

C.gtk_paned_pack1(_arg0, _arg1, _arg2, _arg3)
}
	
	// Pack2 adds a child to the bottom or right pane.
	func (p Paned) Pack2(child WidgetClass, resize bool, shrink bool)  {
var _arg0 *C.GtkPaned // out
var _arg1 *C.GtkWidget // out
var _arg2 C.gboolean // out
var _arg3 C.gboolean // out

_arg0 = (*C.GtkPaned)(unsafe.Pointer(p.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
if resize { _arg2 = C.TRUE }
if shrink { _arg3 = C.TRUE }

C.gtk_paned_pack2(_arg0, _arg1, _arg2, _arg3)
}
	
	// SetPosition sets the position of the divider between the two panes.
	func (p Paned) SetPosition(position int)  {
var _arg0 *C.GtkPaned // out
var _arg1 C.gint // out

_arg0 = (*C.GtkPaned)(unsafe.Pointer(p.Native()))
_arg1 = (C.gint)(position)

C.gtk_paned_set_position(_arg0, _arg1)
}
	
	// SetWideHandle sets the Paned:wide-handle property.
	func (p Paned) SetWideHandle(wide bool)  {
var _arg0 *C.GtkPaned // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkPaned)(unsafe.Pointer(p.Native()))
if wide { _arg1 = C.TRUE }

C.gtk_paned_set_wide_handle(_arg0, _arg1)
}
	


	// PlacesSidebar is a widget that displays a list of frequently-used places in
// the file system: the user’s home directory, the user’s bookmarks, and volumes
// and drives. This widget is used as a sidebar in FileChooser and may be used
// by file managers and similar programs.
// 
// The places sidebar displays drives and volumes, and will automatically mount
// or unmount them when the user selects them.
// 
// Applications can hook to various signals in the places sidebar to customize
// its behavior. For example, they can add extra commands to the context menu of
// the sidebar.
// 
// While bookmarks are completely in control of the user, the places sidebar
// also allows individual applications to provide extra shortcut folders that
// are unique to each application. For example, a Paint program may want to add
// a shortcut for a Clipart folder. You can do this with
// gtk_places_sidebar_add_shortcut().
// 
// To make use of the places sidebar, an application at least needs to connect
// to the PlacesSidebar::open-location signal. This is emitted when the user
// selects in the sidebar a location to open. The application should also call
// gtk_places_sidebar_set_location() when it changes the currently-viewed
// location.
// 
// 
// CSS nodes
// 
// GtkPlacesSidebar uses a single CSS node with name placessidebar and style
// class .sidebar.
// 
// Among the children of the places sidebar, the following style classes can be
// used: - .sidebar-new-bookmark-row for the 'Add new bookmark' row -
// .sidebar-placeholder-row for a row that is a placeholder - .has-open-popup
// when a popup is open for a row
	type PlacesSidebar struct {
		ScrolledWindow
		Buildable
		
	}

	// PlacesSidebarClass is an interface that the PlacesSidebar class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type PlacesSidebarClass interface {
		gextras.Objector
		_placesSidebar()
	}

	func (PlacesSidebar) _placesSidebar() {}

	
	func marshalPlacesSidebar(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapPlacesSidebar(obj), nil
	}
	

	
	// NewPlacesSidebar creates a new PlacesSidebar widget.
// 
// The application should connect to at least the PlacesSidebar::open-location
// signal to be notified when the user makes a selection in the sidebar.
	func NewPlacesSidebar() PlacesSidebar {
var _cret *C.GtkWidget // in

_cret = C.gtk_places_sidebar_new()


var _placesSidebar PlacesSidebar // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_placesSidebar = PlacesSidebar{
ScrolledWindow: ScrolledWindow{
Bin: Bin{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _placesSidebar
}
	

	
	// AddShortcut applications may want to present some folders in the places
// sidebar if they could be immediately useful to users. For example, a drawing
// program could add a “/usr/share/clipart” location when the sidebar is being
// used in an “Insert Clipart” dialog box.
// 
// This function adds the specified @location to a special place for immutable
// shortcuts. The shortcuts are application-specific; they are not shared across
// applications, and they are not persistent. If this function is called
// multiple times with different locations, then they are added to the sidebar’s
// list in the same order as the function is called.
	func (s PlacesSidebar) AddShortcut(location gio.File)  {
var _arg0 *C.GtkPlacesSidebar // out
var _arg1 *C.GFile // out

_arg0 = (*C.GtkPlacesSidebar)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GFile)(unsafe.Pointer(location.Native()))

C.gtk_places_sidebar_add_shortcut(_arg0, _arg1)
}
	
	// LocalOnly returns the value previously set with
// gtk_places_sidebar_set_local_only().
	func (s PlacesSidebar) LocalOnly() bool {
var _arg0 *C.GtkPlacesSidebar // out
var _cret C.gboolean // in

_arg0 = (*C.GtkPlacesSidebar)(unsafe.Pointer(s.Native()))

_cret = C.gtk_places_sidebar_get_local_only(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Location gets the currently selected location in the @sidebar. This can be
// nil when nothing is selected, for example, when
// gtk_places_sidebar_set_location() has been called with a location that is not
// among the sidebar’s list of places to show.
// 
// You can use this function to get the selection in the @sidebar. Also, if you
// connect to the PlacesSidebar::populate-popup signal, you can use this
// function to get the location that is being referred to during the callbacks
// for your menu items.
	func (s PlacesSidebar) Location() gio.File {
var _arg0 *C.GtkPlacesSidebar // out
var _cret *C.GFile // in

_arg0 = (*C.GtkPlacesSidebar)(unsafe.Pointer(s.Native()))

_cret = C.gtk_places_sidebar_get_location(_arg0)


var _file gio.File // out

_file = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gio.File)

return _file
}
	
	// NthBookmark: this function queries the bookmarks added by the user to the
// places sidebar, and returns one of them. This function is used by FileChooser
// to implement the “Alt-1”, “Alt-2”, etc. shortcuts, which activate the
// cooresponding bookmark.
	func (s PlacesSidebar) NthBookmark(n int) gio.File {
var _arg0 *C.GtkPlacesSidebar // out
var _arg1 C.gint // out
var _cret *C.GFile // in

_arg0 = (*C.GtkPlacesSidebar)(unsafe.Pointer(s.Native()))
_arg1 = (C.gint)(n)

_cret = C.gtk_places_sidebar_get_nth_bookmark(_arg0, _arg1)


var _file gio.File // out

_file = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gio.File)

return _file
}
	
	// OpenFlags gets the open flags.
	func (s PlacesSidebar) OpenFlags() PlacesOpenFlags {
var _arg0 *C.GtkPlacesSidebar // out
var _cret C.GtkPlacesOpenFlags // in

_arg0 = (*C.GtkPlacesSidebar)(unsafe.Pointer(s.Native()))

_cret = C.gtk_places_sidebar_get_open_flags(_arg0)


var _placesOpenFlags PlacesOpenFlags // out

_placesOpenFlags = PlacesOpenFlags(_cret)

return _placesOpenFlags
}
	
	// ShowConnectToServer returns the value previously set with
// gtk_places_sidebar_set_show_connect_to_server()
	func (s PlacesSidebar) ShowConnectToServer() bool {
var _arg0 *C.GtkPlacesSidebar // out
var _cret C.gboolean // in

_arg0 = (*C.GtkPlacesSidebar)(unsafe.Pointer(s.Native()))

_cret = C.gtk_places_sidebar_get_show_connect_to_server(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ShowDesktop returns the value previously set with
// gtk_places_sidebar_set_show_desktop()
	func (s PlacesSidebar) ShowDesktop() bool {
var _arg0 *C.GtkPlacesSidebar // out
var _cret C.gboolean // in

_arg0 = (*C.GtkPlacesSidebar)(unsafe.Pointer(s.Native()))

_cret = C.gtk_places_sidebar_get_show_desktop(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ShowEnterLocation returns the value previously set with
// gtk_places_sidebar_set_show_enter_location()
	func (s PlacesSidebar) ShowEnterLocation() bool {
var _arg0 *C.GtkPlacesSidebar // out
var _cret C.gboolean // in

_arg0 = (*C.GtkPlacesSidebar)(unsafe.Pointer(s.Native()))

_cret = C.gtk_places_sidebar_get_show_enter_location(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ShowOtherLocations returns the value previously set with
// gtk_places_sidebar_set_show_other_locations()
	func (s PlacesSidebar) ShowOtherLocations() bool {
var _arg0 *C.GtkPlacesSidebar // out
var _cret C.gboolean // in

_arg0 = (*C.GtkPlacesSidebar)(unsafe.Pointer(s.Native()))

_cret = C.gtk_places_sidebar_get_show_other_locations(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ShowRecent returns the value previously set with
// gtk_places_sidebar_set_show_recent()
	func (s PlacesSidebar) ShowRecent() bool {
var _arg0 *C.GtkPlacesSidebar // out
var _cret C.gboolean // in

_arg0 = (*C.GtkPlacesSidebar)(unsafe.Pointer(s.Native()))

_cret = C.gtk_places_sidebar_get_show_recent(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ShowStarredLocation returns the value previously set with
// gtk_places_sidebar_set_show_starred_location()
	func (s PlacesSidebar) ShowStarredLocation() bool {
var _arg0 *C.GtkPlacesSidebar // out
var _cret C.gboolean // in

_arg0 = (*C.GtkPlacesSidebar)(unsafe.Pointer(s.Native()))

_cret = C.gtk_places_sidebar_get_show_starred_location(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ShowTrash returns the value previously set with
// gtk_places_sidebar_set_show_trash()
	func (s PlacesSidebar) ShowTrash() bool {
var _arg0 *C.GtkPlacesSidebar // out
var _cret C.gboolean // in

_arg0 = (*C.GtkPlacesSidebar)(unsafe.Pointer(s.Native()))

_cret = C.gtk_places_sidebar_get_show_trash(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// RemoveShortcut removes an application-specific shortcut that has been
// previously been inserted with gtk_places_sidebar_add_shortcut(). If the
// @location is not a shortcut in the sidebar, then nothing is done.
	func (s PlacesSidebar) RemoveShortcut(location gio.File)  {
var _arg0 *C.GtkPlacesSidebar // out
var _arg1 *C.GFile // out

_arg0 = (*C.GtkPlacesSidebar)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GFile)(unsafe.Pointer(location.Native()))

C.gtk_places_sidebar_remove_shortcut(_arg0, _arg1)
}
	
	// SetDropTargetsVisible: make the GtkPlacesSidebar show drop targets, so it can
// show the available drop targets and a "new bookmark" row. This improves the
// Drag-and-Drop experience of the user and allows applications to show all
// available drop targets at once.
// 
// This needs to be called when the application is aware of an ongoing drag that
// might target the sidebar. The drop-targets-visible state will be unset
// automatically if the drag finishes in the GtkPlacesSidebar. You only need to
// unset the state when the drag ends on some other widget on your application.
	func (s PlacesSidebar) SetDropTargetsVisible(visible bool, context gdk.DragContextClass)  {
var _arg0 *C.GtkPlacesSidebar // out
var _arg1 C.gboolean // out
var _arg2 *C.GdkDragContext // out

_arg0 = (*C.GtkPlacesSidebar)(unsafe.Pointer(s.Native()))
if visible { _arg1 = C.TRUE }
_arg2 = (*C.GdkDragContext)(unsafe.Pointer(context.Native()))

C.gtk_places_sidebar_set_drop_targets_visible(_arg0, _arg1, _arg2)
}
	
	// SetLocalOnly sets whether the @sidebar should only show local files.
	func (s PlacesSidebar) SetLocalOnly(localOnly bool)  {
var _arg0 *C.GtkPlacesSidebar // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkPlacesSidebar)(unsafe.Pointer(s.Native()))
if localOnly { _arg1 = C.TRUE }

C.gtk_places_sidebar_set_local_only(_arg0, _arg1)
}
	
	// SetLocation sets the location that is being shown in the widgets surrounding
// the @sidebar, for example, in a folder view in a file manager. In turn, the
// @sidebar will highlight that location if it is being shown in the list of
// places, or it will unhighlight everything if the @location is not among the
// places in the list.
	func (s PlacesSidebar) SetLocation(location gio.File)  {
var _arg0 *C.GtkPlacesSidebar // out
var _arg1 *C.GFile // out

_arg0 = (*C.GtkPlacesSidebar)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GFile)(unsafe.Pointer(location.Native()))

C.gtk_places_sidebar_set_location(_arg0, _arg1)
}
	
	// SetOpenFlags sets the way in which the calling application can open new
// locations from the places sidebar. For example, some applications only open
// locations “directly” into their main view, while others may support opening
// locations in a new notebook tab or a new window.
// 
// This function is used to tell the places @sidebar about the ways in which the
// application can open new locations, so that the sidebar can display (or not)
// the “Open in new tab” and “Open in new window” menu items as appropriate.
// 
// When the PlacesSidebar::open-location signal is emitted, its flags argument
// will be set to one of the @flags that was passed in
// gtk_places_sidebar_set_open_flags().
// 
// Passing 0 for @flags will cause K_PLACES_OPEN_NORMAL to always be sent to
// callbacks for the “open-location” signal.
	func (s PlacesSidebar) SetOpenFlags(flags PlacesOpenFlags)  {
var _arg0 *C.GtkPlacesSidebar // out
var _arg1 C.GtkPlacesOpenFlags // out

_arg0 = (*C.GtkPlacesSidebar)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkPlacesOpenFlags)(flags)

C.gtk_places_sidebar_set_open_flags(_arg0, _arg1)
}
	
	// SetShowConnectToServer sets whether the @sidebar should show an item for
// connecting to a network server; this is off by default. An application may
// want to turn this on if it implements a way for the user to connect to
// network servers directly.
// 
// If you enable this, you should connect to the
// PlacesSidebar::show-connect-to-server signal.
	func (s PlacesSidebar) SetShowConnectToServer(showConnectToServer bool)  {
var _arg0 *C.GtkPlacesSidebar // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkPlacesSidebar)(unsafe.Pointer(s.Native()))
if showConnectToServer { _arg1 = C.TRUE }

C.gtk_places_sidebar_set_show_connect_to_server(_arg0, _arg1)
}
	
	// SetShowDesktop sets whether the @sidebar should show an item for the Desktop
// folder. The default value for this option is determined by the desktop
// environment and the user’s configuration, but this function can be used to
// override it on a per-application basis.
	func (s PlacesSidebar) SetShowDesktop(showDesktop bool)  {
var _arg0 *C.GtkPlacesSidebar // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkPlacesSidebar)(unsafe.Pointer(s.Native()))
if showDesktop { _arg1 = C.TRUE }

C.gtk_places_sidebar_set_show_desktop(_arg0, _arg1)
}
	
	// SetShowEnterLocation sets whether the @sidebar should show an item for
// entering a location; this is off by default. An application may want to turn
// this on if manually entering URLs is an expected user action.
// 
// If you enable this, you should connect to the
// PlacesSidebar::show-enter-location signal.
	func (s PlacesSidebar) SetShowEnterLocation(showEnterLocation bool)  {
var _arg0 *C.GtkPlacesSidebar // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkPlacesSidebar)(unsafe.Pointer(s.Native()))
if showEnterLocation { _arg1 = C.TRUE }

C.gtk_places_sidebar_set_show_enter_location(_arg0, _arg1)
}
	
	// SetShowOtherLocations sets whether the @sidebar should show an item for the
// application to show an Other Locations view; this is off by default. When set
// to true, persistent devices such as hard drives are hidden, otherwise they
// are shown in the sidebar. An application may want to turn this on if it
// implements a way for the user to see and interact with drives and network
// servers directly.
// 
// If you enable this, you should connect to the
// PlacesSidebar::show-other-locations signal.
	func (s PlacesSidebar) SetShowOtherLocations(showOtherLocations bool)  {
var _arg0 *C.GtkPlacesSidebar // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkPlacesSidebar)(unsafe.Pointer(s.Native()))
if showOtherLocations { _arg1 = C.TRUE }

C.gtk_places_sidebar_set_show_other_locations(_arg0, _arg1)
}
	
	// SetShowRecent sets whether the @sidebar should show an item for recent files.
// The default value for this option is determined by the desktop environment,
// but this function can be used to override it on a per-application basis.
	func (s PlacesSidebar) SetShowRecent(showRecent bool)  {
var _arg0 *C.GtkPlacesSidebar // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkPlacesSidebar)(unsafe.Pointer(s.Native()))
if showRecent { _arg1 = C.TRUE }

C.gtk_places_sidebar_set_show_recent(_arg0, _arg1)
}
	
	// SetShowStarredLocation: if you enable this, you should connect to the
// PlacesSidebar::show-starred-location signal.
	func (s PlacesSidebar) SetShowStarredLocation(showStarredLocation bool)  {
var _arg0 *C.GtkPlacesSidebar // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkPlacesSidebar)(unsafe.Pointer(s.Native()))
if showStarredLocation { _arg1 = C.TRUE }

C.gtk_places_sidebar_set_show_starred_location(_arg0, _arg1)
}
	
	// SetShowTrash sets whether the @sidebar should show an item for the Trash
// location.
	func (s PlacesSidebar) SetShowTrash(showTrash bool)  {
var _arg0 *C.GtkPlacesSidebar // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkPlacesSidebar)(unsafe.Pointer(s.Native()))
if showTrash { _arg1 = C.TRUE }

C.gtk_places_sidebar_set_show_trash(_arg0, _arg1)
}
	


	// Plug: together with Socket, Plug provides the ability to embed widgets from
// one process into another process in a fashion that is transparent to the
// user. One process creates a Socket widget and passes the ID of that widget’s
// window to the other process, which then creates a Plug with that window ID.
// Any widgets contained in the Plug then will appear inside the first
// application’s window.
// 
// The communication between a Socket and a Plug follows the XEmbed Protocol
// (http://www.freedesktop.org/Standards/xembed-spec). This protocol has also
// been implemented in other toolkits, e.g. Qt, allowing the same level of
// integration when embedding a Qt widget in GTK+ or vice versa.
// 
// The Plug and Socket widgets are only available when GTK+ is compiled for the
// X11 platform and GDK_WINDOWING_X11 is defined. They can only be used on a
// X11Display. To use Plug and Socket, you need to include the `gtk/gtkx.h`
// header.
	type Plug struct {
		Window
		Buildable
		
	}

	// PlugClass is an interface that the Plug class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type PlugClass interface {
		gextras.Objector
		_plug()
	}

	func (Plug) _plug() {}

	
	func marshalPlug(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapPlug(obj), nil
	}
	

	

	
	// Embedded determines whether the plug is embedded in a socket.
	func (p Plug) Embedded() bool {
var _arg0 *C.GtkPlug // out
var _cret C.gboolean // in

_arg0 = (*C.GtkPlug)(unsafe.Pointer(p.Native()))

_cret = C.gtk_plug_get_embedded(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SocketWindow retrieves the socket the plug is embedded in.
	func (p Plug) SocketWindow() gdk.Window {
var _arg0 *C.GtkPlug // out
var _cret *C.GdkWindow // in

_arg0 = (*C.GtkPlug)(unsafe.Pointer(p.Native()))

_cret = C.gtk_plug_get_socket_window(_arg0)


var _window gdk.Window // out

_window = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Window)

return _window
}
	


	// Popover: gtkPopover is a bubble-like context window, primarily meant to
// provide context-dependent information or options. Popovers are attached to a
// widget, passed at construction time on gtk_popover_new(), or updated
// afterwards through gtk_popover_set_relative_to(), by default they will point
// to the whole widget area, although this behavior can be changed through
// gtk_popover_set_pointing_to().
// 
// The position of a popover relative to the widget it is attached to can also
// be changed through gtk_popover_set_position().
// 
// By default, Popover performs a GTK+ grab, in order to ensure input events get
// redirected to it while it is shown, and also so the popover is dismissed in
// the expected situations (clicks outside the popover, or the Esc key being
// pressed). If no such modal behavior is desired on a popover,
// gtk_popover_set_modal() may be called on it to tweak its behavior.
// 
// 
// GtkPopover as menu replacement
// 
// GtkPopover is often used to replace menus. To facilitate this, it supports
// being populated from a Model, using gtk_popover_new_from_model(). In addition
// to all the regular menu model features, this function supports rendering
// sections in the model in a more compact form, as a row of icon buttons
// instead of menu items.
// 
// To use this rendering, set the ”display-hint” attribute of the section to
// ”horizontal-buttons” and set the icons of your items with the ”verb-icon”
// attribute.
// 
//    <section>
//      <attribute name="display-hint">horizontal-buttons</attribute>
//      <item>
//        <attribute name="label">Cut</attribute>
//        <attribute name="action">app.cut</attribute>
//        <attribute name="verb-icon">edit-cut-symbolic</attribute>
//      </item>
//      <item>
//        <attribute name="label">Copy</attribute>
//        <attribute name="action">app.copy</attribute>
//        <attribute name="verb-icon">edit-copy-symbolic</attribute>
//      </item>
//      <item>
//        <attribute name="label">Paste</attribute>
//        <attribute name="action">app.paste</attribute>
//        <attribute name="verb-icon">edit-paste-symbolic</attribute>
//      </item>
//    </section>
// 
// 
// CSS nodes
// 
// GtkPopover has a single css node called popover. It always gets the
// .background style class and it gets the .menu style class if it is menu-like
// (e.g. PopoverMenu or created using gtk_popover_new_from_model().
// 
// Particular uses of GtkPopover, such as touch selection popups or magnifiers
// in Entry or TextView get style classes like .touch-selection or .magnifier to
// differentiate from plain popovers.
	type Popover struct {
		Bin
		Buildable
		
	}

	// PopoverClass is an interface that the Popover class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type PopoverClass interface {
		gextras.Objector
		_popover()
	}

	func (Popover) _popover() {}

	
	func marshalPopover(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapPopover(obj), nil
	}
	

	
	// NewPopover creates a new popover to point to @relative_to
	func NewPopover(relativeTo WidgetClass) Popover {
var _arg1 *C.GtkWidget // out
var _cret *C.GtkWidget // in

_arg1 = (*C.GtkWidget)(unsafe.Pointer(relativeTo.Native()))

_cret = C.gtk_popover_new(_arg1)


var _popover Popover // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_popover = Popover{
Bin: Bin{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _popover
}
	
	// NewPopoverFromModel creates a Popover and populates it according to @model.
// The popover is pointed to the @relative_to widget.
// 
// The created buttons are connected to actions found in the ApplicationWindow
// to which the popover belongs - typically by means of being attached to a
// widget that is contained within the ApplicationWindows widget hierarchy.
// 
// Actions can also be added using gtk_widget_insert_action_group() on the menus
// attach widget or on any of its parent widgets.
	func NewPopoverFromModel(relativeTo WidgetClass, model gio.MenuModelClass) Popover {
var _arg1 *C.GtkWidget // out
var _arg2 *C.GMenuModel // out
var _cret *C.GtkWidget // in

_arg1 = (*C.GtkWidget)(unsafe.Pointer(relativeTo.Native()))
_arg2 = (*C.GMenuModel)(unsafe.Pointer(model.Native()))

_cret = C.gtk_popover_new_from_model(_arg1, _arg2)


var _popover Popover // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_popover = Popover{
Bin: Bin{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _popover
}
	

	
	// BindModel establishes a binding between a Popover and a Model.
// 
// The contents of @popover are removed and then refilled with menu items
// according to @model. When @model changes, @popover is updated. Calling this
// function twice on @popover with different @model will cause the first binding
// to be replaced with a binding to the new model. If @model is nil then any
// previous binding is undone and all children are removed.
// 
// If @action_namespace is non-nil then the effect is as if all actions
// mentioned in the @model have their names prefixed with the namespace, plus a
// dot. For example, if the action “quit” is mentioned and @action_namespace is
// “app” then the effective action name is “app.quit”.
// 
// This function uses Actionable to define the action name and target values on
// the created menu items. If you want to use an action group other than “app”
// and “win”, or if you want to use a MenuShell outside of a ApplicationWindow,
// then you will need to attach your own action group to the widget hierarchy
// using gtk_widget_insert_action_group(). As an example, if you created a group
// with a “quit” action and inserted it with the name “mygroup” then you would
// use the action name “mygroup.quit” in your Model.
	func (p Popover) BindModel(model gio.MenuModelClass, actionNamespace string)  {
var _arg0 *C.GtkPopover // out
var _arg1 *C.GMenuModel // out
var _arg2 *C.gchar // out

_arg0 = (*C.GtkPopover)(unsafe.Pointer(p.Native()))
_arg1 = (*C.GMenuModel)(unsafe.Pointer(model.Native()))
_arg2 = (*C.gchar)(C.CString(actionNamespace))
defer C.free(unsafe.Pointer(_arg2))

C.gtk_popover_bind_model(_arg0, _arg1, _arg2)
}
	
	// ConstrainTo returns the constraint for placing this popover. See
// gtk_popover_set_constrain_to().
	func (p Popover) ConstrainTo() PopoverConstraint {
var _arg0 *C.GtkPopover // out
var _cret C.GtkPopoverConstraint // in

_arg0 = (*C.GtkPopover)(unsafe.Pointer(p.Native()))

_cret = C.gtk_popover_get_constrain_to(_arg0)


var _popoverConstraint PopoverConstraint // out

_popoverConstraint = PopoverConstraint(_cret)

return _popoverConstraint
}
	
	// DefaultWidget gets the widget that should be set as the default while the
// popover is shown.
	func (p Popover) DefaultWidget() Widget {
var _arg0 *C.GtkPopover // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkPopover)(unsafe.Pointer(p.Native()))

_cret = C.gtk_popover_get_default_widget(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// Modal returns whether the popover is modal, see gtk_popover_set_modal to see
// the implications of this.
	func (p Popover) Modal() bool {
var _arg0 *C.GtkPopover // out
var _cret C.gboolean // in

_arg0 = (*C.GtkPopover)(unsafe.Pointer(p.Native()))

_cret = C.gtk_popover_get_modal(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// PointingTo: if a rectangle to point to has been set, this function will
// return true and fill in @rect with such rectangle, otherwise it will return
// false and fill in @rect with the attached widget coordinates.
	func (p Popover) PointingTo() (gdk.Rectangle, bool) {
var _arg0 *C.GtkPopover // out
var _rect gdk.Rectangle
var _cret C.gboolean // in

_arg0 = (*C.GtkPopover)(unsafe.Pointer(p.Native()))

_cret = C.gtk_popover_get_pointing_to(_arg0, (*C.GdkRectangle)(unsafe.Pointer(&_rect)))



var _ok bool // out


if _cret != 0 { _ok = true }

return _rect, _ok
}
	
	// Position returns the preferred position of @popover.
	func (p Popover) Position() PositionType {
var _arg0 *C.GtkPopover // out
var _cret C.GtkPositionType // in

_arg0 = (*C.GtkPopover)(unsafe.Pointer(p.Native()))

_cret = C.gtk_popover_get_position(_arg0)


var _positionType PositionType // out

_positionType = PositionType(_cret)

return _positionType
}
	
	// RelativeTo returns the widget @popover is currently attached to
	func (p Popover) RelativeTo() Widget {
var _arg0 *C.GtkPopover // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkPopover)(unsafe.Pointer(p.Native()))

_cret = C.gtk_popover_get_relative_to(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// TransitionsEnabled returns whether show/hide transitions are enabled on this
// popover.
	func (p Popover) TransitionsEnabled() bool {
var _arg0 *C.GtkPopover // out
var _cret C.gboolean // in

_arg0 = (*C.GtkPopover)(unsafe.Pointer(p.Native()))

_cret = C.gtk_popover_get_transitions_enabled(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Popdown pops @popover down.This is different than a gtk_widget_hide() call in
// that it shows the popover with a transition. If you want to hide the popover
// without a transition, use gtk_widget_hide().
	func (p Popover) Popdown()  {
var _arg0 *C.GtkPopover // out

_arg0 = (*C.GtkPopover)(unsafe.Pointer(p.Native()))

C.gtk_popover_popdown(_arg0)
}
	
	// Popup pops @popover up. This is different than a gtk_widget_show() call in
// that it shows the popover with a transition. If you want to show the popover
// without a transition, use gtk_widget_show().
	func (p Popover) Popup()  {
var _arg0 *C.GtkPopover // out

_arg0 = (*C.GtkPopover)(unsafe.Pointer(p.Native()))

C.gtk_popover_popup(_arg0)
}
	
	// SetConstrainTo sets a constraint for positioning this popover.
// 
// Note that not all platforms support placing popovers freely, and may already
// impose constraints.
	func (p Popover) SetConstrainTo(constraint PopoverConstraint)  {
var _arg0 *C.GtkPopover // out
var _arg1 C.GtkPopoverConstraint // out

_arg0 = (*C.GtkPopover)(unsafe.Pointer(p.Native()))
_arg1 = (C.GtkPopoverConstraint)(constraint)

C.gtk_popover_set_constrain_to(_arg0, _arg1)
}
	
	// SetDefaultWidget sets the widget that should be set as default widget while
// the popover is shown (see gtk_window_set_default()). Popover remembers the
// previous default widget and reestablishes it when the popover is dismissed.
	func (p Popover) SetDefaultWidget(widget WidgetClass)  {
var _arg0 *C.GtkPopover // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkPopover)(unsafe.Pointer(p.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

C.gtk_popover_set_default_widget(_arg0, _arg1)
}
	
	// SetModal sets whether @popover is modal, a modal popover will grab all input
// within the toplevel and grab the keyboard focus on it when being displayed.
// Clicking outside the popover area or pressing Esc will dismiss the popover
// and ungrab input.
	func (p Popover) SetModal(modal bool)  {
var _arg0 *C.GtkPopover // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkPopover)(unsafe.Pointer(p.Native()))
if modal { _arg1 = C.TRUE }

C.gtk_popover_set_modal(_arg0, _arg1)
}
	
	// SetPointingTo sets the rectangle that @popover will point to, in the
// coordinate space of the widget @popover is attached to, see
// gtk_popover_set_relative_to().
	func (p Popover) SetPointingTo(rect *gdk.Rectangle)  {
var _arg0 *C.GtkPopover // out
var _arg1 *C.GdkRectangle // out

_arg0 = (*C.GtkPopover)(unsafe.Pointer(p.Native()))
_arg1 = (*C.GdkRectangle)(unsafe.Pointer(rect.Native()))

C.gtk_popover_set_pointing_to(_arg0, _arg1)
}
	
	// SetPosition sets the preferred position for @popover to appear. If the
// @popover is currently visible, it will be immediately updated.
// 
// This preference will be respected where possible, although on lack of space
// (eg. if close to the window edges), the Popover may choose to appear on the
// opposite side
	func (p Popover) SetPosition(position PositionType)  {
var _arg0 *C.GtkPopover // out
var _arg1 C.GtkPositionType // out

_arg0 = (*C.GtkPopover)(unsafe.Pointer(p.Native()))
_arg1 = (C.GtkPositionType)(position)

C.gtk_popover_set_position(_arg0, _arg1)
}
	
	// SetRelativeTo sets a new widget to be attached to @popover. If @popover is
// visible, the position will be updated.
// 
// Note: the ownership of popovers is always given to their @relative_to widget,
// so if @relative_to is set to nil on an attached @popover, it will be detached
// from its previous widget, and consequently destroyed unless extra references
// are kept.
	func (p Popover) SetRelativeTo(relativeTo WidgetClass)  {
var _arg0 *C.GtkPopover // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkPopover)(unsafe.Pointer(p.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(relativeTo.Native()))

C.gtk_popover_set_relative_to(_arg0, _arg1)
}
	
	// SetTransitionsEnabled sets whether show/hide transitions are enabled on this
// popover
	func (p Popover) SetTransitionsEnabled(transitionsEnabled bool)  {
var _arg0 *C.GtkPopover // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkPopover)(unsafe.Pointer(p.Native()))
if transitionsEnabled { _arg1 = C.TRUE }

C.gtk_popover_set_transitions_enabled(_arg0, _arg1)
}
	


	// PopoverMenu: gtkPopoverMenu is a subclass of Popover that treats its children
// like menus and allows switching between them. It is meant to be used
// primarily together with ModelButton, but any widget can be used, such as
// SpinButton or Scale. In this respect, GtkPopoverMenu is more flexible than
// popovers that are created from a Model with gtk_popover_new_from_model().
// 
// To add a child as a submenu, set the PopoverMenu:submenu child property to
// the name of the submenu. To let the user open this submenu, add a ModelButton
// whose ModelButton:menu-name property is set to the name you've given to the
// submenu.
// 
// By convention, the first child of a submenu should be a ModelButton to switch
// back to the parent menu. Such a button should use the ModelButton:inverted
// and ModelButton:centered properties to achieve a title-like appearance and
// place the submenu indicator at the opposite side. To switch back to the main
// menu, use "main" as the menu name.
// 
// Example
// 
//    <object class="GtkPopoverMenu">
//      <child>
//        <object class="GtkBox">
//          <property name="visible">True</property>
//          <property name="margin">10</property>
//          <child>
//            <object class="GtkModelButton">
//              <property name="visible">True</property>
//              <property name="action-name">win.frob</property>
//              <property name="text" translatable="yes">Frob</property>
//            </object>
//          </child>
//          <child>
//            <object class="GtkModelButton">
//              <property name="visible">True</property>
//              <property name="menu-name">more</property>
//              <property name="text" translatable="yes">More</property>
//            </object>
//          </child>
//        </object>
//      </child>
//      <child>
//        <object class="GtkBox">
//          <property name="visible">True</property>
//          <property name="margin">10</property>
//          <child>
//            <object class="GtkModelButton">
//              <property name="visible">True</property>
//              <property name="action-name">win.foo</property>
//              <property name="text" translatable="yes">Foo</property>
//            </object>
//          </child>
//          <child>
//            <object class="GtkModelButton">
//              <property name="visible">True</property>
//              <property name="action-name">win.bar</property>
//              <property name="text" translatable="yes">Bar</property>
//            </object>
//          </child>
//        </object>
//        <packing>
//          <property name="submenu">more</property>
//        </packing>
//      </child>
//    </object>
// 
// Just like normal popovers created using gtk_popover_new_from_model,
// PopoverMenu instances have a single css node called "popover" and get the
// .menu style class.
	type PopoverMenu struct {
		Popover
		Buildable
		
	}

	// PopoverMenuClass is an interface that the PopoverMenu class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type PopoverMenuClass interface {
		gextras.Objector
		_popoverMenu()
	}

	func (PopoverMenu) _popoverMenu() {}

	
	func marshalPopoverMenu(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapPopoverMenu(obj), nil
	}
	

	
	// NewPopoverMenu creates a new popover menu.
	func NewPopoverMenu() PopoverMenu {
var _cret *C.GtkWidget // in

_cret = C.gtk_popover_menu_new()


var _popoverMenu PopoverMenu // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_popoverMenu = PopoverMenu{
Popover: Popover{
Bin: Bin{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _popoverMenu
}
	

	
	// OpenSubmenu opens a submenu of the @popover. The @name must be one of the
// names given to the submenus of @popover with PopoverMenu:submenu, or "main"
// to switch back to the main menu.
// 
// ModelButton will open submenus automatically when the ModelButton:menu-name
// property is set, so this function is only needed when you are using other
// kinds of widgets to initiate menu changes.
	func (p PopoverMenu) OpenSubmenu(name string)  {
var _arg0 *C.GtkPopoverMenu // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkPopoverMenu)(unsafe.Pointer(p.Native()))
_arg1 = (*C.gchar)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_popover_menu_open_submenu(_arg0, _arg1)
}
	


	// PrintContext: a GtkPrintContext encapsulates context information that is
// required when drawing pages for printing, such as the cairo context and
// important parameters like page size and resolution. It also lets you easily
// create Layout and Context objects that match the font metrics of the cairo
// surface.
// 
// GtkPrintContext objects gets passed to the PrintOperation::begin-print,
// PrintOperation::end-print, PrintOperation::request-page-setup and
// PrintOperation::draw-page signals on the PrintOperation.
// 
// Using GtkPrintContext in a PrintOperation::draw-page callback
// 
//    static void
//    draw_page (GtkPrintOperation *operation,
//    	   GtkPrintContext   *context,
//    	   int                page_nr)
//    {
//      cairo_t *cr;
//      PangoLayout *layout;
//      PangoFontDescription *desc;
// 
//      cr = gtk_print_context_get_cairo_context (context);
// 
//      // Draw a red rectangle, as wide as the paper (inside the margins)
//      cairo_set_source_rgb (cr, 1.0, 0, 0);
//      cairo_rectangle (cr, 0, 0, gtk_print_context_get_width (context), 50);
// 
//      cairo_fill (cr);
// 
//      // Draw some lines
//      cairo_move_to (cr, 20, 10);
//      cairo_line_to (cr, 40, 20);
//      cairo_arc (cr, 60, 60, 20, 0, M_PI);
//      cairo_line_to (cr, 80, 20);
// 
//      cairo_set_source_rgb (cr, 0, 0, 0);
//      cairo_set_line_width (cr, 5);
//      cairo_set_line_cap (cr, CAIRO_LINE_CAP_ROUND);
//      cairo_set_line_join (cr, CAIRO_LINE_JOIN_ROUND);
// 
//      cairo_stroke (cr);
// 
//      // Draw some text
//      layout = gtk_print_context_create_pango_layout (context);
//      pango_layout_set_text (layout, "Hello World! Printing is easy", -1);
//      desc = pango_font_description_from_string ("sans 28");
//      pango_layout_set_font_description (layout, desc);
//      pango_font_description_free (desc);
// 
//      cairo_move_to (cr, 30, 20);
//      pango_cairo_layout_path (cr, layout);
// 
//      // Font Outline
//      cairo_set_source_rgb (cr, 0.93, 1.0, 0.47);
//      cairo_set_line_width (cr, 0.5);
//      cairo_stroke_preserve (cr);
// 
//      // Font Fill
//      cairo_set_source_rgb (cr, 0, 0.0, 1.0);
//      cairo_fill (cr);
// 
//      g_object_unref (layout);
//    }
// 
// Printing support was added in GTK+ 2.10.
	type PrintContext struct {
		**externglib.Object
		
	}

	// PrintContextClass is an interface that the PrintContext class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type PrintContextClass interface {
		gextras.Objector
		_printContext()
	}

	func (PrintContext) _printContext() {}

	
	func marshalPrintContext(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapPrintContext(obj), nil
	}
	

	

	
	// CreatePangoContext creates a new Context that can be used with the
// PrintContext.
	func (c PrintContext) CreatePangoContext() pango.Context {
var _arg0 *C.GtkPrintContext // out
var _cret *C.PangoContext // in

_arg0 = (*C.GtkPrintContext)(unsafe.Pointer(c.Native()))

_cret = C.gtk_print_context_create_pango_context(_arg0)


var _ret pango.Context // out

_ret = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(pango.Context)

return _ret
}
	
	// CreatePangoLayout creates a new Layout that is suitable for use with the
// PrintContext.
	func (c PrintContext) CreatePangoLayout() pango.Layout {
var _arg0 *C.GtkPrintContext // out
var _cret *C.PangoLayout // in

_arg0 = (*C.GtkPrintContext)(unsafe.Pointer(c.Native()))

_cret = C.gtk_print_context_create_pango_layout(_arg0)


var _layout pango.Layout // out

_layout = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(pango.Layout)

return _layout
}
	
	// CairoContext obtains the cairo context that is associated with the
// PrintContext.
	func (c PrintContext) CairoContext() *cairo.Context {
var _arg0 *C.GtkPrintContext // out
var _cret *C.cairo_t // in

_arg0 = (*C.GtkPrintContext)(unsafe.Pointer(c.Native()))

_cret = C.gtk_print_context_get_cairo_context(_arg0)


var _ret *cairo.Context // out

_ret = *(**cairo.Context)(unsafe.Pointer(&_cret))

return _ret
}
	
	// DPIX obtains the horizontal resolution of the PrintContext, in dots per inch.
	func (c PrintContext) DPIX() float64 {
var _arg0 *C.GtkPrintContext // out
var _cret C.gdouble // in

_arg0 = (*C.GtkPrintContext)(unsafe.Pointer(c.Native()))

_cret = C.gtk_print_context_get_dpi_x(_arg0)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// DPIY obtains the vertical resolution of the PrintContext, in dots per inch.
	func (c PrintContext) DPIY() float64 {
var _arg0 *C.GtkPrintContext // out
var _cret C.gdouble // in

_arg0 = (*C.GtkPrintContext)(unsafe.Pointer(c.Native()))

_cret = C.gtk_print_context_get_dpi_y(_arg0)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// HardMargins obtains the hardware printer margins of the PrintContext, in
// units.
	func (c PrintContext) HardMargins() (top float64, bottom float64, left float64, right float64, ok bool) {
var _arg0 *C.GtkPrintContext // out
var _arg1 C.gdouble // in
var _arg2 C.gdouble // in
var _arg3 C.gdouble // in
var _arg4 C.gdouble // in
var _cret C.gboolean // in

_arg0 = (*C.GtkPrintContext)(unsafe.Pointer(c.Native()))

_cret = C.gtk_print_context_get_hard_margins(_arg0, &_arg1, &_arg2, &_arg3, &_arg4)


var _top float64 // out
var _bottom float64 // out
var _left float64 // out
var _right float64 // out
var _ok bool // out

_top = (float64)(_arg1)
_bottom = (float64)(_arg2)
_left = (float64)(_arg3)
_right = (float64)(_arg4)
if _cret != 0 { _ok = true }

return _top, _bottom, _left, _right, _ok
}
	
	// Height obtains the height of the PrintContext, in pixels.
	func (c PrintContext) Height() float64 {
var _arg0 *C.GtkPrintContext // out
var _cret C.gdouble // in

_arg0 = (*C.GtkPrintContext)(unsafe.Pointer(c.Native()))

_cret = C.gtk_print_context_get_height(_arg0)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// PageSetup obtains the PageSetup that determines the page dimensions of the
// PrintContext.
	func (c PrintContext) PageSetup() PageSetup {
var _arg0 *C.GtkPrintContext // out
var _cret *C.GtkPageSetup // in

_arg0 = (*C.GtkPrintContext)(unsafe.Pointer(c.Native()))

_cret = C.gtk_print_context_get_page_setup(_arg0)


var _pageSetup PageSetup // out

_pageSetup = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(PageSetup)

return _pageSetup
}
	
	// PangoFontmap returns a FontMap that is suitable for use with the
// PrintContext.
	func (c PrintContext) PangoFontmap() pango.FontMap {
var _arg0 *C.GtkPrintContext // out
var _cret *C.PangoFontMap // in

_arg0 = (*C.GtkPrintContext)(unsafe.Pointer(c.Native()))

_cret = C.gtk_print_context_get_pango_fontmap(_arg0)


var _fontMap pango.FontMap // out

_fontMap = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(pango.FontMap)

return _fontMap
}
	
	// Width obtains the width of the PrintContext, in pixels.
	func (c PrintContext) Width() float64 {
var _arg0 *C.GtkPrintContext // out
var _cret C.gdouble // in

_arg0 = (*C.GtkPrintContext)(unsafe.Pointer(c.Native()))

_cret = C.gtk_print_context_get_width(_arg0)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// SetCairoContext sets a new cairo context on a print context.
// 
// This function is intended to be used when implementing an internal print
// preview, it is not needed for printing, since GTK+ itself creates a suitable
// cairo context in that case.
	func (c PrintContext) SetCairoContext(cr *cairo.Context, dpiX float64, dpiY float64)  {
var _arg0 *C.GtkPrintContext // out
var _arg1 *C.cairo_t // out
var _arg2 C.double // out
var _arg3 C.double // out

_arg0 = (*C.GtkPrintContext)(unsafe.Pointer(c.Native()))
_arg1 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
_arg2 = (C.double)(dpiX)
_arg3 = (C.double)(dpiY)

C.gtk_print_context_set_cairo_context(_arg0, _arg1, _arg2, _arg3)
}
	


	// PrintOperation: gtkPrintOperation is the high-level, portable printing API.
// It looks a bit different than other GTK+ dialogs such as the FileChooser,
// since some platforms don’t expose enough infrastructure to implement a good
// print dialog. On such platforms, GtkPrintOperation uses the native print
// dialog. On platforms which do not provide a native print dialog, GTK+ uses
// its own, see PrintUnixDialog.
// 
// The typical way to use the high-level printing API is to create a
// GtkPrintOperation object with gtk_print_operation_new() when the user selects
// to print. Then you set some properties on it, e.g. the page size, any
// PrintSettings from previous print operations, the number of pages, the
// current page, etc.
// 
// Then you start the print operation by calling gtk_print_operation_run(). It
// will then show a dialog, let the user select a printer and options. When the
// user finished the dialog various signals will be emitted on the
// PrintOperation, the main one being PrintOperation::draw-page, which you are
// supposed to catch and render the page on the provided PrintContext using
// Cairo.
// 
// The high-level printing API
// 
//    static GtkPrintSettings *settings = NULL;
// 
//    static void
//    do_print (void)
//    {
//      GtkPrintOperation *print;
//      GtkPrintOperationResult res;
// 
//      print = gtk_print_operation_new ();
// 
//      if (settings != NULL)
//        gtk_print_operation_set_print_settings (print, settings);
// 
//      g_signal_connect (print, "begin_print", G_CALLBACK (begin_print), NULL);
//      g_signal_connect (print, "draw_page", G_CALLBACK (draw_page), NULL);
// 
//      res = gtk_print_operation_run (print, GTK_PRINT_OPERATION_ACTION_PRINT_DIALOG,
//                                     GTK_WINDOW (main_window), NULL);
// 
//      if (res == GTK_PRINT_OPERATION_RESULT_APPLY)
//        {
//          if (settings != NULL)
//            g_object_unref (settings);
//          settings = g_object_ref (gtk_print_operation_get_print_settings (print));
//        }
// 
//      g_object_unref (print);
//    }
// 
// By default GtkPrintOperation uses an external application to do print
// preview. To implement a custom print preview, an application must connect to
// the preview signal. The functions gtk_print_operation_preview_render_page(),
// gtk_print_operation_preview_end_preview() and
// gtk_print_operation_preview_is_selected() are useful when implementing a
// print preview.
	type PrintOperation struct {
		**externglib.Object
		PrintOperationPreview
		
	}

	// PrintOperationClass is an interface that the PrintOperation class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type PrintOperationClass interface {
		gextras.Objector
		_printOperation()
	}

	func (PrintOperation) _printOperation() {}

	
	func marshalPrintOperation(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapPrintOperation(obj), nil
	}
	

	
	// NewPrintOperation creates a new PrintOperation.
	func NewPrintOperation() PrintOperation {
var _cret *C.GtkPrintOperation // in

_cret = C.gtk_print_operation_new()


var _printOperation PrintOperation // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_printOperation = PrintOperation{
Object: &externglib.Object{externglib.ToGObject(obj)},
PrintOperationPreview: PrintOperationPreview{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _printOperation
}
	

	
	// Cancel cancels a running print operation. This function may be called from a
// PrintOperation::begin-print, PrintOperation::paginate or
// PrintOperation::draw-page signal handler to stop the currently running print
// operation.
	func (o PrintOperation) Cancel()  {
var _arg0 *C.GtkPrintOperation // out

_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))

C.gtk_print_operation_cancel(_arg0)
}
	
	// DrawPageFinish: signalize that drawing of particular page is complete.
// 
// It is called after completion of page drawing (e.g. drawing in another
// thread). If gtk_print_operation_set_defer_drawing() was called before, then
// this function has to be called by application. In another case it is called
// by the library itself.
	func (o PrintOperation) DrawPageFinish()  {
var _arg0 *C.GtkPrintOperation // out

_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))

C.gtk_print_operation_draw_page_finish(_arg0)
}
	
	// DefaultPageSetup returns the default page setup, see
// gtk_print_operation_set_default_page_setup().
	func (o PrintOperation) DefaultPageSetup() PageSetup {
var _arg0 *C.GtkPrintOperation // out
var _cret *C.GtkPageSetup // in

_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))

_cret = C.gtk_print_operation_get_default_page_setup(_arg0)


var _pageSetup PageSetup // out

_pageSetup = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(PageSetup)

return _pageSetup
}
	
	// EmbedPageSetup gets the value of PrintOperation:embed-page-setup property.
	func (o PrintOperation) EmbedPageSetup() bool {
var _arg0 *C.GtkPrintOperation // out
var _cret C.gboolean // in

_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))

_cret = C.gtk_print_operation_get_embed_page_setup(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Error: call this when the result of a print operation is
// GTK_PRINT_OPERATION_RESULT_ERROR, either as returned by
// gtk_print_operation_run(), or in the PrintOperation::done signal handler. The
// returned #GError will contain more details on what went wrong.
	func (o PrintOperation) Error() error {
var _arg0 *C.GtkPrintOperation // out
var _cerr *C.GError // in

_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))

C.gtk_print_operation_get_error(_arg0, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// HasSelection gets the value of PrintOperation:has-selection property.
	func (o PrintOperation) HasSelection() bool {
var _arg0 *C.GtkPrintOperation // out
var _cret C.gboolean // in

_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))

_cret = C.gtk_print_operation_get_has_selection(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// NPagesToPrint returns the number of pages that will be printed.
// 
// Note that this value is set during print preparation phase
// (GTK_PRINT_STATUS_PREPARING), so this function should never be called before
// the data generation phase (GTK_PRINT_STATUS_GENERATING_DATA). You can connect
// to the PrintOperation::status-changed signal and call
// gtk_print_operation_get_n_pages_to_print() when print status is
// GTK_PRINT_STATUS_GENERATING_DATA. This is typically used to track the
// progress of print operation.
	func (o PrintOperation) NPagesToPrint() int {
var _arg0 *C.GtkPrintOperation // out
var _cret C.gint // in

_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))

_cret = C.gtk_print_operation_get_n_pages_to_print(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// PrintSettings returns the current print settings.
// 
// Note that the return value is nil until either
// gtk_print_operation_set_print_settings() or gtk_print_operation_run() have
// been called.
	func (o PrintOperation) PrintSettings() PrintSettings {
var _arg0 *C.GtkPrintOperation // out
var _cret *C.GtkPrintSettings // in

_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))

_cret = C.gtk_print_operation_get_print_settings(_arg0)


var _printSettings PrintSettings // out

_printSettings = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(PrintSettings)

return _printSettings
}
	
	// Status returns the status of the print operation. Also see
// gtk_print_operation_get_status_string().
	func (o PrintOperation) Status() PrintStatus {
var _arg0 *C.GtkPrintOperation // out
var _cret C.GtkPrintStatus // in

_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))

_cret = C.gtk_print_operation_get_status(_arg0)


var _printStatus PrintStatus // out

_printStatus = PrintStatus(_cret)

return _printStatus
}
	
	// StatusString returns a string representation of the status of the print
// operation. The string is translated and suitable for displaying the print
// status e.g. in a Statusbar.
// 
// Use gtk_print_operation_get_status() to obtain a status value that is
// suitable for programmatic use.
	func (o PrintOperation) StatusString() string {
var _arg0 *C.GtkPrintOperation // out
var _cret *C.gchar // in

_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))

_cret = C.gtk_print_operation_get_status_string(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// SupportSelection gets the value of PrintOperation:support-selection property.
	func (o PrintOperation) SupportSelection() bool {
var _arg0 *C.GtkPrintOperation // out
var _cret C.gboolean // in

_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))

_cret = C.gtk_print_operation_get_support_selection(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsFinished: a convenience function to find out if the print operation is
// finished, either successfully (GTK_PRINT_STATUS_FINISHED) or unsuccessfully
// (GTK_PRINT_STATUS_FINISHED_ABORTED).
// 
// Note: when you enable print status tracking the print operation can be in a
// non-finished state even after done has been called, as the operation status
// then tracks the print job status on the printer.
	func (o PrintOperation) IsFinished() bool {
var _arg0 *C.GtkPrintOperation // out
var _cret C.gboolean // in

_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))

_cret = C.gtk_print_operation_is_finished(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Run runs the print operation, by first letting the user modify print settings
// in the print dialog, and then print the document.
// 
// Normally that this function does not return until the rendering of all pages
// is complete. You can connect to the PrintOperation::status-changed signal on
// @op to obtain some information about the progress of the print operation.
// Furthermore, it may use a recursive mainloop to show the print dialog.
// 
// If you call gtk_print_operation_set_allow_async() or set the
// PrintOperation:allow-async property the operation will run asynchronously if
// this is supported on the platform. The PrintOperation::done signal will be
// emitted with the result of the operation when the it is done (i.e. when the
// dialog is canceled, or when the print succeeds or fails).
// 
//    if (settings != NULL)
//      gtk_print_operation_set_print_settings (print, settings);
//      
//    if (page_setup != NULL)
//      gtk_print_operation_set_default_page_setup (print, page_setup);
//      
//    g_signal_connect (print, "begin-print",
//                      G_CALLBACK (begin_print), &data);
//    g_signal_connect (print, "draw-page",
//                      G_CALLBACK (draw_page), &data);
//     
//    res = gtk_print_operation_run (print,
//                                   GTK_PRINT_OPERATION_ACTION_PRINT_DIALOG,
//                                   parent,
//                                   &error);
//     
//    if (res == GTK_PRINT_OPERATION_RESULT_ERROR)
//     {
//       error_dialog = gtk_message_dialog_new (GTK_WINDOW (parent),
//      			                     GTK_DIALOG_DESTROY_WITH_PARENT,
//    					     GTK_MESSAGE_ERROR,
//    					     GTK_BUTTONS_CLOSE,
//    					     "Error printing file:\ns",
//    					     error->message);
//       g_signal_connect (error_dialog, "response",
//                         G_CALLBACK (gtk_widget_destroy), NULL);
//       gtk_widget_show (error_dialog);
//       g_error_free (error);
//     }
//    else if (res == GTK_PRINT_OPERATION_RESULT_APPLY)
//     {
//       if (settings != NULL)
//    g_object_unref (settings);
//       settings = g_object_ref (gtk_print_operation_get_print_settings (print));
//     }
// 
// Note that gtk_print_operation_run() can only be called once on a given
// PrintOperation.
	func (o PrintOperation) Run(action PrintOperationAction, parent WindowClass) (PrintOperationResult, error) {
var _arg0 *C.GtkPrintOperation // out
var _arg1 C.GtkPrintOperationAction // out
var _arg2 *C.GtkWindow // out
var _cret C.GtkPrintOperationResult // in
var _cerr *C.GError // in

_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))
_arg1 = (C.GtkPrintOperationAction)(action)
_arg2 = (*C.GtkWindow)(unsafe.Pointer(parent.Native()))

_cret = C.gtk_print_operation_run(_arg0, _arg1, _arg2, &_cerr)


var _printOperationResult PrintOperationResult // out
var _goerr error // out

_printOperationResult = PrintOperationResult(_cret)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _printOperationResult, _goerr
}
	
	// SetAllowAsync sets whether the gtk_print_operation_run() may return before
// the print operation is completed. Note that some platforms may not allow
// asynchronous operation.
	func (o PrintOperation) SetAllowAsync(allowAsync bool)  {
var _arg0 *C.GtkPrintOperation // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))
if allowAsync { _arg1 = C.TRUE }

C.gtk_print_operation_set_allow_async(_arg0, _arg1)
}
	
	// SetCurrentPage sets the current page.
// 
// If this is called before gtk_print_operation_run(), the user will be able to
// select to print only the current page.
// 
// Note that this only makes sense for pre-paginated documents.
	func (o PrintOperation) SetCurrentPage(currentPage int)  {
var _arg0 *C.GtkPrintOperation // out
var _arg1 C.gint // out

_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))
_arg1 = (C.gint)(currentPage)

C.gtk_print_operation_set_current_page(_arg0, _arg1)
}
	
	// SetCustomTabLabel sets the label for the tab holding custom widgets.
	func (o PrintOperation) SetCustomTabLabel(label string)  {
var _arg0 *C.GtkPrintOperation // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))
_arg1 = (*C.gchar)(C.CString(label))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_print_operation_set_custom_tab_label(_arg0, _arg1)
}
	
	// SetDefaultPageSetup makes @default_page_setup the default page setup for @op.
// 
// This page setup will be used by gtk_print_operation_run(), but it can be
// overridden on a per-page basis by connecting to the
// PrintOperation::request-page-setup signal.
	func (o PrintOperation) SetDefaultPageSetup(defaultPageSetup PageSetupClass)  {
var _arg0 *C.GtkPrintOperation // out
var _arg1 *C.GtkPageSetup // out

_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))
_arg1 = (*C.GtkPageSetup)(unsafe.Pointer(defaultPageSetup.Native()))

C.gtk_print_operation_set_default_page_setup(_arg0, _arg1)
}
	
	// SetDeferDrawing sets up the PrintOperation to wait for calling of
// gtk_print_operation_draw_page_finish() from application. It can be used for
// drawing page in another thread.
// 
// This function must be called in the callback of “draw-page” signal.
	func (o PrintOperation) SetDeferDrawing()  {
var _arg0 *C.GtkPrintOperation // out

_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))

C.gtk_print_operation_set_defer_drawing(_arg0)
}
	
	// SetEmbedPageSetup: embed page size combo box and orientation combo box into
// page setup page. Selected page setup is stored as default page setup in
// PrintOperation.
	func (o PrintOperation) SetEmbedPageSetup(embed bool)  {
var _arg0 *C.GtkPrintOperation // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))
if embed { _arg1 = C.TRUE }

C.gtk_print_operation_set_embed_page_setup(_arg0, _arg1)
}
	
	// SetExportFilename sets up the PrintOperation to generate a file instead of
// showing the print dialog. The indended use of this function is for
// implementing “Export to PDF” actions. Currently, PDF is the only supported
// format.
// 
// “Print to PDF” support is independent of this and is done by letting the user
// pick the “Print to PDF” item from the list of printers in the print dialog.
	func (o PrintOperation) SetExportFilename(filename string)  {
var _arg0 *C.GtkPrintOperation // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))
_arg1 = (*C.gchar)(C.CString(filename))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_print_operation_set_export_filename(_arg0, _arg1)
}
	
	// SetHasSelection sets whether there is a selection to print.
// 
// Application has to set number of pages to which the selection will draw by
// gtk_print_operation_set_n_pages() in a callback of
// PrintOperation::begin-print.
	func (o PrintOperation) SetHasSelection(hasSelection bool)  {
var _arg0 *C.GtkPrintOperation // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))
if hasSelection { _arg1 = C.TRUE }

C.gtk_print_operation_set_has_selection(_arg0, _arg1)
}
	
	// SetJobName sets the name of the print job. The name is used to identify the
// job (e.g. in monitoring applications like eggcups).
// 
// If you don’t set a job name, GTK+ picks a default one by numbering successive
// print jobs.
	func (o PrintOperation) SetJobName(jobName string)  {
var _arg0 *C.GtkPrintOperation // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))
_arg1 = (*C.gchar)(C.CString(jobName))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_print_operation_set_job_name(_arg0, _arg1)
}
	
	// SetNPages sets the number of pages in the document.
// 
// This must be set to a positive number before the rendering starts. It may be
// set in a PrintOperation::begin-print signal hander.
// 
// Note that the page numbers passed to the PrintOperation::request-page-setup
// and PrintOperation::draw-page signals are 0-based, i.e. if the user chooses
// to print all pages, the last ::draw-page signal will be for page @n_pages -
// 1.
	func (o PrintOperation) SetNPages(nPages int)  {
var _arg0 *C.GtkPrintOperation // out
var _arg1 C.gint // out

_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))
_arg1 = (C.gint)(nPages)

C.gtk_print_operation_set_n_pages(_arg0, _arg1)
}
	
	// SetPrintSettings sets the print settings for @op. This is typically used to
// re-establish print settings from a previous print operation, see
// gtk_print_operation_run().
	func (o PrintOperation) SetPrintSettings(printSettings PrintSettingsClass)  {
var _arg0 *C.GtkPrintOperation // out
var _arg1 *C.GtkPrintSettings // out

_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))
_arg1 = (*C.GtkPrintSettings)(unsafe.Pointer(printSettings.Native()))

C.gtk_print_operation_set_print_settings(_arg0, _arg1)
}
	
	// SetShowProgress: if @show_progress is true, the print operation will show a
// progress dialog during the print operation.
	func (o PrintOperation) SetShowProgress(showProgress bool)  {
var _arg0 *C.GtkPrintOperation // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))
if showProgress { _arg1 = C.TRUE }

C.gtk_print_operation_set_show_progress(_arg0, _arg1)
}
	
	// SetSupportSelection sets whether selection is supported by PrintOperation.
	func (o PrintOperation) SetSupportSelection(supportSelection bool)  {
var _arg0 *C.GtkPrintOperation // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))
if supportSelection { _arg1 = C.TRUE }

C.gtk_print_operation_set_support_selection(_arg0, _arg1)
}
	
	// SetTrackPrintStatus: if track_status is true, the print operation will try to
// continue report on the status of the print job in the printer queues and
// printer. This can allow your application to show things like “out of paper”
// issues, and when the print job actually reaches the printer.
// 
// This function is often implemented using some form of polling, so it should
// not be enabled unless needed.
	func (o PrintOperation) SetTrackPrintStatus(trackStatus bool)  {
var _arg0 *C.GtkPrintOperation // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))
if trackStatus { _arg1 = C.TRUE }

C.gtk_print_operation_set_track_print_status(_arg0, _arg1)
}
	
	// SetUnit sets up the transformation for the cairo context obtained from
// PrintContext in such a way that distances are measured in units of @unit.
	func (o PrintOperation) SetUnit(unit Unit)  {
var _arg0 *C.GtkPrintOperation // out
var _arg1 C.GtkUnit // out

_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))
_arg1 = (C.GtkUnit)(unit)

C.gtk_print_operation_set_unit(_arg0, _arg1)
}
	
	// SetUseFullPage: if @full_page is true, the transformation for the cairo
// context obtained from PrintContext puts the origin at the top left corner of
// the page (which may not be the top left corner of the sheet, depending on
// page orientation and the number of pages per sheet). Otherwise, the origin is
// at the top left corner of the imageable area (i.e. inside the margins).
	func (o PrintOperation) SetUseFullPage(fullPage bool)  {
var _arg0 *C.GtkPrintOperation // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))
if fullPage { _arg1 = C.TRUE }

C.gtk_print_operation_set_use_full_page(_arg0, _arg1)
}
	


	// PrintSettings: a GtkPrintSettings object represents the settings of a print
// dialog in a system-independent way. The main use for this object is that once
// you’ve printed you can get a settings object that represents the settings the
// user chose, and the next time you print you can pass that object in so that
// the user doesn’t have to re-set all his settings.
// 
// Its also possible to enumerate the settings so that you can easily save the
// settings for the next time your app runs, or even store them in a document.
// The predefined keys try to use shared values as much as possible so that
// moving such a document between systems still works.
// 
// Printing support was added in GTK+ 2.10.
	type PrintSettings struct {
		**externglib.Object
		
	}

	// PrintSettingsClass is an interface that the PrintSettings class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type PrintSettingsClass interface {
		gextras.Objector
		_printSettings()
	}

	func (PrintSettings) _printSettings() {}

	
	func marshalPrintSettings(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapPrintSettings(obj), nil
	}
	

	
	// NewPrintSettings creates a new PrintSettings object.
	func NewPrintSettings() PrintSettings {
var _cret *C.GtkPrintSettings // in

_cret = C.gtk_print_settings_new()


var _printSettings PrintSettings // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_printSettings = PrintSettings{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}

return _printSettings
}
	
	// NewPrintSettingsFromFile reads the print settings from @file_name. Returns a
// new PrintSettings object with the restored settings, or nil if an error
// occurred. If the file could not be loaded then error is set to either a Error
// or FileError. See gtk_print_settings_to_file().
	func NewPrintSettingsFromFile(fileName string) (PrintSettings, error) {
var _arg1 *C.gchar // out
var _cret *C.GtkPrintSettings // in
var _cerr *C.GError // in

_arg1 = (*C.gchar)(C.CString(fileName))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_print_settings_new_from_file(_arg1, &_cerr)


var _printSettings PrintSettings // out
var _goerr error // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_printSettings = PrintSettings{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _printSettings, _goerr
}
	
	// NewPrintSettingsFromGVariant: deserialize print settings from an a{sv}
// variant in the format produced by gtk_print_settings_to_gvariant().
	func NewPrintSettingsFromGVariant(variant *glib.Variant) PrintSettings {
var _arg1 *C.GVariant // out
var _cret *C.GtkPrintSettings // in

_arg1 = (*C.GVariant)(unsafe.Pointer(variant.Native()))

_cret = C.gtk_print_settings_new_from_gvariant(_arg1)


var _printSettings PrintSettings // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_printSettings = PrintSettings{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}

return _printSettings
}
	
	// NewPrintSettingsFromKeyFile reads the print settings from the group
// @group_name in @key_file. Returns a new PrintSettings object with the
// restored settings, or nil if an error occurred. If the file could not be
// loaded then error is set to either a Error or FileError.
	func NewPrintSettingsFromKeyFile(keyFile *glib.KeyFile, groupName string) (PrintSettings, error) {
var _arg1 *C.GKeyFile // out
var _arg2 *C.gchar // out
var _cret *C.GtkPrintSettings // in
var _cerr *C.GError // in

_arg1 = (*C.GKeyFile)(unsafe.Pointer(keyFile.Native()))
_arg2 = (*C.gchar)(C.CString(groupName))
defer C.free(unsafe.Pointer(_arg2))

_cret = C.gtk_print_settings_new_from_key_file(_arg1, _arg2, &_cerr)


var _printSettings PrintSettings // out
var _goerr error // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_printSettings = PrintSettings{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _printSettings, _goerr
}
	

	
	// Copy copies a PrintSettings object.
	func (o PrintSettings) Copy() PrintSettings {
var _arg0 *C.GtkPrintSettings // out
var _cret *C.GtkPrintSettings // in

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(o.Native()))

_cret = C.gtk_print_settings_copy(_arg0)


var _printSettings PrintSettings // out

_printSettings = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(PrintSettings)

return _printSettings
}
	
	// Get looks up the string value associated with @key.
	func (s PrintSettings) Get(key string) string {
var _arg0 *C.GtkPrintSettings // out
var _arg1 *C.gchar // out
var _cret *C.gchar // in

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(key))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_print_settings_get(_arg0, _arg1)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Bool returns the boolean represented by the value that is associated with
// @key.
// 
// The string “true” represents true, any other string false.
	func (s PrintSettings) Bool(key string) bool {
var _arg0 *C.GtkPrintSettings // out
var _arg1 *C.gchar // out
var _cret C.gboolean // in

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(key))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_print_settings_get_bool(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Collate gets the value of GTK_PRINT_SETTINGS_COLLATE.
	func (s PrintSettings) Collate() bool {
var _arg0 *C.GtkPrintSettings // out
var _cret C.gboolean // in

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

_cret = C.gtk_print_settings_get_collate(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// DefaultSource gets the value of GTK_PRINT_SETTINGS_DEFAULT_SOURCE.
	func (s PrintSettings) DefaultSource() string {
var _arg0 *C.GtkPrintSettings // out
var _cret *C.gchar // in

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

_cret = C.gtk_print_settings_get_default_source(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Dither gets the value of GTK_PRINT_SETTINGS_DITHER.
	func (s PrintSettings) Dither() string {
var _arg0 *C.GtkPrintSettings // out
var _cret *C.gchar // in

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

_cret = C.gtk_print_settings_get_dither(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Double returns the double value associated with @key, or 0.
	func (s PrintSettings) Double(key string) float64 {
var _arg0 *C.GtkPrintSettings // out
var _arg1 *C.gchar // out
var _cret C.gdouble // in

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(key))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_print_settings_get_double(_arg0, _arg1)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// DoubleWithDefault returns the floating point number represented by the value
// that is associated with @key, or @default_val if the value does not represent
// a floating point number.
// 
// Floating point numbers are parsed with g_ascii_strtod().
	func (s PrintSettings) DoubleWithDefault(key string, def float64) float64 {
var _arg0 *C.GtkPrintSettings // out
var _arg1 *C.gchar // out
var _arg2 C.gdouble // out
var _cret C.gdouble // in

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(key))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.gdouble)(def)

_cret = C.gtk_print_settings_get_double_with_default(_arg0, _arg1, _arg2)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// Duplex gets the value of GTK_PRINT_SETTINGS_DUPLEX.
	func (s PrintSettings) Duplex() PrintDuplex {
var _arg0 *C.GtkPrintSettings // out
var _cret C.GtkPrintDuplex // in

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

_cret = C.gtk_print_settings_get_duplex(_arg0)


var _printDuplex PrintDuplex // out

_printDuplex = PrintDuplex(_cret)

return _printDuplex
}
	
	// Finishings gets the value of GTK_PRINT_SETTINGS_FINISHINGS.
	func (s PrintSettings) Finishings() string {
var _arg0 *C.GtkPrintSettings // out
var _cret *C.gchar // in

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

_cret = C.gtk_print_settings_get_finishings(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Int returns the integer value of @key, or 0.
	func (s PrintSettings) Int(key string) int {
var _arg0 *C.GtkPrintSettings // out
var _arg1 *C.gchar // out
var _cret C.gint // in

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(key))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_print_settings_get_int(_arg0, _arg1)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// IntWithDefault returns the value of @key, interpreted as an integer, or the
// default value.
	func (s PrintSettings) IntWithDefault(key string, def int) int {
var _arg0 *C.GtkPrintSettings // out
var _arg1 *C.gchar // out
var _arg2 C.gint // out
var _cret C.gint // in

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(key))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.gint)(def)

_cret = C.gtk_print_settings_get_int_with_default(_arg0, _arg1, _arg2)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Length returns the value associated with @key, interpreted as a length. The
// returned value is converted to @units.
	func (s PrintSettings) Length(key string, unit Unit) float64 {
var _arg0 *C.GtkPrintSettings // out
var _arg1 *C.gchar // out
var _arg2 C.GtkUnit // out
var _cret C.gdouble // in

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(key))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.GtkUnit)(unit)

_cret = C.gtk_print_settings_get_length(_arg0, _arg1, _arg2)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// MediaType gets the value of GTK_PRINT_SETTINGS_MEDIA_TYPE.
// 
// The set of media types is defined in PWG 5101.1-2002 PWG.
	func (s PrintSettings) MediaType() string {
var _arg0 *C.GtkPrintSettings // out
var _cret *C.gchar // in

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

_cret = C.gtk_print_settings_get_media_type(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// NCopies gets the value of GTK_PRINT_SETTINGS_N_COPIES.
	func (s PrintSettings) NCopies() int {
var _arg0 *C.GtkPrintSettings // out
var _cret C.gint // in

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

_cret = C.gtk_print_settings_get_n_copies(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// NumberUp gets the value of GTK_PRINT_SETTINGS_NUMBER_UP.
	func (s PrintSettings) NumberUp() int {
var _arg0 *C.GtkPrintSettings // out
var _cret C.gint // in

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

_cret = C.gtk_print_settings_get_number_up(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// NumberUpLayout gets the value of GTK_PRINT_SETTINGS_NUMBER_UP_LAYOUT.
	func (s PrintSettings) NumberUpLayout() NumberUpLayout {
var _arg0 *C.GtkPrintSettings // out
var _cret C.GtkNumberUpLayout // in

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

_cret = C.gtk_print_settings_get_number_up_layout(_arg0)


var _numberUpLayout NumberUpLayout // out

_numberUpLayout = NumberUpLayout(_cret)

return _numberUpLayout
}
	
	// Orientation: get the value of GTK_PRINT_SETTINGS_ORIENTATION, converted to a
// PageOrientation.
	func (s PrintSettings) Orientation() PageOrientation {
var _arg0 *C.GtkPrintSettings // out
var _cret C.GtkPageOrientation // in

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

_cret = C.gtk_print_settings_get_orientation(_arg0)


var _pageOrientation PageOrientation // out

_pageOrientation = PageOrientation(_cret)

return _pageOrientation
}
	
	// OutputBin gets the value of GTK_PRINT_SETTINGS_OUTPUT_BIN.
	func (s PrintSettings) OutputBin() string {
var _arg0 *C.GtkPrintSettings // out
var _cret *C.gchar // in

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

_cret = C.gtk_print_settings_get_output_bin(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// PageSet gets the value of GTK_PRINT_SETTINGS_PAGE_SET.
	func (s PrintSettings) PageSet() PageSet {
var _arg0 *C.GtkPrintSettings // out
var _cret C.GtkPageSet // in

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

_cret = C.gtk_print_settings_get_page_set(_arg0)


var _pageSet PageSet // out

_pageSet = PageSet(_cret)

return _pageSet
}
	
	// PaperHeight gets the value of GTK_PRINT_SETTINGS_PAPER_HEIGHT, converted to
// @unit.
	func (s PrintSettings) PaperHeight(unit Unit) float64 {
var _arg0 *C.GtkPrintSettings // out
var _arg1 C.GtkUnit // out
var _cret C.gdouble // in

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkUnit)(unit)

_cret = C.gtk_print_settings_get_paper_height(_arg0, _arg1)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// PaperSize gets the value of GTK_PRINT_SETTINGS_PAPER_FORMAT, converted to a
// PaperSize.
	func (s PrintSettings) PaperSize() *PaperSize {
var _arg0 *C.GtkPrintSettings // out
var _cret *C.GtkPaperSize // in

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

_cret = C.gtk_print_settings_get_paper_size(_arg0)


var _paperSize *PaperSize // out

_paperSize = *(**PaperSize)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_paperSize, func(v *PaperSize) {
  C.free(unsafe.Pointer(v.Native()))
})

return _paperSize
}
	
	// PaperWidth gets the value of GTK_PRINT_SETTINGS_PAPER_WIDTH, converted to
// @unit.
	func (s PrintSettings) PaperWidth(unit Unit) float64 {
var _arg0 *C.GtkPrintSettings // out
var _arg1 C.GtkUnit // out
var _cret C.gdouble // in

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkUnit)(unit)

_cret = C.gtk_print_settings_get_paper_width(_arg0, _arg1)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// PrintPages gets the value of GTK_PRINT_SETTINGS_PRINT_PAGES.
	func (s PrintSettings) PrintPages() PrintPages {
var _arg0 *C.GtkPrintSettings // out
var _cret C.GtkPrintPages // in

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

_cret = C.gtk_print_settings_get_print_pages(_arg0)


var _printPages PrintPages // out

_printPages = PrintPages(_cret)

return _printPages
}
	
	// Printer: convenience function to obtain the value of
// GTK_PRINT_SETTINGS_PRINTER.
	func (s PrintSettings) Printer() string {
var _arg0 *C.GtkPrintSettings // out
var _cret *C.gchar // in

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

_cret = C.gtk_print_settings_get_printer(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// PrinterLpi gets the value of GTK_PRINT_SETTINGS_PRINTER_LPI.
	func (s PrintSettings) PrinterLpi() float64 {
var _arg0 *C.GtkPrintSettings // out
var _cret C.gdouble // in

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

_cret = C.gtk_print_settings_get_printer_lpi(_arg0)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// Quality gets the value of GTK_PRINT_SETTINGS_QUALITY.
	func (s PrintSettings) Quality() PrintQuality {
var _arg0 *C.GtkPrintSettings // out
var _cret C.GtkPrintQuality // in

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

_cret = C.gtk_print_settings_get_quality(_arg0)


var _printQuality PrintQuality // out

_printQuality = PrintQuality(_cret)

return _printQuality
}
	
	// Resolution gets the value of GTK_PRINT_SETTINGS_RESOLUTION.
	func (s PrintSettings) Resolution() int {
var _arg0 *C.GtkPrintSettings // out
var _cret C.gint // in

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

_cret = C.gtk_print_settings_get_resolution(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// ResolutionX gets the value of GTK_PRINT_SETTINGS_RESOLUTION_X.
	func (s PrintSettings) ResolutionX() int {
var _arg0 *C.GtkPrintSettings // out
var _cret C.gint // in

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

_cret = C.gtk_print_settings_get_resolution_x(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// ResolutionY gets the value of GTK_PRINT_SETTINGS_RESOLUTION_Y.
	func (s PrintSettings) ResolutionY() int {
var _arg0 *C.GtkPrintSettings // out
var _cret C.gint // in

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

_cret = C.gtk_print_settings_get_resolution_y(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Reverse gets the value of GTK_PRINT_SETTINGS_REVERSE.
	func (s PrintSettings) Reverse() bool {
var _arg0 *C.GtkPrintSettings // out
var _cret C.gboolean // in

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

_cret = C.gtk_print_settings_get_reverse(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Scale gets the value of GTK_PRINT_SETTINGS_SCALE.
	func (s PrintSettings) Scale() float64 {
var _arg0 *C.GtkPrintSettings // out
var _cret C.gdouble // in

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

_cret = C.gtk_print_settings_get_scale(_arg0)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// UseColor gets the value of GTK_PRINT_SETTINGS_USE_COLOR.
	func (s PrintSettings) UseColor() bool {
var _arg0 *C.GtkPrintSettings // out
var _cret C.gboolean // in

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

_cret = C.gtk_print_settings_get_use_color(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// HasKey returns true, if a value is associated with @key.
	func (s PrintSettings) HasKey(key string) bool {
var _arg0 *C.GtkPrintSettings // out
var _arg1 *C.gchar // out
var _cret C.gboolean // in

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(key))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_print_settings_has_key(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// LoadFile reads the print settings from @file_name. If the file could not be
// loaded then error is set to either a Error or FileError. See
// gtk_print_settings_to_file().
	func (s PrintSettings) LoadFile(fileName string) error {
var _arg0 *C.GtkPrintSettings // out
var _arg1 *C.gchar // out
var _cerr *C.GError // in

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(fileName))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_print_settings_load_file(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// LoadKeyFile reads the print settings from the group @group_name in @key_file.
// If the file could not be loaded then error is set to either a Error or
// FileError.
	func (s PrintSettings) LoadKeyFile(keyFile *glib.KeyFile, groupName string) error {
var _arg0 *C.GtkPrintSettings // out
var _arg1 *C.GKeyFile // out
var _arg2 *C.gchar // out
var _cerr *C.GError // in

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GKeyFile)(unsafe.Pointer(keyFile.Native()))
_arg2 = (*C.gchar)(C.CString(groupName))
defer C.free(unsafe.Pointer(_arg2))

C.gtk_print_settings_load_key_file(_arg0, _arg1, _arg2, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// Set associates @value with @key.
	func (s PrintSettings) Set(key string, value string)  {
var _arg0 *C.GtkPrintSettings // out
var _arg1 *C.gchar // out
var _arg2 *C.gchar // out

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(key))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.gchar)(C.CString(value))
defer C.free(unsafe.Pointer(_arg2))

C.gtk_print_settings_set(_arg0, _arg1, _arg2)
}
	
	// SetBool sets @key to a boolean value.
	func (s PrintSettings) SetBool(key string, value bool)  {
var _arg0 *C.GtkPrintSettings // out
var _arg1 *C.gchar // out
var _arg2 C.gboolean // out

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(key))
defer C.free(unsafe.Pointer(_arg1))
if value { _arg2 = C.TRUE }

C.gtk_print_settings_set_bool(_arg0, _arg1, _arg2)
}
	
	// SetCollate sets the value of GTK_PRINT_SETTINGS_COLLATE.
	func (s PrintSettings) SetCollate(collate bool)  {
var _arg0 *C.GtkPrintSettings // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
if collate { _arg1 = C.TRUE }

C.gtk_print_settings_set_collate(_arg0, _arg1)
}
	
	// SetDefaultSource sets the value of GTK_PRINT_SETTINGS_DEFAULT_SOURCE.
	func (s PrintSettings) SetDefaultSource(defaultSource string)  {
var _arg0 *C.GtkPrintSettings // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(defaultSource))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_print_settings_set_default_source(_arg0, _arg1)
}
	
	// SetDither sets the value of GTK_PRINT_SETTINGS_DITHER.
	func (s PrintSettings) SetDither(dither string)  {
var _arg0 *C.GtkPrintSettings // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(dither))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_print_settings_set_dither(_arg0, _arg1)
}
	
	// SetDouble sets @key to a double value.
	func (s PrintSettings) SetDouble(key string, value float64)  {
var _arg0 *C.GtkPrintSettings // out
var _arg1 *C.gchar // out
var _arg2 C.gdouble // out

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(key))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.gdouble)(value)

C.gtk_print_settings_set_double(_arg0, _arg1, _arg2)
}
	
	// SetDuplex sets the value of GTK_PRINT_SETTINGS_DUPLEX.
	func (s PrintSettings) SetDuplex(duplex PrintDuplex)  {
var _arg0 *C.GtkPrintSettings // out
var _arg1 C.GtkPrintDuplex // out

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkPrintDuplex)(duplex)

C.gtk_print_settings_set_duplex(_arg0, _arg1)
}
	
	// SetFinishings sets the value of GTK_PRINT_SETTINGS_FINISHINGS.
	func (s PrintSettings) SetFinishings(finishings string)  {
var _arg0 *C.GtkPrintSettings // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(finishings))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_print_settings_set_finishings(_arg0, _arg1)
}
	
	// SetInt sets @key to an integer value.
	func (s PrintSettings) SetInt(key string, value int)  {
var _arg0 *C.GtkPrintSettings // out
var _arg1 *C.gchar // out
var _arg2 C.gint // out

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(key))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.gint)(value)

C.gtk_print_settings_set_int(_arg0, _arg1, _arg2)
}
	
	// SetLength associates a length in units of @unit with @key.
	func (s PrintSettings) SetLength(key string, value float64, unit Unit)  {
var _arg0 *C.GtkPrintSettings // out
var _arg1 *C.gchar // out
var _arg2 C.gdouble // out
var _arg3 C.GtkUnit // out

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(key))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.gdouble)(value)
_arg3 = (C.GtkUnit)(unit)

C.gtk_print_settings_set_length(_arg0, _arg1, _arg2, _arg3)
}
	
	// SetMediaType sets the value of GTK_PRINT_SETTINGS_MEDIA_TYPE.
// 
// The set of media types is defined in PWG 5101.1-2002 PWG.
	func (s PrintSettings) SetMediaType(mediaType string)  {
var _arg0 *C.GtkPrintSettings // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(mediaType))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_print_settings_set_media_type(_arg0, _arg1)
}
	
	// SetNCopies sets the value of GTK_PRINT_SETTINGS_N_COPIES.
	func (s PrintSettings) SetNCopies(numCopies int)  {
var _arg0 *C.GtkPrintSettings // out
var _arg1 C.gint // out

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
_arg1 = (C.gint)(numCopies)

C.gtk_print_settings_set_n_copies(_arg0, _arg1)
}
	
	// SetNumberUp sets the value of GTK_PRINT_SETTINGS_NUMBER_UP.
	func (s PrintSettings) SetNumberUp(numberUp int)  {
var _arg0 *C.GtkPrintSettings // out
var _arg1 C.gint // out

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
_arg1 = (C.gint)(numberUp)

C.gtk_print_settings_set_number_up(_arg0, _arg1)
}
	
	// SetNumberUpLayout sets the value of GTK_PRINT_SETTINGS_NUMBER_UP_LAYOUT.
	func (s PrintSettings) SetNumberUpLayout(numberUpLayout NumberUpLayout)  {
var _arg0 *C.GtkPrintSettings // out
var _arg1 C.GtkNumberUpLayout // out

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkNumberUpLayout)(numberUpLayout)

C.gtk_print_settings_set_number_up_layout(_arg0, _arg1)
}
	
	// SetOrientation sets the value of GTK_PRINT_SETTINGS_ORIENTATION.
	func (s PrintSettings) SetOrientation(orientation PageOrientation)  {
var _arg0 *C.GtkPrintSettings // out
var _arg1 C.GtkPageOrientation // out

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkPageOrientation)(orientation)

C.gtk_print_settings_set_orientation(_arg0, _arg1)
}
	
	// SetOutputBin sets the value of GTK_PRINT_SETTINGS_OUTPUT_BIN.
	func (s PrintSettings) SetOutputBin(outputBin string)  {
var _arg0 *C.GtkPrintSettings // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(outputBin))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_print_settings_set_output_bin(_arg0, _arg1)
}
	
	// SetPageRanges sets the value of GTK_PRINT_SETTINGS_PAGE_RANGES.
	func (s PrintSettings) SetPageRanges(pageRanges []PageRange)  {
var _arg0 *C.GtkPrintSettings // out
var _arg1 *C.GtkPageRange
var _arg2 C.gint

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
_arg2 = C.gint(len(pageRanges))
_arg1 = (*C.GtkPageRange)(unsafe.Pointer(&pageRanges[0]))

C.gtk_print_settings_set_page_ranges(_arg0, _arg1, _arg2)
}
	
	// SetPageSet sets the value of GTK_PRINT_SETTINGS_PAGE_SET.
	func (s PrintSettings) SetPageSet(pageSet PageSet)  {
var _arg0 *C.GtkPrintSettings // out
var _arg1 C.GtkPageSet // out

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkPageSet)(pageSet)

C.gtk_print_settings_set_page_set(_arg0, _arg1)
}
	
	// SetPaperHeight sets the value of GTK_PRINT_SETTINGS_PAPER_HEIGHT.
	func (s PrintSettings) SetPaperHeight(height float64, unit Unit)  {
var _arg0 *C.GtkPrintSettings // out
var _arg1 C.gdouble // out
var _arg2 C.GtkUnit // out

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
_arg1 = (C.gdouble)(height)
_arg2 = (C.GtkUnit)(unit)

C.gtk_print_settings_set_paper_height(_arg0, _arg1, _arg2)
}
	
	// SetPaperSize sets the value of GTK_PRINT_SETTINGS_PAPER_FORMAT,
// GTK_PRINT_SETTINGS_PAPER_WIDTH and GTK_PRINT_SETTINGS_PAPER_HEIGHT.
	func (s PrintSettings) SetPaperSize(paperSize *PaperSize)  {
var _arg0 *C.GtkPrintSettings // out
var _arg1 *C.GtkPaperSize // out

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkPaperSize)(unsafe.Pointer(paperSize.Native()))

C.gtk_print_settings_set_paper_size(_arg0, _arg1)
}
	
	// SetPaperWidth sets the value of GTK_PRINT_SETTINGS_PAPER_WIDTH.
	func (s PrintSettings) SetPaperWidth(width float64, unit Unit)  {
var _arg0 *C.GtkPrintSettings // out
var _arg1 C.gdouble // out
var _arg2 C.GtkUnit // out

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
_arg1 = (C.gdouble)(width)
_arg2 = (C.GtkUnit)(unit)

C.gtk_print_settings_set_paper_width(_arg0, _arg1, _arg2)
}
	
	// SetPrintPages sets the value of GTK_PRINT_SETTINGS_PRINT_PAGES.
	func (s PrintSettings) SetPrintPages(pages PrintPages)  {
var _arg0 *C.GtkPrintSettings // out
var _arg1 C.GtkPrintPages // out

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkPrintPages)(pages)

C.gtk_print_settings_set_print_pages(_arg0, _arg1)
}
	
	// SetPrinter: convenience function to set GTK_PRINT_SETTINGS_PRINTER to
// @printer.
	func (s PrintSettings) SetPrinter(printer string)  {
var _arg0 *C.GtkPrintSettings // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(printer))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_print_settings_set_printer(_arg0, _arg1)
}
	
	// SetPrinterLpi sets the value of GTK_PRINT_SETTINGS_PRINTER_LPI.
	func (s PrintSettings) SetPrinterLpi(lpi float64)  {
var _arg0 *C.GtkPrintSettings // out
var _arg1 C.gdouble // out

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
_arg1 = (C.gdouble)(lpi)

C.gtk_print_settings_set_printer_lpi(_arg0, _arg1)
}
	
	// SetQuality sets the value of GTK_PRINT_SETTINGS_QUALITY.
	func (s PrintSettings) SetQuality(quality PrintQuality)  {
var _arg0 *C.GtkPrintSettings // out
var _arg1 C.GtkPrintQuality // out

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkPrintQuality)(quality)

C.gtk_print_settings_set_quality(_arg0, _arg1)
}
	
	// SetResolution sets the values of GTK_PRINT_SETTINGS_RESOLUTION,
// GTK_PRINT_SETTINGS_RESOLUTION_X and GTK_PRINT_SETTINGS_RESOLUTION_Y.
	func (s PrintSettings) SetResolution(resolution int)  {
var _arg0 *C.GtkPrintSettings // out
var _arg1 C.gint // out

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
_arg1 = (C.gint)(resolution)

C.gtk_print_settings_set_resolution(_arg0, _arg1)
}
	
	// SetResolutionXY sets the values of GTK_PRINT_SETTINGS_RESOLUTION,
// GTK_PRINT_SETTINGS_RESOLUTION_X and GTK_PRINT_SETTINGS_RESOLUTION_Y.
	func (s PrintSettings) SetResolutionXY(resolutionX int, resolutionY int)  {
var _arg0 *C.GtkPrintSettings // out
var _arg1 C.gint // out
var _arg2 C.gint // out

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
_arg1 = (C.gint)(resolutionX)
_arg2 = (C.gint)(resolutionY)

C.gtk_print_settings_set_resolution_xy(_arg0, _arg1, _arg2)
}
	
	// SetReverse sets the value of GTK_PRINT_SETTINGS_REVERSE.
	func (s PrintSettings) SetReverse(reverse bool)  {
var _arg0 *C.GtkPrintSettings // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
if reverse { _arg1 = C.TRUE }

C.gtk_print_settings_set_reverse(_arg0, _arg1)
}
	
	// SetScale sets the value of GTK_PRINT_SETTINGS_SCALE.
	func (s PrintSettings) SetScale(scale float64)  {
var _arg0 *C.GtkPrintSettings // out
var _arg1 C.gdouble // out

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
_arg1 = (C.gdouble)(scale)

C.gtk_print_settings_set_scale(_arg0, _arg1)
}
	
	// SetUseColor sets the value of GTK_PRINT_SETTINGS_USE_COLOR.
	func (s PrintSettings) SetUseColor(useColor bool)  {
var _arg0 *C.GtkPrintSettings // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
if useColor { _arg1 = C.TRUE }

C.gtk_print_settings_set_use_color(_arg0, _arg1)
}
	
	// ToFile: this function saves the print settings from @settings to @file_name.
// If the file could not be loaded then error is set to either a Error or
// FileError.
	func (s PrintSettings) ToFile(fileName string) error {
var _arg0 *C.GtkPrintSettings // out
var _arg1 *C.gchar // out
var _cerr *C.GError // in

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(fileName))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_print_settings_to_file(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// ToGVariant: serialize print settings to an a{sv} variant.
	func (s PrintSettings) ToGVariant() *glib.Variant {
var _arg0 *C.GtkPrintSettings // out
var _cret *C.GVariant // in

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

_cret = C.gtk_print_settings_to_gvariant(_arg0)


var _variant *glib.Variant // out

_variant = *(**glib.Variant)(unsafe.Pointer(&_cret))

return _variant
}
	
	// ToKeyFile: this function adds the print settings from @settings to @key_file.
	func (s PrintSettings) ToKeyFile(keyFile *glib.KeyFile, groupName string)  {
var _arg0 *C.GtkPrintSettings // out
var _arg1 *C.GKeyFile // out
var _arg2 *C.gchar // out

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GKeyFile)(unsafe.Pointer(keyFile.Native()))
_arg2 = (*C.gchar)(C.CString(groupName))
defer C.free(unsafe.Pointer(_arg2))

C.gtk_print_settings_to_key_file(_arg0, _arg1, _arg2)
}
	
	// Unset removes any value associated with @key. This has the same effect as
// setting the value to nil.
	func (s PrintSettings) Unset(key string)  {
var _arg0 *C.GtkPrintSettings // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(key))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_print_settings_unset(_arg0, _arg1)
}
	


	// ProgressBar: the ProgressBar is typically used to display the progress of a
// long running operation. It provides a visual clue that processing is
// underway. The GtkProgressBar can be used in two different modes: percentage
// mode and activity mode.
// 
// When an application can determine how much work needs to take place (e.g.
// read a fixed number of bytes from a file) and can monitor its progress, it
// can use the GtkProgressBar in percentage mode and the user sees a growing bar
// indicating the percentage of the work that has been completed. In this mode,
// the application is required to call gtk_progress_bar_set_fraction()
// periodically to update the progress bar.
// 
// When an application has no accurate way of knowing the amount of work to do,
// it can use the ProgressBar in activity mode, which shows activity by a block
// moving back and forth within the progress area. In this mode, the application
// is required to call gtk_progress_bar_pulse() periodically to update the
// progress bar.
// 
// There is quite a bit of flexibility provided to control the appearance of the
// ProgressBar. Functions are provided to control the orientation of the bar,
// optional text can be displayed along with the bar, and the step size used in
// activity mode can be set.
// 
// CSS nodes
// 
//    progressbar[.osd]
//    ├── [text]
//    ╰── trough[.empty][.full]
//        ╰── progress[.pulse]
// 
// GtkProgressBar has a main CSS node with name progressbar and subnodes with
// names text and trough, of which the latter has a subnode named progress. The
// text subnode is only present if text is shown. The progress subnode has the
// style class .pulse when in activity mode. It gets the style classes .left,
// .right, .top or .bottom added when the progress 'touches' the corresponding
// end of the GtkProgressBar. The .osd class on the progressbar node is for use
// in overlays like the one Epiphany has for page loading progress.
	type ProgressBar struct {
		Widget
		Buildable
		Orientable
		
	}

	// ProgressBarClass is an interface that the ProgressBar class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ProgressBarClass interface {
		gextras.Objector
		_progressBar()
	}

	func (ProgressBar) _progressBar() {}

	
	func marshalProgressBar(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapProgressBar(obj), nil
	}
	

	
	// NewProgressBar creates a new ProgressBar.
	func NewProgressBar() ProgressBar {
var _cret *C.GtkWidget // in

_cret = C.gtk_progress_bar_new()


var _progressBar ProgressBar // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_progressBar = ProgressBar{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _progressBar
}
	

	
	// Ellipsize returns the ellipsizing position of the progress bar. See
// gtk_progress_bar_set_ellipsize().
	func (p ProgressBar) Ellipsize() pango.EllipsizeMode {
var _arg0 *C.GtkProgressBar // out
var _cret C.PangoEllipsizeMode // in

_arg0 = (*C.GtkProgressBar)(unsafe.Pointer(p.Native()))

_cret = C.gtk_progress_bar_get_ellipsize(_arg0)


var _ellipsizeMode pango.EllipsizeMode // out

_ellipsizeMode = pango.EllipsizeMode(_cret)

return _ellipsizeMode
}
	
	// Fraction returns the current fraction of the task that’s been completed.
	func (p ProgressBar) Fraction() float64 {
var _arg0 *C.GtkProgressBar // out
var _cret C.gdouble // in

_arg0 = (*C.GtkProgressBar)(unsafe.Pointer(p.Native()))

_cret = C.gtk_progress_bar_get_fraction(_arg0)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// Inverted gets the value set by gtk_progress_bar_set_inverted().
	func (p ProgressBar) Inverted() bool {
var _arg0 *C.GtkProgressBar // out
var _cret C.gboolean // in

_arg0 = (*C.GtkProgressBar)(unsafe.Pointer(p.Native()))

_cret = C.gtk_progress_bar_get_inverted(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// PulseStep retrieves the pulse step set with
// gtk_progress_bar_set_pulse_step().
	func (p ProgressBar) PulseStep() float64 {
var _arg0 *C.GtkProgressBar // out
var _cret C.gdouble // in

_arg0 = (*C.GtkProgressBar)(unsafe.Pointer(p.Native()))

_cret = C.gtk_progress_bar_get_pulse_step(_arg0)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// ShowText gets the value of the ProgressBar:show-text property. See
// gtk_progress_bar_set_show_text().
	func (p ProgressBar) ShowText() bool {
var _arg0 *C.GtkProgressBar // out
var _cret C.gboolean // in

_arg0 = (*C.GtkProgressBar)(unsafe.Pointer(p.Native()))

_cret = C.gtk_progress_bar_get_show_text(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Text retrieves the text that is displayed with the progress bar, if any,
// otherwise nil. The return value is a reference to the text, not a copy of it,
// so will become invalid if you change the text in the progress bar.
	func (p ProgressBar) Text() string {
var _arg0 *C.GtkProgressBar // out
var _cret *C.gchar // in

_arg0 = (*C.GtkProgressBar)(unsafe.Pointer(p.Native()))

_cret = C.gtk_progress_bar_get_text(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Pulse indicates that some progress has been made, but you don’t know how
// much. Causes the progress bar to enter “activity mode,” where a block bounces
// back and forth. Each call to gtk_progress_bar_pulse() causes the block to
// move by a little bit (the amount of movement per pulse is determined by
// gtk_progress_bar_set_pulse_step()).
	func (p ProgressBar) Pulse()  {
var _arg0 *C.GtkProgressBar // out

_arg0 = (*C.GtkProgressBar)(unsafe.Pointer(p.Native()))

C.gtk_progress_bar_pulse(_arg0)
}
	
	// SetEllipsize sets the mode used to ellipsize (add an ellipsis: "...") the
// text if there is not enough space to render the entire string.
	func (p ProgressBar) SetEllipsize(mode pango.EllipsizeMode)  {
var _arg0 *C.GtkProgressBar // out
var _arg1 C.PangoEllipsizeMode // out

_arg0 = (*C.GtkProgressBar)(unsafe.Pointer(p.Native()))
_arg1 = (C.PangoEllipsizeMode)(mode)

C.gtk_progress_bar_set_ellipsize(_arg0, _arg1)
}
	
	// SetFraction causes the progress bar to “fill in” the given fraction of the
// bar. The fraction should be between 0.0 and 1.0, inclusive.
	func (p ProgressBar) SetFraction(fraction float64)  {
var _arg0 *C.GtkProgressBar // out
var _arg1 C.gdouble // out

_arg0 = (*C.GtkProgressBar)(unsafe.Pointer(p.Native()))
_arg1 = (C.gdouble)(fraction)

C.gtk_progress_bar_set_fraction(_arg0, _arg1)
}
	
	// SetInverted progress bars normally grow from top to bottom or left to right.
// Inverted progress bars grow in the opposite direction.
	func (p ProgressBar) SetInverted(inverted bool)  {
var _arg0 *C.GtkProgressBar // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkProgressBar)(unsafe.Pointer(p.Native()))
if inverted { _arg1 = C.TRUE }

C.gtk_progress_bar_set_inverted(_arg0, _arg1)
}
	
	// SetPulseStep sets the fraction of total progress bar length to move the
// bouncing block for each call to gtk_progress_bar_pulse().
	func (p ProgressBar) SetPulseStep(fraction float64)  {
var _arg0 *C.GtkProgressBar // out
var _arg1 C.gdouble // out

_arg0 = (*C.GtkProgressBar)(unsafe.Pointer(p.Native()))
_arg1 = (C.gdouble)(fraction)

C.gtk_progress_bar_set_pulse_step(_arg0, _arg1)
}
	
	// SetShowText sets whether the progress bar will show text next to the bar. The
// shown text is either the value of the ProgressBar:text property or, if that
// is nil, the ProgressBar:fraction value, as a percentage.
// 
// To make a progress bar that is styled and sized suitably for containing text
// (even if the actual text is blank), set ProgressBar:show-text to true and
// ProgressBar:text to the empty string (not nil).
	func (p ProgressBar) SetShowText(showText bool)  {
var _arg0 *C.GtkProgressBar // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkProgressBar)(unsafe.Pointer(p.Native()))
if showText { _arg1 = C.TRUE }

C.gtk_progress_bar_set_show_text(_arg0, _arg1)
}
	
	// SetText causes the given @text to appear next to the progress bar.
// 
// If @text is nil and ProgressBar:show-text is true, the current value of
// ProgressBar:fraction will be displayed as a percentage.
// 
// If @text is non-nil and ProgressBar:show-text is true, the text will be
// displayed. In this case, it will not display the progress percentage. If
// @text is the empty string, the progress bar will still be styled and sized
// suitably for containing text, as long as ProgressBar:show-text is true.
	func (p ProgressBar) SetText(text string)  {
var _arg0 *C.GtkProgressBar // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkProgressBar)(unsafe.Pointer(p.Native()))
_arg1 = (*C.gchar)(C.CString(text))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_progress_bar_set_text(_arg0, _arg1)
}
	


	// RadioAction: a RadioAction is similar to RadioMenuItem. A number of radio
// actions can be linked together so that only one may be active at any one
// time.
	type RadioAction struct {
		ToggleAction
		Buildable
		
	}

	// RadioActionClass is an interface that the RadioAction class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type RadioActionClass interface {
		gextras.Objector
		_radioAction()
	}

	func (RadioAction) _radioAction() {}

	
	func marshalRadioAction(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapRadioAction(obj), nil
	}
	

	
	// NewRadioAction creates a new RadioAction object. To add the action to a
// ActionGroup and set the accelerator for the action, call
// gtk_action_group_add_action_with_accel().
	func NewRadioAction(name string, label string, tooltip string, stockId string, value int) RadioAction {
var _arg1 *C.gchar // out
var _arg2 *C.gchar // out
var _arg3 *C.gchar // out
var _arg4 *C.gchar // out
var _arg5 C.gint // out
var _cret *C.GtkRadioAction // in

_arg1 = (*C.gchar)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.gchar)(C.CString(label))
defer C.free(unsafe.Pointer(_arg2))
_arg3 = (*C.gchar)(C.CString(tooltip))
defer C.free(unsafe.Pointer(_arg3))
_arg4 = (*C.gchar)(C.CString(stockId))
defer C.free(unsafe.Pointer(_arg4))
_arg5 = (C.gint)(value)

_cret = C.gtk_radio_action_new(_arg1, _arg2, _arg3, _arg4, _arg5)


var _radioAction RadioAction // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_radioAction = RadioAction{
ToggleAction: ToggleAction{
Action: Action{
Object: &externglib.Object{externglib.ToGObject(obj)},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _radioAction
}
	

	
	// CurrentValue obtains the value property of the currently active member of the
// group to which @action belongs.
	func (a RadioAction) CurrentValue() int {
var _arg0 *C.GtkRadioAction // out
var _cret C.gint // in

_arg0 = (*C.GtkRadioAction)(unsafe.Pointer(a.Native()))

_cret = C.gtk_radio_action_get_current_value(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// JoinGroup joins a radio action object to the group of another radio action
// object.
// 
// Use this in language bindings instead of the gtk_radio_action_get_group() and
// gtk_radio_action_set_group() methods
// 
// A common way to set up a group of radio actions is the following:
// 
//     GtkRadioAction *action;
//     GtkRadioAction *last_action;
// 
//     while ( ...more actions to add... /)
//       {
//          action = gtk_radio_action_new (...);
//          
//          gtk_radio_action_join_group (action, last_action);
//          last_action = action;
//       }
	func (a RadioAction) JoinGroup(groupSource RadioActionClass)  {
var _arg0 *C.GtkRadioAction // out
var _arg1 *C.GtkRadioAction // out

_arg0 = (*C.GtkRadioAction)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkRadioAction)(unsafe.Pointer(groupSource.Native()))

C.gtk_radio_action_join_group(_arg0, _arg1)
}
	
	// SetCurrentValue sets the currently active group member to the member with
// value property @current_value.
	func (a RadioAction) SetCurrentValue(currentValue int)  {
var _arg0 *C.GtkRadioAction // out
var _arg1 C.gint // out

_arg0 = (*C.GtkRadioAction)(unsafe.Pointer(a.Native()))
_arg1 = (C.gint)(currentValue)

C.gtk_radio_action_set_current_value(_arg0, _arg1)
}
	


	// RadioButton: a single radio button performs the same basic function as a
// CheckButton, as its position in the object hierarchy reflects. It is only
// when multiple radio buttons are grouped together that they become a different
// user interface component in their own right.
// 
// Every radio button is a member of some group of radio buttons. When one is
// selected, all other radio buttons in the same group are deselected. A
// RadioButton is one way of giving the user a choice from many options.
// 
// Radio button widgets are created with gtk_radio_button_new(), passing nil as
// the argument if this is the first radio button in a group. In subsequent
// calls, the group you wish to add this button to should be passed as an
// argument. Optionally, gtk_radio_button_new_with_label() can be used if you
// want a text label on the radio button.
// 
// Alternatively, when adding widgets to an existing group of radio buttons, use
// gtk_radio_button_new_from_widget() with a RadioButton that already has a
// group assigned to it. The convenience function
// gtk_radio_button_new_with_label_from_widget() is also provided.
// 
// To retrieve the group a RadioButton is assigned to, use
// gtk_radio_button_get_group().
// 
// To remove a RadioButton from one group and make it part of a new one, use
// gtk_radio_button_set_group().
// 
// The group list does not need to be freed, as each RadioButton will remove
// itself and its list item when it is destroyed.
// 
// CSS nodes
// 
//    void create_radio_buttons (void) {
// 
//       GtkWidget *window, *radio1, *radio2, *box, *entry;
//       window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
//       box = gtk_box_new (GTK_ORIENTATION_VERTICAL, 2);
//       gtk_box_set_homogeneous (GTK_BOX (box), TRUE);
// 
//       // Create a radio button with a GtkEntry widget
//       radio1 = gtk_radio_button_new (NULL);
//       entry = gtk_entry_new ();
//       gtk_container_add (GTK_CONTAINER (radio1), entry);
// 
// 
//       // Create a radio button with a label
//       radio2 = gtk_radio_button_new_with_label_from_widget (GTK_RADIO_BUTTON (radio1),
//                                                             "I’m the second radio button.");
// 
//       // Pack them into a box, then show all the widgets
//       gtk_box_pack_start (GTK_BOX (box), radio1);
//       gtk_box_pack_start (GTK_BOX (box), radio2);
//       gtk_container_add (GTK_CONTAINER (window), box);
//       gtk_widget_show_all (window);
//       return;
//    }
// 
// When an unselected button in the group is clicked the clicked button receives
// the ToggleButton::toggled signal, as does the previously selected button.
// Inside the ToggleButton::toggled handler, gtk_toggle_button_get_active() can
// be used to determine if the button has been selected or deselected.
	type RadioButton struct {
		CheckButton
		Actionable
		Activatable
		Buildable
		
	}

	// RadioButtonClass is an interface that the RadioButton class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type RadioButtonClass interface {
		gextras.Objector
		_radioButton()
	}

	func (RadioButton) _radioButton() {}

	
	func marshalRadioButton(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapRadioButton(obj), nil
	}
	

	
	// NewRadioButtonFromWidget creates a new RadioButton, adding it to the same
// group as @radio_group_member. As with gtk_radio_button_new(), a widget should
// be packed into the radio button.
	func NewRadioButtonFromWidget(radioGroupMember RadioButtonClass) RadioButton {
var _arg1 *C.GtkRadioButton // out
var _cret *C.GtkWidget // in

_arg1 = (*C.GtkRadioButton)(unsafe.Pointer(radioGroupMember.Native()))

_cret = C.gtk_radio_button_new_from_widget(_arg1)


var _radioButton RadioButton // out

_radioButton = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(RadioButton)

return _radioButton
}
	
	// NewRadioButtonWithLabelFromWidget creates a new RadioButton with a text
// label, adding it to the same group as @radio_group_member.
	func NewRadioButtonWithLabelFromWidget(radioGroupMember RadioButtonClass, label string) RadioButton {
var _arg1 *C.GtkRadioButton // out
var _arg2 *C.gchar // out
var _cret *C.GtkWidget // in

_arg1 = (*C.GtkRadioButton)(unsafe.Pointer(radioGroupMember.Native()))
_arg2 = (*C.gchar)(C.CString(label))
defer C.free(unsafe.Pointer(_arg2))

_cret = C.gtk_radio_button_new_with_label_from_widget(_arg1, _arg2)


var _radioButton RadioButton // out

_radioButton = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(RadioButton)

return _radioButton
}
	
	// NewRadioButtonWithMnemonicFromWidget creates a new RadioButton containing a
// label. The label will be created using gtk_label_new_with_mnemonic(), so
// underscores in @label indicate the mnemonic for the button.
	func NewRadioButtonWithMnemonicFromWidget(radioGroupMember RadioButtonClass, label string) RadioButton {
var _arg1 *C.GtkRadioButton // out
var _arg2 *C.gchar // out
var _cret *C.GtkWidget // in

_arg1 = (*C.GtkRadioButton)(unsafe.Pointer(radioGroupMember.Native()))
_arg2 = (*C.gchar)(C.CString(label))
defer C.free(unsafe.Pointer(_arg2))

_cret = C.gtk_radio_button_new_with_mnemonic_from_widget(_arg1, _arg2)


var _radioButton RadioButton // out

_radioButton = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(RadioButton)

return _radioButton
}
	

	
	// JoinGroup joins a RadioButton object to the group of another RadioButton
// object
// 
// Use this in language bindings instead of the gtk_radio_button_get_group() and
// gtk_radio_button_set_group() methods
// 
// A common way to set up a group of radio buttons is the following:
// 
//      GtkRadioButton *radio_button;
//      GtkRadioButton *last_button;
// 
//      while (some_condition)
//        {
//           radio_button = gtk_radio_button_new (NULL);
// 
//           gtk_radio_button_join_group (radio_button, last_button);
//           last_button = radio_button;
//        }
	func (r RadioButton) JoinGroup(groupSource RadioButtonClass)  {
var _arg0 *C.GtkRadioButton // out
var _arg1 *C.GtkRadioButton // out

_arg0 = (*C.GtkRadioButton)(unsafe.Pointer(r.Native()))
_arg1 = (*C.GtkRadioButton)(unsafe.Pointer(groupSource.Native()))

C.gtk_radio_button_join_group(_arg0, _arg1)
}
	


	// RadioMenuItem: a radio menu item is a check menu item that belongs to a
// group. At each instant exactly one of the radio menu items from a group is
// selected.
// 
// The group list does not need to be freed, as each RadioMenuItem will remove
// itself and its list item when it is destroyed.
// 
// The correct way to create a group of radio menu items is approximatively
// this:
// 
// How to create a group of radio menu items.
// 
//    menuitem
//    ├── radio.left
//    ╰── <child>
// 
// GtkRadioMenuItem has a main CSS node with name menuitem, and a subnode with
// name radio, which gets the .left or .right style class.
	type RadioMenuItem struct {
		CheckMenuItem
		Actionable
		Activatable
		Buildable
		
	}

	// RadioMenuItemClass is an interface that the RadioMenuItem class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type RadioMenuItemClass interface {
		gextras.Objector
		_radioMenuItem()
	}

	func (RadioMenuItem) _radioMenuItem() {}

	
	func marshalRadioMenuItem(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapRadioMenuItem(obj), nil
	}
	

	
	// NewRadioMenuItemFromWidget creates a new RadioMenuItem adding it to the same
// group as @group.
	func NewRadioMenuItemFromWidget(group RadioMenuItemClass) RadioMenuItem {
var _arg1 *C.GtkRadioMenuItem // out
var _cret *C.GtkWidget // in

_arg1 = (*C.GtkRadioMenuItem)(unsafe.Pointer(group.Native()))

_cret = C.gtk_radio_menu_item_new_from_widget(_arg1)


var _radioMenuItem RadioMenuItem // out

_radioMenuItem = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(RadioMenuItem)

return _radioMenuItem
}
	
	// NewRadioMenuItemWithLabelFromWidget creates a new GtkRadioMenuItem whose
// child is a simple GtkLabel. The new RadioMenuItem is added to the same group
// as @group.
	func NewRadioMenuItemWithLabelFromWidget(group RadioMenuItemClass, label string) RadioMenuItem {
var _arg1 *C.GtkRadioMenuItem // out
var _arg2 *C.gchar // out
var _cret *C.GtkWidget // in

_arg1 = (*C.GtkRadioMenuItem)(unsafe.Pointer(group.Native()))
_arg2 = (*C.gchar)(C.CString(label))
defer C.free(unsafe.Pointer(_arg2))

_cret = C.gtk_radio_menu_item_new_with_label_from_widget(_arg1, _arg2)


var _radioMenuItem RadioMenuItem // out

_radioMenuItem = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(RadioMenuItem)

return _radioMenuItem
}
	
	// NewRadioMenuItemWithMnemonicFromWidget creates a new GtkRadioMenuItem
// containing a label. The label will be created using
// gtk_label_new_with_mnemonic(), so underscores in label indicate the mnemonic
// for the menu item.
// 
// The new RadioMenuItem is added to the same group as @group.
	func NewRadioMenuItemWithMnemonicFromWidget(group RadioMenuItemClass, label string) RadioMenuItem {
var _arg1 *C.GtkRadioMenuItem // out
var _arg2 *C.gchar // out
var _cret *C.GtkWidget // in

_arg1 = (*C.GtkRadioMenuItem)(unsafe.Pointer(group.Native()))
_arg2 = (*C.gchar)(C.CString(label))
defer C.free(unsafe.Pointer(_arg2))

_cret = C.gtk_radio_menu_item_new_with_mnemonic_from_widget(_arg1, _arg2)


var _radioMenuItem RadioMenuItem // out

_radioMenuItem = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(RadioMenuItem)

return _radioMenuItem
}
	

	
	// JoinGroup joins a RadioMenuItem object to the group of another RadioMenuItem
// object.
// 
// This function should be used by language bindings to avoid the memory
// manangement of the opaque List of gtk_radio_menu_item_get_group() and
// gtk_radio_menu_item_set_group().
// 
// A common way to set up a group of RadioMenuItem instances is:
// 
//      GtkRadioMenuItem *last_item = NULL;
// 
//      while ( ...more items to add... )
//        {
//          GtkRadioMenuItem *radio_item;
// 
//          radio_item = gtk_radio_menu_item_new (...);
// 
//          gtk_radio_menu_item_join_group (radio_item, last_item);
//          last_item = radio_item;
//        }
	func (r RadioMenuItem) JoinGroup(groupSource RadioMenuItemClass)  {
var _arg0 *C.GtkRadioMenuItem // out
var _arg1 *C.GtkRadioMenuItem // out

_arg0 = (*C.GtkRadioMenuItem)(unsafe.Pointer(r.Native()))
_arg1 = (*C.GtkRadioMenuItem)(unsafe.Pointer(groupSource.Native()))

C.gtk_radio_menu_item_join_group(_arg0, _arg1)
}
	


	// RadioToolButton: a RadioToolButton is a ToolItem that contains a radio
// button, that is, a button that is part of a group of toggle buttons where
// only one button can be active at a time.
// 
// Use gtk_radio_tool_button_new() to create a new GtkRadioToolButton. Use
// gtk_radio_tool_button_new_from_widget() to create a new GtkRadioToolButton
// that is part of the same group as an existing GtkRadioToolButton.
// 
// 
// CSS nodes
// 
// GtkRadioToolButton has a single CSS node with name toolbutton.
	type RadioToolButton struct {
		ToggleToolButton
		Actionable
		Activatable
		Buildable
		
	}

	// RadioToolButtonClass is an interface that the RadioToolButton class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type RadioToolButtonClass interface {
		gextras.Objector
		_radioToolButton()
	}

	func (RadioToolButton) _radioToolButton() {}

	
	func marshalRadioToolButton(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapRadioToolButton(obj), nil
	}
	

	
	// NewRadioToolButtonFromWidget creates a new RadioToolButton adding it to the
// same group as @gruup
	func NewRadioToolButtonFromWidget(group RadioToolButtonClass) RadioToolButton {
var _arg1 *C.GtkRadioToolButton // out
var _cret *C.GtkToolItem // in

_arg1 = (*C.GtkRadioToolButton)(unsafe.Pointer(group.Native()))

_cret = C.gtk_radio_tool_button_new_from_widget(_arg1)


var _radioToolButton RadioToolButton // out

_radioToolButton = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(RadioToolButton)

return _radioToolButton
}
	
	// NewRadioToolButtonWithStockFromWidget creates a new RadioToolButton adding it
// to the same group as @group. The new RadioToolButton will contain an icon and
// label from the stock item indicated by @stock_id.
	func NewRadioToolButtonWithStockFromWidget(group RadioToolButtonClass, stockId string) RadioToolButton {
var _arg1 *C.GtkRadioToolButton // out
var _arg2 *C.gchar // out
var _cret *C.GtkToolItem // in

_arg1 = (*C.GtkRadioToolButton)(unsafe.Pointer(group.Native()))
_arg2 = (*C.gchar)(C.CString(stockId))
defer C.free(unsafe.Pointer(_arg2))

_cret = C.gtk_radio_tool_button_new_with_stock_from_widget(_arg1, _arg2)


var _radioToolButton RadioToolButton // out

_radioToolButton = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(RadioToolButton)

return _radioToolButton
}
	

	


	// Range is the common base class for widgets which visualize an adjustment, e.g
// Scale or Scrollbar.
// 
// Apart from signals for monitoring the parameters of the adjustment, Range
// provides properties and methods for influencing the sensitivity of the
// “steppers”. It also provides properties and methods for setting a “fill
// level” on range widgets. See gtk_range_set_fill_level().
	type Range struct {
		Widget
		Buildable
		Orientable
		
	}

	// RangeClass is an interface that the Range class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type RangeClass interface {
		gextras.Objector
		__range()
	}

	func (Range) __range() {}

	
	func marshalRange(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapRange(obj), nil
	}
	

	

	
	// Adjustment: get the Adjustment which is the “model” object for Range. See
// gtk_range_set_adjustment() for details. The return value does not have a
// reference added, so should not be unreferenced.
	func (r Range) Adjustment() Adjustment {
var _arg0 *C.GtkRange // out
var _cret *C.GtkAdjustment // in

_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))

_cret = C.gtk_range_get_adjustment(_arg0)


var _adjustment Adjustment // out

_adjustment = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Adjustment)

return _adjustment
}
	
	// FillLevel gets the current position of the fill level indicator.
	func (r Range) FillLevel() float64 {
var _arg0 *C.GtkRange // out
var _cret C.gdouble // in

_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))

_cret = C.gtk_range_get_fill_level(_arg0)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// Flippable gets the value set by gtk_range_set_flippable().
	func (r Range) Flippable() bool {
var _arg0 *C.GtkRange // out
var _cret C.gboolean // in

_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))

_cret = C.gtk_range_get_flippable(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Inverted gets the value set by gtk_range_set_inverted().
	func (r Range) Inverted() bool {
var _arg0 *C.GtkRange // out
var _cret C.gboolean // in

_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))

_cret = C.gtk_range_get_inverted(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// LowerStepperSensitivity gets the sensitivity policy for the stepper that
// points to the 'lower' end of the GtkRange’s adjustment.
	func (r Range) LowerStepperSensitivity() SensitivityType {
var _arg0 *C.GtkRange // out
var _cret C.GtkSensitivityType // in

_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))

_cret = C.gtk_range_get_lower_stepper_sensitivity(_arg0)


var _sensitivityType SensitivityType // out

_sensitivityType = SensitivityType(_cret)

return _sensitivityType
}
	
	// MinSliderSize: this function is useful mainly for Range subclasses.
// 
// See gtk_range_set_min_slider_size().
	func (r Range) MinSliderSize() int {
var _arg0 *C.GtkRange // out
var _cret C.gint // in

_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))

_cret = C.gtk_range_get_min_slider_size(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// RangeRect: this function returns the area that contains the range’s trough
// and its steppers, in widget->window coordinates.
// 
// This function is useful mainly for Range subclasses.
	func (r Range) RangeRect() gdk.Rectangle {
var _arg0 *C.GtkRange // out
var _rangeRect gdk.Rectangle

_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))

C.gtk_range_get_range_rect(_arg0, (*C.GdkRectangle)(unsafe.Pointer(&_rangeRect)))





return _rangeRect
}
	
	// RestrictToFillLevel gets whether the range is restricted to the fill level.
	func (r Range) RestrictToFillLevel() bool {
var _arg0 *C.GtkRange // out
var _cret C.gboolean // in

_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))

_cret = C.gtk_range_get_restrict_to_fill_level(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// RoundDigits gets the number of digits to round the value to when it changes.
// See Range::change-value.
	func (r Range) RoundDigits() int {
var _arg0 *C.GtkRange // out
var _cret C.gint // in

_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))

_cret = C.gtk_range_get_round_digits(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// ShowFillLevel gets whether the range displays the fill level graphically.
	func (r Range) ShowFillLevel() bool {
var _arg0 *C.GtkRange // out
var _cret C.gboolean // in

_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))

_cret = C.gtk_range_get_show_fill_level(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SliderRange: this function returns sliders range along the long dimension, in
// widget->window coordinates.
// 
// This function is useful mainly for Range subclasses.
	func (r Range) SliderRange() (sliderStart int, sliderEnd int) {
var _arg0 *C.GtkRange // out
var _arg1 C.gint // in
var _arg2 C.gint // in

_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))

C.gtk_range_get_slider_range(_arg0, &_arg1, &_arg2)

var _sliderStart int // out
var _sliderEnd int // out

_sliderStart = (int)(_arg1)
_sliderEnd = (int)(_arg2)

return _sliderStart, _sliderEnd
}
	
	// SliderSizeFixed: this function is useful mainly for Range subclasses.
// 
// See gtk_range_set_slider_size_fixed().
	func (r Range) SliderSizeFixed() bool {
var _arg0 *C.GtkRange // out
var _cret C.gboolean // in

_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))

_cret = C.gtk_range_get_slider_size_fixed(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// UpperStepperSensitivity gets the sensitivity policy for the stepper that
// points to the 'upper' end of the GtkRange’s adjustment.
	func (r Range) UpperStepperSensitivity() SensitivityType {
var _arg0 *C.GtkRange // out
var _cret C.GtkSensitivityType // in

_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))

_cret = C.gtk_range_get_upper_stepper_sensitivity(_arg0)


var _sensitivityType SensitivityType // out

_sensitivityType = SensitivityType(_cret)

return _sensitivityType
}
	
	// Value gets the current value of the range.
	func (r Range) Value() float64 {
var _arg0 *C.GtkRange // out
var _cret C.gdouble // in

_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))

_cret = C.gtk_range_get_value(_arg0)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// SetAdjustment sets the adjustment to be used as the “model” object for this
// range widget. The adjustment indicates the current range value, the minimum
// and maximum range values, the step/page increments used for keybindings and
// scrolling, and the page size. The page size is normally 0 for Scale and
// nonzero for Scrollbar, and indicates the size of the visible area of the
// widget being scrolled. The page size affects the size of the scrollbar
// slider.
	func (r Range) SetAdjustment(adjustment AdjustmentClass)  {
var _arg0 *C.GtkRange // out
var _arg1 *C.GtkAdjustment // out

_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))
_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(adjustment.Native()))

C.gtk_range_set_adjustment(_arg0, _arg1)
}
	
	// SetFillLevel: set the new position of the fill level indicator.
// 
// The “fill level” is probably best described by its most prominent use case,
// which is an indicator for the amount of pre-buffering in a streaming media
// player. In that use case, the value of the range would indicate the current
// play position, and the fill level would be the position up to which the
// file/stream has been downloaded.
// 
// This amount of prebuffering can be displayed on the range’s trough and is
// themeable separately from the trough. To enable fill level display, use
// gtk_range_set_show_fill_level(). The range defaults to not showing the fill
// level.
// 
// Additionally, it’s possible to restrict the range’s slider position to values
// which are smaller than the fill level. This is controller by
// gtk_range_set_restrict_to_fill_level() and is by default enabled.
	func (r Range) SetFillLevel(fillLevel float64)  {
var _arg0 *C.GtkRange // out
var _arg1 C.gdouble // out

_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))
_arg1 = (C.gdouble)(fillLevel)

C.gtk_range_set_fill_level(_arg0, _arg1)
}
	
	// SetFlippable: if a range is flippable, it will switch its direction if it is
// horizontal and its direction is GTK_TEXT_DIR_RTL.
// 
// See gtk_widget_get_direction().
	func (r Range) SetFlippable(flippable bool)  {
var _arg0 *C.GtkRange // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))
if flippable { _arg1 = C.TRUE }

C.gtk_range_set_flippable(_arg0, _arg1)
}
	
	// SetIncrements sets the step and page sizes for the range. The step size is
// used when the user clicks the Scrollbar arrows or moves Scale via arrow keys.
// The page size is used for example when moving via Page Up or Page Down keys.
	func (r Range) SetIncrements(step float64, page float64)  {
var _arg0 *C.GtkRange // out
var _arg1 C.gdouble // out
var _arg2 C.gdouble // out

_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))
_arg1 = (C.gdouble)(step)
_arg2 = (C.gdouble)(page)

C.gtk_range_set_increments(_arg0, _arg1, _arg2)
}
	
	// SetInverted ranges normally move from lower to higher values as the slider
// moves from top to bottom or left to right. Inverted ranges have higher values
// at the top or on the right rather than on the bottom or left.
	func (r Range) SetInverted(setting bool)  {
var _arg0 *C.GtkRange // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))
if setting { _arg1 = C.TRUE }

C.gtk_range_set_inverted(_arg0, _arg1)
}
	
	// SetLowerStepperSensitivity sets the sensitivity policy for the stepper that
// points to the 'lower' end of the GtkRange’s adjustment.
	func (r Range) SetLowerStepperSensitivity(sensitivity SensitivityType)  {
var _arg0 *C.GtkRange // out
var _arg1 C.GtkSensitivityType // out

_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))
_arg1 = (C.GtkSensitivityType)(sensitivity)

C.gtk_range_set_lower_stepper_sensitivity(_arg0, _arg1)
}
	
	// SetMinSliderSize sets the minimum size of the range’s slider.
// 
// This function is useful mainly for Range subclasses.
	func (r Range) SetMinSliderSize(minSize int)  {
var _arg0 *C.GtkRange // out
var _arg1 C.gint // out

_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))
_arg1 = (C.gint)(minSize)

C.gtk_range_set_min_slider_size(_arg0, _arg1)
}
	
	// SetRange sets the allowable values in the Range, and clamps the range value
// to be between @min and @max. (If the range has a non-zero page size, it is
// clamped between @min and @max - page-size.)
	func (r Range) SetRange(min float64, max float64)  {
var _arg0 *C.GtkRange // out
var _arg1 C.gdouble // out
var _arg2 C.gdouble // out

_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))
_arg1 = (C.gdouble)(min)
_arg2 = (C.gdouble)(max)

C.gtk_range_set_range(_arg0, _arg1, _arg2)
}
	
	// SetRestrictToFillLevel sets whether the slider is restricted to the fill
// level. See gtk_range_set_fill_level() for a general description of the fill
// level concept.
	func (r Range) SetRestrictToFillLevel(restrictToFillLevel bool)  {
var _arg0 *C.GtkRange // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))
if restrictToFillLevel { _arg1 = C.TRUE }

C.gtk_range_set_restrict_to_fill_level(_arg0, _arg1)
}
	
	// SetRoundDigits sets the number of digits to round the value to when it
// changes. See Range::change-value.
	func (r Range) SetRoundDigits(roundDigits int)  {
var _arg0 *C.GtkRange // out
var _arg1 C.gint // out

_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))
_arg1 = (C.gint)(roundDigits)

C.gtk_range_set_round_digits(_arg0, _arg1)
}
	
	// SetShowFillLevel sets whether a graphical fill level is show on the trough.
// See gtk_range_set_fill_level() for a general description of the fill level
// concept.
	func (r Range) SetShowFillLevel(showFillLevel bool)  {
var _arg0 *C.GtkRange // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))
if showFillLevel { _arg1 = C.TRUE }

C.gtk_range_set_show_fill_level(_arg0, _arg1)
}
	
	// SetSliderSizeFixed sets whether the range’s slider has a fixed size, or a
// size that depends on its adjustment’s page size.
// 
// This function is useful mainly for Range subclasses.
	func (r Range) SetSliderSizeFixed(sizeFixed bool)  {
var _arg0 *C.GtkRange // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))
if sizeFixed { _arg1 = C.TRUE }

C.gtk_range_set_slider_size_fixed(_arg0, _arg1)
}
	
	// SetUpperStepperSensitivity sets the sensitivity policy for the stepper that
// points to the 'upper' end of the GtkRange’s adjustment.
	func (r Range) SetUpperStepperSensitivity(sensitivity SensitivityType)  {
var _arg0 *C.GtkRange // out
var _arg1 C.GtkSensitivityType // out

_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))
_arg1 = (C.GtkSensitivityType)(sensitivity)

C.gtk_range_set_upper_stepper_sensitivity(_arg0, _arg1)
}
	
	// SetValue sets the current value of the range; if the value is outside the
// minimum or maximum range values, it will be clamped to fit inside them. The
// range emits the Range::value-changed signal if the value changes.
	func (r Range) SetValue(value float64)  {
var _arg0 *C.GtkRange // out
var _arg1 C.gdouble // out

_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))
_arg1 = (C.gdouble)(value)

C.gtk_range_set_value(_arg0, _arg1)
}
	


	// RCStyle: the RcStyle-struct is used to represent a set of information about
// the appearance of a widget. This can later be composited together with other
// RcStyle-struct<!-- -->s to form a Style.
	type RCStyle struct {
		**externglib.Object
		
	}

	// RCStyleClass is an interface that the RCStyle class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type RCStyleClass interface {
		gextras.Objector
		_rcStyle()
	}

	func (RCStyle) _rcStyle() {}

	
	func marshalRCStyle(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapRCStyle(obj), nil
	}
	

	
	// NewRCStyle creates a new RcStyle with no fields set and a reference count of
// 1.
	func NewRCStyle() RCStyle {
var _cret *C.GtkRcStyle // in

_cret = C.gtk_rc_style_new()


var _rcStyle RCStyle // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_rcStyle = RCStyle{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}

return _rcStyle
}
	

	
	// Copy makes a copy of the specified RcStyle. This function will correctly copy
// an RC style that is a member of a class derived from RcStyle.
	func (o RCStyle) Copy() RCStyle {
var _arg0 *C.GtkRcStyle // out
var _cret *C.GtkRcStyle // in

_arg0 = (*C.GtkRcStyle)(unsafe.Pointer(o.Native()))

_cret = C.gtk_rc_style_copy(_arg0)


var _rcStyle RCStyle // out

_rcStyle = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(RCStyle)

return _rcStyle
}
	


	// RecentAction: a RecentAction represents a list of recently used files, which
// can be shown by widgets such as RecentChooserDialog or RecentChooserMenu.
// 
// To construct a submenu showing recently used files, use a RecentAction as the
// action for a <menuitem>. To construct a menu toolbutton showing the recently
// used files in the popup menu, use a RecentAction as the action for a
// <toolitem> element.
	type RecentAction struct {
		Action
		Buildable
		RecentChooser
		
	}

	// RecentActionClass is an interface that the RecentAction class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type RecentActionClass interface {
		gextras.Objector
		_recentAction()
	}

	func (RecentAction) _recentAction() {}

	
	func marshalRecentAction(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapRecentAction(obj), nil
	}
	

	
	// NewRecentAction creates a new RecentAction object. To add the action to a
// ActionGroup and set the accelerator for the action, call
// gtk_action_group_add_action_with_accel().
	func NewRecentAction(name string, label string, tooltip string, stockId string) RecentAction {
var _arg1 *C.gchar // out
var _arg2 *C.gchar // out
var _arg3 *C.gchar // out
var _arg4 *C.gchar // out
var _cret *C.GtkAction // in

_arg1 = (*C.gchar)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.gchar)(C.CString(label))
defer C.free(unsafe.Pointer(_arg2))
_arg3 = (*C.gchar)(C.CString(tooltip))
defer C.free(unsafe.Pointer(_arg3))
_arg4 = (*C.gchar)(C.CString(stockId))
defer C.free(unsafe.Pointer(_arg4))

_cret = C.gtk_recent_action_new(_arg1, _arg2, _arg3, _arg4)


var _recentAction RecentAction // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_recentAction = RecentAction{
Action: Action{
Object: &externglib.Object{externglib.ToGObject(obj)},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
RecentChooser: RecentChooser{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _recentAction
}
	
	// NewRecentActionForManager creates a new RecentAction object. To add the
// action to a ActionGroup and set the accelerator for the action, call
// gtk_action_group_add_action_with_accel().
	func NewRecentActionForManager(name string, label string, tooltip string, stockId string, manager RecentManagerClass) RecentAction {
var _arg1 *C.gchar // out
var _arg2 *C.gchar // out
var _arg3 *C.gchar // out
var _arg4 *C.gchar // out
var _arg5 *C.GtkRecentManager // out
var _cret *C.GtkAction // in

_arg1 = (*C.gchar)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.gchar)(C.CString(label))
defer C.free(unsafe.Pointer(_arg2))
_arg3 = (*C.gchar)(C.CString(tooltip))
defer C.free(unsafe.Pointer(_arg3))
_arg4 = (*C.gchar)(C.CString(stockId))
defer C.free(unsafe.Pointer(_arg4))
_arg5 = (*C.GtkRecentManager)(unsafe.Pointer(manager.Native()))

_cret = C.gtk_recent_action_new_for_manager(_arg1, _arg2, _arg3, _arg4, _arg5)


var _recentAction RecentAction // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_recentAction = RecentAction{
Action: Action{
Object: &externglib.Object{externglib.ToGObject(obj)},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
RecentChooser: RecentChooser{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _recentAction
}
	

	
	// ShowNumbers returns the value set by
// gtk_recent_chooser_menu_set_show_numbers().
	func (a RecentAction) ShowNumbers() bool {
var _arg0 *C.GtkRecentAction // out
var _cret C.gboolean // in

_arg0 = (*C.GtkRecentAction)(unsafe.Pointer(a.Native()))

_cret = C.gtk_recent_action_get_show_numbers(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetShowNumbers sets whether a number should be added to the items shown by
// the widgets representing @action. The numbers are shown to provide a unique
// character for a mnemonic to be used inside the menu item's label. Only the
// first ten items get a number to avoid clashes.
	func (a RecentAction) SetShowNumbers(showNumbers bool)  {
var _arg0 *C.GtkRecentAction // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkRecentAction)(unsafe.Pointer(a.Native()))
if showNumbers { _arg1 = C.TRUE }

C.gtk_recent_action_set_show_numbers(_arg0, _arg1)
}
	


	// RecentChooserDialog is a dialog box suitable for displaying the recently used
// documents. This widgets works by putting a RecentChooserWidget inside a
// Dialog. It exposes the RecentChooserIface interface, so you can use all the
// RecentChooser functions on the recent chooser dialog as well as those for
// Dialog.
// 
// Note that RecentChooserDialog does not have any methods of its own. Instead,
// you should use the functions that work on a RecentChooser.
// 
// 
// Typical usage
// 
// In the simplest of cases, you can use the following code to use a
// RecentChooserDialog to select a recently used file:
// 
//    GtkWidget *dialog;
//    gint res;
// 
//    dialog = gtk_recent_chooser_dialog_new ("Recent Documents",
//                                            parent_window,
//                                            _("_Cancel"),
//                                            GTK_RESPONSE_CANCEL,
//                                            _("_Open"),
//                                            GTK_RESPONSE_ACCEPT,
//                                            NULL);
// 
//    res = gtk_dialog_run (GTK_DIALOG (dialog));
//    if (res == GTK_RESPONSE_ACCEPT)
//      {
//        GtkRecentInfo *info;
//        GtkRecentChooser *chooser = GTK_RECENT_CHOOSER (dialog);
// 
//        info = gtk_recent_chooser_get_current_item (chooser);
//        open_file (gtk_recent_info_get_uri (info));
//        gtk_recent_info_unref (info);
//      }
// 
//    gtk_widget_destroy (dialog);
// 
// Recently used files are supported since GTK+ 2.10.
	type RecentChooserDialog struct {
		Dialog
		Buildable
		RecentChooser
		
	}

	// RecentChooserDialogClass is an interface that the RecentChooserDialog class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type RecentChooserDialogClass interface {
		gextras.Objector
		_recentChooserDialog()
	}

	func (RecentChooserDialog) _recentChooserDialog() {}

	
	func marshalRecentChooserDialog(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapRecentChooserDialog(obj), nil
	}
	

	

	


	// RecentChooserMenu is a widget suitable for displaying recently used files
// inside a menu. It can be used to set a sub-menu of a MenuItem using
// gtk_menu_item_set_submenu(), or as the menu of a MenuToolButton.
// 
// Note that RecentChooserMenu does not have any methods of its own. Instead,
// you should use the functions that work on a RecentChooser.
// 
// Note also that RecentChooserMenu does not support multiple filters, as it has
// no way to let the user choose between them as the RecentChooserWidget and
// RecentChooserDialog widgets do. Thus using gtk_recent_chooser_add_filter() on
// a RecentChooserMenu widget will yield the same effects as using
// gtk_recent_chooser_set_filter(), replacing any currently set filter with the
// supplied filter; gtk_recent_chooser_remove_filter() will remove any currently
// set RecentFilter object and will unset the current filter;
// gtk_recent_chooser_list_filters() will return a list containing a single
// RecentFilter object.
// 
// Recently used files are supported since GTK+ 2.10.
	type RecentChooserMenu struct {
		Menu
		Activatable
		Buildable
		RecentChooser
		
	}

	// RecentChooserMenuClass is an interface that the RecentChooserMenu class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type RecentChooserMenuClass interface {
		gextras.Objector
		_recentChooserMenu()
	}

	func (RecentChooserMenu) _recentChooserMenu() {}

	
	func marshalRecentChooserMenu(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapRecentChooserMenu(obj), nil
	}
	

	
	// NewRecentChooserMenu creates a new RecentChooserMenu widget.
// 
// This kind of widget shows the list of recently used resources as a menu, each
// item as a menu item. Each item inside the menu might have an icon,
// representing its MIME type, and a number, for mnemonic access.
// 
// This widget implements the RecentChooser interface.
// 
// This widget creates its own RecentManager object. See the
// gtk_recent_chooser_menu_new_for_manager() function to know how to create a
// RecentChooserMenu widget bound to another RecentManager object.
	func NewRecentChooserMenu() RecentChooserMenu {
var _cret *C.GtkWidget // in

_cret = C.gtk_recent_chooser_menu_new()


var _recentChooserMenu RecentChooserMenu // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_recentChooserMenu = RecentChooserMenu{
Menu: Menu{
MenuShell: MenuShell{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
RecentChooser: RecentChooser{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _recentChooserMenu
}
	
	// NewRecentChooserMenuForManager creates a new RecentChooserMenu widget using
// @manager as the underlying recently used resources manager.
// 
// This is useful if you have implemented your own recent manager, or if you
// have a customized instance of a RecentManager object or if you wish to share
// a common RecentManager object among multiple RecentChooser widgets.
	func NewRecentChooserMenuForManager(manager RecentManagerClass) RecentChooserMenu {
var _arg1 *C.GtkRecentManager // out
var _cret *C.GtkWidget // in

_arg1 = (*C.GtkRecentManager)(unsafe.Pointer(manager.Native()))

_cret = C.gtk_recent_chooser_menu_new_for_manager(_arg1)


var _recentChooserMenu RecentChooserMenu // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_recentChooserMenu = RecentChooserMenu{
Menu: Menu{
MenuShell: MenuShell{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
RecentChooser: RecentChooser{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _recentChooserMenu
}
	

	
	// ShowNumbers returns the value set by
// gtk_recent_chooser_menu_set_show_numbers().
	func (m RecentChooserMenu) ShowNumbers() bool {
var _arg0 *C.GtkRecentChooserMenu // out
var _cret C.gboolean // in

_arg0 = (*C.GtkRecentChooserMenu)(unsafe.Pointer(m.Native()))

_cret = C.gtk_recent_chooser_menu_get_show_numbers(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetShowNumbers sets whether a number should be added to the items of @menu.
// The numbers are shown to provide a unique character for a mnemonic to be used
// inside ten menu item’s label. Only the first the items get a number to avoid
// clashes.
	func (m RecentChooserMenu) SetShowNumbers(showNumbers bool)  {
var _arg0 *C.GtkRecentChooserMenu // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkRecentChooserMenu)(unsafe.Pointer(m.Native()))
if showNumbers { _arg1 = C.TRUE }

C.gtk_recent_chooser_menu_set_show_numbers(_arg0, _arg1)
}
	


	// RecentChooserWidget is a widget suitable for selecting recently used files.
// It is the main building block of a RecentChooserDialog. Most applications
// will only need to use the latter; you can use RecentChooserWidget as part of
// a larger window if you have special needs.
// 
// Note that RecentChooserWidget does not have any methods of its own. Instead,
// you should use the functions that work on a RecentChooser.
// 
// Recently used files are supported since GTK+ 2.10.
	type RecentChooserWidget struct {
		Box
		Buildable
		Orientable
		RecentChooser
		
	}

	// RecentChooserWidgetClass is an interface that the RecentChooserWidget class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type RecentChooserWidgetClass interface {
		gextras.Objector
		_recentChooserWidget()
	}

	func (RecentChooserWidget) _recentChooserWidget() {}

	
	func marshalRecentChooserWidget(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapRecentChooserWidget(obj), nil
	}
	

	
	// NewRecentChooserWidget creates a new RecentChooserWidget object. This is an
// embeddable widget used to access the recently used resources list.
	func NewRecentChooserWidget() RecentChooserWidget {
var _cret *C.GtkWidget // in

_cret = C.gtk_recent_chooser_widget_new()


var _recentChooserWidget RecentChooserWidget // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_recentChooserWidget = RecentChooserWidget{
Box: Box{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
RecentChooser: RecentChooser{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _recentChooserWidget
}
	
	// NewRecentChooserWidgetForManager creates a new RecentChooserWidget with a
// specified recent manager.
// 
// This is useful if you have implemented your own recent manager, or if you
// have a customized instance of a RecentManager object.
	func NewRecentChooserWidgetForManager(manager RecentManagerClass) RecentChooserWidget {
var _arg1 *C.GtkRecentManager // out
var _cret *C.GtkWidget // in

_arg1 = (*C.GtkRecentManager)(unsafe.Pointer(manager.Native()))

_cret = C.gtk_recent_chooser_widget_new_for_manager(_arg1)


var _recentChooserWidget RecentChooserWidget // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_recentChooserWidget = RecentChooserWidget{
Box: Box{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
RecentChooser: RecentChooser{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _recentChooserWidget
}
	

	


	// RecentFilter: a RecentFilter can be used to restrict the files being shown in
// a RecentChooser. Files can be filtered based on their name (with
// gtk_recent_filter_add_pattern()), on their mime type (with
// gtk_file_filter_add_mime_type()), on the application that has registered them
// (with gtk_recent_filter_add_application()), or by a custom filter function
// (with gtk_recent_filter_add_custom()).
// 
// Filtering by mime type handles aliasing and subclassing of mime types; e.g. a
// filter for text/plain also matches a file with mime type application/rtf,
// since application/rtf is a subclass of text/plain. Note that RecentFilter
// allows wildcards for the subtype of a mime type, so you can e.g. filter for
// image/\*.
// 
// Normally, filters are used by adding them to a RecentChooser, see
// gtk_recent_chooser_add_filter(), but it is also possible to manually use a
// filter on a file with gtk_recent_filter_filter().
// 
// Recently used files are supported since GTK+ 2.10.
// 
// 
// GtkRecentFilter as GtkBuildable
// 
// The GtkRecentFilter implementation of the GtkBuildable interface supports
// adding rules using the <mime-types>, <patterns> and <applications> elements
// and listing the rules within. Specifying a <mime-type>, <pattern> or
// <application> has the same effect as calling
// gtk_recent_filter_add_mime_type(), gtk_recent_filter_add_pattern() or
// gtk_recent_filter_add_application().
// 
// An example of a UI definition fragment specifying GtkRecentFilter rules:
// 
//    <object class="GtkRecentFilter">
//      <mime-types>
//        <mime-type>text/plain</mime-type>
//        <mime-type>image/png</mime-type>
//      </mime-types>
//      <patterns>
//        <pattern>*.txt</pattern>
//        <pattern>*.png</pattern>
//      </patterns>
//      <applications>
//        <application>gimp</application>
//        <application>gedit</application>
//        <application>glade</application>
//      </applications>
//    </object>
	type RecentFilter struct {
		externglib.InitiallyUnowned
		Buildable
		
	}

	// RecentFilterClass is an interface that the RecentFilter class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type RecentFilterClass interface {
		gextras.Objector
		_recentFilter()
	}

	func (RecentFilter) _recentFilter() {}

	
	func marshalRecentFilter(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapRecentFilter(obj), nil
	}
	

	
	// NewRecentFilter creates a new RecentFilter with no rules added to it. Such
// filter does not accept any recently used resources, so is not particularly
// useful until you add rules with gtk_recent_filter_add_pattern(),
// gtk_recent_filter_add_mime_type(), gtk_recent_filter_add_application(),
// gtk_recent_filter_add_age(). To create a filter that accepts any recently
// used resource, use:
// 
//    GtkRecentFilter *filter = gtk_recent_filter_new ();
//    gtk_recent_filter_add_pattern (filter, "*");
	func NewRecentFilter() RecentFilter {
var _cret *C.GtkRecentFilter // in

_cret = C.gtk_recent_filter_new()


var _recentFilter RecentFilter // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_recentFilter = RecentFilter{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _recentFilter
}
	

	
	// AddAge adds a rule that allows resources based on their age - that is, the
// number of days elapsed since they were last modified.
	func (f RecentFilter) AddAge(days int)  {
var _arg0 *C.GtkRecentFilter // out
var _arg1 C.gint // out

_arg0 = (*C.GtkRecentFilter)(unsafe.Pointer(f.Native()))
_arg1 = (C.gint)(days)

C.gtk_recent_filter_add_age(_arg0, _arg1)
}
	
	// AddApplication adds a rule that allows resources based on the name of the
// application that has registered them.
	func (f RecentFilter) AddApplication(application string)  {
var _arg0 *C.GtkRecentFilter // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkRecentFilter)(unsafe.Pointer(f.Native()))
_arg1 = (*C.gchar)(C.CString(application))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_recent_filter_add_application(_arg0, _arg1)
}
	
	// AddGroup adds a rule that allows resources based on the name of the group to
// which they belong
	func (f RecentFilter) AddGroup(group string)  {
var _arg0 *C.GtkRecentFilter // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkRecentFilter)(unsafe.Pointer(f.Native()))
_arg1 = (*C.gchar)(C.CString(group))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_recent_filter_add_group(_arg0, _arg1)
}
	
	// AddMIMEType adds a rule that allows resources based on their registered MIME
// type.
	func (f RecentFilter) AddMIMEType(mimeType string)  {
var _arg0 *C.GtkRecentFilter // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkRecentFilter)(unsafe.Pointer(f.Native()))
_arg1 = (*C.gchar)(C.CString(mimeType))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_recent_filter_add_mime_type(_arg0, _arg1)
}
	
	// AddPattern adds a rule that allows resources based on a pattern matching
// their display name.
	func (f RecentFilter) AddPattern(pattern string)  {
var _arg0 *C.GtkRecentFilter // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkRecentFilter)(unsafe.Pointer(f.Native()))
_arg1 = (*C.gchar)(C.CString(pattern))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_recent_filter_add_pattern(_arg0, _arg1)
}
	
	// AddPixbufFormats adds a rule allowing image files in the formats supported by
// GdkPixbuf.
	func (f RecentFilter) AddPixbufFormats()  {
var _arg0 *C.GtkRecentFilter // out

_arg0 = (*C.GtkRecentFilter)(unsafe.Pointer(f.Native()))

C.gtk_recent_filter_add_pixbuf_formats(_arg0)
}
	
	// Filter tests whether a file should be displayed according to @filter. The
// RecentFilterInfo @filter_info should include the fields returned from
// gtk_recent_filter_get_needed(), and must set the RecentFilterInfo.contains
// field of @filter_info to indicate which fields have been set.
// 
// This function will not typically be used by applications; it is intended
// principally for use in the implementation of RecentChooser.
	func (f RecentFilter) Filter(filterInfo *RecentFilterInfo) bool {
var _arg0 *C.GtkRecentFilter // out
var _arg1 *C.GtkRecentFilterInfo // out
var _cret C.gboolean // in

_arg0 = (*C.GtkRecentFilter)(unsafe.Pointer(f.Native()))
_arg1 = (*C.GtkRecentFilterInfo)(unsafe.Pointer(filterInfo.Native()))

_cret = C.gtk_recent_filter_filter(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Name gets the human-readable name for the filter. See
// gtk_recent_filter_set_name().
	func (f RecentFilter) Name() string {
var _arg0 *C.GtkRecentFilter // out
var _cret *C.gchar // in

_arg0 = (*C.GtkRecentFilter)(unsafe.Pointer(f.Native()))

_cret = C.gtk_recent_filter_get_name(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Needed gets the fields that need to be filled in for the RecentFilterInfo
// passed to gtk_recent_filter_filter()
// 
// This function will not typically be used by applications; it is intended
// principally for use in the implementation of RecentChooser.
	func (f RecentFilter) Needed() RecentFilterFlags {
var _arg0 *C.GtkRecentFilter // out
var _cret C.GtkRecentFilterFlags // in

_arg0 = (*C.GtkRecentFilter)(unsafe.Pointer(f.Native()))

_cret = C.gtk_recent_filter_get_needed(_arg0)


var _recentFilterFlags RecentFilterFlags // out

_recentFilterFlags = RecentFilterFlags(_cret)

return _recentFilterFlags
}
	
	// SetName sets the human-readable name of the filter; this is the string that
// will be displayed in the recently used resources selector user interface if
// there is a selectable list of filters.
	func (f RecentFilter) SetName(name string)  {
var _arg0 *C.GtkRecentFilter // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkRecentFilter)(unsafe.Pointer(f.Native()))
_arg1 = (*C.gchar)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_recent_filter_set_name(_arg0, _arg1)
}
	


	// RecentManager provides a facility for adding, removing and looking up
// recently used files. Each recently used file is identified by its URI, and
// has meta-data associated to it, like the names and command lines of the
// applications that have registered it, the number of time each application has
// registered the same file, the mime type of the file and whether the file
// should be displayed only by the applications that have registered it.
// 
// The recently used files list is per user.
// 
// The RecentManager acts like a database of all the recently used files. You
// can create new RecentManager objects, but it is more efficient to use the
// default manager created by GTK+.
// 
// Adding a new recently used file is as simple as:
// 
//    GtkRecentManager *manager;
//    GtkRecentInfo *info;
//    GError *error = NULL;
// 
//    manager = gtk_recent_manager_get_default ();
//    info = gtk_recent_manager_lookup_item (manager, file_uri, &error);
//    if (error)
//      {
//        g_warning ("Could not find the file: s", error->message);
//        g_error_free (error);
//      }
//    else
//     {
//       // Use the info object
//       gtk_recent_info_unref (info);
//     }
// 
// In order to retrieve the list of recently used files, you can use
// gtk_recent_manager_get_items(), which returns a list of RecentInfo-structs.
// 
// A RecentManager is the model used to populate the contents of one, or more
// RecentChooser implementations.
// 
// Note that the maximum age of the recently used files list is controllable
// through the Settings:gtk-recent-files-max-age property.
// 
// Recently used files are supported since GTK+ 2.10.
	type RecentManager struct {
		**externglib.Object
		
	}

	// RecentManagerClass is an interface that the RecentManager class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type RecentManagerClass interface {
		gextras.Objector
		_recentManager()
	}

	func (RecentManager) _recentManager() {}

	
	func marshalRecentManager(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapRecentManager(obj), nil
	}
	

	
	// NewRecentManager creates a new recent manager object. Recent manager objects
// are used to handle the list of recently used resources. A RecentManager
// object monitors the recently used resources list, and emits the “changed”
// signal each time something inside the list changes.
// 
// RecentManager objects are expensive: be sure to create them only when needed.
// You should use gtk_recent_manager_get_default() instead.
	func NewRecentManager() RecentManager {
var _cret *C.GtkRecentManager // in

_cret = C.gtk_recent_manager_new()


var _recentManager RecentManager // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_recentManager = RecentManager{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}

return _recentManager
}
	

	
	// AddFull adds a new resource, pointed by @uri, into the recently used
// resources list, using the metadata specified inside the RecentData-struct
// passed in @recent_data.
// 
// The passed URI will be used to identify this resource inside the list.
// 
// In order to register the new recently used resource, metadata about the
// resource must be passed as well as the URI; the metadata is stored in a
// RecentData-struct, which must contain the MIME type of the resource pointed
// by the URI; the name of the application that is registering the item, and a
// command line to be used when launching the item.
// 
// Optionally, a RecentData-struct might contain a UTF-8 string to be used when
// viewing the item instead of the last component of the URI; a short
// description of the item; whether the item should be considered private - that
// is, should be displayed only by the applications that have registered it.
	func (m RecentManager) AddFull(uri string, recentData *RecentData) bool {
var _arg0 *C.GtkRecentManager // out
var _arg1 *C.gchar // out
var _arg2 *C.GtkRecentData // out
var _cret C.gboolean // in

_arg0 = (*C.GtkRecentManager)(unsafe.Pointer(m.Native()))
_arg1 = (*C.gchar)(C.CString(uri))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.GtkRecentData)(unsafe.Pointer(recentData.Native()))

_cret = C.gtk_recent_manager_add_full(_arg0, _arg1, _arg2)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// AddItem adds a new resource, pointed by @uri, into the recently used
// resources list.
// 
// This function automatically retrieves some of the needed metadata and setting
// other metadata to common default values; it then feeds the data to
// gtk_recent_manager_add_full().
// 
// See gtk_recent_manager_add_full() if you want to explicitly define the
// metadata for the resource pointed by @uri.
	func (m RecentManager) AddItem(uri string) bool {
var _arg0 *C.GtkRecentManager // out
var _arg1 *C.gchar // out
var _cret C.gboolean // in

_arg0 = (*C.GtkRecentManager)(unsafe.Pointer(m.Native()))
_arg1 = (*C.gchar)(C.CString(uri))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_recent_manager_add_item(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// HasItem checks whether there is a recently used resource registered with @uri
// inside the recent manager.
	func (m RecentManager) HasItem(uri string) bool {
var _arg0 *C.GtkRecentManager // out
var _arg1 *C.gchar // out
var _cret C.gboolean // in

_arg0 = (*C.GtkRecentManager)(unsafe.Pointer(m.Native()))
_arg1 = (*C.gchar)(C.CString(uri))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_recent_manager_has_item(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// LookupItem searches for a URI inside the recently used resources list, and
// returns a RecentInfo-struct containing informations about the resource like
// its MIME type, or its display name.
	func (m RecentManager) LookupItem(uri string) (*RecentInfo, error) {
var _arg0 *C.GtkRecentManager // out
var _arg1 *C.gchar // out
var _cret *C.GtkRecentInfo // in
var _cerr *C.GError // in

_arg0 = (*C.GtkRecentManager)(unsafe.Pointer(m.Native()))
_arg1 = (*C.gchar)(C.CString(uri))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_recent_manager_lookup_item(_arg0, _arg1, &_cerr)


var _recentInfo *RecentInfo // out
var _goerr error // out

_recentInfo = *(**RecentInfo)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_recentInfo, func(v *RecentInfo) {
  C.free(unsafe.Pointer(v.Native()))
})
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _recentInfo, _goerr
}
	
	// MoveItem changes the location of a recently used resource from @uri to
// @new_uri.
// 
// Please note that this function will not affect the resource pointed by the
// URIs, but only the URI used in the recently used resources list.
	func (m RecentManager) MoveItem(uri string, newUri string) error {
var _arg0 *C.GtkRecentManager // out
var _arg1 *C.gchar // out
var _arg2 *C.gchar // out
var _cerr *C.GError // in

_arg0 = (*C.GtkRecentManager)(unsafe.Pointer(m.Native()))
_arg1 = (*C.gchar)(C.CString(uri))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.gchar)(C.CString(newUri))
defer C.free(unsafe.Pointer(_arg2))

C.gtk_recent_manager_move_item(_arg0, _arg1, _arg2, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// PurgeItems purges every item from the recently used resources list.
	func (m RecentManager) PurgeItems() (int, error) {
var _arg0 *C.GtkRecentManager // out
var _cret C.gint // in
var _cerr *C.GError // in

_arg0 = (*C.GtkRecentManager)(unsafe.Pointer(m.Native()))

_cret = C.gtk_recent_manager_purge_items(_arg0, &_cerr)


var _gint int // out
var _goerr error // out

_gint = (int)(_cret)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _gint, _goerr
}
	
	// RemoveItem removes a resource pointed by @uri from the recently used
// resources list handled by a recent manager.
	func (m RecentManager) RemoveItem(uri string) error {
var _arg0 *C.GtkRecentManager // out
var _arg1 *C.gchar // out
var _cerr *C.GError // in

_arg0 = (*C.GtkRecentManager)(unsafe.Pointer(m.Native()))
_arg1 = (*C.gchar)(C.CString(uri))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_recent_manager_remove_item(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	


	// Revealer: the GtkRevealer widget is a container which animates the transition
// of its child from invisible to visible.
// 
// The style of transition can be controlled with
// gtk_revealer_set_transition_type().
// 
// These animations respect the Settings:gtk-enable-animations setting.
// 
// 
// CSS nodes
// 
// GtkRevealer has a single CSS node with name revealer.
// 
// The GtkRevealer widget was added in GTK+ 3.10.
	type Revealer struct {
		Bin
		Buildable
		
	}

	// RevealerClass is an interface that the Revealer class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type RevealerClass interface {
		gextras.Objector
		_revealer()
	}

	func (Revealer) _revealer() {}

	
	func marshalRevealer(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapRevealer(obj), nil
	}
	

	
	// NewRevealer creates a new Revealer.
	func NewRevealer() Revealer {
var _cret *C.GtkWidget // in

_cret = C.gtk_revealer_new()


var _revealer Revealer // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_revealer = Revealer{
Bin: Bin{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _revealer
}
	

	
	// ChildRevealed returns whether the child is fully revealed, in other words
// whether the transition to the revealed state is completed.
	func (r Revealer) ChildRevealed() bool {
var _arg0 *C.GtkRevealer // out
var _cret C.gboolean // in

_arg0 = (*C.GtkRevealer)(unsafe.Pointer(r.Native()))

_cret = C.gtk_revealer_get_child_revealed(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// RevealChild returns whether the child is currently revealed. See
// gtk_revealer_set_reveal_child().
// 
// This function returns true as soon as the transition is to the revealed state
// is started. To learn whether the child is fully revealed (ie the transition
// is completed), use gtk_revealer_get_child_revealed().
	func (r Revealer) RevealChild() bool {
var _arg0 *C.GtkRevealer // out
var _cret C.gboolean // in

_arg0 = (*C.GtkRevealer)(unsafe.Pointer(r.Native()))

_cret = C.gtk_revealer_get_reveal_child(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// TransitionDuration returns the amount of time (in milliseconds) that
// transitions will take.
	func (r Revealer) TransitionDuration() uint {
var _arg0 *C.GtkRevealer // out
var _cret C.guint // in

_arg0 = (*C.GtkRevealer)(unsafe.Pointer(r.Native()))

_cret = C.gtk_revealer_get_transition_duration(_arg0)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// TransitionType gets the type of animation that will be used for transitions
// in @revealer.
	func (r Revealer) TransitionType() RevealerTransitionType {
var _arg0 *C.GtkRevealer // out
var _cret C.GtkRevealerTransitionType // in

_arg0 = (*C.GtkRevealer)(unsafe.Pointer(r.Native()))

_cret = C.gtk_revealer_get_transition_type(_arg0)


var _revealerTransitionType RevealerTransitionType // out

_revealerTransitionType = RevealerTransitionType(_cret)

return _revealerTransitionType
}
	
	// SetRevealChild tells the Revealer to reveal or conceal its child.
// 
// The transition will be animated with the current transition type of
// @revealer.
	func (r Revealer) SetRevealChild(revealChild bool)  {
var _arg0 *C.GtkRevealer // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkRevealer)(unsafe.Pointer(r.Native()))
if revealChild { _arg1 = C.TRUE }

C.gtk_revealer_set_reveal_child(_arg0, _arg1)
}
	
	// SetTransitionDuration sets the duration that transitions will take.
	func (r Revealer) SetTransitionDuration(duration uint)  {
var _arg0 *C.GtkRevealer // out
var _arg1 C.guint // out

_arg0 = (*C.GtkRevealer)(unsafe.Pointer(r.Native()))
_arg1 = (C.guint)(duration)

C.gtk_revealer_set_transition_duration(_arg0, _arg1)
}
	
	// SetTransitionType sets the type of animation that will be used for
// transitions in @revealer. Available types include various kinds of fades and
// slides.
	func (r Revealer) SetTransitionType(transition RevealerTransitionType)  {
var _arg0 *C.GtkRevealer // out
var _arg1 C.GtkRevealerTransitionType // out

_arg0 = (*C.GtkRevealer)(unsafe.Pointer(r.Native()))
_arg1 = (C.GtkRevealerTransitionType)(transition)

C.gtk_revealer_set_transition_type(_arg0, _arg1)
}
	


	// Scale: a GtkScale is a slider control used to select a numeric value. To use
// it, you’ll probably want to investigate the methods on its base class, Range,
// in addition to the methods for GtkScale itself. To set the value of a scale,
// you would normally use gtk_range_set_value(). To detect changes to the value,
// you would normally use the Range::value-changed signal.
// 
// Note that using the same upper and lower bounds for the Scale (through the
// Range methods) will hide the slider itself. This is useful for applications
// that want to show an undeterminate value on the scale, without changing the
// layout of the application (such as movie or music players).
// 
// 
// GtkScale as GtkBuildable
// 
// GtkScale supports a custom <marks> element, which can contain multiple <mark>
// elements. The “value” and “position” attributes have the same meaning as
// gtk_scale_add_mark() parameters of the same name. If the element is not
// empty, its content is taken as the markup to show at the mark. It can be
// translated with the usual ”translatable” and “context” attributes.
// 
// CSS nodes
// 
//    scale[.fine-tune][.marks-before][.marks-after]
//    ├── marks.top
//    │   ├── mark
//    │   ┊    ├── [label]
//    │   ┊    ╰── indicator
//    ┊   ┊
//    │   ╰── mark
//    ├── [value]
//    ├── contents
//    │   ╰── trough
//    │       ├── slider
//    │       ├── [highlight]
//    │       ╰── [fill]
//    ╰── marks.bottom
//        ├── mark
//        ┊    ├── indicator
//        ┊    ╰── [label]
//        ╰── mark
// 
// GtkScale has a main CSS node with name scale and a subnode for its contents,
// with subnodes named trough and slider.
// 
// The main node gets the style class .fine-tune added when the scale is in
// 'fine-tuning' mode.
// 
// If the scale has an origin (see gtk_scale_set_has_origin()), there is a
// subnode with name highlight below the trough node that is used for rendering
// the highlighted part of the trough.
// 
// If the scale is showing a fill level (see gtk_range_set_show_fill_level()),
// there is a subnode with name fill below the trough node that is used for
// rendering the filled in part of the trough.
// 
// If marks are present, there is a marks subnode before or after the contents
// node, below which each mark gets a node with name mark. The marks nodes get
// either the .top or .bottom style class.
// 
// The mark node has a subnode named indicator. If the mark has text, it also
// has a subnode named label. When the mark is either above or left of the
// scale, the label subnode is the first when present. Otherwise, the indicator
// subnode is the first.
// 
// The main CSS node gets the 'marks-before' and/or 'marks-after' style classes
// added depending on what marks are present.
// 
// If the scale is displaying the value (see Scale:draw-value), there is subnode
// with name value.
	type Scale struct {
		Range
		Buildable
		Orientable
		
	}

	// ScaleClass is an interface that the Scale class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ScaleClass interface {
		gextras.Objector
		_scale()
	}

	func (Scale) _scale() {}

	
	func marshalScale(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapScale(obj), nil
	}
	

	
	// NewScale creates a new Scale.
	func NewScale(orientation Orientation, adjustment AdjustmentClass) Scale {
var _arg1 C.GtkOrientation // out
var _arg2 *C.GtkAdjustment // out
var _cret *C.GtkWidget // in

_arg1 = (C.GtkOrientation)(orientation)
_arg2 = (*C.GtkAdjustment)(unsafe.Pointer(adjustment.Native()))

_cret = C.gtk_scale_new(_arg1, _arg2)


var _scale Scale // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_scale = Scale{
Range: Range{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _scale
}
	
	// NewScaleWithRange creates a new scale widget with the given orientation that
// lets the user input a number between @min and @max (including @min and @max)
// with the increment @step. @step must be nonzero; it’s the distance the slider
// moves when using the arrow keys to adjust the scale value.
// 
// Note that the way in which the precision is derived works best if @step is a
// power of ten. If the resulting precision is not suitable for your needs, use
// gtk_scale_set_digits() to correct it.
	func NewScaleWithRange(orientation Orientation, min float64, max float64, step float64) Scale {
var _arg1 C.GtkOrientation // out
var _arg2 C.gdouble // out
var _arg3 C.gdouble // out
var _arg4 C.gdouble // out
var _cret *C.GtkWidget // in

_arg1 = (C.GtkOrientation)(orientation)
_arg2 = (C.gdouble)(min)
_arg3 = (C.gdouble)(max)
_arg4 = (C.gdouble)(step)

_cret = C.gtk_scale_new_with_range(_arg1, _arg2, _arg3, _arg4)


var _scale Scale // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_scale = Scale{
Range: Range{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _scale
}
	

	
	// AddMark adds a mark at @value.
// 
// A mark is indicated visually by drawing a tick mark next to the scale, and
// GTK+ makes it easy for the user to position the scale exactly at the marks
// value.
// 
// If @markup is not nil, text is shown next to the tick mark.
// 
// To remove marks from a scale, use gtk_scale_clear_marks().
	func (s Scale) AddMark(value float64, position PositionType, markup string)  {
var _arg0 *C.GtkScale // out
var _arg1 C.gdouble // out
var _arg2 C.GtkPositionType // out
var _arg3 *C.gchar // out

_arg0 = (*C.GtkScale)(unsafe.Pointer(s.Native()))
_arg1 = (C.gdouble)(value)
_arg2 = (C.GtkPositionType)(position)
_arg3 = (*C.gchar)(C.CString(markup))
defer C.free(unsafe.Pointer(_arg3))

C.gtk_scale_add_mark(_arg0, _arg1, _arg2, _arg3)
}
	
	// ClearMarks removes any marks that have been added with gtk_scale_add_mark().
	func (s Scale) ClearMarks()  {
var _arg0 *C.GtkScale // out

_arg0 = (*C.GtkScale)(unsafe.Pointer(s.Native()))

C.gtk_scale_clear_marks(_arg0)
}
	
	// Digits gets the number of decimal places that are displayed in the value.
	func (s Scale) Digits() int {
var _arg0 *C.GtkScale // out
var _cret C.gint // in

_arg0 = (*C.GtkScale)(unsafe.Pointer(s.Native()))

_cret = C.gtk_scale_get_digits(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// DrawValue returns whether the current value is displayed as a string next to
// the slider.
	func (s Scale) DrawValue() bool {
var _arg0 *C.GtkScale // out
var _cret C.gboolean // in

_arg0 = (*C.GtkScale)(unsafe.Pointer(s.Native()))

_cret = C.gtk_scale_get_draw_value(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// HasOrigin returns whether the scale has an origin.
	func (s Scale) HasOrigin() bool {
var _arg0 *C.GtkScale // out
var _cret C.gboolean // in

_arg0 = (*C.GtkScale)(unsafe.Pointer(s.Native()))

_cret = C.gtk_scale_get_has_origin(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Layout gets the Layout used to display the scale. The returned object is
// owned by the scale so does not need to be freed by the caller.
	func (s Scale) Layout() pango.Layout {
var _arg0 *C.GtkScale // out
var _cret *C.PangoLayout // in

_arg0 = (*C.GtkScale)(unsafe.Pointer(s.Native()))

_cret = C.gtk_scale_get_layout(_arg0)


var _layout pango.Layout // out

_layout = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(pango.Layout)

return _layout
}
	
	// LayoutOffsets obtains the coordinates where the scale will draw the Layout
// representing the text in the scale. Remember when using the Layout function
// you need to convert to and from pixels using PANGO_PIXELS() or NGO_SCALE.
// 
// If the Scale:draw-value property is false, the return values are undefined.
	func (s Scale) LayoutOffsets() (x int, y int) {
var _arg0 *C.GtkScale // out
var _arg1 C.gint // in
var _arg2 C.gint // in

_arg0 = (*C.GtkScale)(unsafe.Pointer(s.Native()))

C.gtk_scale_get_layout_offsets(_arg0, &_arg1, &_arg2)

var _x int // out
var _y int // out

_x = (int)(_arg1)
_y = (int)(_arg2)

return _x, _y
}
	
	// ValuePos gets the position in which the current value is displayed.
	func (s Scale) ValuePos() PositionType {
var _arg0 *C.GtkScale // out
var _cret C.GtkPositionType // in

_arg0 = (*C.GtkScale)(unsafe.Pointer(s.Native()))

_cret = C.gtk_scale_get_value_pos(_arg0)


var _positionType PositionType // out

_positionType = PositionType(_cret)

return _positionType
}
	
	// SetDigits sets the number of decimal places that are displayed in the value.
// Also causes the value of the adjustment to be rounded to this number of
// digits, so the retrieved value matches the displayed one, if Scale:draw-value
// is true when the value changes. If you want to enforce rounding the value
// when Scale:draw-value is false, you can set Range:round-digits instead.
// 
// Note that rounding to a small number of digits can interfere with the smooth
// autoscrolling that is built into Scale. As an alternative, you can use the
// Scale::format-value signal to format the displayed value yourself.
	func (s Scale) SetDigits(digits int)  {
var _arg0 *C.GtkScale // out
var _arg1 C.gint // out

_arg0 = (*C.GtkScale)(unsafe.Pointer(s.Native()))
_arg1 = (C.gint)(digits)

C.gtk_scale_set_digits(_arg0, _arg1)
}
	
	// SetDrawValue specifies whether the current value is displayed as a string
// next to the slider.
	func (s Scale) SetDrawValue(drawValue bool)  {
var _arg0 *C.GtkScale // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkScale)(unsafe.Pointer(s.Native()))
if drawValue { _arg1 = C.TRUE }

C.gtk_scale_set_draw_value(_arg0, _arg1)
}
	
	// SetHasOrigin: if Scale:has-origin is set to true (the default), the scale
// will highlight the part of the trough between the origin (bottom or left
// side) and the current value.
	func (s Scale) SetHasOrigin(hasOrigin bool)  {
var _arg0 *C.GtkScale // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkScale)(unsafe.Pointer(s.Native()))
if hasOrigin { _arg1 = C.TRUE }

C.gtk_scale_set_has_origin(_arg0, _arg1)
}
	
	// SetValuePos sets the position in which the current value is displayed.
	func (s Scale) SetValuePos(pos PositionType)  {
var _arg0 *C.GtkScale // out
var _arg1 C.GtkPositionType // out

_arg0 = (*C.GtkScale)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkPositionType)(pos)

C.gtk_scale_set_value_pos(_arg0, _arg1)
}
	


	// ScaleButton provides a button which pops up a scale widget. This kind of
// widget is commonly used for volume controls in multimedia applications, and
// GTK+ provides a VolumeButton subclass that is tailored for this use case.
// 
// 
// CSS nodes
// 
// GtkScaleButton has a single CSS node with name button. To differentiate it
// from a plain Button, it gets the .scale style class.
// 
// The popup widget that contains the scale has a .scale-popup style class.
	type ScaleButton struct {
		Button
		Actionable
		Activatable
		Buildable
		Orientable
		
	}

	// ScaleButtonClass is an interface that the ScaleButton class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ScaleButtonClass interface {
		gextras.Objector
		_scaleButton()
	}

	func (ScaleButton) _scaleButton() {}

	
	func marshalScaleButton(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapScaleButton(obj), nil
	}
	

	
	// NewScaleButton creates a ScaleButton, with a range between @min and @max,
// with a stepping of @step.
	func NewScaleButton(size int, min float64, max float64, step float64, icons []string) ScaleButton {
var _arg1 C.GtkIconSize // out
var _arg2 C.gdouble // out
var _arg3 C.gdouble // out
var _arg4 C.gdouble // out
var _arg5 **C.gchar
var _cret *C.GtkWidget // in

_arg1 = (C.GtkIconSize)(size)
_arg2 = (C.gdouble)(min)
_arg3 = (C.gdouble)(max)
_arg4 = (C.gdouble)(step)
_arg5 = (**C.gchar)(C.malloc(C.ulong(len(icons)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
defer C.free(unsafe.Pointer(_arg5))
{
out := unsafe.Slice(_arg5, len(icons))
for i := range icons {
out[i] = (*C.gchar)(C.CString(icons[i]))
defer C.free(unsafe.Pointer(out[i]))
}
}

_cret = C.gtk_scale_button_new(_arg1, _arg2, _arg3, _arg4, _arg5)


var _scaleButton ScaleButton // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_scaleButton = ScaleButton{
Button: Button{
Bin: Bin{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _scaleButton
}
	

	
	// Adjustment gets the Adjustment associated with the ScaleButton’s scale. See
// gtk_range_get_adjustment() for details.
	func (b ScaleButton) Adjustment() Adjustment {
var _arg0 *C.GtkScaleButton // out
var _cret *C.GtkAdjustment // in

_arg0 = (*C.GtkScaleButton)(unsafe.Pointer(b.Native()))

_cret = C.gtk_scale_button_get_adjustment(_arg0)


var _adjustment Adjustment // out

_adjustment = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Adjustment)

return _adjustment
}
	
	// MinusButton retrieves the minus button of the ScaleButton.
	func (b ScaleButton) MinusButton() Button {
var _arg0 *C.GtkScaleButton // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkScaleButton)(unsafe.Pointer(b.Native()))

_cret = C.gtk_scale_button_get_minus_button(_arg0)


var _ret Button // out

_ret = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Button)

return _ret
}
	
	// PlusButton retrieves the plus button of the ScaleButton.
	func (b ScaleButton) PlusButton() Button {
var _arg0 *C.GtkScaleButton // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkScaleButton)(unsafe.Pointer(b.Native()))

_cret = C.gtk_scale_button_get_plus_button(_arg0)


var _ret Button // out

_ret = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Button)

return _ret
}
	
	// Popup retrieves the popup of the ScaleButton.
	func (b ScaleButton) Popup() Widget {
var _arg0 *C.GtkScaleButton // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkScaleButton)(unsafe.Pointer(b.Native()))

_cret = C.gtk_scale_button_get_popup(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// Value gets the current value of the scale button.
	func (b ScaleButton) Value() float64 {
var _arg0 *C.GtkScaleButton // out
var _cret C.gdouble // in

_arg0 = (*C.GtkScaleButton)(unsafe.Pointer(b.Native()))

_cret = C.gtk_scale_button_get_value(_arg0)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// SetAdjustment sets the Adjustment to be used as a model for the ScaleButton’s
// scale. See gtk_range_set_adjustment() for details.
	func (b ScaleButton) SetAdjustment(adjustment AdjustmentClass)  {
var _arg0 *C.GtkScaleButton // out
var _arg1 *C.GtkAdjustment // out

_arg0 = (*C.GtkScaleButton)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(adjustment.Native()))

C.gtk_scale_button_set_adjustment(_arg0, _arg1)
}
	
	// SetIcons sets the icons to be used by the scale button. For details, see the
// ScaleButton:icons property.
	func (b ScaleButton) SetIcons(icons []string)  {
var _arg0 *C.GtkScaleButton // out
var _arg1 **C.gchar

_arg0 = (*C.GtkScaleButton)(unsafe.Pointer(b.Native()))
_arg1 = (**C.gchar)(C.malloc(C.ulong(len(icons)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
defer C.free(unsafe.Pointer(_arg1))
{
out := unsafe.Slice(_arg1, len(icons))
for i := range icons {
out[i] = (*C.gchar)(C.CString(icons[i]))
defer C.free(unsafe.Pointer(out[i]))
}
}

C.gtk_scale_button_set_icons(_arg0, _arg1)
}
	
	// SetValue sets the current value of the scale; if the value is outside the
// minimum or maximum range values, it will be clamped to fit inside them. The
// scale button emits the ScaleButton::value-changed signal if the value
// changes.
	func (b ScaleButton) SetValue(value float64)  {
var _arg0 *C.GtkScaleButton // out
var _arg1 C.gdouble // out

_arg0 = (*C.GtkScaleButton)(unsafe.Pointer(b.Native()))
_arg1 = (C.gdouble)(value)

C.gtk_scale_button_set_value(_arg0, _arg1)
}
	


	// Scrollbar: the Scrollbar widget is a horizontal or vertical scrollbar,
// depending on the value of the Orientable:orientation property.
// 
// Its position and movement are controlled by the adjustment that is passed to
// or created by gtk_scrollbar_new(). See Adjustment for more details. The
// Adjustment:value field sets the position of the thumb and must be between
// Adjustment:lower and Adjustment:upper - Adjustment:page-size. The
// Adjustment:page-size represents the size of the visible scrollable area. The
// fields Adjustment:step-increment and Adjustment:page-increment fields are
// added to or subtracted from the Adjustment:value when the user asks to move
// by a step (using e.g. the cursor arrow keys or, if present, the stepper
// buttons) or by a page (using e.g. the Page Down/Up keys).
// 
// CSS nodes
// 
//    scrollbar[.fine-tune]
//    ╰── contents
//        ├── [button.up]
//        ├── [button.down]
//        ├── trough
//        │   ╰── slider
//        ├── [button.up]
//        ╰── [button.down]
// 
// GtkScrollbar has a main CSS node with name scrollbar and a subnode for its
// contents, with subnodes named trough and slider.
// 
// The main node gets the style class .fine-tune added when the scrollbar is in
// 'fine-tuning' mode.
// 
// If steppers are enabled, they are represented by up to four additional
// subnodes with name button. These get the style classes .up and .down to
// indicate in which direction they are moving.
// 
// Other style classes that may be added to scrollbars inside ScrolledWindow
// include the positional classes (.left, .right, .top, .bottom) and style
// classes related to overlay scrolling (.overlay-indicator, .dragging,
// .hovering).
	type Scrollbar struct {
		Range
		Buildable
		Orientable
		
	}

	// ScrollbarClass is an interface that the Scrollbar class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ScrollbarClass interface {
		gextras.Objector
		_scrollbar()
	}

	func (Scrollbar) _scrollbar() {}

	
	func marshalScrollbar(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapScrollbar(obj), nil
	}
	

	
	// NewScrollbar creates a new scrollbar with the given orientation.
	func NewScrollbar(orientation Orientation, adjustment AdjustmentClass) Scrollbar {
var _arg1 C.GtkOrientation // out
var _arg2 *C.GtkAdjustment // out
var _cret *C.GtkWidget // in

_arg1 = (C.GtkOrientation)(orientation)
_arg2 = (*C.GtkAdjustment)(unsafe.Pointer(adjustment.Native()))

_cret = C.gtk_scrollbar_new(_arg1, _arg2)


var _scrollbar Scrollbar // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_scrollbar = Scrollbar{
Range: Range{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _scrollbar
}
	

	


	// ScrolledWindow: gtkScrolledWindow is a container that accepts a single child
// widget, makes that child scrollable using either internally added scrollbars
// or externally associated adjustments, and optionally draws a frame around the
// child.
// 
// Widgets with native scrolling support, i.e. those whose classes implement the
// Scrollable interface, are added directly. For other types of widget, the
// class Viewport acts as an adaptor, giving scrollability to other widgets.
// GtkScrolledWindow’s implementation of gtk_container_add() intelligently
// accounts for whether or not the added child is a Scrollable. If it isn’t,
// ScrolledWindow wraps the child in a Viewport and adds that for you.
// Therefore, you can just add any child widget and not worry about the details.
// 
// If gtk_container_add() has added a Viewport for you, you can remove both your
// added child widget from the Viewport, and the Viewport from the
// GtkScrolledWindow, like this:
// 
//    GtkWidget *scrolled_window = gtk_scrolled_window_new (NULL, NULL);
//    GtkWidget *child_widget = gtk_button_new ();
// 
//    // GtkButton is not a GtkScrollable, so GtkScrolledWindow will automatically
//    // add a GtkViewport.
//    gtk_container_add (GTK_CONTAINER (scrolled_window),
//                       child_widget);
// 
//    // Either of these will result in child_widget being unparented:
//    gtk_container_remove (GTK_CONTAINER (scrolled_window),
//                          child_widget);
//    // or
//    gtk_container_remove (GTK_CONTAINER (scrolled_window),
//                          gtk_bin_get_child (GTK_BIN (scrolled_window)));
// 
// Unless ScrolledWindow:policy is GTK_POLICY_NEVER or GTK_POLICY_EXTERNAL,
// GtkScrolledWindow adds internal Scrollbar widgets around its child. The
// scroll position of the child, and if applicable the scrollbars, is controlled
// by the ScrolledWindow:hadjustment and ScrolledWindow:vadjustment that are
// associated with the GtkScrolledWindow. See the docs on Scrollbar for the
// details, but note that the “step_increment” and “page_increment” fields are
// only effective if the policy causes scrollbars to be present.
// 
// If a GtkScrolledWindow doesn’t behave quite as you would like, or doesn’t
// have exactly the right layout, it’s very possible to set up your own
// scrolling with Scrollbar and for example a Grid.
// 
// 
// Touch support
// 
// GtkScrolledWindow has built-in support for touch devices. When a touchscreen
// is used, swiping will move the scrolled window, and will expose 'kinetic'
// behavior. This can be turned off with the ScrolledWindow:kinetic-scrolling
// property if it is undesired.
// 
// GtkScrolledWindow also displays visual 'overshoot' indication when the
// content is pulled beyond the end, and this situation can be captured with the
// ScrolledWindow::edge-overshot signal.
// 
// If no mouse device is present, the scrollbars will overlayed as narrow,
// auto-hiding indicators over the content. If traditional scrollbars are
// desired although no mouse is present, this behaviour can be turned off with
// the ScrolledWindow:overlay-scrolling property.
// 
// 
// CSS nodes
// 
// GtkScrolledWindow has a main CSS node with name scrolledwindow.
// 
// It uses subnodes with names overshoot and undershoot to draw the overflow and
// underflow indications. These nodes get the .left, .right, .top or .bottom
// style class added depending on where the indication is drawn.
// 
// GtkScrolledWindow also sets the positional style classes (.left, .right,
// .top, .bottom) and style classes related to overlay scrolling
// (.overlay-indicator, .dragging, .hovering) on its scrollbars.
// 
// If both scrollbars are visible, the area where they meet is drawn with a
// subnode named junction.
	type ScrolledWindow struct {
		Bin
		Buildable
		
	}

	// ScrolledWindowClass is an interface that the ScrolledWindow class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ScrolledWindowClass interface {
		gextras.Objector
		_scrolledWindow()
	}

	func (ScrolledWindow) _scrolledWindow() {}

	
	func marshalScrolledWindow(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapScrolledWindow(obj), nil
	}
	

	
	// NewScrolledWindow creates a new scrolled window.
// 
// The two arguments are the scrolled window’s adjustments; these will be shared
// with the scrollbars and the child widget to keep the bars in sync with the
// child. Usually you want to pass nil for the adjustments, which will cause the
// scrolled window to create them for you.
	func NewScrolledWindow(hadjustment AdjustmentClass, vadjustment AdjustmentClass) ScrolledWindow {
var _arg1 *C.GtkAdjustment // out
var _arg2 *C.GtkAdjustment // out
var _cret *C.GtkWidget // in

_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(hadjustment.Native()))
_arg2 = (*C.GtkAdjustment)(unsafe.Pointer(vadjustment.Native()))

_cret = C.gtk_scrolled_window_new(_arg1, _arg2)


var _scrolledWindow ScrolledWindow // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_scrolledWindow = ScrolledWindow{
Bin: Bin{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _scrolledWindow
}
	

	
	// AddWithViewport: used to add children without native scrolling capabilities.
// This is simply a convenience function; it is equivalent to adding the
// unscrollable child to a viewport, then adding the viewport to the scrolled
// window. If a child has native scrolling, use gtk_container_add() instead of
// this function.
// 
// The viewport scrolls the child by moving its Window, and takes the size of
// the child to be the size of its toplevel Window. This will be very wrong for
// most widgets that support native scrolling; for example, if you add a widget
// such as TreeView with a viewport, the whole widget will scroll, including the
// column headings. Thus, widgets with native scrolling support should not be
// used with the Viewport proxy.
// 
// A widget supports scrolling natively if it implements the Scrollable
// interface.
	func (s ScrolledWindow) AddWithViewport(child WidgetClass)  {
var _arg0 *C.GtkScrolledWindow // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

C.gtk_scrolled_window_add_with_viewport(_arg0, _arg1)
}
	
	// CaptureButtonPress: return whether button presses are captured during kinetic
// scrolling. See gtk_scrolled_window_set_capture_button_press().
	func (s ScrolledWindow) CaptureButtonPress() bool {
var _arg0 *C.GtkScrolledWindow // out
var _cret C.gboolean // in

_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

_cret = C.gtk_scrolled_window_get_capture_button_press(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// HAdjustment returns the horizontal scrollbar’s adjustment, used to connect
// the horizontal scrollbar to the child widget’s horizontal scroll
// functionality.
	func (s ScrolledWindow) HAdjustment() Adjustment {
var _arg0 *C.GtkScrolledWindow // out
var _cret *C.GtkAdjustment // in

_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

_cret = C.gtk_scrolled_window_get_hadjustment(_arg0)


var _adjustment Adjustment // out

_adjustment = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Adjustment)

return _adjustment
}
	
	// HScrollbar returns the horizontal scrollbar of @scrolled_window.
	func (s ScrolledWindow) HScrollbar() Widget {
var _arg0 *C.GtkScrolledWindow // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

_cret = C.gtk_scrolled_window_get_hscrollbar(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// KineticScrolling returns the specified kinetic scrolling behavior.
	func (s ScrolledWindow) KineticScrolling() bool {
var _arg0 *C.GtkScrolledWindow // out
var _cret C.gboolean // in

_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

_cret = C.gtk_scrolled_window_get_kinetic_scrolling(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// MaxContentHeight returns the maximum content height set.
	func (s ScrolledWindow) MaxContentHeight() int {
var _arg0 *C.GtkScrolledWindow // out
var _cret C.gint // in

_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

_cret = C.gtk_scrolled_window_get_max_content_height(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// MaxContentWidth returns the maximum content width set.
	func (s ScrolledWindow) MaxContentWidth() int {
var _arg0 *C.GtkScrolledWindow // out
var _cret C.gint // in

_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

_cret = C.gtk_scrolled_window_get_max_content_width(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// MinContentHeight gets the minimal content height of @scrolled_window, or -1
// if not set.
	func (s ScrolledWindow) MinContentHeight() int {
var _arg0 *C.GtkScrolledWindow // out
var _cret C.gint // in

_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

_cret = C.gtk_scrolled_window_get_min_content_height(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// MinContentWidth gets the minimum content width of @scrolled_window, or -1 if
// not set.
	func (s ScrolledWindow) MinContentWidth() int {
var _arg0 *C.GtkScrolledWindow // out
var _cret C.gint // in

_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

_cret = C.gtk_scrolled_window_get_min_content_width(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// OverlayScrolling returns whether overlay scrolling is enabled for this
// scrolled window.
	func (s ScrolledWindow) OverlayScrolling() bool {
var _arg0 *C.GtkScrolledWindow // out
var _cret C.gboolean // in

_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

_cret = C.gtk_scrolled_window_get_overlay_scrolling(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Placement gets the placement of the contents with respect to the scrollbars
// for the scrolled window. See gtk_scrolled_window_set_placement().
	func (s ScrolledWindow) Placement() CornerType {
var _arg0 *C.GtkScrolledWindow // out
var _cret C.GtkCornerType // in

_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

_cret = C.gtk_scrolled_window_get_placement(_arg0)


var _cornerType CornerType // out

_cornerType = CornerType(_cret)

return _cornerType
}
	
	// Policy retrieves the current policy values for the horizontal and vertical
// scrollbars. See gtk_scrolled_window_set_policy().
	func (s ScrolledWindow) Policy() (hscrollbarPolicy PolicyType, vscrollbarPolicy PolicyType) {
var _arg0 *C.GtkScrolledWindow // out
var _arg1 C.GtkPolicyType // in
var _arg2 C.GtkPolicyType // in

_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

C.gtk_scrolled_window_get_policy(_arg0, &_arg1, &_arg2)

var _hscrollbarPolicy PolicyType // out
var _vscrollbarPolicy PolicyType // out

_hscrollbarPolicy = PolicyType(_arg1)
_vscrollbarPolicy = PolicyType(_arg2)

return _hscrollbarPolicy, _vscrollbarPolicy
}
	
	// PropagateNaturalHeight reports whether the natural height of the child will
// be calculated and propagated through the scrolled window’s requested natural
// height.
	func (s ScrolledWindow) PropagateNaturalHeight() bool {
var _arg0 *C.GtkScrolledWindow // out
var _cret C.gboolean // in

_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

_cret = C.gtk_scrolled_window_get_propagate_natural_height(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// PropagateNaturalWidth reports whether the natural width of the child will be
// calculated and propagated through the scrolled window’s requested natural
// width.
	func (s ScrolledWindow) PropagateNaturalWidth() bool {
var _arg0 *C.GtkScrolledWindow // out
var _cret C.gboolean // in

_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

_cret = C.gtk_scrolled_window_get_propagate_natural_width(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ShadowType gets the shadow type of the scrolled window. See
// gtk_scrolled_window_set_shadow_type().
	func (s ScrolledWindow) ShadowType() ShadowType {
var _arg0 *C.GtkScrolledWindow // out
var _cret C.GtkShadowType // in

_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

_cret = C.gtk_scrolled_window_get_shadow_type(_arg0)


var _shadowType ShadowType // out

_shadowType = ShadowType(_cret)

return _shadowType
}
	
	// VAdjustment returns the vertical scrollbar’s adjustment, used to connect the
// vertical scrollbar to the child widget’s vertical scroll functionality.
	func (s ScrolledWindow) VAdjustment() Adjustment {
var _arg0 *C.GtkScrolledWindow // out
var _cret *C.GtkAdjustment // in

_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

_cret = C.gtk_scrolled_window_get_vadjustment(_arg0)


var _adjustment Adjustment // out

_adjustment = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Adjustment)

return _adjustment
}
	
	// VScrollbar returns the vertical scrollbar of @scrolled_window.
	func (s ScrolledWindow) VScrollbar() Widget {
var _arg0 *C.GtkScrolledWindow // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

_cret = C.gtk_scrolled_window_get_vscrollbar(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// SetCaptureButtonPress changes the behaviour of @scrolled_window with regard
// to the initial event that possibly starts kinetic scrolling. When
// @capture_button_press is set to true, the event is captured by the scrolled
// window, and then later replayed if it is meant to go to the child widget.
// 
// This should be enabled if any child widgets perform non-reversible actions on
// Widget::button-press-event. If they don't, and handle additionally handle
// Widget::grab-broken-event, it might be better to set @capture_button_press to
// false.
// 
// This setting only has an effect if kinetic scrolling is enabled.
	func (s ScrolledWindow) SetCaptureButtonPress(captureButtonPress bool)  {
var _arg0 *C.GtkScrolledWindow // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
if captureButtonPress { _arg1 = C.TRUE }

C.gtk_scrolled_window_set_capture_button_press(_arg0, _arg1)
}
	
	// SetHAdjustment sets the Adjustment for the horizontal scrollbar.
	func (s ScrolledWindow) SetHAdjustment(hadjustment AdjustmentClass)  {
var _arg0 *C.GtkScrolledWindow // out
var _arg1 *C.GtkAdjustment // out

_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(hadjustment.Native()))

C.gtk_scrolled_window_set_hadjustment(_arg0, _arg1)
}
	
	// SetKineticScrolling turns kinetic scrolling on or off. Kinetic scrolling only
// applies to devices with source GDK_SOURCE_TOUCHSCREEN.
	func (s ScrolledWindow) SetKineticScrolling(kineticScrolling bool)  {
var _arg0 *C.GtkScrolledWindow // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
if kineticScrolling { _arg1 = C.TRUE }

C.gtk_scrolled_window_set_kinetic_scrolling(_arg0, _arg1)
}
	
	// SetMaxContentHeight sets the maximum height that @scrolled_window should keep
// visible. The @scrolled_window will grow up to this height before it starts
// scrolling the content.
// 
// It is a programming error to set the maximum content height to a value
// smaller than ScrolledWindow:min-content-height.
	func (s ScrolledWindow) SetMaxContentHeight(height int)  {
var _arg0 *C.GtkScrolledWindow // out
var _arg1 C.gint // out

_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
_arg1 = (C.gint)(height)

C.gtk_scrolled_window_set_max_content_height(_arg0, _arg1)
}
	
	// SetMaxContentWidth sets the maximum width that @scrolled_window should keep
// visible. The @scrolled_window will grow up to this width before it starts
// scrolling the content.
// 
// It is a programming error to set the maximum content width to a value smaller
// than ScrolledWindow:min-content-width.
	func (s ScrolledWindow) SetMaxContentWidth(width int)  {
var _arg0 *C.GtkScrolledWindow // out
var _arg1 C.gint // out

_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
_arg1 = (C.gint)(width)

C.gtk_scrolled_window_set_max_content_width(_arg0, _arg1)
}
	
	// SetMinContentHeight sets the minimum height that @scrolled_window should keep
// visible. Note that this can and (usually will) be smaller than the minimum
// size of the content.
// 
// It is a programming error to set the minimum content height to a value
// greater than ScrolledWindow:max-content-height.
	func (s ScrolledWindow) SetMinContentHeight(height int)  {
var _arg0 *C.GtkScrolledWindow // out
var _arg1 C.gint // out

_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
_arg1 = (C.gint)(height)

C.gtk_scrolled_window_set_min_content_height(_arg0, _arg1)
}
	
	// SetMinContentWidth sets the minimum width that @scrolled_window should keep
// visible. Note that this can and (usually will) be smaller than the minimum
// size of the content.
// 
// It is a programming error to set the minimum content width to a value greater
// than ScrolledWindow:max-content-width.
	func (s ScrolledWindow) SetMinContentWidth(width int)  {
var _arg0 *C.GtkScrolledWindow // out
var _arg1 C.gint // out

_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
_arg1 = (C.gint)(width)

C.gtk_scrolled_window_set_min_content_width(_arg0, _arg1)
}
	
	// SetOverlayScrolling enables or disables overlay scrolling for this scrolled
// window.
	func (s ScrolledWindow) SetOverlayScrolling(overlayScrolling bool)  {
var _arg0 *C.GtkScrolledWindow // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
if overlayScrolling { _arg1 = C.TRUE }

C.gtk_scrolled_window_set_overlay_scrolling(_arg0, _arg1)
}
	
	// SetPlacement sets the placement of the contents with respect to the
// scrollbars for the scrolled window.
// 
// The default is GTK_CORNER_TOP_LEFT, meaning the child is in the top left,
// with the scrollbars underneath and to the right. Other values in CornerType
// are GTK_CORNER_TOP_RIGHT, GTK_CORNER_BOTTOM_LEFT, and
// GTK_CORNER_BOTTOM_RIGHT.
// 
// See also gtk_scrolled_window_get_placement() and
// gtk_scrolled_window_unset_placement().
	func (s ScrolledWindow) SetPlacement(windowPlacement CornerType)  {
var _arg0 *C.GtkScrolledWindow // out
var _arg1 C.GtkCornerType // out

_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkCornerType)(windowPlacement)

C.gtk_scrolled_window_set_placement(_arg0, _arg1)
}
	
	// SetPolicy sets the scrollbar policy for the horizontal and vertical
// scrollbars.
// 
// The policy determines when the scrollbar should appear; it is a value from
// the PolicyType enumeration. If GTK_POLICY_ALWAYS, the scrollbar is always
// present; if GTK_POLICY_NEVER, the scrollbar is never present; if
// GTK_POLICY_AUTOMATIC, the scrollbar is present only if needed (that is, if
// the slider part of the bar would be smaller than the trough — the display is
// larger than the page size).
	func (s ScrolledWindow) SetPolicy(hscrollbarPolicy PolicyType, vscrollbarPolicy PolicyType)  {
var _arg0 *C.GtkScrolledWindow // out
var _arg1 C.GtkPolicyType // out
var _arg2 C.GtkPolicyType // out

_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkPolicyType)(hscrollbarPolicy)
_arg2 = (C.GtkPolicyType)(vscrollbarPolicy)

C.gtk_scrolled_window_set_policy(_arg0, _arg1, _arg2)
}
	
	// SetPropagateNaturalHeight sets whether the natural height of the child should
// be calculated and propagated through the scrolled window’s requested natural
// height.
	func (s ScrolledWindow) SetPropagateNaturalHeight(propagate bool)  {
var _arg0 *C.GtkScrolledWindow // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
if propagate { _arg1 = C.TRUE }

C.gtk_scrolled_window_set_propagate_natural_height(_arg0, _arg1)
}
	
	// SetPropagateNaturalWidth sets whether the natural width of the child should
// be calculated and propagated through the scrolled window’s requested natural
// width.
	func (s ScrolledWindow) SetPropagateNaturalWidth(propagate bool)  {
var _arg0 *C.GtkScrolledWindow // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
if propagate { _arg1 = C.TRUE }

C.gtk_scrolled_window_set_propagate_natural_width(_arg0, _arg1)
}
	
	// SetShadowType changes the type of shadow drawn around the contents of
// @scrolled_window.
	func (s ScrolledWindow) SetShadowType(typ ShadowType)  {
var _arg0 *C.GtkScrolledWindow // out
var _arg1 C.GtkShadowType // out

_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkShadowType)(typ)

C.gtk_scrolled_window_set_shadow_type(_arg0, _arg1)
}
	
	// SetVAdjustment sets the Adjustment for the vertical scrollbar.
	func (s ScrolledWindow) SetVAdjustment(vadjustment AdjustmentClass)  {
var _arg0 *C.GtkScrolledWindow // out
var _arg1 *C.GtkAdjustment // out

_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(vadjustment.Native()))

C.gtk_scrolled_window_set_vadjustment(_arg0, _arg1)
}
	
	// UnsetPlacement unsets the placement of the contents with respect to the
// scrollbars for the scrolled window. If no window placement is set for a
// scrolled window, it defaults to GTK_CORNER_TOP_LEFT.
// 
// See also gtk_scrolled_window_set_placement() and
// gtk_scrolled_window_get_placement().
	func (s ScrolledWindow) UnsetPlacement()  {
var _arg0 *C.GtkScrolledWindow // out

_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

C.gtk_scrolled_window_unset_placement(_arg0)
}
	


	// SearchBar is a container made to have a search entry (possibly with
// additional connex widgets, such as drop-down menus, or buttons) built-in. The
// search bar would appear when a search is started through typing on the
// keyboard, or the application’s search mode is toggled on.
// 
// For keyboard presses to start a search, events will need to be forwarded from
// the top-level window that contains the search bar. See
// gtk_search_bar_handle_event() for example code. Common shortcuts such as
// Ctrl+F should be handled as an application action, or through the menu items.
// 
// You will also need to tell the search bar about which entry you are using as
// your search entry using gtk_search_bar_connect_entry(). The following example
// shows you how to create a more complex search entry.
// 
// 
// CSS nodes
// 
// GtkSearchBar has a single CSS node with name searchbar.
// 
// 
// Creating a search bar
// 
// A simple example
// (https://gitlab.gnome.org/GNOME/gtk/blob/gtk-3-24/examples/search-bar.c)
	type SearchBar struct {
		Bin
		Buildable
		
	}

	// SearchBarClass is an interface that the SearchBar class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type SearchBarClass interface {
		gextras.Objector
		_searchBar()
	}

	func (SearchBar) _searchBar() {}

	
	func marshalSearchBar(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapSearchBar(obj), nil
	}
	

	
	// NewSearchBar creates a SearchBar. You will need to tell it about which widget
// is going to be your text entry using gtk_search_bar_connect_entry().
	func NewSearchBar() SearchBar {
var _cret *C.GtkWidget // in

_cret = C.gtk_search_bar_new()


var _searchBar SearchBar // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_searchBar = SearchBar{
Bin: Bin{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _searchBar
}
	

	
	// ConnectEntry connects the Entry widget passed as the one to be used in this
// search bar. The entry should be a descendant of the search bar. This is only
// required if the entry isn’t the direct child of the search bar (as in our
// main example).
	func (b SearchBar) ConnectEntry(entry EntryClass)  {
var _arg0 *C.GtkSearchBar // out
var _arg1 *C.GtkEntry // out

_arg0 = (*C.GtkSearchBar)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkEntry)(unsafe.Pointer(entry.Native()))

C.gtk_search_bar_connect_entry(_arg0, _arg1)
}
	
	// SearchMode returns whether the search mode is on or off.
	func (b SearchBar) SearchMode() bool {
var _arg0 *C.GtkSearchBar // out
var _cret C.gboolean // in

_arg0 = (*C.GtkSearchBar)(unsafe.Pointer(b.Native()))

_cret = C.gtk_search_bar_get_search_mode(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ShowCloseButton returns whether the close button is shown.
	func (b SearchBar) ShowCloseButton() bool {
var _arg0 *C.GtkSearchBar // out
var _cret C.gboolean // in

_arg0 = (*C.GtkSearchBar)(unsafe.Pointer(b.Native()))

_cret = C.gtk_search_bar_get_show_close_button(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetSearchMode switches the search mode on or off.
	func (b SearchBar) SetSearchMode(searchMode bool)  {
var _arg0 *C.GtkSearchBar // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkSearchBar)(unsafe.Pointer(b.Native()))
if searchMode { _arg1 = C.TRUE }

C.gtk_search_bar_set_search_mode(_arg0, _arg1)
}
	
	// SetShowCloseButton shows or hides the close button. Applications that already
// have a “search” toggle button should not show a close button in their search
// bar, as it duplicates the role of the toggle button.
	func (b SearchBar) SetShowCloseButton(visible bool)  {
var _arg0 *C.GtkSearchBar // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkSearchBar)(unsafe.Pointer(b.Native()))
if visible { _arg1 = C.TRUE }

C.gtk_search_bar_set_show_close_button(_arg0, _arg1)
}
	


	// SearchEntry is a subclass of Entry that has been tailored for use as a search
// entry.
// 
// It will show an inactive symbolic “find” icon when the search entry is empty,
// and a symbolic “clear” icon when there is text. Clicking on the “clear” icon
// will empty the search entry.
// 
// Note that the search/clear icon is shown using a secondary icon, and thus
// does not work if you are using the secondary icon position for some other
// purpose.
// 
// To make filtering appear more reactive, it is a good idea to not react to
// every change in the entry text immediately, but only after a short delay. To
// support this, SearchEntry emits the SearchEntry::search-changed signal which
// can be used instead of the Editable::changed signal.
// 
// The SearchEntry::previous-match, SearchEntry::next-match and
// SearchEntry::stop-search signals can be used to implement moving between
// search results and ending the search.
// 
// Often, GtkSearchEntry will be fed events by means of being placed inside a
// SearchBar. If that is not the case, you can use
// gtk_search_entry_handle_event() to pass events.
	type SearchEntry struct {
		Entry
		Buildable
		CellEditable
		Editable
		
	}

	// SearchEntryClass is an interface that the SearchEntry class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type SearchEntryClass interface {
		gextras.Objector
		_searchEntry()
	}

	func (SearchEntry) _searchEntry() {}

	
	func marshalSearchEntry(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapSearchEntry(obj), nil
	}
	

	
	// NewSearchEntry creates a SearchEntry, with a find icon when the search field
// is empty, and a clear icon when it isn't.
	func NewSearchEntry() SearchEntry {
var _cret *C.GtkWidget // in

_cret = C.gtk_search_entry_new()


var _searchEntry SearchEntry // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_searchEntry = SearchEntry{
Entry: Entry{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
CellEditable: CellEditable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Editable: Editable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
CellEditable: CellEditable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Editable: Editable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _searchEntry
}
	

	


	// Separator: gtkSeparator is a horizontal or vertical separator widget,
// depending on the value of the Orientable:orientation property, used to group
// the widgets within a window. It displays a line with a shadow to make it
// appear sunken into the interface.
// 
// 
// CSS nodes
// 
// GtkSeparator has a single CSS node with name separator. The node gets one of
// the .horizontal or .vertical style classes.
	type Separator struct {
		Widget
		Buildable
		Orientable
		
	}

	// SeparatorClass is an interface that the Separator class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type SeparatorClass interface {
		gextras.Objector
		_separator()
	}

	func (Separator) _separator() {}

	
	func marshalSeparator(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapSeparator(obj), nil
	}
	

	
	// NewSeparator creates a new Separator with the given orientation.
	func NewSeparator(orientation Orientation) Separator {
var _arg1 C.GtkOrientation // out
var _cret *C.GtkWidget // in

_arg1 = (C.GtkOrientation)(orientation)

_cret = C.gtk_separator_new(_arg1)


var _separator Separator // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_separator = Separator{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _separator
}
	

	


	// SeparatorMenuItem: the SeparatorMenuItem is a separator used to group items
// within a menu. It displays a horizontal line with a shadow to make it appear
// sunken into the interface.
// 
// 
// CSS nodes
// 
// GtkSeparatorMenuItem has a single CSS node with name separator.
	type SeparatorMenuItem struct {
		MenuItem
		Actionable
		Activatable
		Buildable
		
	}

	// SeparatorMenuItemClass is an interface that the SeparatorMenuItem class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type SeparatorMenuItemClass interface {
		gextras.Objector
		_separatorMenuItem()
	}

	func (SeparatorMenuItem) _separatorMenuItem() {}

	
	func marshalSeparatorMenuItem(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapSeparatorMenuItem(obj), nil
	}
	

	
	// NewSeparatorMenuItem creates a new SeparatorMenuItem.
	func NewSeparatorMenuItem() SeparatorMenuItem {
var _cret *C.GtkWidget // in

_cret = C.gtk_separator_menu_item_new()


var _separatorMenuItem SeparatorMenuItem // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_separatorMenuItem = SeparatorMenuItem{
MenuItem: MenuItem{
Bin: Bin{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _separatorMenuItem
}
	

	


	// SeparatorToolItem: a SeparatorToolItem is a ToolItem that separates groups of
// other ToolItems. Depending on the theme, a SeparatorToolItem will often look
// like a vertical line on horizontally docked toolbars.
// 
// If the Toolbar child property “expand” is true and the property
// SeparatorToolItem:draw is false, a SeparatorToolItem will act as a “spring”
// that forces other items to the ends of the toolbar.
// 
// Use gtk_separator_tool_item_new() to create a new SeparatorToolItem.
// 
// 
// CSS nodes
// 
// GtkSeparatorToolItem has a single CSS node with name separator.
	type SeparatorToolItem struct {
		ToolItem
		Activatable
		Buildable
		
	}

	// SeparatorToolItemClass is an interface that the SeparatorToolItem class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type SeparatorToolItemClass interface {
		gextras.Objector
		_separatorToolItem()
	}

	func (SeparatorToolItem) _separatorToolItem() {}

	
	func marshalSeparatorToolItem(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapSeparatorToolItem(obj), nil
	}
	

	
	// NewSeparatorToolItem: create a new SeparatorToolItem
	func NewSeparatorToolItem() SeparatorToolItem {
var _cret *C.GtkToolItem // in

_cret = C.gtk_separator_tool_item_new()


var _separatorToolItem SeparatorToolItem // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_separatorToolItem = SeparatorToolItem{
ToolItem: ToolItem{
Bin: Bin{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _separatorToolItem
}
	

	
	// Draw returns whether @item is drawn as a line, or just blank. See
// gtk_separator_tool_item_set_draw().
	func (i SeparatorToolItem) Draw() bool {
var _arg0 *C.GtkSeparatorToolItem // out
var _cret C.gboolean // in

_arg0 = (*C.GtkSeparatorToolItem)(unsafe.Pointer(i.Native()))

_cret = C.gtk_separator_tool_item_get_draw(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetDraw: whether @item is drawn as a vertical line, or just blank. Setting
// this to false along with gtk_tool_item_set_expand() is useful to create an
// item that forces following items to the end of the toolbar.
	func (i SeparatorToolItem) SetDraw(draw bool)  {
var _arg0 *C.GtkSeparatorToolItem // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkSeparatorToolItem)(unsafe.Pointer(i.Native()))
if draw { _arg1 = C.TRUE }

C.gtk_separator_tool_item_set_draw(_arg0, _arg1)
}
	


	// Settings gtkSettings provide a mechanism to share global settings between
// applications.
// 
// On the X window system, this sharing is realized by an XSettings
// (http://www.freedesktop.org/wiki/Specifications/xsettings-spec) manager that
// is usually part of the desktop environment, along with utilities that let the
// user change these settings. In the absence of an Xsettings manager, GTK+
// reads default values for settings from `settings.ini` files in
// `/etc/gtk-3.0`, `$XDG_CONFIG_DIRS/gtk-3.0` and `$XDG_CONFIG_HOME/gtk-3.0`.
// These files must be valid key files (see File), and have a section called
// Settings. Themes can also provide default values for settings by installing a
// `settings.ini` file next to their `gtk.css` file.
// 
// Applications can override system-wide settings by setting the property of the
// GtkSettings object with g_object_set(). This should be restricted to special
// cases though; GtkSettings are not meant as an application configuration
// facility. When doing so, you need to be aware that settings that are specific
// to individual widgets may not be available before the widget type has been
// realized at least once. The following example demonstrates a way to do this:
// 
//      gtk_init (&argc, &argv);
// 
//      // make sure the type is realized
//      g_type_class_unref (g_type_class_ref (GTK_TYPE_IMAGE_MENU_ITEM));
// 
//      g_object_set (gtk_settings_get_default (), "gtk-enable-animations", FALSE, NULL);
// 
// There is one GtkSettings instance per screen. It can be obtained with
// gtk_settings_get_for_screen(), but in many cases, it is more convenient to
// use gtk_widget_get_settings(). gtk_settings_get_default() returns the
// GtkSettings instance for the default screen.
	type Settings struct {
		**externglib.Object
		StyleProvider
		
	}

	// SettingsClass is an interface that the Settings class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type SettingsClass interface {
		gextras.Objector
		_settings()
	}

	func (Settings) _settings() {}

	
	func marshalSettings(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapSettings(obj), nil
	}
	

	

	
	// ResetProperty undoes the effect of calling g_object_set() to install an
// application-specific value for a setting. After this call, the setting will
// again follow the session-wide value for this setting.
	func (s Settings) ResetProperty(name string)  {
var _arg0 *C.GtkSettings // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_settings_reset_property(_arg0, _arg1)
}
	
	
	func (s Settings) SetDoubleProperty(name string, vDouble float64, origin string)  {
var _arg0 *C.GtkSettings // out
var _arg1 *C.gchar // out
var _arg2 C.gdouble // out
var _arg3 *C.gchar // out

_arg0 = (*C.GtkSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.gdouble)(vDouble)
_arg3 = (*C.gchar)(C.CString(origin))
defer C.free(unsafe.Pointer(_arg3))

C.gtk_settings_set_double_property(_arg0, _arg1, _arg2, _arg3)
}
	
	
	func (s Settings) SetLongProperty(name string, vLong int32, origin string)  {
var _arg0 *C.GtkSettings // out
var _arg1 *C.gchar // out
var _arg2 C.glong // out
var _arg3 *C.gchar // out

_arg0 = (*C.GtkSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.glong)(vLong)
_arg3 = (*C.gchar)(C.CString(origin))
defer C.free(unsafe.Pointer(_arg3))

C.gtk_settings_set_long_property(_arg0, _arg1, _arg2, _arg3)
}
	
	
	func (s Settings) SetStringProperty(name string, vString string, origin string)  {
var _arg0 *C.GtkSettings // out
var _arg1 *C.gchar // out
var _arg2 *C.gchar // out
var _arg3 *C.gchar // out

_arg0 = (*C.GtkSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.gchar)(C.CString(vString))
defer C.free(unsafe.Pointer(_arg2))
_arg3 = (*C.gchar)(C.CString(origin))
defer C.free(unsafe.Pointer(_arg3))

C.gtk_settings_set_string_property(_arg0, _arg1, _arg2, _arg3)
}
	


	// ShortcutLabel is a widget that represents a single keyboard shortcut or
// gesture in the user interface.
	type ShortcutLabel struct {
		Box
		Buildable
		Orientable
		
	}

	// ShortcutLabelClass is an interface that the ShortcutLabel class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ShortcutLabelClass interface {
		gextras.Objector
		_shortcutLabel()
	}

	func (ShortcutLabel) _shortcutLabel() {}

	
	func marshalShortcutLabel(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapShortcutLabel(obj), nil
	}
	

	
	// NewShortcutLabel creates a new ShortcutLabel with @accelerator set.
	func NewShortcutLabel(accelerator string) ShortcutLabel {
var _arg1 *C.gchar // out
var _cret *C.GtkWidget // in

_arg1 = (*C.gchar)(C.CString(accelerator))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_shortcut_label_new(_arg1)


var _shortcutLabel ShortcutLabel // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_shortcutLabel = ShortcutLabel{
Box: Box{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _shortcutLabel
}
	

	
	// Accelerator retrieves the current accelerator of @self.
	func (s ShortcutLabel) Accelerator() string {
var _arg0 *C.GtkShortcutLabel // out
var _cret *C.gchar // in

_arg0 = (*C.GtkShortcutLabel)(unsafe.Pointer(s.Native()))

_cret = C.gtk_shortcut_label_get_accelerator(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// DisabledText retrieves the text that is displayed when no accelerator is set.
	func (s ShortcutLabel) DisabledText() string {
var _arg0 *C.GtkShortcutLabel // out
var _cret *C.gchar // in

_arg0 = (*C.GtkShortcutLabel)(unsafe.Pointer(s.Native()))

_cret = C.gtk_shortcut_label_get_disabled_text(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// SetAccelerator sets the accelerator to be displayed by @self.
	func (s ShortcutLabel) SetAccelerator(accelerator string)  {
var _arg0 *C.GtkShortcutLabel // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkShortcutLabel)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(accelerator))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_shortcut_label_set_accelerator(_arg0, _arg1)
}
	
	// SetDisabledText sets the text to be displayed by @self when no accelerator is
// set.
	func (s ShortcutLabel) SetDisabledText(disabledText string)  {
var _arg0 *C.GtkShortcutLabel // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkShortcutLabel)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(disabledText))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_shortcut_label_set_disabled_text(_arg0, _arg1)
}
	


	// ShortcutsGroup: a GtkShortcutsGroup represents a group of related keyboard
// shortcuts or gestures. The group has a title. It may optionally be associated
// with a view of the application, which can be used to show only relevant
// shortcuts depending on the application context.
// 
// This widget is only meant to be used with ShortcutsWindow.
	type ShortcutsGroup struct {
		Box
		Buildable
		Orientable
		
	}

	// ShortcutsGroupClass is an interface that the ShortcutsGroup class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ShortcutsGroupClass interface {
		gextras.Objector
		_shortcutsGroup()
	}

	func (ShortcutsGroup) _shortcutsGroup() {}

	
	func marshalShortcutsGroup(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapShortcutsGroup(obj), nil
	}
	

	

	


	// ShortcutsSection: a GtkShortcutsSection collects all the keyboard shortcuts
// and gestures for a major application mode. If your application needs multiple
// sections, you should give each section a unique ShortcutsSection:section-name
// and a ShortcutsSection:title that can be shown in the section selector of the
// GtkShortcutsWindow.
// 
// The ShortcutsSection:max-height property can be used to influence how the
// groups in the section are distributed over pages and columns.
// 
// This widget is only meant to be used with ShortcutsWindow.
	type ShortcutsSection struct {
		Box
		Buildable
		Orientable
		
	}

	// ShortcutsSectionClass is an interface that the ShortcutsSection class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ShortcutsSectionClass interface {
		gextras.Objector
		_shortcutsSection()
	}

	func (ShortcutsSection) _shortcutsSection() {}

	
	func marshalShortcutsSection(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapShortcutsSection(obj), nil
	}
	

	

	


	// ShortcutsShortcut: a GtkShortcutsShortcut represents a single keyboard
// shortcut or gesture with a short text. This widget is only meant to be used
// with ShortcutsWindow.
	type ShortcutsShortcut struct {
		Box
		Buildable
		Orientable
		
	}

	// ShortcutsShortcutClass is an interface that the ShortcutsShortcut class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ShortcutsShortcutClass interface {
		gextras.Objector
		_shortcutsShortcut()
	}

	func (ShortcutsShortcut) _shortcutsShortcut() {}

	
	func marshalShortcutsShortcut(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapShortcutsShortcut(obj), nil
	}
	

	

	


	// ShortcutsWindow: a GtkShortcutsWindow shows brief information about the
// keyboard shortcuts and gestures of an application. The shortcuts can be
// grouped, and you can have multiple sections in this window, corresponding to
// the major modes of your application.
// 
// Additionally, the shortcuts can be filtered by the current view, to avoid
// showing information that is not relevant in the current application context.
// 
// The recommended way to construct a GtkShortcutsWindow is with GtkBuilder, by
// populating a ShortcutsWindow with one or more ShortcutsSection objects, which
// contain ShortcutsGroups that in turn contain objects of class
// ShortcutsShortcut.
// 
// A simple example:
// 
// ! (gedit-shortcuts.png)
// 
// This example has as single section. As you can see, the shortcut groups are
// arranged in columns, and spread across several pages if there are too many to
// find on a single page.
// 
// The .ui file for this example can be found here
// (https://git.gnome.org/browse/gtk+/tree/demos/gtk-demo/shortcuts-gedit.ui).
// 
// An example with multiple views:
// 
// ! (clocks-shortcuts.png)
// 
// This example shows a ShortcutsWindow that has been configured to show only
// the shortcuts relevant to the "stopwatch" view.
// 
// The .ui file for this example can be found here
// (https://git.gnome.org/browse/gtk+/tree/demos/gtk-demo/shortcuts-clocks.ui).
// 
// An example with multiple sections:
// 
// ! (builder-shortcuts.png)
// 
// This example shows a ShortcutsWindow with two sections, "Editor Shortcuts"
// and "Terminal Shortcuts".
// 
// The .ui file for this example can be found here
// (https://git.gnome.org/browse/gtk+/tree/demos/gtk-demo/shortcuts-builder.ui).
	type ShortcutsWindow struct {
		Window
		Buildable
		
	}

	// ShortcutsWindowClass is an interface that the ShortcutsWindow class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ShortcutsWindowClass interface {
		gextras.Objector
		_shortcutsWindow()
	}

	func (ShortcutsWindow) _shortcutsWindow() {}

	
	func marshalShortcutsWindow(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapShortcutsWindow(obj), nil
	}
	

	

	


	// SizeGroup provides a mechanism for grouping a number of widgets together so
// they all request the same amount of space. This is typically useful when you
// want a column of widgets to have the same size, but you can’t use a Grid
// widget.
// 
// In detail, the size requested for each widget in a SizeGroup is the maximum
// of the sizes that would have been requested for each widget in the size group
// if they were not in the size group. The mode of the size group (see
// gtk_size_group_set_mode()) determines whether this applies to the horizontal
// size, the vertical size, or both sizes.
// 
// Note that size groups only affect the amount of space requested, not the size
// that the widgets finally receive. If you want the widgets in a SizeGroup to
// actually be the same size, you need to pack them in such a way that they get
// the size they request and not more. For example, if you are packing your
// widgets into a table, you would not include the GTK_FILL flag.
// 
// SizeGroup objects are referenced by each widget in the size group, so once
// you have added all widgets to a SizeGroup, you can drop the initial reference
// to the size group with g_object_unref(). If the widgets in the size group are
// subsequently destroyed, then they will be removed from the size group and
// drop their references on the size group; when all widgets have been removed,
// the size group will be freed.
// 
// Widgets can be part of multiple size groups; GTK+ will compute the horizontal
// size of a widget from the horizontal requisition of all widgets that can be
// reached from the widget by a chain of size groups of type
// GTK_SIZE_GROUP_HORIZONTAL or GTK_SIZE_GROUP_BOTH, and the vertical size from
// the vertical requisition of all widgets that can be reached from the widget
// by a chain of size groups of type GTK_SIZE_GROUP_VERTICAL or
// GTK_SIZE_GROUP_BOTH.
// 
// Note that only non-contextual sizes of every widget are ever consulted by
// size groups (since size groups have no knowledge of what size a widget will
// be allocated in one dimension, it cannot derive how much height a widget will
// receive for a given width). When grouping widgets that trade height for width
// in mode GTK_SIZE_GROUP_VERTICAL or GTK_SIZE_GROUP_BOTH: the height for the
// minimum width will be the requested height for all widgets in the group. The
// same is of course true when horizontally grouping width for height widgets.
// 
// Widgets that trade height-for-width should set a reasonably large minimum
// width by way of Label:width-chars for instance. Widgets with static sizes as
// well as widgets that grow (such as ellipsizing text) need no such
// considerations.
// 
// 
// GtkSizeGroup as GtkBuildable
// 
// Size groups can be specified in a UI definition by placing an <object>
// element with `class="GtkSizeGroup"` somewhere in the UI definition. The
// widgets that belong to the size group are specified by a <widgets> element
// that may contain multiple <widget> elements, one for each member of the size
// group. The ”name” attribute gives the id of the widget.
// 
// An example of a UI definition fragment with GtkSizeGroup:
// 
//    <object class="GtkSizeGroup">
//      <property name="mode">GTK_SIZE_GROUP_HORIZONTAL</property>
//      <widgets>
//        <widget name="radio1"/>
//        <widget name="radio2"/>
//      </widgets>
//    </object>
	type SizeGroup struct {
		**externglib.Object
		Buildable
		
	}

	// SizeGroupClass is an interface that the SizeGroup class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type SizeGroupClass interface {
		gextras.Objector
		_sizeGroup()
	}

	func (SizeGroup) _sizeGroup() {}

	
	func marshalSizeGroup(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapSizeGroup(obj), nil
	}
	

	
	// NewSizeGroup: create a new SizeGroup.
	func NewSizeGroup(mode SizeGroupMode) SizeGroup {
var _arg1 C.GtkSizeGroupMode // out
var _cret *C.GtkSizeGroup // in

_arg1 = (C.GtkSizeGroupMode)(mode)

_cret = C.gtk_size_group_new(_arg1)


var _sizeGroup SizeGroup // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_sizeGroup = SizeGroup{
Object: &externglib.Object{externglib.ToGObject(obj)},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _sizeGroup
}
	

	
	// AddWidget adds a widget to a SizeGroup. In the future, the requisition of the
// widget will be determined as the maximum of its requisition and the
// requisition of the other widgets in the size group. Whether this applies
// horizontally, vertically, or in both directions depends on the mode of the
// size group. See gtk_size_group_set_mode().
// 
// When the widget is destroyed or no longer referenced elsewhere, it will be
// removed from the size group.
	func (s SizeGroup) AddWidget(widget WidgetClass)  {
var _arg0 *C.GtkSizeGroup // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkSizeGroup)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

C.gtk_size_group_add_widget(_arg0, _arg1)
}
	
	// IgnoreHidden returns if invisible widgets are ignored when calculating the
// size.
	func (s SizeGroup) IgnoreHidden() bool {
var _arg0 *C.GtkSizeGroup // out
var _cret C.gboolean // in

_arg0 = (*C.GtkSizeGroup)(unsafe.Pointer(s.Native()))

_cret = C.gtk_size_group_get_ignore_hidden(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Mode gets the current mode of the size group. See gtk_size_group_set_mode().
	func (s SizeGroup) Mode() SizeGroupMode {
var _arg0 *C.GtkSizeGroup // out
var _cret C.GtkSizeGroupMode // in

_arg0 = (*C.GtkSizeGroup)(unsafe.Pointer(s.Native()))

_cret = C.gtk_size_group_get_mode(_arg0)


var _sizeGroupMode SizeGroupMode // out

_sizeGroupMode = SizeGroupMode(_cret)

return _sizeGroupMode
}
	
	// RemoveWidget removes a widget from a SizeGroup.
	func (s SizeGroup) RemoveWidget(widget WidgetClass)  {
var _arg0 *C.GtkSizeGroup // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkSizeGroup)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

C.gtk_size_group_remove_widget(_arg0, _arg1)
}
	
	// SetIgnoreHidden sets whether unmapped widgets should be ignored when
// calculating the size.
	func (s SizeGroup) SetIgnoreHidden(ignoreHidden bool)  {
var _arg0 *C.GtkSizeGroup // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkSizeGroup)(unsafe.Pointer(s.Native()))
if ignoreHidden { _arg1 = C.TRUE }

C.gtk_size_group_set_ignore_hidden(_arg0, _arg1)
}
	
	// SetMode sets the SizeGroupMode of the size group. The mode of the size group
// determines whether the widgets in the size group should all have the same
// horizontal requisition (GTK_SIZE_GROUP_HORIZONTAL) all have the same vertical
// requisition (GTK_SIZE_GROUP_VERTICAL), or should all have the same
// requisition in both directions (GTK_SIZE_GROUP_BOTH).
	func (s SizeGroup) SetMode(mode SizeGroupMode)  {
var _arg0 *C.GtkSizeGroup // out
var _arg1 C.GtkSizeGroupMode // out

_arg0 = (*C.GtkSizeGroup)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkSizeGroupMode)(mode)

C.gtk_size_group_set_mode(_arg0, _arg1)
}
	


	// Socket: together with Plug, Socket provides the ability to embed widgets from
// one process into another process in a fashion that is transparent to the
// user. One process creates a Socket widget and passes that widget’s window ID
// to the other process, which then creates a Plug with that window ID. Any
// widgets contained in the Plug then will appear inside the first application’s
// window.
// 
// The socket’s window ID is obtained by using gtk_socket_get_id(). Before using
// this function, the socket must have been realized, and for hence, have been
// added to its parent.
// 
// Obtaining the window ID of a socket.
// 
//    GtkWidget *socket = gtk_socket_new ();
//    gtk_widget_show (socket);
//    gtk_container_add (GTK_CONTAINER (parent), socket);
// 
//    // The following call is only necessary if one of
//    // the ancestors of the socket is not yet visible.
//    gtk_widget_realize (socket);
//    g_print ("The ID of the sockets window is %#x\n",
//             gtk_socket_get_id (socket));
// 
// Note that if you pass the window ID of the socket to another process that
// will create a plug in the socket, you must make sure that the socket widget
// is not destroyed until that plug is created. Violating this rule will cause
// unpredictable consequences, the most likely consequence being that the plug
// will appear as a separate toplevel window. You can check if the plug has been
// created by using gtk_socket_get_plug_window(). If it returns a non-nil value,
// then the plug has been successfully created inside of the socket.
// 
// When GTK+ is notified that the embedded window has been destroyed, then it
// will destroy the socket as well. You should always, therefore, be prepared
// for your sockets to be destroyed at any time when the main event loop is
// running. To prevent this from happening, you can connect to the
// Socket::plug-removed signal.
// 
// The communication between a Socket and a Plug follows the XEmbed Protocol
// (http://www.freedesktop.org/Standards/xembed-spec). This protocol has also
// been implemented in other toolkits, e.g. Qt, allowing the same level of
// integration when embedding a Qt widget in GTK or vice versa.
// 
// The Plug and Socket widgets are only available when GTK+ is compiled for the
// X11 platform and GDK_WINDOWING_X11 is defined. They can only be used on a
// X11Display. To use Plug and Socket, you need to include the `gtk/gtkx.h`
// header.
	type Socket struct {
		Container
		Buildable
		
	}

	// SocketClass is an interface that the Socket class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type SocketClass interface {
		gextras.Objector
		_socket()
	}

	func (Socket) _socket() {}

	
	func marshalSocket(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapSocket(obj), nil
	}
	

	
	// NewSocket: create a new empty Socket.
	func NewSocket() Socket {
var _cret *C.GtkWidget // in

_cret = C.gtk_socket_new()


var _socket Socket // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_socket = Socket{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _socket
}
	

	
	// PlugWindow retrieves the window of the plug. Use this to check if the plug
// has been created inside of the socket.
	func (s Socket) PlugWindow() gdk.Window {
var _arg0 *C.GtkSocket // out
var _cret *C.GdkWindow // in

_arg0 = (*C.GtkSocket)(unsafe.Pointer(s.Native()))

_cret = C.gtk_socket_get_plug_window(_arg0)


var _window gdk.Window // out

_window = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Window)

return _window
}
	


	// SpinButton: a SpinButton is an ideal way to allow the user to set the value
// of some attribute. Rather than having to directly type a number into a Entry,
// GtkSpinButton allows the user to click on one of two arrows to increment or
// decrement the displayed value. A value can still be typed in, with the bonus
// that it can be checked to ensure it is in a given range.
// 
// The main properties of a GtkSpinButton are through an adjustment. See the
// Adjustment section for more details about an adjustment's properties. Note
// that GtkSpinButton will by default make its entry large enough to accomodate
// the lower and upper bounds of the adjustment, which can lead to surprising
// results. Best practice is to set both the Entry:width-chars and
// Entry:max-width-chars poperties to the desired number of characters to
// display in the entry.
// 
// CSS nodes
// 
//    // Provides a function to retrieve a floating point value from a
//    // GtkSpinButton, and creates a high precision spin button.
// 
//    gfloat
//    grab_float_value (GtkSpinButton *button,
//                      gpointer       user_data)
//    {
//      return gtk_spin_button_get_value (button);
//    }
// 
//    void
//    create_floating_spin_button (void)
//    {
//      GtkWidget *window, *button;
//      GtkAdjustment *adjustment;
// 
//      adjustment = gtk_adjustment_new (2.500, 0.0, 5.0, 0.001, 0.1, 0.0);
// 
//      window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
//      gtk_container_set_border_width (GTK_CONTAINER (window), 5);
// 
//      // creates the spinbutton, with three decimal places
//      button = gtk_spin_button_new (adjustment, 0.001, 3);
//      gtk_container_add (GTK_CONTAINER (window), button);
// 
//      gtk_widget_show_all (window);
//    }
	type SpinButton struct {
		Entry
		Buildable
		CellEditable
		Editable
		Orientable
		
	}

	// SpinButtonClass is an interface that the SpinButton class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type SpinButtonClass interface {
		gextras.Objector
		_spinButton()
	}

	func (SpinButton) _spinButton() {}

	
	func marshalSpinButton(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapSpinButton(obj), nil
	}
	

	
	// NewSpinButton creates a new SpinButton.
	func NewSpinButton(adjustment AdjustmentClass, climbRate float64, digits uint) SpinButton {
var _arg1 *C.GtkAdjustment // out
var _arg2 C.gdouble // out
var _arg3 C.guint // out
var _cret *C.GtkWidget // in

_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(adjustment.Native()))
_arg2 = (C.gdouble)(climbRate)
_arg3 = (C.guint)(digits)

_cret = C.gtk_spin_button_new(_arg1, _arg2, _arg3)


var _spinButton SpinButton // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_spinButton = SpinButton{
Entry: Entry{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
CellEditable: CellEditable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Editable: Editable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
CellEditable: CellEditable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Editable: Editable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _spinButton
}
	
	// NewSpinButtonWithRange: this is a convenience constructor that allows
// creation of a numeric SpinButton without manually creating an adjustment. The
// value is initially set to the minimum value and a page increment of 10 *
// @step is the default. The precision of the spin button is equivalent to the
// precision of @step.
// 
// Note that the way in which the precision is derived works best if @step is a
// power of ten. If the resulting precision is not suitable for your needs, use
// gtk_spin_button_set_digits() to correct it.
	func NewSpinButtonWithRange(min float64, max float64, step float64) SpinButton {
var _arg1 C.gdouble // out
var _arg2 C.gdouble // out
var _arg3 C.gdouble // out
var _cret *C.GtkWidget // in

_arg1 = (C.gdouble)(min)
_arg2 = (C.gdouble)(max)
_arg3 = (C.gdouble)(step)

_cret = C.gtk_spin_button_new_with_range(_arg1, _arg2, _arg3)


var _spinButton SpinButton // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_spinButton = SpinButton{
Entry: Entry{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
CellEditable: CellEditable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Editable: Editable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
CellEditable: CellEditable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Editable: Editable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _spinButton
}
	

	
	// Configure changes the properties of an existing spin button. The adjustment,
// climb rate, and number of decimal places are updated accordingly.
	func (s SpinButton) Configure(adjustment AdjustmentClass, climbRate float64, digits uint)  {
var _arg0 *C.GtkSpinButton // out
var _arg1 *C.GtkAdjustment // out
var _arg2 C.gdouble // out
var _arg3 C.guint // out

_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(adjustment.Native()))
_arg2 = (C.gdouble)(climbRate)
_arg3 = (C.guint)(digits)

C.gtk_spin_button_configure(_arg0, _arg1, _arg2, _arg3)
}
	
	// Adjustment: get the adjustment associated with a SpinButton
	func (s SpinButton) Adjustment() Adjustment {
var _arg0 *C.GtkSpinButton // out
var _cret *C.GtkAdjustment // in

_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))

_cret = C.gtk_spin_button_get_adjustment(_arg0)


var _adjustment Adjustment // out

_adjustment = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Adjustment)

return _adjustment
}
	
	// Digits fetches the precision of @spin_button. See
// gtk_spin_button_set_digits().
	func (s SpinButton) Digits() uint {
var _arg0 *C.GtkSpinButton // out
var _cret C.guint // in

_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))

_cret = C.gtk_spin_button_get_digits(_arg0)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// Increments gets the current step and page the increments used by
// @spin_button. See gtk_spin_button_set_increments().
	func (s SpinButton) Increments() (step float64, page float64) {
var _arg0 *C.GtkSpinButton // out
var _arg1 C.gdouble // in
var _arg2 C.gdouble // in

_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))

C.gtk_spin_button_get_increments(_arg0, &_arg1, &_arg2)

var _step float64 // out
var _page float64 // out

_step = (float64)(_arg1)
_page = (float64)(_arg2)

return _step, _page
}
	
	// Numeric returns whether non-numeric text can be typed into the spin button.
// See gtk_spin_button_set_numeric().
	func (s SpinButton) Numeric() bool {
var _arg0 *C.GtkSpinButton // out
var _cret C.gboolean // in

_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))

_cret = C.gtk_spin_button_get_numeric(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Range gets the range allowed for @spin_button. See
// gtk_spin_button_set_range().
	func (s SpinButton) Range() (min float64, max float64) {
var _arg0 *C.GtkSpinButton // out
var _arg1 C.gdouble // in
var _arg2 C.gdouble // in

_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))

C.gtk_spin_button_get_range(_arg0, &_arg1, &_arg2)

var _min float64 // out
var _max float64 // out

_min = (float64)(_arg1)
_max = (float64)(_arg2)

return _min, _max
}
	
	// SnapToTicks returns whether the values are corrected to the nearest step. See
// gtk_spin_button_set_snap_to_ticks().
	func (s SpinButton) SnapToTicks() bool {
var _arg0 *C.GtkSpinButton // out
var _cret C.gboolean // in

_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))

_cret = C.gtk_spin_button_get_snap_to_ticks(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// UpdatePolicy gets the update behavior of a spin button. See
// gtk_spin_button_set_update_policy().
	func (s SpinButton) UpdatePolicy() SpinButtonUpdatePolicy {
var _arg0 *C.GtkSpinButton // out
var _cret C.GtkSpinButtonUpdatePolicy // in

_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))

_cret = C.gtk_spin_button_get_update_policy(_arg0)


var _spinButtonUpdatePolicy SpinButtonUpdatePolicy // out

_spinButtonUpdatePolicy = SpinButtonUpdatePolicy(_cret)

return _spinButtonUpdatePolicy
}
	
	// Value: get the value in the @spin_button.
	func (s SpinButton) Value() float64 {
var _arg0 *C.GtkSpinButton // out
var _cret C.gdouble // in

_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))

_cret = C.gtk_spin_button_get_value(_arg0)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// ValueAsInt: get the value @spin_button represented as an integer.
	func (s SpinButton) ValueAsInt() int {
var _arg0 *C.GtkSpinButton // out
var _cret C.gint // in

_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))

_cret = C.gtk_spin_button_get_value_as_int(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Wrap returns whether the spin button’s value wraps around to the opposite
// limit when the upper or lower limit of the range is exceeded. See
// gtk_spin_button_set_wrap().
	func (s SpinButton) Wrap() bool {
var _arg0 *C.GtkSpinButton // out
var _cret C.gboolean // in

_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))

_cret = C.gtk_spin_button_get_wrap(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetAdjustment replaces the Adjustment associated with @spin_button.
	func (s SpinButton) SetAdjustment(adjustment AdjustmentClass)  {
var _arg0 *C.GtkSpinButton // out
var _arg1 *C.GtkAdjustment // out

_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(adjustment.Native()))

C.gtk_spin_button_set_adjustment(_arg0, _arg1)
}
	
	// SetDigits: set the precision to be displayed by @spin_button. Up to 20 digit
// precision is allowed.
	func (s SpinButton) SetDigits(digits uint)  {
var _arg0 *C.GtkSpinButton // out
var _arg1 C.guint // out

_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))
_arg1 = (C.guint)(digits)

C.gtk_spin_button_set_digits(_arg0, _arg1)
}
	
	// SetIncrements sets the step and page increments for spin_button. This affects
// how quickly the value changes when the spin button’s arrows are activated.
	func (s SpinButton) SetIncrements(step float64, page float64)  {
var _arg0 *C.GtkSpinButton // out
var _arg1 C.gdouble // out
var _arg2 C.gdouble // out

_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))
_arg1 = (C.gdouble)(step)
_arg2 = (C.gdouble)(page)

C.gtk_spin_button_set_increments(_arg0, _arg1, _arg2)
}
	
	// SetNumeric sets the flag that determines if non-numeric text can be typed
// into the spin button.
	func (s SpinButton) SetNumeric(numeric bool)  {
var _arg0 *C.GtkSpinButton // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))
if numeric { _arg1 = C.TRUE }

C.gtk_spin_button_set_numeric(_arg0, _arg1)
}
	
	// SetRange sets the minimum and maximum allowable values for @spin_button.
// 
// If the current value is outside this range, it will be adjusted to fit within
// the range, otherwise it will remain unchanged.
	func (s SpinButton) SetRange(min float64, max float64)  {
var _arg0 *C.GtkSpinButton // out
var _arg1 C.gdouble // out
var _arg2 C.gdouble // out

_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))
_arg1 = (C.gdouble)(min)
_arg2 = (C.gdouble)(max)

C.gtk_spin_button_set_range(_arg0, _arg1, _arg2)
}
	
	// SetSnapToTicks sets the policy as to whether values are corrected to the
// nearest step increment when a spin button is activated after providing an
// invalid value.
	func (s SpinButton) SetSnapToTicks(snapToTicks bool)  {
var _arg0 *C.GtkSpinButton // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))
if snapToTicks { _arg1 = C.TRUE }

C.gtk_spin_button_set_snap_to_ticks(_arg0, _arg1)
}
	
	// SetUpdatePolicy sets the update behavior of a spin button. This determines
// whether the spin button is always updated or only when a valid value is set.
	func (s SpinButton) SetUpdatePolicy(policy SpinButtonUpdatePolicy)  {
var _arg0 *C.GtkSpinButton // out
var _arg1 C.GtkSpinButtonUpdatePolicy // out

_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkSpinButtonUpdatePolicy)(policy)

C.gtk_spin_button_set_update_policy(_arg0, _arg1)
}
	
	// SetValue sets the value of @spin_button.
	func (s SpinButton) SetValue(value float64)  {
var _arg0 *C.GtkSpinButton // out
var _arg1 C.gdouble // out

_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))
_arg1 = (C.gdouble)(value)

C.gtk_spin_button_set_value(_arg0, _arg1)
}
	
	// SetWrap sets the flag that determines if a spin button value wraps around to
// the opposite limit when the upper or lower limit of the range is exceeded.
	func (s SpinButton) SetWrap(wrap bool)  {
var _arg0 *C.GtkSpinButton // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))
if wrap { _arg1 = C.TRUE }

C.gtk_spin_button_set_wrap(_arg0, _arg1)
}
	
	// Spin: increment or decrement a spin button’s value in a specified direction
// by a specified amount.
	func (s SpinButton) Spin(direction SpinType, increment float64)  {
var _arg0 *C.GtkSpinButton // out
var _arg1 C.GtkSpinType // out
var _arg2 C.gdouble // out

_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkSpinType)(direction)
_arg2 = (C.gdouble)(increment)

C.gtk_spin_button_spin(_arg0, _arg1, _arg2)
}
	
	// Update: manually force an update of the spin button.
	func (s SpinButton) Update()  {
var _arg0 *C.GtkSpinButton // out

_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))

C.gtk_spin_button_update(_arg0)
}
	


	// Spinner: a GtkSpinner widget displays an icon-size spinning animation. It is
// often used as an alternative to a ProgressBar for displaying indefinite
// activity, instead of actual progress.
// 
// To start the animation, use gtk_spinner_start(), to stop it use
// gtk_spinner_stop().
// 
// 
// CSS nodes
// 
// GtkSpinner has a single CSS node with the name spinner. When the animation is
// active, the :checked pseudoclass is added to this node.
	type Spinner struct {
		Widget
		Buildable
		
	}

	// SpinnerClass is an interface that the Spinner class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type SpinnerClass interface {
		gextras.Objector
		_spinner()
	}

	func (Spinner) _spinner() {}

	
	func marshalSpinner(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapSpinner(obj), nil
	}
	

	
	// NewSpinner returns a new spinner widget. Not yet started.
	func NewSpinner() Spinner {
var _cret *C.GtkWidget // in

_cret = C.gtk_spinner_new()


var _spinner Spinner // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_spinner = Spinner{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _spinner
}
	

	
	// Start starts the animation of the spinner.
	func (s Spinner) Start()  {
var _arg0 *C.GtkSpinner // out

_arg0 = (*C.GtkSpinner)(unsafe.Pointer(s.Native()))

C.gtk_spinner_start(_arg0)
}
	
	// Stop stops the animation of the spinner.
	func (s Spinner) Stop()  {
var _arg0 *C.GtkSpinner // out

_arg0 = (*C.GtkSpinner)(unsafe.Pointer(s.Native()))

C.gtk_spinner_stop(_arg0)
}
	


	// Stack: the GtkStack widget is a container which only shows one of its
// children at a time. In contrast to GtkNotebook, GtkStack does not provide a
// means for users to change the visible child. Instead, the StackSwitcher
// widget can be used with GtkStack to provide this functionality.
// 
// Transitions between pages can be animated as slides or fades. This can be
// controlled with gtk_stack_set_transition_type(). These animations respect the
// Settings:gtk-enable-animations setting.
// 
// The GtkStack widget was added in GTK+ 3.10.
// 
// 
// CSS nodes
// 
// GtkStack has a single CSS node named stack.
	type Stack struct {
		Container
		Buildable
		
	}

	// StackClass is an interface that the Stack class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type StackClass interface {
		gextras.Objector
		_stack()
	}

	func (Stack) _stack() {}

	
	func marshalStack(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapStack(obj), nil
	}
	

	
	// NewStack creates a new Stack container.
	func NewStack() Stack {
var _cret *C.GtkWidget // in

_cret = C.gtk_stack_new()


var _stack Stack // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_stack = Stack{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _stack
}
	

	
	// AddNamed adds a child to @stack. The child is identified by the @name.
	func (s Stack) AddNamed(child WidgetClass, name string)  {
var _arg0 *C.GtkStack // out
var _arg1 *C.GtkWidget // out
var _arg2 *C.gchar // out

_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
_arg2 = (*C.gchar)(C.CString(name))
defer C.free(unsafe.Pointer(_arg2))

C.gtk_stack_add_named(_arg0, _arg1, _arg2)
}
	
	// AddTitled adds a child to @stack. The child is identified by the @name. The
// @title will be used by StackSwitcher to represent @child in a tab bar, so it
// should be short.
	func (s Stack) AddTitled(child WidgetClass, name string, title string)  {
var _arg0 *C.GtkStack // out
var _arg1 *C.GtkWidget // out
var _arg2 *C.gchar // out
var _arg3 *C.gchar // out

_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
_arg2 = (*C.gchar)(C.CString(name))
defer C.free(unsafe.Pointer(_arg2))
_arg3 = (*C.gchar)(C.CString(title))
defer C.free(unsafe.Pointer(_arg3))

C.gtk_stack_add_titled(_arg0, _arg1, _arg2, _arg3)
}
	
	// ChildByName finds the child of the Stack with the name given as the argument.
// Returns nil if there is no child with this name.
	func (s Stack) ChildByName(name string) Widget {
var _arg0 *C.GtkStack // out
var _arg1 *C.gchar // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_stack_get_child_by_name(_arg0, _arg1)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// Hhomogeneous gets whether @stack is horizontally homogeneous. See
// gtk_stack_set_hhomogeneous().
	func (s Stack) Hhomogeneous() bool {
var _arg0 *C.GtkStack // out
var _cret C.gboolean // in

_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))

_cret = C.gtk_stack_get_hhomogeneous(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Homogeneous gets whether @stack is homogeneous. See
// gtk_stack_set_homogeneous().
	func (s Stack) Homogeneous() bool {
var _arg0 *C.GtkStack // out
var _cret C.gboolean // in

_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))

_cret = C.gtk_stack_get_homogeneous(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// InterpolateSize returns wether the Stack is set up to interpolate between the
// sizes of children on page switch.
	func (s Stack) InterpolateSize() bool {
var _arg0 *C.GtkStack // out
var _cret C.gboolean // in

_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))

_cret = C.gtk_stack_get_interpolate_size(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// TransitionDuration returns the amount of time (in milliseconds) that
// transitions between pages in @stack will take.
	func (s Stack) TransitionDuration() uint {
var _arg0 *C.GtkStack // out
var _cret C.guint // in

_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))

_cret = C.gtk_stack_get_transition_duration(_arg0)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// TransitionRunning returns whether the @stack is currently in a transition
// from one page to another.
	func (s Stack) TransitionRunning() bool {
var _arg0 *C.GtkStack // out
var _cret C.gboolean // in

_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))

_cret = C.gtk_stack_get_transition_running(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// TransitionType gets the type of animation that will be used for transitions
// between pages in @stack.
	func (s Stack) TransitionType() StackTransitionType {
var _arg0 *C.GtkStack // out
var _cret C.GtkStackTransitionType // in

_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))

_cret = C.gtk_stack_get_transition_type(_arg0)


var _stackTransitionType StackTransitionType // out

_stackTransitionType = StackTransitionType(_cret)

return _stackTransitionType
}
	
	// Vhomogeneous gets whether @stack is vertically homogeneous. See
// gtk_stack_set_vhomogeneous().
	func (s Stack) Vhomogeneous() bool {
var _arg0 *C.GtkStack // out
var _cret C.gboolean // in

_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))

_cret = C.gtk_stack_get_vhomogeneous(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// VisibleChild gets the currently visible child of @stack, or nil if there are
// no visible children.
	func (s Stack) VisibleChild() Widget {
var _arg0 *C.GtkStack // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))

_cret = C.gtk_stack_get_visible_child(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// VisibleChildName returns the name of the currently visible child of @stack,
// or nil if there is no visible child.
	func (s Stack) VisibleChildName() string {
var _arg0 *C.GtkStack // out
var _cret *C.gchar // in

_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))

_cret = C.gtk_stack_get_visible_child_name(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// SetHhomogeneous sets the Stack to be horizontally homogeneous or not. If it
// is homogeneous, the Stack will request the same width for all its children.
// If it isn't, the stack may change width when a different child becomes
// visible.
	func (s Stack) SetHhomogeneous(hhomogeneous bool)  {
var _arg0 *C.GtkStack // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))
if hhomogeneous { _arg1 = C.TRUE }

C.gtk_stack_set_hhomogeneous(_arg0, _arg1)
}
	
	// SetHomogeneous sets the Stack to be homogeneous or not. If it is homogeneous,
// the Stack will request the same size for all its children. If it isn't, the
// stack may change size when a different child becomes visible.
// 
// Since 3.16, homogeneity can be controlled separately for horizontal and
// vertical size, with the Stack:hhomogeneous and Stack:vhomogeneous.
	func (s Stack) SetHomogeneous(homogeneous bool)  {
var _arg0 *C.GtkStack // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))
if homogeneous { _arg1 = C.TRUE }

C.gtk_stack_set_homogeneous(_arg0, _arg1)
}
	
	// SetInterpolateSize sets whether or not @stack will interpolate its size when
// changing the visible child. If the Stack:interpolate-size property is set to
// true, @stack will interpolate its size between the current one and the one
// it'll take after changing the visible child, according to the set transition
// duration.
	func (s Stack) SetInterpolateSize(interpolateSize bool)  {
var _arg0 *C.GtkStack // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))
if interpolateSize { _arg1 = C.TRUE }

C.gtk_stack_set_interpolate_size(_arg0, _arg1)
}
	
	// SetTransitionDuration sets the duration that transitions between pages in
// @stack will take.
	func (s Stack) SetTransitionDuration(duration uint)  {
var _arg0 *C.GtkStack // out
var _arg1 C.guint // out

_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))
_arg1 = (C.guint)(duration)

C.gtk_stack_set_transition_duration(_arg0, _arg1)
}
	
	// SetTransitionType sets the type of animation that will be used for
// transitions between pages in @stack. Available types include various kinds of
// fades and slides.
// 
// The transition type can be changed without problems at runtime, so it is
// possible to change the animation based on the page that is about to become
// current.
	func (s Stack) SetTransitionType(transition StackTransitionType)  {
var _arg0 *C.GtkStack // out
var _arg1 C.GtkStackTransitionType // out

_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkStackTransitionType)(transition)

C.gtk_stack_set_transition_type(_arg0, _arg1)
}
	
	// SetVhomogeneous sets the Stack to be vertically homogeneous or not. If it is
// homogeneous, the Stack will request the same height for all its children. If
// it isn't, the stack may change height when a different child becomes visible.
	func (s Stack) SetVhomogeneous(vhomogeneous bool)  {
var _arg0 *C.GtkStack // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))
if vhomogeneous { _arg1 = C.TRUE }

C.gtk_stack_set_vhomogeneous(_arg0, _arg1)
}
	
	// SetVisibleChild makes @child the visible child of @stack.
// 
// If @child is different from the currently visible child, the transition
// between the two will be animated with the current transition type of @stack.
// 
// Note that the @child widget has to be visible itself (see gtk_widget_show())
// in order to become the visible child of @stack.
	func (s Stack) SetVisibleChild(child WidgetClass)  {
var _arg0 *C.GtkStack // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

C.gtk_stack_set_visible_child(_arg0, _arg1)
}
	
	// SetVisibleChildFull makes the child with the given name visible.
// 
// Note that the child widget has to be visible itself (see gtk_widget_show())
// in order to become the visible child of @stack.
	func (s Stack) SetVisibleChildFull(name string, transition StackTransitionType)  {
var _arg0 *C.GtkStack // out
var _arg1 *C.gchar // out
var _arg2 C.GtkStackTransitionType // out

_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.GtkStackTransitionType)(transition)

C.gtk_stack_set_visible_child_full(_arg0, _arg1, _arg2)
}
	
	// SetVisibleChildName makes the child with the given name visible.
// 
// If @child is different from the currently visible child, the transition
// between the two will be animated with the current transition type of @stack.
// 
// Note that the child widget has to be visible itself (see gtk_widget_show())
// in order to become the visible child of @stack.
	func (s Stack) SetVisibleChildName(name string)  {
var _arg0 *C.GtkStack // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_stack_set_visible_child_name(_arg0, _arg1)
}
	


	// StackSidebar: a GtkStackSidebar enables you to quickly and easily provide a
// consistent "sidebar" object for your user interface.
// 
// In order to use a GtkStackSidebar, you simply use a GtkStack to organize your
// UI flow, and add the sidebar to your sidebar area. You can use
// gtk_stack_sidebar_set_stack() to connect the StackSidebar to the Stack.
// 
// 
// CSS nodes
// 
// GtkStackSidebar has a single CSS node with name stacksidebar and style class
// .sidebar.
// 
// When circumstances require it, GtkStackSidebar adds the .needs-attention
// style class to the widgets representing the stack pages.
	type StackSidebar struct {
		Bin
		Buildable
		
	}

	// StackSidebarClass is an interface that the StackSidebar class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type StackSidebarClass interface {
		gextras.Objector
		_stackSidebar()
	}

	func (StackSidebar) _stackSidebar() {}

	
	func marshalStackSidebar(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapStackSidebar(obj), nil
	}
	

	
	// NewStackSidebar creates a new sidebar.
	func NewStackSidebar() StackSidebar {
var _cret *C.GtkWidget // in

_cret = C.gtk_stack_sidebar_new()


var _stackSidebar StackSidebar // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_stackSidebar = StackSidebar{
Bin: Bin{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _stackSidebar
}
	

	
	// Stack retrieves the stack. See gtk_stack_sidebar_set_stack().
	func (s StackSidebar) Stack() Stack {
var _arg0 *C.GtkStackSidebar // out
var _cret *C.GtkStack // in

_arg0 = (*C.GtkStackSidebar)(unsafe.Pointer(s.Native()))

_cret = C.gtk_stack_sidebar_get_stack(_arg0)


var _stack Stack // out

_stack = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Stack)

return _stack
}
	
	// SetStack: set the Stack associated with this StackSidebar.
// 
// The sidebar widget will automatically update according to the order (packing)
// and items within the given Stack.
	func (s StackSidebar) SetStack(stack StackClass)  {
var _arg0 *C.GtkStackSidebar // out
var _arg1 *C.GtkStack // out

_arg0 = (*C.GtkStackSidebar)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkStack)(unsafe.Pointer(stack.Native()))

C.gtk_stack_sidebar_set_stack(_arg0, _arg1)
}
	


	// StackSwitcher: the GtkStackSwitcher widget acts as a controller for a Stack;
// it shows a row of buttons to switch between the various pages of the
// associated stack widget.
// 
// All the content for the buttons comes from the child properties of the Stack;
// the button visibility in a StackSwitcher widget is controlled by the
// visibility of the child in the Stack.
// 
// It is possible to associate multiple StackSwitcher widgets with the same
// Stack widget.
// 
// The GtkStackSwitcher widget was added in 3.10.
// 
// 
// CSS nodes
// 
// GtkStackSwitcher has a single CSS node named stackswitcher and style class
// .stack-switcher.
// 
// When circumstances require it, GtkStackSwitcher adds the .needs-attention
// style class to the widgets representing the stack pages.
	type StackSwitcher struct {
		Box
		Buildable
		Orientable
		
	}

	// StackSwitcherClass is an interface that the StackSwitcher class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type StackSwitcherClass interface {
		gextras.Objector
		_stackSwitcher()
	}

	func (StackSwitcher) _stackSwitcher() {}

	
	func marshalStackSwitcher(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapStackSwitcher(obj), nil
	}
	

	
	// NewStackSwitcher: create a new StackSwitcher.
	func NewStackSwitcher() StackSwitcher {
var _cret *C.GtkWidget // in

_cret = C.gtk_stack_switcher_new()


var _stackSwitcher StackSwitcher // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_stackSwitcher = StackSwitcher{
Box: Box{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _stackSwitcher
}
	

	
	// Stack retrieves the stack. See gtk_stack_switcher_set_stack().
	func (s StackSwitcher) Stack() Stack {
var _arg0 *C.GtkStackSwitcher // out
var _cret *C.GtkStack // in

_arg0 = (*C.GtkStackSwitcher)(unsafe.Pointer(s.Native()))

_cret = C.gtk_stack_switcher_get_stack(_arg0)


var _stack Stack // out

_stack = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Stack)

return _stack
}
	
	// SetStack sets the stack to control.
	func (s StackSwitcher) SetStack(stack StackClass)  {
var _arg0 *C.GtkStackSwitcher // out
var _arg1 *C.GtkStack // out

_arg0 = (*C.GtkStackSwitcher)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkStack)(unsafe.Pointer(stack.Native()))

C.gtk_stack_switcher_set_stack(_arg0, _arg1)
}
	


	// StatusIcon: the “system tray” or notification area is normally used for
// transient icons that indicate some special state. For example, a system tray
// icon might appear to tell the user that they have new mail, or have an
// incoming instant message, or something along those lines. The basic idea is
// that creating an icon in the notification area is less annoying than popping
// up a dialog.
// 
// A StatusIcon object can be used to display an icon in a “system tray”. The
// icon can have a tooltip, and the user can interact with it by activating it
// or popping up a context menu.
// 
// It is very important to notice that status icons depend on the existence of a
// notification area being available to the user; you should not use status
// icons as the only way to convey critical information regarding your
// application, as the notification area may not exist on the user's
// environment, or may have been removed. You should always check that a status
// icon has been embedded into a notification area by using
// gtk_status_icon_is_embedded(), and gracefully recover if the function returns
// false.
// 
// On X11, the implementation follows the FreeDesktop System Tray Specification
// (http://www.freedesktop.org/wiki/Specifications/systemtray-spec).
// Implementations of the “tray” side of this specification can be found e.g. in
// the GNOME 2 and KDE panel applications.
// 
// Note that a GtkStatusIcon is not a widget, but just a #GObject. Making it a
// widget would be impractical, since the system tray on Windows doesn’t allow
// to embed arbitrary widgets.
// 
// GtkStatusIcon has been deprecated in 3.14. You should consider using
// notifications or more modern platform-specific APIs instead. GLib provides
// the #GNotification API which works well with Application on multiple
// platforms and environments, and should be the preferred mechanism to notify
// the users of transient status updates. See this HowDoI
// (https://wiki.gnome.org/HowDoI/GNotification) for code examples.
	type StatusIcon struct {
		**externglib.Object
		
	}

	// StatusIconClass is an interface that the StatusIcon class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type StatusIconClass interface {
		gextras.Objector
		_statusIcon()
	}

	func (StatusIcon) _statusIcon() {}

	
	func marshalStatusIcon(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapStatusIcon(obj), nil
	}
	

	
	// NewStatusIcon creates an empty status icon object.
	func NewStatusIcon() StatusIcon {
var _cret *C.GtkStatusIcon // in

_cret = C.gtk_status_icon_new()


var _statusIcon StatusIcon // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_statusIcon = StatusIcon{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}

return _statusIcon
}
	
	// NewStatusIconFromFile creates a status icon displaying the file @filename.
// 
// The image will be scaled down to fit in the available space in the
// notification area, if necessary.
	func NewStatusIconFromFile(filename string) StatusIcon {
var _arg1 *C.gchar // out
var _cret *C.GtkStatusIcon // in

_arg1 = (*C.gchar)(C.CString(filename))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_status_icon_new_from_file(_arg1)


var _statusIcon StatusIcon // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_statusIcon = StatusIcon{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}

return _statusIcon
}
	
	// NewStatusIconFromGIcon creates a status icon displaying a #GIcon. If the icon
// is a themed icon, it will be updated when the theme changes.
	func NewStatusIconFromGIcon(icon gio.Icon) StatusIcon {
var _arg1 *C.GIcon // out
var _cret *C.GtkStatusIcon // in

_arg1 = (*C.GIcon)(unsafe.Pointer(icon.Native()))

_cret = C.gtk_status_icon_new_from_gicon(_arg1)


var _statusIcon StatusIcon // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_statusIcon = StatusIcon{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}

return _statusIcon
}
	
	// NewStatusIconFromIconName creates a status icon displaying an icon from the
// current icon theme. If the current icon theme is changed, the icon will be
// updated appropriately.
	func NewStatusIconFromIconName(iconName string) StatusIcon {
var _arg1 *C.gchar // out
var _cret *C.GtkStatusIcon // in

_arg1 = (*C.gchar)(C.CString(iconName))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_status_icon_new_from_icon_name(_arg1)


var _statusIcon StatusIcon // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_statusIcon = StatusIcon{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}

return _statusIcon
}
	
	// NewStatusIconFromPixbuf creates a status icon displaying @pixbuf.
// 
// The image will be scaled down to fit in the available space in the
// notification area, if necessary.
	func NewStatusIconFromPixbuf(pixbuf gdkpixbuf.PixbufClass) StatusIcon {
var _arg1 *C.GdkPixbuf // out
var _cret *C.GtkStatusIcon // in

_arg1 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))

_cret = C.gtk_status_icon_new_from_pixbuf(_arg1)


var _statusIcon StatusIcon // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_statusIcon = StatusIcon{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}

return _statusIcon
}
	
	// NewStatusIconFromStock creates a status icon displaying a stock icon. Sample
// stock icon names are K_STOCK_OPEN, K_STOCK_QUIT. You can register your own
// stock icon names, see gtk_icon_factory_add_default() and
// gtk_icon_factory_add().
	func NewStatusIconFromStock(stockId string) StatusIcon {
var _arg1 *C.gchar // out
var _cret *C.GtkStatusIcon // in

_arg1 = (*C.gchar)(C.CString(stockId))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_status_icon_new_from_stock(_arg1)


var _statusIcon StatusIcon // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_statusIcon = StatusIcon{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}

return _statusIcon
}
	

	
	// Geometry obtains information about the location of the status icon on screen.
// This information can be used to e.g. position popups like notification
// bubbles.
// 
// See gtk_status_icon_position_menu() for a more convenient alternative for
// positioning menus.
// 
// Note that some platforms do not allow GTK+ to provide this information, and
// even on platforms that do allow it, the information is not reliable unless
// the status icon is embedded in a notification area, see
// gtk_status_icon_is_embedded().
	func (s StatusIcon) Geometry() (gdk.Screen, gdk.Rectangle, Orientation, bool) {
var _arg0 *C.GtkStatusIcon // out
var _arg1 *C.GdkScreen // in
var _area gdk.Rectangle
var _arg3 C.GtkOrientation // in
var _cret C.gboolean // in

_arg0 = (*C.GtkStatusIcon)(unsafe.Pointer(s.Native()))

_cret = C.gtk_status_icon_get_geometry(_arg0, &_arg1, (*C.GdkRectangle)(unsafe.Pointer(&_area)), &_arg3)


var _screen gdk.Screen // out

var _orientation Orientation // out
var _ok bool // out

_screen = gextras.CastObject(externglib.Take(unsafe.Pointer(_arg1))).(gdk.Screen)

_orientation = Orientation(_arg3)
if _cret != 0 { _ok = true }

return _screen, _area, _orientation, _ok
}
	
	// GIcon retrieves the #GIcon being displayed by the StatusIcon. The storage
// type of the status icon must be GTK_IMAGE_EMPTY or GTK_IMAGE_GICON (see
// gtk_status_icon_get_storage_type()). The caller of this function does not own
// a reference to the returned #GIcon.
// 
// If this function fails, @icon is left unchanged;
	func (s StatusIcon) GIcon() gio.Icon {
var _arg0 *C.GtkStatusIcon // out
var _cret *C.GIcon // in

_arg0 = (*C.GtkStatusIcon)(unsafe.Pointer(s.Native()))

_cret = C.gtk_status_icon_get_gicon(_arg0)


var _icon gio.Icon // out

_icon = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.Icon)

return _icon
}
	
	// HasTooltip returns the current value of the has-tooltip property. See
// StatusIcon:has-tooltip for more information.
	func (s StatusIcon) HasTooltip() bool {
var _arg0 *C.GtkStatusIcon // out
var _cret C.gboolean // in

_arg0 = (*C.GtkStatusIcon)(unsafe.Pointer(s.Native()))

_cret = C.gtk_status_icon_get_has_tooltip(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IconName gets the name of the icon being displayed by the StatusIcon. The
// storage type of the status icon must be GTK_IMAGE_EMPTY or
// GTK_IMAGE_ICON_NAME (see gtk_status_icon_get_storage_type()). The returned
// string is owned by the StatusIcon and should not be freed or modified.
	func (s StatusIcon) IconName() string {
var _arg0 *C.GtkStatusIcon // out
var _cret *C.gchar // in

_arg0 = (*C.GtkStatusIcon)(unsafe.Pointer(s.Native()))

_cret = C.gtk_status_icon_get_icon_name(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Pixbuf gets the Pixbuf being displayed by the StatusIcon. The storage type of
// the status icon must be GTK_IMAGE_EMPTY or GTK_IMAGE_PIXBUF (see
// gtk_status_icon_get_storage_type()). The caller of this function does not own
// a reference to the returned pixbuf.
	func (s StatusIcon) Pixbuf() gdkpixbuf.Pixbuf {
var _arg0 *C.GtkStatusIcon // out
var _cret *C.GdkPixbuf // in

_arg0 = (*C.GtkStatusIcon)(unsafe.Pointer(s.Native()))

_cret = C.gtk_status_icon_get_pixbuf(_arg0)


var _pixbuf gdkpixbuf.Pixbuf // out

_pixbuf = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdkpixbuf.Pixbuf)

return _pixbuf
}
	
	// Screen returns the Screen associated with @status_icon.
	func (s StatusIcon) Screen() gdk.Screen {
var _arg0 *C.GtkStatusIcon // out
var _cret *C.GdkScreen // in

_arg0 = (*C.GtkStatusIcon)(unsafe.Pointer(s.Native()))

_cret = C.gtk_status_icon_get_screen(_arg0)


var _screen gdk.Screen // out

_screen = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Screen)

return _screen
}
	
	// Size gets the size in pixels that is available for the image. Stock icons and
// named icons adapt their size automatically if the size of the notification
// area changes. For other storage types, the size-changed signal can be used to
// react to size changes.
// 
// Note that the returned size is only meaningful while the status icon is
// embedded (see gtk_status_icon_is_embedded()).
	func (s StatusIcon) Size() int {
var _arg0 *C.GtkStatusIcon // out
var _cret C.gint // in

_arg0 = (*C.GtkStatusIcon)(unsafe.Pointer(s.Native()))

_cret = C.gtk_status_icon_get_size(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Stock gets the id of the stock icon being displayed by the StatusIcon. The
// storage type of the status icon must be GTK_IMAGE_EMPTY or GTK_IMAGE_STOCK
// (see gtk_status_icon_get_storage_type()). The returned string is owned by the
// StatusIcon and should not be freed or modified.
	func (s StatusIcon) Stock() string {
var _arg0 *C.GtkStatusIcon // out
var _cret *C.gchar // in

_arg0 = (*C.GtkStatusIcon)(unsafe.Pointer(s.Native()))

_cret = C.gtk_status_icon_get_stock(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// StorageType gets the type of representation being used by the StatusIcon to
// store image data. If the StatusIcon has no image data, the return value will
// be GTK_IMAGE_EMPTY.
	func (s StatusIcon) StorageType() ImageType {
var _arg0 *C.GtkStatusIcon // out
var _cret C.GtkImageType // in

_arg0 = (*C.GtkStatusIcon)(unsafe.Pointer(s.Native()))

_cret = C.gtk_status_icon_get_storage_type(_arg0)


var _imageType ImageType // out

_imageType = ImageType(_cret)

return _imageType
}
	
	// Title gets the title of this tray icon. See gtk_status_icon_set_title().
	func (s StatusIcon) Title() string {
var _arg0 *C.GtkStatusIcon // out
var _cret *C.gchar // in

_arg0 = (*C.GtkStatusIcon)(unsafe.Pointer(s.Native()))

_cret = C.gtk_status_icon_get_title(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// TooltipMarkup gets the contents of the tooltip for @status_icon.
	func (s StatusIcon) TooltipMarkup() string {
var _arg0 *C.GtkStatusIcon // out
var _cret *C.gchar // in

_arg0 = (*C.GtkStatusIcon)(unsafe.Pointer(s.Native()))

_cret = C.gtk_status_icon_get_tooltip_markup(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// TooltipText gets the contents of the tooltip for @status_icon.
	func (s StatusIcon) TooltipText() string {
var _arg0 *C.GtkStatusIcon // out
var _cret *C.gchar // in

_arg0 = (*C.GtkStatusIcon)(unsafe.Pointer(s.Native()))

_cret = C.gtk_status_icon_get_tooltip_text(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// Visible returns whether the status icon is visible or not. Note that being
// visible does not guarantee that the user can actually see the icon, see also
// gtk_status_icon_is_embedded().
	func (s StatusIcon) Visible() bool {
var _arg0 *C.GtkStatusIcon // out
var _cret C.gboolean // in

_arg0 = (*C.GtkStatusIcon)(unsafe.Pointer(s.Native()))

_cret = C.gtk_status_icon_get_visible(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// X11WindowID: this function is only useful on the X11/freedesktop.org
// platform.
// 
// It returns a window ID for the widget in the underlying status icon
// implementation. This is useful for the Galago notification service, which can
// send a window ID in the protocol in order for the server to position
// notification windows pointing to a status icon reliably.
// 
// This function is not intended for other use cases which are more likely to be
// met by one of the non-X11 specific methods, such as
// gtk_status_icon_position_menu().
	func (s StatusIcon) X11WindowID() uint32 {
var _arg0 *C.GtkStatusIcon // out
var _cret C.guint32 // in

_arg0 = (*C.GtkStatusIcon)(unsafe.Pointer(s.Native()))

_cret = C.gtk_status_icon_get_x11_window_id(_arg0)


var _guint32 uint32 // out

_guint32 = (uint32)(_cret)

return _guint32
}
	
	// IsEmbedded returns whether the status icon is embedded in a notification
// area.
	func (s StatusIcon) IsEmbedded() bool {
var _arg0 *C.GtkStatusIcon // out
var _cret C.gboolean // in

_arg0 = (*C.GtkStatusIcon)(unsafe.Pointer(s.Native()))

_cret = C.gtk_status_icon_is_embedded(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetFromFile makes @status_icon display the file @filename. See
// gtk_status_icon_new_from_file() for details.
	func (s StatusIcon) SetFromFile(filename string)  {
var _arg0 *C.GtkStatusIcon // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkStatusIcon)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(filename))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_status_icon_set_from_file(_arg0, _arg1)
}
	
	// SetFromGIcon makes @status_icon display the #GIcon. See
// gtk_status_icon_new_from_gicon() for details.
	func (s StatusIcon) SetFromGIcon(icon gio.Icon)  {
var _arg0 *C.GtkStatusIcon // out
var _arg1 *C.GIcon // out

_arg0 = (*C.GtkStatusIcon)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GIcon)(unsafe.Pointer(icon.Native()))

C.gtk_status_icon_set_from_gicon(_arg0, _arg1)
}
	
	// SetFromIconName makes @status_icon display the icon named @icon_name from the
// current icon theme. See gtk_status_icon_new_from_icon_name() for details.
	func (s StatusIcon) SetFromIconName(iconName string)  {
var _arg0 *C.GtkStatusIcon // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkStatusIcon)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(iconName))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_status_icon_set_from_icon_name(_arg0, _arg1)
}
	
	// SetFromPixbuf makes @status_icon display @pixbuf. See
// gtk_status_icon_new_from_pixbuf() for details.
	func (s StatusIcon) SetFromPixbuf(pixbuf gdkpixbuf.PixbufClass)  {
var _arg0 *C.GtkStatusIcon // out
var _arg1 *C.GdkPixbuf // out

_arg0 = (*C.GtkStatusIcon)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))

C.gtk_status_icon_set_from_pixbuf(_arg0, _arg1)
}
	
	// SetFromStock makes @status_icon display the stock icon with the id @stock_id.
// See gtk_status_icon_new_from_stock() for details.
	func (s StatusIcon) SetFromStock(stockId string)  {
var _arg0 *C.GtkStatusIcon // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkStatusIcon)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(stockId))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_status_icon_set_from_stock(_arg0, _arg1)
}
	
	// SetHasTooltip sets the has-tooltip property on @status_icon to @has_tooltip.
// See StatusIcon:has-tooltip for more information.
	func (s StatusIcon) SetHasTooltip(hasTooltip bool)  {
var _arg0 *C.GtkStatusIcon // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkStatusIcon)(unsafe.Pointer(s.Native()))
if hasTooltip { _arg1 = C.TRUE }

C.gtk_status_icon_set_has_tooltip(_arg0, _arg1)
}
	
	// SetName sets the name of this tray icon. This should be a string identifying
// this icon. It is may be used for sorting the icons in the tray and will not
// be shown to the user.
	func (s StatusIcon) SetName(name string)  {
var _arg0 *C.GtkStatusIcon // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkStatusIcon)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_status_icon_set_name(_arg0, _arg1)
}
	
	// SetScreen sets the Screen where @status_icon is displayed; if the icon is
// already mapped, it will be unmapped, and then remapped on the new screen.
	func (s StatusIcon) SetScreen(screen gdk.ScreenClass)  {
var _arg0 *C.GtkStatusIcon // out
var _arg1 *C.GdkScreen // out

_arg0 = (*C.GtkStatusIcon)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GdkScreen)(unsafe.Pointer(screen.Native()))

C.gtk_status_icon_set_screen(_arg0, _arg1)
}
	
	// SetTitle sets the title of this tray icon. This should be a short,
// human-readable, localized string describing the tray icon. It may be used by
// tools like screen readers to render the tray icon.
	func (s StatusIcon) SetTitle(title string)  {
var _arg0 *C.GtkStatusIcon // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkStatusIcon)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(title))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_status_icon_set_title(_arg0, _arg1)
}
	
	// SetTooltipMarkup sets @markup as the contents of the tooltip, which is marked
// up with the [Pango text markup language][PangoMarkupFormat].
// 
// This function will take care of setting StatusIcon:has-tooltip to true and of
// the default handler for the StatusIcon::query-tooltip signal.
// 
// See also the StatusIcon:tooltip-markup property and gtk_tooltip_set_markup().
	func (s StatusIcon) SetTooltipMarkup(markup string)  {
var _arg0 *C.GtkStatusIcon // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkStatusIcon)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(markup))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_status_icon_set_tooltip_markup(_arg0, _arg1)
}
	
	// SetTooltipText sets @text as the contents of the tooltip.
// 
// This function will take care of setting StatusIcon:has-tooltip to true and of
// the default handler for the StatusIcon::query-tooltip signal.
// 
// See also the StatusIcon:tooltip-text property and gtk_tooltip_set_text().
	func (s StatusIcon) SetTooltipText(text string)  {
var _arg0 *C.GtkStatusIcon // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkStatusIcon)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(text))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_status_icon_set_tooltip_text(_arg0, _arg1)
}
	
	// SetVisible shows or hides a status icon.
	func (s StatusIcon) SetVisible(visible bool)  {
var _arg0 *C.GtkStatusIcon // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkStatusIcon)(unsafe.Pointer(s.Native()))
if visible { _arg1 = C.TRUE }

C.gtk_status_icon_set_visible(_arg0, _arg1)
}
	


	// Statusbar: a Statusbar is usually placed along the bottom of an application's
// main Window. It may provide a regular commentary of the application's status
// (as is usually the case in a web browser, for example), or may be used to
// simply output a message when the status changes, (when an upload is complete
// in an FTP client, for example).
// 
// Status bars in GTK+ maintain a stack of messages. The message at the top of
// the each bar’s stack is the one that will currently be displayed.
// 
// Any messages added to a statusbar’s stack must specify a context id that is
// used to uniquely identify the source of a message. This context id can be
// generated by gtk_statusbar_get_context_id(), given a message and the
// statusbar that it will be added to. Note that messages are stored in a stack,
// and when choosing which message to display, the stack structure is adhered
// to, regardless of the context identifier of a message.
// 
// One could say that a statusbar maintains one stack of messages for display
// purposes, but allows multiple message producers to maintain sub-stacks of the
// messages they produced (via context ids).
// 
// Status bars are created using gtk_statusbar_new().
// 
// Messages are added to the bar’s stack with gtk_statusbar_push().
// 
// The message at the top of the stack can be removed using gtk_statusbar_pop().
// A message can be removed from anywhere in the stack if its message id was
// recorded at the time it was added. This is done using gtk_statusbar_remove().
// 
// 
// CSS node
// 
// GtkStatusbar has a single CSS node with name statusbar.
	type Statusbar struct {
		Box
		Buildable
		Orientable
		
	}

	// StatusbarClass is an interface that the Statusbar class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type StatusbarClass interface {
		gextras.Objector
		_statusbar()
	}

	func (Statusbar) _statusbar() {}

	
	func marshalStatusbar(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapStatusbar(obj), nil
	}
	

	
	// NewStatusbar creates a new Statusbar ready for messages.
	func NewStatusbar() Statusbar {
var _cret *C.GtkWidget // in

_cret = C.gtk_statusbar_new()


var _statusbar Statusbar // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_statusbar = Statusbar{
Box: Box{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _statusbar
}
	

	
	// ContextID returns a new context identifier, given a description of the actual
// context. Note that the description is not shown in the UI.
	func (s Statusbar) ContextID(contextDescription string) uint {
var _arg0 *C.GtkStatusbar // out
var _arg1 *C.gchar // out
var _cret C.guint // in

_arg0 = (*C.GtkStatusbar)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(contextDescription))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_statusbar_get_context_id(_arg0, _arg1)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// MessageArea retrieves the box containing the label widget.
	func (s Statusbar) MessageArea() Box {
var _arg0 *C.GtkStatusbar // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkStatusbar)(unsafe.Pointer(s.Native()))

_cret = C.gtk_statusbar_get_message_area(_arg0)


var _box Box // out

_box = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Box)

return _box
}
	
	// Pop removes the first message in the Statusbar’s stack with the given context
// id.
// 
// Note that this may not change the displayed message, if the message at the
// top of the stack has a different context id.
	func (s Statusbar) Pop(contextId uint)  {
var _arg0 *C.GtkStatusbar // out
var _arg1 C.guint // out

_arg0 = (*C.GtkStatusbar)(unsafe.Pointer(s.Native()))
_arg1 = (C.guint)(contextId)

C.gtk_statusbar_pop(_arg0, _arg1)
}
	
	// Push pushes a new message onto a statusbar’s stack.
	func (s Statusbar) Push(contextId uint, text string) uint {
var _arg0 *C.GtkStatusbar // out
var _arg1 C.guint // out
var _arg2 *C.gchar // out
var _cret C.guint // in

_arg0 = (*C.GtkStatusbar)(unsafe.Pointer(s.Native()))
_arg1 = (C.guint)(contextId)
_arg2 = (*C.gchar)(C.CString(text))
defer C.free(unsafe.Pointer(_arg2))

_cret = C.gtk_statusbar_push(_arg0, _arg1, _arg2)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// Remove forces the removal of a message from a statusbar’s stack. The exact
// @context_id and @message_id must be specified.
	func (s Statusbar) Remove(contextId uint, messageId uint)  {
var _arg0 *C.GtkStatusbar // out
var _arg1 C.guint // out
var _arg2 C.guint // out

_arg0 = (*C.GtkStatusbar)(unsafe.Pointer(s.Native()))
_arg1 = (C.guint)(contextId)
_arg2 = (C.guint)(messageId)

C.gtk_statusbar_remove(_arg0, _arg1, _arg2)
}
	
	// RemoveAll forces the removal of all messages from a statusbar's stack with
// the exact @context_id.
	func (s Statusbar) RemoveAll(contextId uint)  {
var _arg0 *C.GtkStatusbar // out
var _arg1 C.guint // out

_arg0 = (*C.GtkStatusbar)(unsafe.Pointer(s.Native()))
_arg1 = (C.guint)(contextId)

C.gtk_statusbar_remove_all(_arg0, _arg1)
}
	


	// Style: a Style object encapsulates the information that provides the look and
// feel for a widget.
// 
// > In GTK+ 3.0, GtkStyle has been deprecated and replaced by > StyleContext.
// 
// Each Widget has an associated Style object that is used when rendering that
// widget. Also, a Style holds information for the five possible widget states
// though not every widget supports all five states; see StateType.
// 
// Usually the Style for a widget is the same as the default style that is set
// by GTK+ and modified the theme engine.
// 
// Usually applications should not need to use or modify the Style of their
// widgets.
	type Style struct {
		**externglib.Object
		
	}

	// StyleClass is an interface that the Style class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type StyleClass interface {
		gextras.Objector
		_style()
	}

	func (Style) _style() {}

	
	func marshalStyle(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapStyle(obj), nil
	}
	

	
	// NewStyle creates a new Style.
	func NewStyle() Style {
var _cret *C.GtkStyle // in

_cret = C.gtk_style_new()


var _style Style // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_style = Style{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}

return _style
}
	

	
	
	func (s Style) ApplyDefaultBackground(cr *cairo.Context, window gdk.WindowClass, stateType StateType, x int, y int, width int, height int)  {
var _arg0 *C.GtkStyle // out
var _arg1 *C.cairo_t // out
var _arg2 *C.GdkWindow // out
var _arg3 C.GtkStateType // out
var _arg4 C.gint // out
var _arg5 C.gint // out
var _arg6 C.gint // out
var _arg7 C.gint // out

_arg0 = (*C.GtkStyle)(unsafe.Pointer(s.Native()))
_arg1 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
_arg2 = (*C.GdkWindow)(unsafe.Pointer(window.Native()))
_arg3 = (C.GtkStateType)(stateType)
_arg4 = (C.gint)(x)
_arg5 = (C.gint)(y)
_arg6 = (C.gint)(width)
_arg7 = (C.gint)(height)

C.gtk_style_apply_default_background(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7)
}
	
	// Copy creates a copy of the passed in Style object.
	func (s Style) Copy() Style {
var _arg0 *C.GtkStyle // out
var _cret *C.GtkStyle // in

_arg0 = (*C.GtkStyle)(unsafe.Pointer(s.Native()))

_cret = C.gtk_style_copy(_arg0)


var _ret Style // out

_ret = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Style)

return _ret
}
	
	// Detach detaches a style from a window. If the style is not attached to any
// windows anymore, it is unrealized. See gtk_style_attach().
	func (s Style) Detach()  {
var _arg0 *C.GtkStyle // out

_arg0 = (*C.GtkStyle)(unsafe.Pointer(s.Native()))

C.gtk_style_detach(_arg0)
}
	
	// StyleProperty queries the value of a style property corresponding to a widget
// class is in the given style.
	func (s Style) StyleProperty(widgetType externglib.Type, propertyName string) *externglib.Value {
var _arg0 *C.GtkStyle // out
var _arg1 C.GType // out
var _arg2 *C.gchar // out
var _arg3 C.GValue // in

_arg0 = (*C.GtkStyle)(unsafe.Pointer(s.Native()))
_arg1 = C.GType(widgetType)
_arg2 = (*C.gchar)(C.CString(propertyName))
defer C.free(unsafe.Pointer(_arg2))

C.gtk_style_get_style_property(_arg0, _arg1, _arg2, &_arg3)

var _value *externglib.Value // out

_value = externglib.ValueFromNative(unsafe.Pointer(_arg3))

return _value
}
	
	// HasContext returns whether @style has an associated StyleContext.
	func (s Style) HasContext() bool {
var _arg0 *C.GtkStyle // out
var _cret C.gboolean // in

_arg0 = (*C.GtkStyle)(unsafe.Pointer(s.Native()))

_cret = C.gtk_style_has_context(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// LookupColor looks up @color_name in the style’s logical color mappings,
// filling in @color and returning true if found, otherwise returning false. Do
// not cache the found mapping, because it depends on the Style and might change
// when a theme switch occurs.
	func (s Style) LookupColor(colorName string) (gdk.Color, bool) {
var _arg0 *C.GtkStyle // out
var _arg1 *C.gchar // out
var _color gdk.Color
var _cret C.gboolean // in

_arg0 = (*C.GtkStyle)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(colorName))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_style_lookup_color(_arg0, _arg1, (*C.GdkColor)(unsafe.Pointer(&_color)))



var _ok bool // out


if _cret != 0 { _ok = true }

return _color, _ok
}
	
	// LookupIconSet looks up @stock_id in the icon factories associated with @style
// and the default icon factory, returning an icon set if found, otherwise nil.
	func (s Style) LookupIconSet(stockId string) *IconSet {
var _arg0 *C.GtkStyle // out
var _arg1 *C.gchar // out
var _cret *C.GtkIconSet // in

_arg0 = (*C.GtkStyle)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(stockId))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_style_lookup_icon_set(_arg0, _arg1)


var _iconSet *IconSet // out

_iconSet = *(**IconSet)(unsafe.Pointer(&_cret))

return _iconSet
}
	
	// RenderIcon renders the icon specified by @source at the given @size according
// to the given parameters and returns the result in a pixbuf.
	func (s Style) RenderIcon(source *IconSource, direction TextDirection, state StateType, size int, widget WidgetClass, detail string) gdkpixbuf.Pixbuf {
var _arg0 *C.GtkStyle // out
var _arg1 *C.GtkIconSource // out
var _arg2 C.GtkTextDirection // out
var _arg3 C.GtkStateType // out
var _arg4 C.GtkIconSize // out
var _arg5 *C.GtkWidget // out
var _arg6 *C.gchar // out
var _cret *C.GdkPixbuf // in

_arg0 = (*C.GtkStyle)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkIconSource)(unsafe.Pointer(source.Native()))
_arg2 = (C.GtkTextDirection)(direction)
_arg3 = (C.GtkStateType)(state)
_arg4 = (C.GtkIconSize)(size)
_arg5 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg6 = (*C.gchar)(C.CString(detail))
defer C.free(unsafe.Pointer(_arg6))

_cret = C.gtk_style_render_icon(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)


var _pixbuf gdkpixbuf.Pixbuf // out

_pixbuf = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gdkpixbuf.Pixbuf)

return _pixbuf
}
	
	// SetBackground sets the background of @window to the background color or
// pixmap specified by @style for the given state.
	func (s Style) SetBackground(window gdk.WindowClass, stateType StateType)  {
var _arg0 *C.GtkStyle // out
var _arg1 *C.GdkWindow // out
var _arg2 C.GtkStateType // out

_arg0 = (*C.GtkStyle)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GdkWindow)(unsafe.Pointer(window.Native()))
_arg2 = (C.GtkStateType)(stateType)

C.gtk_style_set_background(_arg0, _arg1, _arg2)
}
	


	// StyleContext is an object that stores styling information affecting a widget
// defined by WidgetPath.
// 
// In order to construct the final style information, StyleContext queries
// information from all attached StyleProviders. Style providers can be either
// attached explicitly to the context through gtk_style_context_add_provider(),
// or to the screen through gtk_style_context_add_provider_for_screen(). The
// resulting style is a combination of all providers’ information in priority
// order.
// 
// For GTK+ widgets, any StyleContext returned by gtk_widget_get_style_context()
// will already have a WidgetPath, a Screen and RTL/LTR information set. The
// style context will also be updated automatically if any of these settings
// change on the widget.
// 
// If you are using the theming layer standalone, you will need to set a widget
// path and a screen yourself to the created style context through
// gtk_style_context_set_path() and possibly gtk_style_context_set_screen(). See
// the “Foreign drawing“ example in gtk3-demo.
// 
// 
// Style Classes
// 
// Widgets can add style classes to their context, which can be used to
// associate different styles by class. The documentation for individual widgets
// lists which style classes it uses itself, and which style classes may be
// added by applications to affect their appearance.
// 
// GTK+ defines macros for a number of style classes.
// 
// 
// Style Regions
// 
// Widgets can also add regions with flags to their context. This feature is
// deprecated and will be removed in a future GTK+ update. Please use style
// classes instead.
// 
// GTK+ defines macros for a number of style regions.
// 
// 
// Custom styling in UI libraries and applications
// 
// If you are developing a library with custom Widgets that render differently
// than standard components, you may need to add a StyleProvider yourself with
// the GTK_STYLE_PROVIDER_PRIORITY_FALLBACK priority, either a CssProvider or a
// custom object implementing the StyleProvider interface. This way themes may
// still attempt to style your UI elements in a different way if needed so.
// 
// If you are using custom styling on an applications, you probably want then to
// make your style information prevail to the theme’s, so you must use a
// StyleProvider with the GTK_STYLE_PROVIDER_PRIORITY_APPLICATION priority, keep
// in mind that the user settings in `XDG_CONFIG_HOME/gtk-3.0/gtk.css` will
// still take precedence over your changes, as it uses the
// GTK_STYLE_PROVIDER_PRIORITY_USER priority.
	type StyleContext struct {
		**externglib.Object
		
	}

	// StyleContextClass is an interface that the StyleContext class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type StyleContextClass interface {
		gextras.Objector
		_styleContext()
	}

	func (StyleContext) _styleContext() {}

	
	func marshalStyleContext(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapStyleContext(obj), nil
	}
	

	
	// NewStyleContext creates a standalone StyleContext, this style context won’t
// be attached to any widget, so you may want to call
// gtk_style_context_set_path() yourself.
// 
// This function is only useful when using the theming layer separated from
// GTK+, if you are using StyleContext to theme Widgets, use
// gtk_widget_get_style_context() in order to get a style context ready to theme
// the widget.
	func NewStyleContext() StyleContext {
var _cret *C.GtkStyleContext // in

_cret = C.gtk_style_context_new()


var _styleContext StyleContext // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_styleContext = StyleContext{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}

return _styleContext
}
	

	
	// AddClass adds a style class to @context, so posterior calls to
// gtk_style_context_get() or any of the gtk_render_*() functions will make use
// of this new class for styling.
// 
// In the CSS file format, a Entry defining a “search” class, would be matched
// by:
// 
// |[ <!-- language="CSS" --> entry.search { ... } ]|
// 
// While any widget defining a “search” class would be matched by: |[ <!--
// language="CSS" --> .search { ... } ]|
	func (c StyleContext) AddClass(className string)  {
var _arg0 *C.GtkStyleContext // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))
_arg1 = (*C.gchar)(C.CString(className))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_style_context_add_class(_arg0, _arg1)
}
	
	// AddProvider adds a style provider to @context, to be used in style
// construction. Note that a style provider added by this function only affects
// the style of the widget to which @context belongs. If you want to affect the
// style of all widgets, use gtk_style_context_add_provider_for_screen().
// 
// Note: If both priorities are the same, a StyleProvider added through this
// function takes precedence over another added through
// gtk_style_context_add_provider_for_screen().
	func (c StyleContext) AddProvider(provider StyleProvider, priority uint)  {
var _arg0 *C.GtkStyleContext // out
var _arg1 *C.GtkStyleProvider // out
var _arg2 C.guint // out

_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GtkStyleProvider)(unsafe.Pointer(provider.Native()))
_arg2 = (C.guint)(priority)

C.gtk_style_context_add_provider(_arg0, _arg1, _arg2)
}
	
	// AddRegion adds a region to @context, so posterior calls to
// gtk_style_context_get() or any of the gtk_render_*() functions will make use
// of this new region for styling.
// 
// In the CSS file format, a TreeView defining a “row” region, would be matched
// by:
// 
// |[ <!-- language="CSS" --> treeview row { ... } ]|
// 
// Pseudo-classes are used for matching @flags, so the two following rules: |[
// <!-- language="CSS" --> treeview row:nth-child(even) { ... } treeview
// row:nth-child(odd) { ... } ]|
// 
// would apply to even and odd rows, respectively.
// 
// Region names must only contain lowercase letters and “-”, starting always
// with a lowercase letter.
	func (c StyleContext) AddRegion(regionName string, flags RegionFlags)  {
var _arg0 *C.GtkStyleContext // out
var _arg1 *C.gchar // out
var _arg2 C.GtkRegionFlags // out

_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))
_arg1 = (*C.gchar)(C.CString(regionName))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.GtkRegionFlags)(flags)

C.gtk_style_context_add_region(_arg0, _arg1, _arg2)
}
	
	// BackgroundColor gets the background color for a given state.
// 
// This function is far less useful than it seems, and it should not be used in
// newly written code. CSS has no concept of "background color", as a background
// can be an image, or a gradient, or any other pattern including solid colors.
// 
// The only reason why you would call gtk_style_context_get_background_color()
// is to use the returned value to draw the background with it; the correct way
// to achieve this result is to use gtk_render_background() instead, along with
// CSS style classes to modify the color to be rendered.
	func (c StyleContext) BackgroundColor(state StateFlags) gdk.RGBA {
var _arg0 *C.GtkStyleContext // out
var _arg1 C.GtkStateFlags // out
var _color gdk.RGBA

_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))
_arg1 = (C.GtkStateFlags)(state)

C.gtk_style_context_get_background_color(_arg0, _arg1, (*C.GdkRGBA)(unsafe.Pointer(&_color)))





return _color
}
	
	// Border gets the border for a given state as a Border.
// 
// See gtk_style_context_get_property() and K_STYLE_PROPERTY_BORDER_WIDTH for
// details.
	func (c StyleContext) Border(state StateFlags) Border {
var _arg0 *C.GtkStyleContext // out
var _arg1 C.GtkStateFlags // out
var _border Border

_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))
_arg1 = (C.GtkStateFlags)(state)

C.gtk_style_context_get_border(_arg0, _arg1, (*C.GtkBorder)(unsafe.Pointer(&_border)))





return _border
}
	
	// BorderColor gets the border color for a given state.
	func (c StyleContext) BorderColor(state StateFlags) gdk.RGBA {
var _arg0 *C.GtkStyleContext // out
var _arg1 C.GtkStateFlags // out
var _color gdk.RGBA

_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))
_arg1 = (C.GtkStateFlags)(state)

C.gtk_style_context_get_border_color(_arg0, _arg1, (*C.GdkRGBA)(unsafe.Pointer(&_color)))





return _color
}
	
	// Color gets the foreground color for a given state.
// 
// See gtk_style_context_get_property() and K_STYLE_PROPERTY_COLOR for details.
	func (c StyleContext) Color(state StateFlags) gdk.RGBA {
var _arg0 *C.GtkStyleContext // out
var _arg1 C.GtkStateFlags // out
var _color gdk.RGBA

_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))
_arg1 = (C.GtkStateFlags)(state)

C.gtk_style_context_get_color(_arg0, _arg1, (*C.GdkRGBA)(unsafe.Pointer(&_color)))





return _color
}
	
	// Direction returns the widget direction used for rendering.
	func (c StyleContext) Direction() TextDirection {
var _arg0 *C.GtkStyleContext // out
var _cret C.GtkTextDirection // in

_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))

_cret = C.gtk_style_context_get_direction(_arg0)


var _textDirection TextDirection // out

_textDirection = TextDirection(_cret)

return _textDirection
}
	
	// Font returns the font description for a given state. The returned object is
// const and will remain valid until the StyleContext::changed signal happens.
	func (c StyleContext) Font(state StateFlags) *pango.FontDescription {
var _arg0 *C.GtkStyleContext // out
var _arg1 C.GtkStateFlags // out
var _cret *C.PangoFontDescription // in

_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))
_arg1 = (C.GtkStateFlags)(state)

_cret = C.gtk_style_context_get_font(_arg0, _arg1)


var _fontDescription *pango.FontDescription // out

_fontDescription = *(**pango.FontDescription)(unsafe.Pointer(&_cret))

return _fontDescription
}
	
	// FrameClock returns the FrameClock to which @context is attached.
	func (c StyleContext) FrameClock() gdk.FrameClock {
var _arg0 *C.GtkStyleContext // out
var _cret *C.GdkFrameClock // in

_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))

_cret = C.gtk_style_context_get_frame_clock(_arg0)


var _frameClock gdk.FrameClock // out

_frameClock = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.FrameClock)

return _frameClock
}
	
	// JunctionSides returns the sides where rendered elements connect visually with
// others.
	func (c StyleContext) JunctionSides() JunctionSides {
var _arg0 *C.GtkStyleContext // out
var _cret C.GtkJunctionSides // in

_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))

_cret = C.gtk_style_context_get_junction_sides(_arg0)


var _junctionSides JunctionSides // out

_junctionSides = JunctionSides(_cret)

return _junctionSides
}
	
	// Margin gets the margin for a given state as a Border. See
// gtk_style_property_get() and K_STYLE_PROPERTY_MARGIN for details.
	func (c StyleContext) Margin(state StateFlags) Border {
var _arg0 *C.GtkStyleContext // out
var _arg1 C.GtkStateFlags // out
var _margin Border

_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))
_arg1 = (C.GtkStateFlags)(state)

C.gtk_style_context_get_margin(_arg0, _arg1, (*C.GtkBorder)(unsafe.Pointer(&_margin)))





return _margin
}
	
	// Padding gets the padding for a given state as a Border. See
// gtk_style_context_get() and K_STYLE_PROPERTY_PADDING for details.
	func (c StyleContext) Padding(state StateFlags) Border {
var _arg0 *C.GtkStyleContext // out
var _arg1 C.GtkStateFlags // out
var _padding Border

_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))
_arg1 = (C.GtkStateFlags)(state)

C.gtk_style_context_get_padding(_arg0, _arg1, (*C.GtkBorder)(unsafe.Pointer(&_padding)))





return _padding
}
	
	// Parent gets the parent context set via gtk_style_context_set_parent(). See
// that function for details.
	func (c StyleContext) Parent() StyleContext {
var _arg0 *C.GtkStyleContext // out
var _cret *C.GtkStyleContext // in

_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))

_cret = C.gtk_style_context_get_parent(_arg0)


var _styleContext StyleContext // out

_styleContext = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(StyleContext)

return _styleContext
}
	
	// Path returns the widget path used for style matching.
	func (c StyleContext) Path() *WidgetPath {
var _arg0 *C.GtkStyleContext // out
var _cret *C.GtkWidgetPath // in

_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))

_cret = C.gtk_style_context_get_path(_arg0)


var _widgetPath *WidgetPath // out

_widgetPath = *(**WidgetPath)(unsafe.Pointer(&_cret))

return _widgetPath
}
	
	// Property gets a style property from @context for the given state.
// 
// Note that not all CSS properties that are supported by GTK+ can be retrieved
// in this way, since they may not be representable as #GValue. GTK+ defines
// macros for a number of properties that can be used with this function.
// 
// Note that passing a state other than the current state of @context is not
// recommended unless the style context has been saved with
// gtk_style_context_save().
// 
// When @value is no longer needed, g_value_unset() must be called to free any
// allocated memory.
	func (c StyleContext) Property(property string, state StateFlags) *externglib.Value {
var _arg0 *C.GtkStyleContext // out
var _arg1 *C.gchar // out
var _arg2 C.GtkStateFlags // out
var _arg3 C.GValue // in

_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))
_arg1 = (*C.gchar)(C.CString(property))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.GtkStateFlags)(state)

C.gtk_style_context_get_property(_arg0, _arg1, _arg2, &_arg3)

var _value *externglib.Value // out

_value = externglib.ValueFromNative(unsafe.Pointer(_arg3))
runtime.SetFinalizer(_value, func(v *externglib.Value) {
  C.g_value_unset((*C.GValue)(v.GValue))
})

return _value
}
	
	// Scale returns the scale used for assets.
	func (c StyleContext) Scale() int {
var _arg0 *C.GtkStyleContext // out
var _cret C.gint // in

_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))

_cret = C.gtk_style_context_get_scale(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Screen returns the Screen to which @context is attached.
	func (c StyleContext) Screen() gdk.Screen {
var _arg0 *C.GtkStyleContext // out
var _cret *C.GdkScreen // in

_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))

_cret = C.gtk_style_context_get_screen(_arg0)


var _screen gdk.Screen // out

_screen = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Screen)

return _screen
}
	
	// Section queries the location in the CSS where @property was defined for the
// current @context. Note that the state to be queried is taken from
// gtk_style_context_get_state().
// 
// If the location is not available, nil will be returned. The location might
// not be available for various reasons, such as the property being overridden,
// @property not naming a supported CSS property or tracking of definitions
// being disabled for performance reasons.
// 
// Shorthand CSS properties cannot be queried for a location and will always
// return nil.
	func (c StyleContext) Section(property string) *CSSSection {
var _arg0 *C.GtkStyleContext // out
var _arg1 *C.gchar // out
var _cret *C.GtkCssSection // in

_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))
_arg1 = (*C.gchar)(C.CString(property))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_style_context_get_section(_arg0, _arg1)


var _cssSection *CSSSection // out

_cssSection = *(**CSSSection)(unsafe.Pointer(&_cret))

return _cssSection
}
	
	// State returns the state used for style matching.
// 
// This method should only be used to retrieve the StateFlags to pass to
// StyleContext methods, like gtk_style_context_get_padding(). If you need to
// retrieve the current state of a Widget, use gtk_widget_get_state_flags().
	func (c StyleContext) State() StateFlags {
var _arg0 *C.GtkStyleContext // out
var _cret C.GtkStateFlags // in

_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))

_cret = C.gtk_style_context_get_state(_arg0)


var _stateFlags StateFlags // out

_stateFlags = StateFlags(_cret)

return _stateFlags
}
	
	// StyleProperty gets the value for a widget style property.
// 
// When @value is no longer needed, g_value_unset() must be called to free any
// allocated memory.
	func (c StyleContext) StyleProperty(propertyName string, value **externglib.Value)  {
var _arg0 *C.GtkStyleContext // out
var _arg1 *C.gchar // out
var _arg2 *C.GValue // out

_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))
_arg1 = (*C.gchar)(C.CString(propertyName))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.GValue)(value.GValue)

C.gtk_style_context_get_style_property(_arg0, _arg1, _arg2)
}
	
	// HasClass returns true if @context currently has defined the given class name.
	func (c StyleContext) HasClass(className string) bool {
var _arg0 *C.GtkStyleContext // out
var _arg1 *C.gchar // out
var _cret C.gboolean // in

_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))
_arg1 = (*C.gchar)(C.CString(className))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_style_context_has_class(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// HasRegion returns true if @context has the region defined. If @flags_return
// is not nil, it is set to the flags affecting the region.
	func (c StyleContext) HasRegion(regionName string) (RegionFlags, bool) {
var _arg0 *C.GtkStyleContext // out
var _arg1 *C.gchar // out
var _arg2 C.GtkRegionFlags // in
var _cret C.gboolean // in

_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))
_arg1 = (*C.gchar)(C.CString(regionName))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_style_context_has_region(_arg0, _arg1, &_arg2)


var _flagsReturn RegionFlags // out
var _ok bool // out

_flagsReturn = RegionFlags(_arg2)
if _cret != 0 { _ok = true }

return _flagsReturn, _ok
}
	
	// Invalidate invalidates @context style information, so it will be
// reconstructed again. It is useful if you modify the @context and need the new
// information immediately.
	func (c StyleContext) Invalidate()  {
var _arg0 *C.GtkStyleContext // out

_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))

C.gtk_style_context_invalidate(_arg0)
}
	
	// LookupColor looks up and resolves a color name in the @context color map.
	func (c StyleContext) LookupColor(colorName string) (gdk.RGBA, bool) {
var _arg0 *C.GtkStyleContext // out
var _arg1 *C.gchar // out
var _color gdk.RGBA
var _cret C.gboolean // in

_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))
_arg1 = (*C.gchar)(C.CString(colorName))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_style_context_lookup_color(_arg0, _arg1, (*C.GdkRGBA)(unsafe.Pointer(&_color)))



var _ok bool // out


if _cret != 0 { _ok = true }

return _color, _ok
}
	
	// LookupIconSet looks up @stock_id in the icon factories associated to @context
// and the default icon factory, returning an icon set if found, otherwise nil.
	func (c StyleContext) LookupIconSet(stockId string) *IconSet {
var _arg0 *C.GtkStyleContext // out
var _arg1 *C.gchar // out
var _cret *C.GtkIconSet // in

_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))
_arg1 = (*C.gchar)(C.CString(stockId))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_style_context_lookup_icon_set(_arg0, _arg1)


var _iconSet *IconSet // out

_iconSet = *(**IconSet)(unsafe.Pointer(&_cret))

return _iconSet
}
	
	// PopAnimatableRegion pops an animatable region from @context. See
// gtk_style_context_push_animatable_region().
	func (c StyleContext) PopAnimatableRegion()  {
var _arg0 *C.GtkStyleContext // out

_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))

C.gtk_style_context_pop_animatable_region(_arg0)
}
	
	// RemoveClass removes @class_name from @context.
	func (c StyleContext) RemoveClass(className string)  {
var _arg0 *C.GtkStyleContext // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))
_arg1 = (*C.gchar)(C.CString(className))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_style_context_remove_class(_arg0, _arg1)
}
	
	// RemoveProvider removes @provider from the style providers list in @context.
	func (c StyleContext) RemoveProvider(provider StyleProvider)  {
var _arg0 *C.GtkStyleContext // out
var _arg1 *C.GtkStyleProvider // out

_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GtkStyleProvider)(unsafe.Pointer(provider.Native()))

C.gtk_style_context_remove_provider(_arg0, _arg1)
}
	
	// RemoveRegion removes a region from @context.
	func (c StyleContext) RemoveRegion(regionName string)  {
var _arg0 *C.GtkStyleContext // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))
_arg1 = (*C.gchar)(C.CString(regionName))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_style_context_remove_region(_arg0, _arg1)
}
	
	// Restore restores @context state to a previous stage. See
// gtk_style_context_save().
	func (c StyleContext) Restore()  {
var _arg0 *C.GtkStyleContext // out

_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))

C.gtk_style_context_restore(_arg0)
}
	
	// Save saves the @context state, so temporary modifications done through
// gtk_style_context_add_class(), gtk_style_context_remove_class(),
// gtk_style_context_set_state(), etc. can quickly be reverted in one go through
// gtk_style_context_restore().
// 
// The matching call to gtk_style_context_restore() must be done before GTK
// returns to the main loop.
	func (c StyleContext) Save()  {
var _arg0 *C.GtkStyleContext // out

_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))

C.gtk_style_context_save(_arg0)
}
	
	// ScrollAnimations: this function is analogous to gdk_window_scroll(), and
// should be called together with it so the invalidation areas for any ongoing
// animation are scrolled together with it.
	func (c StyleContext) ScrollAnimations(window gdk.WindowClass, dx int, dy int)  {
var _arg0 *C.GtkStyleContext // out
var _arg1 *C.GdkWindow // out
var _arg2 C.gint // out
var _arg3 C.gint // out

_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GdkWindow)(unsafe.Pointer(window.Native()))
_arg2 = (C.gint)(dx)
_arg3 = (C.gint)(dy)

C.gtk_style_context_scroll_animations(_arg0, _arg1, _arg2, _arg3)
}
	
	// SetBackground sets the background of @window to the background pattern or
// color specified in @context for its current state.
	func (c StyleContext) SetBackground(window gdk.WindowClass)  {
var _arg0 *C.GtkStyleContext // out
var _arg1 *C.GdkWindow // out

_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GdkWindow)(unsafe.Pointer(window.Native()))

C.gtk_style_context_set_background(_arg0, _arg1)
}
	
	// SetDirection sets the reading direction for rendering purposes.
// 
// If you are using a StyleContext returned from gtk_widget_get_style_context(),
// you do not need to call this yourself.
	func (c StyleContext) SetDirection(direction TextDirection)  {
var _arg0 *C.GtkStyleContext // out
var _arg1 C.GtkTextDirection // out

_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))
_arg1 = (C.GtkTextDirection)(direction)

C.gtk_style_context_set_direction(_arg0, _arg1)
}
	
	// SetFrameClock attaches @context to the given frame clock.
// 
// The frame clock is used for the timing of animations.
// 
// If you are using a StyleContext returned from gtk_widget_get_style_context(),
// you do not need to call this yourself.
	func (c StyleContext) SetFrameClock(frameClock gdk.FrameClockClass)  {
var _arg0 *C.GtkStyleContext // out
var _arg1 *C.GdkFrameClock // out

_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GdkFrameClock)(unsafe.Pointer(frameClock.Native()))

C.gtk_style_context_set_frame_clock(_arg0, _arg1)
}
	
	// SetJunctionSides sets the sides where rendered elements (mostly through
// gtk_render_frame()) will visually connect with other visual elements.
// 
// This is merely a hint that may or may not be honored by themes.
// 
// Container widgets are expected to set junction hints as appropriate for their
// children, so it should not normally be necessary to call this function
// manually.
	func (c StyleContext) SetJunctionSides(sides JunctionSides)  {
var _arg0 *C.GtkStyleContext // out
var _arg1 C.GtkJunctionSides // out

_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))
_arg1 = (C.GtkJunctionSides)(sides)

C.gtk_style_context_set_junction_sides(_arg0, _arg1)
}
	
	// SetParent sets the parent style context for @context. The parent style
// context is used to implement inheritance
// (http://www.w3.org/TR/css3-cascade/#inheritance) of properties.
// 
// If you are using a StyleContext returned from gtk_widget_get_style_context(),
// the parent will be set for you.
	func (c StyleContext) SetParent(parent StyleContextClass)  {
var _arg0 *C.GtkStyleContext // out
var _arg1 *C.GtkStyleContext // out

_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(parent.Native()))

C.gtk_style_context_set_parent(_arg0, _arg1)
}
	
	// SetPath sets the WidgetPath used for style matching. As a consequence, the
// style will be regenerated to match the new given path.
// 
// If you are using a StyleContext returned from gtk_widget_get_style_context(),
// you do not need to call this yourself.
	func (c StyleContext) SetPath(path *WidgetPath)  {
var _arg0 *C.GtkStyleContext // out
var _arg1 *C.GtkWidgetPath // out

_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GtkWidgetPath)(unsafe.Pointer(path.Native()))

C.gtk_style_context_set_path(_arg0, _arg1)
}
	
	// SetScale sets the scale to use when getting image assets for the style.
	func (c StyleContext) SetScale(scale int)  {
var _arg0 *C.GtkStyleContext // out
var _arg1 C.gint // out

_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))
_arg1 = (C.gint)(scale)

C.gtk_style_context_set_scale(_arg0, _arg1)
}
	
	// SetScreen attaches @context to the given screen.
// 
// The screen is used to add style information from “global” style providers,
// such as the screen’s Settings instance.
// 
// If you are using a StyleContext returned from gtk_widget_get_style_context(),
// you do not need to call this yourself.
	func (c StyleContext) SetScreen(screen gdk.ScreenClass)  {
var _arg0 *C.GtkStyleContext // out
var _arg1 *C.GdkScreen // out

_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GdkScreen)(unsafe.Pointer(screen.Native()))

C.gtk_style_context_set_screen(_arg0, _arg1)
}
	
	// SetState sets the state to be used for style matching.
	func (c StyleContext) SetState(flags StateFlags)  {
var _arg0 *C.GtkStyleContext // out
var _arg1 C.GtkStateFlags // out

_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))
_arg1 = (C.GtkStateFlags)(flags)

C.gtk_style_context_set_state(_arg0, _arg1)
}
	
	// StateIsRunning returns true if there is a transition animation running for
// the current region (see gtk_style_context_push_animatable_region()).
// 
// If @progress is not nil, the animation progress will be returned there, 0.0
// means the state is closest to being unset, while 1.0 means it’s closest to
// being set. This means transition animation will run from 0 to 1 when @state
// is being set and from 1 to 0 when it’s being unset.
	func (c StyleContext) StateIsRunning(state StateType) (float64, bool) {
var _arg0 *C.GtkStyleContext // out
var _arg1 C.GtkStateType // out
var _arg2 C.gdouble // in
var _cret C.gboolean // in

_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))
_arg1 = (C.GtkStateType)(state)

_cret = C.gtk_style_context_state_is_running(_arg0, _arg1, &_arg2)


var _progress float64 // out
var _ok bool // out

_progress = (float64)(_arg2)
if _cret != 0 { _ok = true }

return _progress, _ok
}
	
	// String converts the style context into a string representation.
// 
// The string representation always includes information about the name, state,
// id, visibility and style classes of the CSS node that is backing @context.
// Depending on the flags, more information may be included.
// 
// This function is intended for testing and debugging of the CSS implementation
// in GTK+. There are no guarantees about the format of the returned string, it
// may change.
	func (c StyleContext) String(flags StyleContextPrintFlags) string {
var _arg0 *C.GtkStyleContext // out
var _arg1 C.GtkStyleContextPrintFlags // out
var _cret *C.char // in

_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))
_arg1 = (C.GtkStyleContextPrintFlags)(flags)

_cret = C.gtk_style_context_to_string(_arg0, _arg1)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	


	// StyleProperties gtkStyleProperties provides the storage for style information
// that is used by StyleContext and other StyleProvider implementations.
// 
// Before style properties can be stored in GtkStyleProperties, they must be
// registered with gtk_style_properties_register_property().
// 
// Unless you are writing a StyleProvider implementation, you are unlikely to
// use this API directly, as gtk_style_context_get() and its variants are the
// preferred way to access styling information from widget implementations and
// theming engine implementations should use the APIs provided by ThemingEngine
// instead.
// 
// StyleProperties has been deprecated in GTK 3.16. The CSS machinery does not
// use it anymore and all users of this object have been deprecated.
	type StyleProperties struct {
		**externglib.Object
		StyleProvider
		
	}

	// StylePropertiesClass is an interface that the StyleProperties class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type StylePropertiesClass interface {
		gextras.Objector
		_styleProperties()
	}

	func (StyleProperties) _styleProperties() {}

	
	func marshalStyleProperties(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapStyleProperties(obj), nil
	}
	

	
	// NewStyleProperties returns a newly created StyleProperties
	func NewStyleProperties() StyleProperties {
var _cret *C.GtkStyleProperties // in

_cret = C.gtk_style_properties_new()


var _styleProperties StyleProperties // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_styleProperties = StyleProperties{
Object: &externglib.Object{externglib.ToGObject(obj)},
StyleProvider: StyleProvider{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _styleProperties
}
	

	
	// Clear clears all style information from @props.
	func (p StyleProperties) Clear()  {
var _arg0 *C.GtkStyleProperties // out

_arg0 = (*C.GtkStyleProperties)(unsafe.Pointer(p.Native()))

C.gtk_style_properties_clear(_arg0)
}
	
	// Property gets a style property from @props for the given state. When done
// with @value, g_value_unset() needs to be called to free any allocated memory.
	func (p StyleProperties) Property(property string, state StateFlags) (*externglib.Value, bool) {
var _arg0 *C.GtkStyleProperties // out
var _arg1 *C.gchar // out
var _arg2 C.GtkStateFlags // out
var _arg3 C.GValue // in
var _cret C.gboolean // in

_arg0 = (*C.GtkStyleProperties)(unsafe.Pointer(p.Native()))
_arg1 = (*C.gchar)(C.CString(property))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.GtkStateFlags)(state)

_cret = C.gtk_style_properties_get_property(_arg0, _arg1, _arg2, &_arg3)


var _value *externglib.Value // out
var _ok bool // out

_value = externglib.ValueFromNative(unsafe.Pointer(_arg3))
runtime.SetFinalizer(_value, func(v *externglib.Value) {
  C.g_value_unset((*C.GValue)(v.GValue))
})
if _cret != 0 { _ok = true }

return _value, _ok
}
	
	// LookupColor returns the symbolic color that is mapped to @name.
	func (p StyleProperties) LookupColor(name string) *SymbolicColor {
var _arg0 *C.GtkStyleProperties // out
var _arg1 *C.gchar // out
var _cret *C.GtkSymbolicColor // in

_arg0 = (*C.GtkStyleProperties)(unsafe.Pointer(p.Native()))
_arg1 = (*C.gchar)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_style_properties_lookup_color(_arg0, _arg1)


var _symbolicColor *SymbolicColor // out

_symbolicColor = *(**SymbolicColor)(unsafe.Pointer(&_cret))

return _symbolicColor
}
	
	// MapColor maps @color so it can be referenced by @name. See
// gtk_style_properties_lookup_color()
	func (p StyleProperties) MapColor(name string, color *SymbolicColor)  {
var _arg0 *C.GtkStyleProperties // out
var _arg1 *C.gchar // out
var _arg2 *C.GtkSymbolicColor // out

_arg0 = (*C.GtkStyleProperties)(unsafe.Pointer(p.Native()))
_arg1 = (*C.gchar)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.GtkSymbolicColor)(unsafe.Pointer(color.Native()))

C.gtk_style_properties_map_color(_arg0, _arg1, _arg2)
}
	
	// Merge merges into @props all the style information contained in
// @props_to_merge. If @replace is true, the values will be overwritten, if it
// is false, the older values will prevail.
	func (p StyleProperties) Merge(propsToMerge StylePropertiesClass, replace bool)  {
var _arg0 *C.GtkStyleProperties // out
var _arg1 *C.GtkStyleProperties // out
var _arg2 C.gboolean // out

_arg0 = (*C.GtkStyleProperties)(unsafe.Pointer(p.Native()))
_arg1 = (*C.GtkStyleProperties)(unsafe.Pointer(propsToMerge.Native()))
if replace { _arg2 = C.TRUE }

C.gtk_style_properties_merge(_arg0, _arg1, _arg2)
}
	
	// SetPropertyStyleProperties sets a styling property in @props.
	func (p StyleProperties) SetPropertyStyleProperties(property string, state StateFlags, value **externglib.Value)  {
var _arg0 *C.GtkStyleProperties // out
var _arg1 *C.gchar // out
var _arg2 C.GtkStateFlags // out
var _arg3 *C.GValue // out

_arg0 = (*C.GtkStyleProperties)(unsafe.Pointer(p.Native()))
_arg1 = (*C.gchar)(C.CString(property))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.GtkStateFlags)(state)
_arg3 = (*C.GValue)(value.GValue)

C.gtk_style_properties_set_property(_arg0, _arg1, _arg2, _arg3)
}
	
	// UnsetProperty unsets a style property in @props.
	func (p StyleProperties) UnsetProperty(property string, state StateFlags)  {
var _arg0 *C.GtkStyleProperties // out
var _arg1 *C.gchar // out
var _arg2 C.GtkStateFlags // out

_arg0 = (*C.GtkStyleProperties)(unsafe.Pointer(p.Native()))
_arg1 = (*C.gchar)(C.CString(property))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.GtkStateFlags)(state)

C.gtk_style_properties_unset_property(_arg0, _arg1, _arg2)
}
	


	// Switch is a widget that has two states: on or off. The user can control which
// state should be active by clicking the empty area, or by dragging the handle.
// 
// GtkSwitch can also handle situations where the underlying state changes with
// a delay. See Switch::state-set for details.
// 
// CSS nodes
// 
//    switch
//    ╰── slider
// 
// GtkSwitch has two css nodes, the main node with the name switch and a subnode
// named slider. Neither of them is using any style classes.
	type Switch struct {
		Widget
		Actionable
		Activatable
		Buildable
		
	}

	// SwitchClass is an interface that the Switch class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type SwitchClass interface {
		gextras.Objector
		__switch()
	}

	func (Switch) __switch() {}

	
	func marshalSwitch(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapSwitch(obj), nil
	}
	

	
	// NewSwitch creates a new Switch widget.
	func NewSwitch() Switch {
var _cret *C.GtkWidget // in

_cret = C.gtk_switch_new()


var __switch Switch // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
__switch = Switch{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return __switch
}
	

	
	// Active gets whether the Switch is in its “on” or “off” state.
	func (s Switch) Active() bool {
var _arg0 *C.GtkSwitch // out
var _cret C.gboolean // in

_arg0 = (*C.GtkSwitch)(unsafe.Pointer(s.Native()))

_cret = C.gtk_switch_get_active(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// State gets the underlying state of the Switch.
	func (s Switch) State() bool {
var _arg0 *C.GtkSwitch // out
var _cret C.gboolean // in

_arg0 = (*C.GtkSwitch)(unsafe.Pointer(s.Native()))

_cret = C.gtk_switch_get_state(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetActive changes the state of @sw to the desired one.
	func (s Switch) SetActive(isActive bool)  {
var _arg0 *C.GtkSwitch // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkSwitch)(unsafe.Pointer(s.Native()))
if isActive { _arg1 = C.TRUE }

C.gtk_switch_set_active(_arg0, _arg1)
}
	
	// SetState sets the underlying state of the Switch.
// 
// Normally, this is the same as Switch:active, unless the switch is set up for
// delayed state changes. This function is typically called from a
// Switch::state-set signal handler.
// 
// See Switch::state-set for details.
	func (s Switch) SetState(state bool)  {
var _arg0 *C.GtkSwitch // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkSwitch)(unsafe.Pointer(s.Native()))
if state { _arg1 = C.TRUE }

C.gtk_switch_set_state(_arg0, _arg1)
}
	


	// Table: the Table functions allow the programmer to arrange widgets in rows
// and columns, making it easy to align many widgets next to each other,
// horizontally and vertically.
// 
// Tables are created with a call to gtk_table_new(), the size of which can
// later be changed with gtk_table_resize().
// 
// Widgets can be added to a table using gtk_table_attach() or the more
// convenient (but slightly less flexible) gtk_table_attach_defaults().
// 
// To alter the space next to a specific row, use gtk_table_set_row_spacing(),
// and for a column, gtk_table_set_col_spacing(). The gaps between all rows or
// columns can be changed by calling gtk_table_set_row_spacings() or
// gtk_table_set_col_spacings() respectively. Note that spacing is added between
// the children, while padding added by gtk_table_attach() is added on either
// side of the widget it belongs to.
// 
// gtk_table_set_homogeneous(), can be used to set whether all cells in the
// table will resize themselves to the size of the largest widget in the table.
// 
// > Table has been deprecated. Use Grid instead. It provides the same >
// capabilities as GtkTable for arranging widgets in a rectangular grid, but >
// does support height-for-width geometry management.
	type Table struct {
		Container
		Buildable
		
	}

	// TableClass is an interface that the Table class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type TableClass interface {
		gextras.Objector
		_table()
	}

	func (Table) _table() {}

	
	func marshalTable(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapTable(obj), nil
	}
	

	
	// NewTable: used to create a new table widget. An initial size must be given by
// specifying how many rows and columns the table should have, although this can
// be changed later with gtk_table_resize(). @rows and @columns must both be in
// the range 1 .. 65535. For historical reasons, 0 is accepted as well and is
// silently interpreted as 1.
	func NewTable(rows uint, columns uint, homogeneous bool) Table {
var _arg1 C.guint // out
var _arg2 C.guint // out
var _arg3 C.gboolean // out
var _cret *C.GtkWidget // in

_arg1 = (C.guint)(rows)
_arg2 = (C.guint)(columns)
if homogeneous { _arg3 = C.TRUE }

_cret = C.gtk_table_new(_arg1, _arg2, _arg3)


var _table Table // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_table = Table{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _table
}
	

	
	// Attach adds a widget to a table. The number of “cells” that a widget will
// occupy is specified by @left_attach, @right_attach, @top_attach and
// @bottom_attach. These each represent the leftmost, rightmost, uppermost and
// lowest column and row numbers of the table. (Columns and rows are indexed
// from zero).
// 
// To make a button occupy the lower right cell of a 2x2 table, use
// 
//    gtk_table_attach (table, button,
//                      1, 2, // left, right attach
//                      1, 2, // top, bottom attach
//                      xoptions, yoptions,
//                      xpadding, ypadding);
// 
// If you want to make the button span the entire bottom row, use @left_attach
// == 0 and @right_attach = 2 instead.
	func (t Table) Attach(child WidgetClass, leftAttach uint, rightAttach uint, topAttach uint, bottomAttach uint, xoptions AttachOptions, yoptions AttachOptions, xpadding uint, ypadding uint)  {
var _arg0 *C.GtkTable // out
var _arg1 *C.GtkWidget // out
var _arg2 C.guint // out
var _arg3 C.guint // out
var _arg4 C.guint // out
var _arg5 C.guint // out
var _arg6 C.GtkAttachOptions // out
var _arg7 C.GtkAttachOptions // out
var _arg8 C.guint // out
var _arg9 C.guint // out

_arg0 = (*C.GtkTable)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
_arg2 = (C.guint)(leftAttach)
_arg3 = (C.guint)(rightAttach)
_arg4 = (C.guint)(topAttach)
_arg5 = (C.guint)(bottomAttach)
_arg6 = (C.GtkAttachOptions)(xoptions)
_arg7 = (C.GtkAttachOptions)(yoptions)
_arg8 = (C.guint)(xpadding)
_arg9 = (C.guint)(ypadding)

C.gtk_table_attach(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9)
}
	
	// AttachDefaults as there are many options associated with gtk_table_attach(),
// this convenience function provides the programmer with a means to add
// children to a table with identical padding and expansion options. The values
// used for the AttachOptions are `GTK_EXPAND | GTK_FILL`, and the padding is
// set to 0.
	func (t Table) AttachDefaults(widget WidgetClass, leftAttach uint, rightAttach uint, topAttach uint, bottomAttach uint)  {
var _arg0 *C.GtkTable // out
var _arg1 *C.GtkWidget // out
var _arg2 C.guint // out
var _arg3 C.guint // out
var _arg4 C.guint // out
var _arg5 C.guint // out

_arg0 = (*C.GtkTable)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg2 = (C.guint)(leftAttach)
_arg3 = (C.guint)(rightAttach)
_arg4 = (C.guint)(topAttach)
_arg5 = (C.guint)(bottomAttach)

C.gtk_table_attach_defaults(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
}
	
	// ColSpacing gets the amount of space between column @col, and column @col + 1.
// See gtk_table_set_col_spacing().
	func (t Table) ColSpacing(column uint) uint {
var _arg0 *C.GtkTable // out
var _arg1 C.guint // out
var _cret C.guint // in

_arg0 = (*C.GtkTable)(unsafe.Pointer(t.Native()))
_arg1 = (C.guint)(column)

_cret = C.gtk_table_get_col_spacing(_arg0, _arg1)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// DefaultColSpacing gets the default column spacing for the table. This is the
// spacing that will be used for newly added columns. (See
// gtk_table_set_col_spacings())
	func (t Table) DefaultColSpacing() uint {
var _arg0 *C.GtkTable // out
var _cret C.guint // in

_arg0 = (*C.GtkTable)(unsafe.Pointer(t.Native()))

_cret = C.gtk_table_get_default_col_spacing(_arg0)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// DefaultRowSpacing gets the default row spacing for the table. This is the
// spacing that will be used for newly added rows. (See
// gtk_table_set_row_spacings())
	func (t Table) DefaultRowSpacing() uint {
var _arg0 *C.GtkTable // out
var _cret C.guint // in

_arg0 = (*C.GtkTable)(unsafe.Pointer(t.Native()))

_cret = C.gtk_table_get_default_row_spacing(_arg0)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// Homogeneous returns whether the table cells are all constrained to the same
// width and height. (See gtk_table_set_homogeneous ())
	func (t Table) Homogeneous() bool {
var _arg0 *C.GtkTable // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTable)(unsafe.Pointer(t.Native()))

_cret = C.gtk_table_get_homogeneous(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// RowSpacing gets the amount of space between row @row, and row @row + 1. See
// gtk_table_set_row_spacing().
	func (t Table) RowSpacing(row uint) uint {
var _arg0 *C.GtkTable // out
var _arg1 C.guint // out
var _cret C.guint // in

_arg0 = (*C.GtkTable)(unsafe.Pointer(t.Native()))
_arg1 = (C.guint)(row)

_cret = C.gtk_table_get_row_spacing(_arg0, _arg1)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// Size gets the number of rows and columns in the table.
	func (t Table) Size() (rows uint, columns uint) {
var _arg0 *C.GtkTable // out
var _arg1 C.guint // in
var _arg2 C.guint // in

_arg0 = (*C.GtkTable)(unsafe.Pointer(t.Native()))

C.gtk_table_get_size(_arg0, &_arg1, &_arg2)

var _rows uint // out
var _columns uint // out

_rows = (uint)(_arg1)
_columns = (uint)(_arg2)

return _rows, _columns
}
	
	// Resize: if you need to change a table’s size after it has been created, this
// function allows you to do so.
	func (t Table) Resize(rows uint, columns uint)  {
var _arg0 *C.GtkTable // out
var _arg1 C.guint // out
var _arg2 C.guint // out

_arg0 = (*C.GtkTable)(unsafe.Pointer(t.Native()))
_arg1 = (C.guint)(rows)
_arg2 = (C.guint)(columns)

C.gtk_table_resize(_arg0, _arg1, _arg2)
}
	
	// SetColSpacing alters the amount of space between a given table column and the
// following column.
	func (t Table) SetColSpacing(column uint, spacing uint)  {
var _arg0 *C.GtkTable // out
var _arg1 C.guint // out
var _arg2 C.guint // out

_arg0 = (*C.GtkTable)(unsafe.Pointer(t.Native()))
_arg1 = (C.guint)(column)
_arg2 = (C.guint)(spacing)

C.gtk_table_set_col_spacing(_arg0, _arg1, _arg2)
}
	
	// SetColSpacings sets the space between every column in @table equal to
// @spacing.
	func (t Table) SetColSpacings(spacing uint)  {
var _arg0 *C.GtkTable // out
var _arg1 C.guint // out

_arg0 = (*C.GtkTable)(unsafe.Pointer(t.Native()))
_arg1 = (C.guint)(spacing)

C.gtk_table_set_col_spacings(_arg0, _arg1)
}
	
	// SetHomogeneous changes the homogenous property of table cells, ie. whether
// all cells are an equal size or not.
	func (t Table) SetHomogeneous(homogeneous bool)  {
var _arg0 *C.GtkTable // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkTable)(unsafe.Pointer(t.Native()))
if homogeneous { _arg1 = C.TRUE }

C.gtk_table_set_homogeneous(_arg0, _arg1)
}
	
	// SetRowSpacing changes the space between a given table row and the subsequent
// row.
	func (t Table) SetRowSpacing(row uint, spacing uint)  {
var _arg0 *C.GtkTable // out
var _arg1 C.guint // out
var _arg2 C.guint // out

_arg0 = (*C.GtkTable)(unsafe.Pointer(t.Native()))
_arg1 = (C.guint)(row)
_arg2 = (C.guint)(spacing)

C.gtk_table_set_row_spacing(_arg0, _arg1, _arg2)
}
	
	// SetRowSpacings sets the space between every row in @table equal to @spacing.
	func (t Table) SetRowSpacings(spacing uint)  {
var _arg0 *C.GtkTable // out
var _arg1 C.guint // out

_arg0 = (*C.GtkTable)(unsafe.Pointer(t.Native()))
_arg1 = (C.guint)(spacing)

C.gtk_table_set_row_spacings(_arg0, _arg1)
}
	


	// TearoffMenuItem: a TearoffMenuItem is a special MenuItem which is used to
// tear off and reattach its menu.
// 
// When its menu is shown normally, the TearoffMenuItem is drawn as a dotted
// line indicating that the menu can be torn off. Activating it causes its menu
// to be torn off and displayed in its own window as a tearoff menu.
// 
// When its menu is shown as a tearoff menu, the TearoffMenuItem is drawn as a
// dotted line which has a left pointing arrow graphic indicating that the
// tearoff menu can be reattached. Activating it will erase the tearoff menu
// window.
// 
// > TearoffMenuItem is deprecated and should not be used in newly > written
// code. Menus are not meant to be torn around.
	type TearoffMenuItem struct {
		MenuItem
		Actionable
		Activatable
		Buildable
		
	}

	// TearoffMenuItemClass is an interface that the TearoffMenuItem class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type TearoffMenuItemClass interface {
		gextras.Objector
		_tearoffMenuItem()
	}

	func (TearoffMenuItem) _tearoffMenuItem() {}

	
	func marshalTearoffMenuItem(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapTearoffMenuItem(obj), nil
	}
	

	
	// NewTearoffMenuItem creates a new TearoffMenuItem.
	func NewTearoffMenuItem() TearoffMenuItem {
var _cret *C.GtkWidget // in

_cret = C.gtk_tearoff_menu_item_new()


var _tearoffMenuItem TearoffMenuItem // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_tearoffMenuItem = TearoffMenuItem{
MenuItem: MenuItem{
Bin: Bin{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _tearoffMenuItem
}
	

	


	// TextBuffer: you may wish to begin by reading the [text widget conceptual
// overview][TextWidget] which gives an overview of all the objects and data
// types related to the text widget and how they work together.
	type TextBuffer struct {
		**externglib.Object
		
	}

	// TextBufferClass is an interface that the TextBuffer class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type TextBufferClass interface {
		gextras.Objector
		_textBuffer()
	}

	func (TextBuffer) _textBuffer() {}

	
	func marshalTextBuffer(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapTextBuffer(obj), nil
	}
	

	
	// NewTextBuffer creates a new text buffer.
	func NewTextBuffer(table TextTagTableClass) TextBuffer {
var _arg1 *C.GtkTextTagTable // out
var _cret *C.GtkTextBuffer // in

_arg1 = (*C.GtkTextTagTable)(unsafe.Pointer(table.Native()))

_cret = C.gtk_text_buffer_new(_arg1)


var _textBuffer TextBuffer // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_textBuffer = TextBuffer{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}

return _textBuffer
}
	

	
	// AddMark adds the mark at position @where. The mark must not be added to
// another buffer, and if its name is not nil then there must not be another
// mark in the buffer with the same name.
// 
// Emits the TextBuffer::mark-set signal as notification of the mark's initial
// placement.
	func (b TextBuffer) AddMark(mark TextMarkClass, where *TextIter)  {
var _arg0 *C.GtkTextBuffer // out
var _arg1 *C.GtkTextMark // out
var _arg2 *C.GtkTextIter // out

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkTextMark)(unsafe.Pointer(mark.Native()))
_arg2 = (*C.GtkTextIter)(unsafe.Pointer(where.Native()))

C.gtk_text_buffer_add_mark(_arg0, _arg1, _arg2)
}
	
	// AddSelectionClipboard adds @clipboard to the list of clipboards in which the
// selection contents of @buffer are available. In most cases, @clipboard will
// be the Clipboard of type GDK_SELECTION_PRIMARY for a view of @buffer.
	func (b TextBuffer) AddSelectionClipboard(clipboard ClipboardClass)  {
var _arg0 *C.GtkTextBuffer // out
var _arg1 *C.GtkClipboard // out

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkClipboard)(unsafe.Pointer(clipboard.Native()))

C.gtk_text_buffer_add_selection_clipboard(_arg0, _arg1)
}
	
	// ApplyTag emits the “apply-tag” signal on @buffer. The default handler for the
// signal applies @tag to the given range. @start and @end do not have to be in
// order.
	func (b TextBuffer) ApplyTag(tag TextTagClass, start *TextIter, end *TextIter)  {
var _arg0 *C.GtkTextBuffer // out
var _arg1 *C.GtkTextTag // out
var _arg2 *C.GtkTextIter // out
var _arg3 *C.GtkTextIter // out

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkTextTag)(unsafe.Pointer(tag.Native()))
_arg2 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
_arg3 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

C.gtk_text_buffer_apply_tag(_arg0, _arg1, _arg2, _arg3)
}
	
	// ApplyTagByName calls gtk_text_tag_table_lookup() on the buffer’s tag table to
// get a TextTag, then calls gtk_text_buffer_apply_tag().
	func (b TextBuffer) ApplyTagByName(name string, start *TextIter, end *TextIter)  {
var _arg0 *C.GtkTextBuffer // out
var _arg1 *C.gchar // out
var _arg2 *C.GtkTextIter // out
var _arg3 *C.GtkTextIter // out

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (*C.gchar)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
_arg3 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

C.gtk_text_buffer_apply_tag_by_name(_arg0, _arg1, _arg2, _arg3)
}
	
	// Backspace performs the appropriate action as if the user hit the delete key
// with the cursor at the position specified by @iter. In the normal case a
// single character will be deleted, but when combining accents are involved,
// more than one character can be deleted, and when precomposed character and
// accent combinations are involved, less than one character will be deleted.
// 
// Because the buffer is modified, all outstanding iterators become invalid
// after calling this function; however, the @iter will be re-initialized to
// point to the location where text was deleted.
	func (b TextBuffer) Backspace(iter *TextIter, interactive bool, defaultEditable bool) bool {
var _arg0 *C.GtkTextBuffer // out
var _arg1 *C.GtkTextIter // out
var _arg2 C.gboolean // out
var _arg3 C.gboolean // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))
if interactive { _arg2 = C.TRUE }
if defaultEditable { _arg3 = C.TRUE }

_cret = C.gtk_text_buffer_backspace(_arg0, _arg1, _arg2, _arg3)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// BeginUserAction: called to indicate that the buffer operations between here
// and a call to gtk_text_buffer_end_user_action() are part of a single
// user-visible operation. The operations between
// gtk_text_buffer_begin_user_action() and gtk_text_buffer_end_user_action() can
// then be grouped when creating an undo stack. TextBuffer maintains a count of
// calls to gtk_text_buffer_begin_user_action() that have not been closed with a
// call to gtk_text_buffer_end_user_action(), and emits the “begin-user-action”
// and “end-user-action” signals only for the outermost pair of calls. This
// allows you to build user actions from other user actions.
// 
// The “interactive” buffer mutation functions, such as
// gtk_text_buffer_insert_interactive(), automatically call begin/end user
// action around the buffer operations they perform, so there's no need to add
// extra calls if you user action consists solely of a single call to one of
// those functions.
	func (b TextBuffer) BeginUserAction()  {
var _arg0 *C.GtkTextBuffer // out

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

C.gtk_text_buffer_begin_user_action(_arg0)
}
	
	// CopyClipboard copies the currently-selected text to a clipboard.
	func (b TextBuffer) CopyClipboard(clipboard ClipboardClass)  {
var _arg0 *C.GtkTextBuffer // out
var _arg1 *C.GtkClipboard // out

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkClipboard)(unsafe.Pointer(clipboard.Native()))

C.gtk_text_buffer_copy_clipboard(_arg0, _arg1)
}
	
	// CreateChildAnchor: this is a convenience function which simply creates a
// child anchor with gtk_text_child_anchor_new() and inserts it into the buffer
// with gtk_text_buffer_insert_child_anchor(). The new anchor is owned by the
// buffer; no reference count is returned to the caller of
// gtk_text_buffer_create_child_anchor().
	func (b TextBuffer) CreateChildAnchor(iter *TextIter) TextChildAnchor {
var _arg0 *C.GtkTextBuffer // out
var _arg1 *C.GtkTextIter // out
var _cret *C.GtkTextChildAnchor // in

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))

_cret = C.gtk_text_buffer_create_child_anchor(_arg0, _arg1)


var _textChildAnchor TextChildAnchor // out

_textChildAnchor = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TextChildAnchor)

return _textChildAnchor
}
	
	// CreateMark creates a mark at position @where. If @mark_name is nil, the mark
// is anonymous; otherwise, the mark can be retrieved by name using
// gtk_text_buffer_get_mark(). If a mark has left gravity, and text is inserted
// at the mark’s current location, the mark will be moved to the left of the
// newly-inserted text. If the mark has right gravity (@left_gravity = false),
// the mark will end up on the right of newly-inserted text. The standard
// left-to-right cursor is a mark with right gravity (when you type, the cursor
// stays on the right side of the text you’re typing).
// 
// The caller of this function does not own a reference to the returned
// TextMark, so you can ignore the return value if you like. Marks are owned by
// the buffer and go away when the buffer does.
// 
// Emits the TextBuffer::mark-set signal as notification of the mark's initial
// placement.
	func (b TextBuffer) CreateMark(markName string, where *TextIter, leftGravity bool) TextMark {
var _arg0 *C.GtkTextBuffer // out
var _arg1 *C.gchar // out
var _arg2 *C.GtkTextIter // out
var _arg3 C.gboolean // out
var _cret *C.GtkTextMark // in

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (*C.gchar)(C.CString(markName))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.GtkTextIter)(unsafe.Pointer(where.Native()))
if leftGravity { _arg3 = C.TRUE }

_cret = C.gtk_text_buffer_create_mark(_arg0, _arg1, _arg2, _arg3)


var _textMark TextMark // out

_textMark = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TextMark)

return _textMark
}
	
	// CutClipboard copies the currently-selected text to a clipboard, then deletes
// said text if it’s editable.
	func (b TextBuffer) CutClipboard(clipboard ClipboardClass, defaultEditable bool)  {
var _arg0 *C.GtkTextBuffer // out
var _arg1 *C.GtkClipboard // out
var _arg2 C.gboolean // out

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkClipboard)(unsafe.Pointer(clipboard.Native()))
if defaultEditable { _arg2 = C.TRUE }

C.gtk_text_buffer_cut_clipboard(_arg0, _arg1, _arg2)
}
	
	// Delete deletes text between @start and @end. The order of @start and @end is
// not actually relevant; gtk_text_buffer_delete() will reorder them. This
// function actually emits the “delete-range” signal, and the default handler of
// that signal deletes the text. Because the buffer is modified, all outstanding
// iterators become invalid after calling this function; however, the @start and
// @end will be re-initialized to point to the location where text was deleted.
	func (b TextBuffer) Delete(start *TextIter, end *TextIter)  {
var _arg0 *C.GtkTextBuffer // out
var _arg1 *C.GtkTextIter // out
var _arg2 *C.GtkTextIter // out

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
_arg2 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

C.gtk_text_buffer_delete(_arg0, _arg1, _arg2)
}
	
	// DeleteInteractive deletes all editable text in the given range. Calls
// gtk_text_buffer_delete() for each editable sub-range of [@start,@end). @start
// and @end are revalidated to point to the location of the last deleted range,
// or left untouched if no text was deleted.
	func (b TextBuffer) DeleteInteractive(startIter *TextIter, endIter *TextIter, defaultEditable bool) bool {
var _arg0 *C.GtkTextBuffer // out
var _arg1 *C.GtkTextIter // out
var _arg2 *C.GtkTextIter // out
var _arg3 C.gboolean // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkTextIter)(unsafe.Pointer(startIter.Native()))
_arg2 = (*C.GtkTextIter)(unsafe.Pointer(endIter.Native()))
if defaultEditable { _arg3 = C.TRUE }

_cret = C.gtk_text_buffer_delete_interactive(_arg0, _arg1, _arg2, _arg3)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// DeleteMark deletes @mark, so that it’s no longer located anywhere in the
// buffer. Removes the reference the buffer holds to the mark, so if you haven’t
// called g_object_ref() on the mark, it will be freed. Even if the mark isn’t
// freed, most operations on @mark become invalid, until it gets added to a
// buffer again with gtk_text_buffer_add_mark(). Use gtk_text_mark_get_deleted()
// to find out if a mark has been removed from its buffer. The
// TextBuffer::mark-deleted signal will be emitted as notification after the
// mark is deleted.
	func (b TextBuffer) DeleteMark(mark TextMarkClass)  {
var _arg0 *C.GtkTextBuffer // out
var _arg1 *C.GtkTextMark // out

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkTextMark)(unsafe.Pointer(mark.Native()))

C.gtk_text_buffer_delete_mark(_arg0, _arg1)
}
	
	// DeleteMarkByName deletes the mark named @name; the mark must exist. See
// gtk_text_buffer_delete_mark() for details.
	func (b TextBuffer) DeleteMarkByName(name string)  {
var _arg0 *C.GtkTextBuffer // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (*C.gchar)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_text_buffer_delete_mark_by_name(_arg0, _arg1)
}
	
	// DeleteSelection deletes the range between the “insert” and “selection_bound”
// marks, that is, the currently-selected text. If @interactive is true, the
// editability of the selection will be considered (users can’t delete
// uneditable text).
	func (b TextBuffer) DeleteSelection(interactive bool, defaultEditable bool) bool {
var _arg0 *C.GtkTextBuffer // out
var _arg1 C.gboolean // out
var _arg2 C.gboolean // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
if interactive { _arg1 = C.TRUE }
if defaultEditable { _arg2 = C.TRUE }

_cret = C.gtk_text_buffer_delete_selection(_arg0, _arg1, _arg2)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Deserialize: this function deserializes rich text in format @format and
// inserts it at @iter.
// 
// @formats to be used must be registered using
// gtk_text_buffer_register_deserialize_format() or
// gtk_text_buffer_register_deserialize_tagset() beforehand.
	func (r TextBuffer) Deserialize(contentBuffer TextBufferClass, format *gdk.Atom, iter *TextIter, data []byte) error {
var _arg0 *C.GtkTextBuffer // out
var _arg1 *C.GtkTextBuffer // out
var _arg2 C.GdkAtom // out
var _arg3 *C.GtkTextIter // out
var _arg4 *C.guint8
var _arg5 C.gsize
var _cerr *C.GError // in

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(r.Native()))
_arg1 = (*C.GtkTextBuffer)(unsafe.Pointer(contentBuffer.Native()))
_arg2 = (C.GdkAtom)(unsafe.Pointer(format.Native()))
_arg3 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))
_arg5 = C.gsize(len(data))
_arg4 = (*C.guint8)(unsafe.Pointer(&data[0]))

C.gtk_text_buffer_deserialize(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// DeserializeGetCanCreateTags: this functions returns the value set with
// gtk_text_buffer_deserialize_set_can_create_tags()
	func (b TextBuffer) DeserializeGetCanCreateTags(format *gdk.Atom) bool {
var _arg0 *C.GtkTextBuffer // out
var _arg1 C.GdkAtom // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (C.GdkAtom)(unsafe.Pointer(format.Native()))

_cret = C.gtk_text_buffer_deserialize_get_can_create_tags(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// DeserializeSetCanCreateTags: use this function to allow a rich text
// deserialization function to create new tags in the receiving buffer. Note
// that using this function is almost always a bad idea, because the rich text
// functions you register should know how to map the rich text format they
// handler to your text buffers set of tags.
// 
// The ability of creating new (arbitrary!) tags in the receiving buffer is
// meant for special rich text formats like the internal one that is registered
// using gtk_text_buffer_register_deserialize_tagset(), because that format is
// essentially a dump of the internal structure of the source buffer, including
// its tag names.
// 
// You should allow creation of tags only if you know what you are doing, e.g.
// if you defined a tagset name for your application suite’s text buffers and
// you know that it’s fine to receive new tags from these buffers, because you
// know that your application can handle the newly created tags.
	func (b TextBuffer) DeserializeSetCanCreateTags(format *gdk.Atom, canCreateTags bool)  {
var _arg0 *C.GtkTextBuffer // out
var _arg1 C.GdkAtom // out
var _arg2 C.gboolean // out

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (C.GdkAtom)(unsafe.Pointer(format.Native()))
if canCreateTags { _arg2 = C.TRUE }

C.gtk_text_buffer_deserialize_set_can_create_tags(_arg0, _arg1, _arg2)
}
	
	// EndUserAction: should be paired with a call to
// gtk_text_buffer_begin_user_action(). See that function for a full
// explanation.
	func (b TextBuffer) EndUserAction()  {
var _arg0 *C.GtkTextBuffer // out

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

C.gtk_text_buffer_end_user_action(_arg0)
}
	
	// Bounds retrieves the first and last iterators in the buffer, i.e. the entire
// buffer lies within the range [@start,@end).
	func (b TextBuffer) Bounds() (start TextIter, end TextIter) {
var _arg0 *C.GtkTextBuffer // out
var _start TextIter
var _end TextIter

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

C.gtk_text_buffer_get_bounds(_arg0, (*C.GtkTextIter)(unsafe.Pointer(&_start)), (*C.GtkTextIter)(unsafe.Pointer(&_end)))







return _start, _end
}
	
	// CharCount gets the number of characters in the buffer; note that characters
// and bytes are not the same, you can’t e.g. expect the contents of the buffer
// in string form to be this many bytes long. The character count is cached, so
// this function is very fast.
	func (b TextBuffer) CharCount() int {
var _arg0 *C.GtkTextBuffer // out
var _cret C.gint // in

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

_cret = C.gtk_text_buffer_get_char_count(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// CopyTargetList: this function returns the list of targets this text buffer
// can provide for copying and as DND source. The targets in the list are added
// with @info values from the TextBufferTargetInfo enum, using
// gtk_target_list_add_rich_text_targets() and
// gtk_target_list_add_text_targets().
	func (b TextBuffer) CopyTargetList() *TargetList {
var _arg0 *C.GtkTextBuffer // out
var _cret *C.GtkTargetList // in

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

_cret = C.gtk_text_buffer_get_copy_target_list(_arg0)


var _targetList *TargetList // out

_targetList = *(**TargetList)(unsafe.Pointer(&_cret))

return _targetList
}
	
	// EndIter initializes @iter with the “end iterator,” one past the last valid
// character in the text buffer. If dereferenced with gtk_text_iter_get_char(),
// the end iterator has a character value of 0. The entire buffer lies in the
// range from the first position in the buffer (call
// gtk_text_buffer_get_start_iter() to get character position 0) to the end
// iterator.
	func (b TextBuffer) EndIter() TextIter {
var _arg0 *C.GtkTextBuffer // out
var _iter TextIter

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

C.gtk_text_buffer_get_end_iter(_arg0, (*C.GtkTextIter)(unsafe.Pointer(&_iter)))





return _iter
}
	
	// HasSelection indicates whether the buffer has some text currently selected.
	func (b TextBuffer) HasSelection() bool {
var _arg0 *C.GtkTextBuffer // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

_cret = C.gtk_text_buffer_get_has_selection(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// GetInsert returns the mark that represents the cursor (insertion point).
// Equivalent to calling gtk_text_buffer_get_mark() to get the mark named
// “insert”, but very slightly more efficient, and involves less typing.
	func (b TextBuffer) GetInsert() TextMark {
var _arg0 *C.GtkTextBuffer // out
var _cret *C.GtkTextMark // in

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

_cret = C.gtk_text_buffer_get_insert(_arg0)


var _textMark TextMark // out

_textMark = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TextMark)

return _textMark
}
	
	// IterAtChildAnchor obtains the location of @anchor within @buffer.
	func (b TextBuffer) IterAtChildAnchor(anchor TextChildAnchorClass) TextIter {
var _arg0 *C.GtkTextBuffer // out
var _iter TextIter
var _arg2 *C.GtkTextChildAnchor // out

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg2 = (*C.GtkTextChildAnchor)(unsafe.Pointer(anchor.Native()))

C.gtk_text_buffer_get_iter_at_child_anchor(_arg0, (*C.GtkTextIter)(unsafe.Pointer(&_iter)), _arg2)





return _iter
}
	
	// IterAtLine initializes @iter to the start of the given line. If @line_number
// is greater than the number of lines in the @buffer, the end iterator is
// returned.
	func (b TextBuffer) IterAtLine(lineNumber int) TextIter {
var _arg0 *C.GtkTextBuffer // out
var _iter TextIter
var _arg2 C.gint // out

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg2 = (C.gint)(lineNumber)

C.gtk_text_buffer_get_iter_at_line(_arg0, (*C.GtkTextIter)(unsafe.Pointer(&_iter)), _arg2)





return _iter
}
	
	// IterAtLineIndex obtains an iterator pointing to @byte_index within the given
// line. @byte_index must be the start of a UTF-8 character. Note bytes, not
// characters; UTF-8 may encode one character as multiple bytes.
// 
// Before the 3.20 version, it was not allowed to pass an invalid location.
// 
// Since the 3.20 version, if @line_number is greater than the number of lines
// in the @buffer, the end iterator is returned. And if @byte_index is off the
// end of the line, the iterator at the end of the line is returned.
	func (b TextBuffer) IterAtLineIndex(lineNumber int, byteIndex int) TextIter {
var _arg0 *C.GtkTextBuffer // out
var _iter TextIter
var _arg2 C.gint // out
var _arg3 C.gint // out

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg2 = (C.gint)(lineNumber)
_arg3 = (C.gint)(byteIndex)

C.gtk_text_buffer_get_iter_at_line_index(_arg0, (*C.GtkTextIter)(unsafe.Pointer(&_iter)), _arg2, _arg3)





return _iter
}
	
	// IterAtLineOffset obtains an iterator pointing to @char_offset within the
// given line. Note characters, not bytes; UTF-8 may encode one character as
// multiple bytes.
// 
// Before the 3.20 version, it was not allowed to pass an invalid location.
// 
// Since the 3.20 version, if @line_number is greater than the number of lines
// in the @buffer, the end iterator is returned. And if @char_offset is off the
// end of the line, the iterator at the end of the line is returned.
	func (b TextBuffer) IterAtLineOffset(lineNumber int, charOffset int) TextIter {
var _arg0 *C.GtkTextBuffer // out
var _iter TextIter
var _arg2 C.gint // out
var _arg3 C.gint // out

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg2 = (C.gint)(lineNumber)
_arg3 = (C.gint)(charOffset)

C.gtk_text_buffer_get_iter_at_line_offset(_arg0, (*C.GtkTextIter)(unsafe.Pointer(&_iter)), _arg2, _arg3)





return _iter
}
	
	// IterAtMark initializes @iter with the current position of @mark.
	func (b TextBuffer) IterAtMark(mark TextMarkClass) TextIter {
var _arg0 *C.GtkTextBuffer // out
var _iter TextIter
var _arg2 *C.GtkTextMark // out

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg2 = (*C.GtkTextMark)(unsafe.Pointer(mark.Native()))

C.gtk_text_buffer_get_iter_at_mark(_arg0, (*C.GtkTextIter)(unsafe.Pointer(&_iter)), _arg2)





return _iter
}
	
	// IterAtOffset initializes @iter to a position @char_offset chars from the
// start of the entire buffer. If @char_offset is -1 or greater than the number
// of characters in the buffer, @iter is initialized to the end iterator, the
// iterator one past the last valid character in the buffer.
	func (b TextBuffer) IterAtOffset(charOffset int) TextIter {
var _arg0 *C.GtkTextBuffer // out
var _iter TextIter
var _arg2 C.gint // out

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg2 = (C.gint)(charOffset)

C.gtk_text_buffer_get_iter_at_offset(_arg0, (*C.GtkTextIter)(unsafe.Pointer(&_iter)), _arg2)





return _iter
}
	
	// LineCount obtains the number of lines in the buffer. This value is cached, so
// the function is very fast.
	func (b TextBuffer) LineCount() int {
var _arg0 *C.GtkTextBuffer // out
var _cret C.gint // in

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

_cret = C.gtk_text_buffer_get_line_count(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Mark returns the mark named @name in buffer @buffer, or nil if no such mark
// exists in the buffer.
	func (b TextBuffer) Mark(name string) TextMark {
var _arg0 *C.GtkTextBuffer // out
var _arg1 *C.gchar // out
var _cret *C.GtkTextMark // in

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (*C.gchar)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_text_buffer_get_mark(_arg0, _arg1)


var _textMark TextMark // out

_textMark = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TextMark)

return _textMark
}
	
	// Modified indicates whether the buffer has been modified since the last call
// to gtk_text_buffer_set_modified() set the modification flag to false. Used
// for example to enable a “save” function in a text editor.
	func (b TextBuffer) Modified() bool {
var _arg0 *C.GtkTextBuffer // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

_cret = C.gtk_text_buffer_get_modified(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// PasteTargetList: this function returns the list of targets this text buffer
// supports for pasting and as DND destination. The targets in the list are
// added with @info values from the TextBufferTargetInfo enum, using
// gtk_target_list_add_rich_text_targets() and
// gtk_target_list_add_text_targets().
	func (b TextBuffer) PasteTargetList() *TargetList {
var _arg0 *C.GtkTextBuffer // out
var _cret *C.GtkTargetList // in

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

_cret = C.gtk_text_buffer_get_paste_target_list(_arg0)


var _targetList *TargetList // out

_targetList = *(**TargetList)(unsafe.Pointer(&_cret))

return _targetList
}
	
	// SelectionBound returns the mark that represents the selection bound.
// Equivalent to calling gtk_text_buffer_get_mark() to get the mark named
// “selection_bound”, but very slightly more efficient, and involves less
// typing.
// 
// The currently-selected text in @buffer is the region between the
// “selection_bound” and “insert” marks. If “selection_bound” and “insert” are
// in the same place, then there is no current selection.
// gtk_text_buffer_get_selection_bounds() is another convenient function for
// handling the selection, if you just want to know whether there’s a selection
// and what its bounds are.
	func (b TextBuffer) SelectionBound() TextMark {
var _arg0 *C.GtkTextBuffer // out
var _cret *C.GtkTextMark // in

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

_cret = C.gtk_text_buffer_get_selection_bound(_arg0)


var _textMark TextMark // out

_textMark = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TextMark)

return _textMark
}
	
	// SelectionBounds returns true if some text is selected; places the bounds of
// the selection in @start and @end (if the selection has length 0, then @start
// and @end are filled in with the same value). @start and @end will be in
// ascending order. If @start and @end are NULL, then they are not filled in,
// but the return value still indicates whether text is selected.
	func (b TextBuffer) SelectionBounds() (start TextIter, end TextIter, ok bool) {
var _arg0 *C.GtkTextBuffer // out
var _start TextIter
var _end TextIter
var _cret C.gboolean // in

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

_cret = C.gtk_text_buffer_get_selection_bounds(_arg0, (*C.GtkTextIter)(unsafe.Pointer(&_start)), (*C.GtkTextIter)(unsafe.Pointer(&_end)))




var _ok bool // out



if _cret != 0 { _ok = true }

return _start, _end, _ok
}
	
	// Slice returns the text in the range [@start,@end). Excludes undisplayed text
// (text marked with tags that set the invisibility attribute) if
// @include_hidden_chars is false. The returned string includes a 0xFFFC
// character whenever the buffer contains embedded images, so byte and character
// indexes into the returned string do correspond to byte and character indexes
// into the buffer. Contrast with gtk_text_buffer_get_text(). Note that 0xFFFC
// can occur in normal text as well, so it is not a reliable indicator that a
// pixbuf or widget is in the buffer.
	func (b TextBuffer) Slice(start *TextIter, end *TextIter, includeHiddenChars bool) string {
var _arg0 *C.GtkTextBuffer // out
var _arg1 *C.GtkTextIter // out
var _arg2 *C.GtkTextIter // out
var _arg3 C.gboolean // out
var _cret *C.gchar // in

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
_arg2 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))
if includeHiddenChars { _arg3 = C.TRUE }

_cret = C.gtk_text_buffer_get_slice(_arg0, _arg1, _arg2, _arg3)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// StartIter: initialized @iter with the first position in the text buffer. This
// is the same as using gtk_text_buffer_get_iter_at_offset() to get the iter at
// character offset 0.
	func (b TextBuffer) StartIter() TextIter {
var _arg0 *C.GtkTextBuffer // out
var _iter TextIter

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

C.gtk_text_buffer_get_start_iter(_arg0, (*C.GtkTextIter)(unsafe.Pointer(&_iter)))





return _iter
}
	
	// TagTable: get the TextTagTable associated with this buffer.
	func (b TextBuffer) TagTable() TextTagTable {
var _arg0 *C.GtkTextBuffer // out
var _cret *C.GtkTextTagTable // in

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

_cret = C.gtk_text_buffer_get_tag_table(_arg0)


var _textTagTable TextTagTable // out

_textTagTable = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TextTagTable)

return _textTagTable
}
	
	// Text returns the text in the range [@start,@end). Excludes undisplayed text
// (text marked with tags that set the invisibility attribute) if
// @include_hidden_chars is false. Does not include characters representing
// embedded images, so byte and character indexes into the returned string do
// not correspond to byte and character indexes into the buffer. Contrast with
// gtk_text_buffer_get_slice().
	func (b TextBuffer) Text(start *TextIter, end *TextIter, includeHiddenChars bool) string {
var _arg0 *C.GtkTextBuffer // out
var _arg1 *C.GtkTextIter // out
var _arg2 *C.GtkTextIter // out
var _arg3 C.gboolean // out
var _cret *C.gchar // in

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
_arg2 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))
if includeHiddenChars { _arg3 = C.TRUE }

_cret = C.gtk_text_buffer_get_text(_arg0, _arg1, _arg2, _arg3)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// Insert inserts @len bytes of @text at position @iter. If @len is -1, @text
// must be nul-terminated and will be inserted in its entirety. Emits the
// “insert-text” signal; insertion actually occurs in the default handler for
// the signal. @iter is invalidated when insertion occurs (because the buffer
// contents change), but the default signal handler revalidates it to point to
// the end of the inserted text.
	func (b TextBuffer) Insert(iter *TextIter, text string, len int)  {
var _arg0 *C.GtkTextBuffer // out
var _arg1 *C.GtkTextIter // out
var _arg2 *C.gchar // out
var _arg3 C.gint // out

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))
_arg2 = (*C.gchar)(C.CString(text))
defer C.free(unsafe.Pointer(_arg2))
_arg3 = (C.gint)(len)

C.gtk_text_buffer_insert(_arg0, _arg1, _arg2, _arg3)
}
	
	// InsertAtCursor: simply calls gtk_text_buffer_insert(), using the current
// cursor position as the insertion point.
	func (b TextBuffer) InsertAtCursor(text string, len int)  {
var _arg0 *C.GtkTextBuffer // out
var _arg1 *C.gchar // out
var _arg2 C.gint // out

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (*C.gchar)(C.CString(text))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.gint)(len)

C.gtk_text_buffer_insert_at_cursor(_arg0, _arg1, _arg2)
}
	
	// InsertChildAnchor inserts a child widget anchor into the text buffer at
// @iter. The anchor will be counted as one character in character counts, and
// when obtaining the buffer contents as a string, will be represented by the
// Unicode “object replacement character” 0xFFFC. Note that the “slice” variants
// for obtaining portions of the buffer as a string include this character for
// child anchors, but the “text” variants do not. E.g. see
// gtk_text_buffer_get_slice() and gtk_text_buffer_get_text(). Consider
// gtk_text_buffer_create_child_anchor() as a more convenient alternative to
// this function. The buffer will add a reference to the anchor, so you can
// unref it after insertion.
	func (b TextBuffer) InsertChildAnchor(iter *TextIter, anchor TextChildAnchorClass)  {
var _arg0 *C.GtkTextBuffer // out
var _arg1 *C.GtkTextIter // out
var _arg2 *C.GtkTextChildAnchor // out

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))
_arg2 = (*C.GtkTextChildAnchor)(unsafe.Pointer(anchor.Native()))

C.gtk_text_buffer_insert_child_anchor(_arg0, _arg1, _arg2)
}
	
	// InsertInteractive: like gtk_text_buffer_insert(), but the insertion will not
// occur if @iter is at a non-editable location in the buffer. Usually you want
// to prevent insertions at ineditable locations if the insertion results from a
// user action (is interactive).
// 
// @default_editable indicates the editability of text that doesn't have a tag
// affecting editability applied to it. Typically the result of
// gtk_text_view_get_editable() is appropriate here.
	func (b TextBuffer) InsertInteractive(iter *TextIter, text string, len int, defaultEditable bool) bool {
var _arg0 *C.GtkTextBuffer // out
var _arg1 *C.GtkTextIter // out
var _arg2 *C.gchar // out
var _arg3 C.gint // out
var _arg4 C.gboolean // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))
_arg2 = (*C.gchar)(C.CString(text))
defer C.free(unsafe.Pointer(_arg2))
_arg3 = (C.gint)(len)
if defaultEditable { _arg4 = C.TRUE }

_cret = C.gtk_text_buffer_insert_interactive(_arg0, _arg1, _arg2, _arg3, _arg4)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// InsertInteractiveAtCursor calls gtk_text_buffer_insert_interactive() at the
// cursor position.
// 
// @default_editable indicates the editability of text that doesn't have a tag
// affecting editability applied to it. Typically the result of
// gtk_text_view_get_editable() is appropriate here.
	func (b TextBuffer) InsertInteractiveAtCursor(text string, len int, defaultEditable bool) bool {
var _arg0 *C.GtkTextBuffer // out
var _arg1 *C.gchar // out
var _arg2 C.gint // out
var _arg3 C.gboolean // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (*C.gchar)(C.CString(text))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.gint)(len)
if defaultEditable { _arg3 = C.TRUE }

_cret = C.gtk_text_buffer_insert_interactive_at_cursor(_arg0, _arg1, _arg2, _arg3)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// InsertMarkup inserts the text in @markup at position @iter. @markup will be
// inserted in its entirety and must be nul-terminated and valid UTF-8. Emits
// the TextBuffer::insert-text signal, possibly multiple times; insertion
// actually occurs in the default handler for the signal. @iter will point to
// the end of the inserted text on return.
	func (b TextBuffer) InsertMarkup(iter *TextIter, markup string, len int)  {
var _arg0 *C.GtkTextBuffer // out
var _arg1 *C.GtkTextIter // out
var _arg2 *C.gchar // out
var _arg3 C.gint // out

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))
_arg2 = (*C.gchar)(C.CString(markup))
defer C.free(unsafe.Pointer(_arg2))
_arg3 = (C.gint)(len)

C.gtk_text_buffer_insert_markup(_arg0, _arg1, _arg2, _arg3)
}
	
	// InsertPixbuf inserts an image into the text buffer at @iter. The image will
// be counted as one character in character counts, and when obtaining the
// buffer contents as a string, will be represented by the Unicode “object
// replacement character” 0xFFFC. Note that the “slice” variants for obtaining
// portions of the buffer as a string include this character for pixbufs, but
// the “text” variants do not. e.g. see gtk_text_buffer_get_slice() and
// gtk_text_buffer_get_text().
	func (b TextBuffer) InsertPixbuf(iter *TextIter, pixbuf gdkpixbuf.PixbufClass)  {
var _arg0 *C.GtkTextBuffer // out
var _arg1 *C.GtkTextIter // out
var _arg2 *C.GdkPixbuf // out

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))
_arg2 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))

C.gtk_text_buffer_insert_pixbuf(_arg0, _arg1, _arg2)
}
	
	// InsertRange copies text, tags, and pixbufs between @start and @end (the order
// of @start and @end doesn’t matter) and inserts the copy at @iter. Used
// instead of simply getting/inserting text because it preserves images and
// tags. If @start and @end are in a different buffer from @buffer, the two
// buffers must share the same tag table.
// 
// Implemented via emissions of the insert_text and apply_tag signals, so expect
// those.
	func (b TextBuffer) InsertRange(iter *TextIter, start *TextIter, end *TextIter)  {
var _arg0 *C.GtkTextBuffer // out
var _arg1 *C.GtkTextIter // out
var _arg2 *C.GtkTextIter // out
var _arg3 *C.GtkTextIter // out

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))
_arg2 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
_arg3 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

C.gtk_text_buffer_insert_range(_arg0, _arg1, _arg2, _arg3)
}
	
	// InsertRangeInteractive: same as gtk_text_buffer_insert_range(), but does
// nothing if the insertion point isn’t editable. The @default_editable
// parameter indicates whether the text is editable at @iter if no tags
// enclosing @iter affect editability. Typically the result of
// gtk_text_view_get_editable() is appropriate here.
	func (b TextBuffer) InsertRangeInteractive(iter *TextIter, start *TextIter, end *TextIter, defaultEditable bool) bool {
var _arg0 *C.GtkTextBuffer // out
var _arg1 *C.GtkTextIter // out
var _arg2 *C.GtkTextIter // out
var _arg3 *C.GtkTextIter // out
var _arg4 C.gboolean // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))
_arg2 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
_arg3 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))
if defaultEditable { _arg4 = C.TRUE }

_cret = C.gtk_text_buffer_insert_range_interactive(_arg0, _arg1, _arg2, _arg3, _arg4)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// MoveMark moves @mark to the new location @where. Emits the
// TextBuffer::mark-set signal as notification of the move.
	func (b TextBuffer) MoveMark(mark TextMarkClass, where *TextIter)  {
var _arg0 *C.GtkTextBuffer // out
var _arg1 *C.GtkTextMark // out
var _arg2 *C.GtkTextIter // out

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkTextMark)(unsafe.Pointer(mark.Native()))
_arg2 = (*C.GtkTextIter)(unsafe.Pointer(where.Native()))

C.gtk_text_buffer_move_mark(_arg0, _arg1, _arg2)
}
	
	// MoveMarkByName moves the mark named @name (which must exist) to location
// @where. See gtk_text_buffer_move_mark() for details.
	func (b TextBuffer) MoveMarkByName(name string, where *TextIter)  {
var _arg0 *C.GtkTextBuffer // out
var _arg1 *C.gchar // out
var _arg2 *C.GtkTextIter // out

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (*C.gchar)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.GtkTextIter)(unsafe.Pointer(where.Native()))

C.gtk_text_buffer_move_mark_by_name(_arg0, _arg1, _arg2)
}
	
	// PasteClipboard pastes the contents of a clipboard. If @override_location is
// nil, the pasted text will be inserted at the cursor position, or the buffer
// selection will be replaced if the selection is non-empty.
// 
// Note: pasting is asynchronous, that is, we’ll ask for the paste data and
// return, and at some point later after the main loop runs, the paste data will
// be inserted.
	func (b TextBuffer) PasteClipboard(clipboard ClipboardClass, overrideLocation *TextIter, defaultEditable bool)  {
var _arg0 *C.GtkTextBuffer // out
var _arg1 *C.GtkClipboard // out
var _arg2 *C.GtkTextIter // out
var _arg3 C.gboolean // out

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkClipboard)(unsafe.Pointer(clipboard.Native()))
_arg2 = (*C.GtkTextIter)(unsafe.Pointer(overrideLocation.Native()))
if defaultEditable { _arg3 = C.TRUE }

C.gtk_text_buffer_paste_clipboard(_arg0, _arg1, _arg2, _arg3)
}
	
	// PlaceCursor: this function moves the “insert” and “selection_bound” marks
// simultaneously. If you move them to the same place in two steps with
// gtk_text_buffer_move_mark(), you will temporarily select a region in between
// their old and new locations, which can be pretty inefficient since the
// temporarily-selected region will force stuff to be recalculated. This
// function moves them as a unit, which can be optimized.
	func (b TextBuffer) PlaceCursor(where *TextIter)  {
var _arg0 *C.GtkTextBuffer // out
var _arg1 *C.GtkTextIter // out

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkTextIter)(unsafe.Pointer(where.Native()))

C.gtk_text_buffer_place_cursor(_arg0, _arg1)
}
	
	// RegisterDeserializeTagset: this function registers GTK+’s internal rich text
// serialization format with the passed @buffer. See
// gtk_text_buffer_register_serialize_tagset() for details.
	func (b TextBuffer) RegisterDeserializeTagset(tagsetName string) *gdk.Atom {
var _arg0 *C.GtkTextBuffer // out
var _arg1 *C.gchar // out
var _cret C.GdkAtom // in

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (*C.gchar)(C.CString(tagsetName))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_text_buffer_register_deserialize_tagset(_arg0, _arg1)


var _atom *gdk.Atom // out

_atom = *(**gdk.Atom)(unsafe.Pointer(&_cret))

return _atom
}
	
	// RegisterSerializeTagset: this function registers GTK+’s internal rich text
// serialization format with the passed @buffer. The internal format does not
// comply to any standard rich text format and only works between TextBuffer
// instances. It is capable of serializing all of a text buffer’s tags and
// embedded pixbufs.
// 
// This function is just a wrapper around
// gtk_text_buffer_register_serialize_format(). The mime type used for
// registering is “application/x-gtk-text-buffer-rich-text”, or
// “application/x-gtk-text-buffer-rich-text;format=@tagset_name” if a
// @tagset_name was passed.
// 
// The @tagset_name can be used to restrict the transfer of rich text to buffers
// with compatible sets of tags, in order to avoid unknown tags from being
// pasted. It is probably the common case to pass an identifier != nil here,
// since the nil tagset requires the receiving buffer to deal with with pasting
// of arbitrary tags.
	func (b TextBuffer) RegisterSerializeTagset(tagsetName string) *gdk.Atom {
var _arg0 *C.GtkTextBuffer // out
var _arg1 *C.gchar // out
var _cret C.GdkAtom // in

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (*C.gchar)(C.CString(tagsetName))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_text_buffer_register_serialize_tagset(_arg0, _arg1)


var _atom *gdk.Atom // out

_atom = *(**gdk.Atom)(unsafe.Pointer(&_cret))

return _atom
}
	
	// RemoveAllTags removes all tags in the range between @start and @end. Be
// careful with this function; it could remove tags added in code unrelated to
// the code you’re currently writing. That is, using this function is probably a
// bad idea if you have two or more unrelated code sections that add tags.
	func (b TextBuffer) RemoveAllTags(start *TextIter, end *TextIter)  {
var _arg0 *C.GtkTextBuffer // out
var _arg1 *C.GtkTextIter // out
var _arg2 *C.GtkTextIter // out

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
_arg2 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

C.gtk_text_buffer_remove_all_tags(_arg0, _arg1, _arg2)
}
	
	// RemoveSelectionClipboard removes a Clipboard added with
// gtk_text_buffer_add_selection_clipboard().
	func (b TextBuffer) RemoveSelectionClipboard(clipboard ClipboardClass)  {
var _arg0 *C.GtkTextBuffer // out
var _arg1 *C.GtkClipboard // out

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkClipboard)(unsafe.Pointer(clipboard.Native()))

C.gtk_text_buffer_remove_selection_clipboard(_arg0, _arg1)
}
	
	// RemoveTag emits the “remove-tag” signal. The default handler for the signal
// removes all occurrences of @tag from the given range. @start and @end don’t
// have to be in order.
	func (b TextBuffer) RemoveTag(tag TextTagClass, start *TextIter, end *TextIter)  {
var _arg0 *C.GtkTextBuffer // out
var _arg1 *C.GtkTextTag // out
var _arg2 *C.GtkTextIter // out
var _arg3 *C.GtkTextIter // out

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkTextTag)(unsafe.Pointer(tag.Native()))
_arg2 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
_arg3 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

C.gtk_text_buffer_remove_tag(_arg0, _arg1, _arg2, _arg3)
}
	
	// RemoveTagByName calls gtk_text_tag_table_lookup() on the buffer’s tag table
// to get a TextTag, then calls gtk_text_buffer_remove_tag().
	func (b TextBuffer) RemoveTagByName(name string, start *TextIter, end *TextIter)  {
var _arg0 *C.GtkTextBuffer // out
var _arg1 *C.gchar // out
var _arg2 *C.GtkTextIter // out
var _arg3 *C.GtkTextIter // out

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (*C.gchar)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
_arg3 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

C.gtk_text_buffer_remove_tag_by_name(_arg0, _arg1, _arg2, _arg3)
}
	
	// SelectRange: this function moves the “insert” and “selection_bound” marks
// simultaneously. If you move them in two steps with
// gtk_text_buffer_move_mark(), you will temporarily select a region in between
// their old and new locations, which can be pretty inefficient since the
// temporarily-selected region will force stuff to be recalculated. This
// function moves them as a unit, which can be optimized.
	func (b TextBuffer) SelectRange(ins *TextIter, bound *TextIter)  {
var _arg0 *C.GtkTextBuffer // out
var _arg1 *C.GtkTextIter // out
var _arg2 *C.GtkTextIter // out

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkTextIter)(unsafe.Pointer(ins.Native()))
_arg2 = (*C.GtkTextIter)(unsafe.Pointer(bound.Native()))

C.gtk_text_buffer_select_range(_arg0, _arg1, _arg2)
}
	
	// SetModified: used to keep track of whether the buffer has been modified since
// the last time it was saved. Whenever the buffer is saved to disk, call
// gtk_text_buffer_set_modified (@buffer, FALSE). When the buffer is modified,
// it will automatically toggled on the modified bit again. When the modified
// bit flips, the buffer emits the TextBuffer::modified-changed signal.
	func (b TextBuffer) SetModified(setting bool)  {
var _arg0 *C.GtkTextBuffer // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
if setting { _arg1 = C.TRUE }

C.gtk_text_buffer_set_modified(_arg0, _arg1)
}
	
	// SetText deletes current contents of @buffer, and inserts @text instead. If
// @len is -1, @text must be nul-terminated. @text must be valid UTF-8.
	func (b TextBuffer) SetText(text string, len int)  {
var _arg0 *C.GtkTextBuffer // out
var _arg1 *C.gchar // out
var _arg2 C.gint // out

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (*C.gchar)(C.CString(text))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.gint)(len)

C.gtk_text_buffer_set_text(_arg0, _arg1, _arg2)
}
	
	// UnregisterDeserializeFormat: this function unregisters a rich text format
// that was previously registered using
// gtk_text_buffer_register_deserialize_format() or
// gtk_text_buffer_register_deserialize_tagset().
	func (b TextBuffer) UnregisterDeserializeFormat(format *gdk.Atom)  {
var _arg0 *C.GtkTextBuffer // out
var _arg1 C.GdkAtom // out

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (C.GdkAtom)(unsafe.Pointer(format.Native()))

C.gtk_text_buffer_unregister_deserialize_format(_arg0, _arg1)
}
	
	// UnregisterSerializeFormat: this function unregisters a rich text format that
// was previously registered using gtk_text_buffer_register_serialize_format()
// or gtk_text_buffer_register_serialize_tagset()
	func (b TextBuffer) UnregisterSerializeFormat(format *gdk.Atom)  {
var _arg0 *C.GtkTextBuffer // out
var _arg1 C.GdkAtom // out

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (C.GdkAtom)(unsafe.Pointer(format.Native()))

C.gtk_text_buffer_unregister_serialize_format(_arg0, _arg1)
}
	


	// TextChildAnchor: a TextChildAnchor is a spot in the buffer where child
// widgets can be “anchored” (inserted inline, as if they were characters). The
// anchor can have multiple widgets anchored, to allow for multiple views.
	type TextChildAnchor struct {
		**externglib.Object
		
	}

	// TextChildAnchorClass is an interface that the TextChildAnchor class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type TextChildAnchorClass interface {
		gextras.Objector
		_textChildAnchor()
	}

	func (TextChildAnchor) _textChildAnchor() {}

	
	func marshalTextChildAnchor(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapTextChildAnchor(obj), nil
	}
	

	
	// NewTextChildAnchor creates a new TextChildAnchor. Usually you would then
// insert it into a TextBuffer with gtk_text_buffer_insert_child_anchor(). To
// perform the creation and insertion in one step, use the convenience function
// gtk_text_buffer_create_child_anchor().
	func NewTextChildAnchor() TextChildAnchor {
var _cret *C.GtkTextChildAnchor // in

_cret = C.gtk_text_child_anchor_new()


var _textChildAnchor TextChildAnchor // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_textChildAnchor = TextChildAnchor{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}

return _textChildAnchor
}
	

	
	// Deleted determines whether a child anchor has been deleted from the buffer.
// Keep in mind that the child anchor will be unreferenced when removed from the
// buffer, so you need to hold your own reference (with g_object_ref()) if you
// plan to use this function — otherwise all deleted child anchors will also be
// finalized.
	func (a TextChildAnchor) Deleted() bool {
var _arg0 *C.GtkTextChildAnchor // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextChildAnchor)(unsafe.Pointer(a.Native()))

_cret = C.gtk_text_child_anchor_get_deleted(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	


	// TextMark: you may wish to begin by reading the [text widget conceptual
// overview][TextWidget] which gives an overview of all the objects and data
// types related to the text widget and how they work together.
// 
// A TextMark is like a bookmark in a text buffer; it preserves a position in
// the text. You can convert the mark to an iterator using
// gtk_text_buffer_get_iter_at_mark(). Unlike iterators, marks remain valid
// across buffer mutations, because their behavior is defined when text is
// inserted or deleted. When text containing a mark is deleted, the mark remains
// in the position originally occupied by the deleted text. When text is
// inserted at a mark, a mark with “left gravity” will be moved to the beginning
// of the newly-inserted text, and a mark with “right gravity” will be moved to
// the end.
// 
// Note that “left” and “right” here refer to logical direction (left is the
// toward the start of the buffer); in some languages such as Hebrew the
// logically-leftmost text is not actually on the left when displayed.
// 
// Marks are reference counted, but the reference count only controls the
// validity of the memory; marks can be deleted from the buffer at any time with
// gtk_text_buffer_delete_mark(). Once deleted from the buffer, a mark is
// essentially useless.
// 
// Marks optionally have names; these can be convenient to avoid passing the
// TextMark object around.
// 
// Marks are typically created using the gtk_text_buffer_create_mark() function.
	type TextMark struct {
		**externglib.Object
		
	}

	// TextMarkClass is an interface that the TextMark class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type TextMarkClass interface {
		gextras.Objector
		_textMark()
	}

	func (TextMark) _textMark() {}

	
	func marshalTextMark(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapTextMark(obj), nil
	}
	

	
	// NewTextMark creates a text mark. Add it to a buffer using
// gtk_text_buffer_add_mark(). If @name is nil, the mark is anonymous;
// otherwise, the mark can be retrieved by name using
// gtk_text_buffer_get_mark(). If a mark has left gravity, and text is inserted
// at the mark’s current location, the mark will be moved to the left of the
// newly-inserted text. If the mark has right gravity (@left_gravity = false),
// the mark will end up on the right of newly-inserted text. The standard
// left-to-right cursor is a mark with right gravity (when you type, the cursor
// stays on the right side of the text you’re typing).
	func NewTextMark(name string, leftGravity bool) TextMark {
var _arg1 *C.gchar // out
var _arg2 C.gboolean // out
var _cret *C.GtkTextMark // in

_arg1 = (*C.gchar)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))
if leftGravity { _arg2 = C.TRUE }

_cret = C.gtk_text_mark_new(_arg1, _arg2)


var _textMark TextMark // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_textMark = TextMark{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}

return _textMark
}
	

	
	// Buffer gets the buffer this mark is located inside, or nil if the mark is
// deleted.
	func (m TextMark) Buffer() TextBuffer {
var _arg0 *C.GtkTextMark // out
var _cret *C.GtkTextBuffer // in

_arg0 = (*C.GtkTextMark)(unsafe.Pointer(m.Native()))

_cret = C.gtk_text_mark_get_buffer(_arg0)


var _textBuffer TextBuffer // out

_textBuffer = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TextBuffer)

return _textBuffer
}
	
	// Deleted returns true if the mark has been removed from its buffer with
// gtk_text_buffer_delete_mark(). See gtk_text_buffer_add_mark() for a way to
// add it to a buffer again.
	func (m TextMark) Deleted() bool {
var _arg0 *C.GtkTextMark // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextMark)(unsafe.Pointer(m.Native()))

_cret = C.gtk_text_mark_get_deleted(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// LeftGravity determines whether the mark has left gravity.
	func (m TextMark) LeftGravity() bool {
var _arg0 *C.GtkTextMark // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextMark)(unsafe.Pointer(m.Native()))

_cret = C.gtk_text_mark_get_left_gravity(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Name returns the mark name; returns NULL for anonymous marks.
	func (m TextMark) Name() string {
var _arg0 *C.GtkTextMark // out
var _cret *C.gchar // in

_arg0 = (*C.GtkTextMark)(unsafe.Pointer(m.Native()))

_cret = C.gtk_text_mark_get_name(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Visible returns true if the mark is visible (i.e. a cursor is displayed for
// it).
	func (m TextMark) Visible() bool {
var _arg0 *C.GtkTextMark // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextMark)(unsafe.Pointer(m.Native()))

_cret = C.gtk_text_mark_get_visible(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetVisible sets the visibility of @mark; the insertion point is normally
// visible, i.e. you can see it as a vertical bar. Also, the text widget uses a
// visible mark to indicate where a drop will occur when dragging-and-dropping
// text. Most other marks are not visible. Marks are not visible by default.
	func (m TextMark) SetVisible(setting bool)  {
var _arg0 *C.GtkTextMark // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkTextMark)(unsafe.Pointer(m.Native()))
if setting { _arg1 = C.TRUE }

C.gtk_text_mark_set_visible(_arg0, _arg1)
}
	


	// TextTag: you may wish to begin by reading the [text widget conceptual
// overview][TextWidget] which gives an overview of all the objects and data
// types related to the text widget and how they work together.
// 
// Tags should be in the TextTagTable for a given TextBuffer before using them
// with that buffer.
// 
// gtk_text_buffer_create_tag() is the best way to create tags. See “gtk3-demo”
// for numerous examples.
// 
// For each property of TextTag, there is a “set” property, e.g. “font-set”
// corresponds to “font”. These “set” properties reflect whether a property has
// been set or not. They are maintained by GTK+ and you should not set them
// independently.
	type TextTag struct {
		**externglib.Object
		
	}

	// TextTagClass is an interface that the TextTag class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type TextTagClass interface {
		gextras.Objector
		_textTag()
	}

	func (TextTag) _textTag() {}

	
	func marshalTextTag(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapTextTag(obj), nil
	}
	

	
	// NewTextTag creates a TextTag. Configure the tag using object arguments, i.e.
// using g_object_set().
	func NewTextTag(name string) TextTag {
var _arg1 *C.gchar // out
var _cret *C.GtkTextTag // in

_arg1 = (*C.gchar)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_text_tag_new(_arg1)


var _textTag TextTag // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_textTag = TextTag{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}

return _textTag
}
	

	
	// Changed emits the TextTagTable::tag-changed signal on the TextTagTable where
// the tag is included.
// 
// The signal is already emitted when setting a TextTag property. This function
// is useful for a TextTag subclass.
	func (t TextTag) Changed(sizeChanged bool)  {
var _arg0 *C.GtkTextTag // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkTextTag)(unsafe.Pointer(t.Native()))
if sizeChanged { _arg1 = C.TRUE }

C.gtk_text_tag_changed(_arg0, _arg1)
}
	
	// Priority: get the tag priority.
	func (t TextTag) Priority() int {
var _arg0 *C.GtkTextTag // out
var _cret C.gint // in

_arg0 = (*C.GtkTextTag)(unsafe.Pointer(t.Native()))

_cret = C.gtk_text_tag_get_priority(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// SetPriority sets the priority of a TextTag. Valid priorities start at 0 and
// go to one less than gtk_text_tag_table_get_size(). Each tag in a table has a
// unique priority; setting the priority of one tag shifts the priorities of all
// the other tags in the table to maintain a unique priority for each tag.
// Higher priority tags “win” if two tags both set the same text attribute. When
// adding a tag to a tag table, it will be assigned the highest priority in the
// table by default; so normally the precedence of a set of tags is the order in
// which they were added to the table, or created with
// gtk_text_buffer_create_tag(), which adds the tag to the buffer’s table
// automatically.
	func (t TextTag) SetPriority(priority int)  {
var _arg0 *C.GtkTextTag // out
var _arg1 C.gint // out

_arg0 = (*C.GtkTextTag)(unsafe.Pointer(t.Native()))
_arg1 = (C.gint)(priority)

C.gtk_text_tag_set_priority(_arg0, _arg1)
}
	


	// TextTagTable: you may wish to begin by reading the [text widget conceptual
// overview][TextWidget] which gives an overview of all the objects and data
// types related to the text widget and how they work together.
// 
// 
// GtkTextTagTables as GtkBuildable
// 
// The GtkTextTagTable implementation of the GtkBuildable interface supports
// adding tags by specifying “tag” as the “type” attribute of a <child> element.
// 
// An example of a UI definition fragment specifying tags:
// 
//    <object class="GtkTextTagTable">
//     <child type="tag">
//       <object class="GtkTextTag"/>
//     </child>
//    </object>
	type TextTagTable struct {
		**externglib.Object
		Buildable
		
	}

	// TextTagTableClass is an interface that the TextTagTable class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type TextTagTableClass interface {
		gextras.Objector
		_textTagTable()
	}

	func (TextTagTable) _textTagTable() {}

	
	func marshalTextTagTable(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapTextTagTable(obj), nil
	}
	

	
	// NewTextTagTable creates a new TextTagTable. The table contains no tags by
// default.
	func NewTextTagTable() TextTagTable {
var _cret *C.GtkTextTagTable // in

_cret = C.gtk_text_tag_table_new()


var _textTagTable TextTagTable // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_textTagTable = TextTagTable{
Object: &externglib.Object{externglib.ToGObject(obj)},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _textTagTable
}
	

	
	// Add: add a tag to the table. The tag is assigned the highest priority in the
// table.
// 
// @tag must not be in a tag table already, and may not have the same name as an
// already-added tag.
	func (t TextTagTable) Add(tag TextTagClass) bool {
var _arg0 *C.GtkTextTagTable // out
var _arg1 *C.GtkTextTag // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextTagTable)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTextTag)(unsafe.Pointer(tag.Native()))

_cret = C.gtk_text_tag_table_add(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Size returns the size of the table (number of tags)
	func (t TextTagTable) Size() int {
var _arg0 *C.GtkTextTagTable // out
var _cret C.gint // in

_arg0 = (*C.GtkTextTagTable)(unsafe.Pointer(t.Native()))

_cret = C.gtk_text_tag_table_get_size(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Lookup: look up a named tag.
	func (t TextTagTable) Lookup(name string) TextTag {
var _arg0 *C.GtkTextTagTable // out
var _arg1 *C.gchar // out
var _cret *C.GtkTextTag // in

_arg0 = (*C.GtkTextTagTable)(unsafe.Pointer(t.Native()))
_arg1 = (*C.gchar)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_text_tag_table_lookup(_arg0, _arg1)


var _textTag TextTag // out

_textTag = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TextTag)

return _textTag
}
	
	// Remove: remove a tag from the table. If a TextBuffer has @table as its tag
// table, the tag is removed from the buffer. The table’s reference to the tag
// is removed, so the tag will end up destroyed if you don’t have a reference to
// it.
	func (t TextTagTable) Remove(tag TextTagClass)  {
var _arg0 *C.GtkTextTagTable // out
var _arg1 *C.GtkTextTag // out

_arg0 = (*C.GtkTextTagTable)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTextTag)(unsafe.Pointer(tag.Native()))

C.gtk_text_tag_table_remove(_arg0, _arg1)
}
	


	// TextView: you may wish to begin by reading the [text widget conceptual
// overview][TextWidget] which gives an overview of all the objects and data
// types related to the text widget and how they work together.
// 
// CSS nodes
// 
//    textview.view
//    ├── border.top
//    ├── border.left
//    ├── text
//    │   ╰── [selection]
//    ├── border.right
//    ├── border.bottom
//    ╰── [window.popup]
// 
// GtkTextView has a main css node with name textview and style class .view, and
// subnodes for each of the border windows, and the main text area, with names
// border and text, respectively. The border nodes each get one of the style
// classes .left, .right, .top or .bottom.
// 
// A node representing the selection will appear below the text node.
// 
// If a context menu is opened, the window node will appear as a subnode of the
// main node.
	type TextView struct {
		Container
		Buildable
		Scrollable
		
	}

	// TextViewClass is an interface that the TextView class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type TextViewClass interface {
		gextras.Objector
		_textView()
	}

	func (TextView) _textView() {}

	
	func marshalTextView(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapTextView(obj), nil
	}
	

	
	// NewTextView creates a new TextView. If you don’t call
// gtk_text_view_set_buffer() before using the text view, an empty default
// buffer will be created for you. Get the buffer with
// gtk_text_view_get_buffer(). If you want to specify your own buffer, consider
// gtk_text_view_new_with_buffer().
	func NewTextView() TextView {
var _cret *C.GtkWidget // in

_cret = C.gtk_text_view_new()


var _textView TextView // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_textView = TextView{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Scrollable: Scrollable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _textView
}
	
	// NewTextViewWithBuffer creates a new TextView widget displaying the buffer
// @buffer. One buffer can be shared among many widgets. @buffer may be nil to
// create a default buffer, in which case this function is equivalent to
// gtk_text_view_new(). The text view adds its own reference count to the
// buffer; it does not take over an existing reference.
	func NewTextViewWithBuffer(buffer TextBufferClass) TextView {
var _arg1 *C.GtkTextBuffer // out
var _cret *C.GtkWidget // in

_arg1 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))

_cret = C.gtk_text_view_new_with_buffer(_arg1)


var _textView TextView // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_textView = TextView{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Scrollable: Scrollable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _textView
}
	

	
	// AddChildAtAnchor adds a child widget in the text buffer, at the given
// @anchor.
	func (t TextView) AddChildAtAnchor(child WidgetClass, anchor TextChildAnchorClass)  {
var _arg0 *C.GtkTextView // out
var _arg1 *C.GtkWidget // out
var _arg2 *C.GtkTextChildAnchor // out

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
_arg2 = (*C.GtkTextChildAnchor)(unsafe.Pointer(anchor.Native()))

C.gtk_text_view_add_child_at_anchor(_arg0, _arg1, _arg2)
}
	
	// AddChildInWindow adds a child at fixed coordinates in one of the text
// widget's windows.
// 
// The window must have nonzero size (see
// gtk_text_view_set_border_window_size()). Note that the child coordinates are
// given relative to scrolling. When placing a child in K_TEXT_WINDOW_WIDGET,
// scrolling is irrelevant, the child floats above all scrollable areas. But
// when placing a child in one of the scrollable windows (border windows or text
// window) it will move with the scrolling as needed.
	func (t TextView) AddChildInWindow(child WidgetClass, whichWindow TextWindowType, xpos int, ypos int)  {
var _arg0 *C.GtkTextView // out
var _arg1 *C.GtkWidget // out
var _arg2 C.GtkTextWindowType // out
var _arg3 C.gint // out
var _arg4 C.gint // out

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
_arg2 = (C.GtkTextWindowType)(whichWindow)
_arg3 = (C.gint)(xpos)
_arg4 = (C.gint)(ypos)

C.gtk_text_view_add_child_in_window(_arg0, _arg1, _arg2, _arg3, _arg4)
}
	
	// BackwardDisplayLine moves the given @iter backward by one display (wrapped)
// line. A display line is different from a paragraph. Paragraphs are separated
// by newlines or other paragraph separator characters. Display lines are
// created by line-wrapping a paragraph. If wrapping is turned off, display
// lines and paragraphs will be the same. Display lines are divided differently
// for each view, since they depend on the view’s width; paragraphs are the same
// in all views, since they depend on the contents of the TextBuffer.
	func (t TextView) BackwardDisplayLine(iter *TextIter) bool {
var _arg0 *C.GtkTextView // out
var _arg1 *C.GtkTextIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))

_cret = C.gtk_text_view_backward_display_line(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// BackwardDisplayLineStart moves the given @iter backward to the next display
// line start. A display line is different from a paragraph. Paragraphs are
// separated by newlines or other paragraph separator characters. Display lines
// are created by line-wrapping a paragraph. If wrapping is turned off, display
// lines and paragraphs will be the same. Display lines are divided differently
// for each view, since they depend on the view’s width; paragraphs are the same
// in all views, since they depend on the contents of the TextBuffer.
	func (t TextView) BackwardDisplayLineStart(iter *TextIter) bool {
var _arg0 *C.GtkTextView // out
var _arg1 *C.GtkTextIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))

_cret = C.gtk_text_view_backward_display_line_start(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// BufferToWindowCoords converts coordinate (@buffer_x, @buffer_y) to
// coordinates for the window @win, and stores the result in (@window_x,
// @window_y).
// 
// Note that you can’t convert coordinates for a nonexisting window (see
// gtk_text_view_set_border_window_size()).
	func (t TextView) BufferToWindowCoords(win TextWindowType, bufferX int, bufferY int) (windowX int, windowY int) {
var _arg0 *C.GtkTextView // out
var _arg1 C.GtkTextWindowType // out
var _arg2 C.gint // out
var _arg3 C.gint // out
var _arg4 C.gint // in
var _arg5 C.gint // in

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
_arg1 = (C.GtkTextWindowType)(win)
_arg2 = (C.gint)(bufferX)
_arg3 = (C.gint)(bufferY)

C.gtk_text_view_buffer_to_window_coords(_arg0, _arg1, _arg2, _arg3, &_arg4, &_arg5)

var _windowX int // out
var _windowY int // out

_windowX = (int)(_arg4)
_windowY = (int)(_arg5)

return _windowX, _windowY
}
	
	// ForwardDisplayLine moves the given @iter forward by one display (wrapped)
// line. A display line is different from a paragraph. Paragraphs are separated
// by newlines or other paragraph separator characters. Display lines are
// created by line-wrapping a paragraph. If wrapping is turned off, display
// lines and paragraphs will be the same. Display lines are divided differently
// for each view, since they depend on the view’s width; paragraphs are the same
// in all views, since they depend on the contents of the TextBuffer.
	func (t TextView) ForwardDisplayLine(iter *TextIter) bool {
var _arg0 *C.GtkTextView // out
var _arg1 *C.GtkTextIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))

_cret = C.gtk_text_view_forward_display_line(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ForwardDisplayLineEnd moves the given @iter forward to the next display line
// end. A display line is different from a paragraph. Paragraphs are separated
// by newlines or other paragraph separator characters. Display lines are
// created by line-wrapping a paragraph. If wrapping is turned off, display
// lines and paragraphs will be the same. Display lines are divided differently
// for each view, since they depend on the view’s width; paragraphs are the same
// in all views, since they depend on the contents of the TextBuffer.
	func (t TextView) ForwardDisplayLineEnd(iter *TextIter) bool {
var _arg0 *C.GtkTextView // out
var _arg1 *C.GtkTextIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))

_cret = C.gtk_text_view_forward_display_line_end(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// AcceptsTab returns whether pressing the Tab key inserts a tab characters.
// gtk_text_view_set_accepts_tab().
	func (t TextView) AcceptsTab() bool {
var _arg0 *C.GtkTextView // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_text_view_get_accepts_tab(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// BorderWindowSize gets the width of the specified border window. See
// gtk_text_view_set_border_window_size().
	func (t TextView) BorderWindowSize(typ TextWindowType) int {
var _arg0 *C.GtkTextView // out
var _arg1 C.GtkTextWindowType // out
var _cret C.gint // in

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
_arg1 = (C.GtkTextWindowType)(typ)

_cret = C.gtk_text_view_get_border_window_size(_arg0, _arg1)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// BottomMargin gets the bottom margin for text in the @text_view.
	func (t TextView) BottomMargin() int {
var _arg0 *C.GtkTextView // out
var _cret C.gint // in

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_text_view_get_bottom_margin(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Buffer returns the TextBuffer being displayed by this text view. The
// reference count on the buffer is not incremented; the caller of this function
// won’t own a new reference.
	func (t TextView) Buffer() TextBuffer {
var _arg0 *C.GtkTextView // out
var _cret *C.GtkTextBuffer // in

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_text_view_get_buffer(_arg0)


var _textBuffer TextBuffer // out

_textBuffer = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TextBuffer)

return _textBuffer
}
	
	// CursorLocations: given an @iter within a text layout, determine the positions
// of the strong and weak cursors if the insertion point is at that iterator.
// The position of each cursor is stored as a zero-width rectangle. The strong
// cursor location is the location where characters of the directionality equal
// to the base direction of the paragraph are inserted. The weak cursor location
// is the location where characters of the directionality opposite to the base
// direction of the paragraph are inserted.
// 
// If @iter is nil, the actual cursor position is used.
// 
// Note that if @iter happens to be the actual cursor position, and there is
// currently an IM preedit sequence being entered, the returned locations will
// be adjusted to account for the preedit cursor’s offset within the preedit
// sequence.
// 
// The rectangle position is in buffer coordinates; use
// gtk_text_view_buffer_to_window_coords() to convert these coordinates to
// coordinates for one of the windows in the text view.
	func (t TextView) CursorLocations(iter *TextIter) (strong gdk.Rectangle, weak gdk.Rectangle) {
var _arg0 *C.GtkTextView // out
var _arg1 *C.GtkTextIter // out
var _strong gdk.Rectangle
var _weak gdk.Rectangle

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))

C.gtk_text_view_get_cursor_locations(_arg0, _arg1, (*C.GdkRectangle)(unsafe.Pointer(&_strong)), (*C.GdkRectangle)(unsafe.Pointer(&_weak)))







return _strong, _weak
}
	
	// CursorVisible: find out whether the cursor should be displayed.
	func (t TextView) CursorVisible() bool {
var _arg0 *C.GtkTextView // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_text_view_get_cursor_visible(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// DefaultAttributes obtains a copy of the default text attributes. These are
// the attributes used for text unless a tag overrides them. You’d typically
// pass the default attributes in to gtk_text_iter_get_attributes() in order to
// get the attributes in effect at a given text position.
// 
// The return value is a copy owned by the caller of this function, and should
// be freed with gtk_text_attributes_unref().
	func (t TextView) DefaultAttributes() *TextAttributes {
var _arg0 *C.GtkTextView // out
var _cret *C.GtkTextAttributes // in

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_text_view_get_default_attributes(_arg0)


var _textAttributes *TextAttributes // out

_textAttributes = *(**TextAttributes)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_textAttributes, func(v *TextAttributes) {
  C.free(unsafe.Pointer(v.Native()))
})

return _textAttributes
}
	
	// Editable returns the default editability of the TextView. Tags in the buffer
// may override this setting for some ranges of text.
	func (t TextView) Editable() bool {
var _arg0 *C.GtkTextView // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_text_view_get_editable(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// HAdjustment gets the horizontal-scrolling Adjustment.
	func (t TextView) HAdjustment() Adjustment {
var _arg0 *C.GtkTextView // out
var _cret *C.GtkAdjustment // in

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_text_view_get_hadjustment(_arg0)


var _adjustment Adjustment // out

_adjustment = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Adjustment)

return _adjustment
}
	
	// Indent gets the default indentation of paragraphs in @text_view. Tags in the
// view’s buffer may override the default. The indentation may be negative.
	func (t TextView) Indent() int {
var _arg0 *C.GtkTextView // out
var _cret C.gint // in

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_text_view_get_indent(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// InputHints gets the value of the TextView:input-hints property.
	func (t TextView) InputHints() InputHints {
var _arg0 *C.GtkTextView // out
var _cret C.GtkInputHints // in

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_text_view_get_input_hints(_arg0)


var _inputHints InputHints // out

_inputHints = InputHints(_cret)

return _inputHints
}
	
	// InputPurpose gets the value of the TextView:input-purpose property.
	func (t TextView) InputPurpose() InputPurpose {
var _arg0 *C.GtkTextView // out
var _cret C.GtkInputPurpose // in

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_text_view_get_input_purpose(_arg0)


var _inputPurpose InputPurpose // out

_inputPurpose = InputPurpose(_cret)

return _inputPurpose
}
	
	// IterAtLocation retrieves the iterator at buffer coordinates @x and @y. Buffer
// coordinates are coordinates for the entire buffer, not just the
// currently-displayed portion. If you have coordinates from an event, you have
// to convert those to buffer coordinates with
// gtk_text_view_window_to_buffer_coords().
	func (t TextView) IterAtLocation(x int, y int) (TextIter, bool) {
var _arg0 *C.GtkTextView // out
var _iter TextIter
var _arg2 C.gint // out
var _arg3 C.gint // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
_arg2 = (C.gint)(x)
_arg3 = (C.gint)(y)

_cret = C.gtk_text_view_get_iter_at_location(_arg0, (*C.GtkTextIter)(unsafe.Pointer(&_iter)), _arg2, _arg3)



var _ok bool // out


if _cret != 0 { _ok = true }

return _iter, _ok
}
	
	// IterAtPosition retrieves the iterator pointing to the character at buffer
// coordinates @x and @y. Buffer coordinates are coordinates for the entire
// buffer, not just the currently-displayed portion. If you have coordinates
// from an event, you have to convert those to buffer coordinates with
// gtk_text_view_window_to_buffer_coords().
// 
// Note that this is different from gtk_text_view_get_iter_at_location(), which
// returns cursor locations, i.e. positions between characters.
	func (t TextView) IterAtPosition(x int, y int) (TextIter, int, bool) {
var _arg0 *C.GtkTextView // out
var _iter TextIter
var _arg2 C.gint // in
var _arg3 C.gint // out
var _arg4 C.gint // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
_arg3 = (C.gint)(x)
_arg4 = (C.gint)(y)

_cret = C.gtk_text_view_get_iter_at_position(_arg0, (*C.GtkTextIter)(unsafe.Pointer(&_iter)), &_arg2, _arg3, _arg4)



var _trailing int // out
var _ok bool // out


_trailing = (int)(_arg2)
if _cret != 0 { _ok = true }

return _iter, _trailing, _ok
}
	
	// IterLocation gets a rectangle which roughly contains the character at @iter.
// The rectangle position is in buffer coordinates; use
// gtk_text_view_buffer_to_window_coords() to convert these coordinates to
// coordinates for one of the windows in the text view.
	func (t TextView) IterLocation(iter *TextIter) gdk.Rectangle {
var _arg0 *C.GtkTextView // out
var _arg1 *C.GtkTextIter // out
var _location gdk.Rectangle

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))

C.gtk_text_view_get_iter_location(_arg0, _arg1, (*C.GdkRectangle)(unsafe.Pointer(&_location)))





return _location
}
	
	// Justification gets the default justification of paragraphs in @text_view.
// Tags in the buffer may override the default.
	func (t TextView) Justification() Justification {
var _arg0 *C.GtkTextView // out
var _cret C.GtkJustification // in

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_text_view_get_justification(_arg0)


var _justification Justification // out

_justification = Justification(_cret)

return _justification
}
	
	// LeftMargin gets the default left margin size of paragraphs in the @text_view.
// Tags in the buffer may override the default.
	func (t TextView) LeftMargin() int {
var _arg0 *C.GtkTextView // out
var _cret C.gint // in

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_text_view_get_left_margin(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// LineAtY gets the TextIter at the start of the line containing the coordinate
// @y. @y is in buffer coordinates, convert from window coordinates with
// gtk_text_view_window_to_buffer_coords(). If non-nil, @line_top will be filled
// with the coordinate of the top edge of the line.
	func (t TextView) LineAtY(y int) (TextIter, int) {
var _arg0 *C.GtkTextView // out
var _targetIter TextIter
var _arg2 C.gint // out
var _arg3 C.gint // in

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
_arg2 = (C.gint)(y)

C.gtk_text_view_get_line_at_y(_arg0, (*C.GtkTextIter)(unsafe.Pointer(&_targetIter)), _arg2, &_arg3)


var _lineTop int // out


_lineTop = (int)(_arg3)

return _targetIter, _lineTop
}
	
	// LineYrange gets the y coordinate of the top of the line containing @iter, and
// the height of the line. The coordinate is a buffer coordinate; convert to
// window coordinates with gtk_text_view_buffer_to_window_coords().
	func (t TextView) LineYrange(iter *TextIter) (y int, height int) {
var _arg0 *C.GtkTextView // out
var _arg1 *C.GtkTextIter // out
var _arg2 C.gint // in
var _arg3 C.gint // in

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))

C.gtk_text_view_get_line_yrange(_arg0, _arg1, &_arg2, &_arg3)

var _y int // out
var _height int // out

_y = (int)(_arg2)
_height = (int)(_arg3)

return _y, _height
}
	
	// Monospace gets the value of the TextView:monospace property.
	func (t TextView) Monospace() bool {
var _arg0 *C.GtkTextView // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_text_view_get_monospace(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Overwrite returns whether the TextView is in overwrite mode or not.
	func (t TextView) Overwrite() bool {
var _arg0 *C.GtkTextView // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_text_view_get_overwrite(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// PixelsAboveLines gets the default number of pixels to put above paragraphs.
// Adding this function with gtk_text_view_get_pixels_below_lines() is equal to
// the line space between each paragraph.
	func (t TextView) PixelsAboveLines() int {
var _arg0 *C.GtkTextView // out
var _cret C.gint // in

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_text_view_get_pixels_above_lines(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// PixelsBelowLines gets the value set by
// gtk_text_view_set_pixels_below_lines().
// 
// The line space is the sum of the value returned by this function and the
// value returned by gtk_text_view_get_pixels_above_lines().
	func (t TextView) PixelsBelowLines() int {
var _arg0 *C.GtkTextView // out
var _cret C.gint // in

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_text_view_get_pixels_below_lines(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// PixelsInsideWrap gets the value set by
// gtk_text_view_set_pixels_inside_wrap().
	func (t TextView) PixelsInsideWrap() int {
var _arg0 *C.GtkTextView // out
var _cret C.gint // in

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_text_view_get_pixels_inside_wrap(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// RightMargin gets the default right margin for text in @text_view. Tags in the
// buffer may override the default.
	func (t TextView) RightMargin() int {
var _arg0 *C.GtkTextView // out
var _cret C.gint // in

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_text_view_get_right_margin(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Tabs gets the default tabs for @text_view. Tags in the buffer may override
// the defaults. The returned array will be nil if “standard” (8-space) tabs are
// used. Free the return value with pango_tab_array_free().
	func (t TextView) Tabs() *pango.TabArray {
var _arg0 *C.GtkTextView // out
var _cret *C.PangoTabArray // in

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_text_view_get_tabs(_arg0)


var _tabArray *pango.TabArray // out

_tabArray = *(**pango.TabArray)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_tabArray, func(v *pango.TabArray) {
  C.free(unsafe.Pointer(v.Native()))
})

return _tabArray
}
	
	// TopMargin gets the top margin for text in the @text_view.
	func (t TextView) TopMargin() int {
var _arg0 *C.GtkTextView // out
var _cret C.gint // in

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_text_view_get_top_margin(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// VAdjustment gets the vertical-scrolling Adjustment.
	func (t TextView) VAdjustment() Adjustment {
var _arg0 *C.GtkTextView // out
var _cret *C.GtkAdjustment // in

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_text_view_get_vadjustment(_arg0)


var _adjustment Adjustment // out

_adjustment = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Adjustment)

return _adjustment
}
	
	// VisibleRect fills @visible_rect with the currently-visible region of the
// buffer, in buffer coordinates. Convert to window coordinates with
// gtk_text_view_buffer_to_window_coords().
	func (t TextView) VisibleRect() gdk.Rectangle {
var _arg0 *C.GtkTextView // out
var _visibleRect gdk.Rectangle

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

C.gtk_text_view_get_visible_rect(_arg0, (*C.GdkRectangle)(unsafe.Pointer(&_visibleRect)))





return _visibleRect
}
	
	// Window retrieves the Window corresponding to an area of the text view;
// possible windows include the overall widget window, child windows on the
// left, right, top, bottom, and the window that displays the text buffer.
// Windows are nil and nonexistent if their width or height is 0, and are
// nonexistent before the widget has been realized.
	func (t TextView) Window(win TextWindowType) gdk.Window {
var _arg0 *C.GtkTextView // out
var _arg1 C.GtkTextWindowType // out
var _cret *C.GdkWindow // in

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
_arg1 = (C.GtkTextWindowType)(win)

_cret = C.gtk_text_view_get_window(_arg0, _arg1)


var _window gdk.Window // out

_window = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Window)

return _window
}
	
	// WindowType: usually used to find out which window an event corresponds to.
// 
// If you connect to an event signal on @text_view, this function should be
// called on `event->window` to see which window it was.
	func (t TextView) WindowType(window gdk.WindowClass) TextWindowType {
var _arg0 *C.GtkTextView // out
var _arg1 *C.GdkWindow // out
var _cret C.GtkTextWindowType // in

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GdkWindow)(unsafe.Pointer(window.Native()))

_cret = C.gtk_text_view_get_window_type(_arg0, _arg1)


var _textWindowType TextWindowType // out

_textWindowType = TextWindowType(_cret)

return _textWindowType
}
	
	// WrapMode gets the line wrapping for the view.
	func (t TextView) WrapMode() WrapMode {
var _arg0 *C.GtkTextView // out
var _cret C.GtkWrapMode // in

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_text_view_get_wrap_mode(_arg0)


var _wrapMode WrapMode // out

_wrapMode = WrapMode(_cret)

return _wrapMode
}
	
	// ImContextFilterKeypress: allow the TextView input method to internally handle
// key press and release events. If this function returns true, then no further
// processing should be done for this key event. See
// gtk_im_context_filter_keypress().
// 
// Note that you are expected to call this function from your handler when
// overriding key event handling. This is needed in the case when you need to
// insert your own key handling between the input method and the default key
// event handling of the TextView.
// 
//    static gboolean
//    gtk_foo_bar_key_press_event (GtkWidget   *widget,
//                                 GdkEventKey *event)
//    {
//      guint keyval;
// 
//      gdk_event_get_keyval ((GdkEvent*)event, &keyval);
// 
//      if (keyval == GDK_KEY_Return || keyval == GDK_KEY_KP_Enter)
//        {
//          if (gtk_text_view_im_context_filter_keypress (GTK_TEXT_VIEW (widget), event))
//            return TRUE;
//        }
// 
//      // Do some stuff
// 
//      return GTK_WIDGET_CLASS (gtk_foo_bar_parent_class)->key_press_event (widget, event);
//    }
	func (t TextView) ImContextFilterKeypress(event *gdk.EventKey) bool {
var _arg0 *C.GtkTextView // out
var _arg1 *C.GdkEventKey // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GdkEventKey)(unsafe.Pointer(event.Native()))

_cret = C.gtk_text_view_im_context_filter_keypress(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// MoveChild updates the position of a child, as for
// gtk_text_view_add_child_in_window().
	func (t TextView) MoveChild(child WidgetClass, xpos int, ypos int)  {
var _arg0 *C.GtkTextView // out
var _arg1 *C.GtkWidget // out
var _arg2 C.gint // out
var _arg3 C.gint // out

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
_arg2 = (C.gint)(xpos)
_arg3 = (C.gint)(ypos)

C.gtk_text_view_move_child(_arg0, _arg1, _arg2, _arg3)
}
	
	// MoveMarkOnscreen moves a mark within the buffer so that it's located within
// the currently-visible text area.
	func (t TextView) MoveMarkOnscreen(mark TextMarkClass) bool {
var _arg0 *C.GtkTextView // out
var _arg1 *C.GtkTextMark // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTextMark)(unsafe.Pointer(mark.Native()))

_cret = C.gtk_text_view_move_mark_onscreen(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// MoveVisually: move the iterator a given number of characters visually,
// treating it as the strong cursor position. If @count is positive, then the
// new strong cursor position will be @count positions to the right of the old
// cursor position. If @count is negative then the new strong cursor position
// will be @count positions to the left of the old cursor position.
// 
// In the presence of bi-directional text, the correspondence between logical
// and visual order will depend on the direction of the current run, and there
// may be jumps when the cursor is moved off of the end of a run.
	func (t TextView) MoveVisually(iter *TextIter, count int) bool {
var _arg0 *C.GtkTextView // out
var _arg1 *C.GtkTextIter // out
var _arg2 C.gint // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))
_arg2 = (C.gint)(count)

_cret = C.gtk_text_view_move_visually(_arg0, _arg1, _arg2)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// PlaceCursorOnscreen moves the cursor to the currently visible region of the
// buffer, it it isn’t there already.
	func (t TextView) PlaceCursorOnscreen() bool {
var _arg0 *C.GtkTextView // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_text_view_place_cursor_onscreen(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ResetCursorBlink ensures that the cursor is shown (i.e. not in an 'off' blink
// interval) and resets the time that it will stay blinking (or visible, in case
// blinking is disabled).
// 
// This function should be called in response to user input (e.g. from derived
// classes that override the textview's Widget::key-press-event handler).
	func (t TextView) ResetCursorBlink()  {
var _arg0 *C.GtkTextView // out

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

C.gtk_text_view_reset_cursor_blink(_arg0)
}
	
	// ResetImContext: reset the input method context of the text view if needed.
// 
// This can be necessary in the case where modifying the buffer would confuse
// on-going input method behavior.
	func (t TextView) ResetImContext()  {
var _arg0 *C.GtkTextView // out

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

C.gtk_text_view_reset_im_context(_arg0)
}
	
	// ScrollMarkOnscreen scrolls @text_view the minimum distance such that @mark is
// contained within the visible area of the widget.
	func (t TextView) ScrollMarkOnscreen(mark TextMarkClass)  {
var _arg0 *C.GtkTextView // out
var _arg1 *C.GtkTextMark // out

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTextMark)(unsafe.Pointer(mark.Native()))

C.gtk_text_view_scroll_mark_onscreen(_arg0, _arg1)
}
	
	// ScrollToIter scrolls @text_view so that @iter is on the screen in the
// position indicated by @xalign and @yalign. An alignment of 0.0 indicates left
// or top, 1.0 indicates right or bottom, 0.5 means center. If @use_align is
// false, the text scrolls the minimal distance to get the mark onscreen,
// possibly not scrolling at all. The effective screen for purposes of this
// function is reduced by a margin of size @within_margin.
// 
// Note that this function uses the currently-computed height of the lines in
// the text buffer. Line heights are computed in an idle handler; so this
// function may not have the desired effect if it’s called before the height
// computations. To avoid oddness, consider using gtk_text_view_scroll_to_mark()
// which saves a point to be scrolled to after line validation.
	func (t TextView) ScrollToIter(iter *TextIter, withinMargin float64, useAlign bool, xalign float64, yalign float64) bool {
var _arg0 *C.GtkTextView // out
var _arg1 *C.GtkTextIter // out
var _arg2 C.gdouble // out
var _arg3 C.gboolean // out
var _arg4 C.gdouble // out
var _arg5 C.gdouble // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))
_arg2 = (C.gdouble)(withinMargin)
if useAlign { _arg3 = C.TRUE }
_arg4 = (C.gdouble)(xalign)
_arg5 = (C.gdouble)(yalign)

_cret = C.gtk_text_view_scroll_to_iter(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ScrollToMark scrolls @text_view so that @mark is on the screen in the
// position indicated by @xalign and @yalign. An alignment of 0.0 indicates left
// or top, 1.0 indicates right or bottom, 0.5 means center. If @use_align is
// false, the text scrolls the minimal distance to get the mark onscreen,
// possibly not scrolling at all. The effective screen for purposes of this
// function is reduced by a margin of size @within_margin.
	func (t TextView) ScrollToMark(mark TextMarkClass, withinMargin float64, useAlign bool, xalign float64, yalign float64)  {
var _arg0 *C.GtkTextView // out
var _arg1 *C.GtkTextMark // out
var _arg2 C.gdouble // out
var _arg3 C.gboolean // out
var _arg4 C.gdouble // out
var _arg5 C.gdouble // out

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTextMark)(unsafe.Pointer(mark.Native()))
_arg2 = (C.gdouble)(withinMargin)
if useAlign { _arg3 = C.TRUE }
_arg4 = (C.gdouble)(xalign)
_arg5 = (C.gdouble)(yalign)

C.gtk_text_view_scroll_to_mark(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
}
	
	// SetAcceptsTab sets the behavior of the text widget when the Tab key is
// pressed. If @accepts_tab is true, a tab character is inserted. If
// @accepts_tab is false the keyboard focus is moved to the next widget in the
// focus chain.
	func (t TextView) SetAcceptsTab(acceptsTab bool)  {
var _arg0 *C.GtkTextView // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
if acceptsTab { _arg1 = C.TRUE }

C.gtk_text_view_set_accepts_tab(_arg0, _arg1)
}
	
	// SetBorderWindowSize sets the width of GTK_TEXT_WINDOW_LEFT or
// GTK_TEXT_WINDOW_RIGHT, or the height of GTK_TEXT_WINDOW_TOP or
// GTK_TEXT_WINDOW_BOTTOM. Automatically destroys the corresponding window if
// the size is set to 0, and creates the window if the size is set to non-zero.
// This function can only be used for the “border windows”, and it won’t work
// with GTK_TEXT_WINDOW_WIDGET, GTK_TEXT_WINDOW_TEXT, or
// GTK_TEXT_WINDOW_PRIVATE.
	func (t TextView) SetBorderWindowSize(typ TextWindowType, size int)  {
var _arg0 *C.GtkTextView // out
var _arg1 C.GtkTextWindowType // out
var _arg2 C.gint // out

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
_arg1 = (C.GtkTextWindowType)(typ)
_arg2 = (C.gint)(size)

C.gtk_text_view_set_border_window_size(_arg0, _arg1, _arg2)
}
	
	// SetBottomMargin sets the bottom margin for text in @text_view.
// 
// Note that this function is confusingly named. In CSS terms, the value set
// here is padding.
	func (t TextView) SetBottomMargin(bottomMargin int)  {
var _arg0 *C.GtkTextView // out
var _arg1 C.gint // out

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
_arg1 = (C.gint)(bottomMargin)

C.gtk_text_view_set_bottom_margin(_arg0, _arg1)
}
	
	// SetBuffer sets @buffer as the buffer being displayed by @text_view. The
// previous buffer displayed by the text view is unreferenced, and a reference
// is added to @buffer. If you owned a reference to @buffer before passing it to
// this function, you must remove that reference yourself; TextView will not
// “adopt” it.
	func (t TextView) SetBuffer(buffer TextBufferClass)  {
var _arg0 *C.GtkTextView // out
var _arg1 *C.GtkTextBuffer // out

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))

C.gtk_text_view_set_buffer(_arg0, _arg1)
}
	
	// SetCursorVisible toggles whether the insertion point should be displayed. A
// buffer with no editable text probably shouldn’t have a visible cursor, so you
// may want to turn the cursor off.
// 
// Note that this property may be overridden by the
// Settings:gtk-keynave-use-caret settings.
	func (t TextView) SetCursorVisible(setting bool)  {
var _arg0 *C.GtkTextView // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
if setting { _arg1 = C.TRUE }

C.gtk_text_view_set_cursor_visible(_arg0, _arg1)
}
	
	// SetEditable sets the default editability of the TextView. You can override
// this default setting with tags in the buffer, using the “editable” attribute
// of tags.
	func (t TextView) SetEditable(setting bool)  {
var _arg0 *C.GtkTextView // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
if setting { _arg1 = C.TRUE }

C.gtk_text_view_set_editable(_arg0, _arg1)
}
	
	// SetIndent sets the default indentation for paragraphs in @text_view. Tags in
// the buffer may override the default.
	func (t TextView) SetIndent(indent int)  {
var _arg0 *C.GtkTextView // out
var _arg1 C.gint // out

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
_arg1 = (C.gint)(indent)

C.gtk_text_view_set_indent(_arg0, _arg1)
}
	
	// SetInputHints sets the TextView:input-hints property, which allows input
// methods to fine-tune their behaviour.
	func (t TextView) SetInputHints(hints InputHints)  {
var _arg0 *C.GtkTextView // out
var _arg1 C.GtkInputHints // out

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
_arg1 = (C.GtkInputHints)(hints)

C.gtk_text_view_set_input_hints(_arg0, _arg1)
}
	
	// SetInputPurpose sets the TextView:input-purpose property which can be used by
// on-screen keyboards and other input methods to adjust their behaviour.
	func (t TextView) SetInputPurpose(purpose InputPurpose)  {
var _arg0 *C.GtkTextView // out
var _arg1 C.GtkInputPurpose // out

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
_arg1 = (C.GtkInputPurpose)(purpose)

C.gtk_text_view_set_input_purpose(_arg0, _arg1)
}
	
	// SetJustification sets the default justification of text in @text_view. Tags
// in the view’s buffer may override the default.
	func (t TextView) SetJustification(justification Justification)  {
var _arg0 *C.GtkTextView // out
var _arg1 C.GtkJustification // out

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
_arg1 = (C.GtkJustification)(justification)

C.gtk_text_view_set_justification(_arg0, _arg1)
}
	
	// SetLeftMargin sets the default left margin for text in @text_view. Tags in
// the buffer may override the default.
// 
// Note that this function is confusingly named. In CSS terms, the value set
// here is padding.
	func (t TextView) SetLeftMargin(leftMargin int)  {
var _arg0 *C.GtkTextView // out
var _arg1 C.gint // out

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
_arg1 = (C.gint)(leftMargin)

C.gtk_text_view_set_left_margin(_arg0, _arg1)
}
	
	// SetMonospace sets the TextView:monospace property, which indicates that the
// text view should use monospace fonts.
	func (t TextView) SetMonospace(monospace bool)  {
var _arg0 *C.GtkTextView // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
if monospace { _arg1 = C.TRUE }

C.gtk_text_view_set_monospace(_arg0, _arg1)
}
	
	// SetOverwrite changes the TextView overwrite mode.
	func (t TextView) SetOverwrite(overwrite bool)  {
var _arg0 *C.GtkTextView // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
if overwrite { _arg1 = C.TRUE }

C.gtk_text_view_set_overwrite(_arg0, _arg1)
}
	
	// SetPixelsAboveLines sets the default number of blank pixels above paragraphs
// in @text_view. Tags in the buffer for @text_view may override the defaults.
	func (t TextView) SetPixelsAboveLines(pixelsAboveLines int)  {
var _arg0 *C.GtkTextView // out
var _arg1 C.gint // out

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
_arg1 = (C.gint)(pixelsAboveLines)

C.gtk_text_view_set_pixels_above_lines(_arg0, _arg1)
}
	
	// SetPixelsBelowLines sets the default number of pixels of blank space to put
// below paragraphs in @text_view. May be overridden by tags applied to
// @text_view’s buffer.
	func (t TextView) SetPixelsBelowLines(pixelsBelowLines int)  {
var _arg0 *C.GtkTextView // out
var _arg1 C.gint // out

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
_arg1 = (C.gint)(pixelsBelowLines)

C.gtk_text_view_set_pixels_below_lines(_arg0, _arg1)
}
	
	// SetPixelsInsideWrap sets the default number of pixels of blank space to leave
// between display/wrapped lines within a paragraph. May be overridden by tags
// in @text_view’s buffer.
	func (t TextView) SetPixelsInsideWrap(pixelsInsideWrap int)  {
var _arg0 *C.GtkTextView // out
var _arg1 C.gint // out

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
_arg1 = (C.gint)(pixelsInsideWrap)

C.gtk_text_view_set_pixels_inside_wrap(_arg0, _arg1)
}
	
	// SetRightMargin sets the default right margin for text in the text view. Tags
// in the buffer may override the default.
// 
// Note that this function is confusingly named. In CSS terms, the value set
// here is padding.
	func (t TextView) SetRightMargin(rightMargin int)  {
var _arg0 *C.GtkTextView // out
var _arg1 C.gint // out

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
_arg1 = (C.gint)(rightMargin)

C.gtk_text_view_set_right_margin(_arg0, _arg1)
}
	
	// SetTabs sets the default tab stops for paragraphs in @text_view. Tags in the
// buffer may override the default.
	func (t TextView) SetTabs(tabs *pango.TabArray)  {
var _arg0 *C.GtkTextView // out
var _arg1 *C.PangoTabArray // out

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
_arg1 = (*C.PangoTabArray)(unsafe.Pointer(tabs.Native()))

C.gtk_text_view_set_tabs(_arg0, _arg1)
}
	
	// SetTopMargin sets the top margin for text in @text_view.
// 
// Note that this function is confusingly named. In CSS terms, the value set
// here is padding.
	func (t TextView) SetTopMargin(topMargin int)  {
var _arg0 *C.GtkTextView // out
var _arg1 C.gint // out

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
_arg1 = (C.gint)(topMargin)

C.gtk_text_view_set_top_margin(_arg0, _arg1)
}
	
	// SetWrapMode sets the line wrapping for the view.
	func (t TextView) SetWrapMode(wrapMode WrapMode)  {
var _arg0 *C.GtkTextView // out
var _arg1 C.GtkWrapMode // out

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
_arg1 = (C.GtkWrapMode)(wrapMode)

C.gtk_text_view_set_wrap_mode(_arg0, _arg1)
}
	
	// StartsDisplayLine determines whether @iter is at the start of a display line.
// See gtk_text_view_forward_display_line() for an explanation of display lines
// vs. paragraphs.
	func (t TextView) StartsDisplayLine(iter *TextIter) bool {
var _arg0 *C.GtkTextView // out
var _arg1 *C.GtkTextIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))

_cret = C.gtk_text_view_starts_display_line(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// WindowToBufferCoords converts coordinates on the window identified by @win to
// buffer coordinates, storing the result in (@buffer_x,@buffer_y).
// 
// Note that you can’t convert coordinates for a nonexisting window (see
// gtk_text_view_set_border_window_size()).
	func (t TextView) WindowToBufferCoords(win TextWindowType, windowX int, windowY int) (bufferX int, bufferY int) {
var _arg0 *C.GtkTextView // out
var _arg1 C.GtkTextWindowType // out
var _arg2 C.gint // out
var _arg3 C.gint // out
var _arg4 C.gint // in
var _arg5 C.gint // in

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
_arg1 = (C.GtkTextWindowType)(win)
_arg2 = (C.gint)(windowX)
_arg3 = (C.gint)(windowY)

C.gtk_text_view_window_to_buffer_coords(_arg0, _arg1, _arg2, _arg3, &_arg4, &_arg5)

var _bufferX int // out
var _bufferY int // out

_bufferX = (int)(_arg4)
_bufferY = (int)(_arg5)

return _bufferX, _bufferY
}
	


	// ThemingEngine was the object used for rendering themed content in GTK+
// widgets. It used to allow overriding GTK+'s default implementation of
// rendering functions by allowing engines to be loaded as modules.
// 
// ThemingEngine has been deprecated in GTK+ 3.14 and will be ignored for
// rendering. The advancements in CSS theming are good enough to allow themers
// to achieve their goals without the need to modify source code.
	type ThemingEngine struct {
		**externglib.Object
		
	}

	// ThemingEngineClass is an interface that the ThemingEngine class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ThemingEngineClass interface {
		gextras.Objector
		_themingEngine()
	}

	func (ThemingEngine) _themingEngine() {}

	
	func marshalThemingEngine(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapThemingEngine(obj), nil
	}
	

	

	
	// BackgroundColor gets the background color for a given state.
	func (e ThemingEngine) BackgroundColor(state StateFlags) gdk.RGBA {
var _arg0 *C.GtkThemingEngine // out
var _arg1 C.GtkStateFlags // out
var _color gdk.RGBA

_arg0 = (*C.GtkThemingEngine)(unsafe.Pointer(e.Native()))
_arg1 = (C.GtkStateFlags)(state)

C.gtk_theming_engine_get_background_color(_arg0, _arg1, (*C.GdkRGBA)(unsafe.Pointer(&_color)))





return _color
}
	
	// Border gets the border for a given state as a Border.
	func (e ThemingEngine) Border(state StateFlags) Border {
var _arg0 *C.GtkThemingEngine // out
var _arg1 C.GtkStateFlags // out
var _border Border

_arg0 = (*C.GtkThemingEngine)(unsafe.Pointer(e.Native()))
_arg1 = (C.GtkStateFlags)(state)

C.gtk_theming_engine_get_border(_arg0, _arg1, (*C.GtkBorder)(unsafe.Pointer(&_border)))





return _border
}
	
	// BorderColor gets the border color for a given state.
	func (e ThemingEngine) BorderColor(state StateFlags) gdk.RGBA {
var _arg0 *C.GtkThemingEngine // out
var _arg1 C.GtkStateFlags // out
var _color gdk.RGBA

_arg0 = (*C.GtkThemingEngine)(unsafe.Pointer(e.Native()))
_arg1 = (C.GtkStateFlags)(state)

C.gtk_theming_engine_get_border_color(_arg0, _arg1, (*C.GdkRGBA)(unsafe.Pointer(&_color)))





return _color
}
	
	// Color gets the foreground color for a given state.
	func (e ThemingEngine) Color(state StateFlags) gdk.RGBA {
var _arg0 *C.GtkThemingEngine // out
var _arg1 C.GtkStateFlags // out
var _color gdk.RGBA

_arg0 = (*C.GtkThemingEngine)(unsafe.Pointer(e.Native()))
_arg1 = (C.GtkStateFlags)(state)

C.gtk_theming_engine_get_color(_arg0, _arg1, (*C.GdkRGBA)(unsafe.Pointer(&_color)))





return _color
}
	
	// Direction returns the widget direction used for rendering.
	func (e ThemingEngine) Direction() TextDirection {
var _arg0 *C.GtkThemingEngine // out
var _cret C.GtkTextDirection // in

_arg0 = (*C.GtkThemingEngine)(unsafe.Pointer(e.Native()))

_cret = C.gtk_theming_engine_get_direction(_arg0)


var _textDirection TextDirection // out

_textDirection = TextDirection(_cret)

return _textDirection
}
	
	// Font returns the font description for a given state.
	func (e ThemingEngine) Font(state StateFlags) *pango.FontDescription {
var _arg0 *C.GtkThemingEngine // out
var _arg1 C.GtkStateFlags // out
var _cret *C.PangoFontDescription // in

_arg0 = (*C.GtkThemingEngine)(unsafe.Pointer(e.Native()))
_arg1 = (C.GtkStateFlags)(state)

_cret = C.gtk_theming_engine_get_font(_arg0, _arg1)


var _fontDescription *pango.FontDescription // out

_fontDescription = *(**pango.FontDescription)(unsafe.Pointer(&_cret))

return _fontDescription
}
	
	// JunctionSides returns the widget direction used for rendering.
	func (e ThemingEngine) JunctionSides() JunctionSides {
var _arg0 *C.GtkThemingEngine // out
var _cret C.GtkJunctionSides // in

_arg0 = (*C.GtkThemingEngine)(unsafe.Pointer(e.Native()))

_cret = C.gtk_theming_engine_get_junction_sides(_arg0)


var _junctionSides JunctionSides // out

_junctionSides = JunctionSides(_cret)

return _junctionSides
}
	
	// Margin gets the margin for a given state as a Border.
	func (e ThemingEngine) Margin(state StateFlags) Border {
var _arg0 *C.GtkThemingEngine // out
var _arg1 C.GtkStateFlags // out
var _margin Border

_arg0 = (*C.GtkThemingEngine)(unsafe.Pointer(e.Native()))
_arg1 = (C.GtkStateFlags)(state)

C.gtk_theming_engine_get_margin(_arg0, _arg1, (*C.GtkBorder)(unsafe.Pointer(&_margin)))





return _margin
}
	
	// Padding gets the padding for a given state as a Border.
	func (e ThemingEngine) Padding(state StateFlags) Border {
var _arg0 *C.GtkThemingEngine // out
var _arg1 C.GtkStateFlags // out
var _padding Border

_arg0 = (*C.GtkThemingEngine)(unsafe.Pointer(e.Native()))
_arg1 = (C.GtkStateFlags)(state)

C.gtk_theming_engine_get_padding(_arg0, _arg1, (*C.GtkBorder)(unsafe.Pointer(&_padding)))





return _padding
}
	
	// Path returns the widget path used for style matching.
	func (e ThemingEngine) Path() *WidgetPath {
var _arg0 *C.GtkThemingEngine // out
var _cret *C.GtkWidgetPath // in

_arg0 = (*C.GtkThemingEngine)(unsafe.Pointer(e.Native()))

_cret = C.gtk_theming_engine_get_path(_arg0)


var _widgetPath *WidgetPath // out

_widgetPath = *(**WidgetPath)(unsafe.Pointer(&_cret))

return _widgetPath
}
	
	// Property gets a property value as retrieved from the style settings that
// apply to the currently rendered element.
	func (e ThemingEngine) Property(property string, state StateFlags) *externglib.Value {
var _arg0 *C.GtkThemingEngine // out
var _arg1 *C.gchar // out
var _arg2 C.GtkStateFlags // out
var _arg3 C.GValue // in

_arg0 = (*C.GtkThemingEngine)(unsafe.Pointer(e.Native()))
_arg1 = (*C.gchar)(C.CString(property))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.GtkStateFlags)(state)

C.gtk_theming_engine_get_property(_arg0, _arg1, _arg2, &_arg3)

var _value *externglib.Value // out

_value = externglib.ValueFromNative(unsafe.Pointer(_arg3))
runtime.SetFinalizer(_value, func(v *externglib.Value) {
  C.g_value_unset((*C.GValue)(v.GValue))
})

return _value
}
	
	// Screen returns the Screen to which @engine currently rendering to.
	func (e ThemingEngine) Screen() gdk.Screen {
var _arg0 *C.GtkThemingEngine // out
var _cret *C.GdkScreen // in

_arg0 = (*C.GtkThemingEngine)(unsafe.Pointer(e.Native()))

_cret = C.gtk_theming_engine_get_screen(_arg0)


var _screen gdk.Screen // out

_screen = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Screen)

return _screen
}
	
	// State returns the state used when rendering.
	func (e ThemingEngine) State() StateFlags {
var _arg0 *C.GtkThemingEngine // out
var _cret C.GtkStateFlags // in

_arg0 = (*C.GtkThemingEngine)(unsafe.Pointer(e.Native()))

_cret = C.gtk_theming_engine_get_state(_arg0)


var _stateFlags StateFlags // out

_stateFlags = StateFlags(_cret)

return _stateFlags
}
	
	// StyleProperty gets the value for a widget style property.
	func (e ThemingEngine) StyleProperty(propertyName string) *externglib.Value {
var _arg0 *C.GtkThemingEngine // out
var _arg1 *C.gchar // out
var _arg2 C.GValue // in

_arg0 = (*C.GtkThemingEngine)(unsafe.Pointer(e.Native()))
_arg1 = (*C.gchar)(C.CString(propertyName))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_theming_engine_get_style_property(_arg0, _arg1, &_arg2)

var _value *externglib.Value // out

_value = externglib.ValueFromNative(unsafe.Pointer(_arg2))

return _value
}
	
	// HasClass returns true if the currently rendered contents have defined the
// given class name.
	func (e ThemingEngine) HasClass(styleClass string) bool {
var _arg0 *C.GtkThemingEngine // out
var _arg1 *C.gchar // out
var _cret C.gboolean // in

_arg0 = (*C.GtkThemingEngine)(unsafe.Pointer(e.Native()))
_arg1 = (*C.gchar)(C.CString(styleClass))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_theming_engine_has_class(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// HasRegion returns true if the currently rendered contents have the region
// defined. If @flags_return is not nil, it is set to the flags affecting the
// region.
	func (e ThemingEngine) HasRegion(styleRegion string) (RegionFlags, bool) {
var _arg0 *C.GtkThemingEngine // out
var _arg1 *C.gchar // out
var _arg2 C.GtkRegionFlags // in
var _cret C.gboolean // in

_arg0 = (*C.GtkThemingEngine)(unsafe.Pointer(e.Native()))
_arg1 = (*C.gchar)(C.CString(styleRegion))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_theming_engine_has_region(_arg0, _arg1, &_arg2)


var _flags RegionFlags // out
var _ok bool // out

_flags = RegionFlags(_arg2)
if _cret != 0 { _ok = true }

return _flags, _ok
}
	
	// LookupColor looks up and resolves a color name in the current style’s color
// map.
	func (e ThemingEngine) LookupColor(colorName string) (gdk.RGBA, bool) {
var _arg0 *C.GtkThemingEngine // out
var _arg1 *C.gchar // out
var _color gdk.RGBA
var _cret C.gboolean // in

_arg0 = (*C.GtkThemingEngine)(unsafe.Pointer(e.Native()))
_arg1 = (*C.gchar)(C.CString(colorName))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_theming_engine_lookup_color(_arg0, _arg1, (*C.GdkRGBA)(unsafe.Pointer(&_color)))



var _ok bool // out


if _cret != 0 { _ok = true }

return _color, _ok
}
	
	// StateIsRunning returns true if there is a transition animation running for
// the current region (see gtk_style_context_push_animatable_region()).
// 
// If @progress is not nil, the animation progress will be returned there, 0.0
// means the state is closest to being false, while 1.0 means it’s closest to
// being true. This means transition animations will run from 0 to 1 when @state
// is being set to true and from 1 to 0 when it’s being set to false.
	func (e ThemingEngine) StateIsRunning(state StateType) (float64, bool) {
var _arg0 *C.GtkThemingEngine // out
var _arg1 C.GtkStateType // out
var _arg2 C.gdouble // in
var _cret C.gboolean // in

_arg0 = (*C.GtkThemingEngine)(unsafe.Pointer(e.Native()))
_arg1 = (C.GtkStateType)(state)

_cret = C.gtk_theming_engine_state_is_running(_arg0, _arg1, &_arg2)


var _progress float64 // out
var _ok bool // out

_progress = (float64)(_arg2)
if _cret != 0 { _ok = true }

return _progress, _ok
}
	


	// ToggleAction: a ToggleAction corresponds roughly to a CheckMenuItem. It has
// an “active” state specifying whether the action has been checked or not.
	type ToggleAction struct {
		Action
		Buildable
		
	}

	// ToggleActionClass is an interface that the ToggleAction class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ToggleActionClass interface {
		gextras.Objector
		_toggleAction()
	}

	func (ToggleAction) _toggleAction() {}

	
	func marshalToggleAction(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapToggleAction(obj), nil
	}
	

	
	// NewToggleAction creates a new ToggleAction object. To add the action to a
// ActionGroup and set the accelerator for the action, call
// gtk_action_group_add_action_with_accel().
	func NewToggleAction(name string, label string, tooltip string, stockId string) ToggleAction {
var _arg1 *C.gchar // out
var _arg2 *C.gchar // out
var _arg3 *C.gchar // out
var _arg4 *C.gchar // out
var _cret *C.GtkToggleAction // in

_arg1 = (*C.gchar)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.gchar)(C.CString(label))
defer C.free(unsafe.Pointer(_arg2))
_arg3 = (*C.gchar)(C.CString(tooltip))
defer C.free(unsafe.Pointer(_arg3))
_arg4 = (*C.gchar)(C.CString(stockId))
defer C.free(unsafe.Pointer(_arg4))

_cret = C.gtk_toggle_action_new(_arg1, _arg2, _arg3, _arg4)


var _toggleAction ToggleAction // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_toggleAction = ToggleAction{
Action: Action{
Object: &externglib.Object{externglib.ToGObject(obj)},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _toggleAction
}
	

	
	// Active returns the checked state of the toggle action.
	func (a ToggleAction) Active() bool {
var _arg0 *C.GtkToggleAction // out
var _cret C.gboolean // in

_arg0 = (*C.GtkToggleAction)(unsafe.Pointer(a.Native()))

_cret = C.gtk_toggle_action_get_active(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// DrawAsRadio returns whether the action should have proxies like a radio
// action.
	func (a ToggleAction) DrawAsRadio() bool {
var _arg0 *C.GtkToggleAction // out
var _cret C.gboolean // in

_arg0 = (*C.GtkToggleAction)(unsafe.Pointer(a.Native()))

_cret = C.gtk_toggle_action_get_draw_as_radio(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetActive sets the checked state on the toggle action.
	func (a ToggleAction) SetActive(isActive bool)  {
var _arg0 *C.GtkToggleAction // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkToggleAction)(unsafe.Pointer(a.Native()))
if isActive { _arg1 = C.TRUE }

C.gtk_toggle_action_set_active(_arg0, _arg1)
}
	
	// SetDrawAsRadio sets whether the action should have proxies like a radio
// action.
	func (a ToggleAction) SetDrawAsRadio(drawAsRadio bool)  {
var _arg0 *C.GtkToggleAction // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkToggleAction)(unsafe.Pointer(a.Native()))
if drawAsRadio { _arg1 = C.TRUE }

C.gtk_toggle_action_set_draw_as_radio(_arg0, _arg1)
}
	
	// Toggled emits the “toggled” signal on the toggle action.
	func (a ToggleAction) Toggled()  {
var _arg0 *C.GtkToggleAction // out

_arg0 = (*C.GtkToggleAction)(unsafe.Pointer(a.Native()))

C.gtk_toggle_action_toggled(_arg0)
}
	


	// ToggleButton: a ToggleButton is a Button which will remain “pressed-in” when
// clicked. Clicking again will cause the toggle button to return to its normal
// state.
// 
// A toggle button is created by calling either gtk_toggle_button_new() or
// gtk_toggle_button_new_with_label(). If using the former, it is advisable to
// pack a widget, (such as a Label and/or a Image), into the toggle button’s
// container. (See Button for more information).
// 
// The state of a ToggleButton can be set specifically using
// gtk_toggle_button_set_active(), and retrieved using
// gtk_toggle_button_get_active().
// 
// To simply switch the state of a toggle button, use
// gtk_toggle_button_toggled().
// 
// 
// CSS nodes
// 
// GtkToggleButton has a single CSS node with name button. To differentiate it
// from a plain Button, it gets the .toggle style class.
// 
// Creating two ToggleButton widgets.
// 
//    static void output_state (GtkToggleButton *source, gpointer user_data) {
//      printf ("Active: d\n", gtk_toggle_button_get_active (source));
//    }
// 
//    void make_toggles (void) {
//      GtkWidget *window, *toggle1, *toggle2;
//      GtkWidget *box;
//      const char *text;
// 
//      window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
//      box = gtk_box_new (GTK_ORIENTATION_VERTICAL, 12);
// 
//      text = "Hi, I’m a toggle button.";
//      toggle1 = gtk_toggle_button_new_with_label (text);
// 
//      // Makes this toggle button invisible
//      gtk_toggle_button_set_mode (GTK_TOGGLE_BUTTON (toggle1),
//                                  TRUE);
// 
//      g_signal_connect (toggle1, "toggled",
//                        G_CALLBACK (output_state),
//                        NULL);
//      gtk_container_add (GTK_CONTAINER (box), toggle1);
// 
//      text = "Hi, I’m a toggle button.";
//      toggle2 = gtk_toggle_button_new_with_label (text);
//      gtk_toggle_button_set_mode (GTK_TOGGLE_BUTTON (toggle2),
//                                  FALSE);
//      g_signal_connect (toggle2, "toggled",
//                        G_CALLBACK (output_state),
//                        NULL);
//      gtk_container_add (GTK_CONTAINER (box), toggle2);
// 
//      gtk_container_add (GTK_CONTAINER (window), box);
//      gtk_widget_show_all (window);
//    }
	type ToggleButton struct {
		Button
		Actionable
		Activatable
		Buildable
		
	}

	// ToggleButtonClass is an interface that the ToggleButton class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ToggleButtonClass interface {
		gextras.Objector
		_toggleButton()
	}

	func (ToggleButton) _toggleButton() {}

	
	func marshalToggleButton(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapToggleButton(obj), nil
	}
	

	
	// NewToggleButton creates a new toggle button. A widget should be packed into
// the button, as in gtk_button_new().
	func NewToggleButton() ToggleButton {
var _cret *C.GtkWidget // in

_cret = C.gtk_toggle_button_new()


var _toggleButton ToggleButton // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_toggleButton = ToggleButton{
Button: Button{
Bin: Bin{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _toggleButton
}
	
	// NewToggleButtonWithLabel creates a new toggle button with a text label.
	func NewToggleButtonWithLabel(label string) ToggleButton {
var _arg1 *C.gchar // out
var _cret *C.GtkWidget // in

_arg1 = (*C.gchar)(C.CString(label))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_toggle_button_new_with_label(_arg1)


var _toggleButton ToggleButton // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_toggleButton = ToggleButton{
Button: Button{
Bin: Bin{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _toggleButton
}
	
	// NewToggleButtonWithMnemonic creates a new ToggleButton containing a label.
// The label will be created using gtk_label_new_with_mnemonic(), so underscores
// in @label indicate the mnemonic for the button.
	func NewToggleButtonWithMnemonic(label string) ToggleButton {
var _arg1 *C.gchar // out
var _cret *C.GtkWidget // in

_arg1 = (*C.gchar)(C.CString(label))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_toggle_button_new_with_mnemonic(_arg1)


var _toggleButton ToggleButton // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_toggleButton = ToggleButton{
Button: Button{
Bin: Bin{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _toggleButton
}
	

	
	// Active queries a ToggleButton and returns its current state. Returns true if
// the toggle button is pressed in and false if it is raised.
	func (t ToggleButton) Active() bool {
var _arg0 *C.GtkToggleButton // out
var _cret C.gboolean // in

_arg0 = (*C.GtkToggleButton)(unsafe.Pointer(t.Native()))

_cret = C.gtk_toggle_button_get_active(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Inconsistent gets the value set by gtk_toggle_button_set_inconsistent().
	func (t ToggleButton) Inconsistent() bool {
var _arg0 *C.GtkToggleButton // out
var _cret C.gboolean // in

_arg0 = (*C.GtkToggleButton)(unsafe.Pointer(t.Native()))

_cret = C.gtk_toggle_button_get_inconsistent(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Mode retrieves whether the button is displayed as a separate indicator and
// label. See gtk_toggle_button_set_mode().
	func (t ToggleButton) Mode() bool {
var _arg0 *C.GtkToggleButton // out
var _cret C.gboolean // in

_arg0 = (*C.GtkToggleButton)(unsafe.Pointer(t.Native()))

_cret = C.gtk_toggle_button_get_mode(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetActive sets the status of the toggle button. Set to true if you want the
// GtkToggleButton to be “pressed in”, and false to raise it. This action causes
// the ToggleButton::toggled signal and the Button::clicked signal to be
// emitted.
	func (t ToggleButton) SetActive(isActive bool)  {
var _arg0 *C.GtkToggleButton // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkToggleButton)(unsafe.Pointer(t.Native()))
if isActive { _arg1 = C.TRUE }

C.gtk_toggle_button_set_active(_arg0, _arg1)
}
	
	// SetInconsistent: if the user has selected a range of elements (such as some
// text or spreadsheet cells) that are affected by a toggle button, and the
// current values in that range are inconsistent, you may want to display the
// toggle in an “in between” state. This function turns on “in between” display.
// Normally you would turn off the inconsistent state again if the user toggles
// the toggle button. This has to be done manually,
// gtk_toggle_button_set_inconsistent() only affects visual appearance, it
// doesn’t affect the semantics of the button.
	func (t ToggleButton) SetInconsistent(setting bool)  {
var _arg0 *C.GtkToggleButton // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkToggleButton)(unsafe.Pointer(t.Native()))
if setting { _arg1 = C.TRUE }

C.gtk_toggle_button_set_inconsistent(_arg0, _arg1)
}
	
	// SetMode sets whether the button is displayed as a separate indicator and
// label. You can call this function on a checkbutton or a radiobutton with
// @draw_indicator = false to make the button look like a normal button.
// 
// This can be used to create linked strip of buttons that work like a
// StackSwitcher.
// 
// This function only affects instances of classes like CheckButton and
// RadioButton that derive from ToggleButton, not instances of ToggleButton
// itself.
	func (t ToggleButton) SetMode(drawIndicator bool)  {
var _arg0 *C.GtkToggleButton // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkToggleButton)(unsafe.Pointer(t.Native()))
if drawIndicator { _arg1 = C.TRUE }

C.gtk_toggle_button_set_mode(_arg0, _arg1)
}
	
	// Toggled emits the ToggleButton::toggled signal on the ToggleButton. There is
// no good reason for an application ever to call this function.
	func (t ToggleButton) Toggled()  {
var _arg0 *C.GtkToggleButton // out

_arg0 = (*C.GtkToggleButton)(unsafe.Pointer(t.Native()))

C.gtk_toggle_button_toggled(_arg0)
}
	


	// ToggleToolButton: a ToggleToolButton is a ToolItem that contains a toggle
// button.
// 
// Use gtk_toggle_tool_button_new() to create a new GtkToggleToolButton.
// 
// 
// CSS nodes
// 
// GtkToggleToolButton has a single CSS node with name togglebutton.
	type ToggleToolButton struct {
		ToolButton
		Actionable
		Activatable
		Buildable
		
	}

	// ToggleToolButtonClass is an interface that the ToggleToolButton class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ToggleToolButtonClass interface {
		gextras.Objector
		_toggleToolButton()
	}

	func (ToggleToolButton) _toggleToolButton() {}

	
	func marshalToggleToolButton(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapToggleToolButton(obj), nil
	}
	

	
	// NewToggleToolButton returns a new ToggleToolButton
	func NewToggleToolButton() ToggleToolButton {
var _cret *C.GtkToolItem // in

_cret = C.gtk_toggle_tool_button_new()


var _toggleToolButton ToggleToolButton // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_toggleToolButton = ToggleToolButton{
ToolButton: ToolButton{
ToolItem: ToolItem{
Bin: Bin{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _toggleToolButton
}
	
	// NewToggleToolButtonFromStock creates a new ToggleToolButton containing the
// image and text from a stock item. Some stock ids have preprocessor macros
// like K_STOCK_OK and K_STOCK_APPLY.
// 
// It is an error if @stock_id is not a name of a stock item.
	func NewToggleToolButtonFromStock(stockId string) ToggleToolButton {
var _arg1 *C.gchar // out
var _cret *C.GtkToolItem // in

_arg1 = (*C.gchar)(C.CString(stockId))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_toggle_tool_button_new_from_stock(_arg1)


var _toggleToolButton ToggleToolButton // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_toggleToolButton = ToggleToolButton{
ToolButton: ToolButton{
ToolItem: ToolItem{
Bin: Bin{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _toggleToolButton
}
	

	
	// Active queries a ToggleToolButton and returns its current state. Returns true
// if the toggle button is pressed in and false if it is raised.
	func (b ToggleToolButton) Active() bool {
var _arg0 *C.GtkToggleToolButton // out
var _cret C.gboolean // in

_arg0 = (*C.GtkToggleToolButton)(unsafe.Pointer(b.Native()))

_cret = C.gtk_toggle_tool_button_get_active(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetActive sets the status of the toggle tool button. Set to true if you want
// the GtkToggleButton to be “pressed in”, and false to raise it. This action
// causes the toggled signal to be emitted.
	func (b ToggleToolButton) SetActive(isActive bool)  {
var _arg0 *C.GtkToggleToolButton // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkToggleToolButton)(unsafe.Pointer(b.Native()))
if isActive { _arg1 = C.TRUE }

C.gtk_toggle_tool_button_set_active(_arg0, _arg1)
}
	


	// ToolButton ToolButtons are ToolItems containing buttons.
// 
// Use gtk_tool_button_new() to create a new ToolButton.
// 
// The label of a ToolButton is determined by the properties
// ToolButton:label-widget, ToolButton:label, and ToolButton:stock-id. If
// ToolButton:label-widget is non-nil, then that widget is used as the label.
// Otherwise, if ToolButton:label is non-nil, that string is used as the label.
// Otherwise, if ToolButton:stock-id is non-nil, the label is determined by the
// stock item. Otherwise, the button does not have a label.
// 
// The icon of a ToolButton is determined by the properties
// ToolButton:icon-widget and ToolButton:stock-id. If ToolButton:icon-widget is
// non-nil, then that widget is used as the icon. Otherwise, if
// ToolButton:stock-id is non-nil, the icon is determined by the stock item.
// Otherwise, the button does not have a icon.
// 
// 
// CSS nodes
// 
// GtkToolButton has a single CSS node with name toolbutton.
	type ToolButton struct {
		ToolItem
		Actionable
		Activatable
		Buildable
		
	}

	// ToolButtonClass is an interface that the ToolButton class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ToolButtonClass interface {
		gextras.Objector
		_toolButton()
	}

	func (ToolButton) _toolButton() {}

	
	func marshalToolButton(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapToolButton(obj), nil
	}
	

	
	// NewToolButton creates a new ToolButton using @icon_widget as contents and
// @label as label.
	func NewToolButton(iconWidget WidgetClass, label string) ToolButton {
var _arg1 *C.GtkWidget // out
var _arg2 *C.gchar // out
var _cret *C.GtkToolItem // in

_arg1 = (*C.GtkWidget)(unsafe.Pointer(iconWidget.Native()))
_arg2 = (*C.gchar)(C.CString(label))
defer C.free(unsafe.Pointer(_arg2))

_cret = C.gtk_tool_button_new(_arg1, _arg2)


var _toolButton ToolButton // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_toolButton = ToolButton{
ToolItem: ToolItem{
Bin: Bin{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _toolButton
}
	
	// NewToolButtonFromStock creates a new ToolButton containing the image and text
// from a stock item. Some stock ids have preprocessor macros like K_STOCK_OK
// and K_STOCK_APPLY.
// 
// It is an error if @stock_id is not a name of a stock item.
	func NewToolButtonFromStock(stockId string) ToolButton {
var _arg1 *C.gchar // out
var _cret *C.GtkToolItem // in

_arg1 = (*C.gchar)(C.CString(stockId))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_tool_button_new_from_stock(_arg1)


var _toolButton ToolButton // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_toolButton = ToolButton{
ToolItem: ToolItem{
Bin: Bin{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _toolButton
}
	

	
	// IconName returns the name of the themed icon for the tool button, see
// gtk_tool_button_set_icon_name().
	func (b ToolButton) IconName() string {
var _arg0 *C.GtkToolButton // out
var _cret *C.gchar // in

_arg0 = (*C.GtkToolButton)(unsafe.Pointer(b.Native()))

_cret = C.gtk_tool_button_get_icon_name(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// IconWidget: return the widget used as icon widget on @button. See
// gtk_tool_button_set_icon_widget().
	func (b ToolButton) IconWidget() Widget {
var _arg0 *C.GtkToolButton // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkToolButton)(unsafe.Pointer(b.Native()))

_cret = C.gtk_tool_button_get_icon_widget(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// Label returns the label used by the tool button, or nil if the tool button
// doesn’t have a label. or uses a the label from a stock item. The returned
// string is owned by GTK+, and must not be modified or freed.
	func (b ToolButton) Label() string {
var _arg0 *C.GtkToolButton // out
var _cret *C.gchar // in

_arg0 = (*C.GtkToolButton)(unsafe.Pointer(b.Native()))

_cret = C.gtk_tool_button_get_label(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// LabelWidget returns the widget used as label on @button. See
// gtk_tool_button_set_label_widget().
	func (b ToolButton) LabelWidget() Widget {
var _arg0 *C.GtkToolButton // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkToolButton)(unsafe.Pointer(b.Native()))

_cret = C.gtk_tool_button_get_label_widget(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// StockID returns the name of the stock item. See
// gtk_tool_button_set_stock_id(). The returned string is owned by GTK+ and must
// not be freed or modifed.
	func (b ToolButton) StockID() string {
var _arg0 *C.GtkToolButton // out
var _cret *C.gchar // in

_arg0 = (*C.GtkToolButton)(unsafe.Pointer(b.Native()))

_cret = C.gtk_tool_button_get_stock_id(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// UseUnderline returns whether underscores in the label property are used as
// mnemonics on menu items on the overflow menu. See
// gtk_tool_button_set_use_underline().
	func (b ToolButton) UseUnderline() bool {
var _arg0 *C.GtkToolButton // out
var _cret C.gboolean // in

_arg0 = (*C.GtkToolButton)(unsafe.Pointer(b.Native()))

_cret = C.gtk_tool_button_get_use_underline(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetIconName sets the icon for the tool button from a named themed icon. See
// the docs for IconTheme for more details. The ToolButton:icon-name property
// only has an effect if not overridden by non-nil ToolButton:label-widget,
// ToolButton:icon-widget and ToolButton:stock-id properties.
	func (b ToolButton) SetIconName(iconName string)  {
var _arg0 *C.GtkToolButton // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkToolButton)(unsafe.Pointer(b.Native()))
_arg1 = (*C.gchar)(C.CString(iconName))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_tool_button_set_icon_name(_arg0, _arg1)
}
	
	// SetIconWidget sets @icon as the widget used as icon on @button. If
// @icon_widget is nil the icon is determined by the ToolButton:stock-id
// property. If the ToolButton:stock-id property is also nil, @button will not
// have an icon.
	func (b ToolButton) SetIconWidget(iconWidget WidgetClass)  {
var _arg0 *C.GtkToolButton // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkToolButton)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(iconWidget.Native()))

C.gtk_tool_button_set_icon_widget(_arg0, _arg1)
}
	
	// SetLabel sets @label as the label used for the tool button. The
// ToolButton:label property only has an effect if not overridden by a non-nil
// ToolButton:label-widget property. If both the ToolButton:label-widget and
// ToolButton:label properties are nil, the label is determined by the
// ToolButton:stock-id property. If the ToolButton:stock-id property is also
// nil, @button will not have a label.
	func (b ToolButton) SetLabel(label string)  {
var _arg0 *C.GtkToolButton // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkToolButton)(unsafe.Pointer(b.Native()))
_arg1 = (*C.gchar)(C.CString(label))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_tool_button_set_label(_arg0, _arg1)
}
	
	// SetLabelWidget sets @label_widget as the widget that will be used as the
// label for @button. If @label_widget is nil the ToolButton:label property is
// used as label. If ToolButton:label is also nil, the label in the stock item
// determined by the ToolButton:stock-id property is used as label. If
// ToolButton:stock-id is also nil, @button does not have a label.
	func (b ToolButton) SetLabelWidget(labelWidget WidgetClass)  {
var _arg0 *C.GtkToolButton // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkToolButton)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(labelWidget.Native()))

C.gtk_tool_button_set_label_widget(_arg0, _arg1)
}
	
	// SetStockID sets the name of the stock item. See
// gtk_tool_button_new_from_stock(). The stock_id property only has an effect if
// not overridden by non-nil ToolButton:label-widget and ToolButton:icon-widget
// properties.
	func (b ToolButton) SetStockID(stockId string)  {
var _arg0 *C.GtkToolButton // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkToolButton)(unsafe.Pointer(b.Native()))
_arg1 = (*C.gchar)(C.CString(stockId))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_tool_button_set_stock_id(_arg0, _arg1)
}
	
	// SetUseUnderline: if set, an underline in the label property indicates that
// the next character should be used for the mnemonic accelerator key in the
// overflow menu. For example, if the label property is “_Open” and
// @use_underline is true, the label on the tool button will be “Open” and the
// item on the overflow menu will have an underlined “O”.
// 
// Labels shown on tool buttons never have mnemonics on them; this property only
// affects the menu item on the overflow menu.
	func (b ToolButton) SetUseUnderline(useUnderline bool)  {
var _arg0 *C.GtkToolButton // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkToolButton)(unsafe.Pointer(b.Native()))
if useUnderline { _arg1 = C.TRUE }

C.gtk_tool_button_set_use_underline(_arg0, _arg1)
}
	


	// ToolItem ToolItems are widgets that can appear on a toolbar. To create a
// toolbar item that contain something else than a button, use
// gtk_tool_item_new(). Use gtk_container_add() to add a child widget to the
// tool item.
// 
// For toolbar items that contain buttons, see the ToolButton, ToggleToolButton
// and RadioToolButton classes.
// 
// See the Toolbar class for a description of the toolbar widget, and ToolShell
// for a description of the tool shell interface.
	type ToolItem struct {
		Bin
		Activatable
		Buildable
		
	}

	// ToolItemClass is an interface that the ToolItem class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ToolItemClass interface {
		gextras.Objector
		_toolItem()
	}

	func (ToolItem) _toolItem() {}

	
	func marshalToolItem(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapToolItem(obj), nil
	}
	

	
	// NewToolItem creates a new ToolItem
	func NewToolItem() ToolItem {
var _cret *C.GtkToolItem // in

_cret = C.gtk_tool_item_new()


var _toolItem ToolItem // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_toolItem = ToolItem{
Bin: Bin{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _toolItem
}
	

	
	// EllipsizeMode returns the ellipsize mode used for @tool_item. Custom
// subclasses of ToolItem should call this function to find out how text should
// be ellipsized.
	func (t ToolItem) EllipsizeMode() pango.EllipsizeMode {
var _arg0 *C.GtkToolItem // out
var _cret C.PangoEllipsizeMode // in

_arg0 = (*C.GtkToolItem)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tool_item_get_ellipsize_mode(_arg0)


var _ellipsizeMode pango.EllipsizeMode // out

_ellipsizeMode = pango.EllipsizeMode(_cret)

return _ellipsizeMode
}
	
	// Expand returns whether @tool_item is allocated extra space. See
// gtk_tool_item_set_expand().
	func (t ToolItem) Expand() bool {
var _arg0 *C.GtkToolItem // out
var _cret C.gboolean // in

_arg0 = (*C.GtkToolItem)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tool_item_get_expand(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Homogeneous returns whether @tool_item is the same size as other homogeneous
// items. See gtk_tool_item_set_homogeneous().
	func (t ToolItem) Homogeneous() bool {
var _arg0 *C.GtkToolItem // out
var _cret C.gboolean // in

_arg0 = (*C.GtkToolItem)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tool_item_get_homogeneous(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IconSize returns the icon size used for @tool_item. Custom subclasses of
// ToolItem should call this function to find out what size icons they should
// use.
	func (t ToolItem) IconSize() int {
var _arg0 *C.GtkToolItem // out
var _cret C.GtkIconSize // in

_arg0 = (*C.GtkToolItem)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tool_item_get_icon_size(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// IsImportant returns whether @tool_item is considered important. See
// gtk_tool_item_set_is_important()
	func (t ToolItem) IsImportant() bool {
var _arg0 *C.GtkToolItem // out
var _cret C.gboolean // in

_arg0 = (*C.GtkToolItem)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tool_item_get_is_important(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Orientation returns the orientation used for @tool_item. Custom subclasses of
// ToolItem should call this function to find out what size icons they should
// use.
	func (t ToolItem) Orientation() Orientation {
var _arg0 *C.GtkToolItem // out
var _cret C.GtkOrientation // in

_arg0 = (*C.GtkToolItem)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tool_item_get_orientation(_arg0)


var _orientation Orientation // out

_orientation = Orientation(_cret)

return _orientation
}
	
	// ProXYMenuItem: if @menu_item_id matches the string passed to
// gtk_tool_item_set_proxy_menu_item() return the corresponding MenuItem.
// 
// Custom subclasses of ToolItem should use this function to update their menu
// item when the ToolItem changes. That the @menu_item_ids must match ensures
// that a ToolItem will not inadvertently change a menu item that they did not
// create.
	func (t ToolItem) ProXYMenuItem(menuItemId string) Widget {
var _arg0 *C.GtkToolItem // out
var _arg1 *C.gchar // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkToolItem)(unsafe.Pointer(t.Native()))
_arg1 = (*C.gchar)(C.CString(menuItemId))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_tool_item_get_proxy_menu_item(_arg0, _arg1)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// ReliefStyle returns the relief style of @tool_item. See
// gtk_button_set_relief(). Custom subclasses of ToolItem should call this
// function in the handler of the ToolItem::toolbar_reconfigured signal to find
// out the relief style of buttons.
	func (t ToolItem) ReliefStyle() ReliefStyle {
var _arg0 *C.GtkToolItem // out
var _cret C.GtkReliefStyle // in

_arg0 = (*C.GtkToolItem)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tool_item_get_relief_style(_arg0)


var _reliefStyle ReliefStyle // out

_reliefStyle = ReliefStyle(_cret)

return _reliefStyle
}
	
	// TextAlignment returns the text alignment used for @tool_item. Custom
// subclasses of ToolItem should call this function to find out how text should
// be aligned.
	func (t ToolItem) TextAlignment() float32 {
var _arg0 *C.GtkToolItem // out
var _cret C.gfloat // in

_arg0 = (*C.GtkToolItem)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tool_item_get_text_alignment(_arg0)


var _gfloat float32 // out

_gfloat = (float32)(_cret)

return _gfloat
}
	
	// TextOrientation returns the text orientation used for @tool_item. Custom
// subclasses of ToolItem should call this function to find out how text should
// be orientated.
	func (t ToolItem) TextOrientation() Orientation {
var _arg0 *C.GtkToolItem // out
var _cret C.GtkOrientation // in

_arg0 = (*C.GtkToolItem)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tool_item_get_text_orientation(_arg0)


var _orientation Orientation // out

_orientation = Orientation(_cret)

return _orientation
}
	
	// TextSizeGroup returns the size group used for labels in @tool_item. Custom
// subclasses of ToolItem should call this function and use the size group for
// labels.
	func (t ToolItem) TextSizeGroup() SizeGroup {
var _arg0 *C.GtkToolItem // out
var _cret *C.GtkSizeGroup // in

_arg0 = (*C.GtkToolItem)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tool_item_get_text_size_group(_arg0)


var _sizeGroup SizeGroup // out

_sizeGroup = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(SizeGroup)

return _sizeGroup
}
	
	// ToolbarStyle returns the toolbar style used for @tool_item. Custom subclasses
// of ToolItem should call this function in the handler of the
// GtkToolItem::toolbar_reconfigured signal to find out in what style the
// toolbar is displayed and change themselves accordingly
// 
// Possibilities are: - GTK_TOOLBAR_BOTH, meaning the tool item should show both
// an icon and a label, stacked vertically - GTK_TOOLBAR_ICONS, meaning the
// toolbar shows only icons - GTK_TOOLBAR_TEXT, meaning the tool item should
// only show text - GTK_TOOLBAR_BOTH_HORIZ, meaning the tool item should show
// both an icon and a label, arranged horizontally
	func (t ToolItem) ToolbarStyle() ToolbarStyle {
var _arg0 *C.GtkToolItem // out
var _cret C.GtkToolbarStyle // in

_arg0 = (*C.GtkToolItem)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tool_item_get_toolbar_style(_arg0)


var _toolbarStyle ToolbarStyle // out

_toolbarStyle = ToolbarStyle(_cret)

return _toolbarStyle
}
	
	// UseDragWindow returns whether @tool_item has a drag window. See
// gtk_tool_item_set_use_drag_window().
	func (t ToolItem) UseDragWindow() bool {
var _arg0 *C.GtkToolItem // out
var _cret C.gboolean // in

_arg0 = (*C.GtkToolItem)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tool_item_get_use_drag_window(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// VisibleHorizontal returns whether the @tool_item is visible on toolbars that
// are docked horizontally.
	func (t ToolItem) VisibleHorizontal() bool {
var _arg0 *C.GtkToolItem // out
var _cret C.gboolean // in

_arg0 = (*C.GtkToolItem)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tool_item_get_visible_horizontal(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// VisibleVertical returns whether @tool_item is visible when the toolbar is
// docked vertically. See gtk_tool_item_set_visible_vertical().
	func (t ToolItem) VisibleVertical() bool {
var _arg0 *C.GtkToolItem // out
var _cret C.gboolean // in

_arg0 = (*C.GtkToolItem)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tool_item_get_visible_vertical(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// RebuildMenu: calling this function signals to the toolbar that the overflow
// menu item for @tool_item has changed. If the overflow menu is visible when
// this function it called, the menu will be rebuilt.
// 
// The function must be called when the tool item changes what it will do in
// response to the ToolItem::create-menu-proxy signal.
	func (t ToolItem) RebuildMenu()  {
var _arg0 *C.GtkToolItem // out

_arg0 = (*C.GtkToolItem)(unsafe.Pointer(t.Native()))

C.gtk_tool_item_rebuild_menu(_arg0)
}
	
	// RetrieveProXYMenuItem returns the MenuItem that was last set by
// gtk_tool_item_set_proxy_menu_item(), ie. the MenuItem that is going to appear
// in the overflow menu.
	func (t ToolItem) RetrieveProXYMenuItem() Widget {
var _arg0 *C.GtkToolItem // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkToolItem)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tool_item_retrieve_proxy_menu_item(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// SetExpand sets whether @tool_item is allocated extra space when there is more
// room on the toolbar then needed for the items. The effect is that the item
// gets bigger when the toolbar gets bigger and smaller when the toolbar gets
// smaller.
	func (t ToolItem) SetExpand(expand bool)  {
var _arg0 *C.GtkToolItem // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkToolItem)(unsafe.Pointer(t.Native()))
if expand { _arg1 = C.TRUE }

C.gtk_tool_item_set_expand(_arg0, _arg1)
}
	
	// SetHomogeneous sets whether @tool_item is to be allocated the same size as
// other homogeneous items. The effect is that all homogeneous items will have
// the same width as the widest of the items.
	func (t ToolItem) SetHomogeneous(homogeneous bool)  {
var _arg0 *C.GtkToolItem // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkToolItem)(unsafe.Pointer(t.Native()))
if homogeneous { _arg1 = C.TRUE }

C.gtk_tool_item_set_homogeneous(_arg0, _arg1)
}
	
	// SetIsImportant sets whether @tool_item should be considered important. The
// ToolButton class uses this property to determine whether to show or hide its
// label when the toolbar style is GTK_TOOLBAR_BOTH_HORIZ. The result is that
// only tool buttons with the “is_important” property set have labels, an effect
// known as “priority text”
	func (t ToolItem) SetIsImportant(isImportant bool)  {
var _arg0 *C.GtkToolItem // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkToolItem)(unsafe.Pointer(t.Native()))
if isImportant { _arg1 = C.TRUE }

C.gtk_tool_item_set_is_important(_arg0, _arg1)
}
	
	// SetProXYMenuItem sets the MenuItem used in the toolbar overflow menu. The
// @menu_item_id is used to identify the caller of this function and should also
// be used with gtk_tool_item_get_proxy_menu_item().
// 
// See also ToolItem::create-menu-proxy.
	func (t ToolItem) SetProXYMenuItem(menuItemId string, menuItem WidgetClass)  {
var _arg0 *C.GtkToolItem // out
var _arg1 *C.gchar // out
var _arg2 *C.GtkWidget // out

_arg0 = (*C.GtkToolItem)(unsafe.Pointer(t.Native()))
_arg1 = (*C.gchar)(C.CString(menuItemId))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.GtkWidget)(unsafe.Pointer(menuItem.Native()))

C.gtk_tool_item_set_proxy_menu_item(_arg0, _arg1, _arg2)
}
	
	// SetTooltipMarkup sets the markup text to be displayed as tooltip on the item.
// See gtk_widget_set_tooltip_markup().
	func (t ToolItem) SetTooltipMarkup(markup string)  {
var _arg0 *C.GtkToolItem // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkToolItem)(unsafe.Pointer(t.Native()))
_arg1 = (*C.gchar)(C.CString(markup))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_tool_item_set_tooltip_markup(_arg0, _arg1)
}
	
	// SetTooltipText sets the text to be displayed as tooltip on the item. See
// gtk_widget_set_tooltip_text().
	func (t ToolItem) SetTooltipText(text string)  {
var _arg0 *C.GtkToolItem // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkToolItem)(unsafe.Pointer(t.Native()))
_arg1 = (*C.gchar)(C.CString(text))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_tool_item_set_tooltip_text(_arg0, _arg1)
}
	
	// SetUseDragWindow sets whether @tool_item has a drag window. When true the
// toolitem can be used as a drag source through gtk_drag_source_set(). When
// @tool_item has a drag window it will intercept all events, even those that
// would otherwise be sent to a child of @tool_item.
	func (t ToolItem) SetUseDragWindow(useDragWindow bool)  {
var _arg0 *C.GtkToolItem // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkToolItem)(unsafe.Pointer(t.Native()))
if useDragWindow { _arg1 = C.TRUE }

C.gtk_tool_item_set_use_drag_window(_arg0, _arg1)
}
	
	// SetVisibleHorizontal sets whether @tool_item is visible when the toolbar is
// docked horizontally.
	func (t ToolItem) SetVisibleHorizontal(visibleHorizontal bool)  {
var _arg0 *C.GtkToolItem // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkToolItem)(unsafe.Pointer(t.Native()))
if visibleHorizontal { _arg1 = C.TRUE }

C.gtk_tool_item_set_visible_horizontal(_arg0, _arg1)
}
	
	// SetVisibleVertical sets whether @tool_item is visible when the toolbar is
// docked vertically. Some tool items, such as text entries, are too wide to be
// useful on a vertically docked toolbar. If @visible_vertical is false
// @tool_item will not appear on toolbars that are docked vertically.
	func (t ToolItem) SetVisibleVertical(visibleVertical bool)  {
var _arg0 *C.GtkToolItem // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkToolItem)(unsafe.Pointer(t.Native()))
if visibleVertical { _arg1 = C.TRUE }

C.gtk_tool_item_set_visible_vertical(_arg0, _arg1)
}
	
	// ToolbarReconfigured emits the signal ToolItem::toolbar_reconfigured on
// @tool_item. Toolbar and other ToolShell implementations use this function to
// notify children, when some aspect of their configuration changes.
	func (t ToolItem) ToolbarReconfigured()  {
var _arg0 *C.GtkToolItem // out

_arg0 = (*C.GtkToolItem)(unsafe.Pointer(t.Native()))

C.gtk_tool_item_toolbar_reconfigured(_arg0)
}
	


	// ToolItemGroup: a ToolItemGroup is used together with ToolPalette to add
// ToolItems to a palette like container with different categories and drag and
// drop support.
// 
// 
// CSS nodes
// 
// GtkToolItemGroup has a single CSS node named toolitemgroup.
	type ToolItemGroup struct {
		Container
		Buildable
		ToolShell
		
	}

	// ToolItemGroupClass is an interface that the ToolItemGroup class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ToolItemGroupClass interface {
		gextras.Objector
		_toolItemGroup()
	}

	func (ToolItemGroup) _toolItemGroup() {}

	
	func marshalToolItemGroup(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapToolItemGroup(obj), nil
	}
	

	
	// NewToolItemGroup creates a new tool item group with label @label.
	func NewToolItemGroup(label string) ToolItemGroup {
var _arg1 *C.gchar // out
var _cret *C.GtkWidget // in

_arg1 = (*C.gchar)(C.CString(label))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_tool_item_group_new(_arg1)


var _toolItemGroup ToolItemGroup // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_toolItemGroup = ToolItemGroup{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ToolShell: ToolShell{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
}
}

return _toolItemGroup
}
	

	
	// Collapsed gets whether @group is collapsed or expanded.
	func (g ToolItemGroup) Collapsed() bool {
var _arg0 *C.GtkToolItemGroup // out
var _cret C.gboolean // in

_arg0 = (*C.GtkToolItemGroup)(unsafe.Pointer(g.Native()))

_cret = C.gtk_tool_item_group_get_collapsed(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// DropItem gets the tool item at position (x, y).
	func (g ToolItemGroup) DropItem(x int, y int) ToolItem {
var _arg0 *C.GtkToolItemGroup // out
var _arg1 C.gint // out
var _arg2 C.gint // out
var _cret *C.GtkToolItem // in

_arg0 = (*C.GtkToolItemGroup)(unsafe.Pointer(g.Native()))
_arg1 = (C.gint)(x)
_arg2 = (C.gint)(y)

_cret = C.gtk_tool_item_group_get_drop_item(_arg0, _arg1, _arg2)


var _toolItem ToolItem // out

_toolItem = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(ToolItem)

return _toolItem
}
	
	// Ellipsize gets the ellipsization mode of @group.
	func (g ToolItemGroup) Ellipsize() pango.EllipsizeMode {
var _arg0 *C.GtkToolItemGroup // out
var _cret C.PangoEllipsizeMode // in

_arg0 = (*C.GtkToolItemGroup)(unsafe.Pointer(g.Native()))

_cret = C.gtk_tool_item_group_get_ellipsize(_arg0)


var _ellipsizeMode pango.EllipsizeMode // out

_ellipsizeMode = pango.EllipsizeMode(_cret)

return _ellipsizeMode
}
	
	// HeaderRelief gets the relief mode of the header button of @group.
	func (g ToolItemGroup) HeaderRelief() ReliefStyle {
var _arg0 *C.GtkToolItemGroup // out
var _cret C.GtkReliefStyle // in

_arg0 = (*C.GtkToolItemGroup)(unsafe.Pointer(g.Native()))

_cret = C.gtk_tool_item_group_get_header_relief(_arg0)


var _reliefStyle ReliefStyle // out

_reliefStyle = ReliefStyle(_cret)

return _reliefStyle
}
	
	// ItemPosition gets the position of @item in @group as index.
	func (g ToolItemGroup) ItemPosition(item ToolItemClass) int {
var _arg0 *C.GtkToolItemGroup // out
var _arg1 *C.GtkToolItem // out
var _cret C.gint // in

_arg0 = (*C.GtkToolItemGroup)(unsafe.Pointer(g.Native()))
_arg1 = (*C.GtkToolItem)(unsafe.Pointer(item.Native()))

_cret = C.gtk_tool_item_group_get_item_position(_arg0, _arg1)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Label gets the label of @group.
	func (g ToolItemGroup) Label() string {
var _arg0 *C.GtkToolItemGroup // out
var _cret *C.gchar // in

_arg0 = (*C.GtkToolItemGroup)(unsafe.Pointer(g.Native()))

_cret = C.gtk_tool_item_group_get_label(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// LabelWidget gets the label widget of @group. See
// gtk_tool_item_group_set_label_widget().
	func (g ToolItemGroup) LabelWidget() Widget {
var _arg0 *C.GtkToolItemGroup // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkToolItemGroup)(unsafe.Pointer(g.Native()))

_cret = C.gtk_tool_item_group_get_label_widget(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// NItems gets the number of tool items in @group.
	func (g ToolItemGroup) NItems() uint {
var _arg0 *C.GtkToolItemGroup // out
var _cret C.guint // in

_arg0 = (*C.GtkToolItemGroup)(unsafe.Pointer(g.Native()))

_cret = C.gtk_tool_item_group_get_n_items(_arg0)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// NthItem gets the tool item at @index in group.
	func (g ToolItemGroup) NthItem(index uint) ToolItem {
var _arg0 *C.GtkToolItemGroup // out
var _arg1 C.guint // out
var _cret *C.GtkToolItem // in

_arg0 = (*C.GtkToolItemGroup)(unsafe.Pointer(g.Native()))
_arg1 = (C.guint)(index)

_cret = C.gtk_tool_item_group_get_nth_item(_arg0, _arg1)


var _toolItem ToolItem // out

_toolItem = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(ToolItem)

return _toolItem
}
	
	// Insert inserts @item at @position in the list of children of @group.
	func (g ToolItemGroup) Insert(item ToolItemClass, position int)  {
var _arg0 *C.GtkToolItemGroup // out
var _arg1 *C.GtkToolItem // out
var _arg2 C.gint // out

_arg0 = (*C.GtkToolItemGroup)(unsafe.Pointer(g.Native()))
_arg1 = (*C.GtkToolItem)(unsafe.Pointer(item.Native()))
_arg2 = (C.gint)(position)

C.gtk_tool_item_group_insert(_arg0, _arg1, _arg2)
}
	
	// SetCollapsed sets whether the @group should be collapsed or expanded.
	func (g ToolItemGroup) SetCollapsed(collapsed bool)  {
var _arg0 *C.GtkToolItemGroup // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkToolItemGroup)(unsafe.Pointer(g.Native()))
if collapsed { _arg1 = C.TRUE }

C.gtk_tool_item_group_set_collapsed(_arg0, _arg1)
}
	
	// SetEllipsize sets the ellipsization mode which should be used by labels in
// @group.
	func (g ToolItemGroup) SetEllipsize(ellipsize pango.EllipsizeMode)  {
var _arg0 *C.GtkToolItemGroup // out
var _arg1 C.PangoEllipsizeMode // out

_arg0 = (*C.GtkToolItemGroup)(unsafe.Pointer(g.Native()))
_arg1 = (C.PangoEllipsizeMode)(ellipsize)

C.gtk_tool_item_group_set_ellipsize(_arg0, _arg1)
}
	
	// SetHeaderRelief: set the button relief of the group header. See
// gtk_button_set_relief() for details.
	func (g ToolItemGroup) SetHeaderRelief(style ReliefStyle)  {
var _arg0 *C.GtkToolItemGroup // out
var _arg1 C.GtkReliefStyle // out

_arg0 = (*C.GtkToolItemGroup)(unsafe.Pointer(g.Native()))
_arg1 = (C.GtkReliefStyle)(style)

C.gtk_tool_item_group_set_header_relief(_arg0, _arg1)
}
	
	// SetItemPosition sets the position of @item in the list of children of @group.
	func (g ToolItemGroup) SetItemPosition(item ToolItemClass, position int)  {
var _arg0 *C.GtkToolItemGroup // out
var _arg1 *C.GtkToolItem // out
var _arg2 C.gint // out

_arg0 = (*C.GtkToolItemGroup)(unsafe.Pointer(g.Native()))
_arg1 = (*C.GtkToolItem)(unsafe.Pointer(item.Native()))
_arg2 = (C.gint)(position)

C.gtk_tool_item_group_set_item_position(_arg0, _arg1, _arg2)
}
	
	// SetLabel sets the label of the tool item group. The label is displayed in the
// header of the group.
	func (g ToolItemGroup) SetLabel(label string)  {
var _arg0 *C.GtkToolItemGroup // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkToolItemGroup)(unsafe.Pointer(g.Native()))
_arg1 = (*C.gchar)(C.CString(label))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_tool_item_group_set_label(_arg0, _arg1)
}
	
	// SetLabelWidget sets the label of the tool item group. The label widget is
// displayed in the header of the group, in place of the usual label.
	func (g ToolItemGroup) SetLabelWidget(labelWidget WidgetClass)  {
var _arg0 *C.GtkToolItemGroup // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkToolItemGroup)(unsafe.Pointer(g.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(labelWidget.Native()))

C.gtk_tool_item_group_set_label_widget(_arg0, _arg1)
}
	


	// ToolPalette: a ToolPalette allows you to add ToolItems to a palette-like
// container with different categories and drag and drop support.
// 
// A ToolPalette is created with a call to gtk_tool_palette_new().
// 
// ToolItems cannot be added directly to a ToolPalette - instead they are added
// to a ToolItemGroup which can than be added to a ToolPalette. To add a
// ToolItemGroup to a ToolPalette, use gtk_container_add().
// 
//    static void
//    passive_canvas_drag_data_received (GtkWidget        *widget,
//                                       GdkDragContext   *context,
//                                       gint              x,
//                                       gint              y,
//                                       GtkSelectionData *selection,
//                                       guint             info,
//                                       guint             time,
//                                       gpointer          data)
//    {
//      GtkWidget *palette;
//      GtkWidget *item;
// 
//      // Get the dragged item
//      palette = gtk_widget_get_ancestor (gtk_drag_get_source_widget (context),
//                                         GTK_TYPE_TOOL_PALETTE);
//      if (palette != NULL)
//        item = gtk_tool_palette_get_drag_item (GTK_TOOL_PALETTE (palette),
//                                               selection);
// 
//      // Do something with item
//    }
// 
//    GtkWidget *target, palette;
// 
//    palette = gtk_tool_palette_new ();
//    target = gtk_drawing_area_new ();
// 
//    g_signal_connect (G_OBJECT (target), "drag-data-received",
//                      G_CALLBACK (passive_canvas_drag_data_received), NULL);
//    gtk_tool_palette_add_drag_dest (GTK_TOOL_PALETTE (palette), target,
//                                    GTK_DEST_DEFAULT_ALL,
//                                    GTK_TOOL_PALETTE_DRAG_ITEMS,
//                                    GDK_ACTION_COPY);
// 
// 
// CSS nodes
// 
// GtkToolPalette has a single CSS node named toolpalette.
	type ToolPalette struct {
		Container
		Buildable
		Orientable
		Scrollable
		
	}

	// ToolPaletteClass is an interface that the ToolPalette class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ToolPaletteClass interface {
		gextras.Objector
		_toolPalette()
	}

	func (ToolPalette) _toolPalette() {}

	
	func marshalToolPalette(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapToolPalette(obj), nil
	}
	

	
	// NewToolPalette creates a new tool palette.
	func NewToolPalette() ToolPalette {
var _cret *C.GtkWidget // in

_cret = C.gtk_tool_palette_new()


var _toolPalette ToolPalette // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_toolPalette = ToolPalette{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Scrollable: Scrollable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _toolPalette
}
	

	
	// AddDragDest sets @palette as drag source (see
// gtk_tool_palette_set_drag_source()) and sets @widget as a drag destination
// for drags from @palette. See gtk_drag_dest_set().
	func (p ToolPalette) AddDragDest(widget WidgetClass, flags DestDefaults, targets ToolPaletteDragTargets, actions gdk.DragAction)  {
var _arg0 *C.GtkToolPalette // out
var _arg1 *C.GtkWidget // out
var _arg2 C.GtkDestDefaults // out
var _arg3 C.GtkToolPaletteDragTargets // out
var _arg4 C.GdkDragAction // out

_arg0 = (*C.GtkToolPalette)(unsafe.Pointer(p.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg2 = (C.GtkDestDefaults)(flags)
_arg3 = (C.GtkToolPaletteDragTargets)(targets)
_arg4 = (C.GdkDragAction)(actions)

C.gtk_tool_palette_add_drag_dest(_arg0, _arg1, _arg2, _arg3, _arg4)
}
	
	// DragItem: get the dragged item from the selection. This could be a ToolItem
// or a ToolItemGroup.
	func (p ToolPalette) DragItem(selection *SelectionData) Widget {
var _arg0 *C.GtkToolPalette // out
var _arg1 *C.GtkSelectionData // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkToolPalette)(unsafe.Pointer(p.Native()))
_arg1 = (*C.GtkSelectionData)(unsafe.Pointer(selection.Native()))

_cret = C.gtk_tool_palette_get_drag_item(_arg0, _arg1)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// DropGroup gets the group at position (x, y).
	func (p ToolPalette) DropGroup(x int, y int) ToolItemGroup {
var _arg0 *C.GtkToolPalette // out
var _arg1 C.gint // out
var _arg2 C.gint // out
var _cret *C.GtkToolItemGroup // in

_arg0 = (*C.GtkToolPalette)(unsafe.Pointer(p.Native()))
_arg1 = (C.gint)(x)
_arg2 = (C.gint)(y)

_cret = C.gtk_tool_palette_get_drop_group(_arg0, _arg1, _arg2)


var _toolItemGroup ToolItemGroup // out

_toolItemGroup = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(ToolItemGroup)

return _toolItemGroup
}
	
	// DropItem gets the item at position (x, y). See
// gtk_tool_palette_get_drop_group().
	func (p ToolPalette) DropItem(x int, y int) ToolItem {
var _arg0 *C.GtkToolPalette // out
var _arg1 C.gint // out
var _arg2 C.gint // out
var _cret *C.GtkToolItem // in

_arg0 = (*C.GtkToolPalette)(unsafe.Pointer(p.Native()))
_arg1 = (C.gint)(x)
_arg2 = (C.gint)(y)

_cret = C.gtk_tool_palette_get_drop_item(_arg0, _arg1, _arg2)


var _toolItem ToolItem // out

_toolItem = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(ToolItem)

return _toolItem
}
	
	// Exclusive gets whether @group is exclusive or not. See
// gtk_tool_palette_set_exclusive().
	func (p ToolPalette) Exclusive(group ToolItemGroupClass) bool {
var _arg0 *C.GtkToolPalette // out
var _arg1 *C.GtkToolItemGroup // out
var _cret C.gboolean // in

_arg0 = (*C.GtkToolPalette)(unsafe.Pointer(p.Native()))
_arg1 = (*C.GtkToolItemGroup)(unsafe.Pointer(group.Native()))

_cret = C.gtk_tool_palette_get_exclusive(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Expand gets whether group should be given extra space. See
// gtk_tool_palette_set_expand().
	func (p ToolPalette) Expand(group ToolItemGroupClass) bool {
var _arg0 *C.GtkToolPalette // out
var _arg1 *C.GtkToolItemGroup // out
var _cret C.gboolean // in

_arg0 = (*C.GtkToolPalette)(unsafe.Pointer(p.Native()))
_arg1 = (*C.GtkToolItemGroup)(unsafe.Pointer(group.Native()))

_cret = C.gtk_tool_palette_get_expand(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// GroupPosition gets the position of @group in @palette as index. See
// gtk_tool_palette_set_group_position().
	func (p ToolPalette) GroupPosition(group ToolItemGroupClass) int {
var _arg0 *C.GtkToolPalette // out
var _arg1 *C.GtkToolItemGroup // out
var _cret C.gint // in

_arg0 = (*C.GtkToolPalette)(unsafe.Pointer(p.Native()))
_arg1 = (*C.GtkToolItemGroup)(unsafe.Pointer(group.Native()))

_cret = C.gtk_tool_palette_get_group_position(_arg0, _arg1)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// HAdjustment gets the horizontal adjustment of the tool palette.
	func (p ToolPalette) HAdjustment() Adjustment {
var _arg0 *C.GtkToolPalette // out
var _cret *C.GtkAdjustment // in

_arg0 = (*C.GtkToolPalette)(unsafe.Pointer(p.Native()))

_cret = C.gtk_tool_palette_get_hadjustment(_arg0)


var _adjustment Adjustment // out

_adjustment = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Adjustment)

return _adjustment
}
	
	// IconSize gets the size of icons in the tool palette. See
// gtk_tool_palette_set_icon_size().
	func (p ToolPalette) IconSize() int {
var _arg0 *C.GtkToolPalette // out
var _cret C.GtkIconSize // in

_arg0 = (*C.GtkToolPalette)(unsafe.Pointer(p.Native()))

_cret = C.gtk_tool_palette_get_icon_size(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Style gets the style (icons, text or both) of items in the tool palette.
	func (p ToolPalette) Style() ToolbarStyle {
var _arg0 *C.GtkToolPalette // out
var _cret C.GtkToolbarStyle // in

_arg0 = (*C.GtkToolPalette)(unsafe.Pointer(p.Native()))

_cret = C.gtk_tool_palette_get_style(_arg0)


var _toolbarStyle ToolbarStyle // out

_toolbarStyle = ToolbarStyle(_cret)

return _toolbarStyle
}
	
	// VAdjustment gets the vertical adjustment of the tool palette.
	func (p ToolPalette) VAdjustment() Adjustment {
var _arg0 *C.GtkToolPalette // out
var _cret *C.GtkAdjustment // in

_arg0 = (*C.GtkToolPalette)(unsafe.Pointer(p.Native()))

_cret = C.gtk_tool_palette_get_vadjustment(_arg0)


var _adjustment Adjustment // out

_adjustment = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Adjustment)

return _adjustment
}
	
	// SetDragSource sets the tool palette as a drag source. Enables all groups and
// items in the tool palette as drag sources on button 1 and button 3 press with
// copy and move actions. See gtk_drag_source_set().
	func (p ToolPalette) SetDragSource(targets ToolPaletteDragTargets)  {
var _arg0 *C.GtkToolPalette // out
var _arg1 C.GtkToolPaletteDragTargets // out

_arg0 = (*C.GtkToolPalette)(unsafe.Pointer(p.Native()))
_arg1 = (C.GtkToolPaletteDragTargets)(targets)

C.gtk_tool_palette_set_drag_source(_arg0, _arg1)
}
	
	// SetExclusive sets whether the group should be exclusive or not. If an
// exclusive group is expanded all other groups are collapsed.
	func (p ToolPalette) SetExclusive(group ToolItemGroupClass, exclusive bool)  {
var _arg0 *C.GtkToolPalette // out
var _arg1 *C.GtkToolItemGroup // out
var _arg2 C.gboolean // out

_arg0 = (*C.GtkToolPalette)(unsafe.Pointer(p.Native()))
_arg1 = (*C.GtkToolItemGroup)(unsafe.Pointer(group.Native()))
if exclusive { _arg2 = C.TRUE }

C.gtk_tool_palette_set_exclusive(_arg0, _arg1, _arg2)
}
	
	// SetExpand sets whether the group should be given extra space.
	func (p ToolPalette) SetExpand(group ToolItemGroupClass, expand bool)  {
var _arg0 *C.GtkToolPalette // out
var _arg1 *C.GtkToolItemGroup // out
var _arg2 C.gboolean // out

_arg0 = (*C.GtkToolPalette)(unsafe.Pointer(p.Native()))
_arg1 = (*C.GtkToolItemGroup)(unsafe.Pointer(group.Native()))
if expand { _arg2 = C.TRUE }

C.gtk_tool_palette_set_expand(_arg0, _arg1, _arg2)
}
	
	// SetGroupPosition sets the position of the group as an index of the tool
// palette. If position is 0 the group will become the first child, if position
// is -1 it will become the last child.
	func (p ToolPalette) SetGroupPosition(group ToolItemGroupClass, position int)  {
var _arg0 *C.GtkToolPalette // out
var _arg1 *C.GtkToolItemGroup // out
var _arg2 C.gint // out

_arg0 = (*C.GtkToolPalette)(unsafe.Pointer(p.Native()))
_arg1 = (*C.GtkToolItemGroup)(unsafe.Pointer(group.Native()))
_arg2 = (C.gint)(position)

C.gtk_tool_palette_set_group_position(_arg0, _arg1, _arg2)
}
	
	// SetIconSize sets the size of icons in the tool palette.
	func (p ToolPalette) SetIconSize(iconSize int)  {
var _arg0 *C.GtkToolPalette // out
var _arg1 C.GtkIconSize // out

_arg0 = (*C.GtkToolPalette)(unsafe.Pointer(p.Native()))
_arg1 = (C.GtkIconSize)(iconSize)

C.gtk_tool_palette_set_icon_size(_arg0, _arg1)
}
	
	// SetStyle sets the style (text, icons or both) of items in the tool palette.
	func (p ToolPalette) SetStyle(style ToolbarStyle)  {
var _arg0 *C.GtkToolPalette // out
var _arg1 C.GtkToolbarStyle // out

_arg0 = (*C.GtkToolPalette)(unsafe.Pointer(p.Native()))
_arg1 = (C.GtkToolbarStyle)(style)

C.gtk_tool_palette_set_style(_arg0, _arg1)
}
	
	// UnsetIconSize unsets the tool palette icon size set with
// gtk_tool_palette_set_icon_size(), so that user preferences will be used to
// determine the icon size.
	func (p ToolPalette) UnsetIconSize()  {
var _arg0 *C.GtkToolPalette // out

_arg0 = (*C.GtkToolPalette)(unsafe.Pointer(p.Native()))

C.gtk_tool_palette_unset_icon_size(_arg0)
}
	
	// UnsetStyle unsets a toolbar style set with gtk_tool_palette_set_style(), so
// that user preferences will be used to determine the toolbar style.
	func (p ToolPalette) UnsetStyle()  {
var _arg0 *C.GtkToolPalette // out

_arg0 = (*C.GtkToolPalette)(unsafe.Pointer(p.Native()))

C.gtk_tool_palette_unset_style(_arg0)
}
	


	// Toolbar: a toolbar is created with a call to gtk_toolbar_new().
// 
// A toolbar can contain instances of a subclass of ToolItem. To add a ToolItem
// to the a toolbar, use gtk_toolbar_insert(). To remove an item from the
// toolbar use gtk_container_remove(). To add a button to the toolbar, add an
// instance of ToolButton.
// 
// Toolbar items can be visually grouped by adding instances of
// SeparatorToolItem to the toolbar. If the GtkToolbar child property “expand”
// is UE and the property SeparatorToolItem:draw is set to LSE, the effect is to
// force all following items to the end of the toolbar.
// 
// By default, a toolbar can be shrunk, upon which it will add an arrow button
// to show an overflow menu offering access to any ToolItem child that has a
// proxy menu item. To disable this and request enough size for all children,
// call gtk_toolbar_set_show_arrow() to set Toolbar:show-arrow to false.
// 
// Creating a context menu for the toolbar can be done by connecting to the
// Toolbar::popup-context-menu signal.
// 
// 
// CSS nodes
// 
// GtkToolbar has a single CSS node with name toolbar.
	type Toolbar struct {
		Container
		Buildable
		Orientable
		ToolShell
		
	}

	// ToolbarClass is an interface that the Toolbar class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ToolbarClass interface {
		gextras.Objector
		_toolbar()
	}

	func (Toolbar) _toolbar() {}

	
	func marshalToolbar(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapToolbar(obj), nil
	}
	

	
	// NewToolbar creates a new toolbar.
	func NewToolbar() Toolbar {
var _cret *C.GtkWidget // in

_cret = C.gtk_toolbar_new()


var _toolbar Toolbar // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_toolbar = Toolbar{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ToolShell: ToolShell{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
}
}

return _toolbar
}
	

	
	// DropIndex returns the position corresponding to the indicated point on
// @toolbar. This is useful when dragging items to the toolbar: this function
// returns the position a new item should be inserted.
// 
// @x and @y are in @toolbar coordinates.
	func (t Toolbar) DropIndex(x int, y int) int {
var _arg0 *C.GtkToolbar // out
var _arg1 C.gint // out
var _arg2 C.gint // out
var _cret C.gint // in

_arg0 = (*C.GtkToolbar)(unsafe.Pointer(t.Native()))
_arg1 = (C.gint)(x)
_arg2 = (C.gint)(y)

_cret = C.gtk_toolbar_get_drop_index(_arg0, _arg1, _arg2)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// IconSize retrieves the icon size for the toolbar. See
// gtk_toolbar_set_icon_size().
	func (t Toolbar) IconSize() IconSize {
var _arg0 *C.GtkToolbar // out
var _cret C.GtkIconSize // in

_arg0 = (*C.GtkToolbar)(unsafe.Pointer(t.Native()))

_cret = C.gtk_toolbar_get_icon_size(_arg0)


var _iconSize IconSize // out

_iconSize = IconSize(_cret)

return _iconSize
}
	
	// ItemIndex returns the position of @item on the toolbar, starting from 0. It
// is an error if @item is not a child of the toolbar.
	func (t Toolbar) ItemIndex(item ToolItemClass) int {
var _arg0 *C.GtkToolbar // out
var _arg1 *C.GtkToolItem // out
var _cret C.gint // in

_arg0 = (*C.GtkToolbar)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkToolItem)(unsafe.Pointer(item.Native()))

_cret = C.gtk_toolbar_get_item_index(_arg0, _arg1)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// NItems returns the number of items on the toolbar.
	func (t Toolbar) NItems() int {
var _arg0 *C.GtkToolbar // out
var _cret C.gint // in

_arg0 = (*C.GtkToolbar)(unsafe.Pointer(t.Native()))

_cret = C.gtk_toolbar_get_n_items(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// NthItem returns the @n'th item on @toolbar, or nil if the toolbar does not
// contain an @n'th item.
	func (t Toolbar) NthItem(n int) ToolItem {
var _arg0 *C.GtkToolbar // out
var _arg1 C.gint // out
var _cret *C.GtkToolItem // in

_arg0 = (*C.GtkToolbar)(unsafe.Pointer(t.Native()))
_arg1 = (C.gint)(n)

_cret = C.gtk_toolbar_get_nth_item(_arg0, _arg1)


var _toolItem ToolItem // out

_toolItem = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(ToolItem)

return _toolItem
}
	
	// ReliefStyle returns the relief style of buttons on @toolbar. See
// gtk_button_set_relief().
	func (t Toolbar) ReliefStyle() ReliefStyle {
var _arg0 *C.GtkToolbar // out
var _cret C.GtkReliefStyle // in

_arg0 = (*C.GtkToolbar)(unsafe.Pointer(t.Native()))

_cret = C.gtk_toolbar_get_relief_style(_arg0)


var _reliefStyle ReliefStyle // out

_reliefStyle = ReliefStyle(_cret)

return _reliefStyle
}
	
	// ShowArrow returns whether the toolbar has an overflow menu. See
// gtk_toolbar_set_show_arrow().
	func (t Toolbar) ShowArrow() bool {
var _arg0 *C.GtkToolbar // out
var _cret C.gboolean // in

_arg0 = (*C.GtkToolbar)(unsafe.Pointer(t.Native()))

_cret = C.gtk_toolbar_get_show_arrow(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Style retrieves whether the toolbar has text, icons, or both . See
// gtk_toolbar_set_style().
	func (t Toolbar) Style() ToolbarStyle {
var _arg0 *C.GtkToolbar // out
var _cret C.GtkToolbarStyle // in

_arg0 = (*C.GtkToolbar)(unsafe.Pointer(t.Native()))

_cret = C.gtk_toolbar_get_style(_arg0)


var _toolbarStyle ToolbarStyle // out

_toolbarStyle = ToolbarStyle(_cret)

return _toolbarStyle
}
	
	// Insert: insert a ToolItem into the toolbar at position @pos. If @pos is 0 the
// item is prepended to the start of the toolbar. If @pos is negative, the item
// is appended to the end of the toolbar.
	func (t Toolbar) Insert(item ToolItemClass, pos int)  {
var _arg0 *C.GtkToolbar // out
var _arg1 *C.GtkToolItem // out
var _arg2 C.gint // out

_arg0 = (*C.GtkToolbar)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkToolItem)(unsafe.Pointer(item.Native()))
_arg2 = (C.gint)(pos)

C.gtk_toolbar_insert(_arg0, _arg1, _arg2)
}
	
	// SetDropHighlightItem highlights @toolbar to give an idea of what it would
// look like if @item was added to @toolbar at the position indicated by
// @index_. If @item is nil, highlighting is turned off. In that case @index_ is
// ignored.
// 
// The @tool_item passed to this function must not be part of any widget
// hierarchy. When an item is set as drop highlight item it can not added to any
// widget hierarchy or used as highlight item for another toolbar.
	func (t Toolbar) SetDropHighlightItem(toolItem ToolItemClass, index_ int)  {
var _arg0 *C.GtkToolbar // out
var _arg1 *C.GtkToolItem // out
var _arg2 C.gint // out

_arg0 = (*C.GtkToolbar)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkToolItem)(unsafe.Pointer(toolItem.Native()))
_arg2 = (C.gint)(index_)

C.gtk_toolbar_set_drop_highlight_item(_arg0, _arg1, _arg2)
}
	
	// SetIconSize: this function sets the size of stock icons in the toolbar. You
// can call it both before you add the icons and after they’ve been added. The
// size you set will override user preferences for the default icon size.
// 
// This should only be used for special-purpose toolbars, normal application
// toolbars should respect the user preferences for the size of icons.
	func (t Toolbar) SetIconSize(iconSize IconSize)  {
var _arg0 *C.GtkToolbar // out
var _arg1 C.GtkIconSize // out

_arg0 = (*C.GtkToolbar)(unsafe.Pointer(t.Native()))
_arg1 = (C.GtkIconSize)(iconSize)

C.gtk_toolbar_set_icon_size(_arg0, _arg1)
}
	
	// SetShowArrow sets whether to show an overflow menu when @toolbar isn’t
// allocated enough size to show all of its items. If true, items which can’t
// fit in @toolbar, and which have a proxy menu item set by
// gtk_tool_item_set_proxy_menu_item() or ToolItem::create-menu-proxy, will be
// available in an overflow menu, which can be opened by an added arrow button.
// If false, @toolbar will request enough size to fit all of its child items
// without any overflow.
	func (t Toolbar) SetShowArrow(showArrow bool)  {
var _arg0 *C.GtkToolbar // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkToolbar)(unsafe.Pointer(t.Native()))
if showArrow { _arg1 = C.TRUE }

C.gtk_toolbar_set_show_arrow(_arg0, _arg1)
}
	
	// SetStyle alters the view of @toolbar to display either icons only, text only,
// or both.
	func (t Toolbar) SetStyle(style ToolbarStyle)  {
var _arg0 *C.GtkToolbar // out
var _arg1 C.GtkToolbarStyle // out

_arg0 = (*C.GtkToolbar)(unsafe.Pointer(t.Native()))
_arg1 = (C.GtkToolbarStyle)(style)

C.gtk_toolbar_set_style(_arg0, _arg1)
}
	
	// UnsetIconSize unsets toolbar icon size set with gtk_toolbar_set_icon_size(),
// so that user preferences will be used to determine the icon size.
	func (t Toolbar) UnsetIconSize()  {
var _arg0 *C.GtkToolbar // out

_arg0 = (*C.GtkToolbar)(unsafe.Pointer(t.Native()))

C.gtk_toolbar_unset_icon_size(_arg0)
}
	
	// UnsetStyle unsets a toolbar style set with gtk_toolbar_set_style(), so that
// user preferences will be used to determine the toolbar style.
	func (t Toolbar) UnsetStyle()  {
var _arg0 *C.GtkToolbar // out

_arg0 = (*C.GtkToolbar)(unsafe.Pointer(t.Native()))

C.gtk_toolbar_unset_style(_arg0)
}
	


	// Tooltip: basic tooltips can be realized simply by using
// gtk_widget_set_tooltip_text() or gtk_widget_set_tooltip_markup() without any
// explicit tooltip object.
// 
// When you need a tooltip with a little more fancy contents, like adding an
// image, or you want the tooltip to have different contents per TreeView row or
// cell, you will have to do a little more work:
// 
// - Set the Widget:has-tooltip property to true, this will make GTK+ monitor
// the widget for motion and related events which are needed to determine when
// and where to show a tooltip.
// 
// - Connect to the Widget::query-tooltip signal. This signal will be emitted
// when a tooltip is supposed to be shown. One of the arguments passed to the
// signal handler is a GtkTooltip object. This is the object that we are about
// to display as a tooltip, and can be manipulated in your callback using
// functions like gtk_tooltip_set_icon(). There are functions for setting the
// tooltip’s markup, setting an image from a named icon, or even putting in a
// custom widget.
// 
//    Return true from your query-tooltip handler. This causes the tooltip to be
//    show. If you return false, it will not be shown.
// 
// In the probably rare case where you want to have even more control over the
// tooltip that is about to be shown, you can set your own Window which will be
// used as tooltip window. This works as follows:
// 
// - Set Widget:has-tooltip and connect to Widget::query-tooltip as before. Use
// gtk_widget_set_tooltip_window() to set a Window created by you as tooltip
// window.
// 
// - In the Widget::query-tooltip callback you can access your window using
// gtk_widget_get_tooltip_window() and manipulate as you wish. The semantics of
// the return value are exactly as before, return true to show the window, false
// to not show it.
	type Tooltip struct {
		**externglib.Object
		
	}

	// TooltipClass is an interface that the Tooltip class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type TooltipClass interface {
		gextras.Objector
		_tooltip()
	}

	func (Tooltip) _tooltip() {}

	
	func marshalTooltip(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapTooltip(obj), nil
	}
	

	

	
	// SetCustom replaces the widget packed into the tooltip with @custom_widget.
// @custom_widget does not get destroyed when the tooltip goes away. By default
// a box with a Image and Label is embedded in the tooltip, which can be
// configured using gtk_tooltip_set_markup() and gtk_tooltip_set_icon().
	func (t Tooltip) SetCustom(customWidget WidgetClass)  {
var _arg0 *C.GtkTooltip // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkTooltip)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(customWidget.Native()))

C.gtk_tooltip_set_custom(_arg0, _arg1)
}
	
	// SetIcon sets the icon of the tooltip (which is in front of the text) to be
// @pixbuf. If @pixbuf is nil, the image will be hidden.
	func (t Tooltip) SetIcon(pixbuf gdkpixbuf.PixbufClass)  {
var _arg0 *C.GtkTooltip // out
var _arg1 *C.GdkPixbuf // out

_arg0 = (*C.GtkTooltip)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))

C.gtk_tooltip_set_icon(_arg0, _arg1)
}
	
	// SetIconFromGIcon sets the icon of the tooltip (which is in front of the text)
// to be the icon indicated by @gicon with the size indicated by @size. If
// @gicon is nil, the image will be hidden.
	func (t Tooltip) SetIconFromGIcon(gicon gio.Icon, size int)  {
var _arg0 *C.GtkTooltip // out
var _arg1 *C.GIcon // out
var _arg2 C.GtkIconSize // out

_arg0 = (*C.GtkTooltip)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GIcon)(unsafe.Pointer(gicon.Native()))
_arg2 = (C.GtkIconSize)(size)

C.gtk_tooltip_set_icon_from_gicon(_arg0, _arg1, _arg2)
}
	
	// SetIconFromIconName sets the icon of the tooltip (which is in front of the
// text) to be the icon indicated by @icon_name with the size indicated by
// @size. If @icon_name is nil, the image will be hidden.
	func (t Tooltip) SetIconFromIconName(iconName string, size int)  {
var _arg0 *C.GtkTooltip // out
var _arg1 *C.gchar // out
var _arg2 C.GtkIconSize // out

_arg0 = (*C.GtkTooltip)(unsafe.Pointer(t.Native()))
_arg1 = (*C.gchar)(C.CString(iconName))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.GtkIconSize)(size)

C.gtk_tooltip_set_icon_from_icon_name(_arg0, _arg1, _arg2)
}
	
	// SetIconFromStock sets the icon of the tooltip (which is in front of the text)
// to be the stock item indicated by @stock_id with the size indicated by @size.
// If @stock_id is nil, the image will be hidden.
	func (t Tooltip) SetIconFromStock(stockId string, size int)  {
var _arg0 *C.GtkTooltip // out
var _arg1 *C.gchar // out
var _arg2 C.GtkIconSize // out

_arg0 = (*C.GtkTooltip)(unsafe.Pointer(t.Native()))
_arg1 = (*C.gchar)(C.CString(stockId))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.GtkIconSize)(size)

C.gtk_tooltip_set_icon_from_stock(_arg0, _arg1, _arg2)
}
	
	// SetMarkup sets the text of the tooltip to be @markup, which is marked up with
// the [Pango text markup language][PangoMarkupFormat]. If @markup is nil, the
// label will be hidden.
	func (t Tooltip) SetMarkup(markup string)  {
var _arg0 *C.GtkTooltip // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkTooltip)(unsafe.Pointer(t.Native()))
_arg1 = (*C.gchar)(C.CString(markup))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_tooltip_set_markup(_arg0, _arg1)
}
	
	// SetText sets the text of the tooltip to be @text. If @text is nil, the label
// will be hidden. See also gtk_tooltip_set_markup().
	func (t Tooltip) SetText(text string)  {
var _arg0 *C.GtkTooltip // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkTooltip)(unsafe.Pointer(t.Native()))
_arg1 = (*C.gchar)(C.CString(text))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_tooltip_set_text(_arg0, _arg1)
}
	
	// SetTipArea sets the area of the widget, where the contents of this tooltip
// apply, to be @rect (in widget coordinates). This is especially useful for
// properly setting tooltips on TreeView rows and cells, IconViews, etc.
// 
// For setting tooltips on TreeView, please refer to the convenience functions
// for this: gtk_tree_view_set_tooltip_row() and
// gtk_tree_view_set_tooltip_cell().
	func (t Tooltip) SetTipArea(rect *gdk.Rectangle)  {
var _arg0 *C.GtkTooltip // out
var _arg1 *C.GdkRectangle // out

_arg0 = (*C.GtkTooltip)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GdkRectangle)(unsafe.Pointer(rect.Native()))

C.gtk_tooltip_set_tip_area(_arg0, _arg1)
}
	


	// TreeModelFilter: a TreeModelFilter is a tree model which wraps another tree
// model, and can do the following things:
// 
// - Filter specific rows, based on data from a “visible column”, a column
// storing booleans indicating whether the row should be filtered or not, or
// based on the return value of a “visible function”, which gets a model, iter
// and user_data and returns a boolean indicating whether the row should be
// filtered or not.
// 
// - Modify the “appearance” of the model, using a modify function. This is
// extremely powerful and allows for just changing some values and also for
// creating a completely different model based on the given child model.
// 
// - Set a different root node, also known as a “virtual root”. You can pass in
// a TreePath indicating the root node for the filter at construction time.
// 
// The basic API is similar to TreeModelSort. For an example on its usage, see
// the section on TreeModelSort.
// 
// When using TreeModelFilter, it is important to realize that TreeModelFilter
// maintains an internal cache of all nodes which are visible in its clients.
// The cache is likely to be a subtree of the tree exposed by the child model.
// TreeModelFilter will not cache the entire child model when unnecessary to not
// compromise the caching mechanism that is exposed by the reference counting
// scheme. If the child model implements reference counting, unnecessary signals
// may not be emitted because of reference counting rule 3, see the TreeModel
// documentation. (Note that e.g. TreeStore does not implement reference
// counting and will always emit all signals, even when the receiving node is
// not visible).
// 
// Because of this, limitations for possible visible functions do apply. In
// general, visible functions should only use data or properties from the node
// for which the visibility state must be determined, its siblings or its
// parents. Usually, having a dependency on the state of any child node is not
// possible, unless references are taken on these explicitly. When no such
// reference exists, no signals may be received for these child nodes (see
// reference couting rule number 3 in the TreeModel section).
// 
// Determining the visibility state of a given node based on the state of its
// child nodes is a frequently occurring use case. Therefore, TreeModelFilter
// explicitly supports this. For example, when a node does not have any
// children, you might not want the node to be visible. As soon as the first row
// is added to the node’s child level (or the last row removed), the node’s
// visibility should be updated.
// 
// This introduces a dependency from the node on its child nodes. In order to
// accommodate this, TreeModelFilter must make sure the necessary signals are
// received from the child model. This is achieved by building, for all nodes
// which are exposed as visible nodes to TreeModelFilter's clients, the child
// level (if any) and take a reference on the first node in this level.
// Furthermore, for every row-inserted, row-changed or row-deleted signal (also
// these which were not handled because the node was not cached),
// TreeModelFilter will check if the visibility state of any parent node has
// changed.
// 
// Beware, however, that this explicit support is limited to these two cases.
// For example, if you want a node to be visible only if two nodes in a child’s
// child level (2 levels deeper) are visible, you are on your own. In this case,
// either rely on TreeStore to emit all signals because it does not implement
// reference counting, or for models that do implement reference counting,
// obtain references on these child levels yourself.
	type TreeModelFilter struct {
		**externglib.Object
		TreeDragSource
		TreeModel
		
	}

	// TreeModelFilterClass is an interface that the TreeModelFilter class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type TreeModelFilterClass interface {
		gextras.Objector
		_treeModelFilter()
	}

	func (TreeModelFilter) _treeModelFilter() {}

	
	func marshalTreeModelFilter(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapTreeModelFilter(obj), nil
	}
	

	

	
	// ClearCache: this function should almost never be called. It clears the
// @filter of any cached iterators that haven’t been reffed with
// gtk_tree_model_ref_node(). This might be useful if the child model being
// filtered is static (and doesn’t change often) and there has been a lot of
// unreffed access to nodes. As a side effect of this function, all unreffed
// iters will be invalid.
	func (f TreeModelFilter) ClearCache()  {
var _arg0 *C.GtkTreeModelFilter // out

_arg0 = (*C.GtkTreeModelFilter)(unsafe.Pointer(f.Native()))

C.gtk_tree_model_filter_clear_cache(_arg0)
}
	
	// ConvertChildIterToIter sets @filter_iter to point to the row in @filter that
// corresponds to the row pointed at by @child_iter. If @filter_iter was not
// set, false is returned.
	func (f TreeModelFilter) ConvertChildIterToIter(childIter *TreeIter) (TreeIter, bool) {
var _arg0 *C.GtkTreeModelFilter // out
var _filterIter TreeIter
var _arg2 *C.GtkTreeIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeModelFilter)(unsafe.Pointer(f.Native()))
_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(childIter.Native()))

_cret = C.gtk_tree_model_filter_convert_child_iter_to_iter(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_filterIter)), _arg2)



var _ok bool // out


if _cret != 0 { _ok = true }

return _filterIter, _ok
}
	
	// ConvertChildPathToPath converts @child_path to a path relative to @filter.
// That is, @child_path points to a path in the child model. The rerturned path
// will point to the same row in the filtered model. If @child_path isn’t a
// valid path on the child model or points to a row which is not visible in
// @filter, then nil is returned.
	func (f TreeModelFilter) ConvertChildPathToPath(childPath *TreePath) *TreePath {
var _arg0 *C.GtkTreeModelFilter // out
var _arg1 *C.GtkTreePath // out
var _cret *C.GtkTreePath // in

_arg0 = (*C.GtkTreeModelFilter)(unsafe.Pointer(f.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(childPath.Native()))

_cret = C.gtk_tree_model_filter_convert_child_path_to_path(_arg0, _arg1)


var _treePath *TreePath // out

_treePath = *(**TreePath)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_treePath, func(v *TreePath) {
  C.free(unsafe.Pointer(v.Native()))
})

return _treePath
}
	
	// ConvertIterToChildIter sets @child_iter to point to the row pointed to by
// @filter_iter.
	func (f TreeModelFilter) ConvertIterToChildIter(filterIter *TreeIter) TreeIter {
var _arg0 *C.GtkTreeModelFilter // out
var _childIter TreeIter
var _arg2 *C.GtkTreeIter // out

_arg0 = (*C.GtkTreeModelFilter)(unsafe.Pointer(f.Native()))
_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(filterIter.Native()))

C.gtk_tree_model_filter_convert_iter_to_child_iter(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_childIter)), _arg2)





return _childIter
}
	
	// ConvertPathToChildPath converts @filter_path to a path on the child model of
// @filter. That is, @filter_path points to a location in @filter. The returned
// path will point to the same location in the model not being filtered. If
// @filter_path does not point to a location in the child model, nil is
// returned.
	func (f TreeModelFilter) ConvertPathToChildPath(filterPath *TreePath) *TreePath {
var _arg0 *C.GtkTreeModelFilter // out
var _arg1 *C.GtkTreePath // out
var _cret *C.GtkTreePath // in

_arg0 = (*C.GtkTreeModelFilter)(unsafe.Pointer(f.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(filterPath.Native()))

_cret = C.gtk_tree_model_filter_convert_path_to_child_path(_arg0, _arg1)


var _treePath *TreePath // out

_treePath = *(**TreePath)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_treePath, func(v *TreePath) {
  C.free(unsafe.Pointer(v.Native()))
})

return _treePath
}
	
	// Model returns a pointer to the child model of @filter.
	func (f TreeModelFilter) Model() TreeModel {
var _arg0 *C.GtkTreeModelFilter // out
var _cret *C.GtkTreeModel // in

_arg0 = (*C.GtkTreeModelFilter)(unsafe.Pointer(f.Native()))

_cret = C.gtk_tree_model_filter_get_model(_arg0)


var _treeModel TreeModel // out

_treeModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TreeModel)

return _treeModel
}
	
	// Refilter emits ::row_changed for each row in the child model, which causes
// the filter to re-evaluate whether a row is visible or not.
	func (f TreeModelFilter) Refilter()  {
var _arg0 *C.GtkTreeModelFilter // out

_arg0 = (*C.GtkTreeModelFilter)(unsafe.Pointer(f.Native()))

C.gtk_tree_model_filter_refilter(_arg0)
}
	
	// SetVisibleColumn sets @column of the child_model to be the column where
// @filter should look for visibility information. @columns should be a column
// of type G_TYPE_BOOLEAN, where true means that a row is visible, and false if
// not.
// 
// Note that gtk_tree_model_filter_set_visible_func() or
// gtk_tree_model_filter_set_visible_column() can only be called once for a
// given filter model.
	func (f TreeModelFilter) SetVisibleColumn(column int)  {
var _arg0 *C.GtkTreeModelFilter // out
var _arg1 C.gint // out

_arg0 = (*C.GtkTreeModelFilter)(unsafe.Pointer(f.Native()))
_arg1 = (C.gint)(column)

C.gtk_tree_model_filter_set_visible_column(_arg0, _arg1)
}
	


	// TreeModelSort: the TreeModelSort is a model which implements the TreeSortable
// interface. It does not hold any data itself, but rather is created with a
// child model and proxies its data. It has identical column types to this child
// model, and the changes in the child are propagated. The primary purpose of
// this model is to provide a way to sort a different model without modifying
// it. Note that the sort function used by TreeModelSort is not guaranteed to be
// stable.
// 
// The use of this is best demonstrated through an example. In the following
// sample code we create two TreeView widgets each with a view of the same data.
// As the model is wrapped here by a TreeModelSort, the two TreeViews can each
// sort their view of the data without affecting the other. By contrast, if we
// simply put the same model in each widget, then sorting the first would sort
// the second.
// 
// Using a TreeModelSort
// 
//    void
//    selection_changed (GtkTreeSelection *selection, gpointer data)
//    {
//      GtkTreeModel *sort_model = NULL;
//      GtkTreeModel *child_model;
//      GtkTreeIter sort_iter;
//      GtkTreeIter child_iter;
//      char *some_data = NULL;
//      char *modified_data;
// 
//      // Get the current selected row and the model.
//      if (! gtk_tree_selection_get_selected (selection,
//                                             &sort_model,
//                                             &sort_iter))
//        return;
// 
//      // Look up the current value on the selected row and get
//      // a new value to change it to.
//      gtk_tree_model_get (GTK_TREE_MODEL (sort_model), &sort_iter,
//                          COLUMN_1, &some_data,
//                          -1);
// 
//      modified_data = change_the_data (some_data);
//      g_free (some_data);
// 
//      // Get an iterator on the child model, instead of the sort model.
//      gtk_tree_model_sort_convert_iter_to_child_iter (GTK_TREE_MODEL_SORT (sort_model),
//                                                      &child_iter,
//                                                      &sort_iter);
// 
//      // Get the child model and change the value of the row. In this
//      // example, the child model is a GtkListStore. It could be any other
//      // type of model, though.
//      child_model = gtk_tree_model_sort_get_model (GTK_TREE_MODEL_SORT (sort_model));
//      gtk_list_store_set (GTK_LIST_STORE (child_model), &child_iter,
//                          COLUMN_1, &modified_data,
//                          -1);
//      g_free (modified_data);
//    }
	type TreeModelSort struct {
		**externglib.Object
		TreeDragSource
		TreeModel
		TreeSortable
		
	}

	// TreeModelSortClass is an interface that the TreeModelSort class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type TreeModelSortClass interface {
		gextras.Objector
		_treeModelSort()
	}

	func (TreeModelSort) _treeModelSort() {}

	
	func marshalTreeModelSort(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapTreeModelSort(obj), nil
	}
	

	
	// NewTreeModelSortWithModel creates a new TreeModelSort, with @child_model as
// the child model.
	func NewTreeModelSortWithModel(childModel TreeModel) TreeModelSort {
var _arg1 *C.GtkTreeModel // out
var _cret *C.GtkTreeModel // in

_arg1 = (*C.GtkTreeModel)(unsafe.Pointer(childModel.Native()))

_cret = C.gtk_tree_model_sort_new_with_model(_arg1)


var _treeModelSort TreeModelSort // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_treeModelSort = TreeModelSort{
Object: &externglib.Object{externglib.ToGObject(obj)},
TreeDragSource: TreeDragSource{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
TreeModel: TreeModel{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
TreeSortable: TreeSortable{
TreeModel: TreeModel{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
}
}

return _treeModelSort
}
	

	
	// ClearCache: this function should almost never be called. It clears the
// @tree_model_sort of any cached iterators that haven’t been reffed with
// gtk_tree_model_ref_node(). This might be useful if the child model being
// sorted is static (and doesn’t change often) and there has been a lot of
// unreffed access to nodes. As a side effect of this function, all unreffed
// iters will be invalid.
	func (t TreeModelSort) ClearCache()  {
var _arg0 *C.GtkTreeModelSort // out

_arg0 = (*C.GtkTreeModelSort)(unsafe.Pointer(t.Native()))

C.gtk_tree_model_sort_clear_cache(_arg0)
}
	
	// ConvertChildIterToIter sets @sort_iter to point to the row in
// @tree_model_sort that corresponds to the row pointed at by @child_iter. If
// @sort_iter was not set, false is returned. Note: a boolean is only returned
// since 2.14.
	func (t TreeModelSort) ConvertChildIterToIter(childIter *TreeIter) (TreeIter, bool) {
var _arg0 *C.GtkTreeModelSort // out
var _sortIter TreeIter
var _arg2 *C.GtkTreeIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeModelSort)(unsafe.Pointer(t.Native()))
_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(childIter.Native()))

_cret = C.gtk_tree_model_sort_convert_child_iter_to_iter(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_sortIter)), _arg2)



var _ok bool // out


if _cret != 0 { _ok = true }

return _sortIter, _ok
}
	
	// ConvertChildPathToPath converts @child_path to a path relative to
// @tree_model_sort. That is, @child_path points to a path in the child model.
// The returned path will point to the same row in the sorted model. If
// @child_path isn’t a valid path on the child model, then nil is returned.
	func (t TreeModelSort) ConvertChildPathToPath(childPath *TreePath) *TreePath {
var _arg0 *C.GtkTreeModelSort // out
var _arg1 *C.GtkTreePath // out
var _cret *C.GtkTreePath // in

_arg0 = (*C.GtkTreeModelSort)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(childPath.Native()))

_cret = C.gtk_tree_model_sort_convert_child_path_to_path(_arg0, _arg1)


var _treePath *TreePath // out

_treePath = *(**TreePath)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_treePath, func(v *TreePath) {
  C.free(unsafe.Pointer(v.Native()))
})

return _treePath
}
	
	// ConvertIterToChildIter sets @child_iter to point to the row pointed to by
// @sorted_iter.
	func (t TreeModelSort) ConvertIterToChildIter(sortedIter *TreeIter) TreeIter {
var _arg0 *C.GtkTreeModelSort // out
var _childIter TreeIter
var _arg2 *C.GtkTreeIter // out

_arg0 = (*C.GtkTreeModelSort)(unsafe.Pointer(t.Native()))
_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(sortedIter.Native()))

C.gtk_tree_model_sort_convert_iter_to_child_iter(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_childIter)), _arg2)





return _childIter
}
	
	// ConvertPathToChildPath converts @sorted_path to a path on the child model of
// @tree_model_sort. That is, @sorted_path points to a location in
// @tree_model_sort. The returned path will point to the same location in the
// model not being sorted. If @sorted_path does not point to a location in the
// child model, nil is returned.
	func (t TreeModelSort) ConvertPathToChildPath(sortedPath *TreePath) *TreePath {
var _arg0 *C.GtkTreeModelSort // out
var _arg1 *C.GtkTreePath // out
var _cret *C.GtkTreePath // in

_arg0 = (*C.GtkTreeModelSort)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(sortedPath.Native()))

_cret = C.gtk_tree_model_sort_convert_path_to_child_path(_arg0, _arg1)


var _treePath *TreePath // out

_treePath = *(**TreePath)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_treePath, func(v *TreePath) {
  C.free(unsafe.Pointer(v.Native()))
})

return _treePath
}
	
	// Model returns the model the TreeModelSort is sorting.
	func (t TreeModelSort) Model() TreeModel {
var _arg0 *C.GtkTreeModelSort // out
var _cret *C.GtkTreeModel // in

_arg0 = (*C.GtkTreeModelSort)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_model_sort_get_model(_arg0)


var _treeModel TreeModel // out

_treeModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TreeModel)

return _treeModel
}
	
	// IterIsValid: > This function is slow. Only use it for debugging and/or
// testing > purposes.
// 
// Checks if the given iter is a valid iter for this TreeModelSort.
	func (t TreeModelSort) IterIsValid(iter *TreeIter) bool {
var _arg0 *C.GtkTreeModelSort // out
var _arg1 *C.GtkTreeIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeModelSort)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

_cret = C.gtk_tree_model_sort_iter_is_valid(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ResetDefaultSortFunc: this resets the default sort function to be in the
// “unsorted” state. That is, it is in the same order as the child model. It
// will re-sort the model to be in the same order as the child model only if the
// TreeModelSort is in “unsorted” state.
	func (t TreeModelSort) ResetDefaultSortFunc()  {
var _arg0 *C.GtkTreeModelSort // out

_arg0 = (*C.GtkTreeModelSort)(unsafe.Pointer(t.Native()))

C.gtk_tree_model_sort_reset_default_sort_func(_arg0)
}
	


	// TreeSelection: the TreeSelection object is a helper object to manage the
// selection for a TreeView widget. The TreeSelection object is automatically
// created when a new TreeView widget is created, and cannot exist independently
// of this widget. The primary reason the TreeSelection objects exists is for
// cleanliness of code and API. That is, there is no conceptual reason all these
// functions could not be methods on the TreeView widget instead of a separate
// function.
// 
// The TreeSelection object is gotten from a TreeView by calling
// gtk_tree_view_get_selection(). It can be manipulated to check the selection
// status of the tree, as well as select and deselect individual rows. Selection
// is done completely view side. As a result, multiple views of the same model
// can have completely different selections. Additionally, you cannot change the
// selection of a row on the model that is not currently displayed by the view
// without expanding its parents first.
// 
// One of the important things to remember when monitoring the selection of a
// view is that the TreeSelection::changed signal is mostly a hint. That is, it
// may only emit one signal when a range of rows is selected. Additionally, it
// may on occasion emit a TreeSelection::changed signal when nothing has
// happened (mostly as a result of programmers calling select_row on an already
// selected row).
	type TreeSelection struct {
		**externglib.Object
		
	}

	// TreeSelectionClass is an interface that the TreeSelection class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type TreeSelectionClass interface {
		gextras.Objector
		_treeSelection()
	}

	func (TreeSelection) _treeSelection() {}

	
	func marshalTreeSelection(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapTreeSelection(obj), nil
	}
	

	

	
	// CountSelectedRows returns the number of rows that have been selected in
// @tree.
	func (s TreeSelection) CountSelectedRows() int {
var _arg0 *C.GtkTreeSelection // out
var _cret C.gint // in

_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))

_cret = C.gtk_tree_selection_count_selected_rows(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Mode gets the selection mode for @selection. See
// gtk_tree_selection_set_mode().
	func (s TreeSelection) Mode() SelectionMode {
var _arg0 *C.GtkTreeSelection // out
var _cret C.GtkSelectionMode // in

_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))

_cret = C.gtk_tree_selection_get_mode(_arg0)


var _selectionMode SelectionMode // out

_selectionMode = SelectionMode(_cret)

return _selectionMode
}
	
	// Selected sets @iter to the currently selected node if @selection is set to
// K_SELECTION_SINGLE or K_SELECTION_BROWSE. @iter may be NULL if you just want
// to test if @selection has any selected nodes. @model is filled with the
// current model as a convenience. This function will not work if you use
// @selection is K_SELECTION_MULTIPLE.
	func (s TreeSelection) Selected() (TreeModel, TreeIter, bool) {
var _arg0 *C.GtkTreeSelection // out
var _arg1 *C.GtkTreeModel // in
var _iter TreeIter
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))

_cret = C.gtk_tree_selection_get_selected(_arg0, &_arg1, (*C.GtkTreeIter)(unsafe.Pointer(&_iter)))


var _model TreeModel // out

var _ok bool // out

_model = gextras.CastObject(externglib.Take(unsafe.Pointer(_arg1))).(TreeModel)

if _cret != 0 { _ok = true }

return _model, _iter, _ok
}
	
	// TreeView returns the tree view associated with @selection.
	func (s TreeSelection) TreeView() TreeView {
var _arg0 *C.GtkTreeSelection // out
var _cret *C.GtkTreeView // in

_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))

_cret = C.gtk_tree_selection_get_tree_view(_arg0)


var _treeView TreeView // out

_treeView = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TreeView)

return _treeView
}
	
	// IterIsSelected returns true if the row at @iter is currently selected.
	func (s TreeSelection) IterIsSelected(iter *TreeIter) bool {
var _arg0 *C.GtkTreeSelection // out
var _arg1 *C.GtkTreeIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

_cret = C.gtk_tree_selection_iter_is_selected(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// PathIsSelected returns true if the row pointed to by @path is currently
// selected. If @path does not point to a valid location, false is returned
	func (s TreeSelection) PathIsSelected(path *TreePath) bool {
var _arg0 *C.GtkTreeSelection // out
var _arg1 *C.GtkTreePath // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

_cret = C.gtk_tree_selection_path_is_selected(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SelectAll selects all the nodes. @selection must be set to
// K_SELECTION_MULTIPLE mode.
	func (s TreeSelection) SelectAll()  {
var _arg0 *C.GtkTreeSelection // out

_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))

C.gtk_tree_selection_select_all(_arg0)
}
	
	// SelectIter selects the specified iterator.
	func (s TreeSelection) SelectIter(iter *TreeIter)  {
var _arg0 *C.GtkTreeSelection // out
var _arg1 *C.GtkTreeIter // out

_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

C.gtk_tree_selection_select_iter(_arg0, _arg1)
}
	
	// SelectPath: select the row at @path.
	func (s TreeSelection) SelectPath(path *TreePath)  {
var _arg0 *C.GtkTreeSelection // out
var _arg1 *C.GtkTreePath // out

_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

C.gtk_tree_selection_select_path(_arg0, _arg1)
}
	
	// SelectRange selects a range of nodes, determined by @start_path and @end_path
// inclusive. @selection must be set to K_SELECTION_MULTIPLE mode.
	func (s TreeSelection) SelectRange(startPath *TreePath, endPath *TreePath)  {
var _arg0 *C.GtkTreeSelection // out
var _arg1 *C.GtkTreePath // out
var _arg2 *C.GtkTreePath // out

_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(startPath.Native()))
_arg2 = (*C.GtkTreePath)(unsafe.Pointer(endPath.Native()))

C.gtk_tree_selection_select_range(_arg0, _arg1, _arg2)
}
	
	// SetMode sets the selection mode of the @selection. If the previous type was
// K_SELECTION_MULTIPLE, then the anchor is kept selected, if it was previously
// selected.
	func (s TreeSelection) SetMode(typ SelectionMode)  {
var _arg0 *C.GtkTreeSelection // out
var _arg1 C.GtkSelectionMode // out

_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkSelectionMode)(typ)

C.gtk_tree_selection_set_mode(_arg0, _arg1)
}
	
	// UnselectAll unselects all the nodes.
	func (s TreeSelection) UnselectAll()  {
var _arg0 *C.GtkTreeSelection // out

_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))

C.gtk_tree_selection_unselect_all(_arg0)
}
	
	// UnselectIter unselects the specified iterator.
	func (s TreeSelection) UnselectIter(iter *TreeIter)  {
var _arg0 *C.GtkTreeSelection // out
var _arg1 *C.GtkTreeIter // out

_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

C.gtk_tree_selection_unselect_iter(_arg0, _arg1)
}
	
	// UnselectPath unselects the row at @path.
	func (s TreeSelection) UnselectPath(path *TreePath)  {
var _arg0 *C.GtkTreeSelection // out
var _arg1 *C.GtkTreePath // out

_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

C.gtk_tree_selection_unselect_path(_arg0, _arg1)
}
	
	// UnselectRange unselects a range of nodes, determined by @start_path and
// @end_path inclusive.
	func (s TreeSelection) UnselectRange(startPath *TreePath, endPath *TreePath)  {
var _arg0 *C.GtkTreeSelection // out
var _arg1 *C.GtkTreePath // out
var _arg2 *C.GtkTreePath // out

_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(startPath.Native()))
_arg2 = (*C.GtkTreePath)(unsafe.Pointer(endPath.Native()))

C.gtk_tree_selection_unselect_range(_arg0, _arg1, _arg2)
}
	


	// TreeStore: the TreeStore object is a list model for use with a TreeView
// widget. It implements the TreeModel interface, and consequentially, can use
// all of the methods available there. It also implements the TreeSortable
// interface so it can be sorted by the view. Finally, it also implements the
// tree [drag and drop][gtk3-GtkTreeView-drag-and-drop] interfaces.
// 
// 
// GtkTreeStore as GtkBuildable
// 
// The GtkTreeStore implementation of the Buildable interface allows to specify
// the model columns with a <columns> element that may contain multiple <column>
// elements, each specifying one model column. The “type” attribute specifies
// the data type for the column.
// 
// An example of a UI Definition fragment for a tree store:
// 
//    <object class="GtkTreeStore">
//      <columns>
//        <column type="gchararray"/>
//        <column type="gchararray"/>
//        <column type="gint"/>
//      </columns>
//    </object>
	type TreeStore struct {
		**externglib.Object
		Buildable
		TreeDragDest
		TreeDragSource
		TreeModel
		TreeSortable
		
	}

	// TreeStoreClass is an interface that the TreeStore class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type TreeStoreClass interface {
		gextras.Objector
		_treeStore()
	}

	func (TreeStore) _treeStore() {}

	
	func marshalTreeStore(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapTreeStore(obj), nil
	}
	

	
	// NewTreeStoreV: non vararg creation function. Used primarily by language
// bindings.
	func NewTreeStoreV(types []externglib.Type) TreeStore {
var _arg2 *C.GType
var _arg1 C.gint
var _cret *C.GtkTreeStore // in

_arg1 = C.gint(len(types))
_arg2 = (*C.GType)(C.malloc(C.ulong(len(types)) * C.ulong(C.sizeof_GType)))
defer C.free(unsafe.Pointer(_arg2))
{
out := unsafe.Slice(_arg2, len(types))
for i := range types {
out[i] = C.GType(types[i])
}
}

_cret = C.gtk_tree_store_newv(_arg1, _arg2)


var _treeStore TreeStore // out

_treeStore = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(TreeStore)

return _treeStore
}
	

	
	// Append appends a new row to @tree_store. If @parent is non-nil, then it will
// append the new row after the last child of @parent, otherwise it will append
// a row to the top level. @iter will be changed to point to this new row. The
// row will be empty after this function is called. To fill in values, you need
// to call gtk_tree_store_set() or gtk_tree_store_set_value().
	func (t TreeStore) Append(parent *TreeIter) TreeIter {
var _arg0 *C.GtkTreeStore // out
var _iter TreeIter
var _arg2 *C.GtkTreeIter // out

_arg0 = (*C.GtkTreeStore)(unsafe.Pointer(t.Native()))
_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(parent.Native()))

C.gtk_tree_store_append(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_iter)), _arg2)





return _iter
}
	
	// Clear removes all rows from @tree_store
	func (t TreeStore) Clear()  {
var _arg0 *C.GtkTreeStore // out

_arg0 = (*C.GtkTreeStore)(unsafe.Pointer(t.Native()))

C.gtk_tree_store_clear(_arg0)
}
	
	// Insert creates a new row at @position. If parent is non-nil, then the row
// will be made a child of @parent. Otherwise, the row will be created at the
// toplevel. If @position is -1 or is larger than the number of rows at that
// level, then the new row will be inserted to the end of the list. @iter will
// be changed to point to this new row. The row will be empty after this
// function is called. To fill in values, you need to call gtk_tree_store_set()
// or gtk_tree_store_set_value().
	func (t TreeStore) Insert(parent *TreeIter, position int) TreeIter {
var _arg0 *C.GtkTreeStore // out
var _iter TreeIter
var _arg2 *C.GtkTreeIter // out
var _arg3 C.gint // out

_arg0 = (*C.GtkTreeStore)(unsafe.Pointer(t.Native()))
_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(parent.Native()))
_arg3 = (C.gint)(position)

C.gtk_tree_store_insert(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_iter)), _arg2, _arg3)





return _iter
}
	
	// InsertAfter inserts a new row after @sibling. If @sibling is nil, then the
// row will be prepended to @parent ’s children. If @parent and @sibling are
// nil, then the row will be prepended to the toplevel. If both @sibling and
// @parent are set, then @parent must be the parent of @sibling. When @sibling
// is set, @parent is optional.
// 
// @iter will be changed to point to this new row. The row will be empty after
// this function is called. To fill in values, you need to call
// gtk_tree_store_set() or gtk_tree_store_set_value().
	func (t TreeStore) InsertAfter(parent *TreeIter, sibling *TreeIter) TreeIter {
var _arg0 *C.GtkTreeStore // out
var _iter TreeIter
var _arg2 *C.GtkTreeIter // out
var _arg3 *C.GtkTreeIter // out

_arg0 = (*C.GtkTreeStore)(unsafe.Pointer(t.Native()))
_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(parent.Native()))
_arg3 = (*C.GtkTreeIter)(unsafe.Pointer(sibling.Native()))

C.gtk_tree_store_insert_after(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_iter)), _arg2, _arg3)





return _iter
}
	
	// InsertBefore inserts a new row before @sibling. If @sibling is nil, then the
// row will be appended to @parent ’s children. If @parent and @sibling are nil,
// then the row will be appended to the toplevel. If both @sibling and @parent
// are set, then @parent must be the parent of @sibling. When @sibling is set,
// @parent is optional.
// 
// @iter will be changed to point to this new row. The row will be empty after
// this function is called. To fill in values, you need to call
// gtk_tree_store_set() or gtk_tree_store_set_value().
	func (t TreeStore) InsertBefore(parent *TreeIter, sibling *TreeIter) TreeIter {
var _arg0 *C.GtkTreeStore // out
var _iter TreeIter
var _arg2 *C.GtkTreeIter // out
var _arg3 *C.GtkTreeIter // out

_arg0 = (*C.GtkTreeStore)(unsafe.Pointer(t.Native()))
_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(parent.Native()))
_arg3 = (*C.GtkTreeIter)(unsafe.Pointer(sibling.Native()))

C.gtk_tree_store_insert_before(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_iter)), _arg2, _arg3)





return _iter
}
	
	// InsertWithValuesv: a variant of gtk_tree_store_insert_with_values() which
// takes the columns and values as two arrays, instead of varargs. This function
// is mainly intended for language bindings.
	func (t TreeStore) InsertWithValuesv(parent *TreeIter, position int, columns []int, values []**externglib.Value) TreeIter {
var _arg0 *C.GtkTreeStore // out
var _iter TreeIter
var _arg2 *C.GtkTreeIter // out
var _arg3 C.gint // out
var _arg4 *C.gint
var _arg6 C.gint
var _arg5 *C.GValue
var _arg6 C.gint

_arg0 = (*C.GtkTreeStore)(unsafe.Pointer(t.Native()))
_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(parent.Native()))
_arg3 = (C.gint)(position)
_arg6 = C.gint(len(columns))
_arg4 = (*C.gint)(unsafe.Pointer(&columns[0]))
_arg6 = C.gint(len(values))
_arg5 = (*C.GValue)(C.malloc(C.ulong(len(values)) * C.ulong(C.sizeof_GValue)))
defer C.free(unsafe.Pointer(_arg5))
{
out := unsafe.Slice(_arg5, len(values))
for i := range values {
out[i] = (*C.GValue)(values[i].GValue)
}
}

C.gtk_tree_store_insert_with_valuesv(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_iter)), _arg2, _arg3, _arg4, _arg5, _arg6)





return _iter
}
	
	// IsAncestor returns true if @iter is an ancestor of @descendant. That is,
// @iter is the parent (or grandparent or great-grandparent) of @descendant.
	func (t TreeStore) IsAncestor(iter *TreeIter, descendant *TreeIter) bool {
var _arg0 *C.GtkTreeStore // out
var _arg1 *C.GtkTreeIter // out
var _arg2 *C.GtkTreeIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeStore)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))
_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(descendant.Native()))

_cret = C.gtk_tree_store_is_ancestor(_arg0, _arg1, _arg2)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IterDepth returns the depth of @iter. This will be 0 for anything on the root
// level, 1 for anything down a level, etc.
	func (t TreeStore) IterDepth(iter *TreeIter) int {
var _arg0 *C.GtkTreeStore // out
var _arg1 *C.GtkTreeIter // out
var _cret C.gint // in

_arg0 = (*C.GtkTreeStore)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

_cret = C.gtk_tree_store_iter_depth(_arg0, _arg1)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// IterIsValid: WARNING: This function is slow. Only use it for debugging and/or
// testing purposes.
// 
// Checks if the given iter is a valid iter for this TreeStore.
	func (t TreeStore) IterIsValid(iter *TreeIter) bool {
var _arg0 *C.GtkTreeStore // out
var _arg1 *C.GtkTreeIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeStore)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

_cret = C.gtk_tree_store_iter_is_valid(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// MoveAfter moves @iter in @tree_store to the position after @position. @iter
// and @position should be in the same level. Note that this function only works
// with unsorted stores. If @position is nil, @iter will be moved to the start
// of the level.
	func (t TreeStore) MoveAfter(iter *TreeIter, position *TreeIter)  {
var _arg0 *C.GtkTreeStore // out
var _arg1 *C.GtkTreeIter // out
var _arg2 *C.GtkTreeIter // out

_arg0 = (*C.GtkTreeStore)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))
_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(position.Native()))

C.gtk_tree_store_move_after(_arg0, _arg1, _arg2)
}
	
	// MoveBefore moves @iter in @tree_store to the position before @position. @iter
// and @position should be in the same level. Note that this function only works
// with unsorted stores. If @position is nil, @iter will be moved to the end of
// the level.
	func (t TreeStore) MoveBefore(iter *TreeIter, position *TreeIter)  {
var _arg0 *C.GtkTreeStore // out
var _arg1 *C.GtkTreeIter // out
var _arg2 *C.GtkTreeIter // out

_arg0 = (*C.GtkTreeStore)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))
_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(position.Native()))

C.gtk_tree_store_move_before(_arg0, _arg1, _arg2)
}
	
	// Prepend prepends a new row to @tree_store. If @parent is non-nil, then it
// will prepend the new row before the first child of @parent, otherwise it will
// prepend a row to the top level. @iter will be changed to point to this new
// row. The row will be empty after this function is called. To fill in values,
// you need to call gtk_tree_store_set() or gtk_tree_store_set_value().
	func (t TreeStore) Prepend(parent *TreeIter) TreeIter {
var _arg0 *C.GtkTreeStore // out
var _iter TreeIter
var _arg2 *C.GtkTreeIter // out

_arg0 = (*C.GtkTreeStore)(unsafe.Pointer(t.Native()))
_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(parent.Native()))

C.gtk_tree_store_prepend(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_iter)), _arg2)





return _iter
}
	
	// Remove removes @iter from @tree_store. After being removed, @iter is set to
// the next valid row at that level, or invalidated if it previously pointed to
// the last one.
	func (t TreeStore) Remove(iter *TreeIter) bool {
var _arg0 *C.GtkTreeStore // out
var _arg1 *C.GtkTreeIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeStore)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

_cret = C.gtk_tree_store_remove(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetColumnTypes: this function is meant primarily for #GObjects that inherit
// from TreeStore, and should only be used when constructing a new TreeStore. It
// will not function after a row has been added, or a method on the TreeModel
// interface is called.
	func (t TreeStore) SetColumnTypes(types []externglib.Type)  {
var _arg0 *C.GtkTreeStore // out
var _arg2 *C.GType
var _arg1 C.gint

_arg0 = (*C.GtkTreeStore)(unsafe.Pointer(t.Native()))
_arg1 = C.gint(len(types))
_arg2 = (*C.GType)(C.malloc(C.ulong(len(types)) * C.ulong(C.sizeof_GType)))
defer C.free(unsafe.Pointer(_arg2))
{
out := unsafe.Slice(_arg2, len(types))
for i := range types {
out[i] = C.GType(types[i])
}
}

C.gtk_tree_store_set_column_types(_arg0, _arg1, _arg2)
}
	
	// SetValue sets the data in the cell specified by @iter and @column. The type
// of @value must be convertible to the type of the column.
	func (t TreeStore) SetValue(iter *TreeIter, column int, value **externglib.Value)  {
var _arg0 *C.GtkTreeStore // out
var _arg1 *C.GtkTreeIter // out
var _arg2 C.gint // out
var _arg3 *C.GValue // out

_arg0 = (*C.GtkTreeStore)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))
_arg2 = (C.gint)(column)
_arg3 = (*C.GValue)(value.GValue)

C.gtk_tree_store_set_value(_arg0, _arg1, _arg2, _arg3)
}
	
	// SetValuesv: a variant of gtk_tree_store_set_valist() which takes the columns
// and values as two arrays, instead of varargs. This function is mainly
// intended for language bindings or in case the number of columns to change is
// not known until run-time.
	func (t TreeStore) SetValuesv(iter *TreeIter, columns []int, values []**externglib.Value)  {
var _arg0 *C.GtkTreeStore // out
var _arg1 *C.GtkTreeIter // out
var _arg2 *C.gint
var _arg4 C.gint
var _arg3 *C.GValue
var _arg4 C.gint

_arg0 = (*C.GtkTreeStore)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))
_arg4 = C.gint(len(columns))
_arg2 = (*C.gint)(unsafe.Pointer(&columns[0]))
_arg4 = C.gint(len(values))
_arg3 = (*C.GValue)(C.malloc(C.ulong(len(values)) * C.ulong(C.sizeof_GValue)))
defer C.free(unsafe.Pointer(_arg3))
{
out := unsafe.Slice(_arg3, len(values))
for i := range values {
out[i] = (*C.GValue)(values[i].GValue)
}
}

C.gtk_tree_store_set_valuesv(_arg0, _arg1, _arg2, _arg3, _arg4)
}
	
	// Swap swaps @a and @b in the same level of @tree_store. Note that this
// function only works with unsorted stores.
	func (t TreeStore) Swap(a *TreeIter, b *TreeIter)  {
var _arg0 *C.GtkTreeStore // out
var _arg1 *C.GtkTreeIter // out
var _arg2 *C.GtkTreeIter // out

_arg0 = (*C.GtkTreeStore)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(a.Native()))
_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(b.Native()))

C.gtk_tree_store_swap(_arg0, _arg1, _arg2)
}
	


	// TreeView: widget that displays any object that implements the TreeModel
// interface.
// 
// Please refer to the [tree widget conceptual overview][TreeWidget] for an
// overview of all the objects and data types related to the tree widget and how
// they work together.
// 
// Several different coordinate systems are exposed in the GtkTreeView API.
// These are:
// 
// ! (tree-view-coordinates.png)
// 
// Coordinate systems in GtkTreeView API:
// 
// - Widget coordinates: Coordinates relative to the widget (usually
// `widget->window`).
// 
// - Bin window coordinates: Coordinates relative to the window that GtkTreeView
// renders to.
// 
// - Tree coordinates: Coordinates relative to the entire scrollable area of
// GtkTreeView. These coordinates start at (0, 0) for row 0 of the tree.
// 
// Several functions are available for converting between the different
// coordinate systems. The most common translations are between widget and bin
// window coordinates and between bin window and tree coordinates. For the
// former you can use gtk_tree_view_convert_widget_to_bin_window_coords() (and
// vice versa), for the latter gtk_tree_view_convert_bin_window_to_tree_coords()
// (and vice versa).
// 
// 
// GtkTreeView as GtkBuildable
// 
// The GtkTreeView implementation of the GtkBuildable interface accepts
// TreeViewColumn objects as <child> elements and exposes the internal
// TreeSelection in UI definitions.
// 
// An example of a UI definition fragment with GtkTreeView:
// 
//    <object class="GtkTreeView" id="treeview">
//      <property name="model">liststore1</property>
//      <child>
//        <object class="GtkTreeViewColumn" id="test-column">
//          <property name="title">Test</property>
//          <child>
//            <object class="GtkCellRendererText" id="test-renderer"/>
//            <attributes>
//              <attribute name="text">1</attribute>
//            </attributes>
//          </child>
//        </object>
//      </child>
//      <child internal-child="selection">
//        <object class="GtkTreeSelection" id="selection">
//          <signal name="changed" handler="on_treeview_selection_changed"/>
//        </object>
//      </child>
//    </object>
// 
// CSS nodes
// 
//    treeview.view
//    ├── header
//    │   ├── <column header>
//    ┊   ┊
//    │   ╰── <column header>
//    │
//    ╰── [rubberband]
// 
// GtkTreeView has a main CSS node with name treeview and style class .view. It
// has a subnode with name header, which is the parent for all the column header
// widgets' CSS nodes. For rubberband selection, a subnode with name rubberband
// is used.
	type TreeView struct {
		Container
		Buildable
		Scrollable
		
	}

	// TreeViewClass is an interface that the TreeView class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type TreeViewClass interface {
		gextras.Objector
		_treeView()
	}

	func (TreeView) _treeView() {}

	
	func marshalTreeView(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapTreeView(obj), nil
	}
	

	
	// NewTreeView creates a new TreeView widget.
	func NewTreeView() TreeView {
var _cret *C.GtkWidget // in

_cret = C.gtk_tree_view_new()


var _treeView TreeView // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_treeView = TreeView{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Scrollable: Scrollable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _treeView
}
	
	// NewTreeViewWithModel creates a new TreeView widget with the model initialized
// to @model.
	func NewTreeViewWithModel(model TreeModel) TreeView {
var _arg1 *C.GtkTreeModel // out
var _cret *C.GtkWidget // in

_arg1 = (*C.GtkTreeModel)(unsafe.Pointer(model.Native()))

_cret = C.gtk_tree_view_new_with_model(_arg1)


var _treeView TreeView // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_treeView = TreeView{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Scrollable: Scrollable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _treeView
}
	

	
	// AppendColumn appends @column to the list of columns. If @tree_view has
// “fixed_height” mode enabled, then @column must have its “sizing” property set
// to be GTK_TREE_VIEW_COLUMN_FIXED.
	func (t TreeView) AppendColumn(column TreeViewColumnClass) int {
var _arg0 *C.GtkTreeView // out
var _arg1 *C.GtkTreeViewColumn // out
var _cret C.gint // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreeViewColumn)(unsafe.Pointer(column.Native()))

_cret = C.gtk_tree_view_append_column(_arg0, _arg1)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// CollapseAll: recursively collapses all visible, expanded nodes in @tree_view.
	func (t TreeView) CollapseAll()  {
var _arg0 *C.GtkTreeView // out

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

C.gtk_tree_view_collapse_all(_arg0)
}
	
	// CollapseRow collapses a row (hides its child rows, if they exist).
	func (t TreeView) CollapseRow(path *TreePath) bool {
var _arg0 *C.GtkTreeView // out
var _arg1 *C.GtkTreePath // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

_cret = C.gtk_tree_view_collapse_row(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ColumnsAutosize resizes all columns to their optimal width. Only works after
// the treeview has been realized.
	func (t TreeView) ColumnsAutosize()  {
var _arg0 *C.GtkTreeView // out

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

C.gtk_tree_view_columns_autosize(_arg0)
}
	
	// ConvertBinWindowToTreeCoords converts bin_window coordinates to coordinates
// for the tree (the full scrollable area of the tree).
	func (t TreeView) ConvertBinWindowToTreeCoords(bx int, by int) (tx int, ty int) {
var _arg0 *C.GtkTreeView // out
var _arg1 C.gint // out
var _arg2 C.gint // out
var _arg3 C.gint // in
var _arg4 C.gint // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
_arg1 = (C.gint)(bx)
_arg2 = (C.gint)(by)

C.gtk_tree_view_convert_bin_window_to_tree_coords(_arg0, _arg1, _arg2, &_arg3, &_arg4)

var _tx int // out
var _ty int // out

_tx = (int)(_arg3)
_ty = (int)(_arg4)

return _tx, _ty
}
	
	// ConvertBinWindowToWidgetCoords converts bin_window coordinates (see
// gtk_tree_view_get_bin_window()) to widget relative coordinates.
	func (t TreeView) ConvertBinWindowToWidgetCoords(bx int, by int) (wx int, wy int) {
var _arg0 *C.GtkTreeView // out
var _arg1 C.gint // out
var _arg2 C.gint // out
var _arg3 C.gint // in
var _arg4 C.gint // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
_arg1 = (C.gint)(bx)
_arg2 = (C.gint)(by)

C.gtk_tree_view_convert_bin_window_to_widget_coords(_arg0, _arg1, _arg2, &_arg3, &_arg4)

var _wx int // out
var _wy int // out

_wx = (int)(_arg3)
_wy = (int)(_arg4)

return _wx, _wy
}
	
	// ConvertTreeToBinWindowCoords converts tree coordinates (coordinates in full
// scrollable area of the tree) to bin_window coordinates.
	func (t TreeView) ConvertTreeToBinWindowCoords(tx int, ty int) (bx int, by int) {
var _arg0 *C.GtkTreeView // out
var _arg1 C.gint // out
var _arg2 C.gint // out
var _arg3 C.gint // in
var _arg4 C.gint // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
_arg1 = (C.gint)(tx)
_arg2 = (C.gint)(ty)

C.gtk_tree_view_convert_tree_to_bin_window_coords(_arg0, _arg1, _arg2, &_arg3, &_arg4)

var _bx int // out
var _by int // out

_bx = (int)(_arg3)
_by = (int)(_arg4)

return _bx, _by
}
	
	// ConvertTreeToWidgetCoords converts tree coordinates (coordinates in full
// scrollable area of the tree) to widget coordinates.
	func (t TreeView) ConvertTreeToWidgetCoords(tx int, ty int) (wx int, wy int) {
var _arg0 *C.GtkTreeView // out
var _arg1 C.gint // out
var _arg2 C.gint // out
var _arg3 C.gint // in
var _arg4 C.gint // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
_arg1 = (C.gint)(tx)
_arg2 = (C.gint)(ty)

C.gtk_tree_view_convert_tree_to_widget_coords(_arg0, _arg1, _arg2, &_arg3, &_arg4)

var _wx int // out
var _wy int // out

_wx = (int)(_arg3)
_wy = (int)(_arg4)

return _wx, _wy
}
	
	// ConvertWidgetToBinWindowCoords converts widget coordinates to coordinates for
// the bin_window (see gtk_tree_view_get_bin_window()).
	func (t TreeView) ConvertWidgetToBinWindowCoords(wx int, wy int) (bx int, by int) {
var _arg0 *C.GtkTreeView // out
var _arg1 C.gint // out
var _arg2 C.gint // out
var _arg3 C.gint // in
var _arg4 C.gint // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
_arg1 = (C.gint)(wx)
_arg2 = (C.gint)(wy)

C.gtk_tree_view_convert_widget_to_bin_window_coords(_arg0, _arg1, _arg2, &_arg3, &_arg4)

var _bx int // out
var _by int // out

_bx = (int)(_arg3)
_by = (int)(_arg4)

return _bx, _by
}
	
	// ConvertWidgetToTreeCoords converts widget coordinates to coordinates for the
// tree (the full scrollable area of the tree).
	func (t TreeView) ConvertWidgetToTreeCoords(wx int, wy int) (tx int, ty int) {
var _arg0 *C.GtkTreeView // out
var _arg1 C.gint // out
var _arg2 C.gint // out
var _arg3 C.gint // in
var _arg4 C.gint // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
_arg1 = (C.gint)(wx)
_arg2 = (C.gint)(wy)

C.gtk_tree_view_convert_widget_to_tree_coords(_arg0, _arg1, _arg2, &_arg3, &_arg4)

var _tx int // out
var _ty int // out

_tx = (int)(_arg3)
_ty = (int)(_arg4)

return _tx, _ty
}
	
	// CreateRowDragIcon creates a #cairo_surface_t representation of the row at
// @path. This image is used for a drag icon.
	func (t TreeView) CreateRowDragIcon(path *TreePath) *cairo.Surface {
var _arg0 *C.GtkTreeView // out
var _arg1 *C.GtkTreePath // out
var _cret *C.cairo_surface_t // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

_cret = C.gtk_tree_view_create_row_drag_icon(_arg0, _arg1)


var _surface *cairo.Surface // out

_surface = *(**cairo.Surface)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_surface, func(v *cairo.Surface) {
  C.free(unsafe.Pointer(v.Native()))
})

return _surface
}
	
	// EnableModelDragDest turns @tree_view into a drop destination for automatic
// DND. Calling this method sets TreeView:reorderable to false.
	func (t TreeView) EnableModelDragDest(targets []TargetEntry, actions gdk.DragAction)  {
var _arg0 *C.GtkTreeView // out
var _arg1 *C.GtkTargetEntry
var _arg2 C.gint
var _arg3 C.GdkDragAction // out

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
_arg2 = C.gint(len(targets))
_arg1 = (*C.GtkTargetEntry)(unsafe.Pointer(&targets[0]))
_arg3 = (C.GdkDragAction)(actions)

C.gtk_tree_view_enable_model_drag_dest(_arg0, _arg1, _arg2, _arg3)
}
	
	// EnableModelDragSource turns @tree_view into a drag source for automatic DND.
// Calling this method sets TreeView:reorderable to false.
	func (t TreeView) EnableModelDragSource(startButtonMask gdk.ModifierType, targets []TargetEntry, actions gdk.DragAction)  {
var _arg0 *C.GtkTreeView // out
var _arg1 C.GdkModifierType // out
var _arg2 *C.GtkTargetEntry
var _arg3 C.gint
var _arg4 C.GdkDragAction // out

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
_arg1 = (C.GdkModifierType)(startButtonMask)
_arg3 = C.gint(len(targets))
_arg2 = (*C.GtkTargetEntry)(unsafe.Pointer(&targets[0]))
_arg4 = (C.GdkDragAction)(actions)

C.gtk_tree_view_enable_model_drag_source(_arg0, _arg1, _arg2, _arg3, _arg4)
}
	
	// ExpandAll: recursively expands all nodes in the @tree_view.
	func (t TreeView) ExpandAll()  {
var _arg0 *C.GtkTreeView // out

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

C.gtk_tree_view_expand_all(_arg0)
}
	
	// ExpandRow opens the row so its children are visible.
	func (t TreeView) ExpandRow(path *TreePath, openAll bool) bool {
var _arg0 *C.GtkTreeView // out
var _arg1 *C.GtkTreePath // out
var _arg2 C.gboolean // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
if openAll { _arg2 = C.TRUE }

_cret = C.gtk_tree_view_expand_row(_arg0, _arg1, _arg2)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ExpandToPath expands the row at @path. This will also expand all parent rows
// of @path as necessary.
	func (t TreeView) ExpandToPath(path *TreePath)  {
var _arg0 *C.GtkTreeView // out
var _arg1 *C.GtkTreePath // out

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

C.gtk_tree_view_expand_to_path(_arg0, _arg1)
}
	
	// ActivateOnSingleClick gets the setting set by
// gtk_tree_view_set_activate_on_single_click().
	func (t TreeView) ActivateOnSingleClick() bool {
var _arg0 *C.GtkTreeView // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_get_activate_on_single_click(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// BackgroundArea fills the bounding rectangle in bin_window coordinates for the
// cell at the row specified by @path and the column specified by @column. If
// @path is nil, or points to a node not found in the tree, the @y and @height
// fields of the rectangle will be filled with 0. If @column is nil, the @x and
// @width fields will be filled with 0. The returned rectangle is equivalent to
// the @background_area passed to gtk_cell_renderer_render(). These background
// areas tile to cover the entire bin window. Contrast with the @cell_area,
// returned by gtk_tree_view_get_cell_area(), which returns only the cell
// itself, excluding surrounding borders and the tree expander area.
	func (t TreeView) BackgroundArea(path *TreePath, column TreeViewColumnClass) gdk.Rectangle {
var _arg0 *C.GtkTreeView // out
var _arg1 *C.GtkTreePath // out
var _arg2 *C.GtkTreeViewColumn // out
var _rect gdk.Rectangle

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
_arg2 = (*C.GtkTreeViewColumn)(unsafe.Pointer(column.Native()))

C.gtk_tree_view_get_background_area(_arg0, _arg1, _arg2, (*C.GdkRectangle)(unsafe.Pointer(&_rect)))





return _rect
}
	
	// BinWindow returns the window that @tree_view renders to. This is used
// primarily to compare to `event->window` to confirm that the event on
// @tree_view is on the right window.
	func (t TreeView) BinWindow() gdk.Window {
var _arg0 *C.GtkTreeView // out
var _cret *C.GdkWindow // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_get_bin_window(_arg0)


var _window gdk.Window // out

_window = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Window)

return _window
}
	
	// CellArea fills the bounding rectangle in bin_window coordinates for the cell
// at the row specified by @path and the column specified by @column. If @path
// is nil, or points to a path not currently displayed, the @y and @height
// fields of the rectangle will be filled with 0. If @column is nil, the @x and
// @width fields will be filled with 0. The sum of all cell rects does not cover
// the entire tree; there are extra pixels in between rows, for example. The
// returned rectangle is equivalent to the @cell_area passed to
// gtk_cell_renderer_render(). This function is only valid if @tree_view is
// realized.
	func (t TreeView) CellArea(path *TreePath, column TreeViewColumnClass) gdk.Rectangle {
var _arg0 *C.GtkTreeView // out
var _arg1 *C.GtkTreePath // out
var _arg2 *C.GtkTreeViewColumn // out
var _rect gdk.Rectangle

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
_arg2 = (*C.GtkTreeViewColumn)(unsafe.Pointer(column.Native()))

C.gtk_tree_view_get_cell_area(_arg0, _arg1, _arg2, (*C.GdkRectangle)(unsafe.Pointer(&_rect)))





return _rect
}
	
	// Column gets the TreeViewColumn at the given position in the #tree_view.
	func (t TreeView) Column(n int) TreeViewColumn {
var _arg0 *C.GtkTreeView // out
var _arg1 C.gint // out
var _cret *C.GtkTreeViewColumn // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
_arg1 = (C.gint)(n)

_cret = C.gtk_tree_view_get_column(_arg0, _arg1)


var _treeViewColumn TreeViewColumn // out

_treeViewColumn = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TreeViewColumn)

return _treeViewColumn
}
	
	// Cursor fills in @path and @focus_column with the current path and focus
// column. If the cursor isn’t currently set, then *@path will be nil. If no
// column currently has focus, then *@focus_column will be nil.
// 
// The returned TreePath must be freed with gtk_tree_path_free() when you are
// done with it.
	func (t TreeView) Cursor() (*TreePath, TreeViewColumn) {
var _arg0 *C.GtkTreeView // out
var _path *TreePath
var _arg2 *C.GtkTreeViewColumn // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

C.gtk_tree_view_get_cursor(_arg0, (**C.GtkTreePath)(unsafe.Pointer(&_path)), &_arg2)


var _focusColumn TreeViewColumn // out


_focusColumn = gextras.CastObject(externglib.Take(unsafe.Pointer(_arg2))).(TreeViewColumn)

return _path, _focusColumn
}
	
	// DestRowAtPos determines the destination row for a given position. @drag_x and
// @drag_y are expected to be in widget coordinates. This function is only
// meaningful if @tree_view is realized. Therefore this function will always
// return false if @tree_view is not realized or does not have a model.
	func (t TreeView) DestRowAtPos(dragX int, dragY int) (*TreePath, TreeViewDropPosition, bool) {
var _arg0 *C.GtkTreeView // out
var _arg1 C.gint // out
var _arg2 C.gint // out
var _path *TreePath
var _arg4 C.GtkTreeViewDropPosition // in
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
_arg1 = (C.gint)(dragX)
_arg2 = (C.gint)(dragY)

_cret = C.gtk_tree_view_get_dest_row_at_pos(_arg0, _arg1, _arg2, (**C.GtkTreePath)(unsafe.Pointer(&_path)), &_arg4)



var _pos TreeViewDropPosition // out
var _ok bool // out


_pos = TreeViewDropPosition(_arg4)
if _cret != 0 { _ok = true }

return _path, _pos, _ok
}
	
	// DragDestRow gets information about the row that is highlighted for feedback.
	func (t TreeView) DragDestRow() (*TreePath, TreeViewDropPosition) {
var _arg0 *C.GtkTreeView // out
var _path *TreePath
var _arg2 C.GtkTreeViewDropPosition // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

C.gtk_tree_view_get_drag_dest_row(_arg0, (**C.GtkTreePath)(unsafe.Pointer(&_path)), &_arg2)


var _pos TreeViewDropPosition // out


_pos = TreeViewDropPosition(_arg2)

return _path, _pos
}
	
	// EnableSearch returns whether or not the tree allows to start interactive
// searching by typing in text.
	func (t TreeView) EnableSearch() bool {
var _arg0 *C.GtkTreeView // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_get_enable_search(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// EnableTreeLines returns whether or not tree lines are drawn in @tree_view.
	func (t TreeView) EnableTreeLines() bool {
var _arg0 *C.GtkTreeView // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_get_enable_tree_lines(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ExpanderColumn returns the column that is the current expander column. This
// column has the expander arrow drawn next to it.
	func (t TreeView) ExpanderColumn() TreeViewColumn {
var _arg0 *C.GtkTreeView // out
var _cret *C.GtkTreeViewColumn // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_get_expander_column(_arg0)


var _treeViewColumn TreeViewColumn // out

_treeViewColumn = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TreeViewColumn)

return _treeViewColumn
}
	
	// FixedHeightMode returns whether fixed height mode is turned on for
// @tree_view.
	func (t TreeView) FixedHeightMode() bool {
var _arg0 *C.GtkTreeView // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_get_fixed_height_mode(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// GridLines returns which grid lines are enabled in @tree_view.
	func (t TreeView) GridLines() TreeViewGridLines {
var _arg0 *C.GtkTreeView // out
var _cret C.GtkTreeViewGridLines // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_get_grid_lines(_arg0)


var _treeViewGridLines TreeViewGridLines // out

_treeViewGridLines = TreeViewGridLines(_cret)

return _treeViewGridLines
}
	
	// HAdjustment gets the Adjustment currently being used for the horizontal
// aspect.
	func (t TreeView) HAdjustment() Adjustment {
var _arg0 *C.GtkTreeView // out
var _cret *C.GtkAdjustment // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_get_hadjustment(_arg0)


var _adjustment Adjustment // out

_adjustment = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Adjustment)

return _adjustment
}
	
	// HeadersClickable returns whether all header columns are clickable.
	func (t TreeView) HeadersClickable() bool {
var _arg0 *C.GtkTreeView // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_get_headers_clickable(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// HeadersVisible returns true if the headers on the @tree_view are visible.
	func (t TreeView) HeadersVisible() bool {
var _arg0 *C.GtkTreeView // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_get_headers_visible(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// HoverExpand returns whether hover expansion mode is turned on for @tree_view.
	func (t TreeView) HoverExpand() bool {
var _arg0 *C.GtkTreeView // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_get_hover_expand(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// HoverSelection returns whether hover selection mode is turned on for
// @tree_view.
	func (t TreeView) HoverSelection() bool {
var _arg0 *C.GtkTreeView // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_get_hover_selection(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// LevelIndentation returns the amount, in pixels, of extra indentation for
// child levels in @tree_view.
	func (t TreeView) LevelIndentation() int {
var _arg0 *C.GtkTreeView // out
var _cret C.gint // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_get_level_indentation(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Model returns the model the TreeView is based on. Returns nil if the model is
// unset.
	func (t TreeView) Model() TreeModel {
var _arg0 *C.GtkTreeView // out
var _cret *C.GtkTreeModel // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_get_model(_arg0)


var _treeModel TreeModel // out

_treeModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TreeModel)

return _treeModel
}
	
	// NColumns queries the number of columns in the given @tree_view.
	func (t TreeView) NColumns() uint {
var _arg0 *C.GtkTreeView // out
var _cret C.guint // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_get_n_columns(_arg0)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// PathAtPos finds the path at the point (@x, @y), relative to bin_window
// coordinates (please see gtk_tree_view_get_bin_window()). That is, @x and @y
// are relative to an events coordinates. @x and @y must come from an event on
// the @tree_view only where `event->window == gtk_tree_view_get_bin_window ()`.
// It is primarily for things like popup menus. If @path is non-nil, then it
// will be filled with the TreePath at that point. This path should be freed
// with gtk_tree_path_free(). If @column is non-nil, then it will be filled with
// the column at that point. @cell_x and @cell_y return the coordinates relative
// to the cell background (i.e. the @background_area passed to
// gtk_cell_renderer_render()). This function is only meaningful if @tree_view
// is realized. Therefore this function will always return false if @tree_view
// is not realized or does not have a model.
// 
// For converting widget coordinates (eg. the ones you get from
// GtkWidget::query-tooltip), please see
// gtk_tree_view_convert_widget_to_bin_window_coords().
	func (t TreeView) PathAtPos(x int, y int) (path *TreePath, column TreeViewColumn, cellX int, cellY int, ok bool) {
var _arg0 *C.GtkTreeView // out
var _arg1 C.gint // out
var _arg2 C.gint // out
var _path *TreePath
var _arg4 *C.GtkTreeViewColumn // in
var _arg5 C.gint // in
var _arg6 C.gint // in
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
_arg1 = (C.gint)(x)
_arg2 = (C.gint)(y)

_cret = C.gtk_tree_view_get_path_at_pos(_arg0, _arg1, _arg2, (**C.GtkTreePath)(unsafe.Pointer(&_path)), &_arg4, &_arg5, &_arg6)



var _column TreeViewColumn // out
var _cellX int // out
var _cellY int // out
var _ok bool // out


_column = gextras.CastObject(externglib.Take(unsafe.Pointer(_arg4))).(TreeViewColumn)
_cellX = (int)(_arg5)
_cellY = (int)(_arg6)
if _cret != 0 { _ok = true }

return _path, _column, _cellX, _cellY, _ok
}
	
	// Reorderable retrieves whether the user can reorder the tree via
// drag-and-drop. See gtk_tree_view_set_reorderable().
	func (t TreeView) Reorderable() bool {
var _arg0 *C.GtkTreeView // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_get_reorderable(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// RubberBanding returns whether rubber banding is turned on for @tree_view. If
// the selection mode is K_SELECTION_MULTIPLE, rubber banding will allow the
// user to select multiple rows by dragging the mouse.
	func (t TreeView) RubberBanding() bool {
var _arg0 *C.GtkTreeView // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_get_rubber_banding(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// RulesHint gets the setting set by gtk_tree_view_set_rules_hint().
	func (t TreeView) RulesHint() bool {
var _arg0 *C.GtkTreeView // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_get_rules_hint(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SearchColumn gets the column searched on by the interactive search code.
	func (t TreeView) SearchColumn() int {
var _arg0 *C.GtkTreeView // out
var _cret C.gint // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_get_search_column(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// SearchEntry returns the Entry which is currently in use as interactive search
// entry for @tree_view. In case the built-in entry is being used, nil will be
// returned.
	func (t TreeView) SearchEntry() Entry {
var _arg0 *C.GtkTreeView // out
var _cret *C.GtkEntry // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_get_search_entry(_arg0)


var _entry Entry // out

_entry = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Entry)

return _entry
}
	
	// Selection gets the TreeSelection associated with @tree_view.
	func (t TreeView) Selection() TreeSelection {
var _arg0 *C.GtkTreeView // out
var _cret *C.GtkTreeSelection // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_get_selection(_arg0)


var _treeSelection TreeSelection // out

_treeSelection = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TreeSelection)

return _treeSelection
}
	
	// ShowExpanders returns whether or not expanders are drawn in @tree_view.
	func (t TreeView) ShowExpanders() bool {
var _arg0 *C.GtkTreeView // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_get_show_expanders(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// TooltipColumn returns the column of @tree_view’s model which is being used
// for displaying tooltips on @tree_view’s rows.
	func (t TreeView) TooltipColumn() int {
var _arg0 *C.GtkTreeView // out
var _cret C.gint // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_get_tooltip_column(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// VAdjustment gets the Adjustment currently being used for the vertical aspect.
	func (t TreeView) VAdjustment() Adjustment {
var _arg0 *C.GtkTreeView // out
var _cret *C.GtkAdjustment // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_get_vadjustment(_arg0)


var _adjustment Adjustment // out

_adjustment = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Adjustment)

return _adjustment
}
	
	// VisibleRange sets @start_path and @end_path to be the first and last visible
// path. Note that there may be invisible paths in between.
// 
// The paths should be freed with gtk_tree_path_free() after use.
	func (t TreeView) VisibleRange() (startPath *TreePath, endPath *TreePath, ok bool) {
var _arg0 *C.GtkTreeView // out
var _startPath *TreePath
var _endPath *TreePath
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_get_visible_range(_arg0, (**C.GtkTreePath)(unsafe.Pointer(&_startPath)), (**C.GtkTreePath)(unsafe.Pointer(&_endPath)))




var _ok bool // out



if _cret != 0 { _ok = true }

return _startPath, _endPath, _ok
}
	
	// VisibleRect fills @visible_rect with the currently-visible region of the
// buffer, in tree coordinates. Convert to bin_window coordinates with
// gtk_tree_view_convert_tree_to_bin_window_coords(). Tree coordinates start at
// 0,0 for row 0 of the tree, and cover the entire scrollable area of the tree.
	func (t TreeView) VisibleRect() gdk.Rectangle {
var _arg0 *C.GtkTreeView // out
var _visibleRect gdk.Rectangle

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

C.gtk_tree_view_get_visible_rect(_arg0, (*C.GdkRectangle)(unsafe.Pointer(&_visibleRect)))





return _visibleRect
}
	
	// InsertColumn: this inserts the @column into the @tree_view at @position. If
// @position is -1, then the column is inserted at the end. If @tree_view has
// “fixed_height” mode enabled, then @column must have its “sizing” property set
// to be GTK_TREE_VIEW_COLUMN_FIXED.
	func (t TreeView) InsertColumn(column TreeViewColumnClass, position int) int {
var _arg0 *C.GtkTreeView // out
var _arg1 *C.GtkTreeViewColumn // out
var _arg2 C.gint // out
var _cret C.gint // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreeViewColumn)(unsafe.Pointer(column.Native()))
_arg2 = (C.gint)(position)

_cret = C.gtk_tree_view_insert_column(_arg0, _arg1, _arg2)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// IsBlankAtPos: determine whether the point (@x, @y) in @tree_view is blank,
// that is no cell content nor an expander arrow is drawn at the location. If
// so, the location can be considered as the background. You might wish to take
// special action on clicks on the background, such as clearing a current
// selection, having a custom context menu or starting rubber banding.
// 
// The @x and @y coordinate that are provided must be relative to bin_window
// coordinates. That is, @x and @y must come from an event on @tree_view where
// `event->window == gtk_tree_view_get_bin_window ()`.
// 
// For converting widget coordinates (eg. the ones you get from
// GtkWidget::query-tooltip), please see
// gtk_tree_view_convert_widget_to_bin_window_coords().
// 
// The @path, @column, @cell_x and @cell_y arguments will be filled in likewise
// as for gtk_tree_view_get_path_at_pos(). Please see
// gtk_tree_view_get_path_at_pos() for more information.
	func (t TreeView) IsBlankAtPos(x int, y int) (path *TreePath, column TreeViewColumn, cellX int, cellY int, ok bool) {
var _arg0 *C.GtkTreeView // out
var _arg1 C.gint // out
var _arg2 C.gint // out
var _path *TreePath
var _arg4 *C.GtkTreeViewColumn // in
var _arg5 C.gint // in
var _arg6 C.gint // in
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
_arg1 = (C.gint)(x)
_arg2 = (C.gint)(y)

_cret = C.gtk_tree_view_is_blank_at_pos(_arg0, _arg1, _arg2, (**C.GtkTreePath)(unsafe.Pointer(&_path)), &_arg4, &_arg5, &_arg6)



var _column TreeViewColumn // out
var _cellX int // out
var _cellY int // out
var _ok bool // out


_column = gextras.CastObject(externglib.Take(unsafe.Pointer(_arg4))).(TreeViewColumn)
_cellX = (int)(_arg5)
_cellY = (int)(_arg6)
if _cret != 0 { _ok = true }

return _path, _column, _cellX, _cellY, _ok
}
	
	// IsRubberBandingActive returns whether a rubber banding operation is currently
// being done in @tree_view.
	func (t TreeView) IsRubberBandingActive() bool {
var _arg0 *C.GtkTreeView // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_is_rubber_banding_active(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// MoveColumnAfter moves @column to be after to @base_column. If @base_column is
// nil, then @column is placed in the first position.
	func (t TreeView) MoveColumnAfter(column TreeViewColumnClass, baseColumn TreeViewColumnClass)  {
var _arg0 *C.GtkTreeView // out
var _arg1 *C.GtkTreeViewColumn // out
var _arg2 *C.GtkTreeViewColumn // out

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreeViewColumn)(unsafe.Pointer(column.Native()))
_arg2 = (*C.GtkTreeViewColumn)(unsafe.Pointer(baseColumn.Native()))

C.gtk_tree_view_move_column_after(_arg0, _arg1, _arg2)
}
	
	// RemoveColumn removes @column from @tree_view.
	func (t TreeView) RemoveColumn(column TreeViewColumnClass) int {
var _arg0 *C.GtkTreeView // out
var _arg1 *C.GtkTreeViewColumn // out
var _cret C.gint // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreeViewColumn)(unsafe.Pointer(column.Native()))

_cret = C.gtk_tree_view_remove_column(_arg0, _arg1)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// RowActivated activates the cell determined by @path and @column.
	func (t TreeView) RowActivated(path *TreePath, column TreeViewColumnClass)  {
var _arg0 *C.GtkTreeView // out
var _arg1 *C.GtkTreePath // out
var _arg2 *C.GtkTreeViewColumn // out

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
_arg2 = (*C.GtkTreeViewColumn)(unsafe.Pointer(column.Native()))

C.gtk_tree_view_row_activated(_arg0, _arg1, _arg2)
}
	
	// RowExpanded returns true if the node pointed to by @path is expanded in
// @tree_view.
	func (t TreeView) RowExpanded(path *TreePath) bool {
var _arg0 *C.GtkTreeView // out
var _arg1 *C.GtkTreePath // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

_cret = C.gtk_tree_view_row_expanded(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ScrollToCell moves the alignments of @tree_view to the position specified by
// @column and @path. If @column is nil, then no horizontal scrolling occurs.
// Likewise, if @path is nil no vertical scrolling occurs. At a minimum, one of
// @column or @path need to be non-nil. @row_align determines where the row is
// placed, and @col_align determines where @column is placed. Both are expected
// to be between 0.0 and 1.0. 0.0 means left/top alignment, 1.0 means
// right/bottom alignment, 0.5 means center.
// 
// If @use_align is false, then the alignment arguments are ignored, and the
// tree does the minimum amount of work to scroll the cell onto the screen. This
// means that the cell will be scrolled to the edge closest to its current
// position. If the cell is currently visible on the screen, nothing is done.
// 
// This function only works if the model is set, and @path is a valid row on the
// model. If the model changes before the @tree_view is realized, the centered
// path will be modified to reflect this change.
	func (t TreeView) ScrollToCell(path *TreePath, column TreeViewColumnClass, useAlign bool, rowAlign float32, colAlign float32)  {
var _arg0 *C.GtkTreeView // out
var _arg1 *C.GtkTreePath // out
var _arg2 *C.GtkTreeViewColumn // out
var _arg3 C.gboolean // out
var _arg4 C.gfloat // out
var _arg5 C.gfloat // out

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
_arg2 = (*C.GtkTreeViewColumn)(unsafe.Pointer(column.Native()))
if useAlign { _arg3 = C.TRUE }
_arg4 = (C.gfloat)(rowAlign)
_arg5 = (C.gfloat)(colAlign)

C.gtk_tree_view_scroll_to_cell(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
}
	
	// ScrollToPoint scrolls the tree view such that the top-left corner of the
// visible area is @tree_x, @tree_y, where @tree_x and @tree_y are specified in
// tree coordinates. The @tree_view must be realized before this function is
// called. If it isn't, you probably want to be using
// gtk_tree_view_scroll_to_cell().
// 
// If either @tree_x or @tree_y are -1, then that direction isn’t scrolled.
	func (t TreeView) ScrollToPoint(treeX int, treeY int)  {
var _arg0 *C.GtkTreeView // out
var _arg1 C.gint // out
var _arg2 C.gint // out

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
_arg1 = (C.gint)(treeX)
_arg2 = (C.gint)(treeY)

C.gtk_tree_view_scroll_to_point(_arg0, _arg1, _arg2)
}
	
	// SetActivateOnSingleClick: cause the TreeView::row-activated signal to be
// emitted on a single click instead of a double click.
	func (t TreeView) SetActivateOnSingleClick(single bool)  {
var _arg0 *C.GtkTreeView // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
if single { _arg1 = C.TRUE }

C.gtk_tree_view_set_activate_on_single_click(_arg0, _arg1)
}
	
	// SetCursor sets the current keyboard focus to be at @path, and selects it.
// This is useful when you want to focus the user’s attention on a particular
// row. If @focus_column is not nil, then focus is given to the column specified
// by it. Additionally, if @focus_column is specified, and @start_editing is
// true, then editing should be started in the specified cell. This function is
// often followed by @gtk_widget_grab_focus (@tree_view) in order to give
// keyboard focus to the widget. Please note that editing can only happen when
// the widget is realized.
// 
// If @path is invalid for @model, the current cursor (if any) will be unset and
// the function will return without failing.
	func (t TreeView) SetCursor(path *TreePath, focusColumn TreeViewColumnClass, startEditing bool)  {
var _arg0 *C.GtkTreeView // out
var _arg1 *C.GtkTreePath // out
var _arg2 *C.GtkTreeViewColumn // out
var _arg3 C.gboolean // out

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
_arg2 = (*C.GtkTreeViewColumn)(unsafe.Pointer(focusColumn.Native()))
if startEditing { _arg3 = C.TRUE }

C.gtk_tree_view_set_cursor(_arg0, _arg1, _arg2, _arg3)
}
	
	// SetCursorOnCell sets the current keyboard focus to be at @path, and selects
// it. This is useful when you want to focus the user’s attention on a
// particular row. If @focus_column is not nil, then focus is given to the
// column specified by it. If @focus_column and @focus_cell are not nil, and
// @focus_column contains 2 or more editable or activatable cells, then focus is
// given to the cell specified by @focus_cell. Additionally, if @focus_column is
// specified, and @start_editing is true, then editing should be started in the
// specified cell. This function is often followed by @gtk_widget_grab_focus
// (@tree_view) in order to give keyboard focus to the widget. Please note that
// editing can only happen when the widget is realized.
// 
// If @path is invalid for @model, the current cursor (if any) will be unset and
// the function will return without failing.
	func (t TreeView) SetCursorOnCell(path *TreePath, focusColumn TreeViewColumnClass, focusCell CellRendererClass, startEditing bool)  {
var _arg0 *C.GtkTreeView // out
var _arg1 *C.GtkTreePath // out
var _arg2 *C.GtkTreeViewColumn // out
var _arg3 *C.GtkCellRenderer // out
var _arg4 C.gboolean // out

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
_arg2 = (*C.GtkTreeViewColumn)(unsafe.Pointer(focusColumn.Native()))
_arg3 = (*C.GtkCellRenderer)(unsafe.Pointer(focusCell.Native()))
if startEditing { _arg4 = C.TRUE }

C.gtk_tree_view_set_cursor_on_cell(_arg0, _arg1, _arg2, _arg3, _arg4)
}
	
	// SetDragDestRow sets the row that is highlighted for feedback. If @path is
// nil, an existing highlight is removed.
	func (t TreeView) SetDragDestRow(path *TreePath, pos TreeViewDropPosition)  {
var _arg0 *C.GtkTreeView // out
var _arg1 *C.GtkTreePath // out
var _arg2 C.GtkTreeViewDropPosition // out

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
_arg2 = (C.GtkTreeViewDropPosition)(pos)

C.gtk_tree_view_set_drag_dest_row(_arg0, _arg1, _arg2)
}
	
	// SetEnableSearch: if @enable_search is set, then the user can type in text to
// search through the tree interactively (this is sometimes called "typeahead
// find").
// 
// Note that even if this is false, the user can still initiate a search using
// the “start-interactive-search” key binding.
	func (t TreeView) SetEnableSearch(enableSearch bool)  {
var _arg0 *C.GtkTreeView // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
if enableSearch { _arg1 = C.TRUE }

C.gtk_tree_view_set_enable_search(_arg0, _arg1)
}
	
	// SetEnableTreeLines sets whether to draw lines interconnecting the expanders
// in @tree_view. This does not have any visible effects for lists.
	func (t TreeView) SetEnableTreeLines(enabled bool)  {
var _arg0 *C.GtkTreeView // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
if enabled { _arg1 = C.TRUE }

C.gtk_tree_view_set_enable_tree_lines(_arg0, _arg1)
}
	
	// SetExpanderColumn sets the column to draw the expander arrow at. It must be
// in @tree_view. If @column is nil, then the expander arrow is always at the
// first visible column.
// 
// If you do not want expander arrow to appear in your tree, set the expander
// column to a hidden column.
	func (t TreeView) SetExpanderColumn(column TreeViewColumnClass)  {
var _arg0 *C.GtkTreeView // out
var _arg1 *C.GtkTreeViewColumn // out

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreeViewColumn)(unsafe.Pointer(column.Native()))

C.gtk_tree_view_set_expander_column(_arg0, _arg1)
}
	
	// SetFixedHeightMode enables or disables the fixed height mode of @tree_view.
// Fixed height mode speeds up TreeView by assuming that all rows have the same
// height. Only enable this option if all rows are the same height and all
// columns are of type GTK_TREE_VIEW_COLUMN_FIXED.
	func (t TreeView) SetFixedHeightMode(enable bool)  {
var _arg0 *C.GtkTreeView // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
if enable { _arg1 = C.TRUE }

C.gtk_tree_view_set_fixed_height_mode(_arg0, _arg1)
}
	
	// SetGridLines sets which grid lines to draw in @tree_view.
	func (t TreeView) SetGridLines(gridLines TreeViewGridLines)  {
var _arg0 *C.GtkTreeView // out
var _arg1 C.GtkTreeViewGridLines // out

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
_arg1 = (C.GtkTreeViewGridLines)(gridLines)

C.gtk_tree_view_set_grid_lines(_arg0, _arg1)
}
	
	// SetHAdjustment sets the Adjustment for the current horizontal aspect.
	func (t TreeView) SetHAdjustment(adjustment AdjustmentClass)  {
var _arg0 *C.GtkTreeView // out
var _arg1 *C.GtkAdjustment // out

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(adjustment.Native()))

C.gtk_tree_view_set_hadjustment(_arg0, _arg1)
}
	
	// SetHeadersClickable: allow the column title buttons to be clicked.
	func (t TreeView) SetHeadersClickable(setting bool)  {
var _arg0 *C.GtkTreeView // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
if setting { _arg1 = C.TRUE }

C.gtk_tree_view_set_headers_clickable(_arg0, _arg1)
}
	
	// SetHeadersVisible sets the visibility state of the headers.
	func (t TreeView) SetHeadersVisible(headersVisible bool)  {
var _arg0 *C.GtkTreeView // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
if headersVisible { _arg1 = C.TRUE }

C.gtk_tree_view_set_headers_visible(_arg0, _arg1)
}
	
	// SetHoverExpand enables or disables the hover expansion mode of @tree_view.
// Hover expansion makes rows expand or collapse if the pointer moves over them.
	func (t TreeView) SetHoverExpand(expand bool)  {
var _arg0 *C.GtkTreeView // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
if expand { _arg1 = C.TRUE }

C.gtk_tree_view_set_hover_expand(_arg0, _arg1)
}
	
	// SetHoverSelection enables or disables the hover selection mode of @tree_view.
// Hover selection makes the selected row follow the pointer. Currently, this
// works only for the selection modes GTK_SELECTION_SINGLE and
// GTK_SELECTION_BROWSE.
	func (t TreeView) SetHoverSelection(hover bool)  {
var _arg0 *C.GtkTreeView // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
if hover { _arg1 = C.TRUE }

C.gtk_tree_view_set_hover_selection(_arg0, _arg1)
}
	
	// SetLevelIndentation sets the amount of extra indentation for child levels to
// use in @tree_view in addition to the default indentation. The value should be
// specified in pixels, a value of 0 disables this feature and in this case only
// the default indentation will be used. This does not have any visible effects
// for lists.
	func (t TreeView) SetLevelIndentation(indentation int)  {
var _arg0 *C.GtkTreeView // out
var _arg1 C.gint // out

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
_arg1 = (C.gint)(indentation)

C.gtk_tree_view_set_level_indentation(_arg0, _arg1)
}
	
	// SetModel sets the model for a TreeView. If the @tree_view already has a model
// set, it will remove it before setting the new model. If @model is nil, then
// it will unset the old model.
	func (t TreeView) SetModel(model TreeModel)  {
var _arg0 *C.GtkTreeView // out
var _arg1 *C.GtkTreeModel // out

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreeModel)(unsafe.Pointer(model.Native()))

C.gtk_tree_view_set_model(_arg0, _arg1)
}
	
	// SetReorderable: this function is a convenience function to allow you to
// reorder models that support the TreeDragSourceIface and the
// TreeDragDestIface. Both TreeStore and ListStore support these. If
// @reorderable is true, then the user can reorder the model by dragging and
// dropping rows. The developer can listen to these changes by connecting to the
// model’s TreeModel::row-inserted and TreeModel::row-deleted signals. The
// reordering is implemented by setting up the tree view as a drag source and
// destination. Therefore, drag and drop can not be used in a reorderable view
// for any other purpose.
// 
// This function does not give you any degree of control over the order -- any
// reordering is allowed. If more control is needed, you should probably handle
// drag and drop manually.
	func (t TreeView) SetReorderable(reorderable bool)  {
var _arg0 *C.GtkTreeView // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
if reorderable { _arg1 = C.TRUE }

C.gtk_tree_view_set_reorderable(_arg0, _arg1)
}
	
	// SetRubberBanding enables or disables rubber banding in @tree_view. If the
// selection mode is K_SELECTION_MULTIPLE, rubber banding will allow the user to
// select multiple rows by dragging the mouse.
	func (t TreeView) SetRubberBanding(enable bool)  {
var _arg0 *C.GtkTreeView // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
if enable { _arg1 = C.TRUE }

C.gtk_tree_view_set_rubber_banding(_arg0, _arg1)
}
	
	// SetRulesHint sets a hint for the theme to draw even/odd rows in the
// @tree_view with different colors, also known as "zebra striping".
// 
// This function tells the GTK+ theme that the user interface for your
// application requires users to read across tree rows and associate cells with
// one another.
// 
// Do not use it just because you prefer the appearance of the ruled tree;
// that’s a question for the theme. Some themes will draw tree rows in
// alternating colors even when rules are turned off, and users who prefer that
// appearance all the time can choose those themes. You should call this
// function only as a semantic hint to the theme engine that your tree makes
// alternating colors useful from a functional standpoint (since it has lots of
// columns, generally).
	func (t TreeView) SetRulesHint(setting bool)  {
var _arg0 *C.GtkTreeView // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
if setting { _arg1 = C.TRUE }

C.gtk_tree_view_set_rules_hint(_arg0, _arg1)
}
	
	// SetSearchColumn sets @column as the column where the interactive search code
// should search in for the current model.
// 
// If the search column is set, users can use the “start-interactive-search” key
// binding to bring up search popup. The enable-search property controls whether
// simply typing text will also start an interactive search.
// 
// Note that @column refers to a column of the current model. The search column
// is reset to -1 when the model is changed.
	func (t TreeView) SetSearchColumn(column int)  {
var _arg0 *C.GtkTreeView // out
var _arg1 C.gint // out

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
_arg1 = (C.gint)(column)

C.gtk_tree_view_set_search_column(_arg0, _arg1)
}
	
	// SetSearchEntry sets the entry which the interactive search code will use for
// this @tree_view. This is useful when you want to provide a search entry in
// our interface at all time at a fixed position. Passing nil for @entry will
// make the interactive search code use the built-in popup entry again.
	func (t TreeView) SetSearchEntry(entry EntryClass)  {
var _arg0 *C.GtkTreeView // out
var _arg1 *C.GtkEntry // out

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkEntry)(unsafe.Pointer(entry.Native()))

C.gtk_tree_view_set_search_entry(_arg0, _arg1)
}
	
	// SetShowExpanders sets whether to draw and enable expanders and indent child
// rows in @tree_view. When disabled there will be no expanders visible in trees
// and there will be no way to expand and collapse rows by default. Also note
// that hiding the expanders will disable the default indentation. You can set a
// custom indentation in this case using gtk_tree_view_set_level_indentation().
// This does not have any visible effects for lists.
	func (t TreeView) SetShowExpanders(enabled bool)  {
var _arg0 *C.GtkTreeView // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
if enabled { _arg1 = C.TRUE }

C.gtk_tree_view_set_show_expanders(_arg0, _arg1)
}
	
	// SetTooltipCell sets the tip area of @tooltip to the area @path, @column and
// @cell have in common. For example if @path is nil and @column is set, the tip
// area will be set to the full area covered by @column. See also
// gtk_tooltip_set_tip_area().
// 
// Note that if @path is not specified and @cell is set and part of a column
// containing the expander, the tooltip might not show and hide at the correct
// position. In such cases @path must be set to the current node under the mouse
// cursor for this function to operate correctly.
// 
// See also gtk_tree_view_set_tooltip_column() for a simpler alternative.
	func (t TreeView) SetTooltipCell(tooltip TooltipClass, path *TreePath, column TreeViewColumnClass, cell CellRendererClass)  {
var _arg0 *C.GtkTreeView // out
var _arg1 *C.GtkTooltip // out
var _arg2 *C.GtkTreePath // out
var _arg3 *C.GtkTreeViewColumn // out
var _arg4 *C.GtkCellRenderer // out

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTooltip)(unsafe.Pointer(tooltip.Native()))
_arg2 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
_arg3 = (*C.GtkTreeViewColumn)(unsafe.Pointer(column.Native()))
_arg4 = (*C.GtkCellRenderer)(unsafe.Pointer(cell.Native()))

C.gtk_tree_view_set_tooltip_cell(_arg0, _arg1, _arg2, _arg3, _arg4)
}
	
	// SetTooltipColumn: if you only plan to have simple (text-only) tooltips on
// full rows, you can use this function to have TreeView handle these
// automatically for you. @column should be set to the column in @tree_view’s
// model containing the tooltip texts, or -1 to disable this feature.
// 
// When enabled, Widget:has-tooltip will be set to true and @tree_view will
// connect a Widget::query-tooltip signal handler.
// 
// Note that the signal handler sets the text with gtk_tooltip_set_markup(), so
// &, <, etc have to be escaped in the text.
	func (t TreeView) SetTooltipColumn(column int)  {
var _arg0 *C.GtkTreeView // out
var _arg1 C.gint // out

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
_arg1 = (C.gint)(column)

C.gtk_tree_view_set_tooltip_column(_arg0, _arg1)
}
	
	// SetTooltipRow sets the tip area of @tooltip to be the area covered by the row
// at @path. See also gtk_tree_view_set_tooltip_column() for a simpler
// alternative. See also gtk_tooltip_set_tip_area().
	func (t TreeView) SetTooltipRow(tooltip TooltipClass, path *TreePath)  {
var _arg0 *C.GtkTreeView // out
var _arg1 *C.GtkTooltip // out
var _arg2 *C.GtkTreePath // out

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTooltip)(unsafe.Pointer(tooltip.Native()))
_arg2 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

C.gtk_tree_view_set_tooltip_row(_arg0, _arg1, _arg2)
}
	
	// SetVAdjustment sets the Adjustment for the current vertical aspect.
	func (t TreeView) SetVAdjustment(adjustment AdjustmentClass)  {
var _arg0 *C.GtkTreeView // out
var _arg1 *C.GtkAdjustment // out

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(adjustment.Native()))

C.gtk_tree_view_set_vadjustment(_arg0, _arg1)
}
	
	// UnsetRowsDragDest undoes the effect of
// gtk_tree_view_enable_model_drag_dest(). Calling this method sets
// TreeView:reorderable to false.
	func (t TreeView) UnsetRowsDragDest()  {
var _arg0 *C.GtkTreeView // out

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

C.gtk_tree_view_unset_rows_drag_dest(_arg0)
}
	
	// UnsetRowsDragSource undoes the effect of
// gtk_tree_view_enable_model_drag_source(). Calling this method sets
// TreeView:reorderable to false.
	func (t TreeView) UnsetRowsDragSource()  {
var _arg0 *C.GtkTreeView // out

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

C.gtk_tree_view_unset_rows_drag_source(_arg0)
}
	


	// TreeViewColumn: the GtkTreeViewColumn object represents a visible column in a
// TreeView widget. It allows to set properties of the column header, and
// functions as a holding pen for the cell renderers which determine how the
// data in the column is displayed.
// 
// Please refer to the [tree widget conceptual overview][TreeWidget] for an
// overview of all the objects and data types related to the tree widget and how
// they work together.
	type TreeViewColumn struct {
		externglib.InitiallyUnowned
		Buildable
		CellLayout
		
	}

	// TreeViewColumnClass is an interface that the TreeViewColumn class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type TreeViewColumnClass interface {
		gextras.Objector
		_treeViewColumn()
	}

	func (TreeViewColumn) _treeViewColumn() {}

	
	func marshalTreeViewColumn(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapTreeViewColumn(obj), nil
	}
	

	
	// NewTreeViewColumn creates a new TreeViewColumn.
	func NewTreeViewColumn() TreeViewColumn {
var _cret *C.GtkTreeViewColumn // in

_cret = C.gtk_tree_view_column_new()


var _treeViewColumn TreeViewColumn // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_treeViewColumn = TreeViewColumn{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
CellLayout: CellLayout{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _treeViewColumn
}
	
	// NewTreeViewColumnWithArea creates a new TreeViewColumn using @area to render
// its cells.
	func NewTreeViewColumnWithArea(area CellAreaClass) TreeViewColumn {
var _arg1 *C.GtkCellArea // out
var _cret *C.GtkTreeViewColumn // in

_arg1 = (*C.GtkCellArea)(unsafe.Pointer(area.Native()))

_cret = C.gtk_tree_view_column_new_with_area(_arg1)


var _treeViewColumn TreeViewColumn // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_treeViewColumn = TreeViewColumn{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
CellLayout: CellLayout{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _treeViewColumn
}
	

	
	// AddAttribute adds an attribute mapping to the list in @tree_column. The
// @column is the column of the model to get a value from, and the @attribute is
// the parameter on @cell_renderer to be set from the value. So for example if
// column 2 of the model contains strings, you could have the “text” attribute
// of a CellRendererText get its values from column 2.
	func (t TreeViewColumn) AddAttribute(cellRenderer CellRendererClass, attribute string, column int)  {
var _arg0 *C.GtkTreeViewColumn // out
var _arg1 *C.GtkCellRenderer // out
var _arg2 *C.gchar // out
var _arg3 C.gint // out

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(cellRenderer.Native()))
_arg2 = (*C.gchar)(C.CString(attribute))
defer C.free(unsafe.Pointer(_arg2))
_arg3 = (C.gint)(column)

C.gtk_tree_view_column_add_attribute(_arg0, _arg1, _arg2, _arg3)
}
	
	// CellGetPosition obtains the horizontal position and size of a cell in a
// column. If the cell is not found in the column, @start_pos and @width are not
// changed and false is returned.
	func (t TreeViewColumn) CellGetPosition(cellRenderer CellRendererClass) (xOffset int, width int, ok bool) {
var _arg0 *C.GtkTreeViewColumn // out
var _arg1 *C.GtkCellRenderer // out
var _arg2 C.gint // in
var _arg3 C.gint // in
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(cellRenderer.Native()))

_cret = C.gtk_tree_view_column_cell_get_position(_arg0, _arg1, &_arg2, &_arg3)


var _xOffset int // out
var _width int // out
var _ok bool // out

_xOffset = (int)(_arg2)
_width = (int)(_arg3)
if _cret != 0 { _ok = true }

return _xOffset, _width, _ok
}
	
	// CellGetSize obtains the width and height needed to render the column. This is
// used primarily by the TreeView.
	func (t TreeViewColumn) CellGetSize(cellArea *gdk.Rectangle) (xOffset int, yOffset int, width int, height int) {
var _arg0 *C.GtkTreeViewColumn // out
var _arg1 *C.GdkRectangle // out
var _arg2 C.gint // in
var _arg3 C.gint // in
var _arg4 C.gint // in
var _arg5 C.gint // in

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GdkRectangle)(unsafe.Pointer(cellArea.Native()))

C.gtk_tree_view_column_cell_get_size(_arg0, _arg1, &_arg2, &_arg3, &_arg4, &_arg5)

var _xOffset int // out
var _yOffset int // out
var _width int // out
var _height int // out

_xOffset = (int)(_arg2)
_yOffset = (int)(_arg3)
_width = (int)(_arg4)
_height = (int)(_arg5)

return _xOffset, _yOffset, _width, _height
}
	
	// CellIsVisible returns true if any of the cells packed into the @tree_column
// are visible. For this to be meaningful, you must first initialize the cells
// with gtk_tree_view_column_cell_set_cell_data()
	func (t TreeViewColumn) CellIsVisible() bool {
var _arg0 *C.GtkTreeViewColumn // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_column_cell_is_visible(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// CellSetCellData sets the cell renderer based on the @tree_model and @iter.
// That is, for every attribute mapping in @tree_column, it will get a value
// from the set column on the @iter, and use that value to set the attribute on
// the cell renderer. This is used primarily by the TreeView.
	func (t TreeViewColumn) CellSetCellData(treeModel TreeModel, iter *TreeIter, isExpander bool, isExpanded bool)  {
var _arg0 *C.GtkTreeViewColumn // out
var _arg1 *C.GtkTreeModel // out
var _arg2 *C.GtkTreeIter // out
var _arg3 C.gboolean // out
var _arg4 C.gboolean // out

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreeModel)(unsafe.Pointer(treeModel.Native()))
_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))
if isExpander { _arg3 = C.TRUE }
if isExpanded { _arg4 = C.TRUE }

C.gtk_tree_view_column_cell_set_cell_data(_arg0, _arg1, _arg2, _arg3, _arg4)
}
	
	// Clear unsets all the mappings on all renderers on the @tree_column.
	func (t TreeViewColumn) Clear()  {
var _arg0 *C.GtkTreeViewColumn // out

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

C.gtk_tree_view_column_clear(_arg0)
}
	
	// ClearAttributes clears all existing attributes previously set with
// gtk_tree_view_column_set_attributes().
	func (t TreeViewColumn) ClearAttributes(cellRenderer CellRendererClass)  {
var _arg0 *C.GtkTreeViewColumn // out
var _arg1 *C.GtkCellRenderer // out

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(cellRenderer.Native()))

C.gtk_tree_view_column_clear_attributes(_arg0, _arg1)
}
	
	// Clicked emits the “clicked” signal on the column. This function will only
// work if @tree_column is clickable.
	func (t TreeViewColumn) Clicked()  {
var _arg0 *C.GtkTreeViewColumn // out

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

C.gtk_tree_view_column_clicked(_arg0)
}
	
	// FocusCell sets the current keyboard focus to be at @cell, if the column
// contains 2 or more editable and activatable cells.
	func (t TreeViewColumn) FocusCell(cell CellRendererClass)  {
var _arg0 *C.GtkTreeViewColumn // out
var _arg1 *C.GtkCellRenderer // out

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(cell.Native()))

C.gtk_tree_view_column_focus_cell(_arg0, _arg1)
}
	
	// Alignment returns the current x alignment of @tree_column. This value can
// range between 0.0 and 1.0.
	func (t TreeViewColumn) Alignment() float32 {
var _arg0 *C.GtkTreeViewColumn // out
var _cret C.gfloat // in

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_column_get_alignment(_arg0)


var _gfloat float32 // out

_gfloat = (float32)(_cret)

return _gfloat
}
	
	// Button returns the button used in the treeview column header
	func (t TreeViewColumn) Button() Widget {
var _arg0 *C.GtkTreeViewColumn // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_column_get_button(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// Clickable returns true if the user can click on the header for the column.
	func (t TreeViewColumn) Clickable() bool {
var _arg0 *C.GtkTreeViewColumn // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_column_get_clickable(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Expand returns true if the column expands to fill available space.
	func (t TreeViewColumn) Expand() bool {
var _arg0 *C.GtkTreeViewColumn // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_column_get_expand(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// FixedWidth gets the fixed width of the column. This may not be the actual
// displayed width of the column; for that, use
// gtk_tree_view_column_get_width().
	func (t TreeViewColumn) FixedWidth() int {
var _arg0 *C.GtkTreeViewColumn // out
var _cret C.gint // in

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_column_get_fixed_width(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// MaxWidth returns the maximum width in pixels of the @tree_column, or -1 if no
// maximum width is set.
	func (t TreeViewColumn) MaxWidth() int {
var _arg0 *C.GtkTreeViewColumn // out
var _cret C.gint // in

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_column_get_max_width(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// MinWidth returns the minimum width in pixels of the @tree_column, or -1 if no
// minimum width is set.
	func (t TreeViewColumn) MinWidth() int {
var _arg0 *C.GtkTreeViewColumn // out
var _cret C.gint // in

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_column_get_min_width(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Reorderable returns true if the @tree_column can be reordered by the user.
	func (t TreeViewColumn) Reorderable() bool {
var _arg0 *C.GtkTreeViewColumn // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_column_get_reorderable(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Resizable returns true if the @tree_column can be resized by the end user.
	func (t TreeViewColumn) Resizable() bool {
var _arg0 *C.GtkTreeViewColumn // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_column_get_resizable(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Sizing returns the current type of @tree_column.
	func (t TreeViewColumn) Sizing() TreeViewColumnSizing {
var _arg0 *C.GtkTreeViewColumn // out
var _cret C.GtkTreeViewColumnSizing // in

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_column_get_sizing(_arg0)


var _treeViewColumnSizing TreeViewColumnSizing // out

_treeViewColumnSizing = TreeViewColumnSizing(_cret)

return _treeViewColumnSizing
}
	
	// SortColumnID gets the logical @sort_column_id that the model sorts on when
// this column is selected for sorting. See
// gtk_tree_view_column_set_sort_column_id().
	func (t TreeViewColumn) SortColumnID() int {
var _arg0 *C.GtkTreeViewColumn // out
var _cret C.gint // in

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_column_get_sort_column_id(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// SortIndicator gets the value set by
// gtk_tree_view_column_set_sort_indicator().
	func (t TreeViewColumn) SortIndicator() bool {
var _arg0 *C.GtkTreeViewColumn // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_column_get_sort_indicator(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SortOrder gets the value set by gtk_tree_view_column_set_sort_order().
	func (t TreeViewColumn) SortOrder() SortType {
var _arg0 *C.GtkTreeViewColumn // out
var _cret C.GtkSortType // in

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_column_get_sort_order(_arg0)


var _sortType SortType // out

_sortType = SortType(_cret)

return _sortType
}
	
	// Spacing returns the spacing of @tree_column.
	func (t TreeViewColumn) Spacing() int {
var _arg0 *C.GtkTreeViewColumn // out
var _cret C.gint // in

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_column_get_spacing(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Title returns the title of the widget.
	func (t TreeViewColumn) Title() string {
var _arg0 *C.GtkTreeViewColumn // out
var _cret *C.gchar // in

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_column_get_title(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// TreeView returns the TreeView wherein @tree_column has been inserted. If
// @column is currently not inserted in any tree view, nil is returned.
	func (t TreeViewColumn) TreeView() Widget {
var _arg0 *C.GtkTreeViewColumn // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_column_get_tree_view(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// Visible returns true if @tree_column is visible.
	func (t TreeViewColumn) Visible() bool {
var _arg0 *C.GtkTreeViewColumn // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_column_get_visible(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Widget returns the Widget in the button on the column header. If a custom
// widget has not been set then nil is returned.
	func (t TreeViewColumn) Widget() Widget {
var _arg0 *C.GtkTreeViewColumn // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_column_get_widget(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// Width returns the current size of @tree_column in pixels.
	func (t TreeViewColumn) Width() int {
var _arg0 *C.GtkTreeViewColumn // out
var _cret C.gint // in

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_column_get_width(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// XOffset returns the current X offset of @tree_column in pixels.
	func (t TreeViewColumn) XOffset() int {
var _arg0 *C.GtkTreeViewColumn // out
var _cret C.gint // in

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_column_get_x_offset(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// PackEnd adds the @cell to end of the column. If @expand is false, then the
// @cell is allocated no more space than it needs. Any unused space is divided
// evenly between cells for which @expand is true.
	func (t TreeViewColumn) PackEnd(cell CellRendererClass, expand bool)  {
var _arg0 *C.GtkTreeViewColumn // out
var _arg1 *C.GtkCellRenderer // out
var _arg2 C.gboolean // out

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(cell.Native()))
if expand { _arg2 = C.TRUE }

C.gtk_tree_view_column_pack_end(_arg0, _arg1, _arg2)
}
	
	// PackStart packs the @cell into the beginning of the column. If @expand is
// false, then the @cell is allocated no more space than it needs. Any unused
// space is divided evenly between cells for which @expand is true.
	func (t TreeViewColumn) PackStart(cell CellRendererClass, expand bool)  {
var _arg0 *C.GtkTreeViewColumn // out
var _arg1 *C.GtkCellRenderer // out
var _arg2 C.gboolean // out

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(cell.Native()))
if expand { _arg2 = C.TRUE }

C.gtk_tree_view_column_pack_start(_arg0, _arg1, _arg2)
}
	
	// QueueResize flags the column, and the cell renderers added to this column, to
// have their sizes renegotiated.
	func (t TreeViewColumn) QueueResize()  {
var _arg0 *C.GtkTreeViewColumn // out

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

C.gtk_tree_view_column_queue_resize(_arg0)
}
	
	// SetAlignment sets the alignment of the title or custom widget inside the
// column header. The alignment determines its location inside the button -- 0.0
// for left, 0.5 for center, 1.0 for right.
	func (t TreeViewColumn) SetAlignment(xalign float32)  {
var _arg0 *C.GtkTreeViewColumn // out
var _arg1 C.gfloat // out

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
_arg1 = (C.gfloat)(xalign)

C.gtk_tree_view_column_set_alignment(_arg0, _arg1)
}
	
	// SetClickable sets the header to be active if @clickable is true. When the
// header is active, then it can take keyboard focus, and can be clicked.
	func (t TreeViewColumn) SetClickable(clickable bool)  {
var _arg0 *C.GtkTreeViewColumn // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
if clickable { _arg1 = C.TRUE }

C.gtk_tree_view_column_set_clickable(_arg0, _arg1)
}
	
	// SetExpand sets the column to take available extra space. This space is shared
// equally amongst all columns that have the expand set to true. If no column
// has this option set, then the last column gets all extra space. By default,
// every column is created with this false.
// 
// Along with “fixed-width”, the “expand” property changes when the column is
// resized by the user.
	func (t TreeViewColumn) SetExpand(expand bool)  {
var _arg0 *C.GtkTreeViewColumn // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
if expand { _arg1 = C.TRUE }

C.gtk_tree_view_column_set_expand(_arg0, _arg1)
}
	
	// SetFixedWidth: if @fixed_width is not -1, sets the fixed width of
// @tree_column; otherwise unsets it. The effective value of @fixed_width is
// clamped between the minimum and maximum width of the column; however, the
// value stored in the “fixed-width” property is not clamped. If the column
// sizing is K_TREE_VIEW_COLUMN_GROW_ONLY or K_TREE_VIEW_COLUMN_AUTOSIZE,
// setting a fixed width overrides the automatically calculated width. Note that
// @fixed_width is only a hint to GTK+; the width actually allocated to the
// column may be greater or less than requested.
// 
// Along with “expand”, the “fixed-width” property changes when the column is
// resized by the user.
	func (t TreeViewColumn) SetFixedWidth(fixedWidth int)  {
var _arg0 *C.GtkTreeViewColumn // out
var _arg1 C.gint // out

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
_arg1 = (C.gint)(fixedWidth)

C.gtk_tree_view_column_set_fixed_width(_arg0, _arg1)
}
	
	// SetMaxWidth sets the maximum width of the @tree_column. If @max_width is -1,
// then the maximum width is unset. Note, the column can actually be wider than
// max width if it’s the last column in a view. In this case, the column expands
// to fill any extra space.
	func (t TreeViewColumn) SetMaxWidth(maxWidth int)  {
var _arg0 *C.GtkTreeViewColumn // out
var _arg1 C.gint // out

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
_arg1 = (C.gint)(maxWidth)

C.gtk_tree_view_column_set_max_width(_arg0, _arg1)
}
	
	// SetMinWidth sets the minimum width of the @tree_column. If @min_width is -1,
// then the minimum width is unset.
	func (t TreeViewColumn) SetMinWidth(minWidth int)  {
var _arg0 *C.GtkTreeViewColumn // out
var _arg1 C.gint // out

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
_arg1 = (C.gint)(minWidth)

C.gtk_tree_view_column_set_min_width(_arg0, _arg1)
}
	
	// SetReorderable: if @reorderable is true, then the column can be reordered by
// the end user dragging the header.
	func (t TreeViewColumn) SetReorderable(reorderable bool)  {
var _arg0 *C.GtkTreeViewColumn // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
if reorderable { _arg1 = C.TRUE }

C.gtk_tree_view_column_set_reorderable(_arg0, _arg1)
}
	
	// SetResizable: if @resizable is true, then the user can explicitly resize the
// column by grabbing the outer edge of the column button. If resizable is true
// and sizing mode of the column is K_TREE_VIEW_COLUMN_AUTOSIZE, then the sizing
// mode is changed to K_TREE_VIEW_COLUMN_GROW_ONLY.
	func (t TreeViewColumn) SetResizable(resizable bool)  {
var _arg0 *C.GtkTreeViewColumn // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
if resizable { _arg1 = C.TRUE }

C.gtk_tree_view_column_set_resizable(_arg0, _arg1)
}
	
	// SetSizing sets the growth behavior of @tree_column to @type.
	func (t TreeViewColumn) SetSizing(typ TreeViewColumnSizing)  {
var _arg0 *C.GtkTreeViewColumn // out
var _arg1 C.GtkTreeViewColumnSizing // out

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
_arg1 = (C.GtkTreeViewColumnSizing)(typ)

C.gtk_tree_view_column_set_sizing(_arg0, _arg1)
}
	
	// SetSortColumnID sets the logical @sort_column_id that this column sorts on
// when this column is selected for sorting. Doing so makes the column header
// clickable.
	func (t TreeViewColumn) SetSortColumnID(sortColumnId int)  {
var _arg0 *C.GtkTreeViewColumn // out
var _arg1 C.gint // out

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
_arg1 = (C.gint)(sortColumnId)

C.gtk_tree_view_column_set_sort_column_id(_arg0, _arg1)
}
	
	// SetSortIndicator: call this function with a @setting of true to display an
// arrow in the header button indicating the column is sorted. Call
// gtk_tree_view_column_set_sort_order() to change the direction of the arrow.
	func (t TreeViewColumn) SetSortIndicator(setting bool)  {
var _arg0 *C.GtkTreeViewColumn // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
if setting { _arg1 = C.TRUE }

C.gtk_tree_view_column_set_sort_indicator(_arg0, _arg1)
}
	
	// SetSortOrder changes the appearance of the sort indicator.
// 
// This does not actually sort the model. Use
// gtk_tree_view_column_set_sort_column_id() if you want automatic sorting
// support. This function is primarily for custom sorting behavior, and should
// be used in conjunction with gtk_tree_sortable_set_sort_column_id() to do
// that. For custom models, the mechanism will vary.
// 
// The sort indicator changes direction to indicate normal sort or reverse sort.
// Note that you must have the sort indicator enabled to see anything when
// calling this function; see gtk_tree_view_column_set_sort_indicator().
	func (t TreeViewColumn) SetSortOrder(order SortType)  {
var _arg0 *C.GtkTreeViewColumn // out
var _arg1 C.GtkSortType // out

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
_arg1 = (C.GtkSortType)(order)

C.gtk_tree_view_column_set_sort_order(_arg0, _arg1)
}
	
	// SetSpacing sets the spacing field of @tree_column, which is the number of
// pixels to place between cell renderers packed into it.
	func (t TreeViewColumn) SetSpacing(spacing int)  {
var _arg0 *C.GtkTreeViewColumn // out
var _arg1 C.gint // out

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
_arg1 = (C.gint)(spacing)

C.gtk_tree_view_column_set_spacing(_arg0, _arg1)
}
	
	// SetTitle sets the title of the @tree_column. If a custom widget has been set,
// then this value is ignored.
	func (t TreeViewColumn) SetTitle(title string)  {
var _arg0 *C.GtkTreeViewColumn // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
_arg1 = (*C.gchar)(C.CString(title))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_tree_view_column_set_title(_arg0, _arg1)
}
	
	// SetVisible sets the visibility of @tree_column.
	func (t TreeViewColumn) SetVisible(visible bool)  {
var _arg0 *C.GtkTreeViewColumn // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
if visible { _arg1 = C.TRUE }

C.gtk_tree_view_column_set_visible(_arg0, _arg1)
}
	
	// SetWidget sets the widget in the header to be @widget. If widget is nil, then
// the header button is set with a Label set to the title of @tree_column.
	func (t TreeViewColumn) SetWidget(widget WidgetClass)  {
var _arg0 *C.GtkTreeViewColumn // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

C.gtk_tree_view_column_set_widget(_arg0, _arg1)
}
	


	// UIManager: > GtkUIManager is deprecated since GTK+ 3.10. To construct user
// interfaces > from XML definitions, you should use Builder, Model, et al. To >
// work with actions, use #GAction, Actionable et al. These newer classes >
// support richer functionality and integration with various desktop shells. >
// It should be possible to migrate most/all functionality from GtkUIManager.
// 
// A UIManager constructs a user interface (menus and toolbars) from one or more
// UI definitions, which reference actions from one or more action groups.
// 
// 
// UI Definitions
// 
// The UI definitions are specified in an XML format which can be roughly
// described by the following DTD.
// 
// > Do not confuse the GtkUIManager UI Definitions described here with > the
// similarly named [GtkBuilder UI Definitions][BUILDER-UI].
// 
//    <!ELEMENT ui          (menubar|toolbar|popup|accelerator)* >
//    <!ELEMENT menubar     (menuitem|separator|placeholder|menu)* >
//    <!ELEMENT menu        (menuitem|separator|placeholder|menu)* >
//    <!ELEMENT popup       (menuitem|separator|placeholder|menu)* >
//    <!ELEMENT toolbar     (toolitem|separator|placeholder)* >
//    <!ELEMENT placeholder (menuitem|toolitem|separator|placeholder|menu)* >
//    <!ELEMENT menuitem     EMPTY >
//    <!ELEMENT toolitem     (menu?) >
//    <!ELEMENT separator    EMPTY >
//    <!ELEMENT accelerator  EMPTY >
//    <!ATTLIST menubar      name                      PLIED
//                           action                    PLIED >
//    <!ATTLIST toolbar      name                      PLIED
//                           action                    PLIED >
//    <!ATTLIST popup        name                      PLIED
//                           action                    PLIED
//                           accelerators (true|false) PLIED >
//    <!ATTLIST placeholder  name                      PLIED
//                           action                    PLIED >
//    <!ATTLIST separator    name                      PLIED
//                           action                    PLIED
//                           expand       (true|false) PLIED >
//    <!ATTLIST menu         name                      PLIED
//                           action                    QUIRED
//                           position     (top|bot)    PLIED >
//    <!ATTLIST menuitem     name                      PLIED
//                           action                    QUIRED
//                           position     (top|bot)    PLIED
//                           always-show-image (true|false) PLIED >
//    <!ATTLIST toolitem     name                      PLIED
//                           action                    QUIRED
//                           position     (top|bot)    PLIED >
//    <!ATTLIST accelerator  name                      PLIED
//                           action                    QUIRED >
// 
// There are some additional restrictions beyond those specified in the DTD,
// e.g. every toolitem must have a toolbar in its anchestry and every menuitem
// must have a menubar or popup in its anchestry. Since a Parser is used to
// parse the UI description, it must not only be valid XML, but valid markup.
// 
// If a name is not specified, it defaults to the action. If an action is not
// specified either, the element name is used. The name and action attributes
// must not contain “/” characters after parsing (since that would mess up path
// lookup) and must be usable as XML attributes when enclosed in doublequotes,
// thus they must not “"” characters or references to the &quot; entity.
// 
// A UI definition #
// 
//    <ui>
//      <menubar>
//        <menu name="FileMenu" action="FileMenuAction">
//          <menuitem name="New" action="New2Action" />
//          <placeholder name="FileMenuAdditions" />
//        </menu>
//        <menu name="JustifyMenu" action="JustifyMenuAction">
//          <menuitem name="Left" action="justify-left"/>
//          <menuitem name="Centre" action="justify-center"/>
//          <menuitem name="Right" action="justify-right"/>
//          <menuitem name="Fill" action="justify-fill"/>
//        </menu>
//      </menubar>
//      <toolbar action="toolbar1">
//        <placeholder name="JustifyToolItems">
//          <separator/>
//          <toolitem name="Left" action="justify-left"/>
//          <toolitem name="Centre" action="justify-center"/>
//          <toolitem name="Right" action="justify-right"/>
//          <toolitem name="Fill" action="justify-fill"/>
//          <separator/>
//        </placeholder>
//      </toolbar>
//    </ui>
// 
// The constructed widget hierarchy is very similar to the element tree of the
// XML, with the exception that placeholders are merged into their parents. The
// correspondence of XML elements to widgets should be almost obvious:
// 
// - menubar
// 
//    a MenuBar
// 
// - toolbar
// 
//    a Toolbar
// 
// - popup
// 
//    a toplevel Menu
// 
// - menu
// 
//    a Menu attached to a menuitem
// 
// - menuitem
// 
//    a MenuItem subclass, the exact type depends on the action
// 
// - toolitem
// 
//    a ToolItem subclass, the exact type depends on the
//    action. Note that toolitem elements may contain a menu element,
//    but only if their associated action specifies a
//    MenuToolButton as proxy.
// 
// - separator
// 
//    a SeparatorMenuItem or SeparatorToolItem
// 
// - accelerator
// 
//    a keyboard accelerator
// 
// The “position” attribute determines where a constructed widget is positioned
// wrt. to its siblings in the partially constructed tree. If it is “top”, the
// widget is prepended, otherwise it is appended.
// 
// 
// UI Merging
// 
// The most remarkable feature of UIManager is that it can overlay a set of
// menuitems and toolitems over another one, and demerge them later.
// 
// Merging is done based on the names of the XML elements. Each element is
// identified by a path which consists of the names of its anchestors, separated
// by slashes. For example, the menuitem named “Left” in the example above has
// the path `/ui/menubar/JustifyMenu/Left` and the toolitem with the same name
// has path `/ui/toolbar1/JustifyToolItems/Left`.
// 
// Accelerators #
// 
// Every action has an accelerator path. Accelerators are installed together
// with menuitem proxies, but they can also be explicitly added with
// <accelerator> elements in the UI definition. This makes it possible to have
// accelerators for actions even if they have no visible proxies.
// 
// 
// Smart Separators
// 
// The separators created by UIManager are “smart”, i.e. they do not show up in
// the UI unless they end up between two visible menu or tool items. Separators
// which are located at the very beginning or end of the menu or toolbar
// containing them, or multiple separators next to each other, are hidden. This
// is a useful feature, since the merging of UI elements from multiple sources
// can make it hard or impossible to determine in advance whether a separator
// will end up in such an unfortunate position.
// 
// For separators in toolbars, you can set `expand="true"` to turn them from a
// small, visible separator to an expanding, invisible one. Toolitems following
// an expanding separator are effectively right-aligned.
// 
// 
// Empty Menus
// 
// Submenus pose similar problems to separators inconnection with merging. It is
// impossible to know in advance whether they will end up empty after merging.
// UIManager offers two ways to treat empty submenus:
// 
// - make them disappear by hiding the menu item they’re attached to
// 
// - add an insensitive “Empty” item
// 
// The behaviour is chosen based on the “hide_if_empty” property of the action
// to which the submenu is associated.
// 
// 
// GtkUIManager as GtkBuildable
// 
// The GtkUIManager implementation of the GtkBuildable interface accepts
// GtkActionGroup objects as <child> elements in UI definitions.
// 
// A GtkUIManager UI definition as described above can be embedded in an
// GtkUIManager <object> element in a GtkBuilder UI definition.
// 
// The widgets that are constructed by a GtkUIManager can be embedded in other
// parts of the constructed user interface with the help of the “constructor”
// attribute. See the example below.
// 
// An embedded GtkUIManager UI definition
// 
//    <object class="GtkUIManager" id="uiman">
//      <child>
//        <object class="GtkActionGroup" id="actiongroup">
//          <child>
//            <object class="GtkAction" id="file">
//              <property name="label">_File</property>
//            </object>
//          </child>
//        </object>
//      </child>
//      <ui>
//        <menubar name="menubar1">
//          <menu action="file">
//          </menu>
//        </menubar>
//      </ui>
//    </object>
//    <object class="GtkWindow" id="main-window">
//      <child>
//        <object class="GtkMenuBar" id="menubar1" constructor="uiman"/>
//      </child>
//    </object>
	type UIManager struct {
		**externglib.Object
		Buildable
		
	}

	// UIManagerClass is an interface that the UIManager class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type UIManagerClass interface {
		gextras.Objector
		_uiManager()
	}

	func (UIManager) _uiManager() {}

	
	func marshalUIManager(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapUIManager(obj), nil
	}
	

	
	// NewUIManager creates a new ui manager object.
	func NewUIManager() UIManager {
var _cret *C.GtkUIManager // in

_cret = C.gtk_ui_manager_new()


var _uiManager UIManager // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_uiManager = UIManager{
Object: &externglib.Object{externglib.ToGObject(obj)},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _uiManager
}
	

	
	// AddUi adds a UI element to the current contents of @manager.
// 
// If @type is GTK_UI_MANAGER_AUTO, GTK+ inserts a menuitem, toolitem or
// separator if such an element can be inserted at the place determined by
// @path. Otherwise @type must indicate an element that can be inserted at the
// place determined by @path.
// 
// If @path points to a menuitem or toolitem, the new element will be inserted
// before or after this item, depending on @top.
	func (m UIManager) AddUi(mergeId uint, path string, name string, action string, typ UIManagerItemType, top bool)  {
var _arg0 *C.GtkUIManager // out
var _arg1 C.guint // out
var _arg2 *C.gchar // out
var _arg3 *C.gchar // out
var _arg4 *C.gchar // out
var _arg5 C.GtkUIManagerItemType // out
var _arg6 C.gboolean // out

_arg0 = (*C.GtkUIManager)(unsafe.Pointer(m.Native()))
_arg1 = (C.guint)(mergeId)
_arg2 = (*C.gchar)(C.CString(path))
defer C.free(unsafe.Pointer(_arg2))
_arg3 = (*C.gchar)(C.CString(name))
defer C.free(unsafe.Pointer(_arg3))
_arg4 = (*C.gchar)(C.CString(action))
defer C.free(unsafe.Pointer(_arg4))
_arg5 = (C.GtkUIManagerItemType)(typ)
if top { _arg6 = C.TRUE }

C.gtk_ui_manager_add_ui(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
}
	
	// AddUiFromFile parses a file containing a [UI definition][XML-UI] and merges
// it with the current contents of @manager.
	func (m UIManager) AddUiFromFile(filename string) (uint, error) {
var _arg0 *C.GtkUIManager // out
var _arg1 *C.gchar // out
var _cret C.guint // in
var _cerr *C.GError // in

_arg0 = (*C.GtkUIManager)(unsafe.Pointer(m.Native()))
_arg1 = (*C.gchar)(C.CString(filename))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_ui_manager_add_ui_from_file(_arg0, _arg1, &_cerr)


var _guint uint // out
var _goerr error // out

_guint = (uint)(_cret)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _guint, _goerr
}
	
	// AddUiFromResource parses a resource file containing a [UI definition][XML-UI]
// and merges it with the current contents of @manager.
	func (m UIManager) AddUiFromResource(resourcePath string) (uint, error) {
var _arg0 *C.GtkUIManager // out
var _arg1 *C.gchar // out
var _cret C.guint // in
var _cerr *C.GError // in

_arg0 = (*C.GtkUIManager)(unsafe.Pointer(m.Native()))
_arg1 = (*C.gchar)(C.CString(resourcePath))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_ui_manager_add_ui_from_resource(_arg0, _arg1, &_cerr)


var _guint uint // out
var _goerr error // out

_guint = (uint)(_cret)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _guint, _goerr
}
	
	// AddUiFromString parses a string containing a [UI definition][XML-UI] and
// merges it with the current contents of @manager. An enclosing <ui> element is
// added if it is missing.
	func (m UIManager) AddUiFromString(buffer string, length int) (uint, error) {
var _arg0 *C.GtkUIManager // out
var _arg1 *C.gchar // out
var _arg2 C.gssize // out
var _cret C.guint // in
var _cerr *C.GError // in

_arg0 = (*C.GtkUIManager)(unsafe.Pointer(m.Native()))
_arg1 = (*C.gchar)(C.CString(buffer))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.gssize)(length)

_cret = C.gtk_ui_manager_add_ui_from_string(_arg0, _arg1, _arg2, &_cerr)


var _guint uint // out
var _goerr error // out

_guint = (uint)(_cret)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _guint, _goerr
}
	
	// EnsureUpdate makes sure that all pending updates to the UI have been
// completed.
// 
// This may occasionally be necessary, since UIManager updates the UI in an idle
// function. A typical example where this function is useful is to enforce that
// the menubar and toolbar have been added to the main window before showing it:
// 
//    gtk_container_add (GTK_CONTAINER (window), vbox);
//    g_signal_connect (merge, "add-widget",
//                      G_CALLBACK (add_widget), vbox);
//    gtk_ui_manager_add_ui_from_file (merge, "my-menus");
//    gtk_ui_manager_add_ui_from_file (merge, "my-toolbars");
//    gtk_ui_manager_ensure_update (merge);
//    gtk_widget_show (window);
	func (m UIManager) EnsureUpdate()  {
var _arg0 *C.GtkUIManager // out

_arg0 = (*C.GtkUIManager)(unsafe.Pointer(m.Native()))

C.gtk_ui_manager_ensure_update(_arg0)
}
	
	// AccelGroup returns the AccelGroup associated with @manager.
	func (m UIManager) AccelGroup() AccelGroup {
var _arg0 *C.GtkUIManager // out
var _cret *C.GtkAccelGroup // in

_arg0 = (*C.GtkUIManager)(unsafe.Pointer(m.Native()))

_cret = C.gtk_ui_manager_get_accel_group(_arg0)


var _accelGroup AccelGroup // out

_accelGroup = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(AccelGroup)

return _accelGroup
}
	
	// Action looks up an action by following a path. See
// gtk_ui_manager_get_widget() for more information about paths.
	func (m UIManager) Action(path string) Action {
var _arg0 *C.GtkUIManager // out
var _arg1 *C.gchar // out
var _cret *C.GtkAction // in

_arg0 = (*C.GtkUIManager)(unsafe.Pointer(m.Native()))
_arg1 = (*C.gchar)(C.CString(path))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_ui_manager_get_action(_arg0, _arg1)


var _action Action // out

_action = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Action)

return _action
}
	
	// AddTearoffs returns whether menus generated by this UIManager will have
// tearoff menu items.
	func (m UIManager) AddTearoffs() bool {
var _arg0 *C.GtkUIManager // out
var _cret C.gboolean // in

_arg0 = (*C.GtkUIManager)(unsafe.Pointer(m.Native()))

_cret = C.gtk_ui_manager_get_add_tearoffs(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Ui creates a [UI definition][XML-UI] of the merged UI.
	func (m UIManager) Ui() string {
var _arg0 *C.GtkUIManager // out
var _cret *C.gchar // in

_arg0 = (*C.GtkUIManager)(unsafe.Pointer(m.Native()))

_cret = C.gtk_ui_manager_get_ui(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// Widget looks up a widget by following a path. The path consists of the names
// specified in the XML description of the UI. separated by “/”. Elements which
// don’t have a name or action attribute in the XML (e.g. <popup>) can be
// addressed by their XML element name (e.g. "popup"). The root element ("/ui")
// can be omitted in the path.
// 
// Note that the widget found by following a path that ends in a <menu>; element
// is the menuitem to which the menu is attached, not the menu it manages.
// 
// Also note that the widgets constructed by a ui manager are not tied to the
// lifecycle of the ui manager. If you add the widgets returned by this function
// to some container or explicitly ref them, they will survive the destruction
// of the ui manager.
	func (m UIManager) Widget(path string) Widget {
var _arg0 *C.GtkUIManager // out
var _arg1 *C.gchar // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkUIManager)(unsafe.Pointer(m.Native()))
_arg1 = (*C.gchar)(C.CString(path))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_ui_manager_get_widget(_arg0, _arg1)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// InsertActionGroup inserts an action group into the list of action groups
// associated with @manager. Actions in earlier groups hide actions with the
// same name in later groups.
// 
// If @pos is larger than the number of action groups in @manager, or negative,
// @action_group will be inserted at the end of the internal list.
	func (m UIManager) InsertActionGroup(actionGroup ActionGroupClass, pos int)  {
var _arg0 *C.GtkUIManager // out
var _arg1 *C.GtkActionGroup // out
var _arg2 C.gint // out

_arg0 = (*C.GtkUIManager)(unsafe.Pointer(m.Native()))
_arg1 = (*C.GtkActionGroup)(unsafe.Pointer(actionGroup.Native()))
_arg2 = (C.gint)(pos)

C.gtk_ui_manager_insert_action_group(_arg0, _arg1, _arg2)
}
	
	// NewMergeID returns an unused merge id, suitable for use with
// gtk_ui_manager_add_ui().
	func (m UIManager) NewMergeID() uint {
var _arg0 *C.GtkUIManager // out
var _cret C.guint // in

_arg0 = (*C.GtkUIManager)(unsafe.Pointer(m.Native()))

_cret = C.gtk_ui_manager_new_merge_id(_arg0)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// RemoveActionGroup removes an action group from the list of action groups
// associated with @manager.
	func (m UIManager) RemoveActionGroup(actionGroup ActionGroupClass)  {
var _arg0 *C.GtkUIManager // out
var _arg1 *C.GtkActionGroup // out

_arg0 = (*C.GtkUIManager)(unsafe.Pointer(m.Native()))
_arg1 = (*C.GtkActionGroup)(unsafe.Pointer(actionGroup.Native()))

C.gtk_ui_manager_remove_action_group(_arg0, _arg1)
}
	
	// RemoveUi unmerges the part of @manager's content identified by @merge_id.
	func (m UIManager) RemoveUi(mergeId uint)  {
var _arg0 *C.GtkUIManager // out
var _arg1 C.guint // out

_arg0 = (*C.GtkUIManager)(unsafe.Pointer(m.Native()))
_arg1 = (C.guint)(mergeId)

C.gtk_ui_manager_remove_ui(_arg0, _arg1)
}
	
	// SetAddTearoffs sets the “add_tearoffs” property, which controls whether menus
// generated by this UIManager will have tearoff menu items.
// 
// Note that this only affects regular menus. Generated popup menus never have
// tearoff menu items.
	func (m UIManager) SetAddTearoffs(addTearoffs bool)  {
var _arg0 *C.GtkUIManager // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkUIManager)(unsafe.Pointer(m.Native()))
if addTearoffs { _arg1 = C.TRUE }

C.gtk_ui_manager_set_add_tearoffs(_arg0, _arg1)
}
	


	// VBox: a VBox is a container that organizes child widgets into a single
// column.
// 
// Use the Box packing interface to determine the arrangement, spacing, height,
// and alignment of VBox children.
// 
// All children are allocated the same width.
// 
// GtkVBox has been deprecated. You can use Box with a Orientable:orientation
// set to GTK_ORIENTATION_VERTICAL instead when calling gtk_box_new(), which is
// a very quick and easy change.
// 
// If you have derived your own classes from GtkVBox, you can change the
// inheritance to derive directly from Box, and set the Orientable:orientation
// property to GTK_ORIENTATION_VERTICAL in your instance init function, with a
// call like:
// 
//    gtk_orientable_set_orientation (GTK_ORIENTABLE (object),
//                                    GTK_ORIENTATION_VERTICAL);
// 
// If you have a grid-like layout composed of nested boxes, and you don’t need
// first-child or last-child styling, the recommendation is to switch to Grid.
// For more information about migrating to Grid, see [Migrating from other
// containers to GtkGrid][gtk-migrating-GtkGrid].
	type VBox struct {
		Box
		Buildable
		Orientable
		
	}

	// VBoxClass is an interface that the VBox class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type VBoxClass interface {
		gextras.Objector
		_vBox()
	}

	func (VBox) _vBox() {}

	
	func marshalVBox(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapVBox(obj), nil
	}
	

	
	// NewVBox creates a new VBox.
	func NewVBox(homogeneous bool, spacing int) VBox {
var _arg1 C.gboolean // out
var _arg2 C.gint // out
var _cret *C.GtkWidget // in

if homogeneous { _arg1 = C.TRUE }
_arg2 = (C.gint)(spacing)

_cret = C.gtk_vbox_new(_arg1, _arg2)


var _vBox VBox // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_vBox = VBox{
Box: Box{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _vBox
}
	

	


	
	type VButtonBox struct {
		ButtonBox
		Buildable
		Orientable
		
	}

	// VButtonBoxClass is an interface that the VButtonBox class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type VButtonBoxClass interface {
		gextras.Objector
		_vButtonBox()
	}

	func (VButtonBox) _vButtonBox() {}

	
	func marshalVButtonBox(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapVButtonBox(obj), nil
	}
	

	
	// NewVButtonBox creates a new vertical button box.
	func NewVButtonBox() VButtonBox {
var _cret *C.GtkWidget // in

_cret = C.gtk_vbutton_box_new()


var _vButtonBox VButtonBox // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_vButtonBox = VButtonBox{
ButtonBox: ButtonBox{
Box: Box{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _vButtonBox
}
	

	


	// VPaned: the VPaned widget is a container widget with two children arranged
// vertically. The division between the two panes is adjustable by the user by
// dragging a handle. See Paned for details.
// 
// GtkVPaned has been deprecated, use Paned instead.
	type VPaned struct {
		Paned
		Buildable
		Orientable
		
	}

	// VPanedClass is an interface that the VPaned class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type VPanedClass interface {
		gextras.Objector
		_vPaned()
	}

	func (VPaned) _vPaned() {}

	
	func marshalVPaned(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapVPaned(obj), nil
	}
	

	
	// NewVPaned: create a new VPaned
	func NewVPaned() VPaned {
var _cret *C.GtkWidget // in

_cret = C.gtk_vpaned_new()


var _vPaned VPaned // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_vPaned = VPaned{
Paned: Paned{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _vPaned
}
	

	


	// VScale: the VScale widget is used to allow the user to select a value using a
// vertical slider. To create one, use gtk_hscale_new_with_range().
// 
// The position to show the current value, and the number of decimal places
// shown can be set using the parent Scale class’s functions.
// 
// GtkVScale has been deprecated, use Scale instead.
	type VScale struct {
		Scale
		Buildable
		Orientable
		
	}

	// VScaleClass is an interface that the VScale class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type VScaleClass interface {
		gextras.Objector
		_vScale()
	}

	func (VScale) _vScale() {}

	
	func marshalVScale(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapVScale(obj), nil
	}
	

	
	// NewVScale creates a new VScale.
	func NewVScale(adjustment AdjustmentClass) VScale {
var _arg1 *C.GtkAdjustment // out
var _cret *C.GtkWidget // in

_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(adjustment.Native()))

_cret = C.gtk_vscale_new(_arg1)


var _vScale VScale // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_vScale = VScale{
Scale: Scale{
Range: Range{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _vScale
}
	
	// NewVScaleWithRange creates a new vertical scale widget that lets the user
// input a number between @min and @max (including @min and @max) with the
// increment @step. @step must be nonzero; it’s the distance the slider moves
// when using the arrow keys to adjust the scale value.
// 
// Note that the way in which the precision is derived works best if @step is a
// power of ten. If the resulting precision is not suitable for your needs, use
// gtk_scale_set_digits() to correct it.
	func NewVScaleWithRange(min float64, max float64, step float64) VScale {
var _arg1 C.gdouble // out
var _arg2 C.gdouble // out
var _arg3 C.gdouble // out
var _cret *C.GtkWidget // in

_arg1 = (C.gdouble)(min)
_arg2 = (C.gdouble)(max)
_arg3 = (C.gdouble)(step)

_cret = C.gtk_vscale_new_with_range(_arg1, _arg2, _arg3)


var _vScale VScale // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_vScale = VScale{
Scale: Scale{
Range: Range{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _vScale
}
	

	


	// VScrollbar: the VScrollbar widget is a widget arranged vertically creating a
// scrollbar. See Scrollbar for details on scrollbars. Adjustment pointers may
// be added to handle the adjustment of the scrollbar or it may be left nil in
// which case one will be created for you. See Scrollbar for a description of
// what the fields in an adjustment represent for a scrollbar.
// 
// GtkVScrollbar has been deprecated, use Scrollbar instead.
	type VScrollbar struct {
		Scrollbar
		Buildable
		Orientable
		
	}

	// VScrollbarClass is an interface that the VScrollbar class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type VScrollbarClass interface {
		gextras.Objector
		_vScrollbar()
	}

	func (VScrollbar) _vScrollbar() {}

	
	func marshalVScrollbar(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapVScrollbar(obj), nil
	}
	

	
	// NewVScrollbar creates a new vertical scrollbar.
	func NewVScrollbar(adjustment AdjustmentClass) VScrollbar {
var _arg1 *C.GtkAdjustment // out
var _cret *C.GtkWidget // in

_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(adjustment.Native()))

_cret = C.gtk_vscrollbar_new(_arg1)


var _vScrollbar VScrollbar // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_vScrollbar = VScrollbar{
Scrollbar: Scrollbar{
Range: Range{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _vScrollbar
}
	

	


	// VSeparator: the VSeparator widget is a vertical separator, used to group the
// widgets within a window. It displays a vertical line with a shadow to make it
// appear sunken into the interface.
// 
// GtkVSeparator has been deprecated, use Separator instead.
	type VSeparator struct {
		Separator
		Buildable
		Orientable
		
	}

	// VSeparatorClass is an interface that the VSeparator class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type VSeparatorClass interface {
		gextras.Objector
		_vSeparator()
	}

	func (VSeparator) _vSeparator() {}

	
	func marshalVSeparator(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapVSeparator(obj), nil
	}
	

	
	// NewVSeparator creates a new VSeparator.
	func NewVSeparator() VSeparator {
var _cret *C.GtkWidget // in

_cret = C.gtk_vseparator_new()


var _vSeparator VSeparator // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_vSeparator = VSeparator{
Separator: Separator{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _vSeparator
}
	

	


	// Viewport: the Viewport widget acts as an adaptor class, implementing
// scrollability for child widgets that lack their own scrolling capabilities.
// Use GtkViewport to scroll child widgets such as Grid, Box, and so on.
// 
// If a widget has native scrolling abilities, such as TextView, TreeView or
// IconView, it can be added to a ScrolledWindow with gtk_container_add(). If a
// widget does not, you must first add the widget to a Viewport, then add the
// viewport to the scrolled window. gtk_container_add() does this automatically
// if a child that does not implement Scrollable is added to a ScrolledWindow,
// so you can ignore the presence of the viewport.
// 
// The GtkViewport will start scrolling content only if allocated less than the
// child widget’s minimum size in a given orientation.
// 
// 
// CSS nodes
// 
// GtkViewport has a single CSS node with name viewport.
	type Viewport struct {
		Bin
		Buildable
		Scrollable
		
	}

	// ViewportClass is an interface that the Viewport class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ViewportClass interface {
		gextras.Objector
		_viewport()
	}

	func (Viewport) _viewport() {}

	
	func marshalViewport(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapViewport(obj), nil
	}
	

	
	// NewViewport creates a new Viewport with the given adjustments, or with
// default adjustments if none are given.
	func NewViewport(hadjustment AdjustmentClass, vadjustment AdjustmentClass) Viewport {
var _arg1 *C.GtkAdjustment // out
var _arg2 *C.GtkAdjustment // out
var _cret *C.GtkWidget // in

_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(hadjustment.Native()))
_arg2 = (*C.GtkAdjustment)(unsafe.Pointer(vadjustment.Native()))

_cret = C.gtk_viewport_new(_arg1, _arg2)


var _viewport Viewport // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_viewport = Viewport{
Bin: Bin{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Scrollable: Scrollable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _viewport
}
	

	
	// BinWindow gets the bin window of the Viewport.
	func (v Viewport) BinWindow() gdk.Window {
var _arg0 *C.GtkViewport // out
var _cret *C.GdkWindow // in

_arg0 = (*C.GtkViewport)(unsafe.Pointer(v.Native()))

_cret = C.gtk_viewport_get_bin_window(_arg0)


var _window gdk.Window // out

_window = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Window)

return _window
}
	
	// HAdjustment returns the horizontal adjustment of the viewport.
	func (v Viewport) HAdjustment() Adjustment {
var _arg0 *C.GtkViewport // out
var _cret *C.GtkAdjustment // in

_arg0 = (*C.GtkViewport)(unsafe.Pointer(v.Native()))

_cret = C.gtk_viewport_get_hadjustment(_arg0)


var _adjustment Adjustment // out

_adjustment = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Adjustment)

return _adjustment
}
	
	// ShadowType gets the shadow type of the Viewport. See
// gtk_viewport_set_shadow_type().
	func (v Viewport) ShadowType() ShadowType {
var _arg0 *C.GtkViewport // out
var _cret C.GtkShadowType // in

_arg0 = (*C.GtkViewport)(unsafe.Pointer(v.Native()))

_cret = C.gtk_viewport_get_shadow_type(_arg0)


var _shadowType ShadowType // out

_shadowType = ShadowType(_cret)

return _shadowType
}
	
	// VAdjustment returns the vertical adjustment of the viewport.
	func (v Viewport) VAdjustment() Adjustment {
var _arg0 *C.GtkViewport // out
var _cret *C.GtkAdjustment // in

_arg0 = (*C.GtkViewport)(unsafe.Pointer(v.Native()))

_cret = C.gtk_viewport_get_vadjustment(_arg0)


var _adjustment Adjustment // out

_adjustment = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Adjustment)

return _adjustment
}
	
	// ViewWindow gets the view window of the Viewport.
	func (v Viewport) ViewWindow() gdk.Window {
var _arg0 *C.GtkViewport // out
var _cret *C.GdkWindow // in

_arg0 = (*C.GtkViewport)(unsafe.Pointer(v.Native()))

_cret = C.gtk_viewport_get_view_window(_arg0)


var _window gdk.Window // out

_window = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Window)

return _window
}
	
	// SetHAdjustment sets the horizontal adjustment of the viewport.
	func (v Viewport) SetHAdjustment(adjustment AdjustmentClass)  {
var _arg0 *C.GtkViewport // out
var _arg1 *C.GtkAdjustment // out

_arg0 = (*C.GtkViewport)(unsafe.Pointer(v.Native()))
_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(adjustment.Native()))

C.gtk_viewport_set_hadjustment(_arg0, _arg1)
}
	
	// SetShadowType sets the shadow type of the viewport.
	func (v Viewport) SetShadowType(typ ShadowType)  {
var _arg0 *C.GtkViewport // out
var _arg1 C.GtkShadowType // out

_arg0 = (*C.GtkViewport)(unsafe.Pointer(v.Native()))
_arg1 = (C.GtkShadowType)(typ)

C.gtk_viewport_set_shadow_type(_arg0, _arg1)
}
	
	// SetVAdjustment sets the vertical adjustment of the viewport.
	func (v Viewport) SetVAdjustment(adjustment AdjustmentClass)  {
var _arg0 *C.GtkViewport // out
var _arg1 *C.GtkAdjustment // out

_arg0 = (*C.GtkViewport)(unsafe.Pointer(v.Native()))
_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(adjustment.Native()))

C.gtk_viewport_set_vadjustment(_arg0, _arg1)
}
	


	// VolumeButton is a subclass of ScaleButton that has been tailored for use as a
// volume control widget with suitable icons, tooltips and accessible labels.
	type VolumeButton struct {
		ScaleButton
		Actionable
		Activatable
		Buildable
		Orientable
		
	}

	// VolumeButtonClass is an interface that the VolumeButton class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type VolumeButtonClass interface {
		gextras.Objector
		_volumeButton()
	}

	func (VolumeButton) _volumeButton() {}

	
	func marshalVolumeButton(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapVolumeButton(obj), nil
	}
	

	
	// NewVolumeButton creates a VolumeButton, with a range between 0.0 and 1.0,
// with a stepping of 0.02. Volume values can be obtained and modified using the
// functions from ScaleButton.
	func NewVolumeButton() VolumeButton {
var _cret *C.GtkWidget // in

_cret = C.gtk_volume_button_new()


var _volumeButton VolumeButton // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_volumeButton = VolumeButton{
ScaleButton: ScaleButton{
Button: Button{
Bin: Bin{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Activatable: Activatable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _volumeButton
}
	

	


	// Widget: gtkWidget is the base class all widgets in GTK+ derive from. It
// manages the widget lifecycle, states and style.
// 
// 
// Height-for-width Geometry Management
// 
// GTK+ uses a height-for-width (and width-for-height) geometry management
// system. Height-for-width means that a widget can change how much vertical
// space it needs, depending on the amount of horizontal space that it is given
// (and similar for width-for-height). The most common example is a label that
// reflows to fill up the available width, wraps to fewer lines, and therefore
// needs less height.
// 
// Height-for-width geometry management is implemented in GTK+ by way of five
// virtual methods:
// 
// - WidgetClass.get_request_mode() - WidgetClass.get_preferred_width() -
// WidgetClass.get_preferred_height() -
// WidgetClass.get_preferred_height_for_width() -
// WidgetClass.get_preferred_width_for_height() -
// WidgetClass.get_preferred_height_and_baseline_for_width()
// 
// There are some important things to keep in mind when implementing
// height-for-width and when using it in container implementations.
// 
// The geometry management system will query a widget hierarchy in only one
// orientation at a time. When widgets are initially queried for their minimum
// sizes it is generally done in two initial passes in the SizeRequestMode
// chosen by the toplevel.
// 
// For example, when queried in the normal GTK_SIZE_REQUEST_HEIGHT_FOR_WIDTH
// mode: First, the default minimum and natural width for each widget in the
// interface will be computed using gtk_widget_get_preferred_width(). Because
// the preferred widths for each container depend on the preferred widths of
// their children, this information propagates up the hierarchy, and finally a
// minimum and natural width is determined for the entire toplevel. Next, the
// toplevel will use the minimum width to query for the minimum height
// contextual to that width using gtk_widget_get_preferred_height_for_width(),
// which will also be a highly recursive operation. The minimum height for the
// minimum width is normally used to set the minimum size constraint on the
// toplevel (unless gtk_window_set_geometry_hints() is explicitly used instead).
// 
// After the toplevel window has initially requested its size in both dimensions
// it can go on to allocate itself a reasonable size (or a size previously
// specified with gtk_window_set_default_size()). During the recursive
// allocation process it’s important to note that request cycles will be
// recursively executed while container widgets allocate their children. Each
// container widget, once allocated a size, will go on to first share the space
// in one orientation among its children and then request each child's height
// for its target allocated width or its width for allocated height, depending.
// In this way a Widget will typically be requested its size a number of times
// before actually being allocated a size. The size a widget is finally
// allocated can of course differ from the size it has requested. For this
// reason, Widget caches a small number of results to avoid re-querying for the
// same sizes in one allocation cycle.
// 
// See [GtkContainer’s geometry management
// section][container-geometry-management] to learn more about how
// height-for-width allocations are performed by container widgets.
// 
// If a widget does move content around to intelligently use up the allocated
// size then it must support the request in both SizeRequestModes even if the
// widget in question only trades sizes in a single orientation.
// 
// For instance, a Label that does height-for-width word wrapping will not
// expect to have WidgetClass.get_preferred_height() called because that call is
// specific to a width-for-height request. In this case the label must return
// the height required for its own minimum possible width. By following this
// rule any widget that handles height-for-width or width-for-height requests
// will always be allocated at least enough space to fit its own content.
// 
// Here are some examples of how a GTK_SIZE_REQUEST_HEIGHT_FOR_WIDTH widget
// generally deals with width-for-height requests, for
// WidgetClass.get_preferred_height() it will do:
// 
//    // the signal handler has the instance and user data swapped
//    // because of the swapped="yes" attribute in the template XML
//    static void
//    hello_button_clicked (FooWidget *self,
//                          GtkButton *button)
//    {
//      g_print ("Hello, world!\n");
//    }
// 
//    static void
//    foo_widget_class_init (FooWidgetClass *klass)
//    {
//      // ...
//      gtk_widget_class_set_template_from_resource (GTK_WIDGET_CLASS (klass),
//                                                   "/com/example/ui/foowidget.ui");
//      gtk_widget_class_bind_template_callback (GTK_WIDGET_CLASS (klass), hello_button_clicked);
//    }
	type Widget struct {
		externglib.InitiallyUnowned
		Buildable
		
	}

	// WidgetClass is an interface that the Widget class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type WidgetClass interface {
		gextras.Objector
		_widget()
	}

	func (Widget) _widget() {}

	
	func marshalWidget(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapWidget(obj), nil
	}
	

	

	
	// Activate: for widgets that can be “activated” (buttons, menu items, etc.)
// this function activates them. Activation is what happens when you press Enter
// on a widget during key navigation. If @widget isn't activatable, the function
// returns false.
	func (w Widget) Activate() bool {
var _arg0 *C.GtkWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_activate(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// AddAccelerator installs an accelerator for this @widget in @accel_group that
// causes @accel_signal to be emitted if the accelerator is activated. The
// @accel_group needs to be added to the widget’s toplevel via
// gtk_window_add_accel_group(), and the signal must be of type G_SIGNAL_ACTION.
// Accelerators added through this function are not user changeable during
// runtime. If you want to support accelerators that can be changed by the user,
// use gtk_accel_map_add_entry() and gtk_widget_set_accel_path() or
// gtk_menu_item_set_accel_path() instead.
	func (w Widget) AddAccelerator(accelSignal string, accelGroup AccelGroupClass, accelKey uint, accelMods gdk.ModifierType, accelFlags AccelFlags)  {
var _arg0 *C.GtkWidget // out
var _arg1 *C.gchar // out
var _arg2 *C.GtkAccelGroup // out
var _arg3 C.guint // out
var _arg4 C.GdkModifierType // out
var _arg5 C.GtkAccelFlags // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (*C.gchar)(C.CString(accelSignal))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.GtkAccelGroup)(unsafe.Pointer(accelGroup.Native()))
_arg3 = (C.guint)(accelKey)
_arg4 = (C.GdkModifierType)(accelMods)
_arg5 = (C.GtkAccelFlags)(accelFlags)

C.gtk_widget_add_accelerator(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
}
	
	// AddDeviceEvents adds the device events in the bitfield @events to the event
// mask for @widget. See gtk_widget_set_device_events() for details.
	func (w Widget) AddDeviceEvents(device gdk.DeviceClass, events gdk.EventMask)  {
var _arg0 *C.GtkWidget // out
var _arg1 *C.GdkDevice // out
var _arg2 C.GdkEventMask // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (*C.GdkDevice)(unsafe.Pointer(device.Native()))
_arg2 = (C.GdkEventMask)(events)

C.gtk_widget_add_device_events(_arg0, _arg1, _arg2)
}
	
	// AddEvents adds the events in the bitfield @events to the event mask for
// @widget. See gtk_widget_set_events() and the [input handling
// overview][event-masks] for details.
	func (w Widget) AddEvents(events int)  {
var _arg0 *C.GtkWidget // out
var _arg1 C.gint // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (C.gint)(events)

C.gtk_widget_add_events(_arg0, _arg1)
}
	
	// AddMnemonicLabel adds a widget to the list of mnemonic labels for this
// widget. (See gtk_widget_list_mnemonic_labels()). Note the list of mnemonic
// labels for the widget is cleared when the widget is destroyed, so the caller
// must make sure to update its internal state at this point as well, by using a
// connection to the Widget::destroy signal or a weak notifier.
	func (w Widget) AddMnemonicLabel(label WidgetClass)  {
var _arg0 *C.GtkWidget // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(label.Native()))

C.gtk_widget_add_mnemonic_label(_arg0, _arg1)
}
	
	// CanActivateAccel determines whether an accelerator that activates the signal
// identified by @signal_id can currently be activated. This is done by emitting
// the Widget::can-activate-accel signal on @widget; if the signal isn’t
// overridden by a handler or in a derived widget, then the default check is
// that the widget must be sensitive, and the widget and all its ancestors
// mapped.
	func (w Widget) CanActivateAccel(signalId uint) bool {
var _arg0 *C.GtkWidget // out
var _arg1 C.guint // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (C.guint)(signalId)

_cret = C.gtk_widget_can_activate_accel(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ChildFocus: this function is used by custom widget implementations; if you're
// writing an app, you’d use gtk_widget_grab_focus() to move the focus to a
// particular widget, and gtk_container_set_focus_chain() to change the focus
// tab order. So you may want to investigate those functions instead.
// 
// gtk_widget_child_focus() is called by containers as the user moves around the
// window using keyboard shortcuts. @direction indicates what kind of motion is
// taking place (up, down, left, right, tab forward, tab backward).
// gtk_widget_child_focus() emits the Widget::focus signal; widgets override the
// default handler for this signal in order to implement appropriate focus
// behavior.
// 
// The default ::focus handler for a widget should return true if moving in
// @direction left the focus on a focusable location inside that widget, and
// false if moving in @direction moved the focus outside the widget. If
// returning true, widgets normally call gtk_widget_grab_focus() to place the
// focus accordingly; if returning false, they don’t modify the current focus
// location.
	func (w Widget) ChildFocus(direction DirectionType) bool {
var _arg0 *C.GtkWidget // out
var _arg1 C.GtkDirectionType // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (C.GtkDirectionType)(direction)

_cret = C.gtk_widget_child_focus(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ChildNotify emits a Widget::child-notify signal for the [child
// property][child-properties] @child_property on @widget.
// 
// This is the analogue of g_object_notify() for child properties.
// 
// Also see gtk_container_child_notify().
	func (w Widget) ChildNotify(childProperty string)  {
var _arg0 *C.GtkWidget // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (*C.gchar)(C.CString(childProperty))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_widget_child_notify(_arg0, _arg1)
}
	
	// ClassPath: same as gtk_widget_path(), but always uses the name of a widget’s
// type, never uses a custom name set with gtk_widget_set_name().
	func (w Widget) ClassPath() (pathLength uint, path string, pathReversed string) {
var _arg0 *C.GtkWidget // out
var _arg1 C.guint // in
var _arg2 *C.gchar // in
var _arg3 *C.gchar // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

C.gtk_widget_class_path(_arg0, &_arg1, &_arg2, &_arg3)

var _pathLength uint // out
var _path string // out
var _pathReversed string // out

_pathLength = (uint)(_arg1)
_path = C.GoString(_arg2)
defer C.free(unsafe.Pointer(_arg2))
_pathReversed = C.GoString(_arg3)
defer C.free(unsafe.Pointer(_arg3))

return _pathLength, _path, _pathReversed
}
	
	// ComputeExpand computes whether a container should give this widget extra
// space when possible. Containers should check this, rather than looking at
// gtk_widget_get_hexpand() or gtk_widget_get_vexpand().
// 
// This function already checks whether the widget is visible, so visibility
// does not need to be checked separately. Non-visible widgets are not expanded.
// 
// The computed expand value uses either the expand setting explicitly set on
// the widget itself, or, if none has been explicitly set, the widget may expand
// if some of its children do.
	func (w Widget) ComputeExpand(orientation Orientation) bool {
var _arg0 *C.GtkWidget // out
var _arg1 C.GtkOrientation // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (C.GtkOrientation)(orientation)

_cret = C.gtk_widget_compute_expand(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// CreatePangoContext creates a new Context with the appropriate font map, font
// options, font description, and base direction for drawing text for this
// widget. See also gtk_widget_get_pango_context().
	func (w Widget) CreatePangoContext() pango.Context {
var _arg0 *C.GtkWidget // out
var _cret *C.PangoContext // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_create_pango_context(_arg0)


var _context pango.Context // out

_context = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(pango.Context)

return _context
}
	
	// CreatePangoLayout creates a new Layout with the appropriate font map, font
// description, and base direction for drawing text for this widget.
// 
// If you keep a Layout created in this way around, you need to re-create it
// when the widget Context is replaced. This can be tracked by using the
// Widget::screen-changed signal on the widget.
	func (w Widget) CreatePangoLayout(text string) pango.Layout {
var _arg0 *C.GtkWidget // out
var _arg1 *C.gchar // out
var _cret *C.PangoLayout // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (*C.gchar)(C.CString(text))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_widget_create_pango_layout(_arg0, _arg1)


var _layout pango.Layout // out

_layout = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(pango.Layout)

return _layout
}
	
	// Destroy destroys a widget.
// 
// When a widget is destroyed all references it holds on other objects will be
// released:
// 
//    - if the widget is inside a container, it will be removed from its
//    parent
//    - if the widget is a container, all its children will be destroyed,
//    recursively
//    - if the widget is a top level, it will be removed from the list
//    of top level widgets that GTK+ maintains internally
// 
// It's expected that all references held on the widget will also be released;
// you should connect to the Widget::destroy signal if you hold a reference to
// @widget and you wish to remove it when this function is called. It is not
// necessary to do so if you are implementing a Container, as you'll be able to
// use the ContainerClass.remove() virtual function for that.
// 
// It's important to notice that gtk_widget_destroy() will only cause the
// @widget to be finalized if no additional references, acquired using
// g_object_ref(), are held on it. In case additional references are in place,
// the @widget will be in an "inert" state after calling this function; @widget
// will still point to valid memory, allowing you to release the references you
// hold, but you may not query the widget's own state.
// 
// You should typically call this function on top level widgets, and rarely on
// child widgets.
// 
// See also: gtk_container_remove()
	func (w Widget) Destroy()  {
var _arg0 *C.GtkWidget // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

C.gtk_widget_destroy(_arg0)
}
	
	// DeviceIsShadowed returns true if @device has been shadowed by a GTK+ device
// grab on another widget, so it would stop sending events to @widget. This may
// be used in the Widget::grab-notify signal to check for specific devices. See
// gtk_device_grab_add().
	func (w Widget) DeviceIsShadowed(device gdk.DeviceClass) bool {
var _arg0 *C.GtkWidget // out
var _arg1 *C.GdkDevice // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (*C.GdkDevice)(unsafe.Pointer(device.Native()))

_cret = C.gtk_widget_device_is_shadowed(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// DragCheckThreshold checks to see if a mouse drag starting at (@start_x,
// @start_y) and ending at (@current_x, @current_y) has passed the GTK+ drag
// threshold, and thus should trigger the beginning of a drag-and-drop
// operation.
	func (w Widget) DragCheckThreshold(startX int, startY int, currentX int, currentY int) bool {
var _arg0 *C.GtkWidget // out
var _arg1 C.gint // out
var _arg2 C.gint // out
var _arg3 C.gint // out
var _arg4 C.gint // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (C.gint)(startX)
_arg2 = (C.gint)(startY)
_arg3 = (C.gint)(currentX)
_arg4 = (C.gint)(currentY)

_cret = C.gtk_drag_check_threshold(_arg0, _arg1, _arg2, _arg3, _arg4)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// DragDestAddImageTargets: add the image targets supported by SelectionData to
// the target list of the drag destination. The targets are added with @info =
// 0. If you need another value, use gtk_target_list_add_image_targets() and
// gtk_drag_dest_set_target_list().
	func (w Widget) DragDestAddImageTargets()  {
var _arg0 *C.GtkWidget // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

C.gtk_drag_dest_add_image_targets(_arg0)
}
	
	// DragDestAddTextTargets: add the text targets supported by SelectionData to
// the target list of the drag destination. The targets are added with @info =
// 0. If you need another value, use gtk_target_list_add_text_targets() and
// gtk_drag_dest_set_target_list().
	func (w Widget) DragDestAddTextTargets()  {
var _arg0 *C.GtkWidget // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

C.gtk_drag_dest_add_text_targets(_arg0)
}
	
	// DragDestAddURITargets: add the URI targets supported by SelectionData to the
// target list of the drag destination. The targets are added with @info = 0. If
// you need another value, use gtk_target_list_add_uri_targets() and
// gtk_drag_dest_set_target_list().
	func (w Widget) DragDestAddURITargets()  {
var _arg0 *C.GtkWidget // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

C.gtk_drag_dest_add_uri_targets(_arg0)
}
	
	// DragDestFindTarget looks for a match between the supported targets of
// @context and the @dest_target_list, returning the first matching target,
// otherwise returning GDK_NONE. @dest_target_list should usually be the return
// value from gtk_drag_dest_get_target_list(), but some widgets may have
// different valid targets for different parts of the widget; in that case, they
// will have to implement a drag_motion handler that passes the correct target
// list to this function.
	func (w Widget) DragDestFindTarget(context gdk.DragContextClass, targetList *TargetList) *gdk.Atom {
var _arg0 *C.GtkWidget // out
var _arg1 *C.GdkDragContext // out
var _arg2 *C.GtkTargetList // out
var _cret C.GdkAtom // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (*C.GdkDragContext)(unsafe.Pointer(context.Native()))
_arg2 = (*C.GtkTargetList)(unsafe.Pointer(targetList.Native()))

_cret = C.gtk_drag_dest_find_target(_arg0, _arg1, _arg2)


var _atom *gdk.Atom // out

_atom = *(**gdk.Atom)(unsafe.Pointer(&_cret))

return _atom
}
	
	// DragDestGetTargetList returns the list of targets this widget can accept from
// drag-and-drop.
	func (w Widget) DragDestGetTargetList() *TargetList {
var _arg0 *C.GtkWidget // out
var _cret *C.GtkTargetList // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_drag_dest_get_target_list(_arg0)


var _targetList *TargetList // out

_targetList = *(**TargetList)(unsafe.Pointer(&_cret))

return _targetList
}
	
	// DragDestGetTrackMotion returns whether the widget has been configured to
// always emit Widget::drag-motion signals.
	func (w Widget) DragDestGetTrackMotion() bool {
var _arg0 *C.GtkWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_drag_dest_get_track_motion(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// DragDestSet sets a widget as a potential drop destination, and adds default
// behaviors.
// 
// The default behaviors listed in @flags have an effect similar to installing
// default handlers for the widget’s drag-and-drop signals (Widget::drag-motion,
// Widget::drag-drop, ...). They all exist for convenience. When passing
// K_DEST_DEFAULT_ALL for instance it is sufficient to connect to the widget’s
// Widget::drag-data-received signal to get primitive, but consistent
// drag-and-drop support.
// 
// Things become more complicated when you try to preview the dragged data, as
// described in the documentation for Widget::drag-motion. The default behaviors
// described by @flags make some assumptions, that can conflict with your own
// signal handlers. For instance K_DEST_DEFAULT_DROP causes invokations of
// gdk_drag_status() in the context of Widget::drag-motion, and invokations of
// gtk_drag_finish() in Widget::drag-data-received. Especially the later is
// dramatic, when your own Widget::drag-motion handler calls gtk_drag_get_data()
// to inspect the dragged data.
// 
// There’s no way to set a default action here, you can use the
// Widget::drag-motion callback for that. Here’s an example which selects the
// action to use depending on whether the control key is pressed or not:
// 
//    static void
//    drag_motion (GtkWidget *widget,
//                 GdkDragContext *context,
//                 gint x,
//                 gint y,
//                 guint time)
//    {
//      GdkModifierType mask;
// 
//      gdk_window_get_pointer (gtk_widget_get_window (widget),
//                              NULL, NULL, &mask);
//      if (mask & GDK_CONTROL_MASK)
//        gdk_drag_status (context, GDK_ACTION_COPY, time);
//      else
//        gdk_drag_status (context, GDK_ACTION_MOVE, time);
//    }
	func (w Widget) DragDestSet(flags DestDefaults, targets []TargetEntry, actions gdk.DragAction)  {
var _arg0 *C.GtkWidget // out
var _arg1 C.GtkDestDefaults // out
var _arg2 *C.GtkTargetEntry
var _arg3 C.gint
var _arg4 C.GdkDragAction // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (C.GtkDestDefaults)(flags)
_arg3 = C.gint(len(targets))
_arg2 = (*C.GtkTargetEntry)(unsafe.Pointer(&targets[0]))
_arg4 = (C.GdkDragAction)(actions)

C.gtk_drag_dest_set(_arg0, _arg1, _arg2, _arg3, _arg4)
}
	
	// DragDestSetProXY sets this widget as a proxy for drops to another window.
	func (w Widget) DragDestSetProXY(proxyWindow gdk.WindowClass, protocol gdk.DragProtocol, useCoordinates bool)  {
var _arg0 *C.GtkWidget // out
var _arg1 *C.GdkWindow // out
var _arg2 C.GdkDragProtocol // out
var _arg3 C.gboolean // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (*C.GdkWindow)(unsafe.Pointer(proxyWindow.Native()))
_arg2 = (C.GdkDragProtocol)(protocol)
if useCoordinates { _arg3 = C.TRUE }

C.gtk_drag_dest_set_proxy(_arg0, _arg1, _arg2, _arg3)
}
	
	// DragDestSetTargetList sets the target types that this widget can accept from
// drag-and-drop. The widget must first be made into a drag destination with
// gtk_drag_dest_set().
	func (w Widget) DragDestSetTargetList(targetList *TargetList)  {
var _arg0 *C.GtkWidget // out
var _arg1 *C.GtkTargetList // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (*C.GtkTargetList)(unsafe.Pointer(targetList.Native()))

C.gtk_drag_dest_set_target_list(_arg0, _arg1)
}
	
	// DragDestSetTrackMotion tells the widget to emit Widget::drag-motion and
// Widget::drag-leave events regardless of the targets and the
// GTK_DEST_DEFAULT_MOTION flag.
// 
// This may be used when a widget wants to do generic actions regardless of the
// targets that the source offers.
	func (w Widget) DragDestSetTrackMotion(trackMotion bool)  {
var _arg0 *C.GtkWidget // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
if trackMotion { _arg1 = C.TRUE }

C.gtk_drag_dest_set_track_motion(_arg0, _arg1)
}
	
	// DragDestUnset clears information about a drop destination set with
// gtk_drag_dest_set(). The widget will no longer receive notification of drags.
	func (w Widget) DragDestUnset()  {
var _arg0 *C.GtkWidget // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

C.gtk_drag_dest_unset(_arg0)
}
	
	// DragGetData gets the data associated with a drag. When the data is received
// or the retrieval fails, GTK+ will emit a Widget::drag-data-received signal.
// Failure of the retrieval is indicated by the length field of the
// @selection_data signal parameter being negative. However, when
// gtk_drag_get_data() is called implicitely because the GTK_DEST_DEFAULT_DROP
// was set, then the widget will not receive notification of failed drops.
	func (w Widget) DragGetData(context gdk.DragContextClass, target *gdk.Atom, time_ uint32)  {
var _arg0 *C.GtkWidget // out
var _arg1 *C.GdkDragContext // out
var _arg2 C.GdkAtom // out
var _arg3 C.guint32 // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (*C.GdkDragContext)(unsafe.Pointer(context.Native()))
_arg2 = (C.GdkAtom)(unsafe.Pointer(target.Native()))
_arg3 = (C.guint32)(time_)

C.gtk_drag_get_data(_arg0, _arg1, _arg2, _arg3)
}
	
	// DragHighlight highlights a widget as a currently hovered drop target. To end
// the highlight, call gtk_drag_unhighlight(). GTK+ calls this automatically if
// GTK_DEST_DEFAULT_HIGHLIGHT is set.
	func (w Widget) DragHighlight()  {
var _arg0 *C.GtkWidget // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

C.gtk_drag_highlight(_arg0)
}
	
	// DragSourceAddImageTargets: add the writable image targets supported by
// SelectionData to the target list of the drag source. The targets are added
// with @info = 0. If you need another value, use
// gtk_target_list_add_image_targets() and gtk_drag_source_set_target_list().
	func (w Widget) DragSourceAddImageTargets()  {
var _arg0 *C.GtkWidget // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

C.gtk_drag_source_add_image_targets(_arg0)
}
	
	// DragSourceAddTextTargets: add the text targets supported by SelectionData to
// the target list of the drag source. The targets are added with @info = 0. If
// you need another value, use gtk_target_list_add_text_targets() and
// gtk_drag_source_set_target_list().
	func (w Widget) DragSourceAddTextTargets()  {
var _arg0 *C.GtkWidget // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

C.gtk_drag_source_add_text_targets(_arg0)
}
	
	// DragSourceAddURITargets: add the URI targets supported by SelectionData to
// the target list of the drag source. The targets are added with @info = 0. If
// you need another value, use gtk_target_list_add_uri_targets() and
// gtk_drag_source_set_target_list().
	func (w Widget) DragSourceAddURITargets()  {
var _arg0 *C.GtkWidget // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

C.gtk_drag_source_add_uri_targets(_arg0)
}
	
	// DragSourceGetTargetList gets the list of targets this widget can provide for
// drag-and-drop.
	func (w Widget) DragSourceGetTargetList() *TargetList {
var _arg0 *C.GtkWidget // out
var _cret *C.GtkTargetList // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_drag_source_get_target_list(_arg0)


var _targetList *TargetList // out

_targetList = *(**TargetList)(unsafe.Pointer(&_cret))

return _targetList
}
	
	// DragSourceSet sets up a widget so that GTK+ will start a drag operation when
// the user clicks and drags on the widget. The widget must have a window.
	func (w Widget) DragSourceSet(startButtonMask gdk.ModifierType, targets []TargetEntry, actions gdk.DragAction)  {
var _arg0 *C.GtkWidget // out
var _arg1 C.GdkModifierType // out
var _arg2 *C.GtkTargetEntry
var _arg3 C.gint
var _arg4 C.GdkDragAction // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (C.GdkModifierType)(startButtonMask)
_arg3 = C.gint(len(targets))
_arg2 = (*C.GtkTargetEntry)(unsafe.Pointer(&targets[0]))
_arg4 = (C.GdkDragAction)(actions)

C.gtk_drag_source_set(_arg0, _arg1, _arg2, _arg3, _arg4)
}
	
	// DragSourceSetIconGIcon sets the icon that will be used for drags from a
// particular source to @icon. See the docs for IconTheme for more details.
	func (w Widget) DragSourceSetIconGIcon(icon gio.Icon)  {
var _arg0 *C.GtkWidget // out
var _arg1 *C.GIcon // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (*C.GIcon)(unsafe.Pointer(icon.Native()))

C.gtk_drag_source_set_icon_gicon(_arg0, _arg1)
}
	
	// DragSourceSetIconName sets the icon that will be used for drags from a
// particular source to a themed icon. See the docs for IconTheme for more
// details.
	func (w Widget) DragSourceSetIconName(iconName string)  {
var _arg0 *C.GtkWidget // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (*C.gchar)(C.CString(iconName))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_drag_source_set_icon_name(_arg0, _arg1)
}
	
	// DragSourceSetIconPixbuf sets the icon that will be used for drags from a
// particular widget from a Pixbuf. GTK+ retains a reference for @pixbuf and
// will release it when it is no longer needed.
	func (w Widget) DragSourceSetIconPixbuf(pixbuf gdkpixbuf.PixbufClass)  {
var _arg0 *C.GtkWidget // out
var _arg1 *C.GdkPixbuf // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))

C.gtk_drag_source_set_icon_pixbuf(_arg0, _arg1)
}
	
	// DragSourceSetIconStock sets the icon that will be used for drags from a
// particular source to a stock icon.
	func (w Widget) DragSourceSetIconStock(stockId string)  {
var _arg0 *C.GtkWidget // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (*C.gchar)(C.CString(stockId))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_drag_source_set_icon_stock(_arg0, _arg1)
}
	
	// DragSourceSetTargetList changes the target types that this widget offers for
// drag-and-drop. The widget must first be made into a drag source with
// gtk_drag_source_set().
	func (w Widget) DragSourceSetTargetList(targetList *TargetList)  {
var _arg0 *C.GtkWidget // out
var _arg1 *C.GtkTargetList // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (*C.GtkTargetList)(unsafe.Pointer(targetList.Native()))

C.gtk_drag_source_set_target_list(_arg0, _arg1)
}
	
	// DragSourceUnset undoes the effects of gtk_drag_source_set().
	func (w Widget) DragSourceUnset()  {
var _arg0 *C.GtkWidget // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

C.gtk_drag_source_unset(_arg0)
}
	
	// DragUnhighlight removes a highlight set by gtk_drag_highlight() from a
// widget.
	func (w Widget) DragUnhighlight()  {
var _arg0 *C.GtkWidget // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

C.gtk_drag_unhighlight(_arg0)
}
	
	// Draw draws @widget to @cr. The top left corner of the widget will be drawn to
// the currently set origin point of @cr.
// 
// You should pass a cairo context as @cr argument that is in an original state.
// Otherwise the resulting drawing is undefined. For example changing the
// operator using cairo_set_operator() or the line width using
// cairo_set_line_width() might have unwanted side effects. You may however
// change the context’s transform matrix - like with cairo_scale(),
// cairo_translate() or cairo_set_matrix() and clip region with cairo_clip()
// prior to calling this function. Also, it is fine to modify the context with
// cairo_save() and cairo_push_group() prior to calling this function.
// 
// Note that special-purpose widgets may contain special code for rendering to
// the screen and might appear differently on screen and when rendered using
// gtk_widget_draw().
	func (w Widget) Draw(cr *cairo.Context)  {
var _arg0 *C.GtkWidget // out
var _arg1 *C.cairo_t // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))

C.gtk_widget_draw(_arg0, _arg1)
}
	
	// EnsureStyle ensures that @widget has a style (@widget->style).
// 
// Not a very useful function; most of the time, if you want the style, the
// widget is realized, and realized widgets are guaranteed to have a style
// already.
	func (w Widget) EnsureStyle()  {
var _arg0 *C.GtkWidget // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

C.gtk_widget_ensure_style(_arg0)
}
	
	// ErrorBell notifies the user about an input-related error on this widget. If
// the Settings:gtk-error-bell setting is true, it calls gdk_window_beep(),
// otherwise it does nothing.
// 
// Note that the effect of gdk_window_beep() can be configured in many ways,
// depending on the windowing backend and the desktop environment or window
// manager that is used.
	func (w Widget) ErrorBell()  {
var _arg0 *C.GtkWidget // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

C.gtk_widget_error_bell(_arg0)
}
	
	// FreezeChildNotify stops emission of Widget::child-notify signals on @widget.
// The signals are queued until gtk_widget_thaw_child_notify() is called on
// @widget.
// 
// This is the analogue of g_object_freeze_notify() for child properties.
	func (w Widget) FreezeChildNotify()  {
var _arg0 *C.GtkWidget // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

C.gtk_widget_freeze_child_notify(_arg0)
}
	
	// ActionGroup retrieves the Group that was registered using @prefix. The
// resulting Group may have been registered to @widget or any Widget in its
// ancestry.
// 
// If no action group was found matching @prefix, then nil is returned.
	func (w Widget) ActionGroup(prefix string) gio.ActionGroup {
var _arg0 *C.GtkWidget // out
var _arg1 *C.gchar // out
var _cret *C.GActionGroup // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (*C.gchar)(C.CString(prefix))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_widget_get_action_group(_arg0, _arg1)


var _actionGroup gio.ActionGroup // out

_actionGroup = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.ActionGroup)

return _actionGroup
}
	
	// AllocatedBaseline returns the baseline that has currently been allocated to
// @widget. This function is intended to be used when implementing handlers for
// the Widget::draw function, and when allocating child widgets in
// Widget::size_allocate.
	func (w Widget) AllocatedBaseline() int {
var _arg0 *C.GtkWidget // out
var _cret C.int // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_allocated_baseline(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// AllocatedHeight returns the height that has currently been allocated to
// @widget. This function is intended to be used when implementing handlers for
// the Widget::draw function.
	func (w Widget) AllocatedHeight() int {
var _arg0 *C.GtkWidget // out
var _cret C.int // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_allocated_height(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// AllocatedWidth returns the width that has currently been allocated to
// @widget. This function is intended to be used when implementing handlers for
// the Widget::draw function.
	func (w Widget) AllocatedWidth() int {
var _arg0 *C.GtkWidget // out
var _cret C.int // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_allocated_width(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Ancestor gets the first ancestor of @widget with type @widget_type. For
// example, `gtk_widget_get_ancestor (widget, GTK_TYPE_BOX)` gets the first Box
// that’s an ancestor of @widget. No reference will be added to the returned
// widget; it should not be unreferenced. See note about checking for a toplevel
// Window in the docs for gtk_widget_get_toplevel().
// 
// Note that unlike gtk_widget_is_ancestor(), gtk_widget_get_ancestor()
// considers @widget to be an ancestor of itself.
	func (w Widget) Ancestor(widgetType externglib.Type) Widget {
var _arg0 *C.GtkWidget // out
var _arg1 C.GType // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = C.GType(widgetType)

_cret = C.gtk_widget_get_ancestor(_arg0, _arg1)


var _ret Widget // out

_ret = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _ret
}
	
	// AppPaintable determines whether the application intends to draw on the widget
// in an Widget::draw handler.
// 
// See gtk_widget_set_app_paintable()
	func (w Widget) AppPaintable() bool {
var _arg0 *C.GtkWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_app_paintable(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// CanDefault determines whether @widget can be a default widget. See
// gtk_widget_set_can_default().
	func (w Widget) CanDefault() bool {
var _arg0 *C.GtkWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_can_default(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// CanFocus determines whether @widget can own the input focus. See
// gtk_widget_set_can_focus().
	func (w Widget) CanFocus() bool {
var _arg0 *C.GtkWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_can_focus(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ChildRequisition: this function is only for use in widget implementations.
// Obtains @widget->requisition, unless someone has forced a particular geometry
// on the widget (e.g. with gtk_widget_set_size_request()), in which case it
// returns that geometry instead of the widget's requisition.
// 
// This function differs from gtk_widget_size_request() in that it retrieves the
// last size request value from @widget->requisition, while
// gtk_widget_size_request() actually calls the "size_request" method on @widget
// to compute the size request and fill in @widget->requisition, and only then
// returns @widget->requisition.
// 
// Because this function does not call the “size_request” method, it can only be
// used when you know that @widget->requisition is up-to-date, that is,
// gtk_widget_size_request() has been called since the last time a resize was
// queued. In general, only container implementations have this information;
// applications should use gtk_widget_size_request().
	func (w Widget) ChildRequisition() Requisition {
var _arg0 *C.GtkWidget // out
var _requisition Requisition

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

C.gtk_widget_get_child_requisition(_arg0, (*C.GtkRequisition)(unsafe.Pointer(&_requisition)))





return _requisition
}
	
	// ChildVisible gets the value set with gtk_widget_set_child_visible(). If you
// feel a need to use this function, your code probably needs reorganization.
// 
// This function is only useful for container implementations and never should
// be called by an application.
	func (w Widget) ChildVisible() bool {
var _arg0 *C.GtkWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_child_visible(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Clipboard returns the clipboard object for the given selection to be used
// with @widget. @widget must have a Display associated with it, so must be
// attached to a toplevel window.
	func (w Widget) Clipboard(selection *gdk.Atom) Clipboard {
var _arg0 *C.GtkWidget // out
var _arg1 C.GdkAtom // out
var _cret *C.GtkClipboard // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (C.GdkAtom)(unsafe.Pointer(selection.Native()))

_cret = C.gtk_widget_get_clipboard(_arg0, _arg1)


var _clipboard Clipboard // out

_clipboard = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Clipboard)

return _clipboard
}
	
	// CompositeName obtains the composite name of a widget.
	func (w Widget) CompositeName() string {
var _arg0 *C.GtkWidget // out
var _cret *C.gchar // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_composite_name(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// DeviceEnabled returns whether @device can interact with @widget and its
// children. See gtk_widget_set_device_enabled().
	func (w Widget) DeviceEnabled(device gdk.DeviceClass) bool {
var _arg0 *C.GtkWidget // out
var _arg1 *C.GdkDevice // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (*C.GdkDevice)(unsafe.Pointer(device.Native()))

_cret = C.gtk_widget_get_device_enabled(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// DeviceEvents returns the events mask for the widget corresponding to an
// specific device. These are the events that the widget will receive when
// @device operates on it.
	func (w Widget) DeviceEvents(device gdk.DeviceClass) gdk.EventMask {
var _arg0 *C.GtkWidget // out
var _arg1 *C.GdkDevice // out
var _cret C.GdkEventMask // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (*C.GdkDevice)(unsafe.Pointer(device.Native()))

_cret = C.gtk_widget_get_device_events(_arg0, _arg1)


var _eventMask gdk.EventMask // out

_eventMask = gdk.EventMask(_cret)

return _eventMask
}
	
	// Direction gets the reading direction for a particular widget. See
// gtk_widget_set_direction().
	func (w Widget) Direction() TextDirection {
var _arg0 *C.GtkWidget // out
var _cret C.GtkTextDirection // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_direction(_arg0)


var _textDirection TextDirection // out

_textDirection = TextDirection(_cret)

return _textDirection
}
	
	// Display: get the Display for the toplevel window associated with this widget.
// This function can only be called after the widget has been added to a widget
// hierarchy with a Window at the top.
// 
// In general, you should only create display specific resources when a widget
// has been realized, and you should free those resources when the widget is
// unrealized.
	func (w Widget) Display() gdk.Display {
var _arg0 *C.GtkWidget // out
var _cret *C.GdkDisplay // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_display(_arg0)


var _display gdk.Display // out

_display = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Display)

return _display
}
	
	// DoubleBuffered determines whether the widget is double buffered.
// 
// See gtk_widget_set_double_buffered()
	func (w Widget) DoubleBuffered() bool {
var _arg0 *C.GtkWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_double_buffered(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Events returns the event mask (see EventMask) for the widget. These are the
// events that the widget will receive.
// 
// Note: Internally, the widget event mask will be the logical OR of the event
// mask set through gtk_widget_set_events() or gtk_widget_add_events(), and the
// event mask necessary to cater for every EventController created for the
// widget.
	func (w Widget) Events() int {
var _arg0 *C.GtkWidget // out
var _cret C.gint // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_events(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// FocusOnClick returns whether the widget should grab focus when it is clicked
// with the mouse. See gtk_widget_set_focus_on_click().
	func (w Widget) FocusOnClick() bool {
var _arg0 *C.GtkWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_focus_on_click(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// FontMap gets the font map that has been set with gtk_widget_set_font_map().
	func (w Widget) FontMap() pango.FontMap {
var _arg0 *C.GtkWidget // out
var _cret *C.PangoFontMap // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_font_map(_arg0)


var _fontMap pango.FontMap // out

_fontMap = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(pango.FontMap)

return _fontMap
}
	
	// FontOptions returns the #cairo_font_options_t used for Pango rendering. When
// not set, the defaults font options for the Screen will be used.
	func (w Widget) FontOptions() *cairo.FontOptions {
var _arg0 *C.GtkWidget // out
var _cret *C.cairo_font_options_t // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_font_options(_arg0)


var _fontOptions *cairo.FontOptions // out

_fontOptions = *(**cairo.FontOptions)(unsafe.Pointer(&_cret))

return _fontOptions
}
	
	// FrameClock obtains the frame clock for a widget. The frame clock is a global
// “ticker” that can be used to drive animations and repaints. The most common
// reason to get the frame clock is to call gdk_frame_clock_get_frame_time(), in
// order to get a time to use for animating. For example you might record the
// start of the animation with an initial value from
// gdk_frame_clock_get_frame_time(), and then update the animation by calling
// gdk_frame_clock_get_frame_time() again during each repaint.
// 
// gdk_frame_clock_request_phase() will result in a new frame on the clock, but
// won’t necessarily repaint any widgets. To repaint a widget, you have to use
// gtk_widget_queue_draw() which invalidates the widget (thus scheduling it to
// receive a draw on the next frame). gtk_widget_queue_draw() will also end up
// requesting a frame on the appropriate frame clock.
// 
// A widget’s frame clock will not change while the widget is mapped.
// Reparenting a widget (which implies a temporary unmap) can change the
// widget’s frame clock.
// 
// Unrealized widgets do not have a frame clock.
	func (w Widget) FrameClock() gdk.FrameClock {
var _arg0 *C.GtkWidget // out
var _cret *C.GdkFrameClock // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_frame_clock(_arg0)


var _frameClock gdk.FrameClock // out

_frameClock = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.FrameClock)

return _frameClock
}
	
	// Halign gets the value of the Widget:halign property.
// 
// For backwards compatibility reasons this method will never return
// GTK_ALIGN_BASELINE, but instead it will convert it to GTK_ALIGN_FILL.
// Baselines are not supported for horizontal alignment.
	func (w Widget) Halign() Align {
var _arg0 *C.GtkWidget // out
var _cret C.GtkAlign // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_halign(_arg0)


var _align Align // out

_align = Align(_cret)

return _align
}
	
	// HasTooltip returns the current value of the has-tooltip property. See
// Widget:has-tooltip for more information.
	func (w Widget) HasTooltip() bool {
var _arg0 *C.GtkWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_has_tooltip(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// HasWindow determines whether @widget has a Window of its own. See
// gtk_widget_set_has_window().
	func (w Widget) HasWindow() bool {
var _arg0 *C.GtkWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_has_window(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Hexpand gets whether the widget would like any available extra horizontal
// space. When a user resizes a Window, widgets with expand=TRUE generally
// receive the extra space. For example, a list or scrollable area or document
// in your window would often be set to expand.
// 
// Containers should use gtk_widget_compute_expand() rather than this function,
// to see whether a widget, or any of its children, has the expand flag set. If
// any child of a widget wants to expand, the parent may ask to expand also.
// 
// This function only looks at the widget’s own hexpand flag, rather than
// computing whether the entire widget tree rooted at this widget wants to
// expand.
	func (w Widget) Hexpand() bool {
var _arg0 *C.GtkWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_hexpand(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// HexpandSet gets whether gtk_widget_set_hexpand() has been used to explicitly
// set the expand flag on this widget.
// 
// If hexpand is set, then it overrides any computed expand value based on child
// widgets. If hexpand is not set, then the expand value depends on whether any
// children of the widget would like to expand.
// 
// There are few reasons to use this function, but it’s here for completeness
// and consistency.
	func (w Widget) HexpandSet() bool {
var _arg0 *C.GtkWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_hexpand_set(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Mapped: whether the widget is mapped.
	func (w Widget) Mapped() bool {
var _arg0 *C.GtkWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_mapped(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// MarginBottom gets the value of the Widget:margin-bottom property.
	func (w Widget) MarginBottom() int {
var _arg0 *C.GtkWidget // out
var _cret C.gint // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_margin_bottom(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// MarginEnd gets the value of the Widget:margin-end property.
	func (w Widget) MarginEnd() int {
var _arg0 *C.GtkWidget // out
var _cret C.gint // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_margin_end(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// MarginLeft gets the value of the Widget:margin-left property.
	func (w Widget) MarginLeft() int {
var _arg0 *C.GtkWidget // out
var _cret C.gint // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_margin_left(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// MarginRight gets the value of the Widget:margin-right property.
	func (w Widget) MarginRight() int {
var _arg0 *C.GtkWidget // out
var _cret C.gint // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_margin_right(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// MarginStart gets the value of the Widget:margin-start property.
	func (w Widget) MarginStart() int {
var _arg0 *C.GtkWidget // out
var _cret C.gint // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_margin_start(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// MarginTop gets the value of the Widget:margin-top property.
	func (w Widget) MarginTop() int {
var _arg0 *C.GtkWidget // out
var _cret C.gint // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_margin_top(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// ModifierMask returns the modifier mask the @widget’s windowing system backend
// uses for a particular purpose.
// 
// See gdk_keymap_get_modifier_mask().
	func (w Widget) ModifierMask(intent gdk.ModifierIntent) gdk.ModifierType {
var _arg0 *C.GtkWidget // out
var _arg1 C.GdkModifierIntent // out
var _cret C.GdkModifierType // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (C.GdkModifierIntent)(intent)

_cret = C.gtk_widget_get_modifier_mask(_arg0, _arg1)


var _modifierType gdk.ModifierType // out

_modifierType = gdk.ModifierType(_cret)

return _modifierType
}
	
	// ModifierStyle returns the current modifier style for the widget. (As set by
// gtk_widget_modify_style().) If no style has previously set, a new RcStyle
// will be created with all values unset, and set as the modifier style for the
// widget. If you make changes to this rc style, you must call
// gtk_widget_modify_style(), passing in the returned rc style, to make sure
// that your changes take effect.
// 
// Caution: passing the style back to gtk_widget_modify_style() will normally
// end up destroying it, because gtk_widget_modify_style() copies the passed-in
// style and sets the copy as the new modifier style, thus dropping any
// reference to the old modifier style. Add a reference to the modifier style if
// you want to keep it alive.
	func (w Widget) ModifierStyle() RCStyle {
var _arg0 *C.GtkWidget // out
var _cret *C.GtkRcStyle // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_modifier_style(_arg0)


var _rcStyle RCStyle // out

_rcStyle = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(RCStyle)

return _rcStyle
}
	
	// Name retrieves the name of a widget. See gtk_widget_set_name() for the
// significance of widget names.
	func (w Widget) Name() string {
var _arg0 *C.GtkWidget // out
var _cret *C.gchar // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_name(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// NoShowAll returns the current value of the Widget:no-show-all property, which
// determines whether calls to gtk_widget_show_all() will affect this widget.
	func (w Widget) NoShowAll() bool {
var _arg0 *C.GtkWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_no_show_all(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Opacity fetches the requested opacity for this widget. See
// gtk_widget_set_opacity().
	func (w Widget) Opacity() float64 {
var _arg0 *C.GtkWidget // out
var _cret C.double // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_opacity(_arg0)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// PangoContext gets a Context with the appropriate font map, font description,
// and base direction for this widget. Unlike the context returned by
// gtk_widget_create_pango_context(), this context is owned by the widget (it
// can be used until the screen for the widget changes or the widget is removed
// from its toplevel), and will be updated to match any changes to the widget’s
// attributes. This can be tracked by using the Widget::screen-changed signal on
// the widget.
	func (w Widget) PangoContext() pango.Context {
var _arg0 *C.GtkWidget // out
var _cret *C.PangoContext // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_pango_context(_arg0)


var _context pango.Context // out

_context = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(pango.Context)

return _context
}
	
	// Parent returns the parent container of @widget.
	func (w Widget) Parent() Widget {
var _arg0 *C.GtkWidget // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_parent(_arg0)


var _ret Widget // out

_ret = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _ret
}
	
	// ParentWindow gets @widget’s parent window, or nil if it does not have one.
	func (w Widget) ParentWindow() gdk.Window {
var _arg0 *C.GtkWidget // out
var _cret *C.GdkWindow // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_parent_window(_arg0)


var _window gdk.Window // out

_window = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Window)

return _window
}
	
	// GetPath returns the WidgetPath representing @widget, if the widget is not
// connected to a toplevel widget, a partial path will be created.
	func (w Widget) GetPath() *WidgetPath {
var _arg0 *C.GtkWidget // out
var _cret *C.GtkWidgetPath // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_path(_arg0)


var _widgetPath *WidgetPath // out

_widgetPath = *(**WidgetPath)(unsafe.Pointer(&_cret))

return _widgetPath
}
	
	// Pointer obtains the location of the mouse pointer in widget coordinates.
// Widget coordinates are a bit odd; for historical reasons, they are defined as
// @widget->window coordinates for widgets that return true for
// gtk_widget_get_has_window(); and are relative to @widget->allocation.x,
// @widget->allocation.y otherwise.
	func (w Widget) Pointer() (x int, y int) {
var _arg0 *C.GtkWidget // out
var _arg1 C.gint // in
var _arg2 C.gint // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

C.gtk_widget_get_pointer(_arg0, &_arg1, &_arg2)

var _x int // out
var _y int // out

_x = (int)(_arg1)
_y = (int)(_arg2)

return _x, _y
}
	
	// PreferredHeight retrieves a widget’s initial minimum and natural height.
// 
// This call is specific to width-for-height requests.
// 
// The returned request will be modified by the
// GtkWidgetClass::adjust_size_request virtual method and by any SizeGroups that
// have been applied. That is, the returned request is the one that should be
// used for layout, not necessarily the one returned by the widget itself.
	func (w Widget) PreferredHeight() (minimumHeight int, naturalHeight int) {
var _arg0 *C.GtkWidget // out
var _arg1 C.gint // in
var _arg2 C.gint // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

C.gtk_widget_get_preferred_height(_arg0, &_arg1, &_arg2)

var _minimumHeight int // out
var _naturalHeight int // out

_minimumHeight = (int)(_arg1)
_naturalHeight = (int)(_arg2)

return _minimumHeight, _naturalHeight
}
	
	// PreferredHeightAndBaselineForWidth retrieves a widget’s minimum and natural
// height and the corresponding baselines if it would be given the specified
// @width, or the default height if @width is -1. The baselines may be -1 which
// means that no baseline is requested for this widget.
// 
// The returned request will be modified by the
// GtkWidgetClass::adjust_size_request and
// GtkWidgetClass::adjust_baseline_request virtual methods and by any SizeGroups
// that have been applied. That is, the returned request is the one that should
// be used for layout, not necessarily the one returned by the widget itself.
	func (w Widget) PreferredHeightAndBaselineForWidth(width int) (minimumHeight int, naturalHeight int, minimumBaseline int, naturalBaseline int) {
var _arg0 *C.GtkWidget // out
var _arg1 C.gint // out
var _arg2 C.gint // in
var _arg3 C.gint // in
var _arg4 C.gint // in
var _arg5 C.gint // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (C.gint)(width)

C.gtk_widget_get_preferred_height_and_baseline_for_width(_arg0, _arg1, &_arg2, &_arg3, &_arg4, &_arg5)

var _minimumHeight int // out
var _naturalHeight int // out
var _minimumBaseline int // out
var _naturalBaseline int // out

_minimumHeight = (int)(_arg2)
_naturalHeight = (int)(_arg3)
_minimumBaseline = (int)(_arg4)
_naturalBaseline = (int)(_arg5)

return _minimumHeight, _naturalHeight, _minimumBaseline, _naturalBaseline
}
	
	// PreferredHeightForWidth retrieves a widget’s minimum and natural height if it
// would be given the specified @width.
// 
// The returned request will be modified by the
// GtkWidgetClass::adjust_size_request virtual method and by any SizeGroups that
// have been applied. That is, the returned request is the one that should be
// used for layout, not necessarily the one returned by the widget itself.
	func (w Widget) PreferredHeightForWidth(width int) (minimumHeight int, naturalHeight int) {
var _arg0 *C.GtkWidget // out
var _arg1 C.gint // out
var _arg2 C.gint // in
var _arg3 C.gint // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (C.gint)(width)

C.gtk_widget_get_preferred_height_for_width(_arg0, _arg1, &_arg2, &_arg3)

var _minimumHeight int // out
var _naturalHeight int // out

_minimumHeight = (int)(_arg2)
_naturalHeight = (int)(_arg3)

return _minimumHeight, _naturalHeight
}
	
	// PreferredSize retrieves the minimum and natural size of a widget, taking into
// account the widget’s preference for height-for-width management.
// 
// This is used to retrieve a suitable size by container widgets which do not
// impose any restrictions on the child placement. It can be used to deduce
// toplevel window and menu sizes as well as child widgets in free-form
// containers such as GtkLayout.
// 
// Handle with care. Note that the natural height of a height-for-width widget
// will generally be a smaller size than the minimum height, since the required
// height for the natural width is generally smaller than the required height
// for the minimum width.
// 
// Use gtk_widget_get_preferred_height_and_baseline_for_width() if you want to
// support baseline alignment.
	func (w Widget) PreferredSize() (minimumSize Requisition, naturalSize Requisition) {
var _arg0 *C.GtkWidget // out
var _minimumSize Requisition
var _naturalSize Requisition

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

C.gtk_widget_get_preferred_size(_arg0, (*C.GtkRequisition)(unsafe.Pointer(&_minimumSize)), (*C.GtkRequisition)(unsafe.Pointer(&_naturalSize)))







return _minimumSize, _naturalSize
}
	
	// PreferredWidth retrieves a widget’s initial minimum and natural width.
// 
// This call is specific to height-for-width requests.
// 
// The returned request will be modified by the
// GtkWidgetClass::adjust_size_request virtual method and by any SizeGroups that
// have been applied. That is, the returned request is the one that should be
// used for layout, not necessarily the one returned by the widget itself.
	func (w Widget) PreferredWidth() (minimumWidth int, naturalWidth int) {
var _arg0 *C.GtkWidget // out
var _arg1 C.gint // in
var _arg2 C.gint // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

C.gtk_widget_get_preferred_width(_arg0, &_arg1, &_arg2)

var _minimumWidth int // out
var _naturalWidth int // out

_minimumWidth = (int)(_arg1)
_naturalWidth = (int)(_arg2)

return _minimumWidth, _naturalWidth
}
	
	// PreferredWidthForHeight retrieves a widget’s minimum and natural width if it
// would be given the specified @height.
// 
// The returned request will be modified by the
// GtkWidgetClass::adjust_size_request virtual method and by any SizeGroups that
// have been applied. That is, the returned request is the one that should be
// used for layout, not necessarily the one returned by the widget itself.
	func (w Widget) PreferredWidthForHeight(height int) (minimumWidth int, naturalWidth int) {
var _arg0 *C.GtkWidget // out
var _arg1 C.gint // out
var _arg2 C.gint // in
var _arg3 C.gint // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (C.gint)(height)

C.gtk_widget_get_preferred_width_for_height(_arg0, _arg1, &_arg2, &_arg3)

var _minimumWidth int // out
var _naturalWidth int // out

_minimumWidth = (int)(_arg2)
_naturalWidth = (int)(_arg3)

return _minimumWidth, _naturalWidth
}
	
	// Realized determines whether @widget is realized.
	func (w Widget) Realized() bool {
var _arg0 *C.GtkWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_realized(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ReceivesDefault determines whether @widget is always treated as the default
// widget within its toplevel when it has the focus, even if another widget is
// the default.
// 
// See gtk_widget_set_receives_default().
	func (w Widget) ReceivesDefault() bool {
var _arg0 *C.GtkWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_receives_default(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// RequestMode gets whether the widget prefers a height-for-width layout or a
// width-for-height layout.
// 
// Bin widgets generally propagate the preference of their child, container
// widgets need to request something either in context of their children or in
// context of their allocation capabilities.
	func (w Widget) RequestMode() SizeRequestMode {
var _arg0 *C.GtkWidget // out
var _cret C.GtkSizeRequestMode // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_request_mode(_arg0)


var _sizeRequestMode SizeRequestMode // out

_sizeRequestMode = SizeRequestMode(_cret)

return _sizeRequestMode
}
	
	// Requisition retrieves the widget’s requisition.
// 
// This function should only be used by widget implementations in order to
// figure whether the widget’s requisition has actually changed after some
// internal state change (so that they can call gtk_widget_queue_resize()
// instead of gtk_widget_queue_draw()).
// 
// Normally, gtk_widget_size_request() should be used.
	func (w Widget) Requisition() Requisition {
var _arg0 *C.GtkWidget // out
var _requisition Requisition

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

C.gtk_widget_get_requisition(_arg0, (*C.GtkRequisition)(unsafe.Pointer(&_requisition)))





return _requisition
}
	
	// RootWindow: get the root window where this widget is located. This function
// can only be called after the widget has been added to a widget hierarchy with
// Window at the top.
// 
// The root window is useful for such purposes as creating a popup Window
// associated with the window. In general, you should only create display
// specific resources when a widget has been realized, and you should free those
// resources when the widget is unrealized.
	func (w Widget) RootWindow() gdk.Window {
var _arg0 *C.GtkWidget // out
var _cret *C.GdkWindow // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_root_window(_arg0)


var _window gdk.Window // out

_window = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Window)

return _window
}
	
	// ScaleFactor retrieves the internal scale factor that maps from window
// coordinates to the actual device pixels. On traditional systems this is 1, on
// high density outputs, it can be a higher value (typically 2).
// 
// See gdk_window_get_scale_factor().
	func (w Widget) ScaleFactor() int {
var _arg0 *C.GtkWidget // out
var _cret C.gint // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_scale_factor(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Screen: get the Screen from the toplevel window associated with this widget.
// This function can only be called after the widget has been added to a widget
// hierarchy with a Window at the top.
// 
// In general, you should only create screen specific resources when a widget
// has been realized, and you should free those resources when the widget is
// unrealized.
	func (w Widget) Screen() gdk.Screen {
var _arg0 *C.GtkWidget // out
var _cret *C.GdkScreen // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_screen(_arg0)


var _screen gdk.Screen // out

_screen = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Screen)

return _screen
}
	
	// Sensitive returns the widget’s sensitivity (in the sense of returning the
// value that has been set using gtk_widget_set_sensitive()).
// 
// The effective sensitivity of a widget is however determined by both its own
// and its parent widget’s sensitivity. See gtk_widget_is_sensitive().
	func (w Widget) Sensitive() bool {
var _arg0 *C.GtkWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_sensitive(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Settings gets the settings object holding the settings used for this widget.
// 
// Note that this function can only be called when the Widget is attached to a
// toplevel, since the settings object is specific to a particular Screen.
	func (w Widget) Settings() Settings {
var _arg0 *C.GtkWidget // out
var _cret *C.GtkSettings // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_settings(_arg0)


var _settings Settings // out

_settings = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Settings)

return _settings
}
	
	// GetSizeRequest gets the size request that was explicitly set for the widget
// using gtk_widget_set_size_request(). A value of -1 stored in @width or
// @height indicates that that dimension has not been set explicitly and the
// natural requisition of the widget will be used instead. See
// gtk_widget_set_size_request(). To get the size a widget will actually
// request, call gtk_widget_get_preferred_size() instead of this function.
	func (w Widget) GetSizeRequest() (width int, height int) {
var _arg0 *C.GtkWidget // out
var _arg1 C.gint // in
var _arg2 C.gint // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

C.gtk_widget_get_size_request(_arg0, &_arg1, &_arg2)

var _width int // out
var _height int // out

_width = (int)(_arg1)
_height = (int)(_arg2)

return _width, _height
}
	
	// State returns the widget’s state. See gtk_widget_set_state().
	func (w Widget) State() StateType {
var _arg0 *C.GtkWidget // out
var _cret C.GtkStateType // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_state(_arg0)


var _stateType StateType // out

_stateType = StateType(_cret)

return _stateType
}
	
	// StateFlags returns the widget state as a flag set. It is worth mentioning
// that the effective GTK_STATE_FLAG_INSENSITIVE state will be returned, that
// is, also based on parent insensitivity, even if @widget itself is sensitive.
// 
// Also note that if you are looking for a way to obtain the StateFlags to pass
// to a StyleContext method, you should look at gtk_style_context_get_state().
	func (w Widget) StateFlags() StateFlags {
var _arg0 *C.GtkWidget // out
var _cret C.GtkStateFlags // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_state_flags(_arg0)


var _stateFlags StateFlags // out

_stateFlags = StateFlags(_cret)

return _stateFlags
}
	
	// Style: simply an accessor function that returns @widget->style.
	func (w Widget) Style() Style {
var _arg0 *C.GtkWidget // out
var _cret *C.GtkStyle // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_style(_arg0)


var _style Style // out

_style = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Style)

return _style
}
	
	// StyleContext returns the style context associated to @widget. The returned
// object is guaranteed to be the same for the lifetime of @widget.
	func (w Widget) StyleContext() StyleContext {
var _arg0 *C.GtkWidget // out
var _cret *C.GtkStyleContext // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_style_context(_arg0)


var _styleContext StyleContext // out

_styleContext = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(StyleContext)

return _styleContext
}
	
	// SupportMultidevice returns true if @widget is multiple pointer aware. See
// gtk_widget_set_support_multidevice() for more information.
	func (w Widget) SupportMultidevice() bool {
var _arg0 *C.GtkWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_support_multidevice(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// TemplateChild: fetch an object build from the template XML for @widget_type
// in this @widget instance.
// 
// This will only report children which were previously declared with
// gtk_widget_class_bind_template_child_full() or one of its variants.
// 
// This function is only meant to be called for code which is private to the
// @widget_type which declared the child and is meant for language bindings
// which cannot easily make use of the GObject structure offsets.
	func (w Widget) TemplateChild(widgetType externglib.Type, name string) **externglib.Object {
var _arg0 *C.GtkWidget // out
var _arg1 C.GType // out
var _arg2 *C.gchar // out
var _cret *C.GObject // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = C.GType(widgetType)
_arg2 = (*C.gchar)(C.CString(name))
defer C.free(unsafe.Pointer(_arg2))

_cret = C.gtk_widget_get_template_child(_arg0, _arg1, _arg2)


var _object **externglib.Object // out

_object = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(**externglib.Object)

return _object
}
	
	// TooltipMarkup gets the contents of the tooltip for @widget.
	func (w Widget) TooltipMarkup() string {
var _arg0 *C.GtkWidget // out
var _cret *C.gchar // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_tooltip_markup(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// TooltipText gets the contents of the tooltip for @widget.
	func (w Widget) TooltipText() string {
var _arg0 *C.GtkWidget // out
var _cret *C.gchar // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_tooltip_text(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// TooltipWindow returns the Window of the current tooltip. This can be the
// GtkWindow created by default, or the custom tooltip window set using
// gtk_widget_set_tooltip_window().
	func (w Widget) TooltipWindow() Window {
var _arg0 *C.GtkWidget // out
var _cret *C.GtkWindow // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_tooltip_window(_arg0)


var _window Window // out

_window = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Window)

return _window
}
	
	// Toplevel: this function returns the topmost widget in the container hierarchy
// @widget is a part of. If @widget has no parent widgets, it will be returned
// as the topmost widget. No reference will be added to the returned widget; it
// should not be unreferenced.
// 
// Note the difference in behavior vs. gtk_widget_get_ancestor();
// `gtk_widget_get_ancestor (widget, GTK_TYPE_WINDOW)` would return nil if
// @widget wasn’t inside a toplevel window, and if the window was inside a
// Window-derived widget which was in turn inside the toplevel Window. While the
// second case may seem unlikely, it actually happens when a Plug is embedded
// inside a Socket within the same application.
// 
// To reliably find the toplevel Window, use gtk_widget_get_toplevel() and call
// GTK_IS_WINDOW() on the result. For instance, to get the title of a widget's
// toplevel window, one might use:
// 
//    static const char *
//    get_widget_toplevel_title (GtkWidget *widget)
//    {
//      GtkWidget *toplevel = gtk_widget_get_toplevel (widget);
//      if (GTK_IS_WINDOW (toplevel))
//        {
//          return gtk_window_get_title (GTK_WINDOW (toplevel));
//        }
// 
//      return NULL;
//    }
	func (w Widget) Toplevel() Widget {
var _arg0 *C.GtkWidget // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_toplevel(_arg0)


var _ret Widget // out

_ret = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _ret
}
	
	// Valign gets the value of the Widget:valign property.
// 
// For backwards compatibility reasons this method will never return
// GTK_ALIGN_BASELINE, but instead it will convert it to GTK_ALIGN_FILL. If your
// widget want to support baseline aligned children it must use
// gtk_widget_get_valign_with_baseline(), or `g_object_get (widget, "valign",
// &value, NULL)`, which will also report the true value.
	func (w Widget) Valign() Align {
var _arg0 *C.GtkWidget // out
var _cret C.GtkAlign // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_valign(_arg0)


var _align Align // out

_align = Align(_cret)

return _align
}
	
	// ValignWithBaseline gets the value of the Widget:valign property, including
// GTK_ALIGN_BASELINE.
	func (w Widget) ValignWithBaseline() Align {
var _arg0 *C.GtkWidget // out
var _cret C.GtkAlign // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_valign_with_baseline(_arg0)


var _align Align // out

_align = Align(_cret)

return _align
}
	
	// Vexpand gets whether the widget would like any available extra vertical
// space.
// 
// See gtk_widget_get_hexpand() for more detail.
	func (w Widget) Vexpand() bool {
var _arg0 *C.GtkWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_vexpand(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// VexpandSet gets whether gtk_widget_set_vexpand() has been used to explicitly
// set the expand flag on this widget.
// 
// See gtk_widget_get_hexpand_set() for more detail.
	func (w Widget) VexpandSet() bool {
var _arg0 *C.GtkWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_vexpand_set(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Visible determines whether the widget is visible. If you want to take into
// account whether the widget’s parent is also marked as visible, use
// gtk_widget_is_visible() instead.
// 
// This function does not check if the widget is obscured in any way.
// 
// See gtk_widget_set_visible().
	func (w Widget) Visible() bool {
var _arg0 *C.GtkWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_visible(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Visual gets the visual that will be used to render @widget.
	func (w Widget) Visual() gdk.Visual {
var _arg0 *C.GtkWidget // out
var _cret *C.GdkVisual // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_visual(_arg0)


var _visual gdk.Visual // out

_visual = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Visual)

return _visual
}
	
	// Window returns the widget’s window if it is realized, nil otherwise
	func (w Widget) Window() gdk.Window {
var _arg0 *C.GtkWidget // out
var _cret *C.GdkWindow // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_window(_arg0)


var _window gdk.Window // out

_window = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Window)

return _window
}
	
	// GrabAdd makes @widget the current grabbed widget.
// 
// This means that interaction with other widgets in the same application is
// blocked and mouse as well as keyboard events are delivered to this widget.
// 
// If @widget is not sensitive, it is not set as the current grabbed widget and
// this function does nothing.
	func (w Widget) GrabAdd()  {
var _arg0 *C.GtkWidget // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

C.gtk_grab_add(_arg0)
}
	
	// GrabDefault causes @widget to become the default widget. @widget must be able
// to be a default widget; typically you would ensure this yourself by calling
// gtk_widget_set_can_default() with a true value. The default widget is
// activated when the user presses Enter in a window. Default widgets must be
// activatable, that is, gtk_widget_activate() should affect them. Note that
// Entry widgets require the “activates-default” property set to true before
// they activate the default widget when Enter is pressed and the Entry is
// focused.
	func (w Widget) GrabDefault()  {
var _arg0 *C.GtkWidget // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

C.gtk_widget_grab_default(_arg0)
}
	
	// GrabFocus causes @widget to have the keyboard focus for the Window it's
// inside. @widget must be a focusable widget, such as a Entry; something like
// Frame won’t work.
// 
// More precisely, it must have the GTK_CAN_FOCUS flag set. Use
// gtk_widget_set_can_focus() to modify that flag.
// 
// The widget also needs to be realized and mapped. This is indicated by the
// related signals. Grabbing the focus immediately after creating the widget
// will likely fail and cause critical warnings.
	func (w Widget) GrabFocus()  {
var _arg0 *C.GtkWidget // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

C.gtk_widget_grab_focus(_arg0)
}
	
	// GrabRemove removes the grab from the given widget.
// 
// You have to pair calls to gtk_grab_add() and gtk_grab_remove().
// 
// If @widget does not have the grab, this function does nothing.
	func (w Widget) GrabRemove()  {
var _arg0 *C.GtkWidget // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

C.gtk_grab_remove(_arg0)
}
	
	// HasDefault determines whether @widget is the current default widget within
// its toplevel. See gtk_widget_set_can_default().
	func (w Widget) HasDefault() bool {
var _arg0 *C.GtkWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_has_default(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// HasFocus determines if the widget has the global input focus. See
// gtk_widget_is_focus() for the difference between having the global input
// focus, and only having the focus within a toplevel.
	func (w Widget) HasFocus() bool {
var _arg0 *C.GtkWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_has_focus(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// HasGrab determines whether the widget is currently grabbing events, so it is
// the only widget receiving input events (keyboard and mouse).
// 
// See also gtk_grab_add().
	func (w Widget) HasGrab() bool {
var _arg0 *C.GtkWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_has_grab(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// HasRCStyle determines if the widget style has been looked up through the rc
// mechanism.
	func (w Widget) HasRCStyle() bool {
var _arg0 *C.GtkWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_has_rc_style(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// HasScreen checks whether there is a Screen is associated with this widget.
// All toplevel widgets have an associated screen, and all widgets added into a
// hierarchy with a toplevel window at the top.
	func (w Widget) HasScreen() bool {
var _arg0 *C.GtkWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_has_screen(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// HasVisibleFocus determines if the widget should show a visible indication
// that it has the global input focus. This is a convenience function for use in
// ::draw handlers that takes into account whether focus indication should
// currently be shown in the toplevel window of @widget. See
// gtk_window_get_focus_visible() for more information about focus indication.
// 
// To find out if the widget has the global input focus, use
// gtk_widget_has_focus().
	func (w Widget) HasVisibleFocus() bool {
var _arg0 *C.GtkWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_has_visible_focus(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Hide reverses the effects of gtk_widget_show(), causing the widget to be
// hidden (invisible to the user).
	func (w Widget) Hide()  {
var _arg0 *C.GtkWidget // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

C.gtk_widget_hide(_arg0)
}
	
	// HideOnDelete: utility function; intended to be connected to the
// Widget::delete-event signal on a Window. The function calls gtk_widget_hide()
// on its argument, then returns true. If connected to ::delete-event, the
// result is that clicking the close button for a window (on the window frame,
// top right corner usually) will hide but not destroy the window. By default,
// GTK+ destroys windows when ::delete-event is received.
	func (w Widget) HideOnDelete() bool {
var _arg0 *C.GtkWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_hide_on_delete(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// InDestruction returns whether the widget is currently being destroyed. This
// information can sometimes be used to avoid doing unnecessary work.
	func (w Widget) InDestruction() bool {
var _arg0 *C.GtkWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_in_destruction(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// InitTemplate creates and initializes child widgets defined in templates. This
// function must be called in the instance initializer for any class which
// assigned itself a template using gtk_widget_class_set_template()
// 
// It is important to call this function in the instance initializer of a Widget
// subclass and not in #GObject.constructed() or #GObject.constructor() for two
// reasons.
// 
// One reason is that generally derived widgets will assume that parent class
// composite widgets have been created in their instance initializers.
// 
// Another reason is that when calling g_object_new() on a widget with composite
// templates, it’s important to build the composite widgets before the construct
// properties are set. Properties passed to g_object_new() should take
// precedence over properties set in the private template XML.
	func (w Widget) InitTemplate()  {
var _arg0 *C.GtkWidget // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

C.gtk_widget_init_template(_arg0)
}
	
	// InputShapeCombineRegion sets an input shape for this widget’s GDK window.
// This allows for windows which react to mouse click in a nonrectangular
// region, see gdk_window_input_shape_combine_region() for more information.
	func (w Widget) InputShapeCombineRegion(region *cairo.Region)  {
var _arg0 *C.GtkWidget // out
var _arg1 *C.cairo_region_t // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (*C.cairo_region_t)(unsafe.Pointer(region.Native()))

C.gtk_widget_input_shape_combine_region(_arg0, _arg1)
}
	
	// InsertActionGroup inserts @group into @widget. Children of @widget that
// implement Actionable can then be associated with actions in @group by setting
// their “action-name” to @prefix.`action-name`.
// 
// If @group is nil, a previously inserted group for @name is removed from
// @widget.
	func (w Widget) InsertActionGroup(name string, group gio.ActionGroup)  {
var _arg0 *C.GtkWidget // out
var _arg1 *C.gchar // out
var _arg2 *C.GActionGroup // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (*C.gchar)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.GActionGroup)(unsafe.Pointer(group.Native()))

C.gtk_widget_insert_action_group(_arg0, _arg1, _arg2)
}
	
	// Intersect computes the intersection of a @widget’s area and @area, storing
// the intersection in @intersection, and returns true if there was an
// intersection. @intersection may be nil if you’re only interested in whether
// there was an intersection.
	func (w Widget) Intersect(area *gdk.Rectangle) (gdk.Rectangle, bool) {
var _arg0 *C.GtkWidget // out
var _arg1 *C.GdkRectangle // out
var _intersection gdk.Rectangle
var _cret C.gboolean // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (*C.GdkRectangle)(unsafe.Pointer(area.Native()))

_cret = C.gtk_widget_intersect(_arg0, _arg1, (*C.GdkRectangle)(unsafe.Pointer(&_intersection)))



var _ok bool // out


if _cret != 0 { _ok = true }

return _intersection, _ok
}
	
	// IsAncestor determines whether @widget is somewhere inside @ancestor, possibly
// with intermediate containers.
	func (w Widget) IsAncestor(ancestor WidgetClass) bool {
var _arg0 *C.GtkWidget // out
var _arg1 *C.GtkWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(ancestor.Native()))

_cret = C.gtk_widget_is_ancestor(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsComposited: whether @widget can rely on having its alpha channel drawn
// correctly. On X11 this function returns whether a compositing manager is
// running for @widget’s screen.
// 
// Please note that the semantics of this call will change in the future if used
// on a widget that has a composited window in its hierarchy (as set by
// gdk_window_set_composited()).
	func (w Widget) IsComposited() bool {
var _arg0 *C.GtkWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_is_composited(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsDrawable determines whether @widget can be drawn to. A widget can be drawn
// to if it is mapped and visible.
	func (w Widget) IsDrawable() bool {
var _arg0 *C.GtkWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_is_drawable(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsFocus determines if the widget is the focus widget within its toplevel.
// (This does not mean that the Widget:has-focus property is necessarily set;
// Widget:has-focus will only be set if the toplevel widget additionally has the
// global input focus.)
	func (w Widget) IsFocus() bool {
var _arg0 *C.GtkWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_is_focus(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsSensitive returns the widget’s effective sensitivity, which means it is
// sensitive itself and also its parent widget is sensitive
	func (w Widget) IsSensitive() bool {
var _arg0 *C.GtkWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_is_sensitive(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsToplevel determines whether @widget is a toplevel widget.
// 
// Currently only Window and Invisible (and out-of-process Plugs) are toplevel
// widgets. Toplevel widgets have no parent widget.
	func (w Widget) IsToplevel() bool {
var _arg0 *C.GtkWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_is_toplevel(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsVisible determines whether the widget and all its parents are marked as
// visible.
// 
// This function does not check if the widget is obscured in any way.
// 
// See also gtk_widget_get_visible() and gtk_widget_set_visible()
	func (w Widget) IsVisible() bool {
var _arg0 *C.GtkWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_is_visible(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// KeynavFailed: this function should be called whenever keyboard navigation
// within a single widget hits a boundary. The function emits the
// Widget::keynav-failed signal on the widget and its return value should be
// interpreted in a way similar to the return value of gtk_widget_child_focus():
// 
// When true is returned, stay in the widget, the failed keyboard navigation is
// OK and/or there is nowhere we can/should move the focus to.
// 
// When false is returned, the caller should continue with keyboard navigation
// outside the widget, e.g. by calling gtk_widget_child_focus() on the widget’s
// toplevel.
// 
// The default ::keynav-failed handler returns false for GTK_DIR_TAB_FORWARD and
// GTK_DIR_TAB_BACKWARD. For the other values of DirectionType it returns true.
// 
// Whenever the default handler returns true, it also calls
// gtk_widget_error_bell() to notify the user of the failed keyboard navigation.
// 
// A use case for providing an own implementation of ::keynav-failed (either by
// connecting to it or by overriding it) would be a row of Entry widgets where
// the user should be able to navigate the entire row with the cursor keys, as
// e.g. known from user interfaces that require entering license keys.
	func (w Widget) KeynavFailed(direction DirectionType) bool {
var _arg0 *C.GtkWidget // out
var _arg1 C.GtkDirectionType // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (C.GtkDirectionType)(direction)

_cret = C.gtk_widget_keynav_failed(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ListActionPrefixes retrieves a nil-terminated array of strings containing the
// prefixes of Group's available to @widget.
	func (w Widget) ListActionPrefixes() []string {
var _arg0 *C.GtkWidget // out
var _cret **C.gchar

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_list_action_prefixes(_arg0)


var _utf8s []string

{
var i int
var z *C.gchar
for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
  i++
}

src := unsafe.Slice(_cret, i)
_utf8s = make([]string, i)
for i := range src {
_utf8s[i] = C.GoString(src[i])
}
}

return _utf8s
}
	
	// Map: this function is only for use in widget implementations. Causes a widget
// to be mapped if it isn’t already.
	func (w Widget) Map()  {
var _arg0 *C.GtkWidget // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

C.gtk_widget_map(_arg0)
}
	
	// MnemonicActivate emits the Widget::mnemonic-activate signal.
	func (w Widget) MnemonicActivate(groupCycling bool) bool {
var _arg0 *C.GtkWidget // out
var _arg1 C.gboolean // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
if groupCycling { _arg1 = C.TRUE }

_cret = C.gtk_widget_mnemonic_activate(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ModifyBase sets the base color for a widget in a particular state. All other
// style values are left untouched. The base color is the background color used
// along with the text color (see gtk_widget_modify_text()) for widgets such as
// Entry and TextView. See also gtk_widget_modify_style().
// 
// > Note that “no window” widgets (which have the GTK_NO_WINDOW > flag set)
// draw on their parent container’s window and thus may > not draw any
// background themselves. This is the case for e.g. > Label. > > To modify the
// background of such widgets, you have to set the > base color on their parent;
// if you want to set the background > of a rectangular area around a label, try
// placing the label in > a EventBox widget and setting the base color on that.
	func (w Widget) ModifyBase(state StateType, color *gdk.Color)  {
var _arg0 *C.GtkWidget // out
var _arg1 C.GtkStateType // out
var _arg2 *C.GdkColor // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (C.GtkStateType)(state)
_arg2 = (*C.GdkColor)(unsafe.Pointer(color.Native()))

C.gtk_widget_modify_base(_arg0, _arg1, _arg2)
}
	
	// ModifyBg sets the background color for a widget in a particular state.
// 
// All other style values are left untouched. See also
// gtk_widget_modify_style().
// 
// > Note that “no window” widgets (which have the GTK_NO_WINDOW > flag set)
// draw on their parent container’s window and thus may > not draw any
// background themselves. This is the case for e.g. > Label. > > To modify the
// background of such widgets, you have to set the > background color on their
// parent; if you want to set the background > of a rectangular area around a
// label, try placing the label in > a EventBox widget and setting the
// background color on that.
	func (w Widget) ModifyBg(state StateType, color *gdk.Color)  {
var _arg0 *C.GtkWidget // out
var _arg1 C.GtkStateType // out
var _arg2 *C.GdkColor // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (C.GtkStateType)(state)
_arg2 = (*C.GdkColor)(unsafe.Pointer(color.Native()))

C.gtk_widget_modify_bg(_arg0, _arg1, _arg2)
}
	
	// ModifyCursor sets the cursor color to use in a widget, overriding the Widget
// cursor-color and secondary-cursor-color style properties.
// 
// All other style values are left untouched. See also
// gtk_widget_modify_style().
	func (w Widget) ModifyCursor(primary *gdk.Color, secondary *gdk.Color)  {
var _arg0 *C.GtkWidget // out
var _arg1 *C.GdkColor // out
var _arg2 *C.GdkColor // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (*C.GdkColor)(unsafe.Pointer(primary.Native()))
_arg2 = (*C.GdkColor)(unsafe.Pointer(secondary.Native()))

C.gtk_widget_modify_cursor(_arg0, _arg1, _arg2)
}
	
	// ModifyFg sets the foreground color for a widget in a particular state.
// 
// All other style values are left untouched. See also
// gtk_widget_modify_style().
	func (w Widget) ModifyFg(state StateType, color *gdk.Color)  {
var _arg0 *C.GtkWidget // out
var _arg1 C.GtkStateType // out
var _arg2 *C.GdkColor // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (C.GtkStateType)(state)
_arg2 = (*C.GdkColor)(unsafe.Pointer(color.Native()))

C.gtk_widget_modify_fg(_arg0, _arg1, _arg2)
}
	
	// ModifyFont sets the font to use for a widget.
// 
// All other style values are left untouched. See also
// gtk_widget_modify_style().
	func (w Widget) ModifyFont(fontDesc *pango.FontDescription)  {
var _arg0 *C.GtkWidget // out
var _arg1 *C.PangoFontDescription // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (*C.PangoFontDescription)(unsafe.Pointer(fontDesc.Native()))

C.gtk_widget_modify_font(_arg0, _arg1)
}
	
	// ModifyStyle modifies style values on the widget.
// 
// Modifications made using this technique take precedence over style values set
// via an RC file, however, they will be overridden if a style is explicitly set
// on the widget using gtk_widget_set_style(). The RcStyle-struct is designed so
// each field can either be set or unset, so it is possible, using this
// function, to modify some style values and leave the others unchanged.
// 
// Note that modifications made with this function are not cumulative with
// previous calls to gtk_widget_modify_style() or with such functions as
// gtk_widget_modify_fg(). If you wish to retain previous values, you must first
// call gtk_widget_get_modifier_style(), make your modifications to the returned
// style, then call gtk_widget_modify_style() with that style. On the other
// hand, if you first call gtk_widget_modify_style(), subsequent calls to such
// functions gtk_widget_modify_fg() will have a cumulative effect with the
// initial modifications.
	func (w Widget) ModifyStyle(style RCStyleClass)  {
var _arg0 *C.GtkWidget // out
var _arg1 *C.GtkRcStyle // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (*C.GtkRcStyle)(unsafe.Pointer(style.Native()))

C.gtk_widget_modify_style(_arg0, _arg1)
}
	
	// ModifyText sets the text color for a widget in a particular state.
// 
// All other style values are left untouched. The text color is the foreground
// color used along with the base color (see gtk_widget_modify_base()) for
// widgets such as Entry and TextView. See also gtk_widget_modify_style().
	func (w Widget) ModifyText(state StateType, color *gdk.Color)  {
var _arg0 *C.GtkWidget // out
var _arg1 C.GtkStateType // out
var _arg2 *C.GdkColor // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (C.GtkStateType)(state)
_arg2 = (*C.GdkColor)(unsafe.Pointer(color.Native()))

C.gtk_widget_modify_text(_arg0, _arg1, _arg2)
}
	
	// OverrideBackgroundColor sets the background color to use for a widget.
// 
// All other style values are left untouched. See gtk_widget_override_color().
	func (w Widget) OverrideBackgroundColor(state StateFlags, color *gdk.RGBA)  {
var _arg0 *C.GtkWidget // out
var _arg1 C.GtkStateFlags // out
var _arg2 *C.GdkRGBA // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (C.GtkStateFlags)(state)
_arg2 = (*C.GdkRGBA)(unsafe.Pointer(color.Native()))

C.gtk_widget_override_background_color(_arg0, _arg1, _arg2)
}
	
	// OverrideColor sets the color to use for a widget.
// 
// All other style values are left untouched.
// 
// This function does not act recursively. Setting the color of a container does
// not affect its children. Note that some widgets that you may not think of as
// containers, for instance Buttons, are actually containers.
// 
// This API is mostly meant as a quick way for applications to change a widget
// appearance. If you are developing a widgets library and intend this change to
// be themeable, it is better done by setting meaningful CSS classes in your
// widget/container implementation through gtk_style_context_add_class().
// 
// This way, your widget library can install a CssProvider with the
// GTK_STYLE_PROVIDER_PRIORITY_FALLBACK priority in order to provide a default
// styling for those widgets that need so, and this theming may fully overridden
// by the user’s theme.
// 
// Note that for complex widgets this may bring in undesired results (such as
// uniform background color everywhere), in these cases it is better to fully
// style such widgets through a CssProvider with the
// GTK_STYLE_PROVIDER_PRIORITY_APPLICATION priority.
	func (w Widget) OverrideColor(state StateFlags, color *gdk.RGBA)  {
var _arg0 *C.GtkWidget // out
var _arg1 C.GtkStateFlags // out
var _arg2 *C.GdkRGBA // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (C.GtkStateFlags)(state)
_arg2 = (*C.GdkRGBA)(unsafe.Pointer(color.Native()))

C.gtk_widget_override_color(_arg0, _arg1, _arg2)
}
	
	// OverrideCursor sets the cursor color to use in a widget, overriding the
// cursor-color and secondary-cursor-color style properties. All other style
// values are left untouched. See also gtk_widget_modify_style().
// 
// Note that the underlying properties have the Color type, so the alpha value
// in @primary and @secondary will be ignored.
	func (w Widget) OverrideCursor(cursor *gdk.RGBA, secondaryCursor *gdk.RGBA)  {
var _arg0 *C.GtkWidget // out
var _arg1 *C.GdkRGBA // out
var _arg2 *C.GdkRGBA // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (*C.GdkRGBA)(unsafe.Pointer(cursor.Native()))
_arg2 = (*C.GdkRGBA)(unsafe.Pointer(secondaryCursor.Native()))

C.gtk_widget_override_cursor(_arg0, _arg1, _arg2)
}
	
	// OverrideFont sets the font to use for a widget. All other style values are
// left untouched. See gtk_widget_override_color().
	func (w Widget) OverrideFont(fontDesc *pango.FontDescription)  {
var _arg0 *C.GtkWidget // out
var _arg1 *C.PangoFontDescription // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (*C.PangoFontDescription)(unsafe.Pointer(fontDesc.Native()))

C.gtk_widget_override_font(_arg0, _arg1)
}
	
	// OverrideSymbolicColor sets a symbolic color for a widget.
// 
// All other style values are left untouched. See gtk_widget_override_color()
// for overriding the foreground or background color.
	func (w Widget) OverrideSymbolicColor(name string, color *gdk.RGBA)  {
var _arg0 *C.GtkWidget // out
var _arg1 *C.gchar // out
var _arg2 *C.GdkRGBA // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (*C.gchar)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.GdkRGBA)(unsafe.Pointer(color.Native()))

C.gtk_widget_override_symbolic_color(_arg0, _arg1, _arg2)
}
	
	// Path obtains the full path to @widget. The path is simply the name of a
// widget and all its parents in the container hierarchy, separated by periods.
// The name of a widget comes from gtk_widget_get_name(). Paths are used to
// apply styles to a widget in gtkrc configuration files. Widget names are the
// type of the widget by default (e.g. “GtkButton”) or can be set to an
// application-specific value with gtk_widget_set_name(). By setting the name of
// a widget, you allow users or theme authors to apply styles to that specific
// widget in their gtkrc file. @path_reversed_p fills in the path in reverse
// order, i.e. starting with @widget’s name instead of starting with the name of
// @widget’s outermost ancestor.
	func (w Widget) Path() (pathLength uint, path string, pathReversed string) {
var _arg0 *C.GtkWidget // out
var _arg1 C.guint // in
var _arg2 *C.gchar // in
var _arg3 *C.gchar // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

C.gtk_widget_path(_arg0, &_arg1, &_arg2, &_arg3)

var _pathLength uint // out
var _path string // out
var _pathReversed string // out

_pathLength = (uint)(_arg1)
_path = C.GoString(_arg2)
defer C.free(unsafe.Pointer(_arg2))
_pathReversed = C.GoString(_arg3)
defer C.free(unsafe.Pointer(_arg3))

return _pathLength, _path, _pathReversed
}
	
	// QueueAllocate: this function is only for use in widget implementations.
// 
// Flags the widget for a rerun of the GtkWidgetClass::size_allocate function.
// Use this function instead of gtk_widget_queue_resize() when the @widget's
// size request didn't change but it wants to reposition its contents.
// 
// An example user of this function is gtk_widget_set_halign().
	func (w Widget) QueueAllocate()  {
var _arg0 *C.GtkWidget // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

C.gtk_widget_queue_allocate(_arg0)
}
	
	// QueueComputeExpand: mark @widget as needing to recompute its expand flags.
// Call this function when setting legacy expand child properties on the child
// of a container.
// 
// See gtk_widget_compute_expand().
	func (w Widget) QueueComputeExpand()  {
var _arg0 *C.GtkWidget // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

C.gtk_widget_queue_compute_expand(_arg0)
}
	
	// QueueDraw: equivalent to calling gtk_widget_queue_draw_area() for the entire
// area of a widget.
	func (w Widget) QueueDraw()  {
var _arg0 *C.GtkWidget // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

C.gtk_widget_queue_draw(_arg0)
}
	
	// QueueDrawArea: convenience function that calls gtk_widget_queue_draw_region()
// on the region created from the given coordinates.
// 
// The region here is specified in widget coordinates. Widget coordinates are a
// bit odd; for historical reasons, they are defined as @widget->window
// coordinates for widgets that return true for gtk_widget_get_has_window(), and
// are relative to @widget->allocation.x, @widget->allocation.y otherwise.
// 
// @width or @height may be 0, in this case this function does nothing. Negative
// values for @width and @height are not allowed.
	func (w Widget) QueueDrawArea(x int, y int, width int, height int)  {
var _arg0 *C.GtkWidget // out
var _arg1 C.gint // out
var _arg2 C.gint // out
var _arg3 C.gint // out
var _arg4 C.gint // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (C.gint)(x)
_arg2 = (C.gint)(y)
_arg3 = (C.gint)(width)
_arg4 = (C.gint)(height)

C.gtk_widget_queue_draw_area(_arg0, _arg1, _arg2, _arg3, _arg4)
}
	
	// QueueDrawRegion invalidates the area of @widget defined by @region by calling
// gdk_window_invalidate_region() on the widget’s window and all its child
// windows. Once the main loop becomes idle (after the current batch of events
// has been processed, roughly), the window will receive expose events for the
// union of all regions that have been invalidated.
// 
// Normally you would only use this function in widget implementations. You
// might also use it to schedule a redraw of a DrawingArea or some portion
// thereof.
	func (w Widget) QueueDrawRegion(region *cairo.Region)  {
var _arg0 *C.GtkWidget // out
var _arg1 *C.cairo_region_t // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (*C.cairo_region_t)(unsafe.Pointer(region.Native()))

C.gtk_widget_queue_draw_region(_arg0, _arg1)
}
	
	// QueueResize: this function is only for use in widget implementations. Flags a
// widget to have its size renegotiated; should be called when a widget for some
// reason has a new size request. For example, when you change the text in a
// Label, Label queues a resize to ensure there’s enough space for the new text.
// 
// Note that you cannot call gtk_widget_queue_resize() on a widget from inside
// its implementation of the GtkWidgetClass::size_allocate virtual method. Calls
// to gtk_widget_queue_resize() from inside GtkWidgetClass::size_allocate will
// be silently ignored.
	func (w Widget) QueueResize()  {
var _arg0 *C.GtkWidget // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

C.gtk_widget_queue_resize(_arg0)
}
	
	// QueueResizeNoRedraw: this function works like gtk_widget_queue_resize(),
// except that the widget is not invalidated.
	func (w Widget) QueueResizeNoRedraw()  {
var _arg0 *C.GtkWidget // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

C.gtk_widget_queue_resize_no_redraw(_arg0)
}
	
	// Realize creates the GDK (windowing system) resources associated with a
// widget. For example, @widget->window will be created when a widget is
// realized. Normally realization happens implicitly; if you show a widget and
// all its parent containers, then the widget will be realized and mapped
// automatically.
// 
// Realizing a widget requires all the widget’s parent widgets to be realized;
// calling gtk_widget_realize() realizes the widget’s parents in addition to
// @widget itself. If a widget is not yet inside a toplevel window when you
// realize it, bad things will happen.
// 
// This function is primarily used in widget implementations, and isn’t very
// useful otherwise. Many times when you think you might need it, a better
// approach is to connect to a signal that will be called after the widget is
// realized automatically, such as Widget::draw. Or simply g_signal_connect ()
// to the Widget::realize signal.
	func (w Widget) Realize()  {
var _arg0 *C.GtkWidget // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

C.gtk_widget_realize(_arg0)
}
	
	// RegionIntersect computes the intersection of a @widget’s area and @region,
// returning the intersection. The result may be empty, use
// cairo_region_is_empty() to check.
	func (w Widget) RegionIntersect(region *cairo.Region) *cairo.Region {
var _arg0 *C.GtkWidget // out
var _arg1 *C.cairo_region_t // out
var _cret *C.cairo_region_t // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (*C.cairo_region_t)(unsafe.Pointer(region.Native()))

_cret = C.gtk_widget_region_intersect(_arg0, _arg1)


var _ret *cairo.Region // out

_ret = *(**cairo.Region)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_ret, func(v *cairo.Region) {
  C.free(unsafe.Pointer(v.Native()))
})

return _ret
}
	
	// RegisterWindow registers a Window with the widget and sets it up so that the
// widget receives events for it. Call gtk_widget_unregister_window() when
// destroying the window.
// 
// Before 3.8 you needed to call gdk_window_set_user_data() directly to set this
// up. This is now deprecated and you should use gtk_widget_register_window()
// instead. Old code will keep working as is, although some new features like
// transparency might not work perfectly.
	func (w Widget) RegisterWindow(window gdk.WindowClass)  {
var _arg0 *C.GtkWidget // out
var _arg1 *C.GdkWindow // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (*C.GdkWindow)(unsafe.Pointer(window.Native()))

C.gtk_widget_register_window(_arg0, _arg1)
}
	
	// RemoveAccelerator removes an accelerator from @widget, previously installed
// with gtk_widget_add_accelerator().
	func (w Widget) RemoveAccelerator(accelGroup AccelGroupClass, accelKey uint, accelMods gdk.ModifierType) bool {
var _arg0 *C.GtkWidget // out
var _arg1 *C.GtkAccelGroup // out
var _arg2 C.guint // out
var _arg3 C.GdkModifierType // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (*C.GtkAccelGroup)(unsafe.Pointer(accelGroup.Native()))
_arg2 = (C.guint)(accelKey)
_arg3 = (C.GdkModifierType)(accelMods)

_cret = C.gtk_widget_remove_accelerator(_arg0, _arg1, _arg2, _arg3)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// RemoveMnemonicLabel removes a widget from the list of mnemonic labels for
// this widget. (See gtk_widget_list_mnemonic_labels()). The widget must have
// previously been added to the list with gtk_widget_add_mnemonic_label().
	func (w Widget) RemoveMnemonicLabel(label WidgetClass)  {
var _arg0 *C.GtkWidget // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(label.Native()))

C.gtk_widget_remove_mnemonic_label(_arg0, _arg1)
}
	
	// RemoveTickCallback removes a tick callback previously registered with
// gtk_widget_add_tick_callback().
	func (w Widget) RemoveTickCallback(id uint)  {
var _arg0 *C.GtkWidget // out
var _arg1 C.guint // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (C.guint)(id)

C.gtk_widget_remove_tick_callback(_arg0, _arg1)
}
	
	// RenderIcon: a convenience function that uses the theme settings for @widget
// to look up @stock_id and render it to a pixbuf. @stock_id should be a stock
// icon ID such as K_STOCK_OPEN or K_STOCK_OK. @size should be a size such as
// K_ICON_SIZE_MENU. @detail should be a string that identifies the widget or
// code doing the rendering, so that theme engines can special-case rendering
// for that widget or code.
// 
// The pixels in the returned Pixbuf are shared with the rest of the application
// and should not be modified. The pixbuf should be freed after use with
// g_object_unref().
	func (w Widget) RenderIcon(stockId string, size int, detail string) gdkpixbuf.Pixbuf {
var _arg0 *C.GtkWidget // out
var _arg1 *C.gchar // out
var _arg2 C.GtkIconSize // out
var _arg3 *C.gchar // out
var _cret *C.GdkPixbuf // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (*C.gchar)(C.CString(stockId))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.GtkIconSize)(size)
_arg3 = (*C.gchar)(C.CString(detail))
defer C.free(unsafe.Pointer(_arg3))

_cret = C.gtk_widget_render_icon(_arg0, _arg1, _arg2, _arg3)


var _pixbuf gdkpixbuf.Pixbuf // out

_pixbuf = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gdkpixbuf.Pixbuf)

return _pixbuf
}
	
	// RenderIconPixbuf: a convenience function that uses the theme engine and style
// settings for @widget to look up @stock_id and render it to a pixbuf.
// @stock_id should be a stock icon ID such as K_STOCK_OPEN or K_STOCK_OK. @size
// should be a size such as K_ICON_SIZE_MENU.
// 
// The pixels in the returned Pixbuf are shared with the rest of the application
// and should not be modified. The pixbuf should be freed after use with
// g_object_unref().
	func (w Widget) RenderIconPixbuf(stockId string, size int) gdkpixbuf.Pixbuf {
var _arg0 *C.GtkWidget // out
var _arg1 *C.gchar // out
var _arg2 C.GtkIconSize // out
var _cret *C.GdkPixbuf // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (*C.gchar)(C.CString(stockId))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.GtkIconSize)(size)

_cret = C.gtk_widget_render_icon_pixbuf(_arg0, _arg1, _arg2)


var _pixbuf gdkpixbuf.Pixbuf // out

_pixbuf = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gdkpixbuf.Pixbuf)

return _pixbuf
}
	
	// Reparent moves a widget from one Container to another, handling reference
// count issues to avoid destroying the widget.
	func (w Widget) Reparent(newParent WidgetClass)  {
var _arg0 *C.GtkWidget // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(newParent.Native()))

C.gtk_widget_reparent(_arg0, _arg1)
}
	
	// ResetRCStyles: reset the styles of @widget and all descendents, so when they
// are looked up again, they get the correct values for the currently loaded RC
// file settings.
// 
// This function is not useful for applications.
	func (w Widget) ResetRCStyles()  {
var _arg0 *C.GtkWidget // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

C.gtk_widget_reset_rc_styles(_arg0)
}
	
	// ResetStyle updates the style context of @widget and all descendants by
// updating its widget path. Containers may want to use this on a child when
// reordering it in a way that a different style might apply to it. See also
// gtk_container_get_path_for_child().
	func (w Widget) ResetStyle()  {
var _arg0 *C.GtkWidget // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

C.gtk_widget_reset_style(_arg0)
}
	
	// SetAccelPath: given an accelerator group, @accel_group, and an accelerator
// path, @accel_path, sets up an accelerator in @accel_group so whenever the key
// binding that is defined for @accel_path is pressed, @widget will be
// activated. This removes any accelerators (for any accelerator group)
// installed by previous calls to gtk_widget_set_accel_path(). Associating
// accelerators with paths allows them to be modified by the user and the
// modifications to be saved for future use. (See gtk_accel_map_save().)
// 
// This function is a low level function that would most likely be used by a
// menu creation system like UIManager. If you use UIManager, setting up
// accelerator paths will be done automatically.
// 
// Even when you you aren’t using UIManager, if you only want to set up
// accelerators on menu items gtk_menu_item_set_accel_path() provides a somewhat
// more convenient interface.
// 
// Note that @accel_path string will be stored in a #GQuark. Therefore, if you
// pass a static string, you can save some memory by interning it first with
// g_intern_static_string().
	func (w Widget) SetAccelPath(accelPath string, accelGroup AccelGroupClass)  {
var _arg0 *C.GtkWidget // out
var _arg1 *C.gchar // out
var _arg2 *C.GtkAccelGroup // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (*C.gchar)(C.CString(accelPath))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.GtkAccelGroup)(unsafe.Pointer(accelGroup.Native()))

C.gtk_widget_set_accel_path(_arg0, _arg1, _arg2)
}
	
	// SetAppPaintable sets whether the application intends to draw on the widget in
// an Widget::draw handler.
// 
// This is a hint to the widget and does not affect the behavior of the GTK+
// core; many widgets ignore this flag entirely. For widgets that do pay
// attention to the flag, such as EventBox and Window, the effect is to suppress
// default themed drawing of the widget's background. (Children of the widget
// will still be drawn.) The application is then entirely responsible for
// drawing the widget background.
// 
// Note that the background is still drawn when the widget is mapped.
	func (w Widget) SetAppPaintable(appPaintable bool)  {
var _arg0 *C.GtkWidget // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
if appPaintable { _arg1 = C.TRUE }

C.gtk_widget_set_app_paintable(_arg0, _arg1)
}
	
	// SetCanDefault specifies whether @widget can be a default widget. See
// gtk_widget_grab_default() for details about the meaning of “default”.
	func (w Widget) SetCanDefault(canDefault bool)  {
var _arg0 *C.GtkWidget // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
if canDefault { _arg1 = C.TRUE }

C.gtk_widget_set_can_default(_arg0, _arg1)
}
	
	// SetCanFocus specifies whether @widget can own the input focus. See
// gtk_widget_grab_focus() for actually setting the input focus on a widget.
	func (w Widget) SetCanFocus(canFocus bool)  {
var _arg0 *C.GtkWidget // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
if canFocus { _arg1 = C.TRUE }

C.gtk_widget_set_can_focus(_arg0, _arg1)
}
	
	// SetChildVisible sets whether @widget should be mapped along with its when its
// parent is mapped and @widget has been shown with gtk_widget_show().
// 
// The child visibility can be set for widget before it is added to a container
// with gtk_widget_set_parent(), to avoid mapping children unnecessary before
// immediately unmapping them. However it will be reset to its default state of
// true when the widget is removed from a container.
// 
// Note that changing the child visibility of a widget does not queue a resize
// on the widget. Most of the time, the size of a widget is computed from all
// visible children, whether or not they are mapped. If this is not the case,
// the container can queue a resize itself.
// 
// This function is only useful for container implementations and never should
// be called by an application.
	func (w Widget) SetChildVisible(isVisible bool)  {
var _arg0 *C.GtkWidget // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
if isVisible { _arg1 = C.TRUE }

C.gtk_widget_set_child_visible(_arg0, _arg1)
}
	
	// SetCompositeName sets a widgets composite name. The widget must be a
// composite child of its parent; see gtk_widget_push_composite_child().
	func (w Widget) SetCompositeName(name string)  {
var _arg0 *C.GtkWidget // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (*C.gchar)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_widget_set_composite_name(_arg0, _arg1)
}
	
	// SetDeviceEnabled enables or disables a Device to interact with @widget and
// all its children.
// 
// It does so by descending through the Window hierarchy and enabling the same
// mask that is has for core events (i.e. the one that gdk_window_get_events()
// returns).
	func (w Widget) SetDeviceEnabled(device gdk.DeviceClass, enabled bool)  {
var _arg0 *C.GtkWidget // out
var _arg1 *C.GdkDevice // out
var _arg2 C.gboolean // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (*C.GdkDevice)(unsafe.Pointer(device.Native()))
if enabled { _arg2 = C.TRUE }

C.gtk_widget_set_device_enabled(_arg0, _arg1, _arg2)
}
	
	// SetDeviceEvents sets the device event mask (see EventMask) for a widget. The
// event mask determines which events a widget will receive from @device. Keep
// in mind that different widgets have different default event masks, and by
// changing the event mask you may disrupt a widget’s functionality, so be
// careful. This function must be called while a widget is unrealized. Consider
// gtk_widget_add_device_events() for widgets that are already realized, or if
// you want to preserve the existing event mask. This function can’t be used
// with windowless widgets (which return false from
// gtk_widget_get_has_window()); to get events on those widgets, place them
// inside a EventBox and receive events on the event box.
	func (w Widget) SetDeviceEvents(device gdk.DeviceClass, events gdk.EventMask)  {
var _arg0 *C.GtkWidget // out
var _arg1 *C.GdkDevice // out
var _arg2 C.GdkEventMask // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (*C.GdkDevice)(unsafe.Pointer(device.Native()))
_arg2 = (C.GdkEventMask)(events)

C.gtk_widget_set_device_events(_arg0, _arg1, _arg2)
}
	
	// SetDirection sets the reading direction on a particular widget. This
// direction controls the primary direction for widgets containing text, and
// also the direction in which the children of a container are packed. The
// ability to set the direction is present in order so that correct localization
// into languages with right-to-left reading directions can be done. Generally,
// applications will let the default reading direction present, except for
// containers where the containers are arranged in an order that is explicitly
// visual rather than logical (such as buttons for text justification).
// 
// If the direction is set to GTK_TEXT_DIR_NONE, then the value set by
// gtk_widget_set_default_direction() will be used.
	func (w Widget) SetDirection(dir TextDirection)  {
var _arg0 *C.GtkWidget // out
var _arg1 C.GtkTextDirection // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (C.GtkTextDirection)(dir)

C.gtk_widget_set_direction(_arg0, _arg1)
}
	
	// SetDoubleBuffered widgets are double buffered by default; you can use this
// function to turn off the buffering. “Double buffered” simply means that
// gdk_window_begin_draw_frame() and gdk_window_end_draw_frame() are called
// automatically around expose events sent to the widget.
// gdk_window_begin_draw_frame() diverts all drawing to a widget's window to an
// offscreen buffer, and gdk_window_end_draw_frame() draws the buffer to the
// screen. The result is that users see the window update in one smooth step,
// and don’t see individual graphics primitives being rendered.
// 
// In very simple terms, double buffered widgets don’t flicker, so you would
// only use this function to turn off double buffering if you had special needs
// and really knew what you were doing.
// 
// Note: if you turn off double-buffering, you have to handle expose events,
// since even the clearing to the background color or pixmap will not happen
// automatically (as it is done in gdk_window_begin_draw_frame()).
// 
// In 3.10 GTK and GDK have been restructured for translucent drawing. Since
// then expose events for double-buffered widgets are culled into a single event
// to the toplevel GDK window. If you now unset double buffering, you will cause
// a separate rendering pass for every widget. This will likely cause rendering
// problems - in particular related to stacking - and usually increases
// rendering times significantly.
	func (w Widget) SetDoubleBuffered(doubleBuffered bool)  {
var _arg0 *C.GtkWidget // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
if doubleBuffered { _arg1 = C.TRUE }

C.gtk_widget_set_double_buffered(_arg0, _arg1)
}
	
	// SetEvents sets the event mask (see EventMask) for a widget. The event mask
// determines which events a widget will receive. Keep in mind that different
// widgets have different default event masks, and by changing the event mask
// you may disrupt a widget’s functionality, so be careful. This function must
// be called while a widget is unrealized. Consider gtk_widget_add_events() for
// widgets that are already realized, or if you want to preserve the existing
// event mask. This function can’t be used with widgets that have no window.
// (See gtk_widget_get_has_window()). To get events on those widgets, place them
// inside a EventBox and receive events on the event box.
	func (w Widget) SetEvents(events int)  {
var _arg0 *C.GtkWidget // out
var _arg1 C.gint // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (C.gint)(events)

C.gtk_widget_set_events(_arg0, _arg1)
}
	
	// SetFocusOnClick sets whether the widget should grab focus when it is clicked
// with the mouse. Making mouse clicks not grab focus is useful in places like
// toolbars where you don’t want the keyboard focus removed from the main area
// of the application.
	func (w Widget) SetFocusOnClick(focusOnClick bool)  {
var _arg0 *C.GtkWidget // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
if focusOnClick { _arg1 = C.TRUE }

C.gtk_widget_set_focus_on_click(_arg0, _arg1)
}
	
	// SetFontMap sets the font map to use for Pango rendering. When not set, the
// widget will inherit the font map from its parent.
	func (w Widget) SetFontMap(fontMap pango.FontMapClass)  {
var _arg0 *C.GtkWidget // out
var _arg1 *C.PangoFontMap // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (*C.PangoFontMap)(unsafe.Pointer(fontMap.Native()))

C.gtk_widget_set_font_map(_arg0, _arg1)
}
	
	// SetFontOptions sets the #cairo_font_options_t used for Pango rendering in
// this widget. When not set, the default font options for the Screen will be
// used.
	func (w Widget) SetFontOptions(options *cairo.FontOptions)  {
var _arg0 *C.GtkWidget // out
var _arg1 *C.cairo_font_options_t // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (*C.cairo_font_options_t)(unsafe.Pointer(options.Native()))

C.gtk_widget_set_font_options(_arg0, _arg1)
}
	
	// SetHalign sets the horizontal alignment of @widget. See the Widget:halign
// property.
	func (w Widget) SetHalign(align Align)  {
var _arg0 *C.GtkWidget // out
var _arg1 C.GtkAlign // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (C.GtkAlign)(align)

C.gtk_widget_set_halign(_arg0, _arg1)
}
	
	// SetHasTooltip sets the has-tooltip property on @widget to @has_tooltip. See
// Widget:has-tooltip for more information.
	func (w Widget) SetHasTooltip(hasTooltip bool)  {
var _arg0 *C.GtkWidget // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
if hasTooltip { _arg1 = C.TRUE }

C.gtk_widget_set_has_tooltip(_arg0, _arg1)
}
	
	// SetHasWindow specifies whether @widget has a Window of its own. Note that all
// realized widgets have a non-nil “window” pointer (gtk_widget_get_window()
// never returns a nil window when a widget is realized), but for many of them
// it’s actually the Window of one of its parent widgets. Widgets that do not
// create a window for themselves in Widget::realize must announce this by
// calling this function with @has_window = false.
// 
// This function should only be called by widget implementations, and they
// should call it in their init() function.
	func (w Widget) SetHasWindow(hasWindow bool)  {
var _arg0 *C.GtkWidget // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
if hasWindow { _arg1 = C.TRUE }

C.gtk_widget_set_has_window(_arg0, _arg1)
}
	
	// SetHexpand sets whether the widget would like any available extra horizontal
// space. When a user resizes a Window, widgets with expand=TRUE generally
// receive the extra space. For example, a list or scrollable area or document
// in your window would often be set to expand.
// 
// Call this function to set the expand flag if you would like your widget to
// become larger horizontally when the window has extra room.
// 
// By default, widgets automatically expand if any of their children want to
// expand. (To see if a widget will automatically expand given its current
// children and state, call gtk_widget_compute_expand(). A container can decide
// how the expandability of children affects the expansion of the container by
// overriding the compute_expand virtual method on Widget.).
// 
// Setting hexpand explicitly with this function will override the automatic
// expand behavior.
// 
// This function forces the widget to expand or not to expand, regardless of
// children. The override occurs because gtk_widget_set_hexpand() sets the
// hexpand-set property (see gtk_widget_set_hexpand_set()) which causes the
// widget’s hexpand value to be used, rather than looking at children and widget
// state.
	func (w Widget) SetHexpand(expand bool)  {
var _arg0 *C.GtkWidget // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
if expand { _arg1 = C.TRUE }

C.gtk_widget_set_hexpand(_arg0, _arg1)
}
	
	// SetHexpandSet sets whether the hexpand flag (see gtk_widget_get_hexpand())
// will be used.
// 
// The hexpand-set property will be set automatically when you call
// gtk_widget_set_hexpand() to set hexpand, so the most likely reason to use
// this function would be to unset an explicit expand flag.
// 
// If hexpand is set, then it overrides any computed expand value based on child
// widgets. If hexpand is not set, then the expand value depends on whether any
// children of the widget would like to expand.
// 
// There are few reasons to use this function, but it’s here for completeness
// and consistency.
	func (w Widget) SetHexpandSet(set bool)  {
var _arg0 *C.GtkWidget // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
if set { _arg1 = C.TRUE }

C.gtk_widget_set_hexpand_set(_arg0, _arg1)
}
	
	// SetMapped marks the widget as being mapped.
// 
// This function should only ever be called in a derived widget's “map” or
// “unmap” implementation.
	func (w Widget) SetMapped(mapped bool)  {
var _arg0 *C.GtkWidget // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
if mapped { _arg1 = C.TRUE }

C.gtk_widget_set_mapped(_arg0, _arg1)
}
	
	// SetMarginBottom sets the bottom margin of @widget. See the
// Widget:margin-bottom property.
	func (w Widget) SetMarginBottom(margin int)  {
var _arg0 *C.GtkWidget // out
var _arg1 C.gint // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (C.gint)(margin)

C.gtk_widget_set_margin_bottom(_arg0, _arg1)
}
	
	// SetMarginEnd sets the end margin of @widget. See the Widget:margin-end
// property.
	func (w Widget) SetMarginEnd(margin int)  {
var _arg0 *C.GtkWidget // out
var _arg1 C.gint // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (C.gint)(margin)

C.gtk_widget_set_margin_end(_arg0, _arg1)
}
	
	// SetMarginLeft sets the left margin of @widget. See the Widget:margin-left
// property.
	func (w Widget) SetMarginLeft(margin int)  {
var _arg0 *C.GtkWidget // out
var _arg1 C.gint // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (C.gint)(margin)

C.gtk_widget_set_margin_left(_arg0, _arg1)
}
	
	// SetMarginRight sets the right margin of @widget. See the Widget:margin-right
// property.
	func (w Widget) SetMarginRight(margin int)  {
var _arg0 *C.GtkWidget // out
var _arg1 C.gint // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (C.gint)(margin)

C.gtk_widget_set_margin_right(_arg0, _arg1)
}
	
	// SetMarginStart sets the start margin of @widget. See the Widget:margin-start
// property.
	func (w Widget) SetMarginStart(margin int)  {
var _arg0 *C.GtkWidget // out
var _arg1 C.gint // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (C.gint)(margin)

C.gtk_widget_set_margin_start(_arg0, _arg1)
}
	
	// SetMarginTop sets the top margin of @widget. See the Widget:margin-top
// property.
	func (w Widget) SetMarginTop(margin int)  {
var _arg0 *C.GtkWidget // out
var _arg1 C.gint // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (C.gint)(margin)

C.gtk_widget_set_margin_top(_arg0, _arg1)
}
	
	// SetName widgets can be named, which allows you to refer to them from a CSS
// file. You can apply a style to widgets with a particular name in the CSS
// file. See the documentation for the CSS syntax (on the same page as the docs
// for StyleContext).
// 
// Note that the CSS syntax has certain special characters to delimit and
// represent elements in a selector (period, #, >, *...), so using these will
// make your widget impossible to match by name. Any combination of alphanumeric
// symbols, dashes and underscores will suffice.
	func (w Widget) SetName(name string)  {
var _arg0 *C.GtkWidget // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (*C.gchar)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_widget_set_name(_arg0, _arg1)
}
	
	// SetNoShowAll sets the Widget:no-show-all property, which determines whether
// calls to gtk_widget_show_all() will affect this widget.
// 
// This is mostly for use in constructing widget hierarchies with externally
// controlled visibility, see UIManager.
	func (w Widget) SetNoShowAll(noShowAll bool)  {
var _arg0 *C.GtkWidget // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
if noShowAll { _arg1 = C.TRUE }

C.gtk_widget_set_no_show_all(_arg0, _arg1)
}
	
	// SetOpacity: request the @widget to be rendered partially transparent, with
// opacity 0 being fully transparent and 1 fully opaque. (Opacity values are
// clamped to the [0,1] range.). This works on both toplevel widget, and child
// widgets, although there are some limitations:
// 
// For toplevel widgets this depends on the capabilities of the windowing
// system. On X11 this has any effect only on X screens with a compositing
// manager running. See gtk_widget_is_composited(). On Windows it should work
// always, although setting a window’s opacity after the window has been shown
// causes it to flicker once on Windows.
// 
// For child widgets it doesn’t work if any affected widget has a native window,
// or disables double buffering.
	func (w Widget) SetOpacity(opacity float64)  {
var _arg0 *C.GtkWidget // out
var _arg1 C.double // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (C.double)(opacity)

C.gtk_widget_set_opacity(_arg0, _arg1)
}
	
	// SetParent: this function is useful only when implementing subclasses of
// Container. Sets the container as the parent of @widget, and takes care of
// some details such as updating the state and style of the child to reflect its
// new location. The opposite function is gtk_widget_unparent().
	func (w Widget) SetParent(parent WidgetClass)  {
var _arg0 *C.GtkWidget // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(parent.Native()))

C.gtk_widget_set_parent(_arg0, _arg1)
}
	
	// SetParentWindow sets a non default parent window for @widget.
// 
// For Window classes, setting a @parent_window effects whether the window is a
// toplevel window or can be embedded into other widgets.
// 
// For Window classes, this needs to be called before the window is realized.
	func (w Widget) SetParentWindow(parentWindow gdk.WindowClass)  {
var _arg0 *C.GtkWidget // out
var _arg1 *C.GdkWindow // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (*C.GdkWindow)(unsafe.Pointer(parentWindow.Native()))

C.gtk_widget_set_parent_window(_arg0, _arg1)
}
	
	// SetRealized marks the widget as being realized. This function must only be
// called after all Windows for the @widget have been created and registered.
// 
// This function should only ever be called in a derived widget's “realize” or
// “unrealize” implementation.
	func (w Widget) SetRealized(realized bool)  {
var _arg0 *C.GtkWidget // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
if realized { _arg1 = C.TRUE }

C.gtk_widget_set_realized(_arg0, _arg1)
}
	
	// SetReceivesDefault specifies whether @widget will be treated as the default
// widget within its toplevel when it has the focus, even if another widget is
// the default.
// 
// See gtk_widget_grab_default() for details about the meaning of “default”.
	func (w Widget) SetReceivesDefault(receivesDefault bool)  {
var _arg0 *C.GtkWidget // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
if receivesDefault { _arg1 = C.TRUE }

C.gtk_widget_set_receives_default(_arg0, _arg1)
}
	
	// SetRedrawOnAllocate sets whether the entire widget is queued for drawing when
// its size allocation changes. By default, this setting is true and the entire
// widget is redrawn on every size change. If your widget leaves the upper left
// unchanged when made bigger, turning this setting off will improve
// performance.
// 
// Note that for widgets where gtk_widget_get_has_window() is false setting this
// flag to false turns off all allocation on resizing: the widget will not even
// redraw if its position changes; this is to allow containers that don’t draw
// anything to avoid excess invalidations. If you set this flag on a widget with
// no window that does draw on @widget->window, you are responsible for
// invalidating both the old and new allocation of the widget when the widget is
// moved and responsible for invalidating regions newly when the widget
// increases size.
	func (w Widget) SetRedrawOnAllocate(redrawOnAllocate bool)  {
var _arg0 *C.GtkWidget // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
if redrawOnAllocate { _arg1 = C.TRUE }

C.gtk_widget_set_redraw_on_allocate(_arg0, _arg1)
}
	
	// SetSensitive sets the sensitivity of a widget. A widget is sensitive if the
// user can interact with it. Insensitive widgets are “grayed out” and the user
// can’t interact with them. Insensitive widgets are known as “inactive”,
// “disabled”, or “ghosted” in some other toolkits.
	func (w Widget) SetSensitive(sensitive bool)  {
var _arg0 *C.GtkWidget // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
if sensitive { _arg1 = C.TRUE }

C.gtk_widget_set_sensitive(_arg0, _arg1)
}
	
	// SetSizeRequest sets the minimum size of a widget; that is, the widget’s size
// request will be at least @width by @height. You can use this function to
// force a widget to be larger than it normally would be.
// 
// In most cases, gtk_window_set_default_size() is a better choice for toplevel
// windows than this function; setting the default size will still allow users
// to shrink the window. Setting the size request will force them to leave the
// window at least as large as the size request. When dealing with window sizes,
// gtk_window_set_geometry_hints() can be a useful function as well.
// 
// Note the inherent danger of setting any fixed size - themes, translations
// into other languages, different fonts, and user action can all change the
// appropriate size for a given widget. So, it's basically impossible to
// hardcode a size that will always be correct.
// 
// The size request of a widget is the smallest size a widget can accept while
// still functioning well and drawing itself correctly. However in some strange
// cases a widget may be allocated less than its requested size, and in many
// cases a widget may be allocated more space than it requested.
// 
// If the size request in a given direction is -1 (unset), then the “natural”
// size request of the widget will be used instead.
// 
// The size request set here does not include any margin from the Widget
// properties margin-left, margin-right, margin-top, and margin-bottom, but it
// does include pretty much all other padding or border properties set by any
// subclass of Widget.
	func (w Widget) SetSizeRequest(width int, height int)  {
var _arg0 *C.GtkWidget // out
var _arg1 C.gint // out
var _arg2 C.gint // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (C.gint)(width)
_arg2 = (C.gint)(height)

C.gtk_widget_set_size_request(_arg0, _arg1, _arg2)
}
	
	// SetState: this function is for use in widget implementations. Sets the state
// of a widget (insensitive, prelighted, etc.) Usually you should set the state
// using wrapper functions such as gtk_widget_set_sensitive().
	func (w Widget) SetState(state StateType)  {
var _arg0 *C.GtkWidget // out
var _arg1 C.GtkStateType // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (C.GtkStateType)(state)

C.gtk_widget_set_state(_arg0, _arg1)
}
	
	// SetStateFlags: this function is for use in widget implementations. Turns on
// flag values in the current widget state (insensitive, prelighted, etc.).
// 
// This function accepts the values GTK_STATE_FLAG_DIR_LTR and
// GTK_STATE_FLAG_DIR_RTL but ignores them. If you want to set the widget's
// direction, use gtk_widget_set_direction().
// 
// It is worth mentioning that any other state than GTK_STATE_FLAG_INSENSITIVE,
// will be propagated down to all non-internal children if @widget is a
// Container, while GTK_STATE_FLAG_INSENSITIVE itself will be propagated down to
// all Container children by different means than turning on the state flag down
// the hierarchy, both gtk_widget_get_state_flags() and
// gtk_widget_is_sensitive() will make use of these.
	func (w Widget) SetStateFlags(flags StateFlags, clear bool)  {
var _arg0 *C.GtkWidget // out
var _arg1 C.GtkStateFlags // out
var _arg2 C.gboolean // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (C.GtkStateFlags)(flags)
if clear { _arg2 = C.TRUE }

C.gtk_widget_set_state_flags(_arg0, _arg1, _arg2)
}
	
	// SetStyle: used to set the Style for a widget (@widget->style). Since GTK 3,
// this function does nothing, the passed in style is ignored.
	func (w Widget) SetStyle(style StyleClass)  {
var _arg0 *C.GtkWidget // out
var _arg1 *C.GtkStyle // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (*C.GtkStyle)(unsafe.Pointer(style.Native()))

C.gtk_widget_set_style(_arg0, _arg1)
}
	
	// SetSupportMultidevice enables or disables multiple pointer awareness. If this
// setting is true, @widget will start receiving multiple, per device
// enter/leave events. Note that if custom Windows are created in
// Widget::realize, gdk_window_set_support_multidevice() will have to be called
// manually on them.
	func (w Widget) SetSupportMultidevice(supportMultidevice bool)  {
var _arg0 *C.GtkWidget // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
if supportMultidevice { _arg1 = C.TRUE }

C.gtk_widget_set_support_multidevice(_arg0, _arg1)
}
	
	// SetTooltipMarkup sets @markup as the contents of the tooltip, which is marked
// up with the [Pango text markup language][PangoMarkupFormat].
// 
// This function will take care of setting Widget:has-tooltip to true and of the
// default handler for the Widget::query-tooltip signal.
// 
// See also the Widget:tooltip-markup property and gtk_tooltip_set_markup().
	func (w Widget) SetTooltipMarkup(markup string)  {
var _arg0 *C.GtkWidget // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (*C.gchar)(C.CString(markup))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_widget_set_tooltip_markup(_arg0, _arg1)
}
	
	// SetTooltipText sets @text as the contents of the tooltip. This function will
// take care of setting Widget:has-tooltip to true and of the default handler
// for the Widget::query-tooltip signal.
// 
// See also the Widget:tooltip-text property and gtk_tooltip_set_text().
	func (w Widget) SetTooltipText(text string)  {
var _arg0 *C.GtkWidget // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (*C.gchar)(C.CString(text))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_widget_set_tooltip_text(_arg0, _arg1)
}
	
	// SetTooltipWindow replaces the default window used for displaying tooltips
// with @custom_window. GTK+ will take care of showing and hiding @custom_window
// at the right moment, to behave likewise as the default tooltip window. If
// @custom_window is nil, the default tooltip window will be used.
	func (w Widget) SetTooltipWindow(customWindow WindowClass)  {
var _arg0 *C.GtkWidget // out
var _arg1 *C.GtkWindow // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (*C.GtkWindow)(unsafe.Pointer(customWindow.Native()))

C.gtk_widget_set_tooltip_window(_arg0, _arg1)
}
	
	// SetValign sets the vertical alignment of @widget. See the Widget:valign
// property.
	func (w Widget) SetValign(align Align)  {
var _arg0 *C.GtkWidget // out
var _arg1 C.GtkAlign // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (C.GtkAlign)(align)

C.gtk_widget_set_valign(_arg0, _arg1)
}
	
	// SetVexpand sets whether the widget would like any available extra vertical
// space.
// 
// See gtk_widget_set_hexpand() for more detail.
	func (w Widget) SetVexpand(expand bool)  {
var _arg0 *C.GtkWidget // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
if expand { _arg1 = C.TRUE }

C.gtk_widget_set_vexpand(_arg0, _arg1)
}
	
	// SetVexpandSet sets whether the vexpand flag (see gtk_widget_get_vexpand())
// will be used.
// 
// See gtk_widget_set_hexpand_set() for more detail.
	func (w Widget) SetVexpandSet(set bool)  {
var _arg0 *C.GtkWidget // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
if set { _arg1 = C.TRUE }

C.gtk_widget_set_vexpand_set(_arg0, _arg1)
}
	
	// SetVisible sets the visibility state of @widget. Note that setting this to
// true doesn’t mean the widget is actually viewable, see
// gtk_widget_get_visible().
// 
// This function simply calls gtk_widget_show() or gtk_widget_hide() but is
// nicer to use when the visibility of the widget depends on some condition.
	func (w Widget) SetVisible(visible bool)  {
var _arg0 *C.GtkWidget // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
if visible { _arg1 = C.TRUE }

C.gtk_widget_set_visible(_arg0, _arg1)
}
	
	// SetVisual sets the visual that should be used for by widget and its children
// for creating Windows. The visual must be on the same Screen as returned by
// gtk_widget_get_screen(), so handling the Widget::screen-changed signal is
// necessary.
// 
// Setting a new @visual will not cause @widget to recreate its windows, so you
// should call this function before @widget is realized.
	func (w Widget) SetVisual(visual gdk.VisualClass)  {
var _arg0 *C.GtkWidget // out
var _arg1 *C.GdkVisual // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (*C.GdkVisual)(unsafe.Pointer(visual.Native()))

C.gtk_widget_set_visual(_arg0, _arg1)
}
	
	// SetWindow sets a widget’s window. This function should only be used in a
// widget’s Widget::realize implementation. The window passed is usually either
// new window created with gdk_window_new(), or the window of its parent widget
// as returned by gtk_widget_get_parent_window().
// 
// Widgets must indicate whether they will create their own Window by calling
// gtk_widget_set_has_window(). This is usually done in the widget’s init()
// function.
// 
// Note that this function does not add any reference to @window.
	func (w Widget) SetWindow(window gdk.WindowClass)  {
var _arg0 *C.GtkWidget // out
var _arg1 *C.GdkWindow // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (*C.GdkWindow)(unsafe.Pointer(window.Native()))

C.gtk_widget_set_window(_arg0, _arg1)
}
	
	// ShapeCombineRegion sets a shape for this widget’s GDK window. This allows for
// transparent windows etc., see gdk_window_shape_combine_region() for more
// information.
	func (w Widget) ShapeCombineRegion(region *cairo.Region)  {
var _arg0 *C.GtkWidget // out
var _arg1 *C.cairo_region_t // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (*C.cairo_region_t)(unsafe.Pointer(region.Native()))

C.gtk_widget_shape_combine_region(_arg0, _arg1)
}
	
	// Show flags a widget to be displayed. Any widget that isn’t shown will not
// appear on the screen. If you want to show all the widgets in a container,
// it’s easier to call gtk_widget_show_all() on the container, instead of
// individually showing the widgets.
// 
// Remember that you have to show the containers containing a widget, in
// addition to the widget itself, before it will appear onscreen.
// 
// When a toplevel container is shown, it is immediately realized and mapped;
// other shown widgets are realized and mapped when their toplevel container is
// realized and mapped.
	func (w Widget) Show()  {
var _arg0 *C.GtkWidget // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

C.gtk_widget_show(_arg0)
}
	
	// ShowAll: recursively shows a widget, and any child widgets (if the widget is
// a container).
	func (w Widget) ShowAll()  {
var _arg0 *C.GtkWidget // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

C.gtk_widget_show_all(_arg0)
}
	
	// ShowNow shows a widget. If the widget is an unmapped toplevel widget (i.e. a
// Window that has not yet been shown), enter the main loop and wait for the
// window to actually be mapped. Be careful; because the main loop is running,
// anything can happen during this function.
	func (w Widget) ShowNow()  {
var _arg0 *C.GtkWidget // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

C.gtk_widget_show_now(_arg0)
}
	
	// SizeRequest: this function is typically used when implementing a Container
// subclass. Obtains the preferred size of a widget. The container uses this
// information to arrange its child widgets and decide what size allocations to
// give them with gtk_widget_size_allocate().
// 
// You can also call this function from an application, with some caveats. Most
// notably, getting a size request requires the widget to be associated with a
// screen, because font information may be needed. Multihead-aware applications
// should keep this in mind.
// 
// Also remember that the size request is not necessarily the size a widget will
// actually be allocated.
	func (w Widget) SizeRequest() Requisition {
var _arg0 *C.GtkWidget // out
var _requisition Requisition

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

C.gtk_widget_size_request(_arg0, (*C.GtkRequisition)(unsafe.Pointer(&_requisition)))





return _requisition
}
	
	// StyleAttach: this function attaches the widget’s Style to the widget's
// Window. It is a replacement for
// 
//    widget->style = gtk_style_attach (widget->style, widget->window);
// 
// and should only ever be called in a derived widget’s “realize” implementation
// which does not chain up to its parent class' “realize” implementation,
// because one of the parent classes (finally Widget) would attach the style
// itself.
	func (w Widget) StyleAttach()  {
var _arg0 *C.GtkWidget // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

C.gtk_widget_style_attach(_arg0)
}
	
	// StyleGetProperty gets the value of a style property of @widget.
	func (w Widget) StyleGetProperty(propertyName string, value **externglib.Value)  {
var _arg0 *C.GtkWidget // out
var _arg1 *C.gchar // out
var _arg2 *C.GValue // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (*C.gchar)(C.CString(propertyName))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.GValue)(value.GValue)

C.gtk_widget_style_get_property(_arg0, _arg1, _arg2)
}
	
	// ThawChildNotify reverts the effect of a previous call to
// gtk_widget_freeze_child_notify(). This causes all queued Widget::child-notify
// signals on @widget to be emitted.
	func (w Widget) ThawChildNotify()  {
var _arg0 *C.GtkWidget // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

C.gtk_widget_thaw_child_notify(_arg0)
}
	
	// TranslateCoordinates: translate coordinates relative to @src_widget’s
// allocation to coordinates relative to @dest_widget’s allocations. In order to
// perform this operation, both widgets must be realized, and must share a
// common toplevel.
	func (s Widget) TranslateCoordinates(destWidget WidgetClass, srcX int, srcY int) (destX int, destY int, ok bool) {
var _arg0 *C.GtkWidget // out
var _arg1 *C.GtkWidget // out
var _arg2 C.gint // out
var _arg3 C.gint // out
var _arg4 C.gint // in
var _arg5 C.gint // in
var _cret C.gboolean // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(destWidget.Native()))
_arg2 = (C.gint)(srcX)
_arg3 = (C.gint)(srcY)

_cret = C.gtk_widget_translate_coordinates(_arg0, _arg1, _arg2, _arg3, &_arg4, &_arg5)


var _destX int // out
var _destY int // out
var _ok bool // out

_destX = (int)(_arg4)
_destY = (int)(_arg5)
if _cret != 0 { _ok = true }

return _destX, _destY, _ok
}
	
	// TriggerTooltipQuery triggers a tooltip query on the display where the
// toplevel of @widget is located. See gtk_tooltip_trigger_tooltip_query() for
// more information.
	func (w Widget) TriggerTooltipQuery()  {
var _arg0 *C.GtkWidget // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

C.gtk_widget_trigger_tooltip_query(_arg0)
}
	
	// Unmap: this function is only for use in widget implementations. Causes a
// widget to be unmapped if it’s currently mapped.
	func (w Widget) Unmap()  {
var _arg0 *C.GtkWidget // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

C.gtk_widget_unmap(_arg0)
}
	
	// Unparent: this function is only for use in widget implementations. Should be
// called by implementations of the remove method on Container, to dissociate a
// child from the container.
	func (w Widget) Unparent()  {
var _arg0 *C.GtkWidget // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

C.gtk_widget_unparent(_arg0)
}
	
	// Unrealize: this function is only useful in widget implementations. Causes a
// widget to be unrealized (frees all GDK resources associated with the widget,
// such as @widget->window).
	func (w Widget) Unrealize()  {
var _arg0 *C.GtkWidget // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

C.gtk_widget_unrealize(_arg0)
}
	
	// UnregisterWindow unregisters a Window from the widget that was previously set
// up with gtk_widget_register_window(). You need to call this when the window
// is no longer used by the widget, such as when you destroy it.
	func (w Widget) UnregisterWindow(window gdk.WindowClass)  {
var _arg0 *C.GtkWidget // out
var _arg1 *C.GdkWindow // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (*C.GdkWindow)(unsafe.Pointer(window.Native()))

C.gtk_widget_unregister_window(_arg0, _arg1)
}
	
	// UnsetStateFlags: this function is for use in widget implementations. Turns
// off flag values for the current widget state (insensitive, prelighted, etc.).
// See gtk_widget_set_state_flags().
	func (w Widget) UnsetStateFlags(flags StateFlags)  {
var _arg0 *C.GtkWidget // out
var _arg1 C.GtkStateFlags // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (C.GtkStateFlags)(flags)

C.gtk_widget_unset_state_flags(_arg0, _arg1)
}
	


	// Window: a GtkWindow is a toplevel window which can contain other widgets.
// Windows normally have decorations that are under the control of the windowing
// system and allow the user to manipulate the window (resize it, move it, close
// it,...).
// 
// 
// GtkWindow as GtkBuildable
// 
// The GtkWindow implementation of the Buildable interface supports a custom
// <accel-groups> element, which supports any number of <group> elements
// representing the AccelGroup objects you want to add to your window
// (synonymous with gtk_window_add_accel_group().
// 
// It also supports the <initial-focus> element, whose name property names the
// widget to receive the focus when the window is mapped.
// 
// An example of a UI definition fragment with accel groups:
// 
//    <object class="GtkWindow">
//      <accel-groups>
//        <group name="accelgroup1"/>
//      </accel-groups>
//      <initial-focus name="thunderclap"/>
//    </object>
// 
//    ...
// 
//    <object class="GtkAccelGroup" id="accelgroup1"/>
// 
// The GtkWindow implementation of the Buildable interface supports setting a
// child as the titlebar by specifying “titlebar” as the “type” attribute of a
// <child> element.
// 
// CSS nodes
// 
//    window.background
//    ├── decoration
//    ├── <titlebar child>.titlebar [.default-decoration]
//    ╰── <child>
// 
// GtkWindow has a main CSS node with name window and style class .background,
// and a subnode with name decoration.
// 
// Style classes that are typically used with the main CSS node are .csd (when
// client-side decorations are in use), .solid-csd (for client-side decorations
// without invisible borders), .ssd (used by mutter when rendering server-side
// decorations). GtkWindow also represents window states with the following
// style classes on the main node: .tiled, .maximized, .fullscreen. Specialized
// types of window often add their own discriminating style classes, such as
// .popup or .tooltip.
// 
// GtkWindow adds the .titlebar and .default-decoration style classes to the
// widget that is added as a titlebar child.
	type Window struct {
		Bin
		Buildable
		
	}

	// WindowClass is an interface that the Window class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type WindowClass interface {
		gextras.Objector
		_window()
	}

	func (Window) _window() {}

	
	func marshalWindow(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapWindow(obj), nil
	}
	

	
	// NewWindow creates a new Window, which is a toplevel window that can contain
// other widgets. Nearly always, the type of the window should be
// K_WINDOW_TOPLEVEL. If you’re implementing something like a popup menu from
// scratch (which is a bad idea, just use Menu), you might use K_WINDOW_POPUP.
// K_WINDOW_POPUP is not for dialogs, though in some other toolkits dialogs are
// called “popups”. In GTK+, K_WINDOW_POPUP means a pop-up menu or pop-up
// tooltip. On X11, popup windows are not controlled by the [window
// manager][gtk-X11-arch].
// 
// If you simply want an undecorated window (no window borders), use
// gtk_window_set_decorated(), don’t use K_WINDOW_POPUP.
// 
// All top-level windows created by gtk_window_new() are stored in an internal
// top-level window list. This list can be obtained from
// gtk_window_list_toplevels(). Due to Gtk+ keeping a reference to the window
// internally, gtk_window_new() does not return a reference to the caller.
// 
// To delete a Window, call gtk_widget_destroy().
	func NewWindow(typ WindowType) Window {
var _arg1 C.GtkWindowType // out
var _cret *C.GtkWidget // in

_arg1 = (C.GtkWindowType)(typ)

_cret = C.gtk_window_new(_arg1)


var _window Window // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_window = Window{
Bin: Bin{
Container: Container{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _window
}
	

	
	// ActivateDefault activates the default widget for the window, unless the
// current focused widget has been configured to receive the default action (see
// gtk_widget_set_receives_default()), in which case the focused widget is
// activated.
	func (w Window) ActivateDefault() bool {
var _arg0 *C.GtkWindow // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

_cret = C.gtk_window_activate_default(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ActivateFocus activates the current focused widget within the window.
	func (w Window) ActivateFocus() bool {
var _arg0 *C.GtkWindow // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

_cret = C.gtk_window_activate_focus(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ActivateKey activates mnemonics and accelerators for this Window. This is
// normally called by the default ::key_press_event handler for toplevel
// windows, however in some cases it may be useful to call this directly when
// overriding the standard key handling for a toplevel window.
	func (w Window) ActivateKey(event *gdk.EventKey) bool {
var _arg0 *C.GtkWindow // out
var _arg1 *C.GdkEventKey // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
_arg1 = (*C.GdkEventKey)(unsafe.Pointer(event.Native()))

_cret = C.gtk_window_activate_key(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// AddAccelGroup: associate @accel_group with @window, such that calling
// gtk_accel_groups_activate() on @window will activate accelerators in
// @accel_group.
	func (w Window) AddAccelGroup(accelGroup AccelGroupClass)  {
var _arg0 *C.GtkWindow // out
var _arg1 *C.GtkAccelGroup // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
_arg1 = (*C.GtkAccelGroup)(unsafe.Pointer(accelGroup.Native()))

C.gtk_window_add_accel_group(_arg0, _arg1)
}
	
	// AddMnemonic adds a mnemonic to this window.
	func (w Window) AddMnemonic(keyval uint, target WidgetClass)  {
var _arg0 *C.GtkWindow // out
var _arg1 C.guint // out
var _arg2 *C.GtkWidget // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
_arg1 = (C.guint)(keyval)
_arg2 = (*C.GtkWidget)(unsafe.Pointer(target.Native()))

C.gtk_window_add_mnemonic(_arg0, _arg1, _arg2)
}
	
	// BeginMoveDrag starts moving a window. This function is used if an application
// has window movement grips. When GDK can support it, the window movement will
// be done using the standard mechanism for the [window manager][gtk-X11-arch]
// or windowing system. Otherwise, GDK will try to emulate window movement,
// potentially not all that well, depending on the windowing system.
	func (w Window) BeginMoveDrag(button int, rootX int, rootY int, timestamp uint32)  {
var _arg0 *C.GtkWindow // out
var _arg1 C.gint // out
var _arg2 C.gint // out
var _arg3 C.gint // out
var _arg4 C.guint32 // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
_arg1 = (C.gint)(button)
_arg2 = (C.gint)(rootX)
_arg3 = (C.gint)(rootY)
_arg4 = (C.guint32)(timestamp)

C.gtk_window_begin_move_drag(_arg0, _arg1, _arg2, _arg3, _arg4)
}
	
	// BeginResizeDrag starts resizing a window. This function is used if an
// application has window resizing controls. When GDK can support it, the resize
// will be done using the standard mechanism for the [window
// manager][gtk-X11-arch] or windowing system. Otherwise, GDK will try to
// emulate window resizing, potentially not all that well, depending on the
// windowing system.
	func (w Window) BeginResizeDrag(edge gdk.WindowEdge, button int, rootX int, rootY int, timestamp uint32)  {
var _arg0 *C.GtkWindow // out
var _arg1 C.GdkWindowEdge // out
var _arg2 C.gint // out
var _arg3 C.gint // out
var _arg4 C.gint // out
var _arg5 C.guint32 // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
_arg1 = (C.GdkWindowEdge)(edge)
_arg2 = (C.gint)(button)
_arg3 = (C.gint)(rootX)
_arg4 = (C.gint)(rootY)
_arg5 = (C.guint32)(timestamp)

C.gtk_window_begin_resize_drag(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
}
	
	// Close requests that the window is closed, similar to what happens when a
// window manager close button is clicked.
// 
// This function can be used with close buttons in custom titlebars.
	func (w Window) Close()  {
var _arg0 *C.GtkWindow // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

C.gtk_window_close(_arg0)
}
	
	// Deiconify asks to deiconify (i.e. unminimize) the specified @window. Note
// that you shouldn’t assume the window is definitely deiconified afterward,
// because other entities (e.g. the user or [window manager][gtk-X11-arch]))
// could iconify it again before your code which assumes deiconification gets to
// run.
// 
// You can track iconification via the “window-state-event” signal on Widget.
	func (w Window) Deiconify()  {
var _arg0 *C.GtkWindow // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

C.gtk_window_deiconify(_arg0)
}
	
	// Fullscreen asks to place @window in the fullscreen state. Note that you
// shouldn’t assume the window is definitely full screen afterward, because
// other entities (e.g. the user or [window manager][gtk-X11-arch]) could
// unfullscreen it again, and not all window managers honor requests to
// fullscreen windows. But normally the window will end up fullscreen. Just
// don’t write code that crashes if not.
// 
// You can track the fullscreen state via the “window-state-event” signal on
// Widget.
	func (w Window) Fullscreen()  {
var _arg0 *C.GtkWindow // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

C.gtk_window_fullscreen(_arg0)
}
	
	// FullscreenOnMonitor asks to place @window in the fullscreen state. Note that
// you shouldn't assume the window is definitely full screen afterward.
// 
// You can track the fullscreen state via the "window-state-event" signal on
// Widget.
	func (w Window) FullscreenOnMonitor(screen gdk.ScreenClass, monitor int)  {
var _arg0 *C.GtkWindow // out
var _arg1 *C.GdkScreen // out
var _arg2 C.gint // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
_arg1 = (*C.GdkScreen)(unsafe.Pointer(screen.Native()))
_arg2 = (C.gint)(monitor)

C.gtk_window_fullscreen_on_monitor(_arg0, _arg1, _arg2)
}
	
	// AcceptFocus gets the value set by gtk_window_set_accept_focus().
	func (w Window) AcceptFocus() bool {
var _arg0 *C.GtkWindow // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

_cret = C.gtk_window_get_accept_focus(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Application gets the Application associated with the window (if any).
	func (w Window) Application() Application {
var _arg0 *C.GtkWindow // out
var _cret *C.GtkApplication // in

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

_cret = C.gtk_window_get_application(_arg0)


var _application Application // out

_application = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Application)

return _application
}
	
	// AttachedTo fetches the attach widget for this window. See
// gtk_window_set_attached_to().
	func (w Window) AttachedTo() Widget {
var _arg0 *C.GtkWindow // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

_cret = C.gtk_window_get_attached_to(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// Decorated returns whether the window has been set to have decorations such as
// a title bar via gtk_window_set_decorated().
	func (w Window) Decorated() bool {
var _arg0 *C.GtkWindow // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

_cret = C.gtk_window_get_decorated(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// DefaultSize gets the default size of the window. A value of -1 for the width
// or height indicates that a default size has not been explicitly set for that
// dimension, so the “natural” size of the window will be used.
	func (w Window) DefaultSize() (width int, height int) {
var _arg0 *C.GtkWindow // out
var _arg1 C.gint // in
var _arg2 C.gint // in

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

C.gtk_window_get_default_size(_arg0, &_arg1, &_arg2)

var _width int // out
var _height int // out

_width = (int)(_arg1)
_height = (int)(_arg2)

return _width, _height
}
	
	// DefaultWidget returns the default widget for @window. See
// gtk_window_set_default() for more details.
	func (w Window) DefaultWidget() Widget {
var _arg0 *C.GtkWindow // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

_cret = C.gtk_window_get_default_widget(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// Deletable returns whether the window has been set to have a close button via
// gtk_window_set_deletable().
	func (w Window) Deletable() bool {
var _arg0 *C.GtkWindow // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

_cret = C.gtk_window_get_deletable(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// DestroyWithParent returns whether the window will be destroyed with its
// transient parent. See gtk_window_set_destroy_with_parent ().
	func (w Window) DestroyWithParent() bool {
var _arg0 *C.GtkWindow // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

_cret = C.gtk_window_get_destroy_with_parent(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Focus retrieves the current focused widget within the window. Note that this
// is the widget that would have the focus if the toplevel window focused; if
// the toplevel window is not focused then `gtk_widget_has_focus (widget)` will
// not be true for the widget.
	func (w Window) Focus() Widget {
var _arg0 *C.GtkWindow // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

_cret = C.gtk_window_get_focus(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// FocusOnMap gets the value set by gtk_window_set_focus_on_map().
	func (w Window) FocusOnMap() bool {
var _arg0 *C.GtkWindow // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

_cret = C.gtk_window_get_focus_on_map(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// FocusVisible gets the value of the Window:focus-visible property.
	func (w Window) FocusVisible() bool {
var _arg0 *C.GtkWindow // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

_cret = C.gtk_window_get_focus_visible(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Gravity gets the value set by gtk_window_set_gravity().
	func (w Window) Gravity() gdk.Gravity {
var _arg0 *C.GtkWindow // out
var _cret C.GdkGravity // in

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

_cret = C.gtk_window_get_gravity(_arg0)


var _gravity gdk.Gravity // out

_gravity = gdk.Gravity(_cret)

return _gravity
}
	
	// Group returns the group for @window or the default group, if @window is nil
// or if @window does not have an explicit window group.
	func (w Window) Group() WindowGroup {
var _arg0 *C.GtkWindow // out
var _cret *C.GtkWindowGroup // in

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

_cret = C.gtk_window_get_group(_arg0)


var _windowGroup WindowGroup // out

_windowGroup = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(WindowGroup)

return _windowGroup
}
	
	// HasResizeGrip determines whether the window may have a resize grip.
	func (w Window) HasResizeGrip() bool {
var _arg0 *C.GtkWindow // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

_cret = C.gtk_window_get_has_resize_grip(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// HideTitlebarWhenMaximized returns whether the window has requested to have
// its titlebar hidden when maximized. See
// gtk_window_set_hide_titlebar_when_maximized ().
	func (w Window) HideTitlebarWhenMaximized() bool {
var _arg0 *C.GtkWindow // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

_cret = C.gtk_window_get_hide_titlebar_when_maximized(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Icon gets the value set by gtk_window_set_icon() (or if you've called
// gtk_window_set_icon_list(), gets the first icon in the icon list).
	func (w Window) Icon() gdkpixbuf.Pixbuf {
var _arg0 *C.GtkWindow // out
var _cret *C.GdkPixbuf // in

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

_cret = C.gtk_window_get_icon(_arg0)


var _pixbuf gdkpixbuf.Pixbuf // out

_pixbuf = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdkpixbuf.Pixbuf)

return _pixbuf
}
	
	// IconName returns the name of the themed icon for the window, see
// gtk_window_set_icon_name().
	func (w Window) IconName() string {
var _arg0 *C.GtkWindow // out
var _cret *C.gchar // in

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

_cret = C.gtk_window_get_icon_name(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// MnemonicModifier returns the mnemonic modifier for this window. See
// gtk_window_set_mnemonic_modifier().
	func (w Window) MnemonicModifier() gdk.ModifierType {
var _arg0 *C.GtkWindow // out
var _cret C.GdkModifierType // in

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

_cret = C.gtk_window_get_mnemonic_modifier(_arg0)


var _modifierType gdk.ModifierType // out

_modifierType = gdk.ModifierType(_cret)

return _modifierType
}
	
	// MnemonicsVisible gets the value of the Window:mnemonics-visible property.
	func (w Window) MnemonicsVisible() bool {
var _arg0 *C.GtkWindow // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

_cret = C.gtk_window_get_mnemonics_visible(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Modal returns whether the window is modal. See gtk_window_set_modal().
	func (w Window) Modal() bool {
var _arg0 *C.GtkWindow // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

_cret = C.gtk_window_get_modal(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Opacity fetches the requested opacity for this window. See
// gtk_window_set_opacity().
	func (w Window) Opacity() float64 {
var _arg0 *C.GtkWindow // out
var _cret C.gdouble // in

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

_cret = C.gtk_window_get_opacity(_arg0)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// Position: this function returns the position you need to pass to
// gtk_window_move() to keep @window in its current position. This means that
// the meaning of the returned value varies with window gravity. See
// gtk_window_move() for more details.
// 
// The reliability of this function depends on the windowing system currently in
// use. Some windowing systems, such as Wayland, do not support a global
// coordinate system, and thus the position of the window will always be (0, 0).
// Others, like X11, do not have a reliable way to obtain the geometry of the
// decorations of a window if they are provided by the window manager.
// Additionally, on X11, window manager have been known to mismanage window
// gravity, which result in windows moving even if you use the coordinates of
// the current position as returned by this function.
// 
// If you haven’t changed the window gravity, its gravity will be
// K_GRAVITY_NORTH_WEST. This means that gtk_window_get_position() gets the
// position of the top-left corner of the window manager frame for the window.
// gtk_window_move() sets the position of this same top-left corner.
// 
// If a window has gravity K_GRAVITY_STATIC the window manager frame is not
// relevant, and thus gtk_window_get_position() will always produce accurate
// results. However you can’t use static gravity to do things like place a
// window in a corner of the screen, because static gravity ignores the window
// manager decorations.
// 
// Ideally, this function should return appropriate values if the window has
// client side decorations, assuming that the windowing system supports global
// coordinates.
// 
// In practice, saving the window position should not be left to applications,
// as they lack enough knowledge of the windowing system and the window manager
// state to effectively do so. The appropriate way to implement saving the
// window position is to use a platform-specific protocol, wherever that is
// available.
	func (w Window) Position() (rootX int, rootY int) {
var _arg0 *C.GtkWindow // out
var _arg1 C.gint // in
var _arg2 C.gint // in

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

C.gtk_window_get_position(_arg0, &_arg1, &_arg2)

var _rootX int // out
var _rootY int // out

_rootX = (int)(_arg1)
_rootY = (int)(_arg2)

return _rootX, _rootY
}
	
	// Resizable gets the value set by gtk_window_set_resizable().
	func (w Window) Resizable() bool {
var _arg0 *C.GtkWindow // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

_cret = C.gtk_window_get_resizable(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ResizeGripArea: if a window has a resize grip, this will retrieve the grip
// position, width and height into the specified Rectangle.
	func (w Window) ResizeGripArea() (gdk.Rectangle, bool) {
var _arg0 *C.GtkWindow // out
var _rect gdk.Rectangle
var _cret C.gboolean // in

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

_cret = C.gtk_window_get_resize_grip_area(_arg0, (*C.GdkRectangle)(unsafe.Pointer(&_rect)))



var _ok bool // out


if _cret != 0 { _ok = true }

return _rect, _ok
}
	
	// Role returns the role of the window. See gtk_window_set_role() for further
// explanation.
	func (w Window) Role() string {
var _arg0 *C.GtkWindow // out
var _cret *C.gchar // in

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

_cret = C.gtk_window_get_role(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Screen returns the Screen associated with @window.
	func (w Window) Screen() gdk.Screen {
var _arg0 *C.GtkWindow // out
var _cret *C.GdkScreen // in

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

_cret = C.gtk_window_get_screen(_arg0)


var _screen gdk.Screen // out

_screen = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Screen)

return _screen
}
	
	// Size obtains the current size of @window.
// 
// If @window is not visible on screen, this function return the size GTK+ will
// suggest to the [window manager][gtk-X11-arch] for the initial window size
// (but this is not reliably the same as the size the window manager will
// actually select). See: gtk_window_set_default_size().
// 
// Depending on the windowing system and the window manager constraints, the
// size returned by this function may not match the size set using
// gtk_window_resize(); additionally, since gtk_window_resize() may be
// implemented as an asynchronous operation, GTK+ cannot guarantee in any way
// that this code:
// 
//    static void
//    on_size_allocate (GtkWidget *widget, GtkAllocation *allocation)
//    {
//      int new_width, new_height;
// 
//      gtk_window_get_size (GTK_WINDOW (widget), &new_width, &new_height);
// 
//      ...
//    }
// 
// Note that, if you connect to the Widget::size-allocate signal, you should not
// use the dimensions of the Allocation passed to the signal handler, as the
// allocation may contain client side decorations added by GTK+, depending on
// the windowing system in use.
// 
// If you are getting a window size in order to position the window on the
// screen, you should, instead, simply set the window’s semantic type with
// gtk_window_set_type_hint(), which allows the window manager to e.g. center
// dialogs. Also, if you set the transient parent of dialogs with
// gtk_window_set_transient_for() window managers will often center the dialog
// over its parent window. It's much preferred to let the window manager handle
// these cases rather than doing it yourself, because all apps will behave
// consistently and according to user or system preferences, if the window
// manager handles it. Also, the window manager can take into account the size
// of the window decorations and border that it may add, and of which GTK+ has
// no knowledge. Additionally, positioning windows in global screen coordinates
// may not be allowed by the windowing system. For more information, see:
// gtk_window_set_position().
	func (w Window) Size() (width int, height int) {
var _arg0 *C.GtkWindow // out
var _arg1 C.gint // in
var _arg2 C.gint // in

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

C.gtk_window_get_size(_arg0, &_arg1, &_arg2)

var _width int // out
var _height int // out

_width = (int)(_arg1)
_height = (int)(_arg2)

return _width, _height
}
	
	// SkipPagerHint gets the value set by gtk_window_set_skip_pager_hint().
	func (w Window) SkipPagerHint() bool {
var _arg0 *C.GtkWindow // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

_cret = C.gtk_window_get_skip_pager_hint(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SkipTaskbarHint gets the value set by gtk_window_set_skip_taskbar_hint()
	func (w Window) SkipTaskbarHint() bool {
var _arg0 *C.GtkWindow // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

_cret = C.gtk_window_get_skip_taskbar_hint(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Title retrieves the title of the window. See gtk_window_set_title().
	func (w Window) Title() string {
var _arg0 *C.GtkWindow // out
var _cret *C.gchar // in

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

_cret = C.gtk_window_get_title(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Titlebar returns the custom titlebar that has been set with
// gtk_window_set_titlebar().
	func (w Window) Titlebar() Widget {
var _arg0 *C.GtkWindow // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

_cret = C.gtk_window_get_titlebar(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// TransientFor fetches the transient parent for this window. See
// gtk_window_set_transient_for().
	func (w Window) TransientFor() Window {
var _arg0 *C.GtkWindow // out
var _cret *C.GtkWindow // in

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

_cret = C.gtk_window_get_transient_for(_arg0)


var _ret Window // out

_ret = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Window)

return _ret
}
	
	// TypeHint gets the type hint for this window. See gtk_window_set_type_hint().
	func (w Window) TypeHint() gdk.WindowTypeHint {
var _arg0 *C.GtkWindow // out
var _cret C.GdkWindowTypeHint // in

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

_cret = C.gtk_window_get_type_hint(_arg0)


var _windowTypeHint gdk.WindowTypeHint // out

_windowTypeHint = gdk.WindowTypeHint(_cret)

return _windowTypeHint
}
	
	// UrgencyHint gets the value set by gtk_window_set_urgency_hint()
	func (w Window) UrgencyHint() bool {
var _arg0 *C.GtkWindow // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

_cret = C.gtk_window_get_urgency_hint(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// WindowType gets the type of the window. See WindowType.
	func (w Window) WindowType() WindowType {
var _arg0 *C.GtkWindow // out
var _cret C.GtkWindowType // in

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

_cret = C.gtk_window_get_window_type(_arg0)


var _windowType WindowType // out

_windowType = WindowType(_cret)

return _windowType
}
	
	// HasGroup returns whether @window has an explicit window group.
	func (w Window) HasGroup() bool {
var _arg0 *C.GtkWindow // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

_cret = C.gtk_window_has_group(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// HasToplevelFocus returns whether the input focus is within this GtkWindow.
// For real toplevel windows, this is identical to gtk_window_is_active(), but
// for embedded windows, like Plug, the results will differ.
	func (w Window) HasToplevelFocus() bool {
var _arg0 *C.GtkWindow // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

_cret = C.gtk_window_has_toplevel_focus(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Iconify asks to iconify (i.e. minimize) the specified @window. Note that you
// shouldn’t assume the window is definitely iconified afterward, because other
// entities (e.g. the user or [window manager][gtk-X11-arch]) could deiconify it
// again, or there may not be a window manager in which case iconification isn’t
// possible, etc. But normally the window will end up iconified. Just don’t
// write code that crashes if not.
// 
// It’s permitted to call this function before showing a window, in which case
// the window will be iconified before it ever appears onscreen.
// 
// You can track iconification via the “window-state-event” signal on Widget.
	func (w Window) Iconify()  {
var _arg0 *C.GtkWindow // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

C.gtk_window_iconify(_arg0)
}
	
	// IsActive returns whether the window is part of the current active toplevel.
// (That is, the toplevel window receiving keystrokes.) The return value is true
// if the window is active toplevel itself, but also if it is, say, a Plug
// embedded in the active toplevel. You might use this function if you wanted to
// draw a widget differently in an active window from a widget in an inactive
// window. See gtk_window_has_toplevel_focus()
	func (w Window) IsActive() bool {
var _arg0 *C.GtkWindow // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

_cret = C.gtk_window_is_active(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsMaximized retrieves the current maximized state of @window.
// 
// Note that since maximization is ultimately handled by the window manager and
// happens asynchronously to an application request, you shouldn’t assume the
// return value of this function changing immediately (or at all), as an effect
// of calling gtk_window_maximize() or gtk_window_unmaximize().
	func (w Window) IsMaximized() bool {
var _arg0 *C.GtkWindow // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

_cret = C.gtk_window_is_maximized(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Maximize asks to maximize @window, so that it becomes full-screen. Note that
// you shouldn’t assume the window is definitely maximized afterward, because
// other entities (e.g. the user or [window manager][gtk-X11-arch]) could
// unmaximize it again, and not all window managers support maximization. But
// normally the window will end up maximized. Just don’t write code that crashes
// if not.
// 
// It’s permitted to call this function before showing a window, in which case
// the window will be maximized when it appears onscreen initially.
// 
// You can track maximization via the “window-state-event” signal on Widget, or
// by listening to notifications on the Window:is-maximized property.
	func (w Window) Maximize()  {
var _arg0 *C.GtkWindow // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

C.gtk_window_maximize(_arg0)
}
	
	// MnemonicActivate activates the targets associated with the mnemonic.
	func (w Window) MnemonicActivate(keyval uint, modifier gdk.ModifierType) bool {
var _arg0 *C.GtkWindow // out
var _arg1 C.guint // out
var _arg2 C.GdkModifierType // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
_arg1 = (C.guint)(keyval)
_arg2 = (C.GdkModifierType)(modifier)

_cret = C.gtk_window_mnemonic_activate(_arg0, _arg1, _arg2)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Move asks the [window manager][gtk-X11-arch] to move @window to the given
// position. Window managers are free to ignore this; most window managers
// ignore requests for initial window positions (instead using a user-defined
// placement algorithm) and honor requests after the window has already been
// shown.
// 
// Note: the position is the position of the gravity-determined reference point
// for the window. The gravity determines two things: first, the location of the
// reference point in root window coordinates; and second, which point on the
// window is positioned at the reference point.
// 
// By default the gravity is K_GRAVITY_NORTH_WEST, so the reference point is
// simply the @x, @y supplied to gtk_window_move(). The top-left corner of the
// window decorations (aka window frame or border) will be placed at @x, @y.
// Therefore, to position a window at the top left of the screen, you want to
// use the default gravity (which is K_GRAVITY_NORTH_WEST) and move the window
// to 0,0.
// 
// To position a window at the bottom right corner of the screen, you would set
// K_GRAVITY_SOUTH_EAST, which means that the reference point is at @x + the
// window width and @y + the window height, and the bottom-right corner of the
// window border will be placed at that reference point. So, to place a window
// in the bottom right corner you would first set gravity to south east, then
// write: `gtk_window_move (window, gdk_screen_width () - window_width,
// gdk_screen_height () - window_height)` (note that this example does not take
// multi-head scenarios into account).
// 
// The Extended Window Manager Hints Specification
// (http://www.freedesktop.org/Standards/wm-spec) has a nice table of gravities
// in the “implementation notes” section.
// 
// The gtk_window_get_position() documentation may also be relevant.
	func (w Window) Move(x int, y int)  {
var _arg0 *C.GtkWindow // out
var _arg1 C.gint // out
var _arg2 C.gint // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
_arg1 = (C.gint)(x)
_arg2 = (C.gint)(y)

C.gtk_window_move(_arg0, _arg1, _arg2)
}
	
	// ParseGeometry parses a standard X Window System geometry string - see the
// manual page for X (type “man X”) for details on this.
// gtk_window_parse_geometry() does work on all GTK+ ports including Win32 but
// is primarily intended for an X environment.
// 
// If either a size or a position can be extracted from the geometry string,
// gtk_window_parse_geometry() returns true and calls
// gtk_window_set_default_size() and/or gtk_window_move() to resize/move the
// window.
// 
// If gtk_window_parse_geometry() returns true, it will also set the
// K_HINT_USER_POS and/or K_HINT_USER_SIZE hints indicating to the window
// manager that the size/position of the window was user-specified. This causes
// most window managers to honor the geometry.
// 
// Note that for gtk_window_parse_geometry() to work as expected, it has to be
// called when the window has its “final” size, i.e. after calling
// gtk_widget_show_all() on the contents and gtk_window_set_geometry_hints() on
// the window.
// 
//    #include <gtk/gtk.h>
// 
//    static void
//    fill_with_content (GtkWidget *vbox)
//    {
//      // fill with content...
//    }
// 
//    int
//    main (int argc, char *argv[])
//    {
//      GtkWidget *window, *vbox;
//      GdkGeometry size_hints = {
//        100, 50, 0, 0, 100, 50, 10,
//        10, 0.0, 0.0, GDK_GRAVITY_NORTH_WEST
//      };
// 
//      gtk_init (&argc, &argv);
// 
//      window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
//      vbox = gtk_box_new (GTK_ORIENTATION_VERTICAL, 0);
// 
//      gtk_container_add (GTK_CONTAINER (window), vbox);
//      fill_with_content (vbox);
//      gtk_widget_show_all (vbox);
// 
//      gtk_window_set_geometry_hints (GTK_WINDOW (window),
//    	  			    NULL,
//    				    &size_hints,
//    				    GDK_HINT_MIN_SIZE |
//    				    GDK_HINT_BASE_SIZE |
//    				    GDK_HINT_RESIZE_INC);
// 
//      if (argc > 1)
//        {
//          gboolean res;
//          res = gtk_window_parse_geometry (GTK_WINDOW (window),
//                                           argv[1]);
//          if (! res)
//            fprintf (stderr,
//                     "Failed to parse “s”\n",
//                     argv[1]);
//        }
// 
//      gtk_widget_show_all (window);
//      gtk_main ();
// 
//      return 0;
//    }
	func (w Window) ParseGeometry(geometry string) bool {
var _arg0 *C.GtkWindow // out
var _arg1 *C.gchar // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
_arg1 = (*C.gchar)(C.CString(geometry))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_window_parse_geometry(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Present presents a window to the user. This function should not be used as
// when it is called, it is too late to gather a valid timestamp to allow focus
// stealing prevention to work correctly.
	func (w Window) Present()  {
var _arg0 *C.GtkWindow // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

C.gtk_window_present(_arg0)
}
	
	// PresentWithTime presents a window to the user. This may mean raising the
// window in the stacking order, deiconifying it, moving it to the current
// desktop, and/or giving it the keyboard focus, possibly dependent on the
// user’s platform, window manager, and preferences.
// 
// If @window is hidden, this function calls gtk_widget_show() as well.
// 
// This function should be used when the user tries to open a window that’s
// already open. Say for example the preferences dialog is currently open, and
// the user chooses Preferences from the menu a second time; use
// gtk_window_present() to move the already-open dialog where the user can see
// it.
// 
// Presents a window to the user in response to a user interaction. The
// timestamp should be gathered when the window was requested to be shown (when
// clicking a link for example), rather than once the window is ready to be
// shown.
	func (w Window) PresentWithTime(timestamp uint32)  {
var _arg0 *C.GtkWindow // out
var _arg1 C.guint32 // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
_arg1 = (C.guint32)(timestamp)

C.gtk_window_present_with_time(_arg0, _arg1)
}
	
	// PropagateKeyEvent: propagate a key press or release event to the focus widget
// and up the focus container chain until a widget handles @event. This is
// normally called by the default ::key_press_event and ::key_release_event
// handlers for toplevel windows, however in some cases it may be useful to call
// this directly when overriding the standard key handling for a toplevel
// window.
	func (w Window) PropagateKeyEvent(event *gdk.EventKey) bool {
var _arg0 *C.GtkWindow // out
var _arg1 *C.GdkEventKey // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
_arg1 = (*C.GdkEventKey)(unsafe.Pointer(event.Native()))

_cret = C.gtk_window_propagate_key_event(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// RemoveAccelGroup reverses the effects of gtk_window_add_accel_group().
	func (w Window) RemoveAccelGroup(accelGroup AccelGroupClass)  {
var _arg0 *C.GtkWindow // out
var _arg1 *C.GtkAccelGroup // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
_arg1 = (*C.GtkAccelGroup)(unsafe.Pointer(accelGroup.Native()))

C.gtk_window_remove_accel_group(_arg0, _arg1)
}
	
	// RemoveMnemonic removes a mnemonic from this window.
	func (w Window) RemoveMnemonic(keyval uint, target WidgetClass)  {
var _arg0 *C.GtkWindow // out
var _arg1 C.guint // out
var _arg2 *C.GtkWidget // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
_arg1 = (C.guint)(keyval)
_arg2 = (*C.GtkWidget)(unsafe.Pointer(target.Native()))

C.gtk_window_remove_mnemonic(_arg0, _arg1, _arg2)
}
	
	// ReshowWithInitialSize hides @window, then reshows it, resetting the default
// size and position of the window. Used by GUI builders only.
	func (w Window) ReshowWithInitialSize()  {
var _arg0 *C.GtkWindow // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

C.gtk_window_reshow_with_initial_size(_arg0)
}
	
	// Resize resizes the window as if the user had done so, obeying geometry
// constraints. The default geometry constraint is that windows may not be
// smaller than their size request; to override this constraint, call
// gtk_widget_set_size_request() to set the window's request to a smaller value.
// 
// If gtk_window_resize() is called before showing a window for the first time,
// it overrides any default size set with gtk_window_set_default_size().
// 
// Windows may not be resized smaller than 1 by 1 pixels.
// 
// When using client side decorations, GTK+ will do its best to adjust the given
// size so that the resulting window size matches the requested size without the
// title bar, borders and shadows added for the client side decorations, but
// there is no guarantee that the result will be totally accurate because these
// widgets added for client side decorations depend on the theme and may not be
// realized or visible at the time gtk_window_resize() is issued.
// 
// If the GtkWindow has a titlebar widget (see gtk_window_set_titlebar()), then
// typically, gtk_window_resize() will compensate for the height of the titlebar
// widget only if the height is known when the resulting GtkWindow configuration
// is issued. For example, if new widgets are added after the GtkWindow
// configuration and cause the titlebar widget to grow in height, this will
// result in a window content smaller that specified by gtk_window_resize() and
// not a larger window.
	func (w Window) Resize(width int, height int)  {
var _arg0 *C.GtkWindow // out
var _arg1 C.gint // out
var _arg2 C.gint // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
_arg1 = (C.gint)(width)
_arg2 = (C.gint)(height)

C.gtk_window_resize(_arg0, _arg1, _arg2)
}
	
	// ResizeGripIsVisible determines whether a resize grip is visible for the
// specified window.
	func (w Window) ResizeGripIsVisible() bool {
var _arg0 *C.GtkWindow // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

_cret = C.gtk_window_resize_grip_is_visible(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ResizeToGeometry: like gtk_window_resize(), but @width and @height are
// interpreted in terms of the base size and increment set with
// gtk_window_set_geometry_hints.
	func (w Window) ResizeToGeometry(width int, height int)  {
var _arg0 *C.GtkWindow // out
var _arg1 C.gint // out
var _arg2 C.gint // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
_arg1 = (C.gint)(width)
_arg2 = (C.gint)(height)

C.gtk_window_resize_to_geometry(_arg0, _arg1, _arg2)
}
	
	// SetAcceptFocus windows may set a hint asking the desktop environment not to
// receive the input focus. This function sets this hint.
	func (w Window) SetAcceptFocus(setting bool)  {
var _arg0 *C.GtkWindow // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
if setting { _arg1 = C.TRUE }

C.gtk_window_set_accept_focus(_arg0, _arg1)
}
	
	// SetApplication sets or unsets the Application associated with the window.
// 
// The application will be kept alive for at least as long as it has any windows
// associated with it (see g_application_hold() for a way to keep it alive
// without windows).
// 
// Normally, the connection between the application and the window will remain
// until the window is destroyed, but you can explicitly remove it by setting
// the @application to nil.
// 
// This is equivalent to calling gtk_application_remove_window() and/or
// gtk_application_add_window() on the old/new applications as relevant.
	func (w Window) SetApplication(application ApplicationClass)  {
var _arg0 *C.GtkWindow // out
var _arg1 *C.GtkApplication // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
_arg1 = (*C.GtkApplication)(unsafe.Pointer(application.Native()))

C.gtk_window_set_application(_arg0, _arg1)
}
	
	// SetAttachedTo marks @window as attached to @attach_widget. This creates a
// logical binding between the window and the widget it belongs to, which is
// used by GTK+ to propagate information such as styling or accessibility to
// @window as if it was a children of @attach_widget.
// 
// Examples of places where specifying this relation is useful are for instance
// a Menu created by a ComboBox, a completion popup window created by Entry or a
// typeahead search entry created by TreeView.
// 
// Note that this function should not be confused with
// gtk_window_set_transient_for(), which specifies a window manager relation
// between two toplevels instead.
// 
// Passing nil for @attach_widget detaches the window.
	func (w Window) SetAttachedTo(attachWidget WidgetClass)  {
var _arg0 *C.GtkWindow // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(attachWidget.Native()))

C.gtk_window_set_attached_to(_arg0, _arg1)
}
	
	// SetDecorated: by default, windows are decorated with a title bar, resize
// controls, etc. Some [window managers][gtk-X11-arch] allow GTK+ to disable
// these decorations, creating a borderless window. If you set the decorated
// property to false using this function, GTK+ will do its best to convince the
// window manager not to decorate the window. Depending on the system, this
// function may not have any effect when called on a window that is already
// visible, so you should call it before calling gtk_widget_show().
// 
// On Windows, this function always works, since there’s no window manager
// policy involved.
	func (w Window) SetDecorated(setting bool)  {
var _arg0 *C.GtkWindow // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
if setting { _arg1 = C.TRUE }

C.gtk_window_set_decorated(_arg0, _arg1)
}
	
	// SetDefault: the default widget is the widget that’s activated when the user
// presses Enter in a dialog (for example). This function sets or unsets the
// default widget for a Window. When setting (rather than unsetting) the default
// widget it’s generally easier to call gtk_widget_grab_default() on the widget.
// Before making a widget the default widget, you must call
// gtk_widget_set_can_default() on the widget you’d like to make the default.
	func (w Window) SetDefault(defaultWidget WidgetClass)  {
var _arg0 *C.GtkWindow // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(defaultWidget.Native()))

C.gtk_window_set_default(_arg0, _arg1)
}
	
	// SetDefaultGeometry: like gtk_window_set_default_size(), but @width and
// @height are interpreted in terms of the base size and increment set with
// gtk_window_set_geometry_hints.
	func (w Window) SetDefaultGeometry(width int, height int)  {
var _arg0 *C.GtkWindow // out
var _arg1 C.gint // out
var _arg2 C.gint // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
_arg1 = (C.gint)(width)
_arg2 = (C.gint)(height)

C.gtk_window_set_default_geometry(_arg0, _arg1, _arg2)
}
	
	// SetDefaultSize sets the default size of a window. If the window’s “natural”
// size (its size request) is larger than the default, the default will be
// ignored. More generally, if the default size does not obey the geometry hints
// for the window (gtk_window_set_geometry_hints() can be used to set these
// explicitly), the default size will be clamped to the nearest permitted size.
// 
// Unlike gtk_widget_set_size_request(), which sets a size request for a widget
// and thus would keep users from shrinking the window, this function only sets
// the initial size, just as if the user had resized the window themselves.
// Users can still shrink the window again as they normally would. Setting a
// default size of -1 means to use the “natural” default size (the size request
// of the window).
// 
// For more control over a window’s initial size and how resizing works,
// investigate gtk_window_set_geometry_hints().
// 
// For some uses, gtk_window_resize() is a more appropriate function.
// gtk_window_resize() changes the current size of the window, rather than the
// size to be used on initial display. gtk_window_resize() always affects the
// window itself, not the geometry widget.
// 
// The default size of a window only affects the first time a window is shown;
// if a window is hidden and re-shown, it will remember the size it had prior to
// hiding, rather than using the default size.
// 
// Windows can’t actually be 0x0 in size, they must be at least 1x1, but passing
// 0 for @width and @height is OK, resulting in a 1x1 default size.
// 
// If you use this function to reestablish a previously saved window size, note
// that the appropriate size to save is the one returned by
// gtk_window_get_size(). Using the window allocation directly will not work in
// all circumstances and can lead to growing or shrinking windows.
	func (w Window) SetDefaultSize(width int, height int)  {
var _arg0 *C.GtkWindow // out
var _arg1 C.gint // out
var _arg2 C.gint // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
_arg1 = (C.gint)(width)
_arg2 = (C.gint)(height)

C.gtk_window_set_default_size(_arg0, _arg1, _arg2)
}
	
	// SetDeletable: by default, windows have a close button in the window frame.
// Some [window managers][gtk-X11-arch] allow GTK+ to disable this button. If
// you set the deletable property to false using this function, GTK+ will do its
// best to convince the window manager not to show a close button. Depending on
// the system, this function may not have any effect when called on a window
// that is already visible, so you should call it before calling
// gtk_widget_show().
// 
// On Windows, this function always works, since there’s no window manager
// policy involved.
	func (w Window) SetDeletable(setting bool)  {
var _arg0 *C.GtkWindow // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
if setting { _arg1 = C.TRUE }

C.gtk_window_set_deletable(_arg0, _arg1)
}
	
	// SetDestroyWithParent: if @setting is true, then destroying the transient
// parent of @window will also destroy @window itself. This is useful for
// dialogs that shouldn’t persist beyond the lifetime of the main window they're
// associated with, for example.
	func (w Window) SetDestroyWithParent(setting bool)  {
var _arg0 *C.GtkWindow // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
if setting { _arg1 = C.TRUE }

C.gtk_window_set_destroy_with_parent(_arg0, _arg1)
}
	
	// SetFocus: if @focus is not the current focus widget, and is focusable, sets
// it as the focus widget for the window. If @focus is nil, unsets the focus
// widget for this window. To set the focus to a particular widget in the
// toplevel, it is usually more convenient to use gtk_widget_grab_focus()
// instead of this function.
	func (w Window) SetFocus(focus WidgetClass)  {
var _arg0 *C.GtkWindow // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(focus.Native()))

C.gtk_window_set_focus(_arg0, _arg1)
}
	
	// SetFocusOnMap windows may set a hint asking the desktop environment not to
// receive the input focus when the window is mapped. This function sets this
// hint.
	func (w Window) SetFocusOnMap(setting bool)  {
var _arg0 *C.GtkWindow // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
if setting { _arg1 = C.TRUE }

C.gtk_window_set_focus_on_map(_arg0, _arg1)
}
	
	// SetFocusVisible sets the Window:focus-visible property.
	func (w Window) SetFocusVisible(setting bool)  {
var _arg0 *C.GtkWindow // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
if setting { _arg1 = C.TRUE }

C.gtk_window_set_focus_visible(_arg0, _arg1)
}
	
	// SetGeometryHints: this function sets up hints about how a window can be
// resized by the user. You can set a minimum and maximum size; allowed resize
// increments (e.g. for xterm, you can only resize by the size of a character);
// aspect ratios; and more. See the Geometry struct.
	func (w Window) SetGeometryHints(geometryWidget WidgetClass, geometry *gdk.Geometry, geomMask gdk.WindowHints)  {
var _arg0 *C.GtkWindow // out
var _arg1 *C.GtkWidget // out
var _arg2 *C.GdkGeometry // out
var _arg3 C.GdkWindowHints // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(geometryWidget.Native()))
_arg2 = (*C.GdkGeometry)(unsafe.Pointer(geometry.Native()))
_arg3 = (C.GdkWindowHints)(geomMask)

C.gtk_window_set_geometry_hints(_arg0, _arg1, _arg2, _arg3)
}
	
	// SetGravity: window gravity defines the meaning of coordinates passed to
// gtk_window_move(). See gtk_window_move() and Gravity for more details.
// 
// The default window gravity is K_GRAVITY_NORTH_WEST which will typically “do
// what you mean.”
	func (w Window) SetGravity(gravity gdk.Gravity)  {
var _arg0 *C.GtkWindow // out
var _arg1 C.GdkGravity // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
_arg1 = (C.GdkGravity)(gravity)

C.gtk_window_set_gravity(_arg0, _arg1)
}
	
	// SetHasResizeGrip sets whether @window has a corner resize grip.
// 
// Note that the resize grip is only shown if the window is actually resizable
// and not maximized. Use gtk_window_resize_grip_is_visible() to find out if the
// resize grip is currently shown.
	func (w Window) SetHasResizeGrip(value bool)  {
var _arg0 *C.GtkWindow // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
if value { _arg1 = C.TRUE }

C.gtk_window_set_has_resize_grip(_arg0, _arg1)
}
	
	// SetHasUserRefCount tells GTK+ whether to drop its extra reference to the
// window when gtk_widget_destroy() is called.
// 
// This function is only exported for the benefit of language bindings which may
// need to keep the window alive until their wrapper object is garbage
// collected. There is no justification for ever calling this function in an
// application.
	func (w Window) SetHasUserRefCount(setting bool)  {
var _arg0 *C.GtkWindow // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
if setting { _arg1 = C.TRUE }

C.gtk_window_set_has_user_ref_count(_arg0, _arg1)
}
	
	// SetHideTitlebarWhenMaximized: if @setting is true, then @window will request
// that it’s titlebar should be hidden when maximized. This is useful for
// windows that don’t convey any information other than the application name in
// the titlebar, to put the available screen space to better use. If the
// underlying window system does not support the request, the setting will not
// have any effect.
// 
// Note that custom titlebars set with gtk_window_set_titlebar() are not
// affected by this. The application is in full control of their content and
// visibility anyway.
	func (w Window) SetHideTitlebarWhenMaximized(setting bool)  {
var _arg0 *C.GtkWindow // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
if setting { _arg1 = C.TRUE }

C.gtk_window_set_hide_titlebar_when_maximized(_arg0, _arg1)
}
	
	// SetIcon sets up the icon representing a Window. This icon is used when the
// window is minimized (also known as iconified). Some window managers or
// desktop environments may also place it in the window frame, or display it in
// other contexts. On others, the icon is not used at all, so your mileage may
// vary.
// 
// The icon should be provided in whatever size it was naturally drawn; that is,
// don’t scale the image before passing it to GTK+. Scaling is postponed until
// the last minute, when the desired final size is known, to allow best quality.
// 
// If you have your icon hand-drawn in multiple sizes, use
// gtk_window_set_icon_list(). Then the best size will be used.
// 
// This function is equivalent to calling gtk_window_set_icon_list() with a
// 1-element list.
// 
// See also gtk_window_set_default_icon_list() to set the icon for all windows
// in your application in one go.
	func (w Window) SetIcon(icon gdkpixbuf.PixbufClass)  {
var _arg0 *C.GtkWindow // out
var _arg1 *C.GdkPixbuf // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
_arg1 = (*C.GdkPixbuf)(unsafe.Pointer(icon.Native()))

C.gtk_window_set_icon(_arg0, _arg1)
}
	
	// SetIconFromFile sets the icon for @window. Warns on failure if @err is nil.
// 
// This function is equivalent to calling gtk_window_set_icon() with a pixbuf
// created by loading the image from @filename.
	func (w Window) SetIconFromFile(filename string) error {
var _arg0 *C.GtkWindow // out
var _arg1 *C.gchar // out
var _cerr *C.GError // in

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
_arg1 = (*C.gchar)(C.CString(filename))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_window_set_icon_from_file(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// SetIconName sets the icon for the window from a named themed icon. See the
// docs for IconTheme for more details. On some platforms, the window icon is
// not used at all.
// 
// Note that this has nothing to do with the WM_ICON_NAME property which is
// mentioned in the ICCCM.
	func (w Window) SetIconName(name string)  {
var _arg0 *C.GtkWindow // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
_arg1 = (*C.gchar)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_window_set_icon_name(_arg0, _arg1)
}
	
	// SetKeepAbove asks to keep @window above, so that it stays on top. Note that
// you shouldn’t assume the window is definitely above afterward, because other
// entities (e.g. the user or [window manager][gtk-X11-arch]) could not keep it
// above, and not all window managers support keeping windows above. But
// normally the window will end kept above. Just don’t write code that crashes
// if not.
// 
// It’s permitted to call this function before showing a window, in which case
// the window will be kept above when it appears onscreen initially.
// 
// You can track the above state via the “window-state-event” signal on Widget.
// 
// Note that, according to the Extended Window Manager Hints Specification
// (http://www.freedesktop.org/Standards/wm-spec), the above state is mainly
// meant for user preferences and should not be used by applications e.g. for
// drawing attention to their dialogs.
	func (w Window) SetKeepAbove(setting bool)  {
var _arg0 *C.GtkWindow // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
if setting { _arg1 = C.TRUE }

C.gtk_window_set_keep_above(_arg0, _arg1)
}
	
	// SetKeepBelow asks to keep @window below, so that it stays in bottom. Note
// that you shouldn’t assume the window is definitely below afterward, because
// other entities (e.g. the user or [window manager][gtk-X11-arch]) could not
// keep it below, and not all window managers support putting windows below. But
// normally the window will be kept below. Just don’t write code that crashes if
// not.
// 
// It’s permitted to call this function before showing a window, in which case
// the window will be kept below when it appears onscreen initially.
// 
// You can track the below state via the “window-state-event” signal on Widget.
// 
// Note that, according to the Extended Window Manager Hints Specification
// (http://www.freedesktop.org/Standards/wm-spec), the above state is mainly
// meant for user preferences and should not be used by applications e.g. for
// drawing attention to their dialogs.
	func (w Window) SetKeepBelow(setting bool)  {
var _arg0 *C.GtkWindow // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
if setting { _arg1 = C.TRUE }

C.gtk_window_set_keep_below(_arg0, _arg1)
}
	
	// SetMnemonicModifier sets the mnemonic modifier for this window.
	func (w Window) SetMnemonicModifier(modifier gdk.ModifierType)  {
var _arg0 *C.GtkWindow // out
var _arg1 C.GdkModifierType // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
_arg1 = (C.GdkModifierType)(modifier)

C.gtk_window_set_mnemonic_modifier(_arg0, _arg1)
}
	
	// SetMnemonicsVisible sets the Window:mnemonics-visible property.
	func (w Window) SetMnemonicsVisible(setting bool)  {
var _arg0 *C.GtkWindow // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
if setting { _arg1 = C.TRUE }

C.gtk_window_set_mnemonics_visible(_arg0, _arg1)
}
	
	// SetModal sets a window modal or non-modal. Modal windows prevent interaction
// with other windows in the same application. To keep modal dialogs on top of
// main application windows, use gtk_window_set_transient_for() to make the
// dialog transient for the parent; most [window managers][gtk-X11-arch] will
// then disallow lowering the dialog below the parent.
	func (w Window) SetModal(modal bool)  {
var _arg0 *C.GtkWindow // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
if modal { _arg1 = C.TRUE }

C.gtk_window_set_modal(_arg0, _arg1)
}
	
	// SetOpacity: request the windowing system to make @window partially
// transparent, with opacity 0 being fully transparent and 1 fully opaque.
// (Values of the opacity parameter are clamped to the [0,1] range.) On X11 this
// has any effect only on X screens with a compositing manager running. See
// gtk_widget_is_composited(). On Windows it should work always.
// 
// Note that setting a window’s opacity after the window has been shown causes
// it to flicker once on Windows.
	func (w Window) SetOpacity(opacity float64)  {
var _arg0 *C.GtkWindow // out
var _arg1 C.gdouble // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
_arg1 = (C.gdouble)(opacity)

C.gtk_window_set_opacity(_arg0, _arg1)
}
	
	// SetPosition sets a position constraint for this window. If the old or new
// constraint is GTK_WIN_POS_CENTER_ALWAYS, this will also cause the window to
// be repositioned to satisfy the new constraint.
	func (w Window) SetPosition(position WindowPosition)  {
var _arg0 *C.GtkWindow // out
var _arg1 C.GtkWindowPosition // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
_arg1 = (C.GtkWindowPosition)(position)

C.gtk_window_set_position(_arg0, _arg1)
}
	
	// SetResizable sets whether the user can resize a window. Windows are user
// resizable by default.
	func (w Window) SetResizable(resizable bool)  {
var _arg0 *C.GtkWindow // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
if resizable { _arg1 = C.TRUE }

C.gtk_window_set_resizable(_arg0, _arg1)
}
	
	// SetRole: this function is only useful on X11, not with other GTK+ targets.
// 
// In combination with the window title, the window role allows a [window
// manager][gtk-X11-arch] to identify "the same" window when an application is
// restarted. So for example you might set the “toolbox” role on your app’s
// toolbox window, so that when the user restarts their session, the window
// manager can put the toolbox back in the same place.
// 
// If a window already has a unique title, you don’t need to set the role, since
// the WM can use the title to identify the window when restoring the session.
	func (w Window) SetRole(role string)  {
var _arg0 *C.GtkWindow // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
_arg1 = (*C.gchar)(C.CString(role))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_window_set_role(_arg0, _arg1)
}
	
	// SetScreen sets the Screen where the @window is displayed; if the window is
// already mapped, it will be unmapped, and then remapped on the new screen.
	func (w Window) SetScreen(screen gdk.ScreenClass)  {
var _arg0 *C.GtkWindow // out
var _arg1 *C.GdkScreen // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
_arg1 = (*C.GdkScreen)(unsafe.Pointer(screen.Native()))

C.gtk_window_set_screen(_arg0, _arg1)
}
	
	// SetSkipPagerHint windows may set a hint asking the desktop environment not to
// display the window in the pager. This function sets this hint. (A "pager" is
// any desktop navigation tool such as a workspace switcher that displays a
// thumbnail representation of the windows on the screen.)
	func (w Window) SetSkipPagerHint(setting bool)  {
var _arg0 *C.GtkWindow // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
if setting { _arg1 = C.TRUE }

C.gtk_window_set_skip_pager_hint(_arg0, _arg1)
}
	
	// SetSkipTaskbarHint windows may set a hint asking the desktop environment not
// to display the window in the task bar. This function sets this hint.
	func (w Window) SetSkipTaskbarHint(setting bool)  {
var _arg0 *C.GtkWindow // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
if setting { _arg1 = C.TRUE }

C.gtk_window_set_skip_taskbar_hint(_arg0, _arg1)
}
	
	// SetStartupID: startup notification identifiers are used by desktop
// environment to track application startup, to provide user feedback and other
// features. This function changes the corresponding property on the underlying
// GdkWindow. Normally, startup identifier is managed automatically and you
// should only use this function in special cases like transferring focus from
// other processes. You should use this function before calling
// gtk_window_present() or any equivalent function generating a window map
// event.
// 
// This function is only useful on X11, not with other GTK+ targets.
	func (w Window) SetStartupID(startupId string)  {
var _arg0 *C.GtkWindow // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
_arg1 = (*C.gchar)(C.CString(startupId))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_window_set_startup_id(_arg0, _arg1)
}
	
	// SetTitle sets the title of the Window. The title of a window will be
// displayed in its title bar; on the X Window System, the title bar is rendered
// by the [window manager][gtk-X11-arch], so exactly how the title appears to
// users may vary according to a user’s exact configuration. The title should
// help a user distinguish this window from other windows they may have open. A
// good title might include the application name and current document filename,
// for example.
	func (w Window) SetTitle(title string)  {
var _arg0 *C.GtkWindow // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
_arg1 = (*C.gchar)(C.CString(title))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_window_set_title(_arg0, _arg1)
}
	
	// SetTitlebar sets a custom titlebar for @window.
// 
// A typical widget used here is HeaderBar, as it provides various features
// expected of a titlebar while allowing the addition of child widgets to it.
// 
// If you set a custom titlebar, GTK+ will do its best to convince the window
// manager not to put its own titlebar on the window. Depending on the system,
// this function may not work for a window that is already visible, so you set
// the titlebar before calling gtk_widget_show().
	func (w Window) SetTitlebar(titlebar WidgetClass)  {
var _arg0 *C.GtkWindow // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(titlebar.Native()))

C.gtk_window_set_titlebar(_arg0, _arg1)
}
	
	// SetTransientFor: dialog windows should be set transient for the main
// application window they were spawned from. This allows [window
// managers][gtk-X11-arch] to e.g. keep the dialog on top of the main window, or
// center the dialog over the main window. gtk_dialog_new_with_buttons() and
// other convenience functions in GTK+ will sometimes call
// gtk_window_set_transient_for() on your behalf.
// 
// Passing nil for @parent unsets the current transient window.
// 
// On Wayland, this function can also be used to attach a new K_WINDOW_POPUP to
// a K_WINDOW_TOPLEVEL parent already mapped on screen so that the
// K_WINDOW_POPUP will be created as a subsurface-based window
// K_WINDOW_SUBSURFACE which can be positioned at will relatively to the
// K_WINDOW_TOPLEVEL surface.
// 
// On Windows, this function puts the child window on top of the parent, much as
// the window manager would have done on X.
	func (w Window) SetTransientFor(parent WindowClass)  {
var _arg0 *C.GtkWindow // out
var _arg1 *C.GtkWindow // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
_arg1 = (*C.GtkWindow)(unsafe.Pointer(parent.Native()))

C.gtk_window_set_transient_for(_arg0, _arg1)
}
	
	// SetTypeHint: by setting the type hint for the window, you allow the window
// manager to decorate and handle the window in a way which is suitable to the
// function of the window in your application.
// 
// This function should be called before the window becomes visible.
// 
// gtk_dialog_new_with_buttons() and other convenience functions in GTK+ will
// sometimes call gtk_window_set_type_hint() on your behalf.
	func (w Window) SetTypeHint(hint gdk.WindowTypeHint)  {
var _arg0 *C.GtkWindow // out
var _arg1 C.GdkWindowTypeHint // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
_arg1 = (C.GdkWindowTypeHint)(hint)

C.gtk_window_set_type_hint(_arg0, _arg1)
}
	
	// SetUrgencyHint windows may set a hint asking the desktop environment to draw
// the users attention to the window. This function sets this hint.
	func (w Window) SetUrgencyHint(setting bool)  {
var _arg0 *C.GtkWindow // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
if setting { _arg1 = C.TRUE }

C.gtk_window_set_urgency_hint(_arg0, _arg1)
}
	
	// SetWmclass: don’t use this function. It sets the X Window System “class” and
// “name” hints for a window. According to the ICCCM, you should always set
// these to the same value for all windows in an application, and GTK+ sets them
// to that value by default, so calling this function is sort of pointless.
// However, you may want to call gtk_window_set_role() on each window in your
// application, for the benefit of the session manager. Setting the role allows
// the window manager to restore window positions when loading a saved session.
	func (w Window) SetWmclass(wmclassName string, wmclassClass string)  {
var _arg0 *C.GtkWindow // out
var _arg1 *C.gchar // out
var _arg2 *C.gchar // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
_arg1 = (*C.gchar)(C.CString(wmclassName))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.gchar)(C.CString(wmclassClass))
defer C.free(unsafe.Pointer(_arg2))

C.gtk_window_set_wmclass(_arg0, _arg1, _arg2)
}
	
	// Stick asks to stick @window, which means that it will appear on all user
// desktops. Note that you shouldn’t assume the window is definitely stuck
// afterward, because other entities (e.g. the user or [window
// manager][gtk-X11-arch] could unstick it again, and some window managers do
// not support sticking windows. But normally the window will end up stuck. Just
// don't write code that crashes if not.
// 
// It’s permitted to call this function before showing a window.
// 
// You can track stickiness via the “window-state-event” signal on Widget.
	func (w Window) Stick()  {
var _arg0 *C.GtkWindow // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

C.gtk_window_stick(_arg0)
}
	
	// Unfullscreen asks to toggle off the fullscreen state for @window. Note that
// you shouldn’t assume the window is definitely not full screen afterward,
// because other entities (e.g. the user or [window manager][gtk-X11-arch])
// could fullscreen it again, and not all window managers honor requests to
// unfullscreen windows. But normally the window will end up restored to its
// normal state. Just don’t write code that crashes if not.
// 
// You can track the fullscreen state via the “window-state-event” signal on
// Widget.
	func (w Window) Unfullscreen()  {
var _arg0 *C.GtkWindow // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

C.gtk_window_unfullscreen(_arg0)
}
	
	// Unmaximize asks to unmaximize @window. Note that you shouldn’t assume the
// window is definitely unmaximized afterward, because other entities (e.g. the
// user or [window manager][gtk-X11-arch]) could maximize it again, and not all
// window managers honor requests to unmaximize. But normally the window will
// end up unmaximized. Just don’t write code that crashes if not.
// 
// You can track maximization via the “window-state-event” signal on Widget.
	func (w Window) Unmaximize()  {
var _arg0 *C.GtkWindow // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

C.gtk_window_unmaximize(_arg0)
}
	
	// Unstick asks to unstick @window, which means that it will appear on only one
// of the user’s desktops. Note that you shouldn’t assume the window is
// definitely unstuck afterward, because other entities (e.g. the user or
// [window manager][gtk-X11-arch]) could stick it again. But normally the window
// will end up stuck. Just don’t write code that crashes if not.
// 
// You can track stickiness via the “window-state-event” signal on Widget.
	func (w Window) Unstick()  {
var _arg0 *C.GtkWindow // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

C.gtk_window_unstick(_arg0)
}
	


	// WindowGroup: a WindowGroup restricts the effect of grabs to windows in the
// same group, thereby making window groups almost behave like separate
// applications.
// 
// A window can be a member in at most one window group at a time. Windows that
// have not been explicitly assigned to a group are implicitly treated like
// windows of the default window group.
// 
// GtkWindowGroup objects are referenced by each window in the group, so once
// you have added all windows to a GtkWindowGroup, you can drop the initial
// reference to the window group with g_object_unref(). If the windows in the
// window group are subsequently destroyed, then they will be removed from the
// window group and drop their references on the window group; when all window
// have been removed, the window group will be freed.
	type WindowGroup struct {
		**externglib.Object
		
	}

	// WindowGroupClass is an interface that the WindowGroup class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type WindowGroupClass interface {
		gextras.Objector
		_windowGroup()
	}

	func (WindowGroup) _windowGroup() {}

	
	func marshalWindowGroup(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapWindowGroup(obj), nil
	}
	

	
	// NewWindowGroup creates a new WindowGroup object. Grabs added with
// gtk_grab_add() only affect windows within the same WindowGroup.
	func NewWindowGroup() WindowGroup {
var _cret *C.GtkWindowGroup // in

_cret = C.gtk_window_group_new()


var _windowGroup WindowGroup // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_windowGroup = WindowGroup{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}

return _windowGroup
}
	

	
	// AddWindow adds a window to a WindowGroup.
	func (w WindowGroup) AddWindow(window WindowClass)  {
var _arg0 *C.GtkWindowGroup // out
var _arg1 *C.GtkWindow // out

_arg0 = (*C.GtkWindowGroup)(unsafe.Pointer(w.Native()))
_arg1 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

C.gtk_window_group_add_window(_arg0, _arg1)
}
	
	// CurrentDeviceGrab returns the current grab widget for @device, or nil if
// none.
	func (w WindowGroup) CurrentDeviceGrab(device gdk.DeviceClass) Widget {
var _arg0 *C.GtkWindowGroup // out
var _arg1 *C.GdkDevice // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkWindowGroup)(unsafe.Pointer(w.Native()))
_arg1 = (*C.GdkDevice)(unsafe.Pointer(device.Native()))

_cret = C.gtk_window_group_get_current_device_grab(_arg0, _arg1)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// CurrentGrab gets the current grab widget of the given group, see
// gtk_grab_add().
	func (w WindowGroup) CurrentGrab() Widget {
var _arg0 *C.GtkWindowGroup // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkWindowGroup)(unsafe.Pointer(w.Native()))

_cret = C.gtk_window_group_get_current_grab(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// RemoveWindow removes a window from a WindowGroup.
	func (w WindowGroup) RemoveWindow(window WindowClass)  {
var _arg0 *C.GtkWindowGroup // out
var _arg1 *C.GtkWindow // out

_arg0 = (*C.GtkWindowGroup)(unsafe.Pointer(w.Native()))
_arg1 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

C.gtk_window_group_remove_window(_arg0, _arg1)
}
	


	
	type AccelKey struct {
		Native C.GtkAccelKey
	}

	

	

	

	// Native returns the underlying C source pointer.
	func (a *AccelKey) Native() uintptr {
		return uintptr(unsafe.Pointer(&a.Native))
	}

	

	


	// BindingArg: a BindingArg holds the data associated with an argument for a key
// binding signal emission as stored in BindingSignal.
	type BindingArg struct {
		Native C.GtkBindingArg
	}

	

	

	

	// Native returns the underlying C source pointer.
	func (b *BindingArg) Native() uintptr {
		return uintptr(unsafe.Pointer(&b.Native))
	}

	

	


	// BindingEntry: each key binding element of a binding sets binding list is
// represented by a GtkBindingEntry.
	type BindingEntry struct {
		Native C.GtkBindingEntry
	}

	

	

	

	// Native returns the underlying C source pointer.
	func (b *BindingEntry) Native() uintptr {
		return uintptr(unsafe.Pointer(&b.Native))
	}

	

	


	// BindingSignal: a GtkBindingSignal stores the necessary information to
// activate a widget in response to a key press via a signal emission.
	type BindingSignal struct {
		Native C.GtkBindingSignal
	}

	

	

	

	// Native returns the underlying C source pointer.
	func (b *BindingSignal) Native() uintptr {
		return uintptr(unsafe.Pointer(&b.Native))
	}

	

	


	// Border: a struct that specifies a border around a rectangular area that can
// be of different width on each side.
	type Border struct {
		Native C.GtkBorder
	}

	
	func marshalBorder(p uintptr) (interface{}, error) {
		b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
		return (*Border)(unsafe.Pointer(b))
	}
	

	
	
	// NewBorder constructs a struct Border.
	func NewBorder() *Border {
var _cret *C.GtkBorder // in

_cret = C.gtk_border_new()


var _border *Border // out

_border = *(**Border)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_border, func(v *Border) {
  C.free(unsafe.Pointer(v.Native()))
})

return _border
}
	
	

	

	// Native returns the underlying C source pointer.
	func (b *Border) Native() uintptr {
		return uintptr(unsafe.Pointer(&b.Native))
	}

	

	
	// Copy copies a Border-struct.
	func (b *Border) Copy() *Border {
var _arg0 *C.GtkBorder // out
var _cret *C.GtkBorder // in

_arg0 = (*C.GtkBorder)(unsafe.Pointer(b.Native()))

_cret = C.gtk_border_copy(_arg0)


var _border *Border // out

_border = *(**Border)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_border, func(v *Border) {
  C.free(unsafe.Pointer(v.Native()))
})

return _border
}
	
	// Free frees a Border-struct.
	func (b *Border) Free()  {
var _arg0 *C.GtkBorder // out

_arg0 = (*C.GtkBorder)(unsafe.Pointer(b.Native()))

C.gtk_border_free(_arg0)
}
	


	// CSSSection defines a part of a CSS document. Because sections are nested into
// one another, you can use gtk_css_section_get_parent() to get the containing
// region.
	type CSSSection struct {
		Native C.GtkCssSection
	}

	
	func marshalCSSSection(p uintptr) (interface{}, error) {
		b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
		return (*CSSSection)(unsafe.Pointer(b))
	}
	

	

	

	// Native returns the underlying C source pointer.
	func (c *CSSSection) Native() uintptr {
		return uintptr(unsafe.Pointer(&c.Native))
	}

	

	
	// EndLine returns the line in the CSS document where this section end. The line
// number is 0-indexed, so the first line of the document will return 0. This
// value may change in future invocations of this function if @section is not
// yet parsed completely. This will for example happen in the
// GtkCssProvider::parsing-error signal. The end position and line may be
// identical to the start position and line for sections which failed to parse
// anything successfully.
	func (s *CSSSection) EndLine() uint {
var _arg0 *C.GtkCssSection // out
var _cret C.guint // in

_arg0 = (*C.GtkCssSection)(unsafe.Pointer(s.Native()))

_cret = C.gtk_css_section_get_end_line(_arg0)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// EndPosition returns the offset in bytes from the start of the current line
// returned via gtk_css_section_get_end_line(). This value may change in future
// invocations of this function if @section is not yet parsed completely. This
// will for example happen in the GtkCssProvider::parsing-error signal. The end
// position and line may be identical to the start position and line for
// sections which failed to parse anything successfully.
	func (s *CSSSection) EndPosition() uint {
var _arg0 *C.GtkCssSection // out
var _cret C.guint // in

_arg0 = (*C.GtkCssSection)(unsafe.Pointer(s.Native()))

_cret = C.gtk_css_section_get_end_position(_arg0)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// File gets the file that @section was parsed from. If no such file exists, for
// example because the CSS was loaded via @gtk_css_provider_load_from_data(),
// then nil is returned.
	func (s *CSSSection) File() gio.File {
var _arg0 *C.GtkCssSection // out
var _cret *C.GFile // in

_arg0 = (*C.GtkCssSection)(unsafe.Pointer(s.Native()))

_cret = C.gtk_css_section_get_file(_arg0)


var _file gio.File // out

_file = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.File)

return _file
}
	
	// Parent gets the parent section for the given @section. The parent section is
// the section that contains this @section. A special case are sections of type
// K_CSS_SECTION_DOCUMENT. Their parent will either be nil if they are the
// original CSS document that was loaded by gtk_css_provider_load_from_file() or
// a section of type K_CSS_SECTION_IMPORT if it was loaded with an import rule
// from a different file.
	func (s *CSSSection) Parent() *CSSSection {
var _arg0 *C.GtkCssSection // out
var _cret *C.GtkCssSection // in

_arg0 = (*C.GtkCssSection)(unsafe.Pointer(s.Native()))

_cret = C.gtk_css_section_get_parent(_arg0)


var _cssSection *CSSSection // out

_cssSection = *(**CSSSection)(unsafe.Pointer(&_cret))

return _cssSection
}
	
	// SectionType gets the type of information that @section describes.
	func (s *CSSSection) SectionType() CSSSectionType {
var _arg0 *C.GtkCssSection // out
var _cret C.GtkCssSectionType // in

_arg0 = (*C.GtkCssSection)(unsafe.Pointer(s.Native()))

_cret = C.gtk_css_section_get_section_type(_arg0)


var _cssSectionType CSSSectionType // out

_cssSectionType = CSSSectionType(_cret)

return _cssSectionType
}
	
	// StartLine returns the line in the CSS document where this section starts. The
// line number is 0-indexed, so the first line of the document will return 0.
	func (s *CSSSection) StartLine() uint {
var _arg0 *C.GtkCssSection // out
var _cret C.guint // in

_arg0 = (*C.GtkCssSection)(unsafe.Pointer(s.Native()))

_cret = C.gtk_css_section_get_start_line(_arg0)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// StartPosition returns the offset in bytes from the start of the current line
// returned via gtk_css_section_get_start_line().
	func (s *CSSSection) StartPosition() uint {
var _arg0 *C.GtkCssSection // out
var _cret C.guint // in

_arg0 = (*C.GtkCssSection)(unsafe.Pointer(s.Native()))

_cret = C.gtk_css_section_get_start_position(_arg0)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// Ref increments the reference count on @section.
	func (s *CSSSection) Ref() *CSSSection {
var _arg0 *C.GtkCssSection // out
var _cret *C.GtkCssSection // in

_arg0 = (*C.GtkCssSection)(unsafe.Pointer(s.Native()))

_cret = C.gtk_css_section_ref(_arg0)


var _cssSection *CSSSection // out

_cssSection = *(**CSSSection)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_cssSection, func(v *CSSSection) {
  C.free(unsafe.Pointer(v.Native()))
})

return _cssSection
}
	
	// Unref decrements the reference count on @section, freeing the structure if
// the reference count reaches 0.
	func (s *CSSSection) Unref()  {
var _arg0 *C.GtkCssSection // out

_arg0 = (*C.GtkCssSection)(unsafe.Pointer(s.Native()))

C.gtk_css_section_unref(_arg0)
}
	


	// FileFilterInfo: a FileFilterInfo-struct is used to pass information about the
// tested file to gtk_file_filter_filter().
	type FileFilterInfo struct {
		Native C.GtkFileFilterInfo
	}

	

	

	

	// Native returns the underlying C source pointer.
	func (f *FileFilterInfo) Native() uintptr {
		return uintptr(unsafe.Pointer(&f.Native))
	}

	

	


	
	type FixedChild struct {
		Native C.GtkFixedChild
	}

	

	

	

	// Native returns the underlying C source pointer.
	func (f *FixedChild) Native() uintptr {
		return uintptr(unsafe.Pointer(&f.Native))
	}

	

	


	// Gradient: gtkGradient is a boxed type that represents a gradient. It is the
// result of parsing a [gradient expression][gtkcssprovider-gradients]. To
// obtain the gradient represented by a GtkGradient, it has to be resolved with
// gtk_gradient_resolve(), which replaces all symbolic color references by the
// colors they refer to (in a given context) and constructs a #cairo_pattern_t
// value.
// 
// It is not normally necessary to deal directly with Gradients, since they are
// mostly used behind the scenes by StyleContext and CssProvider.
// 
// Gradient is deprecated. It was used internally by GTK’s CSS engine to
// represent gradients. As its handling is not conforming to modern web
// standards, it is not used anymore. If you want to use gradients in your own
// code, please use Cairo directly.
	type Gradient struct {
		Native C.GtkGradient
	}

	
	func marshalGradient(p uintptr) (interface{}, error) {
		b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
		return (*Gradient)(unsafe.Pointer(b))
	}
	

	
	
	// NewGradientLinear constructs a struct Gradient.
	func NewGradientLinear(x0 float64, y0 float64, x1 float64, y1 float64) *Gradient {
var _arg1 C.gdouble // out
var _arg2 C.gdouble // out
var _arg3 C.gdouble // out
var _arg4 C.gdouble // out
var _cret *C.GtkGradient // in

_arg1 = (C.gdouble)(x0)
_arg2 = (C.gdouble)(y0)
_arg3 = (C.gdouble)(x1)
_arg4 = (C.gdouble)(y1)

_cret = C.gtk_gradient_new_linear(_arg1, _arg2, _arg3, _arg4)


var _gradient *Gradient // out

_gradient = *(**Gradient)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_gradient, func(v *Gradient) {
  C.free(unsafe.Pointer(v.Native()))
})

return _gradient
}
	
	
	
	// NewGradientRadial constructs a struct Gradient.
	func NewGradientRadial(x0 float64, y0 float64, radius0 float64, x1 float64, y1 float64, radius1 float64) *Gradient {
var _arg1 C.gdouble // out
var _arg2 C.gdouble // out
var _arg3 C.gdouble // out
var _arg4 C.gdouble // out
var _arg5 C.gdouble // out
var _arg6 C.gdouble // out
var _cret *C.GtkGradient // in

_arg1 = (C.gdouble)(x0)
_arg2 = (C.gdouble)(y0)
_arg3 = (C.gdouble)(radius0)
_arg4 = (C.gdouble)(x1)
_arg5 = (C.gdouble)(y1)
_arg6 = (C.gdouble)(radius1)

_cret = C.gtk_gradient_new_radial(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)


var _gradient *Gradient // out

_gradient = *(**Gradient)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_gradient, func(v *Gradient) {
  C.free(unsafe.Pointer(v.Native()))
})

return _gradient
}
	
	

	

	// Native returns the underlying C source pointer.
	func (g *Gradient) Native() uintptr {
		return uintptr(unsafe.Pointer(&g.Native))
	}

	

	
	// AddColorStop adds a stop color to @gradient.
	func (g *Gradient) AddColorStop(offset float64, color *SymbolicColor)  {
var _arg0 *C.GtkGradient // out
var _arg1 C.gdouble // out
var _arg2 *C.GtkSymbolicColor // out

_arg0 = (*C.GtkGradient)(unsafe.Pointer(g.Native()))
_arg1 = (C.gdouble)(offset)
_arg2 = (*C.GtkSymbolicColor)(unsafe.Pointer(color.Native()))

C.gtk_gradient_add_color_stop(_arg0, _arg1, _arg2)
}
	
	// Ref increases the reference count of @gradient.
	func (g *Gradient) Ref() *Gradient {
var _arg0 *C.GtkGradient // out
var _cret *C.GtkGradient // in

_arg0 = (*C.GtkGradient)(unsafe.Pointer(g.Native()))

_cret = C.gtk_gradient_ref(_arg0)


var _ret *Gradient // out

_ret = *(**Gradient)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_ret, func(v *Gradient) {
  C.free(unsafe.Pointer(v.Native()))
})

return _ret
}
	
	// Resolve: if @gradient is resolvable, @resolved_gradient will be filled in
// with the resolved gradient as a cairo_pattern_t, and true will be returned.
// Generally, if @gradient can’t be resolved, it is due to it being defined on
// top of a named color that doesn't exist in @props.
	func (g *Gradient) Resolve(props StylePropertiesClass) (*cairo.Pattern, bool) {
var _arg0 *C.GtkGradient // out
var _arg1 *C.GtkStyleProperties // out
var _resolvedGradient *cairo.Pattern
var _cret C.gboolean // in

_arg0 = (*C.GtkGradient)(unsafe.Pointer(g.Native()))
_arg1 = (*C.GtkStyleProperties)(unsafe.Pointer(props.Native()))

_cret = C.gtk_gradient_resolve(_arg0, _arg1, (**C.cairo_pattern_t)(unsafe.Pointer(&_resolvedGradient)))



var _ok bool // out


if _cret != 0 { _ok = true }

return _resolvedGradient, _ok
}
	
	
	func (g *Gradient) ResolveForContext(context StyleContextClass) *cairo.Pattern {
var _arg0 *C.GtkGradient // out
var _arg1 *C.GtkStyleContext // out
var _cret *C.cairo_pattern_t // in

_arg0 = (*C.GtkGradient)(unsafe.Pointer(g.Native()))
_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))

_cret = C.gtk_gradient_resolve_for_context(_arg0, _arg1)


var _pattern *cairo.Pattern // out

_pattern = *(**cairo.Pattern)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_pattern, func(v *cairo.Pattern) {
  C.free(unsafe.Pointer(v.Native()))
})

return _pattern
}
	
	// String creates a string representation for @gradient that is suitable for
// using in GTK CSS files.
	func (g *Gradient) String() string {
var _arg0 *C.GtkGradient // out
var _cret *C.char // in

_arg0 = (*C.GtkGradient)(unsafe.Pointer(g.Native()))

_cret = C.gtk_gradient_to_string(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// Unref decreases the reference count of @gradient, freeing its memory if the
// reference count reaches 0.
	func (g *Gradient) Unref()  {
var _arg0 *C.GtkGradient // out

_arg0 = (*C.GtkGradient)(unsafe.Pointer(g.Native()))

C.gtk_gradient_unref(_arg0)
}
	


	// IMContextInfo: bookkeeping information about a loadable input method.
	type IMContextInfo struct {
		Native C.GtkIMContextInfo
	}

	

	

	

	// Native returns the underlying C source pointer.
	func (i *IMContextInfo) Native() uintptr {
		return uintptr(unsafe.Pointer(&i.Native))
	}

	

	


	
	type IconSet struct {
		Native C.GtkIconSet
	}

	
	func marshalIconSet(p uintptr) (interface{}, error) {
		b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
		return (*IconSet)(unsafe.Pointer(b))
	}
	

	
	
	// NewIconSet constructs a struct IconSet.
	func NewIconSet() *IconSet {
var _cret *C.GtkIconSet // in

_cret = C.gtk_icon_set_new()


var _iconSet *IconSet // out

_iconSet = *(**IconSet)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_iconSet, func(v *IconSet) {
  C.free(unsafe.Pointer(v.Native()))
})

return _iconSet
}
	
	
	
	// NewIconSetFromPixbuf constructs a struct IconSet.
	func NewIconSetFromPixbuf(pixbuf gdkpixbuf.PixbufClass) *IconSet {
var _arg1 *C.GdkPixbuf // out
var _cret *C.GtkIconSet // in

_arg1 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))

_cret = C.gtk_icon_set_new_from_pixbuf(_arg1)


var _iconSet *IconSet // out

_iconSet = *(**IconSet)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_iconSet, func(v *IconSet) {
  C.free(unsafe.Pointer(v.Native()))
})

return _iconSet
}
	
	

	

	// Native returns the underlying C source pointer.
	func (i *IconSet) Native() uintptr {
		return uintptr(unsafe.Pointer(&i.Native))
	}

	

	
	// AddSource: icon sets have a list of IconSource, which they use as base icons
// for rendering icons in different states and sizes. Icons are scaled, made to
// look insensitive, etc. in gtk_icon_set_render_icon(), but IconSet needs base
// images to work with. The base images and when to use them are described by a
// IconSource.
// 
// This function copies @source, so you can reuse the same source immediately
// without affecting the icon set.
// 
// An example of when you’d use this function: a web browser’s "Back to Previous
// Page" icon might point in a different direction in Hebrew and in English; it
// might look different when insensitive; and it might change size depending on
// toolbar mode (small/large icons). So a single icon set would contain all
// those variants of the icon, and you might add a separate source for each one.
// 
// You should nearly always add a “default” icon source with all fields
// wildcarded, which will be used as a fallback if no more specific source
// matches. IconSet always prefers more specific icon sources to more generic
// icon sources. The order in which you add the sources to the icon set does not
// matter.
// 
// gtk_icon_set_new_from_pixbuf() creates a new icon set with a default icon
// source based on the given pixbuf.
	func (i *IconSet) AddSource(source *IconSource)  {
var _arg0 *C.GtkIconSet // out
var _arg1 *C.GtkIconSource // out

_arg0 = (*C.GtkIconSet)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GtkIconSource)(unsafe.Pointer(source.Native()))

C.gtk_icon_set_add_source(_arg0, _arg1)
}
	
	// Copy copies @icon_set by value.
	func (i *IconSet) Copy() *IconSet {
var _arg0 *C.GtkIconSet // out
var _cret *C.GtkIconSet // in

_arg0 = (*C.GtkIconSet)(unsafe.Pointer(i.Native()))

_cret = C.gtk_icon_set_copy(_arg0)


var _iconSet *IconSet // out

_iconSet = *(**IconSet)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_iconSet, func(v *IconSet) {
  C.free(unsafe.Pointer(v.Native()))
})

return _iconSet
}
	
	// Sizes obtains a list of icon sizes this icon set can render. The returned
// array must be freed with g_free().
	func (i *IconSet) Sizes() []int {
var _arg0 *C.GtkIconSet // out
var _arg1 *C.GtkIconSize
var _arg2 C.gint // in

_arg0 = (*C.GtkIconSet)(unsafe.Pointer(i.Native()))

C.gtk_icon_set_get_sizes(_arg0, &_arg1, &_arg2)

var _sizes []int

_sizes = unsafe.Slice((*int)(unsafe.Pointer(_arg1)), _arg2)
runtime.SetFinalizer(&_sizes, func(v *[]int) {
  C.free(unsafe.Pointer(&(*v)[0]))
})

return _sizes
}
	
	// Ref increments the reference count on @icon_set.
	func (i *IconSet) Ref() *IconSet {
var _arg0 *C.GtkIconSet // out
var _cret *C.GtkIconSet // in

_arg0 = (*C.GtkIconSet)(unsafe.Pointer(i.Native()))

_cret = C.gtk_icon_set_ref(_arg0)


var _iconSet *IconSet // out

_iconSet = *(**IconSet)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_iconSet, func(v *IconSet) {
  C.free(unsafe.Pointer(v.Native()))
})

return _iconSet
}
	
	// RenderIcon renders an icon using gtk_style_render_icon(). In most cases,
// gtk_widget_render_icon() is better, since it automatically provides most of
// the arguments from the current widget settings. This function never returns
// nil; if the icon can’t be rendered (perhaps because an image file fails to
// load), a default "missing image" icon will be returned instead.
	func (i *IconSet) RenderIcon(style StyleClass, direction TextDirection, state StateType, size int, widget WidgetClass, detail string) gdkpixbuf.Pixbuf {
var _arg0 *C.GtkIconSet // out
var _arg1 *C.GtkStyle // out
var _arg2 C.GtkTextDirection // out
var _arg3 C.GtkStateType // out
var _arg4 C.GtkIconSize // out
var _arg5 *C.GtkWidget // out
var _arg6 *C.gchar // out
var _cret *C.GdkPixbuf // in

_arg0 = (*C.GtkIconSet)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GtkStyle)(unsafe.Pointer(style.Native()))
_arg2 = (C.GtkTextDirection)(direction)
_arg3 = (C.GtkStateType)(state)
_arg4 = (C.GtkIconSize)(size)
_arg5 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg6 = (*C.gchar)(C.CString(detail))
defer C.free(unsafe.Pointer(_arg6))

_cret = C.gtk_icon_set_render_icon(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)


var _pixbuf gdkpixbuf.Pixbuf // out

_pixbuf = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gdkpixbuf.Pixbuf)

return _pixbuf
}
	
	// RenderIconPixbuf renders an icon using gtk_render_icon_pixbuf(). In most
// cases, gtk_widget_render_icon_pixbuf() is better, since it automatically
// provides most of the arguments from the current widget settings. This
// function never returns nil; if the icon can’t be rendered (perhaps because an
// image file fails to load), a default "missing image" icon will be returned
// instead.
	func (i *IconSet) RenderIconPixbuf(context StyleContextClass, size int) gdkpixbuf.Pixbuf {
var _arg0 *C.GtkIconSet // out
var _arg1 *C.GtkStyleContext // out
var _arg2 C.GtkIconSize // out
var _cret *C.GdkPixbuf // in

_arg0 = (*C.GtkIconSet)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))
_arg2 = (C.GtkIconSize)(size)

_cret = C.gtk_icon_set_render_icon_pixbuf(_arg0, _arg1, _arg2)


var _pixbuf gdkpixbuf.Pixbuf // out

_pixbuf = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gdkpixbuf.Pixbuf)

return _pixbuf
}
	
	// RenderIconSurface renders an icon using gtk_render_icon_pixbuf() and converts
// it to a cairo surface.
// 
// This function never returns nil; if the icon can’t be rendered (perhaps
// because an image file fails to load), a default "missing image" icon will be
// returned instead.
	func (i *IconSet) RenderIconSurface(context StyleContextClass, size int, scale int, forWindow gdk.WindowClass) *cairo.Surface {
var _arg0 *C.GtkIconSet // out
var _arg1 *C.GtkStyleContext // out
var _arg2 C.GtkIconSize // out
var _arg3 C.int // out
var _arg4 *C.GdkWindow // out
var _cret *C.cairo_surface_t // in

_arg0 = (*C.GtkIconSet)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))
_arg2 = (C.GtkIconSize)(size)
_arg3 = (C.int)(scale)
_arg4 = (*C.GdkWindow)(unsafe.Pointer(forWindow.Native()))

_cret = C.gtk_icon_set_render_icon_surface(_arg0, _arg1, _arg2, _arg3, _arg4)


var _surface *cairo.Surface // out

_surface = *(**cairo.Surface)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_surface, func(v *cairo.Surface) {
  C.free(unsafe.Pointer(v.Native()))
})

return _surface
}
	
	// Unref decrements the reference count on @icon_set, and frees memory if the
// reference count reaches 0.
	func (i *IconSet) Unref()  {
var _arg0 *C.GtkIconSet // out

_arg0 = (*C.GtkIconSet)(unsafe.Pointer(i.Native()))

C.gtk_icon_set_unref(_arg0)
}
	


	
	type IconSource struct {
		Native C.GtkIconSource
	}

	
	func marshalIconSource(p uintptr) (interface{}, error) {
		b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
		return (*IconSource)(unsafe.Pointer(b))
	}
	

	
	
	// NewIconSource constructs a struct IconSource.
	func NewIconSource() *IconSource {
var _cret *C.GtkIconSource // in

_cret = C.gtk_icon_source_new()


var _iconSource *IconSource // out

_iconSource = *(**IconSource)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_iconSource, func(v *IconSource) {
  C.free(unsafe.Pointer(v.Native()))
})

return _iconSource
}
	
	

	

	// Native returns the underlying C source pointer.
	func (i *IconSource) Native() uintptr {
		return uintptr(unsafe.Pointer(&i.Native))
	}

	

	
	// Copy creates a copy of @source; mostly useful for language bindings.
	func (s *IconSource) Copy() *IconSource {
var _arg0 *C.GtkIconSource // out
var _cret *C.GtkIconSource // in

_arg0 = (*C.GtkIconSource)(unsafe.Pointer(s.Native()))

_cret = C.gtk_icon_source_copy(_arg0)


var _iconSource *IconSource // out

_iconSource = *(**IconSource)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_iconSource, func(v *IconSource) {
  C.free(unsafe.Pointer(v.Native()))
})

return _iconSource
}
	
	// Free frees a dynamically-allocated icon source, along with its filename,
// size, and pixbuf fields if those are not nil.
	func (s *IconSource) Free()  {
var _arg0 *C.GtkIconSource // out

_arg0 = (*C.GtkIconSource)(unsafe.Pointer(s.Native()))

C.gtk_icon_source_free(_arg0)
}
	
	// Direction obtains the text direction this icon source applies to. The return
// value is only useful/meaningful if the text direction is not wildcarded.
	func (s *IconSource) Direction() TextDirection {
var _arg0 *C.GtkIconSource // out
var _cret C.GtkTextDirection // in

_arg0 = (*C.GtkIconSource)(unsafe.Pointer(s.Native()))

_cret = C.gtk_icon_source_get_direction(_arg0)


var _textDirection TextDirection // out

_textDirection = TextDirection(_cret)

return _textDirection
}
	
	// DirectionWildcarded gets the value set by
// gtk_icon_source_set_direction_wildcarded().
	func (s *IconSource) DirectionWildcarded() bool {
var _arg0 *C.GtkIconSource // out
var _cret C.gboolean // in

_arg0 = (*C.GtkIconSource)(unsafe.Pointer(s.Native()))

_cret = C.gtk_icon_source_get_direction_wildcarded(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Filename retrieves the source filename, or nil if none is set. The filename
// is not a copy, and should not be modified or expected to persist beyond the
// lifetime of the icon source.
	func (s *IconSource) Filename() string {
var _arg0 *C.GtkIconSource // out
var _cret *C.gchar // in

_arg0 = (*C.GtkIconSource)(unsafe.Pointer(s.Native()))

_cret = C.gtk_icon_source_get_filename(_arg0)


var _filename string // out

_filename = C.GoString(_cret)

return _filename
}
	
	// IconName retrieves the source icon name, or nil if none is set. The icon_name
// is not a copy, and should not be modified or expected to persist beyond the
// lifetime of the icon source.
	func (s *IconSource) IconName() string {
var _arg0 *C.GtkIconSource // out
var _cret *C.gchar // in

_arg0 = (*C.GtkIconSource)(unsafe.Pointer(s.Native()))

_cret = C.gtk_icon_source_get_icon_name(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Pixbuf retrieves the source pixbuf, or nil if none is set. In addition, if a
// filename source is in use, this function in some cases will return the pixbuf
// from loaded from the filename. This is, for example, true for the
// GtkIconSource passed to the Style render_icon() virtual function. The
// reference count on the pixbuf is not incremented.
	func (s *IconSource) Pixbuf() gdkpixbuf.Pixbuf {
var _arg0 *C.GtkIconSource // out
var _cret *C.GdkPixbuf // in

_arg0 = (*C.GtkIconSource)(unsafe.Pointer(s.Native()))

_cret = C.gtk_icon_source_get_pixbuf(_arg0)


var _pixbuf gdkpixbuf.Pixbuf // out

_pixbuf = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdkpixbuf.Pixbuf)

return _pixbuf
}
	
	// Size obtains the icon size this source applies to. The return value is only
// useful/meaningful if the icon size is not wildcarded.
	func (s *IconSource) Size() int {
var _arg0 *C.GtkIconSource // out
var _cret C.GtkIconSize // in

_arg0 = (*C.GtkIconSource)(unsafe.Pointer(s.Native()))

_cret = C.gtk_icon_source_get_size(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// SizeWildcarded gets the value set by gtk_icon_source_set_size_wildcarded().
	func (s *IconSource) SizeWildcarded() bool {
var _arg0 *C.GtkIconSource // out
var _cret C.gboolean // in

_arg0 = (*C.GtkIconSource)(unsafe.Pointer(s.Native()))

_cret = C.gtk_icon_source_get_size_wildcarded(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// State obtains the widget state this icon source applies to. The return value
// is only useful/meaningful if the widget state is not wildcarded.
	func (s *IconSource) State() StateType {
var _arg0 *C.GtkIconSource // out
var _cret C.GtkStateType // in

_arg0 = (*C.GtkIconSource)(unsafe.Pointer(s.Native()))

_cret = C.gtk_icon_source_get_state(_arg0)


var _stateType StateType // out

_stateType = StateType(_cret)

return _stateType
}
	
	// StateWildcarded gets the value set by gtk_icon_source_set_state_wildcarded().
	func (s *IconSource) StateWildcarded() bool {
var _arg0 *C.GtkIconSource // out
var _cret C.gboolean // in

_arg0 = (*C.GtkIconSource)(unsafe.Pointer(s.Native()))

_cret = C.gtk_icon_source_get_state_wildcarded(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetDirection sets the text direction this icon source is intended to be used
// with.
// 
// Setting the text direction on an icon source makes no difference if the text
// direction is wildcarded. Therefore, you should usually call
// gtk_icon_source_set_direction_wildcarded() to un-wildcard it in addition to
// calling this function.
	func (s *IconSource) SetDirection(direction TextDirection)  {
var _arg0 *C.GtkIconSource // out
var _arg1 C.GtkTextDirection // out

_arg0 = (*C.GtkIconSource)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkTextDirection)(direction)

C.gtk_icon_source_set_direction(_arg0, _arg1)
}
	
	// SetDirectionWildcarded: if the text direction is wildcarded, this source can
// be used as the base image for an icon in any TextDirection. If the text
// direction is not wildcarded, then the text direction the icon source applies
// to should be set with gtk_icon_source_set_direction(), and the icon source
// will only be used with that text direction.
// 
// IconSet prefers non-wildcarded sources (exact matches) over wildcarded
// sources, and will use an exact match when possible.
	func (s *IconSource) SetDirectionWildcarded(setting bool)  {
var _arg0 *C.GtkIconSource // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkIconSource)(unsafe.Pointer(s.Native()))
if setting { _arg1 = C.TRUE }

C.gtk_icon_source_set_direction_wildcarded(_arg0, _arg1)
}
	
	// SetFilename sets the name of an image file to use as a base image when
// creating icon variants for IconSet. The filename must be absolute.
	func (s *IconSource) SetFilename(filename string)  {
var _arg0 *C.GtkIconSource // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkIconSource)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(filename))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_icon_source_set_filename(_arg0, _arg1)
}
	
	// SetIconName sets the name of an icon to look up in the current icon theme to
// use as a base image when creating icon variants for IconSet.
	func (s *IconSource) SetIconName(iconName string)  {
var _arg0 *C.GtkIconSource // out
var _arg1 *C.gchar // out

_arg0 = (*C.GtkIconSource)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(iconName))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_icon_source_set_icon_name(_arg0, _arg1)
}
	
	// SetPixbuf sets a pixbuf to use as a base image when creating icon variants
// for IconSet.
	func (s *IconSource) SetPixbuf(pixbuf gdkpixbuf.PixbufClass)  {
var _arg0 *C.GtkIconSource // out
var _arg1 *C.GdkPixbuf // out

_arg0 = (*C.GtkIconSource)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))

C.gtk_icon_source_set_pixbuf(_arg0, _arg1)
}
	
	// SetSize sets the icon size this icon source is intended to be used with.
// 
// Setting the icon size on an icon source makes no difference if the size is
// wildcarded. Therefore, you should usually call
// gtk_icon_source_set_size_wildcarded() to un-wildcard it in addition to
// calling this function.
	func (s *IconSource) SetSize(size int)  {
var _arg0 *C.GtkIconSource // out
var _arg1 C.GtkIconSize // out

_arg0 = (*C.GtkIconSource)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkIconSize)(size)

C.gtk_icon_source_set_size(_arg0, _arg1)
}
	
	// SetSizeWildcarded: if the icon size is wildcarded, this source can be used as
// the base image for an icon of any size. If the size is not wildcarded, then
// the size the source applies to should be set with gtk_icon_source_set_size()
// and the icon source will only be used with that specific size.
// 
// IconSet prefers non-wildcarded sources (exact matches) over wildcarded
// sources, and will use an exact match when possible.
// 
// IconSet will normally scale wildcarded source images to produce an
// appropriate icon at a given size, but will not change the size of source
// images that match exactly.
	func (s *IconSource) SetSizeWildcarded(setting bool)  {
var _arg0 *C.GtkIconSource // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkIconSource)(unsafe.Pointer(s.Native()))
if setting { _arg1 = C.TRUE }

C.gtk_icon_source_set_size_wildcarded(_arg0, _arg1)
}
	
	// SetState sets the widget state this icon source is intended to be used with.
// 
// Setting the widget state on an icon source makes no difference if the state
// is wildcarded. Therefore, you should usually call
// gtk_icon_source_set_state_wildcarded() to un-wildcard it in addition to
// calling this function.
	func (s *IconSource) SetState(state StateType)  {
var _arg0 *C.GtkIconSource // out
var _arg1 C.GtkStateType // out

_arg0 = (*C.GtkIconSource)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkStateType)(state)

C.gtk_icon_source_set_state(_arg0, _arg1)
}
	
	// SetStateWildcarded: if the widget state is wildcarded, this source can be
// used as the base image for an icon in any StateType. If the widget state is
// not wildcarded, then the state the source applies to should be set with
// gtk_icon_source_set_state() and the icon source will only be used with that
// specific state.
// 
// IconSet prefers non-wildcarded sources (exact matches) over wildcarded
// sources, and will use an exact match when possible.
// 
// IconSet will normally transform wildcarded source images to produce an
// appropriate icon for a given state, for example lightening an image on
// prelight, but will not modify source images that match exactly.
	func (s *IconSource) SetStateWildcarded(setting bool)  {
var _arg0 *C.GtkIconSource // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkIconSource)(unsafe.Pointer(s.Native()))
if setting { _arg1 = C.TRUE }

C.gtk_icon_source_set_state_wildcarded(_arg0, _arg1)
}
	


	
	type LabelSelectionInfo struct {
		Native C.GtkLabelSelectionInfo
	}

	

	

	

	// Native returns the underlying C source pointer.
	func (l *LabelSelectionInfo) Native() uintptr {
		return uintptr(unsafe.Pointer(&l.Native))
	}

	

	


	// PadActionEntry: struct defining a pad action entry.
	type PadActionEntry struct {
		Native C.GtkPadActionEntry
	}

	

	

	

	// Native returns the underlying C source pointer.
	func (p *PadActionEntry) Native() uintptr {
		return uintptr(unsafe.Pointer(&p.Native))
	}

	

	


	// PageRange: see also gtk_print_settings_set_page_ranges().
	type PageRange struct {
		Native C.GtkPageRange
	}

	

	

	

	// Native returns the underlying C source pointer.
	func (p *PageRange) Native() uintptr {
		return uintptr(unsafe.Pointer(&p.Native))
	}

	

	


	// PaperSize: gtkPaperSize handles paper sizes. It uses the standard called PWG
// 5101.1-2002 PWG: Standard for Media Standardized Names
// (http://www.pwg.org/standards.html) to name the paper sizes (and to get the
// data for the page sizes). In addition to standard paper sizes, GtkPaperSize
// allows to construct custom paper sizes with arbitrary dimensions.
// 
// The PaperSize object stores not only the dimensions (width and height) of a
// paper size and its name, it also provides default [print
// margins][print-margins].
// 
// Printing support has been added in GTK+ 2.10.
	type PaperSize struct {
		Native C.GtkPaperSize
	}

	
	func marshalPaperSize(p uintptr) (interface{}, error) {
		b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
		return (*PaperSize)(unsafe.Pointer(b))
	}
	

	
	
	// NewPaperSize constructs a struct PaperSize.
	func NewPaperSize(name string) *PaperSize {
var _arg1 *C.gchar // out
var _cret *C.GtkPaperSize // in

_arg1 = (*C.gchar)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_paper_size_new(_arg1)


var _paperSize *PaperSize // out

_paperSize = *(**PaperSize)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_paperSize, func(v *PaperSize) {
  C.free(unsafe.Pointer(v.Native()))
})

return _paperSize
}
	
	
	
	// NewPaperSizeCustom constructs a struct PaperSize.
	func NewPaperSizeCustom(name string, displayName string, width float64, height float64, unit Unit) *PaperSize {
var _arg1 *C.gchar // out
var _arg2 *C.gchar // out
var _arg3 C.gdouble // out
var _arg4 C.gdouble // out
var _arg5 C.GtkUnit // out
var _cret *C.GtkPaperSize // in

_arg1 = (*C.gchar)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.gchar)(C.CString(displayName))
defer C.free(unsafe.Pointer(_arg2))
_arg3 = (C.gdouble)(width)
_arg4 = (C.gdouble)(height)
_arg5 = (C.GtkUnit)(unit)

_cret = C.gtk_paper_size_new_custom(_arg1, _arg2, _arg3, _arg4, _arg5)


var _paperSize *PaperSize // out

_paperSize = *(**PaperSize)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_paperSize, func(v *PaperSize) {
  C.free(unsafe.Pointer(v.Native()))
})

return _paperSize
}
	
	
	
	// NewPaperSizeFromGVariant constructs a struct PaperSize.
	func NewPaperSizeFromGVariant(variant *glib.Variant) *PaperSize {
var _arg1 *C.GVariant // out
var _cret *C.GtkPaperSize // in

_arg1 = (*C.GVariant)(unsafe.Pointer(variant.Native()))

_cret = C.gtk_paper_size_new_from_gvariant(_arg1)


var _paperSize *PaperSize // out

_paperSize = *(**PaperSize)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_paperSize, func(v *PaperSize) {
  C.free(unsafe.Pointer(v.Native()))
})

return _paperSize
}
	
	
	
	// NewPaperSizeFromIpp constructs a struct PaperSize.
	func NewPaperSizeFromIpp(ippName string, width float64, height float64) *PaperSize {
var _arg1 *C.gchar // out
var _arg2 C.gdouble // out
var _arg3 C.gdouble // out
var _cret *C.GtkPaperSize // in

_arg1 = (*C.gchar)(C.CString(ippName))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.gdouble)(width)
_arg3 = (C.gdouble)(height)

_cret = C.gtk_paper_size_new_from_ipp(_arg1, _arg2, _arg3)


var _paperSize *PaperSize // out

_paperSize = *(**PaperSize)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_paperSize, func(v *PaperSize) {
  C.free(unsafe.Pointer(v.Native()))
})

return _paperSize
}
	
	
	
	// NewPaperSizeFromKeyFile constructs a struct PaperSize.
	func NewPaperSizeFromKeyFile(keyFile *glib.KeyFile, groupName string) (*PaperSize, error) {
var _arg1 *C.GKeyFile // out
var _arg2 *C.gchar // out
var _cret *C.GtkPaperSize // in
var _cerr *C.GError // in

_arg1 = (*C.GKeyFile)(unsafe.Pointer(keyFile.Native()))
_arg2 = (*C.gchar)(C.CString(groupName))
defer C.free(unsafe.Pointer(_arg2))

_cret = C.gtk_paper_size_new_from_key_file(_arg1, _arg2, &_cerr)


var _paperSize *PaperSize // out
var _goerr error // out

_paperSize = *(**PaperSize)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_paperSize, func(v *PaperSize) {
  C.free(unsafe.Pointer(v.Native()))
})
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _paperSize, _goerr
}
	
	
	
	// NewPaperSizeFromPpd constructs a struct PaperSize.
	func NewPaperSizeFromPpd(ppdName string, ppdDisplayName string, width float64, height float64) *PaperSize {
var _arg1 *C.gchar // out
var _arg2 *C.gchar // out
var _arg3 C.gdouble // out
var _arg4 C.gdouble // out
var _cret *C.GtkPaperSize // in

_arg1 = (*C.gchar)(C.CString(ppdName))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.gchar)(C.CString(ppdDisplayName))
defer C.free(unsafe.Pointer(_arg2))
_arg3 = (C.gdouble)(width)
_arg4 = (C.gdouble)(height)

_cret = C.gtk_paper_size_new_from_ppd(_arg1, _arg2, _arg3, _arg4)


var _paperSize *PaperSize // out

_paperSize = *(**PaperSize)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_paperSize, func(v *PaperSize) {
  C.free(unsafe.Pointer(v.Native()))
})

return _paperSize
}
	
	

	

	// Native returns the underlying C source pointer.
	func (p *PaperSize) Native() uintptr {
		return uintptr(unsafe.Pointer(&p.Native))
	}

	

	
	// Copy copies an existing PaperSize.
	func (o *PaperSize) Copy() *PaperSize {
var _arg0 *C.GtkPaperSize // out
var _cret *C.GtkPaperSize // in

_arg0 = (*C.GtkPaperSize)(unsafe.Pointer(o.Native()))

_cret = C.gtk_paper_size_copy(_arg0)


var _paperSize *PaperSize // out

_paperSize = *(**PaperSize)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_paperSize, func(v *PaperSize) {
  C.free(unsafe.Pointer(v.Native()))
})

return _paperSize
}
	
	// Free: free the given PaperSize object.
	func (s *PaperSize) Free()  {
var _arg0 *C.GtkPaperSize // out

_arg0 = (*C.GtkPaperSize)(unsafe.Pointer(s.Native()))

C.gtk_paper_size_free(_arg0)
}
	
	// DefaultBottomMargin gets the default bottom margin for the PaperSize.
	func (s *PaperSize) DefaultBottomMargin(unit Unit) float64 {
var _arg0 *C.GtkPaperSize // out
var _arg1 C.GtkUnit // out
var _cret C.gdouble // in

_arg0 = (*C.GtkPaperSize)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkUnit)(unit)

_cret = C.gtk_paper_size_get_default_bottom_margin(_arg0, _arg1)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// DefaultLeftMargin gets the default left margin for the PaperSize.
	func (s *PaperSize) DefaultLeftMargin(unit Unit) float64 {
var _arg0 *C.GtkPaperSize // out
var _arg1 C.GtkUnit // out
var _cret C.gdouble // in

_arg0 = (*C.GtkPaperSize)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkUnit)(unit)

_cret = C.gtk_paper_size_get_default_left_margin(_arg0, _arg1)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// DefaultRightMargin gets the default right margin for the PaperSize.
	func (s *PaperSize) DefaultRightMargin(unit Unit) float64 {
var _arg0 *C.GtkPaperSize // out
var _arg1 C.GtkUnit // out
var _cret C.gdouble // in

_arg0 = (*C.GtkPaperSize)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkUnit)(unit)

_cret = C.gtk_paper_size_get_default_right_margin(_arg0, _arg1)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// DefaultTopMargin gets the default top margin for the PaperSize.
	func (s *PaperSize) DefaultTopMargin(unit Unit) float64 {
var _arg0 *C.GtkPaperSize // out
var _arg1 C.GtkUnit // out
var _cret C.gdouble // in

_arg0 = (*C.GtkPaperSize)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkUnit)(unit)

_cret = C.gtk_paper_size_get_default_top_margin(_arg0, _arg1)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// DisplayName gets the human-readable name of the PaperSize.
	func (s *PaperSize) DisplayName() string {
var _arg0 *C.GtkPaperSize // out
var _cret *C.gchar // in

_arg0 = (*C.GtkPaperSize)(unsafe.Pointer(s.Native()))

_cret = C.gtk_paper_size_get_display_name(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Height gets the paper height of the PaperSize, in units of @unit.
	func (s *PaperSize) Height(unit Unit) float64 {
var _arg0 *C.GtkPaperSize // out
var _arg1 C.GtkUnit // out
var _cret C.gdouble // in

_arg0 = (*C.GtkPaperSize)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkUnit)(unit)

_cret = C.gtk_paper_size_get_height(_arg0, _arg1)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// Name gets the name of the PaperSize.
	func (s *PaperSize) Name() string {
var _arg0 *C.GtkPaperSize // out
var _cret *C.gchar // in

_arg0 = (*C.GtkPaperSize)(unsafe.Pointer(s.Native()))

_cret = C.gtk_paper_size_get_name(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// PpdName gets the PPD name of the PaperSize, which may be nil.
	func (s *PaperSize) PpdName() string {
var _arg0 *C.GtkPaperSize // out
var _cret *C.gchar // in

_arg0 = (*C.GtkPaperSize)(unsafe.Pointer(s.Native()))

_cret = C.gtk_paper_size_get_ppd_name(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Width gets the paper width of the PaperSize, in units of @unit.
	func (s *PaperSize) Width(unit Unit) float64 {
var _arg0 *C.GtkPaperSize // out
var _arg1 C.GtkUnit // out
var _cret C.gdouble // in

_arg0 = (*C.GtkPaperSize)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkUnit)(unit)

_cret = C.gtk_paper_size_get_width(_arg0, _arg1)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// IsCustom returns true if @size is not a standard paper size.
	func (s *PaperSize) IsCustom() bool {
var _arg0 *C.GtkPaperSize // out
var _cret C.gboolean // in

_arg0 = (*C.GtkPaperSize)(unsafe.Pointer(s.Native()))

_cret = C.gtk_paper_size_is_custom(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsEqual compares two PaperSize objects.
	func (s *PaperSize) IsEqual(size2 *PaperSize) bool {
var _arg0 *C.GtkPaperSize // out
var _arg1 *C.GtkPaperSize // out
var _cret C.gboolean // in

_arg0 = (*C.GtkPaperSize)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkPaperSize)(unsafe.Pointer(size2.Native()))

_cret = C.gtk_paper_size_is_equal(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsIpp returns true if @size is an IPP standard paper size.
	func (s *PaperSize) IsIpp() bool {
var _arg0 *C.GtkPaperSize // out
var _cret C.gboolean // in

_arg0 = (*C.GtkPaperSize)(unsafe.Pointer(s.Native()))

_cret = C.gtk_paper_size_is_ipp(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetSize changes the dimensions of a @size to @width x @height.
	func (s *PaperSize) SetSize(width float64, height float64, unit Unit)  {
var _arg0 *C.GtkPaperSize // out
var _arg1 C.gdouble // out
var _arg2 C.gdouble // out
var _arg3 C.GtkUnit // out

_arg0 = (*C.GtkPaperSize)(unsafe.Pointer(s.Native()))
_arg1 = (C.gdouble)(width)
_arg2 = (C.gdouble)(height)
_arg3 = (C.GtkUnit)(unit)

C.gtk_paper_size_set_size(_arg0, _arg1, _arg2, _arg3)
}
	
	// ToGVariant: serialize a paper size to an a{sv} variant.
	func (p *PaperSize) ToGVariant() *glib.Variant {
var _arg0 *C.GtkPaperSize // out
var _cret *C.GVariant // in

_arg0 = (*C.GtkPaperSize)(unsafe.Pointer(p.Native()))

_cret = C.gtk_paper_size_to_gvariant(_arg0)


var _variant *glib.Variant // out

_variant = *(**glib.Variant)(unsafe.Pointer(&_cret))

return _variant
}
	
	// ToKeyFile: this function adds the paper size from @size to @key_file.
	func (s *PaperSize) ToKeyFile(keyFile *glib.KeyFile, groupName string)  {
var _arg0 *C.GtkPaperSize // out
var _arg1 *C.GKeyFile // out
var _arg2 *C.gchar // out

_arg0 = (*C.GtkPaperSize)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GKeyFile)(unsafe.Pointer(keyFile.Native()))
_arg2 = (*C.gchar)(C.CString(groupName))
defer C.free(unsafe.Pointer(_arg2))

C.gtk_paper_size_to_key_file(_arg0, _arg1, _arg2)
}
	


	// RadioActionEntry structs are used with gtk_action_group_add_radio_actions()
// to construct groups of radio actions.
	type RadioActionEntry struct {
		Native C.GtkRadioActionEntry
	}

	

	

	

	// Native returns the underlying C source pointer.
	func (r *RadioActionEntry) Native() uintptr {
		return uintptr(unsafe.Pointer(&r.Native))
	}

	

	


	
	type RCContext struct {
		Native C.GtkRcContext
	}

	

	

	

	// Native returns the underlying C source pointer.
	func (r *RCContext) Native() uintptr {
		return uintptr(unsafe.Pointer(&r.Native))
	}

	

	


	// RecentData: meta-data to be passed to gtk_recent_manager_add_full() when
// registering a recently used resource.
	type RecentData struct {
		Native C.GtkRecentData
	}

	

	

	

	// Native returns the underlying C source pointer.
	func (r *RecentData) Native() uintptr {
		return uintptr(unsafe.Pointer(&r.Native))
	}

	

	


	// RecentFilterInfo: a GtkRecentFilterInfo struct is used to pass information
// about the tested file to gtk_recent_filter_filter().
	type RecentFilterInfo struct {
		Native C.GtkRecentFilterInfo
	}

	

	

	

	// Native returns the underlying C source pointer.
	func (r *RecentFilterInfo) Native() uintptr {
		return uintptr(unsafe.Pointer(&r.Native))
	}

	

	


	// RecentInfo contains private data only, and should be accessed using the
// provided API.
// 
// RecentInfo constains all the meta-data associated with an entry in the
// recently used files list.
	type RecentInfo struct {
		Native C.GtkRecentInfo
	}

	
	func marshalRecentInfo(p uintptr) (interface{}, error) {
		b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
		return (*RecentInfo)(unsafe.Pointer(b))
	}
	

	

	

	// Native returns the underlying C source pointer.
	func (r *RecentInfo) Native() uintptr {
		return uintptr(unsafe.Pointer(&r.Native))
	}

	

	
	// CreateAppInfo creates a Info for the specified RecentInfo
	func (i *RecentInfo) CreateAppInfo(appName string) (gio.AppInfo, error) {
var _arg0 *C.GtkRecentInfo // out
var _arg1 *C.gchar // out
var _cret *C.GAppInfo // in
var _cerr *C.GError // in

_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))
_arg1 = (*C.gchar)(C.CString(appName))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_recent_info_create_app_info(_arg0, _arg1, &_cerr)


var _appInfo gio.AppInfo // out
var _goerr error // out

_appInfo = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gio.AppInfo)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _appInfo, _goerr
}
	
	// Exists checks whether the resource pointed by @info still exists. At the
// moment this check is done only on resources pointing to local files.
	func (i *RecentInfo) Exists() bool {
var _arg0 *C.GtkRecentInfo // out
var _cret C.gboolean // in

_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))

_cret = C.gtk_recent_info_exists(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Added gets the timestamp (seconds from system’s Epoch) when the resource was
// added to the recently used resources list.
	func (i *RecentInfo) Added() int32 {
var _arg0 *C.GtkRecentInfo // out
var _cret C.time_t // in

_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))

_cret = C.gtk_recent_info_get_added(_arg0)


var _glong int32 // out

_glong = (int32)(_cret)

return _glong
}
	
	// Age gets the number of days elapsed since the last update of the resource
// pointed by @info.
	func (i *RecentInfo) Age() int {
var _arg0 *C.GtkRecentInfo // out
var _cret C.gint // in

_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))

_cret = C.gtk_recent_info_get_age(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// ApplicationInfo gets the data regarding the application that has registered
// the resource pointed by @info.
// 
// If the command line contains any escape characters defined inside the storage
// specification, they will be expanded.
	func (i *RecentInfo) ApplicationInfo(appName string) (string, uint, int32, bool) {
var _arg0 *C.GtkRecentInfo // out
var _arg1 *C.gchar // out
var _arg2 *C.gchar // in
var _arg3 C.guint // in
var _arg4 C.time_t // in
var _cret C.gboolean // in

_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))
_arg1 = (*C.gchar)(C.CString(appName))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_recent_info_get_application_info(_arg0, _arg1, &_arg2, &_arg3, &_arg4)


var _appExec string // out
var _count uint // out
var _time_ int32 // out
var _ok bool // out

_appExec = C.GoString(_arg2)
_count = (uint)(_arg3)
_time_ = (int32)(_arg4)
if _cret != 0 { _ok = true }

return _appExec, _count, _time_, _ok
}
	
	// Description gets the (short) description of the resource.
	func (i *RecentInfo) Description() string {
var _arg0 *C.GtkRecentInfo // out
var _cret *C.gchar // in

_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))

_cret = C.gtk_recent_info_get_description(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// DisplayName gets the name of the resource. If none has been defined, the
// basename of the resource is obtained.
	func (i *RecentInfo) DisplayName() string {
var _arg0 *C.GtkRecentInfo // out
var _cret *C.gchar // in

_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))

_cret = C.gtk_recent_info_get_display_name(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// GIcon retrieves the icon associated to the resource MIME type.
	func (i *RecentInfo) GIcon() gio.Icon {
var _arg0 *C.GtkRecentInfo // out
var _cret *C.GIcon // in

_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))

_cret = C.gtk_recent_info_get_gicon(_arg0)


var _icon gio.Icon // out

_icon = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gio.Icon)

return _icon
}
	
	// Icon retrieves the icon of size @size associated to the resource MIME type.
	func (i *RecentInfo) Icon(size int) gdkpixbuf.Pixbuf {
var _arg0 *C.GtkRecentInfo // out
var _arg1 C.gint // out
var _cret *C.GdkPixbuf // in

_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))
_arg1 = (C.gint)(size)

_cret = C.gtk_recent_info_get_icon(_arg0, _arg1)


var _pixbuf gdkpixbuf.Pixbuf // out

_pixbuf = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gdkpixbuf.Pixbuf)

return _pixbuf
}
	
	// MIMEType gets the MIME type of the resource.
	func (i *RecentInfo) MIMEType() string {
var _arg0 *C.GtkRecentInfo // out
var _cret *C.gchar // in

_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))

_cret = C.gtk_recent_info_get_mime_type(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Modified gets the timestamp (seconds from system’s Epoch) when the meta-data
// for the resource was last modified.
	func (i *RecentInfo) Modified() int32 {
var _arg0 *C.GtkRecentInfo // out
var _cret C.time_t // in

_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))

_cret = C.gtk_recent_info_get_modified(_arg0)


var _glong int32 // out

_glong = (int32)(_cret)

return _glong
}
	
	// PrivateHint gets the value of the “private” flag. Resources in the recently
// used list that have this flag set to true should only be displayed by the
// applications that have registered them.
	func (i *RecentInfo) PrivateHint() bool {
var _arg0 *C.GtkRecentInfo // out
var _cret C.gboolean // in

_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))

_cret = C.gtk_recent_info_get_private_hint(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ShortName computes a valid UTF-8 string that can be used as the name of the
// item in a menu or list. For example, calling this function on an item that
// refers to “file:///foo/bar.txt” will yield “bar.txt”.
	func (i *RecentInfo) ShortName() string {
var _arg0 *C.GtkRecentInfo // out
var _cret *C.gchar // in

_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))

_cret = C.gtk_recent_info_get_short_name(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// URI gets the URI of the resource.
	func (i *RecentInfo) URI() string {
var _arg0 *C.GtkRecentInfo // out
var _cret *C.gchar // in

_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))

_cret = C.gtk_recent_info_get_uri(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// URIDisplay gets a displayable version of the resource’s URI. If the resource
// is local, it returns a local path; if the resource is not local, it returns
// the UTF-8 encoded content of gtk_recent_info_get_uri().
	func (i *RecentInfo) URIDisplay() string {
var _arg0 *C.GtkRecentInfo // out
var _cret *C.gchar // in

_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))

_cret = C.gtk_recent_info_get_uri_display(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// Visited gets the timestamp (seconds from system’s Epoch) when the meta-data
// for the resource was last visited.
	func (i *RecentInfo) Visited() int32 {
var _arg0 *C.GtkRecentInfo // out
var _cret C.time_t // in

_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))

_cret = C.gtk_recent_info_get_visited(_arg0)


var _glong int32 // out

_glong = (int32)(_cret)

return _glong
}
	
	// HasApplication checks whether an application registered this resource using
// @app_name.
	func (i *RecentInfo) HasApplication(appName string) bool {
var _arg0 *C.GtkRecentInfo // out
var _arg1 *C.gchar // out
var _cret C.gboolean // in

_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))
_arg1 = (*C.gchar)(C.CString(appName))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_recent_info_has_application(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// HasGroup checks whether @group_name appears inside the groups registered for
// the recently used item @info.
	func (i *RecentInfo) HasGroup(groupName string) bool {
var _arg0 *C.GtkRecentInfo // out
var _arg1 *C.gchar // out
var _cret C.gboolean // in

_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))
_arg1 = (*C.gchar)(C.CString(groupName))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_recent_info_has_group(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsLocal checks whether the resource is local or not by looking at the scheme
// of its URI.
	func (i *RecentInfo) IsLocal() bool {
var _arg0 *C.GtkRecentInfo // out
var _cret C.gboolean // in

_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))

_cret = C.gtk_recent_info_is_local(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// LastApplication gets the name of the last application that have registered
// the recently used resource represented by @info.
	func (i *RecentInfo) LastApplication() string {
var _arg0 *C.GtkRecentInfo // out
var _cret *C.gchar // in

_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))

_cret = C.gtk_recent_info_last_application(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// Match checks whether two RecentInfo-struct point to the same resource.
	func (i *RecentInfo) Match(infoB *RecentInfo) bool {
var _arg0 *C.GtkRecentInfo // out
var _arg1 *C.GtkRecentInfo // out
var _cret C.gboolean // in

_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GtkRecentInfo)(unsafe.Pointer(infoB.Native()))

_cret = C.gtk_recent_info_match(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Ref increases the reference count of @recent_info by one.
	func (i *RecentInfo) Ref() *RecentInfo {
var _arg0 *C.GtkRecentInfo // out
var _cret *C.GtkRecentInfo // in

_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))

_cret = C.gtk_recent_info_ref(_arg0)


var _recentInfo *RecentInfo // out

_recentInfo = *(**RecentInfo)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_recentInfo, func(v *RecentInfo) {
  C.free(unsafe.Pointer(v.Native()))
})

return _recentInfo
}
	
	// Unref decreases the reference count of @info by one. If the reference count
// reaches zero, @info is deallocated, and the memory freed.
	func (i *RecentInfo) Unref()  {
var _arg0 *C.GtkRecentInfo // out

_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))

C.gtk_recent_info_unref(_arg0)
}
	


	// RequestedSize represents a request of a screen object in a given orientation.
// These are primarily used in container implementations when allocating a
// natural size for children calling. See gtk_distribute_natural_allocation().
	type RequestedSize struct {
		Native C.GtkRequestedSize
	}

	

	

	

	// Native returns the underlying C source pointer.
	func (r *RequestedSize) Native() uintptr {
		return uintptr(unsafe.Pointer(&r.Native))
	}

	

	


	// Requisition: a Requisition-struct represents the desired size of a widget.
// See [GtkWidget’s geometry management section][geometry-management] for more
// information.
	type Requisition struct {
		Native C.GtkRequisition
	}

	
	func marshalRequisition(p uintptr) (interface{}, error) {
		b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
		return (*Requisition)(unsafe.Pointer(b))
	}
	

	
	
	// NewRequisition constructs a struct Requisition.
	func NewRequisition() *Requisition {
var _cret *C.GtkRequisition // in

_cret = C.gtk_requisition_new()


var _requisition *Requisition // out

_requisition = *(**Requisition)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_requisition, func(v *Requisition) {
  C.free(unsafe.Pointer(v.Native()))
})

return _requisition
}
	
	

	

	// Native returns the underlying C source pointer.
	func (r *Requisition) Native() uintptr {
		return uintptr(unsafe.Pointer(&r.Native))
	}

	

	
	// Copy copies a Requisition.
	func (r *Requisition) Copy() *Requisition {
var _arg0 *C.GtkRequisition // out
var _cret *C.GtkRequisition // in

_arg0 = (*C.GtkRequisition)(unsafe.Pointer(r.Native()))

_cret = C.gtk_requisition_copy(_arg0)


var _ret *Requisition // out

_ret = *(**Requisition)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_ret, func(v *Requisition) {
  C.free(unsafe.Pointer(v.Native()))
})

return _ret
}
	
	// Free frees a Requisition.
	func (r *Requisition) Free()  {
var _arg0 *C.GtkRequisition // out

_arg0 = (*C.GtkRequisition)(unsafe.Pointer(r.Native()))

C.gtk_requisition_free(_arg0)
}
	


	
	type SelectionData struct {
		Native C.GtkSelectionData
	}

	
	func marshalSelectionData(p uintptr) (interface{}, error) {
		b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
		return (*SelectionData)(unsafe.Pointer(b))
	}
	

	

	

	// Native returns the underlying C source pointer.
	func (s *SelectionData) Native() uintptr {
		return uintptr(unsafe.Pointer(&s.Native))
	}

	

	
	// Copy makes a copy of a SelectionData-struct and its data.
	func (d *SelectionData) Copy() *SelectionData {
var _arg0 *C.GtkSelectionData // out
var _cret *C.GtkSelectionData // in

_arg0 = (*C.GtkSelectionData)(unsafe.Pointer(d.Native()))

_cret = C.gtk_selection_data_copy(_arg0)


var _selectionData *SelectionData // out

_selectionData = *(**SelectionData)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_selectionData, func(v *SelectionData) {
  C.free(unsafe.Pointer(v.Native()))
})

return _selectionData
}
	
	// Free frees a SelectionData-struct returned from gtk_selection_data_copy().
	func (d *SelectionData) Free()  {
var _arg0 *C.GtkSelectionData // out

_arg0 = (*C.GtkSelectionData)(unsafe.Pointer(d.Native()))

C.gtk_selection_data_free(_arg0)
}
	
	// DataType retrieves the data type of the selection.
	func (s *SelectionData) DataType() *gdk.Atom {
var _arg0 *C.GtkSelectionData // out
var _cret C.GdkAtom // in

_arg0 = (*C.GtkSelectionData)(unsafe.Pointer(s.Native()))

_cret = C.gtk_selection_data_get_data_type(_arg0)


var _atom *gdk.Atom // out

_atom = *(**gdk.Atom)(unsafe.Pointer(&_cret))

return _atom
}
	
	// Display retrieves the display of the selection.
	func (s *SelectionData) Display() gdk.Display {
var _arg0 *C.GtkSelectionData // out
var _cret *C.GdkDisplay // in

_arg0 = (*C.GtkSelectionData)(unsafe.Pointer(s.Native()))

_cret = C.gtk_selection_data_get_display(_arg0)


var _display gdk.Display // out

_display = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Display)

return _display
}
	
	// Format retrieves the format of the selection.
	func (s *SelectionData) Format() int {
var _arg0 *C.GtkSelectionData // out
var _cret C.gint // in

_arg0 = (*C.GtkSelectionData)(unsafe.Pointer(s.Native()))

_cret = C.gtk_selection_data_get_format(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Length retrieves the length of the raw data of the selection.
	func (s *SelectionData) Length() int {
var _arg0 *C.GtkSelectionData // out
var _cret C.gint // in

_arg0 = (*C.GtkSelectionData)(unsafe.Pointer(s.Native()))

_cret = C.gtk_selection_data_get_length(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Pixbuf gets the contents of the selection data as a Pixbuf.
	func (s *SelectionData) Pixbuf() gdkpixbuf.Pixbuf {
var _arg0 *C.GtkSelectionData // out
var _cret *C.GdkPixbuf // in

_arg0 = (*C.GtkSelectionData)(unsafe.Pointer(s.Native()))

_cret = C.gtk_selection_data_get_pixbuf(_arg0)


var _pixbuf gdkpixbuf.Pixbuf // out

_pixbuf = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gdkpixbuf.Pixbuf)

return _pixbuf
}
	
	// Selection retrieves the selection Atom of the selection data.
	func (s *SelectionData) Selection() *gdk.Atom {
var _arg0 *C.GtkSelectionData // out
var _cret C.GdkAtom // in

_arg0 = (*C.GtkSelectionData)(unsafe.Pointer(s.Native()))

_cret = C.gtk_selection_data_get_selection(_arg0)


var _atom *gdk.Atom // out

_atom = *(**gdk.Atom)(unsafe.Pointer(&_cret))

return _atom
}
	
	// Target retrieves the target of the selection.
	func (s *SelectionData) Target() *gdk.Atom {
var _arg0 *C.GtkSelectionData // out
var _cret C.GdkAtom // in

_arg0 = (*C.GtkSelectionData)(unsafe.Pointer(s.Native()))

_cret = C.gtk_selection_data_get_target(_arg0)


var _atom *gdk.Atom // out

_atom = *(**gdk.Atom)(unsafe.Pointer(&_cret))

return _atom
}
	
	// Targets gets the contents of @selection_data as an array of targets. This can
// be used to interpret the results of getting the standard TARGETS target that
// is always supplied for any selection.
	func (s *SelectionData) Targets() ([]gdk.Atom, bool) {
var _arg0 *C.GtkSelectionData // out
var _arg1 *C.GdkAtom
var _arg2 C.gint // in
var _cret C.gboolean // in

_arg0 = (*C.GtkSelectionData)(unsafe.Pointer(s.Native()))

_cret = C.gtk_selection_data_get_targets(_arg0, &_arg1, &_arg2)


var _targets []gdk.Atom
var _ok bool // out

_targets = unsafe.Slice((*gdk.Atom)(unsafe.Pointer(_arg1)), _arg2)
runtime.SetFinalizer(&_targets, func(v *[]gdk.Atom) {
  C.free(unsafe.Pointer(&(*v)[0]))
})
if _cret != 0 { _ok = true }

return _targets, _ok
}
	
	// Text gets the contents of the selection data as a UTF-8 string.
	func (s *SelectionData) Text() string {
var _arg0 *C.GtkSelectionData // out
var _cret *C.guchar // in

_arg0 = (*C.GtkSelectionData)(unsafe.Pointer(s.Native()))

_cret = C.gtk_selection_data_get_text(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// Uris gets the contents of the selection data as array of URIs.
	func (s *SelectionData) Uris() []string {
var _arg0 *C.GtkSelectionData // out
var _cret **C.gchar

_arg0 = (*C.GtkSelectionData)(unsafe.Pointer(s.Native()))

_cret = C.gtk_selection_data_get_uris(_arg0)


var _utf8s []string

{
var i int
var z *C.gchar
for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
  i++
}

src := unsafe.Slice(_cret, i)
_utf8s = make([]string, i)
for i := range src {
_utf8s[i] = C.GoString(src[i])
defer C.free(unsafe.Pointer(src[i]))
}
}

return _utf8s
}
	
	// Set stores new data into a SelectionData object. Should only be called from a
// selection handler callback. Zero-terminates the stored data.
	func (s *SelectionData) Set(typ *gdk.Atom, format int, data []byte)  {
var _arg0 *C.GtkSelectionData // out
var _arg1 C.GdkAtom // out
var _arg2 C.gint // out
var _arg3 *C.guchar
var _arg4 C.gint

_arg0 = (*C.GtkSelectionData)(unsafe.Pointer(s.Native()))
_arg1 = (C.GdkAtom)(unsafe.Pointer(typ.Native()))
_arg2 = (C.gint)(format)
_arg4 = C.gint(len(data))
_arg3 = (*C.guchar)(unsafe.Pointer(&data[0]))

C.gtk_selection_data_set(_arg0, _arg1, _arg2, _arg3, _arg4)
}
	
	// SetPixbuf sets the contents of the selection from a Pixbuf The pixbuf is
// converted to the form determined by @selection_data->target.
	func (s *SelectionData) SetPixbuf(pixbuf gdkpixbuf.PixbufClass) bool {
var _arg0 *C.GtkSelectionData // out
var _arg1 *C.GdkPixbuf // out
var _cret C.gboolean // in

_arg0 = (*C.GtkSelectionData)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))

_cret = C.gtk_selection_data_set_pixbuf(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetText sets the contents of the selection from a UTF-8 encoded string. The
// string is converted to the form determined by @selection_data->target.
	func (s *SelectionData) SetText(str string, len int) bool {
var _arg0 *C.GtkSelectionData // out
var _arg1 *C.gchar // out
var _arg2 C.gint // out
var _cret C.gboolean // in

_arg0 = (*C.GtkSelectionData)(unsafe.Pointer(s.Native()))
_arg1 = (*C.gchar)(C.CString(str))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.gint)(len)

_cret = C.gtk_selection_data_set_text(_arg0, _arg1, _arg2)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetUris sets the contents of the selection from a list of URIs. The string is
// converted to the form determined by @selection_data->target.
	func (s *SelectionData) SetUris(uris []string) bool {
var _arg0 *C.GtkSelectionData // out
var _arg1 **C.gchar
var _cret C.gboolean // in

_arg0 = (*C.GtkSelectionData)(unsafe.Pointer(s.Native()))
_arg1 = (**C.gchar)(C.malloc(C.ulong(len(uris)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
defer C.free(unsafe.Pointer(_arg1))
{
out := unsafe.Slice(_arg1, len(uris))
for i := range uris {
out[i] = (*C.gchar)(C.CString(uris[i]))
defer C.free(unsafe.Pointer(out[i]))
}
}

_cret = C.gtk_selection_data_set_uris(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// TargetsIncludeImage: given a SelectionData object holding a list of targets,
// determines if any of the targets in @targets can be used to provide a Pixbuf.
	func (s *SelectionData) TargetsIncludeImage(writable bool) bool {
var _arg0 *C.GtkSelectionData // out
var _arg1 C.gboolean // out
var _cret C.gboolean // in

_arg0 = (*C.GtkSelectionData)(unsafe.Pointer(s.Native()))
if writable { _arg1 = C.TRUE }

_cret = C.gtk_selection_data_targets_include_image(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// TargetsIncludeRichText: given a SelectionData object holding a list of
// targets, determines if any of the targets in @targets can be used to provide
// rich text.
	func (s *SelectionData) TargetsIncludeRichText(buffer TextBufferClass) bool {
var _arg0 *C.GtkSelectionData // out
var _arg1 *C.GtkTextBuffer // out
var _cret C.gboolean // in

_arg0 = (*C.GtkSelectionData)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))

_cret = C.gtk_selection_data_targets_include_rich_text(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// TargetsIncludeText: given a SelectionData object holding a list of targets,
// determines if any of the targets in @targets can be used to provide text.
	func (s *SelectionData) TargetsIncludeText() bool {
var _arg0 *C.GtkSelectionData // out
var _cret C.gboolean // in

_arg0 = (*C.GtkSelectionData)(unsafe.Pointer(s.Native()))

_cret = C.gtk_selection_data_targets_include_text(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// TargetsIncludeURI: given a SelectionData object holding a list of targets,
// determines if any of the targets in @targets can be used to provide a list or
// URIs.
	func (s *SelectionData) TargetsIncludeURI() bool {
var _arg0 *C.GtkSelectionData // out
var _cret C.gboolean // in

_arg0 = (*C.GtkSelectionData)(unsafe.Pointer(s.Native()))

_cret = C.gtk_selection_data_targets_include_uri(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	


	
	type StockItem struct {
		Native C.GtkStockItem
	}

	

	

	

	// Native returns the underlying C source pointer.
	func (s *StockItem) Native() uintptr {
		return uintptr(unsafe.Pointer(&s.Native))
	}

	

	
	// Free frees a stock item allocated on the heap, such as one returned by
// gtk_stock_item_copy(). Also frees the fields inside the stock item, if they
// are not nil.
	func (i *StockItem) Free()  {
var _arg0 *C.GtkStockItem // out

_arg0 = (*C.GtkStockItem)(unsafe.Pointer(i.Native()))

C.gtk_stock_item_free(_arg0)
}
	


	// SymbolicColor: gtkSymbolicColor is a boxed type that represents a symbolic
// color. It is the result of parsing a [color
// expression][gtkcssprovider-symbolic-colors]. To obtain the color represented
// by a GtkSymbolicColor, it has to be resolved with
// gtk_symbolic_color_resolve(), which replaces all symbolic color references by
// the colors they refer to (in a given context) and evaluates mix, shade and
// other expressions, resulting in a RGBA value.
// 
// It is not normally necessary to deal directly with SymbolicColors, since they
// are mostly used behind the scenes by StyleContext and CssProvider.
// 
// SymbolicColor is deprecated. Symbolic colors are considered an implementation
// detail of GTK+.
	type SymbolicColor struct {
		Native C.GtkSymbolicColor
	}

	
	func marshalSymbolicColor(p uintptr) (interface{}, error) {
		b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
		return (*SymbolicColor)(unsafe.Pointer(b))
	}
	

	
	
	// NewSymbolicColorAlpha constructs a struct SymbolicColor.
	func NewSymbolicColorAlpha(color *SymbolicColor, factor float64) *SymbolicColor {
var _arg1 *C.GtkSymbolicColor // out
var _arg2 C.gdouble // out
var _cret *C.GtkSymbolicColor // in

_arg1 = (*C.GtkSymbolicColor)(unsafe.Pointer(color.Native()))
_arg2 = (C.gdouble)(factor)

_cret = C.gtk_symbolic_color_new_alpha(_arg1, _arg2)


var _symbolicColor *SymbolicColor // out

_symbolicColor = *(**SymbolicColor)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_symbolicColor, func(v *SymbolicColor) {
  C.free(unsafe.Pointer(v.Native()))
})

return _symbolicColor
}
	
	
	
	// NewSymbolicColorLiteral constructs a struct SymbolicColor.
	func NewSymbolicColorLiteral(color *gdk.RGBA) *SymbolicColor {
var _arg1 *C.GdkRGBA // out
var _cret *C.GtkSymbolicColor // in

_arg1 = (*C.GdkRGBA)(unsafe.Pointer(color.Native()))

_cret = C.gtk_symbolic_color_new_literal(_arg1)


var _symbolicColor *SymbolicColor // out

_symbolicColor = *(**SymbolicColor)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_symbolicColor, func(v *SymbolicColor) {
  C.free(unsafe.Pointer(v.Native()))
})

return _symbolicColor
}
	
	
	
	// NewSymbolicColorMix constructs a struct SymbolicColor.
	func NewSymbolicColorMix(color1 *SymbolicColor, color2 *SymbolicColor, factor float64) *SymbolicColor {
var _arg1 *C.GtkSymbolicColor // out
var _arg2 *C.GtkSymbolicColor // out
var _arg3 C.gdouble // out
var _cret *C.GtkSymbolicColor // in

_arg1 = (*C.GtkSymbolicColor)(unsafe.Pointer(color1.Native()))
_arg2 = (*C.GtkSymbolicColor)(unsafe.Pointer(color2.Native()))
_arg3 = (C.gdouble)(factor)

_cret = C.gtk_symbolic_color_new_mix(_arg1, _arg2, _arg3)


var _symbolicColor *SymbolicColor // out

_symbolicColor = *(**SymbolicColor)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_symbolicColor, func(v *SymbolicColor) {
  C.free(unsafe.Pointer(v.Native()))
})

return _symbolicColor
}
	
	
	
	// NewSymbolicColorName constructs a struct SymbolicColor.
	func NewSymbolicColorName(name string) *SymbolicColor {
var _arg1 *C.gchar // out
var _cret *C.GtkSymbolicColor // in

_arg1 = (*C.gchar)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_symbolic_color_new_name(_arg1)


var _symbolicColor *SymbolicColor // out

_symbolicColor = *(**SymbolicColor)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_symbolicColor, func(v *SymbolicColor) {
  C.free(unsafe.Pointer(v.Native()))
})

return _symbolicColor
}
	
	
	
	// NewSymbolicColorShade constructs a struct SymbolicColor.
	func NewSymbolicColorShade(color *SymbolicColor, factor float64) *SymbolicColor {
var _arg1 *C.GtkSymbolicColor // out
var _arg2 C.gdouble // out
var _cret *C.GtkSymbolicColor // in

_arg1 = (*C.GtkSymbolicColor)(unsafe.Pointer(color.Native()))
_arg2 = (C.gdouble)(factor)

_cret = C.gtk_symbolic_color_new_shade(_arg1, _arg2)


var _symbolicColor *SymbolicColor // out

_symbolicColor = *(**SymbolicColor)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_symbolicColor, func(v *SymbolicColor) {
  C.free(unsafe.Pointer(v.Native()))
})

return _symbolicColor
}
	
	
	
	// NewSymbolicColorWin32 constructs a struct SymbolicColor.
	func NewSymbolicColorWin32(themeClass string, id int) *SymbolicColor {
var _arg1 *C.gchar // out
var _arg2 C.gint // out
var _cret *C.GtkSymbolicColor // in

_arg1 = (*C.gchar)(C.CString(themeClass))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.gint)(id)

_cret = C.gtk_symbolic_color_new_win32(_arg1, _arg2)


var _symbolicColor *SymbolicColor // out

_symbolicColor = *(**SymbolicColor)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_symbolicColor, func(v *SymbolicColor) {
  C.free(unsafe.Pointer(v.Native()))
})

return _symbolicColor
}
	
	

	

	// Native returns the underlying C source pointer.
	func (s *SymbolicColor) Native() uintptr {
		return uintptr(unsafe.Pointer(&s.Native))
	}

	

	
	// Ref increases the reference count of @color
	func (c *SymbolicColor) Ref() *SymbolicColor {
var _arg0 *C.GtkSymbolicColor // out
var _cret *C.GtkSymbolicColor // in

_arg0 = (*C.GtkSymbolicColor)(unsafe.Pointer(c.Native()))

_cret = C.gtk_symbolic_color_ref(_arg0)


var _symbolicColor *SymbolicColor // out

_symbolicColor = *(**SymbolicColor)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_symbolicColor, func(v *SymbolicColor) {
  C.free(unsafe.Pointer(v.Native()))
})

return _symbolicColor
}
	
	// Resolve: if @color is resolvable, @resolved_color will be filled in with the
// resolved color, and true will be returned. Generally, if @color can’t be
// resolved, it is due to it being defined on top of a named color that doesn’t
// exist in @props.
// 
// When @props is nil, resolving of named colors will fail, so if your @color is
// or references such a color, this function will return false.
	func (c *SymbolicColor) Resolve(props StylePropertiesClass) (gdk.RGBA, bool) {
var _arg0 *C.GtkSymbolicColor // out
var _arg1 *C.GtkStyleProperties // out
var _resolvedColor gdk.RGBA
var _cret C.gboolean // in

_arg0 = (*C.GtkSymbolicColor)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GtkStyleProperties)(unsafe.Pointer(props.Native()))

_cret = C.gtk_symbolic_color_resolve(_arg0, _arg1, (*C.GdkRGBA)(unsafe.Pointer(&_resolvedColor)))



var _ok bool // out


if _cret != 0 { _ok = true }

return _resolvedColor, _ok
}
	
	// String converts the given @color to a string representation. This is useful
// both for debugging and for serialization of strings. The format of the string
// may change between different versions of GTK, but it is guaranteed that the
// GTK css parser is able to read the string and create the same symbolic color
// from it.
	func (c *SymbolicColor) String() string {
var _arg0 *C.GtkSymbolicColor // out
var _cret *C.char // in

_arg0 = (*C.GtkSymbolicColor)(unsafe.Pointer(c.Native()))

_cret = C.gtk_symbolic_color_to_string(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// Unref decreases the reference count of @color, freeing its memory if the
// reference count reaches 0.
	func (c *SymbolicColor) Unref()  {
var _arg0 *C.GtkSymbolicColor // out

_arg0 = (*C.GtkSymbolicColor)(unsafe.Pointer(c.Native()))

C.gtk_symbolic_color_unref(_arg0)
}
	


	
	type TableChild struct {
		Native C.GtkTableChild
	}

	

	

	

	// Native returns the underlying C source pointer.
	func (t *TableChild) Native() uintptr {
		return uintptr(unsafe.Pointer(&t.Native))
	}

	

	


	
	type TableRowCol struct {
		Native C.GtkTableRowCol
	}

	

	

	

	// Native returns the underlying C source pointer.
	func (t *TableRowCol) Native() uintptr {
		return uintptr(unsafe.Pointer(&t.Native))
	}

	

	


	// TargetEntry: a TargetEntry represents a single type of data than can be
// supplied for by a widget for a selection or for supplied or received during
// drag-and-drop.
	type TargetEntry struct {
		Native C.GtkTargetEntry
	}

	
	func marshalTargetEntry(p uintptr) (interface{}, error) {
		b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
		return (*TargetEntry)(unsafe.Pointer(b))
	}
	

	
	
	// NewTargetEntry constructs a struct TargetEntry.
	func NewTargetEntry(target string, flags uint, info uint) *TargetEntry {
var _arg1 *C.gchar // out
var _arg2 C.guint // out
var _arg3 C.guint // out
var _cret *C.GtkTargetEntry // in

_arg1 = (*C.gchar)(C.CString(target))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.guint)(flags)
_arg3 = (C.guint)(info)

_cret = C.gtk_target_entry_new(_arg1, _arg2, _arg3)


var _targetEntry *TargetEntry // out

_targetEntry = *(**TargetEntry)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_targetEntry, func(v *TargetEntry) {
  C.free(unsafe.Pointer(v.Native()))
})

return _targetEntry
}
	
	

	

	// Native returns the underlying C source pointer.
	func (t *TargetEntry) Native() uintptr {
		return uintptr(unsafe.Pointer(&t.Native))
	}

	

	
	// Copy makes a copy of a TargetEntry and its data.
	func (d *TargetEntry) Copy() *TargetEntry {
var _arg0 *C.GtkTargetEntry // out
var _cret *C.GtkTargetEntry // in

_arg0 = (*C.GtkTargetEntry)(unsafe.Pointer(d.Native()))

_cret = C.gtk_target_entry_copy(_arg0)


var _targetEntry *TargetEntry // out

_targetEntry = *(**TargetEntry)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_targetEntry, func(v *TargetEntry) {
  C.free(unsafe.Pointer(v.Native()))
})

return _targetEntry
}
	
	// Free frees a TargetEntry returned from gtk_target_entry_new() or
// gtk_target_entry_copy().
	func (d *TargetEntry) Free()  {
var _arg0 *C.GtkTargetEntry // out

_arg0 = (*C.GtkTargetEntry)(unsafe.Pointer(d.Native()))

C.gtk_target_entry_free(_arg0)
}
	


	// TargetList: a TargetList-struct is a reference counted list of TargetPair and
// should be treated as opaque.
	type TargetList struct {
		Native C.GtkTargetList
	}

	
	func marshalTargetList(p uintptr) (interface{}, error) {
		b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
		return (*TargetList)(unsafe.Pointer(b))
	}
	

	
	
	// NewTargetList constructs a struct TargetList.
	func NewTargetList(targets []TargetEntry) *TargetList {
var _arg1 *C.GtkTargetEntry
var _arg2 C.guint
var _cret *C.GtkTargetList // in

_arg2 = C.guint(len(targets))
_arg1 = (*C.GtkTargetEntry)(unsafe.Pointer(&targets[0]))

_cret = C.gtk_target_list_new(_arg1, _arg2)


var _targetList *TargetList // out

_targetList = *(**TargetList)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_targetList, func(v *TargetList) {
  C.free(unsafe.Pointer(v.Native()))
})

return _targetList
}
	
	

	

	// Native returns the underlying C source pointer.
	func (t *TargetList) Native() uintptr {
		return uintptr(unsafe.Pointer(&t.Native))
	}

	

	
	// Add appends another target to a TargetList.
	func (l *TargetList) Add(target *gdk.Atom, flags uint, info uint)  {
var _arg0 *C.GtkTargetList // out
var _arg1 C.GdkAtom // out
var _arg2 C.guint // out
var _arg3 C.guint // out

_arg0 = (*C.GtkTargetList)(unsafe.Pointer(l.Native()))
_arg1 = (C.GdkAtom)(unsafe.Pointer(target.Native()))
_arg2 = (C.guint)(flags)
_arg3 = (C.guint)(info)

C.gtk_target_list_add(_arg0, _arg1, _arg2, _arg3)
}
	
	// AddImageTargets appends the image targets supported by SelectionData to the
// target list. All targets are added with the same @info.
	func (l *TargetList) AddImageTargets(info uint, writable bool)  {
var _arg0 *C.GtkTargetList // out
var _arg1 C.guint // out
var _arg2 C.gboolean // out

_arg0 = (*C.GtkTargetList)(unsafe.Pointer(l.Native()))
_arg1 = (C.guint)(info)
if writable { _arg2 = C.TRUE }

C.gtk_target_list_add_image_targets(_arg0, _arg1, _arg2)
}
	
	// AddRichTextTargets appends the rich text targets registered with
// gtk_text_buffer_register_serialize_format() or
// gtk_text_buffer_register_deserialize_format() to the target list. All targets
// are added with the same @info.
	func (l *TargetList) AddRichTextTargets(info uint, deserializable bool, buffer TextBufferClass)  {
var _arg0 *C.GtkTargetList // out
var _arg1 C.guint // out
var _arg2 C.gboolean // out
var _arg3 *C.GtkTextBuffer // out

_arg0 = (*C.GtkTargetList)(unsafe.Pointer(l.Native()))
_arg1 = (C.guint)(info)
if deserializable { _arg2 = C.TRUE }
_arg3 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))

C.gtk_target_list_add_rich_text_targets(_arg0, _arg1, _arg2, _arg3)
}
	
	// AddTable prepends a table of TargetEntry to a target list.
	func (l *TargetList) AddTable(targets []TargetEntry)  {
var _arg0 *C.GtkTargetList // out
var _arg1 *C.GtkTargetEntry
var _arg2 C.guint

_arg0 = (*C.GtkTargetList)(unsafe.Pointer(l.Native()))
_arg2 = C.guint(len(targets))
_arg1 = (*C.GtkTargetEntry)(unsafe.Pointer(&targets[0]))

C.gtk_target_list_add_table(_arg0, _arg1, _arg2)
}
	
	// AddTextTargets appends the text targets supported by SelectionData to the
// target list. All targets are added with the same @info.
	func (l *TargetList) AddTextTargets(info uint)  {
var _arg0 *C.GtkTargetList // out
var _arg1 C.guint // out

_arg0 = (*C.GtkTargetList)(unsafe.Pointer(l.Native()))
_arg1 = (C.guint)(info)

C.gtk_target_list_add_text_targets(_arg0, _arg1)
}
	
	// AddURITargets appends the URI targets supported by SelectionData to the
// target list. All targets are added with the same @info.
	func (l *TargetList) AddURITargets(info uint)  {
var _arg0 *C.GtkTargetList // out
var _arg1 C.guint // out

_arg0 = (*C.GtkTargetList)(unsafe.Pointer(l.Native()))
_arg1 = (C.guint)(info)

C.gtk_target_list_add_uri_targets(_arg0, _arg1)
}
	
	// Find looks up a given target in a TargetList.
	func (l *TargetList) Find(target *gdk.Atom) (uint, bool) {
var _arg0 *C.GtkTargetList // out
var _arg1 C.GdkAtom // out
var _arg2 C.guint // in
var _cret C.gboolean // in

_arg0 = (*C.GtkTargetList)(unsafe.Pointer(l.Native()))
_arg1 = (C.GdkAtom)(unsafe.Pointer(target.Native()))

_cret = C.gtk_target_list_find(_arg0, _arg1, &_arg2)


var _info uint // out
var _ok bool // out

_info = (uint)(_arg2)
if _cret != 0 { _ok = true }

return _info, _ok
}
	
	// Ref increases the reference count of a TargetList by one.
	func (l *TargetList) Ref() *TargetList {
var _arg0 *C.GtkTargetList // out
var _cret *C.GtkTargetList // in

_arg0 = (*C.GtkTargetList)(unsafe.Pointer(l.Native()))

_cret = C.gtk_target_list_ref(_arg0)


var _targetList *TargetList // out

_targetList = *(**TargetList)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_targetList, func(v *TargetList) {
  C.free(unsafe.Pointer(v.Native()))
})

return _targetList
}
	
	// Remove removes a target from a target list.
	func (l *TargetList) Remove(target *gdk.Atom)  {
var _arg0 *C.GtkTargetList // out
var _arg1 C.GdkAtom // out

_arg0 = (*C.GtkTargetList)(unsafe.Pointer(l.Native()))
_arg1 = (C.GdkAtom)(unsafe.Pointer(target.Native()))

C.gtk_target_list_remove(_arg0, _arg1)
}
	
	// Unref decreases the reference count of a TargetList by one. If the resulting
// reference count is zero, frees the list.
	func (l *TargetList) Unref()  {
var _arg0 *C.GtkTargetList // out

_arg0 = (*C.GtkTargetList)(unsafe.Pointer(l.Native()))

C.gtk_target_list_unref(_arg0)
}
	


	// TargetPair: a TargetPair is used to represent the same information as a table
// of TargetEntry, but in an efficient form.
	type TargetPair struct {
		Native C.GtkTargetPair
	}

	

	

	

	// Native returns the underlying C source pointer.
	func (t *TargetPair) Native() uintptr {
		return uintptr(unsafe.Pointer(&t.Native))
	}

	

	


	
	type TextAppearance struct {
		Native C.GtkTextAppearance
	}

	

	

	

	// Native returns the underlying C source pointer.
	func (t *TextAppearance) Native() uintptr {
		return uintptr(unsafe.Pointer(&t.Native))
	}

	

	


	// TextAttributes: using TextAttributes directly should rarely be necessary.
// It’s primarily useful with gtk_text_iter_get_attributes(). As with most GTK+
// structs, the fields in this struct should only be read, never modified
// directly.
	type TextAttributes struct {
		Native C.GtkTextAttributes
	}

	
	func marshalTextAttributes(p uintptr) (interface{}, error) {
		b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
		return (*TextAttributes)(unsafe.Pointer(b))
	}
	

	
	
	// NewTextAttributes constructs a struct TextAttributes.
	func NewTextAttributes() *TextAttributes {
var _cret *C.GtkTextAttributes // in

_cret = C.gtk_text_attributes_new()


var _textAttributes *TextAttributes // out

_textAttributes = *(**TextAttributes)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_textAttributes, func(v *TextAttributes) {
  C.free(unsafe.Pointer(v.Native()))
})

return _textAttributes
}
	
	

	

	// Native returns the underlying C source pointer.
	func (t *TextAttributes) Native() uintptr {
		return uintptr(unsafe.Pointer(&t.Native))
	}

	

	
	// Copy copies @src and returns a new TextAttributes.
	func (s *TextAttributes) Copy() *TextAttributes {
var _arg0 *C.GtkTextAttributes // out
var _cret *C.GtkTextAttributes // in

_arg0 = (*C.GtkTextAttributes)(unsafe.Pointer(s.Native()))

_cret = C.gtk_text_attributes_copy(_arg0)


var _textAttributes *TextAttributes // out

_textAttributes = *(**TextAttributes)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_textAttributes, func(v *TextAttributes) {
  C.free(unsafe.Pointer(v.Native()))
})

return _textAttributes
}
	
	// CopyValues copies the values from @src to @dest so that @dest has the same
// values as @src. Frees existing values in @dest.
	func (s *TextAttributes) CopyValues(dest *TextAttributes)  {
var _arg0 *C.GtkTextAttributes // out
var _arg1 *C.GtkTextAttributes // out

_arg0 = (*C.GtkTextAttributes)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkTextAttributes)(unsafe.Pointer(dest.Native()))

C.gtk_text_attributes_copy_values(_arg0, _arg1)
}
	
	// Ref increments the reference count on @values.
	func (v *TextAttributes) Ref() *TextAttributes {
var _arg0 *C.GtkTextAttributes // out
var _cret *C.GtkTextAttributes // in

_arg0 = (*C.GtkTextAttributes)(unsafe.Pointer(v.Native()))

_cret = C.gtk_text_attributes_ref(_arg0)


var _textAttributes *TextAttributes // out

_textAttributes = *(**TextAttributes)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_textAttributes, func(v *TextAttributes) {
  C.free(unsafe.Pointer(v.Native()))
})

return _textAttributes
}
	
	// Unref decrements the reference count on @values, freeing the structure if the
// reference count reaches 0.
	func (v *TextAttributes) Unref()  {
var _arg0 *C.GtkTextAttributes // out

_arg0 = (*C.GtkTextAttributes)(unsafe.Pointer(v.Native()))

C.gtk_text_attributes_unref(_arg0)
}
	


	
	type TextBTree struct {
		Native C.GtkTextBTree
	}

	

	

	

	// Native returns the underlying C source pointer.
	func (t *TextBTree) Native() uintptr {
		return uintptr(unsafe.Pointer(&t.Native))
	}

	

	


	// TextIter: you may wish to begin by reading the [text widget conceptual
// overview][TextWidget] which gives an overview of all the objects and data
// types related to the text widget and how they work together.
	type TextIter struct {
		Native C.GtkTextIter
	}

	
	func marshalTextIter(p uintptr) (interface{}, error) {
		b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
		return (*TextIter)(unsafe.Pointer(b))
	}
	

	

	

	// Native returns the underlying C source pointer.
	func (t *TextIter) Native() uintptr {
		return uintptr(unsafe.Pointer(&t.Native))
	}

	

	
	// Assign assigns the value of @other to @iter. This function is not useful in
// applications, because iterators can be assigned with `GtkTextIter i = j;`.
// The function is used by language bindings.
	func (i *TextIter) Assign(other *TextIter)  {
var _arg0 *C.GtkTextIter // out
var _arg1 *C.GtkTextIter // out

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GtkTextIter)(unsafe.Pointer(other.Native()))

C.gtk_text_iter_assign(_arg0, _arg1)
}
	
	// BackwardChar moves backward by one character offset. Returns true if movement
// was possible; if @iter was the first in the buffer (character offset 0),
// gtk_text_iter_backward_char() returns false for convenience when writing
// loops.
	func (i *TextIter) BackwardChar() bool {
var _arg0 *C.GtkTextIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_text_iter_backward_char(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// BackwardChars moves @count characters backward, if possible (if @count would
// move past the start or end of the buffer, moves to the start or end of the
// buffer). The return value indicates whether the iterator moved onto a
// dereferenceable position; if the iterator didn’t move, or moved onto the end
// iterator, then false is returned. If @count is 0, the function does nothing
// and returns false.
	func (i *TextIter) BackwardChars(count int) bool {
var _arg0 *C.GtkTextIter // out
var _arg1 C.gint // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
_arg1 = (C.gint)(count)

_cret = C.gtk_text_iter_backward_chars(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// BackwardCursorPosition: like gtk_text_iter_forward_cursor_position(), but
// moves backward.
	func (i *TextIter) BackwardCursorPosition() bool {
var _arg0 *C.GtkTextIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_text_iter_backward_cursor_position(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// BackwardCursorPositions moves up to @count cursor positions. See
// gtk_text_iter_forward_cursor_position() for details.
	func (i *TextIter) BackwardCursorPositions(count int) bool {
var _arg0 *C.GtkTextIter // out
var _arg1 C.gint // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
_arg1 = (C.gint)(count)

_cret = C.gtk_text_iter_backward_cursor_positions(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// BackwardLine moves @iter to the start of the previous line. Returns true if
// @iter could be moved; i.e. if @iter was at character offset 0, this function
// returns false. Therefore if @iter was already on line 0, but not at the start
// of the line, @iter is snapped to the start of the line and the function
// returns true. (Note that this implies that in a loop calling this function,
// the line number may not change on every iteration, if your first iteration is
// on line 0.)
	func (i *TextIter) BackwardLine() bool {
var _arg0 *C.GtkTextIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_text_iter_backward_line(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// BackwardLines moves @count lines backward, if possible (if @count would move
// past the start or end of the buffer, moves to the start or end of the
// buffer). The return value indicates whether the iterator moved onto a
// dereferenceable position; if the iterator didn’t move, or moved onto the end
// iterator, then false is returned. If @count is 0, the function does nothing
// and returns false. If @count is negative, moves forward by 0 - @count lines.
	func (i *TextIter) BackwardLines(count int) bool {
var _arg0 *C.GtkTextIter // out
var _arg1 C.gint // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
_arg1 = (C.gint)(count)

_cret = C.gtk_text_iter_backward_lines(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// BackwardSearch: same as gtk_text_iter_forward_search(), but moves backward.
// 
// @match_end will never be set to a TextIter located after @iter, even if there
// is a possible @match_start before or at @iter.
	func (i *TextIter) BackwardSearch(str string, flags TextSearchFlags, limit *TextIter) (matchStart TextIter, matchEnd TextIter, ok bool) {
var _arg0 *C.GtkTextIter // out
var _arg1 *C.gchar // out
var _arg2 C.GtkTextSearchFlags // out
var _matchStart TextIter
var _matchEnd TextIter
var _arg5 *C.GtkTextIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
_arg1 = (*C.gchar)(C.CString(str))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.GtkTextSearchFlags)(flags)
_arg5 = (*C.GtkTextIter)(unsafe.Pointer(limit.Native()))

_cret = C.gtk_text_iter_backward_search(_arg0, _arg1, _arg2, (*C.GtkTextIter)(unsafe.Pointer(&_matchStart)), (*C.GtkTextIter)(unsafe.Pointer(&_matchEnd)), _arg5)




var _ok bool // out



if _cret != 0 { _ok = true }

return _matchStart, _matchEnd, _ok
}
	
	// BackwardSentenceStart moves backward to the previous sentence start; if @iter
// is already at the start of a sentence, moves backward to the next one.
// Sentence boundaries are determined by Pango and should be correct for nearly
// any language (if not, the correct fix would be to the Pango text boundary
// algorithms).
	func (i *TextIter) BackwardSentenceStart() bool {
var _arg0 *C.GtkTextIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_text_iter_backward_sentence_start(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// BackwardSentenceStarts calls gtk_text_iter_backward_sentence_start() up to
// @count times, or until it returns false. If @count is negative, moves forward
// instead of backward.
	func (i *TextIter) BackwardSentenceStarts(count int) bool {
var _arg0 *C.GtkTextIter // out
var _arg1 C.gint // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
_arg1 = (C.gint)(count)

_cret = C.gtk_text_iter_backward_sentence_starts(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// BackwardToTagToggle moves backward to the next toggle (on or off) of the
// TextTag @tag, or to the next toggle of any tag if @tag is nil. If no matching
// tag toggles are found, returns false, otherwise true. Does not return toggles
// located at @iter, only toggles before @iter. Sets @iter to the location of
// the toggle, or the start of the buffer if no toggle is found.
	func (i *TextIter) BackwardToTagToggle(tag TextTagClass) bool {
var _arg0 *C.GtkTextIter // out
var _arg1 *C.GtkTextTag // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GtkTextTag)(unsafe.Pointer(tag.Native()))

_cret = C.gtk_text_iter_backward_to_tag_toggle(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// BackwardVisibleCursorPosition moves @iter forward to the previous visible
// cursor position. See gtk_text_iter_backward_cursor_position() for details.
	func (i *TextIter) BackwardVisibleCursorPosition() bool {
var _arg0 *C.GtkTextIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_text_iter_backward_visible_cursor_position(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// BackwardVisibleCursorPositions moves up to @count visible cursor positions.
// See gtk_text_iter_backward_cursor_position() for details.
	func (i *TextIter) BackwardVisibleCursorPositions(count int) bool {
var _arg0 *C.GtkTextIter // out
var _arg1 C.gint // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
_arg1 = (C.gint)(count)

_cret = C.gtk_text_iter_backward_visible_cursor_positions(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// BackwardVisibleLine moves @iter to the start of the previous visible line.
// Returns true if @iter could be moved; i.e. if @iter was at character offset
// 0, this function returns false. Therefore if @iter was already on line 0, but
// not at the start of the line, @iter is snapped to the start of the line and
// the function returns true. (Note that this implies that in a loop calling
// this function, the line number may not change on every iteration, if your
// first iteration is on line 0.)
	func (i *TextIter) BackwardVisibleLine() bool {
var _arg0 *C.GtkTextIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_text_iter_backward_visible_line(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// BackwardVisibleLines moves @count visible lines backward, if possible (if
// @count would move past the start or end of the buffer, moves to the start or
// end of the buffer). The return value indicates whether the iterator moved
// onto a dereferenceable position; if the iterator didn’t move, or moved onto
// the end iterator, then false is returned. If @count is 0, the function does
// nothing and returns false. If @count is negative, moves forward by 0 - @count
// lines.
	func (i *TextIter) BackwardVisibleLines(count int) bool {
var _arg0 *C.GtkTextIter // out
var _arg1 C.gint // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
_arg1 = (C.gint)(count)

_cret = C.gtk_text_iter_backward_visible_lines(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// BackwardVisibleWordStart moves backward to the previous visible word start.
// (If @iter is currently on a word start, moves backward to the next one after
// that.) Word breaks are determined by Pango and should be correct for nearly
// any language (if not, the correct fix would be to the Pango word break
// algorithms).
	func (i *TextIter) BackwardVisibleWordStart() bool {
var _arg0 *C.GtkTextIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_text_iter_backward_visible_word_start(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// BackwardVisibleWordStarts calls gtk_text_iter_backward_visible_word_start()
// up to @count times.
	func (i *TextIter) BackwardVisibleWordStarts(count int) bool {
var _arg0 *C.GtkTextIter // out
var _arg1 C.gint // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
_arg1 = (C.gint)(count)

_cret = C.gtk_text_iter_backward_visible_word_starts(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// BackwardWordStart moves backward to the previous word start. (If @iter is
// currently on a word start, moves backward to the next one after that.) Word
// breaks are determined by Pango and should be correct for nearly any language
// (if not, the correct fix would be to the Pango word break algorithms).
	func (i *TextIter) BackwardWordStart() bool {
var _arg0 *C.GtkTextIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_text_iter_backward_word_start(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// BackwardWordStarts calls gtk_text_iter_backward_word_start() up to @count
// times.
	func (i *TextIter) BackwardWordStarts(count int) bool {
var _arg0 *C.GtkTextIter // out
var _arg1 C.gint // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
_arg1 = (C.gint)(count)

_cret = C.gtk_text_iter_backward_word_starts(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// BeginsTag returns true if @tag is toggled on at exactly this point. If @tag
// is nil, returns true if any tag is toggled on at this point.
// 
// Note that if gtk_text_iter_begins_tag() returns true, it means that @iter is
// at the beginning of the tagged range, and that the character at @iter is
// inside the tagged range. In other words, unlike gtk_text_iter_ends_tag(), if
// gtk_text_iter_begins_tag() returns true, gtk_text_iter_has_tag() will also
// return true for the same parameters.
	func (i *TextIter) BeginsTag(tag TextTagClass) bool {
var _arg0 *C.GtkTextIter // out
var _arg1 *C.GtkTextTag // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GtkTextTag)(unsafe.Pointer(tag.Native()))

_cret = C.gtk_text_iter_begins_tag(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// CanInsert: considering the default editability of the buffer, and tags that
// affect editability, determines whether text inserted at @iter would be
// editable. If text inserted at @iter would be editable then the user should be
// allowed to insert text at @iter. gtk_text_buffer_insert_interactive() uses
// this function to decide whether insertions are allowed at a given position.
	func (i *TextIter) CanInsert(defaultEditability bool) bool {
var _arg0 *C.GtkTextIter // out
var _arg1 C.gboolean // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
if defaultEditability { _arg1 = C.TRUE }

_cret = C.gtk_text_iter_can_insert(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Compare: a qsort()-style function that returns negative if @lhs is less than
// @rhs, positive if @lhs is greater than @rhs, and 0 if they’re equal. Ordering
// is in character offset order, i.e. the first character in the buffer is less
// than the second character in the buffer.
	func (l *TextIter) Compare(rhs *TextIter) int {
var _arg0 *C.GtkTextIter // out
var _arg1 *C.GtkTextIter // out
var _cret C.gint // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(l.Native()))
_arg1 = (*C.GtkTextIter)(unsafe.Pointer(rhs.Native()))

_cret = C.gtk_text_iter_compare(_arg0, _arg1)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Copy creates a dynamically-allocated copy of an iterator. This function is
// not useful in applications, because iterators can be copied with a simple
// assignment (`GtkTextIter i = j;`). The function is used by language bindings.
	func (i *TextIter) Copy() *TextIter {
var _arg0 *C.GtkTextIter // out
var _cret *C.GtkTextIter // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_text_iter_copy(_arg0)


var _textIter *TextIter // out

_textIter = *(**TextIter)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_textIter, func(v *TextIter) {
  C.free(unsafe.Pointer(v.Native()))
})

return _textIter
}
	
	// Editable returns whether the character at @iter is within an editable region
// of text. Non-editable text is “locked” and can’t be changed by the user via
// TextView. This function is simply a convenience wrapper around
// gtk_text_iter_get_attributes(). If no tags applied to this text affect
// editability, @default_setting will be returned.
// 
// You don’t want to use this function to decide whether text can be inserted at
// @iter, because for insertion you don’t want to know whether the char at @iter
// is inside an editable range, you want to know whether a new character
// inserted at @iter would be inside an editable range. Use
// gtk_text_iter_can_insert() to handle this case.
	func (i *TextIter) Editable(defaultSetting bool) bool {
var _arg0 *C.GtkTextIter // out
var _arg1 C.gboolean // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
if defaultSetting { _arg1 = C.TRUE }

_cret = C.gtk_text_iter_editable(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// EndsLine returns true if @iter points to the start of the paragraph delimiter
// characters for a line (delimiters will be either a newline, a carriage
// return, a carriage return followed by a newline, or a Unicode paragraph
// separator character). Note that an iterator pointing to the \n of a \r\n pair
// will not be counted as the end of a line, the line ends before the \r. The
// end iterator is considered to be at the end of a line, even though there are
// no paragraph delimiter chars there.
	func (i *TextIter) EndsLine() bool {
var _arg0 *C.GtkTextIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_text_iter_ends_line(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// EndsSentence determines whether @iter ends a sentence. Sentence boundaries
// are determined by Pango and should be correct for nearly any language (if
// not, the correct fix would be to the Pango text boundary algorithms).
	func (i *TextIter) EndsSentence() bool {
var _arg0 *C.GtkTextIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_text_iter_ends_sentence(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// EndsTag returns true if @tag is toggled off at exactly this point. If @tag is
// nil, returns true if any tag is toggled off at this point.
// 
// Note that if gtk_text_iter_ends_tag() returns true, it means that @iter is at
// the end of the tagged range, but that the character at @iter is outside the
// tagged range. In other words, unlike gtk_text_iter_starts_tag(), if
// gtk_text_iter_ends_tag() returns true, gtk_text_iter_has_tag() will return
// false for the same parameters.
	func (i *TextIter) EndsTag(tag TextTagClass) bool {
var _arg0 *C.GtkTextIter // out
var _arg1 *C.GtkTextTag // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GtkTextTag)(unsafe.Pointer(tag.Native()))

_cret = C.gtk_text_iter_ends_tag(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// EndsWord determines whether @iter ends a natural-language word. Word breaks
// are determined by Pango and should be correct for nearly any language (if
// not, the correct fix would be to the Pango word break algorithms).
	func (i *TextIter) EndsWord() bool {
var _arg0 *C.GtkTextIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_text_iter_ends_word(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Equal tests whether two iterators are equal, using the fastest possible
// mechanism. This function is very fast; you can expect it to perform better
// than e.g. getting the character offset for each iterator and comparing the
// offsets yourself. Also, it’s a bit faster than gtk_text_iter_compare().
	func (l *TextIter) Equal(rhs *TextIter) bool {
var _arg0 *C.GtkTextIter // out
var _arg1 *C.GtkTextIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(l.Native()))
_arg1 = (*C.GtkTextIter)(unsafe.Pointer(rhs.Native()))

_cret = C.gtk_text_iter_equal(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ForwardChar moves @iter forward by one character offset. Note that images
// embedded in the buffer occupy 1 character slot, so
// gtk_text_iter_forward_char() may actually move onto an image instead of a
// character, if you have images in your buffer. If @iter is the end iterator or
// one character before it, @iter will now point at the end iterator, and
// gtk_text_iter_forward_char() returns false for convenience when writing
// loops.
	func (i *TextIter) ForwardChar() bool {
var _arg0 *C.GtkTextIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_text_iter_forward_char(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ForwardChars moves @count characters if possible (if @count would move past
// the start or end of the buffer, moves to the start or end of the buffer). The
// return value indicates whether the new position of @iter is different from
// its original position, and dereferenceable (the last iterator in the buffer
// is not dereferenceable). If @count is 0, the function does nothing and
// returns false.
	func (i *TextIter) ForwardChars(count int) bool {
var _arg0 *C.GtkTextIter // out
var _arg1 C.gint // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
_arg1 = (C.gint)(count)

_cret = C.gtk_text_iter_forward_chars(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ForwardCursorPosition moves @iter forward by a single cursor position. Cursor
// positions are (unsurprisingly) positions where the cursor can appear. Perhaps
// surprisingly, there may not be a cursor position between all characters. The
// most common example for European languages would be a carriage return/newline
// sequence. For some Unicode characters, the equivalent of say the letter “a”
// with an accent mark will be represented as two characters, first the letter
// then a "combining mark" that causes the accent to be rendered; so the cursor
// can’t go between those two characters. See also the LogAttr-struct and
// pango_break() function.
	func (i *TextIter) ForwardCursorPosition() bool {
var _arg0 *C.GtkTextIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_text_iter_forward_cursor_position(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ForwardCursorPositions moves up to @count cursor positions. See
// gtk_text_iter_forward_cursor_position() for details.
	func (i *TextIter) ForwardCursorPositions(count int) bool {
var _arg0 *C.GtkTextIter // out
var _arg1 C.gint // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
_arg1 = (C.gint)(count)

_cret = C.gtk_text_iter_forward_cursor_positions(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ForwardLine moves @iter to the start of the next line. If the iter is already
// on the last line of the buffer, moves the iter to the end of the current
// line. If after the operation, the iter is at the end of the buffer and not
// dereferencable, returns false. Otherwise, returns true.
	func (i *TextIter) ForwardLine() bool {
var _arg0 *C.GtkTextIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_text_iter_forward_line(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ForwardLines moves @count lines forward, if possible (if @count would move
// past the start or end of the buffer, moves to the start or end of the
// buffer). The return value indicates whether the iterator moved onto a
// dereferenceable position; if the iterator didn’t move, or moved onto the end
// iterator, then false is returned. If @count is 0, the function does nothing
// and returns false. If @count is negative, moves backward by 0 - @count lines.
	func (i *TextIter) ForwardLines(count int) bool {
var _arg0 *C.GtkTextIter // out
var _arg1 C.gint // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
_arg1 = (C.gint)(count)

_cret = C.gtk_text_iter_forward_lines(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ForwardSearch searches forward for @str. Any match is returned by setting
// @match_start to the first character of the match and @match_end to the first
// character after the match. The search will not continue past @limit. Note
// that a search is a linear or O(n) operation, so you may wish to use @limit to
// avoid locking up your UI on large buffers.
// 
// @match_start will never be set to a TextIter located before @iter, even if
// there is a possible @match_end after or at @iter.
	func (i *TextIter) ForwardSearch(str string, flags TextSearchFlags, limit *TextIter) (matchStart TextIter, matchEnd TextIter, ok bool) {
var _arg0 *C.GtkTextIter // out
var _arg1 *C.gchar // out
var _arg2 C.GtkTextSearchFlags // out
var _matchStart TextIter
var _matchEnd TextIter
var _arg5 *C.GtkTextIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
_arg1 = (*C.gchar)(C.CString(str))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.GtkTextSearchFlags)(flags)
_arg5 = (*C.GtkTextIter)(unsafe.Pointer(limit.Native()))

_cret = C.gtk_text_iter_forward_search(_arg0, _arg1, _arg2, (*C.GtkTextIter)(unsafe.Pointer(&_matchStart)), (*C.GtkTextIter)(unsafe.Pointer(&_matchEnd)), _arg5)




var _ok bool // out



if _cret != 0 { _ok = true }

return _matchStart, _matchEnd, _ok
}
	
	// ForwardSentenceEnd moves forward to the next sentence end. (If @iter is at
// the end of a sentence, moves to the next end of sentence.) Sentence
// boundaries are determined by Pango and should be correct for nearly any
// language (if not, the correct fix would be to the Pango text boundary
// algorithms).
	func (i *TextIter) ForwardSentenceEnd() bool {
var _arg0 *C.GtkTextIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_text_iter_forward_sentence_end(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ForwardSentenceEnds calls gtk_text_iter_forward_sentence_end() @count times
// (or until gtk_text_iter_forward_sentence_end() returns false). If @count is
// negative, moves backward instead of forward.
	func (i *TextIter) ForwardSentenceEnds(count int) bool {
var _arg0 *C.GtkTextIter // out
var _arg1 C.gint // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
_arg1 = (C.gint)(count)

_cret = C.gtk_text_iter_forward_sentence_ends(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ForwardToEnd moves @iter forward to the “end iterator,” which points one past
// the last valid character in the buffer. gtk_text_iter_get_char() called on
// the end iterator returns 0, which is convenient for writing loops.
	func (i *TextIter) ForwardToEnd()  {
var _arg0 *C.GtkTextIter // out

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

C.gtk_text_iter_forward_to_end(_arg0)
}
	
	// ForwardToLineEnd moves the iterator to point to the paragraph delimiter
// characters, which will be either a newline, a carriage return, a carriage
// return/newline in sequence, or the Unicode paragraph separator character. If
// the iterator is already at the paragraph delimiter characters, moves to the
// paragraph delimiter characters for the next line. If @iter is on the last
// line in the buffer, which does not end in paragraph delimiters, moves to the
// end iterator (end of the last line), and returns false.
	func (i *TextIter) ForwardToLineEnd() bool {
var _arg0 *C.GtkTextIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_text_iter_forward_to_line_end(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ForwardToTagToggle moves forward to the next toggle (on or off) of the
// TextTag @tag, or to the next toggle of any tag if @tag is nil. If no matching
// tag toggles are found, returns false, otherwise true. Does not return toggles
// located at @iter, only toggles after @iter. Sets @iter to the location of the
// toggle, or to the end of the buffer if no toggle is found.
	func (i *TextIter) ForwardToTagToggle(tag TextTagClass) bool {
var _arg0 *C.GtkTextIter // out
var _arg1 *C.GtkTextTag // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GtkTextTag)(unsafe.Pointer(tag.Native()))

_cret = C.gtk_text_iter_forward_to_tag_toggle(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ForwardVisibleCursorPosition moves @iter forward to the next visible cursor
// position. See gtk_text_iter_forward_cursor_position() for details.
	func (i *TextIter) ForwardVisibleCursorPosition() bool {
var _arg0 *C.GtkTextIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_text_iter_forward_visible_cursor_position(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ForwardVisibleCursorPositions moves up to @count visible cursor positions.
// See gtk_text_iter_forward_cursor_position() for details.
	func (i *TextIter) ForwardVisibleCursorPositions(count int) bool {
var _arg0 *C.GtkTextIter // out
var _arg1 C.gint // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
_arg1 = (C.gint)(count)

_cret = C.gtk_text_iter_forward_visible_cursor_positions(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ForwardVisibleLine moves @iter to the start of the next visible line. Returns
// true if there was a next line to move to, and false if @iter was simply moved
// to the end of the buffer and is now not dereferenceable, or if @iter was
// already at the end of the buffer.
	func (i *TextIter) ForwardVisibleLine() bool {
var _arg0 *C.GtkTextIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_text_iter_forward_visible_line(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ForwardVisibleLines moves @count visible lines forward, if possible (if
// @count would move past the start or end of the buffer, moves to the start or
// end of the buffer). The return value indicates whether the iterator moved
// onto a dereferenceable position; if the iterator didn’t move, or moved onto
// the end iterator, then false is returned. If @count is 0, the function does
// nothing and returns false. If @count is negative, moves backward by 0 -
// @count lines.
	func (i *TextIter) ForwardVisibleLines(count int) bool {
var _arg0 *C.GtkTextIter // out
var _arg1 C.gint // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
_arg1 = (C.gint)(count)

_cret = C.gtk_text_iter_forward_visible_lines(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ForwardVisibleWordEnd moves forward to the next visible word end. (If @iter
// is currently on a word end, moves forward to the next one after that.) Word
// breaks are determined by Pango and should be correct for nearly any language
// (if not, the correct fix would be to the Pango word break algorithms).
	func (i *TextIter) ForwardVisibleWordEnd() bool {
var _arg0 *C.GtkTextIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_text_iter_forward_visible_word_end(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ForwardVisibleWordEnds calls gtk_text_iter_forward_visible_word_end() up to
// @count times.
	func (i *TextIter) ForwardVisibleWordEnds(count int) bool {
var _arg0 *C.GtkTextIter // out
var _arg1 C.gint // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
_arg1 = (C.gint)(count)

_cret = C.gtk_text_iter_forward_visible_word_ends(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ForwardWordEnd moves forward to the next word end. (If @iter is currently on
// a word end, moves forward to the next one after that.) Word breaks are
// determined by Pango and should be correct for nearly any language (if not,
// the correct fix would be to the Pango word break algorithms).
	func (i *TextIter) ForwardWordEnd() bool {
var _arg0 *C.GtkTextIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_text_iter_forward_word_end(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ForwardWordEnds calls gtk_text_iter_forward_word_end() up to @count times.
	func (i *TextIter) ForwardWordEnds(count int) bool {
var _arg0 *C.GtkTextIter // out
var _arg1 C.gint // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
_arg1 = (C.gint)(count)

_cret = C.gtk_text_iter_forward_word_ends(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Free: free an iterator allocated on the heap. This function is intended for
// use in language bindings, and is not especially useful for applications,
// because iterators can simply be allocated on the stack.
	func (i *TextIter) Free()  {
var _arg0 *C.GtkTextIter // out

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

C.gtk_text_iter_free(_arg0)
}
	
	// Attributes computes the effect of any tags applied to this spot in the text.
// The @values parameter should be initialized to the default settings you wish
// to use if no tags are in effect. You’d typically obtain the defaults from
// gtk_text_view_get_default_attributes().
// 
// gtk_text_iter_get_attributes() will modify @values, applying the effects of
// any tags present at @iter. If any tags affected @values, the function returns
// true.
	func (i *TextIter) Attributes() (TextAttributes, bool) {
var _arg0 *C.GtkTextIter // out
var _values TextAttributes
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_text_iter_get_attributes(_arg0, (*C.GtkTextAttributes)(unsafe.Pointer(&_values)))



var _ok bool // out


if _cret != 0 { _ok = true }

return _values, _ok
}
	
	// Buffer returns the TextBuffer this iterator is associated with.
	func (i *TextIter) Buffer() TextBuffer {
var _arg0 *C.GtkTextIter // out
var _cret *C.GtkTextBuffer // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_text_iter_get_buffer(_arg0)


var _textBuffer TextBuffer // out

_textBuffer = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TextBuffer)

return _textBuffer
}
	
	// BytesInLine returns the number of bytes in the line containing @iter,
// including the paragraph delimiters.
	func (i *TextIter) BytesInLine() int {
var _arg0 *C.GtkTextIter // out
var _cret C.gint // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_text_iter_get_bytes_in_line(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Char: the Unicode character at this iterator is returned. (Equivalent to
// operator* on a C++ iterator.) If the element at this iterator is a
// non-character element, such as an image embedded in the buffer, the Unicode
// “unknown” character 0xFFFC is returned. If invoked on the end iterator, zero
// is returned; zero is not a valid Unicode character. So you can write a loop
// which ends when gtk_text_iter_get_char() returns 0.
	func (i *TextIter) Char() uint32 {
var _arg0 *C.GtkTextIter // out
var _cret C.gunichar // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_text_iter_get_char(_arg0)


var _gunichar uint32 // out

_gunichar = (uint32)(_cret)

return _gunichar
}
	
	// CharsInLine returns the number of characters in the line containing @iter,
// including the paragraph delimiters.
	func (i *TextIter) CharsInLine() int {
var _arg0 *C.GtkTextIter // out
var _cret C.gint // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_text_iter_get_chars_in_line(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// ChildAnchor: if the location at @iter contains a child anchor, the anchor is
// returned (with no new reference count added). Otherwise, nil is returned.
	func (i *TextIter) ChildAnchor() TextChildAnchor {
var _arg0 *C.GtkTextIter // out
var _cret *C.GtkTextChildAnchor // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_text_iter_get_child_anchor(_arg0)


var _textChildAnchor TextChildAnchor // out

_textChildAnchor = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TextChildAnchor)

return _textChildAnchor
}
	
	// Language: a convenience wrapper around gtk_text_iter_get_attributes(), which
// returns the language in effect at @iter. If no tags affecting language apply
// to @iter, the return value is identical to that of
// gtk_get_default_language().
	func (i *TextIter) Language() *pango.Language {
var _arg0 *C.GtkTextIter // out
var _cret *C.PangoLanguage // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_text_iter_get_language(_arg0)


var _language *pango.Language // out

_language = *(**pango.Language)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_language, func(v *pango.Language) {
  C.free(unsafe.Pointer(v.Native()))
})

return _language
}
	
	// Line returns the line number containing the iterator. Lines in a TextBuffer
// are numbered beginning with 0 for the first line in the buffer.
	func (i *TextIter) Line() int {
var _arg0 *C.GtkTextIter // out
var _cret C.gint // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_text_iter_get_line(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// LineIndex returns the byte index of the iterator, counting from the start of
// a newline-terminated line. Remember that TextBuffer encodes text in UTF-8,
// and that characters can require a variable number of bytes to represent.
	func (i *TextIter) LineIndex() int {
var _arg0 *C.GtkTextIter // out
var _cret C.gint // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_text_iter_get_line_index(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// LineOffset returns the character offset of the iterator, counting from the
// start of a newline-terminated line. The first character on the line has
// offset 0.
	func (i *TextIter) LineOffset() int {
var _arg0 *C.GtkTextIter // out
var _cret C.gint // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_text_iter_get_line_offset(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Offset returns the character offset of an iterator. Each character in a
// TextBuffer has an offset, starting with 0 for the first character in the
// buffer. Use gtk_text_buffer_get_iter_at_offset() to convert an offset back
// into an iterator.
	func (i *TextIter) Offset() int {
var _arg0 *C.GtkTextIter // out
var _cret C.gint // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_text_iter_get_offset(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Pixbuf: if the element at @iter is a pixbuf, the pixbuf is returned (with no
// new reference count added). Otherwise, nil is returned.
	func (i *TextIter) Pixbuf() gdkpixbuf.Pixbuf {
var _arg0 *C.GtkTextIter // out
var _cret *C.GdkPixbuf // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_text_iter_get_pixbuf(_arg0)


var _pixbuf gdkpixbuf.Pixbuf // out

_pixbuf = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdkpixbuf.Pixbuf)

return _pixbuf
}
	
	// Slice returns the text in the given range. A “slice” is an array of
// characters encoded in UTF-8 format, including the Unicode “unknown” character
// 0xFFFC for iterable non-character elements in the buffer, such as images.
// Because images are encoded in the slice, byte and character offsets in the
// returned array will correspond to byte offsets in the text buffer. Note that
// 0xFFFC can occur in normal text as well, so it is not a reliable indicator
// that a pixbuf or widget is in the buffer.
	func (s *TextIter) Slice(end *TextIter) string {
var _arg0 *C.GtkTextIter // out
var _arg1 *C.GtkTextIter // out
var _cret *C.gchar // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

_cret = C.gtk_text_iter_get_slice(_arg0, _arg1)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// Text returns text in the given range. If the range contains non-text elements
// such as images, the character and byte offsets in the returned string will
// not correspond to character and byte offsets in the buffer. If you want
// offsets to correspond, see gtk_text_iter_get_slice().
	func (s *TextIter) Text(end *TextIter) string {
var _arg0 *C.GtkTextIter // out
var _arg1 *C.GtkTextIter // out
var _cret *C.gchar // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

_cret = C.gtk_text_iter_get_text(_arg0, _arg1)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// VisibleLineIndex returns the number of bytes from the start of the line to
// the given @iter, not counting bytes that are invisible due to tags with the
// “invisible” flag toggled on.
	func (i *TextIter) VisibleLineIndex() int {
var _arg0 *C.GtkTextIter // out
var _cret C.gint // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_text_iter_get_visible_line_index(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// VisibleLineOffset returns the offset in characters from the start of the line
// to the given @iter, not counting characters that are invisible due to tags
// with the “invisible” flag toggled on.
	func (i *TextIter) VisibleLineOffset() int {
var _arg0 *C.GtkTextIter // out
var _cret C.gint // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_text_iter_get_visible_line_offset(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// VisibleSlice: like gtk_text_iter_get_slice(), but invisible text is not
// included. Invisible text is usually invisible because a TextTag with the
// “invisible” attribute turned on has been applied to it.
	func (s *TextIter) VisibleSlice(end *TextIter) string {
var _arg0 *C.GtkTextIter // out
var _arg1 *C.GtkTextIter // out
var _cret *C.gchar // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

_cret = C.gtk_text_iter_get_visible_slice(_arg0, _arg1)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// VisibleText: like gtk_text_iter_get_text(), but invisible text is not
// included. Invisible text is usually invisible because a TextTag with the
// “invisible” attribute turned on has been applied to it.
	func (s *TextIter) VisibleText(end *TextIter) string {
var _arg0 *C.GtkTextIter // out
var _arg1 *C.GtkTextIter // out
var _cret *C.gchar // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

_cret = C.gtk_text_iter_get_visible_text(_arg0, _arg1)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// HasTag returns true if @iter points to a character that is part of a range
// tagged with @tag. See also gtk_text_iter_starts_tag() and
// gtk_text_iter_ends_tag().
	func (i *TextIter) HasTag(tag TextTagClass) bool {
var _arg0 *C.GtkTextIter // out
var _arg1 *C.GtkTextTag // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GtkTextTag)(unsafe.Pointer(tag.Native()))

_cret = C.gtk_text_iter_has_tag(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// InRange checks whether @iter falls in the range [@start, @end). @start and
// @end must be in ascending order.
	func (i *TextIter) InRange(start *TextIter, end *TextIter) bool {
var _arg0 *C.GtkTextIter // out
var _arg1 *C.GtkTextIter // out
var _arg2 *C.GtkTextIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
_arg2 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

_cret = C.gtk_text_iter_in_range(_arg0, _arg1, _arg2)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// InsideSentence determines whether @iter is inside a sentence (as opposed to
// in between two sentences, e.g. after a period and before the first letter of
// the next sentence). Sentence boundaries are determined by Pango and should be
// correct for nearly any language (if not, the correct fix would be to the
// Pango text boundary algorithms).
	func (i *TextIter) InsideSentence() bool {
var _arg0 *C.GtkTextIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_text_iter_inside_sentence(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// InsideWord determines whether the character pointed by @iter is part of a
// natural-language word (as opposed to say inside some whitespace). Word breaks
// are determined by Pango and should be correct for nearly any language (if
// not, the correct fix would be to the Pango word break algorithms).
// 
// Note that if gtk_text_iter_starts_word() returns true, then this function
// returns true too, since @iter points to the first character of the word.
	func (i *TextIter) InsideWord() bool {
var _arg0 *C.GtkTextIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_text_iter_inside_word(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsCursorPosition: see gtk_text_iter_forward_cursor_position() or LogAttr or
// pango_break() for details on what a cursor position is.
	func (i *TextIter) IsCursorPosition() bool {
var _arg0 *C.GtkTextIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_text_iter_is_cursor_position(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsEnd returns true if @iter is the end iterator, i.e. one past the last
// dereferenceable iterator in the buffer. gtk_text_iter_is_end() is the most
// efficient way to check whether an iterator is the end iterator.
	func (i *TextIter) IsEnd() bool {
var _arg0 *C.GtkTextIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_text_iter_is_end(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsStart returns true if @iter is the first iterator in the buffer, that is if
// @iter has a character offset of 0.
	func (i *TextIter) IsStart() bool {
var _arg0 *C.GtkTextIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_text_iter_is_start(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Order swaps the value of @first and @second if @second comes before @first in
// the buffer. That is, ensures that @first and @second are in sequence. Most
// text buffer functions that take a range call this automatically on your
// behalf, so there’s no real reason to call it yourself in those cases. There
// are some exceptions, such as gtk_text_iter_in_range(), that expect a
// pre-sorted range.
	func (f *TextIter) Order(second *TextIter)  {
var _arg0 *C.GtkTextIter // out
var _arg1 *C.GtkTextIter // out

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(f.Native()))
_arg1 = (*C.GtkTextIter)(unsafe.Pointer(second.Native()))

C.gtk_text_iter_order(_arg0, _arg1)
}
	
	// SetLine moves iterator @iter to the start of the line @line_number. If
// @line_number is negative or larger than the number of lines in the buffer,
// moves @iter to the start of the last line in the buffer.
	func (i *TextIter) SetLine(lineNumber int)  {
var _arg0 *C.GtkTextIter // out
var _arg1 C.gint // out

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
_arg1 = (C.gint)(lineNumber)

C.gtk_text_iter_set_line(_arg0, _arg1)
}
	
	// SetLineIndex: same as gtk_text_iter_set_line_offset(), but works with a byte
// index. The given byte index must be at the start of a character, it can’t be
// in the middle of a UTF-8 encoded character.
	func (i *TextIter) SetLineIndex(byteOnLine int)  {
var _arg0 *C.GtkTextIter // out
var _arg1 C.gint // out

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
_arg1 = (C.gint)(byteOnLine)

C.gtk_text_iter_set_line_index(_arg0, _arg1)
}
	
	// SetLineOffset moves @iter within a line, to a new character (not byte)
// offset. The given character offset must be less than or equal to the number
// of characters in the line; if equal, @iter moves to the start of the next
// line. See gtk_text_iter_set_line_index() if you have a byte index rather than
// a character offset.
	func (i *TextIter) SetLineOffset(charOnLine int)  {
var _arg0 *C.GtkTextIter // out
var _arg1 C.gint // out

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
_arg1 = (C.gint)(charOnLine)

C.gtk_text_iter_set_line_offset(_arg0, _arg1)
}
	
	// SetOffset sets @iter to point to @char_offset. @char_offset counts from the
// start of the entire text buffer, starting with 0.
	func (i *TextIter) SetOffset(charOffset int)  {
var _arg0 *C.GtkTextIter // out
var _arg1 C.gint // out

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
_arg1 = (C.gint)(charOffset)

C.gtk_text_iter_set_offset(_arg0, _arg1)
}
	
	// SetVisibleLineIndex: like gtk_text_iter_set_line_index(), but the index is in
// visible bytes, i.e. text with a tag making it invisible is not counted in the
// index.
	func (i *TextIter) SetVisibleLineIndex(byteOnLine int)  {
var _arg0 *C.GtkTextIter // out
var _arg1 C.gint // out

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
_arg1 = (C.gint)(byteOnLine)

C.gtk_text_iter_set_visible_line_index(_arg0, _arg1)
}
	
	// SetVisibleLineOffset: like gtk_text_iter_set_line_offset(), but the offset is
// in visible characters, i.e. text with a tag making it invisible is not
// counted in the offset.
	func (i *TextIter) SetVisibleLineOffset(charOnLine int)  {
var _arg0 *C.GtkTextIter // out
var _arg1 C.gint // out

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
_arg1 = (C.gint)(charOnLine)

C.gtk_text_iter_set_visible_line_offset(_arg0, _arg1)
}
	
	// StartsLine returns true if @iter begins a paragraph, i.e. if
// gtk_text_iter_get_line_offset() would return 0. However this function is
// potentially more efficient than gtk_text_iter_get_line_offset() because it
// doesn’t have to compute the offset, it just has to see whether it’s 0.
	func (i *TextIter) StartsLine() bool {
var _arg0 *C.GtkTextIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_text_iter_starts_line(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// StartsSentence determines whether @iter begins a sentence. Sentence
// boundaries are determined by Pango and should be correct for nearly any
// language (if not, the correct fix would be to the Pango text boundary
// algorithms).
	func (i *TextIter) StartsSentence() bool {
var _arg0 *C.GtkTextIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_text_iter_starts_sentence(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// StartsTag returns true if @tag is toggled on at exactly this point. If @tag
// is nil, returns true if any tag is toggled on at this point.
// 
// Note that if gtk_text_iter_starts_tag() returns true, it means that @iter is
// at the beginning of the tagged range, and that the character at @iter is
// inside the tagged range. In other words, unlike gtk_text_iter_ends_tag(), if
// gtk_text_iter_starts_tag() returns true, gtk_text_iter_has_tag() will also
// return true for the same parameters.
	func (i *TextIter) StartsTag(tag TextTagClass) bool {
var _arg0 *C.GtkTextIter // out
var _arg1 *C.GtkTextTag // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GtkTextTag)(unsafe.Pointer(tag.Native()))

_cret = C.gtk_text_iter_starts_tag(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// StartsWord determines whether @iter begins a natural-language word. Word
// breaks are determined by Pango and should be correct for nearly any language
// (if not, the correct fix would be to the Pango word break algorithms).
	func (i *TextIter) StartsWord() bool {
var _arg0 *C.GtkTextIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_text_iter_starts_word(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// TogglesTag: this is equivalent to (gtk_text_iter_starts_tag() ||
// gtk_text_iter_ends_tag()), i.e. it tells you whether a range with @tag
// applied to it begins or ends at @iter.
	func (i *TextIter) TogglesTag(tag TextTagClass) bool {
var _arg0 *C.GtkTextIter // out
var _arg1 *C.GtkTextTag // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GtkTextTag)(unsafe.Pointer(tag.Native()))

_cret = C.gtk_text_iter_toggles_tag(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	


	
	type ThemeEngine struct {
		Native C.GtkThemeEngine
	}

	

	

	

	// Native returns the underlying C source pointer.
	func (t *ThemeEngine) Native() uintptr {
		return uintptr(unsafe.Pointer(&t.Native))
	}

	

	


	// TreeIter: the TreeIter is the primary structure for accessing a TreeModel.
// Models are expected to put a unique integer in the @stamp member, and put
// model-specific data in the three @user_data members.
	type TreeIter struct {
		Native C.GtkTreeIter
	}

	
	func marshalTreeIter(p uintptr) (interface{}, error) {
		b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
		return (*TreeIter)(unsafe.Pointer(b))
	}
	

	

	

	// Native returns the underlying C source pointer.
	func (t *TreeIter) Native() uintptr {
		return uintptr(unsafe.Pointer(&t.Native))
	}

	

	
	// Copy creates a dynamically allocated tree iterator as a copy of @iter.
// 
// This function is not intended for use in applications, because you can just
// copy the structs by value (`GtkTreeIter new_iter = iter;`). You must free
// this iter with gtk_tree_iter_free().
	func (i *TreeIter) Copy() *TreeIter {
var _arg0 *C.GtkTreeIter // out
var _cret *C.GtkTreeIter // in

_arg0 = (*C.GtkTreeIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_tree_iter_copy(_arg0)


var _treeIter *TreeIter // out

_treeIter = *(**TreeIter)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_treeIter, func(v *TreeIter) {
  C.free(unsafe.Pointer(v.Native()))
})

return _treeIter
}
	
	// Free frees an iterator that has been allocated by gtk_tree_iter_copy().
// 
// This function is mainly used for language bindings.
	func (i *TreeIter) Free()  {
var _arg0 *C.GtkTreeIter // out

_arg0 = (*C.GtkTreeIter)(unsafe.Pointer(i.Native()))

C.gtk_tree_iter_free(_arg0)
}
	


	
	type TreePath struct {
		Native C.GtkTreePath
	}

	
	func marshalTreePath(p uintptr) (interface{}, error) {
		b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
		return (*TreePath)(unsafe.Pointer(b))
	}
	

	
	
	// NewTreePath constructs a struct TreePath.
	func NewTreePath() *TreePath {
var _cret *C.GtkTreePath // in

_cret = C.gtk_tree_path_new()


var _treePath *TreePath // out

_treePath = *(**TreePath)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_treePath, func(v *TreePath) {
  C.free(unsafe.Pointer(v.Native()))
})

return _treePath
}
	
	
	
	// NewTreePathFirst constructs a struct TreePath.
	func NewTreePathFirst() *TreePath {
var _cret *C.GtkTreePath // in

_cret = C.gtk_tree_path_new_first()


var _treePath *TreePath // out

_treePath = *(**TreePath)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_treePath, func(v *TreePath) {
  C.free(unsafe.Pointer(v.Native()))
})

return _treePath
}
	
	
	
	
	
	// NewTreePathFromIndicesv constructs a struct TreePath.
	func NewTreePathFromIndicesv(indices []int) *TreePath {
var _arg1 *C.gint
var _arg2 C.gsize
var _cret *C.GtkTreePath // in

_arg2 = C.gsize(len(indices))
_arg1 = (*C.gint)(unsafe.Pointer(&indices[0]))

_cret = C.gtk_tree_path_new_from_indicesv(_arg1, _arg2)


var _treePath *TreePath // out

_treePath = *(**TreePath)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_treePath, func(v *TreePath) {
  C.free(unsafe.Pointer(v.Native()))
})

return _treePath
}
	
	
	
	// NewTreePathFromString constructs a struct TreePath.
	func NewTreePathFromString(path string) *TreePath {
var _arg1 *C.gchar // out
var _cret *C.GtkTreePath // in

_arg1 = (*C.gchar)(C.CString(path))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_tree_path_new_from_string(_arg1)


var _treePath *TreePath // out

_treePath = *(**TreePath)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_treePath, func(v *TreePath) {
  C.free(unsafe.Pointer(v.Native()))
})

return _treePath
}
	
	

	

	// Native returns the underlying C source pointer.
	func (t *TreePath) Native() uintptr {
		return uintptr(unsafe.Pointer(&t.Native))
	}

	

	
	// AppendIndex appends a new index to a path.
// 
// As a result, the depth of the path is increased.
	func (p *TreePath) AppendIndex(index_ int)  {
var _arg0 *C.GtkTreePath // out
var _arg1 C.gint // out

_arg0 = (*C.GtkTreePath)(unsafe.Pointer(p.Native()))
_arg1 = (C.gint)(index_)

C.gtk_tree_path_append_index(_arg0, _arg1)
}
	
	// Compare compares two paths.
// 
// If @a appears before @b in a tree, then -1 is returned. If @b appears before
// @a, then 1 is returned. If the two nodes are equal, then 0 is returned.
	func (a *TreePath) Compare(b *TreePath) int {
var _arg0 *C.GtkTreePath // out
var _arg1 *C.GtkTreePath // out
var _cret C.gint // in

_arg0 = (*C.GtkTreePath)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(b.Native()))

_cret = C.gtk_tree_path_compare(_arg0, _arg1)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Copy creates a new TreePath-struct as a copy of @path.
	func (p *TreePath) Copy() *TreePath {
var _arg0 *C.GtkTreePath // out
var _cret *C.GtkTreePath // in

_arg0 = (*C.GtkTreePath)(unsafe.Pointer(p.Native()))

_cret = C.gtk_tree_path_copy(_arg0)


var _treePath *TreePath // out

_treePath = *(**TreePath)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_treePath, func(v *TreePath) {
  C.free(unsafe.Pointer(v.Native()))
})

return _treePath
}
	
	// Down moves @path to point to the first child of the current path.
	func (p *TreePath) Down()  {
var _arg0 *C.GtkTreePath // out

_arg0 = (*C.GtkTreePath)(unsafe.Pointer(p.Native()))

C.gtk_tree_path_down(_arg0)
}
	
	// Free frees @path. If @path is nil, it simply returns.
	func (p *TreePath) Free()  {
var _arg0 *C.GtkTreePath // out

_arg0 = (*C.GtkTreePath)(unsafe.Pointer(p.Native()))

C.gtk_tree_path_free(_arg0)
}
	
	// Depth returns the current depth of @path.
	func (p *TreePath) Depth() int {
var _arg0 *C.GtkTreePath // out
var _cret C.gint // in

_arg0 = (*C.GtkTreePath)(unsafe.Pointer(p.Native()))

_cret = C.gtk_tree_path_get_depth(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// IsAncestor returns true if @descendant is a descendant of @path.
	func (p *TreePath) IsAncestor(descendant *TreePath) bool {
var _arg0 *C.GtkTreePath // out
var _arg1 *C.GtkTreePath // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreePath)(unsafe.Pointer(p.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(descendant.Native()))

_cret = C.gtk_tree_path_is_ancestor(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsDescendant returns true if @path is a descendant of @ancestor.
	func (p *TreePath) IsDescendant(ancestor *TreePath) bool {
var _arg0 *C.GtkTreePath // out
var _arg1 *C.GtkTreePath // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreePath)(unsafe.Pointer(p.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(ancestor.Native()))

_cret = C.gtk_tree_path_is_descendant(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Next moves the @path to point to the next node at the current depth.
	func (p *TreePath) Next()  {
var _arg0 *C.GtkTreePath // out

_arg0 = (*C.GtkTreePath)(unsafe.Pointer(p.Native()))

C.gtk_tree_path_next(_arg0)
}
	
	// PrependIndex prepends a new index to a path.
// 
// As a result, the depth of the path is increased.
	func (p *TreePath) PrependIndex(index_ int)  {
var _arg0 *C.GtkTreePath // out
var _arg1 C.gint // out

_arg0 = (*C.GtkTreePath)(unsafe.Pointer(p.Native()))
_arg1 = (C.gint)(index_)

C.gtk_tree_path_prepend_index(_arg0, _arg1)
}
	
	// Prev moves the @path to point to the previous node at the current depth, if
// it exists.
	func (p *TreePath) Prev() bool {
var _arg0 *C.GtkTreePath // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreePath)(unsafe.Pointer(p.Native()))

_cret = C.gtk_tree_path_prev(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// String generates a string representation of the path.
// 
// This string is a “:” separated list of numbers. For example, “4:10:0:3” would
// be an acceptable return value for this string.
	func (p *TreePath) String() string {
var _arg0 *C.GtkTreePath // out
var _cret *C.gchar // in

_arg0 = (*C.GtkTreePath)(unsafe.Pointer(p.Native()))

_cret = C.gtk_tree_path_to_string(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// Up moves the @path to point to its parent node, if it has a parent.
	func (p *TreePath) Up() bool {
var _arg0 *C.GtkTreePath // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreePath)(unsafe.Pointer(p.Native()))

_cret = C.gtk_tree_path_up(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	


	// TreeRowReference: a GtkTreeRowReference tracks model changes so that it
// always refers to the same row (a TreePath refers to a position, not a fixed
// row). Create a new GtkTreeRowReference with gtk_tree_row_reference_new().
	type TreeRowReference struct {
		Native C.GtkTreeRowReference
	}

	
	func marshalTreeRowReference(p uintptr) (interface{}, error) {
		b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
		return (*TreeRowReference)(unsafe.Pointer(b))
	}
	

	
	
	// NewTreeRowReference constructs a struct TreeRowReference.
	func NewTreeRowReference(model TreeModel, path *TreePath) *TreeRowReference {
var _arg1 *C.GtkTreeModel // out
var _arg2 *C.GtkTreePath // out
var _cret *C.GtkTreeRowReference // in

_arg1 = (*C.GtkTreeModel)(unsafe.Pointer(model.Native()))
_arg2 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

_cret = C.gtk_tree_row_reference_new(_arg1, _arg2)


var _treeRowReference *TreeRowReference // out

_treeRowReference = *(**TreeRowReference)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_treeRowReference, func(v *TreeRowReference) {
  C.free(unsafe.Pointer(v.Native()))
})

return _treeRowReference
}
	
	
	
	// NewTreeRowReferenceProXY constructs a struct TreeRowReference.
	func NewTreeRowReferenceProXY(proxy **externglib.Object, model TreeModel, path *TreePath) *TreeRowReference {
var _arg1 *C.GObject // out
var _arg2 *C.GtkTreeModel // out
var _arg3 *C.GtkTreePath // out
var _cret *C.GtkTreeRowReference // in

_arg1 = (*C.GObject)(unsafe.Pointer(proxy.Native()))
_arg2 = (*C.GtkTreeModel)(unsafe.Pointer(model.Native()))
_arg3 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

_cret = C.gtk_tree_row_reference_new_proxy(_arg1, _arg2, _arg3)


var _treeRowReference *TreeRowReference // out

_treeRowReference = *(**TreeRowReference)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_treeRowReference, func(v *TreeRowReference) {
  C.free(unsafe.Pointer(v.Native()))
})

return _treeRowReference
}
	
	

	

	// Native returns the underlying C source pointer.
	func (t *TreeRowReference) Native() uintptr {
		return uintptr(unsafe.Pointer(&t.Native))
	}

	

	
	// Copy copies a TreeRowReference.
	func (r *TreeRowReference) Copy() *TreeRowReference {
var _arg0 *C.GtkTreeRowReference // out
var _cret *C.GtkTreeRowReference // in

_arg0 = (*C.GtkTreeRowReference)(unsafe.Pointer(r.Native()))

_cret = C.gtk_tree_row_reference_copy(_arg0)


var _treeRowReference *TreeRowReference // out

_treeRowReference = *(**TreeRowReference)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_treeRowReference, func(v *TreeRowReference) {
  C.free(unsafe.Pointer(v.Native()))
})

return _treeRowReference
}
	
	// Free free’s @reference. @reference may be nil
	func (r *TreeRowReference) Free()  {
var _arg0 *C.GtkTreeRowReference // out

_arg0 = (*C.GtkTreeRowReference)(unsafe.Pointer(r.Native()))

C.gtk_tree_row_reference_free(_arg0)
}
	
	// Model returns the model that the row reference is monitoring.
	func (r *TreeRowReference) Model() TreeModel {
var _arg0 *C.GtkTreeRowReference // out
var _cret *C.GtkTreeModel // in

_arg0 = (*C.GtkTreeRowReference)(unsafe.Pointer(r.Native()))

_cret = C.gtk_tree_row_reference_get_model(_arg0)


var _treeModel TreeModel // out

_treeModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TreeModel)

return _treeModel
}
	
	// Path returns a path that the row reference currently points to, or nil if the
// path pointed to is no longer valid.
	func (r *TreeRowReference) Path() *TreePath {
var _arg0 *C.GtkTreeRowReference // out
var _cret *C.GtkTreePath // in

_arg0 = (*C.GtkTreeRowReference)(unsafe.Pointer(r.Native()))

_cret = C.gtk_tree_row_reference_get_path(_arg0)


var _treePath *TreePath // out

_treePath = *(**TreePath)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_treePath, func(v *TreePath) {
  C.free(unsafe.Pointer(v.Native()))
})

return _treePath
}
	
	// Valid returns true if the @reference is non-nil and refers to a current valid
// path.
	func (r *TreeRowReference) Valid() bool {
var _arg0 *C.GtkTreeRowReference // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeRowReference)(unsafe.Pointer(r.Native()))

_cret = C.gtk_tree_row_reference_valid(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	


	// WidgetPath: gtkWidgetPath is a boxed type that represents a widget hierarchy
// from the topmost widget, typically a toplevel, to any child. This widget path
// abstraction is used in StyleContext on behalf of the real widget in order to
// query style information.
// 
// If you are using GTK+ widgets, you probably will not need to use this API
// directly, as there is gtk_widget_get_path(), and the style context returned
// by gtk_widget_get_style_context() will be automatically updated on widget
// hierarchy changes.
// 
// The widget path generation is generally simple:
// 
// Defining a button within a window
// 
//    {
//      GtkWidgetPath *path;
//      guint pos;
// 
//      path = gtk_widget_path_new ();
// 
//      pos = gtk_widget_path_append_type (path, GTK_TYPE_NOTEBOOK);
//      gtk_widget_path_iter_add_region (path, pos, "tab", GTK_REGION_EVEN | GTK_REGION_FIRST);
// 
//      pos = gtk_widget_path_append_type (path, GTK_TYPE_LABEL);
//      gtk_widget_path_iter_set_name (path, pos, "first tab label");
//    }
// 
// All this information will be used to match the style information that applies
// to the described widget.
	type WidgetPath struct {
		Native C.GtkWidgetPath
	}

	
	func marshalWidgetPath(p uintptr) (interface{}, error) {
		b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
		return (*WidgetPath)(unsafe.Pointer(b))
	}
	

	
	
	// NewWidgetPath constructs a struct WidgetPath.
	func NewWidgetPath() *WidgetPath {
var _cret *C.GtkWidgetPath // in

_cret = C.gtk_widget_path_new()


var _widgetPath *WidgetPath // out

_widgetPath = *(**WidgetPath)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_widgetPath, func(v *WidgetPath) {
  C.free(unsafe.Pointer(v.Native()))
})

return _widgetPath
}
	
	

	

	// Native returns the underlying C source pointer.
	func (w *WidgetPath) Native() uintptr {
		return uintptr(unsafe.Pointer(&w.Native))
	}

	

	
	// AppendForWidget appends the data from @widget to the widget hierarchy
// represented by @path. This function is a shortcut for adding information from
// @widget to the given @path. This includes setting the name or adding the
// style classes from @widget.
	func (p *WidgetPath) AppendForWidget(widget WidgetClass) int {
var _arg0 *C.GtkWidgetPath // out
var _arg1 *C.GtkWidget // out
var _cret C.gint // in

_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

_cret = C.gtk_widget_path_append_for_widget(_arg0, _arg1)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// AppendType appends a widget type to the widget hierarchy represented by
// @path.
	func (p *WidgetPath) AppendType(typ externglib.Type) int {
var _arg0 *C.GtkWidgetPath // out
var _arg1 C.GType // out
var _cret C.gint // in

_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
_arg1 = C.GType(typ)

_cret = C.gtk_widget_path_append_type(_arg0, _arg1)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// AppendWithSiblings appends a widget type with all its siblings to the widget
// hierarchy represented by @path. Using this function instead of
// gtk_widget_path_append_type() will allow the CSS theming to use sibling
// matches in selectors and apply :nth-child() pseudo classes. In turn, it
// requires a lot more care in widget implementations as widgets need to make
// sure to call gtk_widget_reset_style() on all involved widgets when the
// @siblings path changes.
	func (p *WidgetPath) AppendWithSiblings(siblings *WidgetPath, siblingIndex uint) int {
var _arg0 *C.GtkWidgetPath // out
var _arg1 *C.GtkWidgetPath // out
var _arg2 C.guint // out
var _cret C.gint // in

_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
_arg1 = (*C.GtkWidgetPath)(unsafe.Pointer(siblings.Native()))
_arg2 = (C.guint)(siblingIndex)

_cret = C.gtk_widget_path_append_with_siblings(_arg0, _arg1, _arg2)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Copy returns a copy of @path
	func (p *WidgetPath) Copy() *WidgetPath {
var _arg0 *C.GtkWidgetPath // out
var _cret *C.GtkWidgetPath // in

_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))

_cret = C.gtk_widget_path_copy(_arg0)


var _widgetPath *WidgetPath // out

_widgetPath = *(**WidgetPath)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_widgetPath, func(v *WidgetPath) {
  C.free(unsafe.Pointer(v.Native()))
})

return _widgetPath
}
	
	// Free decrements the reference count on @path, freeing the structure if the
// reference count reaches 0.
	func (p *WidgetPath) Free()  {
var _arg0 *C.GtkWidgetPath // out

_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))

C.gtk_widget_path_free(_arg0)
}
	
	// ObjectType returns the topmost object type, that is, the object type this
// path is representing.
	func (p *WidgetPath) ObjectType() externglib.Type {
var _arg0 *C.GtkWidgetPath // out
var _cret C.GType // in

_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))

_cret = C.gtk_widget_path_get_object_type(_arg0)


var _gType externglib.Type // out

_gType = externglib.Type(_cret)

return _gType
}
	
	// HasParent returns true if any of the parents of the widget represented in
// @path is of type @type, or any subtype of it.
	func (p *WidgetPath) HasParent(typ externglib.Type) bool {
var _arg0 *C.GtkWidgetPath // out
var _arg1 C.GType // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
_arg1 = C.GType(typ)

_cret = C.gtk_widget_path_has_parent(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsType returns true if the widget type represented by this path is @type, or
// a subtype of it.
	func (p *WidgetPath) IsType(typ externglib.Type) bool {
var _arg0 *C.GtkWidgetPath // out
var _arg1 C.GType // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
_arg1 = C.GType(typ)

_cret = C.gtk_widget_path_is_type(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IterAddClass adds the class @name to the widget at position @pos in the
// hierarchy defined in @path. See gtk_style_context_add_class().
	func (p *WidgetPath) IterAddClass(pos int, name string)  {
var _arg0 *C.GtkWidgetPath // out
var _arg1 C.gint // out
var _arg2 *C.gchar // out

_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
_arg1 = (C.gint)(pos)
_arg2 = (*C.gchar)(C.CString(name))
defer C.free(unsafe.Pointer(_arg2))

C.gtk_widget_path_iter_add_class(_arg0, _arg1, _arg2)
}
	
	// IterAddRegion adds the region @name to the widget at position @pos in the
// hierarchy defined in @path. See gtk_style_context_add_region().
// 
// Region names must only contain lowercase letters and “-”, starting always
// with a lowercase letter.
	func (p *WidgetPath) IterAddRegion(pos int, name string, flags RegionFlags)  {
var _arg0 *C.GtkWidgetPath // out
var _arg1 C.gint // out
var _arg2 *C.gchar // out
var _arg3 C.GtkRegionFlags // out

_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
_arg1 = (C.gint)(pos)
_arg2 = (*C.gchar)(C.CString(name))
defer C.free(unsafe.Pointer(_arg2))
_arg3 = (C.GtkRegionFlags)(flags)

C.gtk_widget_path_iter_add_region(_arg0, _arg1, _arg2, _arg3)
}
	
	// IterClearClasses removes all classes from the widget at position @pos in the
// hierarchy defined in @path.
	func (p *WidgetPath) IterClearClasses(pos int)  {
var _arg0 *C.GtkWidgetPath // out
var _arg1 C.gint // out

_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
_arg1 = (C.gint)(pos)

C.gtk_widget_path_iter_clear_classes(_arg0, _arg1)
}
	
	// IterClearRegions removes all regions from the widget at position @pos in the
// hierarchy defined in @path.
	func (p *WidgetPath) IterClearRegions(pos int)  {
var _arg0 *C.GtkWidgetPath // out
var _arg1 C.gint // out

_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
_arg1 = (C.gint)(pos)

C.gtk_widget_path_iter_clear_regions(_arg0, _arg1)
}
	
	// IterGetName returns the name corresponding to the widget found at the
// position @pos in the widget hierarchy defined by @path
	func (p *WidgetPath) IterGetName(pos int) string {
var _arg0 *C.GtkWidgetPath // out
var _arg1 C.gint // out
var _cret *C.gchar // in

_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
_arg1 = (C.gint)(pos)

_cret = C.gtk_widget_path_iter_get_name(_arg0, _arg1)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// IterGetObjectName returns the object name that is at position @pos in the
// widget hierarchy defined in @path.
	func (p *WidgetPath) IterGetObjectName(pos int) string {
var _arg0 *C.GtkWidgetPath // out
var _arg1 C.gint // out
var _cret *C.char // in

_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
_arg1 = (C.gint)(pos)

_cret = C.gtk_widget_path_iter_get_object_name(_arg0, _arg1)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// IterGetObjectType returns the object #GType that is at position @pos in the
// widget hierarchy defined in @path.
	func (p *WidgetPath) IterGetObjectType(pos int) externglib.Type {
var _arg0 *C.GtkWidgetPath // out
var _arg1 C.gint // out
var _cret C.GType // in

_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
_arg1 = (C.gint)(pos)

_cret = C.gtk_widget_path_iter_get_object_type(_arg0, _arg1)


var _gType externglib.Type // out

_gType = externglib.Type(_cret)

return _gType
}
	
	// IterGetSiblingIndex returns the index into the list of siblings for the
// element at @pos as returned by gtk_widget_path_iter_get_siblings(). If that
// function would return nil because the element at @pos has no siblings, this
// function will return 0.
	func (p *WidgetPath) IterGetSiblingIndex(pos int) uint {
var _arg0 *C.GtkWidgetPath // out
var _arg1 C.gint // out
var _cret C.guint // in

_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
_arg1 = (C.gint)(pos)

_cret = C.gtk_widget_path_iter_get_sibling_index(_arg0, _arg1)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// IterGetSiblings returns the list of siblings for the element at @pos. If the
// element was not added with siblings, nil is returned.
	func (p *WidgetPath) IterGetSiblings(pos int) *WidgetPath {
var _arg0 *C.GtkWidgetPath // out
var _arg1 C.gint // out
var _cret *C.GtkWidgetPath // in

_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
_arg1 = (C.gint)(pos)

_cret = C.gtk_widget_path_iter_get_siblings(_arg0, _arg1)


var _widgetPath *WidgetPath // out

_widgetPath = *(**WidgetPath)(unsafe.Pointer(&_cret))

return _widgetPath
}
	
	// IterGetState returns the state flags corresponding to the widget found at the
// position @pos in the widget hierarchy defined by @path
	func (p *WidgetPath) IterGetState(pos int) StateFlags {
var _arg0 *C.GtkWidgetPath // out
var _arg1 C.gint // out
var _cret C.GtkStateFlags // in

_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
_arg1 = (C.gint)(pos)

_cret = C.gtk_widget_path_iter_get_state(_arg0, _arg1)


var _stateFlags StateFlags // out

_stateFlags = StateFlags(_cret)

return _stateFlags
}
	
	// IterHasClass returns true if the widget at position @pos has the class @name
// defined, false otherwise.
	func (p *WidgetPath) IterHasClass(pos int, name string) bool {
var _arg0 *C.GtkWidgetPath // out
var _arg1 C.gint // out
var _arg2 *C.gchar // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
_arg1 = (C.gint)(pos)
_arg2 = (*C.gchar)(C.CString(name))
defer C.free(unsafe.Pointer(_arg2))

_cret = C.gtk_widget_path_iter_has_class(_arg0, _arg1, _arg2)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IterHasName returns true if the widget at position @pos has the name @name,
// false otherwise.
	func (p *WidgetPath) IterHasName(pos int, name string) bool {
var _arg0 *C.GtkWidgetPath // out
var _arg1 C.gint // out
var _arg2 *C.gchar // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
_arg1 = (C.gint)(pos)
_arg2 = (*C.gchar)(C.CString(name))
defer C.free(unsafe.Pointer(_arg2))

_cret = C.gtk_widget_path_iter_has_name(_arg0, _arg1, _arg2)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IterHasRegion returns true if the widget at position @pos has the class @name
// defined, false otherwise.
	func (p *WidgetPath) IterHasRegion(pos int, name string) (RegionFlags, bool) {
var _arg0 *C.GtkWidgetPath // out
var _arg1 C.gint // out
var _arg2 *C.gchar // out
var _arg3 C.GtkRegionFlags // in
var _cret C.gboolean // in

_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
_arg1 = (C.gint)(pos)
_arg2 = (*C.gchar)(C.CString(name))
defer C.free(unsafe.Pointer(_arg2))

_cret = C.gtk_widget_path_iter_has_region(_arg0, _arg1, _arg2, &_arg3)


var _flags RegionFlags // out
var _ok bool // out

_flags = RegionFlags(_arg3)
if _cret != 0 { _ok = true }

return _flags, _ok
}
	
	// IterRemoveClass removes the class @name from the widget at position @pos in
// the hierarchy defined in @path.
	func (p *WidgetPath) IterRemoveClass(pos int, name string)  {
var _arg0 *C.GtkWidgetPath // out
var _arg1 C.gint // out
var _arg2 *C.gchar // out

_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
_arg1 = (C.gint)(pos)
_arg2 = (*C.gchar)(C.CString(name))
defer C.free(unsafe.Pointer(_arg2))

C.gtk_widget_path_iter_remove_class(_arg0, _arg1, _arg2)
}
	
	// IterRemoveRegion removes the region @name from the widget at position @pos in
// the hierarchy defined in @path.
	func (p *WidgetPath) IterRemoveRegion(pos int, name string)  {
var _arg0 *C.GtkWidgetPath // out
var _arg1 C.gint // out
var _arg2 *C.gchar // out

_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
_arg1 = (C.gint)(pos)
_arg2 = (*C.gchar)(C.CString(name))
defer C.free(unsafe.Pointer(_arg2))

C.gtk_widget_path_iter_remove_region(_arg0, _arg1, _arg2)
}
	
	// IterSetName sets the widget name for the widget found at position @pos in the
// widget hierarchy defined by @path.
	func (p *WidgetPath) IterSetName(pos int, name string)  {
var _arg0 *C.GtkWidgetPath // out
var _arg1 C.gint // out
var _arg2 *C.gchar // out

_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
_arg1 = (C.gint)(pos)
_arg2 = (*C.gchar)(C.CString(name))
defer C.free(unsafe.Pointer(_arg2))

C.gtk_widget_path_iter_set_name(_arg0, _arg1, _arg2)
}
	
	// IterSetObjectName sets the object name for a given position in the widget
// hierarchy defined by @path.
// 
// When set, the object name overrides the object type when matching CSS.
	func (p *WidgetPath) IterSetObjectName(pos int, name string)  {
var _arg0 *C.GtkWidgetPath // out
var _arg1 C.gint // out
var _arg2 *C.char // out

_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
_arg1 = (C.gint)(pos)
_arg2 = (*C.char)(C.CString(name))
defer C.free(unsafe.Pointer(_arg2))

C.gtk_widget_path_iter_set_object_name(_arg0, _arg1, _arg2)
}
	
	// IterSetObjectType sets the object type for a given position in the widget
// hierarchy defined by @path.
	func (p *WidgetPath) IterSetObjectType(pos int, typ externglib.Type)  {
var _arg0 *C.GtkWidgetPath // out
var _arg1 C.gint // out
var _arg2 C.GType // out

_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
_arg1 = (C.gint)(pos)
_arg2 = C.GType(typ)

C.gtk_widget_path_iter_set_object_type(_arg0, _arg1, _arg2)
}
	
	// IterSetState sets the widget name for the widget found at position @pos in
// the widget hierarchy defined by @path.
// 
// If you want to update just a single state flag, you need to do this manually,
// as this function updates all state flags.
// 
// Setting a flag
// 
//    gtk_widget_path_iter_set_state (path, pos, gtk_widget_path_iter_get_state (path, pos) & ~flag);
	func (p *WidgetPath) IterSetState(pos int, state StateFlags)  {
var _arg0 *C.GtkWidgetPath // out
var _arg1 C.gint // out
var _arg2 C.GtkStateFlags // out

_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
_arg1 = (C.gint)(pos)
_arg2 = (C.GtkStateFlags)(state)

C.gtk_widget_path_iter_set_state(_arg0, _arg1, _arg2)
}
	
	// Length returns the number of Widget #GTypes between the represented widget
// and its topmost container.
	func (p *WidgetPath) Length() int {
var _arg0 *C.GtkWidgetPath // out
var _cret C.gint // in

_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))

_cret = C.gtk_widget_path_length(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// PrependType prepends a widget type to the widget hierachy represented by
// @path.
	func (p *WidgetPath) PrependType(typ externglib.Type)  {
var _arg0 *C.GtkWidgetPath // out
var _arg1 C.GType // out

_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))
_arg1 = C.GType(typ)

C.gtk_widget_path_prepend_type(_arg0, _arg1)
}
	
	// Ref increments the reference count on @path.
	func (p *WidgetPath) Ref() *WidgetPath {
var _arg0 *C.GtkWidgetPath // out
var _cret *C.GtkWidgetPath // in

_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))

_cret = C.gtk_widget_path_ref(_arg0)


var _widgetPath *WidgetPath // out

_widgetPath = *(**WidgetPath)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_widgetPath, func(v *WidgetPath) {
  C.free(unsafe.Pointer(v.Native()))
})

return _widgetPath
}
	
	// String dumps the widget path into a string representation. It tries to match
// the CSS style as closely as possible (Note that there might be paths that
// cannot be represented in CSS).
// 
// The main use of this code is for debugging purposes, so that you can
// g_print() the path or dump it in a gdb session.
	func (p *WidgetPath) String() string {
var _arg0 *C.GtkWidgetPath // out
var _cret *C.char // in

_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))

_cret = C.gtk_widget_path_to_string(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// Unref decrements the reference count on @path, freeing the structure if the
// reference count reaches 0.
	func (p *WidgetPath) Unref()  {
var _arg0 *C.GtkWidgetPath // out

_arg0 = (*C.GtkWidgetPath)(unsafe.Pointer(p.Native()))

C.gtk_widget_path_unref(_arg0)
}
	


	
	type WindowGeometryInfo struct {
		Native C.GtkWindowGeometryInfo
	}

	

	

	

	// Native returns the underlying C source pointer.
	func (w *WindowGeometryInfo) Native() uintptr {
		return uintptr(unsafe.Pointer(&w.Native))
	}

	

	
