// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/internal/box"
	"github.com/diamondburned/gotk4/internal/gextras"
	"github.com/diamondburned/gotk4/pkg/cairo"
	"github.com/diamondburned/gotk4/pkg/gdk/v3"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config:
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <stdbool.h>
// #include <glib-object.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_icon_view_get_type()), F: marshalIconView},
	})
}

// IconViewForeachFunc: a function used by gtk_icon_view_selected_foreach() to
// map all selected rows. It will be called on every selected row in the view.
type IconViewForeachFunc func(iconView IconView, path *TreePath)

//export gotk4_IconViewForeachFunc
func gotk4_IconViewForeachFunc(arg0 *C.GtkIconView, arg1 *C.GtkTreePath, arg2 C.gpointer) {
	v := box.Get(uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	fn := v.(IconViewForeachFunc)
	fn(iconView, path, data)
}

// IconView provides an alternative view on a TreeModel. It displays the model
// as a grid of icons with labels. Like TreeView, it allows to select one or
// multiple items (depending on the selection mode, see
// gtk_icon_view_set_selection_mode()). In addition to selection with the arrow
// keys, IconView supports rubberband selection, which is controlled by dragging
// the pointer.
//
// Note that if the tree model is backed by an actual tree store (as opposed to
// a flat list where the mapping to icons is obvious), IconView will only
// display the first level of the tree and ignore the tree’s branches.
//
// CSS nodes
//
//    iconview.view
//    ╰── [rubberband]
//
// GtkIconView has a single CSS node with name iconview and style class .view.
// For rubberband selection, a subnode with name rubberband is used.
type IconView interface {
	Container
	Buildable
	CellLayout
	Scrollable

	// ConvertWidgetToBinWindowCoords converts widget coordinates to coordinates
	// for the bin_window, as expected by e.g. gtk_icon_view_get_path_at_pos().
	ConvertWidgetToBinWindowCoords(wx int, wy int) (bx int, by int)
	// CreateDragIcon creates a #cairo_surface_t representation of the item at
	// @path. This image is used for a drag icon.
	CreateDragIcon(path *TreePath) *cairo.Surface
	// ActivateOnSingleClick gets the setting set by
	// gtk_icon_view_set_activate_on_single_click().
	ActivateOnSingleClick() bool
	// CellRect fills the bounding rectangle in widget coordinates for the cell
	// specified by @path and @cell. If @cell is nil the main cell area is used.
	//
	// This function is only valid if @icon_view is realized.
	CellRect(path *TreePath, cell CellRenderer) (rect gdk.Rectangle, ok bool)
	// ColumnSpacing returns the value of the ::column-spacing property.
	ColumnSpacing() int
	// Columns returns the value of the ::columns property.
	Columns() int
	// Cursor fills in @path and @cell with the current cursor path and cell. If
	// the cursor isn’t currently set, then *@path will be nil. If no cell
	// currently has focus, then *@cell will be nil.
	//
	// The returned TreePath must be freed with gtk_tree_path_free().
	Cursor() (path *TreePath, cell CellRenderer, ok bool)
	// DestItemAtPos determines the destination item for a given position.
	DestItemAtPos(dragX int, dragY int) (path *TreePath, pos IconViewDropPosition, ok bool)
	// DragDestItem gets information about the item that is highlighted for
	// feedback.
	DragDestItem() (path *TreePath, pos IconViewDropPosition)
	// ItemAtPos finds the path at the point (@x, @y), relative to bin_window
	// coordinates. In contrast to gtk_icon_view_get_path_at_pos(), this
	// function also obtains the cell at the specified position. The returned
	// path should be freed with gtk_tree_path_free(). See
	// gtk_icon_view_convert_widget_to_bin_window_coords() for converting widget
	// coordinates to bin_window coordinates.
	ItemAtPos(x int, y int) (path *TreePath, cell CellRenderer, ok bool)
	// ItemColumn gets the column in which the item @path is currently
	// displayed. Column numbers start at 0.
	ItemColumn(path *TreePath) int
	// ItemOrientation returns the value of the ::item-orientation property
	// which determines whether the labels are drawn beside the icons instead of
	// below.
	ItemOrientation() Orientation
	// ItemPadding returns the value of the ::item-padding property.
	ItemPadding() int
	// ItemRow gets the row in which the item @path is currently displayed. Row
	// numbers start at 0.
	ItemRow(path *TreePath) int
	// ItemWidth returns the value of the ::item-width property.
	ItemWidth() int
	// Margin returns the value of the ::margin property.
	Margin() int
	// MarkupColumn returns the column with markup text for @icon_view.
	MarkupColumn() int
	// Model returns the model the IconView is based on. Returns nil if the
	// model is unset.
	Model() TreeModel
	// PathAtPos finds the path at the point (@x, @y), relative to bin_window
	// coordinates. See gtk_icon_view_get_item_at_pos(), if you are also
	// interested in the cell at the specified position. See
	// gtk_icon_view_convert_widget_to_bin_window_coords() for converting widget
	// coordinates to bin_window coordinates.
	PathAtPos(x int, y int) *TreePath
	// PixbufColumn returns the column with pixbufs for @icon_view.
	PixbufColumn() int
	// Reorderable retrieves whether the user can reorder the list via
	// drag-and-drop. See gtk_icon_view_set_reorderable().
	Reorderable() bool
	// RowSpacing returns the value of the ::row-spacing property.
	RowSpacing() int
	// SelectedItems creates a list of paths of all selected items.
	// Additionally, if you are planning on modifying the model after calling
	// this function, you may want to convert the returned list into a list of
	// TreeRowReferences. To do this, you can use gtk_tree_row_reference_new().
	//
	// To free the return value, use:
	//
	//    g_list_free_full (list, (GDestroyNotify) gtk_tree_path_free);
	SelectedItems() *glib.List
	// SelectionMode gets the selection mode of the @icon_view.
	SelectionMode() SelectionMode
	// Spacing returns the value of the ::spacing property.
	Spacing() int
	// TextColumn returns the column with text for @icon_view.
	TextColumn() int
	// TooltipColumn returns the column of @icon_view’s model which is being
	// used for displaying tooltips on @icon_view’s rows.
	TooltipColumn() int
	// TooltipContext: this function is supposed to be used in a
	// Widget::query-tooltip signal handler for IconView. The @x, @y and
	// @keyboard_tip values which are received in the signal handler, should be
	// passed to this function without modification.
	//
	// The return value indicates whether there is an icon view item at the
	// given coordinates (true) or not (false) for mouse tooltips. For keyboard
	// tooltips the item returned will be the cursor item. When true, then any
	// of @model, @path and @iter which have been provided will be set to point
	// to that row and the corresponding model. @x and @y will always be
	// converted to be relative to @icon_view’s bin_window if @keyboard_tooltip
	// is false.
	TooltipContext(x int, y int, keyboardTip bool) (model TreeModel, path *TreePath, iter TreeIter, ok bool)
	// VisibleRange sets @start_path and @end_path to be the first and last
	// visible path. Note that there may be invisible paths in between.
	//
	// Both paths should be freed with gtk_tree_path_free() after use.
	VisibleRange() (startPath *TreePath, endPath *TreePath, ok bool)
	// ItemActivated activates the item determined by @path.
	ItemActivated(path *TreePath)
	// PathIsSelected returns true if the icon pointed to by @path is currently
	// selected. If @path does not point to a valid location, false is returned.
	PathIsSelected(path *TreePath) bool
	// ScrollToPath moves the alignments of @icon_view to the position specified
	// by @path. @row_align determines where the row is placed, and @col_align
	// determines where @column is placed. Both are expected to be between 0.0
	// and 1.0. 0.0 means left/top alignment, 1.0 means right/bottom alignment,
	// 0.5 means center.
	//
	// If @use_align is false, then the alignment arguments are ignored, and the
	// tree does the minimum amount of work to scroll the item onto the screen.
	// This means that the item will be scrolled to the edge closest to its
	// current position. If the item is currently visible on the screen, nothing
	// is done.
	//
	// This function only works if the model is set, and @path is a valid row on
	// the model. If the model changes before the @icon_view is realized, the
	// centered path will be modified to reflect this change.
	ScrollToPath(path *TreePath, useAlign bool, rowAlign float32, colAlign float32)
	// SelectAll selects all the icons. @icon_view must has its selection mode
	// set to K_SELECTION_MULTIPLE.
	SelectAll()
	// SelectPath selects the row at @path.
	SelectPath(path *TreePath)
	// SelectedForeach calls a function for each selected icon. Note that the
	// model or selection cannot be modified from within this function.
	SelectedForeach(fn IconViewForeachFunc)
	// SetActivateOnSingleClick causes the IconView::item-activated signal to be
	// emitted on a single click instead of a double click.
	SetActivateOnSingleClick(single bool)
	// SetColumnSpacing sets the ::column-spacing property which specifies the
	// space which is inserted between the columns of the icon view.
	SetColumnSpacing(columnSpacing int)
	// SetColumns sets the ::columns property which determines in how many
	// columns the icons are arranged. If @columns is -1, the number of columns
	// will be chosen automatically to fill the available area.
	SetColumns(columns int)
	// SetCursor sets the current keyboard focus to be at @path, and selects it.
	// This is useful when you want to focus the user’s attention on a
	// particular item. If @cell is not nil, then focus is given to the cell
	// specified by it. Additionally, if @start_editing is true, then editing
	// should be started in the specified cell.
	//
	// This function is often followed by `gtk_widget_grab_focus (icon_view)` in
	// order to give keyboard focus to the widget. Please note that editing can
	// only happen when the widget is realized.
	SetCursor(path *TreePath, cell CellRenderer, startEditing bool)
	// SetDragDestItem sets the item that is highlighted for feedback.
	SetDragDestItem(path *TreePath, pos IconViewDropPosition)
	// SetItemOrientation sets the ::item-orientation property which determines
	// whether the labels are drawn beside the icons instead of below.
	SetItemOrientation(orientation Orientation)
	// SetItemPadding sets the IconView:item-padding property which specifies
	// the padding around each of the icon view’s items.
	SetItemPadding(itemPadding int)
	// SetItemWidth sets the ::item-width property which specifies the width to
	// use for each item. If it is set to -1, the icon view will automatically
	// determine a suitable item size.
	SetItemWidth(itemWidth int)
	// SetMargin sets the ::margin property which specifies the space which is
	// inserted at the top, bottom, left and right of the icon view.
	SetMargin(margin int)
	// SetMarkupColumn sets the column with markup information for @icon_view to
	// be @column. The markup column must be of type TYPE_STRING. If the markup
	// column is set to something, it overrides the text column set by
	// gtk_icon_view_set_text_column().
	SetMarkupColumn(column int)
	// SetModel sets the model for a IconView. If the @icon_view already has a
	// model set, it will remove it before setting the new model. If @model is
	// nil, then it will unset the old model.
	SetModel(model TreeModel)
	// SetPixbufColumn sets the column with pixbufs for @icon_view to be
	// @column. The pixbuf column must be of type K_TYPE_PIXBUF
	SetPixbufColumn(column int)
	// SetReorderable: this function is a convenience function to allow you to
	// reorder models that support the TreeDragSourceIface and the
	// TreeDragDestIface. Both TreeStore and ListStore support these. If
	// @reorderable is true, then the user can reorder the model by dragging and
	// dropping rows. The developer can listen to these changes by connecting to
	// the model's row_inserted and row_deleted signals. The reordering is
	// implemented by setting up the icon view as a drag source and destination.
	// Therefore, drag and drop can not be used in a reorderable view for any
	// other purpose.
	//
	// This function does not give you any degree of control over the order --
	// any reordering is allowed. If more control is needed, you should probably
	// handle drag and drop manually.
	SetReorderable(reorderable bool)
	// SetRowSpacing sets the ::row-spacing property which specifies the space
	// which is inserted between the rows of the icon view.
	SetRowSpacing(rowSpacing int)
	// SetSelectionMode sets the selection mode of the @icon_view.
	SetSelectionMode(mode SelectionMode)
	// SetSpacing sets the ::spacing property which specifies the space which is
	// inserted between the cells (i.e. the icon and the text) of an item.
	SetSpacing(spacing int)
	// SetTextColumn sets the column with text for @icon_view to be @column. The
	// text column must be of type TYPE_STRING.
	SetTextColumn(column int)
	// SetTooltipCell sets the tip area of @tooltip to the area which @cell
	// occupies in the item pointed to by @path. See also
	// gtk_tooltip_set_tip_area().
	//
	// See also gtk_icon_view_set_tooltip_column() for a simpler alternative.
	SetTooltipCell(tooltip Tooltip, path *TreePath, cell CellRenderer)
	// SetTooltipColumn: if you only plan to have simple (text-only) tooltips on
	// full items, you can use this function to have IconView handle these
	// automatically for you. @column should be set to the column in
	// @icon_view’s model containing the tooltip texts, or -1 to disable this
	// feature.
	//
	// When enabled, Widget:has-tooltip will be set to true and @icon_view will
	// connect a Widget::query-tooltip signal handler.
	//
	// Note that the signal handler sets the text with gtk_tooltip_set_markup(),
	// so &, <, etc have to be escaped in the text.
	SetTooltipColumn(column int)
	// SetTooltipItem sets the tip area of @tooltip to be the area covered by
	// the item at @path. See also gtk_icon_view_set_tooltip_column() for a
	// simpler alternative. See also gtk_tooltip_set_tip_area().
	SetTooltipItem(tooltip Tooltip, path *TreePath)
	// UnselectAll unselects all the icons.
	UnselectAll()
	// UnselectPath unselects the row at @path.
	UnselectPath(path *TreePath)
	// UnsetModelDragDest undoes the effect of
	// gtk_icon_view_enable_model_drag_dest(). Calling this method sets
	// IconView:reorderable to false.
	UnsetModelDragDest()
	// UnsetModelDragSource undoes the effect of
	// gtk_icon_view_enable_model_drag_source(). Calling this method sets
	// IconView:reorderable to false.
	UnsetModelDragSource()
}

// iconView implements the IconView interface.
type iconView struct {
	Container
	Buildable
	CellLayout
	Scrollable
}

var _ IconView = (*iconView)(nil)

// WrapIconView wraps a GObject to the right type. It is
// primarily used internally.
func WrapIconView(obj *externglib.Object) IconView {
	return IconView{
		Container:  WrapContainer(obj),
		Buildable:  WrapBuildable(obj),
		CellLayout: WrapCellLayout(obj),
		Scrollable: WrapScrollable(obj),
	}
}

func marshalIconView(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapIconView(obj), nil
}

// NewIconView constructs a class IconView.
func NewIconView() IconView {
	var cret C.GtkIconView
	var goret1 IconView

	cret = C.gtk_icon_view_new()

	goret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(IconView)

	return goret1
}

// NewIconViewWithArea constructs a class IconView.
func NewIconViewWithArea(area CellArea) IconView {
	var arg1 *C.GtkCellArea

	arg1 = (*C.GtkCellArea)(unsafe.Pointer(area.Native()))

	var cret C.GtkIconView
	var goret1 IconView

	cret = C.gtk_icon_view_new_with_area(area)

	goret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(IconView)

	return goret1
}

// NewIconViewWithModel constructs a class IconView.
func NewIconViewWithModel(model TreeModel) IconView {
	var arg1 *C.GtkTreeModel

	arg1 = (*C.GtkTreeModel)(unsafe.Pointer(model.Native()))

	var cret C.GtkIconView
	var goret1 IconView

	cret = C.gtk_icon_view_new_with_model(model)

	goret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(IconView)

	return goret1
}

// ConvertWidgetToBinWindowCoords converts widget coordinates to coordinates
// for the bin_window, as expected by e.g. gtk_icon_view_get_path_at_pos().
func (i iconView) ConvertWidgetToBinWindowCoords(wx int, wy int) (bx int, by int) {
	var arg0 *C.GtkIconView
	var arg1 C.gint
	var arg2 C.gint

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	arg1 = C.gint(wx)
	arg2 = C.gint(wy)

	var arg3 *C.gint
	var ret3 int
	var arg4 *C.gint
	var ret4 int

	C.gtk_icon_view_convert_widget_to_bin_window_coords(arg0, wx, wy, &arg3, &arg4)

	ret3 = *C.gint(arg3)
	ret4 = *C.gint(arg4)

	return ret3, ret4
}

// CreateDragIcon creates a #cairo_surface_t representation of the item at
// @path. This image is used for a drag icon.
func (i iconView) CreateDragIcon(path *TreePath) *cairo.Surface {
	var arg0 *C.GtkIconView
	var arg1 *C.GtkTreePath

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	var cret *C.cairo_surface_t
	var goret1 *cairo.Surface

	cret = C.gtk_icon_view_create_drag_icon(arg0, path)

	goret1 = cairo.WrapSurface(unsafe.Pointer(cret))
	runtime.SetFinalizer(goret1, func(v *cairo.Surface) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return goret1
}

// ActivateOnSingleClick gets the setting set by
// gtk_icon_view_set_activate_on_single_click().
func (i iconView) ActivateOnSingleClick() bool {
	var arg0 *C.GtkIconView

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	var cret C.gboolean
	var goret1 bool

	cret = C.gtk_icon_view_get_activate_on_single_click(arg0)

	goret1 = C.bool(cret) != C.false

	return goret1
}

// CellRect fills the bounding rectangle in widget coordinates for the cell
// specified by @path and @cell. If @cell is nil the main cell area is used.
//
// This function is only valid if @icon_view is realized.
func (i iconView) CellRect(path *TreePath, cell CellRenderer) (rect gdk.Rectangle, ok bool) {
	var arg0 *C.GtkIconView
	var arg1 *C.GtkTreePath
	var arg2 *C.GtkCellRenderer

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
	arg2 = (*C.GtkCellRenderer)(unsafe.Pointer(cell.Native()))

	var arg3 *C.GdkRectangle
	var ret3 *gdk.Rectangle
	var cret C.gboolean
	var goret2 bool

	cret = C.gtk_icon_view_get_cell_rect(arg0, path, cell, &arg3)

	ret3 = gdk.WrapRectangle(unsafe.Pointer(arg3))
	goret2 = C.bool(cret) != C.false

	return ret3, goret2
}

// ColumnSpacing returns the value of the ::column-spacing property.
func (i iconView) ColumnSpacing() int {
	var arg0 *C.GtkIconView

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	var cret C.gint
	var goret1 int

	cret = C.gtk_icon_view_get_column_spacing(arg0)

	goret1 = C.gint(cret)

	return goret1
}

// Columns returns the value of the ::columns property.
func (i iconView) Columns() int {
	var arg0 *C.GtkIconView

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	var cret C.gint
	var goret1 int

	cret = C.gtk_icon_view_get_columns(arg0)

	goret1 = C.gint(cret)

	return goret1
}

// Cursor fills in @path and @cell with the current cursor path and cell. If
// the cursor isn’t currently set, then *@path will be nil. If no cell
// currently has focus, then *@cell will be nil.
//
// The returned TreePath must be freed with gtk_tree_path_free().
func (i iconView) Cursor() (path *TreePath, cell CellRenderer, ok bool) {
	var arg0 *C.GtkIconView

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	var arg1 **C.GtkTreePath
	var ret1 **TreePath
	var arg2 **C.GtkCellRenderer
	var ret2 CellRenderer
	var cret C.gboolean
	var goret3 bool

	cret = C.gtk_icon_view_get_cursor(arg0, &arg1, &arg2)

	ret1 = WrapTreePath(unsafe.Pointer(arg1))
	runtime.SetFinalizer(ret1, func(v **TreePath) {
		C.free(unsafe.Pointer(v.Native()))
	})
	ret2 = gextras.CastObject(externglib.Take(unsafe.Pointer(arg2.Native()))).(CellRenderer)
	goret3 = C.bool(cret) != C.false

	return ret1, ret2, goret3
}

// DestItemAtPos determines the destination item for a given position.
func (i iconView) DestItemAtPos(dragX int, dragY int) (path *TreePath, pos IconViewDropPosition, ok bool) {
	var arg0 *C.GtkIconView
	var arg1 C.gint
	var arg2 C.gint

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	arg1 = C.gint(dragX)
	arg2 = C.gint(dragY)

	var arg3 **C.GtkTreePath
	var ret3 **TreePath
	var arg4 *C.GtkIconViewDropPosition
	var ret4 *IconViewDropPosition
	var cret C.gboolean
	var goret3 bool

	cret = C.gtk_icon_view_get_dest_item_at_pos(arg0, dragX, dragY, &arg3, &arg4)

	ret3 = WrapTreePath(unsafe.Pointer(arg3))
	runtime.SetFinalizer(ret3, func(v **TreePath) {
		C.free(unsafe.Pointer(v.Native()))
	})
	ret4 = *IconViewDropPosition(arg4)
	goret3 = C.bool(cret) != C.false

	return ret3, ret4, goret3
}

// DragDestItem gets information about the item that is highlighted for
// feedback.
func (i iconView) DragDestItem() (path *TreePath, pos IconViewDropPosition) {
	var arg0 *C.GtkIconView

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	var arg1 **C.GtkTreePath
	var ret1 **TreePath
	var arg2 *C.GtkIconViewDropPosition
	var ret2 *IconViewDropPosition

	C.gtk_icon_view_get_drag_dest_item(arg0, &arg1, &arg2)

	ret1 = WrapTreePath(unsafe.Pointer(arg1))
	runtime.SetFinalizer(ret1, func(v **TreePath) {
		C.free(unsafe.Pointer(v.Native()))
	})
	ret2 = *IconViewDropPosition(arg2)

	return ret1, ret2
}

// ItemAtPos finds the path at the point (@x, @y), relative to bin_window
// coordinates. In contrast to gtk_icon_view_get_path_at_pos(), this
// function also obtains the cell at the specified position. The returned
// path should be freed with gtk_tree_path_free(). See
// gtk_icon_view_convert_widget_to_bin_window_coords() for converting widget
// coordinates to bin_window coordinates.
func (i iconView) ItemAtPos(x int, y int) (path *TreePath, cell CellRenderer, ok bool) {
	var arg0 *C.GtkIconView
	var arg1 C.gint
	var arg2 C.gint

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	arg1 = C.gint(x)
	arg2 = C.gint(y)

	var arg3 **C.GtkTreePath
	var ret3 **TreePath
	var arg4 **C.GtkCellRenderer
	var ret4 CellRenderer
	var cret C.gboolean
	var goret3 bool

	cret = C.gtk_icon_view_get_item_at_pos(arg0, x, y, &arg3, &arg4)

	ret3 = WrapTreePath(unsafe.Pointer(arg3))
	runtime.SetFinalizer(ret3, func(v **TreePath) {
		C.free(unsafe.Pointer(v.Native()))
	})
	ret4 = gextras.CastObject(externglib.Take(unsafe.Pointer(arg4.Native()))).(CellRenderer)
	goret3 = C.bool(cret) != C.false

	return ret3, ret4, goret3
}

// ItemColumn gets the column in which the item @path is currently
// displayed. Column numbers start at 0.
func (i iconView) ItemColumn(path *TreePath) int {
	var arg0 *C.GtkIconView
	var arg1 *C.GtkTreePath

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	var cret C.gint
	var goret1 int

	cret = C.gtk_icon_view_get_item_column(arg0, path)

	goret1 = C.gint(cret)

	return goret1
}

// ItemOrientation returns the value of the ::item-orientation property
// which determines whether the labels are drawn beside the icons instead of
// below.
func (i iconView) ItemOrientation() Orientation {
	var arg0 *C.GtkIconView

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	var cret C.GtkOrientation
	var goret1 Orientation

	cret = C.gtk_icon_view_get_item_orientation(arg0)

	goret1 = Orientation(cret)

	return goret1
}

// ItemPadding returns the value of the ::item-padding property.
func (i iconView) ItemPadding() int {
	var arg0 *C.GtkIconView

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	var cret C.gint
	var goret1 int

	cret = C.gtk_icon_view_get_item_padding(arg0)

	goret1 = C.gint(cret)

	return goret1
}

// ItemRow gets the row in which the item @path is currently displayed. Row
// numbers start at 0.
func (i iconView) ItemRow(path *TreePath) int {
	var arg0 *C.GtkIconView
	var arg1 *C.GtkTreePath

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	var cret C.gint
	var goret1 int

	cret = C.gtk_icon_view_get_item_row(arg0, path)

	goret1 = C.gint(cret)

	return goret1
}

// ItemWidth returns the value of the ::item-width property.
func (i iconView) ItemWidth() int {
	var arg0 *C.GtkIconView

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	var cret C.gint
	var goret1 int

	cret = C.gtk_icon_view_get_item_width(arg0)

	goret1 = C.gint(cret)

	return goret1
}

// Margin returns the value of the ::margin property.
func (i iconView) Margin() int {
	var arg0 *C.GtkIconView

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	var cret C.gint
	var goret1 int

	cret = C.gtk_icon_view_get_margin(arg0)

	goret1 = C.gint(cret)

	return goret1
}

// MarkupColumn returns the column with markup text for @icon_view.
func (i iconView) MarkupColumn() int {
	var arg0 *C.GtkIconView

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	var cret C.gint
	var goret1 int

	cret = C.gtk_icon_view_get_markup_column(arg0)

	goret1 = C.gint(cret)

	return goret1
}

// Model returns the model the IconView is based on. Returns nil if the
// model is unset.
func (i iconView) Model() TreeModel {
	var arg0 *C.GtkIconView

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	var cret *C.GtkTreeModel
	var goret1 TreeModel

	cret = C.gtk_icon_view_get_model(arg0)

	goret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(TreeModel)

	return goret1
}

// PathAtPos finds the path at the point (@x, @y), relative to bin_window
// coordinates. See gtk_icon_view_get_item_at_pos(), if you are also
// interested in the cell at the specified position. See
// gtk_icon_view_convert_widget_to_bin_window_coords() for converting widget
// coordinates to bin_window coordinates.
func (i iconView) PathAtPos(x int, y int) *TreePath {
	var arg0 *C.GtkIconView
	var arg1 C.gint
	var arg2 C.gint

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	arg1 = C.gint(x)
	arg2 = C.gint(y)

	var cret *C.GtkTreePath
	var goret1 *TreePath

	cret = C.gtk_icon_view_get_path_at_pos(arg0, x, y)

	goret1 = WrapTreePath(unsafe.Pointer(cret))
	runtime.SetFinalizer(goret1, func(v *TreePath) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return goret1
}

// PixbufColumn returns the column with pixbufs for @icon_view.
func (i iconView) PixbufColumn() int {
	var arg0 *C.GtkIconView

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	var cret C.gint
	var goret1 int

	cret = C.gtk_icon_view_get_pixbuf_column(arg0)

	goret1 = C.gint(cret)

	return goret1
}

// Reorderable retrieves whether the user can reorder the list via
// drag-and-drop. See gtk_icon_view_set_reorderable().
func (i iconView) Reorderable() bool {
	var arg0 *C.GtkIconView

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	var cret C.gboolean
	var goret1 bool

	cret = C.gtk_icon_view_get_reorderable(arg0)

	goret1 = C.bool(cret) != C.false

	return goret1
}

// RowSpacing returns the value of the ::row-spacing property.
func (i iconView) RowSpacing() int {
	var arg0 *C.GtkIconView

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	var cret C.gint
	var goret1 int

	cret = C.gtk_icon_view_get_row_spacing(arg0)

	goret1 = C.gint(cret)

	return goret1
}

// SelectedItems creates a list of paths of all selected items.
// Additionally, if you are planning on modifying the model after calling
// this function, you may want to convert the returned list into a list of
// TreeRowReferences. To do this, you can use gtk_tree_row_reference_new().
//
// To free the return value, use:
//
//    g_list_free_full (list, (GDestroyNotify) gtk_tree_path_free);
func (i iconView) SelectedItems() *glib.List {
	var arg0 *C.GtkIconView

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	var cret *C.GList
	var goret1 *glib.List

	cret = C.gtk_icon_view_get_selected_items(arg0)

	goret1 = glib.WrapList(unsafe.Pointer(cret))
	runtime.SetFinalizer(goret1, func(v *glib.List) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return goret1
}

// SelectionMode gets the selection mode of the @icon_view.
func (i iconView) SelectionMode() SelectionMode {
	var arg0 *C.GtkIconView

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	var cret C.GtkSelectionMode
	var goret1 SelectionMode

	cret = C.gtk_icon_view_get_selection_mode(arg0)

	goret1 = SelectionMode(cret)

	return goret1
}

// Spacing returns the value of the ::spacing property.
func (i iconView) Spacing() int {
	var arg0 *C.GtkIconView

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	var cret C.gint
	var goret1 int

	cret = C.gtk_icon_view_get_spacing(arg0)

	goret1 = C.gint(cret)

	return goret1
}

// TextColumn returns the column with text for @icon_view.
func (i iconView) TextColumn() int {
	var arg0 *C.GtkIconView

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	var cret C.gint
	var goret1 int

	cret = C.gtk_icon_view_get_text_column(arg0)

	goret1 = C.gint(cret)

	return goret1
}

// TooltipColumn returns the column of @icon_view’s model which is being
// used for displaying tooltips on @icon_view’s rows.
func (i iconView) TooltipColumn() int {
	var arg0 *C.GtkIconView

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	var cret C.gint
	var goret1 int

	cret = C.gtk_icon_view_get_tooltip_column(arg0)

	goret1 = C.gint(cret)

	return goret1
}

// TooltipContext: this function is supposed to be used in a
// Widget::query-tooltip signal handler for IconView. The @x, @y and
// @keyboard_tip values which are received in the signal handler, should be
// passed to this function without modification.
//
// The return value indicates whether there is an icon view item at the
// given coordinates (true) or not (false) for mouse tooltips. For keyboard
// tooltips the item returned will be the cursor item. When true, then any
// of @model, @path and @iter which have been provided will be set to point
// to that row and the corresponding model. @x and @y will always be
// converted to be relative to @icon_view’s bin_window if @keyboard_tooltip
// is false.
func (i iconView) TooltipContext(x int, y int, keyboardTip bool) (model TreeModel, path *TreePath, iter TreeIter, ok bool) {
	var arg0 *C.GtkIconView
	var arg1 *C.gint
	var arg2 *C.gint
	var arg3 C.gboolean

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	arg1 = *C.gint(x)
	arg2 = *C.gint(y)
	if keyboardTip {
		arg3 = C.gboolean(1)
	}

	var arg4 **C.GtkTreeModel
	var ret4 *TreeModel
	var arg5 **C.GtkTreePath
	var ret5 **TreePath
	var arg6 *C.GtkTreeIter
	var ret6 *TreeIter
	var cret C.gboolean
	var goret4 bool

	cret = C.gtk_icon_view_get_tooltip_context(arg0, x, y, keyboardTip, &arg4, &arg5, &arg6)

	ret4 = gextras.CastObject(externglib.Take(unsafe.Pointer(arg4.Native()))).(*TreeModel)
	ret5 = WrapTreePath(unsafe.Pointer(arg5))
	runtime.SetFinalizer(ret5, func(v **TreePath) {
		C.free(unsafe.Pointer(v.Native()))
	})
	ret6 = WrapTreeIter(unsafe.Pointer(arg6))
	goret4 = C.bool(cret) != C.false

	return ret4, ret5, ret6, goret4
}

// VisibleRange sets @start_path and @end_path to be the first and last
// visible path. Note that there may be invisible paths in between.
//
// Both paths should be freed with gtk_tree_path_free() after use.
func (i iconView) VisibleRange() (startPath *TreePath, endPath *TreePath, ok bool) {
	var arg0 *C.GtkIconView

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	var arg1 **C.GtkTreePath
	var ret1 **TreePath
	var arg2 **C.GtkTreePath
	var ret2 **TreePath
	var cret C.gboolean
	var goret3 bool

	cret = C.gtk_icon_view_get_visible_range(arg0, &arg1, &arg2)

	ret1 = WrapTreePath(unsafe.Pointer(arg1))
	runtime.SetFinalizer(ret1, func(v **TreePath) {
		C.free(unsafe.Pointer(v.Native()))
	})
	ret2 = WrapTreePath(unsafe.Pointer(arg2))
	runtime.SetFinalizer(ret2, func(v **TreePath) {
		C.free(unsafe.Pointer(v.Native()))
	})
	goret3 = C.bool(cret) != C.false

	return ret1, ret2, goret3
}

// ItemActivated activates the item determined by @path.
func (i iconView) ItemActivated(path *TreePath) {
	var arg0 *C.GtkIconView
	var arg1 *C.GtkTreePath

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	C.gtk_icon_view_item_activated(arg0, path)
}

// PathIsSelected returns true if the icon pointed to by @path is currently
// selected. If @path does not point to a valid location, false is returned.
func (i iconView) PathIsSelected(path *TreePath) bool {
	var arg0 *C.GtkIconView
	var arg1 *C.GtkTreePath

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	var cret C.gboolean
	var goret1 bool

	cret = C.gtk_icon_view_path_is_selected(arg0, path)

	goret1 = C.bool(cret) != C.false

	return goret1
}

// ScrollToPath moves the alignments of @icon_view to the position specified
// by @path. @row_align determines where the row is placed, and @col_align
// determines where @column is placed. Both are expected to be between 0.0
// and 1.0. 0.0 means left/top alignment, 1.0 means right/bottom alignment,
// 0.5 means center.
//
// If @use_align is false, then the alignment arguments are ignored, and the
// tree does the minimum amount of work to scroll the item onto the screen.
// This means that the item will be scrolled to the edge closest to its
// current position. If the item is currently visible on the screen, nothing
// is done.
//
// This function only works if the model is set, and @path is a valid row on
// the model. If the model changes before the @icon_view is realized, the
// centered path will be modified to reflect this change.
func (i iconView) ScrollToPath(path *TreePath, useAlign bool, rowAlign float32, colAlign float32) {
	var arg0 *C.GtkIconView
	var arg1 *C.GtkTreePath
	var arg2 C.gboolean
	var arg3 C.gfloat
	var arg4 C.gfloat

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
	if useAlign {
		arg2 = C.gboolean(1)
	}
	arg3 = C.gfloat(rowAlign)
	arg4 = C.gfloat(colAlign)

	C.gtk_icon_view_scroll_to_path(arg0, path, useAlign, rowAlign, colAlign)
}

// SelectAll selects all the icons. @icon_view must has its selection mode
// set to K_SELECTION_MULTIPLE.
func (i iconView) SelectAll() {
	var arg0 *C.GtkIconView

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	C.gtk_icon_view_select_all(arg0)
}

// SelectPath selects the row at @path.
func (i iconView) SelectPath(path *TreePath) {
	var arg0 *C.GtkIconView
	var arg1 *C.GtkTreePath

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	C.gtk_icon_view_select_path(arg0, path)
}

// SelectedForeach calls a function for each selected icon. Note that the
// model or selection cannot be modified from within this function.
func (i iconView) SelectedForeach(fn IconViewForeachFunc) {
	var arg0 *C.GtkIconView

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	C.gtk_icon_view_selected_foreach(arg0, fn, data)
}

// SetActivateOnSingleClick causes the IconView::item-activated signal to be
// emitted on a single click instead of a double click.
func (i iconView) SetActivateOnSingleClick(single bool) {
	var arg0 *C.GtkIconView
	var arg1 C.gboolean

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	if single {
		arg1 = C.gboolean(1)
	}

	C.gtk_icon_view_set_activate_on_single_click(arg0, single)
}

// SetColumnSpacing sets the ::column-spacing property which specifies the
// space which is inserted between the columns of the icon view.
func (i iconView) SetColumnSpacing(columnSpacing int) {
	var arg0 *C.GtkIconView
	var arg1 C.gint

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	arg1 = C.gint(columnSpacing)

	C.gtk_icon_view_set_column_spacing(arg0, columnSpacing)
}

// SetColumns sets the ::columns property which determines in how many
// columns the icons are arranged. If @columns is -1, the number of columns
// will be chosen automatically to fill the available area.
func (i iconView) SetColumns(columns int) {
	var arg0 *C.GtkIconView
	var arg1 C.gint

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	arg1 = C.gint(columns)

	C.gtk_icon_view_set_columns(arg0, columns)
}

// SetCursor sets the current keyboard focus to be at @path, and selects it.
// This is useful when you want to focus the user’s attention on a
// particular item. If @cell is not nil, then focus is given to the cell
// specified by it. Additionally, if @start_editing is true, then editing
// should be started in the specified cell.
//
// This function is often followed by `gtk_widget_grab_focus (icon_view)` in
// order to give keyboard focus to the widget. Please note that editing can
// only happen when the widget is realized.
func (i iconView) SetCursor(path *TreePath, cell CellRenderer, startEditing bool) {
	var arg0 *C.GtkIconView
	var arg1 *C.GtkTreePath
	var arg2 *C.GtkCellRenderer
	var arg3 C.gboolean

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
	arg2 = (*C.GtkCellRenderer)(unsafe.Pointer(cell.Native()))
	if startEditing {
		arg3 = C.gboolean(1)
	}

	C.gtk_icon_view_set_cursor(arg0, path, cell, startEditing)
}

// SetDragDestItem sets the item that is highlighted for feedback.
func (i iconView) SetDragDestItem(path *TreePath, pos IconViewDropPosition) {
	var arg0 *C.GtkIconView
	var arg1 *C.GtkTreePath
	var arg2 C.GtkIconViewDropPosition

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
	arg2 = (C.GtkIconViewDropPosition)(pos)

	C.gtk_icon_view_set_drag_dest_item(arg0, path, pos)
}

// SetItemOrientation sets the ::item-orientation property which determines
// whether the labels are drawn beside the icons instead of below.
func (i iconView) SetItemOrientation(orientation Orientation) {
	var arg0 *C.GtkIconView
	var arg1 C.GtkOrientation

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	arg1 = (C.GtkOrientation)(orientation)

	C.gtk_icon_view_set_item_orientation(arg0, orientation)
}

// SetItemPadding sets the IconView:item-padding property which specifies
// the padding around each of the icon view’s items.
func (i iconView) SetItemPadding(itemPadding int) {
	var arg0 *C.GtkIconView
	var arg1 C.gint

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	arg1 = C.gint(itemPadding)

	C.gtk_icon_view_set_item_padding(arg0, itemPadding)
}

// SetItemWidth sets the ::item-width property which specifies the width to
// use for each item. If it is set to -1, the icon view will automatically
// determine a suitable item size.
func (i iconView) SetItemWidth(itemWidth int) {
	var arg0 *C.GtkIconView
	var arg1 C.gint

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	arg1 = C.gint(itemWidth)

	C.gtk_icon_view_set_item_width(arg0, itemWidth)
}

// SetMargin sets the ::margin property which specifies the space which is
// inserted at the top, bottom, left and right of the icon view.
func (i iconView) SetMargin(margin int) {
	var arg0 *C.GtkIconView
	var arg1 C.gint

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	arg1 = C.gint(margin)

	C.gtk_icon_view_set_margin(arg0, margin)
}

// SetMarkupColumn sets the column with markup information for @icon_view to
// be @column. The markup column must be of type TYPE_STRING. If the markup
// column is set to something, it overrides the text column set by
// gtk_icon_view_set_text_column().
func (i iconView) SetMarkupColumn(column int) {
	var arg0 *C.GtkIconView
	var arg1 C.gint

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	arg1 = C.gint(column)

	C.gtk_icon_view_set_markup_column(arg0, column)
}

// SetModel sets the model for a IconView. If the @icon_view already has a
// model set, it will remove it before setting the new model. If @model is
// nil, then it will unset the old model.
func (i iconView) SetModel(model TreeModel) {
	var arg0 *C.GtkIconView
	var arg1 *C.GtkTreeModel

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	arg1 = (*C.GtkTreeModel)(unsafe.Pointer(model.Native()))

	C.gtk_icon_view_set_model(arg0, model)
}

// SetPixbufColumn sets the column with pixbufs for @icon_view to be
// @column. The pixbuf column must be of type K_TYPE_PIXBUF
func (i iconView) SetPixbufColumn(column int) {
	var arg0 *C.GtkIconView
	var arg1 C.gint

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	arg1 = C.gint(column)

	C.gtk_icon_view_set_pixbuf_column(arg0, column)
}

// SetReorderable: this function is a convenience function to allow you to
// reorder models that support the TreeDragSourceIface and the
// TreeDragDestIface. Both TreeStore and ListStore support these. If
// @reorderable is true, then the user can reorder the model by dragging and
// dropping rows. The developer can listen to these changes by connecting to
// the model's row_inserted and row_deleted signals. The reordering is
// implemented by setting up the icon view as a drag source and destination.
// Therefore, drag and drop can not be used in a reorderable view for any
// other purpose.
//
// This function does not give you any degree of control over the order --
// any reordering is allowed. If more control is needed, you should probably
// handle drag and drop manually.
func (i iconView) SetReorderable(reorderable bool) {
	var arg0 *C.GtkIconView
	var arg1 C.gboolean

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	if reorderable {
		arg1 = C.gboolean(1)
	}

	C.gtk_icon_view_set_reorderable(arg0, reorderable)
}

// SetRowSpacing sets the ::row-spacing property which specifies the space
// which is inserted between the rows of the icon view.
func (i iconView) SetRowSpacing(rowSpacing int) {
	var arg0 *C.GtkIconView
	var arg1 C.gint

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	arg1 = C.gint(rowSpacing)

	C.gtk_icon_view_set_row_spacing(arg0, rowSpacing)
}

// SetSelectionMode sets the selection mode of the @icon_view.
func (i iconView) SetSelectionMode(mode SelectionMode) {
	var arg0 *C.GtkIconView
	var arg1 C.GtkSelectionMode

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	arg1 = (C.GtkSelectionMode)(mode)

	C.gtk_icon_view_set_selection_mode(arg0, mode)
}

// SetSpacing sets the ::spacing property which specifies the space which is
// inserted between the cells (i.e. the icon and the text) of an item.
func (i iconView) SetSpacing(spacing int) {
	var arg0 *C.GtkIconView
	var arg1 C.gint

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	arg1 = C.gint(spacing)

	C.gtk_icon_view_set_spacing(arg0, spacing)
}

// SetTextColumn sets the column with text for @icon_view to be @column. The
// text column must be of type TYPE_STRING.
func (i iconView) SetTextColumn(column int) {
	var arg0 *C.GtkIconView
	var arg1 C.gint

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	arg1 = C.gint(column)

	C.gtk_icon_view_set_text_column(arg0, column)
}

// SetTooltipCell sets the tip area of @tooltip to the area which @cell
// occupies in the item pointed to by @path. See also
// gtk_tooltip_set_tip_area().
//
// See also gtk_icon_view_set_tooltip_column() for a simpler alternative.
func (i iconView) SetTooltipCell(tooltip Tooltip, path *TreePath, cell CellRenderer) {
	var arg0 *C.GtkIconView
	var arg1 *C.GtkTooltip
	var arg2 *C.GtkTreePath
	var arg3 *C.GtkCellRenderer

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	arg1 = (*C.GtkTooltip)(unsafe.Pointer(tooltip.Native()))
	arg2 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
	arg3 = (*C.GtkCellRenderer)(unsafe.Pointer(cell.Native()))

	C.gtk_icon_view_set_tooltip_cell(arg0, tooltip, path, cell)
}

// SetTooltipColumn: if you only plan to have simple (text-only) tooltips on
// full items, you can use this function to have IconView handle these
// automatically for you. @column should be set to the column in
// @icon_view’s model containing the tooltip texts, or -1 to disable this
// feature.
//
// When enabled, Widget:has-tooltip will be set to true and @icon_view will
// connect a Widget::query-tooltip signal handler.
//
// Note that the signal handler sets the text with gtk_tooltip_set_markup(),
// so &, <, etc have to be escaped in the text.
func (i iconView) SetTooltipColumn(column int) {
	var arg0 *C.GtkIconView
	var arg1 C.gint

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	arg1 = C.gint(column)

	C.gtk_icon_view_set_tooltip_column(arg0, column)
}

// SetTooltipItem sets the tip area of @tooltip to be the area covered by
// the item at @path. See also gtk_icon_view_set_tooltip_column() for a
// simpler alternative. See also gtk_tooltip_set_tip_area().
func (i iconView) SetTooltipItem(tooltip Tooltip, path *TreePath) {
	var arg0 *C.GtkIconView
	var arg1 *C.GtkTooltip
	var arg2 *C.GtkTreePath

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	arg1 = (*C.GtkTooltip)(unsafe.Pointer(tooltip.Native()))
	arg2 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	C.gtk_icon_view_set_tooltip_item(arg0, tooltip, path)
}

// UnselectAll unselects all the icons.
func (i iconView) UnselectAll() {
	var arg0 *C.GtkIconView

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	C.gtk_icon_view_unselect_all(arg0)
}

// UnselectPath unselects the row at @path.
func (i iconView) UnselectPath(path *TreePath) {
	var arg0 *C.GtkIconView
	var arg1 *C.GtkTreePath

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	C.gtk_icon_view_unselect_path(arg0, path)
}

// UnsetModelDragDest undoes the effect of
// gtk_icon_view_enable_model_drag_dest(). Calling this method sets
// IconView:reorderable to false.
func (i iconView) UnsetModelDragDest() {
	var arg0 *C.GtkIconView

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	C.gtk_icon_view_unset_model_drag_dest(arg0)
}

// UnsetModelDragSource undoes the effect of
// gtk_icon_view_enable_model_drag_source(). Calling this method sets
// IconView:reorderable to false.
func (i iconView) UnsetModelDragSource() {
	var arg0 *C.GtkIconView

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	C.gtk_icon_view_unset_model_drag_source(arg0)
}

type IconViewPrivate struct {
	native C.GtkIconViewPrivate
}

// WrapIconViewPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapIconViewPrivate(ptr unsafe.Pointer) *IconViewPrivate {
	if ptr == nil {
		return nil
	}

	return (*IconViewPrivate)(ptr)
}

func marshalIconViewPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapIconViewPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (i *IconViewPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&i.native)
}
