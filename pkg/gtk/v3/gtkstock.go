// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"reflect"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/internal/box"
	"github.com/diamondburned/gotk4/pkg/gdk/v3"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #cgo pkg-config: gtk+-3.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <stdbool.h>
// #include <glib-object.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
//
// extern gchar* gotk4_TranslateFunc(const gchar* _0, gpointer _1);
// extern void callbackDelete(gpointer);
import "C"

//export callbackDelete
func callbackDelete(ptr C.gpointer) {
	box.Delete(box.Callback, uintptr(ptr))
}

type Stock string

// TranslateFunc: the function used to translate messages in e.g. IconFactory
// and ActionGroup.
type TranslateFunc func(path string) string

//export gotk4_TranslateFunc
func gotk4_TranslateFunc(arg0 *C.gchar, arg1 C.gpointer) *C.gchar {
	v := box.Get(uintptr(arg1))
	if v == nil {
		panic(`callback not found`)
	}

	var path string

	path = C.GoString(arg0)

	utf8 := v.(TranslateFunc)(path)
}

// StockAdd registers each of the stock items in @items. If an item already
// exists with the same stock ID as one of the @items, the old item gets
// replaced. The stock items are copied, so GTK+ does not hold any pointer into
// @items and @items can be freed. Use gtk_stock_add_static() if @items is
// persistent and GTK+ need not copy the array.
func StockAdd(items []StockItem) {
	var arg1 *C.GtkStockItem
	var arg2 C.guint

	{
		var dst []C.GtkStockItem
		ptr := C.malloc(C.sizeof_GtkStockItem * len(items))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(items)
		sliceHeader.Cap = len(items)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(items); i++ {
			src := items[i]
			dst[i] = (C.GtkStockItem)(src.Native())
		}

		arg1 = (*C.GtkStockItem)(unsafe.Pointer(ptr))
		arg2 = len(items)
	}

	C.gtk_stock_add(arg1, arg2)
}

// StockAddStatic: same as gtk_stock_add(), but doesnâ€™t copy @items, so @items
// must persist until application exit.
func StockAddStatic(items []StockItem) {
	var arg1 *C.GtkStockItem
	var arg2 C.guint

	{
		var dst []C.GtkStockItem
		ptr := C.malloc(C.sizeof_GtkStockItem * len(items))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(items)
		sliceHeader.Cap = len(items)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(items); i++ {
			src := items[i]
			dst[i] = (C.GtkStockItem)(src.Native())
		}

		arg1 = (*C.GtkStockItem)(unsafe.Pointer(ptr))
		arg2 = len(items)
	}

	C.gtk_stock_add_static(arg1, arg2)
}

// StockListIds retrieves a list of all known stock IDs added to a IconFactory
// or registered with gtk_stock_add(). The list must be freed with
// g_slist_free(), and each string in the list must be freed with g_free().
func StockListIds() *glib.SList {
	ret := C.gtk_stock_list_ids()

	var ret0 *glib.SList

	{
		ret0 = glib.WrapSList(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *glib.SList) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// StockLookup fills @item with the registered values for @stock_id, returning
// true if @stock_id was known.
func StockLookup(stockID string) (item StockItem, ok bool) {
	var arg1 *C.gchar
	var arg2 *C.GtkStockItem // out

	arg1 = (*C.gchar)(C.CString(stockID))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_stock_lookup(arg1, &arg2)

	var ret0 *StockItem
	var ret1 bool

	{
		ret0 = WrapStockItem(unsafe.Pointer(arg2))
	}

	ret1 = C.bool(ret) != 0

	return ret0, ret1
}

// StockSetTranslateFunc sets a function to be used for translating the @label
// of a stock item.
//
// If no function is registered for a translation domain, g_dgettext() is used.
//
// The function is used for all stock items whose @translation_domain matches
// @domain. Note that it is possible to use strings different from the actual
// gettext translation domain of your application for this, as long as your
// TranslateFunc uses the correct domain when calling dgettext(). This can be
// useful, e.g. when dealing with message contexts:
//
//    GtkStockItem items[] = {
//     { MY_ITEM1, NC_("odd items", "Item 1"), 0, 0, "odd-item-domain" },
//     { MY_ITEM2, NC_("even items", "Item 2"), 0, 0, "even-item-domain" },
//    };
//
//    gchar *
//    my_translate_func (const gchar *msgid,
//                       gpointer     data)
//    {
//      gchar *msgctxt = data;
//
//      return (gchar*)g_dpgettext2 (GETTEXT_PACKAGE, msgctxt, msgid);
//    }
//
//    ...
//
//    gtk_stock_add (items, G_N_ELEMENTS (items));
//    gtk_stock_set_translate_func ("odd-item-domain", my_translate_func, "odd items");
//    gtk_stock_set_translate_func ("even-item-domain", my_translate_func, "even items");
func StockSetTranslateFunc(domain string, fn TranslateFunc) {
	var arg1 *C.gchar
	var arg2 C.GtkTranslateFunc
	var arg3 C.gpointer
	var arg4 C.GDestroyNotify

	arg1 = (*C.gchar)(C.CString(domain))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*[0]byte)(C.gotk4_TranslateFunc)
	arg3 = C.gpointer(box.Assign(fn))
	arg4 = (*[0]byte)(C.callbackDelete)

	C.gtk_stock_set_translate_func(arg1, arg2, arg3, arg4)
}

type StockItem struct {
	native C.GtkStockItem
}

// WrapStockItem wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapStockItem(ptr unsafe.Pointer) *StockItem {
	if ptr == nil {
		return nil
	}

	return (*StockItem)(ptr)
}

func marshalStockItem(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapStockItem(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (s *StockItem) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

// StockID gets the field inside the struct.
func (s *StockItem) StockID() string {
	var ret string
	ret = C.GoString(s.native.stock_id)
	return ret
}

// Label gets the field inside the struct.
func (s *StockItem) Label() string {
	var ret string
	ret = C.GoString(s.native.label)
	return ret
}

// Modifier gets the field inside the struct.
func (s *StockItem) Modifier() gdk.ModifierType {
	var ret gdk.ModifierType
	ret = gdk.ModifierType(s.native.modifier)
	return ret
}

// Keyval gets the field inside the struct.
func (s *StockItem) Keyval() uint {
	var ret uint
	ret = uint(s.native.keyval)
	return ret
}

// TranslationDomain gets the field inside the struct.
func (s *StockItem) TranslationDomain() string {
	var ret string
	ret = C.GoString(s.native.translation_domain)
	return ret
}

// Copy copies a stock item, mostly useful for language bindings and not in
// applications.
func (i *StockItem) Copy() *StockItem {
	var arg0 *C.GtkStockItem

	arg0 = (*C.GtkStockItem)(i.Native())

	ret := C.gtk_stock_item_copy(arg0)

	var ret0 *StockItem

	{
		ret0 = WrapStockItem(unsafe.Pointer(ret))
	}

	return ret0
}

// Free frees a stock item allocated on the heap, such as one returned by
// gtk_stock_item_copy(). Also frees the fields inside the stock item, if they
// are not nil.
func (i *StockItem) Free() {
	var arg0 *C.GtkStockItem

	arg0 = (*C.GtkStockItem)(i.Native())

	C.gtk_stock_item_free(arg0)
}
