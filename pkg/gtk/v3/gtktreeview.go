// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"unsafe"

	"github.com/diamondburned/gotk4/internal/box"
	"github.com/diamondburned/gotk4/internal/gextras"
)

// #cgo pkg-config: gtk+-3.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
//
// void gotk4_TreeDestroyCountFunc(GtkTreeView*, GtkTreePath*, gint, gpointer);
// gboolean gotk4_TreeViewColumnDropFunc(GtkTreeView*, GtkTreeViewColumn*, GtkTreeViewColumn*, GtkTreeViewColumn*, gpointer);
// void gotk4_TreeViewMappingFunc(GtkTreeView*, GtkTreePath*, gpointer);
// gboolean gotk4_TreeViewRowSeparatorFunc(GtkTreeModel*, GtkTreeIter*, gpointer);
// gboolean gotk4_TreeViewSearchEqualFunc(GtkTreeModel*, gint,  gchar*, GtkTreeIter*, gpointer);
// void gotk4_TreeViewSearchPositionFunc(GtkTreeView*, GtkWidget*, gpointer);
import "C"

type TreeDestroyCountFunc func(treeView TreeView, path *TreePath, children int)

//export gotk4_TreeDestroyCountFunc
func gotk4_TreeDestroyCountFunc(arg0 *C.GtkTreeView, arg1 *C.GtkTreePath, arg2 C.gint, arg3 C.gpointer) {
	v := box.Get(uintptr(arg3))
	if v == nil {
		panic(`callback not found`)
	}

	var treeView TreeView
	var path *TreePath
	var children int

	treeView = gextras.CastObject(externglib.Take(unsafe.Pointer(arg0.Native()))).(TreeView)

	{
		path = WrapTreePath(unsafe.Pointer(arg1))
	}

	children = int(arg2)

	v.(TreeDestroyCountFunc)(treeView, path, children)
}

// TreeViewColumnDropFunc: function type for determining whether @column can be
// dropped in a particular spot (as determined by @prev_column and
// @next_column). In left to right locales, @prev_column is on the left of the
// potential drop spot, and @next_column is on the right. In right to left mode,
// this is reversed. This function should return true if the spot is a valid
// drop spot. Please note that returning true does not actually indicate that
// the column drop was made, but is meant only to indicate a possible drop spot
// to the user.
type TreeViewColumnDropFunc func(treeView TreeView, column TreeViewColumn, prevColumn TreeViewColumn, nextColumn TreeViewColumn) bool

//export gotk4_TreeViewColumnDropFunc
func gotk4_TreeViewColumnDropFunc(arg0 *C.GtkTreeView, arg1 *C.GtkTreeViewColumn, arg2 *C.GtkTreeViewColumn, arg3 *C.GtkTreeViewColumn, arg4 C.gpointer) C.gboolean {
	v := box.Get(uintptr(arg4))
	if v == nil {
		panic(`callback not found`)
	}

	var treeView TreeView
	var column TreeViewColumn
	var prevColumn TreeViewColumn
	var nextColumn TreeViewColumn

	treeView = gextras.CastObject(externglib.Take(unsafe.Pointer(arg0.Native()))).(TreeView)

	column = gextras.CastObject(externglib.Take(unsafe.Pointer(arg1.Native()))).(TreeViewColumn)

	prevColumn = gextras.CastObject(externglib.Take(unsafe.Pointer(arg2.Native()))).(TreeViewColumn)

	nextColumn = gextras.CastObject(externglib.Take(unsafe.Pointer(arg3.Native()))).(TreeViewColumn)

	ok := v.(TreeViewColumnDropFunc)(treeView, column, prevColumn, nextColumn)
}

// TreeViewMappingFunc: function used for gtk_tree_view_map_expanded_rows().
type TreeViewMappingFunc func(treeView TreeView, path *TreePath)

//export gotk4_TreeViewMappingFunc
func gotk4_TreeViewMappingFunc(arg0 *C.GtkTreeView, arg1 *C.GtkTreePath, arg2 C.gpointer) {
	v := box.Get(uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var treeView TreeView
	var path *TreePath

	treeView = gextras.CastObject(externglib.Take(unsafe.Pointer(arg0.Native()))).(TreeView)

	{
		path = WrapTreePath(unsafe.Pointer(arg1))
	}

	v.(TreeViewMappingFunc)(treeView, path)
}

// TreeViewRowSeparatorFunc: function type for determining whether the row
// pointed to by @iter should be rendered as a separator. A common way to
// implement this is to have a boolean column in the model, whose values the
// TreeViewRowSeparatorFunc returns.
type TreeViewRowSeparatorFunc func(model TreeModel, iter *TreeIter) bool

//export gotk4_TreeViewRowSeparatorFunc
func gotk4_TreeViewRowSeparatorFunc(arg0 *C.GtkTreeModel, arg1 *C.GtkTreeIter, arg2 C.gpointer) C.gboolean {
	v := box.Get(uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var model TreeModel
	var iter *TreeIter

	model = gextras.CastObject(externglib.Take(unsafe.Pointer(arg0.Native()))).(TreeModel)

	{
		iter = WrapTreeIter(unsafe.Pointer(arg1))
	}

	ok := v.(TreeViewRowSeparatorFunc)(model, iter)
}

// TreeViewSearchEqualFunc: a function used for checking whether a row in @model
// matches a search key string entered by the user. Note the return value is
// reversed from what you would normally expect, though it has some similarity
// to strcmp() returning 0 for equal strings.
type TreeViewSearchEqualFunc func(model TreeModel, column int, key string, iter *TreeIter) bool

//export gotk4_TreeViewSearchEqualFunc
func gotk4_TreeViewSearchEqualFunc(arg0 *C.GtkTreeModel, arg1 C.gint, arg2 *C.gchar, arg3 *C.GtkTreeIter, arg4 C.gpointer) C.gboolean {
	v := box.Get(uintptr(arg4))
	if v == nil {
		panic(`callback not found`)
	}

	var model TreeModel
	var column int
	var key string
	var iter *TreeIter

	model = gextras.CastObject(externglib.Take(unsafe.Pointer(arg0.Native()))).(TreeModel)

	column = int(arg1)

	key = C.GoString(arg2)

	{
		iter = WrapTreeIter(unsafe.Pointer(arg3))
	}

	ok := v.(TreeViewSearchEqualFunc)(model, column, key, iter)
}

type TreeViewSearchPositionFunc func(treeView TreeView, searchDialog Widget)

//export gotk4_TreeViewSearchPositionFunc
func gotk4_TreeViewSearchPositionFunc(arg0 *C.GtkTreeView, arg1 *C.GtkWidget, arg2 C.gpointer) {
	v := box.Get(uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var treeView TreeView
	var searchDialog Widget

	treeView = gextras.CastObject(externglib.Take(unsafe.Pointer(arg0.Native()))).(TreeView)

	searchDialog = gextras.CastObject(externglib.Take(unsafe.Pointer(arg1.Native()))).(Widget)

	v.(TreeViewSearchPositionFunc)(treeView, searchDialog)
}

type TreeViewPrivate struct {
	native C.GtkTreeViewPrivate
}

// WrapTreeViewPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTreeViewPrivate(ptr unsafe.Pointer) *TreeViewPrivate {
	if ptr == nil {
		return nil
	}

	return (*TreeViewPrivate)(ptr)
}

func marshalTreeViewPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapTreeViewPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *TreeViewPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}
