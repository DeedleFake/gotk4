// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"unsafe"

	"github.com/diamondburned/gotk4/internal/gextras"
	"github.com/diamondburned/gotk4/pkg/gdk/v3"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config:
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_pad_controller_get_type()), F: marshalPadController},
	})
}

// PadController is an event controller for the pads found in drawing tablets
// (The collection of buttons and tactile sensors often found around the
// stylus-sensitive area).
//
// These buttons and sensors have no implicit meaning, and by default they
// perform no action, this event controller is provided to map those to #GAction
// objects, thus letting the application give those a more semantic meaning.
//
// Buttons and sensors are not constrained to triggering a single action, some
// GDK_SOURCE_TABLET_PAD devices feature multiple "modes", all these input
// elements have one current mode, which may determine the final action being
// triggered. Pad devices often divide buttons and sensors into groups, all
// elements in a group share the same current mode, but different groups may
// have different modes. See gdk_device_pad_get_n_groups() and
// gdk_device_pad_get_group_n_modes().
//
// Each of the actions that a given button/strip/ring performs for a given mode
// is defined by PadActionEntry, it contains an action name that will be looked
// up in the given Group and activated whenever the specified input element and
// mode are triggered.
//
// A simple example of PadController usage, assigning button 1 in all modes and
// pad devices to an "invert-selection" action:
//
//      GtkPadActionEntry *pad_actions[] = {
//        { GTK_PAD_ACTION_BUTTON, 1, -1, "Invert selection", "pad-actions.invert-selection" },
//        …
//      };
//
//      …
//      action_group = g_simple_action_group_new ();
//      action = g_simple_action_new ("pad-actions.invert-selection", NULL);
//      g_signal_connect (action, "activate", on_invert_selection_activated, NULL);
//      g_action_map_add_action (G_ACTION_MAP (action_group), action);
//      …
//      pad_controller = gtk_pad_controller_new (window, action_group, NULL);
//
// The actions belonging to rings/strips will be activated with a parameter of
// type G_VARIANT_TYPE_DOUBLE bearing the value of the given axis, it is
// required that those are made stateful and accepting this Type.
type PadController interface {
	EventController

	// SetAction adds an individual action to @controller. This action will only
	// be activated if the given button/ring/strip number in @index is
	// interacted while the current mode is @mode. -1 may be used for simple
	// cases, so the action is triggered on all modes.
	//
	// The given @label should be considered user-visible, so
	// internationalization rules apply. Some windowing systems may be able to
	// use those for user feedback.
	SetAction(typ PadActionType, index int, mode int, label string, actionName string)
	// SetActionEntries: this is a convenience function to add a group of action
	// entries on @controller. See PadActionEntry and
	// gtk_pad_controller_set_action().
	SetActionEntries()
}

// padController implements the PadController interface.
type padController struct {
	EventController
}

var _ PadController = (*padController)(nil)

// WrapPadController wraps a GObject to the right type. It is
// primarily used internally.
func WrapPadController(obj *externglib.Object) PadController {
	return PadController{
		EventController: WrapEventController(obj),
	}
}

func marshalPadController(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPadController(obj), nil
}

// NewPadController constructs a class PadController.
func NewPadController(window Window, group gio.ActionGroup, pad gdk.Device) PadController {
	var arg1 *C.GtkWindow
	var arg2 *C.GActionGroup
	var arg3 *C.GdkDevice

	arg1 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	arg2 = (*C.GActionGroup)(unsafe.Pointer(group.Native()))
	arg3 = (*C.GdkDevice)(unsafe.Pointer(pad.Native()))

	cret := new(C.GtkPadController)
	var goret PadController

	cret = C.gtk_pad_controller_new(arg1, arg2, arg3)

	goret = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(PadController)

	return goret
}

// SetAction adds an individual action to @controller. This action will only
// be activated if the given button/ring/strip number in @index is
// interacted while the current mode is @mode. -1 may be used for simple
// cases, so the action is triggered on all modes.
//
// The given @label should be considered user-visible, so
// internationalization rules apply. Some windowing systems may be able to
// use those for user feedback.
func (c padController) SetAction(typ PadActionType, index int, mode int, label string, actionName string) {
	var arg0 *C.GtkPadController
	var arg1 C.GtkPadActionType
	var arg2 C.gint
	var arg3 C.gint
	var arg4 *C.gchar
	var arg5 *C.gchar

	arg0 = (*C.GtkPadController)(unsafe.Pointer(c.Native()))
	arg1 = (C.GtkPadActionType)(typ)
	arg2 = C.gint(index)
	arg3 = C.gint(mode)
	arg4 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(arg4))
	arg5 = (*C.gchar)(C.CString(actionName))
	defer C.free(unsafe.Pointer(arg5))

	C.gtk_pad_controller_set_action(arg0, arg1, arg2, arg3, arg4, arg5)
}

// SetActionEntries: this is a convenience function to add a group of action
// entries on @controller. See PadActionEntry and
// gtk_pad_controller_set_action().
func (c padController) SetActionEntries() {
	var arg0 *C.GtkPadController

	arg0 = (*C.GtkPadController)(unsafe.Pointer(c.Native()))

	C.gtk_pad_controller_set_action_entries(arg0, arg1, arg2)
}

// PadActionEntry: struct defining a pad action entry.
type PadActionEntry struct {
	native C.GtkPadActionEntry
}

// WrapPadActionEntry wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapPadActionEntry(ptr unsafe.Pointer) *PadActionEntry {
	if ptr == nil {
		return nil
	}

	return (*PadActionEntry)(ptr)
}

func marshalPadActionEntry(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapPadActionEntry(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (p *PadActionEntry) Native() unsafe.Pointer {
	return unsafe.Pointer(&p.native)
}

// Type gets the field inside the struct.
func (p *PadActionEntry) Type() PadActionType {
	var v PadActionType
	v = PadActionType(p.native._type)
	return v
}

// Index gets the field inside the struct.
func (p *PadActionEntry) Index() int {
	var v int
	v = int(p.native.index)
	return v
}

// Mode gets the field inside the struct.
func (p *PadActionEntry) Mode() int {
	var v int
	v = int(p.native.mode)
	return v
}

// Label gets the field inside the struct.
func (p *PadActionEntry) Label() string {
	var v string
	v = C.GoString(p.native.label)
	return v
}

// ActionName gets the field inside the struct.
func (p *PadActionEntry) ActionName() string {
	var v string
	v = C.GoString(p.native.action_name)
	return v
}
