// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"runtime"
	"runtime/cgo"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/gdk/v3"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
	"github.com/diamondburned/gotk4/pkg/pango"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gtk+-3.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
import "C"

// KeySnoopFunc: key snooper functions are called before normal event delivery.
// They can be used to implement custom key event handling.
type KeySnoopFunc func(grabWidget *Widget, event *gdk.EventKey, funcData cgo.Handle) (gint int)

//export gotk4_KeySnoopFunc
func gotk4_KeySnoopFunc(arg0 *C.GtkWidget, arg1 *C.GdkEventKey, arg2 C.gpointer) (cret C.gint) {
	v := gbox.Get(uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var grabWidget *Widget  // out
	var event *gdk.EventKey // out
	var funcData cgo.Handle // out

	grabWidget = wrapWidget(externglib.Take(unsafe.Pointer(arg0)))
	event = (*gdk.EventKey)(unsafe.Pointer(arg1))
	runtime.SetFinalizer(event, func(v *gdk.EventKey) {
		C.free(unsafe.Pointer(v))
	})
	funcData = (cgo.Handle)(unsafe.Pointer(arg2))

	fn := v.(KeySnoopFunc)
	gint := fn(grabWidget, event, funcData)

	cret = C.gint(gint)

	return cret
}

// CheckVersion checks that the GTK+ library in use is compatible with the given
// version. Generally you would pass in the constants K_MAJOR_VERSION,
// K_MINOR_VERSION, K_MICRO_VERSION as the three arguments to this function;
// that produces a check that the library in use is compatible with the version
// of GTK+ the application or module was compiled against.
//
// Compatibility is defined by two things: first the version of the running
// library is newer than the version
// required_major.required_minor.required_micro. Second the running library must
// be binary compatible with the version
// required_major.required_minor.required_micro (same major version.)
//
// This function is primarily for GTK+ modules; the module can call this
// function to check that it wasn’t loaded into an incompatible version of GTK+.
// However, such a check isn’t completely reliable, since the module may be
// linked against an old version of GTK+ and calling the old version of
// gtk_check_version(), but still get loaded into an application using a newer
// version of GTK+.
func CheckVersion(requiredMajor uint, requiredMinor uint, requiredMicro uint) string {
	var _arg1 C.guint  // out
	var _arg2 C.guint  // out
	var _arg3 C.guint  // out
	var _cret *C.gchar // in

	_arg1 = C.guint(requiredMajor)
	_arg2 = C.guint(requiredMinor)
	_arg3 = C.guint(requiredMicro)

	_cret = C.gtk_check_version(_arg1, _arg2, _arg3)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// DeviceGrabAdd adds a GTK+ grab on device, so all the events on device and its
// associated pointer or keyboard (if any) are delivered to widget. If the
// block_others parameter is TRUE, any other devices will be unable to interact
// with widget during the grab.
func DeviceGrabAdd(widget Widgeter, device gdk.Devicer, blockOthers bool) {
	var _arg1 *C.GtkWidget // out
	var _arg2 *C.GdkDevice // out
	var _arg3 C.gboolean   // out

	_arg1 = (*C.GtkWidget)(unsafe.Pointer((widget).(gextras.Nativer).Native()))
	_arg2 = (*C.GdkDevice)(unsafe.Pointer((device).(gextras.Nativer).Native()))
	if blockOthers {
		_arg3 = C.TRUE
	}

	C.gtk_device_grab_add(_arg1, _arg2, _arg3)
}

// DeviceGrabRemove removes a device grab from the given widget.
//
// You have to pair calls to gtk_device_grab_add() and gtk_device_grab_remove().
func DeviceGrabRemove(widget Widgeter, device gdk.Devicer) {
	var _arg1 *C.GtkWidget // out
	var _arg2 *C.GdkDevice // out

	_arg1 = (*C.GtkWidget)(unsafe.Pointer((widget).(gextras.Nativer).Native()))
	_arg2 = (*C.GdkDevice)(unsafe.Pointer((device).(gextras.Nativer).Native()))

	C.gtk_device_grab_remove(_arg1, _arg2)
}

// DisableSetlocale prevents gtk_init(), gtk_init_check(), gtk_init_with_args()
// and gtk_parse_args() from automatically calling setlocale (LC_ALL, ""). You
// would want to use this function if you wanted to set the locale for your
// program to something other than the user’s locale, or if you wanted to set
// different values for different locale categories.
//
// Most programs should not need to call this function.
func DisableSetlocale() {
	C.gtk_disable_setlocale()
}

// EventsPending checks if any events are pending.
//
// This can be used to update the UI and invoke timeouts etc. while doing some
// time intensive computation.
//
// Updating the UI during a long computation
//
//     // computation going on...
//
//     while (gtk_events_pending ())
//       gtk_main_iteration ();
//
//     // ...computation continued
func EventsPending() bool {
	var _cret C.gboolean // in

	_cret = C.gtk_events_pending()

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// False: analogical to gtk_true(), this function does nothing but always
// returns FALSE.
func False() bool {
	var _cret C.gboolean // in

	_cret = C.gtk_false()

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// GetBinaryAge returns the binary age as passed to libtool when building the
// GTK+ library the process is running against. If libtool means nothing to you,
// don't worry about it.
func GetBinaryAge() uint {
	var _cret C.guint // in

	_cret = C.gtk_get_binary_age()

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// GetCurrentEventDevice: if there is a current event and it has a device,
// return that device, otherwise return NULL.
func GetCurrentEventDevice() *gdk.Device {
	var _cret *C.GdkDevice // in

	_cret = C.gtk_get_current_event_device()

	var _device *gdk.Device // out

	{
		obj := externglib.Take(unsafe.Pointer(_cret))
		_device = &gdk.Device{
			Object: obj,
		}
	}

	return _device
}

// GetCurrentEventState: if there is a current event and it has a state field,
// place that state field in state and return TRUE, otherwise return FALSE.
func GetCurrentEventState() (gdk.ModifierType, bool) {
	var _arg1 C.GdkModifierType // in
	var _cret C.gboolean        // in

	_cret = C.gtk_get_current_event_state(&_arg1)

	var _state gdk.ModifierType // out
	var _ok bool                // out

	_state = gdk.ModifierType(_arg1)
	if _cret != 0 {
		_ok = true
	}

	return _state, _ok
}

// GetCurrentEventTime: if there is a current event and it has a timestamp,
// return that timestamp, otherwise return GDK_CURRENT_TIME.
func GetCurrentEventTime() uint32 {
	var _cret C.guint32 // in

	_cret = C.gtk_get_current_event_time()

	var _guint32 uint32 // out

	_guint32 = uint32(_cret)

	return _guint32
}

// GetDefaultLanguage returns the Language for the default language currently in
// effect. (Note that this can change over the life of an application.) The
// default language is derived from the current locale. It determines, for
// example, whether GTK+ uses the right-to-left or left-to-right text direction.
//
// This function is equivalent to pango_language_get_default(). See that
// function for details.
func GetDefaultLanguage() *pango.Language {
	var _cret *C.PangoLanguage // in

	_cret = C.gtk_get_default_language()

	var _language *pango.Language // out

	_language = (*pango.Language)(unsafe.Pointer(_cret))

	return _language
}

// GetInterfaceAge returns the interface age as passed to libtool when building
// the GTK+ library the process is running against. If libtool means nothing to
// you, don't worry about it.
func GetInterfaceAge() uint {
	var _cret C.guint // in

	_cret = C.gtk_get_interface_age()

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// GetLocaleDirection: get the direction of the current locale. This is the
// expected reading direction for text and UI.
//
// This function depends on the current locale being set with setlocale() and
// will default to setting the GTK_TEXT_DIR_LTR direction otherwise.
// GTK_TEXT_DIR_NONE will never be returned.
//
// GTK+ sets the default text direction according to the locale during
// gtk_init(), and you should normally use gtk_widget_get_direction() or
// gtk_widget_get_default_direction() to obtain the current direcion.
//
// This function is only needed rare cases when the locale is changed after GTK+
// has already been initialized. In this case, you can use it to update the
// default text direction as follows:
//
//    setlocale (LC_ALL, new_locale);
//    direction = gtk_get_locale_direction ();
//    gtk_widget_set_default_direction (direction);
func GetLocaleDirection() TextDirection {
	var _cret C.GtkTextDirection // in

	_cret = C.gtk_get_locale_direction()

	var _textDirection TextDirection // out

	_textDirection = TextDirection(_cret)

	return _textDirection
}

// GetMajorVersion returns the major version number of the GTK+ library. (e.g.
// in GTK+ version 3.1.5 this is 3.)
//
// This function is in the library, so it represents the GTK+ library your code
// is running against. Contrast with the K_MAJOR_VERSION macro, which represents
// the major version of the GTK+ headers you have included when compiling your
// code.
func GetMajorVersion() uint {
	var _cret C.guint // in

	_cret = C.gtk_get_major_version()

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// GetMicroVersion returns the micro version number of the GTK+ library. (e.g.
// in GTK+ version 3.1.5 this is 5.)
//
// This function is in the library, so it represents the GTK+ library your code
// is are running against. Contrast with the K_MICRO_VERSION macro, which
// represents the micro version of the GTK+ headers you have included when
// compiling your code.
func GetMicroVersion() uint {
	var _cret C.guint // in

	_cret = C.gtk_get_micro_version()

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// GetMinorVersion returns the minor version number of the GTK+ library. (e.g.
// in GTK+ version 3.1.5 this is 1.)
//
// This function is in the library, so it represents the GTK+ library your code
// is are running against. Contrast with the K_MINOR_VERSION macro, which
// represents the minor version of the GTK+ headers you have included when
// compiling your code.
func GetMinorVersion() uint {
	var _cret C.guint // in

	_cret = C.gtk_get_minor_version()

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// GetOptionGroup returns a Group for the commandline arguments recognized by
// GTK+ and GDK.
//
// You should add this group to your Context with g_option_context_add_group(),
// if you are using g_option_context_parse() to parse your commandline
// arguments.
func GetOptionGroup(openDefaultDisplay bool) *glib.OptionGroup {
	var _arg1 C.gboolean      // out
	var _cret *C.GOptionGroup // in

	if openDefaultDisplay {
		_arg1 = C.TRUE
	}

	_cret = C.gtk_get_option_group(_arg1)

	var _optionGroup *glib.OptionGroup // out

	_optionGroup = (*glib.OptionGroup)(unsafe.Pointer(_cret))
	C.g_option_group_ref(_cret)
	runtime.SetFinalizer(_optionGroup, func(v *glib.OptionGroup) {
		C.g_option_group_unref((*C.GOptionGroup)(unsafe.Pointer(v)))
	})

	return _optionGroup
}

// GrabGetCurrent queries the current grab of the default window group.
func GrabGetCurrent() *Widget {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_grab_get_current()

	var _widget *Widget // out

	_widget = wrapWidget(externglib.Take(unsafe.Pointer(_cret)))

	return _widget
}

// Init: call this function before using any other GTK+ functions in your GUI
// applications. It will initialize everything needed to operate the toolkit and
// parses some standard command line options.
//
// Although you are expected to pass the argc, argv parameters from main() to
// this function, it is possible to pass NULL if argv is not available or
// commandline handling is not required.
//
// argc and argv are adjusted accordingly so your own code will never see those
// standard arguments.
//
// Note that there are some alternative ways to initialize GTK+: if you are
// calling gtk_parse_args(), gtk_init_check(), gtk_init_with_args() or
// g_option_context_parse() with the option group returned by
// gtk_get_option_group(), you don’t have to call gtk_init().
//
// And if you are using Application, you don't have to call any of the
// initialization functions either; the Application::startup handler does it for
// you.
//
// This function will terminate your program if it was unable to initialize the
// windowing system for some reason. If you want your program to fall back to a
// textual interface you want to call gtk_init_check() instead.
//
// Since 2.18, GTK+ calls signal (SIGPIPE, SIG_IGN) during initialization, to
// ignore SIGPIPE signals, since these are almost never wanted in graphical
// applications. If you do need to handle SIGPIPE for some reason, reset the
// handler after gtk_init(), but notice that other libraries (e.g. libdbus or
// gvfs) might do similar things.
func Init(argv []string) {
	var _arg2 ***C.char
	var _arg1 C.int

	*_arg1 = (C.int)(len(argv))
	_arg2 = (***C.char)(C.malloc(C.ulong(len(argv)) * C.ulong(unsafe.Sizeof(uint(0)))))
	{
		out := unsafe.Slice((**C.char)(_arg2), len(argv))
		for i := range argv {
			*out[i] = (*C.char)(unsafe.Pointer(C.CString(argv[i])))
		}
	}

	C.gtk_init(_arg1, _arg2)
}

// InitCheck: this function does the same work as gtk_init() with only a single
// change: It does not terminate the program if the commandline arguments
// couldn’t be parsed or the windowing system can’t be initialized. Instead it
// returns FALSE on failure.
//
// This way the application can fall back to some other means of communication
// with the user - for example a curses or command line interface.
//
// Note that calling any GTK function or instantiating any GTK type after this
// function returns FALSE results in undefined behavior.
func InitCheck(argv []string) bool {
	var _arg2 ***C.char
	var _arg1 C.int
	var _cret C.gboolean // in

	*_arg1 = (C.int)(len(argv))
	_arg2 = (***C.char)(C.malloc(C.ulong(len(argv)) * C.ulong(unsafe.Sizeof(uint(0)))))
	{
		out := unsafe.Slice((**C.char)(_arg2), len(argv))
		for i := range argv {
			*out[i] = (*C.char)(unsafe.Pointer(C.CString(argv[i])))
		}
	}

	_cret = C.gtk_init_check(_arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// InitWithArgs: this function does the same work as gtk_init_check().
// Additionally, it allows you to add your own commandline options, and it
// automatically generates nicely formatted --help output. Note that your
// program will be terminated after writing out the help output.
func InitWithArgs(argv []string, parameterString string, entries []glib.OptionEntry, translationDomain string) error {
	var _arg2 ***C.gchar
	var _arg1 C.gint
	var _arg3 *C.gchar // out
	var _arg4 *C.GOptionEntry
	var _arg5 *C.gchar  // out
	var _cerr *C.GError // in

	*_arg1 = (C.gint)(len(argv))
	_arg2 = (***C.gchar)(C.malloc(C.ulong(len(argv)) * C.ulong(unsafe.Sizeof(uint(0)))))
	{
		out := unsafe.Slice((**C.gchar)(_arg2), len(argv))
		for i := range argv {
			*out[i] = (*C.gchar)(unsafe.Pointer(C.CString(argv[i])))
		}
	}
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(parameterString)))
	{
		var zero glib.OptionEntry
		entries = append(entries, zero)
		_arg4 = (*C.GOptionEntry)(unsafe.Pointer(&entries[0]))
	}
	_arg5 = (*C.gchar)(unsafe.Pointer(C.CString(translationDomain)))

	C.gtk_init_with_args(_arg1, _arg2, _arg3, _arg4, _arg5, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// KeySnooperRemove removes the key snooper function with the given id.
//
// Deprecated: Key snooping should not be done. Events should be handled by
// widgets.
func KeySnooperRemove(snooperHandlerId uint) {
	var _arg1 C.guint // out

	_arg1 = C.guint(snooperHandlerId)

	C.gtk_key_snooper_remove(_arg1)
}

// Main runs the main loop until gtk_main_quit() is called.
//
// You can nest calls to gtk_main(). In that case gtk_main_quit() will make the
// innermost invocation of the main loop return.
func Main() {
	C.gtk_main()
}

// MainIteration runs a single iteration of the mainloop.
//
// If no events are waiting to be processed GTK+ will block until the next event
// is noticed. If you don’t want to block look at gtk_main_iteration_do() or
// check if any events are pending with gtk_events_pending() first.
func MainIteration() bool {
	var _cret C.gboolean // in

	_cret = C.gtk_main_iteration()

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MainIterationDo runs a single iteration of the mainloop. If no events are
// available either return or block depending on the value of blocking.
func MainIterationDo(blocking bool) bool {
	var _arg1 C.gboolean // out
	var _cret C.gboolean // in

	if blocking {
		_arg1 = C.TRUE
	}

	_cret = C.gtk_main_iteration_do(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MainLevel asks for the current nesting level of the main loop.
func MainLevel() uint {
	var _cret C.guint // in

	_cret = C.gtk_main_level()

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// MainQuit makes the innermost invocation of the main loop return when it
// regains control.
func MainQuit() {
	C.gtk_main_quit()
}

// ParseArgs parses command line arguments, and initializes global attributes of
// GTK+, but does not actually open a connection to a display. (See
// gdk_display_open(), gdk_get_display_arg_name())
//
// Any arguments used by GTK+ or GDK are removed from the array and argc and
// argv are updated accordingly.
//
// There is no need to call this function explicitly if you are using
// gtk_init(), or gtk_init_check().
//
// Note that many aspects of GTK+ require a display connection to function, so
// this way of initializing GTK+ is really only useful for specialized use
// cases.
func ParseArgs(argv []string) bool {
	var _arg2 ***C.char
	var _arg1 C.int
	var _cret C.gboolean // in

	*_arg1 = (C.int)(len(argv))
	_arg2 = (***C.char)(C.malloc(C.ulong(len(argv)) * C.ulong(unsafe.Sizeof(uint(0)))))
	{
		out := unsafe.Slice((**C.char)(_arg2), len(argv))
		for i := range argv {
			*out[i] = (*C.char)(unsafe.Pointer(C.CString(argv[i])))
		}
	}

	_cret = C.gtk_parse_args(_arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// True: all this function does it to return TRUE.
//
// This can be useful for example if you want to inhibit the deletion of a
// window. Of course you should not do this as the user expects a reaction from
// clicking the close icon of the window...
//
// A persistent window
//
//    #include <gtk/gtk.h>
//
//    int
//    main (int argc, char **argv)
//    {
//      GtkWidget *win, *but;
//      const char *text = "Close yourself. I mean it!";
//
//      gtk_init (&argc, &argv);
//
//      win = gtk_window_new (GTK_WINDOW_TOPLEVEL);
//      g_signal_connect (win,
//                        "delete-event",
//                        G_CALLBACK (gtk_true),
//                        NULL);
//      g_signal_connect (win, "destroy",
//                        G_CALLBACK (gtk_main_quit),
//                        NULL);
//
//      but = gtk_button_new_with_label (text);
//      g_signal_connect_swapped (but, "clicked",
//                                G_CALLBACK (gtk_object_destroy),
//                                win);
//      gtk_container_add (GTK_CONTAINER (win), but);
//
//      gtk_widget_show_all (win);
//
//      gtk_main ();
//
//      return 0;
//    }
func True() bool {
	var _cret C.gboolean // in

	_cret = C.gtk_true()

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}
