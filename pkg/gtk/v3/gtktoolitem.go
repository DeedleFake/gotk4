// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"unsafe"

	"github.com/diamondburned/gotk4/internal/gextras"
	"github.com/diamondburned/gotk4/pkg/pango"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config:
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <stdbool.h>
// #include <glib-object.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_tool_item_get_type()), F: marshalToolItem},
	})
}

// ToolItem ToolItems are widgets that can appear on a toolbar. To create a
// toolbar item that contain something else than a button, use
// gtk_tool_item_new(). Use gtk_container_add() to add a child widget to the
// tool item.
//
// For toolbar items that contain buttons, see the ToolButton, ToggleToolButton
// and RadioToolButton classes.
//
// See the Toolbar class for a description of the toolbar widget, and ToolShell
// for a description of the tool shell interface.
type ToolItem interface {
	Bin
	Activatable
	Buildable

	// EllipsizeMode returns the ellipsize mode used for @tool_item. Custom
	// subclasses of ToolItem should call this function to find out how text
	// should be ellipsized.
	EllipsizeMode() pango.EllipsizeMode
	// Expand returns whether @tool_item is allocated extra space. See
	// gtk_tool_item_set_expand().
	Expand() bool
	// Homogeneous returns whether @tool_item is the same size as other
	// homogeneous items. See gtk_tool_item_set_homogeneous().
	Homogeneous() bool
	// IconSize returns the icon size used for @tool_item. Custom subclasses of
	// ToolItem should call this function to find out what size icons they
	// should use.
	IconSize() int
	// IsImportant returns whether @tool_item is considered important. See
	// gtk_tool_item_set_is_important()
	IsImportant() bool
	// Orientation returns the orientation used for @tool_item. Custom
	// subclasses of ToolItem should call this function to find out what size
	// icons they should use.
	Orientation() Orientation
	// ProxyMenuItem: if @menu_item_id matches the string passed to
	// gtk_tool_item_set_proxy_menu_item() return the corresponding MenuItem.
	//
	// Custom subclasses of ToolItem should use this function to update their
	// menu item when the ToolItem changes. That the @menu_item_ids must match
	// ensures that a ToolItem will not inadvertently change a menu item that
	// they did not create.
	ProxyMenuItem(menuItemID string) Widget
	// ReliefStyle returns the relief style of @tool_item. See
	// gtk_button_set_relief(). Custom subclasses of ToolItem should call this
	// function in the handler of the ToolItem::toolbar_reconfigured signal to
	// find out the relief style of buttons.
	ReliefStyle() ReliefStyle
	// TextAlignment returns the text alignment used for @tool_item. Custom
	// subclasses of ToolItem should call this function to find out how text
	// should be aligned.
	TextAlignment() float32
	// TextOrientation returns the text orientation used for @tool_item. Custom
	// subclasses of ToolItem should call this function to find out how text
	// should be orientated.
	TextOrientation() Orientation
	// TextSizeGroup returns the size group used for labels in @tool_item.
	// Custom subclasses of ToolItem should call this function and use the size
	// group for labels.
	TextSizeGroup() SizeGroup
	// ToolbarStyle returns the toolbar style used for @tool_item. Custom
	// subclasses of ToolItem should call this function in the handler of the
	// GtkToolItem::toolbar_reconfigured signal to find out in what style the
	// toolbar is displayed and change themselves accordingly
	//
	// Possibilities are: - GTK_TOOLBAR_BOTH, meaning the tool item should show
	// both an icon and a label, stacked vertically - GTK_TOOLBAR_ICONS, meaning
	// the toolbar shows only icons - GTK_TOOLBAR_TEXT, meaning the tool item
	// should only show text - GTK_TOOLBAR_BOTH_HORIZ, meaning the tool item
	// should show both an icon and a label, arranged horizontally
	ToolbarStyle() ToolbarStyle
	// UseDragWindow returns whether @tool_item has a drag window. See
	// gtk_tool_item_set_use_drag_window().
	UseDragWindow() bool
	// VisibleHorizontal returns whether the @tool_item is visible on toolbars
	// that are docked horizontally.
	VisibleHorizontal() bool
	// VisibleVertical returns whether @tool_item is visible when the toolbar is
	// docked vertically. See gtk_tool_item_set_visible_vertical().
	VisibleVertical() bool
	// RebuildMenu: calling this function signals to the toolbar that the
	// overflow menu item for @tool_item has changed. If the overflow menu is
	// visible when this function it called, the menu will be rebuilt.
	//
	// The function must be called when the tool item changes what it will do in
	// response to the ToolItem::create-menu-proxy signal.
	RebuildMenu()
	// RetrieveProxyMenuItem returns the MenuItem that was last set by
	// gtk_tool_item_set_proxy_menu_item(), ie. the MenuItem that is going to
	// appear in the overflow menu.
	RetrieveProxyMenuItem() Widget
	// SetExpand sets whether @tool_item is allocated extra space when there is
	// more room on the toolbar then needed for the items. The effect is that
	// the item gets bigger when the toolbar gets bigger and smaller when the
	// toolbar gets smaller.
	SetExpand(expand bool)
	// SetHomogeneous sets whether @tool_item is to be allocated the same size
	// as other homogeneous items. The effect is that all homogeneous items will
	// have the same width as the widest of the items.
	SetHomogeneous(homogeneous bool)
	// SetIsImportant sets whether @tool_item should be considered important.
	// The ToolButton class uses this property to determine whether to show or
	// hide its label when the toolbar style is GTK_TOOLBAR_BOTH_HORIZ. The
	// result is that only tool buttons with the “is_important” property set
	// have labels, an effect known as “priority text”
	SetIsImportant(isImportant bool)
	// SetProxyMenuItem sets the MenuItem used in the toolbar overflow menu. The
	// @menu_item_id is used to identify the caller of this function and should
	// also be used with gtk_tool_item_get_proxy_menu_item().
	//
	// See also ToolItem::create-menu-proxy.
	SetProxyMenuItem(menuItemID string, menuItem Widget)
	// SetTooltipMarkup sets the markup text to be displayed as tooltip on the
	// item. See gtk_widget_set_tooltip_markup().
	SetTooltipMarkup(markup string)
	// SetTooltipText sets the text to be displayed as tooltip on the item. See
	// gtk_widget_set_tooltip_text().
	SetTooltipText(text string)
	// SetUseDragWindow sets whether @tool_item has a drag window. When true the
	// toolitem can be used as a drag source through gtk_drag_source_set(). When
	// @tool_item has a drag window it will intercept all events, even those
	// that would otherwise be sent to a child of @tool_item.
	SetUseDragWindow(useDragWindow bool)
	// SetVisibleHorizontal sets whether @tool_item is visible when the toolbar
	// is docked horizontally.
	SetVisibleHorizontal(visibleHorizontal bool)
	// SetVisibleVertical sets whether @tool_item is visible when the toolbar is
	// docked vertically. Some tool items, such as text entries, are too wide to
	// be useful on a vertically docked toolbar. If @visible_vertical is false
	// @tool_item will not appear on toolbars that are docked vertically.
	SetVisibleVertical(visibleVertical bool)
	// ToolbarReconfigured emits the signal ToolItem::toolbar_reconfigured on
	// @tool_item. Toolbar and other ToolShell implementations use this function
	// to notify children, when some aspect of their configuration changes.
	ToolbarReconfigured()
}

// toolItem implements the ToolItem interface.
type toolItem struct {
	Bin
	Activatable
	Buildable
}

var _ ToolItem = (*toolItem)(nil)

// WrapToolItem wraps a GObject to the right type. It is
// primarily used internally.
func WrapToolItem(obj *externglib.Object) ToolItem {
	return ToolItem{
		Bin:         WrapBin(obj),
		Activatable: WrapActivatable(obj),
		Buildable:   WrapBuildable(obj),
	}
}

func marshalToolItem(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapToolItem(obj), nil
}

// NewToolItem constructs a class ToolItem.
func NewToolItem() ToolItem {
	var cret C.GtkToolItem
	var ret1 ToolItem

	cret = C.gtk_tool_item_new()

	ret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(ToolItem)

	return ret1
}

// EllipsizeMode returns the ellipsize mode used for @tool_item. Custom
// subclasses of ToolItem should call this function to find out how text
// should be ellipsized.
func (t toolItem) EllipsizeMode() pango.EllipsizeMode {
	var arg0 *C.GtkToolItem

	arg0 = (*C.GtkToolItem)(unsafe.Pointer(t.Native()))

	var cret C.PangoEllipsizeMode
	var ret1 pango.EllipsizeMode

	cret = C.gtk_tool_item_get_ellipsize_mode(arg0)

	ret1 = pango.EllipsizeMode(cret)

	return ret1
}

// Expand returns whether @tool_item is allocated extra space. See
// gtk_tool_item_set_expand().
func (t toolItem) Expand() bool {
	var arg0 *C.GtkToolItem

	arg0 = (*C.GtkToolItem)(unsafe.Pointer(t.Native()))

	var cret C.gboolean
	var ret1 bool

	cret = C.gtk_tool_item_get_expand(arg0)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// Homogeneous returns whether @tool_item is the same size as other
// homogeneous items. See gtk_tool_item_set_homogeneous().
func (t toolItem) Homogeneous() bool {
	var arg0 *C.GtkToolItem

	arg0 = (*C.GtkToolItem)(unsafe.Pointer(t.Native()))

	var cret C.gboolean
	var ret1 bool

	cret = C.gtk_tool_item_get_homogeneous(arg0)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// IconSize returns the icon size used for @tool_item. Custom subclasses of
// ToolItem should call this function to find out what size icons they
// should use.
func (t toolItem) IconSize() int {
	var arg0 *C.GtkToolItem

	arg0 = (*C.GtkToolItem)(unsafe.Pointer(t.Native()))

	var cret C.GtkIconSize
	var ret1 int

	cret = C.gtk_tool_item_get_icon_size(arg0)

	ret1 = C.GtkIconSize(cret)

	return ret1
}

// IsImportant returns whether @tool_item is considered important. See
// gtk_tool_item_set_is_important()
func (t toolItem) IsImportant() bool {
	var arg0 *C.GtkToolItem

	arg0 = (*C.GtkToolItem)(unsafe.Pointer(t.Native()))

	var cret C.gboolean
	var ret1 bool

	cret = C.gtk_tool_item_get_is_important(arg0)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// Orientation returns the orientation used for @tool_item. Custom
// subclasses of ToolItem should call this function to find out what size
// icons they should use.
func (t toolItem) Orientation() Orientation {
	var arg0 *C.GtkToolItem

	arg0 = (*C.GtkToolItem)(unsafe.Pointer(t.Native()))

	var cret C.GtkOrientation
	var ret1 Orientation

	cret = C.gtk_tool_item_get_orientation(arg0)

	ret1 = Orientation(cret)

	return ret1
}

// ProxyMenuItem: if @menu_item_id matches the string passed to
// gtk_tool_item_set_proxy_menu_item() return the corresponding MenuItem.
//
// Custom subclasses of ToolItem should use this function to update their
// menu item when the ToolItem changes. That the @menu_item_ids must match
// ensures that a ToolItem will not inadvertently change a menu item that
// they did not create.
func (t toolItem) ProxyMenuItem(menuItemID string) Widget {
	var arg0 *C.GtkToolItem
	var arg1 *C.gchar

	arg0 = (*C.GtkToolItem)(unsafe.Pointer(t.Native()))
	arg1 = (*C.gchar)(C.CString(menuItemID))
	defer C.free(unsafe.Pointer(arg1))

	var cret *C.GtkWidget
	var ret1 Widget

	cret = C.gtk_tool_item_get_proxy_menu_item(arg0, menuItemID)

	ret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Widget)

	return ret1
}

// ReliefStyle returns the relief style of @tool_item. See
// gtk_button_set_relief(). Custom subclasses of ToolItem should call this
// function in the handler of the ToolItem::toolbar_reconfigured signal to
// find out the relief style of buttons.
func (t toolItem) ReliefStyle() ReliefStyle {
	var arg0 *C.GtkToolItem

	arg0 = (*C.GtkToolItem)(unsafe.Pointer(t.Native()))

	var cret C.GtkReliefStyle
	var ret1 ReliefStyle

	cret = C.gtk_tool_item_get_relief_style(arg0)

	ret1 = ReliefStyle(cret)

	return ret1
}

// TextAlignment returns the text alignment used for @tool_item. Custom
// subclasses of ToolItem should call this function to find out how text
// should be aligned.
func (t toolItem) TextAlignment() float32 {
	var arg0 *C.GtkToolItem

	arg0 = (*C.GtkToolItem)(unsafe.Pointer(t.Native()))

	var cret C.gfloat
	var ret1 float32

	cret = C.gtk_tool_item_get_text_alignment(arg0)

	ret1 = C.gfloat(cret)

	return ret1
}

// TextOrientation returns the text orientation used for @tool_item. Custom
// subclasses of ToolItem should call this function to find out how text
// should be orientated.
func (t toolItem) TextOrientation() Orientation {
	var arg0 *C.GtkToolItem

	arg0 = (*C.GtkToolItem)(unsafe.Pointer(t.Native()))

	var cret C.GtkOrientation
	var ret1 Orientation

	cret = C.gtk_tool_item_get_text_orientation(arg0)

	ret1 = Orientation(cret)

	return ret1
}

// TextSizeGroup returns the size group used for labels in @tool_item.
// Custom subclasses of ToolItem should call this function and use the size
// group for labels.
func (t toolItem) TextSizeGroup() SizeGroup {
	var arg0 *C.GtkToolItem

	arg0 = (*C.GtkToolItem)(unsafe.Pointer(t.Native()))

	var cret *C.GtkSizeGroup
	var ret1 SizeGroup

	cret = C.gtk_tool_item_get_text_size_group(arg0)

	ret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(SizeGroup)

	return ret1
}

// ToolbarStyle returns the toolbar style used for @tool_item. Custom
// subclasses of ToolItem should call this function in the handler of the
// GtkToolItem::toolbar_reconfigured signal to find out in what style the
// toolbar is displayed and change themselves accordingly
//
// Possibilities are: - GTK_TOOLBAR_BOTH, meaning the tool item should show
// both an icon and a label, stacked vertically - GTK_TOOLBAR_ICONS, meaning
// the toolbar shows only icons - GTK_TOOLBAR_TEXT, meaning the tool item
// should only show text - GTK_TOOLBAR_BOTH_HORIZ, meaning the tool item
// should show both an icon and a label, arranged horizontally
func (t toolItem) ToolbarStyle() ToolbarStyle {
	var arg0 *C.GtkToolItem

	arg0 = (*C.GtkToolItem)(unsafe.Pointer(t.Native()))

	var cret C.GtkToolbarStyle
	var ret1 ToolbarStyle

	cret = C.gtk_tool_item_get_toolbar_style(arg0)

	ret1 = ToolbarStyle(cret)

	return ret1
}

// UseDragWindow returns whether @tool_item has a drag window. See
// gtk_tool_item_set_use_drag_window().
func (t toolItem) UseDragWindow() bool {
	var arg0 *C.GtkToolItem

	arg0 = (*C.GtkToolItem)(unsafe.Pointer(t.Native()))

	var cret C.gboolean
	var ret1 bool

	cret = C.gtk_tool_item_get_use_drag_window(arg0)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// VisibleHorizontal returns whether the @tool_item is visible on toolbars
// that are docked horizontally.
func (t toolItem) VisibleHorizontal() bool {
	var arg0 *C.GtkToolItem

	arg0 = (*C.GtkToolItem)(unsafe.Pointer(t.Native()))

	var cret C.gboolean
	var ret1 bool

	cret = C.gtk_tool_item_get_visible_horizontal(arg0)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// VisibleVertical returns whether @tool_item is visible when the toolbar is
// docked vertically. See gtk_tool_item_set_visible_vertical().
func (t toolItem) VisibleVertical() bool {
	var arg0 *C.GtkToolItem

	arg0 = (*C.GtkToolItem)(unsafe.Pointer(t.Native()))

	var cret C.gboolean
	var ret1 bool

	cret = C.gtk_tool_item_get_visible_vertical(arg0)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// RebuildMenu: calling this function signals to the toolbar that the
// overflow menu item for @tool_item has changed. If the overflow menu is
// visible when this function it called, the menu will be rebuilt.
//
// The function must be called when the tool item changes what it will do in
// response to the ToolItem::create-menu-proxy signal.
func (t toolItem) RebuildMenu() {
	var arg0 *C.GtkToolItem

	arg0 = (*C.GtkToolItem)(unsafe.Pointer(t.Native()))

	C.gtk_tool_item_rebuild_menu(arg0)
}

// RetrieveProxyMenuItem returns the MenuItem that was last set by
// gtk_tool_item_set_proxy_menu_item(), ie. the MenuItem that is going to
// appear in the overflow menu.
func (t toolItem) RetrieveProxyMenuItem() Widget {
	var arg0 *C.GtkToolItem

	arg0 = (*C.GtkToolItem)(unsafe.Pointer(t.Native()))

	var cret *C.GtkWidget
	var ret1 Widget

	cret = C.gtk_tool_item_retrieve_proxy_menu_item(arg0)

	ret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Widget)

	return ret1
}

// SetExpand sets whether @tool_item is allocated extra space when there is
// more room on the toolbar then needed for the items. The effect is that
// the item gets bigger when the toolbar gets bigger and smaller when the
// toolbar gets smaller.
func (t toolItem) SetExpand(expand bool) {
	var arg0 *C.GtkToolItem
	var arg1 C.gboolean

	arg0 = (*C.GtkToolItem)(unsafe.Pointer(t.Native()))
	if expand {
		arg1 = C.gboolean(1)
	}

	C.gtk_tool_item_set_expand(arg0, expand)
}

// SetHomogeneous sets whether @tool_item is to be allocated the same size
// as other homogeneous items. The effect is that all homogeneous items will
// have the same width as the widest of the items.
func (t toolItem) SetHomogeneous(homogeneous bool) {
	var arg0 *C.GtkToolItem
	var arg1 C.gboolean

	arg0 = (*C.GtkToolItem)(unsafe.Pointer(t.Native()))
	if homogeneous {
		arg1 = C.gboolean(1)
	}

	C.gtk_tool_item_set_homogeneous(arg0, homogeneous)
}

// SetIsImportant sets whether @tool_item should be considered important.
// The ToolButton class uses this property to determine whether to show or
// hide its label when the toolbar style is GTK_TOOLBAR_BOTH_HORIZ. The
// result is that only tool buttons with the “is_important” property set
// have labels, an effect known as “priority text”
func (t toolItem) SetIsImportant(isImportant bool) {
	var arg0 *C.GtkToolItem
	var arg1 C.gboolean

	arg0 = (*C.GtkToolItem)(unsafe.Pointer(t.Native()))
	if isImportant {
		arg1 = C.gboolean(1)
	}

	C.gtk_tool_item_set_is_important(arg0, isImportant)
}

// SetProxyMenuItem sets the MenuItem used in the toolbar overflow menu. The
// @menu_item_id is used to identify the caller of this function and should
// also be used with gtk_tool_item_get_proxy_menu_item().
//
// See also ToolItem::create-menu-proxy.
func (t toolItem) SetProxyMenuItem(menuItemID string, menuItem Widget) {
	var arg0 *C.GtkToolItem
	var arg1 *C.gchar
	var arg2 *C.GtkWidget

	arg0 = (*C.GtkToolItem)(unsafe.Pointer(t.Native()))
	arg1 = (*C.gchar)(C.CString(menuItemID))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GtkWidget)(unsafe.Pointer(menuItem.Native()))

	C.gtk_tool_item_set_proxy_menu_item(arg0, menuItemID, menuItem)
}

// SetTooltipMarkup sets the markup text to be displayed as tooltip on the
// item. See gtk_widget_set_tooltip_markup().
func (t toolItem) SetTooltipMarkup(markup string) {
	var arg0 *C.GtkToolItem
	var arg1 *C.gchar

	arg0 = (*C.GtkToolItem)(unsafe.Pointer(t.Native()))
	arg1 = (*C.gchar)(C.CString(markup))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_tool_item_set_tooltip_markup(arg0, markup)
}

// SetTooltipText sets the text to be displayed as tooltip on the item. See
// gtk_widget_set_tooltip_text().
func (t toolItem) SetTooltipText(text string) {
	var arg0 *C.GtkToolItem
	var arg1 *C.gchar

	arg0 = (*C.GtkToolItem)(unsafe.Pointer(t.Native()))
	arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_tool_item_set_tooltip_text(arg0, text)
}

// SetUseDragWindow sets whether @tool_item has a drag window. When true the
// toolitem can be used as a drag source through gtk_drag_source_set(). When
// @tool_item has a drag window it will intercept all events, even those
// that would otherwise be sent to a child of @tool_item.
func (t toolItem) SetUseDragWindow(useDragWindow bool) {
	var arg0 *C.GtkToolItem
	var arg1 C.gboolean

	arg0 = (*C.GtkToolItem)(unsafe.Pointer(t.Native()))
	if useDragWindow {
		arg1 = C.gboolean(1)
	}

	C.gtk_tool_item_set_use_drag_window(arg0, useDragWindow)
}

// SetVisibleHorizontal sets whether @tool_item is visible when the toolbar
// is docked horizontally.
func (t toolItem) SetVisibleHorizontal(visibleHorizontal bool) {
	var arg0 *C.GtkToolItem
	var arg1 C.gboolean

	arg0 = (*C.GtkToolItem)(unsafe.Pointer(t.Native()))
	if visibleHorizontal {
		arg1 = C.gboolean(1)
	}

	C.gtk_tool_item_set_visible_horizontal(arg0, visibleHorizontal)
}

// SetVisibleVertical sets whether @tool_item is visible when the toolbar is
// docked vertically. Some tool items, such as text entries, are too wide to
// be useful on a vertically docked toolbar. If @visible_vertical is false
// @tool_item will not appear on toolbars that are docked vertically.
func (t toolItem) SetVisibleVertical(visibleVertical bool) {
	var arg0 *C.GtkToolItem
	var arg1 C.gboolean

	arg0 = (*C.GtkToolItem)(unsafe.Pointer(t.Native()))
	if visibleVertical {
		arg1 = C.gboolean(1)
	}

	C.gtk_tool_item_set_visible_vertical(arg0, visibleVertical)
}

// ToolbarReconfigured emits the signal ToolItem::toolbar_reconfigured on
// @tool_item. Toolbar and other ToolShell implementations use this function
// to notify children, when some aspect of their configuration changes.
func (t toolItem) ToolbarReconfigured() {
	var arg0 *C.GtkToolItem

	arg0 = (*C.GtkToolItem)(unsafe.Pointer(t.Native()))

	C.gtk_tool_item_toolbar_reconfigured(arg0)
}
