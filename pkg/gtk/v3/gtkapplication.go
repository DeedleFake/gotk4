// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/core/gextras"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gtk+-3.0
// #cgo CFLAGS: -Wno-deprecated-declarations
//
// #include <glib-object.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_application_inhibit_flags_get_type()), F: marshalApplicationInhibitFlags},
		{T: externglib.Type(C.gtk_application_get_type()), F: marshalApplication},
	})
}

// ApplicationInhibitFlags types of user actions that may be blocked by
// gtk_application_inhibit().
type ApplicationInhibitFlags int

const (
	// ApplicationInhibitFlagsLogout: inhibit ending the user session by logging
	// out or by shutting down the computer
	ApplicationInhibitFlagsLogout ApplicationInhibitFlags = 0b1
	// ApplicationInhibitFlagsSwitch: inhibit user switching
	ApplicationInhibitFlagsSwitch ApplicationInhibitFlags = 0b10
	// ApplicationInhibitFlagsSuspend: inhibit suspending the session or
	// computer
	ApplicationInhibitFlagsSuspend ApplicationInhibitFlags = 0b100
	// ApplicationInhibitFlagsIdle: inhibit the session being marked as idle
	// (and possibly locked)
	ApplicationInhibitFlagsIdle ApplicationInhibitFlags = 0b1000
)

func marshalApplicationInhibitFlags(p uintptr) (interface{}, error) {
	return ApplicationInhibitFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// Application is a class that handles many important aspects of a GTK+
// application in a convenient fashion, without enforcing a one-size-fits-all
// application model.
//
// Currently, GtkApplication handles GTK+ initialization, application
// uniqueness, session management, provides some basic scriptability and desktop
// shell integration by exporting actions and menus and manages a list of
// toplevel windows whose life-cycle is automatically tied to the life-cycle of
// your application.
//
// While GtkApplication works fine with plain Windows, it is recommended to use
// it together with ApplicationWindow.
//
// When GDK threads are enabled, GtkApplication will acquire the GDK lock when
// invoking actions that arrive from other processes. The GDK lock is not
// touched for local action invocations. In order to have actions invoked in a
// predictable context it is therefore recommended that the GDK lock be held
// while invoking actions locally with g_action_group_activate_action(). The
// same applies to actions associated with ApplicationWindow and to the
// “activate” and “open” #GApplication methods.
//
//
// Automatic resources
//
// Application will automatically load menus from the Builder resource located
// at "gtk/menus.ui", relative to the application's resource base path (see
// g_application_set_resource_base_path()). The menu with the ID "app-menu" is
// taken as the application's app menu and the menu with the ID "menubar" is
// taken as the application's menubar. Additional menus (most interesting
// submenus) can be named and accessed via gtk_application_get_menu_by_id()
// which allows for dynamic population of a part of the menu structure.
//
// If the resources "gtk/menus-appmenu.ui" or "gtk/menus-traditional.ui" are
// present then these files will be used in preference, depending on the value
// of gtk_application_prefers_app_menu(). If the resource "gtk/menus-common.ui"
// is present it will be loaded as well. This is useful for storing items that
// are referenced from both "gtk/menus-appmenu.ui" and
// "gtk/menus-traditional.ui".
//
// It is also possible to provide the menus manually using
// gtk_application_set_app_menu() and gtk_application_set_menubar().
//
// Application will also automatically setup an icon search path for the default
// icon theme by appending "icons" to the resource base path. This allows your
// application to easily store its icons as resources. See
// gtk_icon_theme_add_resource_path() for more information.
//
// If there is a resource located at "gtk/help-overlay.ui" which defines a
// ShortcutsWindow with ID "help_overlay" then GtkApplication associates an
// instance of this shortcuts window with each ApplicationWindow and sets up
// keyboard accelerators (Control-F1 and Control-?) to open it. To create a menu
// item that displays the shortcuts window, associate the item with the action
// win.show-help-overlay.
//
//
// A simple application
//
// A simple example
// (https://git.gnome.org/browse/gtk+/tree/examples/bp/bloatpad.c)
//
// GtkApplication optionally registers with a session manager of the users
// session (if you set the Application:register-session property) and offers
// various functionality related to the session life-cycle.
//
// An application can block various ways to end the session with the
// gtk_application_inhibit() function. Typical use cases for this kind of
// inhibiting are long-running, uninterruptible operations, such as burning a CD
// or performing a disk backup. The session manager may not honor the inhibitor,
// but it can be expected to inform the user about the negative consequences of
// ending the session while inhibitors are present.
//
//
// See Also
//
// HowDoI: Using GtkApplication (https://wiki.gnome.org/HowDoI/GtkApplication),
// Getting Started with GTK+: Basics
// (https://developer.gnome.org/gtk3/stable/gtk-getting-started.html#id-1.2.3.3)
type Application interface {
	gio.Application
	gio.ActionGroup
	gio.ActionMap

	// AddAcceleratorApplication:
	AddAcceleratorApplication(accelerator string, actionName string, parameter *glib.Variant)
	// AddWindowApplication:
	AddWindowApplication(window Window)
	// AccelsForAction:
	AccelsForAction(detailedActionName string) []string
	// ActionsForAccel:
	ActionsForAccel(accel string) []string
	// ActiveWindow:
	ActiveWindow() Window
	// AppMenu:
	AppMenu() gio.MenuModel
	// MenuByID:
	MenuByID(id string) gio.Menu
	// Menubar:
	Menubar() gio.MenuModel
	// WindowByID:
	WindowByID(id uint) Window
	// InhibitApplication:
	InhibitApplication(window Window, flags ApplicationInhibitFlags, reason string) uint
	// IsInhibitedApplication:
	IsInhibitedApplication(flags ApplicationInhibitFlags) bool
	// ListActionDescriptionsApplication:
	ListActionDescriptionsApplication() []string
	// PrefersAppMenuApplication:
	PrefersAppMenuApplication() bool
	// RemoveAcceleratorApplication:
	RemoveAcceleratorApplication(actionName string, parameter *glib.Variant)
	// RemoveWindowApplication:
	RemoveWindowApplication(window Window)
	// SetAccelsForActionApplication:
	SetAccelsForActionApplication(detailedActionName string, accels []string)
	// SetAppMenuApplication:
	SetAppMenuApplication(appMenu gio.MenuModel)
	// SetMenubarApplication:
	SetMenubarApplication(menubar gio.MenuModel)
	// UninhibitApplication:
	UninhibitApplication(cookie uint)
}

// application implements the Application class.
type application struct {
	gio.Application
}

// WrapApplication wraps a GObject to the right type. It is
// primarily used internally.
func WrapApplication(obj *externglib.Object) Application {
	return application{
		Application: gio.WrapApplication(obj),
	}
}

func marshalApplication(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapApplication(obj), nil
}

// NewApplication:
func NewApplication(applicationId string, flags gio.ApplicationFlags) Application {
	var _arg1 *C.gchar            // out
	var _arg2 C.GApplicationFlags // out
	var _cret *C.GtkApplication   // in

	_arg1 = (*C.gchar)(C.CString(applicationId))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GApplicationFlags(flags)

	_cret = C.gtk_application_new(_arg1, _arg2)

	var _application Application // out

	_application = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Application)

	return _application
}

func (a application) AddAcceleratorApplication(accelerator string, actionName string, parameter *glib.Variant) {
	var _arg0 *C.GtkApplication // out
	var _arg1 *C.gchar          // out
	var _arg2 *C.gchar          // out
	var _arg3 *C.GVariant       // out

	_arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.gchar)(C.CString(accelerator))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(actionName))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.GVariant)(unsafe.Pointer(parameter.Native()))

	C.gtk_application_add_accelerator(_arg0, _arg1, _arg2, _arg3)
}

func (a application) AddWindowApplication(window Window) {
	var _arg0 *C.GtkApplication // out
	var _arg1 *C.GtkWindow      // out

	_arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	C.gtk_application_add_window(_arg0, _arg1)
}

func (a application) AccelsForAction(detailedActionName string) []string {
	var _arg0 *C.GtkApplication // out
	var _arg1 *C.gchar          // out
	var _cret **C.gchar

	_arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.gchar)(C.CString(detailedActionName))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_application_get_accels_for_action(_arg0, _arg1)

	var _utf8s []string

	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString(src[i])
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

func (a application) ActionsForAccel(accel string) []string {
	var _arg0 *C.GtkApplication // out
	var _arg1 *C.gchar          // out
	var _cret **C.gchar

	_arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.gchar)(C.CString(accel))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_application_get_actions_for_accel(_arg0, _arg1)

	var _utf8s []string

	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString(src[i])
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

func (a application) ActiveWindow() Window {
	var _arg0 *C.GtkApplication // out
	var _cret *C.GtkWindow      // in

	_arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_application_get_active_window(_arg0)

	var _window Window // out

	_window = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Window)

	return _window
}

func (a application) AppMenu() gio.MenuModel {
	var _arg0 *C.GtkApplication // out
	var _cret *C.GMenuModel     // in

	_arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_application_get_app_menu(_arg0)

	var _menuModel gio.MenuModel // out

	_menuModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.MenuModel)

	return _menuModel
}

func (a application) MenuByID(id string) gio.Menu {
	var _arg0 *C.GtkApplication // out
	var _arg1 *C.gchar          // out
	var _cret *C.GMenu          // in

	_arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.gchar)(C.CString(id))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_application_get_menu_by_id(_arg0, _arg1)

	var _menu gio.Menu // out

	_menu = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.Menu)

	return _menu
}

func (a application) Menubar() gio.MenuModel {
	var _arg0 *C.GtkApplication // out
	var _cret *C.GMenuModel     // in

	_arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_application_get_menubar(_arg0)

	var _menuModel gio.MenuModel // out

	_menuModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.MenuModel)

	return _menuModel
}

func (a application) WindowByID(id uint) Window {
	var _arg0 *C.GtkApplication // out
	var _arg1 C.guint           // out
	var _cret *C.GtkWindow      // in

	_arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))
	_arg1 = C.guint(id)

	_cret = C.gtk_application_get_window_by_id(_arg0, _arg1)

	var _window Window // out

	_window = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Window)

	return _window
}

func (a application) InhibitApplication(window Window, flags ApplicationInhibitFlags, reason string) uint {
	var _arg0 *C.GtkApplication            // out
	var _arg1 *C.GtkWindow                 // out
	var _arg2 C.GtkApplicationInhibitFlags // out
	var _arg3 *C.gchar                     // out
	var _cret C.guint                      // in

	_arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	_arg2 = C.GtkApplicationInhibitFlags(flags)
	_arg3 = (*C.gchar)(C.CString(reason))
	defer C.free(unsafe.Pointer(_arg3))

	_cret = C.gtk_application_inhibit(_arg0, _arg1, _arg2, _arg3)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

func (a application) IsInhibitedApplication(flags ApplicationInhibitFlags) bool {
	var _arg0 *C.GtkApplication            // out
	var _arg1 C.GtkApplicationInhibitFlags // out
	var _cret C.gboolean                   // in

	_arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))
	_arg1 = C.GtkApplicationInhibitFlags(flags)

	_cret = C.gtk_application_is_inhibited(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (a application) ListActionDescriptionsApplication() []string {
	var _arg0 *C.GtkApplication // out
	var _cret **C.gchar

	_arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_application_list_action_descriptions(_arg0)

	var _utf8s []string

	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString(src[i])
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

func (a application) PrefersAppMenuApplication() bool {
	var _arg0 *C.GtkApplication // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))

	_cret = C.gtk_application_prefers_app_menu(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (a application) RemoveAcceleratorApplication(actionName string, parameter *glib.Variant) {
	var _arg0 *C.GtkApplication // out
	var _arg1 *C.gchar          // out
	var _arg2 *C.GVariant       // out

	_arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.gchar)(C.CString(actionName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GVariant)(unsafe.Pointer(parameter.Native()))

	C.gtk_application_remove_accelerator(_arg0, _arg1, _arg2)
}

func (a application) RemoveWindowApplication(window Window) {
	var _arg0 *C.GtkApplication // out
	var _arg1 *C.GtkWindow      // out

	_arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	C.gtk_application_remove_window(_arg0, _arg1)
}

func (a application) SetAccelsForActionApplication(detailedActionName string, accels []string) {
	var _arg0 *C.GtkApplication // out
	var _arg1 *C.gchar          // out
	var _arg2 **C.gchar

	_arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.gchar)(C.CString(detailedActionName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (**C.gchar)(C.malloc(C.ulong(len(accels)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg2))
	{
		out := unsafe.Slice(_arg2, len(accels))
		for i := range accels {
			out[i] = (*C.gchar)(C.CString(accels[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	C.gtk_application_set_accels_for_action(_arg0, _arg1, _arg2)
}

func (a application) SetAppMenuApplication(appMenu gio.MenuModel) {
	var _arg0 *C.GtkApplication // out
	var _arg1 *C.GMenuModel     // out

	_arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GMenuModel)(unsafe.Pointer(appMenu.Native()))

	C.gtk_application_set_app_menu(_arg0, _arg1)
}

func (a application) SetMenubarApplication(menubar gio.MenuModel) {
	var _arg0 *C.GtkApplication // out
	var _arg1 *C.GMenuModel     // out

	_arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GMenuModel)(unsafe.Pointer(menubar.Native()))

	C.gtk_application_set_menubar(_arg0, _arg1)
}

func (a application) UninhibitApplication(cookie uint) {
	var _arg0 *C.GtkApplication // out
	var _arg1 C.guint           // out

	_arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))
	_arg1 = C.guint(cookie)

	C.gtk_application_uninhibit(_arg0, _arg1)
}

func (b application) AddChild(builder Builder, child gextras.Objector, typ string) {
	WrapBuildable(gextras.InternObject(b)).AddChild(builder, child, typ)
}

func (b application) ConstructChild(builder Builder, name string) gextras.Objector {
	return WrapBuildable(gextras.InternObject(b)).ConstructChild(builder, name)
}

func (b application) InternalChild(builder Builder, childname string) gextras.Objector {
	return WrapBuildable(gextras.InternObject(b)).InternalChild(builder, childname)
}

func (b application) Name() string {
	return WrapBuildable(gextras.InternObject(b)).Name()
}

func (b application) ParserFinished(builder Builder) {
	WrapBuildable(gextras.InternObject(b)).ParserFinished(builder)
}

func (b application) SetBuildableProperty(builder Builder, name string, value externglib.Value) {
	WrapBuildable(gextras.InternObject(b)).SetBuildableProperty(builder, name, value)
}

func (b application) SetName(name string) {
	WrapBuildable(gextras.InternObject(b)).SetName(name)
}

func (a application) ActionAdded(actionName string) {
	gio.WrapActionGroup(gextras.InternObject(a)).ActionAdded(actionName)
}

func (a application) ActionEnabledChanged(actionName string, enabled bool) {
	gio.WrapActionGroup(gextras.InternObject(a)).ActionEnabledChanged(actionName, enabled)
}

func (a application) ActionRemoved(actionName string) {
	gio.WrapActionGroup(gextras.InternObject(a)).ActionRemoved(actionName)
}

func (a application) ActionStateChanged(actionName string, state *glib.Variant) {
	gio.WrapActionGroup(gextras.InternObject(a)).ActionStateChanged(actionName, state)
}

func (a application) ActivateAction(actionName string, parameter *glib.Variant) {
	gio.WrapActionGroup(gextras.InternObject(a)).ActivateAction(actionName, parameter)
}

func (a application) ChangeActionState(actionName string, value *glib.Variant) {
	gio.WrapActionGroup(gextras.InternObject(a)).ChangeActionState(actionName, value)
}

func (a application) ActionEnabled(actionName string) bool {
	return gio.WrapActionGroup(gextras.InternObject(a)).ActionEnabled(actionName)
}

func (a application) ActionParameterType(actionName string) *glib.VariantType {
	return gio.WrapActionGroup(gextras.InternObject(a)).ActionParameterType(actionName)
}

func (a application) ActionState(actionName string) *glib.Variant {
	return gio.WrapActionGroup(gextras.InternObject(a)).ActionState(actionName)
}

func (a application) ActionStateHint(actionName string) *glib.Variant {
	return gio.WrapActionGroup(gextras.InternObject(a)).ActionStateHint(actionName)
}

func (a application) ActionStateType(actionName string) *glib.VariantType {
	return gio.WrapActionGroup(gextras.InternObject(a)).ActionStateType(actionName)
}

func (a application) HasAction(actionName string) bool {
	return gio.WrapActionGroup(gextras.InternObject(a)).HasAction(actionName)
}

func (a application) ListActions() []string {
	return gio.WrapActionGroup(gextras.InternObject(a)).ListActions()
}

func (a application) QueryAction(actionName string) (enabled bool, parameterType *glib.VariantType, stateType *glib.VariantType, stateHint *glib.Variant, state *glib.Variant, ok bool) {
	return gio.WrapActionGroup(gextras.InternObject(a)).QueryAction(actionName)
}

func (a application) AddAction(action gio.Action) {
	gio.WrapActionMap(gextras.InternObject(a)).AddAction(action)
}

func (a application) LookupAction(actionName string) gio.Action {
	return gio.WrapActionMap(gextras.InternObject(a)).LookupAction(actionName)
}

func (a application) RemoveAction(actionName string) {
	gio.WrapActionMap(gextras.InternObject(a)).RemoveAction(actionName)
}
