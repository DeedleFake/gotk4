// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/atk"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/gdk/v3"
	"github.com/diamondburned/gotk4/pkg/pango"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gtk+-3.0
// #cgo CFLAGS: -Wno-deprecated-declarations
//
// #include <glib-object.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_text_extend_selection_get_type()), F: marshalTextExtendSelection},
		{T: externglib.Type(C.gtk_text_view_layer_get_type()), F: marshalTextViewLayer},
		{T: externglib.Type(C.gtk_text_window_type_get_type()), F: marshalTextWindowType},
		{T: externglib.Type(C.gtk_text_view_get_type()), F: marshalTextViewer},
	})
}

// TextExtendSelection: granularity types that extend the text selection. Use
// the TextView::extend-selection signal to customize the selection.
type TextExtendSelection int

const (
	// Word selects the current word. It is triggered by a double-click for
	// example.
	TextExtendSelectionWord TextExtendSelection = iota
	// Line selects the current line. It is triggered by a triple-click for
	// example.
	TextExtendSelectionLine
)

func marshalTextExtendSelection(p uintptr) (interface{}, error) {
	return TextExtendSelection(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TextViewLayer: used to reference the layers of TextView for the purpose of
// customized drawing with the ::draw_layer vfunc.
type TextViewLayer int

const (
	// Below: old deprecated layer, use GTK_TEXT_VIEW_LAYER_BELOW_TEXT instead
	TextViewLayerBelow TextViewLayer = iota
	// Above: old deprecated layer, use GTK_TEXT_VIEW_LAYER_ABOVE_TEXT instead
	TextViewLayerAbove
	// BelowText: the layer rendered below the text (but above the background).
	// Since: 3.20
	TextViewLayerBelowText
	// AboveText: the layer rendered above the text. Since: 3.20
	TextViewLayerAboveText
)

func marshalTextViewLayer(p uintptr) (interface{}, error) {
	return TextViewLayer(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TextWindowType: used to reference the parts of TextView.
type TextWindowType int

const (
	// Private: invalid value, used as a marker
	TextWindowTypePrivate TextWindowType = iota
	// Widget: window that floats over scrolling areas.
	TextWindowTypeWidget
	// Text: scrollable text window.
	TextWindowTypeText
	// Left: left side border window.
	TextWindowTypeLeft
	// Right: right side border window.
	TextWindowTypeRight
	// Top: top border window.
	TextWindowTypeTop
	// Bottom: bottom border window.
	TextWindowTypeBottom
)

func marshalTextWindowType(p uintptr) (interface{}, error) {
	return TextWindowType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TextViewerOverrider contains methods that are overridable.
//
// As of right now, interface overriding and subclassing is not supported
// yet, so the interface currently has no use.
type TextViewerOverrider interface {
	Backspace()
	CopyClipboard()
	CutClipboard()
	InsertAtCursor(str string)
	InsertEmoji()
	PasteClipboard()
	PopulatePopup(popup Widgetter)
	SetAnchor()
	ToggleOverwrite()
}

// TextViewer describes TextView's methods.
type TextViewer interface {
	gextras.Objector

	AddChildAtAnchor(child Widgetter, anchor TextChildAnchorrer)
	BackwardDisplayLine(iter *TextIter) bool
	BackwardDisplayLineStart(iter *TextIter) bool
	ForwardDisplayLine(iter *TextIter) bool
	ForwardDisplayLineEnd(iter *TextIter) bool
	AcceptsTab() bool
	BottomMargin() int
	Buffer() *TextBuffer
	CursorLocations(iter *TextIter) (strong gdk.Rectangle, weak gdk.Rectangle)
	CursorVisible() bool
	DefaultAttributes() *TextAttributes
	Editable() bool
	HAdjustment() *Adjustment
	Indent() int
	InputHints() InputHints
	InputPurpose() InputPurpose
	IterAtLocation(x int, y int) (TextIter, bool)
	IterAtPosition(x int, y int) (TextIter, int, bool)
	IterLocation(iter *TextIter) gdk.Rectangle
	Justification() Justification
	LeftMargin() int
	LineAtY(y int) (TextIter, int)
	LineYrange(iter *TextIter) (y int, height int)
	Monospace() bool
	Overwrite() bool
	PixelsAboveLines() int
	PixelsBelowLines() int
	PixelsInsideWrap() int
	RightMargin() int
	Tabs() *pango.TabArray
	TopMargin() int
	VAdjustment() *Adjustment
	VisibleRect() gdk.Rectangle
	WindowType(window gdk.Windowwer) TextWindowType
	WrapMode() WrapMode
	ImContextFilterKeypress(event *gdk.EventKey) bool
	MoveChild(child Widgetter, xpos int, ypos int)
	MoveMarkOnscreen(mark TextMarker) bool
	MoveVisually(iter *TextIter, count int) bool
	PlaceCursorOnscreen() bool
	ResetCursorBlink()
	ResetImContext()
	ScrollMarkOnscreen(mark TextMarker)
	ScrollToIter(iter *TextIter, withinMargin float64, useAlign bool, xalign float64, yalign float64) bool
	ScrollToMark(mark TextMarker, withinMargin float64, useAlign bool, xalign float64, yalign float64)
	SetAcceptsTab(acceptsTab bool)
	SetBottomMargin(bottomMargin int)
	SetBuffer(buffer TextBufferrer)
	SetCursorVisible(setting bool)
	SetEditable(setting bool)
	SetIndent(indent int)
	SetLeftMargin(leftMargin int)
	SetMonospace(monospace bool)
	SetOverwrite(overwrite bool)
	SetPixelsAboveLines(pixelsAboveLines int)
	SetPixelsBelowLines(pixelsBelowLines int)
	SetPixelsInsideWrap(pixelsInsideWrap int)
	SetRightMargin(rightMargin int)
	SetTabs(tabs *pango.TabArray)
	SetTopMargin(topMargin int)
	StartsDisplayLine(iter *TextIter) bool
}

// TextView: you may wish to begin by reading the [text widget conceptual
// overview][TextWidget] which gives an overview of all the objects and data
// types related to the text widget and how they work together.
//
// CSS nodes
//
//    textview.view
//    ├── border.top
//    ├── border.left
//    ├── text
//    │   ╰── [selection]
//    ├── border.right
//    ├── border.bottom
//    ╰── [window.popup]
//
// GtkTextView has a main css node with name textview and style class .view, and
// subnodes for each of the border windows, and the main text area, with names
// border and text, respectively. The border nodes each get one of the style
// classes .left, .right, .top or .bottom.
//
// A node representing the selection will appear below the text node.
//
// If a context menu is opened, the window node will appear as a subnode of the
// main node.
type TextView struct {
	*externglib.Object

	Container
	atk.ImplementorIface
	Buildable
	Scrollable
}

var _ TextViewer = (*TextView)(nil)

func wrapTextViewer(obj *externglib.Object) TextViewer {
	return &TextView{
		Object: obj,
		Container: Container{
			Object: obj,
			Widget: Widget{
				Object: obj,
				InitiallyUnowned: externglib.InitiallyUnowned{
					Object: obj,
				},
				ImplementorIface: atk.ImplementorIface{
					Object: obj,
				},
				Buildable: Buildable{
					Object: obj,
				},
			},
			ImplementorIface: atk.ImplementorIface{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
		},
		ImplementorIface: atk.ImplementorIface{
			Object: obj,
		},
		Buildable: Buildable{
			Object: obj,
		},
		Scrollable: Scrollable{
			Object: obj,
		},
	}
}

func marshalTextViewer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapTextViewer(obj), nil
}

// NewTextView creates a new TextView. If you don’t call
// gtk_text_view_set_buffer() before using the text view, an empty default
// buffer will be created for you. Get the buffer with
// gtk_text_view_get_buffer(). If you want to specify your own buffer, consider
// gtk_text_view_new_with_buffer().
func NewTextView() *TextView {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_text_view_new()

	var _textView *TextView // out

	_textView = (gextras.CastObject(externglib.Take(unsafe.Pointer(_cret)))).(*TextView)

	return _textView
}

// NewTextViewWithBuffer creates a new TextView widget displaying the buffer
// @buffer. One buffer can be shared among many widgets. @buffer may be nil to
// create a default buffer, in which case this function is equivalent to
// gtk_text_view_new(). The text view adds its own reference count to the
// buffer; it does not take over an existing reference.
func NewTextViewWithBuffer(buffer TextBufferrer) *TextView {
	var _arg1 *C.GtkTextBuffer // out
	var _cret *C.GtkWidget     // in

	_arg1 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))

	_cret = C.gtk_text_view_new_with_buffer(_arg1)

	var _textView *TextView // out

	_textView = (gextras.CastObject(externglib.Take(unsafe.Pointer(_cret)))).(*TextView)

	return _textView
}

// AddChildAtAnchor adds a child widget in the text buffer, at the given
// @anchor.
func (textView *TextView) AddChildAtAnchor(child Widgetter, anchor TextChildAnchorrer) {
	var _arg0 *C.GtkTextView        // out
	var _arg1 *C.GtkWidget          // out
	var _arg2 *C.GtkTextChildAnchor // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.GtkTextChildAnchor)(unsafe.Pointer(anchor.Native()))

	C.gtk_text_view_add_child_at_anchor(_arg0, _arg1, _arg2)
}

// BackwardDisplayLine moves the given @iter backward by one display (wrapped)
// line. A display line is different from a paragraph. Paragraphs are separated
// by newlines or other paragraph separator characters. Display lines are
// created by line-wrapping a paragraph. If wrapping is turned off, display
// lines and paragraphs will be the same. Display lines are divided differently
// for each view, since they depend on the view’s width; paragraphs are the same
// in all views, since they depend on the contents of the TextBuffer.
func (textView *TextView) BackwardDisplayLine(iter *TextIter) bool {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter))

	_cret = C.gtk_text_view_backward_display_line(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BackwardDisplayLineStart moves the given @iter backward to the next display
// line start. A display line is different from a paragraph. Paragraphs are
// separated by newlines or other paragraph separator characters. Display lines
// are created by line-wrapping a paragraph. If wrapping is turned off, display
// lines and paragraphs will be the same. Display lines are divided differently
// for each view, since they depend on the view’s width; paragraphs are the same
// in all views, since they depend on the contents of the TextBuffer.
func (textView *TextView) BackwardDisplayLineStart(iter *TextIter) bool {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter))

	_cret = C.gtk_text_view_backward_display_line_start(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForwardDisplayLine moves the given @iter forward by one display (wrapped)
// line. A display line is different from a paragraph. Paragraphs are separated
// by newlines or other paragraph separator characters. Display lines are
// created by line-wrapping a paragraph. If wrapping is turned off, display
// lines and paragraphs will be the same. Display lines are divided differently
// for each view, since they depend on the view’s width; paragraphs are the same
// in all views, since they depend on the contents of the TextBuffer.
func (textView *TextView) ForwardDisplayLine(iter *TextIter) bool {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter))

	_cret = C.gtk_text_view_forward_display_line(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForwardDisplayLineEnd moves the given @iter forward to the next display line
// end. A display line is different from a paragraph. Paragraphs are separated
// by newlines or other paragraph separator characters. Display lines are
// created by line-wrapping a paragraph. If wrapping is turned off, display
// lines and paragraphs will be the same. Display lines are divided differently
// for each view, since they depend on the view’s width; paragraphs are the same
// in all views, since they depend on the contents of the TextBuffer.
func (textView *TextView) ForwardDisplayLineEnd(iter *TextIter) bool {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter))

	_cret = C.gtk_text_view_forward_display_line_end(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// AcceptsTab returns whether pressing the Tab key inserts a tab characters.
// gtk_text_view_set_accepts_tab().
func (textView *TextView) AcceptsTab() bool {
	var _arg0 *C.GtkTextView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))

	_cret = C.gtk_text_view_get_accepts_tab(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BottomMargin gets the bottom margin for text in the @text_view.
func (textView *TextView) BottomMargin() int {
	var _arg0 *C.GtkTextView // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))

	_cret = C.gtk_text_view_get_bottom_margin(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Buffer returns the TextBuffer being displayed by this text view. The
// reference count on the buffer is not incremented; the caller of this function
// won’t own a new reference.
func (textView *TextView) Buffer() *TextBuffer {
	var _arg0 *C.GtkTextView   // out
	var _cret *C.GtkTextBuffer // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))

	_cret = C.gtk_text_view_get_buffer(_arg0)

	var _textBuffer *TextBuffer // out

	_textBuffer = (gextras.CastObject(externglib.Take(unsafe.Pointer(_cret)))).(*TextBuffer)

	return _textBuffer
}

// CursorLocations: given an @iter within a text layout, determine the positions
// of the strong and weak cursors if the insertion point is at that iterator.
// The position of each cursor is stored as a zero-width rectangle. The strong
// cursor location is the location where characters of the directionality equal
// to the base direction of the paragraph are inserted. The weak cursor location
// is the location where characters of the directionality opposite to the base
// direction of the paragraph are inserted.
//
// If @iter is nil, the actual cursor position is used.
//
// Note that if @iter happens to be the actual cursor position, and there is
// currently an IM preedit sequence being entered, the returned locations will
// be adjusted to account for the preedit cursor’s offset within the preedit
// sequence.
//
// The rectangle position is in buffer coordinates; use
// gtk_text_view_buffer_to_window_coords() to convert these coordinates to
// coordinates for one of the windows in the text view.
func (textView *TextView) CursorLocations(iter *TextIter) (strong gdk.Rectangle, weak gdk.Rectangle) {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextIter // out
	var _arg2 C.GdkRectangle // in
	var _arg3 C.GdkRectangle // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter))

	C.gtk_text_view_get_cursor_locations(_arg0, _arg1, &_arg2, &_arg3)

	var _strong gdk.Rectangle // out
	var _weak gdk.Rectangle   // out

	_strong = *(*gdk.Rectangle)(unsafe.Pointer((&_arg2)))
	_weak = *(*gdk.Rectangle)(unsafe.Pointer((&_arg3)))

	return _strong, _weak
}

// CursorVisible: find out whether the cursor should be displayed.
func (textView *TextView) CursorVisible() bool {
	var _arg0 *C.GtkTextView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))

	_cret = C.gtk_text_view_get_cursor_visible(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DefaultAttributes obtains a copy of the default text attributes. These are
// the attributes used for text unless a tag overrides them. You’d typically
// pass the default attributes in to gtk_text_iter_get_attributes() in order to
// get the attributes in effect at a given text position.
//
// The return value is a copy owned by the caller of this function, and should
// be freed with gtk_text_attributes_unref().
func (textView *TextView) DefaultAttributes() *TextAttributes {
	var _arg0 *C.GtkTextView       // out
	var _cret *C.GtkTextAttributes // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))

	_cret = C.gtk_text_view_get_default_attributes(_arg0)

	var _textAttributes *TextAttributes // out

	_textAttributes = (*TextAttributes)(unsafe.Pointer(_cret))
	C.gtk_text_attributes_ref(_cret)
	runtime.SetFinalizer(_textAttributes, func(v *TextAttributes) {
		C.gtk_text_attributes_unref((*C.GtkTextAttributes)(unsafe.Pointer(v)))
	})

	return _textAttributes
}

// Editable returns the default editability of the TextView. Tags in the buffer
// may override this setting for some ranges of text.
func (textView *TextView) Editable() bool {
	var _arg0 *C.GtkTextView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))

	_cret = C.gtk_text_view_get_editable(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HAdjustment gets the horizontal-scrolling Adjustment.
//
// Deprecated: Use gtk_scrollable_get_hadjustment().
func (textView *TextView) HAdjustment() *Adjustment {
	var _arg0 *C.GtkTextView   // out
	var _cret *C.GtkAdjustment // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))

	_cret = C.gtk_text_view_get_hadjustment(_arg0)

	var _adjustment *Adjustment // out

	_adjustment = (gextras.CastObject(externglib.Take(unsafe.Pointer(_cret)))).(*Adjustment)

	return _adjustment
}

// Indent gets the default indentation of paragraphs in @text_view. Tags in the
// view’s buffer may override the default. The indentation may be negative.
func (textView *TextView) Indent() int {
	var _arg0 *C.GtkTextView // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))

	_cret = C.gtk_text_view_get_indent(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// InputHints gets the value of the TextView:input-hints property.
func (textView *TextView) InputHints() InputHints {
	var _arg0 *C.GtkTextView  // out
	var _cret C.GtkInputHints // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))

	_cret = C.gtk_text_view_get_input_hints(_arg0)

	var _inputHints InputHints // out

	_inputHints = (InputHints)(_cret)

	return _inputHints
}

// InputPurpose gets the value of the TextView:input-purpose property.
func (textView *TextView) InputPurpose() InputPurpose {
	var _arg0 *C.GtkTextView    // out
	var _cret C.GtkInputPurpose // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))

	_cret = C.gtk_text_view_get_input_purpose(_arg0)

	var _inputPurpose InputPurpose // out

	_inputPurpose = (InputPurpose)(_cret)

	return _inputPurpose
}

// IterAtLocation retrieves the iterator at buffer coordinates @x and @y. Buffer
// coordinates are coordinates for the entire buffer, not just the
// currently-displayed portion. If you have coordinates from an event, you have
// to convert those to buffer coordinates with
// gtk_text_view_window_to_buffer_coords().
func (textView *TextView) IterAtLocation(x int, y int) (TextIter, bool) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.GtkTextIter  // in
	var _arg2 C.gint         // out
	var _arg3 C.gint         // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))
	_arg2 = C.gint(x)
	_arg3 = C.gint(y)

	_cret = C.gtk_text_view_get_iter_at_location(_arg0, &_arg1, _arg2, _arg3)

	var _iter TextIter // out
	var _ok bool       // out

	_iter = *(*TextIter)(unsafe.Pointer((&_arg1)))
	if _cret != 0 {
		_ok = true
	}

	return _iter, _ok
}

// IterAtPosition retrieves the iterator pointing to the character at buffer
// coordinates @x and @y. Buffer coordinates are coordinates for the entire
// buffer, not just the currently-displayed portion. If you have coordinates
// from an event, you have to convert those to buffer coordinates with
// gtk_text_view_window_to_buffer_coords().
//
// Note that this is different from gtk_text_view_get_iter_at_location(), which
// returns cursor locations, i.e. positions between characters.
func (textView *TextView) IterAtPosition(x int, y int) (TextIter, int, bool) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.GtkTextIter  // in
	var _arg2 C.gint         // in
	var _arg3 C.gint         // out
	var _arg4 C.gint         // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))
	_arg3 = C.gint(x)
	_arg4 = C.gint(y)

	_cret = C.gtk_text_view_get_iter_at_position(_arg0, &_arg1, &_arg2, _arg3, _arg4)

	var _iter TextIter // out
	var _trailing int  // out
	var _ok bool       // out

	_iter = *(*TextIter)(unsafe.Pointer((&_arg1)))
	_trailing = int(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _iter, _trailing, _ok
}

// IterLocation gets a rectangle which roughly contains the character at @iter.
// The rectangle position is in buffer coordinates; use
// gtk_text_view_buffer_to_window_coords() to convert these coordinates to
// coordinates for one of the windows in the text view.
func (textView *TextView) IterLocation(iter *TextIter) gdk.Rectangle {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextIter // out
	var _arg2 C.GdkRectangle // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter))

	C.gtk_text_view_get_iter_location(_arg0, _arg1, &_arg2)

	var _location gdk.Rectangle // out

	_location = *(*gdk.Rectangle)(unsafe.Pointer((&_arg2)))

	return _location
}

// Justification gets the default justification of paragraphs in @text_view.
// Tags in the buffer may override the default.
func (textView *TextView) Justification() Justification {
	var _arg0 *C.GtkTextView     // out
	var _cret C.GtkJustification // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))

	_cret = C.gtk_text_view_get_justification(_arg0)

	var _justification Justification // out

	_justification = (Justification)(_cret)

	return _justification
}

// LeftMargin gets the default left margin size of paragraphs in the @text_view.
// Tags in the buffer may override the default.
func (textView *TextView) LeftMargin() int {
	var _arg0 *C.GtkTextView // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))

	_cret = C.gtk_text_view_get_left_margin(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// LineAtY gets the TextIter at the start of the line containing the coordinate
// @y. @y is in buffer coordinates, convert from window coordinates with
// gtk_text_view_window_to_buffer_coords(). If non-nil, @line_top will be filled
// with the coordinate of the top edge of the line.
func (textView *TextView) LineAtY(y int) (TextIter, int) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.GtkTextIter  // in
	var _arg2 C.gint         // out
	var _arg3 C.gint         // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))
	_arg2 = C.gint(y)

	C.gtk_text_view_get_line_at_y(_arg0, &_arg1, _arg2, &_arg3)

	var _targetIter TextIter // out
	var _lineTop int         // out

	_targetIter = *(*TextIter)(unsafe.Pointer((&_arg1)))
	_lineTop = int(_arg3)

	return _targetIter, _lineTop
}

// LineYrange gets the y coordinate of the top of the line containing @iter, and
// the height of the line. The coordinate is a buffer coordinate; convert to
// window coordinates with gtk_text_view_buffer_to_window_coords().
func (textView *TextView) LineYrange(iter *TextIter) (y int, height int) {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextIter // out
	var _arg2 C.gint         // in
	var _arg3 C.gint         // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter))

	C.gtk_text_view_get_line_yrange(_arg0, _arg1, &_arg2, &_arg3)

	var _y int      // out
	var _height int // out

	_y = int(_arg2)
	_height = int(_arg3)

	return _y, _height
}

// Monospace gets the value of the TextView:monospace property.
func (textView *TextView) Monospace() bool {
	var _arg0 *C.GtkTextView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))

	_cret = C.gtk_text_view_get_monospace(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Overwrite returns whether the TextView is in overwrite mode or not.
func (textView *TextView) Overwrite() bool {
	var _arg0 *C.GtkTextView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))

	_cret = C.gtk_text_view_get_overwrite(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PixelsAboveLines gets the default number of pixels to put above paragraphs.
// Adding this function with gtk_text_view_get_pixels_below_lines() is equal to
// the line space between each paragraph.
func (textView *TextView) PixelsAboveLines() int {
	var _arg0 *C.GtkTextView // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))

	_cret = C.gtk_text_view_get_pixels_above_lines(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// PixelsBelowLines gets the value set by
// gtk_text_view_set_pixels_below_lines().
//
// The line space is the sum of the value returned by this function and the
// value returned by gtk_text_view_get_pixels_above_lines().
func (textView *TextView) PixelsBelowLines() int {
	var _arg0 *C.GtkTextView // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))

	_cret = C.gtk_text_view_get_pixels_below_lines(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// PixelsInsideWrap gets the value set by
// gtk_text_view_set_pixels_inside_wrap().
func (textView *TextView) PixelsInsideWrap() int {
	var _arg0 *C.GtkTextView // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))

	_cret = C.gtk_text_view_get_pixels_inside_wrap(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// RightMargin gets the default right margin for text in @text_view. Tags in the
// buffer may override the default.
func (textView *TextView) RightMargin() int {
	var _arg0 *C.GtkTextView // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))

	_cret = C.gtk_text_view_get_right_margin(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Tabs gets the default tabs for @text_view. Tags in the buffer may override
// the defaults. The returned array will be nil if “standard” (8-space) tabs are
// used. Free the return value with pango_tab_array_free().
func (textView *TextView) Tabs() *pango.TabArray {
	var _arg0 *C.GtkTextView   // out
	var _cret *C.PangoTabArray // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))

	_cret = C.gtk_text_view_get_tabs(_arg0)

	var _tabArray *pango.TabArray // out

	_tabArray = (*pango.TabArray)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_tabArray, func(v *pango.TabArray) {
		C.pango_tab_array_free((*C.PangoTabArray)(unsafe.Pointer(v)))
	})

	return _tabArray
}

// TopMargin gets the top margin for text in the @text_view.
func (textView *TextView) TopMargin() int {
	var _arg0 *C.GtkTextView // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))

	_cret = C.gtk_text_view_get_top_margin(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// VAdjustment gets the vertical-scrolling Adjustment.
//
// Deprecated: Use gtk_scrollable_get_vadjustment().
func (textView *TextView) VAdjustment() *Adjustment {
	var _arg0 *C.GtkTextView   // out
	var _cret *C.GtkAdjustment // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))

	_cret = C.gtk_text_view_get_vadjustment(_arg0)

	var _adjustment *Adjustment // out

	_adjustment = (gextras.CastObject(externglib.Take(unsafe.Pointer(_cret)))).(*Adjustment)

	return _adjustment
}

// VisibleRect fills @visible_rect with the currently-visible region of the
// buffer, in buffer coordinates. Convert to window coordinates with
// gtk_text_view_buffer_to_window_coords().
func (textView *TextView) VisibleRect() gdk.Rectangle {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.GdkRectangle // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))

	C.gtk_text_view_get_visible_rect(_arg0, &_arg1)

	var _visibleRect gdk.Rectangle // out

	_visibleRect = *(*gdk.Rectangle)(unsafe.Pointer((&_arg1)))

	return _visibleRect
}

// WindowType: usually used to find out which window an event corresponds to.
//
// If you connect to an event signal on @text_view, this function should be
// called on `event->window` to see which window it was.
func (textView *TextView) WindowType(window gdk.Windowwer) TextWindowType {
	var _arg0 *C.GtkTextView      // out
	var _arg1 *C.GdkWindow        // out
	var _cret C.GtkTextWindowType // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))
	_arg1 = (*C.GdkWindow)(unsafe.Pointer(window.Native()))

	_cret = C.gtk_text_view_get_window_type(_arg0, _arg1)

	var _textWindowType TextWindowType // out

	_textWindowType = (TextWindowType)(_cret)

	return _textWindowType
}

// WrapMode gets the line wrapping for the view.
func (textView *TextView) WrapMode() WrapMode {
	var _arg0 *C.GtkTextView // out
	var _cret C.GtkWrapMode  // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))

	_cret = C.gtk_text_view_get_wrap_mode(_arg0)

	var _wrapMode WrapMode // out

	_wrapMode = (WrapMode)(_cret)

	return _wrapMode
}

// ImContextFilterKeypress: allow the TextView input method to internally handle
// key press and release events. If this function returns true, then no further
// processing should be done for this key event. See
// gtk_im_context_filter_keypress().
//
// Note that you are expected to call this function from your handler when
// overriding key event handling. This is needed in the case when you need to
// insert your own key handling between the input method and the default key
// event handling of the TextView.
//
//    static gboolean
//    gtk_foo_bar_key_press_event (GtkWidget   *widget,
//                                 GdkEventKey *event)
//    {
//      guint keyval;
//
//      gdk_event_get_keyval ((GdkEvent*)event, &keyval);
//
//      if (keyval == GDK_KEY_Return || keyval == GDK_KEY_KP_Enter)
//        {
//          if (gtk_text_view_im_context_filter_keypress (GTK_TEXT_VIEW (widget), event))
//            return TRUE;
//        }
//
//      // Do some stuff
//
//      return GTK_WIDGET_CLASS (gtk_foo_bar_parent_class)->key_press_event (widget, event);
//    }
func (textView *TextView) ImContextFilterKeypress(event *gdk.EventKey) bool {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GdkEventKey // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))
	_arg1 = (*C.GdkEventKey)(unsafe.Pointer(event))

	_cret = C.gtk_text_view_im_context_filter_keypress(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MoveChild updates the position of a child, as for
// gtk_text_view_add_child_in_window().
func (textView *TextView) MoveChild(child Widgetter, xpos int, ypos int) {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkWidget   // out
	var _arg2 C.gint         // out
	var _arg3 C.gint         // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = C.gint(xpos)
	_arg3 = C.gint(ypos)

	C.gtk_text_view_move_child(_arg0, _arg1, _arg2, _arg3)
}

// MoveMarkOnscreen moves a mark within the buffer so that it's located within
// the currently-visible text area.
func (textView *TextView) MoveMarkOnscreen(mark TextMarker) bool {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextMark // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))
	_arg1 = (*C.GtkTextMark)(unsafe.Pointer(mark.Native()))

	_cret = C.gtk_text_view_move_mark_onscreen(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MoveVisually: move the iterator a given number of characters visually,
// treating it as the strong cursor position. If @count is positive, then the
// new strong cursor position will be @count positions to the right of the old
// cursor position. If @count is negative then the new strong cursor position
// will be @count positions to the left of the old cursor position.
//
// In the presence of bi-directional text, the correspondence between logical
// and visual order will depend on the direction of the current run, and there
// may be jumps when the cursor is moved off of the end of a run.
func (textView *TextView) MoveVisually(iter *TextIter, count int) bool {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextIter // out
	var _arg2 C.gint         // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter))
	_arg2 = C.gint(count)

	_cret = C.gtk_text_view_move_visually(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PlaceCursorOnscreen moves the cursor to the currently visible region of the
// buffer, it it isn’t there already.
func (textView *TextView) PlaceCursorOnscreen() bool {
	var _arg0 *C.GtkTextView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))

	_cret = C.gtk_text_view_place_cursor_onscreen(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ResetCursorBlink ensures that the cursor is shown (i.e. not in an 'off' blink
// interval) and resets the time that it will stay blinking (or visible, in case
// blinking is disabled).
//
// This function should be called in response to user input (e.g. from derived
// classes that override the textview's Widget::key-press-event handler).
func (textView *TextView) ResetCursorBlink() {
	var _arg0 *C.GtkTextView // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))

	C.gtk_text_view_reset_cursor_blink(_arg0)
}

// ResetImContext: reset the input method context of the text view if needed.
//
// This can be necessary in the case where modifying the buffer would confuse
// on-going input method behavior.
func (textView *TextView) ResetImContext() {
	var _arg0 *C.GtkTextView // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))

	C.gtk_text_view_reset_im_context(_arg0)
}

// ScrollMarkOnscreen scrolls @text_view the minimum distance such that @mark is
// contained within the visible area of the widget.
func (textView *TextView) ScrollMarkOnscreen(mark TextMarker) {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextMark // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))
	_arg1 = (*C.GtkTextMark)(unsafe.Pointer(mark.Native()))

	C.gtk_text_view_scroll_mark_onscreen(_arg0, _arg1)
}

// ScrollToIter scrolls @text_view so that @iter is on the screen in the
// position indicated by @xalign and @yalign. An alignment of 0.0 indicates left
// or top, 1.0 indicates right or bottom, 0.5 means center. If @use_align is
// false, the text scrolls the minimal distance to get the mark onscreen,
// possibly not scrolling at all. The effective screen for purposes of this
// function is reduced by a margin of size @within_margin.
//
// Note that this function uses the currently-computed height of the lines in
// the text buffer. Line heights are computed in an idle handler; so this
// function may not have the desired effect if it’s called before the height
// computations. To avoid oddness, consider using gtk_text_view_scroll_to_mark()
// which saves a point to be scrolled to after line validation.
func (textView *TextView) ScrollToIter(iter *TextIter, withinMargin float64, useAlign bool, xalign float64, yalign float64) bool {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextIter // out
	var _arg2 C.gdouble      // out
	var _arg3 C.gboolean     // out
	var _arg4 C.gdouble      // out
	var _arg5 C.gdouble      // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter))
	_arg2 = C.gdouble(withinMargin)
	if useAlign {
		_arg3 = C.TRUE
	}
	_arg4 = C.gdouble(xalign)
	_arg5 = C.gdouble(yalign)

	_cret = C.gtk_text_view_scroll_to_iter(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ScrollToMark scrolls @text_view so that @mark is on the screen in the
// position indicated by @xalign and @yalign. An alignment of 0.0 indicates left
// or top, 1.0 indicates right or bottom, 0.5 means center. If @use_align is
// false, the text scrolls the minimal distance to get the mark onscreen,
// possibly not scrolling at all. The effective screen for purposes of this
// function is reduced by a margin of size @within_margin.
func (textView *TextView) ScrollToMark(mark TextMarker, withinMargin float64, useAlign bool, xalign float64, yalign float64) {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextMark // out
	var _arg2 C.gdouble      // out
	var _arg3 C.gboolean     // out
	var _arg4 C.gdouble      // out
	var _arg5 C.gdouble      // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))
	_arg1 = (*C.GtkTextMark)(unsafe.Pointer(mark.Native()))
	_arg2 = C.gdouble(withinMargin)
	if useAlign {
		_arg3 = C.TRUE
	}
	_arg4 = C.gdouble(xalign)
	_arg5 = C.gdouble(yalign)

	C.gtk_text_view_scroll_to_mark(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
}

// SetAcceptsTab sets the behavior of the text widget when the Tab key is
// pressed. If @accepts_tab is true, a tab character is inserted. If
// @accepts_tab is false the keyboard focus is moved to the next widget in the
// focus chain.
func (textView *TextView) SetAcceptsTab(acceptsTab bool) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))
	if acceptsTab {
		_arg1 = C.TRUE
	}

	C.gtk_text_view_set_accepts_tab(_arg0, _arg1)
}

// SetBottomMargin sets the bottom margin for text in @text_view.
//
// Note that this function is confusingly named. In CSS terms, the value set
// here is padding.
func (textView *TextView) SetBottomMargin(bottomMargin int) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.gint         // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))
	_arg1 = C.gint(bottomMargin)

	C.gtk_text_view_set_bottom_margin(_arg0, _arg1)
}

// SetBuffer sets @buffer as the buffer being displayed by @text_view. The
// previous buffer displayed by the text view is unreferenced, and a reference
// is added to @buffer. If you owned a reference to @buffer before passing it to
// this function, you must remove that reference yourself; TextView will not
// “adopt” it.
func (textView *TextView) SetBuffer(buffer TextBufferrer) {
	var _arg0 *C.GtkTextView   // out
	var _arg1 *C.GtkTextBuffer // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))
	_arg1 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))

	C.gtk_text_view_set_buffer(_arg0, _arg1)
}

// SetCursorVisible toggles whether the insertion point should be displayed. A
// buffer with no editable text probably shouldn’t have a visible cursor, so you
// may want to turn the cursor off.
//
// Note that this property may be overridden by the
// Settings:gtk-keynave-use-caret settings.
func (textView *TextView) SetCursorVisible(setting bool) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_text_view_set_cursor_visible(_arg0, _arg1)
}

// SetEditable sets the default editability of the TextView. You can override
// this default setting with tags in the buffer, using the “editable” attribute
// of tags.
func (textView *TextView) SetEditable(setting bool) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_text_view_set_editable(_arg0, _arg1)
}

// SetIndent sets the default indentation for paragraphs in @text_view. Tags in
// the buffer may override the default.
func (textView *TextView) SetIndent(indent int) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.gint         // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))
	_arg1 = C.gint(indent)

	C.gtk_text_view_set_indent(_arg0, _arg1)
}

// SetLeftMargin sets the default left margin for text in @text_view. Tags in
// the buffer may override the default.
//
// Note that this function is confusingly named. In CSS terms, the value set
// here is padding.
func (textView *TextView) SetLeftMargin(leftMargin int) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.gint         // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))
	_arg1 = C.gint(leftMargin)

	C.gtk_text_view_set_left_margin(_arg0, _arg1)
}

// SetMonospace sets the TextView:monospace property, which indicates that the
// text view should use monospace fonts.
func (textView *TextView) SetMonospace(monospace bool) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))
	if monospace {
		_arg1 = C.TRUE
	}

	C.gtk_text_view_set_monospace(_arg0, _arg1)
}

// SetOverwrite changes the TextView overwrite mode.
func (textView *TextView) SetOverwrite(overwrite bool) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))
	if overwrite {
		_arg1 = C.TRUE
	}

	C.gtk_text_view_set_overwrite(_arg0, _arg1)
}

// SetPixelsAboveLines sets the default number of blank pixels above paragraphs
// in @text_view. Tags in the buffer for @text_view may override the defaults.
func (textView *TextView) SetPixelsAboveLines(pixelsAboveLines int) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.gint         // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))
	_arg1 = C.gint(pixelsAboveLines)

	C.gtk_text_view_set_pixels_above_lines(_arg0, _arg1)
}

// SetPixelsBelowLines sets the default number of pixels of blank space to put
// below paragraphs in @text_view. May be overridden by tags applied to
// @text_view’s buffer.
func (textView *TextView) SetPixelsBelowLines(pixelsBelowLines int) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.gint         // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))
	_arg1 = C.gint(pixelsBelowLines)

	C.gtk_text_view_set_pixels_below_lines(_arg0, _arg1)
}

// SetPixelsInsideWrap sets the default number of pixels of blank space to leave
// between display/wrapped lines within a paragraph. May be overridden by tags
// in @text_view’s buffer.
func (textView *TextView) SetPixelsInsideWrap(pixelsInsideWrap int) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.gint         // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))
	_arg1 = C.gint(pixelsInsideWrap)

	C.gtk_text_view_set_pixels_inside_wrap(_arg0, _arg1)
}

// SetRightMargin sets the default right margin for text in the text view. Tags
// in the buffer may override the default.
//
// Note that this function is confusingly named. In CSS terms, the value set
// here is padding.
func (textView *TextView) SetRightMargin(rightMargin int) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.gint         // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))
	_arg1 = C.gint(rightMargin)

	C.gtk_text_view_set_right_margin(_arg0, _arg1)
}

// SetTabs sets the default tab stops for paragraphs in @text_view. Tags in the
// buffer may override the default.
func (textView *TextView) SetTabs(tabs *pango.TabArray) {
	var _arg0 *C.GtkTextView   // out
	var _arg1 *C.PangoTabArray // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))
	_arg1 = (*C.PangoTabArray)(unsafe.Pointer(tabs))

	C.gtk_text_view_set_tabs(_arg0, _arg1)
}

// SetTopMargin sets the top margin for text in @text_view.
//
// Note that this function is confusingly named. In CSS terms, the value set
// here is padding.
func (textView *TextView) SetTopMargin(topMargin int) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.gint         // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))
	_arg1 = C.gint(topMargin)

	C.gtk_text_view_set_top_margin(_arg0, _arg1)
}

// StartsDisplayLine determines whether @iter is at the start of a display line.
// See gtk_text_view_forward_display_line() for an explanation of display lines
// vs. paragraphs.
func (textView *TextView) StartsDisplayLine(iter *TextIter) bool {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter))

	_cret = C.gtk_text_view_starts_display_line(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}
