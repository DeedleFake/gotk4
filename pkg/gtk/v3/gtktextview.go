// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/internal/gextras"
	"github.com/diamondburned/gotk4/pkg/gdk/v3"
	"github.com/diamondburned/gotk4/pkg/pango"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config:
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <stdbool.h>
// #include <glib-object.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_text_view_get_type()), F: marshalTextView},
	})
}

// TextView: you may wish to begin by reading the [text widget conceptual
// overview][TextWidget] which gives an overview of all the objects and data
// types related to the text widget and how they work together.
//
// CSS nodes
//
//    textview.view
//    ├── border.top
//    ├── border.left
//    ├── text
//    │   ╰── [selection]
//    ├── border.right
//    ├── border.bottom
//    ╰── [window.popup]
//
// GtkTextView has a main css node with name textview and style class .view, and
// subnodes for each of the border windows, and the main text area, with names
// border and text, respectively. The border nodes each get one of the style
// classes .left, .right, .top or .bottom.
//
// A node representing the selection will appear below the text node.
//
// If a context menu is opened, the window node will appear as a subnode of the
// main node.
type TextView interface {
	Container
	Buildable
	Scrollable

	// AddChildAtAnchor adds a child widget in the text buffer, at the given
	// @anchor.
	AddChildAtAnchor(child Widget, anchor TextChildAnchor)
	// AddChildInWindow adds a child at fixed coordinates in one of the text
	// widget's windows.
	//
	// The window must have nonzero size (see
	// gtk_text_view_set_border_window_size()). Note that the child coordinates
	// are given relative to scrolling. When placing a child in
	// K_TEXT_WINDOW_WIDGET, scrolling is irrelevant, the child floats above all
	// scrollable areas. But when placing a child in one of the scrollable
	// windows (border windows or text window) it will move with the scrolling
	// as needed.
	AddChildInWindow(child Widget, whichWindow TextWindowType, xpos int, ypos int)
	// BackwardDisplayLine moves the given @iter backward by one display
	// (wrapped) line. A display line is different from a paragraph. Paragraphs
	// are separated by newlines or other paragraph separator characters.
	// Display lines are created by line-wrapping a paragraph. If wrapping is
	// turned off, display lines and paragraphs will be the same. Display lines
	// are divided differently for each view, since they depend on the view’s
	// width; paragraphs are the same in all views, since they depend on the
	// contents of the TextBuffer.
	BackwardDisplayLine(iter *TextIter) bool
	// BackwardDisplayLineStart moves the given @iter backward to the next
	// display line start. A display line is different from a paragraph.
	// Paragraphs are separated by newlines or other paragraph separator
	// characters. Display lines are created by line-wrapping a paragraph. If
	// wrapping is turned off, display lines and paragraphs will be the same.
	// Display lines are divided differently for each view, since they depend on
	// the view’s width; paragraphs are the same in all views, since they depend
	// on the contents of the TextBuffer.
	BackwardDisplayLineStart(iter *TextIter) bool
	// BufferToWindowCoords converts coordinate (@buffer_x, @buffer_y) to
	// coordinates for the window @win, and stores the result in (@window_x,
	// @window_y).
	//
	// Note that you can’t convert coordinates for a nonexisting window (see
	// gtk_text_view_set_border_window_size()).
	BufferToWindowCoords(win TextWindowType, bufferX int, bufferY int) (windowX int, windowY int)
	// ForwardDisplayLine moves the given @iter forward by one display (wrapped)
	// line. A display line is different from a paragraph. Paragraphs are
	// separated by newlines or other paragraph separator characters. Display
	// lines are created by line-wrapping a paragraph. If wrapping is turned
	// off, display lines and paragraphs will be the same. Display lines are
	// divided differently for each view, since they depend on the view’s width;
	// paragraphs are the same in all views, since they depend on the contents
	// of the TextBuffer.
	ForwardDisplayLine(iter *TextIter) bool
	// ForwardDisplayLineEnd moves the given @iter forward to the next display
	// line end. A display line is different from a paragraph. Paragraphs are
	// separated by newlines or other paragraph separator characters. Display
	// lines are created by line-wrapping a paragraph. If wrapping is turned
	// off, display lines and paragraphs will be the same. Display lines are
	// divided differently for each view, since they depend on the view’s width;
	// paragraphs are the same in all views, since they depend on the contents
	// of the TextBuffer.
	ForwardDisplayLineEnd(iter *TextIter) bool
	// AcceptsTab returns whether pressing the Tab key inserts a tab characters.
	// gtk_text_view_set_accepts_tab().
	AcceptsTab() bool
	// BorderWindowSize gets the width of the specified border window. See
	// gtk_text_view_set_border_window_size().
	BorderWindowSize(typ TextWindowType) int
	// BottomMargin gets the bottom margin for text in the @text_view.
	BottomMargin() int
	// Buffer returns the TextBuffer being displayed by this text view. The
	// reference count on the buffer is not incremented; the caller of this
	// function won’t own a new reference.
	Buffer() TextBuffer
	// CursorLocations: given an @iter within a text layout, determine the
	// positions of the strong and weak cursors if the insertion point is at
	// that iterator. The position of each cursor is stored as a zero-width
	// rectangle. The strong cursor location is the location where characters of
	// the directionality equal to the base direction of the paragraph are
	// inserted. The weak cursor location is the location where characters of
	// the directionality opposite to the base direction of the paragraph are
	// inserted.
	//
	// If @iter is nil, the actual cursor position is used.
	//
	// Note that if @iter happens to be the actual cursor position, and there is
	// currently an IM preedit sequence being entered, the returned locations
	// will be adjusted to account for the preedit cursor’s offset within the
	// preedit sequence.
	//
	// The rectangle position is in buffer coordinates; use
	// gtk_text_view_buffer_to_window_coords() to convert these coordinates to
	// coordinates for one of the windows in the text view.
	CursorLocations(iter *TextIter) (strong gdk.Rectangle, weak gdk.Rectangle)
	// CursorVisible: find out whether the cursor should be displayed.
	CursorVisible() bool
	// DefaultAttributes obtains a copy of the default text attributes. These
	// are the attributes used for text unless a tag overrides them. You’d
	// typically pass the default attributes in to
	// gtk_text_iter_get_attributes() in order to get the attributes in effect
	// at a given text position.
	//
	// The return value is a copy owned by the caller of this function, and
	// should be freed with gtk_text_attributes_unref().
	DefaultAttributes() *TextAttributes
	// Editable returns the default editability of the TextView. Tags in the
	// buffer may override this setting for some ranges of text.
	Editable() bool
	// HAdjustment gets the horizontal-scrolling Adjustment.
	HAdjustment() Adjustment
	// Indent gets the default indentation of paragraphs in @text_view. Tags in
	// the view’s buffer may override the default. The indentation may be
	// negative.
	Indent() int
	// InputHints gets the value of the TextView:input-hints property.
	InputHints() InputHints
	// InputPurpose gets the value of the TextView:input-purpose property.
	InputPurpose() InputPurpose
	// IterAtLocation retrieves the iterator at buffer coordinates @x and @y.
	// Buffer coordinates are coordinates for the entire buffer, not just the
	// currently-displayed portion. If you have coordinates from an event, you
	// have to convert those to buffer coordinates with
	// gtk_text_view_window_to_buffer_coords().
	IterAtLocation(x int, y int) (iter TextIter, ok bool)
	// IterAtPosition retrieves the iterator pointing to the character at buffer
	// coordinates @x and @y. Buffer coordinates are coordinates for the entire
	// buffer, not just the currently-displayed portion. If you have coordinates
	// from an event, you have to convert those to buffer coordinates with
	// gtk_text_view_window_to_buffer_coords().
	//
	// Note that this is different from gtk_text_view_get_iter_at_location(),
	// which returns cursor locations, i.e. positions between characters.
	IterAtPosition(x int, y int) (iter TextIter, trailing int, ok bool)
	// IterLocation gets a rectangle which roughly contains the character at
	// @iter. The rectangle position is in buffer coordinates; use
	// gtk_text_view_buffer_to_window_coords() to convert these coordinates to
	// coordinates for one of the windows in the text view.
	IterLocation(iter *TextIter) gdk.Rectangle
	// Justification gets the default justification of paragraphs in @text_view.
	// Tags in the buffer may override the default.
	Justification() Justification
	// LeftMargin gets the default left margin size of paragraphs in the
	// @text_view. Tags in the buffer may override the default.
	LeftMargin() int
	// LineAtY gets the TextIter at the start of the line containing the
	// coordinate @y. @y is in buffer coordinates, convert from window
	// coordinates with gtk_text_view_window_to_buffer_coords(). If non-nil,
	// @line_top will be filled with the coordinate of the top edge of the line.
	LineAtY(y int) (targetIter TextIter, lineTop int)
	// LineYrange gets the y coordinate of the top of the line containing @iter,
	// and the height of the line. The coordinate is a buffer coordinate;
	// convert to window coordinates with
	// gtk_text_view_buffer_to_window_coords().
	LineYrange(iter *TextIter) (y int, height int)
	// Monospace gets the value of the TextView:monospace property.
	Monospace() bool
	// Overwrite returns whether the TextView is in overwrite mode or not.
	Overwrite() bool
	// PixelsAboveLines gets the default number of pixels to put above
	// paragraphs. Adding this function with
	// gtk_text_view_get_pixels_below_lines() is equal to the line space between
	// each paragraph.
	PixelsAboveLines() int
	// PixelsBelowLines gets the value set by
	// gtk_text_view_set_pixels_below_lines().
	//
	// The line space is the sum of the value returned by this function and the
	// value returned by gtk_text_view_get_pixels_above_lines().
	PixelsBelowLines() int
	// PixelsInsideWrap gets the value set by
	// gtk_text_view_set_pixels_inside_wrap().
	PixelsInsideWrap() int
	// RightMargin gets the default right margin for text in @text_view. Tags in
	// the buffer may override the default.
	RightMargin() int
	// Tabs gets the default tabs for @text_view. Tags in the buffer may
	// override the defaults. The returned array will be nil if “standard”
	// (8-space) tabs are used. Free the return value with
	// pango_tab_array_free().
	Tabs() *pango.TabArray
	// TopMargin gets the top margin for text in the @text_view.
	TopMargin() int
	// VAdjustment gets the vertical-scrolling Adjustment.
	VAdjustment() Adjustment
	// VisibleRect fills @visible_rect with the currently-visible region of the
	// buffer, in buffer coordinates. Convert to window coordinates with
	// gtk_text_view_buffer_to_window_coords().
	VisibleRect() gdk.Rectangle
	// Window retrieves the Window corresponding to an area of the text view;
	// possible windows include the overall widget window, child windows on the
	// left, right, top, bottom, and the window that displays the text buffer.
	// Windows are nil and nonexistent if their width or height is 0, and are
	// nonexistent before the widget has been realized.
	Window(win TextWindowType) gdk.Window
	// WindowType: usually used to find out which window an event corresponds
	// to.
	//
	// If you connect to an event signal on @text_view, this function should be
	// called on `event->window` to see which window it was.
	WindowType(window gdk.Window) TextWindowType
	// WrapMode gets the line wrapping for the view.
	WrapMode() WrapMode
	// ImContextFilterKeypress: allow the TextView input method to internally
	// handle key press and release events. If this function returns true, then
	// no further processing should be done for this key event. See
	// gtk_im_context_filter_keypress().
	//
	// Note that you are expected to call this function from your handler when
	// overriding key event handling. This is needed in the case when you need
	// to insert your own key handling between the input method and the default
	// key event handling of the TextView.
	//
	//    static gboolean
	//    gtk_foo_bar_key_press_event (GtkWidget   *widget,
	//                                 GdkEventKey *event)
	//    {
	//      guint keyval;
	//
	//      gdk_event_get_keyval ((GdkEvent*)event, &keyval);
	//
	//      if (keyval == GDK_KEY_Return || keyval == GDK_KEY_KP_Enter)
	//        {
	//          if (gtk_text_view_im_context_filter_keypress (GTK_TEXT_VIEW (widget), event))
	//            return TRUE;
	//        }
	//
	//      // Do some stuff
	//
	//      return GTK_WIDGET_CLASS (gtk_foo_bar_parent_class)->key_press_event (widget, event);
	//    }
	ImContextFilterKeypress(event *gdk.EventKey) bool
	// MoveChild updates the position of a child, as for
	// gtk_text_view_add_child_in_window().
	MoveChild(child Widget, xpos int, ypos int)
	// MoveMarkOnscreen moves a mark within the buffer so that it's located
	// within the currently-visible text area.
	MoveMarkOnscreen(mark TextMark) bool
	// MoveVisually: move the iterator a given number of characters visually,
	// treating it as the strong cursor position. If @count is positive, then
	// the new strong cursor position will be @count positions to the right of
	// the old cursor position. If @count is negative then the new strong cursor
	// position will be @count positions to the left of the old cursor position.
	//
	// In the presence of bi-directional text, the correspondence between
	// logical and visual order will depend on the direction of the current run,
	// and there may be jumps when the cursor is moved off of the end of a run.
	MoveVisually(iter *TextIter, count int) bool
	// PlaceCursorOnscreen moves the cursor to the currently visible region of
	// the buffer, it it isn’t there already.
	PlaceCursorOnscreen() bool
	// ResetCursorBlink ensures that the cursor is shown (i.e. not in an 'off'
	// blink interval) and resets the time that it will stay blinking (or
	// visible, in case blinking is disabled).
	//
	// This function should be called in response to user input (e.g. from
	// derived classes that override the textview's Widget::key-press-event
	// handler).
	ResetCursorBlink()
	// ResetImContext: reset the input method context of the text view if
	// needed.
	//
	// This can be necessary in the case where modifying the buffer would
	// confuse on-going input method behavior.
	ResetImContext()
	// ScrollMarkOnscreen scrolls @text_view the minimum distance such that
	// @mark is contained within the visible area of the widget.
	ScrollMarkOnscreen(mark TextMark)
	// ScrollToIter scrolls @text_view so that @iter is on the screen in the
	// position indicated by @xalign and @yalign. An alignment of 0.0 indicates
	// left or top, 1.0 indicates right or bottom, 0.5 means center. If
	// @use_align is false, the text scrolls the minimal distance to get the
	// mark onscreen, possibly not scrolling at all. The effective screen for
	// purposes of this function is reduced by a margin of size @within_margin.
	//
	// Note that this function uses the currently-computed height of the lines
	// in the text buffer. Line heights are computed in an idle handler; so this
	// function may not have the desired effect if it’s called before the height
	// computations. To avoid oddness, consider using
	// gtk_text_view_scroll_to_mark() which saves a point to be scrolled to
	// after line validation.
	ScrollToIter(iter *TextIter, withinMargin float64, useAlign bool, xalign float64, yalign float64) bool
	// ScrollToMark scrolls @text_view so that @mark is on the screen in the
	// position indicated by @xalign and @yalign. An alignment of 0.0 indicates
	// left or top, 1.0 indicates right or bottom, 0.5 means center. If
	// @use_align is false, the text scrolls the minimal distance to get the
	// mark onscreen, possibly not scrolling at all. The effective screen for
	// purposes of this function is reduced by a margin of size @within_margin.
	ScrollToMark(mark TextMark, withinMargin float64, useAlign bool, xalign float64, yalign float64)
	// SetAcceptsTab sets the behavior of the text widget when the Tab key is
	// pressed. If @accepts_tab is true, a tab character is inserted. If
	// @accepts_tab is false the keyboard focus is moved to the next widget in
	// the focus chain.
	SetAcceptsTab(acceptsTab bool)
	// SetBorderWindowSize sets the width of GTK_TEXT_WINDOW_LEFT or
	// GTK_TEXT_WINDOW_RIGHT, or the height of GTK_TEXT_WINDOW_TOP or
	// GTK_TEXT_WINDOW_BOTTOM. Automatically destroys the corresponding window
	// if the size is set to 0, and creates the window if the size is set to
	// non-zero. This function can only be used for the “border windows”, and it
	// won’t work with GTK_TEXT_WINDOW_WIDGET, GTK_TEXT_WINDOW_TEXT, or
	// GTK_TEXT_WINDOW_PRIVATE.
	SetBorderWindowSize(typ TextWindowType, size int)
	// SetBottomMargin sets the bottom margin for text in @text_view.
	//
	// Note that this function is confusingly named. In CSS terms, the value set
	// here is padding.
	SetBottomMargin(bottomMargin int)
	// SetBuffer sets @buffer as the buffer being displayed by @text_view. The
	// previous buffer displayed by the text view is unreferenced, and a
	// reference is added to @buffer. If you owned a reference to @buffer before
	// passing it to this function, you must remove that reference yourself;
	// TextView will not “adopt” it.
	SetBuffer(buffer TextBuffer)
	// SetCursorVisible toggles whether the insertion point should be displayed.
	// A buffer with no editable text probably shouldn’t have a visible cursor,
	// so you may want to turn the cursor off.
	//
	// Note that this property may be overridden by the
	// Settings:gtk-keynave-use-caret settings.
	SetCursorVisible(setting bool)
	// SetEditable sets the default editability of the TextView. You can
	// override this default setting with tags in the buffer, using the
	// “editable” attribute of tags.
	SetEditable(setting bool)
	// SetIndent sets the default indentation for paragraphs in @text_view. Tags
	// in the buffer may override the default.
	SetIndent(indent int)
	// SetInputHints sets the TextView:input-hints property, which allows input
	// methods to fine-tune their behaviour.
	SetInputHints(hints InputHints)
	// SetInputPurpose sets the TextView:input-purpose property which can be
	// used by on-screen keyboards and other input methods to adjust their
	// behaviour.
	SetInputPurpose(purpose InputPurpose)
	// SetJustification sets the default justification of text in @text_view.
	// Tags in the view’s buffer may override the default.
	SetJustification(justification Justification)
	// SetLeftMargin sets the default left margin for text in @text_view. Tags
	// in the buffer may override the default.
	//
	// Note that this function is confusingly named. In CSS terms, the value set
	// here is padding.
	SetLeftMargin(leftMargin int)
	// SetMonospace sets the TextView:monospace property, which indicates that
	// the text view should use monospace fonts.
	SetMonospace(monospace bool)
	// SetOverwrite changes the TextView overwrite mode.
	SetOverwrite(overwrite bool)
	// SetPixelsAboveLines sets the default number of blank pixels above
	// paragraphs in @text_view. Tags in the buffer for @text_view may override
	// the defaults.
	SetPixelsAboveLines(pixelsAboveLines int)
	// SetPixelsBelowLines sets the default number of pixels of blank space to
	// put below paragraphs in @text_view. May be overridden by tags applied to
	// @text_view’s buffer.
	SetPixelsBelowLines(pixelsBelowLines int)
	// SetPixelsInsideWrap sets the default number of pixels of blank space to
	// leave between display/wrapped lines within a paragraph. May be overridden
	// by tags in @text_view’s buffer.
	SetPixelsInsideWrap(pixelsInsideWrap int)
	// SetRightMargin sets the default right margin for text in the text view.
	// Tags in the buffer may override the default.
	//
	// Note that this function is confusingly named. In CSS terms, the value set
	// here is padding.
	SetRightMargin(rightMargin int)
	// SetTabs sets the default tab stops for paragraphs in @text_view. Tags in
	// the buffer may override the default.
	SetTabs(tabs *pango.TabArray)
	// SetTopMargin sets the top margin for text in @text_view.
	//
	// Note that this function is confusingly named. In CSS terms, the value set
	// here is padding.
	SetTopMargin(topMargin int)
	// SetWrapMode sets the line wrapping for the view.
	SetWrapMode(wrapMode WrapMode)
	// StartsDisplayLine determines whether @iter is at the start of a display
	// line. See gtk_text_view_forward_display_line() for an explanation of
	// display lines vs. paragraphs.
	StartsDisplayLine(iter *TextIter) bool
	// WindowToBufferCoords converts coordinates on the window identified by
	// @win to buffer coordinates, storing the result in (@buffer_x,@buffer_y).
	//
	// Note that you can’t convert coordinates for a nonexisting window (see
	// gtk_text_view_set_border_window_size()).
	WindowToBufferCoords(win TextWindowType, windowX int, windowY int) (bufferX int, bufferY int)
}

// textView implements the TextView interface.
type textView struct {
	Container
	Buildable
	Scrollable
}

var _ TextView = (*textView)(nil)

// WrapTextView wraps a GObject to the right type. It is
// primarily used internally.
func WrapTextView(obj *externglib.Object) TextView {
	return TextView{
		Container:  WrapContainer(obj),
		Buildable:  WrapBuildable(obj),
		Scrollable: WrapScrollable(obj),
	}
}

func marshalTextView(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTextView(obj), nil
}

// NewTextView constructs a class TextView.
func NewTextView() TextView {
	var cret C.GtkTextView
	var ret1 TextView

	cret = C.gtk_text_view_new()

	ret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(TextView)

	return ret1
}

// NewTextViewWithBuffer constructs a class TextView.
func NewTextViewWithBuffer(buffer TextBuffer) TextView {
	var arg1 *C.GtkTextBuffer

	arg1 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))

	var cret C.GtkTextView
	var ret1 TextView

	cret = C.gtk_text_view_new_with_buffer(buffer)

	ret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(TextView)

	return ret1
}

// AddChildAtAnchor adds a child widget in the text buffer, at the given
// @anchor.
func (t textView) AddChildAtAnchor(child Widget, anchor TextChildAnchor) {
	var arg0 *C.GtkTextView
	var arg1 *C.GtkWidget
	var arg2 *C.GtkTextChildAnchor

	arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	arg2 = (*C.GtkTextChildAnchor)(unsafe.Pointer(anchor.Native()))

	C.gtk_text_view_add_child_at_anchor(arg0, child, anchor)
}

// AddChildInWindow adds a child at fixed coordinates in one of the text
// widget's windows.
//
// The window must have nonzero size (see
// gtk_text_view_set_border_window_size()). Note that the child coordinates
// are given relative to scrolling. When placing a child in
// K_TEXT_WINDOW_WIDGET, scrolling is irrelevant, the child floats above all
// scrollable areas. But when placing a child in one of the scrollable
// windows (border windows or text window) it will move with the scrolling
// as needed.
func (t textView) AddChildInWindow(child Widget, whichWindow TextWindowType, xpos int, ypos int) {
	var arg0 *C.GtkTextView
	var arg1 *C.GtkWidget
	var arg2 C.GtkTextWindowType
	var arg3 C.gint
	var arg4 C.gint

	arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	arg2 = (C.GtkTextWindowType)(whichWindow)
	arg3 = C.gint(xpos)
	arg4 = C.gint(ypos)

	C.gtk_text_view_add_child_in_window(arg0, child, whichWindow, xpos, ypos)
}

// BackwardDisplayLine moves the given @iter backward by one display
// (wrapped) line. A display line is different from a paragraph. Paragraphs
// are separated by newlines or other paragraph separator characters.
// Display lines are created by line-wrapping a paragraph. If wrapping is
// turned off, display lines and paragraphs will be the same. Display lines
// are divided differently for each view, since they depend on the view’s
// width; paragraphs are the same in all views, since they depend on the
// contents of the TextBuffer.
func (t textView) BackwardDisplayLine(iter *TextIter) bool {
	var arg0 *C.GtkTextView
	var arg1 *C.GtkTextIter

	arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))

	var cret C.gboolean
	var ret1 bool

	cret = C.gtk_text_view_backward_display_line(arg0, iter)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// BackwardDisplayLineStart moves the given @iter backward to the next
// display line start. A display line is different from a paragraph.
// Paragraphs are separated by newlines or other paragraph separator
// characters. Display lines are created by line-wrapping a paragraph. If
// wrapping is turned off, display lines and paragraphs will be the same.
// Display lines are divided differently for each view, since they depend on
// the view’s width; paragraphs are the same in all views, since they depend
// on the contents of the TextBuffer.
func (t textView) BackwardDisplayLineStart(iter *TextIter) bool {
	var arg0 *C.GtkTextView
	var arg1 *C.GtkTextIter

	arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))

	var cret C.gboolean
	var ret1 bool

	cret = C.gtk_text_view_backward_display_line_start(arg0, iter)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// BufferToWindowCoords converts coordinate (@buffer_x, @buffer_y) to
// coordinates for the window @win, and stores the result in (@window_x,
// @window_y).
//
// Note that you can’t convert coordinates for a nonexisting window (see
// gtk_text_view_set_border_window_size()).
func (t textView) BufferToWindowCoords(win TextWindowType, bufferX int, bufferY int) (windowX int, windowY int) {
	var arg0 *C.GtkTextView
	var arg1 C.GtkTextWindowType
	var arg2 C.gint
	var arg3 C.gint

	arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	arg1 = (C.GtkTextWindowType)(win)
	arg2 = C.gint(bufferX)
	arg3 = C.gint(bufferY)

	var arg4 C.gint
	var ret4 int
	var arg5 C.gint
	var ret5 int

	C.gtk_text_view_buffer_to_window_coords(arg0, win, bufferX, bufferY, &arg4, &arg5)

	*ret4 = C.gint(arg4)
	*ret5 = C.gint(arg5)

	return ret4, ret5
}

// ForwardDisplayLine moves the given @iter forward by one display (wrapped)
// line. A display line is different from a paragraph. Paragraphs are
// separated by newlines or other paragraph separator characters. Display
// lines are created by line-wrapping a paragraph. If wrapping is turned
// off, display lines and paragraphs will be the same. Display lines are
// divided differently for each view, since they depend on the view’s width;
// paragraphs are the same in all views, since they depend on the contents
// of the TextBuffer.
func (t textView) ForwardDisplayLine(iter *TextIter) bool {
	var arg0 *C.GtkTextView
	var arg1 *C.GtkTextIter

	arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))

	var cret C.gboolean
	var ret1 bool

	cret = C.gtk_text_view_forward_display_line(arg0, iter)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// ForwardDisplayLineEnd moves the given @iter forward to the next display
// line end. A display line is different from a paragraph. Paragraphs are
// separated by newlines or other paragraph separator characters. Display
// lines are created by line-wrapping a paragraph. If wrapping is turned
// off, display lines and paragraphs will be the same. Display lines are
// divided differently for each view, since they depend on the view’s width;
// paragraphs are the same in all views, since they depend on the contents
// of the TextBuffer.
func (t textView) ForwardDisplayLineEnd(iter *TextIter) bool {
	var arg0 *C.GtkTextView
	var arg1 *C.GtkTextIter

	arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))

	var cret C.gboolean
	var ret1 bool

	cret = C.gtk_text_view_forward_display_line_end(arg0, iter)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// AcceptsTab returns whether pressing the Tab key inserts a tab characters.
// gtk_text_view_set_accepts_tab().
func (t textView) AcceptsTab() bool {
	var arg0 *C.GtkTextView

	arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	var cret C.gboolean
	var ret1 bool

	cret = C.gtk_text_view_get_accepts_tab(arg0)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// BorderWindowSize gets the width of the specified border window. See
// gtk_text_view_set_border_window_size().
func (t textView) BorderWindowSize(typ TextWindowType) int {
	var arg0 *C.GtkTextView
	var arg1 C.GtkTextWindowType

	arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	arg1 = (C.GtkTextWindowType)(typ)

	var cret C.gint
	var ret1 int

	cret = C.gtk_text_view_get_border_window_size(arg0, typ)

	ret1 = C.gint(cret)

	return ret1
}

// BottomMargin gets the bottom margin for text in the @text_view.
func (t textView) BottomMargin() int {
	var arg0 *C.GtkTextView

	arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	var cret C.gint
	var ret1 int

	cret = C.gtk_text_view_get_bottom_margin(arg0)

	ret1 = C.gint(cret)

	return ret1
}

// Buffer returns the TextBuffer being displayed by this text view. The
// reference count on the buffer is not incremented; the caller of this
// function won’t own a new reference.
func (t textView) Buffer() TextBuffer {
	var arg0 *C.GtkTextView

	arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	var cret *C.GtkTextBuffer
	var ret1 TextBuffer

	cret = C.gtk_text_view_get_buffer(arg0)

	ret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(TextBuffer)

	return ret1
}

// CursorLocations: given an @iter within a text layout, determine the
// positions of the strong and weak cursors if the insertion point is at
// that iterator. The position of each cursor is stored as a zero-width
// rectangle. The strong cursor location is the location where characters of
// the directionality equal to the base direction of the paragraph are
// inserted. The weak cursor location is the location where characters of
// the directionality opposite to the base direction of the paragraph are
// inserted.
//
// If @iter is nil, the actual cursor position is used.
//
// Note that if @iter happens to be the actual cursor position, and there is
// currently an IM preedit sequence being entered, the returned locations
// will be adjusted to account for the preedit cursor’s offset within the
// preedit sequence.
//
// The rectangle position is in buffer coordinates; use
// gtk_text_view_buffer_to_window_coords() to convert these coordinates to
// coordinates for one of the windows in the text view.
func (t textView) CursorLocations(iter *TextIter) (strong gdk.Rectangle, weak gdk.Rectangle) {
	var arg0 *C.GtkTextView
	var arg1 *C.GtkTextIter

	arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))

	var arg2 C.GdkRectangle
	var ret2 *gdk.Rectangle
	var arg3 C.GdkRectangle
	var ret3 *gdk.Rectangle

	C.gtk_text_view_get_cursor_locations(arg0, iter, &arg2, &arg3)

	*ret2 = gdk.WrapRectangle(unsafe.Pointer(arg2))
	*ret3 = gdk.WrapRectangle(unsafe.Pointer(arg3))

	return ret2, ret3
}

// CursorVisible: find out whether the cursor should be displayed.
func (t textView) CursorVisible() bool {
	var arg0 *C.GtkTextView

	arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	var cret C.gboolean
	var ret1 bool

	cret = C.gtk_text_view_get_cursor_visible(arg0)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// DefaultAttributes obtains a copy of the default text attributes. These
// are the attributes used for text unless a tag overrides them. You’d
// typically pass the default attributes in to
// gtk_text_iter_get_attributes() in order to get the attributes in effect
// at a given text position.
//
// The return value is a copy owned by the caller of this function, and
// should be freed with gtk_text_attributes_unref().
func (t textView) DefaultAttributes() *TextAttributes {
	var arg0 *C.GtkTextView

	arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	var cret *C.GtkTextAttributes
	var ret1 *TextAttributes

	cret = C.gtk_text_view_get_default_attributes(arg0)

	ret1 = WrapTextAttributes(unsafe.Pointer(cret))
	runtime.SetFinalizer(ret1, func(v *TextAttributes) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return ret1
}

// Editable returns the default editability of the TextView. Tags in the
// buffer may override this setting for some ranges of text.
func (t textView) Editable() bool {
	var arg0 *C.GtkTextView

	arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	var cret C.gboolean
	var ret1 bool

	cret = C.gtk_text_view_get_editable(arg0)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// HAdjustment gets the horizontal-scrolling Adjustment.
func (t textView) HAdjustment() Adjustment {
	var arg0 *C.GtkTextView

	arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	var cret *C.GtkAdjustment
	var ret1 Adjustment

	cret = C.gtk_text_view_get_hadjustment(arg0)

	ret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Adjustment)

	return ret1
}

// Indent gets the default indentation of paragraphs in @text_view. Tags in
// the view’s buffer may override the default. The indentation may be
// negative.
func (t textView) Indent() int {
	var arg0 *C.GtkTextView

	arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	var cret C.gint
	var ret1 int

	cret = C.gtk_text_view_get_indent(arg0)

	ret1 = C.gint(cret)

	return ret1
}

// InputHints gets the value of the TextView:input-hints property.
func (t textView) InputHints() InputHints {
	var arg0 *C.GtkTextView

	arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	var cret C.GtkInputHints
	var ret1 InputHints

	cret = C.gtk_text_view_get_input_hints(arg0)

	ret1 = InputHints(cret)

	return ret1
}

// InputPurpose gets the value of the TextView:input-purpose property.
func (t textView) InputPurpose() InputPurpose {
	var arg0 *C.GtkTextView

	arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	var cret C.GtkInputPurpose
	var ret1 InputPurpose

	cret = C.gtk_text_view_get_input_purpose(arg0)

	ret1 = InputPurpose(cret)

	return ret1
}

// IterAtLocation retrieves the iterator at buffer coordinates @x and @y.
// Buffer coordinates are coordinates for the entire buffer, not just the
// currently-displayed portion. If you have coordinates from an event, you
// have to convert those to buffer coordinates with
// gtk_text_view_window_to_buffer_coords().
func (t textView) IterAtLocation(x int, y int) (iter TextIter, ok bool) {
	var arg0 *C.GtkTextView
	var arg2 C.gint
	var arg3 C.gint

	arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	arg2 = C.gint(x)
	arg3 = C.gint(y)

	var arg1 C.GtkTextIter
	var ret1 *TextIter
	var cret C.gboolean
	var ret2 bool

	cret = C.gtk_text_view_get_iter_at_location(arg0, &arg1, x, y)

	*ret1 = WrapTextIter(unsafe.Pointer(arg1))
	ret2 = C.bool(cret) != C.false

	return ret1, ret2
}

// IterAtPosition retrieves the iterator pointing to the character at buffer
// coordinates @x and @y. Buffer coordinates are coordinates for the entire
// buffer, not just the currently-displayed portion. If you have coordinates
// from an event, you have to convert those to buffer coordinates with
// gtk_text_view_window_to_buffer_coords().
//
// Note that this is different from gtk_text_view_get_iter_at_location(),
// which returns cursor locations, i.e. positions between characters.
func (t textView) IterAtPosition(x int, y int) (iter TextIter, trailing int, ok bool) {
	var arg0 *C.GtkTextView
	var arg3 C.gint
	var arg4 C.gint

	arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	arg3 = C.gint(x)
	arg4 = C.gint(y)

	var arg1 C.GtkTextIter
	var ret1 *TextIter
	var arg2 C.gint
	var ret2 int
	var cret C.gboolean
	var ret3 bool

	cret = C.gtk_text_view_get_iter_at_position(arg0, &arg1, &arg2, x, y)

	*ret1 = WrapTextIter(unsafe.Pointer(arg1))
	*ret2 = C.gint(arg2)
	ret3 = C.bool(cret) != C.false

	return ret1, ret2, ret3
}

// IterLocation gets a rectangle which roughly contains the character at
// @iter. The rectangle position is in buffer coordinates; use
// gtk_text_view_buffer_to_window_coords() to convert these coordinates to
// coordinates for one of the windows in the text view.
func (t textView) IterLocation(iter *TextIter) gdk.Rectangle {
	var arg0 *C.GtkTextView
	var arg1 *C.GtkTextIter

	arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))

	var arg2 C.GdkRectangle
	var ret2 *gdk.Rectangle

	C.gtk_text_view_get_iter_location(arg0, iter, &arg2)

	*ret2 = gdk.WrapRectangle(unsafe.Pointer(arg2))

	return ret2
}

// Justification gets the default justification of paragraphs in @text_view.
// Tags in the buffer may override the default.
func (t textView) Justification() Justification {
	var arg0 *C.GtkTextView

	arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	var cret C.GtkJustification
	var ret1 Justification

	cret = C.gtk_text_view_get_justification(arg0)

	ret1 = Justification(cret)

	return ret1
}

// LeftMargin gets the default left margin size of paragraphs in the
// @text_view. Tags in the buffer may override the default.
func (t textView) LeftMargin() int {
	var arg0 *C.GtkTextView

	arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	var cret C.gint
	var ret1 int

	cret = C.gtk_text_view_get_left_margin(arg0)

	ret1 = C.gint(cret)

	return ret1
}

// LineAtY gets the TextIter at the start of the line containing the
// coordinate @y. @y is in buffer coordinates, convert from window
// coordinates with gtk_text_view_window_to_buffer_coords(). If non-nil,
// @line_top will be filled with the coordinate of the top edge of the line.
func (t textView) LineAtY(y int) (targetIter TextIter, lineTop int) {
	var arg0 *C.GtkTextView
	var arg2 C.gint

	arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	arg2 = C.gint(y)

	var arg1 C.GtkTextIter
	var ret1 *TextIter
	var arg3 C.gint
	var ret3 int

	C.gtk_text_view_get_line_at_y(arg0, &arg1, y, &arg3)

	*ret1 = WrapTextIter(unsafe.Pointer(arg1))
	*ret3 = C.gint(arg3)

	return ret1, ret3
}

// LineYrange gets the y coordinate of the top of the line containing @iter,
// and the height of the line. The coordinate is a buffer coordinate;
// convert to window coordinates with
// gtk_text_view_buffer_to_window_coords().
func (t textView) LineYrange(iter *TextIter) (y int, height int) {
	var arg0 *C.GtkTextView
	var arg1 *C.GtkTextIter

	arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))

	var arg2 C.gint
	var ret2 int
	var arg3 C.gint
	var ret3 int

	C.gtk_text_view_get_line_yrange(arg0, iter, &arg2, &arg3)

	*ret2 = C.gint(arg2)
	*ret3 = C.gint(arg3)

	return ret2, ret3
}

// Monospace gets the value of the TextView:monospace property.
func (t textView) Monospace() bool {
	var arg0 *C.GtkTextView

	arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	var cret C.gboolean
	var ret1 bool

	cret = C.gtk_text_view_get_monospace(arg0)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// Overwrite returns whether the TextView is in overwrite mode or not.
func (t textView) Overwrite() bool {
	var arg0 *C.GtkTextView

	arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	var cret C.gboolean
	var ret1 bool

	cret = C.gtk_text_view_get_overwrite(arg0)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// PixelsAboveLines gets the default number of pixels to put above
// paragraphs. Adding this function with
// gtk_text_view_get_pixels_below_lines() is equal to the line space between
// each paragraph.
func (t textView) PixelsAboveLines() int {
	var arg0 *C.GtkTextView

	arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	var cret C.gint
	var ret1 int

	cret = C.gtk_text_view_get_pixels_above_lines(arg0)

	ret1 = C.gint(cret)

	return ret1
}

// PixelsBelowLines gets the value set by
// gtk_text_view_set_pixels_below_lines().
//
// The line space is the sum of the value returned by this function and the
// value returned by gtk_text_view_get_pixels_above_lines().
func (t textView) PixelsBelowLines() int {
	var arg0 *C.GtkTextView

	arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	var cret C.gint
	var ret1 int

	cret = C.gtk_text_view_get_pixels_below_lines(arg0)

	ret1 = C.gint(cret)

	return ret1
}

// PixelsInsideWrap gets the value set by
// gtk_text_view_set_pixels_inside_wrap().
func (t textView) PixelsInsideWrap() int {
	var arg0 *C.GtkTextView

	arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	var cret C.gint
	var ret1 int

	cret = C.gtk_text_view_get_pixels_inside_wrap(arg0)

	ret1 = C.gint(cret)

	return ret1
}

// RightMargin gets the default right margin for text in @text_view. Tags in
// the buffer may override the default.
func (t textView) RightMargin() int {
	var arg0 *C.GtkTextView

	arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	var cret C.gint
	var ret1 int

	cret = C.gtk_text_view_get_right_margin(arg0)

	ret1 = C.gint(cret)

	return ret1
}

// Tabs gets the default tabs for @text_view. Tags in the buffer may
// override the defaults. The returned array will be nil if “standard”
// (8-space) tabs are used. Free the return value with
// pango_tab_array_free().
func (t textView) Tabs() *pango.TabArray {
	var arg0 *C.GtkTextView

	arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	var cret *C.PangoTabArray
	var ret1 *pango.TabArray

	cret = C.gtk_text_view_get_tabs(arg0)

	ret1 = pango.WrapTabArray(unsafe.Pointer(cret))
	runtime.SetFinalizer(ret1, func(v *pango.TabArray) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return ret1
}

// TopMargin gets the top margin for text in the @text_view.
func (t textView) TopMargin() int {
	var arg0 *C.GtkTextView

	arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	var cret C.gint
	var ret1 int

	cret = C.gtk_text_view_get_top_margin(arg0)

	ret1 = C.gint(cret)

	return ret1
}

// VAdjustment gets the vertical-scrolling Adjustment.
func (t textView) VAdjustment() Adjustment {
	var arg0 *C.GtkTextView

	arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	var cret *C.GtkAdjustment
	var ret1 Adjustment

	cret = C.gtk_text_view_get_vadjustment(arg0)

	ret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Adjustment)

	return ret1
}

// VisibleRect fills @visible_rect with the currently-visible region of the
// buffer, in buffer coordinates. Convert to window coordinates with
// gtk_text_view_buffer_to_window_coords().
func (t textView) VisibleRect() gdk.Rectangle {
	var arg0 *C.GtkTextView

	arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	var arg1 C.GdkRectangle
	var ret1 *gdk.Rectangle

	C.gtk_text_view_get_visible_rect(arg0, &arg1)

	*ret1 = gdk.WrapRectangle(unsafe.Pointer(arg1))

	return ret1
}

// Window retrieves the Window corresponding to an area of the text view;
// possible windows include the overall widget window, child windows on the
// left, right, top, bottom, and the window that displays the text buffer.
// Windows are nil and nonexistent if their width or height is 0, and are
// nonexistent before the widget has been realized.
func (t textView) Window(win TextWindowType) gdk.Window {
	var arg0 *C.GtkTextView
	var arg1 C.GtkTextWindowType

	arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	arg1 = (C.GtkTextWindowType)(win)

	var cret *C.GdkWindow
	var ret1 gdk.Window

	cret = C.gtk_text_view_get_window(arg0, win)

	ret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(gdk.Window)

	return ret1
}

// WindowType: usually used to find out which window an event corresponds
// to.
//
// If you connect to an event signal on @text_view, this function should be
// called on `event->window` to see which window it was.
func (t textView) WindowType(window gdk.Window) TextWindowType {
	var arg0 *C.GtkTextView
	var arg1 *C.GdkWindow

	arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	arg1 = (*C.GdkWindow)(unsafe.Pointer(window.Native()))

	var cret C.GtkTextWindowType
	var ret1 TextWindowType

	cret = C.gtk_text_view_get_window_type(arg0, window)

	ret1 = TextWindowType(cret)

	return ret1
}

// WrapMode gets the line wrapping for the view.
func (t textView) WrapMode() WrapMode {
	var arg0 *C.GtkTextView

	arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	var cret C.GtkWrapMode
	var ret1 WrapMode

	cret = C.gtk_text_view_get_wrap_mode(arg0)

	ret1 = WrapMode(cret)

	return ret1
}

// ImContextFilterKeypress: allow the TextView input method to internally
// handle key press and release events. If this function returns true, then
// no further processing should be done for this key event. See
// gtk_im_context_filter_keypress().
//
// Note that you are expected to call this function from your handler when
// overriding key event handling. This is needed in the case when you need
// to insert your own key handling between the input method and the default
// key event handling of the TextView.
//
//    static gboolean
//    gtk_foo_bar_key_press_event (GtkWidget   *widget,
//                                 GdkEventKey *event)
//    {
//      guint keyval;
//
//      gdk_event_get_keyval ((GdkEvent*)event, &keyval);
//
//      if (keyval == GDK_KEY_Return || keyval == GDK_KEY_KP_Enter)
//        {
//          if (gtk_text_view_im_context_filter_keypress (GTK_TEXT_VIEW (widget), event))
//            return TRUE;
//        }
//
//      // Do some stuff
//
//      return GTK_WIDGET_CLASS (gtk_foo_bar_parent_class)->key_press_event (widget, event);
//    }
func (t textView) ImContextFilterKeypress(event *gdk.EventKey) bool {
	var arg0 *C.GtkTextView
	var arg1 *C.GdkEventKey

	arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	arg1 = (*C.GdkEventKey)(unsafe.Pointer(event.Native()))

	var cret C.gboolean
	var ret1 bool

	cret = C.gtk_text_view_im_context_filter_keypress(arg0, event)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// MoveChild updates the position of a child, as for
// gtk_text_view_add_child_in_window().
func (t textView) MoveChild(child Widget, xpos int, ypos int) {
	var arg0 *C.GtkTextView
	var arg1 *C.GtkWidget
	var arg2 C.gint
	var arg3 C.gint

	arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	arg2 = C.gint(xpos)
	arg3 = C.gint(ypos)

	C.gtk_text_view_move_child(arg0, child, xpos, ypos)
}

// MoveMarkOnscreen moves a mark within the buffer so that it's located
// within the currently-visible text area.
func (t textView) MoveMarkOnscreen(mark TextMark) bool {
	var arg0 *C.GtkTextView
	var arg1 *C.GtkTextMark

	arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	arg1 = (*C.GtkTextMark)(unsafe.Pointer(mark.Native()))

	var cret C.gboolean
	var ret1 bool

	cret = C.gtk_text_view_move_mark_onscreen(arg0, mark)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// MoveVisually: move the iterator a given number of characters visually,
// treating it as the strong cursor position. If @count is positive, then
// the new strong cursor position will be @count positions to the right of
// the old cursor position. If @count is negative then the new strong cursor
// position will be @count positions to the left of the old cursor position.
//
// In the presence of bi-directional text, the correspondence between
// logical and visual order will depend on the direction of the current run,
// and there may be jumps when the cursor is moved off of the end of a run.
func (t textView) MoveVisually(iter *TextIter, count int) bool {
	var arg0 *C.GtkTextView
	var arg1 *C.GtkTextIter
	var arg2 C.gint

	arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))
	arg2 = C.gint(count)

	var cret C.gboolean
	var ret1 bool

	cret = C.gtk_text_view_move_visually(arg0, iter, count)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// PlaceCursorOnscreen moves the cursor to the currently visible region of
// the buffer, it it isn’t there already.
func (t textView) PlaceCursorOnscreen() bool {
	var arg0 *C.GtkTextView

	arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	var cret C.gboolean
	var ret1 bool

	cret = C.gtk_text_view_place_cursor_onscreen(arg0)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// ResetCursorBlink ensures that the cursor is shown (i.e. not in an 'off'
// blink interval) and resets the time that it will stay blinking (or
// visible, in case blinking is disabled).
//
// This function should be called in response to user input (e.g. from
// derived classes that override the textview's Widget::key-press-event
// handler).
func (t textView) ResetCursorBlink() {
	var arg0 *C.GtkTextView

	arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	C.gtk_text_view_reset_cursor_blink(arg0)
}

// ResetImContext: reset the input method context of the text view if
// needed.
//
// This can be necessary in the case where modifying the buffer would
// confuse on-going input method behavior.
func (t textView) ResetImContext() {
	var arg0 *C.GtkTextView

	arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	C.gtk_text_view_reset_im_context(arg0)
}

// ScrollMarkOnscreen scrolls @text_view the minimum distance such that
// @mark is contained within the visible area of the widget.
func (t textView) ScrollMarkOnscreen(mark TextMark) {
	var arg0 *C.GtkTextView
	var arg1 *C.GtkTextMark

	arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	arg1 = (*C.GtkTextMark)(unsafe.Pointer(mark.Native()))

	C.gtk_text_view_scroll_mark_onscreen(arg0, mark)
}

// ScrollToIter scrolls @text_view so that @iter is on the screen in the
// position indicated by @xalign and @yalign. An alignment of 0.0 indicates
// left or top, 1.0 indicates right or bottom, 0.5 means center. If
// @use_align is false, the text scrolls the minimal distance to get the
// mark onscreen, possibly not scrolling at all. The effective screen for
// purposes of this function is reduced by a margin of size @within_margin.
//
// Note that this function uses the currently-computed height of the lines
// in the text buffer. Line heights are computed in an idle handler; so this
// function may not have the desired effect if it’s called before the height
// computations. To avoid oddness, consider using
// gtk_text_view_scroll_to_mark() which saves a point to be scrolled to
// after line validation.
func (t textView) ScrollToIter(iter *TextIter, withinMargin float64, useAlign bool, xalign float64, yalign float64) bool {
	var arg0 *C.GtkTextView
	var arg1 *C.GtkTextIter
	var arg2 C.gdouble
	var arg3 C.gboolean
	var arg4 C.gdouble
	var arg5 C.gdouble

	arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))
	arg2 = C.gdouble(withinMargin)
	if useAlign {
		arg3 = C.gboolean(1)
	}
	arg4 = C.gdouble(xalign)
	arg5 = C.gdouble(yalign)

	var cret C.gboolean
	var ret1 bool

	cret = C.gtk_text_view_scroll_to_iter(arg0, iter, withinMargin, useAlign, xalign, yalign)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// ScrollToMark scrolls @text_view so that @mark is on the screen in the
// position indicated by @xalign and @yalign. An alignment of 0.0 indicates
// left or top, 1.0 indicates right or bottom, 0.5 means center. If
// @use_align is false, the text scrolls the minimal distance to get the
// mark onscreen, possibly not scrolling at all. The effective screen for
// purposes of this function is reduced by a margin of size @within_margin.
func (t textView) ScrollToMark(mark TextMark, withinMargin float64, useAlign bool, xalign float64, yalign float64) {
	var arg0 *C.GtkTextView
	var arg1 *C.GtkTextMark
	var arg2 C.gdouble
	var arg3 C.gboolean
	var arg4 C.gdouble
	var arg5 C.gdouble

	arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	arg1 = (*C.GtkTextMark)(unsafe.Pointer(mark.Native()))
	arg2 = C.gdouble(withinMargin)
	if useAlign {
		arg3 = C.gboolean(1)
	}
	arg4 = C.gdouble(xalign)
	arg5 = C.gdouble(yalign)

	C.gtk_text_view_scroll_to_mark(arg0, mark, withinMargin, useAlign, xalign, yalign)
}

// SetAcceptsTab sets the behavior of the text widget when the Tab key is
// pressed. If @accepts_tab is true, a tab character is inserted. If
// @accepts_tab is false the keyboard focus is moved to the next widget in
// the focus chain.
func (t textView) SetAcceptsTab(acceptsTab bool) {
	var arg0 *C.GtkTextView
	var arg1 C.gboolean

	arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	if acceptsTab {
		arg1 = C.gboolean(1)
	}

	C.gtk_text_view_set_accepts_tab(arg0, acceptsTab)
}

// SetBorderWindowSize sets the width of GTK_TEXT_WINDOW_LEFT or
// GTK_TEXT_WINDOW_RIGHT, or the height of GTK_TEXT_WINDOW_TOP or
// GTK_TEXT_WINDOW_BOTTOM. Automatically destroys the corresponding window
// if the size is set to 0, and creates the window if the size is set to
// non-zero. This function can only be used for the “border windows”, and it
// won’t work with GTK_TEXT_WINDOW_WIDGET, GTK_TEXT_WINDOW_TEXT, or
// GTK_TEXT_WINDOW_PRIVATE.
func (t textView) SetBorderWindowSize(typ TextWindowType, size int) {
	var arg0 *C.GtkTextView
	var arg1 C.GtkTextWindowType
	var arg2 C.gint

	arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	arg1 = (C.GtkTextWindowType)(typ)
	arg2 = C.gint(size)

	C.gtk_text_view_set_border_window_size(arg0, typ, size)
}

// SetBottomMargin sets the bottom margin for text in @text_view.
//
// Note that this function is confusingly named. In CSS terms, the value set
// here is padding.
func (t textView) SetBottomMargin(bottomMargin int) {
	var arg0 *C.GtkTextView
	var arg1 C.gint

	arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	arg1 = C.gint(bottomMargin)

	C.gtk_text_view_set_bottom_margin(arg0, bottomMargin)
}

// SetBuffer sets @buffer as the buffer being displayed by @text_view. The
// previous buffer displayed by the text view is unreferenced, and a
// reference is added to @buffer. If you owned a reference to @buffer before
// passing it to this function, you must remove that reference yourself;
// TextView will not “adopt” it.
func (t textView) SetBuffer(buffer TextBuffer) {
	var arg0 *C.GtkTextView
	var arg1 *C.GtkTextBuffer

	arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	arg1 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))

	C.gtk_text_view_set_buffer(arg0, buffer)
}

// SetCursorVisible toggles whether the insertion point should be displayed.
// A buffer with no editable text probably shouldn’t have a visible cursor,
// so you may want to turn the cursor off.
//
// Note that this property may be overridden by the
// Settings:gtk-keynave-use-caret settings.
func (t textView) SetCursorVisible(setting bool) {
	var arg0 *C.GtkTextView
	var arg1 C.gboolean

	arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	if setting {
		arg1 = C.gboolean(1)
	}

	C.gtk_text_view_set_cursor_visible(arg0, setting)
}

// SetEditable sets the default editability of the TextView. You can
// override this default setting with tags in the buffer, using the
// “editable” attribute of tags.
func (t textView) SetEditable(setting bool) {
	var arg0 *C.GtkTextView
	var arg1 C.gboolean

	arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	if setting {
		arg1 = C.gboolean(1)
	}

	C.gtk_text_view_set_editable(arg0, setting)
}

// SetIndent sets the default indentation for paragraphs in @text_view. Tags
// in the buffer may override the default.
func (t textView) SetIndent(indent int) {
	var arg0 *C.GtkTextView
	var arg1 C.gint

	arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	arg1 = C.gint(indent)

	C.gtk_text_view_set_indent(arg0, indent)
}

// SetInputHints sets the TextView:input-hints property, which allows input
// methods to fine-tune their behaviour.
func (t textView) SetInputHints(hints InputHints) {
	var arg0 *C.GtkTextView
	var arg1 C.GtkInputHints

	arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	arg1 = (C.GtkInputHints)(hints)

	C.gtk_text_view_set_input_hints(arg0, hints)
}

// SetInputPurpose sets the TextView:input-purpose property which can be
// used by on-screen keyboards and other input methods to adjust their
// behaviour.
func (t textView) SetInputPurpose(purpose InputPurpose) {
	var arg0 *C.GtkTextView
	var arg1 C.GtkInputPurpose

	arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	arg1 = (C.GtkInputPurpose)(purpose)

	C.gtk_text_view_set_input_purpose(arg0, purpose)
}

// SetJustification sets the default justification of text in @text_view.
// Tags in the view’s buffer may override the default.
func (t textView) SetJustification(justification Justification) {
	var arg0 *C.GtkTextView
	var arg1 C.GtkJustification

	arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	arg1 = (C.GtkJustification)(justification)

	C.gtk_text_view_set_justification(arg0, justification)
}

// SetLeftMargin sets the default left margin for text in @text_view. Tags
// in the buffer may override the default.
//
// Note that this function is confusingly named. In CSS terms, the value set
// here is padding.
func (t textView) SetLeftMargin(leftMargin int) {
	var arg0 *C.GtkTextView
	var arg1 C.gint

	arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	arg1 = C.gint(leftMargin)

	C.gtk_text_view_set_left_margin(arg0, leftMargin)
}

// SetMonospace sets the TextView:monospace property, which indicates that
// the text view should use monospace fonts.
func (t textView) SetMonospace(monospace bool) {
	var arg0 *C.GtkTextView
	var arg1 C.gboolean

	arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	if monospace {
		arg1 = C.gboolean(1)
	}

	C.gtk_text_view_set_monospace(arg0, monospace)
}

// SetOverwrite changes the TextView overwrite mode.
func (t textView) SetOverwrite(overwrite bool) {
	var arg0 *C.GtkTextView
	var arg1 C.gboolean

	arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	if overwrite {
		arg1 = C.gboolean(1)
	}

	C.gtk_text_view_set_overwrite(arg0, overwrite)
}

// SetPixelsAboveLines sets the default number of blank pixels above
// paragraphs in @text_view. Tags in the buffer for @text_view may override
// the defaults.
func (t textView) SetPixelsAboveLines(pixelsAboveLines int) {
	var arg0 *C.GtkTextView
	var arg1 C.gint

	arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	arg1 = C.gint(pixelsAboveLines)

	C.gtk_text_view_set_pixels_above_lines(arg0, pixelsAboveLines)
}

// SetPixelsBelowLines sets the default number of pixels of blank space to
// put below paragraphs in @text_view. May be overridden by tags applied to
// @text_view’s buffer.
func (t textView) SetPixelsBelowLines(pixelsBelowLines int) {
	var arg0 *C.GtkTextView
	var arg1 C.gint

	arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	arg1 = C.gint(pixelsBelowLines)

	C.gtk_text_view_set_pixels_below_lines(arg0, pixelsBelowLines)
}

// SetPixelsInsideWrap sets the default number of pixels of blank space to
// leave between display/wrapped lines within a paragraph. May be overridden
// by tags in @text_view’s buffer.
func (t textView) SetPixelsInsideWrap(pixelsInsideWrap int) {
	var arg0 *C.GtkTextView
	var arg1 C.gint

	arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	arg1 = C.gint(pixelsInsideWrap)

	C.gtk_text_view_set_pixels_inside_wrap(arg0, pixelsInsideWrap)
}

// SetRightMargin sets the default right margin for text in the text view.
// Tags in the buffer may override the default.
//
// Note that this function is confusingly named. In CSS terms, the value set
// here is padding.
func (t textView) SetRightMargin(rightMargin int) {
	var arg0 *C.GtkTextView
	var arg1 C.gint

	arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	arg1 = C.gint(rightMargin)

	C.gtk_text_view_set_right_margin(arg0, rightMargin)
}

// SetTabs sets the default tab stops for paragraphs in @text_view. Tags in
// the buffer may override the default.
func (t textView) SetTabs(tabs *pango.TabArray) {
	var arg0 *C.GtkTextView
	var arg1 *C.PangoTabArray

	arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	arg1 = (*C.PangoTabArray)(unsafe.Pointer(tabs.Native()))

	C.gtk_text_view_set_tabs(arg0, tabs)
}

// SetTopMargin sets the top margin for text in @text_view.
//
// Note that this function is confusingly named. In CSS terms, the value set
// here is padding.
func (t textView) SetTopMargin(topMargin int) {
	var arg0 *C.GtkTextView
	var arg1 C.gint

	arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	arg1 = C.gint(topMargin)

	C.gtk_text_view_set_top_margin(arg0, topMargin)
}

// SetWrapMode sets the line wrapping for the view.
func (t textView) SetWrapMode(wrapMode WrapMode) {
	var arg0 *C.GtkTextView
	var arg1 C.GtkWrapMode

	arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	arg1 = (C.GtkWrapMode)(wrapMode)

	C.gtk_text_view_set_wrap_mode(arg0, wrapMode)
}

// StartsDisplayLine determines whether @iter is at the start of a display
// line. See gtk_text_view_forward_display_line() for an explanation of
// display lines vs. paragraphs.
func (t textView) StartsDisplayLine(iter *TextIter) bool {
	var arg0 *C.GtkTextView
	var arg1 *C.GtkTextIter

	arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))

	var cret C.gboolean
	var ret1 bool

	cret = C.gtk_text_view_starts_display_line(arg0, iter)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// WindowToBufferCoords converts coordinates on the window identified by
// @win to buffer coordinates, storing the result in (@buffer_x,@buffer_y).
//
// Note that you can’t convert coordinates for a nonexisting window (see
// gtk_text_view_set_border_window_size()).
func (t textView) WindowToBufferCoords(win TextWindowType, windowX int, windowY int) (bufferX int, bufferY int) {
	var arg0 *C.GtkTextView
	var arg1 C.GtkTextWindowType
	var arg2 C.gint
	var arg3 C.gint

	arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	arg1 = (C.GtkTextWindowType)(win)
	arg2 = C.gint(windowX)
	arg3 = C.gint(windowY)

	var arg4 C.gint
	var ret4 int
	var arg5 C.gint
	var ret5 int

	C.gtk_text_view_window_to_buffer_coords(arg0, win, windowX, windowY, &arg4, &arg5)

	*ret4 = C.gint(arg4)
	*ret5 = C.gint(arg5)

	return ret4, ret5
}

type TextViewPrivate struct {
	native C.GtkTextViewPrivate
}

// WrapTextViewPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTextViewPrivate(ptr unsafe.Pointer) *TextViewPrivate {
	if ptr == nil {
		return nil
	}

	return (*TextViewPrivate)(ptr)
}

func marshalTextViewPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapTextViewPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *TextViewPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}
