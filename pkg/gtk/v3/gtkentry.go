// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"unsafe"

	"github.com/diamondburned/gotk4/internal/gextras"
	"github.com/diamondburned/gotk4/pkg/gdk/v3"
	"github.com/diamondburned/gotk4/pkg/gdkpixbuf/v2"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
	"github.com/diamondburned/gotk4/pkg/pango"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config:
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <stdbool.h>
// #include <glib-object.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_entry_get_type()), F: marshalEntry},
	})
}

// Entry: the Entry widget is a single line text entry widget. A fairly large
// set of key bindings are supported by default. If the entered text is longer
// than the allocation of the widget, the widget will scroll so that the cursor
// position is visible.
//
// When using an entry for passwords and other sensitive information, it can be
// put into “password mode” using gtk_entry_set_visibility(). In this mode,
// entered text is displayed using a “invisible” character. By default, GTK+
// picks the best invisible character that is available in the current font, but
// it can be changed with gtk_entry_set_invisible_char(). Since 2.16, GTK+
// displays a warning when Caps Lock or input methods might interfere with
// entering text in a password entry. The warning can be turned off with the
// Entry:caps-lock-warning property.
//
// Since 2.16, GtkEntry has the ability to display progress or activity
// information behind the text. To make an entry display such information, use
// gtk_entry_set_progress_fraction() or gtk_entry_set_progress_pulse_step().
//
// Additionally, GtkEntry can show icons at either side of the entry. These
// icons can be activatable by clicking, can be set up as drag source and can
// have tooltips. To add an icon, use gtk_entry_set_icon_from_gicon() or one of
// the various other functions that set an icon from a stock id, an icon name or
// a pixbuf. To trigger an action when the user clicks an icon, connect to the
// Entry::icon-press signal. To allow DND operations from an icon, use
// gtk_entry_set_icon_drag_source(). To set a tooltip on an icon, use
// gtk_entry_set_icon_tooltip_text() or the corresponding function for markup.
//
// Note that functionality or information that is only available by clicking on
// an icon in an entry may not be accessible at all to users which are not able
// to use a mouse or other pointing device. It is therefore recommended that any
// such functionality should also be available by other means, e.g. via the
// context menu of the entry.
//
// CSS nodes
//
//    entry[.read-only][.flat][.warning][.error]
//    ├── image.left
//    ├── image.right
//    ├── undershoot.left
//    ├── undershoot.right
//    ├── [selection]
//    ├── [progress[.pulse]]
//    ╰── [window.popup]
//
// GtkEntry has a main node with the name entry. Depending on the properties of
// the entry, the style classes .read-only and .flat may appear. The style
// classes .warning and .error may also be used with entries.
//
// When the entry shows icons, it adds subnodes with the name image and the
// style class .left or .right, depending on where the icon appears.
//
// When the entry has a selection, it adds a subnode with the name selection.
//
// When the entry shows progress, it adds a subnode with the name progress. The
// node has the style class .pulse when the shown progress is pulsing.
//
// The CSS node for a context menu is added as a subnode below entry as well.
//
// The undershoot nodes are used to draw the underflow indication when content
// is scrolled out of view. These nodes get the .left and .right style classes
// added depending on where the indication is drawn.
//
// When touch is used and touch selection handles are shown, they are using CSS
// nodes with name cursor-handle. They get the .top or .bottom style class
// depending on where they are shown in relation to the selection. If there is
// just a single handle for the text cursor, it gets the style class
// .insertion-cursor.
type Entry interface {
	Widget
	Buildable
	CellEditable
	Editable

	// ActivatesDefault retrieves the value set by
	// gtk_entry_set_activates_default().
	ActivatesDefault() bool
	// Alignment gets the value set by gtk_entry_set_alignment().
	Alignment() float32
	// Attributes gets the attribute list that was set on the entry using
	// gtk_entry_set_attributes(), if any.
	Attributes() *pango.AttrList
	// Buffer: get the EntryBuffer object which holds the text for this widget.
	Buffer() EntryBuffer
	// Completion returns the auxiliary completion object currently in use by
	// @entry.
	Completion() EntryCompletion
	// CurrentIconDragSource returns the index of the icon which is the source
	// of the current DND operation, or -1.
	//
	// This function is meant to be used in a Widget::drag-data-get callback.
	CurrentIconDragSource() int
	// CursorHAdjustment retrieves the horizontal cursor adjustment for the
	// entry. See gtk_entry_set_cursor_hadjustment().
	CursorHAdjustment() Adjustment
	// HasFrame gets the value set by gtk_entry_set_has_frame().
	HasFrame() bool
	// IconActivatable returns whether the icon is activatable.
	IconActivatable(iconPos EntryIconPosition) bool
	// IconArea gets the area where entry’s icon at @icon_pos is drawn. This
	// function is useful when drawing something to the entry in a draw
	// callback.
	//
	// If the entry is not realized or has no icon at the given position,
	// @icon_area is filled with zeros. Otherwise, @icon_area will be filled
	// with the icon’s allocation, relative to @entry’s allocation.
	//
	// See also gtk_entry_get_text_area()
	IconArea(iconPos EntryIconPosition) gdk.Rectangle
	// IconAtPos finds the icon at the given position and return its index. The
	// position’s coordinates are relative to the @entry’s top left corner. If
	// @x, @y doesn’t lie inside an icon, -1 is returned. This function is
	// intended for use in a Widget::query-tooltip signal handler.
	IconAtPos(x int, y int) int
	// IconGIcon retrieves the #GIcon used for the icon, or nil if there is no
	// icon or if the icon was set by some other method (e.g., by stock, pixbuf,
	// or icon name).
	IconGIcon(iconPos EntryIconPosition) gio.Icon
	// IconName retrieves the icon name used for the icon, or nil if there is no
	// icon or if the icon was set by some other method (e.g., by pixbuf, stock
	// or gicon).
	IconName(iconPos EntryIconPosition) string
	// IconPixbuf retrieves the image used for the icon.
	//
	// Unlike the other methods of setting and getting icon data, this method
	// will work regardless of whether the icon was set using a Pixbuf, a
	// #GIcon, a stock item, or an icon name.
	IconPixbuf(iconPos EntryIconPosition) gdkpixbuf.Pixbuf
	// IconSensitive returns whether the icon appears sensitive or insensitive.
	IconSensitive(iconPos EntryIconPosition) bool
	// IconStock retrieves the stock id used for the icon, or nil if there is no
	// icon or if the icon was set by some other method (e.g., by pixbuf, icon
	// name or gicon).
	IconStock(iconPos EntryIconPosition) string
	// IconStorageType gets the type of representation being used by the icon to
	// store image data. If the icon has no image data, the return value will be
	// GTK_IMAGE_EMPTY.
	IconStorageType(iconPos EntryIconPosition) ImageType
	// IconTooltipMarkup gets the contents of the tooltip on the icon at the
	// specified position in @entry.
	IconTooltipMarkup(iconPos EntryIconPosition) string
	// IconTooltipText gets the contents of the tooltip on the icon at the
	// specified position in @entry.
	IconTooltipText(iconPos EntryIconPosition) string
	// InnerBorder: this function returns the entry’s Entry:inner-border
	// property. See gtk_entry_set_inner_border() for more information.
	InnerBorder() *Border
	// InputHints gets the value of the Entry:input-hints property.
	InputHints() InputHints
	// InputPurpose gets the value of the Entry:input-purpose property.
	InputPurpose() InputPurpose
	// InvisibleChar retrieves the character displayed in place of the real
	// characters for entries with visibility set to false. See
	// gtk_entry_set_invisible_char().
	InvisibleChar() uint32
	// Layout gets the Layout used to display the entry. The layout is useful to
	// e.g. convert text positions to pixel positions, in combination with
	// gtk_entry_get_layout_offsets(). The returned layout is owned by the entry
	// and must not be modified or freed by the caller.
	//
	// Keep in mind that the layout text may contain a preedit string, so
	// gtk_entry_layout_index_to_text_index() and
	// gtk_entry_text_index_to_layout_index() are needed to convert byte indices
	// in the layout to byte indices in the entry contents.
	Layout() pango.Layout
	// LayoutOffsets obtains the position of the Layout used to render text in
	// the entry, in widget coordinates. Useful if you want to line up the text
	// in an entry with some other text, e.g. when using the entry to implement
	// editable cells in a sheet widget.
	//
	// Also useful to convert mouse events into coordinates inside the Layout,
	// e.g. to take some action if some part of the entry text is clicked.
	//
	// Note that as the user scrolls around in the entry the offsets will
	// change; you’ll need to connect to the “notify::scroll-offset” signal to
	// track this. Remember when using the Layout functions you need to convert
	// to and from pixels using PANGO_PIXELS() or NGO_SCALE.
	//
	// Keep in mind that the layout text may contain a preedit string, so
	// gtk_entry_layout_index_to_text_index() and
	// gtk_entry_text_index_to_layout_index() are needed to convert byte indices
	// in the layout to byte indices in the entry contents.
	LayoutOffsets() (x int, y int)
	// MaxLength retrieves the maximum allowed length of the text in @entry. See
	// gtk_entry_set_max_length().
	//
	// This is equivalent to getting @entry's EntryBuffer and calling
	// gtk_entry_buffer_get_max_length() on it.
	MaxLength() int
	// MaxWidthChars retrieves the desired maximum width of @entry, in
	// characters. See gtk_entry_set_max_width_chars().
	MaxWidthChars() int
	// OverwriteMode gets the value set by gtk_entry_set_overwrite_mode().
	OverwriteMode() bool
	// PlaceholderText retrieves the text that will be displayed when @entry is
	// empty and unfocused
	PlaceholderText() string
	// ProgressFraction returns the current fraction of the task that’s been
	// completed. See gtk_entry_set_progress_fraction().
	ProgressFraction() float64
	// ProgressPulseStep retrieves the pulse step set with
	// gtk_entry_set_progress_pulse_step().
	ProgressPulseStep() float64
	// Tabs gets the tabstops that were set on the entry using
	// gtk_entry_set_tabs(), if any.
	Tabs() *pango.TabArray
	// Text retrieves the contents of the entry widget. See also
	// gtk_editable_get_chars().
	//
	// This is equivalent to getting @entry's EntryBuffer and calling
	// gtk_entry_buffer_get_text() on it.
	Text() string
	// TextArea gets the area where the entry’s text is drawn. This function is
	// useful when drawing something to the entry in a draw callback.
	//
	// If the entry is not realized, @text_area is filled with zeros.
	//
	// See also gtk_entry_get_icon_area().
	TextArea() gdk.Rectangle
	// TextLength retrieves the current length of the text in @entry.
	//
	// This is equivalent to getting @entry's EntryBuffer and calling
	// gtk_entry_buffer_get_length() on it.
	TextLength() uint16
	// Visibility retrieves whether the text in @entry is visible. See
	// gtk_entry_set_visibility().
	Visibility() bool
	// WidthChars gets the value set by gtk_entry_set_width_chars().
	WidthChars() int
	// GrabFocusWithoutSelecting causes @entry to have keyboard focus.
	//
	// It behaves like gtk_widget_grab_focus(), except that it doesn't select
	// the contents of the entry. You only want to call this on some special
	// entries which the user usually doesn't want to replace all text in, such
	// as search-as-you-type entries.
	GrabFocusWithoutSelecting()
	// ImContextFilterKeypress: allow the Entry input method to internally
	// handle key press and release events. If this function returns true, then
	// no further processing should be done for this key event. See
	// gtk_im_context_filter_keypress().
	//
	// Note that you are expected to call this function from your handler when
	// overriding key event handling. This is needed in the case when you need
	// to insert your own key handling between the input method and the default
	// key event handling of the Entry. See gtk_text_view_reset_im_context() for
	// an example of use.
	ImContextFilterKeypress(event *gdk.EventKey) bool
	// LayoutIndexToTextIndex converts from a position in the entry’s Layout
	// (returned by gtk_entry_get_layout()) to a position in the entry contents
	// (returned by gtk_entry_get_text()).
	LayoutIndexToTextIndex(layoutIndex int) int
	// ProgressPulse indicates that some progress is made, but you don’t know
	// how much. Causes the entry’s progress indicator to enter “activity mode,”
	// where a block bounces back and forth. Each call to
	// gtk_entry_progress_pulse() causes the block to move by a little bit (the
	// amount of movement per pulse is determined by
	// gtk_entry_set_progress_pulse_step()).
	ProgressPulse()
	// ResetImContext: reset the input method context of the entry if needed.
	//
	// This can be necessary in the case where modifying the buffer would
	// confuse on-going input method behavior.
	ResetImContext()
	// SetActivatesDefault: if @setting is true, pressing Enter in the @entry
	// will activate the default widget for the window containing the entry.
	// This usually means that the dialog box containing the entry will be
	// closed, since the default widget is usually one of the dialog buttons.
	//
	// (For experts: if @setting is true, the entry calls
	// gtk_window_activate_default() on the window containing the entry, in the
	// default handler for the Entry::activate signal.)
	SetActivatesDefault(setting bool)
	// SetAlignment sets the alignment for the contents of the entry. This
	// controls the horizontal positioning of the contents when the displayed
	// text is shorter than the width of the entry.
	SetAlignment(xalign float32)
	// SetAttributes sets a AttrList; the attributes in the list are applied to
	// the entry text.
	SetAttributes(attrs *pango.AttrList)
	// SetBuffer: set the EntryBuffer object which holds the text for this
	// widget.
	SetBuffer(buffer EntryBuffer)
	// SetCompletion sets @completion to be the auxiliary completion object to
	// use with @entry. All further configuration of the completion mechanism is
	// done on @completion using the EntryCompletion API. Completion is disabled
	// if @completion is set to nil.
	SetCompletion(completion EntryCompletion)
	// SetCursorHAdjustment hooks up an adjustment to the cursor position in an
	// entry, so that when the cursor is moved, the adjustment is scrolled to
	// show that position. See gtk_scrolled_window_get_hadjustment() for a
	// typical way of obtaining the adjustment.
	//
	// The adjustment has to be in pixel units and in the same coordinate system
	// as the entry.
	SetCursorHAdjustment(adjustment Adjustment)
	// SetHasFrame sets whether the entry has a beveled frame around it.
	SetHasFrame(setting bool)
	// SetIconActivatable sets whether the icon is activatable.
	SetIconActivatable(iconPos EntryIconPosition, activatable bool)
	// SetIconDragSource sets up the icon at the given position so that GTK+
	// will start a drag operation when the user clicks and drags the icon.
	//
	// To handle the drag operation, you need to connect to the usual
	// Widget::drag-data-get (or possibly Widget::drag-data-delete) signal, and
	// use gtk_entry_get_current_icon_drag_source() in your signal handler to
	// find out if the drag was started from an icon.
	//
	// By default, GTK+ uses the icon as the drag icon. You can use the
	// Widget::drag-begin signal to set a different icon. Note that you have to
	// use g_signal_connect_after() to ensure that your signal handler gets
	// executed after the default handler.
	SetIconDragSource(iconPos EntryIconPosition, targetList *TargetList, actions gdk.DragAction)
	// SetIconFromGIcon sets the icon shown in the entry at the specified
	// position from the current icon theme. If the icon isn’t known, a “broken
	// image” icon will be displayed instead.
	//
	// If @icon is nil, no icon will be shown in the specified position.
	SetIconFromGIcon(iconPos EntryIconPosition, icon gio.Icon)
	// SetIconFromIconName sets the icon shown in the entry at the specified
	// position from the current icon theme.
	//
	// If the icon name isn’t known, a “broken image” icon will be displayed
	// instead.
	//
	// If @icon_name is nil, no icon will be shown in the specified position.
	SetIconFromIconName(iconPos EntryIconPosition, iconName string)
	// SetIconFromPixbuf sets the icon shown in the specified position using a
	// pixbuf.
	//
	// If @pixbuf is nil, no icon will be shown in the specified position.
	SetIconFromPixbuf(iconPos EntryIconPosition, pixbuf gdkpixbuf.Pixbuf)
	// SetIconFromStock sets the icon shown in the entry at the specified
	// position from a stock image.
	//
	// If @stock_id is nil, no icon will be shown in the specified position.
	SetIconFromStock(iconPos EntryIconPosition, stockID string)
	// SetIconSensitive sets the sensitivity for the specified icon.
	SetIconSensitive(iconPos EntryIconPosition, sensitive bool)
	// SetIconTooltipMarkup sets @tooltip as the contents of the tooltip for the
	// icon at the specified position. @tooltip is assumed to be marked up with
	// the [Pango text markup language][PangoMarkupFormat].
	//
	// Use nil for @tooltip to remove an existing tooltip.
	//
	// See also gtk_widget_set_tooltip_markup() and
	// gtk_entry_set_icon_tooltip_text().
	SetIconTooltipMarkup(iconPos EntryIconPosition, tooltip string)
	// SetIconTooltipText sets @tooltip as the contents of the tooltip for the
	// icon at the specified position.
	//
	// Use nil for @tooltip to remove an existing tooltip.
	//
	// See also gtk_widget_set_tooltip_text() and
	// gtk_entry_set_icon_tooltip_markup().
	//
	// If you unset the widget tooltip via gtk_widget_set_tooltip_text() or
	// gtk_widget_set_tooltip_markup(), this sets GtkWidget:has-tooltip to
	// false, which suppresses icon tooltips too. You can resolve this by then
	// calling gtk_widget_set_has_tooltip() to set GtkWidget:has-tooltip back to
	// true, or setting at least one non-empty tooltip on any icon achieves the
	// same result.
	SetIconTooltipText(iconPos EntryIconPosition, tooltip string)
	// SetInnerBorder sets entry’s inner-border property to @border, or clears
	// it if nil is passed. The inner-border is the area around the entry’s
	// text, but inside its frame.
	//
	// If set, this property overrides the inner-border style property.
	// Overriding the style-provided border is useful when you want to do
	// in-place editing of some text in a canvas or list widget, where
	// pixel-exact positioning of the entry is important.
	SetInnerBorder(border *Border)
	// SetInputHints sets the Entry:input-hints property, which allows input
	// methods to fine-tune their behaviour.
	SetInputHints(hints InputHints)
	// SetInputPurpose sets the Entry:input-purpose property which can be used
	// by on-screen keyboards and other input methods to adjust their behaviour.
	SetInputPurpose(purpose InputPurpose)
	// SetInvisibleChar sets the character to use in place of the actual text
	// when gtk_entry_set_visibility() has been called to set text visibility to
	// false. i.e. this is the character used in “password mode” to show the
	// user how many characters have been typed. By default, GTK+ picks the best
	// invisible char available in the current font. If you set the invisible
	// char to 0, then the user will get no feedback at all; there will be no
	// text on the screen as they type.
	SetInvisibleChar(ch uint32)
	// SetMaxLength sets the maximum allowed length of the contents of the
	// widget. If the current contents are longer than the given length, then
	// they will be truncated to fit.
	//
	// This is equivalent to getting @entry's EntryBuffer and calling
	// gtk_entry_buffer_set_max_length() on it. ]|
	SetMaxLength(max int)
	// SetMaxWidthChars sets the desired maximum width in characters of @entry.
	SetMaxWidthChars(nChars int)
	// SetOverwriteMode sets whether the text is overwritten when typing in the
	// Entry.
	SetOverwriteMode(overwrite bool)
	// SetPlaceholderText sets text to be displayed in @entry when it is empty
	// and unfocused. This can be used to give a visual hint of the expected
	// contents of the Entry.
	//
	// Note that since the placeholder text gets removed when the entry received
	// focus, using this feature is a bit problematic if the entry is given the
	// initial focus in a window. Sometimes this can be worked around by
	// delaying the initial focus setting until the first key event arrives.
	SetPlaceholderText(text string)
	// SetProgressFraction causes the entry’s progress indicator to “fill in”
	// the given fraction of the bar. The fraction should be between 0.0 and
	// 1.0, inclusive.
	SetProgressFraction(fraction float64)
	// SetProgressPulseStep sets the fraction of total entry width to move the
	// progress bouncing block for each call to gtk_entry_progress_pulse().
	SetProgressPulseStep(fraction float64)
	// SetTabs sets a TabArray; the tabstops in the array are applied to the
	// entry text.
	SetTabs(tabs *pango.TabArray)
	// SetText sets the text in the widget to the given value, replacing the
	// current contents.
	//
	// See gtk_entry_buffer_set_text().
	SetText(text string)
	// SetVisibility sets whether the contents of the entry are visible or not.
	// When visibility is set to false, characters are displayed as the
	// invisible char, and will also appear that way when the text in the entry
	// widget is copied elsewhere.
	//
	// By default, GTK+ picks the best invisible character available in the
	// current font, but it can be changed with gtk_entry_set_invisible_char().
	//
	// Note that you probably want to set Entry:input-purpose to
	// GTK_INPUT_PURPOSE_PASSWORD or GTK_INPUT_PURPOSE_PIN to inform input
	// methods about the purpose of this entry, in addition to setting
	// visibility to false.
	SetVisibility(visible bool)
	// SetWidthChars changes the size request of the entry to be about the right
	// size for @n_chars characters. Note that it changes the size request, the
	// size can still be affected by how you pack the widget into containers. If
	// @n_chars is -1, the size reverts to the default entry size.
	SetWidthChars(nChars int)
	// TextIndexToLayoutIndex converts from a position in the entry contents
	// (returned by gtk_entry_get_text()) to a position in the entry’s Layout
	// (returned by gtk_entry_get_layout(), with text retrieved via
	// pango_layout_get_text()).
	TextIndexToLayoutIndex(textIndex int) int
	// UnsetInvisibleChar unsets the invisible char previously set with
	// gtk_entry_set_invisible_char(). So that the default invisible char is
	// used again.
	UnsetInvisibleChar()
}

// entry implements the Entry interface.
type entry struct {
	Widget
	Buildable
	CellEditable
	Editable
}

var _ Entry = (*entry)(nil)

// WrapEntry wraps a GObject to the right type. It is
// primarily used internally.
func WrapEntry(obj *externglib.Object) Entry {
	return Entry{
		Widget:       WrapWidget(obj),
		Buildable:    WrapBuildable(obj),
		CellEditable: WrapCellEditable(obj),
		Editable:     WrapEditable(obj),
	}
}

func marshalEntry(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapEntry(obj), nil
}

// NewEntry constructs a class Entry.
func NewEntry() Entry {
	var cret C.GtkEntry
	var ret1 Entry

	cret = C.gtk_entry_new()

	ret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Entry)

	return ret1
}

// NewEntryWithBuffer constructs a class Entry.
func NewEntryWithBuffer(buffer EntryBuffer) Entry {
	var arg1 *C.GtkEntryBuffer

	arg1 = (*C.GtkEntryBuffer)(unsafe.Pointer(buffer.Native()))

	var cret C.GtkEntry
	var ret1 Entry

	cret = C.gtk_entry_new_with_buffer(buffer)

	ret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Entry)

	return ret1
}

// ActivatesDefault retrieves the value set by
// gtk_entry_set_activates_default().
func (e entry) ActivatesDefault() bool {
	var arg0 *C.GtkEntry

	arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

	var cret C.gboolean
	var ret1 bool

	cret = C.gtk_entry_get_activates_default(arg0)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// Alignment gets the value set by gtk_entry_set_alignment().
func (e entry) Alignment() float32 {
	var arg0 *C.GtkEntry

	arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

	var cret C.gfloat
	var ret1 float32

	cret = C.gtk_entry_get_alignment(arg0)

	ret1 = C.gfloat(cret)

	return ret1
}

// Attributes gets the attribute list that was set on the entry using
// gtk_entry_set_attributes(), if any.
func (e entry) Attributes() *pango.AttrList {
	var arg0 *C.GtkEntry

	arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

	var cret *C.PangoAttrList
	var ret1 *pango.AttrList

	cret = C.gtk_entry_get_attributes(arg0)

	ret1 = pango.WrapAttrList(unsafe.Pointer(cret))

	return ret1
}

// Buffer: get the EntryBuffer object which holds the text for this widget.
func (e entry) Buffer() EntryBuffer {
	var arg0 *C.GtkEntry

	arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

	var cret *C.GtkEntryBuffer
	var ret1 EntryBuffer

	cret = C.gtk_entry_get_buffer(arg0)

	ret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(EntryBuffer)

	return ret1
}

// Completion returns the auxiliary completion object currently in use by
// @entry.
func (e entry) Completion() EntryCompletion {
	var arg0 *C.GtkEntry

	arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

	var cret *C.GtkEntryCompletion
	var ret1 EntryCompletion

	cret = C.gtk_entry_get_completion(arg0)

	ret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(EntryCompletion)

	return ret1
}

// CurrentIconDragSource returns the index of the icon which is the source
// of the current DND operation, or -1.
//
// This function is meant to be used in a Widget::drag-data-get callback.
func (e entry) CurrentIconDragSource() int {
	var arg0 *C.GtkEntry

	arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

	var cret C.gint
	var ret1 int

	cret = C.gtk_entry_get_current_icon_drag_source(arg0)

	ret1 = C.gint(cret)

	return ret1
}

// CursorHAdjustment retrieves the horizontal cursor adjustment for the
// entry. See gtk_entry_set_cursor_hadjustment().
func (e entry) CursorHAdjustment() Adjustment {
	var arg0 *C.GtkEntry

	arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

	var cret *C.GtkAdjustment
	var ret1 Adjustment

	cret = C.gtk_entry_get_cursor_hadjustment(arg0)

	ret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Adjustment)

	return ret1
}

// HasFrame gets the value set by gtk_entry_set_has_frame().
func (e entry) HasFrame() bool {
	var arg0 *C.GtkEntry

	arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

	var cret C.gboolean
	var ret1 bool

	cret = C.gtk_entry_get_has_frame(arg0)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// IconActivatable returns whether the icon is activatable.
func (e entry) IconActivatable(iconPos EntryIconPosition) bool {
	var arg0 *C.GtkEntry
	var arg1 C.GtkEntryIconPosition

	arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	arg1 = (C.GtkEntryIconPosition)(iconPos)

	var cret C.gboolean
	var ret1 bool

	cret = C.gtk_entry_get_icon_activatable(arg0, iconPos)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// IconArea gets the area where entry’s icon at @icon_pos is drawn. This
// function is useful when drawing something to the entry in a draw
// callback.
//
// If the entry is not realized or has no icon at the given position,
// @icon_area is filled with zeros. Otherwise, @icon_area will be filled
// with the icon’s allocation, relative to @entry’s allocation.
//
// See also gtk_entry_get_text_area()
func (e entry) IconArea(iconPos EntryIconPosition) gdk.Rectangle {
	var arg0 *C.GtkEntry
	var arg1 C.GtkEntryIconPosition

	arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	arg1 = (C.GtkEntryIconPosition)(iconPos)

	var arg2 C.GdkRectangle
	var ret2 *gdk.Rectangle

	C.gtk_entry_get_icon_area(arg0, iconPos, &arg2)

	*ret2 = gdk.WrapRectangle(unsafe.Pointer(arg2))

	return ret2
}

// IconAtPos finds the icon at the given position and return its index. The
// position’s coordinates are relative to the @entry’s top left corner. If
// @x, @y doesn’t lie inside an icon, -1 is returned. This function is
// intended for use in a Widget::query-tooltip signal handler.
func (e entry) IconAtPos(x int, y int) int {
	var arg0 *C.GtkEntry
	var arg1 C.gint
	var arg2 C.gint

	arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	arg1 = C.gint(x)
	arg2 = C.gint(y)

	var cret C.gint
	var ret1 int

	cret = C.gtk_entry_get_icon_at_pos(arg0, x, y)

	ret1 = C.gint(cret)

	return ret1
}

// IconGIcon retrieves the #GIcon used for the icon, or nil if there is no
// icon or if the icon was set by some other method (e.g., by stock, pixbuf,
// or icon name).
func (e entry) IconGIcon(iconPos EntryIconPosition) gio.Icon {
	var arg0 *C.GtkEntry
	var arg1 C.GtkEntryIconPosition

	arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	arg1 = (C.GtkEntryIconPosition)(iconPos)

	var cret *C.GIcon
	var ret1 gio.Icon

	cret = C.gtk_entry_get_icon_gicon(arg0, iconPos)

	ret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(gio.Icon)

	return ret1
}

// IconName retrieves the icon name used for the icon, or nil if there is no
// icon or if the icon was set by some other method (e.g., by pixbuf, stock
// or gicon).
func (e entry) IconName(iconPos EntryIconPosition) string {
	var arg0 *C.GtkEntry
	var arg1 C.GtkEntryIconPosition

	arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	arg1 = (C.GtkEntryIconPosition)(iconPos)

	var cret *C.gchar
	var ret1 string

	cret = C.gtk_entry_get_icon_name(arg0, iconPos)

	ret1 = C.GoString(cret)

	return ret1
}

// IconPixbuf retrieves the image used for the icon.
//
// Unlike the other methods of setting and getting icon data, this method
// will work regardless of whether the icon was set using a Pixbuf, a
// #GIcon, a stock item, or an icon name.
func (e entry) IconPixbuf(iconPos EntryIconPosition) gdkpixbuf.Pixbuf {
	var arg0 *C.GtkEntry
	var arg1 C.GtkEntryIconPosition

	arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	arg1 = (C.GtkEntryIconPosition)(iconPos)

	var cret *C.GdkPixbuf
	var ret1 gdkpixbuf.Pixbuf

	cret = C.gtk_entry_get_icon_pixbuf(arg0, iconPos)

	ret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(gdkpixbuf.Pixbuf)

	return ret1
}

// IconSensitive returns whether the icon appears sensitive or insensitive.
func (e entry) IconSensitive(iconPos EntryIconPosition) bool {
	var arg0 *C.GtkEntry
	var arg1 C.GtkEntryIconPosition

	arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	arg1 = (C.GtkEntryIconPosition)(iconPos)

	var cret C.gboolean
	var ret1 bool

	cret = C.gtk_entry_get_icon_sensitive(arg0, iconPos)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// IconStock retrieves the stock id used for the icon, or nil if there is no
// icon or if the icon was set by some other method (e.g., by pixbuf, icon
// name or gicon).
func (e entry) IconStock(iconPos EntryIconPosition) string {
	var arg0 *C.GtkEntry
	var arg1 C.GtkEntryIconPosition

	arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	arg1 = (C.GtkEntryIconPosition)(iconPos)

	var cret *C.gchar
	var ret1 string

	cret = C.gtk_entry_get_icon_stock(arg0, iconPos)

	ret1 = C.GoString(cret)

	return ret1
}

// IconStorageType gets the type of representation being used by the icon to
// store image data. If the icon has no image data, the return value will be
// GTK_IMAGE_EMPTY.
func (e entry) IconStorageType(iconPos EntryIconPosition) ImageType {
	var arg0 *C.GtkEntry
	var arg1 C.GtkEntryIconPosition

	arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	arg1 = (C.GtkEntryIconPosition)(iconPos)

	var cret C.GtkImageType
	var ret1 ImageType

	cret = C.gtk_entry_get_icon_storage_type(arg0, iconPos)

	ret1 = ImageType(cret)

	return ret1
}

// IconTooltipMarkup gets the contents of the tooltip on the icon at the
// specified position in @entry.
func (e entry) IconTooltipMarkup(iconPos EntryIconPosition) string {
	var arg0 *C.GtkEntry
	var arg1 C.GtkEntryIconPosition

	arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	arg1 = (C.GtkEntryIconPosition)(iconPos)

	var cret *C.gchar
	var ret1 string

	cret = C.gtk_entry_get_icon_tooltip_markup(arg0, iconPos)

	ret1 = C.GoString(cret)
	defer C.free(unsafe.Pointer(cret))

	return ret1
}

// IconTooltipText gets the contents of the tooltip on the icon at the
// specified position in @entry.
func (e entry) IconTooltipText(iconPos EntryIconPosition) string {
	var arg0 *C.GtkEntry
	var arg1 C.GtkEntryIconPosition

	arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	arg1 = (C.GtkEntryIconPosition)(iconPos)

	var cret *C.gchar
	var ret1 string

	cret = C.gtk_entry_get_icon_tooltip_text(arg0, iconPos)

	ret1 = C.GoString(cret)
	defer C.free(unsafe.Pointer(cret))

	return ret1
}

// InnerBorder: this function returns the entry’s Entry:inner-border
// property. See gtk_entry_set_inner_border() for more information.
func (e entry) InnerBorder() *Border {
	var arg0 *C.GtkEntry

	arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

	var cret *C.GtkBorder
	var ret1 *Border

	cret = C.gtk_entry_get_inner_border(arg0)

	ret1 = WrapBorder(unsafe.Pointer(cret))

	return ret1
}

// InputHints gets the value of the Entry:input-hints property.
func (e entry) InputHints() InputHints {
	var arg0 *C.GtkEntry

	arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

	var cret C.GtkInputHints
	var ret1 InputHints

	cret = C.gtk_entry_get_input_hints(arg0)

	ret1 = InputHints(cret)

	return ret1
}

// InputPurpose gets the value of the Entry:input-purpose property.
func (e entry) InputPurpose() InputPurpose {
	var arg0 *C.GtkEntry

	arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

	var cret C.GtkInputPurpose
	var ret1 InputPurpose

	cret = C.gtk_entry_get_input_purpose(arg0)

	ret1 = InputPurpose(cret)

	return ret1
}

// InvisibleChar retrieves the character displayed in place of the real
// characters for entries with visibility set to false. See
// gtk_entry_set_invisible_char().
func (e entry) InvisibleChar() uint32 {
	var arg0 *C.GtkEntry

	arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

	var cret C.gunichar
	var ret1 uint32

	cret = C.gtk_entry_get_invisible_char(arg0)

	ret1 = C.gunichar(cret)

	return ret1
}

// Layout gets the Layout used to display the entry. The layout is useful to
// e.g. convert text positions to pixel positions, in combination with
// gtk_entry_get_layout_offsets(). The returned layout is owned by the entry
// and must not be modified or freed by the caller.
//
// Keep in mind that the layout text may contain a preedit string, so
// gtk_entry_layout_index_to_text_index() and
// gtk_entry_text_index_to_layout_index() are needed to convert byte indices
// in the layout to byte indices in the entry contents.
func (e entry) Layout() pango.Layout {
	var arg0 *C.GtkEntry

	arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

	var cret *C.PangoLayout
	var ret1 pango.Layout

	cret = C.gtk_entry_get_layout(arg0)

	ret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(pango.Layout)

	return ret1
}

// LayoutOffsets obtains the position of the Layout used to render text in
// the entry, in widget coordinates. Useful if you want to line up the text
// in an entry with some other text, e.g. when using the entry to implement
// editable cells in a sheet widget.
//
// Also useful to convert mouse events into coordinates inside the Layout,
// e.g. to take some action if some part of the entry text is clicked.
//
// Note that as the user scrolls around in the entry the offsets will
// change; you’ll need to connect to the “notify::scroll-offset” signal to
// track this. Remember when using the Layout functions you need to convert
// to and from pixels using PANGO_PIXELS() or NGO_SCALE.
//
// Keep in mind that the layout text may contain a preedit string, so
// gtk_entry_layout_index_to_text_index() and
// gtk_entry_text_index_to_layout_index() are needed to convert byte indices
// in the layout to byte indices in the entry contents.
func (e entry) LayoutOffsets() (x int, y int) {
	var arg0 *C.GtkEntry

	arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

	var arg1 C.gint
	var ret1 int
	var arg2 C.gint
	var ret2 int

	C.gtk_entry_get_layout_offsets(arg0, &arg1, &arg2)

	*ret1 = C.gint(arg1)
	*ret2 = C.gint(arg2)

	return ret1, ret2
}

// MaxLength retrieves the maximum allowed length of the text in @entry. See
// gtk_entry_set_max_length().
//
// This is equivalent to getting @entry's EntryBuffer and calling
// gtk_entry_buffer_get_max_length() on it.
func (e entry) MaxLength() int {
	var arg0 *C.GtkEntry

	arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

	var cret C.gint
	var ret1 int

	cret = C.gtk_entry_get_max_length(arg0)

	ret1 = C.gint(cret)

	return ret1
}

// MaxWidthChars retrieves the desired maximum width of @entry, in
// characters. See gtk_entry_set_max_width_chars().
func (e entry) MaxWidthChars() int {
	var arg0 *C.GtkEntry

	arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

	var cret C.gint
	var ret1 int

	cret = C.gtk_entry_get_max_width_chars(arg0)

	ret1 = C.gint(cret)

	return ret1
}

// OverwriteMode gets the value set by gtk_entry_set_overwrite_mode().
func (e entry) OverwriteMode() bool {
	var arg0 *C.GtkEntry

	arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

	var cret C.gboolean
	var ret1 bool

	cret = C.gtk_entry_get_overwrite_mode(arg0)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// PlaceholderText retrieves the text that will be displayed when @entry is
// empty and unfocused
func (e entry) PlaceholderText() string {
	var arg0 *C.GtkEntry

	arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

	var cret *C.gchar
	var ret1 string

	cret = C.gtk_entry_get_placeholder_text(arg0)

	ret1 = C.GoString(cret)

	return ret1
}

// ProgressFraction returns the current fraction of the task that’s been
// completed. See gtk_entry_set_progress_fraction().
func (e entry) ProgressFraction() float64 {
	var arg0 *C.GtkEntry

	arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

	var cret C.gdouble
	var ret1 float64

	cret = C.gtk_entry_get_progress_fraction(arg0)

	ret1 = C.gdouble(cret)

	return ret1
}

// ProgressPulseStep retrieves the pulse step set with
// gtk_entry_set_progress_pulse_step().
func (e entry) ProgressPulseStep() float64 {
	var arg0 *C.GtkEntry

	arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

	var cret C.gdouble
	var ret1 float64

	cret = C.gtk_entry_get_progress_pulse_step(arg0)

	ret1 = C.gdouble(cret)

	return ret1
}

// Tabs gets the tabstops that were set on the entry using
// gtk_entry_set_tabs(), if any.
func (e entry) Tabs() *pango.TabArray {
	var arg0 *C.GtkEntry

	arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

	var cret *C.PangoTabArray
	var ret1 *pango.TabArray

	cret = C.gtk_entry_get_tabs(arg0)

	ret1 = pango.WrapTabArray(unsafe.Pointer(cret))

	return ret1
}

// Text retrieves the contents of the entry widget. See also
// gtk_editable_get_chars().
//
// This is equivalent to getting @entry's EntryBuffer and calling
// gtk_entry_buffer_get_text() on it.
func (e entry) Text() string {
	var arg0 *C.GtkEntry

	arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

	var cret *C.gchar
	var ret1 string

	cret = C.gtk_entry_get_text(arg0)

	ret1 = C.GoString(cret)

	return ret1
}

// TextArea gets the area where the entry’s text is drawn. This function is
// useful when drawing something to the entry in a draw callback.
//
// If the entry is not realized, @text_area is filled with zeros.
//
// See also gtk_entry_get_icon_area().
func (e entry) TextArea() gdk.Rectangle {
	var arg0 *C.GtkEntry

	arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

	var arg1 C.GdkRectangle
	var ret1 *gdk.Rectangle

	C.gtk_entry_get_text_area(arg0, &arg1)

	*ret1 = gdk.WrapRectangle(unsafe.Pointer(arg1))

	return ret1
}

// TextLength retrieves the current length of the text in @entry.
//
// This is equivalent to getting @entry's EntryBuffer and calling
// gtk_entry_buffer_get_length() on it.
func (e entry) TextLength() uint16 {
	var arg0 *C.GtkEntry

	arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

	var cret C.guint16
	var ret1 uint16

	cret = C.gtk_entry_get_text_length(arg0)

	ret1 = C.guint16(cret)

	return ret1
}

// Visibility retrieves whether the text in @entry is visible. See
// gtk_entry_set_visibility().
func (e entry) Visibility() bool {
	var arg0 *C.GtkEntry

	arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

	var cret C.gboolean
	var ret1 bool

	cret = C.gtk_entry_get_visibility(arg0)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// WidthChars gets the value set by gtk_entry_set_width_chars().
func (e entry) WidthChars() int {
	var arg0 *C.GtkEntry

	arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

	var cret C.gint
	var ret1 int

	cret = C.gtk_entry_get_width_chars(arg0)

	ret1 = C.gint(cret)

	return ret1
}

// GrabFocusWithoutSelecting causes @entry to have keyboard focus.
//
// It behaves like gtk_widget_grab_focus(), except that it doesn't select
// the contents of the entry. You only want to call this on some special
// entries which the user usually doesn't want to replace all text in, such
// as search-as-you-type entries.
func (e entry) GrabFocusWithoutSelecting() {
	var arg0 *C.GtkEntry

	arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

	C.gtk_entry_grab_focus_without_selecting(arg0)
}

// ImContextFilterKeypress: allow the Entry input method to internally
// handle key press and release events. If this function returns true, then
// no further processing should be done for this key event. See
// gtk_im_context_filter_keypress().
//
// Note that you are expected to call this function from your handler when
// overriding key event handling. This is needed in the case when you need
// to insert your own key handling between the input method and the default
// key event handling of the Entry. See gtk_text_view_reset_im_context() for
// an example of use.
func (e entry) ImContextFilterKeypress(event *gdk.EventKey) bool {
	var arg0 *C.GtkEntry
	var arg1 *C.GdkEventKey

	arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	arg1 = (*C.GdkEventKey)(unsafe.Pointer(event.Native()))

	var cret C.gboolean
	var ret1 bool

	cret = C.gtk_entry_im_context_filter_keypress(arg0, event)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// LayoutIndexToTextIndex converts from a position in the entry’s Layout
// (returned by gtk_entry_get_layout()) to a position in the entry contents
// (returned by gtk_entry_get_text()).
func (e entry) LayoutIndexToTextIndex(layoutIndex int) int {
	var arg0 *C.GtkEntry
	var arg1 C.gint

	arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	arg1 = C.gint(layoutIndex)

	var cret C.gint
	var ret1 int

	cret = C.gtk_entry_layout_index_to_text_index(arg0, layoutIndex)

	ret1 = C.gint(cret)

	return ret1
}

// ProgressPulse indicates that some progress is made, but you don’t know
// how much. Causes the entry’s progress indicator to enter “activity mode,”
// where a block bounces back and forth. Each call to
// gtk_entry_progress_pulse() causes the block to move by a little bit (the
// amount of movement per pulse is determined by
// gtk_entry_set_progress_pulse_step()).
func (e entry) ProgressPulse() {
	var arg0 *C.GtkEntry

	arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

	C.gtk_entry_progress_pulse(arg0)
}

// ResetImContext: reset the input method context of the entry if needed.
//
// This can be necessary in the case where modifying the buffer would
// confuse on-going input method behavior.
func (e entry) ResetImContext() {
	var arg0 *C.GtkEntry

	arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

	C.gtk_entry_reset_im_context(arg0)
}

// SetActivatesDefault: if @setting is true, pressing Enter in the @entry
// will activate the default widget for the window containing the entry.
// This usually means that the dialog box containing the entry will be
// closed, since the default widget is usually one of the dialog buttons.
//
// (For experts: if @setting is true, the entry calls
// gtk_window_activate_default() on the window containing the entry, in the
// default handler for the Entry::activate signal.)
func (e entry) SetActivatesDefault(setting bool) {
	var arg0 *C.GtkEntry
	var arg1 C.gboolean

	arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	if setting {
		arg1 = C.gboolean(1)
	}

	C.gtk_entry_set_activates_default(arg0, setting)
}

// SetAlignment sets the alignment for the contents of the entry. This
// controls the horizontal positioning of the contents when the displayed
// text is shorter than the width of the entry.
func (e entry) SetAlignment(xalign float32) {
	var arg0 *C.GtkEntry
	var arg1 C.gfloat

	arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	arg1 = C.gfloat(xalign)

	C.gtk_entry_set_alignment(arg0, xalign)
}

// SetAttributes sets a AttrList; the attributes in the list are applied to
// the entry text.
func (e entry) SetAttributes(attrs *pango.AttrList) {
	var arg0 *C.GtkEntry
	var arg1 *C.PangoAttrList

	arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	arg1 = (*C.PangoAttrList)(unsafe.Pointer(attrs.Native()))

	C.gtk_entry_set_attributes(arg0, attrs)
}

// SetBuffer: set the EntryBuffer object which holds the text for this
// widget.
func (e entry) SetBuffer(buffer EntryBuffer) {
	var arg0 *C.GtkEntry
	var arg1 *C.GtkEntryBuffer

	arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	arg1 = (*C.GtkEntryBuffer)(unsafe.Pointer(buffer.Native()))

	C.gtk_entry_set_buffer(arg0, buffer)
}

// SetCompletion sets @completion to be the auxiliary completion object to
// use with @entry. All further configuration of the completion mechanism is
// done on @completion using the EntryCompletion API. Completion is disabled
// if @completion is set to nil.
func (e entry) SetCompletion(completion EntryCompletion) {
	var arg0 *C.GtkEntry
	var arg1 *C.GtkEntryCompletion

	arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	arg1 = (*C.GtkEntryCompletion)(unsafe.Pointer(completion.Native()))

	C.gtk_entry_set_completion(arg0, completion)
}

// SetCursorHAdjustment hooks up an adjustment to the cursor position in an
// entry, so that when the cursor is moved, the adjustment is scrolled to
// show that position. See gtk_scrolled_window_get_hadjustment() for a
// typical way of obtaining the adjustment.
//
// The adjustment has to be in pixel units and in the same coordinate system
// as the entry.
func (e entry) SetCursorHAdjustment(adjustment Adjustment) {
	var arg0 *C.GtkEntry
	var arg1 *C.GtkAdjustment

	arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	arg1 = (*C.GtkAdjustment)(unsafe.Pointer(adjustment.Native()))

	C.gtk_entry_set_cursor_hadjustment(arg0, adjustment)
}

// SetHasFrame sets whether the entry has a beveled frame around it.
func (e entry) SetHasFrame(setting bool) {
	var arg0 *C.GtkEntry
	var arg1 C.gboolean

	arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	if setting {
		arg1 = C.gboolean(1)
	}

	C.gtk_entry_set_has_frame(arg0, setting)
}

// SetIconActivatable sets whether the icon is activatable.
func (e entry) SetIconActivatable(iconPos EntryIconPosition, activatable bool) {
	var arg0 *C.GtkEntry
	var arg1 C.GtkEntryIconPosition
	var arg2 C.gboolean

	arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	arg1 = (C.GtkEntryIconPosition)(iconPos)
	if activatable {
		arg2 = C.gboolean(1)
	}

	C.gtk_entry_set_icon_activatable(arg0, iconPos, activatable)
}

// SetIconDragSource sets up the icon at the given position so that GTK+
// will start a drag operation when the user clicks and drags the icon.
//
// To handle the drag operation, you need to connect to the usual
// Widget::drag-data-get (or possibly Widget::drag-data-delete) signal, and
// use gtk_entry_get_current_icon_drag_source() in your signal handler to
// find out if the drag was started from an icon.
//
// By default, GTK+ uses the icon as the drag icon. You can use the
// Widget::drag-begin signal to set a different icon. Note that you have to
// use g_signal_connect_after() to ensure that your signal handler gets
// executed after the default handler.
func (e entry) SetIconDragSource(iconPos EntryIconPosition, targetList *TargetList, actions gdk.DragAction) {
	var arg0 *C.GtkEntry
	var arg1 C.GtkEntryIconPosition
	var arg2 *C.GtkTargetList
	var arg3 C.GdkDragAction

	arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	arg1 = (C.GtkEntryIconPosition)(iconPos)
	arg2 = (*C.GtkTargetList)(unsafe.Pointer(targetList.Native()))
	arg3 = (C.GdkDragAction)(actions)

	C.gtk_entry_set_icon_drag_source(arg0, iconPos, targetList, actions)
}

// SetIconFromGIcon sets the icon shown in the entry at the specified
// position from the current icon theme. If the icon isn’t known, a “broken
// image” icon will be displayed instead.
//
// If @icon is nil, no icon will be shown in the specified position.
func (e entry) SetIconFromGIcon(iconPos EntryIconPosition, icon gio.Icon) {
	var arg0 *C.GtkEntry
	var arg1 C.GtkEntryIconPosition
	var arg2 *C.GIcon

	arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	arg1 = (C.GtkEntryIconPosition)(iconPos)
	arg2 = (*C.GIcon)(unsafe.Pointer(icon.Native()))

	C.gtk_entry_set_icon_from_gicon(arg0, iconPos, icon)
}

// SetIconFromIconName sets the icon shown in the entry at the specified
// position from the current icon theme.
//
// If the icon name isn’t known, a “broken image” icon will be displayed
// instead.
//
// If @icon_name is nil, no icon will be shown in the specified position.
func (e entry) SetIconFromIconName(iconPos EntryIconPosition, iconName string) {
	var arg0 *C.GtkEntry
	var arg1 C.GtkEntryIconPosition
	var arg2 *C.gchar

	arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	arg1 = (C.GtkEntryIconPosition)(iconPos)
	arg2 = (*C.gchar)(C.CString(iconName))
	defer C.free(unsafe.Pointer(arg2))

	C.gtk_entry_set_icon_from_icon_name(arg0, iconPos, iconName)
}

// SetIconFromPixbuf sets the icon shown in the specified position using a
// pixbuf.
//
// If @pixbuf is nil, no icon will be shown in the specified position.
func (e entry) SetIconFromPixbuf(iconPos EntryIconPosition, pixbuf gdkpixbuf.Pixbuf) {
	var arg0 *C.GtkEntry
	var arg1 C.GtkEntryIconPosition
	var arg2 *C.GdkPixbuf

	arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	arg1 = (C.GtkEntryIconPosition)(iconPos)
	arg2 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))

	C.gtk_entry_set_icon_from_pixbuf(arg0, iconPos, pixbuf)
}

// SetIconFromStock sets the icon shown in the entry at the specified
// position from a stock image.
//
// If @stock_id is nil, no icon will be shown in the specified position.
func (e entry) SetIconFromStock(iconPos EntryIconPosition, stockID string) {
	var arg0 *C.GtkEntry
	var arg1 C.GtkEntryIconPosition
	var arg2 *C.gchar

	arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	arg1 = (C.GtkEntryIconPosition)(iconPos)
	arg2 = (*C.gchar)(C.CString(stockID))
	defer C.free(unsafe.Pointer(arg2))

	C.gtk_entry_set_icon_from_stock(arg0, iconPos, stockID)
}

// SetIconSensitive sets the sensitivity for the specified icon.
func (e entry) SetIconSensitive(iconPos EntryIconPosition, sensitive bool) {
	var arg0 *C.GtkEntry
	var arg1 C.GtkEntryIconPosition
	var arg2 C.gboolean

	arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	arg1 = (C.GtkEntryIconPosition)(iconPos)
	if sensitive {
		arg2 = C.gboolean(1)
	}

	C.gtk_entry_set_icon_sensitive(arg0, iconPos, sensitive)
}

// SetIconTooltipMarkup sets @tooltip as the contents of the tooltip for the
// icon at the specified position. @tooltip is assumed to be marked up with
// the [Pango text markup language][PangoMarkupFormat].
//
// Use nil for @tooltip to remove an existing tooltip.
//
// See also gtk_widget_set_tooltip_markup() and
// gtk_entry_set_icon_tooltip_text().
func (e entry) SetIconTooltipMarkup(iconPos EntryIconPosition, tooltip string) {
	var arg0 *C.GtkEntry
	var arg1 C.GtkEntryIconPosition
	var arg2 *C.gchar

	arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	arg1 = (C.GtkEntryIconPosition)(iconPos)
	arg2 = (*C.gchar)(C.CString(tooltip))
	defer C.free(unsafe.Pointer(arg2))

	C.gtk_entry_set_icon_tooltip_markup(arg0, iconPos, tooltip)
}

// SetIconTooltipText sets @tooltip as the contents of the tooltip for the
// icon at the specified position.
//
// Use nil for @tooltip to remove an existing tooltip.
//
// See also gtk_widget_set_tooltip_text() and
// gtk_entry_set_icon_tooltip_markup().
//
// If you unset the widget tooltip via gtk_widget_set_tooltip_text() or
// gtk_widget_set_tooltip_markup(), this sets GtkWidget:has-tooltip to
// false, which suppresses icon tooltips too. You can resolve this by then
// calling gtk_widget_set_has_tooltip() to set GtkWidget:has-tooltip back to
// true, or setting at least one non-empty tooltip on any icon achieves the
// same result.
func (e entry) SetIconTooltipText(iconPos EntryIconPosition, tooltip string) {
	var arg0 *C.GtkEntry
	var arg1 C.GtkEntryIconPosition
	var arg2 *C.gchar

	arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	arg1 = (C.GtkEntryIconPosition)(iconPos)
	arg2 = (*C.gchar)(C.CString(tooltip))
	defer C.free(unsafe.Pointer(arg2))

	C.gtk_entry_set_icon_tooltip_text(arg0, iconPos, tooltip)
}

// SetInnerBorder sets entry’s inner-border property to @border, or clears
// it if nil is passed. The inner-border is the area around the entry’s
// text, but inside its frame.
//
// If set, this property overrides the inner-border style property.
// Overriding the style-provided border is useful when you want to do
// in-place editing of some text in a canvas or list widget, where
// pixel-exact positioning of the entry is important.
func (e entry) SetInnerBorder(border *Border) {
	var arg0 *C.GtkEntry
	var arg1 *C.GtkBorder

	arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	arg1 = (*C.GtkBorder)(unsafe.Pointer(border.Native()))

	C.gtk_entry_set_inner_border(arg0, border)
}

// SetInputHints sets the Entry:input-hints property, which allows input
// methods to fine-tune their behaviour.
func (e entry) SetInputHints(hints InputHints) {
	var arg0 *C.GtkEntry
	var arg1 C.GtkInputHints

	arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	arg1 = (C.GtkInputHints)(hints)

	C.gtk_entry_set_input_hints(arg0, hints)
}

// SetInputPurpose sets the Entry:input-purpose property which can be used
// by on-screen keyboards and other input methods to adjust their behaviour.
func (e entry) SetInputPurpose(purpose InputPurpose) {
	var arg0 *C.GtkEntry
	var arg1 C.GtkInputPurpose

	arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	arg1 = (C.GtkInputPurpose)(purpose)

	C.gtk_entry_set_input_purpose(arg0, purpose)
}

// SetInvisibleChar sets the character to use in place of the actual text
// when gtk_entry_set_visibility() has been called to set text visibility to
// false. i.e. this is the character used in “password mode” to show the
// user how many characters have been typed. By default, GTK+ picks the best
// invisible char available in the current font. If you set the invisible
// char to 0, then the user will get no feedback at all; there will be no
// text on the screen as they type.
func (e entry) SetInvisibleChar(ch uint32) {
	var arg0 *C.GtkEntry
	var arg1 C.gunichar

	arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	arg1 = C.gunichar(ch)

	C.gtk_entry_set_invisible_char(arg0, ch)
}

// SetMaxLength sets the maximum allowed length of the contents of the
// widget. If the current contents are longer than the given length, then
// they will be truncated to fit.
//
// This is equivalent to getting @entry's EntryBuffer and calling
// gtk_entry_buffer_set_max_length() on it. ]|
func (e entry) SetMaxLength(max int) {
	var arg0 *C.GtkEntry
	var arg1 C.gint

	arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	arg1 = C.gint(max)

	C.gtk_entry_set_max_length(arg0, max)
}

// SetMaxWidthChars sets the desired maximum width in characters of @entry.
func (e entry) SetMaxWidthChars(nChars int) {
	var arg0 *C.GtkEntry
	var arg1 C.gint

	arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	arg1 = C.gint(nChars)

	C.gtk_entry_set_max_width_chars(arg0, nChars)
}

// SetOverwriteMode sets whether the text is overwritten when typing in the
// Entry.
func (e entry) SetOverwriteMode(overwrite bool) {
	var arg0 *C.GtkEntry
	var arg1 C.gboolean

	arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	if overwrite {
		arg1 = C.gboolean(1)
	}

	C.gtk_entry_set_overwrite_mode(arg0, overwrite)
}

// SetPlaceholderText sets text to be displayed in @entry when it is empty
// and unfocused. This can be used to give a visual hint of the expected
// contents of the Entry.
//
// Note that since the placeholder text gets removed when the entry received
// focus, using this feature is a bit problematic if the entry is given the
// initial focus in a window. Sometimes this can be worked around by
// delaying the initial focus setting until the first key event arrives.
func (e entry) SetPlaceholderText(text string) {
	var arg0 *C.GtkEntry
	var arg1 *C.gchar

	arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_entry_set_placeholder_text(arg0, text)
}

// SetProgressFraction causes the entry’s progress indicator to “fill in”
// the given fraction of the bar. The fraction should be between 0.0 and
// 1.0, inclusive.
func (e entry) SetProgressFraction(fraction float64) {
	var arg0 *C.GtkEntry
	var arg1 C.gdouble

	arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	arg1 = C.gdouble(fraction)

	C.gtk_entry_set_progress_fraction(arg0, fraction)
}

// SetProgressPulseStep sets the fraction of total entry width to move the
// progress bouncing block for each call to gtk_entry_progress_pulse().
func (e entry) SetProgressPulseStep(fraction float64) {
	var arg0 *C.GtkEntry
	var arg1 C.gdouble

	arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	arg1 = C.gdouble(fraction)

	C.gtk_entry_set_progress_pulse_step(arg0, fraction)
}

// SetTabs sets a TabArray; the tabstops in the array are applied to the
// entry text.
func (e entry) SetTabs(tabs *pango.TabArray) {
	var arg0 *C.GtkEntry
	var arg1 *C.PangoTabArray

	arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	arg1 = (*C.PangoTabArray)(unsafe.Pointer(tabs.Native()))

	C.gtk_entry_set_tabs(arg0, tabs)
}

// SetText sets the text in the widget to the given value, replacing the
// current contents.
//
// See gtk_entry_buffer_set_text().
func (e entry) SetText(text string) {
	var arg0 *C.GtkEntry
	var arg1 *C.gchar

	arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_entry_set_text(arg0, text)
}

// SetVisibility sets whether the contents of the entry are visible or not.
// When visibility is set to false, characters are displayed as the
// invisible char, and will also appear that way when the text in the entry
// widget is copied elsewhere.
//
// By default, GTK+ picks the best invisible character available in the
// current font, but it can be changed with gtk_entry_set_invisible_char().
//
// Note that you probably want to set Entry:input-purpose to
// GTK_INPUT_PURPOSE_PASSWORD or GTK_INPUT_PURPOSE_PIN to inform input
// methods about the purpose of this entry, in addition to setting
// visibility to false.
func (e entry) SetVisibility(visible bool) {
	var arg0 *C.GtkEntry
	var arg1 C.gboolean

	arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	if visible {
		arg1 = C.gboolean(1)
	}

	C.gtk_entry_set_visibility(arg0, visible)
}

// SetWidthChars changes the size request of the entry to be about the right
// size for @n_chars characters. Note that it changes the size request, the
// size can still be affected by how you pack the widget into containers. If
// @n_chars is -1, the size reverts to the default entry size.
func (e entry) SetWidthChars(nChars int) {
	var arg0 *C.GtkEntry
	var arg1 C.gint

	arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	arg1 = C.gint(nChars)

	C.gtk_entry_set_width_chars(arg0, nChars)
}

// TextIndexToLayoutIndex converts from a position in the entry contents
// (returned by gtk_entry_get_text()) to a position in the entry’s Layout
// (returned by gtk_entry_get_layout(), with text retrieved via
// pango_layout_get_text()).
func (e entry) TextIndexToLayoutIndex(textIndex int) int {
	var arg0 *C.GtkEntry
	var arg1 C.gint

	arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
	arg1 = C.gint(textIndex)

	var cret C.gint
	var ret1 int

	cret = C.gtk_entry_text_index_to_layout_index(arg0, textIndex)

	ret1 = C.gint(cret)

	return ret1
}

// UnsetInvisibleChar unsets the invisible char previously set with
// gtk_entry_set_invisible_char(). So that the default invisible char is
// used again.
func (e entry) UnsetInvisibleChar() {
	var arg0 *C.GtkEntry

	arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

	C.gtk_entry_unset_invisible_char(arg0)
}

type EntryPrivate struct {
	native C.GtkEntryPrivate
}

// WrapEntryPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapEntryPrivate(ptr unsafe.Pointer) *EntryPrivate {
	if ptr == nil {
		return nil
	}

	return (*EntryPrivate)(ptr)
}

func marshalEntryPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapEntryPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (e *EntryPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&e.native)
}
