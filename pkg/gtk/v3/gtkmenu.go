// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"runtime/cgo"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/atk"
	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/gdk/v3"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gtk+-3.0
// #cgo CFLAGS: -Wno-deprecated-declarations
//
// #include <glib-object.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
//
// void gotk4_MenuPositionFunc(GtkMenu*, gint*, gint*, gboolean*, gpointer);
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_arrow_placement_get_type()), F: marshalArrowPlacement},
		{T: externglib.Type(C.gtk_menu_get_type()), F: marshalMenuer},
	})
}

// ArrowPlacement: used to specify the placement of scroll arrows in scrolling
// menus.
type ArrowPlacement int

const (
	// Both: place one arrow on each end of the menu.
	ArrowPlacementBoth ArrowPlacement = iota
	// Start: place both arrows at the top of the menu.
	ArrowPlacementStart
	// End: place both arrows at the bottom of the menu.
	ArrowPlacementEnd
)

func marshalArrowPlacement(p uintptr) (interface{}, error) {
	return ArrowPlacement(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// MenuPositionFunc: user function supplied when calling gtk_menu_popup() which
// controls the positioning of the menu when it is displayed. The function sets
// the @x and @y parameters to the coordinates where the menu is to be drawn. To
// make the menu appear on a different monitor than the mouse pointer,
// gtk_menu_set_monitor() must be called.
type MenuPositionFunc func(menu *Menu, x *int, y *int, userData cgo.Handle) (pushIn bool)

//export gotk4_MenuPositionFunc
func gotk4_MenuPositionFunc(arg0 *C.GtkMenu, arg1 *C.gint, arg2 *C.gint, arg3 *C.gboolean, arg4 C.gpointer) {
	v := gbox.Get(uintptr(arg4))
	if v == nil {
		panic(`callback not found`)
	}

	var menu *Menu          // out
	var x *int              // out
	var y *int              // out
	var userData cgo.Handle // out

	menu = (gextras.CastObject(externglib.Take(unsafe.Pointer(arg0)))).(*Menu)
	x = (*int)(unsafe.Pointer(arg1))
	y = (*int)(unsafe.Pointer(arg2))
	userData = (cgo.Handle)(arg4)

	fn := v.(MenuPositionFunc)
	pushIn := fn(menu, x, y, userData)

	if pushIn {
		*arg3 = C.TRUE
	}
}

// Menuer describes Menu's methods.
type Menuer interface {
	// Attach adds a new MenuItem to a (table) menu.
	Attach(child Widgetter, leftAttach uint, rightAttach uint, topAttach uint, bottomAttach uint)
	// Detach detaches the menu from the widget to which it had been attached.
	Detach()
	// AccelGroup gets the AccelGroup which holds global accelerators for the
	// menu.
	AccelGroup() *AccelGroup
	// AccelPath retrieves the accelerator path set on the menu.
	AccelPath() string
	// Active returns the selected menu item from the menu.
	Active() *Widget
	// AttachWidget returns the Widget that the menu is attached to.
	AttachWidget() *Widget
	// Monitor retrieves the number of the monitor on which to show the menu.
	Monitor() int
	// ReserveToggleSize returns whether the menu reserves space for toggles and
	// icons, regardless of their actual presence.
	ReserveToggleSize() bool
	// TearoffState returns whether the menu is torn off.
	TearoffState() bool
	// Title returns the title of the menu.
	Title() string
	// PlaceOnMonitor places @menu on the given monitor.
	PlaceOnMonitor(monitor gdk.Monitorrer)
	// Popdown removes the menu from the screen.
	Popdown()
	// Popup displays a menu and makes it available for selection.
	Popup(parentMenuShell Widgetter, parentMenuItem Widgetter, fn MenuPositionFunc, button uint, activateTime uint32)
	// ReorderChild moves @child to a new @position in the list of @menu
	// children.
	ReorderChild(child Widgetter, position int)
	// Reposition repositions the menu according to its position function.
	Reposition()
	// SetAccelGroup: set the AccelGroup which holds global accelerators for the
	// menu.
	SetAccelGroup(accelGroup AccelGrouper)
	// SetAccelPath sets an accelerator path for this menu from which
	// accelerator paths for its immediate children, its menu items, can be
	// constructed.
	SetAccelPath(accelPath string)
	// SetActive selects the specified menu item within the menu.
	SetActive(index uint)
	// SetMonitor informs GTK+ on which monitor a menu should be popped up.
	SetMonitor(monitorNum int)
	// SetReserveToggleSize sets whether the menu should reserve space for
	// drawing toggles or icons, regardless of their actual presence.
	SetReserveToggleSize(reserveToggleSize bool)
	// SetScreen sets the Screen on which the menu will be displayed.
	SetScreen(screen gdk.Screener)
	// SetTearoffState changes the tearoff state of the menu.
	SetTearoffState(tornOff bool)
	// SetTitle sets the title string for the menu.
	SetTitle(title string)
}

// Menu is a MenuShell that implements a drop down menu consisting of a list of
// MenuItem objects which can be navigated and activated by the user to perform
// application functions.
//
// A Menu is most commonly dropped down by activating a MenuItem in a MenuBar or
// popped up by activating a MenuItem in another Menu.
//
// A Menu can also be popped up by activating a ComboBox. Other composite
// widgets such as the Notebook can pop up a Menu as well.
//
// Applications can display a Menu as a popup menu by calling the
// gtk_menu_popup() function. The example below shows how an application can pop
// up a menu when the 3rd mouse button is pressed.
//
// Connecting the popup signal handler.
//
//    menu
//    ├── arrow.top
//    ├── <child>
//    ┊
//    ├── <child>
//    ╰── arrow.bottom
//
// The main CSS node of GtkMenu has name menu, and there are two subnodes with
// name arrow, for scrolling menu arrows. These subnodes get the .top and
// .bottom style classes.
type Menu struct {
	MenuShell
}

var (
	_ Menuer          = (*Menu)(nil)
	_ gextras.Nativer = (*Menu)(nil)
)

func wrapMenu(obj *externglib.Object) Menuer {
	return &Menu{
		MenuShell: MenuShell{
			Container: Container{
				Widget: Widget{
					InitiallyUnowned: externglib.InitiallyUnowned{
						Object: obj,
					},
					ImplementorIface: atk.ImplementorIface{
						Object: obj,
					},
					Buildable: Buildable{
						Object: obj,
					},
				},
			},
		},
	}
}

func marshalMenuer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapMenu(obj), nil
}

// NewMenu creates a new Menu
func NewMenu() *Menu {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_menu_new()

	var _menu *Menu // out

	_menu = (gextras.CastObject(externglib.Take(unsafe.Pointer(_cret)))).(*Menu)

	return _menu
}

// NewMenuFromModel creates a Menu and populates it with menu items and submenus
// according to @model.
//
// The created menu items are connected to actions found in the
// ApplicationWindow to which the menu belongs - typically by means of being
// attached to a widget (see gtk_menu_attach_to_widget()) that is contained
// within the ApplicationWindows widget hierarchy.
//
// Actions can also be added using gtk_widget_insert_action_group() on the
// menu's attach widget or on any of its parent widgets.
func NewMenuFromModel(model gio.MenuModeller) *Menu {
	var _arg1 *C.GMenuModel // out
	var _cret *C.GtkWidget  // in

	_arg1 = (*C.GMenuModel)(unsafe.Pointer((model).(gextras.Nativer).Native()))

	_cret = C.gtk_menu_new_from_model(_arg1)

	var _menu *Menu // out

	_menu = (gextras.CastObject(externglib.Take(unsafe.Pointer(_cret)))).(*Menu)

	return _menu
}

// Attach adds a new MenuItem to a (table) menu. The number of “cells” that an
// item will occupy is specified by @left_attach, @right_attach, @top_attach and
// @bottom_attach. These each represent the leftmost, rightmost, uppermost and
// lower column and row numbers of the table. (Columns and rows are indexed from
// zero).
//
// Note that this function is not related to gtk_menu_detach().
func (menu *Menu) Attach(child Widgetter, leftAttach uint, rightAttach uint, topAttach uint, bottomAttach uint) {
	var _arg0 *C.GtkMenu   // out
	var _arg1 *C.GtkWidget // out
	var _arg2 C.guint      // out
	var _arg3 C.guint      // out
	var _arg4 C.guint      // out
	var _arg5 C.guint      // out

	_arg0 = (*C.GtkMenu)(unsafe.Pointer(menu.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer((child).(gextras.Nativer).Native()))
	_arg2 = C.guint(leftAttach)
	_arg3 = C.guint(rightAttach)
	_arg4 = C.guint(topAttach)
	_arg5 = C.guint(bottomAttach)

	C.gtk_menu_attach(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
}

// Detach detaches the menu from the widget to which it had been attached. This
// function will call the callback function, @detacher, provided when the
// gtk_menu_attach_to_widget() function was called.
func (menu *Menu) Detach() {
	var _arg0 *C.GtkMenu // out

	_arg0 = (*C.GtkMenu)(unsafe.Pointer(menu.Native()))

	C.gtk_menu_detach(_arg0)
}

// AccelGroup gets the AccelGroup which holds global accelerators for the menu.
// See gtk_menu_set_accel_group().
func (menu *Menu) AccelGroup() *AccelGroup {
	var _arg0 *C.GtkMenu       // out
	var _cret *C.GtkAccelGroup // in

	_arg0 = (*C.GtkMenu)(unsafe.Pointer(menu.Native()))

	_cret = C.gtk_menu_get_accel_group(_arg0)

	var _accelGroup *AccelGroup // out

	_accelGroup = (gextras.CastObject(externglib.Take(unsafe.Pointer(_cret)))).(*AccelGroup)

	return _accelGroup
}

// AccelPath retrieves the accelerator path set on the menu.
func (menu *Menu) AccelPath() string {
	var _arg0 *C.GtkMenu // out
	var _cret *C.gchar   // in

	_arg0 = (*C.GtkMenu)(unsafe.Pointer(menu.Native()))

	_cret = C.gtk_menu_get_accel_path(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(_cret))

	return _utf8
}

// Active returns the selected menu item from the menu. This is used by the
// ComboBox.
func (menu *Menu) Active() *Widget {
	var _arg0 *C.GtkMenu   // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkMenu)(unsafe.Pointer(menu.Native()))

	_cret = C.gtk_menu_get_active(_arg0)

	var _widget *Widget // out

	_widget = (gextras.CastObject(externglib.Take(unsafe.Pointer(_cret)))).(*Widget)

	return _widget
}

// AttachWidget returns the Widget that the menu is attached to.
func (menu *Menu) AttachWidget() *Widget {
	var _arg0 *C.GtkMenu   // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkMenu)(unsafe.Pointer(menu.Native()))

	_cret = C.gtk_menu_get_attach_widget(_arg0)

	var _widget *Widget // out

	_widget = (gextras.CastObject(externglib.Take(unsafe.Pointer(_cret)))).(*Widget)

	return _widget
}

// Monitor retrieves the number of the monitor on which to show the menu.
func (menu *Menu) Monitor() int {
	var _arg0 *C.GtkMenu // out
	var _cret C.gint     // in

	_arg0 = (*C.GtkMenu)(unsafe.Pointer(menu.Native()))

	_cret = C.gtk_menu_get_monitor(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// ReserveToggleSize returns whether the menu reserves space for toggles and
// icons, regardless of their actual presence.
func (menu *Menu) ReserveToggleSize() bool {
	var _arg0 *C.GtkMenu // out
	var _cret C.gboolean // in

	_arg0 = (*C.GtkMenu)(unsafe.Pointer(menu.Native()))

	_cret = C.gtk_menu_get_reserve_toggle_size(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TearoffState returns whether the menu is torn off. See
// gtk_menu_set_tearoff_state().
//
// Deprecated: since version 3.10.
func (menu *Menu) TearoffState() bool {
	var _arg0 *C.GtkMenu // out
	var _cret C.gboolean // in

	_arg0 = (*C.GtkMenu)(unsafe.Pointer(menu.Native()))

	_cret = C.gtk_menu_get_tearoff_state(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Title returns the title of the menu. See gtk_menu_set_title().
//
// Deprecated: since version 3.10.
func (menu *Menu) Title() string {
	var _arg0 *C.GtkMenu // out
	var _cret *C.gchar   // in

	_arg0 = (*C.GtkMenu)(unsafe.Pointer(menu.Native()))

	_cret = C.gtk_menu_get_title(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(_cret))

	return _utf8
}

// PlaceOnMonitor places @menu on the given monitor.
func (menu *Menu) PlaceOnMonitor(monitor gdk.Monitorrer) {
	var _arg0 *C.GtkMenu    // out
	var _arg1 *C.GdkMonitor // out

	_arg0 = (*C.GtkMenu)(unsafe.Pointer(menu.Native()))
	_arg1 = (*C.GdkMonitor)(unsafe.Pointer((monitor).(gextras.Nativer).Native()))

	C.gtk_menu_place_on_monitor(_arg0, _arg1)
}

// Popdown removes the menu from the screen.
func (menu *Menu) Popdown() {
	var _arg0 *C.GtkMenu // out

	_arg0 = (*C.GtkMenu)(unsafe.Pointer(menu.Native()))

	C.gtk_menu_popdown(_arg0)
}

// Popup displays a menu and makes it available for selection.
//
// Applications can use this function to display context-sensitive menus, and
// will typically supply nil for the @parent_menu_shell, @parent_menu_item,
// @func and @data parameters. The default menu positioning function will
// position the menu at the current mouse cursor position.
//
// The @button parameter should be the mouse button pressed to initiate the menu
// popup. If the menu popup was initiated by something other than a mouse button
// press, such as a mouse button release or a keypress, @button should be 0.
//
// The @activate_time parameter is used to conflict-resolve initiation of
// concurrent requests for mouse/keyboard grab requests. To function properly,
// this needs to be the timestamp of the user event (such as a mouse click or
// key press) that caused the initiation of the popup. Only if no such event is
// available, gtk_get_current_event_time() can be used instead.
//
// Note that this function does not work very well on GDK backends that do not
// have global coordinates, such as Wayland or Mir. You should probably use one
// of the gtk_menu_popup_at_ variants, which do not have this problem.
//
// Deprecated: Please use gtk_menu_popup_at_widget(),
// gtk_menu_popup_at_pointer(). or gtk_menu_popup_at_rect() instead.
func (menu *Menu) Popup(parentMenuShell Widgetter, parentMenuItem Widgetter, fn MenuPositionFunc, button uint, activateTime uint32) {
	var _arg0 *C.GtkMenu            // out
	var _arg1 *C.GtkWidget          // out
	var _arg2 *C.GtkWidget          // out
	var _arg3 C.GtkMenuPositionFunc // out
	var _arg4 C.gpointer
	var _arg5 C.guint   // out
	var _arg6 C.guint32 // out

	_arg0 = (*C.GtkMenu)(unsafe.Pointer(menu.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer((parentMenuShell).(gextras.Nativer).Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer((parentMenuItem).(gextras.Nativer).Native()))
	_arg3 = (*[0]byte)(C.gotk4_MenuPositionFunc)
	_arg4 = C.gpointer(gbox.Assign(fn))
	_arg5 = C.guint(button)
	_arg6 = C.guint32(activateTime)

	C.gtk_menu_popup(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
}

// ReorderChild moves @child to a new @position in the list of @menu children.
func (menu *Menu) ReorderChild(child Widgetter, position int) {
	var _arg0 *C.GtkMenu   // out
	var _arg1 *C.GtkWidget // out
	var _arg2 C.gint       // out

	_arg0 = (*C.GtkMenu)(unsafe.Pointer(menu.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer((child).(gextras.Nativer).Native()))
	_arg2 = C.gint(position)

	C.gtk_menu_reorder_child(_arg0, _arg1, _arg2)
}

// Reposition repositions the menu according to its position function.
func (menu *Menu) Reposition() {
	var _arg0 *C.GtkMenu // out

	_arg0 = (*C.GtkMenu)(unsafe.Pointer(menu.Native()))

	C.gtk_menu_reposition(_arg0)
}

// SetAccelGroup: set the AccelGroup which holds global accelerators for the
// menu. This accelerator group needs to also be added to all windows that this
// menu is being used in with gtk_window_add_accel_group(), in order for those
// windows to support all the accelerators contained in this group.
func (menu *Menu) SetAccelGroup(accelGroup AccelGrouper) {
	var _arg0 *C.GtkMenu       // out
	var _arg1 *C.GtkAccelGroup // out

	_arg0 = (*C.GtkMenu)(unsafe.Pointer(menu.Native()))
	_arg1 = (*C.GtkAccelGroup)(unsafe.Pointer((accelGroup).(gextras.Nativer).Native()))

	C.gtk_menu_set_accel_group(_arg0, _arg1)
}

// SetAccelPath sets an accelerator path for this menu from which accelerator
// paths for its immediate children, its menu items, can be constructed. The
// main purpose of this function is to spare the programmer the inconvenience of
// having to call gtk_menu_item_set_accel_path() on each menu item that should
// support runtime user changable accelerators. Instead, by just calling
// gtk_menu_set_accel_path() on their parent, each menu item of this menu, that
// contains a label describing its purpose, automatically gets an accel path
// assigned.
//
// For example, a menu containing menu items “New” and “Exit”, will, after
// `gtk_menu_set_accel_path (menu, "<Gnumeric-Sheet>/File");` has been called,
// assign its items the accel paths: `"<Gnumeric-Sheet>/File/New"` and
// `"<Gnumeric-Sheet>/File/Exit"`.
//
// Assigning accel paths to menu items then enables the user to change their
// accelerators at runtime. More details about accelerator paths and their
// default setups can be found at gtk_accel_map_add_entry().
//
// Note that @accel_path string will be stored in a #GQuark. Therefore, if you
// pass a static string, you can save some memory by interning it first with
// g_intern_static_string().
func (menu *Menu) SetAccelPath(accelPath string) {
	var _arg0 *C.GtkMenu // out
	var _arg1 *C.gchar   // out

	_arg0 = (*C.GtkMenu)(unsafe.Pointer(menu.Native()))
	_arg1 = (*C.gchar)(C.CString(accelPath))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_menu_set_accel_path(_arg0, _arg1)
}

// SetActive selects the specified menu item within the menu. This is used by
// the ComboBox and should not be used by anyone else.
func (menu *Menu) SetActive(index uint) {
	var _arg0 *C.GtkMenu // out
	var _arg1 C.guint    // out

	_arg0 = (*C.GtkMenu)(unsafe.Pointer(menu.Native()))
	_arg1 = C.guint(index)

	C.gtk_menu_set_active(_arg0, _arg1)
}

// SetMonitor informs GTK+ on which monitor a menu should be popped up. See
// gdk_monitor_get_geometry().
//
// This function should be called from a MenuPositionFunc if the menu should not
// appear on the same monitor as the pointer. This information can’t be reliably
// inferred from the coordinates returned by a MenuPositionFunc, since, for very
// long menus, these coordinates may extend beyond the monitor boundaries or
// even the screen boundaries.
func (menu *Menu) SetMonitor(monitorNum int) {
	var _arg0 *C.GtkMenu // out
	var _arg1 C.gint     // out

	_arg0 = (*C.GtkMenu)(unsafe.Pointer(menu.Native()))
	_arg1 = C.gint(monitorNum)

	C.gtk_menu_set_monitor(_arg0, _arg1)
}

// SetReserveToggleSize sets whether the menu should reserve space for drawing
// toggles or icons, regardless of their actual presence.
func (menu *Menu) SetReserveToggleSize(reserveToggleSize bool) {
	var _arg0 *C.GtkMenu // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.GtkMenu)(unsafe.Pointer(menu.Native()))
	if reserveToggleSize {
		_arg1 = C.TRUE
	}

	C.gtk_menu_set_reserve_toggle_size(_arg0, _arg1)
}

// SetScreen sets the Screen on which the menu will be displayed.
func (menu *Menu) SetScreen(screen gdk.Screener) {
	var _arg0 *C.GtkMenu   // out
	var _arg1 *C.GdkScreen // out

	_arg0 = (*C.GtkMenu)(unsafe.Pointer(menu.Native()))
	_arg1 = (*C.GdkScreen)(unsafe.Pointer((screen).(gextras.Nativer).Native()))

	C.gtk_menu_set_screen(_arg0, _arg1)
}

// SetTearoffState changes the tearoff state of the menu. A menu is normally
// displayed as drop down menu which persists as long as the menu is active. It
// can also be displayed as a tearoff menu which persists until it is closed or
// reattached.
//
// Deprecated: since version 3.10.
func (menu *Menu) SetTearoffState(tornOff bool) {
	var _arg0 *C.GtkMenu // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.GtkMenu)(unsafe.Pointer(menu.Native()))
	if tornOff {
		_arg1 = C.TRUE
	}

	C.gtk_menu_set_tearoff_state(_arg0, _arg1)
}

// SetTitle sets the title string for the menu.
//
// The title is displayed when the menu is shown as a tearoff menu. If @title is
// nil, the menu will see if it is attached to a parent menu item, and if so it
// will try to use the same text as that menu item’s label.
//
// Deprecated: since version 3.10.
func (menu *Menu) SetTitle(title string) {
	var _arg0 *C.GtkMenu // out
	var _arg1 *C.gchar   // out

	_arg0 = (*C.GtkMenu)(unsafe.Pointer(menu.Native()))
	_arg1 = (*C.gchar)(C.CString(title))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_menu_set_title(_arg0, _arg1)
}
