// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"unsafe"

	"github.com/diamondburned/gotk4/internal/gextras"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config:
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <stdbool.h>
// #include <glib-object.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_level_bar_get_type()), F: marshalLevelBar},
	})
}

// LevelBar: the LevelBar is a bar widget that can be used as a level indicator.
// Typical use cases are displaying the strength of a password, or showing the
// charge level of a battery.
//
// Use gtk_level_bar_set_value() to set the current value, and
// gtk_level_bar_add_offset_value() to set the value offsets at which the bar
// will be considered in a different state. GTK will add a few offsets by
// default on the level bar: K_LEVEL_BAR_OFFSET_LOW, K_LEVEL_BAR_OFFSET_HIGH and
// K_LEVEL_BAR_OFFSET_FULL, with values 0.25, 0.75 and 1.0 respectively.
//
// Note that it is your responsibility to update preexisting offsets when
// changing the minimum or maximum value. GTK+ will simply clamp them to the new
// range.
//
// Adding a custom offset on the bar
//
//    levelbar[.discrete]
//    ╰── trough
//        ├── block.filled.level-name
//        ┊
//        ├── block.empty
//        ┊
//
// GtkLevelBar has a main CSS node with name levelbar and one of the style
// classes .discrete or .continuous and a subnode with name trough. Below the
// trough node are a number of nodes with name block and style class .filled or
// .empty. In continuous mode, there is exactly one node of each, in discrete
// mode, the number of filled and unfilled nodes corresponds to blocks that are
// drawn. The block.filled nodes also get a style class .level-name
// corresponding to the level for the current value.
//
// In horizontal orientation, the nodes are always arranged from left to right,
// regardless of text direction.
type LevelBar interface {
	Widget
	Buildable
	Orientable

	// AddOffsetValue adds a new offset marker on @self at the position
	// specified by @value. When the bar value is in the interval topped by
	// @value (or between @value and LevelBar:max-value in case the offset is
	// the last one on the bar) a style class named `level-`@name will be
	// applied when rendering the level bar fill. If another offset marker named
	// @name exists, its value will be replaced by @value.
	AddOffsetValue(name string, value float64)
	// Inverted: return the value of the LevelBar:inverted property.
	Inverted() bool
	// MaxValue returns the value of the LevelBar:max-value property.
	MaxValue() float64
	// MinValue returns the value of the LevelBar:min-value property.
	MinValue() float64
	// Mode returns the value of the LevelBar:mode property.
	Mode() LevelBarMode
	// OffsetValue fetches the value specified for the offset marker @name in
	// @self, returning true in case an offset named @name was found.
	OffsetValue(name string) (value float64, ok bool)
	// Value returns the value of the LevelBar:value property.
	Value() float64
	// RemoveOffsetValue removes an offset marker previously added with
	// gtk_level_bar_add_offset_value().
	RemoveOffsetValue(name string)
	// SetInverted sets the value of the LevelBar:inverted property.
	SetInverted(inverted bool)
	// SetMaxValue sets the value of the LevelBar:max-value property.
	//
	// You probably want to update preexisting level offsets after calling this
	// function.
	SetMaxValue(value float64)
	// SetMinValue sets the value of the LevelBar:min-value property.
	//
	// You probably want to update preexisting level offsets after calling this
	// function.
	SetMinValue(value float64)
	// SetMode sets the value of the LevelBar:mode property.
	SetMode(mode LevelBarMode)
	// SetValue sets the value of the LevelBar:value property.
	SetValue(value float64)
}

// levelBar implements the LevelBar interface.
type levelBar struct {
	Widget
	Buildable
	Orientable
}

var _ LevelBar = (*levelBar)(nil)

// WrapLevelBar wraps a GObject to the right type. It is
// primarily used internally.
func WrapLevelBar(obj *externglib.Object) LevelBar {
	return LevelBar{
		Widget:     WrapWidget(obj),
		Buildable:  WrapBuildable(obj),
		Orientable: WrapOrientable(obj),
	}
}

func marshalLevelBar(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapLevelBar(obj), nil
}

// NewLevelBar constructs a class LevelBar.
func NewLevelBar() LevelBar {
	var cret C.GtkLevelBar
	var ret1 LevelBar

	cret = C.gtk_level_bar_new()

	ret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(LevelBar)

	return ret1
}

// NewLevelBarForInterval constructs a class LevelBar.
func NewLevelBarForInterval(minValue float64, maxValue float64) LevelBar {
	var arg1 C.gdouble
	var arg2 C.gdouble

	arg1 = C.gdouble(minValue)
	arg2 = C.gdouble(maxValue)

	var cret C.GtkLevelBar
	var ret1 LevelBar

	cret = C.gtk_level_bar_new_for_interval(minValue, maxValue)

	ret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(LevelBar)

	return ret1
}

// AddOffsetValue adds a new offset marker on @self at the position
// specified by @value. When the bar value is in the interval topped by
// @value (or between @value and LevelBar:max-value in case the offset is
// the last one on the bar) a style class named `level-`@name will be
// applied when rendering the level bar fill. If another offset marker named
// @name exists, its value will be replaced by @value.
func (s levelBar) AddOffsetValue(name string, value float64) {
	var arg0 *C.GtkLevelBar
	var arg1 *C.gchar
	var arg2 C.gdouble

	arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gdouble(value)

	C.gtk_level_bar_add_offset_value(arg0, name, value)
}

// Inverted: return the value of the LevelBar:inverted property.
func (s levelBar) Inverted() bool {
	var arg0 *C.GtkLevelBar

	arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))

	var cret C.gboolean
	var ret1 bool

	cret = C.gtk_level_bar_get_inverted(arg0)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// MaxValue returns the value of the LevelBar:max-value property.
func (s levelBar) MaxValue() float64 {
	var arg0 *C.GtkLevelBar

	arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))

	var cret C.gdouble
	var ret1 float64

	cret = C.gtk_level_bar_get_max_value(arg0)

	ret1 = C.gdouble(cret)

	return ret1
}

// MinValue returns the value of the LevelBar:min-value property.
func (s levelBar) MinValue() float64 {
	var arg0 *C.GtkLevelBar

	arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))

	var cret C.gdouble
	var ret1 float64

	cret = C.gtk_level_bar_get_min_value(arg0)

	ret1 = C.gdouble(cret)

	return ret1
}

// Mode returns the value of the LevelBar:mode property.
func (s levelBar) Mode() LevelBarMode {
	var arg0 *C.GtkLevelBar

	arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))

	var cret C.GtkLevelBarMode
	var ret1 LevelBarMode

	cret = C.gtk_level_bar_get_mode(arg0)

	ret1 = LevelBarMode(cret)

	return ret1
}

// OffsetValue fetches the value specified for the offset marker @name in
// @self, returning true in case an offset named @name was found.
func (s levelBar) OffsetValue(name string) (value float64, ok bool) {
	var arg0 *C.GtkLevelBar
	var arg1 *C.gchar

	arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	var arg2 C.gdouble
	var ret2 float64
	var cret C.gboolean
	var ret2 bool

	cret = C.gtk_level_bar_get_offset_value(arg0, name, &arg2)

	*ret2 = C.gdouble(arg2)
	ret2 = C.bool(cret) != C.false

	return ret2, ret2
}

// Value returns the value of the LevelBar:value property.
func (s levelBar) Value() float64 {
	var arg0 *C.GtkLevelBar

	arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))

	var cret C.gdouble
	var ret1 float64

	cret = C.gtk_level_bar_get_value(arg0)

	ret1 = C.gdouble(cret)

	return ret1
}

// RemoveOffsetValue removes an offset marker previously added with
// gtk_level_bar_add_offset_value().
func (s levelBar) RemoveOffsetValue(name string) {
	var arg0 *C.GtkLevelBar
	var arg1 *C.gchar

	arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_level_bar_remove_offset_value(arg0, name)
}

// SetInverted sets the value of the LevelBar:inverted property.
func (s levelBar) SetInverted(inverted bool) {
	var arg0 *C.GtkLevelBar
	var arg1 C.gboolean

	arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))
	if inverted {
		arg1 = C.gboolean(1)
	}

	C.gtk_level_bar_set_inverted(arg0, inverted)
}

// SetMaxValue sets the value of the LevelBar:max-value property.
//
// You probably want to update preexisting level offsets after calling this
// function.
func (s levelBar) SetMaxValue(value float64) {
	var arg0 *C.GtkLevelBar
	var arg1 C.gdouble

	arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))
	arg1 = C.gdouble(value)

	C.gtk_level_bar_set_max_value(arg0, value)
}

// SetMinValue sets the value of the LevelBar:min-value property.
//
// You probably want to update preexisting level offsets after calling this
// function.
func (s levelBar) SetMinValue(value float64) {
	var arg0 *C.GtkLevelBar
	var arg1 C.gdouble

	arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))
	arg1 = C.gdouble(value)

	C.gtk_level_bar_set_min_value(arg0, value)
}

// SetMode sets the value of the LevelBar:mode property.
func (s levelBar) SetMode(mode LevelBarMode) {
	var arg0 *C.GtkLevelBar
	var arg1 C.GtkLevelBarMode

	arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))
	arg1 = (C.GtkLevelBarMode)(mode)

	C.gtk_level_bar_set_mode(arg0, mode)
}

// SetValue sets the value of the LevelBar:value property.
func (s levelBar) SetValue(value float64) {
	var arg0 *C.GtkLevelBar
	var arg1 C.gdouble

	arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))
	arg1 = C.gdouble(value)

	C.gtk_level_bar_set_value(arg0, value)
}

type LevelBarPrivate struct {
	native C.GtkLevelBarPrivate
}

// WrapLevelBarPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapLevelBarPrivate(ptr unsafe.Pointer) *LevelBarPrivate {
	if ptr == nil {
		return nil
	}

	return (*LevelBarPrivate)(ptr)
}

func marshalLevelBarPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapLevelBarPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (l *LevelBarPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&l.native)
}
