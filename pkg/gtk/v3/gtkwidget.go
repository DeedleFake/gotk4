// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/internal/box"
	"github.com/diamondburned/gotk4/internal/gextras"
	"github.com/diamondburned/gotk4/pkg/cairo"
	"github.com/diamondburned/gotk4/pkg/gdk/v3"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gtk+-3.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <stdbool.h>
// #include <glib-object.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
//
// void gotk4_Callback(GtkWidget*, gpointer);
// gboolean gotk4_TickCallback(GtkWidget*, GdkFrameClock*, gpointer);
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_requisition_get_type()), F: marshalRequisition},
	})
}

// Allocation: a Allocation-struct of a widget represents region which has been
// allocated to the widget by its parent. It is a subregion of its parents
// allocation. See [GtkWidget’s geometry management
// section][geometry-management] for more information.
type Allocation gdk.Rectangle

// Callback: the type of the callback functions used for e.g. iterating over the
// children of a container, see gtk_container_foreach().
type Callback func(widget Widget)

//export gotk4_Callback
func gotk4_Callback(arg0 *C.GtkWidget, arg1 C.gpointer) {
	v := box.Get(uintptr(arg1))
	if v == nil {
		panic(`callback not found`)
	}

	var widget Widget

	widget = gextras.CastObject(externglib.Take(unsafe.Pointer(arg0.Native()))).(Widget)

	v.(Callback)(widget)
}

// TickCallback: callback type for adding a function to update animations. See
// gtk_widget_add_tick_callback().
type TickCallback func(widget Widget, frameClock gdk.FrameClock) bool

//export gotk4_TickCallback
func gotk4_TickCallback(arg0 *C.GtkWidget, arg1 *C.GdkFrameClock, arg2 C.gpointer) C.gboolean {
	v := box.Get(uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var widget Widget
	var frameClock gdk.FrameClock

	widget = gextras.CastObject(externglib.Take(unsafe.Pointer(arg0.Native()))).(Widget)

	frameClock = gextras.CastObject(externglib.Take(unsafe.Pointer(arg1.Native()))).(gdk.FrameClock)

	ok := v.(TickCallback)(widget, frameClock)
}

// CairoShouldDrawWindow: this function is supposed to be called in Widget::draw
// implementations for widgets that support multiple windows. @cr must be
// untransformed from invoking of the draw function. This function will return
// true if the contents of the given @window are supposed to be drawn and false
// otherwise. Note that when the drawing was not initiated by the windowing
// system this function will return true for all windows, so you need to draw
// the bottommost window first. Also, do not use “else if” statements to check
// which window should be drawn.
func CairoShouldDrawWindow(cr *cairo.Context, window gdk.Window) bool {
	var arg1 *C.cairo_t
	var arg2 *C.GdkWindow

	arg1 = (*C.cairo_t)(cr.Native())
	arg2 = (*C.GdkWindow)(window.Native())

	ret := C.gtk_cairo_should_draw_window(arg1, arg2)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// CairoTransformToWindow transforms the given cairo context @cr that from
// @widget-relative coordinates to @window-relative coordinates. If the
// @widget’s window is not an ancestor of @window, no modification will be
// applied.
//
// This is the inverse to the transformation GTK applies when preparing an
// expose event to be emitted with the Widget::draw signal. It is intended to
// help porting multiwindow widgets from GTK+ 2 to the rendering architecture of
// GTK+ 3.
func CairoTransformToWindow(cr *cairo.Context, widget Widget, window gdk.Window) {
	var arg1 *C.cairo_t
	var arg2 *C.GtkWidget
	var arg3 *C.GdkWindow

	arg1 = (*C.cairo_t)(cr.Native())
	arg2 = (*C.GtkWidget)(widget.Native())
	arg3 = (*C.GdkWindow)(window.Native())

	C.gtk_cairo_transform_to_window(arg1, arg2, arg3)
}

// Requisition: a Requisition-struct represents the desired size of a widget.
// See [GtkWidget’s geometry management section][geometry-management] for more
// information.
type Requisition struct {
	native C.GtkRequisition
}

// WrapRequisition wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapRequisition(ptr unsafe.Pointer) *Requisition {
	if ptr == nil {
		return nil
	}

	return (*Requisition)(ptr)
}

func marshalRequisition(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapRequisition(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (r *Requisition) Native() unsafe.Pointer {
	return unsafe.Pointer(&r.native)
}

// NewRequisition constructs a struct Requisition.
func NewRequisition() *Requisition {
	ret := C.gtk_requisition_new()

	var ret0 *Requisition

	{
		ret0 = WrapRequisition(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *Requisition) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Width gets the field inside the struct.
func (r *Requisition) Width() int {
	var ret int
	ret = int(r.native.width)
	return ret
}

// Height gets the field inside the struct.
func (r *Requisition) Height() int {
	var ret int
	ret = int(r.native.height)
	return ret
}

// Copy copies a Requisition.
func (r *Requisition) Copy() *Requisition {
	var arg0 *C.GtkRequisition

	arg0 = (*C.GtkRequisition)(r.Native())

	ret := C.gtk_requisition_copy(arg0)

	var ret0 *Requisition

	{
		ret0 = WrapRequisition(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *Requisition) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Free frees a Requisition.
func (r *Requisition) Free() {
	var arg0 *C.GtkRequisition

	arg0 = (*C.GtkRequisition)(r.Native())

	C.gtk_requisition_free(arg0)
}

type WidgetClassPrivate struct {
	native C.GtkWidgetClassPrivate
}

// WrapWidgetClassPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapWidgetClassPrivate(ptr unsafe.Pointer) *WidgetClassPrivate {
	if ptr == nil {
		return nil
	}

	return (*WidgetClassPrivate)(ptr)
}

func marshalWidgetClassPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapWidgetClassPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (w *WidgetClassPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&w.native)
}

type WidgetPrivate struct {
	native C.GtkWidgetPrivate
}

// WrapWidgetPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapWidgetPrivate(ptr unsafe.Pointer) *WidgetPrivate {
	if ptr == nil {
		return nil
	}

	return (*WidgetPrivate)(ptr)
}

func marshalWidgetPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapWidgetPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (w *WidgetPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&w.native)
}
