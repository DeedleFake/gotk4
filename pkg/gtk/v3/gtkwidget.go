// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/internal/box"
	"github.com/diamondburned/gotk4/internal/gextras"
	"github.com/diamondburned/gotk4/internal/ptr"
	"github.com/diamondburned/gotk4/pkg/cairo"
	"github.com/diamondburned/gotk4/pkg/gdk/v3"
	"github.com/diamondburned/gotk4/pkg/gdkpixbuf/v2"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
	"github.com/diamondburned/gotk4/pkg/pango"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config:
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_widget_get_type()), F: marshalWidget},
		{T: externglib.Type(C.gtk_requisition_get_type()), F: marshalRequisition},
	})
}

// Allocation: a Allocation-struct of a widget represents region which has been
// allocated to the widget by its parent. It is a subregion of its parents
// allocation. See [GtkWidget’s geometry management
// section][geometry-management] for more information.
type Allocation gdk.Rectangle

// Callback: the type of the callback functions used for e.g. iterating over the
// children of a container, see gtk_container_foreach().
type Callback func()

//export gotk4_Callback
func gotk4_Callback(arg0 *C.GtkWidget, arg1 C.gpointer) {
	v := box.Get(uintptr(arg1))
	if v == nil {
		panic(`callback not found`)
	}

	fn := v.(Callback)
	fn()
}

// TickCallback: callback type for adding a function to update animations. See
// gtk_widget_add_tick_callback().
type TickCallback func() (ok bool)

//export gotk4_TickCallback
func gotk4_TickCallback(arg0 *C.GtkWidget, arg1 *C.GdkFrameClock, arg2 C.gpointer) C.gboolean {
	v := box.Get(uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	fn := v.(TickCallback)
	fn(ok)

	if ok {
		cret = C.gboolean(1)
	}
}

// CairoShouldDrawWindow: this function is supposed to be called in Widget::draw
// implementations for widgets that support multiple windows. @cr must be
// untransformed from invoking of the draw function. This function will return
// true if the contents of the given @window are supposed to be drawn and false
// otherwise. Note that when the drawing was not initiated by the windowing
// system this function will return true for all windows, so you need to draw
// the bottommost window first. Also, do not use “else if” statements to check
// which window should be drawn.
func CairoShouldDrawWindow(cr *cairo.Context, window gdk.Window) bool {
	var arg1 *C.cairo_t
	var arg2 *C.GdkWindow

	arg1 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	arg2 = (*C.GdkWindow)(unsafe.Pointer(window.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.gtk_cairo_should_draw_window(arg1, arg2)

	if cret {
		goret = true
	}

	return goret
}

// CairoTransformToWindow transforms the given cairo context @cr that from
// @widget-relative coordinates to @window-relative coordinates. If the
// @widget’s window is not an ancestor of @window, no modification will be
// applied.
//
// This is the inverse to the transformation GTK applies when preparing an
// expose event to be emitted with the Widget::draw signal. It is intended to
// help porting multiwindow widgets from GTK+ 2 to the rendering architecture of
// GTK+ 3.
func CairoTransformToWindow(cr *cairo.Context, widget Widget, window gdk.Window) {
	var arg1 *C.cairo_t
	var arg2 *C.GtkWidget
	var arg3 *C.GdkWindow

	arg1 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	arg2 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	arg3 = (*C.GdkWindow)(unsafe.Pointer(window.Native()))

	C.gtk_cairo_transform_to_window(arg1, arg2, arg3)
}

// Widget: gtkWidget is the base class all widgets in GTK+ derive from. It
// manages the widget lifecycle, states and style.
//
//
// Height-for-width Geometry Management
//
// GTK+ uses a height-for-width (and width-for-height) geometry management
// system. Height-for-width means that a widget can change how much vertical
// space it needs, depending on the amount of horizontal space that it is given
// (and similar for width-for-height). The most common example is a label that
// reflows to fill up the available width, wraps to fewer lines, and therefore
// needs less height.
//
// Height-for-width geometry management is implemented in GTK+ by way of five
// virtual methods:
//
// - WidgetClass.get_request_mode() - WidgetClass.get_preferred_width() -
// WidgetClass.get_preferred_height() -
// WidgetClass.get_preferred_height_for_width() -
// WidgetClass.get_preferred_width_for_height() -
// WidgetClass.get_preferred_height_and_baseline_for_width()
//
// There are some important things to keep in mind when implementing
// height-for-width and when using it in container implementations.
//
// The geometry management system will query a widget hierarchy in only one
// orientation at a time. When widgets are initially queried for their minimum
// sizes it is generally done in two initial passes in the SizeRequestMode
// chosen by the toplevel.
//
// For example, when queried in the normal GTK_SIZE_REQUEST_HEIGHT_FOR_WIDTH
// mode: First, the default minimum and natural width for each widget in the
// interface will be computed using gtk_widget_get_preferred_width(). Because
// the preferred widths for each container depend on the preferred widths of
// their children, this information propagates up the hierarchy, and finally a
// minimum and natural width is determined for the entire toplevel. Next, the
// toplevel will use the minimum width to query for the minimum height
// contextual to that width using gtk_widget_get_preferred_height_for_width(),
// which will also be a highly recursive operation. The minimum height for the
// minimum width is normally used to set the minimum size constraint on the
// toplevel (unless gtk_window_set_geometry_hints() is explicitly used instead).
//
// After the toplevel window has initially requested its size in both dimensions
// it can go on to allocate itself a reasonable size (or a size previously
// specified with gtk_window_set_default_size()). During the recursive
// allocation process it’s important to note that request cycles will be
// recursively executed while container widgets allocate their children. Each
// container widget, once allocated a size, will go on to first share the space
// in one orientation among its children and then request each child's height
// for its target allocated width or its width for allocated height, depending.
// In this way a Widget will typically be requested its size a number of times
// before actually being allocated a size. The size a widget is finally
// allocated can of course differ from the size it has requested. For this
// reason, Widget caches a small number of results to avoid re-querying for the
// same sizes in one allocation cycle.
//
// See [GtkContainer’s geometry management
// section][container-geometry-management] to learn more about how
// height-for-width allocations are performed by container widgets.
//
// If a widget does move content around to intelligently use up the allocated
// size then it must support the request in both SizeRequestModes even if the
// widget in question only trades sizes in a single orientation.
//
// For instance, a Label that does height-for-width word wrapping will not
// expect to have WidgetClass.get_preferred_height() called because that call is
// specific to a width-for-height request. In this case the label must return
// the height required for its own minimum possible width. By following this
// rule any widget that handles height-for-width or width-for-height requests
// will always be allocated at least enough space to fit its own content.
//
// Here are some examples of how a GTK_SIZE_REQUEST_HEIGHT_FOR_WIDTH widget
// generally deals with width-for-height requests, for
// WidgetClass.get_preferred_height() it will do:
//
//    // the signal handler has the instance and user data swapped
//    // because of the swapped="yes" attribute in the template XML
//    static void
//    hello_button_clicked (FooWidget *self,
//                          GtkButton *button)
//    {
//      g_print ("Hello, world!\n");
//    }
//
//    static void
//    foo_widget_class_init (FooWidgetClass *klass)
//    {
//      // ...
//      gtk_widget_class_set_template_from_resource (GTK_WIDGET_CLASS (klass),
//                                                   "/com/example/ui/foowidget.ui");
//      gtk_widget_class_bind_template_callback (GTK_WIDGET_CLASS (klass), hello_button_clicked);
//    }
type Widget interface {
	gextras.Objector
	Buildable

	// Activate: for widgets that can be “activated” (buttons, menu items, etc.)
	// this function activates them. Activation is what happens when you press
	// Enter on a widget during key navigation. If @widget isn't activatable,
	// the function returns false.
	Activate() bool
	// AddAccelerator installs an accelerator for this @widget in @accel_group
	// that causes @accel_signal to be emitted if the accelerator is activated.
	// The @accel_group needs to be added to the widget’s toplevel via
	// gtk_window_add_accel_group(), and the signal must be of type
	// G_SIGNAL_ACTION. Accelerators added through this function are not user
	// changeable during runtime. If you want to support accelerators that can
	// be changed by the user, use gtk_accel_map_add_entry() and
	// gtk_widget_set_accel_path() or gtk_menu_item_set_accel_path() instead.
	AddAccelerator(accelSignal string, accelGroup AccelGroup, accelKey uint, accelMods gdk.ModifierType, accelFlags AccelFlags)
	// AddDeviceEvents adds the device events in the bitfield @events to the
	// event mask for @widget. See gtk_widget_set_device_events() for details.
	AddDeviceEvents(device gdk.Device, events gdk.EventMask)
	// AddEvents adds the events in the bitfield @events to the event mask for
	// @widget. See gtk_widget_set_events() and the [input handling
	// overview][event-masks] for details.
	AddEvents(events int)
	// AddMnemonicLabel adds a widget to the list of mnemonic labels for this
	// widget. (See gtk_widget_list_mnemonic_labels()). Note the list of
	// mnemonic labels for the widget is cleared when the widget is destroyed,
	// so the caller must make sure to update its internal state at this point
	// as well, by using a connection to the Widget::destroy signal or a weak
	// notifier.
	AddMnemonicLabel(label Widget)
	// AddTickCallback queues an animation frame update and adds a callback to
	// be called before each frame. Until the tick callback is removed, it will
	// be called frequently (usually at the frame rate of the output device or
	// as quickly as the application can be repainted, whichever is slower). For
	// this reason, is most suitable for handling graphics that change every
	// frame or every few frames. The tick callback does not automatically imply
	// a relayout or repaint. If you want a repaint or relayout, and aren’t
	// changing widget properties that would trigger that (for example, changing
	// the text of a Label), then you will have to call
	// gtk_widget_queue_resize() or gtk_widget_queue_draw_area() yourself.
	//
	// gdk_frame_clock_get_frame_time() should generally be used for timing
	// continuous animations and
	// gdk_frame_timings_get_predicted_presentation_time() if you are trying to
	// display isolated frames at particular times.
	//
	// This is a more convenient alternative to connecting directly to the
	// FrameClock::update signal of FrameClock, since you don't have to worry
	// about when a FrameClock is assigned to a widget.
	AddTickCallback() uint
	// CanActivateAccel determines whether an accelerator that activates the
	// signal identified by @signal_id can currently be activated. This is done
	// by emitting the Widget::can-activate-accel signal on @widget; if the
	// signal isn’t overridden by a handler or in a derived widget, then the
	// default check is that the widget must be sensitive, and the widget and
	// all its ancestors mapped.
	CanActivateAccel(signalID uint) bool
	// ChildFocus: this function is used by custom widget implementations; if
	// you're writing an app, you’d use gtk_widget_grab_focus() to move the
	// focus to a particular widget, and gtk_container_set_focus_chain() to
	// change the focus tab order. So you may want to investigate those
	// functions instead.
	//
	// gtk_widget_child_focus() is called by containers as the user moves around
	// the window using keyboard shortcuts. @direction indicates what kind of
	// motion is taking place (up, down, left, right, tab forward, tab
	// backward). gtk_widget_child_focus() emits the Widget::focus signal;
	// widgets override the default handler for this signal in order to
	// implement appropriate focus behavior.
	//
	// The default ::focus handler for a widget should return true if moving in
	// @direction left the focus on a focusable location inside that widget, and
	// false if moving in @direction moved the focus outside the widget. If
	// returning true, widgets normally call gtk_widget_grab_focus() to place
	// the focus accordingly; if returning false, they don’t modify the current
	// focus location.
	ChildFocus(direction DirectionType) bool
	// ChildNotify emits a Widget::child-notify signal for the [child
	// property][child-properties] @child_property on @widget.
	//
	// This is the analogue of g_object_notify() for child properties.
	//
	// Also see gtk_container_child_notify().
	ChildNotify(childProperty string)
	// ClassPath: same as gtk_widget_path(), but always uses the name of a
	// widget’s type, never uses a custom name set with gtk_widget_set_name().
	ClassPath() (pathLength uint, path string, pathReversed string)
	// ComputeExpand computes whether a container should give this widget extra
	// space when possible. Containers should check this, rather than looking at
	// gtk_widget_get_hexpand() or gtk_widget_get_vexpand().
	//
	// This function already checks whether the widget is visible, so visibility
	// does not need to be checked separately. Non-visible widgets are not
	// expanded.
	//
	// The computed expand value uses either the expand setting explicitly set
	// on the widget itself, or, if none has been explicitly set, the widget may
	// expand if some of its children do.
	ComputeExpand(orientation Orientation) bool
	// CreatePangoContext creates a new Context with the appropriate font map,
	// font options, font description, and base direction for drawing text for
	// this widget. See also gtk_widget_get_pango_context().
	CreatePangoContext() pango.Context
	// CreatePangoLayout creates a new Layout with the appropriate font map,
	// font description, and base direction for drawing text for this widget.
	//
	// If you keep a Layout created in this way around, you need to re-create it
	// when the widget Context is replaced. This can be tracked by using the
	// Widget::screen-changed signal on the widget.
	CreatePangoLayout(text string) pango.Layout
	// Destroy destroys a widget.
	//
	// When a widget is destroyed all references it holds on other objects will
	// be released:
	//
	//    - if the widget is inside a container, it will be removed from its
	//    parent
	//    - if the widget is a container, all its children will be destroyed,
	//    recursively
	//    - if the widget is a top level, it will be removed from the list
	//    of top level widgets that GTK+ maintains internally
	//
	// It's expected that all references held on the widget will also be
	// released; you should connect to the Widget::destroy signal if you hold a
	// reference to @widget and you wish to remove it when this function is
	// called. It is not necessary to do so if you are implementing a Container,
	// as you'll be able to use the ContainerClass.remove() virtual function for
	// that.
	//
	// It's important to notice that gtk_widget_destroy() will only cause the
	// @widget to be finalized if no additional references, acquired using
	// g_object_ref(), are held on it. In case additional references are in
	// place, the @widget will be in an "inert" state after calling this
	// function; @widget will still point to valid memory, allowing you to
	// release the references you hold, but you may not query the widget's own
	// state.
	//
	// You should typically call this function on top level widgets, and rarely
	// on child widgets.
	//
	// See also: gtk_container_remove()
	Destroy()
	// Destroyed: this function sets *@widget_pointer to nil if @widget_pointer
	// != nil. It’s intended to be used as a callback connected to the “destroy”
	// signal of a widget. You connect gtk_widget_destroyed() as a signal
	// handler, and pass the address of your widget variable as user data. Then
	// when the widget is destroyed, the variable will be set to nil. Useful for
	// example to avoid multiple copies of the same dialog.
	Destroyed(widgetPointer Widget)
	// DeviceIsShadowed returns true if @device has been shadowed by a GTK+
	// device grab on another widget, so it would stop sending events to
	// @widget. This may be used in the Widget::grab-notify signal to check for
	// specific devices. See gtk_device_grab_add().
	DeviceIsShadowed(device gdk.Device) bool
	// DragBegin: this function is equivalent to
	// gtk_drag_begin_with_coordinates(), passing -1, -1 as coordinates.
	DragBegin(targets *TargetList, actions gdk.DragAction, button int, event *gdk.Event) gdk.DragContext
	// DragBeginWithCoordinates initiates a drag on the source side. The
	// function only needs to be used when the application is starting drags
	// itself, and is not needed when gtk_drag_source_set() is used.
	//
	// The @event is used to retrieve the timestamp that will be used internally
	// to grab the pointer. If @event is nil, then GDK_CURRENT_TIME will be
	// used. However, you should try to pass a real event in all cases, since
	// that can be used to get information about the drag.
	//
	// Generally there are three cases when you want to start a drag by hand by
	// calling this function:
	//
	// 1. During a Widget::button-press-event handler, if you want to start a
	// drag immediately when the user presses the mouse button. Pass the @event
	// that you have in your Widget::button-press-event handler.
	//
	// 2. During a Widget::motion-notify-event handler, if you want to start a
	// drag when the mouse moves past a certain threshold distance after a
	// button-press. Pass the @event that you have in your
	// Widget::motion-notify-event handler.
	//
	// 3. During a timeout handler, if you want to start a drag after the mouse
	// button is held down for some time. Try to save the last event that you
	// got from the mouse, using gdk_event_copy(), and pass it to this function
	// (remember to free the event with gdk_event_free() when you are done). If
	// you really cannot pass a real event, pass nil instead.
	DragBeginWithCoordinates(targets *TargetList, actions gdk.DragAction, button int, event *gdk.Event, x int, y int) gdk.DragContext
	// DragCheckThreshold checks to see if a mouse drag starting at (@start_x,
	// @start_y) and ending at (@current_x, @current_y) has passed the GTK+ drag
	// threshold, and thus should trigger the beginning of a drag-and-drop
	// operation.
	DragCheckThreshold(startX int, startY int, currentX int, currentY int) bool
	// DragDestAddImageTargets: add the image targets supported by SelectionData
	// to the target list of the drag destination. The targets are added with
	// @info = 0. If you need another value, use
	// gtk_target_list_add_image_targets() and gtk_drag_dest_set_target_list().
	DragDestAddImageTargets()
	// DragDestAddTextTargets: add the text targets supported by SelectionData
	// to the target list of the drag destination. The targets are added with
	// @info = 0. If you need another value, use
	// gtk_target_list_add_text_targets() and gtk_drag_dest_set_target_list().
	DragDestAddTextTargets()
	// DragDestAddURITargets: add the URI targets supported by SelectionData to
	// the target list of the drag destination. The targets are added with @info
	// = 0. If you need another value, use gtk_target_list_add_uri_targets() and
	// gtk_drag_dest_set_target_list().
	DragDestAddURITargets()
	// DragDestFindTarget looks for a match between the supported targets of
	// @context and the @dest_target_list, returning the first matching target,
	// otherwise returning GDK_NONE. @dest_target_list should usually be the
	// return value from gtk_drag_dest_get_target_list(), but some widgets may
	// have different valid targets for different parts of the widget; in that
	// case, they will have to implement a drag_motion handler that passes the
	// correct target list to this function.
	DragDestFindTarget(context gdk.DragContext, targetList *TargetList) gdk.Atom
	// DragDestGetTargetList returns the list of targets this widget can accept
	// from drag-and-drop.
	DragDestGetTargetList() *TargetList
	// DragDestGetTrackMotion returns whether the widget has been configured to
	// always emit Widget::drag-motion signals.
	DragDestGetTrackMotion() bool
	// DragDestSetProxy sets this widget as a proxy for drops to another window.
	DragDestSetProxy(proxyWindow gdk.Window, protocol gdk.DragProtocol, useCoordinates bool)
	// DragDestSetTargetList sets the target types that this widget can accept
	// from drag-and-drop. The widget must first be made into a drag destination
	// with gtk_drag_dest_set().
	DragDestSetTargetList(targetList *TargetList)
	// DragDestSetTrackMotion tells the widget to emit Widget::drag-motion and
	// Widget::drag-leave events regardless of the targets and the
	// GTK_DEST_DEFAULT_MOTION flag.
	//
	// This may be used when a widget wants to do generic actions regardless of
	// the targets that the source offers.
	DragDestSetTrackMotion(trackMotion bool)
	// DragDestUnset clears information about a drop destination set with
	// gtk_drag_dest_set(). The widget will no longer receive notification of
	// drags.
	DragDestUnset()
	// DragGetData gets the data associated with a drag. When the data is
	// received or the retrieval fails, GTK+ will emit a
	// Widget::drag-data-received signal. Failure of the retrieval is indicated
	// by the length field of the @selection_data signal parameter being
	// negative. However, when gtk_drag_get_data() is called implicitely because
	// the GTK_DEST_DEFAULT_DROP was set, then the widget will not receive
	// notification of failed drops.
	DragGetData(context gdk.DragContext, target gdk.Atom, time_ uint32)
	// DragHighlight highlights a widget as a currently hovered drop target. To
	// end the highlight, call gtk_drag_unhighlight(). GTK+ calls this
	// automatically if GTK_DEST_DEFAULT_HIGHLIGHT is set.
	DragHighlight()
	// DragSourceAddImageTargets: add the writable image targets supported by
	// SelectionData to the target list of the drag source. The targets are
	// added with @info = 0. If you need another value, use
	// gtk_target_list_add_image_targets() and
	// gtk_drag_source_set_target_list().
	DragSourceAddImageTargets()
	// DragSourceAddTextTargets: add the text targets supported by SelectionData
	// to the target list of the drag source. The targets are added with @info =
	// 0. If you need another value, use gtk_target_list_add_text_targets() and
	// gtk_drag_source_set_target_list().
	DragSourceAddTextTargets()
	// DragSourceAddURITargets: add the URI targets supported by SelectionData
	// to the target list of the drag source. The targets are added with @info =
	// 0. If you need another value, use gtk_target_list_add_uri_targets() and
	// gtk_drag_source_set_target_list().
	DragSourceAddURITargets()
	// DragSourceGetTargetList gets the list of targets this widget can provide
	// for drag-and-drop.
	DragSourceGetTargetList() *TargetList
	// DragSourceSetIconGIcon sets the icon that will be used for drags from a
	// particular source to @icon. See the docs for IconTheme for more details.
	DragSourceSetIconGIcon(icon gio.Icon)
	// DragSourceSetIconName sets the icon that will be used for drags from a
	// particular source to a themed icon. See the docs for IconTheme for more
	// details.
	DragSourceSetIconName(iconName string)
	// DragSourceSetIconPixbuf sets the icon that will be used for drags from a
	// particular widget from a Pixbuf. GTK+ retains a reference for @pixbuf and
	// will release it when it is no longer needed.
	DragSourceSetIconPixbuf(pixbuf gdkpixbuf.Pixbuf)
	// DragSourceSetIconStock sets the icon that will be used for drags from a
	// particular source to a stock icon.
	DragSourceSetIconStock(stockID string)
	// DragSourceSetTargetList changes the target types that this widget offers
	// for drag-and-drop. The widget must first be made into a drag source with
	// gtk_drag_source_set().
	DragSourceSetTargetList(targetList *TargetList)
	// DragSourceUnset undoes the effects of gtk_drag_source_set().
	DragSourceUnset()
	// DragUnhighlight removes a highlight set by gtk_drag_highlight() from a
	// widget.
	DragUnhighlight()
	// Draw draws @widget to @cr. The top left corner of the widget will be
	// drawn to the currently set origin point of @cr.
	//
	// You should pass a cairo context as @cr argument that is in an original
	// state. Otherwise the resulting drawing is undefined. For example changing
	// the operator using cairo_set_operator() or the line width using
	// cairo_set_line_width() might have unwanted side effects. You may however
	// change the context’s transform matrix - like with cairo_scale(),
	// cairo_translate() or cairo_set_matrix() and clip region with cairo_clip()
	// prior to calling this function. Also, it is fine to modify the context
	// with cairo_save() and cairo_push_group() prior to calling this function.
	//
	// Note that special-purpose widgets may contain special code for rendering
	// to the screen and might appear differently on screen and when rendered
	// using gtk_widget_draw().
	Draw(cr *cairo.Context)
	// EnsureStyle ensures that @widget has a style (@widget->style).
	//
	// Not a very useful function; most of the time, if you want the style, the
	// widget is realized, and realized widgets are guaranteed to have a style
	// already.
	EnsureStyle()
	// ErrorBell notifies the user about an input-related error on this widget.
	// If the Settings:gtk-error-bell setting is true, it calls
	// gdk_window_beep(), otherwise it does nothing.
	//
	// Note that the effect of gdk_window_beep() can be configured in many ways,
	// depending on the windowing backend and the desktop environment or window
	// manager that is used.
	ErrorBell()
	// FreezeChildNotify stops emission of Widget::child-notify signals on
	// @widget. The signals are queued until gtk_widget_thaw_child_notify() is
	// called on @widget.
	//
	// This is the analogue of g_object_freeze_notify() for child properties.
	FreezeChildNotify()
	// ActionGroup retrieves the Group that was registered using @prefix. The
	// resulting Group may have been registered to @widget or any Widget in its
	// ancestry.
	//
	// If no action group was found matching @prefix, then nil is returned.
	ActionGroup(prefix string) gio.ActionGroup
	// AllocatedBaseline returns the baseline that has currently been allocated
	// to @widget. This function is intended to be used when implementing
	// handlers for the Widget::draw function, and when allocating child widgets
	// in Widget::size_allocate.
	AllocatedBaseline() int
	// AllocatedHeight returns the height that has currently been allocated to
	// @widget. This function is intended to be used when implementing handlers
	// for the Widget::draw function.
	AllocatedHeight() int
	// AllocatedWidth returns the width that has currently been allocated to
	// @widget. This function is intended to be used when implementing handlers
	// for the Widget::draw function.
	AllocatedWidth() int
	// Ancestor gets the first ancestor of @widget with type @widget_type. For
	// example, `gtk_widget_get_ancestor (widget, GTK_TYPE_BOX)` gets the first
	// Box that’s an ancestor of @widget. No reference will be added to the
	// returned widget; it should not be unreferenced. See note about checking
	// for a toplevel Window in the docs for gtk_widget_get_toplevel().
	//
	// Note that unlike gtk_widget_is_ancestor(), gtk_widget_get_ancestor()
	// considers @widget to be an ancestor of itself.
	Ancestor(widgetType externglib.Type) Widget
	// AppPaintable determines whether the application intends to draw on the
	// widget in an Widget::draw handler.
	//
	// See gtk_widget_set_app_paintable()
	AppPaintable() bool
	// CanDefault determines whether @widget can be a default widget. See
	// gtk_widget_set_can_default().
	CanDefault() bool
	// CanFocus determines whether @widget can own the input focus. See
	// gtk_widget_set_can_focus().
	CanFocus() bool
	// ChildRequisition: this function is only for use in widget
	// implementations. Obtains @widget->requisition, unless someone has forced
	// a particular geometry on the widget (e.g. with
	// gtk_widget_set_size_request()), in which case it returns that geometry
	// instead of the widget's requisition.
	//
	// This function differs from gtk_widget_size_request() in that it retrieves
	// the last size request value from @widget->requisition, while
	// gtk_widget_size_request() actually calls the "size_request" method on
	// @widget to compute the size request and fill in @widget->requisition, and
	// only then returns @widget->requisition.
	//
	// Because this function does not call the “size_request” method, it can
	// only be used when you know that @widget->requisition is up-to-date, that
	// is, gtk_widget_size_request() has been called since the last time a
	// resize was queued. In general, only container implementations have this
	// information; applications should use gtk_widget_size_request().
	ChildRequisition() *Requisition
	// ChildVisible gets the value set with gtk_widget_set_child_visible(). If
	// you feel a need to use this function, your code probably needs
	// reorganization.
	//
	// This function is only useful for container implementations and never
	// should be called by an application.
	ChildVisible() bool
	// Clipboard returns the clipboard object for the given selection to be used
	// with @widget. @widget must have a Display associated with it, so must be
	// attached to a toplevel window.
	Clipboard(selection gdk.Atom) Clipboard
	// CompositeName obtains the composite name of a widget.
	CompositeName() string
	// DeviceEnabled returns whether @device can interact with @widget and its
	// children. See gtk_widget_set_device_enabled().
	DeviceEnabled(device gdk.Device) bool
	// DeviceEvents returns the events mask for the widget corresponding to an
	// specific device. These are the events that the widget will receive when
	// @device operates on it.
	DeviceEvents(device gdk.Device) gdk.EventMask
	// Direction gets the reading direction for a particular widget. See
	// gtk_widget_set_direction().
	Direction() TextDirection
	// Display: get the Display for the toplevel window associated with this
	// widget. This function can only be called after the widget has been added
	// to a widget hierarchy with a Window at the top.
	//
	// In general, you should only create display specific resources when a
	// widget has been realized, and you should free those resources when the
	// widget is unrealized.
	Display() gdk.Display
	// DoubleBuffered determines whether the widget is double buffered.
	//
	// See gtk_widget_set_double_buffered()
	DoubleBuffered() bool
	// Events returns the event mask (see EventMask) for the widget. These are
	// the events that the widget will receive.
	//
	// Note: Internally, the widget event mask will be the logical OR of the
	// event mask set through gtk_widget_set_events() or
	// gtk_widget_add_events(), and the event mask necessary to cater for every
	// EventController created for the widget.
	Events() int
	// FocusOnClick returns whether the widget should grab focus when it is
	// clicked with the mouse. See gtk_widget_set_focus_on_click().
	FocusOnClick() bool
	// FontMap gets the font map that has been set with
	// gtk_widget_set_font_map().
	FontMap() pango.FontMap
	// FontOptions returns the #cairo_font_options_t used for Pango rendering.
	// When not set, the defaults font options for the Screen will be used.
	FontOptions() *cairo.FontOptions
	// FrameClock obtains the frame clock for a widget. The frame clock is a
	// global “ticker” that can be used to drive animations and repaints. The
	// most common reason to get the frame clock is to call
	// gdk_frame_clock_get_frame_time(), in order to get a time to use for
	// animating. For example you might record the start of the animation with
	// an initial value from gdk_frame_clock_get_frame_time(), and then update
	// the animation by calling gdk_frame_clock_get_frame_time() again during
	// each repaint.
	//
	// gdk_frame_clock_request_phase() will result in a new frame on the clock,
	// but won’t necessarily repaint any widgets. To repaint a widget, you have
	// to use gtk_widget_queue_draw() which invalidates the widget (thus
	// scheduling it to receive a draw on the next frame).
	// gtk_widget_queue_draw() will also end up requesting a frame on the
	// appropriate frame clock.
	//
	// A widget’s frame clock will not change while the widget is mapped.
	// Reparenting a widget (which implies a temporary unmap) can change the
	// widget’s frame clock.
	//
	// Unrealized widgets do not have a frame clock.
	FrameClock() gdk.FrameClock
	// Halign gets the value of the Widget:halign property.
	//
	// For backwards compatibility reasons this method will never return
	// GTK_ALIGN_BASELINE, but instead it will convert it to GTK_ALIGN_FILL.
	// Baselines are not supported for horizontal alignment.
	Halign() Align
	// HasTooltip returns the current value of the has-tooltip property. See
	// Widget:has-tooltip for more information.
	HasTooltip() bool
	// HasWindow determines whether @widget has a Window of its own. See
	// gtk_widget_set_has_window().
	HasWindow() bool
	// Hexpand gets whether the widget would like any available extra horizontal
	// space. When a user resizes a Window, widgets with expand=TRUE generally
	// receive the extra space. For example, a list or scrollable area or
	// document in your window would often be set to expand.
	//
	// Containers should use gtk_widget_compute_expand() rather than this
	// function, to see whether a widget, or any of its children, has the expand
	// flag set. If any child of a widget wants to expand, the parent may ask to
	// expand also.
	//
	// This function only looks at the widget’s own hexpand flag, rather than
	// computing whether the entire widget tree rooted at this widget wants to
	// expand.
	Hexpand() bool
	// HexpandSet gets whether gtk_widget_set_hexpand() has been used to
	// explicitly set the expand flag on this widget.
	//
	// If hexpand is set, then it overrides any computed expand value based on
	// child widgets. If hexpand is not set, then the expand value depends on
	// whether any children of the widget would like to expand.
	//
	// There are few reasons to use this function, but it’s here for
	// completeness and consistency.
	HexpandSet() bool
	// Mapped: whether the widget is mapped.
	Mapped() bool
	// MarginBottom gets the value of the Widget:margin-bottom property.
	MarginBottom() int
	// MarginEnd gets the value of the Widget:margin-end property.
	MarginEnd() int
	// MarginLeft gets the value of the Widget:margin-left property.
	MarginLeft() int
	// MarginRight gets the value of the Widget:margin-right property.
	MarginRight() int
	// MarginStart gets the value of the Widget:margin-start property.
	MarginStart() int
	// MarginTop gets the value of the Widget:margin-top property.
	MarginTop() int
	// ModifierMask returns the modifier mask the @widget’s windowing system
	// backend uses for a particular purpose.
	//
	// See gdk_keymap_get_modifier_mask().
	ModifierMask(intent gdk.ModifierIntent) gdk.ModifierType
	// ModifierStyle returns the current modifier style for the widget. (As set
	// by gtk_widget_modify_style().) If no style has previously set, a new
	// RcStyle will be created with all values unset, and set as the modifier
	// style for the widget. If you make changes to this rc style, you must call
	// gtk_widget_modify_style(), passing in the returned rc style, to make sure
	// that your changes take effect.
	//
	// Caution: passing the style back to gtk_widget_modify_style() will
	// normally end up destroying it, because gtk_widget_modify_style() copies
	// the passed-in style and sets the copy as the new modifier style, thus
	// dropping any reference to the old modifier style. Add a reference to the
	// modifier style if you want to keep it alive.
	ModifierStyle() RCStyle
	// Name retrieves the name of a widget. See gtk_widget_set_name() for the
	// significance of widget names.
	Name() string
	// NoShowAll returns the current value of the Widget:no-show-all property,
	// which determines whether calls to gtk_widget_show_all() will affect this
	// widget.
	NoShowAll() bool
	// Opacity fetches the requested opacity for this widget. See
	// gtk_widget_set_opacity().
	Opacity() float64
	// PangoContext gets a Context with the appropriate font map, font
	// description, and base direction for this widget. Unlike the context
	// returned by gtk_widget_create_pango_context(), this context is owned by
	// the widget (it can be used until the screen for the widget changes or the
	// widget is removed from its toplevel), and will be updated to match any
	// changes to the widget’s attributes. This can be tracked by using the
	// Widget::screen-changed signal on the widget.
	PangoContext() pango.Context
	// Parent returns the parent container of @widget.
	Parent() Widget
	// ParentWindow gets @widget’s parent window, or nil if it does not have
	// one.
	ParentWindow() gdk.Window
	// GetPath returns the WidgetPath representing @widget, if the widget is not
	// connected to a toplevel widget, a partial path will be created.
	GetPath() *WidgetPath
	// Pointer obtains the location of the mouse pointer in widget coordinates.
	// Widget coordinates are a bit odd; for historical reasons, they are
	// defined as @widget->window coordinates for widgets that return true for
	// gtk_widget_get_has_window(); and are relative to @widget->allocation.x,
	// @widget->allocation.y otherwise.
	Pointer() (x int, y int)
	// PreferredHeight retrieves a widget’s initial minimum and natural height.
	//
	// This call is specific to width-for-height requests.
	//
	// The returned request will be modified by the
	// GtkWidgetClass::adjust_size_request virtual method and by any SizeGroups
	// that have been applied. That is, the returned request is the one that
	// should be used for layout, not necessarily the one returned by the widget
	// itself.
	PreferredHeight() (minimumHeight int, naturalHeight int)
	// PreferredHeightAndBaselineForWidth retrieves a widget’s minimum and
	// natural height and the corresponding baselines if it would be given the
	// specified @width, or the default height if @width is -1. The baselines
	// may be -1 which means that no baseline is requested for this widget.
	//
	// The returned request will be modified by the
	// GtkWidgetClass::adjust_size_request and
	// GtkWidgetClass::adjust_baseline_request virtual methods and by any
	// SizeGroups that have been applied. That is, the returned request is the
	// one that should be used for layout, not necessarily the one returned by
	// the widget itself.
	PreferredHeightAndBaselineForWidth(width int) (minimumHeight int, naturalHeight int, minimumBaseline int, naturalBaseline int)
	// PreferredHeightForWidth retrieves a widget’s minimum and natural height
	// if it would be given the specified @width.
	//
	// The returned request will be modified by the
	// GtkWidgetClass::adjust_size_request virtual method and by any SizeGroups
	// that have been applied. That is, the returned request is the one that
	// should be used for layout, not necessarily the one returned by the widget
	// itself.
	PreferredHeightForWidth(width int) (minimumHeight int, naturalHeight int)
	// PreferredSize retrieves the minimum and natural size of a widget, taking
	// into account the widget’s preference for height-for-width management.
	//
	// This is used to retrieve a suitable size by container widgets which do
	// not impose any restrictions on the child placement. It can be used to
	// deduce toplevel window and menu sizes as well as child widgets in
	// free-form containers such as GtkLayout.
	//
	// Handle with care. Note that the natural height of a height-for-width
	// widget will generally be a smaller size than the minimum height, since
	// the required height for the natural width is generally smaller than the
	// required height for the minimum width.
	//
	// Use gtk_widget_get_preferred_height_and_baseline_for_width() if you want
	// to support baseline alignment.
	PreferredSize() (minimumSize *Requisition, naturalSize *Requisition)
	// PreferredWidth retrieves a widget’s initial minimum and natural width.
	//
	// This call is specific to height-for-width requests.
	//
	// The returned request will be modified by the
	// GtkWidgetClass::adjust_size_request virtual method and by any SizeGroups
	// that have been applied. That is, the returned request is the one that
	// should be used for layout, not necessarily the one returned by the widget
	// itself.
	PreferredWidth() (minimumWidth int, naturalWidth int)
	// PreferredWidthForHeight retrieves a widget’s minimum and natural width if
	// it would be given the specified @height.
	//
	// The returned request will be modified by the
	// GtkWidgetClass::adjust_size_request virtual method and by any SizeGroups
	// that have been applied. That is, the returned request is the one that
	// should be used for layout, not necessarily the one returned by the widget
	// itself.
	PreferredWidthForHeight(height int) (minimumWidth int, naturalWidth int)
	// Realized determines whether @widget is realized.
	Realized() bool
	// ReceivesDefault determines whether @widget is always treated as the
	// default widget within its toplevel when it has the focus, even if another
	// widget is the default.
	//
	// See gtk_widget_set_receives_default().
	ReceivesDefault() bool
	// RequestMode gets whether the widget prefers a height-for-width layout or
	// a width-for-height layout.
	//
	// Bin widgets generally propagate the preference of their child, container
	// widgets need to request something either in context of their children or
	// in context of their allocation capabilities.
	RequestMode() SizeRequestMode
	// Requisition retrieves the widget’s requisition.
	//
	// This function should only be used by widget implementations in order to
	// figure whether the widget’s requisition has actually changed after some
	// internal state change (so that they can call gtk_widget_queue_resize()
	// instead of gtk_widget_queue_draw()).
	//
	// Normally, gtk_widget_size_request() should be used.
	Requisition() *Requisition
	// RootWindow: get the root window where this widget is located. This
	// function can only be called after the widget has been added to a widget
	// hierarchy with Window at the top.
	//
	// The root window is useful for such purposes as creating a popup Window
	// associated with the window. In general, you should only create display
	// specific resources when a widget has been realized, and you should free
	// those resources when the widget is unrealized.
	RootWindow() gdk.Window
	// ScaleFactor retrieves the internal scale factor that maps from window
	// coordinates to the actual device pixels. On traditional systems this is
	// 1, on high density outputs, it can be a higher value (typically 2).
	//
	// See gdk_window_get_scale_factor().
	ScaleFactor() int
	// Screen: get the Screen from the toplevel window associated with this
	// widget. This function can only be called after the widget has been added
	// to a widget hierarchy with a Window at the top.
	//
	// In general, you should only create screen specific resources when a
	// widget has been realized, and you should free those resources when the
	// widget is unrealized.
	Screen() gdk.Screen
	// Sensitive returns the widget’s sensitivity (in the sense of returning the
	// value that has been set using gtk_widget_set_sensitive()).
	//
	// The effective sensitivity of a widget is however determined by both its
	// own and its parent widget’s sensitivity. See gtk_widget_is_sensitive().
	Sensitive() bool
	// Settings gets the settings object holding the settings used for this
	// widget.
	//
	// Note that this function can only be called when the Widget is attached to
	// a toplevel, since the settings object is specific to a particular Screen.
	Settings() Settings
	// GetSizeRequest gets the size request that was explicitly set for the
	// widget using gtk_widget_set_size_request(). A value of -1 stored in
	// @width or @height indicates that that dimension has not been set
	// explicitly and the natural requisition of the widget will be used
	// instead. See gtk_widget_set_size_request(). To get the size a widget will
	// actually request, call gtk_widget_get_preferred_size() instead of this
	// function.
	GetSizeRequest() (width int, height int)
	// State returns the widget’s state. See gtk_widget_set_state().
	State() StateType
	// StateFlags returns the widget state as a flag set. It is worth mentioning
	// that the effective GTK_STATE_FLAG_INSENSITIVE state will be returned,
	// that is, also based on parent insensitivity, even if @widget itself is
	// sensitive.
	//
	// Also note that if you are looking for a way to obtain the StateFlags to
	// pass to a StyleContext method, you should look at
	// gtk_style_context_get_state().
	StateFlags() StateFlags
	// Style: simply an accessor function that returns @widget->style.
	Style() Style
	// StyleContext returns the style context associated to @widget. The
	// returned object is guaranteed to be the same for the lifetime of @widget.
	StyleContext() StyleContext
	// SupportMultidevice returns true if @widget is multiple pointer aware. See
	// gtk_widget_set_support_multidevice() for more information.
	SupportMultidevice() bool
	// TemplateChild: fetch an object build from the template XML for
	// @widget_type in this @widget instance.
	//
	// This will only report children which were previously declared with
	// gtk_widget_class_bind_template_child_full() or one of its variants.
	//
	// This function is only meant to be called for code which is private to the
	// @widget_type which declared the child and is meant for language bindings
	// which cannot easily make use of the GObject structure offsets.
	TemplateChild(widgetType externglib.Type, name string) gextras.Objector
	// TooltipMarkup gets the contents of the tooltip for @widget.
	TooltipMarkup() string
	// TooltipText gets the contents of the tooltip for @widget.
	TooltipText() string
	// TooltipWindow returns the Window of the current tooltip. This can be the
	// GtkWindow created by default, or the custom tooltip window set using
	// gtk_widget_set_tooltip_window().
	TooltipWindow() Window
	// Toplevel: this function returns the topmost widget in the container
	// hierarchy @widget is a part of. If @widget has no parent widgets, it will
	// be returned as the topmost widget. No reference will be added to the
	// returned widget; it should not be unreferenced.
	//
	// Note the difference in behavior vs. gtk_widget_get_ancestor();
	// `gtk_widget_get_ancestor (widget, GTK_TYPE_WINDOW)` would return nil if
	// @widget wasn’t inside a toplevel window, and if the window was inside a
	// Window-derived widget which was in turn inside the toplevel Window. While
	// the second case may seem unlikely, it actually happens when a Plug is
	// embedded inside a Socket within the same application.
	//
	// To reliably find the toplevel Window, use gtk_widget_get_toplevel() and
	// call GTK_IS_WINDOW() on the result. For instance, to get the title of a
	// widget's toplevel window, one might use:
	//
	//    static const char *
	//    get_widget_toplevel_title (GtkWidget *widget)
	//    {
	//      GtkWidget *toplevel = gtk_widget_get_toplevel (widget);
	//      if (GTK_IS_WINDOW (toplevel))
	//        {
	//          return gtk_window_get_title (GTK_WINDOW (toplevel));
	//        }
	//
	//      return NULL;
	//    }
	Toplevel() Widget
	// Valign gets the value of the Widget:valign property.
	//
	// For backwards compatibility reasons this method will never return
	// GTK_ALIGN_BASELINE, but instead it will convert it to GTK_ALIGN_FILL. If
	// your widget want to support baseline aligned children it must use
	// gtk_widget_get_valign_with_baseline(), or `g_object_get (widget,
	// "valign", &value, NULL)`, which will also report the true value.
	Valign() Align
	// ValignWithBaseline gets the value of the Widget:valign property,
	// including GTK_ALIGN_BASELINE.
	ValignWithBaseline() Align
	// Vexpand gets whether the widget would like any available extra vertical
	// space.
	//
	// See gtk_widget_get_hexpand() for more detail.
	Vexpand() bool
	// VexpandSet gets whether gtk_widget_set_vexpand() has been used to
	// explicitly set the expand flag on this widget.
	//
	// See gtk_widget_get_hexpand_set() for more detail.
	VexpandSet() bool
	// Visible determines whether the widget is visible. If you want to take
	// into account whether the widget’s parent is also marked as visible, use
	// gtk_widget_is_visible() instead.
	//
	// This function does not check if the widget is obscured in any way.
	//
	// See gtk_widget_set_visible().
	Visible() bool
	// Visual gets the visual that will be used to render @widget.
	Visual() gdk.Visual
	// Window returns the widget’s window if it is realized, nil otherwise
	Window() gdk.Window
	// GrabAdd makes @widget the current grabbed widget.
	//
	// This means that interaction with other widgets in the same application is
	// blocked and mouse as well as keyboard events are delivered to this
	// widget.
	//
	// If @widget is not sensitive, it is not set as the current grabbed widget
	// and this function does nothing.
	GrabAdd()
	// GrabDefault causes @widget to become the default widget. @widget must be
	// able to be a default widget; typically you would ensure this yourself by
	// calling gtk_widget_set_can_default() with a true value. The default
	// widget is activated when the user presses Enter in a window. Default
	// widgets must be activatable, that is, gtk_widget_activate() should affect
	// them. Note that Entry widgets require the “activates-default” property
	// set to true before they activate the default widget when Enter is pressed
	// and the Entry is focused.
	GrabDefault()
	// GrabFocus causes @widget to have the keyboard focus for the Window it's
	// inside. @widget must be a focusable widget, such as a Entry; something
	// like Frame won’t work.
	//
	// More precisely, it must have the GTK_CAN_FOCUS flag set. Use
	// gtk_widget_set_can_focus() to modify that flag.
	//
	// The widget also needs to be realized and mapped. This is indicated by the
	// related signals. Grabbing the focus immediately after creating the widget
	// will likely fail and cause critical warnings.
	GrabFocus()
	// GrabRemove removes the grab from the given widget.
	//
	// You have to pair calls to gtk_grab_add() and gtk_grab_remove().
	//
	// If @widget does not have the grab, this function does nothing.
	GrabRemove()
	// HasDefault determines whether @widget is the current default widget
	// within its toplevel. See gtk_widget_set_can_default().
	HasDefault() bool
	// HasFocus determines if the widget has the global input focus. See
	// gtk_widget_is_focus() for the difference between having the global input
	// focus, and only having the focus within a toplevel.
	HasFocus() bool
	// HasGrab determines whether the widget is currently grabbing events, so it
	// is the only widget receiving input events (keyboard and mouse).
	//
	// See also gtk_grab_add().
	HasGrab() bool
	// HasRCStyle determines if the widget style has been looked up through the
	// rc mechanism.
	HasRCStyle() bool
	// HasScreen checks whether there is a Screen is associated with this
	// widget. All toplevel widgets have an associated screen, and all widgets
	// added into a hierarchy with a toplevel window at the top.
	HasScreen() bool
	// HasVisibleFocus determines if the widget should show a visible indication
	// that it has the global input focus. This is a convenience function for
	// use in ::draw handlers that takes into account whether focus indication
	// should currently be shown in the toplevel window of @widget. See
	// gtk_window_get_focus_visible() for more information about focus
	// indication.
	//
	// To find out if the widget has the global input focus, use
	// gtk_widget_has_focus().
	HasVisibleFocus() bool
	// Hide reverses the effects of gtk_widget_show(), causing the widget to be
	// hidden (invisible to the user).
	Hide()
	// HideOnDelete: utility function; intended to be connected to the
	// Widget::delete-event signal on a Window. The function calls
	// gtk_widget_hide() on its argument, then returns true. If connected to
	// ::delete-event, the result is that clicking the close button for a window
	// (on the window frame, top right corner usually) will hide but not destroy
	// the window. By default, GTK+ destroys windows when ::delete-event is
	// received.
	HideOnDelete() bool
	// InDestruction returns whether the widget is currently being destroyed.
	// This information can sometimes be used to avoid doing unnecessary work.
	InDestruction() bool
	// InitTemplate creates and initializes child widgets defined in templates.
	// This function must be called in the instance initializer for any class
	// which assigned itself a template using gtk_widget_class_set_template()
	//
	// It is important to call this function in the instance initializer of a
	// Widget subclass and not in #GObject.constructed() or
	// #GObject.constructor() for two reasons.
	//
	// One reason is that generally derived widgets will assume that parent
	// class composite widgets have been created in their instance initializers.
	//
	// Another reason is that when calling g_object_new() on a widget with
	// composite templates, it’s important to build the composite widgets before
	// the construct properties are set. Properties passed to g_object_new()
	// should take precedence over properties set in the private template XML.
	InitTemplate()
	// InputShapeCombineRegion sets an input shape for this widget’s GDK window.
	// This allows for windows which react to mouse click in a nonrectangular
	// region, see gdk_window_input_shape_combine_region() for more information.
	InputShapeCombineRegion(region *cairo.Region)
	// InsertActionGroup inserts @group into @widget. Children of @widget that
	// implement Actionable can then be associated with actions in @group by
	// setting their “action-name” to @prefix.`action-name`.
	//
	// If @group is nil, a previously inserted group for @name is removed from
	// @widget.
	InsertActionGroup(name string, group gio.ActionGroup)
	// Intersect computes the intersection of a @widget’s area and @area,
	// storing the intersection in @intersection, and returns true if there was
	// an intersection. @intersection may be nil if you’re only interested in
	// whether there was an intersection.
	Intersect(area *gdk.Rectangle) (intersection *gdk.Rectangle, ok bool)
	// IsAncestor determines whether @widget is somewhere inside @ancestor,
	// possibly with intermediate containers.
	IsAncestor(ancestor Widget) bool
	// IsComposited: whether @widget can rely on having its alpha channel drawn
	// correctly. On X11 this function returns whether a compositing manager is
	// running for @widget’s screen.
	//
	// Please note that the semantics of this call will change in the future if
	// used on a widget that has a composited window in its hierarchy (as set by
	// gdk_window_set_composited()).
	IsComposited() bool
	// IsDrawable determines whether @widget can be drawn to. A widget can be
	// drawn to if it is mapped and visible.
	IsDrawable() bool
	// IsFocus determines if the widget is the focus widget within its toplevel.
	// (This does not mean that the Widget:has-focus property is necessarily
	// set; Widget:has-focus will only be set if the toplevel widget
	// additionally has the global input focus.)
	IsFocus() bool
	// IsSensitive returns the widget’s effective sensitivity, which means it is
	// sensitive itself and also its parent widget is sensitive
	IsSensitive() bool
	// IsToplevel determines whether @widget is a toplevel widget.
	//
	// Currently only Window and Invisible (and out-of-process Plugs) are
	// toplevel widgets. Toplevel widgets have no parent widget.
	IsToplevel() bool
	// IsVisible determines whether the widget and all its parents are marked as
	// visible.
	//
	// This function does not check if the widget is obscured in any way.
	//
	// See also gtk_widget_get_visible() and gtk_widget_set_visible()
	IsVisible() bool
	// KeynavFailed: this function should be called whenever keyboard navigation
	// within a single widget hits a boundary. The function emits the
	// Widget::keynav-failed signal on the widget and its return value should be
	// interpreted in a way similar to the return value of
	// gtk_widget_child_focus():
	//
	// When true is returned, stay in the widget, the failed keyboard navigation
	// is OK and/or there is nowhere we can/should move the focus to.
	//
	// When false is returned, the caller should continue with keyboard
	// navigation outside the widget, e.g. by calling gtk_widget_child_focus()
	// on the widget’s toplevel.
	//
	// The default ::keynav-failed handler returns false for GTK_DIR_TAB_FORWARD
	// and GTK_DIR_TAB_BACKWARD. For the other values of DirectionType it
	// returns true.
	//
	// Whenever the default handler returns true, it also calls
	// gtk_widget_error_bell() to notify the user of the failed keyboard
	// navigation.
	//
	// A use case for providing an own implementation of ::keynav-failed (either
	// by connecting to it or by overriding it) would be a row of Entry widgets
	// where the user should be able to navigate the entire row with the cursor
	// keys, as e.g. known from user interfaces that require entering license
	// keys.
	KeynavFailed(direction DirectionType) bool
	// ListAccelClosures lists the closures used by @widget for accelerator
	// group connections with gtk_accel_group_connect_by_path() or
	// gtk_accel_group_connect(). The closures can be used to monitor
	// accelerator changes on @widget, by connecting to the
	// @GtkAccelGroup::accel-changed signal of the AccelGroup of a closure which
	// can be found out with gtk_accel_group_from_accel_closure().
	ListAccelClosures() *glib.List
	// ListActionPrefixes retrieves a nil-terminated array of strings containing
	// the prefixes of Group's available to @widget.
	ListActionPrefixes() []string
	// ListMnemonicLabels returns a newly allocated list of the widgets,
	// normally labels, for which this widget is the target of a mnemonic (see
	// for example, gtk_label_set_mnemonic_widget()).
	//
	// The widgets in the list are not individually referenced. If you want to
	// iterate through the list and perform actions involving callbacks that
	// might destroy the widgets, you must call `g_list_foreach (result,
	// (GFunc)g_object_ref, NULL)` first, and then unref all the widgets
	// afterwards.
	ListMnemonicLabels() *glib.List
	// Map: this function is only for use in widget implementations. Causes a
	// widget to be mapped if it isn’t already.
	Map()
	// MnemonicActivate emits the Widget::mnemonic-activate signal.
	MnemonicActivate(groupCycling bool) bool
	// ModifyBase sets the base color for a widget in a particular state. All
	// other style values are left untouched. The base color is the background
	// color used along with the text color (see gtk_widget_modify_text()) for
	// widgets such as Entry and TextView. See also gtk_widget_modify_style().
	//
	// > Note that “no window” widgets (which have the GTK_NO_WINDOW > flag set)
	// draw on their parent container’s window and thus may > not draw any
	// background themselves. This is the case for e.g. > Label. > > To modify
	// the background of such widgets, you have to set the > base color on their
	// parent; if you want to set the background > of a rectangular area around
	// a label, try placing the label in > a EventBox widget and setting the
	// base color on that.
	ModifyBase(state StateType, color *gdk.Color)
	// ModifyBg sets the background color for a widget in a particular state.
	//
	// All other style values are left untouched. See also
	// gtk_widget_modify_style().
	//
	// > Note that “no window” widgets (which have the GTK_NO_WINDOW > flag set)
	// draw on their parent container’s window and thus may > not draw any
	// background themselves. This is the case for e.g. > Label. > > To modify
	// the background of such widgets, you have to set the > background color on
	// their parent; if you want to set the background > of a rectangular area
	// around a label, try placing the label in > a EventBox widget and setting
	// the background color on that.
	ModifyBg(state StateType, color *gdk.Color)
	// ModifyCursor sets the cursor color to use in a widget, overriding the
	// Widget cursor-color and secondary-cursor-color style properties.
	//
	// All other style values are left untouched. See also
	// gtk_widget_modify_style().
	ModifyCursor(primary *gdk.Color, secondary *gdk.Color)
	// ModifyFg sets the foreground color for a widget in a particular state.
	//
	// All other style values are left untouched. See also
	// gtk_widget_modify_style().
	ModifyFg(state StateType, color *gdk.Color)
	// ModifyFont sets the font to use for a widget.
	//
	// All other style values are left untouched. See also
	// gtk_widget_modify_style().
	ModifyFont(fontDesc *pango.FontDescription)
	// ModifyStyle modifies style values on the widget.
	//
	// Modifications made using this technique take precedence over style values
	// set via an RC file, however, they will be overridden if a style is
	// explicitly set on the widget using gtk_widget_set_style(). The
	// RcStyle-struct is designed so each field can either be set or unset, so
	// it is possible, using this function, to modify some style values and
	// leave the others unchanged.
	//
	// Note that modifications made with this function are not cumulative with
	// previous calls to gtk_widget_modify_style() or with such functions as
	// gtk_widget_modify_fg(). If you wish to retain previous values, you must
	// first call gtk_widget_get_modifier_style(), make your modifications to
	// the returned style, then call gtk_widget_modify_style() with that style.
	// On the other hand, if you first call gtk_widget_modify_style(),
	// subsequent calls to such functions gtk_widget_modify_fg() will have a
	// cumulative effect with the initial modifications.
	ModifyStyle(style RCStyle)
	// ModifyText sets the text color for a widget in a particular state.
	//
	// All other style values are left untouched. The text color is the
	// foreground color used along with the base color (see
	// gtk_widget_modify_base()) for widgets such as Entry and TextView. See
	// also gtk_widget_modify_style().
	ModifyText(state StateType, color *gdk.Color)
	// OverrideBackgroundColor sets the background color to use for a widget.
	//
	// All other style values are left untouched. See
	// gtk_widget_override_color().
	OverrideBackgroundColor(state StateFlags, color *gdk.RGBA)
	// OverrideColor sets the color to use for a widget.
	//
	// All other style values are left untouched.
	//
	// This function does not act recursively. Setting the color of a container
	// does not affect its children. Note that some widgets that you may not
	// think of as containers, for instance Buttons, are actually containers.
	//
	// This API is mostly meant as a quick way for applications to change a
	// widget appearance. If you are developing a widgets library and intend
	// this change to be themeable, it is better done by setting meaningful CSS
	// classes in your widget/container implementation through
	// gtk_style_context_add_class().
	//
	// This way, your widget library can install a CssProvider with the
	// GTK_STYLE_PROVIDER_PRIORITY_FALLBACK priority in order to provide a
	// default styling for those widgets that need so, and this theming may
	// fully overridden by the user’s theme.
	//
	// Note that for complex widgets this may bring in undesired results (such
	// as uniform background color everywhere), in these cases it is better to
	// fully style such widgets through a CssProvider with the
	// GTK_STYLE_PROVIDER_PRIORITY_APPLICATION priority.
	OverrideColor(state StateFlags, color *gdk.RGBA)
	// OverrideCursor sets the cursor color to use in a widget, overriding the
	// cursor-color and secondary-cursor-color style properties. All other style
	// values are left untouched. See also gtk_widget_modify_style().
	//
	// Note that the underlying properties have the Color type, so the alpha
	// value in @primary and @secondary will be ignored.
	OverrideCursor(cursor *gdk.RGBA, secondaryCursor *gdk.RGBA)
	// OverrideFont sets the font to use for a widget. All other style values
	// are left untouched. See gtk_widget_override_color().
	OverrideFont(fontDesc *pango.FontDescription)
	// OverrideSymbolicColor sets a symbolic color for a widget.
	//
	// All other style values are left untouched. See
	// gtk_widget_override_color() for overriding the foreground or background
	// color.
	OverrideSymbolicColor(name string, color *gdk.RGBA)
	// Path obtains the full path to @widget. The path is simply the name of a
	// widget and all its parents in the container hierarchy, separated by
	// periods. The name of a widget comes from gtk_widget_get_name(). Paths are
	// used to apply styles to a widget in gtkrc configuration files. Widget
	// names are the type of the widget by default (e.g. “GtkButton”) or can be
	// set to an application-specific value with gtk_widget_set_name(). By
	// setting the name of a widget, you allow users or theme authors to apply
	// styles to that specific widget in their gtkrc file. @path_reversed_p
	// fills in the path in reverse order, i.e. starting with @widget’s name
	// instead of starting with the name of @widget’s outermost ancestor.
	Path() (pathLength uint, path string, pathReversed string)
	// QueueAllocate: this function is only for use in widget implementations.
	//
	// Flags the widget for a rerun of the GtkWidgetClass::size_allocate
	// function. Use this function instead of gtk_widget_queue_resize() when the
	// @widget's size request didn't change but it wants to reposition its
	// contents.
	//
	// An example user of this function is gtk_widget_set_halign().
	QueueAllocate()
	// QueueComputeExpand: mark @widget as needing to recompute its expand
	// flags. Call this function when setting legacy expand child properties on
	// the child of a container.
	//
	// See gtk_widget_compute_expand().
	QueueComputeExpand()
	// QueueDraw: equivalent to calling gtk_widget_queue_draw_area() for the
	// entire area of a widget.
	QueueDraw()
	// QueueDrawArea: convenience function that calls
	// gtk_widget_queue_draw_region() on the region created from the given
	// coordinates.
	//
	// The region here is specified in widget coordinates. Widget coordinates
	// are a bit odd; for historical reasons, they are defined as
	// @widget->window coordinates for widgets that return true for
	// gtk_widget_get_has_window(), and are relative to @widget->allocation.x,
	// @widget->allocation.y otherwise.
	//
	// @width or @height may be 0, in this case this function does nothing.
	// Negative values for @width and @height are not allowed.
	QueueDrawArea(x int, y int, width int, height int)
	// QueueDrawRegion invalidates the area of @widget defined by @region by
	// calling gdk_window_invalidate_region() on the widget’s window and all its
	// child windows. Once the main loop becomes idle (after the current batch
	// of events has been processed, roughly), the window will receive expose
	// events for the union of all regions that have been invalidated.
	//
	// Normally you would only use this function in widget implementations. You
	// might also use it to schedule a redraw of a DrawingArea or some portion
	// thereof.
	QueueDrawRegion(region *cairo.Region)
	// QueueResize: this function is only for use in widget implementations.
	// Flags a widget to have its size renegotiated; should be called when a
	// widget for some reason has a new size request. For example, when you
	// change the text in a Label, Label queues a resize to ensure there’s
	// enough space for the new text.
	//
	// Note that you cannot call gtk_widget_queue_resize() on a widget from
	// inside its implementation of the GtkWidgetClass::size_allocate virtual
	// method. Calls to gtk_widget_queue_resize() from inside
	// GtkWidgetClass::size_allocate will be silently ignored.
	QueueResize()
	// QueueResizeNoRedraw: this function works like gtk_widget_queue_resize(),
	// except that the widget is not invalidated.
	QueueResizeNoRedraw()
	// Realize creates the GDK (windowing system) resources associated with a
	// widget. For example, @widget->window will be created when a widget is
	// realized. Normally realization happens implicitly; if you show a widget
	// and all its parent containers, then the widget will be realized and
	// mapped automatically.
	//
	// Realizing a widget requires all the widget’s parent widgets to be
	// realized; calling gtk_widget_realize() realizes the widget’s parents in
	// addition to @widget itself. If a widget is not yet inside a toplevel
	// window when you realize it, bad things will happen.
	//
	// This function is primarily used in widget implementations, and isn’t very
	// useful otherwise. Many times when you think you might need it, a better
	// approach is to connect to a signal that will be called after the widget
	// is realized automatically, such as Widget::draw. Or simply
	// g_signal_connect () to the Widget::realize signal.
	Realize()
	// RegionIntersect computes the intersection of a @widget’s area and
	// @region, returning the intersection. The result may be empty, use
	// cairo_region_is_empty() to check.
	RegionIntersect(region *cairo.Region) *cairo.Region
	// RegisterWindow registers a Window with the widget and sets it up so that
	// the widget receives events for it. Call gtk_widget_unregister_window()
	// when destroying the window.
	//
	// Before 3.8 you needed to call gdk_window_set_user_data() directly to set
	// this up. This is now deprecated and you should use
	// gtk_widget_register_window() instead. Old code will keep working as is,
	// although some new features like transparency might not work perfectly.
	RegisterWindow(window gdk.Window)
	// RemoveAccelerator removes an accelerator from @widget, previously
	// installed with gtk_widget_add_accelerator().
	RemoveAccelerator(accelGroup AccelGroup, accelKey uint, accelMods gdk.ModifierType) bool
	// RemoveMnemonicLabel removes a widget from the list of mnemonic labels for
	// this widget. (See gtk_widget_list_mnemonic_labels()). The widget must
	// have previously been added to the list with
	// gtk_widget_add_mnemonic_label().
	RemoveMnemonicLabel(label Widget)
	// RemoveTickCallback removes a tick callback previously registered with
	// gtk_widget_add_tick_callback().
	RemoveTickCallback(iD uint)
	// RenderIcon: a convenience function that uses the theme settings for
	// @widget to look up @stock_id and render it to a pixbuf. @stock_id should
	// be a stock icon ID such as K_STOCK_OPEN or K_STOCK_OK. @size should be a
	// size such as K_ICON_SIZE_MENU. @detail should be a string that identifies
	// the widget or code doing the rendering, so that theme engines can
	// special-case rendering for that widget or code.
	//
	// The pixels in the returned Pixbuf are shared with the rest of the
	// application and should not be modified. The pixbuf should be freed after
	// use with g_object_unref().
	RenderIcon(stockID string, size int, detail string) gdkpixbuf.Pixbuf
	// RenderIconPixbuf: a convenience function that uses the theme engine and
	// style settings for @widget to look up @stock_id and render it to a
	// pixbuf. @stock_id should be a stock icon ID such as K_STOCK_OPEN or
	// K_STOCK_OK. @size should be a size such as K_ICON_SIZE_MENU.
	//
	// The pixels in the returned Pixbuf are shared with the rest of the
	// application and should not be modified. The pixbuf should be freed after
	// use with g_object_unref().
	RenderIconPixbuf(stockID string, size int) gdkpixbuf.Pixbuf
	// Reparent moves a widget from one Container to another, handling reference
	// count issues to avoid destroying the widget.
	Reparent(newParent Widget)
	// ResetRCStyles: reset the styles of @widget and all descendents, so when
	// they are looked up again, they get the correct values for the currently
	// loaded RC file settings.
	//
	// This function is not useful for applications.
	ResetRCStyles()
	// ResetStyle updates the style context of @widget and all descendants by
	// updating its widget path. Containers may want to use this on a child when
	// reordering it in a way that a different style might apply to it. See also
	// gtk_container_get_path_for_child().
	ResetStyle()
	// SetAccelPath: given an accelerator group, @accel_group, and an
	// accelerator path, @accel_path, sets up an accelerator in @accel_group so
	// whenever the key binding that is defined for @accel_path is pressed,
	// @widget will be activated. This removes any accelerators (for any
	// accelerator group) installed by previous calls to
	// gtk_widget_set_accel_path(). Associating accelerators with paths allows
	// them to be modified by the user and the modifications to be saved for
	// future use. (See gtk_accel_map_save().)
	//
	// This function is a low level function that would most likely be used by a
	// menu creation system like UIManager. If you use UIManager, setting up
	// accelerator paths will be done automatically.
	//
	// Even when you you aren’t using UIManager, if you only want to set up
	// accelerators on menu items gtk_menu_item_set_accel_path() provides a
	// somewhat more convenient interface.
	//
	// Note that @accel_path string will be stored in a #GQuark. Therefore, if
	// you pass a static string, you can save some memory by interning it first
	// with g_intern_static_string().
	SetAccelPath(accelPath string, accelGroup AccelGroup)
	// SetAppPaintable sets whether the application intends to draw on the
	// widget in an Widget::draw handler.
	//
	// This is a hint to the widget and does not affect the behavior of the GTK+
	// core; many widgets ignore this flag entirely. For widgets that do pay
	// attention to the flag, such as EventBox and Window, the effect is to
	// suppress default themed drawing of the widget's background. (Children of
	// the widget will still be drawn.) The application is then entirely
	// responsible for drawing the widget background.
	//
	// Note that the background is still drawn when the widget is mapped.
	SetAppPaintable(appPaintable bool)
	// SetCanDefault specifies whether @widget can be a default widget. See
	// gtk_widget_grab_default() for details about the meaning of “default”.
	SetCanDefault(canDefault bool)
	// SetCanFocus specifies whether @widget can own the input focus. See
	// gtk_widget_grab_focus() for actually setting the input focus on a widget.
	SetCanFocus(canFocus bool)
	// SetChildVisible sets whether @widget should be mapped along with its when
	// its parent is mapped and @widget has been shown with gtk_widget_show().
	//
	// The child visibility can be set for widget before it is added to a
	// container with gtk_widget_set_parent(), to avoid mapping children
	// unnecessary before immediately unmapping them. However it will be reset
	// to its default state of true when the widget is removed from a container.
	//
	// Note that changing the child visibility of a widget does not queue a
	// resize on the widget. Most of the time, the size of a widget is computed
	// from all visible children, whether or not they are mapped. If this is not
	// the case, the container can queue a resize itself.
	//
	// This function is only useful for container implementations and never
	// should be called by an application.
	SetChildVisible(isVisible bool)
	// SetCompositeName sets a widgets composite name. The widget must be a
	// composite child of its parent; see gtk_widget_push_composite_child().
	SetCompositeName(name string)
	// SetDeviceEnabled enables or disables a Device to interact with @widget
	// and all its children.
	//
	// It does so by descending through the Window hierarchy and enabling the
	// same mask that is has for core events (i.e. the one that
	// gdk_window_get_events() returns).
	SetDeviceEnabled(device gdk.Device, enabled bool)
	// SetDeviceEvents sets the device event mask (see EventMask) for a widget.
	// The event mask determines which events a widget will receive from
	// @device. Keep in mind that different widgets have different default event
	// masks, and by changing the event mask you may disrupt a widget’s
	// functionality, so be careful. This function must be called while a widget
	// is unrealized. Consider gtk_widget_add_device_events() for widgets that
	// are already realized, or if you want to preserve the existing event mask.
	// This function can’t be used with windowless widgets (which return false
	// from gtk_widget_get_has_window()); to get events on those widgets, place
	// them inside a EventBox and receive events on the event box.
	SetDeviceEvents(device gdk.Device, events gdk.EventMask)
	// SetDirection sets the reading direction on a particular widget. This
	// direction controls the primary direction for widgets containing text, and
	// also the direction in which the children of a container are packed. The
	// ability to set the direction is present in order so that correct
	// localization into languages with right-to-left reading directions can be
	// done. Generally, applications will let the default reading direction
	// present, except for containers where the containers are arranged in an
	// order that is explicitly visual rather than logical (such as buttons for
	// text justification).
	//
	// If the direction is set to GTK_TEXT_DIR_NONE, then the value set by
	// gtk_widget_set_default_direction() will be used.
	SetDirection(dir TextDirection)
	// SetDoubleBuffered widgets are double buffered by default; you can use
	// this function to turn off the buffering. “Double buffered” simply means
	// that gdk_window_begin_draw_frame() and gdk_window_end_draw_frame() are
	// called automatically around expose events sent to the widget.
	// gdk_window_begin_draw_frame() diverts all drawing to a widget's window to
	// an offscreen buffer, and gdk_window_end_draw_frame() draws the buffer to
	// the screen. The result is that users see the window update in one smooth
	// step, and don’t see individual graphics primitives being rendered.
	//
	// In very simple terms, double buffered widgets don’t flicker, so you would
	// only use this function to turn off double buffering if you had special
	// needs and really knew what you were doing.
	//
	// Note: if you turn off double-buffering, you have to handle expose events,
	// since even the clearing to the background color or pixmap will not happen
	// automatically (as it is done in gdk_window_begin_draw_frame()).
	//
	// In 3.10 GTK and GDK have been restructured for translucent drawing. Since
	// then expose events for double-buffered widgets are culled into a single
	// event to the toplevel GDK window. If you now unset double buffering, you
	// will cause a separate rendering pass for every widget. This will likely
	// cause rendering problems - in particular related to stacking - and
	// usually increases rendering times significantly.
	SetDoubleBuffered(doubleBuffered bool)
	// SetEvents sets the event mask (see EventMask) for a widget. The event
	// mask determines which events a widget will receive. Keep in mind that
	// different widgets have different default event masks, and by changing the
	// event mask you may disrupt a widget’s functionality, so be careful. This
	// function must be called while a widget is unrealized. Consider
	// gtk_widget_add_events() for widgets that are already realized, or if you
	// want to preserve the existing event mask. This function can’t be used
	// with widgets that have no window. (See gtk_widget_get_has_window()). To
	// get events on those widgets, place them inside a EventBox and receive
	// events on the event box.
	SetEvents(events int)
	// SetFocusOnClick sets whether the widget should grab focus when it is
	// clicked with the mouse. Making mouse clicks not grab focus is useful in
	// places like toolbars where you don’t want the keyboard focus removed from
	// the main area of the application.
	SetFocusOnClick(focusOnClick bool)
	// SetFontMap sets the font map to use for Pango rendering. When not set,
	// the widget will inherit the font map from its parent.
	SetFontMap(fontMap pango.FontMap)
	// SetFontOptions sets the #cairo_font_options_t used for Pango rendering in
	// this widget. When not set, the default font options for the Screen will
	// be used.
	SetFontOptions(options *cairo.FontOptions)
	// SetHalign sets the horizontal alignment of @widget. See the Widget:halign
	// property.
	SetHalign(align Align)
	// SetHasTooltip sets the has-tooltip property on @widget to @has_tooltip.
	// See Widget:has-tooltip for more information.
	SetHasTooltip(hasTooltip bool)
	// SetHasWindow specifies whether @widget has a Window of its own. Note that
	// all realized widgets have a non-nil “window” pointer
	// (gtk_widget_get_window() never returns a nil window when a widget is
	// realized), but for many of them it’s actually the Window of one of its
	// parent widgets. Widgets that do not create a window for themselves in
	// Widget::realize must announce this by calling this function with
	// @has_window = false.
	//
	// This function should only be called by widget implementations, and they
	// should call it in their init() function.
	SetHasWindow(hasWindow bool)
	// SetHexpand sets whether the widget would like any available extra
	// horizontal space. When a user resizes a Window, widgets with expand=TRUE
	// generally receive the extra space. For example, a list or scrollable area
	// or document in your window would often be set to expand.
	//
	// Call this function to set the expand flag if you would like your widget
	// to become larger horizontally when the window has extra room.
	//
	// By default, widgets automatically expand if any of their children want to
	// expand. (To see if a widget will automatically expand given its current
	// children and state, call gtk_widget_compute_expand(). A container can
	// decide how the expandability of children affects the expansion of the
	// container by overriding the compute_expand virtual method on Widget.).
	//
	// Setting hexpand explicitly with this function will override the automatic
	// expand behavior.
	//
	// This function forces the widget to expand or not to expand, regardless of
	// children. The override occurs because gtk_widget_set_hexpand() sets the
	// hexpand-set property (see gtk_widget_set_hexpand_set()) which causes the
	// widget’s hexpand value to be used, rather than looking at children and
	// widget state.
	SetHexpand(expand bool)
	// SetHexpandSet sets whether the hexpand flag (see
	// gtk_widget_get_hexpand()) will be used.
	//
	// The hexpand-set property will be set automatically when you call
	// gtk_widget_set_hexpand() to set hexpand, so the most likely reason to use
	// this function would be to unset an explicit expand flag.
	//
	// If hexpand is set, then it overrides any computed expand value based on
	// child widgets. If hexpand is not set, then the expand value depends on
	// whether any children of the widget would like to expand.
	//
	// There are few reasons to use this function, but it’s here for
	// completeness and consistency.
	SetHexpandSet(set bool)
	// SetMapped marks the widget as being mapped.
	//
	// This function should only ever be called in a derived widget's “map” or
	// “unmap” implementation.
	SetMapped(mapped bool)
	// SetMarginBottom sets the bottom margin of @widget. See the
	// Widget:margin-bottom property.
	SetMarginBottom(margin int)
	// SetMarginEnd sets the end margin of @widget. See the Widget:margin-end
	// property.
	SetMarginEnd(margin int)
	// SetMarginLeft sets the left margin of @widget. See the Widget:margin-left
	// property.
	SetMarginLeft(margin int)
	// SetMarginRight sets the right margin of @widget. See the
	// Widget:margin-right property.
	SetMarginRight(margin int)
	// SetMarginStart sets the start margin of @widget. See the
	// Widget:margin-start property.
	SetMarginStart(margin int)
	// SetMarginTop sets the top margin of @widget. See the Widget:margin-top
	// property.
	SetMarginTop(margin int)
	// SetName widgets can be named, which allows you to refer to them from a
	// CSS file. You can apply a style to widgets with a particular name in the
	// CSS file. See the documentation for the CSS syntax (on the same page as
	// the docs for StyleContext).
	//
	// Note that the CSS syntax has certain special characters to delimit and
	// represent elements in a selector (period, #, >, *...), so using these
	// will make your widget impossible to match by name. Any combination of
	// alphanumeric symbols, dashes and underscores will suffice.
	SetName(name string)
	// SetNoShowAll sets the Widget:no-show-all property, which determines
	// whether calls to gtk_widget_show_all() will affect this widget.
	//
	// This is mostly for use in constructing widget hierarchies with externally
	// controlled visibility, see UIManager.
	SetNoShowAll(noShowAll bool)
	// SetOpacity: request the @widget to be rendered partially transparent,
	// with opacity 0 being fully transparent and 1 fully opaque. (Opacity
	// values are clamped to the [0,1] range.). This works on both toplevel
	// widget, and child widgets, although there are some limitations:
	//
	// For toplevel widgets this depends on the capabilities of the windowing
	// system. On X11 this has any effect only on X screens with a compositing
	// manager running. See gtk_widget_is_composited(). On Windows it should
	// work always, although setting a window’s opacity after the window has
	// been shown causes it to flicker once on Windows.
	//
	// For child widgets it doesn’t work if any affected widget has a native
	// window, or disables double buffering.
	SetOpacity(opacity float64)
	// SetParent: this function is useful only when implementing subclasses of
	// Container. Sets the container as the parent of @widget, and takes care of
	// some details such as updating the state and style of the child to reflect
	// its new location. The opposite function is gtk_widget_unparent().
	SetParent(parent Widget)
	// SetParentWindow sets a non default parent window for @widget.
	//
	// For Window classes, setting a @parent_window effects whether the window
	// is a toplevel window or can be embedded into other widgets.
	//
	// For Window classes, this needs to be called before the window is
	// realized.
	SetParentWindow(parentWindow gdk.Window)
	// SetRealized marks the widget as being realized. This function must only
	// be called after all Windows for the @widget have been created and
	// registered.
	//
	// This function should only ever be called in a derived widget's “realize”
	// or “unrealize” implementation.
	SetRealized(realized bool)
	// SetReceivesDefault specifies whether @widget will be treated as the
	// default widget within its toplevel when it has the focus, even if another
	// widget is the default.
	//
	// See gtk_widget_grab_default() for details about the meaning of “default”.
	SetReceivesDefault(receivesDefault bool)
	// SetRedrawOnAllocate sets whether the entire widget is queued for drawing
	// when its size allocation changes. By default, this setting is true and
	// the entire widget is redrawn on every size change. If your widget leaves
	// the upper left unchanged when made bigger, turning this setting off will
	// improve performance.
	//
	// Note that for widgets where gtk_widget_get_has_window() is false setting
	// this flag to false turns off all allocation on resizing: the widget will
	// not even redraw if its position changes; this is to allow containers that
	// don’t draw anything to avoid excess invalidations. If you set this flag
	// on a widget with no window that does draw on @widget->window, you are
	// responsible for invalidating both the old and new allocation of the
	// widget when the widget is moved and responsible for invalidating regions
	// newly when the widget increases size.
	SetRedrawOnAllocate(redrawOnAllocate bool)
	// SetSensitive sets the sensitivity of a widget. A widget is sensitive if
	// the user can interact with it. Insensitive widgets are “grayed out” and
	// the user can’t interact with them. Insensitive widgets are known as
	// “inactive”, “disabled”, or “ghosted” in some other toolkits.
	SetSensitive(sensitive bool)
	// SetSizeRequest sets the minimum size of a widget; that is, the widget’s
	// size request will be at least @width by @height. You can use this
	// function to force a widget to be larger than it normally would be.
	//
	// In most cases, gtk_window_set_default_size() is a better choice for
	// toplevel windows than this function; setting the default size will still
	// allow users to shrink the window. Setting the size request will force
	// them to leave the window at least as large as the size request. When
	// dealing with window sizes, gtk_window_set_geometry_hints() can be a
	// useful function as well.
	//
	// Note the inherent danger of setting any fixed size - themes, translations
	// into other languages, different fonts, and user action can all change the
	// appropriate size for a given widget. So, it's basically impossible to
	// hardcode a size that will always be correct.
	//
	// The size request of a widget is the smallest size a widget can accept
	// while still functioning well and drawing itself correctly. However in
	// some strange cases a widget may be allocated less than its requested
	// size, and in many cases a widget may be allocated more space than it
	// requested.
	//
	// If the size request in a given direction is -1 (unset), then the
	// “natural” size request of the widget will be used instead.
	//
	// The size request set here does not include any margin from the Widget
	// properties margin-left, margin-right, margin-top, and margin-bottom, but
	// it does include pretty much all other padding or border properties set by
	// any subclass of Widget.
	SetSizeRequest(width int, height int)
	// SetState: this function is for use in widget implementations. Sets the
	// state of a widget (insensitive, prelighted, etc.) Usually you should set
	// the state using wrapper functions such as gtk_widget_set_sensitive().
	SetState(state StateType)
	// SetStateFlags: this function is for use in widget implementations. Turns
	// on flag values in the current widget state (insensitive, prelighted,
	// etc.).
	//
	// This function accepts the values GTK_STATE_FLAG_DIR_LTR and
	// GTK_STATE_FLAG_DIR_RTL but ignores them. If you want to set the widget's
	// direction, use gtk_widget_set_direction().
	//
	// It is worth mentioning that any other state than
	// GTK_STATE_FLAG_INSENSITIVE, will be propagated down to all non-internal
	// children if @widget is a Container, while GTK_STATE_FLAG_INSENSITIVE
	// itself will be propagated down to all Container children by different
	// means than turning on the state flag down the hierarchy, both
	// gtk_widget_get_state_flags() and gtk_widget_is_sensitive() will make use
	// of these.
	SetStateFlags(flags StateFlags, clear bool)
	// SetStyle: used to set the Style for a widget (@widget->style). Since GTK
	// 3, this function does nothing, the passed in style is ignored.
	SetStyle(style Style)
	// SetSupportMultidevice enables or disables multiple pointer awareness. If
	// this setting is true, @widget will start receiving multiple, per device
	// enter/leave events. Note that if custom Windows are created in
	// Widget::realize, gdk_window_set_support_multidevice() will have to be
	// called manually on them.
	SetSupportMultidevice(supportMultidevice bool)
	// SetTooltipMarkup sets @markup as the contents of the tooltip, which is
	// marked up with the [Pango text markup language][PangoMarkupFormat].
	//
	// This function will take care of setting Widget:has-tooltip to true and of
	// the default handler for the Widget::query-tooltip signal.
	//
	// See also the Widget:tooltip-markup property and gtk_tooltip_set_markup().
	SetTooltipMarkup(markup string)
	// SetTooltipText sets @text as the contents of the tooltip. This function
	// will take care of setting Widget:has-tooltip to true and of the default
	// handler for the Widget::query-tooltip signal.
	//
	// See also the Widget:tooltip-text property and gtk_tooltip_set_text().
	SetTooltipText(text string)
	// SetTooltipWindow replaces the default window used for displaying tooltips
	// with @custom_window. GTK+ will take care of showing and hiding
	// @custom_window at the right moment, to behave likewise as the default
	// tooltip window. If @custom_window is nil, the default tooltip window will
	// be used.
	SetTooltipWindow(customWindow Window)
	// SetValign sets the vertical alignment of @widget. See the Widget:valign
	// property.
	SetValign(align Align)
	// SetVexpand sets whether the widget would like any available extra
	// vertical space.
	//
	// See gtk_widget_set_hexpand() for more detail.
	SetVexpand(expand bool)
	// SetVexpandSet sets whether the vexpand flag (see
	// gtk_widget_get_vexpand()) will be used.
	//
	// See gtk_widget_set_hexpand_set() for more detail.
	SetVexpandSet(set bool)
	// SetVisible sets the visibility state of @widget. Note that setting this
	// to true doesn’t mean the widget is actually viewable, see
	// gtk_widget_get_visible().
	//
	// This function simply calls gtk_widget_show() or gtk_widget_hide() but is
	// nicer to use when the visibility of the widget depends on some condition.
	SetVisible(visible bool)
	// SetVisual sets the visual that should be used for by widget and its
	// children for creating Windows. The visual must be on the same Screen as
	// returned by gtk_widget_get_screen(), so handling the
	// Widget::screen-changed signal is necessary.
	//
	// Setting a new @visual will not cause @widget to recreate its windows, so
	// you should call this function before @widget is realized.
	SetVisual(visual gdk.Visual)
	// SetWindow sets a widget’s window. This function should only be used in a
	// widget’s Widget::realize implementation. The window passed is usually
	// either new window created with gdk_window_new(), or the window of its
	// parent widget as returned by gtk_widget_get_parent_window().
	//
	// Widgets must indicate whether they will create their own Window by
	// calling gtk_widget_set_has_window(). This is usually done in the widget’s
	// init() function.
	//
	// Note that this function does not add any reference to @window.
	SetWindow(window gdk.Window)
	// ShapeCombineRegion sets a shape for this widget’s GDK window. This allows
	// for transparent windows etc., see gdk_window_shape_combine_region() for
	// more information.
	ShapeCombineRegion(region *cairo.Region)
	// Show flags a widget to be displayed. Any widget that isn’t shown will not
	// appear on the screen. If you want to show all the widgets in a container,
	// it’s easier to call gtk_widget_show_all() on the container, instead of
	// individually showing the widgets.
	//
	// Remember that you have to show the containers containing a widget, in
	// addition to the widget itself, before it will appear onscreen.
	//
	// When a toplevel container is shown, it is immediately realized and
	// mapped; other shown widgets are realized and mapped when their toplevel
	// container is realized and mapped.
	Show()
	// ShowAll: recursively shows a widget, and any child widgets (if the widget
	// is a container).
	ShowAll()
	// ShowNow shows a widget. If the widget is an unmapped toplevel widget
	// (i.e. a Window that has not yet been shown), enter the main loop and wait
	// for the window to actually be mapped. Be careful; because the main loop
	// is running, anything can happen during this function.
	ShowNow()
	// SizeRequest: this function is typically used when implementing a
	// Container subclass. Obtains the preferred size of a widget. The container
	// uses this information to arrange its child widgets and decide what size
	// allocations to give them with gtk_widget_size_allocate().
	//
	// You can also call this function from an application, with some caveats.
	// Most notably, getting a size request requires the widget to be associated
	// with a screen, because font information may be needed. Multihead-aware
	// applications should keep this in mind.
	//
	// Also remember that the size request is not necessarily the size a widget
	// will actually be allocated.
	SizeRequest() *Requisition
	// StyleAttach: this function attaches the widget’s Style to the widget's
	// Window. It is a replacement for
	//
	//    widget->style = gtk_style_attach (widget->style, widget->window);
	//
	// and should only ever be called in a derived widget’s “realize”
	// implementation which does not chain up to its parent class' “realize”
	// implementation, because one of the parent classes (finally Widget) would
	// attach the style itself.
	StyleAttach()
	// StyleGetProperty gets the value of a style property of @widget.
	StyleGetProperty(propertyName string, value *externglib.Value)
	// ThawChildNotify reverts the effect of a previous call to
	// gtk_widget_freeze_child_notify(). This causes all queued
	// Widget::child-notify signals on @widget to be emitted.
	ThawChildNotify()
	// TranslateCoordinates: translate coordinates relative to @src_widget’s
	// allocation to coordinates relative to @dest_widget’s allocations. In
	// order to perform this operation, both widgets must be realized, and must
	// share a common toplevel.
	TranslateCoordinates(destWidget Widget, srcX int, srcY int) (destX int, destY int, ok bool)
	// TriggerTooltipQuery triggers a tooltip query on the display where the
	// toplevel of @widget is located. See gtk_tooltip_trigger_tooltip_query()
	// for more information.
	TriggerTooltipQuery()
	// Unmap: this function is only for use in widget implementations. Causes a
	// widget to be unmapped if it’s currently mapped.
	Unmap()
	// Unparent: this function is only for use in widget implementations. Should
	// be called by implementations of the remove method on Container, to
	// dissociate a child from the container.
	Unparent()
	// Unrealize: this function is only useful in widget implementations. Causes
	// a widget to be unrealized (frees all GDK resources associated with the
	// widget, such as @widget->window).
	Unrealize()
	// UnregisterWindow unregisters a Window from the widget that was previously
	// set up with gtk_widget_register_window(). You need to call this when the
	// window is no longer used by the widget, such as when you destroy it.
	UnregisterWindow(window gdk.Window)
	// UnsetStateFlags: this function is for use in widget implementations.
	// Turns off flag values for the current widget state (insensitive,
	// prelighted, etc.). See gtk_widget_set_state_flags().
	UnsetStateFlags(flags StateFlags)
}

// widget implements the Widget interface.
type widget struct {
	gextras.Objector
	Buildable
}

var _ Widget = (*widget)(nil)

// WrapWidget wraps a GObject to the right type. It is
// primarily used internally.
func WrapWidget(obj *externglib.Object) Widget {
	return Widget{
		Objector:  obj,
		Buildable: WrapBuildable(obj),
	}
}

func marshalWidget(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapWidget(obj), nil
}

// Activate: for widgets that can be “activated” (buttons, menu items, etc.)
// this function activates them. Activation is what happens when you press
// Enter on a widget during key navigation. If @widget isn't activatable,
// the function returns false.
func (w widget) Activate() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.gtk_widget_activate(arg0)

	if cret {
		goret = true
	}

	return goret
}

// AddAccelerator installs an accelerator for this @widget in @accel_group
// that causes @accel_signal to be emitted if the accelerator is activated.
// The @accel_group needs to be added to the widget’s toplevel via
// gtk_window_add_accel_group(), and the signal must be of type
// G_SIGNAL_ACTION. Accelerators added through this function are not user
// changeable during runtime. If you want to support accelerators that can
// be changed by the user, use gtk_accel_map_add_entry() and
// gtk_widget_set_accel_path() or gtk_menu_item_set_accel_path() instead.
func (w widget) AddAccelerator(accelSignal string, accelGroup AccelGroup, accelKey uint, accelMods gdk.ModifierType, accelFlags AccelFlags) {
	var arg0 *C.GtkWidget
	var arg1 *C.gchar
	var arg2 *C.GtkAccelGroup
	var arg3 C.guint
	var arg4 C.GdkModifierType
	var arg5 C.GtkAccelFlags

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (*C.gchar)(C.CString(accelSignal))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GtkAccelGroup)(unsafe.Pointer(accelGroup.Native()))
	arg3 = C.guint(accelKey)
	arg4 = (C.GdkModifierType)(accelMods)
	arg5 = (C.GtkAccelFlags)(accelFlags)

	C.gtk_widget_add_accelerator(arg0, arg1, arg2, arg3, arg4, arg5)
}

// AddDeviceEvents adds the device events in the bitfield @events to the
// event mask for @widget. See gtk_widget_set_device_events() for details.
func (w widget) AddDeviceEvents(device gdk.Device, events gdk.EventMask) {
	var arg0 *C.GtkWidget
	var arg1 *C.GdkDevice
	var arg2 C.GdkEventMask

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (*C.GdkDevice)(unsafe.Pointer(device.Native()))
	arg2 = (C.GdkEventMask)(events)

	C.gtk_widget_add_device_events(arg0, arg1, arg2)
}

// AddEvents adds the events in the bitfield @events to the event mask for
// @widget. See gtk_widget_set_events() and the [input handling
// overview][event-masks] for details.
func (w widget) AddEvents(events int) {
	var arg0 *C.GtkWidget
	var arg1 C.gint

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = C.gint(events)

	C.gtk_widget_add_events(arg0, arg1)
}

// AddMnemonicLabel adds a widget to the list of mnemonic labels for this
// widget. (See gtk_widget_list_mnemonic_labels()). Note the list of
// mnemonic labels for the widget is cleared when the widget is destroyed,
// so the caller must make sure to update its internal state at this point
// as well, by using a connection to the Widget::destroy signal or a weak
// notifier.
func (w widget) AddMnemonicLabel(label Widget) {
	var arg0 *C.GtkWidget
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(label.Native()))

	C.gtk_widget_add_mnemonic_label(arg0, arg1)
}

// AddTickCallback queues an animation frame update and adds a callback to
// be called before each frame. Until the tick callback is removed, it will
// be called frequently (usually at the frame rate of the output device or
// as quickly as the application can be repainted, whichever is slower). For
// this reason, is most suitable for handling graphics that change every
// frame or every few frames. The tick callback does not automatically imply
// a relayout or repaint. If you want a repaint or relayout, and aren’t
// changing widget properties that would trigger that (for example, changing
// the text of a Label), then you will have to call
// gtk_widget_queue_resize() or gtk_widget_queue_draw_area() yourself.
//
// gdk_frame_clock_get_frame_time() should generally be used for timing
// continuous animations and
// gdk_frame_timings_get_predicted_presentation_time() if you are trying to
// display isolated frames at particular times.
//
// This is a more convenient alternative to connecting directly to the
// FrameClock::update signal of FrameClock, since you don't have to worry
// about when a FrameClock is assigned to a widget.
func (w widget) AddTickCallback() uint {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret C.guint
	var goret uint

	cret = C.gtk_widget_add_tick_callback(arg0, arg1, arg2, arg3)

	goret = uint(cret)

	return goret
}

// CanActivateAccel determines whether an accelerator that activates the
// signal identified by @signal_id can currently be activated. This is done
// by emitting the Widget::can-activate-accel signal on @widget; if the
// signal isn’t overridden by a handler or in a derived widget, then the
// default check is that the widget must be sensitive, and the widget and
// all its ancestors mapped.
func (w widget) CanActivateAccel(signalID uint) bool {
	var arg0 *C.GtkWidget
	var arg1 C.guint

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = C.guint(signalID)

	var cret C.gboolean
	var goret bool

	cret = C.gtk_widget_can_activate_accel(arg0, arg1)

	if cret {
		goret = true
	}

	return goret
}

// ChildFocus: this function is used by custom widget implementations; if
// you're writing an app, you’d use gtk_widget_grab_focus() to move the
// focus to a particular widget, and gtk_container_set_focus_chain() to
// change the focus tab order. So you may want to investigate those
// functions instead.
//
// gtk_widget_child_focus() is called by containers as the user moves around
// the window using keyboard shortcuts. @direction indicates what kind of
// motion is taking place (up, down, left, right, tab forward, tab
// backward). gtk_widget_child_focus() emits the Widget::focus signal;
// widgets override the default handler for this signal in order to
// implement appropriate focus behavior.
//
// The default ::focus handler for a widget should return true if moving in
// @direction left the focus on a focusable location inside that widget, and
// false if moving in @direction moved the focus outside the widget. If
// returning true, widgets normally call gtk_widget_grab_focus() to place
// the focus accordingly; if returning false, they don’t modify the current
// focus location.
func (w widget) ChildFocus(direction DirectionType) bool {
	var arg0 *C.GtkWidget
	var arg1 C.GtkDirectionType

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (C.GtkDirectionType)(direction)

	var cret C.gboolean
	var goret bool

	cret = C.gtk_widget_child_focus(arg0, arg1)

	if cret {
		goret = true
	}

	return goret
}

// ChildNotify emits a Widget::child-notify signal for the [child
// property][child-properties] @child_property on @widget.
//
// This is the analogue of g_object_notify() for child properties.
//
// Also see gtk_container_child_notify().
func (w widget) ChildNotify(childProperty string) {
	var arg0 *C.GtkWidget
	var arg1 *C.gchar

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (*C.gchar)(C.CString(childProperty))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_widget_child_notify(arg0, arg1)
}

// ClassPath: same as gtk_widget_path(), but always uses the name of a
// widget’s type, never uses a custom name set with gtk_widget_set_name().
func (w widget) ClassPath() (pathLength uint, path string, pathReversed string) {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	arg1 := new(C.guint)
	var ret1 uint
	arg2 := new(*C.gchar)
	var ret2 string
	arg3 := new(*C.gchar)
	var ret3 string

	C.gtk_widget_class_path(arg0, arg1, arg2, arg3)

	ret1 = uint(*arg1)
	ret2 = C.GoString(*arg2)
	defer C.free(unsafe.Pointer(*arg2))
	ret3 = C.GoString(*arg3)
	defer C.free(unsafe.Pointer(*arg3))

	return ret1, ret2, ret3
}

// ComputeExpand computes whether a container should give this widget extra
// space when possible. Containers should check this, rather than looking at
// gtk_widget_get_hexpand() or gtk_widget_get_vexpand().
//
// This function already checks whether the widget is visible, so visibility
// does not need to be checked separately. Non-visible widgets are not
// expanded.
//
// The computed expand value uses either the expand setting explicitly set
// on the widget itself, or, if none has been explicitly set, the widget may
// expand if some of its children do.
func (w widget) ComputeExpand(orientation Orientation) bool {
	var arg0 *C.GtkWidget
	var arg1 C.GtkOrientation

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (C.GtkOrientation)(orientation)

	var cret C.gboolean
	var goret bool

	cret = C.gtk_widget_compute_expand(arg0, arg1)

	if cret {
		goret = true
	}

	return goret
}

// CreatePangoContext creates a new Context with the appropriate font map,
// font options, font description, and base direction for drawing text for
// this widget. See also gtk_widget_get_pango_context().
func (w widget) CreatePangoContext() pango.Context {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	cret := new(C.PangoContext)
	var goret pango.Context

	cret = C.gtk_widget_create_pango_context(arg0)

	goret = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(pango.Context)

	return goret
}

// CreatePangoLayout creates a new Layout with the appropriate font map,
// font description, and base direction for drawing text for this widget.
//
// If you keep a Layout created in this way around, you need to re-create it
// when the widget Context is replaced. This can be tracked by using the
// Widget::screen-changed signal on the widget.
func (w widget) CreatePangoLayout(text string) pango.Layout {
	var arg0 *C.GtkWidget
	var arg1 *C.gchar

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(arg1))

	cret := new(C.PangoLayout)
	var goret pango.Layout

	cret = C.gtk_widget_create_pango_layout(arg0, arg1)

	goret = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(pango.Layout)

	return goret
}

// Destroy destroys a widget.
//
// When a widget is destroyed all references it holds on other objects will
// be released:
//
//    - if the widget is inside a container, it will be removed from its
//    parent
//    - if the widget is a container, all its children will be destroyed,
//    recursively
//    - if the widget is a top level, it will be removed from the list
//    of top level widgets that GTK+ maintains internally
//
// It's expected that all references held on the widget will also be
// released; you should connect to the Widget::destroy signal if you hold a
// reference to @widget and you wish to remove it when this function is
// called. It is not necessary to do so if you are implementing a Container,
// as you'll be able to use the ContainerClass.remove() virtual function for
// that.
//
// It's important to notice that gtk_widget_destroy() will only cause the
// @widget to be finalized if no additional references, acquired using
// g_object_ref(), are held on it. In case additional references are in
// place, the @widget will be in an "inert" state after calling this
// function; @widget will still point to valid memory, allowing you to
// release the references you hold, but you may not query the widget's own
// state.
//
// You should typically call this function on top level widgets, and rarely
// on child widgets.
//
// See also: gtk_container_remove()
func (w widget) Destroy() {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_destroy(arg0)
}

// Destroyed: this function sets *@widget_pointer to nil if @widget_pointer
// != nil. It’s intended to be used as a callback connected to the “destroy”
// signal of a widget. You connect gtk_widget_destroyed() as a signal
// handler, and pass the address of your widget variable as user data. Then
// when the widget is destroyed, the variable will be set to nil. Useful for
// example to avoid multiple copies of the same dialog.
func (w widget) Destroyed(widgetPointer Widget) {
	var arg0 *C.GtkWidget
	var arg1 **C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (**C.GtkWidget)(unsafe.Pointer(widgetPointer.Native()))

	C.gtk_widget_destroyed(arg0, arg1)
}

// DeviceIsShadowed returns true if @device has been shadowed by a GTK+
// device grab on another widget, so it would stop sending events to
// @widget. This may be used in the Widget::grab-notify signal to check for
// specific devices. See gtk_device_grab_add().
func (w widget) DeviceIsShadowed(device gdk.Device) bool {
	var arg0 *C.GtkWidget
	var arg1 *C.GdkDevice

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (*C.GdkDevice)(unsafe.Pointer(device.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.gtk_widget_device_is_shadowed(arg0, arg1)

	if cret {
		goret = true
	}

	return goret
}

// DragBegin: this function is equivalent to
// gtk_drag_begin_with_coordinates(), passing -1, -1 as coordinates.
func (w widget) DragBegin(targets *TargetList, actions gdk.DragAction, button int, event *gdk.Event) gdk.DragContext {
	var arg0 *C.GtkWidget
	var arg1 *C.GtkTargetList
	var arg2 C.GdkDragAction
	var arg3 C.gint
	var arg4 *C.GdkEvent

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (*C.GtkTargetList)(unsafe.Pointer(targets.Native()))
	arg2 = (C.GdkDragAction)(actions)
	arg3 = C.gint(button)
	var arg4 *C.GdkEvent // unsupported

	var cret *C.GdkDragContext
	var goret gdk.DragContext

	cret = C.gtk_drag_begin(arg0, arg1, arg2, arg3, arg4)

	goret = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(gdk.DragContext)

	return goret
}

// DragBeginWithCoordinates initiates a drag on the source side. The
// function only needs to be used when the application is starting drags
// itself, and is not needed when gtk_drag_source_set() is used.
//
// The @event is used to retrieve the timestamp that will be used internally
// to grab the pointer. If @event is nil, then GDK_CURRENT_TIME will be
// used. However, you should try to pass a real event in all cases, since
// that can be used to get information about the drag.
//
// Generally there are three cases when you want to start a drag by hand by
// calling this function:
//
// 1. During a Widget::button-press-event handler, if you want to start a
// drag immediately when the user presses the mouse button. Pass the @event
// that you have in your Widget::button-press-event handler.
//
// 2. During a Widget::motion-notify-event handler, if you want to start a
// drag when the mouse moves past a certain threshold distance after a
// button-press. Pass the @event that you have in your
// Widget::motion-notify-event handler.
//
// 3. During a timeout handler, if you want to start a drag after the mouse
// button is held down for some time. Try to save the last event that you
// got from the mouse, using gdk_event_copy(), and pass it to this function
// (remember to free the event with gdk_event_free() when you are done). If
// you really cannot pass a real event, pass nil instead.
func (w widget) DragBeginWithCoordinates(targets *TargetList, actions gdk.DragAction, button int, event *gdk.Event, x int, y int) gdk.DragContext {
	var arg0 *C.GtkWidget
	var arg1 *C.GtkTargetList
	var arg2 C.GdkDragAction
	var arg3 C.gint
	var arg4 *C.GdkEvent
	var arg5 C.gint
	var arg6 C.gint

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (*C.GtkTargetList)(unsafe.Pointer(targets.Native()))
	arg2 = (C.GdkDragAction)(actions)
	arg3 = C.gint(button)
	var arg4 *C.GdkEvent // unsupported
	arg5 = C.gint(x)
	arg6 = C.gint(y)

	var cret *C.GdkDragContext
	var goret gdk.DragContext

	cret = C.gtk_drag_begin_with_coordinates(arg0, arg1, arg2, arg3, arg4, arg5, arg6)

	goret = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(gdk.DragContext)

	return goret
}

// DragCheckThreshold checks to see if a mouse drag starting at (@start_x,
// @start_y) and ending at (@current_x, @current_y) has passed the GTK+ drag
// threshold, and thus should trigger the beginning of a drag-and-drop
// operation.
func (w widget) DragCheckThreshold(startX int, startY int, currentX int, currentY int) bool {
	var arg0 *C.GtkWidget
	var arg1 C.gint
	var arg2 C.gint
	var arg3 C.gint
	var arg4 C.gint

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = C.gint(startX)
	arg2 = C.gint(startY)
	arg3 = C.gint(currentX)
	arg4 = C.gint(currentY)

	var cret C.gboolean
	var goret bool

	cret = C.gtk_drag_check_threshold(arg0, arg1, arg2, arg3, arg4)

	if cret {
		goret = true
	}

	return goret
}

// DragDestAddImageTargets: add the image targets supported by SelectionData
// to the target list of the drag destination. The targets are added with
// @info = 0. If you need another value, use
// gtk_target_list_add_image_targets() and gtk_drag_dest_set_target_list().
func (w widget) DragDestAddImageTargets() {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_drag_dest_add_image_targets(arg0)
}

// DragDestAddTextTargets: add the text targets supported by SelectionData
// to the target list of the drag destination. The targets are added with
// @info = 0. If you need another value, use
// gtk_target_list_add_text_targets() and gtk_drag_dest_set_target_list().
func (w widget) DragDestAddTextTargets() {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_drag_dest_add_text_targets(arg0)
}

// DragDestAddURITargets: add the URI targets supported by SelectionData to
// the target list of the drag destination. The targets are added with @info
// = 0. If you need another value, use gtk_target_list_add_uri_targets() and
// gtk_drag_dest_set_target_list().
func (w widget) DragDestAddURITargets() {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_drag_dest_add_uri_targets(arg0)
}

// DragDestFindTarget looks for a match between the supported targets of
// @context and the @dest_target_list, returning the first matching target,
// otherwise returning GDK_NONE. @dest_target_list should usually be the
// return value from gtk_drag_dest_get_target_list(), but some widgets may
// have different valid targets for different parts of the widget; in that
// case, they will have to implement a drag_motion handler that passes the
// correct target list to this function.
func (w widget) DragDestFindTarget(context gdk.DragContext, targetList *TargetList) gdk.Atom {
	var arg0 *C.GtkWidget
	var arg1 *C.GdkDragContext
	var arg2 *C.GtkTargetList

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (*C.GdkDragContext)(unsafe.Pointer(context.Native()))
	arg2 = (*C.GtkTargetList)(unsafe.Pointer(targetList.Native()))

	var cret C.GdkAtom
	var goret gdk.Atom

	cret = C.gtk_drag_dest_find_target(arg0, arg1, arg2)

	goret = *gdk.WrapAtom(unsafe.Pointer(&cret))

	return goret
}

// DragDestGetTargetList returns the list of targets this widget can accept
// from drag-and-drop.
func (w widget) DragDestGetTargetList() *TargetList {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret *C.GtkTargetList
	var goret *TargetList

	cret = C.gtk_drag_dest_get_target_list(arg0)

	goret = WrapTargetList(unsafe.Pointer(cret))

	return goret
}

// DragDestGetTrackMotion returns whether the widget has been configured to
// always emit Widget::drag-motion signals.
func (w widget) DragDestGetTrackMotion() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.gtk_drag_dest_get_track_motion(arg0)

	if cret {
		goret = true
	}

	return goret
}

// DragDestSetProxy sets this widget as a proxy for drops to another window.
func (w widget) DragDestSetProxy(proxyWindow gdk.Window, protocol gdk.DragProtocol, useCoordinates bool) {
	var arg0 *C.GtkWidget
	var arg1 *C.GdkWindow
	var arg2 C.GdkDragProtocol
	var arg3 C.gboolean

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (*C.GdkWindow)(unsafe.Pointer(proxyWindow.Native()))
	arg2 = (C.GdkDragProtocol)(protocol)
	if useCoordinates {
		arg3 = C.gboolean(1)
	}

	C.gtk_drag_dest_set_proxy(arg0, arg1, arg2, arg3)
}

// DragDestSetTargetList sets the target types that this widget can accept
// from drag-and-drop. The widget must first be made into a drag destination
// with gtk_drag_dest_set().
func (w widget) DragDestSetTargetList(targetList *TargetList) {
	var arg0 *C.GtkWidget
	var arg1 *C.GtkTargetList

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (*C.GtkTargetList)(unsafe.Pointer(targetList.Native()))

	C.gtk_drag_dest_set_target_list(arg0, arg1)
}

// DragDestSetTrackMotion tells the widget to emit Widget::drag-motion and
// Widget::drag-leave events regardless of the targets and the
// GTK_DEST_DEFAULT_MOTION flag.
//
// This may be used when a widget wants to do generic actions regardless of
// the targets that the source offers.
func (w widget) DragDestSetTrackMotion(trackMotion bool) {
	var arg0 *C.GtkWidget
	var arg1 C.gboolean

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	if trackMotion {
		arg1 = C.gboolean(1)
	}

	C.gtk_drag_dest_set_track_motion(arg0, arg1)
}

// DragDestUnset clears information about a drop destination set with
// gtk_drag_dest_set(). The widget will no longer receive notification of
// drags.
func (w widget) DragDestUnset() {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_drag_dest_unset(arg0)
}

// DragGetData gets the data associated with a drag. When the data is
// received or the retrieval fails, GTK+ will emit a
// Widget::drag-data-received signal. Failure of the retrieval is indicated
// by the length field of the @selection_data signal parameter being
// negative. However, when gtk_drag_get_data() is called implicitely because
// the GTK_DEST_DEFAULT_DROP was set, then the widget will not receive
// notification of failed drops.
func (w widget) DragGetData(context gdk.DragContext, target gdk.Atom, time_ uint32) {
	var arg0 *C.GtkWidget
	var arg1 *C.GdkDragContext
	var arg2 C.GdkAtom
	var arg3 C.guint32

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (*C.GdkDragContext)(unsafe.Pointer(context.Native()))
	arg2 = (C.GdkAtom)(unsafe.Pointer(target.Native()))
	arg3 = C.guint32(time_)

	C.gtk_drag_get_data(arg0, arg1, arg2, arg3)
}

// DragHighlight highlights a widget as a currently hovered drop target. To
// end the highlight, call gtk_drag_unhighlight(). GTK+ calls this
// automatically if GTK_DEST_DEFAULT_HIGHLIGHT is set.
func (w widget) DragHighlight() {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_drag_highlight(arg0)
}

// DragSourceAddImageTargets: add the writable image targets supported by
// SelectionData to the target list of the drag source. The targets are
// added with @info = 0. If you need another value, use
// gtk_target_list_add_image_targets() and
// gtk_drag_source_set_target_list().
func (w widget) DragSourceAddImageTargets() {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_drag_source_add_image_targets(arg0)
}

// DragSourceAddTextTargets: add the text targets supported by SelectionData
// to the target list of the drag source. The targets are added with @info =
// 0. If you need another value, use gtk_target_list_add_text_targets() and
// gtk_drag_source_set_target_list().
func (w widget) DragSourceAddTextTargets() {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_drag_source_add_text_targets(arg0)
}

// DragSourceAddURITargets: add the URI targets supported by SelectionData
// to the target list of the drag source. The targets are added with @info =
// 0. If you need another value, use gtk_target_list_add_uri_targets() and
// gtk_drag_source_set_target_list().
func (w widget) DragSourceAddURITargets() {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_drag_source_add_uri_targets(arg0)
}

// DragSourceGetTargetList gets the list of targets this widget can provide
// for drag-and-drop.
func (w widget) DragSourceGetTargetList() *TargetList {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret *C.GtkTargetList
	var goret *TargetList

	cret = C.gtk_drag_source_get_target_list(arg0)

	goret = WrapTargetList(unsafe.Pointer(cret))

	return goret
}

// DragSourceSetIconGIcon sets the icon that will be used for drags from a
// particular source to @icon. See the docs for IconTheme for more details.
func (w widget) DragSourceSetIconGIcon(icon gio.Icon) {
	var arg0 *C.GtkWidget
	var arg1 *C.GIcon

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (*C.GIcon)(unsafe.Pointer(icon.Native()))

	C.gtk_drag_source_set_icon_gicon(arg0, arg1)
}

// DragSourceSetIconName sets the icon that will be used for drags from a
// particular source to a themed icon. See the docs for IconTheme for more
// details.
func (w widget) DragSourceSetIconName(iconName string) {
	var arg0 *C.GtkWidget
	var arg1 *C.gchar

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (*C.gchar)(C.CString(iconName))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_drag_source_set_icon_name(arg0, arg1)
}

// DragSourceSetIconPixbuf sets the icon that will be used for drags from a
// particular widget from a Pixbuf. GTK+ retains a reference for @pixbuf and
// will release it when it is no longer needed.
func (w widget) DragSourceSetIconPixbuf(pixbuf gdkpixbuf.Pixbuf) {
	var arg0 *C.GtkWidget
	var arg1 *C.GdkPixbuf

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))

	C.gtk_drag_source_set_icon_pixbuf(arg0, arg1)
}

// DragSourceSetIconStock sets the icon that will be used for drags from a
// particular source to a stock icon.
func (w widget) DragSourceSetIconStock(stockID string) {
	var arg0 *C.GtkWidget
	var arg1 *C.gchar

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (*C.gchar)(C.CString(stockID))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_drag_source_set_icon_stock(arg0, arg1)
}

// DragSourceSetTargetList changes the target types that this widget offers
// for drag-and-drop. The widget must first be made into a drag source with
// gtk_drag_source_set().
func (w widget) DragSourceSetTargetList(targetList *TargetList) {
	var arg0 *C.GtkWidget
	var arg1 *C.GtkTargetList

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (*C.GtkTargetList)(unsafe.Pointer(targetList.Native()))

	C.gtk_drag_source_set_target_list(arg0, arg1)
}

// DragSourceUnset undoes the effects of gtk_drag_source_set().
func (w widget) DragSourceUnset() {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_drag_source_unset(arg0)
}

// DragUnhighlight removes a highlight set by gtk_drag_highlight() from a
// widget.
func (w widget) DragUnhighlight() {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_drag_unhighlight(arg0)
}

// Draw draws @widget to @cr. The top left corner of the widget will be
// drawn to the currently set origin point of @cr.
//
// You should pass a cairo context as @cr argument that is in an original
// state. Otherwise the resulting drawing is undefined. For example changing
// the operator using cairo_set_operator() or the line width using
// cairo_set_line_width() might have unwanted side effects. You may however
// change the context’s transform matrix - like with cairo_scale(),
// cairo_translate() or cairo_set_matrix() and clip region with cairo_clip()
// prior to calling this function. Also, it is fine to modify the context
// with cairo_save() and cairo_push_group() prior to calling this function.
//
// Note that special-purpose widgets may contain special code for rendering
// to the screen and might appear differently on screen and when rendered
// using gtk_widget_draw().
func (w widget) Draw(cr *cairo.Context) {
	var arg0 *C.GtkWidget
	var arg1 *C.cairo_t

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))

	C.gtk_widget_draw(arg0, arg1)
}

// EnsureStyle ensures that @widget has a style (@widget->style).
//
// Not a very useful function; most of the time, if you want the style, the
// widget is realized, and realized widgets are guaranteed to have a style
// already.
func (w widget) EnsureStyle() {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_ensure_style(arg0)
}

// ErrorBell notifies the user about an input-related error on this widget.
// If the Settings:gtk-error-bell setting is true, it calls
// gdk_window_beep(), otherwise it does nothing.
//
// Note that the effect of gdk_window_beep() can be configured in many ways,
// depending on the windowing backend and the desktop environment or window
// manager that is used.
func (w widget) ErrorBell() {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_error_bell(arg0)
}

// FreezeChildNotify stops emission of Widget::child-notify signals on
// @widget. The signals are queued until gtk_widget_thaw_child_notify() is
// called on @widget.
//
// This is the analogue of g_object_freeze_notify() for child properties.
func (w widget) FreezeChildNotify() {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_freeze_child_notify(arg0)
}

// ActionGroup retrieves the Group that was registered using @prefix. The
// resulting Group may have been registered to @widget or any Widget in its
// ancestry.
//
// If no action group was found matching @prefix, then nil is returned.
func (w widget) ActionGroup(prefix string) gio.ActionGroup {
	var arg0 *C.GtkWidget
	var arg1 *C.gchar

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (*C.gchar)(C.CString(prefix))
	defer C.free(unsafe.Pointer(arg1))

	var cret *C.GActionGroup
	var goret gio.ActionGroup

	cret = C.gtk_widget_get_action_group(arg0, arg1)

	goret = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(gio.ActionGroup)

	return goret
}

// AllocatedBaseline returns the baseline that has currently been allocated
// to @widget. This function is intended to be used when implementing
// handlers for the Widget::draw function, and when allocating child widgets
// in Widget::size_allocate.
func (w widget) AllocatedBaseline() int {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret C.int
	var goret int

	cret = C.gtk_widget_get_allocated_baseline(arg0)

	goret = int(cret)

	return goret
}

// AllocatedHeight returns the height that has currently been allocated to
// @widget. This function is intended to be used when implementing handlers
// for the Widget::draw function.
func (w widget) AllocatedHeight() int {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret C.int
	var goret int

	cret = C.gtk_widget_get_allocated_height(arg0)

	goret = int(cret)

	return goret
}

// AllocatedWidth returns the width that has currently been allocated to
// @widget. This function is intended to be used when implementing handlers
// for the Widget::draw function.
func (w widget) AllocatedWidth() int {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret C.int
	var goret int

	cret = C.gtk_widget_get_allocated_width(arg0)

	goret = int(cret)

	return goret
}

// Ancestor gets the first ancestor of @widget with type @widget_type. For
// example, `gtk_widget_get_ancestor (widget, GTK_TYPE_BOX)` gets the first
// Box that’s an ancestor of @widget. No reference will be added to the
// returned widget; it should not be unreferenced. See note about checking
// for a toplevel Window in the docs for gtk_widget_get_toplevel().
//
// Note that unlike gtk_widget_is_ancestor(), gtk_widget_get_ancestor()
// considers @widget to be an ancestor of itself.
func (w widget) Ancestor(widgetType externglib.Type) Widget {
	var arg0 *C.GtkWidget
	var arg1 C.GType

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = C.GType(widgetType)

	var cret *C.GtkWidget
	var goret Widget

	cret = C.gtk_widget_get_ancestor(arg0, arg1)

	goret = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Widget)

	return goret
}

// AppPaintable determines whether the application intends to draw on the
// widget in an Widget::draw handler.
//
// See gtk_widget_set_app_paintable()
func (w widget) AppPaintable() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.gtk_widget_get_app_paintable(arg0)

	if cret {
		goret = true
	}

	return goret
}

// CanDefault determines whether @widget can be a default widget. See
// gtk_widget_set_can_default().
func (w widget) CanDefault() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.gtk_widget_get_can_default(arg0)

	if cret {
		goret = true
	}

	return goret
}

// CanFocus determines whether @widget can own the input focus. See
// gtk_widget_set_can_focus().
func (w widget) CanFocus() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.gtk_widget_get_can_focus(arg0)

	if cret {
		goret = true
	}

	return goret
}

// ChildRequisition: this function is only for use in widget
// implementations. Obtains @widget->requisition, unless someone has forced
// a particular geometry on the widget (e.g. with
// gtk_widget_set_size_request()), in which case it returns that geometry
// instead of the widget's requisition.
//
// This function differs from gtk_widget_size_request() in that it retrieves
// the last size request value from @widget->requisition, while
// gtk_widget_size_request() actually calls the "size_request" method on
// @widget to compute the size request and fill in @widget->requisition, and
// only then returns @widget->requisition.
//
// Because this function does not call the “size_request” method, it can
// only be used when you know that @widget->requisition is up-to-date, that
// is, gtk_widget_size_request() has been called since the last time a
// resize was queued. In general, only container implementations have this
// information; applications should use gtk_widget_size_request().
func (w widget) ChildRequisition() *Requisition {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	arg1 := new(C.GtkRequisition)
	var ret1 *Requisition

	C.gtk_widget_get_child_requisition(arg0, arg1)

	ret1 = WrapRequisition(unsafe.Pointer(arg1))

	return ret1
}

// ChildVisible gets the value set with gtk_widget_set_child_visible(). If
// you feel a need to use this function, your code probably needs
// reorganization.
//
// This function is only useful for container implementations and never
// should be called by an application.
func (w widget) ChildVisible() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.gtk_widget_get_child_visible(arg0)

	if cret {
		goret = true
	}

	return goret
}

// Clipboard returns the clipboard object for the given selection to be used
// with @widget. @widget must have a Display associated with it, so must be
// attached to a toplevel window.
func (w widget) Clipboard(selection gdk.Atom) Clipboard {
	var arg0 *C.GtkWidget
	var arg1 C.GdkAtom

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (C.GdkAtom)(unsafe.Pointer(selection.Native()))

	var cret *C.GtkClipboard
	var goret Clipboard

	cret = C.gtk_widget_get_clipboard(arg0, arg1)

	goret = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Clipboard)

	return goret
}

// CompositeName obtains the composite name of a widget.
func (w widget) CompositeName() string {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	cret := new(C.gchar)
	var goret string

	cret = C.gtk_widget_get_composite_name(arg0)

	goret = C.GoString(cret)
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// DeviceEnabled returns whether @device can interact with @widget and its
// children. See gtk_widget_set_device_enabled().
func (w widget) DeviceEnabled(device gdk.Device) bool {
	var arg0 *C.GtkWidget
	var arg1 *C.GdkDevice

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (*C.GdkDevice)(unsafe.Pointer(device.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.gtk_widget_get_device_enabled(arg0, arg1)

	if cret {
		goret = true
	}

	return goret
}

// DeviceEvents returns the events mask for the widget corresponding to an
// specific device. These are the events that the widget will receive when
// @device operates on it.
func (w widget) DeviceEvents(device gdk.Device) gdk.EventMask {
	var arg0 *C.GtkWidget
	var arg1 *C.GdkDevice

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (*C.GdkDevice)(unsafe.Pointer(device.Native()))

	var cret C.GdkEventMask
	var goret gdk.EventMask

	cret = C.gtk_widget_get_device_events(arg0, arg1)

	goret = gdk.EventMask(cret)

	return goret
}

// Direction gets the reading direction for a particular widget. See
// gtk_widget_set_direction().
func (w widget) Direction() TextDirection {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret C.GtkTextDirection
	var goret TextDirection

	cret = C.gtk_widget_get_direction(arg0)

	goret = TextDirection(cret)

	return goret
}

// Display: get the Display for the toplevel window associated with this
// widget. This function can only be called after the widget has been added
// to a widget hierarchy with a Window at the top.
//
// In general, you should only create display specific resources when a
// widget has been realized, and you should free those resources when the
// widget is unrealized.
func (w widget) Display() gdk.Display {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret *C.GdkDisplay
	var goret gdk.Display

	cret = C.gtk_widget_get_display(arg0)

	goret = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(gdk.Display)

	return goret
}

// DoubleBuffered determines whether the widget is double buffered.
//
// See gtk_widget_set_double_buffered()
func (w widget) DoubleBuffered() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.gtk_widget_get_double_buffered(arg0)

	if cret {
		goret = true
	}

	return goret
}

// Events returns the event mask (see EventMask) for the widget. These are
// the events that the widget will receive.
//
// Note: Internally, the widget event mask will be the logical OR of the
// event mask set through gtk_widget_set_events() or
// gtk_widget_add_events(), and the event mask necessary to cater for every
// EventController created for the widget.
func (w widget) Events() int {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret C.gint
	var goret int

	cret = C.gtk_widget_get_events(arg0)

	goret = int(cret)

	return goret
}

// FocusOnClick returns whether the widget should grab focus when it is
// clicked with the mouse. See gtk_widget_set_focus_on_click().
func (w widget) FocusOnClick() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.gtk_widget_get_focus_on_click(arg0)

	if cret {
		goret = true
	}

	return goret
}

// FontMap gets the font map that has been set with
// gtk_widget_set_font_map().
func (w widget) FontMap() pango.FontMap {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret *C.PangoFontMap
	var goret pango.FontMap

	cret = C.gtk_widget_get_font_map(arg0)

	goret = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(pango.FontMap)

	return goret
}

// FontOptions returns the #cairo_font_options_t used for Pango rendering.
// When not set, the defaults font options for the Screen will be used.
func (w widget) FontOptions() *cairo.FontOptions {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret *C.cairo_font_options_t
	var goret *cairo.FontOptions

	cret = C.gtk_widget_get_font_options(arg0)

	goret = cairo.WrapFontOptions(unsafe.Pointer(cret))

	return goret
}

// FrameClock obtains the frame clock for a widget. The frame clock is a
// global “ticker” that can be used to drive animations and repaints. The
// most common reason to get the frame clock is to call
// gdk_frame_clock_get_frame_time(), in order to get a time to use for
// animating. For example you might record the start of the animation with
// an initial value from gdk_frame_clock_get_frame_time(), and then update
// the animation by calling gdk_frame_clock_get_frame_time() again during
// each repaint.
//
// gdk_frame_clock_request_phase() will result in a new frame on the clock,
// but won’t necessarily repaint any widgets. To repaint a widget, you have
// to use gtk_widget_queue_draw() which invalidates the widget (thus
// scheduling it to receive a draw on the next frame).
// gtk_widget_queue_draw() will also end up requesting a frame on the
// appropriate frame clock.
//
// A widget’s frame clock will not change while the widget is mapped.
// Reparenting a widget (which implies a temporary unmap) can change the
// widget’s frame clock.
//
// Unrealized widgets do not have a frame clock.
func (w widget) FrameClock() gdk.FrameClock {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret *C.GdkFrameClock
	var goret gdk.FrameClock

	cret = C.gtk_widget_get_frame_clock(arg0)

	goret = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(gdk.FrameClock)

	return goret
}

// Halign gets the value of the Widget:halign property.
//
// For backwards compatibility reasons this method will never return
// GTK_ALIGN_BASELINE, but instead it will convert it to GTK_ALIGN_FILL.
// Baselines are not supported for horizontal alignment.
func (w widget) Halign() Align {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret C.GtkAlign
	var goret Align

	cret = C.gtk_widget_get_halign(arg0)

	goret = Align(cret)

	return goret
}

// HasTooltip returns the current value of the has-tooltip property. See
// Widget:has-tooltip for more information.
func (w widget) HasTooltip() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.gtk_widget_get_has_tooltip(arg0)

	if cret {
		goret = true
	}

	return goret
}

// HasWindow determines whether @widget has a Window of its own. See
// gtk_widget_set_has_window().
func (w widget) HasWindow() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.gtk_widget_get_has_window(arg0)

	if cret {
		goret = true
	}

	return goret
}

// Hexpand gets whether the widget would like any available extra horizontal
// space. When a user resizes a Window, widgets with expand=TRUE generally
// receive the extra space. For example, a list or scrollable area or
// document in your window would often be set to expand.
//
// Containers should use gtk_widget_compute_expand() rather than this
// function, to see whether a widget, or any of its children, has the expand
// flag set. If any child of a widget wants to expand, the parent may ask to
// expand also.
//
// This function only looks at the widget’s own hexpand flag, rather than
// computing whether the entire widget tree rooted at this widget wants to
// expand.
func (w widget) Hexpand() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.gtk_widget_get_hexpand(arg0)

	if cret {
		goret = true
	}

	return goret
}

// HexpandSet gets whether gtk_widget_set_hexpand() has been used to
// explicitly set the expand flag on this widget.
//
// If hexpand is set, then it overrides any computed expand value based on
// child widgets. If hexpand is not set, then the expand value depends on
// whether any children of the widget would like to expand.
//
// There are few reasons to use this function, but it’s here for
// completeness and consistency.
func (w widget) HexpandSet() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.gtk_widget_get_hexpand_set(arg0)

	if cret {
		goret = true
	}

	return goret
}

// Mapped: whether the widget is mapped.
func (w widget) Mapped() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.gtk_widget_get_mapped(arg0)

	if cret {
		goret = true
	}

	return goret
}

// MarginBottom gets the value of the Widget:margin-bottom property.
func (w widget) MarginBottom() int {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret C.gint
	var goret int

	cret = C.gtk_widget_get_margin_bottom(arg0)

	goret = int(cret)

	return goret
}

// MarginEnd gets the value of the Widget:margin-end property.
func (w widget) MarginEnd() int {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret C.gint
	var goret int

	cret = C.gtk_widget_get_margin_end(arg0)

	goret = int(cret)

	return goret
}

// MarginLeft gets the value of the Widget:margin-left property.
func (w widget) MarginLeft() int {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret C.gint
	var goret int

	cret = C.gtk_widget_get_margin_left(arg0)

	goret = int(cret)

	return goret
}

// MarginRight gets the value of the Widget:margin-right property.
func (w widget) MarginRight() int {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret C.gint
	var goret int

	cret = C.gtk_widget_get_margin_right(arg0)

	goret = int(cret)

	return goret
}

// MarginStart gets the value of the Widget:margin-start property.
func (w widget) MarginStart() int {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret C.gint
	var goret int

	cret = C.gtk_widget_get_margin_start(arg0)

	goret = int(cret)

	return goret
}

// MarginTop gets the value of the Widget:margin-top property.
func (w widget) MarginTop() int {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret C.gint
	var goret int

	cret = C.gtk_widget_get_margin_top(arg0)

	goret = int(cret)

	return goret
}

// ModifierMask returns the modifier mask the @widget’s windowing system
// backend uses for a particular purpose.
//
// See gdk_keymap_get_modifier_mask().
func (w widget) ModifierMask(intent gdk.ModifierIntent) gdk.ModifierType {
	var arg0 *C.GtkWidget
	var arg1 C.GdkModifierIntent

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (C.GdkModifierIntent)(intent)

	var cret C.GdkModifierType
	var goret gdk.ModifierType

	cret = C.gtk_widget_get_modifier_mask(arg0, arg1)

	goret = gdk.ModifierType(cret)

	return goret
}

// ModifierStyle returns the current modifier style for the widget. (As set
// by gtk_widget_modify_style().) If no style has previously set, a new
// RcStyle will be created with all values unset, and set as the modifier
// style for the widget. If you make changes to this rc style, you must call
// gtk_widget_modify_style(), passing in the returned rc style, to make sure
// that your changes take effect.
//
// Caution: passing the style back to gtk_widget_modify_style() will
// normally end up destroying it, because gtk_widget_modify_style() copies
// the passed-in style and sets the copy as the new modifier style, thus
// dropping any reference to the old modifier style. Add a reference to the
// modifier style if you want to keep it alive.
func (w widget) ModifierStyle() RCStyle {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret *C.GtkRcStyle
	var goret RCStyle

	cret = C.gtk_widget_get_modifier_style(arg0)

	goret = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(RCStyle)

	return goret
}

// Name retrieves the name of a widget. See gtk_widget_set_name() for the
// significance of widget names.
func (w widget) Name() string {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret *C.gchar
	var goret string

	cret = C.gtk_widget_get_name(arg0)

	goret = C.GoString(cret)

	return goret
}

// NoShowAll returns the current value of the Widget:no-show-all property,
// which determines whether calls to gtk_widget_show_all() will affect this
// widget.
func (w widget) NoShowAll() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.gtk_widget_get_no_show_all(arg0)

	if cret {
		goret = true
	}

	return goret
}

// Opacity fetches the requested opacity for this widget. See
// gtk_widget_set_opacity().
func (w widget) Opacity() float64 {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret C.double
	var goret float64

	cret = C.gtk_widget_get_opacity(arg0)

	goret = float64(cret)

	return goret
}

// PangoContext gets a Context with the appropriate font map, font
// description, and base direction for this widget. Unlike the context
// returned by gtk_widget_create_pango_context(), this context is owned by
// the widget (it can be used until the screen for the widget changes or the
// widget is removed from its toplevel), and will be updated to match any
// changes to the widget’s attributes. This can be tracked by using the
// Widget::screen-changed signal on the widget.
func (w widget) PangoContext() pango.Context {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret *C.PangoContext
	var goret pango.Context

	cret = C.gtk_widget_get_pango_context(arg0)

	goret = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(pango.Context)

	return goret
}

// Parent returns the parent container of @widget.
func (w widget) Parent() Widget {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret *C.GtkWidget
	var goret Widget

	cret = C.gtk_widget_get_parent(arg0)

	goret = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Widget)

	return goret
}

// ParentWindow gets @widget’s parent window, or nil if it does not have
// one.
func (w widget) ParentWindow() gdk.Window {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret *C.GdkWindow
	var goret gdk.Window

	cret = C.gtk_widget_get_parent_window(arg0)

	goret = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(gdk.Window)

	return goret
}

// GetPath returns the WidgetPath representing @widget, if the widget is not
// connected to a toplevel widget, a partial path will be created.
func (w widget) GetPath() *WidgetPath {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret *C.GtkWidgetPath
	var goret *WidgetPath

	cret = C.gtk_widget_get_path(arg0)

	goret = WrapWidgetPath(unsafe.Pointer(cret))

	return goret
}

// Pointer obtains the location of the mouse pointer in widget coordinates.
// Widget coordinates are a bit odd; for historical reasons, they are
// defined as @widget->window coordinates for widgets that return true for
// gtk_widget_get_has_window(); and are relative to @widget->allocation.x,
// @widget->allocation.y otherwise.
func (w widget) Pointer() (x int, y int) {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	arg1 := new(C.gint)
	var ret1 int
	arg2 := new(C.gint)
	var ret2 int

	C.gtk_widget_get_pointer(arg0, arg1, arg2)

	ret1 = int(*arg1)
	ret2 = int(*arg2)

	return ret1, ret2
}

// PreferredHeight retrieves a widget’s initial minimum and natural height.
//
// This call is specific to width-for-height requests.
//
// The returned request will be modified by the
// GtkWidgetClass::adjust_size_request virtual method and by any SizeGroups
// that have been applied. That is, the returned request is the one that
// should be used for layout, not necessarily the one returned by the widget
// itself.
func (w widget) PreferredHeight() (minimumHeight int, naturalHeight int) {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	arg1 := new(C.gint)
	var ret1 int
	arg2 := new(C.gint)
	var ret2 int

	C.gtk_widget_get_preferred_height(arg0, arg1, arg2)

	ret1 = int(*arg1)
	ret2 = int(*arg2)

	return ret1, ret2
}

// PreferredHeightAndBaselineForWidth retrieves a widget’s minimum and
// natural height and the corresponding baselines if it would be given the
// specified @width, or the default height if @width is -1. The baselines
// may be -1 which means that no baseline is requested for this widget.
//
// The returned request will be modified by the
// GtkWidgetClass::adjust_size_request and
// GtkWidgetClass::adjust_baseline_request virtual methods and by any
// SizeGroups that have been applied. That is, the returned request is the
// one that should be used for layout, not necessarily the one returned by
// the widget itself.
func (w widget) PreferredHeightAndBaselineForWidth(width int) (minimumHeight int, naturalHeight int, minimumBaseline int, naturalBaseline int) {
	var arg0 *C.GtkWidget
	var arg1 C.gint

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = C.gint(width)

	arg2 := new(C.gint)
	var ret2 int
	arg3 := new(C.gint)
	var ret3 int
	arg4 := new(C.gint)
	var ret4 int
	arg5 := new(C.gint)
	var ret5 int

	C.gtk_widget_get_preferred_height_and_baseline_for_width(arg0, arg1, arg2, arg3, arg4, arg5)

	ret2 = int(*arg2)
	ret3 = int(*arg3)
	ret4 = int(*arg4)
	ret5 = int(*arg5)

	return ret2, ret3, ret4, ret5
}

// PreferredHeightForWidth retrieves a widget’s minimum and natural height
// if it would be given the specified @width.
//
// The returned request will be modified by the
// GtkWidgetClass::adjust_size_request virtual method and by any SizeGroups
// that have been applied. That is, the returned request is the one that
// should be used for layout, not necessarily the one returned by the widget
// itself.
func (w widget) PreferredHeightForWidth(width int) (minimumHeight int, naturalHeight int) {
	var arg0 *C.GtkWidget
	var arg1 C.gint

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = C.gint(width)

	arg2 := new(C.gint)
	var ret2 int
	arg3 := new(C.gint)
	var ret3 int

	C.gtk_widget_get_preferred_height_for_width(arg0, arg1, arg2, arg3)

	ret2 = int(*arg2)
	ret3 = int(*arg3)

	return ret2, ret3
}

// PreferredSize retrieves the minimum and natural size of a widget, taking
// into account the widget’s preference for height-for-width management.
//
// This is used to retrieve a suitable size by container widgets which do
// not impose any restrictions on the child placement. It can be used to
// deduce toplevel window and menu sizes as well as child widgets in
// free-form containers such as GtkLayout.
//
// Handle with care. Note that the natural height of a height-for-width
// widget will generally be a smaller size than the minimum height, since
// the required height for the natural width is generally smaller than the
// required height for the minimum width.
//
// Use gtk_widget_get_preferred_height_and_baseline_for_width() if you want
// to support baseline alignment.
func (w widget) PreferredSize() (minimumSize *Requisition, naturalSize *Requisition) {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	arg1 := new(C.GtkRequisition)
	var ret1 *Requisition
	arg2 := new(C.GtkRequisition)
	var ret2 *Requisition

	C.gtk_widget_get_preferred_size(arg0, arg1, arg2)

	ret1 = WrapRequisition(unsafe.Pointer(arg1))
	ret2 = WrapRequisition(unsafe.Pointer(arg2))

	return ret1, ret2
}

// PreferredWidth retrieves a widget’s initial minimum and natural width.
//
// This call is specific to height-for-width requests.
//
// The returned request will be modified by the
// GtkWidgetClass::adjust_size_request virtual method and by any SizeGroups
// that have been applied. That is, the returned request is the one that
// should be used for layout, not necessarily the one returned by the widget
// itself.
func (w widget) PreferredWidth() (minimumWidth int, naturalWidth int) {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	arg1 := new(C.gint)
	var ret1 int
	arg2 := new(C.gint)
	var ret2 int

	C.gtk_widget_get_preferred_width(arg0, arg1, arg2)

	ret1 = int(*arg1)
	ret2 = int(*arg2)

	return ret1, ret2
}

// PreferredWidthForHeight retrieves a widget’s minimum and natural width if
// it would be given the specified @height.
//
// The returned request will be modified by the
// GtkWidgetClass::adjust_size_request virtual method and by any SizeGroups
// that have been applied. That is, the returned request is the one that
// should be used for layout, not necessarily the one returned by the widget
// itself.
func (w widget) PreferredWidthForHeight(height int) (minimumWidth int, naturalWidth int) {
	var arg0 *C.GtkWidget
	var arg1 C.gint

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = C.gint(height)

	arg2 := new(C.gint)
	var ret2 int
	arg3 := new(C.gint)
	var ret3 int

	C.gtk_widget_get_preferred_width_for_height(arg0, arg1, arg2, arg3)

	ret2 = int(*arg2)
	ret3 = int(*arg3)

	return ret2, ret3
}

// Realized determines whether @widget is realized.
func (w widget) Realized() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.gtk_widget_get_realized(arg0)

	if cret {
		goret = true
	}

	return goret
}

// ReceivesDefault determines whether @widget is always treated as the
// default widget within its toplevel when it has the focus, even if another
// widget is the default.
//
// See gtk_widget_set_receives_default().
func (w widget) ReceivesDefault() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.gtk_widget_get_receives_default(arg0)

	if cret {
		goret = true
	}

	return goret
}

// RequestMode gets whether the widget prefers a height-for-width layout or
// a width-for-height layout.
//
// Bin widgets generally propagate the preference of their child, container
// widgets need to request something either in context of their children or
// in context of their allocation capabilities.
func (w widget) RequestMode() SizeRequestMode {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret C.GtkSizeRequestMode
	var goret SizeRequestMode

	cret = C.gtk_widget_get_request_mode(arg0)

	goret = SizeRequestMode(cret)

	return goret
}

// Requisition retrieves the widget’s requisition.
//
// This function should only be used by widget implementations in order to
// figure whether the widget’s requisition has actually changed after some
// internal state change (so that they can call gtk_widget_queue_resize()
// instead of gtk_widget_queue_draw()).
//
// Normally, gtk_widget_size_request() should be used.
func (w widget) Requisition() *Requisition {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	arg1 := new(C.GtkRequisition)
	var ret1 *Requisition

	C.gtk_widget_get_requisition(arg0, arg1)

	ret1 = WrapRequisition(unsafe.Pointer(arg1))

	return ret1
}

// RootWindow: get the root window where this widget is located. This
// function can only be called after the widget has been added to a widget
// hierarchy with Window at the top.
//
// The root window is useful for such purposes as creating a popup Window
// associated with the window. In general, you should only create display
// specific resources when a widget has been realized, and you should free
// those resources when the widget is unrealized.
func (w widget) RootWindow() gdk.Window {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret *C.GdkWindow
	var goret gdk.Window

	cret = C.gtk_widget_get_root_window(arg0)

	goret = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(gdk.Window)

	return goret
}

// ScaleFactor retrieves the internal scale factor that maps from window
// coordinates to the actual device pixels. On traditional systems this is
// 1, on high density outputs, it can be a higher value (typically 2).
//
// See gdk_window_get_scale_factor().
func (w widget) ScaleFactor() int {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret C.gint
	var goret int

	cret = C.gtk_widget_get_scale_factor(arg0)

	goret = int(cret)

	return goret
}

// Screen: get the Screen from the toplevel window associated with this
// widget. This function can only be called after the widget has been added
// to a widget hierarchy with a Window at the top.
//
// In general, you should only create screen specific resources when a
// widget has been realized, and you should free those resources when the
// widget is unrealized.
func (w widget) Screen() gdk.Screen {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret *C.GdkScreen
	var goret gdk.Screen

	cret = C.gtk_widget_get_screen(arg0)

	goret = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(gdk.Screen)

	return goret
}

// Sensitive returns the widget’s sensitivity (in the sense of returning the
// value that has been set using gtk_widget_set_sensitive()).
//
// The effective sensitivity of a widget is however determined by both its
// own and its parent widget’s sensitivity. See gtk_widget_is_sensitive().
func (w widget) Sensitive() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.gtk_widget_get_sensitive(arg0)

	if cret {
		goret = true
	}

	return goret
}

// Settings gets the settings object holding the settings used for this
// widget.
//
// Note that this function can only be called when the Widget is attached to
// a toplevel, since the settings object is specific to a particular Screen.
func (w widget) Settings() Settings {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret *C.GtkSettings
	var goret Settings

	cret = C.gtk_widget_get_settings(arg0)

	goret = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Settings)

	return goret
}

// GetSizeRequest gets the size request that was explicitly set for the
// widget using gtk_widget_set_size_request(). A value of -1 stored in
// @width or @height indicates that that dimension has not been set
// explicitly and the natural requisition of the widget will be used
// instead. See gtk_widget_set_size_request(). To get the size a widget will
// actually request, call gtk_widget_get_preferred_size() instead of this
// function.
func (w widget) GetSizeRequest() (width int, height int) {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	arg1 := new(C.gint)
	var ret1 int
	arg2 := new(C.gint)
	var ret2 int

	C.gtk_widget_get_size_request(arg0, arg1, arg2)

	ret1 = int(*arg1)
	ret2 = int(*arg2)

	return ret1, ret2
}

// State returns the widget’s state. See gtk_widget_set_state().
func (w widget) State() StateType {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret C.GtkStateType
	var goret StateType

	cret = C.gtk_widget_get_state(arg0)

	goret = StateType(cret)

	return goret
}

// StateFlags returns the widget state as a flag set. It is worth mentioning
// that the effective GTK_STATE_FLAG_INSENSITIVE state will be returned,
// that is, also based on parent insensitivity, even if @widget itself is
// sensitive.
//
// Also note that if you are looking for a way to obtain the StateFlags to
// pass to a StyleContext method, you should look at
// gtk_style_context_get_state().
func (w widget) StateFlags() StateFlags {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret C.GtkStateFlags
	var goret StateFlags

	cret = C.gtk_widget_get_state_flags(arg0)

	goret = StateFlags(cret)

	return goret
}

// Style: simply an accessor function that returns @widget->style.
func (w widget) Style() Style {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret *C.GtkStyle
	var goret Style

	cret = C.gtk_widget_get_style(arg0)

	goret = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Style)

	return goret
}

// StyleContext returns the style context associated to @widget. The
// returned object is guaranteed to be the same for the lifetime of @widget.
func (w widget) StyleContext() StyleContext {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret *C.GtkStyleContext
	var goret StyleContext

	cret = C.gtk_widget_get_style_context(arg0)

	goret = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(StyleContext)

	return goret
}

// SupportMultidevice returns true if @widget is multiple pointer aware. See
// gtk_widget_set_support_multidevice() for more information.
func (w widget) SupportMultidevice() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.gtk_widget_get_support_multidevice(arg0)

	if cret {
		goret = true
	}

	return goret
}

// TemplateChild: fetch an object build from the template XML for
// @widget_type in this @widget instance.
//
// This will only report children which were previously declared with
// gtk_widget_class_bind_template_child_full() or one of its variants.
//
// This function is only meant to be called for code which is private to the
// @widget_type which declared the child and is meant for language bindings
// which cannot easily make use of the GObject structure offsets.
func (w widget) TemplateChild(widgetType externglib.Type, name string) gextras.Objector {
	var arg0 *C.GtkWidget
	var arg1 C.GType
	var arg2 *C.gchar

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = C.GType(widgetType)
	arg2 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg2))

	var cret *C.GObject
	var goret gextras.Objector

	cret = C.gtk_widget_get_template_child(arg0, arg1, arg2)

	goret = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(gextras.Objector)

	return goret
}

// TooltipMarkup gets the contents of the tooltip for @widget.
func (w widget) TooltipMarkup() string {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	cret := new(C.gchar)
	var goret string

	cret = C.gtk_widget_get_tooltip_markup(arg0)

	goret = C.GoString(cret)
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// TooltipText gets the contents of the tooltip for @widget.
func (w widget) TooltipText() string {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	cret := new(C.gchar)
	var goret string

	cret = C.gtk_widget_get_tooltip_text(arg0)

	goret = C.GoString(cret)
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// TooltipWindow returns the Window of the current tooltip. This can be the
// GtkWindow created by default, or the custom tooltip window set using
// gtk_widget_set_tooltip_window().
func (w widget) TooltipWindow() Window {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret *C.GtkWindow
	var goret Window

	cret = C.gtk_widget_get_tooltip_window(arg0)

	goret = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Window)

	return goret
}

// Toplevel: this function returns the topmost widget in the container
// hierarchy @widget is a part of. If @widget has no parent widgets, it will
// be returned as the topmost widget. No reference will be added to the
// returned widget; it should not be unreferenced.
//
// Note the difference in behavior vs. gtk_widget_get_ancestor();
// `gtk_widget_get_ancestor (widget, GTK_TYPE_WINDOW)` would return nil if
// @widget wasn’t inside a toplevel window, and if the window was inside a
// Window-derived widget which was in turn inside the toplevel Window. While
// the second case may seem unlikely, it actually happens when a Plug is
// embedded inside a Socket within the same application.
//
// To reliably find the toplevel Window, use gtk_widget_get_toplevel() and
// call GTK_IS_WINDOW() on the result. For instance, to get the title of a
// widget's toplevel window, one might use:
//
//    static const char *
//    get_widget_toplevel_title (GtkWidget *widget)
//    {
//      GtkWidget *toplevel = gtk_widget_get_toplevel (widget);
//      if (GTK_IS_WINDOW (toplevel))
//        {
//          return gtk_window_get_title (GTK_WINDOW (toplevel));
//        }
//
//      return NULL;
//    }
func (w widget) Toplevel() Widget {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret *C.GtkWidget
	var goret Widget

	cret = C.gtk_widget_get_toplevel(arg0)

	goret = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Widget)

	return goret
}

// Valign gets the value of the Widget:valign property.
//
// For backwards compatibility reasons this method will never return
// GTK_ALIGN_BASELINE, but instead it will convert it to GTK_ALIGN_FILL. If
// your widget want to support baseline aligned children it must use
// gtk_widget_get_valign_with_baseline(), or `g_object_get (widget,
// "valign", &value, NULL)`, which will also report the true value.
func (w widget) Valign() Align {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret C.GtkAlign
	var goret Align

	cret = C.gtk_widget_get_valign(arg0)

	goret = Align(cret)

	return goret
}

// ValignWithBaseline gets the value of the Widget:valign property,
// including GTK_ALIGN_BASELINE.
func (w widget) ValignWithBaseline() Align {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret C.GtkAlign
	var goret Align

	cret = C.gtk_widget_get_valign_with_baseline(arg0)

	goret = Align(cret)

	return goret
}

// Vexpand gets whether the widget would like any available extra vertical
// space.
//
// See gtk_widget_get_hexpand() for more detail.
func (w widget) Vexpand() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.gtk_widget_get_vexpand(arg0)

	if cret {
		goret = true
	}

	return goret
}

// VexpandSet gets whether gtk_widget_set_vexpand() has been used to
// explicitly set the expand flag on this widget.
//
// See gtk_widget_get_hexpand_set() for more detail.
func (w widget) VexpandSet() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.gtk_widget_get_vexpand_set(arg0)

	if cret {
		goret = true
	}

	return goret
}

// Visible determines whether the widget is visible. If you want to take
// into account whether the widget’s parent is also marked as visible, use
// gtk_widget_is_visible() instead.
//
// This function does not check if the widget is obscured in any way.
//
// See gtk_widget_set_visible().
func (w widget) Visible() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.gtk_widget_get_visible(arg0)

	if cret {
		goret = true
	}

	return goret
}

// Visual gets the visual that will be used to render @widget.
func (w widget) Visual() gdk.Visual {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret *C.GdkVisual
	var goret gdk.Visual

	cret = C.gtk_widget_get_visual(arg0)

	goret = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(gdk.Visual)

	return goret
}

// Window returns the widget’s window if it is realized, nil otherwise
func (w widget) Window() gdk.Window {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret *C.GdkWindow
	var goret gdk.Window

	cret = C.gtk_widget_get_window(arg0)

	goret = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(gdk.Window)

	return goret
}

// GrabAdd makes @widget the current grabbed widget.
//
// This means that interaction with other widgets in the same application is
// blocked and mouse as well as keyboard events are delivered to this
// widget.
//
// If @widget is not sensitive, it is not set as the current grabbed widget
// and this function does nothing.
func (w widget) GrabAdd() {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_grab_add(arg0)
}

// GrabDefault causes @widget to become the default widget. @widget must be
// able to be a default widget; typically you would ensure this yourself by
// calling gtk_widget_set_can_default() with a true value. The default
// widget is activated when the user presses Enter in a window. Default
// widgets must be activatable, that is, gtk_widget_activate() should affect
// them. Note that Entry widgets require the “activates-default” property
// set to true before they activate the default widget when Enter is pressed
// and the Entry is focused.
func (w widget) GrabDefault() {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_grab_default(arg0)
}

// GrabFocus causes @widget to have the keyboard focus for the Window it's
// inside. @widget must be a focusable widget, such as a Entry; something
// like Frame won’t work.
//
// More precisely, it must have the GTK_CAN_FOCUS flag set. Use
// gtk_widget_set_can_focus() to modify that flag.
//
// The widget also needs to be realized and mapped. This is indicated by the
// related signals. Grabbing the focus immediately after creating the widget
// will likely fail and cause critical warnings.
func (w widget) GrabFocus() {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_grab_focus(arg0)
}

// GrabRemove removes the grab from the given widget.
//
// You have to pair calls to gtk_grab_add() and gtk_grab_remove().
//
// If @widget does not have the grab, this function does nothing.
func (w widget) GrabRemove() {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_grab_remove(arg0)
}

// HasDefault determines whether @widget is the current default widget
// within its toplevel. See gtk_widget_set_can_default().
func (w widget) HasDefault() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.gtk_widget_has_default(arg0)

	if cret {
		goret = true
	}

	return goret
}

// HasFocus determines if the widget has the global input focus. See
// gtk_widget_is_focus() for the difference between having the global input
// focus, and only having the focus within a toplevel.
func (w widget) HasFocus() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.gtk_widget_has_focus(arg0)

	if cret {
		goret = true
	}

	return goret
}

// HasGrab determines whether the widget is currently grabbing events, so it
// is the only widget receiving input events (keyboard and mouse).
//
// See also gtk_grab_add().
func (w widget) HasGrab() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.gtk_widget_has_grab(arg0)

	if cret {
		goret = true
	}

	return goret
}

// HasRCStyle determines if the widget style has been looked up through the
// rc mechanism.
func (w widget) HasRCStyle() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.gtk_widget_has_rc_style(arg0)

	if cret {
		goret = true
	}

	return goret
}

// HasScreen checks whether there is a Screen is associated with this
// widget. All toplevel widgets have an associated screen, and all widgets
// added into a hierarchy with a toplevel window at the top.
func (w widget) HasScreen() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.gtk_widget_has_screen(arg0)

	if cret {
		goret = true
	}

	return goret
}

// HasVisibleFocus determines if the widget should show a visible indication
// that it has the global input focus. This is a convenience function for
// use in ::draw handlers that takes into account whether focus indication
// should currently be shown in the toplevel window of @widget. See
// gtk_window_get_focus_visible() for more information about focus
// indication.
//
// To find out if the widget has the global input focus, use
// gtk_widget_has_focus().
func (w widget) HasVisibleFocus() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.gtk_widget_has_visible_focus(arg0)

	if cret {
		goret = true
	}

	return goret
}

// Hide reverses the effects of gtk_widget_show(), causing the widget to be
// hidden (invisible to the user).
func (w widget) Hide() {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_hide(arg0)
}

// HideOnDelete: utility function; intended to be connected to the
// Widget::delete-event signal on a Window. The function calls
// gtk_widget_hide() on its argument, then returns true. If connected to
// ::delete-event, the result is that clicking the close button for a window
// (on the window frame, top right corner usually) will hide but not destroy
// the window. By default, GTK+ destroys windows when ::delete-event is
// received.
func (w widget) HideOnDelete() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.gtk_widget_hide_on_delete(arg0)

	if cret {
		goret = true
	}

	return goret
}

// InDestruction returns whether the widget is currently being destroyed.
// This information can sometimes be used to avoid doing unnecessary work.
func (w widget) InDestruction() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.gtk_widget_in_destruction(arg0)

	if cret {
		goret = true
	}

	return goret
}

// InitTemplate creates and initializes child widgets defined in templates.
// This function must be called in the instance initializer for any class
// which assigned itself a template using gtk_widget_class_set_template()
//
// It is important to call this function in the instance initializer of a
// Widget subclass and not in #GObject.constructed() or
// #GObject.constructor() for two reasons.
//
// One reason is that generally derived widgets will assume that parent
// class composite widgets have been created in their instance initializers.
//
// Another reason is that when calling g_object_new() on a widget with
// composite templates, it’s important to build the composite widgets before
// the construct properties are set. Properties passed to g_object_new()
// should take precedence over properties set in the private template XML.
func (w widget) InitTemplate() {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_init_template(arg0)
}

// InputShapeCombineRegion sets an input shape for this widget’s GDK window.
// This allows for windows which react to mouse click in a nonrectangular
// region, see gdk_window_input_shape_combine_region() for more information.
func (w widget) InputShapeCombineRegion(region *cairo.Region) {
	var arg0 *C.GtkWidget
	var arg1 *C.cairo_region_t

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (*C.cairo_region_t)(unsafe.Pointer(region.Native()))

	C.gtk_widget_input_shape_combine_region(arg0, arg1)
}

// InsertActionGroup inserts @group into @widget. Children of @widget that
// implement Actionable can then be associated with actions in @group by
// setting their “action-name” to @prefix.`action-name`.
//
// If @group is nil, a previously inserted group for @name is removed from
// @widget.
func (w widget) InsertActionGroup(name string, group gio.ActionGroup) {
	var arg0 *C.GtkWidget
	var arg1 *C.gchar
	var arg2 *C.GActionGroup

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GActionGroup)(unsafe.Pointer(group.Native()))

	C.gtk_widget_insert_action_group(arg0, arg1, arg2)
}

// Intersect computes the intersection of a @widget’s area and @area,
// storing the intersection in @intersection, and returns true if there was
// an intersection. @intersection may be nil if you’re only interested in
// whether there was an intersection.
func (w widget) Intersect(area *gdk.Rectangle) (intersection *gdk.Rectangle, ok bool) {
	var arg0 *C.GtkWidget
	var arg1 *C.GdkRectangle

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (*C.GdkRectangle)(unsafe.Pointer(area.Native()))

	arg2 := new(C.GdkRectangle)
	var ret2 *gdk.Rectangle
	var cret C.gboolean
	var goret bool

	cret = C.gtk_widget_intersect(arg0, arg1, arg2)

	ret2 = gdk.WrapRectangle(unsafe.Pointer(arg2))
	if cret {
		goret = true
	}

	return ret2, goret
}

// IsAncestor determines whether @widget is somewhere inside @ancestor,
// possibly with intermediate containers.
func (w widget) IsAncestor(ancestor Widget) bool {
	var arg0 *C.GtkWidget
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(ancestor.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.gtk_widget_is_ancestor(arg0, arg1)

	if cret {
		goret = true
	}

	return goret
}

// IsComposited: whether @widget can rely on having its alpha channel drawn
// correctly. On X11 this function returns whether a compositing manager is
// running for @widget’s screen.
//
// Please note that the semantics of this call will change in the future if
// used on a widget that has a composited window in its hierarchy (as set by
// gdk_window_set_composited()).
func (w widget) IsComposited() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.gtk_widget_is_composited(arg0)

	if cret {
		goret = true
	}

	return goret
}

// IsDrawable determines whether @widget can be drawn to. A widget can be
// drawn to if it is mapped and visible.
func (w widget) IsDrawable() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.gtk_widget_is_drawable(arg0)

	if cret {
		goret = true
	}

	return goret
}

// IsFocus determines if the widget is the focus widget within its toplevel.
// (This does not mean that the Widget:has-focus property is necessarily
// set; Widget:has-focus will only be set if the toplevel widget
// additionally has the global input focus.)
func (w widget) IsFocus() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.gtk_widget_is_focus(arg0)

	if cret {
		goret = true
	}

	return goret
}

// IsSensitive returns the widget’s effective sensitivity, which means it is
// sensitive itself and also its parent widget is sensitive
func (w widget) IsSensitive() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.gtk_widget_is_sensitive(arg0)

	if cret {
		goret = true
	}

	return goret
}

// IsToplevel determines whether @widget is a toplevel widget.
//
// Currently only Window and Invisible (and out-of-process Plugs) are
// toplevel widgets. Toplevel widgets have no parent widget.
func (w widget) IsToplevel() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.gtk_widget_is_toplevel(arg0)

	if cret {
		goret = true
	}

	return goret
}

// IsVisible determines whether the widget and all its parents are marked as
// visible.
//
// This function does not check if the widget is obscured in any way.
//
// See also gtk_widget_get_visible() and gtk_widget_set_visible()
func (w widget) IsVisible() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.gtk_widget_is_visible(arg0)

	if cret {
		goret = true
	}

	return goret
}

// KeynavFailed: this function should be called whenever keyboard navigation
// within a single widget hits a boundary. The function emits the
// Widget::keynav-failed signal on the widget and its return value should be
// interpreted in a way similar to the return value of
// gtk_widget_child_focus():
//
// When true is returned, stay in the widget, the failed keyboard navigation
// is OK and/or there is nowhere we can/should move the focus to.
//
// When false is returned, the caller should continue with keyboard
// navigation outside the widget, e.g. by calling gtk_widget_child_focus()
// on the widget’s toplevel.
//
// The default ::keynav-failed handler returns false for GTK_DIR_TAB_FORWARD
// and GTK_DIR_TAB_BACKWARD. For the other values of DirectionType it
// returns true.
//
// Whenever the default handler returns true, it also calls
// gtk_widget_error_bell() to notify the user of the failed keyboard
// navigation.
//
// A use case for providing an own implementation of ::keynav-failed (either
// by connecting to it or by overriding it) would be a row of Entry widgets
// where the user should be able to navigate the entire row with the cursor
// keys, as e.g. known from user interfaces that require entering license
// keys.
func (w widget) KeynavFailed(direction DirectionType) bool {
	var arg0 *C.GtkWidget
	var arg1 C.GtkDirectionType

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (C.GtkDirectionType)(direction)

	var cret C.gboolean
	var goret bool

	cret = C.gtk_widget_keynav_failed(arg0, arg1)

	if cret {
		goret = true
	}

	return goret
}

// ListAccelClosures lists the closures used by @widget for accelerator
// group connections with gtk_accel_group_connect_by_path() or
// gtk_accel_group_connect(). The closures can be used to monitor
// accelerator changes on @widget, by connecting to the
// @GtkAccelGroup::accel-changed signal of the AccelGroup of a closure which
// can be found out with gtk_accel_group_from_accel_closure().
func (w widget) ListAccelClosures() *glib.List {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	cret := new(C.GList)
	var goret *glib.List

	cret = C.gtk_widget_list_accel_closures(arg0)

	goret = glib.WrapList(unsafe.Pointer(cret))
	runtime.SetFinalizer(goret, func(v *glib.List) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return goret
}

// ListActionPrefixes retrieves a nil-terminated array of strings containing
// the prefixes of Group's available to @widget.
func (w widget) ListActionPrefixes() []string {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret **C.gchar
	var goret []string

	cret = C.gtk_widget_list_action_prefixes(arg0)

	{
		var length int
		for p := cret; *p != 0; p = (**C.gchar)(ptr.Add(unsafe.Pointer(p), unsafe.Sizeof(int(0)))) {
			length++
			if length < 0 {
				panic(`length overflow`)
			}
		}

		goret = make([]string, length)
		for i := uintptr(0); i < uintptr(length); i += unsafe.Sizeof(int(0)) {
			src := (*C.gchar)(ptr.Add(unsafe.Pointer(cret), i))
			goret[i] = C.GoString(src)
		}
	}

	return goret
}

// ListMnemonicLabels returns a newly allocated list of the widgets,
// normally labels, for which this widget is the target of a mnemonic (see
// for example, gtk_label_set_mnemonic_widget()).
//
// The widgets in the list are not individually referenced. If you want to
// iterate through the list and perform actions involving callbacks that
// might destroy the widgets, you must call `g_list_foreach (result,
// (GFunc)g_object_ref, NULL)` first, and then unref all the widgets
// afterwards.
func (w widget) ListMnemonicLabels() *glib.List {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	cret := new(C.GList)
	var goret *glib.List

	cret = C.gtk_widget_list_mnemonic_labels(arg0)

	goret = glib.WrapList(unsafe.Pointer(cret))
	runtime.SetFinalizer(goret, func(v *glib.List) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return goret
}

// Map: this function is only for use in widget implementations. Causes a
// widget to be mapped if it isn’t already.
func (w widget) Map() {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_map(arg0)
}

// MnemonicActivate emits the Widget::mnemonic-activate signal.
func (w widget) MnemonicActivate(groupCycling bool) bool {
	var arg0 *C.GtkWidget
	var arg1 C.gboolean

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	if groupCycling {
		arg1 = C.gboolean(1)
	}

	var cret C.gboolean
	var goret bool

	cret = C.gtk_widget_mnemonic_activate(arg0, arg1)

	if cret {
		goret = true
	}

	return goret
}

// ModifyBase sets the base color for a widget in a particular state. All
// other style values are left untouched. The base color is the background
// color used along with the text color (see gtk_widget_modify_text()) for
// widgets such as Entry and TextView. See also gtk_widget_modify_style().
//
// > Note that “no window” widgets (which have the GTK_NO_WINDOW > flag set)
// draw on their parent container’s window and thus may > not draw any
// background themselves. This is the case for e.g. > Label. > > To modify
// the background of such widgets, you have to set the > base color on their
// parent; if you want to set the background > of a rectangular area around
// a label, try placing the label in > a EventBox widget and setting the
// base color on that.
func (w widget) ModifyBase(state StateType, color *gdk.Color) {
	var arg0 *C.GtkWidget
	var arg1 C.GtkStateType
	var arg2 *C.GdkColor

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (C.GtkStateType)(state)
	arg2 = (*C.GdkColor)(unsafe.Pointer(color.Native()))

	C.gtk_widget_modify_base(arg0, arg1, arg2)
}

// ModifyBg sets the background color for a widget in a particular state.
//
// All other style values are left untouched. See also
// gtk_widget_modify_style().
//
// > Note that “no window” widgets (which have the GTK_NO_WINDOW > flag set)
// draw on their parent container’s window and thus may > not draw any
// background themselves. This is the case for e.g. > Label. > > To modify
// the background of such widgets, you have to set the > background color on
// their parent; if you want to set the background > of a rectangular area
// around a label, try placing the label in > a EventBox widget and setting
// the background color on that.
func (w widget) ModifyBg(state StateType, color *gdk.Color) {
	var arg0 *C.GtkWidget
	var arg1 C.GtkStateType
	var arg2 *C.GdkColor

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (C.GtkStateType)(state)
	arg2 = (*C.GdkColor)(unsafe.Pointer(color.Native()))

	C.gtk_widget_modify_bg(arg0, arg1, arg2)
}

// ModifyCursor sets the cursor color to use in a widget, overriding the
// Widget cursor-color and secondary-cursor-color style properties.
//
// All other style values are left untouched. See also
// gtk_widget_modify_style().
func (w widget) ModifyCursor(primary *gdk.Color, secondary *gdk.Color) {
	var arg0 *C.GtkWidget
	var arg1 *C.GdkColor
	var arg2 *C.GdkColor

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (*C.GdkColor)(unsafe.Pointer(primary.Native()))
	arg2 = (*C.GdkColor)(unsafe.Pointer(secondary.Native()))

	C.gtk_widget_modify_cursor(arg0, arg1, arg2)
}

// ModifyFg sets the foreground color for a widget in a particular state.
//
// All other style values are left untouched. See also
// gtk_widget_modify_style().
func (w widget) ModifyFg(state StateType, color *gdk.Color) {
	var arg0 *C.GtkWidget
	var arg1 C.GtkStateType
	var arg2 *C.GdkColor

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (C.GtkStateType)(state)
	arg2 = (*C.GdkColor)(unsafe.Pointer(color.Native()))

	C.gtk_widget_modify_fg(arg0, arg1, arg2)
}

// ModifyFont sets the font to use for a widget.
//
// All other style values are left untouched. See also
// gtk_widget_modify_style().
func (w widget) ModifyFont(fontDesc *pango.FontDescription) {
	var arg0 *C.GtkWidget
	var arg1 *C.PangoFontDescription

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (*C.PangoFontDescription)(unsafe.Pointer(fontDesc.Native()))

	C.gtk_widget_modify_font(arg0, arg1)
}

// ModifyStyle modifies style values on the widget.
//
// Modifications made using this technique take precedence over style values
// set via an RC file, however, they will be overridden if a style is
// explicitly set on the widget using gtk_widget_set_style(). The
// RcStyle-struct is designed so each field can either be set or unset, so
// it is possible, using this function, to modify some style values and
// leave the others unchanged.
//
// Note that modifications made with this function are not cumulative with
// previous calls to gtk_widget_modify_style() or with such functions as
// gtk_widget_modify_fg(). If you wish to retain previous values, you must
// first call gtk_widget_get_modifier_style(), make your modifications to
// the returned style, then call gtk_widget_modify_style() with that style.
// On the other hand, if you first call gtk_widget_modify_style(),
// subsequent calls to such functions gtk_widget_modify_fg() will have a
// cumulative effect with the initial modifications.
func (w widget) ModifyStyle(style RCStyle) {
	var arg0 *C.GtkWidget
	var arg1 *C.GtkRcStyle

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (*C.GtkRcStyle)(unsafe.Pointer(style.Native()))

	C.gtk_widget_modify_style(arg0, arg1)
}

// ModifyText sets the text color for a widget in a particular state.
//
// All other style values are left untouched. The text color is the
// foreground color used along with the base color (see
// gtk_widget_modify_base()) for widgets such as Entry and TextView. See
// also gtk_widget_modify_style().
func (w widget) ModifyText(state StateType, color *gdk.Color) {
	var arg0 *C.GtkWidget
	var arg1 C.GtkStateType
	var arg2 *C.GdkColor

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (C.GtkStateType)(state)
	arg2 = (*C.GdkColor)(unsafe.Pointer(color.Native()))

	C.gtk_widget_modify_text(arg0, arg1, arg2)
}

// OverrideBackgroundColor sets the background color to use for a widget.
//
// All other style values are left untouched. See
// gtk_widget_override_color().
func (w widget) OverrideBackgroundColor(state StateFlags, color *gdk.RGBA) {
	var arg0 *C.GtkWidget
	var arg1 C.GtkStateFlags
	var arg2 *C.GdkRGBA

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (C.GtkStateFlags)(state)
	arg2 = (*C.GdkRGBA)(unsafe.Pointer(color.Native()))

	C.gtk_widget_override_background_color(arg0, arg1, arg2)
}

// OverrideColor sets the color to use for a widget.
//
// All other style values are left untouched.
//
// This function does not act recursively. Setting the color of a container
// does not affect its children. Note that some widgets that you may not
// think of as containers, for instance Buttons, are actually containers.
//
// This API is mostly meant as a quick way for applications to change a
// widget appearance. If you are developing a widgets library and intend
// this change to be themeable, it is better done by setting meaningful CSS
// classes in your widget/container implementation through
// gtk_style_context_add_class().
//
// This way, your widget library can install a CssProvider with the
// GTK_STYLE_PROVIDER_PRIORITY_FALLBACK priority in order to provide a
// default styling for those widgets that need so, and this theming may
// fully overridden by the user’s theme.
//
// Note that for complex widgets this may bring in undesired results (such
// as uniform background color everywhere), in these cases it is better to
// fully style such widgets through a CssProvider with the
// GTK_STYLE_PROVIDER_PRIORITY_APPLICATION priority.
func (w widget) OverrideColor(state StateFlags, color *gdk.RGBA) {
	var arg0 *C.GtkWidget
	var arg1 C.GtkStateFlags
	var arg2 *C.GdkRGBA

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (C.GtkStateFlags)(state)
	arg2 = (*C.GdkRGBA)(unsafe.Pointer(color.Native()))

	C.gtk_widget_override_color(arg0, arg1, arg2)
}

// OverrideCursor sets the cursor color to use in a widget, overriding the
// cursor-color and secondary-cursor-color style properties. All other style
// values are left untouched. See also gtk_widget_modify_style().
//
// Note that the underlying properties have the Color type, so the alpha
// value in @primary and @secondary will be ignored.
func (w widget) OverrideCursor(cursor *gdk.RGBA, secondaryCursor *gdk.RGBA) {
	var arg0 *C.GtkWidget
	var arg1 *C.GdkRGBA
	var arg2 *C.GdkRGBA

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (*C.GdkRGBA)(unsafe.Pointer(cursor.Native()))
	arg2 = (*C.GdkRGBA)(unsafe.Pointer(secondaryCursor.Native()))

	C.gtk_widget_override_cursor(arg0, arg1, arg2)
}

// OverrideFont sets the font to use for a widget. All other style values
// are left untouched. See gtk_widget_override_color().
func (w widget) OverrideFont(fontDesc *pango.FontDescription) {
	var arg0 *C.GtkWidget
	var arg1 *C.PangoFontDescription

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (*C.PangoFontDescription)(unsafe.Pointer(fontDesc.Native()))

	C.gtk_widget_override_font(arg0, arg1)
}

// OverrideSymbolicColor sets a symbolic color for a widget.
//
// All other style values are left untouched. See
// gtk_widget_override_color() for overriding the foreground or background
// color.
func (w widget) OverrideSymbolicColor(name string, color *gdk.RGBA) {
	var arg0 *C.GtkWidget
	var arg1 *C.gchar
	var arg2 *C.GdkRGBA

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GdkRGBA)(unsafe.Pointer(color.Native()))

	C.gtk_widget_override_symbolic_color(arg0, arg1, arg2)
}

// Path obtains the full path to @widget. The path is simply the name of a
// widget and all its parents in the container hierarchy, separated by
// periods. The name of a widget comes from gtk_widget_get_name(). Paths are
// used to apply styles to a widget in gtkrc configuration files. Widget
// names are the type of the widget by default (e.g. “GtkButton”) or can be
// set to an application-specific value with gtk_widget_set_name(). By
// setting the name of a widget, you allow users or theme authors to apply
// styles to that specific widget in their gtkrc file. @path_reversed_p
// fills in the path in reverse order, i.e. starting with @widget’s name
// instead of starting with the name of @widget’s outermost ancestor.
func (w widget) Path() (pathLength uint, path string, pathReversed string) {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	arg1 := new(C.guint)
	var ret1 uint
	arg2 := new(*C.gchar)
	var ret2 string
	arg3 := new(*C.gchar)
	var ret3 string

	C.gtk_widget_path(arg0, arg1, arg2, arg3)

	ret1 = uint(*arg1)
	ret2 = C.GoString(*arg2)
	defer C.free(unsafe.Pointer(*arg2))
	ret3 = C.GoString(*arg3)
	defer C.free(unsafe.Pointer(*arg3))

	return ret1, ret2, ret3
}

// QueueAllocate: this function is only for use in widget implementations.
//
// Flags the widget for a rerun of the GtkWidgetClass::size_allocate
// function. Use this function instead of gtk_widget_queue_resize() when the
// @widget's size request didn't change but it wants to reposition its
// contents.
//
// An example user of this function is gtk_widget_set_halign().
func (w widget) QueueAllocate() {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_queue_allocate(arg0)
}

// QueueComputeExpand: mark @widget as needing to recompute its expand
// flags. Call this function when setting legacy expand child properties on
// the child of a container.
//
// See gtk_widget_compute_expand().
func (w widget) QueueComputeExpand() {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_queue_compute_expand(arg0)
}

// QueueDraw: equivalent to calling gtk_widget_queue_draw_area() for the
// entire area of a widget.
func (w widget) QueueDraw() {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_queue_draw(arg0)
}

// QueueDrawArea: convenience function that calls
// gtk_widget_queue_draw_region() on the region created from the given
// coordinates.
//
// The region here is specified in widget coordinates. Widget coordinates
// are a bit odd; for historical reasons, they are defined as
// @widget->window coordinates for widgets that return true for
// gtk_widget_get_has_window(), and are relative to @widget->allocation.x,
// @widget->allocation.y otherwise.
//
// @width or @height may be 0, in this case this function does nothing.
// Negative values for @width and @height are not allowed.
func (w widget) QueueDrawArea(x int, y int, width int, height int) {
	var arg0 *C.GtkWidget
	var arg1 C.gint
	var arg2 C.gint
	var arg3 C.gint
	var arg4 C.gint

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = C.gint(x)
	arg2 = C.gint(y)
	arg3 = C.gint(width)
	arg4 = C.gint(height)

	C.gtk_widget_queue_draw_area(arg0, arg1, arg2, arg3, arg4)
}

// QueueDrawRegion invalidates the area of @widget defined by @region by
// calling gdk_window_invalidate_region() on the widget’s window and all its
// child windows. Once the main loop becomes idle (after the current batch
// of events has been processed, roughly), the window will receive expose
// events for the union of all regions that have been invalidated.
//
// Normally you would only use this function in widget implementations. You
// might also use it to schedule a redraw of a DrawingArea or some portion
// thereof.
func (w widget) QueueDrawRegion(region *cairo.Region) {
	var arg0 *C.GtkWidget
	var arg1 *C.cairo_region_t

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (*C.cairo_region_t)(unsafe.Pointer(region.Native()))

	C.gtk_widget_queue_draw_region(arg0, arg1)
}

// QueueResize: this function is only for use in widget implementations.
// Flags a widget to have its size renegotiated; should be called when a
// widget for some reason has a new size request. For example, when you
// change the text in a Label, Label queues a resize to ensure there’s
// enough space for the new text.
//
// Note that you cannot call gtk_widget_queue_resize() on a widget from
// inside its implementation of the GtkWidgetClass::size_allocate virtual
// method. Calls to gtk_widget_queue_resize() from inside
// GtkWidgetClass::size_allocate will be silently ignored.
func (w widget) QueueResize() {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_queue_resize(arg0)
}

// QueueResizeNoRedraw: this function works like gtk_widget_queue_resize(),
// except that the widget is not invalidated.
func (w widget) QueueResizeNoRedraw() {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_queue_resize_no_redraw(arg0)
}

// Realize creates the GDK (windowing system) resources associated with a
// widget. For example, @widget->window will be created when a widget is
// realized. Normally realization happens implicitly; if you show a widget
// and all its parent containers, then the widget will be realized and
// mapped automatically.
//
// Realizing a widget requires all the widget’s parent widgets to be
// realized; calling gtk_widget_realize() realizes the widget’s parents in
// addition to @widget itself. If a widget is not yet inside a toplevel
// window when you realize it, bad things will happen.
//
// This function is primarily used in widget implementations, and isn’t very
// useful otherwise. Many times when you think you might need it, a better
// approach is to connect to a signal that will be called after the widget
// is realized automatically, such as Widget::draw. Or simply
// g_signal_connect () to the Widget::realize signal.
func (w widget) Realize() {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_realize(arg0)
}

// RegionIntersect computes the intersection of a @widget’s area and
// @region, returning the intersection. The result may be empty, use
// cairo_region_is_empty() to check.
func (w widget) RegionIntersect(region *cairo.Region) *cairo.Region {
	var arg0 *C.GtkWidget
	var arg1 *C.cairo_region_t

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (*C.cairo_region_t)(unsafe.Pointer(region.Native()))

	cret := new(C.cairo_region_t)
	var goret *cairo.Region

	cret = C.gtk_widget_region_intersect(arg0, arg1)

	goret = cairo.WrapRegion(unsafe.Pointer(cret))
	runtime.SetFinalizer(goret, func(v *cairo.Region) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return goret
}

// RegisterWindow registers a Window with the widget and sets it up so that
// the widget receives events for it. Call gtk_widget_unregister_window()
// when destroying the window.
//
// Before 3.8 you needed to call gdk_window_set_user_data() directly to set
// this up. This is now deprecated and you should use
// gtk_widget_register_window() instead. Old code will keep working as is,
// although some new features like transparency might not work perfectly.
func (w widget) RegisterWindow(window gdk.Window) {
	var arg0 *C.GtkWidget
	var arg1 *C.GdkWindow

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (*C.GdkWindow)(unsafe.Pointer(window.Native()))

	C.gtk_widget_register_window(arg0, arg1)
}

// RemoveAccelerator removes an accelerator from @widget, previously
// installed with gtk_widget_add_accelerator().
func (w widget) RemoveAccelerator(accelGroup AccelGroup, accelKey uint, accelMods gdk.ModifierType) bool {
	var arg0 *C.GtkWidget
	var arg1 *C.GtkAccelGroup
	var arg2 C.guint
	var arg3 C.GdkModifierType

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (*C.GtkAccelGroup)(unsafe.Pointer(accelGroup.Native()))
	arg2 = C.guint(accelKey)
	arg3 = (C.GdkModifierType)(accelMods)

	var cret C.gboolean
	var goret bool

	cret = C.gtk_widget_remove_accelerator(arg0, arg1, arg2, arg3)

	if cret {
		goret = true
	}

	return goret
}

// RemoveMnemonicLabel removes a widget from the list of mnemonic labels for
// this widget. (See gtk_widget_list_mnemonic_labels()). The widget must
// have previously been added to the list with
// gtk_widget_add_mnemonic_label().
func (w widget) RemoveMnemonicLabel(label Widget) {
	var arg0 *C.GtkWidget
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(label.Native()))

	C.gtk_widget_remove_mnemonic_label(arg0, arg1)
}

// RemoveTickCallback removes a tick callback previously registered with
// gtk_widget_add_tick_callback().
func (w widget) RemoveTickCallback(iD uint) {
	var arg0 *C.GtkWidget
	var arg1 C.guint

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = C.guint(iD)

	C.gtk_widget_remove_tick_callback(arg0, arg1)
}

// RenderIcon: a convenience function that uses the theme settings for
// @widget to look up @stock_id and render it to a pixbuf. @stock_id should
// be a stock icon ID such as K_STOCK_OPEN or K_STOCK_OK. @size should be a
// size such as K_ICON_SIZE_MENU. @detail should be a string that identifies
// the widget or code doing the rendering, so that theme engines can
// special-case rendering for that widget or code.
//
// The pixels in the returned Pixbuf are shared with the rest of the
// application and should not be modified. The pixbuf should be freed after
// use with g_object_unref().
func (w widget) RenderIcon(stockID string, size int, detail string) gdkpixbuf.Pixbuf {
	var arg0 *C.GtkWidget
	var arg1 *C.gchar
	var arg2 C.GtkIconSize
	var arg3 *C.gchar

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (*C.gchar)(C.CString(stockID))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.GtkIconSize(size)
	arg3 = (*C.gchar)(C.CString(detail))
	defer C.free(unsafe.Pointer(arg3))

	cret := new(C.GdkPixbuf)
	var goret gdkpixbuf.Pixbuf

	cret = C.gtk_widget_render_icon(arg0, arg1, arg2, arg3)

	goret = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(gdkpixbuf.Pixbuf)

	return goret
}

// RenderIconPixbuf: a convenience function that uses the theme engine and
// style settings for @widget to look up @stock_id and render it to a
// pixbuf. @stock_id should be a stock icon ID such as K_STOCK_OPEN or
// K_STOCK_OK. @size should be a size such as K_ICON_SIZE_MENU.
//
// The pixels in the returned Pixbuf are shared with the rest of the
// application and should not be modified. The pixbuf should be freed after
// use with g_object_unref().
func (w widget) RenderIconPixbuf(stockID string, size int) gdkpixbuf.Pixbuf {
	var arg0 *C.GtkWidget
	var arg1 *C.gchar
	var arg2 C.GtkIconSize

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (*C.gchar)(C.CString(stockID))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.GtkIconSize(size)

	cret := new(C.GdkPixbuf)
	var goret gdkpixbuf.Pixbuf

	cret = C.gtk_widget_render_icon_pixbuf(arg0, arg1, arg2)

	goret = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(gdkpixbuf.Pixbuf)

	return goret
}

// Reparent moves a widget from one Container to another, handling reference
// count issues to avoid destroying the widget.
func (w widget) Reparent(newParent Widget) {
	var arg0 *C.GtkWidget
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(newParent.Native()))

	C.gtk_widget_reparent(arg0, arg1)
}

// ResetRCStyles: reset the styles of @widget and all descendents, so when
// they are looked up again, they get the correct values for the currently
// loaded RC file settings.
//
// This function is not useful for applications.
func (w widget) ResetRCStyles() {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_reset_rc_styles(arg0)
}

// ResetStyle updates the style context of @widget and all descendants by
// updating its widget path. Containers may want to use this on a child when
// reordering it in a way that a different style might apply to it. See also
// gtk_container_get_path_for_child().
func (w widget) ResetStyle() {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_reset_style(arg0)
}

// SetAccelPath: given an accelerator group, @accel_group, and an
// accelerator path, @accel_path, sets up an accelerator in @accel_group so
// whenever the key binding that is defined for @accel_path is pressed,
// @widget will be activated. This removes any accelerators (for any
// accelerator group) installed by previous calls to
// gtk_widget_set_accel_path(). Associating accelerators with paths allows
// them to be modified by the user and the modifications to be saved for
// future use. (See gtk_accel_map_save().)
//
// This function is a low level function that would most likely be used by a
// menu creation system like UIManager. If you use UIManager, setting up
// accelerator paths will be done automatically.
//
// Even when you you aren’t using UIManager, if you only want to set up
// accelerators on menu items gtk_menu_item_set_accel_path() provides a
// somewhat more convenient interface.
//
// Note that @accel_path string will be stored in a #GQuark. Therefore, if
// you pass a static string, you can save some memory by interning it first
// with g_intern_static_string().
func (w widget) SetAccelPath(accelPath string, accelGroup AccelGroup) {
	var arg0 *C.GtkWidget
	var arg1 *C.gchar
	var arg2 *C.GtkAccelGroup

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (*C.gchar)(C.CString(accelPath))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GtkAccelGroup)(unsafe.Pointer(accelGroup.Native()))

	C.gtk_widget_set_accel_path(arg0, arg1, arg2)
}

// SetAppPaintable sets whether the application intends to draw on the
// widget in an Widget::draw handler.
//
// This is a hint to the widget and does not affect the behavior of the GTK+
// core; many widgets ignore this flag entirely. For widgets that do pay
// attention to the flag, such as EventBox and Window, the effect is to
// suppress default themed drawing of the widget's background. (Children of
// the widget will still be drawn.) The application is then entirely
// responsible for drawing the widget background.
//
// Note that the background is still drawn when the widget is mapped.
func (w widget) SetAppPaintable(appPaintable bool) {
	var arg0 *C.GtkWidget
	var arg1 C.gboolean

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	if appPaintable {
		arg1 = C.gboolean(1)
	}

	C.gtk_widget_set_app_paintable(arg0, arg1)
}

// SetCanDefault specifies whether @widget can be a default widget. See
// gtk_widget_grab_default() for details about the meaning of “default”.
func (w widget) SetCanDefault(canDefault bool) {
	var arg0 *C.GtkWidget
	var arg1 C.gboolean

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	if canDefault {
		arg1 = C.gboolean(1)
	}

	C.gtk_widget_set_can_default(arg0, arg1)
}

// SetCanFocus specifies whether @widget can own the input focus. See
// gtk_widget_grab_focus() for actually setting the input focus on a widget.
func (w widget) SetCanFocus(canFocus bool) {
	var arg0 *C.GtkWidget
	var arg1 C.gboolean

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	if canFocus {
		arg1 = C.gboolean(1)
	}

	C.gtk_widget_set_can_focus(arg0, arg1)
}

// SetChildVisible sets whether @widget should be mapped along with its when
// its parent is mapped and @widget has been shown with gtk_widget_show().
//
// The child visibility can be set for widget before it is added to a
// container with gtk_widget_set_parent(), to avoid mapping children
// unnecessary before immediately unmapping them. However it will be reset
// to its default state of true when the widget is removed from a container.
//
// Note that changing the child visibility of a widget does not queue a
// resize on the widget. Most of the time, the size of a widget is computed
// from all visible children, whether or not they are mapped. If this is not
// the case, the container can queue a resize itself.
//
// This function is only useful for container implementations and never
// should be called by an application.
func (w widget) SetChildVisible(isVisible bool) {
	var arg0 *C.GtkWidget
	var arg1 C.gboolean

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	if isVisible {
		arg1 = C.gboolean(1)
	}

	C.gtk_widget_set_child_visible(arg0, arg1)
}

// SetCompositeName sets a widgets composite name. The widget must be a
// composite child of its parent; see gtk_widget_push_composite_child().
func (w widget) SetCompositeName(name string) {
	var arg0 *C.GtkWidget
	var arg1 *C.gchar

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_widget_set_composite_name(arg0, arg1)
}

// SetDeviceEnabled enables or disables a Device to interact with @widget
// and all its children.
//
// It does so by descending through the Window hierarchy and enabling the
// same mask that is has for core events (i.e. the one that
// gdk_window_get_events() returns).
func (w widget) SetDeviceEnabled(device gdk.Device, enabled bool) {
	var arg0 *C.GtkWidget
	var arg1 *C.GdkDevice
	var arg2 C.gboolean

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (*C.GdkDevice)(unsafe.Pointer(device.Native()))
	if enabled {
		arg2 = C.gboolean(1)
	}

	C.gtk_widget_set_device_enabled(arg0, arg1, arg2)
}

// SetDeviceEvents sets the device event mask (see EventMask) for a widget.
// The event mask determines which events a widget will receive from
// @device. Keep in mind that different widgets have different default event
// masks, and by changing the event mask you may disrupt a widget’s
// functionality, so be careful. This function must be called while a widget
// is unrealized. Consider gtk_widget_add_device_events() for widgets that
// are already realized, or if you want to preserve the existing event mask.
// This function can’t be used with windowless widgets (which return false
// from gtk_widget_get_has_window()); to get events on those widgets, place
// them inside a EventBox and receive events on the event box.
func (w widget) SetDeviceEvents(device gdk.Device, events gdk.EventMask) {
	var arg0 *C.GtkWidget
	var arg1 *C.GdkDevice
	var arg2 C.GdkEventMask

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (*C.GdkDevice)(unsafe.Pointer(device.Native()))
	arg2 = (C.GdkEventMask)(events)

	C.gtk_widget_set_device_events(arg0, arg1, arg2)
}

// SetDirection sets the reading direction on a particular widget. This
// direction controls the primary direction for widgets containing text, and
// also the direction in which the children of a container are packed. The
// ability to set the direction is present in order so that correct
// localization into languages with right-to-left reading directions can be
// done. Generally, applications will let the default reading direction
// present, except for containers where the containers are arranged in an
// order that is explicitly visual rather than logical (such as buttons for
// text justification).
//
// If the direction is set to GTK_TEXT_DIR_NONE, then the value set by
// gtk_widget_set_default_direction() will be used.
func (w widget) SetDirection(dir TextDirection) {
	var arg0 *C.GtkWidget
	var arg1 C.GtkTextDirection

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (C.GtkTextDirection)(dir)

	C.gtk_widget_set_direction(arg0, arg1)
}

// SetDoubleBuffered widgets are double buffered by default; you can use
// this function to turn off the buffering. “Double buffered” simply means
// that gdk_window_begin_draw_frame() and gdk_window_end_draw_frame() are
// called automatically around expose events sent to the widget.
// gdk_window_begin_draw_frame() diverts all drawing to a widget's window to
// an offscreen buffer, and gdk_window_end_draw_frame() draws the buffer to
// the screen. The result is that users see the window update in one smooth
// step, and don’t see individual graphics primitives being rendered.
//
// In very simple terms, double buffered widgets don’t flicker, so you would
// only use this function to turn off double buffering if you had special
// needs and really knew what you were doing.
//
// Note: if you turn off double-buffering, you have to handle expose events,
// since even the clearing to the background color or pixmap will not happen
// automatically (as it is done in gdk_window_begin_draw_frame()).
//
// In 3.10 GTK and GDK have been restructured for translucent drawing. Since
// then expose events for double-buffered widgets are culled into a single
// event to the toplevel GDK window. If you now unset double buffering, you
// will cause a separate rendering pass for every widget. This will likely
// cause rendering problems - in particular related to stacking - and
// usually increases rendering times significantly.
func (w widget) SetDoubleBuffered(doubleBuffered bool) {
	var arg0 *C.GtkWidget
	var arg1 C.gboolean

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	if doubleBuffered {
		arg1 = C.gboolean(1)
	}

	C.gtk_widget_set_double_buffered(arg0, arg1)
}

// SetEvents sets the event mask (see EventMask) for a widget. The event
// mask determines which events a widget will receive. Keep in mind that
// different widgets have different default event masks, and by changing the
// event mask you may disrupt a widget’s functionality, so be careful. This
// function must be called while a widget is unrealized. Consider
// gtk_widget_add_events() for widgets that are already realized, or if you
// want to preserve the existing event mask. This function can’t be used
// with widgets that have no window. (See gtk_widget_get_has_window()). To
// get events on those widgets, place them inside a EventBox and receive
// events on the event box.
func (w widget) SetEvents(events int) {
	var arg0 *C.GtkWidget
	var arg1 C.gint

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = C.gint(events)

	C.gtk_widget_set_events(arg0, arg1)
}

// SetFocusOnClick sets whether the widget should grab focus when it is
// clicked with the mouse. Making mouse clicks not grab focus is useful in
// places like toolbars where you don’t want the keyboard focus removed from
// the main area of the application.
func (w widget) SetFocusOnClick(focusOnClick bool) {
	var arg0 *C.GtkWidget
	var arg1 C.gboolean

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	if focusOnClick {
		arg1 = C.gboolean(1)
	}

	C.gtk_widget_set_focus_on_click(arg0, arg1)
}

// SetFontMap sets the font map to use for Pango rendering. When not set,
// the widget will inherit the font map from its parent.
func (w widget) SetFontMap(fontMap pango.FontMap) {
	var arg0 *C.GtkWidget
	var arg1 *C.PangoFontMap

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (*C.PangoFontMap)(unsafe.Pointer(fontMap.Native()))

	C.gtk_widget_set_font_map(arg0, arg1)
}

// SetFontOptions sets the #cairo_font_options_t used for Pango rendering in
// this widget. When not set, the default font options for the Screen will
// be used.
func (w widget) SetFontOptions(options *cairo.FontOptions) {
	var arg0 *C.GtkWidget
	var arg1 *C.cairo_font_options_t

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (*C.cairo_font_options_t)(unsafe.Pointer(options.Native()))

	C.gtk_widget_set_font_options(arg0, arg1)
}

// SetHalign sets the horizontal alignment of @widget. See the Widget:halign
// property.
func (w widget) SetHalign(align Align) {
	var arg0 *C.GtkWidget
	var arg1 C.GtkAlign

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (C.GtkAlign)(align)

	C.gtk_widget_set_halign(arg0, arg1)
}

// SetHasTooltip sets the has-tooltip property on @widget to @has_tooltip.
// See Widget:has-tooltip for more information.
func (w widget) SetHasTooltip(hasTooltip bool) {
	var arg0 *C.GtkWidget
	var arg1 C.gboolean

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	if hasTooltip {
		arg1 = C.gboolean(1)
	}

	C.gtk_widget_set_has_tooltip(arg0, arg1)
}

// SetHasWindow specifies whether @widget has a Window of its own. Note that
// all realized widgets have a non-nil “window” pointer
// (gtk_widget_get_window() never returns a nil window when a widget is
// realized), but for many of them it’s actually the Window of one of its
// parent widgets. Widgets that do not create a window for themselves in
// Widget::realize must announce this by calling this function with
// @has_window = false.
//
// This function should only be called by widget implementations, and they
// should call it in their init() function.
func (w widget) SetHasWindow(hasWindow bool) {
	var arg0 *C.GtkWidget
	var arg1 C.gboolean

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	if hasWindow {
		arg1 = C.gboolean(1)
	}

	C.gtk_widget_set_has_window(arg0, arg1)
}

// SetHexpand sets whether the widget would like any available extra
// horizontal space. When a user resizes a Window, widgets with expand=TRUE
// generally receive the extra space. For example, a list or scrollable area
// or document in your window would often be set to expand.
//
// Call this function to set the expand flag if you would like your widget
// to become larger horizontally when the window has extra room.
//
// By default, widgets automatically expand if any of their children want to
// expand. (To see if a widget will automatically expand given its current
// children and state, call gtk_widget_compute_expand(). A container can
// decide how the expandability of children affects the expansion of the
// container by overriding the compute_expand virtual method on Widget.).
//
// Setting hexpand explicitly with this function will override the automatic
// expand behavior.
//
// This function forces the widget to expand or not to expand, regardless of
// children. The override occurs because gtk_widget_set_hexpand() sets the
// hexpand-set property (see gtk_widget_set_hexpand_set()) which causes the
// widget’s hexpand value to be used, rather than looking at children and
// widget state.
func (w widget) SetHexpand(expand bool) {
	var arg0 *C.GtkWidget
	var arg1 C.gboolean

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	if expand {
		arg1 = C.gboolean(1)
	}

	C.gtk_widget_set_hexpand(arg0, arg1)
}

// SetHexpandSet sets whether the hexpand flag (see
// gtk_widget_get_hexpand()) will be used.
//
// The hexpand-set property will be set automatically when you call
// gtk_widget_set_hexpand() to set hexpand, so the most likely reason to use
// this function would be to unset an explicit expand flag.
//
// If hexpand is set, then it overrides any computed expand value based on
// child widgets. If hexpand is not set, then the expand value depends on
// whether any children of the widget would like to expand.
//
// There are few reasons to use this function, but it’s here for
// completeness and consistency.
func (w widget) SetHexpandSet(set bool) {
	var arg0 *C.GtkWidget
	var arg1 C.gboolean

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	if set {
		arg1 = C.gboolean(1)
	}

	C.gtk_widget_set_hexpand_set(arg0, arg1)
}

// SetMapped marks the widget as being mapped.
//
// This function should only ever be called in a derived widget's “map” or
// “unmap” implementation.
func (w widget) SetMapped(mapped bool) {
	var arg0 *C.GtkWidget
	var arg1 C.gboolean

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	if mapped {
		arg1 = C.gboolean(1)
	}

	C.gtk_widget_set_mapped(arg0, arg1)
}

// SetMarginBottom sets the bottom margin of @widget. See the
// Widget:margin-bottom property.
func (w widget) SetMarginBottom(margin int) {
	var arg0 *C.GtkWidget
	var arg1 C.gint

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = C.gint(margin)

	C.gtk_widget_set_margin_bottom(arg0, arg1)
}

// SetMarginEnd sets the end margin of @widget. See the Widget:margin-end
// property.
func (w widget) SetMarginEnd(margin int) {
	var arg0 *C.GtkWidget
	var arg1 C.gint

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = C.gint(margin)

	C.gtk_widget_set_margin_end(arg0, arg1)
}

// SetMarginLeft sets the left margin of @widget. See the Widget:margin-left
// property.
func (w widget) SetMarginLeft(margin int) {
	var arg0 *C.GtkWidget
	var arg1 C.gint

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = C.gint(margin)

	C.gtk_widget_set_margin_left(arg0, arg1)
}

// SetMarginRight sets the right margin of @widget. See the
// Widget:margin-right property.
func (w widget) SetMarginRight(margin int) {
	var arg0 *C.GtkWidget
	var arg1 C.gint

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = C.gint(margin)

	C.gtk_widget_set_margin_right(arg0, arg1)
}

// SetMarginStart sets the start margin of @widget. See the
// Widget:margin-start property.
func (w widget) SetMarginStart(margin int) {
	var arg0 *C.GtkWidget
	var arg1 C.gint

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = C.gint(margin)

	C.gtk_widget_set_margin_start(arg0, arg1)
}

// SetMarginTop sets the top margin of @widget. See the Widget:margin-top
// property.
func (w widget) SetMarginTop(margin int) {
	var arg0 *C.GtkWidget
	var arg1 C.gint

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = C.gint(margin)

	C.gtk_widget_set_margin_top(arg0, arg1)
}

// SetName widgets can be named, which allows you to refer to them from a
// CSS file. You can apply a style to widgets with a particular name in the
// CSS file. See the documentation for the CSS syntax (on the same page as
// the docs for StyleContext).
//
// Note that the CSS syntax has certain special characters to delimit and
// represent elements in a selector (period, #, >, *...), so using these
// will make your widget impossible to match by name. Any combination of
// alphanumeric symbols, dashes and underscores will suffice.
func (w widget) SetName(name string) {
	var arg0 *C.GtkWidget
	var arg1 *C.gchar

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_widget_set_name(arg0, arg1)
}

// SetNoShowAll sets the Widget:no-show-all property, which determines
// whether calls to gtk_widget_show_all() will affect this widget.
//
// This is mostly for use in constructing widget hierarchies with externally
// controlled visibility, see UIManager.
func (w widget) SetNoShowAll(noShowAll bool) {
	var arg0 *C.GtkWidget
	var arg1 C.gboolean

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	if noShowAll {
		arg1 = C.gboolean(1)
	}

	C.gtk_widget_set_no_show_all(arg0, arg1)
}

// SetOpacity: request the @widget to be rendered partially transparent,
// with opacity 0 being fully transparent and 1 fully opaque. (Opacity
// values are clamped to the [0,1] range.). This works on both toplevel
// widget, and child widgets, although there are some limitations:
//
// For toplevel widgets this depends on the capabilities of the windowing
// system. On X11 this has any effect only on X screens with a compositing
// manager running. See gtk_widget_is_composited(). On Windows it should
// work always, although setting a window’s opacity after the window has
// been shown causes it to flicker once on Windows.
//
// For child widgets it doesn’t work if any affected widget has a native
// window, or disables double buffering.
func (w widget) SetOpacity(opacity float64) {
	var arg0 *C.GtkWidget
	var arg1 C.double

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = C.double(opacity)

	C.gtk_widget_set_opacity(arg0, arg1)
}

// SetParent: this function is useful only when implementing subclasses of
// Container. Sets the container as the parent of @widget, and takes care of
// some details such as updating the state and style of the child to reflect
// its new location. The opposite function is gtk_widget_unparent().
func (w widget) SetParent(parent Widget) {
	var arg0 *C.GtkWidget
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(parent.Native()))

	C.gtk_widget_set_parent(arg0, arg1)
}

// SetParentWindow sets a non default parent window for @widget.
//
// For Window classes, setting a @parent_window effects whether the window
// is a toplevel window or can be embedded into other widgets.
//
// For Window classes, this needs to be called before the window is
// realized.
func (w widget) SetParentWindow(parentWindow gdk.Window) {
	var arg0 *C.GtkWidget
	var arg1 *C.GdkWindow

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (*C.GdkWindow)(unsafe.Pointer(parentWindow.Native()))

	C.gtk_widget_set_parent_window(arg0, arg1)
}

// SetRealized marks the widget as being realized. This function must only
// be called after all Windows for the @widget have been created and
// registered.
//
// This function should only ever be called in a derived widget's “realize”
// or “unrealize” implementation.
func (w widget) SetRealized(realized bool) {
	var arg0 *C.GtkWidget
	var arg1 C.gboolean

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	if realized {
		arg1 = C.gboolean(1)
	}

	C.gtk_widget_set_realized(arg0, arg1)
}

// SetReceivesDefault specifies whether @widget will be treated as the
// default widget within its toplevel when it has the focus, even if another
// widget is the default.
//
// See gtk_widget_grab_default() for details about the meaning of “default”.
func (w widget) SetReceivesDefault(receivesDefault bool) {
	var arg0 *C.GtkWidget
	var arg1 C.gboolean

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	if receivesDefault {
		arg1 = C.gboolean(1)
	}

	C.gtk_widget_set_receives_default(arg0, arg1)
}

// SetRedrawOnAllocate sets whether the entire widget is queued for drawing
// when its size allocation changes. By default, this setting is true and
// the entire widget is redrawn on every size change. If your widget leaves
// the upper left unchanged when made bigger, turning this setting off will
// improve performance.
//
// Note that for widgets where gtk_widget_get_has_window() is false setting
// this flag to false turns off all allocation on resizing: the widget will
// not even redraw if its position changes; this is to allow containers that
// don’t draw anything to avoid excess invalidations. If you set this flag
// on a widget with no window that does draw on @widget->window, you are
// responsible for invalidating both the old and new allocation of the
// widget when the widget is moved and responsible for invalidating regions
// newly when the widget increases size.
func (w widget) SetRedrawOnAllocate(redrawOnAllocate bool) {
	var arg0 *C.GtkWidget
	var arg1 C.gboolean

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	if redrawOnAllocate {
		arg1 = C.gboolean(1)
	}

	C.gtk_widget_set_redraw_on_allocate(arg0, arg1)
}

// SetSensitive sets the sensitivity of a widget. A widget is sensitive if
// the user can interact with it. Insensitive widgets are “grayed out” and
// the user can’t interact with them. Insensitive widgets are known as
// “inactive”, “disabled”, or “ghosted” in some other toolkits.
func (w widget) SetSensitive(sensitive bool) {
	var arg0 *C.GtkWidget
	var arg1 C.gboolean

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	if sensitive {
		arg1 = C.gboolean(1)
	}

	C.gtk_widget_set_sensitive(arg0, arg1)
}

// SetSizeRequest sets the minimum size of a widget; that is, the widget’s
// size request will be at least @width by @height. You can use this
// function to force a widget to be larger than it normally would be.
//
// In most cases, gtk_window_set_default_size() is a better choice for
// toplevel windows than this function; setting the default size will still
// allow users to shrink the window. Setting the size request will force
// them to leave the window at least as large as the size request. When
// dealing with window sizes, gtk_window_set_geometry_hints() can be a
// useful function as well.
//
// Note the inherent danger of setting any fixed size - themes, translations
// into other languages, different fonts, and user action can all change the
// appropriate size for a given widget. So, it's basically impossible to
// hardcode a size that will always be correct.
//
// The size request of a widget is the smallest size a widget can accept
// while still functioning well and drawing itself correctly. However in
// some strange cases a widget may be allocated less than its requested
// size, and in many cases a widget may be allocated more space than it
// requested.
//
// If the size request in a given direction is -1 (unset), then the
// “natural” size request of the widget will be used instead.
//
// The size request set here does not include any margin from the Widget
// properties margin-left, margin-right, margin-top, and margin-bottom, but
// it does include pretty much all other padding or border properties set by
// any subclass of Widget.
func (w widget) SetSizeRequest(width int, height int) {
	var arg0 *C.GtkWidget
	var arg1 C.gint
	var arg2 C.gint

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = C.gint(width)
	arg2 = C.gint(height)

	C.gtk_widget_set_size_request(arg0, arg1, arg2)
}

// SetState: this function is for use in widget implementations. Sets the
// state of a widget (insensitive, prelighted, etc.) Usually you should set
// the state using wrapper functions such as gtk_widget_set_sensitive().
func (w widget) SetState(state StateType) {
	var arg0 *C.GtkWidget
	var arg1 C.GtkStateType

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (C.GtkStateType)(state)

	C.gtk_widget_set_state(arg0, arg1)
}

// SetStateFlags: this function is for use in widget implementations. Turns
// on flag values in the current widget state (insensitive, prelighted,
// etc.).
//
// This function accepts the values GTK_STATE_FLAG_DIR_LTR and
// GTK_STATE_FLAG_DIR_RTL but ignores them. If you want to set the widget's
// direction, use gtk_widget_set_direction().
//
// It is worth mentioning that any other state than
// GTK_STATE_FLAG_INSENSITIVE, will be propagated down to all non-internal
// children if @widget is a Container, while GTK_STATE_FLAG_INSENSITIVE
// itself will be propagated down to all Container children by different
// means than turning on the state flag down the hierarchy, both
// gtk_widget_get_state_flags() and gtk_widget_is_sensitive() will make use
// of these.
func (w widget) SetStateFlags(flags StateFlags, clear bool) {
	var arg0 *C.GtkWidget
	var arg1 C.GtkStateFlags
	var arg2 C.gboolean

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (C.GtkStateFlags)(flags)
	if clear {
		arg2 = C.gboolean(1)
	}

	C.gtk_widget_set_state_flags(arg0, arg1, arg2)
}

// SetStyle: used to set the Style for a widget (@widget->style). Since GTK
// 3, this function does nothing, the passed in style is ignored.
func (w widget) SetStyle(style Style) {
	var arg0 *C.GtkWidget
	var arg1 *C.GtkStyle

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (*C.GtkStyle)(unsafe.Pointer(style.Native()))

	C.gtk_widget_set_style(arg0, arg1)
}

// SetSupportMultidevice enables or disables multiple pointer awareness. If
// this setting is true, @widget will start receiving multiple, per device
// enter/leave events. Note that if custom Windows are created in
// Widget::realize, gdk_window_set_support_multidevice() will have to be
// called manually on them.
func (w widget) SetSupportMultidevice(supportMultidevice bool) {
	var arg0 *C.GtkWidget
	var arg1 C.gboolean

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	if supportMultidevice {
		arg1 = C.gboolean(1)
	}

	C.gtk_widget_set_support_multidevice(arg0, arg1)
}

// SetTooltipMarkup sets @markup as the contents of the tooltip, which is
// marked up with the [Pango text markup language][PangoMarkupFormat].
//
// This function will take care of setting Widget:has-tooltip to true and of
// the default handler for the Widget::query-tooltip signal.
//
// See also the Widget:tooltip-markup property and gtk_tooltip_set_markup().
func (w widget) SetTooltipMarkup(markup string) {
	var arg0 *C.GtkWidget
	var arg1 *C.gchar

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (*C.gchar)(C.CString(markup))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_widget_set_tooltip_markup(arg0, arg1)
}

// SetTooltipText sets @text as the contents of the tooltip. This function
// will take care of setting Widget:has-tooltip to true and of the default
// handler for the Widget::query-tooltip signal.
//
// See also the Widget:tooltip-text property and gtk_tooltip_set_text().
func (w widget) SetTooltipText(text string) {
	var arg0 *C.GtkWidget
	var arg1 *C.gchar

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_widget_set_tooltip_text(arg0, arg1)
}

// SetTooltipWindow replaces the default window used for displaying tooltips
// with @custom_window. GTK+ will take care of showing and hiding
// @custom_window at the right moment, to behave likewise as the default
// tooltip window. If @custom_window is nil, the default tooltip window will
// be used.
func (w widget) SetTooltipWindow(customWindow Window) {
	var arg0 *C.GtkWidget
	var arg1 *C.GtkWindow

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (*C.GtkWindow)(unsafe.Pointer(customWindow.Native()))

	C.gtk_widget_set_tooltip_window(arg0, arg1)
}

// SetValign sets the vertical alignment of @widget. See the Widget:valign
// property.
func (w widget) SetValign(align Align) {
	var arg0 *C.GtkWidget
	var arg1 C.GtkAlign

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (C.GtkAlign)(align)

	C.gtk_widget_set_valign(arg0, arg1)
}

// SetVexpand sets whether the widget would like any available extra
// vertical space.
//
// See gtk_widget_set_hexpand() for more detail.
func (w widget) SetVexpand(expand bool) {
	var arg0 *C.GtkWidget
	var arg1 C.gboolean

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	if expand {
		arg1 = C.gboolean(1)
	}

	C.gtk_widget_set_vexpand(arg0, arg1)
}

// SetVexpandSet sets whether the vexpand flag (see
// gtk_widget_get_vexpand()) will be used.
//
// See gtk_widget_set_hexpand_set() for more detail.
func (w widget) SetVexpandSet(set bool) {
	var arg0 *C.GtkWidget
	var arg1 C.gboolean

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	if set {
		arg1 = C.gboolean(1)
	}

	C.gtk_widget_set_vexpand_set(arg0, arg1)
}

// SetVisible sets the visibility state of @widget. Note that setting this
// to true doesn’t mean the widget is actually viewable, see
// gtk_widget_get_visible().
//
// This function simply calls gtk_widget_show() or gtk_widget_hide() but is
// nicer to use when the visibility of the widget depends on some condition.
func (w widget) SetVisible(visible bool) {
	var arg0 *C.GtkWidget
	var arg1 C.gboolean

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	if visible {
		arg1 = C.gboolean(1)
	}

	C.gtk_widget_set_visible(arg0, arg1)
}

// SetVisual sets the visual that should be used for by widget and its
// children for creating Windows. The visual must be on the same Screen as
// returned by gtk_widget_get_screen(), so handling the
// Widget::screen-changed signal is necessary.
//
// Setting a new @visual will not cause @widget to recreate its windows, so
// you should call this function before @widget is realized.
func (w widget) SetVisual(visual gdk.Visual) {
	var arg0 *C.GtkWidget
	var arg1 *C.GdkVisual

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (*C.GdkVisual)(unsafe.Pointer(visual.Native()))

	C.gtk_widget_set_visual(arg0, arg1)
}

// SetWindow sets a widget’s window. This function should only be used in a
// widget’s Widget::realize implementation. The window passed is usually
// either new window created with gdk_window_new(), or the window of its
// parent widget as returned by gtk_widget_get_parent_window().
//
// Widgets must indicate whether they will create their own Window by
// calling gtk_widget_set_has_window(). This is usually done in the widget’s
// init() function.
//
// Note that this function does not add any reference to @window.
func (w widget) SetWindow(window gdk.Window) {
	var arg0 *C.GtkWidget
	var arg1 *C.GdkWindow

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (*C.GdkWindow)(unsafe.Pointer(window.Native()))

	C.gtk_widget_set_window(arg0, arg1)
}

// ShapeCombineRegion sets a shape for this widget’s GDK window. This allows
// for transparent windows etc., see gdk_window_shape_combine_region() for
// more information.
func (w widget) ShapeCombineRegion(region *cairo.Region) {
	var arg0 *C.GtkWidget
	var arg1 *C.cairo_region_t

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (*C.cairo_region_t)(unsafe.Pointer(region.Native()))

	C.gtk_widget_shape_combine_region(arg0, arg1)
}

// Show flags a widget to be displayed. Any widget that isn’t shown will not
// appear on the screen. If you want to show all the widgets in a container,
// it’s easier to call gtk_widget_show_all() on the container, instead of
// individually showing the widgets.
//
// Remember that you have to show the containers containing a widget, in
// addition to the widget itself, before it will appear onscreen.
//
// When a toplevel container is shown, it is immediately realized and
// mapped; other shown widgets are realized and mapped when their toplevel
// container is realized and mapped.
func (w widget) Show() {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_show(arg0)
}

// ShowAll: recursively shows a widget, and any child widgets (if the widget
// is a container).
func (w widget) ShowAll() {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_show_all(arg0)
}

// ShowNow shows a widget. If the widget is an unmapped toplevel widget
// (i.e. a Window that has not yet been shown), enter the main loop and wait
// for the window to actually be mapped. Be careful; because the main loop
// is running, anything can happen during this function.
func (w widget) ShowNow() {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_show_now(arg0)
}

// SizeRequest: this function is typically used when implementing a
// Container subclass. Obtains the preferred size of a widget. The container
// uses this information to arrange its child widgets and decide what size
// allocations to give them with gtk_widget_size_allocate().
//
// You can also call this function from an application, with some caveats.
// Most notably, getting a size request requires the widget to be associated
// with a screen, because font information may be needed. Multihead-aware
// applications should keep this in mind.
//
// Also remember that the size request is not necessarily the size a widget
// will actually be allocated.
func (w widget) SizeRequest() *Requisition {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	arg1 := new(C.GtkRequisition)
	var ret1 *Requisition

	C.gtk_widget_size_request(arg0, arg1)

	ret1 = WrapRequisition(unsafe.Pointer(arg1))

	return ret1
}

// StyleAttach: this function attaches the widget’s Style to the widget's
// Window. It is a replacement for
//
//    widget->style = gtk_style_attach (widget->style, widget->window);
//
// and should only ever be called in a derived widget’s “realize”
// implementation which does not chain up to its parent class' “realize”
// implementation, because one of the parent classes (finally Widget) would
// attach the style itself.
func (w widget) StyleAttach() {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_style_attach(arg0)
}

// StyleGetProperty gets the value of a style property of @widget.
func (w widget) StyleGetProperty(propertyName string, value *externglib.Value) {
	var arg0 *C.GtkWidget
	var arg1 *C.gchar
	var arg2 *C.GValue

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (*C.gchar)(C.CString(propertyName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GValue)(value.GValue)

	C.gtk_widget_style_get_property(arg0, arg1, arg2)
}

// ThawChildNotify reverts the effect of a previous call to
// gtk_widget_freeze_child_notify(). This causes all queued
// Widget::child-notify signals on @widget to be emitted.
func (w widget) ThawChildNotify() {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_thaw_child_notify(arg0)
}

// TranslateCoordinates: translate coordinates relative to @src_widget’s
// allocation to coordinates relative to @dest_widget’s allocations. In
// order to perform this operation, both widgets must be realized, and must
// share a common toplevel.
func (s widget) TranslateCoordinates(destWidget Widget, srcX int, srcY int) (destX int, destY int, ok bool) {
	var arg0 *C.GtkWidget
	var arg1 *C.GtkWidget
	var arg2 C.gint
	var arg3 C.gint

	arg0 = (*C.GtkWidget)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(destWidget.Native()))
	arg2 = C.gint(srcX)
	arg3 = C.gint(srcY)

	arg4 := new(C.gint)
	var ret4 int
	arg5 := new(C.gint)
	var ret5 int
	var cret C.gboolean
	var goret bool

	cret = C.gtk_widget_translate_coordinates(arg0, arg1, arg2, arg3, arg4, arg5)

	ret4 = int(*arg4)
	ret5 = int(*arg5)
	if cret {
		goret = true
	}

	return ret4, ret5, goret
}

// TriggerTooltipQuery triggers a tooltip query on the display where the
// toplevel of @widget is located. See gtk_tooltip_trigger_tooltip_query()
// for more information.
func (w widget) TriggerTooltipQuery() {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_trigger_tooltip_query(arg0)
}

// Unmap: this function is only for use in widget implementations. Causes a
// widget to be unmapped if it’s currently mapped.
func (w widget) Unmap() {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_unmap(arg0)
}

// Unparent: this function is only for use in widget implementations. Should
// be called by implementations of the remove method on Container, to
// dissociate a child from the container.
func (w widget) Unparent() {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_unparent(arg0)
}

// Unrealize: this function is only useful in widget implementations. Causes
// a widget to be unrealized (frees all GDK resources associated with the
// widget, such as @widget->window).
func (w widget) Unrealize() {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_unrealize(arg0)
}

// UnregisterWindow unregisters a Window from the widget that was previously
// set up with gtk_widget_register_window(). You need to call this when the
// window is no longer used by the widget, such as when you destroy it.
func (w widget) UnregisterWindow(window gdk.Window) {
	var arg0 *C.GtkWidget
	var arg1 *C.GdkWindow

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (*C.GdkWindow)(unsafe.Pointer(window.Native()))

	C.gtk_widget_unregister_window(arg0, arg1)
}

// UnsetStateFlags: this function is for use in widget implementations.
// Turns off flag values for the current widget state (insensitive,
// prelighted, etc.). See gtk_widget_set_state_flags().
func (w widget) UnsetStateFlags(flags StateFlags) {
	var arg0 *C.GtkWidget
	var arg1 C.GtkStateFlags

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (C.GtkStateFlags)(flags)

	C.gtk_widget_unset_state_flags(arg0, arg1)
}

// Requisition: a Requisition-struct represents the desired size of a widget.
// See [GtkWidget’s geometry management section][geometry-management] for more
// information.
type Requisition struct {
	native C.GtkRequisition
}

// WrapRequisition wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapRequisition(ptr unsafe.Pointer) *Requisition {
	if ptr == nil {
		return nil
	}

	return (*Requisition)(ptr)
}

func marshalRequisition(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapRequisition(unsafe.Pointer(b)), nil
}

// NewRequisition constructs a struct Requisition.
func NewRequisition() *Requisition {
	cret := new(C.GtkRequisition)
	var goret *Requisition

	cret = C.gtk_requisition_new()

	goret = WrapRequisition(unsafe.Pointer(cret))
	runtime.SetFinalizer(goret, func(v *Requisition) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return goret
}

// Native returns the underlying C source pointer.
func (r *Requisition) Native() unsafe.Pointer {
	return unsafe.Pointer(&r.native)
}

// Width gets the field inside the struct.
func (r *Requisition) Width() int {
	var v int
	v = int(r.native.width)
	return v
}

// Height gets the field inside the struct.
func (r *Requisition) Height() int {
	var v int
	v = int(r.native.height)
	return v
}

// Copy copies a Requisition.
func (r *Requisition) Copy() *Requisition {
	var arg0 *C.GtkRequisition

	arg0 = (*C.GtkRequisition)(unsafe.Pointer(r.Native()))

	cret := new(C.GtkRequisition)
	var goret *Requisition

	cret = C.gtk_requisition_copy(arg0)

	goret = WrapRequisition(unsafe.Pointer(cret))
	runtime.SetFinalizer(goret, func(v *Requisition) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return goret
}

// Free frees a Requisition.
func (r *Requisition) Free() {
	var arg0 *C.GtkRequisition

	arg0 = (*C.GtkRequisition)(unsafe.Pointer(r.Native()))

	C.gtk_requisition_free(arg0)
}
