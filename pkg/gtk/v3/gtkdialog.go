// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"unsafe"

	"github.com/diamondburned/gotk4/internal/gextras"
	"github.com/diamondburned/gotk4/pkg/gdk/v3"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config:
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <stdbool.h>
// #include <glib-object.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_dialog_get_type()), F: marshalDialog},
	})
}

// AlternativeDialogButtonOrder returns true if dialogs are expected to use an
// alternative button order on the screen @screen. See
// gtk_dialog_set_alternative_button_order() for more details about alternative
// button order.
//
// If you need to use this function, you should probably connect to the
// ::notify:gtk-alternative-button-order signal on the Settings object
// associated to @screen, in order to be notified if the button order setting
// changes.
func AlternativeDialogButtonOrder(screen gdk.Screen) bool {
	var arg1 *C.GdkScreen

	arg1 = (*C.GdkScreen)(unsafe.Pointer(screen.Native()))

	var cret C.gboolean
	var ret1 bool

	cret = C.gtk_alternative_dialog_button_order(screen)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// Dialog: dialog boxes are a convenient way to prompt the user for a small
// amount of input, e.g. to display a message, ask a question, or anything else
// that does not require extensive effort on the user’s part.
//
// GTK+ treats a dialog as a window split vertically. The top section is a VBox,
// and is where widgets such as a Label or a Entry should be packed. The bottom
// area is known as the “action area”. This is generally used for packing
// buttons into the dialog which may perform functions such as cancel, ok, or
// apply.
//
// Dialog boxes are created with a call to gtk_dialog_new() or
// gtk_dialog_new_with_buttons(). gtk_dialog_new_with_buttons() is recommended;
// it allows you to set the dialog title, some convenient flags, and add simple
// buttons.
//
// If “dialog” is a newly created dialog, the two primary areas of the window
// can be accessed through gtk_dialog_get_content_area() and
// gtk_dialog_get_action_area(), as can be seen from the example below.
//
// A “modal” dialog (that is, one which freezes the rest of the application from
// user input), can be created by calling gtk_window_set_modal() on the dialog.
// Use the GTK_WINDOW() macro to cast the widget returned from gtk_dialog_new()
// into a Window. When using gtk_dialog_new_with_buttons() you can also pass the
// K_DIALOG_MODAL flag to make a dialog modal.
//
// If you add buttons to Dialog using gtk_dialog_new_with_buttons(),
// gtk_dialog_add_button(), gtk_dialog_add_buttons(), or
// gtk_dialog_add_action_widget(), clicking the button will emit a signal called
// Dialog::response with a response ID that you specified. GTK+ will never
// assign a meaning to positive response IDs; these are entirely user-defined.
// But for convenience, you can use the response IDs in the ResponseType
// enumeration (these all have values less than zero). If a dialog receives a
// delete event, the Dialog::response signal will be emitted with a response ID
// of K_RESPONSE_DELETE_EVENT.
//
// If you want to block waiting for a dialog to return before returning control
// flow to your code, you can call gtk_dialog_run(). This function enters a
// recursive main loop and waits for the user to respond to the dialog,
// returning the response ID corresponding to the button the user clicked.
//
// For the simple dialog in the following example, in reality you’d probably use
// MessageDialog to save yourself some effort. But you’d need to create the
// dialog contents manually if you had more than a simple message in the dialog.
//
// An example for simple GtkDialog usage:
//
//    // Function to open a dialog box with a message
//    void
//    quick_message (GtkWindow *parent, gchar *message)
//    {
//     GtkWidget *dialog, *label, *content_area;
//     GtkDialogFlags flags;
//
//     // Create the widgets
//     flags = GTK_DIALOG_DESTROY_WITH_PARENT;
//     dialog = gtk_dialog_new_with_buttons ("Message",
//                                           parent,
//                                           flags,
//                                           _("_OK"),
//                                           GTK_RESPONSE_NONE,
//                                           NULL);
//     content_area = gtk_dialog_get_content_area (GTK_DIALOG (dialog));
//     label = gtk_label_new (message);
//
//     // Ensure that the dialog box is destroyed when the user responds
//
//     g_signal_connect_swapped (dialog,
//                               "response",
//                               G_CALLBACK (gtk_widget_destroy),
//                               dialog);
//
//     // Add the label, and show everything we’ve added
//
//     gtk_container_add (GTK_CONTAINER (content_area), label);
//     gtk_widget_show_all (dialog);
//    }
//
//
// GtkDialog as GtkBuildable
//
// The GtkDialog implementation of the Buildable interface exposes the @vbox and
// @action_area as internal children with the names “vbox” and “action_area”.
//
// GtkDialog supports a custom <action-widgets> element, which can contain
// multiple <action-widget> elements. The “response” attribute specifies a
// numeric response, and the content of the element is the id of widget (which
// should be a child of the dialogs @action_area). To mark a response as
// default, set the “default“ attribute of the <action-widget> element to true.
//
// GtkDialog supports adding action widgets by specifying “action“ as the “type“
// attribute of a <child> element. The widget will be added either to the action
// area or the headerbar of the dialog, depending on the “use-header-bar“
// property. The response id has to be associated with the action widget using
// the <action-widgets> element.
//
// An example of a Dialog UI definition fragment:
//
//    <object class="GtkDialog" id="dialog1">
//      <child type="action">
//        <object class="GtkButton" id="button_cancel"/>
//      </child>
//      <child type="action">
//        <object class="GtkButton" id="button_ok">
//          <property name="can-default">True</property>
//        </object>
//      </child>
//      <action-widgets>
//        <action-widget response="cancel">button_cancel</action-widget>
//        <action-widget response="ok" default="true">button_ok</action-widget>
//      </action-widgets>
//    </object>
type Dialog interface {
	Window
	Buildable

	// AddActionWidget adds an activatable widget to the action area of a
	// Dialog, connecting a signal handler that will emit the Dialog::response
	// signal on the dialog when the widget is activated. The widget is appended
	// to the end of the dialog’s action area. If you want to add a
	// non-activatable widget, simply pack it into the @action_area field of the
	// Dialog struct.
	AddActionWidget(child Widget, responseID int)
	// AddButton adds a button with the given text and sets things up so that
	// clicking the button will emit the Dialog::response signal with the given
	// @response_id. The button is appended to the end of the dialog’s action
	// area. The button widget is returned, but usually you don’t need it.
	AddButton(buttonText string, responseID int) Widget
	// ActionArea returns the action area of @dialog.
	ActionArea() Box
	// ContentArea returns the content area of @dialog.
	ContentArea() Box
	// HeaderBar returns the header bar of @dialog. Note that the headerbar is
	// only used by the dialog if the Dialog:use-header-bar property is true.
	HeaderBar() HeaderBar
	// ResponseForWidget gets the response id of a widget in the action area of
	// a dialog.
	ResponseForWidget(widget Widget) int
	// WidgetForResponse gets the widget button that uses the given response ID
	// in the action area of a dialog.
	WidgetForResponse(responseID int) Widget
	// Response emits the Dialog::response signal with the given response ID.
	// Used to indicate that the user has responded to the dialog in some way;
	// typically either you or gtk_dialog_run() will be monitoring the
	// ::response signal and take appropriate action.
	Response(responseID int)
	// Run blocks in a recursive main loop until the @dialog either emits the
	// Dialog::response signal, or is destroyed. If the dialog is destroyed
	// during the call to gtk_dialog_run(), gtk_dialog_run() returns
	// K_RESPONSE_NONE. Otherwise, it returns the response ID from the
	// ::response signal emission.
	//
	// Before entering the recursive main loop, gtk_dialog_run() calls
	// gtk_widget_show() on the dialog for you. Note that you still need to show
	// any children of the dialog yourself.
	//
	// During gtk_dialog_run(), the default behavior of Widget::delete-event is
	// disabled; if the dialog receives ::delete_event, it will not be destroyed
	// as windows usually are, and gtk_dialog_run() will return
	// K_RESPONSE_DELETE_EVENT. Also, during gtk_dialog_run() the dialog will be
	// modal. You can force gtk_dialog_run() to return at any time by calling
	// gtk_dialog_response() to emit the ::response signal. Destroying the
	// dialog during gtk_dialog_run() is a very bad idea, because your post-run
	// code won’t know whether the dialog was destroyed or not.
	//
	// After gtk_dialog_run() returns, you are responsible for hiding or
	// destroying the dialog if you wish to do so.
	//
	// Typical usage of this function might be:
	//
	//      GtkWidget *dialog = gtk_dialog_new ();
	//      // Set up dialog...
	//
	//      int result = gtk_dialog_run (GTK_DIALOG (dialog));
	//      switch (result)
	//        {
	//          case GTK_RESPONSE_ACCEPT:
	//             // do_application_specific_something ();
	//             break;
	//          default:
	//             // do_nothing_since_dialog_was_cancelled ();
	//             break;
	//        }
	//      gtk_widget_destroy (dialog);
	//
	// Note that even though the recursive main loop gives the effect of a modal
	// dialog (it prevents the user from interacting with other windows in the
	// same window group while the dialog is run), callbacks such as timeouts,
	// IO channel watches, DND drops, etc, will be triggered during a
	// gtk_dialog_run() call.
	Run() int
	// SetDefaultResponse sets the last widget in the dialog’s action area with
	// the given @response_id as the default widget for the dialog. Pressing
	// “Enter” normally activates the default widget.
	SetDefaultResponse(responseID int)
	// SetResponseSensitive calls `gtk_widget_set_sensitive (widget, @setting)`
	// for each widget in the dialog’s action area with the given @response_id.
	// A convenient way to sensitize/desensitize dialog buttons.
	SetResponseSensitive(responseID int, setting bool)
}

// dialog implements the Dialog interface.
type dialog struct {
	Window
	Buildable
}

var _ Dialog = (*dialog)(nil)

// WrapDialog wraps a GObject to the right type. It is
// primarily used internally.
func WrapDialog(obj *externglib.Object) Dialog {
	return Dialog{
		Window:    WrapWindow(obj),
		Buildable: WrapBuildable(obj),
	}
}

func marshalDialog(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDialog(obj), nil
}

// NewDialog constructs a class Dialog.
func NewDialog() Dialog {
	var cret C.GtkDialog
	var ret1 Dialog

	cret = C.gtk_dialog_new()

	ret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Dialog)

	return ret1
}

// AddActionWidget adds an activatable widget to the action area of a
// Dialog, connecting a signal handler that will emit the Dialog::response
// signal on the dialog when the widget is activated. The widget is appended
// to the end of the dialog’s action area. If you want to add a
// non-activatable widget, simply pack it into the @action_area field of the
// Dialog struct.
func (d dialog) AddActionWidget(child Widget, responseID int) {
	var arg0 *C.GtkDialog
	var arg1 *C.GtkWidget
	var arg2 C.gint

	arg0 = (*C.GtkDialog)(unsafe.Pointer(d.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	arg2 = C.gint(responseID)

	C.gtk_dialog_add_action_widget(arg0, child, responseID)
}

// AddButton adds a button with the given text and sets things up so that
// clicking the button will emit the Dialog::response signal with the given
// @response_id. The button is appended to the end of the dialog’s action
// area. The button widget is returned, but usually you don’t need it.
func (d dialog) AddButton(buttonText string, responseID int) Widget {
	var arg0 *C.GtkDialog
	var arg1 *C.gchar
	var arg2 C.gint

	arg0 = (*C.GtkDialog)(unsafe.Pointer(d.Native()))
	arg1 = (*C.gchar)(C.CString(buttonText))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gint(responseID)

	var cret *C.GtkWidget
	var ret1 Widget

	cret = C.gtk_dialog_add_button(arg0, buttonText, responseID)

	ret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Widget)

	return ret1
}

// ActionArea returns the action area of @dialog.
func (d dialog) ActionArea() Box {
	var arg0 *C.GtkDialog

	arg0 = (*C.GtkDialog)(unsafe.Pointer(d.Native()))

	var cret *C.GtkWidget
	var ret1 Box

	cret = C.gtk_dialog_get_action_area(arg0)

	ret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Box)

	return ret1
}

// ContentArea returns the content area of @dialog.
func (d dialog) ContentArea() Box {
	var arg0 *C.GtkDialog

	arg0 = (*C.GtkDialog)(unsafe.Pointer(d.Native()))

	var cret *C.GtkWidget
	var ret1 Box

	cret = C.gtk_dialog_get_content_area(arg0)

	ret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Box)

	return ret1
}

// HeaderBar returns the header bar of @dialog. Note that the headerbar is
// only used by the dialog if the Dialog:use-header-bar property is true.
func (d dialog) HeaderBar() HeaderBar {
	var arg0 *C.GtkDialog

	arg0 = (*C.GtkDialog)(unsafe.Pointer(d.Native()))

	var cret *C.GtkWidget
	var ret1 HeaderBar

	cret = C.gtk_dialog_get_header_bar(arg0)

	ret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(HeaderBar)

	return ret1
}

// ResponseForWidget gets the response id of a widget in the action area of
// a dialog.
func (d dialog) ResponseForWidget(widget Widget) int {
	var arg0 *C.GtkDialog
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkDialog)(unsafe.Pointer(d.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	var cret C.gint
	var ret1 int

	cret = C.gtk_dialog_get_response_for_widget(arg0, widget)

	ret1 = C.gint(cret)

	return ret1
}

// WidgetForResponse gets the widget button that uses the given response ID
// in the action area of a dialog.
func (d dialog) WidgetForResponse(responseID int) Widget {
	var arg0 *C.GtkDialog
	var arg1 C.gint

	arg0 = (*C.GtkDialog)(unsafe.Pointer(d.Native()))
	arg1 = C.gint(responseID)

	var cret *C.GtkWidget
	var ret1 Widget

	cret = C.gtk_dialog_get_widget_for_response(arg0, responseID)

	ret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Widget)

	return ret1
}

// Response emits the Dialog::response signal with the given response ID.
// Used to indicate that the user has responded to the dialog in some way;
// typically either you or gtk_dialog_run() will be monitoring the
// ::response signal and take appropriate action.
func (d dialog) Response(responseID int) {
	var arg0 *C.GtkDialog
	var arg1 C.gint

	arg0 = (*C.GtkDialog)(unsafe.Pointer(d.Native()))
	arg1 = C.gint(responseID)

	C.gtk_dialog_response(arg0, responseID)
}

// Run blocks in a recursive main loop until the @dialog either emits the
// Dialog::response signal, or is destroyed. If the dialog is destroyed
// during the call to gtk_dialog_run(), gtk_dialog_run() returns
// K_RESPONSE_NONE. Otherwise, it returns the response ID from the
// ::response signal emission.
//
// Before entering the recursive main loop, gtk_dialog_run() calls
// gtk_widget_show() on the dialog for you. Note that you still need to show
// any children of the dialog yourself.
//
// During gtk_dialog_run(), the default behavior of Widget::delete-event is
// disabled; if the dialog receives ::delete_event, it will not be destroyed
// as windows usually are, and gtk_dialog_run() will return
// K_RESPONSE_DELETE_EVENT. Also, during gtk_dialog_run() the dialog will be
// modal. You can force gtk_dialog_run() to return at any time by calling
// gtk_dialog_response() to emit the ::response signal. Destroying the
// dialog during gtk_dialog_run() is a very bad idea, because your post-run
// code won’t know whether the dialog was destroyed or not.
//
// After gtk_dialog_run() returns, you are responsible for hiding or
// destroying the dialog if you wish to do so.
//
// Typical usage of this function might be:
//
//      GtkWidget *dialog = gtk_dialog_new ();
//      // Set up dialog...
//
//      int result = gtk_dialog_run (GTK_DIALOG (dialog));
//      switch (result)
//        {
//          case GTK_RESPONSE_ACCEPT:
//             // do_application_specific_something ();
//             break;
//          default:
//             // do_nothing_since_dialog_was_cancelled ();
//             break;
//        }
//      gtk_widget_destroy (dialog);
//
// Note that even though the recursive main loop gives the effect of a modal
// dialog (it prevents the user from interacting with other windows in the
// same window group while the dialog is run), callbacks such as timeouts,
// IO channel watches, DND drops, etc, will be triggered during a
// gtk_dialog_run() call.
func (d dialog) Run() int {
	var arg0 *C.GtkDialog

	arg0 = (*C.GtkDialog)(unsafe.Pointer(d.Native()))

	var cret C.gint
	var ret1 int

	cret = C.gtk_dialog_run(arg0)

	ret1 = C.gint(cret)

	return ret1
}

// SetDefaultResponse sets the last widget in the dialog’s action area with
// the given @response_id as the default widget for the dialog. Pressing
// “Enter” normally activates the default widget.
func (d dialog) SetDefaultResponse(responseID int) {
	var arg0 *C.GtkDialog
	var arg1 C.gint

	arg0 = (*C.GtkDialog)(unsafe.Pointer(d.Native()))
	arg1 = C.gint(responseID)

	C.gtk_dialog_set_default_response(arg0, responseID)
}

// SetResponseSensitive calls `gtk_widget_set_sensitive (widget, @setting)`
// for each widget in the dialog’s action area with the given @response_id.
// A convenient way to sensitize/desensitize dialog buttons.
func (d dialog) SetResponseSensitive(responseID int, setting bool) {
	var arg0 *C.GtkDialog
	var arg1 C.gint
	var arg2 C.gboolean

	arg0 = (*C.GtkDialog)(unsafe.Pointer(d.Native()))
	arg1 = C.gint(responseID)
	if setting {
		arg2 = C.gboolean(1)
	}

	C.gtk_dialog_set_response_sensitive(arg0, responseID, setting)
}

type DialogPrivate struct {
	native C.GtkDialogPrivate
}

// WrapDialogPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapDialogPrivate(ptr unsafe.Pointer) *DialogPrivate {
	if ptr == nil {
		return nil
	}

	return (*DialogPrivate)(ptr)
}

func marshalDialogPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapDialogPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (d *DialogPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&d.native)
}
