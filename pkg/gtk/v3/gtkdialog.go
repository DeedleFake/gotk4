// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"unsafe"

	"github.com/diamondburned/gotk4/core/gextras"
	"github.com/diamondburned/gotk4/pkg/gdk/v3"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gtk+-3.0
// #cgo CFLAGS: -Wno-deprecated-declarations
//
// #include <glib-object.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_response_type_get_type()), F: marshalResponseType},
		{T: externglib.Type(C.gtk_dialog_flags_get_type()), F: marshalDialogFlags},
		{T: externglib.Type(C.gtk_dialog_get_type()), F: marshalDialog},
	})
}

// ResponseType: predefined values for use as response ids in
// gtk_dialog_add_button(). All predefined values are negative; GTK+ leaves
// values of 0 or greater for application-defined response ids.
type ResponseType int

const (
	// none: returned if an action widget has no response id, or if the dialog
	// gets programmatically hidden or destroyed
	ResponseTypeNone ResponseType = -1
	// reject: generic response id, not used by GTK+ dialogs
	ResponseTypeReject ResponseType = -2
	// accept: generic response id, not used by GTK+ dialogs
	ResponseTypeAccept ResponseType = -3
	// DeleteEvent: returned if the dialog is deleted
	ResponseTypeDeleteEvent ResponseType = -4
	// ok: returned by OK buttons in GTK+ dialogs
	ResponseTypeOk ResponseType = -5
	// cancel: returned by Cancel buttons in GTK+ dialogs
	ResponseTypeCancel ResponseType = -6
	// close: returned by Close buttons in GTK+ dialogs
	ResponseTypeClose ResponseType = -7
	// yes: returned by Yes buttons in GTK+ dialogs
	ResponseTypeYes ResponseType = -8
	// no: returned by No buttons in GTK+ dialogs
	ResponseTypeNo ResponseType = -9
	// apply: returned by Apply buttons in GTK+ dialogs
	ResponseTypeApply ResponseType = -10
	// help: returned by Help buttons in GTK+ dialogs
	ResponseTypeHelp ResponseType = -11
)

func marshalResponseType(p uintptr) (interface{}, error) {
	return ResponseType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DialogFlags flags used to influence dialog construction.
type DialogFlags int

const (
	// DialogFlagsModal: make the constructed dialog modal, see
	// gtk_window_set_modal()
	DialogFlagsModal DialogFlags = 0b1
	// DialogFlagsDestroyWithParent: destroy the dialog when its parent is
	// destroyed, see gtk_window_set_destroy_with_parent()
	DialogFlagsDestroyWithParent DialogFlags = 0b10
	// DialogFlagsUseHeaderBar: create dialog with actions in header bar instead
	// of action area. Since 3.12.
	DialogFlagsUseHeaderBar DialogFlags = 0b100
)

func marshalDialogFlags(p uintptr) (interface{}, error) {
	return DialogFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AlternativeDialogButtonOrder returns true if dialogs are expected to use an
// alternative button order on the screen @screen. See
// gtk_dialog_set_alternative_button_order() for more details about alternative
// button order.
//
// If you need to use this function, you should probably connect to the
// ::notify:gtk-alternative-button-order signal on the Settings object
// associated to @screen, in order to be notified if the button order setting
// changes.
//
// Deprecated: since version 3.10.
func AlternativeDialogButtonOrder(screen gdk.Screen) bool {
	var _arg1 *C.GdkScreen // out
	var _cret C.gboolean   // in

	_arg1 = (*C.GdkScreen)(unsafe.Pointer(screen.Native()))

	_cret = C.gtk_alternative_dialog_button_order(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Dialog: dialog boxes are a convenient way to prompt the user for a small
// amount of input, e.g. to display a message, ask a question, or anything else
// that does not require extensive effort on the user’s part.
//
// GTK+ treats a dialog as a window split vertically. The top section is a VBox,
// and is where widgets such as a Label or a Entry should be packed. The bottom
// area is known as the “action area”. This is generally used for packing
// buttons into the dialog which may perform functions such as cancel, ok, or
// apply.
//
// Dialog boxes are created with a call to gtk_dialog_new() or
// gtk_dialog_new_with_buttons(). gtk_dialog_new_with_buttons() is recommended;
// it allows you to set the dialog title, some convenient flags, and add simple
// buttons.
//
// If “dialog” is a newly created dialog, the two primary areas of the window
// can be accessed through gtk_dialog_get_content_area() and
// gtk_dialog_get_action_area(), as can be seen from the example below.
//
// A “modal” dialog (that is, one which freezes the rest of the application from
// user input), can be created by calling gtk_window_set_modal() on the dialog.
// Use the GTK_WINDOW() macro to cast the widget returned from gtk_dialog_new()
// into a Window. When using gtk_dialog_new_with_buttons() you can also pass the
// K_DIALOG_MODAL flag to make a dialog modal.
//
// If you add buttons to Dialog using gtk_dialog_new_with_buttons(),
// gtk_dialog_add_button(), gtk_dialog_add_buttons(), or
// gtk_dialog_add_action_widget(), clicking the button will emit a signal called
// Dialog::response with a response ID that you specified. GTK+ will never
// assign a meaning to positive response IDs; these are entirely user-defined.
// But for convenience, you can use the response IDs in the ResponseType
// enumeration (these all have values less than zero). If a dialog receives a
// delete event, the Dialog::response signal will be emitted with a response ID
// of K_RESPONSE_DELETE_EVENT.
//
// If you want to block waiting for a dialog to return before returning control
// flow to your code, you can call gtk_dialog_run(). This function enters a
// recursive main loop and waits for the user to respond to the dialog,
// returning the response ID corresponding to the button the user clicked.
//
// For the simple dialog in the following example, in reality you’d probably use
// MessageDialog to save yourself some effort. But you’d need to create the
// dialog contents manually if you had more than a simple message in the dialog.
//
// An example for simple GtkDialog usage:
//
//    // Function to open a dialog box with a message
//    void
//    quick_message (GtkWindow *parent, gchar *message)
//    {
//     GtkWidget *dialog, *label, *content_area;
//     GtkDialogFlags flags;
//
//     // Create the widgets
//     flags = GTK_DIALOG_DESTROY_WITH_PARENT;
//     dialog = gtk_dialog_new_with_buttons ("Message",
//                                           parent,
//                                           flags,
//                                           _("_OK"),
//                                           GTK_RESPONSE_NONE,
//                                           NULL);
//     content_area = gtk_dialog_get_content_area (GTK_DIALOG (dialog));
//     label = gtk_label_new (message);
//
//     // Ensure that the dialog box is destroyed when the user responds
//
//     g_signal_connect_swapped (dialog,
//                               "response",
//                               G_CALLBACK (gtk_widget_destroy),
//                               dialog);
//
//     // Add the label, and show everything we’ve added
//
//     gtk_container_add (GTK_CONTAINER (content_area), label);
//     gtk_widget_show_all (dialog);
//    }
//
//
// GtkDialog as GtkBuildable
//
// The GtkDialog implementation of the Buildable interface exposes the @vbox and
// @action_area as internal children with the names “vbox” and “action_area”.
//
// GtkDialog supports a custom <action-widgets> element, which can contain
// multiple <action-widget> elements. The “response” attribute specifies a
// numeric response, and the content of the element is the id of widget (which
// should be a child of the dialogs @action_area). To mark a response as
// default, set the “default“ attribute of the <action-widget> element to true.
//
// GtkDialog supports adding action widgets by specifying “action“ as the “type“
// attribute of a <child> element. The widget will be added either to the action
// area or the headerbar of the dialog, depending on the “use-header-bar“
// property. The response id has to be associated with the action widget using
// the <action-widgets> element.
//
// An example of a Dialog UI definition fragment:
//
//    <object class="GtkDialog" id="dialog1">
//      <child type="action">
//        <object class="GtkButton" id="button_cancel"/>
//      </child>
//      <child type="action">
//        <object class="GtkButton" id="button_ok">
//          <property name="can-default">True</property>
//        </object>
//      </child>
//      <action-widgets>
//        <action-widget response="cancel">button_cancel</action-widget>
//        <action-widget response="ok" default="true">button_ok</action-widget>
//      </action-widgets>
//    </object>
type Dialog interface {
	Window

	// AddActionWidgetDialog:
	AddActionWidgetDialog(child Widget, responseId int)
	// AddButtonDialog:
	AddButtonDialog(buttonText string, responseId int) Widget
	// ActionArea:
	ActionArea() Box
	// ContentArea:
	ContentArea() Box
	// HeaderBar:
	HeaderBar() HeaderBar
	// ResponseForWidget:
	ResponseForWidget(widget Widget) int
	// WidgetForResponse:
	WidgetForResponse(responseId int) Widget
	// ResponseDialog:
	ResponseDialog(responseId int)
	// RunDialog:
	RunDialog() int
	// SetAlternativeButtonOrderFromArrayDialog:
	SetAlternativeButtonOrderFromArrayDialog(newOrder []int)
	// SetDefaultResponseDialog:
	SetDefaultResponseDialog(responseId int)
	// SetResponseSensitiveDialog:
	SetResponseSensitiveDialog(responseId int, setting bool)
}

// dialog implements the Dialog class.
type dialog struct {
	Window
}

// WrapDialog wraps a GObject to the right type. It is
// primarily used internally.
func WrapDialog(obj *externglib.Object) Dialog {
	return dialog{
		Window: WrapWindow(obj),
	}
}

func marshalDialog(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDialog(obj), nil
}

// NewDialog:
func NewDialog() Dialog {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_dialog_new()

	var _dialog Dialog // out

	_dialog = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Dialog)

	return _dialog
}

func (d dialog) AddActionWidgetDialog(child Widget, responseId int) {
	var _arg0 *C.GtkDialog // out
	var _arg1 *C.GtkWidget // out
	var _arg2 C.gint       // out

	_arg0 = (*C.GtkDialog)(unsafe.Pointer(d.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = C.gint(responseId)

	C.gtk_dialog_add_action_widget(_arg0, _arg1, _arg2)
}

func (d dialog) AddButtonDialog(buttonText string, responseId int) Widget {
	var _arg0 *C.GtkDialog // out
	var _arg1 *C.gchar     // out
	var _arg2 C.gint       // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkDialog)(unsafe.Pointer(d.Native()))
	_arg1 = (*C.gchar)(C.CString(buttonText))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gint(responseId)

	_cret = C.gtk_dialog_add_button(_arg0, _arg1, _arg2)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

func (d dialog) ActionArea() Box {
	var _arg0 *C.GtkDialog // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkDialog)(unsafe.Pointer(d.Native()))

	_cret = C.gtk_dialog_get_action_area(_arg0)

	var _box Box // out

	_box = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Box)

	return _box
}

func (d dialog) ContentArea() Box {
	var _arg0 *C.GtkDialog // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkDialog)(unsafe.Pointer(d.Native()))

	_cret = C.gtk_dialog_get_content_area(_arg0)

	var _box Box // out

	_box = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Box)

	return _box
}

func (d dialog) HeaderBar() HeaderBar {
	var _arg0 *C.GtkDialog // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkDialog)(unsafe.Pointer(d.Native()))

	_cret = C.gtk_dialog_get_header_bar(_arg0)

	var _headerBar HeaderBar // out

	_headerBar = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(HeaderBar)

	return _headerBar
}

func (d dialog) ResponseForWidget(widget Widget) int {
	var _arg0 *C.GtkDialog // out
	var _arg1 *C.GtkWidget // out
	var _cret C.gint       // in

	_arg0 = (*C.GtkDialog)(unsafe.Pointer(d.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	_cret = C.gtk_dialog_get_response_for_widget(_arg0, _arg1)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

func (d dialog) WidgetForResponse(responseId int) Widget {
	var _arg0 *C.GtkDialog // out
	var _arg1 C.gint       // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkDialog)(unsafe.Pointer(d.Native()))
	_arg1 = C.gint(responseId)

	_cret = C.gtk_dialog_get_widget_for_response(_arg0, _arg1)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

func (d dialog) ResponseDialog(responseId int) {
	var _arg0 *C.GtkDialog // out
	var _arg1 C.gint       // out

	_arg0 = (*C.GtkDialog)(unsafe.Pointer(d.Native()))
	_arg1 = C.gint(responseId)

	C.gtk_dialog_response(_arg0, _arg1)
}

func (d dialog) RunDialog() int {
	var _arg0 *C.GtkDialog // out
	var _cret C.gint       // in

	_arg0 = (*C.GtkDialog)(unsafe.Pointer(d.Native()))

	_cret = C.gtk_dialog_run(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

func (d dialog) SetAlternativeButtonOrderFromArrayDialog(newOrder []int) {
	var _arg0 *C.GtkDialog // out
	var _arg2 *C.gint
	var _arg1 C.gint

	_arg0 = (*C.GtkDialog)(unsafe.Pointer(d.Native()))
	_arg1 = C.gint(len(newOrder))
	_arg2 = (*C.gint)(unsafe.Pointer(&newOrder[0]))

	C.gtk_dialog_set_alternative_button_order_from_array(_arg0, _arg1, _arg2)
}

func (d dialog) SetDefaultResponseDialog(responseId int) {
	var _arg0 *C.GtkDialog // out
	var _arg1 C.gint       // out

	_arg0 = (*C.GtkDialog)(unsafe.Pointer(d.Native()))
	_arg1 = C.gint(responseId)

	C.gtk_dialog_set_default_response(_arg0, _arg1)
}

func (d dialog) SetResponseSensitiveDialog(responseId int, setting bool) {
	var _arg0 *C.GtkDialog // out
	var _arg1 C.gint       // out
	var _arg2 C.gboolean   // out

	_arg0 = (*C.GtkDialog)(unsafe.Pointer(d.Native()))
	_arg1 = C.gint(responseId)
	if setting {
		_arg2 = C.TRUE
	}

	C.gtk_dialog_set_response_sensitive(_arg0, _arg1, _arg2)
}

func (b dialog) AddChild(builder Builder, child gextras.Objector, typ string) {
	WrapBuildable(gextras.InternObject(b)).AddChild(builder, child, typ)
}

func (b dialog) ConstructChild(builder Builder, name string) gextras.Objector {
	return WrapBuildable(gextras.InternObject(b)).ConstructChild(builder, name)
}

func (b dialog) InternalChild(builder Builder, childname string) gextras.Objector {
	return WrapBuildable(gextras.InternObject(b)).InternalChild(builder, childname)
}

func (b dialog) Name() string {
	return WrapBuildable(gextras.InternObject(b)).Name()
}

func (b dialog) ParserFinished(builder Builder) {
	WrapBuildable(gextras.InternObject(b)).ParserFinished(builder)
}

func (b dialog) SetBuildableProperty(builder Builder, name string, value externglib.Value) {
	WrapBuildable(gextras.InternObject(b)).SetBuildableProperty(builder, name, value)
}

func (b dialog) SetName(name string) {
	WrapBuildable(gextras.InternObject(b)).SetName(name)
}
