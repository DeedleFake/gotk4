// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"reflect"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/internal/gextras"
	"github.com/diamondburned/gotk4/pkg/cairo"
	"github.com/diamondburned/gotk4/pkg/gdk"
	"github.com/diamondburned/gotk4/pkg/gdkpixbuf"
	"github.com/diamondburned/gotk4/pkg/gio"
	"github.com/diamondburned/gotk4/pkg/glib"
	"github.com/diamondburned/gotk4/pkg/graphene"
	"github.com/diamondburned/gotk4/pkg/pango"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gtk4
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <gtk/gtk.h>
//
// extern int gotk4_AssistantPageFunc(int, gpointer)
// extern gboolean gotk4_CellAllocCallback(GtkCellRenderer*, const GdkRectangle*, const GdkRectangle*, gpointer)
// extern gboolean gotk4_CellCallback(GtkCellRenderer*, gpointer)
// extern void gotk4_CellLayoutDataFunc(GtkCellLayout*, GtkCellRenderer*, GtkTreeModel*, GtkTreeIter*, gpointer)
// extern gboolean gotk4_CustomFilterFunc(gpointer, gpointer)
// extern void gotk4_DrawingAreaDrawFunc(GtkDrawingArea*, cairo_t*, int, int, gpointer)
// extern gboolean gotk4_EntryCompletionMatchFunc(GtkEntryCompletion*, const char*, GtkTreeIter*, gpointer)
// extern void gotk4_ExpressionNotify(gpointer)
// extern GtkWidget* gotk4_FlowBoxCreateWidgetFunc(gpointer, gpointer)
// extern gboolean gotk4_FlowBoxFilterFunc(GtkFlowBoxChild*, gpointer)
// extern void gotk4_FlowBoxForeachFunc(GtkFlowBox*, GtkFlowBoxChild*, gpointer)
// extern int gotk4_FlowBoxSortFunc(GtkFlowBoxChild*, GtkFlowBoxChild*, gpointer)
// extern gboolean gotk4_FontFilterFunc(const PangoFontFamily*, const PangoFontFace*, gpointer)
// extern void gotk4_IconViewForeachFunc(GtkIconView*, GtkTreePath*, gpointer)
// extern GtkWidget* gotk4_ListBoxCreateWidgetFunc(gpointer, gpointer)
// extern gboolean gotk4_ListBoxFilterFunc(GtkListBoxRow*, gpointer)
// extern void gotk4_ListBoxForeachFunc(GtkListBox*, GtkListBoxRow*, gpointer)
// extern int gotk4_ListBoxSortFunc(GtkListBoxRow*, GtkListBoxRow*, gpointer)
// extern void gotk4_ListBoxUpdateHeaderFunc(GtkListBoxRow*, GtkListBoxRow*, gpointer)
// extern gpointer gotk4_MapListModelMapFunc(gpointer, gpointer)
// extern void gotk4_MenuButtonCreatePopupFunc(GtkMenuButton*, gpointer)
// extern void gotk4_PageSetupDoneFunc(GtkPageSetup*, gpointer)
// extern void gotk4_PrintSettingsFunc(const char*, const char*, gpointer)
// extern char* gotk4_ScaleFormatValueFunc(GtkScale*, double, gpointer)
// extern gboolean gotk4_ShortcutFunc(GtkWidget*, GVariant*, gpointer)
// extern gboolean gotk4_TextCharPredicate(gunichar, gpointer)
// extern void gotk4_TextTagTableForeach(GtkTextTag*, gpointer)
// extern gboolean gotk4_TickCallback(GtkWidget*, GdkFrameClock*, gpointer)
// extern void gotk4_TreeCellDataFunc(GtkTreeViewColumn*, GtkCellRenderer*, GtkTreeModel*, GtkTreeIter*, gpointer)
// extern int gotk4_TreeIterCompareFunc(GtkTreeModel*, GtkTreeIter*, GtkTreeIter*, gpointer)
// extern GListModel* gotk4_TreeListModelCreateModelFunc(gpointer, gpointer)
// extern void gotk4_TreeModelFilterModifyFunc(GtkTreeModel*, GtkTreeIter*, GValue*, int, gpointer)
// extern gboolean gotk4_TreeModelFilterVisibleFunc(GtkTreeModel*, GtkTreeIter*, gpointer)
// extern gboolean gotk4_TreeModelForeachFunc(GtkTreeModel*, GtkTreePath*, GtkTreeIter*, gpointer)
// extern void gotk4_TreeSelectionForeachFunc(GtkTreeModel*, GtkTreePath*, GtkTreeIter*, gpointer)
// extern gboolean gotk4_TreeSelectionFunc(GtkTreeSelection*, GtkTreeModel*, GtkTreePath*, gboolean, gpointer)
// extern gboolean gotk4_TreeViewColumnDropFunc(GtkTreeView*, GtkTreeViewColumn*, GtkTreeViewColumn*, GtkTreeViewColumn*, gpointer)
// extern void gotk4_TreeViewMappingFunc(GtkTreeView*, GtkTreePath*, gpointer)
// extern gboolean gotk4_TreeViewRowSeparatorFunc(GtkTreeModel*, GtkTreeIter*, gpointer)
// extern gboolean gotk4_TreeViewSearchEqualFunc(GtkTreeModel*, int, const char*, GtkTreeIter*, gpointer)
// // extern void callbackDelete(gpointer);
import "C"

//export callbackDelete
func callbackDelete(ptr C.gpointer) {
	box.Delete(box.Callback, uintptr(ptr))
}

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		// Enums
		{T: externglib.Type(C.gtk_accessible_autocomplete_get_type()), F: marshalAccessibleAutocomplete},
		{T: externglib.Type(C.gtk_accessible_invalid_state_get_type()), F: marshalAccessibleInvalidState},
		{T: externglib.Type(C.gtk_accessible_property_get_type()), F: marshalAccessibleProperty},
		{T: externglib.Type(C.gtk_accessible_relation_get_type()), F: marshalAccessibleRelation},
		{T: externglib.Type(C.gtk_accessible_role_get_type()), F: marshalAccessibleRole},
		{T: externglib.Type(C.gtk_accessible_sort_get_type()), F: marshalAccessibleSort},
		{T: externglib.Type(C.gtk_accessible_state_get_type()), F: marshalAccessibleState},
		{T: externglib.Type(C.gtk_accessible_tristate_get_type()), F: marshalAccessibleTristate},
		{T: externglib.Type(C.gtk_align_get_type()), F: marshalAlign},
		{T: externglib.Type(C.gtk_arrow_type_get_type()), F: marshalArrowType},
		{T: externglib.Type(C.gtk_assistant_page_type_get_type()), F: marshalAssistantPageType},
		{T: externglib.Type(C.gtk_baseline_position_get_type()), F: marshalBaselinePosition},
		{T: externglib.Type(C.gtk_border_style_get_type()), F: marshalBorderStyle},
		{T: externglib.Type(C.gtk_builder_error_get_type()), F: marshalBuilderError},
		{T: externglib.Type(C.gtk_buttons_type_get_type()), F: marshalButtonsType},
		{T: externglib.Type(C.gtk_cell_renderer_accel_mode_get_type()), F: marshalCellRendererAccelMode},
		{T: externglib.Type(C.gtk_cell_renderer_mode_get_type()), F: marshalCellRendererMode},
		{T: externglib.Type(C.gtk_constraint_attribute_get_type()), F: marshalConstraintAttribute},
		{T: externglib.Type(C.gtk_constraint_relation_get_type()), F: marshalConstraintRelation},
		{T: externglib.Type(C.gtk_constraint_strength_get_type()), F: marshalConstraintStrength},
		{T: externglib.Type(C.gtk_constraint_vfl_parser_error_get_type()), F: marshalConstraintVflParserError},
		{T: externglib.Type(C.gtk_corner_type_get_type()), F: marshalCornerType},
		// Skipped CssParserError.
		// Skipped CssParserWarning.
		{T: externglib.Type(C.gtk_delete_type_get_type()), F: marshalDeleteType},
		{T: externglib.Type(C.gtk_direction_type_get_type()), F: marshalDirectionType},
		{T: externglib.Type(C.gtk_editable_properties_get_type()), F: marshalEditableProperties},
		{T: externglib.Type(C.gtk_entry_icon_position_get_type()), F: marshalEntryIconPosition},
		{T: externglib.Type(C.gtk_event_sequence_state_get_type()), F: marshalEventSequenceState},
		{T: externglib.Type(C.gtk_file_chooser_action_get_type()), F: marshalFileChooserAction},
		{T: externglib.Type(C.gtk_file_chooser_error_get_type()), F: marshalFileChooserError},
		{T: externglib.Type(C.gtk_filter_change_get_type()), F: marshalFilterChange},
		{T: externglib.Type(C.gtk_filter_match_get_type()), F: marshalFilterMatch},
		{T: externglib.Type(C.gtk_icon_size_get_type()), F: marshalIconSize},
		{T: externglib.Type(C.gtk_icon_theme_error_get_type()), F: marshalIconThemeError},
		{T: externglib.Type(C.gtk_icon_view_drop_position_get_type()), F: marshalIconViewDropPosition},
		{T: externglib.Type(C.gtk_image_type_get_type()), F: marshalImageType},
		{T: externglib.Type(C.gtk_input_purpose_get_type()), F: marshalInputPurpose},
		{T: externglib.Type(C.gtk_justification_get_type()), F: marshalJustification},
		{T: externglib.Type(C.gtk_level_bar_mode_get_type()), F: marshalLevelBarMode},
		{T: externglib.Type(C.gtk_license_get_type()), F: marshalLicense},
		{T: externglib.Type(C.gtk_message_type_get_type()), F: marshalMessageType},
		{T: externglib.Type(C.gtk_movement_step_get_type()), F: marshalMovementStep},
		{T: externglib.Type(C.gtk_notebook_tab_get_type()), F: marshalNotebookTab},
		{T: externglib.Type(C.gtk_number_up_layout_get_type()), F: marshalNumberUpLayout},
		{T: externglib.Type(C.gtk_ordering_get_type()), F: marshalOrdering},
		{T: externglib.Type(C.gtk_orientation_get_type()), F: marshalOrientation},
		{T: externglib.Type(C.gtk_overflow_get_type()), F: marshalOverflow},
		{T: externglib.Type(C.gtk_pack_type_get_type()), F: marshalPackType},
		{T: externglib.Type(C.gtk_pad_action_type_get_type()), F: marshalPadActionType},
		{T: externglib.Type(C.gtk_page_orientation_get_type()), F: marshalPageOrientation},
		{T: externglib.Type(C.gtk_page_set_get_type()), F: marshalPageSet},
		{T: externglib.Type(C.gtk_pan_direction_get_type()), F: marshalPanDirection},
		{T: externglib.Type(C.gtk_policy_type_get_type()), F: marshalPolicyType},
		{T: externglib.Type(C.gtk_position_type_get_type()), F: marshalPositionType},
		{T: externglib.Type(C.gtk_print_duplex_get_type()), F: marshalPrintDuplex},
		{T: externglib.Type(C.gtk_print_error_get_type()), F: marshalPrintError},
		{T: externglib.Type(C.gtk_print_operation_action_get_type()), F: marshalPrintOperationAction},
		{T: externglib.Type(C.gtk_print_operation_result_get_type()), F: marshalPrintOperationResult},
		{T: externglib.Type(C.gtk_print_pages_get_type()), F: marshalPrintPages},
		{T: externglib.Type(C.gtk_print_quality_get_type()), F: marshalPrintQuality},
		{T: externglib.Type(C.gtk_print_status_get_type()), F: marshalPrintStatus},
		{T: externglib.Type(C.gtk_propagation_limit_get_type()), F: marshalPropagationLimit},
		{T: externglib.Type(C.gtk_propagation_phase_get_type()), F: marshalPropagationPhase},
		{T: externglib.Type(C.gtk_recent_manager_error_get_type()), F: marshalRecentManagerError},
		{T: externglib.Type(C.gtk_response_type_get_type()), F: marshalResponseType},
		{T: externglib.Type(C.gtk_revealer_transition_type_get_type()), F: marshalRevealerTransitionType},
		{T: externglib.Type(C.gtk_scroll_step_get_type()), F: marshalScrollStep},
		{T: externglib.Type(C.gtk_scroll_type_get_type()), F: marshalScrollType},
		{T: externglib.Type(C.gtk_scrollable_policy_get_type()), F: marshalScrollablePolicy},
		{T: externglib.Type(C.gtk_selection_mode_get_type()), F: marshalSelectionMode},
		{T: externglib.Type(C.gtk_sensitivity_type_get_type()), F: marshalSensitivityType},
		{T: externglib.Type(C.gtk_shortcut_scope_get_type()), F: marshalShortcutScope},
		{T: externglib.Type(C.gtk_shortcut_type_get_type()), F: marshalShortcutType},
		{T: externglib.Type(C.gtk_size_group_mode_get_type()), F: marshalSizeGroupMode},
		{T: externglib.Type(C.gtk_size_request_mode_get_type()), F: marshalSizeRequestMode},
		{T: externglib.Type(C.gtk_sort_type_get_type()), F: marshalSortType},
		{T: externglib.Type(C.gtk_sorter_change_get_type()), F: marshalSorterChange},
		{T: externglib.Type(C.gtk_sorter_order_get_type()), F: marshalSorterOrder},
		{T: externglib.Type(C.gtk_spin_button_update_policy_get_type()), F: marshalSpinButtonUpdatePolicy},
		{T: externglib.Type(C.gtk_spin_type_get_type()), F: marshalSpinType},
		{T: externglib.Type(C.gtk_stack_transition_type_get_type()), F: marshalStackTransitionType},
		{T: externglib.Type(C.gtk_string_filter_match_mode_get_type()), F: marshalStringFilterMatchMode},
		{T: externglib.Type(C.gtk_system_setting_get_type()), F: marshalSystemSetting},
		{T: externglib.Type(C.gtk_text_direction_get_type()), F: marshalTextDirection},
		{T: externglib.Type(C.gtk_text_extend_selection_get_type()), F: marshalTextExtendSelection},
		{T: externglib.Type(C.gtk_text_view_layer_get_type()), F: marshalTextViewLayer},
		{T: externglib.Type(C.gtk_text_window_type_get_type()), F: marshalTextWindowType},
		{T: externglib.Type(C.gtk_tree_view_column_sizing_get_type()), F: marshalTreeViewColumnSizing},
		{T: externglib.Type(C.gtk_tree_view_drop_position_get_type()), F: marshalTreeViewDropPosition},
		{T: externglib.Type(C.gtk_tree_view_grid_lines_get_type()), F: marshalTreeViewGridLines},
		{T: externglib.Type(C.gtk_unit_get_type()), F: marshalUnit},
		{T: externglib.Type(C.gtk_wrap_mode_get_type()), F: marshalWrapMode},

		// Records
		// Skipped ATContextClass.
		// Skipped AccessibleInterface.
		// Skipped ActionableInterface.
		// Skipped ActivateActionClass.
		// Skipped AdjustmentClass.
		// Skipped AlternativeTriggerClass.
		// Skipped AnyFilterClass.
		// Skipped ApplicationClass.
		// Skipped ApplicationWindowClass.
		// Skipped BinLayoutClass.
		{T: externglib.Type(C.gtk_bitset_get_type()), F: marshalBitset},
		// Skipped BitsetIter.
		// Skipped BookmarkListClass.
		// Skipped BoolFilterClass.
		{T: externglib.Type(C.gtk_border_get_type()), F: marshalBorder},
		// Skipped BoxClass.
		// Skipped BoxLayoutClass.
		// Skipped BuildableIface.
		// Skipped BuildableParseContext.
		// Skipped BuildableParser.
		// Skipped BuilderCScopeClass.
		// Skipped BuilderClass.
		// Skipped BuilderListItemFactoryClass.
		// Skipped BuilderScopeInterface.
		// Skipped ButtonClass.
		// Skipped ButtonPrivate.
		// Skipped CallbackActionClass.
		// Skipped CellAreaClass.
		// Skipped CellAreaContextClass.
		// Skipped CellAreaContextPrivate.
		// Skipped CellEditableIface.
		// Skipped CellLayoutIface.
		// Skipped CellRendererClass.
		// Skipped CellRendererClassPrivate.
		// Skipped CellRendererPrivate.
		// Skipped CellRendererTextClass.
		// Skipped CenterBoxClass.
		// Skipped CenterLayoutClass.
		// Skipped CheckButtonClass.
		// Skipped ColorChooserInterface.
		// Skipped ColumnViewClass.
		// Skipped ColumnViewColumnClass.
		// Skipped ComboBoxClass.
		// Skipped ConstraintClass.
		// Skipped ConstraintGuideClass.
		// Skipped ConstraintLayoutChildClass.
		// Skipped ConstraintLayoutClass.
		// Skipped ConstraintTargetInterface.
		// Skipped CssLocation.
		// Skipped CssProviderClass.
		// Skipped CssProviderPrivate.
		{T: externglib.Type(C.gtk_css_section_get_type()), F: marshalCSSSection},
		// Skipped CssStyleChange.
		// Skipped CustomFilterClass.
		// Skipped CustomLayoutClass.
		// Skipped CustomSorterClass.
		// Skipped DialogClass.
		// Skipped DirectoryListClass.
		// Skipped DragIconClass.
		// Skipped DragSourceClass.
		// Skipped DrawingAreaClass.
		// Skipped DropControllerMotionClass.
		// Skipped DropDownClass.
		// Skipped DropTargetAsyncClass.
		// Skipped DropTargetClass.
		// Skipped EditableInterface.
		// Skipped EditableLabelClass.
		// Skipped EmojiChooserClass.
		// Skipped EntryBufferClass.
		// Skipped EntryClass.
		// Skipped EventControllerClass.
		// Skipped EventControllerFocusClass.
		// Skipped EventControllerKeyClass.
		// Skipped EventControllerLegacyClass.
		// Skipped EventControllerMotionClass.
		// Skipped EventControllerScrollClass.
		// Skipped EveryFilterClass.
		// Skipped ExpressionWatch.
		// Skipped FileChooserNativeClass.
		// Skipped FilterClass.
		// Skipped FilterListModelClass.
		// Skipped FixedClass.
		// Skipped FixedLayoutChildClass.
		// Skipped FixedLayoutClass.
		// Skipped FlattenListModelClass.
		// Skipped FlowBoxChildClass.
		// Skipped FontChooserIface.
		// Skipped FrameClass.
		// Skipped GLAreaClass.
		// Skipped GestureClass.
		// Skipped GestureClickClass.
		// Skipped GestureDragClass.
		// Skipped GestureLongPressClass.
		// Skipped GesturePanClass.
		// Skipped GestureRotateClass.
		// Skipped GestureSingleClass.
		// Skipped GestureStylusClass.
		// Skipped GestureSwipeClass.
		// Skipped GestureZoomClass.
		// Skipped GridClass.
		// Skipped GridLayoutChildClass.
		// Skipped GridLayoutClass.
		// Skipped GridViewClass.
		// Skipped IMContextClass.
		// Skipped IMContextSimpleClass.
		// Skipped IMContextSimplePrivate.
		// Skipped IMMulticontextClass.
		// Skipped IMMulticontextPrivate.
		// Skipped KeyvalTriggerClass.
		// Skipped LayoutChildClass.
		// Skipped LayoutManagerClass.
		// Skipped ListBaseClass.
		// Skipped ListBoxRowClass.
		// Skipped ListItemClass.
		// Skipped ListItemFactoryClass.
		// Skipped ListStoreClass.
		// Skipped ListStorePrivate.
		// Skipped ListViewClass.
		// Skipped MapListModelClass.
		// Skipped MediaControlsClass.
		// Skipped MediaFileClass.
		// Skipped MediaStreamClass.
		// Skipped MessageDialogClass.
		// Skipped MnemonicActionClass.
		// Skipped MnemonicTriggerClass.
		// Skipped MountOperationClass.
		// Skipped MountOperationPrivate.
		// Skipped MultiFilterClass.
		// Skipped MultiSelectionClass.
		// Skipped MultiSorterClass.
		// Skipped NamedActionClass.
		// Skipped NativeDialogClass.
		// Skipped NativeInterface.
		// Skipped NeverTriggerClass.
		// Skipped NoSelectionClass.
		// Skipped NothingActionClass.
		// Skipped NumericSorterClass.
		// Skipped OrientableIface.
		// Skipped OverlayLayoutChildClass.
		// Skipped OverlayLayoutClass.
		// Skipped PadActionEntry.
		// Skipped PadControllerClass.
		// Skipped PageRange.
		{T: externglib.Type(C.gtk_paper_size_get_type()), F: marshalPaperSize},
		// Skipped PasswordEntryClass.
		// Skipped PictureClass.
		// Skipped PopoverClass.
		// Skipped PrintOperationClass.
		// Skipped PrintOperationPreviewIface.
		// Skipped PrintOperationPrivate.
		// Skipped RangeClass.
		// Skipped RecentData.
		{T: externglib.Type(C.gtk_recent_info_get_type()), F: marshalRecentInfo},
		// Skipped RecentManagerClass.
		// Skipped RecentManagerPrivate.
		// Skipped RequestedSize.
		{T: externglib.Type(C.gtk_requisition_get_type()), F: marshalRequisition},
		// Skipped RootInterface.
		// Skipped ScaleButtonClass.
		// Skipped ScaleClass.
		// Skipped ScrollableInterface.
		// Skipped SelectionFilterModelClass.
		// Skipped SelectionModelInterface.
		// Skipped SettingsValue.
		// Skipped ShortcutActionClass.
		// Skipped ShortcutClass.
		// Skipped ShortcutControllerClass.
		// Skipped ShortcutLabelClass.
		// Skipped ShortcutManagerInterface.
		// Skipped ShortcutTriggerClass.
		// Skipped ShortcutsGroupClass.
		// Skipped ShortcutsSectionClass.
		// Skipped ShortcutsShortcutClass.
		// Skipped SignalActionClass.
		// Skipped SignalListItemFactoryClass.
		// Skipped SingleSelectionClass.
		// Skipped SliceListModelClass.
		// Skipped SnapshotClass.
		// Skipped SortListModelClass.
		// Skipped SorterClass.
		// Skipped StringFilterClass.
		// Skipped StringListClass.
		// Skipped StringObjectClass.
		// Skipped StringSorterClass.
		// Skipped StyleContextClass.
		// Skipped TextBTree.
		// Skipped TextBufferClass.
		// Skipped TextBufferPrivate.
		// Skipped TextChildAnchorClass.
		{T: externglib.Type(C.gtk_text_iter_get_type()), F: marshalTextIter},
		// Skipped TextMarkClass.
		// Skipped TextTagClass.
		// Skipped TextTagPrivate.
		// Skipped TextViewClass.
		// Skipped TextViewPrivate.
		// Skipped ToggleButtonClass.
		// Skipped TreeDragDestIface.
		// Skipped TreeDragSourceIface.
		// Skipped TreeExpanderClass.
		{T: externglib.Type(C.gtk_tree_iter_get_type()), F: marshalTreeIter},
		// Skipped TreeListModelClass.
		// Skipped TreeListRowClass.
		// Skipped TreeListRowSorterClass.
		// Skipped TreeModelFilterClass.
		// Skipped TreeModelFilterPrivate.
		// Skipped TreeModelIface.
		// Skipped TreeModelSortClass.
		// Skipped TreeModelSortPrivate.
		{T: externglib.Type(C.gtk_tree_path_get_type()), F: marshalTreePath},
		{T: externglib.Type(C.gtk_tree_row_reference_get_type()), F: marshalTreeRowReference},
		// Skipped TreeSortableIface.
		// Skipped TreeStoreClass.
		// Skipped TreeStorePrivate.
		// Skipped TreeViewClass.
		// Skipped VideoClass.
		// Skipped WidgetClass.
		// Skipped WidgetClassPrivate.
		// Skipped WidgetPaintableClass.
		// Skipped WidgetPrivate.
		// Skipped WindowClass.
		// Skipped WindowControlsClass.
		// Skipped WindowGroupClass.
		// Skipped WindowGroupPrivate.
		// Skipped WindowHandleClass.

		// Classes
		{T: externglib.Type(C.gtk_at_context_get_type()), F: marshalATContext},
		{T: externglib.Type(C.gtk_about_dialog_get_type()), F: marshalAboutDialog},
		{T: externglib.Type(C.gtk_action_bar_get_type()), F: marshalActionBar},
		{T: externglib.Type(C.gtk_activate_action_get_type()), F: marshalActivateAction},
		{T: externglib.Type(C.gtk_adjustment_get_type()), F: marshalAdjustment},
		{T: externglib.Type(C.gtk_alternative_trigger_get_type()), F: marshalAlternativeTrigger},
		{T: externglib.Type(C.gtk_any_filter_get_type()), F: marshalAnyFilter},
		{T: externglib.Type(C.gtk_app_chooser_button_get_type()), F: marshalAppChooserButton},
		{T: externglib.Type(C.gtk_app_chooser_dialog_get_type()), F: marshalAppChooserDialog},
		{T: externglib.Type(C.gtk_app_chooser_widget_get_type()), F: marshalAppChooserWidget},
		{T: externglib.Type(C.gtk_application_get_type()), F: marshalApplication},
		{T: externglib.Type(C.gtk_application_window_get_type()), F: marshalApplicationWindow},
		{T: externglib.Type(C.gtk_aspect_frame_get_type()), F: marshalAspectFrame},
		{T: externglib.Type(C.gtk_assistant_get_type()), F: marshalAssistant},
		{T: externglib.Type(C.gtk_assistant_page_get_type()), F: marshalAssistantPage},
		{T: externglib.Type(C.gtk_bin_layout_get_type()), F: marshalBinLayout},
		{T: externglib.Type(C.gtk_bookmark_list_get_type()), F: marshalBookmarkList},
		{T: externglib.Type(C.gtk_bool_filter_get_type()), F: marshalBoolFilter},
		{T: externglib.Type(C.gtk_box_get_type()), F: marshalBox},
		{T: externglib.Type(C.gtk_box_layout_get_type()), F: marshalBoxLayout},
		{T: externglib.Type(C.gtk_builder_get_type()), F: marshalBuilder},
		{T: externglib.Type(C.gtk_builder_cscope_get_type()), F: marshalBuilderCScope},
		{T: externglib.Type(C.gtk_builder_list_item_factory_get_type()), F: marshalBuilderListItemFactory},
		{T: externglib.Type(C.gtk_button_get_type()), F: marshalButton},
		{T: externglib.Type(C.gtk_cclosure_expression_get_type()), F: marshalCClosureExpression},
		{T: externglib.Type(C.gtk_calendar_get_type()), F: marshalCalendar},
		{T: externglib.Type(C.gtk_callback_action_get_type()), F: marshalCallbackAction},
		{T: externglib.Type(C.gtk_cell_area_get_type()), F: marshalCellArea},
		{T: externglib.Type(C.gtk_cell_area_box_get_type()), F: marshalCellAreaBox},
		{T: externglib.Type(C.gtk_cell_area_context_get_type()), F: marshalCellAreaContext},
		{T: externglib.Type(C.gtk_cell_renderer_get_type()), F: marshalCellRenderer},
		{T: externglib.Type(C.gtk_cell_renderer_accel_get_type()), F: marshalCellRendererAccel},
		{T: externglib.Type(C.gtk_cell_renderer_combo_get_type()), F: marshalCellRendererCombo},
		{T: externglib.Type(C.gtk_cell_renderer_pixbuf_get_type()), F: marshalCellRendererPixbuf},
		{T: externglib.Type(C.gtk_cell_renderer_progress_get_type()), F: marshalCellRendererProgress},
		{T: externglib.Type(C.gtk_cell_renderer_spin_get_type()), F: marshalCellRendererSpin},
		{T: externglib.Type(C.gtk_cell_renderer_spinner_get_type()), F: marshalCellRendererSpinner},
		{T: externglib.Type(C.gtk_cell_renderer_text_get_type()), F: marshalCellRendererText},
		{T: externglib.Type(C.gtk_cell_renderer_toggle_get_type()), F: marshalCellRendererToggle},
		{T: externglib.Type(C.gtk_cell_view_get_type()), F: marshalCellView},
		{T: externglib.Type(C.gtk_center_box_get_type()), F: marshalCenterBox},
		{T: externglib.Type(C.gtk_center_layout_get_type()), F: marshalCenterLayout},
		{T: externglib.Type(C.gtk_check_button_get_type()), F: marshalCheckButton},
		{T: externglib.Type(C.gtk_closure_expression_get_type()), F: marshalClosureExpression},
		{T: externglib.Type(C.gtk_color_button_get_type()), F: marshalColorButton},
		{T: externglib.Type(C.gtk_color_chooser_dialog_get_type()), F: marshalColorChooserDialog},
		{T: externglib.Type(C.gtk_color_chooser_widget_get_type()), F: marshalColorChooserWidget},
		{T: externglib.Type(C.gtk_column_view_get_type()), F: marshalColumnView},
		{T: externglib.Type(C.gtk_column_view_column_get_type()), F: marshalColumnViewColumn},
		{T: externglib.Type(C.gtk_combo_box_get_type()), F: marshalComboBox},
		{T: externglib.Type(C.gtk_combo_box_text_get_type()), F: marshalComboBoxText},
		{T: externglib.Type(C.gtk_constant_expression_get_type()), F: marshalConstantExpression},
		{T: externglib.Type(C.gtk_constraint_get_type()), F: marshalConstraint},
		{T: externglib.Type(C.gtk_constraint_guide_get_type()), F: marshalConstraintGuide},
		{T: externglib.Type(C.gtk_constraint_layout_get_type()), F: marshalConstraintLayout},
		{T: externglib.Type(C.gtk_constraint_layout_child_get_type()), F: marshalConstraintLayoutChild},
		{T: externglib.Type(C.gtk_css_provider_get_type()), F: marshalCSSProvider},
		{T: externglib.Type(C.gtk_custom_filter_get_type()), F: marshalCustomFilter},
		{T: externglib.Type(C.gtk_custom_layout_get_type()), F: marshalCustomLayout},
		{T: externglib.Type(C.gtk_custom_sorter_get_type()), F: marshalCustomSorter},
		{T: externglib.Type(C.gtk_dialog_get_type()), F: marshalDialog},
		{T: externglib.Type(C.gtk_directory_list_get_type()), F: marshalDirectoryList},
		{T: externglib.Type(C.gtk_drag_icon_get_type()), F: marshalDragIcon},
		{T: externglib.Type(C.gtk_drag_source_get_type()), F: marshalDragSource},
		{T: externglib.Type(C.gtk_drawing_area_get_type()), F: marshalDrawingArea},
		{T: externglib.Type(C.gtk_drop_controller_motion_get_type()), F: marshalDropControllerMotion},
		{T: externglib.Type(C.gtk_drop_down_get_type()), F: marshalDropDown},
		{T: externglib.Type(C.gtk_drop_target_get_type()), F: marshalDropTarget},
		{T: externglib.Type(C.gtk_drop_target_async_get_type()), F: marshalDropTargetAsync},
		{T: externglib.Type(C.gtk_editable_label_get_type()), F: marshalEditableLabel},
		{T: externglib.Type(C.gtk_emoji_chooser_get_type()), F: marshalEmojiChooser},
		{T: externglib.Type(C.gtk_entry_get_type()), F: marshalEntry},
		{T: externglib.Type(C.gtk_entry_buffer_get_type()), F: marshalEntryBuffer},
		{T: externglib.Type(C.gtk_entry_completion_get_type()), F: marshalEntryCompletion},
		{T: externglib.Type(C.gtk_event_controller_get_type()), F: marshalEventController},
		{T: externglib.Type(C.gtk_event_controller_focus_get_type()), F: marshalEventControllerFocus},
		{T: externglib.Type(C.gtk_event_controller_key_get_type()), F: marshalEventControllerKey},
		{T: externglib.Type(C.gtk_event_controller_legacy_get_type()), F: marshalEventControllerLegacy},
		{T: externglib.Type(C.gtk_event_controller_motion_get_type()), F: marshalEventControllerMotion},
		{T: externglib.Type(C.gtk_event_controller_scroll_get_type()), F: marshalEventControllerScroll},
		{T: externglib.Type(C.gtk_every_filter_get_type()), F: marshalEveryFilter},
		{T: externglib.Type(C.gtk_expander_get_type()), F: marshalExpander},
		// Skipped Expression.
		{T: externglib.Type(C.gtk_file_chooser_dialog_get_type()), F: marshalFileChooserDialog},
		{T: externglib.Type(C.gtk_file_chooser_native_get_type()), F: marshalFileChooserNative},
		{T: externglib.Type(C.gtk_file_chooser_widget_get_type()), F: marshalFileChooserWidget},
		{T: externglib.Type(C.gtk_file_filter_get_type()), F: marshalFileFilter},
		{T: externglib.Type(C.gtk_filter_get_type()), F: marshalFilter},
		{T: externglib.Type(C.gtk_filter_list_model_get_type()), F: marshalFilterListModel},
		{T: externglib.Type(C.gtk_fixed_get_type()), F: marshalFixed},
		{T: externglib.Type(C.gtk_fixed_layout_get_type()), F: marshalFixedLayout},
		{T: externglib.Type(C.gtk_fixed_layout_child_get_type()), F: marshalFixedLayoutChild},
		{T: externglib.Type(C.gtk_flatten_list_model_get_type()), F: marshalFlattenListModel},
		{T: externglib.Type(C.gtk_flow_box_get_type()), F: marshalFlowBox},
		{T: externglib.Type(C.gtk_flow_box_child_get_type()), F: marshalFlowBoxChild},
		{T: externglib.Type(C.gtk_font_button_get_type()), F: marshalFontButton},
		{T: externglib.Type(C.gtk_font_chooser_dialog_get_type()), F: marshalFontChooserDialog},
		{T: externglib.Type(C.gtk_font_chooser_widget_get_type()), F: marshalFontChooserWidget},
		{T: externglib.Type(C.gtk_frame_get_type()), F: marshalFrame},
		{T: externglib.Type(C.gtk_gl_area_get_type()), F: marshalGLArea},
		{T: externglib.Type(C.gtk_gesture_get_type()), F: marshalGesture},
		{T: externglib.Type(C.gtk_gesture_click_get_type()), F: marshalGestureClick},
		{T: externglib.Type(C.gtk_gesture_drag_get_type()), F: marshalGestureDrag},
		{T: externglib.Type(C.gtk_gesture_long_press_get_type()), F: marshalGestureLongPress},
		{T: externglib.Type(C.gtk_gesture_pan_get_type()), F: marshalGesturePan},
		{T: externglib.Type(C.gtk_gesture_rotate_get_type()), F: marshalGestureRotate},
		{T: externglib.Type(C.gtk_gesture_single_get_type()), F: marshalGestureSingle},
		{T: externglib.Type(C.gtk_gesture_stylus_get_type()), F: marshalGestureStylus},
		{T: externglib.Type(C.gtk_gesture_swipe_get_type()), F: marshalGestureSwipe},
		{T: externglib.Type(C.gtk_gesture_zoom_get_type()), F: marshalGestureZoom},
		{T: externglib.Type(C.gtk_grid_get_type()), F: marshalGrid},
		{T: externglib.Type(C.gtk_grid_layout_get_type()), F: marshalGridLayout},
		{T: externglib.Type(C.gtk_grid_layout_child_get_type()), F: marshalGridLayoutChild},
		{T: externglib.Type(C.gtk_grid_view_get_type()), F: marshalGridView},
		{T: externglib.Type(C.gtk_header_bar_get_type()), F: marshalHeaderBar},
		{T: externglib.Type(C.gtk_im_context_get_type()), F: marshalIMContext},
		{T: externglib.Type(C.gtk_im_context_simple_get_type()), F: marshalIMContextSimple},
		{T: externglib.Type(C.gtk_im_multicontext_get_type()), F: marshalIMMulticontext},
		{T: externglib.Type(C.gtk_icon_paintable_get_type()), F: marshalIconPaintable},
		{T: externglib.Type(C.gtk_icon_theme_get_type()), F: marshalIconTheme},
		{T: externglib.Type(C.gtk_icon_view_get_type()), F: marshalIconView},
		{T: externglib.Type(C.gtk_image_get_type()), F: marshalImage},
		{T: externglib.Type(C.gtk_info_bar_get_type()), F: marshalInfoBar},
		{T: externglib.Type(C.gtk_keyval_trigger_get_type()), F: marshalKeyvalTrigger},
		{T: externglib.Type(C.gtk_label_get_type()), F: marshalLabel},
		{T: externglib.Type(C.gtk_layout_child_get_type()), F: marshalLayoutChild},
		{T: externglib.Type(C.gtk_layout_manager_get_type()), F: marshalLayoutManager},
		{T: externglib.Type(C.gtk_level_bar_get_type()), F: marshalLevelBar},
		{T: externglib.Type(C.gtk_link_button_get_type()), F: marshalLinkButton},
		{T: externglib.Type(C.gtk_list_base_get_type()), F: marshalListBase},
		{T: externglib.Type(C.gtk_list_box_get_type()), F: marshalListBox},
		{T: externglib.Type(C.gtk_list_box_row_get_type()), F: marshalListBoxRow},
		{T: externglib.Type(C.gtk_list_item_get_type()), F: marshalListItem},
		{T: externglib.Type(C.gtk_list_item_factory_get_type()), F: marshalListItemFactory},
		{T: externglib.Type(C.gtk_list_store_get_type()), F: marshalListStore},
		{T: externglib.Type(C.gtk_list_view_get_type()), F: marshalListView},
		{T: externglib.Type(C.gtk_lock_button_get_type()), F: marshalLockButton},
		{T: externglib.Type(C.gtk_map_list_model_get_type()), F: marshalMapListModel},
		{T: externglib.Type(C.gtk_media_controls_get_type()), F: marshalMediaControls},
		{T: externglib.Type(C.gtk_media_file_get_type()), F: marshalMediaFile},
		{T: externglib.Type(C.gtk_media_stream_get_type()), F: marshalMediaStream},
		{T: externglib.Type(C.gtk_menu_button_get_type()), F: marshalMenuButton},
		{T: externglib.Type(C.gtk_message_dialog_get_type()), F: marshalMessageDialog},
		{T: externglib.Type(C.gtk_mnemonic_action_get_type()), F: marshalMnemonicAction},
		{T: externglib.Type(C.gtk_mnemonic_trigger_get_type()), F: marshalMnemonicTrigger},
		{T: externglib.Type(C.gtk_mount_operation_get_type()), F: marshalMountOperation},
		{T: externglib.Type(C.gtk_multi_filter_get_type()), F: marshalMultiFilter},
		{T: externglib.Type(C.gtk_multi_selection_get_type()), F: marshalMultiSelection},
		{T: externglib.Type(C.gtk_multi_sorter_get_type()), F: marshalMultiSorter},
		{T: externglib.Type(C.gtk_named_action_get_type()), F: marshalNamedAction},
		{T: externglib.Type(C.gtk_native_dialog_get_type()), F: marshalNativeDialog},
		{T: externglib.Type(C.gtk_never_trigger_get_type()), F: marshalNeverTrigger},
		{T: externglib.Type(C.gtk_no_selection_get_type()), F: marshalNoSelection},
		{T: externglib.Type(C.gtk_notebook_get_type()), F: marshalNotebook},
		{T: externglib.Type(C.gtk_notebook_page_get_type()), F: marshalNotebookPage},
		{T: externglib.Type(C.gtk_nothing_action_get_type()), F: marshalNothingAction},
		{T: externglib.Type(C.gtk_numeric_sorter_get_type()), F: marshalNumericSorter},
		{T: externglib.Type(C.gtk_object_expression_get_type()), F: marshalObjectExpression},
		{T: externglib.Type(C.gtk_overlay_get_type()), F: marshalOverlay},
		{T: externglib.Type(C.gtk_overlay_layout_get_type()), F: marshalOverlayLayout},
		{T: externglib.Type(C.gtk_overlay_layout_child_get_type()), F: marshalOverlayLayoutChild},
		{T: externglib.Type(C.gtk_pad_controller_get_type()), F: marshalPadController},
		{T: externglib.Type(C.gtk_page_setup_get_type()), F: marshalPageSetup},
		{T: externglib.Type(C.gtk_paned_get_type()), F: marshalPaned},
		// Skipped ParamSpecExpression.
		{T: externglib.Type(C.gtk_password_entry_get_type()), F: marshalPasswordEntry},
		{T: externglib.Type(C.gtk_picture_get_type()), F: marshalPicture},
		{T: externglib.Type(C.gtk_popover_get_type()), F: marshalPopover},
		{T: externglib.Type(C.gtk_popover_menu_get_type()), F: marshalPopoverMenu},
		{T: externglib.Type(C.gtk_popover_menu_bar_get_type()), F: marshalPopoverMenuBar},
		{T: externglib.Type(C.gtk_print_context_get_type()), F: marshalPrintContext},
		{T: externglib.Type(C.gtk_print_operation_get_type()), F: marshalPrintOperation},
		{T: externglib.Type(C.gtk_print_settings_get_type()), F: marshalPrintSettings},
		{T: externglib.Type(C.gtk_progress_bar_get_type()), F: marshalProgressBar},
		{T: externglib.Type(C.gtk_property_expression_get_type()), F: marshalPropertyExpression},
		{T: externglib.Type(C.gtk_range_get_type()), F: marshalRange},
		{T: externglib.Type(C.gtk_recent_manager_get_type()), F: marshalRecentManager},
		{T: externglib.Type(C.gtk_revealer_get_type()), F: marshalRevealer},
		{T: externglib.Type(C.gtk_scale_get_type()), F: marshalScale},
		{T: externglib.Type(C.gtk_scale_button_get_type()), F: marshalScaleButton},
		{T: externglib.Type(C.gtk_scrollbar_get_type()), F: marshalScrollbar},
		{T: externglib.Type(C.gtk_scrolled_window_get_type()), F: marshalScrolledWindow},
		{T: externglib.Type(C.gtk_search_bar_get_type()), F: marshalSearchBar},
		{T: externglib.Type(C.gtk_search_entry_get_type()), F: marshalSearchEntry},
		{T: externglib.Type(C.gtk_selection_filter_model_get_type()), F: marshalSelectionFilterModel},
		{T: externglib.Type(C.gtk_separator_get_type()), F: marshalSeparator},
		{T: externglib.Type(C.gtk_settings_get_type()), F: marshalSettings},
		{T: externglib.Type(C.gtk_shortcut_get_type()), F: marshalShortcut},
		{T: externglib.Type(C.gtk_shortcut_action_get_type()), F: marshalShortcutAction},
		{T: externglib.Type(C.gtk_shortcut_controller_get_type()), F: marshalShortcutController},
		{T: externglib.Type(C.gtk_shortcut_label_get_type()), F: marshalShortcutLabel},
		{T: externglib.Type(C.gtk_shortcut_trigger_get_type()), F: marshalShortcutTrigger},
		{T: externglib.Type(C.gtk_shortcuts_group_get_type()), F: marshalShortcutsGroup},
		{T: externglib.Type(C.gtk_shortcuts_section_get_type()), F: marshalShortcutsSection},
		{T: externglib.Type(C.gtk_shortcuts_shortcut_get_type()), F: marshalShortcutsShortcut},
		{T: externglib.Type(C.gtk_shortcuts_window_get_type()), F: marshalShortcutsWindow},
		{T: externglib.Type(C.gtk_signal_action_get_type()), F: marshalSignalAction},
		{T: externglib.Type(C.gtk_signal_list_item_factory_get_type()), F: marshalSignalListItemFactory},
		{T: externglib.Type(C.gtk_single_selection_get_type()), F: marshalSingleSelection},
		{T: externglib.Type(C.gtk_size_group_get_type()), F: marshalSizeGroup},
		{T: externglib.Type(C.gtk_slice_list_model_get_type()), F: marshalSliceListModel},
		{T: externglib.Type(C.gtk_snapshot_get_type()), F: marshalSnapshot},
		{T: externglib.Type(C.gtk_sort_list_model_get_type()), F: marshalSortListModel},
		{T: externglib.Type(C.gtk_sorter_get_type()), F: marshalSorter},
		{T: externglib.Type(C.gtk_spin_button_get_type()), F: marshalSpinButton},
		{T: externglib.Type(C.gtk_spinner_get_type()), F: marshalSpinner},
		{T: externglib.Type(C.gtk_stack_get_type()), F: marshalStack},
		{T: externglib.Type(C.gtk_stack_page_get_type()), F: marshalStackPage},
		{T: externglib.Type(C.gtk_stack_sidebar_get_type()), F: marshalStackSidebar},
		{T: externglib.Type(C.gtk_stack_switcher_get_type()), F: marshalStackSwitcher},
		{T: externglib.Type(C.gtk_statusbar_get_type()), F: marshalStatusbar},
		{T: externglib.Type(C.gtk_string_filter_get_type()), F: marshalStringFilter},
		{T: externglib.Type(C.gtk_string_list_get_type()), F: marshalStringList},
		{T: externglib.Type(C.gtk_string_object_get_type()), F: marshalStringObject},
		{T: externglib.Type(C.gtk_string_sorter_get_type()), F: marshalStringSorter},
		{T: externglib.Type(C.gtk_style_context_get_type()), F: marshalStyleContext},
		{T: externglib.Type(C.gtk_switch_get_type()), F: marshalSwitch},
		{T: externglib.Type(C.gtk_text_get_type()), F: marshalText},
		{T: externglib.Type(C.gtk_text_buffer_get_type()), F: marshalTextBuffer},
		{T: externglib.Type(C.gtk_text_child_anchor_get_type()), F: marshalTextChildAnchor},
		{T: externglib.Type(C.gtk_text_mark_get_type()), F: marshalTextMark},
		{T: externglib.Type(C.gtk_text_tag_get_type()), F: marshalTextTag},
		{T: externglib.Type(C.gtk_text_tag_table_get_type()), F: marshalTextTagTable},
		{T: externglib.Type(C.gtk_text_view_get_type()), F: marshalTextView},
		{T: externglib.Type(C.gtk_toggle_button_get_type()), F: marshalToggleButton},
		{T: externglib.Type(C.gtk_tooltip_get_type()), F: marshalTooltip},
		{T: externglib.Type(C.gtk_tree_expander_get_type()), F: marshalTreeExpander},
		{T: externglib.Type(C.gtk_tree_list_model_get_type()), F: marshalTreeListModel},
		{T: externglib.Type(C.gtk_tree_list_row_get_type()), F: marshalTreeListRow},
		{T: externglib.Type(C.gtk_tree_list_row_sorter_get_type()), F: marshalTreeListRowSorter},
		{T: externglib.Type(C.gtk_tree_model_filter_get_type()), F: marshalTreeModelFilter},
		{T: externglib.Type(C.gtk_tree_model_sort_get_type()), F: marshalTreeModelSort},
		{T: externglib.Type(C.gtk_tree_selection_get_type()), F: marshalTreeSelection},
		{T: externglib.Type(C.gtk_tree_store_get_type()), F: marshalTreeStore},
		{T: externglib.Type(C.gtk_tree_view_get_type()), F: marshalTreeView},
		{T: externglib.Type(C.gtk_tree_view_column_get_type()), F: marshalTreeViewColumn},
		{T: externglib.Type(C.gtk_video_get_type()), F: marshalVideo},
		{T: externglib.Type(C.gtk_viewport_get_type()), F: marshalViewport},
		{T: externglib.Type(C.gtk_volume_button_get_type()), F: marshalVolumeButton},
		{T: externglib.Type(C.gtk_widget_get_type()), F: marshalWidget},
		{T: externglib.Type(C.gtk_widget_paintable_get_type()), F: marshalWidgetPaintable},
		{T: externglib.Type(C.gtk_window_get_type()), F: marshalWindow},
		{T: externglib.Type(C.gtk_window_controls_get_type()), F: marshalWindowControls},
		{T: externglib.Type(C.gtk_window_group_get_type()), F: marshalWindowGroup},
		{T: externglib.Type(C.gtk_window_handle_get_type()), F: marshalWindowHandle},
	})
}

// Allocation: a Allocation-struct of a widget represents region which has been
// allocated to the widget by its parent. It is a subregion of its parents
// allocation. See [GtkWidget’s geometry management
// section][geometry-management] for more information.
type Allocation gdk.Rectangle

// AccessibleAutocomplete: the possible values for the
// GTK_ACCESSIBLE_PROPERTY_AUTOCOMPLETE accessible property.
type AccessibleAutocomplete int

const (
	// AccessibleAutocompleteNone: automatic suggestions are not displayed.
	AccessibleAutocompleteNone AccessibleAutocomplete = 0
	// AccessibleAutocompleteInline: when a user is providing input, text
	// suggesting one way to complete the provided input may be dynamically
	// inserted after the caret.
	AccessibleAutocompleteInline AccessibleAutocomplete = 1
	// AccessibleAutocompleteList: when a user is providing input, an element
	// containing a collection of values that could complete the provided input
	// may be displayed.
	AccessibleAutocompleteList AccessibleAutocomplete = 2
	// AccessibleAutocompleteBoth: when a user is providing input, an element
	// containing a collection of values that could complete the provided input
	// may be displayed. If displayed, one value in the collection is
	// automatically selected, and the text needed to complete the automatically
	// selected value appears after the caret in the input.
	AccessibleAutocompleteBoth AccessibleAutocomplete = 3
)

func marshalAccessibleAutocomplete(p uintptr) (interface{}, error) {
	return AccessibleAutocomplete(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AccessibleInvalidState: the possible values for the
// GTK_ACCESSIBLE_STATE_INVALID accessible state.
//
// Note that the GTK_ACCESSIBLE_INVALID_FALSE and GTK_ACCESSIBLE_INVALID_TRUE
// have the same values as false and true.
type AccessibleInvalidState int

const (
	// AccessibleInvalidStateFalse: there are no detected errors in the value
	AccessibleInvalidStateFalse AccessibleInvalidState = 0
	// AccessibleInvalidStateTrue: the value entered by the user has failed
	// validation
	AccessibleInvalidStateTrue AccessibleInvalidState = 1
	// AccessibleInvalidStateGrammar: a grammatical error was detected
	AccessibleInvalidStateGrammar AccessibleInvalidState = 2
	// AccessibleInvalidStateSpelling: a spelling error was detected
	AccessibleInvalidStateSpelling AccessibleInvalidState = 3
)

func marshalAccessibleInvalidState(p uintptr) (interface{}, error) {
	return AccessibleInvalidState(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AccessibleProperty: the possible accessible properties of a Accessible.
type AccessibleProperty int

const (
	// AccessiblePropertyAutocomplete indicates whether inputting text could
	// trigger display of one or more predictions of the user's intended value
	// for a combobox, searchbox, or textbox and specifies how predictions would
	// be presented if they were made. Value type: AccessibleAutocomplete
	AccessiblePropertyAutocomplete AccessibleProperty = 0
	// AccessiblePropertyDescription defines a string value that describes or
	// annotates the current element. Value type: string
	AccessiblePropertyDescription AccessibleProperty = 1
	// AccessiblePropertyHasPopup indicates the availability and type of
	// interactive popup element, such as menu or dialog, that can be triggered
	// by an element.
	AccessiblePropertyHasPopup AccessibleProperty = 2
	// AccessiblePropertyKeyShortcuts indicates keyboard shortcuts that an
	// author has implemented to activate or give focus to an element. Value
	// type: string
	AccessiblePropertyKeyShortcuts AccessibleProperty = 3
	// AccessiblePropertyLabel defines a string value that labels the current
	// element. Value type: string
	AccessiblePropertyLabel AccessibleProperty = 4
	// AccessiblePropertyLevel defines the hierarchical level of an element
	// within a structure. Value type: integer
	AccessiblePropertyLevel AccessibleProperty = 5
	// AccessiblePropertyModal indicates whether an element is modal when
	// displayed. Value type: boolean
	AccessiblePropertyModal AccessibleProperty = 6
	// AccessiblePropertyMultiLine indicates whether a text box accepts multiple
	// lines of input or only a single line. Value type: boolean
	AccessiblePropertyMultiLine AccessibleProperty = 7
	// AccessiblePropertyMultiSelectable indicates that the user may select more
	// than one item from the current selectable descendants. Value type:
	// boolean
	AccessiblePropertyMultiSelectable AccessibleProperty = 8
	// AccessiblePropertyOrientation indicates whether the element's orientation
	// is horizontal, vertical, or unknown/ambiguous. Value type: Orientation
	AccessiblePropertyOrientation AccessibleProperty = 9
	// AccessiblePropertyPlaceholder defines a short hint (a word or short
	// phrase) intended to aid the user with data entry when the control has no
	// value. A hint could be a sample value or a brief description of the
	// expected format. Value type: string
	AccessiblePropertyPlaceholder AccessibleProperty = 10
	// AccessiblePropertyReadOnly indicates that the element is not editable,
	// but is otherwise operable. Value type: boolean
	AccessiblePropertyReadOnly AccessibleProperty = 11
	// AccessiblePropertyRequired indicates that user input is required on the
	// element before a form may be submitted. Value type: boolean
	AccessiblePropertyRequired AccessibleProperty = 12
	// AccessiblePropertyRoleDescription defines a human-readable,
	// author-localized description for the role of an element. Value type:
	// string
	AccessiblePropertyRoleDescription AccessibleProperty = 13
	// AccessiblePropertySort indicates if items in a table or grid are sorted
	// in ascending or descending order. Possible property values are in the
	// AccessibleSort enumeration. Value type: AccessibleSort
	AccessiblePropertySort AccessibleProperty = 14
	// AccessiblePropertyValueMax defines the maximum allowed value for a range
	// widget. Value type: double
	AccessiblePropertyValueMax AccessibleProperty = 15
	// AccessiblePropertyValueMin defines the minimum allowed value for a range
	// widget. Value type: double
	AccessiblePropertyValueMin AccessibleProperty = 16
	// AccessiblePropertyValueNow defines the current value for a range widget.
	// Value type: double
	AccessiblePropertyValueNow AccessibleProperty = 17
	// AccessiblePropertyValueText defines the human readable text alternative
	// of aria-valuenow for a range widget. Value type: string
	AccessiblePropertyValueText AccessibleProperty = 18
)

func marshalAccessibleProperty(p uintptr) (interface{}, error) {
	return AccessibleProperty(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AccessibleRelation: the possible accessible relations of a Accessible.
// Accessible relations can be references to other widgets, integers or strings.
type AccessibleRelation int

const (
	// AccessibleRelationActiveDescendant identifies the currently active
	// element when focus is on a composite widget, combobox, textbox, group, or
	// application. Value type: reference
	AccessibleRelationActiveDescendant AccessibleRelation = 0
	// AccessibleRelationColCount defines the total number of columns in a
	// table, grid, or treegrid. Value type: integer
	AccessibleRelationColCount AccessibleRelation = 1
	// AccessibleRelationColIndex defines an element's column index or position
	// with respect to the total number of columns within a table, grid, or
	// treegrid. Value type: integer
	AccessibleRelationColIndex AccessibleRelation = 2
	// AccessibleRelationColIndexText defines a human readable text alternative
	// of GTK_ACCESSIBLE_RELATION_COL_INDEX. Value type: string
	AccessibleRelationColIndexText AccessibleRelation = 3
	// AccessibleRelationColSpan defines the number of columns spanned by a cell
	// or gridcell within a table, grid, or treegrid. Value type: integer
	AccessibleRelationColSpan AccessibleRelation = 4
	// AccessibleRelationControls identifies the element (or elements) whose
	// contents or presence are controlled by the current element. Value type:
	// reference
	AccessibleRelationControls AccessibleRelation = 5
	// AccessibleRelationDescribedBy identifies the element (or elements) that
	// describes the object. Value type: reference
	AccessibleRelationDescribedBy AccessibleRelation = 6
	// AccessibleRelationDetails identifies the element (or elements) that
	// provide additional information related to the object. Value type:
	// reference
	AccessibleRelationDetails AccessibleRelation = 7
	// AccessibleRelationErrorMessage identifies the element that provides an
	// error message for an object. Value type: reference
	AccessibleRelationErrorMessage AccessibleRelation = 8
	// AccessibleRelationFlowTo identifies the next element (or elements) in an
	// alternate reading order of content which, at the user's discretion,
	// allows assistive technology to override the general default of reading in
	// document source order. Value type: reference
	AccessibleRelationFlowTo AccessibleRelation = 9
	// AccessibleRelationLabelledBy identifies the element (or elements) that
	// labels the current element. Value type: reference
	AccessibleRelationLabelledBy AccessibleRelation = 10
	// AccessibleRelationOwns identifies an element (or elements) in order to
	// define a visual, functional, or contextual parent/child relationship
	// between elements where the widget hierarchy cannot be used to represent
	// the relationship. Value type: reference
	AccessibleRelationOwns AccessibleRelation = 11
	// AccessibleRelationPosInSet defines an element's number or position in the
	// current set of listitems or treeitems. Value type: integer
	AccessibleRelationPosInSet AccessibleRelation = 12
	// AccessibleRelationRowCount defines the total number of rows in a table,
	// grid, or treegrid. Value type: integer
	AccessibleRelationRowCount AccessibleRelation = 13
	// AccessibleRelationRowIndex defines an element's row index or position
	// with respect to the total number of rows within a table, grid, or
	// treegrid. Value type: integer
	AccessibleRelationRowIndex AccessibleRelation = 14
	// AccessibleRelationRowIndexText defines a human readable text alternative
	// of aria-rowindex. Value type: string
	AccessibleRelationRowIndexText AccessibleRelation = 15
	// AccessibleRelationRowSpan defines the number of rows spanned by a cell or
	// gridcell within a table, grid, or treegrid. Value type: integer
	AccessibleRelationRowSpan AccessibleRelation = 16
	// AccessibleRelationSetSize defines the number of items in the current set
	// of listitems or treeitems. Value type: integer
	AccessibleRelationSetSize AccessibleRelation = 17
)

func marshalAccessibleRelation(p uintptr) (interface{}, error) {
	return AccessibleRelation(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AccessibleRole: the accessible role for a Accessible implementation.
//
// Abstract roles are only used as part of the ontology; application developers
// must not use abstract roles in their code.
type AccessibleRole int

const (
	// AccessibleRoleAlert: an element with important, and usually
	// time-sensitive, information
	AccessibleRoleAlert AccessibleRole = 0
	// AccessibleRoleAlertDialog: a type of dialog that contains an alert
	// message
	AccessibleRoleAlertDialog AccessibleRole = 1
	// AccessibleRoleBanner: unused
	AccessibleRoleBanner AccessibleRole = 2
	// AccessibleRoleButton: an input element that allows for user-triggered
	// actions when clicked or pressed
	AccessibleRoleButton AccessibleRole = 3
	// AccessibleRoleCaption: unused
	AccessibleRoleCaption AccessibleRole = 4
	// AccessibleRoleCell: unused
	AccessibleRoleCell AccessibleRole = 5
	// AccessibleRoleCheckbox: a checkable input element that has three possible
	// values: `true`, `false`, or `mixed`
	AccessibleRoleCheckbox AccessibleRole = 6
	// AccessibleRoleColumnHeader: a header in a columned list.
	AccessibleRoleColumnHeader AccessibleRole = 7
	// AccessibleRoleComboBox: an input that controls another element, such as a
	// list or a grid, that can dynamically pop up to help the user set the
	// value of the input
	AccessibleRoleComboBox AccessibleRole = 8
	// AccessibleRoleCommand: abstract role.
	AccessibleRoleCommand AccessibleRole = 9
	// AccessibleRoleComposite: abstract role.
	AccessibleRoleComposite AccessibleRole = 10
	// AccessibleRoleDialog: a dialog is a window that is designed to interrupt
	// the current processing of an application in order to prompt the user to
	// enter information or require a response.
	AccessibleRoleDialog AccessibleRole = 11
	// AccessibleRoleDocument: unused
	AccessibleRoleDocument AccessibleRole = 12
	// AccessibleRoleFeed: unused
	AccessibleRoleFeed AccessibleRole = 13
	// AccessibleRoleForm: unused
	AccessibleRoleForm AccessibleRole = 14
	// AccessibleRoleGeneric: unused
	AccessibleRoleGeneric AccessibleRole = 15
	// AccessibleRoleGrid: a grid of items.
	AccessibleRoleGrid AccessibleRole = 16
	// AccessibleRoleGridCell: an item in a grid or tree grid.
	AccessibleRoleGridCell AccessibleRole = 17
	// AccessibleRoleGroup: an element that groups multiple widgets. GTK uses
	// this role for various containers, like Box, Viewport, and HeaderBar.
	AccessibleRoleGroup AccessibleRole = 18
	// AccessibleRoleHeading: unused
	AccessibleRoleHeading AccessibleRole = 19
	// AccessibleRoleImg: an image.
	AccessibleRoleImg AccessibleRole = 20
	// AccessibleRoleInput: abstract role.
	AccessibleRoleInput AccessibleRole = 21
	// AccessibleRoleLabel: a visible name or caption for a user interface
	// component.
	AccessibleRoleLabel AccessibleRole = 22
	// AccessibleRoleLandmark: abstract role.
	AccessibleRoleLandmark AccessibleRole = 23
	// AccessibleRoleLegend: unused
	AccessibleRoleLegend AccessibleRole = 24
	// AccessibleRoleLink: a clickable link.
	AccessibleRoleLink AccessibleRole = 25
	// AccessibleRoleList: a list of items.
	AccessibleRoleList AccessibleRole = 26
	// AccessibleRoleListBox: unused.
	AccessibleRoleListBox AccessibleRole = 27
	// AccessibleRoleListItem: an item in a list.
	AccessibleRoleListItem AccessibleRole = 28
	// AccessibleRoleLog: unused
	AccessibleRoleLog AccessibleRole = 29
	// AccessibleRoleMain: unused
	AccessibleRoleMain AccessibleRole = 30
	// AccessibleRoleMarquee: unused
	AccessibleRoleMarquee AccessibleRole = 31
	// AccessibleRoleMath: unused
	AccessibleRoleMath AccessibleRole = 32
	// AccessibleRoleMeter: an element that represents a value within a known
	// range.
	AccessibleRoleMeter AccessibleRole = 33
	// AccessibleRoleMenu: a menu.
	AccessibleRoleMenu AccessibleRole = 34
	// AccessibleRoleMenuBar: a menubar.
	AccessibleRoleMenuBar AccessibleRole = 35
	// AccessibleRoleMenuItem: an item in a menu.
	AccessibleRoleMenuItem AccessibleRole = 36
	// AccessibleRoleMenuItemCheckbox: a check item in a menu.
	AccessibleRoleMenuItemCheckbox AccessibleRole = 37
	// AccessibleRoleMenuItemRadio: a radio item in a menu.
	AccessibleRoleMenuItemRadio AccessibleRole = 38
	// AccessibleRoleNavigation: unused
	AccessibleRoleNavigation AccessibleRole = 39
	// AccessibleRoleNone: an element that is not represented to accessibility
	// technologies.
	AccessibleRoleNone AccessibleRole = 40
	// AccessibleRoleNote: unused
	AccessibleRoleNote AccessibleRole = 41
	// AccessibleRoleOption: unused
	AccessibleRoleOption AccessibleRole = 42
	// AccessibleRolePresentation: an element that is not represented to
	// accessibility technologies.
	AccessibleRolePresentation AccessibleRole = 43
	// AccessibleRoleProgressBar: an element that displays the progress status
	// for tasks that take a long time.
	AccessibleRoleProgressBar AccessibleRole = 44
	// AccessibleRoleRadio: a checkable input in a group of radio roles, only
	// one of which can be checked at a time.
	AccessibleRoleRadio AccessibleRole = 45
	// AccessibleRoleRadioGroup: unused
	AccessibleRoleRadioGroup AccessibleRole = 46
	// AccessibleRoleRange: abstract role.
	AccessibleRoleRange AccessibleRole = 47
	// AccessibleRoleRegion: unused
	AccessibleRoleRegion AccessibleRole = 48
	// AccessibleRoleRow: a row in a columned list.
	AccessibleRoleRow AccessibleRole = 49
	// AccessibleRoleRowGroup: unused
	AccessibleRoleRowGroup AccessibleRole = 50
	// AccessibleRoleRowHeader: unused
	AccessibleRoleRowHeader AccessibleRole = 51
	// AccessibleRoleScrollbar: a graphical object that controls the scrolling
	// of content within a viewing area, regardless of whether the content is
	// fully displayed within the viewing area.
	AccessibleRoleScrollbar AccessibleRole = 52
	// AccessibleRoleSearch: unused
	AccessibleRoleSearch AccessibleRole = 53
	// AccessibleRoleSearchBox: a type of textbox intended for specifying search
	// criteria.
	AccessibleRoleSearchBox AccessibleRole = 54
	// AccessibleRoleSection: abstract role.
	AccessibleRoleSection AccessibleRole = 55
	// AccessibleRoleSectionHead: abstract role.
	AccessibleRoleSectionHead AccessibleRole = 56
	// AccessibleRoleSelect: abstract role.
	AccessibleRoleSelect AccessibleRole = 57
	// AccessibleRoleSeparator: a divider that separates and distinguishes
	// sections of content or groups of menuitems.
	AccessibleRoleSeparator AccessibleRole = 58
	// AccessibleRoleSlider: a user input where the user selects a value from
	// within a given range.
	AccessibleRoleSlider AccessibleRole = 59
	// AccessibleRoleSpinButton: a form of range that expects the user to select
	// from among discrete choices.
	AccessibleRoleSpinButton AccessibleRole = 60
	// AccessibleRoleStatus: unused
	AccessibleRoleStatus AccessibleRole = 61
	// AccessibleRoleStructure: abstract role.
	AccessibleRoleStructure AccessibleRole = 62
	// AccessibleRoleSwitch: a type of checkbox that represents on/off values,
	// as opposed to checked/unchecked values.
	AccessibleRoleSwitch AccessibleRole = 63
	// AccessibleRoleTab: an item in a list of tab used for switching pages.
	AccessibleRoleTab AccessibleRole = 64
	// AccessibleRoleTable: unused
	AccessibleRoleTable AccessibleRole = 65
	// AccessibleRoleTabList: a list of tabs for switching pages.
	AccessibleRoleTabList AccessibleRole = 66
	// AccessibleRoleTabPanel: a page in a notebook or stack.
	AccessibleRoleTabPanel AccessibleRole = 67
	// AccessibleRoleTextBox: a type of input that allows free-form text as its
	// value.
	AccessibleRoleTextBox AccessibleRole = 68
	// AccessibleRoleTime: unused
	AccessibleRoleTime AccessibleRole = 69
	// AccessibleRoleTimer: unused
	AccessibleRoleTimer AccessibleRole = 70
	// AccessibleRoleToolbar: unused
	AccessibleRoleToolbar AccessibleRole = 71
	// AccessibleRoleTooltip: unused
	AccessibleRoleTooltip AccessibleRole = 72
	// AccessibleRoleTree: unused
	AccessibleRoleTree AccessibleRole = 73
	// AccessibleRoleTreeGrid: a treeview-like, columned list.
	AccessibleRoleTreeGrid AccessibleRole = 74
	// AccessibleRoleTreeItem: unused
	AccessibleRoleTreeItem AccessibleRole = 75
	// AccessibleRoleWidget: an interactive component of a graphical user
	// interface. This is the role that GTK uses by default for widgets.
	AccessibleRoleWidget AccessibleRole = 76
	// AccessibleRoleWindow: an application window.
	AccessibleRoleWindow AccessibleRole = 77
)

func marshalAccessibleRole(p uintptr) (interface{}, error) {
	return AccessibleRole(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AccessibleSort: the possible values for the GTK_ACCESSIBLE_PROPERTY_SORT
// accessible property.
type AccessibleSort int

const (
	// AccessibleSortNone: there is no defined sort applied to the column.
	AccessibleSortNone AccessibleSort = 0
	// AccessibleSortAscending items are sorted in ascending order by this
	// column.
	AccessibleSortAscending AccessibleSort = 1
	// AccessibleSortDescending items are sorted in descending order by this
	// column.
	AccessibleSortDescending AccessibleSort = 2
	// AccessibleSortOther: a sort algorithm other than ascending or descending
	// has been applied.
	AccessibleSortOther AccessibleSort = 3
)

func marshalAccessibleSort(p uintptr) (interface{}, error) {
	return AccessibleSort(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AccessibleState: the possible accessible states of a Accessible.
type AccessibleState int

const (
	// AccessibleStateBusy: a “busy” state. This state has boolean values
	AccessibleStateBusy AccessibleState = 0
	// AccessibleStateChecked: a “checked” state; indicates the current state of
	// a CheckButton. Value type: AccessibleTristate
	AccessibleStateChecked AccessibleState = 1
	// AccessibleStateDisabled: a “disabled” state; corresponds to the
	// Widget:sensitive property on Widget. It indicates a UI element that is
	// perceivable, but not editable or operable. Value type: boolean
	AccessibleStateDisabled AccessibleState = 2
	// AccessibleStateExpanded: an “expanded” state; corresponds to the
	// Expander:expanded property on Expander. Value type: boolean or undefined
	AccessibleStateExpanded AccessibleState = 3
	// AccessibleStateHidden: a “hidden” state; corresponds to the
	// Widget:visible property on Widget. You can use this state explicitly on
	// UI elements that should not be exposed to an assistive technology. Value
	// type: boolean See also: GTK_ACCESSIBLE_STATE_DISABLED
	AccessibleStateHidden AccessibleState = 4
	// AccessibleStateInvalid: an “invalid” state; set when a widget is showing
	// an error. Value type: AccessibleInvalidState
	AccessibleStateInvalid AccessibleState = 5
	// AccessibleStatePressed: a “pressed” state; indicates the current state of
	// a ToggleButton. Value type: AccessibleTristate enumeration
	AccessibleStatePressed AccessibleState = 6
	// AccessibleStateSelected: a “selected” state; set when a widget is
	// selected. Value type: boolean or undefined
	AccessibleStateSelected AccessibleState = 7
)

func marshalAccessibleState(p uintptr) (interface{}, error) {
	return AccessibleState(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AccessibleTristate: the possible values for the GTK_ACCESSIBLE_STATE_PRESSED
// accessible state.
//
// Note that the GTK_ACCESSIBLE_TRISTATE_FALSE and GTK_ACCESSIBLE_TRISTATE_TRUE
// have the same values as false and true.
type AccessibleTristate int

const (
	// AccessibleTristateFalse: the state is `false`
	AccessibleTristateFalse AccessibleTristate = 0
	// AccessibleTristateTrue: the state is `true`
	AccessibleTristateTrue AccessibleTristate = 1
	// AccessibleTristateMixed: the state is `mixed`
	AccessibleTristateMixed AccessibleTristate = 2
)

func marshalAccessibleTristate(p uintptr) (interface{}, error) {
	return AccessibleTristate(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// Align controls how a widget deals with extra space in a single (x or y)
// dimension.
//
// Alignment only matters if the widget receives a “too large” allocation, for
// example if you packed the widget with the Widget:hexpand property inside a
// Box, then the widget might get extra space. If you have for example a 16x16
// icon inside a 32x32 space, the icon could be scaled and stretched, it could
// be centered, or it could be positioned to one side of the space.
//
// Note that in horizontal context GTK_ALIGN_START and GTK_ALIGN_END are
// interpreted relative to text direction.
//
// GTK_ALIGN_BASELINE support is optional for containers and widgets, and it is
// only supported for vertical alignment. When it's not supported by a child or
// a container it is treated as GTK_ALIGN_FILL.
type Align int

const (
	// AlignFill: stretch to fill all space if possible, center if no meaningful
	// way to stretch
	AlignFill Align = 0
	// AlignStart: snap to left or top side, leaving space on right or bottom
	AlignStart Align = 1
	// AlignEnd: snap to right or bottom side, leaving space on left or top
	AlignEnd Align = 2
	// AlignCenter: center natural width of widget inside the allocation
	AlignCenter Align = 3
	// AlignBaseline: align the widget according to the baseline. See Widget
	AlignBaseline Align = 4
)

func marshalAlign(p uintptr) (interface{}, error) {
	return Align(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ArrowType: used to indicate the direction in which an arrow should point.
type ArrowType int

const (
	// ArrowTypeUp represents an upward pointing arrow.
	ArrowTypeUp ArrowType = 0
	// ArrowTypeDown represents a downward pointing arrow.
	ArrowTypeDown ArrowType = 1
	// ArrowTypeLeft represents a left pointing arrow.
	ArrowTypeLeft ArrowType = 2
	// ArrowTypeRight represents a right pointing arrow.
	ArrowTypeRight ArrowType = 3
	// ArrowTypeNone: no arrow.
	ArrowTypeNone ArrowType = 4
)

func marshalArrowType(p uintptr) (interface{}, error) {
	return ArrowType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AssistantPageType: an enum for determining the page role inside the
// Assistant. It's used to handle buttons sensitivity and visibility.
//
// Note that an assistant needs to end its page flow with a page of type
// GTK_ASSISTANT_PAGE_CONFIRM, GTK_ASSISTANT_PAGE_SUMMARY or
// GTK_ASSISTANT_PAGE_PROGRESS to be correct.
//
// The Cancel button will only be shown if the page isn’t “committed”. See
// gtk_assistant_commit() for details.
type AssistantPageType int

const (
	// AssistantPageTypeContent: the page has regular contents. Both the Back
	// and forward buttons will be shown.
	AssistantPageTypeContent AssistantPageType = 0
	// AssistantPageTypeIntro: the page contains an introduction to the
	// assistant task. Only the Forward button will be shown if there is a next
	// page.
	AssistantPageTypeIntro AssistantPageType = 1
	// AssistantPageTypeConfirm: the page lets the user confirm or deny the
	// changes. The Back and Apply buttons will be shown.
	AssistantPageTypeConfirm AssistantPageType = 2
	// AssistantPageTypeSummary: the page informs the user of the changes done.
	// Only the Close button will be shown.
	AssistantPageTypeSummary AssistantPageType = 3
	// AssistantPageTypeProgress: used for tasks that take a long time to
	// complete, blocks the assistant until the page is marked as complete. Only
	// the back button will be shown.
	AssistantPageTypeProgress AssistantPageType = 4
	// AssistantPageTypeCustom: used for when other page types are not
	// appropriate. No buttons will be shown, and the application must add its
	// own buttons through gtk_assistant_add_action_widget().
	AssistantPageTypeCustom AssistantPageType = 5
)

func marshalAssistantPageType(p uintptr) (interface{}, error) {
	return AssistantPageType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// BaselinePosition: whenever a container has some form of natural row it may
// align children in that row along a common typographical baseline. If the
// amount of vertical space in the row is taller than the total requested height
// of the baseline-aligned children then it can use a BaselinePosition to select
// where to put the baseline inside the extra available space.
type BaselinePosition int

const (
	// BaselinePositionTop: align the baseline at the top
	BaselinePositionTop BaselinePosition = 0
	// BaselinePositionCenter: center the baseline
	BaselinePositionCenter BaselinePosition = 1
	// BaselinePositionBottom: align the baseline at the bottom
	BaselinePositionBottom BaselinePosition = 2
)

func marshalBaselinePosition(p uintptr) (interface{}, error) {
	return BaselinePosition(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// BorderStyle describes how the border of a UI element should be rendered.
type BorderStyle int

const (
	// BorderStyleNone: no visible border
	BorderStyleNone BorderStyle = 0
	// BorderStyleHidden: same as GTK_BORDER_STYLE_NONE
	BorderStyleHidden BorderStyle = 1
	// BorderStyleSolid: a single line segment
	BorderStyleSolid BorderStyle = 2
	// BorderStyleInset looks as if the content is sunken into the canvas
	BorderStyleInset BorderStyle = 3
	// BorderStyleOutset looks as if the content is coming out of the canvas
	BorderStyleOutset BorderStyle = 4
	// BorderStyleDotted: a series of round dots
	BorderStyleDotted BorderStyle = 5
	// BorderStyleDashed: a series of square-ended dashes
	BorderStyleDashed BorderStyle = 6
	// BorderStyleDouble: two parallel lines with some space between them
	BorderStyleDouble BorderStyle = 7
	// BorderStyleGroove looks as if it were carved in the canvas
	BorderStyleGroove BorderStyle = 8
	// BorderStyleRidge looks as if it were coming out of the canvas
	BorderStyleRidge BorderStyle = 9
)

func marshalBorderStyle(p uintptr) (interface{}, error) {
	return BorderStyle(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// BuilderError: error codes that identify various errors that can occur while
// using Builder.
type BuilderError int

const (
	// BuilderErrorInvalidTypeFunction: a type-func attribute didn’t name a
	// function that returns a #GType.
	BuilderErrorInvalidTypeFunction BuilderError = 0
	// BuilderErrorUnhandledTag: the input contained a tag that Builder can’t
	// handle.
	BuilderErrorUnhandledTag BuilderError = 1
	// BuilderErrorMissingAttribute: an attribute that is required by Builder
	// was missing.
	BuilderErrorMissingAttribute BuilderError = 2
	// BuilderErrorInvalidAttribute: Builder found an attribute that it doesn’t
	// understand.
	BuilderErrorInvalidAttribute BuilderError = 3
	// BuilderErrorInvalidTag: Builder found a tag that it doesn’t understand.
	BuilderErrorInvalidTag BuilderError = 4
	// BuilderErrorMissingPropertyValue: a required property value was missing.
	BuilderErrorMissingPropertyValue BuilderError = 5
	// BuilderErrorInvalidValue: Builder couldn’t parse some attribute value.
	BuilderErrorInvalidValue BuilderError = 6
	// BuilderErrorVersionMismatch: the input file requires a newer version of
	// GTK.
	BuilderErrorVersionMismatch BuilderError = 7
	// BuilderErrorDuplicateID: an object id occurred twice.
	BuilderErrorDuplicateID BuilderError = 8
	// BuilderErrorObjectTypeRefused: a specified object type is of the same
	// type or derived from the type of the composite class being extended with
	// builder XML.
	BuilderErrorObjectTypeRefused BuilderError = 9
	// BuilderErrorTemplateMismatch: the wrong type was specified in a composite
	// class’s template XML
	BuilderErrorTemplateMismatch BuilderError = 10
	// BuilderErrorInvalidProperty: the specified property is unknown for the
	// object class.
	BuilderErrorInvalidProperty BuilderError = 11
	// BuilderErrorInvalidSignal: the specified signal is unknown for the object
	// class.
	BuilderErrorInvalidSignal BuilderError = 12
	// BuilderErrorInvalidID: an object id is unknown.
	BuilderErrorInvalidID BuilderError = 13
	// BuilderErrorInvalidFunction: a function could not be found. This often
	// happens when symbols are set to be kept private. Compiling code with
	// -rdynamic or using the `gmodule-export-2.0` pkgconfig module can fix this
	// problem.
	BuilderErrorInvalidFunction BuilderError = 14
)

func marshalBuilderError(p uintptr) (interface{}, error) {
	return BuilderError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ButtonsType: prebuilt sets of buttons for the dialog. If none of these
// choices are appropriate, simply use GTK_BUTTONS_NONE then call
// gtk_dialog_add_buttons().
//
// > Please note that GTK_BUTTONS_OK, GTK_BUTTONS_YES_NO > and
// GTK_BUTTONS_OK_CANCEL are discouraged by the > GNOME Human Interface
// Guidelines (http://library.gnome.org/devel/hig-book/stable/).
type ButtonsType int

const (
	// ButtonsTypeNone: no buttons at all
	ButtonsTypeNone ButtonsType = 0
	// ButtonsTypeOk: an OK button
	ButtonsTypeOk ButtonsType = 1
	// ButtonsTypeClose: a Close button
	ButtonsTypeClose ButtonsType = 2
	// ButtonsTypeCancel: a Cancel button
	ButtonsTypeCancel ButtonsType = 3
	// ButtonsTypeYesNo yes and No buttons
	ButtonsTypeYesNo ButtonsType = 4
	// ButtonsTypeOkCancel: OK and Cancel buttons
	ButtonsTypeOkCancel ButtonsType = 5
)

func marshalButtonsType(p uintptr) (interface{}, error) {
	return ButtonsType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// CellRendererAccelMode determines if the edited accelerators are GTK
// accelerators. If they are, consumed modifiers are suppressed, only
// accelerators accepted by GTK are allowed, and the accelerators are rendered
// in the same way as they are in menus.
type CellRendererAccelMode int

const (
	// CellRendererAccelModeGTK: GTK accelerators mode
	CellRendererAccelModeGTK CellRendererAccelMode = 0
	// CellRendererAccelModeOther: other accelerator mode
	CellRendererAccelModeOther CellRendererAccelMode = 1
)

func marshalCellRendererAccelMode(p uintptr) (interface{}, error) {
	return CellRendererAccelMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// CellRendererMode identifies how the user can interact with a particular cell.
type CellRendererMode int

const (
	// CellRendererModeInert: the cell is just for display and cannot be
	// interacted with. Note that this doesn’t mean that eg. the row being drawn
	// can’t be selected -- just that a particular element of it cannot be
	// individually modified.
	CellRendererModeInert CellRendererMode = 0
	// CellRendererModeActivatable: the cell can be clicked.
	CellRendererModeActivatable CellRendererMode = 1
	// CellRendererModeEditable: the cell can be edited or otherwise modified.
	CellRendererModeEditable CellRendererMode = 2
)

func marshalCellRendererMode(p uintptr) (interface{}, error) {
	return CellRendererMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ConstraintAttribute: the widget attributes that can be used when creating a
// Constraint.
type ConstraintAttribute int

const (
	// ConstraintAttributeNone: no attribute, used for constant relations
	ConstraintAttributeNone ConstraintAttribute = 0
	// ConstraintAttributeLeft: the left edge of a widget, regardless of text
	// direction
	ConstraintAttributeLeft ConstraintAttribute = 1
	// ConstraintAttributeRight: the right edge of a widget, regardless of text
	// direction
	ConstraintAttributeRight ConstraintAttribute = 2
	// ConstraintAttributeTop: the top edge of a widget
	ConstraintAttributeTop ConstraintAttribute = 3
	// ConstraintAttributeBottom: the bottom edge of a widget
	ConstraintAttributeBottom ConstraintAttribute = 4
	// ConstraintAttributeStart: the leading edge of a widget, depending on text
	// direction; equivalent to GTK_CONSTRAINT_ATTRIBUTE_LEFT for LTR languages,
	// and GTK_CONSTRAINT_ATTRIBUTE_RIGHT for RTL ones
	ConstraintAttributeStart ConstraintAttribute = 5
	// ConstraintAttributeEnd: the trailing edge of a widget, depending on text
	// direction; equivalent to GTK_CONSTRAINT_ATTRIBUTE_RIGHT for LTR
	// languages, and GTK_CONSTRAINT_ATTRIBUTE_LEFT for RTL ones
	ConstraintAttributeEnd ConstraintAttribute = 6
	// ConstraintAttributeWidth: the width of a widget
	ConstraintAttributeWidth ConstraintAttribute = 7
	// ConstraintAttributeHeight: the height of a widget
	ConstraintAttributeHeight ConstraintAttribute = 8
	// ConstraintAttributeCenterX: the center of a widget, on the horizontal
	// axis
	ConstraintAttributeCenterX ConstraintAttribute = 9
	// ConstraintAttributeCenterY: the center of a widget, on the vertical axis
	ConstraintAttributeCenterY ConstraintAttribute = 10
	// ConstraintAttributeBaseline: the baseline of a widget
	ConstraintAttributeBaseline ConstraintAttribute = 11
)

func marshalConstraintAttribute(p uintptr) (interface{}, error) {
	return ConstraintAttribute(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ConstraintRelation: the relation between two terms of a constraint.
type ConstraintRelation int

const (
	// ConstraintRelationLe less than, or equal
	ConstraintRelationLe ConstraintRelation = -1
	// ConstraintRelationEq: equal
	ConstraintRelationEq ConstraintRelation = 0
	// ConstraintRelationGe: greater than, or equal
	ConstraintRelationGe ConstraintRelation = 1
)

func marshalConstraintRelation(p uintptr) (interface{}, error) {
	return ConstraintRelation(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ConstraintStrength: the strength of a constraint, expressed as a symbolic
// constant.
//
// The strength of a Constraint can be expressed with any positive integer; the
// values of this enumeration can be used for readability.
type ConstraintStrength int

const (
	// ConstraintStrengthRequired: the constraint is required towards solving
	// the layout
	ConstraintStrengthRequired ConstraintStrength = 1001001000
	// ConstraintStrengthStrong: a strong constraint
	ConstraintStrengthStrong ConstraintStrength = 1000000000
	// ConstraintStrengthMedium: a medium constraint
	ConstraintStrengthMedium ConstraintStrength = 1000
	// ConstraintStrengthWeak: a weak constraint
	ConstraintStrengthWeak ConstraintStrength = 1
)

func marshalConstraintStrength(p uintptr) (interface{}, error) {
	return ConstraintStrength(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ConstraintVflParserError: domain for VFL parsing errors.
type ConstraintVflParserError int

const (
	// ConstraintVflParserErrorSymbol: invalid or unknown symbol
	ConstraintVflParserErrorSymbol ConstraintVflParserError = 0
	// ConstraintVflParserErrorAttribute: invalid or unknown attribute
	ConstraintVflParserErrorAttribute ConstraintVflParserError = 1
	// ConstraintVflParserErrorView: invalid or unknown view
	ConstraintVflParserErrorView ConstraintVflParserError = 2
	// ConstraintVflParserErrorMetric: invalid or unknown metric
	ConstraintVflParserErrorMetric ConstraintVflParserError = 3
	// ConstraintVflParserErrorPriority: invalid or unknown priority
	ConstraintVflParserErrorPriority ConstraintVflParserError = 4
	// ConstraintVflParserErrorRelation: invalid or unknown relation
	ConstraintVflParserErrorRelation ConstraintVflParserError = 5
)

func marshalConstraintVflParserError(p uintptr) (interface{}, error) {
	return ConstraintVflParserError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// CornerType specifies which corner a child widget should be placed in when
// packed into a ScrolledWindow. This is effectively the opposite of where the
// scroll bars are placed.
type CornerType int

const (
	// CornerTypeTopLeft: place the scrollbars on the right and bottom of the
	// widget (default behaviour).
	CornerTypeTopLeft CornerType = 0
	// CornerTypeBottomLeft: place the scrollbars on the top and right of the
	// widget.
	CornerTypeBottomLeft CornerType = 1
	// CornerTypeTopRight: place the scrollbars on the left and bottom of the
	// widget.
	CornerTypeTopRight CornerType = 2
	// CornerTypeBottomRight: place the scrollbars on the top and left of the
	// widget.
	CornerTypeBottomRight CornerType = 3
)

func marshalCornerType(p uintptr) (interface{}, error) {
	return CornerType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// CSSParserError errors that can occur while parsing CSS.
//
// These errors are unexpected and will cause parts of the given CSS to be
// ignored.
type CSSParserError int

const (
	// CSSParserErrorFailed: unknown failure.
	CSSParserErrorFailed CSSParserError = 0
	// CSSParserErrorSyntax: the given text does not form valid syntax
	CSSParserErrorSyntax CSSParserError = 1
	// CSSParserErrorImport: failed to import a resource
	CSSParserErrorImport CSSParserError = 2
	// CSSParserErrorName: the given name has not been defined
	CSSParserErrorName CSSParserError = 3
	// CSSParserErrorUnknownValue: the given value is not correct
	CSSParserErrorUnknownValue CSSParserError = 4
)

// CSSParserWarning warnings that can occur while parsing CSS.
//
// Unlike CssParserErrors, warnings do not cause the parser to skip any input,
// but they indicate issues that should be fixed.
type CSSParserWarning int

const (
	// CSSParserWarningDeprecated: the given construct is deprecated and will be
	// removed in a future version
	CSSParserWarningDeprecated CSSParserWarning = 0
	// CSSParserWarningSyntax: a syntax construct was used that should be
	// avoided
	CSSParserWarningSyntax CSSParserWarning = 1
	// CSSParserWarningUnimplemented: a feature is not implemented
	CSSParserWarningUnimplemented CSSParserWarning = 2
)

// DeleteType: see also: Entry::delete-from-cursor.
type DeleteType int

const (
	// DeleteTypeChars: delete characters.
	DeleteTypeChars DeleteType = 0
	// DeleteTypeWordEnds: delete only the portion of the word to the left/right
	// of cursor if we’re in the middle of a word.
	DeleteTypeWordEnds DeleteType = 1
	// DeleteTypeWords: delete words.
	DeleteTypeWords DeleteType = 2
	// DeleteTypeDisplayLines: delete display-lines. Display-lines refers to the
	// visible lines, with respect to the current line breaks. As opposed to
	// paragraphs, which are defined by line breaks in the input.
	DeleteTypeDisplayLines DeleteType = 3
	// DeleteTypeDisplayLineEnds: delete only the portion of the display-line to
	// the left/right of cursor.
	DeleteTypeDisplayLineEnds DeleteType = 4
	// DeleteTypeParagraphEnds: delete to the end of the paragraph. Like C-k in
	// Emacs (or its reverse).
	DeleteTypeParagraphEnds DeleteType = 5
	// DeleteTypeParagraphs: delete entire line. Like C-k in pico.
	DeleteTypeParagraphs DeleteType = 6
	// DeleteTypeWhitespace: delete only whitespace. Like M-\ in Emacs.
	DeleteTypeWhitespace DeleteType = 7
)

func marshalDeleteType(p uintptr) (interface{}, error) {
	return DeleteType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DirectionType focus movement types.
type DirectionType int

const (
	// DirectionTypeTabForward: move forward.
	DirectionTypeTabForward DirectionType = 0
	// DirectionTypeTabBackward: move backward.
	DirectionTypeTabBackward DirectionType = 1
	// DirectionTypeUp: move up.
	DirectionTypeUp DirectionType = 2
	// DirectionTypeDown: move down.
	DirectionTypeDown DirectionType = 3
	// DirectionTypeLeft: move left.
	DirectionTypeLeft DirectionType = 4
	// DirectionTypeRight: move right.
	DirectionTypeRight DirectionType = 5
)

func marshalDirectionType(p uintptr) (interface{}, error) {
	return DirectionType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

type EditableProperties int

const (
	EditablePropertiesPropText EditableProperties = 0

	EditablePropertiesPropCursorPosition EditableProperties = 1

	EditablePropertiesPropSelectionBound EditableProperties = 2

	EditablePropertiesPropEditable EditableProperties = 3

	EditablePropertiesPropWidthChars EditableProperties = 4

	EditablePropertiesPropMaxWidthChars EditableProperties = 5

	EditablePropertiesPropXalign EditableProperties = 6

	EditablePropertiesPropEnableUndo EditableProperties = 7

	EditablePropertiesNumProperties EditableProperties = 8
)

func marshalEditableProperties(p uintptr) (interface{}, error) {
	return EditableProperties(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// EntryIconPosition specifies the side of the entry at which an icon is placed.
type EntryIconPosition int

const (
	// EntryIconPositionPrimary: at the beginning of the entry (depending on the
	// text direction).
	EntryIconPositionPrimary EntryIconPosition = 0
	// EntryIconPositionSecondary: at the end of the entry (depending on the
	// text direction).
	EntryIconPositionSecondary EntryIconPosition = 1
)

func marshalEntryIconPosition(p uintptr) (interface{}, error) {
	return EntryIconPosition(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// EventSequenceState describes the state of a EventSequence in a Gesture.
type EventSequenceState int

const (
	// EventSequenceStateNone: the sequence is handled, but not grabbed.
	EventSequenceStateNone EventSequenceState = 0
	// EventSequenceStateClaimed: the sequence is handled and grabbed.
	EventSequenceStateClaimed EventSequenceState = 1
	// EventSequenceStateDenied: the sequence is denied.
	EventSequenceStateDenied EventSequenceState = 2
)

func marshalEventSequenceState(p uintptr) (interface{}, error) {
	return EventSequenceState(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FileChooserAction describes whether a FileChooser is being used to open
// existing files or to save to a possibly new file.
type FileChooserAction int

const (
	// FileChooserActionOpen indicates open mode. The file chooser will only let
	// the user pick an existing file.
	FileChooserActionOpen FileChooserAction = 0
	// FileChooserActionSave indicates save mode. The file chooser will let the
	// user pick an existing file, or type in a new filename.
	FileChooserActionSave FileChooserAction = 1
	// FileChooserActionSelectFolder indicates an Open mode for selecting
	// folders. The file chooser will let the user pick an existing folder.
	FileChooserActionSelectFolder FileChooserAction = 2
)

func marshalFileChooserAction(p uintptr) (interface{}, error) {
	return FileChooserAction(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FileChooserError: these identify the various errors that can occur while
// calling FileChooser functions.
type FileChooserError int

const (
	// FileChooserErrorNonexistent indicates that a file does not exist.
	FileChooserErrorNonexistent FileChooserError = 0
	// FileChooserErrorBadFilename indicates a malformed filename.
	FileChooserErrorBadFilename FileChooserError = 1
	// FileChooserErrorAlreadyExists indicates a duplicate path (e.g. when
	// adding a bookmark).
	FileChooserErrorAlreadyExists FileChooserError = 2
	// FileChooserErrorIncompleteHostname indicates an incomplete hostname (e.g.
	// "http://foo" without a slash after that).
	FileChooserErrorIncompleteHostname FileChooserError = 3
)

func marshalFileChooserError(p uintptr) (interface{}, error) {
	return FileChooserError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FilterChange describes changes in a filter in more detail and allows objects
// using the filter to optimize refiltering items.
//
// If you are writing an implementation and are not sure which value to pass,
// GTK_FILTER_CHANGE_DIFFERENT is always a correct choice.
type FilterChange int

const (
	// FilterChangeDifferent: the filter change cannot be described with any of
	// the other enumeration values.
	FilterChangeDifferent FilterChange = 0
	// FilterChangeLessStrict: the filter is less strict than it was before: All
	// items that it used to return true for still return true, others now may,
	// too.
	FilterChangeLessStrict FilterChange = 1
	// FilterChangeMoreStrict: the filter is more strict than it was before: All
	// items that it used to return false for still return false, others now
	// may, too.
	FilterChangeMoreStrict FilterChange = 2
)

func marshalFilterChange(p uintptr) (interface{}, error) {
	return FilterChange(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FilterMatch describes the known strictness of a filter.
//
// Note that for filters where the strictness is not known,
// GTK_FILTER_MATCH_SOME is always an acceptable value, even if a filter does
// match all or no items.
type FilterMatch int

const (
	// FilterMatchSome: the filter matches some items, gtk_filter_match() may
	// return true or false
	FilterMatchSome FilterMatch = 0
	// FilterMatchNone: the filter does not match any item, gtk_filter_match()
	// will always return false.
	FilterMatchNone FilterMatch = 1
	// FilterMatchAll: the filter matches all items, gtk_filter_match() will
	// alays return true.
	FilterMatchAll FilterMatch = 2
)

func marshalFilterMatch(p uintptr) (interface{}, error) {
	return FilterMatch(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// IconSize: built-in icon sizes.
//
// Icon sizes default to being inherited. Where they cannot be inherited, text
// size is the default.
//
// All widgets which use GtkIconSize set the normal-icons or large-icons style
// classes correspondingly, and let themes determine the actual size to be used
// with the -gtk-icon-size CSS property.
type IconSize int

const (
	// IconSizeInherit: keep the size of the parent element
	IconSizeInherit IconSize = 0
	// IconSizeNormal: size similar to text size
	IconSizeNormal IconSize = 1
	// IconSizeLarge: large size, for example in an icon view
	IconSizeLarge IconSize = 2
)

func marshalIconSize(p uintptr) (interface{}, error) {
	return IconSize(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// IconThemeError: error codes for GtkIconTheme operations.
type IconThemeError int

const (
	// IconThemeErrorNotFound: the icon specified does not exist in the theme
	IconThemeErrorNotFound IconThemeError = 0
	// IconThemeErrorFailed: an unspecified error occurred.
	IconThemeErrorFailed IconThemeError = 1
)

func marshalIconThemeError(p uintptr) (interface{}, error) {
	return IconThemeError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// IconViewDropPosition: an enum for determining where a dropped item goes.
type IconViewDropPosition int

const (
	// IconViewDropPositionNoDrop: no drop possible
	IconViewDropPositionNoDrop IconViewDropPosition = 0
	// IconViewDropPositionDropInto: dropped item replaces the item
	IconViewDropPositionDropInto IconViewDropPosition = 1
	// IconViewDropPositionDropLeft: dropped item is inserted to the left
	IconViewDropPositionDropLeft IconViewDropPosition = 2
	// IconViewDropPositionDropRight: dropped item is inserted to the right
	IconViewDropPositionDropRight IconViewDropPosition = 3
	// IconViewDropPositionDropAbove: dropped item is inserted above
	IconViewDropPositionDropAbove IconViewDropPosition = 4
	// IconViewDropPositionDropBelow: dropped item is inserted below
	IconViewDropPositionDropBelow IconViewDropPosition = 5
)

func marshalIconViewDropPosition(p uintptr) (interface{}, error) {
	return IconViewDropPosition(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ImageType describes the image data representation used by a Image. If you
// want to get the image from the widget, you can only get the currently-stored
// representation. e.g. if the gtk_image_get_storage_type() returns
// K_IMAGE_PAINTABLE, then you can call gtk_image_get_paintable(). For empty
// images, you can request any storage type (call any of the "get" functions),
// but they will all return nil values.
type ImageType int

const (
	// ImageTypeEmpty: there is no image displayed by the widget
	ImageTypeEmpty ImageType = 0
	// ImageTypeIconName: the widget contains a named icon
	ImageTypeIconName ImageType = 1
	// ImageTypeGIcon: the widget contains a #GIcon
	ImageTypeGIcon ImageType = 2
	// ImageTypePaintable: the widget contains a Paintable
	ImageTypePaintable ImageType = 3
)

func marshalImageType(p uintptr) (interface{}, error) {
	return ImageType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// InputPurpose describes primary purpose of the input widget. This information
// is useful for on-screen keyboards and similar input methods to decide which
// keys should be presented to the user.
//
// Note that the purpose is not meant to impose a totally strict rule about
// allowed characters, and does not replace input validation. It is fine for an
// on-screen keyboard to let the user override the character set restriction
// that is expressed by the purpose. The application is expected to validate the
// entry contents, even if it specified a purpose.
//
// The difference between GTK_INPUT_PURPOSE_DIGITS and GTK_INPUT_PURPOSE_NUMBER
// is that the former accepts only digits while the latter also some punctuation
// (like commas or points, plus, minus) and “e” or “E” as in 3.14E+000.
//
// This enumeration may be extended in the future; input methods should
// interpret unknown values as “free form”.
type InputPurpose int

const (
	// InputPurposeFreeForm: allow any character
	InputPurposeFreeForm InputPurpose = 0
	// InputPurposeAlpha: allow only alphabetic characters
	InputPurposeAlpha InputPurpose = 1
	// InputPurposeDigits: allow only digits
	InputPurposeDigits InputPurpose = 2
	// InputPurposeNumber: edited field expects numbers
	InputPurposeNumber InputPurpose = 3
	// InputPurposePhone: edited field expects phone number
	InputPurposePhone InputPurpose = 4
	// InputPurposeURL: edited field expects URL
	InputPurposeURL InputPurpose = 5
	// InputPurposeEmail: edited field expects email address
	InputPurposeEmail InputPurpose = 6
	// InputPurposeName: edited field expects the name of a person
	InputPurposeName InputPurpose = 7
	// InputPurposePassword: like GTK_INPUT_PURPOSE_FREE_FORM, but characters
	// are hidden
	InputPurposePassword InputPurpose = 8
	// InputPurposePin: like GTK_INPUT_PURPOSE_DIGITS, but characters are hidden
	InputPurposePin InputPurpose = 9
	// InputPurposeTerminal: allow any character, in addition to control codes
	InputPurposeTerminal InputPurpose = 10
)

func marshalInputPurpose(p uintptr) (interface{}, error) {
	return InputPurpose(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// Justification: used for justifying the text inside a Label widget.
type Justification int

const (
	// JustificationLeft: the text is placed at the left edge of the label.
	JustificationLeft Justification = 0
	// JustificationRight: the text is placed at the right edge of the label.
	JustificationRight Justification = 1
	// JustificationCenter: the text is placed in the center of the label.
	JustificationCenter Justification = 2
	// JustificationFill: the text is placed is distributed across the label.
	JustificationFill Justification = 3
)

func marshalJustification(p uintptr) (interface{}, error) {
	return Justification(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// LevelBarMode describes how LevelBar contents should be rendered. Note that
// this enumeration could be extended with additional modes in the future.
type LevelBarMode int

const (
	// LevelBarModeContinuous: the bar has a continuous mode
	LevelBarModeContinuous LevelBarMode = 0
	// LevelBarModeDiscrete: the bar has a discrete mode
	LevelBarModeDiscrete LevelBarMode = 1
)

func marshalLevelBarMode(p uintptr) (interface{}, error) {
	return LevelBarMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// License: the type of license for an application.
//
// This enumeration can be expanded at later date.
type License int

const (
	// LicenseUnknown: no license specified
	LicenseUnknown License = 0
	// LicenseCustom: a license text is going to be specified by the developer
	LicenseCustom License = 1
	// LicenseGpl20: the GNU General Public License, version 2.0 or later
	LicenseGpl20 License = 2
	// LicenseGpl30: the GNU General Public License, version 3.0 or later
	LicenseGpl30 License = 3
	// LicenseLgpl21: the GNU Lesser General Public License, version 2.1 or
	// later
	LicenseLgpl21 License = 4
	// LicenseLgpl30: the GNU Lesser General Public License, version 3.0 or
	// later
	LicenseLgpl30 License = 5
	// LicenseBsd: the BSD standard license
	LicenseBsd License = 6
	// LicenseMitX11: the MIT/X11 standard license
	LicenseMitX11 License = 7
	// LicenseArtistic: the Artistic License, version 2.0
	LicenseArtistic License = 8
	// LicenseGpl20Only: the GNU General Public License, version 2.0 only
	LicenseGpl20Only License = 9
	// LicenseGpl30Only: the GNU General Public License, version 3.0 only
	LicenseGpl30Only License = 10
	// LicenseLgpl21Only: the GNU Lesser General Public License, version 2.1
	// only
	LicenseLgpl21Only License = 11
	// LicenseLgpl30Only: the GNU Lesser General Public License, version 3.0
	// only
	LicenseLgpl30Only License = 12
	// LicenseAgpl30: the GNU Affero General Public License, version 3.0 or
	// later
	LicenseAgpl30 License = 13
	// LicenseAgpl30Only: the GNU Affero General Public License, version 3.0
	// only
	LicenseAgpl30Only License = 14
	// LicenseBsd3: the 3-clause BSD licence
	LicenseBsd3 License = 15
	// LicenseApache20: the Apache License, version 2.0
	LicenseApache20 License = 16
	// LicenseMpl20: the Mozilla Public License, version 2.0
	LicenseMpl20 License = 17
)

func marshalLicense(p uintptr) (interface{}, error) {
	return License(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// MessageType: the type of message being displayed in the dialog.
type MessageType int

const (
	// MessageTypeInfo: informational message
	MessageTypeInfo MessageType = 0
	// MessageTypeWarning: non-fatal warning message
	MessageTypeWarning MessageType = 1
	// MessageTypeQuestion: question requiring a choice
	MessageTypeQuestion MessageType = 2
	// MessageTypeError: fatal error message
	MessageTypeError MessageType = 3
	// MessageTypeOther: none of the above
	MessageTypeOther MessageType = 4
)

func marshalMessageType(p uintptr) (interface{}, error) {
	return MessageType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

type MovementStep int

const (
	// MovementStepLogicalPositions: move forward or back by graphemes
	MovementStepLogicalPositions MovementStep = 0
	// MovementStepVisualPositions: move left or right by graphemes
	MovementStepVisualPositions MovementStep = 1
	// MovementStepWords: move forward or back by words
	MovementStepWords MovementStep = 2
	// MovementStepDisplayLines: move up or down lines (wrapped lines)
	MovementStepDisplayLines MovementStep = 3
	// MovementStepDisplayLineEnds: move to either end of a line
	MovementStepDisplayLineEnds MovementStep = 4
	// MovementStepParagraphs: move up or down paragraphs (newline-ended lines)
	MovementStepParagraphs MovementStep = 5
	// MovementStepParagraphEnds: move to either end of a paragraph
	MovementStepParagraphEnds MovementStep = 6
	// MovementStepPages: move by pages
	MovementStepPages MovementStep = 7
	// MovementStepBufferEnds: move to ends of the buffer
	MovementStepBufferEnds MovementStep = 8
	// MovementStepHorizontalPages: move horizontally by pages
	MovementStepHorizontalPages MovementStep = 9
)

func marshalMovementStep(p uintptr) (interface{}, error) {
	return MovementStep(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// NotebookTab: the parameter used in the action signals of Notebook.
type NotebookTab int

const (
	// NotebookTabFirst: the first tab in the notebook
	NotebookTabFirst NotebookTab = 0
	// NotebookTabLast: the last tab in the notebook
	NotebookTabLast NotebookTab = 1
)

func marshalNotebookTab(p uintptr) (interface{}, error) {
	return NotebookTab(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// NumberUpLayout: used to determine the layout of pages on a sheet when
// printing multiple pages per sheet.
type NumberUpLayout int

const (
	// NumberUpLayoutLrtb: ! (layout-lrtb.png)
	NumberUpLayoutLrtb NumberUpLayout = 0
	// NumberUpLayoutLrbt: ! (layout-lrbt.png)
	NumberUpLayoutLrbt NumberUpLayout = 1
	// NumberUpLayoutRltb: ! (layout-rltb.png)
	NumberUpLayoutRltb NumberUpLayout = 2
	// NumberUpLayoutRlbt: ! (layout-rlbt.png)
	NumberUpLayoutRlbt NumberUpLayout = 3
	// NumberUpLayoutTblr: ! (layout-tblr.png)
	NumberUpLayoutTblr NumberUpLayout = 4
	// NumberUpLayoutTbrl: ! (layout-tbrl.png)
	NumberUpLayoutTbrl NumberUpLayout = 5
	// NumberUpLayoutBtlr: ! (layout-btlr.png)
	NumberUpLayoutBtlr NumberUpLayout = 6
	// NumberUpLayoutBtrl: ! (layout-btrl.png)
	NumberUpLayoutBtrl NumberUpLayout = 7
)

func marshalNumberUpLayout(p uintptr) (interface{}, error) {
	return NumberUpLayout(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// Ordering describes the way two values can be compared.
//
// These values can be used with a Func. However, a Func is allowed to return
// any integer values. For converting such a value to a Ordering, use
// gtk_ordering_from_cmpfunc().
type Ordering int

const (
	// OrderingSmaller: the first value is smaller than the second
	OrderingSmaller Ordering = -1
	// OrderingEqual: the two values are equal
	OrderingEqual Ordering = 0
	// OrderingLarger: the first value is larger than the second
	OrderingLarger Ordering = 1
)

func marshalOrdering(p uintptr) (interface{}, error) {
	return Ordering(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// Orientation represents the orientation of widgets and other objects which can
// be switched between horizontal and vertical orientation on the fly, like Box
// or GesturePan.
type Orientation int

const (
	// OrientationHorizontal: the element is in horizontal orientation.
	OrientationHorizontal Orientation = 0
	// OrientationVertical: the element is in vertical orientation.
	OrientationVertical Orientation = 1
)

func marshalOrientation(p uintptr) (interface{}, error) {
	return Orientation(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// Overflow defines how content overflowing a given area should be handled, such
// as with gtk_widget_set_overflow(). This property is modeled after the CSS
// overflow property, but implements it only partially.
type Overflow int

const (
	// OverflowVisible: no change is applied. Content is drawn at the specified
	// position.
	OverflowVisible Overflow = 0
	// OverflowHidden: content is clipped to the bounds of the area. Content
	// outside the area is not drawn and cannot be interacted with.
	OverflowHidden Overflow = 1
)

func marshalOverflow(p uintptr) (interface{}, error) {
	return Overflow(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PackType represents the packing location of a children in its parent. See
// WindowControls for example.
type PackType int

const (
	// PackTypeStart: the child is packed into the start of the widget
	PackTypeStart PackType = 0
	// PackTypeEnd: the child is packed into the end of the widget
	PackTypeEnd PackType = 1
)

func marshalPackType(p uintptr) (interface{}, error) {
	return PackType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PadActionType: the type of a pad action.
type PadActionType int

const (
	// PadActionTypeButton: action is triggered by a pad button
	PadActionTypeButton PadActionType = 0
	// PadActionTypeRing: action is triggered by a pad ring
	PadActionTypeRing PadActionType = 1
	// PadActionTypeStrip: action is triggered by a pad strip
	PadActionTypeStrip PadActionType = 2
)

func marshalPadActionType(p uintptr) (interface{}, error) {
	return PadActionType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PageOrientation: see also gtk_print_settings_set_orientation().
type PageOrientation int

const (
	// PageOrientationPortrait: portrait mode.
	PageOrientationPortrait PageOrientation = 0
	// PageOrientationLandscape: landscape mode.
	PageOrientationLandscape PageOrientation = 1
	// PageOrientationReversePortrait: reverse portrait mode.
	PageOrientationReversePortrait PageOrientation = 2
	// PageOrientationReverseLandscape: reverse landscape mode.
	PageOrientationReverseLandscape PageOrientation = 3
)

func marshalPageOrientation(p uintptr) (interface{}, error) {
	return PageOrientation(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PageSet: see also gtk_print_job_set_page_set().
type PageSet int

const (
	// PageSetAll: all pages.
	PageSetAll PageSet = 0
	// PageSetEven: even pages.
	PageSetEven PageSet = 1
	// PageSetOdd: odd pages.
	PageSetOdd PageSet = 2
)

func marshalPageSet(p uintptr) (interface{}, error) {
	return PageSet(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PanDirection describes the panning direction of a GesturePan
type PanDirection int

const (
	// PanDirectionLeft: panned towards the left
	PanDirectionLeft PanDirection = 0
	// PanDirectionRight: panned towards the right
	PanDirectionRight PanDirection = 1
	// PanDirectionUp: panned upwards
	PanDirectionUp PanDirection = 2
	// PanDirectionDown: panned downwards
	PanDirectionDown PanDirection = 3
)

func marshalPanDirection(p uintptr) (interface{}, error) {
	return PanDirection(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PolicyType determines how the size should be computed to achieve the one of
// the visibility mode for the scrollbars.
type PolicyType int

const (
	// PolicyTypeAlways: the scrollbar is always visible. The view size is
	// independent of the content.
	PolicyTypeAlways PolicyType = 0
	// PolicyTypeAutomatic: the scrollbar will appear and disappear as
	// necessary. For example, when all of a TreeView can not be seen.
	PolicyTypeAutomatic PolicyType = 1
	// PolicyTypeNever: the scrollbar should never appear. In this mode the
	// content determines the size.
	PolicyTypeNever PolicyType = 2
	// PolicyTypeExternal: don't show a scrollbar, but don't force the size to
	// follow the content. This can be used e.g. to make multiple scrolled
	// windows share a scrollbar.
	PolicyTypeExternal PolicyType = 3
)

func marshalPolicyType(p uintptr) (interface{}, error) {
	return PolicyType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PositionType describes which edge of a widget a certain feature is positioned
// at, e.g. the tabs of a Notebook, or the label of a Scale.
type PositionType int

const (
	// PositionTypeLeft: the feature is at the left edge.
	PositionTypeLeft PositionType = 0
	// PositionTypeRight: the feature is at the right edge.
	PositionTypeRight PositionType = 1
	// PositionTypeTop: the feature is at the top edge.
	PositionTypeTop PositionType = 2
	// PositionTypeBottom: the feature is at the bottom edge.
	PositionTypeBottom PositionType = 3
)

func marshalPositionType(p uintptr) (interface{}, error) {
	return PositionType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PrintDuplex: see also gtk_print_settings_set_duplex().
type PrintDuplex int

const (
	// PrintDuplexSimplex: no duplex.
	PrintDuplexSimplex PrintDuplex = 0
	// PrintDuplexHorizontal: horizontal duplex.
	PrintDuplexHorizontal PrintDuplex = 1
	// PrintDuplexVertical: vertical duplex.
	PrintDuplexVertical PrintDuplex = 2
)

func marshalPrintDuplex(p uintptr) (interface{}, error) {
	return PrintDuplex(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PrintError: error codes that identify various errors that can occur while
// using the GTK printing support.
type PrintError int

const (
	// PrintErrorGeneral: an unspecified error occurred.
	PrintErrorGeneral PrintError = 0
	// PrintErrorInternalError: an internal error occurred.
	PrintErrorInternalError PrintError = 1
	// PrintErrorNomem: a memory allocation failed.
	PrintErrorNomem PrintError = 2
	// PrintErrorInvalidFile: an error occurred while loading a page setup or
	// paper size from a key file.
	PrintErrorInvalidFile PrintError = 3
)

func marshalPrintError(p uintptr) (interface{}, error) {
	return PrintError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PrintOperationAction: the @action parameter to gtk_print_operation_run()
// determines what action the print operation should perform.
type PrintOperationAction int

const (
	// PrintOperationActionPrintDialog: show the print dialog.
	PrintOperationActionPrintDialog PrintOperationAction = 0
	// PrintOperationActionPrint: start to print without showing the print
	// dialog, based on the current print settings.
	PrintOperationActionPrint PrintOperationAction = 1
	// PrintOperationActionPreview: show the print preview.
	PrintOperationActionPreview PrintOperationAction = 2
	// PrintOperationActionExport: export to a file. This requires the
	// export-filename property to be set.
	PrintOperationActionExport PrintOperationAction = 3
)

func marshalPrintOperationAction(p uintptr) (interface{}, error) {
	return PrintOperationAction(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PrintOperationResult: a value of this type is returned by
// gtk_print_operation_run().
type PrintOperationResult int

const (
	// PrintOperationResultError: an error has occurred.
	PrintOperationResultError PrintOperationResult = 0
	// PrintOperationResultApply: the print settings should be stored.
	PrintOperationResultApply PrintOperationResult = 1
	// PrintOperationResultCancel: the print operation has been canceled, the
	// print settings should not be stored.
	PrintOperationResultCancel PrintOperationResult = 2
	// PrintOperationResultInProgress: the print operation is not complete yet.
	// This value will only be returned when running asynchronously.
	PrintOperationResultInProgress PrintOperationResult = 3
)

func marshalPrintOperationResult(p uintptr) (interface{}, error) {
	return PrintOperationResult(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PrintPages: see also gtk_print_job_set_pages()
type PrintPages int

const (
	// PrintPagesAll: all pages.
	PrintPagesAll PrintPages = 0
	// PrintPagesCurrent: current page.
	PrintPagesCurrent PrintPages = 1
	// PrintPagesRanges: range of pages.
	PrintPagesRanges PrintPages = 2
	// PrintPagesSelection: selected pages.
	PrintPagesSelection PrintPages = 3
)

func marshalPrintPages(p uintptr) (interface{}, error) {
	return PrintPages(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PrintQuality: see also gtk_print_settings_set_quality().
type PrintQuality int

const (
	// PrintQualityLow: low quality.
	PrintQualityLow PrintQuality = 0
	// PrintQualityNormal: normal quality.
	PrintQualityNormal PrintQuality = 1
	// PrintQualityHigh: high quality.
	PrintQualityHigh PrintQuality = 2
	// PrintQualityDraft: draft quality.
	PrintQualityDraft PrintQuality = 3
)

func marshalPrintQuality(p uintptr) (interface{}, error) {
	return PrintQuality(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PrintStatus: the status gives a rough indication of the completion of a
// running print operation.
type PrintStatus int

const (
	// PrintStatusInitial: the printing has not started yet; this status is set
	// initially, and while the print dialog is shown.
	PrintStatusInitial PrintStatus = 0
	// PrintStatusPreparing: this status is set while the begin-print signal is
	// emitted and during pagination.
	PrintStatusPreparing PrintStatus = 1
	// PrintStatusGeneratingData: this status is set while the pages are being
	// rendered.
	PrintStatusGeneratingData PrintStatus = 2
	// PrintStatusSendingData: the print job is being sent off to the printer.
	PrintStatusSendingData PrintStatus = 3
	// PrintStatusPending: the print job has been sent to the printer, but is
	// not printed for some reason, e.g. the printer may be stopped.
	PrintStatusPending PrintStatus = 4
	// PrintStatusPendingIssue: some problem has occurred during printing, e.g.
	// a paper jam.
	PrintStatusPendingIssue PrintStatus = 5
	// PrintStatusPrinting: the printer is processing the print job.
	PrintStatusPrinting PrintStatus = 6
	// PrintStatusFinished: the printing has been completed successfully.
	PrintStatusFinished PrintStatus = 7
	// PrintStatusFinishedAborted: the printing has been aborted.
	PrintStatusFinishedAborted PrintStatus = 8
)

func marshalPrintStatus(p uintptr) (interface{}, error) {
	return PrintStatus(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PropagationLimit describes limits of a EventController for handling events
// targeting other widgets.
type PropagationLimit int

const (
	// PropagationLimitNone events are handled regardless of what their target
	// is.
	PropagationLimitNone PropagationLimit = 0
	// PropagationLimitSameNative events are only handled if their target is in
	// the same Native as the event controllers widget. Note that some event
	// types have two targets (origin and destination).
	PropagationLimitSameNative PropagationLimit = 1
)

func marshalPropagationLimit(p uintptr) (interface{}, error) {
	return PropagationLimit(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PropagationPhase describes the stage at which events are fed into a
// EventController.
type PropagationPhase int

const (
	// PropagationPhaseNone events are not delivered.
	PropagationPhaseNone PropagationPhase = 0
	// PropagationPhaseCapture events are delivered in the capture phase. The
	// capture phase happens before the bubble phase, runs from the toplevel
	// down to the event widget. This option should only be used on containers
	// that might possibly handle events before their children do.
	PropagationPhaseCapture PropagationPhase = 1
	// PropagationPhaseBubble events are delivered in the bubble phase. The
	// bubble phase happens after the capture phase, and before the default
	// handlers are run. This phase runs from the event widget, up to the
	// toplevel.
	PropagationPhaseBubble PropagationPhase = 2
	// PropagationPhaseTarget events are delivered in the default widget event
	// handlers, note that widget implementations must chain up on button,
	// motion, touch and grab broken handlers for controllers in this phase to
	// be run.
	PropagationPhaseTarget PropagationPhase = 3
)

func marshalPropagationPhase(p uintptr) (interface{}, error) {
	return PropagationPhase(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// RecentManagerError: error codes for RecentManager operations
type RecentManagerError int

const (
	// RecentManagerErrorNotFound: the URI specified does not exists in the
	// recently used resources list.
	RecentManagerErrorNotFound RecentManagerError = 0
	// RecentManagerErrorInvalidURI: the URI specified is not valid.
	RecentManagerErrorInvalidURI RecentManagerError = 1
	// RecentManagerErrorInvalidEncoding: the supplied string is not UTF-8
	// encoded.
	RecentManagerErrorInvalidEncoding RecentManagerError = 2
	// RecentManagerErrorNotRegistered: no application has registered the
	// specified item.
	RecentManagerErrorNotRegistered RecentManagerError = 3
	// RecentManagerErrorRead: failure while reading the recently used resources
	// file.
	RecentManagerErrorRead RecentManagerError = 4
	// RecentManagerErrorWrite: failure while writing the recently used
	// resources file.
	RecentManagerErrorWrite RecentManagerError = 5
	// RecentManagerErrorUnknown: unspecified error.
	RecentManagerErrorUnknown RecentManagerError = 6
)

func marshalRecentManagerError(p uintptr) (interface{}, error) {
	return RecentManagerError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ResponseType: predefined values for use as response ids in
// gtk_dialog_add_button(). All predefined values are negative; GTK leaves
// values of 0 or greater for application-defined response ids.
type ResponseType int

const (
	// ResponseTypeNone: returned if an action widget has no response id, or if
	// the dialog gets programmatically hidden or destroyed
	ResponseTypeNone ResponseType = -1
	// ResponseTypeReject: generic response id, not used by GTK dialogs
	ResponseTypeReject ResponseType = -2
	// ResponseTypeAccept: generic response id, not used by GTK dialogs
	ResponseTypeAccept ResponseType = -3
	// ResponseTypeDeleteEvent: returned if the dialog is deleted
	ResponseTypeDeleteEvent ResponseType = -4
	// ResponseTypeOk: returned by OK buttons in GTK dialogs
	ResponseTypeOk ResponseType = -5
	// ResponseTypeCancel: returned by Cancel buttons in GTK dialogs
	ResponseTypeCancel ResponseType = -6
	// ResponseTypeClose: returned by Close buttons in GTK dialogs
	ResponseTypeClose ResponseType = -7
	// ResponseTypeYes: returned by Yes buttons in GTK dialogs
	ResponseTypeYes ResponseType = -8
	// ResponseTypeNo: returned by No buttons in GTK dialogs
	ResponseTypeNo ResponseType = -9
	// ResponseTypeApply: returned by Apply buttons in GTK dialogs
	ResponseTypeApply ResponseType = -10
	// ResponseTypeHelp: returned by Help buttons in GTK dialogs
	ResponseTypeHelp ResponseType = -11
)

func marshalResponseType(p uintptr) (interface{}, error) {
	return ResponseType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// RevealerTransitionType: these enumeration values describe the possible
// transitions when the child of a Revealer widget is shown or hidden.
type RevealerTransitionType int

const (
	// RevealerTransitionTypeNone: no transition
	RevealerTransitionTypeNone RevealerTransitionType = 0
	// RevealerTransitionTypeCrossfade: fade in
	RevealerTransitionTypeCrossfade RevealerTransitionType = 1
	// RevealerTransitionTypeSlideRight: slide in from the left
	RevealerTransitionTypeSlideRight RevealerTransitionType = 2
	// RevealerTransitionTypeSlideLeft: slide in from the right
	RevealerTransitionTypeSlideLeft RevealerTransitionType = 3
	// RevealerTransitionTypeSlideUp: slide in from the bottom
	RevealerTransitionTypeSlideUp RevealerTransitionType = 4
	// RevealerTransitionTypeSlideDown: slide in from the top
	RevealerTransitionTypeSlideDown RevealerTransitionType = 5
	// RevealerTransitionTypeSwingRight: floop in from the left
	RevealerTransitionTypeSwingRight RevealerTransitionType = 6
	// RevealerTransitionTypeSwingLeft: floop in from the right
	RevealerTransitionTypeSwingLeft RevealerTransitionType = 7
	// RevealerTransitionTypeSwingUp: floop in from the bottom
	RevealerTransitionTypeSwingUp RevealerTransitionType = 8
	// RevealerTransitionTypeSwingDown: floop in from the top
	RevealerTransitionTypeSwingDown RevealerTransitionType = 9
)

func marshalRevealerTransitionType(p uintptr) (interface{}, error) {
	return RevealerTransitionType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

type ScrollStep int

const (
	// ScrollStepSteps: scroll in steps.
	ScrollStepSteps ScrollStep = 0
	// ScrollStepPages: scroll by pages.
	ScrollStepPages ScrollStep = 1
	// ScrollStepEnds: scroll to ends.
	ScrollStepEnds ScrollStep = 2
	// ScrollStepHorizontalSteps: scroll in horizontal steps.
	ScrollStepHorizontalSteps ScrollStep = 3
	// ScrollStepHorizontalPages: scroll by horizontal pages.
	ScrollStepHorizontalPages ScrollStep = 4
	// ScrollStepHorizontalEnds: scroll to the horizontal ends.
	ScrollStepHorizontalEnds ScrollStep = 5
)

func marshalScrollStep(p uintptr) (interface{}, error) {
	return ScrollStep(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ScrollType: scrolling types.
type ScrollType int

const (
	// ScrollTypeNone: no scrolling.
	ScrollTypeNone ScrollType = 0
	// ScrollTypeJump: jump to new location.
	ScrollTypeJump ScrollType = 1
	// ScrollTypeStepBackward: step backward.
	ScrollTypeStepBackward ScrollType = 2
	// ScrollTypeStepForward: step forward.
	ScrollTypeStepForward ScrollType = 3
	// ScrollTypePageBackward: page backward.
	ScrollTypePageBackward ScrollType = 4
	// ScrollTypePageForward: page forward.
	ScrollTypePageForward ScrollType = 5
	// ScrollTypeStepUp: step up.
	ScrollTypeStepUp ScrollType = 6
	// ScrollTypeStepDown: step down.
	ScrollTypeStepDown ScrollType = 7
	// ScrollTypePageUp: page up.
	ScrollTypePageUp ScrollType = 8
	// ScrollTypePageDown: page down.
	ScrollTypePageDown ScrollType = 9
	// ScrollTypeStepLeft: step to the left.
	ScrollTypeStepLeft ScrollType = 10
	// ScrollTypeStepRight: step to the right.
	ScrollTypeStepRight ScrollType = 11
	// ScrollTypePageLeft: page to the left.
	ScrollTypePageLeft ScrollType = 12
	// ScrollTypePageRight: page to the right.
	ScrollTypePageRight ScrollType = 13
	// ScrollTypeStart: scroll to start.
	ScrollTypeStart ScrollType = 14
	// ScrollTypeEnd: scroll to end.
	ScrollTypeEnd ScrollType = 15
)

func marshalScrollType(p uintptr) (interface{}, error) {
	return ScrollType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ScrollablePolicy defines the policy to be used in a scrollable widget when
// updating the scrolled window adjustments in a given orientation.
type ScrollablePolicy int

const (
	// ScrollablePolicyMinimum: scrollable adjustments are based on the minimum
	// size
	ScrollablePolicyMinimum ScrollablePolicy = 0
	// ScrollablePolicyNatural: scrollable adjustments are based on the natural
	// size
	ScrollablePolicyNatural ScrollablePolicy = 1
)

func marshalScrollablePolicy(p uintptr) (interface{}, error) {
	return ScrollablePolicy(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SelectionMode: used to control what selections users are allowed to make.
type SelectionMode int

const (
	// SelectionModeNone: no selection is possible.
	SelectionModeNone SelectionMode = 0
	// SelectionModeSingle: zero or one element may be selected.
	SelectionModeSingle SelectionMode = 1
	// SelectionModeBrowse: exactly one element is selected. In some
	// circumstances, such as initially or during a search operation, it’s
	// possible for no element to be selected with GTK_SELECTION_BROWSE. What is
	// really enforced is that the user can’t deselect a currently selected
	// element except by selecting another element.
	SelectionModeBrowse SelectionMode = 2
	// SelectionModeMultiple: any number of elements may be selected. The Ctrl
	// key may be used to enlarge the selection, and Shift key to select between
	// the focus and the child pointed to. Some widgets may also allow
	// Click-drag to select a range of elements.
	SelectionModeMultiple SelectionMode = 3
)

func marshalSelectionMode(p uintptr) (interface{}, error) {
	return SelectionMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SensitivityType determines how GTK handles the sensitivity of various
// controls, such as combo box buttons.
type SensitivityType int

const (
	// SensitivityTypeAuto: the control is made insensitive if no action can be
	// triggered
	SensitivityTypeAuto SensitivityType = 0
	// SensitivityTypeOn: the control is always sensitive
	SensitivityTypeOn SensitivityType = 1
	// SensitivityTypeOff: the control is always insensitive
	SensitivityTypeOff SensitivityType = 2
)

func marshalSensitivityType(p uintptr) (interface{}, error) {
	return SensitivityType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ShortcutScope describes where Shortcuts added to a ShortcutController get
// handled.
type ShortcutScope int

const (
	// ShortcutScopeLocal shortcuts are handled inside the widget the controller
	// belongs to.
	ShortcutScopeLocal ShortcutScope = 0
	// ShortcutScopeManaged shortcuts are handled by the first ancestor that is
	// a ShortcutManager
	ShortcutScopeManaged ShortcutScope = 1
	// ShortcutScopeGlobal shortcuts are handled by the root widget.
	ShortcutScopeGlobal ShortcutScope = 2
)

func marshalShortcutScope(p uintptr) (interface{}, error) {
	return ShortcutScope(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ShortcutType: gtkShortcutType specifies the kind of shortcut that is being
// described. More values may be added to this enumeration over time.
type ShortcutType int

const (
	// ShortcutTypeAccelerator: the shortcut is a keyboard accelerator. The
	// ShortcutsShortcut:accelerator property will be used.
	ShortcutTypeAccelerator ShortcutType = 0
	// ShortcutTypeGesturePinch: the shortcut is a pinch gesture. GTK+ provides
	// an icon and subtitle.
	ShortcutTypeGesturePinch ShortcutType = 1
	// ShortcutTypeGestureStretch: the shortcut is a stretch gesture. GTK+
	// provides an icon and subtitle.
	ShortcutTypeGestureStretch ShortcutType = 2
	// ShortcutTypeGestureRotateClockwise: the shortcut is a clockwise rotation
	// gesture. GTK+ provides an icon and subtitle.
	ShortcutTypeGestureRotateClockwise ShortcutType = 3
	// ShortcutTypeGestureRotateCounterclockwise: the shortcut is a
	// counterclockwise rotation gesture. GTK+ provides an icon and subtitle.
	ShortcutTypeGestureRotateCounterclockwise ShortcutType = 4
	// ShortcutTypeGestureTwoFingerSwipeLeft: the shortcut is a two-finger swipe
	// gesture. GTK+ provides an icon and subtitle.
	ShortcutTypeGestureTwoFingerSwipeLeft ShortcutType = 5
	// ShortcutTypeGestureTwoFingerSwipeRight: the shortcut is a two-finger
	// swipe gesture. GTK+ provides an icon and subtitle.
	ShortcutTypeGestureTwoFingerSwipeRight ShortcutType = 6
	// ShortcutTypeGesture: the shortcut is a gesture. The
	// ShortcutsShortcut:icon property will be used.
	ShortcutTypeGesture ShortcutType = 7
	// ShortcutTypeGestureSwipeLeft: the shortcut is a swipe gesture. GTK+
	// provides an icon and subtitle.
	ShortcutTypeGestureSwipeLeft ShortcutType = 8
	// ShortcutTypeGestureSwipeRight: the shortcut is a swipe gesture. GTK+
	// provides an icon and subtitle.
	ShortcutTypeGestureSwipeRight ShortcutType = 9
)

func marshalShortcutType(p uintptr) (interface{}, error) {
	return ShortcutType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SizeGroupMode: the mode of the size group determines the directions in which
// the size group affects the requested sizes of its component widgets.
type SizeGroupMode int

const (
	// SizeGroupModeNone: group has no effect
	SizeGroupModeNone SizeGroupMode = 0
	// SizeGroupModeHorizontal: group affects horizontal requisition
	SizeGroupModeHorizontal SizeGroupMode = 1
	// SizeGroupModeVertical: group affects vertical requisition
	SizeGroupModeVertical SizeGroupMode = 2
	// SizeGroupModeBoth: group affects both horizontal and vertical requisition
	SizeGroupModeBoth SizeGroupMode = 3
)

func marshalSizeGroupMode(p uintptr) (interface{}, error) {
	return SizeGroupMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SizeRequestMode specifies a preference for height-for-width or
// width-for-height geometry management.
type SizeRequestMode int

const (
	// SizeRequestModeHeightForWidth: prefer height-for-width geometry
	// management
	SizeRequestModeHeightForWidth SizeRequestMode = 0
	// SizeRequestModeWidthForHeight: prefer width-for-height geometry
	// management
	SizeRequestModeWidthForHeight SizeRequestMode = 1
	// SizeRequestModeConstantSize: don’t trade height-for-width or
	// width-for-height
	SizeRequestModeConstantSize SizeRequestMode = 2
)

func marshalSizeRequestMode(p uintptr) (interface{}, error) {
	return SizeRequestMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SortType determines the direction of a sort.
type SortType int

const (
	// SortTypeAscending: sorting is in ascending order.
	SortTypeAscending SortType = 0
	// SortTypeDescending: sorting is in descending order.
	SortTypeDescending SortType = 1
)

func marshalSortType(p uintptr) (interface{}, error) {
	return SortType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SorterChange describes changes in a sorter in more detail and allows users to
// optimize resorting.
type SorterChange int

const (
	// SorterChangeDifferent: the sorter change cannot be described by any of
	// the other enumeration values
	SorterChangeDifferent SorterChange = 0
	// SorterChangeInverted: the sort order was inverted. Comparisons that
	// returned GTK_ORDERING_SMALLER now return GTK_ORDERING_LARGER and vice
	// versa. Other comparisons return the same values as before.
	SorterChangeInverted SorterChange = 1
	// SorterChangeLessStrict: the sorter is less strict: Comparisons may now
	// return GTK_ORDERING_EQUAL that did not do so before.
	SorterChangeLessStrict SorterChange = 2
	// SorterChangeMoreStrict: the sorter is more strict: Comparisons that did
	// return GTK_ORDERING_EQUAL may not do so anymore.
	SorterChangeMoreStrict SorterChange = 3
)

func marshalSorterChange(p uintptr) (interface{}, error) {
	return SorterChange(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SorterOrder describes the type of order that a Sorter may describe.
type SorterOrder int

const (
	// SorterOrderPartial: a partial order. Any Ordering is possible.
	SorterOrderPartial SorterOrder = 0
	// SorterOrderNone: no order, all elements are considered equal.
	// gtk_sorter_compare() will only return GTK_ORDERING_EQUAL.
	SorterOrderNone SorterOrder = 1
	// SorterOrderTotal: a total order. gtk_sorter_compare() will only return
	// GTK_ORDERING_EQUAL if an item is compared with itself. Two different
	// items will never cause this value to be returned.
	SorterOrderTotal SorterOrder = 2
)

func marshalSorterOrder(p uintptr) (interface{}, error) {
	return SorterOrder(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SpinButtonUpdatePolicy: the spin button update policy determines whether the
// spin button displays values even if they are outside the bounds of its
// adjustment. See gtk_spin_button_set_update_policy().
type SpinButtonUpdatePolicy int

const (
	// SpinButtonUpdatePolicyAlways: when refreshing your SpinButton, the value
	// is always displayed
	SpinButtonUpdatePolicyAlways SpinButtonUpdatePolicy = 0
	// SpinButtonUpdatePolicyIfValid: when refreshing your SpinButton, the value
	// is only displayed if it is valid within the bounds of the spin button's
	// adjustment
	SpinButtonUpdatePolicyIfValid SpinButtonUpdatePolicy = 1
)

func marshalSpinButtonUpdatePolicy(p uintptr) (interface{}, error) {
	return SpinButtonUpdatePolicy(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SpinType: the values of the GtkSpinType enumeration are used to specify the
// change to make in gtk_spin_button_spin().
type SpinType int

const (
	// SpinTypeStepForward: increment by the adjustments step increment.
	SpinTypeStepForward SpinType = 0
	// SpinTypeStepBackward: decrement by the adjustments step increment.
	SpinTypeStepBackward SpinType = 1
	// SpinTypePageForward: increment by the adjustments page increment.
	SpinTypePageForward SpinType = 2
	// SpinTypePageBackward: decrement by the adjustments page increment.
	SpinTypePageBackward SpinType = 3
	// SpinTypeHome: go to the adjustments lower bound.
	SpinTypeHome SpinType = 4
	// SpinTypeEnd: go to the adjustments upper bound.
	SpinTypeEnd SpinType = 5
	// SpinTypeUserDefined: change by a specified amount.
	SpinTypeUserDefined SpinType = 6
)

func marshalSpinType(p uintptr) (interface{}, error) {
	return SpinType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// StackTransitionType: these enumeration values describe the possible
// transitions between pages in a Stack widget.
//
// New values may be added to this enumeration over time.
type StackTransitionType int

const (
	// StackTransitionTypeNone: no transition
	StackTransitionTypeNone StackTransitionType = 0
	// StackTransitionTypeCrossfade: a cross-fade
	StackTransitionTypeCrossfade StackTransitionType = 1
	// StackTransitionTypeSlideRight: slide from left to right
	StackTransitionTypeSlideRight StackTransitionType = 2
	// StackTransitionTypeSlideLeft: slide from right to left
	StackTransitionTypeSlideLeft StackTransitionType = 3
	// StackTransitionTypeSlideUp: slide from bottom up
	StackTransitionTypeSlideUp StackTransitionType = 4
	// StackTransitionTypeSlideDown: slide from top down
	StackTransitionTypeSlideDown StackTransitionType = 5
	// StackTransitionTypeSlideLeftRight: slide from left or right according to
	// the children order
	StackTransitionTypeSlideLeftRight StackTransitionType = 6
	// StackTransitionTypeSlideUpDown: slide from top down or bottom up
	// according to the order
	StackTransitionTypeSlideUpDown StackTransitionType = 7
	// StackTransitionTypeOverUp: cover the old page by sliding up
	StackTransitionTypeOverUp StackTransitionType = 8
	// StackTransitionTypeOverDown: cover the old page by sliding down
	StackTransitionTypeOverDown StackTransitionType = 9
	// StackTransitionTypeOverLeft: cover the old page by sliding to the left
	StackTransitionTypeOverLeft StackTransitionType = 10
	// StackTransitionTypeOverRight: cover the old page by sliding to the right
	StackTransitionTypeOverRight StackTransitionType = 11
	// StackTransitionTypeUnderUp: uncover the new page by sliding up
	StackTransitionTypeUnderUp StackTransitionType = 12
	// StackTransitionTypeUnderDown: uncover the new page by sliding down
	StackTransitionTypeUnderDown StackTransitionType = 13
	// StackTransitionTypeUnderLeft: uncover the new page by sliding to the left
	StackTransitionTypeUnderLeft StackTransitionType = 14
	// StackTransitionTypeUnderRight: uncover the new page by sliding to the
	// right
	StackTransitionTypeUnderRight StackTransitionType = 15
	// StackTransitionTypeOverUpDown: cover the old page sliding up or uncover
	// the new page sliding down, according to order
	StackTransitionTypeOverUpDown StackTransitionType = 16
	// StackTransitionTypeOverDownUp: cover the old page sliding down or uncover
	// the new page sliding up, according to order
	StackTransitionTypeOverDownUp StackTransitionType = 17
	// StackTransitionTypeOverLeftRight: cover the old page sliding left or
	// uncover the new page sliding right, according to order
	StackTransitionTypeOverLeftRight StackTransitionType = 18
	// StackTransitionTypeOverRightLeft: cover the old page sliding right or
	// uncover the new page sliding left, according to order
	StackTransitionTypeOverRightLeft StackTransitionType = 19
	// StackTransitionTypeRotateLeft: pretend the pages are sides of a cube and
	// rotate that cube to the left
	StackTransitionTypeRotateLeft StackTransitionType = 20
	// StackTransitionTypeRotateRight: pretend the pages are sides of a cube and
	// rotate that cube to the right
	StackTransitionTypeRotateRight StackTransitionType = 21
	// StackTransitionTypeRotateLeftRight: pretend the pages are sides of a cube
	// and rotate that cube to the left or right according to the children order
	StackTransitionTypeRotateLeftRight StackTransitionType = 22
)

func marshalStackTransitionType(p uintptr) (interface{}, error) {
	return StackTransitionType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// StringFilterMatchMode specifies how search strings are matched inside text.
type StringFilterMatchMode int

const (
	// StringFilterMatchModeExact: the search string and text must match
	// exactly.
	StringFilterMatchModeExact StringFilterMatchMode = 0
	// StringFilterMatchModeSubstring: the search string must be contained as a
	// substring inside the text.
	StringFilterMatchModeSubstring StringFilterMatchMode = 1
	// StringFilterMatchModePrefix: the text must begin with the search string.
	StringFilterMatchModePrefix StringFilterMatchMode = 2
)

func marshalStringFilterMatchMode(p uintptr) (interface{}, error) {
	return StringFilterMatchMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SystemSetting values that can be passed to the
// GtkWidgetClass.system_setting_changed vfunc to indicate that a system setting
// has changed and widgets may need to drop caches, or react otherwise.
//
// Most of the values correspond to Settings properties.
//
// More values may be added over time.
type SystemSetting int

const (
	// SystemSettingDPI: the Settings:gtk-xft-dpi setting has changed
	SystemSettingDPI SystemSetting = 0
	// SystemSettingFontName: the Settings:gtk-font-name setting has changed
	SystemSettingFontName SystemSetting = 1
	// SystemSettingFontConfig: the font configuration has changed in a way that
	// requires text to be redrawn. This can be any of the
	// Settings:gtk-xft-antialias, Settings:gtk-xft-hinting,
	// Settings:gtk-xft-hintstyle, Settings:gtk-xft-rgba or
	// Settings:gtk-fontconfig-timestamp settings
	SystemSettingFontConfig SystemSetting = 2
	// SystemSettingDisplay: the display has changed
	SystemSettingDisplay SystemSetting = 3
	// SystemSettingIconTheme: the icon theme has changed in a way that requires
	// icons to be looked up again
	SystemSettingIconTheme SystemSetting = 4
)

func marshalSystemSetting(p uintptr) (interface{}, error) {
	return SystemSetting(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TextDirection: reading directions for text.
type TextDirection int

const (
	// TextDirectionNone: no direction.
	TextDirectionNone TextDirection = 0
	// TextDirectionLTR: left to right text direction.
	TextDirectionLTR TextDirection = 1
	// TextDirectionRTL: right to left text direction.
	TextDirectionRTL TextDirection = 2
)

func marshalTextDirection(p uintptr) (interface{}, error) {
	return TextDirection(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TextExtendSelection: granularity types that extend the text selection. Use
// the TextView::extend-selection signal to customize the selection.
type TextExtendSelection int

const (
	// TextExtendSelectionWord selects the current word. It is triggered by a
	// double-click for example.
	TextExtendSelectionWord TextExtendSelection = 0
	// TextExtendSelectionLine selects the current line. It is triggered by a
	// triple-click for example.
	TextExtendSelectionLine TextExtendSelection = 1
)

func marshalTextExtendSelection(p uintptr) (interface{}, error) {
	return TextExtendSelection(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TextViewLayer: used to reference the layers of TextView for the purpose of
// customized drawing with the ::snapshot_layer vfunc.
type TextViewLayer int

const (
	// TextViewLayerBelowText: the layer rendered below the text (but above the
	// background).
	TextViewLayerBelowText TextViewLayer = 0
	// TextViewLayerAboveText: the layer rendered above the text.
	TextViewLayerAboveText TextViewLayer = 1
)

func marshalTextViewLayer(p uintptr) (interface{}, error) {
	return TextViewLayer(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TextWindowType: used to reference the parts of TextView.
type TextWindowType int

const (
	// TextWindowTypeWidget: window that floats over scrolling areas.
	TextWindowTypeWidget TextWindowType = 1
	// TextWindowTypeText: scrollable text window.
	TextWindowTypeText TextWindowType = 2
	// TextWindowTypeLeft: left side border window.
	TextWindowTypeLeft TextWindowType = 3
	// TextWindowTypeRight: right side border window.
	TextWindowTypeRight TextWindowType = 4
	// TextWindowTypeTop: top border window.
	TextWindowTypeTop TextWindowType = 5
	// TextWindowTypeBottom: bottom border window.
	TextWindowTypeBottom TextWindowType = 6
)

func marshalTextWindowType(p uintptr) (interface{}, error) {
	return TextWindowType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TreeViewColumnSizing: the sizing method the column uses to determine its
// width. Please note that GTK_TREE_VIEW_COLUMN_AUTOSIZE are inefficient for
// large views, and can make columns appear choppy.
type TreeViewColumnSizing int

const (
	// TreeViewColumnSizingGrowOnly columns only get bigger in reaction to
	// changes in the model
	TreeViewColumnSizingGrowOnly TreeViewColumnSizing = 0
	// TreeViewColumnSizingAutosize columns resize to be the optimal size every
	// time the model changes.
	TreeViewColumnSizingAutosize TreeViewColumnSizing = 1
	// TreeViewColumnSizingFixed columns are a fixed numbers of pixels wide.
	TreeViewColumnSizingFixed TreeViewColumnSizing = 2
)

func marshalTreeViewColumnSizing(p uintptr) (interface{}, error) {
	return TreeViewColumnSizing(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TreeViewDropPosition: an enum for determining where a dropped row goes.
type TreeViewDropPosition int

const (
	// TreeViewDropPositionBefore: dropped row is inserted before
	TreeViewDropPositionBefore TreeViewDropPosition = 0
	// TreeViewDropPositionAfter: dropped row is inserted after
	TreeViewDropPositionAfter TreeViewDropPosition = 1
	// TreeViewDropPositionIntoOrBefore: dropped row becomes a child or is
	// inserted before
	TreeViewDropPositionIntoOrBefore TreeViewDropPosition = 2
	// TreeViewDropPositionIntoOrAfter: dropped row becomes a child or is
	// inserted after
	TreeViewDropPositionIntoOrAfter TreeViewDropPosition = 3
)

func marshalTreeViewDropPosition(p uintptr) (interface{}, error) {
	return TreeViewDropPosition(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TreeViewGridLines: used to indicate which grid lines to draw in a tree view.
type TreeViewGridLines int

const (
	// TreeViewGridLinesNone: no grid lines.
	TreeViewGridLinesNone TreeViewGridLines = 0
	// TreeViewGridLinesHorizontal: horizontal grid lines.
	TreeViewGridLinesHorizontal TreeViewGridLines = 1
	// TreeViewGridLinesVertical: vertical grid lines.
	TreeViewGridLinesVertical TreeViewGridLines = 2
	// TreeViewGridLinesBoth: horizontal and vertical grid lines.
	TreeViewGridLinesBoth TreeViewGridLines = 3
)

func marshalTreeViewGridLines(p uintptr) (interface{}, error) {
	return TreeViewGridLines(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// Unit: see also gtk_print_settings_set_paper_width().
type Unit int

const (
	// UnitNone: no units.
	UnitNone Unit = 0
	// UnitPoints dimensions in points.
	UnitPoints Unit = 1
	// UnitInch dimensions in inches.
	UnitInch Unit = 2
	// UnitMm dimensions in millimeters
	UnitMm Unit = 3
)

func marshalUnit(p uintptr) (interface{}, error) {
	return Unit(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// WrapMode describes a type of line wrapping.
type WrapMode int

const (
	// WrapModeNone: do not wrap lines; just make the text area wider
	WrapModeNone WrapMode = 0
	// WrapModeChar: wrap text, breaking lines anywhere the cursor can appear
	// (between characters, usually - if you want to be technical, between
	// graphemes, see pango_get_log_attrs())
	WrapModeChar WrapMode = 1
	// WrapModeWord: wrap text, breaking lines in between words
	WrapModeWord WrapMode = 2
	// WrapModeWordChar: wrap text, breaking lines in between words, or if that
	// is not enough, also between graphemes
	WrapModeWordChar WrapMode = 3
)

func marshalWrapMode(p uintptr) (interface{}, error) {
	return WrapMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ApplicationInhibitFlags types of user actions that may be blocked by
// gtk_application_inhibit().
type ApplicationInhibitFlags int

const (
	// ApplicationInhibitFlagsLogout: inhibit ending the user session by logging
	// out or by shutting down the computer
	ApplicationInhibitFlagsLogout ApplicationInhibitFlags = 0b1
	// ApplicationInhibitFlagsSwitch: inhibit user switching
	ApplicationInhibitFlagsSwitch ApplicationInhibitFlags = 0b10
	// ApplicationInhibitFlagsSuspend: inhibit suspending the session or
	// computer
	ApplicationInhibitFlagsSuspend ApplicationInhibitFlags = 0b100
	// ApplicationInhibitFlagsIdle: inhibit the session being marked as idle
	// (and possibly locked)
	ApplicationInhibitFlagsIdle ApplicationInhibitFlags = 0b1000
)

func marshalApplicationInhibitFlags(p uintptr) (interface{}, error) {
	return ApplicationInhibitFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// BuilderClosureFlags: the list of flags that can be passed to
// gtk_builder_create_closure(). New values may be added in the future for new
// features, so external implementations of GtkBuilderScopeInterface should test
// the flags for unknown values and raise a GTK_BUILDER_ERROR_INVALID_ATTRIBUTE
// error when they encounter one.
type BuilderClosureFlags int

const (
	// BuilderClosureFlagsSwapped: the closure should be created swapped. See
	// g_cclosure_new_swap() for details.
	BuilderClosureFlagsSwapped BuilderClosureFlags = 0b1
)

func marshalBuilderClosureFlags(p uintptr) (interface{}, error) {
	return BuilderClosureFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// CellRendererState tells how a cell is to be rendered.
type CellRendererState int

const (
	// CellRendererStateSelected: the cell is currently selected, and probably
	// has a selection colored background to render to.
	CellRendererStateSelected CellRendererState = 0b1
	// CellRendererStatePrelit: the mouse is hovering over the cell.
	CellRendererStatePrelit CellRendererState = 0b10
	// CellRendererStateInsensitive: the cell is drawn in an insensitive manner
	CellRendererStateInsensitive CellRendererState = 0b100
	// CellRendererStateSorted: the cell is in a sorted row
	CellRendererStateSorted CellRendererState = 0b1000
	// CellRendererStateFocused: the cell is in the focus row.
	CellRendererStateFocused CellRendererState = 0b10000
	// CellRendererStateExpandable: the cell is in a row that can be expanded
	CellRendererStateExpandable CellRendererState = 0b100000
	// CellRendererStateExpanded: the cell is in a row that is expanded
	CellRendererStateExpanded CellRendererState = 0b1000000
)

func marshalCellRendererState(p uintptr) (interface{}, error) {
	return CellRendererState(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

type DebugFlags int

const (
	DebugFlagsText DebugFlags = 0b1

	DebugFlagsTree DebugFlags = 0b10

	DebugFlagsKeybindings DebugFlags = 0b100

	DebugFlagsModules DebugFlags = 0b1000

	DebugFlagsGeometry DebugFlags = 0b10000

	DebugFlagsIcontheme DebugFlags = 0b100000

	DebugFlagsPrinting DebugFlags = 0b1000000

	DebugFlagsBuilder DebugFlags = 0b10000000

	DebugFlagsSizeRequest DebugFlags = 0b100000000

	DebugFlagsNoCSSCache DebugFlags = 0b1000000000

	DebugFlagsInteractive DebugFlags = 0b10000000000

	DebugFlagsTouchscreen DebugFlags = 0b100000000000

	DebugFlagsActions DebugFlags = 0b1000000000000

	DebugFlagsLayout DebugFlags = 0b10000000000000

	DebugFlagsSnapshot DebugFlags = 0b100000000000000

	DebugFlagsConstraints DebugFlags = 0b1000000000000000

	DebugFlagsBuilderObjects DebugFlags = 0b10000000000000000

	DebugFlagsA11Y DebugFlags = 0b100000000000000000
)

func marshalDebugFlags(p uintptr) (interface{}, error) {
	return DebugFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DialogFlags flags used to influence dialog construction.
type DialogFlags int

const (
	// DialogFlagsModal: make the constructed dialog modal, see
	// gtk_window_set_modal()
	DialogFlagsModal DialogFlags = 0b1
	// DialogFlagsDestroyWithParent: destroy the dialog when its parent is
	// destroyed, see gtk_window_set_destroy_with_parent()
	DialogFlagsDestroyWithParent DialogFlags = 0b10
	// DialogFlagsUseHeaderBar: create dialog with actions in header bar instead
	// of action area
	DialogFlagsUseHeaderBar DialogFlags = 0b100
)

func marshalDialogFlags(p uintptr) (interface{}, error) {
	return DialogFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// EventControllerScrollFlags describes the behavior of a EventControllerScroll.
type EventControllerScrollFlags int

const (
	// EventControllerScrollFlagsNone: don't emit scroll.
	EventControllerScrollFlagsNone EventControllerScrollFlags = 0b0
	// EventControllerScrollFlagsVertical: emit scroll with vertical deltas.
	EventControllerScrollFlagsVertical EventControllerScrollFlags = 0b1
	// EventControllerScrollFlagsHorizontal: emit scroll with horizontal deltas.
	EventControllerScrollFlagsHorizontal EventControllerScrollFlags = 0b10
	// EventControllerScrollFlagsDiscrete: only emit deltas that are multiples
	// of 1.
	EventControllerScrollFlagsDiscrete EventControllerScrollFlags = 0b100
	// EventControllerScrollFlagsKinetic: emit EventControllerScroll::decelerate
	// after continuous scroll finishes.
	EventControllerScrollFlagsKinetic EventControllerScrollFlags = 0b1000
	// EventControllerScrollFlagsBothAxes: emit scroll on both axes.
	EventControllerScrollFlagsBothAxes EventControllerScrollFlags = 0b11
)

func marshalEventControllerScrollFlags(p uintptr) (interface{}, error) {
	return EventControllerScrollFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FontChooserLevel: this enumeration specifies the granularity of font
// selection that is desired in a font chooser.
//
// This enumeration may be extended in the future; applications should ignore
// unknown values.
type FontChooserLevel int

const (
	// FontChooserLevelFamily: allow selecting a font family
	FontChooserLevelFamily FontChooserLevel = 0b0
	// FontChooserLevelStyle: allow selecting a specific font face
	FontChooserLevelStyle FontChooserLevel = 0b1
	// FontChooserLevelSize: allow selecting a specific font size
	FontChooserLevelSize FontChooserLevel = 0b10
	// FontChooserLevelVariations: allow changing OpenType font variation axes
	FontChooserLevelVariations FontChooserLevel = 0b100
	// FontChooserLevelFeatures: allow selecting specific OpenType font features
	FontChooserLevelFeatures FontChooserLevel = 0b1000
)

func marshalFontChooserLevel(p uintptr) (interface{}, error) {
	return FontChooserLevel(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// IconLookupFlags: used to specify options for gtk_icon_theme_lookup_icon()
type IconLookupFlags int

const (
	// IconLookupFlagsForceRegular: try to always load regular icons, even when
	// symbolic icon names are given
	IconLookupFlagsForceRegular IconLookupFlags = 0b1
	// IconLookupFlagsForceSymbolic: try to always load symbolic icons, even
	// when regular icon names are given
	IconLookupFlagsForceSymbolic IconLookupFlags = 0b10
	// IconLookupFlagsPreload starts loading the texture in the background so it
	// is ready when later needed.
	IconLookupFlagsPreload IconLookupFlags = 0b100
)

func marshalIconLookupFlags(p uintptr) (interface{}, error) {
	return IconLookupFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// InputHints describes hints that might be taken into account by input methods
// or applications. Note that input methods may already tailor their behaviour
// according to the InputPurpose of the entry.
//
// Some common sense is expected when using these flags - mixing
// GTK_INPUT_HINT_LOWERCASE with any of the uppercase hints makes no sense.
//
// This enumeration may be extended in the future; input methods should ignore
// unknown values.
type InputHints int

const (
	// InputHintsNone: no special behaviour suggested
	InputHintsNone InputHints = 0b0
	// InputHintsSpellcheck: suggest checking for typos
	InputHintsSpellcheck InputHints = 0b1
	// InputHintsNoSpellcheck: suggest not checking for typos
	InputHintsNoSpellcheck InputHints = 0b10
	// InputHintsWordCompletion: suggest word completion
	InputHintsWordCompletion InputHints = 0b100
	// InputHintsLowercase: suggest to convert all text to lowercase
	InputHintsLowercase InputHints = 0b1000
	// InputHintsUppercaseChars: suggest to capitalize all text
	InputHintsUppercaseChars InputHints = 0b10000
	// InputHintsUppercaseWords: suggest to capitalize the first character of
	// each word
	InputHintsUppercaseWords InputHints = 0b100000
	// InputHintsUppercaseSentences: suggest to capitalize the first word of
	// each sentence
	InputHintsUppercaseSentences InputHints = 0b1000000
	// InputHintsInhibitOsk: suggest to not show an onscreen keyboard (e.g for a
	// calculator that already has all the keys).
	InputHintsInhibitOsk InputHints = 0b10000000
	// InputHintsVerticalWriting: the text is vertical
	InputHintsVerticalWriting InputHints = 0b100000000
	// InputHintsEmoji: suggest offering Emoji support
	InputHintsEmoji InputHints = 0b1000000000
	// InputHintsNoEmoji: suggest not offering Emoji support
	InputHintsNoEmoji InputHints = 0b10000000000
	// InputHintsPrivate: request that the input method should not update
	// personalized data (like typing history)
	InputHintsPrivate InputHints = 0b100000000000
)

func marshalInputHints(p uintptr) (interface{}, error) {
	return InputHints(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PickFlags flags that influence the behavior of gtk_widget_pick()
type PickFlags int

const (
	// PickFlagsDefault: the default behavior, include widgets that are
	// receiving events
	PickFlagsDefault PickFlags = 0b0
	// PickFlagsInsensitive: include widgets that are insensitive
	PickFlagsInsensitive PickFlags = 0b1
	// PickFlagsNonTargetable: include widgets that are marked as
	// non-targetable. See Widget:can-target
	PickFlagsNonTargetable PickFlags = 0b10
)

func marshalPickFlags(p uintptr) (interface{}, error) {
	return PickFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PopoverMenuFlags flags that affect how popover menus are created from a menu
// model.
type PopoverMenuFlags int

const (
	// PopoverMenuFlagsNested: create submenus as nested popovers. Without this
	// flag, submenus are created as sliding pages that replace the main menu.
	PopoverMenuFlagsNested PopoverMenuFlags = 0b1
)

func marshalPopoverMenuFlags(p uintptr) (interface{}, error) {
	return PopoverMenuFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ShortcutActionFlags: list of flags that can be passed to action activation.
// More flags may be added in the future.
type ShortcutActionFlags int

const (
	// ShortcutActionFlagsExclusive: the action is the only action that can be
	// activated. If this flag is not set, a future activation may select a
	// different action.
	ShortcutActionFlagsExclusive ShortcutActionFlags = 0b1
)

func marshalShortcutActionFlags(p uintptr) (interface{}, error) {
	return ShortcutActionFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// StateFlags describes a widget state. Widget states are used to match the
// widget against CSS pseudo-classes. Note that GTK extends the regular CSS
// classes and sometimes uses different names.
type StateFlags int

const (
	// StateFlagsNormal: state during normal operation
	StateFlagsNormal StateFlags = 0b0
	// StateFlagsActive: widget is active
	StateFlagsActive StateFlags = 0b1
	// StateFlagsPrelight: widget has a mouse pointer over it
	StateFlagsPrelight StateFlags = 0b10
	// StateFlagsSelected: widget is selected
	StateFlagsSelected StateFlags = 0b100
	// StateFlagsInsensitive: widget is insensitive
	StateFlagsInsensitive StateFlags = 0b1000
	// StateFlagsInconsistent: widget is inconsistent
	StateFlagsInconsistent StateFlags = 0b10000
	// StateFlagsFocused: widget has the keyboard focus
	StateFlagsFocused StateFlags = 0b100000
	// StateFlagsBackdrop: widget is in a background toplevel window
	StateFlagsBackdrop StateFlags = 0b1000000
	// StateFlagsDirLTR: widget is in left-to-right text direction
	StateFlagsDirLTR StateFlags = 0b10000000
	// StateFlagsDirRTL: widget is in right-to-left text direction
	StateFlagsDirRTL StateFlags = 0b100000000
	// StateFlagsLink: widget is a link
	StateFlagsLink StateFlags = 0b1000000000
	// StateFlagsVisited: the location the widget points to has already been
	// visited
	StateFlagsVisited StateFlags = 0b10000000000
	// StateFlagsChecked: widget is checked
	StateFlagsChecked StateFlags = 0b100000000000
	// StateFlagsDropActive: widget is highlighted as a drop target for DND
	StateFlagsDropActive StateFlags = 0b1000000000000
	// StateFlagsFocusVisible: widget has the visible focus
	StateFlagsFocusVisible StateFlags = 0b10000000000000
	// StateFlagsFocusWithin: widget contains the keyboard focus
	StateFlagsFocusWithin StateFlags = 0b100000000000000
)

func marshalStateFlags(p uintptr) (interface{}, error) {
	return StateFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// StyleContextPrintFlags flags that modify the behavior of
// gtk_style_context_to_string(). New values may be added to this enumeration.
type StyleContextPrintFlags int

const (
	// StyleContextPrintFlagsNone: default value.
	StyleContextPrintFlagsNone StyleContextPrintFlags = 0b0
	// StyleContextPrintFlagsRecurse: print the entire tree of CSS nodes
	// starting at the style context's node
	StyleContextPrintFlagsRecurse StyleContextPrintFlags = 0b1
	// StyleContextPrintFlagsShowStyle: show the values of the CSS properties
	// for each node
	StyleContextPrintFlagsShowStyle StyleContextPrintFlags = 0b10
	// StyleContextPrintFlagsShowChange: show information about what changes
	// affect the styles
	StyleContextPrintFlagsShowChange StyleContextPrintFlags = 0b100
)

func marshalStyleContextPrintFlags(p uintptr) (interface{}, error) {
	return StyleContextPrintFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TextSearchFlags flags affecting how a search is done.
//
// If neither K_TEXT_SEARCH_VISIBLE_ONLY nor K_TEXT_SEARCH_TEXT_ONLY are
// enabled, the match must be exact; the special 0xFFFC character will match
// embedded paintables or child widgets.
type TextSearchFlags int

const (
	// TextSearchFlagsVisibleOnly: search only visible data. A search match may
	// have invisible text interspersed.
	TextSearchFlagsVisibleOnly TextSearchFlags = 0b1
	// TextSearchFlagsTextOnly: search only text. A match may have paintables or
	// child widgets mixed inside the matched range.
	TextSearchFlagsTextOnly TextSearchFlags = 0b10
	// TextSearchFlagsCaseInsensitive: the text will be matched regardless of
	// what case it is in.
	TextSearchFlagsCaseInsensitive TextSearchFlags = 0b100
)

func marshalTextSearchFlags(p uintptr) (interface{}, error) {
	return TextSearchFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TreeModelFlags: these flags indicate various properties of a TreeModel.
//
// They are returned by gtk_tree_model_get_flags(), and must be static for the
// lifetime of the object. A more complete description of
// K_TREE_MODEL_ITERS_PERSIST can be found in the overview of this section.
type TreeModelFlags int

const (
	// TreeModelFlagsItersPersist iterators survive all signals emitted by the
	// tree
	TreeModelFlagsItersPersist TreeModelFlags = 0b1
	// TreeModelFlagsListOnly: the model is a list only, and never has children
	TreeModelFlagsListOnly TreeModelFlags = 0b10
)

func marshalTreeModelFlags(p uintptr) (interface{}, error) {
	return TreeModelFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AssistantPageFunc: a function used by gtk_assistant_set_forward_page_func()
// to know which is the next page given a current one. It’s called both for
// computing the next page when the user presses the “forward” button and for
// handling the behavior of the “last” button.
type AssistantPageFunc func(currentPage int) int

//export gotk4_AssistantPageFunc
func gotk4_AssistantPageFunc(arg0 C.int, arg1 C.gpointer) C.int {
	v := box.Get(box.Callback, uintptr(arg1))
	if v == nil {
		panic(`callback not found`)
	}

	var currentPage int

	currentPage = int(arg0)

	gint := v.(AssistantPageFunc)(currentPage)
}

// CellAllocCallback: the type of the callback functions used for iterating over
// the cell renderers and their allocated areas inside a CellArea, see
// gtk_cell_area_foreach_alloc().
type CellAllocCallback func(renderer CellRenderer, cellArea *gdk.Rectangle, cellBackground *gdk.Rectangle) bool

//export gotk4_CellAllocCallback
func gotk4_CellAllocCallback(arg0 *C.GtkCellRenderer, arg1 *C.GdkRectangle, arg2 *C.GdkRectangle, arg3 C.gpointer) C.gboolean {
	v := box.Get(box.Callback, uintptr(arg3))
	if v == nil {
		panic(`callback not found`)
	}

	var renderer CellRenderer
	var cellArea *gdk.Rectangle
	var cellBackground *gdk.Rectangle

	renderer = WrapCellRenderer(externglib.Take(unsafe.Pointer(arg0.Native())))

	cellArea = gdk.WrapRectangle(arg1)

	cellBackground = gdk.WrapRectangle(arg2)

	ok := v.(CellAllocCallback)(renderer, cellArea, cellBackground)
}

// CellCallback: the type of the callback functions used for iterating over the
// cell renderers of a CellArea, see gtk_cell_area_foreach().
type CellCallback func(renderer CellRenderer) bool

//export gotk4_CellCallback
func gotk4_CellCallback(arg0 *C.GtkCellRenderer, arg1 C.gpointer) C.gboolean {
	v := box.Get(box.Callback, uintptr(arg1))
	if v == nil {
		panic(`callback not found`)
	}

	var renderer CellRenderer

	renderer = WrapCellRenderer(externglib.Take(unsafe.Pointer(arg0.Native())))

	ok := v.(CellCallback)(renderer)
}

// CellLayoutDataFunc: a function which should set the value of @cell_layout’s
// cell renderer(s) as appropriate.
type CellLayoutDataFunc func(cellLayout CellLayout, cell CellRenderer, treeModel TreeModel, iter *TreeIter)

//export gotk4_CellLayoutDataFunc
func gotk4_CellLayoutDataFunc(arg0 *C.GtkCellLayout, arg1 *C.GtkCellRenderer, arg2 *C.GtkTreeModel, arg3 *C.GtkTreeIter, arg4 C.gpointer) {
	v := box.Get(box.Callback, uintptr(arg4))
	if v == nil {
		panic(`callback not found`)
	}

	var cellLayout CellLayout
	var cell CellRenderer
	var treeModel TreeModel
	var iter *TreeIter

	cell = WrapCellRenderer(externglib.Take(unsafe.Pointer(arg1.Native())))

	iter = WrapTreeIter(arg3)

	v.(CellLayoutDataFunc)(cellLayout, cell, treeModel, iter)
}

// CustomFilterFunc: user function that is called to determine if the @item
// should be matched. If the filter matches the item, this function must return
// true. If the item should be filtered out, false must be returned.
type CustomFilterFunc func(item gextras.Objector) bool

//export gotk4_CustomFilterFunc
func gotk4_CustomFilterFunc(arg0 C.gpointer, arg1 C.gpointer) C.gboolean {
	v := box.Get(box.Callback, uintptr(arg1))
	if v == nil {
		panic(`callback not found`)
	}

	var item gextras.Objector

	item = externglib.Take(unsafe.Pointer(arg0.Native()))

	ok := v.(CustomFilterFunc)(item)
}

// DrawingAreaDrawFunc: whenever @drawing_area needs to redraw, this function
// will be called.
//
// This function should exclusively redraw the contents of the drawing area and
// must not call any widget functions that cause changes.
type DrawingAreaDrawFunc func(drawingArea DrawingArea, cr *cairo.Context, width int, height int)

//export gotk4_DrawingAreaDrawFunc
func gotk4_DrawingAreaDrawFunc(arg0 *C.GtkDrawingArea, arg1 *C.cairo_t, arg2 C.int, arg3 C.int, arg4 C.gpointer) {
	v := box.Get(box.Callback, uintptr(arg4))
	if v == nil {
		panic(`callback not found`)
	}

	var drawingArea DrawingArea
	var cr *cairo.Context
	var width int
	var height int

	drawingArea = WrapDrawingArea(externglib.Take(unsafe.Pointer(arg0.Native())))

	cr = cairo.WrapContext(arg1)

	width = int(arg2)

	height = int(arg3)

	v.(DrawingAreaDrawFunc)(drawingArea, cr, width, height)
}

// EntryCompletionMatchFunc: a function which decides whether the row indicated
// by @iter matches a given @key, and should be displayed as a possible
// completion for @key. Note that @key is normalized and case-folded (see
// g_utf8_normalize() and g_utf8_casefold()). If this is not appropriate, match
// functions have access to the unmodified key via `gtk_editable_get_text
// (GTK_EDITABLE (gtk_entry_completion_get_entry ()))`.
type EntryCompletionMatchFunc func(completion EntryCompletion, key string, iter *TreeIter) bool

//export gotk4_EntryCompletionMatchFunc
func gotk4_EntryCompletionMatchFunc(arg0 *C.GtkEntryCompletion, arg1 *C.char, arg2 *C.GtkTreeIter, arg3 C.gpointer) C.gboolean {
	v := box.Get(box.Callback, uintptr(arg3))
	if v == nil {
		panic(`callback not found`)
	}

	var completion EntryCompletion
	var key string
	var iter *TreeIter

	completion = WrapEntryCompletion(externglib.Take(unsafe.Pointer(arg0.Native())))

	key = C.GoString(arg1)

	iter = WrapTreeIter(arg2)

	ok := v.(EntryCompletionMatchFunc)(completion, key, iter)
}

// ExpressionNotify: callback called by gtk_expression_watch() when the
// expression value changes.
type ExpressionNotify func()

//export gotk4_ExpressionNotify
func gotk4_ExpressionNotify(arg0 C.gpointer) {
	v := box.Get(box.Callback, uintptr(arg0))
	if v == nil {
		panic(`callback not found`)
	}

	v.(ExpressionNotify)()
}

// FlowBoxCreateWidgetFunc: called for flow boxes that are bound to a Model with
// gtk_flow_box_bind_model() for each item that gets added to the model.
type FlowBoxCreateWidgetFunc func(item gextras.Objector) Widget

//export gotk4_FlowBoxCreateWidgetFunc
func gotk4_FlowBoxCreateWidgetFunc(arg0 C.gpointer, arg1 C.gpointer) *C.GtkWidget {
	v := box.Get(box.Callback, uintptr(arg1))
	if v == nil {
		panic(`callback not found`)
	}

	var item gextras.Objector

	item = externglib.Take(unsafe.Pointer(arg0.Native()))

	widget := v.(FlowBoxCreateWidgetFunc)(item)
}

// FlowBoxFilterFunc: a function that will be called whenever a child changes or
// is added. It lets you control if the child should be visible or not.
type FlowBoxFilterFunc func(child FlowBoxChild) bool

//export gotk4_FlowBoxFilterFunc
func gotk4_FlowBoxFilterFunc(arg0 *C.GtkFlowBoxChild, arg1 C.gpointer) C.gboolean {
	v := box.Get(box.Callback, uintptr(arg1))
	if v == nil {
		panic(`callback not found`)
	}

	var child FlowBoxChild

	child = WrapFlowBoxChild(externglib.Take(unsafe.Pointer(arg0.Native())))

	ok := v.(FlowBoxFilterFunc)(child)
}

// FlowBoxForeachFunc: a function used by gtk_flow_box_selected_foreach(). It
// will be called on every selected child of the @box.
type FlowBoxForeachFunc func(box FlowBox, child FlowBoxChild)

//export gotk4_FlowBoxForeachFunc
func gotk4_FlowBoxForeachFunc(arg0 *C.GtkFlowBox, arg1 *C.GtkFlowBoxChild, arg2 C.gpointer) {
	v := box.Get(box.Callback, uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var box FlowBox
	var child FlowBoxChild

	box = WrapFlowBox(externglib.Take(unsafe.Pointer(arg0.Native())))

	child = WrapFlowBoxChild(externglib.Take(unsafe.Pointer(arg1.Native())))

	v.(FlowBoxForeachFunc)(box, child)
}

// FlowBoxSortFunc: a function to compare two children to determine which should
// come first.
type FlowBoxSortFunc func(child1 FlowBoxChild, child2 FlowBoxChild) int

//export gotk4_FlowBoxSortFunc
func gotk4_FlowBoxSortFunc(arg0 *C.GtkFlowBoxChild, arg1 *C.GtkFlowBoxChild, arg2 C.gpointer) C.int {
	v := box.Get(box.Callback, uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var child1 FlowBoxChild
	var child2 FlowBoxChild

	child1 = WrapFlowBoxChild(externglib.Take(unsafe.Pointer(arg0.Native())))

	child2 = WrapFlowBoxChild(externglib.Take(unsafe.Pointer(arg1.Native())))

	gint := v.(FlowBoxSortFunc)(child1, child2)
}

// FontFilterFunc: the type of function that is used for deciding what fonts get
// shown in a FontChooser. See gtk_font_chooser_set_filter_func().
type FontFilterFunc func(family pango.FontFamily, face pango.FontFace) bool

//export gotk4_FontFilterFunc
func gotk4_FontFilterFunc(arg0 *C.PangoFontFamily, arg1 *C.PangoFontFace, arg2 C.gpointer) C.gboolean {
	v := box.Get(box.Callback, uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var family pango.FontFamily
	var face pango.FontFace

	family = pango.WrapFontFamily(externglib.Take(unsafe.Pointer(arg0.Native())))

	face = pango.WrapFontFace(externglib.Take(unsafe.Pointer(arg1.Native())))

	ok := v.(FontFilterFunc)(family, face)
}

// IconViewForeachFunc: a function used by gtk_icon_view_selected_foreach() to
// map all selected rows. It will be called on every selected row in the view.
type IconViewForeachFunc func(iconView IconView, path *TreePath)

//export gotk4_IconViewForeachFunc
func gotk4_IconViewForeachFunc(arg0 *C.GtkIconView, arg1 *C.GtkTreePath, arg2 C.gpointer) {
	v := box.Get(box.Callback, uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var iconView IconView
	var path *TreePath

	iconView = WrapIconView(externglib.Take(unsafe.Pointer(arg0.Native())))

	path = WrapTreePath(arg1)

	v.(IconViewForeachFunc)(iconView, path)
}

// ListBoxCreateWidgetFunc: called for list boxes that are bound to a Model with
// gtk_list_box_bind_model() for each item that gets added to the model.
type ListBoxCreateWidgetFunc func(item gextras.Objector) Widget

//export gotk4_ListBoxCreateWidgetFunc
func gotk4_ListBoxCreateWidgetFunc(arg0 C.gpointer, arg1 C.gpointer) *C.GtkWidget {
	v := box.Get(box.Callback, uintptr(arg1))
	if v == nil {
		panic(`callback not found`)
	}

	var item gextras.Objector

	item = externglib.Take(unsafe.Pointer(arg0.Native()))

	widget := v.(ListBoxCreateWidgetFunc)(item)
}

// ListBoxFilterFunc: will be called whenever the row changes or is added and
// lets you control if the row should be visible or not.
type ListBoxFilterFunc func(row ListBoxRow) bool

//export gotk4_ListBoxFilterFunc
func gotk4_ListBoxFilterFunc(arg0 *C.GtkListBoxRow, arg1 C.gpointer) C.gboolean {
	v := box.Get(box.Callback, uintptr(arg1))
	if v == nil {
		panic(`callback not found`)
	}

	var row ListBoxRow

	row = WrapListBoxRow(externglib.Take(unsafe.Pointer(arg0.Native())))

	ok := v.(ListBoxFilterFunc)(row)
}

// ListBoxForeachFunc: a function used by gtk_list_box_selected_foreach(). It
// will be called on every selected child of the @box.
type ListBoxForeachFunc func(box ListBox, row ListBoxRow)

//export gotk4_ListBoxForeachFunc
func gotk4_ListBoxForeachFunc(arg0 *C.GtkListBox, arg1 *C.GtkListBoxRow, arg2 C.gpointer) {
	v := box.Get(box.Callback, uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var box ListBox
	var row ListBoxRow

	box = WrapListBox(externglib.Take(unsafe.Pointer(arg0.Native())))

	row = WrapListBoxRow(externglib.Take(unsafe.Pointer(arg1.Native())))

	v.(ListBoxForeachFunc)(box, row)
}

// ListBoxSortFunc: compare two rows to determine which should be first.
type ListBoxSortFunc func(row1 ListBoxRow, row2 ListBoxRow) int

//export gotk4_ListBoxSortFunc
func gotk4_ListBoxSortFunc(arg0 *C.GtkListBoxRow, arg1 *C.GtkListBoxRow, arg2 C.gpointer) C.int {
	v := box.Get(box.Callback, uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var row1 ListBoxRow
	var row2 ListBoxRow

	row1 = WrapListBoxRow(externglib.Take(unsafe.Pointer(arg0.Native())))

	row2 = WrapListBoxRow(externglib.Take(unsafe.Pointer(arg1.Native())))

	gint := v.(ListBoxSortFunc)(row1, row2)
}

// ListBoxUpdateHeaderFunc: whenever @row changes or which row is before @row
// changes this is called, which lets you update the header on @row. You may
// remove or set a new one via gtk_list_box_row_set_header() or just change the
// state of the current header widget.
type ListBoxUpdateHeaderFunc func(row ListBoxRow, before ListBoxRow)

//export gotk4_ListBoxUpdateHeaderFunc
func gotk4_ListBoxUpdateHeaderFunc(arg0 *C.GtkListBoxRow, arg1 *C.GtkListBoxRow, arg2 C.gpointer) {
	v := box.Get(box.Callback, uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var row ListBoxRow
	var before ListBoxRow

	row = WrapListBoxRow(externglib.Take(unsafe.Pointer(arg0.Native())))

	before = WrapListBoxRow(externglib.Take(unsafe.Pointer(arg1.Native())))

	v.(ListBoxUpdateHeaderFunc)(row, before)
}

// MapListModelMapFunc: user function that is called to map an @item of the
// original model to an item expected by the map model.
//
// The returned items must conform to the item type of the model they are used
// with.
type MapListModelMapFunc func(item gextras.Objector) gextras.Objector

//export gotk4_MapListModelMapFunc
func gotk4_MapListModelMapFunc(arg0 C.gpointer, arg1 C.gpointer) C.gpointer {
	v := box.Get(box.Callback, uintptr(arg1))
	if v == nil {
		panic(`callback not found`)
	}

	var item gextras.Objector

	item = externglib.AssumeOwnership(unsafe.Pointer(arg0.Native()))

	object := v.(MapListModelMapFunc)(item)
}

// MenuButtonCreatePopupFunc: user-provided callback function to create a popup
// for @menu_button on demand. This function is called when the popup of
// @menu_button is shown, but none has been provided via
// gtk_menu_button_set_popover() or gtk_menu_button_set_menu_model().
type MenuButtonCreatePopupFunc func(menuButton MenuButton)

//export gotk4_MenuButtonCreatePopupFunc
func gotk4_MenuButtonCreatePopupFunc(arg0 *C.GtkMenuButton, arg1 C.gpointer) {
	v := box.Get(box.Callback, uintptr(arg1))
	if v == nil {
		panic(`callback not found`)
	}

	var menuButton MenuButton

	menuButton = WrapMenuButton(externglib.Take(unsafe.Pointer(arg0.Native())))

	v.(MenuButtonCreatePopupFunc)(menuButton)
}

// PageSetupDoneFunc: the type of function that is passed to
// gtk_print_run_page_setup_dialog_async().
//
// This function will be called when the page setup dialog is dismissed, and
// also serves as destroy notify for @data.
type PageSetupDoneFunc func(pageSetup PageSetup)

//export gotk4_PageSetupDoneFunc
func gotk4_PageSetupDoneFunc(arg0 *C.GtkPageSetup, arg1 C.gpointer) {
	v := box.Get(box.Callback, uintptr(arg1))
	if v == nil {
		panic(`callback not found`)
	}

	var pageSetup PageSetup

	pageSetup = WrapPageSetup(externglib.Take(unsafe.Pointer(arg0.Native())))

	v.(PageSetupDoneFunc)(pageSetup)
}

type PrintSettingsFunc func(key string, value string)

//export gotk4_PrintSettingsFunc
func gotk4_PrintSettingsFunc(arg0 *C.char, arg1 *C.char, arg2 C.gpointer) {
	v := box.Get(box.Callback, uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var key string
	var value string

	key = C.GoString(arg0)

	value = C.GoString(arg1)

	v.(PrintSettingsFunc)(key, value)
}

type ScaleFormatValueFunc func(scale Scale, value float64) string

//export gotk4_ScaleFormatValueFunc
func gotk4_ScaleFormatValueFunc(arg0 *C.GtkScale, arg1 C.double, arg2 C.gpointer) *C.char {
	v := box.Get(box.Callback, uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var scale Scale
	var value float64

	scale = WrapScale(externglib.Take(unsafe.Pointer(arg0.Native())))

	value = float64(arg1)

	utf8 := v.(ScaleFormatValueFunc)(scale, value)
}

// ShortcutFunc: prototype for shortcuts based on user callbacks.
type ShortcutFunc func(widget Widget, args *glib.Variant) bool

//export gotk4_ShortcutFunc
func gotk4_ShortcutFunc(arg0 *C.GtkWidget, arg1 *C.GVariant, arg2 C.gpointer) C.gboolean {
	v := box.Get(box.Callback, uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var widget Widget
	var args *glib.Variant

	widget = WrapWidget(externglib.Take(unsafe.Pointer(arg0.Native())))

	args = glib.WrapVariant(arg1)

	ok := v.(ShortcutFunc)(widget, args)
}

// TextCharPredicate: the predicate function used by
// gtk_text_iter_forward_find_char() and gtk_text_iter_backward_find_char().
type TextCharPredicate func(ch uint32) bool

//export gotk4_TextCharPredicate
func gotk4_TextCharPredicate(arg0 C.gunichar, arg1 C.gpointer) C.gboolean {
	v := box.Get(box.Callback, uintptr(arg1))
	if v == nil {
		panic(`callback not found`)
	}

	var ch uint32

	ch = uint32(arg0)

	ok := v.(TextCharPredicate)(ch)
}

// TextTagTableForeach: a function used with gtk_text_tag_table_foreach(), to
// iterate over every TextTag inside a TextTagTable.
type TextTagTableForeach func(tag TextTag)

//export gotk4_TextTagTableForeach
func gotk4_TextTagTableForeach(arg0 *C.GtkTextTag, arg1 C.gpointer) {
	v := box.Get(box.Callback, uintptr(arg1))
	if v == nil {
		panic(`callback not found`)
	}

	var tag TextTag

	tag = WrapTextTag(externglib.Take(unsafe.Pointer(arg0.Native())))

	v.(TextTagTableForeach)(tag)
}

// TickCallback: callback type for adding a function to update animations. See
// gtk_widget_add_tick_callback().
type TickCallback func(widget Widget, frameClock gdk.FrameClock) bool

//export gotk4_TickCallback
func gotk4_TickCallback(arg0 *C.GtkWidget, arg1 *C.GdkFrameClock, arg2 C.gpointer) C.gboolean {
	v := box.Get(box.Callback, uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var widget Widget
	var frameClock gdk.FrameClock

	widget = WrapWidget(externglib.Take(unsafe.Pointer(arg0.Native())))

	frameClock = gdk.WrapFrameClock(externglib.Take(unsafe.Pointer(arg1.Native())))

	ok := v.(TickCallback)(widget, frameClock)
}

// TreeCellDataFunc: a function to set the properties of a cell instead of just
// using the straight mapping between the cell and the model. This is useful for
// customizing the cell renderer. For example, a function might get an integer
// from the @tree_model, and render it to the “text” attribute of “cell” by
// converting it to its written equivalent. This is set by calling
// gtk_tree_view_column_set_cell_data_func()
type TreeCellDataFunc func(treeColumn TreeViewColumn, cell CellRenderer, treeModel TreeModel, iter *TreeIter)

//export gotk4_TreeCellDataFunc
func gotk4_TreeCellDataFunc(arg0 *C.GtkTreeViewColumn, arg1 *C.GtkCellRenderer, arg2 *C.GtkTreeModel, arg3 *C.GtkTreeIter, arg4 C.gpointer) {
	v := box.Get(box.Callback, uintptr(arg4))
	if v == nil {
		panic(`callback not found`)
	}

	var treeColumn TreeViewColumn
	var cell CellRenderer
	var treeModel TreeModel
	var iter *TreeIter

	treeColumn = WrapTreeViewColumn(externglib.Take(unsafe.Pointer(arg0.Native())))

	cell = WrapCellRenderer(externglib.Take(unsafe.Pointer(arg1.Native())))

	iter = WrapTreeIter(arg3)

	v.(TreeCellDataFunc)(treeColumn, cell, treeModel, iter)
}

// TreeIterCompareFunc: a GtkTreeIterCompareFunc should return a negative
// integer, zero, or a positive integer if @a sorts before @b, @a sorts with @b,
// or @a sorts after @b respectively. If two iters compare as equal, their order
// in the sorted model is undefined. In order to ensure that the TreeSortable
// behaves as expected, the GtkTreeIterCompareFunc must define a partial order
// on the model, i.e. it must be reflexive, antisymmetric and transitive.
//
// For example, if @model is a product catalogue, then a compare function for
// the “price” column could be one which returns `price_of(@a) - price_of(@b)`.
type TreeIterCompareFunc func(model TreeModel, a *TreeIter, b *TreeIter) int

//export gotk4_TreeIterCompareFunc
func gotk4_TreeIterCompareFunc(arg0 *C.GtkTreeModel, arg1 *C.GtkTreeIter, arg2 *C.GtkTreeIter, arg3 C.gpointer) C.int {
	v := box.Get(box.Callback, uintptr(arg3))
	if v == nil {
		panic(`callback not found`)
	}

	var model TreeModel
	var a *TreeIter
	var b *TreeIter

	a = WrapTreeIter(arg1)

	b = WrapTreeIter(arg2)

	gint := v.(TreeIterCompareFunc)(model, a, b)
}

// TreeListModelCreateModelFunc: prototype of the function called to create new
// child models when gtk_tree_list_row_set_expanded() is called.
//
// This function can return nil to indicate that @item is guaranteed to be a
// leaf node and will never have children. If it does not have children but may
// get children later, it should return an empty model that is filled once
// children arrive.
type TreeListModelCreateModelFunc func(item gextras.Objector) gio.ListModel

//export gotk4_TreeListModelCreateModelFunc
func gotk4_TreeListModelCreateModelFunc(arg0 C.gpointer, arg1 C.gpointer) *C.GListModel {
	v := box.Get(box.Callback, uintptr(arg1))
	if v == nil {
		panic(`callback not found`)
	}

	var item gextras.Objector

	item = externglib.Take(unsafe.Pointer(arg0.Native()))

	listModel := v.(TreeListModelCreateModelFunc)(item)
}

// TreeModelFilterModifyFunc: a function which calculates display values from
// raw values in the model. It must fill @value with the display value for the
// column @column in the row indicated by @iter.
//
// Since this function is called for each data access, it’s not a particularly
// efficient operation.
type TreeModelFilterModifyFunc func(model TreeModel, iter *TreeIter, column int) externglib.Value

//export gotk4_TreeModelFilterModifyFunc
func gotk4_TreeModelFilterModifyFunc(arg0 *C.GtkTreeModel, arg1 *C.GtkTreeIter, arg2 *C.GValue, arg3 C.int, arg4 C.gpointer) {
	v := box.Get(box.Callback, uintptr(arg4))
	if v == nil {
		panic(`callback not found`)
	}

	var model TreeModel
	var iter *TreeIter
	var column int

	iter = WrapTreeIter(arg1)

	column = int(arg3)

	value := v.(TreeModelFilterModifyFunc)(model, iter, column)
}

// TreeModelFilterVisibleFunc: a function which decides whether the row
// indicated by @iter is visible.
type TreeModelFilterVisibleFunc func(model TreeModel, iter *TreeIter) bool

//export gotk4_TreeModelFilterVisibleFunc
func gotk4_TreeModelFilterVisibleFunc(arg0 *C.GtkTreeModel, arg1 *C.GtkTreeIter, arg2 C.gpointer) C.gboolean {
	v := box.Get(box.Callback, uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var model TreeModel
	var iter *TreeIter

	iter = WrapTreeIter(arg1)

	ok := v.(TreeModelFilterVisibleFunc)(model, iter)
}

// TreeModelForeachFunc: type of the callback passed to gtk_tree_model_foreach()
// to iterate over the rows in a tree model.
type TreeModelForeachFunc func(model TreeModel, path *TreePath, iter *TreeIter) bool

//export gotk4_TreeModelForeachFunc
func gotk4_TreeModelForeachFunc(arg0 *C.GtkTreeModel, arg1 *C.GtkTreePath, arg2 *C.GtkTreeIter, arg3 C.gpointer) C.gboolean {
	v := box.Get(box.Callback, uintptr(arg3))
	if v == nil {
		panic(`callback not found`)
	}

	var model TreeModel
	var path *TreePath
	var iter *TreeIter

	path = WrapTreePath(arg1)

	iter = WrapTreeIter(arg2)

	ok := v.(TreeModelForeachFunc)(model, path, iter)
}

// TreeSelectionForeachFunc: a function used by
// gtk_tree_selection_selected_foreach() to map all selected rows. It will be
// called on every selected row in the view.
type TreeSelectionForeachFunc func(model TreeModel, path *TreePath, iter *TreeIter)

//export gotk4_TreeSelectionForeachFunc
func gotk4_TreeSelectionForeachFunc(arg0 *C.GtkTreeModel, arg1 *C.GtkTreePath, arg2 *C.GtkTreeIter, arg3 C.gpointer) {
	v := box.Get(box.Callback, uintptr(arg3))
	if v == nil {
		panic(`callback not found`)
	}

	var model TreeModel
	var path *TreePath
	var iter *TreeIter

	path = WrapTreePath(arg1)

	iter = WrapTreeIter(arg2)

	v.(TreeSelectionForeachFunc)(model, path, iter)
}

// TreeSelectionFunc: a function used by
// gtk_tree_selection_set_select_function() to filter whether or not a row may
// be selected. It is called whenever a row's state might change. A return value
// of true indicates to @selection that it is okay to change the selection.
type TreeSelectionFunc func(selection TreeSelection, model TreeModel, path *TreePath, pathCurrentlySelected bool) bool

//export gotk4_TreeSelectionFunc
func gotk4_TreeSelectionFunc(arg0 *C.GtkTreeSelection, arg1 *C.GtkTreeModel, arg2 *C.GtkTreePath, arg3 C.gboolean, arg4 C.gpointer) C.gboolean {
	v := box.Get(box.Callback, uintptr(arg4))
	if v == nil {
		panic(`callback not found`)
	}

	var selection TreeSelection
	var model TreeModel
	var path *TreePath
	var pathCurrentlySelected bool

	selection = WrapTreeSelection(externglib.Take(unsafe.Pointer(arg0.Native())))

	path = WrapTreePath(arg2)

	pathCurrentlySelected = gextras.Gobool(arg3)

	ok := v.(TreeSelectionFunc)(selection, model, path, pathCurrentlySelected)
}

// TreeViewColumnDropFunc: function type for determining whether @column can be
// dropped in a particular spot (as determined by @prev_column and
// @next_column). In left to right locales, @prev_column is on the left of the
// potential drop spot, and @next_column is on the right. In right to left mode,
// this is reversed. This function should return true if the spot is a valid
// drop spot. Please note that returning true does not actually indicate that
// the column drop was made, but is meant only to indicate a possible drop spot
// to the user.
type TreeViewColumnDropFunc func(treeView TreeView, column TreeViewColumn, prevColumn TreeViewColumn, nextColumn TreeViewColumn) bool

//export gotk4_TreeViewColumnDropFunc
func gotk4_TreeViewColumnDropFunc(arg0 *C.GtkTreeView, arg1 *C.GtkTreeViewColumn, arg2 *C.GtkTreeViewColumn, arg3 *C.GtkTreeViewColumn, arg4 C.gpointer) C.gboolean {
	v := box.Get(box.Callback, uintptr(arg4))
	if v == nil {
		panic(`callback not found`)
	}

	var treeView TreeView
	var column TreeViewColumn
	var prevColumn TreeViewColumn
	var nextColumn TreeViewColumn

	treeView = WrapTreeView(externglib.Take(unsafe.Pointer(arg0.Native())))

	column = WrapTreeViewColumn(externglib.Take(unsafe.Pointer(arg1.Native())))

	prevColumn = WrapTreeViewColumn(externglib.Take(unsafe.Pointer(arg2.Native())))

	nextColumn = WrapTreeViewColumn(externglib.Take(unsafe.Pointer(arg3.Native())))

	ok := v.(TreeViewColumnDropFunc)(treeView, column, prevColumn, nextColumn)
}

// TreeViewMappingFunc: function used for gtk_tree_view_map_expanded_rows().
type TreeViewMappingFunc func(treeView TreeView, path *TreePath)

//export gotk4_TreeViewMappingFunc
func gotk4_TreeViewMappingFunc(arg0 *C.GtkTreeView, arg1 *C.GtkTreePath, arg2 C.gpointer) {
	v := box.Get(box.Callback, uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var treeView TreeView
	var path *TreePath

	treeView = WrapTreeView(externglib.Take(unsafe.Pointer(arg0.Native())))

	path = WrapTreePath(arg1)

	v.(TreeViewMappingFunc)(treeView, path)
}

// TreeViewRowSeparatorFunc: function type for determining whether the row
// pointed to by @iter should be rendered as a separator. A common way to
// implement this is to have a boolean column in the model, whose values the
// TreeViewRowSeparatorFunc returns.
type TreeViewRowSeparatorFunc func(model TreeModel, iter *TreeIter) bool

//export gotk4_TreeViewRowSeparatorFunc
func gotk4_TreeViewRowSeparatorFunc(arg0 *C.GtkTreeModel, arg1 *C.GtkTreeIter, arg2 C.gpointer) C.gboolean {
	v := box.Get(box.Callback, uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var model TreeModel
	var iter *TreeIter

	iter = WrapTreeIter(arg1)

	ok := v.(TreeViewRowSeparatorFunc)(model, iter)
}

// TreeViewSearchEqualFunc: a function used for checking whether a row in @model
// matches a search key string entered by the user. Note the return value is
// reversed from what you would normally expect, though it has some similarity
// to strcmp() returning 0 for equal strings.
type TreeViewSearchEqualFunc func(model TreeModel, column int, key string, iter *TreeIter) bool

//export gotk4_TreeViewSearchEqualFunc
func gotk4_TreeViewSearchEqualFunc(arg0 *C.GtkTreeModel, arg1 C.int, arg2 *C.char, arg3 *C.GtkTreeIter, arg4 C.gpointer) C.gboolean {
	v := box.Get(box.Callback, uintptr(arg4))
	if v == nil {
		panic(`callback not found`)
	}

	var model TreeModel
	var column int
	var key string
	var iter *TreeIter

	column = int(arg1)

	key = C.GoString(arg2)

	iter = WrapTreeIter(arg3)

	ok := v.(TreeViewSearchEqualFunc)(model, column, key, iter)
}

// AcceleratorGetDefaultModMask gets the modifier mask.
//
// The modifier mask determines which modifiers are considered significant for
// keyboard accelerators. This includes all keyboard modifiers except for
// GDK_LOCK_MASK.
func AcceleratorGetDefaultModMask() gdk.ModifierType {

	ret := C.gtk_accelerator_get_default_mod_mask()

	var ret0 gdk.ModifierType

	ret0 = gdk.ModifierType(ret)

	return ret0
}

// AcceleratorGetLabel converts an accelerator keyval and modifier mask into a
// string which can be used to represent the accelerator to the user.
func AcceleratorGetLabel(acceleratorKey uint, acceleratorMods gdk.ModifierType) string {
	var arg1 C.guint
	var arg2 C.GdkModifierType

	arg1 = C.guint(acceleratorKey)
	arg2 = (C.GdkModifierType)(acceleratorMods)

	ret := C.gtk_accelerator_get_label(arg1, arg2)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// AcceleratorGetLabelWithKeycode converts an accelerator keyval and modifier
// mask into a (possibly translated) string that can be displayed to a user,
// similarly to gtk_accelerator_get_label(), but handling keycodes.
//
// This is only useful for system-level components, applications should use
// gtk_accelerator_parse() instead.
func AcceleratorGetLabelWithKeycode(display gdk.Display, acceleratorKey uint, keycode uint, acceleratorMods gdk.ModifierType) string {
	var arg1 *C.GdkDisplay
	var arg2 C.guint
	var arg3 C.guint
	var arg4 C.GdkModifierType

	arg1 = (*C.GdkDisplay)(display.Native())
	arg2 = C.guint(acceleratorKey)
	arg3 = C.guint(keycode)
	arg4 = (C.GdkModifierType)(acceleratorMods)

	ret := C.gtk_accelerator_get_label_with_keycode(arg1, arg2, arg3, arg4)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// AcceleratorName converts an accelerator keyval and modifier mask into a
// string parseable by gtk_accelerator_parse(). For example, if you pass in
// K_KEY_q and K_CONTROL_MASK, this function returns “<Control>q”.
//
// If you need to display accelerators in the user interface, see
// gtk_accelerator_get_label().
func AcceleratorName(acceleratorKey uint, acceleratorMods gdk.ModifierType) string {
	var arg1 C.guint
	var arg2 C.GdkModifierType

	arg1 = C.guint(acceleratorKey)
	arg2 = (C.GdkModifierType)(acceleratorMods)

	ret := C.gtk_accelerator_name(arg1, arg2)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// AcceleratorNameWithKeycode converts an accelerator keyval and modifier mask
// into a string parseable by gtk_accelerator_parse_with_keycode(), similarly to
// gtk_accelerator_name() but handling keycodes. This is only useful for
// system-level components, applications should use gtk_accelerator_parse()
// instead.
func AcceleratorNameWithKeycode(display gdk.Display, acceleratorKey uint, keycode uint, acceleratorMods gdk.ModifierType) string {
	var arg1 *C.GdkDisplay
	var arg2 C.guint
	var arg3 C.guint
	var arg4 C.GdkModifierType

	arg1 = (*C.GdkDisplay)(display.Native())
	arg2 = C.guint(acceleratorKey)
	arg3 = C.guint(keycode)
	arg4 = (C.GdkModifierType)(acceleratorMods)

	ret := C.gtk_accelerator_name_with_keycode(arg1, arg2, arg3, arg4)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// AcceleratorParse parses a string representing an accelerator. The format
// looks like “<Control>a” or “<Shift><Alt>F1”.
//
// The parser is fairly liberal and allows lower or upper case, and also
// abbreviations such as “<Ctl>” and “<Ctrl>”. Key names are parsed using
// gdk_keyval_from_name(). For character keys the name is not the symbol, but
// the lowercase name, e.g. one would use “<Ctrl>minus” instead of “<Ctrl>-”.
//
// If the parse fails, @accelerator_key and @accelerator_mods will be set to 0
// (zero).
func AcceleratorParse(accelerator string) (acceleratorKey uint, acceleratorMods gdk.ModifierType, ok bool) {
	var arg1 *C.char
	var arg2 *C.guint           // out
	var arg3 *C.GdkModifierType // out

	arg1 = (*C.gchar)(C.CString(accelerator))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_accelerator_parse(arg1, &arg2, &arg3)

	var ret0 uint
	var ret1 *gdk.ModifierType
	var ret2 bool

	ret0 = uint(arg2)

	ret1 = (*gdk.ModifierType)(arg3)

	ret2 = gextras.Gobool(ret)

	return ret0, ret1, ret2
}

// AcceleratorParseWithKeycode parses a string representing an accelerator,
// similarly to gtk_accelerator_parse() but handles keycodes as well. This is
// only useful for system-level components, applications should use
// gtk_accelerator_parse() instead.
//
// If @accelerator_codes is given and the result stored in it is non-nil, the
// result must be freed with g_free().
//
// If a keycode is present in the accelerator and no @accelerator_codes is
// given, the parse will fail.
//
// If the parse fails, @accelerator_key, @accelerator_mods and
// @accelerator_codes will be set to 0 (zero).
func AcceleratorParseWithKeycode(accelerator string, display gdk.Display) (acceleratorKey uint, acceleratorCodes []uint, acceleratorMods gdk.ModifierType, ok bool) {
	var arg1 *C.char
	var arg2 *C.GdkDisplay
	var arg3 *C.guint           // out
	var arg4 **C.guint          // out
	var arg5 *C.GdkModifierType // out

	arg1 = (*C.gchar)(C.CString(accelerator))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GdkDisplay)(display.Native())

	ret := C.gtk_accelerator_parse_with_keycode(arg1, arg2, &arg3, &arg4, &arg5)

	var ret0 uint
	var ret1 []uint
	var ret2 *gdk.ModifierType
	var ret3 bool

	ret0 = uint(arg3)

	{
		var length uint
		for p := unsafe.Pointer(arg4); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret1 = make([]uint, length)
		for i := 0; i < length; i++ {
			src := (*C.guint)(unsafe.Pointer(uintptr(unsafe.Pointer(arg4)) + i))
			ret1[i] = uint(src)
		}
	}

	ret2 = (*gdk.ModifierType)(arg5)

	ret3 = gextras.Gobool(ret)

	return ret0, ret1, ret2, ret3
}

// AcceleratorValid determines whether a given keyval and modifier mask
// constitute a valid keyboard accelerator. For example, the K_KEY_a keyval plus
// K_CONTROL_MASK is valid - this is a “Ctrl+a” accelerator. But, you can't, for
// instance, use the K_KEY_Control_L keyval as an accelerator.
func AcceleratorValid(keyval uint, modifiers gdk.ModifierType) bool {
	var arg1 C.guint
	var arg2 C.GdkModifierType

	arg1 = C.guint(keyval)
	arg2 = (C.GdkModifierType)(modifiers)

	ret := C.gtk_accelerator_valid(arg1, arg2)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

func AccessiblePropertyInitValue(property AccessibleProperty, value *externglib.Value) {
	var arg1 C.GtkAccessibleProperty
	var arg2 *C.GValue

	arg1 = (C.GtkAccessibleProperty)(property)
	arg2 = (*C.GValue)(value.GValue)

	C.gtk_accessible_property_init_value(arg1, arg2)
}

func AccessibleRelationInitValue(relation AccessibleRelation, value *externglib.Value) {
	var arg1 C.GtkAccessibleRelation
	var arg2 *C.GValue

	arg1 = (C.GtkAccessibleRelation)(relation)
	arg2 = (*C.GValue)(value.GValue)

	C.gtk_accessible_relation_init_value(arg1, arg2)
}

func AccessibleStateInitValue(state AccessibleState, value *externglib.Value) {
	var arg1 C.GtkAccessibleState
	var arg2 *C.GValue

	arg1 = (C.GtkAccessibleState)(state)
	arg2 = (*C.GValue)(value.GValue)

	C.gtk_accessible_state_init_value(arg1, arg2)
}

// BitsetIterInitAt initializes @iter to point to @target. If @target is not
// found, finds the next value after it. If no value >= @target exists in @set,
// this function returns false.
func BitsetIterInitAt(set *Bitset, target uint) (iter BitsetIter, value uint, ok bool) {
	var arg1 *C.GtkBitsetIter // out
	var arg2 *C.GtkBitset
	var arg3 C.guint
	var arg4 *C.guint // out

	arg2 = (*C.GtkBitset)(set.Native())
	arg3 = C.guint(target)

	ret := C.gtk_bitset_iter_init_at(&arg1, arg2, arg3, &arg4)

	var ret0 *BitsetIter
	var ret1 uint
	var ret2 bool

	ret0 = WrapBitsetIter(arg1)

	ret1 = uint(arg4)

	ret2 = gextras.Gobool(ret)

	return ret0, ret1, ret2
}

// BitsetIterInitFirst initializes an iterator for @set and points it to the
// first value in @set. If @set is empty, false is returned and @value is set to
// G_MAXUINT.
func BitsetIterInitFirst(set *Bitset) (iter BitsetIter, value uint, ok bool) {
	var arg1 *C.GtkBitsetIter // out
	var arg2 *C.GtkBitset
	var arg3 *C.guint // out

	arg2 = (*C.GtkBitset)(set.Native())

	ret := C.gtk_bitset_iter_init_first(&arg1, arg2, &arg3)

	var ret0 *BitsetIter
	var ret1 uint
	var ret2 bool

	ret0 = WrapBitsetIter(arg1)

	ret1 = uint(arg3)

	ret2 = gextras.Gobool(ret)

	return ret0, ret1, ret2
}

// BitsetIterInitLast initializes an iterator for @set and points it to the last
// value in @set. If @set is empty, false is returned.
func BitsetIterInitLast(set *Bitset) (iter BitsetIter, value uint, ok bool) {
	var arg1 *C.GtkBitsetIter // out
	var arg2 *C.GtkBitset
	var arg3 *C.guint // out

	arg2 = (*C.GtkBitset)(set.Native())

	ret := C.gtk_bitset_iter_init_last(&arg1, arg2, &arg3)

	var ret0 *BitsetIter
	var ret1 uint
	var ret2 bool

	ret0 = WrapBitsetIter(arg1)

	ret1 = uint(arg3)

	ret2 = gextras.Gobool(ret)

	return ret0, ret1, ret2
}

func BuilderErrorQuark() glib.Quark {

	ret := C.gtk_builder_error_quark()

	var ret0 glib.Quark

	{
		var tmp uint32
		tmp = uint32(ret)
		ret0 = glib.Quark(tmp)
	}

	return ret0
}

// CheckVersion checks that the GTK library in use is compatible with the given
// version. Generally you would pass in the constants GTK_MAJOR_VERSION,
// GTK_MINOR_VERSION, GTK_MICRO_VERSION as the three arguments to this function;
// that produces a check that the library in use is compatible with the version
// of GTK the application or module was compiled against.
//
// Compatibility is defined by two things: first the version of the running
// library is newer than the version
// @required_major.required_minor.@required_micro. Second the running library
// must be binary compatible with the version
// @required_major.required_minor.@required_micro (same major version.)
//
// This function is primarily for GTK modules; the module can call this function
// to check that it wasn’t loaded into an incompatible version of GTK. However,
// such a check isn’t completely reliable, since the module may be linked
// against an old version of GTK and calling the old version of
// gtk_check_version(), but still get loaded into an application using a newer
// version of GTK.
func CheckVersion(requiredMajor uint, requiredMinor uint, requiredMicro uint) string {
	var arg1 C.guint
	var arg2 C.guint
	var arg3 C.guint

	arg1 = C.guint(requiredMajor)
	arg2 = C.guint(requiredMinor)
	arg3 = C.guint(requiredMicro)

	ret := C.gtk_check_version(arg1, arg2, arg3)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

func ConstraintVflParserErrorQuark() glib.Quark {

	ret := C.gtk_constraint_vfl_parser_error_quark()

	var ret0 glib.Quark

	{
		var tmp uint32
		tmp = uint32(ret)
		ret0 = glib.Quark(tmp)
	}

	return ret0
}

func CSSParserErrorQuark() glib.Quark {

	ret := C.gtk_css_parser_error_quark()

	var ret0 glib.Quark

	{
		var tmp uint32
		tmp = uint32(ret)
		ret0 = glib.Quark(tmp)
	}

	return ret0
}

func CSSParserWarningQuark() glib.Quark {

	ret := C.gtk_css_parser_warning_quark()

	var ret0 glib.Quark

	{
		var tmp uint32
		tmp = uint32(ret)
		ret0 = glib.Quark(tmp)
	}

	return ret0
}

// DisableSetlocale prevents gtk_init(), gtk_init_check() and gtk_parse_args()
// from automatically calling `setlocale (LC_ALL, "")`. You would want to use
// this function if you wanted to set the locale for your program to something
// other than the user’s locale, or if you wanted to set different values for
// different locale categories.
//
// Most programs should not need to call this function.
func DisableSetlocale() {

	C.gtk_disable_setlocale()
}

// DistributeNaturalAllocation distributes @extra_space to child @sizes by
// bringing smaller children up to natural size first.
//
// The remaining space will be added to the @minimum_size member of the
// GtkRequestedSize struct. If all sizes reach their natural size then the
// remaining space is returned.
func DistributeNaturalAllocation(extraSpace int, nRequestedSizes uint, sizes *RequestedSize) int {
	var arg1 C.int
	var arg2 C.guint
	var arg3 *C.GtkRequestedSize

	arg1 = C.int(extraSpace)
	arg2 = C.guint(nRequestedSizes)
	arg3 = (*C.GtkRequestedSize)(sizes.Native())

	ret := C.gtk_distribute_natural_allocation(arg1, arg2, arg3)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// FileChooserErrorQuark registers an error quark for FileChooser if necessary.
func FileChooserErrorQuark() glib.Quark {

	ret := C.gtk_file_chooser_error_quark()

	var ret0 glib.Quark

	{
		var tmp uint32
		tmp = uint32(ret)
		ret0 = glib.Quark(tmp)
	}

	return ret0
}

// GetBinaryAge returns the binary age as passed to `libtool` when building the
// GTK library the process is running against. If `libtool` means nothing to
// you, don't worry about it.
func GetBinaryAge() uint {

	ret := C.gtk_get_binary_age()

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// GetDebugFlags returns the GTK debug flags that are currently active.
//
// This function is intended for GTK modules that want to adjust their debug
// output based on GTK debug flags.
func GetDebugFlags() DebugFlags {

	ret := C.gtk_get_debug_flags()

	var ret0 DebugFlags

	ret0 = DebugFlags(ret)

	return ret0
}

// GetDefaultLanguage returns the Language for the default language currently in
// effect. (Note that this can change over the life of an application.) The
// default language is derived from the current locale. It determines, for
// example, whether GTK uses the right-to-left or left-to-right text direction.
//
// This function is equivalent to pango_language_get_default(). See that
// function for details.
func GetDefaultLanguage() *pango.Language {

	ret := C.gtk_get_default_language()

	var ret0 *pango.Language

	ret0 = pango.WrapLanguage(ret)

	return ret0
}

// GetInterfaceAge returns the interface age as passed to `libtool` when
// building the GTK library the process is running against. If `libtool` means
// nothing to you, don't worry about it.
func GetInterfaceAge() uint {

	ret := C.gtk_get_interface_age()

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// GetLocaleDirection: get the direction of the current locale. This is the
// expected reading direction for text and UI.
//
// This function depends on the current locale being set with setlocale() and
// will default to setting the GTK_TEXT_DIR_LTR direction otherwise.
// GTK_TEXT_DIR_NONE will never be returned.
//
// GTK sets the default text direction according to the locale during
// gtk_init(), and you should normally use gtk_widget_get_direction() or
// gtk_widget_get_default_direction() to obtain the current direction.
//
// This function is only needed rare cases when the locale is changed after GTK
// has already been initialized. In this case, you can use it to update the
// default text direction as follows:
//
//    setlocale (LC_ALL, new_locale);
//    direction = gtk_get_locale_direction ();
//    gtk_widget_set_default_direction (direction);
//
func GetLocaleDirection() TextDirection {

	ret := C.gtk_get_locale_direction()

	var ret0 TextDirection

	ret0 = TextDirection(ret)

	return ret0
}

// GetMajorVersion returns the major version number of the GTK library. (e.g. in
// GTK version 3.1.5 this is 3.)
//
// This function is in the library, so it represents the GTK library your code
// is running against. Contrast with the GTK_MAJOR_VERSION macro, which
// represents the major version of the GTK headers you have included when
// compiling your code.
func GetMajorVersion() uint {

	ret := C.gtk_get_major_version()

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// GetMicroVersion returns the micro version number of the GTK library. (e.g. in
// GTK version 3.1.5 this is 5.)
//
// This function is in the library, so it represents the GTK library your code
// is are running against. Contrast with the GTK_MICRO_VERSION macro, which
// represents the micro version of the GTK headers you have included when
// compiling your code.
func GetMicroVersion() uint {

	ret := C.gtk_get_micro_version()

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// GetMinorVersion returns the minor version number of the GTK library. (e.g. in
// GTK version 3.1.5 this is 1.)
//
// This function is in the library, so it represents the GTK library your code
// is are running against. Contrast with the GTK_MINOR_VERSION macro, which
// represents the minor version of the GTK headers you have included when
// compiling your code.
func GetMinorVersion() uint {

	ret := C.gtk_get_minor_version()

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// HSVToRGB converts a color from HSV space to RGB.
//
// Input values must be in the [0.0, 1.0] range; output values will be in the
// same range.
func HSVToRGB(h float32, s float32, v float32) (r float32, g float32, b float32) {
	var arg1 C.float
	var arg2 C.float
	var arg3 C.float
	var arg4 *C.float // out
	var arg5 *C.float // out
	var arg6 *C.float // out

	arg1 = C.float(h)
	arg2 = C.float(s)
	arg3 = C.float(v)

	ret := C.gtk_hsv_to_rgb(arg1, arg2, arg3, &arg4, &arg5, &arg6)

	var ret0 float32
	var ret1 float32
	var ret2 float32

	ret0 = float32(arg4)

	ret1 = float32(arg5)

	ret2 = float32(arg6)

	return ret0, ret1, ret2
}

func IconThemeErrorQuark() glib.Quark {

	ret := C.gtk_icon_theme_error_quark()

	var ret0 glib.Quark

	{
		var tmp uint32
		tmp = uint32(ret)
		ret0 = glib.Quark(tmp)
	}

	return ret0
}

func ImModulesInit() {

	C.gtk_im_modules_init()
}

// Init: call this function before using any other GTK functions in your GUI
// applications. It will initialize everything needed to operate the toolkit and
// parses some standard command line options.
//
// If you are using Application, you don't have to call gtk_init() or
// gtk_init_check(); the #GApplication::startup handler does it for you.
//
// This function will terminate your program if it was unable to initialize the
// windowing system for some reason. If you want your program to fall back to a
// textual interface you want to call gtk_init_check() instead.
//
// GTK calls `signal (SIGPIPE, SIG_IGN)` during initialization, to ignore
// SIGPIPE signals, since these are almost never wanted in graphical
// applications. If you do need to handle SIGPIPE for some reason, reset the
// handler after gtk_init(), but notice that other libraries (e.g. libdbus or
// gvfs) might do similar things.
func Init() {

	C.gtk_init()
}

// InitCheck: this function does the same work as gtk_init() with only a single
// change: It does not terminate the program if the windowing system can’t be
// initialized. Instead it returns false on failure.
//
// This way the application can fall back to some other means of communication
// with the user - for example a curses or command line interface.
func InitCheck() bool {

	ret := C.gtk_init_check()

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// IsInitialized: use this function to check if GTK has been initialized with
// gtk_init() or gtk_init_check().
func IsInitialized() bool {

	ret := C.gtk_is_initialized()

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// NativeGetForSurface finds the GtkNative associated with the surface.
func NativeGetForSurface(surface gdk.Surface) Native {
	var arg1 *C.GdkSurface

	arg1 = (*C.GdkSurface)(surface.Native())

	ret := C.gtk_native_get_for_surface(arg1)

	var ret0 Native

	return ret0
}

// PaperSizeGetDefault returns the name of the default paper size, which depends
// on the current locale.
func PaperSizeGetDefault() string {

	ret := C.gtk_paper_size_get_default()

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// PaperSizeGetPaperSizes creates a list of known paper sizes.
func PaperSizeGetPaperSizes(includeCustom bool) *glib.List {
	var arg1 C.gboolean

	arg1 = gextras.Cbool(includeCustom)

	ret := C.gtk_paper_size_get_paper_sizes(arg1)

	var ret0 *glib.List

	ret0 = glib.WrapList(ret)

	return ret0
}

// PrintErrorQuark registers an error quark for PrintOperation if necessary.
func PrintErrorQuark() glib.Quark {

	ret := C.gtk_print_error_quark()

	var ret0 glib.Quark

	{
		var tmp uint32
		tmp = uint32(ret)
		ret0 = glib.Quark(tmp)
	}

	return ret0
}

// PrintRunPageSetupDialog runs a page setup dialog, letting the user modify the
// values from @page_setup. If the user cancels the dialog, the returned
// PageSetup is identical to the passed in @page_setup, otherwise it contains
// the modifications done in the dialog.
//
// Note that this function may use a recursive mainloop to show the page setup
// dialog. See gtk_print_run_page_setup_dialog_async() if this is a problem.
func PrintRunPageSetupDialog(parent Window, pageSetup PageSetup, settings PrintSettings) PageSetup {
	var arg1 *C.GtkWindow
	var arg2 *C.GtkPageSetup
	var arg3 *C.GtkPrintSettings

	arg1 = (*C.GtkWindow)(parent.Native())
	arg2 = (*C.GtkPageSetup)(pageSetup.Native())
	arg3 = (*C.GtkPrintSettings)(settings.Native())

	ret := C.gtk_print_run_page_setup_dialog(arg1, arg2, arg3)

	var ret0 PageSetup

	ret0 = WrapPageSetup(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// PrintRunPageSetupDialogAsync runs a page setup dialog, letting the user
// modify the values from @page_setup.
//
// In contrast to gtk_print_run_page_setup_dialog(), this function returns after
// showing the page setup dialog on platforms that support this, and calls
// @done_cb from a signal handler for the ::response signal of the dialog.
func PrintRunPageSetupDialogAsync(parent Window, pageSetup PageSetup, settings PrintSettings, doneCb PageSetupDoneFunc) {
	var arg1 *C.GtkWindow
	var arg2 *C.GtkPageSetup
	var arg3 *C.GtkPrintSettings
	var arg4 C.GtkPageSetupDoneFunc
	arg5 := C.gpointer(box.Assign(data))

	arg1 = (*C.GtkWindow)(parent.Native())
	arg2 = (*C.GtkPageSetup)(pageSetup.Native())
	arg3 = (*C.GtkPrintSettings)(settings.Native())
	arg4 = (*[0]byte)(C.gotk4_PageSetupDoneFunc)

	C.gtk_print_run_page_setup_dialog_async(arg1, arg2, arg3, arg4)
}

func RecentManagerErrorQuark() glib.Quark {

	ret := C.gtk_recent_manager_error_quark()

	var ret0 glib.Quark

	{
		var tmp uint32
		tmp = uint32(ret)
		ret0 = glib.Quark(tmp)
	}

	return ret0
}

// RenderActivity renders an activity indicator (such as in Spinner). The state
// GTK_STATE_FLAG_CHECKED determines whether there is activity going on.
func RenderActivity(context StyleContext, cr *cairo.Context, x float64, y float64, width float64, height float64) {
	var arg1 *C.GtkStyleContext
	var arg2 *C.cairo_t
	var arg3 C.double
	var arg4 C.double
	var arg5 C.double
	var arg6 C.double

	arg1 = (*C.GtkStyleContext)(context.Native())
	arg2 = (*C.cairo_t)(cr.Native())
	arg3 = C.double(x)
	arg4 = C.double(y)
	arg5 = C.double(width)
	arg6 = C.double(height)

	C.gtk_render_activity(arg1, arg2, arg3, arg4, arg5, arg6)
}

// RenderArrow renders an arrow pointing to @angle.
//
// Typical arrow rendering at 0, 1⁄2 π;, π; and 3⁄2 π:
//
// ! (arrows.png)
func RenderArrow(context StyleContext, cr *cairo.Context, angle float64, x float64, y float64, size float64) {
	var arg1 *C.GtkStyleContext
	var arg2 *C.cairo_t
	var arg3 C.double
	var arg4 C.double
	var arg5 C.double
	var arg6 C.double

	arg1 = (*C.GtkStyleContext)(context.Native())
	arg2 = (*C.cairo_t)(cr.Native())
	arg3 = C.double(angle)
	arg4 = C.double(x)
	arg5 = C.double(y)
	arg6 = C.double(size)

	C.gtk_render_arrow(arg1, arg2, arg3, arg4, arg5, arg6)
}

// RenderBackground renders the background of an element.
//
// Typical background rendering, showing the effect of `background-image`,
// `border-width` and `border-radius`:
//
// ! (background.png)
func RenderBackground(context StyleContext, cr *cairo.Context, x float64, y float64, width float64, height float64) {
	var arg1 *C.GtkStyleContext
	var arg2 *C.cairo_t
	var arg3 C.double
	var arg4 C.double
	var arg5 C.double
	var arg6 C.double

	arg1 = (*C.GtkStyleContext)(context.Native())
	arg2 = (*C.cairo_t)(cr.Native())
	arg3 = C.double(x)
	arg4 = C.double(y)
	arg5 = C.double(width)
	arg6 = C.double(height)

	C.gtk_render_background(arg1, arg2, arg3, arg4, arg5, arg6)
}

// RenderCheck renders a checkmark (as in a CheckButton).
//
// The GTK_STATE_FLAG_CHECKED state determines whether the check is on or off,
// and GTK_STATE_FLAG_INCONSISTENT determines whether it should be marked as
// undefined.
//
// Typical checkmark rendering:
//
// ! (checks.png)
func RenderCheck(context StyleContext, cr *cairo.Context, x float64, y float64, width float64, height float64) {
	var arg1 *C.GtkStyleContext
	var arg2 *C.cairo_t
	var arg3 C.double
	var arg4 C.double
	var arg5 C.double
	var arg6 C.double

	arg1 = (*C.GtkStyleContext)(context.Native())
	arg2 = (*C.cairo_t)(cr.Native())
	arg3 = C.double(x)
	arg4 = C.double(y)
	arg5 = C.double(width)
	arg6 = C.double(height)

	C.gtk_render_check(arg1, arg2, arg3, arg4, arg5, arg6)
}

// RenderExpander renders an expander (as used in TreeView and Expander) in the
// area defined by @x, @y, @width, @height. The state GTK_STATE_FLAG_CHECKED
// determines whether the expander is collapsed or expanded.
//
// Typical expander rendering:
//
// ! (expanders.png)
func RenderExpander(context StyleContext, cr *cairo.Context, x float64, y float64, width float64, height float64) {
	var arg1 *C.GtkStyleContext
	var arg2 *C.cairo_t
	var arg3 C.double
	var arg4 C.double
	var arg5 C.double
	var arg6 C.double

	arg1 = (*C.GtkStyleContext)(context.Native())
	arg2 = (*C.cairo_t)(cr.Native())
	arg3 = C.double(x)
	arg4 = C.double(y)
	arg5 = C.double(width)
	arg6 = C.double(height)

	C.gtk_render_expander(arg1, arg2, arg3, arg4, arg5, arg6)
}

// RenderFocus renders a focus indicator on the rectangle determined by @x, @y,
// @width, @height.
//
// Typical focus rendering:
//
// ! (focus.png)
func RenderFocus(context StyleContext, cr *cairo.Context, x float64, y float64, width float64, height float64) {
	var arg1 *C.GtkStyleContext
	var arg2 *C.cairo_t
	var arg3 C.double
	var arg4 C.double
	var arg5 C.double
	var arg6 C.double

	arg1 = (*C.GtkStyleContext)(context.Native())
	arg2 = (*C.cairo_t)(cr.Native())
	arg3 = C.double(x)
	arg4 = C.double(y)
	arg5 = C.double(width)
	arg6 = C.double(height)

	C.gtk_render_focus(arg1, arg2, arg3, arg4, arg5, arg6)
}

// RenderFrame renders a frame around the rectangle defined by @x, @y, @width,
// @height.
//
// Examples of frame rendering, showing the effect of `border-image`,
// `border-color`, `border-width`, `border-radius` and junctions:
//
// ! (frames.png)
func RenderFrame(context StyleContext, cr *cairo.Context, x float64, y float64, width float64, height float64) {
	var arg1 *C.GtkStyleContext
	var arg2 *C.cairo_t
	var arg3 C.double
	var arg4 C.double
	var arg5 C.double
	var arg6 C.double

	arg1 = (*C.GtkStyleContext)(context.Native())
	arg2 = (*C.cairo_t)(cr.Native())
	arg3 = C.double(x)
	arg4 = C.double(y)
	arg5 = C.double(width)
	arg6 = C.double(height)

	C.gtk_render_frame(arg1, arg2, arg3, arg4, arg5, arg6)
}

// RenderHandle renders a handle (as in Paned and Window’s resize grip), in the
// rectangle determined by @x, @y, @width, @height.
//
// Handles rendered for the paned and grip classes:
//
// ! (handles.png)
func RenderHandle(context StyleContext, cr *cairo.Context, x float64, y float64, width float64, height float64) {
	var arg1 *C.GtkStyleContext
	var arg2 *C.cairo_t
	var arg3 C.double
	var arg4 C.double
	var arg5 C.double
	var arg6 C.double

	arg1 = (*C.GtkStyleContext)(context.Native())
	arg2 = (*C.cairo_t)(cr.Native())
	arg3 = C.double(x)
	arg4 = C.double(y)
	arg5 = C.double(width)
	arg6 = C.double(height)

	C.gtk_render_handle(arg1, arg2, arg3, arg4, arg5, arg6)
}

// RenderIcon renders the icon in @texture at the specified @x and @y
// coordinates.
//
// This function will render the icon in @texture at exactly its size,
// regardless of scaling factors, which may not be appropriate when drawing on
// displays with high pixel densities.
func RenderIcon(context StyleContext, cr *cairo.Context, texture gdk.Texture, x float64, y float64) {
	var arg1 *C.GtkStyleContext
	var arg2 *C.cairo_t
	var arg3 *C.GdkTexture
	var arg4 C.double
	var arg5 C.double

	arg1 = (*C.GtkStyleContext)(context.Native())
	arg2 = (*C.cairo_t)(cr.Native())
	arg3 = (*C.GdkTexture)(texture.Native())
	arg4 = C.double(x)
	arg5 = C.double(y)

	C.gtk_render_icon(arg1, arg2, arg3, arg4, arg5)
}

// RenderLayout renders @layout on the coordinates @x, @y
func RenderLayout(context StyleContext, cr *cairo.Context, x float64, y float64, layout pango.Layout) {
	var arg1 *C.GtkStyleContext
	var arg2 *C.cairo_t
	var arg3 C.double
	var arg4 C.double
	var arg5 *C.PangoLayout

	arg1 = (*C.GtkStyleContext)(context.Native())
	arg2 = (*C.cairo_t)(cr.Native())
	arg3 = C.double(x)
	arg4 = C.double(y)
	arg5 = (*C.PangoLayout)(layout.Native())

	C.gtk_render_layout(arg1, arg2, arg3, arg4, arg5)
}

// RenderLine renders a line from (x0, y0) to (x1, y1).
func RenderLine(context StyleContext, cr *cairo.Context, x0 float64, y0 float64, x1 float64, y1 float64) {
	var arg1 *C.GtkStyleContext
	var arg2 *C.cairo_t
	var arg3 C.double
	var arg4 C.double
	var arg5 C.double
	var arg6 C.double

	arg1 = (*C.GtkStyleContext)(context.Native())
	arg2 = (*C.cairo_t)(cr.Native())
	arg3 = C.double(x0)
	arg4 = C.double(y0)
	arg5 = C.double(x1)
	arg6 = C.double(y1)

	C.gtk_render_line(arg1, arg2, arg3, arg4, arg5, arg6)
}

// RenderOption renders an option mark (as in a radio button), the
// GTK_STATE_FLAG_CHECKED state will determine whether the option is on or off,
// and GTK_STATE_FLAG_INCONSISTENT whether it should be marked as undefined.
//
// Typical option mark rendering:
//
// ! (options.png)
func RenderOption(context StyleContext, cr *cairo.Context, x float64, y float64, width float64, height float64) {
	var arg1 *C.GtkStyleContext
	var arg2 *C.cairo_t
	var arg3 C.double
	var arg4 C.double
	var arg5 C.double
	var arg6 C.double

	arg1 = (*C.GtkStyleContext)(context.Native())
	arg2 = (*C.cairo_t)(cr.Native())
	arg3 = C.double(x)
	arg4 = C.double(y)
	arg5 = C.double(width)
	arg6 = C.double(height)

	C.gtk_render_option(arg1, arg2, arg3, arg4, arg5, arg6)
}

// RGBToHSV converts a color from RGB space to HSV.
//
// Input values must be in the [0.0, 1.0] range; output values will be in the
// same range.
func RGBToHSV(r float32, g float32, b float32) (h float32, s float32, v float32) {
	var arg1 C.float
	var arg2 C.float
	var arg3 C.float
	var arg4 *C.float // out
	var arg5 *C.float // out
	var arg6 *C.float // out

	arg1 = C.float(r)
	arg2 = C.float(g)
	arg3 = C.float(b)

	ret := C.gtk_rgb_to_hsv(arg1, arg2, arg3, &arg4, &arg5, &arg6)

	var ret0 float32
	var ret1 float32
	var ret2 float32

	ret0 = float32(arg4)

	ret1 = float32(arg5)

	ret2 = float32(arg6)

	return ret0, ret1, ret2
}

// SetDebugFlags sets the GTK debug flags.
func SetDebugFlags(flags DebugFlags) {
	var arg1 C.GtkDebugFlags

	arg1 = (C.GtkDebugFlags)(flags)

	C.gtk_set_debug_flags(arg1)
}

// ShowURI: this function launches the default application for showing a given
// uri, or shows an error dialog if that fails.
func ShowURI(parent Window, uri string, timestamp uint32) {
	var arg1 *C.GtkWindow
	var arg2 *C.char
	var arg3 C.guint32

	arg1 = (*C.GtkWindow)(parent.Native())
	arg2 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = C.guint32(timestamp)

	C.gtk_show_uri(arg1, arg2, arg3)
}

// ShowURIFull: this function launches the default application for showing a
// given uri.
//
// The @callback will be called when the launch is completed. It should call
// gtk_show_uri_full_finish() to obtain the result.
//
// This is the recommended call to be used as it passes information necessary
// for sandbox helpers to parent their dialogs properly.
func ShowURIFull(parent Window, uri string, timestamp uint32, cancellable gio.Cancellable, callback gio.AsyncReadyCallback) {
	var arg1 *C.GtkWindow
	var arg2 *C.char
	var arg3 C.guint32
	var arg4 *C.GCancellable
	var arg5 C.GAsyncReadyCallback
	var arg6 C.gpointer

	arg1 = (*C.GtkWindow)(parent.Native())
	arg2 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = C.guint32(timestamp)
	arg4 = (*C.GCancellable)(cancellable.Native())

	C.gtk_show_uri_full(arg1, arg2, arg3, arg4, arg5, arg6)
}

// ShowURIFullFinish finishes the gtk_show_uri() call and returns the result of
// the operation.
func ShowURIFullFinish(parent Window, result gio.AsyncResult) bool {
	var arg1 *C.GtkWindow
	var arg2 *C.GAsyncResult

	arg1 = (*C.GtkWindow)(parent.Native())

	ret := C.gtk_show_uri_full_finish(arg1, arg2)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

func TestAccessibleAssertionMessageRole(domain string, file string, line int, _func string, expr string, accessible Accessible, expectedRole AccessibleRole, actualRole AccessibleRole) {
	var arg1 *C.char
	var arg2 *C.char
	var arg3 C.int
	var arg4 *C.char
	var arg5 *C.char
	var arg6 *C.GtkAccessible
	var arg7 C.GtkAccessibleRole
	var arg8 C.GtkAccessibleRole

	arg1 = (*C.gchar)(C.CString(domain))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(file))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = C.int(line)
	arg4 = (*C.gchar)(C.CString(_func))
	defer C.free(unsafe.Pointer(arg4))
	arg5 = (*C.gchar)(C.CString(expr))
	defer C.free(unsafe.Pointer(arg5))
	arg7 = (C.GtkAccessibleRole)(expectedRole)
	arg8 = (C.GtkAccessibleRole)(actualRole)

	C.gtk_test_accessible_assertion_message_role(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)
}

// TestAccessibleHasProperty checks whether the Accessible has @property set.
func TestAccessibleHasProperty(accessible Accessible, property AccessibleProperty) bool {
	var arg1 *C.GtkAccessible
	var arg2 C.GtkAccessibleProperty

	arg2 = (C.GtkAccessibleProperty)(property)

	ret := C.gtk_test_accessible_has_property(arg1, arg2)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// TestAccessibleHasRelation checks whether the Accessible has @relation set.
func TestAccessibleHasRelation(accessible Accessible, relation AccessibleRelation) bool {
	var arg1 *C.GtkAccessible
	var arg2 C.GtkAccessibleRelation

	arg2 = (C.GtkAccessibleRelation)(relation)

	ret := C.gtk_test_accessible_has_relation(arg1, arg2)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// TestAccessibleHasRole checks whether the Accessible:accessible-role of the
// accessible is @role.
func TestAccessibleHasRole(accessible Accessible, role AccessibleRole) bool {
	var arg1 *C.GtkAccessible
	var arg2 C.GtkAccessibleRole

	arg2 = (C.GtkAccessibleRole)(role)

	ret := C.gtk_test_accessible_has_role(arg1, arg2)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// TestAccessibleHasState checks whether the Accessible has @state set.
func TestAccessibleHasState(accessible Accessible, state AccessibleState) bool {
	var arg1 *C.GtkAccessible
	var arg2 C.GtkAccessibleState

	arg2 = (C.GtkAccessibleState)(state)

	ret := C.gtk_test_accessible_has_state(arg1, arg2)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// TestListAllTypes: return the type ids that have been registered after calling
// gtk_test_register_all_types().
func TestListAllTypes() (nTypes uint, gTypes []externglib.Type) {
	var arg1 *C.guint // out

	ret := C.gtk_test_list_all_types(&arg1)

	var ret0 uint
	var ret1 []externglib.Type

	ret0 = uint(arg1)

	return ret0, ret1
}

// TestRegisterAllTypes: force registration of all core GTK object types.
//
// This allowes to refer to any of those object types via g_type_from_name()
// after calling this function.
func TestRegisterAllTypes() {

	C.gtk_test_register_all_types()
}

// TestWidgetWaitForDraw enters the main loop and waits for @widget to be
// “drawn”. In this context that means it waits for the frame clock of @widget
// to have run a full styling, layout and drawing cycle.
//
// This function is intended to be used for syncing with actions that depend on
// @widget relayouting or on interaction with the display server.
func TestWidgetWaitForDraw(widget Widget) {
	var arg1 *C.GtkWidget

	arg1 = (*C.GtkWidget)(widget.Native())

	C.gtk_test_widget_wait_for_draw(arg1)
}

// TreeCreateRowDragContent creates a content provider for dragging @path from
// @tree_model.
func TreeCreateRowDragContent(treeModel TreeModel, path *TreePath) gdk.ContentProvider {
	var arg1 *C.GtkTreeModel
	var arg2 *C.GtkTreePath

	arg2 = (*C.GtkTreePath)(path.Native())

	ret := C.gtk_tree_create_row_drag_content(arg1, arg2)

	var ret0 gdk.ContentProvider

	ret0 = gdk.WrapContentProvider(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// TreeGetRowDragData obtains a @tree_model and @path from value of target type
// GTK_TYPE_TREE_ROW_DATA.
//
// The returned path must be freed with gtk_tree_path_free().
func TreeGetRowDragData(value *externglib.Value) (treeModel TreeModel, path *TreePath, ok bool) {
	var arg1 *C.GValue
	var arg2 **C.GtkTreeModel // out
	var arg3 **C.GtkTreePath  // out

	arg1 = (*C.GValue)(value.GValue)

	ret := C.gtk_tree_get_row_drag_data(arg1, &arg2, &arg3)

	var ret0 *TreeModel
	var ret1 **TreePath
	var ret2 bool

	ret1 = WrapTreePath(arg3)

	ret2 = gextras.Gobool(ret)

	return ret0, ret1, ret2
}

// TreeRowReferenceDeleted lets a set of row reference created by
// gtk_tree_row_reference_new_proxy() know that the model emitted the
// TreeModel::row-deleted signal.
func TreeRowReferenceDeleted(proxy gextras.Objector, path *TreePath) {
	var arg1 *C.GObject
	var arg2 *C.GtkTreePath

	arg1 = (*C.GObject)(proxy.Native())
	arg2 = (*C.GtkTreePath)(path.Native())

	C.gtk_tree_row_reference_deleted(arg1, arg2)
}

// TreeRowReferenceInserted lets a set of row reference created by
// gtk_tree_row_reference_new_proxy() know that the model emitted the
// TreeModel::row-inserted signal.
func TreeRowReferenceInserted(proxy gextras.Objector, path *TreePath) {
	var arg1 *C.GObject
	var arg2 *C.GtkTreePath

	arg1 = (*C.GObject)(proxy.Native())
	arg2 = (*C.GtkTreePath)(path.Native())

	C.gtk_tree_row_reference_inserted(arg1, arg2)
}

// TreeRowReferenceReordered lets a set of row reference created by
// gtk_tree_row_reference_new_proxy() know that the model emitted the
// TreeModel::rows-reordered signal.
func TreeRowReferenceReordered(proxy gextras.Objector, path *TreePath, iter *TreeIter, newOrder []int) {
	var arg1 *C.GObject
	var arg2 *C.GtkTreePath
	var arg3 *C.GtkTreeIter
	var arg4 *C.int

	arg1 = (*C.GObject)(proxy.Native())
	arg2 = (*C.GtkTreePath)(path.Native())
	arg3 = (*C.GtkTreeIter)(iter.Native())
	{

	}

	C.gtk_tree_row_reference_reordered(arg1, arg2, arg3, arg4)
}

// ValueDupExpression retrieves the Expression stored inside the given @value,
// and acquires a reference to it.
func ValueDupExpression(value *externglib.Value) Expression {
	var arg1 *C.GValue

	arg1 = (*C.GValue)(value.GValue)

	ret := C.gtk_value_dup_expression(arg1)

	var ret0 Expression

	ret0 = WrapExpression(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// ValueGetExpression retrieves the Expression stored inside the given @value.
func ValueGetExpression(value *externglib.Value) Expression {
	var arg1 *C.GValue

	arg1 = (*C.GValue)(value.GValue)

	ret := C.gtk_value_get_expression(arg1)

	var ret0 Expression

	ret0 = WrapExpression(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// ValueSetExpression stores the given Expression inside @value.
//
// The #GValue will acquire a reference to the @expression.
func ValueSetExpression(value *externglib.Value, expression Expression) {
	var arg1 *C.GValue
	var arg2 *C.GtkExpression

	arg1 = (*C.GValue)(value.GValue)
	arg2 = (*C.GtkExpression)(expression.Native())

	C.gtk_value_set_expression(arg1, arg2)
}

// ValueTakeExpression stores the given Expression inside @value.
//
// This function transfers the ownership of the @expression to the #GValue.
func ValueTakeExpression(value *externglib.Value, expression Expression) {
	var arg1 *C.GValue
	var arg2 *C.GtkExpression

	arg1 = (*C.GValue)(value.GValue)
	arg2 = (*C.GtkExpression)(expression.Native())

	C.gtk_value_take_expression(arg1, arg2)
}

// Accessible: gtkAccessible provides an interface for describing a UI element,
// like a Widget, in a way that can be consumed by Assistive Technologies, or
// “AT”. Every accessible implementation has:
//
//    - a “role”, represented by a value of the AccessibleRole enumeration
//    - an “attribute”, represented by a set of AccessibleState,
//      AccessibleProperty and AccessibleRelation values
//
// The role cannot be changed after instantiating a Accessible implementation.
//
// The attributes are updated every time a UI element's state changes in a way
// that should be reflected by assistive technologies. For instance, if a Widget
// visibility changes, the GTK_ACCESSIBLE_STATE_HIDDEN state will also change to
// reflect the Widget:visible property.
type Accessible interface {
	AccessibleRole() AccessibleRole
	ResetProperty(property AccessibleProperty)
	ResetRelation(relation AccessibleRelation)
	ResetState(state AccessibleState)
	UpdatePropertyValue(nProperties int, properties []AccessibleProperty, values []*externglib.Value)
	UpdateRelationValue(nRelations int, relations []AccessibleRelation, values []*externglib.Value)
	UpdateStateValue(nStates int, states []AccessibleState, values []*externglib.Value)
}

// Actionable: this interface provides a convenient way of associating widgets
// with actions on a ApplicationWindow or Application.
//
// It primarily consists of two properties: Actionable:action-name and
// Actionable:action-target. There are also some convenience APIs for setting
// these properties.
//
// The action will be looked up in action groups that are found among the
// widgets ancestors. Most commonly, these will be the actions with the “win.”
// or “app.” prefix that are associated with the ApplicationWindow or
// Application, but other action groups that are added with
// gtk_widget_insert_action_group() will be consulted as well.
type Actionable interface {
	ActionName() string
	ActionTargetValue() *glib.Variant
	SetActionName(actionName string)
	SetActionTargetValue(targetValue *glib.Variant)
	SetDetailedActionName(detailedActionName string)
}

// AppChooser is an interface that can be implemented by widgets which allow the
// user to choose an application (typically for the purpose of opening a file).
// The main objects that implement this interface are AppChooserWidget,
// AppChooserDialog and AppChooserButton.
//
// Applications are represented by GIO Info objects here. GIO has a concept of
// recommended and fallback applications for a given content type. Recommended
// applications are those that claim to handle the content type itself, while
// fallback also includes applications that handle a more generic content type.
// GIO also knows the default and last-used application for a given content
// type. The AppChooserWidget provides detailed control over whether the shown
// list of applications should include default, recommended or fallback
// applications.
//
// To obtain the application that has been selected in a AppChooser, use
// gtk_app_chooser_get_app_info().
type AppChooser interface {
	AppInfo() gio.AppInfo
	ContentType() string
	Refresh()
}

// Buildable: gtkBuildable allows objects to extend and customize their
// deserialization from [GtkBuilder UI descriptions][BUILDER-UI]. The interface
// includes methods for setting names and properties of objects, parsing custom
// tags and constructing child objects.
//
// The GtkBuildable interface is implemented by all widgets and many of the
// non-widget objects that are provided by GTK. The main user of this interface
// is Builder. There should be very little need for applications to call any of
// these functions directly.
//
// An object only needs to implement this interface if it needs to extend the
// Builder format or run any extra routines at deserialization time.
type Buildable interface {
	BuildableID() string
}

// CellEditable: the CellEditable interface must be implemented for widgets to
// be usable to edit the contents of a TreeView cell. It provides a way to
// specify how temporary widgets should be configured for editing, get the new
// value, etc.
type CellEditable interface {
	EditingDone()
	RemoveWidget()
	StartEditing(event gdk.Event)
}

// CellLayout is an interface to be implemented by all objects which want to
// provide a TreeViewColumn like API for packing cells, setting attributes and
// data funcs.
//
// One of the notable features provided by implementations of GtkCellLayout are
// attributes. Attributes let you set the properties in flexible ways. They can
// just be set to constant values like regular properties. But they can also be
// mapped to a column of the underlying tree model with
// gtk_cell_layout_set_attributes(), which means that the value of the attribute
// can change from cell to cell as they are rendered by the cell renderer.
// Finally, it is possible to specify a function with
// gtk_cell_layout_set_cell_data_func() that is called to determine the value of
// the attribute for each cell that is rendered.
//
//
// GtkCellLayouts as GtkBuildable
//
// Implementations of GtkCellLayout which also implement the GtkBuildable
// interface (CellView, IconView, ComboBox, EntryCompletion, TreeViewColumn)
// accept GtkCellRenderer objects as <child> elements in UI definitions. They
// support a custom <attributes> element for their children, which can contain
// multiple <attribute> elements. Each <attribute> element has a name attribute
// which specifies a property of the cell renderer; the content of the element
// is the attribute value.
//
// This is an example of a UI definition fragment specifying attributes:
//
//
//    <object class="GtkCellView">
//      <child>
//        <object class="GtkCellRendererText"/>
//        <attributes>
//          <attribute name="text">0</attribute>
//        </attributes>
//      </child>"
//    </object>
//    ]|
//
//    Furthermore for implementations of GtkCellLayout that use a CellArea
//    to lay out cells (all GtkCellLayouts in GTK use a GtkCellArea)
//    [cell properties][cell-properties] can also be defined in the format by
//    specifying the custom <cell-packing> attribute which can contain multiple
//    <property> elements defined in the normal way.
//
//    Here is a UI definition fragment specifying cell properties:
//
//    |[
//    <object class="GtkTreeViewColumn">
//      <child>
//        <object class="GtkCellRendererText"/>
//        <cell-packing>
//          <property name="align">True</property>
//          <property name="expand">False</property>
//        </cell-packing>
//      </child>"
//    </object>
//    ]|
//
//
//
// Subclassing GtkCellLayout implementations
//
//
//    When subclassing a widget that implements CellLayout like
//    IconView or ComboBox, there are some considerations related
//    to the fact that these widgets internally use a CellArea.
//    The cell area is exposed as a construct-only property by these
//    widgets. This means that it is possible to e.g. do
//
//    |[<!-- language="C" -->
//    combo = g_object_new (GTK_TYPE_COMBO_BOX, "cell-area", my_cell_area, NULL);
//    ]|
//
//    to use a custom cell area with a combo box. But construct properties
//    are only initialized after instance init()
//    functions have run, which means that using functions which rely on
//    the existence of the cell area in your subclass’ init() function will
//    cause the default cell area to be instantiated. In this case, a provided
//    construct property value will be ignored (with a warning, to alert
//    you to the problem).
//
//    |[<!-- language="C" -->
//    static void
//    my_combo_box_init (MyComboBox *b)
//    {
//      GtkCellRenderer *cell;
//
//      cell = gtk_cell_renderer_pixbuf_new ();
//      // The following call causes the default cell area for combo boxes,
//      // a GtkCellAreaBox, to be instantiated
//      gtk_cell_layout_pack_start (GTK_CELL_LAYOUT (b), cell, FALSE);
//      ...
//    }
//
//    GtkWidget *
//    my_combo_box_new (GtkCellArea *area)
//    {
//      // This call is going to cause a warning about area being ignored
//      return g_object_new (MY_TYPE_COMBO_BOX, "cell-area", area, NULL);
//    }
//
//
// If supporting alternative cell areas with your derived widget is not
// important, then this does not have to concern you. If you want to support
// alternative cell areas, you can do so by moving the problematic calls out of
// init() and into a constructor() for your class.
type CellLayout interface {
	AddAttribute(cell CellRenderer, attribute string, column int)
	Clear()
	ClearAttributes(cell CellRenderer)
	Area() CellArea
	Cells() *glib.List
	PackEnd(cell CellRenderer, expand bool)
	PackStart(cell CellRenderer, expand bool)
	Reorder(cell CellRenderer, position int)
	SetCellDataFunc(cell CellRenderer, _func CellLayoutDataFunc)
}

// ColorChooser is an interface that is implemented by widgets for choosing
// colors. Depending on the situation, colors may be allowed to have alpha
// (translucency).
//
// In GTK, the main widgets that implement this interface are
// ColorChooserWidget, ColorChooserDialog and ColorButton.
type ColorChooser interface {
	AddPalette(orientation Orientation, colorsPerLine int, nColors int, colors []gdk.RGBA)
	RGBA() gdk.RGBA
	UseAlpha() bool
	SetRGBA(color *gdk.RGBA)
	SetUseAlpha(useAlpha bool)
}

// Editable: the Editable interface is an interface which should be implemented
// by text editing widgets, such as Entry and SpinButton. It contains functions
// for generically manipulating an editable widget, a large number of action
// signals used for key bindings, and several signals that an application can
// connect to modify the behavior of a widget.
//
// As an example of the latter usage, by connecting the following handler to
// Editable::insert-text, an application can convert all entry into a widget
// into uppercase.
//
// Forcing entry to uppercase.
//
//    #include <ctype.h>
//
//    void
//    insert_text_handler (GtkEditable *editable,
//                         const char  *text,
//                         int          length,
//                         int         *position,
//                         gpointer     data)
//    {
//      char *result = g_utf8_strup (text, length);
//
//      g_signal_handlers_block_by_func (editable,
//                                   (gpointer) insert_text_handler, data);
//      gtk_editable_insert_text (editable, result, length, position);
//      g_signal_handlers_unblock_by_func (editable,
//                                         (gpointer) insert_text_handler, data);
//
//      g_signal_stop_emission_by_name (editable, "insert_text");
//
//      g_free (result);
//    }
//    ]|
//
//
//
// Implementing GtkEditable
//
//
//    The most likely scenario for implementing GtkEditable on your own widget
//    is that you will embed a Text inside a complex widget, and want to
//    delegate the editable functionality to that text widget. GtkEditable
//    provides some utility functions to make this easy.
//
//    In your class_init function, call gtk_editable_install_properties(),
//    passing the first available property ID:
//
//    |[
//    static void
//    my_class_init (MyClass *class)
//    {
//       ...
//       g_object_class_install_properties (object_class, NUM_PROPERTIES, props);
//       gtk_editable_install_properties (object_clas, NUM_PROPERTIES);
//       ...
//    }
//    ]|
//
//    In your interface_init function for the GtkEditable interface, provide
//    an implementation for the get_delegate vfunc that returns your text widget:
//
//    |[
//    GtkEditable *
//    get_editable_delegate (GtkEditable *editable)
//    {
//      return GTK_EDITABLE (MY_WIDGET (editable)->text_widget);
//    }
//
//    static void
//    my_editable_init (GtkEditableInterface *iface)
//    {
//      iface->get_delegate = get_editable_delegate;
//    }
//    ]|
//
//    You don't need to provide any other vfuncs. The default implementations
//    work by forwarding to the delegate that the EditableInterface.get_delegate()
//    vfunc returns.
//
//    In your instance_init function, create your text widget, and then call
//    gtk_editable_init_delegate():
//
//    |[
//    static void
//    my_widget_init (MyWidget *self)
//    {
//      ...
//      self->text_widget = gtk_text_new ();
//      gtk_editable_init_delegate (GTK_EDITABLE (self));
//      ...
//    }
//    ]|
//
//    In your dispose function, call gtk_editable_finish_delegate() before
//    destroying your text widget:
//
//    |[
//    static void
//    my_widget_dispose (GObject *object)
//    {
//      ...
//      gtk_editable_finish_delegate (GTK_EDITABLE (self));
//      g_clear_pointer (&self->text_widget, gtk_widget_unparent);
//      ...
//    }
//    ]|
//
//    Finally, use gtk_editable_delegate_set_property() in your `set_property`
//    function (and similar for `get_property`), to set the editable properties:
//
//    |[
//      ...
//      if (gtk_editable_delegate_set_property (object, prop_id, value, pspec))
//        return;
//
//      switch (prop_id)
//      ...
//
//
// It is important to note that if you create a GtkEditable that uses a
// delegate, the low level Editable::insert-text and Editable::delete-text
// signals will be propagated from the "wrapper" editable to the delegate, but
// they will not be propagated from the delegate to the "wrapper" editable, as
// they would cause an infinite recursion. If you wish to connect to the
// Editable::insert-text and Editable::delete-text signals, you will need to
// connect to them on the delegate obtained via gtk_editable_get_delegate().
type Editable interface {
	DeleteSelection()
	DeleteText(startPos int, endPos int)
	FinishDelegate()
	Alignment() float32
	Chars(startPos int, endPos int) string
	Delegate() Editable
	Editable() bool
	EnableUndo() bool
	MaxWidthChars() int
	Position() int
	SelectionBounds() (startPos int, endPos int, ok bool)
	Text() string
	WidthChars() int
	InitDelegate()
	InsertText(text string, length int, position int)
	SelectRegion(startPos int, endPos int)
	SetAlignment(xalign float32)
	SetEditable(isEditable bool)
	SetEnableUndo(enableUndo bool)
	SetMaxWidthChars(nChars int)
	SetPosition(position int)
	SetText(text string)
	SetWidthChars(nChars int)
}

// FileChooser is an interface that can be implemented by file selection
// widgets. In GTK, the main objects that implement this interface are
// FileChooserWidget and FileChooserDialog. You do not need to write an object
// that implements the FileChooser interface unless you are trying to adapt an
// existing file selector to expose a standard programming interface.
//
// FileChooser allows for shortcuts to various places in the filesystem. In the
// default implementation these are displayed in the left pane. It may be a bit
// confusing at first that these shortcuts come from various sources and in
// various flavours, so lets explain the terminology here:
//
// - Bookmarks: are created by the user, by dragging folders from the right pane
// to the left pane, or by using the “Add”. Bookmarks can be renamed and deleted
// by the user.
//
// - Shortcuts: can be provided by the application. For example, a Paint program
// may want to add a shortcut for a Clipart folder. Shortcuts cannot be modified
// by the user.
//
// - Volumes: are provided by the underlying filesystem abstraction. They are
// the “roots” of the filesystem.
//
//
// File Names and Encodings
//
// When the user is finished selecting files in a FileChooser, your program can
// get the selected filenames as #GFiles.
//
//
// Adding options
//
// You can add extra widgets to a file chooser to provide options that are not
// present in the default design, by using gtk_file_chooser_add_choice(). Each
// choice has an identifier and a user visible label; additionally, each choice
// can have multiple options. If a choice has no option, it will be rendered as
// a check button with the given label; if a choice has options, it will be
// rendered as a combo box.
type FileChooser interface {
	AddChoice(id string, label string, options []string, optionLabels []string)
	AddFilter(filter FileFilter)
	AddShortcutFolder(folder gio.File) bool
	Action() FileChooserAction
	Choice(id string) string
	CreateFolders() bool
	CurrentFolder() gio.File
	CurrentName() string
	File() gio.File
	Files() gio.ListModel
	Filter() FileFilter
	Filters() gio.ListModel
	SelectMultiple() bool
	ShortcutFolders() gio.ListModel
	RemoveChoice(id string)
	RemoveFilter(filter FileFilter)
	RemoveShortcutFolder(folder gio.File) bool
	SetAction(action FileChooserAction)
	SetChoice(id string, option string)
	SetCreateFolders(createFolders bool)
	SetCurrentFolder(file gio.File) bool
	SetCurrentName(name string)
	SetFile(file gio.File) bool
	SetFilter(filter FileFilter)
	SetSelectMultiple(selectMultiple bool)
}

// FontChooser is an interface that can be implemented by widgets displaying the
// list of fonts. In GTK, the main objects that implement this interface are
// FontChooserWidget, FontChooserDialog and FontButton.
type FontChooser interface {
	Font() string
	FontDesc() *pango.FontDescription
	FontFace() pango.FontFace
	FontFamily() pango.FontFamily
	FontFeatures() string
	FontMap() pango.FontMap
	FontSize() int
	Language() string
	Level() FontChooserLevel
	PreviewText() string
	ShowPreviewEntry() bool
	SetFilterFunc(filter FontFilterFunc)
	SetFont(fontname string)
	SetFontDesc(fontDesc *pango.FontDescription)
	SetFontMap(fontmap pango.FontMap)
	SetLanguage(language string)
	SetLevel(level FontChooserLevel)
	SetPreviewText(text string)
	SetShowPreviewEntry(showPreviewEntry bool)
}

// Native is the interface implemented by all widgets that can provide a
// GdkSurface for widgets to render on.
//
// The obvious example of a Native is Window.
type Native interface {
	Renderer() gsk.Renderer
	Surface() gdk.Surface
	SurfaceTransform() (x float64, y float64)
	Realize()
	Unrealize()
}

// Orientable: the Orientable interface is implemented by all widgets that can
// be oriented horizontally or vertically. Orientable is more flexible in that
// it allows the orientation to be changed at runtime, allowing the widgets to
// “flip”.
type Orientable interface {
	Orientation() Orientation
	SetOrientation(orientation Orientation)
}

type PrintOperationPreview interface {
	EndPreview()
	IsSelected(pageNr int) bool
	RenderPage(pageNr int)
}

// Root is the interface implemented by all widgets that can act as a toplevel
// widget to a hierarchy of widgets. The root widget takes care of providing the
// connection to the windowing system and manages layout, drawing and event
// delivery for its widget hierarchy.
//
// The obvious example of a Root is Window.
type Root interface {
	Display() gdk.Display
	Focus() Widget
	SetFocus(focus Widget)
}

// Scrollable is an interface that is implemented by widgets with native
// scrolling ability.
//
// To implement this interface you should override the Scrollable:hadjustment
// and Scrollable:vadjustment properties.
//
//
// Creating a scrollable widget
//
// All scrollable widgets should do the following.
//
// - When a parent widget sets the scrollable child widget’s adjustments, the
// widget should populate the adjustments’ Adjustment:lower, Adjustment:upper,
// Adjustment:step-increment, Adjustment:page-increment and Adjustment:page-size
// properties and connect to the Adjustment::value-changed signal.
//
// - Because its preferred size is the size for a fully expanded widget, the
// scrollable widget must be able to cope with underallocations. This means that
// it must accept any value passed to its WidgetClass.size_allocate() function.
//
// - When the parent allocates space to the scrollable child widget, the widget
// should update the adjustments’ properties with new values.
//
// - When any of the adjustments emits the Adjustment::value-changed signal, the
// scrollable widget should scroll its contents.
type Scrollable interface {
	Border() (border Border, ok bool)
	Hadjustment() Adjustment
	HscrollPolicy() ScrollablePolicy
	Vadjustment() Adjustment
	VscrollPolicy() ScrollablePolicy
	SetHadjustment(hadjustment Adjustment)
	SetHscrollPolicy(policy ScrollablePolicy)
	SetVadjustment(vadjustment Adjustment)
	SetVscrollPolicy(policy ScrollablePolicy)
}

// SelectionModel is an interface that extends the Model interface by adding
// support for selections. This support is then used by widgets using list
// models to add the ability to select and unselect various items.
//
// GTK provides default implementations of the most common selection modes such
// as SingleSelection, so you will only need to implement this interface if you
// want detailed control about how selections should be handled.
//
// A SelectionModel supports a single boolean per item indicating if an item is
// selected or not. This can be queried via gtk_selection_model_is_selected().
// When the selected state of one or more items changes, the model will emit the
// SelectionModel::selection-changed signal by calling the
// gtk_selection_model_selection_changed() function. The positions given in that
// signal may have their selection state changed, though that is not a
// requirement. If new items added to the model via the Model::items-changed
// signal are selected or not is up to the implementation.
//
// Note that items added via Model::items-changed may already be selected and no
// SelectionModel::selection-changed will be emitted for them. So to track which
// items are selected, it is necessary to listen to both signals.
//
// Additionally, the interface can expose functionality to select and unselect
// items. If these functions are implemented, GTK's list widgets will allow
// users to select and unselect items. However, SelectionModels are free to only
// implement them partially or not at all. In that case the widgets will not
// support the unimplemented operations.
//
// When selecting or unselecting is supported by a model, the return values of
// the selection functions do *not* indicate if selection or unselection
// happened. They are only meant to indicate complete failure, like when this
// mode of selecting is not supported by the model.
//
// Selections may happen asynchronously, so the only reliable way to find out
// when an item was selected is to listen to the signals that indicate
// selection.
type SelectionModel interface {
	Selection() *Bitset
	SelectionInRange(position uint, nItems uint) *Bitset
	IsSelected(position uint) bool
	SelectAll() bool
	SelectItem(position uint, unselectRest bool) bool
	SelectRange(position uint, nItems uint, unselectRest bool) bool
	SelectionChanged(position uint, nItems uint)
	SetSelection(selected *Bitset, mask *Bitset) bool
	UnselectAll() bool
	UnselectItem(position uint) bool
	UnselectRange(position uint, nItems uint) bool
}

type TreeDragDest interface {
	DragDataReceived(dest *TreePath, value *externglib.Value) bool
	RowDropPossible(destPath *TreePath, value *externglib.Value) bool
}

type TreeDragSource interface {
	DragDataDelete(path *TreePath) bool
	DragDataGet(path *TreePath) gdk.ContentProvider
	RowDraggable(path *TreePath) bool
}

// TreeModel: the TreeModel interface defines a generic tree interface for use
// by the TreeView widget. It is an abstract interface, and is designed to be
// usable with any appropriate data structure. The programmer just has to
// implement this interface on their own data type for it to be viewable by a
// TreeView widget.
//
// The model is represented as a hierarchical tree of strongly-typed, columned
// data. In other words, the model can be seen as a tree where every node has
// different values depending on which column is being queried. The type of data
// found in a column is determined by using the GType system (ie. TYPE_INT,
// K_TYPE_BUTTON, TYPE_POINTER, etc). The types are homogeneous per column
// across all nodes. It is important to note that this interface only provides a
// way of examining a model and observing changes. The implementation of each
// individual model decides how and if changes are made.
//
// In order to make life simpler for programmers who do not need to write their
// own specialized model, two generic models are provided — the TreeStore and
// the ListStore. To use these, the developer simply pushes data into these
// models as necessary. These models provide the data structure as well as all
// appropriate tree interfaces. As a result, implementing drag and drop,
// sorting, and storing data is trivial. For the vast majority of trees and
// lists, these two models are sufficient.
//
// Models are accessed on a node/column level of granularity. One can query for
// the value of a model at a certain node and a certain column on that node.
// There are two structures used to reference a particular node in a model. They
// are the TreePath-struct and the TreeIter-struct (“iter” is short for
// iterator). Most of the interface consists of operations on a TreeIter-struct.
//
// A path is essentially a potential node. It is a location on a model that may
// or may not actually correspond to a node on a specific model. The
// TreePath-struct can be converted into either an array of unsigned integers or
// a string. The string form is a list of numbers separated by a colon. Each
// number refers to the offset at that level. Thus, the path `0` refers to the
// root node and the path `2:4` refers to the fifth child of the third node.
//
// By contrast, a TreeIter-struct is a reference to a specific node on a
// specific model. It is a generic struct with an integer and three generic
// pointers. These are filled in by the model in a model-specific way. One can
// convert a path to an iterator by calling gtk_tree_model_get_iter(). These
// iterators are the primary way of accessing a model and are similar to the
// iterators used by TextBuffer. They are generally statically allocated on the
// stack and only used for a short time. The model interface defines a set of
// operations using them for navigating the model.
//
// It is expected that models fill in the iterator with private data. For
// example, the ListStore model, which is internally a simple linked list,
// stores a list node in one of the pointers. The TreeModelSort stores an array
// and an offset in two of the pointers. Additionally, there is an integer
// field. This field is generally filled with a unique stamp per model. This
// stamp is for catching errors resulting from using invalid iterators with a
// model.
//
// The lifecycle of an iterator can be a little confusing at first. Iterators
// are expected to always be valid for as long as the model is unchanged (and
// doesn’t emit a signal). The model is considered to own all outstanding
// iterators and nothing needs to be done to free them from the user’s point of
// view. Additionally, some models guarantee that an iterator is valid for as
// long as the node it refers to is valid (most notably the TreeStore and
// ListStore). Although generally uninteresting, as one always has to allow for
// the case where iterators do not persist beyond a signal, some very important
// performance enhancements were made in the sort model. As a result, the
// K_TREE_MODEL_ITERS_PERSIST flag was added to indicate this behavior.
//
// To help show some common operation of a model, some examples are provided.
// The first example shows three ways of getting the iter at the location
// `3:2:5`. While the first method shown is easier, the second is much more
// common, as you often get paths from callbacks.
//
// Acquiring a TreeIter-struct
//
//    enum
//    {
//      STRING_COLUMN,
//      INT_COLUMN,
//      N_COLUMNS
//    };
//
//    ...
//
//    GtkTreeModel *list_store;
//    GtkTreeIter iter;
//    gboolean valid;
//    int row_count = 0;
//
//    // make a new list_store
//    list_store = gtk_list_store_new (N_COLUMNS,
//                                     G_TYPE_STRING,
//                                     G_TYPE_INT);
//
//    // Fill the list store with data
//    populate_model (list_store);
//
//    // Get the first iter in the list, check it is valid and walk
//    // through the list, reading each row.
//
//    valid = gtk_tree_model_get_iter_first (list_store,
//                                           &iter);
//    while (valid)
//     {
//       char *str_data;
//       int    int_data;
//
//       // Make sure you terminate calls to gtk_tree_model_get() with a “-1” value
//       gtk_tree_model_get (list_store, &iter,
//                           STRING_COLUMN, &str_data,
//                           INT_COLUMN, &int_data,
//                           -1);
//
//       // Do something with the data
//       g_print ("Row d: (s,d)\n",
//                row_count, str_data, int_data);
//       g_free (str_data);
//
//       valid = gtk_tree_model_iter_next (list_store,
//                                         &iter);
//       row_count++;
//     }
//
//
// The TreeModel interface contains two methods for reference counting:
// gtk_tree_model_ref_node() and gtk_tree_model_unref_node(). These two methods
// are optional to implement. The reference counting is meant as a way for views
// to let models know when nodes are being displayed. TreeView will take a
// reference on a node when it is visible, which means the node is either in the
// toplevel or expanded. Being displayed does not mean that the node is
// currently directly visible to the user in the viewport. Based on this
// reference counting scheme a caching model, for example, can decide whether or
// not to cache a node based on the reference count. A file-system based model
// would not want to keep the entire file hierarchy in memory, but just the
// folders that are currently expanded in every current view.
//
// When working with reference counting, the following rules must be taken into
// account:
//
// - Never take a reference on a node without owning a reference on its parent.
// This means that all parent nodes of a referenced node must be referenced as
// well.
//
// - Outstanding references on a deleted node are not released. This is not
// possible because the node has already been deleted by the time the
// row-deleted signal is received.
//
// - Models are not obligated to emit a signal on rows of which none of its
// siblings are referenced. To phrase this differently, signals are only
// required for levels in which nodes are referenced. For the root level
// however, signals must be emitted at all times (however the root level is
// always referenced when any view is attached).
type TreeModel interface {
	NewFilter(root *TreePath) TreeModel
	Foreach(_func TreeModelForeachFunc)
	ColumnType(index_ int) externglib.Type
	Flags() TreeModelFlags
	Iter(path *TreePath) (iter TreeIter, ok bool)
	IterFirst() (iter TreeIter, ok bool)
	IterFromString(pathString string) (iter TreeIter, ok bool)
	NColumns() int
	Path(iter *TreeIter) *TreePath
	StringFromIter(iter *TreeIter) string
	Value(iter *TreeIter, column int) externglib.Value
	IterChildren(parent *TreeIter) (iter TreeIter, ok bool)
	IterHasChild(iter *TreeIter) bool
	IterNChildren(iter *TreeIter) int
	IterNext(iter *TreeIter) bool
	IterNthChild(parent *TreeIter, n int) (iter TreeIter, ok bool)
	IterParent(child *TreeIter) (iter TreeIter, ok bool)
	IterPrevious(iter *TreeIter) bool
	RefNode(iter *TreeIter)
	RowChanged(path *TreePath, iter *TreeIter)
	RowDeleted(path *TreePath)
	RowHasChildToggled(path *TreePath, iter *TreeIter)
	RowInserted(path *TreePath, iter *TreeIter)
	RowsReordered(path *TreePath, iter *TreeIter, newOrder int)
	RowsReorderedWithLength(path *TreePath, iter *TreeIter, newOrder []int)
	UnrefNode(iter *TreeIter)
}

// TreeSortable is an interface to be implemented by tree models which support
// sorting. The TreeView uses the methods provided by this interface to sort the
// model.
type TreeSortable interface {
	SortColumnID() (sortColumnID int, order SortType, ok bool)
	HasDefaultSortFunc() bool
	SetDefaultSortFunc(sortFunc TreeIterCompareFunc)
	SetSortColumnID(sortColumnID int, order SortType)
	SetSortFunc(sortColumnID int, sortFunc TreeIterCompareFunc)
	SortColumnChanged()
}

// Bitset is a data structure for representing a set of unsigned integers.
// Another name for this data structure is "bitmap".
//
// The current implementation is based on roaring bitmaps
// (https://roaringbitmap.org/).
//
// A bitset allows adding a set of integers and provides support for set
// operations like unions, intersections and checks for equality or if a value
// is contained in the set. Bitset also contains various functions to query
// metadata about the bitset, such as the minimum or maximum values or its size.
//
// The fastest way to iterate values in a bitset is BitsetIter.
//
// The main use case for Bitset is implementing complex selections for
// SelectionModel.
type Bitset struct {
	native C.GtkBitset
}

// WrapBitset wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapBitset(ptr unsafe.Pointer) *Bitset {
	if ptr == nil {
		return nil
	}

	return (*Bitset)(ptr)
}

func marshalBitset(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapBitset(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (b *Bitset) Native() unsafe.Pointer {
	return unsafe.Pointer(&b.native)
}

// NewBitsetEmpty constructs a struct Bitset.
func NewBitsetEmpty() *Bitset {

	ret := C.gtk_bitset_new_empty()

	var ret0 *Bitset

	ret0 = WrapBitset(ret)

	return ret0
}

// NewBitsetRange constructs a struct Bitset.
func NewBitsetRange(start uint, nItems uint) *Bitset {
	var arg1 C.guint
	var arg2 C.guint

	arg1 = C.guint(start)
	arg2 = C.guint(nItems)

	ret := C.gtk_bitset_new_range(arg1, arg2)

	var ret0 *Bitset

	ret0 = WrapBitset(ret)

	return ret0
}

// BitsetIter: an opaque, stack-allocated struct for iterating over the elements
// of a Bitset. Before a GtkBitsetIter can be used, it needs to be initialized
// with gtk_bitset_iter_init_first(), gtk_bitset_iter_init_last() or
// gtk_bitset_iter_init_at().
type BitsetIter struct {
	native C.GtkBitsetIter
}

// WrapBitsetIter wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapBitsetIter(ptr unsafe.Pointer) *BitsetIter {
	if ptr == nil {
		return nil
	}

	return (*BitsetIter)(ptr)
}

func marshalBitsetIter(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapBitsetIter(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (b *BitsetIter) Native() unsafe.Pointer {
	return unsafe.Pointer(&b.native)
}

// Border: a struct that specifies a border around a rectangular area that can
// be of different width on each side.
type Border struct {
	native C.GtkBorder
}

// WrapBorder wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapBorder(ptr unsafe.Pointer) *Border {
	if ptr == nil {
		return nil
	}

	return (*Border)(ptr)
}

func marshalBorder(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapBorder(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (b *Border) Native() unsafe.Pointer {
	return unsafe.Pointer(&b.native)
}

// NewBorder constructs a struct Border.
func NewBorder() *Border {

	ret := C.gtk_border_new()

	var ret0 *Border

	ret0 = WrapBorder(ret)

	return ret0
}

// Left gets the field inside the struct.
func (l *Border) Left() int16 {
	var ret int16
	ret = int16(b.native.left)
	return ret
}

// Right gets the field inside the struct.
func (r *Border) Right() int16 {
	var ret int16
	ret = int16(b.native.right)
	return ret
}

// Top gets the field inside the struct.
func (t *Border) Top() int16 {
	var ret int16
	ret = int16(b.native.top)
	return ret
}

// Bottom gets the field inside the struct.
func (b *Border) Bottom() int16 {
	var ret int16
	ret = int16(b.native.bottom)
	return ret
}

// CSSLocation is used to present a location in a file - or other source of data
// parsed by the CSS engine.
//
// The @bytes and @line_bytes offsets are meant to be used to programmatically
// match data. The @lines and @line_chars offsets can be used for printing the
// location in a file.
//
// Note that the @lines parameter starts from 0 and is increased whenever a CSS
// line break is encountered. (CSS defines the C character sequences "\r\n",
// "\r", "\n" and "\f" as newlines.) If your document uses different rules for
// line breaking, you might want run into problems here.
type CSSLocation struct {
	native C.GtkCssLocation
}

// WrapCSSLocation wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapCSSLocation(ptr unsafe.Pointer) *CSSLocation {
	if ptr == nil {
		return nil
	}

	return (*CSSLocation)(ptr)
}

func marshalCSSLocation(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapCSSLocation(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (c *CSSLocation) Native() unsafe.Pointer {
	return unsafe.Pointer(&c.native)
}

// Bytes gets the field inside the struct.
func (b *CSSLocation) Bytes() uint {
	var ret uint
	ret = uint(c.native.bytes)
	return ret
}

// Chars gets the field inside the struct.
func (c *CSSLocation) Chars() uint {
	var ret uint
	ret = uint(c.native.chars)
	return ret
}

// Lines gets the field inside the struct.
func (l *CSSLocation) Lines() uint {
	var ret uint
	ret = uint(c.native.lines)
	return ret
}

// LineBytes gets the field inside the struct.
func (l *CSSLocation) LineBytes() uint {
	var ret uint
	ret = uint(c.native.line_bytes)
	return ret
}

// LineChars gets the field inside the struct.
func (l *CSSLocation) LineChars() uint {
	var ret uint
	ret = uint(c.native.line_chars)
	return ret
}

// CSSSection defines a part of a CSS document. Because sections are nested into
// one another, you can use gtk_css_section_get_parent() to get the containing
// region.
type CSSSection struct {
	native C.GtkCssSection
}

// WrapCSSSection wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapCSSSection(ptr unsafe.Pointer) *CSSSection {
	if ptr == nil {
		return nil
	}

	return (*CSSSection)(ptr)
}

func marshalCSSSection(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapCSSSection(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (c *CSSSection) Native() unsafe.Pointer {
	return unsafe.Pointer(&c.native)
}

// NewCSSSection constructs a struct CSSSection.
func NewCSSSection(file gio.File, start *CSSLocation, end *CSSLocation) *CSSSection {
	var arg1 *C.GFile
	var arg2 *C.GtkCssLocation
	var arg3 *C.GtkCssLocation

	arg2 = (*C.GtkCssLocation)(start.Native())
	arg3 = (*C.GtkCssLocation)(end.Native())

	ret := C.gtk_css_section_new(arg1, arg2, arg3)

	var ret0 *CSSSection

	ret0 = WrapCSSSection(ret)

	return ret0
}

// PadActionEntry: struct defining a pad action entry.
type PadActionEntry struct {
	native C.GtkPadActionEntry
}

// WrapPadActionEntry wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapPadActionEntry(ptr unsafe.Pointer) *PadActionEntry {
	if ptr == nil {
		return nil
	}

	return (*PadActionEntry)(ptr)
}

func marshalPadActionEntry(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapPadActionEntry(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (p *PadActionEntry) Native() unsafe.Pointer {
	return unsafe.Pointer(&p.native)
}

// Type gets the field inside the struct.
func (t *PadActionEntry) Type() PadActionType {
	var ret PadActionType
	ret = PadActionType(p.native._type)
	return ret
}

// Index gets the field inside the struct.
func (i *PadActionEntry) Index() int {
	var ret int
	ret = int(p.native.index)
	return ret
}

// Mode gets the field inside the struct.
func (m *PadActionEntry) Mode() int {
	var ret int
	ret = int(p.native.mode)
	return ret
}

// Label gets the field inside the struct.
func (l *PadActionEntry) Label() string {
	var ret string
	ret = C.GoString(p.native.label)
	return ret
}

// ActionName gets the field inside the struct.
func (a *PadActionEntry) ActionName() string {
	var ret string
	ret = C.GoString(p.native.action_name)
	return ret
}

// PageRange: see also gtk_print_settings_set_page_ranges().
type PageRange struct {
	native C.GtkPageRange
}

// WrapPageRange wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapPageRange(ptr unsafe.Pointer) *PageRange {
	if ptr == nil {
		return nil
	}

	return (*PageRange)(ptr)
}

func marshalPageRange(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapPageRange(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (p *PageRange) Native() unsafe.Pointer {
	return unsafe.Pointer(&p.native)
}

// Start gets the field inside the struct.
func (s *PageRange) Start() int {
	var ret int
	ret = int(p.native.start)
	return ret
}

// End gets the field inside the struct.
func (e *PageRange) End() int {
	var ret int
	ret = int(p.native.end)
	return ret
}

// PaperSize: gtkPaperSize handles paper sizes. It uses the standard called PWG
// 5101.1-2002 PWG: Standard for Media Standardized Names
// (http://www.pwg.org/standards.html) to name the paper sizes (and to get the
// data for the page sizes). In addition to standard paper sizes, GtkPaperSize
// allows to construct custom paper sizes with arbitrary dimensions.
//
// The PaperSize object stores not only the dimensions (width and height) of a
// paper size and its name, it also provides default [print
// margins][print-margins].
type PaperSize struct {
	native C.GtkPaperSize
}

// WrapPaperSize wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapPaperSize(ptr unsafe.Pointer) *PaperSize {
	if ptr == nil {
		return nil
	}

	return (*PaperSize)(ptr)
}

func marshalPaperSize(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapPaperSize(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (p *PaperSize) Native() unsafe.Pointer {
	return unsafe.Pointer(&p.native)
}

// NewPaperSize constructs a struct PaperSize.
func NewPaperSize(name string) *PaperSize {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_paper_size_new(arg1)

	var ret0 *PaperSize

	ret0 = WrapPaperSize(ret)

	return ret0
}

// NewPaperSizeCustom constructs a struct PaperSize.
func NewPaperSizeCustom(name string, displayName string, width float64, height float64, unit Unit) *PaperSize {
	var arg1 *C.char
	var arg2 *C.char
	var arg3 C.double
	var arg4 C.double
	var arg5 C.GtkUnit

	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(displayName))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = C.double(width)
	arg4 = C.double(height)
	arg5 = (C.GtkUnit)(unit)

	ret := C.gtk_paper_size_new_custom(arg1, arg2, arg3, arg4, arg5)

	var ret0 *PaperSize

	ret0 = WrapPaperSize(ret)

	return ret0
}

// NewPaperSizeFromGvariant constructs a struct PaperSize.
func NewPaperSizeFromGvariant(variant *glib.Variant) *PaperSize {
	var arg1 *C.GVariant

	arg1 = (*C.GVariant)(variant.Native())

	ret := C.gtk_paper_size_new_from_gvariant(arg1)

	var ret0 *PaperSize

	ret0 = WrapPaperSize(ret)

	return ret0
}

// NewPaperSizeFromIpp constructs a struct PaperSize.
func NewPaperSizeFromIpp(ippName string, width float64, height float64) *PaperSize {
	var arg1 *C.char
	var arg2 C.double
	var arg3 C.double

	arg1 = (*C.gchar)(C.CString(ippName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.double(width)
	arg3 = C.double(height)

	ret := C.gtk_paper_size_new_from_ipp(arg1, arg2, arg3)

	var ret0 *PaperSize

	ret0 = WrapPaperSize(ret)

	return ret0
}

// NewPaperSizeFromKeyFile constructs a struct PaperSize.
func NewPaperSizeFromKeyFile(keyFile *glib.KeyFile, groupName string) *PaperSize {
	var arg1 *C.GKeyFile
	var arg2 *C.char

	arg1 = (*C.GKeyFile)(keyFile.Native())
	arg2 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.gtk_paper_size_new_from_key_file(arg1, arg2)

	var ret0 *PaperSize

	ret0 = WrapPaperSize(ret)

	return ret0
}

// NewPaperSizeFromPpd constructs a struct PaperSize.
func NewPaperSizeFromPpd(ppdName string, ppdDisplayName string, width float64, height float64) *PaperSize {
	var arg1 *C.char
	var arg2 *C.char
	var arg3 C.double
	var arg4 C.double

	arg1 = (*C.gchar)(C.CString(ppdName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(ppdDisplayName))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = C.double(width)
	arg4 = C.double(height)

	ret := C.gtk_paper_size_new_from_ppd(arg1, arg2, arg3, arg4)

	var ret0 *PaperSize

	ret0 = WrapPaperSize(ret)

	return ret0
}

// RecentData: meta-data to be passed to gtk_recent_manager_add_full() when
// registering a recently used resource.
type RecentData struct {
	native C.GtkRecentData
}

// WrapRecentData wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapRecentData(ptr unsafe.Pointer) *RecentData {
	if ptr == nil {
		return nil
	}

	return (*RecentData)(ptr)
}

func marshalRecentData(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapRecentData(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (r *RecentData) Native() unsafe.Pointer {
	return unsafe.Pointer(&r.native)
}

// DisplayName gets the field inside the struct.
func (d *RecentData) DisplayName() string {
	var ret string
	ret = C.GoString(r.native.display_name)
	return ret
}

// Description gets the field inside the struct.
func (d *RecentData) Description() string {
	var ret string
	ret = C.GoString(r.native.description)
	return ret
}

// MIMEType gets the field inside the struct.
func (m *RecentData) MIMEType() string {
	var ret string
	ret = C.GoString(r.native.mime_type)
	return ret
}

// AppName gets the field inside the struct.
func (a *RecentData) AppName() string {
	var ret string
	ret = C.GoString(r.native.app_name)
	return ret
}

// AppExec gets the field inside the struct.
func (a *RecentData) AppExec() string {
	var ret string
	ret = C.GoString(r.native.app_exec)
	return ret
}

// Groups gets the field inside the struct.
func (g *RecentData) Groups() []string {
	var ret []string
	{
		var length uint
		for p := unsafe.Pointer(r.native.groups); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret = make([]string, length)
		for i := 0; i < length; i++ {
			src := (*C.gchar)(unsafe.Pointer(uintptr(unsafe.Pointer(r.native.groups)) + i))
			ret[i] = C.GoString(src)
		}
	}
	return ret
}

// IsPrivate gets the field inside the struct.
func (i *RecentData) IsPrivate() bool {
	var ret bool
	ret = gextras.Gobool(r.native.is_private)
	return ret
}

// RecentInfo contains private data only, and should be accessed using the
// provided API.
//
// RecentInfo contains all the meta-data associated with an entry in the
// recently used files list.
type RecentInfo struct {
	native C.GtkRecentInfo
}

// WrapRecentInfo wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapRecentInfo(ptr unsafe.Pointer) *RecentInfo {
	if ptr == nil {
		return nil
	}

	return (*RecentInfo)(ptr)
}

func marshalRecentInfo(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapRecentInfo(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (r *RecentInfo) Native() unsafe.Pointer {
	return unsafe.Pointer(&r.native)
}

// RequestedSize represents a request of a screen object in a given orientation.
// These are primarily used in container implementations when allocating a
// natural size for children calling. See gtk_distribute_natural_allocation().
type RequestedSize struct {
	native C.GtkRequestedSize
}

// WrapRequestedSize wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapRequestedSize(ptr unsafe.Pointer) *RequestedSize {
	if ptr == nil {
		return nil
	}

	return (*RequestedSize)(ptr)
}

func marshalRequestedSize(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapRequestedSize(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (r *RequestedSize) Native() unsafe.Pointer {
	return unsafe.Pointer(&r.native)
}

// Data gets the field inside the struct.
func (d *RequestedSize) Data() interface{} {
	var ret interface{}
	ret = box.Get(uintptr(r.native.data))
	return ret
}

// MinimumSize gets the field inside the struct.
func (m *RequestedSize) MinimumSize() int {
	var ret int
	ret = int(r.native.minimum_size)
	return ret
}

// NaturalSize gets the field inside the struct.
func (n *RequestedSize) NaturalSize() int {
	var ret int
	ret = int(r.native.natural_size)
	return ret
}

// Requisition: a Requisition-struct represents the desired size of a widget.
// See [GtkWidget’s geometry management section][geometry-management] for more
// information.
type Requisition struct {
	native C.GtkRequisition
}

// WrapRequisition wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapRequisition(ptr unsafe.Pointer) *Requisition {
	if ptr == nil {
		return nil
	}

	return (*Requisition)(ptr)
}

func marshalRequisition(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapRequisition(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (r *Requisition) Native() unsafe.Pointer {
	return unsafe.Pointer(&r.native)
}

// NewRequisition constructs a struct Requisition.
func NewRequisition() *Requisition {

	ret := C.gtk_requisition_new()

	var ret0 *Requisition

	ret0 = WrapRequisition(ret)

	return ret0
}

// Width gets the field inside the struct.
func (w *Requisition) Width() int {
	var ret int
	ret = int(r.native.width)
	return ret
}

// Height gets the field inside the struct.
func (h *Requisition) Height() int {
	var ret int
	ret = int(r.native.height)
	return ret
}

type SettingsValue struct {
	native C.GtkSettingsValue
}

// WrapSettingsValue wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapSettingsValue(ptr unsafe.Pointer) *SettingsValue {
	if ptr == nil {
		return nil
	}

	return (*SettingsValue)(ptr)
}

func marshalSettingsValue(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapSettingsValue(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (s *SettingsValue) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

// Origin gets the field inside the struct.
func (o *SettingsValue) Origin() string {
	var ret string
	ret = C.GoString(s.native.origin)
	return ret
}

// TextIter: you may wish to begin by reading the [text widget conceptual
// overview][TextWidget] which gives an overview of all the objects and data
// types related to the text widget and how they work together.
type TextIter struct {
	native C.GtkTextIter
}

// WrapTextIter wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTextIter(ptr unsafe.Pointer) *TextIter {
	if ptr == nil {
		return nil
	}

	return (*TextIter)(ptr)
}

func marshalTextIter(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapTextIter(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (t *TextIter) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

// TreeIter: the TreeIter is the primary structure for accessing a TreeModel.
// Models are expected to put a unique integer in the @stamp member, and put
// model-specific data in the three @user_data members.
type TreeIter struct {
	native C.GtkTreeIter
}

// WrapTreeIter wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTreeIter(ptr unsafe.Pointer) *TreeIter {
	if ptr == nil {
		return nil
	}

	return (*TreeIter)(ptr)
}

func marshalTreeIter(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapTreeIter(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (t *TreeIter) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

// Stamp gets the field inside the struct.
func (s *TreeIter) Stamp() int {
	var ret int
	ret = int(t.native.stamp)
	return ret
}

// UserData gets the field inside the struct.
func (u *TreeIter) UserData() interface{} {
	var ret interface{}
	ret = box.Get(uintptr(t.native.user_data))
	return ret
}

// UserData2 gets the field inside the struct.
func (u *TreeIter) UserData2() interface{} {
	var ret interface{}
	ret = box.Get(uintptr(t.native.user_data2))
	return ret
}

// UserData3 gets the field inside the struct.
func (u *TreeIter) UserData3() interface{} {
	var ret interface{}
	ret = box.Get(uintptr(t.native.user_data3))
	return ret
}

type TreePath struct {
	native C.GtkTreePath
}

// WrapTreePath wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTreePath(ptr unsafe.Pointer) *TreePath {
	if ptr == nil {
		return nil
	}

	return (*TreePath)(ptr)
}

func marshalTreePath(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapTreePath(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (t *TreePath) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

// NewTreePath constructs a struct TreePath.
func NewTreePath() *TreePath {

	ret := C.gtk_tree_path_new()

	var ret0 *TreePath

	ret0 = WrapTreePath(ret)

	return ret0
}

// NewTreePathFirst constructs a struct TreePath.
func NewTreePathFirst() *TreePath {

	ret := C.gtk_tree_path_new_first()

	var ret0 *TreePath

	ret0 = WrapTreePath(ret)

	return ret0
}

// NewTreePathFromIndicesv constructs a struct TreePath.
func NewTreePathFromIndicesv(indices []int) *TreePath {
	var arg1 *C.int
	var arg2 C.gsize

	{
		arg1 = (*C.int)(&indices[0])
		arg2 = len(indices)
		defer runtime.KeepAlive(indices)
	}

	ret := C.gtk_tree_path_new_from_indicesv(arg1, arg2)

	var ret0 *TreePath

	ret0 = WrapTreePath(ret)

	return ret0
}

// NewTreePathFromString constructs a struct TreePath.
func NewTreePathFromString(path string) *TreePath {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_tree_path_new_from_string(arg1)

	var ret0 *TreePath

	ret0 = WrapTreePath(ret)

	return ret0
}

// TreeRowReference: a GtkTreeRowReference tracks model changes so that it
// always refers to the same row (a TreePath refers to a position, not a fixed
// row). Create a new GtkTreeRowReference with gtk_tree_row_reference_new().
type TreeRowReference struct {
	native C.GtkTreeRowReference
}

// WrapTreeRowReference wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTreeRowReference(ptr unsafe.Pointer) *TreeRowReference {
	if ptr == nil {
		return nil
	}

	return (*TreeRowReference)(ptr)
}

func marshalTreeRowReference(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapTreeRowReference(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (t *TreeRowReference) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

// NewTreeRowReference constructs a struct TreeRowReference.
func NewTreeRowReference(model TreeModel, path *TreePath) *TreeRowReference {
	var arg1 *C.GtkTreeModel
	var arg2 *C.GtkTreePath

	arg2 = (*C.GtkTreePath)(path.Native())

	ret := C.gtk_tree_row_reference_new(arg1, arg2)

	var ret0 *TreeRowReference

	ret0 = WrapTreeRowReference(ret)

	return ret0
}

// NewTreeRowReferenceProxy constructs a struct TreeRowReference.
func NewTreeRowReferenceProxy(proxy gextras.Objector, model TreeModel, path *TreePath) *TreeRowReference {
	var arg1 *C.GObject
	var arg2 *C.GtkTreeModel
	var arg3 *C.GtkTreePath

	arg1 = (*C.GObject)(proxy.Native())
	arg3 = (*C.GtkTreePath)(path.Native())

	ret := C.gtk_tree_row_reference_new_proxy(arg1, arg2, arg3)

	var ret0 *TreeRowReference

	ret0 = WrapTreeRowReference(ret)

	return ret0
}

// ATContext: gtkATContext is an abstract class provided by GTK to communicate
// to platform-specific assistive technologies API.
//
// Each platform supported by GTK implements a ATContext subclass, and is
// responsible for updating the accessible state in response to state changes in
// Accessible.
type ATContext interface {
	gextras.Objector

	// Accessible retrieves the Accessible using this context.
	Accessible() Accessible
	// AccessibleRole retrieves the accessible role of this context.
	AccessibleRole() AccessibleRole
}

type atContext struct {
	*externglib.Object
}

// WrapATContext wraps a GObject to the right type. It is
// primarily used internally.
func WrapATContext(obj *externglib.Object) ATContext {
	return atContext{*externglib.Object{obj}}
}

func marshalATContext(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapATContext(obj), nil
}

// NewATContextCreate constructs a class ATContext.
func NewATContextCreate(accessibleRole AccessibleRole, accessible Accessible, display gdk.Display) ATContext {
	var arg1 C.GtkAccessibleRole
	var arg2 *C.GtkAccessible
	var arg3 *C.GdkDisplay

	arg1 = (C.GtkAccessibleRole)(accessibleRole)
	arg3 = (*C.GdkDisplay)(display.Native())

	ret := C.gtk_at_context_create(arg1, arg2, arg3)

	var ret0 ATContext

	ret0 = WrapATContext(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Accessible retrieves the Accessible using this context.
func (self atContext) Accessible() Accessible {
	var arg0 *C.GtkATContext

	arg0 = (*C.GtkATContext)(self.Native())

	ret := C.gtk_at_context_get_accessible(arg0)

	var ret0 Accessible

	return ret0
}

// AccessibleRole retrieves the accessible role of this context.
func (self atContext) AccessibleRole() AccessibleRole {
	var arg0 *C.GtkATContext

	arg0 = (*C.GtkATContext)(self.Native())

	ret := C.gtk_at_context_get_accessible_role(arg0)

	var ret0 AccessibleRole

	ret0 = AccessibleRole(ret)

	return ret0
}

// AboutDialog: the GtkAboutDialog offers a simple way to display information
// about a program like its logo, name, copyright, website and license. It is
// also possible to give credits to the authors, documenters, translators and
// artists who have worked on the program. An about dialog is typically opened
// when the user selects the `About` option from the `Help` menu. All parts of
// the dialog are optional.
//
// About dialogs often contain links and email addresses. GtkAboutDialog
// displays these as clickable links. By default, it calls gtk_show_uri() when a
// user clicks one. The behaviour can be overridden with the
// AboutDialog::activate-link signal.
//
// To specify a person with an email address, use a string like "Edgar Allan Poe
// <edgar\@poe.com>". To specify a website with a title, use a string like "GTK
// team http://www.gtk.org".
//
// To make constructing a GtkAboutDialog as convenient as possible, you can use
// the function gtk_show_about_dialog() which constructs and shows a dialog and
// keeps it around so that it can be shown again.
//
// Note that GTK sets a default title of `_("About s")` on the dialog window
// (where \s is replaced by the name of the application, but in order to ensure
// proper translation of the title, applications should set the title property
// explicitly when constructing a GtkAboutDialog, as shown in the following
// example:
//
//    GFile *logo_file = g_file_new_for_path ("./logo.png");
//    GdkTexture *example_logo = gdk_texture_new_from_file (logo_file, NULL);
//    g_object_unref (logo_file);
//
//    gtk_show_about_dialog (NULL,
//                           "program-name", "ExampleCode",
//                           "logo", example_logo,
//                           "title", _("About ExampleCode"),
//                           NULL);
//
//
//
// CSS nodes
//
// GtkAboutDialog has a single CSS node with the name window and style class
// .aboutdialog.
type AboutDialog interface {
	Window

	// AddCreditSection creates a new section in the Credits page.
	AddCreditSection(sectionName string, people []string)
	// Artists returns the string which are displayed in the artists tab of the
	// secondary credits dialog.
	Artists() []string
	// Authors returns the string which are displayed in the authors tab of the
	// secondary credits dialog.
	Authors() []string
	// Comments returns the comments string.
	Comments() string
	// Copyright returns the copyright string.
	Copyright() string
	// Documenters returns the string which are displayed in the documenters tab
	// of the secondary credits dialog.
	Documenters() []string
	// License returns the license information.
	License() string
	// LicenseType retrieves the license set using
	// gtk_about_dialog_set_license_type()
	LicenseType() License
	// Logo returns the paintable displayed as logo in the about dialog.
	Logo() gdk.Paintable
	// LogoIconName returns the icon name displayed as logo in the about dialog.
	LogoIconName() string
	// ProgramName returns the program name displayed in the about dialog.
	ProgramName() string
	// SystemInformation returns the system information that is shown in the
	// about dialog.
	SystemInformation() string
	// TranslatorCredits returns the translator credits string which is
	// displayed in the translators tab of the secondary credits dialog.
	TranslatorCredits() string
	// Version returns the version string.
	Version() string
	// Website returns the website URL.
	Website() string
	// WebsiteLabel returns the label used for the website link.
	WebsiteLabel() string
	// WrapLicense returns whether the license text in @about is automatically
	// wrapped.
	WrapLicense() bool
	// SetArtists sets the strings which are displayed in the artists tab of the
	// secondary credits dialog.
	SetArtists(artists []string)
	// SetAuthors sets the strings which are displayed in the authors tab of the
	// secondary credits dialog.
	SetAuthors(authors []string)
	// SetComments sets the comments string to display in the about dialog. This
	// should be a short string of one or two lines.
	SetComments(comments string)
	// SetCopyright sets the copyright string to display in the about dialog.
	// This should be a short string of one or two lines.
	SetCopyright(copyright string)
	// SetDocumenters sets the strings which are displayed in the documenters
	// tab of the credits dialog.
	SetDocumenters(documenters []string)
	// SetLicense sets the license information to be displayed in the secondary
	// license dialog. If @license is nil, the license button is hidden.
	SetLicense(license string)
	// SetLicenseType sets the license of the application showing the @about
	// dialog from a list of known licenses.
	//
	// This function overrides the license set using
	// gtk_about_dialog_set_license().
	SetLicenseType(licenseType License)
	// SetLogo sets the logo in the about dialog.
	SetLogo(logo gdk.Paintable)
	// SetLogoIconName sets the icon name to be displayed as logo in the about
	// dialog.
	SetLogoIconName(iconName string)
	// SetProgramName sets the name to display in the about dialog. If this is
	// not set, it defaults to g_get_application_name().
	SetProgramName(name string)
	// SetSystemInformation sets the system information to be displayed in the
	// about dialog. If @system_information is nil, the system information tab
	// is hidden.
	//
	// See AboutDialog:system-information.
	SetSystemInformation(systemInformation string)
	// SetTranslatorCredits sets the translator credits string which is
	// displayed in the translators tab of the secondary credits dialog.
	//
	// The intended use for this string is to display the translator of the
	// language which is currently used in the user interface. Using gettext(),
	// a simple way to achieve that is to mark the string for translation:
	//
	//    GtkWidget *about = gtk_about_dialog_new ();
	//     gtk_about_dialog_set_translator_credits (GTK_ABOUT_DIALOG (about),
	//                                              _("translator-credits"));
	//
	//
	// It is a good idea to use the customary msgid “translator-credits” for
	// this purpose, since translators will already know the purpose of that
	// msgid, and since AboutDialog will detect if “translator-credits” is
	// untranslated and hide the tab.
	SetTranslatorCredits(translatorCredits string)
	// SetVersion sets the version string to display in the about dialog.
	SetVersion(version string)
	// SetWebsite sets the URL to use for the website link.
	SetWebsite(website string)
	// SetWebsiteLabel sets the label to be used for the website link.
	SetWebsiteLabel(websiteLabel string)
	// SetWrapLicense sets whether the license text in @about is automatically
	// wrapped.
	SetWrapLicense(wrapLicense bool)
}

type aboutDialog struct {
	window
}

// WrapAboutDialog wraps a GObject to the right type. It is
// primarily used internally.
func WrapAboutDialog(obj *externglib.Object) AboutDialog {
	return aboutDialog{window{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}}
}

func marshalAboutDialog(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapAboutDialog(obj), nil
}

// NewAboutDialog constructs a class AboutDialog.
func NewAboutDialog() AboutDialog {

	ret := C.gtk_about_dialog_new()

	var ret0 AboutDialog

	ret0 = WrapAboutDialog(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// AddCreditSection creates a new section in the Credits page.
func (about aboutDialog) AddCreditSection(sectionName string, people []string) {
	var arg0 *C.GtkAboutDialog
	var arg1 *C.char
	var arg2 **C.char

	arg0 = (*C.GtkAboutDialog)(about.Native())
	arg1 = (*C.gchar)(C.CString(sectionName))
	defer C.free(unsafe.Pointer(arg1))
	{

	}

	C.gtk_about_dialog_add_credit_section(arg0, arg1, arg2)
}

// Artists returns the string which are displayed in the artists tab of the
// secondary credits dialog.
func (about aboutDialog) Artists() []string {
	var arg0 *C.GtkAboutDialog

	arg0 = (*C.GtkAboutDialog)(about.Native())

	ret := C.gtk_about_dialog_get_artists(arg0)

	var ret0 []string

	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]string, length)
		for i := 0; i < length; i++ {
			src := (C.utf8)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			ret0[i] = C.GoString(src)
		}
	}

	return ret0
}

// Authors returns the string which are displayed in the authors tab of the
// secondary credits dialog.
func (about aboutDialog) Authors() []string {
	var arg0 *C.GtkAboutDialog

	arg0 = (*C.GtkAboutDialog)(about.Native())

	ret := C.gtk_about_dialog_get_authors(arg0)

	var ret0 []string

	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]string, length)
		for i := 0; i < length; i++ {
			src := (C.utf8)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			ret0[i] = C.GoString(src)
		}
	}

	return ret0
}

// Comments returns the comments string.
func (about aboutDialog) Comments() string {
	var arg0 *C.GtkAboutDialog

	arg0 = (*C.GtkAboutDialog)(about.Native())

	ret := C.gtk_about_dialog_get_comments(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Copyright returns the copyright string.
func (about aboutDialog) Copyright() string {
	var arg0 *C.GtkAboutDialog

	arg0 = (*C.GtkAboutDialog)(about.Native())

	ret := C.gtk_about_dialog_get_copyright(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Documenters returns the string which are displayed in the documenters tab
// of the secondary credits dialog.
func (about aboutDialog) Documenters() []string {
	var arg0 *C.GtkAboutDialog

	arg0 = (*C.GtkAboutDialog)(about.Native())

	ret := C.gtk_about_dialog_get_documenters(arg0)

	var ret0 []string

	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]string, length)
		for i := 0; i < length; i++ {
			src := (C.utf8)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			ret0[i] = C.GoString(src)
		}
	}

	return ret0
}

// License returns the license information.
func (about aboutDialog) License() string {
	var arg0 *C.GtkAboutDialog

	arg0 = (*C.GtkAboutDialog)(about.Native())

	ret := C.gtk_about_dialog_get_license(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// LicenseType retrieves the license set using
// gtk_about_dialog_set_license_type()
func (about aboutDialog) LicenseType() License {
	var arg0 *C.GtkAboutDialog

	arg0 = (*C.GtkAboutDialog)(about.Native())

	ret := C.gtk_about_dialog_get_license_type(arg0)

	var ret0 License

	ret0 = License(ret)

	return ret0
}

// Logo returns the paintable displayed as logo in the about dialog.
func (about aboutDialog) Logo() gdk.Paintable {
	var arg0 *C.GtkAboutDialog

	arg0 = (*C.GtkAboutDialog)(about.Native())

	ret := C.gtk_about_dialog_get_logo(arg0)

	var ret0 gdk.Paintable

	return ret0
}

// LogoIconName returns the icon name displayed as logo in the about dialog.
func (about aboutDialog) LogoIconName() string {
	var arg0 *C.GtkAboutDialog

	arg0 = (*C.GtkAboutDialog)(about.Native())

	ret := C.gtk_about_dialog_get_logo_icon_name(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// ProgramName returns the program name displayed in the about dialog.
func (about aboutDialog) ProgramName() string {
	var arg0 *C.GtkAboutDialog

	arg0 = (*C.GtkAboutDialog)(about.Native())

	ret := C.gtk_about_dialog_get_program_name(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// SystemInformation returns the system information that is shown in the
// about dialog.
func (about aboutDialog) SystemInformation() string {
	var arg0 *C.GtkAboutDialog

	arg0 = (*C.GtkAboutDialog)(about.Native())

	ret := C.gtk_about_dialog_get_system_information(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// TranslatorCredits returns the translator credits string which is
// displayed in the translators tab of the secondary credits dialog.
func (about aboutDialog) TranslatorCredits() string {
	var arg0 *C.GtkAboutDialog

	arg0 = (*C.GtkAboutDialog)(about.Native())

	ret := C.gtk_about_dialog_get_translator_credits(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Version returns the version string.
func (about aboutDialog) Version() string {
	var arg0 *C.GtkAboutDialog

	arg0 = (*C.GtkAboutDialog)(about.Native())

	ret := C.gtk_about_dialog_get_version(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Website returns the website URL.
func (about aboutDialog) Website() string {
	var arg0 *C.GtkAboutDialog

	arg0 = (*C.GtkAboutDialog)(about.Native())

	ret := C.gtk_about_dialog_get_website(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// WebsiteLabel returns the label used for the website link.
func (about aboutDialog) WebsiteLabel() string {
	var arg0 *C.GtkAboutDialog

	arg0 = (*C.GtkAboutDialog)(about.Native())

	ret := C.gtk_about_dialog_get_website_label(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// WrapLicense returns whether the license text in @about is automatically
// wrapped.
func (about aboutDialog) WrapLicense() bool {
	var arg0 *C.GtkAboutDialog

	arg0 = (*C.GtkAboutDialog)(about.Native())

	ret := C.gtk_about_dialog_get_wrap_license(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// SetArtists sets the strings which are displayed in the artists tab of the
// secondary credits dialog.
func (about aboutDialog) SetArtists(artists []string) {
	var arg0 *C.GtkAboutDialog
	var arg1 **C.char

	arg0 = (*C.GtkAboutDialog)(about.Native())
	{

	}

	C.gtk_about_dialog_set_artists(arg0, arg1)
}

// SetAuthors sets the strings which are displayed in the authors tab of the
// secondary credits dialog.
func (about aboutDialog) SetAuthors(authors []string) {
	var arg0 *C.GtkAboutDialog
	var arg1 **C.char

	arg0 = (*C.GtkAboutDialog)(about.Native())
	{

	}

	C.gtk_about_dialog_set_authors(arg0, arg1)
}

// SetComments sets the comments string to display in the about dialog. This
// should be a short string of one or two lines.
func (about aboutDialog) SetComments(comments string) {
	var arg0 *C.GtkAboutDialog
	var arg1 *C.char

	arg0 = (*C.GtkAboutDialog)(about.Native())
	arg1 = (*C.gchar)(C.CString(comments))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_about_dialog_set_comments(arg0, arg1)
}

// SetCopyright sets the copyright string to display in the about dialog.
// This should be a short string of one or two lines.
func (about aboutDialog) SetCopyright(copyright string) {
	var arg0 *C.GtkAboutDialog
	var arg1 *C.char

	arg0 = (*C.GtkAboutDialog)(about.Native())
	arg1 = (*C.gchar)(C.CString(copyright))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_about_dialog_set_copyright(arg0, arg1)
}

// SetDocumenters sets the strings which are displayed in the documenters
// tab of the credits dialog.
func (about aboutDialog) SetDocumenters(documenters []string) {
	var arg0 *C.GtkAboutDialog
	var arg1 **C.char

	arg0 = (*C.GtkAboutDialog)(about.Native())
	{

	}

	C.gtk_about_dialog_set_documenters(arg0, arg1)
}

// SetLicense sets the license information to be displayed in the secondary
// license dialog. If @license is nil, the license button is hidden.
func (about aboutDialog) SetLicense(license string) {
	var arg0 *C.GtkAboutDialog
	var arg1 *C.char

	arg0 = (*C.GtkAboutDialog)(about.Native())
	arg1 = (*C.gchar)(C.CString(license))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_about_dialog_set_license(arg0, arg1)
}

// SetLicenseType sets the license of the application showing the @about
// dialog from a list of known licenses.
//
// This function overrides the license set using
// gtk_about_dialog_set_license().
func (about aboutDialog) SetLicenseType(licenseType License) {
	var arg0 *C.GtkAboutDialog
	var arg1 C.GtkLicense

	arg0 = (*C.GtkAboutDialog)(about.Native())
	arg1 = (C.GtkLicense)(licenseType)

	C.gtk_about_dialog_set_license_type(arg0, arg1)
}

// SetLogo sets the logo in the about dialog.
func (about aboutDialog) SetLogo(logo gdk.Paintable) {
	var arg0 *C.GtkAboutDialog
	var arg1 *C.GdkPaintable

	arg0 = (*C.GtkAboutDialog)(about.Native())

	C.gtk_about_dialog_set_logo(arg0, arg1)
}

// SetLogoIconName sets the icon name to be displayed as logo in the about
// dialog.
func (about aboutDialog) SetLogoIconName(iconName string) {
	var arg0 *C.GtkAboutDialog
	var arg1 *C.char

	arg0 = (*C.GtkAboutDialog)(about.Native())
	arg1 = (*C.gchar)(C.CString(iconName))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_about_dialog_set_logo_icon_name(arg0, arg1)
}

// SetProgramName sets the name to display in the about dialog. If this is
// not set, it defaults to g_get_application_name().
func (about aboutDialog) SetProgramName(name string) {
	var arg0 *C.GtkAboutDialog
	var arg1 *C.char

	arg0 = (*C.GtkAboutDialog)(about.Native())
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_about_dialog_set_program_name(arg0, arg1)
}

// SetSystemInformation sets the system information to be displayed in the
// about dialog. If @system_information is nil, the system information tab
// is hidden.
//
// See AboutDialog:system-information.
func (about aboutDialog) SetSystemInformation(systemInformation string) {
	var arg0 *C.GtkAboutDialog
	var arg1 *C.char

	arg0 = (*C.GtkAboutDialog)(about.Native())
	arg1 = (*C.gchar)(C.CString(systemInformation))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_about_dialog_set_system_information(arg0, arg1)
}

// SetTranslatorCredits sets the translator credits string which is
// displayed in the translators tab of the secondary credits dialog.
//
// The intended use for this string is to display the translator of the
// language which is currently used in the user interface. Using gettext(),
// a simple way to achieve that is to mark the string for translation:
//
//    GtkWidget *about = gtk_about_dialog_new ();
//     gtk_about_dialog_set_translator_credits (GTK_ABOUT_DIALOG (about),
//                                              _("translator-credits"));
//
//
// It is a good idea to use the customary msgid “translator-credits” for
// this purpose, since translators will already know the purpose of that
// msgid, and since AboutDialog will detect if “translator-credits” is
// untranslated and hide the tab.
func (about aboutDialog) SetTranslatorCredits(translatorCredits string) {
	var arg0 *C.GtkAboutDialog
	var arg1 *C.char

	arg0 = (*C.GtkAboutDialog)(about.Native())
	arg1 = (*C.gchar)(C.CString(translatorCredits))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_about_dialog_set_translator_credits(arg0, arg1)
}

// SetVersion sets the version string to display in the about dialog.
func (about aboutDialog) SetVersion(version string) {
	var arg0 *C.GtkAboutDialog
	var arg1 *C.char

	arg0 = (*C.GtkAboutDialog)(about.Native())
	arg1 = (*C.gchar)(C.CString(version))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_about_dialog_set_version(arg0, arg1)
}

// SetWebsite sets the URL to use for the website link.
func (about aboutDialog) SetWebsite(website string) {
	var arg0 *C.GtkAboutDialog
	var arg1 *C.char

	arg0 = (*C.GtkAboutDialog)(about.Native())
	arg1 = (*C.gchar)(C.CString(website))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_about_dialog_set_website(arg0, arg1)
}

// SetWebsiteLabel sets the label to be used for the website link.
func (about aboutDialog) SetWebsiteLabel(websiteLabel string) {
	var arg0 *C.GtkAboutDialog
	var arg1 *C.char

	arg0 = (*C.GtkAboutDialog)(about.Native())
	arg1 = (*C.gchar)(C.CString(websiteLabel))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_about_dialog_set_website_label(arg0, arg1)
}

// SetWrapLicense sets whether the license text in @about is automatically
// wrapped.
func (about aboutDialog) SetWrapLicense(wrapLicense bool) {
	var arg0 *C.GtkAboutDialog
	var arg1 C.gboolean

	arg0 = (*C.GtkAboutDialog)(about.Native())
	arg1 = gextras.Cbool(wrapLicense)

	C.gtk_about_dialog_set_wrap_license(arg0, arg1)
}

// ActionBar: gtkActionBar is designed to present contextual actions. It is
// expected to be displayed below the content and expand horizontally to fill
// the area.
//
// It allows placing children at the start or the end. In addition, it contains
// an internal centered box which is centered with respect to the full width of
// the box, even if the children at either side take up different amounts of
// space.
//
//
// CSS nodes
//
// GtkActionBar has a single CSS node with name actionbar.
type ActionBar interface {
	Widget

	// CenterWidget retrieves the center bar widget of the bar.
	CenterWidget() Widget
	// Revealed gets the value of the ActionBar:revealed property.
	Revealed() bool
	// PackEnd adds @child to @action_bar, packed with reference to the end of
	// the @action_bar.
	PackEnd(child Widget)
	// PackStart adds @child to @action_bar, packed with reference to the start
	// of the @action_bar.
	PackStart(child Widget)
	// Remove removes a child from @action_bar.
	Remove(child Widget)
	// SetCenterWidget sets the center widget for the ActionBar.
	SetCenterWidget(centerWidget Widget)
	// SetRevealed sets the ActionBar:revealed property to @revealed. Changing
	// this will make @action_bar reveal (true) or conceal (false) itself via a
	// sliding transition.
	//
	// Note: this does not show or hide @action_bar in the Widget:visible sense,
	// so revealing has no effect if Widget:visible is false.
	SetRevealed(revealed bool)
}

type actionBar struct {
	widget
}

// WrapActionBar wraps a GObject to the right type. It is
// primarily used internally.
func WrapActionBar(obj *externglib.Object) ActionBar {
	return actionBar{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}
}

func marshalActionBar(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapActionBar(obj), nil
}

// NewActionBar constructs a class ActionBar.
func NewActionBar() ActionBar {

	ret := C.gtk_action_bar_new()

	var ret0 ActionBar

	ret0 = WrapActionBar(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// CenterWidget retrieves the center bar widget of the bar.
func (actionBar actionBar) CenterWidget() Widget {
	var arg0 *C.GtkActionBar

	arg0 = (*C.GtkActionBar)(actionBar.Native())

	ret := C.gtk_action_bar_get_center_widget(arg0)

	var ret0 Widget

	ret0 = WrapWidget(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Revealed gets the value of the ActionBar:revealed property.
func (actionBar actionBar) Revealed() bool {
	var arg0 *C.GtkActionBar

	arg0 = (*C.GtkActionBar)(actionBar.Native())

	ret := C.gtk_action_bar_get_revealed(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// PackEnd adds @child to @action_bar, packed with reference to the end of
// the @action_bar.
func (actionBar actionBar) PackEnd(child Widget) {
	var arg0 *C.GtkActionBar
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkActionBar)(actionBar.Native())
	arg1 = (*C.GtkWidget)(child.Native())

	C.gtk_action_bar_pack_end(arg0, arg1)
}

// PackStart adds @child to @action_bar, packed with reference to the start
// of the @action_bar.
func (actionBar actionBar) PackStart(child Widget) {
	var arg0 *C.GtkActionBar
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkActionBar)(actionBar.Native())
	arg1 = (*C.GtkWidget)(child.Native())

	C.gtk_action_bar_pack_start(arg0, arg1)
}

// Remove removes a child from @action_bar.
func (actionBar actionBar) Remove(child Widget) {
	var arg0 *C.GtkActionBar
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkActionBar)(actionBar.Native())
	arg1 = (*C.GtkWidget)(child.Native())

	C.gtk_action_bar_remove(arg0, arg1)
}

// SetCenterWidget sets the center widget for the ActionBar.
func (actionBar actionBar) SetCenterWidget(centerWidget Widget) {
	var arg0 *C.GtkActionBar
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkActionBar)(actionBar.Native())
	arg1 = (*C.GtkWidget)(centerWidget.Native())

	C.gtk_action_bar_set_center_widget(arg0, arg1)
}

// SetRevealed sets the ActionBar:revealed property to @revealed. Changing
// this will make @action_bar reveal (true) or conceal (false) itself via a
// sliding transition.
//
// Note: this does not show or hide @action_bar in the Widget:visible sense,
// so revealing has no effect if Widget:visible is false.
func (actionBar actionBar) SetRevealed(revealed bool) {
	var arg0 *C.GtkActionBar
	var arg1 C.gboolean

	arg0 = (*C.GtkActionBar)(actionBar.Native())
	arg1 = gextras.Cbool(revealed)

	C.gtk_action_bar_set_revealed(arg0, arg1)
}

// ActivateAction: a ShortcutAction that calls gtk_widget_activate().
type ActivateAction interface {
	ShortcutAction
}

type activateAction struct {
	shortcutAction
}

// WrapActivateAction wraps a GObject to the right type. It is
// primarily used internally.
func WrapActivateAction(obj *externglib.Object) ActivateAction {
	return activateAction{shortcutAction{*externglib.Object{obj}}}
}

func marshalActivateAction(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapActivateAction(obj), nil
}

// Adjustment: the Adjustment object represents a value which has an associated
// lower and upper bound, together with step and page increments, and a page
// size. It is used within several GTK+ widgets, including SpinButton, Viewport,
// and Range (which is a base class for Scrollbar and Scale).
//
// The Adjustment object does not update the value itself. Instead it is left up
// to the owner of the Adjustment to control the value.
type Adjustment interface {
	gextras.Objector

	// ClampPage updates the Adjustment:value property to ensure that the range
	// between @lower and @upper is in the current page (i.e. between
	// Adjustment:value and Adjustment:value + Adjustment:page-size). If the
	// range is larger than the page size, then only the start of it will be in
	// the current page.
	//
	// A Adjustment::value-changed signal will be emitted if the value is
	// changed.
	ClampPage(lower float64, upper float64)
	// Configure sets all properties of the adjustment at once.
	//
	// Use this function to avoid multiple emissions of the Adjustment::changed
	// signal. See gtk_adjustment_set_lower() for an alternative way of
	// compressing multiple emissions of Adjustment::changed into one.
	Configure(value float64, lower float64, upper float64, stepIncrement float64, pageIncrement float64, pageSize float64)
	// Lower retrieves the minimum value of the adjustment.
	Lower() float64
	// MinimumIncrement gets the smaller of step increment and page increment.
	MinimumIncrement() float64
	// PageIncrement retrieves the page increment of the adjustment.
	PageIncrement() float64
	// PageSize retrieves the page size of the adjustment.
	PageSize() float64
	// StepIncrement retrieves the step increment of the adjustment.
	StepIncrement() float64
	// Upper retrieves the maximum value of the adjustment.
	Upper() float64
	// Value gets the current value of the adjustment. See
	// gtk_adjustment_set_value().
	Value() float64
	// SetLower sets the minimum value of the adjustment.
	//
	// When setting multiple adjustment properties via their individual setters,
	// multiple Adjustment::changed signals will be emitted. However, since the
	// emission of the Adjustment::changed signal is tied to the emission of the
	// #GObject::notify signals of the changed properties, it’s possible to
	// compress the Adjustment::changed signals into one by calling
	// g_object_freeze_notify() and g_object_thaw_notify() around the calls to
	// the individual setters.
	//
	// Alternatively, using a single g_object_set() for all the properties to
	// change, or using gtk_adjustment_configure() has the same effect of
	// compressing Adjustment::changed emissions.
	SetLower(lower float64)
	// SetPageIncrement sets the page increment of the adjustment.
	//
	// See gtk_adjustment_set_lower() about how to compress multiple emissions
	// of the Adjustment::changed signal when setting multiple adjustment
	// properties.
	SetPageIncrement(pageIncrement float64)
	// SetPageSize sets the page size of the adjustment.
	//
	// See gtk_adjustment_set_lower() about how to compress multiple emissions
	// of the GtkAdjustment::changed signal when setting multiple adjustment
	// properties.
	SetPageSize(pageSize float64)
	// SetStepIncrement sets the step increment of the adjustment.
	//
	// See gtk_adjustment_set_lower() about how to compress multiple emissions
	// of the Adjustment::changed signal when setting multiple adjustment
	// properties.
	SetStepIncrement(stepIncrement float64)
	// SetUpper sets the maximum value of the adjustment.
	//
	// Note that values will be restricted by `upper - page-size` if the
	// page-size property is nonzero.
	//
	// See gtk_adjustment_set_lower() about how to compress multiple emissions
	// of the Adjustment::changed signal when setting multiple adjustment
	// properties.
	SetUpper(upper float64)
	// SetValue sets the Adjustment value. The value is clamped to lie between
	// Adjustment:lower and Adjustment:upper.
	//
	// Note that for adjustments which are used in a Scrollbar, the effective
	// range of allowed values goes from Adjustment:lower to Adjustment:upper -
	// Adjustment:page-size.
	SetValue(value float64)
}

type adjustment struct {
	externglib.InitiallyUnowned
}

// WrapAdjustment wraps a GObject to the right type. It is
// primarily used internally.
func WrapAdjustment(obj *externglib.Object) Adjustment {
	return adjustment{externglib.InitiallyUnowned{*externglib.Object{obj}}}
}

func marshalAdjustment(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapAdjustment(obj), nil
}

// NewAdjustment constructs a class Adjustment.
func NewAdjustment(value float64, lower float64, upper float64, stepIncrement float64, pageIncrement float64, pageSize float64) Adjustment {
	var arg1 C.double
	var arg2 C.double
	var arg3 C.double
	var arg4 C.double
	var arg5 C.double
	var arg6 C.double

	arg1 = C.double(value)
	arg2 = C.double(lower)
	arg3 = C.double(upper)
	arg4 = C.double(stepIncrement)
	arg5 = C.double(pageIncrement)
	arg6 = C.double(pageSize)

	ret := C.gtk_adjustment_new(arg1, arg2, arg3, arg4, arg5, arg6)

	var ret0 Adjustment

	ret0 = WrapAdjustment(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// ClampPage updates the Adjustment:value property to ensure that the range
// between @lower and @upper is in the current page (i.e. between
// Adjustment:value and Adjustment:value + Adjustment:page-size). If the
// range is larger than the page size, then only the start of it will be in
// the current page.
//
// A Adjustment::value-changed signal will be emitted if the value is
// changed.
func (adjustment adjustment) ClampPage(lower float64, upper float64) {
	var arg0 *C.GtkAdjustment
	var arg1 C.double
	var arg2 C.double

	arg0 = (*C.GtkAdjustment)(adjustment.Native())
	arg1 = C.double(lower)
	arg2 = C.double(upper)

	C.gtk_adjustment_clamp_page(arg0, arg1, arg2)
}

// Configure sets all properties of the adjustment at once.
//
// Use this function to avoid multiple emissions of the Adjustment::changed
// signal. See gtk_adjustment_set_lower() for an alternative way of
// compressing multiple emissions of Adjustment::changed into one.
func (adjustment adjustment) Configure(value float64, lower float64, upper float64, stepIncrement float64, pageIncrement float64, pageSize float64) {
	var arg0 *C.GtkAdjustment
	var arg1 C.double
	var arg2 C.double
	var arg3 C.double
	var arg4 C.double
	var arg5 C.double
	var arg6 C.double

	arg0 = (*C.GtkAdjustment)(adjustment.Native())
	arg1 = C.double(value)
	arg2 = C.double(lower)
	arg3 = C.double(upper)
	arg4 = C.double(stepIncrement)
	arg5 = C.double(pageIncrement)
	arg6 = C.double(pageSize)

	C.gtk_adjustment_configure(arg0, arg1, arg2, arg3, arg4, arg5, arg6)
}

// Lower retrieves the minimum value of the adjustment.
func (adjustment adjustment) Lower() float64 {
	var arg0 *C.GtkAdjustment

	arg0 = (*C.GtkAdjustment)(adjustment.Native())

	ret := C.gtk_adjustment_get_lower(arg0)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// MinimumIncrement gets the smaller of step increment and page increment.
func (adjustment adjustment) MinimumIncrement() float64 {
	var arg0 *C.GtkAdjustment

	arg0 = (*C.GtkAdjustment)(adjustment.Native())

	ret := C.gtk_adjustment_get_minimum_increment(arg0)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// PageIncrement retrieves the page increment of the adjustment.
func (adjustment adjustment) PageIncrement() float64 {
	var arg0 *C.GtkAdjustment

	arg0 = (*C.GtkAdjustment)(adjustment.Native())

	ret := C.gtk_adjustment_get_page_increment(arg0)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// PageSize retrieves the page size of the adjustment.
func (adjustment adjustment) PageSize() float64 {
	var arg0 *C.GtkAdjustment

	arg0 = (*C.GtkAdjustment)(adjustment.Native())

	ret := C.gtk_adjustment_get_page_size(arg0)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// StepIncrement retrieves the step increment of the adjustment.
func (adjustment adjustment) StepIncrement() float64 {
	var arg0 *C.GtkAdjustment

	arg0 = (*C.GtkAdjustment)(adjustment.Native())

	ret := C.gtk_adjustment_get_step_increment(arg0)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// Upper retrieves the maximum value of the adjustment.
func (adjustment adjustment) Upper() float64 {
	var arg0 *C.GtkAdjustment

	arg0 = (*C.GtkAdjustment)(adjustment.Native())

	ret := C.gtk_adjustment_get_upper(arg0)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// Value gets the current value of the adjustment. See
// gtk_adjustment_set_value().
func (adjustment adjustment) Value() float64 {
	var arg0 *C.GtkAdjustment

	arg0 = (*C.GtkAdjustment)(adjustment.Native())

	ret := C.gtk_adjustment_get_value(arg0)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// SetLower sets the minimum value of the adjustment.
//
// When setting multiple adjustment properties via their individual setters,
// multiple Adjustment::changed signals will be emitted. However, since the
// emission of the Adjustment::changed signal is tied to the emission of the
// #GObject::notify signals of the changed properties, it’s possible to
// compress the Adjustment::changed signals into one by calling
// g_object_freeze_notify() and g_object_thaw_notify() around the calls to
// the individual setters.
//
// Alternatively, using a single g_object_set() for all the properties to
// change, or using gtk_adjustment_configure() has the same effect of
// compressing Adjustment::changed emissions.
func (adjustment adjustment) SetLower(lower float64) {
	var arg0 *C.GtkAdjustment
	var arg1 C.double

	arg0 = (*C.GtkAdjustment)(adjustment.Native())
	arg1 = C.double(lower)

	C.gtk_adjustment_set_lower(arg0, arg1)
}

// SetPageIncrement sets the page increment of the adjustment.
//
// See gtk_adjustment_set_lower() about how to compress multiple emissions
// of the Adjustment::changed signal when setting multiple adjustment
// properties.
func (adjustment adjustment) SetPageIncrement(pageIncrement float64) {
	var arg0 *C.GtkAdjustment
	var arg1 C.double

	arg0 = (*C.GtkAdjustment)(adjustment.Native())
	arg1 = C.double(pageIncrement)

	C.gtk_adjustment_set_page_increment(arg0, arg1)
}

// SetPageSize sets the page size of the adjustment.
//
// See gtk_adjustment_set_lower() about how to compress multiple emissions
// of the GtkAdjustment::changed signal when setting multiple adjustment
// properties.
func (adjustment adjustment) SetPageSize(pageSize float64) {
	var arg0 *C.GtkAdjustment
	var arg1 C.double

	arg0 = (*C.GtkAdjustment)(adjustment.Native())
	arg1 = C.double(pageSize)

	C.gtk_adjustment_set_page_size(arg0, arg1)
}

// SetStepIncrement sets the step increment of the adjustment.
//
// See gtk_adjustment_set_lower() about how to compress multiple emissions
// of the Adjustment::changed signal when setting multiple adjustment
// properties.
func (adjustment adjustment) SetStepIncrement(stepIncrement float64) {
	var arg0 *C.GtkAdjustment
	var arg1 C.double

	arg0 = (*C.GtkAdjustment)(adjustment.Native())
	arg1 = C.double(stepIncrement)

	C.gtk_adjustment_set_step_increment(arg0, arg1)
}

// SetUpper sets the maximum value of the adjustment.
//
// Note that values will be restricted by `upper - page-size` if the
// page-size property is nonzero.
//
// See gtk_adjustment_set_lower() about how to compress multiple emissions
// of the Adjustment::changed signal when setting multiple adjustment
// properties.
func (adjustment adjustment) SetUpper(upper float64) {
	var arg0 *C.GtkAdjustment
	var arg1 C.double

	arg0 = (*C.GtkAdjustment)(adjustment.Native())
	arg1 = C.double(upper)

	C.gtk_adjustment_set_upper(arg0, arg1)
}

// SetValue sets the Adjustment value. The value is clamped to lie between
// Adjustment:lower and Adjustment:upper.
//
// Note that for adjustments which are used in a Scrollbar, the effective
// range of allowed values goes from Adjustment:lower to Adjustment:upper -
// Adjustment:page-size.
func (adjustment adjustment) SetValue(value float64) {
	var arg0 *C.GtkAdjustment
	var arg1 C.double

	arg0 = (*C.GtkAdjustment)(adjustment.Native())
	arg1 = C.double(value)

	C.gtk_adjustment_set_value(arg0, arg1)
}

// AlternativeTrigger: a ShortcutTrigger that triggers when either of two
// ShortcutTriggers trigger.
type AlternativeTrigger interface {
	ShortcutTrigger

	// First gets the first of the two alternative triggers that may trigger
	// @self. gtk_alternative_trigger_get_second() will return the other one.
	First() ShortcutTrigger
	// Second gets the second of the two alternative triggers that may trigger
	// @self. gtk_alternative_trigger_get_first() will return the other one.
	Second() ShortcutTrigger
}

type alternativeTrigger struct {
	shortcutTrigger
}

// WrapAlternativeTrigger wraps a GObject to the right type. It is
// primarily used internally.
func WrapAlternativeTrigger(obj *externglib.Object) AlternativeTrigger {
	return alternativeTrigger{shortcutTrigger{*externglib.Object{obj}}}
}

func marshalAlternativeTrigger(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapAlternativeTrigger(obj), nil
}

// NewAlternativeTrigger constructs a class AlternativeTrigger.
func NewAlternativeTrigger(first ShortcutTrigger, second ShortcutTrigger) AlternativeTrigger {
	var arg1 *C.GtkShortcutTrigger
	var arg2 *C.GtkShortcutTrigger

	arg1 = (*C.GtkShortcutTrigger)(first.Native())
	arg2 = (*C.GtkShortcutTrigger)(second.Native())

	ret := C.gtk_alternative_trigger_new(arg1, arg2)

	var ret0 AlternativeTrigger

	ret0 = WrapAlternativeTrigger(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// First gets the first of the two alternative triggers that may trigger
// @self. gtk_alternative_trigger_get_second() will return the other one.
func (self alternativeTrigger) First() ShortcutTrigger {
	var arg0 *C.GtkAlternativeTrigger

	arg0 = (*C.GtkAlternativeTrigger)(self.Native())

	ret := C.gtk_alternative_trigger_get_first(arg0)

	var ret0 ShortcutTrigger

	ret0 = WrapShortcutTrigger(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Second gets the second of the two alternative triggers that may trigger
// @self. gtk_alternative_trigger_get_first() will return the other one.
func (self alternativeTrigger) Second() ShortcutTrigger {
	var arg0 *C.GtkAlternativeTrigger

	arg0 = (*C.GtkAlternativeTrigger)(self.Native())

	ret := C.gtk_alternative_trigger_get_second(arg0)

	var ret0 ShortcutTrigger

	ret0 = WrapShortcutTrigger(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

type AnyFilter interface {
	MultiFilter
}

type anyFilter struct {
	multiFilter
}

// WrapAnyFilter wraps a GObject to the right type. It is
// primarily used internally.
func WrapAnyFilter(obj *externglib.Object) AnyFilter {
	return anyFilter{multiFilter{filter{*externglib.Object{obj}}}}
}

func marshalAnyFilter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapAnyFilter(obj), nil
}

// NewAnyFilter constructs a class AnyFilter.
func NewAnyFilter() AnyFilter {

	ret := C.gtk_any_filter_new()

	var ret0 AnyFilter

	ret0 = WrapAnyFilter(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// AppChooserButton: the AppChooserButton is a widget that lets the user select
// an application. It implements the AppChooser interface.
//
// Initially, a AppChooserButton selects the first application in its list,
// which will either be the most-recently used application or, if
// AppChooserButton:show-default-item is true, the default application.
//
// The list of applications shown in a AppChooserButton includes the recommended
// applications for the given content type. When
// AppChooserButton:show-default-item is set, the default application is also
// included. To let the user chooser other applications, you can set the
// AppChooserButton:show-dialog-item property, which allows to open a full
// AppChooserDialog.
//
// It is possible to add custom items to the list, using
// gtk_app_chooser_button_append_custom_item(). These items cause the
// AppChooserButton::custom-item-activated signal to be emitted when they are
// selected.
//
// To track changes in the selected application, use the
// AppChooserButton::changed signal.
//
//
// CSS nodes
//
// GtkAppChooserButton has a single CSS node with the name “appchooserbutton”.
type AppChooserButton interface {
	Widget

	// AppendCustomItem appends a custom item to the list of applications that
	// is shown in the popup; the item name must be unique per-widget. Clients
	// can use the provided name as a detail for the
	// AppChooserButton::custom-item-activated signal, to add a callback for the
	// activation of a particular custom item in the list. See also
	// gtk_app_chooser_button_append_separator().
	AppendCustomItem(name string, label string, icon gio.Icon)
	// AppendSeparator appends a separator to the list of applications that is
	// shown in the popup.
	AppendSeparator()
	// Heading returns the text to display at the top of the dialog.
	Heading() string
	// Modal gets whether the dialog is modal.
	Modal() bool
	// ShowDefaultItem returns the current value of the
	// AppChooserButton:show-default-item property.
	ShowDefaultItem() bool
	// ShowDialogItem returns the current value of the
	// AppChooserButton:show-dialog-item property.
	ShowDialogItem() bool
	// SetActiveCustomItem selects a custom item previously added with
	// gtk_app_chooser_button_append_custom_item().
	//
	// Use gtk_app_chooser_refresh() to bring the selection to its initial
	// state.
	SetActiveCustomItem(name string)
	// SetHeading sets the text to display at the top of the dialog. If the
	// heading is not set, the dialog displays a default text.
	SetHeading(heading string)
	// SetModal sets whether the dialog should be modal.
	SetModal(modal bool)
	// SetShowDefaultItem sets whether the dropdown menu of this button should
	// show the default application for the given content type at top.
	SetShowDefaultItem(setting bool)
	// SetShowDialogItem sets whether the dropdown menu of this button should
	// show an entry to trigger a AppChooserDialog.
	SetShowDialogItem(setting bool)
}

type appChooserButton struct {
	widget
}

// WrapAppChooserButton wraps a GObject to the right type. It is
// primarily used internally.
func WrapAppChooserButton(obj *externglib.Object) AppChooserButton {
	return appChooserButton{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}
}

func marshalAppChooserButton(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapAppChooserButton(obj), nil
}

// NewAppChooserButton constructs a class AppChooserButton.
func NewAppChooserButton(contentType string) AppChooserButton {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(contentType))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_app_chooser_button_new(arg1)

	var ret0 AppChooserButton

	ret0 = WrapAppChooserButton(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// AppendCustomItem appends a custom item to the list of applications that
// is shown in the popup; the item name must be unique per-widget. Clients
// can use the provided name as a detail for the
// AppChooserButton::custom-item-activated signal, to add a callback for the
// activation of a particular custom item in the list. See also
// gtk_app_chooser_button_append_separator().
func (self appChooserButton) AppendCustomItem(name string, label string, icon gio.Icon) {
	var arg0 *C.GtkAppChooserButton
	var arg1 *C.char
	var arg2 *C.char
	var arg3 *C.GIcon

	arg0 = (*C.GtkAppChooserButton)(self.Native())
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(arg2))

	C.gtk_app_chooser_button_append_custom_item(arg0, arg1, arg2, arg3)
}

// AppendSeparator appends a separator to the list of applications that is
// shown in the popup.
func (self appChooserButton) AppendSeparator() {
	var arg0 *C.GtkAppChooserButton

	arg0 = (*C.GtkAppChooserButton)(self.Native())

	C.gtk_app_chooser_button_append_separator(arg0)
}

// Heading returns the text to display at the top of the dialog.
func (self appChooserButton) Heading() string {
	var arg0 *C.GtkAppChooserButton

	arg0 = (*C.GtkAppChooserButton)(self.Native())

	ret := C.gtk_app_chooser_button_get_heading(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Modal gets whether the dialog is modal.
func (self appChooserButton) Modal() bool {
	var arg0 *C.GtkAppChooserButton

	arg0 = (*C.GtkAppChooserButton)(self.Native())

	ret := C.gtk_app_chooser_button_get_modal(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// ShowDefaultItem returns the current value of the
// AppChooserButton:show-default-item property.
func (self appChooserButton) ShowDefaultItem() bool {
	var arg0 *C.GtkAppChooserButton

	arg0 = (*C.GtkAppChooserButton)(self.Native())

	ret := C.gtk_app_chooser_button_get_show_default_item(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// ShowDialogItem returns the current value of the
// AppChooserButton:show-dialog-item property.
func (self appChooserButton) ShowDialogItem() bool {
	var arg0 *C.GtkAppChooserButton

	arg0 = (*C.GtkAppChooserButton)(self.Native())

	ret := C.gtk_app_chooser_button_get_show_dialog_item(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// SetActiveCustomItem selects a custom item previously added with
// gtk_app_chooser_button_append_custom_item().
//
// Use gtk_app_chooser_refresh() to bring the selection to its initial
// state.
func (self appChooserButton) SetActiveCustomItem(name string) {
	var arg0 *C.GtkAppChooserButton
	var arg1 *C.char

	arg0 = (*C.GtkAppChooserButton)(self.Native())
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_app_chooser_button_set_active_custom_item(arg0, arg1)
}

// SetHeading sets the text to display at the top of the dialog. If the
// heading is not set, the dialog displays a default text.
func (self appChooserButton) SetHeading(heading string) {
	var arg0 *C.GtkAppChooserButton
	var arg1 *C.char

	arg0 = (*C.GtkAppChooserButton)(self.Native())
	arg1 = (*C.gchar)(C.CString(heading))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_app_chooser_button_set_heading(arg0, arg1)
}

// SetModal sets whether the dialog should be modal.
func (self appChooserButton) SetModal(modal bool) {
	var arg0 *C.GtkAppChooserButton
	var arg1 C.gboolean

	arg0 = (*C.GtkAppChooserButton)(self.Native())
	arg1 = gextras.Cbool(modal)

	C.gtk_app_chooser_button_set_modal(arg0, arg1)
}

// SetShowDefaultItem sets whether the dropdown menu of this button should
// show the default application for the given content type at top.
func (self appChooserButton) SetShowDefaultItem(setting bool) {
	var arg0 *C.GtkAppChooserButton
	var arg1 C.gboolean

	arg0 = (*C.GtkAppChooserButton)(self.Native())
	arg1 = gextras.Cbool(setting)

	C.gtk_app_chooser_button_set_show_default_item(arg0, arg1)
}

// SetShowDialogItem sets whether the dropdown menu of this button should
// show an entry to trigger a AppChooserDialog.
func (self appChooserButton) SetShowDialogItem(setting bool) {
	var arg0 *C.GtkAppChooserButton
	var arg1 C.gboolean

	arg0 = (*C.GtkAppChooserButton)(self.Native())
	arg1 = gextras.Cbool(setting)

	C.gtk_app_chooser_button_set_show_dialog_item(arg0, arg1)
}

// AppChooserDialog shows a AppChooserWidget inside a Dialog.
//
// Note that AppChooserDialog does not have any interesting methods of its own.
// Instead, you should get the embedded AppChooserWidget using
// gtk_app_chooser_dialog_get_widget() and call its methods if the generic
// AppChooser interface is not sufficient for your needs.
//
// To set the heading that is shown above the AppChooserWidget, use
// gtk_app_chooser_dialog_set_heading().
type AppChooserDialog interface {
	Dialog

	// Heading returns the text to display at the top of the dialog.
	Heading() string
	// Widget returns the AppChooserWidget of this dialog.
	Widget() Widget
	// SetHeading sets the text to display at the top of the dialog. If the
	// heading is not set, the dialog displays a default text.
	SetHeading(heading string)
}

type appChooserDialog struct {
	dialog
}

// WrapAppChooserDialog wraps a GObject to the right type. It is
// primarily used internally.
func WrapAppChooserDialog(obj *externglib.Object) AppChooserDialog {
	return appChooserDialog{dialog{window{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}}}
}

func marshalAppChooserDialog(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapAppChooserDialog(obj), nil
}

// NewAppChooserDialog constructs a class AppChooserDialog.
func NewAppChooserDialog(parent Window, flags DialogFlags, file gio.File) AppChooserDialog {
	var arg1 *C.GtkWindow
	var arg2 C.GtkDialogFlags
	var arg3 *C.GFile

	arg1 = (*C.GtkWindow)(parent.Native())
	arg2 = (C.GtkDialogFlags)(flags)

	ret := C.gtk_app_chooser_dialog_new(arg1, arg2, arg3)

	var ret0 AppChooserDialog

	ret0 = WrapAppChooserDialog(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewAppChooserDialogForContentType constructs a class AppChooserDialog.
func NewAppChooserDialogForContentType(parent Window, flags DialogFlags, contentType string) AppChooserDialog {
	var arg1 *C.GtkWindow
	var arg2 C.GtkDialogFlags
	var arg3 *C.char

	arg1 = (*C.GtkWindow)(parent.Native())
	arg2 = (C.GtkDialogFlags)(flags)
	arg3 = (*C.gchar)(C.CString(contentType))
	defer C.free(unsafe.Pointer(arg3))

	ret := C.gtk_app_chooser_dialog_new_for_content_type(arg1, arg2, arg3)

	var ret0 AppChooserDialog

	ret0 = WrapAppChooserDialog(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Heading returns the text to display at the top of the dialog.
func (self appChooserDialog) Heading() string {
	var arg0 *C.GtkAppChooserDialog

	arg0 = (*C.GtkAppChooserDialog)(self.Native())

	ret := C.gtk_app_chooser_dialog_get_heading(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Widget returns the AppChooserWidget of this dialog.
func (self appChooserDialog) Widget() Widget {
	var arg0 *C.GtkAppChooserDialog

	arg0 = (*C.GtkAppChooserDialog)(self.Native())

	ret := C.gtk_app_chooser_dialog_get_widget(arg0)

	var ret0 Widget

	ret0 = WrapWidget(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// SetHeading sets the text to display at the top of the dialog. If the
// heading is not set, the dialog displays a default text.
func (self appChooserDialog) SetHeading(heading string) {
	var arg0 *C.GtkAppChooserDialog
	var arg1 *C.char

	arg0 = (*C.GtkAppChooserDialog)(self.Native())
	arg1 = (*C.gchar)(C.CString(heading))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_app_chooser_dialog_set_heading(arg0, arg1)
}

// AppChooserWidget is a widget for selecting applications. It is the main
// building block for AppChooserDialog. Most applications only need to use the
// latter; but you can use this widget as part of a larger widget if you have
// special needs.
//
// AppChooserWidget offers detailed control over what applications are shown,
// using the AppChooserWidget:show-default, AppChooserWidget:show-recommended,
// AppChooserWidget:show-fallback, AppChooserWidget:show-other and
// AppChooserWidget:show-all properties. See the AppChooser documentation for
// more information about these groups of applications.
//
// To keep track of the selected application, use the
// AppChooserWidget::application-selected and
// AppChooserWidget::application-activated signals.
//
//
// CSS nodes
//
// GtkAppChooserWidget has a single CSS node with name appchooser.
type AppChooserWidget interface {
	Widget

	// DefaultText returns the text that is shown if there are not applications
	// that can handle the content type.
	DefaultText() string
	// ShowAll returns the current value of the AppChooserWidget:show-all
	// property.
	ShowAll() bool
	// ShowDefault returns the current value of the
	// AppChooserWidget:show-default property.
	ShowDefault() bool
	// ShowFallback returns the current value of the
	// AppChooserWidget:show-fallback property.
	ShowFallback() bool
	// ShowOther returns the current value of the AppChooserWidget:show-other
	// property.
	ShowOther() bool
	// ShowRecommended returns the current value of the
	// AppChooserWidget:show-recommended property.
	ShowRecommended() bool
	// SetDefaultText sets the text that is shown if there are not applications
	// that can handle the content type.
	SetDefaultText(text string)
	// SetShowAll sets whether the app chooser should show all applications in a
	// flat list.
	SetShowAll(setting bool)
	// SetShowDefault sets whether the app chooser should show the default
	// handler for the content type in a separate section.
	SetShowDefault(setting bool)
	// SetShowFallback sets whether the app chooser should show related
	// applications for the content type in a separate section.
	SetShowFallback(setting bool)
	// SetShowOther sets whether the app chooser should show applications which
	// are unrelated to the content type.
	SetShowOther(setting bool)
	// SetShowRecommended sets whether the app chooser should show recommended
	// applications for the content type in a separate section.
	SetShowRecommended(setting bool)
}

type appChooserWidget struct {
	widget
}

// WrapAppChooserWidget wraps a GObject to the right type. It is
// primarily used internally.
func WrapAppChooserWidget(obj *externglib.Object) AppChooserWidget {
	return appChooserWidget{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}
}

func marshalAppChooserWidget(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapAppChooserWidget(obj), nil
}

// NewAppChooserWidget constructs a class AppChooserWidget.
func NewAppChooserWidget(contentType string) AppChooserWidget {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(contentType))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_app_chooser_widget_new(arg1)

	var ret0 AppChooserWidget

	ret0 = WrapAppChooserWidget(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// DefaultText returns the text that is shown if there are not applications
// that can handle the content type.
func (self appChooserWidget) DefaultText() string {
	var arg0 *C.GtkAppChooserWidget

	arg0 = (*C.GtkAppChooserWidget)(self.Native())

	ret := C.gtk_app_chooser_widget_get_default_text(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// ShowAll returns the current value of the AppChooserWidget:show-all
// property.
func (self appChooserWidget) ShowAll() bool {
	var arg0 *C.GtkAppChooserWidget

	arg0 = (*C.GtkAppChooserWidget)(self.Native())

	ret := C.gtk_app_chooser_widget_get_show_all(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// ShowDefault returns the current value of the
// AppChooserWidget:show-default property.
func (self appChooserWidget) ShowDefault() bool {
	var arg0 *C.GtkAppChooserWidget

	arg0 = (*C.GtkAppChooserWidget)(self.Native())

	ret := C.gtk_app_chooser_widget_get_show_default(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// ShowFallback returns the current value of the
// AppChooserWidget:show-fallback property.
func (self appChooserWidget) ShowFallback() bool {
	var arg0 *C.GtkAppChooserWidget

	arg0 = (*C.GtkAppChooserWidget)(self.Native())

	ret := C.gtk_app_chooser_widget_get_show_fallback(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// ShowOther returns the current value of the AppChooserWidget:show-other
// property.
func (self appChooserWidget) ShowOther() bool {
	var arg0 *C.GtkAppChooserWidget

	arg0 = (*C.GtkAppChooserWidget)(self.Native())

	ret := C.gtk_app_chooser_widget_get_show_other(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// ShowRecommended returns the current value of the
// AppChooserWidget:show-recommended property.
func (self appChooserWidget) ShowRecommended() bool {
	var arg0 *C.GtkAppChooserWidget

	arg0 = (*C.GtkAppChooserWidget)(self.Native())

	ret := C.gtk_app_chooser_widget_get_show_recommended(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// SetDefaultText sets the text that is shown if there are not applications
// that can handle the content type.
func (self appChooserWidget) SetDefaultText(text string) {
	var arg0 *C.GtkAppChooserWidget
	var arg1 *C.char

	arg0 = (*C.GtkAppChooserWidget)(self.Native())
	arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_app_chooser_widget_set_default_text(arg0, arg1)
}

// SetShowAll sets whether the app chooser should show all applications in a
// flat list.
func (self appChooserWidget) SetShowAll(setting bool) {
	var arg0 *C.GtkAppChooserWidget
	var arg1 C.gboolean

	arg0 = (*C.GtkAppChooserWidget)(self.Native())
	arg1 = gextras.Cbool(setting)

	C.gtk_app_chooser_widget_set_show_all(arg0, arg1)
}

// SetShowDefault sets whether the app chooser should show the default
// handler for the content type in a separate section.
func (self appChooserWidget) SetShowDefault(setting bool) {
	var arg0 *C.GtkAppChooserWidget
	var arg1 C.gboolean

	arg0 = (*C.GtkAppChooserWidget)(self.Native())
	arg1 = gextras.Cbool(setting)

	C.gtk_app_chooser_widget_set_show_default(arg0, arg1)
}

// SetShowFallback sets whether the app chooser should show related
// applications for the content type in a separate section.
func (self appChooserWidget) SetShowFallback(setting bool) {
	var arg0 *C.GtkAppChooserWidget
	var arg1 C.gboolean

	arg0 = (*C.GtkAppChooserWidget)(self.Native())
	arg1 = gextras.Cbool(setting)

	C.gtk_app_chooser_widget_set_show_fallback(arg0, arg1)
}

// SetShowOther sets whether the app chooser should show applications which
// are unrelated to the content type.
func (self appChooserWidget) SetShowOther(setting bool) {
	var arg0 *C.GtkAppChooserWidget
	var arg1 C.gboolean

	arg0 = (*C.GtkAppChooserWidget)(self.Native())
	arg1 = gextras.Cbool(setting)

	C.gtk_app_chooser_widget_set_show_other(arg0, arg1)
}

// SetShowRecommended sets whether the app chooser should show recommended
// applications for the content type in a separate section.
func (self appChooserWidget) SetShowRecommended(setting bool) {
	var arg0 *C.GtkAppChooserWidget
	var arg1 C.gboolean

	arg0 = (*C.GtkAppChooserWidget)(self.Native())
	arg1 = gextras.Cbool(setting)

	C.gtk_app_chooser_widget_set_show_recommended(arg0, arg1)
}

// Application is a class that handles many important aspects of a GTK+
// application in a convenient fashion, without enforcing a one-size-fits-all
// application model.
//
// Currently, GtkApplication handles GTK initialization, application uniqueness,
// session management, provides some basic scriptability and desktop shell
// integration by exporting actions and menus and manages a list of toplevel
// windows whose life-cycle is automatically tied to the life-cycle of your
// application.
//
// While GtkApplication works fine with plain Windows, it is recommended to use
// it together with ApplicationWindow.
//
// When GDK threads are enabled, GtkApplication will acquire the GDK lock when
// invoking actions that arrive from other processes. The GDK lock is not
// touched for local action invocations. In order to have actions invoked in a
// predictable context it is therefore recommended that the GDK lock be held
// while invoking actions locally with g_action_group_activate_action(). The
// same applies to actions associated with ApplicationWindow and to the
// “activate” and “open” #GApplication methods.
//
//
// Automatic resources
//
// Application will automatically load menus from the Builder resource located
// at "gtk/menus.ui", relative to the application's resource base path (see
// g_application_set_resource_base_path()). The menu with the ID "menubar" is
// taken as the application's menubar. Additional menus (most interesting
// submenus) can be named and accessed via gtk_application_get_menu_by_id()
// which allows for dynamic population of a part of the menu structure.
//
// It is also possible to provide the menubar manually using
// gtk_application_set_menubar().
//
// Application will also automatically setup an icon search path for the default
// icon theme by appending "icons" to the resource base path. This allows your
// application to easily store its icons as resources. See
// gtk_icon_theme_add_resource_path() for more information.
//
// If there is a resource located at "gtk/help-overlay.ui" which defines a
// ShortcutsWindow with ID "help_overlay" then GtkApplication associates an
// instance of this shortcuts window with each ApplicationWindow and sets up the
// keyboard accelerator Control-? to open it. To create a menu item that
// displays the shortcuts window, associate the item with the action
// win.show-help-overlay.
//
//
// A simple application
//
// A simple example
// (https://gitlab.gnome.org/GNOME/gtk/tree/master/examples/bp/bloatpad.c)
//
// GtkApplication optionally registers with a session manager of the users
// session (if you set the Application:register-session property) and offers
// various functionality related to the session life-cycle.
//
// An application can block various ways to end the session with the
// gtk_application_inhibit() function. Typical use cases for this kind of
// inhibiting are long-running, uninterruptible operations, such as burning a CD
// or performing a disk backup. The session manager may not honor the inhibitor,
// but it can be expected to inform the user about the negative consequences of
// ending the session while inhibitors are present.
//
//
// See Also
//
// HowDoI: Using GtkApplication (https://wiki.gnome.org/HowDoI/GtkApplication),
// Getting Started with GTK: Basics
// (https://developer.gnome.org/gtk3/stable/gtk-getting-started.html#id-1.2.3.3)
type Application interface {
	gio.Application

	// AddWindow adds a window to @application.
	//
	// This call can only happen after the @application has started; typically,
	// you should add new application windows in response to the emission of the
	// #GApplication::activate signal.
	//
	// This call is equivalent to setting the Window:application property of
	// @window to @application.
	//
	// Normally, the connection between the application and the window will
	// remain until the window is destroyed, but you can explicitly remove it
	// with gtk_application_remove_window().
	//
	// GTK+ will keep the @application running as long as it has any windows.
	AddWindow(window Window)
	// AccelsForAction gets the accelerators that are currently associated with
	// the given action.
	AccelsForAction(detailedActionName string) []string
	// ActionsForAccel returns the list of actions (possibly empty) that @accel
	// maps to. Each item in the list is a detailed action name in the usual
	// form.
	//
	// This might be useful to discover if an accel already exists in order to
	// prevent installation of a conflicting accelerator (from an accelerator
	// editor or a plugin system, for example). Note that having more than one
	// action per accelerator may not be a bad thing and might make sense in
	// cases where the actions never appear in the same context.
	//
	// In case there are no actions for a given accelerator, an empty array is
	// returned. nil is never returned.
	//
	// It is a programmer error to pass an invalid accelerator string. If you
	// are unsure, check it with gtk_accelerator_parse() first.
	ActionsForAccel(accel string) []string
	// ActiveWindow gets the “active” window for the application.
	//
	// The active window is the one that was most recently focused (within the
	// application). This window may not have the focus at the moment if another
	// application has it — this is just the most recently-focused window within
	// this application.
	ActiveWindow() Window
	// MenuByID gets a menu from automatically loaded resources. See [Automatic
	// resources][automatic-resources] for more information.
	MenuByID(id string) gio.Menu
	// Menubar returns the menu model that has been set with
	// gtk_application_set_menubar().
	Menubar() gio.MenuModel
	// WindowByID returns the ApplicationWindow with the given ID.
	//
	// The ID of a ApplicationWindow can be retrieved with
	// gtk_application_window_get_id().
	WindowByID(id uint) Window
	// Windows gets a list of the Windows associated with @application.
	//
	// The list is sorted by most recently focused window, such that the first
	// element is the currently focused window. (Useful for choosing a parent
	// for a transient window.)
	//
	// The list that is returned should not be modified in any way. It will only
	// remain valid until the next focus change or window creation or deletion.
	Windows() *glib.List
	// Inhibit: inform the session manager that certain types of actions should
	// be inhibited. This is not guaranteed to work on all platforms and for all
	// types of actions.
	//
	// Applications should invoke this method when they begin an operation that
	// should not be interrupted, such as creating a CD or DVD. The types of
	// actions that may be blocked are specified by the @flags parameter. When
	// the application completes the operation it should call
	// gtk_application_uninhibit() to remove the inhibitor. Note that an
	// application can have multiple inhibitors, and all of them must be
	// individually removed. Inhibitors are also cleared when the application
	// exits.
	//
	// Applications should not expect that they will always be able to block the
	// action. In most cases, users will be given the option to force the action
	// to take place.
	//
	// Reasons should be short and to the point.
	//
	// If @window is given, the session manager may point the user to this
	// window to find out more about why the action is inhibited.
	Inhibit(window Window, flags ApplicationInhibitFlags, reason string) uint
	// ListActionDescriptions lists the detailed action names which have
	// associated accelerators. See gtk_application_set_accels_for_action().
	ListActionDescriptions() []string
	// RemoveWindow: remove a window from @application.
	//
	// If @window belongs to @application then this call is equivalent to
	// setting the Window:application property of @window to nil.
	//
	// The application may stop running as a result of a call to this function.
	RemoveWindow(window Window)
	// SetAccelsForAction sets zero or more keyboard accelerators that will
	// trigger the given action. The first item in @accels will be the primary
	// accelerator, which may be displayed in the UI.
	//
	// To remove all accelerators for an action, use an empty, zero-terminated
	// array for @accels.
	//
	// For the @detailed_action_name, see g_action_parse_detailed_name() and
	// g_action_print_detailed_name().
	SetAccelsForAction(detailedActionName string, accels []string)
	// SetMenubar sets or unsets the menubar for windows of @application.
	//
	// This is a menubar in the traditional sense.
	//
	// This can only be done in the primary instance of the application, after
	// it has been registered. #GApplication::startup is a good place to call
	// this.
	//
	// Depending on the desktop environment, this may appear at the top of each
	// window, or at the top of the screen. In some environments, if both the
	// application menu and the menubar are set, the application menu will be
	// presented as if it were the first item of the menubar. Other environments
	// treat the two as completely separate — for example, the application menu
	// may be rendered by the desktop shell while the menubar (if set) remains
	// in each individual window.
	//
	// Use the base Map interface to add actions, to respond to the user
	// selecting these menu items.
	SetMenubar(menubar gio.MenuModel)
	// Uninhibit removes an inhibitor that has been established with
	// gtk_application_inhibit(). Inhibitors are also cleared when the
	// application exits.
	Uninhibit(cookie uint)
}

type application struct {
	gio.Application
}

// WrapApplication wraps a GObject to the right type. It is
// primarily used internally.
func WrapApplication(obj *externglib.Object) Application {
	return application{gio.WrapApplication(obj)}
}

func marshalApplication(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapApplication(obj), nil
}

// NewApplication constructs a class Application.
func NewApplication(applicationID string, flags gio.ApplicationFlags) Application {
	var arg1 *C.char
	var arg2 C.GApplicationFlags

	arg1 = (*C.gchar)(C.CString(applicationID))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (C.GApplicationFlags)(flags)

	ret := C.gtk_application_new(arg1, arg2)

	var ret0 Application

	ret0 = WrapApplication(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// AddWindow adds a window to @application.
//
// This call can only happen after the @application has started; typically,
// you should add new application windows in response to the emission of the
// #GApplication::activate signal.
//
// This call is equivalent to setting the Window:application property of
// @window to @application.
//
// Normally, the connection between the application and the window will
// remain until the window is destroyed, but you can explicitly remove it
// with gtk_application_remove_window().
//
// GTK+ will keep the @application running as long as it has any windows.
func (application application) AddWindow(window Window) {
	var arg0 *C.GtkApplication
	var arg1 *C.GtkWindow

	arg0 = (*C.GtkApplication)(application.Native())
	arg1 = (*C.GtkWindow)(window.Native())

	C.gtk_application_add_window(arg0, arg1)
}

// AccelsForAction gets the accelerators that are currently associated with
// the given action.
func (application application) AccelsForAction(detailedActionName string) []string {
	var arg0 *C.GtkApplication
	var arg1 *C.char

	arg0 = (*C.GtkApplication)(application.Native())
	arg1 = (*C.gchar)(C.CString(detailedActionName))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_application_get_accels_for_action(arg0, arg1)

	var ret0 []string

	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]string, length)
		for i := 0; i < length; i++ {
			src := (C.utf8)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			ret0[i] = C.GoString(src)
			C.free(unsafe.Pointer(src))
		}
	}

	return ret0
}

// ActionsForAccel returns the list of actions (possibly empty) that @accel
// maps to. Each item in the list is a detailed action name in the usual
// form.
//
// This might be useful to discover if an accel already exists in order to
// prevent installation of a conflicting accelerator (from an accelerator
// editor or a plugin system, for example). Note that having more than one
// action per accelerator may not be a bad thing and might make sense in
// cases where the actions never appear in the same context.
//
// In case there are no actions for a given accelerator, an empty array is
// returned. nil is never returned.
//
// It is a programmer error to pass an invalid accelerator string. If you
// are unsure, check it with gtk_accelerator_parse() first.
func (application application) ActionsForAccel(accel string) []string {
	var arg0 *C.GtkApplication
	var arg1 *C.char

	arg0 = (*C.GtkApplication)(application.Native())
	arg1 = (*C.gchar)(C.CString(accel))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_application_get_actions_for_accel(arg0, arg1)

	var ret0 []string

	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]string, length)
		for i := 0; i < length; i++ {
			src := (C.utf8)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			ret0[i] = C.GoString(src)
			C.free(unsafe.Pointer(src))
		}
	}

	return ret0
}

// ActiveWindow gets the “active” window for the application.
//
// The active window is the one that was most recently focused (within the
// application). This window may not have the focus at the moment if another
// application has it — this is just the most recently-focused window within
// this application.
func (application application) ActiveWindow() Window {
	var arg0 *C.GtkApplication

	arg0 = (*C.GtkApplication)(application.Native())

	ret := C.gtk_application_get_active_window(arg0)

	var ret0 Window

	ret0 = WrapWindow(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// MenuByID gets a menu from automatically loaded resources. See [Automatic
// resources][automatic-resources] for more information.
func (application application) MenuByID(id string) gio.Menu {
	var arg0 *C.GtkApplication
	var arg1 *C.char

	arg0 = (*C.GtkApplication)(application.Native())
	arg1 = (*C.gchar)(C.CString(id))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_application_get_menu_by_id(arg0, arg1)

	var ret0 gio.Menu

	ret0 = gio.WrapMenu(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Menubar returns the menu model that has been set with
// gtk_application_set_menubar().
func (application application) Menubar() gio.MenuModel {
	var arg0 *C.GtkApplication

	arg0 = (*C.GtkApplication)(application.Native())

	ret := C.gtk_application_get_menubar(arg0)

	var ret0 gio.MenuModel

	ret0 = gio.WrapMenuModel(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// WindowByID returns the ApplicationWindow with the given ID.
//
// The ID of a ApplicationWindow can be retrieved with
// gtk_application_window_get_id().
func (application application) WindowByID(id uint) Window {
	var arg0 *C.GtkApplication
	var arg1 C.guint

	arg0 = (*C.GtkApplication)(application.Native())
	arg1 = C.guint(id)

	ret := C.gtk_application_get_window_by_id(arg0, arg1)

	var ret0 Window

	ret0 = WrapWindow(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Windows gets a list of the Windows associated with @application.
//
// The list is sorted by most recently focused window, such that the first
// element is the currently focused window. (Useful for choosing a parent
// for a transient window.)
//
// The list that is returned should not be modified in any way. It will only
// remain valid until the next focus change or window creation or deletion.
func (application application) Windows() *glib.List {
	var arg0 *C.GtkApplication

	arg0 = (*C.GtkApplication)(application.Native())

	ret := C.gtk_application_get_windows(arg0)

	var ret0 *glib.List

	ret0 = glib.WrapList(ret)

	return ret0
}

// Inhibit: inform the session manager that certain types of actions should
// be inhibited. This is not guaranteed to work on all platforms and for all
// types of actions.
//
// Applications should invoke this method when they begin an operation that
// should not be interrupted, such as creating a CD or DVD. The types of
// actions that may be blocked are specified by the @flags parameter. When
// the application completes the operation it should call
// gtk_application_uninhibit() to remove the inhibitor. Note that an
// application can have multiple inhibitors, and all of them must be
// individually removed. Inhibitors are also cleared when the application
// exits.
//
// Applications should not expect that they will always be able to block the
// action. In most cases, users will be given the option to force the action
// to take place.
//
// Reasons should be short and to the point.
//
// If @window is given, the session manager may point the user to this
// window to find out more about why the action is inhibited.
func (application application) Inhibit(window Window, flags ApplicationInhibitFlags, reason string) uint {
	var arg0 *C.GtkApplication
	var arg1 *C.GtkWindow
	var arg2 C.GtkApplicationInhibitFlags
	var arg3 *C.char

	arg0 = (*C.GtkApplication)(application.Native())
	arg1 = (*C.GtkWindow)(window.Native())
	arg2 = (C.GtkApplicationInhibitFlags)(flags)
	arg3 = (*C.gchar)(C.CString(reason))
	defer C.free(unsafe.Pointer(arg3))

	ret := C.gtk_application_inhibit(arg0, arg1, arg2, arg3)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// ListActionDescriptions lists the detailed action names which have
// associated accelerators. See gtk_application_set_accels_for_action().
func (application application) ListActionDescriptions() []string {
	var arg0 *C.GtkApplication

	arg0 = (*C.GtkApplication)(application.Native())

	ret := C.gtk_application_list_action_descriptions(arg0)

	var ret0 []string

	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]string, length)
		for i := 0; i < length; i++ {
			src := (C.utf8)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			ret0[i] = C.GoString(src)
			C.free(unsafe.Pointer(src))
		}
	}

	return ret0
}

// RemoveWindow: remove a window from @application.
//
// If @window belongs to @application then this call is equivalent to
// setting the Window:application property of @window to nil.
//
// The application may stop running as a result of a call to this function.
func (application application) RemoveWindow(window Window) {
	var arg0 *C.GtkApplication
	var arg1 *C.GtkWindow

	arg0 = (*C.GtkApplication)(application.Native())
	arg1 = (*C.GtkWindow)(window.Native())

	C.gtk_application_remove_window(arg0, arg1)
}

// SetAccelsForAction sets zero or more keyboard accelerators that will
// trigger the given action. The first item in @accels will be the primary
// accelerator, which may be displayed in the UI.
//
// To remove all accelerators for an action, use an empty, zero-terminated
// array for @accels.
//
// For the @detailed_action_name, see g_action_parse_detailed_name() and
// g_action_print_detailed_name().
func (application application) SetAccelsForAction(detailedActionName string, accels []string) {
	var arg0 *C.GtkApplication
	var arg1 *C.char
	var arg2 **C.char

	arg0 = (*C.GtkApplication)(application.Native())
	arg1 = (*C.gchar)(C.CString(detailedActionName))
	defer C.free(unsafe.Pointer(arg1))
	{

	}

	C.gtk_application_set_accels_for_action(arg0, arg1, arg2)
}

// SetMenubar sets or unsets the menubar for windows of @application.
//
// This is a menubar in the traditional sense.
//
// This can only be done in the primary instance of the application, after
// it has been registered. #GApplication::startup is a good place to call
// this.
//
// Depending on the desktop environment, this may appear at the top of each
// window, or at the top of the screen. In some environments, if both the
// application menu and the menubar are set, the application menu will be
// presented as if it were the first item of the menubar. Other environments
// treat the two as completely separate — for example, the application menu
// may be rendered by the desktop shell while the menubar (if set) remains
// in each individual window.
//
// Use the base Map interface to add actions, to respond to the user
// selecting these menu items.
func (application application) SetMenubar(menubar gio.MenuModel) {
	var arg0 *C.GtkApplication
	var arg1 *C.GMenuModel

	arg0 = (*C.GtkApplication)(application.Native())
	arg1 = (*C.GMenuModel)(menubar.Native())

	C.gtk_application_set_menubar(arg0, arg1)
}

// Uninhibit removes an inhibitor that has been established with
// gtk_application_inhibit(). Inhibitors are also cleared when the
// application exits.
func (application application) Uninhibit(cookie uint) {
	var arg0 *C.GtkApplication
	var arg1 C.guint

	arg0 = (*C.GtkApplication)(application.Native())
	arg1 = C.guint(cookie)

	C.gtk_application_uninhibit(arg0, arg1)
}

// ApplicationWindow is a Window subclass that offers some extra functionality
// for better integration with Application features. Notably, it can handle an
// application menubar. See gtk_application_set_menubar().
//
// This class implements the Group and Map interfaces, to let you add
// window-specific actions that will be exported by the associated Application,
// together with its application-wide actions. Window-specific actions are
// prefixed with the “win.” prefix and application-wide actions are prefixed
// with the “app.” prefix. Actions must be addressed with the prefixed name when
// referring to them from a Model.
//
// Note that widgets that are placed inside a ApplicationWindow can also
// activate these actions, if they implement the Actionable interface.
//
// As with Application, the GDK lock will be acquired when processing actions
// arriving from other processes and should therefore be held when activating
// actions locally (if GDK threads are enabled).
//
// The settings Settings:gtk-shell-shows-app-menu and
// Settings:gtk-shell-shows-menubar tell GTK+ whether the desktop environment is
// showing the application menu and menubar models outside the application as
// part of the desktop shell. For instance, on OS X, both menus will be
// displayed remotely; on Windows neither will be. gnome-shell (starting with
// version 3.4) will display the application menu, but not the menubar.
//
// If the desktop environment does not display the menubar, then
// ApplicationWindow will automatically show a menubar for it. This behaviour
// can be overridden with the ApplicationWindow:show-menubar property. If the
// desktop environment does not display the application menu, then it will
// automatically be included in the menubar or in the windows client-side
// decorations.
//
// See PopoverMenu for information about the XML language used by Builder for
// menu models.
//
// A GtkApplicationWindow with a menubar
//
//    GtkApplication *app = gtk_application_new ("org.gtk.test", 0);
//
//    GtkBuilder *builder = gtk_builder_new_from_string (
//        "<interface>"
//        "  <menu id='menubar'>"
//        "    <submenu>"
//        "      <attribute name='label' translatable='yes'>_Edit</attribute>"
//        "      <item>"
//        "        <attribute name='label' translatable='yes'>_Copy</attribute>"
//        "        <attribute name='action'>win.copy</attribute>"
//        "      </item>"
//        "      <item>"
//        "        <attribute name='label' translatable='yes'>_Paste</attribute>"
//        "        <attribute name='action'>win.paste</attribute>"
//        "      </item>"
//        "    </submenu>"
//        "  </menu>"
//        "</interface>",
//        -1);
//
//    GMenuModel *menubar = G_MENU_MODEL (gtk_builder_get_object (builder,
//                                                               "menubar"));
//    gtk_application_set_menubar (GTK_APPLICATION (app), menubar);
//    g_object_unref (builder);
//
//    // ...
//
//    GtkWidget *window = gtk_application_window_new (app);
//
type ApplicationWindow interface {
	Window

	// HelpOverlay gets the ShortcutsWindow that has been set up with a prior
	// call to gtk_application_window_set_help_overlay().
	HelpOverlay() ShortcutsWindow
	// ID returns the unique ID of the window. If the window has not yet been
	// added to a Application, returns `0`.
	ID() uint
	// ShowMenubar returns whether the window will display a menubar for the app
	// menu and menubar as needed.
	ShowMenubar() bool
	// SetHelpOverlay associates a shortcuts window with the application window,
	// and sets up an action with the name win.show-help-overlay to present it.
	//
	// @window takes responsibility for destroying @help_overlay.
	SetHelpOverlay(helpOverlay ShortcutsWindow)
	// SetShowMenubar sets whether the window will display a menubar for the app
	// menu and menubar as needed.
	SetShowMenubar(showMenubar bool)
}

type applicationWindow struct {
	window
}

// WrapApplicationWindow wraps a GObject to the right type. It is
// primarily used internally.
func WrapApplicationWindow(obj *externglib.Object) ApplicationWindow {
	return applicationWindow{window{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}}
}

func marshalApplicationWindow(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapApplicationWindow(obj), nil
}

// NewApplicationWindow constructs a class ApplicationWindow.
func NewApplicationWindow(application Application) ApplicationWindow {
	var arg1 *C.GtkApplication

	arg1 = (*C.GtkApplication)(application.Native())

	ret := C.gtk_application_window_new(arg1)

	var ret0 ApplicationWindow

	ret0 = WrapApplicationWindow(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// HelpOverlay gets the ShortcutsWindow that has been set up with a prior
// call to gtk_application_window_set_help_overlay().
func (window applicationWindow) HelpOverlay() ShortcutsWindow {
	var arg0 *C.GtkApplicationWindow

	arg0 = (*C.GtkApplicationWindow)(window.Native())

	ret := C.gtk_application_window_get_help_overlay(arg0)

	var ret0 ShortcutsWindow

	ret0 = WrapShortcutsWindow(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// ID returns the unique ID of the window. If the window has not yet been
// added to a Application, returns `0`.
func (window applicationWindow) ID() uint {
	var arg0 *C.GtkApplicationWindow

	arg0 = (*C.GtkApplicationWindow)(window.Native())

	ret := C.gtk_application_window_get_id(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// ShowMenubar returns whether the window will display a menubar for the app
// menu and menubar as needed.
func (window applicationWindow) ShowMenubar() bool {
	var arg0 *C.GtkApplicationWindow

	arg0 = (*C.GtkApplicationWindow)(window.Native())

	ret := C.gtk_application_window_get_show_menubar(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// SetHelpOverlay associates a shortcuts window with the application window,
// and sets up an action with the name win.show-help-overlay to present it.
//
// @window takes responsibility for destroying @help_overlay.
func (window applicationWindow) SetHelpOverlay(helpOverlay ShortcutsWindow) {
	var arg0 *C.GtkApplicationWindow
	var arg1 *C.GtkShortcutsWindow

	arg0 = (*C.GtkApplicationWindow)(window.Native())
	arg1 = (*C.GtkShortcutsWindow)(helpOverlay.Native())

	C.gtk_application_window_set_help_overlay(arg0, arg1)
}

// SetShowMenubar sets whether the window will display a menubar for the app
// menu and menubar as needed.
func (window applicationWindow) SetShowMenubar(showMenubar bool) {
	var arg0 *C.GtkApplicationWindow
	var arg1 C.gboolean

	arg0 = (*C.GtkApplicationWindow)(window.Native())
	arg1 = gextras.Cbool(showMenubar)

	C.gtk_application_window_set_show_menubar(arg0, arg1)
}

// AspectFrame: gtkAspectFrame is useful when you want pack a widget so that it
// can resize while retaining the same aspect ratio. For instance, one might be
// drawing a small preview of a larger image.
//
// The frame can respect the aspect ratio of the child widget, or use its own
// aspect ratio.
//
//
// CSS nodes
//
// GtkAspectFrame uses a CSS node with name `frame`.
type AspectFrame interface {
	Widget

	// Child gets the child widget of @self.
	Child() Widget
	// ObeyChild returns whether the child's size request should override the
	// set aspect ratio of the AspectFrame.
	ObeyChild() bool
	// Ratio returns the desired aspect ratio of the child set using
	// gtk_aspect_frame_set_ratio().
	Ratio() float32
	// Xalign returns the horizontal alignment of the child within the
	// allocation of the AspectFrame.
	Xalign() float32
	// Yalign returns the vertical alignment of the child within the allocation
	// of the AspectFrame.
	Yalign() float32
	// SetChild sets the child widget of @self.
	SetChild(child Widget)
	// SetObeyChild sets whether the aspect ratio of the child's size request
	// should override the set aspect ratio of the AspectFrame.
	SetObeyChild(obeyChild bool)
	// SetRatio sets the desired aspect ratio of the child.
	SetRatio(ratio float32)
	// SetXalign sets the horizontal alignment of the child within the
	// allocation of the AspectFrame.
	SetXalign(xalign float32)
	// SetYalign sets the vertical alignment of the child within the allocation
	// of the AspectFrame.
	SetYalign(yalign float32)
}

type aspectFrame struct {
	widget
}

// WrapAspectFrame wraps a GObject to the right type. It is
// primarily used internally.
func WrapAspectFrame(obj *externglib.Object) AspectFrame {
	return aspectFrame{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}
}

func marshalAspectFrame(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapAspectFrame(obj), nil
}

// NewAspectFrame constructs a class AspectFrame.
func NewAspectFrame(xalign float32, yalign float32, ratio float32, obeyChild bool) AspectFrame {
	var arg1 C.float
	var arg2 C.float
	var arg3 C.float
	var arg4 C.gboolean

	arg1 = C.float(xalign)
	arg2 = C.float(yalign)
	arg3 = C.float(ratio)
	arg4 = gextras.Cbool(obeyChild)

	ret := C.gtk_aspect_frame_new(arg1, arg2, arg3, arg4)

	var ret0 AspectFrame

	ret0 = WrapAspectFrame(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Child gets the child widget of @self.
func (self aspectFrame) Child() Widget {
	var arg0 *C.GtkAspectFrame

	arg0 = (*C.GtkAspectFrame)(self.Native())

	ret := C.gtk_aspect_frame_get_child(arg0)

	var ret0 Widget

	ret0 = WrapWidget(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// ObeyChild returns whether the child's size request should override the
// set aspect ratio of the AspectFrame.
func (self aspectFrame) ObeyChild() bool {
	var arg0 *C.GtkAspectFrame

	arg0 = (*C.GtkAspectFrame)(self.Native())

	ret := C.gtk_aspect_frame_get_obey_child(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Ratio returns the desired aspect ratio of the child set using
// gtk_aspect_frame_set_ratio().
func (self aspectFrame) Ratio() float32 {
	var arg0 *C.GtkAspectFrame

	arg0 = (*C.GtkAspectFrame)(self.Native())

	ret := C.gtk_aspect_frame_get_ratio(arg0)

	var ret0 float32

	ret0 = float32(ret)

	return ret0
}

// Xalign returns the horizontal alignment of the child within the
// allocation of the AspectFrame.
func (self aspectFrame) Xalign() float32 {
	var arg0 *C.GtkAspectFrame

	arg0 = (*C.GtkAspectFrame)(self.Native())

	ret := C.gtk_aspect_frame_get_xalign(arg0)

	var ret0 float32

	ret0 = float32(ret)

	return ret0
}

// Yalign returns the vertical alignment of the child within the allocation
// of the AspectFrame.
func (self aspectFrame) Yalign() float32 {
	var arg0 *C.GtkAspectFrame

	arg0 = (*C.GtkAspectFrame)(self.Native())

	ret := C.gtk_aspect_frame_get_yalign(arg0)

	var ret0 float32

	ret0 = float32(ret)

	return ret0
}

// SetChild sets the child widget of @self.
func (self aspectFrame) SetChild(child Widget) {
	var arg0 *C.GtkAspectFrame
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkAspectFrame)(self.Native())
	arg1 = (*C.GtkWidget)(child.Native())

	C.gtk_aspect_frame_set_child(arg0, arg1)
}

// SetObeyChild sets whether the aspect ratio of the child's size request
// should override the set aspect ratio of the AspectFrame.
func (self aspectFrame) SetObeyChild(obeyChild bool) {
	var arg0 *C.GtkAspectFrame
	var arg1 C.gboolean

	arg0 = (*C.GtkAspectFrame)(self.Native())
	arg1 = gextras.Cbool(obeyChild)

	C.gtk_aspect_frame_set_obey_child(arg0, arg1)
}

// SetRatio sets the desired aspect ratio of the child.
func (self aspectFrame) SetRatio(ratio float32) {
	var arg0 *C.GtkAspectFrame
	var arg1 C.float

	arg0 = (*C.GtkAspectFrame)(self.Native())
	arg1 = C.float(ratio)

	C.gtk_aspect_frame_set_ratio(arg0, arg1)
}

// SetXalign sets the horizontal alignment of the child within the
// allocation of the AspectFrame.
func (self aspectFrame) SetXalign(xalign float32) {
	var arg0 *C.GtkAspectFrame
	var arg1 C.float

	arg0 = (*C.GtkAspectFrame)(self.Native())
	arg1 = C.float(xalign)

	C.gtk_aspect_frame_set_xalign(arg0, arg1)
}

// SetYalign sets the vertical alignment of the child within the allocation
// of the AspectFrame.
func (self aspectFrame) SetYalign(yalign float32) {
	var arg0 *C.GtkAspectFrame
	var arg1 C.float

	arg0 = (*C.GtkAspectFrame)(self.Native())
	arg1 = C.float(yalign)

	C.gtk_aspect_frame_set_yalign(arg0, arg1)
}

// Assistant: a Assistant is a widget used to represent a generally complex
// operation split up into several steps. Each step consists of one or more
// pages. GtkAssistant guides the user through the pages, and controls the page
// flow to collect the data needed for the operation.
//
// GtkAssistant handles which buttons to show and to make sensitive based on
// page sequence knowledge and the [type][GtkAssistantPageType] of each page in
// addition to state information like the
// [completion][gtk-assistant-set-page-complete] and
// [committed][gtk-assistant-commit] page statuses.
//
// If you have a case that doesn’t quite fit in Assistants way of handling
// buttons, you can use the K_ASSISTANT_PAGE_CUSTOM page type and handle buttons
// yourself.
//
// GtkAssistant maintains a AssistantPage object for each added child, which
// holds additional per-child properties. You obtain the AssistantPage for a
// child with gtk_assistant_get_page().
//
//
// GtkAssistant as GtkBuildable
//
// The GtkAssistant implementation of the Buildable interface exposes the
// @action_area as internal children with the name “action_area”.
//
// To add pages to an assistant in Builder, simply add it as a child to the
// GtkAssistant object. If you need to set per-object properties, create a
// AssistantPage object explicitly, and set the child widget as a property on
// it.
//
//
// CSS nodes
//
// GtkAssistant has a single CSS node with the name window and style class
// .assistant.
type Assistant interface {
	Window

	// AddActionWidget adds a widget to the action area of a Assistant.
	AddActionWidget(child Widget)
	// AppendPage appends a page to the @assistant.
	AppendPage(page Widget) int
	// Commit erases the visited page history so the back button is not shown on
	// the current page, and removes the cancel button from subsequent pages.
	//
	// Use this when the information provided up to the current page is
	// hereafter deemed permanent and cannot be modified or undone. For example,
	// showing a progress page to track a long-running, unreversible operation
	// after the user has clicked apply on a confirmation page.
	Commit()
	// CurrentPage returns the page number of the current page.
	CurrentPage() int
	// NPages returns the number of pages in the @assistant
	NPages() int
	// NthPage returns the child widget contained in page number @page_num.
	NthPage(pageNum int) Widget
	// Page returns the AssistantPage object for @child.
	Page(child Widget) AssistantPage
	// PageComplete gets whether @page is complete.
	PageComplete(page Widget) bool
	// PageTitle gets the title for @page.
	PageTitle(page Widget) string
	// PageType gets the page type of @page.
	PageType(page Widget) AssistantPageType
	// Pages gets a list model of the assistant pages.
	Pages() gio.ListModel
	// InsertPage inserts a page in the @assistant at a given position.
	InsertPage(page Widget, position int) int
	// NextPage: navigate to the next page.
	//
	// It is a programming error to call this function when there is no next
	// page.
	//
	// This function is for use when creating pages of the
	// K_ASSISTANT_PAGE_CUSTOM type.
	NextPage()
	// PrependPage prepends a page to the @assistant.
	PrependPage(page Widget) int
	// PreviousPage: navigate to the previous visited page.
	//
	// It is a programming error to call this function when no previous page is
	// available.
	//
	// This function is for use when creating pages of the
	// K_ASSISTANT_PAGE_CUSTOM type.
	PreviousPage()
	// RemoveActionWidget removes a widget from the action area of a Assistant.
	RemoveActionWidget(child Widget)
	// RemovePage removes the @page_num’s page from @assistant.
	RemovePage(pageNum int)
	// SetCurrentPage switches the page to @page_num.
	//
	// Note that this will only be necessary in custom buttons, as the
	// @assistant flow can be set with gtk_assistant_set_forward_page_func().
	SetCurrentPage(pageNum int)
	// SetForwardPageFunc sets the page forwarding function to be @page_func.
	//
	// This function will be used to determine what will be the next page when
	// the user presses the forward button. Setting @page_func to nil will make
	// the assistant to use the default forward function, which just goes to the
	// next visible page.
	SetForwardPageFunc(pageFunc AssistantPageFunc)
	// SetPageComplete sets whether @page contents are complete.
	//
	// This will make @assistant update the buttons state to be able to continue
	// the task.
	SetPageComplete(page Widget, complete bool)
	// SetPageTitle sets a title for @page.
	//
	// The title is displayed in the header area of the assistant when @page is
	// the current page.
	SetPageTitle(page Widget, title string)
	// SetPageType sets the page type for @page.
	//
	// The page type determines the page behavior in the @assistant.
	SetPageType(page Widget, _type AssistantPageType)
	// UpdateButtonsState forces @assistant to recompute the buttons state.
	//
	// GTK automatically takes care of this in most situations, e.g. when the
	// user goes to a different page, or when the visibility or completeness of
	// a page changes.
	//
	// One situation where it can be necessary to call this function is when
	// changing a value on the current page affects the future page flow of the
	// assistant.
	UpdateButtonsState()
}

type assistant struct {
	window
}

// WrapAssistant wraps a GObject to the right type. It is
// primarily used internally.
func WrapAssistant(obj *externglib.Object) Assistant {
	return assistant{window{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}}
}

func marshalAssistant(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapAssistant(obj), nil
}

// NewAssistant constructs a class Assistant.
func NewAssistant() Assistant {

	ret := C.gtk_assistant_new()

	var ret0 Assistant

	ret0 = WrapAssistant(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// AddActionWidget adds a widget to the action area of a Assistant.
func (assistant assistant) AddActionWidget(child Widget) {
	var arg0 *C.GtkAssistant
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkAssistant)(assistant.Native())
	arg1 = (*C.GtkWidget)(child.Native())

	C.gtk_assistant_add_action_widget(arg0, arg1)
}

// AppendPage appends a page to the @assistant.
func (assistant assistant) AppendPage(page Widget) int {
	var arg0 *C.GtkAssistant
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkAssistant)(assistant.Native())
	arg1 = (*C.GtkWidget)(page.Native())

	ret := C.gtk_assistant_append_page(arg0, arg1)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Commit erases the visited page history so the back button is not shown on
// the current page, and removes the cancel button from subsequent pages.
//
// Use this when the information provided up to the current page is
// hereafter deemed permanent and cannot be modified or undone. For example,
// showing a progress page to track a long-running, unreversible operation
// after the user has clicked apply on a confirmation page.
func (assistant assistant) Commit() {
	var arg0 *C.GtkAssistant

	arg0 = (*C.GtkAssistant)(assistant.Native())

	C.gtk_assistant_commit(arg0)
}

// CurrentPage returns the page number of the current page.
func (assistant assistant) CurrentPage() int {
	var arg0 *C.GtkAssistant

	arg0 = (*C.GtkAssistant)(assistant.Native())

	ret := C.gtk_assistant_get_current_page(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// NPages returns the number of pages in the @assistant
func (assistant assistant) NPages() int {
	var arg0 *C.GtkAssistant

	arg0 = (*C.GtkAssistant)(assistant.Native())

	ret := C.gtk_assistant_get_n_pages(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// NthPage returns the child widget contained in page number @page_num.
func (assistant assistant) NthPage(pageNum int) Widget {
	var arg0 *C.GtkAssistant
	var arg1 C.int

	arg0 = (*C.GtkAssistant)(assistant.Native())
	arg1 = C.int(pageNum)

	ret := C.gtk_assistant_get_nth_page(arg0, arg1)

	var ret0 Widget

	ret0 = WrapWidget(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Page returns the AssistantPage object for @child.
func (assistant assistant) Page(child Widget) AssistantPage {
	var arg0 *C.GtkAssistant
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkAssistant)(assistant.Native())
	arg1 = (*C.GtkWidget)(child.Native())

	ret := C.gtk_assistant_get_page(arg0, arg1)

	var ret0 AssistantPage

	ret0 = WrapAssistantPage(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// PageComplete gets whether @page is complete.
func (assistant assistant) PageComplete(page Widget) bool {
	var arg0 *C.GtkAssistant
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkAssistant)(assistant.Native())
	arg1 = (*C.GtkWidget)(page.Native())

	ret := C.gtk_assistant_get_page_complete(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// PageTitle gets the title for @page.
func (assistant assistant) PageTitle(page Widget) string {
	var arg0 *C.GtkAssistant
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkAssistant)(assistant.Native())
	arg1 = (*C.GtkWidget)(page.Native())

	ret := C.gtk_assistant_get_page_title(arg0, arg1)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// PageType gets the page type of @page.
func (assistant assistant) PageType(page Widget) AssistantPageType {
	var arg0 *C.GtkAssistant
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkAssistant)(assistant.Native())
	arg1 = (*C.GtkWidget)(page.Native())

	ret := C.gtk_assistant_get_page_type(arg0, arg1)

	var ret0 AssistantPageType

	ret0 = AssistantPageType(ret)

	return ret0
}

// Pages gets a list model of the assistant pages.
func (assistant assistant) Pages() gio.ListModel {
	var arg0 *C.GtkAssistant

	arg0 = (*C.GtkAssistant)(assistant.Native())

	ret := C.gtk_assistant_get_pages(arg0)

	var ret0 gio.ListModel

	return ret0
}

// InsertPage inserts a page in the @assistant at a given position.
func (assistant assistant) InsertPage(page Widget, position int) int {
	var arg0 *C.GtkAssistant
	var arg1 *C.GtkWidget
	var arg2 C.int

	arg0 = (*C.GtkAssistant)(assistant.Native())
	arg1 = (*C.GtkWidget)(page.Native())
	arg2 = C.int(position)

	ret := C.gtk_assistant_insert_page(arg0, arg1, arg2)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// NextPage: navigate to the next page.
//
// It is a programming error to call this function when there is no next
// page.
//
// This function is for use when creating pages of the
// K_ASSISTANT_PAGE_CUSTOM type.
func (assistant assistant) NextPage() {
	var arg0 *C.GtkAssistant

	arg0 = (*C.GtkAssistant)(assistant.Native())

	C.gtk_assistant_next_page(arg0)
}

// PrependPage prepends a page to the @assistant.
func (assistant assistant) PrependPage(page Widget) int {
	var arg0 *C.GtkAssistant
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkAssistant)(assistant.Native())
	arg1 = (*C.GtkWidget)(page.Native())

	ret := C.gtk_assistant_prepend_page(arg0, arg1)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// PreviousPage: navigate to the previous visited page.
//
// It is a programming error to call this function when no previous page is
// available.
//
// This function is for use when creating pages of the
// K_ASSISTANT_PAGE_CUSTOM type.
func (assistant assistant) PreviousPage() {
	var arg0 *C.GtkAssistant

	arg0 = (*C.GtkAssistant)(assistant.Native())

	C.gtk_assistant_previous_page(arg0)
}

// RemoveActionWidget removes a widget from the action area of a Assistant.
func (assistant assistant) RemoveActionWidget(child Widget) {
	var arg0 *C.GtkAssistant
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkAssistant)(assistant.Native())
	arg1 = (*C.GtkWidget)(child.Native())

	C.gtk_assistant_remove_action_widget(arg0, arg1)
}

// RemovePage removes the @page_num’s page from @assistant.
func (assistant assistant) RemovePage(pageNum int) {
	var arg0 *C.GtkAssistant
	var arg1 C.int

	arg0 = (*C.GtkAssistant)(assistant.Native())
	arg1 = C.int(pageNum)

	C.gtk_assistant_remove_page(arg0, arg1)
}

// SetCurrentPage switches the page to @page_num.
//
// Note that this will only be necessary in custom buttons, as the
// @assistant flow can be set with gtk_assistant_set_forward_page_func().
func (assistant assistant) SetCurrentPage(pageNum int) {
	var arg0 *C.GtkAssistant
	var arg1 C.int

	arg0 = (*C.GtkAssistant)(assistant.Native())
	arg1 = C.int(pageNum)

	C.gtk_assistant_set_current_page(arg0, arg1)
}

// SetForwardPageFunc sets the page forwarding function to be @page_func.
//
// This function will be used to determine what will be the next page when
// the user presses the forward button. Setting @page_func to nil will make
// the assistant to use the default forward function, which just goes to the
// next visible page.
func (assistant assistant) SetForwardPageFunc(pageFunc AssistantPageFunc) {
	var arg0 *C.GtkAssistant
	var arg1 C.GtkAssistantPageFunc
	arg2 := C.gpointer(box.Assign(data))

	arg0 = (*C.GtkAssistant)(assistant.Native())
	arg1 = (*[0]byte)(C.gotk4_AssistantPageFunc)

	C.gtk_assistant_set_forward_page_func(arg0, arg1, (*[0]byte)(C.callbackDelete))
}

// SetPageComplete sets whether @page contents are complete.
//
// This will make @assistant update the buttons state to be able to continue
// the task.
func (assistant assistant) SetPageComplete(page Widget, complete bool) {
	var arg0 *C.GtkAssistant
	var arg1 *C.GtkWidget
	var arg2 C.gboolean

	arg0 = (*C.GtkAssistant)(assistant.Native())
	arg1 = (*C.GtkWidget)(page.Native())
	arg2 = gextras.Cbool(complete)

	C.gtk_assistant_set_page_complete(arg0, arg1, arg2)
}

// SetPageTitle sets a title for @page.
//
// The title is displayed in the header area of the assistant when @page is
// the current page.
func (assistant assistant) SetPageTitle(page Widget, title string) {
	var arg0 *C.GtkAssistant
	var arg1 *C.GtkWidget
	var arg2 *C.char

	arg0 = (*C.GtkAssistant)(assistant.Native())
	arg1 = (*C.GtkWidget)(page.Native())
	arg2 = (*C.gchar)(C.CString(title))
	defer C.free(unsafe.Pointer(arg2))

	C.gtk_assistant_set_page_title(arg0, arg1, arg2)
}

// SetPageType sets the page type for @page.
//
// The page type determines the page behavior in the @assistant.
func (assistant assistant) SetPageType(page Widget, _type AssistantPageType) {
	var arg0 *C.GtkAssistant
	var arg1 *C.GtkWidget
	var arg2 C.GtkAssistantPageType

	arg0 = (*C.GtkAssistant)(assistant.Native())
	arg1 = (*C.GtkWidget)(page.Native())
	arg2 = (C.GtkAssistantPageType)(_type)

	C.gtk_assistant_set_page_type(arg0, arg1, arg2)
}

// UpdateButtonsState forces @assistant to recompute the buttons state.
//
// GTK automatically takes care of this in most situations, e.g. when the
// user goes to a different page, or when the visibility or completeness of
// a page changes.
//
// One situation where it can be necessary to call this function is when
// changing a value on the current page affects the future page flow of the
// assistant.
func (assistant assistant) UpdateButtonsState() {
	var arg0 *C.GtkAssistant

	arg0 = (*C.GtkAssistant)(assistant.Native())

	C.gtk_assistant_update_buttons_state(arg0)
}

type AssistantPage interface {
	gextras.Objector

	// Child returns the child to which @page belongs.
	Child() Widget
}

type assistantPage struct {
	*externglib.Object
}

// WrapAssistantPage wraps a GObject to the right type. It is
// primarily used internally.
func WrapAssistantPage(obj *externglib.Object) AssistantPage {
	return assistantPage{*externglib.Object{obj}}
}

func marshalAssistantPage(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapAssistantPage(obj), nil
}

// Child returns the child to which @page belongs.
func (page assistantPage) Child() Widget {
	var arg0 *C.GtkAssistantPage

	arg0 = (*C.GtkAssistantPage)(page.Native())

	ret := C.gtk_assistant_page_get_child(arg0)

	var ret0 Widget

	ret0 = WrapWidget(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// BinLayout: gtkBinLayout is a LayoutManager subclass useful for create "bins"
// of widgets. GtkBinLayout will stack each child of a widget on top of each
// other, using the Widget:hexpand, Widget:vexpand, Widget:halign, and
// Widget:valign properties of each child to determine where they should be
// positioned.
type BinLayout interface {
	LayoutManager
}

type binLayout struct {
	layoutManager
}

// WrapBinLayout wraps a GObject to the right type. It is
// primarily used internally.
func WrapBinLayout(obj *externglib.Object) BinLayout {
	return binLayout{layoutManager{*externglib.Object{obj}}}
}

func marshalBinLayout(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapBinLayout(obj), nil
}

// NewBinLayout constructs a class BinLayout.
func NewBinLayout() BinLayout {

	ret := C.gtk_bin_layout_new()

	var ret0 BinLayout

	ret0 = WrapBinLayout(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// BookmarkList is a list model that wraps GBookmarkFile. It presents a Model
// and fills it asynchronously with the Infos returned from that function.
//
// The Infos in the list have some attributes in the recent namespace added:
// recent::private (boolean) and recent:applications (stringv).
type BookmarkList interface {
	gextras.Objector

	// Attributes gets the attributes queried on the children.
	Attributes() string
	// Filename returns the filename of the bookmark file that this list is
	// loading.
	Filename() string
	// IOPriority gets the IO priority set via
	// gtk_bookmark_list_set_io_priority().
	IOPriority() int
	// IsLoading returns true if the files are currently being loaded.
	//
	// Files will be added to @self from time to time while loading is going on.
	// The order in which are added is undefined and may change in between runs.
	IsLoading() bool
	// SetAttributes sets the @attributes to be enumerated and starts the
	// enumeration.
	//
	// If @attributes is nil, no attributes will be queried, but a list of Infos
	// will still be created.
	SetAttributes(attributes string)
	// SetIOPriority sets the IO priority to use while loading files.
	//
	// The default IO priority is G_PRIORITY_DEFAULT.
	SetIOPriority(ioPriority int)
}

type bookmarkList struct {
	*externglib.Object
}

// WrapBookmarkList wraps a GObject to the right type. It is
// primarily used internally.
func WrapBookmarkList(obj *externglib.Object) BookmarkList {
	return bookmarkList{*externglib.Object{obj}}
}

func marshalBookmarkList(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapBookmarkList(obj), nil
}

// NewBookmarkList constructs a class BookmarkList.
func NewBookmarkList(filename string, attributes string) BookmarkList {
	var arg1 *C.char
	var arg2 *C.char

	arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(attributes))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.gtk_bookmark_list_new(arg1, arg2)

	var ret0 BookmarkList

	ret0 = WrapBookmarkList(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Attributes gets the attributes queried on the children.
func (self bookmarkList) Attributes() string {
	var arg0 *C.GtkBookmarkList

	arg0 = (*C.GtkBookmarkList)(self.Native())

	ret := C.gtk_bookmark_list_get_attributes(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Filename returns the filename of the bookmark file that this list is
// loading.
func (self bookmarkList) Filename() string {
	var arg0 *C.GtkBookmarkList

	arg0 = (*C.GtkBookmarkList)(self.Native())

	ret := C.gtk_bookmark_list_get_filename(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// IOPriority gets the IO priority set via
// gtk_bookmark_list_set_io_priority().
func (self bookmarkList) IOPriority() int {
	var arg0 *C.GtkBookmarkList

	arg0 = (*C.GtkBookmarkList)(self.Native())

	ret := C.gtk_bookmark_list_get_io_priority(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// IsLoading returns true if the files are currently being loaded.
//
// Files will be added to @self from time to time while loading is going on.
// The order in which are added is undefined and may change in between runs.
func (self bookmarkList) IsLoading() bool {
	var arg0 *C.GtkBookmarkList

	arg0 = (*C.GtkBookmarkList)(self.Native())

	ret := C.gtk_bookmark_list_is_loading(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// SetAttributes sets the @attributes to be enumerated and starts the
// enumeration.
//
// If @attributes is nil, no attributes will be queried, but a list of Infos
// will still be created.
func (self bookmarkList) SetAttributes(attributes string) {
	var arg0 *C.GtkBookmarkList
	var arg1 *C.char

	arg0 = (*C.GtkBookmarkList)(self.Native())
	arg1 = (*C.gchar)(C.CString(attributes))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_bookmark_list_set_attributes(arg0, arg1)
}

// SetIOPriority sets the IO priority to use while loading files.
//
// The default IO priority is G_PRIORITY_DEFAULT.
func (self bookmarkList) SetIOPriority(ioPriority int) {
	var arg0 *C.GtkBookmarkList
	var arg1 C.int

	arg0 = (*C.GtkBookmarkList)(self.Native())
	arg1 = C.int(ioPriority)

	C.gtk_bookmark_list_set_io_priority(arg0, arg1)
}

// BoolFilter: gtkBoolFilter is a simple filter that takes a boolean Expression
// to determine whether to include items.
type BoolFilter interface {
	Filter

	// Expression gets the expression that the filter uses to evaluate if an
	// item should be filtered.
	Expression() Expression
	// Invert returns whether the filter inverts the expression.
	Invert() bool
	// SetExpression sets the expression that the filter uses to check if items
	// should be filtered. The expression must have a value type of
	// TYPE_BOOLEAN.
	SetExpression(expression Expression)
	// SetInvert sets whether the filter should invert the expression.
	SetInvert(invert bool)
}

type boolFilter struct {
	filter
}

// WrapBoolFilter wraps a GObject to the right type. It is
// primarily used internally.
func WrapBoolFilter(obj *externglib.Object) BoolFilter {
	return boolFilter{filter{*externglib.Object{obj}}}
}

func marshalBoolFilter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapBoolFilter(obj), nil
}

// NewBoolFilter constructs a class BoolFilter.
func NewBoolFilter(expression Expression) BoolFilter {
	var arg1 *C.GtkExpression

	arg1 = (*C.GtkExpression)(expression.Native())

	ret := C.gtk_bool_filter_new(arg1)

	var ret0 BoolFilter

	ret0 = WrapBoolFilter(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Expression gets the expression that the filter uses to evaluate if an
// item should be filtered.
func (self boolFilter) Expression() Expression {
	var arg0 *C.GtkBoolFilter

	arg0 = (*C.GtkBoolFilter)(self.Native())

	ret := C.gtk_bool_filter_get_expression(arg0)

	var ret0 Expression

	ret0 = WrapExpression(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Invert returns whether the filter inverts the expression.
func (self boolFilter) Invert() bool {
	var arg0 *C.GtkBoolFilter

	arg0 = (*C.GtkBoolFilter)(self.Native())

	ret := C.gtk_bool_filter_get_invert(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// SetExpression sets the expression that the filter uses to check if items
// should be filtered. The expression must have a value type of
// TYPE_BOOLEAN.
func (self boolFilter) SetExpression(expression Expression) {
	var arg0 *C.GtkBoolFilter
	var arg1 *C.GtkExpression

	arg0 = (*C.GtkBoolFilter)(self.Native())
	arg1 = (*C.GtkExpression)(expression.Native())

	C.gtk_bool_filter_set_expression(arg0, arg1)
}

// SetInvert sets whether the filter should invert the expression.
func (self boolFilter) SetInvert(invert bool) {
	var arg0 *C.GtkBoolFilter
	var arg1 C.gboolean

	arg0 = (*C.GtkBoolFilter)(self.Native())
	arg1 = gextras.Cbool(invert)

	C.gtk_bool_filter_set_invert(arg0, arg1)
}

// Box: the GtkBox widget arranges child widgets into a single row or column,
// depending upon the value of its Orientable:orientation property. Within the
// other dimension, all children are allocated the same size. Of course, the
// Widget:halign and Widget:valign properties can be used on the children to
// influence their allocation.
//
// Use repeated calls to gtk_box_append() to pack widgets into a GtkBox from
// start to end. Use gtk_box_remove() to remove widgets from the GtkBox.
// gtk_box_insert_child_after() can be used to add a child at a particular
// position.
//
// Use gtk_box_set_homogeneous() to specify whether or not all children of the
// GtkBox are forced to get the same amount of space.
//
// Use gtk_box_set_spacing() to determine how much space will be minimally
// placed between all children in the GtkBox. Note that spacing is added between
// the children.
//
// Use gtk_box_reorder_child_after() to move a child to a different place in the
// box.
//
//
// CSS nodes
//
// GtkBox uses a single CSS node with name box.
//
//
// Accessibility
//
// GtkBox uses the GTK_ACCESSIBLE_ROLE_GROUP role.
type Box interface {
	Widget

	// Append adds @child as the last child to @box.
	Append(child Widget)
	// BaselinePosition gets the value set by gtk_box_set_baseline_position().
	BaselinePosition() BaselinePosition
	// Homogeneous returns whether the box is homogeneous (all children are the
	// same size). See gtk_box_set_homogeneous().
	Homogeneous() bool
	// Spacing gets the value set by gtk_box_set_spacing().
	Spacing() int
	// InsertChildAfter inserts @child in the position after @sibling in the
	// list of @box children. If @sibling is nil, insert @child at the first
	// position.
	InsertChildAfter(child Widget, sibling Widget)
	// Prepend adds @child as the first child to @box.
	Prepend(child Widget)
	// Remove removes a child widget from @box, after it has been added with
	// gtk_box_append(), gtk_box_prepend(), or gtk_box_insert_child_after().
	Remove(child Widget)
	// ReorderChildAfter moves @child to the position after @sibling in the list
	// of @box children. If @sibling is nil, move @child to the first position.
	ReorderChildAfter(child Widget, sibling Widget)
	// SetBaselinePosition sets the baseline position of a box. This affects
	// only horizontal boxes with at least one baseline aligned child. If there
	// is more vertical space available than requested, and the baseline is not
	// allocated by the parent then @position is used to allocate the baseline
	// wrt the extra space available.
	SetBaselinePosition(position BaselinePosition)
	// SetHomogeneous sets the Box:homogeneous property of @box, controlling
	// whether or not all children of @box are given equal space in the box.
	SetHomogeneous(homogeneous bool)
	// SetSpacing sets the Box:spacing property of @box, which is the number of
	// pixels to place between children of @box.
	SetSpacing(spacing int)
}

type box struct {
	widget
}

// WrapBox wraps a GObject to the right type. It is
// primarily used internally.
func WrapBox(obj *externglib.Object) Box {
	return box{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}
}

func marshalBox(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapBox(obj), nil
}

// NewBox constructs a class Box.
func NewBox(orientation Orientation, spacing int) Box {
	var arg1 C.GtkOrientation
	var arg2 C.int

	arg1 = (C.GtkOrientation)(orientation)
	arg2 = C.int(spacing)

	ret := C.gtk_box_new(arg1, arg2)

	var ret0 Box

	ret0 = WrapBox(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Append adds @child as the last child to @box.
func (box box) Append(child Widget) {
	var arg0 *C.GtkBox
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkBox)(box.Native())
	arg1 = (*C.GtkWidget)(child.Native())

	C.gtk_box_append(arg0, arg1)
}

// BaselinePosition gets the value set by gtk_box_set_baseline_position().
func (box box) BaselinePosition() BaselinePosition {
	var arg0 *C.GtkBox

	arg0 = (*C.GtkBox)(box.Native())

	ret := C.gtk_box_get_baseline_position(arg0)

	var ret0 BaselinePosition

	ret0 = BaselinePosition(ret)

	return ret0
}

// Homogeneous returns whether the box is homogeneous (all children are the
// same size). See gtk_box_set_homogeneous().
func (box box) Homogeneous() bool {
	var arg0 *C.GtkBox

	arg0 = (*C.GtkBox)(box.Native())

	ret := C.gtk_box_get_homogeneous(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Spacing gets the value set by gtk_box_set_spacing().
func (box box) Spacing() int {
	var arg0 *C.GtkBox

	arg0 = (*C.GtkBox)(box.Native())

	ret := C.gtk_box_get_spacing(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// InsertChildAfter inserts @child in the position after @sibling in the
// list of @box children. If @sibling is nil, insert @child at the first
// position.
func (box box) InsertChildAfter(child Widget, sibling Widget) {
	var arg0 *C.GtkBox
	var arg1 *C.GtkWidget
	var arg2 *C.GtkWidget

	arg0 = (*C.GtkBox)(box.Native())
	arg1 = (*C.GtkWidget)(child.Native())
	arg2 = (*C.GtkWidget)(sibling.Native())

	C.gtk_box_insert_child_after(arg0, arg1, arg2)
}

// Prepend adds @child as the first child to @box.
func (box box) Prepend(child Widget) {
	var arg0 *C.GtkBox
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkBox)(box.Native())
	arg1 = (*C.GtkWidget)(child.Native())

	C.gtk_box_prepend(arg0, arg1)
}

// Remove removes a child widget from @box, after it has been added with
// gtk_box_append(), gtk_box_prepend(), or gtk_box_insert_child_after().
func (box box) Remove(child Widget) {
	var arg0 *C.GtkBox
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkBox)(box.Native())
	arg1 = (*C.GtkWidget)(child.Native())

	C.gtk_box_remove(arg0, arg1)
}

// ReorderChildAfter moves @child to the position after @sibling in the list
// of @box children. If @sibling is nil, move @child to the first position.
func (box box) ReorderChildAfter(child Widget, sibling Widget) {
	var arg0 *C.GtkBox
	var arg1 *C.GtkWidget
	var arg2 *C.GtkWidget

	arg0 = (*C.GtkBox)(box.Native())
	arg1 = (*C.GtkWidget)(child.Native())
	arg2 = (*C.GtkWidget)(sibling.Native())

	C.gtk_box_reorder_child_after(arg0, arg1, arg2)
}

// SetBaselinePosition sets the baseline position of a box. This affects
// only horizontal boxes with at least one baseline aligned child. If there
// is more vertical space available than requested, and the baseline is not
// allocated by the parent then @position is used to allocate the baseline
// wrt the extra space available.
func (box box) SetBaselinePosition(position BaselinePosition) {
	var arg0 *C.GtkBox
	var arg1 C.GtkBaselinePosition

	arg0 = (*C.GtkBox)(box.Native())
	arg1 = (C.GtkBaselinePosition)(position)

	C.gtk_box_set_baseline_position(arg0, arg1)
}

// SetHomogeneous sets the Box:homogeneous property of @box, controlling
// whether or not all children of @box are given equal space in the box.
func (box box) SetHomogeneous(homogeneous bool) {
	var arg0 *C.GtkBox
	var arg1 C.gboolean

	arg0 = (*C.GtkBox)(box.Native())
	arg1 = gextras.Cbool(homogeneous)

	C.gtk_box_set_homogeneous(arg0, arg1)
}

// SetSpacing sets the Box:spacing property of @box, which is the number of
// pixels to place between children of @box.
func (box box) SetSpacing(spacing int) {
	var arg0 *C.GtkBox
	var arg1 C.int

	arg0 = (*C.GtkBox)(box.Native())
	arg1 = C.int(spacing)

	C.gtk_box_set_spacing(arg0, arg1)
}

// BoxLayout: a GtkBoxLayout is a layout manager that arranges the children of
// any widget using it into a single row or column, depending on the value of
// its Orientable:orientation property. Within the other dimension all children
// all allocated the same size. The GtkBoxLayout will respect the Widget:halign
// and Widget:valign properties of each child widget.
//
// If you want all children to be assigned the same size, you can use the
// BoxLayout:homogeneous property.
//
// If you want to specify the amount of space placed between each child, you can
// use the BoxLayout:spacing property.
type BoxLayout interface {
	LayoutManager

	// BaselinePosition gets the value set by
	// gtk_box_layout_set_baseline_position().
	BaselinePosition() BaselinePosition
	// Homogeneous returns whether the layout is set to be homogeneous.
	Homogeneous() bool
	// Spacing returns the space that @box_layout puts between children.
	Spacing() uint
	// SetBaselinePosition sets the baseline position of a box layout.
	//
	// The baseline position affects only horizontal boxes with at least one
	// baseline aligned child. If there is more vertical space available than
	// requested, and the baseline is not allocated by the parent then the given
	// @position is used to allocate the baseline within the extra space
	// available.
	SetBaselinePosition(position BaselinePosition)
	// SetHomogeneous sets whether the box layout will allocate the same size to
	// all children.
	SetHomogeneous(homogeneous bool)
	// SetSpacing sets how much spacing to put between children.
	SetSpacing(spacing uint)
}

type boxLayout struct {
	layoutManager
}

// WrapBoxLayout wraps a GObject to the right type. It is
// primarily used internally.
func WrapBoxLayout(obj *externglib.Object) BoxLayout {
	return boxLayout{layoutManager{*externglib.Object{obj}}}
}

func marshalBoxLayout(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapBoxLayout(obj), nil
}

// NewBoxLayout constructs a class BoxLayout.
func NewBoxLayout(orientation Orientation) BoxLayout {
	var arg1 C.GtkOrientation

	arg1 = (C.GtkOrientation)(orientation)

	ret := C.gtk_box_layout_new(arg1)

	var ret0 BoxLayout

	ret0 = WrapBoxLayout(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// BaselinePosition gets the value set by
// gtk_box_layout_set_baseline_position().
func (boxLayout boxLayout) BaselinePosition() BaselinePosition {
	var arg0 *C.GtkBoxLayout

	arg0 = (*C.GtkBoxLayout)(boxLayout.Native())

	ret := C.gtk_box_layout_get_baseline_position(arg0)

	var ret0 BaselinePosition

	ret0 = BaselinePosition(ret)

	return ret0
}

// Homogeneous returns whether the layout is set to be homogeneous.
func (boxLayout boxLayout) Homogeneous() bool {
	var arg0 *C.GtkBoxLayout

	arg0 = (*C.GtkBoxLayout)(boxLayout.Native())

	ret := C.gtk_box_layout_get_homogeneous(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Spacing returns the space that @box_layout puts between children.
func (boxLayout boxLayout) Spacing() uint {
	var arg0 *C.GtkBoxLayout

	arg0 = (*C.GtkBoxLayout)(boxLayout.Native())

	ret := C.gtk_box_layout_get_spacing(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// SetBaselinePosition sets the baseline position of a box layout.
//
// The baseline position affects only horizontal boxes with at least one
// baseline aligned child. If there is more vertical space available than
// requested, and the baseline is not allocated by the parent then the given
// @position is used to allocate the baseline within the extra space
// available.
func (boxLayout boxLayout) SetBaselinePosition(position BaselinePosition) {
	var arg0 *C.GtkBoxLayout
	var arg1 C.GtkBaselinePosition

	arg0 = (*C.GtkBoxLayout)(boxLayout.Native())
	arg1 = (C.GtkBaselinePosition)(position)

	C.gtk_box_layout_set_baseline_position(arg0, arg1)
}

// SetHomogeneous sets whether the box layout will allocate the same size to
// all children.
func (boxLayout boxLayout) SetHomogeneous(homogeneous bool) {
	var arg0 *C.GtkBoxLayout
	var arg1 C.gboolean

	arg0 = (*C.GtkBoxLayout)(boxLayout.Native())
	arg1 = gextras.Cbool(homogeneous)

	C.gtk_box_layout_set_homogeneous(arg0, arg1)
}

// SetSpacing sets how much spacing to put between children.
func (boxLayout boxLayout) SetSpacing(spacing uint) {
	var arg0 *C.GtkBoxLayout
	var arg1 C.guint

	arg0 = (*C.GtkBoxLayout)(boxLayout.Native())
	arg1 = C.guint(spacing)

	C.gtk_box_layout_set_spacing(arg0, arg1)
}

// Builder: a GtkBuilder is an auxiliary object that reads textual descriptions
// of a user interface and instantiates the described objects. To create a
// GtkBuilder from a user interface description, call
// gtk_builder_new_from_file(), gtk_builder_new_from_resource() or
// gtk_builder_new_from_string().
//
// In the (unusual) case that you want to add user interface descriptions from
// multiple sources to the same GtkBuilder you can call gtk_builder_new() to get
// an empty builder and populate it by (multiple) calls to
// gtk_builder_add_from_file(), gtk_builder_add_from_resource() or
// gtk_builder_add_from_string().
//
// A GtkBuilder holds a reference to all objects that it has constructed and
// drops these references when it is finalized. This finalization can cause the
// destruction of non-widget objects or widgets which are not contained in a
// toplevel window. For toplevel windows constructed by a builder, it is the
// responsibility of the user to call gtk_window_destroy() to get rid of them
// and all the widgets they contain.
//
// The functions gtk_builder_get_object() and gtk_builder_get_objects() can be
// used to access the widgets in the interface by the names assigned to them
// inside the UI description. Toplevel windows returned by these functions will
// stay around until the user explicitly destroys them with
// gtk_window_destroy(). Other widgets will either be part of a larger hierarchy
// constructed by the builder (in which case you should not have to worry about
// their lifecycle), or without a parent, in which case they have to be added to
// some container to make use of them. Non-widget objects need to be reffed with
// g_object_ref() to keep them beyond the lifespan of the builder.
//
//
// GtkBuilder UI Definitions
//
// GtkBuilder parses textual descriptions of user interfaces which are specified
// in XML format. We refer to these descriptions as “GtkBuilder UI definitions”
// or just “UI definitions” if the context is clear.
//
// The toplevel element is `<interface>`. It optionally takes a “domain”
// attribute, which will make the builder look for translated strings using
// `dgettext()` in the domain specified. This can also be done by calling
// gtk_builder_set_translation_domain() on the builder. Objects are described by
// `<object>` elements, which can contain <property> elements to set properties,
// `<signal>` elements which connect signals to handlers, and `<child>`
// elements, which describe child objects (most often widgets inside a
// container, but also e.g. actions in an action group, or columns in a tree
// model). A `<child>` element contains an `<object>` element which describes
// the child object. The target toolkit version(s) are described by <requires>
// elements, the “lib” attribute specifies the widget library in question
// (currently the only supported value is “gtk”) and the “version” attribute
// specifies the target version in the form “`<major>`.`<minor>`”. The builder
// will error out if the version requirements are not met.
//
// Typically, the specific kind of object represented by an `<object>` element
// is specified by the “class” attribute. If the type has not been loaded yet,
// GTK tries to find the `get_type()` function from the class name by applying
// heuristics. This works in most cases, but if necessary, it is possible to
// specify the name of the `get_type()` function explicitly with the "type-func"
// attribute.
//
// Objects may be given a name with the “id” attribute, which allows the
// application to retrieve them from the builder with gtk_builder_get_object().
// An id is also necessary to use the object as property value in other parts of
// the UI definition. GTK reserves ids starting and ending with `___` (three
// consecutive underscores) for its own purposes.
//
// Setting properties of objects is pretty straightforward with the <property>
// element: the “name” attribute specifies the name of the property, and the
// content of the element specifies the value. If the “translatable” attribute
// is set to a true value, GTK uses `gettext()` (or `dgettext()` if the builder
// has a translation domain set) to find a translation for the value. This
// happens before the value is parsed, so it can be used for properties of any
// type, but it is probably most useful for string properties. It is also
// possible to specify a context to disambiguate short strings, and comments
// which may help the translators.
//
// Builder can parse textual representations for the most common property types:
// characters, strings, integers, floating-point numbers, booleans (strings like
// “TRUE”, “t”, “yes”, “y”, “1” are interpreted as true, strings like “FALSE”,
// “f”, “no”, “n”, “0” are interpreted as false), enumerations (can be specified
// by their name, nick or integer value), flags (can be specified by their name,
// nick, integer value, optionally combined with “|”, e.g.
// “GTK_INPUT_HINT_EMOJI|GTK_INPUT_HINT_LOWERCASE”) and colors (in a format
// understood by gdk_rgba_parse()).
//
// GVariants can be specified in the format understood by g_variant_parse(), and
// pixbufs can be specified as a filename of an image file to load.
//
// Objects can be referred to by their name and by default refer to objects
// declared in the local XML fragment and objects exposed via
// gtk_builder_expose_object(). In general, GtkBuilder allows forward references
// to objects — declared in the local XML; an object doesn’t have to be
// constructed before it can be referred to. The exception to this rule is that
// an object has to be constructed before it can be used as the value of a
// construct-only property.
//
// It is also possible to bind a property value to another object's property
// value using the attributes "bind-source" to specify the source object of the
// binding, and optionally, "bind-property" and "bind-flags" to specify the
// source property and source binding flags respectively. Internally builder
// implements this using #GBinding objects. For more information see
// g_object_bind_property()
//
// Sometimes it is necessary to refer to widgets which have implicitly been
// constructed by GTK as part of a composite widget, to set properties on them
// or to add further children (e.g. the content area of a Dialog). This can be
// achieved by setting the “internal-child” property of the `<child>` element to
// a true value. Note that Builder still requires an `<object>` element for the
// internal child, even if it has already been constructed.
//
// A number of widgets have different places where a child can be added (e.g.
// tabs vs. page content in notebooks). This can be reflected in a UI definition
// by specifying the “type” attribute on a `<child>` The possible values for the
// “type” attribute are described in the sections describing the widget-specific
// portions of UI definitions.
//
//
// Signal handlers and function pointers
//
// Signal handlers are set up with the <signal> element. The “name” attribute
// specifies the name of the signal, and the “handler” attribute specifies the
// function to connect to the signal. The remaining attributes, “after”,
// “swapped” and “object”, have the same meaning as the corresponding parameters
// of the g_signal_connect_object() or g_signal_connect_data() functions. A
// “last_modification_time” attribute is also allowed, but it does not have a
// meaning to the builder.
//
// If you rely on #GModule support to lookup callbacks in the symbol table, the
// following details should be noted:
//
// When compiling applications for Windows, you must declare signal callbacks
// with MODULE_EXPORT, or they will not be put in the symbol table. On Linux and
// Unices, this is not necessary; applications should instead be compiled with
// the -Wl,--export-dynamic CFLAGS, and linked against gmodule-export-2.0.
//
// A GtkBuilder UI Definition
//
//
//    <interface>
//      <object class="GtkDialog" id="dialog1">
//        <child internal-child="vbox">
//          <object class="GtkBox" id="vbox1">
//            <child internal-child="action_area">
//              <object class="GtkBox" id="hbuttonbox1">
//                <child>
//                  <object class="GtkButton" id="ok_button">
//                    <property name="label">gtk-ok</property>
//                    <signal name="clicked" handler="ok_button_clicked"/>
//                  </object>
//                </child>
//              </object>
//            </child>
//          </object>
//        </child>
//      </object>
//    </interface>
//
//
// Beyond this general structure, several object classes define their own XML
// DTD fragments for filling in the ANY placeholders in the DTD above. Note that
// a custom element in a <child> element gets parsed by the custom tag handler
// of the parent object, while a custom element in an <object> element gets
// parsed by the custom tag handler of the object.
//
// These XML fragments are explained in the documentation of the respective
// objects.
//
// Additionally, since 3.10 a special <template> tag has been added to the
// format allowing one to define a widget class’s components. See the [GtkWidget
// documentation][composite-templates] for details.
type Builder interface {
	gextras.Objector

	// AddFromFile parses a file containing a [GtkBuilder UI
	// definition][BUILDER-UI] and merges it with the current contents of
	// @builder.
	//
	// This function is useful if you need to call
	// gtk_builder_set_current_object() to add user data to callbacks before
	// loading GtkBuilder UI. Otherwise, you probably want
	// gtk_builder_new_from_file() instead.
	//
	// If an error occurs, 0 will be returned and @error will be assigned a
	// #GError from the K_BUILDER_ERROR, MARKUP_ERROR or FILE_ERROR domain.
	//
	// It’s not really reasonable to attempt to handle failures of this call.
	// You should not use this function with untrusted files (ie: files that are
	// not part of your application). Broken Builder files can easily crash your
	// program, and it’s possible that memory was leaked leading up to the
	// reported failure. The only reasonable thing to do when an error is
	// detected is to call g_error().
	AddFromFile(filename string) bool
	// AddFromResource parses a resource file containing a [GtkBuilder UI
	// definition][BUILDER-UI] and merges it with the current contents of
	// @builder.
	//
	// This function is useful if you need to call
	// gtk_builder_set_current_object() to add user data to callbacks before
	// loading GtkBuilder UI. Otherwise, you probably want
	// gtk_builder_new_from_resource() instead.
	//
	// If an error occurs, 0 will be returned and @error will be assigned a
	// #GError from the K_BUILDER_ERROR, MARKUP_ERROR or RESOURCE_ERROR domain.
	//
	// It’s not really reasonable to attempt to handle failures of this call.
	// The only reasonable thing to do when an error is detected is to call
	// g_error().
	AddFromResource(resourcePath string) bool
	// AddFromString parses a string containing a [GtkBuilder UI
	// definition][BUILDER-UI] and merges it with the current contents of
	// @builder.
	//
	// This function is useful if you need to call
	// gtk_builder_set_current_object() to add user data to callbacks before
	// loading GtkBuilder UI. Otherwise, you probably want
	// gtk_builder_new_from_string() instead.
	//
	// Upon errors false will be returned and @error will be assigned a #GError
	// from the K_BUILDER_ERROR, MARKUP_ERROR or VARIANT_PARSE_ERROR domain.
	//
	// It’s not really reasonable to attempt to handle failures of this call.
	// The only reasonable thing to do when an error is detected is to call
	// g_error().
	AddFromString(buffer string, length int) bool
	// AddObjectsFromFile parses a file containing a [GtkBuilder UI
	// definition][BUILDER-UI] building only the requested objects and merges
	// them with the current contents of @builder.
	//
	// Upon errors 0 will be returned and @error will be assigned a #GError from
	// the K_BUILDER_ERROR, MARKUP_ERROR or FILE_ERROR domain.
	//
	// If you are adding an object that depends on an object that is not its
	// child (for instance a TreeView that depends on its TreeModel), you have
	// to explicitly list all of them in @object_ids.
	AddObjectsFromFile(filename string, objectIds []string) bool
	// AddObjectsFromResource parses a resource file containing a [GtkBuilder UI
	// definition][BUILDER-UI] building only the requested objects and merges
	// them with the current contents of @builder.
	//
	// Upon errors 0 will be returned and @error will be assigned a #GError from
	// the K_BUILDER_ERROR, MARKUP_ERROR or RESOURCE_ERROR domain.
	//
	// If you are adding an object that depends on an object that is not its
	// child (for instance a TreeView that depends on its TreeModel), you have
	// to explicitly list all of them in @object_ids.
	AddObjectsFromResource(resourcePath string, objectIds []string) bool
	// AddObjectsFromString parses a string containing a [GtkBuilder UI
	// definition][BUILDER-UI] building only the requested objects and merges
	// them with the current contents of @builder.
	//
	// Upon errors false will be returned and @error will be assigned a #GError
	// from the K_BUILDER_ERROR or MARKUP_ERROR domain.
	//
	// If you are adding an object that depends on an object that is not its
	// child (for instance a TreeView that depends on its TreeModel), you have
	// to explicitly list all of them in @object_ids.
	AddObjectsFromString(buffer string, length int, objectIds []string) bool
	// CreateClosure creates a closure to invoke the function called
	// @function_name, by using the create_closure() implementation of
	// @builder's BuilderScope.
	//
	// If no closure could be created, nil will be returned and @error will be
	// set.
	CreateClosure(functionName string, flags BuilderClosureFlags, object gextras.Objector) *externglib.Closure
	// ExposeObject: add @object to the @builder object pool so it can be
	// referenced just like any other object built by builder.
	ExposeObject(name string, object gextras.Objector)
	// ExtendWithTemplate: main private entry point for building composite
	// container components from template XML.
	//
	// This is exported purely to let gtk-builder-tool validate templates,
	// applications have no need to call this function.
	ExtendWithTemplate(object gextras.Objector, templateType externglib.Type, buffer string, length int) bool
	// CurrentObject gets the current object set via
	// gtk_builder_set_current_object().
	CurrentObject() gextras.Objector
	// Object gets the object named @name. Note that this function does not
	// increment the reference count of the returned object.
	Object(name string) gextras.Objector
	// Objects gets all objects that have been constructed by @builder. Note
	// that this function does not increment the reference counts of the
	// returned objects.
	Objects() *glib.SList
	// Scope gets the scope in use that was set via gtk_builder_set_scope().
	//
	// See the BuilderScope documentation for details.
	Scope() BuilderScope
	// TranslationDomain gets the translation domain of @builder.
	TranslationDomain() string
	// TypeFromName looks up a type by name, using the virtual function that
	// Builder has for that purpose. This is mainly used when implementing the
	// Buildable interface on a type.
	TypeFromName(typeName string) externglib.Type
	// SetCurrentObject sets the current object for the @builder. The current
	// object can be thought of as the `this` object that the builder is working
	// for and will often be used as the default object when an object is
	// optional.
	//
	// gtk_widget_init_template() for example will set the current object to the
	// widget the template is inited for. For functions like
	// gtk_builder_new_from_resource(), the current object will be nil.
	SetCurrentObject(currentObject gextras.Objector)
	// SetScope sets the scope the builder should operate in.
	//
	// If @scope is nil a new BuilderCScope will be created.
	//
	// See the BuilderScope documentation for details.
	SetScope(scope BuilderScope)
	// SetTranslationDomain sets the translation domain of @builder. See
	// Builder:translation-domain.
	SetTranslationDomain(domain string)
	// ValueFromStringType: like gtk_builder_value_from_string(), this function
	// demarshals a value from a string, but takes a #GType instead of Spec.
	// This function calls g_value_init() on the @value argument, so it need not
	// be initialised beforehand.
	//
	// Upon errors false will be returned and @error will be assigned a #GError
	// from the K_BUILDER_ERROR domain.
	ValueFromStringType(_type externglib.Type, string string) (value externglib.Value, ok bool)
}

type builder struct {
	*externglib.Object
}

// WrapBuilder wraps a GObject to the right type. It is
// primarily used internally.
func WrapBuilder(obj *externglib.Object) Builder {
	return builder{*externglib.Object{obj}}
}

func marshalBuilder(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapBuilder(obj), nil
}

// NewBuilder constructs a class Builder.
func NewBuilder() Builder {

	ret := C.gtk_builder_new()

	var ret0 Builder

	ret0 = WrapBuilder(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewBuilderFromFile constructs a class Builder.
func NewBuilderFromFile(filename string) Builder {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_builder_new_from_file(arg1)

	var ret0 Builder

	ret0 = WrapBuilder(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewBuilderFromResource constructs a class Builder.
func NewBuilderFromResource(resourcePath string) Builder {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(resourcePath))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_builder_new_from_resource(arg1)

	var ret0 Builder

	ret0 = WrapBuilder(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewBuilderFromString constructs a class Builder.
func NewBuilderFromString(string string, length int) Builder {
	var arg1 *C.char
	var arg2 C.gssize

	arg1 = (*C.gchar)(C.CString(string))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gssize(length)

	ret := C.gtk_builder_new_from_string(arg1, arg2)

	var ret0 Builder

	ret0 = WrapBuilder(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// AddFromFile parses a file containing a [GtkBuilder UI
// definition][BUILDER-UI] and merges it with the current contents of
// @builder.
//
// This function is useful if you need to call
// gtk_builder_set_current_object() to add user data to callbacks before
// loading GtkBuilder UI. Otherwise, you probably want
// gtk_builder_new_from_file() instead.
//
// If an error occurs, 0 will be returned and @error will be assigned a
// #GError from the K_BUILDER_ERROR, MARKUP_ERROR or FILE_ERROR domain.
//
// It’s not really reasonable to attempt to handle failures of this call.
// You should not use this function with untrusted files (ie: files that are
// not part of your application). Broken Builder files can easily crash your
// program, and it’s possible that memory was leaked leading up to the
// reported failure. The only reasonable thing to do when an error is
// detected is to call g_error().
func (builder builder) AddFromFile(filename string) bool {
	var arg0 *C.GtkBuilder
	var arg1 *C.char

	arg0 = (*C.GtkBuilder)(builder.Native())
	arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_builder_add_from_file(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// AddFromResource parses a resource file containing a [GtkBuilder UI
// definition][BUILDER-UI] and merges it with the current contents of
// @builder.
//
// This function is useful if you need to call
// gtk_builder_set_current_object() to add user data to callbacks before
// loading GtkBuilder UI. Otherwise, you probably want
// gtk_builder_new_from_resource() instead.
//
// If an error occurs, 0 will be returned and @error will be assigned a
// #GError from the K_BUILDER_ERROR, MARKUP_ERROR or RESOURCE_ERROR domain.
//
// It’s not really reasonable to attempt to handle failures of this call.
// The only reasonable thing to do when an error is detected is to call
// g_error().
func (builder builder) AddFromResource(resourcePath string) bool {
	var arg0 *C.GtkBuilder
	var arg1 *C.char

	arg0 = (*C.GtkBuilder)(builder.Native())
	arg1 = (*C.gchar)(C.CString(resourcePath))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_builder_add_from_resource(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// AddFromString parses a string containing a [GtkBuilder UI
// definition][BUILDER-UI] and merges it with the current contents of
// @builder.
//
// This function is useful if you need to call
// gtk_builder_set_current_object() to add user data to callbacks before
// loading GtkBuilder UI. Otherwise, you probably want
// gtk_builder_new_from_string() instead.
//
// Upon errors false will be returned and @error will be assigned a #GError
// from the K_BUILDER_ERROR, MARKUP_ERROR or VARIANT_PARSE_ERROR domain.
//
// It’s not really reasonable to attempt to handle failures of this call.
// The only reasonable thing to do when an error is detected is to call
// g_error().
func (builder builder) AddFromString(buffer string, length int) bool {
	var arg0 *C.GtkBuilder
	var arg1 *C.char
	var arg2 C.gssize

	arg0 = (*C.GtkBuilder)(builder.Native())
	arg1 = (*C.gchar)(C.CString(buffer))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gssize(length)

	ret := C.gtk_builder_add_from_string(arg0, arg1, arg2)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// AddObjectsFromFile parses a file containing a [GtkBuilder UI
// definition][BUILDER-UI] building only the requested objects and merges
// them with the current contents of @builder.
//
// Upon errors 0 will be returned and @error will be assigned a #GError from
// the K_BUILDER_ERROR, MARKUP_ERROR or FILE_ERROR domain.
//
// If you are adding an object that depends on an object that is not its
// child (for instance a TreeView that depends on its TreeModel), you have
// to explicitly list all of them in @object_ids.
func (builder builder) AddObjectsFromFile(filename string, objectIds []string) bool {
	var arg0 *C.GtkBuilder
	var arg1 *C.char
	var arg2 **C.char

	arg0 = (*C.GtkBuilder)(builder.Native())
	arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))
	{

	}

	ret := C.gtk_builder_add_objects_from_file(arg0, arg1, arg2)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// AddObjectsFromResource parses a resource file containing a [GtkBuilder UI
// definition][BUILDER-UI] building only the requested objects and merges
// them with the current contents of @builder.
//
// Upon errors 0 will be returned and @error will be assigned a #GError from
// the K_BUILDER_ERROR, MARKUP_ERROR or RESOURCE_ERROR domain.
//
// If you are adding an object that depends on an object that is not its
// child (for instance a TreeView that depends on its TreeModel), you have
// to explicitly list all of them in @object_ids.
func (builder builder) AddObjectsFromResource(resourcePath string, objectIds []string) bool {
	var arg0 *C.GtkBuilder
	var arg1 *C.char
	var arg2 **C.char

	arg0 = (*C.GtkBuilder)(builder.Native())
	arg1 = (*C.gchar)(C.CString(resourcePath))
	defer C.free(unsafe.Pointer(arg1))
	{

	}

	ret := C.gtk_builder_add_objects_from_resource(arg0, arg1, arg2)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// AddObjectsFromString parses a string containing a [GtkBuilder UI
// definition][BUILDER-UI] building only the requested objects and merges
// them with the current contents of @builder.
//
// Upon errors false will be returned and @error will be assigned a #GError
// from the K_BUILDER_ERROR or MARKUP_ERROR domain.
//
// If you are adding an object that depends on an object that is not its
// child (for instance a TreeView that depends on its TreeModel), you have
// to explicitly list all of them in @object_ids.
func (builder builder) AddObjectsFromString(buffer string, length int, objectIds []string) bool {
	var arg0 *C.GtkBuilder
	var arg1 *C.char
	var arg2 C.gssize
	var arg3 **C.char

	arg0 = (*C.GtkBuilder)(builder.Native())
	arg1 = (*C.gchar)(C.CString(buffer))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gssize(length)
	{

	}

	ret := C.gtk_builder_add_objects_from_string(arg0, arg1, arg2, arg3)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// CreateClosure creates a closure to invoke the function called
// @function_name, by using the create_closure() implementation of
// @builder's BuilderScope.
//
// If no closure could be created, nil will be returned and @error will be
// set.
func (builder builder) CreateClosure(functionName string, flags BuilderClosureFlags, object gextras.Objector) *externglib.Closure {
	var arg0 *C.GtkBuilder
	var arg1 *C.char
	var arg2 C.GtkBuilderClosureFlags
	var arg3 *C.GObject

	arg0 = (*C.GtkBuilder)(builder.Native())
	arg1 = (*C.gchar)(C.CString(functionName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (C.GtkBuilderClosureFlags)(flags)
	arg3 = (*C.GObject)(object.Native())

	ret := C.gtk_builder_create_closure(arg0, arg1, arg2, arg3)

	var ret0 *externglib.Closure

	return ret0
}

// ExposeObject: add @object to the @builder object pool so it can be
// referenced just like any other object built by builder.
func (builder builder) ExposeObject(name string, object gextras.Objector) {
	var arg0 *C.GtkBuilder
	var arg1 *C.char
	var arg2 *C.GObject

	arg0 = (*C.GtkBuilder)(builder.Native())
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GObject)(object.Native())

	C.gtk_builder_expose_object(arg0, arg1, arg2)
}

// ExtendWithTemplate: main private entry point for building composite
// container components from template XML.
//
// This is exported purely to let gtk-builder-tool validate templates,
// applications have no need to call this function.
func (builder builder) ExtendWithTemplate(object gextras.Objector, templateType externglib.Type, buffer string, length int) bool {
	var arg0 *C.GtkBuilder
	var arg1 *C.GObject
	var arg2 C.GType
	var arg3 *C.char
	var arg4 C.gssize

	arg0 = (*C.GtkBuilder)(builder.Native())
	arg1 = (*C.GObject)(object.Native())
	arg2 = C.GType(templateType)
	arg3 = (*C.gchar)(C.CString(buffer))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = C.gssize(length)

	ret := C.gtk_builder_extend_with_template(arg0, arg1, arg2, arg3, arg4)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// CurrentObject gets the current object set via
// gtk_builder_set_current_object().
func (builder builder) CurrentObject() gextras.Objector {
	var arg0 *C.GtkBuilder

	arg0 = (*C.GtkBuilder)(builder.Native())

	ret := C.gtk_builder_get_current_object(arg0)

	var ret0 gextras.Objector

	ret0 = externglib.Take(unsafe.Pointer(ret.Native()))

	return ret0
}

// Object gets the object named @name. Note that this function does not
// increment the reference count of the returned object.
func (builder builder) Object(name string) gextras.Objector {
	var arg0 *C.GtkBuilder
	var arg1 *C.char

	arg0 = (*C.GtkBuilder)(builder.Native())
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_builder_get_object(arg0, arg1)

	var ret0 gextras.Objector

	ret0 = externglib.Take(unsafe.Pointer(ret.Native()))

	return ret0
}

// Objects gets all objects that have been constructed by @builder. Note
// that this function does not increment the reference counts of the
// returned objects.
func (builder builder) Objects() *glib.SList {
	var arg0 *C.GtkBuilder

	arg0 = (*C.GtkBuilder)(builder.Native())

	ret := C.gtk_builder_get_objects(arg0)

	var ret0 *glib.SList

	ret0 = glib.WrapSList(ret)

	return ret0
}

// Scope gets the scope in use that was set via gtk_builder_set_scope().
//
// See the BuilderScope documentation for details.
func (builder builder) Scope() BuilderScope {
	var arg0 *C.GtkBuilder

	arg0 = (*C.GtkBuilder)(builder.Native())

	ret := C.gtk_builder_get_scope(arg0)

	var ret0 BuilderScope

	return ret0
}

// TranslationDomain gets the translation domain of @builder.
func (builder builder) TranslationDomain() string {
	var arg0 *C.GtkBuilder

	arg0 = (*C.GtkBuilder)(builder.Native())

	ret := C.gtk_builder_get_translation_domain(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// TypeFromName looks up a type by name, using the virtual function that
// Builder has for that purpose. This is mainly used when implementing the
// Buildable interface on a type.
func (builder builder) TypeFromName(typeName string) externglib.Type {
	var arg0 *C.GtkBuilder
	var arg1 *C.char

	arg0 = (*C.GtkBuilder)(builder.Native())
	arg1 = (*C.gchar)(C.CString(typeName))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_builder_get_type_from_name(arg0, arg1)

	var ret0 externglib.Type

	return ret0
}

// SetCurrentObject sets the current object for the @builder. The current
// object can be thought of as the `this` object that the builder is working
// for and will often be used as the default object when an object is
// optional.
//
// gtk_widget_init_template() for example will set the current object to the
// widget the template is inited for. For functions like
// gtk_builder_new_from_resource(), the current object will be nil.
func (builder builder) SetCurrentObject(currentObject gextras.Objector) {
	var arg0 *C.GtkBuilder
	var arg1 *C.GObject

	arg0 = (*C.GtkBuilder)(builder.Native())
	arg1 = (*C.GObject)(currentObject.Native())

	C.gtk_builder_set_current_object(arg0, arg1)
}

// SetScope sets the scope the builder should operate in.
//
// If @scope is nil a new BuilderCScope will be created.
//
// See the BuilderScope documentation for details.
func (builder builder) SetScope(scope BuilderScope) {
	var arg0 *C.GtkBuilder
	var arg1 *C.GtkBuilderScope

	arg0 = (*C.GtkBuilder)(builder.Native())

	C.gtk_builder_set_scope(arg0, arg1)
}

// SetTranslationDomain sets the translation domain of @builder. See
// Builder:translation-domain.
func (builder builder) SetTranslationDomain(domain string) {
	var arg0 *C.GtkBuilder
	var arg1 *C.char

	arg0 = (*C.GtkBuilder)(builder.Native())
	arg1 = (*C.gchar)(C.CString(domain))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_builder_set_translation_domain(arg0, arg1)
}

// ValueFromStringType: like gtk_builder_value_from_string(), this function
// demarshals a value from a string, but takes a #GType instead of Spec.
// This function calls g_value_init() on the @value argument, so it need not
// be initialised beforehand.
//
// Upon errors false will be returned and @error will be assigned a #GError
// from the K_BUILDER_ERROR domain.
func (builder builder) ValueFromStringType(_type externglib.Type, string string) (value externglib.Value, ok bool) {
	var arg0 *C.GtkBuilder
	var arg1 C.GType
	var arg2 *C.char
	var arg3 *C.GValue // out

	arg0 = (*C.GtkBuilder)(builder.Native())
	arg1 = C.GType(_type)
	arg2 = (*C.gchar)(C.CString(string))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.gtk_builder_value_from_string_type(arg0, arg1, arg2, &arg3)

	var ret0 *externglib.Value
	var ret1 bool

	ret1 = gextras.Gobool(ret)

	return ret0, ret1
}

type BuilderCScope interface {
	gextras.Objector

	// AddCallbackSymbol adds the @callback_symbol to the scope of @builder
	// under the given @callback_name.
	//
	// Using this function overrides the behavior of
	// gtk_builder_create_closure() for any callback symbols that are added.
	// Using this method allows for better encapsulation as it does not require
	// that callback symbols be declared in the global namespace.
	AddCallbackSymbol(callbackName string, callbackSymbol interface{})
	// LookupCallbackSymbol fetches a symbol previously added to @self with
	// gtk_builder_cscope_add_callback_symbol().
	LookupCallbackSymbol(callbackName string) interface{}
}

type builderCScope struct {
	*externglib.Object
}

// WrapBuilderCScope wraps a GObject to the right type. It is
// primarily used internally.
func WrapBuilderCScope(obj *externglib.Object) BuilderCScope {
	return builderCScope{*externglib.Object{obj}}
}

func marshalBuilderCScope(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapBuilderCScope(obj), nil
}

// NewBuilderCScope constructs a class BuilderCScope.
func NewBuilderCScope() BuilderCScope {

	ret := C.gtk_builder_cscope_new()

	var ret0 BuilderCScope

	ret0 = WrapBuilderCScope(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// AddCallbackSymbol adds the @callback_symbol to the scope of @builder
// under the given @callback_name.
//
// Using this function overrides the behavior of
// gtk_builder_create_closure() for any callback symbols that are added.
// Using this method allows for better encapsulation as it does not require
// that callback symbols be declared in the global namespace.
func (self builderCScope) AddCallbackSymbol(callbackName string, callbackSymbol interface{}) {
	var arg0 *C.GtkBuilderCScope
	var arg1 *C.char
	var arg2 C.GCallback

	arg0 = (*C.GtkBuilderCScope)(self.Native())
	arg1 = (*C.gchar)(C.CString(callbackName))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_builder_cscope_add_callback_symbol(arg0, arg1, arg2)
}

// LookupCallbackSymbol fetches a symbol previously added to @self with
// gtk_builder_cscope_add_callback_symbol().
func (self builderCScope) LookupCallbackSymbol(callbackName string) interface{} {
	var arg0 *C.GtkBuilderCScope
	var arg1 *C.char

	arg0 = (*C.GtkBuilderCScope)(self.Native())
	arg1 = (*C.gchar)(C.CString(callbackName))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_builder_cscope_lookup_callback_symbol(arg0, arg1)

	var ret0 interface{}

	return ret0
}

// BuilderListItemFactory is a ListItemFactory that creates widgets by
// instantiating Builder UI templates. The templates must be extending ListItem,
// and typically use Expressions to obtain data from the items in the model.
//
// Example:
//
//
//      <interface>
//        <template class="GtkListItem">
//          <property name="child">
//            <object class="GtkLabel">
//              <property name="xalign">0</property>
//              <binding name="label">
//                <lookup name="name" type="SettingsKey">
//                  <lookup name="item">GtkListItem</lookup>
//                </lookup>
//              </binding>
//            </object>
//          </property>
//        </template>
//      </interface>
//
type BuilderListItemFactory interface {
	ListItemFactory

	// Bytes gets the data used as the Builder UI template for constructing
	// listitems.
	Bytes() *glib.Bytes
	// Resource: if the data references a resource, gets the path of that
	// resource.
	Resource() string
	// Scope gets the scope used when constructing listitems.
	Scope() BuilderScope
}

type builderListItemFactory struct {
	listItemFactory
}

// WrapBuilderListItemFactory wraps a GObject to the right type. It is
// primarily used internally.
func WrapBuilderListItemFactory(obj *externglib.Object) BuilderListItemFactory {
	return builderListItemFactory{listItemFactory{*externglib.Object{obj}}}
}

func marshalBuilderListItemFactory(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapBuilderListItemFactory(obj), nil
}

// NewBuilderListItemFactoryFromBytes constructs a class BuilderListItemFactory.
func NewBuilderListItemFactoryFromBytes(scope BuilderScope, bytes *glib.Bytes) BuilderListItemFactory {
	var arg1 *C.GtkBuilderScope
	var arg2 *C.GBytes

	arg2 = (*C.GBytes)(bytes.Native())

	ret := C.gtk_builder_list_item_factory_new_from_bytes(arg1, arg2)

	var ret0 BuilderListItemFactory

	ret0 = WrapBuilderListItemFactory(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewBuilderListItemFactoryFromResource constructs a class BuilderListItemFactory.
func NewBuilderListItemFactoryFromResource(scope BuilderScope, resourcePath string) BuilderListItemFactory {
	var arg1 *C.GtkBuilderScope
	var arg2 *C.char

	arg2 = (*C.gchar)(C.CString(resourcePath))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.gtk_builder_list_item_factory_new_from_resource(arg1, arg2)

	var ret0 BuilderListItemFactory

	ret0 = WrapBuilderListItemFactory(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Bytes gets the data used as the Builder UI template for constructing
// listitems.
func (self builderListItemFactory) Bytes() *glib.Bytes {
	var arg0 *C.GtkBuilderListItemFactory

	arg0 = (*C.GtkBuilderListItemFactory)(self.Native())

	ret := C.gtk_builder_list_item_factory_get_bytes(arg0)

	var ret0 *glib.Bytes

	ret0 = glib.WrapBytes(ret)

	return ret0
}

// Resource: if the data references a resource, gets the path of that
// resource.
func (self builderListItemFactory) Resource() string {
	var arg0 *C.GtkBuilderListItemFactory

	arg0 = (*C.GtkBuilderListItemFactory)(self.Native())

	ret := C.gtk_builder_list_item_factory_get_resource(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Scope gets the scope used when constructing listitems.
func (self builderListItemFactory) Scope() BuilderScope {
	var arg0 *C.GtkBuilderListItemFactory

	arg0 = (*C.GtkBuilderListItemFactory)(self.Native())

	ret := C.gtk_builder_list_item_factory_get_scope(arg0)

	var ret0 BuilderScope

	return ret0
}

// Button: the Button widget is generally used to trigger a callback function
// that is called when the button is pressed. The various signals and how to use
// them are outlined below.
//
// The Button widget can hold any valid child widget. That is, it can hold
// almost any other standard Widget. The most commonly used child is the Label.
//
//
// CSS nodes
//
// GtkButton has a single CSS node with name button. The node will get the style
// classes .image-button or .text-button, if the content is just an image or
// label, respectively. It may also receive the .flat style class.
//
// Other style classes that are commonly used with GtkButton include
// .suggested-action and .destructive-action. In special cases, buttons can be
// made round by adding the .circular style class.
//
// Button-like widgets like ToggleButton, MenuButton, VolumeButton, LockButton,
// ColorButton or FontButton use style classes such as .toggle, .popup, .scale,
// .lock, .color on the button node to differentiate themselves from a plain
// GtkButton.
//
//
// Accessibility
//
// GtkButton uses the K_ACCESSIBLE_ROLE_BUTTON role.
type Button interface {
	Widget

	// Child gets the child widget of @button.
	Child() Widget
	// HasFrame returns whether the button has a frame.
	HasFrame() bool
	// IconName returns the icon name set via gtk_button_set_icon_name().
	IconName() string
	// Label fetches the text from the label of the button, as set by
	// gtk_button_set_label(). If the label text has not been set the return
	// value will be nil. This will be the case if you create an empty button
	// with gtk_button_new() to use as a container.
	Label() string
	// UseUnderline returns whether an embedded underline in the button label
	// indicates a mnemonic. See gtk_button_set_use_underline().
	UseUnderline() bool
	// SetChild sets the child widget of @button.
	SetChild(child Widget)
	// SetHasFrame sets the style of the button. Buttons can has a flat
	// appearance or have a frame drawn around them.
	SetHasFrame(hasFrame bool)
	// SetIconName adds a Image with the given icon name as a child. If @button
	// already contains a child widget, that child widget will be removed and
	// replaced with the image.
	SetIconName(iconName string)
	// SetLabel sets the text of the label of the button to @label.
	//
	// This will also clear any previously set labels.
	SetLabel(label string)
	// SetUseUnderline: if true, an underline in the text of the button label
	// indicates the next character should be used for the mnemonic accelerator
	// key.
	SetUseUnderline(useUnderline bool)
}

type button struct {
	widget
}

// WrapButton wraps a GObject to the right type. It is
// primarily used internally.
func WrapButton(obj *externglib.Object) Button {
	return button{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}
}

func marshalButton(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapButton(obj), nil
}

// NewButton constructs a class Button.
func NewButton() Button {

	ret := C.gtk_button_new()

	var ret0 Button

	ret0 = WrapButton(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewButtonFromIconName constructs a class Button.
func NewButtonFromIconName(iconName string) Button {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(iconName))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_button_new_from_icon_name(arg1)

	var ret0 Button

	ret0 = WrapButton(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewButtonWithLabel constructs a class Button.
func NewButtonWithLabel(label string) Button {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_button_new_with_label(arg1)

	var ret0 Button

	ret0 = WrapButton(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewButtonWithMnemonic constructs a class Button.
func NewButtonWithMnemonic(label string) Button {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_button_new_with_mnemonic(arg1)

	var ret0 Button

	ret0 = WrapButton(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Child gets the child widget of @button.
func (button button) Child() Widget {
	var arg0 *C.GtkButton

	arg0 = (*C.GtkButton)(button.Native())

	ret := C.gtk_button_get_child(arg0)

	var ret0 Widget

	ret0 = WrapWidget(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// HasFrame returns whether the button has a frame.
func (button button) HasFrame() bool {
	var arg0 *C.GtkButton

	arg0 = (*C.GtkButton)(button.Native())

	ret := C.gtk_button_get_has_frame(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// IconName returns the icon name set via gtk_button_set_icon_name().
func (button button) IconName() string {
	var arg0 *C.GtkButton

	arg0 = (*C.GtkButton)(button.Native())

	ret := C.gtk_button_get_icon_name(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Label fetches the text from the label of the button, as set by
// gtk_button_set_label(). If the label text has not been set the return
// value will be nil. This will be the case if you create an empty button
// with gtk_button_new() to use as a container.
func (button button) Label() string {
	var arg0 *C.GtkButton

	arg0 = (*C.GtkButton)(button.Native())

	ret := C.gtk_button_get_label(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// UseUnderline returns whether an embedded underline in the button label
// indicates a mnemonic. See gtk_button_set_use_underline().
func (button button) UseUnderline() bool {
	var arg0 *C.GtkButton

	arg0 = (*C.GtkButton)(button.Native())

	ret := C.gtk_button_get_use_underline(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// SetChild sets the child widget of @button.
func (button button) SetChild(child Widget) {
	var arg0 *C.GtkButton
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkButton)(button.Native())
	arg1 = (*C.GtkWidget)(child.Native())

	C.gtk_button_set_child(arg0, arg1)
}

// SetHasFrame sets the style of the button. Buttons can has a flat
// appearance or have a frame drawn around them.
func (button button) SetHasFrame(hasFrame bool) {
	var arg0 *C.GtkButton
	var arg1 C.gboolean

	arg0 = (*C.GtkButton)(button.Native())
	arg1 = gextras.Cbool(hasFrame)

	C.gtk_button_set_has_frame(arg0, arg1)
}

// SetIconName adds a Image with the given icon name as a child. If @button
// already contains a child widget, that child widget will be removed and
// replaced with the image.
func (button button) SetIconName(iconName string) {
	var arg0 *C.GtkButton
	var arg1 *C.char

	arg0 = (*C.GtkButton)(button.Native())
	arg1 = (*C.gchar)(C.CString(iconName))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_button_set_icon_name(arg0, arg1)
}

// SetLabel sets the text of the label of the button to @label.
//
// This will also clear any previously set labels.
func (button button) SetLabel(label string) {
	var arg0 *C.GtkButton
	var arg1 *C.char

	arg0 = (*C.GtkButton)(button.Native())
	arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_button_set_label(arg0, arg1)
}

// SetUseUnderline: if true, an underline in the text of the button label
// indicates the next character should be used for the mnemonic accelerator
// key.
func (button button) SetUseUnderline(useUnderline bool) {
	var arg0 *C.GtkButton
	var arg1 C.gboolean

	arg0 = (*C.GtkButton)(button.Native())
	arg1 = gextras.Cbool(useUnderline)

	C.gtk_button_set_use_underline(arg0, arg1)
}

type CClosureExpression interface {
	Expression
}

type cClosureExpression struct {
	expression
}

// WrapCClosureExpression wraps a GObject to the right type. It is
// primarily used internally.
func WrapCClosureExpression(obj *externglib.Object) CClosureExpression {
	return cClosureExpression{expression{obj}}
}

func marshalCClosureExpression(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCClosureExpression(obj), nil
}

// Calendar is a widget that displays a Gregorian calendar, one month at a time.
// It can be created with gtk_calendar_new().
//
// The date that is currently displayed can be altered with
// gtk_calendar_select_day().
//
// To place a visual marker on a particular day, use gtk_calendar_mark_day() and
// to remove the marker, gtk_calendar_unmark_day(). Alternative, all marks can
// be cleared with gtk_calendar_clear_marks().
//
// The selected date can be retrieved from a Calendar using
// gtk_calendar_get_date().
//
// Users should be aware that, although the Gregorian calendar is the legal
// calendar in most countries, it was adopted progressively between 1582 and
// 1929. Display before these dates is likely to be historically incorrect.
//
// CSS nodes
//
//    calendar.view
//    ├── header
//    │   ├── button
//    │   ├── stack.month
//    │   ├── button
//    │   ├── button
//    │   ├── label.year
//    │   ╰── button
//    ╰── grid
//        ╰── label[.day-name][.week-number][.day-number][.other-month][.today]
//
//
// GtkCalendar has a main node with name calendar. It contains a subnode called
// header containing the widgets for switching between years and months.
//
// The grid subnode contains all day labels, including week numbers on the left
// (marked with the .week-number css class) and day names on top (marked with
// the .day-name css class).
//
// Day labels that belong to the previous or next month get the .other-month
// style class. The label of the current day get the .today style class.
//
// Marked day labels get the :selected state assigned.
type Calendar interface {
	Widget

	// ClearMarks: remove all visual markers.
	ClearMarks()
	// Date returns a Time representing the shown year, month and the selected
	// day, in the local time zone.
	Date() *glib.DateTime
	// DayIsMarked returns if the @day of the @calendar is already marked.
	DayIsMarked(day uint) bool
	// ShowDayNames returns whether @self is currently showing the names of the
	// week days above the day numbers, i.e. the value of the
	// Calendar:show-day-names property.
	ShowDayNames() bool
	// ShowHeading returns whether @self is currently showing the heading, i.e.
	// the value of the Calendar:show-heading property.
	ShowHeading() bool
	// ShowWeekNumbers returns whether @self is showing week numbers right now,
	// i.e. the value of the Calendar:show-week-numbers property.
	ShowWeekNumbers() bool
	// MarkDay places a visual marker on a particular day.
	MarkDay(day uint)
	// SelectDay: will switch to @date's year and month and select its day.
	SelectDay(date *glib.DateTime)
	// SetShowDayNames sets whether the calendar shows day names.
	SetShowDayNames(value bool)
	// SetShowHeading sets whether the calendar should show a heading containing
	// the current year and month as well as buttons for changing both.
	SetShowHeading(value bool)
	// SetShowWeekNumbers sets whether week numbers are shown in the calendar.
	SetShowWeekNumbers(value bool)
	// UnmarkDay removes the visual marker from a particular day.
	UnmarkDay(day uint)
}

type calendar struct {
	widget
}

// WrapCalendar wraps a GObject to the right type. It is
// primarily used internally.
func WrapCalendar(obj *externglib.Object) Calendar {
	return calendar{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}
}

func marshalCalendar(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCalendar(obj), nil
}

// NewCalendar constructs a class Calendar.
func NewCalendar() Calendar {

	ret := C.gtk_calendar_new()

	var ret0 Calendar

	ret0 = WrapCalendar(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// ClearMarks: remove all visual markers.
func (calendar calendar) ClearMarks() {
	var arg0 *C.GtkCalendar

	arg0 = (*C.GtkCalendar)(calendar.Native())

	C.gtk_calendar_clear_marks(arg0)
}

// Date returns a Time representing the shown year, month and the selected
// day, in the local time zone.
func (self calendar) Date() *glib.DateTime {
	var arg0 *C.GtkCalendar

	arg0 = (*C.GtkCalendar)(self.Native())

	ret := C.gtk_calendar_get_date(arg0)

	var ret0 *glib.DateTime

	ret0 = glib.WrapDateTime(ret)

	return ret0
}

// DayIsMarked returns if the @day of the @calendar is already marked.
func (calendar calendar) DayIsMarked(day uint) bool {
	var arg0 *C.GtkCalendar
	var arg1 C.guint

	arg0 = (*C.GtkCalendar)(calendar.Native())
	arg1 = C.guint(day)

	ret := C.gtk_calendar_get_day_is_marked(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// ShowDayNames returns whether @self is currently showing the names of the
// week days above the day numbers, i.e. the value of the
// Calendar:show-day-names property.
func (self calendar) ShowDayNames() bool {
	var arg0 *C.GtkCalendar

	arg0 = (*C.GtkCalendar)(self.Native())

	ret := C.gtk_calendar_get_show_day_names(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// ShowHeading returns whether @self is currently showing the heading, i.e.
// the value of the Calendar:show-heading property.
func (self calendar) ShowHeading() bool {
	var arg0 *C.GtkCalendar

	arg0 = (*C.GtkCalendar)(self.Native())

	ret := C.gtk_calendar_get_show_heading(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// ShowWeekNumbers returns whether @self is showing week numbers right now,
// i.e. the value of the Calendar:show-week-numbers property.
func (self calendar) ShowWeekNumbers() bool {
	var arg0 *C.GtkCalendar

	arg0 = (*C.GtkCalendar)(self.Native())

	ret := C.gtk_calendar_get_show_week_numbers(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// MarkDay places a visual marker on a particular day.
func (calendar calendar) MarkDay(day uint) {
	var arg0 *C.GtkCalendar
	var arg1 C.guint

	arg0 = (*C.GtkCalendar)(calendar.Native())
	arg1 = C.guint(day)

	C.gtk_calendar_mark_day(arg0, arg1)
}

// SelectDay: will switch to @date's year and month and select its day.
func (self calendar) SelectDay(date *glib.DateTime) {
	var arg0 *C.GtkCalendar
	var arg1 *C.GDateTime

	arg0 = (*C.GtkCalendar)(self.Native())
	arg1 = (*C.GDateTime)(date.Native())

	C.gtk_calendar_select_day(arg0, arg1)
}

// SetShowDayNames sets whether the calendar shows day names.
func (self calendar) SetShowDayNames(value bool) {
	var arg0 *C.GtkCalendar
	var arg1 C.gboolean

	arg0 = (*C.GtkCalendar)(self.Native())
	arg1 = gextras.Cbool(value)

	C.gtk_calendar_set_show_day_names(arg0, arg1)
}

// SetShowHeading sets whether the calendar should show a heading containing
// the current year and month as well as buttons for changing both.
func (self calendar) SetShowHeading(value bool) {
	var arg0 *C.GtkCalendar
	var arg1 C.gboolean

	arg0 = (*C.GtkCalendar)(self.Native())
	arg1 = gextras.Cbool(value)

	C.gtk_calendar_set_show_heading(arg0, arg1)
}

// SetShowWeekNumbers sets whether week numbers are shown in the calendar.
func (self calendar) SetShowWeekNumbers(value bool) {
	var arg0 *C.GtkCalendar
	var arg1 C.gboolean

	arg0 = (*C.GtkCalendar)(self.Native())
	arg1 = gextras.Cbool(value)

	C.gtk_calendar_set_show_week_numbers(arg0, arg1)
}

// UnmarkDay removes the visual marker from a particular day.
func (calendar calendar) UnmarkDay(day uint) {
	var arg0 *C.GtkCalendar
	var arg1 C.guint

	arg0 = (*C.GtkCalendar)(calendar.Native())
	arg1 = C.guint(day)

	C.gtk_calendar_unmark_day(arg0, arg1)
}

// CallbackAction: a ShortcutAction that invokes a callback.
type CallbackAction interface {
	ShortcutAction
}

type callbackAction struct {
	shortcutAction
}

// WrapCallbackAction wraps a GObject to the right type. It is
// primarily used internally.
func WrapCallbackAction(obj *externglib.Object) CallbackAction {
	return callbackAction{shortcutAction{*externglib.Object{obj}}}
}

func marshalCallbackAction(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCallbackAction(obj), nil
}

// NewCallbackAction constructs a class CallbackAction.
func NewCallbackAction(callback ShortcutFunc) CallbackAction {
	var arg1 C.GtkShortcutFunc
	var arg2 C.gpointer
	var arg3 C.GDestroyNotify

	ret := C.gtk_callback_action_new(arg1, arg2, arg3)

	var ret0 CallbackAction

	ret0 = WrapCallbackAction(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// CellArea: the CellArea is an abstract class for CellLayout widgets (also
// referred to as "layouting widgets") to interface with an arbitrary number of
// CellRenderers and interact with the user for a given TreeModel row.
//
// The cell area handles events, focus navigation, drawing and size requests and
// allocations for a given row of data.
//
// Usually users dont have to interact with the CellArea directly unless they
// are implementing a cell-layouting widget themselves.
//
//
// Requesting area sizes
//
// As outlined in [GtkWidget’s geometry management
// section][geometry-management], GTK uses a height-for-width geometry
// management system to compute the sizes of widgets and user interfaces.
// CellArea uses the same semantics to calculate the size of an area for an
// arbitrary number of TreeModel rows.
//
// When requesting the size of a cell area one needs to calculate the size for a
// handful of rows, and this will be done differently by different layouting
// widgets. For instance a TreeViewColumn always lines up the areas from top to
// bottom while a IconView on the other hand might enforce that all areas
// received the same width and wrap the areas around, requesting height for more
// cell areas when allocated less width.
//
// It’s also important for areas to maintain some cell alignments with areas
// rendered for adjacent rows (cells can appear “columnized” inside an area even
// when the size of cells are different in each row). For this reason the
// CellArea uses a CellAreaContext object to store the alignments and sizes
// along the way (as well as the overall largest minimum and natural size for
// all the rows which have been calculated with the said context).
//
// The CellAreaContext is an opaque object specific to the CellArea which
// created it (see gtk_cell_area_create_context()). The owning cell-layouting
// widget can create as many contexts as it wishes to calculate sizes of rows
// which should receive the same size in at least one orientation (horizontally
// or vertically), However, it’s important that the same CellAreaContext which
// was used to request the sizes for a given TreeModel row be used when
// rendering or processing events for that row.
//
// In order to request the width of all the rows at the root level of a
// TreeModel one would do the following:
//
//    static gboolean
//    foo_focus (GtkWidget       *widget,
//               GtkDirectionType direction)
//    {
//      Foo        *foo  = FOO (widget);
//      FooPrivate *priv = foo->priv;
//      int         focus_row;
//      gboolean    have_focus = FALSE;
//
//      focus_row = priv->focus_row;
//
//      if (!gtk_widget_has_focus (widget))
//        gtk_widget_grab_focus (widget);
//
//      valid = gtk_tree_model_iter_nth_child (priv->model, &iter, NULL, priv->focus_row);
//      while (valid)
//        {
//          gtk_cell_area_apply_attributes (priv->area, priv->model, &iter, FALSE, FALSE);
//
//          if (gtk_cell_area_focus (priv->area, direction))
//            {
//               priv->focus_row = focus_row;
//               have_focus = TRUE;
//               break;
//            }
//          else
//            {
//              if (direction == GTK_DIR_RIGHT ||
//                  direction == GTK_DIR_LEFT)
//                break;
//              else if (direction == GTK_DIR_UP ||
//                       direction == GTK_DIR_TAB_BACKWARD)
//               {
//                  if (focus_row == 0)
//                    break;
//                  else
//                   {
//                      focus_row--;
//                      valid = gtk_tree_model_iter_nth_child (priv->model, &iter, NULL, focus_row);
//                   }
//                }
//              else
//                {
//                  if (focus_row == last_row)
//                    break;
//                  else
//                    {
//                      focus_row++;
//                      valid = gtk_tree_model_iter_next (priv->model, &iter);
//                    }
//                }
//            }
//        }
//        return have_focus;
//    }
//
//
// Note that the layouting widget is responsible for matching the
// GtkDirectionType values to the way it lays out its cells.
//
//
// Cell Properties
//
// The CellArea introduces cell properties for CellRenderers. This provides some
// general interfaces for defining the relationship cell areas have with their
// cells. For instance in a CellAreaBox a cell might “expand” and receive extra
// space when the area is allocated more than its full natural request, or a
// cell might be configured to “align” with adjacent rows which were requested
// and rendered with the same CellAreaContext.
//
// Use gtk_cell_area_class_install_cell_property() to install cell properties
// for a cell area class and gtk_cell_area_class_find_cell_property() or
// gtk_cell_area_class_list_cell_properties() to get information about existing
// cell properties.
//
// To set the value of a cell property, use gtk_cell_area_cell_set_property(),
// gtk_cell_area_cell_set() or gtk_cell_area_cell_set_valist(). To obtain the
// value of a cell property, use gtk_cell_area_cell_get_property(),
// gtk_cell_area_cell_get() or gtk_cell_area_cell_get_valist().
type CellArea interface {
	gextras.Objector

	// Activate activates @area, usually by activating the currently focused
	// cell, however some subclasses which embed widgets in the area can also
	// activate a widget if it currently has the focus.
	Activate(context CellAreaContext, widget Widget, cellArea *gdk.Rectangle, flags CellRendererState, editOnly bool) bool
	// ActivateCell: this is used by CellArea subclasses when handling events to
	// activate cells, the base CellArea class activates cells for keyboard
	// events for free in its own GtkCellArea->activate() implementation.
	ActivateCell(widget Widget, renderer CellRenderer, event gdk.Event, cellArea *gdk.Rectangle, flags CellRendererState) bool
	// Add adds @renderer to @area with the default child cell properties.
	Add(renderer CellRenderer)
	// AddFocusSibling adds @sibling to @renderer’s focusable area, focus will
	// be drawn around @renderer and all of its siblings if @renderer can focus
	// for a given row.
	//
	// Events handled by focus siblings can also activate the given focusable
	// @renderer.
	AddFocusSibling(renderer CellRenderer, sibling CellRenderer)
	// ApplyAttributes applies any connected attributes to the renderers in
	// @area by pulling the values from @tree_model.
	ApplyAttributes(treeModel TreeModel, iter *TreeIter, isExpander bool, isExpanded bool)
	// AttributeConnect connects an @attribute to apply values from @column for
	// the TreeModel in use.
	AttributeConnect(renderer CellRenderer, attribute string, column int)
	// AttributeDisconnect disconnects @attribute for the @renderer in @area so
	// that attribute will no longer be updated with values from the model.
	AttributeDisconnect(renderer CellRenderer, attribute string)
	// AttributeGetColumn returns the model column that an attribute has been
	// mapped to, or -1 if the attribute is not mapped.
	AttributeGetColumn(renderer CellRenderer, attribute string) int
	// CellGetProperty gets the value of a cell property for @renderer in @area.
	CellGetProperty(renderer CellRenderer, propertyName string, value *externglib.Value)
	// CellSetProperty sets a cell property for @renderer in @area.
	CellSetProperty(renderer CellRenderer, propertyName string, value *externglib.Value)
	// CopyContext: this is sometimes needed for cases where rows need to share
	// alignments in one orientation but may be separately grouped in the
	// opposing orientation.
	//
	// For instance, IconView creates all icons (rows) to have the same width
	// and the cells theirin to have the same horizontal alignments. However
	// each row of icons may have a separate collective height. IconView uses
	// this to request the heights of each row based on a context which was
	// already used to request all the row widths that are to be displayed.
	CopyContext(context CellAreaContext) CellAreaContext
	// CreateContext creates a CellAreaContext to be used with @area for all
	// purposes. CellAreaContext stores geometry information for rows for which
	// it was operated on, it is important to use the same context for the same
	// row of data at all times (i.e. one should render and handle events with
	// the same CellAreaContext which was used to request the size of those rows
	// of data).
	CreateContext() CellAreaContext
	// Event delegates event handling to a CellArea.
	Event(context CellAreaContext, widget Widget, event gdk.Event, cellArea *gdk.Rectangle, flags CellRendererState) int
	// Focus: this should be called by the @area’s owning layout widget when
	// focus is to be passed to @area, or moved within @area for a given
	// @direction and row data.
	//
	// Implementing CellArea classes should implement this method to receive and
	// navigate focus in its own way particular to how it lays out cells.
	Focus(direction DirectionType) bool
	// Foreach calls @callback for every CellRenderer in @area.
	Foreach(callback CellCallback)
	// ForeachAlloc calls @callback for every CellRenderer in @area with the
	// allocated rectangle inside @cell_area.
	ForeachAlloc(context CellAreaContext, widget Widget, cellArea *gdk.Rectangle, backgroundArea *gdk.Rectangle, callback CellAllocCallback)
	// CellAllocation derives the allocation of @renderer inside @area if @area
	// were to be renderered in @cell_area.
	CellAllocation(context CellAreaContext, widget Widget, renderer CellRenderer, cellArea *gdk.Rectangle) gdk.Rectangle
	// CellAtPosition gets the CellRenderer at @x and @y coordinates inside
	// @area and optionally returns the full cell allocation for it inside
	// @cell_area.
	CellAtPosition(context CellAreaContext, widget Widget, cellArea *gdk.Rectangle, x int, y int) (allocArea gdk.Rectangle, cellRenderer CellRenderer)
	// CurrentPathString gets the current TreePath string for the currently
	// applied TreeIter, this is implicitly updated when
	// gtk_cell_area_apply_attributes() is called and can be used to interact
	// with renderers from CellArea subclasses.
	CurrentPathString() string
	// EditWidget gets the CellEditable widget currently used to edit the
	// currently edited cell.
	EditWidget() CellEditable
	// EditedCell gets the CellRenderer in @area that is currently being edited.
	EditedCell() CellRenderer
	// FocusCell retrieves the currently focused cell for @area
	FocusCell() CellRenderer
	// FocusFromSibling gets the CellRenderer which is expected to be focusable
	// for which @renderer is, or may be a sibling.
	//
	// This is handy for CellArea subclasses when handling events, after
	// determining the renderer at the event location it can then chose to
	// activate the focus cell for which the event cell may have been a sibling.
	FocusFromSibling(renderer CellRenderer) CellRenderer
	// FocusSiblings gets the focus sibling cell renderers for @renderer.
	FocusSiblings(renderer CellRenderer) *glib.List
	// PreferredHeight retrieves a cell area’s initial minimum and natural
	// height.
	//
	// @area will store some geometrical information in @context along the way;
	// when requesting sizes over an arbitrary number of rows, it’s not
	// important to check the @minimum_height and @natural_height of this call
	// but rather to consult gtk_cell_area_context_get_preferred_height() after
	// a series of requests.
	PreferredHeight(context CellAreaContext, widget Widget) (minimumHeight int, naturalHeight int)
	// PreferredHeightForWidth retrieves a cell area’s minimum and natural
	// height if it would be given the specified @width.
	//
	// @area stores some geometrical information in @context along the way while
	// calling gtk_cell_area_get_preferred_width(). It’s important to perform a
	// series of gtk_cell_area_get_preferred_width() requests with @context
	// first and then call gtk_cell_area_get_preferred_height_for_width() on
	// each cell area individually to get the height for width of each fully
	// requested row.
	//
	// If at some point, the width of a single row changes, it should be
	// requested with gtk_cell_area_get_preferred_width() again and then the
	// full width of the requested rows checked again with
	// gtk_cell_area_context_get_preferred_width().
	PreferredHeightForWidth(context CellAreaContext, widget Widget, width int) (minimumHeight int, naturalHeight int)
	// PreferredWidth retrieves a cell area’s initial minimum and natural width.
	//
	// @area will store some geometrical information in @context along the way;
	// when requesting sizes over an arbitrary number of rows, it’s not
	// important to check the @minimum_width and @natural_width of this call but
	// rather to consult gtk_cell_area_context_get_preferred_width() after a
	// series of requests.
	PreferredWidth(context CellAreaContext, widget Widget) (minimumWidth int, naturalWidth int)
	// PreferredWidthForHeight retrieves a cell area’s minimum and natural width
	// if it would be given the specified @height.
	//
	// @area stores some geometrical information in @context along the way while
	// calling gtk_cell_area_get_preferred_height(). It’s important to perform a
	// series of gtk_cell_area_get_preferred_height() requests with @context
	// first and then call gtk_cell_area_get_preferred_width_for_height() on
	// each cell area individually to get the height for width of each fully
	// requested row.
	//
	// If at some point, the height of a single row changes, it should be
	// requested with gtk_cell_area_get_preferred_height() again and then the
	// full height of the requested rows checked again with
	// gtk_cell_area_context_get_preferred_height().
	PreferredWidthForHeight(context CellAreaContext, widget Widget, height int) (minimumWidth int, naturalWidth int)
	// RequestMode gets whether the area prefers a height-for-width layout or a
	// width-for-height layout.
	RequestMode() SizeRequestMode
	// HasRenderer checks if @area contains @renderer.
	HasRenderer(renderer CellRenderer) bool
	// InnerCellArea: this is a convenience function for CellArea
	// implementations to get the inner area where a given CellRenderer will be
	// rendered. It removes any padding previously added by
	// gtk_cell_area_request_renderer().
	InnerCellArea(widget Widget, cellArea *gdk.Rectangle) gdk.Rectangle
	// IsActivatable returns whether the area can do anything when activated,
	// after applying new attributes to @area.
	IsActivatable() bool
	// IsFocusSibling returns whether @sibling is one of @renderer’s focus
	// siblings (see gtk_cell_area_add_focus_sibling()).
	IsFocusSibling(renderer CellRenderer, sibling CellRenderer) bool
	// Remove removes @renderer from @area.
	Remove(renderer CellRenderer)
	// RemoveFocusSibling removes @sibling from @renderer’s focus sibling list
	// (see gtk_cell_area_add_focus_sibling()).
	RemoveFocusSibling(renderer CellRenderer, sibling CellRenderer)
	// RequestRenderer: this is a convenience function for CellArea
	// implementations to request size for cell renderers. It’s important to use
	// this function to request size and then use
	// gtk_cell_area_inner_cell_area() at render and event time since this
	// function will add padding around the cell for focus painting.
	RequestRenderer(renderer CellRenderer, orientation Orientation, widget Widget, forSize int) (minimumSize int, naturalSize int)
	// SetFocusCell: explicitly sets the currently focused cell to @renderer.
	//
	// This is generally called by implementations of CellAreaClass.focus() or
	// CellAreaClass.event(), however it can also be used to implement functions
	// such as gtk_tree_view_set_cursor_on_cell().
	SetFocusCell(renderer CellRenderer)
	// Snapshot snapshots @area’s cells according to @area’s layout onto at the
	// given coordinates.
	Snapshot(context CellAreaContext, widget Widget, snapshot Snapshot, backgroundArea *gdk.Rectangle, cellArea *gdk.Rectangle, flags CellRendererState, paintFocus bool)
	// StopEditing: explicitly stops the editing of the currently edited cell.
	//
	// If @canceled is true, the currently edited cell renderer will emit the
	// ::editing-canceled signal, otherwise the the ::editing-done signal will
	// be emitted on the current edit widget.
	//
	// See gtk_cell_area_get_edited_cell() and gtk_cell_area_get_edit_widget().
	StopEditing(canceled bool)
}

type cellArea struct {
	externglib.InitiallyUnowned
}

// WrapCellArea wraps a GObject to the right type. It is
// primarily used internally.
func WrapCellArea(obj *externglib.Object) CellArea {
	return cellArea{externglib.InitiallyUnowned{*externglib.Object{obj}}}
}

func marshalCellArea(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCellArea(obj), nil
}

// Activate activates @area, usually by activating the currently focused
// cell, however some subclasses which embed widgets in the area can also
// activate a widget if it currently has the focus.
func (area cellArea) Activate(context CellAreaContext, widget Widget, cellArea *gdk.Rectangle, flags CellRendererState, editOnly bool) bool {
	var arg0 *C.GtkCellArea
	var arg1 *C.GtkCellAreaContext
	var arg2 *C.GtkWidget
	var arg3 *C.GdkRectangle
	var arg4 C.GtkCellRendererState
	var arg5 C.gboolean

	arg0 = (*C.GtkCellArea)(area.Native())
	arg1 = (*C.GtkCellAreaContext)(context.Native())
	arg2 = (*C.GtkWidget)(widget.Native())
	arg3 = (*C.GdkRectangle)(cellArea.Native())
	arg4 = (C.GtkCellRendererState)(flags)
	arg5 = gextras.Cbool(editOnly)

	ret := C.gtk_cell_area_activate(arg0, arg1, arg2, arg3, arg4, arg5)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// ActivateCell: this is used by CellArea subclasses when handling events to
// activate cells, the base CellArea class activates cells for keyboard
// events for free in its own GtkCellArea->activate() implementation.
func (area cellArea) ActivateCell(widget Widget, renderer CellRenderer, event gdk.Event, cellArea *gdk.Rectangle, flags CellRendererState) bool {
	var arg0 *C.GtkCellArea
	var arg1 *C.GtkWidget
	var arg2 *C.GtkCellRenderer
	var arg3 *C.GdkEvent
	var arg4 *C.GdkRectangle
	var arg5 C.GtkCellRendererState

	arg0 = (*C.GtkCellArea)(area.Native())
	arg1 = (*C.GtkWidget)(widget.Native())
	arg2 = (*C.GtkCellRenderer)(renderer.Native())
	arg3 = (*C.GdkEvent)(event.Native())
	arg4 = (*C.GdkRectangle)(cellArea.Native())
	arg5 = (C.GtkCellRendererState)(flags)

	ret := C.gtk_cell_area_activate_cell(arg0, arg1, arg2, arg3, arg4, arg5)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Add adds @renderer to @area with the default child cell properties.
func (area cellArea) Add(renderer CellRenderer) {
	var arg0 *C.GtkCellArea
	var arg1 *C.GtkCellRenderer

	arg0 = (*C.GtkCellArea)(area.Native())
	arg1 = (*C.GtkCellRenderer)(renderer.Native())

	C.gtk_cell_area_add(arg0, arg1)
}

// AddFocusSibling adds @sibling to @renderer’s focusable area, focus will
// be drawn around @renderer and all of its siblings if @renderer can focus
// for a given row.
//
// Events handled by focus siblings can also activate the given focusable
// @renderer.
func (area cellArea) AddFocusSibling(renderer CellRenderer, sibling CellRenderer) {
	var arg0 *C.GtkCellArea
	var arg1 *C.GtkCellRenderer
	var arg2 *C.GtkCellRenderer

	arg0 = (*C.GtkCellArea)(area.Native())
	arg1 = (*C.GtkCellRenderer)(renderer.Native())
	arg2 = (*C.GtkCellRenderer)(sibling.Native())

	C.gtk_cell_area_add_focus_sibling(arg0, arg1, arg2)
}

// ApplyAttributes applies any connected attributes to the renderers in
// @area by pulling the values from @tree_model.
func (area cellArea) ApplyAttributes(treeModel TreeModel, iter *TreeIter, isExpander bool, isExpanded bool) {
	var arg0 *C.GtkCellArea
	var arg1 *C.GtkTreeModel
	var arg2 *C.GtkTreeIter
	var arg3 C.gboolean
	var arg4 C.gboolean

	arg0 = (*C.GtkCellArea)(area.Native())
	arg2 = (*C.GtkTreeIter)(iter.Native())
	arg3 = gextras.Cbool(isExpander)
	arg4 = gextras.Cbool(isExpanded)

	C.gtk_cell_area_apply_attributes(arg0, arg1, arg2, arg3, arg4)
}

// AttributeConnect connects an @attribute to apply values from @column for
// the TreeModel in use.
func (area cellArea) AttributeConnect(renderer CellRenderer, attribute string, column int) {
	var arg0 *C.GtkCellArea
	var arg1 *C.GtkCellRenderer
	var arg2 *C.char
	var arg3 C.int

	arg0 = (*C.GtkCellArea)(area.Native())
	arg1 = (*C.GtkCellRenderer)(renderer.Native())
	arg2 = (*C.gchar)(C.CString(attribute))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = C.int(column)

	C.gtk_cell_area_attribute_connect(arg0, arg1, arg2, arg3)
}

// AttributeDisconnect disconnects @attribute for the @renderer in @area so
// that attribute will no longer be updated with values from the model.
func (area cellArea) AttributeDisconnect(renderer CellRenderer, attribute string) {
	var arg0 *C.GtkCellArea
	var arg1 *C.GtkCellRenderer
	var arg2 *C.char

	arg0 = (*C.GtkCellArea)(area.Native())
	arg1 = (*C.GtkCellRenderer)(renderer.Native())
	arg2 = (*C.gchar)(C.CString(attribute))
	defer C.free(unsafe.Pointer(arg2))

	C.gtk_cell_area_attribute_disconnect(arg0, arg1, arg2)
}

// AttributeGetColumn returns the model column that an attribute has been
// mapped to, or -1 if the attribute is not mapped.
func (area cellArea) AttributeGetColumn(renderer CellRenderer, attribute string) int {
	var arg0 *C.GtkCellArea
	var arg1 *C.GtkCellRenderer
	var arg2 *C.char

	arg0 = (*C.GtkCellArea)(area.Native())
	arg1 = (*C.GtkCellRenderer)(renderer.Native())
	arg2 = (*C.gchar)(C.CString(attribute))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.gtk_cell_area_attribute_get_column(arg0, arg1, arg2)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// CellGetProperty gets the value of a cell property for @renderer in @area.
func (area cellArea) CellGetProperty(renderer CellRenderer, propertyName string, value *externglib.Value) {
	var arg0 *C.GtkCellArea
	var arg1 *C.GtkCellRenderer
	var arg2 *C.char
	var arg3 *C.GValue

	arg0 = (*C.GtkCellArea)(area.Native())
	arg1 = (*C.GtkCellRenderer)(renderer.Native())
	arg2 = (*C.gchar)(C.CString(propertyName))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.GValue)(value.GValue)

	C.gtk_cell_area_cell_get_property(arg0, arg1, arg2, arg3)
}

// CellSetProperty sets a cell property for @renderer in @area.
func (area cellArea) CellSetProperty(renderer CellRenderer, propertyName string, value *externglib.Value) {
	var arg0 *C.GtkCellArea
	var arg1 *C.GtkCellRenderer
	var arg2 *C.char
	var arg3 *C.GValue

	arg0 = (*C.GtkCellArea)(area.Native())
	arg1 = (*C.GtkCellRenderer)(renderer.Native())
	arg2 = (*C.gchar)(C.CString(propertyName))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.GValue)(value.GValue)

	C.gtk_cell_area_cell_set_property(arg0, arg1, arg2, arg3)
}

// CopyContext: this is sometimes needed for cases where rows need to share
// alignments in one orientation but may be separately grouped in the
// opposing orientation.
//
// For instance, IconView creates all icons (rows) to have the same width
// and the cells theirin to have the same horizontal alignments. However
// each row of icons may have a separate collective height. IconView uses
// this to request the heights of each row based on a context which was
// already used to request all the row widths that are to be displayed.
func (area cellArea) CopyContext(context CellAreaContext) CellAreaContext {
	var arg0 *C.GtkCellArea
	var arg1 *C.GtkCellAreaContext

	arg0 = (*C.GtkCellArea)(area.Native())
	arg1 = (*C.GtkCellAreaContext)(context.Native())

	ret := C.gtk_cell_area_copy_context(arg0, arg1)

	var ret0 CellAreaContext

	ret0 = WrapCellAreaContext(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// CreateContext creates a CellAreaContext to be used with @area for all
// purposes. CellAreaContext stores geometry information for rows for which
// it was operated on, it is important to use the same context for the same
// row of data at all times (i.e. one should render and handle events with
// the same CellAreaContext which was used to request the size of those rows
// of data).
func (area cellArea) CreateContext() CellAreaContext {
	var arg0 *C.GtkCellArea

	arg0 = (*C.GtkCellArea)(area.Native())

	ret := C.gtk_cell_area_create_context(arg0)

	var ret0 CellAreaContext

	ret0 = WrapCellAreaContext(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Event delegates event handling to a CellArea.
func (area cellArea) Event(context CellAreaContext, widget Widget, event gdk.Event, cellArea *gdk.Rectangle, flags CellRendererState) int {
	var arg0 *C.GtkCellArea
	var arg1 *C.GtkCellAreaContext
	var arg2 *C.GtkWidget
	var arg3 *C.GdkEvent
	var arg4 *C.GdkRectangle
	var arg5 C.GtkCellRendererState

	arg0 = (*C.GtkCellArea)(area.Native())
	arg1 = (*C.GtkCellAreaContext)(context.Native())
	arg2 = (*C.GtkWidget)(widget.Native())
	arg3 = (*C.GdkEvent)(event.Native())
	arg4 = (*C.GdkRectangle)(cellArea.Native())
	arg5 = (C.GtkCellRendererState)(flags)

	ret := C.gtk_cell_area_event(arg0, arg1, arg2, arg3, arg4, arg5)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Focus: this should be called by the @area’s owning layout widget when
// focus is to be passed to @area, or moved within @area for a given
// @direction and row data.
//
// Implementing CellArea classes should implement this method to receive and
// navigate focus in its own way particular to how it lays out cells.
func (area cellArea) Focus(direction DirectionType) bool {
	var arg0 *C.GtkCellArea
	var arg1 C.GtkDirectionType

	arg0 = (*C.GtkCellArea)(area.Native())
	arg1 = (C.GtkDirectionType)(direction)

	ret := C.gtk_cell_area_focus(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Foreach calls @callback for every CellRenderer in @area.
func (area cellArea) Foreach(callback CellCallback) {
	var arg0 *C.GtkCellArea
	var arg1 C.GtkCellCallback
	arg2 := C.gpointer(box.Assign(callbackData))

	arg0 = (*C.GtkCellArea)(area.Native())
	arg1 = (*[0]byte)(C.gotk4_CellCallback)

	C.gtk_cell_area_foreach(arg0, arg1)
}

// ForeachAlloc calls @callback for every CellRenderer in @area with the
// allocated rectangle inside @cell_area.
func (area cellArea) ForeachAlloc(context CellAreaContext, widget Widget, cellArea *gdk.Rectangle, backgroundArea *gdk.Rectangle, callback CellAllocCallback) {
	var arg0 *C.GtkCellArea
	var arg1 *C.GtkCellAreaContext
	var arg2 *C.GtkWidget
	var arg3 *C.GdkRectangle
	var arg4 *C.GdkRectangle
	var arg5 C.GtkCellAllocCallback
	arg6 := C.gpointer(box.Assign(callbackData))

	arg0 = (*C.GtkCellArea)(area.Native())
	arg1 = (*C.GtkCellAreaContext)(context.Native())
	arg2 = (*C.GtkWidget)(widget.Native())
	arg3 = (*C.GdkRectangle)(cellArea.Native())
	arg4 = (*C.GdkRectangle)(backgroundArea.Native())
	arg5 = (*[0]byte)(C.gotk4_CellAllocCallback)

	C.gtk_cell_area_foreach_alloc(arg0, arg1, arg2, arg3, arg4, arg5)
}

// CellAllocation derives the allocation of @renderer inside @area if @area
// were to be renderered in @cell_area.
func (area cellArea) CellAllocation(context CellAreaContext, widget Widget, renderer CellRenderer, cellArea *gdk.Rectangle) gdk.Rectangle {
	var arg0 *C.GtkCellArea
	var arg1 *C.GtkCellAreaContext
	var arg2 *C.GtkWidget
	var arg3 *C.GtkCellRenderer
	var arg4 *C.GdkRectangle
	var arg5 *C.GdkRectangle // out

	arg0 = (*C.GtkCellArea)(area.Native())
	arg1 = (*C.GtkCellAreaContext)(context.Native())
	arg2 = (*C.GtkWidget)(widget.Native())
	arg3 = (*C.GtkCellRenderer)(renderer.Native())
	arg4 = (*C.GdkRectangle)(cellArea.Native())

	ret := C.gtk_cell_area_get_cell_allocation(arg0, arg1, arg2, arg3, arg4, &arg5)

	var ret0 *gdk.Rectangle

	ret0 = gdk.WrapRectangle(arg5)

	return ret0
}

// CellAtPosition gets the CellRenderer at @x and @y coordinates inside
// @area and optionally returns the full cell allocation for it inside
// @cell_area.
func (area cellArea) CellAtPosition(context CellAreaContext, widget Widget, cellArea *gdk.Rectangle, x int, y int) (allocArea gdk.Rectangle, cellRenderer CellRenderer) {
	var arg0 *C.GtkCellArea
	var arg1 *C.GtkCellAreaContext
	var arg2 *C.GtkWidget
	var arg3 *C.GdkRectangle
	var arg4 C.int
	var arg5 C.int
	var arg6 *C.GdkRectangle // out

	arg0 = (*C.GtkCellArea)(area.Native())
	arg1 = (*C.GtkCellAreaContext)(context.Native())
	arg2 = (*C.GtkWidget)(widget.Native())
	arg3 = (*C.GdkRectangle)(cellArea.Native())
	arg4 = C.int(x)
	arg5 = C.int(y)

	ret := C.gtk_cell_area_get_cell_at_position(arg0, arg1, arg2, arg3, arg4, arg5, &arg6)

	var ret0 *gdk.Rectangle
	var ret1 CellRenderer

	ret0 = gdk.WrapRectangle(arg6)

	ret1 = WrapCellRenderer(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0, ret1
}

// CurrentPathString gets the current TreePath string for the currently
// applied TreeIter, this is implicitly updated when
// gtk_cell_area_apply_attributes() is called and can be used to interact
// with renderers from CellArea subclasses.
func (area cellArea) CurrentPathString() string {
	var arg0 *C.GtkCellArea

	arg0 = (*C.GtkCellArea)(area.Native())

	ret := C.gtk_cell_area_get_current_path_string(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// EditWidget gets the CellEditable widget currently used to edit the
// currently edited cell.
func (area cellArea) EditWidget() CellEditable {
	var arg0 *C.GtkCellArea

	arg0 = (*C.GtkCellArea)(area.Native())

	ret := C.gtk_cell_area_get_edit_widget(arg0)

	var ret0 CellEditable

	return ret0
}

// EditedCell gets the CellRenderer in @area that is currently being edited.
func (area cellArea) EditedCell() CellRenderer {
	var arg0 *C.GtkCellArea

	arg0 = (*C.GtkCellArea)(area.Native())

	ret := C.gtk_cell_area_get_edited_cell(arg0)

	var ret0 CellRenderer

	ret0 = WrapCellRenderer(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// FocusCell retrieves the currently focused cell for @area
func (area cellArea) FocusCell() CellRenderer {
	var arg0 *C.GtkCellArea

	arg0 = (*C.GtkCellArea)(area.Native())

	ret := C.gtk_cell_area_get_focus_cell(arg0)

	var ret0 CellRenderer

	ret0 = WrapCellRenderer(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// FocusFromSibling gets the CellRenderer which is expected to be focusable
// for which @renderer is, or may be a sibling.
//
// This is handy for CellArea subclasses when handling events, after
// determining the renderer at the event location it can then chose to
// activate the focus cell for which the event cell may have been a sibling.
func (area cellArea) FocusFromSibling(renderer CellRenderer) CellRenderer {
	var arg0 *C.GtkCellArea
	var arg1 *C.GtkCellRenderer

	arg0 = (*C.GtkCellArea)(area.Native())
	arg1 = (*C.GtkCellRenderer)(renderer.Native())

	ret := C.gtk_cell_area_get_focus_from_sibling(arg0, arg1)

	var ret0 CellRenderer

	ret0 = WrapCellRenderer(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// FocusSiblings gets the focus sibling cell renderers for @renderer.
func (area cellArea) FocusSiblings(renderer CellRenderer) *glib.List {
	var arg0 *C.GtkCellArea
	var arg1 *C.GtkCellRenderer

	arg0 = (*C.GtkCellArea)(area.Native())
	arg1 = (*C.GtkCellRenderer)(renderer.Native())

	ret := C.gtk_cell_area_get_focus_siblings(arg0, arg1)

	var ret0 *glib.List

	ret0 = glib.WrapList(ret)

	return ret0
}

// PreferredHeight retrieves a cell area’s initial minimum and natural
// height.
//
// @area will store some geometrical information in @context along the way;
// when requesting sizes over an arbitrary number of rows, it’s not
// important to check the @minimum_height and @natural_height of this call
// but rather to consult gtk_cell_area_context_get_preferred_height() after
// a series of requests.
func (area cellArea) PreferredHeight(context CellAreaContext, widget Widget) (minimumHeight int, naturalHeight int) {
	var arg0 *C.GtkCellArea
	var arg1 *C.GtkCellAreaContext
	var arg2 *C.GtkWidget
	var arg3 *C.int // out
	var arg4 *C.int // out

	arg0 = (*C.GtkCellArea)(area.Native())
	arg1 = (*C.GtkCellAreaContext)(context.Native())
	arg2 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_cell_area_get_preferred_height(arg0, arg1, arg2, &arg3, &arg4)

	var ret0 int
	var ret1 int

	ret0 = int(arg3)

	ret1 = int(arg4)

	return ret0, ret1
}

// PreferredHeightForWidth retrieves a cell area’s minimum and natural
// height if it would be given the specified @width.
//
// @area stores some geometrical information in @context along the way while
// calling gtk_cell_area_get_preferred_width(). It’s important to perform a
// series of gtk_cell_area_get_preferred_width() requests with @context
// first and then call gtk_cell_area_get_preferred_height_for_width() on
// each cell area individually to get the height for width of each fully
// requested row.
//
// If at some point, the width of a single row changes, it should be
// requested with gtk_cell_area_get_preferred_width() again and then the
// full width of the requested rows checked again with
// gtk_cell_area_context_get_preferred_width().
func (area cellArea) PreferredHeightForWidth(context CellAreaContext, widget Widget, width int) (minimumHeight int, naturalHeight int) {
	var arg0 *C.GtkCellArea
	var arg1 *C.GtkCellAreaContext
	var arg2 *C.GtkWidget
	var arg3 C.int
	var arg4 *C.int // out
	var arg5 *C.int // out

	arg0 = (*C.GtkCellArea)(area.Native())
	arg1 = (*C.GtkCellAreaContext)(context.Native())
	arg2 = (*C.GtkWidget)(widget.Native())
	arg3 = C.int(width)

	ret := C.gtk_cell_area_get_preferred_height_for_width(arg0, arg1, arg2, arg3, &arg4, &arg5)

	var ret0 int
	var ret1 int

	ret0 = int(arg4)

	ret1 = int(arg5)

	return ret0, ret1
}

// PreferredWidth retrieves a cell area’s initial minimum and natural width.
//
// @area will store some geometrical information in @context along the way;
// when requesting sizes over an arbitrary number of rows, it’s not
// important to check the @minimum_width and @natural_width of this call but
// rather to consult gtk_cell_area_context_get_preferred_width() after a
// series of requests.
func (area cellArea) PreferredWidth(context CellAreaContext, widget Widget) (minimumWidth int, naturalWidth int) {
	var arg0 *C.GtkCellArea
	var arg1 *C.GtkCellAreaContext
	var arg2 *C.GtkWidget
	var arg3 *C.int // out
	var arg4 *C.int // out

	arg0 = (*C.GtkCellArea)(area.Native())
	arg1 = (*C.GtkCellAreaContext)(context.Native())
	arg2 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_cell_area_get_preferred_width(arg0, arg1, arg2, &arg3, &arg4)

	var ret0 int
	var ret1 int

	ret0 = int(arg3)

	ret1 = int(arg4)

	return ret0, ret1
}

// PreferredWidthForHeight retrieves a cell area’s minimum and natural width
// if it would be given the specified @height.
//
// @area stores some geometrical information in @context along the way while
// calling gtk_cell_area_get_preferred_height(). It’s important to perform a
// series of gtk_cell_area_get_preferred_height() requests with @context
// first and then call gtk_cell_area_get_preferred_width_for_height() on
// each cell area individually to get the height for width of each fully
// requested row.
//
// If at some point, the height of a single row changes, it should be
// requested with gtk_cell_area_get_preferred_height() again and then the
// full height of the requested rows checked again with
// gtk_cell_area_context_get_preferred_height().
func (area cellArea) PreferredWidthForHeight(context CellAreaContext, widget Widget, height int) (minimumWidth int, naturalWidth int) {
	var arg0 *C.GtkCellArea
	var arg1 *C.GtkCellAreaContext
	var arg2 *C.GtkWidget
	var arg3 C.int
	var arg4 *C.int // out
	var arg5 *C.int // out

	arg0 = (*C.GtkCellArea)(area.Native())
	arg1 = (*C.GtkCellAreaContext)(context.Native())
	arg2 = (*C.GtkWidget)(widget.Native())
	arg3 = C.int(height)

	ret := C.gtk_cell_area_get_preferred_width_for_height(arg0, arg1, arg2, arg3, &arg4, &arg5)

	var ret0 int
	var ret1 int

	ret0 = int(arg4)

	ret1 = int(arg5)

	return ret0, ret1
}

// RequestMode gets whether the area prefers a height-for-width layout or a
// width-for-height layout.
func (area cellArea) RequestMode() SizeRequestMode {
	var arg0 *C.GtkCellArea

	arg0 = (*C.GtkCellArea)(area.Native())

	ret := C.gtk_cell_area_get_request_mode(arg0)

	var ret0 SizeRequestMode

	ret0 = SizeRequestMode(ret)

	return ret0
}

// HasRenderer checks if @area contains @renderer.
func (area cellArea) HasRenderer(renderer CellRenderer) bool {
	var arg0 *C.GtkCellArea
	var arg1 *C.GtkCellRenderer

	arg0 = (*C.GtkCellArea)(area.Native())
	arg1 = (*C.GtkCellRenderer)(renderer.Native())

	ret := C.gtk_cell_area_has_renderer(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// InnerCellArea: this is a convenience function for CellArea
// implementations to get the inner area where a given CellRenderer will be
// rendered. It removes any padding previously added by
// gtk_cell_area_request_renderer().
func (area cellArea) InnerCellArea(widget Widget, cellArea *gdk.Rectangle) gdk.Rectangle {
	var arg0 *C.GtkCellArea
	var arg1 *C.GtkWidget
	var arg2 *C.GdkRectangle
	var arg3 *C.GdkRectangle // out

	arg0 = (*C.GtkCellArea)(area.Native())
	arg1 = (*C.GtkWidget)(widget.Native())
	arg2 = (*C.GdkRectangle)(cellArea.Native())

	ret := C.gtk_cell_area_inner_cell_area(arg0, arg1, arg2, &arg3)

	var ret0 *gdk.Rectangle

	ret0 = gdk.WrapRectangle(arg3)

	return ret0
}

// IsActivatable returns whether the area can do anything when activated,
// after applying new attributes to @area.
func (area cellArea) IsActivatable() bool {
	var arg0 *C.GtkCellArea

	arg0 = (*C.GtkCellArea)(area.Native())

	ret := C.gtk_cell_area_is_activatable(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// IsFocusSibling returns whether @sibling is one of @renderer’s focus
// siblings (see gtk_cell_area_add_focus_sibling()).
func (area cellArea) IsFocusSibling(renderer CellRenderer, sibling CellRenderer) bool {
	var arg0 *C.GtkCellArea
	var arg1 *C.GtkCellRenderer
	var arg2 *C.GtkCellRenderer

	arg0 = (*C.GtkCellArea)(area.Native())
	arg1 = (*C.GtkCellRenderer)(renderer.Native())
	arg2 = (*C.GtkCellRenderer)(sibling.Native())

	ret := C.gtk_cell_area_is_focus_sibling(arg0, arg1, arg2)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Remove removes @renderer from @area.
func (area cellArea) Remove(renderer CellRenderer) {
	var arg0 *C.GtkCellArea
	var arg1 *C.GtkCellRenderer

	arg0 = (*C.GtkCellArea)(area.Native())
	arg1 = (*C.GtkCellRenderer)(renderer.Native())

	C.gtk_cell_area_remove(arg0, arg1)
}

// RemoveFocusSibling removes @sibling from @renderer’s focus sibling list
// (see gtk_cell_area_add_focus_sibling()).
func (area cellArea) RemoveFocusSibling(renderer CellRenderer, sibling CellRenderer) {
	var arg0 *C.GtkCellArea
	var arg1 *C.GtkCellRenderer
	var arg2 *C.GtkCellRenderer

	arg0 = (*C.GtkCellArea)(area.Native())
	arg1 = (*C.GtkCellRenderer)(renderer.Native())
	arg2 = (*C.GtkCellRenderer)(sibling.Native())

	C.gtk_cell_area_remove_focus_sibling(arg0, arg1, arg2)
}

// RequestRenderer: this is a convenience function for CellArea
// implementations to request size for cell renderers. It’s important to use
// this function to request size and then use
// gtk_cell_area_inner_cell_area() at render and event time since this
// function will add padding around the cell for focus painting.
func (area cellArea) RequestRenderer(renderer CellRenderer, orientation Orientation, widget Widget, forSize int) (minimumSize int, naturalSize int) {
	var arg0 *C.GtkCellArea
	var arg1 *C.GtkCellRenderer
	var arg2 C.GtkOrientation
	var arg3 *C.GtkWidget
	var arg4 C.int
	var arg5 *C.int // out
	var arg6 *C.int // out

	arg0 = (*C.GtkCellArea)(area.Native())
	arg1 = (*C.GtkCellRenderer)(renderer.Native())
	arg2 = (C.GtkOrientation)(orientation)
	arg3 = (*C.GtkWidget)(widget.Native())
	arg4 = C.int(forSize)

	ret := C.gtk_cell_area_request_renderer(arg0, arg1, arg2, arg3, arg4, &arg5, &arg6)

	var ret0 int
	var ret1 int

	ret0 = int(arg5)

	ret1 = int(arg6)

	return ret0, ret1
}

// SetFocusCell: explicitly sets the currently focused cell to @renderer.
//
// This is generally called by implementations of CellAreaClass.focus() or
// CellAreaClass.event(), however it can also be used to implement functions
// such as gtk_tree_view_set_cursor_on_cell().
func (area cellArea) SetFocusCell(renderer CellRenderer) {
	var arg0 *C.GtkCellArea
	var arg1 *C.GtkCellRenderer

	arg0 = (*C.GtkCellArea)(area.Native())
	arg1 = (*C.GtkCellRenderer)(renderer.Native())

	C.gtk_cell_area_set_focus_cell(arg0, arg1)
}

// Snapshot snapshots @area’s cells according to @area’s layout onto at the
// given coordinates.
func (area cellArea) Snapshot(context CellAreaContext, widget Widget, snapshot Snapshot, backgroundArea *gdk.Rectangle, cellArea *gdk.Rectangle, flags CellRendererState, paintFocus bool) {
	var arg0 *C.GtkCellArea
	var arg1 *C.GtkCellAreaContext
	var arg2 *C.GtkWidget
	var arg3 *C.GtkSnapshot
	var arg4 *C.GdkRectangle
	var arg5 *C.GdkRectangle
	var arg6 C.GtkCellRendererState
	var arg7 C.gboolean

	arg0 = (*C.GtkCellArea)(area.Native())
	arg1 = (*C.GtkCellAreaContext)(context.Native())
	arg2 = (*C.GtkWidget)(widget.Native())
	arg3 = (*C.GtkSnapshot)(snapshot.Native())
	arg4 = (*C.GdkRectangle)(backgroundArea.Native())
	arg5 = (*C.GdkRectangle)(cellArea.Native())
	arg6 = (C.GtkCellRendererState)(flags)
	arg7 = gextras.Cbool(paintFocus)

	C.gtk_cell_area_snapshot(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7)
}

// StopEditing: explicitly stops the editing of the currently edited cell.
//
// If @canceled is true, the currently edited cell renderer will emit the
// ::editing-canceled signal, otherwise the the ::editing-done signal will
// be emitted on the current edit widget.
//
// See gtk_cell_area_get_edited_cell() and gtk_cell_area_get_edit_widget().
func (area cellArea) StopEditing(canceled bool) {
	var arg0 *C.GtkCellArea
	var arg1 C.gboolean

	arg0 = (*C.GtkCellArea)(area.Native())
	arg1 = gextras.Cbool(canceled)

	C.gtk_cell_area_stop_editing(arg0, arg1)
}

// CellAreaBox: the CellAreaBox renders cell renderers into a row or a column
// depending on its Orientation.
//
// GtkCellAreaBox uses a notion of packing. Packing refers to adding cell
// renderers with reference to a particular position in a CellAreaBox. There are
// two reference positions: the start and the end of the box. When the
// CellAreaBox is oriented in the GTK_ORIENTATION_VERTICAL orientation, the
// start is defined as the top of the box and the end is defined as the bottom.
// In the GTK_ORIENTATION_HORIZONTAL orientation start is defined as the left
// side and the end is defined as the right side.
//
// Alignments of CellRenderers rendered in adjacent rows can be configured by
// configuring the CellAreaBox align child cell property with
// gtk_cell_area_cell_set_property() or by specifying the "align" argument to
// gtk_cell_area_box_pack_start() and gtk_cell_area_box_pack_end().
type CellAreaBox interface {
	CellArea

	// Spacing gets the spacing added between cell renderers.
	Spacing() int
	// PackEnd adds @renderer to @box, packed with reference to the end of @box.
	//
	// The @renderer is packed after (away from end of) any other CellRenderer
	// packed with reference to the end of @box.
	PackEnd(renderer CellRenderer, expand bool, align bool, fixed bool)
	// PackStart adds @renderer to @box, packed with reference to the start of
	// @box.
	//
	// The @renderer is packed after any other CellRenderer packed with
	// reference to the start of @box.
	PackStart(renderer CellRenderer, expand bool, align bool, fixed bool)
	// SetSpacing sets the spacing to add between cell renderers in @box.
	SetSpacing(spacing int)
}

type cellAreaBox struct {
	cellArea
}

// WrapCellAreaBox wraps a GObject to the right type. It is
// primarily used internally.
func WrapCellAreaBox(obj *externglib.Object) CellAreaBox {
	return cellAreaBox{cellArea{externglib.InitiallyUnowned{*externglib.Object{obj}}}}
}

func marshalCellAreaBox(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCellAreaBox(obj), nil
}

// NewCellAreaBox constructs a class CellAreaBox.
func NewCellAreaBox() CellAreaBox {

	ret := C.gtk_cell_area_box_new()

	var ret0 CellAreaBox

	ret0 = WrapCellAreaBox(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Spacing gets the spacing added between cell renderers.
func (box cellAreaBox) Spacing() int {
	var arg0 *C.GtkCellAreaBox

	arg0 = (*C.GtkCellAreaBox)(box.Native())

	ret := C.gtk_cell_area_box_get_spacing(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// PackEnd adds @renderer to @box, packed with reference to the end of @box.
//
// The @renderer is packed after (away from end of) any other CellRenderer
// packed with reference to the end of @box.
func (box cellAreaBox) PackEnd(renderer CellRenderer, expand bool, align bool, fixed bool) {
	var arg0 *C.GtkCellAreaBox
	var arg1 *C.GtkCellRenderer
	var arg2 C.gboolean
	var arg3 C.gboolean
	var arg4 C.gboolean

	arg0 = (*C.GtkCellAreaBox)(box.Native())
	arg1 = (*C.GtkCellRenderer)(renderer.Native())
	arg2 = gextras.Cbool(expand)
	arg3 = gextras.Cbool(align)
	arg4 = gextras.Cbool(fixed)

	C.gtk_cell_area_box_pack_end(arg0, arg1, arg2, arg3, arg4)
}

// PackStart adds @renderer to @box, packed with reference to the start of
// @box.
//
// The @renderer is packed after any other CellRenderer packed with
// reference to the start of @box.
func (box cellAreaBox) PackStart(renderer CellRenderer, expand bool, align bool, fixed bool) {
	var arg0 *C.GtkCellAreaBox
	var arg1 *C.GtkCellRenderer
	var arg2 C.gboolean
	var arg3 C.gboolean
	var arg4 C.gboolean

	arg0 = (*C.GtkCellAreaBox)(box.Native())
	arg1 = (*C.GtkCellRenderer)(renderer.Native())
	arg2 = gextras.Cbool(expand)
	arg3 = gextras.Cbool(align)
	arg4 = gextras.Cbool(fixed)

	C.gtk_cell_area_box_pack_start(arg0, arg1, arg2, arg3, arg4)
}

// SetSpacing sets the spacing to add between cell renderers in @box.
func (box cellAreaBox) SetSpacing(spacing int) {
	var arg0 *C.GtkCellAreaBox
	var arg1 C.int

	arg0 = (*C.GtkCellAreaBox)(box.Native())
	arg1 = C.int(spacing)

	C.gtk_cell_area_box_set_spacing(arg0, arg1)
}

// CellAreaContext: the CellAreaContext object is created by a given CellArea
// implementation via its CellAreaClass.create_context() virtual method and is
// used to store cell sizes and alignments for a series of TreeModel rows that
// are requested and rendered in the same context.
//
// CellLayout widgets can create any number of contexts in which to request and
// render groups of data rows. However, it’s important that the same context
// which was used to request sizes for a given TreeModel row also be used for
// the same row when calling other CellArea APIs such as gtk_cell_area_render()
// and gtk_cell_area_event().
type CellAreaContext interface {
	gextras.Objector

	// Allocate allocates a width and/or a height for all rows which are to be
	// rendered with @context.
	//
	// Usually allocation is performed only horizontally or sometimes vertically
	// since a group of rows are usually rendered side by side vertically or
	// horizontally and share either the same width or the same height.
	// Sometimes they are allocated in both horizontal and vertical orientations
	// producing a homogeneous effect of the rows. This is generally the case
	// for TreeView when TreeView:fixed-height-mode is enabled.
	Allocate(width int, height int)
	// Allocation fetches the current allocation size for @context.
	//
	// If the context was not allocated in width or height, or if the context
	// was recently reset with gtk_cell_area_context_reset(), the returned value
	// will be -1.
	Allocation() (width int, height int)
	// Area fetches the CellArea this @context was created by.
	//
	// This is generally unneeded by layouting widgets; however, it is important
	// for the context implementation itself to fetch information about the area
	// it is being used for.
	//
	// For instance at CellAreaContextClass.allocate() time it’s important to
	// know details about any cell spacing that the CellArea is configured with
	// in order to compute a proper allocation.
	Area() CellArea
	// PreferredHeight gets the accumulative preferred height for all rows which
	// have been requested with this context.
	//
	// After gtk_cell_area_context_reset() is called and/or before ever
	// requesting the size of a CellArea, the returned values are 0.
	PreferredHeight() (minimumHeight int, naturalHeight int)
	// PreferredHeightForWidth gets the accumulative preferred height for @width
	// for all rows which have been requested for the same said @width with this
	// context.
	//
	// After gtk_cell_area_context_reset() is called and/or before ever
	// requesting the size of a CellArea, the returned values are -1.
	PreferredHeightForWidth(width int) (minimumHeight int, naturalHeight int)
	// PreferredWidth gets the accumulative preferred width for all rows which
	// have been requested with this context.
	//
	// After gtk_cell_area_context_reset() is called and/or before ever
	// requesting the size of a CellArea, the returned values are 0.
	PreferredWidth() (minimumWidth int, naturalWidth int)
	// PreferredWidthForHeight gets the accumulative preferred width for @height
	// for all rows which have been requested for the same said @height with
	// this context.
	//
	// After gtk_cell_area_context_reset() is called and/or before ever
	// requesting the size of a CellArea, the returned values are -1.
	PreferredWidthForHeight(height int) (minimumWidth int, naturalWidth int)
	// PushPreferredHeight causes the minimum and/or natural height to grow if
	// the new proposed sizes exceed the current minimum and natural height.
	//
	// This is used by CellAreaContext implementations during the request
	// process over a series of TreeModel rows to progressively push the
	// requested height over a series of gtk_cell_area_get_preferred_height()
	// requests.
	PushPreferredHeight(minimumHeight int, naturalHeight int)
	// PushPreferredWidth causes the minimum and/or natural width to grow if the
	// new proposed sizes exceed the current minimum and natural width.
	//
	// This is used by CellAreaContext implementations during the request
	// process over a series of TreeModel rows to progressively push the
	// requested width over a series of gtk_cell_area_get_preferred_width()
	// requests.
	PushPreferredWidth(minimumWidth int, naturalWidth int)
	// Reset resets any previously cached request and allocation data.
	//
	// When underlying TreeModel data changes its important to reset the context
	// if the content size is allowed to shrink. If the content size is only
	// allowed to grow (this is usually an option for views rendering large data
	// stores as a measure of optimization), then only the row that changed or
	// was inserted needs to be (re)requested with
	// gtk_cell_area_get_preferred_width().
	//
	// When the new overall size of the context requires that the allocated size
	// changes (or whenever this allocation changes at all), the variable row
	// sizes need to be re-requested for every row.
	//
	// For instance, if the rows are displayed all with the same width from top
	// to bottom then a change in the allocated width necessitates a
	// recalculation of all the displayed row heights using
	// gtk_cell_area_get_preferred_height_for_width().
	Reset()
}

type cellAreaContext struct {
	*externglib.Object
}

// WrapCellAreaContext wraps a GObject to the right type. It is
// primarily used internally.
func WrapCellAreaContext(obj *externglib.Object) CellAreaContext {
	return cellAreaContext{*externglib.Object{obj}}
}

func marshalCellAreaContext(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCellAreaContext(obj), nil
}

// Allocate allocates a width and/or a height for all rows which are to be
// rendered with @context.
//
// Usually allocation is performed only horizontally or sometimes vertically
// since a group of rows are usually rendered side by side vertically or
// horizontally and share either the same width or the same height.
// Sometimes they are allocated in both horizontal and vertical orientations
// producing a homogeneous effect of the rows. This is generally the case
// for TreeView when TreeView:fixed-height-mode is enabled.
func (context cellAreaContext) Allocate(width int, height int) {
	var arg0 *C.GtkCellAreaContext
	var arg1 C.int
	var arg2 C.int

	arg0 = (*C.GtkCellAreaContext)(context.Native())
	arg1 = C.int(width)
	arg2 = C.int(height)

	C.gtk_cell_area_context_allocate(arg0, arg1, arg2)
}

// Allocation fetches the current allocation size for @context.
//
// If the context was not allocated in width or height, or if the context
// was recently reset with gtk_cell_area_context_reset(), the returned value
// will be -1.
func (context cellAreaContext) Allocation() (width int, height int) {
	var arg0 *C.GtkCellAreaContext
	var arg1 *C.int // out
	var arg2 *C.int // out

	arg0 = (*C.GtkCellAreaContext)(context.Native())

	ret := C.gtk_cell_area_context_get_allocation(arg0, &arg1, &arg2)

	var ret0 int
	var ret1 int

	ret0 = int(arg1)

	ret1 = int(arg2)

	return ret0, ret1
}

// Area fetches the CellArea this @context was created by.
//
// This is generally unneeded by layouting widgets; however, it is important
// for the context implementation itself to fetch information about the area
// it is being used for.
//
// For instance at CellAreaContextClass.allocate() time it’s important to
// know details about any cell spacing that the CellArea is configured with
// in order to compute a proper allocation.
func (context cellAreaContext) Area() CellArea {
	var arg0 *C.GtkCellAreaContext

	arg0 = (*C.GtkCellAreaContext)(context.Native())

	ret := C.gtk_cell_area_context_get_area(arg0)

	var ret0 CellArea

	ret0 = WrapCellArea(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// PreferredHeight gets the accumulative preferred height for all rows which
// have been requested with this context.
//
// After gtk_cell_area_context_reset() is called and/or before ever
// requesting the size of a CellArea, the returned values are 0.
func (context cellAreaContext) PreferredHeight() (minimumHeight int, naturalHeight int) {
	var arg0 *C.GtkCellAreaContext
	var arg1 *C.int // out
	var arg2 *C.int // out

	arg0 = (*C.GtkCellAreaContext)(context.Native())

	ret := C.gtk_cell_area_context_get_preferred_height(arg0, &arg1, &arg2)

	var ret0 int
	var ret1 int

	ret0 = int(arg1)

	ret1 = int(arg2)

	return ret0, ret1
}

// PreferredHeightForWidth gets the accumulative preferred height for @width
// for all rows which have been requested for the same said @width with this
// context.
//
// After gtk_cell_area_context_reset() is called and/or before ever
// requesting the size of a CellArea, the returned values are -1.
func (context cellAreaContext) PreferredHeightForWidth(width int) (minimumHeight int, naturalHeight int) {
	var arg0 *C.GtkCellAreaContext
	var arg1 C.int
	var arg2 *C.int // out
	var arg3 *C.int // out

	arg0 = (*C.GtkCellAreaContext)(context.Native())
	arg1 = C.int(width)

	ret := C.gtk_cell_area_context_get_preferred_height_for_width(arg0, arg1, &arg2, &arg3)

	var ret0 int
	var ret1 int

	ret0 = int(arg2)

	ret1 = int(arg3)

	return ret0, ret1
}

// PreferredWidth gets the accumulative preferred width for all rows which
// have been requested with this context.
//
// After gtk_cell_area_context_reset() is called and/or before ever
// requesting the size of a CellArea, the returned values are 0.
func (context cellAreaContext) PreferredWidth() (minimumWidth int, naturalWidth int) {
	var arg0 *C.GtkCellAreaContext
	var arg1 *C.int // out
	var arg2 *C.int // out

	arg0 = (*C.GtkCellAreaContext)(context.Native())

	ret := C.gtk_cell_area_context_get_preferred_width(arg0, &arg1, &arg2)

	var ret0 int
	var ret1 int

	ret0 = int(arg1)

	ret1 = int(arg2)

	return ret0, ret1
}

// PreferredWidthForHeight gets the accumulative preferred width for @height
// for all rows which have been requested for the same said @height with
// this context.
//
// After gtk_cell_area_context_reset() is called and/or before ever
// requesting the size of a CellArea, the returned values are -1.
func (context cellAreaContext) PreferredWidthForHeight(height int) (minimumWidth int, naturalWidth int) {
	var arg0 *C.GtkCellAreaContext
	var arg1 C.int
	var arg2 *C.int // out
	var arg3 *C.int // out

	arg0 = (*C.GtkCellAreaContext)(context.Native())
	arg1 = C.int(height)

	ret := C.gtk_cell_area_context_get_preferred_width_for_height(arg0, arg1, &arg2, &arg3)

	var ret0 int
	var ret1 int

	ret0 = int(arg2)

	ret1 = int(arg3)

	return ret0, ret1
}

// PushPreferredHeight causes the minimum and/or natural height to grow if
// the new proposed sizes exceed the current minimum and natural height.
//
// This is used by CellAreaContext implementations during the request
// process over a series of TreeModel rows to progressively push the
// requested height over a series of gtk_cell_area_get_preferred_height()
// requests.
func (context cellAreaContext) PushPreferredHeight(minimumHeight int, naturalHeight int) {
	var arg0 *C.GtkCellAreaContext
	var arg1 C.int
	var arg2 C.int

	arg0 = (*C.GtkCellAreaContext)(context.Native())
	arg1 = C.int(minimumHeight)
	arg2 = C.int(naturalHeight)

	C.gtk_cell_area_context_push_preferred_height(arg0, arg1, arg2)
}

// PushPreferredWidth causes the minimum and/or natural width to grow if the
// new proposed sizes exceed the current minimum and natural width.
//
// This is used by CellAreaContext implementations during the request
// process over a series of TreeModel rows to progressively push the
// requested width over a series of gtk_cell_area_get_preferred_width()
// requests.
func (context cellAreaContext) PushPreferredWidth(minimumWidth int, naturalWidth int) {
	var arg0 *C.GtkCellAreaContext
	var arg1 C.int
	var arg2 C.int

	arg0 = (*C.GtkCellAreaContext)(context.Native())
	arg1 = C.int(minimumWidth)
	arg2 = C.int(naturalWidth)

	C.gtk_cell_area_context_push_preferred_width(arg0, arg1, arg2)
}

// Reset resets any previously cached request and allocation data.
//
// When underlying TreeModel data changes its important to reset the context
// if the content size is allowed to shrink. If the content size is only
// allowed to grow (this is usually an option for views rendering large data
// stores as a measure of optimization), then only the row that changed or
// was inserted needs to be (re)requested with
// gtk_cell_area_get_preferred_width().
//
// When the new overall size of the context requires that the allocated size
// changes (or whenever this allocation changes at all), the variable row
// sizes need to be re-requested for every row.
//
// For instance, if the rows are displayed all with the same width from top
// to bottom then a change in the allocated width necessitates a
// recalculation of all the displayed row heights using
// gtk_cell_area_get_preferred_height_for_width().
func (context cellAreaContext) Reset() {
	var arg0 *C.GtkCellAreaContext

	arg0 = (*C.GtkCellAreaContext)(context.Native())

	C.gtk_cell_area_context_reset(arg0)
}

// CellRenderer: the CellRenderer is a base class of a set of objects used for
// rendering a cell to a #cairo_t. These objects are used primarily by the
// TreeView widget, though they aren’t tied to them in any specific way. It is
// worth noting that CellRenderer is not a Widget and cannot be treated as such.
//
// The primary use of a CellRenderer is for drawing a certain graphical elements
// on a #cairo_t. Typically, one cell renderer is used to draw many cells on the
// screen. To this extent, it isn’t expected that a CellRenderer keep any
// permanent state around. Instead, any state is set just prior to use using
// #GObjects property system. Then, the cell is measured using
// gtk_cell_renderer_get_preferred_size(). Finally, the cell is rendered in the
// correct location using gtk_cell_renderer_snapshot().
//
// There are a number of rules that must be followed when writing a new
// CellRenderer. First and foremost, it’s important that a certain set of
// properties will always yield a cell renderer of the same size, barring a
// style change. The CellRenderer also has a number of generic properties that
// are expected to be honored by all children.
//
// Beyond merely rendering a cell, cell renderers can optionally provide active
// user interface elements. A cell renderer can be “activatable” like
// CellRendererToggle, which toggles when it gets activated by a mouse click, or
// it can be “editable” like CellRendererText, which allows the user to edit the
// text using a widget implementing the CellEditable interface, e.g. Entry. To
// make a cell renderer activatable or editable, you have to implement the
// CellRendererClass.activate or CellRendererClass.start_editing virtual
// functions, respectively.
//
// Many properties of CellRenderer and its subclasses have a corresponding “set”
// property, e.g. “cell-background-set” corresponds to “cell-background”. These
// “set” properties reflect whether a property has been set or not. You should
// not set them independently.
type CellRenderer interface {
	gextras.Objector

	// Activate passes an activate event to the cell renderer for possible
	// processing. Some cell renderers may use events; for example,
	// CellRendererToggle toggles when it gets a mouse click.
	Activate(event gdk.Event, widget Widget, path string, backgroundArea *gdk.Rectangle, cellArea *gdk.Rectangle, flags CellRendererState) bool
	// AlignedArea gets the aligned area used by @cell inside @cell_area. Used
	// for finding the appropriate edit and focus rectangle.
	AlignedArea(widget Widget, flags CellRendererState, cellArea *gdk.Rectangle) gdk.Rectangle
	// Alignment fills in @xalign and @yalign with the appropriate values of
	// @cell.
	Alignment() (xalign float32, yalign float32)
	// FixedSize fills in @width and @height with the appropriate size of @cell.
	FixedSize() (width int, height int)
	// IsExpanded checks whether the given CellRenderer is expanded.
	IsExpanded() bool
	// IsExpander checks whether the given CellRenderer is an expander.
	IsExpander() bool
	// Padding fills in @xpad and @ypad with the appropriate values of @cell.
	Padding() (xpad int, ypad int)
	// PreferredHeight retrieves a renderer’s natural size when rendered to
	// @widget.
	PreferredHeight(widget Widget) (minimumSize int, naturalSize int)
	// PreferredHeightForWidth retrieves a cell renderers’s minimum and natural
	// height if it were rendered to @widget with the specified @width.
	PreferredHeightForWidth(widget Widget, width int) (minimumHeight int, naturalHeight int)
	// PreferredSize retrieves the minimum and natural size of a cell taking
	// into account the widget’s preference for height-for-width management.
	PreferredSize(widget Widget) (minimumSize Requisition, naturalSize Requisition)
	// PreferredWidth retrieves a renderer’s natural size when rendered to
	// @widget.
	PreferredWidth(widget Widget) (minimumSize int, naturalSize int)
	// PreferredWidthForHeight retrieves a cell renderers’s minimum and natural
	// width if it were rendered to @widget with the specified @height.
	PreferredWidthForHeight(widget Widget, height int) (minimumWidth int, naturalWidth int)
	// RequestMode gets whether the cell renderer prefers a height-for-width
	// layout or a width-for-height layout.
	RequestMode() SizeRequestMode
	// Sensitive returns the cell renderer’s sensitivity.
	Sensitive() bool
	// State translates the cell renderer state to StateFlags, based on the cell
	// renderer and widget sensitivity, and the given CellRendererState.
	State(widget Widget, cellState CellRendererState) StateFlags
	// Visible returns the cell renderer’s visibility.
	Visible() bool
	// IsActivatable checks whether the cell renderer can do something when
	// activated.
	IsActivatable() bool
	// SetAlignment sets the renderer’s alignment within its available space.
	SetAlignment(xalign float32, yalign float32)
	// SetFixedSize sets the renderer size to be explicit, independent of the
	// properties set.
	SetFixedSize(width int, height int)
	// SetIsExpanded sets whether the given CellRenderer is expanded.
	SetIsExpanded(isExpanded bool)
	// SetIsExpander sets whether the given CellRenderer is an expander.
	SetIsExpander(isExpander bool)
	// SetPadding sets the renderer’s padding.
	SetPadding(xpad int, ypad int)
	// SetSensitive sets the cell renderer’s sensitivity.
	SetSensitive(sensitive bool)
	// SetVisible sets the cell renderer’s visibility.
	SetVisible(visible bool)
	// Snapshot invokes the virtual render function of the CellRenderer. The
	// three passed-in rectangles are areas in @cr. Most renderers will draw
	// within @cell_area; the xalign, yalign, xpad, and ypad fields of the
	// CellRenderer should be honored with respect to @cell_area.
	// @background_area includes the blank space around the cell, and also the
	// area containing the tree expander; so the @background_area rectangles for
	// all cells tile to cover the entire @window.
	Snapshot(snapshot Snapshot, widget Widget, backgroundArea *gdk.Rectangle, cellArea *gdk.Rectangle, flags CellRendererState)
	// StartEditing starts editing the contents of this @cell, through a new
	// CellEditable widget created by the CellRendererClass.start_editing
	// virtual function.
	StartEditing(event gdk.Event, widget Widget, path string, backgroundArea *gdk.Rectangle, cellArea *gdk.Rectangle, flags CellRendererState) CellEditable
	// StopEditing informs the cell renderer that the editing is stopped. If
	// @canceled is true, the cell renderer will emit the
	// CellRenderer::editing-canceled signal.
	//
	// This function should be called by cell renderer implementations in
	// response to the CellEditable::editing-done signal of CellEditable.
	StopEditing(canceled bool)
}

type cellRenderer struct {
	externglib.InitiallyUnowned
}

// WrapCellRenderer wraps a GObject to the right type. It is
// primarily used internally.
func WrapCellRenderer(obj *externglib.Object) CellRenderer {
	return cellRenderer{externglib.InitiallyUnowned{*externglib.Object{obj}}}
}

func marshalCellRenderer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCellRenderer(obj), nil
}

// Activate passes an activate event to the cell renderer for possible
// processing. Some cell renderers may use events; for example,
// CellRendererToggle toggles when it gets a mouse click.
func (cell cellRenderer) Activate(event gdk.Event, widget Widget, path string, backgroundArea *gdk.Rectangle, cellArea *gdk.Rectangle, flags CellRendererState) bool {
	var arg0 *C.GtkCellRenderer
	var arg1 *C.GdkEvent
	var arg2 *C.GtkWidget
	var arg3 *C.char
	var arg4 *C.GdkRectangle
	var arg5 *C.GdkRectangle
	var arg6 C.GtkCellRendererState

	arg0 = (*C.GtkCellRenderer)(cell.Native())
	arg1 = (*C.GdkEvent)(event.Native())
	arg2 = (*C.GtkWidget)(widget.Native())
	arg3 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = (*C.GdkRectangle)(backgroundArea.Native())
	arg5 = (*C.GdkRectangle)(cellArea.Native())
	arg6 = (C.GtkCellRendererState)(flags)

	ret := C.gtk_cell_renderer_activate(arg0, arg1, arg2, arg3, arg4, arg5, arg6)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// AlignedArea gets the aligned area used by @cell inside @cell_area. Used
// for finding the appropriate edit and focus rectangle.
func (cell cellRenderer) AlignedArea(widget Widget, flags CellRendererState, cellArea *gdk.Rectangle) gdk.Rectangle {
	var arg0 *C.GtkCellRenderer
	var arg1 *C.GtkWidget
	var arg2 C.GtkCellRendererState
	var arg3 *C.GdkRectangle
	var arg4 *C.GdkRectangle // out

	arg0 = (*C.GtkCellRenderer)(cell.Native())
	arg1 = (*C.GtkWidget)(widget.Native())
	arg2 = (C.GtkCellRendererState)(flags)
	arg3 = (*C.GdkRectangle)(cellArea.Native())

	ret := C.gtk_cell_renderer_get_aligned_area(arg0, arg1, arg2, arg3, &arg4)

	var ret0 *gdk.Rectangle

	ret0 = gdk.WrapRectangle(arg4)

	return ret0
}

// Alignment fills in @xalign and @yalign with the appropriate values of
// @cell.
func (cell cellRenderer) Alignment() (xalign float32, yalign float32) {
	var arg0 *C.GtkCellRenderer
	var arg1 *C.float // out
	var arg2 *C.float // out

	arg0 = (*C.GtkCellRenderer)(cell.Native())

	ret := C.gtk_cell_renderer_get_alignment(arg0, &arg1, &arg2)

	var ret0 float32
	var ret1 float32

	ret0 = float32(arg1)

	ret1 = float32(arg2)

	return ret0, ret1
}

// FixedSize fills in @width and @height with the appropriate size of @cell.
func (cell cellRenderer) FixedSize() (width int, height int) {
	var arg0 *C.GtkCellRenderer
	var arg1 *C.int // out
	var arg2 *C.int // out

	arg0 = (*C.GtkCellRenderer)(cell.Native())

	ret := C.gtk_cell_renderer_get_fixed_size(arg0, &arg1, &arg2)

	var ret0 int
	var ret1 int

	ret0 = int(arg1)

	ret1 = int(arg2)

	return ret0, ret1
}

// IsExpanded checks whether the given CellRenderer is expanded.
func (cell cellRenderer) IsExpanded() bool {
	var arg0 *C.GtkCellRenderer

	arg0 = (*C.GtkCellRenderer)(cell.Native())

	ret := C.gtk_cell_renderer_get_is_expanded(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// IsExpander checks whether the given CellRenderer is an expander.
func (cell cellRenderer) IsExpander() bool {
	var arg0 *C.GtkCellRenderer

	arg0 = (*C.GtkCellRenderer)(cell.Native())

	ret := C.gtk_cell_renderer_get_is_expander(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Padding fills in @xpad and @ypad with the appropriate values of @cell.
func (cell cellRenderer) Padding() (xpad int, ypad int) {
	var arg0 *C.GtkCellRenderer
	var arg1 *C.int // out
	var arg2 *C.int // out

	arg0 = (*C.GtkCellRenderer)(cell.Native())

	ret := C.gtk_cell_renderer_get_padding(arg0, &arg1, &arg2)

	var ret0 int
	var ret1 int

	ret0 = int(arg1)

	ret1 = int(arg2)

	return ret0, ret1
}

// PreferredHeight retrieves a renderer’s natural size when rendered to
// @widget.
func (cell cellRenderer) PreferredHeight(widget Widget) (minimumSize int, naturalSize int) {
	var arg0 *C.GtkCellRenderer
	var arg1 *C.GtkWidget
	var arg2 *C.int // out
	var arg3 *C.int // out

	arg0 = (*C.GtkCellRenderer)(cell.Native())
	arg1 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_cell_renderer_get_preferred_height(arg0, arg1, &arg2, &arg3)

	var ret0 int
	var ret1 int

	ret0 = int(arg2)

	ret1 = int(arg3)

	return ret0, ret1
}

// PreferredHeightForWidth retrieves a cell renderers’s minimum and natural
// height if it were rendered to @widget with the specified @width.
func (cell cellRenderer) PreferredHeightForWidth(widget Widget, width int) (minimumHeight int, naturalHeight int) {
	var arg0 *C.GtkCellRenderer
	var arg1 *C.GtkWidget
	var arg2 C.int
	var arg3 *C.int // out
	var arg4 *C.int // out

	arg0 = (*C.GtkCellRenderer)(cell.Native())
	arg1 = (*C.GtkWidget)(widget.Native())
	arg2 = C.int(width)

	ret := C.gtk_cell_renderer_get_preferred_height_for_width(arg0, arg1, arg2, &arg3, &arg4)

	var ret0 int
	var ret1 int

	ret0 = int(arg3)

	ret1 = int(arg4)

	return ret0, ret1
}

// PreferredSize retrieves the minimum and natural size of a cell taking
// into account the widget’s preference for height-for-width management.
func (cell cellRenderer) PreferredSize(widget Widget) (minimumSize Requisition, naturalSize Requisition) {
	var arg0 *C.GtkCellRenderer
	var arg1 *C.GtkWidget
	var arg2 *C.GtkRequisition // out
	var arg3 *C.GtkRequisition // out

	arg0 = (*C.GtkCellRenderer)(cell.Native())
	arg1 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_cell_renderer_get_preferred_size(arg0, arg1, &arg2, &arg3)

	var ret0 *Requisition
	var ret1 *Requisition

	ret0 = WrapRequisition(arg2)

	ret1 = WrapRequisition(arg3)

	return ret0, ret1
}

// PreferredWidth retrieves a renderer’s natural size when rendered to
// @widget.
func (cell cellRenderer) PreferredWidth(widget Widget) (minimumSize int, naturalSize int) {
	var arg0 *C.GtkCellRenderer
	var arg1 *C.GtkWidget
	var arg2 *C.int // out
	var arg3 *C.int // out

	arg0 = (*C.GtkCellRenderer)(cell.Native())
	arg1 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_cell_renderer_get_preferred_width(arg0, arg1, &arg2, &arg3)

	var ret0 int
	var ret1 int

	ret0 = int(arg2)

	ret1 = int(arg3)

	return ret0, ret1
}

// PreferredWidthForHeight retrieves a cell renderers’s minimum and natural
// width if it were rendered to @widget with the specified @height.
func (cell cellRenderer) PreferredWidthForHeight(widget Widget, height int) (minimumWidth int, naturalWidth int) {
	var arg0 *C.GtkCellRenderer
	var arg1 *C.GtkWidget
	var arg2 C.int
	var arg3 *C.int // out
	var arg4 *C.int // out

	arg0 = (*C.GtkCellRenderer)(cell.Native())
	arg1 = (*C.GtkWidget)(widget.Native())
	arg2 = C.int(height)

	ret := C.gtk_cell_renderer_get_preferred_width_for_height(arg0, arg1, arg2, &arg3, &arg4)

	var ret0 int
	var ret1 int

	ret0 = int(arg3)

	ret1 = int(arg4)

	return ret0, ret1
}

// RequestMode gets whether the cell renderer prefers a height-for-width
// layout or a width-for-height layout.
func (cell cellRenderer) RequestMode() SizeRequestMode {
	var arg0 *C.GtkCellRenderer

	arg0 = (*C.GtkCellRenderer)(cell.Native())

	ret := C.gtk_cell_renderer_get_request_mode(arg0)

	var ret0 SizeRequestMode

	ret0 = SizeRequestMode(ret)

	return ret0
}

// Sensitive returns the cell renderer’s sensitivity.
func (cell cellRenderer) Sensitive() bool {
	var arg0 *C.GtkCellRenderer

	arg0 = (*C.GtkCellRenderer)(cell.Native())

	ret := C.gtk_cell_renderer_get_sensitive(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// State translates the cell renderer state to StateFlags, based on the cell
// renderer and widget sensitivity, and the given CellRendererState.
func (cell cellRenderer) State(widget Widget, cellState CellRendererState) StateFlags {
	var arg0 *C.GtkCellRenderer
	var arg1 *C.GtkWidget
	var arg2 C.GtkCellRendererState

	arg0 = (*C.GtkCellRenderer)(cell.Native())
	arg1 = (*C.GtkWidget)(widget.Native())
	arg2 = (C.GtkCellRendererState)(cellState)

	ret := C.gtk_cell_renderer_get_state(arg0, arg1, arg2)

	var ret0 StateFlags

	ret0 = StateFlags(ret)

	return ret0
}

// Visible returns the cell renderer’s visibility.
func (cell cellRenderer) Visible() bool {
	var arg0 *C.GtkCellRenderer

	arg0 = (*C.GtkCellRenderer)(cell.Native())

	ret := C.gtk_cell_renderer_get_visible(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// IsActivatable checks whether the cell renderer can do something when
// activated.
func (cell cellRenderer) IsActivatable() bool {
	var arg0 *C.GtkCellRenderer

	arg0 = (*C.GtkCellRenderer)(cell.Native())

	ret := C.gtk_cell_renderer_is_activatable(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// SetAlignment sets the renderer’s alignment within its available space.
func (cell cellRenderer) SetAlignment(xalign float32, yalign float32) {
	var arg0 *C.GtkCellRenderer
	var arg1 C.float
	var arg2 C.float

	arg0 = (*C.GtkCellRenderer)(cell.Native())
	arg1 = C.float(xalign)
	arg2 = C.float(yalign)

	C.gtk_cell_renderer_set_alignment(arg0, arg1, arg2)
}

// SetFixedSize sets the renderer size to be explicit, independent of the
// properties set.
func (cell cellRenderer) SetFixedSize(width int, height int) {
	var arg0 *C.GtkCellRenderer
	var arg1 C.int
	var arg2 C.int

	arg0 = (*C.GtkCellRenderer)(cell.Native())
	arg1 = C.int(width)
	arg2 = C.int(height)

	C.gtk_cell_renderer_set_fixed_size(arg0, arg1, arg2)
}

// SetIsExpanded sets whether the given CellRenderer is expanded.
func (cell cellRenderer) SetIsExpanded(isExpanded bool) {
	var arg0 *C.GtkCellRenderer
	var arg1 C.gboolean

	arg0 = (*C.GtkCellRenderer)(cell.Native())
	arg1 = gextras.Cbool(isExpanded)

	C.gtk_cell_renderer_set_is_expanded(arg0, arg1)
}

// SetIsExpander sets whether the given CellRenderer is an expander.
func (cell cellRenderer) SetIsExpander(isExpander bool) {
	var arg0 *C.GtkCellRenderer
	var arg1 C.gboolean

	arg0 = (*C.GtkCellRenderer)(cell.Native())
	arg1 = gextras.Cbool(isExpander)

	C.gtk_cell_renderer_set_is_expander(arg0, arg1)
}

// SetPadding sets the renderer’s padding.
func (cell cellRenderer) SetPadding(xpad int, ypad int) {
	var arg0 *C.GtkCellRenderer
	var arg1 C.int
	var arg2 C.int

	arg0 = (*C.GtkCellRenderer)(cell.Native())
	arg1 = C.int(xpad)
	arg2 = C.int(ypad)

	C.gtk_cell_renderer_set_padding(arg0, arg1, arg2)
}

// SetSensitive sets the cell renderer’s sensitivity.
func (cell cellRenderer) SetSensitive(sensitive bool) {
	var arg0 *C.GtkCellRenderer
	var arg1 C.gboolean

	arg0 = (*C.GtkCellRenderer)(cell.Native())
	arg1 = gextras.Cbool(sensitive)

	C.gtk_cell_renderer_set_sensitive(arg0, arg1)
}

// SetVisible sets the cell renderer’s visibility.
func (cell cellRenderer) SetVisible(visible bool) {
	var arg0 *C.GtkCellRenderer
	var arg1 C.gboolean

	arg0 = (*C.GtkCellRenderer)(cell.Native())
	arg1 = gextras.Cbool(visible)

	C.gtk_cell_renderer_set_visible(arg0, arg1)
}

// Snapshot invokes the virtual render function of the CellRenderer. The
// three passed-in rectangles are areas in @cr. Most renderers will draw
// within @cell_area; the xalign, yalign, xpad, and ypad fields of the
// CellRenderer should be honored with respect to @cell_area.
// @background_area includes the blank space around the cell, and also the
// area containing the tree expander; so the @background_area rectangles for
// all cells tile to cover the entire @window.
func (cell cellRenderer) Snapshot(snapshot Snapshot, widget Widget, backgroundArea *gdk.Rectangle, cellArea *gdk.Rectangle, flags CellRendererState) {
	var arg0 *C.GtkCellRenderer
	var arg1 *C.GtkSnapshot
	var arg2 *C.GtkWidget
	var arg3 *C.GdkRectangle
	var arg4 *C.GdkRectangle
	var arg5 C.GtkCellRendererState

	arg0 = (*C.GtkCellRenderer)(cell.Native())
	arg1 = (*C.GtkSnapshot)(snapshot.Native())
	arg2 = (*C.GtkWidget)(widget.Native())
	arg3 = (*C.GdkRectangle)(backgroundArea.Native())
	arg4 = (*C.GdkRectangle)(cellArea.Native())
	arg5 = (C.GtkCellRendererState)(flags)

	C.gtk_cell_renderer_snapshot(arg0, arg1, arg2, arg3, arg4, arg5)
}

// StartEditing starts editing the contents of this @cell, through a new
// CellEditable widget created by the CellRendererClass.start_editing
// virtual function.
func (cell cellRenderer) StartEditing(event gdk.Event, widget Widget, path string, backgroundArea *gdk.Rectangle, cellArea *gdk.Rectangle, flags CellRendererState) CellEditable {
	var arg0 *C.GtkCellRenderer
	var arg1 *C.GdkEvent
	var arg2 *C.GtkWidget
	var arg3 *C.char
	var arg4 *C.GdkRectangle
	var arg5 *C.GdkRectangle
	var arg6 C.GtkCellRendererState

	arg0 = (*C.GtkCellRenderer)(cell.Native())
	arg1 = (*C.GdkEvent)(event.Native())
	arg2 = (*C.GtkWidget)(widget.Native())
	arg3 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = (*C.GdkRectangle)(backgroundArea.Native())
	arg5 = (*C.GdkRectangle)(cellArea.Native())
	arg6 = (C.GtkCellRendererState)(flags)

	ret := C.gtk_cell_renderer_start_editing(arg0, arg1, arg2, arg3, arg4, arg5, arg6)

	var ret0 CellEditable

	return ret0
}

// StopEditing informs the cell renderer that the editing is stopped. If
// @canceled is true, the cell renderer will emit the
// CellRenderer::editing-canceled signal.
//
// This function should be called by cell renderer implementations in
// response to the CellEditable::editing-done signal of CellEditable.
func (cell cellRenderer) StopEditing(canceled bool) {
	var arg0 *C.GtkCellRenderer
	var arg1 C.gboolean

	arg0 = (*C.GtkCellRenderer)(cell.Native())
	arg1 = gextras.Cbool(canceled)

	C.gtk_cell_renderer_stop_editing(arg0, arg1)
}

// CellRendererAccel displays a keyboard accelerator (i.e. a key combination
// like `Control + a`). If the cell renderer is editable, the accelerator can be
// changed by simply typing the new combination.
type CellRendererAccel interface {
	CellRendererText
}

type cellRendererAccel struct {
	cellRendererText
}

// WrapCellRendererAccel wraps a GObject to the right type. It is
// primarily used internally.
func WrapCellRendererAccel(obj *externglib.Object) CellRendererAccel {
	return cellRendererAccel{cellRendererText{cellRenderer{externglib.InitiallyUnowned{*externglib.Object{obj}}}}}
}

func marshalCellRendererAccel(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCellRendererAccel(obj), nil
}

// NewCellRendererAccel constructs a class CellRendererAccel.
func NewCellRendererAccel() CellRendererAccel {

	ret := C.gtk_cell_renderer_accel_new()

	var ret0 CellRendererAccel

	ret0 = WrapCellRendererAccel(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// CellRendererCombo renders text in a cell like CellRendererText from which it
// is derived. But while CellRendererText offers a simple entry to edit the
// text, CellRendererCombo offers a ComboBox widget to edit the text. The values
// to display in the combo box are taken from the tree model specified in the
// CellRendererCombo:model property.
//
// The combo cell renderer takes care of adding a text cell renderer to the
// combo box and sets it to display the column specified by its
// CellRendererCombo:text-column property. Further properties of the combo box
// can be set in a handler for the CellRenderer::editing-started signal.
type CellRendererCombo interface {
	CellRendererText
}

type cellRendererCombo struct {
	cellRendererText
}

// WrapCellRendererCombo wraps a GObject to the right type. It is
// primarily used internally.
func WrapCellRendererCombo(obj *externglib.Object) CellRendererCombo {
	return cellRendererCombo{cellRendererText{cellRenderer{externglib.InitiallyUnowned{*externglib.Object{obj}}}}}
}

func marshalCellRendererCombo(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCellRendererCombo(obj), nil
}

// NewCellRendererCombo constructs a class CellRendererCombo.
func NewCellRendererCombo() CellRendererCombo {

	ret := C.gtk_cell_renderer_combo_new()

	var ret0 CellRendererCombo

	ret0 = WrapCellRendererCombo(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// CellRendererPixbuf: a CellRendererPixbuf can be used to render an image in a
// cell. It allows to render either a given Pixbuf (set via the
// CellRendererPixbuf:pixbuf property) or a named icon (set via the
// CellRendererPixbuf:icon-name property).
//
// To support the tree view, CellRendererPixbuf also supports rendering two
// alternative pixbufs, when the CellRenderer:is-expander property is true. If
// the CellRenderer:is-expanded property is true and the
// CellRendererPixbuf:pixbuf-expander-open property is set to a pixbuf, it
// renders that pixbuf, if the CellRenderer:is-expanded property is false and
// the CellRendererPixbuf:pixbuf-expander-closed property is set to a pixbuf, it
// renders that one.
type CellRendererPixbuf interface {
	CellRenderer
}

type cellRendererPixbuf struct {
	cellRenderer
}

// WrapCellRendererPixbuf wraps a GObject to the right type. It is
// primarily used internally.
func WrapCellRendererPixbuf(obj *externglib.Object) CellRendererPixbuf {
	return cellRendererPixbuf{cellRenderer{externglib.InitiallyUnowned{*externglib.Object{obj}}}}
}

func marshalCellRendererPixbuf(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCellRendererPixbuf(obj), nil
}

// NewCellRendererPixbuf constructs a class CellRendererPixbuf.
func NewCellRendererPixbuf() CellRendererPixbuf {

	ret := C.gtk_cell_renderer_pixbuf_new()

	var ret0 CellRendererPixbuf

	ret0 = WrapCellRendererPixbuf(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// CellRendererProgress renders a numeric value as a progress par in a cell.
// Additionally, it can display a text on top of the progress bar.
type CellRendererProgress interface {
	CellRenderer
}

type cellRendererProgress struct {
	cellRenderer
}

// WrapCellRendererProgress wraps a GObject to the right type. It is
// primarily used internally.
func WrapCellRendererProgress(obj *externglib.Object) CellRendererProgress {
	return cellRendererProgress{cellRenderer{externglib.InitiallyUnowned{*externglib.Object{obj}}}}
}

func marshalCellRendererProgress(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCellRendererProgress(obj), nil
}

// NewCellRendererProgress constructs a class CellRendererProgress.
func NewCellRendererProgress() CellRendererProgress {

	ret := C.gtk_cell_renderer_progress_new()

	var ret0 CellRendererProgress

	ret0 = WrapCellRendererProgress(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// CellRendererSpin renders text in a cell like CellRendererText from which it
// is derived. But while CellRendererText offers a simple entry to edit the
// text, CellRendererSpin offers a SpinButton widget. Of course, that means that
// the text has to be parseable as a floating point number.
//
// The range of the spinbutton is taken from the adjustment property of the cell
// renderer, which can be set explicitly or mapped to a column in the tree
// model, like all properties of cell renders. CellRendererSpin also has
// properties for the CellRendererSpin:climb-rate and the number of
// CellRendererSpin:digits to display. Other SpinButton properties can be set in
// a handler for the CellRenderer::editing-started signal.
//
// The CellRendererSpin cell renderer was added in GTK 2.10.
type CellRendererSpin interface {
	CellRendererText
}

type cellRendererSpin struct {
	cellRendererText
}

// WrapCellRendererSpin wraps a GObject to the right type. It is
// primarily used internally.
func WrapCellRendererSpin(obj *externglib.Object) CellRendererSpin {
	return cellRendererSpin{cellRendererText{cellRenderer{externglib.InitiallyUnowned{*externglib.Object{obj}}}}}
}

func marshalCellRendererSpin(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCellRendererSpin(obj), nil
}

// NewCellRendererSpin constructs a class CellRendererSpin.
func NewCellRendererSpin() CellRendererSpin {

	ret := C.gtk_cell_renderer_spin_new()

	var ret0 CellRendererSpin

	ret0 = WrapCellRendererSpin(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// CellRendererSpinner: gtkCellRendererSpinner renders a spinning animation in a
// cell, very similar to Spinner. It can often be used as an alternative to a
// CellRendererProgress for displaying indefinite activity, instead of actual
// progress.
//
// To start the animation in a cell, set the CellRendererSpinner:active property
// to true and increment the CellRendererSpinner:pulse property at regular
// intervals. The usual way to set the cell renderer properties for each cell is
// to bind them to columns in your tree model using e.g.
// gtk_tree_view_column_add_attribute().
type CellRendererSpinner interface {
	CellRenderer
}

type cellRendererSpinner struct {
	cellRenderer
}

// WrapCellRendererSpinner wraps a GObject to the right type. It is
// primarily used internally.
func WrapCellRendererSpinner(obj *externglib.Object) CellRendererSpinner {
	return cellRendererSpinner{cellRenderer{externglib.InitiallyUnowned{*externglib.Object{obj}}}}
}

func marshalCellRendererSpinner(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCellRendererSpinner(obj), nil
}

// NewCellRendererSpinner constructs a class CellRendererSpinner.
func NewCellRendererSpinner() CellRendererSpinner {

	ret := C.gtk_cell_renderer_spinner_new()

	var ret0 CellRendererSpinner

	ret0 = WrapCellRendererSpinner(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// CellRendererText: a CellRendererText renders a given text in its cell, using
// the font, color and style information provided by its properties. The text
// will be ellipsized if it is too long and the CellRendererText:ellipsize
// property allows it.
//
// If the CellRenderer:mode is GTK_CELL_RENDERER_MODE_EDITABLE, the
// CellRendererText allows to edit its text using an entry.
type CellRendererText interface {
	CellRenderer

	// SetFixedHeightFromFont sets the height of a renderer to explicitly be
	// determined by the “font” and “y_pad” property set on it. Further changes
	// in these properties do not affect the height, so they must be accompanied
	// by a subsequent call to this function. Using this function is inflexible,
	// and should really only be used if calculating the size of a cell is too
	// slow (ie, a massive number of cells displayed). If @number_of_rows is -1,
	// then the fixed height is unset, and the height is determined by the
	// properties again.
	SetFixedHeightFromFont(numberOfRows int)
}

type cellRendererText struct {
	cellRenderer
}

// WrapCellRendererText wraps a GObject to the right type. It is
// primarily used internally.
func WrapCellRendererText(obj *externglib.Object) CellRendererText {
	return cellRendererText{cellRenderer{externglib.InitiallyUnowned{*externglib.Object{obj}}}}
}

func marshalCellRendererText(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCellRendererText(obj), nil
}

// NewCellRendererText constructs a class CellRendererText.
func NewCellRendererText() CellRendererText {

	ret := C.gtk_cell_renderer_text_new()

	var ret0 CellRendererText

	ret0 = WrapCellRendererText(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// SetFixedHeightFromFont sets the height of a renderer to explicitly be
// determined by the “font” and “y_pad” property set on it. Further changes
// in these properties do not affect the height, so they must be accompanied
// by a subsequent call to this function. Using this function is inflexible,
// and should really only be used if calculating the size of a cell is too
// slow (ie, a massive number of cells displayed). If @number_of_rows is -1,
// then the fixed height is unset, and the height is determined by the
// properties again.
func (renderer cellRendererText) SetFixedHeightFromFont(numberOfRows int) {
	var arg0 *C.GtkCellRendererText
	var arg1 C.int

	arg0 = (*C.GtkCellRendererText)(renderer.Native())
	arg1 = C.int(numberOfRows)

	C.gtk_cell_renderer_text_set_fixed_height_from_font(arg0, arg1)
}

// CellRendererToggle renders a toggle button in a cell. The button is drawn as
// a radio or a checkbutton, depending on the CellRendererToggle:radio property.
// When activated, it emits the CellRendererToggle::toggled signal.
type CellRendererToggle interface {
	CellRenderer

	// Activatable returns whether the cell renderer is activatable. See
	// gtk_cell_renderer_toggle_set_activatable().
	Activatable() bool
	// Active returns whether the cell renderer is active. See
	// gtk_cell_renderer_toggle_set_active().
	Active() bool
	// Radio returns whether we’re rendering radio toggles rather than
	// checkboxes.
	Radio() bool
	// SetActivatable makes the cell renderer activatable.
	SetActivatable(setting bool)
	// SetActive activates or deactivates a cell renderer.
	SetActive(setting bool)
	// SetRadio: if @radio is true, the cell renderer renders a radio toggle
	// (i.e. a toggle in a group of mutually-exclusive toggles). If false, it
	// renders a check toggle (a standalone boolean option). This can be set
	// globally for the cell renderer, or changed just before rendering each
	// cell in the model (for TreeView, you set up a per-row setting using
	// TreeViewColumn to associate model columns with cell renderer properties).
	SetRadio(radio bool)
}

type cellRendererToggle struct {
	cellRenderer
}

// WrapCellRendererToggle wraps a GObject to the right type. It is
// primarily used internally.
func WrapCellRendererToggle(obj *externglib.Object) CellRendererToggle {
	return cellRendererToggle{cellRenderer{externglib.InitiallyUnowned{*externglib.Object{obj}}}}
}

func marshalCellRendererToggle(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCellRendererToggle(obj), nil
}

// NewCellRendererToggle constructs a class CellRendererToggle.
func NewCellRendererToggle() CellRendererToggle {

	ret := C.gtk_cell_renderer_toggle_new()

	var ret0 CellRendererToggle

	ret0 = WrapCellRendererToggle(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Activatable returns whether the cell renderer is activatable. See
// gtk_cell_renderer_toggle_set_activatable().
func (toggle cellRendererToggle) Activatable() bool {
	var arg0 *C.GtkCellRendererToggle

	arg0 = (*C.GtkCellRendererToggle)(toggle.Native())

	ret := C.gtk_cell_renderer_toggle_get_activatable(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Active returns whether the cell renderer is active. See
// gtk_cell_renderer_toggle_set_active().
func (toggle cellRendererToggle) Active() bool {
	var arg0 *C.GtkCellRendererToggle

	arg0 = (*C.GtkCellRendererToggle)(toggle.Native())

	ret := C.gtk_cell_renderer_toggle_get_active(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Radio returns whether we’re rendering radio toggles rather than
// checkboxes.
func (toggle cellRendererToggle) Radio() bool {
	var arg0 *C.GtkCellRendererToggle

	arg0 = (*C.GtkCellRendererToggle)(toggle.Native())

	ret := C.gtk_cell_renderer_toggle_get_radio(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// SetActivatable makes the cell renderer activatable.
func (toggle cellRendererToggle) SetActivatable(setting bool) {
	var arg0 *C.GtkCellRendererToggle
	var arg1 C.gboolean

	arg0 = (*C.GtkCellRendererToggle)(toggle.Native())
	arg1 = gextras.Cbool(setting)

	C.gtk_cell_renderer_toggle_set_activatable(arg0, arg1)
}

// SetActive activates or deactivates a cell renderer.
func (toggle cellRendererToggle) SetActive(setting bool) {
	var arg0 *C.GtkCellRendererToggle
	var arg1 C.gboolean

	arg0 = (*C.GtkCellRendererToggle)(toggle.Native())
	arg1 = gextras.Cbool(setting)

	C.gtk_cell_renderer_toggle_set_active(arg0, arg1)
}

// SetRadio: if @radio is true, the cell renderer renders a radio toggle
// (i.e. a toggle in a group of mutually-exclusive toggles). If false, it
// renders a check toggle (a standalone boolean option). This can be set
// globally for the cell renderer, or changed just before rendering each
// cell in the model (for TreeView, you set up a per-row setting using
// TreeViewColumn to associate model columns with cell renderer properties).
func (toggle cellRendererToggle) SetRadio(radio bool) {
	var arg0 *C.GtkCellRendererToggle
	var arg1 C.gboolean

	arg0 = (*C.GtkCellRendererToggle)(toggle.Native())
	arg1 = gextras.Cbool(radio)

	C.gtk_cell_renderer_toggle_set_radio(arg0, arg1)
}

// CellView: a CellView displays a single row of a TreeModel using a CellArea
// and CellAreaContext. A CellAreaContext can be provided to the CellView at
// construction time in order to keep the cellview in context of a group of cell
// views, this ensures that the renderers displayed will be properly aligned
// with each other (like the aligned cells in the menus of ComboBox).
//
// CellView is Orientable in order to decide in which orientation the underlying
// CellAreaContext should be allocated. Taking the ComboBox menu as an example,
// cellviews should be oriented horizontally if the menus are listed
// top-to-bottom and thus all share the same width but may have separate
// individual heights (left-to-right menus should be allocated vertically since
// they all share the same height but may have variable widths).
//
//
// CSS nodes
//
// GtkCellView has a single CSS node with name cellview.
type CellView interface {
	Widget

	// DisplayedRow returns a TreePath referring to the currently displayed row.
	// If no row is currently displayed, nil is returned.
	DisplayedRow() *TreePath
	// DrawSensitive gets whether @cell_view is configured to draw all of its
	// cells in a sensitive state.
	DrawSensitive() bool
	// FitModel gets whether @cell_view is configured to request space to fit
	// the entire TreeModel.
	FitModel() bool
	// Model returns the model for @cell_view. If no model is used nil is
	// returned.
	Model() TreeModel
	// SetDisplayedRow sets the row of the model that is currently displayed by
	// the CellView. If the path is unset, then the contents of the cellview
	// “stick” at their last value; this is not normally a desired result, but
	// may be a needed intermediate state if say, the model for the CellView
	// becomes temporarily empty.
	SetDisplayedRow(path *TreePath)
	// SetDrawSensitive sets whether @cell_view should draw all of its cells in
	// a sensitive state, this is used by ComboBox menus to ensure that rows
	// with insensitive cells that contain children appear sensitive in the
	// parent menu item.
	SetDrawSensitive(drawSensitive bool)
	// SetFitModel sets whether @cell_view should request space to fit the
	// entire TreeModel.
	//
	// This is used by ComboBox to ensure that the cell view displayed on the
	// combo box’s button always gets enough space and does not resize when
	// selection changes.
	SetFitModel(fitModel bool)
	// SetModel sets the model for @cell_view. If @cell_view already has a model
	// set, it will remove it before setting the new model. If @model is nil,
	// then it will unset the old model.
	SetModel(model TreeModel)
}

type cellView struct {
	widget
}

// WrapCellView wraps a GObject to the right type. It is
// primarily used internally.
func WrapCellView(obj *externglib.Object) CellView {
	return cellView{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}
}

func marshalCellView(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCellView(obj), nil
}

// NewCellView constructs a class CellView.
func NewCellView() CellView {

	ret := C.gtk_cell_view_new()

	var ret0 CellView

	ret0 = WrapCellView(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewCellViewWithContext constructs a class CellView.
func NewCellViewWithContext(area CellArea, context CellAreaContext) CellView {
	var arg1 *C.GtkCellArea
	var arg2 *C.GtkCellAreaContext

	arg1 = (*C.GtkCellArea)(area.Native())
	arg2 = (*C.GtkCellAreaContext)(context.Native())

	ret := C.gtk_cell_view_new_with_context(arg1, arg2)

	var ret0 CellView

	ret0 = WrapCellView(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewCellViewWithMarkup constructs a class CellView.
func NewCellViewWithMarkup(markup string) CellView {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(markup))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_cell_view_new_with_markup(arg1)

	var ret0 CellView

	ret0 = WrapCellView(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewCellViewWithText constructs a class CellView.
func NewCellViewWithText(text string) CellView {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_cell_view_new_with_text(arg1)

	var ret0 CellView

	ret0 = WrapCellView(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewCellViewWithTexture constructs a class CellView.
func NewCellViewWithTexture(texture gdk.Texture) CellView {
	var arg1 *C.GdkTexture

	arg1 = (*C.GdkTexture)(texture.Native())

	ret := C.gtk_cell_view_new_with_texture(arg1)

	var ret0 CellView

	ret0 = WrapCellView(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// DisplayedRow returns a TreePath referring to the currently displayed row.
// If no row is currently displayed, nil is returned.
func (cellView cellView) DisplayedRow() *TreePath {
	var arg0 *C.GtkCellView

	arg0 = (*C.GtkCellView)(cellView.Native())

	ret := C.gtk_cell_view_get_displayed_row(arg0)

	var ret0 *TreePath

	ret0 = WrapTreePath(ret)

	return ret0
}

// DrawSensitive gets whether @cell_view is configured to draw all of its
// cells in a sensitive state.
func (cellView cellView) DrawSensitive() bool {
	var arg0 *C.GtkCellView

	arg0 = (*C.GtkCellView)(cellView.Native())

	ret := C.gtk_cell_view_get_draw_sensitive(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// FitModel gets whether @cell_view is configured to request space to fit
// the entire TreeModel.
func (cellView cellView) FitModel() bool {
	var arg0 *C.GtkCellView

	arg0 = (*C.GtkCellView)(cellView.Native())

	ret := C.gtk_cell_view_get_fit_model(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Model returns the model for @cell_view. If no model is used nil is
// returned.
func (cellView cellView) Model() TreeModel {
	var arg0 *C.GtkCellView

	arg0 = (*C.GtkCellView)(cellView.Native())

	ret := C.gtk_cell_view_get_model(arg0)

	var ret0 TreeModel

	return ret0
}

// SetDisplayedRow sets the row of the model that is currently displayed by
// the CellView. If the path is unset, then the contents of the cellview
// “stick” at their last value; this is not normally a desired result, but
// may be a needed intermediate state if say, the model for the CellView
// becomes temporarily empty.
func (cellView cellView) SetDisplayedRow(path *TreePath) {
	var arg0 *C.GtkCellView
	var arg1 *C.GtkTreePath

	arg0 = (*C.GtkCellView)(cellView.Native())
	arg1 = (*C.GtkTreePath)(path.Native())

	C.gtk_cell_view_set_displayed_row(arg0, arg1)
}

// SetDrawSensitive sets whether @cell_view should draw all of its cells in
// a sensitive state, this is used by ComboBox menus to ensure that rows
// with insensitive cells that contain children appear sensitive in the
// parent menu item.
func (cellView cellView) SetDrawSensitive(drawSensitive bool) {
	var arg0 *C.GtkCellView
	var arg1 C.gboolean

	arg0 = (*C.GtkCellView)(cellView.Native())
	arg1 = gextras.Cbool(drawSensitive)

	C.gtk_cell_view_set_draw_sensitive(arg0, arg1)
}

// SetFitModel sets whether @cell_view should request space to fit the
// entire TreeModel.
//
// This is used by ComboBox to ensure that the cell view displayed on the
// combo box’s button always gets enough space and does not resize when
// selection changes.
func (cellView cellView) SetFitModel(fitModel bool) {
	var arg0 *C.GtkCellView
	var arg1 C.gboolean

	arg0 = (*C.GtkCellView)(cellView.Native())
	arg1 = gextras.Cbool(fitModel)

	C.gtk_cell_view_set_fit_model(arg0, arg1)
}

// SetModel sets the model for @cell_view. If @cell_view already has a model
// set, it will remove it before setting the new model. If @model is nil,
// then it will unset the old model.
func (cellView cellView) SetModel(model TreeModel) {
	var arg0 *C.GtkCellView
	var arg1 *C.GtkTreeModel

	arg0 = (*C.GtkCellView)(cellView.Native())

	C.gtk_cell_view_set_model(arg0, arg1)
}

// CenterBox: the GtkCenterBox widget arranges three children in a horizontal or
// vertical arrangement, keeping the middle child centered as well as possible.
//
// To add children to GtkCenterBox, use gtk_center_box_set_start_widget(),
// gtk_center_box_set_center_widget() and gtk_center_box_set_end_widget().
//
// The sizing and positioning of children can be influenced with the align and
// expand properties of the children.
//
//
// GtkCenterBox as GtkBuildable
//
// The GtkCenterBox implementation of the Buildable interface supports placing
// children in the 3 positions by specifying “start”, “center” or “end” as the
// “type” attribute of a <child> element.
//
//
// CSS nodes
//
// GtkCenterBox uses a single CSS node with the name “box”,
//
// The first child of the CenterBox will be allocated depending on the text
// direction, i.e. in left-to-right layouts it will be allocated on the left and
// in right-to-left layouts on the right.
//
// In vertical orientation, the nodes of the children are arranged from top to
// bottom.
//
//
// Accessibility
//
// GtkCenterBox uses the GTK_ACCESSIBLE_ROLE_GROUP role.
type CenterBox interface {
	Widget

	// BaselinePosition gets the value set by
	// gtk_center_box_set_baseline_position().
	BaselinePosition() BaselinePosition
	// CenterWidget gets the center widget, or nil if there is none.
	CenterWidget() Widget
	// EndWidget gets the end widget, or nil if there is none.
	EndWidget() Widget
	// StartWidget gets the start widget, or nil if there is none.
	StartWidget() Widget
	// SetBaselinePosition sets the baseline position of a center box.
	//
	// This affects only horizontal boxes with at least one baseline aligned
	// child. If there is more vertical space available than requested, and the
	// baseline is not allocated by the parent then @position is used to
	// allocate the baseline wrt. the extra space available.
	SetBaselinePosition(position BaselinePosition)
	// SetCenterWidget sets the center widget. To remove the existing center
	// widget, pas nil.
	SetCenterWidget(child Widget)
	// SetEndWidget sets the end widget. To remove the existing end widget, pass
	// nil.
	SetEndWidget(child Widget)
	// SetStartWidget sets the start widget. To remove the existing start
	// widget, pass nil.
	SetStartWidget(child Widget)
}

type centerBox struct {
	widget
}

// WrapCenterBox wraps a GObject to the right type. It is
// primarily used internally.
func WrapCenterBox(obj *externglib.Object) CenterBox {
	return centerBox{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}
}

func marshalCenterBox(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCenterBox(obj), nil
}

// NewCenterBox constructs a class CenterBox.
func NewCenterBox() CenterBox {

	ret := C.gtk_center_box_new()

	var ret0 CenterBox

	ret0 = WrapCenterBox(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// BaselinePosition gets the value set by
// gtk_center_box_set_baseline_position().
func (self centerBox) BaselinePosition() BaselinePosition {
	var arg0 *C.GtkCenterBox

	arg0 = (*C.GtkCenterBox)(self.Native())

	ret := C.gtk_center_box_get_baseline_position(arg0)

	var ret0 BaselinePosition

	ret0 = BaselinePosition(ret)

	return ret0
}

// CenterWidget gets the center widget, or nil if there is none.
func (self centerBox) CenterWidget() Widget {
	var arg0 *C.GtkCenterBox

	arg0 = (*C.GtkCenterBox)(self.Native())

	ret := C.gtk_center_box_get_center_widget(arg0)

	var ret0 Widget

	ret0 = WrapWidget(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// EndWidget gets the end widget, or nil if there is none.
func (self centerBox) EndWidget() Widget {
	var arg0 *C.GtkCenterBox

	arg0 = (*C.GtkCenterBox)(self.Native())

	ret := C.gtk_center_box_get_end_widget(arg0)

	var ret0 Widget

	ret0 = WrapWidget(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// StartWidget gets the start widget, or nil if there is none.
func (self centerBox) StartWidget() Widget {
	var arg0 *C.GtkCenterBox

	arg0 = (*C.GtkCenterBox)(self.Native())

	ret := C.gtk_center_box_get_start_widget(arg0)

	var ret0 Widget

	ret0 = WrapWidget(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// SetBaselinePosition sets the baseline position of a center box.
//
// This affects only horizontal boxes with at least one baseline aligned
// child. If there is more vertical space available than requested, and the
// baseline is not allocated by the parent then @position is used to
// allocate the baseline wrt. the extra space available.
func (self centerBox) SetBaselinePosition(position BaselinePosition) {
	var arg0 *C.GtkCenterBox
	var arg1 C.GtkBaselinePosition

	arg0 = (*C.GtkCenterBox)(self.Native())
	arg1 = (C.GtkBaselinePosition)(position)

	C.gtk_center_box_set_baseline_position(arg0, arg1)
}

// SetCenterWidget sets the center widget. To remove the existing center
// widget, pas nil.
func (self centerBox) SetCenterWidget(child Widget) {
	var arg0 *C.GtkCenterBox
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkCenterBox)(self.Native())
	arg1 = (*C.GtkWidget)(child.Native())

	C.gtk_center_box_set_center_widget(arg0, arg1)
}

// SetEndWidget sets the end widget. To remove the existing end widget, pass
// nil.
func (self centerBox) SetEndWidget(child Widget) {
	var arg0 *C.GtkCenterBox
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkCenterBox)(self.Native())
	arg1 = (*C.GtkWidget)(child.Native())

	C.gtk_center_box_set_end_widget(arg0, arg1)
}

// SetStartWidget sets the start widget. To remove the existing start
// widget, pass nil.
func (self centerBox) SetStartWidget(child Widget) {
	var arg0 *C.GtkCenterBox
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkCenterBox)(self.Native())
	arg1 = (*C.GtkWidget)(child.Native())

	C.gtk_center_box_set_start_widget(arg0, arg1)
}

// CenterLayout: a CenterLayout is a layout manager that manages up to three
// children. The start widget is allocated at the start of the layout (left in
// LRT layouts and right in RTL ones), and the end widget at the end.
//
// The center widget is centered regarding the full width of the layout's.
type CenterLayout interface {
	LayoutManager

	// BaselinePosition returns the baseline position of the layout.
	BaselinePosition() BaselinePosition
	// CenterWidget returns the center widget of the layout.
	CenterWidget() Widget
	// EndWidget returns the end widget of the layout.
	EndWidget() Widget
	// Orientation gets the current orienration of the layout manager.
	Orientation() Orientation
	// StartWidget returns the start widget fo the layout.
	StartWidget() Widget
	// SetBaselinePosition sets the new baseline position of @self
	SetBaselinePosition(baselinePosition BaselinePosition)
	// SetCenterWidget sets the new center widget of @self.
	//
	// To remove the existing center widget, pass nil.
	SetCenterWidget(widget Widget)
	// SetEndWidget sets the new end widget of @self.
	//
	// To remove the existing center widget, pass nil.
	SetEndWidget(widget Widget)
	// SetOrientation sets the orientation of @self.
	SetOrientation(orientation Orientation)
	// SetStartWidget sets the new start widget of @self.
	//
	// To remove the existing start widget, pass nil.
	SetStartWidget(widget Widget)
}

type centerLayout struct {
	layoutManager
}

// WrapCenterLayout wraps a GObject to the right type. It is
// primarily used internally.
func WrapCenterLayout(obj *externglib.Object) CenterLayout {
	return centerLayout{layoutManager{*externglib.Object{obj}}}
}

func marshalCenterLayout(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCenterLayout(obj), nil
}

// NewCenterLayout constructs a class CenterLayout.
func NewCenterLayout() CenterLayout {

	ret := C.gtk_center_layout_new()

	var ret0 CenterLayout

	ret0 = WrapCenterLayout(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// BaselinePosition returns the baseline position of the layout.
func (self centerLayout) BaselinePosition() BaselinePosition {
	var arg0 *C.GtkCenterLayout

	arg0 = (*C.GtkCenterLayout)(self.Native())

	ret := C.gtk_center_layout_get_baseline_position(arg0)

	var ret0 BaselinePosition

	ret0 = BaselinePosition(ret)

	return ret0
}

// CenterWidget returns the center widget of the layout.
func (self centerLayout) CenterWidget() Widget {
	var arg0 *C.GtkCenterLayout

	arg0 = (*C.GtkCenterLayout)(self.Native())

	ret := C.gtk_center_layout_get_center_widget(arg0)

	var ret0 Widget

	ret0 = WrapWidget(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// EndWidget returns the end widget of the layout.
func (self centerLayout) EndWidget() Widget {
	var arg0 *C.GtkCenterLayout

	arg0 = (*C.GtkCenterLayout)(self.Native())

	ret := C.gtk_center_layout_get_end_widget(arg0)

	var ret0 Widget

	ret0 = WrapWidget(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Orientation gets the current orienration of the layout manager.
func (self centerLayout) Orientation() Orientation {
	var arg0 *C.GtkCenterLayout

	arg0 = (*C.GtkCenterLayout)(self.Native())

	ret := C.gtk_center_layout_get_orientation(arg0)

	var ret0 Orientation

	ret0 = Orientation(ret)

	return ret0
}

// StartWidget returns the start widget fo the layout.
func (self centerLayout) StartWidget() Widget {
	var arg0 *C.GtkCenterLayout

	arg0 = (*C.GtkCenterLayout)(self.Native())

	ret := C.gtk_center_layout_get_start_widget(arg0)

	var ret0 Widget

	ret0 = WrapWidget(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// SetBaselinePosition sets the new baseline position of @self
func (self centerLayout) SetBaselinePosition(baselinePosition BaselinePosition) {
	var arg0 *C.GtkCenterLayout
	var arg1 C.GtkBaselinePosition

	arg0 = (*C.GtkCenterLayout)(self.Native())
	arg1 = (C.GtkBaselinePosition)(baselinePosition)

	C.gtk_center_layout_set_baseline_position(arg0, arg1)
}

// SetCenterWidget sets the new center widget of @self.
//
// To remove the existing center widget, pass nil.
func (self centerLayout) SetCenterWidget(widget Widget) {
	var arg0 *C.GtkCenterLayout
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkCenterLayout)(self.Native())
	arg1 = (*C.GtkWidget)(widget.Native())

	C.gtk_center_layout_set_center_widget(arg0, arg1)
}

// SetEndWidget sets the new end widget of @self.
//
// To remove the existing center widget, pass nil.
func (self centerLayout) SetEndWidget(widget Widget) {
	var arg0 *C.GtkCenterLayout
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkCenterLayout)(self.Native())
	arg1 = (*C.GtkWidget)(widget.Native())

	C.gtk_center_layout_set_end_widget(arg0, arg1)
}

// SetOrientation sets the orientation of @self.
func (self centerLayout) SetOrientation(orientation Orientation) {
	var arg0 *C.GtkCenterLayout
	var arg1 C.GtkOrientation

	arg0 = (*C.GtkCenterLayout)(self.Native())
	arg1 = (C.GtkOrientation)(orientation)

	C.gtk_center_layout_set_orientation(arg0, arg1)
}

// SetStartWidget sets the new start widget of @self.
//
// To remove the existing start widget, pass nil.
func (self centerLayout) SetStartWidget(widget Widget) {
	var arg0 *C.GtkCenterLayout
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkCenterLayout)(self.Native())
	arg1 = (*C.GtkWidget)(widget.Native())

	C.gtk_center_layout_set_start_widget(arg0, arg1)
}

// CheckButton: a CheckButton places a label next to an indicator.
//
// CSS nodes
//
//    checkbutton[.text-button]
//    ├── check
//    ╰── [label]
//
//
// A CheckButton has a main node with name checkbutton. If the CheckButton:label
// property is set, it contains a label child. The indicator node is named check
// when no group is set, and radio if the checkbutton is grouped together with
// other checkbuttons.
//
//
// Accessibility
//
// GtkCheckButton uses the K_ACCESSIBLE_ROLE_CHECKBOX role.
type CheckButton interface {
	Widget

	// Active returns the current value of the CheckButton:active property.
	Active() bool
	// Inconsistent returns whether the check button is in an inconsistent
	// state.
	Inconsistent() bool
	// Label returns the label of the checkbutton.
	Label() string
	// UseUnderline returns the current value of the CheckButton:use-underline
	// property.
	UseUnderline() bool
	// SetActive sets the new value of the CheckButton:active property. See also
	// gtk_check_button_get_active().
	//
	// Setting CheckButton:active to true will add the `:checked:` state to both
	// the checkbutton and the indicator CSS node.
	SetActive(setting bool)
	// SetGroup adds @self to the group of @group. In a group of multiple check
	// buttons, only one button can be active at a time.
	//
	// Setting the group of a check button also changes the css name of the
	// indicator widget's CSS node to 'radio'.
	//
	// The behavior of a checkbutton in a group is also commonly known as a
	// 'radio button'.
	//
	// Note that the same effect can be achieved via the Actionable api, by
	// using the same action with parameter type and state type 's' for all
	// buttons in the group, and giving each button its own target value.
	SetGroup(group CheckButton)
	// SetInconsistent: if the user has selected a range of elements (such as
	// some text or spreadsheet cells) that are affected by a check button, and
	// the current values in that range are inconsistent, you may want to
	// display the toggle in an "in between" state. Normally you would turn off
	// the inconsistent state again if the user checks the check button. This
	// has to be done manually, gtk_check_button_set_inconsistent only affects
	// visual appearance, not the semantics of the button.
	SetInconsistent(inconsistent bool)
	// SetLabel sets the text of @self. If CheckButton:use-underline is true,
	// the underscore in @label is interpreted as mnemonic indicator, see
	// gtk_check_button_set_use_underline() for details on this behavior.
	SetLabel(label string)
	// SetUseUnderline sets the new value of the CheckButton:use-underline
	// property. See also gtk_check_button_get_use_underline().
	//
	// If @setting is true, an underscore character in @self's label indicates a
	// mnemonic accelerator key. This behavior is similar to
	// Label:use-underline.
	SetUseUnderline(setting bool)
}

type checkButton struct {
	widget
}

// WrapCheckButton wraps a GObject to the right type. It is
// primarily used internally.
func WrapCheckButton(obj *externglib.Object) CheckButton {
	return checkButton{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}
}

func marshalCheckButton(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCheckButton(obj), nil
}

// NewCheckButton constructs a class CheckButton.
func NewCheckButton() CheckButton {

	ret := C.gtk_check_button_new()

	var ret0 CheckButton

	ret0 = WrapCheckButton(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewCheckButtonWithLabel constructs a class CheckButton.
func NewCheckButtonWithLabel(label string) CheckButton {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_check_button_new_with_label(arg1)

	var ret0 CheckButton

	ret0 = WrapCheckButton(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewCheckButtonWithMnemonic constructs a class CheckButton.
func NewCheckButtonWithMnemonic(label string) CheckButton {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_check_button_new_with_mnemonic(arg1)

	var ret0 CheckButton

	ret0 = WrapCheckButton(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Active returns the current value of the CheckButton:active property.
func (self checkButton) Active() bool {
	var arg0 *C.GtkCheckButton

	arg0 = (*C.GtkCheckButton)(self.Native())

	ret := C.gtk_check_button_get_active(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Inconsistent returns whether the check button is in an inconsistent
// state.
func (checkButton checkButton) Inconsistent() bool {
	var arg0 *C.GtkCheckButton

	arg0 = (*C.GtkCheckButton)(checkButton.Native())

	ret := C.gtk_check_button_get_inconsistent(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Label returns the label of the checkbutton.
func (self checkButton) Label() string {
	var arg0 *C.GtkCheckButton

	arg0 = (*C.GtkCheckButton)(self.Native())

	ret := C.gtk_check_button_get_label(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// UseUnderline returns the current value of the CheckButton:use-underline
// property.
func (self checkButton) UseUnderline() bool {
	var arg0 *C.GtkCheckButton

	arg0 = (*C.GtkCheckButton)(self.Native())

	ret := C.gtk_check_button_get_use_underline(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// SetActive sets the new value of the CheckButton:active property. See also
// gtk_check_button_get_active().
//
// Setting CheckButton:active to true will add the `:checked:` state to both
// the checkbutton and the indicator CSS node.
func (self checkButton) SetActive(setting bool) {
	var arg0 *C.GtkCheckButton
	var arg1 C.gboolean

	arg0 = (*C.GtkCheckButton)(self.Native())
	arg1 = gextras.Cbool(setting)

	C.gtk_check_button_set_active(arg0, arg1)
}

// SetGroup adds @self to the group of @group. In a group of multiple check
// buttons, only one button can be active at a time.
//
// Setting the group of a check button also changes the css name of the
// indicator widget's CSS node to 'radio'.
//
// The behavior of a checkbutton in a group is also commonly known as a
// 'radio button'.
//
// Note that the same effect can be achieved via the Actionable api, by
// using the same action with parameter type and state type 's' for all
// buttons in the group, and giving each button its own target value.
func (self checkButton) SetGroup(group CheckButton) {
	var arg0 *C.GtkCheckButton
	var arg1 *C.GtkCheckButton

	arg0 = (*C.GtkCheckButton)(self.Native())
	arg1 = (*C.GtkCheckButton)(group.Native())

	C.gtk_check_button_set_group(arg0, arg1)
}

// SetInconsistent: if the user has selected a range of elements (such as
// some text or spreadsheet cells) that are affected by a check button, and
// the current values in that range are inconsistent, you may want to
// display the toggle in an "in between" state. Normally you would turn off
// the inconsistent state again if the user checks the check button. This
// has to be done manually, gtk_check_button_set_inconsistent only affects
// visual appearance, not the semantics of the button.
func (checkButton checkButton) SetInconsistent(inconsistent bool) {
	var arg0 *C.GtkCheckButton
	var arg1 C.gboolean

	arg0 = (*C.GtkCheckButton)(checkButton.Native())
	arg1 = gextras.Cbool(inconsistent)

	C.gtk_check_button_set_inconsistent(arg0, arg1)
}

// SetLabel sets the text of @self. If CheckButton:use-underline is true,
// the underscore in @label is interpreted as mnemonic indicator, see
// gtk_check_button_set_use_underline() for details on this behavior.
func (self checkButton) SetLabel(label string) {
	var arg0 *C.GtkCheckButton
	var arg1 *C.char

	arg0 = (*C.GtkCheckButton)(self.Native())
	arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_check_button_set_label(arg0, arg1)
}

// SetUseUnderline sets the new value of the CheckButton:use-underline
// property. See also gtk_check_button_get_use_underline().
//
// If @setting is true, an underscore character in @self's label indicates a
// mnemonic accelerator key. This behavior is similar to
// Label:use-underline.
func (self checkButton) SetUseUnderline(setting bool) {
	var arg0 *C.GtkCheckButton
	var arg1 C.gboolean

	arg0 = (*C.GtkCheckButton)(self.Native())
	arg1 = gextras.Cbool(setting)

	C.gtk_check_button_set_use_underline(arg0, arg1)
}

type ClosureExpression interface {
	Expression
}

type closureExpression struct {
	expression
}

// WrapClosureExpression wraps a GObject to the right type. It is
// primarily used internally.
func WrapClosureExpression(obj *externglib.Object) ClosureExpression {
	return closureExpression{expression{obj}}
}

func marshalClosureExpression(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapClosureExpression(obj), nil
}

// NewClosureExpression constructs a class ClosureExpression.
func NewClosureExpression(valueType externglib.Type, closure *externglib.Closure, nParams uint, params []Expression) ClosureExpression {
	var arg1 C.GType
	var arg2 *C.GClosure
	var arg3 C.guint
	var arg4 **C.GtkExpression

	arg1 = C.GType(valueType)
	{
		var dst []*C.GtkExpression
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(C.malloc(unsafe.Sizeof((*struct{})(nil)) * len(params))))
		sliceHeader.Len = len(params)
		sliceHeader.Cap = len(params)

		for i := 0; i < len(params); i++ {
			src := params[i]
			dst[i] = (*C.GtkExpression)(src.Native())
		}

		arg4 = (**C.GtkExpression)(unsafe.Pointer(sliceHeader.Data))
		arg3 = len(params)
	}

	ret := C.gtk_closure_expression_new(arg1, arg2, arg3, arg4)

	var ret0 ClosureExpression

	ret0 = WrapClosureExpression(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// ColorButton: the ColorButton is a button which displays the currently
// selected color and allows to open a color selection dialog to change the
// color. It is suitable widget for selecting a color in a preference dialog.
//
// CSS nodes
//
//    colorbutton
//    ╰── button.color
//        ╰── [content]
//
//
// GtkColorButton has a single CSS node with name colorbutton which contains a
// button node. To differentiate it from a plain Button, it gets the .color
// style class.
type ColorButton interface {
	Widget

	// Modal gets whether the dialog is modal.
	Modal() bool
	// Title gets the title of the color selection dialog.
	Title() string
	// SetModal sets whether the dialog should be modal.
	SetModal(modal bool)
	// SetTitle sets the title for the color selection dialog.
	SetTitle(title string)
}

type colorButton struct {
	widget
}

// WrapColorButton wraps a GObject to the right type. It is
// primarily used internally.
func WrapColorButton(obj *externglib.Object) ColorButton {
	return colorButton{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}
}

func marshalColorButton(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapColorButton(obj), nil
}

// NewColorButton constructs a class ColorButton.
func NewColorButton() ColorButton {

	ret := C.gtk_color_button_new()

	var ret0 ColorButton

	ret0 = WrapColorButton(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewColorButtonWithRGBA constructs a class ColorButton.
func NewColorButtonWithRGBA(rgba *gdk.RGBA) ColorButton {
	var arg1 *C.GdkRGBA

	arg1 = (*C.GdkRGBA)(rgba.Native())

	ret := C.gtk_color_button_new_with_rgba(arg1)

	var ret0 ColorButton

	ret0 = WrapColorButton(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Modal gets whether the dialog is modal.
func (button colorButton) Modal() bool {
	var arg0 *C.GtkColorButton

	arg0 = (*C.GtkColorButton)(button.Native())

	ret := C.gtk_color_button_get_modal(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Title gets the title of the color selection dialog.
func (button colorButton) Title() string {
	var arg0 *C.GtkColorButton

	arg0 = (*C.GtkColorButton)(button.Native())

	ret := C.gtk_color_button_get_title(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// SetModal sets whether the dialog should be modal.
func (button colorButton) SetModal(modal bool) {
	var arg0 *C.GtkColorButton
	var arg1 C.gboolean

	arg0 = (*C.GtkColorButton)(button.Native())
	arg1 = gextras.Cbool(modal)

	C.gtk_color_button_set_modal(arg0, arg1)
}

// SetTitle sets the title for the color selection dialog.
func (button colorButton) SetTitle(title string) {
	var arg0 *C.GtkColorButton
	var arg1 *C.char

	arg0 = (*C.GtkColorButton)(button.Native())
	arg1 = (*C.gchar)(C.CString(title))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_color_button_set_title(arg0, arg1)
}

// ColorChooserDialog: the ColorChooserDialog widget is a dialog for choosing a
// color. It implements the ColorChooser interface.
type ColorChooserDialog interface {
	Dialog
}

type colorChooserDialog struct {
	dialog
}

// WrapColorChooserDialog wraps a GObject to the right type. It is
// primarily used internally.
func WrapColorChooserDialog(obj *externglib.Object) ColorChooserDialog {
	return colorChooserDialog{dialog{window{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}}}
}

func marshalColorChooserDialog(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapColorChooserDialog(obj), nil
}

// NewColorChooserDialog constructs a class ColorChooserDialog.
func NewColorChooserDialog(title string, parent Window) ColorChooserDialog {
	var arg1 *C.char
	var arg2 *C.GtkWindow

	arg1 = (*C.gchar)(C.CString(title))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GtkWindow)(parent.Native())

	ret := C.gtk_color_chooser_dialog_new(arg1, arg2)

	var ret0 ColorChooserDialog

	ret0 = WrapColorChooserDialog(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// ColorChooserWidget: the ColorChooserWidget widget lets the user select a
// color. By default, the chooser presents a predefined palette of colors, plus
// a small number of settable custom colors. It is also possible to select a
// different color with the single-color editor. To enter the single-color
// editing mode, use the context menu of any color of the palette, or use the
// '+' button to add a new custom color.
//
// The chooser automatically remembers the last selection, as well as custom
// colors.
//
// To change the initially selected color, use gtk_color_chooser_set_rgba(). To
// get the selected color use gtk_color_chooser_get_rgba().
//
// The ColorChooserWidget is used in the ColorChooserDialog to provide a dialog
// for selecting colors.
//
//
// CSS names
//
// GtkColorChooserWidget has a single CSS node with name colorchooser.
type ColorChooserWidget interface {
	Widget
}

type colorChooserWidget struct {
	widget
}

// WrapColorChooserWidget wraps a GObject to the right type. It is
// primarily used internally.
func WrapColorChooserWidget(obj *externglib.Object) ColorChooserWidget {
	return colorChooserWidget{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}
}

func marshalColorChooserWidget(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapColorChooserWidget(obj), nil
}

// NewColorChooserWidget constructs a class ColorChooserWidget.
func NewColorChooserWidget() ColorChooserWidget {

	ret := C.gtk_color_chooser_widget_new()

	var ret0 ColorChooserWidget

	ret0 = WrapColorChooserWidget(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// ColumnView: gtkColumnView is a widget to present a view into a large dynamic
// list of items using multiple columns with headers.
//
// GtkColumnView uses the factories of its columns to generate a cell widget for
// each column, for each visible item and displays them together as the row for
// this item. The ColumnView:show-row-separators and
// ColumnView:show-column-separators properties offer a simple way to display
// separators between the rows or columns.
//
// GtkColumnView allows the user to select items according to the selection
// characteristics of the model. For models that allow multiple selected items,
// it is possible to turn on *rubberband selection*, using
// ColumnView:enable-rubberband.
//
// The column view supports sorting that can be customized by the user by
// clicking on column headers. To set this up, the Sorter returned by
// gtk_column_view_get_sorter() must be attached to a sort model for the data
// that the view is showing, and the columns must have sorters attached to them
// by calling gtk_column_view_column_set_sorter(). The initial sort order can be
// set with gtk_column_view_sort_by_column().
//
// The column view also supports interactive resizing and reordering of columns,
// via Drag-and-Drop of the column headers. This can be enabled or disabled with
// the ColumnView:reorderable and ColumnViewColumn:resizable properties.
//
// To learn more about the list widget framework, see the overview (Widget).
//
// CSS nodes
//
//    columnview[.column-separators][.rich-list][.navigation-sidebar][.data-table]
//    ├── header
//    │   ├── <column header>
//    ┊   ┊
//    │   ╰── <column header>
//    │
//    ├── listview
//    │
//    ┊
//    ╰── [rubberband]
//
//
//
// GtkColumnView uses a single CSS node named columnview. It may carry the
// .column-separators style class, when ColumnView:show-column-separators
// property is set. Header widets appear below a node with name header. The rows
// are contained in a GtkListView widget, so there is a listview node with the
// same structure as for a standalone GtkListView widget. If
// ColumnView:show-row-separators is set, it will be passed on to the list view,
// causing its CSS node to carry the .separators style class. For rubberband
// selection, a node with name rubberband is used.
//
// The main columnview node may also carry style classes to select the style of
// list presentation (ListContainers.html#list-styles): .rich-list,
// .navigation-sidebar or .data-table.
//
//
// Accessibility
//
// GtkColumnView uses the K_ACCESSIBLE_ROLE_TREE_GRID role, header title widgets
// are using the K_ACCESSIBLE_ROLE_COLUMN_HEADER role. The row widgets are using
// the K_ACCESSIBLE_ROLE_ROW role, and individual cells are using the
// K_ACCESSIBLE_ROLE_GRID_CELL role
type ColumnView interface {
	Widget

	// AppendColumn appends the @column to the end of the columns in @self.
	AppendColumn(column ColumnViewColumn)
	// Columns gets the list of columns in this column view. This list is
	// constant over the lifetime of @self and can be used to monitor changes to
	// the columns of @self by connecting to the Model:items-changed signal.
	Columns() gio.ListModel
	// EnableRubberband returns whether rows can be selected by dragging with
	// the mouse.
	EnableRubberband() bool
	// Model gets the model that's currently used to read the items displayed.
	Model() SelectionModel
	// Reorderable returns whether columns are reorderable.
	Reorderable() bool
	// ShowColumnSeparators returns whether the list should show separators
	// between columns.
	ShowColumnSeparators() bool
	// ShowRowSeparators returns whether the list should show separators between
	// rows.
	ShowRowSeparators() bool
	// SingleClickActivate returns whether rows will be activated on single
	// click and selected on hover.
	SingleClickActivate() bool
	// Sorter returns a special sorter that reflects the users sorting choices
	// in the column view.
	//
	// To allow users to customizable sorting by clicking on column headers,
	// this sorter needs to be set on the sort model underneath the model that
	// is displayed by the view.
	//
	// See gtk_column_view_column_set_sorter() for setting up per-column
	// sorting.
	//
	// Here is an example:
	//
	//
	//      gtk_column_view_column_set_sorter (column, sorter);
	//      gtk_column_view_append_column (view, column);
	//      sorter = g_object_ref (gtk_column_view_get_sorter (view)));
	//      model = gtk_sort_list_model_new (store, sorter);
	//      selection = gtk_no_selection_new (model);
	//      gtk_column_view_set_model (view, selection);
	//
	Sorter() Sorter
	// InsertColumn inserts a column at the given position in the columns of
	// @self.
	//
	// If @column is already a column of @self, it will be repositioned.
	InsertColumn(position uint, column ColumnViewColumn)
	// RemoveColumn removes the @column from the list of columns of @self.
	RemoveColumn(column ColumnViewColumn)
	// SetEnableRubberband sets whether selections can be changed by dragging
	// with the mouse.
	SetEnableRubberband(enableRubberband bool)
	// SetModel sets the SelectionModel to use.
	SetModel(model SelectionModel)
	// SetReorderable sets whether columns should be reorderable by dragging.
	SetReorderable(reorderable bool)
	// SetShowColumnSeparators sets whether the list should show separators
	// between columns.
	SetShowColumnSeparators(showColumnSeparators bool)
	// SetShowRowSeparators sets whether the list should show separators between
	// rows.
	SetShowRowSeparators(showRowSeparators bool)
	// SetSingleClickActivate sets whether rows should be activated on single
	// click and selected on hover.
	SetSingleClickActivate(singleClickActivate bool)
	// SortByColumn sets the sorting of the view.
	//
	// This function should be used to set up the initial sorting. At runtime,
	// users can change the sorting of a column view by clicking on the list
	// headers.
	//
	// This call only has an effect if the sorter returned by
	// gtk_column_view_get_sorter() is set on a sort model, and
	// gtk_column_view_column_set_sorter() has been called on @column to
	// associate a sorter with the column.
	//
	// If @column is nil, the view will be unsorted.
	SortByColumn(column ColumnViewColumn, direction SortType)
}

type columnView struct {
	widget
}

// WrapColumnView wraps a GObject to the right type. It is
// primarily used internally.
func WrapColumnView(obj *externglib.Object) ColumnView {
	return columnView{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}
}

func marshalColumnView(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapColumnView(obj), nil
}

// NewColumnView constructs a class ColumnView.
func NewColumnView(model SelectionModel) ColumnView {
	var arg1 *C.GtkSelectionModel

	ret := C.gtk_column_view_new(arg1)

	var ret0 ColumnView

	ret0 = WrapColumnView(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// AppendColumn appends the @column to the end of the columns in @self.
func (self columnView) AppendColumn(column ColumnViewColumn) {
	var arg0 *C.GtkColumnView
	var arg1 *C.GtkColumnViewColumn

	arg0 = (*C.GtkColumnView)(self.Native())
	arg1 = (*C.GtkColumnViewColumn)(column.Native())

	C.gtk_column_view_append_column(arg0, arg1)
}

// Columns gets the list of columns in this column view. This list is
// constant over the lifetime of @self and can be used to monitor changes to
// the columns of @self by connecting to the Model:items-changed signal.
func (self columnView) Columns() gio.ListModel {
	var arg0 *C.GtkColumnView

	arg0 = (*C.GtkColumnView)(self.Native())

	ret := C.gtk_column_view_get_columns(arg0)

	var ret0 gio.ListModel

	return ret0
}

// EnableRubberband returns whether rows can be selected by dragging with
// the mouse.
func (self columnView) EnableRubberband() bool {
	var arg0 *C.GtkColumnView

	arg0 = (*C.GtkColumnView)(self.Native())

	ret := C.gtk_column_view_get_enable_rubberband(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Model gets the model that's currently used to read the items displayed.
func (self columnView) Model() SelectionModel {
	var arg0 *C.GtkColumnView

	arg0 = (*C.GtkColumnView)(self.Native())

	ret := C.gtk_column_view_get_model(arg0)

	var ret0 SelectionModel

	return ret0
}

// Reorderable returns whether columns are reorderable.
func (self columnView) Reorderable() bool {
	var arg0 *C.GtkColumnView

	arg0 = (*C.GtkColumnView)(self.Native())

	ret := C.gtk_column_view_get_reorderable(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// ShowColumnSeparators returns whether the list should show separators
// between columns.
func (self columnView) ShowColumnSeparators() bool {
	var arg0 *C.GtkColumnView

	arg0 = (*C.GtkColumnView)(self.Native())

	ret := C.gtk_column_view_get_show_column_separators(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// ShowRowSeparators returns whether the list should show separators between
// rows.
func (self columnView) ShowRowSeparators() bool {
	var arg0 *C.GtkColumnView

	arg0 = (*C.GtkColumnView)(self.Native())

	ret := C.gtk_column_view_get_show_row_separators(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// SingleClickActivate returns whether rows will be activated on single
// click and selected on hover.
func (self columnView) SingleClickActivate() bool {
	var arg0 *C.GtkColumnView

	arg0 = (*C.GtkColumnView)(self.Native())

	ret := C.gtk_column_view_get_single_click_activate(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Sorter returns a special sorter that reflects the users sorting choices
// in the column view.
//
// To allow users to customizable sorting by clicking on column headers,
// this sorter needs to be set on the sort model underneath the model that
// is displayed by the view.
//
// See gtk_column_view_column_set_sorter() for setting up per-column
// sorting.
//
// Here is an example:
//
//
//      gtk_column_view_column_set_sorter (column, sorter);
//      gtk_column_view_append_column (view, column);
//      sorter = g_object_ref (gtk_column_view_get_sorter (view)));
//      model = gtk_sort_list_model_new (store, sorter);
//      selection = gtk_no_selection_new (model);
//      gtk_column_view_set_model (view, selection);
//
func (self columnView) Sorter() Sorter {
	var arg0 *C.GtkColumnView

	arg0 = (*C.GtkColumnView)(self.Native())

	ret := C.gtk_column_view_get_sorter(arg0)

	var ret0 Sorter

	ret0 = WrapSorter(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// InsertColumn inserts a column at the given position in the columns of
// @self.
//
// If @column is already a column of @self, it will be repositioned.
func (self columnView) InsertColumn(position uint, column ColumnViewColumn) {
	var arg0 *C.GtkColumnView
	var arg1 C.guint
	var arg2 *C.GtkColumnViewColumn

	arg0 = (*C.GtkColumnView)(self.Native())
	arg1 = C.guint(position)
	arg2 = (*C.GtkColumnViewColumn)(column.Native())

	C.gtk_column_view_insert_column(arg0, arg1, arg2)
}

// RemoveColumn removes the @column from the list of columns of @self.
func (self columnView) RemoveColumn(column ColumnViewColumn) {
	var arg0 *C.GtkColumnView
	var arg1 *C.GtkColumnViewColumn

	arg0 = (*C.GtkColumnView)(self.Native())
	arg1 = (*C.GtkColumnViewColumn)(column.Native())

	C.gtk_column_view_remove_column(arg0, arg1)
}

// SetEnableRubberband sets whether selections can be changed by dragging
// with the mouse.
func (self columnView) SetEnableRubberband(enableRubberband bool) {
	var arg0 *C.GtkColumnView
	var arg1 C.gboolean

	arg0 = (*C.GtkColumnView)(self.Native())
	arg1 = gextras.Cbool(enableRubberband)

	C.gtk_column_view_set_enable_rubberband(arg0, arg1)
}

// SetModel sets the SelectionModel to use.
func (self columnView) SetModel(model SelectionModel) {
	var arg0 *C.GtkColumnView
	var arg1 *C.GtkSelectionModel

	arg0 = (*C.GtkColumnView)(self.Native())

	C.gtk_column_view_set_model(arg0, arg1)
}

// SetReorderable sets whether columns should be reorderable by dragging.
func (self columnView) SetReorderable(reorderable bool) {
	var arg0 *C.GtkColumnView
	var arg1 C.gboolean

	arg0 = (*C.GtkColumnView)(self.Native())
	arg1 = gextras.Cbool(reorderable)

	C.gtk_column_view_set_reorderable(arg0, arg1)
}

// SetShowColumnSeparators sets whether the list should show separators
// between columns.
func (self columnView) SetShowColumnSeparators(showColumnSeparators bool) {
	var arg0 *C.GtkColumnView
	var arg1 C.gboolean

	arg0 = (*C.GtkColumnView)(self.Native())
	arg1 = gextras.Cbool(showColumnSeparators)

	C.gtk_column_view_set_show_column_separators(arg0, arg1)
}

// SetShowRowSeparators sets whether the list should show separators between
// rows.
func (self columnView) SetShowRowSeparators(showRowSeparators bool) {
	var arg0 *C.GtkColumnView
	var arg1 C.gboolean

	arg0 = (*C.GtkColumnView)(self.Native())
	arg1 = gextras.Cbool(showRowSeparators)

	C.gtk_column_view_set_show_row_separators(arg0, arg1)
}

// SetSingleClickActivate sets whether rows should be activated on single
// click and selected on hover.
func (self columnView) SetSingleClickActivate(singleClickActivate bool) {
	var arg0 *C.GtkColumnView
	var arg1 C.gboolean

	arg0 = (*C.GtkColumnView)(self.Native())
	arg1 = gextras.Cbool(singleClickActivate)

	C.gtk_column_view_set_single_click_activate(arg0, arg1)
}

// SortByColumn sets the sorting of the view.
//
// This function should be used to set up the initial sorting. At runtime,
// users can change the sorting of a column view by clicking on the list
// headers.
//
// This call only has an effect if the sorter returned by
// gtk_column_view_get_sorter() is set on a sort model, and
// gtk_column_view_column_set_sorter() has been called on @column to
// associate a sorter with the column.
//
// If @column is nil, the view will be unsorted.
func (self columnView) SortByColumn(column ColumnViewColumn, direction SortType) {
	var arg0 *C.GtkColumnView
	var arg1 *C.GtkColumnViewColumn
	var arg2 C.GtkSortType

	arg0 = (*C.GtkColumnView)(self.Native())
	arg1 = (*C.GtkColumnViewColumn)(column.Native())
	arg2 = (C.GtkSortType)(direction)

	C.gtk_column_view_sort_by_column(arg0, arg1, arg2)
}

// ColumnViewColumn: gtkColumnViewColumn represents the columns being added to
// ColumnView.
//
// Columns have a title, and can optionally have a header menu set with
// gtk_column_view_column_set_header_menu().
//
// A sorter can be associated with a column using
// gtk_column_view_column_set_sorter(), to let users influence sorting by
// clicking on the column header.
type ColumnViewColumn interface {
	gextras.Objector

	// ColumnView gets the column view that's currently displaying this column.
	//
	// If @self has not been added to a column view yet, nil is returned.
	ColumnView() ColumnView
	// Expand returns whether this column should expand.
	Expand() bool
	// Factory gets the factory that's currently used to populate list items for
	// this column.
	Factory() ListItemFactory
	// FixedWidth gets the fixed width of the column.
	FixedWidth() int
	// HeaderMenu gets the menu model that is used to create the context menu
	// for the column header.
	HeaderMenu() gio.MenuModel
	// Resizable returns whether this column is resizable.
	Resizable() bool
	// Sorter returns the sorter that is associated with the column.
	Sorter() Sorter
	// Title returns the title set with gtk_column_view_column_set_title().
	Title() string
	// Visible returns whether this column is visible.
	Visible() bool
	// SetExpand sets the column to take available extra space.
	//
	// The extra space is shared equally amongst all columns that have the
	// expand set to true.
	SetExpand(expand bool)
	// SetFactory sets the ListItemFactory to use for populating list items for
	// this column.
	SetFactory(factory ListItemFactory)
	// SetFixedWidth: if @fixed_width is not -1, sets the fixed width of
	// @column; otherwise unsets it.
	//
	// Setting a fixed width overrides the automatically calculated width.
	// Interactive resizing also sets the “fixed-width” property.
	SetFixedWidth(fixedWidth int)
	// SetHeaderMenu sets the menu model that is used to create the context menu
	// for the column header.
	SetHeaderMenu(menu gio.MenuModel)
	// SetResizable sets whether this column should be resizable by dragging.
	SetResizable(resizable bool)
	// SetSorter associates a sorter with the column.
	//
	// If @sorter is nil, the column will not let users change the sorting by
	// clicking on its header.
	//
	// This sorter can be made active by clicking on the column header, or by
	// calling gtk_column_view_sort_by_column().
	//
	// See gtk_column_view_get_sorter() for the necessary steps for setting up
	// customizable sorting for ColumnView.
	SetSorter(sorter Sorter)
	// SetTitle sets the title of this column. The title is displayed in the
	// header of a ColumnView for this column and is therefore user-facing text
	// that should be translated.
	SetTitle(title string)
	// SetVisible sets whether this column should be visible in views.
	SetVisible(visible bool)
}

type columnViewColumn struct {
	*externglib.Object
}

// WrapColumnViewColumn wraps a GObject to the right type. It is
// primarily used internally.
func WrapColumnViewColumn(obj *externglib.Object) ColumnViewColumn {
	return columnViewColumn{*externglib.Object{obj}}
}

func marshalColumnViewColumn(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapColumnViewColumn(obj), nil
}

// NewColumnViewColumn constructs a class ColumnViewColumn.
func NewColumnViewColumn(title string, factory ListItemFactory) ColumnViewColumn {
	var arg1 *C.char
	var arg2 *C.GtkListItemFactory

	arg1 = (*C.gchar)(C.CString(title))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GtkListItemFactory)(factory.Native())

	ret := C.gtk_column_view_column_new(arg1, arg2)

	var ret0 ColumnViewColumn

	ret0 = WrapColumnViewColumn(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// ColumnView gets the column view that's currently displaying this column.
//
// If @self has not been added to a column view yet, nil is returned.
func (self columnViewColumn) ColumnView() ColumnView {
	var arg0 *C.GtkColumnViewColumn

	arg0 = (*C.GtkColumnViewColumn)(self.Native())

	ret := C.gtk_column_view_column_get_column_view(arg0)

	var ret0 ColumnView

	ret0 = WrapColumnView(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Expand returns whether this column should expand.
func (self columnViewColumn) Expand() bool {
	var arg0 *C.GtkColumnViewColumn

	arg0 = (*C.GtkColumnViewColumn)(self.Native())

	ret := C.gtk_column_view_column_get_expand(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Factory gets the factory that's currently used to populate list items for
// this column.
func (self columnViewColumn) Factory() ListItemFactory {
	var arg0 *C.GtkColumnViewColumn

	arg0 = (*C.GtkColumnViewColumn)(self.Native())

	ret := C.gtk_column_view_column_get_factory(arg0)

	var ret0 ListItemFactory

	ret0 = WrapListItemFactory(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// FixedWidth gets the fixed width of the column.
func (self columnViewColumn) FixedWidth() int {
	var arg0 *C.GtkColumnViewColumn

	arg0 = (*C.GtkColumnViewColumn)(self.Native())

	ret := C.gtk_column_view_column_get_fixed_width(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// HeaderMenu gets the menu model that is used to create the context menu
// for the column header.
func (self columnViewColumn) HeaderMenu() gio.MenuModel {
	var arg0 *C.GtkColumnViewColumn

	arg0 = (*C.GtkColumnViewColumn)(self.Native())

	ret := C.gtk_column_view_column_get_header_menu(arg0)

	var ret0 gio.MenuModel

	ret0 = gio.WrapMenuModel(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Resizable returns whether this column is resizable.
func (self columnViewColumn) Resizable() bool {
	var arg0 *C.GtkColumnViewColumn

	arg0 = (*C.GtkColumnViewColumn)(self.Native())

	ret := C.gtk_column_view_column_get_resizable(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Sorter returns the sorter that is associated with the column.
func (self columnViewColumn) Sorter() Sorter {
	var arg0 *C.GtkColumnViewColumn

	arg0 = (*C.GtkColumnViewColumn)(self.Native())

	ret := C.gtk_column_view_column_get_sorter(arg0)

	var ret0 Sorter

	ret0 = WrapSorter(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Title returns the title set with gtk_column_view_column_set_title().
func (self columnViewColumn) Title() string {
	var arg0 *C.GtkColumnViewColumn

	arg0 = (*C.GtkColumnViewColumn)(self.Native())

	ret := C.gtk_column_view_column_get_title(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Visible returns whether this column is visible.
func (self columnViewColumn) Visible() bool {
	var arg0 *C.GtkColumnViewColumn

	arg0 = (*C.GtkColumnViewColumn)(self.Native())

	ret := C.gtk_column_view_column_get_visible(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// SetExpand sets the column to take available extra space.
//
// The extra space is shared equally amongst all columns that have the
// expand set to true.
func (self columnViewColumn) SetExpand(expand bool) {
	var arg0 *C.GtkColumnViewColumn
	var arg1 C.gboolean

	arg0 = (*C.GtkColumnViewColumn)(self.Native())
	arg1 = gextras.Cbool(expand)

	C.gtk_column_view_column_set_expand(arg0, arg1)
}

// SetFactory sets the ListItemFactory to use for populating list items for
// this column.
func (self columnViewColumn) SetFactory(factory ListItemFactory) {
	var arg0 *C.GtkColumnViewColumn
	var arg1 *C.GtkListItemFactory

	arg0 = (*C.GtkColumnViewColumn)(self.Native())
	arg1 = (*C.GtkListItemFactory)(factory.Native())

	C.gtk_column_view_column_set_factory(arg0, arg1)
}

// SetFixedWidth: if @fixed_width is not -1, sets the fixed width of
// @column; otherwise unsets it.
//
// Setting a fixed width overrides the automatically calculated width.
// Interactive resizing also sets the “fixed-width” property.
func (self columnViewColumn) SetFixedWidth(fixedWidth int) {
	var arg0 *C.GtkColumnViewColumn
	var arg1 C.int

	arg0 = (*C.GtkColumnViewColumn)(self.Native())
	arg1 = C.int(fixedWidth)

	C.gtk_column_view_column_set_fixed_width(arg0, arg1)
}

// SetHeaderMenu sets the menu model that is used to create the context menu
// for the column header.
func (self columnViewColumn) SetHeaderMenu(menu gio.MenuModel) {
	var arg0 *C.GtkColumnViewColumn
	var arg1 *C.GMenuModel

	arg0 = (*C.GtkColumnViewColumn)(self.Native())
	arg1 = (*C.GMenuModel)(menu.Native())

	C.gtk_column_view_column_set_header_menu(arg0, arg1)
}

// SetResizable sets whether this column should be resizable by dragging.
func (self columnViewColumn) SetResizable(resizable bool) {
	var arg0 *C.GtkColumnViewColumn
	var arg1 C.gboolean

	arg0 = (*C.GtkColumnViewColumn)(self.Native())
	arg1 = gextras.Cbool(resizable)

	C.gtk_column_view_column_set_resizable(arg0, arg1)
}

// SetSorter associates a sorter with the column.
//
// If @sorter is nil, the column will not let users change the sorting by
// clicking on its header.
//
// This sorter can be made active by clicking on the column header, or by
// calling gtk_column_view_sort_by_column().
//
// See gtk_column_view_get_sorter() for the necessary steps for setting up
// customizable sorting for ColumnView.
func (self columnViewColumn) SetSorter(sorter Sorter) {
	var arg0 *C.GtkColumnViewColumn
	var arg1 *C.GtkSorter

	arg0 = (*C.GtkColumnViewColumn)(self.Native())
	arg1 = (*C.GtkSorter)(sorter.Native())

	C.gtk_column_view_column_set_sorter(arg0, arg1)
}

// SetTitle sets the title of this column. The title is displayed in the
// header of a ColumnView for this column and is therefore user-facing text
// that should be translated.
func (self columnViewColumn) SetTitle(title string) {
	var arg0 *C.GtkColumnViewColumn
	var arg1 *C.char

	arg0 = (*C.GtkColumnViewColumn)(self.Native())
	arg1 = (*C.gchar)(C.CString(title))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_column_view_column_set_title(arg0, arg1)
}

// SetVisible sets whether this column should be visible in views.
func (self columnViewColumn) SetVisible(visible bool) {
	var arg0 *C.GtkColumnViewColumn
	var arg1 C.gboolean

	arg0 = (*C.GtkColumnViewColumn)(self.Native())
	arg1 = gextras.Cbool(visible)

	C.gtk_column_view_column_set_visible(arg0, arg1)
}

// ComboBox: a GtkComboBox is a widget that allows the user to choose from a
// list of valid choices. The GtkComboBox displays the selected choice. When
// activated, the GtkComboBox displays a popup which allows the user to make a
// new choice. The style in which the selected value is displayed, and the style
// of the popup is determined by the current theme. It may be similar to a
// Windows-style combo box.
//
// The GtkComboBox uses the model-view pattern; the list of valid choices is
// specified in the form of a tree model, and the display of the choices can be
// adapted to the data in the model by using cell renderers, as you would in a
// tree view. This is possible since GtkComboBox implements the CellLayout
// interface. The tree model holding the valid choices is not restricted to a
// flat list, it can be a real tree, and the popup will reflect the tree
// structure.
//
// To allow the user to enter values not in the model, the “has-entry” property
// allows the GtkComboBox to contain a Entry. This entry can be accessed by
// calling gtk_combo_box_get_child() on the combo box.
//
// For a simple list of textual choices, the model-view API of GtkComboBox can
// be a bit overwhelming. In this case, ComboBoxText offers a simple
// alternative. Both GtkComboBox and ComboBoxText can contain an entry.
//
// CSS nodes
//
//    combobox
//    ├── box.linked
//    │   ├── entry.combo
//    │   ╰── button.combo
//    │       ╰── box
//    │           ╰── arrow
//    ╰── window.popup
//
//
// A GtkComboBox with an entry has a single CSS node with name combobox. It
// contains a box with the .linked class. That box contains an entry and a
// button, both with the .combo class added. The button also contains another
// node with name arrow.
//
//
// Accessibility
//
// GtkComboBox uses the K_ACCESSIBLE_ROLE_COMBO_BOX role.
type ComboBox interface {
	Widget

	// Active returns the index of the currently active item, or -1 if there’s
	// no active item. If the model is a non-flat treemodel, and the active item
	// is not an immediate child of the root of the tree, this function returns
	// `gtk_tree_path_get_indices (path)[0]`, where `path` is the TreePath of
	// the active item.
	Active() int
	// ActiveID returns the ID of the active row of @combo_box. This value is
	// taken from the active row and the column specified by the
	// ComboBox:id-column property of @combo_box (see
	// gtk_combo_box_set_id_column()).
	//
	// The returned value is an interned string which means that you can compare
	// the pointer by value to other interned strings and that you must not free
	// it.
	//
	// If the ComboBox:id-column property of @combo_box is not set, or if no row
	// is active, or if the active row has a nil ID value, then nil is returned.
	ActiveID() string
	// ActiveIter sets @iter to point to the currently active item, if any item
	// is active. Otherwise, @iter is left unchanged.
	ActiveIter() (iter TreeIter, ok bool)
	// ButtonSensitivity returns whether the combo box sets the dropdown button
	// sensitive or not when there are no items in the model.
	ButtonSensitivity() SensitivityType
	// Child gets the child widget of @combo_box.
	Child() Widget
	// EntryTextColumn returns the column which @combo_box is using to get the
	// strings from to display in the internal entry.
	EntryTextColumn() int
	// HasEntry returns whether the combo box has an entry.
	HasEntry() bool
	// IDColumn returns the column which @combo_box is using to get string IDs
	// for values from.
	IDColumn() int
	// Model returns the TreeModel which is acting as data source for
	// @combo_box.
	Model() TreeModel
	// PopupFixedWidth gets whether the popup uses a fixed width matching the
	// allocated width of the combo box.
	PopupFixedWidth() bool
	// RowSeparatorFunc returns the current row separator function.
	RowSeparatorFunc() TreeViewRowSeparatorFunc
	// Popdown hides the menu or dropdown list of @combo_box.
	//
	// This function is mostly intended for use by accessibility technologies;
	// applications should have little use for it.
	Popdown()
	// Popup pops up the menu or dropdown list of @combo_box.
	//
	// This function is mostly intended for use by accessibility technologies;
	// applications should have little use for it.
	//
	// Before calling this, @combo_box must be mapped, or nothing will happen.
	Popup()
	// PopupForDevice pops up the menu of @combo_box. Note that currently this
	// does not do anything with the device, as it was previously only used for
	// list-mode combo boxes, and those were removed in GTK 4. However, it is
	// retained in case similar functionality is added back later.
	PopupForDevice(device gdk.Device)
	// SetActive sets the active item of @combo_box to be the item at @index.
	SetActive(index_ int)
	// SetActiveID changes the active row of @combo_box to the one that has an
	// ID equal to @active_id, or unsets the active row if @active_id is nil.
	// Rows having a nil ID string cannot be made active by this function.
	//
	// If the ComboBox:id-column property of @combo_box is unset or if no row
	// has the given ID then the function does nothing and returns false.
	SetActiveID(activeID string) bool
	// SetActiveIter sets the current active item to be the one referenced by
	// @iter, or unsets the active item if @iter is nil.
	SetActiveIter(iter *TreeIter)
	// SetButtonSensitivity sets whether the dropdown button of the combo box
	// should be always sensitive (GTK_SENSITIVITY_ON), never sensitive
	// (GTK_SENSITIVITY_OFF) or only if there is at least one item to display
	// (GTK_SENSITIVITY_AUTO).
	SetButtonSensitivity(sensitivity SensitivityType)
	// SetChild sets the child widget of @combo_box.
	SetChild(child Widget)
	// SetEntryTextColumn sets the model column which @combo_box should use to
	// get strings from to be @text_column. The column @text_column in the model
	// of @combo_box must be of type G_TYPE_STRING.
	//
	// This is only relevant if @combo_box has been created with
	// ComboBox:has-entry as true.
	SetEntryTextColumn(textColumn int)
	// SetIDColumn sets the model column which @combo_box should use to get
	// string IDs for values from. The column @id_column in the model of
	// @combo_box must be of type G_TYPE_STRING.
	SetIDColumn(idColumn int)
	// SetModel sets the model used by @combo_box to be @model. Will unset a
	// previously set model (if applicable). If model is nil, then it will unset
	// the model.
	//
	// Note that this function does not clear the cell renderers, you have to
	// call gtk_cell_layout_clear() yourself if you need to set up different
	// cell renderers for the new model.
	SetModel(model TreeModel)
	// SetPopupFixedWidth specifies whether the popup’s width should be a fixed
	// width matching the allocated width of the combo box.
	SetPopupFixedWidth(fixed bool)
	// SetRowSeparatorFunc sets the row separator function, which is used to
	// determine whether a row should be drawn as a separator. If the row
	// separator function is nil, no separators are drawn. This is the default
	// value.
	SetRowSeparatorFunc(_func TreeViewRowSeparatorFunc)
}

type comboBox struct {
	widget
}

// WrapComboBox wraps a GObject to the right type. It is
// primarily used internally.
func WrapComboBox(obj *externglib.Object) ComboBox {
	return comboBox{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}
}

func marshalComboBox(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapComboBox(obj), nil
}

// NewComboBox constructs a class ComboBox.
func NewComboBox() ComboBox {

	ret := C.gtk_combo_box_new()

	var ret0 ComboBox

	ret0 = WrapComboBox(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewComboBoxWithEntry constructs a class ComboBox.
func NewComboBoxWithEntry() ComboBox {

	ret := C.gtk_combo_box_new_with_entry()

	var ret0 ComboBox

	ret0 = WrapComboBox(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewComboBoxWithModel constructs a class ComboBox.
func NewComboBoxWithModel(model TreeModel) ComboBox {
	var arg1 *C.GtkTreeModel

	ret := C.gtk_combo_box_new_with_model(arg1)

	var ret0 ComboBox

	ret0 = WrapComboBox(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewComboBoxWithModelAndEntry constructs a class ComboBox.
func NewComboBoxWithModelAndEntry(model TreeModel) ComboBox {
	var arg1 *C.GtkTreeModel

	ret := C.gtk_combo_box_new_with_model_and_entry(arg1)

	var ret0 ComboBox

	ret0 = WrapComboBox(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Active returns the index of the currently active item, or -1 if there’s
// no active item. If the model is a non-flat treemodel, and the active item
// is not an immediate child of the root of the tree, this function returns
// `gtk_tree_path_get_indices (path)[0]`, where `path` is the TreePath of
// the active item.
func (comboBox comboBox) Active() int {
	var arg0 *C.GtkComboBox

	arg0 = (*C.GtkComboBox)(comboBox.Native())

	ret := C.gtk_combo_box_get_active(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// ActiveID returns the ID of the active row of @combo_box. This value is
// taken from the active row and the column specified by the
// ComboBox:id-column property of @combo_box (see
// gtk_combo_box_set_id_column()).
//
// The returned value is an interned string which means that you can compare
// the pointer by value to other interned strings and that you must not free
// it.
//
// If the ComboBox:id-column property of @combo_box is not set, or if no row
// is active, or if the active row has a nil ID value, then nil is returned.
func (comboBox comboBox) ActiveID() string {
	var arg0 *C.GtkComboBox

	arg0 = (*C.GtkComboBox)(comboBox.Native())

	ret := C.gtk_combo_box_get_active_id(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// ActiveIter sets @iter to point to the currently active item, if any item
// is active. Otherwise, @iter is left unchanged.
func (comboBox comboBox) ActiveIter() (iter TreeIter, ok bool) {
	var arg0 *C.GtkComboBox
	var arg1 *C.GtkTreeIter // out

	arg0 = (*C.GtkComboBox)(comboBox.Native())

	ret := C.gtk_combo_box_get_active_iter(arg0, &arg1)

	var ret0 *TreeIter
	var ret1 bool

	ret0 = WrapTreeIter(arg1)

	ret1 = gextras.Gobool(ret)

	return ret0, ret1
}

// ButtonSensitivity returns whether the combo box sets the dropdown button
// sensitive or not when there are no items in the model.
func (comboBox comboBox) ButtonSensitivity() SensitivityType {
	var arg0 *C.GtkComboBox

	arg0 = (*C.GtkComboBox)(comboBox.Native())

	ret := C.gtk_combo_box_get_button_sensitivity(arg0)

	var ret0 SensitivityType

	ret0 = SensitivityType(ret)

	return ret0
}

// Child gets the child widget of @combo_box.
func (comboBox comboBox) Child() Widget {
	var arg0 *C.GtkComboBox

	arg0 = (*C.GtkComboBox)(comboBox.Native())

	ret := C.gtk_combo_box_get_child(arg0)

	var ret0 Widget

	ret0 = WrapWidget(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// EntryTextColumn returns the column which @combo_box is using to get the
// strings from to display in the internal entry.
func (comboBox comboBox) EntryTextColumn() int {
	var arg0 *C.GtkComboBox

	arg0 = (*C.GtkComboBox)(comboBox.Native())

	ret := C.gtk_combo_box_get_entry_text_column(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// HasEntry returns whether the combo box has an entry.
func (comboBox comboBox) HasEntry() bool {
	var arg0 *C.GtkComboBox

	arg0 = (*C.GtkComboBox)(comboBox.Native())

	ret := C.gtk_combo_box_get_has_entry(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// IDColumn returns the column which @combo_box is using to get string IDs
// for values from.
func (comboBox comboBox) IDColumn() int {
	var arg0 *C.GtkComboBox

	arg0 = (*C.GtkComboBox)(comboBox.Native())

	ret := C.gtk_combo_box_get_id_column(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Model returns the TreeModel which is acting as data source for
// @combo_box.
func (comboBox comboBox) Model() TreeModel {
	var arg0 *C.GtkComboBox

	arg0 = (*C.GtkComboBox)(comboBox.Native())

	ret := C.gtk_combo_box_get_model(arg0)

	var ret0 TreeModel

	return ret0
}

// PopupFixedWidth gets whether the popup uses a fixed width matching the
// allocated width of the combo box.
func (comboBox comboBox) PopupFixedWidth() bool {
	var arg0 *C.GtkComboBox

	arg0 = (*C.GtkComboBox)(comboBox.Native())

	ret := C.gtk_combo_box_get_popup_fixed_width(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// RowSeparatorFunc returns the current row separator function.
func (comboBox comboBox) RowSeparatorFunc() TreeViewRowSeparatorFunc {
	var arg0 *C.GtkComboBox

	arg0 = (*C.GtkComboBox)(comboBox.Native())

	ret := C.gtk_combo_box_get_row_separator_func(arg0)

	var ret0 TreeViewRowSeparatorFunc

	return ret0
}

// Popdown hides the menu or dropdown list of @combo_box.
//
// This function is mostly intended for use by accessibility technologies;
// applications should have little use for it.
func (comboBox comboBox) Popdown() {
	var arg0 *C.GtkComboBox

	arg0 = (*C.GtkComboBox)(comboBox.Native())

	C.gtk_combo_box_popdown(arg0)
}

// Popup pops up the menu or dropdown list of @combo_box.
//
// This function is mostly intended for use by accessibility technologies;
// applications should have little use for it.
//
// Before calling this, @combo_box must be mapped, or nothing will happen.
func (comboBox comboBox) Popup() {
	var arg0 *C.GtkComboBox

	arg0 = (*C.GtkComboBox)(comboBox.Native())

	C.gtk_combo_box_popup(arg0)
}

// PopupForDevice pops up the menu of @combo_box. Note that currently this
// does not do anything with the device, as it was previously only used for
// list-mode combo boxes, and those were removed in GTK 4. However, it is
// retained in case similar functionality is added back later.
func (comboBox comboBox) PopupForDevice(device gdk.Device) {
	var arg0 *C.GtkComboBox
	var arg1 *C.GdkDevice

	arg0 = (*C.GtkComboBox)(comboBox.Native())
	arg1 = (*C.GdkDevice)(device.Native())

	C.gtk_combo_box_popup_for_device(arg0, arg1)
}

// SetActive sets the active item of @combo_box to be the item at @index.
func (comboBox comboBox) SetActive(index_ int) {
	var arg0 *C.GtkComboBox
	var arg1 C.int

	arg0 = (*C.GtkComboBox)(comboBox.Native())
	arg1 = C.int(index_)

	C.gtk_combo_box_set_active(arg0, arg1)
}

// SetActiveID changes the active row of @combo_box to the one that has an
// ID equal to @active_id, or unsets the active row if @active_id is nil.
// Rows having a nil ID string cannot be made active by this function.
//
// If the ComboBox:id-column property of @combo_box is unset or if no row
// has the given ID then the function does nothing and returns false.
func (comboBox comboBox) SetActiveID(activeID string) bool {
	var arg0 *C.GtkComboBox
	var arg1 *C.char

	arg0 = (*C.GtkComboBox)(comboBox.Native())
	arg1 = (*C.gchar)(C.CString(activeID))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_combo_box_set_active_id(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// SetActiveIter sets the current active item to be the one referenced by
// @iter, or unsets the active item if @iter is nil.
func (comboBox comboBox) SetActiveIter(iter *TreeIter) {
	var arg0 *C.GtkComboBox
	var arg1 *C.GtkTreeIter

	arg0 = (*C.GtkComboBox)(comboBox.Native())
	arg1 = (*C.GtkTreeIter)(iter.Native())

	C.gtk_combo_box_set_active_iter(arg0, arg1)
}

// SetButtonSensitivity sets whether the dropdown button of the combo box
// should be always sensitive (GTK_SENSITIVITY_ON), never sensitive
// (GTK_SENSITIVITY_OFF) or only if there is at least one item to display
// (GTK_SENSITIVITY_AUTO).
func (comboBox comboBox) SetButtonSensitivity(sensitivity SensitivityType) {
	var arg0 *C.GtkComboBox
	var arg1 C.GtkSensitivityType

	arg0 = (*C.GtkComboBox)(comboBox.Native())
	arg1 = (C.GtkSensitivityType)(sensitivity)

	C.gtk_combo_box_set_button_sensitivity(arg0, arg1)
}

// SetChild sets the child widget of @combo_box.
func (comboBox comboBox) SetChild(child Widget) {
	var arg0 *C.GtkComboBox
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkComboBox)(comboBox.Native())
	arg1 = (*C.GtkWidget)(child.Native())

	C.gtk_combo_box_set_child(arg0, arg1)
}

// SetEntryTextColumn sets the model column which @combo_box should use to
// get strings from to be @text_column. The column @text_column in the model
// of @combo_box must be of type G_TYPE_STRING.
//
// This is only relevant if @combo_box has been created with
// ComboBox:has-entry as true.
func (comboBox comboBox) SetEntryTextColumn(textColumn int) {
	var arg0 *C.GtkComboBox
	var arg1 C.int

	arg0 = (*C.GtkComboBox)(comboBox.Native())
	arg1 = C.int(textColumn)

	C.gtk_combo_box_set_entry_text_column(arg0, arg1)
}

// SetIDColumn sets the model column which @combo_box should use to get
// string IDs for values from. The column @id_column in the model of
// @combo_box must be of type G_TYPE_STRING.
func (comboBox comboBox) SetIDColumn(idColumn int) {
	var arg0 *C.GtkComboBox
	var arg1 C.int

	arg0 = (*C.GtkComboBox)(comboBox.Native())
	arg1 = C.int(idColumn)

	C.gtk_combo_box_set_id_column(arg0, arg1)
}

// SetModel sets the model used by @combo_box to be @model. Will unset a
// previously set model (if applicable). If model is nil, then it will unset
// the model.
//
// Note that this function does not clear the cell renderers, you have to
// call gtk_cell_layout_clear() yourself if you need to set up different
// cell renderers for the new model.
func (comboBox comboBox) SetModel(model TreeModel) {
	var arg0 *C.GtkComboBox
	var arg1 *C.GtkTreeModel

	arg0 = (*C.GtkComboBox)(comboBox.Native())

	C.gtk_combo_box_set_model(arg0, arg1)
}

// SetPopupFixedWidth specifies whether the popup’s width should be a fixed
// width matching the allocated width of the combo box.
func (comboBox comboBox) SetPopupFixedWidth(fixed bool) {
	var arg0 *C.GtkComboBox
	var arg1 C.gboolean

	arg0 = (*C.GtkComboBox)(comboBox.Native())
	arg1 = gextras.Cbool(fixed)

	C.gtk_combo_box_set_popup_fixed_width(arg0, arg1)
}

// SetRowSeparatorFunc sets the row separator function, which is used to
// determine whether a row should be drawn as a separator. If the row
// separator function is nil, no separators are drawn. This is the default
// value.
func (comboBox comboBox) SetRowSeparatorFunc(_func TreeViewRowSeparatorFunc) {
	var arg0 *C.GtkComboBox
	var arg1 C.GtkTreeViewRowSeparatorFunc
	arg2 := C.gpointer(box.Assign(data))

	arg0 = (*C.GtkComboBox)(comboBox.Native())
	arg1 = (*[0]byte)(C.gotk4_TreeViewRowSeparatorFunc)

	C.gtk_combo_box_set_row_separator_func(arg0, arg1, (*[0]byte)(C.callbackDelete))
}

// ComboBoxText: a GtkComboBoxText is a simple variant of ComboBox that hides
// the model-view complexity for simple text-only use cases.
//
// To create a GtkComboBoxText, use gtk_combo_box_text_new() or
// gtk_combo_box_text_new_with_entry().
//
// You can add items to a GtkComboBoxText with gtk_combo_box_text_append_text(),
// gtk_combo_box_text_insert_text() or gtk_combo_box_text_prepend_text() and
// remove options with gtk_combo_box_text_remove().
//
// If the GtkComboBoxText contains an entry (via the “has-entry” property), its
// contents can be retrieved using gtk_combo_box_text_get_active_text(). The
// entry itself can be accessed by calling gtk_bin_get_child() on the combo box.
//
// You should not call gtk_combo_box_set_model() or attempt to pack more cells
// into this combo box via its GtkCellLayout interface.
//
//
// GtkComboBoxText as GtkBuildable
//
// The GtkComboBoxText implementation of the GtkBuildable interface supports
// adding items directly using the <items> element and specifying <item>
// elements for each item. Each <item> element can specify the “id”
// corresponding to the appended text and also supports the regular translation
// attributes “translatable”, “context” and “comments”.
//
// Here is a UI definition fragment specifying GtkComboBoxText items:
//
//
//    <object class="GtkComboBoxText">
//      <items>
//        <item translatable="yes" id="factory">Factory</item>
//        <item translatable="yes" id="home">Home</item>
//        <item translatable="yes" id="subway">Subway</item>
//      </items>
//    </object>
//    ]|
//
//
//
// CSS nodes
//
//
//    |[<!-- language="plain" -->
//    combobox
//    ╰── box.linked
//        ├── entry.combo
//        ├── button.combo
//        ╰── window.popup
//
//
// GtkComboBoxText has a single CSS node with name combobox. It adds the style
// class .combo to the main CSS nodes of its entry and button children, and the
// .linked class to the node of its internal box.
type ComboBoxText interface {
	ComboBox

	// Append appends @text to the list of strings stored in @combo_box. If @id
	// is non-nil then it is used as the ID of the row.
	//
	// This is the same as calling gtk_combo_box_text_insert() with a position
	// of -1.
	Append(id string, text string)
	// AppendText appends @text to the list of strings stored in @combo_box.
	//
	// This is the same as calling gtk_combo_box_text_insert_text() with a
	// position of -1.
	AppendText(text string)
	// ActiveText returns the currently active string in @combo_box, or nil if
	// none is selected. If @combo_box contains an entry, this function will
	// return its contents (which will not necessarily be an item from the
	// list).
	ActiveText() string
	// Insert inserts @text at @position in the list of strings stored in
	// @combo_box. If @id is non-nil then it is used as the ID of the row. See
	// ComboBox:id-column.
	//
	// If @position is negative then @text is appended.
	Insert(position int, id string, text string)
	// InsertText inserts @text at @position in the list of strings stored in
	// @combo_box.
	//
	// If @position is negative then @text is appended.
	//
	// This is the same as calling gtk_combo_box_text_insert() with a nil ID
	// string.
	InsertText(position int, text string)
	// Prepend prepends @text to the list of strings stored in @combo_box. If
	// @id is non-nil then it is used as the ID of the row.
	//
	// This is the same as calling gtk_combo_box_text_insert() with a position
	// of 0.
	Prepend(id string, text string)
	// PrependText prepends @text to the list of strings stored in @combo_box.
	//
	// This is the same as calling gtk_combo_box_text_insert_text() with a
	// position of 0.
	PrependText(text string)
	// Remove removes the string at @position from @combo_box.
	Remove(position int)
	// RemoveAll removes all the text entries from the combo box.
	RemoveAll()
}

type comboBoxText struct {
	comboBox
}

// WrapComboBoxText wraps a GObject to the right type. It is
// primarily used internally.
func WrapComboBoxText(obj *externglib.Object) ComboBoxText {
	return comboBoxText{comboBox{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}}
}

func marshalComboBoxText(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapComboBoxText(obj), nil
}

// NewComboBoxText constructs a class ComboBoxText.
func NewComboBoxText() ComboBoxText {

	ret := C.gtk_combo_box_text_new()

	var ret0 ComboBoxText

	ret0 = WrapComboBoxText(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewComboBoxTextWithEntry constructs a class ComboBoxText.
func NewComboBoxTextWithEntry() ComboBoxText {

	ret := C.gtk_combo_box_text_new_with_entry()

	var ret0 ComboBoxText

	ret0 = WrapComboBoxText(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Append appends @text to the list of strings stored in @combo_box. If @id
// is non-nil then it is used as the ID of the row.
//
// This is the same as calling gtk_combo_box_text_insert() with a position
// of -1.
func (comboBox comboBoxText) Append(id string, text string) {
	var arg0 *C.GtkComboBoxText
	var arg1 *C.char
	var arg2 *C.char

	arg0 = (*C.GtkComboBoxText)(comboBox.Native())
	arg1 = (*C.gchar)(C.CString(id))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(arg2))

	C.gtk_combo_box_text_append(arg0, arg1, arg2)
}

// AppendText appends @text to the list of strings stored in @combo_box.
//
// This is the same as calling gtk_combo_box_text_insert_text() with a
// position of -1.
func (comboBox comboBoxText) AppendText(text string) {
	var arg0 *C.GtkComboBoxText
	var arg1 *C.char

	arg0 = (*C.GtkComboBoxText)(comboBox.Native())
	arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_combo_box_text_append_text(arg0, arg1)
}

// ActiveText returns the currently active string in @combo_box, or nil if
// none is selected. If @combo_box contains an entry, this function will
// return its contents (which will not necessarily be an item from the
// list).
func (comboBox comboBoxText) ActiveText() string {
	var arg0 *C.GtkComboBoxText

	arg0 = (*C.GtkComboBoxText)(comboBox.Native())

	ret := C.gtk_combo_box_text_get_active_text(arg0)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// Insert inserts @text at @position in the list of strings stored in
// @combo_box. If @id is non-nil then it is used as the ID of the row. See
// ComboBox:id-column.
//
// If @position is negative then @text is appended.
func (comboBox comboBoxText) Insert(position int, id string, text string) {
	var arg0 *C.GtkComboBoxText
	var arg1 C.int
	var arg2 *C.char
	var arg3 *C.char

	arg0 = (*C.GtkComboBoxText)(comboBox.Native())
	arg1 = C.int(position)
	arg2 = (*C.gchar)(C.CString(id))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(arg3))

	C.gtk_combo_box_text_insert(arg0, arg1, arg2, arg3)
}

// InsertText inserts @text at @position in the list of strings stored in
// @combo_box.
//
// If @position is negative then @text is appended.
//
// This is the same as calling gtk_combo_box_text_insert() with a nil ID
// string.
func (comboBox comboBoxText) InsertText(position int, text string) {
	var arg0 *C.GtkComboBoxText
	var arg1 C.int
	var arg2 *C.char

	arg0 = (*C.GtkComboBoxText)(comboBox.Native())
	arg1 = C.int(position)
	arg2 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(arg2))

	C.gtk_combo_box_text_insert_text(arg0, arg1, arg2)
}

// Prepend prepends @text to the list of strings stored in @combo_box. If
// @id is non-nil then it is used as the ID of the row.
//
// This is the same as calling gtk_combo_box_text_insert() with a position
// of 0.
func (comboBox comboBoxText) Prepend(id string, text string) {
	var arg0 *C.GtkComboBoxText
	var arg1 *C.char
	var arg2 *C.char

	arg0 = (*C.GtkComboBoxText)(comboBox.Native())
	arg1 = (*C.gchar)(C.CString(id))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(arg2))

	C.gtk_combo_box_text_prepend(arg0, arg1, arg2)
}

// PrependText prepends @text to the list of strings stored in @combo_box.
//
// This is the same as calling gtk_combo_box_text_insert_text() with a
// position of 0.
func (comboBox comboBoxText) PrependText(text string) {
	var arg0 *C.GtkComboBoxText
	var arg1 *C.char

	arg0 = (*C.GtkComboBoxText)(comboBox.Native())
	arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_combo_box_text_prepend_text(arg0, arg1)
}

// Remove removes the string at @position from @combo_box.
func (comboBox comboBoxText) Remove(position int) {
	var arg0 *C.GtkComboBoxText
	var arg1 C.int

	arg0 = (*C.GtkComboBoxText)(comboBox.Native())
	arg1 = C.int(position)

	C.gtk_combo_box_text_remove(arg0, arg1)
}

// RemoveAll removes all the text entries from the combo box.
func (comboBox comboBoxText) RemoveAll() {
	var arg0 *C.GtkComboBoxText

	arg0 = (*C.GtkComboBoxText)(comboBox.Native())

	C.gtk_combo_box_text_remove_all(arg0)
}

type ConstantExpression interface {
	Expression

	// Value gets the value that a constant expression evaluates to.
	Value() *externglib.Value
}

type constantExpression struct {
	expression
}

// WrapConstantExpression wraps a GObject to the right type. It is
// primarily used internally.
func WrapConstantExpression(obj *externglib.Object) ConstantExpression {
	return constantExpression{expression{obj}}
}

func marshalConstantExpression(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapConstantExpression(obj), nil
}

// NewConstantExpressionForValue constructs a class ConstantExpression.
func NewConstantExpressionForValue(value *externglib.Value) ConstantExpression {
	var arg1 *C.GValue

	arg1 = (*C.GValue)(value.GValue)

	ret := C.gtk_constant_expression_new_for_value(arg1)

	var ret0 ConstantExpression

	ret0 = WrapConstantExpression(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Value gets the value that a constant expression evaluates to.
func (expression constantExpression) Value() *externglib.Value {
	var arg0 *C.GtkExpression

	arg0 = (*C.GtkExpression)(expression.Native())

	ret := C.gtk_constant_expression_get_value(arg0)

	var ret0 *externglib.Value

	return ret0
}

// Constraint describes a constraint between an attribute on a widget and
// another attribute on another widget, expressed as a linear equation like:
//
//
//      target.attr1 = source.attr2 × multiplier + constant
//
//
// Each Constraint is part of a system that will be solved by a ConstraintLayout
// in order to allocate and position each child widget.
//
// The source and target widgets, as well as their attributes, of a Constraint
// instance are immutable after creation.
type Constraint interface {
	gextras.Objector

	// Constant retrieves the constant factor added to the source attributes'
	// value.
	Constant() float64
	// Multiplier retrieves the multiplication factor applied to the source
	// attribute's value.
	Multiplier() float64
	// Relation: the order relation between the terms of the @constraint.
	Relation() ConstraintRelation
	// Source retrieves the ConstraintTarget used as the source for @constraint.
	//
	// If the Constraint:source property is set to nil, the @constraint will use
	// the ConstraintLayout's widget.
	Source() ConstraintTarget
	// SourceAttribute retrieves the attribute of the source to be read by the
	// @constraint.
	SourceAttribute() ConstraintAttribute
	// Strength retrieves the strength of the constraint.
	Strength() int
	// Target retrieves the ConstraintTarget used as the target for @constraint.
	//
	// If the Constraint:target property is set to nil, the @constraint will use
	// the ConstraintLayout's widget.
	Target() ConstraintTarget
	// TargetAttribute retrieves the attribute of the target to be set by the
	// @constraint.
	TargetAttribute() ConstraintAttribute
	// IsAttached checks whether the @constraint is attached to a
	// ConstraintLayout, and it is contributing to the layout.
	IsAttached() bool
	// IsConstant checks whether the @constraint describes a relation between an
	// attribute on the Constraint:target and a constant value.
	IsConstant() bool
	// IsRequired checks whether the @constraint is a required relation for
	// solving the constraint layout.
	IsRequired() bool
}

type constraint struct {
	*externglib.Object
}

// WrapConstraint wraps a GObject to the right type. It is
// primarily used internally.
func WrapConstraint(obj *externglib.Object) Constraint {
	return constraint{*externglib.Object{obj}}
}

func marshalConstraint(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapConstraint(obj), nil
}

// NewConstraint constructs a class Constraint.
func NewConstraint(target ConstraintTarget, targetAttribute ConstraintAttribute, relation ConstraintRelation, source ConstraintTarget, sourceAttribute ConstraintAttribute, multiplier float64, constant float64, strength int) Constraint {
	var arg1 C.gpointer
	var arg2 C.GtkConstraintAttribute
	var arg3 C.GtkConstraintRelation
	var arg4 C.gpointer
	var arg5 C.GtkConstraintAttribute
	var arg6 C.double
	var arg7 C.double
	var arg8 C.int

	arg2 = (C.GtkConstraintAttribute)(targetAttribute)
	arg3 = (C.GtkConstraintRelation)(relation)
	arg5 = (C.GtkConstraintAttribute)(sourceAttribute)
	arg6 = C.double(multiplier)
	arg7 = C.double(constant)
	arg8 = C.int(strength)

	ret := C.gtk_constraint_new(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)

	var ret0 Constraint

	ret0 = WrapConstraint(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewConstraintConstant constructs a class Constraint.
func NewConstraintConstant(target ConstraintTarget, targetAttribute ConstraintAttribute, relation ConstraintRelation, constant float64, strength int) Constraint {
	var arg1 C.gpointer
	var arg2 C.GtkConstraintAttribute
	var arg3 C.GtkConstraintRelation
	var arg4 C.double
	var arg5 C.int

	arg2 = (C.GtkConstraintAttribute)(targetAttribute)
	arg3 = (C.GtkConstraintRelation)(relation)
	arg4 = C.double(constant)
	arg5 = C.int(strength)

	ret := C.gtk_constraint_new_constant(arg1, arg2, arg3, arg4, arg5)

	var ret0 Constraint

	ret0 = WrapConstraint(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Constant retrieves the constant factor added to the source attributes'
// value.
func (constraint constraint) Constant() float64 {
	var arg0 *C.GtkConstraint

	arg0 = (*C.GtkConstraint)(constraint.Native())

	ret := C.gtk_constraint_get_constant(arg0)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// Multiplier retrieves the multiplication factor applied to the source
// attribute's value.
func (constraint constraint) Multiplier() float64 {
	var arg0 *C.GtkConstraint

	arg0 = (*C.GtkConstraint)(constraint.Native())

	ret := C.gtk_constraint_get_multiplier(arg0)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// Relation: the order relation between the terms of the @constraint.
func (constraint constraint) Relation() ConstraintRelation {
	var arg0 *C.GtkConstraint

	arg0 = (*C.GtkConstraint)(constraint.Native())

	ret := C.gtk_constraint_get_relation(arg0)

	var ret0 ConstraintRelation

	ret0 = ConstraintRelation(ret)

	return ret0
}

// Source retrieves the ConstraintTarget used as the source for @constraint.
//
// If the Constraint:source property is set to nil, the @constraint will use
// the ConstraintLayout's widget.
func (constraint constraint) Source() ConstraintTarget {
	var arg0 *C.GtkConstraint

	arg0 = (*C.GtkConstraint)(constraint.Native())

	ret := C.gtk_constraint_get_source(arg0)

	var ret0 ConstraintTarget

	return ret0
}

// SourceAttribute retrieves the attribute of the source to be read by the
// @constraint.
func (constraint constraint) SourceAttribute() ConstraintAttribute {
	var arg0 *C.GtkConstraint

	arg0 = (*C.GtkConstraint)(constraint.Native())

	ret := C.gtk_constraint_get_source_attribute(arg0)

	var ret0 ConstraintAttribute

	ret0 = ConstraintAttribute(ret)

	return ret0
}

// Strength retrieves the strength of the constraint.
func (constraint constraint) Strength() int {
	var arg0 *C.GtkConstraint

	arg0 = (*C.GtkConstraint)(constraint.Native())

	ret := C.gtk_constraint_get_strength(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Target retrieves the ConstraintTarget used as the target for @constraint.
//
// If the Constraint:target property is set to nil, the @constraint will use
// the ConstraintLayout's widget.
func (constraint constraint) Target() ConstraintTarget {
	var arg0 *C.GtkConstraint

	arg0 = (*C.GtkConstraint)(constraint.Native())

	ret := C.gtk_constraint_get_target(arg0)

	var ret0 ConstraintTarget

	return ret0
}

// TargetAttribute retrieves the attribute of the target to be set by the
// @constraint.
func (constraint constraint) TargetAttribute() ConstraintAttribute {
	var arg0 *C.GtkConstraint

	arg0 = (*C.GtkConstraint)(constraint.Native())

	ret := C.gtk_constraint_get_target_attribute(arg0)

	var ret0 ConstraintAttribute

	ret0 = ConstraintAttribute(ret)

	return ret0
}

// IsAttached checks whether the @constraint is attached to a
// ConstraintLayout, and it is contributing to the layout.
func (constraint constraint) IsAttached() bool {
	var arg0 *C.GtkConstraint

	arg0 = (*C.GtkConstraint)(constraint.Native())

	ret := C.gtk_constraint_is_attached(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// IsConstant checks whether the @constraint describes a relation between an
// attribute on the Constraint:target and a constant value.
func (constraint constraint) IsConstant() bool {
	var arg0 *C.GtkConstraint

	arg0 = (*C.GtkConstraint)(constraint.Native())

	ret := C.gtk_constraint_is_constant(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// IsRequired checks whether the @constraint is a required relation for
// solving the constraint layout.
func (constraint constraint) IsRequired() bool {
	var arg0 *C.GtkConstraint

	arg0 = (*C.GtkConstraint)(constraint.Native())

	ret := C.gtk_constraint_is_required(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// ConstraintGuide: a ConstraintGuide is an invisible layout element that can be
// used by widgets inside a ConstraintLayout as a source or a target of a
// Constraint. Guides can be used like guidelines or as flexible space.
//
// Unlike a Widget, a ConstraintGuide will not be drawn.
type ConstraintGuide interface {
	gextras.Objector

	// MaxSize gets the maximum size of @guide.
	MaxSize(width int, height int)
	// MinSize gets the minimum size of @guide.
	MinSize(width int, height int)
	// Name retrieves the name set using gtk_constraint_guide_set_name().
	Name() string
	// NatSize gets the natural size of @guide.
	NatSize(width int, height int)
	// Strength retrieves the strength set using
	// gtk_constraint_guide_set_strength().
	Strength() ConstraintStrength
	// SetMaxSize sets the maximum size of @guide.
	//
	// If @guide is attached to a ConstraintLayout, the constraints will be
	// updated to reflect the new size.
	SetMaxSize(width int, height int)
	// SetMinSize sets the minimum size of @guide.
	//
	// If @guide is attached to a ConstraintLayout, the constraints will be
	// updated to reflect the new size.
	SetMinSize(width int, height int)
	// SetName sets a name for the given ConstraintGuide.
	//
	// The name is useful for debugging purposes.
	SetName(name string)
	// SetNatSize sets the natural size of @guide.
	//
	// If @guide is attached to a ConstraintLayout, the constraints will be
	// updated to reflect the new size.
	SetNatSize(width int, height int)
	// SetStrength sets the strength of the constraint on the natural size of
	// the given ConstraintGuide.
	SetStrength(strength ConstraintStrength)
}

type constraintGuide struct {
	*externglib.Object
}

// WrapConstraintGuide wraps a GObject to the right type. It is
// primarily used internally.
func WrapConstraintGuide(obj *externglib.Object) ConstraintGuide {
	return constraintGuide{*externglib.Object{obj}}
}

func marshalConstraintGuide(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapConstraintGuide(obj), nil
}

// NewConstraintGuide constructs a class ConstraintGuide.
func NewConstraintGuide() ConstraintGuide {

	ret := C.gtk_constraint_guide_new()

	var ret0 ConstraintGuide

	ret0 = WrapConstraintGuide(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// MaxSize gets the maximum size of @guide.
func (guide constraintGuide) MaxSize(width int, height int) {
	var arg0 *C.GtkConstraintGuide
	var arg1 *C.int
	var arg2 *C.int

	arg0 = (*C.GtkConstraintGuide)(guide.Native())
	arg1 = (*C.int)(width)
	arg2 = (*C.int)(height)

	C.gtk_constraint_guide_get_max_size(arg0, arg1, arg2)
}

// MinSize gets the minimum size of @guide.
func (guide constraintGuide) MinSize(width int, height int) {
	var arg0 *C.GtkConstraintGuide
	var arg1 *C.int
	var arg2 *C.int

	arg0 = (*C.GtkConstraintGuide)(guide.Native())
	arg1 = (*C.int)(width)
	arg2 = (*C.int)(height)

	C.gtk_constraint_guide_get_min_size(arg0, arg1, arg2)
}

// Name retrieves the name set using gtk_constraint_guide_set_name().
func (guide constraintGuide) Name() string {
	var arg0 *C.GtkConstraintGuide

	arg0 = (*C.GtkConstraintGuide)(guide.Native())

	ret := C.gtk_constraint_guide_get_name(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// NatSize gets the natural size of @guide.
func (guide constraintGuide) NatSize(width int, height int) {
	var arg0 *C.GtkConstraintGuide
	var arg1 *C.int
	var arg2 *C.int

	arg0 = (*C.GtkConstraintGuide)(guide.Native())
	arg1 = (*C.int)(width)
	arg2 = (*C.int)(height)

	C.gtk_constraint_guide_get_nat_size(arg0, arg1, arg2)
}

// Strength retrieves the strength set using
// gtk_constraint_guide_set_strength().
func (guide constraintGuide) Strength() ConstraintStrength {
	var arg0 *C.GtkConstraintGuide

	arg0 = (*C.GtkConstraintGuide)(guide.Native())

	ret := C.gtk_constraint_guide_get_strength(arg0)

	var ret0 ConstraintStrength

	ret0 = ConstraintStrength(ret)

	return ret0
}

// SetMaxSize sets the maximum size of @guide.
//
// If @guide is attached to a ConstraintLayout, the constraints will be
// updated to reflect the new size.
func (guide constraintGuide) SetMaxSize(width int, height int) {
	var arg0 *C.GtkConstraintGuide
	var arg1 C.int
	var arg2 C.int

	arg0 = (*C.GtkConstraintGuide)(guide.Native())
	arg1 = C.int(width)
	arg2 = C.int(height)

	C.gtk_constraint_guide_set_max_size(arg0, arg1, arg2)
}

// SetMinSize sets the minimum size of @guide.
//
// If @guide is attached to a ConstraintLayout, the constraints will be
// updated to reflect the new size.
func (guide constraintGuide) SetMinSize(width int, height int) {
	var arg0 *C.GtkConstraintGuide
	var arg1 C.int
	var arg2 C.int

	arg0 = (*C.GtkConstraintGuide)(guide.Native())
	arg1 = C.int(width)
	arg2 = C.int(height)

	C.gtk_constraint_guide_set_min_size(arg0, arg1, arg2)
}

// SetName sets a name for the given ConstraintGuide.
//
// The name is useful for debugging purposes.
func (guide constraintGuide) SetName(name string) {
	var arg0 *C.GtkConstraintGuide
	var arg1 *C.char

	arg0 = (*C.GtkConstraintGuide)(guide.Native())
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_constraint_guide_set_name(arg0, arg1)
}

// SetNatSize sets the natural size of @guide.
//
// If @guide is attached to a ConstraintLayout, the constraints will be
// updated to reflect the new size.
func (guide constraintGuide) SetNatSize(width int, height int) {
	var arg0 *C.GtkConstraintGuide
	var arg1 C.int
	var arg2 C.int

	arg0 = (*C.GtkConstraintGuide)(guide.Native())
	arg1 = C.int(width)
	arg2 = C.int(height)

	C.gtk_constraint_guide_set_nat_size(arg0, arg1, arg2)
}

// SetStrength sets the strength of the constraint on the natural size of
// the given ConstraintGuide.
func (guide constraintGuide) SetStrength(strength ConstraintStrength) {
	var arg0 *C.GtkConstraintGuide
	var arg1 C.GtkConstraintStrength

	arg0 = (*C.GtkConstraintGuide)(guide.Native())
	arg1 = (C.GtkConstraintStrength)(strength)

	C.gtk_constraint_guide_set_strength(arg0, arg1)
}

// ConstraintLayout: gtkConstraintLayout is a layout manager that uses relations
// between widget attributes, expressed via Constraint instances, to measure and
// allocate widgets.
//
//
// How do constraints work
//
// Constraints are objects defining the relationship between attributes of a
// widget; you can read the description of the Constraint class to have a more
// in depth definition.
//
// By taking multiple constraints and applying them to the children of a widget
// using ConstraintLayout, it's possible to describe complex layout policies;
// each constraint applied to a child or to the parent widgets contributes to
// the full description of the layout, in terms of parameters for resolving the
// value of each attribute.
//
// It is important to note that a layout is defined by the totality of
// constraints; removing a child, or a constraint, from an existing layout
// without changing the remaining constraints may result in an unstable or
// unsolvable layout.
//
// Constraints have an implicit "reading order"; you should start describing
// each edge of each child, as well as their relationship with the parent
// container, from the top left (or top right, in RTL languages), horizontally
// first, and then vertically.
//
// A constraint-based layout with too few constraints can become "unstable",
// that is: have more than one solution. The behavior of an unstable layout is
// undefined.
//
// A constraint-based layout with conflicting constraints may be unsolvable, and
// lead to an unstable layout. You can use the Constraint:strength property of
// Constraint to "nudge" the layout towards a solution.
//
//
// GtkConstraintLayout as GtkBuildable
//
// GtkConstraintLayout implements the Buildable interface and has a custom
// "constraints" element which allows describing constraints in a GtkBuilder UI
// file.
//
// An example of a UI definition fragment specifying a constraint:
//
//
//      <object class="GtkConstraintLayout">
//        <constraints>
//          <constraint target="button" target-attribute="start"
//                      relation="eq"
//                      source="super" source-attribute="start"
//                      constant="12"
//                      strength="required" />
//          <constraint target="button" target-attribute="width"
//                      relation="ge"
//                      constant="250"
//                      strength="strong" />
//        </constraints>
//      </object>
//    ]|
//
//    The definition above will add two constraints to the GtkConstraintLayout:
//
//     - a required constraint between the leading edge of "button" and
//       the leading edge of the widget using the constraint layout, plus
//       12 pixels
//     - a strong, constant constraint making the width of "button" greater
//       than, or equal to 250 pixels
//
//    The "target" and "target-attribute" attributes are required.
//
//    The "source" and "source-attribute" attributes of the "constraint"
//    element are optional; if they are not specified, the constraint is
//    assumed to be a constant.
//
//    The "relation" attribute is optional; if not specified, the constraint
//    is assumed to be an equality.
//
//    The "strength" attribute is optional; if not specified, the constraint
//    is assumed to be required.
//
//    The "source" and "target" attributes can be set to "super" to indicate
//    that the constraint target is the widget using the GtkConstraintLayout.
//
//    There can be "constant" and "multiplier" attributes.
//
//    Additionally, the "constraints" element can also contain a description
//    of the ConstraintGuides used by the layout:
//
//    |[
//      <constraints>
//        <guide min-width="100" max-width="500" name="hspace"/>
//        <guide min-height="64" nat-height="128" name="vspace" strength="strong"/>
//      </constraints>
//    ]|
//
//    The "guide" element has the following optional attributes:
//
//      - "min-width", "nat-width", and "max-width", describe the minimum,
//        natural, and maximum width of the guide, respectively
//      - "min-height", "nat-height", and "max-height", describe the minimum,
//        natural, and maximum height of the guide, respectively
//      - "strength" describes the strength of the constraint on the natural
//        size of the guide; if not specified, the constraint is assumed to
//        have a medium strength
//      - "name" describes a name for the guide, useful when debugging
//
//
//
// Using the Visual Format Language
//
//
//    Complex constraints can be described using a compact syntax called VFL,
//    or *Visual Format Language*.
//
//    The Visual Format Language describes all the constraints on a row or
//    column, typically starting from the leading edge towards the trailing
//    one. Each element of the layout is composed by "views", which identify
//    a ConstraintTarget.
//
//    For instance:
//
//    |[
//      [button]-[textField]
//    ]|
//
//    Describes a constraint that binds the trailing edge of "button" to the
//    leading edge of "textField", leaving a default space between the two.
//
//    Using VFL is also possible to specify predicates that describe constraints
//    on attributes like width and height:
//
//    |[
//      // Width must be greater than, or equal to 50
//      [button(>=50)]
//
//      // Width of button1 must be equal to width of button2
//      [button1(==button2)]
//    ]|
//
//    The default orientation for a VFL description is horizontal, unless
//    otherwise specified:
//
//    |[
//      // horizontal orientation, default attribute: width
//      H:[button(>=150)]
//
//      // vertical orientation, default attribute: height
//      V:[button1(==button2)]
//    ]|
//
//    It's also possible to specify multiple predicates, as well as their
//    strength:
//
//    |[
//      // minimum width of button must be 150
//      // natural width of button can be 250
//      [button(>=150@required, ==250@medium)]
//    ]|
//
//    Finally, it's also possible to use simple arithmetic operators:
//
//    |[
//      // width of button1 must be equal to width of button2
//      // divided by 2 plus 12
//      [button1(button2 / 2 + 12)]
//
type ConstraintLayout interface {
	LayoutManager

	// AddConstraint adds a Constraint to the layout manager.
	//
	// The Constraint:source and Constraint:target properties of @constraint can
	// be:
	//
	//    - set to nil to indicate that the constraint refers to the
	//      widget using @layout
	//    - set to the Widget using @layout
	//    - set to a child of the Widget using @layout
	//    - set to a guide that is part of @layout
	//
	// The @layout acquires the ownership of @constraint after calling this
	// function.
	AddConstraint(constraint Constraint)
	// AddConstraintsFromDescriptionv creates a list of constraints from a
	// formal description using a compact description syntax called VFL, or
	// "Visual Format Language".
	//
	// The Visual Format Language is based on Apple's AutoLayout VFL
	// (https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/VisualFormatLanguage.html).
	//
	// The @views dictionary is used to match ConstraintTargets to the symbolic
	// view name inside the VFL.
	//
	// The VFL grammar is:
	//
	//      // Default spacing
	//      [button]-[textField]
	//
	//      // Width constraint
	//      [button(>=50)]
	//
	//      // Connection to super view
	//      |-50-[purpleBox]-50-|
	//
	//      // Vertical layout
	//      V:[topField]-10-[bottomField]
	//
	//      // Flush views
	//      [maroonView][blueView]
	//
	//      // Priority
	//      [button(100@strong)]
	//
	//      // Equal widths
	//      [button1(==button2)]
	//
	//      // Multiple predicates
	//      [flexibleButton(>=70,<=100)]
	//
	//      // A complete line of layout
	//      |-[find]-[findNext]-[findField(>=20)]-|
	//
	//      // Operators
	//      [button1(button2 / 3 + 50)]
	//
	//      // Named attributes
	//      [button1(==button2.height)]
	//
	AddConstraintsFromDescriptionv(lines []string, hspacing int, vspacing int, views *glib.HashTable) *glib.List
	// AddGuide adds a guide to @layout. A guide can be used as the source or
	// target of constraints, like a widget, but it is not visible.
	//
	// The @layout acquires the ownership of @guide after calling this function.
	AddGuide(guide ConstraintGuide)
	// ObserveConstraints returns a Model to track the constraints that are part
	// of @layout.
	//
	// Calling this function will enable extra internal bookkeeping to track
	// constraints and emit signals on the returned listmodel. It may slow down
	// operations a lot.
	//
	// Applications should try hard to avoid calling this function because of
	// the slowdowns.
	ObserveConstraints() gio.ListModel
	// ObserveGuides returns a Model to track the guides that are part of
	// @layout.
	//
	// Calling this function will enable extra internal bookkeeping to track
	// guides and emit signals on the returned listmodel. It may slow down
	// operations a lot.
	//
	// Applications should try hard to avoid calling this function because of
	// the slowdowns.
	ObserveGuides() gio.ListModel
	// RemoveAllConstraints removes all constraints from the layout manager.
	RemoveAllConstraints()
	// RemoveConstraint removes @constraint from the layout manager, so that it
	// no longer influences the layout.
	RemoveConstraint(constraint Constraint)
	// RemoveGuide removes @guide from the layout manager, so that it no longer
	// influences the layout.
	RemoveGuide(guide ConstraintGuide)
}

type constraintLayout struct {
	layoutManager
}

// WrapConstraintLayout wraps a GObject to the right type. It is
// primarily used internally.
func WrapConstraintLayout(obj *externglib.Object) ConstraintLayout {
	return constraintLayout{layoutManager{*externglib.Object{obj}}}
}

func marshalConstraintLayout(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapConstraintLayout(obj), nil
}

// NewConstraintLayout constructs a class ConstraintLayout.
func NewConstraintLayout() ConstraintLayout {

	ret := C.gtk_constraint_layout_new()

	var ret0 ConstraintLayout

	ret0 = WrapConstraintLayout(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// AddConstraint adds a Constraint to the layout manager.
//
// The Constraint:source and Constraint:target properties of @constraint can
// be:
//
//    - set to nil to indicate that the constraint refers to the
//      widget using @layout
//    - set to the Widget using @layout
//    - set to a child of the Widget using @layout
//    - set to a guide that is part of @layout
//
// The @layout acquires the ownership of @constraint after calling this
// function.
func (layout constraintLayout) AddConstraint(constraint Constraint) {
	var arg0 *C.GtkConstraintLayout
	var arg1 *C.GtkConstraint

	arg0 = (*C.GtkConstraintLayout)(layout.Native())
	arg1 = (*C.GtkConstraint)(constraint.Native())

	C.gtk_constraint_layout_add_constraint(arg0, arg1)
}

// AddConstraintsFromDescriptionv creates a list of constraints from a
// formal description using a compact description syntax called VFL, or
// "Visual Format Language".
//
// The Visual Format Language is based on Apple's AutoLayout VFL
// (https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/VisualFormatLanguage.html).
//
// The @views dictionary is used to match ConstraintTargets to the symbolic
// view name inside the VFL.
//
// The VFL grammar is:
//
//      // Default spacing
//      [button]-[textField]
//
//      // Width constraint
//      [button(>=50)]
//
//      // Connection to super view
//      |-50-[purpleBox]-50-|
//
//      // Vertical layout
//      V:[topField]-10-[bottomField]
//
//      // Flush views
//      [maroonView][blueView]
//
//      // Priority
//      [button(100@strong)]
//
//      // Equal widths
//      [button1(==button2)]
//
//      // Multiple predicates
//      [flexibleButton(>=70,<=100)]
//
//      // A complete line of layout
//      |-[find]-[findNext]-[findField(>=20)]-|
//
//      // Operators
//      [button1(button2 / 3 + 50)]
//
//      // Named attributes
//      [button1(==button2.height)]
//
func (layout constraintLayout) AddConstraintsFromDescriptionv(lines []string, hspacing int, vspacing int, views *glib.HashTable) *glib.List {
	var arg0 *C.GtkConstraintLayout
	var arg1 **C.char
	var arg2 C.gsize
	var arg3 C.int
	var arg4 C.int
	var arg5 *C.GHashTable

	arg0 = (*C.GtkConstraintLayout)(layout.Native())
	{
		var dst []*C.gchar
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(C.malloc(unsafe.Sizeof((*struct{})(nil)) * len(lines))))
		sliceHeader.Len = len(lines)
		sliceHeader.Cap = len(lines)
		defer C.free(unsafe.Pointer(sliceHeader.Data))

		for i := 0; i < len(lines); i++ {
			src := lines[i]
			dst[i] = (*C.gchar)(C.CString(src))
			defer C.free(unsafe.Pointer(dst[i]))
		}

		arg1 = (**C.char)(unsafe.Pointer(sliceHeader.Data))
		arg2 = len(lines)
	}
	arg3 = C.int(hspacing)
	arg4 = C.int(vspacing)
	arg5 = (*C.GHashTable)(views.Native())

	ret := C.gtk_constraint_layout_add_constraints_from_descriptionv(arg0, arg1, arg2, arg3, arg4, arg5)

	var ret0 *glib.List

	ret0 = glib.WrapList(ret)

	return ret0
}

// AddGuide adds a guide to @layout. A guide can be used as the source or
// target of constraints, like a widget, but it is not visible.
//
// The @layout acquires the ownership of @guide after calling this function.
func (layout constraintLayout) AddGuide(guide ConstraintGuide) {
	var arg0 *C.GtkConstraintLayout
	var arg1 *C.GtkConstraintGuide

	arg0 = (*C.GtkConstraintLayout)(layout.Native())
	arg1 = (*C.GtkConstraintGuide)(guide.Native())

	C.gtk_constraint_layout_add_guide(arg0, arg1)
}

// ObserveConstraints returns a Model to track the constraints that are part
// of @layout.
//
// Calling this function will enable extra internal bookkeeping to track
// constraints and emit signals on the returned listmodel. It may slow down
// operations a lot.
//
// Applications should try hard to avoid calling this function because of
// the slowdowns.
func (layout constraintLayout) ObserveConstraints() gio.ListModel {
	var arg0 *C.GtkConstraintLayout

	arg0 = (*C.GtkConstraintLayout)(layout.Native())

	ret := C.gtk_constraint_layout_observe_constraints(arg0)

	var ret0 gio.ListModel

	return ret0
}

// ObserveGuides returns a Model to track the guides that are part of
// @layout.
//
// Calling this function will enable extra internal bookkeeping to track
// guides and emit signals on the returned listmodel. It may slow down
// operations a lot.
//
// Applications should try hard to avoid calling this function because of
// the slowdowns.
func (layout constraintLayout) ObserveGuides() gio.ListModel {
	var arg0 *C.GtkConstraintLayout

	arg0 = (*C.GtkConstraintLayout)(layout.Native())

	ret := C.gtk_constraint_layout_observe_guides(arg0)

	var ret0 gio.ListModel

	return ret0
}

// RemoveAllConstraints removes all constraints from the layout manager.
func (layout constraintLayout) RemoveAllConstraints() {
	var arg0 *C.GtkConstraintLayout

	arg0 = (*C.GtkConstraintLayout)(layout.Native())

	C.gtk_constraint_layout_remove_all_constraints(arg0)
}

// RemoveConstraint removes @constraint from the layout manager, so that it
// no longer influences the layout.
func (layout constraintLayout) RemoveConstraint(constraint Constraint) {
	var arg0 *C.GtkConstraintLayout
	var arg1 *C.GtkConstraint

	arg0 = (*C.GtkConstraintLayout)(layout.Native())
	arg1 = (*C.GtkConstraint)(constraint.Native())

	C.gtk_constraint_layout_remove_constraint(arg0, arg1)
}

// RemoveGuide removes @guide from the layout manager, so that it no longer
// influences the layout.
func (layout constraintLayout) RemoveGuide(guide ConstraintGuide) {
	var arg0 *C.GtkConstraintLayout
	var arg1 *C.GtkConstraintGuide

	arg0 = (*C.GtkConstraintLayout)(layout.Native())
	arg1 = (*C.GtkConstraintGuide)(guide.Native())

	C.gtk_constraint_layout_remove_guide(arg0, arg1)
}

// ConstraintLayoutChild: a LayoutChild in a ConstraintLayout.
type ConstraintLayoutChild interface {
	LayoutChild
}

type constraintLayoutChild struct {
	layoutChild
}

// WrapConstraintLayoutChild wraps a GObject to the right type. It is
// primarily used internally.
func WrapConstraintLayoutChild(obj *externglib.Object) ConstraintLayoutChild {
	return constraintLayoutChild{layoutChild{*externglib.Object{obj}}}
}

func marshalConstraintLayoutChild(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapConstraintLayoutChild(obj), nil
}

// CSSProvider: gtkCssProvider is an object implementing the StyleProvider
// interface. It is able to parse [CSS-like][css-overview] input in order to
// style widgets.
//
// An application can make GTK parse a specific CSS style sheet by calling
// gtk_css_provider_load_from_file() or gtk_css_provider_load_from_resource()
// and adding the provider with gtk_style_context_add_provider() or
// gtk_style_context_add_provider_for_display().
//
// In addition, certain files will be read when GTK is initialized. First, the
// file `$XDG_CONFIG_HOME/gtk-4.0/gtk.css` is loaded if it exists. Then, GTK
// loads the first existing file among
// `XDG_DATA_HOME/themes/THEME/gtk-VERSION/gtk-VARIANT.css`,
// `$HOME/.themes/THEME/gtk-VERSION/gtk-VARIANT.css`,
// `$XDG_DATA_DIRS/themes/THEME/gtk-VERSION/gtk-VARIANT.css` and
// `DATADIR/share/themes/THEME/gtk-VERSION/gtk-VARIANT.css`, where `THEME` is
// the name of the current theme (see the Settings:gtk-theme-name setting),
// VARIANT is the variant to load (see the
// Settings:gtk-application-prefer-dark-theme setting), `DATADIR` is the prefix
// configured when GTK was compiled (unless overridden by the `GTK_DATA_PREFIX`
// environment variable), and `VERSION` is the GTK version number. If no file is
// found for the current version, GTK tries older versions all the way back to
// 4.0.
type CSSProvider interface {
	gextras.Objector

	// LoadFromData loads @data into @css_provider, and by doing so clears any
	// previously loaded information.
	LoadFromData(data []byte)
	// LoadFromFile loads the data contained in @file into @css_provider, making
	// it clear any previously loaded information.
	LoadFromFile(file gio.File)
	// LoadFromPath loads the data contained in @path into @css_provider, making
	// it clear any previously loaded information.
	LoadFromPath(path string)
	// LoadFromResource loads the data contained in the resource at
	// @resource_path into the CssProvider, clearing any previously loaded
	// information.
	//
	// To track errors while loading CSS, connect to the
	// CssProvider::parsing-error signal.
	LoadFromResource(resourcePath string)
	// LoadNamed loads a theme from the usual theme paths. The actual process of
	// finding the theme might change between releases, but it is guaranteed
	// that this function uses the same mechanism to load the theme that GTK
	// uses for loading its own theme.
	LoadNamed(name string, variant string)
	// String converts the @provider into a string representation in CSS format.
	//
	// Using gtk_css_provider_load_from_data() with the return value from this
	// function on a new provider created with gtk_css_provider_new() will
	// basically create a duplicate of this @provider.
	String() string
}

type cssProvider struct {
	*externglib.Object
}

// WrapCSSProvider wraps a GObject to the right type. It is
// primarily used internally.
func WrapCSSProvider(obj *externglib.Object) CSSProvider {
	return cssProvider{*externglib.Object{obj}}
}

func marshalCSSProvider(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCSSProvider(obj), nil
}

// NewCSSProvider constructs a class CSSProvider.
func NewCSSProvider() CSSProvider {

	ret := C.gtk_css_provider_new()

	var ret0 CSSProvider

	ret0 = WrapCSSProvider(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// LoadFromData loads @data into @css_provider, and by doing so clears any
// previously loaded information.
func (cssProvider cssProvider) LoadFromData(data []byte) {
	var arg0 *C.GtkCssProvider
	var arg1 *C.char
	var arg2 C.gssize

	arg0 = (*C.GtkCssProvider)(cssProvider.Native())
	{
		arg1 = (*C.char)(&data[0])
		arg2 = len(data)
		defer runtime.KeepAlive(data)
	}

	C.gtk_css_provider_load_from_data(arg0, arg1, arg2)
}

// LoadFromFile loads the data contained in @file into @css_provider, making
// it clear any previously loaded information.
func (cssProvider cssProvider) LoadFromFile(file gio.File) {
	var arg0 *C.GtkCssProvider
	var arg1 *C.GFile

	arg0 = (*C.GtkCssProvider)(cssProvider.Native())

	C.gtk_css_provider_load_from_file(arg0, arg1)
}

// LoadFromPath loads the data contained in @path into @css_provider, making
// it clear any previously loaded information.
func (cssProvider cssProvider) LoadFromPath(path string) {
	var arg0 *C.GtkCssProvider
	var arg1 *C.char

	arg0 = (*C.GtkCssProvider)(cssProvider.Native())
	arg1 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_css_provider_load_from_path(arg0, arg1)
}

// LoadFromResource loads the data contained in the resource at
// @resource_path into the CssProvider, clearing any previously loaded
// information.
//
// To track errors while loading CSS, connect to the
// CssProvider::parsing-error signal.
func (cssProvider cssProvider) LoadFromResource(resourcePath string) {
	var arg0 *C.GtkCssProvider
	var arg1 *C.char

	arg0 = (*C.GtkCssProvider)(cssProvider.Native())
	arg1 = (*C.gchar)(C.CString(resourcePath))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_css_provider_load_from_resource(arg0, arg1)
}

// LoadNamed loads a theme from the usual theme paths. The actual process of
// finding the theme might change between releases, but it is guaranteed
// that this function uses the same mechanism to load the theme that GTK
// uses for loading its own theme.
func (provider cssProvider) LoadNamed(name string, variant string) {
	var arg0 *C.GtkCssProvider
	var arg1 *C.char
	var arg2 *C.char

	arg0 = (*C.GtkCssProvider)(provider.Native())
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(variant))
	defer C.free(unsafe.Pointer(arg2))

	C.gtk_css_provider_load_named(arg0, arg1, arg2)
}

// String converts the @provider into a string representation in CSS format.
//
// Using gtk_css_provider_load_from_data() with the return value from this
// function on a new provider created with gtk_css_provider_new() will
// basically create a duplicate of this @provider.
func (provider cssProvider) String() string {
	var arg0 *C.GtkCssProvider

	arg0 = (*C.GtkCssProvider)(provider.Native())

	ret := C.gtk_css_provider_to_string(arg0)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// CustomFilter is a Filter that uses a callback to determine whether to include
// an item or not.
type CustomFilter interface {
	Filter

	// SetFilterFunc sets (or unsets) the function used for filtering items.
	//
	// If @match_func is nil, the filter matches all items.
	//
	// If the filter func changes its filtering behavior, gtk_filter_changed()
	// needs to be called.
	//
	// If a previous function was set, its @user_destroy will be called now.
	SetFilterFunc(matchFunc CustomFilterFunc)
}

type customFilter struct {
	filter
}

// WrapCustomFilter wraps a GObject to the right type. It is
// primarily used internally.
func WrapCustomFilter(obj *externglib.Object) CustomFilter {
	return customFilter{filter{*externglib.Object{obj}}}
}

func marshalCustomFilter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCustomFilter(obj), nil
}

// NewCustomFilter constructs a class CustomFilter.
func NewCustomFilter(matchFunc CustomFilterFunc) CustomFilter {
	var arg1 C.GtkCustomFilterFunc
	arg2 := C.gpointer(box.Assign(userData))

	arg1 = (*[0]byte)(C.gotk4_CustomFilterFunc)

	ret := C.gtk_custom_filter_new(arg1, (*[0]byte)(C.callbackDelete))

	var ret0 CustomFilter

	ret0 = WrapCustomFilter(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// SetFilterFunc sets (or unsets) the function used for filtering items.
//
// If @match_func is nil, the filter matches all items.
//
// If the filter func changes its filtering behavior, gtk_filter_changed()
// needs to be called.
//
// If a previous function was set, its @user_destroy will be called now.
func (self customFilter) SetFilterFunc(matchFunc CustomFilterFunc) {
	var arg0 *C.GtkCustomFilter
	var arg1 C.GtkCustomFilterFunc
	arg2 := C.gpointer(box.Assign(userData))

	arg0 = (*C.GtkCustomFilter)(self.Native())
	arg1 = (*[0]byte)(C.gotk4_CustomFilterFunc)

	C.gtk_custom_filter_set_filter_func(arg0, arg1, (*[0]byte)(C.callbackDelete))
}

// CustomLayout is a convenience type meant to be used as a transition mechanism
// between Widgets implementing a layout policy, and LayoutManager classes.
//
// A CustomLayout uses closures matching to the old Widget virtual functions for
// size negotiation, as a convenience API to ease the porting towards the
// corresponding LayoutManager virtual functions.
type CustomLayout interface {
	LayoutManager
}

type customLayout struct {
	layoutManager
}

// WrapCustomLayout wraps a GObject to the right type. It is
// primarily used internally.
func WrapCustomLayout(obj *externglib.Object) CustomLayout {
	return customLayout{layoutManager{*externglib.Object{obj}}}
}

func marshalCustomLayout(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCustomLayout(obj), nil
}

// NewCustomLayout constructs a class CustomLayout.
func NewCustomLayout(requestMode CustomRequestModeFunc, measure CustomMeasureFunc, allocate CustomAllocateFunc) CustomLayout {
	var arg1 C.GtkCustomRequestModeFunc
	var arg2 C.GtkCustomMeasureFunc
	var arg3 C.GtkCustomAllocateFunc

	arg1 = (*[0]byte)(C.gotk4_CustomRequestModeFunc)
	arg2 = (*[0]byte)(C.gotk4_CustomMeasureFunc)
	arg3 = (*[0]byte)(C.gotk4_CustomAllocateFunc)

	ret := C.gtk_custom_layout_new(arg1, arg2, arg3)

	var ret0 CustomLayout

	ret0 = WrapCustomLayout(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// CustomSorter: gtkCustomSorter is a Sorter implementation that sorts via a
// traditional DataFunc callback.
type CustomSorter interface {
	Sorter

	// SetSortFunc sets (or unsets) the function used for sorting items.
	//
	// If @sort_func is nil, all items are considered equal.
	//
	// If the sort func changes its sorting behavior, gtk_sorter_changed() needs
	// to be called.
	//
	// If a previous function was set, its @user_destroy will be called now.
	SetSortFunc(sortFunc glib.CompareDataFunc)
}

type customSorter struct {
	sorter
}

// WrapCustomSorter wraps a GObject to the right type. It is
// primarily used internally.
func WrapCustomSorter(obj *externglib.Object) CustomSorter {
	return customSorter{sorter{*externglib.Object{obj}}}
}

func marshalCustomSorter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCustomSorter(obj), nil
}

// NewCustomSorter constructs a class CustomSorter.
func NewCustomSorter(sortFunc glib.CompareDataFunc) CustomSorter {
	var arg1 C.GCompareDataFunc
	arg2 := C.gpointer(box.Assign(userData))

	arg1 = (*[0]byte)(C.gotk4_CompareDataFunc)

	ret := C.gtk_custom_sorter_new(arg1, (*[0]byte)(C.callbackDelete))

	var ret0 CustomSorter

	ret0 = WrapCustomSorter(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// SetSortFunc sets (or unsets) the function used for sorting items.
//
// If @sort_func is nil, all items are considered equal.
//
// If the sort func changes its sorting behavior, gtk_sorter_changed() needs
// to be called.
//
// If a previous function was set, its @user_destroy will be called now.
func (self customSorter) SetSortFunc(sortFunc glib.CompareDataFunc) {
	var arg0 *C.GtkCustomSorter
	var arg1 C.GCompareDataFunc
	arg2 := C.gpointer(box.Assign(userData))

	arg0 = (*C.GtkCustomSorter)(self.Native())
	arg1 = (*[0]byte)(C.gotk4_CompareDataFunc)

	C.gtk_custom_sorter_set_sort_func(arg0, arg1, (*[0]byte)(C.callbackDelete))
}

// Dialog dialogs are a convenient way to prompt the user for a small amount of
// input, e.g. to display a message, ask a question, or anything else that does
// not require extensive effort on the user’s part.
//
// The main area of a GtkDialog is called the "content area", and is yours to
// populate with widgets such a Label or Entry, to present your information,
// questions, or tasks to the user. In addition, dialogs allow you to add
// "action widgets". Most commonly, action widgets are buttons. Depending on the
// platform, action widgets may be presented in the header bar at the top of the
// window, or at the bottom of the window. To add action widgets, use GtkDialog
// using gtk_dialog_new_with_buttons(), gtk_dialog_add_button(),
// gtk_dialog_add_buttons(), or gtk_dialog_add_action_widget().
//
// Clicking a button that was added as an action widget will emit the
// Dialog::response signal with a response ID that you specified. GTK will never
// assign a meaning to positive response IDs; these are entirely user-defined.
// But for convenience, you can use the response IDs in the ResponseType
// enumeration (these all have values less than zero). If a dialog receives a
// delete event, the Dialog::response signal will be emitted with the
// K_RESPONSE_DELETE_EVENT response ID.
//
// Dialogs are created with a call to gtk_dialog_new() or
// gtk_dialog_new_with_buttons(). gtk_dialog_new_with_buttons() is recommended;
// it allows you to set the dialog title, some convenient flags, and add simple
// buttons.
//
// A “modal” dialog (that is, one which freezes the rest of the application from
// user input), can be created by calling gtk_window_set_modal() on the dialog.
// Use the GTK_WINDOW() macro to cast the widget returned from gtk_dialog_new()
// into a Window. When using gtk_dialog_new_with_buttons() you can also pass the
// K_DIALOG_MODAL flag to make a dialog modal.
//
// For the simple dialog in the following example, a MessageDialog would save
// some effort. But you’d need to create the dialog contents manually if you had
// more than a simple message in the dialog.
//
// An example for simple GtkDialog usage:
//
//    // Function to open a dialog box with a message
//    void
//    quick_message (GtkWindow *parent, char *message)
//    {
//     GtkWidget *dialog, *label, *content_area;
//     GtkDialogFlags flags;
//
//     // Create the widgets
//     flags = GTK_DIALOG_DESTROY_WITH_PARENT;
//     dialog = gtk_dialog_new_with_buttons ("Message",
//                                           parent,
//                                           flags,
//                                           _("_OK"),
//                                           GTK_RESPONSE_NONE,
//                                           NULL);
//     content_area = gtk_dialog_get_content_area (GTK_DIALOG (dialog));
//     label = gtk_label_new (message);
//
//     // Ensure that the dialog box is destroyed when the user responds
//
//     g_signal_connect_swapped (dialog,
//                               "response",
//                               G_CALLBACK (gtk_window_destroy),
//                               dialog);
//
//     // Add the label, and show everything we’ve added
//
//     gtk_box_append (GTK_BOX (content_area), label);
//     gtk_widget_show (dialog);
//    }
//    ]|
//
//
//
// GtkDialog as GtkBuildable
//
//
//    The GtkDialog implementation of the Buildable interface exposes the
//    @content_area as an internal child with the name “content_area”.
//
//    GtkDialog supports a custom <action-widgets> element, which can contain
//    multiple <action-widget> elements. The “response” attribute specifies a
//    numeric response, and the content of the element is the id of widget
//    (which should be a child of the dialogs @action_area). To mark a response
//    as default, set the “default“ attribute of the <action-widget> element
//    to true.
//
//    GtkDialog supports adding action widgets by specifying “action“ as
//    the “type“ attribute of a <child> element. The widget will be added
//    either to the action area or the headerbar of the dialog, depending
//    on the “use-header-bar“ property. The response id has to be associated
//    with the action widget using the <action-widgets> element.
//
//    An example of a Dialog UI definition fragment:
//    |[
//    <object class="GtkDialog" id="dialog1">
//      <child type="action">
//        <object class="GtkButton" id="button_cancel"/>
//      </child>
//      <child type="action">
//        <object class="GtkButton" id="button_ok">
//        </object>
//      </child>
//      <action-widgets>
//        <action-widget response="cancel">button_cancel</action-widget>
//        <action-widget response="ok" default="true">button_ok</action-widget>
//      </action-widgets>
//    </object>
//
//
//
// Accessibility
//
// GtkDialog uses the K_ACCESSIBLE_ROLE_DIALOG role.
type Dialog interface {
	Window

	// AddActionWidget adds an activatable widget to the action area of a
	// Dialog, connecting a signal handler that will emit the Dialog::response
	// signal on the dialog when the widget is activated. The widget is appended
	// to the end of the dialog’s action area. If you want to add a
	// non-activatable widget, simply pack it into the @action_area field of the
	// Dialog struct.
	AddActionWidget(child Widget, responseID int)
	// AddButton adds a button with the given text and sets things up so that
	// clicking the button will emit the Dialog::response signal with the given
	// @response_id. The button is appended to the end of the dialog’s action
	// area. The button widget is returned, but usually you don’t need it.
	AddButton(buttonText string, responseID int) Widget
	// ContentArea returns the content area of @dialog.
	ContentArea() Box
	// HeaderBar returns the header bar of @dialog. Note that the headerbar is
	// only used by the dialog if the Dialog:use-header-bar property is true.
	HeaderBar() HeaderBar
	// ResponseForWidget gets the response id of a widget in the action area of
	// a dialog.
	ResponseForWidget(widget Widget) int
	// WidgetForResponse gets the widget button that uses the given response ID
	// in the action area of a dialog.
	WidgetForResponse(responseID int) Widget
	// Response emits the Dialog::response signal with the given response ID.
	//
	// Used to indicate that the user has responded to the dialog in some way.
	Response(responseID int)
	// SetDefaultResponse sets the last widget in the dialog’s action area with
	// the given @response_id as the default widget for the dialog. Pressing
	// “Enter” normally activates the default widget.
	SetDefaultResponse(responseID int)
	// SetResponseSensitive calls `gtk_widget_set_sensitive (widget, @setting)`
	// for each widget in the dialog’s action area with the given @response_id.
	// A convenient way to sensitize/desensitize dialog buttons.
	SetResponseSensitive(responseID int, setting bool)
}

type dialog struct {
	window
}

// WrapDialog wraps a GObject to the right type. It is
// primarily used internally.
func WrapDialog(obj *externglib.Object) Dialog {
	return dialog{window{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}}
}

func marshalDialog(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDialog(obj), nil
}

// NewDialog constructs a class Dialog.
func NewDialog() Dialog {

	ret := C.gtk_dialog_new()

	var ret0 Dialog

	ret0 = WrapDialog(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// AddActionWidget adds an activatable widget to the action area of a
// Dialog, connecting a signal handler that will emit the Dialog::response
// signal on the dialog when the widget is activated. The widget is appended
// to the end of the dialog’s action area. If you want to add a
// non-activatable widget, simply pack it into the @action_area field of the
// Dialog struct.
func (dialog dialog) AddActionWidget(child Widget, responseID int) {
	var arg0 *C.GtkDialog
	var arg1 *C.GtkWidget
	var arg2 C.int

	arg0 = (*C.GtkDialog)(dialog.Native())
	arg1 = (*C.GtkWidget)(child.Native())
	arg2 = C.int(responseID)

	C.gtk_dialog_add_action_widget(arg0, arg1, arg2)
}

// AddButton adds a button with the given text and sets things up so that
// clicking the button will emit the Dialog::response signal with the given
// @response_id. The button is appended to the end of the dialog’s action
// area. The button widget is returned, but usually you don’t need it.
func (dialog dialog) AddButton(buttonText string, responseID int) Widget {
	var arg0 *C.GtkDialog
	var arg1 *C.char
	var arg2 C.int

	arg0 = (*C.GtkDialog)(dialog.Native())
	arg1 = (*C.gchar)(C.CString(buttonText))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.int(responseID)

	ret := C.gtk_dialog_add_button(arg0, arg1, arg2)

	var ret0 Widget

	ret0 = WrapWidget(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// ContentArea returns the content area of @dialog.
func (dialog dialog) ContentArea() Box {
	var arg0 *C.GtkDialog

	arg0 = (*C.GtkDialog)(dialog.Native())

	ret := C.gtk_dialog_get_content_area(arg0)

	var ret0 Box

	ret0 = WrapBox(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// HeaderBar returns the header bar of @dialog. Note that the headerbar is
// only used by the dialog if the Dialog:use-header-bar property is true.
func (dialog dialog) HeaderBar() HeaderBar {
	var arg0 *C.GtkDialog

	arg0 = (*C.GtkDialog)(dialog.Native())

	ret := C.gtk_dialog_get_header_bar(arg0)

	var ret0 HeaderBar

	ret0 = WrapHeaderBar(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// ResponseForWidget gets the response id of a widget in the action area of
// a dialog.
func (dialog dialog) ResponseForWidget(widget Widget) int {
	var arg0 *C.GtkDialog
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkDialog)(dialog.Native())
	arg1 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_dialog_get_response_for_widget(arg0, arg1)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// WidgetForResponse gets the widget button that uses the given response ID
// in the action area of a dialog.
func (dialog dialog) WidgetForResponse(responseID int) Widget {
	var arg0 *C.GtkDialog
	var arg1 C.int

	arg0 = (*C.GtkDialog)(dialog.Native())
	arg1 = C.int(responseID)

	ret := C.gtk_dialog_get_widget_for_response(arg0, arg1)

	var ret0 Widget

	ret0 = WrapWidget(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Response emits the Dialog::response signal with the given response ID.
//
// Used to indicate that the user has responded to the dialog in some way.
func (dialog dialog) Response(responseID int) {
	var arg0 *C.GtkDialog
	var arg1 C.int

	arg0 = (*C.GtkDialog)(dialog.Native())
	arg1 = C.int(responseID)

	C.gtk_dialog_response(arg0, arg1)
}

// SetDefaultResponse sets the last widget in the dialog’s action area with
// the given @response_id as the default widget for the dialog. Pressing
// “Enter” normally activates the default widget.
func (dialog dialog) SetDefaultResponse(responseID int) {
	var arg0 *C.GtkDialog
	var arg1 C.int

	arg0 = (*C.GtkDialog)(dialog.Native())
	arg1 = C.int(responseID)

	C.gtk_dialog_set_default_response(arg0, arg1)
}

// SetResponseSensitive calls `gtk_widget_set_sensitive (widget, @setting)`
// for each widget in the dialog’s action area with the given @response_id.
// A convenient way to sensitize/desensitize dialog buttons.
func (dialog dialog) SetResponseSensitive(responseID int, setting bool) {
	var arg0 *C.GtkDialog
	var arg1 C.int
	var arg2 C.gboolean

	arg0 = (*C.GtkDialog)(dialog.Native())
	arg1 = C.int(responseID)
	arg2 = gextras.Cbool(setting)

	C.gtk_dialog_set_response_sensitive(arg0, arg1, arg2)
}

// DirectoryList is a list model that wraps g_file_enumerate_children_async().
// It presents a Model and fills it asynchronously with the Infos returned from
// that function.
//
// Enumeration will start automatically when a the DirectoryList:file property
// is set.
//
// While the DirectoryList is being filled, the DirectoryList:loading property
// will be set to true. You can listen to that property if you want to show
// information like a Spinner or a "Loading..." text.
//
// If loading fails at any point, the DirectoryList:error property will be set
// to give more indication about the failure.
//
// The Infos returned from a DirectoryList have the "standard::file" attribute
// set to the #GFile they refer to. This way you can get at the file that is
// referred to in the same way you would via g_file_enumerator_get_child(). This
// means you do not need access to the DirectoryList but can access the #GFile
// directly from the Info when operating with a ListView or similar.
type DirectoryList interface {
	gextras.Objector

	// Attributes gets the attributes queried on the children.
	Attributes() string
	// Error gets the loading error, if any.
	//
	// If an error occurs during the loading process, the loading process will
	// finish and this property allows querying the error that happened. This
	// error will persist until a file is loaded again.
	//
	// An error being set does not mean that no files were loaded, and all
	// successfully queried files will remain in the list.
	Error() *glib.Error
	// File gets the file whose children are currently enumerated.
	File() gio.File
	// IOPriority gets the IO priority set via
	// gtk_directory_list_set_io_priority().
	IOPriority() int
	// Monitored returns whether the directory list is monitoring the directory
	// for changes.
	Monitored() bool
	// IsLoading returns true if the children enumeration is currently in
	// progress.
	//
	// Files will be added to @self from time to time while loading is going on.
	// The order in which are added is undefined and may change in between runs.
	IsLoading() bool
	// SetAttributes sets the @attributes to be enumerated and starts the
	// enumeration.
	//
	// If @attributes is nil, no attributes will be queried, but a list of Infos
	// will still be created.
	SetAttributes(attributes string)
	// SetFile sets the @file to be enumerated and starts the enumeration.
	//
	// If @file is nil, the result will be an empty list.
	SetFile(file gio.File)
	// SetIOPriority sets the IO priority to use while loading directories.
	//
	// Setting the priority while @self is loading will reprioritize the ongoing
	// load as soon as possible.
	//
	// The default IO priority is G_PRIORITY_DEFAULT, which is higher than the
	// GTK redraw priority. If you are loading a lot of directories in parallel,
	// lowering it to something like G_PRIORITY_DEFAULT_IDLE may increase
	// responsiveness.
	SetIOPriority(ioPriority int)
	// SetMonitored sets whether the directory list will monitor the directory
	// for changes. If monitoring is enabled, the Model::items-changed signal
	// will be emitted when the directory contents change.
	//
	// When monitoring is turned on after the initial creation of the directory
	// list, the directory is reloaded to avoid missing files that appeared
	// between the initial loading and when monitoring was turned on.
	SetMonitored(monitored bool)
}

type directoryList struct {
	*externglib.Object
}

// WrapDirectoryList wraps a GObject to the right type. It is
// primarily used internally.
func WrapDirectoryList(obj *externglib.Object) DirectoryList {
	return directoryList{*externglib.Object{obj}}
}

func marshalDirectoryList(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDirectoryList(obj), nil
}

// NewDirectoryList constructs a class DirectoryList.
func NewDirectoryList(attributes string, file gio.File) DirectoryList {
	var arg1 *C.char
	var arg2 *C.GFile

	arg1 = (*C.gchar)(C.CString(attributes))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_directory_list_new(arg1, arg2)

	var ret0 DirectoryList

	ret0 = WrapDirectoryList(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Attributes gets the attributes queried on the children.
func (self directoryList) Attributes() string {
	var arg0 *C.GtkDirectoryList

	arg0 = (*C.GtkDirectoryList)(self.Native())

	ret := C.gtk_directory_list_get_attributes(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Error gets the loading error, if any.
//
// If an error occurs during the loading process, the loading process will
// finish and this property allows querying the error that happened. This
// error will persist until a file is loaded again.
//
// An error being set does not mean that no files were loaded, and all
// successfully queried files will remain in the list.
func (self directoryList) Error() *glib.Error {
	var arg0 *C.GtkDirectoryList

	arg0 = (*C.GtkDirectoryList)(self.Native())

	ret := C.gtk_directory_list_get_error(arg0)

	var ret0 *glib.Error

	ret0 = glib.WrapError(ret)

	return ret0
}

// File gets the file whose children are currently enumerated.
func (self directoryList) File() gio.File {
	var arg0 *C.GtkDirectoryList

	arg0 = (*C.GtkDirectoryList)(self.Native())

	ret := C.gtk_directory_list_get_file(arg0)

	var ret0 gio.File

	return ret0
}

// IOPriority gets the IO priority set via
// gtk_directory_list_set_io_priority().
func (self directoryList) IOPriority() int {
	var arg0 *C.GtkDirectoryList

	arg0 = (*C.GtkDirectoryList)(self.Native())

	ret := C.gtk_directory_list_get_io_priority(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Monitored returns whether the directory list is monitoring the directory
// for changes.
func (self directoryList) Monitored() bool {
	var arg0 *C.GtkDirectoryList

	arg0 = (*C.GtkDirectoryList)(self.Native())

	ret := C.gtk_directory_list_get_monitored(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// IsLoading returns true if the children enumeration is currently in
// progress.
//
// Files will be added to @self from time to time while loading is going on.
// The order in which are added is undefined and may change in between runs.
func (self directoryList) IsLoading() bool {
	var arg0 *C.GtkDirectoryList

	arg0 = (*C.GtkDirectoryList)(self.Native())

	ret := C.gtk_directory_list_is_loading(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// SetAttributes sets the @attributes to be enumerated and starts the
// enumeration.
//
// If @attributes is nil, no attributes will be queried, but a list of Infos
// will still be created.
func (self directoryList) SetAttributes(attributes string) {
	var arg0 *C.GtkDirectoryList
	var arg1 *C.char

	arg0 = (*C.GtkDirectoryList)(self.Native())
	arg1 = (*C.gchar)(C.CString(attributes))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_directory_list_set_attributes(arg0, arg1)
}

// SetFile sets the @file to be enumerated and starts the enumeration.
//
// If @file is nil, the result will be an empty list.
func (self directoryList) SetFile(file gio.File) {
	var arg0 *C.GtkDirectoryList
	var arg1 *C.GFile

	arg0 = (*C.GtkDirectoryList)(self.Native())

	C.gtk_directory_list_set_file(arg0, arg1)
}

// SetIOPriority sets the IO priority to use while loading directories.
//
// Setting the priority while @self is loading will reprioritize the ongoing
// load as soon as possible.
//
// The default IO priority is G_PRIORITY_DEFAULT, which is higher than the
// GTK redraw priority. If you are loading a lot of directories in parallel,
// lowering it to something like G_PRIORITY_DEFAULT_IDLE may increase
// responsiveness.
func (self directoryList) SetIOPriority(ioPriority int) {
	var arg0 *C.GtkDirectoryList
	var arg1 C.int

	arg0 = (*C.GtkDirectoryList)(self.Native())
	arg1 = C.int(ioPriority)

	C.gtk_directory_list_set_io_priority(arg0, arg1)
}

// SetMonitored sets whether the directory list will monitor the directory
// for changes. If monitoring is enabled, the Model::items-changed signal
// will be emitted when the directory contents change.
//
// When monitoring is turned on after the initial creation of the directory
// list, the directory is reloaded to avoid missing files that appeared
// between the initial loading and when monitoring was turned on.
func (self directoryList) SetMonitored(monitored bool) {
	var arg0 *C.GtkDirectoryList
	var arg1 C.gboolean

	arg0 = (*C.GtkDirectoryList)(self.Native())
	arg1 = gextras.Cbool(monitored)

	C.gtk_directory_list_set_monitored(arg0, arg1)
}

// DragIcon: gtkDragIcon is a Root implementation with the sole purpose to serve
// as a drag icon during DND operations. A drag icon moves with the pointer
// during a drag operation and is destroyed when the drag ends.
//
// To set up a drag icon and associate it with an ongoing drag operation, use
// gtk_drag_icon_get_for_drag() to get the icon for a drag. You can then use it
// like any other widget and use gtk_drag_icon_set_child() to set whatever
// widget should be used for the drag icon.
//
// Keep in mind that drag icons do not allow user input.
type DragIcon interface {
	Widget

	// Child gets the widget currently used as drag icon.
	Child() Widget
	// SetChild sets the widget to display as the drag icon.
	SetChild(child Widget)
}

type dragIcon struct {
	widget
}

// WrapDragIcon wraps a GObject to the right type. It is
// primarily used internally.
func WrapDragIcon(obj *externglib.Object) DragIcon {
	return dragIcon{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}
}

func marshalDragIcon(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDragIcon(obj), nil
}

// Child gets the widget currently used as drag icon.
func (self dragIcon) Child() Widget {
	var arg0 *C.GtkDragIcon

	arg0 = (*C.GtkDragIcon)(self.Native())

	ret := C.gtk_drag_icon_get_child(arg0)

	var ret0 Widget

	ret0 = WrapWidget(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// SetChild sets the widget to display as the drag icon.
func (self dragIcon) SetChild(child Widget) {
	var arg0 *C.GtkDragIcon
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkDragIcon)(self.Native())
	arg1 = (*C.GtkWidget)(child.Native())

	C.gtk_drag_icon_set_child(arg0, arg1)
}

// DragSource: gtkDragSource is an auxiliary object that is used to initiate
// Drag-And-Drop operations. It can be set up with the necessary ingredients for
// a DND operation ahead of time. This includes the source for the data that is
// being transferred, in the form of a ContentProvider, the desired action, and
// the icon to use during the drag operation. After setting it up, the drag
// source must be added to a widget as an event controller, using
// gtk_widget_add_controller().
//
//    static void
//    on_drag_begin (GtkDragSource *source,
//                   GtkDrag       *drag,
//                   MyWidget      *self)
//    {
//      // Set the widget as the drag icon
//      GdkPaintable *paintable = gtk_widget_paintable_new (GTK_WIDGET (self));
//      gtk_drag_source_set_icon (source, paintable, 0, 0);
//      g_object_unref (paintable);
//    }
//
//
// During the DND operation, GtkDragSource emits signals that can be used to
// obtain updates about the status of the operation, but it is not normally
// necessary to connect to any signals, except for one case: when the supported
// actions include GDK_ACTION_MOVE, you need to listen for the
// DragSource::drag-end signal and delete the data after it has been
// transferred.
type DragSource interface {
	GestureSingle

	// DragCancel cancels a currently ongoing drag operation.
	DragCancel()
	// Actions gets the actions that are currently set on the DragSource.
	Actions() gdk.DragAction
	// Content gets the current content provider of a DragSource.
	Content() gdk.ContentProvider
	// Drag returns the underlying Drag object for an ongoing drag.
	Drag() gdk.Drag
	// SetActions sets the actions on the DragSource.
	//
	// During a DND operation, the actions are offered to potential drop
	// targets. If @actions include GDK_ACTION_MOVE, you need to listen to the
	// DragSource::drag-end signal and handle @delete_data being true.
	//
	// This function can be called before a drag is started, or in a handler for
	// the DragSource::prepare signal.
	SetActions(actions gdk.DragAction)
	// SetContent sets a content provider on a DragSource.
	//
	// When the data is requested in the cause of a DND operation, it will be
	// obtained from the content provider.
	//
	// This function can be called before a drag is started, or in a handler for
	// the DragSource::prepare signal.
	//
	// You may consider setting the content provider back to nil in a
	// DragSource::drag-end signal handler.
	SetContent(content gdk.ContentProvider)
	// SetIcon sets a paintable to use as icon during DND operations.
	//
	// The hotspot coordinates determine the point on the icon that gets aligned
	// with the hotspot of the cursor.
	//
	// If @paintable is nil, a default icon is used.
	//
	// This function can be called before a drag is started, or in a
	// DragSource::prepare or DragSource::drag-begin signal handler.
	SetIcon(paintable gdk.Paintable, hotX int, hotY int)
}

type dragSource struct {
	gestureSingle
}

// WrapDragSource wraps a GObject to the right type. It is
// primarily used internally.
func WrapDragSource(obj *externglib.Object) DragSource {
	return dragSource{gestureSingle{gesture{eventController{*externglib.Object{obj}}}}}
}

func marshalDragSource(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDragSource(obj), nil
}

// NewDragSource constructs a class DragSource.
func NewDragSource() DragSource {

	ret := C.gtk_drag_source_new()

	var ret0 DragSource

	ret0 = WrapDragSource(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// DragCancel cancels a currently ongoing drag operation.
func (source dragSource) DragCancel() {
	var arg0 *C.GtkDragSource

	arg0 = (*C.GtkDragSource)(source.Native())

	C.gtk_drag_source_drag_cancel(arg0)
}

// Actions gets the actions that are currently set on the DragSource.
func (source dragSource) Actions() gdk.DragAction {
	var arg0 *C.GtkDragSource

	arg0 = (*C.GtkDragSource)(source.Native())

	ret := C.gtk_drag_source_get_actions(arg0)

	var ret0 gdk.DragAction

	ret0 = gdk.DragAction(ret)

	return ret0
}

// Content gets the current content provider of a DragSource.
func (source dragSource) Content() gdk.ContentProvider {
	var arg0 *C.GtkDragSource

	arg0 = (*C.GtkDragSource)(source.Native())

	ret := C.gtk_drag_source_get_content(arg0)

	var ret0 gdk.ContentProvider

	ret0 = gdk.WrapContentProvider(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Drag returns the underlying Drag object for an ongoing drag.
func (source dragSource) Drag() gdk.Drag {
	var arg0 *C.GtkDragSource

	arg0 = (*C.GtkDragSource)(source.Native())

	ret := C.gtk_drag_source_get_drag(arg0)

	var ret0 gdk.Drag

	ret0 = gdk.WrapDrag(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// SetActions sets the actions on the DragSource.
//
// During a DND operation, the actions are offered to potential drop
// targets. If @actions include GDK_ACTION_MOVE, you need to listen to the
// DragSource::drag-end signal and handle @delete_data being true.
//
// This function can be called before a drag is started, or in a handler for
// the DragSource::prepare signal.
func (source dragSource) SetActions(actions gdk.DragAction) {
	var arg0 *C.GtkDragSource
	var arg1 C.GdkDragAction

	arg0 = (*C.GtkDragSource)(source.Native())
	arg1 = (C.GdkDragAction)(actions)

	C.gtk_drag_source_set_actions(arg0, arg1)
}

// SetContent sets a content provider on a DragSource.
//
// When the data is requested in the cause of a DND operation, it will be
// obtained from the content provider.
//
// This function can be called before a drag is started, or in a handler for
// the DragSource::prepare signal.
//
// You may consider setting the content provider back to nil in a
// DragSource::drag-end signal handler.
func (source dragSource) SetContent(content gdk.ContentProvider) {
	var arg0 *C.GtkDragSource
	var arg1 *C.GdkContentProvider

	arg0 = (*C.GtkDragSource)(source.Native())
	arg1 = (*C.GdkContentProvider)(content.Native())

	C.gtk_drag_source_set_content(arg0, arg1)
}

// SetIcon sets a paintable to use as icon during DND operations.
//
// The hotspot coordinates determine the point on the icon that gets aligned
// with the hotspot of the cursor.
//
// If @paintable is nil, a default icon is used.
//
// This function can be called before a drag is started, or in a
// DragSource::prepare or DragSource::drag-begin signal handler.
func (source dragSource) SetIcon(paintable gdk.Paintable, hotX int, hotY int) {
	var arg0 *C.GtkDragSource
	var arg1 *C.GdkPaintable
	var arg2 C.int
	var arg3 C.int

	arg0 = (*C.GtkDragSource)(source.Native())
	arg2 = C.int(hotX)
	arg3 = C.int(hotY)

	C.gtk_drag_source_set_icon(arg0, arg1, arg2, arg3)
}

// DrawingArea: the DrawingArea widget is used for creating custom user
// interface elements. It’s essentially a blank widget; you can draw on it.
// After creating a drawing area, the application may want to connect to:
//
// - The Widget::realize signal to take any necessary actions when the widget is
// instantiated on a particular display. (Create GDK resources in response to
// this signal.)
//
// - The DrawingArea::resize signal to take any necessary actions when the
// widget changes size.
//
// - Call gtk_drawing_area_set_draw_func() to handle redrawing the contents of
// the widget.
//
// The following code portion demonstrates using a drawing area to display a
// circle in the normal widget foreground color.
//
// Simple GtkDrawingArea usage
//
//    static void
//    draw_function (GtkDrawingArea *area,
//                   cairo_t        *cr,
//                   int             width,
//                   int             height,
//                   gpointer        data)
//    {
//      GdkRGBA color;
//      GtkStyleContext *context;
//
//      context = gtk_widget_get_style_context (GTK_WIDGET (area));
//
//      cairo_arc (cr,
//                 width / 2.0, height / 2.0,
//                 MIN (width, height) / 2.0,
//                 0, 2 * G_PI);
//
//      gtk_style_context_get_color (context,
//                                   &color);
//      gdk_cairo_set_source_rgba (cr, &color);
//
//      cairo_fill (cr);
//    }
//
//    int
//    main (int argc, char **argv)
//    {
//      gtk_init ();
//
//      GtkWidget *area = gtk_drawing_area_new ();
//      gtk_drawing_area_set_content_width (GTK_DRAWING_AREA (area), 100);
//      gtk_drawing_area_set_content_height (GTK_DRAWING_AREA (area), 100);
//      gtk_drawing_area_set_draw_func (GTK_DRAWING_AREA (area),
//                                      draw_function,
//                                      NULL, NULL);
//      return 0;
//    }
//
//
// The draw function is normally called when a drawing area first comes
// onscreen, or when it’s covered by another window and then uncovered. You can
// also force a redraw by adding to the “damage region” of the drawing area’s
// window using gtk_widget_queue_draw(). This will cause the drawing area to
// call the draw function again.
//
// The available routines for drawing are documented on the [GDK Drawing
// Primitives][gdk4-Cairo-Interaction] page and the cairo documentation.
//
// To receive mouse events on a drawing area, you will need to use event
// controllers. To receive keyboard events, you will need to set the “can-focus”
// property on the drawing area, and you should probably draw some user-visible
// indication that the drawing area is focused.
//
// If you need more complex control over your widget, you should consider
// creating your own Widget subclass.
type DrawingArea interface {
	Widget

	// ContentHeight retrieves the value previously set via
	// gtk_drawing_area_set_content_height().
	ContentHeight() int
	// ContentWidth retrieves the value previously set via
	// gtk_drawing_area_set_content_width().
	ContentWidth() int
	// SetContentHeight sets the desired height of the contents of the drawing
	// area. Note that because widgets may be allocated larger sizes than they
	// requested, it is possible that the actual height passed to your draw
	// function is larger than the height set here. You can use
	// gtk_widget_set_valign() to avoid that.
	//
	// If the height is set to 0 (the default), the drawing area may disappear.
	SetContentHeight(height int)
	// SetContentWidth sets the desired width of the contents of the drawing
	// area. Note that because widgets may be allocated larger sizes than they
	// requested, it is possible that the actual width passed to your draw
	// function is larger than the width set here. You can use
	// gtk_widget_set_halign() to avoid that.
	//
	// If the width is set to 0 (the default), the drawing area may disappear.
	SetContentWidth(width int)
	// SetDrawFunc: setting a draw function is the main thing you want to do
	// when using a drawing area. It is called whenever GTK needs to draw the
	// contents of the drawing area to the screen.
	//
	// The draw function will be called during the drawing stage of GTK. In the
	// drawing stage it is not allowed to change properties of any GTK widgets
	// or call any functions that would cause any properties to be changed. You
	// should restrict yourself exclusively to drawing your contents in the draw
	// function.
	//
	// If what you are drawing does change, call gtk_widget_queue_draw() on the
	// drawing area. This will cause a redraw and will call @draw_func again.
	SetDrawFunc(drawFunc DrawingAreaDrawFunc)
}

type drawingArea struct {
	widget
}

// WrapDrawingArea wraps a GObject to the right type. It is
// primarily used internally.
func WrapDrawingArea(obj *externglib.Object) DrawingArea {
	return drawingArea{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}
}

func marshalDrawingArea(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDrawingArea(obj), nil
}

// NewDrawingArea constructs a class DrawingArea.
func NewDrawingArea() DrawingArea {

	ret := C.gtk_drawing_area_new()

	var ret0 DrawingArea

	ret0 = WrapDrawingArea(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// ContentHeight retrieves the value previously set via
// gtk_drawing_area_set_content_height().
func (self drawingArea) ContentHeight() int {
	var arg0 *C.GtkDrawingArea

	arg0 = (*C.GtkDrawingArea)(self.Native())

	ret := C.gtk_drawing_area_get_content_height(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// ContentWidth retrieves the value previously set via
// gtk_drawing_area_set_content_width().
func (self drawingArea) ContentWidth() int {
	var arg0 *C.GtkDrawingArea

	arg0 = (*C.GtkDrawingArea)(self.Native())

	ret := C.gtk_drawing_area_get_content_width(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// SetContentHeight sets the desired height of the contents of the drawing
// area. Note that because widgets may be allocated larger sizes than they
// requested, it is possible that the actual height passed to your draw
// function is larger than the height set here. You can use
// gtk_widget_set_valign() to avoid that.
//
// If the height is set to 0 (the default), the drawing area may disappear.
func (self drawingArea) SetContentHeight(height int) {
	var arg0 *C.GtkDrawingArea
	var arg1 C.int

	arg0 = (*C.GtkDrawingArea)(self.Native())
	arg1 = C.int(height)

	C.gtk_drawing_area_set_content_height(arg0, arg1)
}

// SetContentWidth sets the desired width of the contents of the drawing
// area. Note that because widgets may be allocated larger sizes than they
// requested, it is possible that the actual width passed to your draw
// function is larger than the width set here. You can use
// gtk_widget_set_halign() to avoid that.
//
// If the width is set to 0 (the default), the drawing area may disappear.
func (self drawingArea) SetContentWidth(width int) {
	var arg0 *C.GtkDrawingArea
	var arg1 C.int

	arg0 = (*C.GtkDrawingArea)(self.Native())
	arg1 = C.int(width)

	C.gtk_drawing_area_set_content_width(arg0, arg1)
}

// SetDrawFunc: setting a draw function is the main thing you want to do
// when using a drawing area. It is called whenever GTK needs to draw the
// contents of the drawing area to the screen.
//
// The draw function will be called during the drawing stage of GTK. In the
// drawing stage it is not allowed to change properties of any GTK widgets
// or call any functions that would cause any properties to be changed. You
// should restrict yourself exclusively to drawing your contents in the draw
// function.
//
// If what you are drawing does change, call gtk_widget_queue_draw() on the
// drawing area. This will cause a redraw and will call @draw_func again.
func (self drawingArea) SetDrawFunc(drawFunc DrawingAreaDrawFunc) {
	var arg0 *C.GtkDrawingArea
	var arg1 C.GtkDrawingAreaDrawFunc
	arg2 := C.gpointer(box.Assign(userData))

	arg0 = (*C.GtkDrawingArea)(self.Native())
	arg1 = (*[0]byte)(C.gotk4_DrawingAreaDrawFunc)

	C.gtk_drawing_area_set_draw_func(arg0, arg1, (*[0]byte)(C.callbackDelete))
}

// DropControllerMotion is an event controller meant for tracking the pointer
// hovering over a widget during a drag and drop operation.
//
// It is modeled after EventControllerMotion so if you have used that, this
// should feel really familiar.
//
// The drop controller is not able to accept drops, use DropTarget for that
// purpose.
type DropControllerMotion interface {
	EventController

	// ContainsPointer returns the value of the
	// GtkDropControllerMotion:contains-pointer property.
	ContainsPointer() bool
	// Drop returns the value of the GtkDropControllerMotion:drop property.
	Drop() gdk.Drop
	// IsPointer returns the value of the GtkDropControllerMotion:is-pointer
	// property.
	IsPointer() bool
}

type dropControllerMotion struct {
	eventController
}

// WrapDropControllerMotion wraps a GObject to the right type. It is
// primarily used internally.
func WrapDropControllerMotion(obj *externglib.Object) DropControllerMotion {
	return dropControllerMotion{eventController{*externglib.Object{obj}}}
}

func marshalDropControllerMotion(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDropControllerMotion(obj), nil
}

// NewDropControllerMotion constructs a class DropControllerMotion.
func NewDropControllerMotion() DropControllerMotion {

	ret := C.gtk_drop_controller_motion_new()

	var ret0 DropControllerMotion

	ret0 = WrapDropControllerMotion(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// ContainsPointer returns the value of the
// GtkDropControllerMotion:contains-pointer property.
func (self dropControllerMotion) ContainsPointer() bool {
	var arg0 *C.GtkDropControllerMotion

	arg0 = (*C.GtkDropControllerMotion)(self.Native())

	ret := C.gtk_drop_controller_motion_contains_pointer(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Drop returns the value of the GtkDropControllerMotion:drop property.
func (self dropControllerMotion) Drop() gdk.Drop {
	var arg0 *C.GtkDropControllerMotion

	arg0 = (*C.GtkDropControllerMotion)(self.Native())

	ret := C.gtk_drop_controller_motion_get_drop(arg0)

	var ret0 gdk.Drop

	ret0 = gdk.WrapDrop(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// IsPointer returns the value of the GtkDropControllerMotion:is-pointer
// property.
func (self dropControllerMotion) IsPointer() bool {
	var arg0 *C.GtkDropControllerMotion

	arg0 = (*C.GtkDropControllerMotion)(self.Native())

	ret := C.gtk_drop_controller_motion_is_pointer(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// DropDown: gtkDropDown is a widget that allows the user to choose an item from
// a list of options. The GtkDropDown displays the selected choice.
//
// The options are given to GtkDropDown in the form of Model, and how the
// individual options are represented is determined by a ListItemFactory. The
// default factory displays simple strings.
//
// GtkDropDown knows how to obtain strings from the items in a StringList; for
// other models, you have to provide an expression to find the strings via
// gtk_drop_down_set_expression().
//
// GtkDropDown can optionally allow search in the popup, which is useful if the
// list of options is long. To enable the search entry, use
// gtk_drop_down_set_enable_search().
//
//
// CSS nodes
//
// GtkDropDown has a single CSS node with name dropdown, with the button and
// popover nodes as children.
//
//
// Accessibility
//
// GtkDropDown uses the K_ACCESSIBLE_ROLE_COMBO_BOX role.
type DropDown interface {
	Widget

	// EnableSearch returns whether search is enabled.
	EnableSearch() bool
	// Expression gets the expression set with gtk_drop_down_set_expression().
	Expression() Expression
	// Factory gets the factory that's currently used to populate list items.
	//
	// The factory returned by this function is always used for the item in the
	// button. It is also used for items in the popup if DropDown:list-factory
	// is not set.
	Factory() ListItemFactory
	// ListFactory gets the factory that's currently used to populate list items
	// in the popup.
	ListFactory() ListItemFactory
	// Model gets the model that provides the displayed items.
	Model() gio.ListModel
	// Selected gets the position of the selected item.
	Selected() uint
	// SelectedItem gets the selected item. If no item is selected, nil is
	// returned.
	SelectedItem() gextras.Objector
	// SetEnableSearch sets whether a search entry will be shown in the popup
	// that allows to search for items in the list.
	//
	// Note that DropDown:expression must be set for search to work.
	SetEnableSearch(enableSearch bool)
	// SetExpression sets the expression that gets evaluated to obtain strings
	// from items when searching in the popup. The expression must have a value
	// type of TYPE_STRING.
	SetExpression(expression Expression)
	// SetFactory sets the ListItemFactory to use for populating list items.
	SetFactory(factory ListItemFactory)
	// SetListFactory sets the ListItemFactory to use for populating list items
	// in the popup.
	SetListFactory(factory ListItemFactory)
	// SetModel sets the Model to use.
	SetModel(model gio.ListModel)
	// SetSelected selects the item at the given position.
	SetSelected(position uint)
}

type dropDown struct {
	widget
}

// WrapDropDown wraps a GObject to the right type. It is
// primarily used internally.
func WrapDropDown(obj *externglib.Object) DropDown {
	return dropDown{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}
}

func marshalDropDown(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDropDown(obj), nil
}

// NewDropDown constructs a class DropDown.
func NewDropDown(model gio.ListModel, expression Expression) DropDown {
	var arg1 *C.GListModel
	var arg2 *C.GtkExpression

	arg2 = (*C.GtkExpression)(expression.Native())

	ret := C.gtk_drop_down_new(arg1, arg2)

	var ret0 DropDown

	ret0 = WrapDropDown(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewDropDownFromStrings constructs a class DropDown.
func NewDropDownFromStrings(strings []string) DropDown {
	var arg1 **C.char

	{

	}

	ret := C.gtk_drop_down_new_from_strings(arg1)

	var ret0 DropDown

	ret0 = WrapDropDown(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// EnableSearch returns whether search is enabled.
func (self dropDown) EnableSearch() bool {
	var arg0 *C.GtkDropDown

	arg0 = (*C.GtkDropDown)(self.Native())

	ret := C.gtk_drop_down_get_enable_search(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Expression gets the expression set with gtk_drop_down_set_expression().
func (self dropDown) Expression() Expression {
	var arg0 *C.GtkDropDown

	arg0 = (*C.GtkDropDown)(self.Native())

	ret := C.gtk_drop_down_get_expression(arg0)

	var ret0 Expression

	ret0 = WrapExpression(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Factory gets the factory that's currently used to populate list items.
//
// The factory returned by this function is always used for the item in the
// button. It is also used for items in the popup if DropDown:list-factory
// is not set.
func (self dropDown) Factory() ListItemFactory {
	var arg0 *C.GtkDropDown

	arg0 = (*C.GtkDropDown)(self.Native())

	ret := C.gtk_drop_down_get_factory(arg0)

	var ret0 ListItemFactory

	ret0 = WrapListItemFactory(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// ListFactory gets the factory that's currently used to populate list items
// in the popup.
func (self dropDown) ListFactory() ListItemFactory {
	var arg0 *C.GtkDropDown

	arg0 = (*C.GtkDropDown)(self.Native())

	ret := C.gtk_drop_down_get_list_factory(arg0)

	var ret0 ListItemFactory

	ret0 = WrapListItemFactory(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Model gets the model that provides the displayed items.
func (self dropDown) Model() gio.ListModel {
	var arg0 *C.GtkDropDown

	arg0 = (*C.GtkDropDown)(self.Native())

	ret := C.gtk_drop_down_get_model(arg0)

	var ret0 gio.ListModel

	return ret0
}

// Selected gets the position of the selected item.
func (self dropDown) Selected() uint {
	var arg0 *C.GtkDropDown

	arg0 = (*C.GtkDropDown)(self.Native())

	ret := C.gtk_drop_down_get_selected(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// SelectedItem gets the selected item. If no item is selected, nil is
// returned.
func (self dropDown) SelectedItem() gextras.Objector {
	var arg0 *C.GtkDropDown

	arg0 = (*C.GtkDropDown)(self.Native())

	ret := C.gtk_drop_down_get_selected_item(arg0)

	var ret0 gextras.Objector

	ret0 = externglib.Take(unsafe.Pointer(ret.Native()))

	return ret0
}

// SetEnableSearch sets whether a search entry will be shown in the popup
// that allows to search for items in the list.
//
// Note that DropDown:expression must be set for search to work.
func (self dropDown) SetEnableSearch(enableSearch bool) {
	var arg0 *C.GtkDropDown
	var arg1 C.gboolean

	arg0 = (*C.GtkDropDown)(self.Native())
	arg1 = gextras.Cbool(enableSearch)

	C.gtk_drop_down_set_enable_search(arg0, arg1)
}

// SetExpression sets the expression that gets evaluated to obtain strings
// from items when searching in the popup. The expression must have a value
// type of TYPE_STRING.
func (self dropDown) SetExpression(expression Expression) {
	var arg0 *C.GtkDropDown
	var arg1 *C.GtkExpression

	arg0 = (*C.GtkDropDown)(self.Native())
	arg1 = (*C.GtkExpression)(expression.Native())

	C.gtk_drop_down_set_expression(arg0, arg1)
}

// SetFactory sets the ListItemFactory to use for populating list items.
func (self dropDown) SetFactory(factory ListItemFactory) {
	var arg0 *C.GtkDropDown
	var arg1 *C.GtkListItemFactory

	arg0 = (*C.GtkDropDown)(self.Native())
	arg1 = (*C.GtkListItemFactory)(factory.Native())

	C.gtk_drop_down_set_factory(arg0, arg1)
}

// SetListFactory sets the ListItemFactory to use for populating list items
// in the popup.
func (self dropDown) SetListFactory(factory ListItemFactory) {
	var arg0 *C.GtkDropDown
	var arg1 *C.GtkListItemFactory

	arg0 = (*C.GtkDropDown)(self.Native())
	arg1 = (*C.GtkListItemFactory)(factory.Native())

	C.gtk_drop_down_set_list_factory(arg0, arg1)
}

// SetModel sets the Model to use.
func (self dropDown) SetModel(model gio.ListModel) {
	var arg0 *C.GtkDropDown
	var arg1 *C.GListModel

	arg0 = (*C.GtkDropDown)(self.Native())

	C.gtk_drop_down_set_model(arg0, arg1)
}

// SetSelected selects the item at the given position.
func (self dropDown) SetSelected(position uint) {
	var arg0 *C.GtkDropDown
	var arg1 C.guint

	arg0 = (*C.GtkDropDown)(self.Native())
	arg1 = C.guint(position)

	C.gtk_drop_down_set_selected(arg0, arg1)
}

// DropTarget: gtkDropTarget is an event controller implementing a simple way to
// receive Drag-and-Drop operations.
//
// The most basic way to use a DropTarget to receive drops on a widget is to
// create it via gtk_drop_target_new() passing in the #GType of the data you
// want to receive and connect to the DropTarget::drop signal to receive the
// data:
//
//    static gboolean
//    on_drop (GtkDropTarget *target,
//             const GValue  *value,
//             double         x,
//             double         y,
//             gpointer       data)
//    {
//      MyWidget *self = data;
//
//      // Call the appropriate setter depending on the type of data
//      // that we received
//      if (G_VALUE_HOLDS (value, G_TYPE_FILE))
//        my_widget_set_file (self, g_value_get_object (value));
//      else if (G_VALUE_HOLDS (value, GDK_TYPE_PIXBUF))
//        my_widget_set_pixbuf (self, g_value_get_object (value));
//      else
//        return FALSE;
//
//      return TRUE;
//    }
//
//    static void
//    my_widget_init (MyWidget *self)
//    {
//      GtkDropTarget *target =
//        gtk_drop_target_new (G_TYPE_INVALID, GDK_ACTION_COPY);
//
//      // This widget accepts two types of drop types: GFile objects
//      // and GdkPixbuf objects
//      gtk_drop_target_set_gtypes (target, (GTypes [2]) {
//        G_TYPE_FILE,
//        GDK_TYPE_PIXBUF,
//      }, 2);
//
//      gtk_widget_add_controller (GTK_WIDGET (self), GTK_EVENT_CONTROLLER (target));
//    }
//
//
// DropTarget supports more options, such as:
//
//    * rejecting potential drops via the DropTarget::accept signal
//      and the gtk_drop_target_reject() function to let other drop
//      targets handle the drop
//    * tracking an ongoing drag operation before the drop via the
//      DropTarget::enter, DropTarget::motion and
//      DropTarget::leave signals
//    * configuring how to receive data by setting the
//      DropTarget:preload property and listening for its availability
//      via the DropTarget:value property
//
// However, DropTarget is ultimately modeled in a synchronous way and only
// supports data transferred via #GType. If you want full control over an
// ongoing drop, the DropTargetAsync object gives you this ability.
//
// While a pointer is dragged over the drop target's widget and the drop has not
// been rejected, that widget will receive the GTK_STATE_FLAG_DROP_ACTIVE state,
// which can be used to style the widget.
type DropTarget interface {
	EventController

	// Actions gets the actions that this drop target supports.
	Actions() gdk.DragAction
	// Drop gets the currently handled drop operation.
	//
	// If no drop operation is going on, nil is returned.
	Drop() gdk.Drop
	// Formats gets the data formats that this drop target accepts.
	//
	// If the result is nil, all formats are expected to be supported.
	Formats() *gdk.ContentFormats
	// GTypes gets the list of supported #GTypes for @self. If no type have been
	// set, nil will be returned.
	GTypes() (nTypes uint, gTypes []externglib.Type)
	// Preload gets the value of the GtkDropTarget:preload property.
	Preload() bool
	// Value gets the value of the GtkDropTarget:value property.
	Value() *externglib.Value
	// Reject rejects the ongoing drop operation.
	//
	// If no drop operation is ongoing - when GdkDropTarget:drop returns nil -
	// this function does nothing.
	//
	// This function should be used when delaying the decision on whether to
	// accept a drag or not until after reading the data.
	Reject()
	// SetActions sets the actions that this drop target supports.
	SetActions(actions gdk.DragAction)
	// SetGTypes sets the supported #GTypes for this drop target.
	SetGTypes(types []externglib.Type)
	// SetPreload sets the GtkDropTarget:preload property.
	SetPreload(preload bool)
}

type dropTarget struct {
	eventController
}

// WrapDropTarget wraps a GObject to the right type. It is
// primarily used internally.
func WrapDropTarget(obj *externglib.Object) DropTarget {
	return dropTarget{eventController{*externglib.Object{obj}}}
}

func marshalDropTarget(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDropTarget(obj), nil
}

// NewDropTarget constructs a class DropTarget.
func NewDropTarget(_type externglib.Type, actions gdk.DragAction) DropTarget {
	var arg1 C.GType
	var arg2 C.GdkDragAction

	arg1 = C.GType(_type)
	arg2 = (C.GdkDragAction)(actions)

	ret := C.gtk_drop_target_new(arg1, arg2)

	var ret0 DropTarget

	ret0 = WrapDropTarget(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Actions gets the actions that this drop target supports.
func (self dropTarget) Actions() gdk.DragAction {
	var arg0 *C.GtkDropTarget

	arg0 = (*C.GtkDropTarget)(self.Native())

	ret := C.gtk_drop_target_get_actions(arg0)

	var ret0 gdk.DragAction

	ret0 = gdk.DragAction(ret)

	return ret0
}

// Drop gets the currently handled drop operation.
//
// If no drop operation is going on, nil is returned.
func (self dropTarget) Drop() gdk.Drop {
	var arg0 *C.GtkDropTarget

	arg0 = (*C.GtkDropTarget)(self.Native())

	ret := C.gtk_drop_target_get_drop(arg0)

	var ret0 gdk.Drop

	ret0 = gdk.WrapDrop(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Formats gets the data formats that this drop target accepts.
//
// If the result is nil, all formats are expected to be supported.
func (self dropTarget) Formats() *gdk.ContentFormats {
	var arg0 *C.GtkDropTarget

	arg0 = (*C.GtkDropTarget)(self.Native())

	ret := C.gtk_drop_target_get_formats(arg0)

	var ret0 *gdk.ContentFormats

	ret0 = gdk.WrapContentFormats(ret)

	return ret0
}

// GTypes gets the list of supported #GTypes for @self. If no type have been
// set, nil will be returned.
func (self dropTarget) GTypes() (nTypes uint, gTypes []externglib.Type) {
	var arg0 *C.GtkDropTarget
	var arg1 *C.gsize // out

	arg0 = (*C.GtkDropTarget)(self.Native())

	ret := C.gtk_drop_target_get_gtypes(arg0, &arg1)

	var ret0 uint
	var ret1 []externglib.Type

	ret0 = uint(arg1)

	return ret0, ret1
}

// Preload gets the value of the GtkDropTarget:preload property.
func (self dropTarget) Preload() bool {
	var arg0 *C.GtkDropTarget

	arg0 = (*C.GtkDropTarget)(self.Native())

	ret := C.gtk_drop_target_get_preload(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Value gets the value of the GtkDropTarget:value property.
func (self dropTarget) Value() *externglib.Value {
	var arg0 *C.GtkDropTarget

	arg0 = (*C.GtkDropTarget)(self.Native())

	ret := C.gtk_drop_target_get_value(arg0)

	var ret0 *externglib.Value

	return ret0
}

// Reject rejects the ongoing drop operation.
//
// If no drop operation is ongoing - when GdkDropTarget:drop returns nil -
// this function does nothing.
//
// This function should be used when delaying the decision on whether to
// accept a drag or not until after reading the data.
func (self dropTarget) Reject() {
	var arg0 *C.GtkDropTarget

	arg0 = (*C.GtkDropTarget)(self.Native())

	C.gtk_drop_target_reject(arg0)
}

// SetActions sets the actions that this drop target supports.
func (self dropTarget) SetActions(actions gdk.DragAction) {
	var arg0 *C.GtkDropTarget
	var arg1 C.GdkDragAction

	arg0 = (*C.GtkDropTarget)(self.Native())
	arg1 = (C.GdkDragAction)(actions)

	C.gtk_drop_target_set_actions(arg0, arg1)
}

// SetGTypes sets the supported #GTypes for this drop target.
func (self dropTarget) SetGTypes(types []externglib.Type) {
	var arg0 *C.GtkDropTarget
	var arg1 *C.GType
	var arg2 C.gsize

	arg0 = (*C.GtkDropTarget)(self.Native())
	{
		var dst []C.GType
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(C.malloc(C.sizeof_GType * len(types))))
		sliceHeader.Len = len(types)
		sliceHeader.Cap = len(types)
		defer C.free(unsafe.Pointer(sliceHeader.Data))

		for i := 0; i < len(types); i++ {
			src := types[i]
			dst[i] = C.GType(src)
		}

		arg1 = (*C.GType)(unsafe.Pointer(sliceHeader.Data))
		arg2 = len(types)
	}

	C.gtk_drop_target_set_gtypes(arg0, arg1, arg2)
}

// SetPreload sets the GtkDropTarget:preload property.
func (self dropTarget) SetPreload(preload bool) {
	var arg0 *C.GtkDropTarget
	var arg1 C.gboolean

	arg0 = (*C.GtkDropTarget)(self.Native())
	arg1 = gextras.Cbool(preload)

	C.gtk_drop_target_set_preload(arg0, arg1)
}

// DropTargetAsync: gtkDropTargetAsync is an auxiliary object that can be used
// to receive Drag-and-Drop operations. It is the more complete but also more
// complex method of handling drop operations compared to DropTarget and you
// should only use it if DropTarget doesn't provide all the features you need.
//
// To use a DropTargetAsync to receive drops on a widget, you create a
// DropTargetAsync object, configure which data formats and actions you support,
// connect to its signals, and then attach it to the widget with
// gtk_widget_add_controller().
//
// During a drag operation, the first signal that a GtkDropTargetAsync emits is
// DropTargetAsync::accept, which is meant to determine whether the target is a
// possible drop site for the ongoing drop. The default handler for the ::accept
// signal accepts the drop if it finds a compatible data format and an action
// that is supported on both sides.
//
// If it is, and the widget becomes a target, you will receive a
// DropTargetAsync::drag-enter signal, followed by DropTargetAsync::drag-motion
// signals as the pointer moves, optionally a DropTargetAsync::drop signal when
// a drop happens, and finally a DropTargetAsync::drag-leave signal when the
// pointer moves off the widget.
//
// The ::drag-enter and ::drag-motion handler return a DragAction to update the
// status of the ongoing operation. The ::drop handler should decide if it
// ultimately accepts the drop and if it does, it should initiate the data
// transfer and finish the operation by calling gdk_drop_finish().
//
// Between the ::drag-enter and ::drag-leave signals the widget is a current
// drop target, and will receive the GTK_STATE_FLAG_DROP_ACTIVE state, which can
// be used by themes to style the widget as a drop target.
type DropTargetAsync interface {
	EventController

	// Actions gets the actions that this drop target supports.
	Actions() gdk.DragAction
	// Formats gets the data formats that this drop target accepts.
	//
	// If the result is nil, all formats are expected to be supported.
	Formats() *gdk.ContentFormats
	// RejectDrop sets the @drop as not accepted on this drag site.
	//
	// This function should be used when delaying the decision on whether to
	// accept a drag or not until after reading the data.
	RejectDrop(drop gdk.Drop)
	// SetActions sets the actions that this drop target supports.
	SetActions(actions gdk.DragAction)
	// SetFormats sets the data formats that this drop target will accept.
	SetFormats(formats *gdk.ContentFormats)
}

type dropTargetAsync struct {
	eventController
}

// WrapDropTargetAsync wraps a GObject to the right type. It is
// primarily used internally.
func WrapDropTargetAsync(obj *externglib.Object) DropTargetAsync {
	return dropTargetAsync{eventController{*externglib.Object{obj}}}
}

func marshalDropTargetAsync(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDropTargetAsync(obj), nil
}

// NewDropTargetAsync constructs a class DropTargetAsync.
func NewDropTargetAsync(formats *gdk.ContentFormats, actions gdk.DragAction) DropTargetAsync {
	var arg1 *C.GdkContentFormats
	var arg2 C.GdkDragAction

	arg1 = (*C.GdkContentFormats)(formats.Native())
	arg2 = (C.GdkDragAction)(actions)

	ret := C.gtk_drop_target_async_new(arg1, arg2)

	var ret0 DropTargetAsync

	ret0 = WrapDropTargetAsync(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Actions gets the actions that this drop target supports.
func (self dropTargetAsync) Actions() gdk.DragAction {
	var arg0 *C.GtkDropTargetAsync

	arg0 = (*C.GtkDropTargetAsync)(self.Native())

	ret := C.gtk_drop_target_async_get_actions(arg0)

	var ret0 gdk.DragAction

	ret0 = gdk.DragAction(ret)

	return ret0
}

// Formats gets the data formats that this drop target accepts.
//
// If the result is nil, all formats are expected to be supported.
func (self dropTargetAsync) Formats() *gdk.ContentFormats {
	var arg0 *C.GtkDropTargetAsync

	arg0 = (*C.GtkDropTargetAsync)(self.Native())

	ret := C.gtk_drop_target_async_get_formats(arg0)

	var ret0 *gdk.ContentFormats

	ret0 = gdk.WrapContentFormats(ret)

	return ret0
}

// RejectDrop sets the @drop as not accepted on this drag site.
//
// This function should be used when delaying the decision on whether to
// accept a drag or not until after reading the data.
func (self dropTargetAsync) RejectDrop(drop gdk.Drop) {
	var arg0 *C.GtkDropTargetAsync
	var arg1 *C.GdkDrop

	arg0 = (*C.GtkDropTargetAsync)(self.Native())
	arg1 = (*C.GdkDrop)(drop.Native())

	C.gtk_drop_target_async_reject_drop(arg0, arg1)
}

// SetActions sets the actions that this drop target supports.
func (self dropTargetAsync) SetActions(actions gdk.DragAction) {
	var arg0 *C.GtkDropTargetAsync
	var arg1 C.GdkDragAction

	arg0 = (*C.GtkDropTargetAsync)(self.Native())
	arg1 = (C.GdkDragAction)(actions)

	C.gtk_drop_target_async_set_actions(arg0, arg1)
}

// SetFormats sets the data formats that this drop target will accept.
func (self dropTargetAsync) SetFormats(formats *gdk.ContentFormats) {
	var arg0 *C.GtkDropTargetAsync
	var arg1 *C.GdkContentFormats

	arg0 = (*C.GtkDropTargetAsync)(self.Native())
	arg1 = (*C.GdkContentFormats)(formats.Native())

	C.gtk_drop_target_async_set_formats(arg0, arg1)
}

// EditableLabel: a GtkEditableLabel is a Label that allows users to edit the
// text by switching the widget to an “edit mode”.
//
// GtkEditableLabel does not have API of its own, but it implements the Editable
// interface.
//
// The default bindings for activating the edit mode is to click or press the
// Enter key. The default bindings for leaving the edit mode are the Enter key
// (to save the results) or the Escape key (to cancel the editing).
//
// CSS nodes
//
//    editablelabel[.editing]
//    ╰── stack
//        ├── label
//        ╰── text
//
//
// GtkEditableLabel has a main node with the name editablelabel. When the entry
// is in editing mode, it gets the .editing style class.
//
// For all the subnodes added to the text node in various situations, see Text.
type EditableLabel interface {
	Widget

	// Editing returns whether the label is currently in “editing mode”.
	Editing() bool
	// StartEditing switches the label into “editing mode”.
	StartEditing()
	// StopEditing switches the label out of “editing mode”. If @commit is true,
	// the resulting text is kept as the Editable:text property value, otherwise
	// the resulting text is discarded and the label will keep its previous
	// Editable:text property value.
	StopEditing(commit bool)
}

type editableLabel struct {
	widget
}

// WrapEditableLabel wraps a GObject to the right type. It is
// primarily used internally.
func WrapEditableLabel(obj *externglib.Object) EditableLabel {
	return editableLabel{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}
}

func marshalEditableLabel(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapEditableLabel(obj), nil
}

// NewEditableLabel constructs a class EditableLabel.
func NewEditableLabel(str string) EditableLabel {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_editable_label_new(arg1)

	var ret0 EditableLabel

	ret0 = WrapEditableLabel(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Editing returns whether the label is currently in “editing mode”.
func (self editableLabel) Editing() bool {
	var arg0 *C.GtkEditableLabel

	arg0 = (*C.GtkEditableLabel)(self.Native())

	ret := C.gtk_editable_label_get_editing(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// StartEditing switches the label into “editing mode”.
func (self editableLabel) StartEditing() {
	var arg0 *C.GtkEditableLabel

	arg0 = (*C.GtkEditableLabel)(self.Native())

	C.gtk_editable_label_start_editing(arg0)
}

// StopEditing switches the label out of “editing mode”. If @commit is true,
// the resulting text is kept as the Editable:text property value, otherwise
// the resulting text is discarded and the label will keep its previous
// Editable:text property value.
func (self editableLabel) StopEditing(commit bool) {
	var arg0 *C.GtkEditableLabel
	var arg1 C.gboolean

	arg0 = (*C.GtkEditableLabel)(self.Native())
	arg1 = gextras.Cbool(commit)

	C.gtk_editable_label_stop_editing(arg0, arg1)
}

// EmojiChooser: the EmojiChooser popover is used by text widgets such as Entry
// or TextView to offer users a convenient way to insert Emoji characters.
//
// GtkEmojiChooser emits the EmojiChooser::emoji-picked signal when an Emoji is
// selected.
//
// CSS nodes
//
//    popover
//    ├── box.emoji-searchbar
//    │   ╰── entry.search
//    ╰── box.emoji-toolbar
//        ├── button.image-button.emoji-section
//        ├── ...
//        ╰── button.image-button.emoji-section
//
//
// Every EmojiChooser consists of a main node called popover. The contents of
// the popover are largely implementation defined and supposed to inherit
// general styles. The top searchbar used to search emoji and gets the
// .emoji-searchbar style class itself. The bottom toolbar used to switch
// between different emoji categories consists of buttons with the
// .emoji-section style class and gets the .emoji-toolbar style class itself.
type EmojiChooser interface {
	Popover
}

type emojiChooser struct {
	popover
}

// WrapEmojiChooser wraps a GObject to the right type. It is
// primarily used internally.
func WrapEmojiChooser(obj *externglib.Object) EmojiChooser {
	return emojiChooser{popover{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}}
}

func marshalEmojiChooser(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapEmojiChooser(obj), nil
}

// NewEmojiChooser constructs a class EmojiChooser.
func NewEmojiChooser() EmojiChooser {

	ret := C.gtk_emoji_chooser_new()

	var ret0 EmojiChooser

	ret0 = WrapEmojiChooser(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Entry: the Entry widget is a single line text entry widget. A fairly large
// set of key bindings are supported by default. If the entered text is longer
// than the allocation of the widget, the widget will scroll so that the cursor
// position is visible.
//
// When using an entry for passwords and other sensitive information, it can be
// put into “password mode” using gtk_entry_set_visibility(). In this mode,
// entered text is displayed using a “invisible” character. By default, GTK
// picks the best invisible character that is available in the current font, but
// it can be changed with gtk_entry_set_invisible_char().
//
// GtkEntry has the ability to display progress or activity information behind
// the text. To make an entry display such information, use
// gtk_entry_set_progress_fraction() or gtk_entry_set_progress_pulse_step().
//
// Additionally, GtkEntry can show icons at either side of the entry. These
// icons can be activatable by clicking, can be set up as drag source and can
// have tooltips. To add an icon, use gtk_entry_set_icon_from_gicon() or one of
// the various other functions that set an icon from an icon name or a
// paintable. To trigger an action when the user clicks an icon, connect to the
// Entry::icon-press signal. To allow DND operations from an icon, use
// gtk_entry_set_icon_drag_source(). To set a tooltip on an icon, use
// gtk_entry_set_icon_tooltip_text() or the corresponding function for markup.
//
// Note that functionality or information that is only available by clicking on
// an icon in an entry may not be accessible at all to users which are not able
// to use a mouse or other pointing device. It is therefore recommended that any
// such functionality should also be available by other means, e.g. via the
// context menu of the entry.
//
// CSS nodes
//
//    entry[.flat][.warning][.error]
//    ├── text[.readonly]
//    ├── image.left
//    ├── image.right
//    ╰── [progress[.pulse]]
//    ]|
//
//    GtkEntry has a main node with the name entry. Depending on the properties
//    of the entry, the style classes .read-only and .flat may appear. The style
//    classes .warning and .error may also be used with entries.
//
//    When the entry shows icons, it adds subnodes with the name image and the
//    style class .left or .right, depending on where the icon appears.
//
//    When the entry shows progress, it adds a subnode with the name progress.
//    The node has the style class .pulse when the shown progress is pulsing.
//
//    For all the subnodes added to the text node in various situations,
//    see Text.
//
//
//
// GtkEntry as GtkBuildable
//
//
//    The GtkEntry implementation of the GtkBuildable interface supports a
//    custom <attributes> element, which supports any number of <attribute>
//    elements. The <attribute> element has attributes named “name“, “value“,
//    “start“ and “end“ and allows you to specify Attribute values for
//    this label.
//
//    An example of a UI definition fragment specifying Pango attributes:
//    |[
//    <object class="GtkEnry">
//      <attributes>
//        <attribute name="weight" value="PANGO_WEIGHT_BOLD"/>
//        <attribute name="background" value="red" start="5" end="10"/>
//      </attributes>
//    </object>
//
//
// The start and end attributes specify the range of characters to which the
// Pango attribute applies. If start and end are not specified, the attribute is
// applied to the whole text. Note that specifying ranges does not make much
// sense with translatable attributes. Use markup embedded in the translatable
// content instead.
//
//
// Accessibility
//
// GtkEntry uses the K_ACCESSIBLE_ROLE_TEXT_BOX role.
type Entry interface {
	Widget

	// ActivatesDefault retrieves the value set by
	// gtk_entry_set_activates_default().
	ActivatesDefault() bool
	// Alignment gets the value set by gtk_entry_set_alignment().
	Alignment() float32
	// Attributes gets the attribute list that was set on the entry using
	// gtk_entry_set_attributes(), if any.
	Attributes() *pango.AttrList
	// Buffer: get the EntryBuffer object which holds the text for this widget.
	Buffer() EntryBuffer
	// Completion returns the auxiliary completion object currently in use by
	// @entry.
	Completion() EntryCompletion
	// CurrentIconDragSource returns the index of the icon which is the source
	// of the current DND operation, or -1.
	CurrentIconDragSource() int
	// ExtraMenu gets the menu model set with gtk_entry_set_extra_menu().
	ExtraMenu() gio.MenuModel
	// HasFrame gets the value set by gtk_entry_set_has_frame().
	HasFrame() bool
	// IconActivatable returns whether the icon is activatable.
	IconActivatable(iconPos EntryIconPosition) bool
	// IconArea gets the area where entry’s icon at @icon_pos is drawn. This
	// function is useful when drawing something to the entry in a draw
	// callback.
	//
	// If the entry is not realized or has no icon at the given position,
	// @icon_area is filled with zeros. Otherwise, @icon_area will be filled
	// with the icon's allocation, relative to @entry's allocation.
	IconArea(iconPos EntryIconPosition) gdk.Rectangle
	// IconAtPos finds the icon at the given position and return its index. The
	// position’s coordinates are relative to the @entry’s top left corner. If
	// @x, @y doesn’t lie inside an icon, -1 is returned. This function is
	// intended for use in a Widget::query-tooltip signal handler.
	IconAtPos(x int, y int) int
	// IconGIcon retrieves the #GIcon used for the icon, or nil if there is no
	// icon or if the icon was set by some other method (e.g., by paintable or
	// icon name).
	IconGIcon(iconPos EntryIconPosition) gio.Icon
	// IconName retrieves the icon name used for the icon, or nil if there is no
	// icon or if the icon was set by some other method (e.g., by paintable or
	// gicon).
	IconName(iconPos EntryIconPosition) string
	// IconPaintable retrieves the Paintable used for the icon.
	//
	// If no Paintable was used for the icon, nil is returned.
	IconPaintable(iconPos EntryIconPosition) gdk.Paintable
	// IconSensitive returns whether the icon appears sensitive or insensitive.
	IconSensitive(iconPos EntryIconPosition) bool
	// IconStorageType gets the type of representation being used by the icon to
	// store image data. If the icon has no image data, the return value will be
	// GTK_IMAGE_EMPTY.
	IconStorageType(iconPos EntryIconPosition) ImageType
	// IconTooltipMarkup gets the contents of the tooltip on the icon at the
	// specified position in @entry.
	IconTooltipMarkup(iconPos EntryIconPosition) string
	// IconTooltipText gets the contents of the tooltip on the icon at the
	// specified position in @entry.
	IconTooltipText(iconPos EntryIconPosition) string
	// InputHints gets the value of the Entry:input-hints property.
	InputHints() InputHints
	// InputPurpose gets the value of the Entry:input-purpose property.
	InputPurpose() InputPurpose
	// InvisibleChar retrieves the character displayed in place of the real
	// characters for entries with visibility set to false. See
	// gtk_entry_set_invisible_char().
	InvisibleChar() uint32
	// MaxLength retrieves the maximum allowed length of the text in @entry. See
	// gtk_entry_set_max_length().
	//
	// This is equivalent to getting @entry's EntryBuffer and calling
	// gtk_entry_buffer_get_max_length() on it.
	MaxLength() int
	// OverwriteMode gets the value set by gtk_entry_set_overwrite_mode().
	OverwriteMode() bool
	// PlaceholderText retrieves the text that will be displayed when @entry is
	// empty and unfocused
	PlaceholderText() string
	// ProgressFraction returns the current fraction of the task that’s been
	// completed. See gtk_entry_set_progress_fraction().
	ProgressFraction() float64
	// ProgressPulseStep retrieves the pulse step set with
	// gtk_entry_set_progress_pulse_step().
	ProgressPulseStep() float64
	// Tabs gets the tabstops that were set on the entry using
	// gtk_entry_set_tabs(), if any.
	Tabs() *pango.TabArray
	// TextLength retrieves the current length of the text in @entry.
	//
	// This is equivalent to getting @entry's EntryBuffer and calling
	// gtk_entry_buffer_get_length() on it.
	TextLength() uint16
	// Visibility retrieves whether the text in @entry is visible. See
	// gtk_entry_set_visibility().
	Visibility() bool
	// GrabFocusWithoutSelecting causes @entry to have keyboard focus.
	//
	// It behaves like gtk_widget_grab_focus(), except that it doesn't select
	// the contents of the entry. You only want to call this on some special
	// entries which the user usually doesn't want to replace all text in, such
	// as search-as-you-type entries.
	GrabFocusWithoutSelecting() bool
	// ProgressPulse indicates that some progress is made, but you don’t know
	// how much. Causes the entry’s progress indicator to enter “activity mode,”
	// where a block bounces back and forth. Each call to
	// gtk_entry_progress_pulse() causes the block to move by a little bit (the
	// amount of movement per pulse is determined by
	// gtk_entry_set_progress_pulse_step()).
	ProgressPulse()
	// ResetImContext: reset the input method context of the entry if needed.
	//
	// This can be necessary in the case where modifying the buffer would
	// confuse on-going input method behavior.
	ResetImContext()
	// SetActivatesDefault: if @setting is true, pressing Enter in the @entry
	// will activate the default widget for the window containing the entry.
	// This usually means that the dialog box containing the entry will be
	// closed, since the default widget is usually one of the dialog buttons.
	SetActivatesDefault(setting bool)
	// SetAlignment sets the alignment for the contents of the entry. This
	// controls the horizontal positioning of the contents when the displayed
	// text is shorter than the width of the entry.
	SetAlignment(xalign float32)
	// SetAttributes sets a AttrList; the attributes in the list are applied to
	// the entry text.
	SetAttributes(attrs *pango.AttrList)
	// SetBuffer: set the EntryBuffer object which holds the text for this
	// widget.
	SetBuffer(buffer EntryBuffer)
	// SetCompletion sets @completion to be the auxiliary completion object to
	// use with @entry. All further configuration of the completion mechanism is
	// done on @completion using the EntryCompletion API. Completion is disabled
	// if @completion is set to nil.
	SetCompletion(completion EntryCompletion)
	// SetExtraMenu sets a menu model to add when constructing the context menu
	// for @entry.
	SetExtraMenu(model gio.MenuModel)
	// SetHasFrame sets whether the entry has a beveled frame around it.
	SetHasFrame(setting bool)
	// SetIconActivatable sets whether the icon is activatable.
	SetIconActivatable(iconPos EntryIconPosition, activatable bool)
	// SetIconDragSource sets up the icon at the given position so that GTK will
	// start a drag operation when the user clicks and drags the icon.
	SetIconDragSource(iconPos EntryIconPosition, provider gdk.ContentProvider, actions gdk.DragAction)
	// SetIconFromGIcon sets the icon shown in the entry at the specified
	// position from the current icon theme. If the icon isn’t known, a “broken
	// image” icon will be displayed instead.
	//
	// If @icon is nil, no icon will be shown in the specified position.
	SetIconFromGIcon(iconPos EntryIconPosition, icon gio.Icon)
	// SetIconFromIconName sets the icon shown in the entry at the specified
	// position from the current icon theme.
	//
	// If the icon name isn’t known, a “broken image” icon will be displayed
	// instead.
	//
	// If @icon_name is nil, no icon will be shown in the specified position.
	SetIconFromIconName(iconPos EntryIconPosition, iconName string)
	// SetIconFromPaintable sets the icon shown in the specified position using
	// a Paintable
	//
	// If @paintable is nil, no icon will be shown in the specified position.
	SetIconFromPaintable(iconPos EntryIconPosition, paintable gdk.Paintable)
	// SetIconSensitive sets the sensitivity for the specified icon.
	SetIconSensitive(iconPos EntryIconPosition, sensitive bool)
	// SetIconTooltipMarkup sets @tooltip as the contents of the tooltip for the
	// icon at the specified position. @tooltip is assumed to be marked up with
	// the [Pango text markup language][PangoMarkupFormat].
	//
	// Use nil for @tooltip to remove an existing tooltip.
	//
	// See also gtk_widget_set_tooltip_markup() and
	// gtk_entry_set_icon_tooltip_text().
	SetIconTooltipMarkup(iconPos EntryIconPosition, tooltip string)
	// SetIconTooltipText sets @tooltip as the contents of the tooltip for the
	// icon at the specified position.
	//
	// Use nil for @tooltip to remove an existing tooltip.
	//
	// See also gtk_widget_set_tooltip_text() and
	// gtk_entry_set_icon_tooltip_markup().
	//
	// If you unset the widget tooltip via gtk_widget_set_tooltip_text() or
	// gtk_widget_set_tooltip_markup(), this sets GtkWidget:has-tooltip to
	// false, which suppresses icon tooltips too. You can resolve this by then
	// calling gtk_widget_set_has_tooltip() to set GtkWidget:has-tooltip back to
	// true, or setting at least one non-empty tooltip on any icon achieves the
	// same result.
	SetIconTooltipText(iconPos EntryIconPosition, tooltip string)
	// SetInputHints sets the Entry:input-hints property, which allows input
	// methods to fine-tune their behaviour.
	SetInputHints(hints InputHints)
	// SetInputPurpose sets the Entry:input-purpose property which can be used
	// by on-screen keyboards and other input methods to adjust their behaviour.
	SetInputPurpose(purpose InputPurpose)
	// SetInvisibleChar sets the character to use in place of the actual text
	// when gtk_entry_set_visibility() has been called to set text visibility to
	// false. i.e. this is the character used in “password mode” to show the
	// user how many characters have been typed. By default, GTK picks the best
	// invisible char available in the current font. If you set the invisible
	// char to 0, then the user will get no feedback at all; there will be no
	// text on the screen as they type.
	SetInvisibleChar(ch uint32)
	// SetMaxLength sets the maximum allowed length of the contents of the
	// widget. If the current contents are longer than the given length, then
	// they will be truncated to fit.
	//
	// This is equivalent to getting @entry's EntryBuffer and calling
	// gtk_entry_buffer_set_max_length() on it.
	SetMaxLength(max int)
	// SetOverwriteMode sets whether the text is overwritten when typing in the
	// Entry.
	SetOverwriteMode(overwrite bool)
	// SetPlaceholderText sets text to be displayed in @entry when it is empty.
	// This can be used to give a visual hint of the expected contents of the
	// Entry.
	SetPlaceholderText(text string)
	// SetProgressFraction causes the entry’s progress indicator to “fill in”
	// the given fraction of the bar. The fraction should be between 0.0 and
	// 1.0, inclusive.
	SetProgressFraction(fraction float64)
	// SetProgressPulseStep sets the fraction of total entry width to move the
	// progress bouncing block for each call to gtk_entry_progress_pulse().
	SetProgressPulseStep(fraction float64)
	// SetTabs sets a TabArray; the tabstops in the array are applied to the
	// entry text.
	SetTabs(tabs *pango.TabArray)
	// SetVisibility sets whether the contents of the entry are visible or not.
	// When visibility is set to false, characters are displayed as the
	// invisible char, and will also appear that way when the text in the entry
	// widget is copied elsewhere.
	//
	// By default, GTK picks the best invisible character available in the
	// current font, but it can be changed with gtk_entry_set_invisible_char().
	//
	// Note that you probably want to set Entry:input-purpose to
	// GTK_INPUT_PURPOSE_PASSWORD or GTK_INPUT_PURPOSE_PIN to inform input
	// methods about the purpose of this entry, in addition to setting
	// visibility to false.
	SetVisibility(visible bool)
	// UnsetInvisibleChar unsets the invisible char previously set with
	// gtk_entry_set_invisible_char(). So that the default invisible char is
	// used again.
	UnsetInvisibleChar()
}

type entry struct {
	widget
}

// WrapEntry wraps a GObject to the right type. It is
// primarily used internally.
func WrapEntry(obj *externglib.Object) Entry {
	return entry{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}
}

func marshalEntry(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapEntry(obj), nil
}

// NewEntry constructs a class Entry.
func NewEntry() Entry {

	ret := C.gtk_entry_new()

	var ret0 Entry

	ret0 = WrapEntry(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewEntryWithBuffer constructs a class Entry.
func NewEntryWithBuffer(buffer EntryBuffer) Entry {
	var arg1 *C.GtkEntryBuffer

	arg1 = (*C.GtkEntryBuffer)(buffer.Native())

	ret := C.gtk_entry_new_with_buffer(arg1)

	var ret0 Entry

	ret0 = WrapEntry(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// ActivatesDefault retrieves the value set by
// gtk_entry_set_activates_default().
func (entry entry) ActivatesDefault() bool {
	var arg0 *C.GtkEntry

	arg0 = (*C.GtkEntry)(entry.Native())

	ret := C.gtk_entry_get_activates_default(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Alignment gets the value set by gtk_entry_set_alignment().
func (entry entry) Alignment() float32 {
	var arg0 *C.GtkEntry

	arg0 = (*C.GtkEntry)(entry.Native())

	ret := C.gtk_entry_get_alignment(arg0)

	var ret0 float32

	ret0 = float32(ret)

	return ret0
}

// Attributes gets the attribute list that was set on the entry using
// gtk_entry_set_attributes(), if any.
func (entry entry) Attributes() *pango.AttrList {
	var arg0 *C.GtkEntry

	arg0 = (*C.GtkEntry)(entry.Native())

	ret := C.gtk_entry_get_attributes(arg0)

	var ret0 *pango.AttrList

	ret0 = pango.WrapAttrList(ret)

	return ret0
}

// Buffer: get the EntryBuffer object which holds the text for this widget.
func (entry entry) Buffer() EntryBuffer {
	var arg0 *C.GtkEntry

	arg0 = (*C.GtkEntry)(entry.Native())

	ret := C.gtk_entry_get_buffer(arg0)

	var ret0 EntryBuffer

	ret0 = WrapEntryBuffer(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Completion returns the auxiliary completion object currently in use by
// @entry.
func (entry entry) Completion() EntryCompletion {
	var arg0 *C.GtkEntry

	arg0 = (*C.GtkEntry)(entry.Native())

	ret := C.gtk_entry_get_completion(arg0)

	var ret0 EntryCompletion

	ret0 = WrapEntryCompletion(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// CurrentIconDragSource returns the index of the icon which is the source
// of the current DND operation, or -1.
func (entry entry) CurrentIconDragSource() int {
	var arg0 *C.GtkEntry

	arg0 = (*C.GtkEntry)(entry.Native())

	ret := C.gtk_entry_get_current_icon_drag_source(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// ExtraMenu gets the menu model set with gtk_entry_set_extra_menu().
func (entry entry) ExtraMenu() gio.MenuModel {
	var arg0 *C.GtkEntry

	arg0 = (*C.GtkEntry)(entry.Native())

	ret := C.gtk_entry_get_extra_menu(arg0)

	var ret0 gio.MenuModel

	ret0 = gio.WrapMenuModel(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// HasFrame gets the value set by gtk_entry_set_has_frame().
func (entry entry) HasFrame() bool {
	var arg0 *C.GtkEntry

	arg0 = (*C.GtkEntry)(entry.Native())

	ret := C.gtk_entry_get_has_frame(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// IconActivatable returns whether the icon is activatable.
func (entry entry) IconActivatable(iconPos EntryIconPosition) bool {
	var arg0 *C.GtkEntry
	var arg1 C.GtkEntryIconPosition

	arg0 = (*C.GtkEntry)(entry.Native())
	arg1 = (C.GtkEntryIconPosition)(iconPos)

	ret := C.gtk_entry_get_icon_activatable(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// IconArea gets the area where entry’s icon at @icon_pos is drawn. This
// function is useful when drawing something to the entry in a draw
// callback.
//
// If the entry is not realized or has no icon at the given position,
// @icon_area is filled with zeros. Otherwise, @icon_area will be filled
// with the icon's allocation, relative to @entry's allocation.
func (entry entry) IconArea(iconPos EntryIconPosition) gdk.Rectangle {
	var arg0 *C.GtkEntry
	var arg1 C.GtkEntryIconPosition
	var arg2 *C.GdkRectangle // out

	arg0 = (*C.GtkEntry)(entry.Native())
	arg1 = (C.GtkEntryIconPosition)(iconPos)

	ret := C.gtk_entry_get_icon_area(arg0, arg1, &arg2)

	var ret0 *gdk.Rectangle

	ret0 = gdk.WrapRectangle(arg2)

	return ret0
}

// IconAtPos finds the icon at the given position and return its index. The
// position’s coordinates are relative to the @entry’s top left corner. If
// @x, @y doesn’t lie inside an icon, -1 is returned. This function is
// intended for use in a Widget::query-tooltip signal handler.
func (entry entry) IconAtPos(x int, y int) int {
	var arg0 *C.GtkEntry
	var arg1 C.int
	var arg2 C.int

	arg0 = (*C.GtkEntry)(entry.Native())
	arg1 = C.int(x)
	arg2 = C.int(y)

	ret := C.gtk_entry_get_icon_at_pos(arg0, arg1, arg2)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// IconGIcon retrieves the #GIcon used for the icon, or nil if there is no
// icon or if the icon was set by some other method (e.g., by paintable or
// icon name).
func (entry entry) IconGIcon(iconPos EntryIconPosition) gio.Icon {
	var arg0 *C.GtkEntry
	var arg1 C.GtkEntryIconPosition

	arg0 = (*C.GtkEntry)(entry.Native())
	arg1 = (C.GtkEntryIconPosition)(iconPos)

	ret := C.gtk_entry_get_icon_gicon(arg0, arg1)

	var ret0 gio.Icon

	return ret0
}

// IconName retrieves the icon name used for the icon, or nil if there is no
// icon or if the icon was set by some other method (e.g., by paintable or
// gicon).
func (entry entry) IconName(iconPos EntryIconPosition) string {
	var arg0 *C.GtkEntry
	var arg1 C.GtkEntryIconPosition

	arg0 = (*C.GtkEntry)(entry.Native())
	arg1 = (C.GtkEntryIconPosition)(iconPos)

	ret := C.gtk_entry_get_icon_name(arg0, arg1)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// IconPaintable retrieves the Paintable used for the icon.
//
// If no Paintable was used for the icon, nil is returned.
func (entry entry) IconPaintable(iconPos EntryIconPosition) gdk.Paintable {
	var arg0 *C.GtkEntry
	var arg1 C.GtkEntryIconPosition

	arg0 = (*C.GtkEntry)(entry.Native())
	arg1 = (C.GtkEntryIconPosition)(iconPos)

	ret := C.gtk_entry_get_icon_paintable(arg0, arg1)

	var ret0 gdk.Paintable

	return ret0
}

// IconSensitive returns whether the icon appears sensitive or insensitive.
func (entry entry) IconSensitive(iconPos EntryIconPosition) bool {
	var arg0 *C.GtkEntry
	var arg1 C.GtkEntryIconPosition

	arg0 = (*C.GtkEntry)(entry.Native())
	arg1 = (C.GtkEntryIconPosition)(iconPos)

	ret := C.gtk_entry_get_icon_sensitive(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// IconStorageType gets the type of representation being used by the icon to
// store image data. If the icon has no image data, the return value will be
// GTK_IMAGE_EMPTY.
func (entry entry) IconStorageType(iconPos EntryIconPosition) ImageType {
	var arg0 *C.GtkEntry
	var arg1 C.GtkEntryIconPosition

	arg0 = (*C.GtkEntry)(entry.Native())
	arg1 = (C.GtkEntryIconPosition)(iconPos)

	ret := C.gtk_entry_get_icon_storage_type(arg0, arg1)

	var ret0 ImageType

	ret0 = ImageType(ret)

	return ret0
}

// IconTooltipMarkup gets the contents of the tooltip on the icon at the
// specified position in @entry.
func (entry entry) IconTooltipMarkup(iconPos EntryIconPosition) string {
	var arg0 *C.GtkEntry
	var arg1 C.GtkEntryIconPosition

	arg0 = (*C.GtkEntry)(entry.Native())
	arg1 = (C.GtkEntryIconPosition)(iconPos)

	ret := C.gtk_entry_get_icon_tooltip_markup(arg0, arg1)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// IconTooltipText gets the contents of the tooltip on the icon at the
// specified position in @entry.
func (entry entry) IconTooltipText(iconPos EntryIconPosition) string {
	var arg0 *C.GtkEntry
	var arg1 C.GtkEntryIconPosition

	arg0 = (*C.GtkEntry)(entry.Native())
	arg1 = (C.GtkEntryIconPosition)(iconPos)

	ret := C.gtk_entry_get_icon_tooltip_text(arg0, arg1)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// InputHints gets the value of the Entry:input-hints property.
func (entry entry) InputHints() InputHints {
	var arg0 *C.GtkEntry

	arg0 = (*C.GtkEntry)(entry.Native())

	ret := C.gtk_entry_get_input_hints(arg0)

	var ret0 InputHints

	ret0 = InputHints(ret)

	return ret0
}

// InputPurpose gets the value of the Entry:input-purpose property.
func (entry entry) InputPurpose() InputPurpose {
	var arg0 *C.GtkEntry

	arg0 = (*C.GtkEntry)(entry.Native())

	ret := C.gtk_entry_get_input_purpose(arg0)

	var ret0 InputPurpose

	ret0 = InputPurpose(ret)

	return ret0
}

// InvisibleChar retrieves the character displayed in place of the real
// characters for entries with visibility set to false. See
// gtk_entry_set_invisible_char().
func (entry entry) InvisibleChar() uint32 {
	var arg0 *C.GtkEntry

	arg0 = (*C.GtkEntry)(entry.Native())

	ret := C.gtk_entry_get_invisible_char(arg0)

	var ret0 uint32

	ret0 = uint32(ret)

	return ret0
}

// MaxLength retrieves the maximum allowed length of the text in @entry. See
// gtk_entry_set_max_length().
//
// This is equivalent to getting @entry's EntryBuffer and calling
// gtk_entry_buffer_get_max_length() on it.
func (entry entry) MaxLength() int {
	var arg0 *C.GtkEntry

	arg0 = (*C.GtkEntry)(entry.Native())

	ret := C.gtk_entry_get_max_length(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// OverwriteMode gets the value set by gtk_entry_set_overwrite_mode().
func (entry entry) OverwriteMode() bool {
	var arg0 *C.GtkEntry

	arg0 = (*C.GtkEntry)(entry.Native())

	ret := C.gtk_entry_get_overwrite_mode(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// PlaceholderText retrieves the text that will be displayed when @entry is
// empty and unfocused
func (entry entry) PlaceholderText() string {
	var arg0 *C.GtkEntry

	arg0 = (*C.GtkEntry)(entry.Native())

	ret := C.gtk_entry_get_placeholder_text(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// ProgressFraction returns the current fraction of the task that’s been
// completed. See gtk_entry_set_progress_fraction().
func (entry entry) ProgressFraction() float64 {
	var arg0 *C.GtkEntry

	arg0 = (*C.GtkEntry)(entry.Native())

	ret := C.gtk_entry_get_progress_fraction(arg0)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// ProgressPulseStep retrieves the pulse step set with
// gtk_entry_set_progress_pulse_step().
func (entry entry) ProgressPulseStep() float64 {
	var arg0 *C.GtkEntry

	arg0 = (*C.GtkEntry)(entry.Native())

	ret := C.gtk_entry_get_progress_pulse_step(arg0)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// Tabs gets the tabstops that were set on the entry using
// gtk_entry_set_tabs(), if any.
func (entry entry) Tabs() *pango.TabArray {
	var arg0 *C.GtkEntry

	arg0 = (*C.GtkEntry)(entry.Native())

	ret := C.gtk_entry_get_tabs(arg0)

	var ret0 *pango.TabArray

	ret0 = pango.WrapTabArray(ret)

	return ret0
}

// TextLength retrieves the current length of the text in @entry.
//
// This is equivalent to getting @entry's EntryBuffer and calling
// gtk_entry_buffer_get_length() on it.
func (entry entry) TextLength() uint16 {
	var arg0 *C.GtkEntry

	arg0 = (*C.GtkEntry)(entry.Native())

	ret := C.gtk_entry_get_text_length(arg0)

	var ret0 uint16

	ret0 = uint16(ret)

	return ret0
}

// Visibility retrieves whether the text in @entry is visible. See
// gtk_entry_set_visibility().
func (entry entry) Visibility() bool {
	var arg0 *C.GtkEntry

	arg0 = (*C.GtkEntry)(entry.Native())

	ret := C.gtk_entry_get_visibility(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// GrabFocusWithoutSelecting causes @entry to have keyboard focus.
//
// It behaves like gtk_widget_grab_focus(), except that it doesn't select
// the contents of the entry. You only want to call this on some special
// entries which the user usually doesn't want to replace all text in, such
// as search-as-you-type entries.
func (entry entry) GrabFocusWithoutSelecting() bool {
	var arg0 *C.GtkEntry

	arg0 = (*C.GtkEntry)(entry.Native())

	ret := C.gtk_entry_grab_focus_without_selecting(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// ProgressPulse indicates that some progress is made, but you don’t know
// how much. Causes the entry’s progress indicator to enter “activity mode,”
// where a block bounces back and forth. Each call to
// gtk_entry_progress_pulse() causes the block to move by a little bit (the
// amount of movement per pulse is determined by
// gtk_entry_set_progress_pulse_step()).
func (entry entry) ProgressPulse() {
	var arg0 *C.GtkEntry

	arg0 = (*C.GtkEntry)(entry.Native())

	C.gtk_entry_progress_pulse(arg0)
}

// ResetImContext: reset the input method context of the entry if needed.
//
// This can be necessary in the case where modifying the buffer would
// confuse on-going input method behavior.
func (entry entry) ResetImContext() {
	var arg0 *C.GtkEntry

	arg0 = (*C.GtkEntry)(entry.Native())

	C.gtk_entry_reset_im_context(arg0)
}

// SetActivatesDefault: if @setting is true, pressing Enter in the @entry
// will activate the default widget for the window containing the entry.
// This usually means that the dialog box containing the entry will be
// closed, since the default widget is usually one of the dialog buttons.
func (entry entry) SetActivatesDefault(setting bool) {
	var arg0 *C.GtkEntry
	var arg1 C.gboolean

	arg0 = (*C.GtkEntry)(entry.Native())
	arg1 = gextras.Cbool(setting)

	C.gtk_entry_set_activates_default(arg0, arg1)
}

// SetAlignment sets the alignment for the contents of the entry. This
// controls the horizontal positioning of the contents when the displayed
// text is shorter than the width of the entry.
func (entry entry) SetAlignment(xalign float32) {
	var arg0 *C.GtkEntry
	var arg1 C.float

	arg0 = (*C.GtkEntry)(entry.Native())
	arg1 = C.float(xalign)

	C.gtk_entry_set_alignment(arg0, arg1)
}

// SetAttributes sets a AttrList; the attributes in the list are applied to
// the entry text.
func (entry entry) SetAttributes(attrs *pango.AttrList) {
	var arg0 *C.GtkEntry
	var arg1 *C.PangoAttrList

	arg0 = (*C.GtkEntry)(entry.Native())
	arg1 = (*C.PangoAttrList)(attrs.Native())

	C.gtk_entry_set_attributes(arg0, arg1)
}

// SetBuffer: set the EntryBuffer object which holds the text for this
// widget.
func (entry entry) SetBuffer(buffer EntryBuffer) {
	var arg0 *C.GtkEntry
	var arg1 *C.GtkEntryBuffer

	arg0 = (*C.GtkEntry)(entry.Native())
	arg1 = (*C.GtkEntryBuffer)(buffer.Native())

	C.gtk_entry_set_buffer(arg0, arg1)
}

// SetCompletion sets @completion to be the auxiliary completion object to
// use with @entry. All further configuration of the completion mechanism is
// done on @completion using the EntryCompletion API. Completion is disabled
// if @completion is set to nil.
func (entry entry) SetCompletion(completion EntryCompletion) {
	var arg0 *C.GtkEntry
	var arg1 *C.GtkEntryCompletion

	arg0 = (*C.GtkEntry)(entry.Native())
	arg1 = (*C.GtkEntryCompletion)(completion.Native())

	C.gtk_entry_set_completion(arg0, arg1)
}

// SetExtraMenu sets a menu model to add when constructing the context menu
// for @entry.
func (entry entry) SetExtraMenu(model gio.MenuModel) {
	var arg0 *C.GtkEntry
	var arg1 *C.GMenuModel

	arg0 = (*C.GtkEntry)(entry.Native())
	arg1 = (*C.GMenuModel)(model.Native())

	C.gtk_entry_set_extra_menu(arg0, arg1)
}

// SetHasFrame sets whether the entry has a beveled frame around it.
func (entry entry) SetHasFrame(setting bool) {
	var arg0 *C.GtkEntry
	var arg1 C.gboolean

	arg0 = (*C.GtkEntry)(entry.Native())
	arg1 = gextras.Cbool(setting)

	C.gtk_entry_set_has_frame(arg0, arg1)
}

// SetIconActivatable sets whether the icon is activatable.
func (entry entry) SetIconActivatable(iconPos EntryIconPosition, activatable bool) {
	var arg0 *C.GtkEntry
	var arg1 C.GtkEntryIconPosition
	var arg2 C.gboolean

	arg0 = (*C.GtkEntry)(entry.Native())
	arg1 = (C.GtkEntryIconPosition)(iconPos)
	arg2 = gextras.Cbool(activatable)

	C.gtk_entry_set_icon_activatable(arg0, arg1, arg2)
}

// SetIconDragSource sets up the icon at the given position so that GTK will
// start a drag operation when the user clicks and drags the icon.
func (entry entry) SetIconDragSource(iconPos EntryIconPosition, provider gdk.ContentProvider, actions gdk.DragAction) {
	var arg0 *C.GtkEntry
	var arg1 C.GtkEntryIconPosition
	var arg2 *C.GdkContentProvider
	var arg3 C.GdkDragAction

	arg0 = (*C.GtkEntry)(entry.Native())
	arg1 = (C.GtkEntryIconPosition)(iconPos)
	arg2 = (*C.GdkContentProvider)(provider.Native())
	arg3 = (C.GdkDragAction)(actions)

	C.gtk_entry_set_icon_drag_source(arg0, arg1, arg2, arg3)
}

// SetIconFromGIcon sets the icon shown in the entry at the specified
// position from the current icon theme. If the icon isn’t known, a “broken
// image” icon will be displayed instead.
//
// If @icon is nil, no icon will be shown in the specified position.
func (entry entry) SetIconFromGIcon(iconPos EntryIconPosition, icon gio.Icon) {
	var arg0 *C.GtkEntry
	var arg1 C.GtkEntryIconPosition
	var arg2 *C.GIcon

	arg0 = (*C.GtkEntry)(entry.Native())
	arg1 = (C.GtkEntryIconPosition)(iconPos)

	C.gtk_entry_set_icon_from_gicon(arg0, arg1, arg2)
}

// SetIconFromIconName sets the icon shown in the entry at the specified
// position from the current icon theme.
//
// If the icon name isn’t known, a “broken image” icon will be displayed
// instead.
//
// If @icon_name is nil, no icon will be shown in the specified position.
func (entry entry) SetIconFromIconName(iconPos EntryIconPosition, iconName string) {
	var arg0 *C.GtkEntry
	var arg1 C.GtkEntryIconPosition
	var arg2 *C.char

	arg0 = (*C.GtkEntry)(entry.Native())
	arg1 = (C.GtkEntryIconPosition)(iconPos)
	arg2 = (*C.gchar)(C.CString(iconName))
	defer C.free(unsafe.Pointer(arg2))

	C.gtk_entry_set_icon_from_icon_name(arg0, arg1, arg2)
}

// SetIconFromPaintable sets the icon shown in the specified position using
// a Paintable
//
// If @paintable is nil, no icon will be shown in the specified position.
func (entry entry) SetIconFromPaintable(iconPos EntryIconPosition, paintable gdk.Paintable) {
	var arg0 *C.GtkEntry
	var arg1 C.GtkEntryIconPosition
	var arg2 *C.GdkPaintable

	arg0 = (*C.GtkEntry)(entry.Native())
	arg1 = (C.GtkEntryIconPosition)(iconPos)

	C.gtk_entry_set_icon_from_paintable(arg0, arg1, arg2)
}

// SetIconSensitive sets the sensitivity for the specified icon.
func (entry entry) SetIconSensitive(iconPos EntryIconPosition, sensitive bool) {
	var arg0 *C.GtkEntry
	var arg1 C.GtkEntryIconPosition
	var arg2 C.gboolean

	arg0 = (*C.GtkEntry)(entry.Native())
	arg1 = (C.GtkEntryIconPosition)(iconPos)
	arg2 = gextras.Cbool(sensitive)

	C.gtk_entry_set_icon_sensitive(arg0, arg1, arg2)
}

// SetIconTooltipMarkup sets @tooltip as the contents of the tooltip for the
// icon at the specified position. @tooltip is assumed to be marked up with
// the [Pango text markup language][PangoMarkupFormat].
//
// Use nil for @tooltip to remove an existing tooltip.
//
// See also gtk_widget_set_tooltip_markup() and
// gtk_entry_set_icon_tooltip_text().
func (entry entry) SetIconTooltipMarkup(iconPos EntryIconPosition, tooltip string) {
	var arg0 *C.GtkEntry
	var arg1 C.GtkEntryIconPosition
	var arg2 *C.char

	arg0 = (*C.GtkEntry)(entry.Native())
	arg1 = (C.GtkEntryIconPosition)(iconPos)
	arg2 = (*C.gchar)(C.CString(tooltip))
	defer C.free(unsafe.Pointer(arg2))

	C.gtk_entry_set_icon_tooltip_markup(arg0, arg1, arg2)
}

// SetIconTooltipText sets @tooltip as the contents of the tooltip for the
// icon at the specified position.
//
// Use nil for @tooltip to remove an existing tooltip.
//
// See also gtk_widget_set_tooltip_text() and
// gtk_entry_set_icon_tooltip_markup().
//
// If you unset the widget tooltip via gtk_widget_set_tooltip_text() or
// gtk_widget_set_tooltip_markup(), this sets GtkWidget:has-tooltip to
// false, which suppresses icon tooltips too. You can resolve this by then
// calling gtk_widget_set_has_tooltip() to set GtkWidget:has-tooltip back to
// true, or setting at least one non-empty tooltip on any icon achieves the
// same result.
func (entry entry) SetIconTooltipText(iconPos EntryIconPosition, tooltip string) {
	var arg0 *C.GtkEntry
	var arg1 C.GtkEntryIconPosition
	var arg2 *C.char

	arg0 = (*C.GtkEntry)(entry.Native())
	arg1 = (C.GtkEntryIconPosition)(iconPos)
	arg2 = (*C.gchar)(C.CString(tooltip))
	defer C.free(unsafe.Pointer(arg2))

	C.gtk_entry_set_icon_tooltip_text(arg0, arg1, arg2)
}

// SetInputHints sets the Entry:input-hints property, which allows input
// methods to fine-tune their behaviour.
func (entry entry) SetInputHints(hints InputHints) {
	var arg0 *C.GtkEntry
	var arg1 C.GtkInputHints

	arg0 = (*C.GtkEntry)(entry.Native())
	arg1 = (C.GtkInputHints)(hints)

	C.gtk_entry_set_input_hints(arg0, arg1)
}

// SetInputPurpose sets the Entry:input-purpose property which can be used
// by on-screen keyboards and other input methods to adjust their behaviour.
func (entry entry) SetInputPurpose(purpose InputPurpose) {
	var arg0 *C.GtkEntry
	var arg1 C.GtkInputPurpose

	arg0 = (*C.GtkEntry)(entry.Native())
	arg1 = (C.GtkInputPurpose)(purpose)

	C.gtk_entry_set_input_purpose(arg0, arg1)
}

// SetInvisibleChar sets the character to use in place of the actual text
// when gtk_entry_set_visibility() has been called to set text visibility to
// false. i.e. this is the character used in “password mode” to show the
// user how many characters have been typed. By default, GTK picks the best
// invisible char available in the current font. If you set the invisible
// char to 0, then the user will get no feedback at all; there will be no
// text on the screen as they type.
func (entry entry) SetInvisibleChar(ch uint32) {
	var arg0 *C.GtkEntry
	var arg1 C.gunichar

	arg0 = (*C.GtkEntry)(entry.Native())
	arg1 = C.gunichar(ch)

	C.gtk_entry_set_invisible_char(arg0, arg1)
}

// SetMaxLength sets the maximum allowed length of the contents of the
// widget. If the current contents are longer than the given length, then
// they will be truncated to fit.
//
// This is equivalent to getting @entry's EntryBuffer and calling
// gtk_entry_buffer_set_max_length() on it.
func (entry entry) SetMaxLength(max int) {
	var arg0 *C.GtkEntry
	var arg1 C.int

	arg0 = (*C.GtkEntry)(entry.Native())
	arg1 = C.int(max)

	C.gtk_entry_set_max_length(arg0, arg1)
}

// SetOverwriteMode sets whether the text is overwritten when typing in the
// Entry.
func (entry entry) SetOverwriteMode(overwrite bool) {
	var arg0 *C.GtkEntry
	var arg1 C.gboolean

	arg0 = (*C.GtkEntry)(entry.Native())
	arg1 = gextras.Cbool(overwrite)

	C.gtk_entry_set_overwrite_mode(arg0, arg1)
}

// SetPlaceholderText sets text to be displayed in @entry when it is empty.
// This can be used to give a visual hint of the expected contents of the
// Entry.
func (entry entry) SetPlaceholderText(text string) {
	var arg0 *C.GtkEntry
	var arg1 *C.char

	arg0 = (*C.GtkEntry)(entry.Native())
	arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_entry_set_placeholder_text(arg0, arg1)
}

// SetProgressFraction causes the entry’s progress indicator to “fill in”
// the given fraction of the bar. The fraction should be between 0.0 and
// 1.0, inclusive.
func (entry entry) SetProgressFraction(fraction float64) {
	var arg0 *C.GtkEntry
	var arg1 C.double

	arg0 = (*C.GtkEntry)(entry.Native())
	arg1 = C.double(fraction)

	C.gtk_entry_set_progress_fraction(arg0, arg1)
}

// SetProgressPulseStep sets the fraction of total entry width to move the
// progress bouncing block for each call to gtk_entry_progress_pulse().
func (entry entry) SetProgressPulseStep(fraction float64) {
	var arg0 *C.GtkEntry
	var arg1 C.double

	arg0 = (*C.GtkEntry)(entry.Native())
	arg1 = C.double(fraction)

	C.gtk_entry_set_progress_pulse_step(arg0, arg1)
}

// SetTabs sets a TabArray; the tabstops in the array are applied to the
// entry text.
func (entry entry) SetTabs(tabs *pango.TabArray) {
	var arg0 *C.GtkEntry
	var arg1 *C.PangoTabArray

	arg0 = (*C.GtkEntry)(entry.Native())
	arg1 = (*C.PangoTabArray)(tabs.Native())

	C.gtk_entry_set_tabs(arg0, arg1)
}

// SetVisibility sets whether the contents of the entry are visible or not.
// When visibility is set to false, characters are displayed as the
// invisible char, and will also appear that way when the text in the entry
// widget is copied elsewhere.
//
// By default, GTK picks the best invisible character available in the
// current font, but it can be changed with gtk_entry_set_invisible_char().
//
// Note that you probably want to set Entry:input-purpose to
// GTK_INPUT_PURPOSE_PASSWORD or GTK_INPUT_PURPOSE_PIN to inform input
// methods about the purpose of this entry, in addition to setting
// visibility to false.
func (entry entry) SetVisibility(visible bool) {
	var arg0 *C.GtkEntry
	var arg1 C.gboolean

	arg0 = (*C.GtkEntry)(entry.Native())
	arg1 = gextras.Cbool(visible)

	C.gtk_entry_set_visibility(arg0, arg1)
}

// UnsetInvisibleChar unsets the invisible char previously set with
// gtk_entry_set_invisible_char(). So that the default invisible char is
// used again.
func (entry entry) UnsetInvisibleChar() {
	var arg0 *C.GtkEntry

	arg0 = (*C.GtkEntry)(entry.Native())

	C.gtk_entry_unset_invisible_char(arg0)
}

// EntryBuffer: the EntryBuffer class contains the actual text displayed in a
// Entry widget.
//
// A single EntryBuffer object can be shared by multiple Entry widgets which
// will then share the same text content, but not the cursor position,
// visibility attributes, icon etc.
//
// EntryBuffer may be derived from. Such a derived class might allow text to be
// stored in an alternate location, such as non-pageable memory, useful in the
// case of important passwords. Or a derived class could integrate with an
// application’s concept of undo/redo.
type EntryBuffer interface {
	gextras.Objector

	// DeleteText deletes a sequence of characters from the buffer. @n_chars
	// characters are deleted starting at @position. If @n_chars is negative,
	// then all characters until the end of the text are deleted.
	//
	// If @position or @n_chars are out of bounds, then they are coerced to sane
	// values.
	//
	// Note that the positions are specified in characters, not bytes.
	DeleteText(position uint, nChars int) uint
	// EmitDeletedText: used when subclassing EntryBuffer
	EmitDeletedText(position uint, nChars uint)
	// EmitInsertedText: used when subclassing EntryBuffer
	EmitInsertedText(position uint, chars string, nChars uint)
	// Bytes retrieves the length in bytes of the buffer. See
	// gtk_entry_buffer_get_length().
	Bytes() uint
	// Length retrieves the length in characters of the buffer.
	Length() uint
	// MaxLength retrieves the maximum allowed length of the text in @buffer.
	// See gtk_entry_buffer_set_max_length().
	MaxLength() int
	// Text retrieves the contents of the buffer.
	//
	// The memory pointer returned by this call will not change unless this
	// object emits a signal, or is finalized.
	Text() string
	// InsertText inserts @n_chars characters of @chars into the contents of the
	// buffer, at position @position.
	//
	// If @n_chars is negative, then characters from chars will be inserted
	// until a null-terminator is found. If @position or @n_chars are out of
	// bounds, or the maximum buffer text length is exceeded, then they are
	// coerced to sane values.
	//
	// Note that the position and length are in characters, not in bytes.
	InsertText(position uint, chars string, nChars int) uint
	// SetMaxLength sets the maximum allowed length of the contents of the
	// buffer. If the current contents are longer than the given length, then
	// they will be truncated to fit.
	SetMaxLength(maxLength int)
	// SetText sets the text in the buffer.
	//
	// This is roughly equivalent to calling gtk_entry_buffer_delete_text() and
	// gtk_entry_buffer_insert_text().
	//
	// Note that @n_chars is in characters, not in bytes.
	SetText(chars string, nChars int)
}

type entryBuffer struct {
	*externglib.Object
}

// WrapEntryBuffer wraps a GObject to the right type. It is
// primarily used internally.
func WrapEntryBuffer(obj *externglib.Object) EntryBuffer {
	return entryBuffer{*externglib.Object{obj}}
}

func marshalEntryBuffer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapEntryBuffer(obj), nil
}

// NewEntryBuffer constructs a class EntryBuffer.
func NewEntryBuffer(initialChars string, nInitialChars int) EntryBuffer {
	var arg1 *C.char
	var arg2 C.int

	arg1 = (*C.gchar)(C.CString(initialChars))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.int(nInitialChars)

	ret := C.gtk_entry_buffer_new(arg1, arg2)

	var ret0 EntryBuffer

	ret0 = WrapEntryBuffer(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// DeleteText deletes a sequence of characters from the buffer. @n_chars
// characters are deleted starting at @position. If @n_chars is negative,
// then all characters until the end of the text are deleted.
//
// If @position or @n_chars are out of bounds, then they are coerced to sane
// values.
//
// Note that the positions are specified in characters, not bytes.
func (buffer entryBuffer) DeleteText(position uint, nChars int) uint {
	var arg0 *C.GtkEntryBuffer
	var arg1 C.guint
	var arg2 C.int

	arg0 = (*C.GtkEntryBuffer)(buffer.Native())
	arg1 = C.guint(position)
	arg2 = C.int(nChars)

	ret := C.gtk_entry_buffer_delete_text(arg0, arg1, arg2)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// EmitDeletedText: used when subclassing EntryBuffer
func (buffer entryBuffer) EmitDeletedText(position uint, nChars uint) {
	var arg0 *C.GtkEntryBuffer
	var arg1 C.guint
	var arg2 C.guint

	arg0 = (*C.GtkEntryBuffer)(buffer.Native())
	arg1 = C.guint(position)
	arg2 = C.guint(nChars)

	C.gtk_entry_buffer_emit_deleted_text(arg0, arg1, arg2)
}

// EmitInsertedText: used when subclassing EntryBuffer
func (buffer entryBuffer) EmitInsertedText(position uint, chars string, nChars uint) {
	var arg0 *C.GtkEntryBuffer
	var arg1 C.guint
	var arg2 *C.char
	var arg3 C.guint

	arg0 = (*C.GtkEntryBuffer)(buffer.Native())
	arg1 = C.guint(position)
	arg2 = (*C.gchar)(C.CString(chars))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = C.guint(nChars)

	C.gtk_entry_buffer_emit_inserted_text(arg0, arg1, arg2, arg3)
}

// Bytes retrieves the length in bytes of the buffer. See
// gtk_entry_buffer_get_length().
func (buffer entryBuffer) Bytes() uint {
	var arg0 *C.GtkEntryBuffer

	arg0 = (*C.GtkEntryBuffer)(buffer.Native())

	ret := C.gtk_entry_buffer_get_bytes(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// Length retrieves the length in characters of the buffer.
func (buffer entryBuffer) Length() uint {
	var arg0 *C.GtkEntryBuffer

	arg0 = (*C.GtkEntryBuffer)(buffer.Native())

	ret := C.gtk_entry_buffer_get_length(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// MaxLength retrieves the maximum allowed length of the text in @buffer.
// See gtk_entry_buffer_set_max_length().
func (buffer entryBuffer) MaxLength() int {
	var arg0 *C.GtkEntryBuffer

	arg0 = (*C.GtkEntryBuffer)(buffer.Native())

	ret := C.gtk_entry_buffer_get_max_length(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Text retrieves the contents of the buffer.
//
// The memory pointer returned by this call will not change unless this
// object emits a signal, or is finalized.
func (buffer entryBuffer) Text() string {
	var arg0 *C.GtkEntryBuffer

	arg0 = (*C.GtkEntryBuffer)(buffer.Native())

	ret := C.gtk_entry_buffer_get_text(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// InsertText inserts @n_chars characters of @chars into the contents of the
// buffer, at position @position.
//
// If @n_chars is negative, then characters from chars will be inserted
// until a null-terminator is found. If @position or @n_chars are out of
// bounds, or the maximum buffer text length is exceeded, then they are
// coerced to sane values.
//
// Note that the position and length are in characters, not in bytes.
func (buffer entryBuffer) InsertText(position uint, chars string, nChars int) uint {
	var arg0 *C.GtkEntryBuffer
	var arg1 C.guint
	var arg2 *C.char
	var arg3 C.int

	arg0 = (*C.GtkEntryBuffer)(buffer.Native())
	arg1 = C.guint(position)
	arg2 = (*C.gchar)(C.CString(chars))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = C.int(nChars)

	ret := C.gtk_entry_buffer_insert_text(arg0, arg1, arg2, arg3)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// SetMaxLength sets the maximum allowed length of the contents of the
// buffer. If the current contents are longer than the given length, then
// they will be truncated to fit.
func (buffer entryBuffer) SetMaxLength(maxLength int) {
	var arg0 *C.GtkEntryBuffer
	var arg1 C.int

	arg0 = (*C.GtkEntryBuffer)(buffer.Native())
	arg1 = C.int(maxLength)

	C.gtk_entry_buffer_set_max_length(arg0, arg1)
}

// SetText sets the text in the buffer.
//
// This is roughly equivalent to calling gtk_entry_buffer_delete_text() and
// gtk_entry_buffer_insert_text().
//
// Note that @n_chars is in characters, not in bytes.
func (buffer entryBuffer) SetText(chars string, nChars int) {
	var arg0 *C.GtkEntryBuffer
	var arg1 *C.char
	var arg2 C.int

	arg0 = (*C.GtkEntryBuffer)(buffer.Native())
	arg1 = (*C.gchar)(C.CString(chars))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.int(nChars)

	C.gtk_entry_buffer_set_text(arg0, arg1, arg2)
}

// EntryCompletion is an auxiliary object to be used in conjunction with Entry
// to provide the completion functionality. It implements the CellLayout
// interface, to allow the user to add extra cells to the TreeView with
// completion matches.
//
// “Completion functionality” means that when the user modifies the text in the
// entry, EntryCompletion checks which rows in the model match the current
// content of the entry, and displays a list of matches. By default, the
// matching is done by comparing the entry text case-insensitively against the
// text column of the model (see gtk_entry_completion_set_text_column()), but
// this can be overridden with a custom match function (see
// gtk_entry_completion_set_match_func()).
//
// When the user selects a completion, the content of the entry is updated. By
// default, the content of the entry is replaced by the text column of the
// model, but this can be overridden by connecting to the
// EntryCompletion::match-selected signal and updating the entry in the signal
// handler. Note that you should return true from the signal handler to suppress
// the default behaviour.
//
// To add completion functionality to an entry, use gtk_entry_set_completion().
//
// GtkEntryCompletion uses a TreeModelFilter model to represent the subset of
// the entire model that is currently matching. While the GtkEntryCompletion
// signals EntryCompletion::match-selected and EntryCompletion::cursor-on-match
// take the original model and an iter pointing to that model as arguments,
// other callbacks and signals (such as CellLayoutDataFuncs or
// CellArea::apply-attributes) will generally take the filter model as argument.
// As long as you are only calling gtk_tree_model_get(), this will make no
// difference to you. If for some reason, you need the original model, use
// gtk_tree_model_filter_get_model(). Don’t forget to use
// gtk_tree_model_filter_convert_iter_to_child_iter() to obtain a matching iter.
type EntryCompletion interface {
	gextras.Objector

	// Complete requests a completion operation, or in other words a refiltering
	// of the current list with completions, using the current key. The
	// completion list view will be updated accordingly.
	Complete()
	// ComputePrefix computes the common prefix that is shared by all rows in
	// @completion that start with @key. If no row matches @key, nil will be
	// returned. Note that a text column must have been set for this function to
	// work, see gtk_entry_completion_set_text_column() for details.
	ComputePrefix(key string) string
	// CompletionPrefix: get the original text entered by the user that
	// triggered the completion or nil if there’s no completion ongoing.
	CompletionPrefix() string
	// Entry gets the entry @completion has been attached to.
	Entry() Widget
	// InlineCompletion returns whether the common prefix of the possible
	// completions should be automatically inserted in the entry.
	InlineCompletion() bool
	// InlineSelection returns true if inline-selection mode is turned on.
	InlineSelection() bool
	// MinimumKeyLength returns the minimum key length as set for @completion.
	MinimumKeyLength() int
	// Model returns the model the EntryCompletion is using as data source.
	// Returns nil if the model is unset.
	Model() TreeModel
	// PopupCompletion returns whether the completions should be presented in a
	// popup window.
	PopupCompletion() bool
	// PopupSetWidth returns whether the completion popup window will be resized
	// to the width of the entry.
	PopupSetWidth() bool
	// PopupSingleMatch returns whether the completion popup window will appear
	// even if there is only a single match.
	PopupSingleMatch() bool
	// TextColumn returns the column in the model of @completion to get strings
	// from.
	TextColumn() int
	// InsertPrefix requests a prefix insertion.
	InsertPrefix()
	// SetInlineCompletion sets whether the common prefix of the possible
	// completions should be automatically inserted in the entry.
	SetInlineCompletion(inlineCompletion bool)
	// SetInlineSelection sets whether it is possible to cycle through the
	// possible completions inside the entry.
	SetInlineSelection(inlineSelection bool)
	// SetMatchFunc sets the match function for @completion to be @func. The
	// match function is used to determine if a row should or should not be in
	// the completion list.
	SetMatchFunc(_func EntryCompletionMatchFunc)
	// SetMinimumKeyLength requires the length of the search key for @completion
	// to be at least @length. This is useful for long lists, where completing
	// using a small key takes a lot of time and will come up with meaningless
	// results anyway (ie, a too large dataset).
	SetMinimumKeyLength(length int)
	// SetModel sets the model for a EntryCompletion. If @completion already has
	// a model set, it will remove it before setting the new model. If model is
	// nil, then it will unset the model.
	SetModel(model TreeModel)
	// SetPopupCompletion sets whether the completions should be presented in a
	// popup window.
	SetPopupCompletion(popupCompletion bool)
	// SetPopupSetWidth sets whether the completion popup window will be resized
	// to be the same width as the entry.
	SetPopupSetWidth(popupSetWidth bool)
	// SetPopupSingleMatch sets whether the completion popup window will appear
	// even if there is only a single match. You may want to set this to false
	// if you are using [inline
	// completion][GtkEntryCompletion--inline-completion].
	SetPopupSingleMatch(popupSingleMatch bool)
	// SetTextColumn: convenience function for setting up the most used case of
	// this code: a completion list with just strings. This function will set up
	// @completion to have a list displaying all (and just) strings in the
	// completion list, and to get those strings from @column in the model of
	// @completion.
	//
	// This functions creates and adds a CellRendererText for the selected
	// column. If you need to set the text column, but don't want the cell
	// renderer, use g_object_set() to set the EntryCompletion:text-column
	// property directly.
	SetTextColumn(column int)
}

type entryCompletion struct {
	*externglib.Object
}

// WrapEntryCompletion wraps a GObject to the right type. It is
// primarily used internally.
func WrapEntryCompletion(obj *externglib.Object) EntryCompletion {
	return entryCompletion{*externglib.Object{obj}}
}

func marshalEntryCompletion(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapEntryCompletion(obj), nil
}

// NewEntryCompletion constructs a class EntryCompletion.
func NewEntryCompletion() EntryCompletion {

	ret := C.gtk_entry_completion_new()

	var ret0 EntryCompletion

	ret0 = WrapEntryCompletion(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewEntryCompletionWithArea constructs a class EntryCompletion.
func NewEntryCompletionWithArea(area CellArea) EntryCompletion {
	var arg1 *C.GtkCellArea

	arg1 = (*C.GtkCellArea)(area.Native())

	ret := C.gtk_entry_completion_new_with_area(arg1)

	var ret0 EntryCompletion

	ret0 = WrapEntryCompletion(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Complete requests a completion operation, or in other words a refiltering
// of the current list with completions, using the current key. The
// completion list view will be updated accordingly.
func (completion entryCompletion) Complete() {
	var arg0 *C.GtkEntryCompletion

	arg0 = (*C.GtkEntryCompletion)(completion.Native())

	C.gtk_entry_completion_complete(arg0)
}

// ComputePrefix computes the common prefix that is shared by all rows in
// @completion that start with @key. If no row matches @key, nil will be
// returned. Note that a text column must have been set for this function to
// work, see gtk_entry_completion_set_text_column() for details.
func (completion entryCompletion) ComputePrefix(key string) string {
	var arg0 *C.GtkEntryCompletion
	var arg1 *C.char

	arg0 = (*C.GtkEntryCompletion)(completion.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_entry_completion_compute_prefix(arg0, arg1)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// CompletionPrefix: get the original text entered by the user that
// triggered the completion or nil if there’s no completion ongoing.
func (completion entryCompletion) CompletionPrefix() string {
	var arg0 *C.GtkEntryCompletion

	arg0 = (*C.GtkEntryCompletion)(completion.Native())

	ret := C.gtk_entry_completion_get_completion_prefix(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Entry gets the entry @completion has been attached to.
func (completion entryCompletion) Entry() Widget {
	var arg0 *C.GtkEntryCompletion

	arg0 = (*C.GtkEntryCompletion)(completion.Native())

	ret := C.gtk_entry_completion_get_entry(arg0)

	var ret0 Widget

	ret0 = WrapWidget(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// InlineCompletion returns whether the common prefix of the possible
// completions should be automatically inserted in the entry.
func (completion entryCompletion) InlineCompletion() bool {
	var arg0 *C.GtkEntryCompletion

	arg0 = (*C.GtkEntryCompletion)(completion.Native())

	ret := C.gtk_entry_completion_get_inline_completion(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// InlineSelection returns true if inline-selection mode is turned on.
func (completion entryCompletion) InlineSelection() bool {
	var arg0 *C.GtkEntryCompletion

	arg0 = (*C.GtkEntryCompletion)(completion.Native())

	ret := C.gtk_entry_completion_get_inline_selection(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// MinimumKeyLength returns the minimum key length as set for @completion.
func (completion entryCompletion) MinimumKeyLength() int {
	var arg0 *C.GtkEntryCompletion

	arg0 = (*C.GtkEntryCompletion)(completion.Native())

	ret := C.gtk_entry_completion_get_minimum_key_length(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Model returns the model the EntryCompletion is using as data source.
// Returns nil if the model is unset.
func (completion entryCompletion) Model() TreeModel {
	var arg0 *C.GtkEntryCompletion

	arg0 = (*C.GtkEntryCompletion)(completion.Native())

	ret := C.gtk_entry_completion_get_model(arg0)

	var ret0 TreeModel

	return ret0
}

// PopupCompletion returns whether the completions should be presented in a
// popup window.
func (completion entryCompletion) PopupCompletion() bool {
	var arg0 *C.GtkEntryCompletion

	arg0 = (*C.GtkEntryCompletion)(completion.Native())

	ret := C.gtk_entry_completion_get_popup_completion(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// PopupSetWidth returns whether the completion popup window will be resized
// to the width of the entry.
func (completion entryCompletion) PopupSetWidth() bool {
	var arg0 *C.GtkEntryCompletion

	arg0 = (*C.GtkEntryCompletion)(completion.Native())

	ret := C.gtk_entry_completion_get_popup_set_width(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// PopupSingleMatch returns whether the completion popup window will appear
// even if there is only a single match.
func (completion entryCompletion) PopupSingleMatch() bool {
	var arg0 *C.GtkEntryCompletion

	arg0 = (*C.GtkEntryCompletion)(completion.Native())

	ret := C.gtk_entry_completion_get_popup_single_match(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// TextColumn returns the column in the model of @completion to get strings
// from.
func (completion entryCompletion) TextColumn() int {
	var arg0 *C.GtkEntryCompletion

	arg0 = (*C.GtkEntryCompletion)(completion.Native())

	ret := C.gtk_entry_completion_get_text_column(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// InsertPrefix requests a prefix insertion.
func (completion entryCompletion) InsertPrefix() {
	var arg0 *C.GtkEntryCompletion

	arg0 = (*C.GtkEntryCompletion)(completion.Native())

	C.gtk_entry_completion_insert_prefix(arg0)
}

// SetInlineCompletion sets whether the common prefix of the possible
// completions should be automatically inserted in the entry.
func (completion entryCompletion) SetInlineCompletion(inlineCompletion bool) {
	var arg0 *C.GtkEntryCompletion
	var arg1 C.gboolean

	arg0 = (*C.GtkEntryCompletion)(completion.Native())
	arg1 = gextras.Cbool(inlineCompletion)

	C.gtk_entry_completion_set_inline_completion(arg0, arg1)
}

// SetInlineSelection sets whether it is possible to cycle through the
// possible completions inside the entry.
func (completion entryCompletion) SetInlineSelection(inlineSelection bool) {
	var arg0 *C.GtkEntryCompletion
	var arg1 C.gboolean

	arg0 = (*C.GtkEntryCompletion)(completion.Native())
	arg1 = gextras.Cbool(inlineSelection)

	C.gtk_entry_completion_set_inline_selection(arg0, arg1)
}

// SetMatchFunc sets the match function for @completion to be @func. The
// match function is used to determine if a row should or should not be in
// the completion list.
func (completion entryCompletion) SetMatchFunc(_func EntryCompletionMatchFunc) {
	var arg0 *C.GtkEntryCompletion
	var arg1 C.GtkEntryCompletionMatchFunc
	arg2 := C.gpointer(box.Assign(funcData))

	arg0 = (*C.GtkEntryCompletion)(completion.Native())
	arg1 = (*[0]byte)(C.gotk4_EntryCompletionMatchFunc)

	C.gtk_entry_completion_set_match_func(arg0, arg1, (*[0]byte)(C.callbackDelete))
}

// SetMinimumKeyLength requires the length of the search key for @completion
// to be at least @length. This is useful for long lists, where completing
// using a small key takes a lot of time and will come up with meaningless
// results anyway (ie, a too large dataset).
func (completion entryCompletion) SetMinimumKeyLength(length int) {
	var arg0 *C.GtkEntryCompletion
	var arg1 C.int

	arg0 = (*C.GtkEntryCompletion)(completion.Native())
	arg1 = C.int(length)

	C.gtk_entry_completion_set_minimum_key_length(arg0, arg1)
}

// SetModel sets the model for a EntryCompletion. If @completion already has
// a model set, it will remove it before setting the new model. If model is
// nil, then it will unset the model.
func (completion entryCompletion) SetModel(model TreeModel) {
	var arg0 *C.GtkEntryCompletion
	var arg1 *C.GtkTreeModel

	arg0 = (*C.GtkEntryCompletion)(completion.Native())

	C.gtk_entry_completion_set_model(arg0, arg1)
}

// SetPopupCompletion sets whether the completions should be presented in a
// popup window.
func (completion entryCompletion) SetPopupCompletion(popupCompletion bool) {
	var arg0 *C.GtkEntryCompletion
	var arg1 C.gboolean

	arg0 = (*C.GtkEntryCompletion)(completion.Native())
	arg1 = gextras.Cbool(popupCompletion)

	C.gtk_entry_completion_set_popup_completion(arg0, arg1)
}

// SetPopupSetWidth sets whether the completion popup window will be resized
// to be the same width as the entry.
func (completion entryCompletion) SetPopupSetWidth(popupSetWidth bool) {
	var arg0 *C.GtkEntryCompletion
	var arg1 C.gboolean

	arg0 = (*C.GtkEntryCompletion)(completion.Native())
	arg1 = gextras.Cbool(popupSetWidth)

	C.gtk_entry_completion_set_popup_set_width(arg0, arg1)
}

// SetPopupSingleMatch sets whether the completion popup window will appear
// even if there is only a single match. You may want to set this to false
// if you are using [inline
// completion][GtkEntryCompletion--inline-completion].
func (completion entryCompletion) SetPopupSingleMatch(popupSingleMatch bool) {
	var arg0 *C.GtkEntryCompletion
	var arg1 C.gboolean

	arg0 = (*C.GtkEntryCompletion)(completion.Native())
	arg1 = gextras.Cbool(popupSingleMatch)

	C.gtk_entry_completion_set_popup_single_match(arg0, arg1)
}

// SetTextColumn: convenience function for setting up the most used case of
// this code: a completion list with just strings. This function will set up
// @completion to have a list displaying all (and just) strings in the
// completion list, and to get those strings from @column in the model of
// @completion.
//
// This functions creates and adds a CellRendererText for the selected
// column. If you need to set the text column, but don't want the cell
// renderer, use g_object_set() to set the EntryCompletion:text-column
// property directly.
func (completion entryCompletion) SetTextColumn(column int) {
	var arg0 *C.GtkEntryCompletion
	var arg1 C.int

	arg0 = (*C.GtkEntryCompletion)(completion.Native())
	arg1 = C.int(column)

	C.gtk_entry_completion_set_text_column(arg0, arg1)
}

// EventController is a base, low-level implementation for event controllers.
// Those react to a series of Events, and possibly trigger actions as a
// consequence of those.
type EventController interface {
	gextras.Objector

	// CurrentEvent returns the event that is currently being handled by the
	// controller, and nil at other times.
	CurrentEvent() gdk.Event
	// CurrentEventDevice returns the device of the event that is currently
	// being handled by the controller, and nil otherwise.
	CurrentEventDevice() gdk.Device
	// CurrentEventState returns the modifier state of the event that is
	// currently being handled by the controller, and 0 otherwise.
	CurrentEventState() gdk.ModifierType
	// CurrentEventTime returns the timestamp of the event that is currently
	// being handled by the controller, and 0 otherwise.
	CurrentEventTime() uint32
	// Name gets the name of @controller.
	Name() string
	// PropagationLimit gets the propagation limit of the event controller.
	PropagationLimit() PropagationLimit
	// PropagationPhase gets the propagation phase at which @controller handles
	// events.
	PropagationPhase() PropagationPhase
	// Widget returns the Widget this controller relates to.
	Widget() Widget
	// Reset resets the @controller to a clean state. Every interaction the
	// controller did through gtk_event_controller_handle_event() will be
	// dropped at this point.
	Reset()
	// SetName sets a name on the controller that can be used for debugging.
	SetName(name string)
	// SetPropagationLimit sets the event propagation limit on the event
	// controller.
	//
	// If the limit is set to GTK_LIMIT_SAME_NATIVE, the controller won't handle
	// events that are targeted at widgets on a different surface, such as
	// popovers.
	SetPropagationLimit(limit PropagationLimit)
	// SetPropagationPhase sets the propagation phase at which a controller
	// handles events.
	//
	// If @phase is GTK_PHASE_NONE, no automatic event handling will be
	// performed, but other additional gesture maintenance will. In that phase,
	// the events can be managed by calling gtk_event_controller_handle_event().
	SetPropagationPhase(phase PropagationPhase)
}

type eventController struct {
	*externglib.Object
}

// WrapEventController wraps a GObject to the right type. It is
// primarily used internally.
func WrapEventController(obj *externglib.Object) EventController {
	return eventController{*externglib.Object{obj}}
}

func marshalEventController(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapEventController(obj), nil
}

// CurrentEvent returns the event that is currently being handled by the
// controller, and nil at other times.
func (controller eventController) CurrentEvent() gdk.Event {
	var arg0 *C.GtkEventController

	arg0 = (*C.GtkEventController)(controller.Native())

	ret := C.gtk_event_controller_get_current_event(arg0)

	var ret0 gdk.Event

	ret0 = gdk.WrapEvent(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// CurrentEventDevice returns the device of the event that is currently
// being handled by the controller, and nil otherwise.
func (controller eventController) CurrentEventDevice() gdk.Device {
	var arg0 *C.GtkEventController

	arg0 = (*C.GtkEventController)(controller.Native())

	ret := C.gtk_event_controller_get_current_event_device(arg0)

	var ret0 gdk.Device

	ret0 = gdk.WrapDevice(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// CurrentEventState returns the modifier state of the event that is
// currently being handled by the controller, and 0 otherwise.
func (controller eventController) CurrentEventState() gdk.ModifierType {
	var arg0 *C.GtkEventController

	arg0 = (*C.GtkEventController)(controller.Native())

	ret := C.gtk_event_controller_get_current_event_state(arg0)

	var ret0 gdk.ModifierType

	ret0 = gdk.ModifierType(ret)

	return ret0
}

// CurrentEventTime returns the timestamp of the event that is currently
// being handled by the controller, and 0 otherwise.
func (controller eventController) CurrentEventTime() uint32 {
	var arg0 *C.GtkEventController

	arg0 = (*C.GtkEventController)(controller.Native())

	ret := C.gtk_event_controller_get_current_event_time(arg0)

	var ret0 uint32

	ret0 = uint32(ret)

	return ret0
}

// Name gets the name of @controller.
func (controller eventController) Name() string {
	var arg0 *C.GtkEventController

	arg0 = (*C.GtkEventController)(controller.Native())

	ret := C.gtk_event_controller_get_name(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// PropagationLimit gets the propagation limit of the event controller.
func (controller eventController) PropagationLimit() PropagationLimit {
	var arg0 *C.GtkEventController

	arg0 = (*C.GtkEventController)(controller.Native())

	ret := C.gtk_event_controller_get_propagation_limit(arg0)

	var ret0 PropagationLimit

	ret0 = PropagationLimit(ret)

	return ret0
}

// PropagationPhase gets the propagation phase at which @controller handles
// events.
func (controller eventController) PropagationPhase() PropagationPhase {
	var arg0 *C.GtkEventController

	arg0 = (*C.GtkEventController)(controller.Native())

	ret := C.gtk_event_controller_get_propagation_phase(arg0)

	var ret0 PropagationPhase

	ret0 = PropagationPhase(ret)

	return ret0
}

// Widget returns the Widget this controller relates to.
func (controller eventController) Widget() Widget {
	var arg0 *C.GtkEventController

	arg0 = (*C.GtkEventController)(controller.Native())

	ret := C.gtk_event_controller_get_widget(arg0)

	var ret0 Widget

	ret0 = WrapWidget(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Reset resets the @controller to a clean state. Every interaction the
// controller did through gtk_event_controller_handle_event() will be
// dropped at this point.
func (controller eventController) Reset() {
	var arg0 *C.GtkEventController

	arg0 = (*C.GtkEventController)(controller.Native())

	C.gtk_event_controller_reset(arg0)
}

// SetName sets a name on the controller that can be used for debugging.
func (controller eventController) SetName(name string) {
	var arg0 *C.GtkEventController
	var arg1 *C.char

	arg0 = (*C.GtkEventController)(controller.Native())
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_event_controller_set_name(arg0, arg1)
}

// SetPropagationLimit sets the event propagation limit on the event
// controller.
//
// If the limit is set to GTK_LIMIT_SAME_NATIVE, the controller won't handle
// events that are targeted at widgets on a different surface, such as
// popovers.
func (controller eventController) SetPropagationLimit(limit PropagationLimit) {
	var arg0 *C.GtkEventController
	var arg1 C.GtkPropagationLimit

	arg0 = (*C.GtkEventController)(controller.Native())
	arg1 = (C.GtkPropagationLimit)(limit)

	C.gtk_event_controller_set_propagation_limit(arg0, arg1)
}

// SetPropagationPhase sets the propagation phase at which a controller
// handles events.
//
// If @phase is GTK_PHASE_NONE, no automatic event handling will be
// performed, but other additional gesture maintenance will. In that phase,
// the events can be managed by calling gtk_event_controller_handle_event().
func (controller eventController) SetPropagationPhase(phase PropagationPhase) {
	var arg0 *C.GtkEventController
	var arg1 C.GtkPropagationPhase

	arg0 = (*C.GtkEventController)(controller.Native())
	arg1 = (C.GtkPropagationPhase)(phase)

	C.gtk_event_controller_set_propagation_phase(arg0, arg1)
}

// EventControllerFocus is an event controller meant for situations where you
// need to know where the focus is.
type EventControllerFocus interface {
	EventController

	// ContainsFocus returns the value of the
	// GtkEventControllerFocus:contains-focus property.
	ContainsFocus() bool
	// IsFocus returns the value of the GtkEventControllerFocus:is-focus
	// property.
	IsFocus() bool
}

type eventControllerFocus struct {
	eventController
}

// WrapEventControllerFocus wraps a GObject to the right type. It is
// primarily used internally.
func WrapEventControllerFocus(obj *externglib.Object) EventControllerFocus {
	return eventControllerFocus{eventController{*externglib.Object{obj}}}
}

func marshalEventControllerFocus(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapEventControllerFocus(obj), nil
}

// NewEventControllerFocus constructs a class EventControllerFocus.
func NewEventControllerFocus() EventControllerFocus {

	ret := C.gtk_event_controller_focus_new()

	var ret0 EventControllerFocus

	ret0 = WrapEventControllerFocus(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// ContainsFocus returns the value of the
// GtkEventControllerFocus:contains-focus property.
func (self eventControllerFocus) ContainsFocus() bool {
	var arg0 *C.GtkEventControllerFocus

	arg0 = (*C.GtkEventControllerFocus)(self.Native())

	ret := C.gtk_event_controller_focus_contains_focus(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// IsFocus returns the value of the GtkEventControllerFocus:is-focus
// property.
func (self eventControllerFocus) IsFocus() bool {
	var arg0 *C.GtkEventControllerFocus

	arg0 = (*C.GtkEventControllerFocus)(self.Native())

	ret := C.gtk_event_controller_focus_is_focus(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// EventControllerKey is an event controller meant for situations where you need
// access to key events.
type EventControllerKey interface {
	EventController

	// Forward forwards the current event of this @controller to a @widget.
	//
	// This function can only be used in handlers for the
	// EventControllerKey::key-pressed, EventControllerKey::key-released or
	// EventControllerKey::modifiers signals.
	Forward(widget Widget) bool
	// Group gets the key group of the current event of this @controller. See
	// gdk_key_event_get_group().
	Group() uint
	// ImContext gets the input method context of the key @controller.
	ImContext() IMContext
	// SetImContext sets the input method context of the key @controller.
	SetImContext(imContext IMContext)
}

type eventControllerKey struct {
	eventController
}

// WrapEventControllerKey wraps a GObject to the right type. It is
// primarily used internally.
func WrapEventControllerKey(obj *externglib.Object) EventControllerKey {
	return eventControllerKey{eventController{*externglib.Object{obj}}}
}

func marshalEventControllerKey(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapEventControllerKey(obj), nil
}

// NewEventControllerKey constructs a class EventControllerKey.
func NewEventControllerKey() EventControllerKey {

	ret := C.gtk_event_controller_key_new()

	var ret0 EventControllerKey

	ret0 = WrapEventControllerKey(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Forward forwards the current event of this @controller to a @widget.
//
// This function can only be used in handlers for the
// EventControllerKey::key-pressed, EventControllerKey::key-released or
// EventControllerKey::modifiers signals.
func (controller eventControllerKey) Forward(widget Widget) bool {
	var arg0 *C.GtkEventControllerKey
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkEventControllerKey)(controller.Native())
	arg1 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_event_controller_key_forward(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Group gets the key group of the current event of this @controller. See
// gdk_key_event_get_group().
func (controller eventControllerKey) Group() uint {
	var arg0 *C.GtkEventControllerKey

	arg0 = (*C.GtkEventControllerKey)(controller.Native())

	ret := C.gtk_event_controller_key_get_group(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// ImContext gets the input method context of the key @controller.
func (controller eventControllerKey) ImContext() IMContext {
	var arg0 *C.GtkEventControllerKey

	arg0 = (*C.GtkEventControllerKey)(controller.Native())

	ret := C.gtk_event_controller_key_get_im_context(arg0)

	var ret0 IMContext

	ret0 = WrapIMContext(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// SetImContext sets the input method context of the key @controller.
func (controller eventControllerKey) SetImContext(imContext IMContext) {
	var arg0 *C.GtkEventControllerKey
	var arg1 *C.GtkIMContext

	arg0 = (*C.GtkEventControllerKey)(controller.Native())
	arg1 = (*C.GtkIMContext)(imContext.Native())

	C.gtk_event_controller_key_set_im_context(arg0, arg1)
}

// EventControllerLegacy is an event controller that gives you direct access to
// the event stream. It should only be used as a last resort if none of the
// other event controllers or gestures do the job.
type EventControllerLegacy interface {
	EventController
}

type eventControllerLegacy struct {
	eventController
}

// WrapEventControllerLegacy wraps a GObject to the right type. It is
// primarily used internally.
func WrapEventControllerLegacy(obj *externglib.Object) EventControllerLegacy {
	return eventControllerLegacy{eventController{*externglib.Object{obj}}}
}

func marshalEventControllerLegacy(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapEventControllerLegacy(obj), nil
}

// NewEventControllerLegacy constructs a class EventControllerLegacy.
func NewEventControllerLegacy() EventControllerLegacy {

	ret := C.gtk_event_controller_legacy_new()

	var ret0 EventControllerLegacy

	ret0 = WrapEventControllerLegacy(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// EventControllerMotion is an event controller meant for situations where you
// need to track the position of the pointer.
type EventControllerMotion interface {
	EventController

	// ContainsPointer returns the value of the
	// GtkEventControllerMotion:contains-pointer property.
	ContainsPointer() bool
	// IsPointer returns the value of the GtkEventControllerMotion:is-pointer
	// property.
	IsPointer() bool
}

type eventControllerMotion struct {
	eventController
}

// WrapEventControllerMotion wraps a GObject to the right type. It is
// primarily used internally.
func WrapEventControllerMotion(obj *externglib.Object) EventControllerMotion {
	return eventControllerMotion{eventController{*externglib.Object{obj}}}
}

func marshalEventControllerMotion(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapEventControllerMotion(obj), nil
}

// NewEventControllerMotion constructs a class EventControllerMotion.
func NewEventControllerMotion() EventControllerMotion {

	ret := C.gtk_event_controller_motion_new()

	var ret0 EventControllerMotion

	ret0 = WrapEventControllerMotion(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// ContainsPointer returns the value of the
// GtkEventControllerMotion:contains-pointer property.
func (self eventControllerMotion) ContainsPointer() bool {
	var arg0 *C.GtkEventControllerMotion

	arg0 = (*C.GtkEventControllerMotion)(self.Native())

	ret := C.gtk_event_controller_motion_contains_pointer(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// IsPointer returns the value of the GtkEventControllerMotion:is-pointer
// property.
func (self eventControllerMotion) IsPointer() bool {
	var arg0 *C.GtkEventControllerMotion

	arg0 = (*C.GtkEventControllerMotion)(self.Native())

	ret := C.gtk_event_controller_motion_is_pointer(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// EventControllerScroll is an event controller meant to handle scroll events
// from mice and touchpads. It is capable of handling both discrete and
// continuous scroll events, abstracting them both on the
// EventControllerScroll::scroll signal (deltas in the discrete case are
// multiples of 1).
//
// In the case of continuous scroll events, EventControllerScroll encloses all
// EventControllerScroll::scroll events between two
// EventControllerScroll::scroll-begin and EventControllerScroll::scroll-end
// signals.
//
// The behavior of the event controller can be modified by the flags given at
// creation time, or modified at a later point through
// gtk_event_controller_scroll_set_flags() (e.g. because the scrolling
// conditions of the widget changed).
//
// The controller can be set up to emit motion for either/both vertical and
// horizontal scroll events through K_EVENT_CONTROLLER_SCROLL_VERTICAL,
// K_EVENT_CONTROLLER_SCROLL_HORIZONTAL and K_EVENT_CONTROLLER_SCROLL_BOTH_AXES.
// If any axis is disabled, the respective EventControllerScroll::scroll delta
// will be 0. Vertical scroll events will be translated to horizontal motion for
// the devices incapable of horizontal scrolling.
//
// The event controller can also be forced to emit discrete events on all
// devices through K_EVENT_CONTROLLER_SCROLL_DISCRETE. This can be used to
// implement discrete actions triggered through scroll events (e.g. switching
// across combobox options).
//
// The K_EVENT_CONTROLLER_SCROLL_KINETIC flag toggles the emission of the
// EventControllerScroll::decelerate signal, emitted at the end of scrolling
// with two X/Y velocity arguments that are consistent with the motion that was
// received.
type EventControllerScroll interface {
	EventController

	// Flags gets the flags conditioning the scroll controller behavior.
	Flags() EventControllerScrollFlags
	// SetFlags sets the flags conditioning scroll controller behavior.
	SetFlags(flags EventControllerScrollFlags)
}

type eventControllerScroll struct {
	eventController
}

// WrapEventControllerScroll wraps a GObject to the right type. It is
// primarily used internally.
func WrapEventControllerScroll(obj *externglib.Object) EventControllerScroll {
	return eventControllerScroll{eventController{*externglib.Object{obj}}}
}

func marshalEventControllerScroll(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapEventControllerScroll(obj), nil
}

// NewEventControllerScroll constructs a class EventControllerScroll.
func NewEventControllerScroll(flags EventControllerScrollFlags) EventControllerScroll {
	var arg1 C.GtkEventControllerScrollFlags

	arg1 = (C.GtkEventControllerScrollFlags)(flags)

	ret := C.gtk_event_controller_scroll_new(arg1)

	var ret0 EventControllerScroll

	ret0 = WrapEventControllerScroll(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Flags gets the flags conditioning the scroll controller behavior.
func (scroll eventControllerScroll) Flags() EventControllerScrollFlags {
	var arg0 *C.GtkEventControllerScroll

	arg0 = (*C.GtkEventControllerScroll)(scroll.Native())

	ret := C.gtk_event_controller_scroll_get_flags(arg0)

	var ret0 EventControllerScrollFlags

	ret0 = EventControllerScrollFlags(ret)

	return ret0
}

// SetFlags sets the flags conditioning scroll controller behavior.
func (scroll eventControllerScroll) SetFlags(flags EventControllerScrollFlags) {
	var arg0 *C.GtkEventControllerScroll
	var arg1 C.GtkEventControllerScrollFlags

	arg0 = (*C.GtkEventControllerScroll)(scroll.Native())
	arg1 = (C.GtkEventControllerScrollFlags)(flags)

	C.gtk_event_controller_scroll_set_flags(arg0, arg1)
}

type EveryFilter interface {
	MultiFilter
}

type everyFilter struct {
	multiFilter
}

// WrapEveryFilter wraps a GObject to the right type. It is
// primarily used internally.
func WrapEveryFilter(obj *externglib.Object) EveryFilter {
	return everyFilter{multiFilter{filter{*externglib.Object{obj}}}}
}

func marshalEveryFilter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapEveryFilter(obj), nil
}

// NewEveryFilter constructs a class EveryFilter.
func NewEveryFilter() EveryFilter {

	ret := C.gtk_every_filter_new()

	var ret0 EveryFilter

	ret0 = WrapEveryFilter(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Expander: a Expander allows the user to hide or show its child by clicking on
// an expander triangle similar to the triangles used in a TreeView.
//
// Normally you use an expander as you would use a frame; you create the child
// widget and use gtk_expander_set_child() to add it to the expander. When the
// expander is toggled, it will take care of showing and hiding the child
// automatically.
//
//
// Special Usage
//
// There are situations in which you may prefer to show and hide the expanded
// widget yourself, such as when you want to actually create the widget at
// expansion time. In this case, create a Expander but do not add a child to it.
// The expander widget has an Expander:expanded property which can be used to
// monitor its expansion state. You should watch this property with a signal
// connection as follows:
//
//    expander
//    ╰── box
//        ├── title
//        │   ├── arrow
//        │   ╰── <label widget>
//        ╰── <child>
//
//
// GtkExpander has three CSS nodes, the main node with the name expander, a
// subnode with name title and node below it with name arrow. The arrow of an
// expander that is showing its child gets the :checked pseudoclass added to it.
//
//
// Accessibility
//
// GtkExpander uses the K_ACCESSIBLE_ROLE_BUTTON role.
type Expander interface {
	Widget

	// Child gets the child widget of @expander.
	Child() Widget
	// Expanded queries a Expander and returns its current state. Returns true
	// if the child widget is revealed.
	//
	// See gtk_expander_set_expanded().
	Expanded() bool
	// Label fetches the text from a label widget including any embedded
	// underlines indicating mnemonics and Pango markup, as set by
	// gtk_expander_set_label(). If the label text has not been set the return
	// value will be nil. This will be the case if you create an empty button
	// with gtk_button_new() to use as a container.
	//
	// Note that this function behaved differently in versions prior to 2.14 and
	// used to return the label text stripped of embedded underlines indicating
	// mnemonics and Pango markup. This problem can be avoided by fetching the
	// label text directly from the label widget.
	Label() string
	// LabelWidget retrieves the label widget for the frame. See
	// gtk_expander_set_label_widget().
	LabelWidget() Widget
	// ResizeToplevel returns whether the expander will resize the toplevel
	// widget containing the expander upon resizing and collpasing.
	ResizeToplevel() bool
	// UseMarkup returns whether the label’s text is interpreted as marked up
	// with the [Pango text markup language][PangoMarkupFormat]. See
	// gtk_expander_set_use_markup().
	UseMarkup() bool
	// UseUnderline returns whether an embedded underline in the expander label
	// indicates a mnemonic. See gtk_expander_set_use_underline().
	UseUnderline() bool
	// SetChild sets the child widget of @expander.
	SetChild(child Widget)
	// SetExpanded sets the state of the expander. Set to true, if you want the
	// child widget to be revealed, and false if you want the child widget to be
	// hidden.
	SetExpanded(expanded bool)
	// SetLabel sets the text of the label of the expander to @label.
	//
	// This will also clear any previously set labels.
	SetLabel(label string)
	// SetLabelWidget: set the label widget for the expander. This is the widget
	// that will appear embedded alongside the expander arrow.
	SetLabelWidget(labelWidget Widget)
	// SetResizeToplevel sets whether the expander will resize the toplevel
	// widget containing the expander upon resizing and collpasing.
	SetResizeToplevel(resizeToplevel bool)
	// SetUseMarkup sets whether the text of the label contains markup in
	// [Pango’s text markup language][PangoMarkupFormat]. See
	// gtk_label_set_markup().
	SetUseMarkup(useMarkup bool)
	// SetUseUnderline: if true, an underline in the text of the expander label
	// indicates the next character should be used for the mnemonic accelerator
	// key.
	SetUseUnderline(useUnderline bool)
}

type expander struct {
	widget
}

// WrapExpander wraps a GObject to the right type. It is
// primarily used internally.
func WrapExpander(obj *externglib.Object) Expander {
	return expander{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}
}

func marshalExpander(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapExpander(obj), nil
}

// NewExpander constructs a class Expander.
func NewExpander(label string) Expander {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_expander_new(arg1)

	var ret0 Expander

	ret0 = WrapExpander(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewExpanderWithMnemonic constructs a class Expander.
func NewExpanderWithMnemonic(label string) Expander {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_expander_new_with_mnemonic(arg1)

	var ret0 Expander

	ret0 = WrapExpander(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Child gets the child widget of @expander.
func (expander expander) Child() Widget {
	var arg0 *C.GtkExpander

	arg0 = (*C.GtkExpander)(expander.Native())

	ret := C.gtk_expander_get_child(arg0)

	var ret0 Widget

	ret0 = WrapWidget(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Expanded queries a Expander and returns its current state. Returns true
// if the child widget is revealed.
//
// See gtk_expander_set_expanded().
func (expander expander) Expanded() bool {
	var arg0 *C.GtkExpander

	arg0 = (*C.GtkExpander)(expander.Native())

	ret := C.gtk_expander_get_expanded(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Label fetches the text from a label widget including any embedded
// underlines indicating mnemonics and Pango markup, as set by
// gtk_expander_set_label(). If the label text has not been set the return
// value will be nil. This will be the case if you create an empty button
// with gtk_button_new() to use as a container.
//
// Note that this function behaved differently in versions prior to 2.14 and
// used to return the label text stripped of embedded underlines indicating
// mnemonics and Pango markup. This problem can be avoided by fetching the
// label text directly from the label widget.
func (expander expander) Label() string {
	var arg0 *C.GtkExpander

	arg0 = (*C.GtkExpander)(expander.Native())

	ret := C.gtk_expander_get_label(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// LabelWidget retrieves the label widget for the frame. See
// gtk_expander_set_label_widget().
func (expander expander) LabelWidget() Widget {
	var arg0 *C.GtkExpander

	arg0 = (*C.GtkExpander)(expander.Native())

	ret := C.gtk_expander_get_label_widget(arg0)

	var ret0 Widget

	ret0 = WrapWidget(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// ResizeToplevel returns whether the expander will resize the toplevel
// widget containing the expander upon resizing and collpasing.
func (expander expander) ResizeToplevel() bool {
	var arg0 *C.GtkExpander

	arg0 = (*C.GtkExpander)(expander.Native())

	ret := C.gtk_expander_get_resize_toplevel(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// UseMarkup returns whether the label’s text is interpreted as marked up
// with the [Pango text markup language][PangoMarkupFormat]. See
// gtk_expander_set_use_markup().
func (expander expander) UseMarkup() bool {
	var arg0 *C.GtkExpander

	arg0 = (*C.GtkExpander)(expander.Native())

	ret := C.gtk_expander_get_use_markup(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// UseUnderline returns whether an embedded underline in the expander label
// indicates a mnemonic. See gtk_expander_set_use_underline().
func (expander expander) UseUnderline() bool {
	var arg0 *C.GtkExpander

	arg0 = (*C.GtkExpander)(expander.Native())

	ret := C.gtk_expander_get_use_underline(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// SetChild sets the child widget of @expander.
func (expander expander) SetChild(child Widget) {
	var arg0 *C.GtkExpander
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkExpander)(expander.Native())
	arg1 = (*C.GtkWidget)(child.Native())

	C.gtk_expander_set_child(arg0, arg1)
}

// SetExpanded sets the state of the expander. Set to true, if you want the
// child widget to be revealed, and false if you want the child widget to be
// hidden.
func (expander expander) SetExpanded(expanded bool) {
	var arg0 *C.GtkExpander
	var arg1 C.gboolean

	arg0 = (*C.GtkExpander)(expander.Native())
	arg1 = gextras.Cbool(expanded)

	C.gtk_expander_set_expanded(arg0, arg1)
}

// SetLabel sets the text of the label of the expander to @label.
//
// This will also clear any previously set labels.
func (expander expander) SetLabel(label string) {
	var arg0 *C.GtkExpander
	var arg1 *C.char

	arg0 = (*C.GtkExpander)(expander.Native())
	arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_expander_set_label(arg0, arg1)
}

// SetLabelWidget: set the label widget for the expander. This is the widget
// that will appear embedded alongside the expander arrow.
func (expander expander) SetLabelWidget(labelWidget Widget) {
	var arg0 *C.GtkExpander
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkExpander)(expander.Native())
	arg1 = (*C.GtkWidget)(labelWidget.Native())

	C.gtk_expander_set_label_widget(arg0, arg1)
}

// SetResizeToplevel sets whether the expander will resize the toplevel
// widget containing the expander upon resizing and collpasing.
func (expander expander) SetResizeToplevel(resizeToplevel bool) {
	var arg0 *C.GtkExpander
	var arg1 C.gboolean

	arg0 = (*C.GtkExpander)(expander.Native())
	arg1 = gextras.Cbool(resizeToplevel)

	C.gtk_expander_set_resize_toplevel(arg0, arg1)
}

// SetUseMarkup sets whether the text of the label contains markup in
// [Pango’s text markup language][PangoMarkupFormat]. See
// gtk_label_set_markup().
func (expander expander) SetUseMarkup(useMarkup bool) {
	var arg0 *C.GtkExpander
	var arg1 C.gboolean

	arg0 = (*C.GtkExpander)(expander.Native())
	arg1 = gextras.Cbool(useMarkup)

	C.gtk_expander_set_use_markup(arg0, arg1)
}

// SetUseUnderline: if true, an underline in the text of the expander label
// indicates the next character should be used for the mnemonic accelerator
// key.
func (expander expander) SetUseUnderline(useUnderline bool) {
	var arg0 *C.GtkExpander
	var arg1 C.gboolean

	arg0 = (*C.GtkExpander)(expander.Native())
	arg1 = gextras.Cbool(useUnderline)

	C.gtk_expander_set_use_underline(arg0, arg1)
}

// FileChooserDialog is a dialog box suitable for use with “File Open” or “File
// Save” commands. This widget works by putting a FileChooserWidget inside a
// Dialog. It exposes the FileChooser interface, so you can use all of the
// FileChooser functions on the file chooser dialog as well as those for Dialog.
//
// Note that FileChooserDialog does not have any methods of its own. Instead,
// you should use the functions that work on a FileChooser.
//
// If you want to integrate well with the platform you should use the
// FileChooserNative API, which will use a platform-specific dialog if available
// and fall back to GtkFileChooserDialog otherwise.
//
//
// Typical usage
//
// In the simplest of cases, you can the following code to use FileChooserDialog
// to select a file for opening:
//
//
//    static void
//    on_open_response (GtkDialog *dialog,
//                      int        response)
//    {
//      if (response == GTK_RESPONSE_ACCEPT)
//        {
//          GtkFileChooser *chooser = GTK_FILE_CHOOSER (dialog);
//
//          g_autoptr(GFile) file = gtk_file_chooser_get_file (chooser);
//
//          open_file (file);
//        }
//
//      gtk_window_destroy (GTK_WINDOW (dialog));
//    }
//
//      // ...
//      GtkWidget *dialog;
//      GtkFileChooserAction action = GTK_FILE_CHOOSER_ACTION_OPEN;
//
//      dialog = gtk_file_chooser_dialog_new ("Open File",
//                                            parent_window,
//                                            action,
//                                            _("_Cancel"),
//                                            GTK_RESPONSE_CANCEL,
//                                            _("_Open"),
//                                            GTK_RESPONSE_ACCEPT,
//                                            NULL);
//
//      gtk_widget_show (dialog);
//
//      g_signal_connect (dialog, "response",
//                        G_CALLBACK (on_open_response),
//                        NULL);
//    ]|
//
//    To use a dialog for saving, you can use this:
//
//    |[
//    static void
//    on_save_response (GtkDialog *dialog,
//                      int        response)
//    {
//      if (response == GTK_RESPONSE_ACCEPT)
//        {
//          GtkFileChooser *chooser = GTK_FILE_CHOOSER (dialog);
//
//          g_autoptr(GFile) file = gtk_file_chooser_get_file (chooser);
//
//          save_to_file (file);
//        }
//
//      gtk_window_destroy (GTK_WINDOW (dialog));
//    }
//
//      // ...
//      GtkWidget *dialog;
//      GtkFileChooser *chooser;
//      GtkFileChooserAction action = GTK_FILE_CHOOSER_ACTION_SAVE;
//
//      dialog = gtk_file_chooser_dialog_new ("Save File",
//                                            parent_window,
//                                            action,
//                                            _("_Cancel"),
//                                            GTK_RESPONSE_CANCEL,
//                                            _("_Save"),
//                                            GTK_RESPONSE_ACCEPT,
//                                            NULL);
//      chooser = GTK_FILE_CHOOSER (dialog);
//
//      if (user_edited_a_new_document)
//        gtk_file_chooser_set_current_name (chooser, _("Untitled document"));
//      else
//        gtk_file_chooser_set_file (chooser, existing_filename);
//
//      gtk_widget_show (dialog);
//
//      g_signal_connect (dialog, "response",
//                        G_CALLBACK (on_save_response),
//                        NULL);
//    ]|
//
//
//
// Setting up a file chooser dialog
//
//
//    There are various cases in which you may need to use a FileChooserDialog:
//
//    - To select a file for opening. Use K_FILE_CHOOSER_ACTION_OPEN.
//
//    - To save a file for the first time. Use K_FILE_CHOOSER_ACTION_SAVE,
//      and suggest a name such as “Untitled” with gtk_file_chooser_set_current_name().
//
//    - To save a file under a different name. Use K_FILE_CHOOSER_ACTION_SAVE,
//      and set the existing file with gtk_file_chooser_set_file().
//
//    - To choose a folder instead of a file. Use K_FILE_CHOOSER_ACTION_SELECT_FOLDER.
//
//    Note that old versions of the file chooser’s documentation suggested
//    using gtk_file_chooser_set_current_folder() in various
//    situations, with the intention of letting the application
//    suggest a reasonable default folder.  This is no longer
//    considered to be a good policy, as now the file chooser is
//    able to make good suggestions on its own.  In general, you
//    should only cause the file chooser to show a specific folder
//    when it is appropriate to use gtk_file_chooser_set_file(),
//    i.e. when you are doing a Save As command and you already
//    have a file saved somewhere.
//
//
//
// Response Codes
//
//
//    FileChooserDialog inherits from Dialog, so buttons that
//    go in its action area have response codes such as
//    K_RESPONSE_ACCEPT and K_RESPONSE_CANCEL.  For example, you
//    could call gtk_file_chooser_dialog_new() as follows:
//
//    |[
//    GtkWidget *dialog;
//    GtkFileChooserAction action = GTK_FILE_CHOOSER_ACTION_OPEN;
//
//    dialog = gtk_file_chooser_dialog_new ("Open File",
//                                          parent_window,
//                                          action,
//                                          _("_Cancel"),
//                                          GTK_RESPONSE_CANCEL,
//                                          _("_Open"),
//                                          GTK_RESPONSE_ACCEPT,
//                                          NULL);
//
//
// This will create buttons for “Cancel” and “Open” that use predefined response
// identifiers from ResponseType. For most dialog boxes you can use your own
// custom response codes rather than the ones in ResponseType, but
// FileChooserDialog assumes that its “accept”-type action, e.g. an “Open” or
// “Save” button, will have one of the following response codes:
//
// - K_RESPONSE_ACCEPT - K_RESPONSE_OK - K_RESPONSE_YES - K_RESPONSE_APPLY
//
// This is because FileChooserDialog must intercept responses and switch to
// folders if appropriate, rather than letting the dialog terminate — the
// implementation uses these known response codes to know which responses can be
// blocked if appropriate.
//
// To summarize, make sure you use a [predefined response
// code][gtkfilechooserdialog-responses] when you use FileChooserDialog to
// ensure proper operation.
type FileChooserDialog interface {
	Dialog
}

type fileChooserDialog struct {
	dialog
}

// WrapFileChooserDialog wraps a GObject to the right type. It is
// primarily used internally.
func WrapFileChooserDialog(obj *externglib.Object) FileChooserDialog {
	return fileChooserDialog{dialog{window{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}}}
}

func marshalFileChooserDialog(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFileChooserDialog(obj), nil
}

// FileChooserNative is an abstraction of a dialog box suitable for use with
// “File Open” or “File Save as” commands. By default, this just uses a
// FileChooserDialog to implement the actual dialog. However, on certain
// platforms, such as Windows and macOS, the native platform file chooser is
// used instead. When the application is running in a sandboxed environment
// without direct filesystem access (such as Flatpak), FileChooserNative may
// call the proper APIs (portals) to let the user choose a file and make it
// available to the application.
//
// While the API of FileChooserNative closely mirrors FileChooserDialog, the
// main difference is that there is no access to any Window or Widget for the
// dialog. This is required, as there may not be one in the case of a platform
// native dialog.
//
// Showing, hiding and running the dialog is handled by the NativeDialog
// functions.
//
// Note that unlike FileChooserDialog, FileChooserNative objects are not
// toplevel widgets, and GTK does not keep them alive. It is your responsibility
// to keep a reference until you are done with the object.
//
//
// Typical usage
//
// In the simplest of cases, you can the following code to use FileChooserDialog
// to select a file for opening:
//
//    static void
//    on_response (GtkNativeDialog *native,
//                 int              response)
//    {
//      if (response == GTK_RESPONSE_ACCEPT)
//        {
//          GtkFileChooser *chooser = GTK_FILE_CHOOSER (native);
//          GFile *file = gtk_file_chooser_get_file (chooser);
//
//          save_to_file (file);
//
//          g_object_unref (file);
//        }
//
//      g_object_unref (native);
//    }
//
//      // ...
//      GtkFileChooserNative *native;
//      GtkFileChooser *chooser;
//      GtkFileChooserAction action = GTK_FILE_CHOOSER_ACTION_SAVE;
//
//      native = gtk_file_chooser_native_new ("Save File",
//                                            parent_window,
//                                            action,
//                                            "_Save",
//                                            "_Cancel");
//      chooser = GTK_FILE_CHOOSER (native);
//
//      if (user_edited_a_new_document)
//        gtk_file_chooser_set_current_name (chooser, _("Untitled document"));
//      else
//        gtk_file_chooser_set_file (chooser, existing_file, NULL);
//
//      g_signal_connect (native, "response", G_CALLBACK (on_response), NULL);
//      gtk_native_dialog_show (GTK_NATIVE_DIALOG (native));
//
//
// For more information on how to best set up a file dialog, see
// FileChooserDialog.
//
//
// Response Codes
//
// FileChooserNative inherits from NativeDialog, which means it will return
// K_RESPONSE_ACCEPT if the user accepted, and K_RESPONSE_CANCEL if he pressed
// cancel. It can also return K_RESPONSE_DELETE_EVENT if the window was
// unexpectedly closed.
//
// Differences from FileChooserDialog ##
// {#gtkfilechooserdialognative-differences}
//
// There are a few things in the GtkFileChooser API that are not possible to use
// with FileChooserNative, as such use would prohibit the use of a native
// dialog.
//
// No operations that change the dialog work while the dialog is visible. Set
// all the properties that are required before showing the dialog.
//
//
// Win32 details
//
// On windows the IFileDialog implementation (added in Windows Vista) is used.
// It supports many of the features that FileChooserDialog does, but there are
// some things it does not handle:
//
// * Any FileFilter added using a mimetype
//
// If any of these features are used the regular FileChooserDialog will be used
// in place of the native one.
//
//
// Portal details
//
// When the org.freedesktop.portal.FileChooser portal is available on the
// session bus, it is used to bring up an out-of-process file chooser. Depending
// on the kind of session the application is running in, this may or may not be
// a GTK file chooser.
//
// macOS details
//
// On macOS the NSSavePanel and NSOpenPanel classes are used to provide native
// file chooser dialogs. Some features provided by FileChooserDialog are not
// supported:
//
// * Shortcut folders.
type FileChooserNative interface {
	NativeDialog

	// AcceptLabel retrieves the custom label text for the accept button.
	AcceptLabel() string
	// CancelLabel retrieves the custom label text for the cancel button.
	CancelLabel() string
	// SetAcceptLabel sets the custom label text for the accept button.
	//
	// If characters in @label are preceded by an underscore, they are
	// underlined. If you need a literal underscore character in a label, use
	// “__” (two underscores). The first underlined character represents a
	// keyboard accelerator called a mnemonic. Pressing Alt and that key
	// activates the button.
	SetAcceptLabel(acceptLabel string)
	// SetCancelLabel sets the custom label text for the cancel button.
	//
	// If characters in @label are preceded by an underscore, they are
	// underlined. If you need a literal underscore character in a label, use
	// “__” (two underscores). The first underlined character represents a
	// keyboard accelerator called a mnemonic. Pressing Alt and that key
	// activates the button.
	SetCancelLabel(cancelLabel string)
}

type fileChooserNative struct {
	nativeDialog
}

// WrapFileChooserNative wraps a GObject to the right type. It is
// primarily used internally.
func WrapFileChooserNative(obj *externglib.Object) FileChooserNative {
	return fileChooserNative{nativeDialog{*externglib.Object{obj}}}
}

func marshalFileChooserNative(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFileChooserNative(obj), nil
}

// NewFileChooserNative constructs a class FileChooserNative.
func NewFileChooserNative(title string, parent Window, action FileChooserAction, acceptLabel string, cancelLabel string) FileChooserNative {
	var arg1 *C.char
	var arg2 *C.GtkWindow
	var arg3 C.GtkFileChooserAction
	var arg4 *C.char
	var arg5 *C.char

	arg1 = (*C.gchar)(C.CString(title))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GtkWindow)(parent.Native())
	arg3 = (C.GtkFileChooserAction)(action)
	arg4 = (*C.gchar)(C.CString(acceptLabel))
	defer C.free(unsafe.Pointer(arg4))
	arg5 = (*C.gchar)(C.CString(cancelLabel))
	defer C.free(unsafe.Pointer(arg5))

	ret := C.gtk_file_chooser_native_new(arg1, arg2, arg3, arg4, arg5)

	var ret0 FileChooserNative

	ret0 = WrapFileChooserNative(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// AcceptLabel retrieves the custom label text for the accept button.
func (self fileChooserNative) AcceptLabel() string {
	var arg0 *C.GtkFileChooserNative

	arg0 = (*C.GtkFileChooserNative)(self.Native())

	ret := C.gtk_file_chooser_native_get_accept_label(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// CancelLabel retrieves the custom label text for the cancel button.
func (self fileChooserNative) CancelLabel() string {
	var arg0 *C.GtkFileChooserNative

	arg0 = (*C.GtkFileChooserNative)(self.Native())

	ret := C.gtk_file_chooser_native_get_cancel_label(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// SetAcceptLabel sets the custom label text for the accept button.
//
// If characters in @label are preceded by an underscore, they are
// underlined. If you need a literal underscore character in a label, use
// “__” (two underscores). The first underlined character represents a
// keyboard accelerator called a mnemonic. Pressing Alt and that key
// activates the button.
func (self fileChooserNative) SetAcceptLabel(acceptLabel string) {
	var arg0 *C.GtkFileChooserNative
	var arg1 *C.char

	arg0 = (*C.GtkFileChooserNative)(self.Native())
	arg1 = (*C.gchar)(C.CString(acceptLabel))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_file_chooser_native_set_accept_label(arg0, arg1)
}

// SetCancelLabel sets the custom label text for the cancel button.
//
// If characters in @label are preceded by an underscore, they are
// underlined. If you need a literal underscore character in a label, use
// “__” (two underscores). The first underlined character represents a
// keyboard accelerator called a mnemonic. Pressing Alt and that key
// activates the button.
func (self fileChooserNative) SetCancelLabel(cancelLabel string) {
	var arg0 *C.GtkFileChooserNative
	var arg1 *C.char

	arg0 = (*C.GtkFileChooserNative)(self.Native())
	arg1 = (*C.gchar)(C.CString(cancelLabel))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_file_chooser_native_set_cancel_label(arg0, arg1)
}

// FileChooserWidget is a widget for choosing files. It exposes the FileChooser
// interface, and you should use the methods of this interface to interact with
// the widget.
//
//
// CSS nodes
//
// GtkFileChooserWidget has a single CSS node with name filechooser.
type FileChooserWidget interface {
	Widget
}

type fileChooserWidget struct {
	widget
}

// WrapFileChooserWidget wraps a GObject to the right type. It is
// primarily used internally.
func WrapFileChooserWidget(obj *externglib.Object) FileChooserWidget {
	return fileChooserWidget{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}
}

func marshalFileChooserWidget(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFileChooserWidget(obj), nil
}

// NewFileChooserWidget constructs a class FileChooserWidget.
func NewFileChooserWidget(action FileChooserAction) FileChooserWidget {
	var arg1 C.GtkFileChooserAction

	arg1 = (C.GtkFileChooserAction)(action)

	ret := C.gtk_file_chooser_widget_new(arg1)

	var ret0 FileChooserWidget

	ret0 = WrapFileChooserWidget(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// FileFilter: a GtkFileFilter can be used to restrict the files being shown in
// a FileChooser. Files can be filtered based on their name (with
// gtk_file_filter_add_pattern()) or on their mime type (with
// gtk_file_filter_add_mime_type()).
//
// Filtering by mime types handles aliasing and subclassing of mime types; e.g.
// a filter for text/plain also matches a file with mime type application/rtf,
// since application/rtf is a subclass of text/plain. Note that FileFilter
// allows wildcards for the subtype of a mime type, so you can e.g. filter for
// image/\*.
//
// Normally, file filters are used by adding them to a FileChooser (see
// gtk_file_chooser_add_filter()), but it is also possible to manually use a
// file filter on any FilterListModel containing Info objects.
//
//
// GtkFileFilter as GtkBuildable
//
// The GtkFileFilter implementation of the GtkBuildable interface supports
// adding rules using the <mime-types> and <patterns> elements and listing the
// rules within. Specifying a <mime-type> or <pattern> has the same effect as as
// calling gtk_file_filter_add_mime_type() or gtk_file_filter_add_pattern().
//
// An example of a UI definition fragment specifying GtkFileFilter rules:
//
//
//    <object class="GtkFileFilter">
//      <property name="name" translatable="yes">Text and Images</property>
//      <mime-types>
//        <mime-type>text/plain</mime-type>
//        <mime-type>image/ *</mime-type>
//      </mime-types>
//      <patterns>
//        <pattern>*.txt</pattern>
//        <pattern>*.png</pattern>
//      </patterns>
//    </object>
//
type FileFilter interface {
	Filter

	// AddMIMEType adds a rule allowing a given mime type to @filter.
	AddMIMEType(mimeType string)
	// AddPattern adds a rule allowing a shell style glob to a filter.
	AddPattern(pattern string)
	// AddPixbufFormats adds a rule allowing image files in the formats
	// supported by GdkPixbuf.
	//
	// This is equivalent to calling gtk_file_filter_add_mime_type() for all the
	// supported mime types.
	AddPixbufFormats()
	// Attributes gets the attributes that need to be filled in for the Info
	// passed to this filter.
	//
	// This function will not typically be used by applications; it is intended
	// principally for use in the implementation of FileChooser.
	Attributes() []string
	// Name gets the human-readable name for the filter. See
	// gtk_file_filter_set_name().
	Name() string
	// SetName sets a human-readable name of the filter; this is the string that
	// will be displayed in the file chooser if there is a selectable list of
	// filters.
	SetName(name string)
	// ToGvariant: serialize a file filter to an a{sv} variant.
	ToGvariant() *glib.Variant
}

type fileFilter struct {
	filter
}

// WrapFileFilter wraps a GObject to the right type. It is
// primarily used internally.
func WrapFileFilter(obj *externglib.Object) FileFilter {
	return fileFilter{filter{*externglib.Object{obj}}}
}

func marshalFileFilter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFileFilter(obj), nil
}

// NewFileFilter constructs a class FileFilter.
func NewFileFilter() FileFilter {

	ret := C.gtk_file_filter_new()

	var ret0 FileFilter

	ret0 = WrapFileFilter(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewFileFilterFromGvariant constructs a class FileFilter.
func NewFileFilterFromGvariant(variant *glib.Variant) FileFilter {
	var arg1 *C.GVariant

	arg1 = (*C.GVariant)(variant.Native())

	ret := C.gtk_file_filter_new_from_gvariant(arg1)

	var ret0 FileFilter

	ret0 = WrapFileFilter(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// AddMIMEType adds a rule allowing a given mime type to @filter.
func (filter fileFilter) AddMIMEType(mimeType string) {
	var arg0 *C.GtkFileFilter
	var arg1 *C.char

	arg0 = (*C.GtkFileFilter)(filter.Native())
	arg1 = (*C.gchar)(C.CString(mimeType))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_file_filter_add_mime_type(arg0, arg1)
}

// AddPattern adds a rule allowing a shell style glob to a filter.
func (filter fileFilter) AddPattern(pattern string) {
	var arg0 *C.GtkFileFilter
	var arg1 *C.char

	arg0 = (*C.GtkFileFilter)(filter.Native())
	arg1 = (*C.gchar)(C.CString(pattern))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_file_filter_add_pattern(arg0, arg1)
}

// AddPixbufFormats adds a rule allowing image files in the formats
// supported by GdkPixbuf.
//
// This is equivalent to calling gtk_file_filter_add_mime_type() for all the
// supported mime types.
func (filter fileFilter) AddPixbufFormats() {
	var arg0 *C.GtkFileFilter

	arg0 = (*C.GtkFileFilter)(filter.Native())

	C.gtk_file_filter_add_pixbuf_formats(arg0)
}

// Attributes gets the attributes that need to be filled in for the Info
// passed to this filter.
//
// This function will not typically be used by applications; it is intended
// principally for use in the implementation of FileChooser.
func (filter fileFilter) Attributes() []string {
	var arg0 *C.GtkFileFilter

	arg0 = (*C.GtkFileFilter)(filter.Native())

	ret := C.gtk_file_filter_get_attributes(arg0)

	var ret0 []string

	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]string, length)
		for i := 0; i < length; i++ {
			src := (C.utf8)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			ret0[i] = C.GoString(src)
		}
	}

	return ret0
}

// Name gets the human-readable name for the filter. See
// gtk_file_filter_set_name().
func (filter fileFilter) Name() string {
	var arg0 *C.GtkFileFilter

	arg0 = (*C.GtkFileFilter)(filter.Native())

	ret := C.gtk_file_filter_get_name(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// SetName sets a human-readable name of the filter; this is the string that
// will be displayed in the file chooser if there is a selectable list of
// filters.
func (filter fileFilter) SetName(name string) {
	var arg0 *C.GtkFileFilter
	var arg1 *C.char

	arg0 = (*C.GtkFileFilter)(filter.Native())
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_file_filter_set_name(arg0, arg1)
}

// ToGvariant: serialize a file filter to an a{sv} variant.
func (filter fileFilter) ToGvariant() *glib.Variant {
	var arg0 *C.GtkFileFilter

	arg0 = (*C.GtkFileFilter)(filter.Native())

	ret := C.gtk_file_filter_to_gvariant(arg0)

	var ret0 *glib.Variant

	ret0 = glib.WrapVariant(ret)

	return ret0
}

// Filter: a Filter object describes the filtering to be performed by a
// FilterListModel.
//
// The model will use the filter to determine if it should include items or not
// by calling gtk_filter_match() for each item and only keeping the ones that
// the function returns true for.
//
// Filters may change what items they match through their lifetime. In that
// case, they will emit the Filter::changed signal to notify that previous
// filter results are no longer valid and that items should be checked again via
// gtk_filter_match().
//
// GTK provides various pre-made filter implementations for common filtering
// operations. These filters often include properties that can be linked to
// various widgets to easily allow searches.
//
// However, in particular for large lists or complex search methods, it is also
// possible to subclass Filter and provide one's own filter.
type Filter interface {
	gextras.Objector

	// Changed emits the Filter::changed signal to notify all users of the
	// filter that the filter changed. Users of the filter should then check
	// items again via gtk_filter_match().
	//
	// Depending on the @change parameter, not all items need to be changed, but
	// only some. Refer to the FilterChange documentation for details.
	//
	// This function is intended for implementors of Filter subclasses and
	// should not be called from other functions.
	Changed(change FilterChange)
	// Strictness gets the known strictness of @filters. If the strictness is
	// not known, GTK_FILTER_MATCH_SOME is returned.
	//
	// This value may change after emission of the Filter::changed signal.
	//
	// This function is meant purely for optimization purposes, filters can
	// choose to omit implementing it, but FilterListModel uses it.
	Strictness() FilterMatch
	// Match checks if the given @item is matched by the filter or not.
	Match(item gextras.Objector) bool
}

type filter struct {
	*externglib.Object
}

// WrapFilter wraps a GObject to the right type. It is
// primarily used internally.
func WrapFilter(obj *externglib.Object) Filter {
	return filter{*externglib.Object{obj}}
}

func marshalFilter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFilter(obj), nil
}

// Changed emits the Filter::changed signal to notify all users of the
// filter that the filter changed. Users of the filter should then check
// items again via gtk_filter_match().
//
// Depending on the @change parameter, not all items need to be changed, but
// only some. Refer to the FilterChange documentation for details.
//
// This function is intended for implementors of Filter subclasses and
// should not be called from other functions.
func (self filter) Changed(change FilterChange) {
	var arg0 *C.GtkFilter
	var arg1 C.GtkFilterChange

	arg0 = (*C.GtkFilter)(self.Native())
	arg1 = (C.GtkFilterChange)(change)

	C.gtk_filter_changed(arg0, arg1)
}

// Strictness gets the known strictness of @filters. If the strictness is
// not known, GTK_FILTER_MATCH_SOME is returned.
//
// This value may change after emission of the Filter::changed signal.
//
// This function is meant purely for optimization purposes, filters can
// choose to omit implementing it, but FilterListModel uses it.
func (self filter) Strictness() FilterMatch {
	var arg0 *C.GtkFilter

	arg0 = (*C.GtkFilter)(self.Native())

	ret := C.gtk_filter_get_strictness(arg0)

	var ret0 FilterMatch

	ret0 = FilterMatch(ret)

	return ret0
}

// Match checks if the given @item is matched by the filter or not.
func (self filter) Match(item gextras.Objector) bool {
	var arg0 *C.GtkFilter
	var arg1 C.gpointer

	arg0 = (*C.GtkFilter)(self.Native())
	arg1 = (*C.GObject)(item.Native())

	ret := C.gtk_filter_match(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// FilterListModel is a list model that filters a given other listmodel. It
// hides some elements from the other model according to criteria given by a
// Filter.
//
// The model can be set up to do incremental searching, so that filtering long
// lists doesn't block the UI. See gtk_filter_list_model_set_incremental() for
// details.
type FilterListModel interface {
	gextras.Objector

	// Filter gets the Filter currently set on @self.
	Filter() Filter
	// Incremental returns whether incremental filtering was enabled via
	// gtk_filter_list_model_set_incremental().
	Incremental() bool
	// Model gets the model currently filtered or nil if none.
	Model() gio.ListModel
	// Pending returns the number of items that have not been filtered yet.
	//
	// You can use this value to check if @self is busy filtering by comparing
	// the return value to 0 or you can compute the percentage of the filter
	// remaining by dividing the return value by the total number of items in
	// the underlying model:
	//
	//
	//      pending = gtk_filter_list_model_get_pending (self);
	//      model = gtk_filter_list_model_get_model (self);
	//      percentage = pending / (double) g_list_model_get_n_items (model);
	//
	//
	// If no filter operation is ongoing - in particular when
	// FilterListModel:incremental is false - this function returns 0.
	Pending() uint
	// SetFilter sets the filter used to filter items.
	SetFilter(filter Filter)
	// SetIncremental: when incremental filtering is enabled, the
	// GtkFilterListModel will not run filters immediately, but will instead
	// queue an idle handler that incrementally filters the items and adds them
	// to the list. This of course means that items are not instantly added to
	// the list, but only appear incrementally.
	//
	// When your filter blocks the UI while filtering, you might consider
	// turning this on. Depending on your model and filters, this may become
	// interesting around 10,000 to 100,000 items.
	//
	// By default, incremental filtering is disabled.
	//
	// See gtk_filter_list_model_get_pending() for progress information about an
	// ongoing incremental filtering operation.
	SetIncremental(incremental bool)
	// SetModel sets the model to be filtered.
	//
	// Note that GTK makes no effort to ensure that @model conforms to the item
	// type of @self. It assumes that the caller knows what they are doing and
	// have set up an appropriate filter to ensure that item types match.
	SetModel(model gio.ListModel)
}

type filterListModel struct {
	*externglib.Object
}

// WrapFilterListModel wraps a GObject to the right type. It is
// primarily used internally.
func WrapFilterListModel(obj *externglib.Object) FilterListModel {
	return filterListModel{*externglib.Object{obj}}
}

func marshalFilterListModel(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFilterListModel(obj), nil
}

// NewFilterListModel constructs a class FilterListModel.
func NewFilterListModel(model gio.ListModel, filter Filter) FilterListModel {
	var arg1 *C.GListModel
	var arg2 *C.GtkFilter

	arg2 = (*C.GtkFilter)(filter.Native())

	ret := C.gtk_filter_list_model_new(arg1, arg2)

	var ret0 FilterListModel

	ret0 = WrapFilterListModel(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Filter gets the Filter currently set on @self.
func (self filterListModel) Filter() Filter {
	var arg0 *C.GtkFilterListModel

	arg0 = (*C.GtkFilterListModel)(self.Native())

	ret := C.gtk_filter_list_model_get_filter(arg0)

	var ret0 Filter

	ret0 = WrapFilter(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Incremental returns whether incremental filtering was enabled via
// gtk_filter_list_model_set_incremental().
func (self filterListModel) Incremental() bool {
	var arg0 *C.GtkFilterListModel

	arg0 = (*C.GtkFilterListModel)(self.Native())

	ret := C.gtk_filter_list_model_get_incremental(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Model gets the model currently filtered or nil if none.
func (self filterListModel) Model() gio.ListModel {
	var arg0 *C.GtkFilterListModel

	arg0 = (*C.GtkFilterListModel)(self.Native())

	ret := C.gtk_filter_list_model_get_model(arg0)

	var ret0 gio.ListModel

	return ret0
}

// Pending returns the number of items that have not been filtered yet.
//
// You can use this value to check if @self is busy filtering by comparing
// the return value to 0 or you can compute the percentage of the filter
// remaining by dividing the return value by the total number of items in
// the underlying model:
//
//
//      pending = gtk_filter_list_model_get_pending (self);
//      model = gtk_filter_list_model_get_model (self);
//      percentage = pending / (double) g_list_model_get_n_items (model);
//
//
// If no filter operation is ongoing - in particular when
// FilterListModel:incremental is false - this function returns 0.
func (self filterListModel) Pending() uint {
	var arg0 *C.GtkFilterListModel

	arg0 = (*C.GtkFilterListModel)(self.Native())

	ret := C.gtk_filter_list_model_get_pending(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// SetFilter sets the filter used to filter items.
func (self filterListModel) SetFilter(filter Filter) {
	var arg0 *C.GtkFilterListModel
	var arg1 *C.GtkFilter

	arg0 = (*C.GtkFilterListModel)(self.Native())
	arg1 = (*C.GtkFilter)(filter.Native())

	C.gtk_filter_list_model_set_filter(arg0, arg1)
}

// SetIncremental: when incremental filtering is enabled, the
// GtkFilterListModel will not run filters immediately, but will instead
// queue an idle handler that incrementally filters the items and adds them
// to the list. This of course means that items are not instantly added to
// the list, but only appear incrementally.
//
// When your filter blocks the UI while filtering, you might consider
// turning this on. Depending on your model and filters, this may become
// interesting around 10,000 to 100,000 items.
//
// By default, incremental filtering is disabled.
//
// See gtk_filter_list_model_get_pending() for progress information about an
// ongoing incremental filtering operation.
func (self filterListModel) SetIncremental(incremental bool) {
	var arg0 *C.GtkFilterListModel
	var arg1 C.gboolean

	arg0 = (*C.GtkFilterListModel)(self.Native())
	arg1 = gextras.Cbool(incremental)

	C.gtk_filter_list_model_set_incremental(arg0, arg1)
}

// SetModel sets the model to be filtered.
//
// Note that GTK makes no effort to ensure that @model conforms to the item
// type of @self. It assumes that the caller knows what they are doing and
// have set up an appropriate filter to ensure that item types match.
func (self filterListModel) SetModel(model gio.ListModel) {
	var arg0 *C.GtkFilterListModel
	var arg1 *C.GListModel

	arg0 = (*C.GtkFilterListModel)(self.Native())

	C.gtk_filter_list_model_set_model(arg0, arg1)
}

// Fixed: the Fixed widget is a container which can place child widgets at fixed
// positions and with fixed sizes, given in pixels. Fixed performs no automatic
// layout management.
//
// For most applications, you should not use this container! It keeps you from
// having to learn about the other GTK+ containers, but it results in broken
// applications. With Fixed, the following things will result in truncated text,
// overlapping widgets, and other display bugs:
//
// - Themes, which may change widget sizes.
//
// - Fonts other than the one you used to write the app will of course change
// the size of widgets containing text; keep in mind that users may use a larger
// font because of difficulty reading the default, or they may be using a
// different OS that provides different fonts.
//
// - Translation of text into other languages changes its size. Also, display of
// non-English text will use a different font in many cases.
//
// In addition, Fixed does not pay attention to text direction and thus may
// produce unwanted results if your app is run under right-to-left languages
// such as Hebrew or Arabic. That is: normally GTK will order containers
// appropriately for the text direction, e.g. to put labels to the right of the
// thing they label when using an RTL language, but it can’t do that with Fixed.
// So if you need to reorder widgets depending on the text direction, you would
// need to manually detect it and adjust child positions accordingly.
//
// Finally, fixed positioning makes it kind of annoying to add/remove GUI
// elements, since you have to reposition all the other elements. This is a
// long-term maintenance problem for your application.
//
// If you know none of these things are an issue for your application, and
// prefer the simplicity of Fixed, by all means use the widget. But you should
// be aware of the tradeoffs.
type Fixed interface {
	Widget

	// ChildPosition retrieves the translation transformation of the given child
	// Widget in the given Fixed container.
	//
	// See also: gtk_fixed_get_child_transform().
	ChildPosition(widget Widget) (x float64, y float64)
	// ChildTransform retrieves the transformation for @widget set using
	// gtk_fixed_set_child_transform().
	ChildTransform(widget Widget) *gsk.Transform
	// Move sets a translation transformation to the given @x and @y coordinates
	// to the child @widget of the given Fixed container.
	Move(widget Widget, x float64, y float64)
	// Put adds a widget to a Fixed container and assigns a translation
	// transformation to the given @x and @y coordinates to it.
	Put(widget Widget, x float64, y float64)
	// Remove removes a child from @fixed, after it has been added with
	// gtk_fixed_put().
	Remove(widget Widget)
	// SetChildTransform sets the transformation for @widget.
	//
	// This is a convenience function that retrieves the FixedLayoutChild
	// instance associated to @widget and calls
	// gtk_fixed_layout_child_set_transform().
	SetChildTransform(widget Widget, transform *gsk.Transform)
}

type fixed struct {
	widget
}

// WrapFixed wraps a GObject to the right type. It is
// primarily used internally.
func WrapFixed(obj *externglib.Object) Fixed {
	return fixed{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}
}

func marshalFixed(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFixed(obj), nil
}

// NewFixed constructs a class Fixed.
func NewFixed() Fixed {

	ret := C.gtk_fixed_new()

	var ret0 Fixed

	ret0 = WrapFixed(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// ChildPosition retrieves the translation transformation of the given child
// Widget in the given Fixed container.
//
// See also: gtk_fixed_get_child_transform().
func (fixed fixed) ChildPosition(widget Widget) (x float64, y float64) {
	var arg0 *C.GtkFixed
	var arg1 *C.GtkWidget
	var arg2 *C.double // out
	var arg3 *C.double // out

	arg0 = (*C.GtkFixed)(fixed.Native())
	arg1 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_fixed_get_child_position(arg0, arg1, &arg2, &arg3)

	var ret0 float64
	var ret1 float64

	ret0 = float64(arg2)

	ret1 = float64(arg3)

	return ret0, ret1
}

// ChildTransform retrieves the transformation for @widget set using
// gtk_fixed_set_child_transform().
func (fixed fixed) ChildTransform(widget Widget) *gsk.Transform {
	var arg0 *C.GtkFixed
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkFixed)(fixed.Native())
	arg1 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_fixed_get_child_transform(arg0, arg1)

	var ret0 *gsk.Transform

	ret0 = gsk.WrapTransform(ret)

	return ret0
}

// Move sets a translation transformation to the given @x and @y coordinates
// to the child @widget of the given Fixed container.
func (fixed fixed) Move(widget Widget, x float64, y float64) {
	var arg0 *C.GtkFixed
	var arg1 *C.GtkWidget
	var arg2 C.double
	var arg3 C.double

	arg0 = (*C.GtkFixed)(fixed.Native())
	arg1 = (*C.GtkWidget)(widget.Native())
	arg2 = C.double(x)
	arg3 = C.double(y)

	C.gtk_fixed_move(arg0, arg1, arg2, arg3)
}

// Put adds a widget to a Fixed container and assigns a translation
// transformation to the given @x and @y coordinates to it.
func (fixed fixed) Put(widget Widget, x float64, y float64) {
	var arg0 *C.GtkFixed
	var arg1 *C.GtkWidget
	var arg2 C.double
	var arg3 C.double

	arg0 = (*C.GtkFixed)(fixed.Native())
	arg1 = (*C.GtkWidget)(widget.Native())
	arg2 = C.double(x)
	arg3 = C.double(y)

	C.gtk_fixed_put(arg0, arg1, arg2, arg3)
}

// Remove removes a child from @fixed, after it has been added with
// gtk_fixed_put().
func (fixed fixed) Remove(widget Widget) {
	var arg0 *C.GtkFixed
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkFixed)(fixed.Native())
	arg1 = (*C.GtkWidget)(widget.Native())

	C.gtk_fixed_remove(arg0, arg1)
}

// SetChildTransform sets the transformation for @widget.
//
// This is a convenience function that retrieves the FixedLayoutChild
// instance associated to @widget and calls
// gtk_fixed_layout_child_set_transform().
func (fixed fixed) SetChildTransform(widget Widget, transform *gsk.Transform) {
	var arg0 *C.GtkFixed
	var arg1 *C.GtkWidget
	var arg2 *C.GskTransform

	arg0 = (*C.GtkFixed)(fixed.Native())
	arg1 = (*C.GtkWidget)(widget.Native())
	arg2 = (*C.GskTransform)(transform.Native())

	C.gtk_fixed_set_child_transform(arg0, arg1, arg2)
}

// FixedLayout is a layout manager which can place child widgets at fixed
// positions, and with fixed sizes.
//
// Most applications should never use this layout manager; fixed positioning and
// sizing requires constant recalculations on where children need to be
// positioned and sized. Other layout managers perform this kind of work
// internally so that application developers don't need to do it. Specifically,
// widgets positioned in a fixed layout manager will need to take into account:
//
// - Themes, which may change widget sizes.
//
// - Fonts other than the one you used to write the app will of course change
// the size of widgets containing text; keep in mind that users may use a larger
// font because of difficulty reading the default, or they may be using a
// different OS that provides different fonts.
//
// - Translation of text into other languages changes its size. Also, display of
// non-English text will use a different font in many cases.
//
// In addition, FixedLayout does not pay attention to text direction and thus
// may produce unwanted results if your app is run under right-to-left languages
// such as Hebrew or Arabic. That is: normally GTK will order containers
// appropriately depending on the text direction, e.g. to put labels to the
// right of the thing they label when using an RTL language; FixedLayout won't
// be able to do that for you.
//
// Finally, fixed positioning makes it kind of annoying to add/remove GUI
// elements, since you have to reposition all the other elements. This is a
// long-term maintenance problem for your application.
type FixedLayout interface {
	LayoutManager
}

type fixedLayout struct {
	layoutManager
}

// WrapFixedLayout wraps a GObject to the right type. It is
// primarily used internally.
func WrapFixedLayout(obj *externglib.Object) FixedLayout {
	return fixedLayout{layoutManager{*externglib.Object{obj}}}
}

func marshalFixedLayout(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFixedLayout(obj), nil
}

// NewFixedLayout constructs a class FixedLayout.
func NewFixedLayout() FixedLayout {

	ret := C.gtk_fixed_layout_new()

	var ret0 FixedLayout

	ret0 = WrapFixedLayout(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

type FixedLayoutChild interface {
	LayoutChild

	// Transform retrieves the transformation of the child of a FixedLayout.
	Transform() *gsk.Transform
	// SetTransform sets the transformation of the child of a FixedLayout.
	SetTransform(transform *gsk.Transform)
}

type fixedLayoutChild struct {
	layoutChild
}

// WrapFixedLayoutChild wraps a GObject to the right type. It is
// primarily used internally.
func WrapFixedLayoutChild(obj *externglib.Object) FixedLayoutChild {
	return fixedLayoutChild{layoutChild{*externglib.Object{obj}}}
}

func marshalFixedLayoutChild(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFixedLayoutChild(obj), nil
}

// Transform retrieves the transformation of the child of a FixedLayout.
func (child fixedLayoutChild) Transform() *gsk.Transform {
	var arg0 *C.GtkFixedLayoutChild

	arg0 = (*C.GtkFixedLayoutChild)(child.Native())

	ret := C.gtk_fixed_layout_child_get_transform(arg0)

	var ret0 *gsk.Transform

	ret0 = gsk.WrapTransform(ret)

	return ret0
}

// SetTransform sets the transformation of the child of a FixedLayout.
func (child fixedLayoutChild) SetTransform(transform *gsk.Transform) {
	var arg0 *C.GtkFixedLayoutChild
	var arg1 *C.GskTransform

	arg0 = (*C.GtkFixedLayoutChild)(child.Native())
	arg1 = (*C.GskTransform)(transform.Native())

	C.gtk_fixed_layout_child_set_transform(arg0, arg1)
}

// FlattenListModel is a list model that takes a list model containing list
// models and flattens it into a single model.
//
// Another term for this is concatenation: FlattenListModel takes a list of
// lists and concatenates them into a single list.
type FlattenListModel interface {
	gextras.Objector

	// Model gets the model set via gtk_flatten_list_model_set_model().
	Model() gio.ListModel
	// ModelForItem returns the model containing the item at the given position.
	ModelForItem(position uint) gio.ListModel
	// SetModel sets a new model to be flattened.
	SetModel(model gio.ListModel)
}

type flattenListModel struct {
	*externglib.Object
}

// WrapFlattenListModel wraps a GObject to the right type. It is
// primarily used internally.
func WrapFlattenListModel(obj *externglib.Object) FlattenListModel {
	return flattenListModel{*externglib.Object{obj}}
}

func marshalFlattenListModel(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFlattenListModel(obj), nil
}

// NewFlattenListModel constructs a class FlattenListModel.
func NewFlattenListModel(model gio.ListModel) FlattenListModel {
	var arg1 *C.GListModel

	ret := C.gtk_flatten_list_model_new(arg1)

	var ret0 FlattenListModel

	ret0 = WrapFlattenListModel(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Model gets the model set via gtk_flatten_list_model_set_model().
func (self flattenListModel) Model() gio.ListModel {
	var arg0 *C.GtkFlattenListModel

	arg0 = (*C.GtkFlattenListModel)(self.Native())

	ret := C.gtk_flatten_list_model_get_model(arg0)

	var ret0 gio.ListModel

	return ret0
}

// ModelForItem returns the model containing the item at the given position.
func (self flattenListModel) ModelForItem(position uint) gio.ListModel {
	var arg0 *C.GtkFlattenListModel
	var arg1 C.guint

	arg0 = (*C.GtkFlattenListModel)(self.Native())
	arg1 = C.guint(position)

	ret := C.gtk_flatten_list_model_get_model_for_item(arg0, arg1)

	var ret0 gio.ListModel

	return ret0
}

// SetModel sets a new model to be flattened.
func (self flattenListModel) SetModel(model gio.ListModel) {
	var arg0 *C.GtkFlattenListModel
	var arg1 *C.GListModel

	arg0 = (*C.GtkFlattenListModel)(self.Native())

	C.gtk_flatten_list_model_set_model(arg0, arg1)
}

// FlowBox: a GtkFlowBox positions child widgets in sequence according to its
// orientation.
//
// For instance, with the horizontal orientation, the widgets will be arranged
// from left to right, starting a new row under the previous row when necessary.
// Reducing the width in this case will require more rows, so a larger height
// will be requested.
//
// Likewise, with the vertical orientation, the widgets will be arranged from
// top to bottom, starting a new column to the right when necessary. Reducing
// the height will require more columns, so a larger width will be requested.
//
// The size request of a GtkFlowBox alone may not be what you expect; if you
// need to be able to shrink it along both axes and dynamically reflow its
// children, you may have to wrap it in a ScrolledWindow to enable that.
//
// The children of a GtkFlowBox can be dynamically sorted and filtered.
//
// Although a GtkFlowBox must have only FlowBoxChild children, you can add any
// kind of widget to it via gtk_flow_box_insert(), and a GtkFlowBoxChild widget
// will automatically be inserted between the box and the widget.
//
// Also see ListBox.
//
// CSS nodes
//
//    flowbox
//    ├── flowboxchild
//    │   ╰── <child>
//    ├── flowboxchild
//    │   ╰── <child>
//    ┊
//    ╰── [rubberband]
//
//
// GtkFlowBox uses a single CSS node with name flowbox. GtkFlowBoxChild uses a
// single CSS node with name flowboxchild. For rubberband selection, a subnode
// with name rubberband is used.
//
//
// Accessibility
//
// GtkFlowBox uses the K_ACCESSIBLE_ROLE_GRID role, and GtkFlowBoxChild uses the
// K_ACCESSIBLE_ROLE_GRID_CELL role.
type FlowBox interface {
	Widget

	// BindModel binds @model to @box.
	//
	// If @box was already bound to a model, that previous binding is destroyed.
	//
	// The contents of @box are cleared and then filled with widgets that
	// represent items from @model. @box is updated whenever @model changes. If
	// @model is nil, @box is left empty.
	//
	// It is undefined to add or remove widgets directly (for example, with
	// gtk_flow_box_insert()) while @box is bound to a model.
	//
	// Note that using a model is incompatible with the filtering and sorting
	// functionality in GtkFlowBox. When using a model, filtering and sorting
	// should be implemented by the model.
	BindModel(model gio.ListModel, createWidgetFunc FlowBoxCreateWidgetFunc)
	// ActivateOnSingleClick returns whether children activate on single clicks.
	ActivateOnSingleClick() bool
	// ChildAtIndex gets the nth child in the @box.
	ChildAtIndex(idx int) FlowBoxChild
	// ChildAtPos gets the child in the (@x, @y) position. Both @x and @y are
	// assumed to be relative to the origin of @box.
	ChildAtPos(x int, y int) FlowBoxChild
	// ColumnSpacing gets the horizontal spacing.
	ColumnSpacing() uint
	// Homogeneous returns whether the box is homogeneous (all children are the
	// same size). See gtk_box_set_homogeneous().
	Homogeneous() bool
	// MaxChildrenPerLine gets the maximum number of children per line.
	MaxChildrenPerLine() uint
	// MinChildrenPerLine gets the minimum number of children per line.
	MinChildrenPerLine() uint
	// RowSpacing gets the vertical spacing.
	RowSpacing() uint
	// SelectedChildren creates a list of all selected children.
	SelectedChildren() *glib.List
	// SelectionMode gets the selection mode of @box.
	SelectionMode() SelectionMode
	// Insert inserts the @widget into @box at @position.
	//
	// If a sort function is set, the widget will actually be inserted at the
	// calculated position.
	//
	// If @position is -1, or larger than the total number of children in the
	// @box, then the @widget will be appended to the end.
	Insert(widget Widget, position int)
	// InvalidateFilter updates the filtering for all children.
	//
	// Call this function when the result of the filter function on the @box is
	// changed due ot an external factor. For instance, this would be used if
	// the filter function just looked for a specific search term, and the entry
	// with the string has changed.
	InvalidateFilter()
	// InvalidateSort updates the sorting for all children.
	//
	// Call this when the result of the sort function on @box is changed due to
	// an external factor.
	InvalidateSort()
	// Remove removes a child from @box.
	Remove(widget Widget)
	// SelectAll: select all children of @box, if the selection mode allows it.
	SelectAll()
	// SelectChild selects a single child of @box, if the selection mode allows
	// it.
	SelectChild(child FlowBoxChild)
	// SelectedForeach calls a function for each selected child.
	//
	// Note that the selection cannot be modified from within this function.
	SelectedForeach(_func FlowBoxForeachFunc)
	// SetActivateOnSingleClick: if @single is true, children will be activated
	// when you click on them, otherwise you need to double-click.
	SetActivateOnSingleClick(single bool)
	// SetColumnSpacing sets the horizontal space to add between children. See
	// the FlowBox:column-spacing property.
	SetColumnSpacing(spacing uint)
	// SetFilterFunc: by setting a filter function on the @box one can decide
	// dynamically which of the children to show. For instance, to implement a
	// search function that only shows the children matching the search terms.
	//
	// The @filter_func will be called for each child after the call, and it
	// will continue to be called each time a child changes (via
	// gtk_flow_box_child_changed()) or when gtk_flow_box_invalidate_filter() is
	// called.
	//
	// Note that using a filter function is incompatible with using a model (see
	// gtk_flow_box_bind_model()).
	SetFilterFunc(filterFunc FlowBoxFilterFunc)
	// SetHadjustment hooks up an adjustment to focus handling in @box. The
	// adjustment is also used for autoscrolling during rubberband selection.
	// See gtk_scrolled_window_get_hadjustment() for a typical way of obtaining
	// the adjustment, and gtk_flow_box_set_vadjustment()for setting the
	// vertical adjustment.
	//
	// The adjustments have to be in pixel units and in the same coordinate
	// system as the allocation for immediate children of the box.
	SetHadjustment(adjustment Adjustment)
	// SetHomogeneous sets the FlowBox:homogeneous property of @box, controlling
	// whether or not all children of @box are given equal space in the box.
	SetHomogeneous(homogeneous bool)
	// SetMaxChildrenPerLine sets the maximum number of children to request and
	// allocate space for in @box’s orientation.
	//
	// Setting the maximum number of children per line limits the overall
	// natural size request to be no more than @n_children children long in the
	// given orientation.
	SetMaxChildrenPerLine(nChildren uint)
	// SetMinChildrenPerLine sets the minimum number of children to line up in
	// @box’s orientation before flowing.
	SetMinChildrenPerLine(nChildren uint)
	// SetRowSpacing sets the vertical space to add between children. See the
	// FlowBox:row-spacing property.
	SetRowSpacing(spacing uint)
	// SetSelectionMode sets how selection works in @box. See SelectionMode for
	// details.
	SetSelectionMode(mode SelectionMode)
	// SetSortFunc: by setting a sort function on the @box, one can dynamically
	// reorder the children of the box, based on the contents of the children.
	//
	// The @sort_func will be called for each child after the call, and will
	// continue to be called each time a child changes (via
	// gtk_flow_box_child_changed()) and when gtk_flow_box_invalidate_sort() is
	// called.
	//
	// Note that using a sort function is incompatible with using a model (see
	// gtk_flow_box_bind_model()).
	SetSortFunc(sortFunc FlowBoxSortFunc)
	// SetVadjustment hooks up an adjustment to focus handling in @box. The
	// adjustment is also used for autoscrolling during rubberband selection.
	// See gtk_scrolled_window_get_vadjustment() for a typical way of obtaining
	// the adjustment, and gtk_flow_box_set_hadjustment()for setting the
	// horizontal adjustment.
	//
	// The adjustments have to be in pixel units and in the same coordinate
	// system as the allocation for immediate children of the box.
	SetVadjustment(adjustment Adjustment)
	// UnselectAll: unselect all children of @box, if the selection mode allows
	// it.
	UnselectAll()
	// UnselectChild unselects a single child of @box, if the selection mode
	// allows it.
	UnselectChild(child FlowBoxChild)
}

type flowBox struct {
	widget
}

// WrapFlowBox wraps a GObject to the right type. It is
// primarily used internally.
func WrapFlowBox(obj *externglib.Object) FlowBox {
	return flowBox{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}
}

func marshalFlowBox(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFlowBox(obj), nil
}

// NewFlowBox constructs a class FlowBox.
func NewFlowBox() FlowBox {

	ret := C.gtk_flow_box_new()

	var ret0 FlowBox

	ret0 = WrapFlowBox(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// BindModel binds @model to @box.
//
// If @box was already bound to a model, that previous binding is destroyed.
//
// The contents of @box are cleared and then filled with widgets that
// represent items from @model. @box is updated whenever @model changes. If
// @model is nil, @box is left empty.
//
// It is undefined to add or remove widgets directly (for example, with
// gtk_flow_box_insert()) while @box is bound to a model.
//
// Note that using a model is incompatible with the filtering and sorting
// functionality in GtkFlowBox. When using a model, filtering and sorting
// should be implemented by the model.
func (box flowBox) BindModel(model gio.ListModel, createWidgetFunc FlowBoxCreateWidgetFunc) {
	var arg0 *C.GtkFlowBox
	var arg1 *C.GListModel
	var arg2 C.GtkFlowBoxCreateWidgetFunc
	arg3 := C.gpointer(box.Assign(userData))

	arg0 = (*C.GtkFlowBox)(box.Native())
	arg2 = (*[0]byte)(C.gotk4_FlowBoxCreateWidgetFunc)

	C.gtk_flow_box_bind_model(arg0, arg1, arg2, (*[0]byte)(C.callbackDelete))
}

// ActivateOnSingleClick returns whether children activate on single clicks.
func (box flowBox) ActivateOnSingleClick() bool {
	var arg0 *C.GtkFlowBox

	arg0 = (*C.GtkFlowBox)(box.Native())

	ret := C.gtk_flow_box_get_activate_on_single_click(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// ChildAtIndex gets the nth child in the @box.
func (box flowBox) ChildAtIndex(idx int) FlowBoxChild {
	var arg0 *C.GtkFlowBox
	var arg1 C.int

	arg0 = (*C.GtkFlowBox)(box.Native())
	arg1 = C.int(idx)

	ret := C.gtk_flow_box_get_child_at_index(arg0, arg1)

	var ret0 FlowBoxChild

	ret0 = WrapFlowBoxChild(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// ChildAtPos gets the child in the (@x, @y) position. Both @x and @y are
// assumed to be relative to the origin of @box.
func (box flowBox) ChildAtPos(x int, y int) FlowBoxChild {
	var arg0 *C.GtkFlowBox
	var arg1 C.int
	var arg2 C.int

	arg0 = (*C.GtkFlowBox)(box.Native())
	arg1 = C.int(x)
	arg2 = C.int(y)

	ret := C.gtk_flow_box_get_child_at_pos(arg0, arg1, arg2)

	var ret0 FlowBoxChild

	ret0 = WrapFlowBoxChild(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// ColumnSpacing gets the horizontal spacing.
func (box flowBox) ColumnSpacing() uint {
	var arg0 *C.GtkFlowBox

	arg0 = (*C.GtkFlowBox)(box.Native())

	ret := C.gtk_flow_box_get_column_spacing(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// Homogeneous returns whether the box is homogeneous (all children are the
// same size). See gtk_box_set_homogeneous().
func (box flowBox) Homogeneous() bool {
	var arg0 *C.GtkFlowBox

	arg0 = (*C.GtkFlowBox)(box.Native())

	ret := C.gtk_flow_box_get_homogeneous(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// MaxChildrenPerLine gets the maximum number of children per line.
func (box flowBox) MaxChildrenPerLine() uint {
	var arg0 *C.GtkFlowBox

	arg0 = (*C.GtkFlowBox)(box.Native())

	ret := C.gtk_flow_box_get_max_children_per_line(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// MinChildrenPerLine gets the minimum number of children per line.
func (box flowBox) MinChildrenPerLine() uint {
	var arg0 *C.GtkFlowBox

	arg0 = (*C.GtkFlowBox)(box.Native())

	ret := C.gtk_flow_box_get_min_children_per_line(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// RowSpacing gets the vertical spacing.
func (box flowBox) RowSpacing() uint {
	var arg0 *C.GtkFlowBox

	arg0 = (*C.GtkFlowBox)(box.Native())

	ret := C.gtk_flow_box_get_row_spacing(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// SelectedChildren creates a list of all selected children.
func (box flowBox) SelectedChildren() *glib.List {
	var arg0 *C.GtkFlowBox

	arg0 = (*C.GtkFlowBox)(box.Native())

	ret := C.gtk_flow_box_get_selected_children(arg0)

	var ret0 *glib.List

	ret0 = glib.WrapList(ret)

	return ret0
}

// SelectionMode gets the selection mode of @box.
func (box flowBox) SelectionMode() SelectionMode {
	var arg0 *C.GtkFlowBox

	arg0 = (*C.GtkFlowBox)(box.Native())

	ret := C.gtk_flow_box_get_selection_mode(arg0)

	var ret0 SelectionMode

	ret0 = SelectionMode(ret)

	return ret0
}

// Insert inserts the @widget into @box at @position.
//
// If a sort function is set, the widget will actually be inserted at the
// calculated position.
//
// If @position is -1, or larger than the total number of children in the
// @box, then the @widget will be appended to the end.
func (box flowBox) Insert(widget Widget, position int) {
	var arg0 *C.GtkFlowBox
	var arg1 *C.GtkWidget
	var arg2 C.int

	arg0 = (*C.GtkFlowBox)(box.Native())
	arg1 = (*C.GtkWidget)(widget.Native())
	arg2 = C.int(position)

	C.gtk_flow_box_insert(arg0, arg1, arg2)
}

// InvalidateFilter updates the filtering for all children.
//
// Call this function when the result of the filter function on the @box is
// changed due ot an external factor. For instance, this would be used if
// the filter function just looked for a specific search term, and the entry
// with the string has changed.
func (box flowBox) InvalidateFilter() {
	var arg0 *C.GtkFlowBox

	arg0 = (*C.GtkFlowBox)(box.Native())

	C.gtk_flow_box_invalidate_filter(arg0)
}

// InvalidateSort updates the sorting for all children.
//
// Call this when the result of the sort function on @box is changed due to
// an external factor.
func (box flowBox) InvalidateSort() {
	var arg0 *C.GtkFlowBox

	arg0 = (*C.GtkFlowBox)(box.Native())

	C.gtk_flow_box_invalidate_sort(arg0)
}

// Remove removes a child from @box.
func (box flowBox) Remove(widget Widget) {
	var arg0 *C.GtkFlowBox
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkFlowBox)(box.Native())
	arg1 = (*C.GtkWidget)(widget.Native())

	C.gtk_flow_box_remove(arg0, arg1)
}

// SelectAll: select all children of @box, if the selection mode allows it.
func (box flowBox) SelectAll() {
	var arg0 *C.GtkFlowBox

	arg0 = (*C.GtkFlowBox)(box.Native())

	C.gtk_flow_box_select_all(arg0)
}

// SelectChild selects a single child of @box, if the selection mode allows
// it.
func (box flowBox) SelectChild(child FlowBoxChild) {
	var arg0 *C.GtkFlowBox
	var arg1 *C.GtkFlowBoxChild

	arg0 = (*C.GtkFlowBox)(box.Native())
	arg1 = (*C.GtkFlowBoxChild)(child.Native())

	C.gtk_flow_box_select_child(arg0, arg1)
}

// SelectedForeach calls a function for each selected child.
//
// Note that the selection cannot be modified from within this function.
func (box flowBox) SelectedForeach(_func FlowBoxForeachFunc) {
	var arg0 *C.GtkFlowBox
	var arg1 C.GtkFlowBoxForeachFunc
	arg2 := C.gpointer(box.Assign(data))

	arg0 = (*C.GtkFlowBox)(box.Native())
	arg1 = (*[0]byte)(C.gotk4_FlowBoxForeachFunc)

	C.gtk_flow_box_selected_foreach(arg0, arg1)
}

// SetActivateOnSingleClick: if @single is true, children will be activated
// when you click on them, otherwise you need to double-click.
func (box flowBox) SetActivateOnSingleClick(single bool) {
	var arg0 *C.GtkFlowBox
	var arg1 C.gboolean

	arg0 = (*C.GtkFlowBox)(box.Native())
	arg1 = gextras.Cbool(single)

	C.gtk_flow_box_set_activate_on_single_click(arg0, arg1)
}

// SetColumnSpacing sets the horizontal space to add between children. See
// the FlowBox:column-spacing property.
func (box flowBox) SetColumnSpacing(spacing uint) {
	var arg0 *C.GtkFlowBox
	var arg1 C.guint

	arg0 = (*C.GtkFlowBox)(box.Native())
	arg1 = C.guint(spacing)

	C.gtk_flow_box_set_column_spacing(arg0, arg1)
}

// SetFilterFunc: by setting a filter function on the @box one can decide
// dynamically which of the children to show. For instance, to implement a
// search function that only shows the children matching the search terms.
//
// The @filter_func will be called for each child after the call, and it
// will continue to be called each time a child changes (via
// gtk_flow_box_child_changed()) or when gtk_flow_box_invalidate_filter() is
// called.
//
// Note that using a filter function is incompatible with using a model (see
// gtk_flow_box_bind_model()).
func (box flowBox) SetFilterFunc(filterFunc FlowBoxFilterFunc) {
	var arg0 *C.GtkFlowBox
	var arg1 C.GtkFlowBoxFilterFunc
	arg2 := C.gpointer(box.Assign(userData))

	arg0 = (*C.GtkFlowBox)(box.Native())
	arg1 = (*[0]byte)(C.gotk4_FlowBoxFilterFunc)

	C.gtk_flow_box_set_filter_func(arg0, arg1, (*[0]byte)(C.callbackDelete))
}

// SetHadjustment hooks up an adjustment to focus handling in @box. The
// adjustment is also used for autoscrolling during rubberband selection.
// See gtk_scrolled_window_get_hadjustment() for a typical way of obtaining
// the adjustment, and gtk_flow_box_set_vadjustment()for setting the
// vertical adjustment.
//
// The adjustments have to be in pixel units and in the same coordinate
// system as the allocation for immediate children of the box.
func (box flowBox) SetHadjustment(adjustment Adjustment) {
	var arg0 *C.GtkFlowBox
	var arg1 *C.GtkAdjustment

	arg0 = (*C.GtkFlowBox)(box.Native())
	arg1 = (*C.GtkAdjustment)(adjustment.Native())

	C.gtk_flow_box_set_hadjustment(arg0, arg1)
}

// SetHomogeneous sets the FlowBox:homogeneous property of @box, controlling
// whether or not all children of @box are given equal space in the box.
func (box flowBox) SetHomogeneous(homogeneous bool) {
	var arg0 *C.GtkFlowBox
	var arg1 C.gboolean

	arg0 = (*C.GtkFlowBox)(box.Native())
	arg1 = gextras.Cbool(homogeneous)

	C.gtk_flow_box_set_homogeneous(arg0, arg1)
}

// SetMaxChildrenPerLine sets the maximum number of children to request and
// allocate space for in @box’s orientation.
//
// Setting the maximum number of children per line limits the overall
// natural size request to be no more than @n_children children long in the
// given orientation.
func (box flowBox) SetMaxChildrenPerLine(nChildren uint) {
	var arg0 *C.GtkFlowBox
	var arg1 C.guint

	arg0 = (*C.GtkFlowBox)(box.Native())
	arg1 = C.guint(nChildren)

	C.gtk_flow_box_set_max_children_per_line(arg0, arg1)
}

// SetMinChildrenPerLine sets the minimum number of children to line up in
// @box’s orientation before flowing.
func (box flowBox) SetMinChildrenPerLine(nChildren uint) {
	var arg0 *C.GtkFlowBox
	var arg1 C.guint

	arg0 = (*C.GtkFlowBox)(box.Native())
	arg1 = C.guint(nChildren)

	C.gtk_flow_box_set_min_children_per_line(arg0, arg1)
}

// SetRowSpacing sets the vertical space to add between children. See the
// FlowBox:row-spacing property.
func (box flowBox) SetRowSpacing(spacing uint) {
	var arg0 *C.GtkFlowBox
	var arg1 C.guint

	arg0 = (*C.GtkFlowBox)(box.Native())
	arg1 = C.guint(spacing)

	C.gtk_flow_box_set_row_spacing(arg0, arg1)
}

// SetSelectionMode sets how selection works in @box. See SelectionMode for
// details.
func (box flowBox) SetSelectionMode(mode SelectionMode) {
	var arg0 *C.GtkFlowBox
	var arg1 C.GtkSelectionMode

	arg0 = (*C.GtkFlowBox)(box.Native())
	arg1 = (C.GtkSelectionMode)(mode)

	C.gtk_flow_box_set_selection_mode(arg0, arg1)
}

// SetSortFunc: by setting a sort function on the @box, one can dynamically
// reorder the children of the box, based on the contents of the children.
//
// The @sort_func will be called for each child after the call, and will
// continue to be called each time a child changes (via
// gtk_flow_box_child_changed()) and when gtk_flow_box_invalidate_sort() is
// called.
//
// Note that using a sort function is incompatible with using a model (see
// gtk_flow_box_bind_model()).
func (box flowBox) SetSortFunc(sortFunc FlowBoxSortFunc) {
	var arg0 *C.GtkFlowBox
	var arg1 C.GtkFlowBoxSortFunc
	arg2 := C.gpointer(box.Assign(userData))

	arg0 = (*C.GtkFlowBox)(box.Native())
	arg1 = (*[0]byte)(C.gotk4_FlowBoxSortFunc)

	C.gtk_flow_box_set_sort_func(arg0, arg1, (*[0]byte)(C.callbackDelete))
}

// SetVadjustment hooks up an adjustment to focus handling in @box. The
// adjustment is also used for autoscrolling during rubberband selection.
// See gtk_scrolled_window_get_vadjustment() for a typical way of obtaining
// the adjustment, and gtk_flow_box_set_hadjustment()for setting the
// horizontal adjustment.
//
// The adjustments have to be in pixel units and in the same coordinate
// system as the allocation for immediate children of the box.
func (box flowBox) SetVadjustment(adjustment Adjustment) {
	var arg0 *C.GtkFlowBox
	var arg1 *C.GtkAdjustment

	arg0 = (*C.GtkFlowBox)(box.Native())
	arg1 = (*C.GtkAdjustment)(adjustment.Native())

	C.gtk_flow_box_set_vadjustment(arg0, arg1)
}

// UnselectAll: unselect all children of @box, if the selection mode allows
// it.
func (box flowBox) UnselectAll() {
	var arg0 *C.GtkFlowBox

	arg0 = (*C.GtkFlowBox)(box.Native())

	C.gtk_flow_box_unselect_all(arg0)
}

// UnselectChild unselects a single child of @box, if the selection mode
// allows it.
func (box flowBox) UnselectChild(child FlowBoxChild) {
	var arg0 *C.GtkFlowBox
	var arg1 *C.GtkFlowBoxChild

	arg0 = (*C.GtkFlowBox)(box.Native())
	arg1 = (*C.GtkFlowBoxChild)(child.Native())

	C.gtk_flow_box_unselect_child(arg0, arg1)
}

type FlowBoxChild interface {
	Widget

	// Changed marks @child as changed, causing any state that depends on this
	// to be updated. This affects sorting and filtering.
	//
	// Note that calls to this method must be in sync with the data used for the
	// sorting and filtering functions. For instance, if the list is mirroring
	// some external data set, and *two* children changed in the external data
	// set when you call gtk_flow_box_child_changed() on the first child, the
	// sort function must only read the new data for the first of the two
	// changed children, otherwise the resorting of the children will be wrong.
	//
	// This generally means that if you don’t fully control the data model, you
	// have to duplicate the data that affects the sorting and filtering
	// functions into the widgets themselves. Another alternative is to call
	// gtk_flow_box_invalidate_sort() on any model change, but that is more
	// expensive.
	Changed()
	// Child gets the child widget of @self.
	Child() Widget
	// Index gets the current index of the @child in its FlowBox container.
	Index() int
	// IsSelected returns whether the @child is currently selected in its
	// FlowBox container.
	IsSelected() bool
	// SetChild sets the child widget of @self.
	SetChild(child Widget)
}

type flowBoxChild struct {
	widget
}

// WrapFlowBoxChild wraps a GObject to the right type. It is
// primarily used internally.
func WrapFlowBoxChild(obj *externglib.Object) FlowBoxChild {
	return flowBoxChild{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}
}

func marshalFlowBoxChild(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFlowBoxChild(obj), nil
}

// NewFlowBoxChild constructs a class FlowBoxChild.
func NewFlowBoxChild() FlowBoxChild {

	ret := C.gtk_flow_box_child_new()

	var ret0 FlowBoxChild

	ret0 = WrapFlowBoxChild(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Changed marks @child as changed, causing any state that depends on this
// to be updated. This affects sorting and filtering.
//
// Note that calls to this method must be in sync with the data used for the
// sorting and filtering functions. For instance, if the list is mirroring
// some external data set, and *two* children changed in the external data
// set when you call gtk_flow_box_child_changed() on the first child, the
// sort function must only read the new data for the first of the two
// changed children, otherwise the resorting of the children will be wrong.
//
// This generally means that if you don’t fully control the data model, you
// have to duplicate the data that affects the sorting and filtering
// functions into the widgets themselves. Another alternative is to call
// gtk_flow_box_invalidate_sort() on any model change, but that is more
// expensive.
func (child flowBoxChild) Changed() {
	var arg0 *C.GtkFlowBoxChild

	arg0 = (*C.GtkFlowBoxChild)(child.Native())

	C.gtk_flow_box_child_changed(arg0)
}

// Child gets the child widget of @self.
func (self flowBoxChild) Child() Widget {
	var arg0 *C.GtkFlowBoxChild

	arg0 = (*C.GtkFlowBoxChild)(self.Native())

	ret := C.gtk_flow_box_child_get_child(arg0)

	var ret0 Widget

	ret0 = WrapWidget(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Index gets the current index of the @child in its FlowBox container.
func (child flowBoxChild) Index() int {
	var arg0 *C.GtkFlowBoxChild

	arg0 = (*C.GtkFlowBoxChild)(child.Native())

	ret := C.gtk_flow_box_child_get_index(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// IsSelected returns whether the @child is currently selected in its
// FlowBox container.
func (child flowBoxChild) IsSelected() bool {
	var arg0 *C.GtkFlowBoxChild

	arg0 = (*C.GtkFlowBoxChild)(child.Native())

	ret := C.gtk_flow_box_child_is_selected(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// SetChild sets the child widget of @self.
func (self flowBoxChild) SetChild(child Widget) {
	var arg0 *C.GtkFlowBoxChild
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkFlowBoxChild)(self.Native())
	arg1 = (*C.GtkWidget)(child.Native())

	C.gtk_flow_box_child_set_child(arg0, arg1)
}

// FontButton: the FontButton is a button which displays the currently selected
// font an allows to open a font chooser dialog to change the font. It is
// suitable widget for selecting a font in a preference dialog.
//
// CSS nodes
//
//    fontbutton
//    ╰── button.font
//        ╰── [content]
//
//
// GtkFontButton has a single CSS node with name fontbutton which contains a
// button node with the .font style class.
type FontButton interface {
	Widget

	// Modal gets whether the dialog is modal.
	Modal() bool
	// Title retrieves the title of the font chooser dialog.
	Title() string
	// UseFont returns whether the selected font is used in the label.
	UseFont() bool
	// UseSize returns whether the selected size is used in the label.
	UseSize() bool
	// SetModal sets whether the dialog should be modal.
	SetModal(modal bool)
	// SetTitle sets the title for the font chooser dialog.
	SetTitle(title string)
	// SetUseFont: if @use_font is true, the font name will be written using the
	// selected font.
	SetUseFont(useFont bool)
	// SetUseSize: if @use_size is true, the font name will be written using the
	// selected size.
	SetUseSize(useSize bool)
}

type fontButton struct {
	widget
}

// WrapFontButton wraps a GObject to the right type. It is
// primarily used internally.
func WrapFontButton(obj *externglib.Object) FontButton {
	return fontButton{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}
}

func marshalFontButton(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFontButton(obj), nil
}

// NewFontButton constructs a class FontButton.
func NewFontButton() FontButton {

	ret := C.gtk_font_button_new()

	var ret0 FontButton

	ret0 = WrapFontButton(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewFontButtonWithFont constructs a class FontButton.
func NewFontButtonWithFont(fontname string) FontButton {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(fontname))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_font_button_new_with_font(arg1)

	var ret0 FontButton

	ret0 = WrapFontButton(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Modal gets whether the dialog is modal.
func (fontButton fontButton) Modal() bool {
	var arg0 *C.GtkFontButton

	arg0 = (*C.GtkFontButton)(fontButton.Native())

	ret := C.gtk_font_button_get_modal(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Title retrieves the title of the font chooser dialog.
func (fontButton fontButton) Title() string {
	var arg0 *C.GtkFontButton

	arg0 = (*C.GtkFontButton)(fontButton.Native())

	ret := C.gtk_font_button_get_title(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// UseFont returns whether the selected font is used in the label.
func (fontButton fontButton) UseFont() bool {
	var arg0 *C.GtkFontButton

	arg0 = (*C.GtkFontButton)(fontButton.Native())

	ret := C.gtk_font_button_get_use_font(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// UseSize returns whether the selected size is used in the label.
func (fontButton fontButton) UseSize() bool {
	var arg0 *C.GtkFontButton

	arg0 = (*C.GtkFontButton)(fontButton.Native())

	ret := C.gtk_font_button_get_use_size(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// SetModal sets whether the dialog should be modal.
func (fontButton fontButton) SetModal(modal bool) {
	var arg0 *C.GtkFontButton
	var arg1 C.gboolean

	arg0 = (*C.GtkFontButton)(fontButton.Native())
	arg1 = gextras.Cbool(modal)

	C.gtk_font_button_set_modal(arg0, arg1)
}

// SetTitle sets the title for the font chooser dialog.
func (fontButton fontButton) SetTitle(title string) {
	var arg0 *C.GtkFontButton
	var arg1 *C.char

	arg0 = (*C.GtkFontButton)(fontButton.Native())
	arg1 = (*C.gchar)(C.CString(title))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_font_button_set_title(arg0, arg1)
}

// SetUseFont: if @use_font is true, the font name will be written using the
// selected font.
func (fontButton fontButton) SetUseFont(useFont bool) {
	var arg0 *C.GtkFontButton
	var arg1 C.gboolean

	arg0 = (*C.GtkFontButton)(fontButton.Native())
	arg1 = gextras.Cbool(useFont)

	C.gtk_font_button_set_use_font(arg0, arg1)
}

// SetUseSize: if @use_size is true, the font name will be written using the
// selected size.
func (fontButton fontButton) SetUseSize(useSize bool) {
	var arg0 *C.GtkFontButton
	var arg1 C.gboolean

	arg0 = (*C.GtkFontButton)(fontButton.Native())
	arg1 = gextras.Cbool(useSize)

	C.gtk_font_button_set_use_size(arg0, arg1)
}

// FontChooserDialog: the FontChooserDialog widget is a dialog for selecting a
// font. It implements the FontChooser interface.
//
//
// GtkFontChooserDialog as GtkBuildable
//
// The GtkFontChooserDialog implementation of the Buildable interface exposes
// the buttons with the names “select_button” and “cancel_button”.
type FontChooserDialog interface {
	Dialog
}

type fontChooserDialog struct {
	dialog
}

// WrapFontChooserDialog wraps a GObject to the right type. It is
// primarily used internally.
func WrapFontChooserDialog(obj *externglib.Object) FontChooserDialog {
	return fontChooserDialog{dialog{window{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}}}
}

func marshalFontChooserDialog(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFontChooserDialog(obj), nil
}

// NewFontChooserDialog constructs a class FontChooserDialog.
func NewFontChooserDialog(title string, parent Window) FontChooserDialog {
	var arg1 *C.char
	var arg2 *C.GtkWindow

	arg1 = (*C.gchar)(C.CString(title))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GtkWindow)(parent.Native())

	ret := C.gtk_font_chooser_dialog_new(arg1, arg2)

	var ret0 FontChooserDialog

	ret0 = WrapFontChooserDialog(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// FontChooserWidget: the FontChooserWidget widget lists the available fonts,
// styles and sizes, allowing the user to select a font. It is used in the
// FontChooserDialog widget to provide a dialog box for selecting fonts.
//
// To set the font which is initially selected, use gtk_font_chooser_set_font()
// or gtk_font_chooser_set_font_desc().
//
// To get the selected font use gtk_font_chooser_get_font() or
// gtk_font_chooser_get_font_desc().
//
// To change the text which is shown in the preview area, use
// gtk_font_chooser_set_preview_text().
//
//
// CSS nodes
//
// GtkFontChooserWidget has a single CSS node with name fontchooser.
type FontChooserWidget interface {
	Widget
}

type fontChooserWidget struct {
	widget
}

// WrapFontChooserWidget wraps a GObject to the right type. It is
// primarily used internally.
func WrapFontChooserWidget(obj *externglib.Object) FontChooserWidget {
	return fontChooserWidget{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}
}

func marshalFontChooserWidget(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFontChooserWidget(obj), nil
}

// NewFontChooserWidget constructs a class FontChooserWidget.
func NewFontChooserWidget() FontChooserWidget {

	ret := C.gtk_font_chooser_widget_new()

	var ret0 FontChooserWidget

	ret0 = WrapFontChooserWidget(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Frame: the frame widget is a widget that surrounds its child with a
// decorative frame and an optional label. If present, the label is drawn inside
// the top edge of the frame. The horizontal position of the label can be
// controlled with gtk_frame_set_label_align().
//
// GtkFrame clips its child. You can use this to add rounded corners to widgets,
// but be aware that it also cuts off shadows.
//
//
// GtkFrame as GtkBuildable
//
// The GtkFrame implementation of the GtkBuildable interface supports placing a
// child in the label position by specifying “label” as the “type” attribute of
// a <child> element. A normal content child can be specified without specifying
// a <child> type attribute.
//
// An example of a UI definition fragment with GtkFrame:
//
//
//    <object class="GtkFrame">
//      <child type="label">
//        <object class="GtkLabel" id="frame_label"/>
//      </child>
//      <child>
//        <object class="GtkEntry" id="frame_content"/>
//      </child>
//    </object>
//    ]|
//
//
//
// CSS nodes
//
//
//    |[<!-- language="plain" -->
//    frame
//    ├── <label widget>
//    ╰── <child>
//
//
// GtkFrame has a main CSS node with name “frame”, which is used to draw the
// visible border. You can set the appearance of the border using CSS properties
// like “border-style” on this node.
type Frame interface {
	Widget

	// Child gets the child widget of @frame.
	Child() Widget
	// Label: if the frame’s label widget is a Label, returns the text in the
	// label widget. (The frame will have a Label for the label widget if a
	// non-nil argument was passed to gtk_frame_new().)
	Label() string
	// LabelAlign retrieves the X alignment of the frame’s label. See
	// gtk_frame_set_label_align().
	LabelAlign() float32
	// LabelWidget retrieves the label widget for the frame. See
	// gtk_frame_set_label_widget().
	LabelWidget() Widget
	// SetChild sets the child widget of @frame.
	SetChild(child Widget)
	// SetLabel removes the current Frame:label-widget. If @label is not nil,
	// creates a new Label with that text and adds it as the Frame:label-widget.
	SetLabel(label string)
	// SetLabelAlign sets the X alignment of the frame widget’s label. The
	// default value for a newly created frame is 0.0.
	SetLabelAlign(xalign float32)
	// SetLabelWidget sets the Frame:label-widget for the frame. This is the
	// widget that will appear embedded in the top edge of the frame as a title.
	SetLabelWidget(labelWidget Widget)
}

type frame struct {
	widget
}

// WrapFrame wraps a GObject to the right type. It is
// primarily used internally.
func WrapFrame(obj *externglib.Object) Frame {
	return frame{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}
}

func marshalFrame(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFrame(obj), nil
}

// NewFrame constructs a class Frame.
func NewFrame(label string) Frame {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_frame_new(arg1)

	var ret0 Frame

	ret0 = WrapFrame(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Child gets the child widget of @frame.
func (frame frame) Child() Widget {
	var arg0 *C.GtkFrame

	arg0 = (*C.GtkFrame)(frame.Native())

	ret := C.gtk_frame_get_child(arg0)

	var ret0 Widget

	ret0 = WrapWidget(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Label: if the frame’s label widget is a Label, returns the text in the
// label widget. (The frame will have a Label for the label widget if a
// non-nil argument was passed to gtk_frame_new().)
func (frame frame) Label() string {
	var arg0 *C.GtkFrame

	arg0 = (*C.GtkFrame)(frame.Native())

	ret := C.gtk_frame_get_label(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// LabelAlign retrieves the X alignment of the frame’s label. See
// gtk_frame_set_label_align().
func (frame frame) LabelAlign() float32 {
	var arg0 *C.GtkFrame

	arg0 = (*C.GtkFrame)(frame.Native())

	ret := C.gtk_frame_get_label_align(arg0)

	var ret0 float32

	ret0 = float32(ret)

	return ret0
}

// LabelWidget retrieves the label widget for the frame. See
// gtk_frame_set_label_widget().
func (frame frame) LabelWidget() Widget {
	var arg0 *C.GtkFrame

	arg0 = (*C.GtkFrame)(frame.Native())

	ret := C.gtk_frame_get_label_widget(arg0)

	var ret0 Widget

	ret0 = WrapWidget(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// SetChild sets the child widget of @frame.
func (frame frame) SetChild(child Widget) {
	var arg0 *C.GtkFrame
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkFrame)(frame.Native())
	arg1 = (*C.GtkWidget)(child.Native())

	C.gtk_frame_set_child(arg0, arg1)
}

// SetLabel removes the current Frame:label-widget. If @label is not nil,
// creates a new Label with that text and adds it as the Frame:label-widget.
func (frame frame) SetLabel(label string) {
	var arg0 *C.GtkFrame
	var arg1 *C.char

	arg0 = (*C.GtkFrame)(frame.Native())
	arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_frame_set_label(arg0, arg1)
}

// SetLabelAlign sets the X alignment of the frame widget’s label. The
// default value for a newly created frame is 0.0.
func (frame frame) SetLabelAlign(xalign float32) {
	var arg0 *C.GtkFrame
	var arg1 C.float

	arg0 = (*C.GtkFrame)(frame.Native())
	arg1 = C.float(xalign)

	C.gtk_frame_set_label_align(arg0, arg1)
}

// SetLabelWidget sets the Frame:label-widget for the frame. This is the
// widget that will appear embedded in the top edge of the frame as a title.
func (frame frame) SetLabelWidget(labelWidget Widget) {
	var arg0 *C.GtkFrame
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkFrame)(frame.Native())
	arg1 = (*C.GtkWidget)(labelWidget.Native())

	C.gtk_frame_set_label_widget(arg0, arg1)
}

// GLArea is a widget that allows drawing with OpenGL.
//
// GLArea sets up its own GLContext for the window it creates, and creates a
// custom GL framebuffer that the widget will do GL rendering onto. It also
// ensures that this framebuffer is the default GL rendering target when
// rendering.
//
// In order to draw, you have to connect to the GLArea::render signal, or
// subclass GLArea and override the @GtkGLAreaClass.render() virtual function.
//
// The GLArea widget ensures that the GLContext is associated with the widget's
// drawing area, and it is kept updated when the size and position of the
// drawing area changes.
//
// Drawing with GtkGLArea ##
//
// The simplest way to draw using OpenGL commands in a GLArea is to create a
// widget instance and connect to the GLArea::render signal:
//
//      static void
//      on_realize (GtkGLarea *area)
//      {
//        // We need to make the context current if we want to
//        // call GL API
//        gtk_gl_area_make_current (area);
//
//        // If there were errors during the initialization or
//        // when trying to make the context current, this
//        // function will return a #GError for you to catch
//        if (gtk_gl_area_get_error (area) != NULL)
//          return;
//
//        // You can also use gtk_gl_area_set_error() in order
//        // to show eventual initialization errors on the
//        // GtkGLArea widget itself
//        GError *internal_error = NULL;
//        init_buffer_objects (&error);
//        if (error != NULL)
//          {
//            gtk_gl_area_set_error (area, error);
//            g_error_free (error);
//            return;
//          }
//
//        init_shaders (&error);
//        if (error != NULL)
//          {
//            gtk_gl_area_set_error (area, error);
//            g_error_free (error);
//            return;
//          }
//      }
//
//
// If you need to change the options for creating the GLContext you should use
// the GLArea::create-context signal.
type GLArea interface {
	Widget

	// AttachBuffers ensures that the @area framebuffer object is made the
	// current draw and read target, and that all the required buffers for the
	// @area are created and bound to the framebuffer.
	//
	// This function is automatically called before emitting the GLArea::render
	// signal, and doesn't normally need to be called by application code.
	AttachBuffers()
	// AutoRender returns whether the area is in auto render mode or not.
	AutoRender() bool
	// Context retrieves the GLContext used by @area.
	Context() gdk.GLContext
	// Error gets the current error set on the @area.
	Error() *glib.Error
	// HasDepthBuffer returns whether the area has a depth buffer.
	HasDepthBuffer() bool
	// HasStencilBuffer returns whether the area has a stencil buffer.
	HasStencilBuffer() bool
	// RequiredVersion retrieves the required version of OpenGL set using
	// gtk_gl_area_set_required_version().
	RequiredVersion() (major int, minor int)
	// UseES retrieves the value set by gtk_gl_area_set_use_es().
	UseES() bool
	// MakeCurrent ensures that the GLContext used by @area is associated with
	// the GLArea.
	//
	// This function is automatically called before emitting the GLArea::render
	// signal, and doesn't normally need to be called by application code.
	MakeCurrent()
	// QueueRender marks the currently rendered data (if any) as invalid, and
	// queues a redraw of the widget, ensuring that the GLArea::render signal is
	// emitted during the draw.
	//
	// This is only needed when the gtk_gl_area_set_auto_render() has been
	// called with a false value. The default behaviour is to emit
	// GLArea::render on each draw.
	QueueRender()
	// SetAutoRender: if @auto_render is true the GLArea::render signal will be
	// emitted every time the widget draws. This is the default and is useful if
	// drawing the widget is faster.
	//
	// If @auto_render is false the data from previous rendering is kept around
	// and will be used for drawing the widget the next time, unless the window
	// is resized. In order to force a rendering gtk_gl_area_queue_render() must
	// be called. This mode is useful when the scene changes seldom, but takes a
	// long time to redraw.
	SetAutoRender(autoRender bool)
	// SetError sets an error on the area which will be shown instead of the GL
	// rendering. This is useful in the GLArea::create-context signal if GL
	// context creation fails.
	SetError(error *glib.Error)
	// SetHasDepthBuffer: if @has_depth_buffer is true the widget will allocate
	// and enable a depth buffer for the target framebuffer. Otherwise there
	// will be none.
	SetHasDepthBuffer(hasDepthBuffer bool)
	// SetHasStencilBuffer: if @has_stencil_buffer is true the widget will
	// allocate and enable a stencil buffer for the target framebuffer.
	// Otherwise there will be none.
	SetHasStencilBuffer(hasStencilBuffer bool)
	// SetRequiredVersion sets the required version of OpenGL to be used when
	// creating the context for the widget.
	//
	// This function must be called before the area has been realized.
	SetRequiredVersion(major int, minor int)
	// SetUseES sets whether the @area should create an OpenGL or an OpenGL ES
	// context.
	//
	// You should check the capabilities of the GLContext before drawing with
	// either API.
	SetUseES(useES bool)
}

type glArea struct {
	widget
}

// WrapGLArea wraps a GObject to the right type. It is
// primarily used internally.
func WrapGLArea(obj *externglib.Object) GLArea {
	return glArea{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}
}

func marshalGLArea(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapGLArea(obj), nil
}

// NewGLArea constructs a class GLArea.
func NewGLArea() GLArea {

	ret := C.gtk_gl_area_new()

	var ret0 GLArea

	ret0 = WrapGLArea(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// AttachBuffers ensures that the @area framebuffer object is made the
// current draw and read target, and that all the required buffers for the
// @area are created and bound to the framebuffer.
//
// This function is automatically called before emitting the GLArea::render
// signal, and doesn't normally need to be called by application code.
func (area glArea) AttachBuffers() {
	var arg0 *C.GtkGLArea

	arg0 = (*C.GtkGLArea)(area.Native())

	C.gtk_gl_area_attach_buffers(arg0)
}

// AutoRender returns whether the area is in auto render mode or not.
func (area glArea) AutoRender() bool {
	var arg0 *C.GtkGLArea

	arg0 = (*C.GtkGLArea)(area.Native())

	ret := C.gtk_gl_area_get_auto_render(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Context retrieves the GLContext used by @area.
func (area glArea) Context() gdk.GLContext {
	var arg0 *C.GtkGLArea

	arg0 = (*C.GtkGLArea)(area.Native())

	ret := C.gtk_gl_area_get_context(arg0)

	var ret0 gdk.GLContext

	ret0 = gdk.WrapGLContext(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Error gets the current error set on the @area.
func (area glArea) Error() *glib.Error {
	var arg0 *C.GtkGLArea

	arg0 = (*C.GtkGLArea)(area.Native())

	ret := C.gtk_gl_area_get_error(arg0)

	var ret0 *glib.Error

	ret0 = glib.WrapError(ret)

	return ret0
}

// HasDepthBuffer returns whether the area has a depth buffer.
func (area glArea) HasDepthBuffer() bool {
	var arg0 *C.GtkGLArea

	arg0 = (*C.GtkGLArea)(area.Native())

	ret := C.gtk_gl_area_get_has_depth_buffer(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// HasStencilBuffer returns whether the area has a stencil buffer.
func (area glArea) HasStencilBuffer() bool {
	var arg0 *C.GtkGLArea

	arg0 = (*C.GtkGLArea)(area.Native())

	ret := C.gtk_gl_area_get_has_stencil_buffer(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// RequiredVersion retrieves the required version of OpenGL set using
// gtk_gl_area_set_required_version().
func (area glArea) RequiredVersion() (major int, minor int) {
	var arg0 *C.GtkGLArea
	var arg1 *C.int // out
	var arg2 *C.int // out

	arg0 = (*C.GtkGLArea)(area.Native())

	ret := C.gtk_gl_area_get_required_version(arg0, &arg1, &arg2)

	var ret0 int
	var ret1 int

	ret0 = int(arg1)

	ret1 = int(arg2)

	return ret0, ret1
}

// UseES retrieves the value set by gtk_gl_area_set_use_es().
func (area glArea) UseES() bool {
	var arg0 *C.GtkGLArea

	arg0 = (*C.GtkGLArea)(area.Native())

	ret := C.gtk_gl_area_get_use_es(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// MakeCurrent ensures that the GLContext used by @area is associated with
// the GLArea.
//
// This function is automatically called before emitting the GLArea::render
// signal, and doesn't normally need to be called by application code.
func (area glArea) MakeCurrent() {
	var arg0 *C.GtkGLArea

	arg0 = (*C.GtkGLArea)(area.Native())

	C.gtk_gl_area_make_current(arg0)
}

// QueueRender marks the currently rendered data (if any) as invalid, and
// queues a redraw of the widget, ensuring that the GLArea::render signal is
// emitted during the draw.
//
// This is only needed when the gtk_gl_area_set_auto_render() has been
// called with a false value. The default behaviour is to emit
// GLArea::render on each draw.
func (area glArea) QueueRender() {
	var arg0 *C.GtkGLArea

	arg0 = (*C.GtkGLArea)(area.Native())

	C.gtk_gl_area_queue_render(arg0)
}

// SetAutoRender: if @auto_render is true the GLArea::render signal will be
// emitted every time the widget draws. This is the default and is useful if
// drawing the widget is faster.
//
// If @auto_render is false the data from previous rendering is kept around
// and will be used for drawing the widget the next time, unless the window
// is resized. In order to force a rendering gtk_gl_area_queue_render() must
// be called. This mode is useful when the scene changes seldom, but takes a
// long time to redraw.
func (area glArea) SetAutoRender(autoRender bool) {
	var arg0 *C.GtkGLArea
	var arg1 C.gboolean

	arg0 = (*C.GtkGLArea)(area.Native())
	arg1 = gextras.Cbool(autoRender)

	C.gtk_gl_area_set_auto_render(arg0, arg1)
}

// SetError sets an error on the area which will be shown instead of the GL
// rendering. This is useful in the GLArea::create-context signal if GL
// context creation fails.
func (area glArea) SetError(error *glib.Error) {
	var arg0 *C.GtkGLArea
	var arg1 *C.GError

	arg0 = (*C.GtkGLArea)(area.Native())
	arg1 = (*C.GError)(error.Native())

	C.gtk_gl_area_set_error(arg0, arg1)
}

// SetHasDepthBuffer: if @has_depth_buffer is true the widget will allocate
// and enable a depth buffer for the target framebuffer. Otherwise there
// will be none.
func (area glArea) SetHasDepthBuffer(hasDepthBuffer bool) {
	var arg0 *C.GtkGLArea
	var arg1 C.gboolean

	arg0 = (*C.GtkGLArea)(area.Native())
	arg1 = gextras.Cbool(hasDepthBuffer)

	C.gtk_gl_area_set_has_depth_buffer(arg0, arg1)
}

// SetHasStencilBuffer: if @has_stencil_buffer is true the widget will
// allocate and enable a stencil buffer for the target framebuffer.
// Otherwise there will be none.
func (area glArea) SetHasStencilBuffer(hasStencilBuffer bool) {
	var arg0 *C.GtkGLArea
	var arg1 C.gboolean

	arg0 = (*C.GtkGLArea)(area.Native())
	arg1 = gextras.Cbool(hasStencilBuffer)

	C.gtk_gl_area_set_has_stencil_buffer(arg0, arg1)
}

// SetRequiredVersion sets the required version of OpenGL to be used when
// creating the context for the widget.
//
// This function must be called before the area has been realized.
func (area glArea) SetRequiredVersion(major int, minor int) {
	var arg0 *C.GtkGLArea
	var arg1 C.int
	var arg2 C.int

	arg0 = (*C.GtkGLArea)(area.Native())
	arg1 = C.int(major)
	arg2 = C.int(minor)

	C.gtk_gl_area_set_required_version(arg0, arg1, arg2)
}

// SetUseES sets whether the @area should create an OpenGL or an OpenGL ES
// context.
//
// You should check the capabilities of the GLContext before drawing with
// either API.
func (area glArea) SetUseES(useES bool) {
	var arg0 *C.GtkGLArea
	var arg1 C.gboolean

	arg0 = (*C.GtkGLArea)(area.Native())
	arg1 = gextras.Cbool(useES)

	C.gtk_gl_area_set_use_es(arg0, arg1)
}

// Gesture is the base object for gesture recognition, although this object is
// quite generalized to serve as a base for multi-touch gestures, it is suitable
// to implement single-touch and pointer-based gestures (using the special nil
// EventSequence value for these).
//
// The number of touches that a Gesture need to be recognized is controlled by
// the Gesture:n-points property, if a gesture is keeping track of less or more
// than that number of sequences, it won't check whether the gesture is
// recognized.
//
// As soon as the gesture has the expected number of touches, it will check
// regularly if it is recognized, the criteria to consider a gesture as
// "recognized" is left to Gesture subclasses.
//
// A recognized gesture will then emit the following signals: - Gesture::begin
// when the gesture is recognized. - A number of Gesture::update, whenever an
// input event is processed. - Gesture::end when the gesture is no longer
// recognized.
//
//
// Event propagation
//
// In order to receive events, a gesture needs to set a propagation phase
// through gtk_event_controller_set_propagation_phase().
//
// In the capture phase, events are propagated from the toplevel down to the
// target widget, and gestures that are attached to containers above the widget
// get a chance to interact with the event before it reaches the target.
//
// In the bubble phase, events are propagated up from the target widget to the
// toplevel, and gestures that are attached to containers above the widget get a
// chance to interact with events that have not been handled yet.
//
//
// States of a sequence
//
// Whenever input interaction happens, a single event may trigger a cascade of
// Gestures, both across the parents of the widget receiving the event and in
// parallel within an individual widget. It is a responsibility of the widgets
// using those gestures to set the state of touch sequences accordingly in order
// to enable cooperation of gestures around the EventSequences triggering those.
//
// Within a widget, gestures can be grouped through gtk_gesture_group(), grouped
// gestures synchronize the state of sequences, so calling
// gtk_gesture_set_sequence_state() on one will effectively propagate the state
// throughout the group.
//
// By default, all sequences start out in the K_EVENT_SEQUENCE_NONE state,
// sequences in this state trigger the gesture event handler, but event
// propagation will continue unstopped by gestures.
//
// If a sequence enters into the K_EVENT_SEQUENCE_DENIED state, the gesture
// group will effectively ignore the sequence, letting events go unstopped
// through the gesture, but the "slot" will still remain occupied while the
// touch is active.
//
// If a sequence enters in the K_EVENT_SEQUENCE_CLAIMED state, the gesture group
// will grab all interaction on the sequence, by: - Setting the same sequence to
// K_EVENT_SEQUENCE_DENIED on every other gesture group within the widget, and
// every gesture on parent widgets in the propagation chain. - calling
// Gesture::cancel on every gesture in widgets underneath in the propagation
// chain. - Stopping event propagation after the gesture group handles the
// event.
//
// Note: if a sequence is set early to K_EVENT_SEQUENCE_CLAIMED on
// K_TOUCH_BEGIN/K_BUTTON_PRESS (so those events are captured before reaching
// the event widget, this implies K_PHASE_CAPTURE), one similar event will
// emulated if the sequence changes to K_EVENT_SEQUENCE_DENIED. This way event
// coherence is preserved before event propagation is unstopped again.
//
// Sequence states can't be changed freely, see gtk_gesture_set_sequence_state()
// to know about the possible lifetimes of a EventSequence.
//
//
// Touchpad gestures
//
// On the platforms that support it, Gesture will handle transparently touchpad
// gesture events. The only precautions users of Gesture should do to enable
// this support are: - Enabling GDK_TOUCHPAD_GESTURE_MASK on their Surfaces - If
// the gesture has GTK_PHASE_NONE, ensuring events of type GDK_TOUCHPAD_SWIPE
// and GDK_TOUCHPAD_PINCH are handled by the Gesture
type Gesture interface {
	EventController

	// BoundingBox: if there are touch sequences being currently handled by
	// @gesture, this function returns true and fills in @rect with the bounding
	// box containing all active touches. Otherwise, false will be returned.
	//
	// Note: This function will yield unexpected results on touchpad gestures.
	// Since there is no correlation between physical and pixel distances, these
	// will look as if constrained in an infinitely small area, @rect width and
	// height will thus be 0 regardless of the number of touchpoints.
	BoundingBox() (rect gdk.Rectangle, ok bool)
	// BoundingBoxCenter: if there are touch sequences being currently handled
	// by @gesture, this function returns true and fills in @x and @y with the
	// center of the bounding box containing all active touches. Otherwise,
	// false will be returned.
	BoundingBoxCenter() (x float64, y float64, ok bool)
	// Device returns the logical Device that is currently operating on
	// @gesture, or nil if the gesture is not being interacted.
	Device() gdk.Device
	// GetGroup returns all gestures in the group of @gesture
	GetGroup() *glib.List
	// LastEvent returns the last event that was processed for @sequence.
	//
	// Note that the returned pointer is only valid as long as the @sequence is
	// still interpreted by the @gesture. If in doubt, you should make a copy of
	// the event.
	LastEvent(sequence *gdk.EventSequence) gdk.Event
	// LastUpdatedSequence returns the EventSequence that was last updated on
	// @gesture.
	LastUpdatedSequence() *gdk.EventSequence
	// Point: if @sequence is currently being interpreted by @gesture, this
	// function returns true and fills in @x and @y with the last coordinates
	// stored for that event sequence. The coordinates are always relative to
	// the widget allocation.
	Point(sequence *gdk.EventSequence) (x float64, y float64, ok bool)
	// SequenceState returns the @sequence state, as seen by @gesture.
	SequenceState(sequence *gdk.EventSequence) EventSequenceState
	// Sequences returns the list of EventSequences currently being interpreted
	// by @gesture.
	Sequences() *glib.List
	// Group adds @gesture to the same group than @group_gesture. Gestures are
	// by default isolated in their own groups.
	//
	// Both gestures must have been added to the same widget before they can be
	// grouped.
	//
	// When gestures are grouped, the state of EventSequences is kept in sync
	// for all of those, so calling gtk_gesture_set_sequence_state(), on one
	// will transfer the same value to the others.
	//
	// Groups also perform an "implicit grabbing" of sequences, if a
	// EventSequence state is set to K_EVENT_SEQUENCE_CLAIMED on one group,
	// every other gesture group attached to the same Widget will switch the
	// state for that sequence to K_EVENT_SEQUENCE_DENIED.
	Group(gesture Gesture)
	// HandlesSequence returns true if @gesture is currently handling events
	// corresponding to @sequence.
	HandlesSequence(sequence *gdk.EventSequence) bool
	// IsActive returns true if the gesture is currently active. A gesture is
	// active meanwhile there are touch sequences interacting with it.
	IsActive() bool
	// IsGroupedWith returns true if both gestures pertain to the same group.
	IsGroupedWith(other Gesture) bool
	// IsRecognized returns true if the gesture is currently recognized. A
	// gesture is recognized if there are as many interacting touch sequences as
	// required by @gesture.
	IsRecognized() bool
	// SetSequenceState sets the state of @sequence in @gesture. Sequences start
	// in state K_EVENT_SEQUENCE_NONE, and whenever they change state, they can
	// never go back to that state. Likewise, sequences in state
	// K_EVENT_SEQUENCE_DENIED cannot turn back to a not denied state. With
	// these rules, the lifetime of an event sequence is constrained to the next
	// four:
	//
	// * None * None → Denied * None → Claimed * None → Claimed → Denied
	//
	// Note: Due to event handling ordering, it may be unsafe to set the state
	// on another gesture within a Gesture::begin signal handler, as the
	// callback might be executed before the other gesture knows about the
	// sequence. A safe way to perform this could be:
	//
	//
	//    static void
	//    first_gesture_begin_cb (GtkGesture       *first_gesture,
	//                            GdkEventSequence *sequence,
	//                            gpointer          user_data)
	//    {
	//      gtk_gesture_set_sequence_state (first_gesture, sequence, GTK_EVENT_SEQUENCE_CLAIMED);
	//      gtk_gesture_set_sequence_state (second_gesture, sequence, GTK_EVENT_SEQUENCE_DENIED);
	//    }
	//
	//    static void
	//    second_gesture_begin_cb (GtkGesture       *second_gesture,
	//                             GdkEventSequence *sequence,
	//                             gpointer          user_data)
	//    {
	//      if (gtk_gesture_get_sequence_state (first_gesture, sequence) == GTK_EVENT_SEQUENCE_CLAIMED)
	//        gtk_gesture_set_sequence_state (second_gesture, sequence, GTK_EVENT_SEQUENCE_DENIED);
	//    }
	//
	//
	// If both gestures are in the same group, just set the state on the gesture
	// emitting the event, the sequence will be already be initialized to the
	// group's global state when the second gesture processes the event.
	SetSequenceState(sequence *gdk.EventSequence, state EventSequenceState) bool
	// SetState sets the state of all sequences that @gesture is currently
	// interacting with. See gtk_gesture_set_sequence_state() for more details
	// on sequence states.
	SetState(state EventSequenceState) bool
	// Ungroup separates @gesture into an isolated group.
	Ungroup()
}

type gesture struct {
	eventController
}

// WrapGesture wraps a GObject to the right type. It is
// primarily used internally.
func WrapGesture(obj *externglib.Object) Gesture {
	return gesture{eventController{*externglib.Object{obj}}}
}

func marshalGesture(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapGesture(obj), nil
}

// BoundingBox: if there are touch sequences being currently handled by
// @gesture, this function returns true and fills in @rect with the bounding
// box containing all active touches. Otherwise, false will be returned.
//
// Note: This function will yield unexpected results on touchpad gestures.
// Since there is no correlation between physical and pixel distances, these
// will look as if constrained in an infinitely small area, @rect width and
// height will thus be 0 regardless of the number of touchpoints.
func (gesture gesture) BoundingBox() (rect gdk.Rectangle, ok bool) {
	var arg0 *C.GtkGesture
	var arg1 *C.GdkRectangle // out

	arg0 = (*C.GtkGesture)(gesture.Native())

	ret := C.gtk_gesture_get_bounding_box(arg0, &arg1)

	var ret0 *gdk.Rectangle
	var ret1 bool

	ret0 = gdk.WrapRectangle(arg1)

	ret1 = gextras.Gobool(ret)

	return ret0, ret1
}

// BoundingBoxCenter: if there are touch sequences being currently handled
// by @gesture, this function returns true and fills in @x and @y with the
// center of the bounding box containing all active touches. Otherwise,
// false will be returned.
func (gesture gesture) BoundingBoxCenter() (x float64, y float64, ok bool) {
	var arg0 *C.GtkGesture
	var arg1 *C.double // out
	var arg2 *C.double // out

	arg0 = (*C.GtkGesture)(gesture.Native())

	ret := C.gtk_gesture_get_bounding_box_center(arg0, &arg1, &arg2)

	var ret0 float64
	var ret1 float64
	var ret2 bool

	ret0 = float64(arg1)

	ret1 = float64(arg2)

	ret2 = gextras.Gobool(ret)

	return ret0, ret1, ret2
}

// Device returns the logical Device that is currently operating on
// @gesture, or nil if the gesture is not being interacted.
func (gesture gesture) Device() gdk.Device {
	var arg0 *C.GtkGesture

	arg0 = (*C.GtkGesture)(gesture.Native())

	ret := C.gtk_gesture_get_device(arg0)

	var ret0 gdk.Device

	ret0 = gdk.WrapDevice(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// GetGroup returns all gestures in the group of @gesture
func (gesture gesture) GetGroup() *glib.List {
	var arg0 *C.GtkGesture

	arg0 = (*C.GtkGesture)(gesture.Native())

	ret := C.gtk_gesture_get_group(arg0)

	var ret0 *glib.List

	ret0 = glib.WrapList(ret)

	return ret0
}

// LastEvent returns the last event that was processed for @sequence.
//
// Note that the returned pointer is only valid as long as the @sequence is
// still interpreted by the @gesture. If in doubt, you should make a copy of
// the event.
func (gesture gesture) LastEvent(sequence *gdk.EventSequence) gdk.Event {
	var arg0 *C.GtkGesture
	var arg1 *C.GdkEventSequence

	arg0 = (*C.GtkGesture)(gesture.Native())
	arg1 = (*C.GdkEventSequence)(sequence.Native())

	ret := C.gtk_gesture_get_last_event(arg0, arg1)

	var ret0 gdk.Event

	ret0 = gdk.WrapEvent(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// LastUpdatedSequence returns the EventSequence that was last updated on
// @gesture.
func (gesture gesture) LastUpdatedSequence() *gdk.EventSequence {
	var arg0 *C.GtkGesture

	arg0 = (*C.GtkGesture)(gesture.Native())

	ret := C.gtk_gesture_get_last_updated_sequence(arg0)

	var ret0 *gdk.EventSequence

	ret0 = gdk.WrapEventSequence(ret)

	return ret0
}

// Point: if @sequence is currently being interpreted by @gesture, this
// function returns true and fills in @x and @y with the last coordinates
// stored for that event sequence. The coordinates are always relative to
// the widget allocation.
func (gesture gesture) Point(sequence *gdk.EventSequence) (x float64, y float64, ok bool) {
	var arg0 *C.GtkGesture
	var arg1 *C.GdkEventSequence
	var arg2 *C.double // out
	var arg3 *C.double // out

	arg0 = (*C.GtkGesture)(gesture.Native())
	arg1 = (*C.GdkEventSequence)(sequence.Native())

	ret := C.gtk_gesture_get_point(arg0, arg1, &arg2, &arg3)

	var ret0 float64
	var ret1 float64
	var ret2 bool

	ret0 = float64(arg2)

	ret1 = float64(arg3)

	ret2 = gextras.Gobool(ret)

	return ret0, ret1, ret2
}

// SequenceState returns the @sequence state, as seen by @gesture.
func (gesture gesture) SequenceState(sequence *gdk.EventSequence) EventSequenceState {
	var arg0 *C.GtkGesture
	var arg1 *C.GdkEventSequence

	arg0 = (*C.GtkGesture)(gesture.Native())
	arg1 = (*C.GdkEventSequence)(sequence.Native())

	ret := C.gtk_gesture_get_sequence_state(arg0, arg1)

	var ret0 EventSequenceState

	ret0 = EventSequenceState(ret)

	return ret0
}

// Sequences returns the list of EventSequences currently being interpreted
// by @gesture.
func (gesture gesture) Sequences() *glib.List {
	var arg0 *C.GtkGesture

	arg0 = (*C.GtkGesture)(gesture.Native())

	ret := C.gtk_gesture_get_sequences(arg0)

	var ret0 *glib.List

	ret0 = glib.WrapList(ret)

	return ret0
}

// Group adds @gesture to the same group than @group_gesture. Gestures are
// by default isolated in their own groups.
//
// Both gestures must have been added to the same widget before they can be
// grouped.
//
// When gestures are grouped, the state of EventSequences is kept in sync
// for all of those, so calling gtk_gesture_set_sequence_state(), on one
// will transfer the same value to the others.
//
// Groups also perform an "implicit grabbing" of sequences, if a
// EventSequence state is set to K_EVENT_SEQUENCE_CLAIMED on one group,
// every other gesture group attached to the same Widget will switch the
// state for that sequence to K_EVENT_SEQUENCE_DENIED.
func (groupGesture gesture) Group(gesture Gesture) {
	var arg0 *C.GtkGesture
	var arg1 *C.GtkGesture

	arg0 = (*C.GtkGesture)(groupGesture.Native())
	arg1 = (*C.GtkGesture)(gesture.Native())

	C.gtk_gesture_group(arg0, arg1)
}

// HandlesSequence returns true if @gesture is currently handling events
// corresponding to @sequence.
func (gesture gesture) HandlesSequence(sequence *gdk.EventSequence) bool {
	var arg0 *C.GtkGesture
	var arg1 *C.GdkEventSequence

	arg0 = (*C.GtkGesture)(gesture.Native())
	arg1 = (*C.GdkEventSequence)(sequence.Native())

	ret := C.gtk_gesture_handles_sequence(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// IsActive returns true if the gesture is currently active. A gesture is
// active meanwhile there are touch sequences interacting with it.
func (gesture gesture) IsActive() bool {
	var arg0 *C.GtkGesture

	arg0 = (*C.GtkGesture)(gesture.Native())

	ret := C.gtk_gesture_is_active(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// IsGroupedWith returns true if both gestures pertain to the same group.
func (gesture gesture) IsGroupedWith(other Gesture) bool {
	var arg0 *C.GtkGesture
	var arg1 *C.GtkGesture

	arg0 = (*C.GtkGesture)(gesture.Native())
	arg1 = (*C.GtkGesture)(other.Native())

	ret := C.gtk_gesture_is_grouped_with(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// IsRecognized returns true if the gesture is currently recognized. A
// gesture is recognized if there are as many interacting touch sequences as
// required by @gesture.
func (gesture gesture) IsRecognized() bool {
	var arg0 *C.GtkGesture

	arg0 = (*C.GtkGesture)(gesture.Native())

	ret := C.gtk_gesture_is_recognized(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// SetSequenceState sets the state of @sequence in @gesture. Sequences start
// in state K_EVENT_SEQUENCE_NONE, and whenever they change state, they can
// never go back to that state. Likewise, sequences in state
// K_EVENT_SEQUENCE_DENIED cannot turn back to a not denied state. With
// these rules, the lifetime of an event sequence is constrained to the next
// four:
//
// * None * None → Denied * None → Claimed * None → Claimed → Denied
//
// Note: Due to event handling ordering, it may be unsafe to set the state
// on another gesture within a Gesture::begin signal handler, as the
// callback might be executed before the other gesture knows about the
// sequence. A safe way to perform this could be:
//
//
//    static void
//    first_gesture_begin_cb (GtkGesture       *first_gesture,
//                            GdkEventSequence *sequence,
//                            gpointer          user_data)
//    {
//      gtk_gesture_set_sequence_state (first_gesture, sequence, GTK_EVENT_SEQUENCE_CLAIMED);
//      gtk_gesture_set_sequence_state (second_gesture, sequence, GTK_EVENT_SEQUENCE_DENIED);
//    }
//
//    static void
//    second_gesture_begin_cb (GtkGesture       *second_gesture,
//                             GdkEventSequence *sequence,
//                             gpointer          user_data)
//    {
//      if (gtk_gesture_get_sequence_state (first_gesture, sequence) == GTK_EVENT_SEQUENCE_CLAIMED)
//        gtk_gesture_set_sequence_state (second_gesture, sequence, GTK_EVENT_SEQUENCE_DENIED);
//    }
//
//
// If both gestures are in the same group, just set the state on the gesture
// emitting the event, the sequence will be already be initialized to the
// group's global state when the second gesture processes the event.
func (gesture gesture) SetSequenceState(sequence *gdk.EventSequence, state EventSequenceState) bool {
	var arg0 *C.GtkGesture
	var arg1 *C.GdkEventSequence
	var arg2 C.GtkEventSequenceState

	arg0 = (*C.GtkGesture)(gesture.Native())
	arg1 = (*C.GdkEventSequence)(sequence.Native())
	arg2 = (C.GtkEventSequenceState)(state)

	ret := C.gtk_gesture_set_sequence_state(arg0, arg1, arg2)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// SetState sets the state of all sequences that @gesture is currently
// interacting with. See gtk_gesture_set_sequence_state() for more details
// on sequence states.
func (gesture gesture) SetState(state EventSequenceState) bool {
	var arg0 *C.GtkGesture
	var arg1 C.GtkEventSequenceState

	arg0 = (*C.GtkGesture)(gesture.Native())
	arg1 = (C.GtkEventSequenceState)(state)

	ret := C.gtk_gesture_set_state(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Ungroup separates @gesture into an isolated group.
func (gesture gesture) Ungroup() {
	var arg0 *C.GtkGesture

	arg0 = (*C.GtkGesture)(gesture.Native())

	C.gtk_gesture_ungroup(arg0)
}

// GestureClick is a Gesture implementation able to recognize multiple clicks on
// a nearby zone, which can be listened for through the GestureClick::pressed
// signal. Whenever time or distance between clicks exceed the GTK defaults,
// GestureClick::stopped is emitted, and the click counter is reset.
type GestureClick interface {
	GestureSingle
}

type gestureClick struct {
	gestureSingle
}

// WrapGestureClick wraps a GObject to the right type. It is
// primarily used internally.
func WrapGestureClick(obj *externglib.Object) GestureClick {
	return gestureClick{gestureSingle{gesture{eventController{*externglib.Object{obj}}}}}
}

func marshalGestureClick(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapGestureClick(obj), nil
}

// NewGestureClick constructs a class GestureClick.
func NewGestureClick() GestureClick {

	ret := C.gtk_gesture_click_new()

	var ret0 GestureClick

	ret0 = WrapGestureClick(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// GestureDrag is a Gesture implementation that recognizes drag operations. The
// drag operation itself can be tracked throughout the GestureDrag::drag-begin,
// GestureDrag::drag-update and GestureDrag::drag-end signals, or the relevant
// coordinates be extracted through gtk_gesture_drag_get_offset() and
// gtk_gesture_drag_get_start_point().
type GestureDrag interface {
	GestureSingle

	// Offset: if the @gesture is active, this function returns true and fills
	// in @x and @y with the coordinates of the current point, as an offset to
	// the starting drag point.
	Offset() (x float64, y float64, ok bool)
	// StartPoint: if the @gesture is active, this function returns true and
	// fills in @x and @y with the drag start coordinates, in window-relative
	// coordinates.
	StartPoint() (x float64, y float64, ok bool)
}

type gestureDrag struct {
	gestureSingle
}

// WrapGestureDrag wraps a GObject to the right type. It is
// primarily used internally.
func WrapGestureDrag(obj *externglib.Object) GestureDrag {
	return gestureDrag{gestureSingle{gesture{eventController{*externglib.Object{obj}}}}}
}

func marshalGestureDrag(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapGestureDrag(obj), nil
}

// NewGestureDrag constructs a class GestureDrag.
func NewGestureDrag() GestureDrag {

	ret := C.gtk_gesture_drag_new()

	var ret0 GestureDrag

	ret0 = WrapGestureDrag(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Offset: if the @gesture is active, this function returns true and fills
// in @x and @y with the coordinates of the current point, as an offset to
// the starting drag point.
func (gesture gestureDrag) Offset() (x float64, y float64, ok bool) {
	var arg0 *C.GtkGestureDrag
	var arg1 *C.double // out
	var arg2 *C.double // out

	arg0 = (*C.GtkGestureDrag)(gesture.Native())

	ret := C.gtk_gesture_drag_get_offset(arg0, &arg1, &arg2)

	var ret0 float64
	var ret1 float64
	var ret2 bool

	ret0 = float64(arg1)

	ret1 = float64(arg2)

	ret2 = gextras.Gobool(ret)

	return ret0, ret1, ret2
}

// StartPoint: if the @gesture is active, this function returns true and
// fills in @x and @y with the drag start coordinates, in window-relative
// coordinates.
func (gesture gestureDrag) StartPoint() (x float64, y float64, ok bool) {
	var arg0 *C.GtkGestureDrag
	var arg1 *C.double // out
	var arg2 *C.double // out

	arg0 = (*C.GtkGestureDrag)(gesture.Native())

	ret := C.gtk_gesture_drag_get_start_point(arg0, &arg1, &arg2)

	var ret0 float64
	var ret1 float64
	var ret2 bool

	ret0 = float64(arg1)

	ret1 = float64(arg2)

	ret2 = gextras.Gobool(ret)

	return ret0, ret1, ret2
}

// GestureLongPress is a Gesture implementation able to recognize long presses,
// triggering the GestureLongPress::pressed after the timeout is exceeded.
//
// If the touchpoint is lifted before the timeout passes, or if it drifts too
// far of the initial press point, the GestureLongPress::cancelled signal will
// be emitted.
type GestureLongPress interface {
	GestureSingle

	// DelayFactor returns the delay factor as set by
	// gtk_gesture_long_press_set_delay_factor().
	DelayFactor() float64
	// SetDelayFactor applies the given delay factor. The default long press
	// time will be multiplied by this value. Valid values are in the range
	// [0.5..2.0].
	SetDelayFactor(delayFactor float64)
}

type gestureLongPress struct {
	gestureSingle
}

// WrapGestureLongPress wraps a GObject to the right type. It is
// primarily used internally.
func WrapGestureLongPress(obj *externglib.Object) GestureLongPress {
	return gestureLongPress{gestureSingle{gesture{eventController{*externglib.Object{obj}}}}}
}

func marshalGestureLongPress(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapGestureLongPress(obj), nil
}

// NewGestureLongPress constructs a class GestureLongPress.
func NewGestureLongPress() GestureLongPress {

	ret := C.gtk_gesture_long_press_new()

	var ret0 GestureLongPress

	ret0 = WrapGestureLongPress(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// DelayFactor returns the delay factor as set by
// gtk_gesture_long_press_set_delay_factor().
func (gesture gestureLongPress) DelayFactor() float64 {
	var arg0 *C.GtkGestureLongPress

	arg0 = (*C.GtkGestureLongPress)(gesture.Native())

	ret := C.gtk_gesture_long_press_get_delay_factor(arg0)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// SetDelayFactor applies the given delay factor. The default long press
// time will be multiplied by this value. Valid values are in the range
// [0.5..2.0].
func (gesture gestureLongPress) SetDelayFactor(delayFactor float64) {
	var arg0 *C.GtkGestureLongPress
	var arg1 C.double

	arg0 = (*C.GtkGestureLongPress)(gesture.Native())
	arg1 = C.double(delayFactor)

	C.gtk_gesture_long_press_set_delay_factor(arg0, arg1)
}

// GesturePan is a Gesture implementation able to recognize pan gestures, those
// are drags that are locked to happen along one axis. The axis that a
// GesturePan handles is defined at construct time, and can be changed through
// gtk_gesture_pan_set_orientation().
//
// When the gesture starts to be recognized, GesturePan will attempt to
// determine as early as possible whether the sequence is moving in the expected
// direction, and denying the sequence if this does not happen.
//
// Once a panning gesture along the expected axis is recognized, the
// GesturePan::pan signal will be emitted as input events are received,
// containing the offset in the given axis.
type GesturePan interface {
	GestureDrag

	// Orientation returns the orientation of the pan gestures that this
	// @gesture expects.
	Orientation() Orientation
	// SetOrientation sets the orientation to be expected on pan gestures.
	SetOrientation(orientation Orientation)
}

type gesturePan struct {
	gestureDrag
}

// WrapGesturePan wraps a GObject to the right type. It is
// primarily used internally.
func WrapGesturePan(obj *externglib.Object) GesturePan {
	return gesturePan{gestureDrag{gestureSingle{gesture{eventController{*externglib.Object{obj}}}}}}
}

func marshalGesturePan(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapGesturePan(obj), nil
}

// NewGesturePan constructs a class GesturePan.
func NewGesturePan(orientation Orientation) GesturePan {
	var arg1 C.GtkOrientation

	arg1 = (C.GtkOrientation)(orientation)

	ret := C.gtk_gesture_pan_new(arg1)

	var ret0 GesturePan

	ret0 = WrapGesturePan(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Orientation returns the orientation of the pan gestures that this
// @gesture expects.
func (gesture gesturePan) Orientation() Orientation {
	var arg0 *C.GtkGesturePan

	arg0 = (*C.GtkGesturePan)(gesture.Native())

	ret := C.gtk_gesture_pan_get_orientation(arg0)

	var ret0 Orientation

	ret0 = Orientation(ret)

	return ret0
}

// SetOrientation sets the orientation to be expected on pan gestures.
func (gesture gesturePan) SetOrientation(orientation Orientation) {
	var arg0 *C.GtkGesturePan
	var arg1 C.GtkOrientation

	arg0 = (*C.GtkGesturePan)(gesture.Native())
	arg1 = (C.GtkOrientation)(orientation)

	C.gtk_gesture_pan_set_orientation(arg0, arg1)
}

// GestureRotate is a Gesture implementation able to recognize 2-finger
// rotations, whenever the angle between both handled sequences changes, the
// GestureRotate::angle-changed signal is emitted.
type GestureRotate interface {
	Gesture

	// AngleDelta: if @gesture is active, this function returns the angle
	// difference in radians since the gesture was first recognized. If @gesture
	// is not active, 0 is returned.
	AngleDelta() float64
}

type gestureRotate struct {
	gesture
}

// WrapGestureRotate wraps a GObject to the right type. It is
// primarily used internally.
func WrapGestureRotate(obj *externglib.Object) GestureRotate {
	return gestureRotate{gesture{eventController{*externglib.Object{obj}}}}
}

func marshalGestureRotate(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapGestureRotate(obj), nil
}

// NewGestureRotate constructs a class GestureRotate.
func NewGestureRotate() GestureRotate {

	ret := C.gtk_gesture_rotate_new()

	var ret0 GestureRotate

	ret0 = WrapGestureRotate(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// AngleDelta: if @gesture is active, this function returns the angle
// difference in radians since the gesture was first recognized. If @gesture
// is not active, 0 is returned.
func (gesture gestureRotate) AngleDelta() float64 {
	var arg0 *C.GtkGestureRotate

	arg0 = (*C.GtkGestureRotate)(gesture.Native())

	ret := C.gtk_gesture_rotate_get_angle_delta(arg0)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// GestureSingle is a subclass of Gesture, optimized (although not restricted)
// for dealing with mouse and single-touch gestures. Under interaction, these
// gestures stick to the first interacting sequence, which is accessible through
// gtk_gesture_single_get_current_sequence() while the gesture is being
// interacted with.
//
// By default gestures react to both GDK_BUTTON_PRIMARY and touch events,
// gtk_gesture_single_set_touch_only() can be used to change the touch behavior.
// Callers may also specify a different mouse button number to interact with
// through gtk_gesture_single_set_button(), or react to any mouse button by
// setting 0. While the gesture is active, the button being currently pressed
// can be known through gtk_gesture_single_get_current_button().
type GestureSingle interface {
	Gesture

	// Button returns the button number @gesture listens for, or 0 if @gesture
	// reacts to any button press.
	Button() uint
	// CurrentButton returns the button number currently interacting with
	// @gesture, or 0 if there is none.
	CurrentButton() uint
	// CurrentSequence returns the event sequence currently interacting with
	// @gesture. This is only meaningful if gtk_gesture_is_active() returns
	// true.
	CurrentSequence() *gdk.EventSequence
	// Exclusive gets whether a gesture is exclusive. For more information, see
	// gtk_gesture_single_set_exclusive().
	Exclusive() bool
	// TouchOnly returns true if the gesture is only triggered by touch events.
	TouchOnly() bool
	// SetButton sets the button number @gesture listens to. If non-0, every
	// button press from a different button number will be ignored. Touch events
	// implicitly match with button 1.
	SetButton(button uint)
	// SetExclusive sets whether @gesture is exclusive. An exclusive gesture
	// will only handle pointer and "pointer emulated" touch events, so at any
	// given time, there is only one sequence able to interact with those.
	SetExclusive(exclusive bool)
	// SetTouchOnly: if @touch_only is true, @gesture will only handle events of
	// type K_TOUCH_BEGIN, K_TOUCH_UPDATE or K_TOUCH_END. If false, mouse events
	// will be handled too.
	SetTouchOnly(touchOnly bool)
}

type gestureSingle struct {
	gesture
}

// WrapGestureSingle wraps a GObject to the right type. It is
// primarily used internally.
func WrapGestureSingle(obj *externglib.Object) GestureSingle {
	return gestureSingle{gesture{eventController{*externglib.Object{obj}}}}
}

func marshalGestureSingle(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapGestureSingle(obj), nil
}

// Button returns the button number @gesture listens for, or 0 if @gesture
// reacts to any button press.
func (gesture gestureSingle) Button() uint {
	var arg0 *C.GtkGestureSingle

	arg0 = (*C.GtkGestureSingle)(gesture.Native())

	ret := C.gtk_gesture_single_get_button(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// CurrentButton returns the button number currently interacting with
// @gesture, or 0 if there is none.
func (gesture gestureSingle) CurrentButton() uint {
	var arg0 *C.GtkGestureSingle

	arg0 = (*C.GtkGestureSingle)(gesture.Native())

	ret := C.gtk_gesture_single_get_current_button(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// CurrentSequence returns the event sequence currently interacting with
// @gesture. This is only meaningful if gtk_gesture_is_active() returns
// true.
func (gesture gestureSingle) CurrentSequence() *gdk.EventSequence {
	var arg0 *C.GtkGestureSingle

	arg0 = (*C.GtkGestureSingle)(gesture.Native())

	ret := C.gtk_gesture_single_get_current_sequence(arg0)

	var ret0 *gdk.EventSequence

	ret0 = gdk.WrapEventSequence(ret)

	return ret0
}

// Exclusive gets whether a gesture is exclusive. For more information, see
// gtk_gesture_single_set_exclusive().
func (gesture gestureSingle) Exclusive() bool {
	var arg0 *C.GtkGestureSingle

	arg0 = (*C.GtkGestureSingle)(gesture.Native())

	ret := C.gtk_gesture_single_get_exclusive(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// TouchOnly returns true if the gesture is only triggered by touch events.
func (gesture gestureSingle) TouchOnly() bool {
	var arg0 *C.GtkGestureSingle

	arg0 = (*C.GtkGestureSingle)(gesture.Native())

	ret := C.gtk_gesture_single_get_touch_only(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// SetButton sets the button number @gesture listens to. If non-0, every
// button press from a different button number will be ignored. Touch events
// implicitly match with button 1.
func (gesture gestureSingle) SetButton(button uint) {
	var arg0 *C.GtkGestureSingle
	var arg1 C.guint

	arg0 = (*C.GtkGestureSingle)(gesture.Native())
	arg1 = C.guint(button)

	C.gtk_gesture_single_set_button(arg0, arg1)
}

// SetExclusive sets whether @gesture is exclusive. An exclusive gesture
// will only handle pointer and "pointer emulated" touch events, so at any
// given time, there is only one sequence able to interact with those.
func (gesture gestureSingle) SetExclusive(exclusive bool) {
	var arg0 *C.GtkGestureSingle
	var arg1 C.gboolean

	arg0 = (*C.GtkGestureSingle)(gesture.Native())
	arg1 = gextras.Cbool(exclusive)

	C.gtk_gesture_single_set_exclusive(arg0, arg1)
}

// SetTouchOnly: if @touch_only is true, @gesture will only handle events of
// type K_TOUCH_BEGIN, K_TOUCH_UPDATE or K_TOUCH_END. If false, mouse events
// will be handled too.
func (gesture gestureSingle) SetTouchOnly(touchOnly bool) {
	var arg0 *C.GtkGestureSingle
	var arg1 C.gboolean

	arg0 = (*C.GtkGestureSingle)(gesture.Native())
	arg1 = gextras.Cbool(touchOnly)

	C.gtk_gesture_single_set_touch_only(arg0, arg1)
}

// GestureStylus is a Gesture implementation specific to stylus input. The
// provided signals just relay the basic information of the stylus events.
type GestureStylus interface {
	GestureSingle

	// Axes returns the current values for the requested @axes. This function
	// must be called from either the GestureStylus::down,
	// GestureStylus::motion, GestureStylus::up or GestureStylus::proximity
	// signals.
	Axes(axes []gdk.AxisUse) (values []float64, ok bool)
	// Axis returns the current value for the requested @axis.
	//
	// This function must be called from the handler of one of the
	// GestureStylus::down, GestureStylus::motion, GestureStylus::up or
	// GestureStylus::proximity signals.
	Axis(axis gdk.AxisUse) (value float64, ok bool)
	// Backlog: by default, GTK will limit rate of input events. On stylus input
	// where accuracy of strokes is paramount, this function returns the
	// accumulated coordinate/timing state before the emission of the current
	// GestureStylus::motion signal.
	//
	// This function may only be called within a GestureStylus::motion signal
	// handler, the state given in this signal and obtainable through
	// gtk_gesture_stylus_get_axis() call express the latest (most up-to-date)
	// state in motion history.
	//
	// The @backlog is provided in chronological order.
	Backlog() (backlog []*gdk.TimeCoord, nElems uint, ok bool)
	// DeviceTool returns the DeviceTool currently driving input through this
	// gesture. This function must be called from either the
	// GestureStylus::down, GestureStylus::motion, GestureStylus::up or
	// GestureStylus::proximity signal handlers.
	DeviceTool() gdk.DeviceTool
}

type gestureStylus struct {
	gestureSingle
}

// WrapGestureStylus wraps a GObject to the right type. It is
// primarily used internally.
func WrapGestureStylus(obj *externglib.Object) GestureStylus {
	return gestureStylus{gestureSingle{gesture{eventController{*externglib.Object{obj}}}}}
}

func marshalGestureStylus(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapGestureStylus(obj), nil
}

// NewGestureStylus constructs a class GestureStylus.
func NewGestureStylus() GestureStylus {

	ret := C.gtk_gesture_stylus_new()

	var ret0 GestureStylus

	ret0 = WrapGestureStylus(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Axes returns the current values for the requested @axes. This function
// must be called from either the GestureStylus::down,
// GestureStylus::motion, GestureStylus::up or GestureStylus::proximity
// signals.
func (gesture gestureStylus) Axes(axes []gdk.AxisUse) (values []float64, ok bool) {
	var arg0 *C.GtkGestureStylus
	var arg1 *C.GdkAxisUse
	var arg2 **C.double // out

	arg0 = (*C.GtkGestureStylus)(gesture.Native())
	{

	}

	ret := C.gtk_gesture_stylus_get_axes(arg0, arg1, &arg2)

	var ret0 []float64
	var ret1 bool

	{
		var length uint
		for p := unsafe.Pointer(arg2); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]float64, length)
		for i := 0; i < length; i++ {
			src := (*C.double)(unsafe.Pointer(uintptr(unsafe.Pointer(arg2)) + i))
			ret0[i] = float64(src)
		}
	}

	ret1 = gextras.Gobool(ret)

	return ret0, ret1
}

// Axis returns the current value for the requested @axis.
//
// This function must be called from the handler of one of the
// GestureStylus::down, GestureStylus::motion, GestureStylus::up or
// GestureStylus::proximity signals.
func (gesture gestureStylus) Axis(axis gdk.AxisUse) (value float64, ok bool) {
	var arg0 *C.GtkGestureStylus
	var arg1 C.GdkAxisUse
	var arg2 *C.double // out

	arg0 = (*C.GtkGestureStylus)(gesture.Native())
	arg1 = (C.GdkAxisUse)(axis)

	ret := C.gtk_gesture_stylus_get_axis(arg0, arg1, &arg2)

	var ret0 float64
	var ret1 bool

	ret0 = float64(arg2)

	ret1 = gextras.Gobool(ret)

	return ret0, ret1
}

// Backlog: by default, GTK will limit rate of input events. On stylus input
// where accuracy of strokes is paramount, this function returns the
// accumulated coordinate/timing state before the emission of the current
// GestureStylus::motion signal.
//
// This function may only be called within a GestureStylus::motion signal
// handler, the state given in this signal and obtainable through
// gtk_gesture_stylus_get_axis() call express the latest (most up-to-date)
// state in motion history.
//
// The @backlog is provided in chronological order.
func (gesture gestureStylus) Backlog() (backlog []*gdk.TimeCoord, nElems uint, ok bool) {
	var arg0 *C.GtkGestureStylus
	var arg1 **C.GdkTimeCoord // out
	var arg2 *C.guint         // out

	arg0 = (*C.GtkGestureStylus)(gesture.Native())

	ret := C.gtk_gesture_stylus_get_backlog(arg0, &arg1, &arg2)

	var ret0 []*gdk.TimeCoord
	var ret1 uint
	var ret2 bool

	{
		ret0 = make([]*gdk.TimeCoord, arg2)
		for i := 0; i < uintptr(arg2); i++ {
			src := (*C.GdkTimeCoord)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			ret0[i] = gdk.WrapTimeCoord(src)
		}
	}

	ret1 = uint(arg2)

	ret2 = gextras.Gobool(ret)

	return ret0, ret1, ret2
}

// DeviceTool returns the DeviceTool currently driving input through this
// gesture. This function must be called from either the
// GestureStylus::down, GestureStylus::motion, GestureStylus::up or
// GestureStylus::proximity signal handlers.
func (gesture gestureStylus) DeviceTool() gdk.DeviceTool {
	var arg0 *C.GtkGestureStylus

	arg0 = (*C.GtkGestureStylus)(gesture.Native())

	ret := C.gtk_gesture_stylus_get_device_tool(arg0)

	var ret0 gdk.DeviceTool

	ret0 = gdk.WrapDeviceTool(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// GestureSwipe is a Gesture implementation able to recognize swipes, after a
// press/move/.../move/release sequence happens, the GestureSwipe::swipe signal
// will be emitted, providing the velocity and directionality of the sequence at
// the time it was lifted.
//
// If the velocity is desired in intermediate points,
// gtk_gesture_swipe_get_velocity() can be called on eg. a Gesture::update
// handler.
//
// All velocities are reported in pixels/sec units.
type GestureSwipe interface {
	GestureSingle

	// Velocity: if the gesture is recognized, this function returns true and
	// fill in @velocity_x and @velocity_y with the recorded velocity, as per
	// the last event(s) processed.
	Velocity() (velocityX float64, velocityY float64, ok bool)
}

type gestureSwipe struct {
	gestureSingle
}

// WrapGestureSwipe wraps a GObject to the right type. It is
// primarily used internally.
func WrapGestureSwipe(obj *externglib.Object) GestureSwipe {
	return gestureSwipe{gestureSingle{gesture{eventController{*externglib.Object{obj}}}}}
}

func marshalGestureSwipe(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapGestureSwipe(obj), nil
}

// NewGestureSwipe constructs a class GestureSwipe.
func NewGestureSwipe() GestureSwipe {

	ret := C.gtk_gesture_swipe_new()

	var ret0 GestureSwipe

	ret0 = WrapGestureSwipe(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Velocity: if the gesture is recognized, this function returns true and
// fill in @velocity_x and @velocity_y with the recorded velocity, as per
// the last event(s) processed.
func (gesture gestureSwipe) Velocity() (velocityX float64, velocityY float64, ok bool) {
	var arg0 *C.GtkGestureSwipe
	var arg1 *C.double // out
	var arg2 *C.double // out

	arg0 = (*C.GtkGestureSwipe)(gesture.Native())

	ret := C.gtk_gesture_swipe_get_velocity(arg0, &arg1, &arg2)

	var ret0 float64
	var ret1 float64
	var ret2 bool

	ret0 = float64(arg1)

	ret1 = float64(arg2)

	ret2 = gextras.Gobool(ret)

	return ret0, ret1, ret2
}

// GestureZoom is a Gesture implementation able to recognize pinch/zoom
// gestures, whenever the distance between both tracked sequences changes, the
// GestureZoom::scale-changed signal is emitted to report the scale factor.
type GestureZoom interface {
	Gesture

	// ScaleDelta: if @gesture is active, this function returns the zooming
	// difference since the gesture was recognized (hence the starting point is
	// considered 1:1). If @gesture is not active, 1 is returned.
	ScaleDelta() float64
}

type gestureZoom struct {
	gesture
}

// WrapGestureZoom wraps a GObject to the right type. It is
// primarily used internally.
func WrapGestureZoom(obj *externglib.Object) GestureZoom {
	return gestureZoom{gesture{eventController{*externglib.Object{obj}}}}
}

func marshalGestureZoom(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapGestureZoom(obj), nil
}

// NewGestureZoom constructs a class GestureZoom.
func NewGestureZoom() GestureZoom {

	ret := C.gtk_gesture_zoom_new()

	var ret0 GestureZoom

	ret0 = WrapGestureZoom(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// ScaleDelta: if @gesture is active, this function returns the zooming
// difference since the gesture was recognized (hence the starting point is
// considered 1:1). If @gesture is not active, 1 is returned.
func (gesture gestureZoom) ScaleDelta() float64 {
	var arg0 *C.GtkGestureZoom

	arg0 = (*C.GtkGestureZoom)(gesture.Native())

	ret := C.gtk_gesture_zoom_get_scale_delta(arg0)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// Grid: gtkGrid is a container which arranges its child widgets in rows and
// columns, with arbitrary positions and horizontal/vertical spans.
//
// Children are added using gtk_grid_attach(). They can span multiple rows or
// columns. It is also possible to add a child next to an existing child, using
// gtk_grid_attach_next_to(). To remove a child from the grid, use
// gtk_grid_remove(). The behaviour of GtkGrid when several children occupy the
// same grid cell is undefined.
//
//
// CSS nodes
//
// GtkGrid uses a single CSS node with name `grid`.
//
//
// Accessibility
//
// GtkGrid uses the GTK_ACCESSIBLE_ROLE_GROUP role.
type Grid interface {
	Widget

	// Attach adds a widget to the grid.
	//
	// The position of @child is determined by @column and @row. The number of
	// “cells” that @child will occupy is determined by @width and @height.
	Attach(child Widget, column int, row int, width int, height int)
	// AttachNextTo adds a widget to the grid.
	//
	// The widget is placed next to @sibling, on the side determined by @side.
	// When @sibling is nil, the widget is placed in row (for left or right
	// placement) or column 0 (for top or bottom placement), at the end
	// indicated by @side.
	//
	// Attaching widgets labeled [1], [2], [3] with @sibling == nil and @side ==
	// GTK_POS_LEFT yields a layout of [3][2][1].
	AttachNextTo(child Widget, sibling Widget, side PositionType, width int, height int)
	// BaselineRow returns which row defines the global baseline of @grid.
	BaselineRow() int
	// ChildAt gets the child of @grid whose area covers the grid cell at
	// @column, @row.
	ChildAt(column int, row int) Widget
	// ColumnHomogeneous returns whether all columns of @grid have the same
	// width.
	ColumnHomogeneous() bool
	// ColumnSpacing returns the amount of space between the columns of @grid.
	ColumnSpacing() uint
	// RowBaselinePosition returns the baseline position of @row as set by
	// gtk_grid_set_row_baseline_position() or the default value
	// GTK_BASELINE_POSITION_CENTER.
	RowBaselinePosition(row int) BaselinePosition
	// RowHomogeneous returns whether all rows of @grid have the same height.
	RowHomogeneous() bool
	// RowSpacing returns the amount of space between the rows of @grid.
	RowSpacing() uint
	// InsertColumn inserts a column at the specified position.
	//
	// Children which are attached at or to the right of this position are moved
	// one column to the right. Children which span across this position are
	// grown to span the new column.
	InsertColumn(position int)
	// InsertNextTo inserts a row or column at the specified position.
	//
	// The new row or column is placed next to @sibling, on the side determined
	// by @side. If @side is GTK_POS_TOP or GTK_POS_BOTTOM, a row is inserted.
	// If @side is GTK_POS_LEFT of GTK_POS_RIGHT, a column is inserted.
	InsertNextTo(sibling Widget, side PositionType)
	// InsertRow inserts a row at the specified position.
	//
	// Children which are attached at or below this position are moved one row
	// down. Children which span across this position are grown to span the new
	// row.
	InsertRow(position int)
	// QueryChild queries the attach points and spans of @child inside the given
	// Grid.
	QueryChild(child Widget) (column int, row int, width int, height int)
	// Remove removes a child from @grid, after it has been added with
	// gtk_grid_attach() or gtk_grid_attach_next_to().
	Remove(child Widget)
	// RemoveColumn removes a column from the grid.
	//
	// Children that are placed in this column are removed, spanning children
	// that overlap this column have their width reduced by one, and children
	// after the column are moved to the left.
	RemoveColumn(position int)
	// RemoveRow removes a row from the grid.
	//
	// Children that are placed in this row are removed, spanning children that
	// overlap this row have their height reduced by one, and children below the
	// row are moved up.
	RemoveRow(position int)
	// SetBaselineRow sets which row defines the global baseline for the entire
	// grid. Each row in the grid can have its own local baseline, but only one
	// of those is global, meaning it will be the baseline in the parent of the
	// @grid.
	SetBaselineRow(row int)
	// SetColumnHomogeneous sets whether all columns of @grid will have the same
	// width.
	SetColumnHomogeneous(homogeneous bool)
	// SetColumnSpacing sets the amount of space between columns of @grid.
	SetColumnSpacing(spacing uint)
	// SetRowBaselinePosition sets how the baseline should be positioned on @row
	// of the grid, in case that row is assigned more space than is requested.
	SetRowBaselinePosition(row int, pos BaselinePosition)
	// SetRowHomogeneous sets whether all rows of @grid will have the same
	// height.
	SetRowHomogeneous(homogeneous bool)
	// SetRowSpacing sets the amount of space between rows of @grid.
	SetRowSpacing(spacing uint)
}

type grid struct {
	widget
}

// WrapGrid wraps a GObject to the right type. It is
// primarily used internally.
func WrapGrid(obj *externglib.Object) Grid {
	return grid{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}
}

func marshalGrid(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapGrid(obj), nil
}

// NewGrid constructs a class Grid.
func NewGrid() Grid {

	ret := C.gtk_grid_new()

	var ret0 Grid

	ret0 = WrapGrid(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Attach adds a widget to the grid.
//
// The position of @child is determined by @column and @row. The number of
// “cells” that @child will occupy is determined by @width and @height.
func (grid grid) Attach(child Widget, column int, row int, width int, height int) {
	var arg0 *C.GtkGrid
	var arg1 *C.GtkWidget
	var arg2 C.int
	var arg3 C.int
	var arg4 C.int
	var arg5 C.int

	arg0 = (*C.GtkGrid)(grid.Native())
	arg1 = (*C.GtkWidget)(child.Native())
	arg2 = C.int(column)
	arg3 = C.int(row)
	arg4 = C.int(width)
	arg5 = C.int(height)

	C.gtk_grid_attach(arg0, arg1, arg2, arg3, arg4, arg5)
}

// AttachNextTo adds a widget to the grid.
//
// The widget is placed next to @sibling, on the side determined by @side.
// When @sibling is nil, the widget is placed in row (for left or right
// placement) or column 0 (for top or bottom placement), at the end
// indicated by @side.
//
// Attaching widgets labeled [1], [2], [3] with @sibling == nil and @side ==
// GTK_POS_LEFT yields a layout of [3][2][1].
func (grid grid) AttachNextTo(child Widget, sibling Widget, side PositionType, width int, height int) {
	var arg0 *C.GtkGrid
	var arg1 *C.GtkWidget
	var arg2 *C.GtkWidget
	var arg3 C.GtkPositionType
	var arg4 C.int
	var arg5 C.int

	arg0 = (*C.GtkGrid)(grid.Native())
	arg1 = (*C.GtkWidget)(child.Native())
	arg2 = (*C.GtkWidget)(sibling.Native())
	arg3 = (C.GtkPositionType)(side)
	arg4 = C.int(width)
	arg5 = C.int(height)

	C.gtk_grid_attach_next_to(arg0, arg1, arg2, arg3, arg4, arg5)
}

// BaselineRow returns which row defines the global baseline of @grid.
func (grid grid) BaselineRow() int {
	var arg0 *C.GtkGrid

	arg0 = (*C.GtkGrid)(grid.Native())

	ret := C.gtk_grid_get_baseline_row(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// ChildAt gets the child of @grid whose area covers the grid cell at
// @column, @row.
func (grid grid) ChildAt(column int, row int) Widget {
	var arg0 *C.GtkGrid
	var arg1 C.int
	var arg2 C.int

	arg0 = (*C.GtkGrid)(grid.Native())
	arg1 = C.int(column)
	arg2 = C.int(row)

	ret := C.gtk_grid_get_child_at(arg0, arg1, arg2)

	var ret0 Widget

	ret0 = WrapWidget(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// ColumnHomogeneous returns whether all columns of @grid have the same
// width.
func (grid grid) ColumnHomogeneous() bool {
	var arg0 *C.GtkGrid

	arg0 = (*C.GtkGrid)(grid.Native())

	ret := C.gtk_grid_get_column_homogeneous(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// ColumnSpacing returns the amount of space between the columns of @grid.
func (grid grid) ColumnSpacing() uint {
	var arg0 *C.GtkGrid

	arg0 = (*C.GtkGrid)(grid.Native())

	ret := C.gtk_grid_get_column_spacing(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// RowBaselinePosition returns the baseline position of @row as set by
// gtk_grid_set_row_baseline_position() or the default value
// GTK_BASELINE_POSITION_CENTER.
func (grid grid) RowBaselinePosition(row int) BaselinePosition {
	var arg0 *C.GtkGrid
	var arg1 C.int

	arg0 = (*C.GtkGrid)(grid.Native())
	arg1 = C.int(row)

	ret := C.gtk_grid_get_row_baseline_position(arg0, arg1)

	var ret0 BaselinePosition

	ret0 = BaselinePosition(ret)

	return ret0
}

// RowHomogeneous returns whether all rows of @grid have the same height.
func (grid grid) RowHomogeneous() bool {
	var arg0 *C.GtkGrid

	arg0 = (*C.GtkGrid)(grid.Native())

	ret := C.gtk_grid_get_row_homogeneous(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// RowSpacing returns the amount of space between the rows of @grid.
func (grid grid) RowSpacing() uint {
	var arg0 *C.GtkGrid

	arg0 = (*C.GtkGrid)(grid.Native())

	ret := C.gtk_grid_get_row_spacing(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// InsertColumn inserts a column at the specified position.
//
// Children which are attached at or to the right of this position are moved
// one column to the right. Children which span across this position are
// grown to span the new column.
func (grid grid) InsertColumn(position int) {
	var arg0 *C.GtkGrid
	var arg1 C.int

	arg0 = (*C.GtkGrid)(grid.Native())
	arg1 = C.int(position)

	C.gtk_grid_insert_column(arg0, arg1)
}

// InsertNextTo inserts a row or column at the specified position.
//
// The new row or column is placed next to @sibling, on the side determined
// by @side. If @side is GTK_POS_TOP or GTK_POS_BOTTOM, a row is inserted.
// If @side is GTK_POS_LEFT of GTK_POS_RIGHT, a column is inserted.
func (grid grid) InsertNextTo(sibling Widget, side PositionType) {
	var arg0 *C.GtkGrid
	var arg1 *C.GtkWidget
	var arg2 C.GtkPositionType

	arg0 = (*C.GtkGrid)(grid.Native())
	arg1 = (*C.GtkWidget)(sibling.Native())
	arg2 = (C.GtkPositionType)(side)

	C.gtk_grid_insert_next_to(arg0, arg1, arg2)
}

// InsertRow inserts a row at the specified position.
//
// Children which are attached at or below this position are moved one row
// down. Children which span across this position are grown to span the new
// row.
func (grid grid) InsertRow(position int) {
	var arg0 *C.GtkGrid
	var arg1 C.int

	arg0 = (*C.GtkGrid)(grid.Native())
	arg1 = C.int(position)

	C.gtk_grid_insert_row(arg0, arg1)
}

// QueryChild queries the attach points and spans of @child inside the given
// Grid.
func (grid grid) QueryChild(child Widget) (column int, row int, width int, height int) {
	var arg0 *C.GtkGrid
	var arg1 *C.GtkWidget
	var arg2 *C.int // out
	var arg3 *C.int // out
	var arg4 *C.int // out
	var arg5 *C.int // out

	arg0 = (*C.GtkGrid)(grid.Native())
	arg1 = (*C.GtkWidget)(child.Native())

	ret := C.gtk_grid_query_child(arg0, arg1, &arg2, &arg3, &arg4, &arg5)

	var ret0 int
	var ret1 int
	var ret2 int
	var ret3 int

	ret0 = int(arg2)

	ret1 = int(arg3)

	ret2 = int(arg4)

	ret3 = int(arg5)

	return ret0, ret1, ret2, ret3
}

// Remove removes a child from @grid, after it has been added with
// gtk_grid_attach() or gtk_grid_attach_next_to().
func (grid grid) Remove(child Widget) {
	var arg0 *C.GtkGrid
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkGrid)(grid.Native())
	arg1 = (*C.GtkWidget)(child.Native())

	C.gtk_grid_remove(arg0, arg1)
}

// RemoveColumn removes a column from the grid.
//
// Children that are placed in this column are removed, spanning children
// that overlap this column have their width reduced by one, and children
// after the column are moved to the left.
func (grid grid) RemoveColumn(position int) {
	var arg0 *C.GtkGrid
	var arg1 C.int

	arg0 = (*C.GtkGrid)(grid.Native())
	arg1 = C.int(position)

	C.gtk_grid_remove_column(arg0, arg1)
}

// RemoveRow removes a row from the grid.
//
// Children that are placed in this row are removed, spanning children that
// overlap this row have their height reduced by one, and children below the
// row are moved up.
func (grid grid) RemoveRow(position int) {
	var arg0 *C.GtkGrid
	var arg1 C.int

	arg0 = (*C.GtkGrid)(grid.Native())
	arg1 = C.int(position)

	C.gtk_grid_remove_row(arg0, arg1)
}

// SetBaselineRow sets which row defines the global baseline for the entire
// grid. Each row in the grid can have its own local baseline, but only one
// of those is global, meaning it will be the baseline in the parent of the
// @grid.
func (grid grid) SetBaselineRow(row int) {
	var arg0 *C.GtkGrid
	var arg1 C.int

	arg0 = (*C.GtkGrid)(grid.Native())
	arg1 = C.int(row)

	C.gtk_grid_set_baseline_row(arg0, arg1)
}

// SetColumnHomogeneous sets whether all columns of @grid will have the same
// width.
func (grid grid) SetColumnHomogeneous(homogeneous bool) {
	var arg0 *C.GtkGrid
	var arg1 C.gboolean

	arg0 = (*C.GtkGrid)(grid.Native())
	arg1 = gextras.Cbool(homogeneous)

	C.gtk_grid_set_column_homogeneous(arg0, arg1)
}

// SetColumnSpacing sets the amount of space between columns of @grid.
func (grid grid) SetColumnSpacing(spacing uint) {
	var arg0 *C.GtkGrid
	var arg1 C.guint

	arg0 = (*C.GtkGrid)(grid.Native())
	arg1 = C.guint(spacing)

	C.gtk_grid_set_column_spacing(arg0, arg1)
}

// SetRowBaselinePosition sets how the baseline should be positioned on @row
// of the grid, in case that row is assigned more space than is requested.
func (grid grid) SetRowBaselinePosition(row int, pos BaselinePosition) {
	var arg0 *C.GtkGrid
	var arg1 C.int
	var arg2 C.GtkBaselinePosition

	arg0 = (*C.GtkGrid)(grid.Native())
	arg1 = C.int(row)
	arg2 = (C.GtkBaselinePosition)(pos)

	C.gtk_grid_set_row_baseline_position(arg0, arg1, arg2)
}

// SetRowHomogeneous sets whether all rows of @grid will have the same
// height.
func (grid grid) SetRowHomogeneous(homogeneous bool) {
	var arg0 *C.GtkGrid
	var arg1 C.gboolean

	arg0 = (*C.GtkGrid)(grid.Native())
	arg1 = gextras.Cbool(homogeneous)

	C.gtk_grid_set_row_homogeneous(arg0, arg1)
}

// SetRowSpacing sets the amount of space between rows of @grid.
func (grid grid) SetRowSpacing(spacing uint) {
	var arg0 *C.GtkGrid
	var arg1 C.guint

	arg0 = (*C.GtkGrid)(grid.Native())
	arg1 = C.guint(spacing)

	C.gtk_grid_set_row_spacing(arg0, arg1)
}

// GridLayout: gtkGridLayout is a layout manager which arranges child widgets in
// rows and columns, with arbitrary positions and horizontal/vertical spans.
//
// Children have an "attach point" defined by the horizontal and vertical index
// of the cell they occupy; children can span multiple rows or columns. The
// layout properties for setting the attach points and spans are set using the
// GridLayoutChild associated to each child widget.
//
// The behaviour of GtkGrid when several children occupy the same grid cell is
// undefined.
//
// GtkGridLayout can be used like a BoxLayout if all children are attached to
// the same row or column; however, if you only ever need a single row or
// column, you should consider using BoxLayout.
type GridLayout interface {
	LayoutManager

	// BaselineRow retrieves the row set with
	// gtk_grid_layout_set_baseline_row().
	BaselineRow() int
	// ColumnHomogeneous checks whether all columns of @grid should have the
	// same width.
	ColumnHomogeneous() bool
	// ColumnSpacing retrieves the spacing set with
	// gtk_grid_layout_set_column_spacing().
	ColumnSpacing() uint
	// RowBaselinePosition returns the baseline position of @row as set by
	// gtk_grid_layout_set_row_baseline_position(), or the default value of
	// GTK_BASELINE_POSITION_CENTER.
	RowBaselinePosition(row int) BaselinePosition
	// RowHomogeneous checks whether all rows of @grid should have the same
	// height.
	RowHomogeneous() bool
	// RowSpacing retrieves the spacing set with
	// gtk_grid_layout_set_row_spacing().
	RowSpacing() uint
	// SetBaselineRow sets which row defines the global baseline for the entire
	// grid.
	//
	// Each row in the grid can have its own local baseline, but only one of
	// those is global, meaning it will be the baseline in the parent of the
	// @grid.
	SetBaselineRow(row int)
	// SetColumnHomogeneous sets whether all columns of @grid should have the
	// same width.
	SetColumnHomogeneous(homogeneous bool)
	// SetColumnSpacing sets the amount of space to insert between consecutive
	// columns.
	SetColumnSpacing(spacing uint)
	// SetRowBaselinePosition sets how the baseline should be positioned on @row
	// of the grid, in case that row is assigned more space than is requested.
	SetRowBaselinePosition(row int, pos BaselinePosition)
	// SetRowHomogeneous sets whether all rows of @grid should have the same
	// height.
	SetRowHomogeneous(homogeneous bool)
	// SetRowSpacing sets the amount of space to insert between consecutive
	// rows.
	SetRowSpacing(spacing uint)
}

type gridLayout struct {
	layoutManager
}

// WrapGridLayout wraps a GObject to the right type. It is
// primarily used internally.
func WrapGridLayout(obj *externglib.Object) GridLayout {
	return gridLayout{layoutManager{*externglib.Object{obj}}}
}

func marshalGridLayout(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapGridLayout(obj), nil
}

// NewGridLayout constructs a class GridLayout.
func NewGridLayout() GridLayout {

	ret := C.gtk_grid_layout_new()

	var ret0 GridLayout

	ret0 = WrapGridLayout(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// BaselineRow retrieves the row set with
// gtk_grid_layout_set_baseline_row().
func (grid gridLayout) BaselineRow() int {
	var arg0 *C.GtkGridLayout

	arg0 = (*C.GtkGridLayout)(grid.Native())

	ret := C.gtk_grid_layout_get_baseline_row(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// ColumnHomogeneous checks whether all columns of @grid should have the
// same width.
func (grid gridLayout) ColumnHomogeneous() bool {
	var arg0 *C.GtkGridLayout

	arg0 = (*C.GtkGridLayout)(grid.Native())

	ret := C.gtk_grid_layout_get_column_homogeneous(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// ColumnSpacing retrieves the spacing set with
// gtk_grid_layout_set_column_spacing().
func (grid gridLayout) ColumnSpacing() uint {
	var arg0 *C.GtkGridLayout

	arg0 = (*C.GtkGridLayout)(grid.Native())

	ret := C.gtk_grid_layout_get_column_spacing(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// RowBaselinePosition returns the baseline position of @row as set by
// gtk_grid_layout_set_row_baseline_position(), or the default value of
// GTK_BASELINE_POSITION_CENTER.
func (grid gridLayout) RowBaselinePosition(row int) BaselinePosition {
	var arg0 *C.GtkGridLayout
	var arg1 C.int

	arg0 = (*C.GtkGridLayout)(grid.Native())
	arg1 = C.int(row)

	ret := C.gtk_grid_layout_get_row_baseline_position(arg0, arg1)

	var ret0 BaselinePosition

	ret0 = BaselinePosition(ret)

	return ret0
}

// RowHomogeneous checks whether all rows of @grid should have the same
// height.
func (grid gridLayout) RowHomogeneous() bool {
	var arg0 *C.GtkGridLayout

	arg0 = (*C.GtkGridLayout)(grid.Native())

	ret := C.gtk_grid_layout_get_row_homogeneous(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// RowSpacing retrieves the spacing set with
// gtk_grid_layout_set_row_spacing().
func (grid gridLayout) RowSpacing() uint {
	var arg0 *C.GtkGridLayout

	arg0 = (*C.GtkGridLayout)(grid.Native())

	ret := C.gtk_grid_layout_get_row_spacing(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// SetBaselineRow sets which row defines the global baseline for the entire
// grid.
//
// Each row in the grid can have its own local baseline, but only one of
// those is global, meaning it will be the baseline in the parent of the
// @grid.
func (grid gridLayout) SetBaselineRow(row int) {
	var arg0 *C.GtkGridLayout
	var arg1 C.int

	arg0 = (*C.GtkGridLayout)(grid.Native())
	arg1 = C.int(row)

	C.gtk_grid_layout_set_baseline_row(arg0, arg1)
}

// SetColumnHomogeneous sets whether all columns of @grid should have the
// same width.
func (grid gridLayout) SetColumnHomogeneous(homogeneous bool) {
	var arg0 *C.GtkGridLayout
	var arg1 C.gboolean

	arg0 = (*C.GtkGridLayout)(grid.Native())
	arg1 = gextras.Cbool(homogeneous)

	C.gtk_grid_layout_set_column_homogeneous(arg0, arg1)
}

// SetColumnSpacing sets the amount of space to insert between consecutive
// columns.
func (grid gridLayout) SetColumnSpacing(spacing uint) {
	var arg0 *C.GtkGridLayout
	var arg1 C.guint

	arg0 = (*C.GtkGridLayout)(grid.Native())
	arg1 = C.guint(spacing)

	C.gtk_grid_layout_set_column_spacing(arg0, arg1)
}

// SetRowBaselinePosition sets how the baseline should be positioned on @row
// of the grid, in case that row is assigned more space than is requested.
func (grid gridLayout) SetRowBaselinePosition(row int, pos BaselinePosition) {
	var arg0 *C.GtkGridLayout
	var arg1 C.int
	var arg2 C.GtkBaselinePosition

	arg0 = (*C.GtkGridLayout)(grid.Native())
	arg1 = C.int(row)
	arg2 = (C.GtkBaselinePosition)(pos)

	C.gtk_grid_layout_set_row_baseline_position(arg0, arg1, arg2)
}

// SetRowHomogeneous sets whether all rows of @grid should have the same
// height.
func (grid gridLayout) SetRowHomogeneous(homogeneous bool) {
	var arg0 *C.GtkGridLayout
	var arg1 C.gboolean

	arg0 = (*C.GtkGridLayout)(grid.Native())
	arg1 = gextras.Cbool(homogeneous)

	C.gtk_grid_layout_set_row_homogeneous(arg0, arg1)
}

// SetRowSpacing sets the amount of space to insert between consecutive
// rows.
func (grid gridLayout) SetRowSpacing(spacing uint) {
	var arg0 *C.GtkGridLayout
	var arg1 C.guint

	arg0 = (*C.GtkGridLayout)(grid.Native())
	arg1 = C.guint(spacing)

	C.gtk_grid_layout_set_row_spacing(arg0, arg1)
}

// GridLayoutChild: layout properties for children of GridLayout.
type GridLayoutChild interface {
	LayoutChild

	// Column retrieves the column number to which @child attaches its left
	// side.
	Column() int
	// ColumnSpan retrieves the number of columns that @child spans to.
	ColumnSpan() int
	// Row retrieves the row number to which @child attaches its top side.
	Row() int
	// RowSpan retrieves the number of rows that @child spans to.
	RowSpan() int
	// SetColumn sets the column number to attach the left side of @child.
	SetColumn(column int)
	// SetColumnSpan sets the number of columns @child spans to.
	SetColumnSpan(span int)
	// SetRow sets the row to place @child in.
	SetRow(row int)
	// SetRowSpan sets the number of rows @child spans to.
	SetRowSpan(span int)
}

type gridLayoutChild struct {
	layoutChild
}

// WrapGridLayoutChild wraps a GObject to the right type. It is
// primarily used internally.
func WrapGridLayoutChild(obj *externglib.Object) GridLayoutChild {
	return gridLayoutChild{layoutChild{*externglib.Object{obj}}}
}

func marshalGridLayoutChild(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapGridLayoutChild(obj), nil
}

// Column retrieves the column number to which @child attaches its left
// side.
func (child gridLayoutChild) Column() int {
	var arg0 *C.GtkGridLayoutChild

	arg0 = (*C.GtkGridLayoutChild)(child.Native())

	ret := C.gtk_grid_layout_child_get_column(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// ColumnSpan retrieves the number of columns that @child spans to.
func (child gridLayoutChild) ColumnSpan() int {
	var arg0 *C.GtkGridLayoutChild

	arg0 = (*C.GtkGridLayoutChild)(child.Native())

	ret := C.gtk_grid_layout_child_get_column_span(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Row retrieves the row number to which @child attaches its top side.
func (child gridLayoutChild) Row() int {
	var arg0 *C.GtkGridLayoutChild

	arg0 = (*C.GtkGridLayoutChild)(child.Native())

	ret := C.gtk_grid_layout_child_get_row(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// RowSpan retrieves the number of rows that @child spans to.
func (child gridLayoutChild) RowSpan() int {
	var arg0 *C.GtkGridLayoutChild

	arg0 = (*C.GtkGridLayoutChild)(child.Native())

	ret := C.gtk_grid_layout_child_get_row_span(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// SetColumn sets the column number to attach the left side of @child.
func (child gridLayoutChild) SetColumn(column int) {
	var arg0 *C.GtkGridLayoutChild
	var arg1 C.int

	arg0 = (*C.GtkGridLayoutChild)(child.Native())
	arg1 = C.int(column)

	C.gtk_grid_layout_child_set_column(arg0, arg1)
}

// SetColumnSpan sets the number of columns @child spans to.
func (child gridLayoutChild) SetColumnSpan(span int) {
	var arg0 *C.GtkGridLayoutChild
	var arg1 C.int

	arg0 = (*C.GtkGridLayoutChild)(child.Native())
	arg1 = C.int(span)

	C.gtk_grid_layout_child_set_column_span(arg0, arg1)
}

// SetRow sets the row to place @child in.
func (child gridLayoutChild) SetRow(row int) {
	var arg0 *C.GtkGridLayoutChild
	var arg1 C.int

	arg0 = (*C.GtkGridLayoutChild)(child.Native())
	arg1 = C.int(row)

	C.gtk_grid_layout_child_set_row(arg0, arg1)
}

// SetRowSpan sets the number of rows @child spans to.
func (child gridLayoutChild) SetRowSpan(span int) {
	var arg0 *C.GtkGridLayoutChild
	var arg1 C.int

	arg0 = (*C.GtkGridLayoutChild)(child.Native())
	arg1 = C.int(span)

	C.gtk_grid_layout_child_set_row_span(arg0, arg1)
}

// GridView: gtkGridView is a widget to present a view into a large dynamic grid
// of items.
//
// GtkGridView uses its factory to generate one child widget for each visible
// item and shows them in a grid. The orientation of the grid view determines if
// the grid reflows vertically or horizontally.
//
// GtkGridView allows the user to select items according to the selection
// characteristics of the model. For models that allow multiple selected items,
// it is possible to turn on _rubberband selection_, using
// GridView:enable-rubberband.
//
// To learn more about the list widget framework, see the overview (Widget).
//
// CSS nodes
//
//    gridview
//    ├── child
//    │
//    ├── child
//    │
//    ┊
//    ╰── [rubberband]
//
//
// GtkGridView uses a single CSS node with name gridview. Each child uses a
// single CSS node with name child. For rubberband selection, a subnode with
// name rubberband is used.
//
//
// Accessibility
//
// GtkGridView uses the K_ACCESSIBLE_ROLE_GRID role, and the items use the
// K_ACCESSIBLE_ROLE_GRID_CELL role.
type GridView interface {
	ListBase

	// EnableRubberband returns whether rows can be selected by dragging with
	// the mouse.
	EnableRubberband() bool
	// Factory gets the factory that's currently used to populate list items.
	Factory() ListItemFactory
	// MaxColumns gets the maximum number of columns that the grid will use.
	MaxColumns() uint
	// MinColumns gets the minimum number of columns that the grid will use.
	MinColumns() uint
	// Model gets the model that's currently used to read the items displayed.
	Model() SelectionModel
	// SingleClickActivate returns whether items will be activated on single
	// click and selected on hover.
	SingleClickActivate() bool
	// SetEnableRubberband sets whether selections can be changed by dragging
	// with the mouse.
	SetEnableRubberband(enableRubberband bool)
	// SetFactory sets the ListItemFactory to use for populating list items.
	SetFactory(factory ListItemFactory)
	// SetMaxColumns sets the maximum number of columns to use. This number must
	// be at least 1.
	//
	// If @max_columns is smaller than the minimum set via
	// gtk_grid_view_set_min_columns(), that value is used instead.
	SetMaxColumns(maxColumns uint)
	// SetMinColumns sets the minimum number of columns to use. This number must
	// be at least 1.
	//
	// If @min_columns is smaller than the minimum set via
	// gtk_grid_view_set_max_columns(), that value is ignored.
	SetMinColumns(minColumns uint)
	// SetModel sets the SelectionModel to use for
	SetModel(model SelectionModel)
	// SetSingleClickActivate sets whether items should be activated on single
	// click and selected on hover.
	SetSingleClickActivate(singleClickActivate bool)
}

type gridView struct {
	listBase
}

// WrapGridView wraps a GObject to the right type. It is
// primarily used internally.
func WrapGridView(obj *externglib.Object) GridView {
	return gridView{listBase{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}}
}

func marshalGridView(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapGridView(obj), nil
}

// NewGridView constructs a class GridView.
func NewGridView(model SelectionModel, factory ListItemFactory) GridView {
	var arg1 *C.GtkSelectionModel
	var arg2 *C.GtkListItemFactory

	arg2 = (*C.GtkListItemFactory)(factory.Native())

	ret := C.gtk_grid_view_new(arg1, arg2)

	var ret0 GridView

	ret0 = WrapGridView(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// EnableRubberband returns whether rows can be selected by dragging with
// the mouse.
func (self gridView) EnableRubberband() bool {
	var arg0 *C.GtkGridView

	arg0 = (*C.GtkGridView)(self.Native())

	ret := C.gtk_grid_view_get_enable_rubberband(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Factory gets the factory that's currently used to populate list items.
func (self gridView) Factory() ListItemFactory {
	var arg0 *C.GtkGridView

	arg0 = (*C.GtkGridView)(self.Native())

	ret := C.gtk_grid_view_get_factory(arg0)

	var ret0 ListItemFactory

	ret0 = WrapListItemFactory(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// MaxColumns gets the maximum number of columns that the grid will use.
func (self gridView) MaxColumns() uint {
	var arg0 *C.GtkGridView

	arg0 = (*C.GtkGridView)(self.Native())

	ret := C.gtk_grid_view_get_max_columns(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// MinColumns gets the minimum number of columns that the grid will use.
func (self gridView) MinColumns() uint {
	var arg0 *C.GtkGridView

	arg0 = (*C.GtkGridView)(self.Native())

	ret := C.gtk_grid_view_get_min_columns(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// Model gets the model that's currently used to read the items displayed.
func (self gridView) Model() SelectionModel {
	var arg0 *C.GtkGridView

	arg0 = (*C.GtkGridView)(self.Native())

	ret := C.gtk_grid_view_get_model(arg0)

	var ret0 SelectionModel

	return ret0
}

// SingleClickActivate returns whether items will be activated on single
// click and selected on hover.
func (self gridView) SingleClickActivate() bool {
	var arg0 *C.GtkGridView

	arg0 = (*C.GtkGridView)(self.Native())

	ret := C.gtk_grid_view_get_single_click_activate(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// SetEnableRubberband sets whether selections can be changed by dragging
// with the mouse.
func (self gridView) SetEnableRubberband(enableRubberband bool) {
	var arg0 *C.GtkGridView
	var arg1 C.gboolean

	arg0 = (*C.GtkGridView)(self.Native())
	arg1 = gextras.Cbool(enableRubberband)

	C.gtk_grid_view_set_enable_rubberband(arg0, arg1)
}

// SetFactory sets the ListItemFactory to use for populating list items.
func (self gridView) SetFactory(factory ListItemFactory) {
	var arg0 *C.GtkGridView
	var arg1 *C.GtkListItemFactory

	arg0 = (*C.GtkGridView)(self.Native())
	arg1 = (*C.GtkListItemFactory)(factory.Native())

	C.gtk_grid_view_set_factory(arg0, arg1)
}

// SetMaxColumns sets the maximum number of columns to use. This number must
// be at least 1.
//
// If @max_columns is smaller than the minimum set via
// gtk_grid_view_set_min_columns(), that value is used instead.
func (self gridView) SetMaxColumns(maxColumns uint) {
	var arg0 *C.GtkGridView
	var arg1 C.guint

	arg0 = (*C.GtkGridView)(self.Native())
	arg1 = C.guint(maxColumns)

	C.gtk_grid_view_set_max_columns(arg0, arg1)
}

// SetMinColumns sets the minimum number of columns to use. This number must
// be at least 1.
//
// If @min_columns is smaller than the minimum set via
// gtk_grid_view_set_max_columns(), that value is ignored.
func (self gridView) SetMinColumns(minColumns uint) {
	var arg0 *C.GtkGridView
	var arg1 C.guint

	arg0 = (*C.GtkGridView)(self.Native())
	arg1 = C.guint(minColumns)

	C.gtk_grid_view_set_min_columns(arg0, arg1)
}

// SetModel sets the SelectionModel to use for
func (self gridView) SetModel(model SelectionModel) {
	var arg0 *C.GtkGridView
	var arg1 *C.GtkSelectionModel

	arg0 = (*C.GtkGridView)(self.Native())

	C.gtk_grid_view_set_model(arg0, arg1)
}

// SetSingleClickActivate sets whether items should be activated on single
// click and selected on hover.
func (self gridView) SetSingleClickActivate(singleClickActivate bool) {
	var arg0 *C.GtkGridView
	var arg1 C.gboolean

	arg0 = (*C.GtkGridView)(self.Native())
	arg1 = gextras.Cbool(singleClickActivate)

	C.gtk_grid_view_set_single_click_activate(arg0, arg1)
}

// HeaderBar: gtkHeaderBar is similar to a horizontal Box. It allows children to
// be placed at the start or the end. In addition, it allows the window title to
// be displayed. The title will be centered with respect to the width of the
// box, even if the children at either side take up different amounts of space.
//
// GtkHeaderBar can add typical window frame controls, such as minimize,
// maximize and close buttons, or the window icon.
//
// For these reasons, GtkHeaderBar is the natural choice for use as the custom
// titlebar widget of a Window (see gtk_window_set_titlebar()), as it gives
// features typical of titlebars while allowing the addition of child widgets.
//
// The GtkHeaderBar implementation of the Buildable interface supports adding
// children at the start or end sides by specifying “start” or “end” as the
// “type” attribute of a <child> element, or setting the title widget by
// specifying “title” value.
//
// By default the GtkHeaderBar uses a Label displaying the title of the window
// it is contained in as the title widget, equivalent to the following UI
// definition:
//
//
//    <object class="GtkHeaderBar">
//      <property name="title-widget">
//        <object class="GtkLabel">
//          <property name="label" translatable="yes">Label</property>
//          <property name="single-line-mode">True</property>
//          <property name="ellipsize">end</property>
//          <property name="width-chars">5</property>
//          <style>
//            <class name="title"/>
//          </style>
//        </object>
//      </property>
//    </object>
//    ]|
//
//
//
// CSS nodes
//
//
//    |[<!-- language="plain" -->
//    headerbar
//    ╰── windowhandle
//        ╰── box
//            ├── box.start
//            │   ├── windowcontrols.start
//            │   ╰── [other children]
//            ├── [Title Widget]
//            ╰── box.end
//                ├── [other children]
//                ╰── windowcontrols.end
//
//
// A HeaderBar's CSS node is called `headerbar`. It contains a `windowhandle`
// subnode, which contains a `box` subnode, which contains two `box` subnodes at
// the start and end of the header bar, as well as a center node that represents
// the title.
//
// Each of the boxes contains a `windowcontrols` subnode, see WindowControls for
// details, as well as other children.
//
//
// Accessibility
//
// GtkHeaderBar uses the GTK_ACCESSIBLE_ROLE_GROUP role.
type HeaderBar interface {
	Widget

	// DecorationLayout gets the decoration layout set with
	// gtk_header_bar_set_decoration_layout().
	DecorationLayout() string
	// ShowTitleButtons returns whether this header bar shows the standard
	// window title buttons.
	ShowTitleButtons() bool
	// TitleWidget retrieves the title widget of the header. See
	// gtk_header_bar_set_title_widget().
	TitleWidget() Widget
	// PackEnd adds @child to @bar, packed with reference to the end of the
	// @bar.
	PackEnd(child Widget)
	// PackStart adds @child to @bar, packed with reference to the start of the
	// @bar.
	PackStart(child Widget)
	// Remove removes a child from @bar, after it has been added with
	// gtk_header_bar_pack_start(), gtk_header_bar_pack_end() or
	// gtk_header_bar_set_title_widget().
	Remove(child Widget)
	// SetDecorationLayout sets the decoration layout for this header bar,
	// overriding the Settings:gtk-decoration-layout setting.
	//
	// There can be valid reasons for overriding the setting, such as a header
	// bar design that does not allow for buttons to take room on the right, or
	// only offers room for a single close button. Split header bars are another
	// example for overriding the setting.
	//
	// The format of the string is button names, separated by commas. A colon
	// separates the buttons that should appear on the left from those on the
	// right. Recognized button names are minimize, maximize, close and icon
	// (the window icon).
	//
	// For example, “icon:minimize,maximize,close” specifies a icon on the left,
	// and minimize, maximize and close buttons on the right.
	SetDecorationLayout(layout string)
	// SetShowTitleButtons sets whether this header bar shows the standard
	// window title buttons including close, maximize, and minimize.
	SetShowTitleButtons(setting bool)
	// SetTitleWidget sets the title for the HeaderBar.
	//
	// When set to nil, the headerbar will display the title of the window it is
	// contained in.
	//
	// The title should help a user identify the current view. To achieve the
	// same style as the builtin title, use the “title” style class.
	//
	// You should set the title widget to nil, for the window title label to be
	// visible again.
	SetTitleWidget(titleWidget Widget)
}

type headerBar struct {
	widget
}

// WrapHeaderBar wraps a GObject to the right type. It is
// primarily used internally.
func WrapHeaderBar(obj *externglib.Object) HeaderBar {
	return headerBar{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}
}

func marshalHeaderBar(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapHeaderBar(obj), nil
}

// NewHeaderBar constructs a class HeaderBar.
func NewHeaderBar() HeaderBar {

	ret := C.gtk_header_bar_new()

	var ret0 HeaderBar

	ret0 = WrapHeaderBar(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// DecorationLayout gets the decoration layout set with
// gtk_header_bar_set_decoration_layout().
func (bar headerBar) DecorationLayout() string {
	var arg0 *C.GtkHeaderBar

	arg0 = (*C.GtkHeaderBar)(bar.Native())

	ret := C.gtk_header_bar_get_decoration_layout(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// ShowTitleButtons returns whether this header bar shows the standard
// window title buttons.
func (bar headerBar) ShowTitleButtons() bool {
	var arg0 *C.GtkHeaderBar

	arg0 = (*C.GtkHeaderBar)(bar.Native())

	ret := C.gtk_header_bar_get_show_title_buttons(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// TitleWidget retrieves the title widget of the header. See
// gtk_header_bar_set_title_widget().
func (bar headerBar) TitleWidget() Widget {
	var arg0 *C.GtkHeaderBar

	arg0 = (*C.GtkHeaderBar)(bar.Native())

	ret := C.gtk_header_bar_get_title_widget(arg0)

	var ret0 Widget

	ret0 = WrapWidget(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// PackEnd adds @child to @bar, packed with reference to the end of the
// @bar.
func (bar headerBar) PackEnd(child Widget) {
	var arg0 *C.GtkHeaderBar
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkHeaderBar)(bar.Native())
	arg1 = (*C.GtkWidget)(child.Native())

	C.gtk_header_bar_pack_end(arg0, arg1)
}

// PackStart adds @child to @bar, packed with reference to the start of the
// @bar.
func (bar headerBar) PackStart(child Widget) {
	var arg0 *C.GtkHeaderBar
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkHeaderBar)(bar.Native())
	arg1 = (*C.GtkWidget)(child.Native())

	C.gtk_header_bar_pack_start(arg0, arg1)
}

// Remove removes a child from @bar, after it has been added with
// gtk_header_bar_pack_start(), gtk_header_bar_pack_end() or
// gtk_header_bar_set_title_widget().
func (bar headerBar) Remove(child Widget) {
	var arg0 *C.GtkHeaderBar
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkHeaderBar)(bar.Native())
	arg1 = (*C.GtkWidget)(child.Native())

	C.gtk_header_bar_remove(arg0, arg1)
}

// SetDecorationLayout sets the decoration layout for this header bar,
// overriding the Settings:gtk-decoration-layout setting.
//
// There can be valid reasons for overriding the setting, such as a header
// bar design that does not allow for buttons to take room on the right, or
// only offers room for a single close button. Split header bars are another
// example for overriding the setting.
//
// The format of the string is button names, separated by commas. A colon
// separates the buttons that should appear on the left from those on the
// right. Recognized button names are minimize, maximize, close and icon
// (the window icon).
//
// For example, “icon:minimize,maximize,close” specifies a icon on the left,
// and minimize, maximize and close buttons on the right.
func (bar headerBar) SetDecorationLayout(layout string) {
	var arg0 *C.GtkHeaderBar
	var arg1 *C.char

	arg0 = (*C.GtkHeaderBar)(bar.Native())
	arg1 = (*C.gchar)(C.CString(layout))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_header_bar_set_decoration_layout(arg0, arg1)
}

// SetShowTitleButtons sets whether this header bar shows the standard
// window title buttons including close, maximize, and minimize.
func (bar headerBar) SetShowTitleButtons(setting bool) {
	var arg0 *C.GtkHeaderBar
	var arg1 C.gboolean

	arg0 = (*C.GtkHeaderBar)(bar.Native())
	arg1 = gextras.Cbool(setting)

	C.gtk_header_bar_set_show_title_buttons(arg0, arg1)
}

// SetTitleWidget sets the title for the HeaderBar.
//
// When set to nil, the headerbar will display the title of the window it is
// contained in.
//
// The title should help a user identify the current view. To achieve the
// same style as the builtin title, use the “title” style class.
//
// You should set the title widget to nil, for the window title label to be
// visible again.
func (bar headerBar) SetTitleWidget(titleWidget Widget) {
	var arg0 *C.GtkHeaderBar
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkHeaderBar)(bar.Native())
	arg1 = (*C.GtkWidget)(titleWidget.Native())

	C.gtk_header_bar_set_title_widget(arg0, arg1)
}

// IMContext defines the interface for GTK input methods. An input method is
// used by GTK text input widgets like Entry to map from key events to Unicode
// character strings.
//
// The default input method can be set programmatically via the
// Settings:gtk-im-module GtkSettings property. Alternatively, you may set the
// GTK_IM_MODULE environment variable as documented in [Running GTK
// Applications][gtk-running].
//
// The Entry Entry:im-module and TextView TextView:im-module properties may also
// be used to set input methods for specific widget instances. For instance, a
// certain entry widget might be expected to contain certain characters which
// would be easier to input with a certain input method.
//
// An input method may consume multiple key events in sequence and finally
// output the composed result. This is called preediting, and an input method
// may provide feedback about this process by displaying the intermediate
// composition states as preedit text. For instance, the default GTK input
// method implements the input of arbitrary Unicode code points by holding down
// the Control and Shift keys and then typing “U” followed by the hexadecimal
// digits of the code point. When releasing the Control and Shift keys,
// preediting ends and the character is inserted as text. Ctrl+Shift+u20AC for
// example results in the € sign.
//
// Additional input methods can be made available for use by GTK widgets as
// loadable modules. An input method module is a small shared library which
// implements a subclass of IMContext or IMContextSimple and exports these four
// functions:
//
//    GtkIMContext * im_module_create(const char *context_id);
//
//
// This function should return a pointer to a newly created instance of the
// IMContext subclass identified by @context_id. The context ID is the same as
// specified in the IMContextInfo array returned by im_module_list().
//
// After a new loadable input method module has been installed on the system,
// the configuration file `gtk.immodules` needs to be regenerated by
// [gtk-query-immodules-3.0][gtk-query-immodules-3.0], in order for the new
// input method to become available to GTK applications.
type IMContext interface {
	gextras.Objector

	// DeleteSurrounding asks the widget that the input context is attached to
	// delete characters around the cursor position by emitting the
	// GtkIMContext::delete_surrounding signal. Note that @offset and @n_chars
	// are in characters not in bytes which differs from the usage other places
	// in IMContext.
	//
	// In order to use this function, you should first call
	// gtk_im_context_get_surrounding() to get the current context, and call
	// this function immediately afterwards to make sure that you know what you
	// are deleting. You should also account for the fact that even if the
	// signal was handled, the input context might not have deleted all the
	// characters that were requested to be deleted.
	//
	// This function is used by an input method that wants to make subsitutions
	// in the existing text in response to new input. It is not useful for
	// applications.
	DeleteSurrounding(offset int, nChars int) bool
	// FilterKey: allow an input method to forward key press and release events
	// to another input method, without necessarily having a GdkEvent available.
	FilterKey(press bool, surface gdk.Surface, device gdk.Device, time uint32, keycode uint, state gdk.ModifierType, group int) bool
	// FilterKeypress: allow an input method to internally handle key press and
	// release events. If this function returns true, then no further processing
	// should be done for this key event.
	FilterKeypress(event gdk.Event) bool
	// FocusIn: notify the input method that the widget to which this input
	// context corresponds has gained focus. The input method may, for example,
	// change the displayed feedback to reflect this change.
	FocusIn()
	// FocusOut: notify the input method that the widget to which this input
	// context corresponds has lost focus. The input method may, for example,
	// change the displayed feedback or reset the contexts state to reflect this
	// change.
	FocusOut()
	// PreeditString: retrieve the current preedit string for the input context,
	// and a list of attributes to apply to the string. This string should be
	// displayed inserted at the insertion point.
	PreeditString() (str string, attrs *pango.AttrList, cursorPos int)
	// Surrounding retrieves context around the insertion point. Input methods
	// typically want context in order to constrain input text based on existing
	// text; this is important for languages such as Thai where only some
	// sequences of characters are allowed.
	//
	// This function is implemented by emitting the
	// GtkIMContext::retrieve_surrounding signal on the input method; in
	// response to this signal, a widget should provide as much context as is
	// available, up to an entire paragraph, by calling
	// gtk_im_context_set_surrounding(). Note that there is no obligation for a
	// widget to respond to the ::retrieve_surrounding signal, so input methods
	// must be prepared to function without context.
	Surrounding() (text string, cursorIndex int, ok bool)
	// Reset: notify the input method that a change such as a change in cursor
	// position has been made. This will typically cause the input method to
	// clear the preedit state.
	Reset()
	// SetClientWidget: set the client window for the input context; this is the
	// Widget holding the input focus. This widget is used in order to correctly
	// position status windows, and may also be used for purposes internal to
	// the input method.
	SetClientWidget(widget Widget)
	// SetCursorLocation: notify the input method that a change in cursor
	// position has been made. The location is relative to the client window.
	SetCursorLocation(area *gdk.Rectangle)
	// SetSurrounding sets surrounding context around the insertion point and
	// preedit string. This function is expected to be called in response to the
	// GtkIMContext::retrieve_surrounding signal, and will likely have no effect
	// if called at other times.
	SetSurrounding(text string, len int, cursorIndex int)
	// SetUsePreedit sets whether the IM context should use the preedit string
	// to display feedback. If @use_preedit is FALSE (default is TRUE), then the
	// IM context may use some other method to display feedback, such as
	// displaying it in a child of the root window.
	SetUsePreedit(usePreedit bool)
}

type imContext struct {
	*externglib.Object
}

// WrapIMContext wraps a GObject to the right type. It is
// primarily used internally.
func WrapIMContext(obj *externglib.Object) IMContext {
	return imContext{*externglib.Object{obj}}
}

func marshalIMContext(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapIMContext(obj), nil
}

// DeleteSurrounding asks the widget that the input context is attached to
// delete characters around the cursor position by emitting the
// GtkIMContext::delete_surrounding signal. Note that @offset and @n_chars
// are in characters not in bytes which differs from the usage other places
// in IMContext.
//
// In order to use this function, you should first call
// gtk_im_context_get_surrounding() to get the current context, and call
// this function immediately afterwards to make sure that you know what you
// are deleting. You should also account for the fact that even if the
// signal was handled, the input context might not have deleted all the
// characters that were requested to be deleted.
//
// This function is used by an input method that wants to make subsitutions
// in the existing text in response to new input. It is not useful for
// applications.
func (context imContext) DeleteSurrounding(offset int, nChars int) bool {
	var arg0 *C.GtkIMContext
	var arg1 C.int
	var arg2 C.int

	arg0 = (*C.GtkIMContext)(context.Native())
	arg1 = C.int(offset)
	arg2 = C.int(nChars)

	ret := C.gtk_im_context_delete_surrounding(arg0, arg1, arg2)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// FilterKey: allow an input method to forward key press and release events
// to another input method, without necessarily having a GdkEvent available.
func (context imContext) FilterKey(press bool, surface gdk.Surface, device gdk.Device, time uint32, keycode uint, state gdk.ModifierType, group int) bool {
	var arg0 *C.GtkIMContext
	var arg1 C.gboolean
	var arg2 *C.GdkSurface
	var arg3 *C.GdkDevice
	var arg4 C.guint32
	var arg5 C.guint
	var arg6 C.GdkModifierType
	var arg7 C.int

	arg0 = (*C.GtkIMContext)(context.Native())
	arg1 = gextras.Cbool(press)
	arg2 = (*C.GdkSurface)(surface.Native())
	arg3 = (*C.GdkDevice)(device.Native())
	arg4 = C.guint32(time)
	arg5 = C.guint(keycode)
	arg6 = (C.GdkModifierType)(state)
	arg7 = C.int(group)

	ret := C.gtk_im_context_filter_key(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// FilterKeypress: allow an input method to internally handle key press and
// release events. If this function returns true, then no further processing
// should be done for this key event.
func (context imContext) FilterKeypress(event gdk.Event) bool {
	var arg0 *C.GtkIMContext
	var arg1 *C.GdkEvent

	arg0 = (*C.GtkIMContext)(context.Native())
	arg1 = (*C.GdkEvent)(event.Native())

	ret := C.gtk_im_context_filter_keypress(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// FocusIn: notify the input method that the widget to which this input
// context corresponds has gained focus. The input method may, for example,
// change the displayed feedback to reflect this change.
func (context imContext) FocusIn() {
	var arg0 *C.GtkIMContext

	arg0 = (*C.GtkIMContext)(context.Native())

	C.gtk_im_context_focus_in(arg0)
}

// FocusOut: notify the input method that the widget to which this input
// context corresponds has lost focus. The input method may, for example,
// change the displayed feedback or reset the contexts state to reflect this
// change.
func (context imContext) FocusOut() {
	var arg0 *C.GtkIMContext

	arg0 = (*C.GtkIMContext)(context.Native())

	C.gtk_im_context_focus_out(arg0)
}

// PreeditString: retrieve the current preedit string for the input context,
// and a list of attributes to apply to the string. This string should be
// displayed inserted at the insertion point.
func (context imContext) PreeditString() (str string, attrs *pango.AttrList, cursorPos int) {
	var arg0 *C.GtkIMContext
	var arg1 **C.char          // out
	var arg2 **C.PangoAttrList // out
	var arg3 *C.int            // out

	arg0 = (*C.GtkIMContext)(context.Native())

	ret := C.gtk_im_context_get_preedit_string(arg0, &arg1, &arg2, &arg3)

	var ret0 string
	var ret1 **pango.AttrList
	var ret2 int

	ret0 = C.GoString(arg1)
	C.free(unsafe.Pointer(arg1))

	ret1 = pango.WrapAttrList(arg2)

	ret2 = int(arg3)

	return ret0, ret1, ret2
}

// Surrounding retrieves context around the insertion point. Input methods
// typically want context in order to constrain input text based on existing
// text; this is important for languages such as Thai where only some
// sequences of characters are allowed.
//
// This function is implemented by emitting the
// GtkIMContext::retrieve_surrounding signal on the input method; in
// response to this signal, a widget should provide as much context as is
// available, up to an entire paragraph, by calling
// gtk_im_context_set_surrounding(). Note that there is no obligation for a
// widget to respond to the ::retrieve_surrounding signal, so input methods
// must be prepared to function without context.
func (context imContext) Surrounding() (text string, cursorIndex int, ok bool) {
	var arg0 *C.GtkIMContext
	var arg1 **C.char // out
	var arg2 *C.int   // out

	arg0 = (*C.GtkIMContext)(context.Native())

	ret := C.gtk_im_context_get_surrounding(arg0, &arg1, &arg2)

	var ret0 string
	var ret1 int
	var ret2 bool

	ret0 = C.GoString(arg1)
	C.free(unsafe.Pointer(arg1))

	ret1 = int(arg2)

	ret2 = gextras.Gobool(ret)

	return ret0, ret1, ret2
}

// Reset: notify the input method that a change such as a change in cursor
// position has been made. This will typically cause the input method to
// clear the preedit state.
func (context imContext) Reset() {
	var arg0 *C.GtkIMContext

	arg0 = (*C.GtkIMContext)(context.Native())

	C.gtk_im_context_reset(arg0)
}

// SetClientWidget: set the client window for the input context; this is the
// Widget holding the input focus. This widget is used in order to correctly
// position status windows, and may also be used for purposes internal to
// the input method.
func (context imContext) SetClientWidget(widget Widget) {
	var arg0 *C.GtkIMContext
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkIMContext)(context.Native())
	arg1 = (*C.GtkWidget)(widget.Native())

	C.gtk_im_context_set_client_widget(arg0, arg1)
}

// SetCursorLocation: notify the input method that a change in cursor
// position has been made. The location is relative to the client window.
func (context imContext) SetCursorLocation(area *gdk.Rectangle) {
	var arg0 *C.GtkIMContext
	var arg1 *C.GdkRectangle

	arg0 = (*C.GtkIMContext)(context.Native())
	arg1 = (*C.GdkRectangle)(area.Native())

	C.gtk_im_context_set_cursor_location(arg0, arg1)
}

// SetSurrounding sets surrounding context around the insertion point and
// preedit string. This function is expected to be called in response to the
// GtkIMContext::retrieve_surrounding signal, and will likely have no effect
// if called at other times.
func (context imContext) SetSurrounding(text string, len int, cursorIndex int) {
	var arg0 *C.GtkIMContext
	var arg1 *C.char
	var arg2 C.int
	var arg3 C.int

	arg0 = (*C.GtkIMContext)(context.Native())
	arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.int(len)
	arg3 = C.int(cursorIndex)

	C.gtk_im_context_set_surrounding(arg0, arg1, arg2, arg3)
}

// SetUsePreedit sets whether the IM context should use the preedit string
// to display feedback. If @use_preedit is FALSE (default is TRUE), then the
// IM context may use some other method to display feedback, such as
// displaying it in a child of the root window.
func (context imContext) SetUsePreedit(usePreedit bool) {
	var arg0 *C.GtkIMContext
	var arg1 C.gboolean

	arg0 = (*C.GtkIMContext)(context.Native())
	arg1 = gextras.Cbool(usePreedit)

	C.gtk_im_context_set_use_preedit(arg0, arg1)
}

// IMContextSimple: gtkIMContextSimple is a simple input method context
// supporting table-based input methods. It has a built-in table of compose
// sequences that is derived from the X11 Compose files.
//
// GtkIMContextSimple reads additional compose sequences from the first of the
// following files that is found: ~/.config/gtk-4.0/Compose, ~/.XCompose,
// /usr/share/X11/locale/$locale/Compose (for locales that have a nontrivial
// Compose file). The syntax of these files is described in the Compose(5)
// manual page.
//
//
// Unicode characters
//
// GtkIMContextSimple also supports numeric entry of Unicode characters by
// typing Ctrl-Shift-u, followed by a hexadecimal Unicode codepoint. For
// example, Ctrl-Shift-u 1 2 3 Enter yields U+0123 LATIN SMALL LETTER G WITH
// CEDILLA, i.e. ģ.
type IMContextSimple interface {
	IMContext

	// AddComposeFile adds an additional table from the X11 compose file.
	AddComposeFile(composeFile string)
	// AddTable adds an additional table to search to the input context. Each
	// row of the table consists of @max_seq_len key symbols followed by two
	// #guint16 interpreted as the high and low words of a #gunicode value.
	// Tables are searched starting from the last added.
	//
	// The table must be sorted in dictionary order on the numeric value of the
	// key symbol fields. (Values beyond the length of the sequence should be
	// zero.)
	AddTable(data []uint16, maxSeqLen int, nSeqs int)
}

type imContextSimple struct {
	imContext
}

// WrapIMContextSimple wraps a GObject to the right type. It is
// primarily used internally.
func WrapIMContextSimple(obj *externglib.Object) IMContextSimple {
	return imContextSimple{imContext{*externglib.Object{obj}}}
}

func marshalIMContextSimple(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapIMContextSimple(obj), nil
}

// NewIMContextSimple constructs a class IMContextSimple.
func NewIMContextSimple() IMContextSimple {

	ret := C.gtk_im_context_simple_new()

	var ret0 IMContextSimple

	ret0 = WrapIMContextSimple(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// AddComposeFile adds an additional table from the X11 compose file.
func (contextSimple imContextSimple) AddComposeFile(composeFile string) {
	var arg0 *C.GtkIMContextSimple
	var arg1 *C.char

	arg0 = (*C.GtkIMContextSimple)(contextSimple.Native())
	arg1 = (*C.gchar)(C.CString(composeFile))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_im_context_simple_add_compose_file(arg0, arg1)
}

// AddTable adds an additional table to search to the input context. Each
// row of the table consists of @max_seq_len key symbols followed by two
// #guint16 interpreted as the high and low words of a #gunicode value.
// Tables are searched starting from the last added.
//
// The table must be sorted in dictionary order on the numeric value of the
// key symbol fields. (Values beyond the length of the sequence should be
// zero.)
func (contextSimple imContextSimple) AddTable(data []uint16, maxSeqLen int, nSeqs int) {
	var arg0 *C.GtkIMContextSimple
	var arg1 *C.guint16
	var arg2 C.int
	var arg3 C.int

	arg0 = (*C.GtkIMContextSimple)(contextSimple.Native())
	{

	}
	arg2 = C.int(maxSeqLen)
	arg3 = C.int(nSeqs)

	C.gtk_im_context_simple_add_table(arg0, arg1, arg2, arg3)
}

type IMMulticontext interface {
	IMContext

	// ContextID gets the id of the currently active delegate of the @context.
	ContextID() string
	// SetContextID sets the context id for @context.
	//
	// This causes the currently active delegate of @context to be replaced by
	// the delegate corresponding to the new context id.
	SetContextID(contextID string)
}

type imMulticontext struct {
	imContext
}

// WrapIMMulticontext wraps a GObject to the right type. It is
// primarily used internally.
func WrapIMMulticontext(obj *externglib.Object) IMMulticontext {
	return imMulticontext{imContext{*externglib.Object{obj}}}
}

func marshalIMMulticontext(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapIMMulticontext(obj), nil
}

// NewIMMulticontext constructs a class IMMulticontext.
func NewIMMulticontext() IMMulticontext {

	ret := C.gtk_im_multicontext_new()

	var ret0 IMMulticontext

	ret0 = WrapIMMulticontext(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// ContextID gets the id of the currently active delegate of the @context.
func (context imMulticontext) ContextID() string {
	var arg0 *C.GtkIMMulticontext

	arg0 = (*C.GtkIMMulticontext)(context.Native())

	ret := C.gtk_im_multicontext_get_context_id(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// SetContextID sets the context id for @context.
//
// This causes the currently active delegate of @context to be replaced by
// the delegate corresponding to the new context id.
func (context imMulticontext) SetContextID(contextID string) {
	var arg0 *C.GtkIMMulticontext
	var arg1 *C.char

	arg0 = (*C.GtkIMMulticontext)(context.Native())
	arg1 = (*C.gchar)(C.CString(contextID))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_im_multicontext_set_context_id(arg0, arg1)
}

// IconPaintable contains information found when looking up an icon in an icon
// theme and supports painting it as a Paintable.
type IconPaintable interface {
	gextras.Objector

	// File gets the #GFile that was used to load the icon, or nil if the icon
	// was not loaded from a file.
	File() gio.File
	// IconName: get the icon name being used for this icon.
	//
	// When an icon looked up in the icon theme was not available, the icon
	// theme may use fallback icons - either those specified to
	// gtk_icon_theme_lookup_icon() or the always-available "image-missing". The
	// icon chosen is returned by this function.
	//
	// If the icon was created without an icon theme, this function returns nil.
	IconName() string
	// IsSymbolic checks if the icon is symbolic or not. This currently uses
	// only the file name and not the file contents for determining this. This
	// behaviour may change in the future.
	//
	// Note that to render a symbolic IconPaintable properly (with recoloring),
	// you have to set its icon name on a Image.
	IsSymbolic() bool
}

type iconPaintable struct {
	*externglib.Object
}

// WrapIconPaintable wraps a GObject to the right type. It is
// primarily used internally.
func WrapIconPaintable(obj *externglib.Object) IconPaintable {
	return iconPaintable{*externglib.Object{obj}}
}

func marshalIconPaintable(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapIconPaintable(obj), nil
}

// NewIconPaintableForFile constructs a class IconPaintable.
func NewIconPaintableForFile(file gio.File, size int, scale int) IconPaintable {
	var arg1 *C.GFile
	var arg2 C.int
	var arg3 C.int

	arg2 = C.int(size)
	arg3 = C.int(scale)

	ret := C.gtk_icon_paintable_new_for_file(arg1, arg2, arg3)

	var ret0 IconPaintable

	ret0 = WrapIconPaintable(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// File gets the #GFile that was used to load the icon, or nil if the icon
// was not loaded from a file.
func (self iconPaintable) File() gio.File {
	var arg0 *C.GtkIconPaintable

	arg0 = (*C.GtkIconPaintable)(self.Native())

	ret := C.gtk_icon_paintable_get_file(arg0)

	var ret0 gio.File

	return ret0
}

// IconName: get the icon name being used for this icon.
//
// When an icon looked up in the icon theme was not available, the icon
// theme may use fallback icons - either those specified to
// gtk_icon_theme_lookup_icon() or the always-available "image-missing". The
// icon chosen is returned by this function.
//
// If the icon was created without an icon theme, this function returns nil.
func (self iconPaintable) IconName() string {
	var arg0 *C.GtkIconPaintable

	arg0 = (*C.GtkIconPaintable)(self.Native())

	ret := C.gtk_icon_paintable_get_icon_name(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// IsSymbolic checks if the icon is symbolic or not. This currently uses
// only the file name and not the file contents for determining this. This
// behaviour may change in the future.
//
// Note that to render a symbolic IconPaintable properly (with recoloring),
// you have to set its icon name on a Image.
func (self iconPaintable) IsSymbolic() bool {
	var arg0 *C.GtkIconPaintable

	arg0 = (*C.GtkIconPaintable)(self.Native())

	ret := C.gtk_icon_paintable_is_symbolic(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// IconTheme provides a facility for looking up icons by name and size. The main
// reason for using a name rather than simply providing a filename is to allow
// different icons to be used depending on what “icon theme” is selected by the
// user. The operation of icon themes on Linux and Unix follows the Icon Theme
// Specification (http://www.freedesktop.org/Standards/icon-theme-spec) There is
// a fallback icon theme, named `hicolor`, where applications should install
// their icons, but additional icon themes can be installed as operating system
// vendors and users choose.
//
// In many cases, named themes are used indirectly, via Image rather than
// directly, but looking up icons directly is also simple. The IconTheme object
// acts as a database of all the icons in the current theme. You can create new
// IconTheme objects, but it’s much more efficient to use the standard icon
// theme of the Widget so that the icon information is shared with other people
// looking up icons.
//
//    GtkIconTheme *icon_theme;
//    GtkIconPaintable *icon;
//    GdkPaintable *paintable;
//
//    icon_theme = gtk_icon_theme_get_for_display (gtk_widget_get_display (my_widget));
//    icon = gtk_icon_theme_lookup_icon (icon_theme,
//                                       "my-icon-name", // icon name
//                                       48, // icon size
//                                       1,  // scale
//                                       0,  // flags);
//     paintable = GDK_PAINTABLE (icon);
//     // Use the paintable
//     g_object_unref (icon);
//
type IconTheme interface {
	gextras.Objector

	// AddResourcePath adds a resource path that will be looked at when looking
	// for icons, similar to search paths.
	//
	// See gtk_icon_theme_set_resource_path().
	//
	// This function should be used to make application-specific icons available
	// as part of the icon theme.
	AddResourcePath(path string)
	// AddSearchPath appends a directory to the search path. See
	// gtk_icon_theme_set_search_path().
	AddSearchPath(path string)
	// Display returns the display that the GtkIconTheme object was created for.
	Display() gdk.Display
	// IconNames lists the names of icons in the current icon theme.
	IconNames() []string
	// IconSizes returns an array of integers describing the sizes at which the
	// icon is available without scaling. A size of -1 means that the icon is
	// available in a scalable format. The array is zero-terminated.
	IconSizes(iconName string) []int
	// ResourcePath gets the current resource path.
	//
	// See gtk_icon_theme_set_resource_path().
	ResourcePath() []string
	// SearchPath gets the current search path. See
	// gtk_icon_theme_set_search_path().
	SearchPath() []string
	// ThemeName gets the current icon theme name.
	//
	// Returns (transfer full): the current icon theme name,
	ThemeName() string
	// HasIcon checks whether an icon theme includes an icon for a particular
	// name.
	HasIcon(iconName string) bool
	// LookupByGIcon looks up a icon for a desired size and window scale,
	// returning a IconPaintable. The icon can then be rendered by using it as a
	// Paintable, or you can get information such as the filename and size.
	LookupByGIcon(icon gio.Icon, size int, scale int, direction TextDirection, flags IconLookupFlags) IconPaintable
	// LookupIcon looks up a named icon for a desired size and window scale,
	// returning a IconPaintable. The icon can then be rendered by using it as a
	// Paintable, or you can get information such as the filename and size.
	//
	// If the available @icon_name is not available and @fallbacks are provided,
	// they will be tried in order.
	//
	// If no matching icon is found, then a paintable that renders the "missing
	// icon" icon is returned. If you need to do something else for missing
	// icons you need to use gtk_icon_theme_has_icon().
	//
	// Note that you probably want to listen for icon theme changes and update
	// the icon. This is usually done by overriding the
	// WidgetClass.css-changed() function.
	LookupIcon(iconName string, fallbacks []string, size int, scale int, direction TextDirection, flags IconLookupFlags) IconPaintable
	// SetResourcePath sets the resource paths that will be looked at when
	// looking for icons, similar to search paths.
	//
	// The resources are considered as part of the hicolor icon theme and must
	// be located in subdirectories that are defined in the hicolor icon theme,
	// such as `@path/16x16/actions/run.png` or
	// `@path/scalable/actions/run.svg`.
	//
	// Icons that are directly placed in the resource path instead of a
	// subdirectory are also considered as ultimate fallback, but they are
	// treated like unthemed icons.
	SetResourcePath(path string)
	// SetSearchPath sets the search path for the icon theme object. When
	// looking for an icon theme, GTK will search for a subdirectory of one or
	// more of the directories in @path with the same name as the icon theme
	// containing an index.theme file. (Themes from multiple of the path
	// elements are combined to allow themes to be extended by adding icons in
	// the user’s home directory.)
	//
	// In addition if an icon found isn’t found either in the current icon theme
	// or the default icon theme, and an image file with the right name is found
	// directly in one of the elements of @path, then that image will be used
	// for the icon name. (This is legacy feature, and new icons should be put
	// into the fallback icon theme, which is called hicolor, rather than
	// directly on the icon path.)
	SetSearchPath(path []string)
	// SetThemeName sets the name of the icon theme that the IconTheme object
	// uses overriding system configuration. This function cannot be called on
	// the icon theme objects returned from gtk_icon_theme_get_for_display().
	SetThemeName(themeName string)
}

type iconTheme struct {
	*externglib.Object
}

// WrapIconTheme wraps a GObject to the right type. It is
// primarily used internally.
func WrapIconTheme(obj *externglib.Object) IconTheme {
	return iconTheme{*externglib.Object{obj}}
}

func marshalIconTheme(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapIconTheme(obj), nil
}

// NewIconTheme constructs a class IconTheme.
func NewIconTheme() IconTheme {

	ret := C.gtk_icon_theme_new()

	var ret0 IconTheme

	ret0 = WrapIconTheme(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// AddResourcePath adds a resource path that will be looked at when looking
// for icons, similar to search paths.
//
// See gtk_icon_theme_set_resource_path().
//
// This function should be used to make application-specific icons available
// as part of the icon theme.
func (self iconTheme) AddResourcePath(path string) {
	var arg0 *C.GtkIconTheme
	var arg1 *C.char

	arg0 = (*C.GtkIconTheme)(self.Native())
	arg1 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_icon_theme_add_resource_path(arg0, arg1)
}

// AddSearchPath appends a directory to the search path. See
// gtk_icon_theme_set_search_path().
func (self iconTheme) AddSearchPath(path string) {
	var arg0 *C.GtkIconTheme
	var arg1 *C.char

	arg0 = (*C.GtkIconTheme)(self.Native())
	arg1 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_icon_theme_add_search_path(arg0, arg1)
}

// Display returns the display that the GtkIconTheme object was created for.
func (self iconTheme) Display() gdk.Display {
	var arg0 *C.GtkIconTheme

	arg0 = (*C.GtkIconTheme)(self.Native())

	ret := C.gtk_icon_theme_get_display(arg0)

	var ret0 gdk.Display

	ret0 = gdk.WrapDisplay(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// IconNames lists the names of icons in the current icon theme.
func (self iconTheme) IconNames() []string {
	var arg0 *C.GtkIconTheme

	arg0 = (*C.GtkIconTheme)(self.Native())

	ret := C.gtk_icon_theme_get_icon_names(arg0)

	var ret0 []string

	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]string, length)
		for i := 0; i < length; i++ {
			src := (C.utf8)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			ret0[i] = C.GoString(src)
			C.free(unsafe.Pointer(src))
		}
	}

	return ret0
}

// IconSizes returns an array of integers describing the sizes at which the
// icon is available without scaling. A size of -1 means that the icon is
// available in a scalable format. The array is zero-terminated.
func (self iconTheme) IconSizes(iconName string) []int {
	var arg0 *C.GtkIconTheme
	var arg1 *C.char

	arg0 = (*C.GtkIconTheme)(self.Native())
	arg1 = (*C.gchar)(C.CString(iconName))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_icon_theme_get_icon_sizes(arg0, arg1)

	var ret0 []int

	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]int, length)
		for i := 0; i < length; i++ {
			src := (C.gint)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			ret0[i] = int(src)
		}
	}

	return ret0
}

// ResourcePath gets the current resource path.
//
// See gtk_icon_theme_set_resource_path().
func (self iconTheme) ResourcePath() []string {
	var arg0 *C.GtkIconTheme

	arg0 = (*C.GtkIconTheme)(self.Native())

	ret := C.gtk_icon_theme_get_resource_path(arg0)

	var ret0 []string

	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]string, length)
		for i := 0; i < length; i++ {
			src := (C.utf8)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			ret0[i] = C.GoString(src)
			C.free(unsafe.Pointer(src))
		}
	}

	return ret0
}

// SearchPath gets the current search path. See
// gtk_icon_theme_set_search_path().
func (self iconTheme) SearchPath() []string {
	var arg0 *C.GtkIconTheme

	arg0 = (*C.GtkIconTheme)(self.Native())

	ret := C.gtk_icon_theme_get_search_path(arg0)

	var ret0 []string

	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]string, length)
		for i := 0; i < length; i++ {
			src := (C.filename)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			ret0[i] = C.GoString(src)
			C.free(unsafe.Pointer(src))
		}
	}

	return ret0
}

// ThemeName gets the current icon theme name.
//
// Returns (transfer full): the current icon theme name,
func (self iconTheme) ThemeName() string {
	var arg0 *C.GtkIconTheme

	arg0 = (*C.GtkIconTheme)(self.Native())

	ret := C.gtk_icon_theme_get_theme_name(arg0)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// HasIcon checks whether an icon theme includes an icon for a particular
// name.
func (self iconTheme) HasIcon(iconName string) bool {
	var arg0 *C.GtkIconTheme
	var arg1 *C.char

	arg0 = (*C.GtkIconTheme)(self.Native())
	arg1 = (*C.gchar)(C.CString(iconName))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_icon_theme_has_icon(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// LookupByGIcon looks up a icon for a desired size and window scale,
// returning a IconPaintable. The icon can then be rendered by using it as a
// Paintable, or you can get information such as the filename and size.
func (self iconTheme) LookupByGIcon(icon gio.Icon, size int, scale int, direction TextDirection, flags IconLookupFlags) IconPaintable {
	var arg0 *C.GtkIconTheme
	var arg1 *C.GIcon
	var arg2 C.int
	var arg3 C.int
	var arg4 C.GtkTextDirection
	var arg5 C.GtkIconLookupFlags

	arg0 = (*C.GtkIconTheme)(self.Native())
	arg2 = C.int(size)
	arg3 = C.int(scale)
	arg4 = (C.GtkTextDirection)(direction)
	arg5 = (C.GtkIconLookupFlags)(flags)

	ret := C.gtk_icon_theme_lookup_by_gicon(arg0, arg1, arg2, arg3, arg4, arg5)

	var ret0 IconPaintable

	ret0 = WrapIconPaintable(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// LookupIcon looks up a named icon for a desired size and window scale,
// returning a IconPaintable. The icon can then be rendered by using it as a
// Paintable, or you can get information such as the filename and size.
//
// If the available @icon_name is not available and @fallbacks are provided,
// they will be tried in order.
//
// If no matching icon is found, then a paintable that renders the "missing
// icon" icon is returned. If you need to do something else for missing
// icons you need to use gtk_icon_theme_has_icon().
//
// Note that you probably want to listen for icon theme changes and update
// the icon. This is usually done by overriding the
// WidgetClass.css-changed() function.
func (self iconTheme) LookupIcon(iconName string, fallbacks []string, size int, scale int, direction TextDirection, flags IconLookupFlags) IconPaintable {
	var arg0 *C.GtkIconTheme
	var arg1 *C.char
	var arg2 **C.char
	var arg3 C.int
	var arg4 C.int
	var arg5 C.GtkTextDirection
	var arg6 C.GtkIconLookupFlags

	arg0 = (*C.GtkIconTheme)(self.Native())
	arg1 = (*C.gchar)(C.CString(iconName))
	defer C.free(unsafe.Pointer(arg1))
	{

	}
	arg3 = C.int(size)
	arg4 = C.int(scale)
	arg5 = (C.GtkTextDirection)(direction)
	arg6 = (C.GtkIconLookupFlags)(flags)

	ret := C.gtk_icon_theme_lookup_icon(arg0, arg1, arg2, arg3, arg4, arg5, arg6)

	var ret0 IconPaintable

	ret0 = WrapIconPaintable(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// SetResourcePath sets the resource paths that will be looked at when
// looking for icons, similar to search paths.
//
// The resources are considered as part of the hicolor icon theme and must
// be located in subdirectories that are defined in the hicolor icon theme,
// such as `@path/16x16/actions/run.png` or
// `@path/scalable/actions/run.svg`.
//
// Icons that are directly placed in the resource path instead of a
// subdirectory are also considered as ultimate fallback, but they are
// treated like unthemed icons.
func (self iconTheme) SetResourcePath(path string) {
	var arg0 *C.GtkIconTheme
	var arg1 **C.char

	arg0 = (*C.GtkIconTheme)(self.Native())
	arg1 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_icon_theme_set_resource_path(arg0, arg1)
}

// SetSearchPath sets the search path for the icon theme object. When
// looking for an icon theme, GTK will search for a subdirectory of one or
// more of the directories in @path with the same name as the icon theme
// containing an index.theme file. (Themes from multiple of the path
// elements are combined to allow themes to be extended by adding icons in
// the user’s home directory.)
//
// In addition if an icon found isn’t found either in the current icon theme
// or the default icon theme, and an image file with the right name is found
// directly in one of the elements of @path, then that image will be used
// for the icon name. (This is legacy feature, and new icons should be put
// into the fallback icon theme, which is called hicolor, rather than
// directly on the icon path.)
func (self iconTheme) SetSearchPath(path []string) {
	var arg0 *C.GtkIconTheme
	var arg1 **C.char

	arg0 = (*C.GtkIconTheme)(self.Native())
	{

	}

	C.gtk_icon_theme_set_search_path(arg0, arg1)
}

// SetThemeName sets the name of the icon theme that the IconTheme object
// uses overriding system configuration. This function cannot be called on
// the icon theme objects returned from gtk_icon_theme_get_for_display().
func (self iconTheme) SetThemeName(themeName string) {
	var arg0 *C.GtkIconTheme
	var arg1 *C.char

	arg0 = (*C.GtkIconTheme)(self.Native())
	arg1 = (*C.gchar)(C.CString(themeName))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_icon_theme_set_theme_name(arg0, arg1)
}

// IconView provides an alternative view on a TreeModel. It displays the model
// as a grid of icons with labels. Like TreeView, it allows to select one or
// multiple items (depending on the selection mode, see
// gtk_icon_view_set_selection_mode()). In addition to selection with the arrow
// keys, IconView supports rubberband selection, which is controlled by dragging
// the pointer.
//
// Note that if the tree model is backed by an actual tree store (as opposed to
// a flat list where the mapping to icons is obvious), IconView will only
// display the first level of the tree and ignore the tree’s branches.
//
// CSS nodes
//
//    iconview.view
//    ╰── [rubberband]
//
//
// GtkIconView has a single CSS node with name iconview and style class .view.
// For rubberband selection, a subnode with name rubberband is used.
type IconView interface {
	Widget

	// CreateDragIcon creates a #cairo_surface_t representation of the item at
	// @path. This image is used for a drag icon.
	CreateDragIcon(path *TreePath) gdk.Paintable
	// EnableModelDragDest turns @icon_view into a drop destination for
	// automatic DND. Calling this method sets IconView:reorderable to false.
	EnableModelDragDest(formats *gdk.ContentFormats, actions gdk.DragAction)
	// EnableModelDragSource turns @icon_view into a drag source for automatic
	// DND. Calling this method sets IconView:reorderable to false.
	EnableModelDragSource(startButtonMask gdk.ModifierType, formats *gdk.ContentFormats, actions gdk.DragAction)
	// ActivateOnSingleClick gets the setting set by
	// gtk_icon_view_set_activate_on_single_click().
	ActivateOnSingleClick() bool
	// CellRect fills the bounding rectangle in widget coordinates for the cell
	// specified by @path and @cell. If @cell is nil the main cell area is used.
	//
	// This function is only valid if @icon_view is realized.
	CellRect(path *TreePath, cell CellRenderer) (rect gdk.Rectangle, ok bool)
	// ColumnSpacing returns the value of the ::column-spacing property.
	ColumnSpacing() int
	// Columns returns the value of the ::columns property.
	Columns() int
	// Cursor fills in @path and @cell with the current cursor path and cell. If
	// the cursor isn’t currently set, then *@path will be nil. If no cell
	// currently has focus, then *@cell will be nil.
	//
	// The returned TreePath must be freed with gtk_tree_path_free().
	Cursor() (path *TreePath, cell CellRenderer, ok bool)
	// DestItemAtPos determines the destination item for a given position.
	DestItemAtPos(dragX int, dragY int) (path *TreePath, pos IconViewDropPosition, ok bool)
	// DragDestItem gets information about the item that is highlighted for
	// feedback.
	DragDestItem() (path *TreePath, pos IconViewDropPosition)
	// ItemAtPos gets the path and cell for the icon at the given position.
	ItemAtPos(x int, y int) (path *TreePath, cell CellRenderer, ok bool)
	// ItemColumn gets the column in which the item @path is currently
	// displayed. Column numbers start at 0.
	ItemColumn(path *TreePath) int
	// ItemOrientation returns the value of the ::item-orientation property
	// which determines whether the labels are drawn beside the icons instead of
	// below.
	ItemOrientation() Orientation
	// ItemPadding returns the value of the ::item-padding property.
	ItemPadding() int
	// ItemRow gets the row in which the item @path is currently displayed. Row
	// numbers start at 0.
	ItemRow(path *TreePath) int
	// ItemWidth returns the value of the ::item-width property.
	ItemWidth() int
	// Margin returns the value of the ::margin property.
	Margin() int
	// MarkupColumn returns the column with markup text for @icon_view.
	MarkupColumn() int
	// Model returns the model the IconView is based on. Returns nil if the
	// model is unset.
	Model() TreeModel
	// PathAtPos gets the path for the icon at the given position.
	PathAtPos(x int, y int) *TreePath
	// PixbufColumn returns the column with pixbufs for @icon_view.
	PixbufColumn() int
	// Reorderable retrieves whether the user can reorder the list via
	// drag-and-drop. See gtk_icon_view_set_reorderable().
	Reorderable() bool
	// RowSpacing returns the value of the ::row-spacing property.
	RowSpacing() int
	// SelectedItems creates a list of paths of all selected items.
	// Additionally, if you are planning on modifying the model after calling
	// this function, you may want to convert the returned list into a list of
	// TreeRowReferences. To do this, you can use gtk_tree_row_reference_new().
	//
	// To free the return value, use:
	//
	//    g_list_free_full (list, (GDestroyNotify) gtk_tree_path_free);
	//
	SelectedItems() *glib.List
	// SelectionMode gets the selection mode of the @icon_view.
	SelectionMode() SelectionMode
	// Spacing returns the value of the ::spacing property.
	Spacing() int
	// TextColumn returns the column with text for @icon_view.
	TextColumn() int
	// TooltipColumn returns the column of @icon_view’s model which is being
	// used for displaying tooltips on @icon_view’s rows.
	TooltipColumn() int
	// TooltipContext: this function is supposed to be used in a
	// Widget::query-tooltip signal handler for IconView. The @x, @y and
	// @keyboard_tip values which are received in the signal handler, should be
	// passed to this function without modification.
	//
	// The return value indicates whether there is an icon view item at the
	// given coordinates (true) or not (false) for mouse tooltips. For keyboard
	// tooltips the item returned will be the cursor item. When true, then any
	// of @model, @path and @iter which have been provided will be set to point
	// to that row and the corresponding model.
	TooltipContext(x int, y int, keyboardTip bool) (model TreeModel, path *TreePath, iter TreeIter, ok bool)
	// VisibleRange sets @start_path and @end_path to be the first and last
	// visible path. Note that there may be invisible paths in between.
	//
	// Both paths should be freed with gtk_tree_path_free() after use.
	VisibleRange() (startPath *TreePath, endPath *TreePath, ok bool)
	// ItemActivated activates the item determined by @path.
	ItemActivated(path *TreePath)
	// PathIsSelected returns true if the icon pointed to by @path is currently
	// selected. If @path does not point to a valid location, false is returned.
	PathIsSelected(path *TreePath) bool
	// ScrollToPath moves the alignments of @icon_view to the position specified
	// by @path. @row_align determines where the row is placed, and @col_align
	// determines where @column is placed. Both are expected to be between 0.0
	// and 1.0. 0.0 means left/top alignment, 1.0 means right/bottom alignment,
	// 0.5 means center.
	//
	// If @use_align is false, then the alignment arguments are ignored, and the
	// tree does the minimum amount of work to scroll the item onto the screen.
	// This means that the item will be scrolled to the edge closest to its
	// current position. If the item is currently visible on the screen, nothing
	// is done.
	//
	// This function only works if the model is set, and @path is a valid row on
	// the model. If the model changes before the @icon_view is realized, the
	// centered path will be modified to reflect this change.
	ScrollToPath(path *TreePath, useAlign bool, rowAlign float32, colAlign float32)
	// SelectAll selects all the icons. @icon_view must has its selection mode
	// set to K_SELECTION_MULTIPLE.
	SelectAll()
	// SelectPath selects the row at @path.
	SelectPath(path *TreePath)
	// SelectedForeach calls a function for each selected icon. Note that the
	// model or selection cannot be modified from within this function.
	SelectedForeach(_func IconViewForeachFunc)
	// SetActivateOnSingleClick causes the IconView::item-activated signal to be
	// emitted on a single click instead of a double click.
	SetActivateOnSingleClick(single bool)
	// SetColumnSpacing sets the ::column-spacing property which specifies the
	// space which is inserted between the columns of the icon view.
	SetColumnSpacing(columnSpacing int)
	// SetColumns sets the ::columns property which determines in how many
	// columns the icons are arranged. If @columns is -1, the number of columns
	// will be chosen automatically to fill the available area.
	SetColumns(columns int)
	// SetCursor sets the current keyboard focus to be at @path, and selects it.
	// This is useful when you want to focus the user’s attention on a
	// particular item. If @cell is not nil, then focus is given to the cell
	// specified by it. Additionally, if @start_editing is true, then editing
	// should be started in the specified cell.
	//
	// This function is often followed by `gtk_widget_grab_focus (icon_view)` in
	// order to give keyboard focus to the widget. Please note that editing can
	// only happen when the widget is realized.
	SetCursor(path *TreePath, cell CellRenderer, startEditing bool)
	// SetDragDestItem sets the item that is highlighted for feedback.
	SetDragDestItem(path *TreePath, pos IconViewDropPosition)
	// SetItemOrientation sets the ::item-orientation property which determines
	// whether the labels are drawn beside the icons instead of below.
	SetItemOrientation(orientation Orientation)
	// SetItemPadding sets the IconView:item-padding property which specifies
	// the padding around each of the icon view’s items.
	SetItemPadding(itemPadding int)
	// SetItemWidth sets the ::item-width property which specifies the width to
	// use for each item. If it is set to -1, the icon view will automatically
	// determine a suitable item size.
	SetItemWidth(itemWidth int)
	// SetMargin sets the ::margin property which specifies the space which is
	// inserted at the top, bottom, left and right of the icon view.
	SetMargin(margin int)
	// SetMarkupColumn sets the column with markup information for @icon_view to
	// be @column. The markup column must be of type TYPE_STRING. If the markup
	// column is set to something, it overrides the text column set by
	// gtk_icon_view_set_text_column().
	SetMarkupColumn(column int)
	// SetModel sets the model for a IconView. If the @icon_view already has a
	// model set, it will remove it before setting the new model. If @model is
	// nil, then it will unset the old model.
	SetModel(model TreeModel)
	// SetPixbufColumn sets the column with pixbufs for @icon_view to be
	// @column. The pixbuf column must be of type K_TYPE_PIXBUF
	SetPixbufColumn(column int)
	// SetReorderable: this function is a convenience function to allow you to
	// reorder models that support the TreeDragSourceIface and the
	// TreeDragDestIface. Both TreeStore and ListStore support these. If
	// @reorderable is true, then the user can reorder the model by dragging and
	// dropping rows. The developer can listen to these changes by connecting to
	// the model's row_inserted and row_deleted signals. The reordering is
	// implemented by setting up the icon view as a drag source and destination.
	// Therefore, drag and drop can not be used in a reorderable view for any
	// other purpose.
	//
	// This function does not give you any degree of control over the order --
	// any reordering is allowed. If more control is needed, you should probably
	// handle drag and drop manually.
	SetReorderable(reorderable bool)
	// SetRowSpacing sets the ::row-spacing property which specifies the space
	// which is inserted between the rows of the icon view.
	SetRowSpacing(rowSpacing int)
	// SetSelectionMode sets the selection mode of the @icon_view.
	SetSelectionMode(mode SelectionMode)
	// SetSpacing sets the ::spacing property which specifies the space which is
	// inserted between the cells (i.e. the icon and the text) of an item.
	SetSpacing(spacing int)
	// SetTextColumn sets the column with text for @icon_view to be @column. The
	// text column must be of type TYPE_STRING.
	SetTextColumn(column int)
	// SetTooltipCell sets the tip area of @tooltip to the area which @cell
	// occupies in the item pointed to by @path. See also
	// gtk_tooltip_set_tip_area().
	//
	// See also gtk_icon_view_set_tooltip_column() for a simpler alternative.
	SetTooltipCell(tooltip Tooltip, path *TreePath, cell CellRenderer)
	// SetTooltipColumn: if you only plan to have simple (text-only) tooltips on
	// full items, you can use this function to have IconView handle these
	// automatically for you. @column should be set to the column in
	// @icon_view’s model containing the tooltip texts, or -1 to disable this
	// feature.
	//
	// When enabled, Widget:has-tooltip will be set to true and @icon_view will
	// connect a Widget::query-tooltip signal handler.
	//
	// Note that the signal handler sets the text with gtk_tooltip_set_markup(),
	// so &, <, etc have to be escaped in the text.
	SetTooltipColumn(column int)
	// SetTooltipItem sets the tip area of @tooltip to be the area covered by
	// the item at @path. See also gtk_icon_view_set_tooltip_column() for a
	// simpler alternative. See also gtk_tooltip_set_tip_area().
	SetTooltipItem(tooltip Tooltip, path *TreePath)
	// UnselectAll unselects all the icons.
	UnselectAll()
	// UnselectPath unselects the row at @path.
	UnselectPath(path *TreePath)
	// UnsetModelDragDest undoes the effect of
	// gtk_icon_view_enable_model_drag_dest(). Calling this method sets
	// IconView:reorderable to false.
	UnsetModelDragDest()
	// UnsetModelDragSource undoes the effect of
	// gtk_icon_view_enable_model_drag_source(). Calling this method sets
	// IconView:reorderable to false.
	UnsetModelDragSource()
}

type iconView struct {
	widget
}

// WrapIconView wraps a GObject to the right type. It is
// primarily used internally.
func WrapIconView(obj *externglib.Object) IconView {
	return iconView{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}
}

func marshalIconView(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapIconView(obj), nil
}

// NewIconView constructs a class IconView.
func NewIconView() IconView {

	ret := C.gtk_icon_view_new()

	var ret0 IconView

	ret0 = WrapIconView(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewIconViewWithArea constructs a class IconView.
func NewIconViewWithArea(area CellArea) IconView {
	var arg1 *C.GtkCellArea

	arg1 = (*C.GtkCellArea)(area.Native())

	ret := C.gtk_icon_view_new_with_area(arg1)

	var ret0 IconView

	ret0 = WrapIconView(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewIconViewWithModel constructs a class IconView.
func NewIconViewWithModel(model TreeModel) IconView {
	var arg1 *C.GtkTreeModel

	ret := C.gtk_icon_view_new_with_model(arg1)

	var ret0 IconView

	ret0 = WrapIconView(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// CreateDragIcon creates a #cairo_surface_t representation of the item at
// @path. This image is used for a drag icon.
func (iconView iconView) CreateDragIcon(path *TreePath) gdk.Paintable {
	var arg0 *C.GtkIconView
	var arg1 *C.GtkTreePath

	arg0 = (*C.GtkIconView)(iconView.Native())
	arg1 = (*C.GtkTreePath)(path.Native())

	ret := C.gtk_icon_view_create_drag_icon(arg0, arg1)

	var ret0 gdk.Paintable

	return ret0
}

// EnableModelDragDest turns @icon_view into a drop destination for
// automatic DND. Calling this method sets IconView:reorderable to false.
func (iconView iconView) EnableModelDragDest(formats *gdk.ContentFormats, actions gdk.DragAction) {
	var arg0 *C.GtkIconView
	var arg1 *C.GdkContentFormats
	var arg2 C.GdkDragAction

	arg0 = (*C.GtkIconView)(iconView.Native())
	arg1 = (*C.GdkContentFormats)(formats.Native())
	arg2 = (C.GdkDragAction)(actions)

	C.gtk_icon_view_enable_model_drag_dest(arg0, arg1, arg2)
}

// EnableModelDragSource turns @icon_view into a drag source for automatic
// DND. Calling this method sets IconView:reorderable to false.
func (iconView iconView) EnableModelDragSource(startButtonMask gdk.ModifierType, formats *gdk.ContentFormats, actions gdk.DragAction) {
	var arg0 *C.GtkIconView
	var arg1 C.GdkModifierType
	var arg2 *C.GdkContentFormats
	var arg3 C.GdkDragAction

	arg0 = (*C.GtkIconView)(iconView.Native())
	arg1 = (C.GdkModifierType)(startButtonMask)
	arg2 = (*C.GdkContentFormats)(formats.Native())
	arg3 = (C.GdkDragAction)(actions)

	C.gtk_icon_view_enable_model_drag_source(arg0, arg1, arg2, arg3)
}

// ActivateOnSingleClick gets the setting set by
// gtk_icon_view_set_activate_on_single_click().
func (iconView iconView) ActivateOnSingleClick() bool {
	var arg0 *C.GtkIconView

	arg0 = (*C.GtkIconView)(iconView.Native())

	ret := C.gtk_icon_view_get_activate_on_single_click(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// CellRect fills the bounding rectangle in widget coordinates for the cell
// specified by @path and @cell. If @cell is nil the main cell area is used.
//
// This function is only valid if @icon_view is realized.
func (iconView iconView) CellRect(path *TreePath, cell CellRenderer) (rect gdk.Rectangle, ok bool) {
	var arg0 *C.GtkIconView
	var arg1 *C.GtkTreePath
	var arg2 *C.GtkCellRenderer
	var arg3 *C.GdkRectangle // out

	arg0 = (*C.GtkIconView)(iconView.Native())
	arg1 = (*C.GtkTreePath)(path.Native())
	arg2 = (*C.GtkCellRenderer)(cell.Native())

	ret := C.gtk_icon_view_get_cell_rect(arg0, arg1, arg2, &arg3)

	var ret0 *gdk.Rectangle
	var ret1 bool

	ret0 = gdk.WrapRectangle(arg3)

	ret1 = gextras.Gobool(ret)

	return ret0, ret1
}

// ColumnSpacing returns the value of the ::column-spacing property.
func (iconView iconView) ColumnSpacing() int {
	var arg0 *C.GtkIconView

	arg0 = (*C.GtkIconView)(iconView.Native())

	ret := C.gtk_icon_view_get_column_spacing(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Columns returns the value of the ::columns property.
func (iconView iconView) Columns() int {
	var arg0 *C.GtkIconView

	arg0 = (*C.GtkIconView)(iconView.Native())

	ret := C.gtk_icon_view_get_columns(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Cursor fills in @path and @cell with the current cursor path and cell. If
// the cursor isn’t currently set, then *@path will be nil. If no cell
// currently has focus, then *@cell will be nil.
//
// The returned TreePath must be freed with gtk_tree_path_free().
func (iconView iconView) Cursor() (path *TreePath, cell CellRenderer, ok bool) {
	var arg0 *C.GtkIconView
	var arg1 **C.GtkTreePath     // out
	var arg2 **C.GtkCellRenderer // out

	arg0 = (*C.GtkIconView)(iconView.Native())

	ret := C.gtk_icon_view_get_cursor(arg0, &arg1, &arg2)

	var ret0 **TreePath
	var ret1 CellRenderer
	var ret2 bool

	ret0 = WrapTreePath(arg1)

	ret1 = WrapCellRenderer(externglib.Take(unsafe.Pointer(arg2.Native())))

	ret2 = gextras.Gobool(ret)

	return ret0, ret1, ret2
}

// DestItemAtPos determines the destination item for a given position.
func (iconView iconView) DestItemAtPos(dragX int, dragY int) (path *TreePath, pos IconViewDropPosition, ok bool) {
	var arg0 *C.GtkIconView
	var arg1 C.int
	var arg2 C.int
	var arg3 **C.GtkTreePath            // out
	var arg4 *C.GtkIconViewDropPosition // out

	arg0 = (*C.GtkIconView)(iconView.Native())
	arg1 = C.int(dragX)
	arg2 = C.int(dragY)

	ret := C.gtk_icon_view_get_dest_item_at_pos(arg0, arg1, arg2, &arg3, &arg4)

	var ret0 **TreePath
	var ret1 *IconViewDropPosition
	var ret2 bool

	ret0 = WrapTreePath(arg3)

	ret1 = (*IconViewDropPosition)(arg4)

	ret2 = gextras.Gobool(ret)

	return ret0, ret1, ret2
}

// DragDestItem gets information about the item that is highlighted for
// feedback.
func (iconView iconView) DragDestItem() (path *TreePath, pos IconViewDropPosition) {
	var arg0 *C.GtkIconView
	var arg1 **C.GtkTreePath            // out
	var arg2 *C.GtkIconViewDropPosition // out

	arg0 = (*C.GtkIconView)(iconView.Native())

	ret := C.gtk_icon_view_get_drag_dest_item(arg0, &arg1, &arg2)

	var ret0 **TreePath
	var ret1 *IconViewDropPosition

	ret0 = WrapTreePath(arg1)

	ret1 = (*IconViewDropPosition)(arg2)

	return ret0, ret1
}

// ItemAtPos gets the path and cell for the icon at the given position.
func (iconView iconView) ItemAtPos(x int, y int) (path *TreePath, cell CellRenderer, ok bool) {
	var arg0 *C.GtkIconView
	var arg1 C.int
	var arg2 C.int
	var arg3 **C.GtkTreePath     // out
	var arg4 **C.GtkCellRenderer // out

	arg0 = (*C.GtkIconView)(iconView.Native())
	arg1 = C.int(x)
	arg2 = C.int(y)

	ret := C.gtk_icon_view_get_item_at_pos(arg0, arg1, arg2, &arg3, &arg4)

	var ret0 **TreePath
	var ret1 CellRenderer
	var ret2 bool

	ret0 = WrapTreePath(arg3)

	ret1 = WrapCellRenderer(externglib.Take(unsafe.Pointer(arg4.Native())))

	ret2 = gextras.Gobool(ret)

	return ret0, ret1, ret2
}

// ItemColumn gets the column in which the item @path is currently
// displayed. Column numbers start at 0.
func (iconView iconView) ItemColumn(path *TreePath) int {
	var arg0 *C.GtkIconView
	var arg1 *C.GtkTreePath

	arg0 = (*C.GtkIconView)(iconView.Native())
	arg1 = (*C.GtkTreePath)(path.Native())

	ret := C.gtk_icon_view_get_item_column(arg0, arg1)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// ItemOrientation returns the value of the ::item-orientation property
// which determines whether the labels are drawn beside the icons instead of
// below.
func (iconView iconView) ItemOrientation() Orientation {
	var arg0 *C.GtkIconView

	arg0 = (*C.GtkIconView)(iconView.Native())

	ret := C.gtk_icon_view_get_item_orientation(arg0)

	var ret0 Orientation

	ret0 = Orientation(ret)

	return ret0
}

// ItemPadding returns the value of the ::item-padding property.
func (iconView iconView) ItemPadding() int {
	var arg0 *C.GtkIconView

	arg0 = (*C.GtkIconView)(iconView.Native())

	ret := C.gtk_icon_view_get_item_padding(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// ItemRow gets the row in which the item @path is currently displayed. Row
// numbers start at 0.
func (iconView iconView) ItemRow(path *TreePath) int {
	var arg0 *C.GtkIconView
	var arg1 *C.GtkTreePath

	arg0 = (*C.GtkIconView)(iconView.Native())
	arg1 = (*C.GtkTreePath)(path.Native())

	ret := C.gtk_icon_view_get_item_row(arg0, arg1)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// ItemWidth returns the value of the ::item-width property.
func (iconView iconView) ItemWidth() int {
	var arg0 *C.GtkIconView

	arg0 = (*C.GtkIconView)(iconView.Native())

	ret := C.gtk_icon_view_get_item_width(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Margin returns the value of the ::margin property.
func (iconView iconView) Margin() int {
	var arg0 *C.GtkIconView

	arg0 = (*C.GtkIconView)(iconView.Native())

	ret := C.gtk_icon_view_get_margin(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// MarkupColumn returns the column with markup text for @icon_view.
func (iconView iconView) MarkupColumn() int {
	var arg0 *C.GtkIconView

	arg0 = (*C.GtkIconView)(iconView.Native())

	ret := C.gtk_icon_view_get_markup_column(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Model returns the model the IconView is based on. Returns nil if the
// model is unset.
func (iconView iconView) Model() TreeModel {
	var arg0 *C.GtkIconView

	arg0 = (*C.GtkIconView)(iconView.Native())

	ret := C.gtk_icon_view_get_model(arg0)

	var ret0 TreeModel

	return ret0
}

// PathAtPos gets the path for the icon at the given position.
func (iconView iconView) PathAtPos(x int, y int) *TreePath {
	var arg0 *C.GtkIconView
	var arg1 C.int
	var arg2 C.int

	arg0 = (*C.GtkIconView)(iconView.Native())
	arg1 = C.int(x)
	arg2 = C.int(y)

	ret := C.gtk_icon_view_get_path_at_pos(arg0, arg1, arg2)

	var ret0 *TreePath

	ret0 = WrapTreePath(ret)

	return ret0
}

// PixbufColumn returns the column with pixbufs for @icon_view.
func (iconView iconView) PixbufColumn() int {
	var arg0 *C.GtkIconView

	arg0 = (*C.GtkIconView)(iconView.Native())

	ret := C.gtk_icon_view_get_pixbuf_column(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Reorderable retrieves whether the user can reorder the list via
// drag-and-drop. See gtk_icon_view_set_reorderable().
func (iconView iconView) Reorderable() bool {
	var arg0 *C.GtkIconView

	arg0 = (*C.GtkIconView)(iconView.Native())

	ret := C.gtk_icon_view_get_reorderable(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// RowSpacing returns the value of the ::row-spacing property.
func (iconView iconView) RowSpacing() int {
	var arg0 *C.GtkIconView

	arg0 = (*C.GtkIconView)(iconView.Native())

	ret := C.gtk_icon_view_get_row_spacing(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// SelectedItems creates a list of paths of all selected items.
// Additionally, if you are planning on modifying the model after calling
// this function, you may want to convert the returned list into a list of
// TreeRowReferences. To do this, you can use gtk_tree_row_reference_new().
//
// To free the return value, use:
//
//    g_list_free_full (list, (GDestroyNotify) gtk_tree_path_free);
//
func (iconView iconView) SelectedItems() *glib.List {
	var arg0 *C.GtkIconView

	arg0 = (*C.GtkIconView)(iconView.Native())

	ret := C.gtk_icon_view_get_selected_items(arg0)

	var ret0 *glib.List

	ret0 = glib.WrapList(ret)

	return ret0
}

// SelectionMode gets the selection mode of the @icon_view.
func (iconView iconView) SelectionMode() SelectionMode {
	var arg0 *C.GtkIconView

	arg0 = (*C.GtkIconView)(iconView.Native())

	ret := C.gtk_icon_view_get_selection_mode(arg0)

	var ret0 SelectionMode

	ret0 = SelectionMode(ret)

	return ret0
}

// Spacing returns the value of the ::spacing property.
func (iconView iconView) Spacing() int {
	var arg0 *C.GtkIconView

	arg0 = (*C.GtkIconView)(iconView.Native())

	ret := C.gtk_icon_view_get_spacing(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// TextColumn returns the column with text for @icon_view.
func (iconView iconView) TextColumn() int {
	var arg0 *C.GtkIconView

	arg0 = (*C.GtkIconView)(iconView.Native())

	ret := C.gtk_icon_view_get_text_column(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// TooltipColumn returns the column of @icon_view’s model which is being
// used for displaying tooltips on @icon_view’s rows.
func (iconView iconView) TooltipColumn() int {
	var arg0 *C.GtkIconView

	arg0 = (*C.GtkIconView)(iconView.Native())

	ret := C.gtk_icon_view_get_tooltip_column(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// TooltipContext: this function is supposed to be used in a
// Widget::query-tooltip signal handler for IconView. The @x, @y and
// @keyboard_tip values which are received in the signal handler, should be
// passed to this function without modification.
//
// The return value indicates whether there is an icon view item at the
// given coordinates (true) or not (false) for mouse tooltips. For keyboard
// tooltips the item returned will be the cursor item. When true, then any
// of @model, @path and @iter which have been provided will be set to point
// to that row and the corresponding model.
func (iconView iconView) TooltipContext(x int, y int, keyboardTip bool) (model TreeModel, path *TreePath, iter TreeIter, ok bool) {
	var arg0 *C.GtkIconView
	var arg1 C.int
	var arg2 C.int
	var arg3 C.gboolean
	var arg4 **C.GtkTreeModel // out
	var arg5 **C.GtkTreePath  // out
	var arg6 *C.GtkTreeIter   // out

	arg0 = (*C.GtkIconView)(iconView.Native())
	arg1 = C.int(x)
	arg2 = C.int(y)
	arg3 = gextras.Cbool(keyboardTip)

	ret := C.gtk_icon_view_get_tooltip_context(arg0, arg1, arg2, arg3, &arg4, &arg5, &arg6)

	var ret0 *TreeModel
	var ret1 **TreePath
	var ret2 *TreeIter
	var ret3 bool

	ret1 = WrapTreePath(arg5)

	ret2 = WrapTreeIter(arg6)

	ret3 = gextras.Gobool(ret)

	return ret0, ret1, ret2, ret3
}

// VisibleRange sets @start_path and @end_path to be the first and last
// visible path. Note that there may be invisible paths in between.
//
// Both paths should be freed with gtk_tree_path_free() after use.
func (iconView iconView) VisibleRange() (startPath *TreePath, endPath *TreePath, ok bool) {
	var arg0 *C.GtkIconView
	var arg1 **C.GtkTreePath // out
	var arg2 **C.GtkTreePath // out

	arg0 = (*C.GtkIconView)(iconView.Native())

	ret := C.gtk_icon_view_get_visible_range(arg0, &arg1, &arg2)

	var ret0 **TreePath
	var ret1 **TreePath
	var ret2 bool

	ret0 = WrapTreePath(arg1)

	ret1 = WrapTreePath(arg2)

	ret2 = gextras.Gobool(ret)

	return ret0, ret1, ret2
}

// ItemActivated activates the item determined by @path.
func (iconView iconView) ItemActivated(path *TreePath) {
	var arg0 *C.GtkIconView
	var arg1 *C.GtkTreePath

	arg0 = (*C.GtkIconView)(iconView.Native())
	arg1 = (*C.GtkTreePath)(path.Native())

	C.gtk_icon_view_item_activated(arg0, arg1)
}

// PathIsSelected returns true if the icon pointed to by @path is currently
// selected. If @path does not point to a valid location, false is returned.
func (iconView iconView) PathIsSelected(path *TreePath) bool {
	var arg0 *C.GtkIconView
	var arg1 *C.GtkTreePath

	arg0 = (*C.GtkIconView)(iconView.Native())
	arg1 = (*C.GtkTreePath)(path.Native())

	ret := C.gtk_icon_view_path_is_selected(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// ScrollToPath moves the alignments of @icon_view to the position specified
// by @path. @row_align determines where the row is placed, and @col_align
// determines where @column is placed. Both are expected to be between 0.0
// and 1.0. 0.0 means left/top alignment, 1.0 means right/bottom alignment,
// 0.5 means center.
//
// If @use_align is false, then the alignment arguments are ignored, and the
// tree does the minimum amount of work to scroll the item onto the screen.
// This means that the item will be scrolled to the edge closest to its
// current position. If the item is currently visible on the screen, nothing
// is done.
//
// This function only works if the model is set, and @path is a valid row on
// the model. If the model changes before the @icon_view is realized, the
// centered path will be modified to reflect this change.
func (iconView iconView) ScrollToPath(path *TreePath, useAlign bool, rowAlign float32, colAlign float32) {
	var arg0 *C.GtkIconView
	var arg1 *C.GtkTreePath
	var arg2 C.gboolean
	var arg3 C.float
	var arg4 C.float

	arg0 = (*C.GtkIconView)(iconView.Native())
	arg1 = (*C.GtkTreePath)(path.Native())
	arg2 = gextras.Cbool(useAlign)
	arg3 = C.float(rowAlign)
	arg4 = C.float(colAlign)

	C.gtk_icon_view_scroll_to_path(arg0, arg1, arg2, arg3, arg4)
}

// SelectAll selects all the icons. @icon_view must has its selection mode
// set to K_SELECTION_MULTIPLE.
func (iconView iconView) SelectAll() {
	var arg0 *C.GtkIconView

	arg0 = (*C.GtkIconView)(iconView.Native())

	C.gtk_icon_view_select_all(arg0)
}

// SelectPath selects the row at @path.
func (iconView iconView) SelectPath(path *TreePath) {
	var arg0 *C.GtkIconView
	var arg1 *C.GtkTreePath

	arg0 = (*C.GtkIconView)(iconView.Native())
	arg1 = (*C.GtkTreePath)(path.Native())

	C.gtk_icon_view_select_path(arg0, arg1)
}

// SelectedForeach calls a function for each selected icon. Note that the
// model or selection cannot be modified from within this function.
func (iconView iconView) SelectedForeach(_func IconViewForeachFunc) {
	var arg0 *C.GtkIconView
	var arg1 C.GtkIconViewForeachFunc
	arg2 := C.gpointer(box.Assign(data))

	arg0 = (*C.GtkIconView)(iconView.Native())
	arg1 = (*[0]byte)(C.gotk4_IconViewForeachFunc)

	C.gtk_icon_view_selected_foreach(arg0, arg1)
}

// SetActivateOnSingleClick causes the IconView::item-activated signal to be
// emitted on a single click instead of a double click.
func (iconView iconView) SetActivateOnSingleClick(single bool) {
	var arg0 *C.GtkIconView
	var arg1 C.gboolean

	arg0 = (*C.GtkIconView)(iconView.Native())
	arg1 = gextras.Cbool(single)

	C.gtk_icon_view_set_activate_on_single_click(arg0, arg1)
}

// SetColumnSpacing sets the ::column-spacing property which specifies the
// space which is inserted between the columns of the icon view.
func (iconView iconView) SetColumnSpacing(columnSpacing int) {
	var arg0 *C.GtkIconView
	var arg1 C.int

	arg0 = (*C.GtkIconView)(iconView.Native())
	arg1 = C.int(columnSpacing)

	C.gtk_icon_view_set_column_spacing(arg0, arg1)
}

// SetColumns sets the ::columns property which determines in how many
// columns the icons are arranged. If @columns is -1, the number of columns
// will be chosen automatically to fill the available area.
func (iconView iconView) SetColumns(columns int) {
	var arg0 *C.GtkIconView
	var arg1 C.int

	arg0 = (*C.GtkIconView)(iconView.Native())
	arg1 = C.int(columns)

	C.gtk_icon_view_set_columns(arg0, arg1)
}

// SetCursor sets the current keyboard focus to be at @path, and selects it.
// This is useful when you want to focus the user’s attention on a
// particular item. If @cell is not nil, then focus is given to the cell
// specified by it. Additionally, if @start_editing is true, then editing
// should be started in the specified cell.
//
// This function is often followed by `gtk_widget_grab_focus (icon_view)` in
// order to give keyboard focus to the widget. Please note that editing can
// only happen when the widget is realized.
func (iconView iconView) SetCursor(path *TreePath, cell CellRenderer, startEditing bool) {
	var arg0 *C.GtkIconView
	var arg1 *C.GtkTreePath
	var arg2 *C.GtkCellRenderer
	var arg3 C.gboolean

	arg0 = (*C.GtkIconView)(iconView.Native())
	arg1 = (*C.GtkTreePath)(path.Native())
	arg2 = (*C.GtkCellRenderer)(cell.Native())
	arg3 = gextras.Cbool(startEditing)

	C.gtk_icon_view_set_cursor(arg0, arg1, arg2, arg3)
}

// SetDragDestItem sets the item that is highlighted for feedback.
func (iconView iconView) SetDragDestItem(path *TreePath, pos IconViewDropPosition) {
	var arg0 *C.GtkIconView
	var arg1 *C.GtkTreePath
	var arg2 C.GtkIconViewDropPosition

	arg0 = (*C.GtkIconView)(iconView.Native())
	arg1 = (*C.GtkTreePath)(path.Native())
	arg2 = (C.GtkIconViewDropPosition)(pos)

	C.gtk_icon_view_set_drag_dest_item(arg0, arg1, arg2)
}

// SetItemOrientation sets the ::item-orientation property which determines
// whether the labels are drawn beside the icons instead of below.
func (iconView iconView) SetItemOrientation(orientation Orientation) {
	var arg0 *C.GtkIconView
	var arg1 C.GtkOrientation

	arg0 = (*C.GtkIconView)(iconView.Native())
	arg1 = (C.GtkOrientation)(orientation)

	C.gtk_icon_view_set_item_orientation(arg0, arg1)
}

// SetItemPadding sets the IconView:item-padding property which specifies
// the padding around each of the icon view’s items.
func (iconView iconView) SetItemPadding(itemPadding int) {
	var arg0 *C.GtkIconView
	var arg1 C.int

	arg0 = (*C.GtkIconView)(iconView.Native())
	arg1 = C.int(itemPadding)

	C.gtk_icon_view_set_item_padding(arg0, arg1)
}

// SetItemWidth sets the ::item-width property which specifies the width to
// use for each item. If it is set to -1, the icon view will automatically
// determine a suitable item size.
func (iconView iconView) SetItemWidth(itemWidth int) {
	var arg0 *C.GtkIconView
	var arg1 C.int

	arg0 = (*C.GtkIconView)(iconView.Native())
	arg1 = C.int(itemWidth)

	C.gtk_icon_view_set_item_width(arg0, arg1)
}

// SetMargin sets the ::margin property which specifies the space which is
// inserted at the top, bottom, left and right of the icon view.
func (iconView iconView) SetMargin(margin int) {
	var arg0 *C.GtkIconView
	var arg1 C.int

	arg0 = (*C.GtkIconView)(iconView.Native())
	arg1 = C.int(margin)

	C.gtk_icon_view_set_margin(arg0, arg1)
}

// SetMarkupColumn sets the column with markup information for @icon_view to
// be @column. The markup column must be of type TYPE_STRING. If the markup
// column is set to something, it overrides the text column set by
// gtk_icon_view_set_text_column().
func (iconView iconView) SetMarkupColumn(column int) {
	var arg0 *C.GtkIconView
	var arg1 C.int

	arg0 = (*C.GtkIconView)(iconView.Native())
	arg1 = C.int(column)

	C.gtk_icon_view_set_markup_column(arg0, arg1)
}

// SetModel sets the model for a IconView. If the @icon_view already has a
// model set, it will remove it before setting the new model. If @model is
// nil, then it will unset the old model.
func (iconView iconView) SetModel(model TreeModel) {
	var arg0 *C.GtkIconView
	var arg1 *C.GtkTreeModel

	arg0 = (*C.GtkIconView)(iconView.Native())

	C.gtk_icon_view_set_model(arg0, arg1)
}

// SetPixbufColumn sets the column with pixbufs for @icon_view to be
// @column. The pixbuf column must be of type K_TYPE_PIXBUF
func (iconView iconView) SetPixbufColumn(column int) {
	var arg0 *C.GtkIconView
	var arg1 C.int

	arg0 = (*C.GtkIconView)(iconView.Native())
	arg1 = C.int(column)

	C.gtk_icon_view_set_pixbuf_column(arg0, arg1)
}

// SetReorderable: this function is a convenience function to allow you to
// reorder models that support the TreeDragSourceIface and the
// TreeDragDestIface. Both TreeStore and ListStore support these. If
// @reorderable is true, then the user can reorder the model by dragging and
// dropping rows. The developer can listen to these changes by connecting to
// the model's row_inserted and row_deleted signals. The reordering is
// implemented by setting up the icon view as a drag source and destination.
// Therefore, drag and drop can not be used in a reorderable view for any
// other purpose.
//
// This function does not give you any degree of control over the order --
// any reordering is allowed. If more control is needed, you should probably
// handle drag and drop manually.
func (iconView iconView) SetReorderable(reorderable bool) {
	var arg0 *C.GtkIconView
	var arg1 C.gboolean

	arg0 = (*C.GtkIconView)(iconView.Native())
	arg1 = gextras.Cbool(reorderable)

	C.gtk_icon_view_set_reorderable(arg0, arg1)
}

// SetRowSpacing sets the ::row-spacing property which specifies the space
// which is inserted between the rows of the icon view.
func (iconView iconView) SetRowSpacing(rowSpacing int) {
	var arg0 *C.GtkIconView
	var arg1 C.int

	arg0 = (*C.GtkIconView)(iconView.Native())
	arg1 = C.int(rowSpacing)

	C.gtk_icon_view_set_row_spacing(arg0, arg1)
}

// SetSelectionMode sets the selection mode of the @icon_view.
func (iconView iconView) SetSelectionMode(mode SelectionMode) {
	var arg0 *C.GtkIconView
	var arg1 C.GtkSelectionMode

	arg0 = (*C.GtkIconView)(iconView.Native())
	arg1 = (C.GtkSelectionMode)(mode)

	C.gtk_icon_view_set_selection_mode(arg0, arg1)
}

// SetSpacing sets the ::spacing property which specifies the space which is
// inserted between the cells (i.e. the icon and the text) of an item.
func (iconView iconView) SetSpacing(spacing int) {
	var arg0 *C.GtkIconView
	var arg1 C.int

	arg0 = (*C.GtkIconView)(iconView.Native())
	arg1 = C.int(spacing)

	C.gtk_icon_view_set_spacing(arg0, arg1)
}

// SetTextColumn sets the column with text for @icon_view to be @column. The
// text column must be of type TYPE_STRING.
func (iconView iconView) SetTextColumn(column int) {
	var arg0 *C.GtkIconView
	var arg1 C.int

	arg0 = (*C.GtkIconView)(iconView.Native())
	arg1 = C.int(column)

	C.gtk_icon_view_set_text_column(arg0, arg1)
}

// SetTooltipCell sets the tip area of @tooltip to the area which @cell
// occupies in the item pointed to by @path. See also
// gtk_tooltip_set_tip_area().
//
// See also gtk_icon_view_set_tooltip_column() for a simpler alternative.
func (iconView iconView) SetTooltipCell(tooltip Tooltip, path *TreePath, cell CellRenderer) {
	var arg0 *C.GtkIconView
	var arg1 *C.GtkTooltip
	var arg2 *C.GtkTreePath
	var arg3 *C.GtkCellRenderer

	arg0 = (*C.GtkIconView)(iconView.Native())
	arg1 = (*C.GtkTooltip)(tooltip.Native())
	arg2 = (*C.GtkTreePath)(path.Native())
	arg3 = (*C.GtkCellRenderer)(cell.Native())

	C.gtk_icon_view_set_tooltip_cell(arg0, arg1, arg2, arg3)
}

// SetTooltipColumn: if you only plan to have simple (text-only) tooltips on
// full items, you can use this function to have IconView handle these
// automatically for you. @column should be set to the column in
// @icon_view’s model containing the tooltip texts, or -1 to disable this
// feature.
//
// When enabled, Widget:has-tooltip will be set to true and @icon_view will
// connect a Widget::query-tooltip signal handler.
//
// Note that the signal handler sets the text with gtk_tooltip_set_markup(),
// so &, <, etc have to be escaped in the text.
func (iconView iconView) SetTooltipColumn(column int) {
	var arg0 *C.GtkIconView
	var arg1 C.int

	arg0 = (*C.GtkIconView)(iconView.Native())
	arg1 = C.int(column)

	C.gtk_icon_view_set_tooltip_column(arg0, arg1)
}

// SetTooltipItem sets the tip area of @tooltip to be the area covered by
// the item at @path. See also gtk_icon_view_set_tooltip_column() for a
// simpler alternative. See also gtk_tooltip_set_tip_area().
func (iconView iconView) SetTooltipItem(tooltip Tooltip, path *TreePath) {
	var arg0 *C.GtkIconView
	var arg1 *C.GtkTooltip
	var arg2 *C.GtkTreePath

	arg0 = (*C.GtkIconView)(iconView.Native())
	arg1 = (*C.GtkTooltip)(tooltip.Native())
	arg2 = (*C.GtkTreePath)(path.Native())

	C.gtk_icon_view_set_tooltip_item(arg0, arg1, arg2)
}

// UnselectAll unselects all the icons.
func (iconView iconView) UnselectAll() {
	var arg0 *C.GtkIconView

	arg0 = (*C.GtkIconView)(iconView.Native())

	C.gtk_icon_view_unselect_all(arg0)
}

// UnselectPath unselects the row at @path.
func (iconView iconView) UnselectPath(path *TreePath) {
	var arg0 *C.GtkIconView
	var arg1 *C.GtkTreePath

	arg0 = (*C.GtkIconView)(iconView.Native())
	arg1 = (*C.GtkTreePath)(path.Native())

	C.gtk_icon_view_unselect_path(arg0, arg1)
}

// UnsetModelDragDest undoes the effect of
// gtk_icon_view_enable_model_drag_dest(). Calling this method sets
// IconView:reorderable to false.
func (iconView iconView) UnsetModelDragDest() {
	var arg0 *C.GtkIconView

	arg0 = (*C.GtkIconView)(iconView.Native())

	C.gtk_icon_view_unset_model_drag_dest(arg0)
}

// UnsetModelDragSource undoes the effect of
// gtk_icon_view_enable_model_drag_source(). Calling this method sets
// IconView:reorderable to false.
func (iconView iconView) UnsetModelDragSource() {
	var arg0 *C.GtkIconView

	arg0 = (*C.GtkIconView)(iconView.Native())

	C.gtk_icon_view_unset_model_drag_source(arg0)
}

// Image: the Image widget displays an image. Various kinds of object can be
// displayed as an image; most typically, you would load a Texture from a file,
// and then display that. There’s a convenience function to do this,
// gtk_image_new_from_file(), used as follows:
//
//      GtkWidget *image;
//      image = gtk_image_new_from_file ("myfile.png");
//
//
// If the file isn’t loaded successfully, the image will contain a “broken
// image” icon similar to that used in many web browsers. If you want to handle
// errors in loading the file yourself, for example by displaying an error
// message, then load the image with gdk_texture_new_from_file(), then create
// the Image with gtk_image_new_from_paintable().
//
// Sometimes an application will want to avoid depending on external data files,
// such as image files. See the documentation of #GResource for details. In this
// case, the Image:resource, gtk_image_new_from_resource() and
// gtk_image_set_from_resource() should be used.
//
// GtkImage displays its image as an icon, with a size that is determined by the
// application. See Picture if you want to show an image at is actual size.
//
//
// CSS nodes
//
// GtkImage has a single CSS node with the name image. The style classes
// .normal-icons or .large-icons may appear, depending on the Image:icon-size
// property.
//
//
// Accessibility
//
// GtkImage uses the K_ACCESSIBLE_ROLE_IMG role.
type Image interface {
	Widget

	// Clear resets the image to be empty.
	Clear()
	// GIcon gets the #GIcon and size being displayed by the Image. The storage
	// type of the image must be GTK_IMAGE_EMPTY or GTK_IMAGE_GICON (see
	// gtk_image_get_storage_type()). The caller of this function does not own a
	// reference to the returned #GIcon.
	//
	// Note: This function was changed in 3.94 not to use out parameters
	// anymore, but return the GIcon directly. See gtk_image_get_icon_size() for
	// a way to get the icon size.
	GIcon() gio.Icon
	// IconName gets the icon name and size being displayed by the Image. The
	// storage type of the image must be GTK_IMAGE_EMPTY or GTK_IMAGE_ICON_NAME
	// (see gtk_image_get_storage_type()). The returned string is owned by the
	// Image and should not be freed.
	//
	// Note: This function was changed in 3.94 not to use out parameters
	// anymore, but return the icon name directly. See gtk_image_get_icon_size()
	// for a way to get the icon size.
	IconName() string
	// IconSize gets the icon size used by the @image when rendering icons.
	IconSize() IconSize
	// Paintable gets the image Paintable being displayed by the Image. The
	// storage type of the image must be GTK_IMAGE_EMPTY or GTK_IMAGE_PAINTABLE
	// (see gtk_image_get_storage_type()). The caller of this function does not
	// own a reference to the returned paintable.
	Paintable() gdk.Paintable
	// PixelSize gets the pixel size used for named icons.
	PixelSize() int
	// StorageType gets the type of representation being used by the Image to
	// store image data. If the Image has no image data, the return value will
	// be GTK_IMAGE_EMPTY.
	StorageType() ImageType
	// SetFromFile: see gtk_image_new_from_file() for details.
	SetFromFile(filename string)
	// SetFromGIcon: see gtk_image_new_from_gicon() for details.
	//
	// Note: Before 3.94, this function was taking an extra icon size argument.
	// See gtk_image_set_icon_size() for another way to set the icon size.
	SetFromGIcon(icon gio.Icon)
	// SetFromIconName: see gtk_image_new_from_icon_name() for details.
	//
	// Note: Before 3.94, this function was taking an extra icon size argument.
	// See gtk_image_set_icon_size() for another way to set the icon size.
	SetFromIconName(iconName string)
	// SetFromPaintable: see gtk_image_new_from_paintable() for details.
	SetFromPaintable(paintable gdk.Paintable)
	// SetFromPixbuf: see gtk_image_new_from_pixbuf() for details.
	//
	// Note: This is a helper for gtk_image_set_from_paintable(), and you can't
	// get back the exact pixbuf once this is called, only a paintable.
	SetFromPixbuf(pixbuf gdkpixbuf.Pixbuf)
	// SetFromResource: see gtk_image_new_from_resource() for details.
	SetFromResource(resourcePath string)
	// SetIconSize suggests an icon size to the theme for named icons.
	SetIconSize(iconSize IconSize)
	// SetPixelSize sets the pixel size to use for named icons. If the pixel
	// size is set to a value != -1, it is used instead of the icon size set by
	// gtk_image_set_from_icon_name().
	SetPixelSize(pixelSize int)
}

type image struct {
	widget
}

// WrapImage wraps a GObject to the right type. It is
// primarily used internally.
func WrapImage(obj *externglib.Object) Image {
	return image{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}
}

func marshalImage(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapImage(obj), nil
}

// NewImage constructs a class Image.
func NewImage() Image {

	ret := C.gtk_image_new()

	var ret0 Image

	ret0 = WrapImage(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewImageFromFile constructs a class Image.
func NewImageFromFile(filename string) Image {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_image_new_from_file(arg1)

	var ret0 Image

	ret0 = WrapImage(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewImageFromGIcon constructs a class Image.
func NewImageFromGIcon(icon gio.Icon) Image {
	var arg1 *C.GIcon

	ret := C.gtk_image_new_from_gicon(arg1)

	var ret0 Image

	ret0 = WrapImage(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewImageFromIconName constructs a class Image.
func NewImageFromIconName(iconName string) Image {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(iconName))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_image_new_from_icon_name(arg1)

	var ret0 Image

	ret0 = WrapImage(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewImageFromPaintable constructs a class Image.
func NewImageFromPaintable(paintable gdk.Paintable) Image {
	var arg1 *C.GdkPaintable

	ret := C.gtk_image_new_from_paintable(arg1)

	var ret0 Image

	ret0 = WrapImage(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewImageFromPixbuf constructs a class Image.
func NewImageFromPixbuf(pixbuf gdkpixbuf.Pixbuf) Image {
	var arg1 *C.GdkPixbuf

	arg1 = (*C.GdkPixbuf)(pixbuf.Native())

	ret := C.gtk_image_new_from_pixbuf(arg1)

	var ret0 Image

	ret0 = WrapImage(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewImageFromResource constructs a class Image.
func NewImageFromResource(resourcePath string) Image {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(resourcePath))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_image_new_from_resource(arg1)

	var ret0 Image

	ret0 = WrapImage(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Clear resets the image to be empty.
func (image image) Clear() {
	var arg0 *C.GtkImage

	arg0 = (*C.GtkImage)(image.Native())

	C.gtk_image_clear(arg0)
}

// GIcon gets the #GIcon and size being displayed by the Image. The storage
// type of the image must be GTK_IMAGE_EMPTY or GTK_IMAGE_GICON (see
// gtk_image_get_storage_type()). The caller of this function does not own a
// reference to the returned #GIcon.
//
// Note: This function was changed in 3.94 not to use out parameters
// anymore, but return the GIcon directly. See gtk_image_get_icon_size() for
// a way to get the icon size.
func (image image) GIcon() gio.Icon {
	var arg0 *C.GtkImage

	arg0 = (*C.GtkImage)(image.Native())

	ret := C.gtk_image_get_gicon(arg0)

	var ret0 gio.Icon

	return ret0
}

// IconName gets the icon name and size being displayed by the Image. The
// storage type of the image must be GTK_IMAGE_EMPTY or GTK_IMAGE_ICON_NAME
// (see gtk_image_get_storage_type()). The returned string is owned by the
// Image and should not be freed.
//
// Note: This function was changed in 3.94 not to use out parameters
// anymore, but return the icon name directly. See gtk_image_get_icon_size()
// for a way to get the icon size.
func (image image) IconName() string {
	var arg0 *C.GtkImage

	arg0 = (*C.GtkImage)(image.Native())

	ret := C.gtk_image_get_icon_name(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// IconSize gets the icon size used by the @image when rendering icons.
func (image image) IconSize() IconSize {
	var arg0 *C.GtkImage

	arg0 = (*C.GtkImage)(image.Native())

	ret := C.gtk_image_get_icon_size(arg0)

	var ret0 IconSize

	ret0 = IconSize(ret)

	return ret0
}

// Paintable gets the image Paintable being displayed by the Image. The
// storage type of the image must be GTK_IMAGE_EMPTY or GTK_IMAGE_PAINTABLE
// (see gtk_image_get_storage_type()). The caller of this function does not
// own a reference to the returned paintable.
func (image image) Paintable() gdk.Paintable {
	var arg0 *C.GtkImage

	arg0 = (*C.GtkImage)(image.Native())

	ret := C.gtk_image_get_paintable(arg0)

	var ret0 gdk.Paintable

	return ret0
}

// PixelSize gets the pixel size used for named icons.
func (image image) PixelSize() int {
	var arg0 *C.GtkImage

	arg0 = (*C.GtkImage)(image.Native())

	ret := C.gtk_image_get_pixel_size(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// StorageType gets the type of representation being used by the Image to
// store image data. If the Image has no image data, the return value will
// be GTK_IMAGE_EMPTY.
func (image image) StorageType() ImageType {
	var arg0 *C.GtkImage

	arg0 = (*C.GtkImage)(image.Native())

	ret := C.gtk_image_get_storage_type(arg0)

	var ret0 ImageType

	ret0 = ImageType(ret)

	return ret0
}

// SetFromFile: see gtk_image_new_from_file() for details.
func (image image) SetFromFile(filename string) {
	var arg0 *C.GtkImage
	var arg1 *C.char

	arg0 = (*C.GtkImage)(image.Native())
	arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_image_set_from_file(arg0, arg1)
}

// SetFromGIcon: see gtk_image_new_from_gicon() for details.
//
// Note: Before 3.94, this function was taking an extra icon size argument.
// See gtk_image_set_icon_size() for another way to set the icon size.
func (image image) SetFromGIcon(icon gio.Icon) {
	var arg0 *C.GtkImage
	var arg1 *C.GIcon

	arg0 = (*C.GtkImage)(image.Native())

	C.gtk_image_set_from_gicon(arg0, arg1)
}

// SetFromIconName: see gtk_image_new_from_icon_name() for details.
//
// Note: Before 3.94, this function was taking an extra icon size argument.
// See gtk_image_set_icon_size() for another way to set the icon size.
func (image image) SetFromIconName(iconName string) {
	var arg0 *C.GtkImage
	var arg1 *C.char

	arg0 = (*C.GtkImage)(image.Native())
	arg1 = (*C.gchar)(C.CString(iconName))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_image_set_from_icon_name(arg0, arg1)
}

// SetFromPaintable: see gtk_image_new_from_paintable() for details.
func (image image) SetFromPaintable(paintable gdk.Paintable) {
	var arg0 *C.GtkImage
	var arg1 *C.GdkPaintable

	arg0 = (*C.GtkImage)(image.Native())

	C.gtk_image_set_from_paintable(arg0, arg1)
}

// SetFromPixbuf: see gtk_image_new_from_pixbuf() for details.
//
// Note: This is a helper for gtk_image_set_from_paintable(), and you can't
// get back the exact pixbuf once this is called, only a paintable.
func (image image) SetFromPixbuf(pixbuf gdkpixbuf.Pixbuf) {
	var arg0 *C.GtkImage
	var arg1 *C.GdkPixbuf

	arg0 = (*C.GtkImage)(image.Native())
	arg1 = (*C.GdkPixbuf)(pixbuf.Native())

	C.gtk_image_set_from_pixbuf(arg0, arg1)
}

// SetFromResource: see gtk_image_new_from_resource() for details.
func (image image) SetFromResource(resourcePath string) {
	var arg0 *C.GtkImage
	var arg1 *C.char

	arg0 = (*C.GtkImage)(image.Native())
	arg1 = (*C.gchar)(C.CString(resourcePath))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_image_set_from_resource(arg0, arg1)
}

// SetIconSize suggests an icon size to the theme for named icons.
func (image image) SetIconSize(iconSize IconSize) {
	var arg0 *C.GtkImage
	var arg1 C.GtkIconSize

	arg0 = (*C.GtkImage)(image.Native())
	arg1 = (C.GtkIconSize)(iconSize)

	C.gtk_image_set_icon_size(arg0, arg1)
}

// SetPixelSize sets the pixel size to use for named icons. If the pixel
// size is set to a value != -1, it is used instead of the icon size set by
// gtk_image_set_from_icon_name().
func (image image) SetPixelSize(pixelSize int) {
	var arg0 *C.GtkImage
	var arg1 C.int

	arg0 = (*C.GtkImage)(image.Native())
	arg1 = C.int(pixelSize)

	C.gtk_image_set_pixel_size(arg0, arg1)
}

// InfoBar is a widget that can be used to show messages to the user without
// showing a dialog. It is often temporarily shown at the top or bottom of a
// document. In contrast to Dialog, which has an action area at the bottom,
// InfoBar has an action area at the side.
//
// The API of InfoBar is very similar to Dialog, allowing you to add buttons to
// the action area with gtk_info_bar_add_button() or
// gtk_info_bar_new_with_buttons(). The sensitivity of action widgets can be
// controlled with gtk_info_bar_set_response_sensitive().
//
// To add widgets to the main content area of a InfoBar, use
// gtk_info_bar_add_child().
//
// Similar to MessageDialog, the contents of a InfoBar can by classified as
// error message, warning, informational message, etc, by using
// gtk_info_bar_set_message_type(). GTK may use the message type to determine
// how the message is displayed.
//
// A simple example for using a InfoBar:
//
//    GtkWidget *message_label;
//    GtkWidget *widget;
//    GtkWidget *grid;
//    GtkInfoBar *bar;
//
//    // set up info bar
//    widget = gtk_info_bar_new ();
//    bar = GTK_INFO_BAR (widget);
//    grid = gtk_grid_new ();
//
//    message_label = gtk_label_new ("");
//    gtk_info_bar_add_child (bar, message_label);
//    gtk_info_bar_add_button (bar,
//                             _("_OK"),
//                             GTK_RESPONSE_OK);
//    g_signal_connect (bar,
//                      "response",
//                      G_CALLBACK (gtk_widget_hide),
//                      NULL);
//    gtk_grid_attach (GTK_GRID (grid),
//                     widget,
//                     0, 2, 1, 1);
//
//    // ...
//
//    // show an error message
//    gtk_label_set_text (GTK_LABEL (message_label), "An error occurred!");
//    gtk_info_bar_set_message_type (bar, GTK_MESSAGE_ERROR);
//    gtk_widget_show (bar);
//
//
//
// GtkInfoBar as GtkBuildable
//
// The GtkInfoBar implementation of the GtkBuildable interface exposes the
// content area and action area as internal children with the names
// “content_area” and “action_area”.
//
// GtkInfoBar supports a custom <action-widgets> element, which can contain
// multiple <action-widget> elements. The “response” attribute specifies a
// numeric response, and the content of the element is the id of widget (which
// should be a child of the dialogs @action_area).
//
//
// CSS nodes
//
// GtkInfoBar has a single CSS node with name infobar. The node may get one of
// the style classes .info, .warning, .error or .question, depending on the
// message type. If the info bar shows a close button, that button will have the
// .close style class applied.
type InfoBar interface {
	Widget

	// AddActionWidget: add an activatable widget to the action area of a
	// InfoBar, connecting a signal handler that will emit the InfoBar::response
	// signal on the message area when the widget is activated. The widget is
	// appended to the end of the message areas action area.
	AddActionWidget(child Widget, responseID int)
	// AddButton adds a button with the given text and sets things up so that
	// clicking the button will emit the “response” signal with the given
	// response_id. The button is appended to the end of the info bars's action
	// area. The button widget is returned, but usually you don't need it.
	AddButton(buttonText string, responseID int) Button
	// AddChild adds a widget to the content area of the info bar.
	AddChild(widget Widget)
	// MessageType returns the message type of the message area.
	MessageType() MessageType
	// Revealed returns whether the info bar is currently revealed.
	Revealed() bool
	// ShowCloseButton returns whether the widget will display a standard close
	// button.
	ShowCloseButton() bool
	// RemoveActionWidget removes a widget from the action area of @info_bar,
	// after it been put there by a call to gtk_info_bar_add_action_widget() or
	// gtk_info_bar_add_button().
	RemoveActionWidget(widget Widget)
	// RemoveChild removes a widget from the content area of the info bar, after
	// it has been added with gtk_info_bar_add_child().
	RemoveChild(widget Widget)
	// Response emits the “response” signal with the given @response_id.
	Response(responseID int)
	// SetDefaultResponse sets the last widget in the info bar’s action area
	// with the given response_id as the default widget for the dialog. Pressing
	// “Enter” normally activates the default widget.
	//
	// Note that this function currently requires @info_bar to be added to a
	// widget hierarchy.
	SetDefaultResponse(responseID int)
	// SetMessageType sets the message type of the message area.
	//
	// GTK uses this type to determine how the message is displayed.
	SetMessageType(messageType MessageType)
	// SetResponseSensitive calls gtk_widget_set_sensitive (widget, setting) for
	// each widget in the info bars’s action area with the given response_id. A
	// convenient way to sensitize/desensitize dialog buttons.
	SetResponseSensitive(responseID int, setting bool)
	// SetRevealed sets the InfoBar:revealed property to @revealed. Changing
	// this will make @info_bar reveal (true) or conceal (false) itself via a
	// sliding transition.
	//
	// Note: this does not show or hide @info_bar in the Widget:visible sense,
	// so revealing has no effect if Widget:visible is false.
	SetRevealed(revealed bool)
	// SetShowCloseButton: if true, a standard close button is shown. When
	// clicked it emits the response GTK_RESPONSE_CLOSE.
	SetShowCloseButton(setting bool)
}

type infoBar struct {
	widget
}

// WrapInfoBar wraps a GObject to the right type. It is
// primarily used internally.
func WrapInfoBar(obj *externglib.Object) InfoBar {
	return infoBar{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}
}

func marshalInfoBar(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapInfoBar(obj), nil
}

// NewInfoBar constructs a class InfoBar.
func NewInfoBar() InfoBar {

	ret := C.gtk_info_bar_new()

	var ret0 InfoBar

	ret0 = WrapInfoBar(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// AddActionWidget: add an activatable widget to the action area of a
// InfoBar, connecting a signal handler that will emit the InfoBar::response
// signal on the message area when the widget is activated. The widget is
// appended to the end of the message areas action area.
func (infoBar infoBar) AddActionWidget(child Widget, responseID int) {
	var arg0 *C.GtkInfoBar
	var arg1 *C.GtkWidget
	var arg2 C.int

	arg0 = (*C.GtkInfoBar)(infoBar.Native())
	arg1 = (*C.GtkWidget)(child.Native())
	arg2 = C.int(responseID)

	C.gtk_info_bar_add_action_widget(arg0, arg1, arg2)
}

// AddButton adds a button with the given text and sets things up so that
// clicking the button will emit the “response” signal with the given
// response_id. The button is appended to the end of the info bars's action
// area. The button widget is returned, but usually you don't need it.
func (infoBar infoBar) AddButton(buttonText string, responseID int) Button {
	var arg0 *C.GtkInfoBar
	var arg1 *C.char
	var arg2 C.int

	arg0 = (*C.GtkInfoBar)(infoBar.Native())
	arg1 = (*C.gchar)(C.CString(buttonText))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.int(responseID)

	ret := C.gtk_info_bar_add_button(arg0, arg1, arg2)

	var ret0 Button

	ret0 = WrapButton(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// AddChild adds a widget to the content area of the info bar.
func (infoBar infoBar) AddChild(widget Widget) {
	var arg0 *C.GtkInfoBar
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkInfoBar)(infoBar.Native())
	arg1 = (*C.GtkWidget)(widget.Native())

	C.gtk_info_bar_add_child(arg0, arg1)
}

// MessageType returns the message type of the message area.
func (infoBar infoBar) MessageType() MessageType {
	var arg0 *C.GtkInfoBar

	arg0 = (*C.GtkInfoBar)(infoBar.Native())

	ret := C.gtk_info_bar_get_message_type(arg0)

	var ret0 MessageType

	ret0 = MessageType(ret)

	return ret0
}

// Revealed returns whether the info bar is currently revealed.
func (infoBar infoBar) Revealed() bool {
	var arg0 *C.GtkInfoBar

	arg0 = (*C.GtkInfoBar)(infoBar.Native())

	ret := C.gtk_info_bar_get_revealed(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// ShowCloseButton returns whether the widget will display a standard close
// button.
func (infoBar infoBar) ShowCloseButton() bool {
	var arg0 *C.GtkInfoBar

	arg0 = (*C.GtkInfoBar)(infoBar.Native())

	ret := C.gtk_info_bar_get_show_close_button(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// RemoveActionWidget removes a widget from the action area of @info_bar,
// after it been put there by a call to gtk_info_bar_add_action_widget() or
// gtk_info_bar_add_button().
func (infoBar infoBar) RemoveActionWidget(widget Widget) {
	var arg0 *C.GtkInfoBar
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkInfoBar)(infoBar.Native())
	arg1 = (*C.GtkWidget)(widget.Native())

	C.gtk_info_bar_remove_action_widget(arg0, arg1)
}

// RemoveChild removes a widget from the content area of the info bar, after
// it has been added with gtk_info_bar_add_child().
func (infoBar infoBar) RemoveChild(widget Widget) {
	var arg0 *C.GtkInfoBar
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkInfoBar)(infoBar.Native())
	arg1 = (*C.GtkWidget)(widget.Native())

	C.gtk_info_bar_remove_child(arg0, arg1)
}

// Response emits the “response” signal with the given @response_id.
func (infoBar infoBar) Response(responseID int) {
	var arg0 *C.GtkInfoBar
	var arg1 C.int

	arg0 = (*C.GtkInfoBar)(infoBar.Native())
	arg1 = C.int(responseID)

	C.gtk_info_bar_response(arg0, arg1)
}

// SetDefaultResponse sets the last widget in the info bar’s action area
// with the given response_id as the default widget for the dialog. Pressing
// “Enter” normally activates the default widget.
//
// Note that this function currently requires @info_bar to be added to a
// widget hierarchy.
func (infoBar infoBar) SetDefaultResponse(responseID int) {
	var arg0 *C.GtkInfoBar
	var arg1 C.int

	arg0 = (*C.GtkInfoBar)(infoBar.Native())
	arg1 = C.int(responseID)

	C.gtk_info_bar_set_default_response(arg0, arg1)
}

// SetMessageType sets the message type of the message area.
//
// GTK uses this type to determine how the message is displayed.
func (infoBar infoBar) SetMessageType(messageType MessageType) {
	var arg0 *C.GtkInfoBar
	var arg1 C.GtkMessageType

	arg0 = (*C.GtkInfoBar)(infoBar.Native())
	arg1 = (C.GtkMessageType)(messageType)

	C.gtk_info_bar_set_message_type(arg0, arg1)
}

// SetResponseSensitive calls gtk_widget_set_sensitive (widget, setting) for
// each widget in the info bars’s action area with the given response_id. A
// convenient way to sensitize/desensitize dialog buttons.
func (infoBar infoBar) SetResponseSensitive(responseID int, setting bool) {
	var arg0 *C.GtkInfoBar
	var arg1 C.int
	var arg2 C.gboolean

	arg0 = (*C.GtkInfoBar)(infoBar.Native())
	arg1 = C.int(responseID)
	arg2 = gextras.Cbool(setting)

	C.gtk_info_bar_set_response_sensitive(arg0, arg1, arg2)
}

// SetRevealed sets the InfoBar:revealed property to @revealed. Changing
// this will make @info_bar reveal (true) or conceal (false) itself via a
// sliding transition.
//
// Note: this does not show or hide @info_bar in the Widget:visible sense,
// so revealing has no effect if Widget:visible is false.
func (infoBar infoBar) SetRevealed(revealed bool) {
	var arg0 *C.GtkInfoBar
	var arg1 C.gboolean

	arg0 = (*C.GtkInfoBar)(infoBar.Native())
	arg1 = gextras.Cbool(revealed)

	C.gtk_info_bar_set_revealed(arg0, arg1)
}

// SetShowCloseButton: if true, a standard close button is shown. When
// clicked it emits the response GTK_RESPONSE_CLOSE.
func (infoBar infoBar) SetShowCloseButton(setting bool) {
	var arg0 *C.GtkInfoBar
	var arg1 C.gboolean

	arg0 = (*C.GtkInfoBar)(infoBar.Native())
	arg1 = gextras.Cbool(setting)

	C.gtk_info_bar_set_show_close_button(arg0, arg1)
}

// KeyvalTrigger: a ShortcutTrigger that triggers when a specific keyval and
// (optionally) modifiers are pressed.
type KeyvalTrigger interface {
	ShortcutTrigger

	// Keyval gets the keyval that must be pressed to succeed triggering @self.
	Keyval() uint
	// Modifiers gets the modifiers that must be present to succeed triggering
	// @self.
	Modifiers() gdk.ModifierType
}

type keyvalTrigger struct {
	shortcutTrigger
}

// WrapKeyvalTrigger wraps a GObject to the right type. It is
// primarily used internally.
func WrapKeyvalTrigger(obj *externglib.Object) KeyvalTrigger {
	return keyvalTrigger{shortcutTrigger{*externglib.Object{obj}}}
}

func marshalKeyvalTrigger(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapKeyvalTrigger(obj), nil
}

// NewKeyvalTrigger constructs a class KeyvalTrigger.
func NewKeyvalTrigger(keyval uint, modifiers gdk.ModifierType) KeyvalTrigger {
	var arg1 C.guint
	var arg2 C.GdkModifierType

	arg1 = C.guint(keyval)
	arg2 = (C.GdkModifierType)(modifiers)

	ret := C.gtk_keyval_trigger_new(arg1, arg2)

	var ret0 KeyvalTrigger

	ret0 = WrapKeyvalTrigger(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Keyval gets the keyval that must be pressed to succeed triggering @self.
func (self keyvalTrigger) Keyval() uint {
	var arg0 *C.GtkKeyvalTrigger

	arg0 = (*C.GtkKeyvalTrigger)(self.Native())

	ret := C.gtk_keyval_trigger_get_keyval(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// Modifiers gets the modifiers that must be present to succeed triggering
// @self.
func (self keyvalTrigger) Modifiers() gdk.ModifierType {
	var arg0 *C.GtkKeyvalTrigger

	arg0 = (*C.GtkKeyvalTrigger)(self.Native())

	ret := C.gtk_keyval_trigger_get_modifiers(arg0)

	var ret0 gdk.ModifierType

	ret0 = gdk.ModifierType(ret)

	return ret0
}

// Label: the Label widget displays a small amount of text. As the name implies,
// most labels are used to label another widget such as a Button.
//
// CSS nodes
//
//    const char *text =
//    "Go to the"
//    "<a href=\"http://www.gtk.org title=\"&lt;i&gt;Our&lt;/i&gt; website\">"
//    "GTK website</a> for more...";
//    GtkWidget *label = gtk_label_new (NULL);
//    gtk_label_set_markup (GTK_LABEL (label), text);
//
//
// It is possible to implement custom handling for links and their tooltips with
// the Label::activate-link signal and the gtk_label_get_current_uri() function.
type Label interface {
	Widget

	// Attributes gets the attribute list that was set on the label using
	// gtk_label_set_attributes(), if any. This function does not reflect
	// attributes that come from the labels markup (see gtk_label_set_markup()).
	// If you want to get the effective attributes for the label, use
	// pango_layout_get_attribute (gtk_label_get_layout (self)).
	Attributes() *pango.AttrList
	// CurrentURI returns the URI for the currently active link in the label.
	// The active link is the one under the mouse pointer or, in a selectable
	// label, the link in which the text cursor is currently positioned.
	//
	// This function is intended for use in a Label::activate-link handler or
	// for use in a Widget::query-tooltip handler.
	CurrentURI() string
	// Ellipsize returns the ellipsizing position of the label. See
	// gtk_label_set_ellipsize().
	Ellipsize() pango.EllipsizeMode
	// ExtraMenu gets the menu model set with gtk_label_set_extra_menu().
	ExtraMenu() gio.MenuModel
	// Justify returns the justification of the label. See
	// gtk_label_set_justify().
	Justify() Justification
	// Label fetches the text from a label widget including any embedded
	// underlines indicating mnemonics and Pango markup. (See
	// gtk_label_get_text()).
	Label() string
	// Layout gets the Layout used to display the label. The layout is useful to
	// e.g. convert text positions to pixel positions, in combination with
	// gtk_label_get_layout_offsets(). The returned layout is owned by the
	// @label so need not be freed by the caller. The @label is free to recreate
	// its layout at any time, so it should be considered read-only.
	Layout() pango.Layout
	// LayoutOffsets obtains the coordinates where the label will draw the
	// Layout representing the text in the label; useful to convert mouse events
	// into coordinates inside the Layout, e.g. to take some action if some part
	// of the label is clicked. Remember when using the Layout functions you
	// need to convert to and from pixels using PANGO_PIXELS() or NGO_SCALE.
	LayoutOffsets() (x int, y int)
	// Lines gets the number of lines to which an ellipsized, wrapping label
	// should be limited. See gtk_label_set_lines().
	Lines() int
	// MaxWidthChars retrieves the desired maximum width of @label, in
	// characters. See gtk_label_set_width_chars().
	MaxWidthChars() int
	// MnemonicKeyval: if the label has been set so that it has a mnemonic key
	// this function returns the keyval used for the mnemonic accelerator. If
	// there is no mnemonic set up it returns K_KEY_VoidSymbol.
	MnemonicKeyval() uint
	// MnemonicWidget retrieves the target of the mnemonic (keyboard shortcut)
	// of this label. See gtk_label_set_mnemonic_widget().
	MnemonicWidget() Widget
	// Selectable gets the value set by gtk_label_set_selectable().
	Selectable() bool
	// SelectionBounds gets the selected range of characters in the label,
	// returning true if there’s a selection.
	SelectionBounds() (start int, end int, ok bool)
	// SingleLineMode returns whether the label is in single line mode.
	SingleLineMode() bool
	// Text fetches the text from a label widget, as displayed on the screen.
	// This does not include any embedded underlines indicating mnemonics or
	// Pango markup. (See gtk_label_get_label())
	Text() string
	// UseMarkup returns whether the label’s text is interpreted as marked up
	// with the [Pango text markup language][PangoMarkupFormat]. See
	// gtk_label_set_use_markup ().
	UseMarkup() bool
	// UseUnderline returns whether an embedded underline in the label indicates
	// a mnemonic. See gtk_label_set_use_underline().
	UseUnderline() bool
	// WidthChars retrieves the desired width of @label, in characters. See
	// gtk_label_set_width_chars().
	WidthChars() int
	// Wrap returns whether lines in the label are automatically wrapped. See
	// gtk_label_set_wrap().
	Wrap() bool
	// WrapMode returns line wrap mode used by the label. See
	// gtk_label_set_wrap_mode().
	WrapMode() pango.WrapMode
	// Xalign gets the Label:xalign property for @label.
	Xalign() float32
	// Yalign gets the Label:yalign property for @label.
	Yalign() float32
	// SelectRegion selects a range of characters in the label, if the label is
	// selectable. See gtk_label_set_selectable(). If the label is not
	// selectable, this function has no effect. If @start_offset or @end_offset
	// are -1, then the end of the label will be substituted.
	SelectRegion(startOffset int, endOffset int)
	// SetAttributes sets a AttrList; the attributes in the list are applied to
	// the label text.
	//
	// The attributes set with this function will be applied and merged with any
	// other attributes previously effected by way of the Label:use-underline or
	// Label:use-markup properties. While it is not recommended to mix markup
	// strings with manually set attributes, if you must; know that the
	// attributes will be applied to the label after the markup string is
	// parsed.
	SetAttributes(attrs *pango.AttrList)
	// SetEllipsize sets the mode used to ellipsize (add an ellipsis: "...") to
	// the text if there is not enough space to render the entire string.
	SetEllipsize(mode pango.EllipsizeMode)
	// SetExtraMenu sets a menu model to add when constructing the context menu
	// for @label.
	SetExtraMenu(model gio.MenuModel)
	// SetJustify sets the alignment of the lines in the text of the label
	// relative to each other. GTK_JUSTIFY_LEFT is the default value when the
	// widget is first created with gtk_label_new(). If you instead want to set
	// the alignment of the label as a whole, use gtk_widget_set_halign()
	// instead. gtk_label_set_justify() has no effect on labels containing only
	// a single line.
	SetJustify(jtype Justification)
	// SetLabel sets the text of the label. The label is interpreted as
	// including embedded underlines and/or Pango markup depending on the values
	// of the Label:use-underline and Label:use-markup properties.
	SetLabel(str string)
	// SetLines sets the number of lines to which an ellipsized, wrapping label
	// should be limited. This has no effect if the label is not wrapping or
	// ellipsized. Set this to -1 if you don’t want to limit the number of
	// lines.
	SetLines(lines int)
	// SetMarkup parses @str which is marked up with the [Pango text markup
	// language][PangoMarkupFormat], setting the label’s text and attribute list
	// based on the parse results.
	//
	// If the @str is external data, you may need to escape it with
	// g_markup_escape_text() or g_markup_printf_escaped():
	//
	//    GtkWidget *self = gtk_label_new (NULL);
	//    const char *str = "...";
	//    const char *format = "<span style=\"italic\">\s</span>";
	//    char *markup;
	//
	//    markup = g_markup_printf_escaped (format, str);
	//    gtk_label_set_markup (GTK_LABEL (self), markup);
	//    g_free (markup);
	//
	//
	// This function will set the Label:use-markup property to true as a side
	// effect.
	//
	// If you set the label contents using the Label:label property you should
	// also ensure that you set the Label:use-markup property accordingly.
	//
	// See also: gtk_label_set_text()
	SetMarkup(str string)
	// SetMarkupWithMnemonic parses @str which is marked up with the [Pango text
	// markup language][PangoMarkupFormat], setting the label’s text and
	// attribute list based on the parse results. If characters in @str are
	// preceded by an underscore, they are underlined indicating that they
	// represent a keyboard accelerator called a mnemonic.
	//
	// The mnemonic key can be used to activate another widget, chosen
	// automatically, or explicitly using gtk_label_set_mnemonic_widget().
	SetMarkupWithMnemonic(str string)
	// SetMaxWidthChars sets the desired maximum width in characters of @label
	// to @n_chars.
	SetMaxWidthChars(nChars int)
	// SetMnemonicWidget: if the label has been set so that it has a mnemonic
	// key (using i.e. gtk_label_set_markup_with_mnemonic(),
	// gtk_label_set_text_with_mnemonic(), gtk_label_new_with_mnemonic() or the
	// “use_underline” property) the label can be associated with a widget that
	// is the target of the mnemonic. When the label is inside a widget (like a
	// Button or a Notebook tab) it is automatically associated with the correct
	// widget, but sometimes (i.e. when the target is a Entry next to the label)
	// you need to set it explicitly using this function.
	//
	// The target widget will be accelerated by emitting the
	// GtkWidget::mnemonic-activate signal on it. The default handler for this
	// signal will activate the widget if there are no mnemonic collisions and
	// toggle focus between the colliding widgets otherwise.
	SetMnemonicWidget(widget Widget)
	// SetSelectable: selectable labels allow the user to select text from the
	// label, for copy-and-paste.
	SetSelectable(setting bool)
	// SetSingleLineMode sets whether the label is in single line mode.
	SetSingleLineMode(singleLineMode bool)
	// SetText sets the text within the Label widget. It overwrites any text
	// that was there before.
	//
	// This function will clear any previously set mnemonic accelerators, and
	// set the Label:use-underline property to false as a side effect.
	//
	// This function will set the Label:use-markup property to false as a side
	// effect.
	//
	// See also: gtk_label_set_markup()
	SetText(str string)
	// SetTextWithMnemonic sets the label’s text from the string @str. If
	// characters in @str are preceded by an underscore, they are underlined
	// indicating that they represent a keyboard accelerator called a mnemonic.
	// The mnemonic key can be used to activate another widget, chosen
	// automatically, or explicitly using gtk_label_set_mnemonic_widget().
	SetTextWithMnemonic(str string)
	// SetUseMarkup sets whether the text of the label contains markup in
	// [Pango’s text markup language][PangoMarkupFormat]. See
	// gtk_label_set_markup().
	SetUseMarkup(setting bool)
	// SetUseUnderline: if true, an underline in the text indicates the next
	// character should be used for the mnemonic accelerator key.
	SetUseUnderline(setting bool)
	// SetWidthChars sets the desired width in characters of @label to @n_chars.
	SetWidthChars(nChars int)
	// SetWrap toggles line wrapping within the Label widget. true makes it
	// break lines if text exceeds the widget’s size. false lets the text get
	// cut off by the edge of the widget if it exceeds the widget size.
	//
	// Note that setting line wrapping to true does not make the label wrap at
	// its parent container’s width, because GTK widgets conceptually can’t make
	// their requisition depend on the parent container’s size. For a label that
	// wraps at a specific position, set the label’s width using
	// gtk_widget_set_size_request().
	SetWrap(wrap bool)
	// SetWrapMode: if line wrapping is on (see gtk_label_set_wrap()) this
	// controls how the line wrapping is done. The default is PANGO_WRAP_WORD
	// which means wrap on word boundaries.
	SetWrapMode(wrapMode pango.WrapMode)
	// SetXalign sets the Label:xalign property for @label.
	SetXalign(xalign float32)
	// SetYalign sets the Label:yalign property for @label.
	SetYalign(yalign float32)
}

type label struct {
	widget
}

// WrapLabel wraps a GObject to the right type. It is
// primarily used internally.
func WrapLabel(obj *externglib.Object) Label {
	return label{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}
}

func marshalLabel(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapLabel(obj), nil
}

// NewLabel constructs a class Label.
func NewLabel(str string) Label {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_label_new(arg1)

	var ret0 Label

	ret0 = WrapLabel(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewLabelWithMnemonic constructs a class Label.
func NewLabelWithMnemonic(str string) Label {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_label_new_with_mnemonic(arg1)

	var ret0 Label

	ret0 = WrapLabel(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Attributes gets the attribute list that was set on the label using
// gtk_label_set_attributes(), if any. This function does not reflect
// attributes that come from the labels markup (see gtk_label_set_markup()).
// If you want to get the effective attributes for the label, use
// pango_layout_get_attribute (gtk_label_get_layout (self)).
func (self label) Attributes() *pango.AttrList {
	var arg0 *C.GtkLabel

	arg0 = (*C.GtkLabel)(self.Native())

	ret := C.gtk_label_get_attributes(arg0)

	var ret0 *pango.AttrList

	ret0 = pango.WrapAttrList(ret)

	return ret0
}

// CurrentURI returns the URI for the currently active link in the label.
// The active link is the one under the mouse pointer or, in a selectable
// label, the link in which the text cursor is currently positioned.
//
// This function is intended for use in a Label::activate-link handler or
// for use in a Widget::query-tooltip handler.
func (self label) CurrentURI() string {
	var arg0 *C.GtkLabel

	arg0 = (*C.GtkLabel)(self.Native())

	ret := C.gtk_label_get_current_uri(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Ellipsize returns the ellipsizing position of the label. See
// gtk_label_set_ellipsize().
func (self label) Ellipsize() pango.EllipsizeMode {
	var arg0 *C.GtkLabel

	arg0 = (*C.GtkLabel)(self.Native())

	ret := C.gtk_label_get_ellipsize(arg0)

	var ret0 pango.EllipsizeMode

	ret0 = pango.EllipsizeMode(ret)

	return ret0
}

// ExtraMenu gets the menu model set with gtk_label_set_extra_menu().
func (self label) ExtraMenu() gio.MenuModel {
	var arg0 *C.GtkLabel

	arg0 = (*C.GtkLabel)(self.Native())

	ret := C.gtk_label_get_extra_menu(arg0)

	var ret0 gio.MenuModel

	ret0 = gio.WrapMenuModel(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Justify returns the justification of the label. See
// gtk_label_set_justify().
func (self label) Justify() Justification {
	var arg0 *C.GtkLabel

	arg0 = (*C.GtkLabel)(self.Native())

	ret := C.gtk_label_get_justify(arg0)

	var ret0 Justification

	ret0 = Justification(ret)

	return ret0
}

// Label fetches the text from a label widget including any embedded
// underlines indicating mnemonics and Pango markup. (See
// gtk_label_get_text()).
func (self label) Label() string {
	var arg0 *C.GtkLabel

	arg0 = (*C.GtkLabel)(self.Native())

	ret := C.gtk_label_get_label(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Layout gets the Layout used to display the label. The layout is useful to
// e.g. convert text positions to pixel positions, in combination with
// gtk_label_get_layout_offsets(). The returned layout is owned by the
// @label so need not be freed by the caller. The @label is free to recreate
// its layout at any time, so it should be considered read-only.
func (self label) Layout() pango.Layout {
	var arg0 *C.GtkLabel

	arg0 = (*C.GtkLabel)(self.Native())

	ret := C.gtk_label_get_layout(arg0)

	var ret0 pango.Layout

	ret0 = pango.WrapLayout(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// LayoutOffsets obtains the coordinates where the label will draw the
// Layout representing the text in the label; useful to convert mouse events
// into coordinates inside the Layout, e.g. to take some action if some part
// of the label is clicked. Remember when using the Layout functions you
// need to convert to and from pixels using PANGO_PIXELS() or NGO_SCALE.
func (self label) LayoutOffsets() (x int, y int) {
	var arg0 *C.GtkLabel
	var arg1 *C.int // out
	var arg2 *C.int // out

	arg0 = (*C.GtkLabel)(self.Native())

	ret := C.gtk_label_get_layout_offsets(arg0, &arg1, &arg2)

	var ret0 int
	var ret1 int

	ret0 = int(arg1)

	ret1 = int(arg2)

	return ret0, ret1
}

// Lines gets the number of lines to which an ellipsized, wrapping label
// should be limited. See gtk_label_set_lines().
func (self label) Lines() int {
	var arg0 *C.GtkLabel

	arg0 = (*C.GtkLabel)(self.Native())

	ret := C.gtk_label_get_lines(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// MaxWidthChars retrieves the desired maximum width of @label, in
// characters. See gtk_label_set_width_chars().
func (self label) MaxWidthChars() int {
	var arg0 *C.GtkLabel

	arg0 = (*C.GtkLabel)(self.Native())

	ret := C.gtk_label_get_max_width_chars(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// MnemonicKeyval: if the label has been set so that it has a mnemonic key
// this function returns the keyval used for the mnemonic accelerator. If
// there is no mnemonic set up it returns K_KEY_VoidSymbol.
func (self label) MnemonicKeyval() uint {
	var arg0 *C.GtkLabel

	arg0 = (*C.GtkLabel)(self.Native())

	ret := C.gtk_label_get_mnemonic_keyval(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// MnemonicWidget retrieves the target of the mnemonic (keyboard shortcut)
// of this label. See gtk_label_set_mnemonic_widget().
func (self label) MnemonicWidget() Widget {
	var arg0 *C.GtkLabel

	arg0 = (*C.GtkLabel)(self.Native())

	ret := C.gtk_label_get_mnemonic_widget(arg0)

	var ret0 Widget

	ret0 = WrapWidget(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Selectable gets the value set by gtk_label_set_selectable().
func (self label) Selectable() bool {
	var arg0 *C.GtkLabel

	arg0 = (*C.GtkLabel)(self.Native())

	ret := C.gtk_label_get_selectable(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// SelectionBounds gets the selected range of characters in the label,
// returning true if there’s a selection.
func (self label) SelectionBounds() (start int, end int, ok bool) {
	var arg0 *C.GtkLabel
	var arg1 *C.int // out
	var arg2 *C.int // out

	arg0 = (*C.GtkLabel)(self.Native())

	ret := C.gtk_label_get_selection_bounds(arg0, &arg1, &arg2)

	var ret0 int
	var ret1 int
	var ret2 bool

	ret0 = int(arg1)

	ret1 = int(arg2)

	ret2 = gextras.Gobool(ret)

	return ret0, ret1, ret2
}

// SingleLineMode returns whether the label is in single line mode.
func (self label) SingleLineMode() bool {
	var arg0 *C.GtkLabel

	arg0 = (*C.GtkLabel)(self.Native())

	ret := C.gtk_label_get_single_line_mode(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Text fetches the text from a label widget, as displayed on the screen.
// This does not include any embedded underlines indicating mnemonics or
// Pango markup. (See gtk_label_get_label())
func (self label) Text() string {
	var arg0 *C.GtkLabel

	arg0 = (*C.GtkLabel)(self.Native())

	ret := C.gtk_label_get_text(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// UseMarkup returns whether the label’s text is interpreted as marked up
// with the [Pango text markup language][PangoMarkupFormat]. See
// gtk_label_set_use_markup ().
func (self label) UseMarkup() bool {
	var arg0 *C.GtkLabel

	arg0 = (*C.GtkLabel)(self.Native())

	ret := C.gtk_label_get_use_markup(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// UseUnderline returns whether an embedded underline in the label indicates
// a mnemonic. See gtk_label_set_use_underline().
func (self label) UseUnderline() bool {
	var arg0 *C.GtkLabel

	arg0 = (*C.GtkLabel)(self.Native())

	ret := C.gtk_label_get_use_underline(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// WidthChars retrieves the desired width of @label, in characters. See
// gtk_label_set_width_chars().
func (self label) WidthChars() int {
	var arg0 *C.GtkLabel

	arg0 = (*C.GtkLabel)(self.Native())

	ret := C.gtk_label_get_width_chars(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Wrap returns whether lines in the label are automatically wrapped. See
// gtk_label_set_wrap().
func (self label) Wrap() bool {
	var arg0 *C.GtkLabel

	arg0 = (*C.GtkLabel)(self.Native())

	ret := C.gtk_label_get_wrap(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// WrapMode returns line wrap mode used by the label. See
// gtk_label_set_wrap_mode().
func (self label) WrapMode() pango.WrapMode {
	var arg0 *C.GtkLabel

	arg0 = (*C.GtkLabel)(self.Native())

	ret := C.gtk_label_get_wrap_mode(arg0)

	var ret0 pango.WrapMode

	ret0 = pango.WrapMode(ret)

	return ret0
}

// Xalign gets the Label:xalign property for @label.
func (self label) Xalign() float32 {
	var arg0 *C.GtkLabel

	arg0 = (*C.GtkLabel)(self.Native())

	ret := C.gtk_label_get_xalign(arg0)

	var ret0 float32

	ret0 = float32(ret)

	return ret0
}

// Yalign gets the Label:yalign property for @label.
func (self label) Yalign() float32 {
	var arg0 *C.GtkLabel

	arg0 = (*C.GtkLabel)(self.Native())

	ret := C.gtk_label_get_yalign(arg0)

	var ret0 float32

	ret0 = float32(ret)

	return ret0
}

// SelectRegion selects a range of characters in the label, if the label is
// selectable. See gtk_label_set_selectable(). If the label is not
// selectable, this function has no effect. If @start_offset or @end_offset
// are -1, then the end of the label will be substituted.
func (self label) SelectRegion(startOffset int, endOffset int) {
	var arg0 *C.GtkLabel
	var arg1 C.int
	var arg2 C.int

	arg0 = (*C.GtkLabel)(self.Native())
	arg1 = C.int(startOffset)
	arg2 = C.int(endOffset)

	C.gtk_label_select_region(arg0, arg1, arg2)
}

// SetAttributes sets a AttrList; the attributes in the list are applied to
// the label text.
//
// The attributes set with this function will be applied and merged with any
// other attributes previously effected by way of the Label:use-underline or
// Label:use-markup properties. While it is not recommended to mix markup
// strings with manually set attributes, if you must; know that the
// attributes will be applied to the label after the markup string is
// parsed.
func (self label) SetAttributes(attrs *pango.AttrList) {
	var arg0 *C.GtkLabel
	var arg1 *C.PangoAttrList

	arg0 = (*C.GtkLabel)(self.Native())
	arg1 = (*C.PangoAttrList)(attrs.Native())

	C.gtk_label_set_attributes(arg0, arg1)
}

// SetEllipsize sets the mode used to ellipsize (add an ellipsis: "...") to
// the text if there is not enough space to render the entire string.
func (self label) SetEllipsize(mode pango.EllipsizeMode) {
	var arg0 *C.GtkLabel
	var arg1 C.PangoEllipsizeMode

	arg0 = (*C.GtkLabel)(self.Native())
	arg1 = (C.PangoEllipsizeMode)(mode)

	C.gtk_label_set_ellipsize(arg0, arg1)
}

// SetExtraMenu sets a menu model to add when constructing the context menu
// for @label.
func (self label) SetExtraMenu(model gio.MenuModel) {
	var arg0 *C.GtkLabel
	var arg1 *C.GMenuModel

	arg0 = (*C.GtkLabel)(self.Native())
	arg1 = (*C.GMenuModel)(model.Native())

	C.gtk_label_set_extra_menu(arg0, arg1)
}

// SetJustify sets the alignment of the lines in the text of the label
// relative to each other. GTK_JUSTIFY_LEFT is the default value when the
// widget is first created with gtk_label_new(). If you instead want to set
// the alignment of the label as a whole, use gtk_widget_set_halign()
// instead. gtk_label_set_justify() has no effect on labels containing only
// a single line.
func (self label) SetJustify(jtype Justification) {
	var arg0 *C.GtkLabel
	var arg1 C.GtkJustification

	arg0 = (*C.GtkLabel)(self.Native())
	arg1 = (C.GtkJustification)(jtype)

	C.gtk_label_set_justify(arg0, arg1)
}

// SetLabel sets the text of the label. The label is interpreted as
// including embedded underlines and/or Pango markup depending on the values
// of the Label:use-underline and Label:use-markup properties.
func (self label) SetLabel(str string) {
	var arg0 *C.GtkLabel
	var arg1 *C.char

	arg0 = (*C.GtkLabel)(self.Native())
	arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_label_set_label(arg0, arg1)
}

// SetLines sets the number of lines to which an ellipsized, wrapping label
// should be limited. This has no effect if the label is not wrapping or
// ellipsized. Set this to -1 if you don’t want to limit the number of
// lines.
func (self label) SetLines(lines int) {
	var arg0 *C.GtkLabel
	var arg1 C.int

	arg0 = (*C.GtkLabel)(self.Native())
	arg1 = C.int(lines)

	C.gtk_label_set_lines(arg0, arg1)
}

// SetMarkup parses @str which is marked up with the [Pango text markup
// language][PangoMarkupFormat], setting the label’s text and attribute list
// based on the parse results.
//
// If the @str is external data, you may need to escape it with
// g_markup_escape_text() or g_markup_printf_escaped():
//
//    GtkWidget *self = gtk_label_new (NULL);
//    const char *str = "...";
//    const char *format = "<span style=\"italic\">\s</span>";
//    char *markup;
//
//    markup = g_markup_printf_escaped (format, str);
//    gtk_label_set_markup (GTK_LABEL (self), markup);
//    g_free (markup);
//
//
// This function will set the Label:use-markup property to true as a side
// effect.
//
// If you set the label contents using the Label:label property you should
// also ensure that you set the Label:use-markup property accordingly.
//
// See also: gtk_label_set_text()
func (self label) SetMarkup(str string) {
	var arg0 *C.GtkLabel
	var arg1 *C.char

	arg0 = (*C.GtkLabel)(self.Native())
	arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_label_set_markup(arg0, arg1)
}

// SetMarkupWithMnemonic parses @str which is marked up with the [Pango text
// markup language][PangoMarkupFormat], setting the label’s text and
// attribute list based on the parse results. If characters in @str are
// preceded by an underscore, they are underlined indicating that they
// represent a keyboard accelerator called a mnemonic.
//
// The mnemonic key can be used to activate another widget, chosen
// automatically, or explicitly using gtk_label_set_mnemonic_widget().
func (self label) SetMarkupWithMnemonic(str string) {
	var arg0 *C.GtkLabel
	var arg1 *C.char

	arg0 = (*C.GtkLabel)(self.Native())
	arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_label_set_markup_with_mnemonic(arg0, arg1)
}

// SetMaxWidthChars sets the desired maximum width in characters of @label
// to @n_chars.
func (self label) SetMaxWidthChars(nChars int) {
	var arg0 *C.GtkLabel
	var arg1 C.int

	arg0 = (*C.GtkLabel)(self.Native())
	arg1 = C.int(nChars)

	C.gtk_label_set_max_width_chars(arg0, arg1)
}

// SetMnemonicWidget: if the label has been set so that it has a mnemonic
// key (using i.e. gtk_label_set_markup_with_mnemonic(),
// gtk_label_set_text_with_mnemonic(), gtk_label_new_with_mnemonic() or the
// “use_underline” property) the label can be associated with a widget that
// is the target of the mnemonic. When the label is inside a widget (like a
// Button or a Notebook tab) it is automatically associated with the correct
// widget, but sometimes (i.e. when the target is a Entry next to the label)
// you need to set it explicitly using this function.
//
// The target widget will be accelerated by emitting the
// GtkWidget::mnemonic-activate signal on it. The default handler for this
// signal will activate the widget if there are no mnemonic collisions and
// toggle focus between the colliding widgets otherwise.
func (self label) SetMnemonicWidget(widget Widget) {
	var arg0 *C.GtkLabel
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkLabel)(self.Native())
	arg1 = (*C.GtkWidget)(widget.Native())

	C.gtk_label_set_mnemonic_widget(arg0, arg1)
}

// SetSelectable: selectable labels allow the user to select text from the
// label, for copy-and-paste.
func (self label) SetSelectable(setting bool) {
	var arg0 *C.GtkLabel
	var arg1 C.gboolean

	arg0 = (*C.GtkLabel)(self.Native())
	arg1 = gextras.Cbool(setting)

	C.gtk_label_set_selectable(arg0, arg1)
}

// SetSingleLineMode sets whether the label is in single line mode.
func (self label) SetSingleLineMode(singleLineMode bool) {
	var arg0 *C.GtkLabel
	var arg1 C.gboolean

	arg0 = (*C.GtkLabel)(self.Native())
	arg1 = gextras.Cbool(singleLineMode)

	C.gtk_label_set_single_line_mode(arg0, arg1)
}

// SetText sets the text within the Label widget. It overwrites any text
// that was there before.
//
// This function will clear any previously set mnemonic accelerators, and
// set the Label:use-underline property to false as a side effect.
//
// This function will set the Label:use-markup property to false as a side
// effect.
//
// See also: gtk_label_set_markup()
func (self label) SetText(str string) {
	var arg0 *C.GtkLabel
	var arg1 *C.char

	arg0 = (*C.GtkLabel)(self.Native())
	arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_label_set_text(arg0, arg1)
}

// SetTextWithMnemonic sets the label’s text from the string @str. If
// characters in @str are preceded by an underscore, they are underlined
// indicating that they represent a keyboard accelerator called a mnemonic.
// The mnemonic key can be used to activate another widget, chosen
// automatically, or explicitly using gtk_label_set_mnemonic_widget().
func (self label) SetTextWithMnemonic(str string) {
	var arg0 *C.GtkLabel
	var arg1 *C.char

	arg0 = (*C.GtkLabel)(self.Native())
	arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_label_set_text_with_mnemonic(arg0, arg1)
}

// SetUseMarkup sets whether the text of the label contains markup in
// [Pango’s text markup language][PangoMarkupFormat]. See
// gtk_label_set_markup().
func (self label) SetUseMarkup(setting bool) {
	var arg0 *C.GtkLabel
	var arg1 C.gboolean

	arg0 = (*C.GtkLabel)(self.Native())
	arg1 = gextras.Cbool(setting)

	C.gtk_label_set_use_markup(arg0, arg1)
}

// SetUseUnderline: if true, an underline in the text indicates the next
// character should be used for the mnemonic accelerator key.
func (self label) SetUseUnderline(setting bool) {
	var arg0 *C.GtkLabel
	var arg1 C.gboolean

	arg0 = (*C.GtkLabel)(self.Native())
	arg1 = gextras.Cbool(setting)

	C.gtk_label_set_use_underline(arg0, arg1)
}

// SetWidthChars sets the desired width in characters of @label to @n_chars.
func (self label) SetWidthChars(nChars int) {
	var arg0 *C.GtkLabel
	var arg1 C.int

	arg0 = (*C.GtkLabel)(self.Native())
	arg1 = C.int(nChars)

	C.gtk_label_set_width_chars(arg0, arg1)
}

// SetWrap toggles line wrapping within the Label widget. true makes it
// break lines if text exceeds the widget’s size. false lets the text get
// cut off by the edge of the widget if it exceeds the widget size.
//
// Note that setting line wrapping to true does not make the label wrap at
// its parent container’s width, because GTK widgets conceptually can’t make
// their requisition depend on the parent container’s size. For a label that
// wraps at a specific position, set the label’s width using
// gtk_widget_set_size_request().
func (self label) SetWrap(wrap bool) {
	var arg0 *C.GtkLabel
	var arg1 C.gboolean

	arg0 = (*C.GtkLabel)(self.Native())
	arg1 = gextras.Cbool(wrap)

	C.gtk_label_set_wrap(arg0, arg1)
}

// SetWrapMode: if line wrapping is on (see gtk_label_set_wrap()) this
// controls how the line wrapping is done. The default is PANGO_WRAP_WORD
// which means wrap on word boundaries.
func (self label) SetWrapMode(wrapMode pango.WrapMode) {
	var arg0 *C.GtkLabel
	var arg1 C.PangoWrapMode

	arg0 = (*C.GtkLabel)(self.Native())
	arg1 = (C.PangoWrapMode)(wrapMode)

	C.gtk_label_set_wrap_mode(arg0, arg1)
}

// SetXalign sets the Label:xalign property for @label.
func (self label) SetXalign(xalign float32) {
	var arg0 *C.GtkLabel
	var arg1 C.float

	arg0 = (*C.GtkLabel)(self.Native())
	arg1 = C.float(xalign)

	C.gtk_label_set_xalign(arg0, arg1)
}

// SetYalign sets the Label:yalign property for @label.
func (self label) SetYalign(yalign float32) {
	var arg0 *C.GtkLabel
	var arg1 C.float

	arg0 = (*C.GtkLabel)(self.Native())
	arg1 = C.float(yalign)

	C.gtk_label_set_yalign(arg0, arg1)
}

// LayoutChild is the base class for objects that are meant to hold layout
// properties. If a LayoutManager has per-child properties, like their packing
// type, or the horizontal and vertical span, or the icon name, then the layout
// manager should use a LayoutChild implementation to store those properties.
//
// A LayoutChild instance is only ever valid while a widget is part of a layout.
type LayoutChild interface {
	gextras.Objector

	// ChildWidget retrieves the Widget associated to the given @layout_child.
	ChildWidget() Widget
	// LayoutManager retrieves the LayoutManager instance that created the given
	// @layout_child.
	LayoutManager() LayoutManager
}

type layoutChild struct {
	*externglib.Object
}

// WrapLayoutChild wraps a GObject to the right type. It is
// primarily used internally.
func WrapLayoutChild(obj *externglib.Object) LayoutChild {
	return layoutChild{*externglib.Object{obj}}
}

func marshalLayoutChild(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapLayoutChild(obj), nil
}

// ChildWidget retrieves the Widget associated to the given @layout_child.
func (layoutChild layoutChild) ChildWidget() Widget {
	var arg0 *C.GtkLayoutChild

	arg0 = (*C.GtkLayoutChild)(layoutChild.Native())

	ret := C.gtk_layout_child_get_child_widget(arg0)

	var ret0 Widget

	ret0 = WrapWidget(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// LayoutManager retrieves the LayoutManager instance that created the given
// @layout_child.
func (layoutChild layoutChild) LayoutManager() LayoutManager {
	var arg0 *C.GtkLayoutChild

	arg0 = (*C.GtkLayoutChild)(layoutChild.Native())

	ret := C.gtk_layout_child_get_layout_manager(arg0)

	var ret0 LayoutManager

	ret0 = WrapLayoutManager(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// LayoutManager: layout managers are delegate classes that handle the preferred
// size and the allocation of a container widget.
//
// You typically subclass LayoutManager if you want to implement a layout policy
// for the children of a widget, or if you want to determine the size of a
// widget depending on its contents.
//
// Each Widget can only have a LayoutManager instance associated to it at any
// given time; it is possible, though, to replace the layout manager instance
// using gtk_widget_set_layout_manager().
//
//
// Layout properties
//
// A layout manager can expose properties for controlling the layout of each
// child, by creating an object type derived from LayoutChild and installing the
// properties on it as normal GObject properties.
//
// Each LayoutChild instance storing the layout properties for a specific child
// is created through the gtk_layout_manager_get_layout_child() method; a
// LayoutManager controls the creation of its LayoutChild instances by
// overriding the GtkLayoutManagerClass.create_layout_child() virtual function.
// The typical implementation should look like:
//
//    static GtkLayoutChild *
//    create_layout_child (GtkLayoutManager *manager,
//                         GtkWidget        *container,
//                         GtkWidget        *child)
//    {
//      return g_object_new (your_layout_child_get_type (),
//                           "layout-manager", manager,
//                           "child-widget", child,
//                           NULL);
//    }
//
//
// The LayoutChild:layout-manager and LayoutChild:child-widget properties on the
// newly created LayoutChild instance are mandatory. The LayoutManager will
// cache the newly created LayoutChild instance until the widget is removed from
// its parent, or the parent removes the layout manager.
//
// Each LayoutManager instance creating a LayoutChild should use
// gtk_layout_manager_get_layout_child() every time it needs to query the layout
// properties; each LayoutChild instance should call
// gtk_layout_manager_layout_changed() every time a property is updated, in
// order to queue a new size measuring and allocation.
type LayoutManager interface {
	gextras.Objector

	// Allocate: this function assigns the given @width, @height, and @baseline
	// to a @widget, and computes the position and sizes of the children of the
	// @widget using the layout management policy of @manager.
	Allocate(widget Widget, width int, height int, baseline int)
	// LayoutChild retrieves a LayoutChild instance for the LayoutManager,
	// creating one if necessary.
	//
	// The @child widget must be a child of the widget using @manager.
	//
	// The LayoutChild instance is owned by the LayoutManager, and is guaranteed
	// to exist as long as @child is a child of the Widget using the given
	// LayoutManager.
	LayoutChild(child Widget) LayoutChild
	// RequestMode retrieves the request mode of @manager.
	RequestMode() SizeRequestMode
	// Widget retrieves the Widget using the given LayoutManager.
	Widget() Widget
	// LayoutChanged queues a resize on the Widget using @manager, if any.
	//
	// This function should be called by subclasses of LayoutManager in response
	// to changes to their layout management policies.
	LayoutChanged()
	// Measure measures the size of the @widget using @manager, for the given
	// @orientation and size.
	//
	// See [GtkWidget's geometry management section][geometry-management] for
	// more details.
	Measure(widget Widget, orientation Orientation, forSize int) (minimum int, natural int, minimumBaseline int, naturalBaseline int)
}

type layoutManager struct {
	*externglib.Object
}

// WrapLayoutManager wraps a GObject to the right type. It is
// primarily used internally.
func WrapLayoutManager(obj *externglib.Object) LayoutManager {
	return layoutManager{*externglib.Object{obj}}
}

func marshalLayoutManager(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapLayoutManager(obj), nil
}

// Allocate: this function assigns the given @width, @height, and @baseline
// to a @widget, and computes the position and sizes of the children of the
// @widget using the layout management policy of @manager.
func (manager layoutManager) Allocate(widget Widget, width int, height int, baseline int) {
	var arg0 *C.GtkLayoutManager
	var arg1 *C.GtkWidget
	var arg2 C.int
	var arg3 C.int
	var arg4 C.int

	arg0 = (*C.GtkLayoutManager)(manager.Native())
	arg1 = (*C.GtkWidget)(widget.Native())
	arg2 = C.int(width)
	arg3 = C.int(height)
	arg4 = C.int(baseline)

	C.gtk_layout_manager_allocate(arg0, arg1, arg2, arg3, arg4)
}

// LayoutChild retrieves a LayoutChild instance for the LayoutManager,
// creating one if necessary.
//
// The @child widget must be a child of the widget using @manager.
//
// The LayoutChild instance is owned by the LayoutManager, and is guaranteed
// to exist as long as @child is a child of the Widget using the given
// LayoutManager.
func (manager layoutManager) LayoutChild(child Widget) LayoutChild {
	var arg0 *C.GtkLayoutManager
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkLayoutManager)(manager.Native())
	arg1 = (*C.GtkWidget)(child.Native())

	ret := C.gtk_layout_manager_get_layout_child(arg0, arg1)

	var ret0 LayoutChild

	ret0 = WrapLayoutChild(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// RequestMode retrieves the request mode of @manager.
func (manager layoutManager) RequestMode() SizeRequestMode {
	var arg0 *C.GtkLayoutManager

	arg0 = (*C.GtkLayoutManager)(manager.Native())

	ret := C.gtk_layout_manager_get_request_mode(arg0)

	var ret0 SizeRequestMode

	ret0 = SizeRequestMode(ret)

	return ret0
}

// Widget retrieves the Widget using the given LayoutManager.
func (manager layoutManager) Widget() Widget {
	var arg0 *C.GtkLayoutManager

	arg0 = (*C.GtkLayoutManager)(manager.Native())

	ret := C.gtk_layout_manager_get_widget(arg0)

	var ret0 Widget

	ret0 = WrapWidget(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// LayoutChanged queues a resize on the Widget using @manager, if any.
//
// This function should be called by subclasses of LayoutManager in response
// to changes to their layout management policies.
func (manager layoutManager) LayoutChanged() {
	var arg0 *C.GtkLayoutManager

	arg0 = (*C.GtkLayoutManager)(manager.Native())

	C.gtk_layout_manager_layout_changed(arg0)
}

// Measure measures the size of the @widget using @manager, for the given
// @orientation and size.
//
// See [GtkWidget's geometry management section][geometry-management] for
// more details.
func (manager layoutManager) Measure(widget Widget, orientation Orientation, forSize int) (minimum int, natural int, minimumBaseline int, naturalBaseline int) {
	var arg0 *C.GtkLayoutManager
	var arg1 *C.GtkWidget
	var arg2 C.GtkOrientation
	var arg3 C.int
	var arg4 *C.int // out
	var arg5 *C.int // out
	var arg6 *C.int // out
	var arg7 *C.int // out

	arg0 = (*C.GtkLayoutManager)(manager.Native())
	arg1 = (*C.GtkWidget)(widget.Native())
	arg2 = (C.GtkOrientation)(orientation)
	arg3 = C.int(forSize)

	ret := C.gtk_layout_manager_measure(arg0, arg1, arg2, arg3, &arg4, &arg5, &arg6, &arg7)

	var ret0 int
	var ret1 int
	var ret2 int
	var ret3 int

	ret0 = int(arg4)

	ret1 = int(arg5)

	ret2 = int(arg6)

	ret3 = int(arg7)

	return ret0, ret1, ret2, ret3
}

// LevelBar: the LevelBar is a bar widget that can be used as a level indicator.
// Typical use cases are displaying the strength of a password, or showing the
// charge level of a battery.
//
// Use gtk_level_bar_set_value() to set the current value, and
// gtk_level_bar_add_offset_value() to set the value offsets at which the bar
// will be considered in a different state. GTK will add a few offsets by
// default on the level bar: K_LEVEL_BAR_OFFSET_LOW, K_LEVEL_BAR_OFFSET_HIGH and
// K_LEVEL_BAR_OFFSET_FULL, with values 0.25, 0.75 and 1.0 respectively.
//
// Note that it is your responsibility to update preexisting offsets when
// changing the minimum or maximum value. GTK will simply clamp them to the new
// range.
//
// Adding a custom offset on the bar
//
//    levelbar[.discrete]
//    ╰── trough
//        ├── block.filled.level-name
//        ┊
//        ├── block.empty
//        ┊
//
//
// GtkLevelBar has a main CSS node with name levelbar and one of the style
// classes .discrete or .continuous and a subnode with name trough. Below the
// trough node are a number of nodes with name block and style class .filled or
// .empty. In continuous mode, there is exactly one node of each, in discrete
// mode, the number of filled and unfilled nodes corresponds to blocks that are
// drawn. The block.filled nodes also get a style class .level-name
// corresponding to the level for the current value.
//
// In horizontal orientation, the nodes are always arranged from left to right,
// regardless of text direction.
//
//
// Accessibility
//
// GtkLevelBar uses the K_ACCESSIBLE_ROLE_METER role.
type LevelBar interface {
	Widget

	// AddOffsetValue adds a new offset marker on @self at the position
	// specified by @value. When the bar value is in the interval topped by
	// @value (or between @value and LevelBar:max-value in case the offset is
	// the last one on the bar) a style class named `level-`@name will be
	// applied when rendering the level bar fill. If another offset marker named
	// @name exists, its value will be replaced by @value.
	AddOffsetValue(name string, value float64)
	// Inverted: return the value of the LevelBar:inverted property.
	Inverted() bool
	// MaxValue returns the value of the LevelBar:max-value property.
	MaxValue() float64
	// MinValue returns the value of the LevelBar:min-value property.
	MinValue() float64
	// Mode returns the value of the LevelBar:mode property.
	Mode() LevelBarMode
	// OffsetValue fetches the value specified for the offset marker @name in
	// @self, returning true in case an offset named @name was found.
	OffsetValue(name string) (value float64, ok bool)
	// Value returns the value of the LevelBar:value property.
	Value() float64
	// RemoveOffsetValue removes an offset marker previously added with
	// gtk_level_bar_add_offset_value().
	RemoveOffsetValue(name string)
	// SetInverted sets the value of the LevelBar:inverted property.
	SetInverted(inverted bool)
	// SetMaxValue sets the value of the LevelBar:max-value property.
	//
	// You probably want to update preexisting level offsets after calling this
	// function.
	SetMaxValue(value float64)
	// SetMinValue sets the value of the LevelBar:min-value property.
	//
	// You probably want to update preexisting level offsets after calling this
	// function.
	SetMinValue(value float64)
	// SetMode sets the value of the LevelBar:mode property.
	SetMode(mode LevelBarMode)
	// SetValue sets the value of the LevelBar:value property.
	SetValue(value float64)
}

type levelBar struct {
	widget
}

// WrapLevelBar wraps a GObject to the right type. It is
// primarily used internally.
func WrapLevelBar(obj *externglib.Object) LevelBar {
	return levelBar{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}
}

func marshalLevelBar(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapLevelBar(obj), nil
}

// NewLevelBar constructs a class LevelBar.
func NewLevelBar() LevelBar {

	ret := C.gtk_level_bar_new()

	var ret0 LevelBar

	ret0 = WrapLevelBar(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewLevelBarForInterval constructs a class LevelBar.
func NewLevelBarForInterval(minValue float64, maxValue float64) LevelBar {
	var arg1 C.double
	var arg2 C.double

	arg1 = C.double(minValue)
	arg2 = C.double(maxValue)

	ret := C.gtk_level_bar_new_for_interval(arg1, arg2)

	var ret0 LevelBar

	ret0 = WrapLevelBar(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// AddOffsetValue adds a new offset marker on @self at the position
// specified by @value. When the bar value is in the interval topped by
// @value (or between @value and LevelBar:max-value in case the offset is
// the last one on the bar) a style class named `level-`@name will be
// applied when rendering the level bar fill. If another offset marker named
// @name exists, its value will be replaced by @value.
func (self levelBar) AddOffsetValue(name string, value float64) {
	var arg0 *C.GtkLevelBar
	var arg1 *C.char
	var arg2 C.double

	arg0 = (*C.GtkLevelBar)(self.Native())
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.double(value)

	C.gtk_level_bar_add_offset_value(arg0, arg1, arg2)
}

// Inverted: return the value of the LevelBar:inverted property.
func (self levelBar) Inverted() bool {
	var arg0 *C.GtkLevelBar

	arg0 = (*C.GtkLevelBar)(self.Native())

	ret := C.gtk_level_bar_get_inverted(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// MaxValue returns the value of the LevelBar:max-value property.
func (self levelBar) MaxValue() float64 {
	var arg0 *C.GtkLevelBar

	arg0 = (*C.GtkLevelBar)(self.Native())

	ret := C.gtk_level_bar_get_max_value(arg0)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// MinValue returns the value of the LevelBar:min-value property.
func (self levelBar) MinValue() float64 {
	var arg0 *C.GtkLevelBar

	arg0 = (*C.GtkLevelBar)(self.Native())

	ret := C.gtk_level_bar_get_min_value(arg0)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// Mode returns the value of the LevelBar:mode property.
func (self levelBar) Mode() LevelBarMode {
	var arg0 *C.GtkLevelBar

	arg0 = (*C.GtkLevelBar)(self.Native())

	ret := C.gtk_level_bar_get_mode(arg0)

	var ret0 LevelBarMode

	ret0 = LevelBarMode(ret)

	return ret0
}

// OffsetValue fetches the value specified for the offset marker @name in
// @self, returning true in case an offset named @name was found.
func (self levelBar) OffsetValue(name string) (value float64, ok bool) {
	var arg0 *C.GtkLevelBar
	var arg1 *C.char
	var arg2 *C.double // out

	arg0 = (*C.GtkLevelBar)(self.Native())
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_level_bar_get_offset_value(arg0, arg1, &arg2)

	var ret0 float64
	var ret1 bool

	ret0 = float64(arg2)

	ret1 = gextras.Gobool(ret)

	return ret0, ret1
}

// Value returns the value of the LevelBar:value property.
func (self levelBar) Value() float64 {
	var arg0 *C.GtkLevelBar

	arg0 = (*C.GtkLevelBar)(self.Native())

	ret := C.gtk_level_bar_get_value(arg0)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// RemoveOffsetValue removes an offset marker previously added with
// gtk_level_bar_add_offset_value().
func (self levelBar) RemoveOffsetValue(name string) {
	var arg0 *C.GtkLevelBar
	var arg1 *C.char

	arg0 = (*C.GtkLevelBar)(self.Native())
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_level_bar_remove_offset_value(arg0, arg1)
}

// SetInverted sets the value of the LevelBar:inverted property.
func (self levelBar) SetInverted(inverted bool) {
	var arg0 *C.GtkLevelBar
	var arg1 C.gboolean

	arg0 = (*C.GtkLevelBar)(self.Native())
	arg1 = gextras.Cbool(inverted)

	C.gtk_level_bar_set_inverted(arg0, arg1)
}

// SetMaxValue sets the value of the LevelBar:max-value property.
//
// You probably want to update preexisting level offsets after calling this
// function.
func (self levelBar) SetMaxValue(value float64) {
	var arg0 *C.GtkLevelBar
	var arg1 C.double

	arg0 = (*C.GtkLevelBar)(self.Native())
	arg1 = C.double(value)

	C.gtk_level_bar_set_max_value(arg0, arg1)
}

// SetMinValue sets the value of the LevelBar:min-value property.
//
// You probably want to update preexisting level offsets after calling this
// function.
func (self levelBar) SetMinValue(value float64) {
	var arg0 *C.GtkLevelBar
	var arg1 C.double

	arg0 = (*C.GtkLevelBar)(self.Native())
	arg1 = C.double(value)

	C.gtk_level_bar_set_min_value(arg0, arg1)
}

// SetMode sets the value of the LevelBar:mode property.
func (self levelBar) SetMode(mode LevelBarMode) {
	var arg0 *C.GtkLevelBar
	var arg1 C.GtkLevelBarMode

	arg0 = (*C.GtkLevelBar)(self.Native())
	arg1 = (C.GtkLevelBarMode)(mode)

	C.gtk_level_bar_set_mode(arg0, arg1)
}

// SetValue sets the value of the LevelBar:value property.
func (self levelBar) SetValue(value float64) {
	var arg0 *C.GtkLevelBar
	var arg1 C.double

	arg0 = (*C.GtkLevelBar)(self.Native())
	arg1 = C.double(value)

	C.gtk_level_bar_set_value(arg0, arg1)
}

// LinkButton: a GtkLinkButton is a Button with a hyperlink, similar to the one
// used by web browsers, which triggers an action when clicked. It is useful to
// show quick links to resources.
//
// A link button is created by calling either gtk_link_button_new() or
// gtk_link_button_new_with_label(). If using the former, the URI you pass to
// the constructor is used as a label for the widget.
//
// The URI bound to a GtkLinkButton can be set specifically using
// gtk_link_button_set_uri(), and retrieved using gtk_link_button_get_uri().
//
// By default, GtkLinkButton calls gtk_show_uri() when the button is clicked.
// This behaviour can be overridden by connecting to the
// LinkButton::activate-link signal and returning true from the signal handler.
//
//
// CSS nodes
//
// GtkLinkButton has a single CSS node with name button. To differentiate it
// from a plain Button, it gets the .link style class.
//
//
// Accessibility
//
// GtkLinkButton uses the K_ACCESSIBLE_ROLE_LINK role.
type LinkButton interface {
	Button

	// URI retrieves the URI set using gtk_link_button_set_uri().
	URI() string
	// Visited retrieves the “visited” state of the URI where the LinkButton
	// points. The button becomes visited when it is clicked. If the URI is
	// changed on the button, the “visited” state is unset again.
	//
	// The state may also be changed using gtk_link_button_set_visited().
	Visited() bool
	// SetURI sets @uri as the URI where the LinkButton points. As a side-effect
	// this unsets the “visited” state of the button.
	SetURI(uri string)
	// SetVisited sets the “visited” state of the URI where the LinkButton
	// points. See gtk_link_button_get_visited() for more details.
	SetVisited(visited bool)
}

type linkButton struct {
	button
}

// WrapLinkButton wraps a GObject to the right type. It is
// primarily used internally.
func WrapLinkButton(obj *externglib.Object) LinkButton {
	return linkButton{button{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}}
}

func marshalLinkButton(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapLinkButton(obj), nil
}

// NewLinkButton constructs a class LinkButton.
func NewLinkButton(uri string) LinkButton {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_link_button_new(arg1)

	var ret0 LinkButton

	ret0 = WrapLinkButton(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewLinkButtonWithLabel constructs a class LinkButton.
func NewLinkButtonWithLabel(uri string, label string) LinkButton {
	var arg1 *C.char
	var arg2 *C.char

	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.gtk_link_button_new_with_label(arg1, arg2)

	var ret0 LinkButton

	ret0 = WrapLinkButton(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// URI retrieves the URI set using gtk_link_button_set_uri().
func (linkButton linkButton) URI() string {
	var arg0 *C.GtkLinkButton

	arg0 = (*C.GtkLinkButton)(linkButton.Native())

	ret := C.gtk_link_button_get_uri(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Visited retrieves the “visited” state of the URI where the LinkButton
// points. The button becomes visited when it is clicked. If the URI is
// changed on the button, the “visited” state is unset again.
//
// The state may also be changed using gtk_link_button_set_visited().
func (linkButton linkButton) Visited() bool {
	var arg0 *C.GtkLinkButton

	arg0 = (*C.GtkLinkButton)(linkButton.Native())

	ret := C.gtk_link_button_get_visited(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// SetURI sets @uri as the URI where the LinkButton points. As a side-effect
// this unsets the “visited” state of the button.
func (linkButton linkButton) SetURI(uri string) {
	var arg0 *C.GtkLinkButton
	var arg1 *C.char

	arg0 = (*C.GtkLinkButton)(linkButton.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_link_button_set_uri(arg0, arg1)
}

// SetVisited sets the “visited” state of the URI where the LinkButton
// points. See gtk_link_button_get_visited() for more details.
func (linkButton linkButton) SetVisited(visited bool) {
	var arg0 *C.GtkLinkButton
	var arg1 C.gboolean

	arg0 = (*C.GtkLinkButton)(linkButton.Native())
	arg1 = gextras.Cbool(visited)

	C.gtk_link_button_set_visited(arg0, arg1)
}

// ListBase: gtkListBase is the abstract base class for GTK's list widgets.
type ListBase interface {
	Widget
}

type listBase struct {
	widget
}

// WrapListBase wraps a GObject to the right type. It is
// primarily used internally.
func WrapListBase(obj *externglib.Object) ListBase {
	return listBase{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}
}

func marshalListBase(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapListBase(obj), nil
}

// ListBox: a GtkListBox is a vertical container that contains GtkListBoxRow
// children. These rows can by dynamically sorted and filtered, and headers can
// be added dynamically depending on the row content. It also allows keyboard
// and mouse navigation and selection like a typical list.
//
// Using GtkListBox is often an alternative to TreeView, especially when the
// list contents has a more complicated layout than what is allowed by a
// CellRenderer, or when the contents is interactive (i.e. has a button in it).
//
// Although a ListBox must have only ListBoxRow children you can add any kind of
// widget to it via gtk_list_box_prepend(), gtk_list_box_append() and
// gtk_list_box_insert() and a ListBoxRow widget will automatically be inserted
// between the list and the widget.
//
// ListBoxRows can be marked as activatable or selectable. If a row is
// activatable, ListBox::row-activated will be emitted for it when the user
// tries to activate it. If it is selectable, the row will be marked as selected
// when the user tries to select it.
//
//
// GtkListBox as GtkBuildable
//
// The GtkListBox implementation of the Buildable interface supports setting a
// child as the placeholder by specifying “placeholder” as the “type” attribute
// of a <child> element. See gtk_list_box_set_placeholder() for info.
//
// CSS nodes
//
//    list[.separators][.rich-list][.navigation-sidebar]
//    ╰── row[.activatable]
//
//
// GtkListBox uses a single CSS node named list. It may carry the .separators
// style class, when the ListBox:show-separators property is set. Each
// GtkListBoxRow uses a single CSS node named row. The row nodes get the
// .activatable style class added when appropriate.
//
// The main list node may also carry style classes to select the style of list
// presentation (ListContainers.html#list-styles): .rich-list,
// .navigation-sidebar or .data-table.
//
//
// Accessibility
//
// GtkListBox uses the K_ACCESSIBLE_ROLE_LIST role and GtkListBoxRow uses the
// K_ACCESSIBLE_ROLE_LIST_ITEM role.
type ListBox interface {
	Widget

	// Append: append a widget to the list. If a sort function is set, the
	// widget will actually be inserted at the calculated position.
	Append(child Widget)
	// BindModel binds @model to @box.
	//
	// If @box was already bound to a model, that previous binding is destroyed.
	//
	// The contents of @box are cleared and then filled with widgets that
	// represent items from @model. @box is updated whenever @model changes. If
	// @model is nil, @box is left empty.
	//
	// It is undefined to add or remove widgets directly (for example, with
	// gtk_list_box_insert()) while @box is bound to a model.
	//
	// Note that using a model is incompatible with the filtering and sorting
	// functionality in GtkListBox. When using a model, filtering and sorting
	// should be implemented by the model.
	BindModel(model gio.ListModel, createWidgetFunc ListBoxCreateWidgetFunc)
	// DragHighlightRow: this is a helper function for implementing DnD onto a
	// ListBox. The passed in @row will be highlighted by setting the
	// K_STATE_FLAG_DROP_ACTIVE state and any previously highlighted row will be
	// unhighlighted.
	//
	// The row will also be unhighlighted when the widget gets a drag leave
	// event.
	DragHighlightRow(row ListBoxRow)
	// DragUnhighlightRow: if a row has previously been highlighted via
	// gtk_list_box_drag_highlight_row() it will have the highlight removed.
	DragUnhighlightRow()
	// ActivateOnSingleClick returns whether rows activate on single clicks.
	ActivateOnSingleClick() bool
	// Adjustment gets the adjustment (if any) that the widget uses to for
	// vertical scrolling.
	Adjustment() Adjustment
	// RowAtIndex gets the n-th child in the list (not counting headers). If
	// @_index is negative or larger than the number of items in the list, nil
	// is returned.
	RowAtIndex(index_ int) ListBoxRow
	// RowAtY gets the row at the @y position.
	RowAtY(y int) ListBoxRow
	// SelectedRow gets the selected row.
	//
	// Note that the box may allow multiple selection, in which case you should
	// use gtk_list_box_selected_foreach() to find all selected rows.
	SelectedRow() ListBoxRow
	// SelectedRows creates a list of all selected children.
	SelectedRows() *glib.List
	// SelectionMode gets the selection mode of the listbox.
	SelectionMode() SelectionMode
	// ShowSeparators returns whether the list box should show separators
	// between rows.
	ShowSeparators() bool
	// Insert: insert the @child into the @box at @position. If a sort function
	// is set, the widget will actually be inserted at the calculated position.
	//
	// If @position is -1, or larger than the total number of items in the @box,
	// then the @child will be appended to the end.
	Insert(child Widget, position int)
	// InvalidateFilter: update the filtering for all rows. Call this when
	// result of the filter function on the @box is changed due to an external
	// factor. For instance, this would be used if the filter function just
	// looked for a specific search string and the entry with the search string
	// has changed.
	InvalidateFilter()
	// InvalidateHeaders: update the separators for all rows. Call this when
	// result of the header function on the @box is changed due to an external
	// factor.
	InvalidateHeaders()
	// InvalidateSort: update the sorting for all rows. Call this when result of
	// the sort function on the @box is changed due to an external factor.
	InvalidateSort()
	// Prepend: prepend a widget to the list. If a sort function is set, the
	// widget will actually be inserted at the calculated position.
	Prepend(child Widget)
	// Remove removes a child from @box.
	Remove(child Widget)
	// SelectAll: select all children of @box, if the selection mode allows it.
	SelectAll()
	// SelectRow: make @row the currently selected row.
	SelectRow(row ListBoxRow)
	// SelectedForeach calls a function for each selected child.
	//
	// Note that the selection cannot be modified from within this function.
	SelectedForeach(_func ListBoxForeachFunc)
	// SetActivateOnSingleClick: if @single is true, rows will be activated when
	// you click on them, otherwise you need to double-click.
	SetActivateOnSingleClick(single bool)
	// SetAdjustment sets the adjustment (if any) that the widget uses to for
	// vertical scrolling. For instance, this is used to get the page size for
	// PageUp/Down key handling.
	//
	// In the normal case when the @box is packed inside a ScrolledWindow the
	// adjustment from that will be picked up automatically, so there is no need
	// to manually do that.
	SetAdjustment(adjustment Adjustment)
	// SetFilterFunc: by setting a filter function on the @box one can decide
	// dynamically which of the rows to show. For instance, to implement a
	// search function on a list that filters the original list to only show the
	// matching rows.
	//
	// The @filter_func will be called for each row after the call, and it will
	// continue to be called each time a row changes (via
	// gtk_list_box_row_changed()) or when gtk_list_box_invalidate_filter() is
	// called.
	//
	// Note that using a filter function is incompatible with using a model (see
	// gtk_list_box_bind_model()).
	SetFilterFunc(filterFunc ListBoxFilterFunc)
	// SetHeaderFunc: by setting a header function on the @box one can
	// dynamically add headers in front of rows, depending on the contents of
	// the row and its position in the list. For instance, one could use it to
	// add headers in front of the first item of a new kind, in a list sorted by
	// the kind.
	//
	// The @update_header can look at the current header widget using
	// gtk_list_box_row_get_header() and either update the state of the widget
	// as needed, or set a new one using gtk_list_box_row_set_header(). If no
	// header is needed, set the header to nil.
	//
	// Note that you may get many calls @update_header to this for a particular
	// row when e.g. changing things that don’t affect the header. In this case
	// it is important for performance to not blindly replace an existing header
	// with an identical one.
	//
	// The @update_header function will be called for each row after the call,
	// and it will continue to be called each time a row changes (via
	// gtk_list_box_row_changed()) and when the row before changes (either by
	// gtk_list_box_row_changed() on the previous row, or when the previous row
	// becomes a different row). It is also called for all rows when
	// gtk_list_box_invalidate_headers() is called.
	SetHeaderFunc(updateHeader ListBoxUpdateHeaderFunc)
	// SetPlaceholder sets the placeholder widget that is shown in the list when
	// it doesn't display any visible children.
	SetPlaceholder(placeholder Widget)
	// SetSelectionMode sets how selection works in the listbox. See
	// SelectionMode for details.
	SetSelectionMode(mode SelectionMode)
	// SetShowSeparators sets whether the list box should show separators
	// between rows.
	SetShowSeparators(showSeparators bool)
	// SetSortFunc: by setting a sort function on the @box one can dynamically
	// reorder the rows of the list, based on the contents of the rows.
	//
	// The @sort_func will be called for each row after the call, and will
	// continue to be called each time a row changes (via
	// gtk_list_box_row_changed()) and when gtk_list_box_invalidate_sort() is
	// called.
	//
	// Note that using a sort function is incompatible with using a model (see
	// gtk_list_box_bind_model()).
	SetSortFunc(sortFunc ListBoxSortFunc)
	// UnselectAll: unselect all children of @box, if the selection mode allows
	// it.
	UnselectAll()
	// UnselectRow unselects a single row of @box, if the selection mode allows
	// it.
	UnselectRow(row ListBoxRow)
}

type listBox struct {
	widget
}

// WrapListBox wraps a GObject to the right type. It is
// primarily used internally.
func WrapListBox(obj *externglib.Object) ListBox {
	return listBox{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}
}

func marshalListBox(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapListBox(obj), nil
}

// NewListBox constructs a class ListBox.
func NewListBox() ListBox {

	ret := C.gtk_list_box_new()

	var ret0 ListBox

	ret0 = WrapListBox(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Append: append a widget to the list. If a sort function is set, the
// widget will actually be inserted at the calculated position.
func (box listBox) Append(child Widget) {
	var arg0 *C.GtkListBox
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkListBox)(box.Native())
	arg1 = (*C.GtkWidget)(child.Native())

	C.gtk_list_box_append(arg0, arg1)
}

// BindModel binds @model to @box.
//
// If @box was already bound to a model, that previous binding is destroyed.
//
// The contents of @box are cleared and then filled with widgets that
// represent items from @model. @box is updated whenever @model changes. If
// @model is nil, @box is left empty.
//
// It is undefined to add or remove widgets directly (for example, with
// gtk_list_box_insert()) while @box is bound to a model.
//
// Note that using a model is incompatible with the filtering and sorting
// functionality in GtkListBox. When using a model, filtering and sorting
// should be implemented by the model.
func (box listBox) BindModel(model gio.ListModel, createWidgetFunc ListBoxCreateWidgetFunc) {
	var arg0 *C.GtkListBox
	var arg1 *C.GListModel
	var arg2 C.GtkListBoxCreateWidgetFunc
	arg3 := C.gpointer(box.Assign(userData))

	arg0 = (*C.GtkListBox)(box.Native())
	arg2 = (*[0]byte)(C.gotk4_ListBoxCreateWidgetFunc)

	C.gtk_list_box_bind_model(arg0, arg1, arg2, (*[0]byte)(C.callbackDelete))
}

// DragHighlightRow: this is a helper function for implementing DnD onto a
// ListBox. The passed in @row will be highlighted by setting the
// K_STATE_FLAG_DROP_ACTIVE state and any previously highlighted row will be
// unhighlighted.
//
// The row will also be unhighlighted when the widget gets a drag leave
// event.
func (box listBox) DragHighlightRow(row ListBoxRow) {
	var arg0 *C.GtkListBox
	var arg1 *C.GtkListBoxRow

	arg0 = (*C.GtkListBox)(box.Native())
	arg1 = (*C.GtkListBoxRow)(row.Native())

	C.gtk_list_box_drag_highlight_row(arg0, arg1)
}

// DragUnhighlightRow: if a row has previously been highlighted via
// gtk_list_box_drag_highlight_row() it will have the highlight removed.
func (box listBox) DragUnhighlightRow() {
	var arg0 *C.GtkListBox

	arg0 = (*C.GtkListBox)(box.Native())

	C.gtk_list_box_drag_unhighlight_row(arg0)
}

// ActivateOnSingleClick returns whether rows activate on single clicks.
func (box listBox) ActivateOnSingleClick() bool {
	var arg0 *C.GtkListBox

	arg0 = (*C.GtkListBox)(box.Native())

	ret := C.gtk_list_box_get_activate_on_single_click(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Adjustment gets the adjustment (if any) that the widget uses to for
// vertical scrolling.
func (box listBox) Adjustment() Adjustment {
	var arg0 *C.GtkListBox

	arg0 = (*C.GtkListBox)(box.Native())

	ret := C.gtk_list_box_get_adjustment(arg0)

	var ret0 Adjustment

	ret0 = WrapAdjustment(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// RowAtIndex gets the n-th child in the list (not counting headers). If
// @_index is negative or larger than the number of items in the list, nil
// is returned.
func (box listBox) RowAtIndex(index_ int) ListBoxRow {
	var arg0 *C.GtkListBox
	var arg1 C.int

	arg0 = (*C.GtkListBox)(box.Native())
	arg1 = C.int(index_)

	ret := C.gtk_list_box_get_row_at_index(arg0, arg1)

	var ret0 ListBoxRow

	ret0 = WrapListBoxRow(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// RowAtY gets the row at the @y position.
func (box listBox) RowAtY(y int) ListBoxRow {
	var arg0 *C.GtkListBox
	var arg1 C.int

	arg0 = (*C.GtkListBox)(box.Native())
	arg1 = C.int(y)

	ret := C.gtk_list_box_get_row_at_y(arg0, arg1)

	var ret0 ListBoxRow

	ret0 = WrapListBoxRow(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// SelectedRow gets the selected row.
//
// Note that the box may allow multiple selection, in which case you should
// use gtk_list_box_selected_foreach() to find all selected rows.
func (box listBox) SelectedRow() ListBoxRow {
	var arg0 *C.GtkListBox

	arg0 = (*C.GtkListBox)(box.Native())

	ret := C.gtk_list_box_get_selected_row(arg0)

	var ret0 ListBoxRow

	ret0 = WrapListBoxRow(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// SelectedRows creates a list of all selected children.
func (box listBox) SelectedRows() *glib.List {
	var arg0 *C.GtkListBox

	arg0 = (*C.GtkListBox)(box.Native())

	ret := C.gtk_list_box_get_selected_rows(arg0)

	var ret0 *glib.List

	ret0 = glib.WrapList(ret)

	return ret0
}

// SelectionMode gets the selection mode of the listbox.
func (box listBox) SelectionMode() SelectionMode {
	var arg0 *C.GtkListBox

	arg0 = (*C.GtkListBox)(box.Native())

	ret := C.gtk_list_box_get_selection_mode(arg0)

	var ret0 SelectionMode

	ret0 = SelectionMode(ret)

	return ret0
}

// ShowSeparators returns whether the list box should show separators
// between rows.
func (box listBox) ShowSeparators() bool {
	var arg0 *C.GtkListBox

	arg0 = (*C.GtkListBox)(box.Native())

	ret := C.gtk_list_box_get_show_separators(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Insert: insert the @child into the @box at @position. If a sort function
// is set, the widget will actually be inserted at the calculated position.
//
// If @position is -1, or larger than the total number of items in the @box,
// then the @child will be appended to the end.
func (box listBox) Insert(child Widget, position int) {
	var arg0 *C.GtkListBox
	var arg1 *C.GtkWidget
	var arg2 C.int

	arg0 = (*C.GtkListBox)(box.Native())
	arg1 = (*C.GtkWidget)(child.Native())
	arg2 = C.int(position)

	C.gtk_list_box_insert(arg0, arg1, arg2)
}

// InvalidateFilter: update the filtering for all rows. Call this when
// result of the filter function on the @box is changed due to an external
// factor. For instance, this would be used if the filter function just
// looked for a specific search string and the entry with the search string
// has changed.
func (box listBox) InvalidateFilter() {
	var arg0 *C.GtkListBox

	arg0 = (*C.GtkListBox)(box.Native())

	C.gtk_list_box_invalidate_filter(arg0)
}

// InvalidateHeaders: update the separators for all rows. Call this when
// result of the header function on the @box is changed due to an external
// factor.
func (box listBox) InvalidateHeaders() {
	var arg0 *C.GtkListBox

	arg0 = (*C.GtkListBox)(box.Native())

	C.gtk_list_box_invalidate_headers(arg0)
}

// InvalidateSort: update the sorting for all rows. Call this when result of
// the sort function on the @box is changed due to an external factor.
func (box listBox) InvalidateSort() {
	var arg0 *C.GtkListBox

	arg0 = (*C.GtkListBox)(box.Native())

	C.gtk_list_box_invalidate_sort(arg0)
}

// Prepend: prepend a widget to the list. If a sort function is set, the
// widget will actually be inserted at the calculated position.
func (box listBox) Prepend(child Widget) {
	var arg0 *C.GtkListBox
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkListBox)(box.Native())
	arg1 = (*C.GtkWidget)(child.Native())

	C.gtk_list_box_prepend(arg0, arg1)
}

// Remove removes a child from @box.
func (box listBox) Remove(child Widget) {
	var arg0 *C.GtkListBox
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkListBox)(box.Native())
	arg1 = (*C.GtkWidget)(child.Native())

	C.gtk_list_box_remove(arg0, arg1)
}

// SelectAll: select all children of @box, if the selection mode allows it.
func (box listBox) SelectAll() {
	var arg0 *C.GtkListBox

	arg0 = (*C.GtkListBox)(box.Native())

	C.gtk_list_box_select_all(arg0)
}

// SelectRow: make @row the currently selected row.
func (box listBox) SelectRow(row ListBoxRow) {
	var arg0 *C.GtkListBox
	var arg1 *C.GtkListBoxRow

	arg0 = (*C.GtkListBox)(box.Native())
	arg1 = (*C.GtkListBoxRow)(row.Native())

	C.gtk_list_box_select_row(arg0, arg1)
}

// SelectedForeach calls a function for each selected child.
//
// Note that the selection cannot be modified from within this function.
func (box listBox) SelectedForeach(_func ListBoxForeachFunc) {
	var arg0 *C.GtkListBox
	var arg1 C.GtkListBoxForeachFunc
	arg2 := C.gpointer(box.Assign(data))

	arg0 = (*C.GtkListBox)(box.Native())
	arg1 = (*[0]byte)(C.gotk4_ListBoxForeachFunc)

	C.gtk_list_box_selected_foreach(arg0, arg1)
}

// SetActivateOnSingleClick: if @single is true, rows will be activated when
// you click on them, otherwise you need to double-click.
func (box listBox) SetActivateOnSingleClick(single bool) {
	var arg0 *C.GtkListBox
	var arg1 C.gboolean

	arg0 = (*C.GtkListBox)(box.Native())
	arg1 = gextras.Cbool(single)

	C.gtk_list_box_set_activate_on_single_click(arg0, arg1)
}

// SetAdjustment sets the adjustment (if any) that the widget uses to for
// vertical scrolling. For instance, this is used to get the page size for
// PageUp/Down key handling.
//
// In the normal case when the @box is packed inside a ScrolledWindow the
// adjustment from that will be picked up automatically, so there is no need
// to manually do that.
func (box listBox) SetAdjustment(adjustment Adjustment) {
	var arg0 *C.GtkListBox
	var arg1 *C.GtkAdjustment

	arg0 = (*C.GtkListBox)(box.Native())
	arg1 = (*C.GtkAdjustment)(adjustment.Native())

	C.gtk_list_box_set_adjustment(arg0, arg1)
}

// SetFilterFunc: by setting a filter function on the @box one can decide
// dynamically which of the rows to show. For instance, to implement a
// search function on a list that filters the original list to only show the
// matching rows.
//
// The @filter_func will be called for each row after the call, and it will
// continue to be called each time a row changes (via
// gtk_list_box_row_changed()) or when gtk_list_box_invalidate_filter() is
// called.
//
// Note that using a filter function is incompatible with using a model (see
// gtk_list_box_bind_model()).
func (box listBox) SetFilterFunc(filterFunc ListBoxFilterFunc) {
	var arg0 *C.GtkListBox
	var arg1 C.GtkListBoxFilterFunc
	arg2 := C.gpointer(box.Assign(userData))

	arg0 = (*C.GtkListBox)(box.Native())
	arg1 = (*[0]byte)(C.gotk4_ListBoxFilterFunc)

	C.gtk_list_box_set_filter_func(arg0, arg1, (*[0]byte)(C.callbackDelete))
}

// SetHeaderFunc: by setting a header function on the @box one can
// dynamically add headers in front of rows, depending on the contents of
// the row and its position in the list. For instance, one could use it to
// add headers in front of the first item of a new kind, in a list sorted by
// the kind.
//
// The @update_header can look at the current header widget using
// gtk_list_box_row_get_header() and either update the state of the widget
// as needed, or set a new one using gtk_list_box_row_set_header(). If no
// header is needed, set the header to nil.
//
// Note that you may get many calls @update_header to this for a particular
// row when e.g. changing things that don’t affect the header. In this case
// it is important for performance to not blindly replace an existing header
// with an identical one.
//
// The @update_header function will be called for each row after the call,
// and it will continue to be called each time a row changes (via
// gtk_list_box_row_changed()) and when the row before changes (either by
// gtk_list_box_row_changed() on the previous row, or when the previous row
// becomes a different row). It is also called for all rows when
// gtk_list_box_invalidate_headers() is called.
func (box listBox) SetHeaderFunc(updateHeader ListBoxUpdateHeaderFunc) {
	var arg0 *C.GtkListBox
	var arg1 C.GtkListBoxUpdateHeaderFunc
	arg2 := C.gpointer(box.Assign(userData))

	arg0 = (*C.GtkListBox)(box.Native())
	arg1 = (*[0]byte)(C.gotk4_ListBoxUpdateHeaderFunc)

	C.gtk_list_box_set_header_func(arg0, arg1, (*[0]byte)(C.callbackDelete))
}

// SetPlaceholder sets the placeholder widget that is shown in the list when
// it doesn't display any visible children.
func (box listBox) SetPlaceholder(placeholder Widget) {
	var arg0 *C.GtkListBox
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkListBox)(box.Native())
	arg1 = (*C.GtkWidget)(placeholder.Native())

	C.gtk_list_box_set_placeholder(arg0, arg1)
}

// SetSelectionMode sets how selection works in the listbox. See
// SelectionMode for details.
func (box listBox) SetSelectionMode(mode SelectionMode) {
	var arg0 *C.GtkListBox
	var arg1 C.GtkSelectionMode

	arg0 = (*C.GtkListBox)(box.Native())
	arg1 = (C.GtkSelectionMode)(mode)

	C.gtk_list_box_set_selection_mode(arg0, arg1)
}

// SetShowSeparators sets whether the list box should show separators
// between rows.
func (box listBox) SetShowSeparators(showSeparators bool) {
	var arg0 *C.GtkListBox
	var arg1 C.gboolean

	arg0 = (*C.GtkListBox)(box.Native())
	arg1 = gextras.Cbool(showSeparators)

	C.gtk_list_box_set_show_separators(arg0, arg1)
}

// SetSortFunc: by setting a sort function on the @box one can dynamically
// reorder the rows of the list, based on the contents of the rows.
//
// The @sort_func will be called for each row after the call, and will
// continue to be called each time a row changes (via
// gtk_list_box_row_changed()) and when gtk_list_box_invalidate_sort() is
// called.
//
// Note that using a sort function is incompatible with using a model (see
// gtk_list_box_bind_model()).
func (box listBox) SetSortFunc(sortFunc ListBoxSortFunc) {
	var arg0 *C.GtkListBox
	var arg1 C.GtkListBoxSortFunc
	arg2 := C.gpointer(box.Assign(userData))

	arg0 = (*C.GtkListBox)(box.Native())
	arg1 = (*[0]byte)(C.gotk4_ListBoxSortFunc)

	C.gtk_list_box_set_sort_func(arg0, arg1, (*[0]byte)(C.callbackDelete))
}

// UnselectAll: unselect all children of @box, if the selection mode allows
// it.
func (box listBox) UnselectAll() {
	var arg0 *C.GtkListBox

	arg0 = (*C.GtkListBox)(box.Native())

	C.gtk_list_box_unselect_all(arg0)
}

// UnselectRow unselects a single row of @box, if the selection mode allows
// it.
func (box listBox) UnselectRow(row ListBoxRow) {
	var arg0 *C.GtkListBox
	var arg1 *C.GtkListBoxRow

	arg0 = (*C.GtkListBox)(box.Native())
	arg1 = (*C.GtkListBoxRow)(row.Native())

	C.gtk_list_box_unselect_row(arg0, arg1)
}

type ListBoxRow interface {
	Widget

	// Changed marks @row as changed, causing any state that depends on this to
	// be updated. This affects sorting, filtering and headers.
	//
	// Note that calls to this method must be in sync with the data used for the
	// row functions. For instance, if the list is mirroring some external data
	// set, and *two* rows changed in the external data set then when you call
	// gtk_list_box_row_changed() on the first row the sort function must only
	// read the new data for the first of the two changed rows, otherwise the
	// resorting of the rows will be wrong.
	//
	// This generally means that if you don’t fully control the data model you
	// have to duplicate the data that affects the listbox row functions into
	// the row widgets themselves. Another alternative is to call
	// gtk_list_box_invalidate_sort() on any model change, but that is more
	// expensive.
	Changed()
	// Activatable gets the value of the ListBoxRow:activatable property for
	// this row.
	Activatable() bool
	// Child gets the child widget of @row.
	Child() Widget
	// Header returns the current header of the @row. This can be used in a
	// ListBoxUpdateHeaderFunc to see if there is a header set already, and if
	// so to update the state of it.
	Header() Widget
	// Index gets the current index of the @row in its ListBox container.
	Index() int
	// Selectable gets the value of the ListBoxRow:selectable property for this
	// row.
	Selectable() bool
	// IsSelected returns whether the child is currently selected in its ListBox
	// container.
	IsSelected() bool
	// SetActivatable: set the ListBoxRow:activatable property for this row.
	SetActivatable(activatable bool)
	// SetChild sets the child widget of @self.
	SetChild(child Widget)
	// SetHeader sets the current header of the @row. This is only allowed to be
	// called from a ListBoxUpdateHeaderFunc. It will replace any existing
	// header in the row, and be shown in front of the row in the listbox.
	SetHeader(header Widget)
	// SetSelectable: set the ListBoxRow:selectable property for this row.
	SetSelectable(selectable bool)
}

type listBoxRow struct {
	widget
}

// WrapListBoxRow wraps a GObject to the right type. It is
// primarily used internally.
func WrapListBoxRow(obj *externglib.Object) ListBoxRow {
	return listBoxRow{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}
}

func marshalListBoxRow(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapListBoxRow(obj), nil
}

// NewListBoxRow constructs a class ListBoxRow.
func NewListBoxRow() ListBoxRow {

	ret := C.gtk_list_box_row_new()

	var ret0 ListBoxRow

	ret0 = WrapListBoxRow(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Changed marks @row as changed, causing any state that depends on this to
// be updated. This affects sorting, filtering and headers.
//
// Note that calls to this method must be in sync with the data used for the
// row functions. For instance, if the list is mirroring some external data
// set, and *two* rows changed in the external data set then when you call
// gtk_list_box_row_changed() on the first row the sort function must only
// read the new data for the first of the two changed rows, otherwise the
// resorting of the rows will be wrong.
//
// This generally means that if you don’t fully control the data model you
// have to duplicate the data that affects the listbox row functions into
// the row widgets themselves. Another alternative is to call
// gtk_list_box_invalidate_sort() on any model change, but that is more
// expensive.
func (row listBoxRow) Changed() {
	var arg0 *C.GtkListBoxRow

	arg0 = (*C.GtkListBoxRow)(row.Native())

	C.gtk_list_box_row_changed(arg0)
}

// Activatable gets the value of the ListBoxRow:activatable property for
// this row.
func (row listBoxRow) Activatable() bool {
	var arg0 *C.GtkListBoxRow

	arg0 = (*C.GtkListBoxRow)(row.Native())

	ret := C.gtk_list_box_row_get_activatable(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Child gets the child widget of @row.
func (row listBoxRow) Child() Widget {
	var arg0 *C.GtkListBoxRow

	arg0 = (*C.GtkListBoxRow)(row.Native())

	ret := C.gtk_list_box_row_get_child(arg0)

	var ret0 Widget

	ret0 = WrapWidget(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Header returns the current header of the @row. This can be used in a
// ListBoxUpdateHeaderFunc to see if there is a header set already, and if
// so to update the state of it.
func (row listBoxRow) Header() Widget {
	var arg0 *C.GtkListBoxRow

	arg0 = (*C.GtkListBoxRow)(row.Native())

	ret := C.gtk_list_box_row_get_header(arg0)

	var ret0 Widget

	ret0 = WrapWidget(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Index gets the current index of the @row in its ListBox container.
func (row listBoxRow) Index() int {
	var arg0 *C.GtkListBoxRow

	arg0 = (*C.GtkListBoxRow)(row.Native())

	ret := C.gtk_list_box_row_get_index(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Selectable gets the value of the ListBoxRow:selectable property for this
// row.
func (row listBoxRow) Selectable() bool {
	var arg0 *C.GtkListBoxRow

	arg0 = (*C.GtkListBoxRow)(row.Native())

	ret := C.gtk_list_box_row_get_selectable(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// IsSelected returns whether the child is currently selected in its ListBox
// container.
func (row listBoxRow) IsSelected() bool {
	var arg0 *C.GtkListBoxRow

	arg0 = (*C.GtkListBoxRow)(row.Native())

	ret := C.gtk_list_box_row_is_selected(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// SetActivatable: set the ListBoxRow:activatable property for this row.
func (row listBoxRow) SetActivatable(activatable bool) {
	var arg0 *C.GtkListBoxRow
	var arg1 C.gboolean

	arg0 = (*C.GtkListBoxRow)(row.Native())
	arg1 = gextras.Cbool(activatable)

	C.gtk_list_box_row_set_activatable(arg0, arg1)
}

// SetChild sets the child widget of @self.
func (row listBoxRow) SetChild(child Widget) {
	var arg0 *C.GtkListBoxRow
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkListBoxRow)(row.Native())
	arg1 = (*C.GtkWidget)(child.Native())

	C.gtk_list_box_row_set_child(arg0, arg1)
}

// SetHeader sets the current header of the @row. This is only allowed to be
// called from a ListBoxUpdateHeaderFunc. It will replace any existing
// header in the row, and be shown in front of the row in the listbox.
func (row listBoxRow) SetHeader(header Widget) {
	var arg0 *C.GtkListBoxRow
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkListBoxRow)(row.Native())
	arg1 = (*C.GtkWidget)(header.Native())

	C.gtk_list_box_row_set_header(arg0, arg1)
}

// SetSelectable: set the ListBoxRow:selectable property for this row.
func (row listBoxRow) SetSelectable(selectable bool) {
	var arg0 *C.GtkListBoxRow
	var arg1 C.gboolean

	arg0 = (*C.GtkListBoxRow)(row.Native())
	arg1 = gextras.Cbool(selectable)

	C.gtk_list_box_row_set_selectable(arg0, arg1)
}

// ListItem is the object that list-handling containers such as ListView use to
// represent items in a Model. They are managed by the container and cannot be
// created by application code.
//
// ListItems need to be populated by application code. This is done by calling
// gtk_list_item_set_child().
//
// ListItems exist in 2 stages:
//
// 1. The unbound stage where the listitem is not currently connected to an item
// in the list. In that case, the ListItem:item property is set to nil.
//
// 2. The bound stage where the listitem references an item from the list. The
// ListItem:item property is not nil.
type ListItem interface {
	gextras.Objector

	// Activatable checks if a list item has been set to be activatable via
	// gtk_list_item_set_activatable().
	Activatable() bool
	// Child gets the child previously set via gtk_list_item_set_child() or nil
	// if none was set.
	Child() Widget
	// Item gets the item that is currently displayed in model that @self is
	// currently bound to or nil if @self is unbound.
	Item() gextras.Objector
	// Position gets the position in the model that @self currently displays. If
	// @self is unbound, GTK_INVALID_LIST_POSITION is returned.
	Position() uint
	// Selectable checks if a list item has been set to be selectable via
	// gtk_list_item_set_selectable().
	//
	// Do not confuse this function with gtk_list_item_get_selected().
	Selectable() bool
	// Selected checks if the item is displayed as selected. The selected state
	// is maintained by the container and its list model and cannot be set
	// otherwise.
	Selected() bool
	// SetActivatable sets @self to be activatable.
	//
	// If an item is activatable, double-clicking on the item, using the Return
	// key or calling gtk_widget_activate() will activate the item. Activating
	// instructs the containing view to handle activation. ListView for example
	// will be emitting the ListView::activate signal.
	//
	// By default, list items are activatable
	SetActivatable(activatable bool)
	// SetChild sets the child to be used for this listitem.
	//
	// This function is typically called by applications when setting up a
	// listitem so that the widget can be reused when binding it multiple times.
	SetChild(child Widget)
	// SetSelectable sets @self to be selectable. If an item is selectable,
	// clicking on the item or using the keyboard will try to select or unselect
	// the item. If this succeeds is up to the model to determine, as it is
	// managing the selected state.
	//
	// Note that this means that making an item non-selectable has no influence
	// on the selected state at all. A non-selectable item may still be
	// selected.
	//
	// By default, list items are selectable. When rebinding them to a new item,
	// they will also be reset to be selectable by GTK.
	SetSelectable(selectable bool)
}

type listItem struct {
	*externglib.Object
}

// WrapListItem wraps a GObject to the right type. It is
// primarily used internally.
func WrapListItem(obj *externglib.Object) ListItem {
	return listItem{*externglib.Object{obj}}
}

func marshalListItem(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapListItem(obj), nil
}

// Activatable checks if a list item has been set to be activatable via
// gtk_list_item_set_activatable().
func (self listItem) Activatable() bool {
	var arg0 *C.GtkListItem

	arg0 = (*C.GtkListItem)(self.Native())

	ret := C.gtk_list_item_get_activatable(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Child gets the child previously set via gtk_list_item_set_child() or nil
// if none was set.
func (self listItem) Child() Widget {
	var arg0 *C.GtkListItem

	arg0 = (*C.GtkListItem)(self.Native())

	ret := C.gtk_list_item_get_child(arg0)

	var ret0 Widget

	ret0 = WrapWidget(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Item gets the item that is currently displayed in model that @self is
// currently bound to or nil if @self is unbound.
func (self listItem) Item() gextras.Objector {
	var arg0 *C.GtkListItem

	arg0 = (*C.GtkListItem)(self.Native())

	ret := C.gtk_list_item_get_item(arg0)

	var ret0 gextras.Objector

	ret0 = externglib.Take(unsafe.Pointer(ret.Native()))

	return ret0
}

// Position gets the position in the model that @self currently displays. If
// @self is unbound, GTK_INVALID_LIST_POSITION is returned.
func (self listItem) Position() uint {
	var arg0 *C.GtkListItem

	arg0 = (*C.GtkListItem)(self.Native())

	ret := C.gtk_list_item_get_position(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// Selectable checks if a list item has been set to be selectable via
// gtk_list_item_set_selectable().
//
// Do not confuse this function with gtk_list_item_get_selected().
func (self listItem) Selectable() bool {
	var arg0 *C.GtkListItem

	arg0 = (*C.GtkListItem)(self.Native())

	ret := C.gtk_list_item_get_selectable(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Selected checks if the item is displayed as selected. The selected state
// is maintained by the container and its list model and cannot be set
// otherwise.
func (self listItem) Selected() bool {
	var arg0 *C.GtkListItem

	arg0 = (*C.GtkListItem)(self.Native())

	ret := C.gtk_list_item_get_selected(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// SetActivatable sets @self to be activatable.
//
// If an item is activatable, double-clicking on the item, using the Return
// key or calling gtk_widget_activate() will activate the item. Activating
// instructs the containing view to handle activation. ListView for example
// will be emitting the ListView::activate signal.
//
// By default, list items are activatable
func (self listItem) SetActivatable(activatable bool) {
	var arg0 *C.GtkListItem
	var arg1 C.gboolean

	arg0 = (*C.GtkListItem)(self.Native())
	arg1 = gextras.Cbool(activatable)

	C.gtk_list_item_set_activatable(arg0, arg1)
}

// SetChild sets the child to be used for this listitem.
//
// This function is typically called by applications when setting up a
// listitem so that the widget can be reused when binding it multiple times.
func (self listItem) SetChild(child Widget) {
	var arg0 *C.GtkListItem
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkListItem)(self.Native())
	arg1 = (*C.GtkWidget)(child.Native())

	C.gtk_list_item_set_child(arg0, arg1)
}

// SetSelectable sets @self to be selectable. If an item is selectable,
// clicking on the item or using the keyboard will try to select or unselect
// the item. If this succeeds is up to the model to determine, as it is
// managing the selected state.
//
// Note that this means that making an item non-selectable has no influence
// on the selected state at all. A non-selectable item may still be
// selected.
//
// By default, list items are selectable. When rebinding them to a new item,
// they will also be reset to be selectable by GTK.
func (self listItem) SetSelectable(selectable bool) {
	var arg0 *C.GtkListItem
	var arg1 C.gboolean

	arg0 = (*C.GtkListItem)(self.Native())
	arg1 = gextras.Cbool(selectable)

	C.gtk_list_item_set_selectable(arg0, arg1)
}

// ListItemFactory is one of the core concepts of handling list widgets. It is
// the object tasked with creating widgets for items taken from a Model when the
// views need them and updating them as the items displayed by the view change.
//
// A view is usually only able to display anything after both a factory and a
// model have been set on the view. So it is important that you do not skip this
// step when setting up your first view.
//
// Because views do not display the whole list at once but only a few items,
// they only need to maintain a few widgets at a time. They will instruct the
// ListItemFactory to create these widgets and bind them to the items that are
// currently displayed. As the list model changes or the user scrolls to the
// list, the items will change and the view will instruct the factory to bind
// the widgets to those new items.
//
// The actual widgets used for displaying those widgets is provided by you.
//
// When the factory needs widgets created, it will create a ListItem and hand it
// to your code to set up a widget for. This list item will provide various
// properties with information about what item to display and provide you with
// some opportunities to configure its behavior. See the ListItem documentation
// for further details.
//
// Various implementations of ListItemFactory exist to allow you different ways
// to provide those widgets. The most common implementations are
// BuilderListItemFactory which takes a Builder .ui file and then creates
// widgets and manages everything automatically from the information in that
// file and SignalListItemFactory which allows you to connect to signals with
// your own code and retain full control over how the widgets are setup and
// managed.
//
// A ListItemFactory is supposed to be final - that means its behavior should
// not change and the first widget created from it should behave the same way as
// the last widget created from it. If you intend to do changes to the behavior,
// it is recommended that you create a new ListItemFactory which will allow the
// views to recreate its widgets.
//
// Once you have chosen your factory and created it, you need to set it on the
// view widget you want to use it with, such as via gtk_list_view_set_factory().
// Reusing factories across different views is allowed, but very uncommon.
type ListItemFactory interface {
	gextras.Objector
}

type listItemFactory struct {
	*externglib.Object
}

// WrapListItemFactory wraps a GObject to the right type. It is
// primarily used internally.
func WrapListItemFactory(obj *externglib.Object) ListItemFactory {
	return listItemFactory{*externglib.Object{obj}}
}

func marshalListItemFactory(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapListItemFactory(obj), nil
}

// ListStore: the ListStore object is a list model for use with a TreeView
// widget. It implements the TreeModel interface, and consequentialy, can use
// all of the methods available there. It also implements the TreeSortable
// interface so it can be sorted by the view. Finally, it also implements the
// tree [drag and drop][gtk4-GtkTreeView-drag-and-drop] interfaces.
//
// The ListStore can accept most GObject types as a column type, though it can’t
// accept all custom types. Internally, it will keep a copy of data passed in
// (such as a string or a boxed pointer). Columns that accept #GObjects are
// handled a little differently. The ListStore will keep a reference to the
// object instead of copying the value. As a result, if the object is modified,
// it is up to the application writer to call gtk_tree_model_row_changed() to
// emit the TreeModel::row_changed signal. This most commonly affects lists with
// Textures stored.
//
// An example for creating a simple list store:
//
//    <object class="GtkListStore">
//      <columns>
//        <column type="gchararray"/>
//        <column type="gchararray"/>
//        <column type="gint"/>
//      </columns>
//      <data>
//        <row>
//          <col id="0">John</col>
//          <col id="1">Doe</col>
//          <col id="2">25</col>
//        </row>
//        <row>
//          <col id="0">Johan</col>
//          <col id="1">Dahlin</col>
//          <col id="2">50</col>
//        </row>
//      </data>
//    </object>
//
type ListStore interface {
	gextras.Objector

	// Append appends a new row to @list_store. @iter will be changed to point
	// to this new row. The row will be empty after this function is called. To
	// fill in values, you need to call gtk_list_store_set() or
	// gtk_list_store_set_value().
	Append() TreeIter
	// Clear removes all rows from the list store.
	Clear()
	// Insert creates a new row at @position. @iter will be changed to point to
	// this new row. If @position is -1 or is larger than the number of rows on
	// the list, then the new row will be appended to the list. The row will be
	// empty after this function is called. To fill in values, you need to call
	// gtk_list_store_set() or gtk_list_store_set_value().
	Insert(position int) TreeIter
	// InsertAfter inserts a new row after @sibling. If @sibling is nil, then
	// the row will be prepended to the beginning of the list. @iter will be
	// changed to point to this new row. The row will be empty after this
	// function is called. To fill in values, you need to call
	// gtk_list_store_set() or gtk_list_store_set_value().
	InsertAfter(sibling *TreeIter) TreeIter
	// InsertBefore inserts a new row before @sibling. If @sibling is nil, then
	// the row will be appended to the end of the list. @iter will be changed to
	// point to this new row. The row will be empty after this function is
	// called. To fill in values, you need to call gtk_list_store_set() or
	// gtk_list_store_set_value().
	InsertBefore(sibling *TreeIter) TreeIter
	// InsertWithValuesv: a variant of gtk_list_store_insert_with_values() which
	// takes the columns and values as two arrays, instead of varargs. This
	// function is mainly intended for language-bindings.
	InsertWithValuesv(position int, columns []int, values []*externglib.Value) TreeIter
	// IterIsValid: > This function is slow. Only use it for debugging and/or
	// testing > purposes.
	//
	// Checks if the given iter is a valid iter for this ListStore.
	IterIsValid(iter *TreeIter) bool
	// MoveAfter moves @iter in @store to the position after @position. Note
	// that this function only works with unsorted stores. If @position is nil,
	// @iter will be moved to the start of the list.
	MoveAfter(iter *TreeIter, position *TreeIter)
	// MoveBefore moves @iter in @store to the position before @position. Note
	// that this function only works with unsorted stores. If @position is nil,
	// @iter will be moved to the end of the list.
	MoveBefore(iter *TreeIter, position *TreeIter)
	// Prepend prepends a new row to @list_store. @iter will be changed to point
	// to this new row. The row will be empty after this function is called. To
	// fill in values, you need to call gtk_list_store_set() or
	// gtk_list_store_set_value().
	Prepend() TreeIter
	// Remove removes the given row from the list store. After being removed,
	// @iter is set to be the next valid row, or invalidated if it pointed to
	// the last row in @list_store.
	Remove(iter *TreeIter) bool
	// Reorder reorders @store to follow the order indicated by @new_order. Note
	// that this function only works with unsorted stores.
	Reorder(newOrder []int)
	// SetColumnTypes: this function is meant primarily for #GObjects that
	// inherit from ListStore, and should only be used when constructing a new
	// ListStore. It will not function after a row has been added, or a method
	// on the TreeModel interface is called.
	SetColumnTypes(nColumns int, types []externglib.Type)
	// SetValue sets the data in the cell specified by @iter and @column. The
	// type of @value must be convertible to the type of the column.
	SetValue(iter *TreeIter, column int, value *externglib.Value)
	// SetValuesv: a variant of gtk_list_store_set_valist() which takes the
	// columns and values as two arrays, instead of varargs. This function is
	// mainly intended for language-bindings and in case the number of columns
	// to change is not known until run-time.
	SetValuesv(iter *TreeIter, columns []int, values []*externglib.Value)
	// Swap swaps @a and @b in @store. Note that this function only works with
	// unsorted stores.
	Swap(a *TreeIter, b *TreeIter)
}

type listStore struct {
	*externglib.Object
}

// WrapListStore wraps a GObject to the right type. It is
// primarily used internally.
func WrapListStore(obj *externglib.Object) ListStore {
	return listStore{*externglib.Object{obj}}
}

func marshalListStore(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapListStore(obj), nil
}

// NewListStoreV constructs a class ListStore.
func NewListStoreV(nColumns int, types []externglib.Type) ListStore {
	var arg1 C.int
	var arg2 *C.GType

	{
		var dst []C.GType
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(C.malloc(C.sizeof_GType * len(types))))
		sliceHeader.Len = len(types)
		sliceHeader.Cap = len(types)
		defer C.free(unsafe.Pointer(sliceHeader.Data))

		for i := 0; i < len(types); i++ {
			src := types[i]
			dst[i] = C.GType(src)
		}

		arg2 = (*C.GType)(unsafe.Pointer(sliceHeader.Data))
		arg1 = len(types)
	}

	ret := C.gtk_list_store_newv(arg1, arg2)

	var ret0 ListStore

	ret0 = WrapListStore(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Append appends a new row to @list_store. @iter will be changed to point
// to this new row. The row will be empty after this function is called. To
// fill in values, you need to call gtk_list_store_set() or
// gtk_list_store_set_value().
func (listStore listStore) Append() TreeIter {
	var arg0 *C.GtkListStore
	var arg1 *C.GtkTreeIter // out

	arg0 = (*C.GtkListStore)(listStore.Native())

	ret := C.gtk_list_store_append(arg0, &arg1)

	var ret0 *TreeIter

	ret0 = WrapTreeIter(arg1)

	return ret0
}

// Clear removes all rows from the list store.
func (listStore listStore) Clear() {
	var arg0 *C.GtkListStore

	arg0 = (*C.GtkListStore)(listStore.Native())

	C.gtk_list_store_clear(arg0)
}

// Insert creates a new row at @position. @iter will be changed to point to
// this new row. If @position is -1 or is larger than the number of rows on
// the list, then the new row will be appended to the list. The row will be
// empty after this function is called. To fill in values, you need to call
// gtk_list_store_set() or gtk_list_store_set_value().
func (listStore listStore) Insert(position int) TreeIter {
	var arg0 *C.GtkListStore
	var arg1 *C.GtkTreeIter // out
	var arg2 C.int

	arg0 = (*C.GtkListStore)(listStore.Native())
	arg2 = C.int(position)

	ret := C.gtk_list_store_insert(arg0, &arg1, arg2)

	var ret0 *TreeIter

	ret0 = WrapTreeIter(arg1)

	return ret0
}

// InsertAfter inserts a new row after @sibling. If @sibling is nil, then
// the row will be prepended to the beginning of the list. @iter will be
// changed to point to this new row. The row will be empty after this
// function is called. To fill in values, you need to call
// gtk_list_store_set() or gtk_list_store_set_value().
func (listStore listStore) InsertAfter(sibling *TreeIter) TreeIter {
	var arg0 *C.GtkListStore
	var arg1 *C.GtkTreeIter // out
	var arg2 *C.GtkTreeIter

	arg0 = (*C.GtkListStore)(listStore.Native())
	arg2 = (*C.GtkTreeIter)(sibling.Native())

	ret := C.gtk_list_store_insert_after(arg0, &arg1, arg2)

	var ret0 *TreeIter

	ret0 = WrapTreeIter(arg1)

	return ret0
}

// InsertBefore inserts a new row before @sibling. If @sibling is nil, then
// the row will be appended to the end of the list. @iter will be changed to
// point to this new row. The row will be empty after this function is
// called. To fill in values, you need to call gtk_list_store_set() or
// gtk_list_store_set_value().
func (listStore listStore) InsertBefore(sibling *TreeIter) TreeIter {
	var arg0 *C.GtkListStore
	var arg1 *C.GtkTreeIter // out
	var arg2 *C.GtkTreeIter

	arg0 = (*C.GtkListStore)(listStore.Native())
	arg2 = (*C.GtkTreeIter)(sibling.Native())

	ret := C.gtk_list_store_insert_before(arg0, &arg1, arg2)

	var ret0 *TreeIter

	ret0 = WrapTreeIter(arg1)

	return ret0
}

// InsertWithValuesv: a variant of gtk_list_store_insert_with_values() which
// takes the columns and values as two arrays, instead of varargs. This
// function is mainly intended for language-bindings.
func (listStore listStore) InsertWithValuesv(position int, columns []int, values []*externglib.Value) TreeIter {
	var arg0 *C.GtkListStore
	var arg1 *C.GtkTreeIter // out
	var arg2 C.int
	var arg3 *C.int
	var arg4 *C.GValue
	var arg5 C.int

	arg0 = (*C.GtkListStore)(listStore.Native())
	arg2 = C.int(position)
	{
		arg3 = (*C.int)(&columns[0])
		arg5 = len(columns)
		defer runtime.KeepAlive(columns)
	}
	{
		var dst []C.GValue
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(C.malloc(C.sizeof_GValue * len(values))))
		sliceHeader.Len = len(values)
		sliceHeader.Cap = len(values)
		defer C.free(unsafe.Pointer(sliceHeader.Data))

		for i := 0; i < len(values); i++ {
			src := values[i]
			dst[i] = (*C.GValue)(src.GValue)
		}

		arg4 = (*C.GValue)(unsafe.Pointer(sliceHeader.Data))
		arg5 = len(values)
	}

	ret := C.gtk_list_store_insert_with_valuesv(arg0, &arg1, arg2, arg3, arg4, arg5)

	var ret0 *TreeIter

	ret0 = WrapTreeIter(arg1)

	return ret0
}

// IterIsValid: > This function is slow. Only use it for debugging and/or
// testing > purposes.
//
// Checks if the given iter is a valid iter for this ListStore.
func (listStore listStore) IterIsValid(iter *TreeIter) bool {
	var arg0 *C.GtkListStore
	var arg1 *C.GtkTreeIter

	arg0 = (*C.GtkListStore)(listStore.Native())
	arg1 = (*C.GtkTreeIter)(iter.Native())

	ret := C.gtk_list_store_iter_is_valid(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// MoveAfter moves @iter in @store to the position after @position. Note
// that this function only works with unsorted stores. If @position is nil,
// @iter will be moved to the start of the list.
func (store listStore) MoveAfter(iter *TreeIter, position *TreeIter) {
	var arg0 *C.GtkListStore
	var arg1 *C.GtkTreeIter
	var arg2 *C.GtkTreeIter

	arg0 = (*C.GtkListStore)(store.Native())
	arg1 = (*C.GtkTreeIter)(iter.Native())
	arg2 = (*C.GtkTreeIter)(position.Native())

	C.gtk_list_store_move_after(arg0, arg1, arg2)
}

// MoveBefore moves @iter in @store to the position before @position. Note
// that this function only works with unsorted stores. If @position is nil,
// @iter will be moved to the end of the list.
func (store listStore) MoveBefore(iter *TreeIter, position *TreeIter) {
	var arg0 *C.GtkListStore
	var arg1 *C.GtkTreeIter
	var arg2 *C.GtkTreeIter

	arg0 = (*C.GtkListStore)(store.Native())
	arg1 = (*C.GtkTreeIter)(iter.Native())
	arg2 = (*C.GtkTreeIter)(position.Native())

	C.gtk_list_store_move_before(arg0, arg1, arg2)
}

// Prepend prepends a new row to @list_store. @iter will be changed to point
// to this new row. The row will be empty after this function is called. To
// fill in values, you need to call gtk_list_store_set() or
// gtk_list_store_set_value().
func (listStore listStore) Prepend() TreeIter {
	var arg0 *C.GtkListStore
	var arg1 *C.GtkTreeIter // out

	arg0 = (*C.GtkListStore)(listStore.Native())

	ret := C.gtk_list_store_prepend(arg0, &arg1)

	var ret0 *TreeIter

	ret0 = WrapTreeIter(arg1)

	return ret0
}

// Remove removes the given row from the list store. After being removed,
// @iter is set to be the next valid row, or invalidated if it pointed to
// the last row in @list_store.
func (listStore listStore) Remove(iter *TreeIter) bool {
	var arg0 *C.GtkListStore
	var arg1 *C.GtkTreeIter

	arg0 = (*C.GtkListStore)(listStore.Native())
	arg1 = (*C.GtkTreeIter)(iter.Native())

	ret := C.gtk_list_store_remove(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Reorder reorders @store to follow the order indicated by @new_order. Note
// that this function only works with unsorted stores.
func (store listStore) Reorder(newOrder []int) {
	var arg0 *C.GtkListStore
	var arg1 *C.int

	arg0 = (*C.GtkListStore)(store.Native())
	{

	}

	C.gtk_list_store_reorder(arg0, arg1)
}

// SetColumnTypes: this function is meant primarily for #GObjects that
// inherit from ListStore, and should only be used when constructing a new
// ListStore. It will not function after a row has been added, or a method
// on the TreeModel interface is called.
func (listStore listStore) SetColumnTypes(nColumns int, types []externglib.Type) {
	var arg0 *C.GtkListStore
	var arg1 C.int
	var arg2 *C.GType

	arg0 = (*C.GtkListStore)(listStore.Native())
	{
		var dst []C.GType
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(C.malloc(C.sizeof_GType * len(types))))
		sliceHeader.Len = len(types)
		sliceHeader.Cap = len(types)
		defer C.free(unsafe.Pointer(sliceHeader.Data))

		for i := 0; i < len(types); i++ {
			src := types[i]
			dst[i] = C.GType(src)
		}

		arg2 = (*C.GType)(unsafe.Pointer(sliceHeader.Data))
		arg1 = len(types)
	}

	C.gtk_list_store_set_column_types(arg0, arg1, arg2)
}

// SetValue sets the data in the cell specified by @iter and @column. The
// type of @value must be convertible to the type of the column.
func (listStore listStore) SetValue(iter *TreeIter, column int, value *externglib.Value) {
	var arg0 *C.GtkListStore
	var arg1 *C.GtkTreeIter
	var arg2 C.int
	var arg3 *C.GValue

	arg0 = (*C.GtkListStore)(listStore.Native())
	arg1 = (*C.GtkTreeIter)(iter.Native())
	arg2 = C.int(column)
	arg3 = (*C.GValue)(value.GValue)

	C.gtk_list_store_set_value(arg0, arg1, arg2, arg3)
}

// SetValuesv: a variant of gtk_list_store_set_valist() which takes the
// columns and values as two arrays, instead of varargs. This function is
// mainly intended for language-bindings and in case the number of columns
// to change is not known until run-time.
func (listStore listStore) SetValuesv(iter *TreeIter, columns []int, values []*externglib.Value) {
	var arg0 *C.GtkListStore
	var arg1 *C.GtkTreeIter
	var arg2 *C.int
	var arg3 *C.GValue
	var arg4 C.int

	arg0 = (*C.GtkListStore)(listStore.Native())
	arg1 = (*C.GtkTreeIter)(iter.Native())
	{
		arg2 = (*C.int)(&columns[0])
		arg4 = len(columns)
		defer runtime.KeepAlive(columns)
	}
	{
		var dst []C.GValue
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(C.malloc(C.sizeof_GValue * len(values))))
		sliceHeader.Len = len(values)
		sliceHeader.Cap = len(values)
		defer C.free(unsafe.Pointer(sliceHeader.Data))

		for i := 0; i < len(values); i++ {
			src := values[i]
			dst[i] = (*C.GValue)(src.GValue)
		}

		arg3 = (*C.GValue)(unsafe.Pointer(sliceHeader.Data))
		arg4 = len(values)
	}

	C.gtk_list_store_set_valuesv(arg0, arg1, arg2, arg3, arg4)
}

// Swap swaps @a and @b in @store. Note that this function only works with
// unsorted stores.
func (store listStore) Swap(a *TreeIter, b *TreeIter) {
	var arg0 *C.GtkListStore
	var arg1 *C.GtkTreeIter
	var arg2 *C.GtkTreeIter

	arg0 = (*C.GtkListStore)(store.Native())
	arg1 = (*C.GtkTreeIter)(a.Native())
	arg2 = (*C.GtkTreeIter)(b.Native())

	C.gtk_list_store_swap(arg0, arg1, arg2)
}

// ListView: gtkListView is a widget to present a view into a large dynamic list
// of items.
//
// GtkListView uses its factory to generate one row widget for each visible item
// and shows them in a linear display, either vertically or horizontally. The
// ListView:show-separators property offers a simple way to display separators
// between the rows.
//
// GtkListView allows the user to select items according to the selection
// characteristics of the model. For models that allow multiple selected items,
// it is possible to turn on _rubberband selection_, using
// ListView:enable-rubberband.
//
// If you need multiple columns with headers, see ColumnView.
//
// To learn more about the list widget framework, see the overview (Widget).
//
// An example of using GtkListView:
//
//
//    static void
//    setup_listitem_cb (GtkListItemFactory *factory,
//                       GtkListItem        *list_item)
//    {
//      GtkWidget *image;
//
//      image = gtk_image_new ();
//      gtk_image_set_icon_size (GTK_IMAGE (image), GTK_ICON_SIZE_LARGE);
//      gtk_list_item_set_child (list_item, image);
//    }
//
//    static void
//    bind_listitem_cb (GtkListItemFactory *factory,
//                      GtkListItem        *list_item)
//    {
//      GtkWidget *image;
//      GAppInfo *app_info;
//
//      image = gtk_list_item_get_child (list_item);
//      app_info = gtk_list_item_get_item (list_item);
//      gtk_image_set_from_gicon (GTK_IMAGE (image), g_app_info_get_icon (app_info));
//    }
//
//    static void
//    activate_cb (GtkListView  *list,
//                 guint         position,
//                 gpointer      unused)
//    {
//      GAppInfo *app_info;
//
//      app_info = g_list_model_get_item (G_LIST_MODEL (gtk_list_view_get_model (list)), position);
//      g_app_info_launch (app_info, NULL, NULL, NULL);
//      g_object_unref (app_info);
//    }
//
//    ...
//
//      model = create_application_list ();
//
//      factory = gtk_signal_list_item_factory_new ();
//      g_signal_connect (factory, "setup", G_CALLBACK (setup_listitem_cb), NULL);
//      g_signal_connect (factory, "bind", G_CALLBACK (bind_listitem_cb), NULL);
//
//      list = gtk_list_view_new (GTK_SELECTION_MODEL (gtk_single_selection_new (model)), factory);
//
//      g_signal_connect (list, "activate", G_CALLBACK (activate_cb), NULL);
//
//      gtk_scrolled_window_set_child (GTK_SCROLLED_WINDOW (sw), list);
//    ]|
//
//
//
// CSS nodes
//
//
//    |[<!-- language="plain" -->
//    listview[.separators][.rich-list][.navigation-sidebar][.data-table]
//    ├── row
//    │
//    ├── row
//    │
//    ┊
//    ╰── [rubberband]
//
//
//
// GtkListView uses a single CSS node named listview. It may carry the
// .separators style class, when ListView:show-separators property is set. Each
// child widget uses a single CSS node named row. For rubberband selection, a
// node with name rubberband is used.
//
// The main listview node may also carry style classes to select the style of
// list presentation (ListContainers.html#list-styles): .rich-list,
// .navigation-sidebar or .data-table.
//
//
// Accessibility
//
// GtkListView uses the K_ACCESSIBLE_ROLE_LIST role, and the list items use the
// K_ACCESSIBLE_ROLE_LIST_ITEM role.
type ListView interface {
	ListBase

	// EnableRubberband returns whether rows can be selected by dragging with
	// the mouse.
	EnableRubberband() bool
	// Factory gets the factory that's currently used to populate list items.
	Factory() ListItemFactory
	// Model gets the model that's currently used to read the items displayed.
	Model() SelectionModel
	// ShowSeparators returns whether the list box should show separators
	// between rows.
	ShowSeparators() bool
	// SingleClickActivate returns whether rows will be activated on single
	// click and selected on hover.
	SingleClickActivate() bool
	// SetEnableRubberband sets whether selections can be changed by dragging
	// with the mouse.
	SetEnableRubberband(enableRubberband bool)
	// SetFactory sets the ListItemFactory to use for populating list items.
	SetFactory(factory ListItemFactory)
	// SetModel sets the SelectionModel to use.
	SetModel(model SelectionModel)
	// SetShowSeparators sets whether the list box should show separators
	// between rows.
	SetShowSeparators(showSeparators bool)
	// SetSingleClickActivate sets whether rows should be activated on single
	// click and selected on hover.
	SetSingleClickActivate(singleClickActivate bool)
}

type listView struct {
	listBase
}

// WrapListView wraps a GObject to the right type. It is
// primarily used internally.
func WrapListView(obj *externglib.Object) ListView {
	return listView{listBase{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}}
}

func marshalListView(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapListView(obj), nil
}

// NewListView constructs a class ListView.
func NewListView(model SelectionModel, factory ListItemFactory) ListView {
	var arg1 *C.GtkSelectionModel
	var arg2 *C.GtkListItemFactory

	arg2 = (*C.GtkListItemFactory)(factory.Native())

	ret := C.gtk_list_view_new(arg1, arg2)

	var ret0 ListView

	ret0 = WrapListView(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// EnableRubberband returns whether rows can be selected by dragging with
// the mouse.
func (self listView) EnableRubberband() bool {
	var arg0 *C.GtkListView

	arg0 = (*C.GtkListView)(self.Native())

	ret := C.gtk_list_view_get_enable_rubberband(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Factory gets the factory that's currently used to populate list items.
func (self listView) Factory() ListItemFactory {
	var arg0 *C.GtkListView

	arg0 = (*C.GtkListView)(self.Native())

	ret := C.gtk_list_view_get_factory(arg0)

	var ret0 ListItemFactory

	ret0 = WrapListItemFactory(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Model gets the model that's currently used to read the items displayed.
func (self listView) Model() SelectionModel {
	var arg0 *C.GtkListView

	arg0 = (*C.GtkListView)(self.Native())

	ret := C.gtk_list_view_get_model(arg0)

	var ret0 SelectionModel

	return ret0
}

// ShowSeparators returns whether the list box should show separators
// between rows.
func (self listView) ShowSeparators() bool {
	var arg0 *C.GtkListView

	arg0 = (*C.GtkListView)(self.Native())

	ret := C.gtk_list_view_get_show_separators(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// SingleClickActivate returns whether rows will be activated on single
// click and selected on hover.
func (self listView) SingleClickActivate() bool {
	var arg0 *C.GtkListView

	arg0 = (*C.GtkListView)(self.Native())

	ret := C.gtk_list_view_get_single_click_activate(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// SetEnableRubberband sets whether selections can be changed by dragging
// with the mouse.
func (self listView) SetEnableRubberband(enableRubberband bool) {
	var arg0 *C.GtkListView
	var arg1 C.gboolean

	arg0 = (*C.GtkListView)(self.Native())
	arg1 = gextras.Cbool(enableRubberband)

	C.gtk_list_view_set_enable_rubberband(arg0, arg1)
}

// SetFactory sets the ListItemFactory to use for populating list items.
func (self listView) SetFactory(factory ListItemFactory) {
	var arg0 *C.GtkListView
	var arg1 *C.GtkListItemFactory

	arg0 = (*C.GtkListView)(self.Native())
	arg1 = (*C.GtkListItemFactory)(factory.Native())

	C.gtk_list_view_set_factory(arg0, arg1)
}

// SetModel sets the SelectionModel to use.
func (self listView) SetModel(model SelectionModel) {
	var arg0 *C.GtkListView
	var arg1 *C.GtkSelectionModel

	arg0 = (*C.GtkListView)(self.Native())

	C.gtk_list_view_set_model(arg0, arg1)
}

// SetShowSeparators sets whether the list box should show separators
// between rows.
func (self listView) SetShowSeparators(showSeparators bool) {
	var arg0 *C.GtkListView
	var arg1 C.gboolean

	arg0 = (*C.GtkListView)(self.Native())
	arg1 = gextras.Cbool(showSeparators)

	C.gtk_list_view_set_show_separators(arg0, arg1)
}

// SetSingleClickActivate sets whether rows should be activated on single
// click and selected on hover.
func (self listView) SetSingleClickActivate(singleClickActivate bool) {
	var arg0 *C.GtkListView
	var arg1 C.gboolean

	arg0 = (*C.GtkListView)(self.Native())
	arg1 = gextras.Cbool(singleClickActivate)

	C.gtk_list_view_set_single_click_activate(arg0, arg1)
}

// LockButton: gtkLockButton is a widget that can be used in control panels or
// preference dialogs to allow users to obtain and revoke authorizations needed
// to operate the controls. The required authorization is represented by a
// #GPermission object. Concrete implementations of #GPermission may use
// PolicyKit or some other authorization framework. To obtain a PolicyKit-based
// #GPermission, use polkit_permission_new().
//
// If the user is not currently allowed to perform the action, but can obtain
// the permission, the widget looks like this:
//
// ! (lockbutton-locked.png)
//
// and the user can click the button to request the permission. Depending on the
// platform, this may pop up an authentication dialog or ask the user to
// authenticate in some other way. Once the user has obtained the permission,
// the widget changes to this:
//
// ! (lockbutton-unlocked.png)
//
// and the permission can be dropped again by clicking the button. If the user
// is not able to obtain the permission at all, the widget looks like this:
//
// ! (lockbutton-sorry.png)
//
// If the user has the permission and cannot drop it, the button is hidden.
//
// The text (and tooltips) that are shown in the various cases can be adjusted
// with the LockButton:text-lock, LockButton:text-unlock,
// LockButton:tooltip-lock, LockButton:tooltip-unlock and
// LockButton:tooltip-not-authorized properties.
type LockButton interface {
	Button

	// Permission obtains the #GPermission object that controls @button.
	Permission() gio.Permission
	// SetPermission sets the #GPermission object that controls @button.
	SetPermission(permission gio.Permission)
}

type lockButton struct {
	button
}

// WrapLockButton wraps a GObject to the right type. It is
// primarily used internally.
func WrapLockButton(obj *externglib.Object) LockButton {
	return lockButton{button{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}}
}

func marshalLockButton(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapLockButton(obj), nil
}

// NewLockButton constructs a class LockButton.
func NewLockButton(permission gio.Permission) LockButton {
	var arg1 *C.GPermission

	arg1 = (*C.GPermission)(permission.Native())

	ret := C.gtk_lock_button_new(arg1)

	var ret0 LockButton

	ret0 = WrapLockButton(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Permission obtains the #GPermission object that controls @button.
func (button lockButton) Permission() gio.Permission {
	var arg0 *C.GtkLockButton

	arg0 = (*C.GtkLockButton)(button.Native())

	ret := C.gtk_lock_button_get_permission(arg0)

	var ret0 gio.Permission

	ret0 = gio.WrapPermission(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// SetPermission sets the #GPermission object that controls @button.
func (button lockButton) SetPermission(permission gio.Permission) {
	var arg0 *C.GtkLockButton
	var arg1 *C.GPermission

	arg0 = (*C.GtkLockButton)(button.Native())
	arg1 = (*C.GPermission)(permission.Native())

	C.gtk_lock_button_set_permission(arg0, arg1)
}

// MapListModel is a list model that takes a list model and maps the items in
// that model to different items according to a MapListModelMapFunc.
//
// Example: Create a list of EventControllers
//
//
//      static gpointer
//      map_to_controllers (gpointer widget,
//                          gpointer data)
//     {
//        gpointer result = gtk_widget_observe_controllers (widget);
//        g_object_unref (widget);
//        return result;
//     }
//
//      widgets = gtk_widget_observe_children (widget);
//
//      controllers = gtk_map_list_model_new (G_TYPE_LIST_MODEL,
//                                            widgets,
//                                            map_to_controllers,
//                                            NULL, NULL);
//
//      model = gtk_flatten_list_model_new (GTK_TYPE_EVENT_CONTROLLER,
//                                          controllers);
//
//
// MapListModel will attempt to discard the mapped objects as soon as they are
// no longer needed and recreate them if necessary.
type MapListModel interface {
	gextras.Objector

	// Model gets the model that is currently being mapped or nil if none.
	Model() gio.ListModel
	// HasMap checks if a map function is currently set on @self
	HasMap() bool
	// SetMapFunc sets the function used to map items. The function will be
	// called whenever an item needs to be mapped and must return the item to
	// use for the given input item.
	//
	// Note that MapListModel may call this function multiple times on the same
	// item, because it may delete items it doesn't need anymore.
	//
	// GTK makes no effort to ensure that @map_func conforms to the item type of
	// @self. It assumes that the caller knows what they are doing and the map
	// function returns items of the appropriate type.
	SetMapFunc(mapFunc MapListModelMapFunc)
	// SetModel sets the model to be mapped.
	//
	// GTK makes no effort to ensure that @model conforms to the item type
	// expected by the map function. It assumes that the caller knows what they
	// are doing and have set up an appropriate map function.
	SetModel(model gio.ListModel)
}

type mapListModel struct {
	*externglib.Object
}

// WrapMapListModel wraps a GObject to the right type. It is
// primarily used internally.
func WrapMapListModel(obj *externglib.Object) MapListModel {
	return mapListModel{*externglib.Object{obj}}
}

func marshalMapListModel(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapMapListModel(obj), nil
}

// NewMapListModel constructs a class MapListModel.
func NewMapListModel(model gio.ListModel, mapFunc MapListModelMapFunc) MapListModel {
	var arg1 *C.GListModel
	var arg2 C.GtkMapListModelMapFunc
	arg3 := C.gpointer(box.Assign(userData))

	arg2 = (*[0]byte)(C.gotk4_MapListModelMapFunc)

	ret := C.gtk_map_list_model_new(arg1, arg2, (*[0]byte)(C.callbackDelete))

	var ret0 MapListModel

	ret0 = WrapMapListModel(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Model gets the model that is currently being mapped or nil if none.
func (self mapListModel) Model() gio.ListModel {
	var arg0 *C.GtkMapListModel

	arg0 = (*C.GtkMapListModel)(self.Native())

	ret := C.gtk_map_list_model_get_model(arg0)

	var ret0 gio.ListModel

	return ret0
}

// HasMap checks if a map function is currently set on @self
func (self mapListModel) HasMap() bool {
	var arg0 *C.GtkMapListModel

	arg0 = (*C.GtkMapListModel)(self.Native())

	ret := C.gtk_map_list_model_has_map(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// SetMapFunc sets the function used to map items. The function will be
// called whenever an item needs to be mapped and must return the item to
// use for the given input item.
//
// Note that MapListModel may call this function multiple times on the same
// item, because it may delete items it doesn't need anymore.
//
// GTK makes no effort to ensure that @map_func conforms to the item type of
// @self. It assumes that the caller knows what they are doing and the map
// function returns items of the appropriate type.
func (self mapListModel) SetMapFunc(mapFunc MapListModelMapFunc) {
	var arg0 *C.GtkMapListModel
	var arg1 C.GtkMapListModelMapFunc
	arg2 := C.gpointer(box.Assign(userData))

	arg0 = (*C.GtkMapListModel)(self.Native())
	arg1 = (*[0]byte)(C.gotk4_MapListModelMapFunc)

	C.gtk_map_list_model_set_map_func(arg0, arg1, (*[0]byte)(C.callbackDelete))
}

// SetModel sets the model to be mapped.
//
// GTK makes no effort to ensure that @model conforms to the item type
// expected by the map function. It assumes that the caller knows what they
// are doing and have set up an appropriate map function.
func (self mapListModel) SetModel(model gio.ListModel) {
	var arg0 *C.GtkMapListModel
	var arg1 *C.GListModel

	arg0 = (*C.GtkMapListModel)(self.Native())

	C.gtk_map_list_model_set_model(arg0, arg1)
}

// MediaControls gtkMediaControls is a widget to show controls for a MediaStream
// and giving users a way to use it.
type MediaControls interface {
	Widget

	// MediaStream gets the media stream managed by @controls or nil if none.
	MediaStream() MediaStream
	// SetMediaStream sets the stream that is controlled by @controls.
	SetMediaStream(stream MediaStream)
}

type mediaControls struct {
	widget
}

// WrapMediaControls wraps a GObject to the right type. It is
// primarily used internally.
func WrapMediaControls(obj *externglib.Object) MediaControls {
	return mediaControls{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}
}

func marshalMediaControls(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapMediaControls(obj), nil
}

// NewMediaControls constructs a class MediaControls.
func NewMediaControls(stream MediaStream) MediaControls {
	var arg1 *C.GtkMediaStream

	arg1 = (*C.GtkMediaStream)(stream.Native())

	ret := C.gtk_media_controls_new(arg1)

	var ret0 MediaControls

	ret0 = WrapMediaControls(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// MediaStream gets the media stream managed by @controls or nil if none.
func (controls mediaControls) MediaStream() MediaStream {
	var arg0 *C.GtkMediaControls

	arg0 = (*C.GtkMediaControls)(controls.Native())

	ret := C.gtk_media_controls_get_media_stream(arg0)

	var ret0 MediaStream

	ret0 = WrapMediaStream(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// SetMediaStream sets the stream that is controlled by @controls.
func (controls mediaControls) SetMediaStream(stream MediaStream) {
	var arg0 *C.GtkMediaControls
	var arg1 *C.GtkMediaStream

	arg0 = (*C.GtkMediaControls)(controls.Native())
	arg1 = (*C.GtkMediaStream)(stream.Native())

	C.gtk_media_controls_set_media_stream(arg0, arg1)
}

// MediaFile is the implementation for media file usage with MediaStream.
//
// This provides a simple way to play back video files with GTK.
//
// GTK provides a GIO extension point for MediaFile implementations to allow for
// external implementations using various media frameworks. GTK itself includes
// implementations using GStreamer and ffmpeg.
type MediaFile interface {
	MediaStream

	// Clear resets the media file to be empty.
	Clear()
	// File returns the file that @self is currently playing from.
	//
	// When @self is not playing or not playing from a file, nil is returned.
	File() gio.File
	// InputStream returns the stream that @self is currently playing from.
	//
	// When @self is not playing or not playing from a stream, nil is returned.
	InputStream() gio.InputStream
	// SetFile: if any file is still playing, stop playing it.
	//
	// Then start playing the given @file.
	SetFile(file gio.File)
	// SetFilename: this is a utility function that converts the given @filename
	// to a #GFile and calls gtk_media_file_set_file().
	SetFilename(filename string)
	// SetInputStream: if anything is still playing, stop playing it. Then start
	// playing the given @stream.
	//
	// Full control about the @stream is assumed for the duration of playback.
	// The stream will not bt be closed.
	SetInputStream(stream gio.InputStream)
	// SetResource: this is a utility function that converts the given
	// @resource_path to a #GFile and calls gtk_media_file_set_file().
	SetResource(resourcePath string)
}

type mediaFile struct {
	mediaStream
}

// WrapMediaFile wraps a GObject to the right type. It is
// primarily used internally.
func WrapMediaFile(obj *externglib.Object) MediaFile {
	return mediaFile{mediaStream{*externglib.Object{obj}}}
}

func marshalMediaFile(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapMediaFile(obj), nil
}

// NewMediaFile constructs a class MediaFile.
func NewMediaFile() MediaFile {

	ret := C.gtk_media_file_new()

	var ret0 MediaFile

	ret0 = WrapMediaFile(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewMediaFileForFile constructs a class MediaFile.
func NewMediaFileForFile(file gio.File) MediaFile {
	var arg1 *C.GFile

	ret := C.gtk_media_file_new_for_file(arg1)

	var ret0 MediaFile

	ret0 = WrapMediaFile(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewMediaFileForFilename constructs a class MediaFile.
func NewMediaFileForFilename(filename string) MediaFile {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_media_file_new_for_filename(arg1)

	var ret0 MediaFile

	ret0 = WrapMediaFile(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewMediaFileForInputStream constructs a class MediaFile.
func NewMediaFileForInputStream(stream gio.InputStream) MediaFile {
	var arg1 *C.GInputStream

	arg1 = (*C.GInputStream)(stream.Native())

	ret := C.gtk_media_file_new_for_input_stream(arg1)

	var ret0 MediaFile

	ret0 = WrapMediaFile(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewMediaFileForResource constructs a class MediaFile.
func NewMediaFileForResource(resourcePath string) MediaFile {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(resourcePath))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_media_file_new_for_resource(arg1)

	var ret0 MediaFile

	ret0 = WrapMediaFile(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Clear resets the media file to be empty.
func (self mediaFile) Clear() {
	var arg0 *C.GtkMediaFile

	arg0 = (*C.GtkMediaFile)(self.Native())

	C.gtk_media_file_clear(arg0)
}

// File returns the file that @self is currently playing from.
//
// When @self is not playing or not playing from a file, nil is returned.
func (self mediaFile) File() gio.File {
	var arg0 *C.GtkMediaFile

	arg0 = (*C.GtkMediaFile)(self.Native())

	ret := C.gtk_media_file_get_file(arg0)

	var ret0 gio.File

	return ret0
}

// InputStream returns the stream that @self is currently playing from.
//
// When @self is not playing or not playing from a stream, nil is returned.
func (self mediaFile) InputStream() gio.InputStream {
	var arg0 *C.GtkMediaFile

	arg0 = (*C.GtkMediaFile)(self.Native())

	ret := C.gtk_media_file_get_input_stream(arg0)

	var ret0 gio.InputStream

	ret0 = gio.WrapInputStream(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// SetFile: if any file is still playing, stop playing it.
//
// Then start playing the given @file.
func (self mediaFile) SetFile(file gio.File) {
	var arg0 *C.GtkMediaFile
	var arg1 *C.GFile

	arg0 = (*C.GtkMediaFile)(self.Native())

	C.gtk_media_file_set_file(arg0, arg1)
}

// SetFilename: this is a utility function that converts the given @filename
// to a #GFile and calls gtk_media_file_set_file().
func (self mediaFile) SetFilename(filename string) {
	var arg0 *C.GtkMediaFile
	var arg1 *C.char

	arg0 = (*C.GtkMediaFile)(self.Native())
	arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_media_file_set_filename(arg0, arg1)
}

// SetInputStream: if anything is still playing, stop playing it. Then start
// playing the given @stream.
//
// Full control about the @stream is assumed for the duration of playback.
// The stream will not bt be closed.
func (self mediaFile) SetInputStream(stream gio.InputStream) {
	var arg0 *C.GtkMediaFile
	var arg1 *C.GInputStream

	arg0 = (*C.GtkMediaFile)(self.Native())
	arg1 = (*C.GInputStream)(stream.Native())

	C.gtk_media_file_set_input_stream(arg0, arg1)
}

// SetResource: this is a utility function that converts the given
// @resource_path to a #GFile and calls gtk_media_file_set_file().
func (self mediaFile) SetResource(resourcePath string) {
	var arg0 *C.GtkMediaFile
	var arg1 *C.char

	arg0 = (*C.GtkMediaFile)(self.Native())
	arg1 = (*C.gchar)(C.CString(resourcePath))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_media_file_set_resource(arg0, arg1)
}

// MediaStream is the integration point for media playback inside GTK.
//
// GTK provides an implementation of the MediaStream interface that is called
// MediaFile.
//
// Apart from application-facing API for stream playback, MediaStream has a
// number of APIs that are only useful for implementations and should not be
// used in applications: gtk_media_stream_prepared(),
// gtk_media_stream_unprepared(), gtk_media_stream_update(),
// gtk_media_stream_ended(), gtk_media_stream_seek_success(),
// gtk_media_stream_seek_failed(), gtk_media_stream_gerror(),
// gtk_media_stream_error(), gtk_media_stream_error_valist().
type MediaStream interface {
	gextras.Objector

	// Ended pauses the media stream and marks it as ended. This is a hint only,
	// calls to GtkMediaStream.play() may still happen.
	Ended()
	// Gerror sets @self into an error state. This will pause the stream (you
	// can check for an error via gtk_media_stream_get_error() in your
	// GtkMediaStream.pause() implementation), abort pending seeks and mark the
	// stream as prepared.
	//
	// if the stream is already in an error state, this call will be ignored and
	// the existing error will be retained. FIXME: Or do we want to set the new
	// error?
	//
	// To unset an error, the stream must be reset via a call to
	// gtk_media_stream_unprepared().
	Gerror(error *glib.Error)
	// Duration gets the duration of the stream. If the duration is not known, 0
	// will be returned.
	Duration() int64
	// GetEnded returns whether the streams playback is finished.
	GetEnded() bool
	// Error: if the stream is in an error state, returns the #GError explaining
	// that state. Any type of error can be reported here depending on the
	// implementation of the media stream.
	//
	// A media stream in an error cannot be operated on, calls like
	// gtk_media_stream_play() or gtk_media_stream_seek() will not have any
	// effect.
	//
	// MediaStream itself does not provide a way to unset an error, but
	// implementations may provide options. For example, a MediaFile will unset
	// errors when a new source is set with ie gtk_media_file_set_file().
	Error() *glib.Error
	// Loop returns whether the stream is set to loop. See
	// gtk_media_stream_set_loop() for details.
	Loop() bool
	// Muted returns whether the audio for the stream is muted. See
	// gtk_media_stream_set_muted() for details.
	Muted() bool
	// Playing: return whether the stream is currently playing.
	Playing() bool
	// Timestamp returns the current presentation timestamp in microseconds.
	Timestamp() int64
	// Volume returns the volume of the audio for the stream. See
	// gtk_media_stream_set_volume() for details.
	Volume() float64
	// HasAudio returns whether the stream has audio.
	HasAudio() bool
	// HasVideo returns whether the stream has video.
	HasVideo() bool
	// IsPrepared returns whether the stream has finished initializing and
	// existence of audio and video is known.
	IsPrepared() bool
	// IsSeekable checks if a stream may be seekable.
	//
	// This is meant to be a hint. Streams may not allow seeking even if this
	// function returns true. However, if this function returns false, streams
	// are guaranteed to not be seekable and user interfaces may hide controls
	// that allow seeking.
	//
	// It is allowed to call gtk_media_stream_seek() on a non-seekable stream,
	// though it will not do anything.
	IsSeekable() bool
	// IsSeeking checks if there is currently a seek operation going on.
	IsSeeking() bool
	// Pause pauses playback of the stream. If the stream is not playing, do
	// nothing.
	Pause()
	// Play starts playing the stream. If the stream is in error or already
	// playing, do nothing.
	Play()
	// Prepared: called by MediaStream implementations to advertise the stream
	// being ready to play and providing details about the stream.
	//
	// Note that the arguments are hints. If the stream implementation cannot
	// determine the correct values, it is better to err on the side of caution
	// and return true. User interfaces will use those values to determine what
	// controls to show.
	//
	// This function may not be called again until the stream has been reset via
	// gtk_media_stream_unprepared().
	Prepared(hasAudio bool, hasVideo bool, seekable bool, duration int64)
	// Realize: called by users to attach the media stream to a Surface they
	// manage. The stream can then access the resources of @surface for its
	// rendering purposes. In particular, media streams might want to create
	// GLContexts or sync to the FrameClock.
	//
	// Whoever calls this function is responsible for calling
	// gtk_media_stream_unrealize() before either the stream or @surface get
	// destroyed.
	//
	// Multiple calls to this function may happen from different users of the
	// video, even with the same @surface. Each of these calls must be followed
	// by its own call to gtk_media_stream_unrealize().
	//
	// It is not required to call this function to make a media stream work.
	Realize(surface gdk.Surface)
	// Seek: start a seek operation on @self to @timestamp. If @timestamp is out
	// of range, it will be clamped.
	//
	// Seek operations may not finish instantly. While a seek operation is in
	// process, the GtkMediaStream:seeking property will be set.
	//
	// When calling gtk_media_stream_seek() during an ongoing seek operation,
	// the new seek will override any pending seek.
	Seek(timestamp int64)
	// SeekFailed ends a seek operation started via GtkMediaStream.seek() as a
	// failure. This will not cause an error on the stream and will assume that
	// playback continues as if no seek had happened.
	//
	// See gtk_media_stream_seek_success() for the other way of ending a seek.
	SeekFailed()
	// SeekSuccess ends a seek operation started via GtkMediaStream.seek()
	// successfully. This function will unset the GtkMediaStream:ended property
	// if it was set.
	//
	// See gtk_media_stream_seek_failed() for the other way of ending a seek.
	SeekSuccess()
	// SetLoop sets whether the stream should loop, ie restart playback from the
	// beginning instead of stopping at the end.
	//
	// Not all streams may support looping, in particular non-seekable streams.
	// Those streams will ignore the loop setting and just end.
	SetLoop(loop bool)
	// SetMuted sets whether the audio stream should be muted. Muting a stream
	// will cause no audio to be played, but it does not modify the volume. This
	// means that muting and then unmuting the stream will restore the volume
	// settings.
	//
	// If the stream has no audio, calling this function will still work but it
	// will not have an audible effect.
	SetMuted(muted bool)
	// SetPlaying starts or pauses playback of the stream.
	SetPlaying(playing bool)
	// SetVolume sets the volume of the audio stream. This function call will
	// work even if the stream is muted.
	//
	// The given @volume should range from 0.0 for silence to 1.0 for as loud as
	// possible. Values outside of this range will be clamped to the nearest
	// value.
	//
	// If the stream has no audio or is muted, calling this function will still
	// work but it will not have an immediate audible effect. When the stream is
	// unmuted, the new volume setting will take effect.
	SetVolume(volume float64)
	// Unprepared resets a given media stream implementation.
	// gtk_media_stream_prepared() can now be called again.
	//
	// This function will also reset any error state the stream was in.
	Unprepared()
	// Unrealize undoes a previous call to gtk_media_stream_realize() and causes
	// the stream to release all resources it had allocated from @surface.
	Unrealize(surface gdk.Surface)
	// Update: media stream implementations should regularly call this function
	// to update the timestamp reported by the stream. It is up to
	// implementations to call this at the frequency they deem appropriate.
	Update(timestamp int64)
}

type mediaStream struct {
	*externglib.Object
}

// WrapMediaStream wraps a GObject to the right type. It is
// primarily used internally.
func WrapMediaStream(obj *externglib.Object) MediaStream {
	return mediaStream{*externglib.Object{obj}}
}

func marshalMediaStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapMediaStream(obj), nil
}

// Ended pauses the media stream and marks it as ended. This is a hint only,
// calls to GtkMediaStream.play() may still happen.
func (self mediaStream) Ended() {
	var arg0 *C.GtkMediaStream

	arg0 = (*C.GtkMediaStream)(self.Native())

	C.gtk_media_stream_ended(arg0)
}

// Gerror sets @self into an error state. This will pause the stream (you
// can check for an error via gtk_media_stream_get_error() in your
// GtkMediaStream.pause() implementation), abort pending seeks and mark the
// stream as prepared.
//
// if the stream is already in an error state, this call will be ignored and
// the existing error will be retained. FIXME: Or do we want to set the new
// error?
//
// To unset an error, the stream must be reset via a call to
// gtk_media_stream_unprepared().
func (self mediaStream) Gerror(error *glib.Error) {
	var arg0 *C.GtkMediaStream
	var arg1 *C.GError

	arg0 = (*C.GtkMediaStream)(self.Native())
	arg1 = (*C.GError)(error.Native())

	C.gtk_media_stream_gerror(arg0, arg1)
}

// Duration gets the duration of the stream. If the duration is not known, 0
// will be returned.
func (self mediaStream) Duration() int64 {
	var arg0 *C.GtkMediaStream

	arg0 = (*C.GtkMediaStream)(self.Native())

	ret := C.gtk_media_stream_get_duration(arg0)

	var ret0 int64

	ret0 = int64(ret)

	return ret0
}

// GetEnded returns whether the streams playback is finished.
func (self mediaStream) GetEnded() bool {
	var arg0 *C.GtkMediaStream

	arg0 = (*C.GtkMediaStream)(self.Native())

	ret := C.gtk_media_stream_get_ended(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Error: if the stream is in an error state, returns the #GError explaining
// that state. Any type of error can be reported here depending on the
// implementation of the media stream.
//
// A media stream in an error cannot be operated on, calls like
// gtk_media_stream_play() or gtk_media_stream_seek() will not have any
// effect.
//
// MediaStream itself does not provide a way to unset an error, but
// implementations may provide options. For example, a MediaFile will unset
// errors when a new source is set with ie gtk_media_file_set_file().
func (self mediaStream) Error() *glib.Error {
	var arg0 *C.GtkMediaStream

	arg0 = (*C.GtkMediaStream)(self.Native())

	ret := C.gtk_media_stream_get_error(arg0)

	var ret0 *glib.Error

	ret0 = glib.WrapError(ret)

	return ret0
}

// Loop returns whether the stream is set to loop. See
// gtk_media_stream_set_loop() for details.
func (self mediaStream) Loop() bool {
	var arg0 *C.GtkMediaStream

	arg0 = (*C.GtkMediaStream)(self.Native())

	ret := C.gtk_media_stream_get_loop(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Muted returns whether the audio for the stream is muted. See
// gtk_media_stream_set_muted() for details.
func (self mediaStream) Muted() bool {
	var arg0 *C.GtkMediaStream

	arg0 = (*C.GtkMediaStream)(self.Native())

	ret := C.gtk_media_stream_get_muted(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Playing: return whether the stream is currently playing.
func (self mediaStream) Playing() bool {
	var arg0 *C.GtkMediaStream

	arg0 = (*C.GtkMediaStream)(self.Native())

	ret := C.gtk_media_stream_get_playing(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Timestamp returns the current presentation timestamp in microseconds.
func (self mediaStream) Timestamp() int64 {
	var arg0 *C.GtkMediaStream

	arg0 = (*C.GtkMediaStream)(self.Native())

	ret := C.gtk_media_stream_get_timestamp(arg0)

	var ret0 int64

	ret0 = int64(ret)

	return ret0
}

// Volume returns the volume of the audio for the stream. See
// gtk_media_stream_set_volume() for details.
func (self mediaStream) Volume() float64 {
	var arg0 *C.GtkMediaStream

	arg0 = (*C.GtkMediaStream)(self.Native())

	ret := C.gtk_media_stream_get_volume(arg0)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// HasAudio returns whether the stream has audio.
func (self mediaStream) HasAudio() bool {
	var arg0 *C.GtkMediaStream

	arg0 = (*C.GtkMediaStream)(self.Native())

	ret := C.gtk_media_stream_has_audio(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// HasVideo returns whether the stream has video.
func (self mediaStream) HasVideo() bool {
	var arg0 *C.GtkMediaStream

	arg0 = (*C.GtkMediaStream)(self.Native())

	ret := C.gtk_media_stream_has_video(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// IsPrepared returns whether the stream has finished initializing and
// existence of audio and video is known.
func (self mediaStream) IsPrepared() bool {
	var arg0 *C.GtkMediaStream

	arg0 = (*C.GtkMediaStream)(self.Native())

	ret := C.gtk_media_stream_is_prepared(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// IsSeekable checks if a stream may be seekable.
//
// This is meant to be a hint. Streams may not allow seeking even if this
// function returns true. However, if this function returns false, streams
// are guaranteed to not be seekable and user interfaces may hide controls
// that allow seeking.
//
// It is allowed to call gtk_media_stream_seek() on a non-seekable stream,
// though it will not do anything.
func (self mediaStream) IsSeekable() bool {
	var arg0 *C.GtkMediaStream

	arg0 = (*C.GtkMediaStream)(self.Native())

	ret := C.gtk_media_stream_is_seekable(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// IsSeeking checks if there is currently a seek operation going on.
func (self mediaStream) IsSeeking() bool {
	var arg0 *C.GtkMediaStream

	arg0 = (*C.GtkMediaStream)(self.Native())

	ret := C.gtk_media_stream_is_seeking(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Pause pauses playback of the stream. If the stream is not playing, do
// nothing.
func (self mediaStream) Pause() {
	var arg0 *C.GtkMediaStream

	arg0 = (*C.GtkMediaStream)(self.Native())

	C.gtk_media_stream_pause(arg0)
}

// Play starts playing the stream. If the stream is in error or already
// playing, do nothing.
func (self mediaStream) Play() {
	var arg0 *C.GtkMediaStream

	arg0 = (*C.GtkMediaStream)(self.Native())

	C.gtk_media_stream_play(arg0)
}

// Prepared: called by MediaStream implementations to advertise the stream
// being ready to play and providing details about the stream.
//
// Note that the arguments are hints. If the stream implementation cannot
// determine the correct values, it is better to err on the side of caution
// and return true. User interfaces will use those values to determine what
// controls to show.
//
// This function may not be called again until the stream has been reset via
// gtk_media_stream_unprepared().
func (self mediaStream) Prepared(hasAudio bool, hasVideo bool, seekable bool, duration int64) {
	var arg0 *C.GtkMediaStream
	var arg1 C.gboolean
	var arg2 C.gboolean
	var arg3 C.gboolean
	var arg4 C.gint64

	arg0 = (*C.GtkMediaStream)(self.Native())
	arg1 = gextras.Cbool(hasAudio)
	arg2 = gextras.Cbool(hasVideo)
	arg3 = gextras.Cbool(seekable)
	arg4 = C.gint64(duration)

	C.gtk_media_stream_prepared(arg0, arg1, arg2, arg3, arg4)
}

// Realize: called by users to attach the media stream to a Surface they
// manage. The stream can then access the resources of @surface for its
// rendering purposes. In particular, media streams might want to create
// GLContexts or sync to the FrameClock.
//
// Whoever calls this function is responsible for calling
// gtk_media_stream_unrealize() before either the stream or @surface get
// destroyed.
//
// Multiple calls to this function may happen from different users of the
// video, even with the same @surface. Each of these calls must be followed
// by its own call to gtk_media_stream_unrealize().
//
// It is not required to call this function to make a media stream work.
func (self mediaStream) Realize(surface gdk.Surface) {
	var arg0 *C.GtkMediaStream
	var arg1 *C.GdkSurface

	arg0 = (*C.GtkMediaStream)(self.Native())
	arg1 = (*C.GdkSurface)(surface.Native())

	C.gtk_media_stream_realize(arg0, arg1)
}

// Seek: start a seek operation on @self to @timestamp. If @timestamp is out
// of range, it will be clamped.
//
// Seek operations may not finish instantly. While a seek operation is in
// process, the GtkMediaStream:seeking property will be set.
//
// When calling gtk_media_stream_seek() during an ongoing seek operation,
// the new seek will override any pending seek.
func (self mediaStream) Seek(timestamp int64) {
	var arg0 *C.GtkMediaStream
	var arg1 C.gint64

	arg0 = (*C.GtkMediaStream)(self.Native())
	arg1 = C.gint64(timestamp)

	C.gtk_media_stream_seek(arg0, arg1)
}

// SeekFailed ends a seek operation started via GtkMediaStream.seek() as a
// failure. This will not cause an error on the stream and will assume that
// playback continues as if no seek had happened.
//
// See gtk_media_stream_seek_success() for the other way of ending a seek.
func (self mediaStream) SeekFailed() {
	var arg0 *C.GtkMediaStream

	arg0 = (*C.GtkMediaStream)(self.Native())

	C.gtk_media_stream_seek_failed(arg0)
}

// SeekSuccess ends a seek operation started via GtkMediaStream.seek()
// successfully. This function will unset the GtkMediaStream:ended property
// if it was set.
//
// See gtk_media_stream_seek_failed() for the other way of ending a seek.
func (self mediaStream) SeekSuccess() {
	var arg0 *C.GtkMediaStream

	arg0 = (*C.GtkMediaStream)(self.Native())

	C.gtk_media_stream_seek_success(arg0)
}

// SetLoop sets whether the stream should loop, ie restart playback from the
// beginning instead of stopping at the end.
//
// Not all streams may support looping, in particular non-seekable streams.
// Those streams will ignore the loop setting and just end.
func (self mediaStream) SetLoop(loop bool) {
	var arg0 *C.GtkMediaStream
	var arg1 C.gboolean

	arg0 = (*C.GtkMediaStream)(self.Native())
	arg1 = gextras.Cbool(loop)

	C.gtk_media_stream_set_loop(arg0, arg1)
}

// SetMuted sets whether the audio stream should be muted. Muting a stream
// will cause no audio to be played, but it does not modify the volume. This
// means that muting and then unmuting the stream will restore the volume
// settings.
//
// If the stream has no audio, calling this function will still work but it
// will not have an audible effect.
func (self mediaStream) SetMuted(muted bool) {
	var arg0 *C.GtkMediaStream
	var arg1 C.gboolean

	arg0 = (*C.GtkMediaStream)(self.Native())
	arg1 = gextras.Cbool(muted)

	C.gtk_media_stream_set_muted(arg0, arg1)
}

// SetPlaying starts or pauses playback of the stream.
func (self mediaStream) SetPlaying(playing bool) {
	var arg0 *C.GtkMediaStream
	var arg1 C.gboolean

	arg0 = (*C.GtkMediaStream)(self.Native())
	arg1 = gextras.Cbool(playing)

	C.gtk_media_stream_set_playing(arg0, arg1)
}

// SetVolume sets the volume of the audio stream. This function call will
// work even if the stream is muted.
//
// The given @volume should range from 0.0 for silence to 1.0 for as loud as
// possible. Values outside of this range will be clamped to the nearest
// value.
//
// If the stream has no audio or is muted, calling this function will still
// work but it will not have an immediate audible effect. When the stream is
// unmuted, the new volume setting will take effect.
func (self mediaStream) SetVolume(volume float64) {
	var arg0 *C.GtkMediaStream
	var arg1 C.double

	arg0 = (*C.GtkMediaStream)(self.Native())
	arg1 = C.double(volume)

	C.gtk_media_stream_set_volume(arg0, arg1)
}

// Unprepared resets a given media stream implementation.
// gtk_media_stream_prepared() can now be called again.
//
// This function will also reset any error state the stream was in.
func (self mediaStream) Unprepared() {
	var arg0 *C.GtkMediaStream

	arg0 = (*C.GtkMediaStream)(self.Native())

	C.gtk_media_stream_unprepared(arg0)
}

// Unrealize undoes a previous call to gtk_media_stream_realize() and causes
// the stream to release all resources it had allocated from @surface.
func (self mediaStream) Unrealize(surface gdk.Surface) {
	var arg0 *C.GtkMediaStream
	var arg1 *C.GdkSurface

	arg0 = (*C.GtkMediaStream)(self.Native())
	arg1 = (*C.GdkSurface)(surface.Native())

	C.gtk_media_stream_unrealize(arg0, arg1)
}

// Update: media stream implementations should regularly call this function
// to update the timestamp reported by the stream. It is up to
// implementations to call this at the frequency they deem appropriate.
func (self mediaStream) Update(timestamp int64) {
	var arg0 *C.GtkMediaStream
	var arg1 C.gint64

	arg0 = (*C.GtkMediaStream)(self.Native())
	arg1 = C.gint64(timestamp)

	C.gtk_media_stream_update(arg0, arg1)
}

// MenuButton: the MenuButton widget is used to display a popup when clicked on.
// This popup can be provided either as a Popover or as an abstract Model.
//
// The MenuButton widget can show either an icon (set with the
// MenuButton:icon-name property) or a label (set with the MenuButton:label
// property). If neither is explicitly set, a Image is automatically created,
// using an arrow image oriented according to MenuButton:direction or the
// generic “open-menu-symbolic” icon if the direction is not set.
//
// The positioning of the popup is determined by the MenuButton:direction
// property of the menu button.
//
// For menus, the Widget:halign and Widget:valign properties of the menu are
// also taken into account. For example, when the direction is GTK_ARROW_DOWN
// and the horizontal alignment is GTK_ALIGN_START, the menu will be positioned
// below the button, with the starting edge (depending on the text direction) of
// the menu aligned with the starting edge of the button. If there is not enough
// space below the button, the menu is popped up above the button instead. If
// the alignment would move part of the menu offscreen, it is “pushed in”.
//
// Direction = Down
//
// - halign = start
//
//    ! (down-start.png)
//
// - halign = center
//
//    ! (down-center.png)
//
// - halign = end
//
//    ! (down-end.png)
//
// Direction = Up
//
// - halign = start
//
//    ! (up-start.png)
//
// - halign = center
//
//    ! (up-center.png)
//
// - halign = end
//
//    ! (up-end.png)
//
// Direction = Left
//
// - valign = start
//
//    ! (left-start.png)
//
// - valign = center
//
//    ! (left-center.png)
//
// - valign = end
//
//    ! (left-end.png)
//
// Direction = Right
//
// - valign = start
//
//    ! (right-start.png)
//
// - valign = center
//
//    ! (right-center.png)
//
// - valign = end
//
//    ! (right-end.png)
//
// CSS nodes
//
//    menubutton
//    ╰── button.toggle
//        ╰── [content]
//
//
// GtkMenuButton has a single CSS node with name menubutton which contains a
// toggle button node.
//
//
// Accessibility
//
// GtkMenuButton uses the K_ACCESSIBLE_ROLE_BUTTON role.
type MenuButton interface {
	Widget

	// Direction returns the direction the popup will be pointing at when popped
	// up.
	Direction() ArrowType
	// HasFrame returns whether the button has a frame.
	HasFrame() bool
	// IconName gets the name of the icon shown in the button.
	IconName() string
	// Label gets the label shown in the button
	Label() string
	// MenuModel returns the Model used to generate the popup.
	MenuModel() gio.MenuModel
	// Popover returns the Popover that pops out of the button. If the button is
	// not using a Popover, this function returns nil.
	Popover() Popover
	// UseUnderline returns whether an embedded underline in the text indicates
	// a mnemonic. See gtk_menu_button_set_use_underline().
	UseUnderline() bool
	// Popdown dismiss the menu.
	Popdown()
	// Popup: pop up the menu.
	Popup()
	// SetCreatePopupFunc sets @func to be called when a popup is about to be
	// shown. @func should use one of
	//
	//    - gtk_menu_button_set_popover()
	//    - gtk_menu_button_set_menu_model()
	//
	// to set a popup for @menu_button. If @func is non-nil, @menu_button will
	// always be sensitive.
	//
	// Using this function will not reset the menu widget attached to
	// @menu_button. Instead, this can be done manually in @func.
	SetCreatePopupFunc(_func MenuButtonCreatePopupFunc)
	// SetDirection sets the direction in which the popup will be popped up, as
	// well as changing the arrow’s direction. The child will not be changed to
	// an arrow if it was customized.
	//
	// If the does not fit in the available space in the given direction, GTK
	// will its best to keep it inside the screen and fully visible.
	//
	// If you pass GTK_ARROW_NONE for a @direction, the popup will behave as if
	// you passed GTK_ARROW_DOWN (although you won’t see any arrows).
	SetDirection(direction ArrowType)
	// SetHasFrame sets the style of the button.
	SetHasFrame(hasFrame bool)
	// SetIconName sets the name of an icon to show inside the menu button.
	SetIconName(iconName string)
	// SetLabel sets the label to show inside the menu button.
	SetLabel(label string)
	// SetMenuModel sets the Model from which the popup will be constructed, or
	// nil to dissociate any existing menu model and disable the button.
	//
	// A Popover will be created from the menu model with
	// gtk_popover_menu_new_from_model(). Actions will be connected as
	// documented for this function.
	//
	// If MenuButton:popover is already set, it will be dissociated from the
	// @menu_button, and the property is set to nil.
	SetMenuModel(menuModel gio.MenuModel)
	// SetPopover sets the Popover that will be popped up when the @menu_button
	// is clicked, or nil to dissociate any existing popover and disable the
	// button.
	//
	// If MenuButton:menu-model is set, the menu model is dissociated from the
	// @menu_button, and the property is set to nil.
	SetPopover(popover Widget)
	// SetUseUnderline: if true, an underline in the text indicates the next
	// character should be used for the mnemonic accelerator key.
	SetUseUnderline(useUnderline bool)
}

type menuButton struct {
	widget
}

// WrapMenuButton wraps a GObject to the right type. It is
// primarily used internally.
func WrapMenuButton(obj *externglib.Object) MenuButton {
	return menuButton{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}
}

func marshalMenuButton(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapMenuButton(obj), nil
}

// NewMenuButton constructs a class MenuButton.
func NewMenuButton() MenuButton {

	ret := C.gtk_menu_button_new()

	var ret0 MenuButton

	ret0 = WrapMenuButton(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Direction returns the direction the popup will be pointing at when popped
// up.
func (menuButton menuButton) Direction() ArrowType {
	var arg0 *C.GtkMenuButton

	arg0 = (*C.GtkMenuButton)(menuButton.Native())

	ret := C.gtk_menu_button_get_direction(arg0)

	var ret0 ArrowType

	ret0 = ArrowType(ret)

	return ret0
}

// HasFrame returns whether the button has a frame.
func (menuButton menuButton) HasFrame() bool {
	var arg0 *C.GtkMenuButton

	arg0 = (*C.GtkMenuButton)(menuButton.Native())

	ret := C.gtk_menu_button_get_has_frame(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// IconName gets the name of the icon shown in the button.
func (menuButton menuButton) IconName() string {
	var arg0 *C.GtkMenuButton

	arg0 = (*C.GtkMenuButton)(menuButton.Native())

	ret := C.gtk_menu_button_get_icon_name(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Label gets the label shown in the button
func (menuButton menuButton) Label() string {
	var arg0 *C.GtkMenuButton

	arg0 = (*C.GtkMenuButton)(menuButton.Native())

	ret := C.gtk_menu_button_get_label(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// MenuModel returns the Model used to generate the popup.
func (menuButton menuButton) MenuModel() gio.MenuModel {
	var arg0 *C.GtkMenuButton

	arg0 = (*C.GtkMenuButton)(menuButton.Native())

	ret := C.gtk_menu_button_get_menu_model(arg0)

	var ret0 gio.MenuModel

	ret0 = gio.WrapMenuModel(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Popover returns the Popover that pops out of the button. If the button is
// not using a Popover, this function returns nil.
func (menuButton menuButton) Popover() Popover {
	var arg0 *C.GtkMenuButton

	arg0 = (*C.GtkMenuButton)(menuButton.Native())

	ret := C.gtk_menu_button_get_popover(arg0)

	var ret0 Popover

	ret0 = WrapPopover(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// UseUnderline returns whether an embedded underline in the text indicates
// a mnemonic. See gtk_menu_button_set_use_underline().
func (menuButton menuButton) UseUnderline() bool {
	var arg0 *C.GtkMenuButton

	arg0 = (*C.GtkMenuButton)(menuButton.Native())

	ret := C.gtk_menu_button_get_use_underline(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Popdown dismiss the menu.
func (menuButton menuButton) Popdown() {
	var arg0 *C.GtkMenuButton

	arg0 = (*C.GtkMenuButton)(menuButton.Native())

	C.gtk_menu_button_popdown(arg0)
}

// Popup: pop up the menu.
func (menuButton menuButton) Popup() {
	var arg0 *C.GtkMenuButton

	arg0 = (*C.GtkMenuButton)(menuButton.Native())

	C.gtk_menu_button_popup(arg0)
}

// SetCreatePopupFunc sets @func to be called when a popup is about to be
// shown. @func should use one of
//
//    - gtk_menu_button_set_popover()
//    - gtk_menu_button_set_menu_model()
//
// to set a popup for @menu_button. If @func is non-nil, @menu_button will
// always be sensitive.
//
// Using this function will not reset the menu widget attached to
// @menu_button. Instead, this can be done manually in @func.
func (menuButton menuButton) SetCreatePopupFunc(_func MenuButtonCreatePopupFunc) {
	var arg0 *C.GtkMenuButton
	var arg1 C.GtkMenuButtonCreatePopupFunc
	arg2 := C.gpointer(box.Assign(userData))

	arg0 = (*C.GtkMenuButton)(menuButton.Native())
	arg1 = (*[0]byte)(C.gotk4_MenuButtonCreatePopupFunc)

	C.gtk_menu_button_set_create_popup_func(arg0, arg1, (*[0]byte)(C.callbackDelete))
}

// SetDirection sets the direction in which the popup will be popped up, as
// well as changing the arrow’s direction. The child will not be changed to
// an arrow if it was customized.
//
// If the does not fit in the available space in the given direction, GTK
// will its best to keep it inside the screen and fully visible.
//
// If you pass GTK_ARROW_NONE for a @direction, the popup will behave as if
// you passed GTK_ARROW_DOWN (although you won’t see any arrows).
func (menuButton menuButton) SetDirection(direction ArrowType) {
	var arg0 *C.GtkMenuButton
	var arg1 C.GtkArrowType

	arg0 = (*C.GtkMenuButton)(menuButton.Native())
	arg1 = (C.GtkArrowType)(direction)

	C.gtk_menu_button_set_direction(arg0, arg1)
}

// SetHasFrame sets the style of the button.
func (menuButton menuButton) SetHasFrame(hasFrame bool) {
	var arg0 *C.GtkMenuButton
	var arg1 C.gboolean

	arg0 = (*C.GtkMenuButton)(menuButton.Native())
	arg1 = gextras.Cbool(hasFrame)

	C.gtk_menu_button_set_has_frame(arg0, arg1)
}

// SetIconName sets the name of an icon to show inside the menu button.
func (menuButton menuButton) SetIconName(iconName string) {
	var arg0 *C.GtkMenuButton
	var arg1 *C.char

	arg0 = (*C.GtkMenuButton)(menuButton.Native())
	arg1 = (*C.gchar)(C.CString(iconName))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_menu_button_set_icon_name(arg0, arg1)
}

// SetLabel sets the label to show inside the menu button.
func (menuButton menuButton) SetLabel(label string) {
	var arg0 *C.GtkMenuButton
	var arg1 *C.char

	arg0 = (*C.GtkMenuButton)(menuButton.Native())
	arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_menu_button_set_label(arg0, arg1)
}

// SetMenuModel sets the Model from which the popup will be constructed, or
// nil to dissociate any existing menu model and disable the button.
//
// A Popover will be created from the menu model with
// gtk_popover_menu_new_from_model(). Actions will be connected as
// documented for this function.
//
// If MenuButton:popover is already set, it will be dissociated from the
// @menu_button, and the property is set to nil.
func (menuButton menuButton) SetMenuModel(menuModel gio.MenuModel) {
	var arg0 *C.GtkMenuButton
	var arg1 *C.GMenuModel

	arg0 = (*C.GtkMenuButton)(menuButton.Native())
	arg1 = (*C.GMenuModel)(menuModel.Native())

	C.gtk_menu_button_set_menu_model(arg0, arg1)
}

// SetPopover sets the Popover that will be popped up when the @menu_button
// is clicked, or nil to dissociate any existing popover and disable the
// button.
//
// If MenuButton:menu-model is set, the menu model is dissociated from the
// @menu_button, and the property is set to nil.
func (menuButton menuButton) SetPopover(popover Widget) {
	var arg0 *C.GtkMenuButton
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkMenuButton)(menuButton.Native())
	arg1 = (*C.GtkWidget)(popover.Native())

	C.gtk_menu_button_set_popover(arg0, arg1)
}

// SetUseUnderline: if true, an underline in the text indicates the next
// character should be used for the mnemonic accelerator key.
func (menuButton menuButton) SetUseUnderline(useUnderline bool) {
	var arg0 *C.GtkMenuButton
	var arg1 C.gboolean

	arg0 = (*C.GtkMenuButton)(menuButton.Native())
	arg1 = gextras.Cbool(useUnderline)

	C.gtk_menu_button_set_use_underline(arg0, arg1)
}

// MessageDialog presents a dialog with some message text. It’s simply a
// convenience widget; you could construct the equivalent of MessageDialog from
// Dialog without too much effort, but MessageDialog saves typing.
//
// The easiest way to do a modal message dialog is to use the GTK_DIALOG_MODAL
// flag, which will call gtk_window_set_modal() internally. The dialog will
// prevent interaction with the parent window until it's hidden or destroyed.
// You can use the Dialog::response signal to know when the user dismissed the
// dialog.
//
// An example for using a modal dialog:
//
//     GtkDialogFlags flags = GTK_DIALOG_DESTROY_WITH_PARENT;
//     dialog = gtk_message_dialog_new (parent_window,
//                                      flags,
//                                      GTK_MESSAGE_ERROR,
//                                      GTK_BUTTONS_CLOSE,
//                                      "Error reading “s”: s",
//                                      filename,
//                                      g_strerror (errno));
//
//     // Destroy the dialog when the user responds to it
//     // (e.g. clicks a button)
//     g_signal_connect (dialog, "response",
//                       G_CALLBACK (gtk_window_destroy),
//                       NULL);
//
//
//
// GtkMessageDialog as GtkBuildable
//
// The GtkMessageDialog implementation of the GtkBuildable interface exposes the
// message area as an internal child with the name “message_area”.
type MessageDialog interface {
	Dialog

	// MessageArea returns the message area of the dialog. This is the box where
	// the dialog’s primary and secondary labels are packed. You can add your
	// own extra content to that box and it will appear below those labels. See
	// gtk_dialog_get_content_area() for the corresponding function in the
	// parent Dialog.
	MessageArea() Widget
	// SetMarkup sets the text of the message dialog to be @str, which is marked
	// up with the [Pango text markup language][PangoMarkupFormat].
	SetMarkup(str string)
}

type messageDialog struct {
	dialog
}

// WrapMessageDialog wraps a GObject to the right type. It is
// primarily used internally.
func WrapMessageDialog(obj *externglib.Object) MessageDialog {
	return messageDialog{dialog{window{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}}}
}

func marshalMessageDialog(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapMessageDialog(obj), nil
}

// MessageArea returns the message area of the dialog. This is the box where
// the dialog’s primary and secondary labels are packed. You can add your
// own extra content to that box and it will appear below those labels. See
// gtk_dialog_get_content_area() for the corresponding function in the
// parent Dialog.
func (messageDialog messageDialog) MessageArea() Widget {
	var arg0 *C.GtkMessageDialog

	arg0 = (*C.GtkMessageDialog)(messageDialog.Native())

	ret := C.gtk_message_dialog_get_message_area(arg0)

	var ret0 Widget

	ret0 = WrapWidget(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// SetMarkup sets the text of the message dialog to be @str, which is marked
// up with the [Pango text markup language][PangoMarkupFormat].
func (messageDialog messageDialog) SetMarkup(str string) {
	var arg0 *C.GtkMessageDialog
	var arg1 *C.char

	arg0 = (*C.GtkMessageDialog)(messageDialog.Native())
	arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_message_dialog_set_markup(arg0, arg1)
}

// MnemonicAction: a ShortcutAction that calls gtk_widget_mnemonic_activate().
type MnemonicAction interface {
	ShortcutAction
}

type mnemonicAction struct {
	shortcutAction
}

// WrapMnemonicAction wraps a GObject to the right type. It is
// primarily used internally.
func WrapMnemonicAction(obj *externglib.Object) MnemonicAction {
	return mnemonicAction{shortcutAction{*externglib.Object{obj}}}
}

func marshalMnemonicAction(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapMnemonicAction(obj), nil
}

// MnemonicTrigger: a ShortcutTrigger that triggers when a specific mnemonic is
// pressed.
type MnemonicTrigger interface {
	ShortcutTrigger

	// Keyval gets the keyval that must be pressed to succeed triggering @self.
	Keyval() uint
}

type mnemonicTrigger struct {
	shortcutTrigger
}

// WrapMnemonicTrigger wraps a GObject to the right type. It is
// primarily used internally.
func WrapMnemonicTrigger(obj *externglib.Object) MnemonicTrigger {
	return mnemonicTrigger{shortcutTrigger{*externglib.Object{obj}}}
}

func marshalMnemonicTrigger(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapMnemonicTrigger(obj), nil
}

// NewMnemonicTrigger constructs a class MnemonicTrigger.
func NewMnemonicTrigger(keyval uint) MnemonicTrigger {
	var arg1 C.guint

	arg1 = C.guint(keyval)

	ret := C.gtk_mnemonic_trigger_new(arg1)

	var ret0 MnemonicTrigger

	ret0 = WrapMnemonicTrigger(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Keyval gets the keyval that must be pressed to succeed triggering @self.
func (self mnemonicTrigger) Keyval() uint {
	var arg0 *C.GtkMnemonicTrigger

	arg0 = (*C.GtkMnemonicTrigger)(self.Native())

	ret := C.gtk_mnemonic_trigger_get_keyval(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// MountOperation: this should not be accessed directly. Use the accessor
// functions below.
type MountOperation interface {
	gio.MountOperation

	// Display gets the display on which windows of the MountOperation will be
	// shown.
	Display() gdk.Display
	// Parent gets the transient parent used by the MountOperation
	Parent() Window
	// IsShowing returns whether the MountOperation is currently displaying a
	// window.
	IsShowing() bool
	// SetDisplay sets the display to show windows of the MountOperation on.
	SetDisplay(display gdk.Display)
	// SetParent sets the transient parent for windows shown by the
	// MountOperation.
	SetParent(parent Window)
}

type mountOperation struct {
	gio.MountOperation
}

// WrapMountOperation wraps a GObject to the right type. It is
// primarily used internally.
func WrapMountOperation(obj *externglib.Object) MountOperation {
	return mountOperation{gio.WrapMountOperation(obj)}
}

func marshalMountOperation(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapMountOperation(obj), nil
}

// NewMountOperation constructs a class MountOperation.
func NewMountOperation(parent Window) MountOperation {
	var arg1 *C.GtkWindow

	arg1 = (*C.GtkWindow)(parent.Native())

	ret := C.gtk_mount_operation_new(arg1)

	var ret0 MountOperation

	ret0 = WrapMountOperation(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Display gets the display on which windows of the MountOperation will be
// shown.
func (op mountOperation) Display() gdk.Display {
	var arg0 *C.GtkMountOperation

	arg0 = (*C.GtkMountOperation)(op.Native())

	ret := C.gtk_mount_operation_get_display(arg0)

	var ret0 gdk.Display

	ret0 = gdk.WrapDisplay(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Parent gets the transient parent used by the MountOperation
func (op mountOperation) Parent() Window {
	var arg0 *C.GtkMountOperation

	arg0 = (*C.GtkMountOperation)(op.Native())

	ret := C.gtk_mount_operation_get_parent(arg0)

	var ret0 Window

	ret0 = WrapWindow(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// IsShowing returns whether the MountOperation is currently displaying a
// window.
func (op mountOperation) IsShowing() bool {
	var arg0 *C.GtkMountOperation

	arg0 = (*C.GtkMountOperation)(op.Native())

	ret := C.gtk_mount_operation_is_showing(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// SetDisplay sets the display to show windows of the MountOperation on.
func (op mountOperation) SetDisplay(display gdk.Display) {
	var arg0 *C.GtkMountOperation
	var arg1 *C.GdkDisplay

	arg0 = (*C.GtkMountOperation)(op.Native())
	arg1 = (*C.GdkDisplay)(display.Native())

	C.gtk_mount_operation_set_display(arg0, arg1)
}

// SetParent sets the transient parent for windows shown by the
// MountOperation.
func (op mountOperation) SetParent(parent Window) {
	var arg0 *C.GtkMountOperation
	var arg1 *C.GtkWindow

	arg0 = (*C.GtkMountOperation)(op.Native())
	arg1 = (*C.GtkWindow)(parent.Native())

	C.gtk_mount_operation_set_parent(arg0, arg1)
}

// MultiFilter: gtkMultiFilter is the base type that implements support for
// handling multiple filters.
//
// GtkAnyFilter is a subclass of GtkMultiFilter that matches an item when at
// least one of its filters matches.
//
// GtkEveryFilter is a subclass of GtkMultiFilter that matches an item when each
// of its filters matches.
type MultiFilter interface {
	Filter

	// Append adds a @filter to @self to use for matching.
	Append(filter Filter)
	// Remove removes the filter at the given @position from the list of filters
	// used by @self. If @position is larger than the number of filters, nothing
	// happens and the function returns.
	Remove(position uint)
}

type multiFilter struct {
	filter
}

// WrapMultiFilter wraps a GObject to the right type. It is
// primarily used internally.
func WrapMultiFilter(obj *externglib.Object) MultiFilter {
	return multiFilter{filter{*externglib.Object{obj}}}
}

func marshalMultiFilter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapMultiFilter(obj), nil
}

// Append adds a @filter to @self to use for matching.
func (self multiFilter) Append(filter Filter) {
	var arg0 *C.GtkMultiFilter
	var arg1 *C.GtkFilter

	arg0 = (*C.GtkMultiFilter)(self.Native())
	arg1 = (*C.GtkFilter)(filter.Native())

	C.gtk_multi_filter_append(arg0, arg1)
}

// Remove removes the filter at the given @position from the list of filters
// used by @self. If @position is larger than the number of filters, nothing
// happens and the function returns.
func (self multiFilter) Remove(position uint) {
	var arg0 *C.GtkMultiFilter
	var arg1 C.guint

	arg0 = (*C.GtkMultiFilter)(self.Native())
	arg1 = C.guint(position)

	C.gtk_multi_filter_remove(arg0, arg1)
}

// MultiSelection: gtkMultiSelection is an implementation of the SelectionModel
// interface that allows selecting multiple elements.
type MultiSelection interface {
	gextras.Objector

	// Model returns the underlying model of @self.
	Model() gio.ListModel
	// SetModel sets the model that @self should wrap. If @model is nil, @self
	// will be empty.
	SetModel(model gio.ListModel)
}

type multiSelection struct {
	*externglib.Object
}

// WrapMultiSelection wraps a GObject to the right type. It is
// primarily used internally.
func WrapMultiSelection(obj *externglib.Object) MultiSelection {
	return multiSelection{*externglib.Object{obj}}
}

func marshalMultiSelection(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapMultiSelection(obj), nil
}

// NewMultiSelection constructs a class MultiSelection.
func NewMultiSelection(model gio.ListModel) MultiSelection {
	var arg1 *C.GListModel

	ret := C.gtk_multi_selection_new(arg1)

	var ret0 MultiSelection

	ret0 = WrapMultiSelection(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Model returns the underlying model of @self.
func (self multiSelection) Model() gio.ListModel {
	var arg0 *C.GtkMultiSelection

	arg0 = (*C.GtkMultiSelection)(self.Native())

	ret := C.gtk_multi_selection_get_model(arg0)

	var ret0 gio.ListModel

	return ret0
}

// SetModel sets the model that @self should wrap. If @model is nil, @self
// will be empty.
func (self multiSelection) SetModel(model gio.ListModel) {
	var arg0 *C.GtkMultiSelection
	var arg1 *C.GListModel

	arg0 = (*C.GtkMultiSelection)(self.Native())

	C.gtk_multi_selection_set_model(arg0, arg1)
}

// MultiSorter: gtkMultiSorter combines multiple sorters by trying them in turn.
// If the first sorter compares two items as equal, the second is tried next,
// and so on.
type MultiSorter interface {
	Sorter

	// Append: add @sorter to @self to use for sorting at the end. @self will
	// consult all existing sorters before it will sort with the given @sorter.
	Append(sorter Sorter)
	// Remove removes the sorter at the given @position from the list of sorter
	// used by @self.
	//
	// If @position is larger than the number of sorters, nothing happens.
	Remove(position uint)
}

type multiSorter struct {
	sorter
}

// WrapMultiSorter wraps a GObject to the right type. It is
// primarily used internally.
func WrapMultiSorter(obj *externglib.Object) MultiSorter {
	return multiSorter{sorter{*externglib.Object{obj}}}
}

func marshalMultiSorter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapMultiSorter(obj), nil
}

// NewMultiSorter constructs a class MultiSorter.
func NewMultiSorter() MultiSorter {

	ret := C.gtk_multi_sorter_new()

	var ret0 MultiSorter

	ret0 = WrapMultiSorter(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Append: add @sorter to @self to use for sorting at the end. @self will
// consult all existing sorters before it will sort with the given @sorter.
func (self multiSorter) Append(sorter Sorter) {
	var arg0 *C.GtkMultiSorter
	var arg1 *C.GtkSorter

	arg0 = (*C.GtkMultiSorter)(self.Native())
	arg1 = (*C.GtkSorter)(sorter.Native())

	C.gtk_multi_sorter_append(arg0, arg1)
}

// Remove removes the sorter at the given @position from the list of sorter
// used by @self.
//
// If @position is larger than the number of sorters, nothing happens.
func (self multiSorter) Remove(position uint) {
	var arg0 *C.GtkMultiSorter
	var arg1 C.guint

	arg0 = (*C.GtkMultiSorter)(self.Native())
	arg1 = C.guint(position)

	C.gtk_multi_sorter_remove(arg0, arg1)
}

// NamedAction: a ShortcutAction that activates an action by name.
type NamedAction interface {
	ShortcutAction

	// ActionName returns the name of the action that will be activated.
	ActionName() string
}

type namedAction struct {
	shortcutAction
}

// WrapNamedAction wraps a GObject to the right type. It is
// primarily used internally.
func WrapNamedAction(obj *externglib.Object) NamedAction {
	return namedAction{shortcutAction{*externglib.Object{obj}}}
}

func marshalNamedAction(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapNamedAction(obj), nil
}

// NewNamedAction constructs a class NamedAction.
func NewNamedAction(name string) NamedAction {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_named_action_new(arg1)

	var ret0 NamedAction

	ret0 = WrapNamedAction(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// ActionName returns the name of the action that will be activated.
func (self namedAction) ActionName() string {
	var arg0 *C.GtkNamedAction

	arg0 = (*C.GtkNamedAction)(self.Native())

	ret := C.gtk_named_action_get_action_name(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// NativeDialog: native dialogs are platform dialogs that don't use Dialog or
// Window. They are used in order to integrate better with a platform, by
// looking the same as other native applications and supporting platform
// specific features.
//
// The Dialog functions cannot be used on such objects, but we need a similar
// API in order to drive them. The NativeDialog object is an API that allows you
// to do this. It allows you to set various common properties on the dialog, as
// well as show and hide it and get a NativeDialog::response signal when the
// user finished with the dialog.
//
// Note that unlike Dialog, NativeDialog objects are not toplevel widgets, and
// GTK does not keep them alive. It is your responsibility to keep a reference
// until you are done with the object.
type NativeDialog interface {
	gextras.Objector

	// Destroy destroys a dialog.
	//
	// When a dialog is destroyed, it will break any references it holds to
	// other objects. If it is visible it will be hidden and any underlying
	// window system resources will be destroyed.
	//
	// Note that this does not release any reference to the object (as opposed
	// to destroying a GtkWindow) because there is no reference from the
	// windowing system to the NativeDialog.
	Destroy()
	// Modal returns whether the dialog is modal. See
	// gtk_native_dialog_set_modal().
	Modal() bool
	// Title gets the title of the NativeDialog.
	Title() string
	// TransientFor fetches the transient parent for this window. See
	// gtk_native_dialog_set_transient_for().
	TransientFor() Window
	// Visible determines whether the dialog is visible.
	Visible() bool
	// Hide hides the dialog if it is visilbe, aborting any interaction. Once
	// this is called the NativeDialog::response signal will not be emitted
	// until after the next call to gtk_native_dialog_show().
	//
	// If the dialog is not visible this does nothing.
	Hide()
	// SetModal sets a dialog modal or non-modal. Modal dialogs prevent
	// interaction with other windows in the same application. To keep modal
	// dialogs on top of main application windows, use
	// gtk_native_dialog_set_transient_for() to make the dialog transient for
	// the parent; most [window managers][gtk-X11-arch] will then disallow
	// lowering the dialog below the parent.
	SetModal(modal bool)
	// SetTitle sets the title of the NativeDialog.
	SetTitle(title string)
	// SetTransientFor: dialog windows should be set transient for the main
	// application window they were spawned from. This allows [window
	// managers][gtk-X11-arch] to e.g. keep the dialog on top of the main
	// window, or center the dialog over the main window.
	//
	// Passing nil for @parent unsets the current transient window.
	SetTransientFor(parent Window)
	// Show shows the dialog on the display, allowing the user to interact with
	// it. When the user accepts the state of the dialog the dialog will be
	// automatically hidden and the NativeDialog::response signal will be
	// emitted.
	//
	// Multiple calls while the dialog is visible will be ignored.
	Show()
}

type nativeDialog struct {
	*externglib.Object
}

// WrapNativeDialog wraps a GObject to the right type. It is
// primarily used internally.
func WrapNativeDialog(obj *externglib.Object) NativeDialog {
	return nativeDialog{*externglib.Object{obj}}
}

func marshalNativeDialog(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapNativeDialog(obj), nil
}

// Destroy destroys a dialog.
//
// When a dialog is destroyed, it will break any references it holds to
// other objects. If it is visible it will be hidden and any underlying
// window system resources will be destroyed.
//
// Note that this does not release any reference to the object (as opposed
// to destroying a GtkWindow) because there is no reference from the
// windowing system to the NativeDialog.
func (self nativeDialog) Destroy() {
	var arg0 *C.GtkNativeDialog

	arg0 = (*C.GtkNativeDialog)(self.Native())

	C.gtk_native_dialog_destroy(arg0)
}

// Modal returns whether the dialog is modal. See
// gtk_native_dialog_set_modal().
func (self nativeDialog) Modal() bool {
	var arg0 *C.GtkNativeDialog

	arg0 = (*C.GtkNativeDialog)(self.Native())

	ret := C.gtk_native_dialog_get_modal(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Title gets the title of the NativeDialog.
func (self nativeDialog) Title() string {
	var arg0 *C.GtkNativeDialog

	arg0 = (*C.GtkNativeDialog)(self.Native())

	ret := C.gtk_native_dialog_get_title(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// TransientFor fetches the transient parent for this window. See
// gtk_native_dialog_set_transient_for().
func (self nativeDialog) TransientFor() Window {
	var arg0 *C.GtkNativeDialog

	arg0 = (*C.GtkNativeDialog)(self.Native())

	ret := C.gtk_native_dialog_get_transient_for(arg0)

	var ret0 Window

	ret0 = WrapWindow(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Visible determines whether the dialog is visible.
func (self nativeDialog) Visible() bool {
	var arg0 *C.GtkNativeDialog

	arg0 = (*C.GtkNativeDialog)(self.Native())

	ret := C.gtk_native_dialog_get_visible(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Hide hides the dialog if it is visilbe, aborting any interaction. Once
// this is called the NativeDialog::response signal will not be emitted
// until after the next call to gtk_native_dialog_show().
//
// If the dialog is not visible this does nothing.
func (self nativeDialog) Hide() {
	var arg0 *C.GtkNativeDialog

	arg0 = (*C.GtkNativeDialog)(self.Native())

	C.gtk_native_dialog_hide(arg0)
}

// SetModal sets a dialog modal or non-modal. Modal dialogs prevent
// interaction with other windows in the same application. To keep modal
// dialogs on top of main application windows, use
// gtk_native_dialog_set_transient_for() to make the dialog transient for
// the parent; most [window managers][gtk-X11-arch] will then disallow
// lowering the dialog below the parent.
func (self nativeDialog) SetModal(modal bool) {
	var arg0 *C.GtkNativeDialog
	var arg1 C.gboolean

	arg0 = (*C.GtkNativeDialog)(self.Native())
	arg1 = gextras.Cbool(modal)

	C.gtk_native_dialog_set_modal(arg0, arg1)
}

// SetTitle sets the title of the NativeDialog.
func (self nativeDialog) SetTitle(title string) {
	var arg0 *C.GtkNativeDialog
	var arg1 *C.char

	arg0 = (*C.GtkNativeDialog)(self.Native())
	arg1 = (*C.gchar)(C.CString(title))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_native_dialog_set_title(arg0, arg1)
}

// SetTransientFor: dialog windows should be set transient for the main
// application window they were spawned from. This allows [window
// managers][gtk-X11-arch] to e.g. keep the dialog on top of the main
// window, or center the dialog over the main window.
//
// Passing nil for @parent unsets the current transient window.
func (self nativeDialog) SetTransientFor(parent Window) {
	var arg0 *C.GtkNativeDialog
	var arg1 *C.GtkWindow

	arg0 = (*C.GtkNativeDialog)(self.Native())
	arg1 = (*C.GtkWindow)(parent.Native())

	C.gtk_native_dialog_set_transient_for(arg0, arg1)
}

// Show shows the dialog on the display, allowing the user to interact with
// it. When the user accepts the state of the dialog the dialog will be
// automatically hidden and the NativeDialog::response signal will be
// emitted.
//
// Multiple calls while the dialog is visible will be ignored.
func (self nativeDialog) Show() {
	var arg0 *C.GtkNativeDialog

	arg0 = (*C.GtkNativeDialog)(self.Native())

	C.gtk_native_dialog_show(arg0)
}

// NeverTrigger: a ShortcutTrigger that never triggers.
type NeverTrigger interface {
	ShortcutTrigger
}

type neverTrigger struct {
	shortcutTrigger
}

// WrapNeverTrigger wraps a GObject to the right type. It is
// primarily used internally.
func WrapNeverTrigger(obj *externglib.Object) NeverTrigger {
	return neverTrigger{shortcutTrigger{*externglib.Object{obj}}}
}

func marshalNeverTrigger(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapNeverTrigger(obj), nil
}

// NoSelection: gtkNoSelection is an implementation of the SelectionModel
// interface that does not allow selecting anything.
//
// This model is meant to be used as a simple wrapper to Models when a
// SelectionModel is required.
type NoSelection interface {
	gextras.Objector

	// Model gets the model that @self is wrapping.
	Model() gio.ListModel
	// SetModel sets the model that @self should wrap. If @model is nil, this
	// model will be empty.
	SetModel(model gio.ListModel)
}

type noSelection struct {
	*externglib.Object
}

// WrapNoSelection wraps a GObject to the right type. It is
// primarily used internally.
func WrapNoSelection(obj *externglib.Object) NoSelection {
	return noSelection{*externglib.Object{obj}}
}

func marshalNoSelection(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapNoSelection(obj), nil
}

// NewNoSelection constructs a class NoSelection.
func NewNoSelection(model gio.ListModel) NoSelection {
	var arg1 *C.GListModel

	ret := C.gtk_no_selection_new(arg1)

	var ret0 NoSelection

	ret0 = WrapNoSelection(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Model gets the model that @self is wrapping.
func (self noSelection) Model() gio.ListModel {
	var arg0 *C.GtkNoSelection

	arg0 = (*C.GtkNoSelection)(self.Native())

	ret := C.gtk_no_selection_get_model(arg0)

	var ret0 gio.ListModel

	return ret0
}

// SetModel sets the model that @self should wrap. If @model is nil, this
// model will be empty.
func (self noSelection) SetModel(model gio.ListModel) {
	var arg0 *C.GtkNoSelection
	var arg1 *C.GListModel

	arg0 = (*C.GtkNoSelection)(self.Native())

	C.gtk_no_selection_set_model(arg0, arg1)
}

// Notebook: the Notebook widget is a layout container whose children are pages
// that can be switched between using tab labels along one edge.
//
// There are many configuration options for GtkNotebook. Among other things, you
// can choose on which edge the tabs appear (see gtk_notebook_set_tab_pos()),
// whether, if there are too many tabs to fit the notebook should be made bigger
// or scrolling arrows added (see gtk_notebook_set_scrollable()), and whether
// there will be a popup menu allowing the users to switch pages. (see
// gtk_notebook_popup_enable(), gtk_notebook_popup_disable())
//
//
// GtkNotebook as GtkBuildable
//
// The GtkNotebook implementation of the Buildable interface supports placing
// children into tabs by specifying “tab” as the “type” attribute of a <child>
// element. Note that the content of the tab must be created before the tab can
// be filled. A tab child can be specified without specifying a <child> type
// attribute.
//
// To add a child widget in the notebooks action area, specify "action-start" or
// “action-end” as the “type” attribute of the <child> element.
//
// An example of a UI definition fragment with GtkNotebook:
//
//
//    <object class="GtkNotebook">
//      <child>
//        <object class="GtkLabel" id="notebook-content">
//          <property name="label">Content</property>
//        </object>
//      </child>
//      <child type="tab">
//        <object class="GtkLabel" id="notebook-tab">
//          <property name="label">Tab</property>
//        </object>
//      </child>
//    </object>
//    ]|
//
//
//
// CSS nodes
//
//
//    |[<!-- language="plain" -->
//    notebook
//    ├── header.top
//    │   ├── [<action widget>]
//    │   ├── tabs
//    │   │   ├── [arrow]
//    │   │   ├── tab
//    │   │   │   ╰── <tab label>
//    ┊   ┊   ┊
//    │   │   ├── tab[.reorderable-page]
//    │   │   │   ╰── <tab label>
//    │   │   ╰── [arrow]
//    │   ╰── [<action widget>]
//    │
//    ╰── stack
//        ├── <child>
//        ┊
//        ╰── <child>
//
//
// GtkNotebook has a main CSS node with name `notebook`, a subnode with name
// `header` and below that a subnode with name `tabs` which contains one subnode
// per tab with name `tab`.
//
// If action widgets are present, their CSS nodes are placed next to the `tabs`
// node. If the notebook is scrollable, CSS nodes with name `arrow` are placed
// as first and last child of the `tabs` node.
//
// The main node gets the `.frame` style class when the notebook has a border
// (see gtk_notebook_set_show_border()).
//
// The header node gets one of the style class `.top`, `.bottom`, `.left` or
// `.right`, depending on where the tabs are placed. For reorderable pages, the
// tab node gets the `.reorderable-page` class.
//
// A `tab` node gets the `.dnd` style class while it is moved with
// drag-and-drop.
//
// The nodes are always arranged from left-to-right, regardless of text
// direction.
//
//
// Accessibility
//
// GtkNotebook uses the following roles:
//
//    - GTK_ACCESSIBLE_ROLE_GROUP for the notebook widget
//    - GTK_ACCESSIBLE_ROLE_TAB_LIST for the list of tabs
//    - GTK_ACCESSIBLE_ROLE_TAB role for each tab
//    - GTK_ACCESSIBLE_ROLE_TAB_PANEL for each page
type Notebook interface {
	Widget

	// AppendPage appends a page to @notebook.
	AppendPage(child Widget, tabLabel Widget) int
	// AppendPageMenu appends a page to @notebook, specifying the widget to use
	// as the label in the popup menu.
	AppendPageMenu(child Widget, tabLabel Widget, menuLabel Widget) int
	// DetachTab removes the child from the notebook.
	//
	// This function is very similar to gtk_notebook_remove_page(), but
	// additionally informs the notebook that the removal is happening as part
	// of a tab DND operation, which should not be cancelled.
	DetachTab(child Widget)
	// ActionWidget gets one of the action widgets. See
	// gtk_notebook_set_action_widget().
	ActionWidget(packType PackType) Widget
	// CurrentPage returns the page number of the current page.
	CurrentPage() int
	// GroupName gets the current group name for @notebook.
	GroupName() string
	// MenuLabel retrieves the menu label widget of the page containing @child.
	MenuLabel(child Widget) Widget
	// MenuLabelText retrieves the text of the menu label for the page
	// containing @child.
	MenuLabelText(child Widget) string
	// NPages gets the number of pages in a notebook.
	NPages() int
	// NthPage returns the child widget contained in page number @page_num.
	NthPage(pageNum int) Widget
	// Page returns the NotebookPage for @child.
	Page(child Widget) NotebookPage
	// Pages returns a Model that contains the pages of the notebook, and can be
	// used to keep an up-to-date view.
	Pages() gio.ListModel
	// Scrollable returns whether the tab label area has arrows for scrolling.
	// See gtk_notebook_set_scrollable().
	Scrollable() bool
	// ShowBorder returns whether a bevel will be drawn around the notebook
	// pages. See gtk_notebook_set_show_border().
	ShowBorder() bool
	// ShowTabs returns whether the tabs of the notebook are shown. See
	// gtk_notebook_set_show_tabs().
	ShowTabs() bool
	// TabDetachable returns whether the tab contents can be detached from
	// @notebook.
	TabDetachable(child Widget) bool
	// TabLabel returns the tab label widget for the page @child. nil is
	// returned if @child is not in @notebook or if no tab label has
	// specifically been set for @child.
	TabLabel(child Widget) Widget
	// TabLabelText retrieves the text of the tab label for the page containing
	// @child.
	TabLabelText(child Widget) string
	// TabPos gets the edge at which the tabs for switching pages in the
	// notebook are drawn.
	TabPos() PositionType
	// TabReorderable gets whether the tab can be reordered via drag and drop or
	// not.
	TabReorderable(child Widget) bool
	// InsertPage: insert a page into @notebook at the given position.
	InsertPage(child Widget, tabLabel Widget, position int) int
	// InsertPageMenu: insert a page into @notebook at the given position,
	// specifying the widget to use as the label in the popup menu.
	InsertPageMenu(child Widget, tabLabel Widget, menuLabel Widget, position int) int
	// NextPage switches to the next page. Nothing happens if the current page
	// is the last page.
	NextPage()
	// PageNum finds the index of the page which contains the given child
	// widget.
	PageNum(child Widget) int
	// PopupDisable disables the popup menu.
	PopupDisable()
	// PopupEnable enables the popup menu: if the user clicks with the right
	// mouse button on the tab labels, a menu with all the pages will be popped
	// up.
	PopupEnable()
	// PrependPage prepends a page to @notebook.
	PrependPage(child Widget, tabLabel Widget) int
	// PrependPageMenu prepends a page to @notebook, specifying the widget to
	// use as the label in the popup menu.
	PrependPageMenu(child Widget, tabLabel Widget, menuLabel Widget) int
	// PrevPage switches to the previous page. Nothing happens if the current
	// page is the first page.
	PrevPage()
	// RemovePage removes a page from the notebook given its index in the
	// notebook.
	RemovePage(pageNum int)
	// ReorderChild reorders the page containing @child, so that it appears in
	// position @position. If @position is greater than or equal to the number
	// of children in the list or negative, @child will be moved to the end of
	// the list.
	ReorderChild(child Widget, position int)
	// SetActionWidget sets @widget as one of the action widgets. Depending on
	// the pack type the widget will be placed before or after the tabs. You can
	// use a Box if you need to pack more than one widget on the same side.
	SetActionWidget(widget Widget, packType PackType)
	// SetCurrentPage switches to the page number @page_num.
	//
	// Note that due to historical reasons, GtkNotebook refuses to switch to a
	// page unless the child widget is visible. Therefore, it is recommended to
	// show child widgets before adding them to a notebook.
	SetCurrentPage(pageNum int)
	// SetGroupName sets a group name for @notebook.
	//
	// Notebooks with the same name will be able to exchange tabs via drag and
	// drop. A notebook with a nil group name will not be able to exchange tabs
	// with any other notebook.
	SetGroupName(groupName string)
	// SetMenuLabel changes the menu label for the page containing @child.
	SetMenuLabel(child Widget, menuLabel Widget)
	// SetMenuLabelText creates a new label and sets it as the menu label of
	// @child.
	SetMenuLabelText(child Widget, menuText string)
	// SetScrollable sets whether the tab label area will have arrows for
	// scrolling if there are too many tabs to fit in the area.
	SetScrollable(scrollable bool)
	// SetShowBorder sets whether a bevel will be drawn around the notebook
	// pages. This only has a visual effect when the tabs are not shown. See
	// gtk_notebook_set_show_tabs().
	SetShowBorder(showBorder bool)
	// SetShowTabs sets whether to show the tabs for the notebook or not.
	SetShowTabs(showTabs bool)
	// SetTabDetachable sets whether the tab can be detached from @notebook to
	// another notebook or widget.
	//
	// Note that 2 notebooks must share a common group identificator (see
	// gtk_notebook_set_group_name()) to allow automatic tabs interchange
	// between them.
	//
	// If you want a widget to interact with a notebook through DnD (i.e.:
	// accept dragged tabs from it) it must be set as a drop destination and
	// accept the target “GTK_NOTEBOOK_TAB”. The notebook will fill the
	// selection with a GtkWidget** pointing to the child widget that
	// corresponds to the dropped tab.
	//
	// Note that you should use gtk_notebook_detach_tab() instead of
	// gtk_notebook_remove_page() if you want to remove the tab from the source
	// notebook as part of accepting a drop. Otherwise, the source notebook will
	// think that the dragged tab was removed from underneath the ongoing drag
	// operation, and will initiate a drag cancel animation.
	//
	//     static void
	//     on_drag_data_received (GtkWidget        *widget,
	//                            GdkDrop          *drop,
	//                            GtkSelectionData *data,
	//                            guint             time,
	//                            gpointer          user_data)
	//     {
	//       GtkDrag *drag;
	//       GtkWidget *notebook;
	//       GtkWidget **child;
	//
	//       drag = gtk_drop_get_drag (drop);
	//       notebook = g_object_get_data (drag, "gtk-notebook-drag-origin");
	//       child = (void*) gtk_selection_data_get_data (data);
	//
	//       // process_widget (*child);
	//
	//       gtk_notebook_detach_tab (GTK_NOTEBOOK (notebook), *child);
	//     }
	//
	//
	// If you want a notebook to accept drags from other widgets, you will have
	// to set your own DnD code to do it.
	SetTabDetachable(child Widget, detachable bool)
	// SetTabLabel changes the tab label for @child. If nil is specified for
	// @tab_label, then the page will have the label “page N”.
	SetTabLabel(child Widget, tabLabel Widget)
	// SetTabLabelText creates a new label and sets it as the tab label for the
	// page containing @child.
	SetTabLabelText(child Widget, tabText string)
	// SetTabPos sets the edge at which the tabs for switching pages in the
	// notebook are drawn.
	SetTabPos(pos PositionType)
	// SetTabReorderable sets whether the notebook tab can be reordered via drag
	// and drop or not.
	SetTabReorderable(child Widget, reorderable bool)
}

type notebook struct {
	widget
}

// WrapNotebook wraps a GObject to the right type. It is
// primarily used internally.
func WrapNotebook(obj *externglib.Object) Notebook {
	return notebook{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}
}

func marshalNotebook(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapNotebook(obj), nil
}

// NewNotebook constructs a class Notebook.
func NewNotebook() Notebook {

	ret := C.gtk_notebook_new()

	var ret0 Notebook

	ret0 = WrapNotebook(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// AppendPage appends a page to @notebook.
func (notebook notebook) AppendPage(child Widget, tabLabel Widget) int {
	var arg0 *C.GtkNotebook
	var arg1 *C.GtkWidget
	var arg2 *C.GtkWidget

	arg0 = (*C.GtkNotebook)(notebook.Native())
	arg1 = (*C.GtkWidget)(child.Native())
	arg2 = (*C.GtkWidget)(tabLabel.Native())

	ret := C.gtk_notebook_append_page(arg0, arg1, arg2)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// AppendPageMenu appends a page to @notebook, specifying the widget to use
// as the label in the popup menu.
func (notebook notebook) AppendPageMenu(child Widget, tabLabel Widget, menuLabel Widget) int {
	var arg0 *C.GtkNotebook
	var arg1 *C.GtkWidget
	var arg2 *C.GtkWidget
	var arg3 *C.GtkWidget

	arg0 = (*C.GtkNotebook)(notebook.Native())
	arg1 = (*C.GtkWidget)(child.Native())
	arg2 = (*C.GtkWidget)(tabLabel.Native())
	arg3 = (*C.GtkWidget)(menuLabel.Native())

	ret := C.gtk_notebook_append_page_menu(arg0, arg1, arg2, arg3)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// DetachTab removes the child from the notebook.
//
// This function is very similar to gtk_notebook_remove_page(), but
// additionally informs the notebook that the removal is happening as part
// of a tab DND operation, which should not be cancelled.
func (notebook notebook) DetachTab(child Widget) {
	var arg0 *C.GtkNotebook
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkNotebook)(notebook.Native())
	arg1 = (*C.GtkWidget)(child.Native())

	C.gtk_notebook_detach_tab(arg0, arg1)
}

// ActionWidget gets one of the action widgets. See
// gtk_notebook_set_action_widget().
func (notebook notebook) ActionWidget(packType PackType) Widget {
	var arg0 *C.GtkNotebook
	var arg1 C.GtkPackType

	arg0 = (*C.GtkNotebook)(notebook.Native())
	arg1 = (C.GtkPackType)(packType)

	ret := C.gtk_notebook_get_action_widget(arg0, arg1)

	var ret0 Widget

	ret0 = WrapWidget(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// CurrentPage returns the page number of the current page.
func (notebook notebook) CurrentPage() int {
	var arg0 *C.GtkNotebook

	arg0 = (*C.GtkNotebook)(notebook.Native())

	ret := C.gtk_notebook_get_current_page(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// GroupName gets the current group name for @notebook.
func (notebook notebook) GroupName() string {
	var arg0 *C.GtkNotebook

	arg0 = (*C.GtkNotebook)(notebook.Native())

	ret := C.gtk_notebook_get_group_name(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// MenuLabel retrieves the menu label widget of the page containing @child.
func (notebook notebook) MenuLabel(child Widget) Widget {
	var arg0 *C.GtkNotebook
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkNotebook)(notebook.Native())
	arg1 = (*C.GtkWidget)(child.Native())

	ret := C.gtk_notebook_get_menu_label(arg0, arg1)

	var ret0 Widget

	ret0 = WrapWidget(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// MenuLabelText retrieves the text of the menu label for the page
// containing @child.
func (notebook notebook) MenuLabelText(child Widget) string {
	var arg0 *C.GtkNotebook
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkNotebook)(notebook.Native())
	arg1 = (*C.GtkWidget)(child.Native())

	ret := C.gtk_notebook_get_menu_label_text(arg0, arg1)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// NPages gets the number of pages in a notebook.
func (notebook notebook) NPages() int {
	var arg0 *C.GtkNotebook

	arg0 = (*C.GtkNotebook)(notebook.Native())

	ret := C.gtk_notebook_get_n_pages(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// NthPage returns the child widget contained in page number @page_num.
func (notebook notebook) NthPage(pageNum int) Widget {
	var arg0 *C.GtkNotebook
	var arg1 C.int

	arg0 = (*C.GtkNotebook)(notebook.Native())
	arg1 = C.int(pageNum)

	ret := C.gtk_notebook_get_nth_page(arg0, arg1)

	var ret0 Widget

	ret0 = WrapWidget(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Page returns the NotebookPage for @child.
func (notebook notebook) Page(child Widget) NotebookPage {
	var arg0 *C.GtkNotebook
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkNotebook)(notebook.Native())
	arg1 = (*C.GtkWidget)(child.Native())

	ret := C.gtk_notebook_get_page(arg0, arg1)

	var ret0 NotebookPage

	ret0 = WrapNotebookPage(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Pages returns a Model that contains the pages of the notebook, and can be
// used to keep an up-to-date view.
func (notebook notebook) Pages() gio.ListModel {
	var arg0 *C.GtkNotebook

	arg0 = (*C.GtkNotebook)(notebook.Native())

	ret := C.gtk_notebook_get_pages(arg0)

	var ret0 gio.ListModel

	return ret0
}

// Scrollable returns whether the tab label area has arrows for scrolling.
// See gtk_notebook_set_scrollable().
func (notebook notebook) Scrollable() bool {
	var arg0 *C.GtkNotebook

	arg0 = (*C.GtkNotebook)(notebook.Native())

	ret := C.gtk_notebook_get_scrollable(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// ShowBorder returns whether a bevel will be drawn around the notebook
// pages. See gtk_notebook_set_show_border().
func (notebook notebook) ShowBorder() bool {
	var arg0 *C.GtkNotebook

	arg0 = (*C.GtkNotebook)(notebook.Native())

	ret := C.gtk_notebook_get_show_border(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// ShowTabs returns whether the tabs of the notebook are shown. See
// gtk_notebook_set_show_tabs().
func (notebook notebook) ShowTabs() bool {
	var arg0 *C.GtkNotebook

	arg0 = (*C.GtkNotebook)(notebook.Native())

	ret := C.gtk_notebook_get_show_tabs(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// TabDetachable returns whether the tab contents can be detached from
// @notebook.
func (notebook notebook) TabDetachable(child Widget) bool {
	var arg0 *C.GtkNotebook
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkNotebook)(notebook.Native())
	arg1 = (*C.GtkWidget)(child.Native())

	ret := C.gtk_notebook_get_tab_detachable(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// TabLabel returns the tab label widget for the page @child. nil is
// returned if @child is not in @notebook or if no tab label has
// specifically been set for @child.
func (notebook notebook) TabLabel(child Widget) Widget {
	var arg0 *C.GtkNotebook
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkNotebook)(notebook.Native())
	arg1 = (*C.GtkWidget)(child.Native())

	ret := C.gtk_notebook_get_tab_label(arg0, arg1)

	var ret0 Widget

	ret0 = WrapWidget(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// TabLabelText retrieves the text of the tab label for the page containing
// @child.
func (notebook notebook) TabLabelText(child Widget) string {
	var arg0 *C.GtkNotebook
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkNotebook)(notebook.Native())
	arg1 = (*C.GtkWidget)(child.Native())

	ret := C.gtk_notebook_get_tab_label_text(arg0, arg1)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// TabPos gets the edge at which the tabs for switching pages in the
// notebook are drawn.
func (notebook notebook) TabPos() PositionType {
	var arg0 *C.GtkNotebook

	arg0 = (*C.GtkNotebook)(notebook.Native())

	ret := C.gtk_notebook_get_tab_pos(arg0)

	var ret0 PositionType

	ret0 = PositionType(ret)

	return ret0
}

// TabReorderable gets whether the tab can be reordered via drag and drop or
// not.
func (notebook notebook) TabReorderable(child Widget) bool {
	var arg0 *C.GtkNotebook
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkNotebook)(notebook.Native())
	arg1 = (*C.GtkWidget)(child.Native())

	ret := C.gtk_notebook_get_tab_reorderable(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// InsertPage: insert a page into @notebook at the given position.
func (notebook notebook) InsertPage(child Widget, tabLabel Widget, position int) int {
	var arg0 *C.GtkNotebook
	var arg1 *C.GtkWidget
	var arg2 *C.GtkWidget
	var arg3 C.int

	arg0 = (*C.GtkNotebook)(notebook.Native())
	arg1 = (*C.GtkWidget)(child.Native())
	arg2 = (*C.GtkWidget)(tabLabel.Native())
	arg3 = C.int(position)

	ret := C.gtk_notebook_insert_page(arg0, arg1, arg2, arg3)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// InsertPageMenu: insert a page into @notebook at the given position,
// specifying the widget to use as the label in the popup menu.
func (notebook notebook) InsertPageMenu(child Widget, tabLabel Widget, menuLabel Widget, position int) int {
	var arg0 *C.GtkNotebook
	var arg1 *C.GtkWidget
	var arg2 *C.GtkWidget
	var arg3 *C.GtkWidget
	var arg4 C.int

	arg0 = (*C.GtkNotebook)(notebook.Native())
	arg1 = (*C.GtkWidget)(child.Native())
	arg2 = (*C.GtkWidget)(tabLabel.Native())
	arg3 = (*C.GtkWidget)(menuLabel.Native())
	arg4 = C.int(position)

	ret := C.gtk_notebook_insert_page_menu(arg0, arg1, arg2, arg3, arg4)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// NextPage switches to the next page. Nothing happens if the current page
// is the last page.
func (notebook notebook) NextPage() {
	var arg0 *C.GtkNotebook

	arg0 = (*C.GtkNotebook)(notebook.Native())

	C.gtk_notebook_next_page(arg0)
}

// PageNum finds the index of the page which contains the given child
// widget.
func (notebook notebook) PageNum(child Widget) int {
	var arg0 *C.GtkNotebook
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkNotebook)(notebook.Native())
	arg1 = (*C.GtkWidget)(child.Native())

	ret := C.gtk_notebook_page_num(arg0, arg1)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// PopupDisable disables the popup menu.
func (notebook notebook) PopupDisable() {
	var arg0 *C.GtkNotebook

	arg0 = (*C.GtkNotebook)(notebook.Native())

	C.gtk_notebook_popup_disable(arg0)
}

// PopupEnable enables the popup menu: if the user clicks with the right
// mouse button on the tab labels, a menu with all the pages will be popped
// up.
func (notebook notebook) PopupEnable() {
	var arg0 *C.GtkNotebook

	arg0 = (*C.GtkNotebook)(notebook.Native())

	C.gtk_notebook_popup_enable(arg0)
}

// PrependPage prepends a page to @notebook.
func (notebook notebook) PrependPage(child Widget, tabLabel Widget) int {
	var arg0 *C.GtkNotebook
	var arg1 *C.GtkWidget
	var arg2 *C.GtkWidget

	arg0 = (*C.GtkNotebook)(notebook.Native())
	arg1 = (*C.GtkWidget)(child.Native())
	arg2 = (*C.GtkWidget)(tabLabel.Native())

	ret := C.gtk_notebook_prepend_page(arg0, arg1, arg2)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// PrependPageMenu prepends a page to @notebook, specifying the widget to
// use as the label in the popup menu.
func (notebook notebook) PrependPageMenu(child Widget, tabLabel Widget, menuLabel Widget) int {
	var arg0 *C.GtkNotebook
	var arg1 *C.GtkWidget
	var arg2 *C.GtkWidget
	var arg3 *C.GtkWidget

	arg0 = (*C.GtkNotebook)(notebook.Native())
	arg1 = (*C.GtkWidget)(child.Native())
	arg2 = (*C.GtkWidget)(tabLabel.Native())
	arg3 = (*C.GtkWidget)(menuLabel.Native())

	ret := C.gtk_notebook_prepend_page_menu(arg0, arg1, arg2, arg3)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// PrevPage switches to the previous page. Nothing happens if the current
// page is the first page.
func (notebook notebook) PrevPage() {
	var arg0 *C.GtkNotebook

	arg0 = (*C.GtkNotebook)(notebook.Native())

	C.gtk_notebook_prev_page(arg0)
}

// RemovePage removes a page from the notebook given its index in the
// notebook.
func (notebook notebook) RemovePage(pageNum int) {
	var arg0 *C.GtkNotebook
	var arg1 C.int

	arg0 = (*C.GtkNotebook)(notebook.Native())
	arg1 = C.int(pageNum)

	C.gtk_notebook_remove_page(arg0, arg1)
}

// ReorderChild reorders the page containing @child, so that it appears in
// position @position. If @position is greater than or equal to the number
// of children in the list or negative, @child will be moved to the end of
// the list.
func (notebook notebook) ReorderChild(child Widget, position int) {
	var arg0 *C.GtkNotebook
	var arg1 *C.GtkWidget
	var arg2 C.int

	arg0 = (*C.GtkNotebook)(notebook.Native())
	arg1 = (*C.GtkWidget)(child.Native())
	arg2 = C.int(position)

	C.gtk_notebook_reorder_child(arg0, arg1, arg2)
}

// SetActionWidget sets @widget as one of the action widgets. Depending on
// the pack type the widget will be placed before or after the tabs. You can
// use a Box if you need to pack more than one widget on the same side.
func (notebook notebook) SetActionWidget(widget Widget, packType PackType) {
	var arg0 *C.GtkNotebook
	var arg1 *C.GtkWidget
	var arg2 C.GtkPackType

	arg0 = (*C.GtkNotebook)(notebook.Native())
	arg1 = (*C.GtkWidget)(widget.Native())
	arg2 = (C.GtkPackType)(packType)

	C.gtk_notebook_set_action_widget(arg0, arg1, arg2)
}

// SetCurrentPage switches to the page number @page_num.
//
// Note that due to historical reasons, GtkNotebook refuses to switch to a
// page unless the child widget is visible. Therefore, it is recommended to
// show child widgets before adding them to a notebook.
func (notebook notebook) SetCurrentPage(pageNum int) {
	var arg0 *C.GtkNotebook
	var arg1 C.int

	arg0 = (*C.GtkNotebook)(notebook.Native())
	arg1 = C.int(pageNum)

	C.gtk_notebook_set_current_page(arg0, arg1)
}

// SetGroupName sets a group name for @notebook.
//
// Notebooks with the same name will be able to exchange tabs via drag and
// drop. A notebook with a nil group name will not be able to exchange tabs
// with any other notebook.
func (notebook notebook) SetGroupName(groupName string) {
	var arg0 *C.GtkNotebook
	var arg1 *C.char

	arg0 = (*C.GtkNotebook)(notebook.Native())
	arg1 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_notebook_set_group_name(arg0, arg1)
}

// SetMenuLabel changes the menu label for the page containing @child.
func (notebook notebook) SetMenuLabel(child Widget, menuLabel Widget) {
	var arg0 *C.GtkNotebook
	var arg1 *C.GtkWidget
	var arg2 *C.GtkWidget

	arg0 = (*C.GtkNotebook)(notebook.Native())
	arg1 = (*C.GtkWidget)(child.Native())
	arg2 = (*C.GtkWidget)(menuLabel.Native())

	C.gtk_notebook_set_menu_label(arg0, arg1, arg2)
}

// SetMenuLabelText creates a new label and sets it as the menu label of
// @child.
func (notebook notebook) SetMenuLabelText(child Widget, menuText string) {
	var arg0 *C.GtkNotebook
	var arg1 *C.GtkWidget
	var arg2 *C.char

	arg0 = (*C.GtkNotebook)(notebook.Native())
	arg1 = (*C.GtkWidget)(child.Native())
	arg2 = (*C.gchar)(C.CString(menuText))
	defer C.free(unsafe.Pointer(arg2))

	C.gtk_notebook_set_menu_label_text(arg0, arg1, arg2)
}

// SetScrollable sets whether the tab label area will have arrows for
// scrolling if there are too many tabs to fit in the area.
func (notebook notebook) SetScrollable(scrollable bool) {
	var arg0 *C.GtkNotebook
	var arg1 C.gboolean

	arg0 = (*C.GtkNotebook)(notebook.Native())
	arg1 = gextras.Cbool(scrollable)

	C.gtk_notebook_set_scrollable(arg0, arg1)
}

// SetShowBorder sets whether a bevel will be drawn around the notebook
// pages. This only has a visual effect when the tabs are not shown. See
// gtk_notebook_set_show_tabs().
func (notebook notebook) SetShowBorder(showBorder bool) {
	var arg0 *C.GtkNotebook
	var arg1 C.gboolean

	arg0 = (*C.GtkNotebook)(notebook.Native())
	arg1 = gextras.Cbool(showBorder)

	C.gtk_notebook_set_show_border(arg0, arg1)
}

// SetShowTabs sets whether to show the tabs for the notebook or not.
func (notebook notebook) SetShowTabs(showTabs bool) {
	var arg0 *C.GtkNotebook
	var arg1 C.gboolean

	arg0 = (*C.GtkNotebook)(notebook.Native())
	arg1 = gextras.Cbool(showTabs)

	C.gtk_notebook_set_show_tabs(arg0, arg1)
}

// SetTabDetachable sets whether the tab can be detached from @notebook to
// another notebook or widget.
//
// Note that 2 notebooks must share a common group identificator (see
// gtk_notebook_set_group_name()) to allow automatic tabs interchange
// between them.
//
// If you want a widget to interact with a notebook through DnD (i.e.:
// accept dragged tabs from it) it must be set as a drop destination and
// accept the target “GTK_NOTEBOOK_TAB”. The notebook will fill the
// selection with a GtkWidget** pointing to the child widget that
// corresponds to the dropped tab.
//
// Note that you should use gtk_notebook_detach_tab() instead of
// gtk_notebook_remove_page() if you want to remove the tab from the source
// notebook as part of accepting a drop. Otherwise, the source notebook will
// think that the dragged tab was removed from underneath the ongoing drag
// operation, and will initiate a drag cancel animation.
//
//     static void
//     on_drag_data_received (GtkWidget        *widget,
//                            GdkDrop          *drop,
//                            GtkSelectionData *data,
//                            guint             time,
//                            gpointer          user_data)
//     {
//       GtkDrag *drag;
//       GtkWidget *notebook;
//       GtkWidget **child;
//
//       drag = gtk_drop_get_drag (drop);
//       notebook = g_object_get_data (drag, "gtk-notebook-drag-origin");
//       child = (void*) gtk_selection_data_get_data (data);
//
//       // process_widget (*child);
//
//       gtk_notebook_detach_tab (GTK_NOTEBOOK (notebook), *child);
//     }
//
//
// If you want a notebook to accept drags from other widgets, you will have
// to set your own DnD code to do it.
func (notebook notebook) SetTabDetachable(child Widget, detachable bool) {
	var arg0 *C.GtkNotebook
	var arg1 *C.GtkWidget
	var arg2 C.gboolean

	arg0 = (*C.GtkNotebook)(notebook.Native())
	arg1 = (*C.GtkWidget)(child.Native())
	arg2 = gextras.Cbool(detachable)

	C.gtk_notebook_set_tab_detachable(arg0, arg1, arg2)
}

// SetTabLabel changes the tab label for @child. If nil is specified for
// @tab_label, then the page will have the label “page N”.
func (notebook notebook) SetTabLabel(child Widget, tabLabel Widget) {
	var arg0 *C.GtkNotebook
	var arg1 *C.GtkWidget
	var arg2 *C.GtkWidget

	arg0 = (*C.GtkNotebook)(notebook.Native())
	arg1 = (*C.GtkWidget)(child.Native())
	arg2 = (*C.GtkWidget)(tabLabel.Native())

	C.gtk_notebook_set_tab_label(arg0, arg1, arg2)
}

// SetTabLabelText creates a new label and sets it as the tab label for the
// page containing @child.
func (notebook notebook) SetTabLabelText(child Widget, tabText string) {
	var arg0 *C.GtkNotebook
	var arg1 *C.GtkWidget
	var arg2 *C.char

	arg0 = (*C.GtkNotebook)(notebook.Native())
	arg1 = (*C.GtkWidget)(child.Native())
	arg2 = (*C.gchar)(C.CString(tabText))
	defer C.free(unsafe.Pointer(arg2))

	C.gtk_notebook_set_tab_label_text(arg0, arg1, arg2)
}

// SetTabPos sets the edge at which the tabs for switching pages in the
// notebook are drawn.
func (notebook notebook) SetTabPos(pos PositionType) {
	var arg0 *C.GtkNotebook
	var arg1 C.GtkPositionType

	arg0 = (*C.GtkNotebook)(notebook.Native())
	arg1 = (C.GtkPositionType)(pos)

	C.gtk_notebook_set_tab_pos(arg0, arg1)
}

// SetTabReorderable sets whether the notebook tab can be reordered via drag
// and drop or not.
func (notebook notebook) SetTabReorderable(child Widget, reorderable bool) {
	var arg0 *C.GtkNotebook
	var arg1 *C.GtkWidget
	var arg2 C.gboolean

	arg0 = (*C.GtkNotebook)(notebook.Native())
	arg1 = (*C.GtkWidget)(child.Native())
	arg2 = gextras.Cbool(reorderable)

	C.gtk_notebook_set_tab_reorderable(arg0, arg1, arg2)
}

// NotebookPage: a page in the Notebook.
//
// The `GtkNotebookPage` structure only contains private data.
type NotebookPage interface {
	gextras.Objector

	// Child returns the notebook child to which @page belongs.
	Child() Widget
}

type notebookPage struct {
	*externglib.Object
}

// WrapNotebookPage wraps a GObject to the right type. It is
// primarily used internally.
func WrapNotebookPage(obj *externglib.Object) NotebookPage {
	return notebookPage{*externglib.Object{obj}}
}

func marshalNotebookPage(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapNotebookPage(obj), nil
}

// Child returns the notebook child to which @page belongs.
func (page notebookPage) Child() Widget {
	var arg0 *C.GtkNotebookPage

	arg0 = (*C.GtkNotebookPage)(page.Native())

	ret := C.gtk_notebook_page_get_child(arg0)

	var ret0 Widget

	ret0 = WrapWidget(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// NothingAction: a ShortcutAction that does nothing.
type NothingAction interface {
	ShortcutAction
}

type nothingAction struct {
	shortcutAction
}

// WrapNothingAction wraps a GObject to the right type. It is
// primarily used internally.
func WrapNothingAction(obj *externglib.Object) NothingAction {
	return nothingAction{shortcutAction{*externglib.Object{obj}}}
}

func marshalNothingAction(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapNothingAction(obj), nil
}

// NumericSorter: gtkNumericSorter is a Sorter that compares numbers.
//
// To obtain the numbers to compare, this sorter evaluates a Expression.
type NumericSorter interface {
	Sorter

	// Expression gets the expression that is evaluated to obtain numbers from
	// items.
	Expression() Expression
	// SortOrder gets whether this sorter will sort smaller numbers first.
	SortOrder() SortType
	// SetExpression sets the expression that is evaluated to obtain numbers
	// from items.
	//
	// Unless an expression is set on @self, the sorter will always compare
	// items as invalid.
	//
	// The expression must have a return type that can be compared numerically,
	// such as TYPE_INT or TYPE_DOUBLE.
	SetExpression(expression Expression)
	// SetSortOrder sets whether to sort smaller numbers before larger ones.
	SetSortOrder(sortOrder SortType)
}

type numericSorter struct {
	sorter
}

// WrapNumericSorter wraps a GObject to the right type. It is
// primarily used internally.
func WrapNumericSorter(obj *externglib.Object) NumericSorter {
	return numericSorter{sorter{*externglib.Object{obj}}}
}

func marshalNumericSorter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapNumericSorter(obj), nil
}

// NewNumericSorter constructs a class NumericSorter.
func NewNumericSorter(expression Expression) NumericSorter {
	var arg1 *C.GtkExpression

	arg1 = (*C.GtkExpression)(expression.Native())

	ret := C.gtk_numeric_sorter_new(arg1)

	var ret0 NumericSorter

	ret0 = WrapNumericSorter(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Expression gets the expression that is evaluated to obtain numbers from
// items.
func (self numericSorter) Expression() Expression {
	var arg0 *C.GtkNumericSorter

	arg0 = (*C.GtkNumericSorter)(self.Native())

	ret := C.gtk_numeric_sorter_get_expression(arg0)

	var ret0 Expression

	ret0 = WrapExpression(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// SortOrder gets whether this sorter will sort smaller numbers first.
func (self numericSorter) SortOrder() SortType {
	var arg0 *C.GtkNumericSorter

	arg0 = (*C.GtkNumericSorter)(self.Native())

	ret := C.gtk_numeric_sorter_get_sort_order(arg0)

	var ret0 SortType

	ret0 = SortType(ret)

	return ret0
}

// SetExpression sets the expression that is evaluated to obtain numbers
// from items.
//
// Unless an expression is set on @self, the sorter will always compare
// items as invalid.
//
// The expression must have a return type that can be compared numerically,
// such as TYPE_INT or TYPE_DOUBLE.
func (self numericSorter) SetExpression(expression Expression) {
	var arg0 *C.GtkNumericSorter
	var arg1 *C.GtkExpression

	arg0 = (*C.GtkNumericSorter)(self.Native())
	arg1 = (*C.GtkExpression)(expression.Native())

	C.gtk_numeric_sorter_set_expression(arg0, arg1)
}

// SetSortOrder sets whether to sort smaller numbers before larger ones.
func (self numericSorter) SetSortOrder(sortOrder SortType) {
	var arg0 *C.GtkNumericSorter
	var arg1 C.GtkSortType

	arg0 = (*C.GtkNumericSorter)(self.Native())
	arg1 = (C.GtkSortType)(sortOrder)

	C.gtk_numeric_sorter_set_sort_order(arg0, arg1)
}

type ObjectExpression interface {
	Expression

	// Object gets the object that the expression evaluates to.
	Object() gextras.Objector
}

type objectExpression struct {
	expression
}

// WrapObjectExpression wraps a GObject to the right type. It is
// primarily used internally.
func WrapObjectExpression(obj *externglib.Object) ObjectExpression {
	return objectExpression{expression{obj}}
}

func marshalObjectExpression(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapObjectExpression(obj), nil
}

// NewObjectExpression constructs a class ObjectExpression.
func NewObjectExpression(object gextras.Objector) ObjectExpression {
	var arg1 *C.GObject

	arg1 = (*C.GObject)(object.Native())

	ret := C.gtk_object_expression_new(arg1)

	var ret0 ObjectExpression

	ret0 = WrapObjectExpression(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Object gets the object that the expression evaluates to.
func (expression objectExpression) Object() gextras.Objector {
	var arg0 *C.GtkExpression

	arg0 = (*C.GtkExpression)(expression.Native())

	ret := C.gtk_object_expression_get_object(arg0)

	var ret0 gextras.Objector

	ret0 = externglib.Take(unsafe.Pointer(ret.Native()))

	return ret0
}

// Overlay: gtkOverlay is a container which contains a single main child, on top
// of which it can place “overlay” widgets. The position of each overlay widget
// is determined by its Widget:halign and Widget:valign properties. E.g. a
// widget with both alignments set to GTK_ALIGN_START will be placed at the top
// left corner of the GtkOverlay container, whereas an overlay with halign set
// to GTK_ALIGN_CENTER and valign set to GTK_ALIGN_END will be placed a the
// bottom edge of the GtkOverlay, horizontally centered. The position can be
// adjusted by setting the margin properties of the child to non-zero values.
//
// More complicated placement of overlays is possible by connecting to the
// Overlay::get-child-position signal.
//
// An overlay’s minimum and natural sizes are those of its main child. The sizes
// of overlay children are not considered when measuring these preferred sizes.
//
//
// GtkOverlay as GtkBuildable
//
// The GtkOverlay implementation of the GtkBuildable interface supports placing
// a child as an overlay by specifying “overlay” as the “type” attribute of a
// `<child>` element.
//
//
// CSS nodes
//
// GtkOverlay has a single CSS node with the name “overlay”. Overlay children
// whose alignments cause them to be positioned at an edge get the style classes
// “.left”, “.right”, “.top”, and/or “.bottom” according to their position.
type Overlay interface {
	Widget

	// AddOverlay adds @widget to @overlay.
	//
	// The widget will be stacked on top of the main widget added with
	// gtk_overlay_set_child().
	//
	// The position at which @widget is placed is determined from its
	// Widget:halign and Widget:valign properties.
	AddOverlay(widget Widget)
	// Child gets the child widget of @overlay.
	Child() Widget
	// ClipOverlay gets whether @widget should be clipped within the parent.
	ClipOverlay(widget Widget) bool
	// MeasureOverlay gets whether @widget's size is included in the measurement
	// of @overlay.
	MeasureOverlay(widget Widget) bool
	// RemoveOverlay removes an overlay that was added with
	// gtk_overlay_add_overlay().
	RemoveOverlay(widget Widget)
	// SetChild sets the child widget of @overlay.
	SetChild(child Widget)
	// SetClipOverlay sets whether @widget should be clipped within the parent.
	SetClipOverlay(widget Widget, clipOverlay bool)
	// SetMeasureOverlay sets whether @widget is included in the measured size
	// of @overlay.
	//
	// The overlay will request the size of the largest child that has this
	// property set to true. Children who are not included may be drawn outside
	// of @overlay's allocation if they are too large.
	SetMeasureOverlay(widget Widget, measure bool)
}

type overlay struct {
	widget
}

// WrapOverlay wraps a GObject to the right type. It is
// primarily used internally.
func WrapOverlay(obj *externglib.Object) Overlay {
	return overlay{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}
}

func marshalOverlay(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapOverlay(obj), nil
}

// NewOverlay constructs a class Overlay.
func NewOverlay() Overlay {

	ret := C.gtk_overlay_new()

	var ret0 Overlay

	ret0 = WrapOverlay(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// AddOverlay adds @widget to @overlay.
//
// The widget will be stacked on top of the main widget added with
// gtk_overlay_set_child().
//
// The position at which @widget is placed is determined from its
// Widget:halign and Widget:valign properties.
func (overlay overlay) AddOverlay(widget Widget) {
	var arg0 *C.GtkOverlay
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkOverlay)(overlay.Native())
	arg1 = (*C.GtkWidget)(widget.Native())

	C.gtk_overlay_add_overlay(arg0, arg1)
}

// Child gets the child widget of @overlay.
func (overlay overlay) Child() Widget {
	var arg0 *C.GtkOverlay

	arg0 = (*C.GtkOverlay)(overlay.Native())

	ret := C.gtk_overlay_get_child(arg0)

	var ret0 Widget

	ret0 = WrapWidget(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// ClipOverlay gets whether @widget should be clipped within the parent.
func (overlay overlay) ClipOverlay(widget Widget) bool {
	var arg0 *C.GtkOverlay
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkOverlay)(overlay.Native())
	arg1 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_overlay_get_clip_overlay(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// MeasureOverlay gets whether @widget's size is included in the measurement
// of @overlay.
func (overlay overlay) MeasureOverlay(widget Widget) bool {
	var arg0 *C.GtkOverlay
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkOverlay)(overlay.Native())
	arg1 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_overlay_get_measure_overlay(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// RemoveOverlay removes an overlay that was added with
// gtk_overlay_add_overlay().
func (overlay overlay) RemoveOverlay(widget Widget) {
	var arg0 *C.GtkOverlay
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkOverlay)(overlay.Native())
	arg1 = (*C.GtkWidget)(widget.Native())

	C.gtk_overlay_remove_overlay(arg0, arg1)
}

// SetChild sets the child widget of @overlay.
func (overlay overlay) SetChild(child Widget) {
	var arg0 *C.GtkOverlay
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkOverlay)(overlay.Native())
	arg1 = (*C.GtkWidget)(child.Native())

	C.gtk_overlay_set_child(arg0, arg1)
}

// SetClipOverlay sets whether @widget should be clipped within the parent.
func (overlay overlay) SetClipOverlay(widget Widget, clipOverlay bool) {
	var arg0 *C.GtkOverlay
	var arg1 *C.GtkWidget
	var arg2 C.gboolean

	arg0 = (*C.GtkOverlay)(overlay.Native())
	arg1 = (*C.GtkWidget)(widget.Native())
	arg2 = gextras.Cbool(clipOverlay)

	C.gtk_overlay_set_clip_overlay(arg0, arg1, arg2)
}

// SetMeasureOverlay sets whether @widget is included in the measured size
// of @overlay.
//
// The overlay will request the size of the largest child that has this
// property set to true. Children who are not included may be drawn outside
// of @overlay's allocation if they are too large.
func (overlay overlay) SetMeasureOverlay(widget Widget, measure bool) {
	var arg0 *C.GtkOverlay
	var arg1 *C.GtkWidget
	var arg2 C.gboolean

	arg0 = (*C.GtkOverlay)(overlay.Native())
	arg1 = (*C.GtkWidget)(widget.Native())
	arg2 = gextras.Cbool(measure)

	C.gtk_overlay_set_measure_overlay(arg0, arg1, arg2)
}

// OverlayLayout: gtkOverlayLayout is the layout manager used by Overlay. It
// places widgets as overlays on top of the main child.
//
// This is not a reusable layout manager, since it expects its widget to be a
// Overlay. It only listed here so that its layout properties get documented.
type OverlayLayout interface {
	LayoutManager
}

type overlayLayout struct {
	layoutManager
}

// WrapOverlayLayout wraps a GObject to the right type. It is
// primarily used internally.
func WrapOverlayLayout(obj *externglib.Object) OverlayLayout {
	return overlayLayout{layoutManager{*externglib.Object{obj}}}
}

func marshalOverlayLayout(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapOverlayLayout(obj), nil
}

// NewOverlayLayout constructs a class OverlayLayout.
func NewOverlayLayout() OverlayLayout {

	ret := C.gtk_overlay_layout_new()

	var ret0 OverlayLayout

	ret0 = WrapOverlayLayout(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

type OverlayLayoutChild interface {
	LayoutChild

	// ClipOverlay retrieves whether the child is clipped.
	ClipOverlay() bool
	// Measure retrieves whether the child is measured.
	Measure() bool
	// SetClipOverlay sets whether to clip this child.
	SetClipOverlay(clipOverlay bool)
	// SetMeasure sets whether to measure this child.
	SetMeasure(measure bool)
}

type overlayLayoutChild struct {
	layoutChild
}

// WrapOverlayLayoutChild wraps a GObject to the right type. It is
// primarily used internally.
func WrapOverlayLayoutChild(obj *externglib.Object) OverlayLayoutChild {
	return overlayLayoutChild{layoutChild{*externglib.Object{obj}}}
}

func marshalOverlayLayoutChild(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapOverlayLayoutChild(obj), nil
}

// ClipOverlay retrieves whether the child is clipped.
func (child overlayLayoutChild) ClipOverlay() bool {
	var arg0 *C.GtkOverlayLayoutChild

	arg0 = (*C.GtkOverlayLayoutChild)(child.Native())

	ret := C.gtk_overlay_layout_child_get_clip_overlay(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Measure retrieves whether the child is measured.
func (child overlayLayoutChild) Measure() bool {
	var arg0 *C.GtkOverlayLayoutChild

	arg0 = (*C.GtkOverlayLayoutChild)(child.Native())

	ret := C.gtk_overlay_layout_child_get_measure(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// SetClipOverlay sets whether to clip this child.
func (child overlayLayoutChild) SetClipOverlay(clipOverlay bool) {
	var arg0 *C.GtkOverlayLayoutChild
	var arg1 C.gboolean

	arg0 = (*C.GtkOverlayLayoutChild)(child.Native())
	arg1 = gextras.Cbool(clipOverlay)

	C.gtk_overlay_layout_child_set_clip_overlay(arg0, arg1)
}

// SetMeasure sets whether to measure this child.
func (child overlayLayoutChild) SetMeasure(measure bool) {
	var arg0 *C.GtkOverlayLayoutChild
	var arg1 C.gboolean

	arg0 = (*C.GtkOverlayLayoutChild)(child.Native())
	arg1 = gextras.Cbool(measure)

	C.gtk_overlay_layout_child_set_measure(arg0, arg1)
}

// PadController is an event controller for the pads found in drawing tablets
// (The collection of buttons and tactile sensors often found around the
// stylus-sensitive area).
//
// These buttons and sensors have no implicit meaning, and by default they
// perform no action, this event controller is provided to map those to #GAction
// objects, thus letting the application give those a more semantic meaning.
//
// Buttons and sensors are not constrained to triggering a single action, some
// GDK_SOURCE_TABLET_PAD devices feature multiple "modes", all these input
// elements have one current mode, which may determine the final action being
// triggered. Pad devices often divide buttons and sensors into groups, all
// elements in a group share the same current mode, but different groups may
// have different modes. See gdk_device_pad_get_n_groups() and
// gdk_device_pad_get_group_n_modes().
//
// Each of the actions that a given button/strip/ring performs for a given mode
// is defined by PadActionEntry, it contains an action name that will be looked
// up in the given Group and activated whenever the specified input element and
// mode are triggered.
//
// A simple example of PadController usage, assigning button 1 in all modes and
// pad devices to an "invert-selection" action:
//
//
//      GtkPadActionEntry *pad_actions[] = {
//        { GTK_PAD_ACTION_BUTTON, 1, -1, "Invert selection", "pad-actions.invert-selection" },
//        …
//      };
//
//      …
//      action_group = g_simple_action_group_new ();
//      action = g_simple_action_new ("pad-actions.invert-selection", NULL);
//      g_signal_connect (action, "activate", on_invert_selection_activated, NULL);
//      g_action_map_add_action (G_ACTION_MAP (action_group), action);
//      …
//      pad_controller = gtk_pad_controller_new (action_group, NULL);
//
//
// The actions belonging to rings/strips will be activated with a parameter of
// type G_VARIANT_TYPE_DOUBLE bearing the value of the given axis, it is
// required that those are made stateful and accepting this Type.
type PadController interface {
	EventController

	// SetAction adds an individual action to @controller. This action will only
	// be activated if the given button/ring/strip number in @index is
	// interacted while the current mode is @mode. -1 may be used for simple
	// cases, so the action is triggered on all modes.
	//
	// The given @label should be considered user-visible, so
	// internationalization rules apply. Some windowing systems may be able to
	// use those for user feedback.
	SetAction(_type PadActionType, index int, mode int, label string, actionName string)
	// SetActionEntries: this is a convenience function to add a group of action
	// entries on @controller. See PadActionEntry and
	// gtk_pad_controller_set_action().
	SetActionEntries(entries []PadActionEntry)
}

type padController struct {
	eventController
}

// WrapPadController wraps a GObject to the right type. It is
// primarily used internally.
func WrapPadController(obj *externglib.Object) PadController {
	return padController{eventController{*externglib.Object{obj}}}
}

func marshalPadController(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPadController(obj), nil
}

// NewPadController constructs a class PadController.
func NewPadController(group gio.ActionGroup, pad gdk.Device) PadController {
	var arg1 *C.GActionGroup
	var arg2 *C.GdkDevice

	arg2 = (*C.GdkDevice)(pad.Native())

	ret := C.gtk_pad_controller_new(arg1, arg2)

	var ret0 PadController

	ret0 = WrapPadController(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// SetAction adds an individual action to @controller. This action will only
// be activated if the given button/ring/strip number in @index is
// interacted while the current mode is @mode. -1 may be used for simple
// cases, so the action is triggered on all modes.
//
// The given @label should be considered user-visible, so
// internationalization rules apply. Some windowing systems may be able to
// use those for user feedback.
func (controller padController) SetAction(_type PadActionType, index int, mode int, label string, actionName string) {
	var arg0 *C.GtkPadController
	var arg1 C.GtkPadActionType
	var arg2 C.int
	var arg3 C.int
	var arg4 *C.char
	var arg5 *C.char

	arg0 = (*C.GtkPadController)(controller.Native())
	arg1 = (C.GtkPadActionType)(_type)
	arg2 = C.int(index)
	arg3 = C.int(mode)
	arg4 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(arg4))
	arg5 = (*C.gchar)(C.CString(actionName))
	defer C.free(unsafe.Pointer(arg5))

	C.gtk_pad_controller_set_action(arg0, arg1, arg2, arg3, arg4, arg5)
}

// SetActionEntries: this is a convenience function to add a group of action
// entries on @controller. See PadActionEntry and
// gtk_pad_controller_set_action().
func (controller padController) SetActionEntries(entries []PadActionEntry) {
	var arg0 *C.GtkPadController
	var arg1 *C.GtkPadActionEntry
	var arg2 C.int

	arg0 = (*C.GtkPadController)(controller.Native())
	{
		var dst []C.GtkPadActionEntry
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(C.malloc(C.sizeof_GtkPadActionEntry * len(entries))))
		sliceHeader.Len = len(entries)
		sliceHeader.Cap = len(entries)
		defer C.free(unsafe.Pointer(sliceHeader.Data))

		for i := 0; i < len(entries); i++ {
			src := entries[i]
			dst[i] = (C.GtkPadActionEntry)(src.Native())
		}

		arg1 = (*C.GtkPadActionEntry)(unsafe.Pointer(sliceHeader.Data))
		arg2 = len(entries)
	}

	C.gtk_pad_controller_set_action_entries(arg0, arg1, arg2)
}

// PageSetup: a GtkPageSetup object stores the page size, orientation and
// margins. The idea is that you can get one of these from the page setup dialog
// and then pass it to the PrintOperation when printing. The benefit of
// splitting this out of the PrintSettings is that these affect the actual
// layout of the page, and thus need to be set long before user prints.
//
//
// Margins
//
// The margins specified in this object are the “print margins”, i.e. the parts
// of the page that the printer cannot print on. These are different from the
// layout margins that a word processor uses; they are typically used to
// determine the minimal size for the layout margins.
//
// To obtain a PageSetup use gtk_page_setup_new() to get the defaults, or use
// gtk_print_run_page_setup_dialog() to show the page setup dialog and receive
// the resulting page setup.
//
// A page setup dialog
//
//    static GtkPrintSettings *settings = NULL;
//    static GtkPageSetup *page_setup = NULL;
//
//    static void
//    do_page_setup (void)
//    {
//      GtkPageSetup *new_page_setup;
//
//      if (settings == NULL)
//        settings = gtk_print_settings_new ();
//
//      new_page_setup = gtk_print_run_page_setup_dialog (GTK_WINDOW (main_window),
//                                                        page_setup, settings);
//
//      if (page_setup)
//        g_object_unref (page_setup);
//
//      page_setup = new_page_setup;
//    }
//
type PageSetup interface {
	gextras.Objector

	// Copy copies a PageSetup.
	Copy() PageSetup
	// BottomMargin gets the bottom margin in units of @unit.
	BottomMargin(unit Unit) float64
	// LeftMargin gets the left margin in units of @unit.
	LeftMargin(unit Unit) float64
	// Orientation gets the page orientation of the PageSetup.
	Orientation() PageOrientation
	// PageHeight returns the page height in units of @unit.
	//
	// Note that this function takes orientation and margins into consideration.
	// See gtk_page_setup_get_paper_height().
	PageHeight(unit Unit) float64
	// PageWidth returns the page width in units of @unit.
	//
	// Note that this function takes orientation and margins into consideration.
	// See gtk_page_setup_get_paper_width().
	PageWidth(unit Unit) float64
	// PaperHeight returns the paper height in units of @unit.
	//
	// Note that this function takes orientation, but not margins into
	// consideration. See gtk_page_setup_get_page_height().
	PaperHeight(unit Unit) float64
	// PaperSize gets the paper size of the PageSetup.
	PaperSize() *PaperSize
	// PaperWidth returns the paper width in units of @unit.
	//
	// Note that this function takes orientation, but not margins into
	// consideration. See gtk_page_setup_get_page_width().
	PaperWidth(unit Unit) float64
	// RightMargin gets the right margin in units of @unit.
	RightMargin(unit Unit) float64
	// TopMargin gets the top margin in units of @unit.
	TopMargin(unit Unit) float64
	// LoadFile reads the page setup from the file @file_name. See
	// gtk_page_setup_to_file().
	LoadFile(fileName string) bool
	// LoadKeyFile reads the page setup from the group @group_name in the key
	// file @key_file.
	LoadKeyFile(keyFile *glib.KeyFile, groupName string) bool
	// SetBottomMargin sets the bottom margin of the PageSetup.
	SetBottomMargin(margin float64, unit Unit)
	// SetLeftMargin sets the left margin of the PageSetup.
	SetLeftMargin(margin float64, unit Unit)
	// SetOrientation sets the page orientation of the PageSetup.
	SetOrientation(orientation PageOrientation)
	// SetPaperSize sets the paper size of the PageSetup without changing the
	// margins. See gtk_page_setup_set_paper_size_and_default_margins().
	SetPaperSize(size *PaperSize)
	// SetPaperSizeAndDefaultMargins sets the paper size of the PageSetup and
	// modifies the margins according to the new paper size.
	SetPaperSizeAndDefaultMargins(size *PaperSize)
	// SetRightMargin sets the right margin of the PageSetup.
	SetRightMargin(margin float64, unit Unit)
	// SetTopMargin sets the top margin of the PageSetup.
	SetTopMargin(margin float64, unit Unit)
	// ToFile: this function saves the information from @setup to @file_name.
	ToFile(fileName string) bool
	// ToGvariant: serialize page setup to an a{sv} variant.
	ToGvariant() *glib.Variant
	// ToKeyFile: this function adds the page setup from @setup to @key_file.
	ToKeyFile(keyFile *glib.KeyFile, groupName string)
}

type pageSetup struct {
	*externglib.Object
}

// WrapPageSetup wraps a GObject to the right type. It is
// primarily used internally.
func WrapPageSetup(obj *externglib.Object) PageSetup {
	return pageSetup{*externglib.Object{obj}}
}

func marshalPageSetup(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPageSetup(obj), nil
}

// NewPageSetup constructs a class PageSetup.
func NewPageSetup() PageSetup {

	ret := C.gtk_page_setup_new()

	var ret0 PageSetup

	ret0 = WrapPageSetup(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewPageSetupFromFile constructs a class PageSetup.
func NewPageSetupFromFile(fileName string) PageSetup {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(fileName))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_page_setup_new_from_file(arg1)

	var ret0 PageSetup

	ret0 = WrapPageSetup(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewPageSetupFromGvariant constructs a class PageSetup.
func NewPageSetupFromGvariant(variant *glib.Variant) PageSetup {
	var arg1 *C.GVariant

	arg1 = (*C.GVariant)(variant.Native())

	ret := C.gtk_page_setup_new_from_gvariant(arg1)

	var ret0 PageSetup

	ret0 = WrapPageSetup(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewPageSetupFromKeyFile constructs a class PageSetup.
func NewPageSetupFromKeyFile(keyFile *glib.KeyFile, groupName string) PageSetup {
	var arg1 *C.GKeyFile
	var arg2 *C.char

	arg1 = (*C.GKeyFile)(keyFile.Native())
	arg2 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.gtk_page_setup_new_from_key_file(arg1, arg2)

	var ret0 PageSetup

	ret0 = WrapPageSetup(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Copy copies a PageSetup.
func (other pageSetup) Copy() PageSetup {
	var arg0 *C.GtkPageSetup

	arg0 = (*C.GtkPageSetup)(other.Native())

	ret := C.gtk_page_setup_copy(arg0)

	var ret0 PageSetup

	ret0 = WrapPageSetup(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// BottomMargin gets the bottom margin in units of @unit.
func (setup pageSetup) BottomMargin(unit Unit) float64 {
	var arg0 *C.GtkPageSetup
	var arg1 C.GtkUnit

	arg0 = (*C.GtkPageSetup)(setup.Native())
	arg1 = (C.GtkUnit)(unit)

	ret := C.gtk_page_setup_get_bottom_margin(arg0, arg1)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// LeftMargin gets the left margin in units of @unit.
func (setup pageSetup) LeftMargin(unit Unit) float64 {
	var arg0 *C.GtkPageSetup
	var arg1 C.GtkUnit

	arg0 = (*C.GtkPageSetup)(setup.Native())
	arg1 = (C.GtkUnit)(unit)

	ret := C.gtk_page_setup_get_left_margin(arg0, arg1)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// Orientation gets the page orientation of the PageSetup.
func (setup pageSetup) Orientation() PageOrientation {
	var arg0 *C.GtkPageSetup

	arg0 = (*C.GtkPageSetup)(setup.Native())

	ret := C.gtk_page_setup_get_orientation(arg0)

	var ret0 PageOrientation

	ret0 = PageOrientation(ret)

	return ret0
}

// PageHeight returns the page height in units of @unit.
//
// Note that this function takes orientation and margins into consideration.
// See gtk_page_setup_get_paper_height().
func (setup pageSetup) PageHeight(unit Unit) float64 {
	var arg0 *C.GtkPageSetup
	var arg1 C.GtkUnit

	arg0 = (*C.GtkPageSetup)(setup.Native())
	arg1 = (C.GtkUnit)(unit)

	ret := C.gtk_page_setup_get_page_height(arg0, arg1)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// PageWidth returns the page width in units of @unit.
//
// Note that this function takes orientation and margins into consideration.
// See gtk_page_setup_get_paper_width().
func (setup pageSetup) PageWidth(unit Unit) float64 {
	var arg0 *C.GtkPageSetup
	var arg1 C.GtkUnit

	arg0 = (*C.GtkPageSetup)(setup.Native())
	arg1 = (C.GtkUnit)(unit)

	ret := C.gtk_page_setup_get_page_width(arg0, arg1)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// PaperHeight returns the paper height in units of @unit.
//
// Note that this function takes orientation, but not margins into
// consideration. See gtk_page_setup_get_page_height().
func (setup pageSetup) PaperHeight(unit Unit) float64 {
	var arg0 *C.GtkPageSetup
	var arg1 C.GtkUnit

	arg0 = (*C.GtkPageSetup)(setup.Native())
	arg1 = (C.GtkUnit)(unit)

	ret := C.gtk_page_setup_get_paper_height(arg0, arg1)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// PaperSize gets the paper size of the PageSetup.
func (setup pageSetup) PaperSize() *PaperSize {
	var arg0 *C.GtkPageSetup

	arg0 = (*C.GtkPageSetup)(setup.Native())

	ret := C.gtk_page_setup_get_paper_size(arg0)

	var ret0 *PaperSize

	ret0 = WrapPaperSize(ret)

	return ret0
}

// PaperWidth returns the paper width in units of @unit.
//
// Note that this function takes orientation, but not margins into
// consideration. See gtk_page_setup_get_page_width().
func (setup pageSetup) PaperWidth(unit Unit) float64 {
	var arg0 *C.GtkPageSetup
	var arg1 C.GtkUnit

	arg0 = (*C.GtkPageSetup)(setup.Native())
	arg1 = (C.GtkUnit)(unit)

	ret := C.gtk_page_setup_get_paper_width(arg0, arg1)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// RightMargin gets the right margin in units of @unit.
func (setup pageSetup) RightMargin(unit Unit) float64 {
	var arg0 *C.GtkPageSetup
	var arg1 C.GtkUnit

	arg0 = (*C.GtkPageSetup)(setup.Native())
	arg1 = (C.GtkUnit)(unit)

	ret := C.gtk_page_setup_get_right_margin(arg0, arg1)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// TopMargin gets the top margin in units of @unit.
func (setup pageSetup) TopMargin(unit Unit) float64 {
	var arg0 *C.GtkPageSetup
	var arg1 C.GtkUnit

	arg0 = (*C.GtkPageSetup)(setup.Native())
	arg1 = (C.GtkUnit)(unit)

	ret := C.gtk_page_setup_get_top_margin(arg0, arg1)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// LoadFile reads the page setup from the file @file_name. See
// gtk_page_setup_to_file().
func (setup pageSetup) LoadFile(fileName string) bool {
	var arg0 *C.GtkPageSetup
	var arg1 *C.char

	arg0 = (*C.GtkPageSetup)(setup.Native())
	arg1 = (*C.gchar)(C.CString(fileName))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_page_setup_load_file(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// LoadKeyFile reads the page setup from the group @group_name in the key
// file @key_file.
func (setup pageSetup) LoadKeyFile(keyFile *glib.KeyFile, groupName string) bool {
	var arg0 *C.GtkPageSetup
	var arg1 *C.GKeyFile
	var arg2 *C.char

	arg0 = (*C.GtkPageSetup)(setup.Native())
	arg1 = (*C.GKeyFile)(keyFile.Native())
	arg2 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.gtk_page_setup_load_key_file(arg0, arg1, arg2)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// SetBottomMargin sets the bottom margin of the PageSetup.
func (setup pageSetup) SetBottomMargin(margin float64, unit Unit) {
	var arg0 *C.GtkPageSetup
	var arg1 C.double
	var arg2 C.GtkUnit

	arg0 = (*C.GtkPageSetup)(setup.Native())
	arg1 = C.double(margin)
	arg2 = (C.GtkUnit)(unit)

	C.gtk_page_setup_set_bottom_margin(arg0, arg1, arg2)
}

// SetLeftMargin sets the left margin of the PageSetup.
func (setup pageSetup) SetLeftMargin(margin float64, unit Unit) {
	var arg0 *C.GtkPageSetup
	var arg1 C.double
	var arg2 C.GtkUnit

	arg0 = (*C.GtkPageSetup)(setup.Native())
	arg1 = C.double(margin)
	arg2 = (C.GtkUnit)(unit)

	C.gtk_page_setup_set_left_margin(arg0, arg1, arg2)
}

// SetOrientation sets the page orientation of the PageSetup.
func (setup pageSetup) SetOrientation(orientation PageOrientation) {
	var arg0 *C.GtkPageSetup
	var arg1 C.GtkPageOrientation

	arg0 = (*C.GtkPageSetup)(setup.Native())
	arg1 = (C.GtkPageOrientation)(orientation)

	C.gtk_page_setup_set_orientation(arg0, arg1)
}

// SetPaperSize sets the paper size of the PageSetup without changing the
// margins. See gtk_page_setup_set_paper_size_and_default_margins().
func (setup pageSetup) SetPaperSize(size *PaperSize) {
	var arg0 *C.GtkPageSetup
	var arg1 *C.GtkPaperSize

	arg0 = (*C.GtkPageSetup)(setup.Native())
	arg1 = (*C.GtkPaperSize)(size.Native())

	C.gtk_page_setup_set_paper_size(arg0, arg1)
}

// SetPaperSizeAndDefaultMargins sets the paper size of the PageSetup and
// modifies the margins according to the new paper size.
func (setup pageSetup) SetPaperSizeAndDefaultMargins(size *PaperSize) {
	var arg0 *C.GtkPageSetup
	var arg1 *C.GtkPaperSize

	arg0 = (*C.GtkPageSetup)(setup.Native())
	arg1 = (*C.GtkPaperSize)(size.Native())

	C.gtk_page_setup_set_paper_size_and_default_margins(arg0, arg1)
}

// SetRightMargin sets the right margin of the PageSetup.
func (setup pageSetup) SetRightMargin(margin float64, unit Unit) {
	var arg0 *C.GtkPageSetup
	var arg1 C.double
	var arg2 C.GtkUnit

	arg0 = (*C.GtkPageSetup)(setup.Native())
	arg1 = C.double(margin)
	arg2 = (C.GtkUnit)(unit)

	C.gtk_page_setup_set_right_margin(arg0, arg1, arg2)
}

// SetTopMargin sets the top margin of the PageSetup.
func (setup pageSetup) SetTopMargin(margin float64, unit Unit) {
	var arg0 *C.GtkPageSetup
	var arg1 C.double
	var arg2 C.GtkUnit

	arg0 = (*C.GtkPageSetup)(setup.Native())
	arg1 = C.double(margin)
	arg2 = (C.GtkUnit)(unit)

	C.gtk_page_setup_set_top_margin(arg0, arg1, arg2)
}

// ToFile: this function saves the information from @setup to @file_name.
func (setup pageSetup) ToFile(fileName string) bool {
	var arg0 *C.GtkPageSetup
	var arg1 *C.char

	arg0 = (*C.GtkPageSetup)(setup.Native())
	arg1 = (*C.gchar)(C.CString(fileName))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_page_setup_to_file(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// ToGvariant: serialize page setup to an a{sv} variant.
func (setup pageSetup) ToGvariant() *glib.Variant {
	var arg0 *C.GtkPageSetup

	arg0 = (*C.GtkPageSetup)(setup.Native())

	ret := C.gtk_page_setup_to_gvariant(arg0)

	var ret0 *glib.Variant

	ret0 = glib.WrapVariant(ret)

	return ret0
}

// ToKeyFile: this function adds the page setup from @setup to @key_file.
func (setup pageSetup) ToKeyFile(keyFile *glib.KeyFile, groupName string) {
	var arg0 *C.GtkPageSetup
	var arg1 *C.GKeyFile
	var arg2 *C.char

	arg0 = (*C.GtkPageSetup)(setup.Native())
	arg1 = (*C.GKeyFile)(keyFile.Native())
	arg2 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(arg2))

	C.gtk_page_setup_to_key_file(arg0, arg1, arg2)
}

// Paned has two panes, arranged either horizontally or vertically. The division
// between the two panes is adjustable by the user by dragging a handle.
//
// Child widgets are added to the panes of the widget with
// gtk_paned_set_start_child() and gtk_paned_set_end_child(). The division
// between the two children is set by default from the size requests of the
// children, but it can be adjusted by the user.
//
// A paned widget draws a separator between the two child widgets and a small
// handle that the user can drag to adjust the division. It does not draw any
// relief around the children or around the separator. (The space in which the
// separator is called the gutter.) Often, it is useful to put each child inside
// a Frame so that the gutter appears as a ridge. No separator is drawn if one
// of the children is missing.
//
// Each child has two options that can be set, @resize and @shrink. If @resize
// is true, then when the Paned is resized, that child will expand or shrink
// along with the paned widget. If @shrink is true, then that child can be made
// smaller than its requisition by the user. Setting @shrink to false allows the
// application to set a minimum size. If @resize is false for both children,
// then this is treated as if @resize is true for both children.
//
// The application can set the position of the slider as if it were set by the
// user, by calling gtk_paned_set_position().
//
// CSS nodes
//
//    GtkWidget *hpaned = gtk_paned_new (GTK_ORIENTATION_HORIZONTAL);
//    GtkWidget *frame1 = gtk_frame_new (NULL);
//    GtkWidget *frame2 = gtk_frame_new (NULL);
//
//    gtk_widget_set_size_request (hpaned, 200, -1);
//
//    gtk_paned_set_start_child (GTK_PANED (hpaned), frame1);
//    gtk_paned_set_start_child_resize (GTK_PANED (hpaned), TRUE);
//    gtk_paned_set_start_child_shrink (GTK_PANED (hpaned), FALSE);
//    gtk_widget_set_size_request (frame1, 50, -1);
//
//    gtk_paned_set_end_child (GTK_PANED (hpaned), frame2);
//    gtk_paned_set_end_child_resize (GTK_PANED (hpaned), FALSE);
//    gtk_paned_set_end_child_shrink (GTK_PANED (hpaned), FALSE);
//    gtk_widget_set_size_request (frame2, 50, -1);
//
type Paned interface {
	Widget

	// EndChild retrieves the end child of the given Paned.
	//
	// See also: Paned:end-child
	EndChild() Widget
	// Position obtains the position of the divider between the two panes.
	Position() int
	// ResizeEndChild returns whether the end child can be resized.
	ResizeEndChild() bool
	// ResizeStartChild returns whether the start child can be resized.
	ResizeStartChild() bool
	// ShrinkEndChild returns whether the end child can be shrunk.
	ShrinkEndChild() bool
	// ShrinkStartChild returns whether the start child can be shrunk.
	ShrinkStartChild() bool
	// StartChild retrieves the start child of the given Paned.
	//
	// See also: Paned:start-child
	StartChild() Widget
	// WideHandle gets the Paned:wide-handle property.
	WideHandle() bool
	// SetEndChild sets the end child of @paned to @child.
	SetEndChild(child Widget)
	// SetPosition sets the position of the divider between the two panes.
	SetPosition(position int)
	// SetResizeEndChild sets the Paned:resize-end-child property
	SetResizeEndChild(resize bool)
	// SetResizeStartChild sets the Paned:resize-start-child property
	SetResizeStartChild(resize bool)
	// SetShrinkEndChild sets the Paned:shrink-end-child property
	SetShrinkEndChild(resize bool)
	// SetShrinkStartChild sets the Paned:shrink-start-child property
	SetShrinkStartChild(resize bool)
	// SetStartChild sets the start child of @paned to @child.
	SetStartChild(child Widget)
	// SetWideHandle sets the Paned:wide-handle property.
	SetWideHandle(wide bool)
}

type paned struct {
	widget
}

// WrapPaned wraps a GObject to the right type. It is
// primarily used internally.
func WrapPaned(obj *externglib.Object) Paned {
	return paned{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}
}

func marshalPaned(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPaned(obj), nil
}

// NewPaned constructs a class Paned.
func NewPaned(orientation Orientation) Paned {
	var arg1 C.GtkOrientation

	arg1 = (C.GtkOrientation)(orientation)

	ret := C.gtk_paned_new(arg1)

	var ret0 Paned

	ret0 = WrapPaned(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// EndChild retrieves the end child of the given Paned.
//
// See also: Paned:end-child
func (paned paned) EndChild() Widget {
	var arg0 *C.GtkPaned

	arg0 = (*C.GtkPaned)(paned.Native())

	ret := C.gtk_paned_get_end_child(arg0)

	var ret0 Widget

	ret0 = WrapWidget(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Position obtains the position of the divider between the two panes.
func (paned paned) Position() int {
	var arg0 *C.GtkPaned

	arg0 = (*C.GtkPaned)(paned.Native())

	ret := C.gtk_paned_get_position(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// ResizeEndChild returns whether the end child can be resized.
func (paned paned) ResizeEndChild() bool {
	var arg0 *C.GtkPaned

	arg0 = (*C.GtkPaned)(paned.Native())

	ret := C.gtk_paned_get_resize_end_child(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// ResizeStartChild returns whether the start child can be resized.
func (paned paned) ResizeStartChild() bool {
	var arg0 *C.GtkPaned

	arg0 = (*C.GtkPaned)(paned.Native())

	ret := C.gtk_paned_get_resize_start_child(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// ShrinkEndChild returns whether the end child can be shrunk.
func (paned paned) ShrinkEndChild() bool {
	var arg0 *C.GtkPaned

	arg0 = (*C.GtkPaned)(paned.Native())

	ret := C.gtk_paned_get_shrink_end_child(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// ShrinkStartChild returns whether the start child can be shrunk.
func (paned paned) ShrinkStartChild() bool {
	var arg0 *C.GtkPaned

	arg0 = (*C.GtkPaned)(paned.Native())

	ret := C.gtk_paned_get_shrink_start_child(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// StartChild retrieves the start child of the given Paned.
//
// See also: Paned:start-child
func (paned paned) StartChild() Widget {
	var arg0 *C.GtkPaned

	arg0 = (*C.GtkPaned)(paned.Native())

	ret := C.gtk_paned_get_start_child(arg0)

	var ret0 Widget

	ret0 = WrapWidget(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// WideHandle gets the Paned:wide-handle property.
func (paned paned) WideHandle() bool {
	var arg0 *C.GtkPaned

	arg0 = (*C.GtkPaned)(paned.Native())

	ret := C.gtk_paned_get_wide_handle(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// SetEndChild sets the end child of @paned to @child.
func (paned paned) SetEndChild(child Widget) {
	var arg0 *C.GtkPaned
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkPaned)(paned.Native())
	arg1 = (*C.GtkWidget)(child.Native())

	C.gtk_paned_set_end_child(arg0, arg1)
}

// SetPosition sets the position of the divider between the two panes.
func (paned paned) SetPosition(position int) {
	var arg0 *C.GtkPaned
	var arg1 C.int

	arg0 = (*C.GtkPaned)(paned.Native())
	arg1 = C.int(position)

	C.gtk_paned_set_position(arg0, arg1)
}

// SetResizeEndChild sets the Paned:resize-end-child property
func (paned paned) SetResizeEndChild(resize bool) {
	var arg0 *C.GtkPaned
	var arg1 C.gboolean

	arg0 = (*C.GtkPaned)(paned.Native())
	arg1 = gextras.Cbool(resize)

	C.gtk_paned_set_resize_end_child(arg0, arg1)
}

// SetResizeStartChild sets the Paned:resize-start-child property
func (paned paned) SetResizeStartChild(resize bool) {
	var arg0 *C.GtkPaned
	var arg1 C.gboolean

	arg0 = (*C.GtkPaned)(paned.Native())
	arg1 = gextras.Cbool(resize)

	C.gtk_paned_set_resize_start_child(arg0, arg1)
}

// SetShrinkEndChild sets the Paned:shrink-end-child property
func (paned paned) SetShrinkEndChild(resize bool) {
	var arg0 *C.GtkPaned
	var arg1 C.gboolean

	arg0 = (*C.GtkPaned)(paned.Native())
	arg1 = gextras.Cbool(resize)

	C.gtk_paned_set_shrink_end_child(arg0, arg1)
}

// SetShrinkStartChild sets the Paned:shrink-start-child property
func (paned paned) SetShrinkStartChild(resize bool) {
	var arg0 *C.GtkPaned
	var arg1 C.gboolean

	arg0 = (*C.GtkPaned)(paned.Native())
	arg1 = gextras.Cbool(resize)

	C.gtk_paned_set_shrink_start_child(arg0, arg1)
}

// SetStartChild sets the start child of @paned to @child.
func (paned paned) SetStartChild(child Widget) {
	var arg0 *C.GtkPaned
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkPaned)(paned.Native())
	arg1 = (*C.GtkWidget)(child.Native())

	C.gtk_paned_set_start_child(arg0, arg1)
}

// SetWideHandle sets the Paned:wide-handle property.
func (paned paned) SetWideHandle(wide bool) {
	var arg0 *C.GtkPaned
	var arg1 C.gboolean

	arg0 = (*C.GtkPaned)(paned.Native())
	arg1 = gextras.Cbool(wide)

	C.gtk_paned_set_wide_handle(arg0, arg1)
}

// PasswordEntry is entry that has been tailored for entering secrets. It does
// not show its contents in clear text, does not allow to copy it to the
// clipboard, and it shows a warning when Caps Lock is engaged. If the
// underlying platform allows it, GtkPasswordEntry will also place the text in a
// non-pageable memory area, to avoid it being written out to disk by the
// operating system.
//
// Optionally, it can offer a way to reveal the contents in clear text.
//
// GtkPasswordEntry provides only minimal API and should be used with the
// Editable API.
//
// CSS Nodes
//
//    entry.password
//    ╰── text
//        ├── image.caps-lock-indicator
//        ┊
//
//
// GtkPasswordEntry has a single CSS node with name entry that carries a
// .passwordstyle class. The text Css node below it has a child with name image
// and style class .caps-lock-indicator for the Caps Lock icon, and possibly
// other children.
//
//
// Accessibility
//
// GtkPasswordEntry uses the K_ACCESSIBLE_ROLE_TEXT_BOX role.
type PasswordEntry interface {
	Widget

	// ExtraMenu gets the menu model set with
	// gtk_password_entry_set_extra_menu().
	ExtraMenu() gio.MenuModel
	// ShowPeekIcon returns whether the entry is showing a clickable icon to
	// reveal the contents of the entry in clear text.
	ShowPeekIcon() bool
	// SetExtraMenu sets a menu model to add when constructing the context menu
	// for @entry.
	SetExtraMenu(model gio.MenuModel)
	// SetShowPeekIcon sets whether the entry should have a clickable icon to
	// show the contents of the entry in clear text.
	//
	// Setting this to false also hides the text again.
	SetShowPeekIcon(showPeekIcon bool)
}

type passwordEntry struct {
	widget
}

// WrapPasswordEntry wraps a GObject to the right type. It is
// primarily used internally.
func WrapPasswordEntry(obj *externglib.Object) PasswordEntry {
	return passwordEntry{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}
}

func marshalPasswordEntry(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPasswordEntry(obj), nil
}

// NewPasswordEntry constructs a class PasswordEntry.
func NewPasswordEntry() PasswordEntry {

	ret := C.gtk_password_entry_new()

	var ret0 PasswordEntry

	ret0 = WrapPasswordEntry(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// ExtraMenu gets the menu model set with
// gtk_password_entry_set_extra_menu().
func (entry passwordEntry) ExtraMenu() gio.MenuModel {
	var arg0 *C.GtkPasswordEntry

	arg0 = (*C.GtkPasswordEntry)(entry.Native())

	ret := C.gtk_password_entry_get_extra_menu(arg0)

	var ret0 gio.MenuModel

	ret0 = gio.WrapMenuModel(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// ShowPeekIcon returns whether the entry is showing a clickable icon to
// reveal the contents of the entry in clear text.
func (entry passwordEntry) ShowPeekIcon() bool {
	var arg0 *C.GtkPasswordEntry

	arg0 = (*C.GtkPasswordEntry)(entry.Native())

	ret := C.gtk_password_entry_get_show_peek_icon(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// SetExtraMenu sets a menu model to add when constructing the context menu
// for @entry.
func (entry passwordEntry) SetExtraMenu(model gio.MenuModel) {
	var arg0 *C.GtkPasswordEntry
	var arg1 *C.GMenuModel

	arg0 = (*C.GtkPasswordEntry)(entry.Native())
	arg1 = (*C.GMenuModel)(model.Native())

	C.gtk_password_entry_set_extra_menu(arg0, arg1)
}

// SetShowPeekIcon sets whether the entry should have a clickable icon to
// show the contents of the entry in clear text.
//
// Setting this to false also hides the text again.
func (entry passwordEntry) SetShowPeekIcon(showPeekIcon bool) {
	var arg0 *C.GtkPasswordEntry
	var arg1 C.gboolean

	arg0 = (*C.GtkPasswordEntry)(entry.Native())
	arg1 = gextras.Cbool(showPeekIcon)

	C.gtk_password_entry_set_show_peek_icon(arg0, arg1)
}

// Picture: the Picture widget displays a Paintable. Many convenience functions
// are provided to make pictures simple to use. For example, if you want to load
// an image from a file, and then display that, there’s a convenience function
// to do this:
//
//      GtkWidget *widget;
//      widget = gtk_picture_new_for_filename ("myfile.png");
//
//
// If the file isn’t loaded successfully, the picture will contain a “broken
// image” icon similar to that used in many web browsers. If you want to handle
// errors in loading the file yourself, for example by displaying an error
// message, then load the image with gdk_texture_new_from_file(), then create
// the Picture with gtk_picture_new_for_paintable().
//
// Sometimes an application will want to avoid depending on external data files,
// such as image files. See the documentation of #GResource for details. In this
// case, gtk_picture_new_for_resource() and gtk_picture_set_resource() should be
// used.
//
// GtkPicture displays an image at its natural size. See Image if you want to
// display a fixed-size image, such as an icon.
//
//
// Sizing the paintable
//
// You can influence how the paintable is displayed inside the Picture. By
// turning off Picture:keep-aspect-ratio you can allow the paintable to get
// stretched. Picture:can-shrink can be unset to make sure that paintables are
// never made smaller than their ideal size - but be careful if you do not know
// the size of the paintable in use (like when displaying user-loaded images).
// This can easily cause the picture to grow larger than the screen. And
// Widget:halign and Widget:valign can be used to make sure the paintable
// doesn't fill all available space but is instead displayed at its original
// size.
//
//
// CSS nodes
//
// GtkPicture has a single CSS node with the name picture.
//
//
// Accessibility
//
// GtkPicture uses the K_ACCESSIBLE_ROLE_IMG role.
type Picture interface {
	Widget

	// AlternativeText gets the alternative textual description of the picture
	// or returns nil if the picture cannot be described textually.
	AlternativeText() string
	// CanShrink gets the value set via gtk_picture_set_can_shrink().
	CanShrink() bool
	// File gets the #GFile currently displayed if @self is displaying a file.
	// If @self is not displaying a file, for example when
	// gtk_picture_set_paintable() was used, then nil is returned.
	File() gio.File
	// KeepAspectRatio gets the value set via
	// gtk_picture_set_keep_aspect_ratio().
	KeepAspectRatio() bool
	// Paintable gets the Paintable being displayed by the Picture.
	Paintable() gdk.Paintable
	// SetAlternativeText sets an alternative textual description for the
	// picture contents. It is equivalent to the "alt" attribute for images on
	// websites.
	//
	// This text will be made available to accessibility tools.
	//
	// If the picture cannot be described textually, set this property to nil.
	SetAlternativeText(alternativeText string)
	// SetCanShrink: if set to true, the @self can be made smaller than its
	// contents. The contents will then be scaled down when rendering.
	//
	// If you want to still force a minimum size manually, consider using
	// gtk_widget_set_size_request().
	//
	// Also of note is that a similar function for growing does not exist
	// because the grow behavior can be controlled via gtk_widget_set_halign()
	// and gtk_widget_set_valign().
	SetCanShrink(canShrink bool)
	// SetFile makes @self load and display @file.
	//
	// See gtk_picture_new_for_file() for details.
	SetFile(file gio.File)
	// SetFilename makes @self load and display the given @filename.
	//
	// This is a utility function that calls gtk_picture_set_file().
	SetFilename(filename string)
	// SetKeepAspectRatio: if set to true, the @self will render its contents
	// according to their aspect ratio. That means that empty space may show up
	// at the top/bottom or left/right of @self.
	//
	// If set to false or if the contents provide no aspect ratio, the contents
	// will be stretched over the picture's whole area.
	SetKeepAspectRatio(keepAspectRatio bool)
	// SetPaintable makes @self display the given @paintable. If @paintable is
	// nil, nothing will be displayed.
	//
	// See gtk_picture_new_for_paintable() for details.
	SetPaintable(paintable gdk.Paintable)
	// SetPixbuf: see gtk_picture_new_for_pixbuf() for details.
	//
	// This is a utility function that calls gtk_picture_set_paintable(),
	SetPixbuf(pixbuf gdkpixbuf.Pixbuf)
	// SetResource makes @self load and display the resource at the given
	// @resource_path.
	//
	// This is a utility function that calls gtk_picture_set_file(),
	SetResource(resourcePath string)
}

type picture struct {
	widget
}

// WrapPicture wraps a GObject to the right type. It is
// primarily used internally.
func WrapPicture(obj *externglib.Object) Picture {
	return picture{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}
}

func marshalPicture(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPicture(obj), nil
}

// NewPicture constructs a class Picture.
func NewPicture() Picture {

	ret := C.gtk_picture_new()

	var ret0 Picture

	ret0 = WrapPicture(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewPictureForFile constructs a class Picture.
func NewPictureForFile(file gio.File) Picture {
	var arg1 *C.GFile

	ret := C.gtk_picture_new_for_file(arg1)

	var ret0 Picture

	ret0 = WrapPicture(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewPictureForFilename constructs a class Picture.
func NewPictureForFilename(filename string) Picture {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_picture_new_for_filename(arg1)

	var ret0 Picture

	ret0 = WrapPicture(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewPictureForPaintable constructs a class Picture.
func NewPictureForPaintable(paintable gdk.Paintable) Picture {
	var arg1 *C.GdkPaintable

	ret := C.gtk_picture_new_for_paintable(arg1)

	var ret0 Picture

	ret0 = WrapPicture(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewPictureForPixbuf constructs a class Picture.
func NewPictureForPixbuf(pixbuf gdkpixbuf.Pixbuf) Picture {
	var arg1 *C.GdkPixbuf

	arg1 = (*C.GdkPixbuf)(pixbuf.Native())

	ret := C.gtk_picture_new_for_pixbuf(arg1)

	var ret0 Picture

	ret0 = WrapPicture(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewPictureForResource constructs a class Picture.
func NewPictureForResource(resourcePath string) Picture {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(resourcePath))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_picture_new_for_resource(arg1)

	var ret0 Picture

	ret0 = WrapPicture(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// AlternativeText gets the alternative textual description of the picture
// or returns nil if the picture cannot be described textually.
func (self picture) AlternativeText() string {
	var arg0 *C.GtkPicture

	arg0 = (*C.GtkPicture)(self.Native())

	ret := C.gtk_picture_get_alternative_text(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// CanShrink gets the value set via gtk_picture_set_can_shrink().
func (self picture) CanShrink() bool {
	var arg0 *C.GtkPicture

	arg0 = (*C.GtkPicture)(self.Native())

	ret := C.gtk_picture_get_can_shrink(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// File gets the #GFile currently displayed if @self is displaying a file.
// If @self is not displaying a file, for example when
// gtk_picture_set_paintable() was used, then nil is returned.
func (self picture) File() gio.File {
	var arg0 *C.GtkPicture

	arg0 = (*C.GtkPicture)(self.Native())

	ret := C.gtk_picture_get_file(arg0)

	var ret0 gio.File

	return ret0
}

// KeepAspectRatio gets the value set via
// gtk_picture_set_keep_aspect_ratio().
func (self picture) KeepAspectRatio() bool {
	var arg0 *C.GtkPicture

	arg0 = (*C.GtkPicture)(self.Native())

	ret := C.gtk_picture_get_keep_aspect_ratio(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Paintable gets the Paintable being displayed by the Picture.
func (self picture) Paintable() gdk.Paintable {
	var arg0 *C.GtkPicture

	arg0 = (*C.GtkPicture)(self.Native())

	ret := C.gtk_picture_get_paintable(arg0)

	var ret0 gdk.Paintable

	return ret0
}

// SetAlternativeText sets an alternative textual description for the
// picture contents. It is equivalent to the "alt" attribute for images on
// websites.
//
// This text will be made available to accessibility tools.
//
// If the picture cannot be described textually, set this property to nil.
func (self picture) SetAlternativeText(alternativeText string) {
	var arg0 *C.GtkPicture
	var arg1 *C.char

	arg0 = (*C.GtkPicture)(self.Native())
	arg1 = (*C.gchar)(C.CString(alternativeText))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_picture_set_alternative_text(arg0, arg1)
}

// SetCanShrink: if set to true, the @self can be made smaller than its
// contents. The contents will then be scaled down when rendering.
//
// If you want to still force a minimum size manually, consider using
// gtk_widget_set_size_request().
//
// Also of note is that a similar function for growing does not exist
// because the grow behavior can be controlled via gtk_widget_set_halign()
// and gtk_widget_set_valign().
func (self picture) SetCanShrink(canShrink bool) {
	var arg0 *C.GtkPicture
	var arg1 C.gboolean

	arg0 = (*C.GtkPicture)(self.Native())
	arg1 = gextras.Cbool(canShrink)

	C.gtk_picture_set_can_shrink(arg0, arg1)
}

// SetFile makes @self load and display @file.
//
// See gtk_picture_new_for_file() for details.
func (self picture) SetFile(file gio.File) {
	var arg0 *C.GtkPicture
	var arg1 *C.GFile

	arg0 = (*C.GtkPicture)(self.Native())

	C.gtk_picture_set_file(arg0, arg1)
}

// SetFilename makes @self load and display the given @filename.
//
// This is a utility function that calls gtk_picture_set_file().
func (self picture) SetFilename(filename string) {
	var arg0 *C.GtkPicture
	var arg1 *C.char

	arg0 = (*C.GtkPicture)(self.Native())
	arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_picture_set_filename(arg0, arg1)
}

// SetKeepAspectRatio: if set to true, the @self will render its contents
// according to their aspect ratio. That means that empty space may show up
// at the top/bottom or left/right of @self.
//
// If set to false or if the contents provide no aspect ratio, the contents
// will be stretched over the picture's whole area.
func (self picture) SetKeepAspectRatio(keepAspectRatio bool) {
	var arg0 *C.GtkPicture
	var arg1 C.gboolean

	arg0 = (*C.GtkPicture)(self.Native())
	arg1 = gextras.Cbool(keepAspectRatio)

	C.gtk_picture_set_keep_aspect_ratio(arg0, arg1)
}

// SetPaintable makes @self display the given @paintable. If @paintable is
// nil, nothing will be displayed.
//
// See gtk_picture_new_for_paintable() for details.
func (self picture) SetPaintable(paintable gdk.Paintable) {
	var arg0 *C.GtkPicture
	var arg1 *C.GdkPaintable

	arg0 = (*C.GtkPicture)(self.Native())

	C.gtk_picture_set_paintable(arg0, arg1)
}

// SetPixbuf: see gtk_picture_new_for_pixbuf() for details.
//
// This is a utility function that calls gtk_picture_set_paintable(),
func (self picture) SetPixbuf(pixbuf gdkpixbuf.Pixbuf) {
	var arg0 *C.GtkPicture
	var arg1 *C.GdkPixbuf

	arg0 = (*C.GtkPicture)(self.Native())
	arg1 = (*C.GdkPixbuf)(pixbuf.Native())

	C.gtk_picture_set_pixbuf(arg0, arg1)
}

// SetResource makes @self load and display the resource at the given
// @resource_path.
//
// This is a utility function that calls gtk_picture_set_file(),
func (self picture) SetResource(resourcePath string) {
	var arg0 *C.GtkPicture
	var arg1 *C.char

	arg0 = (*C.GtkPicture)(self.Native())
	arg1 = (*C.gchar)(C.CString(resourcePath))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_picture_set_resource(arg0, arg1)
}

// Popover: gtkPopover is a bubble-like context window, primarily meant to
// provide context-dependent information or options. Popovers are attached to a
// widget, set with gtk_widget_set_parent(). By default they will point to the
// whole widget area, although this behavior can be changed through
// gtk_popover_set_pointing_to().
//
// The position of a popover relative to the widget it is attached to can also
// be changed through gtk_popover_set_position().
//
// By default, Popover performs a grab, in order to ensure input events get
// redirected to it while it is shown, and also so the popover is dismissed in
// the expected situations (clicks outside the popover, or the Escape key being
// pressed). If no such modal behavior is desired on a popover,
// gtk_popover_set_autohide() may be called on it to tweak its behavior.
//
//
// GtkPopover as menu replacement
//
// GtkPopover is often used to replace menus. The best was to do this is to use
// the PopoverMenu subclass which supports being populated from a Model with
// gtk_popover_menu_new_from_model().
//
//
//    <section>
//      <attribute name="display-hint">horizontal-buttons</attribute>
//      <item>
//        <attribute name="label">Cut</attribute>
//        <attribute name="action">app.cut</attribute>
//        <attribute name="verb-icon">edit-cut-symbolic</attribute>
//      </item>
//      <item>
//        <attribute name="label">Copy</attribute>
//        <attribute name="action">app.copy</attribute>
//        <attribute name="verb-icon">edit-copy-symbolic</attribute>
//      </item>
//      <item>
//        <attribute name="label">Paste</attribute>
//        <attribute name="action">app.paste</attribute>
//        <attribute name="verb-icon">edit-paste-symbolic</attribute>
//      </item>
//    </section>
//    ]|
//
//
//
// CSS nodes
//
//
//    |[<!-- language="plain" -->
//    popover[.menu]
//    ├── arrow
//    ╰── contents.background
//        ╰── <child>
//
//
// The contents child node always gets the .background style class and the
// popover itself gets the .menu style class if the popover is menu-like (i.e.
// PopoverMenu).
//
// Particular uses of GtkPopover, such as touch selection popups or magnifiers
// in Entry or TextView get style classes like .touch-selection or .magnifier to
// differentiate from plain popovers.
//
// When styling a popover directly, the popover node should usually not have any
// background.
//
// Note that, in order to accomplish appropriate arrow visuals, Popover uses
// custom drawing for the arrow node. This makes it possible for the arrow to
// change its shape dynamically, but it also limits the possibilities of styling
// it using CSS. In particular, the arrow gets drawn over the content node's
// border so they look like one shape, which means that the border-width of the
// content node and the arrow node should be the same. The arrow also does not
// support any border shape other than solid, no border-radius, only one border
// width (border-bottom-width is used) and no box-shadow.
type Popover interface {
	Widget

	// Autohide returns whether the popover is modal.
	//
	// See gtk_popover_set_autohide() for the implications of this.
	Autohide() bool
	// CascadePopdown returns whether the popover will close after a modal child
	// is closed.
	CascadePopdown() bool
	// Child gets the child widget of @popover.
	Child() Widget
	// HasArrow gets whether this popover is showing an arrow pointing at the
	// widget that it is relative to.
	HasArrow() bool
	// MnemonicsVisible gets the value of the Popover:mnemonics-visible
	// property.
	MnemonicsVisible() bool
	// Offset gets the offset previous set with gtk_popover_set_offset().
	Offset() (xOffset int, yOffset int)
	// PointingTo: if a rectangle to point to has been set, this function will
	// return true and fill in @rect with such rectangle, otherwise it will
	// return false and fill in @rect with the attached widget coordinates.
	PointingTo() (rect gdk.Rectangle, ok bool)
	// Position returns the preferred position of @popover.
	Position() PositionType
	// Popdown pops @popover down.This is different than a gtk_widget_hide()
	// call in that it shows the popover with a transition. If you want to hide
	// the popover without a transition, use gtk_widget_hide().
	Popdown()
	// Popup pops @popover up. This is different than a gtk_widget_show() call
	// in that it shows the popover with a transition. If you want to show the
	// popover without a transition, use gtk_widget_show().
	Popup()
	// Present presents the popover to the user.
	Present()
	// SetAutohide sets whether @popover is modal.
	//
	// A modal popover will grab the keyboard focus on it when being displayed.
	// Clicking outside the popover area or pressing Esc will dismiss the
	// popover.
	//
	// Called this function on an already showing popup with a new autohide
	// value different from the current one, will cause the popup to be hidden.
	SetAutohide(autohide bool)
	// SetCascadePopdown: if @cascade_popdown is UE, the popover will be closed
	// when a child modal popover is closed. If LSE, @popover will stay visible.
	SetCascadePopdown(cascadePopdown bool)
	// SetChild sets the child widget of @popover.
	SetChild(child Widget)
	// SetDefaultWidget: the default widget is the widget that’s activated when
	// the user presses Enter in a dialog (for example). This function sets or
	// unsets the default widget for a Popover.
	SetDefaultWidget(widget Widget)
	// SetHasArrow sets whether this popover should draw an arrow pointing at
	// the widget it is relative to.
	SetHasArrow(hasArrow bool)
	// SetMnemonicsVisible sets the Popover:mnemonics-visible property.
	SetMnemonicsVisible(mnemonicsVisible bool)
	// SetOffset sets the offset to use when calculating the position of the
	// popover.
	//
	// These values are used when preparing the PopupLayout for positioning the
	// popover.
	SetOffset(xOffset int, yOffset int)
	// SetPointingTo sets the rectangle that @popover will point to, in the
	// coordinate space of the @popover parent.
	SetPointingTo(rect *gdk.Rectangle)
	// SetPosition sets the preferred position for @popover to appear. If the
	// @popover is currently visible, it will be immediately updated.
	//
	// This preference will be respected where possible, although on lack of
	// space (eg. if close to the window edges), the Popover may choose to
	// appear on the opposite side
	SetPosition(position PositionType)
}

type popover struct {
	widget
}

// WrapPopover wraps a GObject to the right type. It is
// primarily used internally.
func WrapPopover(obj *externglib.Object) Popover {
	return popover{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}
}

func marshalPopover(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPopover(obj), nil
}

// NewPopover constructs a class Popover.
func NewPopover() Popover {

	ret := C.gtk_popover_new()

	var ret0 Popover

	ret0 = WrapPopover(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Autohide returns whether the popover is modal.
//
// See gtk_popover_set_autohide() for the implications of this.
func (popover popover) Autohide() bool {
	var arg0 *C.GtkPopover

	arg0 = (*C.GtkPopover)(popover.Native())

	ret := C.gtk_popover_get_autohide(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// CascadePopdown returns whether the popover will close after a modal child
// is closed.
func (popover popover) CascadePopdown() bool {
	var arg0 *C.GtkPopover

	arg0 = (*C.GtkPopover)(popover.Native())

	ret := C.gtk_popover_get_cascade_popdown(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Child gets the child widget of @popover.
func (popover popover) Child() Widget {
	var arg0 *C.GtkPopover

	arg0 = (*C.GtkPopover)(popover.Native())

	ret := C.gtk_popover_get_child(arg0)

	var ret0 Widget

	ret0 = WrapWidget(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// HasArrow gets whether this popover is showing an arrow pointing at the
// widget that it is relative to.
func (popover popover) HasArrow() bool {
	var arg0 *C.GtkPopover

	arg0 = (*C.GtkPopover)(popover.Native())

	ret := C.gtk_popover_get_has_arrow(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// MnemonicsVisible gets the value of the Popover:mnemonics-visible
// property.
func (popover popover) MnemonicsVisible() bool {
	var arg0 *C.GtkPopover

	arg0 = (*C.GtkPopover)(popover.Native())

	ret := C.gtk_popover_get_mnemonics_visible(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Offset gets the offset previous set with gtk_popover_set_offset().
func (popover popover) Offset() (xOffset int, yOffset int) {
	var arg0 *C.GtkPopover
	var arg1 *C.int // out
	var arg2 *C.int // out

	arg0 = (*C.GtkPopover)(popover.Native())

	ret := C.gtk_popover_get_offset(arg0, &arg1, &arg2)

	var ret0 int
	var ret1 int

	ret0 = int(arg1)

	ret1 = int(arg2)

	return ret0, ret1
}

// PointingTo: if a rectangle to point to has been set, this function will
// return true and fill in @rect with such rectangle, otherwise it will
// return false and fill in @rect with the attached widget coordinates.
func (popover popover) PointingTo() (rect gdk.Rectangle, ok bool) {
	var arg0 *C.GtkPopover
	var arg1 *C.GdkRectangle // out

	arg0 = (*C.GtkPopover)(popover.Native())

	ret := C.gtk_popover_get_pointing_to(arg0, &arg1)

	var ret0 *gdk.Rectangle
	var ret1 bool

	ret0 = gdk.WrapRectangle(arg1)

	ret1 = gextras.Gobool(ret)

	return ret0, ret1
}

// Position returns the preferred position of @popover.
func (popover popover) Position() PositionType {
	var arg0 *C.GtkPopover

	arg0 = (*C.GtkPopover)(popover.Native())

	ret := C.gtk_popover_get_position(arg0)

	var ret0 PositionType

	ret0 = PositionType(ret)

	return ret0
}

// Popdown pops @popover down.This is different than a gtk_widget_hide()
// call in that it shows the popover with a transition. If you want to hide
// the popover without a transition, use gtk_widget_hide().
func (popover popover) Popdown() {
	var arg0 *C.GtkPopover

	arg0 = (*C.GtkPopover)(popover.Native())

	C.gtk_popover_popdown(arg0)
}

// Popup pops @popover up. This is different than a gtk_widget_show() call
// in that it shows the popover with a transition. If you want to show the
// popover without a transition, use gtk_widget_show().
func (popover popover) Popup() {
	var arg0 *C.GtkPopover

	arg0 = (*C.GtkPopover)(popover.Native())

	C.gtk_popover_popup(arg0)
}

// Present presents the popover to the user.
func (popover popover) Present() {
	var arg0 *C.GtkPopover

	arg0 = (*C.GtkPopover)(popover.Native())

	C.gtk_popover_present(arg0)
}

// SetAutohide sets whether @popover is modal.
//
// A modal popover will grab the keyboard focus on it when being displayed.
// Clicking outside the popover area or pressing Esc will dismiss the
// popover.
//
// Called this function on an already showing popup with a new autohide
// value different from the current one, will cause the popup to be hidden.
func (popover popover) SetAutohide(autohide bool) {
	var arg0 *C.GtkPopover
	var arg1 C.gboolean

	arg0 = (*C.GtkPopover)(popover.Native())
	arg1 = gextras.Cbool(autohide)

	C.gtk_popover_set_autohide(arg0, arg1)
}

// SetCascadePopdown: if @cascade_popdown is UE, the popover will be closed
// when a child modal popover is closed. If LSE, @popover will stay visible.
func (popover popover) SetCascadePopdown(cascadePopdown bool) {
	var arg0 *C.GtkPopover
	var arg1 C.gboolean

	arg0 = (*C.GtkPopover)(popover.Native())
	arg1 = gextras.Cbool(cascadePopdown)

	C.gtk_popover_set_cascade_popdown(arg0, arg1)
}

// SetChild sets the child widget of @popover.
func (popover popover) SetChild(child Widget) {
	var arg0 *C.GtkPopover
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkPopover)(popover.Native())
	arg1 = (*C.GtkWidget)(child.Native())

	C.gtk_popover_set_child(arg0, arg1)
}

// SetDefaultWidget: the default widget is the widget that’s activated when
// the user presses Enter in a dialog (for example). This function sets or
// unsets the default widget for a Popover.
func (popover popover) SetDefaultWidget(widget Widget) {
	var arg0 *C.GtkPopover
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkPopover)(popover.Native())
	arg1 = (*C.GtkWidget)(widget.Native())

	C.gtk_popover_set_default_widget(arg0, arg1)
}

// SetHasArrow sets whether this popover should draw an arrow pointing at
// the widget it is relative to.
func (popover popover) SetHasArrow(hasArrow bool) {
	var arg0 *C.GtkPopover
	var arg1 C.gboolean

	arg0 = (*C.GtkPopover)(popover.Native())
	arg1 = gextras.Cbool(hasArrow)

	C.gtk_popover_set_has_arrow(arg0, arg1)
}

// SetMnemonicsVisible sets the Popover:mnemonics-visible property.
func (popover popover) SetMnemonicsVisible(mnemonicsVisible bool) {
	var arg0 *C.GtkPopover
	var arg1 C.gboolean

	arg0 = (*C.GtkPopover)(popover.Native())
	arg1 = gextras.Cbool(mnemonicsVisible)

	C.gtk_popover_set_mnemonics_visible(arg0, arg1)
}

// SetOffset sets the offset to use when calculating the position of the
// popover.
//
// These values are used when preparing the PopupLayout for positioning the
// popover.
func (popover popover) SetOffset(xOffset int, yOffset int) {
	var arg0 *C.GtkPopover
	var arg1 C.int
	var arg2 C.int

	arg0 = (*C.GtkPopover)(popover.Native())
	arg1 = C.int(xOffset)
	arg2 = C.int(yOffset)

	C.gtk_popover_set_offset(arg0, arg1, arg2)
}

// SetPointingTo sets the rectangle that @popover will point to, in the
// coordinate space of the @popover parent.
func (popover popover) SetPointingTo(rect *gdk.Rectangle) {
	var arg0 *C.GtkPopover
	var arg1 *C.GdkRectangle

	arg0 = (*C.GtkPopover)(popover.Native())
	arg1 = (*C.GdkRectangle)(rect.Native())

	C.gtk_popover_set_pointing_to(arg0, arg1)
}

// SetPosition sets the preferred position for @popover to appear. If the
// @popover is currently visible, it will be immediately updated.
//
// This preference will be respected where possible, although on lack of
// space (eg. if close to the window edges), the Popover may choose to
// appear on the opposite side
func (popover popover) SetPosition(position PositionType) {
	var arg0 *C.GtkPopover
	var arg1 C.GtkPositionType

	arg0 = (*C.GtkPopover)(popover.Native())
	arg1 = (C.GtkPositionType)(position)

	C.gtk_popover_set_position(arg0, arg1)
}

// PopoverMenu: gtkPopoverMenu is a subclass of Popover that treats its children
// like menus and allows switching between them. It can open submenus as
// traditional, nested submenus, or in a more touch-friendly sliding fashion.
//
// GtkPopoverMenu is meant to be used primarily with menu models, using
// gtk_popover_menu_new_from_model(). If you need to put other widgets such as
// SpinButton or Switch into a popover, use a plain Popover.
//
//
// Menu models
//
// The XML format understood by Builder for Model consists of a toplevel
// `<menu>` element, which contains one or more `<item>` elements. Each `<item>`
// element contains `<attribute>` and `<link>` elements with a mandatory name
// attribute. `<link>` elements have the same content model as `<menu>`. Instead
// of `<link name="submenu>` or `<link name="section">`, you can use `<submenu>`
// or `<section>` elements.
//
//    <menu id='app-menu'>
//      <section>
//        <item>
//          <attribute name='label' translatable='yes'>_New Window</attribute>
//          <attribute name='action'>app.new</attribute>
//        </item>
//        <item>
//          <attribute name='label' translatable='yes'>_About Sunny</attribute>
//          <attribute name='action'>app.about</attribute>
//        </item>
//        <item>
//          <attribute name='label' translatable='yes'>_Quit</attribute>
//          <attribute name='action'>app.quit</attribute>
//        </item>
//      </section>
//    </menu>
//
//
// Attribute values can be translated using gettext, like other Builder content.
// `<attribute>` elements can be marked for translation with a
// `translatable="yes"` attribute. It is also possible to specify message
// context and translator comments, using the context and comments attributes.
// To make use of this, the Builder must have been given the gettext domain to
// use.
//
// The following attributes are used when constructing menu items: - "label": a
// user-visible string to display - "action": the prefixed name of the action to
// trigger - "target": the parameter to use when activating the action - "icon"
// and "verb-icon": names of icons that may be displayed - "submenu-action":
// name of an action that may be used to determine if a submenu can be opened -
// "hidden-when": a string used to determine when the item will be hidden.
// Possible values include "action-disabled", "action-missing", "macos-menubar".
// This is mainly useful for exported menus, see gtk_application_set_menubar().
// - "custom": a string used to match against the ID of a custom child added
// with gtk_popover_menu_add_child(), gtk_popover_menu_bar_add_child(), or in
// the ui file with `<child type="ID">`.
//
// The following attributes are used when constructing sections: - "label": a
// user-visible string to use as section heading - "display-hint": a string used
// to determine special formatting for the section. Possible values include
// "horizontal-buttons", "circular-buttons" and "inline-buttons". They all
// indicate that section should be displayed as a horizontal row of buttons. -
// "text-direction": a string used to determine the TextDirection to use when
// "display-hint" is set to "horizontal-buttons". Possible values include "rtl",
// "ltr", and "none".
//
// The following attributes are used when constructing submenus: - "label": a
// user-visible string to display - "icon": icon name to display
//
// Menu items will also show accelerators, which are usually associated with
// actions via gtk_application_set_accels_for_action(),
// gtk_widget_class_add_binding_action() or
// gtk_shortcut_controller_add_shortcut().
//
//
// CSS Nodes
//
// PopoverMenu is just a subclass of Popover that adds custom content to it,
// therefore it has the same CSS nodes. It is one of the cases that add a .menu
// style class to the popover's main node.
//
//
// Accessibility
//
// GtkPopoverMenu uses the K_ACCESSIBLE_ROLE_MENU role, and its items use the
// K_ACCESSIBLE_ROLE_MENU_ITEM, K_ACCESSIBLE_ROLE_MENU_ITEM_CHECKBOX or
// K_ACCESSIBLE_ROLE_MENU_ITEM_RADIO roles, depending on the action they are
// connected to.
type PopoverMenu interface {
	Popover

	// AddChild adds a custom widget to a generated menu.
	//
	// For this to work, the menu model of @popover must have an item with a
	// `custom` attribute that matches @id.
	AddChild(child Widget, id string) bool
	// MenuModel returns the menu model used to populate the popover.
	MenuModel() gio.MenuModel
	// RemoveChild removes a widget that has previously been added with
	// gtk_popover_menu_add_child().
	RemoveChild(child Widget) bool
	// SetMenuModel sets a new menu model on @popover.
	//
	// The existing contents of @popover are removed, and the @popover is
	// populated with new contents according to @model.
	SetMenuModel(model gio.MenuModel)
}

type popoverMenu struct {
	popover
}

// WrapPopoverMenu wraps a GObject to the right type. It is
// primarily used internally.
func WrapPopoverMenu(obj *externglib.Object) PopoverMenu {
	return popoverMenu{popover{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}}
}

func marshalPopoverMenu(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPopoverMenu(obj), nil
}

// NewPopoverMenuFromModel constructs a class PopoverMenu.
func NewPopoverMenuFromModel(model gio.MenuModel) PopoverMenu {
	var arg1 *C.GMenuModel

	arg1 = (*C.GMenuModel)(model.Native())

	ret := C.gtk_popover_menu_new_from_model(arg1)

	var ret0 PopoverMenu

	ret0 = WrapPopoverMenu(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewPopoverMenuFromModelFull constructs a class PopoverMenu.
func NewPopoverMenuFromModelFull(model gio.MenuModel, flags PopoverMenuFlags) PopoverMenu {
	var arg1 *C.GMenuModel
	var arg2 C.GtkPopoverMenuFlags

	arg1 = (*C.GMenuModel)(model.Native())
	arg2 = (C.GtkPopoverMenuFlags)(flags)

	ret := C.gtk_popover_menu_new_from_model_full(arg1, arg2)

	var ret0 PopoverMenu

	ret0 = WrapPopoverMenu(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// AddChild adds a custom widget to a generated menu.
//
// For this to work, the menu model of @popover must have an item with a
// `custom` attribute that matches @id.
func (popover popoverMenu) AddChild(child Widget, id string) bool {
	var arg0 *C.GtkPopoverMenu
	var arg1 *C.GtkWidget
	var arg2 *C.char

	arg0 = (*C.GtkPopoverMenu)(popover.Native())
	arg1 = (*C.GtkWidget)(child.Native())
	arg2 = (*C.gchar)(C.CString(id))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.gtk_popover_menu_add_child(arg0, arg1, arg2)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// MenuModel returns the menu model used to populate the popover.
func (popover popoverMenu) MenuModel() gio.MenuModel {
	var arg0 *C.GtkPopoverMenu

	arg0 = (*C.GtkPopoverMenu)(popover.Native())

	ret := C.gtk_popover_menu_get_menu_model(arg0)

	var ret0 gio.MenuModel

	ret0 = gio.WrapMenuModel(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// RemoveChild removes a widget that has previously been added with
// gtk_popover_menu_add_child().
func (popover popoverMenu) RemoveChild(child Widget) bool {
	var arg0 *C.GtkPopoverMenu
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkPopoverMenu)(popover.Native())
	arg1 = (*C.GtkWidget)(child.Native())

	ret := C.gtk_popover_menu_remove_child(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// SetMenuModel sets a new menu model on @popover.
//
// The existing contents of @popover are removed, and the @popover is
// populated with new contents according to @model.
func (popover popoverMenu) SetMenuModel(model gio.MenuModel) {
	var arg0 *C.GtkPopoverMenu
	var arg1 *C.GMenuModel

	arg0 = (*C.GtkPopoverMenu)(popover.Native())
	arg1 = (*C.GMenuModel)(model.Native())

	C.gtk_popover_menu_set_menu_model(arg0, arg1)
}

// PopoverMenuBar: gtkPopoverMenuBar presents a horizontal bar of items that pop
// up popover menus when clicked.
//
// The only way to create instances of GtkPopoverMenuBar is from a Model.
//
// CSS nodes
//
//    menubar
//    ├── item[.active]
//    ┊   ╰── popover
//    ╰── item
//        ╰── popover
//
//
// GtkPopoverMenuBar has a single CSS node with name menubar, below which each
// item has its CSS node, and below that the corresponding popover.
//
// The item whose popover is currently open gets the .active style class.
//
//
// Accessibility
//
// GtkPopoverMenuBar uses the K_ACCESSIBLE_ROLE_MENU_BAR role, the menu items
// use the K_ACCESSIBLE_ROLE_MENU_ITEM role and the menus use the
// K_ACCESSIBLE_ROLE_MENU role.
type PopoverMenuBar interface {
	Widget

	// AddChild adds a custom widget to a generated menubar.
	//
	// For this to work, the menu model of @bar must have an item with a
	// `custom` attribute that matches @id.
	AddChild(child Widget, id string) bool
	// MenuModel returns the model from which the contents of @bar are taken.
	MenuModel() gio.MenuModel
	// RemoveChild removes a widget that has previously been added with
	// gtk_popover_menu_bar_add_child().
	RemoveChild(child Widget) bool
	// SetMenuModel sets a menu model from which @bar should take its contents.
	SetMenuModel(model gio.MenuModel)
}

type popoverMenuBar struct {
	widget
}

// WrapPopoverMenuBar wraps a GObject to the right type. It is
// primarily used internally.
func WrapPopoverMenuBar(obj *externglib.Object) PopoverMenuBar {
	return popoverMenuBar{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}
}

func marshalPopoverMenuBar(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPopoverMenuBar(obj), nil
}

// NewPopoverMenuBarFromModel constructs a class PopoverMenuBar.
func NewPopoverMenuBarFromModel(model gio.MenuModel) PopoverMenuBar {
	var arg1 *C.GMenuModel

	arg1 = (*C.GMenuModel)(model.Native())

	ret := C.gtk_popover_menu_bar_new_from_model(arg1)

	var ret0 PopoverMenuBar

	ret0 = WrapPopoverMenuBar(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// AddChild adds a custom widget to a generated menubar.
//
// For this to work, the menu model of @bar must have an item with a
// `custom` attribute that matches @id.
func (bar popoverMenuBar) AddChild(child Widget, id string) bool {
	var arg0 *C.GtkPopoverMenuBar
	var arg1 *C.GtkWidget
	var arg2 *C.char

	arg0 = (*C.GtkPopoverMenuBar)(bar.Native())
	arg1 = (*C.GtkWidget)(child.Native())
	arg2 = (*C.gchar)(C.CString(id))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.gtk_popover_menu_bar_add_child(arg0, arg1, arg2)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// MenuModel returns the model from which the contents of @bar are taken.
func (bar popoverMenuBar) MenuModel() gio.MenuModel {
	var arg0 *C.GtkPopoverMenuBar

	arg0 = (*C.GtkPopoverMenuBar)(bar.Native())

	ret := C.gtk_popover_menu_bar_get_menu_model(arg0)

	var ret0 gio.MenuModel

	ret0 = gio.WrapMenuModel(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// RemoveChild removes a widget that has previously been added with
// gtk_popover_menu_bar_add_child().
func (bar popoverMenuBar) RemoveChild(child Widget) bool {
	var arg0 *C.GtkPopoverMenuBar
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkPopoverMenuBar)(bar.Native())
	arg1 = (*C.GtkWidget)(child.Native())

	ret := C.gtk_popover_menu_bar_remove_child(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// SetMenuModel sets a menu model from which @bar should take its contents.
func (bar popoverMenuBar) SetMenuModel(model gio.MenuModel) {
	var arg0 *C.GtkPopoverMenuBar
	var arg1 *C.GMenuModel

	arg0 = (*C.GtkPopoverMenuBar)(bar.Native())
	arg1 = (*C.GMenuModel)(model.Native())

	C.gtk_popover_menu_bar_set_menu_model(arg0, arg1)
}

// PrintContext: a GtkPrintContext encapsulates context information that is
// required when drawing pages for printing, such as the cairo context and
// important parameters like page size and resolution. It also lets you easily
// create Layout and Context objects that match the font metrics of the cairo
// surface.
//
// GtkPrintContext objects gets passed to the PrintOperation::begin-print,
// PrintOperation::end-print, PrintOperation::request-page-setup and
// PrintOperation::draw-page signals on the PrintOperation.
//
// Using GtkPrintContext in a PrintOperation::draw-page callback
//
//    static void
//    draw_page (GtkPrintOperation *operation,
//    	   GtkPrintContext   *context,
//    	   int                page_nr)
//    {
//      cairo_t *cr;
//      PangoLayout *layout;
//      PangoFontDescription *desc;
//
//      cr = gtk_print_context_get_cairo_context (context);
//
//      // Draw a red rectangle, as wide as the paper (inside the margins)
//      cairo_set_source_rgb (cr, 1.0, 0, 0);
//      cairo_rectangle (cr, 0, 0, gtk_print_context_get_width (context), 50);
//
//      cairo_fill (cr);
//
//      // Draw some lines
//      cairo_move_to (cr, 20, 10);
//      cairo_line_to (cr, 40, 20);
//      cairo_arc (cr, 60, 60, 20, 0, M_PI);
//      cairo_line_to (cr, 80, 20);
//
//      cairo_set_source_rgb (cr, 0, 0, 0);
//      cairo_set_line_width (cr, 5);
//      cairo_set_line_cap (cr, CAIRO_LINE_CAP_ROUND);
//      cairo_set_line_join (cr, CAIRO_LINE_JOIN_ROUND);
//
//      cairo_stroke (cr);
//
//      // Draw some text
//      layout = gtk_print_context_create_pango_layout (context);
//      pango_layout_set_text (layout, "Hello World! Printing is easy", -1);
//      desc = pango_font_description_from_string ("sans 28");
//      pango_layout_set_font_description (layout, desc);
//      pango_font_description_free (desc);
//
//      cairo_move_to (cr, 30, 20);
//      pango_cairo_layout_path (cr, layout);
//
//      // Font Outline
//      cairo_set_source_rgb (cr, 0.93, 1.0, 0.47);
//      cairo_set_line_width (cr, 0.5);
//      cairo_stroke_preserve (cr);
//
//      // Font Fill
//      cairo_set_source_rgb (cr, 0, 0.0, 1.0);
//      cairo_fill (cr);
//
//      g_object_unref (layout);
//    }
//
type PrintContext interface {
	gextras.Objector

	// CreatePangoContext creates a new Context that can be used with the
	// PrintContext.
	CreatePangoContext() pango.Context
	// CreatePangoLayout creates a new Layout that is suitable for use with the
	// PrintContext.
	CreatePangoLayout() pango.Layout
	// CairoContext obtains the cairo context that is associated with the
	// PrintContext.
	CairoContext() *cairo.Context
	// DPIX obtains the horizontal resolution of the PrintContext, in dots per
	// inch.
	DPIX() float64
	// DPIY obtains the vertical resolution of the PrintContext, in dots per
	// inch.
	DPIY() float64
	// HardMargins obtains the hardware printer margins of the PrintContext, in
	// units.
	HardMargins() (top float64, bottom float64, left float64, right float64, ok bool)
	// Height obtains the height of the PrintContext, in pixels.
	Height() float64
	// PageSetup obtains the PageSetup that determines the page dimensions of
	// the PrintContext.
	PageSetup() PageSetup
	// PangoFontmap returns a FontMap that is suitable for use with the
	// PrintContext.
	PangoFontmap() pango.FontMap
	// Width obtains the width of the PrintContext, in pixels.
	Width() float64
	// SetCairoContext sets a new cairo context on a print context.
	//
	// This function is intended to be used when implementing an internal print
	// preview, it is not needed for printing, since GTK itself creates a
	// suitable cairo context in that case.
	SetCairoContext(cr *cairo.Context, dpiX float64, dpiY float64)
}

type printContext struct {
	*externglib.Object
}

// WrapPrintContext wraps a GObject to the right type. It is
// primarily used internally.
func WrapPrintContext(obj *externglib.Object) PrintContext {
	return printContext{*externglib.Object{obj}}
}

func marshalPrintContext(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPrintContext(obj), nil
}

// CreatePangoContext creates a new Context that can be used with the
// PrintContext.
func (context printContext) CreatePangoContext() pango.Context {
	var arg0 *C.GtkPrintContext

	arg0 = (*C.GtkPrintContext)(context.Native())

	ret := C.gtk_print_context_create_pango_context(arg0)

	var ret0 pango.Context

	ret0 = pango.WrapContext(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// CreatePangoLayout creates a new Layout that is suitable for use with the
// PrintContext.
func (context printContext) CreatePangoLayout() pango.Layout {
	var arg0 *C.GtkPrintContext

	arg0 = (*C.GtkPrintContext)(context.Native())

	ret := C.gtk_print_context_create_pango_layout(arg0)

	var ret0 pango.Layout

	ret0 = pango.WrapLayout(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// CairoContext obtains the cairo context that is associated with the
// PrintContext.
func (context printContext) CairoContext() *cairo.Context {
	var arg0 *C.GtkPrintContext

	arg0 = (*C.GtkPrintContext)(context.Native())

	ret := C.gtk_print_context_get_cairo_context(arg0)

	var ret0 *cairo.Context

	ret0 = cairo.WrapContext(ret)

	return ret0
}

// DPIX obtains the horizontal resolution of the PrintContext, in dots per
// inch.
func (context printContext) DPIX() float64 {
	var arg0 *C.GtkPrintContext

	arg0 = (*C.GtkPrintContext)(context.Native())

	ret := C.gtk_print_context_get_dpi_x(arg0)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// DPIY obtains the vertical resolution of the PrintContext, in dots per
// inch.
func (context printContext) DPIY() float64 {
	var arg0 *C.GtkPrintContext

	arg0 = (*C.GtkPrintContext)(context.Native())

	ret := C.gtk_print_context_get_dpi_y(arg0)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// HardMargins obtains the hardware printer margins of the PrintContext, in
// units.
func (context printContext) HardMargins() (top float64, bottom float64, left float64, right float64, ok bool) {
	var arg0 *C.GtkPrintContext
	var arg1 *C.double // out
	var arg2 *C.double // out
	var arg3 *C.double // out
	var arg4 *C.double // out

	arg0 = (*C.GtkPrintContext)(context.Native())

	ret := C.gtk_print_context_get_hard_margins(arg0, &arg1, &arg2, &arg3, &arg4)

	var ret0 float64
	var ret1 float64
	var ret2 float64
	var ret3 float64
	var ret4 bool

	ret0 = float64(arg1)

	ret1 = float64(arg2)

	ret2 = float64(arg3)

	ret3 = float64(arg4)

	ret4 = gextras.Gobool(ret)

	return ret0, ret1, ret2, ret3, ret4
}

// Height obtains the height of the PrintContext, in pixels.
func (context printContext) Height() float64 {
	var arg0 *C.GtkPrintContext

	arg0 = (*C.GtkPrintContext)(context.Native())

	ret := C.gtk_print_context_get_height(arg0)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// PageSetup obtains the PageSetup that determines the page dimensions of
// the PrintContext.
func (context printContext) PageSetup() PageSetup {
	var arg0 *C.GtkPrintContext

	arg0 = (*C.GtkPrintContext)(context.Native())

	ret := C.gtk_print_context_get_page_setup(arg0)

	var ret0 PageSetup

	ret0 = WrapPageSetup(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// PangoFontmap returns a FontMap that is suitable for use with the
// PrintContext.
func (context printContext) PangoFontmap() pango.FontMap {
	var arg0 *C.GtkPrintContext

	arg0 = (*C.GtkPrintContext)(context.Native())

	ret := C.gtk_print_context_get_pango_fontmap(arg0)

	var ret0 pango.FontMap

	ret0 = pango.WrapFontMap(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Width obtains the width of the PrintContext, in pixels.
func (context printContext) Width() float64 {
	var arg0 *C.GtkPrintContext

	arg0 = (*C.GtkPrintContext)(context.Native())

	ret := C.gtk_print_context_get_width(arg0)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// SetCairoContext sets a new cairo context on a print context.
//
// This function is intended to be used when implementing an internal print
// preview, it is not needed for printing, since GTK itself creates a
// suitable cairo context in that case.
func (context printContext) SetCairoContext(cr *cairo.Context, dpiX float64, dpiY float64) {
	var arg0 *C.GtkPrintContext
	var arg1 *C.cairo_t
	var arg2 C.double
	var arg3 C.double

	arg0 = (*C.GtkPrintContext)(context.Native())
	arg1 = (*C.cairo_t)(cr.Native())
	arg2 = C.double(dpiX)
	arg3 = C.double(dpiY)

	C.gtk_print_context_set_cairo_context(arg0, arg1, arg2, arg3)
}

// PrintOperation: gtkPrintOperation is the high-level, portable printing API.
// It looks a bit different than other GTK dialogs such as the FileChooser,
// since some platforms don’t expose enough infrastructure to implement a good
// print dialog. On such platforms, GtkPrintOperation uses the native print
// dialog. On platforms which do not provide a native print dialog, GTK uses its
// own, see PrintUnixDialog.
//
// The typical way to use the high-level printing API is to create a
// GtkPrintOperation object with gtk_print_operation_new() when the user selects
// to print. Then you set some properties on it, e.g. the page size, any
// PrintSettings from previous print operations, the number of pages, the
// current page, etc.
//
// Then you start the print operation by calling gtk_print_operation_run(). It
// will then show a dialog, let the user select a printer and options. When the
// user finished the dialog various signals will be emitted on the
// PrintOperation, the main one being PrintOperation::draw-page, which you are
// supposed to catch and render the page on the provided PrintContext using
// Cairo.
//
// The high-level printing API
//
//    static GtkPrintSettings *settings = NULL;
//
//    static void
//    do_print (void)
//    {
//      GtkPrintOperation *print;
//      GtkPrintOperationResult res;
//
//      print = gtk_print_operation_new ();
//
//      if (settings != NULL)
//        gtk_print_operation_set_print_settings (print, settings);
//
//      g_signal_connect (print, "begin_print", G_CALLBACK (begin_print), NULL);
//      g_signal_connect (print, "draw_page", G_CALLBACK (draw_page), NULL);
//
//      res = gtk_print_operation_run (print, GTK_PRINT_OPERATION_ACTION_PRINT_DIALOG,
//                                     GTK_WINDOW (main_window), NULL);
//
//      if (res == GTK_PRINT_OPERATION_RESULT_APPLY)
//        {
//          if (settings != NULL)
//            g_object_unref (settings);
//          settings = g_object_ref (gtk_print_operation_get_print_settings (print));
//        }
//
//      g_object_unref (print);
//    }
//
//
// By default GtkPrintOperation uses an external application to do print
// preview. To implement a custom print preview, an application must connect to
// the preview signal. The functions gtk_print_operation_preview_render_page(),
// gtk_print_operation_preview_end_preview() and
// gtk_print_operation_preview_is_selected() are useful when implementing a
// print preview.
type PrintOperation interface {
	gextras.Objector

	// Cancel cancels a running print operation. This function may be called
	// from a PrintOperation::begin-print, PrintOperation::paginate or
	// PrintOperation::draw-page signal handler to stop the currently running
	// print operation.
	Cancel()
	// DrawPageFinish: signalize that drawing of particular page is complete.
	//
	// It is called after completion of page drawing (e.g. drawing in another
	// thread). If gtk_print_operation_set_defer_drawing() was called before,
	// then this function has to be called by application. In another case it is
	// called by the library itself.
	DrawPageFinish()
	// DefaultPageSetup returns the default page setup, see
	// gtk_print_operation_set_default_page_setup().
	DefaultPageSetup() PageSetup
	// EmbedPageSetup gets the value of PrintOperation:embed-page-setup
	// property.
	EmbedPageSetup() bool
	// Error: call this when the result of a print operation is
	// GTK_PRINT_OPERATION_RESULT_ERROR, either as returned by
	// gtk_print_operation_run(), or in the PrintOperation::done signal handler.
	// The returned #GError will contain more details on what went wrong.
	Error()
	// HasSelection gets the value of PrintOperation:has-selection property.
	HasSelection() bool
	// NPagesToPrint returns the number of pages that will be printed.
	//
	// Note that this value is set during print preparation phase
	// (GTK_PRINT_STATUS_PREPARING), so this function should never be called
	// before the data generation phase (GTK_PRINT_STATUS_GENERATING_DATA). You
	// can connect to the PrintOperation::status-changed signal and call
	// gtk_print_operation_get_n_pages_to_print() when print status is
	// GTK_PRINT_STATUS_GENERATING_DATA. This is typically used to track the
	// progress of print operation.
	NPagesToPrint() int
	// PrintSettings returns the current print settings.
	//
	// Note that the return value is nil until either
	// gtk_print_operation_set_print_settings() or gtk_print_operation_run()
	// have been called.
	PrintSettings() PrintSettings
	// Status returns the status of the print operation. Also see
	// gtk_print_operation_get_status_string().
	Status() PrintStatus
	// StatusString returns a string representation of the status of the print
	// operation. The string is translated and suitable for displaying the print
	// status e.g. in a Statusbar.
	//
	// Use gtk_print_operation_get_status() to obtain a status value that is
	// suitable for programmatic use.
	StatusString() string
	// SupportSelection gets the value of PrintOperation:support-selection
	// property.
	SupportSelection() bool
	// IsFinished: a convenience function to find out if the print operation is
	// finished, either successfully (GTK_PRINT_STATUS_FINISHED) or
	// unsuccessfully (GTK_PRINT_STATUS_FINISHED_ABORTED).
	//
	// Note: when you enable print status tracking the print operation can be in
	// a non-finished state even after done has been called, as the operation
	// status then tracks the print job status on the printer.
	IsFinished() bool
	// Run runs the print operation, by first letting the user modify print
	// settings in the print dialog, and then print the document.
	//
	// Normally that this function does not return until the rendering of all
	// pages is complete. You can connect to the PrintOperation::status-changed
	// signal on @op to obtain some information about the progress of the print
	// operation. Furthermore, it may use a recursive mainloop to show the print
	// dialog.
	//
	// If you call gtk_print_operation_set_allow_async() or set the
	// PrintOperation:allow-async property the operation will run asynchronously
	// if this is supported on the platform. The PrintOperation::done signal
	// will be emitted with the result of the operation when the it is done
	// (i.e. when the dialog is canceled, or when the print succeeds or fails).
	//
	//    if (settings != NULL)
	//      gtk_print_operation_set_print_settings (print, settings);
	//
	//    if (page_setup != NULL)
	//      gtk_print_operation_set_default_page_setup (print, page_setup);
	//
	//    g_signal_connect (print, "begin-print",
	//                      G_CALLBACK (begin_print), &data);
	//    g_signal_connect (print, "draw-page",
	//                      G_CALLBACK (draw_page), &data);
	//
	//    res = gtk_print_operation_run (print,
	//                                   GTK_PRINT_OPERATION_ACTION_PRINT_DIALOG,
	//                                   parent,
	//                                   &error);
	//
	//    if (res == GTK_PRINT_OPERATION_RESULT_ERROR)
	//     {
	//       error_dialog = gtk_message_dialog_new (GTK_WINDOW (parent),
	//      			                     GTK_DIALOG_DESTROY_WITH_PARENT,
	//    					     GTK_MESSAGE_ERROR,
	//    					     GTK_BUTTONS_CLOSE,
	//    					     "Error printing file:\ns",
	//    					     error->message);
	//       g_signal_connect (error_dialog, "response",
	//                         G_CALLBACK (gtk_window_destroy), NULL);
	//       gtk_widget_show (error_dialog);
	//       g_error_free (error);
	//     }
	//    else if (res == GTK_PRINT_OPERATION_RESULT_APPLY)
	//     {
	//       if (settings != NULL)
	//    g_object_unref (settings);
	//       settings = g_object_ref (gtk_print_operation_get_print_settings (print));
	//     }
	//
	//
	// Note that gtk_print_operation_run() can only be called once on a given
	// PrintOperation.
	Run(action PrintOperationAction, parent Window) PrintOperationResult
	// SetAllowAsync sets whether the gtk_print_operation_run() may return
	// before the print operation is completed. Note that some platforms may not
	// allow asynchronous operation.
	SetAllowAsync(allowAsync bool)
	// SetCurrentPage sets the current page.
	//
	// If this is called before gtk_print_operation_run(), the user will be able
	// to select to print only the current page.
	//
	// Note that this only makes sense for pre-paginated documents.
	SetCurrentPage(currentPage int)
	// SetCustomTabLabel sets the label for the tab holding custom widgets.
	SetCustomTabLabel(label string)
	// SetDefaultPageSetup makes @default_page_setup the default page setup for
	// @op.
	//
	// This page setup will be used by gtk_print_operation_run(), but it can be
	// overridden on a per-page basis by connecting to the
	// PrintOperation::request-page-setup signal.
	SetDefaultPageSetup(defaultPageSetup PageSetup)
	// SetDeferDrawing sets up the PrintOperation to wait for calling of
	// gtk_print_operation_draw_page_finish() from application. It can be used
	// for drawing page in another thread.
	//
	// This function must be called in the callback of “draw-page” signal.
	SetDeferDrawing()
	// SetEmbedPageSetup: embed page size combo box and orientation combo box
	// into page setup page. Selected page setup is stored as default page setup
	// in PrintOperation.
	SetEmbedPageSetup(embed bool)
	// SetExportFilename sets up the PrintOperation to generate a file instead
	// of showing the print dialog. The intended use of this function is for
	// implementing “Export to PDF” actions. Currently, PDF is the only
	// supported format.
	//
	// “Print to PDF” support is independent of this and is done by letting the
	// user pick the “Print to PDF” item from the list of printers in the print
	// dialog.
	SetExportFilename(filename string)
	// SetHasSelection sets whether there is a selection to print.
	//
	// Application has to set number of pages to which the selection will draw
	// by gtk_print_operation_set_n_pages() in a callback of
	// PrintOperation::begin-print.
	SetHasSelection(hasSelection bool)
	// SetJobName sets the name of the print job. The name is used to identify
	// the job (e.g. in monitoring applications like eggcups).
	//
	// If you don’t set a job name, GTK picks a default one by numbering
	// successive print jobs.
	SetJobName(jobName string)
	// SetNPages sets the number of pages in the document.
	//
	// This must be set to a positive number before the rendering starts. It may
	// be set in a PrintOperation::begin-print signal handler.
	//
	// Note that the page numbers passed to the
	// PrintOperation::request-page-setup and PrintOperation::draw-page signals
	// are 0-based, i.e. if the user chooses to print all pages, the last
	// ::draw-page signal will be for page @n_pages - 1.
	SetNPages(nPages int)
	// SetPrintSettings sets the print settings for @op. This is typically used
	// to re-establish print settings from a previous print operation, see
	// gtk_print_operation_run().
	SetPrintSettings(printSettings PrintSettings)
	// SetShowProgress: if @show_progress is true, the print operation will show
	// a progress dialog during the print operation.
	SetShowProgress(showProgress bool)
	// SetSupportSelection sets whether selection is supported by
	// PrintOperation.
	SetSupportSelection(supportSelection bool)
	// SetTrackPrintStatus: if track_status is true, the print operation will
	// try to continue report on the status of the print job in the printer
	// queues and printer. This can allow your application to show things like
	// “out of paper” issues, and when the print job actually reaches the
	// printer.
	//
	// This function is often implemented using some form of polling, so it
	// should not be enabled unless needed.
	SetTrackPrintStatus(trackStatus bool)
	// SetUnit sets up the transformation for the cairo context obtained from
	// PrintContext in such a way that distances are measured in units of @unit.
	SetUnit(unit Unit)
	// SetUseFullPage: if @full_page is true, the transformation for the cairo
	// context obtained from PrintContext puts the origin at the top left corner
	// of the page (which may not be the top left corner of the sheet, depending
	// on page orientation and the number of pages per sheet). Otherwise, the
	// origin is at the top left corner of the imageable area (i.e. inside the
	// margins).
	SetUseFullPage(fullPage bool)
}

type printOperation struct {
	*externglib.Object
}

// WrapPrintOperation wraps a GObject to the right type. It is
// primarily used internally.
func WrapPrintOperation(obj *externglib.Object) PrintOperation {
	return printOperation{*externglib.Object{obj}}
}

func marshalPrintOperation(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPrintOperation(obj), nil
}

// NewPrintOperation constructs a class PrintOperation.
func NewPrintOperation() PrintOperation {

	ret := C.gtk_print_operation_new()

	var ret0 PrintOperation

	ret0 = WrapPrintOperation(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Cancel cancels a running print operation. This function may be called
// from a PrintOperation::begin-print, PrintOperation::paginate or
// PrintOperation::draw-page signal handler to stop the currently running
// print operation.
func (op printOperation) Cancel() {
	var arg0 *C.GtkPrintOperation

	arg0 = (*C.GtkPrintOperation)(op.Native())

	C.gtk_print_operation_cancel(arg0)
}

// DrawPageFinish: signalize that drawing of particular page is complete.
//
// It is called after completion of page drawing (e.g. drawing in another
// thread). If gtk_print_operation_set_defer_drawing() was called before,
// then this function has to be called by application. In another case it is
// called by the library itself.
func (op printOperation) DrawPageFinish() {
	var arg0 *C.GtkPrintOperation

	arg0 = (*C.GtkPrintOperation)(op.Native())

	C.gtk_print_operation_draw_page_finish(arg0)
}

// DefaultPageSetup returns the default page setup, see
// gtk_print_operation_set_default_page_setup().
func (op printOperation) DefaultPageSetup() PageSetup {
	var arg0 *C.GtkPrintOperation

	arg0 = (*C.GtkPrintOperation)(op.Native())

	ret := C.gtk_print_operation_get_default_page_setup(arg0)

	var ret0 PageSetup

	ret0 = WrapPageSetup(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// EmbedPageSetup gets the value of PrintOperation:embed-page-setup
// property.
func (op printOperation) EmbedPageSetup() bool {
	var arg0 *C.GtkPrintOperation

	arg0 = (*C.GtkPrintOperation)(op.Native())

	ret := C.gtk_print_operation_get_embed_page_setup(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Error: call this when the result of a print operation is
// GTK_PRINT_OPERATION_RESULT_ERROR, either as returned by
// gtk_print_operation_run(), or in the PrintOperation::done signal handler.
// The returned #GError will contain more details on what went wrong.
func (op printOperation) Error() {
	var arg0 *C.GtkPrintOperation

	arg0 = (*C.GtkPrintOperation)(op.Native())

	C.gtk_print_operation_get_error(arg0)
}

// HasSelection gets the value of PrintOperation:has-selection property.
func (op printOperation) HasSelection() bool {
	var arg0 *C.GtkPrintOperation

	arg0 = (*C.GtkPrintOperation)(op.Native())

	ret := C.gtk_print_operation_get_has_selection(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// NPagesToPrint returns the number of pages that will be printed.
//
// Note that this value is set during print preparation phase
// (GTK_PRINT_STATUS_PREPARING), so this function should never be called
// before the data generation phase (GTK_PRINT_STATUS_GENERATING_DATA). You
// can connect to the PrintOperation::status-changed signal and call
// gtk_print_operation_get_n_pages_to_print() when print status is
// GTK_PRINT_STATUS_GENERATING_DATA. This is typically used to track the
// progress of print operation.
func (op printOperation) NPagesToPrint() int {
	var arg0 *C.GtkPrintOperation

	arg0 = (*C.GtkPrintOperation)(op.Native())

	ret := C.gtk_print_operation_get_n_pages_to_print(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// PrintSettings returns the current print settings.
//
// Note that the return value is nil until either
// gtk_print_operation_set_print_settings() or gtk_print_operation_run()
// have been called.
func (op printOperation) PrintSettings() PrintSettings {
	var arg0 *C.GtkPrintOperation

	arg0 = (*C.GtkPrintOperation)(op.Native())

	ret := C.gtk_print_operation_get_print_settings(arg0)

	var ret0 PrintSettings

	ret0 = WrapPrintSettings(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Status returns the status of the print operation. Also see
// gtk_print_operation_get_status_string().
func (op printOperation) Status() PrintStatus {
	var arg0 *C.GtkPrintOperation

	arg0 = (*C.GtkPrintOperation)(op.Native())

	ret := C.gtk_print_operation_get_status(arg0)

	var ret0 PrintStatus

	ret0 = PrintStatus(ret)

	return ret0
}

// StatusString returns a string representation of the status of the print
// operation. The string is translated and suitable for displaying the print
// status e.g. in a Statusbar.
//
// Use gtk_print_operation_get_status() to obtain a status value that is
// suitable for programmatic use.
func (op printOperation) StatusString() string {
	var arg0 *C.GtkPrintOperation

	arg0 = (*C.GtkPrintOperation)(op.Native())

	ret := C.gtk_print_operation_get_status_string(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// SupportSelection gets the value of PrintOperation:support-selection
// property.
func (op printOperation) SupportSelection() bool {
	var arg0 *C.GtkPrintOperation

	arg0 = (*C.GtkPrintOperation)(op.Native())

	ret := C.gtk_print_operation_get_support_selection(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// IsFinished: a convenience function to find out if the print operation is
// finished, either successfully (GTK_PRINT_STATUS_FINISHED) or
// unsuccessfully (GTK_PRINT_STATUS_FINISHED_ABORTED).
//
// Note: when you enable print status tracking the print operation can be in
// a non-finished state even after done has been called, as the operation
// status then tracks the print job status on the printer.
func (op printOperation) IsFinished() bool {
	var arg0 *C.GtkPrintOperation

	arg0 = (*C.GtkPrintOperation)(op.Native())

	ret := C.gtk_print_operation_is_finished(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Run runs the print operation, by first letting the user modify print
// settings in the print dialog, and then print the document.
//
// Normally that this function does not return until the rendering of all
// pages is complete. You can connect to the PrintOperation::status-changed
// signal on @op to obtain some information about the progress of the print
// operation. Furthermore, it may use a recursive mainloop to show the print
// dialog.
//
// If you call gtk_print_operation_set_allow_async() or set the
// PrintOperation:allow-async property the operation will run asynchronously
// if this is supported on the platform. The PrintOperation::done signal
// will be emitted with the result of the operation when the it is done
// (i.e. when the dialog is canceled, or when the print succeeds or fails).
//
//    if (settings != NULL)
//      gtk_print_operation_set_print_settings (print, settings);
//
//    if (page_setup != NULL)
//      gtk_print_operation_set_default_page_setup (print, page_setup);
//
//    g_signal_connect (print, "begin-print",
//                      G_CALLBACK (begin_print), &data);
//    g_signal_connect (print, "draw-page",
//                      G_CALLBACK (draw_page), &data);
//
//    res = gtk_print_operation_run (print,
//                                   GTK_PRINT_OPERATION_ACTION_PRINT_DIALOG,
//                                   parent,
//                                   &error);
//
//    if (res == GTK_PRINT_OPERATION_RESULT_ERROR)
//     {
//       error_dialog = gtk_message_dialog_new (GTK_WINDOW (parent),
//      			                     GTK_DIALOG_DESTROY_WITH_PARENT,
//    					     GTK_MESSAGE_ERROR,
//    					     GTK_BUTTONS_CLOSE,
//    					     "Error printing file:\ns",
//    					     error->message);
//       g_signal_connect (error_dialog, "response",
//                         G_CALLBACK (gtk_window_destroy), NULL);
//       gtk_widget_show (error_dialog);
//       g_error_free (error);
//     }
//    else if (res == GTK_PRINT_OPERATION_RESULT_APPLY)
//     {
//       if (settings != NULL)
//    g_object_unref (settings);
//       settings = g_object_ref (gtk_print_operation_get_print_settings (print));
//     }
//
//
// Note that gtk_print_operation_run() can only be called once on a given
// PrintOperation.
func (op printOperation) Run(action PrintOperationAction, parent Window) PrintOperationResult {
	var arg0 *C.GtkPrintOperation
	var arg1 C.GtkPrintOperationAction
	var arg2 *C.GtkWindow

	arg0 = (*C.GtkPrintOperation)(op.Native())
	arg1 = (C.GtkPrintOperationAction)(action)
	arg2 = (*C.GtkWindow)(parent.Native())

	ret := C.gtk_print_operation_run(arg0, arg1, arg2)

	var ret0 PrintOperationResult

	ret0 = PrintOperationResult(ret)

	return ret0
}

// SetAllowAsync sets whether the gtk_print_operation_run() may return
// before the print operation is completed. Note that some platforms may not
// allow asynchronous operation.
func (op printOperation) SetAllowAsync(allowAsync bool) {
	var arg0 *C.GtkPrintOperation
	var arg1 C.gboolean

	arg0 = (*C.GtkPrintOperation)(op.Native())
	arg1 = gextras.Cbool(allowAsync)

	C.gtk_print_operation_set_allow_async(arg0, arg1)
}

// SetCurrentPage sets the current page.
//
// If this is called before gtk_print_operation_run(), the user will be able
// to select to print only the current page.
//
// Note that this only makes sense for pre-paginated documents.
func (op printOperation) SetCurrentPage(currentPage int) {
	var arg0 *C.GtkPrintOperation
	var arg1 C.int

	arg0 = (*C.GtkPrintOperation)(op.Native())
	arg1 = C.int(currentPage)

	C.gtk_print_operation_set_current_page(arg0, arg1)
}

// SetCustomTabLabel sets the label for the tab holding custom widgets.
func (op printOperation) SetCustomTabLabel(label string) {
	var arg0 *C.GtkPrintOperation
	var arg1 *C.char

	arg0 = (*C.GtkPrintOperation)(op.Native())
	arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_print_operation_set_custom_tab_label(arg0, arg1)
}

// SetDefaultPageSetup makes @default_page_setup the default page setup for
// @op.
//
// This page setup will be used by gtk_print_operation_run(), but it can be
// overridden on a per-page basis by connecting to the
// PrintOperation::request-page-setup signal.
func (op printOperation) SetDefaultPageSetup(defaultPageSetup PageSetup) {
	var arg0 *C.GtkPrintOperation
	var arg1 *C.GtkPageSetup

	arg0 = (*C.GtkPrintOperation)(op.Native())
	arg1 = (*C.GtkPageSetup)(defaultPageSetup.Native())

	C.gtk_print_operation_set_default_page_setup(arg0, arg1)
}

// SetDeferDrawing sets up the PrintOperation to wait for calling of
// gtk_print_operation_draw_page_finish() from application. It can be used
// for drawing page in another thread.
//
// This function must be called in the callback of “draw-page” signal.
func (op printOperation) SetDeferDrawing() {
	var arg0 *C.GtkPrintOperation

	arg0 = (*C.GtkPrintOperation)(op.Native())

	C.gtk_print_operation_set_defer_drawing(arg0)
}

// SetEmbedPageSetup: embed page size combo box and orientation combo box
// into page setup page. Selected page setup is stored as default page setup
// in PrintOperation.
func (op printOperation) SetEmbedPageSetup(embed bool) {
	var arg0 *C.GtkPrintOperation
	var arg1 C.gboolean

	arg0 = (*C.GtkPrintOperation)(op.Native())
	arg1 = gextras.Cbool(embed)

	C.gtk_print_operation_set_embed_page_setup(arg0, arg1)
}

// SetExportFilename sets up the PrintOperation to generate a file instead
// of showing the print dialog. The intended use of this function is for
// implementing “Export to PDF” actions. Currently, PDF is the only
// supported format.
//
// “Print to PDF” support is independent of this and is done by letting the
// user pick the “Print to PDF” item from the list of printers in the print
// dialog.
func (op printOperation) SetExportFilename(filename string) {
	var arg0 *C.GtkPrintOperation
	var arg1 *C.char

	arg0 = (*C.GtkPrintOperation)(op.Native())
	arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_print_operation_set_export_filename(arg0, arg1)
}

// SetHasSelection sets whether there is a selection to print.
//
// Application has to set number of pages to which the selection will draw
// by gtk_print_operation_set_n_pages() in a callback of
// PrintOperation::begin-print.
func (op printOperation) SetHasSelection(hasSelection bool) {
	var arg0 *C.GtkPrintOperation
	var arg1 C.gboolean

	arg0 = (*C.GtkPrintOperation)(op.Native())
	arg1 = gextras.Cbool(hasSelection)

	C.gtk_print_operation_set_has_selection(arg0, arg1)
}

// SetJobName sets the name of the print job. The name is used to identify
// the job (e.g. in monitoring applications like eggcups).
//
// If you don’t set a job name, GTK picks a default one by numbering
// successive print jobs.
func (op printOperation) SetJobName(jobName string) {
	var arg0 *C.GtkPrintOperation
	var arg1 *C.char

	arg0 = (*C.GtkPrintOperation)(op.Native())
	arg1 = (*C.gchar)(C.CString(jobName))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_print_operation_set_job_name(arg0, arg1)
}

// SetNPages sets the number of pages in the document.
//
// This must be set to a positive number before the rendering starts. It may
// be set in a PrintOperation::begin-print signal handler.
//
// Note that the page numbers passed to the
// PrintOperation::request-page-setup and PrintOperation::draw-page signals
// are 0-based, i.e. if the user chooses to print all pages, the last
// ::draw-page signal will be for page @n_pages - 1.
func (op printOperation) SetNPages(nPages int) {
	var arg0 *C.GtkPrintOperation
	var arg1 C.int

	arg0 = (*C.GtkPrintOperation)(op.Native())
	arg1 = C.int(nPages)

	C.gtk_print_operation_set_n_pages(arg0, arg1)
}

// SetPrintSettings sets the print settings for @op. This is typically used
// to re-establish print settings from a previous print operation, see
// gtk_print_operation_run().
func (op printOperation) SetPrintSettings(printSettings PrintSettings) {
	var arg0 *C.GtkPrintOperation
	var arg1 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintOperation)(op.Native())
	arg1 = (*C.GtkPrintSettings)(printSettings.Native())

	C.gtk_print_operation_set_print_settings(arg0, arg1)
}

// SetShowProgress: if @show_progress is true, the print operation will show
// a progress dialog during the print operation.
func (op printOperation) SetShowProgress(showProgress bool) {
	var arg0 *C.GtkPrintOperation
	var arg1 C.gboolean

	arg0 = (*C.GtkPrintOperation)(op.Native())
	arg1 = gextras.Cbool(showProgress)

	C.gtk_print_operation_set_show_progress(arg0, arg1)
}

// SetSupportSelection sets whether selection is supported by
// PrintOperation.
func (op printOperation) SetSupportSelection(supportSelection bool) {
	var arg0 *C.GtkPrintOperation
	var arg1 C.gboolean

	arg0 = (*C.GtkPrintOperation)(op.Native())
	arg1 = gextras.Cbool(supportSelection)

	C.gtk_print_operation_set_support_selection(arg0, arg1)
}

// SetTrackPrintStatus: if track_status is true, the print operation will
// try to continue report on the status of the print job in the printer
// queues and printer. This can allow your application to show things like
// “out of paper” issues, and when the print job actually reaches the
// printer.
//
// This function is often implemented using some form of polling, so it
// should not be enabled unless needed.
func (op printOperation) SetTrackPrintStatus(trackStatus bool) {
	var arg0 *C.GtkPrintOperation
	var arg1 C.gboolean

	arg0 = (*C.GtkPrintOperation)(op.Native())
	arg1 = gextras.Cbool(trackStatus)

	C.gtk_print_operation_set_track_print_status(arg0, arg1)
}

// SetUnit sets up the transformation for the cairo context obtained from
// PrintContext in such a way that distances are measured in units of @unit.
func (op printOperation) SetUnit(unit Unit) {
	var arg0 *C.GtkPrintOperation
	var arg1 C.GtkUnit

	arg0 = (*C.GtkPrintOperation)(op.Native())
	arg1 = (C.GtkUnit)(unit)

	C.gtk_print_operation_set_unit(arg0, arg1)
}

// SetUseFullPage: if @full_page is true, the transformation for the cairo
// context obtained from PrintContext puts the origin at the top left corner
// of the page (which may not be the top left corner of the sheet, depending
// on page orientation and the number of pages per sheet). Otherwise, the
// origin is at the top left corner of the imageable area (i.e. inside the
// margins).
func (op printOperation) SetUseFullPage(fullPage bool) {
	var arg0 *C.GtkPrintOperation
	var arg1 C.gboolean

	arg0 = (*C.GtkPrintOperation)(op.Native())
	arg1 = gextras.Cbool(fullPage)

	C.gtk_print_operation_set_use_full_page(arg0, arg1)
}

// PrintSettings: a GtkPrintSettings object represents the settings of a print
// dialog in a system-independent way. The main use for this object is that once
// you’ve printed you can get a settings object that represents the settings the
// user chose, and the next time you print you can pass that object in so that
// the user doesn’t have to re-set all his settings.
//
// Its also possible to enumerate the settings so that you can easily save the
// settings for the next time your app runs, or even store them in a document.
// The predefined keys try to use shared values as much as possible so that
// moving such a document between systems still works.
type PrintSettings interface {
	gextras.Objector

	// Copy copies a PrintSettings object.
	Copy() PrintSettings
	// Foreach calls @func for each key-value pair of @settings.
	Foreach(_func PrintSettingsFunc)
	// Get looks up the string value associated with @key.
	Get(key string) string
	// Bool returns the boolean represented by the value that is associated with
	// @key.
	//
	// The string “true” represents true, any other string false.
	Bool(key string) bool
	// Collate gets the value of GTK_PRINT_SETTINGS_COLLATE.
	Collate() bool
	// DefaultSource gets the value of GTK_PRINT_SETTINGS_DEFAULT_SOURCE.
	DefaultSource() string
	// Dither gets the value of GTK_PRINT_SETTINGS_DITHER.
	Dither() string
	// Double returns the double value associated with @key, or 0.
	Double(key string) float64
	// DoubleWithDefault returns the floating point number represented by the
	// value that is associated with @key, or @default_val if the value does not
	// represent a floating point number.
	//
	// Floating point numbers are parsed with g_ascii_strtod().
	DoubleWithDefault(key string, def float64) float64
	// Duplex gets the value of GTK_PRINT_SETTINGS_DUPLEX.
	Duplex() PrintDuplex
	// Finishings gets the value of GTK_PRINT_SETTINGS_FINISHINGS.
	Finishings() string
	// Int returns the integer value of @key, or 0.
	Int(key string) int
	// IntWithDefault returns the value of @key, interpreted as an integer, or
	// the default value.
	IntWithDefault(key string, def int) int
	// Length returns the value associated with @key, interpreted as a length.
	// The returned value is converted to @units.
	Length(key string, unit Unit) float64
	// MediaType gets the value of GTK_PRINT_SETTINGS_MEDIA_TYPE.
	//
	// The set of media types is defined in PWG 5101.1-2002 PWG.
	MediaType() string
	// NCopies gets the value of GTK_PRINT_SETTINGS_N_COPIES.
	NCopies() int
	// NumberUp gets the value of GTK_PRINT_SETTINGS_NUMBER_UP.
	NumberUp() int
	// NumberUpLayout gets the value of GTK_PRINT_SETTINGS_NUMBER_UP_LAYOUT.
	NumberUpLayout() NumberUpLayout
	// Orientation: get the value of GTK_PRINT_SETTINGS_ORIENTATION, converted
	// to a PageOrientation.
	Orientation() PageOrientation
	// OutputBin gets the value of GTK_PRINT_SETTINGS_OUTPUT_BIN.
	OutputBin() string
	// PageRanges gets the value of GTK_PRINT_SETTINGS_PAGE_RANGES.
	PageRanges() (numRanges int, pageRanges []PageRange)
	// PageSet gets the value of GTK_PRINT_SETTINGS_PAGE_SET.
	PageSet() PageSet
	// PaperHeight gets the value of GTK_PRINT_SETTINGS_PAPER_HEIGHT, converted
	// to @unit.
	PaperHeight(unit Unit) float64
	// PaperSize gets the value of GTK_PRINT_SETTINGS_PAPER_FORMAT, converted to
	// a PaperSize.
	PaperSize() *PaperSize
	// PaperWidth gets the value of GTK_PRINT_SETTINGS_PAPER_WIDTH, converted to
	// @unit.
	PaperWidth(unit Unit) float64
	// PrintPages gets the value of GTK_PRINT_SETTINGS_PRINT_PAGES.
	PrintPages() PrintPages
	// Printer: convenience function to obtain the value of
	// GTK_PRINT_SETTINGS_PRINTER.
	Printer() string
	// PrinterLpi gets the value of GTK_PRINT_SETTINGS_PRINTER_LPI.
	PrinterLpi() float64
	// Quality gets the value of GTK_PRINT_SETTINGS_QUALITY.
	Quality() PrintQuality
	// Resolution gets the value of GTK_PRINT_SETTINGS_RESOLUTION.
	Resolution() int
	// ResolutionX gets the value of GTK_PRINT_SETTINGS_RESOLUTION_X.
	ResolutionX() int
	// ResolutionY gets the value of GTK_PRINT_SETTINGS_RESOLUTION_Y.
	ResolutionY() int
	// Reverse gets the value of GTK_PRINT_SETTINGS_REVERSE.
	Reverse() bool
	// Scale gets the value of GTK_PRINT_SETTINGS_SCALE.
	Scale() float64
	// UseColor gets the value of GTK_PRINT_SETTINGS_USE_COLOR.
	UseColor() bool
	// HasKey returns true, if a value is associated with @key.
	HasKey(key string) bool
	// LoadFile reads the print settings from @file_name. If the file could not
	// be loaded then error is set to either a Error or FileError. See
	// gtk_print_settings_to_file().
	LoadFile(fileName string) bool
	// LoadKeyFile reads the print settings from the group @group_name in
	// @key_file. If the file could not be loaded then error is set to either a
	// Error or FileError.
	LoadKeyFile(keyFile *glib.KeyFile, groupName string) bool
	// Set associates @value with @key.
	Set(key string, value string)
	// SetBool sets @key to a boolean value.
	SetBool(key string, value bool)
	// SetCollate sets the value of GTK_PRINT_SETTINGS_COLLATE.
	SetCollate(collate bool)
	// SetDefaultSource sets the value of GTK_PRINT_SETTINGS_DEFAULT_SOURCE.
	SetDefaultSource(defaultSource string)
	// SetDither sets the value of GTK_PRINT_SETTINGS_DITHER.
	SetDither(dither string)
	// SetDouble sets @key to a double value.
	SetDouble(key string, value float64)
	// SetDuplex sets the value of GTK_PRINT_SETTINGS_DUPLEX.
	SetDuplex(duplex PrintDuplex)
	// SetFinishings sets the value of GTK_PRINT_SETTINGS_FINISHINGS.
	SetFinishings(finishings string)
	// SetInt sets @key to an integer value.
	SetInt(key string, value int)
	// SetLength associates a length in units of @unit with @key.
	SetLength(key string, value float64, unit Unit)
	// SetMediaType sets the value of GTK_PRINT_SETTINGS_MEDIA_TYPE.
	//
	// The set of media types is defined in PWG 5101.1-2002 PWG.
	SetMediaType(mediaType string)
	// SetNCopies sets the value of GTK_PRINT_SETTINGS_N_COPIES.
	SetNCopies(numCopies int)
	// SetNumberUp sets the value of GTK_PRINT_SETTINGS_NUMBER_UP.
	SetNumberUp(numberUp int)
	// SetNumberUpLayout sets the value of GTK_PRINT_SETTINGS_NUMBER_UP_LAYOUT.
	SetNumberUpLayout(numberUpLayout NumberUpLayout)
	// SetOrientation sets the value of GTK_PRINT_SETTINGS_ORIENTATION.
	SetOrientation(orientation PageOrientation)
	// SetOutputBin sets the value of GTK_PRINT_SETTINGS_OUTPUT_BIN.
	SetOutputBin(outputBin string)
	// SetPageRanges sets the value of GTK_PRINT_SETTINGS_PAGE_RANGES.
	SetPageRanges(pageRanges []PageRange)
	// SetPageSet sets the value of GTK_PRINT_SETTINGS_PAGE_SET.
	SetPageSet(pageSet PageSet)
	// SetPaperHeight sets the value of GTK_PRINT_SETTINGS_PAPER_HEIGHT.
	SetPaperHeight(height float64, unit Unit)
	// SetPaperSize sets the value of GTK_PRINT_SETTINGS_PAPER_FORMAT,
	// GTK_PRINT_SETTINGS_PAPER_WIDTH and GTK_PRINT_SETTINGS_PAPER_HEIGHT.
	SetPaperSize(paperSize *PaperSize)
	// SetPaperWidth sets the value of GTK_PRINT_SETTINGS_PAPER_WIDTH.
	SetPaperWidth(width float64, unit Unit)
	// SetPrintPages sets the value of GTK_PRINT_SETTINGS_PRINT_PAGES.
	SetPrintPages(pages PrintPages)
	// SetPrinter: convenience function to set GTK_PRINT_SETTINGS_PRINTER to
	// @printer.
	SetPrinter(printer string)
	// SetPrinterLpi sets the value of GTK_PRINT_SETTINGS_PRINTER_LPI.
	SetPrinterLpi(lpi float64)
	// SetQuality sets the value of GTK_PRINT_SETTINGS_QUALITY.
	SetQuality(quality PrintQuality)
	// SetResolution sets the values of GTK_PRINT_SETTINGS_RESOLUTION,
	// GTK_PRINT_SETTINGS_RESOLUTION_X and GTK_PRINT_SETTINGS_RESOLUTION_Y.
	SetResolution(resolution int)
	// SetResolutionXY sets the values of GTK_PRINT_SETTINGS_RESOLUTION,
	// GTK_PRINT_SETTINGS_RESOLUTION_X and GTK_PRINT_SETTINGS_RESOLUTION_Y.
	SetResolutionXY(resolutionX int, resolutionY int)
	// SetReverse sets the value of GTK_PRINT_SETTINGS_REVERSE.
	SetReverse(reverse bool)
	// SetScale sets the value of GTK_PRINT_SETTINGS_SCALE.
	SetScale(scale float64)
	// SetUseColor sets the value of GTK_PRINT_SETTINGS_USE_COLOR.
	SetUseColor(useColor bool)
	// ToFile: this function saves the print settings from @settings to
	// @file_name. If the file could not be loaded then error is set to either a
	// Error or FileError.
	ToFile(fileName string) bool
	// ToGvariant: serialize print settings to an a{sv} variant.
	ToGvariant() *glib.Variant
	// ToKeyFile: this function adds the print settings from @settings to
	// @key_file.
	ToKeyFile(keyFile *glib.KeyFile, groupName string)
	// Unset removes any value associated with @key. This has the same effect as
	// setting the value to nil.
	Unset(key string)
}

type printSettings struct {
	*externglib.Object
}

// WrapPrintSettings wraps a GObject to the right type. It is
// primarily used internally.
func WrapPrintSettings(obj *externglib.Object) PrintSettings {
	return printSettings{*externglib.Object{obj}}
}

func marshalPrintSettings(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPrintSettings(obj), nil
}

// NewPrintSettings constructs a class PrintSettings.
func NewPrintSettings() PrintSettings {

	ret := C.gtk_print_settings_new()

	var ret0 PrintSettings

	ret0 = WrapPrintSettings(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewPrintSettingsFromFile constructs a class PrintSettings.
func NewPrintSettingsFromFile(fileName string) PrintSettings {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(fileName))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_print_settings_new_from_file(arg1)

	var ret0 PrintSettings

	ret0 = WrapPrintSettings(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewPrintSettingsFromGvariant constructs a class PrintSettings.
func NewPrintSettingsFromGvariant(variant *glib.Variant) PrintSettings {
	var arg1 *C.GVariant

	arg1 = (*C.GVariant)(variant.Native())

	ret := C.gtk_print_settings_new_from_gvariant(arg1)

	var ret0 PrintSettings

	ret0 = WrapPrintSettings(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewPrintSettingsFromKeyFile constructs a class PrintSettings.
func NewPrintSettingsFromKeyFile(keyFile *glib.KeyFile, groupName string) PrintSettings {
	var arg1 *C.GKeyFile
	var arg2 *C.char

	arg1 = (*C.GKeyFile)(keyFile.Native())
	arg2 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.gtk_print_settings_new_from_key_file(arg1, arg2)

	var ret0 PrintSettings

	ret0 = WrapPrintSettings(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Copy copies a PrintSettings object.
func (other printSettings) Copy() PrintSettings {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(other.Native())

	ret := C.gtk_print_settings_copy(arg0)

	var ret0 PrintSettings

	ret0 = WrapPrintSettings(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Foreach calls @func for each key-value pair of @settings.
func (settings printSettings) Foreach(_func PrintSettingsFunc) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.GtkPrintSettingsFunc
	arg2 := C.gpointer(box.Assign(userData))

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = (*[0]byte)(C.gotk4_PrintSettingsFunc)

	C.gtk_print_settings_foreach(arg0, arg1)
}

// Get looks up the string value associated with @key.
func (settings printSettings) Get(key string) string {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.char

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_print_settings_get(arg0, arg1)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Bool returns the boolean represented by the value that is associated with
// @key.
//
// The string “true” represents true, any other string false.
func (settings printSettings) Bool(key string) bool {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.char

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_print_settings_get_bool(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Collate gets the value of GTK_PRINT_SETTINGS_COLLATE.
func (settings printSettings) Collate() bool {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(settings.Native())

	ret := C.gtk_print_settings_get_collate(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// DefaultSource gets the value of GTK_PRINT_SETTINGS_DEFAULT_SOURCE.
func (settings printSettings) DefaultSource() string {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(settings.Native())

	ret := C.gtk_print_settings_get_default_source(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Dither gets the value of GTK_PRINT_SETTINGS_DITHER.
func (settings printSettings) Dither() string {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(settings.Native())

	ret := C.gtk_print_settings_get_dither(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Double returns the double value associated with @key, or 0.
func (settings printSettings) Double(key string) float64 {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.char

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_print_settings_get_double(arg0, arg1)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// DoubleWithDefault returns the floating point number represented by the
// value that is associated with @key, or @default_val if the value does not
// represent a floating point number.
//
// Floating point numbers are parsed with g_ascii_strtod().
func (settings printSettings) DoubleWithDefault(key string, def float64) float64 {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.char
	var arg2 C.double

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.double(def)

	ret := C.gtk_print_settings_get_double_with_default(arg0, arg1, arg2)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// Duplex gets the value of GTK_PRINT_SETTINGS_DUPLEX.
func (settings printSettings) Duplex() PrintDuplex {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(settings.Native())

	ret := C.gtk_print_settings_get_duplex(arg0)

	var ret0 PrintDuplex

	ret0 = PrintDuplex(ret)

	return ret0
}

// Finishings gets the value of GTK_PRINT_SETTINGS_FINISHINGS.
func (settings printSettings) Finishings() string {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(settings.Native())

	ret := C.gtk_print_settings_get_finishings(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Int returns the integer value of @key, or 0.
func (settings printSettings) Int(key string) int {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.char

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_print_settings_get_int(arg0, arg1)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// IntWithDefault returns the value of @key, interpreted as an integer, or
// the default value.
func (settings printSettings) IntWithDefault(key string, def int) int {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.char
	var arg2 C.int

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.int(def)

	ret := C.gtk_print_settings_get_int_with_default(arg0, arg1, arg2)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Length returns the value associated with @key, interpreted as a length.
// The returned value is converted to @units.
func (settings printSettings) Length(key string, unit Unit) float64 {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.char
	var arg2 C.GtkUnit

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (C.GtkUnit)(unit)

	ret := C.gtk_print_settings_get_length(arg0, arg1, arg2)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// MediaType gets the value of GTK_PRINT_SETTINGS_MEDIA_TYPE.
//
// The set of media types is defined in PWG 5101.1-2002 PWG.
func (settings printSettings) MediaType() string {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(settings.Native())

	ret := C.gtk_print_settings_get_media_type(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// NCopies gets the value of GTK_PRINT_SETTINGS_N_COPIES.
func (settings printSettings) NCopies() int {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(settings.Native())

	ret := C.gtk_print_settings_get_n_copies(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// NumberUp gets the value of GTK_PRINT_SETTINGS_NUMBER_UP.
func (settings printSettings) NumberUp() int {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(settings.Native())

	ret := C.gtk_print_settings_get_number_up(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// NumberUpLayout gets the value of GTK_PRINT_SETTINGS_NUMBER_UP_LAYOUT.
func (settings printSettings) NumberUpLayout() NumberUpLayout {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(settings.Native())

	ret := C.gtk_print_settings_get_number_up_layout(arg0)

	var ret0 NumberUpLayout

	ret0 = NumberUpLayout(ret)

	return ret0
}

// Orientation: get the value of GTK_PRINT_SETTINGS_ORIENTATION, converted
// to a PageOrientation.
func (settings printSettings) Orientation() PageOrientation {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(settings.Native())

	ret := C.gtk_print_settings_get_orientation(arg0)

	var ret0 PageOrientation

	ret0 = PageOrientation(ret)

	return ret0
}

// OutputBin gets the value of GTK_PRINT_SETTINGS_OUTPUT_BIN.
func (settings printSettings) OutputBin() string {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(settings.Native())

	ret := C.gtk_print_settings_get_output_bin(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// PageRanges gets the value of GTK_PRINT_SETTINGS_PAGE_RANGES.
func (settings printSettings) PageRanges() (numRanges int, pageRanges []PageRange) {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.int // out

	arg0 = (*C.GtkPrintSettings)(settings.Native())

	ret := C.gtk_print_settings_get_page_ranges(arg0, &arg1)

	var ret0 int
	var ret1 []PageRange

	ret0 = int(arg1)

	{
		ret1 = make([]PageRange, arg1)
		for i := 0; i < uintptr(arg1); i++ {
			src := (C.GtkPageRange)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			ret1[i] = WrapPageRange(src)
		}
	}

	return ret0, ret1
}

// PageSet gets the value of GTK_PRINT_SETTINGS_PAGE_SET.
func (settings printSettings) PageSet() PageSet {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(settings.Native())

	ret := C.gtk_print_settings_get_page_set(arg0)

	var ret0 PageSet

	ret0 = PageSet(ret)

	return ret0
}

// PaperHeight gets the value of GTK_PRINT_SETTINGS_PAPER_HEIGHT, converted
// to @unit.
func (settings printSettings) PaperHeight(unit Unit) float64 {
	var arg0 *C.GtkPrintSettings
	var arg1 C.GtkUnit

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = (C.GtkUnit)(unit)

	ret := C.gtk_print_settings_get_paper_height(arg0, arg1)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// PaperSize gets the value of GTK_PRINT_SETTINGS_PAPER_FORMAT, converted to
// a PaperSize.
func (settings printSettings) PaperSize() *PaperSize {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(settings.Native())

	ret := C.gtk_print_settings_get_paper_size(arg0)

	var ret0 *PaperSize

	ret0 = WrapPaperSize(ret)

	return ret0
}

// PaperWidth gets the value of GTK_PRINT_SETTINGS_PAPER_WIDTH, converted to
// @unit.
func (settings printSettings) PaperWidth(unit Unit) float64 {
	var arg0 *C.GtkPrintSettings
	var arg1 C.GtkUnit

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = (C.GtkUnit)(unit)

	ret := C.gtk_print_settings_get_paper_width(arg0, arg1)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// PrintPages gets the value of GTK_PRINT_SETTINGS_PRINT_PAGES.
func (settings printSettings) PrintPages() PrintPages {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(settings.Native())

	ret := C.gtk_print_settings_get_print_pages(arg0)

	var ret0 PrintPages

	ret0 = PrintPages(ret)

	return ret0
}

// Printer: convenience function to obtain the value of
// GTK_PRINT_SETTINGS_PRINTER.
func (settings printSettings) Printer() string {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(settings.Native())

	ret := C.gtk_print_settings_get_printer(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// PrinterLpi gets the value of GTK_PRINT_SETTINGS_PRINTER_LPI.
func (settings printSettings) PrinterLpi() float64 {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(settings.Native())

	ret := C.gtk_print_settings_get_printer_lpi(arg0)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// Quality gets the value of GTK_PRINT_SETTINGS_QUALITY.
func (settings printSettings) Quality() PrintQuality {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(settings.Native())

	ret := C.gtk_print_settings_get_quality(arg0)

	var ret0 PrintQuality

	ret0 = PrintQuality(ret)

	return ret0
}

// Resolution gets the value of GTK_PRINT_SETTINGS_RESOLUTION.
func (settings printSettings) Resolution() int {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(settings.Native())

	ret := C.gtk_print_settings_get_resolution(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// ResolutionX gets the value of GTK_PRINT_SETTINGS_RESOLUTION_X.
func (settings printSettings) ResolutionX() int {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(settings.Native())

	ret := C.gtk_print_settings_get_resolution_x(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// ResolutionY gets the value of GTK_PRINT_SETTINGS_RESOLUTION_Y.
func (settings printSettings) ResolutionY() int {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(settings.Native())

	ret := C.gtk_print_settings_get_resolution_y(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Reverse gets the value of GTK_PRINT_SETTINGS_REVERSE.
func (settings printSettings) Reverse() bool {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(settings.Native())

	ret := C.gtk_print_settings_get_reverse(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Scale gets the value of GTK_PRINT_SETTINGS_SCALE.
func (settings printSettings) Scale() float64 {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(settings.Native())

	ret := C.gtk_print_settings_get_scale(arg0)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// UseColor gets the value of GTK_PRINT_SETTINGS_USE_COLOR.
func (settings printSettings) UseColor() bool {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(settings.Native())

	ret := C.gtk_print_settings_get_use_color(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// HasKey returns true, if a value is associated with @key.
func (settings printSettings) HasKey(key string) bool {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.char

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_print_settings_has_key(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// LoadFile reads the print settings from @file_name. If the file could not
// be loaded then error is set to either a Error or FileError. See
// gtk_print_settings_to_file().
func (settings printSettings) LoadFile(fileName string) bool {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.char

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = (*C.gchar)(C.CString(fileName))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_print_settings_load_file(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// LoadKeyFile reads the print settings from the group @group_name in
// @key_file. If the file could not be loaded then error is set to either a
// Error or FileError.
func (settings printSettings) LoadKeyFile(keyFile *glib.KeyFile, groupName string) bool {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.GKeyFile
	var arg2 *C.char

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = (*C.GKeyFile)(keyFile.Native())
	arg2 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.gtk_print_settings_load_key_file(arg0, arg1, arg2)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Set associates @value with @key.
func (settings printSettings) Set(key string, value string) {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.char
	var arg2 *C.char

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(value))
	defer C.free(unsafe.Pointer(arg2))

	C.gtk_print_settings_set(arg0, arg1, arg2)
}

// SetBool sets @key to a boolean value.
func (settings printSettings) SetBool(key string, value bool) {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.char
	var arg2 C.gboolean

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = gextras.Cbool(value)

	C.gtk_print_settings_set_bool(arg0, arg1, arg2)
}

// SetCollate sets the value of GTK_PRINT_SETTINGS_COLLATE.
func (settings printSettings) SetCollate(collate bool) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.gboolean

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = gextras.Cbool(collate)

	C.gtk_print_settings_set_collate(arg0, arg1)
}

// SetDefaultSource sets the value of GTK_PRINT_SETTINGS_DEFAULT_SOURCE.
func (settings printSettings) SetDefaultSource(defaultSource string) {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.char

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = (*C.gchar)(C.CString(defaultSource))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_print_settings_set_default_source(arg0, arg1)
}

// SetDither sets the value of GTK_PRINT_SETTINGS_DITHER.
func (settings printSettings) SetDither(dither string) {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.char

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = (*C.gchar)(C.CString(dither))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_print_settings_set_dither(arg0, arg1)
}

// SetDouble sets @key to a double value.
func (settings printSettings) SetDouble(key string, value float64) {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.char
	var arg2 C.double

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.double(value)

	C.gtk_print_settings_set_double(arg0, arg1, arg2)
}

// SetDuplex sets the value of GTK_PRINT_SETTINGS_DUPLEX.
func (settings printSettings) SetDuplex(duplex PrintDuplex) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.GtkPrintDuplex

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = (C.GtkPrintDuplex)(duplex)

	C.gtk_print_settings_set_duplex(arg0, arg1)
}

// SetFinishings sets the value of GTK_PRINT_SETTINGS_FINISHINGS.
func (settings printSettings) SetFinishings(finishings string) {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.char

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = (*C.gchar)(C.CString(finishings))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_print_settings_set_finishings(arg0, arg1)
}

// SetInt sets @key to an integer value.
func (settings printSettings) SetInt(key string, value int) {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.char
	var arg2 C.int

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.int(value)

	C.gtk_print_settings_set_int(arg0, arg1, arg2)
}

// SetLength associates a length in units of @unit with @key.
func (settings printSettings) SetLength(key string, value float64, unit Unit) {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.char
	var arg2 C.double
	var arg3 C.GtkUnit

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.double(value)
	arg3 = (C.GtkUnit)(unit)

	C.gtk_print_settings_set_length(arg0, arg1, arg2, arg3)
}

// SetMediaType sets the value of GTK_PRINT_SETTINGS_MEDIA_TYPE.
//
// The set of media types is defined in PWG 5101.1-2002 PWG.
func (settings printSettings) SetMediaType(mediaType string) {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.char

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = (*C.gchar)(C.CString(mediaType))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_print_settings_set_media_type(arg0, arg1)
}

// SetNCopies sets the value of GTK_PRINT_SETTINGS_N_COPIES.
func (settings printSettings) SetNCopies(numCopies int) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.int

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = C.int(numCopies)

	C.gtk_print_settings_set_n_copies(arg0, arg1)
}

// SetNumberUp sets the value of GTK_PRINT_SETTINGS_NUMBER_UP.
func (settings printSettings) SetNumberUp(numberUp int) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.int

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = C.int(numberUp)

	C.gtk_print_settings_set_number_up(arg0, arg1)
}

// SetNumberUpLayout sets the value of GTK_PRINT_SETTINGS_NUMBER_UP_LAYOUT.
func (settings printSettings) SetNumberUpLayout(numberUpLayout NumberUpLayout) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.GtkNumberUpLayout

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = (C.GtkNumberUpLayout)(numberUpLayout)

	C.gtk_print_settings_set_number_up_layout(arg0, arg1)
}

// SetOrientation sets the value of GTK_PRINT_SETTINGS_ORIENTATION.
func (settings printSettings) SetOrientation(orientation PageOrientation) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.GtkPageOrientation

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = (C.GtkPageOrientation)(orientation)

	C.gtk_print_settings_set_orientation(arg0, arg1)
}

// SetOutputBin sets the value of GTK_PRINT_SETTINGS_OUTPUT_BIN.
func (settings printSettings) SetOutputBin(outputBin string) {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.char

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = (*C.gchar)(C.CString(outputBin))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_print_settings_set_output_bin(arg0, arg1)
}

// SetPageRanges sets the value of GTK_PRINT_SETTINGS_PAGE_RANGES.
func (settings printSettings) SetPageRanges(pageRanges []PageRange) {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.GtkPageRange
	var arg2 C.int

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	{
		var dst []C.GtkPageRange
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(C.malloc(C.sizeof_GtkPageRange * len(pageRanges))))
		sliceHeader.Len = len(pageRanges)
		sliceHeader.Cap = len(pageRanges)
		defer C.free(unsafe.Pointer(sliceHeader.Data))

		for i := 0; i < len(pageRanges); i++ {
			src := pageRanges[i]
			dst[i] = (C.GtkPageRange)(src.Native())
		}

		arg1 = (*C.GtkPageRange)(unsafe.Pointer(sliceHeader.Data))
		arg2 = len(pageRanges)
	}

	C.gtk_print_settings_set_page_ranges(arg0, arg1, arg2)
}

// SetPageSet sets the value of GTK_PRINT_SETTINGS_PAGE_SET.
func (settings printSettings) SetPageSet(pageSet PageSet) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.GtkPageSet

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = (C.GtkPageSet)(pageSet)

	C.gtk_print_settings_set_page_set(arg0, arg1)
}

// SetPaperHeight sets the value of GTK_PRINT_SETTINGS_PAPER_HEIGHT.
func (settings printSettings) SetPaperHeight(height float64, unit Unit) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.double
	var arg2 C.GtkUnit

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = C.double(height)
	arg2 = (C.GtkUnit)(unit)

	C.gtk_print_settings_set_paper_height(arg0, arg1, arg2)
}

// SetPaperSize sets the value of GTK_PRINT_SETTINGS_PAPER_FORMAT,
// GTK_PRINT_SETTINGS_PAPER_WIDTH and GTK_PRINT_SETTINGS_PAPER_HEIGHT.
func (settings printSettings) SetPaperSize(paperSize *PaperSize) {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.GtkPaperSize

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = (*C.GtkPaperSize)(paperSize.Native())

	C.gtk_print_settings_set_paper_size(arg0, arg1)
}

// SetPaperWidth sets the value of GTK_PRINT_SETTINGS_PAPER_WIDTH.
func (settings printSettings) SetPaperWidth(width float64, unit Unit) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.double
	var arg2 C.GtkUnit

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = C.double(width)
	arg2 = (C.GtkUnit)(unit)

	C.gtk_print_settings_set_paper_width(arg0, arg1, arg2)
}

// SetPrintPages sets the value of GTK_PRINT_SETTINGS_PRINT_PAGES.
func (settings printSettings) SetPrintPages(pages PrintPages) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.GtkPrintPages

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = (C.GtkPrintPages)(pages)

	C.gtk_print_settings_set_print_pages(arg0, arg1)
}

// SetPrinter: convenience function to set GTK_PRINT_SETTINGS_PRINTER to
// @printer.
func (settings printSettings) SetPrinter(printer string) {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.char

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = (*C.gchar)(C.CString(printer))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_print_settings_set_printer(arg0, arg1)
}

// SetPrinterLpi sets the value of GTK_PRINT_SETTINGS_PRINTER_LPI.
func (settings printSettings) SetPrinterLpi(lpi float64) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.double

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = C.double(lpi)

	C.gtk_print_settings_set_printer_lpi(arg0, arg1)
}

// SetQuality sets the value of GTK_PRINT_SETTINGS_QUALITY.
func (settings printSettings) SetQuality(quality PrintQuality) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.GtkPrintQuality

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = (C.GtkPrintQuality)(quality)

	C.gtk_print_settings_set_quality(arg0, arg1)
}

// SetResolution sets the values of GTK_PRINT_SETTINGS_RESOLUTION,
// GTK_PRINT_SETTINGS_RESOLUTION_X and GTK_PRINT_SETTINGS_RESOLUTION_Y.
func (settings printSettings) SetResolution(resolution int) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.int

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = C.int(resolution)

	C.gtk_print_settings_set_resolution(arg0, arg1)
}

// SetResolutionXY sets the values of GTK_PRINT_SETTINGS_RESOLUTION,
// GTK_PRINT_SETTINGS_RESOLUTION_X and GTK_PRINT_SETTINGS_RESOLUTION_Y.
func (settings printSettings) SetResolutionXY(resolutionX int, resolutionY int) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.int
	var arg2 C.int

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = C.int(resolutionX)
	arg2 = C.int(resolutionY)

	C.gtk_print_settings_set_resolution_xy(arg0, arg1, arg2)
}

// SetReverse sets the value of GTK_PRINT_SETTINGS_REVERSE.
func (settings printSettings) SetReverse(reverse bool) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.gboolean

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = gextras.Cbool(reverse)

	C.gtk_print_settings_set_reverse(arg0, arg1)
}

// SetScale sets the value of GTK_PRINT_SETTINGS_SCALE.
func (settings printSettings) SetScale(scale float64) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.double

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = C.double(scale)

	C.gtk_print_settings_set_scale(arg0, arg1)
}

// SetUseColor sets the value of GTK_PRINT_SETTINGS_USE_COLOR.
func (settings printSettings) SetUseColor(useColor bool) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.gboolean

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = gextras.Cbool(useColor)

	C.gtk_print_settings_set_use_color(arg0, arg1)
}

// ToFile: this function saves the print settings from @settings to
// @file_name. If the file could not be loaded then error is set to either a
// Error or FileError.
func (settings printSettings) ToFile(fileName string) bool {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.char

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = (*C.gchar)(C.CString(fileName))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_print_settings_to_file(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// ToGvariant: serialize print settings to an a{sv} variant.
func (settings printSettings) ToGvariant() *glib.Variant {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(settings.Native())

	ret := C.gtk_print_settings_to_gvariant(arg0)

	var ret0 *glib.Variant

	ret0 = glib.WrapVariant(ret)

	return ret0
}

// ToKeyFile: this function adds the print settings from @settings to
// @key_file.
func (settings printSettings) ToKeyFile(keyFile *glib.KeyFile, groupName string) {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.GKeyFile
	var arg2 *C.char

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = (*C.GKeyFile)(keyFile.Native())
	arg2 = (*C.gchar)(C.CString(groupName))
	defer C.free(unsafe.Pointer(arg2))

	C.gtk_print_settings_to_key_file(arg0, arg1, arg2)
}

// Unset removes any value associated with @key. This has the same effect as
// setting the value to nil.
func (settings printSettings) Unset(key string) {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.char

	arg0 = (*C.GtkPrintSettings)(settings.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_print_settings_unset(arg0, arg1)
}

// ProgressBar: the ProgressBar is typically used to display the progress of a
// long running operation. It provides a visual clue that processing is
// underway. The GtkProgressBar can be used in two different modes: percentage
// mode and activity mode.
//
// When an application can determine how much work needs to take place (e.g.
// read a fixed number of bytes from a file) and can monitor its progress, it
// can use the GtkProgressBar in percentage mode and the user sees a growing bar
// indicating the percentage of the work that has been completed. In this mode,
// the application is required to call gtk_progress_bar_set_fraction()
// periodically to update the progress bar.
//
// When an application has no accurate way of knowing the amount of work to do,
// it can use the ProgressBar in activity mode, which shows activity by a block
// moving back and forth within the progress area. In this mode, the application
// is required to call gtk_progress_bar_pulse() periodically to update the
// progress bar.
//
// There is quite a bit of flexibility provided to control the appearance of the
// ProgressBar. Functions are provided to control the orientation of the bar,
// optional text can be displayed along with the bar, and the step size used in
// activity mode can be set.
//
// CSS nodes
//
//    progressbar[.osd]
//    ├── [text]
//    ╰── trough[.empty][.full]
//        ╰── progress[.pulse]
//
//
// GtkProgressBar has a main CSS node with name progressbar and subnodes with
// names text and trough, of which the latter has a subnode named progress. The
// text subnode is only present if text is shown. The progress subnode has the
// style class .pulse when in activity mode. It gets the style classes .left,
// .right, .top or .bottom added when the progress 'touches' the corresponding
// end of the GtkProgressBar. The .osd class on the progressbar node is for use
// in overlays like the one Epiphany has for page loading progress.
//
//
// Accessibility
//
// GtkProgressBar uses the K_ACCESSIBLE_ROLE_PROGRESS_BAR role.
type ProgressBar interface {
	Widget

	// Ellipsize returns the ellipsizing position of the progress bar. See
	// gtk_progress_bar_set_ellipsize().
	Ellipsize() pango.EllipsizeMode
	// Fraction returns the current fraction of the task that’s been completed.
	Fraction() float64
	// Inverted gets the value set by gtk_progress_bar_set_inverted().
	Inverted() bool
	// PulseStep retrieves the pulse step set with
	// gtk_progress_bar_set_pulse_step().
	PulseStep() float64
	// ShowText gets the value of the ProgressBar:show-text property. See
	// gtk_progress_bar_set_show_text().
	ShowText() bool
	// Text retrieves the text that is displayed with the progress bar, if any,
	// otherwise nil. The return value is a reference to the text, not a copy of
	// it, so will become invalid if you change the text in the progress bar.
	Text() string
	// Pulse indicates that some progress has been made, but you don’t know how
	// much. Causes the progress bar to enter “activity mode,” where a block
	// bounces back and forth. Each call to gtk_progress_bar_pulse() causes the
	// block to move by a little bit (the amount of movement per pulse is
	// determined by gtk_progress_bar_set_pulse_step()).
	Pulse()
	// SetEllipsize sets the mode used to ellipsize (add an ellipsis: "...") the
	// text if there is not enough space to render the entire string.
	SetEllipsize(mode pango.EllipsizeMode)
	// SetFraction causes the progress bar to “fill in” the given fraction of
	// the bar. The fraction should be between 0.0 and 1.0, inclusive.
	SetFraction(fraction float64)
	// SetInverted progress bars normally grow from top to bottom or left to
	// right. Inverted progress bars grow in the opposite direction.
	SetInverted(inverted bool)
	// SetPulseStep sets the fraction of total progress bar length to move the
	// bouncing block for each call to gtk_progress_bar_pulse().
	SetPulseStep(fraction float64)
	// SetShowText sets whether the progress bar will show text next to the bar.
	// The shown text is either the value of the ProgressBar:text property or,
	// if that is nil, the ProgressBar:fraction value, as a percentage.
	//
	// To make a progress bar that is styled and sized suitably for containing
	// text (even if the actual text is blank), set ProgressBar:show-text to
	// true and ProgressBar:text to the empty string (not nil).
	SetShowText(showText bool)
	// SetText causes the given @text to appear next to the progress bar.
	//
	// If @text is nil and ProgressBar:show-text is true, the current value of
	// ProgressBar:fraction will be displayed as a percentage.
	//
	// If @text is non-nil and ProgressBar:show-text is true, the text will be
	// displayed. In this case, it will not display the progress percentage. If
	// @text is the empty string, the progress bar will still be styled and
	// sized suitably for containing text, as long as ProgressBar:show-text is
	// true.
	SetText(text string)
}

type progressBar struct {
	widget
}

// WrapProgressBar wraps a GObject to the right type. It is
// primarily used internally.
func WrapProgressBar(obj *externglib.Object) ProgressBar {
	return progressBar{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}
}

func marshalProgressBar(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapProgressBar(obj), nil
}

// NewProgressBar constructs a class ProgressBar.
func NewProgressBar() ProgressBar {

	ret := C.gtk_progress_bar_new()

	var ret0 ProgressBar

	ret0 = WrapProgressBar(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Ellipsize returns the ellipsizing position of the progress bar. See
// gtk_progress_bar_set_ellipsize().
func (pbar progressBar) Ellipsize() pango.EllipsizeMode {
	var arg0 *C.GtkProgressBar

	arg0 = (*C.GtkProgressBar)(pbar.Native())

	ret := C.gtk_progress_bar_get_ellipsize(arg0)

	var ret0 pango.EllipsizeMode

	ret0 = pango.EllipsizeMode(ret)

	return ret0
}

// Fraction returns the current fraction of the task that’s been completed.
func (pbar progressBar) Fraction() float64 {
	var arg0 *C.GtkProgressBar

	arg0 = (*C.GtkProgressBar)(pbar.Native())

	ret := C.gtk_progress_bar_get_fraction(arg0)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// Inverted gets the value set by gtk_progress_bar_set_inverted().
func (pbar progressBar) Inverted() bool {
	var arg0 *C.GtkProgressBar

	arg0 = (*C.GtkProgressBar)(pbar.Native())

	ret := C.gtk_progress_bar_get_inverted(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// PulseStep retrieves the pulse step set with
// gtk_progress_bar_set_pulse_step().
func (pbar progressBar) PulseStep() float64 {
	var arg0 *C.GtkProgressBar

	arg0 = (*C.GtkProgressBar)(pbar.Native())

	ret := C.gtk_progress_bar_get_pulse_step(arg0)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// ShowText gets the value of the ProgressBar:show-text property. See
// gtk_progress_bar_set_show_text().
func (pbar progressBar) ShowText() bool {
	var arg0 *C.GtkProgressBar

	arg0 = (*C.GtkProgressBar)(pbar.Native())

	ret := C.gtk_progress_bar_get_show_text(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Text retrieves the text that is displayed with the progress bar, if any,
// otherwise nil. The return value is a reference to the text, not a copy of
// it, so will become invalid if you change the text in the progress bar.
func (pbar progressBar) Text() string {
	var arg0 *C.GtkProgressBar

	arg0 = (*C.GtkProgressBar)(pbar.Native())

	ret := C.gtk_progress_bar_get_text(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Pulse indicates that some progress has been made, but you don’t know how
// much. Causes the progress bar to enter “activity mode,” where a block
// bounces back and forth. Each call to gtk_progress_bar_pulse() causes the
// block to move by a little bit (the amount of movement per pulse is
// determined by gtk_progress_bar_set_pulse_step()).
func (pbar progressBar) Pulse() {
	var arg0 *C.GtkProgressBar

	arg0 = (*C.GtkProgressBar)(pbar.Native())

	C.gtk_progress_bar_pulse(arg0)
}

// SetEllipsize sets the mode used to ellipsize (add an ellipsis: "...") the
// text if there is not enough space to render the entire string.
func (pbar progressBar) SetEllipsize(mode pango.EllipsizeMode) {
	var arg0 *C.GtkProgressBar
	var arg1 C.PangoEllipsizeMode

	arg0 = (*C.GtkProgressBar)(pbar.Native())
	arg1 = (C.PangoEllipsizeMode)(mode)

	C.gtk_progress_bar_set_ellipsize(arg0, arg1)
}

// SetFraction causes the progress bar to “fill in” the given fraction of
// the bar. The fraction should be between 0.0 and 1.0, inclusive.
func (pbar progressBar) SetFraction(fraction float64) {
	var arg0 *C.GtkProgressBar
	var arg1 C.double

	arg0 = (*C.GtkProgressBar)(pbar.Native())
	arg1 = C.double(fraction)

	C.gtk_progress_bar_set_fraction(arg0, arg1)
}

// SetInverted progress bars normally grow from top to bottom or left to
// right. Inverted progress bars grow in the opposite direction.
func (pbar progressBar) SetInverted(inverted bool) {
	var arg0 *C.GtkProgressBar
	var arg1 C.gboolean

	arg0 = (*C.GtkProgressBar)(pbar.Native())
	arg1 = gextras.Cbool(inverted)

	C.gtk_progress_bar_set_inverted(arg0, arg1)
}

// SetPulseStep sets the fraction of total progress bar length to move the
// bouncing block for each call to gtk_progress_bar_pulse().
func (pbar progressBar) SetPulseStep(fraction float64) {
	var arg0 *C.GtkProgressBar
	var arg1 C.double

	arg0 = (*C.GtkProgressBar)(pbar.Native())
	arg1 = C.double(fraction)

	C.gtk_progress_bar_set_pulse_step(arg0, arg1)
}

// SetShowText sets whether the progress bar will show text next to the bar.
// The shown text is either the value of the ProgressBar:text property or,
// if that is nil, the ProgressBar:fraction value, as a percentage.
//
// To make a progress bar that is styled and sized suitably for containing
// text (even if the actual text is blank), set ProgressBar:show-text to
// true and ProgressBar:text to the empty string (not nil).
func (pbar progressBar) SetShowText(showText bool) {
	var arg0 *C.GtkProgressBar
	var arg1 C.gboolean

	arg0 = (*C.GtkProgressBar)(pbar.Native())
	arg1 = gextras.Cbool(showText)

	C.gtk_progress_bar_set_show_text(arg0, arg1)
}

// SetText causes the given @text to appear next to the progress bar.
//
// If @text is nil and ProgressBar:show-text is true, the current value of
// ProgressBar:fraction will be displayed as a percentage.
//
// If @text is non-nil and ProgressBar:show-text is true, the text will be
// displayed. In this case, it will not display the progress percentage. If
// @text is the empty string, the progress bar will still be styled and
// sized suitably for containing text, as long as ProgressBar:show-text is
// true.
func (pbar progressBar) SetText(text string) {
	var arg0 *C.GtkProgressBar
	var arg1 *C.char

	arg0 = (*C.GtkProgressBar)(pbar.Native())
	arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_progress_bar_set_text(arg0, arg1)
}

type PropertyExpression interface {
	Expression

	// Expression gets the expression specifying the object of a property
	// expression.
	Expression() Expression
}

type propertyExpression struct {
	expression
}

// WrapPropertyExpression wraps a GObject to the right type. It is
// primarily used internally.
func WrapPropertyExpression(obj *externglib.Object) PropertyExpression {
	return propertyExpression{expression{obj}}
}

func marshalPropertyExpression(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPropertyExpression(obj), nil
}

// NewPropertyExpression constructs a class PropertyExpression.
func NewPropertyExpression(thisType externglib.Type, expression Expression, propertyName string) PropertyExpression {
	var arg1 C.GType
	var arg2 *C.GtkExpression
	var arg3 *C.char

	arg1 = C.GType(thisType)
	arg2 = (*C.GtkExpression)(expression.Native())
	arg3 = (*C.gchar)(C.CString(propertyName))
	defer C.free(unsafe.Pointer(arg3))

	ret := C.gtk_property_expression_new(arg1, arg2, arg3)

	var ret0 PropertyExpression

	ret0 = WrapPropertyExpression(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Expression gets the expression specifying the object of a property
// expression.
func (expression propertyExpression) Expression() Expression {
	var arg0 *C.GtkExpression

	arg0 = (*C.GtkExpression)(expression.Native())

	ret := C.gtk_property_expression_get_expression(arg0)

	var ret0 Expression

	ret0 = WrapExpression(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Range is the common base class for widgets which visualize an adjustment, e.g
// Scale or Scrollbar.
//
// Apart from signals for monitoring the parameters of the adjustment, Range
// provides properties and methods for setting a “fill level” on range widgets.
// See gtk_range_set_fill_level().
type Range interface {
	Widget

	// Adjustment: get the Adjustment which is the “model” object for Range. See
	// gtk_range_set_adjustment() for details. The return value does not have a
	// reference added, so should not be unreferenced.
	Adjustment() Adjustment
	// FillLevel gets the current position of the fill level indicator.
	FillLevel() float64
	// Flippable gets the value set by gtk_range_set_flippable().
	Flippable() bool
	// Inverted gets the value set by gtk_range_set_inverted().
	Inverted() bool
	// RangeRect: this function returns the area that contains the range’s
	// trough, in coordinates relative to @range's origin.
	//
	// This function is useful mainly for Range subclasses.
	RangeRect() gdk.Rectangle
	// RestrictToFillLevel gets whether the range is restricted to the fill
	// level.
	RestrictToFillLevel() bool
	// RoundDigits gets the number of digits to round the value to when it
	// changes. See Range::change-value.
	RoundDigits() int
	// ShowFillLevel gets whether the range displays the fill level graphically.
	ShowFillLevel() bool
	// SliderRange: this function returns sliders range along the long
	// dimension, in widget->window coordinates.
	//
	// This function is useful mainly for Range subclasses.
	SliderRange() (sliderStart int, sliderEnd int)
	// SliderSizeFixed: this function is useful mainly for Range subclasses.
	//
	// See gtk_range_set_slider_size_fixed().
	SliderSizeFixed() bool
	// Value gets the current value of the range.
	Value() float64
	// SetAdjustment sets the adjustment to be used as the “model” object for
	// this range widget. The adjustment indicates the current range value, the
	// minimum and maximum range values, the step/page increments used for
	// keybindings and scrolling, and the page size. The page size is normally 0
	// for Scale and nonzero for Scrollbar, and indicates the size of the
	// visible area of the widget being scrolled. The page size affects the size
	// of the scrollbar slider.
	SetAdjustment(adjustment Adjustment)
	// SetFillLevel: set the new position of the fill level indicator.
	//
	// The “fill level” is probably best described by its most prominent use
	// case, which is an indicator for the amount of pre-buffering in a
	// streaming media player. In that use case, the value of the range would
	// indicate the current play position, and the fill level would be the
	// position up to which the file/stream has been downloaded.
	//
	// This amount of prebuffering can be displayed on the range’s trough and is
	// themeable separately from the trough. To enable fill level display, use
	// gtk_range_set_show_fill_level(). The range defaults to not showing the
	// fill level.
	//
	// Additionally, it’s possible to restrict the range’s slider position to
	// values which are smaller than the fill level. This is controller by
	// gtk_range_set_restrict_to_fill_level() and is by default enabled.
	SetFillLevel(fillLevel float64)
	// SetFlippable: if a range is flippable, it will switch its direction if it
	// is horizontal and its direction is GTK_TEXT_DIR_RTL.
	//
	// See gtk_widget_get_direction().
	SetFlippable(flippable bool)
	// SetIncrements sets the step and page sizes for the range. The step size
	// is used when the user clicks the Scrollbar arrows or moves Scale via
	// arrow keys. The page size is used for example when moving via Page Up or
	// Page Down keys.
	SetIncrements(step float64, page float64)
	// SetInverted ranges normally move from lower to higher values as the
	// slider moves from top to bottom or left to right. Inverted ranges have
	// higher values at the top or on the right rather than on the bottom or
	// left.
	SetInverted(setting bool)
	// SetRange sets the allowable values in the Range, and clamps the range
	// value to be between @min and @max. (If the range has a non-zero page
	// size, it is clamped between @min and @max - page-size.)
	SetRange(min float64, max float64)
	// SetRestrictToFillLevel sets whether the slider is restricted to the fill
	// level. See gtk_range_set_fill_level() for a general description of the
	// fill level concept.
	SetRestrictToFillLevel(restrictToFillLevel bool)
	// SetRoundDigits sets the number of digits to round the value to when it
	// changes. See Range::change-value.
	SetRoundDigits(roundDigits int)
	// SetShowFillLevel sets whether a graphical fill level is show on the
	// trough. See gtk_range_set_fill_level() for a general description of the
	// fill level concept.
	SetShowFillLevel(showFillLevel bool)
	// SetSliderSizeFixed sets whether the range’s slider has a fixed size, or a
	// size that depends on its adjustment’s page size.
	//
	// This function is useful mainly for Range subclasses.
	SetSliderSizeFixed(sizeFixed bool)
	// SetValue sets the current value of the range; if the value is outside the
	// minimum or maximum range values, it will be clamped to fit inside them.
	// The range emits the Range::value-changed signal if the value changes.
	SetValue(value float64)
}

type _range struct {
	widget
}

// WrapRange wraps a GObject to the right type. It is
// primarily used internally.
func WrapRange(obj *externglib.Object) Range {
	return _range{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}
}

func marshalRange(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapRange(obj), nil
}

// Adjustment: get the Adjustment which is the “model” object for Range. See
// gtk_range_set_adjustment() for details. The return value does not have a
// reference added, so should not be unreferenced.
func (_range _range) Adjustment() Adjustment {
	var arg0 *C.GtkRange

	arg0 = (*C.GtkRange)(_range.Native())

	ret := C.gtk_range_get_adjustment(arg0)

	var ret0 Adjustment

	ret0 = WrapAdjustment(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// FillLevel gets the current position of the fill level indicator.
func (_range _range) FillLevel() float64 {
	var arg0 *C.GtkRange

	arg0 = (*C.GtkRange)(_range.Native())

	ret := C.gtk_range_get_fill_level(arg0)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// Flippable gets the value set by gtk_range_set_flippable().
func (_range _range) Flippable() bool {
	var arg0 *C.GtkRange

	arg0 = (*C.GtkRange)(_range.Native())

	ret := C.gtk_range_get_flippable(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Inverted gets the value set by gtk_range_set_inverted().
func (_range _range) Inverted() bool {
	var arg0 *C.GtkRange

	arg0 = (*C.GtkRange)(_range.Native())

	ret := C.gtk_range_get_inverted(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// RangeRect: this function returns the area that contains the range’s
// trough, in coordinates relative to @range's origin.
//
// This function is useful mainly for Range subclasses.
func (_range _range) RangeRect() gdk.Rectangle {
	var arg0 *C.GtkRange
	var arg1 *C.GdkRectangle // out

	arg0 = (*C.GtkRange)(_range.Native())

	ret := C.gtk_range_get_range_rect(arg0, &arg1)

	var ret0 *gdk.Rectangle

	ret0 = gdk.WrapRectangle(arg1)

	return ret0
}

// RestrictToFillLevel gets whether the range is restricted to the fill
// level.
func (_range _range) RestrictToFillLevel() bool {
	var arg0 *C.GtkRange

	arg0 = (*C.GtkRange)(_range.Native())

	ret := C.gtk_range_get_restrict_to_fill_level(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// RoundDigits gets the number of digits to round the value to when it
// changes. See Range::change-value.
func (_range _range) RoundDigits() int {
	var arg0 *C.GtkRange

	arg0 = (*C.GtkRange)(_range.Native())

	ret := C.gtk_range_get_round_digits(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// ShowFillLevel gets whether the range displays the fill level graphically.
func (_range _range) ShowFillLevel() bool {
	var arg0 *C.GtkRange

	arg0 = (*C.GtkRange)(_range.Native())

	ret := C.gtk_range_get_show_fill_level(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// SliderRange: this function returns sliders range along the long
// dimension, in widget->window coordinates.
//
// This function is useful mainly for Range subclasses.
func (_range _range) SliderRange() (sliderStart int, sliderEnd int) {
	var arg0 *C.GtkRange
	var arg1 *C.int // out
	var arg2 *C.int // out

	arg0 = (*C.GtkRange)(_range.Native())

	ret := C.gtk_range_get_slider_range(arg0, &arg1, &arg2)

	var ret0 int
	var ret1 int

	ret0 = int(arg1)

	ret1 = int(arg2)

	return ret0, ret1
}

// SliderSizeFixed: this function is useful mainly for Range subclasses.
//
// See gtk_range_set_slider_size_fixed().
func (_range _range) SliderSizeFixed() bool {
	var arg0 *C.GtkRange

	arg0 = (*C.GtkRange)(_range.Native())

	ret := C.gtk_range_get_slider_size_fixed(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Value gets the current value of the range.
func (_range _range) Value() float64 {
	var arg0 *C.GtkRange

	arg0 = (*C.GtkRange)(_range.Native())

	ret := C.gtk_range_get_value(arg0)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// SetAdjustment sets the adjustment to be used as the “model” object for
// this range widget. The adjustment indicates the current range value, the
// minimum and maximum range values, the step/page increments used for
// keybindings and scrolling, and the page size. The page size is normally 0
// for Scale and nonzero for Scrollbar, and indicates the size of the
// visible area of the widget being scrolled. The page size affects the size
// of the scrollbar slider.
func (_range _range) SetAdjustment(adjustment Adjustment) {
	var arg0 *C.GtkRange
	var arg1 *C.GtkAdjustment

	arg0 = (*C.GtkRange)(_range.Native())
	arg1 = (*C.GtkAdjustment)(adjustment.Native())

	C.gtk_range_set_adjustment(arg0, arg1)
}

// SetFillLevel: set the new position of the fill level indicator.
//
// The “fill level” is probably best described by its most prominent use
// case, which is an indicator for the amount of pre-buffering in a
// streaming media player. In that use case, the value of the range would
// indicate the current play position, and the fill level would be the
// position up to which the file/stream has been downloaded.
//
// This amount of prebuffering can be displayed on the range’s trough and is
// themeable separately from the trough. To enable fill level display, use
// gtk_range_set_show_fill_level(). The range defaults to not showing the
// fill level.
//
// Additionally, it’s possible to restrict the range’s slider position to
// values which are smaller than the fill level. This is controller by
// gtk_range_set_restrict_to_fill_level() and is by default enabled.
func (_range _range) SetFillLevel(fillLevel float64) {
	var arg0 *C.GtkRange
	var arg1 C.double

	arg0 = (*C.GtkRange)(_range.Native())
	arg1 = C.double(fillLevel)

	C.gtk_range_set_fill_level(arg0, arg1)
}

// SetFlippable: if a range is flippable, it will switch its direction if it
// is horizontal and its direction is GTK_TEXT_DIR_RTL.
//
// See gtk_widget_get_direction().
func (_range _range) SetFlippable(flippable bool) {
	var arg0 *C.GtkRange
	var arg1 C.gboolean

	arg0 = (*C.GtkRange)(_range.Native())
	arg1 = gextras.Cbool(flippable)

	C.gtk_range_set_flippable(arg0, arg1)
}

// SetIncrements sets the step and page sizes for the range. The step size
// is used when the user clicks the Scrollbar arrows or moves Scale via
// arrow keys. The page size is used for example when moving via Page Up or
// Page Down keys.
func (_range _range) SetIncrements(step float64, page float64) {
	var arg0 *C.GtkRange
	var arg1 C.double
	var arg2 C.double

	arg0 = (*C.GtkRange)(_range.Native())
	arg1 = C.double(step)
	arg2 = C.double(page)

	C.gtk_range_set_increments(arg0, arg1, arg2)
}

// SetInverted ranges normally move from lower to higher values as the
// slider moves from top to bottom or left to right. Inverted ranges have
// higher values at the top or on the right rather than on the bottom or
// left.
func (_range _range) SetInverted(setting bool) {
	var arg0 *C.GtkRange
	var arg1 C.gboolean

	arg0 = (*C.GtkRange)(_range.Native())
	arg1 = gextras.Cbool(setting)

	C.gtk_range_set_inverted(arg0, arg1)
}

// SetRange sets the allowable values in the Range, and clamps the range
// value to be between @min and @max. (If the range has a non-zero page
// size, it is clamped between @min and @max - page-size.)
func (_range _range) SetRange(min float64, max float64) {
	var arg0 *C.GtkRange
	var arg1 C.double
	var arg2 C.double

	arg0 = (*C.GtkRange)(_range.Native())
	arg1 = C.double(min)
	arg2 = C.double(max)

	C.gtk_range_set_range(arg0, arg1, arg2)
}

// SetRestrictToFillLevel sets whether the slider is restricted to the fill
// level. See gtk_range_set_fill_level() for a general description of the
// fill level concept.
func (_range _range) SetRestrictToFillLevel(restrictToFillLevel bool) {
	var arg0 *C.GtkRange
	var arg1 C.gboolean

	arg0 = (*C.GtkRange)(_range.Native())
	arg1 = gextras.Cbool(restrictToFillLevel)

	C.gtk_range_set_restrict_to_fill_level(arg0, arg1)
}

// SetRoundDigits sets the number of digits to round the value to when it
// changes. See Range::change-value.
func (_range _range) SetRoundDigits(roundDigits int) {
	var arg0 *C.GtkRange
	var arg1 C.int

	arg0 = (*C.GtkRange)(_range.Native())
	arg1 = C.int(roundDigits)

	C.gtk_range_set_round_digits(arg0, arg1)
}

// SetShowFillLevel sets whether a graphical fill level is show on the
// trough. See gtk_range_set_fill_level() for a general description of the
// fill level concept.
func (_range _range) SetShowFillLevel(showFillLevel bool) {
	var arg0 *C.GtkRange
	var arg1 C.gboolean

	arg0 = (*C.GtkRange)(_range.Native())
	arg1 = gextras.Cbool(showFillLevel)

	C.gtk_range_set_show_fill_level(arg0, arg1)
}

// SetSliderSizeFixed sets whether the range’s slider has a fixed size, or a
// size that depends on its adjustment’s page size.
//
// This function is useful mainly for Range subclasses.
func (_range _range) SetSliderSizeFixed(sizeFixed bool) {
	var arg0 *C.GtkRange
	var arg1 C.gboolean

	arg0 = (*C.GtkRange)(_range.Native())
	arg1 = gextras.Cbool(sizeFixed)

	C.gtk_range_set_slider_size_fixed(arg0, arg1)
}

// SetValue sets the current value of the range; if the value is outside the
// minimum or maximum range values, it will be clamped to fit inside them.
// The range emits the Range::value-changed signal if the value changes.
func (_range _range) SetValue(value float64) {
	var arg0 *C.GtkRange
	var arg1 C.double

	arg0 = (*C.GtkRange)(_range.Native())
	arg1 = C.double(value)

	C.gtk_range_set_value(arg0, arg1)
}

// RecentManager provides a facility for adding, removing and looking up
// recently used files. Each recently used file is identified by its URI, and
// has meta-data associated to it, like the names and command lines of the
// applications that have registered it, the number of time each application has
// registered the same file, the mime type of the file and whether the file
// should be displayed only by the applications that have registered it.
//
// The recently used files list is per user.
//
// The RecentManager acts like a database of all the recently used files. You
// can create new RecentManager objects, but it is more efficient to use the
// default manager created by GTK
//
// Adding a new recently used file is as simple as:
//
//    GtkRecentManager *manager;
//    GtkRecentInfo *info;
//    GError *error = NULL;
//
//    manager = gtk_recent_manager_get_default ();
//    info = gtk_recent_manager_lookup_item (manager, file_uri, &error);
//    if (error)
//      {
//        g_warning ("Could not find the file: s", error->message);
//        g_error_free (error);
//      }
//    else
//     {
//       // Use the info object
//       gtk_recent_info_unref (info);
//     }
//
//
// In order to retrieve the list of recently used files, you can use
// gtk_recent_manager_get_items(), which returns a list of RecentInfo.
//
// A RecentManager is the model used to populate the contents of one, or more
// RecentChooser implementations.
//
// Note that the maximum age of the recently used files list is controllable
// through the Settings:gtk-recent-files-max-age property.
type RecentManager interface {
	gextras.Objector

	// AddFull adds a new resource, pointed by @uri, into the recently used
	// resources list, using the metadata specified inside the RecentData passed
	// in @recent_data.
	//
	// The passed URI will be used to identify this resource inside the list.
	//
	// In order to register the new recently used resource, metadata about the
	// resource must be passed as well as the URI; the metadata is stored in a
	// RecentData, which must contain the MIME type of the resource pointed by
	// the URI; the name of the application that is registering the item, and a
	// command line to be used when launching the item.
	//
	// Optionally, a RecentData might contain a UTF-8 string to be used when
	// viewing the item instead of the last component of the URI; a short
	// description of the item; whether the item should be considered private -
	// that is, should be displayed only by the applications that have
	// registered it.
	AddFull(uri string, recentData *RecentData) bool
	// AddItem adds a new resource, pointed by @uri, into the recently used
	// resources list.
	//
	// This function automatically retrieves some of the needed metadata and
	// setting other metadata to common default values; it then feeds the data
	// to gtk_recent_manager_add_full().
	//
	// See gtk_recent_manager_add_full() if you want to explicitly define the
	// metadata for the resource pointed by @uri.
	AddItem(uri string) bool
	// Items gets the list of recently used resources.
	Items() *glib.List
	// HasItem checks whether there is a recently used resource registered with
	// @uri inside the recent manager.
	HasItem(uri string) bool
	// LookupItem searches for a URI inside the recently used resources list,
	// and returns a RecentInfo containing information about the resource like
	// its MIME type, or its display name.
	LookupItem(uri string) *RecentInfo
	// MoveItem changes the location of a recently used resource from @uri to
	// @new_uri.
	//
	// Please note that this function will not affect the resource pointed by
	// the URIs, but only the URI used in the recently used resources list.
	MoveItem(uri string, newURI string) bool
	// PurgeItems purges every item from the recently used resources list.
	PurgeItems() int
	// RemoveItem removes a resource pointed by @uri from the recently used
	// resources list handled by a recent manager.
	RemoveItem(uri string) bool
}

type recentManager struct {
	*externglib.Object
}

// WrapRecentManager wraps a GObject to the right type. It is
// primarily used internally.
func WrapRecentManager(obj *externglib.Object) RecentManager {
	return recentManager{*externglib.Object{obj}}
}

func marshalRecentManager(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapRecentManager(obj), nil
}

// NewRecentManager constructs a class RecentManager.
func NewRecentManager() RecentManager {

	ret := C.gtk_recent_manager_new()

	var ret0 RecentManager

	ret0 = WrapRecentManager(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// AddFull adds a new resource, pointed by @uri, into the recently used
// resources list, using the metadata specified inside the RecentData passed
// in @recent_data.
//
// The passed URI will be used to identify this resource inside the list.
//
// In order to register the new recently used resource, metadata about the
// resource must be passed as well as the URI; the metadata is stored in a
// RecentData, which must contain the MIME type of the resource pointed by
// the URI; the name of the application that is registering the item, and a
// command line to be used when launching the item.
//
// Optionally, a RecentData might contain a UTF-8 string to be used when
// viewing the item instead of the last component of the URI; a short
// description of the item; whether the item should be considered private -
// that is, should be displayed only by the applications that have
// registered it.
func (manager recentManager) AddFull(uri string, recentData *RecentData) bool {
	var arg0 *C.GtkRecentManager
	var arg1 *C.char
	var arg2 *C.GtkRecentData

	arg0 = (*C.GtkRecentManager)(manager.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GtkRecentData)(recentData.Native())

	ret := C.gtk_recent_manager_add_full(arg0, arg1, arg2)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// AddItem adds a new resource, pointed by @uri, into the recently used
// resources list.
//
// This function automatically retrieves some of the needed metadata and
// setting other metadata to common default values; it then feeds the data
// to gtk_recent_manager_add_full().
//
// See gtk_recent_manager_add_full() if you want to explicitly define the
// metadata for the resource pointed by @uri.
func (manager recentManager) AddItem(uri string) bool {
	var arg0 *C.GtkRecentManager
	var arg1 *C.char

	arg0 = (*C.GtkRecentManager)(manager.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_recent_manager_add_item(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Items gets the list of recently used resources.
func (manager recentManager) Items() *glib.List {
	var arg0 *C.GtkRecentManager

	arg0 = (*C.GtkRecentManager)(manager.Native())

	ret := C.gtk_recent_manager_get_items(arg0)

	var ret0 *glib.List

	ret0 = glib.WrapList(ret)

	return ret0
}

// HasItem checks whether there is a recently used resource registered with
// @uri inside the recent manager.
func (manager recentManager) HasItem(uri string) bool {
	var arg0 *C.GtkRecentManager
	var arg1 *C.char

	arg0 = (*C.GtkRecentManager)(manager.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_recent_manager_has_item(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// LookupItem searches for a URI inside the recently used resources list,
// and returns a RecentInfo containing information about the resource like
// its MIME type, or its display name.
func (manager recentManager) LookupItem(uri string) *RecentInfo {
	var arg0 *C.GtkRecentManager
	var arg1 *C.char

	arg0 = (*C.GtkRecentManager)(manager.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_recent_manager_lookup_item(arg0, arg1)

	var ret0 *RecentInfo

	ret0 = WrapRecentInfo(ret)

	return ret0
}

// MoveItem changes the location of a recently used resource from @uri to
// @new_uri.
//
// Please note that this function will not affect the resource pointed by
// the URIs, but only the URI used in the recently used resources list.
func (manager recentManager) MoveItem(uri string, newURI string) bool {
	var arg0 *C.GtkRecentManager
	var arg1 *C.char
	var arg2 *C.char

	arg0 = (*C.GtkRecentManager)(manager.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(newURI))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.gtk_recent_manager_move_item(arg0, arg1, arg2)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// PurgeItems purges every item from the recently used resources list.
func (manager recentManager) PurgeItems() int {
	var arg0 *C.GtkRecentManager

	arg0 = (*C.GtkRecentManager)(manager.Native())

	ret := C.gtk_recent_manager_purge_items(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// RemoveItem removes a resource pointed by @uri from the recently used
// resources list handled by a recent manager.
func (manager recentManager) RemoveItem(uri string) bool {
	var arg0 *C.GtkRecentManager
	var arg1 *C.char

	arg0 = (*C.GtkRecentManager)(manager.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_recent_manager_remove_item(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Revealer: the GtkRevealer widget is a container which animates the transition
// of its child from invisible to visible.
//
// The style of transition can be controlled with
// gtk_revealer_set_transition_type().
//
// These animations respect the Settings:gtk-enable-animations setting.
//
//
// CSS nodes
//
// GtkRevealer has a single CSS node with name revealer. When styling Revealer
// using CSS, remember that it only hides its contents, not itself. That means
// applied margin, padding and borders will be visible even when the
// Revealer:reveal-child property is set to false.
//
//
// Accessibility
//
// GtkRevealer uses the GTK_ACCESSIBLE_ROLE_GROUP role.
//
// The child of GtkRevealer, if set, is always available in the accessibility
// tree, regardless of the state of the revealer widget.
type Revealer interface {
	Widget

	// Child gets the child widget of @revealer.
	Child() Widget
	// ChildRevealed returns whether the child is fully revealed, in other words
	// whether the transition to the revealed state is completed.
	ChildRevealed() bool
	// RevealChild returns whether the child is currently revealed. See
	// gtk_revealer_set_reveal_child().
	//
	// This function returns true as soon as the transition is to the revealed
	// state is started. To learn whether the child is fully revealed (ie the
	// transition is completed), use gtk_revealer_get_child_revealed().
	RevealChild() bool
	// TransitionDuration returns the amount of time (in milliseconds) that
	// transitions will take.
	TransitionDuration() uint
	// TransitionType gets the type of animation that will be used for
	// transitions in @revealer.
	TransitionType() RevealerTransitionType
	// SetChild sets the child widget of @revealer.
	SetChild(child Widget)
	// SetRevealChild tells the Revealer to reveal or conceal its child.
	//
	// The transition will be animated with the current transition type of
	// @revealer.
	SetRevealChild(revealChild bool)
	// SetTransitionDuration sets the duration that transitions will take.
	SetTransitionDuration(duration uint)
	// SetTransitionType sets the type of animation that will be used for
	// transitions in @revealer. Available types include various kinds of fades
	// and slides.
	SetTransitionType(transition RevealerTransitionType)
}

type revealer struct {
	widget
}

// WrapRevealer wraps a GObject to the right type. It is
// primarily used internally.
func WrapRevealer(obj *externglib.Object) Revealer {
	return revealer{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}
}

func marshalRevealer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapRevealer(obj), nil
}

// NewRevealer constructs a class Revealer.
func NewRevealer() Revealer {

	ret := C.gtk_revealer_new()

	var ret0 Revealer

	ret0 = WrapRevealer(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Child gets the child widget of @revealer.
func (revealer revealer) Child() Widget {
	var arg0 *C.GtkRevealer

	arg0 = (*C.GtkRevealer)(revealer.Native())

	ret := C.gtk_revealer_get_child(arg0)

	var ret0 Widget

	ret0 = WrapWidget(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// ChildRevealed returns whether the child is fully revealed, in other words
// whether the transition to the revealed state is completed.
func (revealer revealer) ChildRevealed() bool {
	var arg0 *C.GtkRevealer

	arg0 = (*C.GtkRevealer)(revealer.Native())

	ret := C.gtk_revealer_get_child_revealed(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// RevealChild returns whether the child is currently revealed. See
// gtk_revealer_set_reveal_child().
//
// This function returns true as soon as the transition is to the revealed
// state is started. To learn whether the child is fully revealed (ie the
// transition is completed), use gtk_revealer_get_child_revealed().
func (revealer revealer) RevealChild() bool {
	var arg0 *C.GtkRevealer

	arg0 = (*C.GtkRevealer)(revealer.Native())

	ret := C.gtk_revealer_get_reveal_child(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// TransitionDuration returns the amount of time (in milliseconds) that
// transitions will take.
func (revealer revealer) TransitionDuration() uint {
	var arg0 *C.GtkRevealer

	arg0 = (*C.GtkRevealer)(revealer.Native())

	ret := C.gtk_revealer_get_transition_duration(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// TransitionType gets the type of animation that will be used for
// transitions in @revealer.
func (revealer revealer) TransitionType() RevealerTransitionType {
	var arg0 *C.GtkRevealer

	arg0 = (*C.GtkRevealer)(revealer.Native())

	ret := C.gtk_revealer_get_transition_type(arg0)

	var ret0 RevealerTransitionType

	ret0 = RevealerTransitionType(ret)

	return ret0
}

// SetChild sets the child widget of @revealer.
func (revealer revealer) SetChild(child Widget) {
	var arg0 *C.GtkRevealer
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkRevealer)(revealer.Native())
	arg1 = (*C.GtkWidget)(child.Native())

	C.gtk_revealer_set_child(arg0, arg1)
}

// SetRevealChild tells the Revealer to reveal or conceal its child.
//
// The transition will be animated with the current transition type of
// @revealer.
func (revealer revealer) SetRevealChild(revealChild bool) {
	var arg0 *C.GtkRevealer
	var arg1 C.gboolean

	arg0 = (*C.GtkRevealer)(revealer.Native())
	arg1 = gextras.Cbool(revealChild)

	C.gtk_revealer_set_reveal_child(arg0, arg1)
}

// SetTransitionDuration sets the duration that transitions will take.
func (revealer revealer) SetTransitionDuration(duration uint) {
	var arg0 *C.GtkRevealer
	var arg1 C.guint

	arg0 = (*C.GtkRevealer)(revealer.Native())
	arg1 = C.guint(duration)

	C.gtk_revealer_set_transition_duration(arg0, arg1)
}

// SetTransitionType sets the type of animation that will be used for
// transitions in @revealer. Available types include various kinds of fades
// and slides.
func (revealer revealer) SetTransitionType(transition RevealerTransitionType) {
	var arg0 *C.GtkRevealer
	var arg1 C.GtkRevealerTransitionType

	arg0 = (*C.GtkRevealer)(revealer.Native())
	arg1 = (C.GtkRevealerTransitionType)(transition)

	C.gtk_revealer_set_transition_type(arg0, arg1)
}

// Scale: a GtkScale is a slider control used to select a numeric value. To use
// it, you’ll probably want to investigate the methods on its base class, Range,
// in addition to the methods for GtkScale itself. To set the value of a scale,
// you would normally use gtk_range_set_value(). To detect changes to the value,
// you would normally use the Range::value-changed signal.
//
// Note that using the same upper and lower bounds for the Scale (through the
// Range methods) will hide the slider itself. This is useful for applications
// that want to show an undeterminate value on the scale, without changing the
// layout of the application (such as movie or music players).
//
//
// GtkScale as GtkBuildable
//
// GtkScale supports a custom <marks> element, which can contain multiple <mark>
// elements. The “value” and “position” attributes have the same meaning as
// gtk_scale_add_mark() parameters of the same name. If the element is not
// empty, its content is taken as the markup to show at the mark. It can be
// translated with the usual ”translatable” and “context” attributes.
//
// CSS nodes
//
//    scale[.fine-tune][.marks-before][.marks-after]
//    ├── [value][.top][.right][.bottom][.left]
//    ├── marks.top
//    │   ├── mark
//    │   ┊    ├── [label]
//    │   ┊    ╰── indicator
//    ┊   ┊
//    │   ╰── mark
//    ├── marks.bottom
//    │   ├── mark
//    │   ┊    ├── indicator
//    │   ┊    ╰── [label]
//    ┊   ┊
//    │   ╰── mark
//    ╰── trough
//        ├── [fill]
//        ├── [highlight]
//        ╰── slider
//
//
// GtkScale has a main CSS node with name scale and a subnode for its contents,
// with subnodes named trough and slider.
//
// The main node gets the style class .fine-tune added when the scale is in
// 'fine-tuning' mode.
//
// If the scale has an origin (see gtk_scale_set_has_origin()), there is a
// subnode with name highlight below the trough node that is used for rendering
// the highlighted part of the trough.
//
// If the scale is showing a fill level (see gtk_range_set_show_fill_level()),
// there is a subnode with name fill below the trough node that is used for
// rendering the filled in part of the trough.
//
// If marks are present, there is a marks subnode before or after the trough
// node, below which each mark gets a node with name mark. The marks nodes get
// either the .top or .bottom style class.
//
// The mark node has a subnode named indicator. If the mark has text, it also
// has a subnode named label. When the mark is either above or left of the
// scale, the label subnode is the first when present. Otherwise, the indicator
// subnode is the first.
//
// The main CSS node gets the 'marks-before' and/or 'marks-after' style classes
// added depending on what marks are present.
//
// If the scale is displaying the value (see Scale:draw-value), there is subnode
// with name value. This node will get the .top or .bottom style classes similar
// to the marks node.
//
//
// Accessibility
//
// GtkScale uses the K_ACCESSIBLE_ROLE_SLIDER role.
type Scale interface {
	Range

	// AddMark adds a mark at @value.
	//
	// A mark is indicated visually by drawing a tick mark next to the scale,
	// and GTK makes it easy for the user to position the scale exactly at the
	// marks value.
	//
	// If @markup is not nil, text is shown next to the tick mark.
	//
	// To remove marks from a scale, use gtk_scale_clear_marks().
	AddMark(value float64, position PositionType, markup string)
	// ClearMarks removes any marks that have been added with
	// gtk_scale_add_mark().
	ClearMarks()
	// Digits gets the number of decimal places that are displayed in the value.
	Digits() int
	// DrawValue returns whether the current value is displayed as a string next
	// to the slider.
	DrawValue() bool
	// HasOrigin returns whether the scale has an origin.
	HasOrigin() bool
	// Layout gets the Layout used to display the scale. The returned object is
	// owned by the scale so does not need to be freed by the caller.
	Layout() pango.Layout
	// LayoutOffsets obtains the coordinates where the scale will draw the
	// Layout representing the text in the scale. Remember when using the Layout
	// function you need to convert to and from pixels using PANGO_PIXELS() or
	// NGO_SCALE.
	//
	// If the Scale:draw-value property is false, the return values are
	// undefined.
	LayoutOffsets() (x int, y int)
	// ValuePos gets the position in which the current value is displayed.
	ValuePos() PositionType
	// SetDigits sets the number of decimal places that are displayed in the
	// value. Also causes the value of the adjustment to be rounded to this
	// number of digits, so the retrieved value matches the displayed one, if
	// Scale:draw-value is true when the value changes. If you want to enforce
	// rounding the value when Scale:draw-value is false, you can set
	// Range:round-digits instead.
	//
	// Note that rounding to a small number of digits can interfere with the
	// smooth autoscrolling that is built into Scale. As an alternative, you can
	// use gtk_scale_set_format_value_func() to format the displayed value
	// yourself.
	SetDigits(digits int)
	// SetDrawValue specifies whether the current value is displayed as a string
	// next to the slider.
	SetDrawValue(drawValue bool)
	// SetFormatValueFunc: @func allows you to change how the scale value is
	// displayed. The given function will return an allocated string
	// representing @value. That string will then be used to display the scale's
	// value.
	//
	// If LL is passed as @func, the value will be displayed on its own, rounded
	// according to the value of the Scale:digits property.
	SetFormatValueFunc(_func ScaleFormatValueFunc)
	// SetHasOrigin: if Scale:has-origin is set to true (the default), the scale
	// will highlight the part of the trough between the origin (bottom or left
	// side) and the current value.
	SetHasOrigin(hasOrigin bool)
	// SetValuePos sets the position in which the current value is displayed.
	SetValuePos(pos PositionType)
}

type scale struct {
	_range
}

// WrapScale wraps a GObject to the right type. It is
// primarily used internally.
func WrapScale(obj *externglib.Object) Scale {
	return scale{_range{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}}
}

func marshalScale(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapScale(obj), nil
}

// NewScale constructs a class Scale.
func NewScale(orientation Orientation, adjustment Adjustment) Scale {
	var arg1 C.GtkOrientation
	var arg2 *C.GtkAdjustment

	arg1 = (C.GtkOrientation)(orientation)
	arg2 = (*C.GtkAdjustment)(adjustment.Native())

	ret := C.gtk_scale_new(arg1, arg2)

	var ret0 Scale

	ret0 = WrapScale(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewScaleWithRange constructs a class Scale.
func NewScaleWithRange(orientation Orientation, min float64, max float64, step float64) Scale {
	var arg1 C.GtkOrientation
	var arg2 C.double
	var arg3 C.double
	var arg4 C.double

	arg1 = (C.GtkOrientation)(orientation)
	arg2 = C.double(min)
	arg3 = C.double(max)
	arg4 = C.double(step)

	ret := C.gtk_scale_new_with_range(arg1, arg2, arg3, arg4)

	var ret0 Scale

	ret0 = WrapScale(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// AddMark adds a mark at @value.
//
// A mark is indicated visually by drawing a tick mark next to the scale,
// and GTK makes it easy for the user to position the scale exactly at the
// marks value.
//
// If @markup is not nil, text is shown next to the tick mark.
//
// To remove marks from a scale, use gtk_scale_clear_marks().
func (scale scale) AddMark(value float64, position PositionType, markup string) {
	var arg0 *C.GtkScale
	var arg1 C.double
	var arg2 C.GtkPositionType
	var arg3 *C.char

	arg0 = (*C.GtkScale)(scale.Native())
	arg1 = C.double(value)
	arg2 = (C.GtkPositionType)(position)
	arg3 = (*C.gchar)(C.CString(markup))
	defer C.free(unsafe.Pointer(arg3))

	C.gtk_scale_add_mark(arg0, arg1, arg2, arg3)
}

// ClearMarks removes any marks that have been added with
// gtk_scale_add_mark().
func (scale scale) ClearMarks() {
	var arg0 *C.GtkScale

	arg0 = (*C.GtkScale)(scale.Native())

	C.gtk_scale_clear_marks(arg0)
}

// Digits gets the number of decimal places that are displayed in the value.
func (scale scale) Digits() int {
	var arg0 *C.GtkScale

	arg0 = (*C.GtkScale)(scale.Native())

	ret := C.gtk_scale_get_digits(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// DrawValue returns whether the current value is displayed as a string next
// to the slider.
func (scale scale) DrawValue() bool {
	var arg0 *C.GtkScale

	arg0 = (*C.GtkScale)(scale.Native())

	ret := C.gtk_scale_get_draw_value(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// HasOrigin returns whether the scale has an origin.
func (scale scale) HasOrigin() bool {
	var arg0 *C.GtkScale

	arg0 = (*C.GtkScale)(scale.Native())

	ret := C.gtk_scale_get_has_origin(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Layout gets the Layout used to display the scale. The returned object is
// owned by the scale so does not need to be freed by the caller.
func (scale scale) Layout() pango.Layout {
	var arg0 *C.GtkScale

	arg0 = (*C.GtkScale)(scale.Native())

	ret := C.gtk_scale_get_layout(arg0)

	var ret0 pango.Layout

	ret0 = pango.WrapLayout(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// LayoutOffsets obtains the coordinates where the scale will draw the
// Layout representing the text in the scale. Remember when using the Layout
// function you need to convert to and from pixels using PANGO_PIXELS() or
// NGO_SCALE.
//
// If the Scale:draw-value property is false, the return values are
// undefined.
func (scale scale) LayoutOffsets() (x int, y int) {
	var arg0 *C.GtkScale
	var arg1 *C.int // out
	var arg2 *C.int // out

	arg0 = (*C.GtkScale)(scale.Native())

	ret := C.gtk_scale_get_layout_offsets(arg0, &arg1, &arg2)

	var ret0 int
	var ret1 int

	ret0 = int(arg1)

	ret1 = int(arg2)

	return ret0, ret1
}

// ValuePos gets the position in which the current value is displayed.
func (scale scale) ValuePos() PositionType {
	var arg0 *C.GtkScale

	arg0 = (*C.GtkScale)(scale.Native())

	ret := C.gtk_scale_get_value_pos(arg0)

	var ret0 PositionType

	ret0 = PositionType(ret)

	return ret0
}

// SetDigits sets the number of decimal places that are displayed in the
// value. Also causes the value of the adjustment to be rounded to this
// number of digits, so the retrieved value matches the displayed one, if
// Scale:draw-value is true when the value changes. If you want to enforce
// rounding the value when Scale:draw-value is false, you can set
// Range:round-digits instead.
//
// Note that rounding to a small number of digits can interfere with the
// smooth autoscrolling that is built into Scale. As an alternative, you can
// use gtk_scale_set_format_value_func() to format the displayed value
// yourself.
func (scale scale) SetDigits(digits int) {
	var arg0 *C.GtkScale
	var arg1 C.int

	arg0 = (*C.GtkScale)(scale.Native())
	arg1 = C.int(digits)

	C.gtk_scale_set_digits(arg0, arg1)
}

// SetDrawValue specifies whether the current value is displayed as a string
// next to the slider.
func (scale scale) SetDrawValue(drawValue bool) {
	var arg0 *C.GtkScale
	var arg1 C.gboolean

	arg0 = (*C.GtkScale)(scale.Native())
	arg1 = gextras.Cbool(drawValue)

	C.gtk_scale_set_draw_value(arg0, arg1)
}

// SetFormatValueFunc: @func allows you to change how the scale value is
// displayed. The given function will return an allocated string
// representing @value. That string will then be used to display the scale's
// value.
//
// If LL is passed as @func, the value will be displayed on its own, rounded
// according to the value of the Scale:digits property.
func (scale scale) SetFormatValueFunc(_func ScaleFormatValueFunc) {
	var arg0 *C.GtkScale
	var arg1 C.GtkScaleFormatValueFunc
	arg2 := C.gpointer(box.Assign(userData))

	arg0 = (*C.GtkScale)(scale.Native())
	arg1 = (*[0]byte)(C.gotk4_ScaleFormatValueFunc)

	C.gtk_scale_set_format_value_func(arg0, arg1, (*[0]byte)(C.callbackDelete))
}

// SetHasOrigin: if Scale:has-origin is set to true (the default), the scale
// will highlight the part of the trough between the origin (bottom or left
// side) and the current value.
func (scale scale) SetHasOrigin(hasOrigin bool) {
	var arg0 *C.GtkScale
	var arg1 C.gboolean

	arg0 = (*C.GtkScale)(scale.Native())
	arg1 = gextras.Cbool(hasOrigin)

	C.gtk_scale_set_has_origin(arg0, arg1)
}

// SetValuePos sets the position in which the current value is displayed.
func (scale scale) SetValuePos(pos PositionType) {
	var arg0 *C.GtkScale
	var arg1 C.GtkPositionType

	arg0 = (*C.GtkScale)(scale.Native())
	arg1 = (C.GtkPositionType)(pos)

	C.gtk_scale_set_value_pos(arg0, arg1)
}

// ScaleButton provides a button which pops up a scale widget. This kind of
// widget is commonly used for volume controls in multimedia applications, and
// GTK provides a VolumeButton subclass that is tailored for this use case.
//
//
// CSS nodes
//
// GtkScaleButton has a single CSS node with name button. To differentiate it
// from a plain Button, it gets the .scale style class.
type ScaleButton interface {
	Widget

	// Adjustment gets the Adjustment associated with the ScaleButton’s scale.
	// See gtk_range_get_adjustment() for details.
	Adjustment() Adjustment
	// MinusButton retrieves the minus button of the ScaleButton.
	MinusButton() Button
	// PlusButton retrieves the plus button of the ScaleButton.
	PlusButton() Button
	// Popup retrieves the popup of the ScaleButton.
	Popup() Widget
	// Value gets the current value of the scale button.
	Value() float64
	// SetAdjustment sets the Adjustment to be used as a model for the
	// ScaleButton’s scale. See gtk_range_set_adjustment() for details.
	SetAdjustment(adjustment Adjustment)
	// SetIcons sets the icons to be used by the scale button. For details, see
	// the ScaleButton:icons property.
	SetIcons(icons []string)
	// SetValue sets the current value of the scale; if the value is outside the
	// minimum or maximum range values, it will be clamped to fit inside them.
	// The scale button emits the ScaleButton::value-changed signal if the value
	// changes.
	SetValue(value float64)
}

type scaleButton struct {
	widget
}

// WrapScaleButton wraps a GObject to the right type. It is
// primarily used internally.
func WrapScaleButton(obj *externglib.Object) ScaleButton {
	return scaleButton{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}
}

func marshalScaleButton(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapScaleButton(obj), nil
}

// NewScaleButton constructs a class ScaleButton.
func NewScaleButton(min float64, max float64, step float64, icons []string) ScaleButton {
	var arg1 C.double
	var arg2 C.double
	var arg3 C.double
	var arg4 **C.char

	arg1 = C.double(min)
	arg2 = C.double(max)
	arg3 = C.double(step)
	{

	}

	ret := C.gtk_scale_button_new(arg1, arg2, arg3, arg4)

	var ret0 ScaleButton

	ret0 = WrapScaleButton(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Adjustment gets the Adjustment associated with the ScaleButton’s scale.
// See gtk_range_get_adjustment() for details.
func (button scaleButton) Adjustment() Adjustment {
	var arg0 *C.GtkScaleButton

	arg0 = (*C.GtkScaleButton)(button.Native())

	ret := C.gtk_scale_button_get_adjustment(arg0)

	var ret0 Adjustment

	ret0 = WrapAdjustment(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// MinusButton retrieves the minus button of the ScaleButton.
func (button scaleButton) MinusButton() Button {
	var arg0 *C.GtkScaleButton

	arg0 = (*C.GtkScaleButton)(button.Native())

	ret := C.gtk_scale_button_get_minus_button(arg0)

	var ret0 Button

	ret0 = WrapButton(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// PlusButton retrieves the plus button of the ScaleButton.
func (button scaleButton) PlusButton() Button {
	var arg0 *C.GtkScaleButton

	arg0 = (*C.GtkScaleButton)(button.Native())

	ret := C.gtk_scale_button_get_plus_button(arg0)

	var ret0 Button

	ret0 = WrapButton(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Popup retrieves the popup of the ScaleButton.
func (button scaleButton) Popup() Widget {
	var arg0 *C.GtkScaleButton

	arg0 = (*C.GtkScaleButton)(button.Native())

	ret := C.gtk_scale_button_get_popup(arg0)

	var ret0 Widget

	ret0 = WrapWidget(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Value gets the current value of the scale button.
func (button scaleButton) Value() float64 {
	var arg0 *C.GtkScaleButton

	arg0 = (*C.GtkScaleButton)(button.Native())

	ret := C.gtk_scale_button_get_value(arg0)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// SetAdjustment sets the Adjustment to be used as a model for the
// ScaleButton’s scale. See gtk_range_set_adjustment() for details.
func (button scaleButton) SetAdjustment(adjustment Adjustment) {
	var arg0 *C.GtkScaleButton
	var arg1 *C.GtkAdjustment

	arg0 = (*C.GtkScaleButton)(button.Native())
	arg1 = (*C.GtkAdjustment)(adjustment.Native())

	C.gtk_scale_button_set_adjustment(arg0, arg1)
}

// SetIcons sets the icons to be used by the scale button. For details, see
// the ScaleButton:icons property.
func (button scaleButton) SetIcons(icons []string) {
	var arg0 *C.GtkScaleButton
	var arg1 **C.char

	arg0 = (*C.GtkScaleButton)(button.Native())
	{

	}

	C.gtk_scale_button_set_icons(arg0, arg1)
}

// SetValue sets the current value of the scale; if the value is outside the
// minimum or maximum range values, it will be clamped to fit inside them.
// The scale button emits the ScaleButton::value-changed signal if the value
// changes.
func (button scaleButton) SetValue(value float64) {
	var arg0 *C.GtkScaleButton
	var arg1 C.double

	arg0 = (*C.GtkScaleButton)(button.Native())
	arg1 = C.double(value)

	C.gtk_scale_button_set_value(arg0, arg1)
}

// Scrollbar: the Scrollbar widget is a horizontal or vertical scrollbar,
// depending on the value of the Orientable:orientation property.
//
// Its position and movement are controlled by the adjustment that is passed to
// or created by gtk_scrollbar_new(). See Adjustment for more details. The
// Adjustment:value field sets the position of the thumb and must be between
// Adjustment:lower and Adjustment:upper - Adjustment:page-size. The
// Adjustment:page-size represents the size of the visible scrollable area. The
// fields Adjustment:step-increment and Adjustment:page-increment fields are
// added to or subtracted from the Adjustment:value when the user asks to move
// by a step (using e.g. the cursor arrow keys) or by a page (using e.g. the
// Page Down/Up keys).
//
// CSS nodes
//
//    scrollbar
//    ╰── range[.fine-tune]
//        ╰── trough
//            ╰── slider
//
//
// GtkScrollbar has a main CSS node with name scrollbar and a subnode for its
// contents. The main node gets the .horizontal or .vertical style classes
// applied, depending on the scrollbar's orientation.
//
// The range node gets the style class .fine-tune added when the scrollbar is in
// 'fine-tuning' mode.
//
// Other style classes that may be added to scrollbars inside ScrolledWindow
// include the positional classes (.left, .right, .top, .bottom) and style
// classes related to overlay scrolling (.overlay-indicator, .dragging,
// .hovering).
//
//
// Accessibility
//
// GtkScrollbar uses the K_ACCESSIBLE_ROLE_SCROLLBAR role.
type Scrollbar interface {
	Widget

	// Adjustment returns the scrollbar's adjustment.
	Adjustment() Adjustment
	// SetAdjustment makes the scrollbar use the given adjustment.
	SetAdjustment(adjustment Adjustment)
}

type scrollbar struct {
	widget
}

// WrapScrollbar wraps a GObject to the right type. It is
// primarily used internally.
func WrapScrollbar(obj *externglib.Object) Scrollbar {
	return scrollbar{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}
}

func marshalScrollbar(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapScrollbar(obj), nil
}

// NewScrollbar constructs a class Scrollbar.
func NewScrollbar(orientation Orientation, adjustment Adjustment) Scrollbar {
	var arg1 C.GtkOrientation
	var arg2 *C.GtkAdjustment

	arg1 = (C.GtkOrientation)(orientation)
	arg2 = (*C.GtkAdjustment)(adjustment.Native())

	ret := C.gtk_scrollbar_new(arg1, arg2)

	var ret0 Scrollbar

	ret0 = WrapScrollbar(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Adjustment returns the scrollbar's adjustment.
func (self scrollbar) Adjustment() Adjustment {
	var arg0 *C.GtkScrollbar

	arg0 = (*C.GtkScrollbar)(self.Native())

	ret := C.gtk_scrollbar_get_adjustment(arg0)

	var ret0 Adjustment

	ret0 = WrapAdjustment(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// SetAdjustment makes the scrollbar use the given adjustment.
func (self scrollbar) SetAdjustment(adjustment Adjustment) {
	var arg0 *C.GtkScrollbar
	var arg1 *C.GtkAdjustment

	arg0 = (*C.GtkScrollbar)(self.Native())
	arg1 = (*C.GtkAdjustment)(adjustment.Native())

	C.gtk_scrollbar_set_adjustment(arg0, arg1)
}

// ScrolledWindow: gtkScrolledWindow is a container that accepts a single child
// widget, makes that child scrollable using either internally added scrollbars
// or externally associated adjustments, and optionally draws a frame around the
// child.
//
// Widgets with native scrolling support, i.e. those whose classes implement the
// Scrollable interface, are added directly. For other types of widget, the
// class Viewport acts as an adaptor, giving scrollability to other widgets.
// gtk_scrolled_window_set_child() intelligently accounts for whether or not the
// added child is a Scrollable. If it isn’t, ScrolledWindow wraps the child in a
// Viewport and adds that for you. Therefore, you can just add any child widget
// and not worry about the details.
//
// If gtk_scrolled_window_set_child() has added a Viewport for you, you can
// remove both your added child widget from the Viewport, and the Viewport from
// the GtkScrolledWindow, like this:
//
//    GtkWidget *scrolled_window = gtk_scrolled_window_new ();
//    GtkWidget *child_widget = gtk_button_new ();
//
//    // GtkButton is not a GtkScrollable, so GtkScrolledWindow will automatically
//    // add a GtkViewport.
//    gtk_box_append (GTK_BOX (scrolled_window),
//                       child_widget);
//
//    // Either of these will result in child_widget being unparented:
//    gtk_box_remove (GTK_BOX (scrolled_window),
//                          child_widget);
//    // or
//    gtk_box_remove (GTK_BOX (scrolled_window),
//                          gtk_bin_get_child (GTK_BIN (scrolled_window)));
//
//
// Unless ScrolledWindow:hscrollbar-policy and ScrolledWindow:vscrollbar-policy
// are GTK_POLICY_NEVER or GTK_POLICY_EXTERNAL, GtkScrolledWindow adds internal
// Scrollbar widgets around its child. The scroll position of the child, and if
// applicable the scrollbars, is controlled by the ScrolledWindow:hadjustment
// and ScrolledWindow:vadjustment that are associated with the
// GtkScrolledWindow. See the docs on Scrollbar for the details, but note that
// the “step_increment” and “page_increment” fields are only effective if the
// policy causes scrollbars to be present.
//
// If a GtkScrolledWindow doesn’t behave quite as you would like, or doesn’t
// have exactly the right layout, it’s very possible to set up your own
// scrolling with Scrollbar and for example a Grid.
//
//
// Touch support
//
// GtkScrolledWindow has built-in support for touch devices. When a touchscreen
// is used, swiping will move the scrolled window, and will expose 'kinetic'
// behavior. This can be turned off with the ScrolledWindow:kinetic-scrolling
// property if it is undesired.
//
// GtkScrolledWindow also displays visual 'overshoot' indication when the
// content is pulled beyond the end, and this situation can be captured with the
// ScrolledWindow::edge-overshot signal.
//
// If no mouse device is present, the scrollbars will overlaid as narrow,
// auto-hiding indicators over the content. If traditional scrollbars are
// desired although no mouse is present, this behaviour can be turned off with
// the ScrolledWindow:overlay-scrolling property.
//
//
// CSS nodes
//
// GtkScrolledWindow has a main CSS node with name scrolledwindow. It gets a
// .frame style class added when ScrolledWindow:has-frame is true.
//
// It uses subnodes with names overshoot and undershoot to draw the overflow and
// underflow indications. These nodes get the .left, .right, .top or .bottom
// style class added depending on where the indication is drawn.
//
// GtkScrolledWindow also sets the positional style classes (.left, .right,
// .top, .bottom) and style classes related to overlay scrolling
// (.overlay-indicator, .dragging, .hovering) on its scrollbars.
//
// If both scrollbars are visible, the area where they meet is drawn with a
// subnode named junction.
//
//
// Accessibility
//
// GtkScrolledWindow uses the GTK_ACCESSIBLE_ROLE_GROUP role.
type ScrolledWindow interface {
	Widget

	// Child gets the child widget of @scrolled_window.
	Child() Widget
	// Hadjustment returns the horizontal scrollbar’s adjustment, used to
	// connect the horizontal scrollbar to the child widget’s horizontal scroll
	// functionality.
	Hadjustment() Adjustment
	// HasFrame gets whether the scrolled window draws a frame. See
	// gtk_scrolled_window_set_has_frame().
	HasFrame() bool
	// Hscrollbar returns the horizontal scrollbar of @scrolled_window.
	Hscrollbar() Widget
	// KineticScrolling returns the specified kinetic scrolling behavior.
	KineticScrolling() bool
	// MaxContentHeight returns the maximum content height set.
	MaxContentHeight() int
	// MaxContentWidth returns the maximum content width set.
	MaxContentWidth() int
	// MinContentHeight gets the minimal content height of @scrolled_window, or
	// -1 if not set.
	MinContentHeight() int
	// MinContentWidth gets the minimum content width of @scrolled_window, or -1
	// if not set.
	MinContentWidth() int
	// OverlayScrolling returns whether overlay scrolling is enabled for this
	// scrolled window.
	OverlayScrolling() bool
	// Placement gets the placement of the contents with respect to the
	// scrollbars for the scrolled window. See
	// gtk_scrolled_window_set_placement().
	Placement() CornerType
	// Policy retrieves the current policy values for the horizontal and
	// vertical scrollbars. See gtk_scrolled_window_set_policy().
	Policy() (hscrollbarPolicy PolicyType, vscrollbarPolicy PolicyType)
	// PropagateNaturalHeight reports whether the natural height of the child
	// will be calculated and propagated through the scrolled window’s requested
	// natural height.
	PropagateNaturalHeight() bool
	// PropagateNaturalWidth reports whether the natural width of the child will
	// be calculated and propagated through the scrolled window’s requested
	// natural width.
	PropagateNaturalWidth() bool
	// Vadjustment returns the vertical scrollbar’s adjustment, used to connect
	// the vertical scrollbar to the child widget’s vertical scroll
	// functionality.
	Vadjustment() Adjustment
	// Vscrollbar returns the vertical scrollbar of @scrolled_window.
	Vscrollbar() Widget
	// SetChild sets the child widget of @scrolled_window.
	SetChild(child Widget)
	// SetHadjustment sets the Adjustment for the horizontal scrollbar.
	SetHadjustment(hadjustment Adjustment)
	// SetHasFrame changes the frame drawn around the contents of
	// @scrolled_window.
	SetHasFrame(hasFrame bool)
	// SetKineticScrolling turns kinetic scrolling on or off. Kinetic scrolling
	// only applies to devices with source GDK_SOURCE_TOUCHSCREEN.
	SetKineticScrolling(kineticScrolling bool)
	// SetMaxContentHeight sets the maximum height that @scrolled_window should
	// keep visible. The @scrolled_window will grow up to this height before it
	// starts scrolling the content.
	//
	// It is a programming error to set the maximum content height to a value
	// smaller than ScrolledWindow:min-content-height.
	SetMaxContentHeight(height int)
	// SetMaxContentWidth sets the maximum width that @scrolled_window should
	// keep visible. The @scrolled_window will grow up to this width before it
	// starts scrolling the content.
	//
	// It is a programming error to set the maximum content width to a value
	// smaller than ScrolledWindow:min-content-width.
	SetMaxContentWidth(width int)
	// SetMinContentHeight sets the minimum height that @scrolled_window should
	// keep visible. Note that this can and (usually will) be smaller than the
	// minimum size of the content.
	//
	// It is a programming error to set the minimum content height to a value
	// greater than ScrolledWindow:max-content-height.
	SetMinContentHeight(height int)
	// SetMinContentWidth sets the minimum width that @scrolled_window should
	// keep visible. Note that this can and (usually will) be smaller than the
	// minimum size of the content.
	//
	// It is a programming error to set the minimum content width to a value
	// greater than ScrolledWindow:max-content-width.
	SetMinContentWidth(width int)
	// SetOverlayScrolling enables or disables overlay scrolling for this
	// scrolled window.
	SetOverlayScrolling(overlayScrolling bool)
	// SetPlacement sets the placement of the contents with respect to the
	// scrollbars for the scrolled window.
	//
	// The default is GTK_CORNER_TOP_LEFT, meaning the child is in the top left,
	// with the scrollbars underneath and to the right. Other values in
	// CornerType are GTK_CORNER_TOP_RIGHT, GTK_CORNER_BOTTOM_LEFT, and
	// GTK_CORNER_BOTTOM_RIGHT.
	//
	// See also gtk_scrolled_window_get_placement() and
	// gtk_scrolled_window_unset_placement().
	SetPlacement(windowPlacement CornerType)
	// SetPolicy sets the scrollbar policy for the horizontal and vertical
	// scrollbars.
	//
	// The policy determines when the scrollbar should appear; it is a value
	// from the PolicyType enumeration. If GTK_POLICY_ALWAYS, the scrollbar is
	// always present; if GTK_POLICY_NEVER, the scrollbar is never present; if
	// GTK_POLICY_AUTOMATIC, the scrollbar is present only if needed (that is,
	// if the slider part of the bar would be smaller than the trough — the
	// display is larger than the page size).
	SetPolicy(hscrollbarPolicy PolicyType, vscrollbarPolicy PolicyType)
	// SetPropagateNaturalHeight sets whether the natural height of the child
	// should be calculated and propagated through the scrolled window’s
	// requested natural height.
	SetPropagateNaturalHeight(propagate bool)
	// SetPropagateNaturalWidth sets whether the natural width of the child
	// should be calculated and propagated through the scrolled window’s
	// requested natural width.
	SetPropagateNaturalWidth(propagate bool)
	// SetVadjustment sets the Adjustment for the vertical scrollbar.
	SetVadjustment(vadjustment Adjustment)
	// UnsetPlacement unsets the placement of the contents with respect to the
	// scrollbars for the scrolled window. If no window placement is set for a
	// scrolled window, it defaults to GTK_CORNER_TOP_LEFT.
	//
	// See also gtk_scrolled_window_set_placement() and
	// gtk_scrolled_window_get_placement().
	UnsetPlacement()
}

type scrolledWindow struct {
	widget
}

// WrapScrolledWindow wraps a GObject to the right type. It is
// primarily used internally.
func WrapScrolledWindow(obj *externglib.Object) ScrolledWindow {
	return scrolledWindow{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}
}

func marshalScrolledWindow(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapScrolledWindow(obj), nil
}

// NewScrolledWindow constructs a class ScrolledWindow.
func NewScrolledWindow() ScrolledWindow {

	ret := C.gtk_scrolled_window_new()

	var ret0 ScrolledWindow

	ret0 = WrapScrolledWindow(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Child gets the child widget of @scrolled_window.
func (scrolledWindow scrolledWindow) Child() Widget {
	var arg0 *C.GtkScrolledWindow

	arg0 = (*C.GtkScrolledWindow)(scrolledWindow.Native())

	ret := C.gtk_scrolled_window_get_child(arg0)

	var ret0 Widget

	ret0 = WrapWidget(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Hadjustment returns the horizontal scrollbar’s adjustment, used to
// connect the horizontal scrollbar to the child widget’s horizontal scroll
// functionality.
func (scrolledWindow scrolledWindow) Hadjustment() Adjustment {
	var arg0 *C.GtkScrolledWindow

	arg0 = (*C.GtkScrolledWindow)(scrolledWindow.Native())

	ret := C.gtk_scrolled_window_get_hadjustment(arg0)

	var ret0 Adjustment

	ret0 = WrapAdjustment(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// HasFrame gets whether the scrolled window draws a frame. See
// gtk_scrolled_window_set_has_frame().
func (scrolledWindow scrolledWindow) HasFrame() bool {
	var arg0 *C.GtkScrolledWindow

	arg0 = (*C.GtkScrolledWindow)(scrolledWindow.Native())

	ret := C.gtk_scrolled_window_get_has_frame(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Hscrollbar returns the horizontal scrollbar of @scrolled_window.
func (scrolledWindow scrolledWindow) Hscrollbar() Widget {
	var arg0 *C.GtkScrolledWindow

	arg0 = (*C.GtkScrolledWindow)(scrolledWindow.Native())

	ret := C.gtk_scrolled_window_get_hscrollbar(arg0)

	var ret0 Widget

	ret0 = WrapWidget(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// KineticScrolling returns the specified kinetic scrolling behavior.
func (scrolledWindow scrolledWindow) KineticScrolling() bool {
	var arg0 *C.GtkScrolledWindow

	arg0 = (*C.GtkScrolledWindow)(scrolledWindow.Native())

	ret := C.gtk_scrolled_window_get_kinetic_scrolling(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// MaxContentHeight returns the maximum content height set.
func (scrolledWindow scrolledWindow) MaxContentHeight() int {
	var arg0 *C.GtkScrolledWindow

	arg0 = (*C.GtkScrolledWindow)(scrolledWindow.Native())

	ret := C.gtk_scrolled_window_get_max_content_height(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// MaxContentWidth returns the maximum content width set.
func (scrolledWindow scrolledWindow) MaxContentWidth() int {
	var arg0 *C.GtkScrolledWindow

	arg0 = (*C.GtkScrolledWindow)(scrolledWindow.Native())

	ret := C.gtk_scrolled_window_get_max_content_width(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// MinContentHeight gets the minimal content height of @scrolled_window, or
// -1 if not set.
func (scrolledWindow scrolledWindow) MinContentHeight() int {
	var arg0 *C.GtkScrolledWindow

	arg0 = (*C.GtkScrolledWindow)(scrolledWindow.Native())

	ret := C.gtk_scrolled_window_get_min_content_height(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// MinContentWidth gets the minimum content width of @scrolled_window, or -1
// if not set.
func (scrolledWindow scrolledWindow) MinContentWidth() int {
	var arg0 *C.GtkScrolledWindow

	arg0 = (*C.GtkScrolledWindow)(scrolledWindow.Native())

	ret := C.gtk_scrolled_window_get_min_content_width(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// OverlayScrolling returns whether overlay scrolling is enabled for this
// scrolled window.
func (scrolledWindow scrolledWindow) OverlayScrolling() bool {
	var arg0 *C.GtkScrolledWindow

	arg0 = (*C.GtkScrolledWindow)(scrolledWindow.Native())

	ret := C.gtk_scrolled_window_get_overlay_scrolling(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Placement gets the placement of the contents with respect to the
// scrollbars for the scrolled window. See
// gtk_scrolled_window_set_placement().
func (scrolledWindow scrolledWindow) Placement() CornerType {
	var arg0 *C.GtkScrolledWindow

	arg0 = (*C.GtkScrolledWindow)(scrolledWindow.Native())

	ret := C.gtk_scrolled_window_get_placement(arg0)

	var ret0 CornerType

	ret0 = CornerType(ret)

	return ret0
}

// Policy retrieves the current policy values for the horizontal and
// vertical scrollbars. See gtk_scrolled_window_set_policy().
func (scrolledWindow scrolledWindow) Policy() (hscrollbarPolicy PolicyType, vscrollbarPolicy PolicyType) {
	var arg0 *C.GtkScrolledWindow
	var arg1 *C.GtkPolicyType // out
	var arg2 *C.GtkPolicyType // out

	arg0 = (*C.GtkScrolledWindow)(scrolledWindow.Native())

	ret := C.gtk_scrolled_window_get_policy(arg0, &arg1, &arg2)

	var ret0 *PolicyType
	var ret1 *PolicyType

	ret0 = (*PolicyType)(arg1)

	ret1 = (*PolicyType)(arg2)

	return ret0, ret1
}

// PropagateNaturalHeight reports whether the natural height of the child
// will be calculated and propagated through the scrolled window’s requested
// natural height.
func (scrolledWindow scrolledWindow) PropagateNaturalHeight() bool {
	var arg0 *C.GtkScrolledWindow

	arg0 = (*C.GtkScrolledWindow)(scrolledWindow.Native())

	ret := C.gtk_scrolled_window_get_propagate_natural_height(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// PropagateNaturalWidth reports whether the natural width of the child will
// be calculated and propagated through the scrolled window’s requested
// natural width.
func (scrolledWindow scrolledWindow) PropagateNaturalWidth() bool {
	var arg0 *C.GtkScrolledWindow

	arg0 = (*C.GtkScrolledWindow)(scrolledWindow.Native())

	ret := C.gtk_scrolled_window_get_propagate_natural_width(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Vadjustment returns the vertical scrollbar’s adjustment, used to connect
// the vertical scrollbar to the child widget’s vertical scroll
// functionality.
func (scrolledWindow scrolledWindow) Vadjustment() Adjustment {
	var arg0 *C.GtkScrolledWindow

	arg0 = (*C.GtkScrolledWindow)(scrolledWindow.Native())

	ret := C.gtk_scrolled_window_get_vadjustment(arg0)

	var ret0 Adjustment

	ret0 = WrapAdjustment(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Vscrollbar returns the vertical scrollbar of @scrolled_window.
func (scrolledWindow scrolledWindow) Vscrollbar() Widget {
	var arg0 *C.GtkScrolledWindow

	arg0 = (*C.GtkScrolledWindow)(scrolledWindow.Native())

	ret := C.gtk_scrolled_window_get_vscrollbar(arg0)

	var ret0 Widget

	ret0 = WrapWidget(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// SetChild sets the child widget of @scrolled_window.
func (scrolledWindow scrolledWindow) SetChild(child Widget) {
	var arg0 *C.GtkScrolledWindow
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkScrolledWindow)(scrolledWindow.Native())
	arg1 = (*C.GtkWidget)(child.Native())

	C.gtk_scrolled_window_set_child(arg0, arg1)
}

// SetHadjustment sets the Adjustment for the horizontal scrollbar.
func (scrolledWindow scrolledWindow) SetHadjustment(hadjustment Adjustment) {
	var arg0 *C.GtkScrolledWindow
	var arg1 *C.GtkAdjustment

	arg0 = (*C.GtkScrolledWindow)(scrolledWindow.Native())
	arg1 = (*C.GtkAdjustment)(hadjustment.Native())

	C.gtk_scrolled_window_set_hadjustment(arg0, arg1)
}

// SetHasFrame changes the frame drawn around the contents of
// @scrolled_window.
func (scrolledWindow scrolledWindow) SetHasFrame(hasFrame bool) {
	var arg0 *C.GtkScrolledWindow
	var arg1 C.gboolean

	arg0 = (*C.GtkScrolledWindow)(scrolledWindow.Native())
	arg1 = gextras.Cbool(hasFrame)

	C.gtk_scrolled_window_set_has_frame(arg0, arg1)
}

// SetKineticScrolling turns kinetic scrolling on or off. Kinetic scrolling
// only applies to devices with source GDK_SOURCE_TOUCHSCREEN.
func (scrolledWindow scrolledWindow) SetKineticScrolling(kineticScrolling bool) {
	var arg0 *C.GtkScrolledWindow
	var arg1 C.gboolean

	arg0 = (*C.GtkScrolledWindow)(scrolledWindow.Native())
	arg1 = gextras.Cbool(kineticScrolling)

	C.gtk_scrolled_window_set_kinetic_scrolling(arg0, arg1)
}

// SetMaxContentHeight sets the maximum height that @scrolled_window should
// keep visible. The @scrolled_window will grow up to this height before it
// starts scrolling the content.
//
// It is a programming error to set the maximum content height to a value
// smaller than ScrolledWindow:min-content-height.
func (scrolledWindow scrolledWindow) SetMaxContentHeight(height int) {
	var arg0 *C.GtkScrolledWindow
	var arg1 C.int

	arg0 = (*C.GtkScrolledWindow)(scrolledWindow.Native())
	arg1 = C.int(height)

	C.gtk_scrolled_window_set_max_content_height(arg0, arg1)
}

// SetMaxContentWidth sets the maximum width that @scrolled_window should
// keep visible. The @scrolled_window will grow up to this width before it
// starts scrolling the content.
//
// It is a programming error to set the maximum content width to a value
// smaller than ScrolledWindow:min-content-width.
func (scrolledWindow scrolledWindow) SetMaxContentWidth(width int) {
	var arg0 *C.GtkScrolledWindow
	var arg1 C.int

	arg0 = (*C.GtkScrolledWindow)(scrolledWindow.Native())
	arg1 = C.int(width)

	C.gtk_scrolled_window_set_max_content_width(arg0, arg1)
}

// SetMinContentHeight sets the minimum height that @scrolled_window should
// keep visible. Note that this can and (usually will) be smaller than the
// minimum size of the content.
//
// It is a programming error to set the minimum content height to a value
// greater than ScrolledWindow:max-content-height.
func (scrolledWindow scrolledWindow) SetMinContentHeight(height int) {
	var arg0 *C.GtkScrolledWindow
	var arg1 C.int

	arg0 = (*C.GtkScrolledWindow)(scrolledWindow.Native())
	arg1 = C.int(height)

	C.gtk_scrolled_window_set_min_content_height(arg0, arg1)
}

// SetMinContentWidth sets the minimum width that @scrolled_window should
// keep visible. Note that this can and (usually will) be smaller than the
// minimum size of the content.
//
// It is a programming error to set the minimum content width to a value
// greater than ScrolledWindow:max-content-width.
func (scrolledWindow scrolledWindow) SetMinContentWidth(width int) {
	var arg0 *C.GtkScrolledWindow
	var arg1 C.int

	arg0 = (*C.GtkScrolledWindow)(scrolledWindow.Native())
	arg1 = C.int(width)

	C.gtk_scrolled_window_set_min_content_width(arg0, arg1)
}

// SetOverlayScrolling enables or disables overlay scrolling for this
// scrolled window.
func (scrolledWindow scrolledWindow) SetOverlayScrolling(overlayScrolling bool) {
	var arg0 *C.GtkScrolledWindow
	var arg1 C.gboolean

	arg0 = (*C.GtkScrolledWindow)(scrolledWindow.Native())
	arg1 = gextras.Cbool(overlayScrolling)

	C.gtk_scrolled_window_set_overlay_scrolling(arg0, arg1)
}

// SetPlacement sets the placement of the contents with respect to the
// scrollbars for the scrolled window.
//
// The default is GTK_CORNER_TOP_LEFT, meaning the child is in the top left,
// with the scrollbars underneath and to the right. Other values in
// CornerType are GTK_CORNER_TOP_RIGHT, GTK_CORNER_BOTTOM_LEFT, and
// GTK_CORNER_BOTTOM_RIGHT.
//
// See also gtk_scrolled_window_get_placement() and
// gtk_scrolled_window_unset_placement().
func (scrolledWindow scrolledWindow) SetPlacement(windowPlacement CornerType) {
	var arg0 *C.GtkScrolledWindow
	var arg1 C.GtkCornerType

	arg0 = (*C.GtkScrolledWindow)(scrolledWindow.Native())
	arg1 = (C.GtkCornerType)(windowPlacement)

	C.gtk_scrolled_window_set_placement(arg0, arg1)
}

// SetPolicy sets the scrollbar policy for the horizontal and vertical
// scrollbars.
//
// The policy determines when the scrollbar should appear; it is a value
// from the PolicyType enumeration. If GTK_POLICY_ALWAYS, the scrollbar is
// always present; if GTK_POLICY_NEVER, the scrollbar is never present; if
// GTK_POLICY_AUTOMATIC, the scrollbar is present only if needed (that is,
// if the slider part of the bar would be smaller than the trough — the
// display is larger than the page size).
func (scrolledWindow scrolledWindow) SetPolicy(hscrollbarPolicy PolicyType, vscrollbarPolicy PolicyType) {
	var arg0 *C.GtkScrolledWindow
	var arg1 C.GtkPolicyType
	var arg2 C.GtkPolicyType

	arg0 = (*C.GtkScrolledWindow)(scrolledWindow.Native())
	arg1 = (C.GtkPolicyType)(hscrollbarPolicy)
	arg2 = (C.GtkPolicyType)(vscrollbarPolicy)

	C.gtk_scrolled_window_set_policy(arg0, arg1, arg2)
}

// SetPropagateNaturalHeight sets whether the natural height of the child
// should be calculated and propagated through the scrolled window’s
// requested natural height.
func (scrolledWindow scrolledWindow) SetPropagateNaturalHeight(propagate bool) {
	var arg0 *C.GtkScrolledWindow
	var arg1 C.gboolean

	arg0 = (*C.GtkScrolledWindow)(scrolledWindow.Native())
	arg1 = gextras.Cbool(propagate)

	C.gtk_scrolled_window_set_propagate_natural_height(arg0, arg1)
}

// SetPropagateNaturalWidth sets whether the natural width of the child
// should be calculated and propagated through the scrolled window’s
// requested natural width.
func (scrolledWindow scrolledWindow) SetPropagateNaturalWidth(propagate bool) {
	var arg0 *C.GtkScrolledWindow
	var arg1 C.gboolean

	arg0 = (*C.GtkScrolledWindow)(scrolledWindow.Native())
	arg1 = gextras.Cbool(propagate)

	C.gtk_scrolled_window_set_propagate_natural_width(arg0, arg1)
}

// SetVadjustment sets the Adjustment for the vertical scrollbar.
func (scrolledWindow scrolledWindow) SetVadjustment(vadjustment Adjustment) {
	var arg0 *C.GtkScrolledWindow
	var arg1 *C.GtkAdjustment

	arg0 = (*C.GtkScrolledWindow)(scrolledWindow.Native())
	arg1 = (*C.GtkAdjustment)(vadjustment.Native())

	C.gtk_scrolled_window_set_vadjustment(arg0, arg1)
}

// UnsetPlacement unsets the placement of the contents with respect to the
// scrollbars for the scrolled window. If no window placement is set for a
// scrolled window, it defaults to GTK_CORNER_TOP_LEFT.
//
// See also gtk_scrolled_window_set_placement() and
// gtk_scrolled_window_get_placement().
func (scrolledWindow scrolledWindow) UnsetPlacement() {
	var arg0 *C.GtkScrolledWindow

	arg0 = (*C.GtkScrolledWindow)(scrolledWindow.Native())

	C.gtk_scrolled_window_unset_placement(arg0)
}

// SearchBar is a container made to have a search entry (possibly with
// additional connex widgets, such as drop-down menus, or buttons) built-in. The
// search bar would appear when a search is started through typing on the
// keyboard, or the application’s search mode is toggled on.
//
// For keyboard presses to start a search, the search bar must be told of a
// widget to capture key events from through
// gtk_search_bar_set_key_capture_widget(). This widget will typically be the
// top-level window, or a parent container of the search bar. Common shortcuts
// such as Ctrl+F should be handled as an application action, or through the
// menu items.
//
// You will also need to tell the search bar about which entry you are using as
// your search entry using gtk_search_bar_connect_entry(). The following example
// shows you how to create a more complex search entry.
//
//
// Creating a search bar
//
// A simple example
// (https://gitlab.gnome.org/GNOME/gtk/tree/master/examples/search-bar.c)
//
// CSS nodes
//
//    searchbar
//    ╰── revealer
//        ╰── box
//             ├── [child]
//             ╰── [button.close]
//
//
// GtkSearchBar has a main CSS node with name searchbar. It has a child node
// with name revealer that contains a node with name box. The box node contains
// both the CSS node of the child widget as well as an optional button node
// which gets the .close style class applied.
//
//
// Accessibility
//
// GtkSearchBar uses the GTK_ACCESSIBLE_ROLE_SEARCH role.
type SearchBar interface {
	Widget

	// ConnectEntry connects the Entry widget passed as the one to be used in
	// this search bar. The entry should be a descendant of the search bar. This
	// is only required if the entry isn’t the direct child of the search bar
	// (as in our main example).
	ConnectEntry(entry Editable)
	// Child gets the child widget of @bar.
	Child() Widget
	// KeyCaptureWidget gets the widget that @bar is capturing key events from.
	KeyCaptureWidget() Widget
	// SearchMode returns whether the search mode is on or off.
	SearchMode() bool
	// ShowCloseButton returns whether the close button is shown.
	ShowCloseButton() bool
	// SetChild sets the child widget of @bar.
	SetChild(child Widget)
	// SetKeyCaptureWidget sets @widget as the widget that @bar will capture key
	// events from.
	//
	// If key events are handled by the search bar, the bar will be shown, and
	// the entry populated with the entered text.
	SetKeyCaptureWidget(widget Widget)
	// SetSearchMode switches the search mode on or off.
	SetSearchMode(searchMode bool)
	// SetShowCloseButton shows or hides the close button. Applications that
	// already have a “search” toggle button should not show a close button in
	// their search bar, as it duplicates the role of the toggle button.
	SetShowCloseButton(visible bool)
}

type searchBar struct {
	widget
}

// WrapSearchBar wraps a GObject to the right type. It is
// primarily used internally.
func WrapSearchBar(obj *externglib.Object) SearchBar {
	return searchBar{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}
}

func marshalSearchBar(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSearchBar(obj), nil
}

// NewSearchBar constructs a class SearchBar.
func NewSearchBar() SearchBar {

	ret := C.gtk_search_bar_new()

	var ret0 SearchBar

	ret0 = WrapSearchBar(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// ConnectEntry connects the Entry widget passed as the one to be used in
// this search bar. The entry should be a descendant of the search bar. This
// is only required if the entry isn’t the direct child of the search bar
// (as in our main example).
func (bar searchBar) ConnectEntry(entry Editable) {
	var arg0 *C.GtkSearchBar
	var arg1 *C.GtkEditable

	arg0 = (*C.GtkSearchBar)(bar.Native())

	C.gtk_search_bar_connect_entry(arg0, arg1)
}

// Child gets the child widget of @bar.
func (bar searchBar) Child() Widget {
	var arg0 *C.GtkSearchBar

	arg0 = (*C.GtkSearchBar)(bar.Native())

	ret := C.gtk_search_bar_get_child(arg0)

	var ret0 Widget

	ret0 = WrapWidget(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// KeyCaptureWidget gets the widget that @bar is capturing key events from.
func (bar searchBar) KeyCaptureWidget() Widget {
	var arg0 *C.GtkSearchBar

	arg0 = (*C.GtkSearchBar)(bar.Native())

	ret := C.gtk_search_bar_get_key_capture_widget(arg0)

	var ret0 Widget

	ret0 = WrapWidget(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// SearchMode returns whether the search mode is on or off.
func (bar searchBar) SearchMode() bool {
	var arg0 *C.GtkSearchBar

	arg0 = (*C.GtkSearchBar)(bar.Native())

	ret := C.gtk_search_bar_get_search_mode(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// ShowCloseButton returns whether the close button is shown.
func (bar searchBar) ShowCloseButton() bool {
	var arg0 *C.GtkSearchBar

	arg0 = (*C.GtkSearchBar)(bar.Native())

	ret := C.gtk_search_bar_get_show_close_button(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// SetChild sets the child widget of @bar.
func (bar searchBar) SetChild(child Widget) {
	var arg0 *C.GtkSearchBar
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkSearchBar)(bar.Native())
	arg1 = (*C.GtkWidget)(child.Native())

	C.gtk_search_bar_set_child(arg0, arg1)
}

// SetKeyCaptureWidget sets @widget as the widget that @bar will capture key
// events from.
//
// If key events are handled by the search bar, the bar will be shown, and
// the entry populated with the entered text.
func (bar searchBar) SetKeyCaptureWidget(widget Widget) {
	var arg0 *C.GtkSearchBar
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkSearchBar)(bar.Native())
	arg1 = (*C.GtkWidget)(widget.Native())

	C.gtk_search_bar_set_key_capture_widget(arg0, arg1)
}

// SetSearchMode switches the search mode on or off.
func (bar searchBar) SetSearchMode(searchMode bool) {
	var arg0 *C.GtkSearchBar
	var arg1 C.gboolean

	arg0 = (*C.GtkSearchBar)(bar.Native())
	arg1 = gextras.Cbool(searchMode)

	C.gtk_search_bar_set_search_mode(arg0, arg1)
}

// SetShowCloseButton shows or hides the close button. Applications that
// already have a “search” toggle button should not show a close button in
// their search bar, as it duplicates the role of the toggle button.
func (bar searchBar) SetShowCloseButton(visible bool) {
	var arg0 *C.GtkSearchBar
	var arg1 C.gboolean

	arg0 = (*C.GtkSearchBar)(bar.Native())
	arg1 = gextras.Cbool(visible)

	C.gtk_search_bar_set_show_close_button(arg0, arg1)
}

// SearchEntry is an entry widget that has been tailored for use as a search
// entry. The main aPI for interacting with a GtkSearchEntry as entry is the
// Editable interface.
//
// It will show an inactive symbolic “find” icon when the search entry is empty,
// and a symbolic “clear” icon when there is text. Clicking on the “clear” icon
// will empty the search entry.
//
// To make filtering appear more reactive, it is a good idea to not react to
// every change in the entry text immediately, but only after a short delay. To
// support this, SearchEntry emits the SearchEntry::search-changed signal which
// can be used instead of the Editable::changed signal.
//
// The SearchEntry::previous-match, SearchEntry::next-match and
// SearchEntry::stop-search signals can be used to implement moving between
// search results and ending the search.
//
// Often, GtkSearchEntry will be fed events by means of being placed inside a
// SearchBar. If that is not the case, you can use
// gtk_search_entry_set_key_capture_widget() to let it capture key input from
// another widget.
//
// CSS Nodes
//
//    entry.search
//    ╰── text
//
//
// GtkSearchEntry has a single CSS node with name entry that carries a .sarch
// style class, and the text node is a child of that.
//
//
// Accessibility
//
// GtkSearchEntry uses the K_ACCESSIBLE_ROLE_SEARCH_BOX role.
type SearchEntry interface {
	Widget

	// KeyCaptureWidget gets the widget that @entry is capturing key events
	// from.
	KeyCaptureWidget() Widget
	// SetKeyCaptureWidget sets @widget as the widget that @entry will capture
	// key events from.
	//
	// Key events are consumed by the search entry to start or continue a
	// search.
	//
	// If the entry is part of a SearchBar, it is preferable to call
	// gtk_search_bar_set_key_capture_widget() instead, which will reveal the
	// entry in addition to triggering the search entry.
	SetKeyCaptureWidget(widget Widget)
}

type searchEntry struct {
	widget
}

// WrapSearchEntry wraps a GObject to the right type. It is
// primarily used internally.
func WrapSearchEntry(obj *externglib.Object) SearchEntry {
	return searchEntry{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}
}

func marshalSearchEntry(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSearchEntry(obj), nil
}

// NewSearchEntry constructs a class SearchEntry.
func NewSearchEntry() SearchEntry {

	ret := C.gtk_search_entry_new()

	var ret0 SearchEntry

	ret0 = WrapSearchEntry(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// KeyCaptureWidget gets the widget that @entry is capturing key events
// from.
func (entry searchEntry) KeyCaptureWidget() Widget {
	var arg0 *C.GtkSearchEntry

	arg0 = (*C.GtkSearchEntry)(entry.Native())

	ret := C.gtk_search_entry_get_key_capture_widget(arg0)

	var ret0 Widget

	ret0 = WrapWidget(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// SetKeyCaptureWidget sets @widget as the widget that @entry will capture
// key events from.
//
// Key events are consumed by the search entry to start or continue a
// search.
//
// If the entry is part of a SearchBar, it is preferable to call
// gtk_search_bar_set_key_capture_widget() instead, which will reveal the
// entry in addition to triggering the search entry.
func (entry searchEntry) SetKeyCaptureWidget(widget Widget) {
	var arg0 *C.GtkSearchEntry
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkSearchEntry)(entry.Native())
	arg1 = (*C.GtkWidget)(widget.Native())

	C.gtk_search_entry_set_key_capture_widget(arg0, arg1)
}

// SelectionFilterModel is a list model that presents the selected items in a
// SelectionModel as its own list model.
type SelectionFilterModel interface {
	gextras.Objector

	// Model gets the model currently filtered or nil if none.
	Model() SelectionModel
	// SetModel sets the model to be filtered.
	//
	// Note that GTK makes no effort to ensure that @model conforms to the item
	// type of @self. It assumes that the caller knows what they are doing and
	// have set up an appropriate filter to ensure that item types match.
	SetModel(model SelectionModel)
}

type selectionFilterModel struct {
	*externglib.Object
}

// WrapSelectionFilterModel wraps a GObject to the right type. It is
// primarily used internally.
func WrapSelectionFilterModel(obj *externglib.Object) SelectionFilterModel {
	return selectionFilterModel{*externglib.Object{obj}}
}

func marshalSelectionFilterModel(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSelectionFilterModel(obj), nil
}

// NewSelectionFilterModel constructs a class SelectionFilterModel.
func NewSelectionFilterModel(model SelectionModel) SelectionFilterModel {
	var arg1 *C.GtkSelectionModel

	ret := C.gtk_selection_filter_model_new(arg1)

	var ret0 SelectionFilterModel

	ret0 = WrapSelectionFilterModel(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Model gets the model currently filtered or nil if none.
func (self selectionFilterModel) Model() SelectionModel {
	var arg0 *C.GtkSelectionFilterModel

	arg0 = (*C.GtkSelectionFilterModel)(self.Native())

	ret := C.gtk_selection_filter_model_get_model(arg0)

	var ret0 SelectionModel

	return ret0
}

// SetModel sets the model to be filtered.
//
// Note that GTK makes no effort to ensure that @model conforms to the item
// type of @self. It assumes that the caller knows what they are doing and
// have set up an appropriate filter to ensure that item types match.
func (self selectionFilterModel) SetModel(model SelectionModel) {
	var arg0 *C.GtkSelectionFilterModel
	var arg1 *C.GtkSelectionModel

	arg0 = (*C.GtkSelectionFilterModel)(self.Native())

	C.gtk_selection_filter_model_set_model(arg0, arg1)
}

// Separator: gtkSeparator is a horizontal or vertical separator widget,
// depending on the value of the Orientable:orientation property, used to group
// the widgets within a window. It displays a line with a shadow to make it
// appear sunken into the interface.
//
//
// CSS nodes
//
// GtkSeparator has a single CSS node with name separator. The node gets one of
// the .horizontal or .vertical style classes.
//
//
// Accessibility
//
// GtkSeparator uses the K_ACCESSIBLE_ROLE_SEPARATOR role.
type Separator interface {
	Widget
}

type separator struct {
	widget
}

// WrapSeparator wraps a GObject to the right type. It is
// primarily used internally.
func WrapSeparator(obj *externglib.Object) Separator {
	return separator{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}
}

func marshalSeparator(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSeparator(obj), nil
}

// NewSeparator constructs a class Separator.
func NewSeparator(orientation Orientation) Separator {
	var arg1 C.GtkOrientation

	arg1 = (C.GtkOrientation)(orientation)

	ret := C.gtk_separator_new(arg1)

	var ret0 Separator

	ret0 = WrapSeparator(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Settings gtkSettings provide a mechanism to share global settings between
// applications.
//
// On the X window system, this sharing is realized by an XSettings
// (http://www.freedesktop.org/wiki/Specifications/xsettings-spec) manager that
// is usually part of the desktop environment, along with utilities that let the
// user change these settings.
//
// On Wayland, the settings are obtained either via a settings portal, or by
// reading desktop settings from DConf.
//
// In the absence of these sharing mechanisms, GTK reads default values for
// settings from `settings.ini` files in `/etc/gtk-4.0`,
// `$XDG_CONFIG_DIRS/gtk-4.0` and `$XDG_CONFIG_HOME/gtk-4.0`. These files must
// be valid key files (see File), and have a section called Settings. Themes can
// also provide default values for settings by installing a `settings.ini` file
// next to their `gtk.css` file.
//
// Applications can override system-wide settings by setting the property of the
// GtkSettings object with g_object_set(). This should be restricted to special
// cases though; GtkSettings are not meant as an application configuration
// facility.
//
// There is one GtkSettings instance per display. It can be obtained with
// gtk_settings_get_for_display(), but in many cases, it is more convenient to
// use gtk_widget_get_settings().
type Settings interface {
	gextras.Objector

	// ResetProperty undoes the effect of calling g_object_set() to install an
	// application-specific value for a setting. After this call, the setting
	// will again follow the session-wide value for this setting.
	ResetProperty(name string)
}

type settings struct {
	*externglib.Object
}

// WrapSettings wraps a GObject to the right type. It is
// primarily used internally.
func WrapSettings(obj *externglib.Object) Settings {
	return settings{*externglib.Object{obj}}
}

func marshalSettings(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSettings(obj), nil
}

// ResetProperty undoes the effect of calling g_object_set() to install an
// application-specific value for a setting. After this call, the setting
// will again follow the session-wide value for this setting.
func (settings settings) ResetProperty(name string) {
	var arg0 *C.GtkSettings
	var arg1 *C.char

	arg0 = (*C.GtkSettings)(settings.Native())
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_settings_reset_property(arg0, arg1)
}

// Shortcut: gtkShortcut is the low level object used for managing keyboard
// shortcuts.
//
// It contains a description of how to trigger the shortcut via a
// ShortcutTrigger and a way to activate the shortcut on a widget via
// ShortcutAction.
//
// The actual work is usually done via ShortcutController, which decides if and
// when to activate a shortcut. Using that controller directly however is rarely
// necessary as various higher level convenience APIs exist on Widgets that make
// it easier to use shortcuts in GTK.
//
// Shortcut does provide functionality to make it easy for users to work with
// shortcuts, either by providing informational strings for display purposes or
// by allowing shortcuts to be configured.
type Shortcut interface {
	gextras.Objector

	// Action gets the action that is activated by this shortcut.
	Action() ShortcutAction
	// Arguments gets the arguments that are passed when activating the
	// shortcut.
	Arguments() *glib.Variant
	// Trigger gets the trigger used to trigger @self.
	Trigger() ShortcutTrigger
	// SetAction sets the new action for @self to be @action.
	SetAction(action ShortcutAction)
	// SetArguments sets the arguments to pass when activating the shortcut.
	SetArguments(args *glib.Variant)
	// SetTrigger sets the new trigger for @self to be @trigger.
	SetTrigger(trigger ShortcutTrigger)
}

type shortcut struct {
	*externglib.Object
}

// WrapShortcut wraps a GObject to the right type. It is
// primarily used internally.
func WrapShortcut(obj *externglib.Object) Shortcut {
	return shortcut{*externglib.Object{obj}}
}

func marshalShortcut(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapShortcut(obj), nil
}

// NewShortcut constructs a class Shortcut.
func NewShortcut(trigger ShortcutTrigger, action ShortcutAction) Shortcut {
	var arg1 *C.GtkShortcutTrigger
	var arg2 *C.GtkShortcutAction

	arg1 = (*C.GtkShortcutTrigger)(trigger.Native())
	arg2 = (*C.GtkShortcutAction)(action.Native())

	ret := C.gtk_shortcut_new(arg1, arg2)

	var ret0 Shortcut

	ret0 = WrapShortcut(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Action gets the action that is activated by this shortcut.
func (self shortcut) Action() ShortcutAction {
	var arg0 *C.GtkShortcut

	arg0 = (*C.GtkShortcut)(self.Native())

	ret := C.gtk_shortcut_get_action(arg0)

	var ret0 ShortcutAction

	ret0 = WrapShortcutAction(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Arguments gets the arguments that are passed when activating the
// shortcut.
func (self shortcut) Arguments() *glib.Variant {
	var arg0 *C.GtkShortcut

	arg0 = (*C.GtkShortcut)(self.Native())

	ret := C.gtk_shortcut_get_arguments(arg0)

	var ret0 *glib.Variant

	ret0 = glib.WrapVariant(ret)

	return ret0
}

// Trigger gets the trigger used to trigger @self.
func (self shortcut) Trigger() ShortcutTrigger {
	var arg0 *C.GtkShortcut

	arg0 = (*C.GtkShortcut)(self.Native())

	ret := C.gtk_shortcut_get_trigger(arg0)

	var ret0 ShortcutTrigger

	ret0 = WrapShortcutTrigger(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// SetAction sets the new action for @self to be @action.
func (self shortcut) SetAction(action ShortcutAction) {
	var arg0 *C.GtkShortcut
	var arg1 *C.GtkShortcutAction

	arg0 = (*C.GtkShortcut)(self.Native())
	arg1 = (*C.GtkShortcutAction)(action.Native())

	C.gtk_shortcut_set_action(arg0, arg1)
}

// SetArguments sets the arguments to pass when activating the shortcut.
func (self shortcut) SetArguments(args *glib.Variant) {
	var arg0 *C.GtkShortcut
	var arg1 *C.GVariant

	arg0 = (*C.GtkShortcut)(self.Native())
	arg1 = (*C.GVariant)(args.Native())

	C.gtk_shortcut_set_arguments(arg0, arg1)
}

// SetTrigger sets the new trigger for @self to be @trigger.
func (self shortcut) SetTrigger(trigger ShortcutTrigger) {
	var arg0 *C.GtkShortcut
	var arg1 *C.GtkShortcutTrigger

	arg0 = (*C.GtkShortcut)(self.Native())
	arg1 = (*C.GtkShortcutTrigger)(trigger.Native())

	C.gtk_shortcut_set_trigger(arg0, arg1)
}

// ShortcutAction is the object used to describe what a Shortcut should do when
// triggered. To activate a ShortcutAction manually,
// gtk_shortcut_action_activate() can be called.
//
// ShortcutActions contain functions that allow easy presentation to end users
// as well as being printed for debugging.
//
// All ShortcutActions are immutable, you can only specify their properties
// during construction. If you want to change a action, you have to replace it
// with a new one. If you need to pass arguments to an action, these are
// specified by the higher-level Shortcut object.
//
// GTK provides various actions:
//
//    - MnemonicAction: a shortcut action that calls gtk_widget_mnemonic_activate()
//    - CallbackAction: a shortcut action that invokes a given callback
//    - SignalAction: a shortcut action that emits a given signal
//    - ActivateAction: a shortcut action that calls gtk_widget_activate()
//    - NamedAction: a shortcut action that calls gtk_widget_activate_action()
//    - NothingAction: a shortcut action that does nothing
//
//
// GtkShortcutAction as GtkBuildable
//
// GtkShortcut
type ShortcutAction interface {
	gextras.Objector

	// Activate activates the action on the @widget with the given @args.
	//
	// Note that some actions ignore the passed in @flags, @widget or @args.
	//
	// Activation of an action can fail for various reasons. If the action is
	// not supported by the @widget, if the @args don't match the action or if
	// the activation otherwise had no effect, false will be returned.
	Activate(flags ShortcutActionFlags, widget Widget, args *glib.Variant) bool
	// Print prints the given action into a string for the developer. This is
	// meant for debugging and logging.
	//
	// The form of the representation may change at any time and is not
	// guaranteed to stay identical.
	Print(string *glib.String)
	// String prints the given action into a human-readable string. This is a
	// small wrapper around gtk_shortcut_action_print() to help when debugging.
	String() string
}

type shortcutAction struct {
	*externglib.Object
}

// WrapShortcutAction wraps a GObject to the right type. It is
// primarily used internally.
func WrapShortcutAction(obj *externglib.Object) ShortcutAction {
	return shortcutAction{*externglib.Object{obj}}
}

func marshalShortcutAction(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapShortcutAction(obj), nil
}

// NewShortcutActionParseString constructs a class ShortcutAction.
func NewShortcutActionParseString(string string) ShortcutAction {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(string))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_shortcut_action_parse_string(arg1)

	var ret0 ShortcutAction

	ret0 = WrapShortcutAction(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Activate activates the action on the @widget with the given @args.
//
// Note that some actions ignore the passed in @flags, @widget or @args.
//
// Activation of an action can fail for various reasons. If the action is
// not supported by the @widget, if the @args don't match the action or if
// the activation otherwise had no effect, false will be returned.
func (self shortcutAction) Activate(flags ShortcutActionFlags, widget Widget, args *glib.Variant) bool {
	var arg0 *C.GtkShortcutAction
	var arg1 C.GtkShortcutActionFlags
	var arg2 *C.GtkWidget
	var arg3 *C.GVariant

	arg0 = (*C.GtkShortcutAction)(self.Native())
	arg1 = (C.GtkShortcutActionFlags)(flags)
	arg2 = (*C.GtkWidget)(widget.Native())
	arg3 = (*C.GVariant)(args.Native())

	ret := C.gtk_shortcut_action_activate(arg0, arg1, arg2, arg3)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Print prints the given action into a string for the developer. This is
// meant for debugging and logging.
//
// The form of the representation may change at any time and is not
// guaranteed to stay identical.
func (self shortcutAction) Print(string *glib.String) {
	var arg0 *C.GtkShortcutAction
	var arg1 *C.GString

	arg0 = (*C.GtkShortcutAction)(self.Native())
	arg1 = (*C.GString)(string.Native())

	C.gtk_shortcut_action_print(arg0, arg1)
}

// String prints the given action into a human-readable string. This is a
// small wrapper around gtk_shortcut_action_print() to help when debugging.
func (self shortcutAction) String() string {
	var arg0 *C.GtkShortcutAction

	arg0 = (*C.GtkShortcutAction)(self.Native())

	ret := C.gtk_shortcut_action_to_string(arg0)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// ShortcutController is an event controller that manages shortcuts.
//
// Most common shortcuts are using this controller implicitly, e.g. by adding a
// mnemonic underline to a Label, or by installing a key binding using
// gtk_widget_class_add_binding(), or by adding accelerators to global actions
// using gtk_application_set_accels_for_action().
//
// But it is possible to create your own shortcut controller, and add shortcuts
// to it.
//
// ShortcutController implements Model for querying the shortcuts that have been
// added to it.
//
//
// GtkShortcutController as a GtkBuildable
//
// GtkShortcutControllers can be creates in ui files to set up shortcuts in the
// same place as the widgets.
//
// An example of a UI definition fragment with GtkShortcutController:
//
//
//      <object class='GtkButton'>
//        <child>
//          <object class='GtkShortcutController'>
//            <property name='scope'>managed</property>
//            <child>
//              <object class='GtkShortcut'>
//                <property name='trigger'>&amp;lt;Control&amp;gt;k</property>
//                <property name='action'>activate</property>
//              </object>
//            </child>
//          </object>
//        </child>
//      </object>
//
//
// This example creates a ActivateAction for triggering the `activate` signal of
// the GtkButton. See gtk_shortcut_action_parse_string() for the syntax for
// other kinds of ShortcutAction. See gtk_shortcut_trigger_parse_string() to
// learn more about the syntax for triggers.
type ShortcutController interface {
	EventController

	// AddShortcut adds @shortcut to the list of shortcuts handled by @self.
	//
	// If this controller uses an external shortcut list, this function does
	// nothing.
	AddShortcut(shortcut Shortcut)
	// MnemonicsModifiers gets the mnemonics modifiers for when this controller
	// activates its shortcuts. See
	// gtk_shortcut_controller_set_mnemonics_modifiers() for details.
	MnemonicsModifiers() gdk.ModifierType
	// Scope gets the scope for when this controller activates its shortcuts.
	// See gtk_shortcut_controller_set_scope() for details.
	Scope() ShortcutScope
	// RemoveShortcut removes @shortcut from the list of shortcuts handled by
	// @self.
	//
	// If @shortcut had not been added to @controller or this controller uses an
	// external shortcut list, this function does nothing.
	RemoveShortcut(shortcut Shortcut)
	// SetMnemonicsModifiers sets the controller to have the given
	// @mnemonics_modifiers.
	//
	// The mnemonics modifiers determines which modifiers need to be pressed to
	// allow activation of shortcuts with mnemonics triggers.
	//
	// GTK normally uses the Alt modifier for mnemonics, except in PopoverMenus,
	// where mnemonics can be triggered without any modifiers. It should be very
	// rarely necessary to change this, and doing so is likely to interfere with
	// other shortcuts.
	//
	// This value is only relevant for local shortcut controllers. Global and
	// managed shortcut controllers will have their shortcuts activated from
	// other places which have their own modifiers for activating mnemonics.
	SetMnemonicsModifiers(modifiers gdk.ModifierType)
	// SetScope sets the controller to have the given @scope.
	//
	// The scope allows shortcuts to be activated outside of the normal event
	// propagation. In particular, it allows installing global keyboard
	// shortcuts that can be activated even when a widget does not have focus.
	//
	// With GTK_SHORTCUT_SCOPE_LOCAL, shortcuts will only be activated when the
	// widget has focus.
	SetScope(scope ShortcutScope)
}

type shortcutController struct {
	eventController
}

// WrapShortcutController wraps a GObject to the right type. It is
// primarily used internally.
func WrapShortcutController(obj *externglib.Object) ShortcutController {
	return shortcutController{eventController{*externglib.Object{obj}}}
}

func marshalShortcutController(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapShortcutController(obj), nil
}

// NewShortcutController constructs a class ShortcutController.
func NewShortcutController() ShortcutController {

	ret := C.gtk_shortcut_controller_new()

	var ret0 ShortcutController

	ret0 = WrapShortcutController(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewShortcutControllerForModel constructs a class ShortcutController.
func NewShortcutControllerForModel(model gio.ListModel) ShortcutController {
	var arg1 *C.GListModel

	ret := C.gtk_shortcut_controller_new_for_model(arg1)

	var ret0 ShortcutController

	ret0 = WrapShortcutController(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// AddShortcut adds @shortcut to the list of shortcuts handled by @self.
//
// If this controller uses an external shortcut list, this function does
// nothing.
func (self shortcutController) AddShortcut(shortcut Shortcut) {
	var arg0 *C.GtkShortcutController
	var arg1 *C.GtkShortcut

	arg0 = (*C.GtkShortcutController)(self.Native())
	arg1 = (*C.GtkShortcut)(shortcut.Native())

	C.gtk_shortcut_controller_add_shortcut(arg0, arg1)
}

// MnemonicsModifiers gets the mnemonics modifiers for when this controller
// activates its shortcuts. See
// gtk_shortcut_controller_set_mnemonics_modifiers() for details.
func (self shortcutController) MnemonicsModifiers() gdk.ModifierType {
	var arg0 *C.GtkShortcutController

	arg0 = (*C.GtkShortcutController)(self.Native())

	ret := C.gtk_shortcut_controller_get_mnemonics_modifiers(arg0)

	var ret0 gdk.ModifierType

	ret0 = gdk.ModifierType(ret)

	return ret0
}

// Scope gets the scope for when this controller activates its shortcuts.
// See gtk_shortcut_controller_set_scope() for details.
func (self shortcutController) Scope() ShortcutScope {
	var arg0 *C.GtkShortcutController

	arg0 = (*C.GtkShortcutController)(self.Native())

	ret := C.gtk_shortcut_controller_get_scope(arg0)

	var ret0 ShortcutScope

	ret0 = ShortcutScope(ret)

	return ret0
}

// RemoveShortcut removes @shortcut from the list of shortcuts handled by
// @self.
//
// If @shortcut had not been added to @controller or this controller uses an
// external shortcut list, this function does nothing.
func (self shortcutController) RemoveShortcut(shortcut Shortcut) {
	var arg0 *C.GtkShortcutController
	var arg1 *C.GtkShortcut

	arg0 = (*C.GtkShortcutController)(self.Native())
	arg1 = (*C.GtkShortcut)(shortcut.Native())

	C.gtk_shortcut_controller_remove_shortcut(arg0, arg1)
}

// SetMnemonicsModifiers sets the controller to have the given
// @mnemonics_modifiers.
//
// The mnemonics modifiers determines which modifiers need to be pressed to
// allow activation of shortcuts with mnemonics triggers.
//
// GTK normally uses the Alt modifier for mnemonics, except in PopoverMenus,
// where mnemonics can be triggered without any modifiers. It should be very
// rarely necessary to change this, and doing so is likely to interfere with
// other shortcuts.
//
// This value is only relevant for local shortcut controllers. Global and
// managed shortcut controllers will have their shortcuts activated from
// other places which have their own modifiers for activating mnemonics.
func (self shortcutController) SetMnemonicsModifiers(modifiers gdk.ModifierType) {
	var arg0 *C.GtkShortcutController
	var arg1 C.GdkModifierType

	arg0 = (*C.GtkShortcutController)(self.Native())
	arg1 = (C.GdkModifierType)(modifiers)

	C.gtk_shortcut_controller_set_mnemonics_modifiers(arg0, arg1)
}

// SetScope sets the controller to have the given @scope.
//
// The scope allows shortcuts to be activated outside of the normal event
// propagation. In particular, it allows installing global keyboard
// shortcuts that can be activated even when a widget does not have focus.
//
// With GTK_SHORTCUT_SCOPE_LOCAL, shortcuts will only be activated when the
// widget has focus.
func (self shortcutController) SetScope(scope ShortcutScope) {
	var arg0 *C.GtkShortcutController
	var arg1 C.GtkShortcutScope

	arg0 = (*C.GtkShortcutController)(self.Native())
	arg1 = (C.GtkShortcutScope)(scope)

	C.gtk_shortcut_controller_set_scope(arg0, arg1)
}

// ShortcutLabel is a widget that represents a single keyboard shortcut or
// gesture in the user interface.
type ShortcutLabel interface {
	Widget

	// Accelerator retrieves the current accelerator of @self.
	Accelerator() string
	// DisabledText retrieves the text that is displayed when no accelerator is
	// set.
	DisabledText() string
	// SetAccelerator sets the accelerator to be displayed by @self.
	SetAccelerator(accelerator string)
	// SetDisabledText sets the text to be displayed by @self when no
	// accelerator is set.
	SetDisabledText(disabledText string)
}

type shortcutLabel struct {
	widget
}

// WrapShortcutLabel wraps a GObject to the right type. It is
// primarily used internally.
func WrapShortcutLabel(obj *externglib.Object) ShortcutLabel {
	return shortcutLabel{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}
}

func marshalShortcutLabel(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapShortcutLabel(obj), nil
}

// NewShortcutLabel constructs a class ShortcutLabel.
func NewShortcutLabel(accelerator string) ShortcutLabel {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(accelerator))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_shortcut_label_new(arg1)

	var ret0 ShortcutLabel

	ret0 = WrapShortcutLabel(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Accelerator retrieves the current accelerator of @self.
func (self shortcutLabel) Accelerator() string {
	var arg0 *C.GtkShortcutLabel

	arg0 = (*C.GtkShortcutLabel)(self.Native())

	ret := C.gtk_shortcut_label_get_accelerator(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// DisabledText retrieves the text that is displayed when no accelerator is
// set.
func (self shortcutLabel) DisabledText() string {
	var arg0 *C.GtkShortcutLabel

	arg0 = (*C.GtkShortcutLabel)(self.Native())

	ret := C.gtk_shortcut_label_get_disabled_text(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// SetAccelerator sets the accelerator to be displayed by @self.
func (self shortcutLabel) SetAccelerator(accelerator string) {
	var arg0 *C.GtkShortcutLabel
	var arg1 *C.char

	arg0 = (*C.GtkShortcutLabel)(self.Native())
	arg1 = (*C.gchar)(C.CString(accelerator))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_shortcut_label_set_accelerator(arg0, arg1)
}

// SetDisabledText sets the text to be displayed by @self when no
// accelerator is set.
func (self shortcutLabel) SetDisabledText(disabledText string) {
	var arg0 *C.GtkShortcutLabel
	var arg1 *C.char

	arg0 = (*C.GtkShortcutLabel)(self.Native())
	arg1 = (*C.gchar)(C.CString(disabledText))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_shortcut_label_set_disabled_text(arg0, arg1)
}

// ShortcutTrigger is the object used to track if a Shortcut should be
// activated. For this purpose, gtk_shortcut_trigger_trigger() can be called on
// a Event.
//
// ShortcutTriggers contain functions that allow easy presentation to end users
// as well as being printed for debugging.
//
// All ShortcutTriggers are immutable, you can only specify their properties
// during construction. If you want to change a trigger, you have to replace it
// with a new one.
type ShortcutTrigger interface {
	gextras.Objector

	// Compare: the types of @trigger1 and @trigger2 are #gconstpointer only to
	// allow use of this function as a Func. They must each be a
	// ShortcutTrigger.
	Compare(trigger2 ShortcutTrigger) int
	// Equal checks if @trigger1 and @trigger2 trigger under the same
	// conditions.
	//
	// The types of @one and @two are #gconstpointer only to allow use of this
	// function with Table. They must each be a ShortcutTrigger.
	Equal(trigger2 ShortcutTrigger) bool
	// Hash generates a hash value for a ShortcutTrigger.
	//
	// The output of this function is guaranteed to be the same for a given
	// value only per-process. It may change between different processor
	// architectures or even different versions of GTK. Do not use this function
	// as a basis for building protocols or file formats.
	//
	// The types of @trigger is #gconstpointer only to allow use of this
	// function with Table. They must each be a ShortcutTrigger.
	Hash() uint
	// Print prints the given trigger into a string for the developer. This is
	// meant for debugging and logging.
	//
	// The form of the representation may change at any time and is not
	// guaranteed to stay identical.
	Print(string *glib.String)
	// PrintLabel prints the given trigger into a string. This function is
	// returning a translated string for presentation to end users for example
	// in menu items or in help texts.
	//
	// The @display in use may influence the resulting string in various forms,
	// such as resolving hardware keycodes or by causing display-specific
	// modifier names.
	//
	// The form of the representation may change at any time and is not
	// guaranteed to stay identical.
	PrintLabel(display gdk.Display, string *glib.String) bool
	// ToLabel gets textual representation for the given trigger. This function
	// is returning a translated string for presentation to end users for
	// example in menu items or in help texts.
	//
	// The @display in use may influence the resulting string in various forms,
	// such as resolving hardware keycodes or by causing display-specific
	// modifier names.
	//
	// The form of the representation may change at any time and is not
	// guaranteed to stay identical.
	ToLabel(display gdk.Display) string
	// String prints the given trigger into a human-readable string. This is a
	// small wrapper around gtk_shortcut_trigger_print() to help when debugging.
	String() string
	// Trigger checks if the given @event triggers @self.
	Trigger(event gdk.Event, enableMnemonics bool) gdk.KeyMatch
}

type shortcutTrigger struct {
	*externglib.Object
}

// WrapShortcutTrigger wraps a GObject to the right type. It is
// primarily used internally.
func WrapShortcutTrigger(obj *externglib.Object) ShortcutTrigger {
	return shortcutTrigger{*externglib.Object{obj}}
}

func marshalShortcutTrigger(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapShortcutTrigger(obj), nil
}

// NewShortcutTriggerParseString constructs a class ShortcutTrigger.
func NewShortcutTriggerParseString(string string) ShortcutTrigger {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(string))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_shortcut_trigger_parse_string(arg1)

	var ret0 ShortcutTrigger

	ret0 = WrapShortcutTrigger(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Compare: the types of @trigger1 and @trigger2 are #gconstpointer only to
// allow use of this function as a Func. They must each be a
// ShortcutTrigger.
func (trigger1 shortcutTrigger) Compare(trigger2 ShortcutTrigger) int {
	var arg0 C.gpointer
	var arg1 C.gpointer

	arg0 = (C.gpointer)(trigger1.Native())
	arg1 = (C.gpointer)(trigger2.Native())

	ret := C.gtk_shortcut_trigger_compare(arg0, arg1)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Equal checks if @trigger1 and @trigger2 trigger under the same
// conditions.
//
// The types of @one and @two are #gconstpointer only to allow use of this
// function with Table. They must each be a ShortcutTrigger.
func (trigger1 shortcutTrigger) Equal(trigger2 ShortcutTrigger) bool {
	var arg0 C.gpointer
	var arg1 C.gpointer

	arg0 = (C.gpointer)(trigger1.Native())
	arg1 = (C.gpointer)(trigger2.Native())

	ret := C.gtk_shortcut_trigger_equal(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Hash generates a hash value for a ShortcutTrigger.
//
// The output of this function is guaranteed to be the same for a given
// value only per-process. It may change between different processor
// architectures or even different versions of GTK. Do not use this function
// as a basis for building protocols or file formats.
//
// The types of @trigger is #gconstpointer only to allow use of this
// function with Table. They must each be a ShortcutTrigger.
func (trigger shortcutTrigger) Hash() uint {
	var arg0 C.gpointer

	arg0 = (C.gpointer)(trigger.Native())

	ret := C.gtk_shortcut_trigger_hash(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// Print prints the given trigger into a string for the developer. This is
// meant for debugging and logging.
//
// The form of the representation may change at any time and is not
// guaranteed to stay identical.
func (self shortcutTrigger) Print(string *glib.String) {
	var arg0 *C.GtkShortcutTrigger
	var arg1 *C.GString

	arg0 = (*C.GtkShortcutTrigger)(self.Native())
	arg1 = (*C.GString)(string.Native())

	C.gtk_shortcut_trigger_print(arg0, arg1)
}

// PrintLabel prints the given trigger into a string. This function is
// returning a translated string for presentation to end users for example
// in menu items or in help texts.
//
// The @display in use may influence the resulting string in various forms,
// such as resolving hardware keycodes or by causing display-specific
// modifier names.
//
// The form of the representation may change at any time and is not
// guaranteed to stay identical.
func (self shortcutTrigger) PrintLabel(display gdk.Display, string *glib.String) bool {
	var arg0 *C.GtkShortcutTrigger
	var arg1 *C.GdkDisplay
	var arg2 *C.GString

	arg0 = (*C.GtkShortcutTrigger)(self.Native())
	arg1 = (*C.GdkDisplay)(display.Native())
	arg2 = (*C.GString)(string.Native())

	ret := C.gtk_shortcut_trigger_print_label(arg0, arg1, arg2)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// ToLabel gets textual representation for the given trigger. This function
// is returning a translated string for presentation to end users for
// example in menu items or in help texts.
//
// The @display in use may influence the resulting string in various forms,
// such as resolving hardware keycodes or by causing display-specific
// modifier names.
//
// The form of the representation may change at any time and is not
// guaranteed to stay identical.
func (self shortcutTrigger) ToLabel(display gdk.Display) string {
	var arg0 *C.GtkShortcutTrigger
	var arg1 *C.GdkDisplay

	arg0 = (*C.GtkShortcutTrigger)(self.Native())
	arg1 = (*C.GdkDisplay)(display.Native())

	ret := C.gtk_shortcut_trigger_to_label(arg0, arg1)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// String prints the given trigger into a human-readable string. This is a
// small wrapper around gtk_shortcut_trigger_print() to help when debugging.
func (self shortcutTrigger) String() string {
	var arg0 *C.GtkShortcutTrigger

	arg0 = (*C.GtkShortcutTrigger)(self.Native())

	ret := C.gtk_shortcut_trigger_to_string(arg0)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// Trigger checks if the given @event triggers @self.
func (self shortcutTrigger) Trigger(event gdk.Event, enableMnemonics bool) gdk.KeyMatch {
	var arg0 *C.GtkShortcutTrigger
	var arg1 *C.GdkEvent
	var arg2 C.gboolean

	arg0 = (*C.GtkShortcutTrigger)(self.Native())
	arg1 = (*C.GdkEvent)(event.Native())
	arg2 = gextras.Cbool(enableMnemonics)

	ret := C.gtk_shortcut_trigger_trigger(arg0, arg1, arg2)

	var ret0 gdk.KeyMatch

	ret0 = gdk.KeyMatch(ret)

	return ret0
}

// ShortcutsGroup: a GtkShortcutsGroup represents a group of related keyboard
// shortcuts or gestures. The group has a title. It may optionally be associated
// with a view of the application, which can be used to show only relevant
// shortcuts depending on the application context.
//
// This widget is only meant to be used with ShortcutsWindow.
type ShortcutsGroup interface {
	Box
}

type shortcutsGroup struct {
	box
}

// WrapShortcutsGroup wraps a GObject to the right type. It is
// primarily used internally.
func WrapShortcutsGroup(obj *externglib.Object) ShortcutsGroup {
	return shortcutsGroup{box{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}}
}

func marshalShortcutsGroup(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapShortcutsGroup(obj), nil
}

// ShortcutsSection: a GtkShortcutsSection collects all the keyboard shortcuts
// and gestures for a major application mode. If your application needs multiple
// sections, you should give each section a unique ShortcutsSection:section-name
// and a ShortcutsSection:title that can be shown in the section selector of the
// GtkShortcutsWindow.
//
// The ShortcutsSection:max-height property can be used to influence how the
// groups in the section are distributed over pages and columns.
//
// This widget is only meant to be used with ShortcutsWindow.
type ShortcutsSection interface {
	Box
}

type shortcutsSection struct {
	box
}

// WrapShortcutsSection wraps a GObject to the right type. It is
// primarily used internally.
func WrapShortcutsSection(obj *externglib.Object) ShortcutsSection {
	return shortcutsSection{box{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}}
}

func marshalShortcutsSection(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapShortcutsSection(obj), nil
}

// ShortcutsShortcut: a GtkShortcutsShortcut represents a single keyboard
// shortcut or gesture with a short text. This widget is only meant to be used
// with ShortcutsWindow.
type ShortcutsShortcut interface {
	Widget
}

type shortcutsShortcut struct {
	widget
}

// WrapShortcutsShortcut wraps a GObject to the right type. It is
// primarily used internally.
func WrapShortcutsShortcut(obj *externglib.Object) ShortcutsShortcut {
	return shortcutsShortcut{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}
}

func marshalShortcutsShortcut(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapShortcutsShortcut(obj), nil
}

// ShortcutsWindow: a GtkShortcutsWindow shows brief information about the
// keyboard shortcuts and gestures of an application. The shortcuts can be
// grouped, and you can have multiple sections in this window, corresponding to
// the major modes of your application.
//
// Additionally, the shortcuts can be filtered by the current view, to avoid
// showing information that is not relevant in the current application context.
//
// The recommended way to construct a GtkShortcutsWindow is with GtkBuilder, by
// populating a ShortcutsWindow with one or more ShortcutsSection objects, which
// contain ShortcutsGroups that in turn contain objects of class
// ShortcutsShortcut.
//
// A simple example:
//
// ! (gedit-shortcuts.png)
//
// This example has as single section. As you can see, the shortcut groups are
// arranged in columns, and spread across several pages if there are too many to
// find on a single page.
//
// The .ui file for this example can be found here
// (https://gitlab.gnome.org/GNOME/gtk/tree/master/demos/gtk-demo/shortcuts-gedit.ui).
//
// An example with multiple views:
//
// ! (clocks-shortcuts.png)
//
// This example shows a ShortcutsWindow that has been configured to show only
// the shortcuts relevant to the "stopwatch" view.
//
// The .ui file for this example can be found here
// (https://gitlab.gnome.org/GNOME/gtk/tree/master/demos/gtk-demo/shortcuts-clocks.ui).
//
// An example with multiple sections:
//
// ! (builder-shortcuts.png)
//
// This example shows a ShortcutsWindow with two sections, "Editor Shortcuts"
// and "Terminal Shortcuts".
//
// The .ui file for this example can be found here
// (https://gitlab.gnome.org/GNOME/gtk/tree/master/demos/gtk-demo/shortcuts-builder.ui).
type ShortcutsWindow interface {
	Window
}

type shortcutsWindow struct {
	window
}

// WrapShortcutsWindow wraps a GObject to the right type. It is
// primarily used internally.
func WrapShortcutsWindow(obj *externglib.Object) ShortcutsWindow {
	return shortcutsWindow{window{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}}
}

func marshalShortcutsWindow(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapShortcutsWindow(obj), nil
}

// SignalAction: a ShortcutAction that emits a signal.
//
// Signals that are used in this way are referred to as keybinding signals, and
// they are expected to be defined with the G_SIGNAL_ACTION flag.
type SignalAction interface {
	ShortcutAction

	// SignalName returns the name of the signal that will be emitted.
	SignalName() string
}

type signalAction struct {
	shortcutAction
}

// WrapSignalAction wraps a GObject to the right type. It is
// primarily used internally.
func WrapSignalAction(obj *externglib.Object) SignalAction {
	return signalAction{shortcutAction{*externglib.Object{obj}}}
}

func marshalSignalAction(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSignalAction(obj), nil
}

// NewSignalAction constructs a class SignalAction.
func NewSignalAction(signalName string) SignalAction {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(signalName))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_signal_action_new(arg1)

	var ret0 SignalAction

	ret0 = WrapSignalAction(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// SignalName returns the name of the signal that will be emitted.
func (self signalAction) SignalName() string {
	var arg0 *C.GtkSignalAction

	arg0 = (*C.GtkSignalAction)(self.Native())

	ret := C.gtk_signal_action_get_signal_name(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// SignalListItemFactory is a ListItemFactory that provides signals that user
// code can connect to to manage listitems. Signals are emitted for every
// listitem in the same order:
//
//    1. SignalListItemFactory::setup is emitted to set up permanent things
//    on the listitem. This usually means constructing the widgets used in the
//    row and adding them to the listitem.
//
//    2. SignalListItemFactory::bind is emitted to bind the item passed via
//    ListItem:item to the widgets that have been created in step 1 or to
//    add item-specific widgets. Signals are connected to listen to changes -
//    both to changes in the item to update the widgets or to changes in the
//    widgets to update the item. After this signal has been called, the
//    listitem may be shown in a list widget.
//
//    3. SignalListItemFactory::unbind is emitted to undo everything done
//    in step 2. Usually this means disconnecting signal handlers. Once this
//    signal has been called, the listitem will no longer be used in a list
//    widget.
//
//    4. SignalListItemFactory::bind and SignalListItemFactory::unbind
//    may be emitted multiple times again to bind the listitem for use with
//    new items. By reusing listitems, potentially costly setup can be
//    avoided. However, it means code needs to make sure to properly clean
//    up the listitem in step 3 so that no information from the previous
//    use leaks into the next use.
//
// 5. SignalListItemFactory::teardown is emitted to allow undoing the effects of
// SignalListItemFactory::setup. After this signal was emitted on a listitem,
// the listitem will be destroyed and not be used again.
//
// Note that during the signal emissions, changing properties on the ListItems
// passed will not trigger notify signals as the listitem's notifications are
// frozen. See g_object_freeze_notify() for details.
//
// For tracking changes in other properties in the ListItem, the
// ListItem::notify signal is recommended. The signal can be connected in the
// SignalListItemFactory::setup signal and removed again during
// SignalListItemFactory::teardown.
type SignalListItemFactory interface {
	ListItemFactory
}

type signalListItemFactory struct {
	listItemFactory
}

// WrapSignalListItemFactory wraps a GObject to the right type. It is
// primarily used internally.
func WrapSignalListItemFactory(obj *externglib.Object) SignalListItemFactory {
	return signalListItemFactory{listItemFactory{*externglib.Object{obj}}}
}

func marshalSignalListItemFactory(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSignalListItemFactory(obj), nil
}

// NewSignalListItemFactory constructs a class SignalListItemFactory.
func NewSignalListItemFactory() SignalListItemFactory {

	ret := C.gtk_signal_list_item_factory_new()

	var ret0 SignalListItemFactory

	ret0 = WrapSignalListItemFactory(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// SingleSelection: gtkSingleSelection is an implementation of the
// SelectionModel interface that allows selecting a single element. It is the
// default selection method used by list widgets in GTK.
//
// Note that the selection is *persistent* -- if the selected item is removed
// and re-added in the same Model::items-changed emission, it stays selected. In
// particular, this means that changing the sort order of an underlying sort
// model will preserve the selection.
type SingleSelection interface {
	gextras.Objector

	// Autoselect checks if autoselect has been enabled or disabled via
	// gtk_single_selection_set_autoselect().
	Autoselect() bool
	// CanUnselect: if true, gtk_selection_model_unselect_item() is supported
	// and allows unselecting the selected item.
	CanUnselect() bool
	// Model gets the model that @self is wrapping.
	Model() gio.ListModel
	// Selected gets the position of the selected item. If no item is selected,
	// K_INVALID_LIST_POSITION is returned.
	Selected() uint
	// SelectedItem gets the selected item.
	//
	// If no item is selected, nil is returned.
	SelectedItem() interface{}
	// SetAutoselect: if @autoselect is true, @self will enforce that an item is
	// always selected. It will select a new item when the currently selected
	// item is deleted and it will disallow unselecting the current item.
	SetAutoselect(autoselect bool)
	// SetCanUnselect: if true, unselecting the current item via
	// gtk_selection_model_unselect_item() is supported.
	//
	// Note that setting SingleSelection:autoselect will cause the unselecting
	// to not work, so it practically makes no sense to set both at the same
	// time the same time.
	SetCanUnselect(canUnselect bool)
	// SetModel sets the model that @self should wrap. If @model is nil, @self
	// will be empty.
	SetModel(model gio.ListModel)
	// SetSelected selects the item at the given position.
	//
	// If the list does not have an item at @position or K_INVALID_LIST_POSITION
	// is given, the behavior depends on the value of the
	// SingleSelection:autoselect property: If it is set, no change will occur
	// and the old item will stay selected. If it is unset, the selection will
	// be unset and no item will be selected.
	SetSelected(position uint)
}

type singleSelection struct {
	*externglib.Object
}

// WrapSingleSelection wraps a GObject to the right type. It is
// primarily used internally.
func WrapSingleSelection(obj *externglib.Object) SingleSelection {
	return singleSelection{*externglib.Object{obj}}
}

func marshalSingleSelection(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSingleSelection(obj), nil
}

// NewSingleSelection constructs a class SingleSelection.
func NewSingleSelection(model gio.ListModel) SingleSelection {
	var arg1 *C.GListModel

	ret := C.gtk_single_selection_new(arg1)

	var ret0 SingleSelection

	ret0 = WrapSingleSelection(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Autoselect checks if autoselect has been enabled or disabled via
// gtk_single_selection_set_autoselect().
func (self singleSelection) Autoselect() bool {
	var arg0 *C.GtkSingleSelection

	arg0 = (*C.GtkSingleSelection)(self.Native())

	ret := C.gtk_single_selection_get_autoselect(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// CanUnselect: if true, gtk_selection_model_unselect_item() is supported
// and allows unselecting the selected item.
func (self singleSelection) CanUnselect() bool {
	var arg0 *C.GtkSingleSelection

	arg0 = (*C.GtkSingleSelection)(self.Native())

	ret := C.gtk_single_selection_get_can_unselect(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Model gets the model that @self is wrapping.
func (self singleSelection) Model() gio.ListModel {
	var arg0 *C.GtkSingleSelection

	arg0 = (*C.GtkSingleSelection)(self.Native())

	ret := C.gtk_single_selection_get_model(arg0)

	var ret0 gio.ListModel

	return ret0
}

// Selected gets the position of the selected item. If no item is selected,
// K_INVALID_LIST_POSITION is returned.
func (self singleSelection) Selected() uint {
	var arg0 *C.GtkSingleSelection

	arg0 = (*C.GtkSingleSelection)(self.Native())

	ret := C.gtk_single_selection_get_selected(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// SelectedItem gets the selected item.
//
// If no item is selected, nil is returned.
func (self singleSelection) SelectedItem() interface{} {
	var arg0 *C.GtkSingleSelection

	arg0 = (*C.GtkSingleSelection)(self.Native())

	ret := C.gtk_single_selection_get_selected_item(arg0)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret))

	return ret0
}

// SetAutoselect: if @autoselect is true, @self will enforce that an item is
// always selected. It will select a new item when the currently selected
// item is deleted and it will disallow unselecting the current item.
func (self singleSelection) SetAutoselect(autoselect bool) {
	var arg0 *C.GtkSingleSelection
	var arg1 C.gboolean

	arg0 = (*C.GtkSingleSelection)(self.Native())
	arg1 = gextras.Cbool(autoselect)

	C.gtk_single_selection_set_autoselect(arg0, arg1)
}

// SetCanUnselect: if true, unselecting the current item via
// gtk_selection_model_unselect_item() is supported.
//
// Note that setting SingleSelection:autoselect will cause the unselecting
// to not work, so it practically makes no sense to set both at the same
// time the same time.
func (self singleSelection) SetCanUnselect(canUnselect bool) {
	var arg0 *C.GtkSingleSelection
	var arg1 C.gboolean

	arg0 = (*C.GtkSingleSelection)(self.Native())
	arg1 = gextras.Cbool(canUnselect)

	C.gtk_single_selection_set_can_unselect(arg0, arg1)
}

// SetModel sets the model that @self should wrap. If @model is nil, @self
// will be empty.
func (self singleSelection) SetModel(model gio.ListModel) {
	var arg0 *C.GtkSingleSelection
	var arg1 *C.GListModel

	arg0 = (*C.GtkSingleSelection)(self.Native())

	C.gtk_single_selection_set_model(arg0, arg1)
}

// SetSelected selects the item at the given position.
//
// If the list does not have an item at @position or K_INVALID_LIST_POSITION
// is given, the behavior depends on the value of the
// SingleSelection:autoselect property: If it is set, no change will occur
// and the old item will stay selected. If it is unset, the selection will
// be unset and no item will be selected.
func (self singleSelection) SetSelected(position uint) {
	var arg0 *C.GtkSingleSelection
	var arg1 C.guint

	arg0 = (*C.GtkSingleSelection)(self.Native())
	arg1 = C.guint(position)

	C.gtk_single_selection_set_selected(arg0, arg1)
}

// SizeGroup provides a mechanism for grouping a number of widgets together so
// they all request the same amount of space. This is typically useful when you
// want a column of widgets to have the same size, but you can’t use a Grid
// widget.
//
// In detail, the size requested for each widget in a SizeGroup is the maximum
// of the sizes that would have been requested for each widget in the size group
// if they were not in the size group. The mode of the size group (see
// gtk_size_group_set_mode()) determines whether this applies to the horizontal
// size, the vertical size, or both sizes.
//
// Note that size groups only affect the amount of space requested, not the size
// that the widgets finally receive. If you want the widgets in a SizeGroup to
// actually be the same size, you need to pack them in such a way that they get
// the size they request and not more. For example, if you are packing your
// widgets into a table, you would not include the GTK_FILL flag.
//
// SizeGroup objects are referenced by each widget in the size group, so once
// you have added all widgets to a SizeGroup, you can drop the initial reference
// to the size group with g_object_unref(). If the widgets in the size group are
// subsequently destroyed, then they will be removed from the size group and
// drop their references on the size group; when all widgets have been removed,
// the size group will be freed.
//
// Widgets can be part of multiple size groups; GTK will compute the horizontal
// size of a widget from the horizontal requisition of all widgets that can be
// reached from the widget by a chain of size groups of type
// GTK_SIZE_GROUP_HORIZONTAL or GTK_SIZE_GROUP_BOTH, and the vertical size from
// the vertical requisition of all widgets that can be reached from the widget
// by a chain of size groups of type GTK_SIZE_GROUP_VERTICAL or
// GTK_SIZE_GROUP_BOTH.
//
// Note that only non-contextual sizes of every widget are ever consulted by
// size groups (since size groups have no knowledge of what size a widget will
// be allocated in one dimension, it cannot derive how much height a widget will
// receive for a given width). When grouping widgets that trade height for width
// in mode GTK_SIZE_GROUP_VERTICAL or GTK_SIZE_GROUP_BOTH: the height for the
// minimum width will be the requested height for all widgets in the group. The
// same is of course true when horizontally grouping width for height widgets.
//
// Widgets that trade height-for-width should set a reasonably large minimum
// width by way of Label:width-chars for instance. Widgets with static sizes as
// well as widgets that grow (such as ellipsizing text) need no such
// considerations.
//
//
// GtkSizeGroup as GtkBuildable
//
// Size groups can be specified in a UI definition by placing an <object>
// element with `class="GtkSizeGroup"` somewhere in the UI definition. The
// widgets that belong to the size group are specified by a <widgets> element
// that may contain multiple <widget> elements, one for each member of the size
// group. The ”name” attribute gives the id of the widget.
//
// An example of a UI definition fragment with GtkSizeGroup:
//
//
//    <object class="GtkSizeGroup">
//      <property name="mode">horizontal</property>
//      <widgets>
//        <widget name="radio1"/>
//        <widget name="radio2"/>
//      </widgets>
//    </object>
//
type SizeGroup interface {
	gextras.Objector

	// AddWidget adds a widget to a SizeGroup. In the future, the requisition of
	// the widget will be determined as the maximum of its requisition and the
	// requisition of the other widgets in the size group. Whether this applies
	// horizontally, vertically, or in both directions depends on the mode of
	// the size group. See gtk_size_group_set_mode().
	//
	// When the widget is destroyed or no longer referenced elsewhere, it will
	// be removed from the size group.
	AddWidget(widget Widget)
	// Mode gets the current mode of the size group. See
	// gtk_size_group_set_mode().
	Mode() SizeGroupMode
	// Widgets returns the list of widgets associated with @size_group.
	Widgets() *glib.SList
	// RemoveWidget removes a widget from a SizeGroup.
	RemoveWidget(widget Widget)
	// SetMode sets the SizeGroupMode of the size group. The mode of the size
	// group determines whether the widgets in the size group should all have
	// the same horizontal requisition (GTK_SIZE_GROUP_HORIZONTAL) all have the
	// same vertical requisition (GTK_SIZE_GROUP_VERTICAL), or should all have
	// the same requisition in both directions (GTK_SIZE_GROUP_BOTH).
	SetMode(mode SizeGroupMode)
}

type sizeGroup struct {
	*externglib.Object
}

// WrapSizeGroup wraps a GObject to the right type. It is
// primarily used internally.
func WrapSizeGroup(obj *externglib.Object) SizeGroup {
	return sizeGroup{*externglib.Object{obj}}
}

func marshalSizeGroup(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSizeGroup(obj), nil
}

// NewSizeGroup constructs a class SizeGroup.
func NewSizeGroup(mode SizeGroupMode) SizeGroup {
	var arg1 C.GtkSizeGroupMode

	arg1 = (C.GtkSizeGroupMode)(mode)

	ret := C.gtk_size_group_new(arg1)

	var ret0 SizeGroup

	ret0 = WrapSizeGroup(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// AddWidget adds a widget to a SizeGroup. In the future, the requisition of
// the widget will be determined as the maximum of its requisition and the
// requisition of the other widgets in the size group. Whether this applies
// horizontally, vertically, or in both directions depends on the mode of
// the size group. See gtk_size_group_set_mode().
//
// When the widget is destroyed or no longer referenced elsewhere, it will
// be removed from the size group.
func (sizeGroup sizeGroup) AddWidget(widget Widget) {
	var arg0 *C.GtkSizeGroup
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkSizeGroup)(sizeGroup.Native())
	arg1 = (*C.GtkWidget)(widget.Native())

	C.gtk_size_group_add_widget(arg0, arg1)
}

// Mode gets the current mode of the size group. See
// gtk_size_group_set_mode().
func (sizeGroup sizeGroup) Mode() SizeGroupMode {
	var arg0 *C.GtkSizeGroup

	arg0 = (*C.GtkSizeGroup)(sizeGroup.Native())

	ret := C.gtk_size_group_get_mode(arg0)

	var ret0 SizeGroupMode

	ret0 = SizeGroupMode(ret)

	return ret0
}

// Widgets returns the list of widgets associated with @size_group.
func (sizeGroup sizeGroup) Widgets() *glib.SList {
	var arg0 *C.GtkSizeGroup

	arg0 = (*C.GtkSizeGroup)(sizeGroup.Native())

	ret := C.gtk_size_group_get_widgets(arg0)

	var ret0 *glib.SList

	ret0 = glib.WrapSList(ret)

	return ret0
}

// RemoveWidget removes a widget from a SizeGroup.
func (sizeGroup sizeGroup) RemoveWidget(widget Widget) {
	var arg0 *C.GtkSizeGroup
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkSizeGroup)(sizeGroup.Native())
	arg1 = (*C.GtkWidget)(widget.Native())

	C.gtk_size_group_remove_widget(arg0, arg1)
}

// SetMode sets the SizeGroupMode of the size group. The mode of the size
// group determines whether the widgets in the size group should all have
// the same horizontal requisition (GTK_SIZE_GROUP_HORIZONTAL) all have the
// same vertical requisition (GTK_SIZE_GROUP_VERTICAL), or should all have
// the same requisition in both directions (GTK_SIZE_GROUP_BOTH).
func (sizeGroup sizeGroup) SetMode(mode SizeGroupMode) {
	var arg0 *C.GtkSizeGroup
	var arg1 C.GtkSizeGroupMode

	arg0 = (*C.GtkSizeGroup)(sizeGroup.Native())
	arg1 = (C.GtkSizeGroupMode)(mode)

	C.gtk_size_group_set_mode(arg0, arg1)
}

// SliceListModel is a list model that takes a list model and presents a slice
// of that model.
//
// This is useful when implementing paging by setting the size to the number of
// elements per page and updating the offset whenever a different page is
// opened.
type SliceListModel interface {
	gextras.Objector

	// Model gets the model that is currently being used or nil if none.
	Model() gio.ListModel
	// Offset gets the offset set via gtk_slice_list_model_set_offset()
	Offset() uint
	// Size gets the size set via gtk_slice_list_model_set_size().
	Size() uint
	// SetModel sets the model to show a slice of. The model's item type must
	// conform to @self's item type.
	SetModel(model gio.ListModel)
	// SetOffset sets the offset into the original model for this slice.
	//
	// If the offset is too large for the sliced model, @self will end up empty.
	SetOffset(offset uint)
	// SetSize sets the maximum size. @self will never have more items than
	// @size.
	//
	// It can however have fewer items if the offset is too large or the model
	// sliced from doesn't have enough items.
	SetSize(size uint)
}

type sliceListModel struct {
	*externglib.Object
}

// WrapSliceListModel wraps a GObject to the right type. It is
// primarily used internally.
func WrapSliceListModel(obj *externglib.Object) SliceListModel {
	return sliceListModel{*externglib.Object{obj}}
}

func marshalSliceListModel(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSliceListModel(obj), nil
}

// NewSliceListModel constructs a class SliceListModel.
func NewSliceListModel(model gio.ListModel, offset uint, size uint) SliceListModel {
	var arg1 *C.GListModel
	var arg2 C.guint
	var arg3 C.guint

	arg2 = C.guint(offset)
	arg3 = C.guint(size)

	ret := C.gtk_slice_list_model_new(arg1, arg2, arg3)

	var ret0 SliceListModel

	ret0 = WrapSliceListModel(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Model gets the model that is currently being used or nil if none.
func (self sliceListModel) Model() gio.ListModel {
	var arg0 *C.GtkSliceListModel

	arg0 = (*C.GtkSliceListModel)(self.Native())

	ret := C.gtk_slice_list_model_get_model(arg0)

	var ret0 gio.ListModel

	return ret0
}

// Offset gets the offset set via gtk_slice_list_model_set_offset()
func (self sliceListModel) Offset() uint {
	var arg0 *C.GtkSliceListModel

	arg0 = (*C.GtkSliceListModel)(self.Native())

	ret := C.gtk_slice_list_model_get_offset(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// Size gets the size set via gtk_slice_list_model_set_size().
func (self sliceListModel) Size() uint {
	var arg0 *C.GtkSliceListModel

	arg0 = (*C.GtkSliceListModel)(self.Native())

	ret := C.gtk_slice_list_model_get_size(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// SetModel sets the model to show a slice of. The model's item type must
// conform to @self's item type.
func (self sliceListModel) SetModel(model gio.ListModel) {
	var arg0 *C.GtkSliceListModel
	var arg1 *C.GListModel

	arg0 = (*C.GtkSliceListModel)(self.Native())

	C.gtk_slice_list_model_set_model(arg0, arg1)
}

// SetOffset sets the offset into the original model for this slice.
//
// If the offset is too large for the sliced model, @self will end up empty.
func (self sliceListModel) SetOffset(offset uint) {
	var arg0 *C.GtkSliceListModel
	var arg1 C.guint

	arg0 = (*C.GtkSliceListModel)(self.Native())
	arg1 = C.guint(offset)

	C.gtk_slice_list_model_set_offset(arg0, arg1)
}

// SetSize sets the maximum size. @self will never have more items than
// @size.
//
// It can however have fewer items if the offset is too large or the model
// sliced from doesn't have enough items.
func (self sliceListModel) SetSize(size uint) {
	var arg0 *C.GtkSliceListModel
	var arg1 C.guint

	arg0 = (*C.GtkSliceListModel)(self.Native())
	arg1 = C.guint(size)

	C.gtk_slice_list_model_set_size(arg0, arg1)
}

// Snapshot: gtkSnapshot is an auxiliary object that assists in creating
// RenderNodes in the PaintableInterface.snapshot() vfunc. It functions in a
// similar way to a cairo context, and maintains a stack of render nodes and
// their associated transformations.
//
// The node at the top of the stack is the the one that gtk_snapshot_append_…
// functions operate on. Use the gtk_snapshot_push_… functions and
// gtk_snapshot_pop() to change the current node.
//
// The typical way to obtain a GtkSnapshot object is as an argument to the
// WidgetClass.snapshot() vfunc. If you need to create your own GtkSnapshot, use
// gtk_snapshot_new().
type Snapshot interface {
	gdk.Snapshot

	// AppendBorder appends a stroked border rectangle inside the given
	// @outline. The 4 sides of the border can have different widths and colors.
	AppendBorder(outline *gsk.RoundedRect, borderWidth [4]float32, borderColor [4]gdk.RGBA)
	// AppendCairo creates a new render node and appends it to the current
	// render node of @snapshot, without changing the current node.
	AppendCairo(bounds *graphene.Rect) *cairo.Context
	// AppendColor creates a new render node drawing the @color into the given
	// @bounds and appends it to the current render node of @snapshot.
	//
	// You should try to avoid calling this function if @color is transparent.
	AppendColor(color *gdk.RGBA, bounds *graphene.Rect)
	// AppendConicGradient appends a conic gradient node with the given stops to
	// @snapshot.
	AppendConicGradient(bounds *graphene.Rect, center *graphene.Point, rotation float32, stops []gsk.ColorStop)
	// AppendInsetShadow appends an inset shadow into the box given by @outline.
	AppendInsetShadow(outline *gsk.RoundedRect, color *gdk.RGBA, dx float32, dy float32, spread float32, blurRadius float32)

	AppendLayout(layout pango.Layout, color *gdk.RGBA)
	// AppendLinearGradient appends a linear gradient node with the given stops
	// to @snapshot.
	AppendLinearGradient(bounds *graphene.Rect, startPoint *graphene.Point, endPoint *graphene.Point, stops []gsk.ColorStop)
	// AppendNode appends @node to the current render node of @snapshot, without
	// changing the current node. If @snapshot does not have a current node yet,
	// @node will become the initial node.
	AppendNode(node gsk.RenderNode)
	// AppendOutsetShadow appends an outset shadow node around the box given by
	// @outline.
	AppendOutsetShadow(outline *gsk.RoundedRect, color *gdk.RGBA, dx float32, dy float32, spread float32, blurRadius float32)
	// AppendRadialGradient appends a radial gradient node with the given stops
	// to @snapshot.
	AppendRadialGradient(bounds *graphene.Rect, center *graphene.Point, hradius float32, vradius float32, start float32, end float32, stops []gsk.ColorStop)
	// AppendRepeatingLinearGradient appends a repeating linear gradient node
	// with the given stops to @snapshot.
	AppendRepeatingLinearGradient(bounds *graphene.Rect, startPoint *graphene.Point, endPoint *graphene.Point, stops []gsk.ColorStop)
	// AppendRepeatingRadialGradient appends a repeating radial gradient node
	// with the given stops to @snapshot.
	AppendRepeatingRadialGradient(bounds *graphene.Rect, center *graphene.Point, hradius float32, vradius float32, start float32, end float32, stops []gsk.ColorStop)
	// AppendTexture creates a new render node drawing the @texture into the
	// given @bounds and appends it to the current render node of @snapshot.
	AppendTexture(texture gdk.Texture, bounds *graphene.Rect)
	// FreeToNode returns the node that was constructed by @snapshot and frees
	// @snapshot.
	FreeToNode() gsk.RenderNode
	// FreeToPaintable returns a paintable for the node that was constructed by
	// @snapshot and frees @snapshot.
	FreeToPaintable(size *graphene.Size) gdk.Paintable
	// GLShaderPopTexture removes the top element from the stack of render nodes
	// and adds it to the nearest GskGLShaderNode below it. This must be called
	// the same number of times as the number of textures is needed for the
	// shader in gtk_snapshot_push_gl_shader().
	GLShaderPopTexture()
	// Perspective applies a perspective projection transform.
	//
	// See gsk_transform_perspective() for a discussion on the details.
	Perspective(depth float32)
	// Pop removes the top element from the stack of render nodes, and appends
	// it to the node underneath it.
	Pop()
	// PushBlend blends together 2 images with the given blend mode.
	//
	// Until the first call to gtk_snapshot_pop(), the bottom image for the
	// blend operation will be recorded. After that call, the top image to be
	// blended will be recorded until the second call to gtk_snapshot_pop().
	//
	// Calling this function requires 2 subsequent calls to gtk_snapshot_pop().
	PushBlend(blendMode gsk.BlendMode)
	// PushBlur blurs an image.
	//
	// The image is recorded until the next call to gtk_snapshot_pop().
	PushBlur(radius float64)
	// PushClip clips an image to a rectangle.
	//
	// The image is recorded until the next call to gtk_snapshot_pop().
	PushClip(bounds *graphene.Rect)
	// PushColorMatrix modifies the colors of an image by applying an affine
	// transformation in RGB space.
	//
	// The image is recorded until the next call to gtk_snapshot_pop().
	PushColorMatrix(colorMatrix *graphene.Matrix, colorOffset *graphene.Vec4)
	// PushCrossFade snapshots a cross-fade operation between two images with
	// the given @progress.
	//
	// Until the first call to gtk_snapshot_pop(), the start image will be
	// snapshot. After that call, the end image will be recorded until the
	// second call to gtk_snapshot_pop().
	//
	// Calling this function requires 2 calls to gtk_snapshot_pop().
	PushCrossFade(progress float64)
	// PushGLShader: push a GLShaderNode with a specific GLShader and a set of
	// uniform values to use while rendering. Additionally this takes a list of
	// @n_children other nodes which will be passed to the GLShaderNode.
	//
	// The @take_args argument is a block of data to use for uniform arguments,
	// as per types and offsets defined by the @shader. Normally this is
	// generated by gsk_gl_shader_format_args() or GLShaderArgBuilder. The
	// snapshotter takes ownership of @take_args, so the caller should not free
	// it after this.
	//
	// If the renderer doesn't support GL shaders, or if there is any problem
	// when compiling the shader, then the node will draw pink. You should use
	// gsk_gl_shader_compile() to ensure the @shader will work for the renderer
	// before using it.
	//
	// If the shader requires textures (see gsk_gl_shader_get_n_textures()),
	// then it is expected that you call gtk_snapshot_gl_shader_pop_texture()
	// the number of times that are required. Each of these calls will generate
	// a node that is added as a child to the gl shader node, which in turn will
	// render these offscreen and pass as a texture to the shader.
	//
	// Once all textures (if any) are pop:ed, you must call the regular
	// gtk_snapshot_pop().
	//
	// If you want to use pre-existing textures as input to the shader rather
	// than rendering new ones, use gtk_snapshot_append_texture() to push a
	// texture node. These will be used directly rather than being re-rendered.
	//
	// For details on how to write shaders, see GLShader.
	PushGLShader(shader gsk.GLShader, bounds *graphene.Rect, takeArgs *glib.Bytes)
	// PushOpacity modifies the opacity of an image.
	//
	// The image is recorded until the next call to gtk_snapshot_pop().
	PushOpacity(opacity float64)
	// PushRepeat creates a node that repeats the child node.
	//
	// The child is recorded until the next call to gtk_snapshot_pop().
	PushRepeat(bounds *graphene.Rect, childBounds *graphene.Rect)
	// PushRoundedClip clips an image to a rounded rectangle.
	//
	// The image is recorded until the next call to gtk_snapshot_pop().
	PushRoundedClip(bounds *gsk.RoundedRect)
	// PushShadow applies a shadow to an image.
	//
	// The image is recorded until the next call to gtk_snapshot_pop().
	PushShadow(shadow *gsk.Shadow, nShadows uint)
	// RenderBackground creates a render node for the CSS background according
	// to @context, and appends it to the current node of @snapshot, without
	// changing the current node.
	RenderBackground(context StyleContext, x float64, y float64, width float64, height float64)
	// RenderFocus creates a render node for the focus outline according to
	// @context, and appends it to the current node of @snapshot, without
	// changing the current node.
	RenderFocus(context StyleContext, x float64, y float64, width float64, height float64)
	// RenderFrame creates a render node for the CSS border according to
	// @context, and appends it to the current node of @snapshot, without
	// changing the current node.
	RenderFrame(context StyleContext, x float64, y float64, width float64, height float64)
	// RenderInsertionCursor draws a text caret using @snapshot at the specified
	// index of @layout.
	RenderInsertionCursor(context StyleContext, x float64, y float64, layout pango.Layout, index int, direction pango.Direction)
	// RenderLayout creates a render node for rendering @layout according to the
	// style information in @context, and appends it to the current node of
	// @snapshot, without changing the current node.
	RenderLayout(context StyleContext, x float64, y float64, layout pango.Layout)
	// Restore restores @snapshot to the state saved by a preceding call to
	// gtk_snapshot_save() and removes that state from the stack of saved
	// states.
	Restore()
	// Rotate rotates @@snapshot's coordinate system by @angle degrees in 2D
	// space - or in 3D speak, rotates around the z axis.
	Rotate(angle float32)
	// Rotate3D rotates @snapshot's coordinate system by @angle degrees around
	// @axis.
	//
	// For a rotation in 2D space, use gsk_transform_rotate().
	Rotate3D(angle float32, axis *graphene.Vec3)
	// Save makes a copy of the current state of @snapshot and saves it on an
	// internal stack of saved states for @snapshot. When gtk_snapshot_restore()
	// is called, @snapshot will be restored to the saved state. Multiple calls
	// to gtk_snapshot_save() and gtk_snapshot_restore() can be nested; each
	// call to gtk_snapshot_restore() restores the state from the matching
	// paired gtk_snapshot_save().
	//
	// It is necessary to clear all saved states with corresponding calls to
	// gtk_snapshot_restore().
	Save()
	// Scale scales @snapshot's coordinate system in 2-dimensional space by the
	// given factors.
	//
	// Use gtk_snapshot_scale_3d() to scale in all 3 dimensions.
	Scale(factorX float32, factorY float32)
	// Scale3D scales @snapshot's coordinate system by the given factors.
	Scale3D(factorX float32, factorY float32, factorZ float32)
	// ToNode returns the render node that was constructed by @snapshot. After
	// calling this function, it is no longer possible to add more nodes to
	// @snapshot. The only function that should be called after this is
	// g_object_unref().
	ToNode() gsk.RenderNode
	// ToPaintable returns a paintable encapsulating the render node that was
	// constructed by @snapshot. After calling this function, it is no longer
	// possible to add more nodes to @snapshot. The only function that should be
	// called after this is g_object_unref().
	ToPaintable(size *graphene.Size) gdk.Paintable
	// Transform transforms @snapshot's coordinate system with the given
	// @transform.
	Transform(transform *gsk.Transform)
	// TransformMatrix transforms @snapshot's coordinate system with the given
	// @matrix.
	TransformMatrix(matrix *graphene.Matrix)
	// Translate translates @snapshot's coordinate system by @point in
	// 2-dimensional space.
	Translate(point *graphene.Point)
	// Translate3D translates @snapshot's coordinate system by @point.
	Translate3D(point *graphene.Point3D)
}

type snapshot struct {
	gdk.Snapshot
}

// WrapSnapshot wraps a GObject to the right type. It is
// primarily used internally.
func WrapSnapshot(obj *externglib.Object) Snapshot {
	return snapshot{gdk.WrapSnapshot(obj)}
}

func marshalSnapshot(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSnapshot(obj), nil
}

// AppendBorder appends a stroked border rectangle inside the given
// @outline. The 4 sides of the border can have different widths and colors.
func (snapshot snapshot) AppendBorder(outline *gsk.RoundedRect, borderWidth [4]float32, borderColor [4]gdk.RGBA) {
	var arg0 *C.GtkSnapshot
	var arg1 *C.GskRoundedRect
	var arg2 *C.float
	var arg3 *C.GdkRGBA

	arg0 = (*C.GtkSnapshot)(snapshot.Native())
	arg1 = (*C.GskRoundedRect)(outline.Native())
	{
		arg2 = (*C.float)(&borderWidth)
		defer runtime.KeepAlive(&borderWidth)
	}
	{
		dst := &arg3

		for i := 0; i < 4; i++ {
			src := borderColor[i]
			dst[i] = (C.GdkRGBA)(src.Native())
		}
	}

	C.gtk_snapshot_append_border(arg0, arg1, arg2, arg3)
}

// AppendCairo creates a new render node and appends it to the current
// render node of @snapshot, without changing the current node.
func (snapshot snapshot) AppendCairo(bounds *graphene.Rect) *cairo.Context {
	var arg0 *C.GtkSnapshot
	var arg1 *C.graphene_rect_t

	arg0 = (*C.GtkSnapshot)(snapshot.Native())
	arg1 = (*C.graphene_rect_t)(bounds.Native())

	ret := C.gtk_snapshot_append_cairo(arg0, arg1)

	var ret0 *cairo.Context

	ret0 = cairo.WrapContext(ret)

	return ret0
}

// AppendColor creates a new render node drawing the @color into the given
// @bounds and appends it to the current render node of @snapshot.
//
// You should try to avoid calling this function if @color is transparent.
func (snapshot snapshot) AppendColor(color *gdk.RGBA, bounds *graphene.Rect) {
	var arg0 *C.GtkSnapshot
	var arg1 *C.GdkRGBA
	var arg2 *C.graphene_rect_t

	arg0 = (*C.GtkSnapshot)(snapshot.Native())
	arg1 = (*C.GdkRGBA)(color.Native())
	arg2 = (*C.graphene_rect_t)(bounds.Native())

	C.gtk_snapshot_append_color(arg0, arg1, arg2)
}

// AppendConicGradient appends a conic gradient node with the given stops to
// @snapshot.
func (snapshot snapshot) AppendConicGradient(bounds *graphene.Rect, center *graphene.Point, rotation float32, stops []gsk.ColorStop) {
	var arg0 *C.GtkSnapshot
	var arg1 *C.graphene_rect_t
	var arg2 *C.graphene_point_t
	var arg3 C.float
	var arg4 *C.GskColorStop
	var arg5 C.gsize

	arg0 = (*C.GtkSnapshot)(snapshot.Native())
	arg1 = (*C.graphene_rect_t)(bounds.Native())
	arg2 = (*C.graphene_point_t)(center.Native())
	arg3 = C.float(rotation)
	{
		var dst []C.GskColorStop
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(C.malloc(C.sizeof_GskColorStop * len(stops))))
		sliceHeader.Len = len(stops)
		sliceHeader.Cap = len(stops)
		defer C.free(unsafe.Pointer(sliceHeader.Data))

		for i := 0; i < len(stops); i++ {
			src := stops[i]
			dst[i] = (C.GskColorStop)(src.Native())
		}

		arg4 = (*C.GskColorStop)(unsafe.Pointer(sliceHeader.Data))
		arg5 = len(stops)
	}

	C.gtk_snapshot_append_conic_gradient(arg0, arg1, arg2, arg3, arg4, arg5)
}

// AppendInsetShadow appends an inset shadow into the box given by @outline.
func (snapshot snapshot) AppendInsetShadow(outline *gsk.RoundedRect, color *gdk.RGBA, dx float32, dy float32, spread float32, blurRadius float32) {
	var arg0 *C.GtkSnapshot
	var arg1 *C.GskRoundedRect
	var arg2 *C.GdkRGBA
	var arg3 C.float
	var arg4 C.float
	var arg5 C.float
	var arg6 C.float

	arg0 = (*C.GtkSnapshot)(snapshot.Native())
	arg1 = (*C.GskRoundedRect)(outline.Native())
	arg2 = (*C.GdkRGBA)(color.Native())
	arg3 = C.float(dx)
	arg4 = C.float(dy)
	arg5 = C.float(spread)
	arg6 = C.float(blurRadius)

	C.gtk_snapshot_append_inset_shadow(arg0, arg1, arg2, arg3, arg4, arg5, arg6)
}

func (snapshot snapshot) AppendLayout(layout pango.Layout, color *gdk.RGBA) {
	var arg0 *C.GtkSnapshot
	var arg1 *C.PangoLayout
	var arg2 *C.GdkRGBA

	arg0 = (*C.GtkSnapshot)(snapshot.Native())
	arg1 = (*C.PangoLayout)(layout.Native())
	arg2 = (*C.GdkRGBA)(color.Native())

	C.gtk_snapshot_append_layout(arg0, arg1, arg2)
}

// AppendLinearGradient appends a linear gradient node with the given stops
// to @snapshot.
func (snapshot snapshot) AppendLinearGradient(bounds *graphene.Rect, startPoint *graphene.Point, endPoint *graphene.Point, stops []gsk.ColorStop) {
	var arg0 *C.GtkSnapshot
	var arg1 *C.graphene_rect_t
	var arg2 *C.graphene_point_t
	var arg3 *C.graphene_point_t
	var arg4 *C.GskColorStop
	var arg5 C.gsize

	arg0 = (*C.GtkSnapshot)(snapshot.Native())
	arg1 = (*C.graphene_rect_t)(bounds.Native())
	arg2 = (*C.graphene_point_t)(startPoint.Native())
	arg3 = (*C.graphene_point_t)(endPoint.Native())
	{
		var dst []C.GskColorStop
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(C.malloc(C.sizeof_GskColorStop * len(stops))))
		sliceHeader.Len = len(stops)
		sliceHeader.Cap = len(stops)
		defer C.free(unsafe.Pointer(sliceHeader.Data))

		for i := 0; i < len(stops); i++ {
			src := stops[i]
			dst[i] = (C.GskColorStop)(src.Native())
		}

		arg4 = (*C.GskColorStop)(unsafe.Pointer(sliceHeader.Data))
		arg5 = len(stops)
	}

	C.gtk_snapshot_append_linear_gradient(arg0, arg1, arg2, arg3, arg4, arg5)
}

// AppendNode appends @node to the current render node of @snapshot, without
// changing the current node. If @snapshot does not have a current node yet,
// @node will become the initial node.
func (snapshot snapshot) AppendNode(node gsk.RenderNode) {
	var arg0 *C.GtkSnapshot
	var arg1 *C.GskRenderNode

	arg0 = (*C.GtkSnapshot)(snapshot.Native())
	arg1 = (*C.GskRenderNode)(node.Native())

	C.gtk_snapshot_append_node(arg0, arg1)
}

// AppendOutsetShadow appends an outset shadow node around the box given by
// @outline.
func (snapshot snapshot) AppendOutsetShadow(outline *gsk.RoundedRect, color *gdk.RGBA, dx float32, dy float32, spread float32, blurRadius float32) {
	var arg0 *C.GtkSnapshot
	var arg1 *C.GskRoundedRect
	var arg2 *C.GdkRGBA
	var arg3 C.float
	var arg4 C.float
	var arg5 C.float
	var arg6 C.float

	arg0 = (*C.GtkSnapshot)(snapshot.Native())
	arg1 = (*C.GskRoundedRect)(outline.Native())
	arg2 = (*C.GdkRGBA)(color.Native())
	arg3 = C.float(dx)
	arg4 = C.float(dy)
	arg5 = C.float(spread)
	arg6 = C.float(blurRadius)

	C.gtk_snapshot_append_outset_shadow(arg0, arg1, arg2, arg3, arg4, arg5, arg6)
}

// AppendRadialGradient appends a radial gradient node with the given stops
// to @snapshot.
func (snapshot snapshot) AppendRadialGradient(bounds *graphene.Rect, center *graphene.Point, hradius float32, vradius float32, start float32, end float32, stops []gsk.ColorStop) {
	var arg0 *C.GtkSnapshot
	var arg1 *C.graphene_rect_t
	var arg2 *C.graphene_point_t
	var arg3 C.float
	var arg4 C.float
	var arg5 C.float
	var arg6 C.float
	var arg7 *C.GskColorStop
	var arg8 C.gsize

	arg0 = (*C.GtkSnapshot)(snapshot.Native())
	arg1 = (*C.graphene_rect_t)(bounds.Native())
	arg2 = (*C.graphene_point_t)(center.Native())
	arg3 = C.float(hradius)
	arg4 = C.float(vradius)
	arg5 = C.float(start)
	arg6 = C.float(end)
	{
		var dst []C.GskColorStop
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(C.malloc(C.sizeof_GskColorStop * len(stops))))
		sliceHeader.Len = len(stops)
		sliceHeader.Cap = len(stops)
		defer C.free(unsafe.Pointer(sliceHeader.Data))

		for i := 0; i < len(stops); i++ {
			src := stops[i]
			dst[i] = (C.GskColorStop)(src.Native())
		}

		arg7 = (*C.GskColorStop)(unsafe.Pointer(sliceHeader.Data))
		arg8 = len(stops)
	}

	C.gtk_snapshot_append_radial_gradient(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)
}

// AppendRepeatingLinearGradient appends a repeating linear gradient node
// with the given stops to @snapshot.
func (snapshot snapshot) AppendRepeatingLinearGradient(bounds *graphene.Rect, startPoint *graphene.Point, endPoint *graphene.Point, stops []gsk.ColorStop) {
	var arg0 *C.GtkSnapshot
	var arg1 *C.graphene_rect_t
	var arg2 *C.graphene_point_t
	var arg3 *C.graphene_point_t
	var arg4 *C.GskColorStop
	var arg5 C.gsize

	arg0 = (*C.GtkSnapshot)(snapshot.Native())
	arg1 = (*C.graphene_rect_t)(bounds.Native())
	arg2 = (*C.graphene_point_t)(startPoint.Native())
	arg3 = (*C.graphene_point_t)(endPoint.Native())
	{
		var dst []C.GskColorStop
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(C.malloc(C.sizeof_GskColorStop * len(stops))))
		sliceHeader.Len = len(stops)
		sliceHeader.Cap = len(stops)
		defer C.free(unsafe.Pointer(sliceHeader.Data))

		for i := 0; i < len(stops); i++ {
			src := stops[i]
			dst[i] = (C.GskColorStop)(src.Native())
		}

		arg4 = (*C.GskColorStop)(unsafe.Pointer(sliceHeader.Data))
		arg5 = len(stops)
	}

	C.gtk_snapshot_append_repeating_linear_gradient(arg0, arg1, arg2, arg3, arg4, arg5)
}

// AppendRepeatingRadialGradient appends a repeating radial gradient node
// with the given stops to @snapshot.
func (snapshot snapshot) AppendRepeatingRadialGradient(bounds *graphene.Rect, center *graphene.Point, hradius float32, vradius float32, start float32, end float32, stops []gsk.ColorStop) {
	var arg0 *C.GtkSnapshot
	var arg1 *C.graphene_rect_t
	var arg2 *C.graphene_point_t
	var arg3 C.float
	var arg4 C.float
	var arg5 C.float
	var arg6 C.float
	var arg7 *C.GskColorStop
	var arg8 C.gsize

	arg0 = (*C.GtkSnapshot)(snapshot.Native())
	arg1 = (*C.graphene_rect_t)(bounds.Native())
	arg2 = (*C.graphene_point_t)(center.Native())
	arg3 = C.float(hradius)
	arg4 = C.float(vradius)
	arg5 = C.float(start)
	arg6 = C.float(end)
	{
		var dst []C.GskColorStop
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(C.malloc(C.sizeof_GskColorStop * len(stops))))
		sliceHeader.Len = len(stops)
		sliceHeader.Cap = len(stops)
		defer C.free(unsafe.Pointer(sliceHeader.Data))

		for i := 0; i < len(stops); i++ {
			src := stops[i]
			dst[i] = (C.GskColorStop)(src.Native())
		}

		arg7 = (*C.GskColorStop)(unsafe.Pointer(sliceHeader.Data))
		arg8 = len(stops)
	}

	C.gtk_snapshot_append_repeating_radial_gradient(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)
}

// AppendTexture creates a new render node drawing the @texture into the
// given @bounds and appends it to the current render node of @snapshot.
func (snapshot snapshot) AppendTexture(texture gdk.Texture, bounds *graphene.Rect) {
	var arg0 *C.GtkSnapshot
	var arg1 *C.GdkTexture
	var arg2 *C.graphene_rect_t

	arg0 = (*C.GtkSnapshot)(snapshot.Native())
	arg1 = (*C.GdkTexture)(texture.Native())
	arg2 = (*C.graphene_rect_t)(bounds.Native())

	C.gtk_snapshot_append_texture(arg0, arg1, arg2)
}

// FreeToNode returns the node that was constructed by @snapshot and frees
// @snapshot.
func (snapshot snapshot) FreeToNode() gsk.RenderNode {
	var arg0 *C.GtkSnapshot

	arg0 = (*C.GtkSnapshot)(snapshot.Native())

	ret := C.gtk_snapshot_free_to_node(arg0)

	var ret0 gsk.RenderNode

	ret0 = gsk.WrapRenderNode(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// FreeToPaintable returns a paintable for the node that was constructed by
// @snapshot and frees @snapshot.
func (snapshot snapshot) FreeToPaintable(size *graphene.Size) gdk.Paintable {
	var arg0 *C.GtkSnapshot
	var arg1 *C.graphene_size_t

	arg0 = (*C.GtkSnapshot)(snapshot.Native())
	arg1 = (*C.graphene_size_t)(size.Native())

	ret := C.gtk_snapshot_free_to_paintable(arg0, arg1)

	var ret0 gdk.Paintable

	return ret0
}

// GLShaderPopTexture removes the top element from the stack of render nodes
// and adds it to the nearest GskGLShaderNode below it. This must be called
// the same number of times as the number of textures is needed for the
// shader in gtk_snapshot_push_gl_shader().
func (snapshot snapshot) GLShaderPopTexture() {
	var arg0 *C.GtkSnapshot

	arg0 = (*C.GtkSnapshot)(snapshot.Native())

	C.gtk_snapshot_gl_shader_pop_texture(arg0)
}

// Perspective applies a perspective projection transform.
//
// See gsk_transform_perspective() for a discussion on the details.
func (snapshot snapshot) Perspective(depth float32) {
	var arg0 *C.GtkSnapshot
	var arg1 C.float

	arg0 = (*C.GtkSnapshot)(snapshot.Native())
	arg1 = C.float(depth)

	C.gtk_snapshot_perspective(arg0, arg1)
}

// Pop removes the top element from the stack of render nodes, and appends
// it to the node underneath it.
func (snapshot snapshot) Pop() {
	var arg0 *C.GtkSnapshot

	arg0 = (*C.GtkSnapshot)(snapshot.Native())

	C.gtk_snapshot_pop(arg0)
}

// PushBlend blends together 2 images with the given blend mode.
//
// Until the first call to gtk_snapshot_pop(), the bottom image for the
// blend operation will be recorded. After that call, the top image to be
// blended will be recorded until the second call to gtk_snapshot_pop().
//
// Calling this function requires 2 subsequent calls to gtk_snapshot_pop().
func (snapshot snapshot) PushBlend(blendMode gsk.BlendMode) {
	var arg0 *C.GtkSnapshot
	var arg1 C.GskBlendMode

	arg0 = (*C.GtkSnapshot)(snapshot.Native())
	arg1 = (C.GskBlendMode)(blendMode)

	C.gtk_snapshot_push_blend(arg0, arg1)
}

// PushBlur blurs an image.
//
// The image is recorded until the next call to gtk_snapshot_pop().
func (snapshot snapshot) PushBlur(radius float64) {
	var arg0 *C.GtkSnapshot
	var arg1 C.double

	arg0 = (*C.GtkSnapshot)(snapshot.Native())
	arg1 = C.double(radius)

	C.gtk_snapshot_push_blur(arg0, arg1)
}

// PushClip clips an image to a rectangle.
//
// The image is recorded until the next call to gtk_snapshot_pop().
func (snapshot snapshot) PushClip(bounds *graphene.Rect) {
	var arg0 *C.GtkSnapshot
	var arg1 *C.graphene_rect_t

	arg0 = (*C.GtkSnapshot)(snapshot.Native())
	arg1 = (*C.graphene_rect_t)(bounds.Native())

	C.gtk_snapshot_push_clip(arg0, arg1)
}

// PushColorMatrix modifies the colors of an image by applying an affine
// transformation in RGB space.
//
// The image is recorded until the next call to gtk_snapshot_pop().
func (snapshot snapshot) PushColorMatrix(colorMatrix *graphene.Matrix, colorOffset *graphene.Vec4) {
	var arg0 *C.GtkSnapshot
	var arg1 *C.graphene_matrix_t
	var arg2 *C.graphene_vec4_t

	arg0 = (*C.GtkSnapshot)(snapshot.Native())
	arg1 = (*C.graphene_matrix_t)(colorMatrix.Native())
	arg2 = (*C.graphene_vec4_t)(colorOffset.Native())

	C.gtk_snapshot_push_color_matrix(arg0, arg1, arg2)
}

// PushCrossFade snapshots a cross-fade operation between two images with
// the given @progress.
//
// Until the first call to gtk_snapshot_pop(), the start image will be
// snapshot. After that call, the end image will be recorded until the
// second call to gtk_snapshot_pop().
//
// Calling this function requires 2 calls to gtk_snapshot_pop().
func (snapshot snapshot) PushCrossFade(progress float64) {
	var arg0 *C.GtkSnapshot
	var arg1 C.double

	arg0 = (*C.GtkSnapshot)(snapshot.Native())
	arg1 = C.double(progress)

	C.gtk_snapshot_push_cross_fade(arg0, arg1)
}

// PushGLShader: push a GLShaderNode with a specific GLShader and a set of
// uniform values to use while rendering. Additionally this takes a list of
// @n_children other nodes which will be passed to the GLShaderNode.
//
// The @take_args argument is a block of data to use for uniform arguments,
// as per types and offsets defined by the @shader. Normally this is
// generated by gsk_gl_shader_format_args() or GLShaderArgBuilder. The
// snapshotter takes ownership of @take_args, so the caller should not free
// it after this.
//
// If the renderer doesn't support GL shaders, or if there is any problem
// when compiling the shader, then the node will draw pink. You should use
// gsk_gl_shader_compile() to ensure the @shader will work for the renderer
// before using it.
//
// If the shader requires textures (see gsk_gl_shader_get_n_textures()),
// then it is expected that you call gtk_snapshot_gl_shader_pop_texture()
// the number of times that are required. Each of these calls will generate
// a node that is added as a child to the gl shader node, which in turn will
// render these offscreen and pass as a texture to the shader.
//
// Once all textures (if any) are pop:ed, you must call the regular
// gtk_snapshot_pop().
//
// If you want to use pre-existing textures as input to the shader rather
// than rendering new ones, use gtk_snapshot_append_texture() to push a
// texture node. These will be used directly rather than being re-rendered.
//
// For details on how to write shaders, see GLShader.
func (snapshot snapshot) PushGLShader(shader gsk.GLShader, bounds *graphene.Rect, takeArgs *glib.Bytes) {
	var arg0 *C.GtkSnapshot
	var arg1 *C.GskGLShader
	var arg2 *C.graphene_rect_t
	var arg3 *C.GBytes

	arg0 = (*C.GtkSnapshot)(snapshot.Native())
	arg1 = (*C.GskGLShader)(shader.Native())
	arg2 = (*C.graphene_rect_t)(bounds.Native())
	arg3 = (*C.GBytes)(takeArgs.Native())

	C.gtk_snapshot_push_gl_shader(arg0, arg1, arg2, arg3)
}

// PushOpacity modifies the opacity of an image.
//
// The image is recorded until the next call to gtk_snapshot_pop().
func (snapshot snapshot) PushOpacity(opacity float64) {
	var arg0 *C.GtkSnapshot
	var arg1 C.double

	arg0 = (*C.GtkSnapshot)(snapshot.Native())
	arg1 = C.double(opacity)

	C.gtk_snapshot_push_opacity(arg0, arg1)
}

// PushRepeat creates a node that repeats the child node.
//
// The child is recorded until the next call to gtk_snapshot_pop().
func (snapshot snapshot) PushRepeat(bounds *graphene.Rect, childBounds *graphene.Rect) {
	var arg0 *C.GtkSnapshot
	var arg1 *C.graphene_rect_t
	var arg2 *C.graphene_rect_t

	arg0 = (*C.GtkSnapshot)(snapshot.Native())
	arg1 = (*C.graphene_rect_t)(bounds.Native())
	arg2 = (*C.graphene_rect_t)(childBounds.Native())

	C.gtk_snapshot_push_repeat(arg0, arg1, arg2)
}

// PushRoundedClip clips an image to a rounded rectangle.
//
// The image is recorded until the next call to gtk_snapshot_pop().
func (snapshot snapshot) PushRoundedClip(bounds *gsk.RoundedRect) {
	var arg0 *C.GtkSnapshot
	var arg1 *C.GskRoundedRect

	arg0 = (*C.GtkSnapshot)(snapshot.Native())
	arg1 = (*C.GskRoundedRect)(bounds.Native())

	C.gtk_snapshot_push_rounded_clip(arg0, arg1)
}

// PushShadow applies a shadow to an image.
//
// The image is recorded until the next call to gtk_snapshot_pop().
func (snapshot snapshot) PushShadow(shadow *gsk.Shadow, nShadows uint) {
	var arg0 *C.GtkSnapshot
	var arg1 *C.GskShadow
	var arg2 C.gsize

	arg0 = (*C.GtkSnapshot)(snapshot.Native())
	arg1 = (*C.GskShadow)(shadow.Native())
	arg2 = C.gsize(nShadows)

	C.gtk_snapshot_push_shadow(arg0, arg1, arg2)
}

// RenderBackground creates a render node for the CSS background according
// to @context, and appends it to the current node of @snapshot, without
// changing the current node.
func (snapshot snapshot) RenderBackground(context StyleContext, x float64, y float64, width float64, height float64) {
	var arg0 *C.GtkSnapshot
	var arg1 *C.GtkStyleContext
	var arg2 C.double
	var arg3 C.double
	var arg4 C.double
	var arg5 C.double

	arg0 = (*C.GtkSnapshot)(snapshot.Native())
	arg1 = (*C.GtkStyleContext)(context.Native())
	arg2 = C.double(x)
	arg3 = C.double(y)
	arg4 = C.double(width)
	arg5 = C.double(height)

	C.gtk_snapshot_render_background(arg0, arg1, arg2, arg3, arg4, arg5)
}

// RenderFocus creates a render node for the focus outline according to
// @context, and appends it to the current node of @snapshot, without
// changing the current node.
func (snapshot snapshot) RenderFocus(context StyleContext, x float64, y float64, width float64, height float64) {
	var arg0 *C.GtkSnapshot
	var arg1 *C.GtkStyleContext
	var arg2 C.double
	var arg3 C.double
	var arg4 C.double
	var arg5 C.double

	arg0 = (*C.GtkSnapshot)(snapshot.Native())
	arg1 = (*C.GtkStyleContext)(context.Native())
	arg2 = C.double(x)
	arg3 = C.double(y)
	arg4 = C.double(width)
	arg5 = C.double(height)

	C.gtk_snapshot_render_focus(arg0, arg1, arg2, arg3, arg4, arg5)
}

// RenderFrame creates a render node for the CSS border according to
// @context, and appends it to the current node of @snapshot, without
// changing the current node.
func (snapshot snapshot) RenderFrame(context StyleContext, x float64, y float64, width float64, height float64) {
	var arg0 *C.GtkSnapshot
	var arg1 *C.GtkStyleContext
	var arg2 C.double
	var arg3 C.double
	var arg4 C.double
	var arg5 C.double

	arg0 = (*C.GtkSnapshot)(snapshot.Native())
	arg1 = (*C.GtkStyleContext)(context.Native())
	arg2 = C.double(x)
	arg3 = C.double(y)
	arg4 = C.double(width)
	arg5 = C.double(height)

	C.gtk_snapshot_render_frame(arg0, arg1, arg2, arg3, arg4, arg5)
}

// RenderInsertionCursor draws a text caret using @snapshot at the specified
// index of @layout.
func (snapshot snapshot) RenderInsertionCursor(context StyleContext, x float64, y float64, layout pango.Layout, index int, direction pango.Direction) {
	var arg0 *C.GtkSnapshot
	var arg1 *C.GtkStyleContext
	var arg2 C.double
	var arg3 C.double
	var arg4 *C.PangoLayout
	var arg5 C.int
	var arg6 C.PangoDirection

	arg0 = (*C.GtkSnapshot)(snapshot.Native())
	arg1 = (*C.GtkStyleContext)(context.Native())
	arg2 = C.double(x)
	arg3 = C.double(y)
	arg4 = (*C.PangoLayout)(layout.Native())
	arg5 = C.int(index)
	arg6 = (C.PangoDirection)(direction)

	C.gtk_snapshot_render_insertion_cursor(arg0, arg1, arg2, arg3, arg4, arg5, arg6)
}

// RenderLayout creates a render node for rendering @layout according to the
// style information in @context, and appends it to the current node of
// @snapshot, without changing the current node.
func (snapshot snapshot) RenderLayout(context StyleContext, x float64, y float64, layout pango.Layout) {
	var arg0 *C.GtkSnapshot
	var arg1 *C.GtkStyleContext
	var arg2 C.double
	var arg3 C.double
	var arg4 *C.PangoLayout

	arg0 = (*C.GtkSnapshot)(snapshot.Native())
	arg1 = (*C.GtkStyleContext)(context.Native())
	arg2 = C.double(x)
	arg3 = C.double(y)
	arg4 = (*C.PangoLayout)(layout.Native())

	C.gtk_snapshot_render_layout(arg0, arg1, arg2, arg3, arg4)
}

// Restore restores @snapshot to the state saved by a preceding call to
// gtk_snapshot_save() and removes that state from the stack of saved
// states.
func (snapshot snapshot) Restore() {
	var arg0 *C.GtkSnapshot

	arg0 = (*C.GtkSnapshot)(snapshot.Native())

	C.gtk_snapshot_restore(arg0)
}

// Rotate rotates @@snapshot's coordinate system by @angle degrees in 2D
// space - or in 3D speak, rotates around the z axis.
func (snapshot snapshot) Rotate(angle float32) {
	var arg0 *C.GtkSnapshot
	var arg1 C.float

	arg0 = (*C.GtkSnapshot)(snapshot.Native())
	arg1 = C.float(angle)

	C.gtk_snapshot_rotate(arg0, arg1)
}

// Rotate3D rotates @snapshot's coordinate system by @angle degrees around
// @axis.
//
// For a rotation in 2D space, use gsk_transform_rotate().
func (snapshot snapshot) Rotate3D(angle float32, axis *graphene.Vec3) {
	var arg0 *C.GtkSnapshot
	var arg1 C.float
	var arg2 *C.graphene_vec3_t

	arg0 = (*C.GtkSnapshot)(snapshot.Native())
	arg1 = C.float(angle)
	arg2 = (*C.graphene_vec3_t)(axis.Native())

	C.gtk_snapshot_rotate_3d(arg0, arg1, arg2)
}

// Save makes a copy of the current state of @snapshot and saves it on an
// internal stack of saved states for @snapshot. When gtk_snapshot_restore()
// is called, @snapshot will be restored to the saved state. Multiple calls
// to gtk_snapshot_save() and gtk_snapshot_restore() can be nested; each
// call to gtk_snapshot_restore() restores the state from the matching
// paired gtk_snapshot_save().
//
// It is necessary to clear all saved states with corresponding calls to
// gtk_snapshot_restore().
func (snapshot snapshot) Save() {
	var arg0 *C.GtkSnapshot

	arg0 = (*C.GtkSnapshot)(snapshot.Native())

	C.gtk_snapshot_save(arg0)
}

// Scale scales @snapshot's coordinate system in 2-dimensional space by the
// given factors.
//
// Use gtk_snapshot_scale_3d() to scale in all 3 dimensions.
func (snapshot snapshot) Scale(factorX float32, factorY float32) {
	var arg0 *C.GtkSnapshot
	var arg1 C.float
	var arg2 C.float

	arg0 = (*C.GtkSnapshot)(snapshot.Native())
	arg1 = C.float(factorX)
	arg2 = C.float(factorY)

	C.gtk_snapshot_scale(arg0, arg1, arg2)
}

// Scale3D scales @snapshot's coordinate system by the given factors.
func (snapshot snapshot) Scale3D(factorX float32, factorY float32, factorZ float32) {
	var arg0 *C.GtkSnapshot
	var arg1 C.float
	var arg2 C.float
	var arg3 C.float

	arg0 = (*C.GtkSnapshot)(snapshot.Native())
	arg1 = C.float(factorX)
	arg2 = C.float(factorY)
	arg3 = C.float(factorZ)

	C.gtk_snapshot_scale_3d(arg0, arg1, arg2, arg3)
}

// ToNode returns the render node that was constructed by @snapshot. After
// calling this function, it is no longer possible to add more nodes to
// @snapshot. The only function that should be called after this is
// g_object_unref().
func (snapshot snapshot) ToNode() gsk.RenderNode {
	var arg0 *C.GtkSnapshot

	arg0 = (*C.GtkSnapshot)(snapshot.Native())

	ret := C.gtk_snapshot_to_node(arg0)

	var ret0 gsk.RenderNode

	ret0 = gsk.WrapRenderNode(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// ToPaintable returns a paintable encapsulating the render node that was
// constructed by @snapshot. After calling this function, it is no longer
// possible to add more nodes to @snapshot. The only function that should be
// called after this is g_object_unref().
func (snapshot snapshot) ToPaintable(size *graphene.Size) gdk.Paintable {
	var arg0 *C.GtkSnapshot
	var arg1 *C.graphene_size_t

	arg0 = (*C.GtkSnapshot)(snapshot.Native())
	arg1 = (*C.graphene_size_t)(size.Native())

	ret := C.gtk_snapshot_to_paintable(arg0, arg1)

	var ret0 gdk.Paintable

	return ret0
}

// Transform transforms @snapshot's coordinate system with the given
// @transform.
func (snapshot snapshot) Transform(transform *gsk.Transform) {
	var arg0 *C.GtkSnapshot
	var arg1 *C.GskTransform

	arg0 = (*C.GtkSnapshot)(snapshot.Native())
	arg1 = (*C.GskTransform)(transform.Native())

	C.gtk_snapshot_transform(arg0, arg1)
}

// TransformMatrix transforms @snapshot's coordinate system with the given
// @matrix.
func (snapshot snapshot) TransformMatrix(matrix *graphene.Matrix) {
	var arg0 *C.GtkSnapshot
	var arg1 *C.graphene_matrix_t

	arg0 = (*C.GtkSnapshot)(snapshot.Native())
	arg1 = (*C.graphene_matrix_t)(matrix.Native())

	C.gtk_snapshot_transform_matrix(arg0, arg1)
}

// Translate translates @snapshot's coordinate system by @point in
// 2-dimensional space.
func (snapshot snapshot) Translate(point *graphene.Point) {
	var arg0 *C.GtkSnapshot
	var arg1 *C.graphene_point_t

	arg0 = (*C.GtkSnapshot)(snapshot.Native())
	arg1 = (*C.graphene_point_t)(point.Native())

	C.gtk_snapshot_translate(arg0, arg1)
}

// Translate3D translates @snapshot's coordinate system by @point.
func (snapshot snapshot) Translate3D(point *graphene.Point3D) {
	var arg0 *C.GtkSnapshot
	var arg1 *C.graphene_point3d_t

	arg0 = (*C.GtkSnapshot)(snapshot.Native())
	arg1 = (*C.graphene_point3d_t)(point.Native())

	C.gtk_snapshot_translate_3d(arg0, arg1)
}

// SortListModel is a list model that takes a list model and sorts its elements
// according to a Sorter.
//
// The model can be set up to do incremental sorting, so that sorting long lists
// doesn't block the UI. See gtk_sort_list_model_set_incremental() for details.
//
// SortListModel is a generic model and because of that it cannot take advantage
// of any external knowledge when sorting. If you run into performance issues
// with SortListModel, it is strongly recommended that you write your own
// sorting list model.
type SortListModel interface {
	gextras.Objector

	// Incremental returns whether incremental sorting was enabled via
	// gtk_sort_list_model_set_incremental().
	Incremental() bool
	// Model gets the model currently sorted or nil if none.
	Model() gio.ListModel
	// Pending estimates progress of an ongoing sorting operation
	//
	// The estimate is the number of items that would still need to be sorted to
	// finish the sorting operation if this was a linear algorithm. So this
	// number is not related to how many items are already correctly sorted.
	//
	// If you want to estimate the progress, you can use code like this:
	//
	//      pending = gtk_sort_list_model_get_pending (self);
	//      model = gtk_sort_list_model_get_model (self);
	//      progress = 1.0 - pending / (double) MAX (1, g_list_model_get_n_items (model));
	//
	//
	// If no sort operation is ongoing - in particular when
	// SortListModel:incremental is false - this function returns 0.
	Pending() uint
	// Sorter gets the sorter that is used to sort @self.
	Sorter() Sorter
	// SetIncremental sets the sort model to do an incremental sort.
	//
	// When incremental sorting is enabled, the sortlistmodel will not do a
	// complete sort immediately, but will instead queue an idle handler that
	// incrementally sorts the items towards their correct position. This of
	// course means that items do not instantly appear in the right place. It
	// also means that the total sorting time is a lot slower.
	//
	// When your filter blocks the UI while sorting, you might consider turning
	// this on. Depending on your model and sorters, this may become interesting
	// around 10,000 to 100,000 items.
	//
	// By default, incremental sorting is disabled.
	//
	// See gtk_sort_list_model_get_pending() for progress information about an
	// ongoing incremental sorting operation.
	SetIncremental(incremental bool)
	// SetModel sets the model to be sorted. The @model's item type must conform
	// to the item type of @self.
	SetModel(model gio.ListModel)
	// SetSorter sets a new sorter on @self.
	SetSorter(sorter Sorter)
}

type sortListModel struct {
	*externglib.Object
}

// WrapSortListModel wraps a GObject to the right type. It is
// primarily used internally.
func WrapSortListModel(obj *externglib.Object) SortListModel {
	return sortListModel{*externglib.Object{obj}}
}

func marshalSortListModel(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSortListModel(obj), nil
}

// NewSortListModel constructs a class SortListModel.
func NewSortListModel(model gio.ListModel, sorter Sorter) SortListModel {
	var arg1 *C.GListModel
	var arg2 *C.GtkSorter

	arg2 = (*C.GtkSorter)(sorter.Native())

	ret := C.gtk_sort_list_model_new(arg1, arg2)

	var ret0 SortListModel

	ret0 = WrapSortListModel(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Incremental returns whether incremental sorting was enabled via
// gtk_sort_list_model_set_incremental().
func (self sortListModel) Incremental() bool {
	var arg0 *C.GtkSortListModel

	arg0 = (*C.GtkSortListModel)(self.Native())

	ret := C.gtk_sort_list_model_get_incremental(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Model gets the model currently sorted or nil if none.
func (self sortListModel) Model() gio.ListModel {
	var arg0 *C.GtkSortListModel

	arg0 = (*C.GtkSortListModel)(self.Native())

	ret := C.gtk_sort_list_model_get_model(arg0)

	var ret0 gio.ListModel

	return ret0
}

// Pending estimates progress of an ongoing sorting operation
//
// The estimate is the number of items that would still need to be sorted to
// finish the sorting operation if this was a linear algorithm. So this
// number is not related to how many items are already correctly sorted.
//
// If you want to estimate the progress, you can use code like this:
//
//      pending = gtk_sort_list_model_get_pending (self);
//      model = gtk_sort_list_model_get_model (self);
//      progress = 1.0 - pending / (double) MAX (1, g_list_model_get_n_items (model));
//
//
// If no sort operation is ongoing - in particular when
// SortListModel:incremental is false - this function returns 0.
func (self sortListModel) Pending() uint {
	var arg0 *C.GtkSortListModel

	arg0 = (*C.GtkSortListModel)(self.Native())

	ret := C.gtk_sort_list_model_get_pending(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// Sorter gets the sorter that is used to sort @self.
func (self sortListModel) Sorter() Sorter {
	var arg0 *C.GtkSortListModel

	arg0 = (*C.GtkSortListModel)(self.Native())

	ret := C.gtk_sort_list_model_get_sorter(arg0)

	var ret0 Sorter

	ret0 = WrapSorter(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// SetIncremental sets the sort model to do an incremental sort.
//
// When incremental sorting is enabled, the sortlistmodel will not do a
// complete sort immediately, but will instead queue an idle handler that
// incrementally sorts the items towards their correct position. This of
// course means that items do not instantly appear in the right place. It
// also means that the total sorting time is a lot slower.
//
// When your filter blocks the UI while sorting, you might consider turning
// this on. Depending on your model and sorters, this may become interesting
// around 10,000 to 100,000 items.
//
// By default, incremental sorting is disabled.
//
// See gtk_sort_list_model_get_pending() for progress information about an
// ongoing incremental sorting operation.
func (self sortListModel) SetIncremental(incremental bool) {
	var arg0 *C.GtkSortListModel
	var arg1 C.gboolean

	arg0 = (*C.GtkSortListModel)(self.Native())
	arg1 = gextras.Cbool(incremental)

	C.gtk_sort_list_model_set_incremental(arg0, arg1)
}

// SetModel sets the model to be sorted. The @model's item type must conform
// to the item type of @self.
func (self sortListModel) SetModel(model gio.ListModel) {
	var arg0 *C.GtkSortListModel
	var arg1 *C.GListModel

	arg0 = (*C.GtkSortListModel)(self.Native())

	C.gtk_sort_list_model_set_model(arg0, arg1)
}

// SetSorter sets a new sorter on @self.
func (self sortListModel) SetSorter(sorter Sorter) {
	var arg0 *C.GtkSortListModel
	var arg1 *C.GtkSorter

	arg0 = (*C.GtkSortListModel)(self.Native())
	arg1 = (*C.GtkSorter)(sorter.Native())

	C.gtk_sort_list_model_set_sorter(arg0, arg1)
}

// Sorter is the way to describe sorting criteria. Its primary user is
// SortListModel.
//
// The model will use a sorter to determine the order in which its items should
// appear by calling gtk_sorter_compare() for pairs of items.
//
// Sorters may change their sorting behavior through their lifetime. In that
// case, they will emit the Sorter::changed signal to notify that the sort order
// is no longer valid and should be updated by calling gtk_sorter_compare()
// again.
//
// GTK provides various pre-made sorter implementations for common sorting
// operations. ColumnView has built-in support for sorting lists via the
// ColumnViewColumn:sorter property, where the user can change the sorting by
// clicking on list headers.
//
// Of course, in particular for large lists, it is also possible to subclass
// Sorter and provide one's own sorter.
type Sorter interface {
	gextras.Objector

	// Changed emits the Sorter::changed signal to notify all users of the
	// sorter that it has changed. Users of the sorter should then update the
	// sort order via gtk_sorter_compare().
	//
	// Depending on the @change parameter, it may be possible to update the sort
	// order without a full resorting. Refer to the SorterChange documentation
	// for details.
	//
	// This function is intended for implementors of Sorter subclasses and
	// should not be called from other functions.
	Changed(change SorterChange)
	// Compare compares two given items according to the sort order implemented
	// by the sorter.
	//
	// Sorters implement a partial order: * It is reflexive, ie a = a * It is
	// antisymmetric, ie if a < b and b < a, then a = b * It is transitive, ie
	// given any 3 items with a ≤ b and b ≤ c, then a ≤ c
	//
	// The sorter may signal it conforms to additional constraints via the
	// return value of gtk_sorter_get_order().
	Compare(item1 gextras.Objector, item2 gextras.Objector) Ordering
	// Order gets the order that @self conforms to. See SorterOrder for details
	// of the possible return values.
	//
	// This function is intended to allow optimizations.
	Order() SorterOrder
}

type sorter struct {
	*externglib.Object
}

// WrapSorter wraps a GObject to the right type. It is
// primarily used internally.
func WrapSorter(obj *externglib.Object) Sorter {
	return sorter{*externglib.Object{obj}}
}

func marshalSorter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSorter(obj), nil
}

// Changed emits the Sorter::changed signal to notify all users of the
// sorter that it has changed. Users of the sorter should then update the
// sort order via gtk_sorter_compare().
//
// Depending on the @change parameter, it may be possible to update the sort
// order without a full resorting. Refer to the SorterChange documentation
// for details.
//
// This function is intended for implementors of Sorter subclasses and
// should not be called from other functions.
func (self sorter) Changed(change SorterChange) {
	var arg0 *C.GtkSorter
	var arg1 C.GtkSorterChange

	arg0 = (*C.GtkSorter)(self.Native())
	arg1 = (C.GtkSorterChange)(change)

	C.gtk_sorter_changed(arg0, arg1)
}

// Compare compares two given items according to the sort order implemented
// by the sorter.
//
// Sorters implement a partial order: * It is reflexive, ie a = a * It is
// antisymmetric, ie if a < b and b < a, then a = b * It is transitive, ie
// given any 3 items with a ≤ b and b ≤ c, then a ≤ c
//
// The sorter may signal it conforms to additional constraints via the
// return value of gtk_sorter_get_order().
func (self sorter) Compare(item1 gextras.Objector, item2 gextras.Objector) Ordering {
	var arg0 *C.GtkSorter
	var arg1 C.gpointer
	var arg2 C.gpointer

	arg0 = (*C.GtkSorter)(self.Native())
	arg1 = (*C.GObject)(item1.Native())
	arg2 = (*C.GObject)(item2.Native())

	ret := C.gtk_sorter_compare(arg0, arg1, arg2)

	var ret0 Ordering

	ret0 = Ordering(ret)

	return ret0
}

// Order gets the order that @self conforms to. See SorterOrder for details
// of the possible return values.
//
// This function is intended to allow optimizations.
func (self sorter) Order() SorterOrder {
	var arg0 *C.GtkSorter

	arg0 = (*C.GtkSorter)(self.Native())

	ret := C.gtk_sorter_get_order(arg0)

	var ret0 SorterOrder

	ret0 = SorterOrder(ret)

	return ret0
}

// SpinButton: a SpinButton is an ideal way to allow the user to set the value
// of some attribute. Rather than having to directly type a number into a Entry,
// GtkSpinButton allows the user to click on one of two arrows to increment or
// decrement the displayed value. A value can still be typed in, with the bonus
// that it can be checked to ensure it is in a given range.
//
// The main properties of a GtkSpinButton are through an adjustment. See the
// Adjustment section for more details about an adjustment's properties.
//
// Note that GtkSpinButton will by default make its entry large enough to
// accommodate the lower and upper bounds of the adjustment. If this is not
// desired, the automatic sizing can be turned off by explicitly setting
// Editable::width-chars to a value != -1.
//
// Using a GtkSpinButton to get an integer
//
//    spinbutton.vertical
//    ├── button.up
//    ├── text
//    │    ├── undershoot.left
//    │    ╰── undershoot.right
//    ╰── button.down
//
//
// GtkSpinButtons main CSS node has the name spinbutton. It creates subnodes for
// the entry and the two buttons, with these names. The button nodes have the
// style classes .up and .down. The GtkText subnodes (if present) are put below
// the text node. The orientation of the spin button is reflected in the
// .vertical or .horizontal style class on the main node.
//
//
// Accessiblity
//
// GtkSpinButton uses the K_ACCESSIBLE_ROLE_SPIN_BUTTON role.
type SpinButton interface {
	Widget

	// Configure changes the properties of an existing spin button. The
	// adjustment, climb rate, and number of decimal places are updated
	// accordingly.
	Configure(adjustment Adjustment, climbRate float64, digits uint)
	// Adjustment: get the adjustment associated with a SpinButton
	Adjustment() Adjustment
	// ClimbRate returns the acceleration rate for repeated changes.
	ClimbRate() float64
	// Digits fetches the precision of @spin_button. See
	// gtk_spin_button_set_digits().
	Digits() uint
	// Increments gets the current step and page the increments used by
	// @spin_button. See gtk_spin_button_set_increments().
	Increments() (step float64, page float64)
	// Numeric returns whether non-numeric text can be typed into the spin
	// button. See gtk_spin_button_set_numeric().
	Numeric() bool
	// Range gets the range allowed for @spin_button. See
	// gtk_spin_button_set_range().
	Range() (min float64, max float64)
	// SnapToTicks returns whether the values are corrected to the nearest step.
	// See gtk_spin_button_set_snap_to_ticks().
	SnapToTicks() bool
	// UpdatePolicy gets the update behavior of a spin button. See
	// gtk_spin_button_set_update_policy().
	UpdatePolicy() SpinButtonUpdatePolicy
	// Value: get the value in the @spin_button.
	Value() float64
	// ValueAsInt: get the value @spin_button represented as an integer.
	ValueAsInt() int
	// Wrap returns whether the spin button’s value wraps around to the opposite
	// limit when the upper or lower limit of the range is exceeded. See
	// gtk_spin_button_set_wrap().
	Wrap() bool
	// SetAdjustment replaces the Adjustment associated with @spin_button.
	SetAdjustment(adjustment Adjustment)
	// SetClimbRate sets the acceleration rate for repeated changes when you
	// hold down a button or key.
	SetClimbRate(climbRate float64)
	// SetDigits: set the precision to be displayed by @spin_button. Up to 20
	// digit precision is allowed.
	SetDigits(digits uint)
	// SetIncrements sets the step and page increments for spin_button. This
	// affects how quickly the value changes when the spin button’s arrows are
	// activated.
	SetIncrements(step float64, page float64)
	// SetNumeric sets the flag that determines if non-numeric text can be typed
	// into the spin button.
	SetNumeric(numeric bool)
	// SetRange sets the minimum and maximum allowable values for @spin_button.
	//
	// If the current value is outside this range, it will be adjusted to fit
	// within the range, otherwise it will remain unchanged.
	SetRange(min float64, max float64)
	// SetSnapToTicks sets the policy as to whether values are corrected to the
	// nearest step increment when a spin button is activated after providing an
	// invalid value.
	SetSnapToTicks(snapToTicks bool)
	// SetUpdatePolicy sets the update behavior of a spin button. This
	// determines whether the spin button is always updated or only when a valid
	// value is set.
	SetUpdatePolicy(policy SpinButtonUpdatePolicy)
	// SetValue sets the value of @spin_button.
	SetValue(value float64)
	// SetWrap sets the flag that determines if a spin button value wraps around
	// to the opposite limit when the upper or lower limit of the range is
	// exceeded.
	SetWrap(wrap bool)
	// Spin: increment or decrement a spin button’s value in a specified
	// direction by a specified amount.
	Spin(direction SpinType, increment float64)
	// Update: manually force an update of the spin button.
	Update()
}

type spinButton struct {
	widget
}

// WrapSpinButton wraps a GObject to the right type. It is
// primarily used internally.
func WrapSpinButton(obj *externglib.Object) SpinButton {
	return spinButton{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}
}

func marshalSpinButton(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSpinButton(obj), nil
}

// NewSpinButton constructs a class SpinButton.
func NewSpinButton(adjustment Adjustment, climbRate float64, digits uint) SpinButton {
	var arg1 *C.GtkAdjustment
	var arg2 C.double
	var arg3 C.guint

	arg1 = (*C.GtkAdjustment)(adjustment.Native())
	arg2 = C.double(climbRate)
	arg3 = C.guint(digits)

	ret := C.gtk_spin_button_new(arg1, arg2, arg3)

	var ret0 SpinButton

	ret0 = WrapSpinButton(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewSpinButtonWithRange constructs a class SpinButton.
func NewSpinButtonWithRange(min float64, max float64, step float64) SpinButton {
	var arg1 C.double
	var arg2 C.double
	var arg3 C.double

	arg1 = C.double(min)
	arg2 = C.double(max)
	arg3 = C.double(step)

	ret := C.gtk_spin_button_new_with_range(arg1, arg2, arg3)

	var ret0 SpinButton

	ret0 = WrapSpinButton(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Configure changes the properties of an existing spin button. The
// adjustment, climb rate, and number of decimal places are updated
// accordingly.
func (spinButton spinButton) Configure(adjustment Adjustment, climbRate float64, digits uint) {
	var arg0 *C.GtkSpinButton
	var arg1 *C.GtkAdjustment
	var arg2 C.double
	var arg3 C.guint

	arg0 = (*C.GtkSpinButton)(spinButton.Native())
	arg1 = (*C.GtkAdjustment)(adjustment.Native())
	arg2 = C.double(climbRate)
	arg3 = C.guint(digits)

	C.gtk_spin_button_configure(arg0, arg1, arg2, arg3)
}

// Adjustment: get the adjustment associated with a SpinButton
func (spinButton spinButton) Adjustment() Adjustment {
	var arg0 *C.GtkSpinButton

	arg0 = (*C.GtkSpinButton)(spinButton.Native())

	ret := C.gtk_spin_button_get_adjustment(arg0)

	var ret0 Adjustment

	ret0 = WrapAdjustment(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// ClimbRate returns the acceleration rate for repeated changes.
func (spinButton spinButton) ClimbRate() float64 {
	var arg0 *C.GtkSpinButton

	arg0 = (*C.GtkSpinButton)(spinButton.Native())

	ret := C.gtk_spin_button_get_climb_rate(arg0)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// Digits fetches the precision of @spin_button. See
// gtk_spin_button_set_digits().
func (spinButton spinButton) Digits() uint {
	var arg0 *C.GtkSpinButton

	arg0 = (*C.GtkSpinButton)(spinButton.Native())

	ret := C.gtk_spin_button_get_digits(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// Increments gets the current step and page the increments used by
// @spin_button. See gtk_spin_button_set_increments().
func (spinButton spinButton) Increments() (step float64, page float64) {
	var arg0 *C.GtkSpinButton
	var arg1 *C.double // out
	var arg2 *C.double // out

	arg0 = (*C.GtkSpinButton)(spinButton.Native())

	ret := C.gtk_spin_button_get_increments(arg0, &arg1, &arg2)

	var ret0 float64
	var ret1 float64

	ret0 = float64(arg1)

	ret1 = float64(arg2)

	return ret0, ret1
}

// Numeric returns whether non-numeric text can be typed into the spin
// button. See gtk_spin_button_set_numeric().
func (spinButton spinButton) Numeric() bool {
	var arg0 *C.GtkSpinButton

	arg0 = (*C.GtkSpinButton)(spinButton.Native())

	ret := C.gtk_spin_button_get_numeric(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Range gets the range allowed for @spin_button. See
// gtk_spin_button_set_range().
func (spinButton spinButton) Range() (min float64, max float64) {
	var arg0 *C.GtkSpinButton
	var arg1 *C.double // out
	var arg2 *C.double // out

	arg0 = (*C.GtkSpinButton)(spinButton.Native())

	ret := C.gtk_spin_button_get_range(arg0, &arg1, &arg2)

	var ret0 float64
	var ret1 float64

	ret0 = float64(arg1)

	ret1 = float64(arg2)

	return ret0, ret1
}

// SnapToTicks returns whether the values are corrected to the nearest step.
// See gtk_spin_button_set_snap_to_ticks().
func (spinButton spinButton) SnapToTicks() bool {
	var arg0 *C.GtkSpinButton

	arg0 = (*C.GtkSpinButton)(spinButton.Native())

	ret := C.gtk_spin_button_get_snap_to_ticks(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// UpdatePolicy gets the update behavior of a spin button. See
// gtk_spin_button_set_update_policy().
func (spinButton spinButton) UpdatePolicy() SpinButtonUpdatePolicy {
	var arg0 *C.GtkSpinButton

	arg0 = (*C.GtkSpinButton)(spinButton.Native())

	ret := C.gtk_spin_button_get_update_policy(arg0)

	var ret0 SpinButtonUpdatePolicy

	ret0 = SpinButtonUpdatePolicy(ret)

	return ret0
}

// Value: get the value in the @spin_button.
func (spinButton spinButton) Value() float64 {
	var arg0 *C.GtkSpinButton

	arg0 = (*C.GtkSpinButton)(spinButton.Native())

	ret := C.gtk_spin_button_get_value(arg0)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// ValueAsInt: get the value @spin_button represented as an integer.
func (spinButton spinButton) ValueAsInt() int {
	var arg0 *C.GtkSpinButton

	arg0 = (*C.GtkSpinButton)(spinButton.Native())

	ret := C.gtk_spin_button_get_value_as_int(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Wrap returns whether the spin button’s value wraps around to the opposite
// limit when the upper or lower limit of the range is exceeded. See
// gtk_spin_button_set_wrap().
func (spinButton spinButton) Wrap() bool {
	var arg0 *C.GtkSpinButton

	arg0 = (*C.GtkSpinButton)(spinButton.Native())

	ret := C.gtk_spin_button_get_wrap(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// SetAdjustment replaces the Adjustment associated with @spin_button.
func (spinButton spinButton) SetAdjustment(adjustment Adjustment) {
	var arg0 *C.GtkSpinButton
	var arg1 *C.GtkAdjustment

	arg0 = (*C.GtkSpinButton)(spinButton.Native())
	arg1 = (*C.GtkAdjustment)(adjustment.Native())

	C.gtk_spin_button_set_adjustment(arg0, arg1)
}

// SetClimbRate sets the acceleration rate for repeated changes when you
// hold down a button or key.
func (spinButton spinButton) SetClimbRate(climbRate float64) {
	var arg0 *C.GtkSpinButton
	var arg1 C.double

	arg0 = (*C.GtkSpinButton)(spinButton.Native())
	arg1 = C.double(climbRate)

	C.gtk_spin_button_set_climb_rate(arg0, arg1)
}

// SetDigits: set the precision to be displayed by @spin_button. Up to 20
// digit precision is allowed.
func (spinButton spinButton) SetDigits(digits uint) {
	var arg0 *C.GtkSpinButton
	var arg1 C.guint

	arg0 = (*C.GtkSpinButton)(spinButton.Native())
	arg1 = C.guint(digits)

	C.gtk_spin_button_set_digits(arg0, arg1)
}

// SetIncrements sets the step and page increments for spin_button. This
// affects how quickly the value changes when the spin button’s arrows are
// activated.
func (spinButton spinButton) SetIncrements(step float64, page float64) {
	var arg0 *C.GtkSpinButton
	var arg1 C.double
	var arg2 C.double

	arg0 = (*C.GtkSpinButton)(spinButton.Native())
	arg1 = C.double(step)
	arg2 = C.double(page)

	C.gtk_spin_button_set_increments(arg0, arg1, arg2)
}

// SetNumeric sets the flag that determines if non-numeric text can be typed
// into the spin button.
func (spinButton spinButton) SetNumeric(numeric bool) {
	var arg0 *C.GtkSpinButton
	var arg1 C.gboolean

	arg0 = (*C.GtkSpinButton)(spinButton.Native())
	arg1 = gextras.Cbool(numeric)

	C.gtk_spin_button_set_numeric(arg0, arg1)
}

// SetRange sets the minimum and maximum allowable values for @spin_button.
//
// If the current value is outside this range, it will be adjusted to fit
// within the range, otherwise it will remain unchanged.
func (spinButton spinButton) SetRange(min float64, max float64) {
	var arg0 *C.GtkSpinButton
	var arg1 C.double
	var arg2 C.double

	arg0 = (*C.GtkSpinButton)(spinButton.Native())
	arg1 = C.double(min)
	arg2 = C.double(max)

	C.gtk_spin_button_set_range(arg0, arg1, arg2)
}

// SetSnapToTicks sets the policy as to whether values are corrected to the
// nearest step increment when a spin button is activated after providing an
// invalid value.
func (spinButton spinButton) SetSnapToTicks(snapToTicks bool) {
	var arg0 *C.GtkSpinButton
	var arg1 C.gboolean

	arg0 = (*C.GtkSpinButton)(spinButton.Native())
	arg1 = gextras.Cbool(snapToTicks)

	C.gtk_spin_button_set_snap_to_ticks(arg0, arg1)
}

// SetUpdatePolicy sets the update behavior of a spin button. This
// determines whether the spin button is always updated or only when a valid
// value is set.
func (spinButton spinButton) SetUpdatePolicy(policy SpinButtonUpdatePolicy) {
	var arg0 *C.GtkSpinButton
	var arg1 C.GtkSpinButtonUpdatePolicy

	arg0 = (*C.GtkSpinButton)(spinButton.Native())
	arg1 = (C.GtkSpinButtonUpdatePolicy)(policy)

	C.gtk_spin_button_set_update_policy(arg0, arg1)
}

// SetValue sets the value of @spin_button.
func (spinButton spinButton) SetValue(value float64) {
	var arg0 *C.GtkSpinButton
	var arg1 C.double

	arg0 = (*C.GtkSpinButton)(spinButton.Native())
	arg1 = C.double(value)

	C.gtk_spin_button_set_value(arg0, arg1)
}

// SetWrap sets the flag that determines if a spin button value wraps around
// to the opposite limit when the upper or lower limit of the range is
// exceeded.
func (spinButton spinButton) SetWrap(wrap bool) {
	var arg0 *C.GtkSpinButton
	var arg1 C.gboolean

	arg0 = (*C.GtkSpinButton)(spinButton.Native())
	arg1 = gextras.Cbool(wrap)

	C.gtk_spin_button_set_wrap(arg0, arg1)
}

// Spin: increment or decrement a spin button’s value in a specified
// direction by a specified amount.
func (spinButton spinButton) Spin(direction SpinType, increment float64) {
	var arg0 *C.GtkSpinButton
	var arg1 C.GtkSpinType
	var arg2 C.double

	arg0 = (*C.GtkSpinButton)(spinButton.Native())
	arg1 = (C.GtkSpinType)(direction)
	arg2 = C.double(increment)

	C.gtk_spin_button_spin(arg0, arg1, arg2)
}

// Update: manually force an update of the spin button.
func (spinButton spinButton) Update() {
	var arg0 *C.GtkSpinButton

	arg0 = (*C.GtkSpinButton)(spinButton.Native())

	C.gtk_spin_button_update(arg0)
}

// Spinner: a GtkSpinner widget displays an icon-size spinning animation. It is
// often used as an alternative to a ProgressBar for displaying indefinite
// activity, instead of actual progress.
//
// To start the animation, use gtk_spinner_start(), to stop it use
// gtk_spinner_stop().
//
//
// CSS nodes
//
// GtkSpinner has a single CSS node with the name spinner. When the animation is
// active, the :checked pseudoclass is added to this node.
type Spinner interface {
	Widget

	// Spinning returns whether the spinner is spinning.
	Spinning() bool
	// SetSpinning sets the activity of the spinner.
	SetSpinning(spinning bool)
	// Start starts the animation of the spinner.
	Start()
	// Stop stops the animation of the spinner.
	Stop()
}

type spinner struct {
	widget
}

// WrapSpinner wraps a GObject to the right type. It is
// primarily used internally.
func WrapSpinner(obj *externglib.Object) Spinner {
	return spinner{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}
}

func marshalSpinner(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSpinner(obj), nil
}

// NewSpinner constructs a class Spinner.
func NewSpinner() Spinner {

	ret := C.gtk_spinner_new()

	var ret0 Spinner

	ret0 = WrapSpinner(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Spinning returns whether the spinner is spinning.
func (spinner spinner) Spinning() bool {
	var arg0 *C.GtkSpinner

	arg0 = (*C.GtkSpinner)(spinner.Native())

	ret := C.gtk_spinner_get_spinning(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// SetSpinning sets the activity of the spinner.
func (spinner spinner) SetSpinning(spinning bool) {
	var arg0 *C.GtkSpinner
	var arg1 C.gboolean

	arg0 = (*C.GtkSpinner)(spinner.Native())
	arg1 = gextras.Cbool(spinning)

	C.gtk_spinner_set_spinning(arg0, arg1)
}

// Start starts the animation of the spinner.
func (spinner spinner) Start() {
	var arg0 *C.GtkSpinner

	arg0 = (*C.GtkSpinner)(spinner.Native())

	C.gtk_spinner_start(arg0)
}

// Stop stops the animation of the spinner.
func (spinner spinner) Stop() {
	var arg0 *C.GtkSpinner

	arg0 = (*C.GtkSpinner)(spinner.Native())

	C.gtk_spinner_stop(arg0)
}

// Stack: the GtkStack widget is a container which only shows one of its
// children at a time. In contrast to GtkNotebook, GtkStack does not provide a
// means for users to change the visible child. Instead, the StackSwitcher
// widget can be used with GtkStack to provide this functionality.
//
// Transitions between pages can be animated as slides or fades. This can be
// controlled with gtk_stack_set_transition_type(). These animations respect the
// Settings:gtk-enable-animations setting.
//
// GtkStack maintains a StackPage object for each added child, which holds
// additional per-child properties. You obtain the StackPage for a child with
// gtk_stack_get_page().
//
//
// GtkStack as GtkBuildable
//
// To set child-specific properties in a .ui file, create GtkStackPage objects
// explicitly, and set the child widget as a property on it:
//
//
//      <object class="GtkStack" id="stack">
//        <child>
//          <object class="GtkStackPage">
//            <property name="name">page1</property>
//            <property name="title">In the beginning…</property>
//            <property name="child">
//              <object class="GtkLabel">
//                <property name="label">It was dark</property>
//              </object>
//            </property>
//          </object>
//        </child>
//
//
//
// CSS nodes
//
// GtkStack has a single CSS node named stack.
//
//
// Accessibility
//
// GtkStack uses the K_ACCESSIBLE_ROLE_TAB_PANEL for the stack pages, which are
// the accessible parent objects of the child widgets.
type Stack interface {
	Widget

	// AddChild adds a child to @stack.
	AddChild(child Widget) StackPage
	// AddNamed adds a child to @stack. The child is identified by the @name.
	AddNamed(child Widget, name string) StackPage
	// AddTitled adds a child to @stack. The child is identified by the @name.
	// The @title will be used by StackSwitcher to represent @child in a tab
	// bar, so it should be short.
	AddTitled(child Widget, name string, title string) StackPage
	// ChildByName finds the child of the Stack with the name given as the
	// argument. Returns nil if there is no child with this name.
	ChildByName(name string) Widget
	// Hhomogeneous gets whether @stack is horizontally homogeneous. See
	// gtk_stack_set_hhomogeneous().
	Hhomogeneous() bool
	// InterpolateSize returns whether the Stack is set up to interpolate
	// between the sizes of children on page switch.
	InterpolateSize() bool
	// Page returns the StackPage object for @child.
	Page(child Widget) StackPage
	// Pages returns a Model that contains the pages of the stack, and can be
	// used to keep an up-to-date view. The model also implements SelectionModel
	// and can be used to track and modify the visible page.
	Pages() SelectionModel
	// TransitionDuration returns the amount of time (in milliseconds) that
	// transitions between pages in @stack will take.
	TransitionDuration() uint
	// TransitionRunning returns whether the @stack is currently in a transition
	// from one page to another.
	TransitionRunning() bool
	// TransitionType gets the type of animation that will be used for
	// transitions between pages in @stack.
	TransitionType() StackTransitionType
	// Vhomogeneous gets whether @stack is vertically homogeneous. See
	// gtk_stack_set_vhomogeneous().
	Vhomogeneous() bool
	// VisibleChild gets the currently visible child of @stack, or nil if there
	// are no visible children.
	VisibleChild() Widget
	// VisibleChildName returns the name of the currently visible child of
	// @stack, or nil if there is no visible child.
	VisibleChildName() string
	// Remove removes a child widget from @stack.
	Remove(child Widget)
	// SetHhomogeneous sets the Stack to be horizontally homogeneous or not. If
	// it is homogeneous, the Stack will request the same width for all its
	// children. If it isn't, the stack may change width when a different child
	// becomes visible.
	SetHhomogeneous(hhomogeneous bool)
	// SetInterpolateSize sets whether or not @stack will interpolate its size
	// when changing the visible child. If the Stack:interpolate-size property
	// is set to true, @stack will interpolate its size between the current one
	// and the one it'll take after changing the visible child, according to the
	// set transition duration.
	SetInterpolateSize(interpolateSize bool)
	// SetTransitionDuration sets the duration that transitions between pages in
	// @stack will take.
	SetTransitionDuration(duration uint)
	// SetTransitionType sets the type of animation that will be used for
	// transitions between pages in @stack. Available types include various
	// kinds of fades and slides.
	//
	// The transition type can be changed without problems at runtime, so it is
	// possible to change the animation based on the page that is about to
	// become current.
	SetTransitionType(transition StackTransitionType)
	// SetVhomogeneous sets the Stack to be vertically homogeneous or not. If it
	// is homogeneous, the Stack will request the same height for all its
	// children. If it isn't, the stack may change height when a different child
	// becomes visible.
	SetVhomogeneous(vhomogeneous bool)
	// SetVisibleChild makes @child the visible child of @stack.
	//
	// If @child is different from the currently visible child, the transition
	// between the two will be animated with the current transition type of
	// @stack.
	//
	// Note that the @child widget has to be visible itself (see
	// gtk_widget_show()) in order to become the visible child of @stack.
	SetVisibleChild(child Widget)
	// SetVisibleChildFull makes the child with the given name visible.
	//
	// Note that the child widget has to be visible itself (see
	// gtk_widget_show()) in order to become the visible child of @stack.
	SetVisibleChildFull(name string, transition StackTransitionType)
	// SetVisibleChildName makes the child with the given name visible.
	//
	// If @child is different from the currently visible child, the transition
	// between the two will be animated with the current transition type of
	// @stack.
	//
	// Note that the child widget has to be visible itself (see
	// gtk_widget_show()) in order to become the visible child of @stack.
	SetVisibleChildName(name string)
}

type stack struct {
	widget
}

// WrapStack wraps a GObject to the right type. It is
// primarily used internally.
func WrapStack(obj *externglib.Object) Stack {
	return stack{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}
}

func marshalStack(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapStack(obj), nil
}

// NewStack constructs a class Stack.
func NewStack() Stack {

	ret := C.gtk_stack_new()

	var ret0 Stack

	ret0 = WrapStack(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// AddChild adds a child to @stack.
func (stack stack) AddChild(child Widget) StackPage {
	var arg0 *C.GtkStack
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkStack)(stack.Native())
	arg1 = (*C.GtkWidget)(child.Native())

	ret := C.gtk_stack_add_child(arg0, arg1)

	var ret0 StackPage

	ret0 = WrapStackPage(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// AddNamed adds a child to @stack. The child is identified by the @name.
func (stack stack) AddNamed(child Widget, name string) StackPage {
	var arg0 *C.GtkStack
	var arg1 *C.GtkWidget
	var arg2 *C.char

	arg0 = (*C.GtkStack)(stack.Native())
	arg1 = (*C.GtkWidget)(child.Native())
	arg2 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.gtk_stack_add_named(arg0, arg1, arg2)

	var ret0 StackPage

	ret0 = WrapStackPage(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// AddTitled adds a child to @stack. The child is identified by the @name.
// The @title will be used by StackSwitcher to represent @child in a tab
// bar, so it should be short.
func (stack stack) AddTitled(child Widget, name string, title string) StackPage {
	var arg0 *C.GtkStack
	var arg1 *C.GtkWidget
	var arg2 *C.char
	var arg3 *C.char

	arg0 = (*C.GtkStack)(stack.Native())
	arg1 = (*C.GtkWidget)(child.Native())
	arg2 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gchar)(C.CString(title))
	defer C.free(unsafe.Pointer(arg3))

	ret := C.gtk_stack_add_titled(arg0, arg1, arg2, arg3)

	var ret0 StackPage

	ret0 = WrapStackPage(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// ChildByName finds the child of the Stack with the name given as the
// argument. Returns nil if there is no child with this name.
func (stack stack) ChildByName(name string) Widget {
	var arg0 *C.GtkStack
	var arg1 *C.char

	arg0 = (*C.GtkStack)(stack.Native())
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_stack_get_child_by_name(arg0, arg1)

	var ret0 Widget

	ret0 = WrapWidget(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Hhomogeneous gets whether @stack is horizontally homogeneous. See
// gtk_stack_set_hhomogeneous().
func (stack stack) Hhomogeneous() bool {
	var arg0 *C.GtkStack

	arg0 = (*C.GtkStack)(stack.Native())

	ret := C.gtk_stack_get_hhomogeneous(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// InterpolateSize returns whether the Stack is set up to interpolate
// between the sizes of children on page switch.
func (stack stack) InterpolateSize() bool {
	var arg0 *C.GtkStack

	arg0 = (*C.GtkStack)(stack.Native())

	ret := C.gtk_stack_get_interpolate_size(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Page returns the StackPage object for @child.
func (stack stack) Page(child Widget) StackPage {
	var arg0 *C.GtkStack
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkStack)(stack.Native())
	arg1 = (*C.GtkWidget)(child.Native())

	ret := C.gtk_stack_get_page(arg0, arg1)

	var ret0 StackPage

	ret0 = WrapStackPage(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Pages returns a Model that contains the pages of the stack, and can be
// used to keep an up-to-date view. The model also implements SelectionModel
// and can be used to track and modify the visible page.
func (stack stack) Pages() SelectionModel {
	var arg0 *C.GtkStack

	arg0 = (*C.GtkStack)(stack.Native())

	ret := C.gtk_stack_get_pages(arg0)

	var ret0 SelectionModel

	return ret0
}

// TransitionDuration returns the amount of time (in milliseconds) that
// transitions between pages in @stack will take.
func (stack stack) TransitionDuration() uint {
	var arg0 *C.GtkStack

	arg0 = (*C.GtkStack)(stack.Native())

	ret := C.gtk_stack_get_transition_duration(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// TransitionRunning returns whether the @stack is currently in a transition
// from one page to another.
func (stack stack) TransitionRunning() bool {
	var arg0 *C.GtkStack

	arg0 = (*C.GtkStack)(stack.Native())

	ret := C.gtk_stack_get_transition_running(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// TransitionType gets the type of animation that will be used for
// transitions between pages in @stack.
func (stack stack) TransitionType() StackTransitionType {
	var arg0 *C.GtkStack

	arg0 = (*C.GtkStack)(stack.Native())

	ret := C.gtk_stack_get_transition_type(arg0)

	var ret0 StackTransitionType

	ret0 = StackTransitionType(ret)

	return ret0
}

// Vhomogeneous gets whether @stack is vertically homogeneous. See
// gtk_stack_set_vhomogeneous().
func (stack stack) Vhomogeneous() bool {
	var arg0 *C.GtkStack

	arg0 = (*C.GtkStack)(stack.Native())

	ret := C.gtk_stack_get_vhomogeneous(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// VisibleChild gets the currently visible child of @stack, or nil if there
// are no visible children.
func (stack stack) VisibleChild() Widget {
	var arg0 *C.GtkStack

	arg0 = (*C.GtkStack)(stack.Native())

	ret := C.gtk_stack_get_visible_child(arg0)

	var ret0 Widget

	ret0 = WrapWidget(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// VisibleChildName returns the name of the currently visible child of
// @stack, or nil if there is no visible child.
func (stack stack) VisibleChildName() string {
	var arg0 *C.GtkStack

	arg0 = (*C.GtkStack)(stack.Native())

	ret := C.gtk_stack_get_visible_child_name(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Remove removes a child widget from @stack.
func (stack stack) Remove(child Widget) {
	var arg0 *C.GtkStack
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkStack)(stack.Native())
	arg1 = (*C.GtkWidget)(child.Native())

	C.gtk_stack_remove(arg0, arg1)
}

// SetHhomogeneous sets the Stack to be horizontally homogeneous or not. If
// it is homogeneous, the Stack will request the same width for all its
// children. If it isn't, the stack may change width when a different child
// becomes visible.
func (stack stack) SetHhomogeneous(hhomogeneous bool) {
	var arg0 *C.GtkStack
	var arg1 C.gboolean

	arg0 = (*C.GtkStack)(stack.Native())
	arg1 = gextras.Cbool(hhomogeneous)

	C.gtk_stack_set_hhomogeneous(arg0, arg1)
}

// SetInterpolateSize sets whether or not @stack will interpolate its size
// when changing the visible child. If the Stack:interpolate-size property
// is set to true, @stack will interpolate its size between the current one
// and the one it'll take after changing the visible child, according to the
// set transition duration.
func (stack stack) SetInterpolateSize(interpolateSize bool) {
	var arg0 *C.GtkStack
	var arg1 C.gboolean

	arg0 = (*C.GtkStack)(stack.Native())
	arg1 = gextras.Cbool(interpolateSize)

	C.gtk_stack_set_interpolate_size(arg0, arg1)
}

// SetTransitionDuration sets the duration that transitions between pages in
// @stack will take.
func (stack stack) SetTransitionDuration(duration uint) {
	var arg0 *C.GtkStack
	var arg1 C.guint

	arg0 = (*C.GtkStack)(stack.Native())
	arg1 = C.guint(duration)

	C.gtk_stack_set_transition_duration(arg0, arg1)
}

// SetTransitionType sets the type of animation that will be used for
// transitions between pages in @stack. Available types include various
// kinds of fades and slides.
//
// The transition type can be changed without problems at runtime, so it is
// possible to change the animation based on the page that is about to
// become current.
func (stack stack) SetTransitionType(transition StackTransitionType) {
	var arg0 *C.GtkStack
	var arg1 C.GtkStackTransitionType

	arg0 = (*C.GtkStack)(stack.Native())
	arg1 = (C.GtkStackTransitionType)(transition)

	C.gtk_stack_set_transition_type(arg0, arg1)
}

// SetVhomogeneous sets the Stack to be vertically homogeneous or not. If it
// is homogeneous, the Stack will request the same height for all its
// children. If it isn't, the stack may change height when a different child
// becomes visible.
func (stack stack) SetVhomogeneous(vhomogeneous bool) {
	var arg0 *C.GtkStack
	var arg1 C.gboolean

	arg0 = (*C.GtkStack)(stack.Native())
	arg1 = gextras.Cbool(vhomogeneous)

	C.gtk_stack_set_vhomogeneous(arg0, arg1)
}

// SetVisibleChild makes @child the visible child of @stack.
//
// If @child is different from the currently visible child, the transition
// between the two will be animated with the current transition type of
// @stack.
//
// Note that the @child widget has to be visible itself (see
// gtk_widget_show()) in order to become the visible child of @stack.
func (stack stack) SetVisibleChild(child Widget) {
	var arg0 *C.GtkStack
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkStack)(stack.Native())
	arg1 = (*C.GtkWidget)(child.Native())

	C.gtk_stack_set_visible_child(arg0, arg1)
}

// SetVisibleChildFull makes the child with the given name visible.
//
// Note that the child widget has to be visible itself (see
// gtk_widget_show()) in order to become the visible child of @stack.
func (stack stack) SetVisibleChildFull(name string, transition StackTransitionType) {
	var arg0 *C.GtkStack
	var arg1 *C.char
	var arg2 C.GtkStackTransitionType

	arg0 = (*C.GtkStack)(stack.Native())
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (C.GtkStackTransitionType)(transition)

	C.gtk_stack_set_visible_child_full(arg0, arg1, arg2)
}

// SetVisibleChildName makes the child with the given name visible.
//
// If @child is different from the currently visible child, the transition
// between the two will be animated with the current transition type of
// @stack.
//
// Note that the child widget has to be visible itself (see
// gtk_widget_show()) in order to become the visible child of @stack.
func (stack stack) SetVisibleChildName(name string) {
	var arg0 *C.GtkStack
	var arg1 *C.char

	arg0 = (*C.GtkStack)(stack.Native())
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_stack_set_visible_child_name(arg0, arg1)
}

type StackPage interface {
	gextras.Objector

	// Child returns the stack child to which @self belongs.
	Child() Widget
	// IconName returns the current value of the StackPage:icon-name property.
	IconName() string
	// Name returns the current value of the StackPage:name property.
	Name() string
	// NeedsAttention returns the current value of the StackPage:needs-attention
	// property.
	NeedsAttention() bool
	// Title returns the current value of the StackPage:title property.
	Title() string
	// UseUnderline returns the current value of the StackPage:use-underline
	// property.
	UseUnderline() bool
	// Visible returns whether @page is visible in its Stack. This is
	// independent from the Widget:visible value of its Widget.
	Visible() bool
	// SetIconName sets the new value of the StackPage:icon-name property. See
	// also gtk_stack_page_get_icon_name()
	SetIconName(setting string)
	// SetName sets the new value of the StackPage:name property. See also
	// gtk_stack_page_get_name()
	SetName(setting string)
	// SetNeedsAttention sets the new value of the StackPage:needs-attention
	// property. See also gtk_stack_page_get_needs_attention()
	SetNeedsAttention(setting bool)
	// SetTitle sets the new value of the StackPage:title property. See also
	// gtk_stack_page_get_title()
	SetTitle(setting string)
	// SetUseUnderline sets the new value of the StackPage:use-underline
	// property. See also gtk_stack_page_get_use_underline()
	SetUseUnderline(setting bool)
	// SetVisible sets the new value of the StackPage:visible property to
	// @visible.
	SetVisible(visible bool)
}

type stackPage struct {
	*externglib.Object
}

// WrapStackPage wraps a GObject to the right type. It is
// primarily used internally.
func WrapStackPage(obj *externglib.Object) StackPage {
	return stackPage{*externglib.Object{obj}}
}

func marshalStackPage(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapStackPage(obj), nil
}

// Child returns the stack child to which @self belongs.
func (self stackPage) Child() Widget {
	var arg0 *C.GtkStackPage

	arg0 = (*C.GtkStackPage)(self.Native())

	ret := C.gtk_stack_page_get_child(arg0)

	var ret0 Widget

	ret0 = WrapWidget(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// IconName returns the current value of the StackPage:icon-name property.
func (self stackPage) IconName() string {
	var arg0 *C.GtkStackPage

	arg0 = (*C.GtkStackPage)(self.Native())

	ret := C.gtk_stack_page_get_icon_name(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Name returns the current value of the StackPage:name property.
func (self stackPage) Name() string {
	var arg0 *C.GtkStackPage

	arg0 = (*C.GtkStackPage)(self.Native())

	ret := C.gtk_stack_page_get_name(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// NeedsAttention returns the current value of the StackPage:needs-attention
// property.
func (self stackPage) NeedsAttention() bool {
	var arg0 *C.GtkStackPage

	arg0 = (*C.GtkStackPage)(self.Native())

	ret := C.gtk_stack_page_get_needs_attention(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Title returns the current value of the StackPage:title property.
func (self stackPage) Title() string {
	var arg0 *C.GtkStackPage

	arg0 = (*C.GtkStackPage)(self.Native())

	ret := C.gtk_stack_page_get_title(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// UseUnderline returns the current value of the StackPage:use-underline
// property.
func (self stackPage) UseUnderline() bool {
	var arg0 *C.GtkStackPage

	arg0 = (*C.GtkStackPage)(self.Native())

	ret := C.gtk_stack_page_get_use_underline(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Visible returns whether @page is visible in its Stack. This is
// independent from the Widget:visible value of its Widget.
func (self stackPage) Visible() bool {
	var arg0 *C.GtkStackPage

	arg0 = (*C.GtkStackPage)(self.Native())

	ret := C.gtk_stack_page_get_visible(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// SetIconName sets the new value of the StackPage:icon-name property. See
// also gtk_stack_page_get_icon_name()
func (self stackPage) SetIconName(setting string) {
	var arg0 *C.GtkStackPage
	var arg1 *C.char

	arg0 = (*C.GtkStackPage)(self.Native())
	arg1 = (*C.gchar)(C.CString(setting))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_stack_page_set_icon_name(arg0, arg1)
}

// SetName sets the new value of the StackPage:name property. See also
// gtk_stack_page_get_name()
func (self stackPage) SetName(setting string) {
	var arg0 *C.GtkStackPage
	var arg1 *C.char

	arg0 = (*C.GtkStackPage)(self.Native())
	arg1 = (*C.gchar)(C.CString(setting))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_stack_page_set_name(arg0, arg1)
}

// SetNeedsAttention sets the new value of the StackPage:needs-attention
// property. See also gtk_stack_page_get_needs_attention()
func (self stackPage) SetNeedsAttention(setting bool) {
	var arg0 *C.GtkStackPage
	var arg1 C.gboolean

	arg0 = (*C.GtkStackPage)(self.Native())
	arg1 = gextras.Cbool(setting)

	C.gtk_stack_page_set_needs_attention(arg0, arg1)
}

// SetTitle sets the new value of the StackPage:title property. See also
// gtk_stack_page_get_title()
func (self stackPage) SetTitle(setting string) {
	var arg0 *C.GtkStackPage
	var arg1 *C.char

	arg0 = (*C.GtkStackPage)(self.Native())
	arg1 = (*C.gchar)(C.CString(setting))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_stack_page_set_title(arg0, arg1)
}

// SetUseUnderline sets the new value of the StackPage:use-underline
// property. See also gtk_stack_page_get_use_underline()
func (self stackPage) SetUseUnderline(setting bool) {
	var arg0 *C.GtkStackPage
	var arg1 C.gboolean

	arg0 = (*C.GtkStackPage)(self.Native())
	arg1 = gextras.Cbool(setting)

	C.gtk_stack_page_set_use_underline(arg0, arg1)
}

// SetVisible sets the new value of the StackPage:visible property to
// @visible.
func (self stackPage) SetVisible(visible bool) {
	var arg0 *C.GtkStackPage
	var arg1 C.gboolean

	arg0 = (*C.GtkStackPage)(self.Native())
	arg1 = gextras.Cbool(visible)

	C.gtk_stack_page_set_visible(arg0, arg1)
}

// StackSidebar: a GtkStackSidebar enables you to quickly and easily provide a
// consistent "sidebar" object for your user interface.
//
// In order to use a GtkStackSidebar, you simply use a GtkStack to organize your
// UI flow, and add the sidebar to your sidebar area. You can use
// gtk_stack_sidebar_set_stack() to connect the StackSidebar to the Stack.
//
//
// CSS nodes
//
// GtkStackSidebar has a single CSS node with name stacksidebar and style class
// .sidebar.
//
// When circumstances require it, GtkStackSidebar adds the .needs-attention
// style class to the widgets representing the stack pages.
type StackSidebar interface {
	Widget

	// Stack retrieves the stack. See gtk_stack_sidebar_set_stack().
	Stack() Stack
	// SetStack: set the Stack associated with this StackSidebar.
	//
	// The sidebar widget will automatically update according to the order
	// (packing) and items within the given Stack.
	SetStack(stack Stack)
}

type stackSidebar struct {
	widget
}

// WrapStackSidebar wraps a GObject to the right type. It is
// primarily used internally.
func WrapStackSidebar(obj *externglib.Object) StackSidebar {
	return stackSidebar{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}
}

func marshalStackSidebar(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapStackSidebar(obj), nil
}

// NewStackSidebar constructs a class StackSidebar.
func NewStackSidebar() StackSidebar {

	ret := C.gtk_stack_sidebar_new()

	var ret0 StackSidebar

	ret0 = WrapStackSidebar(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Stack retrieves the stack. See gtk_stack_sidebar_set_stack().
func (self stackSidebar) Stack() Stack {
	var arg0 *C.GtkStackSidebar

	arg0 = (*C.GtkStackSidebar)(self.Native())

	ret := C.gtk_stack_sidebar_get_stack(arg0)

	var ret0 Stack

	ret0 = WrapStack(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// SetStack: set the Stack associated with this StackSidebar.
//
// The sidebar widget will automatically update according to the order
// (packing) and items within the given Stack.
func (self stackSidebar) SetStack(stack Stack) {
	var arg0 *C.GtkStackSidebar
	var arg1 *C.GtkStack

	arg0 = (*C.GtkStackSidebar)(self.Native())
	arg1 = (*C.GtkStack)(stack.Native())

	C.gtk_stack_sidebar_set_stack(arg0, arg1)
}

// StackSwitcher: the GtkStackSwitcher widget acts as a controller for a Stack;
// it shows a row of buttons to switch between the various pages of the
// associated stack widget.
//
// All the content for the buttons comes from the child properties of the Stack;
// the button visibility in a StackSwitcher widget is controlled by the
// visibility of the child in the Stack.
//
// It is possible to associate multiple StackSwitcher widgets with the same
// Stack widget.
//
//
// CSS nodes
//
// GtkStackSwitcher has a single CSS node named stackswitcher and style class
// .stack-switcher.
//
// When circumstances require it, GtkStackSwitcher adds the .needs-attention
// style class to the widgets representing the stack pages.
//
//
// Accessibility
//
// GtkStackSwitcher uses the K_ACCESSIBLE_ROLE_TAB_LIST role and uses the
// K_ACCESSIBLE_ROLE_TAB for its buttons.
type StackSwitcher interface {
	Widget

	// Stack retrieves the stack. See gtk_stack_switcher_set_stack().
	Stack() Stack
	// SetStack sets the stack to control.
	SetStack(stack Stack)
}

type stackSwitcher struct {
	widget
}

// WrapStackSwitcher wraps a GObject to the right type. It is
// primarily used internally.
func WrapStackSwitcher(obj *externglib.Object) StackSwitcher {
	return stackSwitcher{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}
}

func marshalStackSwitcher(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapStackSwitcher(obj), nil
}

// NewStackSwitcher constructs a class StackSwitcher.
func NewStackSwitcher() StackSwitcher {

	ret := C.gtk_stack_switcher_new()

	var ret0 StackSwitcher

	ret0 = WrapStackSwitcher(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Stack retrieves the stack. See gtk_stack_switcher_set_stack().
func (switcher stackSwitcher) Stack() Stack {
	var arg0 *C.GtkStackSwitcher

	arg0 = (*C.GtkStackSwitcher)(switcher.Native())

	ret := C.gtk_stack_switcher_get_stack(arg0)

	var ret0 Stack

	ret0 = WrapStack(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// SetStack sets the stack to control.
func (switcher stackSwitcher) SetStack(stack Stack) {
	var arg0 *C.GtkStackSwitcher
	var arg1 *C.GtkStack

	arg0 = (*C.GtkStackSwitcher)(switcher.Native())
	arg1 = (*C.GtkStack)(stack.Native())

	C.gtk_stack_switcher_set_stack(arg0, arg1)
}

// Statusbar: a Statusbar is usually placed along the bottom of an application's
// main Window. It may provide a regular commentary of the application's status
// (as is usually the case in a web browser, for example), or may be used to
// simply output a message when the status changes, (when an upload is complete
// in an FTP client, for example).
//
// Status bars in GTK+ maintain a stack of messages. The message at the top of
// the each bar’s stack is the one that will currently be displayed.
//
// Any messages added to a statusbar’s stack must specify a context id that is
// used to uniquely identify the source of a message. This context id can be
// generated by gtk_statusbar_get_context_id(), given a message and the
// statusbar that it will be added to. Note that messages are stored in a stack,
// and when choosing which message to display, the stack structure is adhered
// to, regardless of the context identifier of a message.
//
// One could say that a statusbar maintains one stack of messages for display
// purposes, but allows multiple message producers to maintain sub-stacks of the
// messages they produced (via context ids).
//
// Status bars are created using gtk_statusbar_new().
//
// Messages are added to the bar’s stack with gtk_statusbar_push().
//
// The message at the top of the stack can be removed using gtk_statusbar_pop().
// A message can be removed from anywhere in the stack if its message id was
// recorded at the time it was added. This is done using gtk_statusbar_remove().
//
//
// CSS node
//
// GtkStatusbar has a single CSS node with name statusbar.
type Statusbar interface {
	Widget

	// ContextID returns a new context identifier, given a description of the
	// actual context. Note that the description is not shown in the UI.
	ContextID(contextDescription string) uint
	// Pop removes the first message in the Statusbar’s stack with the given
	// context id.
	//
	// Note that this may not change the displayed message, if the message at
	// the top of the stack has a different context id.
	Pop(contextID uint)
	// Push pushes a new message onto a statusbar’s stack.
	Push(contextID uint, text string) uint
	// Remove forces the removal of a message from a statusbar’s stack. The
	// exact @context_id and @message_id must be specified.
	Remove(contextID uint, messageID uint)
	// RemoveAll forces the removal of all messages from a statusbar's stack
	// with the exact @context_id.
	RemoveAll(contextID uint)
}

type statusbar struct {
	widget
}

// WrapStatusbar wraps a GObject to the right type. It is
// primarily used internally.
func WrapStatusbar(obj *externglib.Object) Statusbar {
	return statusbar{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}
}

func marshalStatusbar(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapStatusbar(obj), nil
}

// NewStatusbar constructs a class Statusbar.
func NewStatusbar() Statusbar {

	ret := C.gtk_statusbar_new()

	var ret0 Statusbar

	ret0 = WrapStatusbar(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// ContextID returns a new context identifier, given a description of the
// actual context. Note that the description is not shown in the UI.
func (statusbar statusbar) ContextID(contextDescription string) uint {
	var arg0 *C.GtkStatusbar
	var arg1 *C.char

	arg0 = (*C.GtkStatusbar)(statusbar.Native())
	arg1 = (*C.gchar)(C.CString(contextDescription))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_statusbar_get_context_id(arg0, arg1)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// Pop removes the first message in the Statusbar’s stack with the given
// context id.
//
// Note that this may not change the displayed message, if the message at
// the top of the stack has a different context id.
func (statusbar statusbar) Pop(contextID uint) {
	var arg0 *C.GtkStatusbar
	var arg1 C.guint

	arg0 = (*C.GtkStatusbar)(statusbar.Native())
	arg1 = C.guint(contextID)

	C.gtk_statusbar_pop(arg0, arg1)
}

// Push pushes a new message onto a statusbar’s stack.
func (statusbar statusbar) Push(contextID uint, text string) uint {
	var arg0 *C.GtkStatusbar
	var arg1 C.guint
	var arg2 *C.char

	arg0 = (*C.GtkStatusbar)(statusbar.Native())
	arg1 = C.guint(contextID)
	arg2 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.gtk_statusbar_push(arg0, arg1, arg2)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// Remove forces the removal of a message from a statusbar’s stack. The
// exact @context_id and @message_id must be specified.
func (statusbar statusbar) Remove(contextID uint, messageID uint) {
	var arg0 *C.GtkStatusbar
	var arg1 C.guint
	var arg2 C.guint

	arg0 = (*C.GtkStatusbar)(statusbar.Native())
	arg1 = C.guint(contextID)
	arg2 = C.guint(messageID)

	C.gtk_statusbar_remove(arg0, arg1, arg2)
}

// RemoveAll forces the removal of all messages from a statusbar's stack
// with the exact @context_id.
func (statusbar statusbar) RemoveAll(contextID uint) {
	var arg0 *C.GtkStatusbar
	var arg1 C.guint

	arg0 = (*C.GtkStatusbar)(statusbar.Native())
	arg1 = C.guint(contextID)

	C.gtk_statusbar_remove_all(arg0, arg1)
}

// StringFilter: gtkStringFilter determines whether to include items by looking
// at strings and comparing them to a fixed search term. The strings are
// obtained from the items by evaluating a Expression.
//
// GtkStringFilter has several different modes of comparison - it can match the
// whole string, just a prefix, or any substring.
type StringFilter interface {
	Filter

	// Expression gets the expression that the string filter uses to obtain
	// strings from items.
	Expression() Expression
	// IgnoreCase returns whether the filter ignores case differences.
	IgnoreCase() bool
	// MatchMode returns the match mode that the filter is using.
	MatchMode() StringFilterMatchMode
	// Search gets the search string set via gtk_string_filter_set_search().
	Search() string
	// SetExpression sets the expression that the string filter uses to obtain
	// strings from items. The expression must have a value type of TYPE_STRING.
	SetExpression(expression Expression)
	// SetIgnoreCase sets whether the filter ignores case differences.
	SetIgnoreCase(ignoreCase bool)
	// SetMatchMode sets the match mode for the filter.
	SetMatchMode(mode StringFilterMatchMode)
	// SetSearch sets the string to search for.
	SetSearch(search string)
}

type stringFilter struct {
	filter
}

// WrapStringFilter wraps a GObject to the right type. It is
// primarily used internally.
func WrapStringFilter(obj *externglib.Object) StringFilter {
	return stringFilter{filter{*externglib.Object{obj}}}
}

func marshalStringFilter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapStringFilter(obj), nil
}

// NewStringFilter constructs a class StringFilter.
func NewStringFilter(expression Expression) StringFilter {
	var arg1 *C.GtkExpression

	arg1 = (*C.GtkExpression)(expression.Native())

	ret := C.gtk_string_filter_new(arg1)

	var ret0 StringFilter

	ret0 = WrapStringFilter(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Expression gets the expression that the string filter uses to obtain
// strings from items.
func (self stringFilter) Expression() Expression {
	var arg0 *C.GtkStringFilter

	arg0 = (*C.GtkStringFilter)(self.Native())

	ret := C.gtk_string_filter_get_expression(arg0)

	var ret0 Expression

	ret0 = WrapExpression(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// IgnoreCase returns whether the filter ignores case differences.
func (self stringFilter) IgnoreCase() bool {
	var arg0 *C.GtkStringFilter

	arg0 = (*C.GtkStringFilter)(self.Native())

	ret := C.gtk_string_filter_get_ignore_case(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// MatchMode returns the match mode that the filter is using.
func (self stringFilter) MatchMode() StringFilterMatchMode {
	var arg0 *C.GtkStringFilter

	arg0 = (*C.GtkStringFilter)(self.Native())

	ret := C.gtk_string_filter_get_match_mode(arg0)

	var ret0 StringFilterMatchMode

	ret0 = StringFilterMatchMode(ret)

	return ret0
}

// Search gets the search string set via gtk_string_filter_set_search().
func (self stringFilter) Search() string {
	var arg0 *C.GtkStringFilter

	arg0 = (*C.GtkStringFilter)(self.Native())

	ret := C.gtk_string_filter_get_search(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// SetExpression sets the expression that the string filter uses to obtain
// strings from items. The expression must have a value type of TYPE_STRING.
func (self stringFilter) SetExpression(expression Expression) {
	var arg0 *C.GtkStringFilter
	var arg1 *C.GtkExpression

	arg0 = (*C.GtkStringFilter)(self.Native())
	arg1 = (*C.GtkExpression)(expression.Native())

	C.gtk_string_filter_set_expression(arg0, arg1)
}

// SetIgnoreCase sets whether the filter ignores case differences.
func (self stringFilter) SetIgnoreCase(ignoreCase bool) {
	var arg0 *C.GtkStringFilter
	var arg1 C.gboolean

	arg0 = (*C.GtkStringFilter)(self.Native())
	arg1 = gextras.Cbool(ignoreCase)

	C.gtk_string_filter_set_ignore_case(arg0, arg1)
}

// SetMatchMode sets the match mode for the filter.
func (self stringFilter) SetMatchMode(mode StringFilterMatchMode) {
	var arg0 *C.GtkStringFilter
	var arg1 C.GtkStringFilterMatchMode

	arg0 = (*C.GtkStringFilter)(self.Native())
	arg1 = (C.GtkStringFilterMatchMode)(mode)

	C.gtk_string_filter_set_match_mode(arg0, arg1)
}

// SetSearch sets the string to search for.
func (self stringFilter) SetSearch(search string) {
	var arg0 *C.GtkStringFilter
	var arg1 *C.char

	arg0 = (*C.GtkStringFilter)(self.Native())
	arg1 = (*C.gchar)(C.CString(search))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_string_filter_set_search(arg0, arg1)
}

// StringList is a list model that wraps an array of strings.
//
// The objects in the model have a "string" property.
//
// GtkStringList is well-suited for any place where you would typically use a
// `char*[]`, but need a list model.
//
//
// GtkStringList as GtkBuildable
//
// The GtkStringList implementation of the GtkBuildable interface supports
// adding items directly using the <items> element and specifying <item>
// elements for each item. Each <item> element supports the regular translation
// attributes “translatable”, “context” and “comments”.
//
// Here is a UI definition fragment specifying a GtkStringList
//
//
//    <object class="GtkStringList">
//      <items>
//        <item translatable="yes">Factory</item>
//        <item translatable="yes">Home</item>
//        <item translatable="yes">Subway</item>
//      </items>
//    </object>
//
type StringList interface {
	gextras.Objector

	// Append appends @string to @self.
	//
	// The @string will be copied. See gtk_string_list_take() for a way to avoid
	// that.
	Append(string string)
	// String gets the string that is at @position in @self. If @self does not
	// contain @position items, nil is returned.
	//
	// This function returns the const char *. To get the object wrapping it,
	// use g_list_model_get_item().
	String(position uint) string
	// Remove removes the string at @position from @self. @position must be
	// smaller than the current length of the list.
	Remove(position uint)
	// Splice changes @self by removing @n_removals strings and adding
	// @additions to it.
	//
	// This function is more efficient than gtk_string_list_append() and
	// gtk_string_list_remove(), because it only emits Model::items-changed once
	// for the change.
	//
	// This function copies the strings in @additions.
	//
	// The parameters @position and @n_removals must be correct (ie: @position +
	// @n_removals must be less than or equal to the length of the list at the
	// time this function is called).
	Splice(position uint, nRemovals uint, additions []string)
	// Take adds @string to self at the end, and takes ownership of it.
	//
	// This variant of gtk_string_list_append() is convenient for formatting
	// strings:
	//
	//
	//    gtk_string_list_take (self, g_strdup_print ("d dollars", lots));
	//
	Take(string string)
}

type stringList struct {
	*externglib.Object
}

// WrapStringList wraps a GObject to the right type. It is
// primarily used internally.
func WrapStringList(obj *externglib.Object) StringList {
	return stringList{*externglib.Object{obj}}
}

func marshalStringList(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapStringList(obj), nil
}

// NewStringList constructs a class StringList.
func NewStringList(strings []string) StringList {
	var arg1 **C.char

	{

	}

	ret := C.gtk_string_list_new(arg1)

	var ret0 StringList

	ret0 = WrapStringList(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Append appends @string to @self.
//
// The @string will be copied. See gtk_string_list_take() for a way to avoid
// that.
func (self stringList) Append(string string) {
	var arg0 *C.GtkStringList
	var arg1 *C.char

	arg0 = (*C.GtkStringList)(self.Native())
	arg1 = (*C.gchar)(C.CString(string))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_string_list_append(arg0, arg1)
}

// String gets the string that is at @position in @self. If @self does not
// contain @position items, nil is returned.
//
// This function returns the const char *. To get the object wrapping it,
// use g_list_model_get_item().
func (self stringList) String(position uint) string {
	var arg0 *C.GtkStringList
	var arg1 C.guint

	arg0 = (*C.GtkStringList)(self.Native())
	arg1 = C.guint(position)

	ret := C.gtk_string_list_get_string(arg0, arg1)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Remove removes the string at @position from @self. @position must be
// smaller than the current length of the list.
func (self stringList) Remove(position uint) {
	var arg0 *C.GtkStringList
	var arg1 C.guint

	arg0 = (*C.GtkStringList)(self.Native())
	arg1 = C.guint(position)

	C.gtk_string_list_remove(arg0, arg1)
}

// Splice changes @self by removing @n_removals strings and adding
// @additions to it.
//
// This function is more efficient than gtk_string_list_append() and
// gtk_string_list_remove(), because it only emits Model::items-changed once
// for the change.
//
// This function copies the strings in @additions.
//
// The parameters @position and @n_removals must be correct (ie: @position +
// @n_removals must be less than or equal to the length of the list at the
// time this function is called).
func (self stringList) Splice(position uint, nRemovals uint, additions []string) {
	var arg0 *C.GtkStringList
	var arg1 C.guint
	var arg2 C.guint
	var arg3 **C.char

	arg0 = (*C.GtkStringList)(self.Native())
	arg1 = C.guint(position)
	arg2 = C.guint(nRemovals)
	{

	}

	C.gtk_string_list_splice(arg0, arg1, arg2, arg3)
}

// Take adds @string to self at the end, and takes ownership of it.
//
// This variant of gtk_string_list_append() is convenient for formatting
// strings:
//
//
//    gtk_string_list_take (self, g_strdup_print ("d dollars", lots));
//
func (self stringList) Take(string string) {
	var arg0 *C.GtkStringList
	var arg1 *C.char

	arg0 = (*C.GtkStringList)(self.Native())
	arg1 = (*C.gchar)(C.CString(string))

	C.gtk_string_list_take(arg0, arg1)
}

type StringObject interface {
	gextras.Objector

	// String returns the string contained in a StringObject.
	String() string
}

type stringObject struct {
	*externglib.Object
}

// WrapStringObject wraps a GObject to the right type. It is
// primarily used internally.
func WrapStringObject(obj *externglib.Object) StringObject {
	return stringObject{*externglib.Object{obj}}
}

func marshalStringObject(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapStringObject(obj), nil
}

// NewStringObject constructs a class StringObject.
func NewStringObject(string string) StringObject {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(string))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_string_object_new(arg1)

	var ret0 StringObject

	ret0 = WrapStringObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// String returns the string contained in a StringObject.
func (self stringObject) String() string {
	var arg0 *C.GtkStringObject

	arg0 = (*C.GtkStringObject)(self.Native())

	ret := C.gtk_string_object_get_string(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// StringSorter: gtkStringSorter is a Sorter that compares strings. It does the
// comparison in a linguistically correct way using the current locale by
// normalizing Unicode strings and possibly case-folding them before performing
// the comparison.
//
// To obtain the strings to compare, this sorter evaluates a Expression.
type StringSorter interface {
	Sorter

	// Expression gets the expression that is evaluated to obtain strings from
	// items.
	Expression() Expression
	// IgnoreCase gets whether the sorter ignores case differences.
	IgnoreCase() bool
	// SetExpression sets the expression that is evaluated to obtain strings
	// from items.
	//
	// The expression must have the type G_TYPE_STRING.
	SetExpression(expression Expression)
	// SetIgnoreCase sets whether the sorter will ignore case differences.
	SetIgnoreCase(ignoreCase bool)
}

type stringSorter struct {
	sorter
}

// WrapStringSorter wraps a GObject to the right type. It is
// primarily used internally.
func WrapStringSorter(obj *externglib.Object) StringSorter {
	return stringSorter{sorter{*externglib.Object{obj}}}
}

func marshalStringSorter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapStringSorter(obj), nil
}

// NewStringSorter constructs a class StringSorter.
func NewStringSorter(expression Expression) StringSorter {
	var arg1 *C.GtkExpression

	arg1 = (*C.GtkExpression)(expression.Native())

	ret := C.gtk_string_sorter_new(arg1)

	var ret0 StringSorter

	ret0 = WrapStringSorter(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Expression gets the expression that is evaluated to obtain strings from
// items.
func (self stringSorter) Expression() Expression {
	var arg0 *C.GtkStringSorter

	arg0 = (*C.GtkStringSorter)(self.Native())

	ret := C.gtk_string_sorter_get_expression(arg0)

	var ret0 Expression

	ret0 = WrapExpression(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// IgnoreCase gets whether the sorter ignores case differences.
func (self stringSorter) IgnoreCase() bool {
	var arg0 *C.GtkStringSorter

	arg0 = (*C.GtkStringSorter)(self.Native())

	ret := C.gtk_string_sorter_get_ignore_case(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// SetExpression sets the expression that is evaluated to obtain strings
// from items.
//
// The expression must have the type G_TYPE_STRING.
func (self stringSorter) SetExpression(expression Expression) {
	var arg0 *C.GtkStringSorter
	var arg1 *C.GtkExpression

	arg0 = (*C.GtkStringSorter)(self.Native())
	arg1 = (*C.GtkExpression)(expression.Native())

	C.gtk_string_sorter_set_expression(arg0, arg1)
}

// SetIgnoreCase sets whether the sorter will ignore case differences.
func (self stringSorter) SetIgnoreCase(ignoreCase bool) {
	var arg0 *C.GtkStringSorter
	var arg1 C.gboolean

	arg0 = (*C.GtkStringSorter)(self.Native())
	arg1 = gextras.Cbool(ignoreCase)

	C.gtk_string_sorter_set_ignore_case(arg0, arg1)
}

// StyleContext is an object that stores styling information affecting a widget.
//
// In order to construct the final style information, StyleContext queries
// information from all attached StyleProviders. Style providers can be either
// attached explicitly to the context through gtk_style_context_add_provider(),
// or to the display through gtk_style_context_add_provider_for_display(). The
// resulting style is a combination of all providers’ information in priority
// order.
//
// For GTK widgets, any StyleContext returned by gtk_widget_get_style_context()
// will already have a Display and RTL/LTR information set. The style context
// will also be updated automatically if any of these settings change on the
// widget.
//
//
// Style Classes
//
// Widgets can add style classes to their context, which can be used to
// associate different styles by class. The documentation for individual widgets
// lists which style classes it uses itself, and which style classes may be
// added by applications to affect their appearance.
//
// GTK defines macros for a number of style classes.
//
//
// Custom styling in UI libraries and applications
//
// If you are developing a library with custom Widgets that render differently
// than standard components, you may need to add a StyleProvider yourself with
// the GTK_STYLE_PROVIDER_PRIORITY_FALLBACK priority, either a CssProvider or a
// custom object implementing the StyleProvider interface. This way themes may
// still attempt to style your UI elements in a different way if needed so.
//
// If you are using custom styling on an applications, you probably want then to
// make your style information prevail to the theme’s, so you must use a
// StyleProvider with the GTK_STYLE_PROVIDER_PRIORITY_APPLICATION priority, keep
// in mind that the user settings in `XDG_CONFIG_HOME/gtk-4.0/gtk.css` will
// still take precedence over your changes, as it uses the
// GTK_STYLE_PROVIDER_PRIORITY_USER priority.
type StyleContext interface {
	gextras.Objector

	// AddClass adds a style class to @context, so later uses of the style
	// context will make use of this new class for styling.
	//
	// In the CSS file format, a Entry defining a “search” class, would be
	// matched by:
	//
	//     <!-- language="CSS" -->
	//    entry.search { ... }
	//    ]|
	//
	//    While any widget defining a “search” class would be
	//    matched by:
	//    |[ <!-- language="CSS" -->
	//    .search { ... }
	//
	AddClass(className string)
	// AddProvider adds a style provider to @context, to be used in style
	// construction. Note that a style provider added by this function only
	// affects the style of the widget to which @context belongs. If you want to
	// affect the style of all widgets, use
	// gtk_style_context_add_provider_for_display().
	//
	// Note: If both priorities are the same, a StyleProvider added through this
	// function takes precedence over another added through
	// gtk_style_context_add_provider_for_display().
	AddProvider(provider StyleProvider, priority uint)
	// Border gets the border for a given state as a Border.
	Border() Border
	// Color gets the foreground color for a given state.
	Color() gdk.RGBA
	// Display returns the Display to which @context is attached.
	Display() gdk.Display
	// Margin gets the margin for a given state as a Border.
	Margin() Border
	// Padding gets the padding for a given state as a Border.
	Padding() Border
	// Scale returns the scale used for assets.
	Scale() int
	// State returns the state used for style matching.
	//
	// This method should only be used to retrieve the StateFlags to pass to
	// StyleContext methods, like gtk_style_context_get_padding(). If you need
	// to retrieve the current state of a Widget, use
	// gtk_widget_get_state_flags().
	State() StateFlags
	// HasClass returns true if @context currently has defined the given class
	// name.
	HasClass(className string) bool
	// LookupColor looks up and resolves a color name in the @context color map.
	LookupColor(colorName string) (color gdk.RGBA, ok bool)
	// RemoveClass removes @class_name from @context.
	RemoveClass(className string)
	// RemoveProvider removes @provider from the style providers list in
	// @context.
	RemoveProvider(provider StyleProvider)
	// Restore restores @context state to a previous stage. See
	// gtk_style_context_save().
	Restore()
	// Save saves the @context state, so temporary modifications done through
	// gtk_style_context_add_class(), gtk_style_context_remove_class(),
	// gtk_style_context_set_state(), etc. can quickly be reverted in one go
	// through gtk_style_context_restore().
	//
	// The matching call to gtk_style_context_restore() must be done before GTK
	// returns to the main loop.
	Save()
	// SetDisplay attaches @context to the given display.
	//
	// The display is used to add style information from “global” style
	// providers, such as the display's Settings instance.
	//
	// If you are using a StyleContext returned from
	// gtk_widget_get_style_context(), you do not need to call this yourself.
	SetDisplay(display gdk.Display)
	// SetScale sets the scale to use when getting image assets for the style.
	SetScale(scale int)
	// SetState sets the state to be used for style matching.
	SetState(flags StateFlags)
	// String converts the style context into a string representation.
	//
	// The string representation always includes information about the name,
	// state, id, visibility and style classes of the CSS node that is backing
	// @context. Depending on the flags, more information may be included.
	//
	// This function is intended for testing and debugging of the CSS
	// implementation in GTK. There are no guarantees about the format of the
	// returned string, it may change.
	String(flags StyleContextPrintFlags) string
}

type styleContext struct {
	*externglib.Object
}

// WrapStyleContext wraps a GObject to the right type. It is
// primarily used internally.
func WrapStyleContext(obj *externglib.Object) StyleContext {
	return styleContext{*externglib.Object{obj}}
}

func marshalStyleContext(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapStyleContext(obj), nil
}

// AddClass adds a style class to @context, so later uses of the style
// context will make use of this new class for styling.
//
// In the CSS file format, a Entry defining a “search” class, would be
// matched by:
//
//     <!-- language="CSS" -->
//    entry.search { ... }
//    ]|
//
//    While any widget defining a “search” class would be
//    matched by:
//    |[ <!-- language="CSS" -->
//    .search { ... }
//
func (context styleContext) AddClass(className string) {
	var arg0 *C.GtkStyleContext
	var arg1 *C.char

	arg0 = (*C.GtkStyleContext)(context.Native())
	arg1 = (*C.gchar)(C.CString(className))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_style_context_add_class(arg0, arg1)
}

// AddProvider adds a style provider to @context, to be used in style
// construction. Note that a style provider added by this function only
// affects the style of the widget to which @context belongs. If you want to
// affect the style of all widgets, use
// gtk_style_context_add_provider_for_display().
//
// Note: If both priorities are the same, a StyleProvider added through this
// function takes precedence over another added through
// gtk_style_context_add_provider_for_display().
func (context styleContext) AddProvider(provider StyleProvider, priority uint) {
	var arg0 *C.GtkStyleContext
	var arg1 *C.GtkStyleProvider
	var arg2 C.guint

	arg0 = (*C.GtkStyleContext)(context.Native())
	arg2 = C.guint(priority)

	C.gtk_style_context_add_provider(arg0, arg1, arg2)
}

// Border gets the border for a given state as a Border.
func (context styleContext) Border() Border {
	var arg0 *C.GtkStyleContext
	var arg1 *C.GtkBorder // out

	arg0 = (*C.GtkStyleContext)(context.Native())

	ret := C.gtk_style_context_get_border(arg0, &arg1)

	var ret0 *Border

	ret0 = WrapBorder(arg1)

	return ret0
}

// Color gets the foreground color for a given state.
func (context styleContext) Color() gdk.RGBA {
	var arg0 *C.GtkStyleContext
	var arg1 *C.GdkRGBA // out

	arg0 = (*C.GtkStyleContext)(context.Native())

	ret := C.gtk_style_context_get_color(arg0, &arg1)

	var ret0 *gdk.RGBA

	ret0 = gdk.WrapRGBA(arg1)

	return ret0
}

// Display returns the Display to which @context is attached.
func (context styleContext) Display() gdk.Display {
	var arg0 *C.GtkStyleContext

	arg0 = (*C.GtkStyleContext)(context.Native())

	ret := C.gtk_style_context_get_display(arg0)

	var ret0 gdk.Display

	ret0 = gdk.WrapDisplay(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Margin gets the margin for a given state as a Border.
func (context styleContext) Margin() Border {
	var arg0 *C.GtkStyleContext
	var arg1 *C.GtkBorder // out

	arg0 = (*C.GtkStyleContext)(context.Native())

	ret := C.gtk_style_context_get_margin(arg0, &arg1)

	var ret0 *Border

	ret0 = WrapBorder(arg1)

	return ret0
}

// Padding gets the padding for a given state as a Border.
func (context styleContext) Padding() Border {
	var arg0 *C.GtkStyleContext
	var arg1 *C.GtkBorder // out

	arg0 = (*C.GtkStyleContext)(context.Native())

	ret := C.gtk_style_context_get_padding(arg0, &arg1)

	var ret0 *Border

	ret0 = WrapBorder(arg1)

	return ret0
}

// Scale returns the scale used for assets.
func (context styleContext) Scale() int {
	var arg0 *C.GtkStyleContext

	arg0 = (*C.GtkStyleContext)(context.Native())

	ret := C.gtk_style_context_get_scale(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// State returns the state used for style matching.
//
// This method should only be used to retrieve the StateFlags to pass to
// StyleContext methods, like gtk_style_context_get_padding(). If you need
// to retrieve the current state of a Widget, use
// gtk_widget_get_state_flags().
func (context styleContext) State() StateFlags {
	var arg0 *C.GtkStyleContext

	arg0 = (*C.GtkStyleContext)(context.Native())

	ret := C.gtk_style_context_get_state(arg0)

	var ret0 StateFlags

	ret0 = StateFlags(ret)

	return ret0
}

// HasClass returns true if @context currently has defined the given class
// name.
func (context styleContext) HasClass(className string) bool {
	var arg0 *C.GtkStyleContext
	var arg1 *C.char

	arg0 = (*C.GtkStyleContext)(context.Native())
	arg1 = (*C.gchar)(C.CString(className))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_style_context_has_class(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// LookupColor looks up and resolves a color name in the @context color map.
func (context styleContext) LookupColor(colorName string) (color gdk.RGBA, ok bool) {
	var arg0 *C.GtkStyleContext
	var arg1 *C.char
	var arg2 *C.GdkRGBA // out

	arg0 = (*C.GtkStyleContext)(context.Native())
	arg1 = (*C.gchar)(C.CString(colorName))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_style_context_lookup_color(arg0, arg1, &arg2)

	var ret0 *gdk.RGBA
	var ret1 bool

	ret0 = gdk.WrapRGBA(arg2)

	ret1 = gextras.Gobool(ret)

	return ret0, ret1
}

// RemoveClass removes @class_name from @context.
func (context styleContext) RemoveClass(className string) {
	var arg0 *C.GtkStyleContext
	var arg1 *C.char

	arg0 = (*C.GtkStyleContext)(context.Native())
	arg1 = (*C.gchar)(C.CString(className))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_style_context_remove_class(arg0, arg1)
}

// RemoveProvider removes @provider from the style providers list in
// @context.
func (context styleContext) RemoveProvider(provider StyleProvider) {
	var arg0 *C.GtkStyleContext
	var arg1 *C.GtkStyleProvider

	arg0 = (*C.GtkStyleContext)(context.Native())

	C.gtk_style_context_remove_provider(arg0, arg1)
}

// Restore restores @context state to a previous stage. See
// gtk_style_context_save().
func (context styleContext) Restore() {
	var arg0 *C.GtkStyleContext

	arg0 = (*C.GtkStyleContext)(context.Native())

	C.gtk_style_context_restore(arg0)
}

// Save saves the @context state, so temporary modifications done through
// gtk_style_context_add_class(), gtk_style_context_remove_class(),
// gtk_style_context_set_state(), etc. can quickly be reverted in one go
// through gtk_style_context_restore().
//
// The matching call to gtk_style_context_restore() must be done before GTK
// returns to the main loop.
func (context styleContext) Save() {
	var arg0 *C.GtkStyleContext

	arg0 = (*C.GtkStyleContext)(context.Native())

	C.gtk_style_context_save(arg0)
}

// SetDisplay attaches @context to the given display.
//
// The display is used to add style information from “global” style
// providers, such as the display's Settings instance.
//
// If you are using a StyleContext returned from
// gtk_widget_get_style_context(), you do not need to call this yourself.
func (context styleContext) SetDisplay(display gdk.Display) {
	var arg0 *C.GtkStyleContext
	var arg1 *C.GdkDisplay

	arg0 = (*C.GtkStyleContext)(context.Native())
	arg1 = (*C.GdkDisplay)(display.Native())

	C.gtk_style_context_set_display(arg0, arg1)
}

// SetScale sets the scale to use when getting image assets for the style.
func (context styleContext) SetScale(scale int) {
	var arg0 *C.GtkStyleContext
	var arg1 C.int

	arg0 = (*C.GtkStyleContext)(context.Native())
	arg1 = C.int(scale)

	C.gtk_style_context_set_scale(arg0, arg1)
}

// SetState sets the state to be used for style matching.
func (context styleContext) SetState(flags StateFlags) {
	var arg0 *C.GtkStyleContext
	var arg1 C.GtkStateFlags

	arg0 = (*C.GtkStyleContext)(context.Native())
	arg1 = (C.GtkStateFlags)(flags)

	C.gtk_style_context_set_state(arg0, arg1)
}

// String converts the style context into a string representation.
//
// The string representation always includes information about the name,
// state, id, visibility and style classes of the CSS node that is backing
// @context. Depending on the flags, more information may be included.
//
// This function is intended for testing and debugging of the CSS
// implementation in GTK. There are no guarantees about the format of the
// returned string, it may change.
func (context styleContext) String(flags StyleContextPrintFlags) string {
	var arg0 *C.GtkStyleContext
	var arg1 C.GtkStyleContextPrintFlags

	arg0 = (*C.GtkStyleContext)(context.Native())
	arg1 = (C.GtkStyleContextPrintFlags)(flags)

	ret := C.gtk_style_context_to_string(arg0, arg1)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// Switch is a widget that has two states: on or off. The user can control which
// state should be active by clicking the empty area, or by dragging the handle.
//
// GtkSwitch can also handle situations where the underlying state changes with
// a delay. See Switch::state-set for details.
//
// CSS nodes
//
//    switch
//    ├── label
//    ├── label
//    ╰── slider
//
//
// GtkSwitch has four css nodes, the main node with the name switch and subnodes
// for the slider and the on and off labels. Neither of them is using any style
// classes.
//
//
// Accessibility
//
// GtkSwitch uses the K_ACCESSIBLE_ROLE_SWITCH role.
type Switch interface {
	Widget

	// Active gets whether the Switch is in its “on” or “off” state.
	Active() bool
	// State gets the underlying state of the Switch.
	State() bool
	// SetActive changes the state of @self to the desired one.
	SetActive(isActive bool)
	// SetState sets the underlying state of the Switch.
	//
	// Normally, this is the same as Switch:active, unless the switch is set up
	// for delayed state changes. This function is typically called from a
	// Switch::state-set signal handler.
	//
	// See Switch::state-set for details.
	SetState(state bool)
}

type _switch struct {
	widget
}

// WrapSwitch wraps a GObject to the right type. It is
// primarily used internally.
func WrapSwitch(obj *externglib.Object) Switch {
	return _switch{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}
}

func marshalSwitch(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSwitch(obj), nil
}

// NewSwitch constructs a class Switch.
func NewSwitch() Switch {

	ret := C.gtk_switch_new()

	var ret0 Switch

	ret0 = WrapSwitch(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Active gets whether the Switch is in its “on” or “off” state.
func (self _switch) Active() bool {
	var arg0 *C.GtkSwitch

	arg0 = (*C.GtkSwitch)(self.Native())

	ret := C.gtk_switch_get_active(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// State gets the underlying state of the Switch.
func (self _switch) State() bool {
	var arg0 *C.GtkSwitch

	arg0 = (*C.GtkSwitch)(self.Native())

	ret := C.gtk_switch_get_state(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// SetActive changes the state of @self to the desired one.
func (self _switch) SetActive(isActive bool) {
	var arg0 *C.GtkSwitch
	var arg1 C.gboolean

	arg0 = (*C.GtkSwitch)(self.Native())
	arg1 = gextras.Cbool(isActive)

	C.gtk_switch_set_active(arg0, arg1)
}

// SetState sets the underlying state of the Switch.
//
// Normally, this is the same as Switch:active, unless the switch is set up
// for delayed state changes. This function is typically called from a
// Switch::state-set signal handler.
//
// See Switch::state-set for details.
func (self _switch) SetState(state bool) {
	var arg0 *C.GtkSwitch
	var arg1 C.gboolean

	arg0 = (*C.GtkSwitch)(self.Native())
	arg1 = gextras.Cbool(state)

	C.gtk_switch_set_state(arg0, arg1)
}

// Text: the Text widget is a single line text entry widget.
//
// A fairly large set of key bindings are supported by default. If the entered
// text is longer than the allocation of the widget, the widget will scroll so
// that the cursor position is visible.
//
// When using an entry for passwords and other sensitive information, it can be
// put into “password mode” using gtk_text_set_visibility(). In this mode,
// entered text is displayed using a “invisible” character. By default, GTK
// picks the best invisible character that is available in the current font, but
// it can be changed with gtk_text_set_invisible_char().
//
// If you are looking to add icons or progress display in an entry, look at
// Entry. There other alternatives for more specialized use cases, such as
// SearchEntry.
//
// If you need multi-line editable text, look at TextView.
//
// CSS nodes
//
//    text[.read-only]
//    ├── placeholder
//    ├── undershoot.left
//    ├── undershoot.right
//    ├── [selection]
//    ├── [block-cursor]
//    ╰── [window.popup]
//
//
// GtkText has a main node with the name text. Depending on the properties of
// the widget, the .read-only style class may appear.
//
// When the entry has a selection, it adds a subnode with the name selection.
//
// When the entry is in overwrite mode, it adds a subnode with the name
// block-cursor that determines how the block cursor is drawn.
//
// The CSS node for a context menu is added as a subnode below text as well.
//
// The undershoot nodes are used to draw the underflow indication when content
// is scrolled out of view. These nodes get the .left and .right style classes
// added depending on where the indication is drawn.
//
// When touch is used and touch selection handles are shown, they are using CSS
// nodes with name cursor-handle. They get the .top or .bottom style class
// depending on where they are shown in relation to the selection. If there is
// just a single handle for the text cursor, it gets the style class
// .insertion-cursor.
//
//
// Accessibility
//
// GtkText uses the K_ACCESSIBLE_ROLE_NONE role, which causes it to be skipped
// for accessibility. This is because GtkText is expected to be used as a
// delegate for a Editable implementation that will be represented to
// accessibility.
type Text interface {
	Widget

	// ActivatesDefault retrieves the value set by
	// gtk_text_set_activates_default().
	ActivatesDefault() bool
	// Attributes gets the attribute list that was set on the self using
	// gtk_text_set_attributes(), if any.
	Attributes() *pango.AttrList
	// Buffer: get the EntryBuffer object which holds the text for this self.
	Buffer() EntryBuffer
	// EnableEmojiCompletion returns whether Emoji completion is enabled for
	// this GtkText widget.
	EnableEmojiCompletion() bool
	// ExtraMenu gets the menu model set with gtk_text_set_extra_menu().
	ExtraMenu() gio.MenuModel
	// InputHints gets the value of the Text:input-hints property.
	InputHints() InputHints
	// InputPurpose gets the value of the Text:input-purpose property.
	InputPurpose() InputPurpose
	// InvisibleChar retrieves the character displayed in place of the real
	// characters for entries with visibility set to false. Note that GTK does
	// not compute this value unless it needs it, so the value returned by this
	// function is not very useful unless it has been explicitly set with
	// gtk_text_set_invisible_char()
	InvisibleChar() uint32
	// MaxLength retrieves the maximum allowed length of the text in @self. See
	// gtk_text_set_max_length().
	//
	// This is equivalent to getting @self's EntryBuffer and calling
	// gtk_entry_buffer_get_max_length() on it.
	MaxLength() int
	// OverwriteMode gets the value set by gtk_text_set_overwrite_mode().
	OverwriteMode() bool
	// PlaceholderText retrieves the text that will be displayed when @self is
	// empty and unfocused
	PlaceholderText() string
	// PropagateTextWidth returns whether the Text will grow and shrink with the
	// content.
	PropagateTextWidth() bool
	// Tabs gets the tabstops that were set on the self using
	// gtk_text_set_tabs(), if any.
	Tabs() *pango.TabArray
	// TextLength retrieves the current length of the text in @self.
	//
	// This is equivalent to getting @self's EntryBuffer and calling
	// gtk_entry_buffer_get_length() on it.
	TextLength() uint16
	// TruncateMultiline returns whether the Text will truncate multi-line text
	// that is pasted into the widget
	TruncateMultiline() bool
	// Visibility retrieves whether the text in @self is visible. See
	// gtk_text_set_visibility().
	Visibility() bool
	// GrabFocusWithoutSelecting causes @self to have keyboard focus.
	//
	// It behaves like gtk_widget_grab_focus(), except that it doesn't select
	// the contents of @self. You only want to call this on some special entries
	// which the user usually doesn't want to replace all text in, such as
	// search-as-you-type entries.
	GrabFocusWithoutSelecting() bool
	// SetActivatesDefault: if @activates is true, pressing Enter in the @self
	// will activate the default widget for the window containing the self. This
	// usually means that the dialog box containing the self will be closed,
	// since the default widget is usually one of the dialog buttons.
	SetActivatesDefault(activates bool)
	// SetAttributes sets a AttrList; the attributes in the list are applied to
	// the text.
	SetAttributes(attrs *pango.AttrList)
	// SetBuffer: set the EntryBuffer object which holds the text for this
	// widget.
	SetBuffer(buffer EntryBuffer)
	// SetEnableEmojiCompletion sets whether Emoji completion is enabled. If it
	// is, typing ':', followed by a recognized keyword, will pop up a window
	// with suggested Emojis matching the keyword.
	SetEnableEmojiCompletion(enableEmojiCompletion bool)
	// SetExtraMenu sets a menu model to add when constructing the context menu
	// for @self.
	SetExtraMenu(model gio.MenuModel)
	// SetInputHints sets the Text:input-hints property, which allows input
	// methods to fine-tune their behaviour.
	SetInputHints(hints InputHints)
	// SetInputPurpose sets the Text:input-purpose property which can be used by
	// on-screen keyboards and other input methods to adjust their behaviour.
	SetInputPurpose(purpose InputPurpose)
	// SetInvisibleChar sets the character to use in place of the actual text
	// when gtk_text_set_visibility() has been called to set text visibility to
	// false. i.e. this is the character used in “password mode” to show the
	// user how many characters have been typed.
	//
	// By default, GTK picks the best invisible char available in the current
	// font. If you set the invisible char to 0, then the user will get no
	// feedback at all; there will be no text on the screen as they type.
	SetInvisibleChar(ch uint32)
	// SetMaxLength sets the maximum allowed length of the contents of the
	// widget.
	//
	// If the current contents are longer than the given length, then they will
	// be truncated to fit.
	//
	// This is equivalent to getting @self's EntryBuffer and calling
	// gtk_entry_buffer_set_max_length() on it. ]|
	SetMaxLength(length int)
	// SetOverwriteMode sets whether the text is overwritten when typing in the
	// Text.
	SetOverwriteMode(overwrite bool)
	// SetPlaceholderText sets text to be displayed in @self when it is empty.
	//
	// This can be used to give a visual hint of the expected contents of the
	// self.
	SetPlaceholderText(text string)
	// SetPropagateTextWidth sets whether the GtkText should grow and shrink
	// with the content.
	SetPropagateTextWidth(propagateTextWidth bool)
	// SetTabs sets a TabArray; the tabstops in the array are applied to the
	// self text.
	SetTabs(tabs *pango.TabArray)
	// SetTruncateMultiline sets whether the GtkText should truncate multi-line
	// text that is pasted into the widget.
	SetTruncateMultiline(truncateMultiline bool)
	// SetVisibility sets whether the contents of the self are visible or not.
	// When visibility is set to false, characters are displayed as the
	// invisible char, and will also appear that way when the text in the self
	// widget is copied to the clipboard.
	//
	// By default, GTK picks the best invisible character available in the
	// current font, but it can be changed with gtk_text_set_invisible_char().
	//
	// Note that you probably want to set Text:input-purpose to
	// GTK_INPUT_PURPOSE_PASSWORD or GTK_INPUT_PURPOSE_PIN to inform input
	// methods about the purpose of this self, in addition to setting visibility
	// to false.
	SetVisibility(visible bool)
	// UnsetInvisibleChar unsets the invisible char previously set with
	// gtk_text_set_invisible_char(). So that the default invisible char is used
	// again.
	UnsetInvisibleChar()
}

type text struct {
	widget
}

// WrapText wraps a GObject to the right type. It is
// primarily used internally.
func WrapText(obj *externglib.Object) Text {
	return text{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}
}

func marshalText(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapText(obj), nil
}

// NewText constructs a class Text.
func NewText() Text {

	ret := C.gtk_text_new()

	var ret0 Text

	ret0 = WrapText(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewTextWithBuffer constructs a class Text.
func NewTextWithBuffer(buffer EntryBuffer) Text {
	var arg1 *C.GtkEntryBuffer

	arg1 = (*C.GtkEntryBuffer)(buffer.Native())

	ret := C.gtk_text_new_with_buffer(arg1)

	var ret0 Text

	ret0 = WrapText(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// ActivatesDefault retrieves the value set by
// gtk_text_set_activates_default().
func (self text) ActivatesDefault() bool {
	var arg0 *C.GtkText

	arg0 = (*C.GtkText)(self.Native())

	ret := C.gtk_text_get_activates_default(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Attributes gets the attribute list that was set on the self using
// gtk_text_set_attributes(), if any.
func (self text) Attributes() *pango.AttrList {
	var arg0 *C.GtkText

	arg0 = (*C.GtkText)(self.Native())

	ret := C.gtk_text_get_attributes(arg0)

	var ret0 *pango.AttrList

	ret0 = pango.WrapAttrList(ret)

	return ret0
}

// Buffer: get the EntryBuffer object which holds the text for this self.
func (self text) Buffer() EntryBuffer {
	var arg0 *C.GtkText

	arg0 = (*C.GtkText)(self.Native())

	ret := C.gtk_text_get_buffer(arg0)

	var ret0 EntryBuffer

	ret0 = WrapEntryBuffer(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// EnableEmojiCompletion returns whether Emoji completion is enabled for
// this GtkText widget.
func (self text) EnableEmojiCompletion() bool {
	var arg0 *C.GtkText

	arg0 = (*C.GtkText)(self.Native())

	ret := C.gtk_text_get_enable_emoji_completion(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// ExtraMenu gets the menu model set with gtk_text_set_extra_menu().
func (self text) ExtraMenu() gio.MenuModel {
	var arg0 *C.GtkText

	arg0 = (*C.GtkText)(self.Native())

	ret := C.gtk_text_get_extra_menu(arg0)

	var ret0 gio.MenuModel

	ret0 = gio.WrapMenuModel(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// InputHints gets the value of the Text:input-hints property.
func (self text) InputHints() InputHints {
	var arg0 *C.GtkText

	arg0 = (*C.GtkText)(self.Native())

	ret := C.gtk_text_get_input_hints(arg0)

	var ret0 InputHints

	ret0 = InputHints(ret)

	return ret0
}

// InputPurpose gets the value of the Text:input-purpose property.
func (self text) InputPurpose() InputPurpose {
	var arg0 *C.GtkText

	arg0 = (*C.GtkText)(self.Native())

	ret := C.gtk_text_get_input_purpose(arg0)

	var ret0 InputPurpose

	ret0 = InputPurpose(ret)

	return ret0
}

// InvisibleChar retrieves the character displayed in place of the real
// characters for entries with visibility set to false. Note that GTK does
// not compute this value unless it needs it, so the value returned by this
// function is not very useful unless it has been explicitly set with
// gtk_text_set_invisible_char()
func (self text) InvisibleChar() uint32 {
	var arg0 *C.GtkText

	arg0 = (*C.GtkText)(self.Native())

	ret := C.gtk_text_get_invisible_char(arg0)

	var ret0 uint32

	ret0 = uint32(ret)

	return ret0
}

// MaxLength retrieves the maximum allowed length of the text in @self. See
// gtk_text_set_max_length().
//
// This is equivalent to getting @self's EntryBuffer and calling
// gtk_entry_buffer_get_max_length() on it.
func (self text) MaxLength() int {
	var arg0 *C.GtkText

	arg0 = (*C.GtkText)(self.Native())

	ret := C.gtk_text_get_max_length(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// OverwriteMode gets the value set by gtk_text_set_overwrite_mode().
func (self text) OverwriteMode() bool {
	var arg0 *C.GtkText

	arg0 = (*C.GtkText)(self.Native())

	ret := C.gtk_text_get_overwrite_mode(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// PlaceholderText retrieves the text that will be displayed when @self is
// empty and unfocused
func (self text) PlaceholderText() string {
	var arg0 *C.GtkText

	arg0 = (*C.GtkText)(self.Native())

	ret := C.gtk_text_get_placeholder_text(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// PropagateTextWidth returns whether the Text will grow and shrink with the
// content.
func (self text) PropagateTextWidth() bool {
	var arg0 *C.GtkText

	arg0 = (*C.GtkText)(self.Native())

	ret := C.gtk_text_get_propagate_text_width(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Tabs gets the tabstops that were set on the self using
// gtk_text_set_tabs(), if any.
func (self text) Tabs() *pango.TabArray {
	var arg0 *C.GtkText

	arg0 = (*C.GtkText)(self.Native())

	ret := C.gtk_text_get_tabs(arg0)

	var ret0 *pango.TabArray

	ret0 = pango.WrapTabArray(ret)

	return ret0
}

// TextLength retrieves the current length of the text in @self.
//
// This is equivalent to getting @self's EntryBuffer and calling
// gtk_entry_buffer_get_length() on it.
func (self text) TextLength() uint16 {
	var arg0 *C.GtkText

	arg0 = (*C.GtkText)(self.Native())

	ret := C.gtk_text_get_text_length(arg0)

	var ret0 uint16

	ret0 = uint16(ret)

	return ret0
}

// TruncateMultiline returns whether the Text will truncate multi-line text
// that is pasted into the widget
func (self text) TruncateMultiline() bool {
	var arg0 *C.GtkText

	arg0 = (*C.GtkText)(self.Native())

	ret := C.gtk_text_get_truncate_multiline(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Visibility retrieves whether the text in @self is visible. See
// gtk_text_set_visibility().
func (self text) Visibility() bool {
	var arg0 *C.GtkText

	arg0 = (*C.GtkText)(self.Native())

	ret := C.gtk_text_get_visibility(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// GrabFocusWithoutSelecting causes @self to have keyboard focus.
//
// It behaves like gtk_widget_grab_focus(), except that it doesn't select
// the contents of @self. You only want to call this on some special entries
// which the user usually doesn't want to replace all text in, such as
// search-as-you-type entries.
func (self text) GrabFocusWithoutSelecting() bool {
	var arg0 *C.GtkText

	arg0 = (*C.GtkText)(self.Native())

	ret := C.gtk_text_grab_focus_without_selecting(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// SetActivatesDefault: if @activates is true, pressing Enter in the @self
// will activate the default widget for the window containing the self. This
// usually means that the dialog box containing the self will be closed,
// since the default widget is usually one of the dialog buttons.
func (self text) SetActivatesDefault(activates bool) {
	var arg0 *C.GtkText
	var arg1 C.gboolean

	arg0 = (*C.GtkText)(self.Native())
	arg1 = gextras.Cbool(activates)

	C.gtk_text_set_activates_default(arg0, arg1)
}

// SetAttributes sets a AttrList; the attributes in the list are applied to
// the text.
func (self text) SetAttributes(attrs *pango.AttrList) {
	var arg0 *C.GtkText
	var arg1 *C.PangoAttrList

	arg0 = (*C.GtkText)(self.Native())
	arg1 = (*C.PangoAttrList)(attrs.Native())

	C.gtk_text_set_attributes(arg0, arg1)
}

// SetBuffer: set the EntryBuffer object which holds the text for this
// widget.
func (self text) SetBuffer(buffer EntryBuffer) {
	var arg0 *C.GtkText
	var arg1 *C.GtkEntryBuffer

	arg0 = (*C.GtkText)(self.Native())
	arg1 = (*C.GtkEntryBuffer)(buffer.Native())

	C.gtk_text_set_buffer(arg0, arg1)
}

// SetEnableEmojiCompletion sets whether Emoji completion is enabled. If it
// is, typing ':', followed by a recognized keyword, will pop up a window
// with suggested Emojis matching the keyword.
func (self text) SetEnableEmojiCompletion(enableEmojiCompletion bool) {
	var arg0 *C.GtkText
	var arg1 C.gboolean

	arg0 = (*C.GtkText)(self.Native())
	arg1 = gextras.Cbool(enableEmojiCompletion)

	C.gtk_text_set_enable_emoji_completion(arg0, arg1)
}

// SetExtraMenu sets a menu model to add when constructing the context menu
// for @self.
func (self text) SetExtraMenu(model gio.MenuModel) {
	var arg0 *C.GtkText
	var arg1 *C.GMenuModel

	arg0 = (*C.GtkText)(self.Native())
	arg1 = (*C.GMenuModel)(model.Native())

	C.gtk_text_set_extra_menu(arg0, arg1)
}

// SetInputHints sets the Text:input-hints property, which allows input
// methods to fine-tune their behaviour.
func (self text) SetInputHints(hints InputHints) {
	var arg0 *C.GtkText
	var arg1 C.GtkInputHints

	arg0 = (*C.GtkText)(self.Native())
	arg1 = (C.GtkInputHints)(hints)

	C.gtk_text_set_input_hints(arg0, arg1)
}

// SetInputPurpose sets the Text:input-purpose property which can be used by
// on-screen keyboards and other input methods to adjust their behaviour.
func (self text) SetInputPurpose(purpose InputPurpose) {
	var arg0 *C.GtkText
	var arg1 C.GtkInputPurpose

	arg0 = (*C.GtkText)(self.Native())
	arg1 = (C.GtkInputPurpose)(purpose)

	C.gtk_text_set_input_purpose(arg0, arg1)
}

// SetInvisibleChar sets the character to use in place of the actual text
// when gtk_text_set_visibility() has been called to set text visibility to
// false. i.e. this is the character used in “password mode” to show the
// user how many characters have been typed.
//
// By default, GTK picks the best invisible char available in the current
// font. If you set the invisible char to 0, then the user will get no
// feedback at all; there will be no text on the screen as they type.
func (self text) SetInvisibleChar(ch uint32) {
	var arg0 *C.GtkText
	var arg1 C.gunichar

	arg0 = (*C.GtkText)(self.Native())
	arg1 = C.gunichar(ch)

	C.gtk_text_set_invisible_char(arg0, arg1)
}

// SetMaxLength sets the maximum allowed length of the contents of the
// widget.
//
// If the current contents are longer than the given length, then they will
// be truncated to fit.
//
// This is equivalent to getting @self's EntryBuffer and calling
// gtk_entry_buffer_set_max_length() on it. ]|
func (self text) SetMaxLength(length int) {
	var arg0 *C.GtkText
	var arg1 C.int

	arg0 = (*C.GtkText)(self.Native())
	arg1 = C.int(length)

	C.gtk_text_set_max_length(arg0, arg1)
}

// SetOverwriteMode sets whether the text is overwritten when typing in the
// Text.
func (self text) SetOverwriteMode(overwrite bool) {
	var arg0 *C.GtkText
	var arg1 C.gboolean

	arg0 = (*C.GtkText)(self.Native())
	arg1 = gextras.Cbool(overwrite)

	C.gtk_text_set_overwrite_mode(arg0, arg1)
}

// SetPlaceholderText sets text to be displayed in @self when it is empty.
//
// This can be used to give a visual hint of the expected contents of the
// self.
func (self text) SetPlaceholderText(text string) {
	var arg0 *C.GtkText
	var arg1 *C.char

	arg0 = (*C.GtkText)(self.Native())
	arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_text_set_placeholder_text(arg0, arg1)
}

// SetPropagateTextWidth sets whether the GtkText should grow and shrink
// with the content.
func (self text) SetPropagateTextWidth(propagateTextWidth bool) {
	var arg0 *C.GtkText
	var arg1 C.gboolean

	arg0 = (*C.GtkText)(self.Native())
	arg1 = gextras.Cbool(propagateTextWidth)

	C.gtk_text_set_propagate_text_width(arg0, arg1)
}

// SetTabs sets a TabArray; the tabstops in the array are applied to the
// self text.
func (self text) SetTabs(tabs *pango.TabArray) {
	var arg0 *C.GtkText
	var arg1 *C.PangoTabArray

	arg0 = (*C.GtkText)(self.Native())
	arg1 = (*C.PangoTabArray)(tabs.Native())

	C.gtk_text_set_tabs(arg0, arg1)
}

// SetTruncateMultiline sets whether the GtkText should truncate multi-line
// text that is pasted into the widget.
func (self text) SetTruncateMultiline(truncateMultiline bool) {
	var arg0 *C.GtkText
	var arg1 C.gboolean

	arg0 = (*C.GtkText)(self.Native())
	arg1 = gextras.Cbool(truncateMultiline)

	C.gtk_text_set_truncate_multiline(arg0, arg1)
}

// SetVisibility sets whether the contents of the self are visible or not.
// When visibility is set to false, characters are displayed as the
// invisible char, and will also appear that way when the text in the self
// widget is copied to the clipboard.
//
// By default, GTK picks the best invisible character available in the
// current font, but it can be changed with gtk_text_set_invisible_char().
//
// Note that you probably want to set Text:input-purpose to
// GTK_INPUT_PURPOSE_PASSWORD or GTK_INPUT_PURPOSE_PIN to inform input
// methods about the purpose of this self, in addition to setting visibility
// to false.
func (self text) SetVisibility(visible bool) {
	var arg0 *C.GtkText
	var arg1 C.gboolean

	arg0 = (*C.GtkText)(self.Native())
	arg1 = gextras.Cbool(visible)

	C.gtk_text_set_visibility(arg0, arg1)
}

// UnsetInvisibleChar unsets the invisible char previously set with
// gtk_text_set_invisible_char(). So that the default invisible char is used
// again.
func (self text) UnsetInvisibleChar() {
	var arg0 *C.GtkText

	arg0 = (*C.GtkText)(self.Native())

	C.gtk_text_unset_invisible_char(arg0)
}

// TextBuffer: you may wish to begin by reading the [text widget conceptual
// overview][TextWidget] which gives an overview of all the objects and data
// types related to the text widget and how they work together.
type TextBuffer interface {
	gextras.Objector

	// AddMark adds the mark at position @where. The mark must not be added to
	// another buffer, and if its name is not nil then there must not be another
	// mark in the buffer with the same name.
	//
	// Emits the TextBuffer::mark-set signal as notification of the mark's
	// initial placement.
	AddMark(mark TextMark, where *TextIter)
	// AddSelectionClipboard adds @clipboard to the list of clipboards in which
	// the selection contents of @buffer are available. In most cases,
	// @clipboard will be the Clipboard returned by
	// gtk_widget_get_primary_clipboard() for a view of @buffer.
	AddSelectionClipboard(clipboard gdk.Clipboard)
	// ApplyTag emits the “apply-tag” signal on @buffer. The default handler for
	// the signal applies @tag to the given range. @start and @end do not have
	// to be in order.
	ApplyTag(tag TextTag, start *TextIter, end *TextIter)
	// ApplyTagByName calls gtk_text_tag_table_lookup() on the buffer’s tag
	// table to get a TextTag, then calls gtk_text_buffer_apply_tag().
	ApplyTagByName(name string, start *TextIter, end *TextIter)
	// Backspace performs the appropriate action as if the user hit the delete
	// key with the cursor at the position specified by @iter. In the normal
	// case a single character will be deleted, but when combining accents are
	// involved, more than one character can be deleted, and when precomposed
	// character and accent combinations are involved, less than one character
	// will be deleted.
	//
	// Because the buffer is modified, all outstanding iterators become invalid
	// after calling this function; however, the @iter will be re-initialized to
	// point to the location where text was deleted.
	Backspace(iter *TextIter, interactive bool, defaultEditable bool) bool
	// BeginIrreversibleAction denotes the beginning of an action that may not
	// be undone. This will cause any previous operations in the undo/redo queue
	// to be cleared.
	//
	// This should be paired with a call to
	// gtk_text_buffer_end_irreversible_action() after the irreversible action
	// has completed.
	//
	// You may nest calls to gtk_text_buffer_begin_irreversible_action() and
	// gtk_text_buffer_end_irreversible_action() pairs.
	BeginIrreversibleAction()
	// BeginUserAction: called to indicate that the buffer operations between
	// here and a call to gtk_text_buffer_end_user_action() are part of a single
	// user-visible operation. The operations between
	// gtk_text_buffer_begin_user_action() and gtk_text_buffer_end_user_action()
	// can then be grouped when creating an undo stack. TextBuffer maintains a
	// count of calls to gtk_text_buffer_begin_user_action() that have not been
	// closed with a call to gtk_text_buffer_end_user_action(), and emits the
	// “begin-user-action” and “end-user-action” signals only for the outermost
	// pair of calls. This allows you to build user actions from other user
	// actions.
	//
	// The “interactive” buffer mutation functions, such as
	// gtk_text_buffer_insert_interactive(), automatically call begin/end user
	// action around the buffer operations they perform, so there's no need to
	// add extra calls if you user action consists solely of a single call to
	// one of those functions.
	BeginUserAction()
	// CopyClipboard copies the currently-selected text to a clipboard.
	CopyClipboard(clipboard gdk.Clipboard)
	// CreateChildAnchor: this is a convenience function which simply creates a
	// child anchor with gtk_text_child_anchor_new() and inserts it into the
	// buffer with gtk_text_buffer_insert_child_anchor(). The new anchor is
	// owned by the buffer; no reference count is returned to the caller of
	// gtk_text_buffer_create_child_anchor().
	CreateChildAnchor(iter *TextIter) TextChildAnchor
	// CreateMark creates a mark at position @where. If @mark_name is nil, the
	// mark is anonymous; otherwise, the mark can be retrieved by name using
	// gtk_text_buffer_get_mark(). If a mark has left gravity, and text is
	// inserted at the mark’s current location, the mark will be moved to the
	// left of the newly-inserted text. If the mark has right gravity
	// (@left_gravity = false), the mark will end up on the right of
	// newly-inserted text. The standard left-to-right cursor is a mark with
	// right gravity (when you type, the cursor stays on the right side of the
	// text you’re typing).
	//
	// The caller of this function does not own a reference to the returned
	// TextMark, so you can ignore the return value if you like. Marks are owned
	// by the buffer and go away when the buffer does.
	//
	// Emits the TextBuffer::mark-set signal as notification of the mark's
	// initial placement.
	CreateMark(markName string, where *TextIter, leftGravity bool) TextMark
	// CutClipboard copies the currently-selected text to a clipboard, then
	// deletes said text if it’s editable.
	CutClipboard(clipboard gdk.Clipboard, defaultEditable bool)
	// Delete deletes text between @start and @end. The order of @start and @end
	// is not actually relevant; gtk_text_buffer_delete() will reorder them.
	// This function actually emits the “delete-range” signal, and the default
	// handler of that signal deletes the text. Because the buffer is modified,
	// all outstanding iterators become invalid after calling this function;
	// however, the @start and @end will be re-initialized to point to the
	// location where text was deleted.
	Delete(start *TextIter, end *TextIter)
	// DeleteInteractive deletes all editable text in the given range. Calls
	// gtk_text_buffer_delete() for each editable sub-range of [@start,@end).
	// @start and @end are revalidated to point to the location of the last
	// deleted range, or left untouched if no text was deleted.
	DeleteInteractive(startIter *TextIter, endIter *TextIter, defaultEditable bool) bool
	// DeleteMark deletes @mark, so that it’s no longer located anywhere in the
	// buffer. Removes the reference the buffer holds to the mark, so if you
	// haven’t called g_object_ref() on the mark, it will be freed. Even if the
	// mark isn’t freed, most operations on @mark become invalid, until it gets
	// added to a buffer again with gtk_text_buffer_add_mark(). Use
	// gtk_text_mark_get_deleted() to find out if a mark has been removed from
	// its buffer. The TextBuffer::mark-deleted signal will be emitted as
	// notification after the mark is deleted.
	DeleteMark(mark TextMark)
	// DeleteMarkByName deletes the mark named @name; the mark must exist. See
	// gtk_text_buffer_delete_mark() for details.
	DeleteMarkByName(name string)
	// DeleteSelection deletes the range between the “insert” and
	// “selection_bound” marks, that is, the currently-selected text. If
	// @interactive is true, the editability of the selection will be considered
	// (users can’t delete uneditable text).
	DeleteSelection(interactive bool, defaultEditable bool) bool
	// EndIrreversibleAction denotes the end of an action that may not be
	// undone. This will cause any previous operations in the undo/redo queue to
	// be cleared.
	//
	// This should be called after completing modifications to the text buffer
	// after gtk_text_buffer_begin_irreversible_action() was called.
	//
	// You may nest calls to gtk_text_buffer_begin_irreversible_action() and
	// gtk_text_buffer_end_irreversible_action() pairs.
	EndIrreversibleAction()
	// EndUserAction: should be paired with a call to
	// gtk_text_buffer_begin_user_action(). See that function for a full
	// explanation.
	EndUserAction()
	// Bounds retrieves the first and last iterators in the buffer, i.e. the
	// entire buffer lies within the range [@start,@end).
	Bounds() (start TextIter, end TextIter)
	// CanRedo gets whether there is a redoable action in the history.
	CanRedo() bool
	// CanUndo gets whether there is an undoable action in the history.
	CanUndo() bool
	// CharCount gets the number of characters in the buffer; note that
	// characters and bytes are not the same, you can’t e.g. expect the contents
	// of the buffer in string form to be this many bytes long. The character
	// count is cached, so this function is very fast.
	CharCount() int
	// EnableUndo gets whether the buffer is saving modifications to the buffer
	// to allow for undo and redo actions.
	//
	// See gtk_text_buffer_begin_irreversible_action() and
	// gtk_text_buffer_end_irreversible_action() to create changes to the buffer
	// that cannot be undone.
	EnableUndo() bool
	// EndIter initializes @iter with the “end iterator,” one past the last
	// valid character in the text buffer. If dereferenced with
	// gtk_text_iter_get_char(), the end iterator has a character value of 0.
	// The entire buffer lies in the range from the first position in the buffer
	// (call gtk_text_buffer_get_start_iter() to get character position 0) to
	// the end iterator.
	EndIter() TextIter
	// HasSelection indicates whether the buffer has some text currently
	// selected.
	HasSelection() bool
	// GetInsert returns the mark that represents the cursor (insertion point).
	// Equivalent to calling gtk_text_buffer_get_mark() to get the mark named
	// “insert”, but very slightly more efficient, and involves less typing.
	GetInsert() TextMark
	// IterAtChildAnchor obtains the location of @anchor within @buffer.
	IterAtChildAnchor(anchor TextChildAnchor) TextIter
	// IterAtLine initializes @iter to the start of the given line. If
	// @line_number is greater than the number of lines in the @buffer, the end
	// iterator is returned.
	IterAtLine(lineNumber int) (iter TextIter, ok bool)
	// IterAtLineIndex obtains an iterator pointing to @byte_index within the
	// given line. @byte_index must be the start of a UTF-8 character. Note
	// bytes, not characters; UTF-8 may encode one character as multiple bytes.
	//
	// If @line_number is greater than the number of lines in the @buffer, the
	// end iterator is returned. And if @byte_index is off the end of the line,
	// the iterator at the end of the line is returned.
	IterAtLineIndex(lineNumber int, byteIndex int) (iter TextIter, ok bool)
	// IterAtLineOffset obtains an iterator pointing to @char_offset within the
	// given line. Note characters, not bytes; UTF-8 may encode one character as
	// multiple bytes.
	//
	// Before the 3.20 version, it was not allowed to pass an invalid location.
	//
	// If @line_number is greater than the number of lines in the @buffer, the
	// end iterator is returned. And if @char_offset is off the end of the line,
	// the iterator at the end of the line is returned.
	IterAtLineOffset(lineNumber int, charOffset int) (iter TextIter, ok bool)
	// IterAtMark initializes @iter with the current position of @mark.
	IterAtMark(mark TextMark) TextIter
	// IterAtOffset initializes @iter to a position @char_offset chars from the
	// start of the entire buffer. If @char_offset is -1 or greater than the
	// number of characters in the buffer, @iter is initialized to the end
	// iterator, the iterator one past the last valid character in the buffer.
	IterAtOffset(charOffset int) TextIter
	// LineCount obtains the number of lines in the buffer. This value is
	// cached, so the function is very fast.
	LineCount() int
	// Mark returns the mark named @name in buffer @buffer, or nil if no such
	// mark exists in the buffer.
	Mark(name string) TextMark
	// MaxUndoLevels gets the maximum number of undo levels to perform. If 0,
	// unlimited undo actions may be performed. Note that this may have a memory
	// usage impact as it requires storing an additional copy of the inserted or
	// removed text within the text buffer.
	MaxUndoLevels() uint
	// Modified indicates whether the buffer has been modified since the last
	// call to gtk_text_buffer_set_modified() set the modification flag to
	// false. Used for example to enable a “save” function in a text editor.
	Modified() bool
	// SelectionBound returns the mark that represents the selection bound.
	// Equivalent to calling gtk_text_buffer_get_mark() to get the mark named
	// “selection_bound”, but very slightly more efficient, and involves less
	// typing.
	//
	// The currently-selected text in @buffer is the region between the
	// “selection_bound” and “insert” marks. If “selection_bound” and “insert”
	// are in the same place, then there is no current selection.
	// gtk_text_buffer_get_selection_bounds() is another convenient function for
	// handling the selection, if you just want to know whether there’s a
	// selection and what its bounds are.
	SelectionBound() TextMark
	// SelectionBounds returns true if some text is selected; places the bounds
	// of the selection in @start and @end (if the selection has length 0, then
	// @start and @end are filled in with the same value). @start and @end will
	// be in ascending order. If @start and @end are NULL, then they are not
	// filled in, but the return value still indicates whether text is selected.
	SelectionBounds() (start TextIter, end TextIter, ok bool)
	// SelectionContent: get a content provider for this buffer. It can be used
	// to make the content of @buffer available in a Clipboard, see
	// gdk_clipboard_set_content().
	SelectionContent() gdk.ContentProvider
	// Slice returns the text in the range [@start,@end). Excludes undisplayed
	// text (text marked with tags that set the invisibility attribute) if
	// @include_hidden_chars is false. The returned string includes a 0xFFFC
	// character whenever the buffer contains embedded images, so byte and
	// character indexes into the returned string do correspond to byte and
	// character indexes into the buffer. Contrast with
	// gtk_text_buffer_get_text(). Note that 0xFFFC can occur in normal text as
	// well, so it is not a reliable indicator that a paintable or widget is in
	// the buffer.
	Slice(start *TextIter, end *TextIter, includeHiddenChars bool) string
	// StartIter: initialized @iter with the first position in the text buffer.
	// This is the same as using gtk_text_buffer_get_iter_at_offset() to get the
	// iter at character offset 0.
	StartIter() TextIter
	// TagTable: get the TextTagTable associated with this buffer.
	TagTable() TextTagTable
	// Text returns the text in the range [@start,@end). Excludes undisplayed
	// text (text marked with tags that set the invisibility attribute) if
	// @include_hidden_chars is false. Does not include characters representing
	// embedded images, so byte and character indexes into the returned string
	// do not correspond to byte and character indexes into the buffer. Contrast
	// with gtk_text_buffer_get_slice().
	Text(start *TextIter, end *TextIter, includeHiddenChars bool) string
	// Insert inserts @len bytes of @text at position @iter. If @len is -1,
	// @text must be nul-terminated and will be inserted in its entirety. Emits
	// the “insert-text” signal; insertion actually occurs in the default
	// handler for the signal. @iter is invalidated when insertion occurs
	// (because the buffer contents change), but the default signal handler
	// revalidates it to point to the end of the inserted text.
	Insert(iter *TextIter, text string, len int)
	// InsertAtCursor: simply calls gtk_text_buffer_insert(), using the current
	// cursor position as the insertion point.
	InsertAtCursor(text string, len int)
	// InsertChildAnchor inserts a child widget anchor into the text buffer at
	// @iter. The anchor will be counted as one character in character counts,
	// and when obtaining the buffer contents as a string, will be represented
	// by the Unicode “object replacement character” 0xFFFC. Note that the
	// “slice” variants for obtaining portions of the buffer as a string include
	// this character for child anchors, but the “text” variants do not. E.g.
	// see gtk_text_buffer_get_slice() and gtk_text_buffer_get_text(). Consider
	// gtk_text_buffer_create_child_anchor() as a more convenient alternative to
	// this function. The buffer will add a reference to the anchor, so you can
	// unref it after insertion.
	InsertChildAnchor(iter *TextIter, anchor TextChildAnchor)
	// InsertInteractive: like gtk_text_buffer_insert(), but the insertion will
	// not occur if @iter is at a non-editable location in the buffer. Usually
	// you want to prevent insertions at ineditable locations if the insertion
	// results from a user action (is interactive).
	//
	// @default_editable indicates the editability of text that doesn't have a
	// tag affecting editability applied to it. Typically the result of
	// gtk_text_view_get_editable() is appropriate here.
	InsertInteractive(iter *TextIter, text string, len int, defaultEditable bool) bool
	// InsertInteractiveAtCursor calls gtk_text_buffer_insert_interactive() at
	// the cursor position.
	//
	// @default_editable indicates the editability of text that doesn't have a
	// tag affecting editability applied to it. Typically the result of
	// gtk_text_view_get_editable() is appropriate here.
	InsertInteractiveAtCursor(text string, len int, defaultEditable bool) bool
	// InsertMarkup inserts the text in @markup at position @iter. @markup will
	// be inserted in its entirety and must be nul-terminated and valid UTF-8.
	// Emits the TextBuffer::insert-text signal, possibly multiple times;
	// insertion actually occurs in the default handler for the signal. @iter
	// will point to the end of the inserted text on return.
	InsertMarkup(iter *TextIter, markup string, len int)
	// InsertPaintable inserts an image into the text buffer at @iter. The image
	// will be counted as one character in character counts, and when obtaining
	// the buffer contents as a string, will be represented by the Unicode
	// “object replacement character” 0xFFFC. Note that the “slice” variants for
	// obtaining portions of the buffer as a string include this character for
	// paintable, but the “text” variants do not. e.g. see
	// gtk_text_buffer_get_slice() and gtk_text_buffer_get_text().
	InsertPaintable(iter *TextIter, paintable gdk.Paintable)
	// InsertRange copies text, tags, and paintables between @start and @end
	// (the order of @start and @end doesn’t matter) and inserts the copy at
	// @iter. Used instead of simply getting/inserting text because it preserves
	// images and tags. If @start and @end are in a different buffer from
	// @buffer, the two buffers must share the same tag table.
	//
	// Implemented via emissions of the insert_text and apply_tag signals, so
	// expect those.
	InsertRange(iter *TextIter, start *TextIter, end *TextIter)
	// InsertRangeInteractive: same as gtk_text_buffer_insert_range(), but does
	// nothing if the insertion point isn’t editable. The @default_editable
	// parameter indicates whether the text is editable at @iter if no tags
	// enclosing @iter affect editability. Typically the result of
	// gtk_text_view_get_editable() is appropriate here.
	InsertRangeInteractive(iter *TextIter, start *TextIter, end *TextIter, defaultEditable bool) bool
	// MoveMark moves @mark to the new location @where. Emits the
	// TextBuffer::mark-set signal as notification of the move.
	MoveMark(mark TextMark, where *TextIter)
	// MoveMarkByName moves the mark named @name (which must exist) to location
	// @where. See gtk_text_buffer_move_mark() for details.
	MoveMarkByName(name string, where *TextIter)
	// PasteClipboard pastes the contents of a clipboard. If @override_location
	// is nil, the pasted text will be inserted at the cursor position, or the
	// buffer selection will be replaced if the selection is non-empty.
	//
	// Note: pasting is asynchronous, that is, we’ll ask for the paste data and
	// return, and at some point later after the main loop runs, the paste data
	// will be inserted.
	PasteClipboard(clipboard gdk.Clipboard, overrideLocation *TextIter, defaultEditable bool)
	// PlaceCursor: this function moves the “insert” and “selection_bound” marks
	// simultaneously. If you move them to the same place in two steps with
	// gtk_text_buffer_move_mark(), you will temporarily select a region in
	// between their old and new locations, which can be pretty inefficient
	// since the temporarily-selected region will force stuff to be
	// recalculated. This function moves them as a unit, which can be optimized.
	PlaceCursor(where *TextIter)
	// Redo redoes the next redoable action on the buffer, if there is one.
	Redo()
	// RemoveAllTags removes all tags in the range between @start and @end. Be
	// careful with this function; it could remove tags added in code unrelated
	// to the code you’re currently writing. That is, using this function is
	// probably a bad idea if you have two or more unrelated code sections that
	// add tags.
	RemoveAllTags(start *TextIter, end *TextIter)
	// RemoveSelectionClipboard removes a Clipboard added with
	// gtk_text_buffer_add_selection_clipboard().
	RemoveSelectionClipboard(clipboard gdk.Clipboard)
	// RemoveTag emits the “remove-tag” signal. The default handler for the
	// signal removes all occurrences of @tag from the given range. @start and
	// @end don’t have to be in order.
	RemoveTag(tag TextTag, start *TextIter, end *TextIter)
	// RemoveTagByName calls gtk_text_tag_table_lookup() on the buffer’s tag
	// table to get a TextTag, then calls gtk_text_buffer_remove_tag().
	RemoveTagByName(name string, start *TextIter, end *TextIter)
	// SelectRange: this function moves the “insert” and “selection_bound” marks
	// simultaneously. If you move them in two steps with
	// gtk_text_buffer_move_mark(), you will temporarily select a region in
	// between their old and new locations, which can be pretty inefficient
	// since the temporarily-selected region will force stuff to be
	// recalculated. This function moves them as a unit, which can be optimized.
	SelectRange(ins *TextIter, bound *TextIter)
	// SetEnableUndo sets whether or not to enable undoable actions in the text
	// buffer. If enabled, the user will be able to undo the last number of
	// actions up to gtk_text_buffer_get_max_undo_levels().
	//
	// See gtk_text_buffer_begin_irreversible_action() and
	// gtk_text_buffer_end_irreversible_action() to create changes to the buffer
	// that cannot be undone.
	SetEnableUndo(enableUndo bool)
	// SetMaxUndoLevels sets the maximum number of undo levels to perform. If 0,
	// unlimited undo actions may be performed. Note that this may have a memory
	// usage impact as it requires storing an additional copy of the inserted or
	// removed text within the text buffer.
	SetMaxUndoLevels(maxUndoLevels uint)
	// SetModified: used to keep track of whether the buffer has been modified
	// since the last time it was saved. Whenever the buffer is saved to disk,
	// call gtk_text_buffer_set_modified (@buffer, FALSE). When the buffer is
	// modified, it will automatically toggled on the modified bit again. When
	// the modified bit flips, the buffer emits the TextBuffer::modified-changed
	// signal.
	SetModified(setting bool)
	// SetText deletes current contents of @buffer, and inserts @text instead.
	// If @len is -1, @text must be nul-terminated. @text must be valid UTF-8.
	SetText(text string, len int)
	// Undo undoes the last undoable action on the buffer, if there is one.
	Undo()
}

type textBuffer struct {
	*externglib.Object
}

// WrapTextBuffer wraps a GObject to the right type. It is
// primarily used internally.
func WrapTextBuffer(obj *externglib.Object) TextBuffer {
	return textBuffer{*externglib.Object{obj}}
}

func marshalTextBuffer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTextBuffer(obj), nil
}

// NewTextBuffer constructs a class TextBuffer.
func NewTextBuffer(table TextTagTable) TextBuffer {
	var arg1 *C.GtkTextTagTable

	arg1 = (*C.GtkTextTagTable)(table.Native())

	ret := C.gtk_text_buffer_new(arg1)

	var ret0 TextBuffer

	ret0 = WrapTextBuffer(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// AddMark adds the mark at position @where. The mark must not be added to
// another buffer, and if its name is not nil then there must not be another
// mark in the buffer with the same name.
//
// Emits the TextBuffer::mark-set signal as notification of the mark's
// initial placement.
func (buffer textBuffer) AddMark(mark TextMark, where *TextIter) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextMark
	var arg2 *C.GtkTextIter

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg1 = (*C.GtkTextMark)(mark.Native())
	arg2 = (*C.GtkTextIter)(where.Native())

	C.gtk_text_buffer_add_mark(arg0, arg1, arg2)
}

// AddSelectionClipboard adds @clipboard to the list of clipboards in which
// the selection contents of @buffer are available. In most cases,
// @clipboard will be the Clipboard returned by
// gtk_widget_get_primary_clipboard() for a view of @buffer.
func (buffer textBuffer) AddSelectionClipboard(clipboard gdk.Clipboard) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GdkClipboard

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg1 = (*C.GdkClipboard)(clipboard.Native())

	C.gtk_text_buffer_add_selection_clipboard(arg0, arg1)
}

// ApplyTag emits the “apply-tag” signal on @buffer. The default handler for
// the signal applies @tag to the given range. @start and @end do not have
// to be in order.
func (buffer textBuffer) ApplyTag(tag TextTag, start *TextIter, end *TextIter) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextTag
	var arg2 *C.GtkTextIter
	var arg3 *C.GtkTextIter

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg1 = (*C.GtkTextTag)(tag.Native())
	arg2 = (*C.GtkTextIter)(start.Native())
	arg3 = (*C.GtkTextIter)(end.Native())

	C.gtk_text_buffer_apply_tag(arg0, arg1, arg2, arg3)
}

// ApplyTagByName calls gtk_text_tag_table_lookup() on the buffer’s tag
// table to get a TextTag, then calls gtk_text_buffer_apply_tag().
func (buffer textBuffer) ApplyTagByName(name string, start *TextIter, end *TextIter) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.char
	var arg2 *C.GtkTextIter
	var arg3 *C.GtkTextIter

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GtkTextIter)(start.Native())
	arg3 = (*C.GtkTextIter)(end.Native())

	C.gtk_text_buffer_apply_tag_by_name(arg0, arg1, arg2, arg3)
}

// Backspace performs the appropriate action as if the user hit the delete
// key with the cursor at the position specified by @iter. In the normal
// case a single character will be deleted, but when combining accents are
// involved, more than one character can be deleted, and when precomposed
// character and accent combinations are involved, less than one character
// will be deleted.
//
// Because the buffer is modified, all outstanding iterators become invalid
// after calling this function; however, the @iter will be re-initialized to
// point to the location where text was deleted.
func (buffer textBuffer) Backspace(iter *TextIter, interactive bool, defaultEditable bool) bool {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextIter
	var arg2 C.gboolean
	var arg3 C.gboolean

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg1 = (*C.GtkTextIter)(iter.Native())
	arg2 = gextras.Cbool(interactive)
	arg3 = gextras.Cbool(defaultEditable)

	ret := C.gtk_text_buffer_backspace(arg0, arg1, arg2, arg3)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// BeginIrreversibleAction denotes the beginning of an action that may not
// be undone. This will cause any previous operations in the undo/redo queue
// to be cleared.
//
// This should be paired with a call to
// gtk_text_buffer_end_irreversible_action() after the irreversible action
// has completed.
//
// You may nest calls to gtk_text_buffer_begin_irreversible_action() and
// gtk_text_buffer_end_irreversible_action() pairs.
func (buffer textBuffer) BeginIrreversibleAction() {
	var arg0 *C.GtkTextBuffer

	arg0 = (*C.GtkTextBuffer)(buffer.Native())

	C.gtk_text_buffer_begin_irreversible_action(arg0)
}

// BeginUserAction: called to indicate that the buffer operations between
// here and a call to gtk_text_buffer_end_user_action() are part of a single
// user-visible operation. The operations between
// gtk_text_buffer_begin_user_action() and gtk_text_buffer_end_user_action()
// can then be grouped when creating an undo stack. TextBuffer maintains a
// count of calls to gtk_text_buffer_begin_user_action() that have not been
// closed with a call to gtk_text_buffer_end_user_action(), and emits the
// “begin-user-action” and “end-user-action” signals only for the outermost
// pair of calls. This allows you to build user actions from other user
// actions.
//
// The “interactive” buffer mutation functions, such as
// gtk_text_buffer_insert_interactive(), automatically call begin/end user
// action around the buffer operations they perform, so there's no need to
// add extra calls if you user action consists solely of a single call to
// one of those functions.
func (buffer textBuffer) BeginUserAction() {
	var arg0 *C.GtkTextBuffer

	arg0 = (*C.GtkTextBuffer)(buffer.Native())

	C.gtk_text_buffer_begin_user_action(arg0)
}

// CopyClipboard copies the currently-selected text to a clipboard.
func (buffer textBuffer) CopyClipboard(clipboard gdk.Clipboard) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GdkClipboard

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg1 = (*C.GdkClipboard)(clipboard.Native())

	C.gtk_text_buffer_copy_clipboard(arg0, arg1)
}

// CreateChildAnchor: this is a convenience function which simply creates a
// child anchor with gtk_text_child_anchor_new() and inserts it into the
// buffer with gtk_text_buffer_insert_child_anchor(). The new anchor is
// owned by the buffer; no reference count is returned to the caller of
// gtk_text_buffer_create_child_anchor().
func (buffer textBuffer) CreateChildAnchor(iter *TextIter) TextChildAnchor {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextIter

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg1 = (*C.GtkTextIter)(iter.Native())

	ret := C.gtk_text_buffer_create_child_anchor(arg0, arg1)

	var ret0 TextChildAnchor

	ret0 = WrapTextChildAnchor(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// CreateMark creates a mark at position @where. If @mark_name is nil, the
// mark is anonymous; otherwise, the mark can be retrieved by name using
// gtk_text_buffer_get_mark(). If a mark has left gravity, and text is
// inserted at the mark’s current location, the mark will be moved to the
// left of the newly-inserted text. If the mark has right gravity
// (@left_gravity = false), the mark will end up on the right of
// newly-inserted text. The standard left-to-right cursor is a mark with
// right gravity (when you type, the cursor stays on the right side of the
// text you’re typing).
//
// The caller of this function does not own a reference to the returned
// TextMark, so you can ignore the return value if you like. Marks are owned
// by the buffer and go away when the buffer does.
//
// Emits the TextBuffer::mark-set signal as notification of the mark's
// initial placement.
func (buffer textBuffer) CreateMark(markName string, where *TextIter, leftGravity bool) TextMark {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.char
	var arg2 *C.GtkTextIter
	var arg3 C.gboolean

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg1 = (*C.gchar)(C.CString(markName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GtkTextIter)(where.Native())
	arg3 = gextras.Cbool(leftGravity)

	ret := C.gtk_text_buffer_create_mark(arg0, arg1, arg2, arg3)

	var ret0 TextMark

	ret0 = WrapTextMark(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// CutClipboard copies the currently-selected text to a clipboard, then
// deletes said text if it’s editable.
func (buffer textBuffer) CutClipboard(clipboard gdk.Clipboard, defaultEditable bool) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GdkClipboard
	var arg2 C.gboolean

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg1 = (*C.GdkClipboard)(clipboard.Native())
	arg2 = gextras.Cbool(defaultEditable)

	C.gtk_text_buffer_cut_clipboard(arg0, arg1, arg2)
}

// Delete deletes text between @start and @end. The order of @start and @end
// is not actually relevant; gtk_text_buffer_delete() will reorder them.
// This function actually emits the “delete-range” signal, and the default
// handler of that signal deletes the text. Because the buffer is modified,
// all outstanding iterators become invalid after calling this function;
// however, the @start and @end will be re-initialized to point to the
// location where text was deleted.
func (buffer textBuffer) Delete(start *TextIter, end *TextIter) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextIter
	var arg2 *C.GtkTextIter

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg1 = (*C.GtkTextIter)(start.Native())
	arg2 = (*C.GtkTextIter)(end.Native())

	C.gtk_text_buffer_delete(arg0, arg1, arg2)
}

// DeleteInteractive deletes all editable text in the given range. Calls
// gtk_text_buffer_delete() for each editable sub-range of [@start,@end).
// @start and @end are revalidated to point to the location of the last
// deleted range, or left untouched if no text was deleted.
func (buffer textBuffer) DeleteInteractive(startIter *TextIter, endIter *TextIter, defaultEditable bool) bool {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextIter
	var arg2 *C.GtkTextIter
	var arg3 C.gboolean

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg1 = (*C.GtkTextIter)(startIter.Native())
	arg2 = (*C.GtkTextIter)(endIter.Native())
	arg3 = gextras.Cbool(defaultEditable)

	ret := C.gtk_text_buffer_delete_interactive(arg0, arg1, arg2, arg3)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// DeleteMark deletes @mark, so that it’s no longer located anywhere in the
// buffer. Removes the reference the buffer holds to the mark, so if you
// haven’t called g_object_ref() on the mark, it will be freed. Even if the
// mark isn’t freed, most operations on @mark become invalid, until it gets
// added to a buffer again with gtk_text_buffer_add_mark(). Use
// gtk_text_mark_get_deleted() to find out if a mark has been removed from
// its buffer. The TextBuffer::mark-deleted signal will be emitted as
// notification after the mark is deleted.
func (buffer textBuffer) DeleteMark(mark TextMark) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextMark

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg1 = (*C.GtkTextMark)(mark.Native())

	C.gtk_text_buffer_delete_mark(arg0, arg1)
}

// DeleteMarkByName deletes the mark named @name; the mark must exist. See
// gtk_text_buffer_delete_mark() for details.
func (buffer textBuffer) DeleteMarkByName(name string) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.char

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_text_buffer_delete_mark_by_name(arg0, arg1)
}

// DeleteSelection deletes the range between the “insert” and
// “selection_bound” marks, that is, the currently-selected text. If
// @interactive is true, the editability of the selection will be considered
// (users can’t delete uneditable text).
func (buffer textBuffer) DeleteSelection(interactive bool, defaultEditable bool) bool {
	var arg0 *C.GtkTextBuffer
	var arg1 C.gboolean
	var arg2 C.gboolean

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg1 = gextras.Cbool(interactive)
	arg2 = gextras.Cbool(defaultEditable)

	ret := C.gtk_text_buffer_delete_selection(arg0, arg1, arg2)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// EndIrreversibleAction denotes the end of an action that may not be
// undone. This will cause any previous operations in the undo/redo queue to
// be cleared.
//
// This should be called after completing modifications to the text buffer
// after gtk_text_buffer_begin_irreversible_action() was called.
//
// You may nest calls to gtk_text_buffer_begin_irreversible_action() and
// gtk_text_buffer_end_irreversible_action() pairs.
func (buffer textBuffer) EndIrreversibleAction() {
	var arg0 *C.GtkTextBuffer

	arg0 = (*C.GtkTextBuffer)(buffer.Native())

	C.gtk_text_buffer_end_irreversible_action(arg0)
}

// EndUserAction: should be paired with a call to
// gtk_text_buffer_begin_user_action(). See that function for a full
// explanation.
func (buffer textBuffer) EndUserAction() {
	var arg0 *C.GtkTextBuffer

	arg0 = (*C.GtkTextBuffer)(buffer.Native())

	C.gtk_text_buffer_end_user_action(arg0)
}

// Bounds retrieves the first and last iterators in the buffer, i.e. the
// entire buffer lies within the range [@start,@end).
func (buffer textBuffer) Bounds() (start TextIter, end TextIter) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextIter // out
	var arg2 *C.GtkTextIter // out

	arg0 = (*C.GtkTextBuffer)(buffer.Native())

	ret := C.gtk_text_buffer_get_bounds(arg0, &arg1, &arg2)

	var ret0 *TextIter
	var ret1 *TextIter

	ret0 = WrapTextIter(arg1)

	ret1 = WrapTextIter(arg2)

	return ret0, ret1
}

// CanRedo gets whether there is a redoable action in the history.
func (buffer textBuffer) CanRedo() bool {
	var arg0 *C.GtkTextBuffer

	arg0 = (*C.GtkTextBuffer)(buffer.Native())

	ret := C.gtk_text_buffer_get_can_redo(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// CanUndo gets whether there is an undoable action in the history.
func (buffer textBuffer) CanUndo() bool {
	var arg0 *C.GtkTextBuffer

	arg0 = (*C.GtkTextBuffer)(buffer.Native())

	ret := C.gtk_text_buffer_get_can_undo(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// CharCount gets the number of characters in the buffer; note that
// characters and bytes are not the same, you can’t e.g. expect the contents
// of the buffer in string form to be this many bytes long. The character
// count is cached, so this function is very fast.
func (buffer textBuffer) CharCount() int {
	var arg0 *C.GtkTextBuffer

	arg0 = (*C.GtkTextBuffer)(buffer.Native())

	ret := C.gtk_text_buffer_get_char_count(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// EnableUndo gets whether the buffer is saving modifications to the buffer
// to allow for undo and redo actions.
//
// See gtk_text_buffer_begin_irreversible_action() and
// gtk_text_buffer_end_irreversible_action() to create changes to the buffer
// that cannot be undone.
func (buffer textBuffer) EnableUndo() bool {
	var arg0 *C.GtkTextBuffer

	arg0 = (*C.GtkTextBuffer)(buffer.Native())

	ret := C.gtk_text_buffer_get_enable_undo(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// EndIter initializes @iter with the “end iterator,” one past the last
// valid character in the text buffer. If dereferenced with
// gtk_text_iter_get_char(), the end iterator has a character value of 0.
// The entire buffer lies in the range from the first position in the buffer
// (call gtk_text_buffer_get_start_iter() to get character position 0) to
// the end iterator.
func (buffer textBuffer) EndIter() TextIter {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextIter // out

	arg0 = (*C.GtkTextBuffer)(buffer.Native())

	ret := C.gtk_text_buffer_get_end_iter(arg0, &arg1)

	var ret0 *TextIter

	ret0 = WrapTextIter(arg1)

	return ret0
}

// HasSelection indicates whether the buffer has some text currently
// selected.
func (buffer textBuffer) HasSelection() bool {
	var arg0 *C.GtkTextBuffer

	arg0 = (*C.GtkTextBuffer)(buffer.Native())

	ret := C.gtk_text_buffer_get_has_selection(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// GetInsert returns the mark that represents the cursor (insertion point).
// Equivalent to calling gtk_text_buffer_get_mark() to get the mark named
// “insert”, but very slightly more efficient, and involves less typing.
func (buffer textBuffer) GetInsert() TextMark {
	var arg0 *C.GtkTextBuffer

	arg0 = (*C.GtkTextBuffer)(buffer.Native())

	ret := C.gtk_text_buffer_get_insert(arg0)

	var ret0 TextMark

	ret0 = WrapTextMark(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// IterAtChildAnchor obtains the location of @anchor within @buffer.
func (buffer textBuffer) IterAtChildAnchor(anchor TextChildAnchor) TextIter {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextIter // out
	var arg2 *C.GtkTextChildAnchor

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg2 = (*C.GtkTextChildAnchor)(anchor.Native())

	ret := C.gtk_text_buffer_get_iter_at_child_anchor(arg0, &arg1, arg2)

	var ret0 *TextIter

	ret0 = WrapTextIter(arg1)

	return ret0
}

// IterAtLine initializes @iter to the start of the given line. If
// @line_number is greater than the number of lines in the @buffer, the end
// iterator is returned.
func (buffer textBuffer) IterAtLine(lineNumber int) (iter TextIter, ok bool) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextIter // out
	var arg2 C.int

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg2 = C.int(lineNumber)

	ret := C.gtk_text_buffer_get_iter_at_line(arg0, &arg1, arg2)

	var ret0 *TextIter
	var ret1 bool

	ret0 = WrapTextIter(arg1)

	ret1 = gextras.Gobool(ret)

	return ret0, ret1
}

// IterAtLineIndex obtains an iterator pointing to @byte_index within the
// given line. @byte_index must be the start of a UTF-8 character. Note
// bytes, not characters; UTF-8 may encode one character as multiple bytes.
//
// If @line_number is greater than the number of lines in the @buffer, the
// end iterator is returned. And if @byte_index is off the end of the line,
// the iterator at the end of the line is returned.
func (buffer textBuffer) IterAtLineIndex(lineNumber int, byteIndex int) (iter TextIter, ok bool) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextIter // out
	var arg2 C.int
	var arg3 C.int

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg2 = C.int(lineNumber)
	arg3 = C.int(byteIndex)

	ret := C.gtk_text_buffer_get_iter_at_line_index(arg0, &arg1, arg2, arg3)

	var ret0 *TextIter
	var ret1 bool

	ret0 = WrapTextIter(arg1)

	ret1 = gextras.Gobool(ret)

	return ret0, ret1
}

// IterAtLineOffset obtains an iterator pointing to @char_offset within the
// given line. Note characters, not bytes; UTF-8 may encode one character as
// multiple bytes.
//
// Before the 3.20 version, it was not allowed to pass an invalid location.
//
// If @line_number is greater than the number of lines in the @buffer, the
// end iterator is returned. And if @char_offset is off the end of the line,
// the iterator at the end of the line is returned.
func (buffer textBuffer) IterAtLineOffset(lineNumber int, charOffset int) (iter TextIter, ok bool) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextIter // out
	var arg2 C.int
	var arg3 C.int

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg2 = C.int(lineNumber)
	arg3 = C.int(charOffset)

	ret := C.gtk_text_buffer_get_iter_at_line_offset(arg0, &arg1, arg2, arg3)

	var ret0 *TextIter
	var ret1 bool

	ret0 = WrapTextIter(arg1)

	ret1 = gextras.Gobool(ret)

	return ret0, ret1
}

// IterAtMark initializes @iter with the current position of @mark.
func (buffer textBuffer) IterAtMark(mark TextMark) TextIter {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextIter // out
	var arg2 *C.GtkTextMark

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg2 = (*C.GtkTextMark)(mark.Native())

	ret := C.gtk_text_buffer_get_iter_at_mark(arg0, &arg1, arg2)

	var ret0 *TextIter

	ret0 = WrapTextIter(arg1)

	return ret0
}

// IterAtOffset initializes @iter to a position @char_offset chars from the
// start of the entire buffer. If @char_offset is -1 or greater than the
// number of characters in the buffer, @iter is initialized to the end
// iterator, the iterator one past the last valid character in the buffer.
func (buffer textBuffer) IterAtOffset(charOffset int) TextIter {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextIter // out
	var arg2 C.int

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg2 = C.int(charOffset)

	ret := C.gtk_text_buffer_get_iter_at_offset(arg0, &arg1, arg2)

	var ret0 *TextIter

	ret0 = WrapTextIter(arg1)

	return ret0
}

// LineCount obtains the number of lines in the buffer. This value is
// cached, so the function is very fast.
func (buffer textBuffer) LineCount() int {
	var arg0 *C.GtkTextBuffer

	arg0 = (*C.GtkTextBuffer)(buffer.Native())

	ret := C.gtk_text_buffer_get_line_count(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Mark returns the mark named @name in buffer @buffer, or nil if no such
// mark exists in the buffer.
func (buffer textBuffer) Mark(name string) TextMark {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.char

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_text_buffer_get_mark(arg0, arg1)

	var ret0 TextMark

	ret0 = WrapTextMark(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// MaxUndoLevels gets the maximum number of undo levels to perform. If 0,
// unlimited undo actions may be performed. Note that this may have a memory
// usage impact as it requires storing an additional copy of the inserted or
// removed text within the text buffer.
func (buffer textBuffer) MaxUndoLevels() uint {
	var arg0 *C.GtkTextBuffer

	arg0 = (*C.GtkTextBuffer)(buffer.Native())

	ret := C.gtk_text_buffer_get_max_undo_levels(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// Modified indicates whether the buffer has been modified since the last
// call to gtk_text_buffer_set_modified() set the modification flag to
// false. Used for example to enable a “save” function in a text editor.
func (buffer textBuffer) Modified() bool {
	var arg0 *C.GtkTextBuffer

	arg0 = (*C.GtkTextBuffer)(buffer.Native())

	ret := C.gtk_text_buffer_get_modified(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// SelectionBound returns the mark that represents the selection bound.
// Equivalent to calling gtk_text_buffer_get_mark() to get the mark named
// “selection_bound”, but very slightly more efficient, and involves less
// typing.
//
// The currently-selected text in @buffer is the region between the
// “selection_bound” and “insert” marks. If “selection_bound” and “insert”
// are in the same place, then there is no current selection.
// gtk_text_buffer_get_selection_bounds() is another convenient function for
// handling the selection, if you just want to know whether there’s a
// selection and what its bounds are.
func (buffer textBuffer) SelectionBound() TextMark {
	var arg0 *C.GtkTextBuffer

	arg0 = (*C.GtkTextBuffer)(buffer.Native())

	ret := C.gtk_text_buffer_get_selection_bound(arg0)

	var ret0 TextMark

	ret0 = WrapTextMark(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// SelectionBounds returns true if some text is selected; places the bounds
// of the selection in @start and @end (if the selection has length 0, then
// @start and @end are filled in with the same value). @start and @end will
// be in ascending order. If @start and @end are NULL, then they are not
// filled in, but the return value still indicates whether text is selected.
func (buffer textBuffer) SelectionBounds() (start TextIter, end TextIter, ok bool) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextIter // out
	var arg2 *C.GtkTextIter // out

	arg0 = (*C.GtkTextBuffer)(buffer.Native())

	ret := C.gtk_text_buffer_get_selection_bounds(arg0, &arg1, &arg2)

	var ret0 *TextIter
	var ret1 *TextIter
	var ret2 bool

	ret0 = WrapTextIter(arg1)

	ret1 = WrapTextIter(arg2)

	ret2 = gextras.Gobool(ret)

	return ret0, ret1, ret2
}

// SelectionContent: get a content provider for this buffer. It can be used
// to make the content of @buffer available in a Clipboard, see
// gdk_clipboard_set_content().
func (buffer textBuffer) SelectionContent() gdk.ContentProvider {
	var arg0 *C.GtkTextBuffer

	arg0 = (*C.GtkTextBuffer)(buffer.Native())

	ret := C.gtk_text_buffer_get_selection_content(arg0)

	var ret0 gdk.ContentProvider

	ret0 = gdk.WrapContentProvider(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Slice returns the text in the range [@start,@end). Excludes undisplayed
// text (text marked with tags that set the invisibility attribute) if
// @include_hidden_chars is false. The returned string includes a 0xFFFC
// character whenever the buffer contains embedded images, so byte and
// character indexes into the returned string do correspond to byte and
// character indexes into the buffer. Contrast with
// gtk_text_buffer_get_text(). Note that 0xFFFC can occur in normal text as
// well, so it is not a reliable indicator that a paintable or widget is in
// the buffer.
func (buffer textBuffer) Slice(start *TextIter, end *TextIter, includeHiddenChars bool) string {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextIter
	var arg2 *C.GtkTextIter
	var arg3 C.gboolean

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg1 = (*C.GtkTextIter)(start.Native())
	arg2 = (*C.GtkTextIter)(end.Native())
	arg3 = gextras.Cbool(includeHiddenChars)

	ret := C.gtk_text_buffer_get_slice(arg0, arg1, arg2, arg3)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// StartIter: initialized @iter with the first position in the text buffer.
// This is the same as using gtk_text_buffer_get_iter_at_offset() to get the
// iter at character offset 0.
func (buffer textBuffer) StartIter() TextIter {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextIter // out

	arg0 = (*C.GtkTextBuffer)(buffer.Native())

	ret := C.gtk_text_buffer_get_start_iter(arg0, &arg1)

	var ret0 *TextIter

	ret0 = WrapTextIter(arg1)

	return ret0
}

// TagTable: get the TextTagTable associated with this buffer.
func (buffer textBuffer) TagTable() TextTagTable {
	var arg0 *C.GtkTextBuffer

	arg0 = (*C.GtkTextBuffer)(buffer.Native())

	ret := C.gtk_text_buffer_get_tag_table(arg0)

	var ret0 TextTagTable

	ret0 = WrapTextTagTable(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Text returns the text in the range [@start,@end). Excludes undisplayed
// text (text marked with tags that set the invisibility attribute) if
// @include_hidden_chars is false. Does not include characters representing
// embedded images, so byte and character indexes into the returned string
// do not correspond to byte and character indexes into the buffer. Contrast
// with gtk_text_buffer_get_slice().
func (buffer textBuffer) Text(start *TextIter, end *TextIter, includeHiddenChars bool) string {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextIter
	var arg2 *C.GtkTextIter
	var arg3 C.gboolean

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg1 = (*C.GtkTextIter)(start.Native())
	arg2 = (*C.GtkTextIter)(end.Native())
	arg3 = gextras.Cbool(includeHiddenChars)

	ret := C.gtk_text_buffer_get_text(arg0, arg1, arg2, arg3)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// Insert inserts @len bytes of @text at position @iter. If @len is -1,
// @text must be nul-terminated and will be inserted in its entirety. Emits
// the “insert-text” signal; insertion actually occurs in the default
// handler for the signal. @iter is invalidated when insertion occurs
// (because the buffer contents change), but the default signal handler
// revalidates it to point to the end of the inserted text.
func (buffer textBuffer) Insert(iter *TextIter, text string, len int) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextIter
	var arg2 *C.char
	var arg3 C.int

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg1 = (*C.GtkTextIter)(iter.Native())
	arg2 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = C.int(len)

	C.gtk_text_buffer_insert(arg0, arg1, arg2, arg3)
}

// InsertAtCursor: simply calls gtk_text_buffer_insert(), using the current
// cursor position as the insertion point.
func (buffer textBuffer) InsertAtCursor(text string, len int) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.char
	var arg2 C.int

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.int(len)

	C.gtk_text_buffer_insert_at_cursor(arg0, arg1, arg2)
}

// InsertChildAnchor inserts a child widget anchor into the text buffer at
// @iter. The anchor will be counted as one character in character counts,
// and when obtaining the buffer contents as a string, will be represented
// by the Unicode “object replacement character” 0xFFFC. Note that the
// “slice” variants for obtaining portions of the buffer as a string include
// this character for child anchors, but the “text” variants do not. E.g.
// see gtk_text_buffer_get_slice() and gtk_text_buffer_get_text(). Consider
// gtk_text_buffer_create_child_anchor() as a more convenient alternative to
// this function. The buffer will add a reference to the anchor, so you can
// unref it after insertion.
func (buffer textBuffer) InsertChildAnchor(iter *TextIter, anchor TextChildAnchor) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextIter
	var arg2 *C.GtkTextChildAnchor

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg1 = (*C.GtkTextIter)(iter.Native())
	arg2 = (*C.GtkTextChildAnchor)(anchor.Native())

	C.gtk_text_buffer_insert_child_anchor(arg0, arg1, arg2)
}

// InsertInteractive: like gtk_text_buffer_insert(), but the insertion will
// not occur if @iter is at a non-editable location in the buffer. Usually
// you want to prevent insertions at ineditable locations if the insertion
// results from a user action (is interactive).
//
// @default_editable indicates the editability of text that doesn't have a
// tag affecting editability applied to it. Typically the result of
// gtk_text_view_get_editable() is appropriate here.
func (buffer textBuffer) InsertInteractive(iter *TextIter, text string, len int, defaultEditable bool) bool {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextIter
	var arg2 *C.char
	var arg3 C.int
	var arg4 C.gboolean

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg1 = (*C.GtkTextIter)(iter.Native())
	arg2 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = C.int(len)
	arg4 = gextras.Cbool(defaultEditable)

	ret := C.gtk_text_buffer_insert_interactive(arg0, arg1, arg2, arg3, arg4)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// InsertInteractiveAtCursor calls gtk_text_buffer_insert_interactive() at
// the cursor position.
//
// @default_editable indicates the editability of text that doesn't have a
// tag affecting editability applied to it. Typically the result of
// gtk_text_view_get_editable() is appropriate here.
func (buffer textBuffer) InsertInteractiveAtCursor(text string, len int, defaultEditable bool) bool {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.char
	var arg2 C.int
	var arg3 C.gboolean

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.int(len)
	arg3 = gextras.Cbool(defaultEditable)

	ret := C.gtk_text_buffer_insert_interactive_at_cursor(arg0, arg1, arg2, arg3)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// InsertMarkup inserts the text in @markup at position @iter. @markup will
// be inserted in its entirety and must be nul-terminated and valid UTF-8.
// Emits the TextBuffer::insert-text signal, possibly multiple times;
// insertion actually occurs in the default handler for the signal. @iter
// will point to the end of the inserted text on return.
func (buffer textBuffer) InsertMarkup(iter *TextIter, markup string, len int) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextIter
	var arg2 *C.char
	var arg3 C.int

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg1 = (*C.GtkTextIter)(iter.Native())
	arg2 = (*C.gchar)(C.CString(markup))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = C.int(len)

	C.gtk_text_buffer_insert_markup(arg0, arg1, arg2, arg3)
}

// InsertPaintable inserts an image into the text buffer at @iter. The image
// will be counted as one character in character counts, and when obtaining
// the buffer contents as a string, will be represented by the Unicode
// “object replacement character” 0xFFFC. Note that the “slice” variants for
// obtaining portions of the buffer as a string include this character for
// paintable, but the “text” variants do not. e.g. see
// gtk_text_buffer_get_slice() and gtk_text_buffer_get_text().
func (buffer textBuffer) InsertPaintable(iter *TextIter, paintable gdk.Paintable) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextIter
	var arg2 *C.GdkPaintable

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg1 = (*C.GtkTextIter)(iter.Native())

	C.gtk_text_buffer_insert_paintable(arg0, arg1, arg2)
}

// InsertRange copies text, tags, and paintables between @start and @end
// (the order of @start and @end doesn’t matter) and inserts the copy at
// @iter. Used instead of simply getting/inserting text because it preserves
// images and tags. If @start and @end are in a different buffer from
// @buffer, the two buffers must share the same tag table.
//
// Implemented via emissions of the insert_text and apply_tag signals, so
// expect those.
func (buffer textBuffer) InsertRange(iter *TextIter, start *TextIter, end *TextIter) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextIter
	var arg2 *C.GtkTextIter
	var arg3 *C.GtkTextIter

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg1 = (*C.GtkTextIter)(iter.Native())
	arg2 = (*C.GtkTextIter)(start.Native())
	arg3 = (*C.GtkTextIter)(end.Native())

	C.gtk_text_buffer_insert_range(arg0, arg1, arg2, arg3)
}

// InsertRangeInteractive: same as gtk_text_buffer_insert_range(), but does
// nothing if the insertion point isn’t editable. The @default_editable
// parameter indicates whether the text is editable at @iter if no tags
// enclosing @iter affect editability. Typically the result of
// gtk_text_view_get_editable() is appropriate here.
func (buffer textBuffer) InsertRangeInteractive(iter *TextIter, start *TextIter, end *TextIter, defaultEditable bool) bool {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextIter
	var arg2 *C.GtkTextIter
	var arg3 *C.GtkTextIter
	var arg4 C.gboolean

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg1 = (*C.GtkTextIter)(iter.Native())
	arg2 = (*C.GtkTextIter)(start.Native())
	arg3 = (*C.GtkTextIter)(end.Native())
	arg4 = gextras.Cbool(defaultEditable)

	ret := C.gtk_text_buffer_insert_range_interactive(arg0, arg1, arg2, arg3, arg4)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// MoveMark moves @mark to the new location @where. Emits the
// TextBuffer::mark-set signal as notification of the move.
func (buffer textBuffer) MoveMark(mark TextMark, where *TextIter) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextMark
	var arg2 *C.GtkTextIter

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg1 = (*C.GtkTextMark)(mark.Native())
	arg2 = (*C.GtkTextIter)(where.Native())

	C.gtk_text_buffer_move_mark(arg0, arg1, arg2)
}

// MoveMarkByName moves the mark named @name (which must exist) to location
// @where. See gtk_text_buffer_move_mark() for details.
func (buffer textBuffer) MoveMarkByName(name string, where *TextIter) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.char
	var arg2 *C.GtkTextIter

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GtkTextIter)(where.Native())

	C.gtk_text_buffer_move_mark_by_name(arg0, arg1, arg2)
}

// PasteClipboard pastes the contents of a clipboard. If @override_location
// is nil, the pasted text will be inserted at the cursor position, or the
// buffer selection will be replaced if the selection is non-empty.
//
// Note: pasting is asynchronous, that is, we’ll ask for the paste data and
// return, and at some point later after the main loop runs, the paste data
// will be inserted.
func (buffer textBuffer) PasteClipboard(clipboard gdk.Clipboard, overrideLocation *TextIter, defaultEditable bool) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GdkClipboard
	var arg2 *C.GtkTextIter
	var arg3 C.gboolean

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg1 = (*C.GdkClipboard)(clipboard.Native())
	arg2 = (*C.GtkTextIter)(overrideLocation.Native())
	arg3 = gextras.Cbool(defaultEditable)

	C.gtk_text_buffer_paste_clipboard(arg0, arg1, arg2, arg3)
}

// PlaceCursor: this function moves the “insert” and “selection_bound” marks
// simultaneously. If you move them to the same place in two steps with
// gtk_text_buffer_move_mark(), you will temporarily select a region in
// between their old and new locations, which can be pretty inefficient
// since the temporarily-selected region will force stuff to be
// recalculated. This function moves them as a unit, which can be optimized.
func (buffer textBuffer) PlaceCursor(where *TextIter) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextIter

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg1 = (*C.GtkTextIter)(where.Native())

	C.gtk_text_buffer_place_cursor(arg0, arg1)
}

// Redo redoes the next redoable action on the buffer, if there is one.
func (buffer textBuffer) Redo() {
	var arg0 *C.GtkTextBuffer

	arg0 = (*C.GtkTextBuffer)(buffer.Native())

	C.gtk_text_buffer_redo(arg0)
}

// RemoveAllTags removes all tags in the range between @start and @end. Be
// careful with this function; it could remove tags added in code unrelated
// to the code you’re currently writing. That is, using this function is
// probably a bad idea if you have two or more unrelated code sections that
// add tags.
func (buffer textBuffer) RemoveAllTags(start *TextIter, end *TextIter) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextIter
	var arg2 *C.GtkTextIter

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg1 = (*C.GtkTextIter)(start.Native())
	arg2 = (*C.GtkTextIter)(end.Native())

	C.gtk_text_buffer_remove_all_tags(arg0, arg1, arg2)
}

// RemoveSelectionClipboard removes a Clipboard added with
// gtk_text_buffer_add_selection_clipboard().
func (buffer textBuffer) RemoveSelectionClipboard(clipboard gdk.Clipboard) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GdkClipboard

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg1 = (*C.GdkClipboard)(clipboard.Native())

	C.gtk_text_buffer_remove_selection_clipboard(arg0, arg1)
}

// RemoveTag emits the “remove-tag” signal. The default handler for the
// signal removes all occurrences of @tag from the given range. @start and
// @end don’t have to be in order.
func (buffer textBuffer) RemoveTag(tag TextTag, start *TextIter, end *TextIter) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextTag
	var arg2 *C.GtkTextIter
	var arg3 *C.GtkTextIter

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg1 = (*C.GtkTextTag)(tag.Native())
	arg2 = (*C.GtkTextIter)(start.Native())
	arg3 = (*C.GtkTextIter)(end.Native())

	C.gtk_text_buffer_remove_tag(arg0, arg1, arg2, arg3)
}

// RemoveTagByName calls gtk_text_tag_table_lookup() on the buffer’s tag
// table to get a TextTag, then calls gtk_text_buffer_remove_tag().
func (buffer textBuffer) RemoveTagByName(name string, start *TextIter, end *TextIter) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.char
	var arg2 *C.GtkTextIter
	var arg3 *C.GtkTextIter

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GtkTextIter)(start.Native())
	arg3 = (*C.GtkTextIter)(end.Native())

	C.gtk_text_buffer_remove_tag_by_name(arg0, arg1, arg2, arg3)
}

// SelectRange: this function moves the “insert” and “selection_bound” marks
// simultaneously. If you move them in two steps with
// gtk_text_buffer_move_mark(), you will temporarily select a region in
// between their old and new locations, which can be pretty inefficient
// since the temporarily-selected region will force stuff to be
// recalculated. This function moves them as a unit, which can be optimized.
func (buffer textBuffer) SelectRange(ins *TextIter, bound *TextIter) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextIter
	var arg2 *C.GtkTextIter

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg1 = (*C.GtkTextIter)(ins.Native())
	arg2 = (*C.GtkTextIter)(bound.Native())

	C.gtk_text_buffer_select_range(arg0, arg1, arg2)
}

// SetEnableUndo sets whether or not to enable undoable actions in the text
// buffer. If enabled, the user will be able to undo the last number of
// actions up to gtk_text_buffer_get_max_undo_levels().
//
// See gtk_text_buffer_begin_irreversible_action() and
// gtk_text_buffer_end_irreversible_action() to create changes to the buffer
// that cannot be undone.
func (buffer textBuffer) SetEnableUndo(enableUndo bool) {
	var arg0 *C.GtkTextBuffer
	var arg1 C.gboolean

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg1 = gextras.Cbool(enableUndo)

	C.gtk_text_buffer_set_enable_undo(arg0, arg1)
}

// SetMaxUndoLevels sets the maximum number of undo levels to perform. If 0,
// unlimited undo actions may be performed. Note that this may have a memory
// usage impact as it requires storing an additional copy of the inserted or
// removed text within the text buffer.
func (buffer textBuffer) SetMaxUndoLevels(maxUndoLevels uint) {
	var arg0 *C.GtkTextBuffer
	var arg1 C.guint

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg1 = C.guint(maxUndoLevels)

	C.gtk_text_buffer_set_max_undo_levels(arg0, arg1)
}

// SetModified: used to keep track of whether the buffer has been modified
// since the last time it was saved. Whenever the buffer is saved to disk,
// call gtk_text_buffer_set_modified (@buffer, FALSE). When the buffer is
// modified, it will automatically toggled on the modified bit again. When
// the modified bit flips, the buffer emits the TextBuffer::modified-changed
// signal.
func (buffer textBuffer) SetModified(setting bool) {
	var arg0 *C.GtkTextBuffer
	var arg1 C.gboolean

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg1 = gextras.Cbool(setting)

	C.gtk_text_buffer_set_modified(arg0, arg1)
}

// SetText deletes current contents of @buffer, and inserts @text instead.
// If @len is -1, @text must be nul-terminated. @text must be valid UTF-8.
func (buffer textBuffer) SetText(text string, len int) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.char
	var arg2 C.int

	arg0 = (*C.GtkTextBuffer)(buffer.Native())
	arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.int(len)

	C.gtk_text_buffer_set_text(arg0, arg1, arg2)
}

// Undo undoes the last undoable action on the buffer, if there is one.
func (buffer textBuffer) Undo() {
	var arg0 *C.GtkTextBuffer

	arg0 = (*C.GtkTextBuffer)(buffer.Native())

	C.gtk_text_buffer_undo(arg0)
}

// TextChildAnchor: a TextChildAnchor is a spot in the buffer where child
// widgets can be “anchored” (inserted inline, as if they were characters). The
// anchor can have multiple widgets anchored, to allow for multiple views.
type TextChildAnchor interface {
	gextras.Objector

	// Deleted determines whether a child anchor has been deleted from the
	// buffer. Keep in mind that the child anchor will be unreferenced when
	// removed from the buffer, so you need to hold your own reference (with
	// g_object_ref()) if you plan to use this function — otherwise all deleted
	// child anchors will also be finalized.
	Deleted() bool
	// Widgets gets a list of all widgets anchored at this child anchor.
	//
	// The order in which the widgets are returned is not defined.
	Widgets() (outLen uint, widgets []Widget)
}

type textChildAnchor struct {
	*externglib.Object
}

// WrapTextChildAnchor wraps a GObject to the right type. It is
// primarily used internally.
func WrapTextChildAnchor(obj *externglib.Object) TextChildAnchor {
	return textChildAnchor{*externglib.Object{obj}}
}

func marshalTextChildAnchor(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTextChildAnchor(obj), nil
}

// NewTextChildAnchor constructs a class TextChildAnchor.
func NewTextChildAnchor() TextChildAnchor {

	ret := C.gtk_text_child_anchor_new()

	var ret0 TextChildAnchor

	ret0 = WrapTextChildAnchor(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Deleted determines whether a child anchor has been deleted from the
// buffer. Keep in mind that the child anchor will be unreferenced when
// removed from the buffer, so you need to hold your own reference (with
// g_object_ref()) if you plan to use this function — otherwise all deleted
// child anchors will also be finalized.
func (anchor textChildAnchor) Deleted() bool {
	var arg0 *C.GtkTextChildAnchor

	arg0 = (*C.GtkTextChildAnchor)(anchor.Native())

	ret := C.gtk_text_child_anchor_get_deleted(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Widgets gets a list of all widgets anchored at this child anchor.
//
// The order in which the widgets are returned is not defined.
func (anchor textChildAnchor) Widgets() (outLen uint, widgets []Widget) {
	var arg0 *C.GtkTextChildAnchor
	var arg1 *C.guint // out

	arg0 = (*C.GtkTextChildAnchor)(anchor.Native())

	ret := C.gtk_text_child_anchor_get_widgets(arg0, &arg1)

	var ret0 uint
	var ret1 []Widget

	ret0 = uint(arg1)

	{
		ret1 = make([]Widget, arg1)
		for i := 0; i < uintptr(arg1); i++ {
			src := (*C.GtkWidget)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			ret1[i] = WrapWidget(externglib.Take(unsafe.Pointer(src.Native())))
		}
	}

	return ret0, ret1
}

// TextMark: you may wish to begin by reading the [text widget conceptual
// overview][TextWidget] which gives an overview of all the objects and data
// types related to the text widget and how they work together.
//
// A TextMark is like a bookmark in a text buffer; it preserves a position in
// the text. You can convert the mark to an iterator using
// gtk_text_buffer_get_iter_at_mark(). Unlike iterators, marks remain valid
// across buffer mutations, because their behavior is defined when text is
// inserted or deleted. When text containing a mark is deleted, the mark remains
// in the position originally occupied by the deleted text. When text is
// inserted at a mark, a mark with “left gravity” will be moved to the beginning
// of the newly-inserted text, and a mark with “right gravity” will be moved to
// the end.
//
// Note that “left” and “right” here refer to logical direction (left is the
// toward the start of the buffer); in some languages such as Hebrew the
// logically-leftmost text is not actually on the left when displayed.
//
// Marks are reference counted, but the reference count only controls the
// validity of the memory; marks can be deleted from the buffer at any time with
// gtk_text_buffer_delete_mark(). Once deleted from the buffer, a mark is
// essentially useless.
//
// Marks optionally have names; these can be convenient to avoid passing the
// TextMark object around.
//
// Marks are typically created using the gtk_text_buffer_create_mark() function.
type TextMark interface {
	gextras.Objector

	// Buffer gets the buffer this mark is located inside, or nil if the mark is
	// deleted.
	Buffer() TextBuffer
	// Deleted returns true if the mark has been removed from its buffer with
	// gtk_text_buffer_delete_mark(). See gtk_text_buffer_add_mark() for a way
	// to add it to a buffer again.
	Deleted() bool
	// LeftGravity determines whether the mark has left gravity.
	LeftGravity() bool
	// Name returns the mark name; returns NULL for anonymous marks.
	Name() string
	// Visible returns true if the mark is visible (i.e. a cursor is displayed
	// for it).
	Visible() bool

	SetVisible(setting bool)
}

type textMark struct {
	*externglib.Object
}

// WrapTextMark wraps a GObject to the right type. It is
// primarily used internally.
func WrapTextMark(obj *externglib.Object) TextMark {
	return textMark{*externglib.Object{obj}}
}

func marshalTextMark(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTextMark(obj), nil
}

// NewTextMark constructs a class TextMark.
func NewTextMark(name string, leftGravity bool) TextMark {
	var arg1 *C.char
	var arg2 C.gboolean

	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = gextras.Cbool(leftGravity)

	ret := C.gtk_text_mark_new(arg1, arg2)

	var ret0 TextMark

	ret0 = WrapTextMark(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Buffer gets the buffer this mark is located inside, or nil if the mark is
// deleted.
func (mark textMark) Buffer() TextBuffer {
	var arg0 *C.GtkTextMark

	arg0 = (*C.GtkTextMark)(mark.Native())

	ret := C.gtk_text_mark_get_buffer(arg0)

	var ret0 TextBuffer

	ret0 = WrapTextBuffer(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Deleted returns true if the mark has been removed from its buffer with
// gtk_text_buffer_delete_mark(). See gtk_text_buffer_add_mark() for a way
// to add it to a buffer again.
func (mark textMark) Deleted() bool {
	var arg0 *C.GtkTextMark

	arg0 = (*C.GtkTextMark)(mark.Native())

	ret := C.gtk_text_mark_get_deleted(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// LeftGravity determines whether the mark has left gravity.
func (mark textMark) LeftGravity() bool {
	var arg0 *C.GtkTextMark

	arg0 = (*C.GtkTextMark)(mark.Native())

	ret := C.gtk_text_mark_get_left_gravity(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Name returns the mark name; returns NULL for anonymous marks.
func (mark textMark) Name() string {
	var arg0 *C.GtkTextMark

	arg0 = (*C.GtkTextMark)(mark.Native())

	ret := C.gtk_text_mark_get_name(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Visible returns true if the mark is visible (i.e. a cursor is displayed
// for it).
func (mark textMark) Visible() bool {
	var arg0 *C.GtkTextMark

	arg0 = (*C.GtkTextMark)(mark.Native())

	ret := C.gtk_text_mark_get_visible(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

func (mark textMark) SetVisible(setting bool) {
	var arg0 *C.GtkTextMark
	var arg1 C.gboolean

	arg0 = (*C.GtkTextMark)(mark.Native())
	arg1 = gextras.Cbool(setting)

	C.gtk_text_mark_set_visible(arg0, arg1)
}

// TextTag: you may wish to begin by reading the [text widget conceptual
// overview][TextWidget] which gives an overview of all the objects and data
// types related to the text widget and how they work together.
//
// Tags should be in the TextTagTable for a given TextBuffer before using them
// with that buffer.
//
// gtk_text_buffer_create_tag() is the best way to create tags. See “gtk4-demo”
// for numerous examples.
//
// For each property of TextTag, there is a “set” property, e.g. “font-set”
// corresponds to “font”. These “set” properties reflect whether a property has
// been set or not. They are maintained by GTK+ and you should not set them
// independently.
type TextTag interface {
	gextras.Objector

	// Changed emits the TextTagTable::tag-changed signal on the TextTagTable
	// where the tag is included.
	//
	// The signal is already emitted when setting a TextTag property. This
	// function is useful for a TextTag subclass.
	Changed(sizeChanged bool)
	// Priority: get the tag priority.
	Priority() int
	// SetPriority sets the priority of a TextTag. Valid priorities start at 0
	// and go to one less than gtk_text_tag_table_get_size(). Each tag in a
	// table has a unique priority; setting the priority of one tag shifts the
	// priorities of all the other tags in the table to maintain a unique
	// priority for each tag. Higher priority tags “win” if two tags both set
	// the same text attribute. When adding a tag to a tag table, it will be
	// assigned the highest priority in the table by default; so normally the
	// precedence of a set of tags is the order in which they were added to the
	// table, or created with gtk_text_buffer_create_tag(), which adds the tag
	// to the buffer’s table automatically.
	SetPriority(priority int)
}

type textTag struct {
	*externglib.Object
}

// WrapTextTag wraps a GObject to the right type. It is
// primarily used internally.
func WrapTextTag(obj *externglib.Object) TextTag {
	return textTag{*externglib.Object{obj}}
}

func marshalTextTag(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTextTag(obj), nil
}

// NewTextTag constructs a class TextTag.
func NewTextTag(name string) TextTag {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_text_tag_new(arg1)

	var ret0 TextTag

	ret0 = WrapTextTag(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Changed emits the TextTagTable::tag-changed signal on the TextTagTable
// where the tag is included.
//
// The signal is already emitted when setting a TextTag property. This
// function is useful for a TextTag subclass.
func (tag textTag) Changed(sizeChanged bool) {
	var arg0 *C.GtkTextTag
	var arg1 C.gboolean

	arg0 = (*C.GtkTextTag)(tag.Native())
	arg1 = gextras.Cbool(sizeChanged)

	C.gtk_text_tag_changed(arg0, arg1)
}

// Priority: get the tag priority.
func (tag textTag) Priority() int {
	var arg0 *C.GtkTextTag

	arg0 = (*C.GtkTextTag)(tag.Native())

	ret := C.gtk_text_tag_get_priority(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// SetPriority sets the priority of a TextTag. Valid priorities start at 0
// and go to one less than gtk_text_tag_table_get_size(). Each tag in a
// table has a unique priority; setting the priority of one tag shifts the
// priorities of all the other tags in the table to maintain a unique
// priority for each tag. Higher priority tags “win” if two tags both set
// the same text attribute. When adding a tag to a tag table, it will be
// assigned the highest priority in the table by default; so normally the
// precedence of a set of tags is the order in which they were added to the
// table, or created with gtk_text_buffer_create_tag(), which adds the tag
// to the buffer’s table automatically.
func (tag textTag) SetPriority(priority int) {
	var arg0 *C.GtkTextTag
	var arg1 C.int

	arg0 = (*C.GtkTextTag)(tag.Native())
	arg1 = C.int(priority)

	C.gtk_text_tag_set_priority(arg0, arg1)
}

// TextTagTable: you may wish to begin by reading the [text widget conceptual
// overview][TextWidget] which gives an overview of all the objects and data
// types related to the text widget and how they work together.
//
//
// GtkTextTagTables as GtkBuildable
//
// The GtkTextTagTable implementation of the GtkBuildable interface supports
// adding tags by specifying “tag” as the “type” attribute of a <child> element.
//
// An example of a UI definition fragment specifying tags:
//
//
//    <object class="GtkTextTagTable">
//     <child type="tag">
//       <object class="GtkTextTag"/>
//     </child>
//    </object>
//
type TextTagTable interface {
	gextras.Objector

	// Add: add a tag to the table. The tag is assigned the highest priority in
	// the table.
	//
	// @tag must not be in a tag table already, and may not have the same name
	// as an already-added tag.
	Add(tag TextTag) bool
	// Foreach calls @func on each tag in @table, with user data @data. Note
	// that the table may not be modified while iterating over it (you can’t
	// add/remove tags).
	Foreach(_func TextTagTableForeach)
	// Size returns the size of the table (number of tags)
	Size() int
	// Lookup: look up a named tag.
	Lookup(name string) TextTag
	// Remove: remove a tag from the table. If a TextBuffer has @table as its
	// tag table, the tag is removed from the buffer. The table’s reference to
	// the tag is removed, so the tag will end up destroyed if you don’t have a
	// reference to it.
	Remove(tag TextTag)
}

type textTagTable struct {
	*externglib.Object
}

// WrapTextTagTable wraps a GObject to the right type. It is
// primarily used internally.
func WrapTextTagTable(obj *externglib.Object) TextTagTable {
	return textTagTable{*externglib.Object{obj}}
}

func marshalTextTagTable(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTextTagTable(obj), nil
}

// NewTextTagTable constructs a class TextTagTable.
func NewTextTagTable() TextTagTable {

	ret := C.gtk_text_tag_table_new()

	var ret0 TextTagTable

	ret0 = WrapTextTagTable(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Add: add a tag to the table. The tag is assigned the highest priority in
// the table.
//
// @tag must not be in a tag table already, and may not have the same name
// as an already-added tag.
func (table textTagTable) Add(tag TextTag) bool {
	var arg0 *C.GtkTextTagTable
	var arg1 *C.GtkTextTag

	arg0 = (*C.GtkTextTagTable)(table.Native())
	arg1 = (*C.GtkTextTag)(tag.Native())

	ret := C.gtk_text_tag_table_add(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Foreach calls @func on each tag in @table, with user data @data. Note
// that the table may not be modified while iterating over it (you can’t
// add/remove tags).
func (table textTagTable) Foreach(_func TextTagTableForeach) {
	var arg0 *C.GtkTextTagTable
	var arg1 C.GtkTextTagTableForeach
	arg2 := C.gpointer(box.Assign(data))

	arg0 = (*C.GtkTextTagTable)(table.Native())
	arg1 = (*[0]byte)(C.gotk4_TextTagTableForeach)

	C.gtk_text_tag_table_foreach(arg0, arg1)
}

// Size returns the size of the table (number of tags)
func (table textTagTable) Size() int {
	var arg0 *C.GtkTextTagTable

	arg0 = (*C.GtkTextTagTable)(table.Native())

	ret := C.gtk_text_tag_table_get_size(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Lookup: look up a named tag.
func (table textTagTable) Lookup(name string) TextTag {
	var arg0 *C.GtkTextTagTable
	var arg1 *C.char

	arg0 = (*C.GtkTextTagTable)(table.Native())
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_text_tag_table_lookup(arg0, arg1)

	var ret0 TextTag

	ret0 = WrapTextTag(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Remove: remove a tag from the table. If a TextBuffer has @table as its
// tag table, the tag is removed from the buffer. The table’s reference to
// the tag is removed, so the tag will end up destroyed if you don’t have a
// reference to it.
func (table textTagTable) Remove(tag TextTag) {
	var arg0 *C.GtkTextTagTable
	var arg1 *C.GtkTextTag

	arg0 = (*C.GtkTextTagTable)(table.Native())
	arg1 = (*C.GtkTextTag)(tag.Native())

	C.gtk_text_tag_table_remove(arg0, arg1)
}

// TextView: you may wish to begin by reading the [text widget conceptual
// overview][TextWidget] which gives an overview of all the objects and data
// types related to the text widget and how they work together.
//
// CSS nodes
//
//    textview.view
//    ├── border.top
//    ├── border.left
//    ├── text
//    │   ╰── [selection]
//    ├── border.right
//    ├── border.bottom
//    ╰── [window.popup]
//
//
// GtkTextView has a main css node with name textview and style class .view, and
// subnodes for each of the border windows, and the main text area, with names
// border and text, respectively. The border nodes each get one of the style
// classes .left, .right, .top or .bottom.
//
// A node representing the selection will appear below the text node.
//
// If a context menu is opened, the window node will appear as a subnode of the
// main node.
//
//
// Accessibility
//
// GtkTextView uses the K_ACCESSIBLE_ROLE_TEXT_BOX role.
type TextView interface {
	Widget

	// AddChildAtAnchor adds a child widget in the text buffer, at the given
	// @anchor.
	AddChildAtAnchor(child Widget, anchor TextChildAnchor)
	// AddOverlay adds @child at a fixed coordinate in the TextView's text
	// window. The @xpos and @ypos must be in buffer coordinates (see
	// gtk_text_view_get_iter_location() to convert to buffer coordinates).
	//
	// @child will scroll with the text view.
	//
	// If instead you want a widget that will not move with the TextView
	// contents see Overlay.
	AddOverlay(child Widget, xpos int, ypos int)
	// BackwardDisplayLine moves the given @iter backward by one display
	// (wrapped) line. A display line is different from a paragraph. Paragraphs
	// are separated by newlines or other paragraph separator characters.
	// Display lines are created by line-wrapping a paragraph. If wrapping is
	// turned off, display lines and paragraphs will be the same. Display lines
	// are divided differently for each view, since they depend on the view’s
	// width; paragraphs are the same in all views, since they depend on the
	// contents of the TextBuffer.
	BackwardDisplayLine(iter *TextIter) bool
	// BackwardDisplayLineStart moves the given @iter backward to the next
	// display line start. A display line is different from a paragraph.
	// Paragraphs are separated by newlines or other paragraph separator
	// characters. Display lines are created by line-wrapping a paragraph. If
	// wrapping is turned off, display lines and paragraphs will be the same.
	// Display lines are divided differently for each view, since they depend on
	// the view’s width; paragraphs are the same in all views, since they depend
	// on the contents of the TextBuffer.
	BackwardDisplayLineStart(iter *TextIter) bool
	// BufferToWindowCoords converts coordinate (@buffer_x, @buffer_y) to
	// coordinates for the window @win, and stores the result in (@window_x,
	// @window_y).
	BufferToWindowCoords(win TextWindowType, bufferX int, bufferY int) (windowX int, windowY int)
	// ForwardDisplayLine moves the given @iter forward by one display (wrapped)
	// line. A display line is different from a paragraph. Paragraphs are
	// separated by newlines or other paragraph separator characters. Display
	// lines are created by line-wrapping a paragraph. If wrapping is turned
	// off, display lines and paragraphs will be the same. Display lines are
	// divided differently for each view, since they depend on the view’s width;
	// paragraphs are the same in all views, since they depend on the contents
	// of the TextBuffer.
	ForwardDisplayLine(iter *TextIter) bool
	// ForwardDisplayLineEnd moves the given @iter forward to the next display
	// line end. A display line is different from a paragraph. Paragraphs are
	// separated by newlines or other paragraph separator characters. Display
	// lines are created by line-wrapping a paragraph. If wrapping is turned
	// off, display lines and paragraphs will be the same. Display lines are
	// divided differently for each view, since they depend on the view’s width;
	// paragraphs are the same in all views, since they depend on the contents
	// of the TextBuffer.
	ForwardDisplayLineEnd(iter *TextIter) bool
	// AcceptsTab returns whether pressing the Tab key inserts a tab characters.
	// gtk_text_view_set_accepts_tab().
	AcceptsTab() bool
	// BottomMargin gets the bottom margin for text in the @text_view.
	BottomMargin() int
	// Buffer returns the TextBuffer being displayed by this text view. The
	// reference count on the buffer is not incremented; the caller of this
	// function won’t own a new reference.
	Buffer() TextBuffer
	// CursorLocations: given an @iter within a text layout, determine the
	// positions of the strong and weak cursors if the insertion point is at
	// that iterator. The position of each cursor is stored as a zero-width
	// rectangle. The strong cursor location is the location where characters of
	// the directionality equal to the base direction of the paragraph are
	// inserted. The weak cursor location is the location where characters of
	// the directionality opposite to the base direction of the paragraph are
	// inserted.
	//
	// If @iter is nil, the actual cursor position is used.
	//
	// Note that if @iter happens to be the actual cursor position, and there is
	// currently an IM preedit sequence being entered, the returned locations
	// will be adjusted to account for the preedit cursor’s offset within the
	// preedit sequence.
	//
	// The rectangle position is in buffer coordinates; use
	// gtk_text_view_buffer_to_window_coords() to convert these coordinates to
	// coordinates for one of the windows in the text view.
	CursorLocations(iter *TextIter) (strong gdk.Rectangle, weak gdk.Rectangle)
	// CursorVisible: find out whether the cursor should be displayed.
	CursorVisible() bool
	// Editable returns the default editability of the TextView. Tags in the
	// buffer may override this setting for some ranges of text.
	Editable() bool
	// ExtraMenu gets the menu model set with gtk_text_view_set_extra_menu() or
	// nil if none has been set.
	ExtraMenu() gio.MenuModel
	// Gutter gets a Widget that has previously been set with
	// gtk_text_view_set_gutter().
	//
	// @win must be one of GTK_TEXT_WINDOW_LEFT, GTK_TEXT_WINDOW_RIGHT,
	// GTK_TEXT_WINDOW_TOP, or GTK_TEXT_WINDOW_BOTTOM.
	Gutter(win TextWindowType) Widget
	// Indent gets the default indentation of paragraphs in @text_view. Tags in
	// the view’s buffer may override the default. The indentation may be
	// negative.
	Indent() int
	// InputHints gets the value of the TextView:input-hints property.
	InputHints() InputHints
	// InputPurpose gets the value of the TextView:input-purpose property.
	InputPurpose() InputPurpose
	// IterAtLocation retrieves the iterator at buffer coordinates @x and @y.
	// Buffer coordinates are coordinates for the entire buffer, not just the
	// currently-displayed portion. If you have coordinates from an event, you
	// have to convert those to buffer coordinates with
	// gtk_text_view_window_to_buffer_coords().
	IterAtLocation(x int, y int) (iter TextIter, ok bool)
	// IterAtPosition retrieves the iterator pointing to the character at buffer
	// coordinates @x and @y. Buffer coordinates are coordinates for the entire
	// buffer, not just the currently-displayed portion. If you have coordinates
	// from an event, you have to convert those to buffer coordinates with
	// gtk_text_view_window_to_buffer_coords().
	//
	// Note that this is different from gtk_text_view_get_iter_at_location(),
	// which returns cursor locations, i.e. positions between characters.
	IterAtPosition(x int, y int) (iter TextIter, trailing int, ok bool)
	// IterLocation gets a rectangle which roughly contains the character at
	// @iter. The rectangle position is in buffer coordinates; use
	// gtk_text_view_buffer_to_window_coords() to convert these coordinates to
	// coordinates for one of the windows in the text view.
	IterLocation(iter *TextIter) gdk.Rectangle
	// Justification gets the default justification of paragraphs in @text_view.
	// Tags in the buffer may override the default.
	Justification() Justification
	// LeftMargin gets the default left margin size of paragraphs in the
	// @text_view. Tags in the buffer may override the default.
	LeftMargin() int
	// LineAtY gets the TextIter at the start of the line containing the
	// coordinate @y. @y is in buffer coordinates, convert from window
	// coordinates with gtk_text_view_window_to_buffer_coords(). If non-nil,
	// @line_top will be filled with the coordinate of the top edge of the line.
	LineAtY(y int) (targetIter TextIter, lineTop int)
	// LineYrange gets the y coordinate of the top of the line containing @iter,
	// and the height of the line. The coordinate is a buffer coordinate;
	// convert to window coordinates with
	// gtk_text_view_buffer_to_window_coords().
	LineYrange(iter *TextIter) (y int, height int)
	// Monospace gets the value of the TextView:monospace property.
	Monospace() bool
	// Overwrite returns whether the TextView is in overwrite mode or not.
	Overwrite() bool
	// PixelsAboveLines gets the default number of pixels to put above
	// paragraphs. Adding this function with
	// gtk_text_view_get_pixels_below_lines() is equal to the line space between
	// each paragraph.
	PixelsAboveLines() int
	// PixelsBelowLines gets the value set by
	// gtk_text_view_set_pixels_below_lines().
	//
	// The line space is the sum of the value returned by this function and the
	// value returned by gtk_text_view_get_pixels_above_lines().
	PixelsBelowLines() int
	// PixelsInsideWrap gets the value set by
	// gtk_text_view_set_pixels_inside_wrap().
	PixelsInsideWrap() int
	// RightMargin gets the default right margin for text in @text_view. Tags in
	// the buffer may override the default.
	RightMargin() int
	// Tabs gets the default tabs for @text_view. Tags in the buffer may
	// override the defaults. The returned array will be nil if “standard”
	// (8-space) tabs are used. Free the return value with
	// pango_tab_array_free().
	Tabs() *pango.TabArray
	// TopMargin gets the top margin for text in the @text_view.
	TopMargin() int
	// VisibleRect fills @visible_rect with the currently-visible region of the
	// buffer, in buffer coordinates. Convert to window coordinates with
	// gtk_text_view_buffer_to_window_coords().
	VisibleRect() gdk.Rectangle
	// WrapMode gets the line wrapping for the view.
	WrapMode() WrapMode
	// ImContextFilterKeypress: allow the TextView input method to internally
	// handle key press and release events. If this function returns true, then
	// no further processing should be done for this key event. See
	// gtk_im_context_filter_keypress().
	//
	// Note that you are expected to call this function from your handler when
	// overriding key event handling. This is needed in the case when you need
	// to insert your own key handling between the input method and the default
	// key event handling of the TextView.
	//
	//    static gboolean
	//    gtk_foo_bar_key_press_event (GtkWidget *widget,
	//                                 GdkEvent  *event)
	//    {
	//      guint keyval;
	//
	//      gdk_event_get_keyval ((GdkEvent*)event, &keyval);
	//
	//      if (keyval == GDK_KEY_Return || keyval == GDK_KEY_KP_Enter)
	//        {
	//          if (gtk_text_view_im_context_filter_keypress (GTK_TEXT_VIEW (widget), event))
	//            return TRUE;
	//        }
	//
	//      // Do some stuff
	//
	//      return GTK_WIDGET_CLASS (gtk_foo_bar_parent_class)->key_press_event (widget, event);
	//    }
	//
	ImContextFilterKeypress(event gdk.Event) bool
	// MoveMarkOnscreen moves a mark within the buffer so that it's located
	// within the currently-visible text area.
	MoveMarkOnscreen(mark TextMark) bool
	// MoveOverlay updates the position of a child, as for
	// gtk_text_view_add_overlay().
	MoveOverlay(child Widget, xpos int, ypos int)
	// MoveVisually: move the iterator a given number of characters visually,
	// treating it as the strong cursor position. If @count is positive, then
	// the new strong cursor position will be @count positions to the right of
	// the old cursor position. If @count is negative then the new strong cursor
	// position will be @count positions to the left of the old cursor position.
	//
	// In the presence of bi-directional text, the correspondence between
	// logical and visual order will depend on the direction of the current run,
	// and there may be jumps when the cursor is moved off of the end of a run.
	MoveVisually(iter *TextIter, count int) bool
	// PlaceCursorOnscreen moves the cursor to the currently visible region of
	// the buffer, if it isn’t there already.
	PlaceCursorOnscreen() bool
	// Remove removes a child widget from @text_view.
	Remove(child Widget)
	// ResetCursorBlink ensures that the cursor is shown (i.e. not in an 'off'
	// blink interval) and resets the time that it will stay blinking (or
	// visible, in case blinking is disabled).
	//
	// This function should be called in response to user input (e.g. from
	// derived classes that override the textview's event handlers).
	ResetCursorBlink()
	// ResetImContext: reset the input method context of the text view if
	// needed.
	//
	// This can be necessary in the case where modifying the buffer would
	// confuse on-going input method behavior.
	ResetImContext()
	// ScrollMarkOnscreen scrolls @text_view the minimum distance such that
	// @mark is contained within the visible area of the widget.
	ScrollMarkOnscreen(mark TextMark)
	// ScrollToIter scrolls @text_view so that @iter is on the screen in the
	// position indicated by @xalign and @yalign. An alignment of 0.0 indicates
	// left or top, 1.0 indicates right or bottom, 0.5 means center. If
	// @use_align is false, the text scrolls the minimal distance to get the
	// mark onscreen, possibly not scrolling at all. The effective screen for
	// purposes of this function is reduced by a margin of size @within_margin.
	//
	// Note that this function uses the currently-computed height of the lines
	// in the text buffer. Line heights are computed in an idle handler; so this
	// function may not have the desired effect if it’s called before the height
	// computations. To avoid oddness, consider using
	// gtk_text_view_scroll_to_mark() which saves a point to be scrolled to
	// after line validation.
	ScrollToIter(iter *TextIter, withinMargin float64, useAlign bool, xalign float64, yalign float64) bool
	// ScrollToMark scrolls @text_view so that @mark is on the screen in the
	// position indicated by @xalign and @yalign. An alignment of 0.0 indicates
	// left or top, 1.0 indicates right or bottom, 0.5 means center. If
	// @use_align is false, the text scrolls the minimal distance to get the
	// mark onscreen, possibly not scrolling at all. The effective screen for
	// purposes of this function is reduced by a margin of size @within_margin.
	ScrollToMark(mark TextMark, withinMargin float64, useAlign bool, xalign float64, yalign float64)
	// SetAcceptsTab sets the behavior of the text widget when the Tab key is
	// pressed. If @accepts_tab is true, a tab character is inserted. If
	// @accepts_tab is false the keyboard focus is moved to the next widget in
	// the focus chain.
	SetAcceptsTab(acceptsTab bool)
	// SetBottomMargin sets the bottom margin for text in @text_view.
	//
	// Note that this function is confusingly named. In CSS terms, the value set
	// here is padding.
	SetBottomMargin(bottomMargin int)
	// SetBuffer sets @buffer as the buffer being displayed by @text_view. The
	// previous buffer displayed by the text view is unreferenced, and a
	// reference is added to @buffer. If you owned a reference to @buffer before
	// passing it to this function, you must remove that reference yourself;
	// TextView will not “adopt” it.
	SetBuffer(buffer TextBuffer)
	// SetCursorVisible toggles whether the insertion point should be displayed.
	// A buffer with no editable text probably shouldn’t have a visible cursor,
	// so you may want to turn the cursor off.
	//
	// Note that this property may be overridden by the
	// Settings:gtk-keynav-use-caret settings.
	SetCursorVisible(setting bool)
	// SetEditable sets the default editability of the TextView. You can
	// override this default setting with tags in the buffer, using the
	// “editable” attribute of tags.
	SetEditable(setting bool)
	// SetExtraMenu sets a menu model to add when constructing the context menu
	// for @text_view. You can pass nil to remove a previously set extra menu.
	SetExtraMenu(model gio.MenuModel)
	// SetGutter places @widget into the gutter specified by @win.
	//
	// @win must be one of GTK_TEXT_WINDOW_LEFT, GTK_TEXT_WINDOW_RIGHT,
	// GTK_TEXT_WINDOW_TOP, or GTK_TEXT_WINDOW_BOTTOM.
	SetGutter(win TextWindowType, widget Widget)
	// SetIndent sets the default indentation for paragraphs in @text_view. Tags
	// in the buffer may override the default.
	SetIndent(indent int)
	// SetInputHints sets the TextView:input-hints property, which allows input
	// methods to fine-tune their behaviour.
	SetInputHints(hints InputHints)
	// SetInputPurpose sets the TextView:input-purpose property which can be
	// used by on-screen keyboards and other input methods to adjust their
	// behaviour.
	SetInputPurpose(purpose InputPurpose)
	// SetJustification sets the default justification of text in @text_view.
	// Tags in the view’s buffer may override the default.
	SetJustification(justification Justification)
	// SetLeftMargin sets the default left margin for text in @text_view. Tags
	// in the buffer may override the default.
	//
	// Note that this function is confusingly named. In CSS terms, the value set
	// here is padding.
	SetLeftMargin(leftMargin int)
	// SetMonospace sets the TextView:monospace property, which indicates that
	// the text view should use monospace fonts.
	SetMonospace(monospace bool)
	// SetOverwrite changes the TextView overwrite mode.
	SetOverwrite(overwrite bool)
	// SetPixelsAboveLines sets the default number of blank pixels above
	// paragraphs in @text_view. Tags in the buffer for @text_view may override
	// the defaults.
	SetPixelsAboveLines(pixelsAboveLines int)
	// SetPixelsBelowLines sets the default number of pixels of blank space to
	// put below paragraphs in @text_view. May be overridden by tags applied to
	// @text_view’s buffer.
	SetPixelsBelowLines(pixelsBelowLines int)
	// SetPixelsInsideWrap sets the default number of pixels of blank space to
	// leave between display/wrapped lines within a paragraph. May be overridden
	// by tags in @text_view’s buffer.
	SetPixelsInsideWrap(pixelsInsideWrap int)
	// SetRightMargin sets the default right margin for text in the text view.
	// Tags in the buffer may override the default.
	//
	// Note that this function is confusingly named. In CSS terms, the value set
	// here is padding.
	SetRightMargin(rightMargin int)
	// SetTabs sets the default tab stops for paragraphs in @text_view. Tags in
	// the buffer may override the default.
	SetTabs(tabs *pango.TabArray)
	// SetTopMargin sets the top margin for text in @text_view.
	//
	// Note that this function is confusingly named. In CSS terms, the value set
	// here is padding.
	SetTopMargin(topMargin int)
	// SetWrapMode sets the line wrapping for the view.
	SetWrapMode(wrapMode WrapMode)
	// StartsDisplayLine determines whether @iter is at the start of a display
	// line. See gtk_text_view_forward_display_line() for an explanation of
	// display lines vs. paragraphs.
	StartsDisplayLine(iter *TextIter) bool
	// WindowToBufferCoords converts coordinates on the window identified by
	// @win to buffer coordinates, storing the result in (@buffer_x,@buffer_y).
	WindowToBufferCoords(win TextWindowType, windowX int, windowY int) (bufferX int, bufferY int)
}

type textView struct {
	widget
}

// WrapTextView wraps a GObject to the right type. It is
// primarily used internally.
func WrapTextView(obj *externglib.Object) TextView {
	return textView{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}
}

func marshalTextView(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTextView(obj), nil
}

// NewTextView constructs a class TextView.
func NewTextView() TextView {

	ret := C.gtk_text_view_new()

	var ret0 TextView

	ret0 = WrapTextView(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewTextViewWithBuffer constructs a class TextView.
func NewTextViewWithBuffer(buffer TextBuffer) TextView {
	var arg1 *C.GtkTextBuffer

	arg1 = (*C.GtkTextBuffer)(buffer.Native())

	ret := C.gtk_text_view_new_with_buffer(arg1)

	var ret0 TextView

	ret0 = WrapTextView(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// AddChildAtAnchor adds a child widget in the text buffer, at the given
// @anchor.
func (textView textView) AddChildAtAnchor(child Widget, anchor TextChildAnchor) {
	var arg0 *C.GtkTextView
	var arg1 *C.GtkWidget
	var arg2 *C.GtkTextChildAnchor

	arg0 = (*C.GtkTextView)(textView.Native())
	arg1 = (*C.GtkWidget)(child.Native())
	arg2 = (*C.GtkTextChildAnchor)(anchor.Native())

	C.gtk_text_view_add_child_at_anchor(arg0, arg1, arg2)
}

// AddOverlay adds @child at a fixed coordinate in the TextView's text
// window. The @xpos and @ypos must be in buffer coordinates (see
// gtk_text_view_get_iter_location() to convert to buffer coordinates).
//
// @child will scroll with the text view.
//
// If instead you want a widget that will not move with the TextView
// contents see Overlay.
func (textView textView) AddOverlay(child Widget, xpos int, ypos int) {
	var arg0 *C.GtkTextView
	var arg1 *C.GtkWidget
	var arg2 C.int
	var arg3 C.int

	arg0 = (*C.GtkTextView)(textView.Native())
	arg1 = (*C.GtkWidget)(child.Native())
	arg2 = C.int(xpos)
	arg3 = C.int(ypos)

	C.gtk_text_view_add_overlay(arg0, arg1, arg2, arg3)
}

// BackwardDisplayLine moves the given @iter backward by one display
// (wrapped) line. A display line is different from a paragraph. Paragraphs
// are separated by newlines or other paragraph separator characters.
// Display lines are created by line-wrapping a paragraph. If wrapping is
// turned off, display lines and paragraphs will be the same. Display lines
// are divided differently for each view, since they depend on the view’s
// width; paragraphs are the same in all views, since they depend on the
// contents of the TextBuffer.
func (textView textView) BackwardDisplayLine(iter *TextIter) bool {
	var arg0 *C.GtkTextView
	var arg1 *C.GtkTextIter

	arg0 = (*C.GtkTextView)(textView.Native())
	arg1 = (*C.GtkTextIter)(iter.Native())

	ret := C.gtk_text_view_backward_display_line(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// BackwardDisplayLineStart moves the given @iter backward to the next
// display line start. A display line is different from a paragraph.
// Paragraphs are separated by newlines or other paragraph separator
// characters. Display lines are created by line-wrapping a paragraph. If
// wrapping is turned off, display lines and paragraphs will be the same.
// Display lines are divided differently for each view, since they depend on
// the view’s width; paragraphs are the same in all views, since they depend
// on the contents of the TextBuffer.
func (textView textView) BackwardDisplayLineStart(iter *TextIter) bool {
	var arg0 *C.GtkTextView
	var arg1 *C.GtkTextIter

	arg0 = (*C.GtkTextView)(textView.Native())
	arg1 = (*C.GtkTextIter)(iter.Native())

	ret := C.gtk_text_view_backward_display_line_start(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// BufferToWindowCoords converts coordinate (@buffer_x, @buffer_y) to
// coordinates for the window @win, and stores the result in (@window_x,
// @window_y).
func (textView textView) BufferToWindowCoords(win TextWindowType, bufferX int, bufferY int) (windowX int, windowY int) {
	var arg0 *C.GtkTextView
	var arg1 C.GtkTextWindowType
	var arg2 C.int
	var arg3 C.int
	var arg4 *C.int // out
	var arg5 *C.int // out

	arg0 = (*C.GtkTextView)(textView.Native())
	arg1 = (C.GtkTextWindowType)(win)
	arg2 = C.int(bufferX)
	arg3 = C.int(bufferY)

	ret := C.gtk_text_view_buffer_to_window_coords(arg0, arg1, arg2, arg3, &arg4, &arg5)

	var ret0 int
	var ret1 int

	ret0 = int(arg4)

	ret1 = int(arg5)

	return ret0, ret1
}

// ForwardDisplayLine moves the given @iter forward by one display (wrapped)
// line. A display line is different from a paragraph. Paragraphs are
// separated by newlines or other paragraph separator characters. Display
// lines are created by line-wrapping a paragraph. If wrapping is turned
// off, display lines and paragraphs will be the same. Display lines are
// divided differently for each view, since they depend on the view’s width;
// paragraphs are the same in all views, since they depend on the contents
// of the TextBuffer.
func (textView textView) ForwardDisplayLine(iter *TextIter) bool {
	var arg0 *C.GtkTextView
	var arg1 *C.GtkTextIter

	arg0 = (*C.GtkTextView)(textView.Native())
	arg1 = (*C.GtkTextIter)(iter.Native())

	ret := C.gtk_text_view_forward_display_line(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// ForwardDisplayLineEnd moves the given @iter forward to the next display
// line end. A display line is different from a paragraph. Paragraphs are
// separated by newlines or other paragraph separator characters. Display
// lines are created by line-wrapping a paragraph. If wrapping is turned
// off, display lines and paragraphs will be the same. Display lines are
// divided differently for each view, since they depend on the view’s width;
// paragraphs are the same in all views, since they depend on the contents
// of the TextBuffer.
func (textView textView) ForwardDisplayLineEnd(iter *TextIter) bool {
	var arg0 *C.GtkTextView
	var arg1 *C.GtkTextIter

	arg0 = (*C.GtkTextView)(textView.Native())
	arg1 = (*C.GtkTextIter)(iter.Native())

	ret := C.gtk_text_view_forward_display_line_end(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// AcceptsTab returns whether pressing the Tab key inserts a tab characters.
// gtk_text_view_set_accepts_tab().
func (textView textView) AcceptsTab() bool {
	var arg0 *C.GtkTextView

	arg0 = (*C.GtkTextView)(textView.Native())

	ret := C.gtk_text_view_get_accepts_tab(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// BottomMargin gets the bottom margin for text in the @text_view.
func (textView textView) BottomMargin() int {
	var arg0 *C.GtkTextView

	arg0 = (*C.GtkTextView)(textView.Native())

	ret := C.gtk_text_view_get_bottom_margin(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Buffer returns the TextBuffer being displayed by this text view. The
// reference count on the buffer is not incremented; the caller of this
// function won’t own a new reference.
func (textView textView) Buffer() TextBuffer {
	var arg0 *C.GtkTextView

	arg0 = (*C.GtkTextView)(textView.Native())

	ret := C.gtk_text_view_get_buffer(arg0)

	var ret0 TextBuffer

	ret0 = WrapTextBuffer(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// CursorLocations: given an @iter within a text layout, determine the
// positions of the strong and weak cursors if the insertion point is at
// that iterator. The position of each cursor is stored as a zero-width
// rectangle. The strong cursor location is the location where characters of
// the directionality equal to the base direction of the paragraph are
// inserted. The weak cursor location is the location where characters of
// the directionality opposite to the base direction of the paragraph are
// inserted.
//
// If @iter is nil, the actual cursor position is used.
//
// Note that if @iter happens to be the actual cursor position, and there is
// currently an IM preedit sequence being entered, the returned locations
// will be adjusted to account for the preedit cursor’s offset within the
// preedit sequence.
//
// The rectangle position is in buffer coordinates; use
// gtk_text_view_buffer_to_window_coords() to convert these coordinates to
// coordinates for one of the windows in the text view.
func (textView textView) CursorLocations(iter *TextIter) (strong gdk.Rectangle, weak gdk.Rectangle) {
	var arg0 *C.GtkTextView
	var arg1 *C.GtkTextIter
	var arg2 *C.GdkRectangle // out
	var arg3 *C.GdkRectangle // out

	arg0 = (*C.GtkTextView)(textView.Native())
	arg1 = (*C.GtkTextIter)(iter.Native())

	ret := C.gtk_text_view_get_cursor_locations(arg0, arg1, &arg2, &arg3)

	var ret0 *gdk.Rectangle
	var ret1 *gdk.Rectangle

	ret0 = gdk.WrapRectangle(arg2)

	ret1 = gdk.WrapRectangle(arg3)

	return ret0, ret1
}

// CursorVisible: find out whether the cursor should be displayed.
func (textView textView) CursorVisible() bool {
	var arg0 *C.GtkTextView

	arg0 = (*C.GtkTextView)(textView.Native())

	ret := C.gtk_text_view_get_cursor_visible(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Editable returns the default editability of the TextView. Tags in the
// buffer may override this setting for some ranges of text.
func (textView textView) Editable() bool {
	var arg0 *C.GtkTextView

	arg0 = (*C.GtkTextView)(textView.Native())

	ret := C.gtk_text_view_get_editable(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// ExtraMenu gets the menu model set with gtk_text_view_set_extra_menu() or
// nil if none has been set.
func (textView textView) ExtraMenu() gio.MenuModel {
	var arg0 *C.GtkTextView

	arg0 = (*C.GtkTextView)(textView.Native())

	ret := C.gtk_text_view_get_extra_menu(arg0)

	var ret0 gio.MenuModel

	ret0 = gio.WrapMenuModel(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Gutter gets a Widget that has previously been set with
// gtk_text_view_set_gutter().
//
// @win must be one of GTK_TEXT_WINDOW_LEFT, GTK_TEXT_WINDOW_RIGHT,
// GTK_TEXT_WINDOW_TOP, or GTK_TEXT_WINDOW_BOTTOM.
func (textView textView) Gutter(win TextWindowType) Widget {
	var arg0 *C.GtkTextView
	var arg1 C.GtkTextWindowType

	arg0 = (*C.GtkTextView)(textView.Native())
	arg1 = (C.GtkTextWindowType)(win)

	ret := C.gtk_text_view_get_gutter(arg0, arg1)

	var ret0 Widget

	ret0 = WrapWidget(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Indent gets the default indentation of paragraphs in @text_view. Tags in
// the view’s buffer may override the default. The indentation may be
// negative.
func (textView textView) Indent() int {
	var arg0 *C.GtkTextView

	arg0 = (*C.GtkTextView)(textView.Native())

	ret := C.gtk_text_view_get_indent(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// InputHints gets the value of the TextView:input-hints property.
func (textView textView) InputHints() InputHints {
	var arg0 *C.GtkTextView

	arg0 = (*C.GtkTextView)(textView.Native())

	ret := C.gtk_text_view_get_input_hints(arg0)

	var ret0 InputHints

	ret0 = InputHints(ret)

	return ret0
}

// InputPurpose gets the value of the TextView:input-purpose property.
func (textView textView) InputPurpose() InputPurpose {
	var arg0 *C.GtkTextView

	arg0 = (*C.GtkTextView)(textView.Native())

	ret := C.gtk_text_view_get_input_purpose(arg0)

	var ret0 InputPurpose

	ret0 = InputPurpose(ret)

	return ret0
}

// IterAtLocation retrieves the iterator at buffer coordinates @x and @y.
// Buffer coordinates are coordinates for the entire buffer, not just the
// currently-displayed portion. If you have coordinates from an event, you
// have to convert those to buffer coordinates with
// gtk_text_view_window_to_buffer_coords().
func (textView textView) IterAtLocation(x int, y int) (iter TextIter, ok bool) {
	var arg0 *C.GtkTextView
	var arg1 *C.GtkTextIter // out
	var arg2 C.int
	var arg3 C.int

	arg0 = (*C.GtkTextView)(textView.Native())
	arg2 = C.int(x)
	arg3 = C.int(y)

	ret := C.gtk_text_view_get_iter_at_location(arg0, &arg1, arg2, arg3)

	var ret0 *TextIter
	var ret1 bool

	ret0 = WrapTextIter(arg1)

	ret1 = gextras.Gobool(ret)

	return ret0, ret1
}

// IterAtPosition retrieves the iterator pointing to the character at buffer
// coordinates @x and @y. Buffer coordinates are coordinates for the entire
// buffer, not just the currently-displayed portion. If you have coordinates
// from an event, you have to convert those to buffer coordinates with
// gtk_text_view_window_to_buffer_coords().
//
// Note that this is different from gtk_text_view_get_iter_at_location(),
// which returns cursor locations, i.e. positions between characters.
func (textView textView) IterAtPosition(x int, y int) (iter TextIter, trailing int, ok bool) {
	var arg0 *C.GtkTextView
	var arg1 *C.GtkTextIter // out
	var arg2 *C.int         // out
	var arg3 C.int
	var arg4 C.int

	arg0 = (*C.GtkTextView)(textView.Native())
	arg3 = C.int(x)
	arg4 = C.int(y)

	ret := C.gtk_text_view_get_iter_at_position(arg0, &arg1, &arg2, arg3, arg4)

	var ret0 *TextIter
	var ret1 int
	var ret2 bool

	ret0 = WrapTextIter(arg1)

	ret1 = int(arg2)

	ret2 = gextras.Gobool(ret)

	return ret0, ret1, ret2
}

// IterLocation gets a rectangle which roughly contains the character at
// @iter. The rectangle position is in buffer coordinates; use
// gtk_text_view_buffer_to_window_coords() to convert these coordinates to
// coordinates for one of the windows in the text view.
func (textView textView) IterLocation(iter *TextIter) gdk.Rectangle {
	var arg0 *C.GtkTextView
	var arg1 *C.GtkTextIter
	var arg2 *C.GdkRectangle // out

	arg0 = (*C.GtkTextView)(textView.Native())
	arg1 = (*C.GtkTextIter)(iter.Native())

	ret := C.gtk_text_view_get_iter_location(arg0, arg1, &arg2)

	var ret0 *gdk.Rectangle

	ret0 = gdk.WrapRectangle(arg2)

	return ret0
}

// Justification gets the default justification of paragraphs in @text_view.
// Tags in the buffer may override the default.
func (textView textView) Justification() Justification {
	var arg0 *C.GtkTextView

	arg0 = (*C.GtkTextView)(textView.Native())

	ret := C.gtk_text_view_get_justification(arg0)

	var ret0 Justification

	ret0 = Justification(ret)

	return ret0
}

// LeftMargin gets the default left margin size of paragraphs in the
// @text_view. Tags in the buffer may override the default.
func (textView textView) LeftMargin() int {
	var arg0 *C.GtkTextView

	arg0 = (*C.GtkTextView)(textView.Native())

	ret := C.gtk_text_view_get_left_margin(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// LineAtY gets the TextIter at the start of the line containing the
// coordinate @y. @y is in buffer coordinates, convert from window
// coordinates with gtk_text_view_window_to_buffer_coords(). If non-nil,
// @line_top will be filled with the coordinate of the top edge of the line.
func (textView textView) LineAtY(y int) (targetIter TextIter, lineTop int) {
	var arg0 *C.GtkTextView
	var arg1 *C.GtkTextIter // out
	var arg2 C.int
	var arg3 *C.int // out

	arg0 = (*C.GtkTextView)(textView.Native())
	arg2 = C.int(y)

	ret := C.gtk_text_view_get_line_at_y(arg0, &arg1, arg2, &arg3)

	var ret0 *TextIter
	var ret1 int

	ret0 = WrapTextIter(arg1)

	ret1 = int(arg3)

	return ret0, ret1
}

// LineYrange gets the y coordinate of the top of the line containing @iter,
// and the height of the line. The coordinate is a buffer coordinate;
// convert to window coordinates with
// gtk_text_view_buffer_to_window_coords().
func (textView textView) LineYrange(iter *TextIter) (y int, height int) {
	var arg0 *C.GtkTextView
	var arg1 *C.GtkTextIter
	var arg2 *C.int // out
	var arg3 *C.int // out

	arg0 = (*C.GtkTextView)(textView.Native())
	arg1 = (*C.GtkTextIter)(iter.Native())

	ret := C.gtk_text_view_get_line_yrange(arg0, arg1, &arg2, &arg3)

	var ret0 int
	var ret1 int

	ret0 = int(arg2)

	ret1 = int(arg3)

	return ret0, ret1
}

// Monospace gets the value of the TextView:monospace property.
func (textView textView) Monospace() bool {
	var arg0 *C.GtkTextView

	arg0 = (*C.GtkTextView)(textView.Native())

	ret := C.gtk_text_view_get_monospace(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Overwrite returns whether the TextView is in overwrite mode or not.
func (textView textView) Overwrite() bool {
	var arg0 *C.GtkTextView

	arg0 = (*C.GtkTextView)(textView.Native())

	ret := C.gtk_text_view_get_overwrite(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// PixelsAboveLines gets the default number of pixels to put above
// paragraphs. Adding this function with
// gtk_text_view_get_pixels_below_lines() is equal to the line space between
// each paragraph.
func (textView textView) PixelsAboveLines() int {
	var arg0 *C.GtkTextView

	arg0 = (*C.GtkTextView)(textView.Native())

	ret := C.gtk_text_view_get_pixels_above_lines(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// PixelsBelowLines gets the value set by
// gtk_text_view_set_pixels_below_lines().
//
// The line space is the sum of the value returned by this function and the
// value returned by gtk_text_view_get_pixels_above_lines().
func (textView textView) PixelsBelowLines() int {
	var arg0 *C.GtkTextView

	arg0 = (*C.GtkTextView)(textView.Native())

	ret := C.gtk_text_view_get_pixels_below_lines(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// PixelsInsideWrap gets the value set by
// gtk_text_view_set_pixels_inside_wrap().
func (textView textView) PixelsInsideWrap() int {
	var arg0 *C.GtkTextView

	arg0 = (*C.GtkTextView)(textView.Native())

	ret := C.gtk_text_view_get_pixels_inside_wrap(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// RightMargin gets the default right margin for text in @text_view. Tags in
// the buffer may override the default.
func (textView textView) RightMargin() int {
	var arg0 *C.GtkTextView

	arg0 = (*C.GtkTextView)(textView.Native())

	ret := C.gtk_text_view_get_right_margin(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Tabs gets the default tabs for @text_view. Tags in the buffer may
// override the defaults. The returned array will be nil if “standard”
// (8-space) tabs are used. Free the return value with
// pango_tab_array_free().
func (textView textView) Tabs() *pango.TabArray {
	var arg0 *C.GtkTextView

	arg0 = (*C.GtkTextView)(textView.Native())

	ret := C.gtk_text_view_get_tabs(arg0)

	var ret0 *pango.TabArray

	ret0 = pango.WrapTabArray(ret)

	return ret0
}

// TopMargin gets the top margin for text in the @text_view.
func (textView textView) TopMargin() int {
	var arg0 *C.GtkTextView

	arg0 = (*C.GtkTextView)(textView.Native())

	ret := C.gtk_text_view_get_top_margin(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// VisibleRect fills @visible_rect with the currently-visible region of the
// buffer, in buffer coordinates. Convert to window coordinates with
// gtk_text_view_buffer_to_window_coords().
func (textView textView) VisibleRect() gdk.Rectangle {
	var arg0 *C.GtkTextView
	var arg1 *C.GdkRectangle // out

	arg0 = (*C.GtkTextView)(textView.Native())

	ret := C.gtk_text_view_get_visible_rect(arg0, &arg1)

	var ret0 *gdk.Rectangle

	ret0 = gdk.WrapRectangle(arg1)

	return ret0
}

// WrapMode gets the line wrapping for the view.
func (textView textView) WrapMode() WrapMode {
	var arg0 *C.GtkTextView

	arg0 = (*C.GtkTextView)(textView.Native())

	ret := C.gtk_text_view_get_wrap_mode(arg0)

	var ret0 WrapMode

	ret0 = WrapMode(ret)

	return ret0
}

// ImContextFilterKeypress: allow the TextView input method to internally
// handle key press and release events. If this function returns true, then
// no further processing should be done for this key event. See
// gtk_im_context_filter_keypress().
//
// Note that you are expected to call this function from your handler when
// overriding key event handling. This is needed in the case when you need
// to insert your own key handling between the input method and the default
// key event handling of the TextView.
//
//    static gboolean
//    gtk_foo_bar_key_press_event (GtkWidget *widget,
//                                 GdkEvent  *event)
//    {
//      guint keyval;
//
//      gdk_event_get_keyval ((GdkEvent*)event, &keyval);
//
//      if (keyval == GDK_KEY_Return || keyval == GDK_KEY_KP_Enter)
//        {
//          if (gtk_text_view_im_context_filter_keypress (GTK_TEXT_VIEW (widget), event))
//            return TRUE;
//        }
//
//      // Do some stuff
//
//      return GTK_WIDGET_CLASS (gtk_foo_bar_parent_class)->key_press_event (widget, event);
//    }
//
func (textView textView) ImContextFilterKeypress(event gdk.Event) bool {
	var arg0 *C.GtkTextView
	var arg1 *C.GdkEvent

	arg0 = (*C.GtkTextView)(textView.Native())
	arg1 = (*C.GdkEvent)(event.Native())

	ret := C.gtk_text_view_im_context_filter_keypress(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// MoveMarkOnscreen moves a mark within the buffer so that it's located
// within the currently-visible text area.
func (textView textView) MoveMarkOnscreen(mark TextMark) bool {
	var arg0 *C.GtkTextView
	var arg1 *C.GtkTextMark

	arg0 = (*C.GtkTextView)(textView.Native())
	arg1 = (*C.GtkTextMark)(mark.Native())

	ret := C.gtk_text_view_move_mark_onscreen(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// MoveOverlay updates the position of a child, as for
// gtk_text_view_add_overlay().
func (textView textView) MoveOverlay(child Widget, xpos int, ypos int) {
	var arg0 *C.GtkTextView
	var arg1 *C.GtkWidget
	var arg2 C.int
	var arg3 C.int

	arg0 = (*C.GtkTextView)(textView.Native())
	arg1 = (*C.GtkWidget)(child.Native())
	arg2 = C.int(xpos)
	arg3 = C.int(ypos)

	C.gtk_text_view_move_overlay(arg0, arg1, arg2, arg3)
}

// MoveVisually: move the iterator a given number of characters visually,
// treating it as the strong cursor position. If @count is positive, then
// the new strong cursor position will be @count positions to the right of
// the old cursor position. If @count is negative then the new strong cursor
// position will be @count positions to the left of the old cursor position.
//
// In the presence of bi-directional text, the correspondence between
// logical and visual order will depend on the direction of the current run,
// and there may be jumps when the cursor is moved off of the end of a run.
func (textView textView) MoveVisually(iter *TextIter, count int) bool {
	var arg0 *C.GtkTextView
	var arg1 *C.GtkTextIter
	var arg2 C.int

	arg0 = (*C.GtkTextView)(textView.Native())
	arg1 = (*C.GtkTextIter)(iter.Native())
	arg2 = C.int(count)

	ret := C.gtk_text_view_move_visually(arg0, arg1, arg2)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// PlaceCursorOnscreen moves the cursor to the currently visible region of
// the buffer, if it isn’t there already.
func (textView textView) PlaceCursorOnscreen() bool {
	var arg0 *C.GtkTextView

	arg0 = (*C.GtkTextView)(textView.Native())

	ret := C.gtk_text_view_place_cursor_onscreen(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Remove removes a child widget from @text_view.
func (textView textView) Remove(child Widget) {
	var arg0 *C.GtkTextView
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkTextView)(textView.Native())
	arg1 = (*C.GtkWidget)(child.Native())

	C.gtk_text_view_remove(arg0, arg1)
}

// ResetCursorBlink ensures that the cursor is shown (i.e. not in an 'off'
// blink interval) and resets the time that it will stay blinking (or
// visible, in case blinking is disabled).
//
// This function should be called in response to user input (e.g. from
// derived classes that override the textview's event handlers).
func (textView textView) ResetCursorBlink() {
	var arg0 *C.GtkTextView

	arg0 = (*C.GtkTextView)(textView.Native())

	C.gtk_text_view_reset_cursor_blink(arg0)
}

// ResetImContext: reset the input method context of the text view if
// needed.
//
// This can be necessary in the case where modifying the buffer would
// confuse on-going input method behavior.
func (textView textView) ResetImContext() {
	var arg0 *C.GtkTextView

	arg0 = (*C.GtkTextView)(textView.Native())

	C.gtk_text_view_reset_im_context(arg0)
}

// ScrollMarkOnscreen scrolls @text_view the minimum distance such that
// @mark is contained within the visible area of the widget.
func (textView textView) ScrollMarkOnscreen(mark TextMark) {
	var arg0 *C.GtkTextView
	var arg1 *C.GtkTextMark

	arg0 = (*C.GtkTextView)(textView.Native())
	arg1 = (*C.GtkTextMark)(mark.Native())

	C.gtk_text_view_scroll_mark_onscreen(arg0, arg1)
}

// ScrollToIter scrolls @text_view so that @iter is on the screen in the
// position indicated by @xalign and @yalign. An alignment of 0.0 indicates
// left or top, 1.0 indicates right or bottom, 0.5 means center. If
// @use_align is false, the text scrolls the minimal distance to get the
// mark onscreen, possibly not scrolling at all. The effective screen for
// purposes of this function is reduced by a margin of size @within_margin.
//
// Note that this function uses the currently-computed height of the lines
// in the text buffer. Line heights are computed in an idle handler; so this
// function may not have the desired effect if it’s called before the height
// computations. To avoid oddness, consider using
// gtk_text_view_scroll_to_mark() which saves a point to be scrolled to
// after line validation.
func (textView textView) ScrollToIter(iter *TextIter, withinMargin float64, useAlign bool, xalign float64, yalign float64) bool {
	var arg0 *C.GtkTextView
	var arg1 *C.GtkTextIter
	var arg2 C.double
	var arg3 C.gboolean
	var arg4 C.double
	var arg5 C.double

	arg0 = (*C.GtkTextView)(textView.Native())
	arg1 = (*C.GtkTextIter)(iter.Native())
	arg2 = C.double(withinMargin)
	arg3 = gextras.Cbool(useAlign)
	arg4 = C.double(xalign)
	arg5 = C.double(yalign)

	ret := C.gtk_text_view_scroll_to_iter(arg0, arg1, arg2, arg3, arg4, arg5)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// ScrollToMark scrolls @text_view so that @mark is on the screen in the
// position indicated by @xalign and @yalign. An alignment of 0.0 indicates
// left or top, 1.0 indicates right or bottom, 0.5 means center. If
// @use_align is false, the text scrolls the minimal distance to get the
// mark onscreen, possibly not scrolling at all. The effective screen for
// purposes of this function is reduced by a margin of size @within_margin.
func (textView textView) ScrollToMark(mark TextMark, withinMargin float64, useAlign bool, xalign float64, yalign float64) {
	var arg0 *C.GtkTextView
	var arg1 *C.GtkTextMark
	var arg2 C.double
	var arg3 C.gboolean
	var arg4 C.double
	var arg5 C.double

	arg0 = (*C.GtkTextView)(textView.Native())
	arg1 = (*C.GtkTextMark)(mark.Native())
	arg2 = C.double(withinMargin)
	arg3 = gextras.Cbool(useAlign)
	arg4 = C.double(xalign)
	arg5 = C.double(yalign)

	C.gtk_text_view_scroll_to_mark(arg0, arg1, arg2, arg3, arg4, arg5)
}

// SetAcceptsTab sets the behavior of the text widget when the Tab key is
// pressed. If @accepts_tab is true, a tab character is inserted. If
// @accepts_tab is false the keyboard focus is moved to the next widget in
// the focus chain.
func (textView textView) SetAcceptsTab(acceptsTab bool) {
	var arg0 *C.GtkTextView
	var arg1 C.gboolean

	arg0 = (*C.GtkTextView)(textView.Native())
	arg1 = gextras.Cbool(acceptsTab)

	C.gtk_text_view_set_accepts_tab(arg0, arg1)
}

// SetBottomMargin sets the bottom margin for text in @text_view.
//
// Note that this function is confusingly named. In CSS terms, the value set
// here is padding.
func (textView textView) SetBottomMargin(bottomMargin int) {
	var arg0 *C.GtkTextView
	var arg1 C.int

	arg0 = (*C.GtkTextView)(textView.Native())
	arg1 = C.int(bottomMargin)

	C.gtk_text_view_set_bottom_margin(arg0, arg1)
}

// SetBuffer sets @buffer as the buffer being displayed by @text_view. The
// previous buffer displayed by the text view is unreferenced, and a
// reference is added to @buffer. If you owned a reference to @buffer before
// passing it to this function, you must remove that reference yourself;
// TextView will not “adopt” it.
func (textView textView) SetBuffer(buffer TextBuffer) {
	var arg0 *C.GtkTextView
	var arg1 *C.GtkTextBuffer

	arg0 = (*C.GtkTextView)(textView.Native())
	arg1 = (*C.GtkTextBuffer)(buffer.Native())

	C.gtk_text_view_set_buffer(arg0, arg1)
}

// SetCursorVisible toggles whether the insertion point should be displayed.
// A buffer with no editable text probably shouldn’t have a visible cursor,
// so you may want to turn the cursor off.
//
// Note that this property may be overridden by the
// Settings:gtk-keynav-use-caret settings.
func (textView textView) SetCursorVisible(setting bool) {
	var arg0 *C.GtkTextView
	var arg1 C.gboolean

	arg0 = (*C.GtkTextView)(textView.Native())
	arg1 = gextras.Cbool(setting)

	C.gtk_text_view_set_cursor_visible(arg0, arg1)
}

// SetEditable sets the default editability of the TextView. You can
// override this default setting with tags in the buffer, using the
// “editable” attribute of tags.
func (textView textView) SetEditable(setting bool) {
	var arg0 *C.GtkTextView
	var arg1 C.gboolean

	arg0 = (*C.GtkTextView)(textView.Native())
	arg1 = gextras.Cbool(setting)

	C.gtk_text_view_set_editable(arg0, arg1)
}

// SetExtraMenu sets a menu model to add when constructing the context menu
// for @text_view. You can pass nil to remove a previously set extra menu.
func (textView textView) SetExtraMenu(model gio.MenuModel) {
	var arg0 *C.GtkTextView
	var arg1 *C.GMenuModel

	arg0 = (*C.GtkTextView)(textView.Native())
	arg1 = (*C.GMenuModel)(model.Native())

	C.gtk_text_view_set_extra_menu(arg0, arg1)
}

// SetGutter places @widget into the gutter specified by @win.
//
// @win must be one of GTK_TEXT_WINDOW_LEFT, GTK_TEXT_WINDOW_RIGHT,
// GTK_TEXT_WINDOW_TOP, or GTK_TEXT_WINDOW_BOTTOM.
func (textView textView) SetGutter(win TextWindowType, widget Widget) {
	var arg0 *C.GtkTextView
	var arg1 C.GtkTextWindowType
	var arg2 *C.GtkWidget

	arg0 = (*C.GtkTextView)(textView.Native())
	arg1 = (C.GtkTextWindowType)(win)
	arg2 = (*C.GtkWidget)(widget.Native())

	C.gtk_text_view_set_gutter(arg0, arg1, arg2)
}

// SetIndent sets the default indentation for paragraphs in @text_view. Tags
// in the buffer may override the default.
func (textView textView) SetIndent(indent int) {
	var arg0 *C.GtkTextView
	var arg1 C.int

	arg0 = (*C.GtkTextView)(textView.Native())
	arg1 = C.int(indent)

	C.gtk_text_view_set_indent(arg0, arg1)
}

// SetInputHints sets the TextView:input-hints property, which allows input
// methods to fine-tune their behaviour.
func (textView textView) SetInputHints(hints InputHints) {
	var arg0 *C.GtkTextView
	var arg1 C.GtkInputHints

	arg0 = (*C.GtkTextView)(textView.Native())
	arg1 = (C.GtkInputHints)(hints)

	C.gtk_text_view_set_input_hints(arg0, arg1)
}

// SetInputPurpose sets the TextView:input-purpose property which can be
// used by on-screen keyboards and other input methods to adjust their
// behaviour.
func (textView textView) SetInputPurpose(purpose InputPurpose) {
	var arg0 *C.GtkTextView
	var arg1 C.GtkInputPurpose

	arg0 = (*C.GtkTextView)(textView.Native())
	arg1 = (C.GtkInputPurpose)(purpose)

	C.gtk_text_view_set_input_purpose(arg0, arg1)
}

// SetJustification sets the default justification of text in @text_view.
// Tags in the view’s buffer may override the default.
func (textView textView) SetJustification(justification Justification) {
	var arg0 *C.GtkTextView
	var arg1 C.GtkJustification

	arg0 = (*C.GtkTextView)(textView.Native())
	arg1 = (C.GtkJustification)(justification)

	C.gtk_text_view_set_justification(arg0, arg1)
}

// SetLeftMargin sets the default left margin for text in @text_view. Tags
// in the buffer may override the default.
//
// Note that this function is confusingly named. In CSS terms, the value set
// here is padding.
func (textView textView) SetLeftMargin(leftMargin int) {
	var arg0 *C.GtkTextView
	var arg1 C.int

	arg0 = (*C.GtkTextView)(textView.Native())
	arg1 = C.int(leftMargin)

	C.gtk_text_view_set_left_margin(arg0, arg1)
}

// SetMonospace sets the TextView:monospace property, which indicates that
// the text view should use monospace fonts.
func (textView textView) SetMonospace(monospace bool) {
	var arg0 *C.GtkTextView
	var arg1 C.gboolean

	arg0 = (*C.GtkTextView)(textView.Native())
	arg1 = gextras.Cbool(monospace)

	C.gtk_text_view_set_monospace(arg0, arg1)
}

// SetOverwrite changes the TextView overwrite mode.
func (textView textView) SetOverwrite(overwrite bool) {
	var arg0 *C.GtkTextView
	var arg1 C.gboolean

	arg0 = (*C.GtkTextView)(textView.Native())
	arg1 = gextras.Cbool(overwrite)

	C.gtk_text_view_set_overwrite(arg0, arg1)
}

// SetPixelsAboveLines sets the default number of blank pixels above
// paragraphs in @text_view. Tags in the buffer for @text_view may override
// the defaults.
func (textView textView) SetPixelsAboveLines(pixelsAboveLines int) {
	var arg0 *C.GtkTextView
	var arg1 C.int

	arg0 = (*C.GtkTextView)(textView.Native())
	arg1 = C.int(pixelsAboveLines)

	C.gtk_text_view_set_pixels_above_lines(arg0, arg1)
}

// SetPixelsBelowLines sets the default number of pixels of blank space to
// put below paragraphs in @text_view. May be overridden by tags applied to
// @text_view’s buffer.
func (textView textView) SetPixelsBelowLines(pixelsBelowLines int) {
	var arg0 *C.GtkTextView
	var arg1 C.int

	arg0 = (*C.GtkTextView)(textView.Native())
	arg1 = C.int(pixelsBelowLines)

	C.gtk_text_view_set_pixels_below_lines(arg0, arg1)
}

// SetPixelsInsideWrap sets the default number of pixels of blank space to
// leave between display/wrapped lines within a paragraph. May be overridden
// by tags in @text_view’s buffer.
func (textView textView) SetPixelsInsideWrap(pixelsInsideWrap int) {
	var arg0 *C.GtkTextView
	var arg1 C.int

	arg0 = (*C.GtkTextView)(textView.Native())
	arg1 = C.int(pixelsInsideWrap)

	C.gtk_text_view_set_pixels_inside_wrap(arg0, arg1)
}

// SetRightMargin sets the default right margin for text in the text view.
// Tags in the buffer may override the default.
//
// Note that this function is confusingly named. In CSS terms, the value set
// here is padding.
func (textView textView) SetRightMargin(rightMargin int) {
	var arg0 *C.GtkTextView
	var arg1 C.int

	arg0 = (*C.GtkTextView)(textView.Native())
	arg1 = C.int(rightMargin)

	C.gtk_text_view_set_right_margin(arg0, arg1)
}

// SetTabs sets the default tab stops for paragraphs in @text_view. Tags in
// the buffer may override the default.
func (textView textView) SetTabs(tabs *pango.TabArray) {
	var arg0 *C.GtkTextView
	var arg1 *C.PangoTabArray

	arg0 = (*C.GtkTextView)(textView.Native())
	arg1 = (*C.PangoTabArray)(tabs.Native())

	C.gtk_text_view_set_tabs(arg0, arg1)
}

// SetTopMargin sets the top margin for text in @text_view.
//
// Note that this function is confusingly named. In CSS terms, the value set
// here is padding.
func (textView textView) SetTopMargin(topMargin int) {
	var arg0 *C.GtkTextView
	var arg1 C.int

	arg0 = (*C.GtkTextView)(textView.Native())
	arg1 = C.int(topMargin)

	C.gtk_text_view_set_top_margin(arg0, arg1)
}

// SetWrapMode sets the line wrapping for the view.
func (textView textView) SetWrapMode(wrapMode WrapMode) {
	var arg0 *C.GtkTextView
	var arg1 C.GtkWrapMode

	arg0 = (*C.GtkTextView)(textView.Native())
	arg1 = (C.GtkWrapMode)(wrapMode)

	C.gtk_text_view_set_wrap_mode(arg0, arg1)
}

// StartsDisplayLine determines whether @iter is at the start of a display
// line. See gtk_text_view_forward_display_line() for an explanation of
// display lines vs. paragraphs.
func (textView textView) StartsDisplayLine(iter *TextIter) bool {
	var arg0 *C.GtkTextView
	var arg1 *C.GtkTextIter

	arg0 = (*C.GtkTextView)(textView.Native())
	arg1 = (*C.GtkTextIter)(iter.Native())

	ret := C.gtk_text_view_starts_display_line(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// WindowToBufferCoords converts coordinates on the window identified by
// @win to buffer coordinates, storing the result in (@buffer_x,@buffer_y).
func (textView textView) WindowToBufferCoords(win TextWindowType, windowX int, windowY int) (bufferX int, bufferY int) {
	var arg0 *C.GtkTextView
	var arg1 C.GtkTextWindowType
	var arg2 C.int
	var arg3 C.int
	var arg4 *C.int // out
	var arg5 *C.int // out

	arg0 = (*C.GtkTextView)(textView.Native())
	arg1 = (C.GtkTextWindowType)(win)
	arg2 = C.int(windowX)
	arg3 = C.int(windowY)

	ret := C.gtk_text_view_window_to_buffer_coords(arg0, arg1, arg2, arg3, &arg4, &arg5)

	var ret0 int
	var ret1 int

	ret0 = int(arg4)

	ret1 = int(arg5)

	return ret0, ret1
}

// ToggleButton: a ToggleButton is a Button which will remain “pressed-in” when
// clicked. Clicking again will cause the toggle button to return to its normal
// state.
//
// A toggle button is created by calling either gtk_toggle_button_new() or
// gtk_toggle_button_new_with_label(). If using the former, it is advisable to
// pack a widget, (such as a Label and/or a Image), into the toggle button’s
// container. (See Button for more information).
//
// The state of a ToggleButton can be set specifically using
// gtk_toggle_button_set_active(), and retrieved using
// gtk_toggle_button_get_active().
//
// To simply switch the state of a toggle button, use
// gtk_toggle_button_toggled().
//
//
// CSS nodes
//
// GtkToggleButton has a single CSS node with name button. To differentiate it
// from a plain Button, it gets the .toggle style class.
//
// Creating two ToggleButton widgets.
//
//    static void output_state (GtkToggleButton *source, gpointer user_data) {
//      printf ("Active: d\n", gtk_toggle_button_get_active (source));
//    }
//
//    void make_toggles (void) {
//      GtkWidget *window, *toggle1, *toggle2;
//      GtkWidget *box;
//      const char *text;
//
//      window = gtk_window_new ();
//      box = gtk_box_new (GTK_ORIENTATION_VERTICAL, 12);
//
//      text = "Hi, I’m a toggle button.";
//      toggle1 = gtk_toggle_button_new_with_label (text);
//
//      g_signal_connect (toggle1, "toggled",
//                        G_CALLBACK (output_state),
//                        NULL);
//      gtk_box_append (GTK_BOX (box), toggle1);
//
//      text = "Hi, I’m a toggle button.";
//      toggle2 = gtk_toggle_button_new_with_label (text);
//      g_signal_connect (toggle2, "toggled",
//                        G_CALLBACK (output_state),
//                        NULL);
//      gtk_box_append (GTK_BOX (box), toggle2);
//
//      gtk_window_set_child (GTK_WINDOW (window), box);
//      gtk_widget_show (window);
//    }
//
type ToggleButton interface {
	Button

	// Active queries a ToggleButton and returns its current state. Returns true
	// if the toggle button is pressed in and false if it is raised.
	Active() bool
	// SetActive sets the status of the toggle button. Set to true if you want
	// the GtkToggleButton to be “pressed in”, and false to raise it.
	//
	// If the status of the button changes, this action causes the
	// ToggleButton::toggled signal to be emitted.
	SetActive(isActive bool)
	// SetGroup adds @self to the group of @group. In a group of multiple toggle
	// buttons, only one button can be active at a time.
	//
	// Note that the same effect can be achieved via the Actionable api, by
	// using the same action with parameter type and state type 's' for all
	// buttons in the group, and giving each button its own target value.
	SetGroup(group ToggleButton)
	// Toggled emits the ToggleButton::toggled signal on the ToggleButton. There
	// is no good reason for an application ever to call this function.
	Toggled()
}

type toggleButton struct {
	button
}

// WrapToggleButton wraps a GObject to the right type. It is
// primarily used internally.
func WrapToggleButton(obj *externglib.Object) ToggleButton {
	return toggleButton{button{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}}
}

func marshalToggleButton(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapToggleButton(obj), nil
}

// NewToggleButton constructs a class ToggleButton.
func NewToggleButton() ToggleButton {

	ret := C.gtk_toggle_button_new()

	var ret0 ToggleButton

	ret0 = WrapToggleButton(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewToggleButtonWithLabel constructs a class ToggleButton.
func NewToggleButtonWithLabel(label string) ToggleButton {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_toggle_button_new_with_label(arg1)

	var ret0 ToggleButton

	ret0 = WrapToggleButton(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewToggleButtonWithMnemonic constructs a class ToggleButton.
func NewToggleButtonWithMnemonic(label string) ToggleButton {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_toggle_button_new_with_mnemonic(arg1)

	var ret0 ToggleButton

	ret0 = WrapToggleButton(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Active queries a ToggleButton and returns its current state. Returns true
// if the toggle button is pressed in and false if it is raised.
func (toggleButton toggleButton) Active() bool {
	var arg0 *C.GtkToggleButton

	arg0 = (*C.GtkToggleButton)(toggleButton.Native())

	ret := C.gtk_toggle_button_get_active(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// SetActive sets the status of the toggle button. Set to true if you want
// the GtkToggleButton to be “pressed in”, and false to raise it.
//
// If the status of the button changes, this action causes the
// ToggleButton::toggled signal to be emitted.
func (toggleButton toggleButton) SetActive(isActive bool) {
	var arg0 *C.GtkToggleButton
	var arg1 C.gboolean

	arg0 = (*C.GtkToggleButton)(toggleButton.Native())
	arg1 = gextras.Cbool(isActive)

	C.gtk_toggle_button_set_active(arg0, arg1)
}

// SetGroup adds @self to the group of @group. In a group of multiple toggle
// buttons, only one button can be active at a time.
//
// Note that the same effect can be achieved via the Actionable api, by
// using the same action with parameter type and state type 's' for all
// buttons in the group, and giving each button its own target value.
func (toggleButton toggleButton) SetGroup(group ToggleButton) {
	var arg0 *C.GtkToggleButton
	var arg1 *C.GtkToggleButton

	arg0 = (*C.GtkToggleButton)(toggleButton.Native())
	arg1 = (*C.GtkToggleButton)(group.Native())

	C.gtk_toggle_button_set_group(arg0, arg1)
}

// Toggled emits the ToggleButton::toggled signal on the ToggleButton. There
// is no good reason for an application ever to call this function.
func (toggleButton toggleButton) Toggled() {
	var arg0 *C.GtkToggleButton

	arg0 = (*C.GtkToggleButton)(toggleButton.Native())

	C.gtk_toggle_button_toggled(arg0)
}

// Tooltip: basic tooltips can be realized simply by using
// gtk_widget_set_tooltip_text() or gtk_widget_set_tooltip_markup() without any
// explicit tooltip object.
//
// When you need a tooltip with a little more fancy contents, like adding an
// image, or you want the tooltip to have different contents per TreeView row or
// cell, you will have to do a little more work:
//
// - Set the Widget:has-tooltip property to true, this will make GTK monitor the
// widget for motion and related events which are needed to determine when and
// where to show a tooltip.
//
// - Connect to the Widget::query-tooltip signal. This signal will be emitted
// when a tooltip is supposed to be shown. One of the arguments passed to the
// signal handler is a GtkTooltip object. This is the object that we are about
// to display as a tooltip, and can be manipulated in your callback using
// functions like gtk_tooltip_set_icon(). There are functions for setting the
// tooltip’s markup, setting an image from a named icon, or even putting in a
// custom widget.
//
//    Return true from your query-tooltip handler. This causes the tooltip to be
//    show. If you return false, it will not be shown.
type Tooltip interface {
	gextras.Objector

	// SetCustom replaces the widget packed into the tooltip with
	// @custom_widget. @custom_widget does not get destroyed when the tooltip
	// goes away. By default a box with a Image and Label is embedded in the
	// tooltip, which can be configured using gtk_tooltip_set_markup() and
	// gtk_tooltip_set_icon().
	SetCustom(customWidget Widget)
	// SetIcon sets the icon of the tooltip (which is in front of the text) to
	// be @paintable. If @paintable is nil, the image will be hidden.
	SetIcon(paintable gdk.Paintable)
	// SetIconFromGIcon sets the icon of the tooltip (which is in front of the
	// text) to be the icon indicated by @gicon with the size indicated by
	// @size. If @gicon is nil, the image will be hidden.
	SetIconFromGIcon(gicon gio.Icon)
	// SetIconFromIconName sets the icon of the tooltip (which is in front of
	// the text) to be the icon indicated by @icon_name with the size indicated
	// by @size. If @icon_name is nil, the image will be hidden.
	SetIconFromIconName(iconName string)
	// SetMarkup sets the text of the tooltip to be @markup, which is marked up
	// with the [Pango text markup language][PangoMarkupFormat]. If @markup is
	// nil, the label will be hidden.
	SetMarkup(markup string)
	// SetText sets the text of the tooltip to be @text. If @text is nil, the
	// label will be hidden. See also gtk_tooltip_set_markup().
	SetText(text string)
	// SetTipArea sets the area of the widget, where the contents of this
	// tooltip apply, to be @rect (in widget coordinates). This is especially
	// useful for properly setting tooltips on TreeView rows and cells,
	// IconViews, etc.
	//
	// For setting tooltips on TreeView, please refer to the convenience
	// functions for this: gtk_tree_view_set_tooltip_row() and
	// gtk_tree_view_set_tooltip_cell().
	SetTipArea(rect *gdk.Rectangle)
}

type tooltip struct {
	*externglib.Object
}

// WrapTooltip wraps a GObject to the right type. It is
// primarily used internally.
func WrapTooltip(obj *externglib.Object) Tooltip {
	return tooltip{*externglib.Object{obj}}
}

func marshalTooltip(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTooltip(obj), nil
}

// SetCustom replaces the widget packed into the tooltip with
// @custom_widget. @custom_widget does not get destroyed when the tooltip
// goes away. By default a box with a Image and Label is embedded in the
// tooltip, which can be configured using gtk_tooltip_set_markup() and
// gtk_tooltip_set_icon().
func (tooltip tooltip) SetCustom(customWidget Widget) {
	var arg0 *C.GtkTooltip
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkTooltip)(tooltip.Native())
	arg1 = (*C.GtkWidget)(customWidget.Native())

	C.gtk_tooltip_set_custom(arg0, arg1)
}

// SetIcon sets the icon of the tooltip (which is in front of the text) to
// be @paintable. If @paintable is nil, the image will be hidden.
func (tooltip tooltip) SetIcon(paintable gdk.Paintable) {
	var arg0 *C.GtkTooltip
	var arg1 *C.GdkPaintable

	arg0 = (*C.GtkTooltip)(tooltip.Native())

	C.gtk_tooltip_set_icon(arg0, arg1)
}

// SetIconFromGIcon sets the icon of the tooltip (which is in front of the
// text) to be the icon indicated by @gicon with the size indicated by
// @size. If @gicon is nil, the image will be hidden.
func (tooltip tooltip) SetIconFromGIcon(gicon gio.Icon) {
	var arg0 *C.GtkTooltip
	var arg1 *C.GIcon

	arg0 = (*C.GtkTooltip)(tooltip.Native())

	C.gtk_tooltip_set_icon_from_gicon(arg0, arg1)
}

// SetIconFromIconName sets the icon of the tooltip (which is in front of
// the text) to be the icon indicated by @icon_name with the size indicated
// by @size. If @icon_name is nil, the image will be hidden.
func (tooltip tooltip) SetIconFromIconName(iconName string) {
	var arg0 *C.GtkTooltip
	var arg1 *C.char

	arg0 = (*C.GtkTooltip)(tooltip.Native())
	arg1 = (*C.gchar)(C.CString(iconName))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_tooltip_set_icon_from_icon_name(arg0, arg1)
}

// SetMarkup sets the text of the tooltip to be @markup, which is marked up
// with the [Pango text markup language][PangoMarkupFormat]. If @markup is
// nil, the label will be hidden.
func (tooltip tooltip) SetMarkup(markup string) {
	var arg0 *C.GtkTooltip
	var arg1 *C.char

	arg0 = (*C.GtkTooltip)(tooltip.Native())
	arg1 = (*C.gchar)(C.CString(markup))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_tooltip_set_markup(arg0, arg1)
}

// SetText sets the text of the tooltip to be @text. If @text is nil, the
// label will be hidden. See also gtk_tooltip_set_markup().
func (tooltip tooltip) SetText(text string) {
	var arg0 *C.GtkTooltip
	var arg1 *C.char

	arg0 = (*C.GtkTooltip)(tooltip.Native())
	arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_tooltip_set_text(arg0, arg1)
}

// SetTipArea sets the area of the widget, where the contents of this
// tooltip apply, to be @rect (in widget coordinates). This is especially
// useful for properly setting tooltips on TreeView rows and cells,
// IconViews, etc.
//
// For setting tooltips on TreeView, please refer to the convenience
// functions for this: gtk_tree_view_set_tooltip_row() and
// gtk_tree_view_set_tooltip_cell().
func (tooltip tooltip) SetTipArea(rect *gdk.Rectangle) {
	var arg0 *C.GtkTooltip
	var arg1 *C.GdkRectangle

	arg0 = (*C.GtkTooltip)(tooltip.Native())
	arg1 = (*C.GdkRectangle)(rect.Native())

	C.gtk_tooltip_set_tip_area(arg0, arg1)
}

// TreeExpander: gtkTreeExpander is a widget that provides an expander for a
// list.
//
// It is typically placed as a bottommost child into a ListView to allow users
// to expand and collapse children in a list with a TreeListModel. It will
// provide the common UI elements, gestures and keybindings for this purpose.
//
// On top of this, the "listitem.expand", "listitem.collapse" and
// "listitem.toggle-expand" actions are provided to allow adding custom UI for
// managing expanded state.
//
// The TreeListModel must be set to not be passthrough. Then it will provide
// TreeListRow items which can be set via gtk_tree_expander_set_list_row() on
// the expander. The expander will then watch that row item automatically.
// gtk_tree_expander_set_child() sets the widget that displays the actual row
// contents.
//
// CSS nodes
//
//    treeexpander
//    ├── [indent]*
//    ├── [expander]
//    ╰── <child>
//
//
// GtkTreeExpander has zero or one CSS nodes with the name "expander" that
// should display the expander icon. The node will be `:checked` when it is
// expanded. If the node is not expandable, an "indent" node will be displayed
// instead.
//
// For every level of depth, another "indent" node is prepended.
//
//
// Accessibility
//
// GtkTreeExpander uses the GTK_ACCESSIBLE_ROLE_GROUP role. The expander icon is
// represented as a GTK_ACCESSIBLE_ROLE_BUTTON, labelled by the expander's
// child, and toggling it will change the GTK_ACCESSIBLE_STATE_EXPANDED state.
type TreeExpander interface {
	Widget

	// Child gets the child widget displayed by @self.
	Child() Widget
	// Item forwards the item set on the TreeListRow that @self is managing.
	//
	// This call is essentially equivalent to calling:
	//
	//      gtk_tree_list_row_get_item (gtk_tree_expander_get_list_row (@self));
	//
	Item() gextras.Objector
	// ListRow gets the list row managed by @self.
	ListRow() TreeListRow
	// SetChild sets the content widget to display.
	SetChild(child Widget)
	// SetListRow sets the tree list row that this expander should manage.
	SetListRow(listRow TreeListRow)
}

type treeExpander struct {
	widget
}

// WrapTreeExpander wraps a GObject to the right type. It is
// primarily used internally.
func WrapTreeExpander(obj *externglib.Object) TreeExpander {
	return treeExpander{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}
}

func marshalTreeExpander(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTreeExpander(obj), nil
}

// NewTreeExpander constructs a class TreeExpander.
func NewTreeExpander() TreeExpander {

	ret := C.gtk_tree_expander_new()

	var ret0 TreeExpander

	ret0 = WrapTreeExpander(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Child gets the child widget displayed by @self.
func (self treeExpander) Child() Widget {
	var arg0 *C.GtkTreeExpander

	arg0 = (*C.GtkTreeExpander)(self.Native())

	ret := C.gtk_tree_expander_get_child(arg0)

	var ret0 Widget

	ret0 = WrapWidget(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Item forwards the item set on the TreeListRow that @self is managing.
//
// This call is essentially equivalent to calling:
//
//      gtk_tree_list_row_get_item (gtk_tree_expander_get_list_row (@self));
//
func (self treeExpander) Item() gextras.Objector {
	var arg0 *C.GtkTreeExpander

	arg0 = (*C.GtkTreeExpander)(self.Native())

	ret := C.gtk_tree_expander_get_item(arg0)

	var ret0 gextras.Objector

	ret0 = externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))

	return ret0
}

// ListRow gets the list row managed by @self.
func (self treeExpander) ListRow() TreeListRow {
	var arg0 *C.GtkTreeExpander

	arg0 = (*C.GtkTreeExpander)(self.Native())

	ret := C.gtk_tree_expander_get_list_row(arg0)

	var ret0 TreeListRow

	ret0 = WrapTreeListRow(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// SetChild sets the content widget to display.
func (self treeExpander) SetChild(child Widget) {
	var arg0 *C.GtkTreeExpander
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkTreeExpander)(self.Native())
	arg1 = (*C.GtkWidget)(child.Native())

	C.gtk_tree_expander_set_child(arg0, arg1)
}

// SetListRow sets the tree list row that this expander should manage.
func (self treeExpander) SetListRow(listRow TreeListRow) {
	var arg0 *C.GtkTreeExpander
	var arg1 *C.GtkTreeListRow

	arg0 = (*C.GtkTreeExpander)(self.Native())
	arg1 = (*C.GtkTreeListRow)(listRow.Native())

	C.gtk_tree_expander_set_list_row(arg0, arg1)
}

// TreeListModel is a Model implementation that can expand rows by creating new
// child list models on demand.
type TreeListModel interface {
	gextras.Objector

	// Autoexpand gets whether the model is set to automatically expand new rows
	// that get added. This can be either rows added by changes to the
	// underlying models or via gtk_tree_list_row_set_expanded().
	Autoexpand() bool
	// ChildRow gets the row item corresponding to the child at index @position
	// for @self's root model.
	//
	// If @position is greater than the number of children in the root model,
	// nil is returned.
	//
	// Do not confuse this function with gtk_tree_list_model_get_row().
	ChildRow(position uint) TreeListRow
	// Model gets the root model that @self was created with.
	Model() gio.ListModel
	// Passthrough: if this function returns false, the Model functions for
	// @self return custom TreeListRow objects. You need to call
	// gtk_tree_list_row_get_item() on these objects to get the original item.
	//
	// If true, the values of the child models are passed through in their
	// original state. You then need to call gtk_tree_list_model_get_row() to
	// get the custom TreeListRows.
	Passthrough() bool
	// Row gets the row object for the given row. If @position is greater than
	// the number of items in @self, nil is returned.
	//
	// The row object can be used to expand and collapse rows as well as to
	// inspect its position in the tree. See its documentation for details.
	//
	// This row object is persistent and will refer to the current item as long
	// as the row is present in @self, independent of other rows being added or
	// removed.
	//
	// If @self is set to not be passthrough, this function is equivalent to
	// calling g_list_model_get_item().
	//
	// Do not confuse this function with gtk_tree_list_model_get_child_row().
	Row(position uint) TreeListRow
	// SetAutoexpand: if set to true, the model will recursively expand all rows
	// that get added to the model. This can be either rows added by changes to
	// the underlying models or via gtk_tree_list_row_set_expanded().
	SetAutoexpand(autoexpand bool)
}

type treeListModel struct {
	*externglib.Object
}

// WrapTreeListModel wraps a GObject to the right type. It is
// primarily used internally.
func WrapTreeListModel(obj *externglib.Object) TreeListModel {
	return treeListModel{*externglib.Object{obj}}
}

func marshalTreeListModel(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTreeListModel(obj), nil
}

// NewTreeListModel constructs a class TreeListModel.
func NewTreeListModel(root gio.ListModel, passthrough bool, autoexpand bool, createFunc TreeListModelCreateModelFunc) TreeListModel {
	var arg1 *C.GListModel
	var arg2 C.gboolean
	var arg3 C.gboolean
	var arg4 C.GtkTreeListModelCreateModelFunc
	arg5 := C.gpointer(box.Assign(userData))

	arg2 = gextras.Cbool(passthrough)
	arg3 = gextras.Cbool(autoexpand)
	arg4 = (*[0]byte)(C.gotk4_TreeListModelCreateModelFunc)

	ret := C.gtk_tree_list_model_new(arg1, arg2, arg3, arg4, (*[0]byte)(C.callbackDelete))

	var ret0 TreeListModel

	ret0 = WrapTreeListModel(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Autoexpand gets whether the model is set to automatically expand new rows
// that get added. This can be either rows added by changes to the
// underlying models or via gtk_tree_list_row_set_expanded().
func (self treeListModel) Autoexpand() bool {
	var arg0 *C.GtkTreeListModel

	arg0 = (*C.GtkTreeListModel)(self.Native())

	ret := C.gtk_tree_list_model_get_autoexpand(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// ChildRow gets the row item corresponding to the child at index @position
// for @self's root model.
//
// If @position is greater than the number of children in the root model,
// nil is returned.
//
// Do not confuse this function with gtk_tree_list_model_get_row().
func (self treeListModel) ChildRow(position uint) TreeListRow {
	var arg0 *C.GtkTreeListModel
	var arg1 C.guint

	arg0 = (*C.GtkTreeListModel)(self.Native())
	arg1 = C.guint(position)

	ret := C.gtk_tree_list_model_get_child_row(arg0, arg1)

	var ret0 TreeListRow

	ret0 = WrapTreeListRow(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Model gets the root model that @self was created with.
func (self treeListModel) Model() gio.ListModel {
	var arg0 *C.GtkTreeListModel

	arg0 = (*C.GtkTreeListModel)(self.Native())

	ret := C.gtk_tree_list_model_get_model(arg0)

	var ret0 gio.ListModel

	return ret0
}

// Passthrough: if this function returns false, the Model functions for
// @self return custom TreeListRow objects. You need to call
// gtk_tree_list_row_get_item() on these objects to get the original item.
//
// If true, the values of the child models are passed through in their
// original state. You then need to call gtk_tree_list_model_get_row() to
// get the custom TreeListRows.
func (self treeListModel) Passthrough() bool {
	var arg0 *C.GtkTreeListModel

	arg0 = (*C.GtkTreeListModel)(self.Native())

	ret := C.gtk_tree_list_model_get_passthrough(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Row gets the row object for the given row. If @position is greater than
// the number of items in @self, nil is returned.
//
// The row object can be used to expand and collapse rows as well as to
// inspect its position in the tree. See its documentation for details.
//
// This row object is persistent and will refer to the current item as long
// as the row is present in @self, independent of other rows being added or
// removed.
//
// If @self is set to not be passthrough, this function is equivalent to
// calling g_list_model_get_item().
//
// Do not confuse this function with gtk_tree_list_model_get_child_row().
func (self treeListModel) Row(position uint) TreeListRow {
	var arg0 *C.GtkTreeListModel
	var arg1 C.guint

	arg0 = (*C.GtkTreeListModel)(self.Native())
	arg1 = C.guint(position)

	ret := C.gtk_tree_list_model_get_row(arg0, arg1)

	var ret0 TreeListRow

	ret0 = WrapTreeListRow(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// SetAutoexpand: if set to true, the model will recursively expand all rows
// that get added to the model. This can be either rows added by changes to
// the underlying models or via gtk_tree_list_row_set_expanded().
func (self treeListModel) SetAutoexpand(autoexpand bool) {
	var arg0 *C.GtkTreeListModel
	var arg1 C.gboolean

	arg0 = (*C.GtkTreeListModel)(self.Native())
	arg1 = gextras.Cbool(autoexpand)

	C.gtk_tree_list_model_set_autoexpand(arg0, arg1)
}

// TreeListRow is the object used by TreeListModel to represent items. It allows
// navigating the model as a tree and modify the state of rows.
//
// TreeListRow instances are created by a TreeListModel only when the
// TreeListModel:passthrough property is not set.
//
// There are various support objects that can make use of TreeListRow objects,
// such as the TreeExpander widget that allows displaying an icon to expand or
// collapse a row or TreeListRowSorter that makes it possible to sort trees
// properly.
type TreeListRow interface {
	gextras.Objector

	// ChildRow: if @self is not expanded or @position is greater than the
	// number of children, nil is returned.
	ChildRow(position uint) TreeListRow
	// Children: if the row is expanded, gets the model holding the children of
	// @self.
	//
	// This model is the model created by the TreeListModelCreateModelFunc and
	// contains the original items, no matter what value
	// TreeListModel:passthrough is set to.
	Children() gio.ListModel
	// Depth gets the depth of this row. Rows that correspond to items in the
	// root model have a depth of zero, rows corresponding to items of models of
	// direct children of the root model have a depth of 1 and so on.
	//
	// The depth of a row never changes until the row is destroyed.
	Depth() uint
	// Expanded gets if a row is currently expanded.
	Expanded() bool
	// Item gets the item corresponding to this row,
	//
	// The value returned by this function never changes until the row is
	// destroyed.
	Item() gextras.Objector
	// Parent gets the row representing the parent for @self. That is the row
	// that would need to be collapsed to make this row disappear.
	//
	// If @self is a row corresponding to the root model, nil is returned.
	//
	// The value returned by this function never changes until the row is
	// destroyed.
	Parent() TreeListRow
	// Position returns the position in the TreeListModel that @self occupies at
	// the moment.
	Position() uint
	// IsExpandable checks if a row can be expanded. This does not mean that the
	// row is actually expanded, this can be checked with
	// gtk_tree_list_row_get_expanded()
	//
	// If a row is expandable never changes until the row is destroyed.
	IsExpandable() bool
	// SetExpanded expands or collapses a row.
	//
	// If a row is expanded, the model of calling the
	// TreeListModelCreateModelFunc for the row's item will be inserted after
	// this row. If a row is collapsed, those items will be removed from the
	// model.
	//
	// If the row is not expandable, this function does nothing.
	SetExpanded(expanded bool)
}

type treeListRow struct {
	*externglib.Object
}

// WrapTreeListRow wraps a GObject to the right type. It is
// primarily used internally.
func WrapTreeListRow(obj *externglib.Object) TreeListRow {
	return treeListRow{*externglib.Object{obj}}
}

func marshalTreeListRow(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTreeListRow(obj), nil
}

// ChildRow: if @self is not expanded or @position is greater than the
// number of children, nil is returned.
func (self treeListRow) ChildRow(position uint) TreeListRow {
	var arg0 *C.GtkTreeListRow
	var arg1 C.guint

	arg0 = (*C.GtkTreeListRow)(self.Native())
	arg1 = C.guint(position)

	ret := C.gtk_tree_list_row_get_child_row(arg0, arg1)

	var ret0 TreeListRow

	ret0 = WrapTreeListRow(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Children: if the row is expanded, gets the model holding the children of
// @self.
//
// This model is the model created by the TreeListModelCreateModelFunc and
// contains the original items, no matter what value
// TreeListModel:passthrough is set to.
func (self treeListRow) Children() gio.ListModel {
	var arg0 *C.GtkTreeListRow

	arg0 = (*C.GtkTreeListRow)(self.Native())

	ret := C.gtk_tree_list_row_get_children(arg0)

	var ret0 gio.ListModel

	return ret0
}

// Depth gets the depth of this row. Rows that correspond to items in the
// root model have a depth of zero, rows corresponding to items of models of
// direct children of the root model have a depth of 1 and so on.
//
// The depth of a row never changes until the row is destroyed.
func (self treeListRow) Depth() uint {
	var arg0 *C.GtkTreeListRow

	arg0 = (*C.GtkTreeListRow)(self.Native())

	ret := C.gtk_tree_list_row_get_depth(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// Expanded gets if a row is currently expanded.
func (self treeListRow) Expanded() bool {
	var arg0 *C.GtkTreeListRow

	arg0 = (*C.GtkTreeListRow)(self.Native())

	ret := C.gtk_tree_list_row_get_expanded(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Item gets the item corresponding to this row,
//
// The value returned by this function never changes until the row is
// destroyed.
func (self treeListRow) Item() gextras.Objector {
	var arg0 *C.GtkTreeListRow

	arg0 = (*C.GtkTreeListRow)(self.Native())

	ret := C.gtk_tree_list_row_get_item(arg0)

	var ret0 gextras.Objector

	ret0 = externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))

	return ret0
}

// Parent gets the row representing the parent for @self. That is the row
// that would need to be collapsed to make this row disappear.
//
// If @self is a row corresponding to the root model, nil is returned.
//
// The value returned by this function never changes until the row is
// destroyed.
func (self treeListRow) Parent() TreeListRow {
	var arg0 *C.GtkTreeListRow

	arg0 = (*C.GtkTreeListRow)(self.Native())

	ret := C.gtk_tree_list_row_get_parent(arg0)

	var ret0 TreeListRow

	ret0 = WrapTreeListRow(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Position returns the position in the TreeListModel that @self occupies at
// the moment.
func (self treeListRow) Position() uint {
	var arg0 *C.GtkTreeListRow

	arg0 = (*C.GtkTreeListRow)(self.Native())

	ret := C.gtk_tree_list_row_get_position(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// IsExpandable checks if a row can be expanded. This does not mean that the
// row is actually expanded, this can be checked with
// gtk_tree_list_row_get_expanded()
//
// If a row is expandable never changes until the row is destroyed.
func (self treeListRow) IsExpandable() bool {
	var arg0 *C.GtkTreeListRow

	arg0 = (*C.GtkTreeListRow)(self.Native())

	ret := C.gtk_tree_list_row_is_expandable(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// SetExpanded expands or collapses a row.
//
// If a row is expanded, the model of calling the
// TreeListModelCreateModelFunc for the row's item will be inserted after
// this row. If a row is collapsed, those items will be removed from the
// model.
//
// If the row is not expandable, this function does nothing.
func (self treeListRow) SetExpanded(expanded bool) {
	var arg0 *C.GtkTreeListRow
	var arg1 C.gboolean

	arg0 = (*C.GtkTreeListRow)(self.Native())
	arg1 = gextras.Cbool(expanded)

	C.gtk_tree_list_row_set_expanded(arg0, arg1)
}

// TreeListRowSorter is a special-purpose sorter that will apply a given sorter
// to the levels in a tree, while respecting the tree structure.
//
// Here is an example for setting up a column view with a tree model and a
// GtkTreeListSorter:
//
//
//    column_sorter = gtk_column_view_get_sorter (view);
//    sorter = gtk_tree_list_row_sorter_new (g_object_ref (column_sorter));
//    sort_model = gtk_sort_list_model_new (tree_model, sorter);
//    selection = gtk_single_selection_new (sort_model);
//    gtk_column_view_set_model (view, G_LIST_MODEL (selection));
//
type TreeListRowSorter interface {
	Sorter

	// Sorter returns the sorter used by @self.
	Sorter() Sorter
	// SetSorter sets the sorter to use for items with the same parent.
	//
	// This sorter will be passed the TreeListRow:item of the tree list rows
	// passed to @self.
	SetSorter(sorter Sorter)
}

type treeListRowSorter struct {
	sorter
}

// WrapTreeListRowSorter wraps a GObject to the right type. It is
// primarily used internally.
func WrapTreeListRowSorter(obj *externglib.Object) TreeListRowSorter {
	return treeListRowSorter{sorter{*externglib.Object{obj}}}
}

func marshalTreeListRowSorter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTreeListRowSorter(obj), nil
}

// NewTreeListRowSorter constructs a class TreeListRowSorter.
func NewTreeListRowSorter(sorter Sorter) TreeListRowSorter {
	var arg1 *C.GtkSorter

	arg1 = (*C.GtkSorter)(sorter.Native())

	ret := C.gtk_tree_list_row_sorter_new(arg1)

	var ret0 TreeListRowSorter

	ret0 = WrapTreeListRowSorter(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Sorter returns the sorter used by @self.
func (self treeListRowSorter) Sorter() Sorter {
	var arg0 *C.GtkTreeListRowSorter

	arg0 = (*C.GtkTreeListRowSorter)(self.Native())

	ret := C.gtk_tree_list_row_sorter_get_sorter(arg0)

	var ret0 Sorter

	ret0 = WrapSorter(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// SetSorter sets the sorter to use for items with the same parent.
//
// This sorter will be passed the TreeListRow:item of the tree list rows
// passed to @self.
func (self treeListRowSorter) SetSorter(sorter Sorter) {
	var arg0 *C.GtkTreeListRowSorter
	var arg1 *C.GtkSorter

	arg0 = (*C.GtkTreeListRowSorter)(self.Native())
	arg1 = (*C.GtkSorter)(sorter.Native())

	C.gtk_tree_list_row_sorter_set_sorter(arg0, arg1)
}

// TreeModelFilter: a TreeModelFilter is a tree model which wraps another tree
// model, and can do the following things:
//
// - Filter specific rows, based on data from a “visible column”, a column
// storing booleans indicating whether the row should be filtered or not, or
// based on the return value of a “visible function”, which gets a model, iter
// and user_data and returns a boolean indicating whether the row should be
// filtered or not.
//
// - Modify the “appearance” of the model, using a modify function. This is
// extremely powerful and allows for just changing some values and also for
// creating a completely different model based on the given child model.
//
// - Set a different root node, also known as a “virtual root”. You can pass in
// a TreePath indicating the root node for the filter at construction time.
//
// The basic API is similar to TreeModelSort. For an example on its usage, see
// the section on TreeModelSort.
//
// When using TreeModelFilter, it is important to realize that TreeModelFilter
// maintains an internal cache of all nodes which are visible in its clients.
// The cache is likely to be a subtree of the tree exposed by the child model.
// TreeModelFilter will not cache the entire child model when unnecessary to not
// compromise the caching mechanism that is exposed by the reference counting
// scheme. If the child model implements reference counting, unnecessary signals
// may not be emitted because of reference counting rule 3, see the TreeModel
// documentation. (Note that e.g. TreeStore does not implement reference
// counting and will always emit all signals, even when the receiving node is
// not visible).
//
// Because of this, limitations for possible visible functions do apply. In
// general, visible functions should only use data or properties from the node
// for which the visibility state must be determined, its siblings or its
// parents. Usually, having a dependency on the state of any child node is not
// possible, unless references are taken on these explicitly. When no such
// reference exists, no signals may be received for these child nodes (see
// reference counting rule number 3 in the TreeModel section).
//
// Determining the visibility state of a given node based on the state of its
// child nodes is a frequently occurring use case. Therefore, TreeModelFilter
// explicitly supports this. For example, when a node does not have any
// children, you might not want the node to be visible. As soon as the first row
// is added to the node’s child level (or the last row removed), the node’s
// visibility should be updated.
//
// This introduces a dependency from the node on its child nodes. In order to
// accommodate this, TreeModelFilter must make sure the necessary signals are
// received from the child model. This is achieved by building, for all nodes
// which are exposed as visible nodes to TreeModelFilter's clients, the child
// level (if any) and take a reference on the first node in this level.
// Furthermore, for every row-inserted, row-changed or row-deleted signal (also
// these which were not handled because the node was not cached),
// TreeModelFilter will check if the visibility state of any parent node has
// changed.
//
// Beware, however, that this explicit support is limited to these two cases.
// For example, if you want a node to be visible only if two nodes in a child’s
// child level (2 levels deeper) are visible, you are on your own. In this case,
// either rely on TreeStore to emit all signals because it does not implement
// reference counting, or for models that do implement reference counting,
// obtain references on these child levels yourself.
type TreeModelFilter interface {
	gextras.Objector

	// ClearCache: this function should almost never be called. It clears the
	// @filter of any cached iterators that haven’t been reffed with
	// gtk_tree_model_ref_node(). This might be useful if the child model being
	// filtered is static (and doesn’t change often) and there has been a lot of
	// unreffed access to nodes. As a side effect of this function, all unreffed
	// iters will be invalid.
	ClearCache()
	// ConvertChildIterToIter sets @filter_iter to point to the row in @filter
	// that corresponds to the row pointed at by @child_iter. If @filter_iter
	// was not set, false is returned.
	ConvertChildIterToIter(childIter *TreeIter) (filterIter TreeIter, ok bool)
	// ConvertChildPathToPath converts @child_path to a path relative to
	// @filter. That is, @child_path points to a path in the child model. The
	// rerturned path will point to the same row in the filtered model. If
	// @child_path isn’t a valid path on the child model or points to a row
	// which is not visible in @filter, then nil is returned.
	ConvertChildPathToPath(childPath *TreePath) *TreePath
	// ConvertIterToChildIter sets @child_iter to point to the row pointed to by
	// @filter_iter.
	ConvertIterToChildIter(filterIter *TreeIter) TreeIter
	// ConvertPathToChildPath converts @filter_path to a path on the child model
	// of @filter. That is, @filter_path points to a location in @filter. The
	// returned path will point to the same location in the model not being
	// filtered. If @filter_path does not point to a location in the child
	// model, nil is returned.
	ConvertPathToChildPath(filterPath *TreePath) *TreePath
	// Model returns a pointer to the child model of @filter.
	Model() TreeModel
	// Refilter emits ::row_changed for each row in the child model, which
	// causes the filter to re-evaluate whether a row is visible or not.
	Refilter()
	// SetModifyFunc: with the @n_columns and @types parameters, you give an
	// array of column types for this model (which will be exposed to the parent
	// model/view). The @func, @data and @destroy parameters are for specifying
	// the modify function. The modify function will get called for each data
	// access, the goal of the modify function is to return the data which
	// should be displayed at the location specified using the parameters of the
	// modify function.
	//
	// Note that gtk_tree_model_filter_set_modify_func() can only be called once
	// for a given filter model.
	SetModifyFunc(nColumns int, types []externglib.Type, _func TreeModelFilterModifyFunc)
	// SetVisibleColumn sets @column of the child_model to be the column where
	// @filter should look for visibility information. @columns should be a
	// column of type G_TYPE_BOOLEAN, where true means that a row is visible,
	// and false if not.
	//
	// Note that gtk_tree_model_filter_set_visible_func() or
	// gtk_tree_model_filter_set_visible_column() can only be called once for a
	// given filter model.
	SetVisibleColumn(column int)
	// SetVisibleFunc sets the visible function used when filtering the @filter
	// to be @func. The function should return true if the given row should be
	// visible and false otherwise.
	//
	// If the condition calculated by the function changes over time (e.g.
	// because it depends on some global parameters), you must call
	// gtk_tree_model_filter_refilter() to keep the visibility information of
	// the model up-to-date.
	//
	// Note that @func is called whenever a row is inserted, when it may still
	// be empty. The visible function should therefore take special care of
	// empty rows, like in the example below.
	//
	//    static gboolean
	//    visible_func (GtkTreeModel *model,
	//                  GtkTreeIter  *iter,
	//                  gpointer      data)
	//    {
	//      // Visible if row is non-empty and first column is “HI”
	//      char *str;
	//      gboolean visible = FALSE;
	//
	//      gtk_tree_model_get (model, iter, 0, &str, -1);
	//      if (str && strcmp (str, "HI") == 0)
	//        visible = TRUE;
	//      g_free (str);
	//
	//      return visible;
	//    }
	//
	//
	// Note that gtk_tree_model_filter_set_visible_func() or
	// gtk_tree_model_filter_set_visible_column() can only be called once for a
	// given filter model.
	SetVisibleFunc(_func TreeModelFilterVisibleFunc)
}

type treeModelFilter struct {
	*externglib.Object
}

// WrapTreeModelFilter wraps a GObject to the right type. It is
// primarily used internally.
func WrapTreeModelFilter(obj *externglib.Object) TreeModelFilter {
	return treeModelFilter{*externglib.Object{obj}}
}

func marshalTreeModelFilter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTreeModelFilter(obj), nil
}

// ClearCache: this function should almost never be called. It clears the
// @filter of any cached iterators that haven’t been reffed with
// gtk_tree_model_ref_node(). This might be useful if the child model being
// filtered is static (and doesn’t change often) and there has been a lot of
// unreffed access to nodes. As a side effect of this function, all unreffed
// iters will be invalid.
func (filter treeModelFilter) ClearCache() {
	var arg0 *C.GtkTreeModelFilter

	arg0 = (*C.GtkTreeModelFilter)(filter.Native())

	C.gtk_tree_model_filter_clear_cache(arg0)
}

// ConvertChildIterToIter sets @filter_iter to point to the row in @filter
// that corresponds to the row pointed at by @child_iter. If @filter_iter
// was not set, false is returned.
func (filter treeModelFilter) ConvertChildIterToIter(childIter *TreeIter) (filterIter TreeIter, ok bool) {
	var arg0 *C.GtkTreeModelFilter
	var arg1 *C.GtkTreeIter // out
	var arg2 *C.GtkTreeIter

	arg0 = (*C.GtkTreeModelFilter)(filter.Native())
	arg2 = (*C.GtkTreeIter)(childIter.Native())

	ret := C.gtk_tree_model_filter_convert_child_iter_to_iter(arg0, &arg1, arg2)

	var ret0 *TreeIter
	var ret1 bool

	ret0 = WrapTreeIter(arg1)

	ret1 = gextras.Gobool(ret)

	return ret0, ret1
}

// ConvertChildPathToPath converts @child_path to a path relative to
// @filter. That is, @child_path points to a path in the child model. The
// rerturned path will point to the same row in the filtered model. If
// @child_path isn’t a valid path on the child model or points to a row
// which is not visible in @filter, then nil is returned.
func (filter treeModelFilter) ConvertChildPathToPath(childPath *TreePath) *TreePath {
	var arg0 *C.GtkTreeModelFilter
	var arg1 *C.GtkTreePath

	arg0 = (*C.GtkTreeModelFilter)(filter.Native())
	arg1 = (*C.GtkTreePath)(childPath.Native())

	ret := C.gtk_tree_model_filter_convert_child_path_to_path(arg0, arg1)

	var ret0 *TreePath

	ret0 = WrapTreePath(ret)

	return ret0
}

// ConvertIterToChildIter sets @child_iter to point to the row pointed to by
// @filter_iter.
func (filter treeModelFilter) ConvertIterToChildIter(filterIter *TreeIter) TreeIter {
	var arg0 *C.GtkTreeModelFilter
	var arg1 *C.GtkTreeIter // out
	var arg2 *C.GtkTreeIter

	arg0 = (*C.GtkTreeModelFilter)(filter.Native())
	arg2 = (*C.GtkTreeIter)(filterIter.Native())

	ret := C.gtk_tree_model_filter_convert_iter_to_child_iter(arg0, &arg1, arg2)

	var ret0 *TreeIter

	ret0 = WrapTreeIter(arg1)

	return ret0
}

// ConvertPathToChildPath converts @filter_path to a path on the child model
// of @filter. That is, @filter_path points to a location in @filter. The
// returned path will point to the same location in the model not being
// filtered. If @filter_path does not point to a location in the child
// model, nil is returned.
func (filter treeModelFilter) ConvertPathToChildPath(filterPath *TreePath) *TreePath {
	var arg0 *C.GtkTreeModelFilter
	var arg1 *C.GtkTreePath

	arg0 = (*C.GtkTreeModelFilter)(filter.Native())
	arg1 = (*C.GtkTreePath)(filterPath.Native())

	ret := C.gtk_tree_model_filter_convert_path_to_child_path(arg0, arg1)

	var ret0 *TreePath

	ret0 = WrapTreePath(ret)

	return ret0
}

// Model returns a pointer to the child model of @filter.
func (filter treeModelFilter) Model() TreeModel {
	var arg0 *C.GtkTreeModelFilter

	arg0 = (*C.GtkTreeModelFilter)(filter.Native())

	ret := C.gtk_tree_model_filter_get_model(arg0)

	var ret0 TreeModel

	return ret0
}

// Refilter emits ::row_changed for each row in the child model, which
// causes the filter to re-evaluate whether a row is visible or not.
func (filter treeModelFilter) Refilter() {
	var arg0 *C.GtkTreeModelFilter

	arg0 = (*C.GtkTreeModelFilter)(filter.Native())

	C.gtk_tree_model_filter_refilter(arg0)
}

// SetModifyFunc: with the @n_columns and @types parameters, you give an
// array of column types for this model (which will be exposed to the parent
// model/view). The @func, @data and @destroy parameters are for specifying
// the modify function. The modify function will get called for each data
// access, the goal of the modify function is to return the data which
// should be displayed at the location specified using the parameters of the
// modify function.
//
// Note that gtk_tree_model_filter_set_modify_func() can only be called once
// for a given filter model.
func (filter treeModelFilter) SetModifyFunc(nColumns int, types []externglib.Type, _func TreeModelFilterModifyFunc) {
	var arg0 *C.GtkTreeModelFilter
	var arg1 C.int
	var arg2 *C.GType
	var arg3 C.GtkTreeModelFilterModifyFunc
	arg4 := C.gpointer(box.Assign(data))

	arg0 = (*C.GtkTreeModelFilter)(filter.Native())
	{
		var dst []C.GType
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(C.malloc(C.sizeof_GType * len(types))))
		sliceHeader.Len = len(types)
		sliceHeader.Cap = len(types)
		defer C.free(unsafe.Pointer(sliceHeader.Data))

		for i := 0; i < len(types); i++ {
			src := types[i]
			dst[i] = C.GType(src)
		}

		arg2 = (*C.GType)(unsafe.Pointer(sliceHeader.Data))
		arg1 = len(types)
	}
	arg3 = (*[0]byte)(C.gotk4_TreeModelFilterModifyFunc)

	C.gtk_tree_model_filter_set_modify_func(arg0, arg1, arg2, arg3, (*[0]byte)(C.callbackDelete))
}

// SetVisibleColumn sets @column of the child_model to be the column where
// @filter should look for visibility information. @columns should be a
// column of type G_TYPE_BOOLEAN, where true means that a row is visible,
// and false if not.
//
// Note that gtk_tree_model_filter_set_visible_func() or
// gtk_tree_model_filter_set_visible_column() can only be called once for a
// given filter model.
func (filter treeModelFilter) SetVisibleColumn(column int) {
	var arg0 *C.GtkTreeModelFilter
	var arg1 C.int

	arg0 = (*C.GtkTreeModelFilter)(filter.Native())
	arg1 = C.int(column)

	C.gtk_tree_model_filter_set_visible_column(arg0, arg1)
}

// SetVisibleFunc sets the visible function used when filtering the @filter
// to be @func. The function should return true if the given row should be
// visible and false otherwise.
//
// If the condition calculated by the function changes over time (e.g.
// because it depends on some global parameters), you must call
// gtk_tree_model_filter_refilter() to keep the visibility information of
// the model up-to-date.
//
// Note that @func is called whenever a row is inserted, when it may still
// be empty. The visible function should therefore take special care of
// empty rows, like in the example below.
//
//    static gboolean
//    visible_func (GtkTreeModel *model,
//                  GtkTreeIter  *iter,
//                  gpointer      data)
//    {
//      // Visible if row is non-empty and first column is “HI”
//      char *str;
//      gboolean visible = FALSE;
//
//      gtk_tree_model_get (model, iter, 0, &str, -1);
//      if (str && strcmp (str, "HI") == 0)
//        visible = TRUE;
//      g_free (str);
//
//      return visible;
//    }
//
//
// Note that gtk_tree_model_filter_set_visible_func() or
// gtk_tree_model_filter_set_visible_column() can only be called once for a
// given filter model.
func (filter treeModelFilter) SetVisibleFunc(_func TreeModelFilterVisibleFunc) {
	var arg0 *C.GtkTreeModelFilter
	var arg1 C.GtkTreeModelFilterVisibleFunc
	arg2 := C.gpointer(box.Assign(data))

	arg0 = (*C.GtkTreeModelFilter)(filter.Native())
	arg1 = (*[0]byte)(C.gotk4_TreeModelFilterVisibleFunc)

	C.gtk_tree_model_filter_set_visible_func(arg0, arg1, (*[0]byte)(C.callbackDelete))
}

// TreeModelSort: the TreeModelSort is a model which implements the TreeSortable
// interface. It does not hold any data itself, but rather is created with a
// child model and proxies its data. It has identical column types to this child
// model, and the changes in the child are propagated. The primary purpose of
// this model is to provide a way to sort a different model without modifying
// it. Note that the sort function used by TreeModelSort is not guaranteed to be
// stable.
//
// The use of this is best demonstrated through an example. In the following
// sample code we create two TreeView widgets each with a view of the same data.
// As the model is wrapped here by a TreeModelSort, the two TreeViews can each
// sort their view of the data without affecting the other. By contrast, if we
// simply put the same model in each widget, then sorting the first would sort
// the second.
//
// Using a TreeModelSort
//
//    void
//    selection_changed (GtkTreeSelection *selection, gpointer data)
//    {
//      GtkTreeModel *sort_model = NULL;
//      GtkTreeModel *child_model;
//      GtkTreeIter sort_iter;
//      GtkTreeIter child_iter;
//      char *some_data = NULL;
//      char *modified_data;
//
//      // Get the current selected row and the model.
//      if (! gtk_tree_selection_get_selected (selection,
//                                             &sort_model,
//                                             &sort_iter))
//        return;
//
//      // Look up the current value on the selected row and get
//      // a new value to change it to.
//      gtk_tree_model_get (GTK_TREE_MODEL (sort_model), &sort_iter,
//                          COLUMN_1, &some_data,
//                          -1);
//
//      modified_data = change_the_data (some_data);
//      g_free (some_data);
//
//      // Get an iterator on the child model, instead of the sort model.
//      gtk_tree_model_sort_convert_iter_to_child_iter (GTK_TREE_MODEL_SORT (sort_model),
//                                                      &child_iter,
//                                                      &sort_iter);
//
//      // Get the child model and change the value of the row. In this
//      // example, the child model is a GtkListStore. It could be any other
//      // type of model, though.
//      child_model = gtk_tree_model_sort_get_model (GTK_TREE_MODEL_SORT (sort_model));
//      gtk_list_store_set (GTK_LIST_STORE (child_model), &child_iter,
//                          COLUMN_1, &modified_data,
//                          -1);
//      g_free (modified_data);
//    }
//
type TreeModelSort interface {
	gextras.Objector

	// ClearCache: this function should almost never be called. It clears the
	// @tree_model_sort of any cached iterators that haven’t been reffed with
	// gtk_tree_model_ref_node(). This might be useful if the child model being
	// sorted is static (and doesn’t change often) and there has been a lot of
	// unreffed access to nodes. As a side effect of this function, all unreffed
	// iters will be invalid.
	ClearCache()
	// ConvertChildIterToIter sets @sort_iter to point to the row in
	// @tree_model_sort that corresponds to the row pointed at by @child_iter.
	// If @sort_iter was not set, false is returned. Note: a boolean is only
	// returned since 2.14.
	ConvertChildIterToIter(childIter *TreeIter) (sortIter TreeIter, ok bool)
	// ConvertChildPathToPath converts @child_path to a path relative to
	// @tree_model_sort. That is, @child_path points to a path in the child
	// model. The returned path will point to the same row in the sorted model.
	// If @child_path isn’t a valid path on the child model, then nil is
	// returned.
	ConvertChildPathToPath(childPath *TreePath) *TreePath
	// ConvertIterToChildIter sets @child_iter to point to the row pointed to by
	// @sorted_iter.
	ConvertIterToChildIter(sortedIter *TreeIter) TreeIter
	// ConvertPathToChildPath converts @sorted_path to a path on the child model
	// of @tree_model_sort. That is, @sorted_path points to a location in
	// @tree_model_sort. The returned path will point to the same location in
	// the model not being sorted. If @sorted_path does not point to a location
	// in the child model, nil is returned.
	ConvertPathToChildPath(sortedPath *TreePath) *TreePath
	// Model returns the model the TreeModelSort is sorting.
	Model() TreeModel
	// IterIsValid: > This function is slow. Only use it for debugging and/or
	// testing > purposes.
	//
	// Checks if the given iter is a valid iter for this TreeModelSort.
	IterIsValid(iter *TreeIter) bool
	// ResetDefaultSortFunc: this resets the default sort function to be in the
	// “unsorted” state. That is, it is in the same order as the child model. It
	// will re-sort the model to be in the same order as the child model only if
	// the TreeModelSort is in “unsorted” state.
	ResetDefaultSortFunc()
}

type treeModelSort struct {
	*externglib.Object
}

// WrapTreeModelSort wraps a GObject to the right type. It is
// primarily used internally.
func WrapTreeModelSort(obj *externglib.Object) TreeModelSort {
	return treeModelSort{*externglib.Object{obj}}
}

func marshalTreeModelSort(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTreeModelSort(obj), nil
}

// NewTreeModelSortWithModel constructs a class TreeModelSort.
func NewTreeModelSortWithModel(childModel TreeModel) TreeModelSort {
	var arg1 *C.GtkTreeModel

	ret := C.gtk_tree_model_sort_new_with_model(arg1)

	var ret0 TreeModelSort

	ret0 = WrapTreeModelSort(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// ClearCache: this function should almost never be called. It clears the
// @tree_model_sort of any cached iterators that haven’t been reffed with
// gtk_tree_model_ref_node(). This might be useful if the child model being
// sorted is static (and doesn’t change often) and there has been a lot of
// unreffed access to nodes. As a side effect of this function, all unreffed
// iters will be invalid.
func (treeModelSort treeModelSort) ClearCache() {
	var arg0 *C.GtkTreeModelSort

	arg0 = (*C.GtkTreeModelSort)(treeModelSort.Native())

	C.gtk_tree_model_sort_clear_cache(arg0)
}

// ConvertChildIterToIter sets @sort_iter to point to the row in
// @tree_model_sort that corresponds to the row pointed at by @child_iter.
// If @sort_iter was not set, false is returned. Note: a boolean is only
// returned since 2.14.
func (treeModelSort treeModelSort) ConvertChildIterToIter(childIter *TreeIter) (sortIter TreeIter, ok bool) {
	var arg0 *C.GtkTreeModelSort
	var arg1 *C.GtkTreeIter // out
	var arg2 *C.GtkTreeIter

	arg0 = (*C.GtkTreeModelSort)(treeModelSort.Native())
	arg2 = (*C.GtkTreeIter)(childIter.Native())

	ret := C.gtk_tree_model_sort_convert_child_iter_to_iter(arg0, &arg1, arg2)

	var ret0 *TreeIter
	var ret1 bool

	ret0 = WrapTreeIter(arg1)

	ret1 = gextras.Gobool(ret)

	return ret0, ret1
}

// ConvertChildPathToPath converts @child_path to a path relative to
// @tree_model_sort. That is, @child_path points to a path in the child
// model. The returned path will point to the same row in the sorted model.
// If @child_path isn’t a valid path on the child model, then nil is
// returned.
func (treeModelSort treeModelSort) ConvertChildPathToPath(childPath *TreePath) *TreePath {
	var arg0 *C.GtkTreeModelSort
	var arg1 *C.GtkTreePath

	arg0 = (*C.GtkTreeModelSort)(treeModelSort.Native())
	arg1 = (*C.GtkTreePath)(childPath.Native())

	ret := C.gtk_tree_model_sort_convert_child_path_to_path(arg0, arg1)

	var ret0 *TreePath

	ret0 = WrapTreePath(ret)

	return ret0
}

// ConvertIterToChildIter sets @child_iter to point to the row pointed to by
// @sorted_iter.
func (treeModelSort treeModelSort) ConvertIterToChildIter(sortedIter *TreeIter) TreeIter {
	var arg0 *C.GtkTreeModelSort
	var arg1 *C.GtkTreeIter // out
	var arg2 *C.GtkTreeIter

	arg0 = (*C.GtkTreeModelSort)(treeModelSort.Native())
	arg2 = (*C.GtkTreeIter)(sortedIter.Native())

	ret := C.gtk_tree_model_sort_convert_iter_to_child_iter(arg0, &arg1, arg2)

	var ret0 *TreeIter

	ret0 = WrapTreeIter(arg1)

	return ret0
}

// ConvertPathToChildPath converts @sorted_path to a path on the child model
// of @tree_model_sort. That is, @sorted_path points to a location in
// @tree_model_sort. The returned path will point to the same location in
// the model not being sorted. If @sorted_path does not point to a location
// in the child model, nil is returned.
func (treeModelSort treeModelSort) ConvertPathToChildPath(sortedPath *TreePath) *TreePath {
	var arg0 *C.GtkTreeModelSort
	var arg1 *C.GtkTreePath

	arg0 = (*C.GtkTreeModelSort)(treeModelSort.Native())
	arg1 = (*C.GtkTreePath)(sortedPath.Native())

	ret := C.gtk_tree_model_sort_convert_path_to_child_path(arg0, arg1)

	var ret0 *TreePath

	ret0 = WrapTreePath(ret)

	return ret0
}

// Model returns the model the TreeModelSort is sorting.
func (treeModel treeModelSort) Model() TreeModel {
	var arg0 *C.GtkTreeModelSort

	arg0 = (*C.GtkTreeModelSort)(treeModel.Native())

	ret := C.gtk_tree_model_sort_get_model(arg0)

	var ret0 TreeModel

	return ret0
}

// IterIsValid: > This function is slow. Only use it for debugging and/or
// testing > purposes.
//
// Checks if the given iter is a valid iter for this TreeModelSort.
func (treeModelSort treeModelSort) IterIsValid(iter *TreeIter) bool {
	var arg0 *C.GtkTreeModelSort
	var arg1 *C.GtkTreeIter

	arg0 = (*C.GtkTreeModelSort)(treeModelSort.Native())
	arg1 = (*C.GtkTreeIter)(iter.Native())

	ret := C.gtk_tree_model_sort_iter_is_valid(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// ResetDefaultSortFunc: this resets the default sort function to be in the
// “unsorted” state. That is, it is in the same order as the child model. It
// will re-sort the model to be in the same order as the child model only if
// the TreeModelSort is in “unsorted” state.
func (treeModelSort treeModelSort) ResetDefaultSortFunc() {
	var arg0 *C.GtkTreeModelSort

	arg0 = (*C.GtkTreeModelSort)(treeModelSort.Native())

	C.gtk_tree_model_sort_reset_default_sort_func(arg0)
}

// TreeSelection: the TreeSelection object is a helper object to manage the
// selection for a TreeView widget. The TreeSelection object is automatically
// created when a new TreeView widget is created, and cannot exist independently
// of this widget. The primary reason the TreeSelection objects exists is for
// cleanliness of code and API. That is, there is no conceptual reason all these
// functions could not be methods on the TreeView widget instead of a separate
// function.
//
// The TreeSelection object is gotten from a TreeView by calling
// gtk_tree_view_get_selection(). It can be manipulated to check the selection
// status of the tree, as well as select and deselect individual rows. Selection
// is done completely view side. As a result, multiple views of the same model
// can have completely different selections. Additionally, you cannot change the
// selection of a row on the model that is not currently displayed by the view
// without expanding its parents first.
//
// One of the important things to remember when monitoring the selection of a
// view is that the TreeSelection::changed signal is mostly a hint. That is, it
// may only emit one signal when a range of rows is selected. Additionally, it
// may on occasion emit a TreeSelection::changed signal when nothing has
// happened (mostly as a result of programmers calling select_row on an already
// selected row).
type TreeSelection interface {
	gextras.Objector

	// CountSelectedRows returns the number of rows that have been selected in
	// @tree.
	CountSelectedRows() int
	// Mode gets the selection mode for @selection. See
	// gtk_tree_selection_set_mode().
	Mode() SelectionMode
	// SelectFunction returns the current selection function.
	SelectFunction() TreeSelectionFunc
	// Selected sets @iter to the currently selected node if @selection is set
	// to K_SELECTION_SINGLE or K_SELECTION_BROWSE. @iter may be NULL if you
	// just want to test if @selection has any selected nodes. @model is filled
	// with the current model as a convenience. This function will not work if
	// you use @selection is K_SELECTION_MULTIPLE.
	Selected() (model TreeModel, iter TreeIter, ok bool)
	// SelectedRows creates a list of path of all selected rows. Additionally,
	// if you are planning on modifying the model after calling this function,
	// you may want to convert the returned list into a list of
	// TreeRowReferences. To do this, you can use gtk_tree_row_reference_new().
	//
	// To free the return value, use:
	//
	//    g_list_free_full (list, (GDestroyNotify) gtk_tree_path_free);
	//
	SelectedRows() (model TreeModel, list *glib.List)
	// TreeView returns the tree view associated with @selection.
	TreeView() TreeView
	// UserData returns the user data for the selection function.
	UserData() interface{}
	// IterIsSelected returns true if the row at @iter is currently selected.
	IterIsSelected(iter *TreeIter) bool
	// PathIsSelected returns true if the row pointed to by @path is currently
	// selected. If @path does not point to a valid location, false is returned
	PathIsSelected(path *TreePath) bool
	// SelectAll selects all the nodes. @selection must be set to
	// K_SELECTION_MULTIPLE mode.
	SelectAll()
	// SelectIter selects the specified iterator.
	SelectIter(iter *TreeIter)
	// SelectPath: select the row at @path.
	SelectPath(path *TreePath)
	// SelectRange selects a range of nodes, determined by @start_path and
	// @end_path inclusive. @selection must be set to K_SELECTION_MULTIPLE mode.
	SelectRange(startPath *TreePath, endPath *TreePath)
	// SelectedForeach calls a function for each selected node. Note that you
	// cannot modify the tree or selection from within this function. As a
	// result, gtk_tree_selection_get_selected_rows() might be more useful.
	SelectedForeach(_func TreeSelectionForeachFunc)
	// SetMode sets the selection mode of the @selection. If the previous type
	// was K_SELECTION_MULTIPLE, then the anchor is kept selected, if it was
	// previously selected.
	SetMode(_type SelectionMode)
	// SetSelectFunction sets the selection function.
	//
	// If set, this function is called before any node is selected or
	// unselected, giving some control over which nodes are selected. The select
	// function should return true if the state of the node may be toggled, and
	// false if the state of the node should be left unchanged.
	SetSelectFunction(_func TreeSelectionFunc)
	// UnselectAll unselects all the nodes.
	UnselectAll()
	// UnselectIter unselects the specified iterator.
	UnselectIter(iter *TreeIter)
	// UnselectPath unselects the row at @path.
	UnselectPath(path *TreePath)
	// UnselectRange unselects a range of nodes, determined by @start_path and
	// @end_path inclusive.
	UnselectRange(startPath *TreePath, endPath *TreePath)
}

type treeSelection struct {
	*externglib.Object
}

// WrapTreeSelection wraps a GObject to the right type. It is
// primarily used internally.
func WrapTreeSelection(obj *externglib.Object) TreeSelection {
	return treeSelection{*externglib.Object{obj}}
}

func marshalTreeSelection(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTreeSelection(obj), nil
}

// CountSelectedRows returns the number of rows that have been selected in
// @tree.
func (selection treeSelection) CountSelectedRows() int {
	var arg0 *C.GtkTreeSelection

	arg0 = (*C.GtkTreeSelection)(selection.Native())

	ret := C.gtk_tree_selection_count_selected_rows(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Mode gets the selection mode for @selection. See
// gtk_tree_selection_set_mode().
func (selection treeSelection) Mode() SelectionMode {
	var arg0 *C.GtkTreeSelection

	arg0 = (*C.GtkTreeSelection)(selection.Native())

	ret := C.gtk_tree_selection_get_mode(arg0)

	var ret0 SelectionMode

	ret0 = SelectionMode(ret)

	return ret0
}

// SelectFunction returns the current selection function.
func (selection treeSelection) SelectFunction() TreeSelectionFunc {
	var arg0 *C.GtkTreeSelection

	arg0 = (*C.GtkTreeSelection)(selection.Native())

	ret := C.gtk_tree_selection_get_select_function(arg0)

	var ret0 TreeSelectionFunc

	return ret0
}

// Selected sets @iter to the currently selected node if @selection is set
// to K_SELECTION_SINGLE or K_SELECTION_BROWSE. @iter may be NULL if you
// just want to test if @selection has any selected nodes. @model is filled
// with the current model as a convenience. This function will not work if
// you use @selection is K_SELECTION_MULTIPLE.
func (selection treeSelection) Selected() (model TreeModel, iter TreeIter, ok bool) {
	var arg0 *C.GtkTreeSelection
	var arg1 **C.GtkTreeModel // out
	var arg2 *C.GtkTreeIter   // out

	arg0 = (*C.GtkTreeSelection)(selection.Native())

	ret := C.gtk_tree_selection_get_selected(arg0, &arg1, &arg2)

	var ret0 *TreeModel
	var ret1 *TreeIter
	var ret2 bool

	ret1 = WrapTreeIter(arg2)

	ret2 = gextras.Gobool(ret)

	return ret0, ret1, ret2
}

// SelectedRows creates a list of path of all selected rows. Additionally,
// if you are planning on modifying the model after calling this function,
// you may want to convert the returned list into a list of
// TreeRowReferences. To do this, you can use gtk_tree_row_reference_new().
//
// To free the return value, use:
//
//    g_list_free_full (list, (GDestroyNotify) gtk_tree_path_free);
//
func (selection treeSelection) SelectedRows() (model TreeModel, list *glib.List) {
	var arg0 *C.GtkTreeSelection
	var arg1 **C.GtkTreeModel // out

	arg0 = (*C.GtkTreeSelection)(selection.Native())

	ret := C.gtk_tree_selection_get_selected_rows(arg0, &arg1)

	var ret0 *TreeModel
	var ret1 *glib.List

	ret1 = glib.WrapList(ret)

	return ret0, ret1
}

// TreeView returns the tree view associated with @selection.
func (selection treeSelection) TreeView() TreeView {
	var arg0 *C.GtkTreeSelection

	arg0 = (*C.GtkTreeSelection)(selection.Native())

	ret := C.gtk_tree_selection_get_tree_view(arg0)

	var ret0 TreeView

	ret0 = WrapTreeView(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// UserData returns the user data for the selection function.
func (selection treeSelection) UserData() interface{} {
	var arg0 *C.GtkTreeSelection

	arg0 = (*C.GtkTreeSelection)(selection.Native())

	ret := C.gtk_tree_selection_get_user_data(arg0)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret))

	return ret0
}

// IterIsSelected returns true if the row at @iter is currently selected.
func (selection treeSelection) IterIsSelected(iter *TreeIter) bool {
	var arg0 *C.GtkTreeSelection
	var arg1 *C.GtkTreeIter

	arg0 = (*C.GtkTreeSelection)(selection.Native())
	arg1 = (*C.GtkTreeIter)(iter.Native())

	ret := C.gtk_tree_selection_iter_is_selected(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// PathIsSelected returns true if the row pointed to by @path is currently
// selected. If @path does not point to a valid location, false is returned
func (selection treeSelection) PathIsSelected(path *TreePath) bool {
	var arg0 *C.GtkTreeSelection
	var arg1 *C.GtkTreePath

	arg0 = (*C.GtkTreeSelection)(selection.Native())
	arg1 = (*C.GtkTreePath)(path.Native())

	ret := C.gtk_tree_selection_path_is_selected(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// SelectAll selects all the nodes. @selection must be set to
// K_SELECTION_MULTIPLE mode.
func (selection treeSelection) SelectAll() {
	var arg0 *C.GtkTreeSelection

	arg0 = (*C.GtkTreeSelection)(selection.Native())

	C.gtk_tree_selection_select_all(arg0)
}

// SelectIter selects the specified iterator.
func (selection treeSelection) SelectIter(iter *TreeIter) {
	var arg0 *C.GtkTreeSelection
	var arg1 *C.GtkTreeIter

	arg0 = (*C.GtkTreeSelection)(selection.Native())
	arg1 = (*C.GtkTreeIter)(iter.Native())

	C.gtk_tree_selection_select_iter(arg0, arg1)
}

// SelectPath: select the row at @path.
func (selection treeSelection) SelectPath(path *TreePath) {
	var arg0 *C.GtkTreeSelection
	var arg1 *C.GtkTreePath

	arg0 = (*C.GtkTreeSelection)(selection.Native())
	arg1 = (*C.GtkTreePath)(path.Native())

	C.gtk_tree_selection_select_path(arg0, arg1)
}

// SelectRange selects a range of nodes, determined by @start_path and
// @end_path inclusive. @selection must be set to K_SELECTION_MULTIPLE mode.
func (selection treeSelection) SelectRange(startPath *TreePath, endPath *TreePath) {
	var arg0 *C.GtkTreeSelection
	var arg1 *C.GtkTreePath
	var arg2 *C.GtkTreePath

	arg0 = (*C.GtkTreeSelection)(selection.Native())
	arg1 = (*C.GtkTreePath)(startPath.Native())
	arg2 = (*C.GtkTreePath)(endPath.Native())

	C.gtk_tree_selection_select_range(arg0, arg1, arg2)
}

// SelectedForeach calls a function for each selected node. Note that you
// cannot modify the tree or selection from within this function. As a
// result, gtk_tree_selection_get_selected_rows() might be more useful.
func (selection treeSelection) SelectedForeach(_func TreeSelectionForeachFunc) {
	var arg0 *C.GtkTreeSelection
	var arg1 C.GtkTreeSelectionForeachFunc
	arg2 := C.gpointer(box.Assign(data))

	arg0 = (*C.GtkTreeSelection)(selection.Native())
	arg1 = (*[0]byte)(C.gotk4_TreeSelectionForeachFunc)

	C.gtk_tree_selection_selected_foreach(arg0, arg1)
}

// SetMode sets the selection mode of the @selection. If the previous type
// was K_SELECTION_MULTIPLE, then the anchor is kept selected, if it was
// previously selected.
func (selection treeSelection) SetMode(_type SelectionMode) {
	var arg0 *C.GtkTreeSelection
	var arg1 C.GtkSelectionMode

	arg0 = (*C.GtkTreeSelection)(selection.Native())
	arg1 = (C.GtkSelectionMode)(_type)

	C.gtk_tree_selection_set_mode(arg0, arg1)
}

// SetSelectFunction sets the selection function.
//
// If set, this function is called before any node is selected or
// unselected, giving some control over which nodes are selected. The select
// function should return true if the state of the node may be toggled, and
// false if the state of the node should be left unchanged.
func (selection treeSelection) SetSelectFunction(_func TreeSelectionFunc) {
	var arg0 *C.GtkTreeSelection
	var arg1 C.GtkTreeSelectionFunc
	arg2 := C.gpointer(box.Assign(data))

	arg0 = (*C.GtkTreeSelection)(selection.Native())
	arg1 = (*[0]byte)(C.gotk4_TreeSelectionFunc)

	C.gtk_tree_selection_set_select_function(arg0, arg1, (*[0]byte)(C.callbackDelete))
}

// UnselectAll unselects all the nodes.
func (selection treeSelection) UnselectAll() {
	var arg0 *C.GtkTreeSelection

	arg0 = (*C.GtkTreeSelection)(selection.Native())

	C.gtk_tree_selection_unselect_all(arg0)
}

// UnselectIter unselects the specified iterator.
func (selection treeSelection) UnselectIter(iter *TreeIter) {
	var arg0 *C.GtkTreeSelection
	var arg1 *C.GtkTreeIter

	arg0 = (*C.GtkTreeSelection)(selection.Native())
	arg1 = (*C.GtkTreeIter)(iter.Native())

	C.gtk_tree_selection_unselect_iter(arg0, arg1)
}

// UnselectPath unselects the row at @path.
func (selection treeSelection) UnselectPath(path *TreePath) {
	var arg0 *C.GtkTreeSelection
	var arg1 *C.GtkTreePath

	arg0 = (*C.GtkTreeSelection)(selection.Native())
	arg1 = (*C.GtkTreePath)(path.Native())

	C.gtk_tree_selection_unselect_path(arg0, arg1)
}

// UnselectRange unselects a range of nodes, determined by @start_path and
// @end_path inclusive.
func (selection treeSelection) UnselectRange(startPath *TreePath, endPath *TreePath) {
	var arg0 *C.GtkTreeSelection
	var arg1 *C.GtkTreePath
	var arg2 *C.GtkTreePath

	arg0 = (*C.GtkTreeSelection)(selection.Native())
	arg1 = (*C.GtkTreePath)(startPath.Native())
	arg2 = (*C.GtkTreePath)(endPath.Native())

	C.gtk_tree_selection_unselect_range(arg0, arg1, arg2)
}

// TreeStore: the TreeStore object is a list model for use with a TreeView
// widget. It implements the TreeModel interface, and consequently, can use all
// of the methods available there. It also implements the TreeSortable interface
// so it can be sorted by the view. Finally, it also implements the tree [drag
// and drop][gtk3-GtkTreeView-drag-and-drop] interfaces.
//
//
// GtkTreeStore as GtkBuildable
//
// The GtkTreeStore implementation of the Buildable interface allows to specify
// the model columns with a <columns> element that may contain multiple <column>
// elements, each specifying one model column. The “type” attribute specifies
// the data type for the column.
//
// An example of a UI Definition fragment for a tree store:
//
//
//    <object class="GtkTreeStore">
//      <columns>
//        <column type="gchararray"/>
//        <column type="gchararray"/>
//        <column type="gint"/>
//      </columns>
//    </object>
//
type TreeStore interface {
	gextras.Objector

	// Append appends a new row to @tree_store. If @parent is non-nil, then it
	// will append the new row after the last child of @parent, otherwise it
	// will append a row to the top level. @iter will be changed to point to
	// this new row. The row will be empty after this function is called. To
	// fill in values, you need to call gtk_tree_store_set() or
	// gtk_tree_store_set_value().
	Append(parent *TreeIter) TreeIter
	// Clear removes all rows from @tree_store
	Clear()
	// Insert creates a new row at @position. If parent is non-nil, then the row
	// will be made a child of @parent. Otherwise, the row will be created at
	// the toplevel. If @position is -1 or is larger than the number of rows at
	// that level, then the new row will be inserted to the end of the list.
	// @iter will be changed to point to this new row. The row will be empty
	// after this function is called. To fill in values, you need to call
	// gtk_tree_store_set() or gtk_tree_store_set_value().
	Insert(parent *TreeIter, position int) TreeIter
	// InsertAfter inserts a new row after @sibling. If @sibling is nil, then
	// the row will be prepended to @parent ’s children. If @parent and @sibling
	// are nil, then the row will be prepended to the toplevel. If both @sibling
	// and @parent are set, then @parent must be the parent of @sibling. When
	// @sibling is set, @parent is optional.
	//
	// @iter will be changed to point to this new row. The row will be empty
	// after this function is called. To fill in values, you need to call
	// gtk_tree_store_set() or gtk_tree_store_set_value().
	InsertAfter(parent *TreeIter, sibling *TreeIter) TreeIter
	// InsertBefore inserts a new row before @sibling. If @sibling is nil, then
	// the row will be appended to @parent ’s children. If @parent and @sibling
	// are nil, then the row will be appended to the toplevel. If both @sibling
	// and @parent are set, then @parent must be the parent of @sibling. When
	// @sibling is set, @parent is optional.
	//
	// @iter will be changed to point to this new row. The row will be empty
	// after this function is called. To fill in values, you need to call
	// gtk_tree_store_set() or gtk_tree_store_set_value().
	InsertBefore(parent *TreeIter, sibling *TreeIter) TreeIter
	// InsertWithValuesv: a variant of gtk_tree_store_insert_with_values() which
	// takes the columns and values as two arrays, instead of varargs. This
	// function is mainly intended for language bindings.
	InsertWithValuesv(parent *TreeIter, position int, columns []int, values []*externglib.Value) TreeIter
	// IsAncestor returns true if @iter is an ancestor of @descendant. That is,
	// @iter is the parent (or grandparent or great-grandparent) of @descendant.
	IsAncestor(iter *TreeIter, descendant *TreeIter) bool
	// IterDepth returns the depth of @iter. This will be 0 for anything on the
	// root level, 1 for anything down a level, etc.
	IterDepth(iter *TreeIter) int
	// IterIsValid: WARNING: This function is slow. Only use it for debugging
	// and/or testing purposes.
	//
	// Checks if the given iter is a valid iter for this TreeStore.
	IterIsValid(iter *TreeIter) bool
	// MoveAfter moves @iter in @tree_store to the position after @position.
	// @iter and @position should be in the same level. Note that this function
	// only works with unsorted stores. If @position is nil, @iter will be moved
	// to the start of the level.
	MoveAfter(iter *TreeIter, position *TreeIter)
	// MoveBefore moves @iter in @tree_store to the position before @position.
	// @iter and @position should be in the same level. Note that this function
	// only works with unsorted stores. If @position is nil, @iter will be moved
	// to the end of the level.
	MoveBefore(iter *TreeIter, position *TreeIter)
	// Prepend prepends a new row to @tree_store. If @parent is non-nil, then it
	// will prepend the new row before the first child of @parent, otherwise it
	// will prepend a row to the top level. @iter will be changed to point to
	// this new row. The row will be empty after this function is called. To
	// fill in values, you need to call gtk_tree_store_set() or
	// gtk_tree_store_set_value().
	Prepend(parent *TreeIter) TreeIter
	// Remove removes @iter from @tree_store. After being removed, @iter is set
	// to the next valid row at that level, or invalidated if it previously
	// pointed to the last one.
	Remove(iter *TreeIter) bool
	// Reorder reorders the children of @parent in @tree_store to follow the
	// order indicated by @new_order. Note that this function only works with
	// unsorted stores.
	Reorder(parent *TreeIter, newOrder []int)
	// SetColumnTypes: this function is meant primarily for #GObjects that
	// inherit from TreeStore, and should only be used when constructing a new
	// TreeStore. It will not function after a row has been added, or a method
	// on the TreeModel interface is called.
	SetColumnTypes(nColumns int, types []externglib.Type)
	// SetValue sets the data in the cell specified by @iter and @column. The
	// type of @value must be convertible to the type of the column.
	SetValue(iter *TreeIter, column int, value *externglib.Value)
	// SetValuesv: a variant of gtk_tree_store_set_valist() which takes the
	// columns and values as two arrays, instead of varargs. This function is
	// mainly intended for language bindings or in case the number of columns to
	// change is not known until run-time.
	SetValuesv(iter *TreeIter, columns []int, values []*externglib.Value)
	// Swap swaps @a and @b in the same level of @tree_store. Note that this
	// function only works with unsorted stores.
	Swap(a *TreeIter, b *TreeIter)
}

type treeStore struct {
	*externglib.Object
}

// WrapTreeStore wraps a GObject to the right type. It is
// primarily used internally.
func WrapTreeStore(obj *externglib.Object) TreeStore {
	return treeStore{*externglib.Object{obj}}
}

func marshalTreeStore(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTreeStore(obj), nil
}

// NewTreeStoreV constructs a class TreeStore.
func NewTreeStoreV(nColumns int, types []externglib.Type) TreeStore {
	var arg1 C.int
	var arg2 *C.GType

	{
		var dst []C.GType
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(C.malloc(C.sizeof_GType * len(types))))
		sliceHeader.Len = len(types)
		sliceHeader.Cap = len(types)
		defer C.free(unsafe.Pointer(sliceHeader.Data))

		for i := 0; i < len(types); i++ {
			src := types[i]
			dst[i] = C.GType(src)
		}

		arg2 = (*C.GType)(unsafe.Pointer(sliceHeader.Data))
		arg1 = len(types)
	}

	ret := C.gtk_tree_store_newv(arg1, arg2)

	var ret0 TreeStore

	ret0 = WrapTreeStore(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Append appends a new row to @tree_store. If @parent is non-nil, then it
// will append the new row after the last child of @parent, otherwise it
// will append a row to the top level. @iter will be changed to point to
// this new row. The row will be empty after this function is called. To
// fill in values, you need to call gtk_tree_store_set() or
// gtk_tree_store_set_value().
func (treeStore treeStore) Append(parent *TreeIter) TreeIter {
	var arg0 *C.GtkTreeStore
	var arg1 *C.GtkTreeIter // out
	var arg2 *C.GtkTreeIter

	arg0 = (*C.GtkTreeStore)(treeStore.Native())
	arg2 = (*C.GtkTreeIter)(parent.Native())

	ret := C.gtk_tree_store_append(arg0, &arg1, arg2)

	var ret0 *TreeIter

	ret0 = WrapTreeIter(arg1)

	return ret0
}

// Clear removes all rows from @tree_store
func (treeStore treeStore) Clear() {
	var arg0 *C.GtkTreeStore

	arg0 = (*C.GtkTreeStore)(treeStore.Native())

	C.gtk_tree_store_clear(arg0)
}

// Insert creates a new row at @position. If parent is non-nil, then the row
// will be made a child of @parent. Otherwise, the row will be created at
// the toplevel. If @position is -1 or is larger than the number of rows at
// that level, then the new row will be inserted to the end of the list.
// @iter will be changed to point to this new row. The row will be empty
// after this function is called. To fill in values, you need to call
// gtk_tree_store_set() or gtk_tree_store_set_value().
func (treeStore treeStore) Insert(parent *TreeIter, position int) TreeIter {
	var arg0 *C.GtkTreeStore
	var arg1 *C.GtkTreeIter // out
	var arg2 *C.GtkTreeIter
	var arg3 C.int

	arg0 = (*C.GtkTreeStore)(treeStore.Native())
	arg2 = (*C.GtkTreeIter)(parent.Native())
	arg3 = C.int(position)

	ret := C.gtk_tree_store_insert(arg0, &arg1, arg2, arg3)

	var ret0 *TreeIter

	ret0 = WrapTreeIter(arg1)

	return ret0
}

// InsertAfter inserts a new row after @sibling. If @sibling is nil, then
// the row will be prepended to @parent ’s children. If @parent and @sibling
// are nil, then the row will be prepended to the toplevel. If both @sibling
// and @parent are set, then @parent must be the parent of @sibling. When
// @sibling is set, @parent is optional.
//
// @iter will be changed to point to this new row. The row will be empty
// after this function is called. To fill in values, you need to call
// gtk_tree_store_set() or gtk_tree_store_set_value().
func (treeStore treeStore) InsertAfter(parent *TreeIter, sibling *TreeIter) TreeIter {
	var arg0 *C.GtkTreeStore
	var arg1 *C.GtkTreeIter // out
	var arg2 *C.GtkTreeIter
	var arg3 *C.GtkTreeIter

	arg0 = (*C.GtkTreeStore)(treeStore.Native())
	arg2 = (*C.GtkTreeIter)(parent.Native())
	arg3 = (*C.GtkTreeIter)(sibling.Native())

	ret := C.gtk_tree_store_insert_after(arg0, &arg1, arg2, arg3)

	var ret0 *TreeIter

	ret0 = WrapTreeIter(arg1)

	return ret0
}

// InsertBefore inserts a new row before @sibling. If @sibling is nil, then
// the row will be appended to @parent ’s children. If @parent and @sibling
// are nil, then the row will be appended to the toplevel. If both @sibling
// and @parent are set, then @parent must be the parent of @sibling. When
// @sibling is set, @parent is optional.
//
// @iter will be changed to point to this new row. The row will be empty
// after this function is called. To fill in values, you need to call
// gtk_tree_store_set() or gtk_tree_store_set_value().
func (treeStore treeStore) InsertBefore(parent *TreeIter, sibling *TreeIter) TreeIter {
	var arg0 *C.GtkTreeStore
	var arg1 *C.GtkTreeIter // out
	var arg2 *C.GtkTreeIter
	var arg3 *C.GtkTreeIter

	arg0 = (*C.GtkTreeStore)(treeStore.Native())
	arg2 = (*C.GtkTreeIter)(parent.Native())
	arg3 = (*C.GtkTreeIter)(sibling.Native())

	ret := C.gtk_tree_store_insert_before(arg0, &arg1, arg2, arg3)

	var ret0 *TreeIter

	ret0 = WrapTreeIter(arg1)

	return ret0
}

// InsertWithValuesv: a variant of gtk_tree_store_insert_with_values() which
// takes the columns and values as two arrays, instead of varargs. This
// function is mainly intended for language bindings.
func (treeStore treeStore) InsertWithValuesv(parent *TreeIter, position int, columns []int, values []*externglib.Value) TreeIter {
	var arg0 *C.GtkTreeStore
	var arg1 *C.GtkTreeIter // out
	var arg2 *C.GtkTreeIter
	var arg3 C.int
	var arg4 *C.int
	var arg5 *C.GValue
	var arg6 C.int

	arg0 = (*C.GtkTreeStore)(treeStore.Native())
	arg2 = (*C.GtkTreeIter)(parent.Native())
	arg3 = C.int(position)
	{
		arg4 = (*C.int)(&columns[0])
		arg6 = len(columns)
		defer runtime.KeepAlive(columns)
	}
	{
		var dst []C.GValue
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(C.malloc(C.sizeof_GValue * len(values))))
		sliceHeader.Len = len(values)
		sliceHeader.Cap = len(values)
		defer C.free(unsafe.Pointer(sliceHeader.Data))

		for i := 0; i < len(values); i++ {
			src := values[i]
			dst[i] = (*C.GValue)(src.GValue)
		}

		arg5 = (*C.GValue)(unsafe.Pointer(sliceHeader.Data))
		arg6 = len(values)
	}

	ret := C.gtk_tree_store_insert_with_valuesv(arg0, &arg1, arg2, arg3, arg4, arg5, arg6)

	var ret0 *TreeIter

	ret0 = WrapTreeIter(arg1)

	return ret0
}

// IsAncestor returns true if @iter is an ancestor of @descendant. That is,
// @iter is the parent (or grandparent or great-grandparent) of @descendant.
func (treeStore treeStore) IsAncestor(iter *TreeIter, descendant *TreeIter) bool {
	var arg0 *C.GtkTreeStore
	var arg1 *C.GtkTreeIter
	var arg2 *C.GtkTreeIter

	arg0 = (*C.GtkTreeStore)(treeStore.Native())
	arg1 = (*C.GtkTreeIter)(iter.Native())
	arg2 = (*C.GtkTreeIter)(descendant.Native())

	ret := C.gtk_tree_store_is_ancestor(arg0, arg1, arg2)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// IterDepth returns the depth of @iter. This will be 0 for anything on the
// root level, 1 for anything down a level, etc.
func (treeStore treeStore) IterDepth(iter *TreeIter) int {
	var arg0 *C.GtkTreeStore
	var arg1 *C.GtkTreeIter

	arg0 = (*C.GtkTreeStore)(treeStore.Native())
	arg1 = (*C.GtkTreeIter)(iter.Native())

	ret := C.gtk_tree_store_iter_depth(arg0, arg1)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// IterIsValid: WARNING: This function is slow. Only use it for debugging
// and/or testing purposes.
//
// Checks if the given iter is a valid iter for this TreeStore.
func (treeStore treeStore) IterIsValid(iter *TreeIter) bool {
	var arg0 *C.GtkTreeStore
	var arg1 *C.GtkTreeIter

	arg0 = (*C.GtkTreeStore)(treeStore.Native())
	arg1 = (*C.GtkTreeIter)(iter.Native())

	ret := C.gtk_tree_store_iter_is_valid(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// MoveAfter moves @iter in @tree_store to the position after @position.
// @iter and @position should be in the same level. Note that this function
// only works with unsorted stores. If @position is nil, @iter will be moved
// to the start of the level.
func (treeStore treeStore) MoveAfter(iter *TreeIter, position *TreeIter) {
	var arg0 *C.GtkTreeStore
	var arg1 *C.GtkTreeIter
	var arg2 *C.GtkTreeIter

	arg0 = (*C.GtkTreeStore)(treeStore.Native())
	arg1 = (*C.GtkTreeIter)(iter.Native())
	arg2 = (*C.GtkTreeIter)(position.Native())

	C.gtk_tree_store_move_after(arg0, arg1, arg2)
}

// MoveBefore moves @iter in @tree_store to the position before @position.
// @iter and @position should be in the same level. Note that this function
// only works with unsorted stores. If @position is nil, @iter will be moved
// to the end of the level.
func (treeStore treeStore) MoveBefore(iter *TreeIter, position *TreeIter) {
	var arg0 *C.GtkTreeStore
	var arg1 *C.GtkTreeIter
	var arg2 *C.GtkTreeIter

	arg0 = (*C.GtkTreeStore)(treeStore.Native())
	arg1 = (*C.GtkTreeIter)(iter.Native())
	arg2 = (*C.GtkTreeIter)(position.Native())

	C.gtk_tree_store_move_before(arg0, arg1, arg2)
}

// Prepend prepends a new row to @tree_store. If @parent is non-nil, then it
// will prepend the new row before the first child of @parent, otherwise it
// will prepend a row to the top level. @iter will be changed to point to
// this new row. The row will be empty after this function is called. To
// fill in values, you need to call gtk_tree_store_set() or
// gtk_tree_store_set_value().
func (treeStore treeStore) Prepend(parent *TreeIter) TreeIter {
	var arg0 *C.GtkTreeStore
	var arg1 *C.GtkTreeIter // out
	var arg2 *C.GtkTreeIter

	arg0 = (*C.GtkTreeStore)(treeStore.Native())
	arg2 = (*C.GtkTreeIter)(parent.Native())

	ret := C.gtk_tree_store_prepend(arg0, &arg1, arg2)

	var ret0 *TreeIter

	ret0 = WrapTreeIter(arg1)

	return ret0
}

// Remove removes @iter from @tree_store. After being removed, @iter is set
// to the next valid row at that level, or invalidated if it previously
// pointed to the last one.
func (treeStore treeStore) Remove(iter *TreeIter) bool {
	var arg0 *C.GtkTreeStore
	var arg1 *C.GtkTreeIter

	arg0 = (*C.GtkTreeStore)(treeStore.Native())
	arg1 = (*C.GtkTreeIter)(iter.Native())

	ret := C.gtk_tree_store_remove(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Reorder reorders the children of @parent in @tree_store to follow the
// order indicated by @new_order. Note that this function only works with
// unsorted stores.
func (treeStore treeStore) Reorder(parent *TreeIter, newOrder []int) {
	var arg0 *C.GtkTreeStore
	var arg1 *C.GtkTreeIter
	var arg2 *C.int

	arg0 = (*C.GtkTreeStore)(treeStore.Native())
	arg1 = (*C.GtkTreeIter)(parent.Native())
	{

	}

	C.gtk_tree_store_reorder(arg0, arg1, arg2)
}

// SetColumnTypes: this function is meant primarily for #GObjects that
// inherit from TreeStore, and should only be used when constructing a new
// TreeStore. It will not function after a row has been added, or a method
// on the TreeModel interface is called.
func (treeStore treeStore) SetColumnTypes(nColumns int, types []externglib.Type) {
	var arg0 *C.GtkTreeStore
	var arg1 C.int
	var arg2 *C.GType

	arg0 = (*C.GtkTreeStore)(treeStore.Native())
	{
		var dst []C.GType
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(C.malloc(C.sizeof_GType * len(types))))
		sliceHeader.Len = len(types)
		sliceHeader.Cap = len(types)
		defer C.free(unsafe.Pointer(sliceHeader.Data))

		for i := 0; i < len(types); i++ {
			src := types[i]
			dst[i] = C.GType(src)
		}

		arg2 = (*C.GType)(unsafe.Pointer(sliceHeader.Data))
		arg1 = len(types)
	}

	C.gtk_tree_store_set_column_types(arg0, arg1, arg2)
}

// SetValue sets the data in the cell specified by @iter and @column. The
// type of @value must be convertible to the type of the column.
func (treeStore treeStore) SetValue(iter *TreeIter, column int, value *externglib.Value) {
	var arg0 *C.GtkTreeStore
	var arg1 *C.GtkTreeIter
	var arg2 C.int
	var arg3 *C.GValue

	arg0 = (*C.GtkTreeStore)(treeStore.Native())
	arg1 = (*C.GtkTreeIter)(iter.Native())
	arg2 = C.int(column)
	arg3 = (*C.GValue)(value.GValue)

	C.gtk_tree_store_set_value(arg0, arg1, arg2, arg3)
}

// SetValuesv: a variant of gtk_tree_store_set_valist() which takes the
// columns and values as two arrays, instead of varargs. This function is
// mainly intended for language bindings or in case the number of columns to
// change is not known until run-time.
func (treeStore treeStore) SetValuesv(iter *TreeIter, columns []int, values []*externglib.Value) {
	var arg0 *C.GtkTreeStore
	var arg1 *C.GtkTreeIter
	var arg2 *C.int
	var arg3 *C.GValue
	var arg4 C.int

	arg0 = (*C.GtkTreeStore)(treeStore.Native())
	arg1 = (*C.GtkTreeIter)(iter.Native())
	{
		arg2 = (*C.int)(&columns[0])
		arg4 = len(columns)
		defer runtime.KeepAlive(columns)
	}
	{
		var dst []C.GValue
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(C.malloc(C.sizeof_GValue * len(values))))
		sliceHeader.Len = len(values)
		sliceHeader.Cap = len(values)
		defer C.free(unsafe.Pointer(sliceHeader.Data))

		for i := 0; i < len(values); i++ {
			src := values[i]
			dst[i] = (*C.GValue)(src.GValue)
		}

		arg3 = (*C.GValue)(unsafe.Pointer(sliceHeader.Data))
		arg4 = len(values)
	}

	C.gtk_tree_store_set_valuesv(arg0, arg1, arg2, arg3, arg4)
}

// Swap swaps @a and @b in the same level of @tree_store. Note that this
// function only works with unsorted stores.
func (treeStore treeStore) Swap(a *TreeIter, b *TreeIter) {
	var arg0 *C.GtkTreeStore
	var arg1 *C.GtkTreeIter
	var arg2 *C.GtkTreeIter

	arg0 = (*C.GtkTreeStore)(treeStore.Native())
	arg1 = (*C.GtkTreeIter)(a.Native())
	arg2 = (*C.GtkTreeIter)(b.Native())

	C.gtk_tree_store_swap(arg0, arg1, arg2)
}

// TreeView: widget that displays any object that implements the TreeModel
// interface.
//
// Please refer to the [tree widget conceptual overview][TreeWidget] for an
// overview of all the objects and data types related to the tree widget and how
// they work together.
//
// Several different coordinate systems are exposed in the GtkTreeView API.
// These are:
//
// ! (tree-view-coordinates.png)
//
// Coordinate systems in GtkTreeView API:
//
// - Widget coordinates: Coordinates relative to the widget (usually
// `widget->window`).
//
// - Bin window coordinates: Coordinates relative to the window that GtkTreeView
// renders to.
//
// - Tree coordinates: Coordinates relative to the entire scrollable area of
// GtkTreeView. These coordinates start at (0, 0) for row 0 of the tree.
//
// Several functions are available for converting between the different
// coordinate systems. The most common translations are between widget and bin
// window coordinates and between bin window and tree coordinates. For the
// former you can use gtk_tree_view_convert_widget_to_bin_window_coords() (and
// vice versa), for the latter gtk_tree_view_convert_bin_window_to_tree_coords()
// (and vice versa).
//
//
// GtkTreeView as GtkBuildable
//
// The GtkTreeView implementation of the GtkBuildable interface accepts
// TreeViewColumn objects as <child> elements and exposes the internal
// TreeSelection in UI definitions.
//
// An example of a UI definition fragment with GtkTreeView:
//
//
//    <object class="GtkTreeView" id="treeview">
//      <property name="model">liststore1</property>
//      <child>
//        <object class="GtkTreeViewColumn" id="test-column">
//          <property name="title">Test</property>
//          <child>
//            <object class="GtkCellRendererText" id="test-renderer"/>
//            <attributes>
//              <attribute name="text">1</attribute>
//            </attributes>
//          </child>
//        </object>
//      </child>
//      <child internal-child="selection">
//        <object class="GtkTreeSelection" id="selection">
//          <signal name="changed" handler="on_treeview_selection_changed"/>
//        </object>
//      </child>
//    </object>
//    ]|
//
//
//
// CSS nodes
//
//
//    |[<!-- language="plain" -->
//    treeview.view
//    ├── header
//    │   ├── <column header>
//    ┊   ┊
//    │   ╰── <column header>
//    │
//    ├── [rubberband]
//    ╰── [dndtarget]
//
//
// GtkTreeView has a main CSS node with name treeview and style class .view. It
// has a subnode with name header, which is the parent for all the column header
// widgets' CSS nodes.
//
// For rubberband selection, a subnode with name rubberband is used.
//
// For the drop target location during DND, a subnode with name dndtarget is
// used.
type TreeView interface {
	Widget

	// AppendColumn appends @column to the list of columns. If @tree_view has
	// “fixed_height” mode enabled, then @column must have its “sizing” property
	// set to be GTK_TREE_VIEW_COLUMN_FIXED.
	AppendColumn(column TreeViewColumn) int
	// CollapseAll: recursively collapses all visible, expanded nodes in
	// @tree_view.
	CollapseAll()
	// CollapseRow collapses a row (hides its child rows, if they exist).
	CollapseRow(path *TreePath) bool
	// ColumnsAutosize resizes all columns to their optimal width. Only works
	// after the treeview has been realized.
	ColumnsAutosize()
	// ConvertBinWindowToTreeCoords converts bin_window coordinates to
	// coordinates for the tree (the full scrollable area of the tree).
	ConvertBinWindowToTreeCoords(bx int, by int) (tx int, ty int)
	// ConvertBinWindowToWidgetCoords converts bin_window coordinates to widget
	// relative coordinates.
	ConvertBinWindowToWidgetCoords(bx int, by int) (wx int, wy int)
	// ConvertTreeToBinWindowCoords converts tree coordinates (coordinates in
	// full scrollable area of the tree) to bin_window coordinates.
	ConvertTreeToBinWindowCoords(tx int, ty int) (bx int, by int)
	// ConvertTreeToWidgetCoords converts tree coordinates (coordinates in full
	// scrollable area of the tree) to widget coordinates.
	ConvertTreeToWidgetCoords(tx int, ty int) (wx int, wy int)
	// ConvertWidgetToBinWindowCoords converts widget coordinates to coordinates
	// for the bin_window.
	ConvertWidgetToBinWindowCoords(wx int, wy int) (bx int, by int)
	// ConvertWidgetToTreeCoords converts widget coordinates to coordinates for
	// the tree (the full scrollable area of the tree).
	ConvertWidgetToTreeCoords(wx int, wy int) (tx int, ty int)
	// CreateRowDragIcon creates a #cairo_surface_t representation of the row at
	// @path. This image is used for a drag icon.
	CreateRowDragIcon(path *TreePath) gdk.Paintable
	// EnableModelDragDest turns @tree_view into a drop destination for
	// automatic DND. Calling this method sets TreeView:reorderable to false.
	EnableModelDragDest(formats *gdk.ContentFormats, actions gdk.DragAction)
	// EnableModelDragSource turns @tree_view into a drag source for automatic
	// DND. Calling this method sets TreeView:reorderable to false.
	EnableModelDragSource(startButtonMask gdk.ModifierType, formats *gdk.ContentFormats, actions gdk.DragAction)
	// ExpandAll: recursively expands all nodes in the @tree_view.
	ExpandAll()
	// ExpandRow opens the row so its children are visible.
	ExpandRow(path *TreePath, openAll bool) bool
	// ExpandToPath expands the row at @path. This will also expand all parent
	// rows of @path as necessary.
	ExpandToPath(path *TreePath)
	// ActivateOnSingleClick gets the setting set by
	// gtk_tree_view_set_activate_on_single_click().
	ActivateOnSingleClick() bool
	// BackgroundArea fills the bounding rectangle in bin_window coordinates for
	// the cell at the row specified by @path and the column specified by
	// @column. If @path is nil, or points to a node not found in the tree, the
	// @y and @height fields of the rectangle will be filled with 0. If @column
	// is nil, the @x and @width fields will be filled with 0. The returned
	// rectangle is equivalent to the @background_area passed to
	// gtk_cell_renderer_render(). These background areas tile to cover the
	// entire bin window. Contrast with the @cell_area, returned by
	// gtk_tree_view_get_cell_area(), which returns only the cell itself,
	// excluding surrounding borders and the tree expander area.
	BackgroundArea(path *TreePath, column TreeViewColumn) gdk.Rectangle
	// CellArea fills the bounding rectangle in bin_window coordinates for the
	// cell at the row specified by @path and the column specified by @column.
	// If @path is nil, or points to a path not currently displayed, the @y and
	// @height fields of the rectangle will be filled with 0. If @column is nil,
	// the @x and @width fields will be filled with 0. The sum of all cell rects
	// does not cover the entire tree; there are extra pixels in between rows,
	// for example. The returned rectangle is equivalent to the @cell_area
	// passed to gtk_cell_renderer_render(). This function is only valid if
	// @tree_view is realized.
	CellArea(path *TreePath, column TreeViewColumn) gdk.Rectangle
	// Column gets the TreeViewColumn at the given position in the #tree_view.
	Column(n int) TreeViewColumn
	// Columns returns a #GList of all the TreeViewColumn s currently in
	// @tree_view. The returned list must be freed with g_list_free ().
	Columns() *glib.List
	// Cursor fills in @path and @focus_column with the current path and focus
	// column. If the cursor isn’t currently set, then *@path will be nil. If no
	// column currently has focus, then *@focus_column will be nil.
	//
	// The returned TreePath must be freed with gtk_tree_path_free() when you
	// are done with it.
	Cursor() (path *TreePath, focusColumn TreeViewColumn)
	// DestRowAtPos determines the destination row for a given position. @drag_x
	// and @drag_y are expected to be in widget coordinates. This function is
	// only meaningful if @tree_view is realized. Therefore this function will
	// always return false if @tree_view is not realized or does not have a
	// model.
	DestRowAtPos(dragX int, dragY int) (path *TreePath, pos TreeViewDropPosition, ok bool)
	// DragDestRow gets information about the row that is highlighted for
	// feedback.
	DragDestRow() (path *TreePath, pos TreeViewDropPosition)
	// EnableSearch returns whether or not the tree allows to start interactive
	// searching by typing in text.
	EnableSearch() bool
	// EnableTreeLines returns whether or not tree lines are drawn in
	// @tree_view.
	EnableTreeLines() bool
	// ExpanderColumn returns the column that is the current expander column, or
	// nil if none has been set. This column has the expander arrow drawn next
	// to it.
	ExpanderColumn() TreeViewColumn
	// FixedHeightMode returns whether fixed height mode is turned on for
	// @tree_view.
	FixedHeightMode() bool
	// GridLines returns which grid lines are enabled in @tree_view.
	GridLines() TreeViewGridLines
	// HeadersClickable returns whether all header columns are clickable.
	HeadersClickable() bool
	// HeadersVisible returns true if the headers on the @tree_view are visible.
	HeadersVisible() bool
	// HoverExpand returns whether hover expansion mode is turned on for
	// @tree_view.
	HoverExpand() bool
	// HoverSelection returns whether hover selection mode is turned on for
	// @tree_view.
	HoverSelection() bool
	// LevelIndentation returns the amount, in pixels, of extra indentation for
	// child levels in @tree_view.
	LevelIndentation() int
	// Model returns the model the TreeView is based on. Returns nil if the
	// model is unset.
	Model() TreeModel
	// NColumns queries the number of columns in the given @tree_view.
	NColumns() uint
	// PathAtPos finds the path at the point (@x, @y), relative to bin_window
	// coordinates. That is, @x and @y are relative to an events coordinates.
	// Widget-relative coordinates must be converted using
	// gtk_tree_view_convert_widget_to_bin_window_coords(). It is primarily for
	// things like popup menus. If @path is non-nil, then it will be filled with
	// the TreePath at that point. This path should be freed with
	// gtk_tree_path_free(). If @column is non-nil, then it will be filled with
	// the column at that point. @cell_x and @cell_y return the coordinates
	// relative to the cell background (i.e. the @background_area passed to
	// gtk_cell_renderer_render()). This function is only meaningful if
	// @tree_view is realized. Therefore this function will always return false
	// if @tree_view is not realized or does not have a model.
	//
	// For converting widget coordinates (eg. the ones you get from
	// GtkWidget::query-tooltip), please see
	// gtk_tree_view_convert_widget_to_bin_window_coords().
	PathAtPos(x int, y int) (path *TreePath, column TreeViewColumn, cellX int, cellY int, ok bool)
	// Reorderable retrieves whether the user can reorder the tree via
	// drag-and-drop. See gtk_tree_view_set_reorderable().
	Reorderable() bool
	// RowSeparatorFunc returns the current row separator function.
	RowSeparatorFunc() TreeViewRowSeparatorFunc
	// RubberBanding returns whether rubber banding is turned on for @tree_view.
	// If the selection mode is K_SELECTION_MULTIPLE, rubber banding will allow
	// the user to select multiple rows by dragging the mouse.
	RubberBanding() bool
	// SearchColumn gets the column searched on by the interactive search code.
	SearchColumn() int
	// SearchEntry returns the Entry which is currently in use as interactive
	// search entry for @tree_view. In case the built-in entry is being used,
	// nil will be returned.
	SearchEntry() Editable
	// SearchEqualFunc returns the compare function currently in use.
	SearchEqualFunc() TreeViewSearchEqualFunc
	// Selection gets the TreeSelection associated with @tree_view.
	Selection() TreeSelection
	// ShowExpanders returns whether or not expanders are drawn in @tree_view.
	ShowExpanders() bool
	// TooltipColumn returns the column of @tree_view’s model which is being
	// used for displaying tooltips on @tree_view’s rows.
	TooltipColumn() int
	// TooltipContext: this function is supposed to be used in a
	// Widget::query-tooltip signal handler for TreeView. The @x, @y and
	// @keyboard_tip values which are received in the signal handler, should be
	// passed to this function without modification.
	//
	// The return value indicates whether there is a tree view row at the given
	// coordinates (true) or not (false) for mouse tooltips. For keyboard
	// tooltips the row returned will be the cursor row. When true, then any of
	// @model, @path and @iter which have been provided will be set to point to
	// that row and the corresponding model. @x and @y will always be converted
	// to be relative to @tree_view’s bin_window if @keyboard_tooltip is false.
	TooltipContext(x int, y int, keyboardTip bool) (model TreeModel, path *TreePath, iter TreeIter, ok bool)
	// VisibleRange sets @start_path and @end_path to be the first and last
	// visible path. Note that there may be invisible paths in between.
	//
	// The paths should be freed with gtk_tree_path_free() after use.
	VisibleRange() (startPath *TreePath, endPath *TreePath, ok bool)
	// VisibleRect fills @visible_rect with the currently-visible region of the
	// buffer, in tree coordinates. Convert to bin_window coordinates with
	// gtk_tree_view_convert_tree_to_bin_window_coords(). Tree coordinates start
	// at 0,0 for row 0 of the tree, and cover the entire scrollable area of the
	// tree.
	VisibleRect() gdk.Rectangle
	// InsertColumn: this inserts the @column into the @tree_view at @position.
	// If @position is -1, then the column is inserted at the end. If @tree_view
	// has “fixed_height” mode enabled, then @column must have its “sizing”
	// property set to be GTK_TREE_VIEW_COLUMN_FIXED.
	InsertColumn(column TreeViewColumn, position int) int
	// InsertColumnWithDataFunc: convenience function that inserts a new column
	// into the TreeView with the given cell renderer and a TreeCellDataFunc to
	// set cell renderer attributes (normally using data from the model). See
	// also gtk_tree_view_column_set_cell_data_func(),
	// gtk_tree_view_column_pack_start(). If @tree_view has “fixed_height” mode
	// enabled, then the new column will have its “sizing” property set to be
	// GTK_TREE_VIEW_COLUMN_FIXED.
	InsertColumnWithDataFunc(position int, title string, cell CellRenderer, _func TreeCellDataFunc) int
	// IsBlankAtPos: determine whether the point (@x, @y) in @tree_view is
	// blank, that is no cell content nor an expander arrow is drawn at the
	// location. If so, the location can be considered as the background. You
	// might wish to take special action on clicks on the background, such as
	// clearing a current selection, having a custom context menu or starting
	// rubber banding.
	//
	// The @x and @y coordinate that are provided must be relative to bin_window
	// coordinates. Widget-relative coordinates must be converted using
	// gtk_tree_view_convert_widget_to_bin_window_coords().
	//
	// For converting widget coordinates (eg. the ones you get from
	// GtkWidget::query-tooltip), please see
	// gtk_tree_view_convert_widget_to_bin_window_coords().
	//
	// The @path, @column, @cell_x and @cell_y arguments will be filled in
	// likewise as for gtk_tree_view_get_path_at_pos(). Please see
	// gtk_tree_view_get_path_at_pos() for more information.
	IsBlankAtPos(x int, y int) (path *TreePath, column TreeViewColumn, cellX int, cellY int, ok bool)
	// IsRubberBandingActive returns whether a rubber banding operation is
	// currently being done in @tree_view.
	IsRubberBandingActive() bool
	// MapExpandedRows calls @func on all expanded rows.
	MapExpandedRows(_func TreeViewMappingFunc)
	// MoveColumnAfter moves @column to be after to @base_column. If
	// @base_column is nil, then @column is placed in the first position.
	MoveColumnAfter(column TreeViewColumn, baseColumn TreeViewColumn)
	// RemoveColumn removes @column from @tree_view.
	RemoveColumn(column TreeViewColumn) int
	// RowActivated activates the cell determined by @path and @column.
	RowActivated(path *TreePath, column TreeViewColumn)
	// RowExpanded returns true if the node pointed to by @path is expanded in
	// @tree_view.
	RowExpanded(path *TreePath) bool
	// ScrollToCell moves the alignments of @tree_view to the position specified
	// by @column and @path. If @column is nil, then no horizontal scrolling
	// occurs. Likewise, if @path is nil no vertical scrolling occurs. At a
	// minimum, one of @column or @path need to be non-nil. @row_align
	// determines where the row is placed, and @col_align determines where
	// @column is placed. Both are expected to be between 0.0 and 1.0. 0.0 means
	// left/top alignment, 1.0 means right/bottom alignment, 0.5 means center.
	//
	// If @use_align is false, then the alignment arguments are ignored, and the
	// tree does the minimum amount of work to scroll the cell onto the screen.
	// This means that the cell will be scrolled to the edge closest to its
	// current position. If the cell is currently visible on the screen, nothing
	// is done.
	//
	// This function only works if the model is set, and @path is a valid row on
	// the model. If the model changes before the @tree_view is realized, the
	// centered path will be modified to reflect this change.
	ScrollToCell(path *TreePath, column TreeViewColumn, useAlign bool, rowAlign float32, colAlign float32)
	// ScrollToPoint scrolls the tree view such that the top-left corner of the
	// visible area is @tree_x, @tree_y, where @tree_x and @tree_y are specified
	// in tree coordinates. The @tree_view must be realized before this function
	// is called. If it isn't, you probably want to be using
	// gtk_tree_view_scroll_to_cell().
	//
	// If either @tree_x or @tree_y are -1, then that direction isn’t scrolled.
	ScrollToPoint(treeX int, treeY int)
	// SetActivateOnSingleClick: cause the TreeView::row-activated signal to be
	// emitted on a single click instead of a double click.
	SetActivateOnSingleClick(single bool)
	// SetColumnDragFunction sets a user function for determining where a column
	// may be dropped when dragged. This function is called on every column pair
	// in turn at the beginning of a column drag to determine where a drop can
	// take place. The arguments passed to @func are: the @tree_view, the
	// TreeViewColumn being dragged, the two TreeViewColumn s determining the
	// drop spot, and @user_data. If either of the TreeViewColumn arguments for
	// the drop spot are nil, then they indicate an edge. If @func is set to be
	// nil, then @tree_view reverts to the default behavior of allowing all
	// columns to be dropped everywhere.
	SetColumnDragFunction(_func TreeViewColumnDropFunc)
	// SetCursor sets the current keyboard focus to be at @path, and selects it.
	// This is useful when you want to focus the user’s attention on a
	// particular row. If @focus_column is not nil, then focus is given to the
	// column specified by it. Additionally, if @focus_column is specified, and
	// @start_editing is true, then editing should be started in the specified
	// cell. This function is often followed by @gtk_widget_grab_focus
	// (@tree_view) in order to give keyboard focus to the widget. Please note
	// that editing can only happen when the widget is realized.
	//
	// If @path is invalid for @model, the current cursor (if any) will be unset
	// and the function will return without failing.
	SetCursor(path *TreePath, focusColumn TreeViewColumn, startEditing bool)
	// SetCursorOnCell sets the current keyboard focus to be at @path, and
	// selects it. This is useful when you want to focus the user’s attention on
	// a particular row. If @focus_column is not nil, then focus is given to the
	// column specified by it. If @focus_column and @focus_cell are not nil, and
	// @focus_column contains 2 or more editable or activatable cells, then
	// focus is given to the cell specified by @focus_cell. Additionally, if
	// @focus_column is specified, and @start_editing is true, then editing
	// should be started in the specified cell. This function is often followed
	// by @gtk_widget_grab_focus (@tree_view) in order to give keyboard focus to
	// the widget. Please note that editing can only happen when the widget is
	// realized.
	//
	// If @path is invalid for @model, the current cursor (if any) will be unset
	// and the function will return without failing.
	SetCursorOnCell(path *TreePath, focusColumn TreeViewColumn, focusCell CellRenderer, startEditing bool)
	// SetDragDestRow sets the row that is highlighted for feedback. If @path is
	// nil, an existing highlight is removed.
	SetDragDestRow(path *TreePath, pos TreeViewDropPosition)
	// SetEnableSearch: if @enable_search is set, then the user can type in text
	// to search through the tree interactively (this is sometimes called
	// "typeahead find").
	//
	// Note that even if this is false, the user can still initiate a search
	// using the “start-interactive-search” key binding.
	SetEnableSearch(enableSearch bool)
	// SetEnableTreeLines sets whether to draw lines interconnecting the
	// expanders in @tree_view. This does not have any visible effects for
	// lists.
	SetEnableTreeLines(enabled bool)
	// SetExpanderColumn sets the column to draw the expander arrow at. It must
	// be in @tree_view. If @column is nil, then the expander arrow is always at
	// the first visible column.
	//
	// If you do not want expander arrow to appear in your tree, set the
	// expander column to a hidden column.
	SetExpanderColumn(column TreeViewColumn)
	// SetFixedHeightMode enables or disables the fixed height mode of
	// @tree_view. Fixed height mode speeds up TreeView by assuming that all
	// rows have the same height. Only enable this option if all rows are the
	// same height and all columns are of type GTK_TREE_VIEW_COLUMN_FIXED.
	SetFixedHeightMode(enable bool)
	// SetGridLines sets which grid lines to draw in @tree_view.
	SetGridLines(gridLines TreeViewGridLines)
	// SetHeadersClickable: allow the column title buttons to be clicked.
	SetHeadersClickable(setting bool)
	// SetHeadersVisible sets the visibility state of the headers.
	SetHeadersVisible(headersVisible bool)
	// SetHoverExpand enables or disables the hover expansion mode of
	// @tree_view. Hover expansion makes rows expand or collapse if the pointer
	// moves over them.
	SetHoverExpand(expand bool)
	// SetHoverSelection enables or disables the hover selection mode of
	// @tree_view. Hover selection makes the selected row follow the pointer.
	// Currently, this works only for the selection modes GTK_SELECTION_SINGLE
	// and GTK_SELECTION_BROWSE.
	SetHoverSelection(hover bool)
	// SetLevelIndentation sets the amount of extra indentation for child levels
	// to use in @tree_view in addition to the default indentation. The value
	// should be specified in pixels, a value of 0 disables this feature and in
	// this case only the default indentation will be used. This does not have
	// any visible effects for lists.
	SetLevelIndentation(indentation int)
	// SetModel sets the model for a TreeView. If the @tree_view already has a
	// model set, it will remove it before setting the new model. If @model is
	// nil, then it will unset the old model.
	SetModel(model TreeModel)
	// SetReorderable: this function is a convenience function to allow you to
	// reorder models that support the TreeDragSourceIface and the
	// TreeDragDestIface. Both TreeStore and ListStore support these. If
	// @reorderable is true, then the user can reorder the model by dragging and
	// dropping rows. The developer can listen to these changes by connecting to
	// the model’s TreeModel::row-inserted and TreeModel::row-deleted signals.
	// The reordering is implemented by setting up the tree view as a drag
	// source and destination. Therefore, drag and drop can not be used in a
	// reorderable view for any other purpose.
	//
	// This function does not give you any degree of control over the order --
	// any reordering is allowed. If more control is needed, you should probably
	// handle drag and drop manually.
	SetReorderable(reorderable bool)
	// SetRowSeparatorFunc sets the row separator function, which is used to
	// determine whether a row should be drawn as a separator. If the row
	// separator function is nil, no separators are drawn. This is the default
	// value.
	SetRowSeparatorFunc(_func TreeViewRowSeparatorFunc)
	// SetRubberBanding enables or disables rubber banding in @tree_view. If the
	// selection mode is K_SELECTION_MULTIPLE, rubber banding will allow the
	// user to select multiple rows by dragging the mouse.
	SetRubberBanding(enable bool)
	// SetSearchColumn sets @column as the column where the interactive search
	// code should search in for the current model.
	//
	// If the search column is set, users can use the “start-interactive-search”
	// key binding to bring up search popup. The enable-search property controls
	// whether simply typing text will also start an interactive search.
	//
	// Note that @column refers to a column of the current model. The search
	// column is reset to -1 when the model is changed.
	SetSearchColumn(column int)
	// SetSearchEntry sets the entry which the interactive search code will use
	// for this @tree_view. This is useful when you want to provide a search
	// entry in our interface at all time at a fixed position. Passing nil for
	// @entry will make the interactive search code use the built-in popup entry
	// again.
	SetSearchEntry(entry Editable)
	// SetSearchEqualFunc sets the compare function for the interactive search
	// capabilities; note that somewhat like strcmp() returning 0 for equality
	// TreeViewSearchEqualFunc returns false on matches.
	SetSearchEqualFunc(searchEqualFunc TreeViewSearchEqualFunc)
	// SetShowExpanders sets whether to draw and enable expanders and indent
	// child rows in @tree_view. When disabled there will be no expanders
	// visible in trees and there will be no way to expand and collapse rows by
	// default. Also note that hiding the expanders will disable the default
	// indentation. You can set a custom indentation in this case using
	// gtk_tree_view_set_level_indentation(). This does not have any visible
	// effects for lists.
	SetShowExpanders(enabled bool)
	// SetTooltipCell sets the tip area of @tooltip to the area @path, @column
	// and @cell have in common. For example if @path is nil and @column is set,
	// the tip area will be set to the full area covered by @column. See also
	// gtk_tooltip_set_tip_area().
	//
	// Note that if @path is not specified and @cell is set and part of a column
	// containing the expander, the tooltip might not show and hide at the
	// correct position. In such cases @path must be set to the current node
	// under the mouse cursor for this function to operate correctly.
	//
	// See also gtk_tree_view_set_tooltip_column() for a simpler alternative.
	SetTooltipCell(tooltip Tooltip, path *TreePath, column TreeViewColumn, cell CellRenderer)
	// SetTooltipColumn: if you only plan to have simple (text-only) tooltips on
	// full rows, you can use this function to have TreeView handle these
	// automatically for you. @column should be set to the column in
	// @tree_view’s model containing the tooltip texts, or -1 to disable this
	// feature.
	//
	// When enabled, Widget:has-tooltip will be set to true and @tree_view will
	// connect a Widget::query-tooltip signal handler.
	//
	// Note that the signal handler sets the text with gtk_tooltip_set_markup(),
	// so &, <, etc have to be escaped in the text.
	SetTooltipColumn(column int)
	// SetTooltipRow sets the tip area of @tooltip to be the area covered by the
	// row at @path. See also gtk_tree_view_set_tooltip_column() for a simpler
	// alternative. See also gtk_tooltip_set_tip_area().
	SetTooltipRow(tooltip Tooltip, path *TreePath)
	// UnsetRowsDragDest undoes the effect of
	// gtk_tree_view_enable_model_drag_dest(). Calling this method sets
	// TreeView:reorderable to false.
	UnsetRowsDragDest()
	// UnsetRowsDragSource undoes the effect of
	// gtk_tree_view_enable_model_drag_source(). Calling this method sets
	// TreeView:reorderable to false.
	UnsetRowsDragSource()
}

type treeView struct {
	widget
}

// WrapTreeView wraps a GObject to the right type. It is
// primarily used internally.
func WrapTreeView(obj *externglib.Object) TreeView {
	return treeView{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}
}

func marshalTreeView(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTreeView(obj), nil
}

// NewTreeView constructs a class TreeView.
func NewTreeView() TreeView {

	ret := C.gtk_tree_view_new()

	var ret0 TreeView

	ret0 = WrapTreeView(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewTreeViewWithModel constructs a class TreeView.
func NewTreeViewWithModel(model TreeModel) TreeView {
	var arg1 *C.GtkTreeModel

	ret := C.gtk_tree_view_new_with_model(arg1)

	var ret0 TreeView

	ret0 = WrapTreeView(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// AppendColumn appends @column to the list of columns. If @tree_view has
// “fixed_height” mode enabled, then @column must have its “sizing” property
// set to be GTK_TREE_VIEW_COLUMN_FIXED.
func (treeView treeView) AppendColumn(column TreeViewColumn) int {
	var arg0 *C.GtkTreeView
	var arg1 *C.GtkTreeViewColumn

	arg0 = (*C.GtkTreeView)(treeView.Native())
	arg1 = (*C.GtkTreeViewColumn)(column.Native())

	ret := C.gtk_tree_view_append_column(arg0, arg1)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// CollapseAll: recursively collapses all visible, expanded nodes in
// @tree_view.
func (treeView treeView) CollapseAll() {
	var arg0 *C.GtkTreeView

	arg0 = (*C.GtkTreeView)(treeView.Native())

	C.gtk_tree_view_collapse_all(arg0)
}

// CollapseRow collapses a row (hides its child rows, if they exist).
func (treeView treeView) CollapseRow(path *TreePath) bool {
	var arg0 *C.GtkTreeView
	var arg1 *C.GtkTreePath

	arg0 = (*C.GtkTreeView)(treeView.Native())
	arg1 = (*C.GtkTreePath)(path.Native())

	ret := C.gtk_tree_view_collapse_row(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// ColumnsAutosize resizes all columns to their optimal width. Only works
// after the treeview has been realized.
func (treeView treeView) ColumnsAutosize() {
	var arg0 *C.GtkTreeView

	arg0 = (*C.GtkTreeView)(treeView.Native())

	C.gtk_tree_view_columns_autosize(arg0)
}

// ConvertBinWindowToTreeCoords converts bin_window coordinates to
// coordinates for the tree (the full scrollable area of the tree).
func (treeView treeView) ConvertBinWindowToTreeCoords(bx int, by int) (tx int, ty int) {
	var arg0 *C.GtkTreeView
	var arg1 C.int
	var arg2 C.int
	var arg3 *C.int // out
	var arg4 *C.int // out

	arg0 = (*C.GtkTreeView)(treeView.Native())
	arg1 = C.int(bx)
	arg2 = C.int(by)

	ret := C.gtk_tree_view_convert_bin_window_to_tree_coords(arg0, arg1, arg2, &arg3, &arg4)

	var ret0 int
	var ret1 int

	ret0 = int(arg3)

	ret1 = int(arg4)

	return ret0, ret1
}

// ConvertBinWindowToWidgetCoords converts bin_window coordinates to widget
// relative coordinates.
func (treeView treeView) ConvertBinWindowToWidgetCoords(bx int, by int) (wx int, wy int) {
	var arg0 *C.GtkTreeView
	var arg1 C.int
	var arg2 C.int
	var arg3 *C.int // out
	var arg4 *C.int // out

	arg0 = (*C.GtkTreeView)(treeView.Native())
	arg1 = C.int(bx)
	arg2 = C.int(by)

	ret := C.gtk_tree_view_convert_bin_window_to_widget_coords(arg0, arg1, arg2, &arg3, &arg4)

	var ret0 int
	var ret1 int

	ret0 = int(arg3)

	ret1 = int(arg4)

	return ret0, ret1
}

// ConvertTreeToBinWindowCoords converts tree coordinates (coordinates in
// full scrollable area of the tree) to bin_window coordinates.
func (treeView treeView) ConvertTreeToBinWindowCoords(tx int, ty int) (bx int, by int) {
	var arg0 *C.GtkTreeView
	var arg1 C.int
	var arg2 C.int
	var arg3 *C.int // out
	var arg4 *C.int // out

	arg0 = (*C.GtkTreeView)(treeView.Native())
	arg1 = C.int(tx)
	arg2 = C.int(ty)

	ret := C.gtk_tree_view_convert_tree_to_bin_window_coords(arg0, arg1, arg2, &arg3, &arg4)

	var ret0 int
	var ret1 int

	ret0 = int(arg3)

	ret1 = int(arg4)

	return ret0, ret1
}

// ConvertTreeToWidgetCoords converts tree coordinates (coordinates in full
// scrollable area of the tree) to widget coordinates.
func (treeView treeView) ConvertTreeToWidgetCoords(tx int, ty int) (wx int, wy int) {
	var arg0 *C.GtkTreeView
	var arg1 C.int
	var arg2 C.int
	var arg3 *C.int // out
	var arg4 *C.int // out

	arg0 = (*C.GtkTreeView)(treeView.Native())
	arg1 = C.int(tx)
	arg2 = C.int(ty)

	ret := C.gtk_tree_view_convert_tree_to_widget_coords(arg0, arg1, arg2, &arg3, &arg4)

	var ret0 int
	var ret1 int

	ret0 = int(arg3)

	ret1 = int(arg4)

	return ret0, ret1
}

// ConvertWidgetToBinWindowCoords converts widget coordinates to coordinates
// for the bin_window.
func (treeView treeView) ConvertWidgetToBinWindowCoords(wx int, wy int) (bx int, by int) {
	var arg0 *C.GtkTreeView
	var arg1 C.int
	var arg2 C.int
	var arg3 *C.int // out
	var arg4 *C.int // out

	arg0 = (*C.GtkTreeView)(treeView.Native())
	arg1 = C.int(wx)
	arg2 = C.int(wy)

	ret := C.gtk_tree_view_convert_widget_to_bin_window_coords(arg0, arg1, arg2, &arg3, &arg4)

	var ret0 int
	var ret1 int

	ret0 = int(arg3)

	ret1 = int(arg4)

	return ret0, ret1
}

// ConvertWidgetToTreeCoords converts widget coordinates to coordinates for
// the tree (the full scrollable area of the tree).
func (treeView treeView) ConvertWidgetToTreeCoords(wx int, wy int) (tx int, ty int) {
	var arg0 *C.GtkTreeView
	var arg1 C.int
	var arg2 C.int
	var arg3 *C.int // out
	var arg4 *C.int // out

	arg0 = (*C.GtkTreeView)(treeView.Native())
	arg1 = C.int(wx)
	arg2 = C.int(wy)

	ret := C.gtk_tree_view_convert_widget_to_tree_coords(arg0, arg1, arg2, &arg3, &arg4)

	var ret0 int
	var ret1 int

	ret0 = int(arg3)

	ret1 = int(arg4)

	return ret0, ret1
}

// CreateRowDragIcon creates a #cairo_surface_t representation of the row at
// @path. This image is used for a drag icon.
func (treeView treeView) CreateRowDragIcon(path *TreePath) gdk.Paintable {
	var arg0 *C.GtkTreeView
	var arg1 *C.GtkTreePath

	arg0 = (*C.GtkTreeView)(treeView.Native())
	arg1 = (*C.GtkTreePath)(path.Native())

	ret := C.gtk_tree_view_create_row_drag_icon(arg0, arg1)

	var ret0 gdk.Paintable

	return ret0
}

// EnableModelDragDest turns @tree_view into a drop destination for
// automatic DND. Calling this method sets TreeView:reorderable to false.
func (treeView treeView) EnableModelDragDest(formats *gdk.ContentFormats, actions gdk.DragAction) {
	var arg0 *C.GtkTreeView
	var arg1 *C.GdkContentFormats
	var arg2 C.GdkDragAction

	arg0 = (*C.GtkTreeView)(treeView.Native())
	arg1 = (*C.GdkContentFormats)(formats.Native())
	arg2 = (C.GdkDragAction)(actions)

	C.gtk_tree_view_enable_model_drag_dest(arg0, arg1, arg2)
}

// EnableModelDragSource turns @tree_view into a drag source for automatic
// DND. Calling this method sets TreeView:reorderable to false.
func (treeView treeView) EnableModelDragSource(startButtonMask gdk.ModifierType, formats *gdk.ContentFormats, actions gdk.DragAction) {
	var arg0 *C.GtkTreeView
	var arg1 C.GdkModifierType
	var arg2 *C.GdkContentFormats
	var arg3 C.GdkDragAction

	arg0 = (*C.GtkTreeView)(treeView.Native())
	arg1 = (C.GdkModifierType)(startButtonMask)
	arg2 = (*C.GdkContentFormats)(formats.Native())
	arg3 = (C.GdkDragAction)(actions)

	C.gtk_tree_view_enable_model_drag_source(arg0, arg1, arg2, arg3)
}

// ExpandAll: recursively expands all nodes in the @tree_view.
func (treeView treeView) ExpandAll() {
	var arg0 *C.GtkTreeView

	arg0 = (*C.GtkTreeView)(treeView.Native())

	C.gtk_tree_view_expand_all(arg0)
}

// ExpandRow opens the row so its children are visible.
func (treeView treeView) ExpandRow(path *TreePath, openAll bool) bool {
	var arg0 *C.GtkTreeView
	var arg1 *C.GtkTreePath
	var arg2 C.gboolean

	arg0 = (*C.GtkTreeView)(treeView.Native())
	arg1 = (*C.GtkTreePath)(path.Native())
	arg2 = gextras.Cbool(openAll)

	ret := C.gtk_tree_view_expand_row(arg0, arg1, arg2)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// ExpandToPath expands the row at @path. This will also expand all parent
// rows of @path as necessary.
func (treeView treeView) ExpandToPath(path *TreePath) {
	var arg0 *C.GtkTreeView
	var arg1 *C.GtkTreePath

	arg0 = (*C.GtkTreeView)(treeView.Native())
	arg1 = (*C.GtkTreePath)(path.Native())

	C.gtk_tree_view_expand_to_path(arg0, arg1)
}

// ActivateOnSingleClick gets the setting set by
// gtk_tree_view_set_activate_on_single_click().
func (treeView treeView) ActivateOnSingleClick() bool {
	var arg0 *C.GtkTreeView

	arg0 = (*C.GtkTreeView)(treeView.Native())

	ret := C.gtk_tree_view_get_activate_on_single_click(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// BackgroundArea fills the bounding rectangle in bin_window coordinates for
// the cell at the row specified by @path and the column specified by
// @column. If @path is nil, or points to a node not found in the tree, the
// @y and @height fields of the rectangle will be filled with 0. If @column
// is nil, the @x and @width fields will be filled with 0. The returned
// rectangle is equivalent to the @background_area passed to
// gtk_cell_renderer_render(). These background areas tile to cover the
// entire bin window. Contrast with the @cell_area, returned by
// gtk_tree_view_get_cell_area(), which returns only the cell itself,
// excluding surrounding borders and the tree expander area.
func (treeView treeView) BackgroundArea(path *TreePath, column TreeViewColumn) gdk.Rectangle {
	var arg0 *C.GtkTreeView
	var arg1 *C.GtkTreePath
	var arg2 *C.GtkTreeViewColumn
	var arg3 *C.GdkRectangle // out

	arg0 = (*C.GtkTreeView)(treeView.Native())
	arg1 = (*C.GtkTreePath)(path.Native())
	arg2 = (*C.GtkTreeViewColumn)(column.Native())

	ret := C.gtk_tree_view_get_background_area(arg0, arg1, arg2, &arg3)

	var ret0 *gdk.Rectangle

	ret0 = gdk.WrapRectangle(arg3)

	return ret0
}

// CellArea fills the bounding rectangle in bin_window coordinates for the
// cell at the row specified by @path and the column specified by @column.
// If @path is nil, or points to a path not currently displayed, the @y and
// @height fields of the rectangle will be filled with 0. If @column is nil,
// the @x and @width fields will be filled with 0. The sum of all cell rects
// does not cover the entire tree; there are extra pixels in between rows,
// for example. The returned rectangle is equivalent to the @cell_area
// passed to gtk_cell_renderer_render(). This function is only valid if
// @tree_view is realized.
func (treeView treeView) CellArea(path *TreePath, column TreeViewColumn) gdk.Rectangle {
	var arg0 *C.GtkTreeView
	var arg1 *C.GtkTreePath
	var arg2 *C.GtkTreeViewColumn
	var arg3 *C.GdkRectangle // out

	arg0 = (*C.GtkTreeView)(treeView.Native())
	arg1 = (*C.GtkTreePath)(path.Native())
	arg2 = (*C.GtkTreeViewColumn)(column.Native())

	ret := C.gtk_tree_view_get_cell_area(arg0, arg1, arg2, &arg3)

	var ret0 *gdk.Rectangle

	ret0 = gdk.WrapRectangle(arg3)

	return ret0
}

// Column gets the TreeViewColumn at the given position in the #tree_view.
func (treeView treeView) Column(n int) TreeViewColumn {
	var arg0 *C.GtkTreeView
	var arg1 C.int

	arg0 = (*C.GtkTreeView)(treeView.Native())
	arg1 = C.int(n)

	ret := C.gtk_tree_view_get_column(arg0, arg1)

	var ret0 TreeViewColumn

	ret0 = WrapTreeViewColumn(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Columns returns a #GList of all the TreeViewColumn s currently in
// @tree_view. The returned list must be freed with g_list_free ().
func (treeView treeView) Columns() *glib.List {
	var arg0 *C.GtkTreeView

	arg0 = (*C.GtkTreeView)(treeView.Native())

	ret := C.gtk_tree_view_get_columns(arg0)

	var ret0 *glib.List

	ret0 = glib.WrapList(ret)

	return ret0
}

// Cursor fills in @path and @focus_column with the current path and focus
// column. If the cursor isn’t currently set, then *@path will be nil. If no
// column currently has focus, then *@focus_column will be nil.
//
// The returned TreePath must be freed with gtk_tree_path_free() when you
// are done with it.
func (treeView treeView) Cursor() (path *TreePath, focusColumn TreeViewColumn) {
	var arg0 *C.GtkTreeView
	var arg1 **C.GtkTreePath       // out
	var arg2 **C.GtkTreeViewColumn // out

	arg0 = (*C.GtkTreeView)(treeView.Native())

	ret := C.gtk_tree_view_get_cursor(arg0, &arg1, &arg2)

	var ret0 **TreePath
	var ret1 TreeViewColumn

	ret0 = WrapTreePath(arg1)

	ret1 = WrapTreeViewColumn(externglib.Take(unsafe.Pointer(arg2.Native())))

	return ret0, ret1
}

// DestRowAtPos determines the destination row for a given position. @drag_x
// and @drag_y are expected to be in widget coordinates. This function is
// only meaningful if @tree_view is realized. Therefore this function will
// always return false if @tree_view is not realized or does not have a
// model.
func (treeView treeView) DestRowAtPos(dragX int, dragY int) (path *TreePath, pos TreeViewDropPosition, ok bool) {
	var arg0 *C.GtkTreeView
	var arg1 C.int
	var arg2 C.int
	var arg3 **C.GtkTreePath            // out
	var arg4 *C.GtkTreeViewDropPosition // out

	arg0 = (*C.GtkTreeView)(treeView.Native())
	arg1 = C.int(dragX)
	arg2 = C.int(dragY)

	ret := C.gtk_tree_view_get_dest_row_at_pos(arg0, arg1, arg2, &arg3, &arg4)

	var ret0 **TreePath
	var ret1 *TreeViewDropPosition
	var ret2 bool

	ret0 = WrapTreePath(arg3)

	ret1 = (*TreeViewDropPosition)(arg4)

	ret2 = gextras.Gobool(ret)

	return ret0, ret1, ret2
}

// DragDestRow gets information about the row that is highlighted for
// feedback.
func (treeView treeView) DragDestRow() (path *TreePath, pos TreeViewDropPosition) {
	var arg0 *C.GtkTreeView
	var arg1 **C.GtkTreePath            // out
	var arg2 *C.GtkTreeViewDropPosition // out

	arg0 = (*C.GtkTreeView)(treeView.Native())

	ret := C.gtk_tree_view_get_drag_dest_row(arg0, &arg1, &arg2)

	var ret0 **TreePath
	var ret1 *TreeViewDropPosition

	ret0 = WrapTreePath(arg1)

	ret1 = (*TreeViewDropPosition)(arg2)

	return ret0, ret1
}

// EnableSearch returns whether or not the tree allows to start interactive
// searching by typing in text.
func (treeView treeView) EnableSearch() bool {
	var arg0 *C.GtkTreeView

	arg0 = (*C.GtkTreeView)(treeView.Native())

	ret := C.gtk_tree_view_get_enable_search(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// EnableTreeLines returns whether or not tree lines are drawn in
// @tree_view.
func (treeView treeView) EnableTreeLines() bool {
	var arg0 *C.GtkTreeView

	arg0 = (*C.GtkTreeView)(treeView.Native())

	ret := C.gtk_tree_view_get_enable_tree_lines(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// ExpanderColumn returns the column that is the current expander column, or
// nil if none has been set. This column has the expander arrow drawn next
// to it.
func (treeView treeView) ExpanderColumn() TreeViewColumn {
	var arg0 *C.GtkTreeView

	arg0 = (*C.GtkTreeView)(treeView.Native())

	ret := C.gtk_tree_view_get_expander_column(arg0)

	var ret0 TreeViewColumn

	ret0 = WrapTreeViewColumn(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// FixedHeightMode returns whether fixed height mode is turned on for
// @tree_view.
func (treeView treeView) FixedHeightMode() bool {
	var arg0 *C.GtkTreeView

	arg0 = (*C.GtkTreeView)(treeView.Native())

	ret := C.gtk_tree_view_get_fixed_height_mode(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// GridLines returns which grid lines are enabled in @tree_view.
func (treeView treeView) GridLines() TreeViewGridLines {
	var arg0 *C.GtkTreeView

	arg0 = (*C.GtkTreeView)(treeView.Native())

	ret := C.gtk_tree_view_get_grid_lines(arg0)

	var ret0 TreeViewGridLines

	ret0 = TreeViewGridLines(ret)

	return ret0
}

// HeadersClickable returns whether all header columns are clickable.
func (treeView treeView) HeadersClickable() bool {
	var arg0 *C.GtkTreeView

	arg0 = (*C.GtkTreeView)(treeView.Native())

	ret := C.gtk_tree_view_get_headers_clickable(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// HeadersVisible returns true if the headers on the @tree_view are visible.
func (treeView treeView) HeadersVisible() bool {
	var arg0 *C.GtkTreeView

	arg0 = (*C.GtkTreeView)(treeView.Native())

	ret := C.gtk_tree_view_get_headers_visible(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// HoverExpand returns whether hover expansion mode is turned on for
// @tree_view.
func (treeView treeView) HoverExpand() bool {
	var arg0 *C.GtkTreeView

	arg0 = (*C.GtkTreeView)(treeView.Native())

	ret := C.gtk_tree_view_get_hover_expand(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// HoverSelection returns whether hover selection mode is turned on for
// @tree_view.
func (treeView treeView) HoverSelection() bool {
	var arg0 *C.GtkTreeView

	arg0 = (*C.GtkTreeView)(treeView.Native())

	ret := C.gtk_tree_view_get_hover_selection(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// LevelIndentation returns the amount, in pixels, of extra indentation for
// child levels in @tree_view.
func (treeView treeView) LevelIndentation() int {
	var arg0 *C.GtkTreeView

	arg0 = (*C.GtkTreeView)(treeView.Native())

	ret := C.gtk_tree_view_get_level_indentation(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Model returns the model the TreeView is based on. Returns nil if the
// model is unset.
func (treeView treeView) Model() TreeModel {
	var arg0 *C.GtkTreeView

	arg0 = (*C.GtkTreeView)(treeView.Native())

	ret := C.gtk_tree_view_get_model(arg0)

	var ret0 TreeModel

	return ret0
}

// NColumns queries the number of columns in the given @tree_view.
func (treeView treeView) NColumns() uint {
	var arg0 *C.GtkTreeView

	arg0 = (*C.GtkTreeView)(treeView.Native())

	ret := C.gtk_tree_view_get_n_columns(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// PathAtPos finds the path at the point (@x, @y), relative to bin_window
// coordinates. That is, @x and @y are relative to an events coordinates.
// Widget-relative coordinates must be converted using
// gtk_tree_view_convert_widget_to_bin_window_coords(). It is primarily for
// things like popup menus. If @path is non-nil, then it will be filled with
// the TreePath at that point. This path should be freed with
// gtk_tree_path_free(). If @column is non-nil, then it will be filled with
// the column at that point. @cell_x and @cell_y return the coordinates
// relative to the cell background (i.e. the @background_area passed to
// gtk_cell_renderer_render()). This function is only meaningful if
// @tree_view is realized. Therefore this function will always return false
// if @tree_view is not realized or does not have a model.
//
// For converting widget coordinates (eg. the ones you get from
// GtkWidget::query-tooltip), please see
// gtk_tree_view_convert_widget_to_bin_window_coords().
func (treeView treeView) PathAtPos(x int, y int) (path *TreePath, column TreeViewColumn, cellX int, cellY int, ok bool) {
	var arg0 *C.GtkTreeView
	var arg1 C.int
	var arg2 C.int
	var arg3 **C.GtkTreePath       // out
	var arg4 **C.GtkTreeViewColumn // out
	var arg5 *C.int                // out
	var arg6 *C.int                // out

	arg0 = (*C.GtkTreeView)(treeView.Native())
	arg1 = C.int(x)
	arg2 = C.int(y)

	ret := C.gtk_tree_view_get_path_at_pos(arg0, arg1, arg2, &arg3, &arg4, &arg5, &arg6)

	var ret0 **TreePath
	var ret1 TreeViewColumn
	var ret2 int
	var ret3 int
	var ret4 bool

	ret0 = WrapTreePath(arg3)

	ret1 = WrapTreeViewColumn(externglib.Take(unsafe.Pointer(arg4.Native())))

	ret2 = int(arg5)

	ret3 = int(arg6)

	ret4 = gextras.Gobool(ret)

	return ret0, ret1, ret2, ret3, ret4
}

// Reorderable retrieves whether the user can reorder the tree via
// drag-and-drop. See gtk_tree_view_set_reorderable().
func (treeView treeView) Reorderable() bool {
	var arg0 *C.GtkTreeView

	arg0 = (*C.GtkTreeView)(treeView.Native())

	ret := C.gtk_tree_view_get_reorderable(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// RowSeparatorFunc returns the current row separator function.
func (treeView treeView) RowSeparatorFunc() TreeViewRowSeparatorFunc {
	var arg0 *C.GtkTreeView

	arg0 = (*C.GtkTreeView)(treeView.Native())

	ret := C.gtk_tree_view_get_row_separator_func(arg0)

	var ret0 TreeViewRowSeparatorFunc

	return ret0
}

// RubberBanding returns whether rubber banding is turned on for @tree_view.
// If the selection mode is K_SELECTION_MULTIPLE, rubber banding will allow
// the user to select multiple rows by dragging the mouse.
func (treeView treeView) RubberBanding() bool {
	var arg0 *C.GtkTreeView

	arg0 = (*C.GtkTreeView)(treeView.Native())

	ret := C.gtk_tree_view_get_rubber_banding(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// SearchColumn gets the column searched on by the interactive search code.
func (treeView treeView) SearchColumn() int {
	var arg0 *C.GtkTreeView

	arg0 = (*C.GtkTreeView)(treeView.Native())

	ret := C.gtk_tree_view_get_search_column(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// SearchEntry returns the Entry which is currently in use as interactive
// search entry for @tree_view. In case the built-in entry is being used,
// nil will be returned.
func (treeView treeView) SearchEntry() Editable {
	var arg0 *C.GtkTreeView

	arg0 = (*C.GtkTreeView)(treeView.Native())

	ret := C.gtk_tree_view_get_search_entry(arg0)

	var ret0 Editable

	return ret0
}

// SearchEqualFunc returns the compare function currently in use.
func (treeView treeView) SearchEqualFunc() TreeViewSearchEqualFunc {
	var arg0 *C.GtkTreeView

	arg0 = (*C.GtkTreeView)(treeView.Native())

	ret := C.gtk_tree_view_get_search_equal_func(arg0)

	var ret0 TreeViewSearchEqualFunc

	return ret0
}

// Selection gets the TreeSelection associated with @tree_view.
func (treeView treeView) Selection() TreeSelection {
	var arg0 *C.GtkTreeView

	arg0 = (*C.GtkTreeView)(treeView.Native())

	ret := C.gtk_tree_view_get_selection(arg0)

	var ret0 TreeSelection

	ret0 = WrapTreeSelection(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// ShowExpanders returns whether or not expanders are drawn in @tree_view.
func (treeView treeView) ShowExpanders() bool {
	var arg0 *C.GtkTreeView

	arg0 = (*C.GtkTreeView)(treeView.Native())

	ret := C.gtk_tree_view_get_show_expanders(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// TooltipColumn returns the column of @tree_view’s model which is being
// used for displaying tooltips on @tree_view’s rows.
func (treeView treeView) TooltipColumn() int {
	var arg0 *C.GtkTreeView

	arg0 = (*C.GtkTreeView)(treeView.Native())

	ret := C.gtk_tree_view_get_tooltip_column(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// TooltipContext: this function is supposed to be used in a
// Widget::query-tooltip signal handler for TreeView. The @x, @y and
// @keyboard_tip values which are received in the signal handler, should be
// passed to this function without modification.
//
// The return value indicates whether there is a tree view row at the given
// coordinates (true) or not (false) for mouse tooltips. For keyboard
// tooltips the row returned will be the cursor row. When true, then any of
// @model, @path and @iter which have been provided will be set to point to
// that row and the corresponding model. @x and @y will always be converted
// to be relative to @tree_view’s bin_window if @keyboard_tooltip is false.
func (treeView treeView) TooltipContext(x int, y int, keyboardTip bool) (model TreeModel, path *TreePath, iter TreeIter, ok bool) {
	var arg0 *C.GtkTreeView
	var arg1 C.int
	var arg2 C.int
	var arg3 C.gboolean
	var arg4 **C.GtkTreeModel // out
	var arg5 **C.GtkTreePath  // out
	var arg6 *C.GtkTreeIter   // out

	arg0 = (*C.GtkTreeView)(treeView.Native())
	arg1 = C.int(x)
	arg2 = C.int(y)
	arg3 = gextras.Cbool(keyboardTip)

	ret := C.gtk_tree_view_get_tooltip_context(arg0, arg1, arg2, arg3, &arg4, &arg5, &arg6)

	var ret0 *TreeModel
	var ret1 **TreePath
	var ret2 *TreeIter
	var ret3 bool

	ret1 = WrapTreePath(arg5)

	ret2 = WrapTreeIter(arg6)

	ret3 = gextras.Gobool(ret)

	return ret0, ret1, ret2, ret3
}

// VisibleRange sets @start_path and @end_path to be the first and last
// visible path. Note that there may be invisible paths in between.
//
// The paths should be freed with gtk_tree_path_free() after use.
func (treeView treeView) VisibleRange() (startPath *TreePath, endPath *TreePath, ok bool) {
	var arg0 *C.GtkTreeView
	var arg1 **C.GtkTreePath // out
	var arg2 **C.GtkTreePath // out

	arg0 = (*C.GtkTreeView)(treeView.Native())

	ret := C.gtk_tree_view_get_visible_range(arg0, &arg1, &arg2)

	var ret0 **TreePath
	var ret1 **TreePath
	var ret2 bool

	ret0 = WrapTreePath(arg1)

	ret1 = WrapTreePath(arg2)

	ret2 = gextras.Gobool(ret)

	return ret0, ret1, ret2
}

// VisibleRect fills @visible_rect with the currently-visible region of the
// buffer, in tree coordinates. Convert to bin_window coordinates with
// gtk_tree_view_convert_tree_to_bin_window_coords(). Tree coordinates start
// at 0,0 for row 0 of the tree, and cover the entire scrollable area of the
// tree.
func (treeView treeView) VisibleRect() gdk.Rectangle {
	var arg0 *C.GtkTreeView
	var arg1 *C.GdkRectangle // out

	arg0 = (*C.GtkTreeView)(treeView.Native())

	ret := C.gtk_tree_view_get_visible_rect(arg0, &arg1)

	var ret0 *gdk.Rectangle

	ret0 = gdk.WrapRectangle(arg1)

	return ret0
}

// InsertColumn: this inserts the @column into the @tree_view at @position.
// If @position is -1, then the column is inserted at the end. If @tree_view
// has “fixed_height” mode enabled, then @column must have its “sizing”
// property set to be GTK_TREE_VIEW_COLUMN_FIXED.
func (treeView treeView) InsertColumn(column TreeViewColumn, position int) int {
	var arg0 *C.GtkTreeView
	var arg1 *C.GtkTreeViewColumn
	var arg2 C.int

	arg0 = (*C.GtkTreeView)(treeView.Native())
	arg1 = (*C.GtkTreeViewColumn)(column.Native())
	arg2 = C.int(position)

	ret := C.gtk_tree_view_insert_column(arg0, arg1, arg2)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// InsertColumnWithDataFunc: convenience function that inserts a new column
// into the TreeView with the given cell renderer and a TreeCellDataFunc to
// set cell renderer attributes (normally using data from the model). See
// also gtk_tree_view_column_set_cell_data_func(),
// gtk_tree_view_column_pack_start(). If @tree_view has “fixed_height” mode
// enabled, then the new column will have its “sizing” property set to be
// GTK_TREE_VIEW_COLUMN_FIXED.
func (treeView treeView) InsertColumnWithDataFunc(position int, title string, cell CellRenderer, _func TreeCellDataFunc) int {
	var arg0 *C.GtkTreeView
	var arg1 C.int
	var arg2 *C.char
	var arg3 *C.GtkCellRenderer
	var arg4 C.GtkTreeCellDataFunc
	arg5 := C.gpointer(box.Assign(data))

	arg0 = (*C.GtkTreeView)(treeView.Native())
	arg1 = C.int(position)
	arg2 = (*C.gchar)(C.CString(title))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.GtkCellRenderer)(cell.Native())
	arg4 = (*[0]byte)(C.gotk4_TreeCellDataFunc)

	ret := C.gtk_tree_view_insert_column_with_data_func(arg0, arg1, arg2, arg3, arg4, (*[0]byte)(C.callbackDelete))

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// IsBlankAtPos: determine whether the point (@x, @y) in @tree_view is
// blank, that is no cell content nor an expander arrow is drawn at the
// location. If so, the location can be considered as the background. You
// might wish to take special action on clicks on the background, such as
// clearing a current selection, having a custom context menu or starting
// rubber banding.
//
// The @x and @y coordinate that are provided must be relative to bin_window
// coordinates. Widget-relative coordinates must be converted using
// gtk_tree_view_convert_widget_to_bin_window_coords().
//
// For converting widget coordinates (eg. the ones you get from
// GtkWidget::query-tooltip), please see
// gtk_tree_view_convert_widget_to_bin_window_coords().
//
// The @path, @column, @cell_x and @cell_y arguments will be filled in
// likewise as for gtk_tree_view_get_path_at_pos(). Please see
// gtk_tree_view_get_path_at_pos() for more information.
func (treeView treeView) IsBlankAtPos(x int, y int) (path *TreePath, column TreeViewColumn, cellX int, cellY int, ok bool) {
	var arg0 *C.GtkTreeView
	var arg1 C.int
	var arg2 C.int
	var arg3 **C.GtkTreePath       // out
	var arg4 **C.GtkTreeViewColumn // out
	var arg5 *C.int                // out
	var arg6 *C.int                // out

	arg0 = (*C.GtkTreeView)(treeView.Native())
	arg1 = C.int(x)
	arg2 = C.int(y)

	ret := C.gtk_tree_view_is_blank_at_pos(arg0, arg1, arg2, &arg3, &arg4, &arg5, &arg6)

	var ret0 **TreePath
	var ret1 TreeViewColumn
	var ret2 int
	var ret3 int
	var ret4 bool

	ret0 = WrapTreePath(arg3)

	ret1 = WrapTreeViewColumn(externglib.Take(unsafe.Pointer(arg4.Native())))

	ret2 = int(arg5)

	ret3 = int(arg6)

	ret4 = gextras.Gobool(ret)

	return ret0, ret1, ret2, ret3, ret4
}

// IsRubberBandingActive returns whether a rubber banding operation is
// currently being done in @tree_view.
func (treeView treeView) IsRubberBandingActive() bool {
	var arg0 *C.GtkTreeView

	arg0 = (*C.GtkTreeView)(treeView.Native())

	ret := C.gtk_tree_view_is_rubber_banding_active(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// MapExpandedRows calls @func on all expanded rows.
func (treeView treeView) MapExpandedRows(_func TreeViewMappingFunc) {
	var arg0 *C.GtkTreeView
	var arg1 C.GtkTreeViewMappingFunc
	arg2 := C.gpointer(box.Assign(data))

	arg0 = (*C.GtkTreeView)(treeView.Native())
	arg1 = (*[0]byte)(C.gotk4_TreeViewMappingFunc)

	C.gtk_tree_view_map_expanded_rows(arg0, arg1)
}

// MoveColumnAfter moves @column to be after to @base_column. If
// @base_column is nil, then @column is placed in the first position.
func (treeView treeView) MoveColumnAfter(column TreeViewColumn, baseColumn TreeViewColumn) {
	var arg0 *C.GtkTreeView
	var arg1 *C.GtkTreeViewColumn
	var arg2 *C.GtkTreeViewColumn

	arg0 = (*C.GtkTreeView)(treeView.Native())
	arg1 = (*C.GtkTreeViewColumn)(column.Native())
	arg2 = (*C.GtkTreeViewColumn)(baseColumn.Native())

	C.gtk_tree_view_move_column_after(arg0, arg1, arg2)
}

// RemoveColumn removes @column from @tree_view.
func (treeView treeView) RemoveColumn(column TreeViewColumn) int {
	var arg0 *C.GtkTreeView
	var arg1 *C.GtkTreeViewColumn

	arg0 = (*C.GtkTreeView)(treeView.Native())
	arg1 = (*C.GtkTreeViewColumn)(column.Native())

	ret := C.gtk_tree_view_remove_column(arg0, arg1)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// RowActivated activates the cell determined by @path and @column.
func (treeView treeView) RowActivated(path *TreePath, column TreeViewColumn) {
	var arg0 *C.GtkTreeView
	var arg1 *C.GtkTreePath
	var arg2 *C.GtkTreeViewColumn

	arg0 = (*C.GtkTreeView)(treeView.Native())
	arg1 = (*C.GtkTreePath)(path.Native())
	arg2 = (*C.GtkTreeViewColumn)(column.Native())

	C.gtk_tree_view_row_activated(arg0, arg1, arg2)
}

// RowExpanded returns true if the node pointed to by @path is expanded in
// @tree_view.
func (treeView treeView) RowExpanded(path *TreePath) bool {
	var arg0 *C.GtkTreeView
	var arg1 *C.GtkTreePath

	arg0 = (*C.GtkTreeView)(treeView.Native())
	arg1 = (*C.GtkTreePath)(path.Native())

	ret := C.gtk_tree_view_row_expanded(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// ScrollToCell moves the alignments of @tree_view to the position specified
// by @column and @path. If @column is nil, then no horizontal scrolling
// occurs. Likewise, if @path is nil no vertical scrolling occurs. At a
// minimum, one of @column or @path need to be non-nil. @row_align
// determines where the row is placed, and @col_align determines where
// @column is placed. Both are expected to be between 0.0 and 1.0. 0.0 means
// left/top alignment, 1.0 means right/bottom alignment, 0.5 means center.
//
// If @use_align is false, then the alignment arguments are ignored, and the
// tree does the minimum amount of work to scroll the cell onto the screen.
// This means that the cell will be scrolled to the edge closest to its
// current position. If the cell is currently visible on the screen, nothing
// is done.
//
// This function only works if the model is set, and @path is a valid row on
// the model. If the model changes before the @tree_view is realized, the
// centered path will be modified to reflect this change.
func (treeView treeView) ScrollToCell(path *TreePath, column TreeViewColumn, useAlign bool, rowAlign float32, colAlign float32) {
	var arg0 *C.GtkTreeView
	var arg1 *C.GtkTreePath
	var arg2 *C.GtkTreeViewColumn
	var arg3 C.gboolean
	var arg4 C.float
	var arg5 C.float

	arg0 = (*C.GtkTreeView)(treeView.Native())
	arg1 = (*C.GtkTreePath)(path.Native())
	arg2 = (*C.GtkTreeViewColumn)(column.Native())
	arg3 = gextras.Cbool(useAlign)
	arg4 = C.float(rowAlign)
	arg5 = C.float(colAlign)

	C.gtk_tree_view_scroll_to_cell(arg0, arg1, arg2, arg3, arg4, arg5)
}

// ScrollToPoint scrolls the tree view such that the top-left corner of the
// visible area is @tree_x, @tree_y, where @tree_x and @tree_y are specified
// in tree coordinates. The @tree_view must be realized before this function
// is called. If it isn't, you probably want to be using
// gtk_tree_view_scroll_to_cell().
//
// If either @tree_x or @tree_y are -1, then that direction isn’t scrolled.
func (treeView treeView) ScrollToPoint(treeX int, treeY int) {
	var arg0 *C.GtkTreeView
	var arg1 C.int
	var arg2 C.int

	arg0 = (*C.GtkTreeView)(treeView.Native())
	arg1 = C.int(treeX)
	arg2 = C.int(treeY)

	C.gtk_tree_view_scroll_to_point(arg0, arg1, arg2)
}

// SetActivateOnSingleClick: cause the TreeView::row-activated signal to be
// emitted on a single click instead of a double click.
func (treeView treeView) SetActivateOnSingleClick(single bool) {
	var arg0 *C.GtkTreeView
	var arg1 C.gboolean

	arg0 = (*C.GtkTreeView)(treeView.Native())
	arg1 = gextras.Cbool(single)

	C.gtk_tree_view_set_activate_on_single_click(arg0, arg1)
}

// SetColumnDragFunction sets a user function for determining where a column
// may be dropped when dragged. This function is called on every column pair
// in turn at the beginning of a column drag to determine where a drop can
// take place. The arguments passed to @func are: the @tree_view, the
// TreeViewColumn being dragged, the two TreeViewColumn s determining the
// drop spot, and @user_data. If either of the TreeViewColumn arguments for
// the drop spot are nil, then they indicate an edge. If @func is set to be
// nil, then @tree_view reverts to the default behavior of allowing all
// columns to be dropped everywhere.
func (treeView treeView) SetColumnDragFunction(_func TreeViewColumnDropFunc) {
	var arg0 *C.GtkTreeView
	var arg1 C.GtkTreeViewColumnDropFunc
	arg2 := C.gpointer(box.Assign(userData))

	arg0 = (*C.GtkTreeView)(treeView.Native())
	arg1 = (*[0]byte)(C.gotk4_TreeViewColumnDropFunc)

	C.gtk_tree_view_set_column_drag_function(arg0, arg1, (*[0]byte)(C.callbackDelete))
}

// SetCursor sets the current keyboard focus to be at @path, and selects it.
// This is useful when you want to focus the user’s attention on a
// particular row. If @focus_column is not nil, then focus is given to the
// column specified by it. Additionally, if @focus_column is specified, and
// @start_editing is true, then editing should be started in the specified
// cell. This function is often followed by @gtk_widget_grab_focus
// (@tree_view) in order to give keyboard focus to the widget. Please note
// that editing can only happen when the widget is realized.
//
// If @path is invalid for @model, the current cursor (if any) will be unset
// and the function will return without failing.
func (treeView treeView) SetCursor(path *TreePath, focusColumn TreeViewColumn, startEditing bool) {
	var arg0 *C.GtkTreeView
	var arg1 *C.GtkTreePath
	var arg2 *C.GtkTreeViewColumn
	var arg3 C.gboolean

	arg0 = (*C.GtkTreeView)(treeView.Native())
	arg1 = (*C.GtkTreePath)(path.Native())
	arg2 = (*C.GtkTreeViewColumn)(focusColumn.Native())
	arg3 = gextras.Cbool(startEditing)

	C.gtk_tree_view_set_cursor(arg0, arg1, arg2, arg3)
}

// SetCursorOnCell sets the current keyboard focus to be at @path, and
// selects it. This is useful when you want to focus the user’s attention on
// a particular row. If @focus_column is not nil, then focus is given to the
// column specified by it. If @focus_column and @focus_cell are not nil, and
// @focus_column contains 2 or more editable or activatable cells, then
// focus is given to the cell specified by @focus_cell. Additionally, if
// @focus_column is specified, and @start_editing is true, then editing
// should be started in the specified cell. This function is often followed
// by @gtk_widget_grab_focus (@tree_view) in order to give keyboard focus to
// the widget. Please note that editing can only happen when the widget is
// realized.
//
// If @path is invalid for @model, the current cursor (if any) will be unset
// and the function will return without failing.
func (treeView treeView) SetCursorOnCell(path *TreePath, focusColumn TreeViewColumn, focusCell CellRenderer, startEditing bool) {
	var arg0 *C.GtkTreeView
	var arg1 *C.GtkTreePath
	var arg2 *C.GtkTreeViewColumn
	var arg3 *C.GtkCellRenderer
	var arg4 C.gboolean

	arg0 = (*C.GtkTreeView)(treeView.Native())
	arg1 = (*C.GtkTreePath)(path.Native())
	arg2 = (*C.GtkTreeViewColumn)(focusColumn.Native())
	arg3 = (*C.GtkCellRenderer)(focusCell.Native())
	arg4 = gextras.Cbool(startEditing)

	C.gtk_tree_view_set_cursor_on_cell(arg0, arg1, arg2, arg3, arg4)
}

// SetDragDestRow sets the row that is highlighted for feedback. If @path is
// nil, an existing highlight is removed.
func (treeView treeView) SetDragDestRow(path *TreePath, pos TreeViewDropPosition) {
	var arg0 *C.GtkTreeView
	var arg1 *C.GtkTreePath
	var arg2 C.GtkTreeViewDropPosition

	arg0 = (*C.GtkTreeView)(treeView.Native())
	arg1 = (*C.GtkTreePath)(path.Native())
	arg2 = (C.GtkTreeViewDropPosition)(pos)

	C.gtk_tree_view_set_drag_dest_row(arg0, arg1, arg2)
}

// SetEnableSearch: if @enable_search is set, then the user can type in text
// to search through the tree interactively (this is sometimes called
// "typeahead find").
//
// Note that even if this is false, the user can still initiate a search
// using the “start-interactive-search” key binding.
func (treeView treeView) SetEnableSearch(enableSearch bool) {
	var arg0 *C.GtkTreeView
	var arg1 C.gboolean

	arg0 = (*C.GtkTreeView)(treeView.Native())
	arg1 = gextras.Cbool(enableSearch)

	C.gtk_tree_view_set_enable_search(arg0, arg1)
}

// SetEnableTreeLines sets whether to draw lines interconnecting the
// expanders in @tree_view. This does not have any visible effects for
// lists.
func (treeView treeView) SetEnableTreeLines(enabled bool) {
	var arg0 *C.GtkTreeView
	var arg1 C.gboolean

	arg0 = (*C.GtkTreeView)(treeView.Native())
	arg1 = gextras.Cbool(enabled)

	C.gtk_tree_view_set_enable_tree_lines(arg0, arg1)
}

// SetExpanderColumn sets the column to draw the expander arrow at. It must
// be in @tree_view. If @column is nil, then the expander arrow is always at
// the first visible column.
//
// If you do not want expander arrow to appear in your tree, set the
// expander column to a hidden column.
func (treeView treeView) SetExpanderColumn(column TreeViewColumn) {
	var arg0 *C.GtkTreeView
	var arg1 *C.GtkTreeViewColumn

	arg0 = (*C.GtkTreeView)(treeView.Native())
	arg1 = (*C.GtkTreeViewColumn)(column.Native())

	C.gtk_tree_view_set_expander_column(arg0, arg1)
}

// SetFixedHeightMode enables or disables the fixed height mode of
// @tree_view. Fixed height mode speeds up TreeView by assuming that all
// rows have the same height. Only enable this option if all rows are the
// same height and all columns are of type GTK_TREE_VIEW_COLUMN_FIXED.
func (treeView treeView) SetFixedHeightMode(enable bool) {
	var arg0 *C.GtkTreeView
	var arg1 C.gboolean

	arg0 = (*C.GtkTreeView)(treeView.Native())
	arg1 = gextras.Cbool(enable)

	C.gtk_tree_view_set_fixed_height_mode(arg0, arg1)
}

// SetGridLines sets which grid lines to draw in @tree_view.
func (treeView treeView) SetGridLines(gridLines TreeViewGridLines) {
	var arg0 *C.GtkTreeView
	var arg1 C.GtkTreeViewGridLines

	arg0 = (*C.GtkTreeView)(treeView.Native())
	arg1 = (C.GtkTreeViewGridLines)(gridLines)

	C.gtk_tree_view_set_grid_lines(arg0, arg1)
}

// SetHeadersClickable: allow the column title buttons to be clicked.
func (treeView treeView) SetHeadersClickable(setting bool) {
	var arg0 *C.GtkTreeView
	var arg1 C.gboolean

	arg0 = (*C.GtkTreeView)(treeView.Native())
	arg1 = gextras.Cbool(setting)

	C.gtk_tree_view_set_headers_clickable(arg0, arg1)
}

// SetHeadersVisible sets the visibility state of the headers.
func (treeView treeView) SetHeadersVisible(headersVisible bool) {
	var arg0 *C.GtkTreeView
	var arg1 C.gboolean

	arg0 = (*C.GtkTreeView)(treeView.Native())
	arg1 = gextras.Cbool(headersVisible)

	C.gtk_tree_view_set_headers_visible(arg0, arg1)
}

// SetHoverExpand enables or disables the hover expansion mode of
// @tree_view. Hover expansion makes rows expand or collapse if the pointer
// moves over them.
func (treeView treeView) SetHoverExpand(expand bool) {
	var arg0 *C.GtkTreeView
	var arg1 C.gboolean

	arg0 = (*C.GtkTreeView)(treeView.Native())
	arg1 = gextras.Cbool(expand)

	C.gtk_tree_view_set_hover_expand(arg0, arg1)
}

// SetHoverSelection enables or disables the hover selection mode of
// @tree_view. Hover selection makes the selected row follow the pointer.
// Currently, this works only for the selection modes GTK_SELECTION_SINGLE
// and GTK_SELECTION_BROWSE.
func (treeView treeView) SetHoverSelection(hover bool) {
	var arg0 *C.GtkTreeView
	var arg1 C.gboolean

	arg0 = (*C.GtkTreeView)(treeView.Native())
	arg1 = gextras.Cbool(hover)

	C.gtk_tree_view_set_hover_selection(arg0, arg1)
}

// SetLevelIndentation sets the amount of extra indentation for child levels
// to use in @tree_view in addition to the default indentation. The value
// should be specified in pixels, a value of 0 disables this feature and in
// this case only the default indentation will be used. This does not have
// any visible effects for lists.
func (treeView treeView) SetLevelIndentation(indentation int) {
	var arg0 *C.GtkTreeView
	var arg1 C.int

	arg0 = (*C.GtkTreeView)(treeView.Native())
	arg1 = C.int(indentation)

	C.gtk_tree_view_set_level_indentation(arg0, arg1)
}

// SetModel sets the model for a TreeView. If the @tree_view already has a
// model set, it will remove it before setting the new model. If @model is
// nil, then it will unset the old model.
func (treeView treeView) SetModel(model TreeModel) {
	var arg0 *C.GtkTreeView
	var arg1 *C.GtkTreeModel

	arg0 = (*C.GtkTreeView)(treeView.Native())

	C.gtk_tree_view_set_model(arg0, arg1)
}

// SetReorderable: this function is a convenience function to allow you to
// reorder models that support the TreeDragSourceIface and the
// TreeDragDestIface. Both TreeStore and ListStore support these. If
// @reorderable is true, then the user can reorder the model by dragging and
// dropping rows. The developer can listen to these changes by connecting to
// the model’s TreeModel::row-inserted and TreeModel::row-deleted signals.
// The reordering is implemented by setting up the tree view as a drag
// source and destination. Therefore, drag and drop can not be used in a
// reorderable view for any other purpose.
//
// This function does not give you any degree of control over the order --
// any reordering is allowed. If more control is needed, you should probably
// handle drag and drop manually.
func (treeView treeView) SetReorderable(reorderable bool) {
	var arg0 *C.GtkTreeView
	var arg1 C.gboolean

	arg0 = (*C.GtkTreeView)(treeView.Native())
	arg1 = gextras.Cbool(reorderable)

	C.gtk_tree_view_set_reorderable(arg0, arg1)
}

// SetRowSeparatorFunc sets the row separator function, which is used to
// determine whether a row should be drawn as a separator. If the row
// separator function is nil, no separators are drawn. This is the default
// value.
func (treeView treeView) SetRowSeparatorFunc(_func TreeViewRowSeparatorFunc) {
	var arg0 *C.GtkTreeView
	var arg1 C.GtkTreeViewRowSeparatorFunc
	arg2 := C.gpointer(box.Assign(data))

	arg0 = (*C.GtkTreeView)(treeView.Native())
	arg1 = (*[0]byte)(C.gotk4_TreeViewRowSeparatorFunc)

	C.gtk_tree_view_set_row_separator_func(arg0, arg1, (*[0]byte)(C.callbackDelete))
}

// SetRubberBanding enables or disables rubber banding in @tree_view. If the
// selection mode is K_SELECTION_MULTIPLE, rubber banding will allow the
// user to select multiple rows by dragging the mouse.
func (treeView treeView) SetRubberBanding(enable bool) {
	var arg0 *C.GtkTreeView
	var arg1 C.gboolean

	arg0 = (*C.GtkTreeView)(treeView.Native())
	arg1 = gextras.Cbool(enable)

	C.gtk_tree_view_set_rubber_banding(arg0, arg1)
}

// SetSearchColumn sets @column as the column where the interactive search
// code should search in for the current model.
//
// If the search column is set, users can use the “start-interactive-search”
// key binding to bring up search popup. The enable-search property controls
// whether simply typing text will also start an interactive search.
//
// Note that @column refers to a column of the current model. The search
// column is reset to -1 when the model is changed.
func (treeView treeView) SetSearchColumn(column int) {
	var arg0 *C.GtkTreeView
	var arg1 C.int

	arg0 = (*C.GtkTreeView)(treeView.Native())
	arg1 = C.int(column)

	C.gtk_tree_view_set_search_column(arg0, arg1)
}

// SetSearchEntry sets the entry which the interactive search code will use
// for this @tree_view. This is useful when you want to provide a search
// entry in our interface at all time at a fixed position. Passing nil for
// @entry will make the interactive search code use the built-in popup entry
// again.
func (treeView treeView) SetSearchEntry(entry Editable) {
	var arg0 *C.GtkTreeView
	var arg1 *C.GtkEditable

	arg0 = (*C.GtkTreeView)(treeView.Native())

	C.gtk_tree_view_set_search_entry(arg0, arg1)
}

// SetSearchEqualFunc sets the compare function for the interactive search
// capabilities; note that somewhat like strcmp() returning 0 for equality
// TreeViewSearchEqualFunc returns false on matches.
func (treeView treeView) SetSearchEqualFunc(searchEqualFunc TreeViewSearchEqualFunc) {
	var arg0 *C.GtkTreeView
	var arg1 C.GtkTreeViewSearchEqualFunc
	arg2 := C.gpointer(box.Assign(searchUserData))

	arg0 = (*C.GtkTreeView)(treeView.Native())
	arg1 = (*[0]byte)(C.gotk4_TreeViewSearchEqualFunc)

	C.gtk_tree_view_set_search_equal_func(arg0, arg1, (*[0]byte)(C.callbackDelete))
}

// SetShowExpanders sets whether to draw and enable expanders and indent
// child rows in @tree_view. When disabled there will be no expanders
// visible in trees and there will be no way to expand and collapse rows by
// default. Also note that hiding the expanders will disable the default
// indentation. You can set a custom indentation in this case using
// gtk_tree_view_set_level_indentation(). This does not have any visible
// effects for lists.
func (treeView treeView) SetShowExpanders(enabled bool) {
	var arg0 *C.GtkTreeView
	var arg1 C.gboolean

	arg0 = (*C.GtkTreeView)(treeView.Native())
	arg1 = gextras.Cbool(enabled)

	C.gtk_tree_view_set_show_expanders(arg0, arg1)
}

// SetTooltipCell sets the tip area of @tooltip to the area @path, @column
// and @cell have in common. For example if @path is nil and @column is set,
// the tip area will be set to the full area covered by @column. See also
// gtk_tooltip_set_tip_area().
//
// Note that if @path is not specified and @cell is set and part of a column
// containing the expander, the tooltip might not show and hide at the
// correct position. In such cases @path must be set to the current node
// under the mouse cursor for this function to operate correctly.
//
// See also gtk_tree_view_set_tooltip_column() for a simpler alternative.
func (treeView treeView) SetTooltipCell(tooltip Tooltip, path *TreePath, column TreeViewColumn, cell CellRenderer) {
	var arg0 *C.GtkTreeView
	var arg1 *C.GtkTooltip
	var arg2 *C.GtkTreePath
	var arg3 *C.GtkTreeViewColumn
	var arg4 *C.GtkCellRenderer

	arg0 = (*C.GtkTreeView)(treeView.Native())
	arg1 = (*C.GtkTooltip)(tooltip.Native())
	arg2 = (*C.GtkTreePath)(path.Native())
	arg3 = (*C.GtkTreeViewColumn)(column.Native())
	arg4 = (*C.GtkCellRenderer)(cell.Native())

	C.gtk_tree_view_set_tooltip_cell(arg0, arg1, arg2, arg3, arg4)
}

// SetTooltipColumn: if you only plan to have simple (text-only) tooltips on
// full rows, you can use this function to have TreeView handle these
// automatically for you. @column should be set to the column in
// @tree_view’s model containing the tooltip texts, or -1 to disable this
// feature.
//
// When enabled, Widget:has-tooltip will be set to true and @tree_view will
// connect a Widget::query-tooltip signal handler.
//
// Note that the signal handler sets the text with gtk_tooltip_set_markup(),
// so &, <, etc have to be escaped in the text.
func (treeView treeView) SetTooltipColumn(column int) {
	var arg0 *C.GtkTreeView
	var arg1 C.int

	arg0 = (*C.GtkTreeView)(treeView.Native())
	arg1 = C.int(column)

	C.gtk_tree_view_set_tooltip_column(arg0, arg1)
}

// SetTooltipRow sets the tip area of @tooltip to be the area covered by the
// row at @path. See also gtk_tree_view_set_tooltip_column() for a simpler
// alternative. See also gtk_tooltip_set_tip_area().
func (treeView treeView) SetTooltipRow(tooltip Tooltip, path *TreePath) {
	var arg0 *C.GtkTreeView
	var arg1 *C.GtkTooltip
	var arg2 *C.GtkTreePath

	arg0 = (*C.GtkTreeView)(treeView.Native())
	arg1 = (*C.GtkTooltip)(tooltip.Native())
	arg2 = (*C.GtkTreePath)(path.Native())

	C.gtk_tree_view_set_tooltip_row(arg0, arg1, arg2)
}

// UnsetRowsDragDest undoes the effect of
// gtk_tree_view_enable_model_drag_dest(). Calling this method sets
// TreeView:reorderable to false.
func (treeView treeView) UnsetRowsDragDest() {
	var arg0 *C.GtkTreeView

	arg0 = (*C.GtkTreeView)(treeView.Native())

	C.gtk_tree_view_unset_rows_drag_dest(arg0)
}

// UnsetRowsDragSource undoes the effect of
// gtk_tree_view_enable_model_drag_source(). Calling this method sets
// TreeView:reorderable to false.
func (treeView treeView) UnsetRowsDragSource() {
	var arg0 *C.GtkTreeView

	arg0 = (*C.GtkTreeView)(treeView.Native())

	C.gtk_tree_view_unset_rows_drag_source(arg0)
}

// TreeViewColumn: the GtkTreeViewColumn object represents a visible column in a
// TreeView widget. It allows to set properties of the column header, and
// functions as a holding pen for the cell renderers which determine how the
// data in the column is displayed.
//
// Please refer to the [tree widget conceptual overview][TreeWidget] for an
// overview of all the objects and data types related to the tree widget and how
// they work together.
type TreeViewColumn interface {
	gextras.Objector

	// AddAttribute adds an attribute mapping to the list in @tree_column. The
	// @column is the column of the model to get a value from, and the
	// @attribute is the parameter on @cell_renderer to be set from the value.
	// So for example if column 2 of the model contains strings, you could have
	// the “text” attribute of a CellRendererText get its values from column 2.
	AddAttribute(cellRenderer CellRenderer, attribute string, column int)
	// CellGetPosition obtains the horizontal position and size of a cell in a
	// column. If the cell is not found in the column, @start_pos and @width are
	// not changed and false is returned.
	CellGetPosition(cellRenderer CellRenderer) (xOffset int, width int, ok bool)
	// CellGetSize obtains the width and height needed to render the column.
	// This is used primarily by the TreeView.
	CellGetSize() (xOffset int, yOffset int, width int, height int)
	// CellIsVisible returns true if any of the cells packed into the
	// @tree_column are visible. For this to be meaningful, you must first
	// initialize the cells with gtk_tree_view_column_cell_set_cell_data()
	CellIsVisible() bool
	// CellSetCellData sets the cell renderer based on the @tree_model and
	// @iter. That is, for every attribute mapping in @tree_column, it will get
	// a value from the set column on the @iter, and use that value to set the
	// attribute on the cell renderer. This is used primarily by the TreeView.
	CellSetCellData(treeModel TreeModel, iter *TreeIter, isExpander bool, isExpanded bool)
	// Clear unsets all the mappings on all renderers on the @tree_column.
	Clear()
	// ClearAttributes clears all existing attributes previously set with
	// gtk_tree_view_column_set_attributes().
	ClearAttributes(cellRenderer CellRenderer)
	// Clicked emits the “clicked” signal on the column. This function will only
	// work if @tree_column is clickable.
	Clicked()
	// FocusCell sets the current keyboard focus to be at @cell, if the column
	// contains 2 or more editable and activatable cells.
	FocusCell(cell CellRenderer)
	// Alignment returns the current x alignment of @tree_column. This value can
	// range between 0.0 and 1.0.
	Alignment() float32
	// Button returns the button used in the treeview column header
	Button() Widget
	// Clickable returns true if the user can click on the header for the
	// column.
	Clickable() bool
	// Expand returns true if the column expands to fill available space.
	Expand() bool
	// FixedWidth gets the fixed width of the column. This may not be the actual
	// displayed width of the column; for that, use
	// gtk_tree_view_column_get_width().
	FixedWidth() int
	// MaxWidth returns the maximum width in pixels of the @tree_column, or -1
	// if no maximum width is set.
	MaxWidth() int
	// MinWidth returns the minimum width in pixels of the @tree_column, or -1
	// if no minimum width is set.
	MinWidth() int
	// Reorderable returns true if the @tree_column can be reordered by the
	// user.
	Reorderable() bool
	// Resizable returns true if the @tree_column can be resized by the end
	// user.
	Resizable() bool
	// Sizing returns the current type of @tree_column.
	Sizing() TreeViewColumnSizing
	// SortColumnID gets the logical @sort_column_id that the model sorts on
	// when this column is selected for sorting. See
	// gtk_tree_view_column_set_sort_column_id().
	SortColumnID() int
	// SortIndicator gets the value set by
	// gtk_tree_view_column_set_sort_indicator().
	SortIndicator() bool
	// SortOrder gets the value set by gtk_tree_view_column_set_sort_order().
	SortOrder() SortType
	// Spacing returns the spacing of @tree_column.
	Spacing() int
	// Title returns the title of the widget.
	Title() string
	// TreeView returns the TreeView wherein @tree_column has been inserted. If
	// @column is currently not inserted in any tree view, nil is returned.
	TreeView() Widget
	// Visible returns true if @tree_column is visible.
	Visible() bool
	// Widget returns the Widget in the button on the column header. If a custom
	// widget has not been set then nil is returned.
	Widget() Widget
	// Width returns the current size of @tree_column in pixels.
	Width() int
	// XOffset returns the current X offset of @tree_column in pixels.
	XOffset() int
	// PackEnd adds the @cell to end of the column. If @expand is false, then
	// the @cell is allocated no more space than it needs. Any unused space is
	// divided evenly between cells for which @expand is true.
	PackEnd(cell CellRenderer, expand bool)
	// PackStart packs the @cell into the beginning of the column. If @expand is
	// false, then the @cell is allocated no more space than it needs. Any
	// unused space is divided evenly between cells for which @expand is true.
	PackStart(cell CellRenderer, expand bool)
	// QueueResize flags the column, and the cell renderers added to this
	// column, to have their sizes renegotiated.
	QueueResize()
	// SetAlignment sets the alignment of the title or custom widget inside the
	// column header. The alignment determines its location inside the button --
	// 0.0 for left, 0.5 for center, 1.0 for right.
	SetAlignment(xalign float32)
	// SetCellDataFunc sets the TreeCellDataFunc to use for the column. This
	// function is used instead of the standard attributes mapping for setting
	// the column value, and should set the value of @tree_column's cell
	// renderer as appropriate. @func may be nil to remove an older one.
	SetCellDataFunc(cellRenderer CellRenderer, _func TreeCellDataFunc)
	// SetClickable sets the header to be active if @clickable is true. When the
	// header is active, then it can take keyboard focus, and can be clicked.
	SetClickable(clickable bool)
	// SetExpand sets the column to take available extra space. This space is
	// shared equally amongst all columns that have the expand set to true. If
	// no column has this option set, then the last column gets all extra space.
	// By default, every column is created with this false.
	//
	// Along with “fixed-width”, the “expand” property changes when the column
	// is resized by the user.
	SetExpand(expand bool)
	// SetFixedWidth: if @fixed_width is not -1, sets the fixed width of
	// @tree_column; otherwise unsets it. The effective value of @fixed_width is
	// clamped between the minimum and maximum width of the column; however, the
	// value stored in the “fixed-width” property is not clamped. If the column
	// sizing is K_TREE_VIEW_COLUMN_GROW_ONLY or K_TREE_VIEW_COLUMN_AUTOSIZE,
	// setting a fixed width overrides the automatically calculated width. Note
	// that @fixed_width is only a hint to GTK; the width actually allocated to
	// the column may be greater or less than requested.
	//
	// Along with “expand”, the “fixed-width” property changes when the column
	// is resized by the user.
	SetFixedWidth(fixedWidth int)
	// SetMaxWidth sets the maximum width of the @tree_column. If @max_width is
	// -1, then the maximum width is unset. Note, the column can actually be
	// wider than max width if it’s the last column in a view. In this case, the
	// column expands to fill any extra space.
	SetMaxWidth(maxWidth int)
	// SetMinWidth sets the minimum width of the @tree_column. If @min_width is
	// -1, then the minimum width is unset.
	SetMinWidth(minWidth int)
	// SetReorderable: if @reorderable is true, then the column can be reordered
	// by the end user dragging the header.
	SetReorderable(reorderable bool)
	// SetResizable: if @resizable is true, then the user can explicitly resize
	// the column by grabbing the outer edge of the column button. If resizable
	// is true and sizing mode of the column is K_TREE_VIEW_COLUMN_AUTOSIZE,
	// then the sizing mode is changed to K_TREE_VIEW_COLUMN_GROW_ONLY.
	SetResizable(resizable bool)
	// SetSizing sets the growth behavior of @tree_column to @type.
	SetSizing(_type TreeViewColumnSizing)
	// SetSortColumnID sets the logical @sort_column_id that this column sorts
	// on when this column is selected for sorting. Doing so makes the column
	// header clickable.
	SetSortColumnID(sortColumnID int)
	// SetSortIndicator: call this function with a @setting of true to display
	// an arrow in the header button indicating the column is sorted. Call
	// gtk_tree_view_column_set_sort_order() to change the direction of the
	// arrow.
	SetSortIndicator(setting bool)
	// SetSortOrder changes the appearance of the sort indicator.
	//
	// This does not actually sort the model. Use
	// gtk_tree_view_column_set_sort_column_id() if you want automatic sorting
	// support. This function is primarily for custom sorting behavior, and
	// should be used in conjunction with gtk_tree_sortable_set_sort_column_id()
	// to do that. For custom models, the mechanism will vary.
	//
	// The sort indicator changes direction to indicate normal sort or reverse
	// sort. Note that you must have the sort indicator enabled to see anything
	// when calling this function; see
	// gtk_tree_view_column_set_sort_indicator().
	SetSortOrder(order SortType)
	// SetSpacing sets the spacing field of @tree_column, which is the number of
	// pixels to place between cell renderers packed into it.
	SetSpacing(spacing int)
	// SetTitle sets the title of the @tree_column. If a custom widget has been
	// set, then this value is ignored.
	SetTitle(title string)
	// SetVisible sets the visibility of @tree_column.
	SetVisible(visible bool)
	// SetWidget sets the widget in the header to be @widget. If widget is nil,
	// then the header button is set with a Label set to the title of
	// @tree_column.
	SetWidget(widget Widget)
}

type treeViewColumn struct {
	externglib.InitiallyUnowned
}

// WrapTreeViewColumn wraps a GObject to the right type. It is
// primarily used internally.
func WrapTreeViewColumn(obj *externglib.Object) TreeViewColumn {
	return treeViewColumn{externglib.InitiallyUnowned{*externglib.Object{obj}}}
}

func marshalTreeViewColumn(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTreeViewColumn(obj), nil
}

// NewTreeViewColumn constructs a class TreeViewColumn.
func NewTreeViewColumn() TreeViewColumn {

	ret := C.gtk_tree_view_column_new()

	var ret0 TreeViewColumn

	ret0 = WrapTreeViewColumn(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewTreeViewColumnWithArea constructs a class TreeViewColumn.
func NewTreeViewColumnWithArea(area CellArea) TreeViewColumn {
	var arg1 *C.GtkCellArea

	arg1 = (*C.GtkCellArea)(area.Native())

	ret := C.gtk_tree_view_column_new_with_area(arg1)

	var ret0 TreeViewColumn

	ret0 = WrapTreeViewColumn(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// AddAttribute adds an attribute mapping to the list in @tree_column. The
// @column is the column of the model to get a value from, and the
// @attribute is the parameter on @cell_renderer to be set from the value.
// So for example if column 2 of the model contains strings, you could have
// the “text” attribute of a CellRendererText get its values from column 2.
func (treeColumn treeViewColumn) AddAttribute(cellRenderer CellRenderer, attribute string, column int) {
	var arg0 *C.GtkTreeViewColumn
	var arg1 *C.GtkCellRenderer
	var arg2 *C.char
	var arg3 C.int

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())
	arg1 = (*C.GtkCellRenderer)(cellRenderer.Native())
	arg2 = (*C.gchar)(C.CString(attribute))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = C.int(column)

	C.gtk_tree_view_column_add_attribute(arg0, arg1, arg2, arg3)
}

// CellGetPosition obtains the horizontal position and size of a cell in a
// column. If the cell is not found in the column, @start_pos and @width are
// not changed and false is returned.
func (treeColumn treeViewColumn) CellGetPosition(cellRenderer CellRenderer) (xOffset int, width int, ok bool) {
	var arg0 *C.GtkTreeViewColumn
	var arg1 *C.GtkCellRenderer
	var arg2 *C.int // out
	var arg3 *C.int // out

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())
	arg1 = (*C.GtkCellRenderer)(cellRenderer.Native())

	ret := C.gtk_tree_view_column_cell_get_position(arg0, arg1, &arg2, &arg3)

	var ret0 int
	var ret1 int
	var ret2 bool

	ret0 = int(arg2)

	ret1 = int(arg3)

	ret2 = gextras.Gobool(ret)

	return ret0, ret1, ret2
}

// CellGetSize obtains the width and height needed to render the column.
// This is used primarily by the TreeView.
func (treeColumn treeViewColumn) CellGetSize() (xOffset int, yOffset int, width int, height int) {
	var arg0 *C.GtkTreeViewColumn
	var arg1 *C.int // out
	var arg2 *C.int // out
	var arg3 *C.int // out
	var arg4 *C.int // out

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())

	ret := C.gtk_tree_view_column_cell_get_size(arg0, &arg1, &arg2, &arg3, &arg4)

	var ret0 int
	var ret1 int
	var ret2 int
	var ret3 int

	ret0 = int(arg1)

	ret1 = int(arg2)

	ret2 = int(arg3)

	ret3 = int(arg4)

	return ret0, ret1, ret2, ret3
}

// CellIsVisible returns true if any of the cells packed into the
// @tree_column are visible. For this to be meaningful, you must first
// initialize the cells with gtk_tree_view_column_cell_set_cell_data()
func (treeColumn treeViewColumn) CellIsVisible() bool {
	var arg0 *C.GtkTreeViewColumn

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())

	ret := C.gtk_tree_view_column_cell_is_visible(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// CellSetCellData sets the cell renderer based on the @tree_model and
// @iter. That is, for every attribute mapping in @tree_column, it will get
// a value from the set column on the @iter, and use that value to set the
// attribute on the cell renderer. This is used primarily by the TreeView.
func (treeColumn treeViewColumn) CellSetCellData(treeModel TreeModel, iter *TreeIter, isExpander bool, isExpanded bool) {
	var arg0 *C.GtkTreeViewColumn
	var arg1 *C.GtkTreeModel
	var arg2 *C.GtkTreeIter
	var arg3 C.gboolean
	var arg4 C.gboolean

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())
	arg2 = (*C.GtkTreeIter)(iter.Native())
	arg3 = gextras.Cbool(isExpander)
	arg4 = gextras.Cbool(isExpanded)

	C.gtk_tree_view_column_cell_set_cell_data(arg0, arg1, arg2, arg3, arg4)
}

// Clear unsets all the mappings on all renderers on the @tree_column.
func (treeColumn treeViewColumn) Clear() {
	var arg0 *C.GtkTreeViewColumn

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())

	C.gtk_tree_view_column_clear(arg0)
}

// ClearAttributes clears all existing attributes previously set with
// gtk_tree_view_column_set_attributes().
func (treeColumn treeViewColumn) ClearAttributes(cellRenderer CellRenderer) {
	var arg0 *C.GtkTreeViewColumn
	var arg1 *C.GtkCellRenderer

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())
	arg1 = (*C.GtkCellRenderer)(cellRenderer.Native())

	C.gtk_tree_view_column_clear_attributes(arg0, arg1)
}

// Clicked emits the “clicked” signal on the column. This function will only
// work if @tree_column is clickable.
func (treeColumn treeViewColumn) Clicked() {
	var arg0 *C.GtkTreeViewColumn

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())

	C.gtk_tree_view_column_clicked(arg0)
}

// FocusCell sets the current keyboard focus to be at @cell, if the column
// contains 2 or more editable and activatable cells.
func (treeColumn treeViewColumn) FocusCell(cell CellRenderer) {
	var arg0 *C.GtkTreeViewColumn
	var arg1 *C.GtkCellRenderer

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())
	arg1 = (*C.GtkCellRenderer)(cell.Native())

	C.gtk_tree_view_column_focus_cell(arg0, arg1)
}

// Alignment returns the current x alignment of @tree_column. This value can
// range between 0.0 and 1.0.
func (treeColumn treeViewColumn) Alignment() float32 {
	var arg0 *C.GtkTreeViewColumn

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())

	ret := C.gtk_tree_view_column_get_alignment(arg0)

	var ret0 float32

	ret0 = float32(ret)

	return ret0
}

// Button returns the button used in the treeview column header
func (treeColumn treeViewColumn) Button() Widget {
	var arg0 *C.GtkTreeViewColumn

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())

	ret := C.gtk_tree_view_column_get_button(arg0)

	var ret0 Widget

	ret0 = WrapWidget(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Clickable returns true if the user can click on the header for the
// column.
func (treeColumn treeViewColumn) Clickable() bool {
	var arg0 *C.GtkTreeViewColumn

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())

	ret := C.gtk_tree_view_column_get_clickable(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Expand returns true if the column expands to fill available space.
func (treeColumn treeViewColumn) Expand() bool {
	var arg0 *C.GtkTreeViewColumn

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())

	ret := C.gtk_tree_view_column_get_expand(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// FixedWidth gets the fixed width of the column. This may not be the actual
// displayed width of the column; for that, use
// gtk_tree_view_column_get_width().
func (treeColumn treeViewColumn) FixedWidth() int {
	var arg0 *C.GtkTreeViewColumn

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())

	ret := C.gtk_tree_view_column_get_fixed_width(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// MaxWidth returns the maximum width in pixels of the @tree_column, or -1
// if no maximum width is set.
func (treeColumn treeViewColumn) MaxWidth() int {
	var arg0 *C.GtkTreeViewColumn

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())

	ret := C.gtk_tree_view_column_get_max_width(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// MinWidth returns the minimum width in pixels of the @tree_column, or -1
// if no minimum width is set.
func (treeColumn treeViewColumn) MinWidth() int {
	var arg0 *C.GtkTreeViewColumn

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())

	ret := C.gtk_tree_view_column_get_min_width(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Reorderable returns true if the @tree_column can be reordered by the
// user.
func (treeColumn treeViewColumn) Reorderable() bool {
	var arg0 *C.GtkTreeViewColumn

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())

	ret := C.gtk_tree_view_column_get_reorderable(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Resizable returns true if the @tree_column can be resized by the end
// user.
func (treeColumn treeViewColumn) Resizable() bool {
	var arg0 *C.GtkTreeViewColumn

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())

	ret := C.gtk_tree_view_column_get_resizable(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Sizing returns the current type of @tree_column.
func (treeColumn treeViewColumn) Sizing() TreeViewColumnSizing {
	var arg0 *C.GtkTreeViewColumn

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())

	ret := C.gtk_tree_view_column_get_sizing(arg0)

	var ret0 TreeViewColumnSizing

	ret0 = TreeViewColumnSizing(ret)

	return ret0
}

// SortColumnID gets the logical @sort_column_id that the model sorts on
// when this column is selected for sorting. See
// gtk_tree_view_column_set_sort_column_id().
func (treeColumn treeViewColumn) SortColumnID() int {
	var arg0 *C.GtkTreeViewColumn

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())

	ret := C.gtk_tree_view_column_get_sort_column_id(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// SortIndicator gets the value set by
// gtk_tree_view_column_set_sort_indicator().
func (treeColumn treeViewColumn) SortIndicator() bool {
	var arg0 *C.GtkTreeViewColumn

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())

	ret := C.gtk_tree_view_column_get_sort_indicator(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// SortOrder gets the value set by gtk_tree_view_column_set_sort_order().
func (treeColumn treeViewColumn) SortOrder() SortType {
	var arg0 *C.GtkTreeViewColumn

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())

	ret := C.gtk_tree_view_column_get_sort_order(arg0)

	var ret0 SortType

	ret0 = SortType(ret)

	return ret0
}

// Spacing returns the spacing of @tree_column.
func (treeColumn treeViewColumn) Spacing() int {
	var arg0 *C.GtkTreeViewColumn

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())

	ret := C.gtk_tree_view_column_get_spacing(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Title returns the title of the widget.
func (treeColumn treeViewColumn) Title() string {
	var arg0 *C.GtkTreeViewColumn

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())

	ret := C.gtk_tree_view_column_get_title(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// TreeView returns the TreeView wherein @tree_column has been inserted. If
// @column is currently not inserted in any tree view, nil is returned.
func (treeColumn treeViewColumn) TreeView() Widget {
	var arg0 *C.GtkTreeViewColumn

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())

	ret := C.gtk_tree_view_column_get_tree_view(arg0)

	var ret0 Widget

	ret0 = WrapWidget(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Visible returns true if @tree_column is visible.
func (treeColumn treeViewColumn) Visible() bool {
	var arg0 *C.GtkTreeViewColumn

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())

	ret := C.gtk_tree_view_column_get_visible(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Widget returns the Widget in the button on the column header. If a custom
// widget has not been set then nil is returned.
func (treeColumn treeViewColumn) Widget() Widget {
	var arg0 *C.GtkTreeViewColumn

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())

	ret := C.gtk_tree_view_column_get_widget(arg0)

	var ret0 Widget

	ret0 = WrapWidget(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Width returns the current size of @tree_column in pixels.
func (treeColumn treeViewColumn) Width() int {
	var arg0 *C.GtkTreeViewColumn

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())

	ret := C.gtk_tree_view_column_get_width(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// XOffset returns the current X offset of @tree_column in pixels.
func (treeColumn treeViewColumn) XOffset() int {
	var arg0 *C.GtkTreeViewColumn

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())

	ret := C.gtk_tree_view_column_get_x_offset(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// PackEnd adds the @cell to end of the column. If @expand is false, then
// the @cell is allocated no more space than it needs. Any unused space is
// divided evenly between cells for which @expand is true.
func (treeColumn treeViewColumn) PackEnd(cell CellRenderer, expand bool) {
	var arg0 *C.GtkTreeViewColumn
	var arg1 *C.GtkCellRenderer
	var arg2 C.gboolean

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())
	arg1 = (*C.GtkCellRenderer)(cell.Native())
	arg2 = gextras.Cbool(expand)

	C.gtk_tree_view_column_pack_end(arg0, arg1, arg2)
}

// PackStart packs the @cell into the beginning of the column. If @expand is
// false, then the @cell is allocated no more space than it needs. Any
// unused space is divided evenly between cells for which @expand is true.
func (treeColumn treeViewColumn) PackStart(cell CellRenderer, expand bool) {
	var arg0 *C.GtkTreeViewColumn
	var arg1 *C.GtkCellRenderer
	var arg2 C.gboolean

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())
	arg1 = (*C.GtkCellRenderer)(cell.Native())
	arg2 = gextras.Cbool(expand)

	C.gtk_tree_view_column_pack_start(arg0, arg1, arg2)
}

// QueueResize flags the column, and the cell renderers added to this
// column, to have their sizes renegotiated.
func (treeColumn treeViewColumn) QueueResize() {
	var arg0 *C.GtkTreeViewColumn

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())

	C.gtk_tree_view_column_queue_resize(arg0)
}

// SetAlignment sets the alignment of the title or custom widget inside the
// column header. The alignment determines its location inside the button --
// 0.0 for left, 0.5 for center, 1.0 for right.
func (treeColumn treeViewColumn) SetAlignment(xalign float32) {
	var arg0 *C.GtkTreeViewColumn
	var arg1 C.float

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())
	arg1 = C.float(xalign)

	C.gtk_tree_view_column_set_alignment(arg0, arg1)
}

// SetCellDataFunc sets the TreeCellDataFunc to use for the column. This
// function is used instead of the standard attributes mapping for setting
// the column value, and should set the value of @tree_column's cell
// renderer as appropriate. @func may be nil to remove an older one.
func (treeColumn treeViewColumn) SetCellDataFunc(cellRenderer CellRenderer, _func TreeCellDataFunc) {
	var arg0 *C.GtkTreeViewColumn
	var arg1 *C.GtkCellRenderer
	var arg2 C.GtkTreeCellDataFunc
	arg3 := C.gpointer(box.Assign(funcData))

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())
	arg1 = (*C.GtkCellRenderer)(cellRenderer.Native())
	arg2 = (*[0]byte)(C.gotk4_TreeCellDataFunc)

	C.gtk_tree_view_column_set_cell_data_func(arg0, arg1, arg2, (*[0]byte)(C.callbackDelete))
}

// SetClickable sets the header to be active if @clickable is true. When the
// header is active, then it can take keyboard focus, and can be clicked.
func (treeColumn treeViewColumn) SetClickable(clickable bool) {
	var arg0 *C.GtkTreeViewColumn
	var arg1 C.gboolean

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())
	arg1 = gextras.Cbool(clickable)

	C.gtk_tree_view_column_set_clickable(arg0, arg1)
}

// SetExpand sets the column to take available extra space. This space is
// shared equally amongst all columns that have the expand set to true. If
// no column has this option set, then the last column gets all extra space.
// By default, every column is created with this false.
//
// Along with “fixed-width”, the “expand” property changes when the column
// is resized by the user.
func (treeColumn treeViewColumn) SetExpand(expand bool) {
	var arg0 *C.GtkTreeViewColumn
	var arg1 C.gboolean

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())
	arg1 = gextras.Cbool(expand)

	C.gtk_tree_view_column_set_expand(arg0, arg1)
}

// SetFixedWidth: if @fixed_width is not -1, sets the fixed width of
// @tree_column; otherwise unsets it. The effective value of @fixed_width is
// clamped between the minimum and maximum width of the column; however, the
// value stored in the “fixed-width” property is not clamped. If the column
// sizing is K_TREE_VIEW_COLUMN_GROW_ONLY or K_TREE_VIEW_COLUMN_AUTOSIZE,
// setting a fixed width overrides the automatically calculated width. Note
// that @fixed_width is only a hint to GTK; the width actually allocated to
// the column may be greater or less than requested.
//
// Along with “expand”, the “fixed-width” property changes when the column
// is resized by the user.
func (treeColumn treeViewColumn) SetFixedWidth(fixedWidth int) {
	var arg0 *C.GtkTreeViewColumn
	var arg1 C.int

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())
	arg1 = C.int(fixedWidth)

	C.gtk_tree_view_column_set_fixed_width(arg0, arg1)
}

// SetMaxWidth sets the maximum width of the @tree_column. If @max_width is
// -1, then the maximum width is unset. Note, the column can actually be
// wider than max width if it’s the last column in a view. In this case, the
// column expands to fill any extra space.
func (treeColumn treeViewColumn) SetMaxWidth(maxWidth int) {
	var arg0 *C.GtkTreeViewColumn
	var arg1 C.int

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())
	arg1 = C.int(maxWidth)

	C.gtk_tree_view_column_set_max_width(arg0, arg1)
}

// SetMinWidth sets the minimum width of the @tree_column. If @min_width is
// -1, then the minimum width is unset.
func (treeColumn treeViewColumn) SetMinWidth(minWidth int) {
	var arg0 *C.GtkTreeViewColumn
	var arg1 C.int

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())
	arg1 = C.int(minWidth)

	C.gtk_tree_view_column_set_min_width(arg0, arg1)
}

// SetReorderable: if @reorderable is true, then the column can be reordered
// by the end user dragging the header.
func (treeColumn treeViewColumn) SetReorderable(reorderable bool) {
	var arg0 *C.GtkTreeViewColumn
	var arg1 C.gboolean

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())
	arg1 = gextras.Cbool(reorderable)

	C.gtk_tree_view_column_set_reorderable(arg0, arg1)
}

// SetResizable: if @resizable is true, then the user can explicitly resize
// the column by grabbing the outer edge of the column button. If resizable
// is true and sizing mode of the column is K_TREE_VIEW_COLUMN_AUTOSIZE,
// then the sizing mode is changed to K_TREE_VIEW_COLUMN_GROW_ONLY.
func (treeColumn treeViewColumn) SetResizable(resizable bool) {
	var arg0 *C.GtkTreeViewColumn
	var arg1 C.gboolean

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())
	arg1 = gextras.Cbool(resizable)

	C.gtk_tree_view_column_set_resizable(arg0, arg1)
}

// SetSizing sets the growth behavior of @tree_column to @type.
func (treeColumn treeViewColumn) SetSizing(_type TreeViewColumnSizing) {
	var arg0 *C.GtkTreeViewColumn
	var arg1 C.GtkTreeViewColumnSizing

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())
	arg1 = (C.GtkTreeViewColumnSizing)(_type)

	C.gtk_tree_view_column_set_sizing(arg0, arg1)
}

// SetSortColumnID sets the logical @sort_column_id that this column sorts
// on when this column is selected for sorting. Doing so makes the column
// header clickable.
func (treeColumn treeViewColumn) SetSortColumnID(sortColumnID int) {
	var arg0 *C.GtkTreeViewColumn
	var arg1 C.int

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())
	arg1 = C.int(sortColumnID)

	C.gtk_tree_view_column_set_sort_column_id(arg0, arg1)
}

// SetSortIndicator: call this function with a @setting of true to display
// an arrow in the header button indicating the column is sorted. Call
// gtk_tree_view_column_set_sort_order() to change the direction of the
// arrow.
func (treeColumn treeViewColumn) SetSortIndicator(setting bool) {
	var arg0 *C.GtkTreeViewColumn
	var arg1 C.gboolean

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())
	arg1 = gextras.Cbool(setting)

	C.gtk_tree_view_column_set_sort_indicator(arg0, arg1)
}

// SetSortOrder changes the appearance of the sort indicator.
//
// This does not actually sort the model. Use
// gtk_tree_view_column_set_sort_column_id() if you want automatic sorting
// support. This function is primarily for custom sorting behavior, and
// should be used in conjunction with gtk_tree_sortable_set_sort_column_id()
// to do that. For custom models, the mechanism will vary.
//
// The sort indicator changes direction to indicate normal sort or reverse
// sort. Note that you must have the sort indicator enabled to see anything
// when calling this function; see
// gtk_tree_view_column_set_sort_indicator().
func (treeColumn treeViewColumn) SetSortOrder(order SortType) {
	var arg0 *C.GtkTreeViewColumn
	var arg1 C.GtkSortType

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())
	arg1 = (C.GtkSortType)(order)

	C.gtk_tree_view_column_set_sort_order(arg0, arg1)
}

// SetSpacing sets the spacing field of @tree_column, which is the number of
// pixels to place between cell renderers packed into it.
func (treeColumn treeViewColumn) SetSpacing(spacing int) {
	var arg0 *C.GtkTreeViewColumn
	var arg1 C.int

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())
	arg1 = C.int(spacing)

	C.gtk_tree_view_column_set_spacing(arg0, arg1)
}

// SetTitle sets the title of the @tree_column. If a custom widget has been
// set, then this value is ignored.
func (treeColumn treeViewColumn) SetTitle(title string) {
	var arg0 *C.GtkTreeViewColumn
	var arg1 *C.char

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())
	arg1 = (*C.gchar)(C.CString(title))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_tree_view_column_set_title(arg0, arg1)
}

// SetVisible sets the visibility of @tree_column.
func (treeColumn treeViewColumn) SetVisible(visible bool) {
	var arg0 *C.GtkTreeViewColumn
	var arg1 C.gboolean

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())
	arg1 = gextras.Cbool(visible)

	C.gtk_tree_view_column_set_visible(arg0, arg1)
}

// SetWidget sets the widget in the header to be @widget. If widget is nil,
// then the header button is set with a Label set to the title of
// @tree_column.
func (treeColumn treeViewColumn) SetWidget(widget Widget) {
	var arg0 *C.GtkTreeViewColumn
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkTreeViewColumn)(treeColumn.Native())
	arg1 = (*C.GtkWidget)(widget.Native())

	C.gtk_tree_view_column_set_widget(arg0, arg1)
}

// Video: gtkVideo is a widget to show a MediaStream with media controls as
// provided by MediaControls. If you just want to display a video without
// controls, you can treat it like any other paintable and for example put it
// into a Picture.
//
// GtkVideo aims to cover use cases such as previews, embedded animations, etc.
// It supports autoplay, looping, and simple media controls. It does not have
// support for video overlays, multichannel audio, device selection, or input.
// If you are writing a full-fledged video player, you may want to use the
// Paintable API and a media framework such as Gstreamer directly.
type Video interface {
	Widget

	// Autoplay returns true if videos have been set to loop via
	// gtk_video_set_loop().
	Autoplay() bool
	// File gets the file played by @self or nil if not playing back a file.
	File() gio.File
	// Loop returns true if videos have been set to loop via
	// gtk_video_set_loop().
	Loop() bool
	// MediaStream gets the media stream managed by @self or nil if none.
	MediaStream() MediaStream
	// SetAutoplay sets whether @self automatically starts playback when it
	// becomes visible or when a new file gets loaded.
	SetAutoplay(autoplay bool)
	// SetFile makes @self play the given @file.
	SetFile(file gio.File)
	// SetFilename makes @self play the given @filename.
	//
	// This is a utility function that calls gtk_video_set_file(),
	SetFilename(filename string)
	// SetLoop sets whether new files loaded by @self should be set to loop.
	SetLoop(loop bool)
	// SetMediaStream sets the media stream to be played back. @self will take
	// full control of managing the media stream. If you want to manage a media
	// stream yourself, consider using a Image for display.
	//
	// If you want to display a file, consider using gtk_video_set_file()
	// instead.
	SetMediaStream(stream MediaStream)
	// SetResource makes @self play the resource at the given @resource_path.
	//
	// This is a utility function that calls gtk_video_set_file(),
	SetResource(resourcePath string)
}

type video struct {
	widget
}

// WrapVideo wraps a GObject to the right type. It is
// primarily used internally.
func WrapVideo(obj *externglib.Object) Video {
	return video{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}
}

func marshalVideo(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapVideo(obj), nil
}

// NewVideo constructs a class Video.
func NewVideo() Video {

	ret := C.gtk_video_new()

	var ret0 Video

	ret0 = WrapVideo(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewVideoForFile constructs a class Video.
func NewVideoForFile(file gio.File) Video {
	var arg1 *C.GFile

	ret := C.gtk_video_new_for_file(arg1)

	var ret0 Video

	ret0 = WrapVideo(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewVideoForFilename constructs a class Video.
func NewVideoForFilename(filename string) Video {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_video_new_for_filename(arg1)

	var ret0 Video

	ret0 = WrapVideo(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewVideoForMediaStream constructs a class Video.
func NewVideoForMediaStream(stream MediaStream) Video {
	var arg1 *C.GtkMediaStream

	arg1 = (*C.GtkMediaStream)(stream.Native())

	ret := C.gtk_video_new_for_media_stream(arg1)

	var ret0 Video

	ret0 = WrapVideo(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewVideoForResource constructs a class Video.
func NewVideoForResource(resourcePath string) Video {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(resourcePath))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_video_new_for_resource(arg1)

	var ret0 Video

	ret0 = WrapVideo(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Autoplay returns true if videos have been set to loop via
// gtk_video_set_loop().
func (self video) Autoplay() bool {
	var arg0 *C.GtkVideo

	arg0 = (*C.GtkVideo)(self.Native())

	ret := C.gtk_video_get_autoplay(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// File gets the file played by @self or nil if not playing back a file.
func (self video) File() gio.File {
	var arg0 *C.GtkVideo

	arg0 = (*C.GtkVideo)(self.Native())

	ret := C.gtk_video_get_file(arg0)

	var ret0 gio.File

	return ret0
}

// Loop returns true if videos have been set to loop via
// gtk_video_set_loop().
func (self video) Loop() bool {
	var arg0 *C.GtkVideo

	arg0 = (*C.GtkVideo)(self.Native())

	ret := C.gtk_video_get_loop(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// MediaStream gets the media stream managed by @self or nil if none.
func (self video) MediaStream() MediaStream {
	var arg0 *C.GtkVideo

	arg0 = (*C.GtkVideo)(self.Native())

	ret := C.gtk_video_get_media_stream(arg0)

	var ret0 MediaStream

	ret0 = WrapMediaStream(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// SetAutoplay sets whether @self automatically starts playback when it
// becomes visible or when a new file gets loaded.
func (self video) SetAutoplay(autoplay bool) {
	var arg0 *C.GtkVideo
	var arg1 C.gboolean

	arg0 = (*C.GtkVideo)(self.Native())
	arg1 = gextras.Cbool(autoplay)

	C.gtk_video_set_autoplay(arg0, arg1)
}

// SetFile makes @self play the given @file.
func (self video) SetFile(file gio.File) {
	var arg0 *C.GtkVideo
	var arg1 *C.GFile

	arg0 = (*C.GtkVideo)(self.Native())

	C.gtk_video_set_file(arg0, arg1)
}

// SetFilename makes @self play the given @filename.
//
// This is a utility function that calls gtk_video_set_file(),
func (self video) SetFilename(filename string) {
	var arg0 *C.GtkVideo
	var arg1 *C.char

	arg0 = (*C.GtkVideo)(self.Native())
	arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_video_set_filename(arg0, arg1)
}

// SetLoop sets whether new files loaded by @self should be set to loop.
func (self video) SetLoop(loop bool) {
	var arg0 *C.GtkVideo
	var arg1 C.gboolean

	arg0 = (*C.GtkVideo)(self.Native())
	arg1 = gextras.Cbool(loop)

	C.gtk_video_set_loop(arg0, arg1)
}

// SetMediaStream sets the media stream to be played back. @self will take
// full control of managing the media stream. If you want to manage a media
// stream yourself, consider using a Image for display.
//
// If you want to display a file, consider using gtk_video_set_file()
// instead.
func (self video) SetMediaStream(stream MediaStream) {
	var arg0 *C.GtkVideo
	var arg1 *C.GtkMediaStream

	arg0 = (*C.GtkVideo)(self.Native())
	arg1 = (*C.GtkMediaStream)(stream.Native())

	C.gtk_video_set_media_stream(arg0, arg1)
}

// SetResource makes @self play the resource at the given @resource_path.
//
// This is a utility function that calls gtk_video_set_file(),
func (self video) SetResource(resourcePath string) {
	var arg0 *C.GtkVideo
	var arg1 *C.char

	arg0 = (*C.GtkVideo)(self.Native())
	arg1 = (*C.gchar)(C.CString(resourcePath))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_video_set_resource(arg0, arg1)
}

// Viewport: the Viewport widget acts as an adaptor class, implementing
// scrollability for child widgets that lack their own scrolling capabilities.
// Use GtkViewport to scroll child widgets such as Grid, Box, and so on.
//
// The GtkViewport will start scrolling content only if allocated less than the
// child widget’s minimum size in a given orientation.
//
//
// CSS nodes
//
// GtkViewport has a single CSS node with name `viewport`.
//
//
// Accessibility
//
// GtkViewport uses the GTK_ACCESSIBLE_ROLE_GROUP role.
type Viewport interface {
	Widget

	// Child gets the child widget of @viewport.
	Child() Widget
	// ScrollToFocus gets whether the viewport is scrolling to keep the focused
	// child in view. See gtk_viewport_set_scroll_to_focus().
	ScrollToFocus() bool
	// SetChild sets the child widget of @viewport.
	SetChild(child Widget)
	// SetScrollToFocus sets whether the viewport should automatically scroll to
	// keep the focused child in view.
	SetScrollToFocus(scrollToFocus bool)
}

type viewport struct {
	widget
}

// WrapViewport wraps a GObject to the right type. It is
// primarily used internally.
func WrapViewport(obj *externglib.Object) Viewport {
	return viewport{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}
}

func marshalViewport(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapViewport(obj), nil
}

// NewViewport constructs a class Viewport.
func NewViewport(hadjustment Adjustment, vadjustment Adjustment) Viewport {
	var arg1 *C.GtkAdjustment
	var arg2 *C.GtkAdjustment

	arg1 = (*C.GtkAdjustment)(hadjustment.Native())
	arg2 = (*C.GtkAdjustment)(vadjustment.Native())

	ret := C.gtk_viewport_new(arg1, arg2)

	var ret0 Viewport

	ret0 = WrapViewport(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Child gets the child widget of @viewport.
func (viewport viewport) Child() Widget {
	var arg0 *C.GtkViewport

	arg0 = (*C.GtkViewport)(viewport.Native())

	ret := C.gtk_viewport_get_child(arg0)

	var ret0 Widget

	ret0 = WrapWidget(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// ScrollToFocus gets whether the viewport is scrolling to keep the focused
// child in view. See gtk_viewport_set_scroll_to_focus().
func (viewport viewport) ScrollToFocus() bool {
	var arg0 *C.GtkViewport

	arg0 = (*C.GtkViewport)(viewport.Native())

	ret := C.gtk_viewport_get_scroll_to_focus(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// SetChild sets the child widget of @viewport.
func (viewport viewport) SetChild(child Widget) {
	var arg0 *C.GtkViewport
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkViewport)(viewport.Native())
	arg1 = (*C.GtkWidget)(child.Native())

	C.gtk_viewport_set_child(arg0, arg1)
}

// SetScrollToFocus sets whether the viewport should automatically scroll to
// keep the focused child in view.
func (viewport viewport) SetScrollToFocus(scrollToFocus bool) {
	var arg0 *C.GtkViewport
	var arg1 C.gboolean

	arg0 = (*C.GtkViewport)(viewport.Native())
	arg1 = gextras.Cbool(scrollToFocus)

	C.gtk_viewport_set_scroll_to_focus(arg0, arg1)
}

// VolumeButton is a subclass of ScaleButton that has been tailored for use as a
// volume control widget with suitable icons, tooltips and accessible labels.
type VolumeButton interface {
	ScaleButton
}

type volumeButton struct {
	scaleButton
}

// WrapVolumeButton wraps a GObject to the right type. It is
// primarily used internally.
func WrapVolumeButton(obj *externglib.Object) VolumeButton {
	return volumeButton{scaleButton{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}}
}

func marshalVolumeButton(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapVolumeButton(obj), nil
}

// NewVolumeButton constructs a class VolumeButton.
func NewVolumeButton() VolumeButton {

	ret := C.gtk_volume_button_new()

	var ret0 VolumeButton

	ret0 = WrapVolumeButton(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Widget: gtkWidget is the base class all widgets in GTK derive from. It
// manages the widget lifecycle, states and style.
//
//
// Height-for-width Geometry Management
//
// GTK uses a height-for-width (and width-for-height) geometry management
// system. Height-for-width means that a widget can change how much vertical
// space it needs, depending on the amount of horizontal space that it is given
// (and similar for width-for-height). The most common example is a label that
// reflows to fill up the available width, wraps to fewer lines, and therefore
// needs less height.
//
// Height-for-width geometry management is implemented in GTK by way of two
// virtual methods:
//
// - WidgetClass.get_request_mode() - WidgetClass.measure()
//
// There are some important things to keep in mind when implementing
// height-for-width and when using it in widget implementations.
//
// If you implement a direct Widget subclass that supports height-for-width or
// width-for-height geometry management for itself or its child widgets, the
// WidgetClass.get_request_mode() virtual function must be implemented as well
// and return the widget's preferred request mode. The default implementation of
// this virtual function returns GTK_SIZE_REQUEST_CONSTANT_SIZE, which means
// that the widget will only ever get -1 passed as the for_size value to its
// WidgetClass.measure() implementation.
//
// The geometry management system will query a widget hierarchy in only one
// orientation at a time. When widgets are initially queried for their minimum
// sizes it is generally done in two initial passes in the SizeRequestMode
// chosen by the toplevel.
//
// For example, when queried in the normal GTK_SIZE_REQUEST_HEIGHT_FOR_WIDTH
// mode: First, the default minimum and natural width for each widget in the
// interface will be computed using gtk_widget_measure() with an orientation of
// GTK_ORIENTATION_HORIZONTAL and a for_size of -1. Because the preferred widths
// for each widget depend on the preferred widths of their children, this
// information propagates up the hierarchy, and finally a minimum and natural
// width is determined for the entire toplevel. Next, the toplevel will use the
// minimum width to query for the minimum height contextual to that width using
// gtk_widget_measure() with an orientation of GTK_ORIENTATION_VERTICAL and a
// for_size of the just computed width. This will also be a highly recursive
// operation. The minimum height for the minimum width is normally used to set
// the minimum size constraint on the toplevel.
//
// After the toplevel window has initially requested its size in both dimensions
// it can go on to allocate itself a reasonable size (or a size previously
// specified with gtk_window_set_default_size()). During the recursive
// allocation process it’s important to note that request cycles will be
// recursively executed while widgets allocate their children. Each widget, once
// allocated a size, will go on to first share the space in one orientation
// among its children and then request each child's height for its target
// allocated width or its width for allocated height, depending. In this way a
// Widget will typically be requested its size a number of times before actually
// being allocated a size. The size a widget is finally allocated can of course
// differ from the size it has requested. For this reason, Widget caches a small
// number of results to avoid re-querying for the same sizes in one allocation
// cycle.
//
// If a widget does move content around to intelligently use up the allocated
// size then it must support the request in both SizeRequestModes even if the
// widget in question only trades sizes in a single orientation.
//
// For instance, a Label that does height-for-width word wrapping will not
// expect to have WidgetClass.measure() with an orientation of
// GTK_ORIENTATION_VERTICAL called because that call is specific to a
// width-for-height request. In this case the label must return the height
// required for its own minimum possible width. By following this rule any
// widget that handles height-for-width or width-for-height requests will always
// be allocated at least enough space to fit its own content.
//
// Here are some examples of how a GTK_SIZE_REQUEST_HEIGHT_FOR_WIDTH widget
// generally deals with width-for-height requests:
//
//    // the signal handler has the instance and user data swapped
//    // because of the swapped="yes" attribute in the template XML
//    static void
//    hello_button_clicked (FooWidget *self,
//                          GtkButton *button)
//    {
//      g_print ("Hello, world!\n");
//    }
//
//    static void
//    foo_widget_class_init (FooWidgetClass *klass)
//    {
//      // ...
//      gtk_widget_class_set_template_from_resource (GTK_WIDGET_CLASS (klass),
//                                                   "/com/example/ui/foowidget.ui");
//      gtk_widget_class_bind_template_callback (GTK_WIDGET_CLASS (klass), hello_button_clicked);
//    }
//
type Widget interface {
	gextras.Objector

	// ActionSetEnabled: enable or disable an action installed with
	// gtk_widget_class_install_action().
	ActionSetEnabled(actionName string, enabled bool)
	// Activate: for widgets that can be “activated” (buttons, menu items, etc.)
	// this function activates them. The activation will emit the signal set
	// using gtk_widget_class_set_activate_signal() during class initialization.
	//
	// Activation is what happens when you press Enter on a widget during key
	// navigation.
	//
	// If you wish to handle the activation keybinding yourself, it is
	// recommended to use gtk_widget_class_add_shortcut() with an action created
	// with gtk_signal_action_new().
	//
	// If @widget isn't activatable, the function returns false.
	Activate() bool
	// ActivateActionVariant looks up the action in the action groups associated
	// with @widget and its ancestors, and activates it.
	//
	// If the action is in an action group added with
	// gtk_widget_insert_action_group(), the @name is expected to be prefixed
	// with the prefix that was used when the group was inserted.
	//
	// The arguments must match the actions expected parameter type, as returned
	// by g_action_get_parameter_type().
	ActivateActionVariant(name string, args *glib.Variant) bool
	// ActivateDefault: activate the default.activate action from @widget.
	ActivateDefault()
	// AddController adds @controller to @widget so that it will receive events.
	// You will usually want to call this function right after creating any kind
	// of EventController.
	AddController(controller EventController)
	// AddCSSClass adds @css_class to @widget. After calling this function,
	// @widget's style will match for @css_class, after the CSS matching rules.
	AddCSSClass(cssClass string)
	// AddMnemonicLabel adds a widget to the list of mnemonic labels for this
	// widget. (See gtk_widget_list_mnemonic_labels()). Note the list of
	// mnemonic labels for the widget is cleared when the widget is destroyed,
	// so the caller must make sure to update its internal state at this point
	// as well, by using a connection to the Widget::destroy signal or a weak
	// notifier.
	AddMnemonicLabel(label Widget)
	// AddTickCallback queues an animation frame update and adds a callback to
	// be called before each frame. Until the tick callback is removed, it will
	// be called frequently (usually at the frame rate of the output device or
	// as quickly as the application can be repainted, whichever is slower). For
	// this reason, is most suitable for handling graphics that change every
	// frame or every few frames. The tick callback does not automatically imply
	// a relayout or repaint. If you want a repaint or relayout, and aren’t
	// changing widget properties that would trigger that (for example, changing
	// the text of a Label), then you will have to call
	// gtk_widget_queue_resize() or gtk_widget_queue_draw() yourself.
	//
	// gdk_frame_clock_get_frame_time() should generally be used for timing
	// continuous animations and
	// gdk_frame_timings_get_predicted_presentation_time() if you are trying to
	// display isolated frames at particular times.
	//
	// This is a more convenient alternative to connecting directly to the
	// FrameClock::update signal of FrameClock, since you don't have to worry
	// about when a FrameClock is assigned to a widget.
	AddTickCallback(callback TickCallback) uint
	// Allocate: this function is only used by Widget subclasses, to assign a
	// size, position and (optionally) baseline to their child widgets.
	//
	// In this function, the allocation and baseline may be adjusted. The given
	// allocation will be forced to be bigger than the widget's minimum size, as
	// well as at least 0×0 in size.
	//
	// For a version that does not take a transform, see
	// gtk_widget_size_allocate()
	Allocate(width int, height int, baseline int, transform *gsk.Transform)
	// ChildFocus: this function is used by custom widget implementations; if
	// you're writing an app, you’d use gtk_widget_grab_focus() to move the
	// focus to a particular widget.
	//
	// gtk_widget_child_focus() is called by widgets as the user moves around
	// the window using keyboard shortcuts. @direction indicates what kind of
	// motion is taking place (up, down, left, right, tab forward, tab
	// backward). gtk_widget_child_focus() calls the WidgetClass.focus() vfunc;
	// widgets override this vfunc in order to implement appropriate focus
	// behavior.
	//
	// The default focus() vfunc for a widget should return true if moving in
	// @direction left the focus on a focusable location inside that widget, and
	// false if moving in @direction moved the focus outside the widget. If
	// returning true, widgets normally call gtk_widget_grab_focus() to place
	// the focus accordingly; if returning false, they don’t modify the current
	// focus location.
	ChildFocus(direction DirectionType) bool
	// ComputeBounds computes the bounds for @widget in the coordinate space of
	// @target. FIXME: Explain what "bounds" are.
	//
	// If the operation is successful, true is returned. If @widget has no
	// bounds or the bounds cannot be expressed in @target's coordinate space
	// (for example if both widgets are in different windows), false is returned
	// and @bounds is set to the zero rectangle.
	//
	// It is valid for @widget and @target to be the same widget.
	ComputeBounds(target Widget) (outBounds graphene.Rect, ok bool)
	// ComputeExpand computes whether a container should give this widget extra
	// space when possible. Containers should check this, rather than looking at
	// gtk_widget_get_hexpand() or gtk_widget_get_vexpand().
	//
	// This function already checks whether the widget is visible, so visibility
	// does not need to be checked separately. Non-visible widgets are not
	// expanded.
	//
	// The computed expand value uses either the expand setting explicitly set
	// on the widget itself, or, if none has been explicitly set, the widget may
	// expand if some of its children do.
	ComputeExpand(orientation Orientation) bool
	// ComputePoint translates the given @point in @widget's coordinates to
	// coordinates relative to @target’s coordinate system. In order to perform
	// this operation, both widgets must share a common root.
	ComputePoint(target Widget, point *graphene.Point) (outPoint graphene.Point, ok bool)
	// ComputeTransform computes a matrix suitable to describe a transformation
	// from @widget's coordinate system into @target's coordinate system.
	ComputeTransform(target Widget) (outTransform graphene.Matrix, ok bool)
	// Contains tests if the point at (@x, @y) is contained in @widget.
	//
	// The coordinates for (@x, @y) must be in widget coordinates, so (0, 0) is
	// assumed to be the top left of @widget's content area.
	Contains(x float64, y float64) bool
	// CreatePangoContext creates a new Context with the appropriate font map,
	// font options, font description, and base direction for drawing text for
	// this widget. See also gtk_widget_get_pango_context().
	CreatePangoContext() pango.Context
	// CreatePangoLayout creates a new Layout with the appropriate font map,
	// font description, and base direction for drawing text for this widget.
	//
	// If you keep a Layout created in this way around, you need to re-create it
	// when the widget Context is replaced. This can be tracked by listening to
	// changes of the Widget:root property on the widget.
	CreatePangoLayout(text string) pango.Layout
	// DragCheckThreshold checks to see if a mouse drag starting at (@start_x,
	// @start_y) and ending at (@current_x, @current_y) has passed the GTK drag
	// threshold, and thus should trigger the beginning of a drag-and-drop
	// operation.
	DragCheckThreshold(startX int, startY int, currentX int, currentY int) bool
	// ErrorBell notifies the user about an input-related error on this widget.
	// If the Settings:gtk-error-bell setting is true, it calls
	// gdk_surface_beep(), otherwise it does nothing.
	//
	// Note that the effect of gdk_surface_beep() can be configured in many
	// ways, depending on the windowing backend and the desktop environment or
	// window manager that is used.
	ErrorBell()
	// AllocatedBaseline returns the baseline that has currently been allocated
	// to @widget. This function is intended to be used when implementing
	// handlers for the WidgetClass.snapshot() function, and when allocating
	// child widgets in WidgetClass.size_allocate().
	AllocatedBaseline() int
	// AllocatedHeight returns the height that has currently been allocated to
	// @widget.
	AllocatedHeight() int
	// AllocatedWidth returns the width that has currently been allocated to
	// @widget.
	AllocatedWidth() int
	// Allocation retrieves the widget’s allocation.
	//
	// Note, when implementing a layout container: a widget’s allocation will be
	// its “adjusted” allocation, that is, the widget’s parent typically calls
	// gtk_widget_size_allocate() with an allocation, and that allocation is
	// then adjusted (to handle margin and alignment for example) before
	// assignment to the widget. gtk_widget_get_allocation() returns the
	// adjusted allocation that was actually assigned to the widget. The
	// adjusted allocation is guaranteed to be completely contained within the
	// gtk_widget_size_allocate() allocation, however.
	//
	// So a layout container is guaranteed that its children stay inside the
	// assigned bounds, but not that they have exactly the bounds the container
	// assigned.
	Allocation() Allocation
	// Ancestor gets the first ancestor of @widget with type @widget_type. For
	// example, `gtk_widget_get_ancestor (widget, GTK_TYPE_BOX)` gets the first
	// Box that’s an ancestor of @widget. No reference will be added to the
	// returned widget; it should not be unreferenced.
	//
	// Note that unlike gtk_widget_is_ancestor(), gtk_widget_get_ancestor()
	// considers @widget to be an ancestor of itself.
	Ancestor(widgetType externglib.Type) Widget
	// CanFocus determines whether the input focus can enter @widget or any of
	// its children.
	//
	// See gtk_widget_set_focusable().
	CanFocus() bool
	// CanTarget queries whether @widget can be the target of pointer events.
	CanTarget() bool
	// ChildVisible gets the value set with gtk_widget_set_child_visible(). If
	// you feel a need to use this function, your code probably needs
	// reorganization.
	//
	// This function is only useful for container implementations and never
	// should be called by an application.
	ChildVisible() bool
	// Clipboard: this is a utility function to get the clipboard object for the
	// Display that @widget is using.
	//
	// Note that this function always works, even when @widget is not realized
	// yet.
	Clipboard() gdk.Clipboard
	// CSSClasses returns the list of css classes applied to @widget.
	CSSClasses() []string
	// CSSName returns the CSS name that is used for @self.
	CSSName() string
	// Cursor queries the cursor set via gtk_widget_set_cursor(). See that
	// function for details.
	Cursor() gdk.Cursor
	// Direction gets the reading direction for a particular widget. See
	// gtk_widget_set_direction().
	Direction() TextDirection
	// Display: get the Display for the toplevel window associated with this
	// widget. This function can only be called after the widget has been added
	// to a widget hierarchy with a Window at the top.
	//
	// In general, you should only create display specific resources when a
	// widget has been realized, and you should free those resources when the
	// widget is unrealized.
	Display() gdk.Display
	// FirstChild returns the widgets first child.
	//
	// This API is primarily meant for widget implementations.
	FirstChild() Widget
	// FocusChild returns the current focus child of @widget.
	FocusChild() Widget
	// FocusOnClick returns whether the widget should grab focus when it is
	// clicked with the mouse. See gtk_widget_set_focus_on_click().
	FocusOnClick() bool
	// Focusable determines whether @widget can own the input focus. See
	// gtk_widget_set_focusable().
	Focusable() bool
	// FontMap gets the font map that has been set with
	// gtk_widget_set_font_map().
	FontMap() pango.FontMap
	// FontOptions returns the #cairo_font_options_t used for Pango rendering.
	// When not set, the defaults font options for the Display will be used.
	FontOptions() *cairo.FontOptions
	// FrameClock obtains the frame clock for a widget. The frame clock is a
	// global “ticker” that can be used to drive animations and repaints. The
	// most common reason to get the frame clock is to call
	// gdk_frame_clock_get_frame_time(), in order to get a time to use for
	// animating. For example you might record the start of the animation with
	// an initial value from gdk_frame_clock_get_frame_time(), and then update
	// the animation by calling gdk_frame_clock_get_frame_time() again during
	// each repaint.
	//
	// gdk_frame_clock_request_phase() will result in a new frame on the clock,
	// but won’t necessarily repaint any widgets. To repaint a widget, you have
	// to use gtk_widget_queue_draw() which invalidates the widget (thus
	// scheduling it to receive a draw on the next frame).
	// gtk_widget_queue_draw() will also end up requesting a frame on the
	// appropriate frame clock.
	//
	// A widget’s frame clock will not change while the widget is mapped.
	// Reparenting a widget (which implies a temporary unmap) can change the
	// widget’s frame clock.
	//
	// Unrealized widgets do not have a frame clock.
	FrameClock() gdk.FrameClock
	// Halign gets the value of the Widget:halign property.
	//
	// For backwards compatibility reasons this method will never return
	// GTK_ALIGN_BASELINE, but instead it will convert it to GTK_ALIGN_FILL.
	// Baselines are not supported for horizontal alignment.
	Halign() Align
	// HasTooltip returns the current value of the has-tooltip property. See
	// Widget:has-tooltip for more information.
	HasTooltip() bool
	// Height returns the content height of the widget, as passed to its
	// size-allocate implementation. This is the size you should be using in
	// GtkWidgetClass.snapshot(). For pointer events, see gtk_widget_contains().
	Height() int
	// Hexpand gets whether the widget would like any available extra horizontal
	// space. When a user resizes a Window, widgets with expand=TRUE generally
	// receive the extra space. For example, a list or scrollable area or
	// document in your window would often be set to expand.
	//
	// Containers should use gtk_widget_compute_expand() rather than this
	// function, to see whether a widget, or any of its children, has the expand
	// flag set. If any child of a widget wants to expand, the parent may ask to
	// expand also.
	//
	// This function only looks at the widget’s own hexpand flag, rather than
	// computing whether the entire widget tree rooted at this widget wants to
	// expand.
	Hexpand() bool
	// HexpandSet gets whether gtk_widget_set_hexpand() has been used to
	// explicitly set the expand flag on this widget.
	//
	// If hexpand is set, then it overrides any computed expand value based on
	// child widgets. If hexpand is not set, then the expand value depends on
	// whether any children of the widget would like to expand.
	//
	// There are few reasons to use this function, but it’s here for
	// completeness and consistency.
	HexpandSet() bool
	// LastChild returns the widgets last child.
	//
	// This API is primarily meant for widget implementations.
	LastChild() Widget
	// LayoutManager retrieves the layout manager set using
	// gtk_widget_set_layout_manager().
	LayoutManager() LayoutManager
	// Mapped: whether the widget is mapped.
	Mapped() bool
	// MarginBottom gets the value of the Widget:margin-bottom property.
	MarginBottom() int
	// MarginEnd gets the value of the Widget:margin-end property.
	MarginEnd() int
	// MarginStart gets the value of the Widget:margin-start property.
	MarginStart() int
	// MarginTop gets the value of the Widget:margin-top property.
	MarginTop() int
	// Name retrieves the name of a widget. See gtk_widget_set_name() for the
	// significance of widget names.
	Name() string
	// Native returns the GtkNative widget that contains @widget, or nil if the
	// widget is not contained inside a widget tree with a native ancestor.
	//
	// Native widgets will return themselves here.
	Native() Native
	// NextSibling returns the widgets next sibling.
	//
	// This API is primarily meant for widget implementations.
	NextSibling() Widget
	// Opacity fetches the requested opacity for this widget. See
	// gtk_widget_set_opacity().
	Opacity() float64
	// Overflow returns the value set via gtk_widget_set_overflow().
	Overflow() Overflow
	// PangoContext gets a Context with the appropriate font map, font
	// description, and base direction for this widget. Unlike the context
	// returned by gtk_widget_create_pango_context(), this context is owned by
	// the widget (it can be used until the screen for the widget changes or the
	// widget is removed from its toplevel), and will be updated to match any
	// changes to the widget’s attributes. This can be tracked by listening to
	// changes of the Widget:root property on the widget.
	PangoContext() pango.Context
	// Parent returns the parent widget of @widget.
	Parent() Widget
	// PreferredSize retrieves the minimum and natural size of a widget, taking
	// into account the widget’s preference for height-for-width management.
	//
	// This is used to retrieve a suitable size by container widgets which do
	// not impose any restrictions on the child placement. It can be used to
	// deduce toplevel window and menu sizes as well as child widgets in
	// free-form containers such as GtkLayout.
	//
	// Handle with care. Note that the natural height of a height-for-width
	// widget will generally be a smaller size than the minimum height, since
	// the required height for the natural width is generally smaller than the
	// required height for the minimum width.
	//
	// Use gtk_widget_measure() if you want to support baseline alignment.
	PreferredSize() (minimumSize Requisition, naturalSize Requisition)
	// PrevSibling returns the widgets previous sibling.
	//
	// This API is primarily meant for widget implementations.
	PrevSibling() Widget
	// PrimaryClipboard: this is a utility function to get the primary clipboard
	// object for the Display that @widget is using.
	//
	// Note that this function always works, even when @widget is not realized
	// yet.
	PrimaryClipboard() gdk.Clipboard
	// Realized determines whether @widget is realized.
	Realized() bool
	// ReceivesDefault determines whether @widget is always treated as the
	// default widget within its toplevel when it has the focus, even if another
	// widget is the default.
	//
	// See gtk_widget_set_receives_default().
	ReceivesDefault() bool
	// RequestMode gets whether the widget prefers a height-for-width layout or
	// a width-for-height layout.
	//
	// Bin widgets generally propagate the preference of their child, container
	// widgets need to request something either in context of their children or
	// in context of their allocation capabilities.
	RequestMode() SizeRequestMode
	// Root returns the Root widget of @widget or nil if the widget is not
	// contained inside a widget tree with a root widget.
	//
	// Root widgets will return themselves here.
	Root() Root
	// ScaleFactor retrieves the internal scale factor that maps from window
	// coordinates to the actual device pixels. On traditional systems this is
	// 1, on high density outputs, it can be a higher value (typically 2).
	//
	// See gdk_surface_get_scale_factor().
	ScaleFactor() int
	// Sensitive returns the widget’s sensitivity (in the sense of returning the
	// value that has been set using gtk_widget_set_sensitive()).
	//
	// The effective sensitivity of a widget is however determined by both its
	// own and its parent widget’s sensitivity. See gtk_widget_is_sensitive().
	Sensitive() bool
	// Settings gets the settings object holding the settings used for this
	// widget.
	//
	// Note that this function can only be called when the Widget is attached to
	// a toplevel, since the settings object is specific to a particular
	// Display. If you want to monitor the widget for changes in its settings,
	// connect to notify::display.
	Settings() Settings
	// Size returns the content width or height of the widget, depending on
	// @orientation. This is equivalent to calling gtk_widget_get_width() for
	// GTK_ORIENTATION_HORIZONTAL or gtk_widget_get_height() for
	// GTK_ORIENTATION_VERTICAL, but can be used when writing
	// orientation-independent code, such as when implementing Orientable
	// widgets.
	Size(orientation Orientation) int
	// SizeRequest gets the size request that was explicitly set for the widget
	// using gtk_widget_set_size_request(). A value of -1 stored in @width or
	// @height indicates that that dimension has not been set explicitly and the
	// natural requisition of the widget will be used instead. See
	// gtk_widget_set_size_request(). To get the size a widget will actually
	// request, call gtk_widget_measure() instead of this function.
	SizeRequest() (width int, height int)
	// StateFlags returns the widget state as a flag set. It is worth mentioning
	// that the effective GTK_STATE_FLAG_INSENSITIVE state will be returned,
	// that is, also based on parent insensitivity, even if @widget itself is
	// sensitive.
	//
	// Also note that if you are looking for a way to obtain the StateFlags to
	// pass to a StyleContext method, you should look at
	// gtk_style_context_get_state().
	StateFlags() StateFlags
	// StyleContext returns the style context associated to @widget. The
	// returned object is guaranteed to be the same for the lifetime of @widget.
	StyleContext() StyleContext
	// TemplateChild: fetch an object build from the template XML for
	// @widget_type in this @widget instance.
	//
	// This will only report children which were previously declared with
	// gtk_widget_class_bind_template_child_full() or one of its variants.
	//
	// This function is only meant to be called for code which is private to the
	// @widget_type which declared the child and is meant for language bindings
	// which cannot easily make use of the GObject structure offsets.
	TemplateChild(widgetType externglib.Type, name string) gextras.Objector
	// TooltipMarkup gets the contents of the tooltip for @widget set using
	// gtk_widget_set_tooltip_markup().
	TooltipMarkup() string
	// TooltipText gets the contents of the tooltip for @widget.
	//
	// If the @widget's tooltip was set using gtk_widget_set_tooltip_markup(),
	// this function will return the escaped text.
	TooltipText() string
	// Valign gets the value of the Widget:valign property.
	Valign() Align
	// Vexpand gets whether the widget would like any available extra vertical
	// space.
	//
	// See gtk_widget_get_hexpand() for more detail.
	Vexpand() bool
	// VexpandSet gets whether gtk_widget_set_vexpand() has been used to
	// explicitly set the expand flag on this widget.
	//
	// See gtk_widget_get_hexpand_set() for more detail.
	VexpandSet() bool
	// Visible determines whether the widget is visible. If you want to take
	// into account whether the widget’s parent is also marked as visible, use
	// gtk_widget_is_visible() instead.
	//
	// This function does not check if the widget is obscured in any way.
	//
	// See gtk_widget_set_visible().
	Visible() bool
	// Width returns the content width of the widget, as passed to its
	// size-allocate implementation. This is the size you should be using in
	// GtkWidgetClass.snapshot(). For pointer events, see gtk_widget_contains().
	Width() int
	// GrabFocus causes @widget (or one of its descendents) to have the keyboard
	// focus for the Window it's inside.
	//
	// If @widget is not focusable, or its ::grab_focus implementation cannot
	// transfer the focus to a descendant of @widget that is focusable, it will
	// not take focus and false will be returned.
	//
	// Calling gtk_widget_grab_focus() on an already focused widget is allowed,
	// should not have an effect, and return true.
	GrabFocus() bool
	// HasCSSClass returns whether @css_class is currently applied to @widget.
	HasCSSClass(cssClass string) bool
	// HasDefault determines whether @widget is the current default widget
	// within its toplevel.
	HasDefault() bool
	// HasFocus determines if the widget has the global input focus. See
	// gtk_widget_is_focus() for the difference between having the global input
	// focus, and only having the focus within a toplevel.
	HasFocus() bool
	// HasVisibleFocus determines if the widget should show a visible indication
	// that it has the global input focus. This is a convenience function that
	// takes into account whether focus indication should currently be shown in
	// the toplevel window of @widget. See gtk_window_get_focus_visible() for
	// more information about focus indication.
	//
	// To find out if the widget has the global input focus, use
	// gtk_widget_has_focus().
	HasVisibleFocus() bool
	// Hide reverses the effects of gtk_widget_show(), causing the widget to be
	// hidden (invisible to the user).
	Hide()
	// InDestruction returns whether the widget is currently being destroyed.
	// This information can sometimes be used to avoid doing unnecessary work.
	InDestruction() bool
	// InitTemplate creates and initializes child widgets defined in templates.
	// This function must be called in the instance initializer for any class
	// which assigned itself a template using gtk_widget_class_set_template()
	//
	// It is important to call this function in the instance initializer of a
	// Widget subclass and not in #GObject.constructed() or
	// #GObject.constructor() for two reasons.
	//
	// One reason is that generally derived widgets will assume that parent
	// class composite widgets have been created in their instance initializers.
	//
	// Another reason is that when calling g_object_new() on a widget with
	// composite templates, it’s important to build the composite widgets before
	// the construct properties are set. Properties passed to g_object_new()
	// should take precedence over properties set in the private template XML.
	InitTemplate()
	// InsertActionGroup inserts @group into @widget. Children of @widget that
	// implement Actionable can then be associated with actions in @group by
	// setting their “action-name” to @prefix.`action-name`.
	//
	// Note that inheritance is defined for individual actions. I.e. even if you
	// insert a group with prefix @prefix, actions with the same prefix will
	// still be inherited from the parent, unless the group contains an action
	// with the same name.
	//
	// If @group is nil, a previously inserted group for @name is removed from
	// @widget.
	InsertActionGroup(name string, group gio.ActionGroup)
	// InsertAfter inserts @widget into the child widget list of @parent.
	//
	// It will be placed after @previous_sibling, or at the beginning if
	// @previous_sibling is nil.
	//
	// After calling this function, gtk_widget_get_prev_sibling(widget) will
	// return @previous_sibling.
	//
	// If @parent is already set as the parent widget of @widget, this function
	// can also be used to reorder @widget in the child widget list of @parent.
	//
	// This API is primarily meant for widget implementations; if you are just
	// using a widget, you *must* use its own API for adding children.
	InsertAfter(parent Widget, previousSibling Widget)
	// InsertBefore inserts @widget into the child widget list of @parent.
	//
	// It will be placed before @next_sibling, or at the end if @next_sibling is
	// nil.
	//
	// After calling this function, gtk_widget_get_next_sibling(widget) will
	// return @next_sibling.
	//
	// If @parent is already set as the parent widget of @widget, this function
	// can also be used to reorder @widget in the child widget list of @parent.
	//
	// This API is primarily meant for widget implementations; if you are just
	// using a widget, you *must* use its own API for adding children.
	InsertBefore(parent Widget, nextSibling Widget)
	// IsAncestor determines whether @widget is somewhere inside @ancestor,
	// possibly with intermediate containers.
	IsAncestor(ancestor Widget) bool
	// IsDrawable determines whether @widget can be drawn to. A widget can be
	// drawn if it is mapped and visible.
	IsDrawable() bool
	// IsFocus determines if the widget is the focus widget within its toplevel.
	// (This does not mean that the Widget:has-focus property is necessarily
	// set; Widget:has-focus will only be set if the toplevel widget
	// additionally has the global input focus.)
	IsFocus() bool
	// IsSensitive returns the widget’s effective sensitivity, which means it is
	// sensitive itself and also its parent widget is sensitive
	IsSensitive() bool
	// IsVisible determines whether the widget and all its parents are marked as
	// visible.
	//
	// This function does not check if the widget is obscured in any way.
	//
	// See also gtk_widget_get_visible() and gtk_widget_set_visible()
	IsVisible() bool
	// KeynavFailed: this function should be called whenever keyboard navigation
	// within a single widget hits a boundary. The function emits the
	// Widget::keynav-failed signal on the widget and its return value should be
	// interpreted in a way similar to the return value of
	// gtk_widget_child_focus():
	//
	// When true is returned, stay in the widget, the failed keyboard navigation
	// is OK and/or there is nowhere we can/should move the focus to.
	//
	// When false is returned, the caller should continue with keyboard
	// navigation outside the widget, e.g. by calling gtk_widget_child_focus()
	// on the widget’s toplevel.
	//
	// The default ::keynav-failed handler returns false for GTK_DIR_TAB_FORWARD
	// and GTK_DIR_TAB_BACKWARD. For the other values of DirectionType it
	// returns true.
	//
	// Whenever the default handler returns true, it also calls
	// gtk_widget_error_bell() to notify the user of the failed keyboard
	// navigation.
	//
	// A use case for providing an own implementation of ::keynav-failed (either
	// by connecting to it or by overriding it) would be a row of Entry widgets
	// where the user should be able to navigate the entire row with the cursor
	// keys, as e.g. known from user interfaces that require entering license
	// keys.
	KeynavFailed(direction DirectionType) bool
	// ListMnemonicLabels returns a newly allocated list of the widgets,
	// normally labels, for which this widget is the target of a mnemonic (see
	// for example, gtk_label_set_mnemonic_widget()).
	//
	// The widgets in the list are not individually referenced. If you want to
	// iterate through the list and perform actions involving callbacks that
	// might destroy the widgets, you must call `g_list_foreach (result,
	// (GFunc)g_object_ref, NULL)` first, and then unref all the widgets
	// afterwards.
	ListMnemonicLabels() *glib.List
	// Map: this function is only for use in widget implementations. Causes a
	// widget to be mapped if it isn’t already.
	Map()
	// Measure measures @widget in the orientation @orientation and for the
	// given @for_size. As an example, if @orientation is
	// GTK_ORIENTATION_HORIZONTAL and @for_size is 300, this functions will
	// compute the minimum and natural width of @widget if it is allocated at a
	// height of 300 pixels.
	//
	// See [GtkWidget’s geometry management section][geometry-management] for a
	// more details on implementing WidgetClass.measure().
	Measure(orientation Orientation, forSize int) (minimum int, natural int, minimumBaseline int, naturalBaseline int)
	// MnemonicActivate emits the Widget::mnemonic-activate signal.
	MnemonicActivate(groupCycling bool) bool
	// ObserveChildren returns a Model to track the children of @widget.
	//
	// Calling this function will enable extra internal bookkeeping to track
	// children and emit signals on the returned listmodel. It may slow down
	// operations a lot.
	//
	// Applications should try hard to avoid calling this function because of
	// the slowdowns.
	ObserveChildren() gio.ListModel
	// ObserveControllers returns a Model to track the EventControllers of
	// @widget.
	//
	// Calling this function will enable extra internal bookkeeping to track
	// controllers and emit signals on the returned listmodel. It may slow down
	// operations a lot.
	//
	// Applications should try hard to avoid calling this function because of
	// the slowdowns.
	ObserveControllers() gio.ListModel
	// Pick finds the descendant of @widget (including @widget itself) closest
	// to the screen at the point (@x, @y). The point must be given in widget
	// coordinates, so (0, 0) is assumed to be the top left of @widget's content
	// area.
	//
	// Usually widgets will return nil if the given coordinate is not contained
	// in @widget checked via gtk_widget_contains(). Otherwise they will
	// recursively try to find a child that does not return nil. Widgets are
	// however free to customize their picking algorithm.
	//
	// This function is used on the toplevel to determine the widget below the
	// mouse cursor for purposes of hover highlighting and delivering events.
	Pick(x float64, y float64, flags PickFlags) Widget
	// QueueAllocate: this function is only for use in widget implementations.
	//
	// Flags the widget for a rerun of the GtkWidgetClass::size_allocate
	// function. Use this function instead of gtk_widget_queue_resize() when the
	// @widget's size request didn't change but it wants to reposition its
	// contents.
	//
	// An example user of this function is gtk_widget_set_halign().
	QueueAllocate()
	// QueueDraw schedules this widget to be redrawn in paint phase of the
	// current or the next frame. This means @widget's GtkWidgetClass.snapshot()
	// implementation will be called.
	QueueDraw()
	// QueueResize: this function is only for use in widget implementations.
	// Flags a widget to have its size renegotiated; should be called when a
	// widget for some reason has a new size request. For example, when you
	// change the text in a Label, Label queues a resize to ensure there’s
	// enough space for the new text.
	//
	// Note that you cannot call gtk_widget_queue_resize() on a widget from
	// inside its implementation of the GtkWidgetClass::size_allocate virtual
	// method. Calls to gtk_widget_queue_resize() from inside
	// GtkWidgetClass::size_allocate will be silently ignored.
	QueueResize()
	// Realize creates the GDK (windowing system) resources associated with a
	// widget. Normally realization happens implicitly; if you show a widget and
	// all its parent containers, then the widget will be realized and mapped
	// automatically.
	//
	// Realizing a widget requires all the widget’s parent widgets to be
	// realized; calling gtk_widget_realize() realizes the widget’s parents in
	// addition to @widget itself. If a widget is not yet inside a toplevel
	// window when you realize it, bad things will happen.
	//
	// This function is primarily used in widget implementations, and isn’t very
	// useful otherwise. Many times when you think you might need it, a better
	// approach is to connect to a signal that will be called after the widget
	// is realized automatically, such as Widget::realize.
	Realize()
	// RemoveController removes @controller from @widget, so that it doesn't
	// process events anymore. It should not be used again.
	//
	// Widgets will remove all event controllers automatically when they are
	// destroyed, there is normally no need to call this function.
	RemoveController(controller EventController)
	// RemoveCSSClass removes @css_class from @widget. After this, the style of
	// @widget will stop matching for @css_class.
	RemoveCSSClass(cssClass string)
	// RemoveMnemonicLabel removes a widget from the list of mnemonic labels for
	// this widget. (See gtk_widget_list_mnemonic_labels()). The widget must
	// have previously been added to the list with
	// gtk_widget_add_mnemonic_label().
	RemoveMnemonicLabel(label Widget)
	// RemoveTickCallback removes a tick callback previously registered with
	// gtk_widget_add_tick_callback().
	RemoveTickCallback(id uint)
	// SetCanFocus specifies whether the input focus can enter the widget or any
	// of its children.
	//
	// Applications should set @can_focus to false to mark a widget as for
	// pointer/touch use only.
	//
	// Note that having @can_focus be true is only one of the necessary
	// conditions for being focusable. A widget must also be sensitive and
	// focusable and not have an ancestor that is marked as not can-focus in
	// order to receive input focus.
	//
	// See gtk_widget_grab_focus() for actually setting the input focus on a
	// widget.
	SetCanFocus(canFocus bool)
	// SetCanTarget sets whether @widget can be the target of pointer events.
	SetCanTarget(canTarget bool)
	// SetChildVisible sets whether @widget should be mapped along with its when
	// its parent is mapped and @widget has been shown with gtk_widget_show().
	//
	// The child visibility can be set for widget before it is added to a
	// container with gtk_widget_set_parent(), to avoid mapping children
	// unnecessary before immediately unmapping them. However it will be reset
	// to its default state of true when the widget is removed from a container.
	//
	// Note that changing the child visibility of a widget does not queue a
	// resize on the widget. Most of the time, the size of a widget is computed
	// from all visible children, whether or not they are mapped. If this is not
	// the case, the container can queue a resize itself.
	//
	// This function is only useful for container implementations and never
	// should be called by an application.
	SetChildVisible(childVisible bool)
	// SetCSSClasses: will clear all css classes applied to @widget and replace
	// them with @classes.
	SetCSSClasses(classes []string)
	// SetCursor sets the cursor to be shown when pointer devices point towards
	// @widget.
	//
	// If the @cursor is NULL, @widget will use the cursor inherited from the
	// parent widget.
	SetCursor(cursor gdk.Cursor)
	// SetCursorFromName sets a named cursor to be shown when pointer devices
	// point towards @widget.
	//
	// This is a utility function that creates a cursor via
	// gdk_cursor_new_from_name() and then sets it on @widget with
	// gtk_widget_set_cursor(). See those 2 functions for details.
	//
	// On top of that, this function allows @name to be nil, which will do the
	// same as calling gtk_widget_set_cursor() with a nil cursor.
	SetCursorFromName(name string)
	// SetDirection sets the reading direction on a particular widget. This
	// direction controls the primary direction for widgets containing text, and
	// also the direction in which the children of a container are packed. The
	// ability to set the direction is present in order so that correct
	// localization into languages with right-to-left reading directions can be
	// done. Generally, applications will let the default reading direction
	// present, except for containers where the containers are arranged in an
	// order that is explicitly visual rather than logical (such as buttons for
	// text justification).
	//
	// If the direction is set to GTK_TEXT_DIR_NONE, then the value set by
	// gtk_widget_set_default_direction() will be used.
	SetDirection(dir TextDirection)
	// SetFocusChild: set @child as the current focus child of @widget. The
	// previous focus child will be unset.
	//
	// This function is only suitable for widget implementations. If you want a
	// certain widget to get the input focus, call gtk_widget_grab_focus() on
	// it.
	SetFocusChild(child Widget)
	// SetFocusOnClick sets whether the widget should grab focus when it is
	// clicked with the mouse. Making mouse clicks not grab focus is useful in
	// places like toolbars where you don’t want the keyboard focus removed from
	// the main area of the application.
	SetFocusOnClick(focusOnClick bool)
	// SetFocusable specifies whether @widget can own the input focus.
	//
	// Widget implementations should set @focusable to true in their init()
	// function if they want to receive keyboard input.
	//
	// Note that having @focusable be true is only one of the necessary
	// conditions for being focusable. A widget must also be sensitive and
	// can-focus and not have an ancestor that is marked as not can-focus in
	// order to receive input focus.
	//
	// See gtk_widget_grab_focus() for actually setting the input focus on a
	// widget.
	SetFocusable(focusable bool)
	// SetFontMap sets the font map to use for Pango rendering. The font map is
	// the object that is used to look up fonts. Setting a custom font map can
	// be useful in special situations, e.g. when you need to add
	// application-specific fonts to the set of available fonts.
	//
	// When not set, the widget will inherit the font map from its parent.
	SetFontMap(fontMap pango.FontMap)
	// SetFontOptions sets the #cairo_font_options_t used for Pango rendering in
	// this widget. When not set, the default font options for the Display will
	// be used.
	SetFontOptions(options *cairo.FontOptions)
	// SetHalign sets the horizontal alignment of @widget. See the Widget:halign
	// property.
	SetHalign(align Align)
	// SetHasTooltip sets the has-tooltip property on @widget to @has_tooltip.
	// See Widget:has-tooltip for more information.
	SetHasTooltip(hasTooltip bool)
	// SetHexpand sets whether the widget would like any available extra
	// horizontal space. When a user resizes a Window, widgets with expand=TRUE
	// generally receive the extra space. For example, a list or scrollable area
	// or document in your window would often be set to expand.
	//
	// Call this function to set the expand flag if you would like your widget
	// to become larger horizontally when the window has extra room.
	//
	// By default, widgets automatically expand if any of their children want to
	// expand. (To see if a widget will automatically expand given its current
	// children and state, call gtk_widget_compute_expand(). A container can
	// decide how the expandability of children affects the expansion of the
	// container by overriding the compute_expand virtual method on Widget.).
	//
	// Setting hexpand explicitly with this function will override the automatic
	// expand behavior.
	//
	// This function forces the widget to expand or not to expand, regardless of
	// children. The override occurs because gtk_widget_set_hexpand() sets the
	// hexpand-set property (see gtk_widget_set_hexpand_set()) which causes the
	// widget’s hexpand value to be used, rather than looking at children and
	// widget state.
	SetHexpand(expand bool)
	// SetHexpandSet sets whether the hexpand flag (see
	// gtk_widget_get_hexpand()) will be used.
	//
	// The hexpand-set property will be set automatically when you call
	// gtk_widget_set_hexpand() to set hexpand, so the most likely reason to use
	// this function would be to unset an explicit expand flag.
	//
	// If hexpand is set, then it overrides any computed expand value based on
	// child widgets. If hexpand is not set, then the expand value depends on
	// whether any children of the widget would like to expand.
	//
	// There are few reasons to use this function, but it’s here for
	// completeness and consistency.
	SetHexpandSet(set bool)
	// SetLayoutManager sets the layout manager delegate instance that provides
	// an implementation for measuring and allocating the children of @widget.
	SetLayoutManager(layoutManager LayoutManager)
	// SetMarginBottom sets the bottom margin of @widget. See the
	// Widget:margin-bottom property.
	SetMarginBottom(margin int)
	// SetMarginEnd sets the end margin of @widget. See the Widget:margin-end
	// property.
	SetMarginEnd(margin int)
	// SetMarginStart sets the start margin of @widget. See the
	// Widget:margin-start property.
	SetMarginStart(margin int)
	// SetMarginTop sets the top margin of @widget. See the Widget:margin-top
	// property.
	SetMarginTop(margin int)
	// SetName widgets can be named, which allows you to refer to them from a
	// CSS file. You can apply a style to widgets with a particular name in the
	// CSS file. See the documentation for the CSS syntax (on the same page as
	// the docs for StyleContext).
	//
	// Note that the CSS syntax has certain special characters to delimit and
	// represent elements in a selector (period, #, >, *...), so using these
	// will make your widget impossible to match by name. Any combination of
	// alphanumeric symbols, dashes and underscores will suffice.
	SetName(name string)
	// SetOpacity: request the @widget to be rendered partially transparent,
	// with opacity 0 being fully transparent and 1 fully opaque. (Opacity
	// values are clamped to the [0,1] range).
	//
	// Opacity works on both toplevel widgets and child widgets, although there
	// are some limitations: For toplevel widgets, applying opacity depends on
	// the capabilities of the windowing system. On X11, this has any effect
	// only on X displays with a compositing manager, see
	// gdk_display_is_composited(). On Windows and Wayland it should always
	// work, although setting a window’s opacity after the window has been shown
	// may cause some flicker.
	//
	// Note that the opacity is inherited through inclusion — if you set a
	// toplevel to be partially translucent, all of its content will appear
	// translucent, since it is ultimatively rendered on that toplevel. The
	// opacity value itself is not inherited by child widgets (since that would
	// make widgets deeper in the hierarchy progressively more translucent). As
	// a consequence, Popovers and other Native widgets with their own surface
	// will use their own opacity value, and thus by default appear
	// non-translucent, even if they are attached to a toplevel that is
	// translucent.
	SetOpacity(opacity float64)
	// SetOverflow sets how @widget treats content that is drawn outside the
	// widget's content area. See the definition of Overflow for details.
	//
	// This setting is provided for widget implementations and should not be
	// used by application code.
	//
	// The default value is GTK_OVERFLOW_VISIBLE.
	SetOverflow(overflow Overflow)
	// SetParent: this function is useful only when implementing subclasses of
	// Widget.
	//
	// Sets @parent as the parent widget of @widget, and takes care of some
	// details such as updating the state and style of the child to reflect its
	// new location and resizing the parent. The opposite function is
	// gtk_widget_unparent().
	SetParent(parent Widget)
	// SetReceivesDefault specifies whether @widget will be treated as the
	// default widget within its toplevel when it has the focus, even if another
	// widget is the default.
	SetReceivesDefault(receivesDefault bool)
	// SetSensitive sets the sensitivity of a widget. A widget is sensitive if
	// the user can interact with it. Insensitive widgets are “grayed out” and
	// the user can’t interact with them. Insensitive widgets are known as
	// “inactive”, “disabled”, or “ghosted” in some other toolkits.
	SetSensitive(sensitive bool)
	// SetSizeRequest sets the minimum size of a widget; that is, the widget’s
	// size request will be at least @width by @height. You can use this
	// function to force a widget to be larger than it normally would be.
	//
	// In most cases, gtk_window_set_default_size() is a better choice for
	// toplevel windows than this function; setting the default size will still
	// allow users to shrink the window. Setting the size request will force
	// them to leave the window at least as large as the size request. When
	// dealing with window sizes, gtk_window_set_geometry_hints() can be a
	// useful function as well.
	//
	// Note the inherent danger of setting any fixed size - themes, translations
	// into other languages, different fonts, and user action can all change the
	// appropriate size for a given widget. So, it's basically impossible to
	// hardcode a size that will always be correct.
	//
	// The size request of a widget is the smallest size a widget can accept
	// while still functioning well and drawing itself correctly. However in
	// some strange cases a widget may be allocated less than its requested
	// size, and in many cases a widget may be allocated more space than it
	// requested.
	//
	// If the size request in a given direction is -1 (unset), then the
	// “natural” size request of the widget will be used instead.
	//
	// The size request set here does not include any margin from the Widget
	// properties margin-left, margin-right, margin-top, and margin-bottom, but
	// it does include pretty much all other padding or border properties set by
	// any subclass of Widget.
	SetSizeRequest(width int, height int)
	// SetStateFlags: this function is for use in widget implementations. Turns
	// on flag values in the current widget state (insensitive, prelighted,
	// etc.).
	//
	// This function accepts the values GTK_STATE_FLAG_DIR_LTR and
	// GTK_STATE_FLAG_DIR_RTL but ignores them. If you want to set the widget's
	// direction, use gtk_widget_set_direction().
	SetStateFlags(flags StateFlags, clear bool)
	// SetTooltipMarkup sets @markup as the contents of the tooltip, which is
	// marked up with the [Pango text markup language][PangoMarkupFormat].
	//
	// This function will take care of setting the Widget:has-tooltip as a side
	// effect, and of the default handler for the Widget::query-tooltip signal.
	//
	// See also the Widget:tooltip-markup property and gtk_tooltip_set_markup().
	SetTooltipMarkup(markup string)
	// SetTooltipText sets @text as the contents of the tooltip.
	//
	// If @text contains any markup, it will be escaped.
	//
	// This function will take care of setting Widget:has-tooltip as a side
	// effect, and of the default handler for the Widget::query-tooltip signal.
	//
	// See also the Widget:tooltip-text property and gtk_tooltip_set_text().
	SetTooltipText(text string)
	// SetValign sets the vertical alignment of @widget. See the Widget:valign
	// property.
	SetValign(align Align)
	// SetVexpand sets whether the widget would like any available extra
	// vertical space.
	//
	// See gtk_widget_set_hexpand() for more detail.
	SetVexpand(expand bool)
	// SetVexpandSet sets whether the vexpand flag (see
	// gtk_widget_get_vexpand()) will be used.
	//
	// See gtk_widget_set_hexpand_set() for more detail.
	SetVexpandSet(set bool)
	// SetVisible sets the visibility state of @widget. Note that setting this
	// to true doesn’t mean the widget is actually viewable, see
	// gtk_widget_get_visible().
	//
	// This function simply calls gtk_widget_show() or gtk_widget_hide() but is
	// nicer to use when the visibility of the widget depends on some condition.
	SetVisible(visible bool)
	// ShouldLayout returns whether @widget should contribute to the measuring
	// and allocation of its parent. This is false for invisible children, but
	// also for children that have their own surface.
	ShouldLayout() bool
	// Show flags a widget to be displayed. Any widget that isn’t shown will not
	// appear on the screen.
	//
	// Remember that you have to show the containers containing a widget, in
	// addition to the widget itself, before it will appear onscreen.
	//
	// When a toplevel container is shown, it is immediately realized and
	// mapped; other shown widgets are realized and mapped when their toplevel
	// container is realized and mapped.
	Show()
	// SizeAllocate: this is a simple form of gtk_widget_allocate() that takes
	// the new position of @widget as part of @allocation.
	SizeAllocate(allocation *Allocation, baseline int)
	// SnapshotChild: when a widget receives a call to the snapshot function, it
	// must send synthetic WidgetClass.snapshot() calls to all children. This
	// function provides a convenient way of doing this. A widget, when it
	// receives a call to its WidgetClass.snapshot() function, calls
	// gtk_widget_snapshot_child() once for each child, passing in the @snapshot
	// the widget received.
	//
	// gtk_widget_snapshot_child() takes care of translating the origin of
	// @snapshot, and deciding whether the child needs to be snapshot.
	//
	// This function does nothing for children that implement Native.
	SnapshotChild(child Widget, snapshot Snapshot)
	// TranslateCoordinates: translate coordinates relative to @src_widget’s
	// allocation to coordinates relative to @dest_widget’s allocations. In
	// order to perform this operation, both widget must share a common
	// toplevel.
	TranslateCoordinates(destWidget Widget, srcX float64, srcY float64) (destX float64, destY float64, ok bool)
	// TriggerTooltipQuery triggers a tooltip query on the display where the
	// toplevel of @widget is located.
	TriggerTooltipQuery()
	// Unmap: this function is only for use in widget implementations. Causes a
	// widget to be unmapped if it’s currently mapped.
	Unmap()
	// Unparent: this function is only for use in widget implementations. It
	// should be called by parent widgets to dissociate @widget from the parent,
	// typically in dispose.
	Unparent()
	// Unrealize: this function is only useful in widget implementations. Causes
	// a widget to be unrealized (frees all GDK resources associated with the
	// widget).
	Unrealize()
	// UnsetStateFlags: this function is for use in widget implementations.
	// Turns off flag values for the current widget state (insensitive,
	// prelighted, etc.). See gtk_widget_set_state_flags().
	UnsetStateFlags(flags StateFlags)
}

type widget struct {
	externglib.InitiallyUnowned
}

// WrapWidget wraps a GObject to the right type. It is
// primarily used internally.
func WrapWidget(obj *externglib.Object) Widget {
	return widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}
}

func marshalWidget(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapWidget(obj), nil
}

// ActionSetEnabled: enable or disable an action installed with
// gtk_widget_class_install_action().
func (widget widget) ActionSetEnabled(actionName string, enabled bool) {
	var arg0 *C.GtkWidget
	var arg1 *C.char
	var arg2 C.gboolean

	arg0 = (*C.GtkWidget)(widget.Native())
	arg1 = (*C.gchar)(C.CString(actionName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = gextras.Cbool(enabled)

	C.gtk_widget_action_set_enabled(arg0, arg1, arg2)
}

// Activate: for widgets that can be “activated” (buttons, menu items, etc.)
// this function activates them. The activation will emit the signal set
// using gtk_widget_class_set_activate_signal() during class initialization.
//
// Activation is what happens when you press Enter on a widget during key
// navigation.
//
// If you wish to handle the activation keybinding yourself, it is
// recommended to use gtk_widget_class_add_shortcut() with an action created
// with gtk_signal_action_new().
//
// If @widget isn't activatable, the function returns false.
func (widget widget) Activate() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_widget_activate(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// ActivateActionVariant looks up the action in the action groups associated
// with @widget and its ancestors, and activates it.
//
// If the action is in an action group added with
// gtk_widget_insert_action_group(), the @name is expected to be prefixed
// with the prefix that was used when the group was inserted.
//
// The arguments must match the actions expected parameter type, as returned
// by g_action_get_parameter_type().
func (widget widget) ActivateActionVariant(name string, args *glib.Variant) bool {
	var arg0 *C.GtkWidget
	var arg1 *C.char
	var arg2 *C.GVariant

	arg0 = (*C.GtkWidget)(widget.Native())
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GVariant)(args.Native())

	ret := C.gtk_widget_activate_action_variant(arg0, arg1, arg2)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// ActivateDefault: activate the default.activate action from @widget.
func (widget widget) ActivateDefault() {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())

	C.gtk_widget_activate_default(arg0)
}

// AddController adds @controller to @widget so that it will receive events.
// You will usually want to call this function right after creating any kind
// of EventController.
func (widget widget) AddController(controller EventController) {
	var arg0 *C.GtkWidget
	var arg1 *C.GtkEventController

	arg0 = (*C.GtkWidget)(widget.Native())
	arg1 = (*C.GtkEventController)(controller.Native())

	C.gtk_widget_add_controller(arg0, arg1)
}

// AddCSSClass adds @css_class to @widget. After calling this function,
// @widget's style will match for @css_class, after the CSS matching rules.
func (widget widget) AddCSSClass(cssClass string) {
	var arg0 *C.GtkWidget
	var arg1 *C.char

	arg0 = (*C.GtkWidget)(widget.Native())
	arg1 = (*C.gchar)(C.CString(cssClass))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_widget_add_css_class(arg0, arg1)
}

// AddMnemonicLabel adds a widget to the list of mnemonic labels for this
// widget. (See gtk_widget_list_mnemonic_labels()). Note the list of
// mnemonic labels for the widget is cleared when the widget is destroyed,
// so the caller must make sure to update its internal state at this point
// as well, by using a connection to the Widget::destroy signal or a weak
// notifier.
func (widget widget) AddMnemonicLabel(label Widget) {
	var arg0 *C.GtkWidget
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())
	arg1 = (*C.GtkWidget)(label.Native())

	C.gtk_widget_add_mnemonic_label(arg0, arg1)
}

// AddTickCallback queues an animation frame update and adds a callback to
// be called before each frame. Until the tick callback is removed, it will
// be called frequently (usually at the frame rate of the output device or
// as quickly as the application can be repainted, whichever is slower). For
// this reason, is most suitable for handling graphics that change every
// frame or every few frames. The tick callback does not automatically imply
// a relayout or repaint. If you want a repaint or relayout, and aren’t
// changing widget properties that would trigger that (for example, changing
// the text of a Label), then you will have to call
// gtk_widget_queue_resize() or gtk_widget_queue_draw() yourself.
//
// gdk_frame_clock_get_frame_time() should generally be used for timing
// continuous animations and
// gdk_frame_timings_get_predicted_presentation_time() if you are trying to
// display isolated frames at particular times.
//
// This is a more convenient alternative to connecting directly to the
// FrameClock::update signal of FrameClock, since you don't have to worry
// about when a FrameClock is assigned to a widget.
func (widget widget) AddTickCallback(callback TickCallback) uint {
	var arg0 *C.GtkWidget
	var arg1 C.GtkTickCallback
	arg2 := C.gpointer(box.Assign(userData))

	arg0 = (*C.GtkWidget)(widget.Native())
	arg1 = (*[0]byte)(C.gotk4_TickCallback)

	ret := C.gtk_widget_add_tick_callback(arg0, arg1, (*[0]byte)(C.callbackDelete))

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// Allocate: this function is only used by Widget subclasses, to assign a
// size, position and (optionally) baseline to their child widgets.
//
// In this function, the allocation and baseline may be adjusted. The given
// allocation will be forced to be bigger than the widget's minimum size, as
// well as at least 0×0 in size.
//
// For a version that does not take a transform, see
// gtk_widget_size_allocate()
func (widget widget) Allocate(width int, height int, baseline int, transform *gsk.Transform) {
	var arg0 *C.GtkWidget
	var arg1 C.int
	var arg2 C.int
	var arg3 C.int
	var arg4 *C.GskTransform

	arg0 = (*C.GtkWidget)(widget.Native())
	arg1 = C.int(width)
	arg2 = C.int(height)
	arg3 = C.int(baseline)
	arg4 = (*C.GskTransform)(transform.Native())

	C.gtk_widget_allocate(arg0, arg1, arg2, arg3, arg4)
}

// ChildFocus: this function is used by custom widget implementations; if
// you're writing an app, you’d use gtk_widget_grab_focus() to move the
// focus to a particular widget.
//
// gtk_widget_child_focus() is called by widgets as the user moves around
// the window using keyboard shortcuts. @direction indicates what kind of
// motion is taking place (up, down, left, right, tab forward, tab
// backward). gtk_widget_child_focus() calls the WidgetClass.focus() vfunc;
// widgets override this vfunc in order to implement appropriate focus
// behavior.
//
// The default focus() vfunc for a widget should return true if moving in
// @direction left the focus on a focusable location inside that widget, and
// false if moving in @direction moved the focus outside the widget. If
// returning true, widgets normally call gtk_widget_grab_focus() to place
// the focus accordingly; if returning false, they don’t modify the current
// focus location.
func (widget widget) ChildFocus(direction DirectionType) bool {
	var arg0 *C.GtkWidget
	var arg1 C.GtkDirectionType

	arg0 = (*C.GtkWidget)(widget.Native())
	arg1 = (C.GtkDirectionType)(direction)

	ret := C.gtk_widget_child_focus(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// ComputeBounds computes the bounds for @widget in the coordinate space of
// @target. FIXME: Explain what "bounds" are.
//
// If the operation is successful, true is returned. If @widget has no
// bounds or the bounds cannot be expressed in @target's coordinate space
// (for example if both widgets are in different windows), false is returned
// and @bounds is set to the zero rectangle.
//
// It is valid for @widget and @target to be the same widget.
func (widget widget) ComputeBounds(target Widget) (outBounds graphene.Rect, ok bool) {
	var arg0 *C.GtkWidget
	var arg1 *C.GtkWidget
	var arg2 *C.graphene_rect_t // out

	arg0 = (*C.GtkWidget)(widget.Native())
	arg1 = (*C.GtkWidget)(target.Native())

	ret := C.gtk_widget_compute_bounds(arg0, arg1, &arg2)

	var ret0 *graphene.Rect
	var ret1 bool

	ret0 = graphene.WrapRect(arg2)

	ret1 = gextras.Gobool(ret)

	return ret0, ret1
}

// ComputeExpand computes whether a container should give this widget extra
// space when possible. Containers should check this, rather than looking at
// gtk_widget_get_hexpand() or gtk_widget_get_vexpand().
//
// This function already checks whether the widget is visible, so visibility
// does not need to be checked separately. Non-visible widgets are not
// expanded.
//
// The computed expand value uses either the expand setting explicitly set
// on the widget itself, or, if none has been explicitly set, the widget may
// expand if some of its children do.
func (widget widget) ComputeExpand(orientation Orientation) bool {
	var arg0 *C.GtkWidget
	var arg1 C.GtkOrientation

	arg0 = (*C.GtkWidget)(widget.Native())
	arg1 = (C.GtkOrientation)(orientation)

	ret := C.gtk_widget_compute_expand(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// ComputePoint translates the given @point in @widget's coordinates to
// coordinates relative to @target’s coordinate system. In order to perform
// this operation, both widgets must share a common root.
func (widget widget) ComputePoint(target Widget, point *graphene.Point) (outPoint graphene.Point, ok bool) {
	var arg0 *C.GtkWidget
	var arg1 *C.GtkWidget
	var arg2 *C.graphene_point_t
	var arg3 *C.graphene_point_t // out

	arg0 = (*C.GtkWidget)(widget.Native())
	arg1 = (*C.GtkWidget)(target.Native())
	arg2 = (*C.graphene_point_t)(point.Native())

	ret := C.gtk_widget_compute_point(arg0, arg1, arg2, &arg3)

	var ret0 *graphene.Point
	var ret1 bool

	ret0 = graphene.WrapPoint(arg3)

	ret1 = gextras.Gobool(ret)

	return ret0, ret1
}

// ComputeTransform computes a matrix suitable to describe a transformation
// from @widget's coordinate system into @target's coordinate system.
func (widget widget) ComputeTransform(target Widget) (outTransform graphene.Matrix, ok bool) {
	var arg0 *C.GtkWidget
	var arg1 *C.GtkWidget
	var arg2 *C.graphene_matrix_t // out

	arg0 = (*C.GtkWidget)(widget.Native())
	arg1 = (*C.GtkWidget)(target.Native())

	ret := C.gtk_widget_compute_transform(arg0, arg1, &arg2)

	var ret0 *graphene.Matrix
	var ret1 bool

	ret0 = graphene.WrapMatrix(arg2)

	ret1 = gextras.Gobool(ret)

	return ret0, ret1
}

// Contains tests if the point at (@x, @y) is contained in @widget.
//
// The coordinates for (@x, @y) must be in widget coordinates, so (0, 0) is
// assumed to be the top left of @widget's content area.
func (widget widget) Contains(x float64, y float64) bool {
	var arg0 *C.GtkWidget
	var arg1 C.double
	var arg2 C.double

	arg0 = (*C.GtkWidget)(widget.Native())
	arg1 = C.double(x)
	arg2 = C.double(y)

	ret := C.gtk_widget_contains(arg0, arg1, arg2)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// CreatePangoContext creates a new Context with the appropriate font map,
// font options, font description, and base direction for drawing text for
// this widget. See also gtk_widget_get_pango_context().
func (widget widget) CreatePangoContext() pango.Context {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_widget_create_pango_context(arg0)

	var ret0 pango.Context

	ret0 = pango.WrapContext(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// CreatePangoLayout creates a new Layout with the appropriate font map,
// font description, and base direction for drawing text for this widget.
//
// If you keep a Layout created in this way around, you need to re-create it
// when the widget Context is replaced. This can be tracked by listening to
// changes of the Widget:root property on the widget.
func (widget widget) CreatePangoLayout(text string) pango.Layout {
	var arg0 *C.GtkWidget
	var arg1 *C.char

	arg0 = (*C.GtkWidget)(widget.Native())
	arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_widget_create_pango_layout(arg0, arg1)

	var ret0 pango.Layout

	ret0 = pango.WrapLayout(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// DragCheckThreshold checks to see if a mouse drag starting at (@start_x,
// @start_y) and ending at (@current_x, @current_y) has passed the GTK drag
// threshold, and thus should trigger the beginning of a drag-and-drop
// operation.
func (widget widget) DragCheckThreshold(startX int, startY int, currentX int, currentY int) bool {
	var arg0 *C.GtkWidget
	var arg1 C.int
	var arg2 C.int
	var arg3 C.int
	var arg4 C.int

	arg0 = (*C.GtkWidget)(widget.Native())
	arg1 = C.int(startX)
	arg2 = C.int(startY)
	arg3 = C.int(currentX)
	arg4 = C.int(currentY)

	ret := C.gtk_drag_check_threshold(arg0, arg1, arg2, arg3, arg4)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// ErrorBell notifies the user about an input-related error on this widget.
// If the Settings:gtk-error-bell setting is true, it calls
// gdk_surface_beep(), otherwise it does nothing.
//
// Note that the effect of gdk_surface_beep() can be configured in many
// ways, depending on the windowing backend and the desktop environment or
// window manager that is used.
func (widget widget) ErrorBell() {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())

	C.gtk_widget_error_bell(arg0)
}

// AllocatedBaseline returns the baseline that has currently been allocated
// to @widget. This function is intended to be used when implementing
// handlers for the WidgetClass.snapshot() function, and when allocating
// child widgets in WidgetClass.size_allocate().
func (widget widget) AllocatedBaseline() int {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_widget_get_allocated_baseline(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// AllocatedHeight returns the height that has currently been allocated to
// @widget.
func (widget widget) AllocatedHeight() int {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_widget_get_allocated_height(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// AllocatedWidth returns the width that has currently been allocated to
// @widget.
func (widget widget) AllocatedWidth() int {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_widget_get_allocated_width(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Allocation retrieves the widget’s allocation.
//
// Note, when implementing a layout container: a widget’s allocation will be
// its “adjusted” allocation, that is, the widget’s parent typically calls
// gtk_widget_size_allocate() with an allocation, and that allocation is
// then adjusted (to handle margin and alignment for example) before
// assignment to the widget. gtk_widget_get_allocation() returns the
// adjusted allocation that was actually assigned to the widget. The
// adjusted allocation is guaranteed to be completely contained within the
// gtk_widget_size_allocate() allocation, however.
//
// So a layout container is guaranteed that its children stay inside the
// assigned bounds, but not that they have exactly the bounds the container
// assigned.
func (widget widget) Allocation() Allocation {
	var arg0 *C.GtkWidget
	var arg1 *C.GtkAllocation // out

	arg0 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_widget_get_allocation(arg0, &arg1)

	var ret0 *Allocation

	{
		var tmp gdk.Rectangle
		tmp = gdk.WrapRectangle(arg1)
		ret0 = *Allocation(tmp)
	}

	return ret0
}

// Ancestor gets the first ancestor of @widget with type @widget_type. For
// example, `gtk_widget_get_ancestor (widget, GTK_TYPE_BOX)` gets the first
// Box that’s an ancestor of @widget. No reference will be added to the
// returned widget; it should not be unreferenced.
//
// Note that unlike gtk_widget_is_ancestor(), gtk_widget_get_ancestor()
// considers @widget to be an ancestor of itself.
func (widget widget) Ancestor(widgetType externglib.Type) Widget {
	var arg0 *C.GtkWidget
	var arg1 C.GType

	arg0 = (*C.GtkWidget)(widget.Native())
	arg1 = C.GType(widgetType)

	ret := C.gtk_widget_get_ancestor(arg0, arg1)

	var ret0 Widget

	ret0 = WrapWidget(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// CanFocus determines whether the input focus can enter @widget or any of
// its children.
//
// See gtk_widget_set_focusable().
func (widget widget) CanFocus() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_widget_get_can_focus(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// CanTarget queries whether @widget can be the target of pointer events.
func (widget widget) CanTarget() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_widget_get_can_target(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// ChildVisible gets the value set with gtk_widget_set_child_visible(). If
// you feel a need to use this function, your code probably needs
// reorganization.
//
// This function is only useful for container implementations and never
// should be called by an application.
func (widget widget) ChildVisible() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_widget_get_child_visible(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Clipboard: this is a utility function to get the clipboard object for the
// Display that @widget is using.
//
// Note that this function always works, even when @widget is not realized
// yet.
func (widget widget) Clipboard() gdk.Clipboard {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_widget_get_clipboard(arg0)

	var ret0 gdk.Clipboard

	ret0 = gdk.WrapClipboard(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// CSSClasses returns the list of css classes applied to @widget.
func (widget widget) CSSClasses() []string {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_widget_get_css_classes(arg0)

	var ret0 []string

	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]string, length)
		for i := 0; i < length; i++ {
			src := (C.utf8)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			ret0[i] = C.GoString(src)
			C.free(unsafe.Pointer(src))
		}
	}

	return ret0
}

// CSSName returns the CSS name that is used for @self.
func (self widget) CSSName() string {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(self.Native())

	ret := C.gtk_widget_get_css_name(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Cursor queries the cursor set via gtk_widget_set_cursor(). See that
// function for details.
func (widget widget) Cursor() gdk.Cursor {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_widget_get_cursor(arg0)

	var ret0 gdk.Cursor

	ret0 = gdk.WrapCursor(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Direction gets the reading direction for a particular widget. See
// gtk_widget_set_direction().
func (widget widget) Direction() TextDirection {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_widget_get_direction(arg0)

	var ret0 TextDirection

	ret0 = TextDirection(ret)

	return ret0
}

// Display: get the Display for the toplevel window associated with this
// widget. This function can only be called after the widget has been added
// to a widget hierarchy with a Window at the top.
//
// In general, you should only create display specific resources when a
// widget has been realized, and you should free those resources when the
// widget is unrealized.
func (widget widget) Display() gdk.Display {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_widget_get_display(arg0)

	var ret0 gdk.Display

	ret0 = gdk.WrapDisplay(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// FirstChild returns the widgets first child.
//
// This API is primarily meant for widget implementations.
func (widget widget) FirstChild() Widget {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_widget_get_first_child(arg0)

	var ret0 Widget

	ret0 = WrapWidget(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// FocusChild returns the current focus child of @widget.
func (widget widget) FocusChild() Widget {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_widget_get_focus_child(arg0)

	var ret0 Widget

	ret0 = WrapWidget(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// FocusOnClick returns whether the widget should grab focus when it is
// clicked with the mouse. See gtk_widget_set_focus_on_click().
func (widget widget) FocusOnClick() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_widget_get_focus_on_click(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Focusable determines whether @widget can own the input focus. See
// gtk_widget_set_focusable().
func (widget widget) Focusable() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_widget_get_focusable(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// FontMap gets the font map that has been set with
// gtk_widget_set_font_map().
func (widget widget) FontMap() pango.FontMap {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_widget_get_font_map(arg0)

	var ret0 pango.FontMap

	ret0 = pango.WrapFontMap(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// FontOptions returns the #cairo_font_options_t used for Pango rendering.
// When not set, the defaults font options for the Display will be used.
func (widget widget) FontOptions() *cairo.FontOptions {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_widget_get_font_options(arg0)

	var ret0 *cairo.FontOptions

	ret0 = cairo.WrapFontOptions(ret)

	return ret0
}

// FrameClock obtains the frame clock for a widget. The frame clock is a
// global “ticker” that can be used to drive animations and repaints. The
// most common reason to get the frame clock is to call
// gdk_frame_clock_get_frame_time(), in order to get a time to use for
// animating. For example you might record the start of the animation with
// an initial value from gdk_frame_clock_get_frame_time(), and then update
// the animation by calling gdk_frame_clock_get_frame_time() again during
// each repaint.
//
// gdk_frame_clock_request_phase() will result in a new frame on the clock,
// but won’t necessarily repaint any widgets. To repaint a widget, you have
// to use gtk_widget_queue_draw() which invalidates the widget (thus
// scheduling it to receive a draw on the next frame).
// gtk_widget_queue_draw() will also end up requesting a frame on the
// appropriate frame clock.
//
// A widget’s frame clock will not change while the widget is mapped.
// Reparenting a widget (which implies a temporary unmap) can change the
// widget’s frame clock.
//
// Unrealized widgets do not have a frame clock.
func (widget widget) FrameClock() gdk.FrameClock {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_widget_get_frame_clock(arg0)

	var ret0 gdk.FrameClock

	ret0 = gdk.WrapFrameClock(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Halign gets the value of the Widget:halign property.
//
// For backwards compatibility reasons this method will never return
// GTK_ALIGN_BASELINE, but instead it will convert it to GTK_ALIGN_FILL.
// Baselines are not supported for horizontal alignment.
func (widget widget) Halign() Align {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_widget_get_halign(arg0)

	var ret0 Align

	ret0 = Align(ret)

	return ret0
}

// HasTooltip returns the current value of the has-tooltip property. See
// Widget:has-tooltip for more information.
func (widget widget) HasTooltip() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_widget_get_has_tooltip(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Height returns the content height of the widget, as passed to its
// size-allocate implementation. This is the size you should be using in
// GtkWidgetClass.snapshot(). For pointer events, see gtk_widget_contains().
func (widget widget) Height() int {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_widget_get_height(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Hexpand gets whether the widget would like any available extra horizontal
// space. When a user resizes a Window, widgets with expand=TRUE generally
// receive the extra space. For example, a list or scrollable area or
// document in your window would often be set to expand.
//
// Containers should use gtk_widget_compute_expand() rather than this
// function, to see whether a widget, or any of its children, has the expand
// flag set. If any child of a widget wants to expand, the parent may ask to
// expand also.
//
// This function only looks at the widget’s own hexpand flag, rather than
// computing whether the entire widget tree rooted at this widget wants to
// expand.
func (widget widget) Hexpand() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_widget_get_hexpand(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// HexpandSet gets whether gtk_widget_set_hexpand() has been used to
// explicitly set the expand flag on this widget.
//
// If hexpand is set, then it overrides any computed expand value based on
// child widgets. If hexpand is not set, then the expand value depends on
// whether any children of the widget would like to expand.
//
// There are few reasons to use this function, but it’s here for
// completeness and consistency.
func (widget widget) HexpandSet() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_widget_get_hexpand_set(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// LastChild returns the widgets last child.
//
// This API is primarily meant for widget implementations.
func (widget widget) LastChild() Widget {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_widget_get_last_child(arg0)

	var ret0 Widget

	ret0 = WrapWidget(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// LayoutManager retrieves the layout manager set using
// gtk_widget_set_layout_manager().
func (widget widget) LayoutManager() LayoutManager {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_widget_get_layout_manager(arg0)

	var ret0 LayoutManager

	ret0 = WrapLayoutManager(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Mapped: whether the widget is mapped.
func (widget widget) Mapped() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_widget_get_mapped(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// MarginBottom gets the value of the Widget:margin-bottom property.
func (widget widget) MarginBottom() int {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_widget_get_margin_bottom(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// MarginEnd gets the value of the Widget:margin-end property.
func (widget widget) MarginEnd() int {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_widget_get_margin_end(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// MarginStart gets the value of the Widget:margin-start property.
func (widget widget) MarginStart() int {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_widget_get_margin_start(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// MarginTop gets the value of the Widget:margin-top property.
func (widget widget) MarginTop() int {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_widget_get_margin_top(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Name retrieves the name of a widget. See gtk_widget_set_name() for the
// significance of widget names.
func (widget widget) Name() string {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_widget_get_name(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Native returns the GtkNative widget that contains @widget, or nil if the
// widget is not contained inside a widget tree with a native ancestor.
//
// Native widgets will return themselves here.
func (widget widget) Native() Native {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_widget_get_native(arg0)

	var ret0 Native

	return ret0
}

// NextSibling returns the widgets next sibling.
//
// This API is primarily meant for widget implementations.
func (widget widget) NextSibling() Widget {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_widget_get_next_sibling(arg0)

	var ret0 Widget

	ret0 = WrapWidget(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Opacity fetches the requested opacity for this widget. See
// gtk_widget_set_opacity().
func (widget widget) Opacity() float64 {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_widget_get_opacity(arg0)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// Overflow returns the value set via gtk_widget_set_overflow().
func (widget widget) Overflow() Overflow {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_widget_get_overflow(arg0)

	var ret0 Overflow

	ret0 = Overflow(ret)

	return ret0
}

// PangoContext gets a Context with the appropriate font map, font
// description, and base direction for this widget. Unlike the context
// returned by gtk_widget_create_pango_context(), this context is owned by
// the widget (it can be used until the screen for the widget changes or the
// widget is removed from its toplevel), and will be updated to match any
// changes to the widget’s attributes. This can be tracked by listening to
// changes of the Widget:root property on the widget.
func (widget widget) PangoContext() pango.Context {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_widget_get_pango_context(arg0)

	var ret0 pango.Context

	ret0 = pango.WrapContext(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Parent returns the parent widget of @widget.
func (widget widget) Parent() Widget {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_widget_get_parent(arg0)

	var ret0 Widget

	ret0 = WrapWidget(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// PreferredSize retrieves the minimum and natural size of a widget, taking
// into account the widget’s preference for height-for-width management.
//
// This is used to retrieve a suitable size by container widgets which do
// not impose any restrictions on the child placement. It can be used to
// deduce toplevel window and menu sizes as well as child widgets in
// free-form containers such as GtkLayout.
//
// Handle with care. Note that the natural height of a height-for-width
// widget will generally be a smaller size than the minimum height, since
// the required height for the natural width is generally smaller than the
// required height for the minimum width.
//
// Use gtk_widget_measure() if you want to support baseline alignment.
func (widget widget) PreferredSize() (minimumSize Requisition, naturalSize Requisition) {
	var arg0 *C.GtkWidget
	var arg1 *C.GtkRequisition // out
	var arg2 *C.GtkRequisition // out

	arg0 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_widget_get_preferred_size(arg0, &arg1, &arg2)

	var ret0 *Requisition
	var ret1 *Requisition

	ret0 = WrapRequisition(arg1)

	ret1 = WrapRequisition(arg2)

	return ret0, ret1
}

// PrevSibling returns the widgets previous sibling.
//
// This API is primarily meant for widget implementations.
func (widget widget) PrevSibling() Widget {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_widget_get_prev_sibling(arg0)

	var ret0 Widget

	ret0 = WrapWidget(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// PrimaryClipboard: this is a utility function to get the primary clipboard
// object for the Display that @widget is using.
//
// Note that this function always works, even when @widget is not realized
// yet.
func (widget widget) PrimaryClipboard() gdk.Clipboard {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_widget_get_primary_clipboard(arg0)

	var ret0 gdk.Clipboard

	ret0 = gdk.WrapClipboard(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Realized determines whether @widget is realized.
func (widget widget) Realized() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_widget_get_realized(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// ReceivesDefault determines whether @widget is always treated as the
// default widget within its toplevel when it has the focus, even if another
// widget is the default.
//
// See gtk_widget_set_receives_default().
func (widget widget) ReceivesDefault() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_widget_get_receives_default(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// RequestMode gets whether the widget prefers a height-for-width layout or
// a width-for-height layout.
//
// Bin widgets generally propagate the preference of their child, container
// widgets need to request something either in context of their children or
// in context of their allocation capabilities.
func (widget widget) RequestMode() SizeRequestMode {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_widget_get_request_mode(arg0)

	var ret0 SizeRequestMode

	ret0 = SizeRequestMode(ret)

	return ret0
}

// Root returns the Root widget of @widget or nil if the widget is not
// contained inside a widget tree with a root widget.
//
// Root widgets will return themselves here.
func (widget widget) Root() Root {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_widget_get_root(arg0)

	var ret0 Root

	return ret0
}

// ScaleFactor retrieves the internal scale factor that maps from window
// coordinates to the actual device pixels. On traditional systems this is
// 1, on high density outputs, it can be a higher value (typically 2).
//
// See gdk_surface_get_scale_factor().
func (widget widget) ScaleFactor() int {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_widget_get_scale_factor(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Sensitive returns the widget’s sensitivity (in the sense of returning the
// value that has been set using gtk_widget_set_sensitive()).
//
// The effective sensitivity of a widget is however determined by both its
// own and its parent widget’s sensitivity. See gtk_widget_is_sensitive().
func (widget widget) Sensitive() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_widget_get_sensitive(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Settings gets the settings object holding the settings used for this
// widget.
//
// Note that this function can only be called when the Widget is attached to
// a toplevel, since the settings object is specific to a particular
// Display. If you want to monitor the widget for changes in its settings,
// connect to notify::display.
func (widget widget) Settings() Settings {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_widget_get_settings(arg0)

	var ret0 Settings

	ret0 = WrapSettings(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Size returns the content width or height of the widget, depending on
// @orientation. This is equivalent to calling gtk_widget_get_width() for
// GTK_ORIENTATION_HORIZONTAL or gtk_widget_get_height() for
// GTK_ORIENTATION_VERTICAL, but can be used when writing
// orientation-independent code, such as when implementing Orientable
// widgets.
func (widget widget) Size(orientation Orientation) int {
	var arg0 *C.GtkWidget
	var arg1 C.GtkOrientation

	arg0 = (*C.GtkWidget)(widget.Native())
	arg1 = (C.GtkOrientation)(orientation)

	ret := C.gtk_widget_get_size(arg0, arg1)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// SizeRequest gets the size request that was explicitly set for the widget
// using gtk_widget_set_size_request(). A value of -1 stored in @width or
// @height indicates that that dimension has not been set explicitly and the
// natural requisition of the widget will be used instead. See
// gtk_widget_set_size_request(). To get the size a widget will actually
// request, call gtk_widget_measure() instead of this function.
func (widget widget) SizeRequest() (width int, height int) {
	var arg0 *C.GtkWidget
	var arg1 *C.int // out
	var arg2 *C.int // out

	arg0 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_widget_get_size_request(arg0, &arg1, &arg2)

	var ret0 int
	var ret1 int

	ret0 = int(arg1)

	ret1 = int(arg2)

	return ret0, ret1
}

// StateFlags returns the widget state as a flag set. It is worth mentioning
// that the effective GTK_STATE_FLAG_INSENSITIVE state will be returned,
// that is, also based on parent insensitivity, even if @widget itself is
// sensitive.
//
// Also note that if you are looking for a way to obtain the StateFlags to
// pass to a StyleContext method, you should look at
// gtk_style_context_get_state().
func (widget widget) StateFlags() StateFlags {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_widget_get_state_flags(arg0)

	var ret0 StateFlags

	ret0 = StateFlags(ret)

	return ret0
}

// StyleContext returns the style context associated to @widget. The
// returned object is guaranteed to be the same for the lifetime of @widget.
func (widget widget) StyleContext() StyleContext {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_widget_get_style_context(arg0)

	var ret0 StyleContext

	ret0 = WrapStyleContext(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// TemplateChild: fetch an object build from the template XML for
// @widget_type in this @widget instance.
//
// This will only report children which were previously declared with
// gtk_widget_class_bind_template_child_full() or one of its variants.
//
// This function is only meant to be called for code which is private to the
// @widget_type which declared the child and is meant for language bindings
// which cannot easily make use of the GObject structure offsets.
func (widget widget) TemplateChild(widgetType externglib.Type, name string) gextras.Objector {
	var arg0 *C.GtkWidget
	var arg1 C.GType
	var arg2 *C.char

	arg0 = (*C.GtkWidget)(widget.Native())
	arg1 = C.GType(widgetType)
	arg2 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.gtk_widget_get_template_child(arg0, arg1, arg2)

	var ret0 gextras.Objector

	ret0 = externglib.Take(unsafe.Pointer(ret.Native()))

	return ret0
}

// TooltipMarkup gets the contents of the tooltip for @widget set using
// gtk_widget_set_tooltip_markup().
func (widget widget) TooltipMarkup() string {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_widget_get_tooltip_markup(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// TooltipText gets the contents of the tooltip for @widget.
//
// If the @widget's tooltip was set using gtk_widget_set_tooltip_markup(),
// this function will return the escaped text.
func (widget widget) TooltipText() string {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_widget_get_tooltip_text(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Valign gets the value of the Widget:valign property.
func (widget widget) Valign() Align {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_widget_get_valign(arg0)

	var ret0 Align

	ret0 = Align(ret)

	return ret0
}

// Vexpand gets whether the widget would like any available extra vertical
// space.
//
// See gtk_widget_get_hexpand() for more detail.
func (widget widget) Vexpand() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_widget_get_vexpand(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// VexpandSet gets whether gtk_widget_set_vexpand() has been used to
// explicitly set the expand flag on this widget.
//
// See gtk_widget_get_hexpand_set() for more detail.
func (widget widget) VexpandSet() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_widget_get_vexpand_set(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Visible determines whether the widget is visible. If you want to take
// into account whether the widget’s parent is also marked as visible, use
// gtk_widget_is_visible() instead.
//
// This function does not check if the widget is obscured in any way.
//
// See gtk_widget_set_visible().
func (widget widget) Visible() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_widget_get_visible(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Width returns the content width of the widget, as passed to its
// size-allocate implementation. This is the size you should be using in
// GtkWidgetClass.snapshot(). For pointer events, see gtk_widget_contains().
func (widget widget) Width() int {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_widget_get_width(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// GrabFocus causes @widget (or one of its descendents) to have the keyboard
// focus for the Window it's inside.
//
// If @widget is not focusable, or its ::grab_focus implementation cannot
// transfer the focus to a descendant of @widget that is focusable, it will
// not take focus and false will be returned.
//
// Calling gtk_widget_grab_focus() on an already focused widget is allowed,
// should not have an effect, and return true.
func (widget widget) GrabFocus() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_widget_grab_focus(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// HasCSSClass returns whether @css_class is currently applied to @widget.
func (widget widget) HasCSSClass(cssClass string) bool {
	var arg0 *C.GtkWidget
	var arg1 *C.char

	arg0 = (*C.GtkWidget)(widget.Native())
	arg1 = (*C.gchar)(C.CString(cssClass))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_widget_has_css_class(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// HasDefault determines whether @widget is the current default widget
// within its toplevel.
func (widget widget) HasDefault() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_widget_has_default(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// HasFocus determines if the widget has the global input focus. See
// gtk_widget_is_focus() for the difference between having the global input
// focus, and only having the focus within a toplevel.
func (widget widget) HasFocus() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_widget_has_focus(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// HasVisibleFocus determines if the widget should show a visible indication
// that it has the global input focus. This is a convenience function that
// takes into account whether focus indication should currently be shown in
// the toplevel window of @widget. See gtk_window_get_focus_visible() for
// more information about focus indication.
//
// To find out if the widget has the global input focus, use
// gtk_widget_has_focus().
func (widget widget) HasVisibleFocus() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_widget_has_visible_focus(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Hide reverses the effects of gtk_widget_show(), causing the widget to be
// hidden (invisible to the user).
func (widget widget) Hide() {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())

	C.gtk_widget_hide(arg0)
}

// InDestruction returns whether the widget is currently being destroyed.
// This information can sometimes be used to avoid doing unnecessary work.
func (widget widget) InDestruction() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_widget_in_destruction(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// InitTemplate creates and initializes child widgets defined in templates.
// This function must be called in the instance initializer for any class
// which assigned itself a template using gtk_widget_class_set_template()
//
// It is important to call this function in the instance initializer of a
// Widget subclass and not in #GObject.constructed() or
// #GObject.constructor() for two reasons.
//
// One reason is that generally derived widgets will assume that parent
// class composite widgets have been created in their instance initializers.
//
// Another reason is that when calling g_object_new() on a widget with
// composite templates, it’s important to build the composite widgets before
// the construct properties are set. Properties passed to g_object_new()
// should take precedence over properties set in the private template XML.
func (widget widget) InitTemplate() {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())

	C.gtk_widget_init_template(arg0)
}

// InsertActionGroup inserts @group into @widget. Children of @widget that
// implement Actionable can then be associated with actions in @group by
// setting their “action-name” to @prefix.`action-name`.
//
// Note that inheritance is defined for individual actions. I.e. even if you
// insert a group with prefix @prefix, actions with the same prefix will
// still be inherited from the parent, unless the group contains an action
// with the same name.
//
// If @group is nil, a previously inserted group for @name is removed from
// @widget.
func (widget widget) InsertActionGroup(name string, group gio.ActionGroup) {
	var arg0 *C.GtkWidget
	var arg1 *C.char
	var arg2 *C.GActionGroup

	arg0 = (*C.GtkWidget)(widget.Native())
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_widget_insert_action_group(arg0, arg1, arg2)
}

// InsertAfter inserts @widget into the child widget list of @parent.
//
// It will be placed after @previous_sibling, or at the beginning if
// @previous_sibling is nil.
//
// After calling this function, gtk_widget_get_prev_sibling(widget) will
// return @previous_sibling.
//
// If @parent is already set as the parent widget of @widget, this function
// can also be used to reorder @widget in the child widget list of @parent.
//
// This API is primarily meant for widget implementations; if you are just
// using a widget, you *must* use its own API for adding children.
func (widget widget) InsertAfter(parent Widget, previousSibling Widget) {
	var arg0 *C.GtkWidget
	var arg1 *C.GtkWidget
	var arg2 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())
	arg1 = (*C.GtkWidget)(parent.Native())
	arg2 = (*C.GtkWidget)(previousSibling.Native())

	C.gtk_widget_insert_after(arg0, arg1, arg2)
}

// InsertBefore inserts @widget into the child widget list of @parent.
//
// It will be placed before @next_sibling, or at the end if @next_sibling is
// nil.
//
// After calling this function, gtk_widget_get_next_sibling(widget) will
// return @next_sibling.
//
// If @parent is already set as the parent widget of @widget, this function
// can also be used to reorder @widget in the child widget list of @parent.
//
// This API is primarily meant for widget implementations; if you are just
// using a widget, you *must* use its own API for adding children.
func (widget widget) InsertBefore(parent Widget, nextSibling Widget) {
	var arg0 *C.GtkWidget
	var arg1 *C.GtkWidget
	var arg2 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())
	arg1 = (*C.GtkWidget)(parent.Native())
	arg2 = (*C.GtkWidget)(nextSibling.Native())

	C.gtk_widget_insert_before(arg0, arg1, arg2)
}

// IsAncestor determines whether @widget is somewhere inside @ancestor,
// possibly with intermediate containers.
func (widget widget) IsAncestor(ancestor Widget) bool {
	var arg0 *C.GtkWidget
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())
	arg1 = (*C.GtkWidget)(ancestor.Native())

	ret := C.gtk_widget_is_ancestor(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// IsDrawable determines whether @widget can be drawn to. A widget can be
// drawn if it is mapped and visible.
func (widget widget) IsDrawable() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_widget_is_drawable(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// IsFocus determines if the widget is the focus widget within its toplevel.
// (This does not mean that the Widget:has-focus property is necessarily
// set; Widget:has-focus will only be set if the toplevel widget
// additionally has the global input focus.)
func (widget widget) IsFocus() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_widget_is_focus(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// IsSensitive returns the widget’s effective sensitivity, which means it is
// sensitive itself and also its parent widget is sensitive
func (widget widget) IsSensitive() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_widget_is_sensitive(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// IsVisible determines whether the widget and all its parents are marked as
// visible.
//
// This function does not check if the widget is obscured in any way.
//
// See also gtk_widget_get_visible() and gtk_widget_set_visible()
func (widget widget) IsVisible() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_widget_is_visible(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// KeynavFailed: this function should be called whenever keyboard navigation
// within a single widget hits a boundary. The function emits the
// Widget::keynav-failed signal on the widget and its return value should be
// interpreted in a way similar to the return value of
// gtk_widget_child_focus():
//
// When true is returned, stay in the widget, the failed keyboard navigation
// is OK and/or there is nowhere we can/should move the focus to.
//
// When false is returned, the caller should continue with keyboard
// navigation outside the widget, e.g. by calling gtk_widget_child_focus()
// on the widget’s toplevel.
//
// The default ::keynav-failed handler returns false for GTK_DIR_TAB_FORWARD
// and GTK_DIR_TAB_BACKWARD. For the other values of DirectionType it
// returns true.
//
// Whenever the default handler returns true, it also calls
// gtk_widget_error_bell() to notify the user of the failed keyboard
// navigation.
//
// A use case for providing an own implementation of ::keynav-failed (either
// by connecting to it or by overriding it) would be a row of Entry widgets
// where the user should be able to navigate the entire row with the cursor
// keys, as e.g. known from user interfaces that require entering license
// keys.
func (widget widget) KeynavFailed(direction DirectionType) bool {
	var arg0 *C.GtkWidget
	var arg1 C.GtkDirectionType

	arg0 = (*C.GtkWidget)(widget.Native())
	arg1 = (C.GtkDirectionType)(direction)

	ret := C.gtk_widget_keynav_failed(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// ListMnemonicLabels returns a newly allocated list of the widgets,
// normally labels, for which this widget is the target of a mnemonic (see
// for example, gtk_label_set_mnemonic_widget()).
//
// The widgets in the list are not individually referenced. If you want to
// iterate through the list and perform actions involving callbacks that
// might destroy the widgets, you must call `g_list_foreach (result,
// (GFunc)g_object_ref, NULL)` first, and then unref all the widgets
// afterwards.
func (widget widget) ListMnemonicLabels() *glib.List {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_widget_list_mnemonic_labels(arg0)

	var ret0 *glib.List

	ret0 = glib.WrapList(ret)

	return ret0
}

// Map: this function is only for use in widget implementations. Causes a
// widget to be mapped if it isn’t already.
func (widget widget) Map() {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())

	C.gtk_widget_map(arg0)
}

// Measure measures @widget in the orientation @orientation and for the
// given @for_size. As an example, if @orientation is
// GTK_ORIENTATION_HORIZONTAL and @for_size is 300, this functions will
// compute the minimum and natural width of @widget if it is allocated at a
// height of 300 pixels.
//
// See [GtkWidget’s geometry management section][geometry-management] for a
// more details on implementing WidgetClass.measure().
func (widget widget) Measure(orientation Orientation, forSize int) (minimum int, natural int, minimumBaseline int, naturalBaseline int) {
	var arg0 *C.GtkWidget
	var arg1 C.GtkOrientation
	var arg2 C.int
	var arg3 *C.int // out
	var arg4 *C.int // out
	var arg5 *C.int // out
	var arg6 *C.int // out

	arg0 = (*C.GtkWidget)(widget.Native())
	arg1 = (C.GtkOrientation)(orientation)
	arg2 = C.int(forSize)

	ret := C.gtk_widget_measure(arg0, arg1, arg2, &arg3, &arg4, &arg5, &arg6)

	var ret0 int
	var ret1 int
	var ret2 int
	var ret3 int

	ret0 = int(arg3)

	ret1 = int(arg4)

	ret2 = int(arg5)

	ret3 = int(arg6)

	return ret0, ret1, ret2, ret3
}

// MnemonicActivate emits the Widget::mnemonic-activate signal.
func (widget widget) MnemonicActivate(groupCycling bool) bool {
	var arg0 *C.GtkWidget
	var arg1 C.gboolean

	arg0 = (*C.GtkWidget)(widget.Native())
	arg1 = gextras.Cbool(groupCycling)

	ret := C.gtk_widget_mnemonic_activate(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// ObserveChildren returns a Model to track the children of @widget.
//
// Calling this function will enable extra internal bookkeeping to track
// children and emit signals on the returned listmodel. It may slow down
// operations a lot.
//
// Applications should try hard to avoid calling this function because of
// the slowdowns.
func (widget widget) ObserveChildren() gio.ListModel {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_widget_observe_children(arg0)

	var ret0 gio.ListModel

	return ret0
}

// ObserveControllers returns a Model to track the EventControllers of
// @widget.
//
// Calling this function will enable extra internal bookkeeping to track
// controllers and emit signals on the returned listmodel. It may slow down
// operations a lot.
//
// Applications should try hard to avoid calling this function because of
// the slowdowns.
func (widget widget) ObserveControllers() gio.ListModel {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_widget_observe_controllers(arg0)

	var ret0 gio.ListModel

	return ret0
}

// Pick finds the descendant of @widget (including @widget itself) closest
// to the screen at the point (@x, @y). The point must be given in widget
// coordinates, so (0, 0) is assumed to be the top left of @widget's content
// area.
//
// Usually widgets will return nil if the given coordinate is not contained
// in @widget checked via gtk_widget_contains(). Otherwise they will
// recursively try to find a child that does not return nil. Widgets are
// however free to customize their picking algorithm.
//
// This function is used on the toplevel to determine the widget below the
// mouse cursor for purposes of hover highlighting and delivering events.
func (widget widget) Pick(x float64, y float64, flags PickFlags) Widget {
	var arg0 *C.GtkWidget
	var arg1 C.double
	var arg2 C.double
	var arg3 C.GtkPickFlags

	arg0 = (*C.GtkWidget)(widget.Native())
	arg1 = C.double(x)
	arg2 = C.double(y)
	arg3 = (C.GtkPickFlags)(flags)

	ret := C.gtk_widget_pick(arg0, arg1, arg2, arg3)

	var ret0 Widget

	ret0 = WrapWidget(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// QueueAllocate: this function is only for use in widget implementations.
//
// Flags the widget for a rerun of the GtkWidgetClass::size_allocate
// function. Use this function instead of gtk_widget_queue_resize() when the
// @widget's size request didn't change but it wants to reposition its
// contents.
//
// An example user of this function is gtk_widget_set_halign().
func (widget widget) QueueAllocate() {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())

	C.gtk_widget_queue_allocate(arg0)
}

// QueueDraw schedules this widget to be redrawn in paint phase of the
// current or the next frame. This means @widget's GtkWidgetClass.snapshot()
// implementation will be called.
func (widget widget) QueueDraw() {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())

	C.gtk_widget_queue_draw(arg0)
}

// QueueResize: this function is only for use in widget implementations.
// Flags a widget to have its size renegotiated; should be called when a
// widget for some reason has a new size request. For example, when you
// change the text in a Label, Label queues a resize to ensure there’s
// enough space for the new text.
//
// Note that you cannot call gtk_widget_queue_resize() on a widget from
// inside its implementation of the GtkWidgetClass::size_allocate virtual
// method. Calls to gtk_widget_queue_resize() from inside
// GtkWidgetClass::size_allocate will be silently ignored.
func (widget widget) QueueResize() {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())

	C.gtk_widget_queue_resize(arg0)
}

// Realize creates the GDK (windowing system) resources associated with a
// widget. Normally realization happens implicitly; if you show a widget and
// all its parent containers, then the widget will be realized and mapped
// automatically.
//
// Realizing a widget requires all the widget’s parent widgets to be
// realized; calling gtk_widget_realize() realizes the widget’s parents in
// addition to @widget itself. If a widget is not yet inside a toplevel
// window when you realize it, bad things will happen.
//
// This function is primarily used in widget implementations, and isn’t very
// useful otherwise. Many times when you think you might need it, a better
// approach is to connect to a signal that will be called after the widget
// is realized automatically, such as Widget::realize.
func (widget widget) Realize() {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())

	C.gtk_widget_realize(arg0)
}

// RemoveController removes @controller from @widget, so that it doesn't
// process events anymore. It should not be used again.
//
// Widgets will remove all event controllers automatically when they are
// destroyed, there is normally no need to call this function.
func (widget widget) RemoveController(controller EventController) {
	var arg0 *C.GtkWidget
	var arg1 *C.GtkEventController

	arg0 = (*C.GtkWidget)(widget.Native())
	arg1 = (*C.GtkEventController)(controller.Native())

	C.gtk_widget_remove_controller(arg0, arg1)
}

// RemoveCSSClass removes @css_class from @widget. After this, the style of
// @widget will stop matching for @css_class.
func (widget widget) RemoveCSSClass(cssClass string) {
	var arg0 *C.GtkWidget
	var arg1 *C.char

	arg0 = (*C.GtkWidget)(widget.Native())
	arg1 = (*C.gchar)(C.CString(cssClass))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_widget_remove_css_class(arg0, arg1)
}

// RemoveMnemonicLabel removes a widget from the list of mnemonic labels for
// this widget. (See gtk_widget_list_mnemonic_labels()). The widget must
// have previously been added to the list with
// gtk_widget_add_mnemonic_label().
func (widget widget) RemoveMnemonicLabel(label Widget) {
	var arg0 *C.GtkWidget
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())
	arg1 = (*C.GtkWidget)(label.Native())

	C.gtk_widget_remove_mnemonic_label(arg0, arg1)
}

// RemoveTickCallback removes a tick callback previously registered with
// gtk_widget_add_tick_callback().
func (widget widget) RemoveTickCallback(id uint) {
	var arg0 *C.GtkWidget
	var arg1 C.guint

	arg0 = (*C.GtkWidget)(widget.Native())
	arg1 = C.guint(id)

	C.gtk_widget_remove_tick_callback(arg0, arg1)
}

// SetCanFocus specifies whether the input focus can enter the widget or any
// of its children.
//
// Applications should set @can_focus to false to mark a widget as for
// pointer/touch use only.
//
// Note that having @can_focus be true is only one of the necessary
// conditions for being focusable. A widget must also be sensitive and
// focusable and not have an ancestor that is marked as not can-focus in
// order to receive input focus.
//
// See gtk_widget_grab_focus() for actually setting the input focus on a
// widget.
func (widget widget) SetCanFocus(canFocus bool) {
	var arg0 *C.GtkWidget
	var arg1 C.gboolean

	arg0 = (*C.GtkWidget)(widget.Native())
	arg1 = gextras.Cbool(canFocus)

	C.gtk_widget_set_can_focus(arg0, arg1)
}

// SetCanTarget sets whether @widget can be the target of pointer events.
func (widget widget) SetCanTarget(canTarget bool) {
	var arg0 *C.GtkWidget
	var arg1 C.gboolean

	arg0 = (*C.GtkWidget)(widget.Native())
	arg1 = gextras.Cbool(canTarget)

	C.gtk_widget_set_can_target(arg0, arg1)
}

// SetChildVisible sets whether @widget should be mapped along with its when
// its parent is mapped and @widget has been shown with gtk_widget_show().
//
// The child visibility can be set for widget before it is added to a
// container with gtk_widget_set_parent(), to avoid mapping children
// unnecessary before immediately unmapping them. However it will be reset
// to its default state of true when the widget is removed from a container.
//
// Note that changing the child visibility of a widget does not queue a
// resize on the widget. Most of the time, the size of a widget is computed
// from all visible children, whether or not they are mapped. If this is not
// the case, the container can queue a resize itself.
//
// This function is only useful for container implementations and never
// should be called by an application.
func (widget widget) SetChildVisible(childVisible bool) {
	var arg0 *C.GtkWidget
	var arg1 C.gboolean

	arg0 = (*C.GtkWidget)(widget.Native())
	arg1 = gextras.Cbool(childVisible)

	C.gtk_widget_set_child_visible(arg0, arg1)
}

// SetCSSClasses: will clear all css classes applied to @widget and replace
// them with @classes.
func (widget widget) SetCSSClasses(classes []string) {
	var arg0 *C.GtkWidget
	var arg1 **C.char

	arg0 = (*C.GtkWidget)(widget.Native())
	{

	}

	C.gtk_widget_set_css_classes(arg0, arg1)
}

// SetCursor sets the cursor to be shown when pointer devices point towards
// @widget.
//
// If the @cursor is NULL, @widget will use the cursor inherited from the
// parent widget.
func (widget widget) SetCursor(cursor gdk.Cursor) {
	var arg0 *C.GtkWidget
	var arg1 *C.GdkCursor

	arg0 = (*C.GtkWidget)(widget.Native())
	arg1 = (*C.GdkCursor)(cursor.Native())

	C.gtk_widget_set_cursor(arg0, arg1)
}

// SetCursorFromName sets a named cursor to be shown when pointer devices
// point towards @widget.
//
// This is a utility function that creates a cursor via
// gdk_cursor_new_from_name() and then sets it on @widget with
// gtk_widget_set_cursor(). See those 2 functions for details.
//
// On top of that, this function allows @name to be nil, which will do the
// same as calling gtk_widget_set_cursor() with a nil cursor.
func (widget widget) SetCursorFromName(name string) {
	var arg0 *C.GtkWidget
	var arg1 *C.char

	arg0 = (*C.GtkWidget)(widget.Native())
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_widget_set_cursor_from_name(arg0, arg1)
}

// SetDirection sets the reading direction on a particular widget. This
// direction controls the primary direction for widgets containing text, and
// also the direction in which the children of a container are packed. The
// ability to set the direction is present in order so that correct
// localization into languages with right-to-left reading directions can be
// done. Generally, applications will let the default reading direction
// present, except for containers where the containers are arranged in an
// order that is explicitly visual rather than logical (such as buttons for
// text justification).
//
// If the direction is set to GTK_TEXT_DIR_NONE, then the value set by
// gtk_widget_set_default_direction() will be used.
func (widget widget) SetDirection(dir TextDirection) {
	var arg0 *C.GtkWidget
	var arg1 C.GtkTextDirection

	arg0 = (*C.GtkWidget)(widget.Native())
	arg1 = (C.GtkTextDirection)(dir)

	C.gtk_widget_set_direction(arg0, arg1)
}

// SetFocusChild: set @child as the current focus child of @widget. The
// previous focus child will be unset.
//
// This function is only suitable for widget implementations. If you want a
// certain widget to get the input focus, call gtk_widget_grab_focus() on
// it.
func (widget widget) SetFocusChild(child Widget) {
	var arg0 *C.GtkWidget
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())
	arg1 = (*C.GtkWidget)(child.Native())

	C.gtk_widget_set_focus_child(arg0, arg1)
}

// SetFocusOnClick sets whether the widget should grab focus when it is
// clicked with the mouse. Making mouse clicks not grab focus is useful in
// places like toolbars where you don’t want the keyboard focus removed from
// the main area of the application.
func (widget widget) SetFocusOnClick(focusOnClick bool) {
	var arg0 *C.GtkWidget
	var arg1 C.gboolean

	arg0 = (*C.GtkWidget)(widget.Native())
	arg1 = gextras.Cbool(focusOnClick)

	C.gtk_widget_set_focus_on_click(arg0, arg1)
}

// SetFocusable specifies whether @widget can own the input focus.
//
// Widget implementations should set @focusable to true in their init()
// function if they want to receive keyboard input.
//
// Note that having @focusable be true is only one of the necessary
// conditions for being focusable. A widget must also be sensitive and
// can-focus and not have an ancestor that is marked as not can-focus in
// order to receive input focus.
//
// See gtk_widget_grab_focus() for actually setting the input focus on a
// widget.
func (widget widget) SetFocusable(focusable bool) {
	var arg0 *C.GtkWidget
	var arg1 C.gboolean

	arg0 = (*C.GtkWidget)(widget.Native())
	arg1 = gextras.Cbool(focusable)

	C.gtk_widget_set_focusable(arg0, arg1)
}

// SetFontMap sets the font map to use for Pango rendering. The font map is
// the object that is used to look up fonts. Setting a custom font map can
// be useful in special situations, e.g. when you need to add
// application-specific fonts to the set of available fonts.
//
// When not set, the widget will inherit the font map from its parent.
func (widget widget) SetFontMap(fontMap pango.FontMap) {
	var arg0 *C.GtkWidget
	var arg1 *C.PangoFontMap

	arg0 = (*C.GtkWidget)(widget.Native())
	arg1 = (*C.PangoFontMap)(fontMap.Native())

	C.gtk_widget_set_font_map(arg0, arg1)
}

// SetFontOptions sets the #cairo_font_options_t used for Pango rendering in
// this widget. When not set, the default font options for the Display will
// be used.
func (widget widget) SetFontOptions(options *cairo.FontOptions) {
	var arg0 *C.GtkWidget
	var arg1 *C.cairo_font_options_t

	arg0 = (*C.GtkWidget)(widget.Native())
	arg1 = (*C.cairo_font_options_t)(options.Native())

	C.gtk_widget_set_font_options(arg0, arg1)
}

// SetHalign sets the horizontal alignment of @widget. See the Widget:halign
// property.
func (widget widget) SetHalign(align Align) {
	var arg0 *C.GtkWidget
	var arg1 C.GtkAlign

	arg0 = (*C.GtkWidget)(widget.Native())
	arg1 = (C.GtkAlign)(align)

	C.gtk_widget_set_halign(arg0, arg1)
}

// SetHasTooltip sets the has-tooltip property on @widget to @has_tooltip.
// See Widget:has-tooltip for more information.
func (widget widget) SetHasTooltip(hasTooltip bool) {
	var arg0 *C.GtkWidget
	var arg1 C.gboolean

	arg0 = (*C.GtkWidget)(widget.Native())
	arg1 = gextras.Cbool(hasTooltip)

	C.gtk_widget_set_has_tooltip(arg0, arg1)
}

// SetHexpand sets whether the widget would like any available extra
// horizontal space. When a user resizes a Window, widgets with expand=TRUE
// generally receive the extra space. For example, a list or scrollable area
// or document in your window would often be set to expand.
//
// Call this function to set the expand flag if you would like your widget
// to become larger horizontally when the window has extra room.
//
// By default, widgets automatically expand if any of their children want to
// expand. (To see if a widget will automatically expand given its current
// children and state, call gtk_widget_compute_expand(). A container can
// decide how the expandability of children affects the expansion of the
// container by overriding the compute_expand virtual method on Widget.).
//
// Setting hexpand explicitly with this function will override the automatic
// expand behavior.
//
// This function forces the widget to expand or not to expand, regardless of
// children. The override occurs because gtk_widget_set_hexpand() sets the
// hexpand-set property (see gtk_widget_set_hexpand_set()) which causes the
// widget’s hexpand value to be used, rather than looking at children and
// widget state.
func (widget widget) SetHexpand(expand bool) {
	var arg0 *C.GtkWidget
	var arg1 C.gboolean

	arg0 = (*C.GtkWidget)(widget.Native())
	arg1 = gextras.Cbool(expand)

	C.gtk_widget_set_hexpand(arg0, arg1)
}

// SetHexpandSet sets whether the hexpand flag (see
// gtk_widget_get_hexpand()) will be used.
//
// The hexpand-set property will be set automatically when you call
// gtk_widget_set_hexpand() to set hexpand, so the most likely reason to use
// this function would be to unset an explicit expand flag.
//
// If hexpand is set, then it overrides any computed expand value based on
// child widgets. If hexpand is not set, then the expand value depends on
// whether any children of the widget would like to expand.
//
// There are few reasons to use this function, but it’s here for
// completeness and consistency.
func (widget widget) SetHexpandSet(set bool) {
	var arg0 *C.GtkWidget
	var arg1 C.gboolean

	arg0 = (*C.GtkWidget)(widget.Native())
	arg1 = gextras.Cbool(set)

	C.gtk_widget_set_hexpand_set(arg0, arg1)
}

// SetLayoutManager sets the layout manager delegate instance that provides
// an implementation for measuring and allocating the children of @widget.
func (widget widget) SetLayoutManager(layoutManager LayoutManager) {
	var arg0 *C.GtkWidget
	var arg1 *C.GtkLayoutManager

	arg0 = (*C.GtkWidget)(widget.Native())
	arg1 = (*C.GtkLayoutManager)(layoutManager.Native())

	C.gtk_widget_set_layout_manager(arg0, arg1)
}

// SetMarginBottom sets the bottom margin of @widget. See the
// Widget:margin-bottom property.
func (widget widget) SetMarginBottom(margin int) {
	var arg0 *C.GtkWidget
	var arg1 C.int

	arg0 = (*C.GtkWidget)(widget.Native())
	arg1 = C.int(margin)

	C.gtk_widget_set_margin_bottom(arg0, arg1)
}

// SetMarginEnd sets the end margin of @widget. See the Widget:margin-end
// property.
func (widget widget) SetMarginEnd(margin int) {
	var arg0 *C.GtkWidget
	var arg1 C.int

	arg0 = (*C.GtkWidget)(widget.Native())
	arg1 = C.int(margin)

	C.gtk_widget_set_margin_end(arg0, arg1)
}

// SetMarginStart sets the start margin of @widget. See the
// Widget:margin-start property.
func (widget widget) SetMarginStart(margin int) {
	var arg0 *C.GtkWidget
	var arg1 C.int

	arg0 = (*C.GtkWidget)(widget.Native())
	arg1 = C.int(margin)

	C.gtk_widget_set_margin_start(arg0, arg1)
}

// SetMarginTop sets the top margin of @widget. See the Widget:margin-top
// property.
func (widget widget) SetMarginTop(margin int) {
	var arg0 *C.GtkWidget
	var arg1 C.int

	arg0 = (*C.GtkWidget)(widget.Native())
	arg1 = C.int(margin)

	C.gtk_widget_set_margin_top(arg0, arg1)
}

// SetName widgets can be named, which allows you to refer to them from a
// CSS file. You can apply a style to widgets with a particular name in the
// CSS file. See the documentation for the CSS syntax (on the same page as
// the docs for StyleContext).
//
// Note that the CSS syntax has certain special characters to delimit and
// represent elements in a selector (period, #, >, *...), so using these
// will make your widget impossible to match by name. Any combination of
// alphanumeric symbols, dashes and underscores will suffice.
func (widget widget) SetName(name string) {
	var arg0 *C.GtkWidget
	var arg1 *C.char

	arg0 = (*C.GtkWidget)(widget.Native())
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_widget_set_name(arg0, arg1)
}

// SetOpacity: request the @widget to be rendered partially transparent,
// with opacity 0 being fully transparent and 1 fully opaque. (Opacity
// values are clamped to the [0,1] range).
//
// Opacity works on both toplevel widgets and child widgets, although there
// are some limitations: For toplevel widgets, applying opacity depends on
// the capabilities of the windowing system. On X11, this has any effect
// only on X displays with a compositing manager, see
// gdk_display_is_composited(). On Windows and Wayland it should always
// work, although setting a window’s opacity after the window has been shown
// may cause some flicker.
//
// Note that the opacity is inherited through inclusion — if you set a
// toplevel to be partially translucent, all of its content will appear
// translucent, since it is ultimatively rendered on that toplevel. The
// opacity value itself is not inherited by child widgets (since that would
// make widgets deeper in the hierarchy progressively more translucent). As
// a consequence, Popovers and other Native widgets with their own surface
// will use their own opacity value, and thus by default appear
// non-translucent, even if they are attached to a toplevel that is
// translucent.
func (widget widget) SetOpacity(opacity float64) {
	var arg0 *C.GtkWidget
	var arg1 C.double

	arg0 = (*C.GtkWidget)(widget.Native())
	arg1 = C.double(opacity)

	C.gtk_widget_set_opacity(arg0, arg1)
}

// SetOverflow sets how @widget treats content that is drawn outside the
// widget's content area. See the definition of Overflow for details.
//
// This setting is provided for widget implementations and should not be
// used by application code.
//
// The default value is GTK_OVERFLOW_VISIBLE.
func (widget widget) SetOverflow(overflow Overflow) {
	var arg0 *C.GtkWidget
	var arg1 C.GtkOverflow

	arg0 = (*C.GtkWidget)(widget.Native())
	arg1 = (C.GtkOverflow)(overflow)

	C.gtk_widget_set_overflow(arg0, arg1)
}

// SetParent: this function is useful only when implementing subclasses of
// Widget.
//
// Sets @parent as the parent widget of @widget, and takes care of some
// details such as updating the state and style of the child to reflect its
// new location and resizing the parent. The opposite function is
// gtk_widget_unparent().
func (widget widget) SetParent(parent Widget) {
	var arg0 *C.GtkWidget
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())
	arg1 = (*C.GtkWidget)(parent.Native())

	C.gtk_widget_set_parent(arg0, arg1)
}

// SetReceivesDefault specifies whether @widget will be treated as the
// default widget within its toplevel when it has the focus, even if another
// widget is the default.
func (widget widget) SetReceivesDefault(receivesDefault bool) {
	var arg0 *C.GtkWidget
	var arg1 C.gboolean

	arg0 = (*C.GtkWidget)(widget.Native())
	arg1 = gextras.Cbool(receivesDefault)

	C.gtk_widget_set_receives_default(arg0, arg1)
}

// SetSensitive sets the sensitivity of a widget. A widget is sensitive if
// the user can interact with it. Insensitive widgets are “grayed out” and
// the user can’t interact with them. Insensitive widgets are known as
// “inactive”, “disabled”, or “ghosted” in some other toolkits.
func (widget widget) SetSensitive(sensitive bool) {
	var arg0 *C.GtkWidget
	var arg1 C.gboolean

	arg0 = (*C.GtkWidget)(widget.Native())
	arg1 = gextras.Cbool(sensitive)

	C.gtk_widget_set_sensitive(arg0, arg1)
}

// SetSizeRequest sets the minimum size of a widget; that is, the widget’s
// size request will be at least @width by @height. You can use this
// function to force a widget to be larger than it normally would be.
//
// In most cases, gtk_window_set_default_size() is a better choice for
// toplevel windows than this function; setting the default size will still
// allow users to shrink the window. Setting the size request will force
// them to leave the window at least as large as the size request. When
// dealing with window sizes, gtk_window_set_geometry_hints() can be a
// useful function as well.
//
// Note the inherent danger of setting any fixed size - themes, translations
// into other languages, different fonts, and user action can all change the
// appropriate size for a given widget. So, it's basically impossible to
// hardcode a size that will always be correct.
//
// The size request of a widget is the smallest size a widget can accept
// while still functioning well and drawing itself correctly. However in
// some strange cases a widget may be allocated less than its requested
// size, and in many cases a widget may be allocated more space than it
// requested.
//
// If the size request in a given direction is -1 (unset), then the
// “natural” size request of the widget will be used instead.
//
// The size request set here does not include any margin from the Widget
// properties margin-left, margin-right, margin-top, and margin-bottom, but
// it does include pretty much all other padding or border properties set by
// any subclass of Widget.
func (widget widget) SetSizeRequest(width int, height int) {
	var arg0 *C.GtkWidget
	var arg1 C.int
	var arg2 C.int

	arg0 = (*C.GtkWidget)(widget.Native())
	arg1 = C.int(width)
	arg2 = C.int(height)

	C.gtk_widget_set_size_request(arg0, arg1, arg2)
}

// SetStateFlags: this function is for use in widget implementations. Turns
// on flag values in the current widget state (insensitive, prelighted,
// etc.).
//
// This function accepts the values GTK_STATE_FLAG_DIR_LTR and
// GTK_STATE_FLAG_DIR_RTL but ignores them. If you want to set the widget's
// direction, use gtk_widget_set_direction().
func (widget widget) SetStateFlags(flags StateFlags, clear bool) {
	var arg0 *C.GtkWidget
	var arg1 C.GtkStateFlags
	var arg2 C.gboolean

	arg0 = (*C.GtkWidget)(widget.Native())
	arg1 = (C.GtkStateFlags)(flags)
	arg2 = gextras.Cbool(clear)

	C.gtk_widget_set_state_flags(arg0, arg1, arg2)
}

// SetTooltipMarkup sets @markup as the contents of the tooltip, which is
// marked up with the [Pango text markup language][PangoMarkupFormat].
//
// This function will take care of setting the Widget:has-tooltip as a side
// effect, and of the default handler for the Widget::query-tooltip signal.
//
// See also the Widget:tooltip-markup property and gtk_tooltip_set_markup().
func (widget widget) SetTooltipMarkup(markup string) {
	var arg0 *C.GtkWidget
	var arg1 *C.char

	arg0 = (*C.GtkWidget)(widget.Native())
	arg1 = (*C.gchar)(C.CString(markup))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_widget_set_tooltip_markup(arg0, arg1)
}

// SetTooltipText sets @text as the contents of the tooltip.
//
// If @text contains any markup, it will be escaped.
//
// This function will take care of setting Widget:has-tooltip as a side
// effect, and of the default handler for the Widget::query-tooltip signal.
//
// See also the Widget:tooltip-text property and gtk_tooltip_set_text().
func (widget widget) SetTooltipText(text string) {
	var arg0 *C.GtkWidget
	var arg1 *C.char

	arg0 = (*C.GtkWidget)(widget.Native())
	arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_widget_set_tooltip_text(arg0, arg1)
}

// SetValign sets the vertical alignment of @widget. See the Widget:valign
// property.
func (widget widget) SetValign(align Align) {
	var arg0 *C.GtkWidget
	var arg1 C.GtkAlign

	arg0 = (*C.GtkWidget)(widget.Native())
	arg1 = (C.GtkAlign)(align)

	C.gtk_widget_set_valign(arg0, arg1)
}

// SetVexpand sets whether the widget would like any available extra
// vertical space.
//
// See gtk_widget_set_hexpand() for more detail.
func (widget widget) SetVexpand(expand bool) {
	var arg0 *C.GtkWidget
	var arg1 C.gboolean

	arg0 = (*C.GtkWidget)(widget.Native())
	arg1 = gextras.Cbool(expand)

	C.gtk_widget_set_vexpand(arg0, arg1)
}

// SetVexpandSet sets whether the vexpand flag (see
// gtk_widget_get_vexpand()) will be used.
//
// See gtk_widget_set_hexpand_set() for more detail.
func (widget widget) SetVexpandSet(set bool) {
	var arg0 *C.GtkWidget
	var arg1 C.gboolean

	arg0 = (*C.GtkWidget)(widget.Native())
	arg1 = gextras.Cbool(set)

	C.gtk_widget_set_vexpand_set(arg0, arg1)
}

// SetVisible sets the visibility state of @widget. Note that setting this
// to true doesn’t mean the widget is actually viewable, see
// gtk_widget_get_visible().
//
// This function simply calls gtk_widget_show() or gtk_widget_hide() but is
// nicer to use when the visibility of the widget depends on some condition.
func (widget widget) SetVisible(visible bool) {
	var arg0 *C.GtkWidget
	var arg1 C.gboolean

	arg0 = (*C.GtkWidget)(widget.Native())
	arg1 = gextras.Cbool(visible)

	C.gtk_widget_set_visible(arg0, arg1)
}

// ShouldLayout returns whether @widget should contribute to the measuring
// and allocation of its parent. This is false for invisible children, but
// also for children that have their own surface.
func (widget widget) ShouldLayout() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_widget_should_layout(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Show flags a widget to be displayed. Any widget that isn’t shown will not
// appear on the screen.
//
// Remember that you have to show the containers containing a widget, in
// addition to the widget itself, before it will appear onscreen.
//
// When a toplevel container is shown, it is immediately realized and
// mapped; other shown widgets are realized and mapped when their toplevel
// container is realized and mapped.
func (widget widget) Show() {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())

	C.gtk_widget_show(arg0)
}

// SizeAllocate: this is a simple form of gtk_widget_allocate() that takes
// the new position of @widget as part of @allocation.
func (widget widget) SizeAllocate(allocation *Allocation, baseline int) {
	var arg0 *C.GtkWidget
	var arg1 *C.GtkAllocation
	var arg2 C.int

	arg0 = (*C.GtkWidget)(widget.Native())
	arg2 = C.int(baseline)

	C.gtk_widget_size_allocate(arg0, arg1, arg2)
}

// SnapshotChild: when a widget receives a call to the snapshot function, it
// must send synthetic WidgetClass.snapshot() calls to all children. This
// function provides a convenient way of doing this. A widget, when it
// receives a call to its WidgetClass.snapshot() function, calls
// gtk_widget_snapshot_child() once for each child, passing in the @snapshot
// the widget received.
//
// gtk_widget_snapshot_child() takes care of translating the origin of
// @snapshot, and deciding whether the child needs to be snapshot.
//
// This function does nothing for children that implement Native.
func (widget widget) SnapshotChild(child Widget, snapshot Snapshot) {
	var arg0 *C.GtkWidget
	var arg1 *C.GtkWidget
	var arg2 *C.GtkSnapshot

	arg0 = (*C.GtkWidget)(widget.Native())
	arg1 = (*C.GtkWidget)(child.Native())
	arg2 = (*C.GtkSnapshot)(snapshot.Native())

	C.gtk_widget_snapshot_child(arg0, arg1, arg2)
}

// TranslateCoordinates: translate coordinates relative to @src_widget’s
// allocation to coordinates relative to @dest_widget’s allocations. In
// order to perform this operation, both widget must share a common
// toplevel.
func (srcWidget widget) TranslateCoordinates(destWidget Widget, srcX float64, srcY float64) (destX float64, destY float64, ok bool) {
	var arg0 *C.GtkWidget
	var arg1 *C.GtkWidget
	var arg2 C.double
	var arg3 C.double
	var arg4 *C.double // out
	var arg5 *C.double // out

	arg0 = (*C.GtkWidget)(srcWidget.Native())
	arg1 = (*C.GtkWidget)(destWidget.Native())
	arg2 = C.double(srcX)
	arg3 = C.double(srcY)

	ret := C.gtk_widget_translate_coordinates(arg0, arg1, arg2, arg3, &arg4, &arg5)

	var ret0 float64
	var ret1 float64
	var ret2 bool

	ret0 = float64(arg4)

	ret1 = float64(arg5)

	ret2 = gextras.Gobool(ret)

	return ret0, ret1, ret2
}

// TriggerTooltipQuery triggers a tooltip query on the display where the
// toplevel of @widget is located.
func (widget widget) TriggerTooltipQuery() {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())

	C.gtk_widget_trigger_tooltip_query(arg0)
}

// Unmap: this function is only for use in widget implementations. Causes a
// widget to be unmapped if it’s currently mapped.
func (widget widget) Unmap() {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())

	C.gtk_widget_unmap(arg0)
}

// Unparent: this function is only for use in widget implementations. It
// should be called by parent widgets to dissociate @widget from the parent,
// typically in dispose.
func (widget widget) Unparent() {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())

	C.gtk_widget_unparent(arg0)
}

// Unrealize: this function is only useful in widget implementations. Causes
// a widget to be unrealized (frees all GDK resources associated with the
// widget).
func (widget widget) Unrealize() {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(widget.Native())

	C.gtk_widget_unrealize(arg0)
}

// UnsetStateFlags: this function is for use in widget implementations.
// Turns off flag values for the current widget state (insensitive,
// prelighted, etc.). See gtk_widget_set_state_flags().
func (widget widget) UnsetStateFlags(flags StateFlags) {
	var arg0 *C.GtkWidget
	var arg1 C.GtkStateFlags

	arg0 = (*C.GtkWidget)(widget.Native())
	arg1 = (C.GtkStateFlags)(flags)

	C.gtk_widget_unset_state_flags(arg0, arg1)
}

// WidgetPaintable: gtkWidgetPaintable is an implementation of the Paintable
// interface that allows displaying the contents of a Widget.
//
// GtkWidgetPaintable will also take care of the widget not being in a state
// where it can be drawn (like when it isn't shown) and just draw nothing or
// where it does not have a size (like when it is hidden) and report no size in
// that case.
//
// Of course, GtkWidgetPaintable allows you to monitor widgets for size changes
// by emitting the Paintable::invalidate-size signal whenever the size of the
// widget changes as well as for visual changes by emitting the
// Paintable::invalidate-contents signal whenever the widget changes.
//
// You can of course use a GtkWidgetPaintable everywhere a Paintable is allowed,
// including using it on a Picture (or one of its parents) that it was set on
// itself via gtk_picture_set_paintable(). The paintable will take care of
// recursion when this happens. If you do this however, ensure the
// Picture:can-shrink property is set to true or you might end up with an
// infinitely growing widget.
type WidgetPaintable interface {
	gextras.Objector

	// Widget returns the widget that is observed or nil if none.
	Widget() Widget
	// SetWidget sets the widget that should be observed.
	SetWidget(widget Widget)
}

type widgetPaintable struct {
	*externglib.Object
}

// WrapWidgetPaintable wraps a GObject to the right type. It is
// primarily used internally.
func WrapWidgetPaintable(obj *externglib.Object) WidgetPaintable {
	return widgetPaintable{*externglib.Object{obj}}
}

func marshalWidgetPaintable(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapWidgetPaintable(obj), nil
}

// NewWidgetPaintable constructs a class WidgetPaintable.
func NewWidgetPaintable(widget Widget) WidgetPaintable {
	var arg1 *C.GtkWidget

	arg1 = (*C.GtkWidget)(widget.Native())

	ret := C.gtk_widget_paintable_new(arg1)

	var ret0 WidgetPaintable

	ret0 = WrapWidgetPaintable(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Widget returns the widget that is observed or nil if none.
func (self widgetPaintable) Widget() Widget {
	var arg0 *C.GtkWidgetPaintable

	arg0 = (*C.GtkWidgetPaintable)(self.Native())

	ret := C.gtk_widget_paintable_get_widget(arg0)

	var ret0 Widget

	ret0 = WrapWidget(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// SetWidget sets the widget that should be observed.
func (self widgetPaintable) SetWidget(widget Widget) {
	var arg0 *C.GtkWidgetPaintable
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkWidgetPaintable)(self.Native())
	arg1 = (*C.GtkWidget)(widget.Native())

	C.gtk_widget_paintable_set_widget(arg0, arg1)
}

// Window: a GtkWindow is a toplevel window which can contain other widgets.
// Windows normally have decorations that are under the control of the windowing
// system and allow the user to manipulate the window (resize it, move it, close
// it,...).
//
//
// GtkWindow as GtkBuildable
//
// The GtkWindow implementation of the Buildable interface supports setting a
// child as the titlebar by specifying “titlebar” as the “type” attribute of a
// <child> element.
//
// CSS nodes
//
//    window.background
//    ├── <child>
//    ╰── <titlebar child>.titlebar [.default-decoration]
//
//
// GtkWindow has a main CSS node with name window and style class .background.
//
// Style classes that are typically used with the main CSS node are .csd (when
// client-side decorations are in use), .solid-csd (for client-side decorations
// without invisible borders), .ssd (used by mutter when rendering server-side
// decorations). GtkWindow also represents window states with the following
// style classes on the main node: .tiled, .maximized, .fullscreen. Specialized
// types of window often add their own discriminating style classes, such as
// .popup or .tooltip.
//
// Generally, some CSS properties don't make sense on the toplevel window node,
// such as margins or padding. When client-side decorations without invisible
// borders are in use (i.e. the .solid-csd style class is added to the main
// window node), the CSS border of the toplevel window is used for resize drags.
// In the .csd case, the shadow area outside of the window can be used to resize
// it.
//
// GtkWindow adds the .titlebar and .default-decoration style classes to the
// widget that is added as a titlebar child.
//
//
// Accessibility
//
// GtkWindow uses the GTK_ACCESSIBLE_ROLE_WINDOW role.
type Window interface {
	Widget

	// Close requests that the window is closed, similar to what happens when a
	// window manager close button is clicked.
	//
	// This function can be used with close buttons in custom titlebars.
	Close()
	// Destroy: drop the internal reference GTK holds on toplevel windows.
	Destroy()
	// Fullscreen asks to place @window in the fullscreen state.
	//
	// Note that you shouldn’t assume the window is definitely full screen
	// afterward, because other entities (e.g. the user or [window
	// manager][gtk-X11-arch]) could unfullscreen it again, and not all window
	// managers honor requests to fullscreen windows.
	//
	// You can track the result of this operation via the Toplevel:state
	// property, or by listening to notifications of the Window:fullscreened
	// property.
	Fullscreen()
	// FullscreenOnMonitor asks to place @window in the fullscreen state on the
	// given @monitor.
	//
	// Note that you shouldn't assume the window is definitely full screen
	// afterward, or that the windowing system allows fullscreen windows on any
	// given monitor.
	//
	// You can track the result of this operation via the Toplevel:state
	// property, or by listening to notifications of the Window:fullscreened
	// property.
	FullscreenOnMonitor(monitor gdk.Monitor)
	// Application gets the Application associated with the window (if any).
	Application() Application
	// Child gets the child widget of @window.
	Child() Widget
	// Decorated returns whether the window has been set to have decorations
	// such as a title bar via gtk_window_set_decorated().
	Decorated() bool
	// DefaultSize gets the default size of the window. A value of 0 for the
	// width or height indicates that a default size has not been explicitly set
	// for that dimension, so the “natural” size of the window will be used.
	DefaultSize() (width int, height int)
	// DefaultWidget returns the default widget for @window.
	//
	// See gtk_window_set_default_widget() for more details.
	DefaultWidget() Widget
	// Deletable returns whether the window has been set to have a close button
	// via gtk_window_set_deletable().
	Deletable() bool
	// DestroyWithParent returns whether the window will be destroyed with its
	// transient parent. See gtk_window_set_destroy_with_parent ().
	DestroyWithParent() bool
	// Focus retrieves the current focused widget within the window. Note that
	// this is the widget that would have the focus if the toplevel window
	// focused; if the toplevel window is not focused then `gtk_widget_has_focus
	// (widget)` will not be true for the widget.
	Focus() Widget
	// FocusVisible gets the value of the Window:focus-visible property.
	FocusVisible() bool
	// Group returns the group for @window or the default group, if @window is
	// nil or if @window does not have an explicit window group.
	Group() WindowGroup
	// HideOnClose returns whether the window will be hidden when the close
	// button is clicked.
	HideOnClose() bool
	// IconName returns the name of the themed icon for the window, see
	// gtk_window_set_icon_name().
	IconName() string
	// MnemonicsVisible gets the value of the Window:mnemonics-visible property.
	MnemonicsVisible() bool
	// Modal returns whether the window is modal. See gtk_window_set_modal().
	Modal() bool
	// Resizable gets the value set by gtk_window_set_resizable().
	Resizable() bool
	// Title retrieves the title of the window. See gtk_window_set_title().
	Title() string
	// Titlebar returns the custom titlebar that has been set with
	// gtk_window_set_titlebar().
	Titlebar() Widget
	// TransientFor fetches the transient parent for this window. See
	// gtk_window_set_transient_for().
	TransientFor() Window
	// HasGroup returns whether @window has an explicit window group.
	HasGroup() bool
	// IsActive returns whether the window is part of the current active
	// toplevel. (That is, the toplevel window receiving keystrokes.) The return
	// value is true if the window is active toplevel itself. You might use this
	// function if you wanted to draw a widget differently in an active window
	// from a widget in an inactive window.
	IsActive() bool
	// IsFullscreen retrieves the current fullscreen state of @window.
	//
	// Note that since fullscreening is ultimately handled by the window manager
	// and happens asynchronously to an application request, you shouldn’t
	// assume the return value of this function changing immediately (or at
	// all), as an effect of calling gtk_window_fullscreen() or
	// gtk_window_unfullscreen().
	//
	// If the window isn't yet mapped, the value returned will whether the
	// initial requested state is fullscreen.
	IsFullscreen() bool
	// IsMaximized retrieves the current maximized state of @window.
	//
	// Note that since maximization is ultimately handled by the window manager
	// and happens asynchronously to an application request, you shouldn’t
	// assume the return value of this function changing immediately (or at
	// all), as an effect of calling gtk_window_maximize() or
	// gtk_window_unmaximize().
	//
	// If the window isn't yet mapped, the value returned will whether the
	// initial requested state is maximized.
	IsMaximized() bool
	// Maximize asks to maximize @window, so that it fills the screen.
	//
	// Note that you shouldn’t assume the window is definitely maximized
	// afterward, because other entities (e.g. the user or [window
	// manager][gtk-X11-arch]) could unmaximize it again, and not all window
	// managers support maximization.
	//
	// It’s permitted to call this function before showing a window, in which
	// case the window will be maximized when it appears onscreen initially.
	//
	// You can track the result of this operation via the Toplevel:state
	// property, or by listening to notifications on the Window:maximized
	// property.
	Maximize()
	// Minimize asks to minimize the specified @window.
	//
	// Note that you shouldn’t assume the window is definitely minimized
	// afterward, because the windowing system might not support this
	// functionality; other entities (e.g. the user or the [window
	// manager][gtk-X11-arch]) could unminimize it again, or there may not be a
	// window manager in which case minimization isn’t possible, etc.
	//
	// It’s permitted to call this function before showing a window, in which
	// case the window will be minimized before it ever appears onscreen.
	//
	// You can track result of this operation via the Toplevel:state property.
	Minimize()
	// Present presents a window to the user. This function should not be used
	// as when it is called, it is too late to gather a valid timestamp to allow
	// focus stealing prevention to work correctly.
	Present()
	// PresentWithTime presents a window to the user. This may mean raising the
	// window in the stacking order, unminimizing it, moving it to the current
	// desktop, and/or giving it the keyboard focus, possibly dependent on the
	// user’s platform, window manager, and preferences.
	//
	// If @window is hidden, this function calls gtk_widget_show() as well.
	//
	// This function should be used when the user tries to open a window that’s
	// already open. Say for example the preferences dialog is currently open,
	// and the user chooses Preferences from the menu a second time; use
	// gtk_window_present() to move the already-open dialog where the user can
	// see it.
	//
	// Presents a window to the user in response to a user interaction. The
	// timestamp should be gathered when the window was requested to be shown
	// (when clicking a link for example), rather than once the window is ready
	// to be shown.
	PresentWithTime(timestamp uint32)
	// SetApplication sets or unsets the Application associated with the window.
	//
	// The application will be kept alive for at least as long as it has any
	// windows associated with it (see g_application_hold() for a way to keep it
	// alive without windows).
	//
	// Normally, the connection between the application and the window will
	// remain until the window is destroyed, but you can explicitly remove it by
	// setting the @application to nil.
	//
	// This is equivalent to calling gtk_application_remove_window() and/or
	// gtk_application_add_window() on the old/new applications as relevant.
	SetApplication(application Application)
	// SetChild sets the child widget of @window.
	SetChild(child Widget)
	// SetDecorated: by default, windows are decorated with a title bar, resize
	// controls, etc. Some [window managers][gtk-X11-arch] allow GTK to disable
	// these decorations, creating a borderless window. If you set the decorated
	// property to false using this function, GTK will do its best to convince
	// the window manager not to decorate the window. Depending on the system,
	// this function may not have any effect when called on a window that is
	// already visible, so you should call it before calling gtk_widget_show().
	//
	// On Windows, this function always works, since there’s no window manager
	// policy involved.
	SetDecorated(setting bool)
	// SetDefaultSize sets the default size of a window. If the window’s
	// “natural” size (its size request) is larger than the default, the default
	// will be ignored.
	//
	// Unlike gtk_widget_set_size_request(), which sets a size request for a
	// widget and thus would keep users from shrinking the window, this function
	// only sets the initial size, just as if the user had resized the window
	// themselves. Users can still shrink the window again as they normally
	// would. Setting a default size of -1 means to use the “natural” default
	// size (the size request of the window).
	//
	// The default size of a window only affects the first time a window is
	// shown; if a window is hidden and re-shown, it will remember the size it
	// had prior to hiding, rather than using the default size.
	//
	// Windows can’t actually be 0x0 in size, they must be at least 1x1, but
	// passing 0 for @width and @height is OK, resulting in a 1x1 default size.
	//
	// If you use this function to reestablish a previously saved window size,
	// note that the appropriate size to save is the one returned by
	// gtk_window_get_default_size(). Using the window allocation directly will
	// not work in all circumstances and can lead to growing or shrinking
	// windows.
	SetDefaultSize(width int, height int)
	// SetDefaultWidget: the default widget is the widget that’s activated when
	// the user presses Enter in a dialog (for example). This function sets or
	// unsets the default widget for a Window.
	SetDefaultWidget(defaultWidget Widget)
	// SetDeletable: by default, windows have a close button in the window
	// frame. Some [window managers][gtk-X11-arch] allow GTK to disable this
	// button. If you set the deletable property to false using this function,
	// GTK will do its best to convince the window manager not to show a close
	// button. Depending on the system, this function may not have any effect
	// when called on a window that is already visible, so you should call it
	// before calling gtk_widget_show().
	//
	// On Windows, this function always works, since there’s no window manager
	// policy involved.
	SetDeletable(setting bool)
	// SetDestroyWithParent: if @setting is true, then destroying the transient
	// parent of @window will also destroy @window itself. This is useful for
	// dialogs that shouldn’t persist beyond the lifetime of the main window
	// they're associated with, for example.
	SetDestroyWithParent(setting bool)
	// SetDisplay sets the Display where the @window is displayed; if the window
	// is already mapped, it will be unmapped, and then remapped on the new
	// display.
	SetDisplay(display gdk.Display)
	// SetFocus: if @focus is not the current focus widget, and is focusable,
	// sets it as the focus widget for the window. If @focus is nil, unsets the
	// focus widget for this window. To set the focus to a particular widget in
	// the toplevel, it is usually more convenient to use
	// gtk_widget_grab_focus() instead of this function.
	SetFocus(focus Widget)
	// SetFocusVisible sets the Window:focus-visible property.
	SetFocusVisible(setting bool)
	// SetHideOnClose: if @setting is true, then clicking the close button on
	// the window will not destroy it, but only hide it.
	SetHideOnClose(setting bool)
	// SetIconName sets the icon for the window from a named themed icon. See
	// the docs for IconTheme for more details. On some platforms, the window
	// icon is not used at all.
	//
	// Note that this has nothing to do with the WM_ICON_NAME property which is
	// mentioned in the ICCCM.
	SetIconName(name string)
	// SetMnemonicsVisible sets the Window:mnemonics-visible property.
	SetMnemonicsVisible(setting bool)
	// SetModal sets a window modal or non-modal. Modal windows prevent
	// interaction with other windows in the same application. To keep modal
	// dialogs on top of main application windows, use
	// gtk_window_set_transient_for() to make the dialog transient for the
	// parent; most [window managers][gtk-X11-arch] will then disallow lowering
	// the dialog below the parent.
	SetModal(modal bool)
	// SetResizable sets whether the user can resize a window.
	//
	// Windows are user resizable by default.
	SetResizable(resizable bool)
	// SetStartupID: startup notification identifiers are used by desktop
	// environment to track application startup, to provide user feedback and
	// other features. This function changes the corresponding property on the
	// underlying GdkSurface. Normally, startup identifier is managed
	// automatically and you should only use this function in special cases like
	// transferring focus from other processes. You should use this function
	// before calling gtk_window_present() or any equivalent function generating
	// a window map event.
	//
	// This function is only useful on X11, not with other GTK targets.
	SetStartupID(startupID string)
	// SetTitle sets the title of the Window. The title of a window will be
	// displayed in its title bar; on the X Window System, the title bar is
	// rendered by the [window manager][gtk-X11-arch], so exactly how the title
	// appears to users may vary according to a user’s exact configuration. The
	// title should help a user distinguish this window from other windows they
	// may have open. A good title might include the application name and
	// current document filename, for example. document filename, for example.
	//
	// Passing nil does the same as setting the title to an empty string.
	SetTitle(title string)
	// SetTitlebar sets a custom titlebar for @window.
	//
	// A typical widget used here is HeaderBar, as it provides various features
	// expected of a titlebar while allowing the addition of child widgets to
	// it.
	//
	// If you set a custom titlebar, GTK will do its best to convince the window
	// manager not to put its own titlebar on the window. Depending on the
	// system, this function may not work for a window that is already visible,
	// so you set the titlebar before calling gtk_widget_show().
	SetTitlebar(titlebar Widget)
	// SetTransientFor: dialog windows should be set transient for the main
	// application window they were spawned from. This allows [window
	// managers][gtk-X11-arch] to e.g. keep the dialog on top of the main
	// window, or center the dialog over the main window.
	// gtk_dialog_new_with_buttons() and other convenience functions in GTK will
	// sometimes call gtk_window_set_transient_for() on your behalf.
	//
	// Passing nil for @parent unsets the current transient window.
	//
	// On Windows, this function puts the child window on top of the parent,
	// much as the window manager would have done on X.
	SetTransientFor(parent Window)
	// Unfullscreen asks to remove the fullscreen state for @window, and return
	// to its previous state.
	//
	// Note that you shouldn’t assume the window is definitely not full screen
	// afterward, because other entities (e.g. the user or [window
	// manager][gtk-X11-arch]) could fullscreen it again, and not all window
	// managers honor requests to unfullscreen windows; normally the window will
	// end up restored to its normal state. Just don’t write code that crashes
	// if not.
	//
	// You can track the result of this operation via the Toplevel:state
	// property, or by listening to notifications of the Window:fullscreened
	// property.
	Unfullscreen()
	// Unmaximize asks to unmaximize @window.
	//
	// Note that you shouldn’t assume the window is definitely unmaximized
	// afterward, because other entities (e.g. the user or [window
	// manager][gtk-X11-arch]) could maximize it again, and not all window
	// managers honor requests to unmaximize.
	//
	// You can track the result of this operation via the Toplevel:state
	// property, or by listening to notifications on the Window:maximized
	// property.
	Unmaximize()
	// Unminimize asks to unminimize the specified @window.
	//
	// Note that you shouldn’t assume the window is definitely unminimized
	// afterward, because the windowing system might not support this
	// functionality; other entities (e.g. the user or the [window
	// manager][gtk-X11-arch]) could minimize it again, or there may not be a
	// window manager in which case minimization isn’t possible, etc.
	//
	// You can track result of this operation via the Toplevel:state property.
	Unminimize()
}

type window struct {
	widget
}

// WrapWindow wraps a GObject to the right type. It is
// primarily used internally.
func WrapWindow(obj *externglib.Object) Window {
	return window{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}
}

func marshalWindow(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapWindow(obj), nil
}

// NewWindow constructs a class Window.
func NewWindow() Window {

	ret := C.gtk_window_new()

	var ret0 Window

	ret0 = WrapWindow(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Close requests that the window is closed, similar to what happens when a
// window manager close button is clicked.
//
// This function can be used with close buttons in custom titlebars.
func (window window) Close() {
	var arg0 *C.GtkWindow

	arg0 = (*C.GtkWindow)(window.Native())

	C.gtk_window_close(arg0)
}

// Destroy: drop the internal reference GTK holds on toplevel windows.
func (window window) Destroy() {
	var arg0 *C.GtkWindow

	arg0 = (*C.GtkWindow)(window.Native())

	C.gtk_window_destroy(arg0)
}

// Fullscreen asks to place @window in the fullscreen state.
//
// Note that you shouldn’t assume the window is definitely full screen
// afterward, because other entities (e.g. the user or [window
// manager][gtk-X11-arch]) could unfullscreen it again, and not all window
// managers honor requests to fullscreen windows.
//
// You can track the result of this operation via the Toplevel:state
// property, or by listening to notifications of the Window:fullscreened
// property.
func (window window) Fullscreen() {
	var arg0 *C.GtkWindow

	arg0 = (*C.GtkWindow)(window.Native())

	C.gtk_window_fullscreen(arg0)
}

// FullscreenOnMonitor asks to place @window in the fullscreen state on the
// given @monitor.
//
// Note that you shouldn't assume the window is definitely full screen
// afterward, or that the windowing system allows fullscreen windows on any
// given monitor.
//
// You can track the result of this operation via the Toplevel:state
// property, or by listening to notifications of the Window:fullscreened
// property.
func (window window) FullscreenOnMonitor(monitor gdk.Monitor) {
	var arg0 *C.GtkWindow
	var arg1 *C.GdkMonitor

	arg0 = (*C.GtkWindow)(window.Native())
	arg1 = (*C.GdkMonitor)(monitor.Native())

	C.gtk_window_fullscreen_on_monitor(arg0, arg1)
}

// Application gets the Application associated with the window (if any).
func (window window) Application() Application {
	var arg0 *C.GtkWindow

	arg0 = (*C.GtkWindow)(window.Native())

	ret := C.gtk_window_get_application(arg0)

	var ret0 Application

	ret0 = WrapApplication(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Child gets the child widget of @window.
func (window window) Child() Widget {
	var arg0 *C.GtkWindow

	arg0 = (*C.GtkWindow)(window.Native())

	ret := C.gtk_window_get_child(arg0)

	var ret0 Widget

	ret0 = WrapWidget(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Decorated returns whether the window has been set to have decorations
// such as a title bar via gtk_window_set_decorated().
func (window window) Decorated() bool {
	var arg0 *C.GtkWindow

	arg0 = (*C.GtkWindow)(window.Native())

	ret := C.gtk_window_get_decorated(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// DefaultSize gets the default size of the window. A value of 0 for the
// width or height indicates that a default size has not been explicitly set
// for that dimension, so the “natural” size of the window will be used.
func (window window) DefaultSize() (width int, height int) {
	var arg0 *C.GtkWindow
	var arg1 *C.int // out
	var arg2 *C.int // out

	arg0 = (*C.GtkWindow)(window.Native())

	ret := C.gtk_window_get_default_size(arg0, &arg1, &arg2)

	var ret0 int
	var ret1 int

	ret0 = int(arg1)

	ret1 = int(arg2)

	return ret0, ret1
}

// DefaultWidget returns the default widget for @window.
//
// See gtk_window_set_default_widget() for more details.
func (window window) DefaultWidget() Widget {
	var arg0 *C.GtkWindow

	arg0 = (*C.GtkWindow)(window.Native())

	ret := C.gtk_window_get_default_widget(arg0)

	var ret0 Widget

	ret0 = WrapWidget(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Deletable returns whether the window has been set to have a close button
// via gtk_window_set_deletable().
func (window window) Deletable() bool {
	var arg0 *C.GtkWindow

	arg0 = (*C.GtkWindow)(window.Native())

	ret := C.gtk_window_get_deletable(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// DestroyWithParent returns whether the window will be destroyed with its
// transient parent. See gtk_window_set_destroy_with_parent ().
func (window window) DestroyWithParent() bool {
	var arg0 *C.GtkWindow

	arg0 = (*C.GtkWindow)(window.Native())

	ret := C.gtk_window_get_destroy_with_parent(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Focus retrieves the current focused widget within the window. Note that
// this is the widget that would have the focus if the toplevel window
// focused; if the toplevel window is not focused then `gtk_widget_has_focus
// (widget)` will not be true for the widget.
func (window window) Focus() Widget {
	var arg0 *C.GtkWindow

	arg0 = (*C.GtkWindow)(window.Native())

	ret := C.gtk_window_get_focus(arg0)

	var ret0 Widget

	ret0 = WrapWidget(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// FocusVisible gets the value of the Window:focus-visible property.
func (window window) FocusVisible() bool {
	var arg0 *C.GtkWindow

	arg0 = (*C.GtkWindow)(window.Native())

	ret := C.gtk_window_get_focus_visible(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Group returns the group for @window or the default group, if @window is
// nil or if @window does not have an explicit window group.
func (window window) Group() WindowGroup {
	var arg0 *C.GtkWindow

	arg0 = (*C.GtkWindow)(window.Native())

	ret := C.gtk_window_get_group(arg0)

	var ret0 WindowGroup

	ret0 = WrapWindowGroup(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// HideOnClose returns whether the window will be hidden when the close
// button is clicked.
func (window window) HideOnClose() bool {
	var arg0 *C.GtkWindow

	arg0 = (*C.GtkWindow)(window.Native())

	ret := C.gtk_window_get_hide_on_close(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// IconName returns the name of the themed icon for the window, see
// gtk_window_set_icon_name().
func (window window) IconName() string {
	var arg0 *C.GtkWindow

	arg0 = (*C.GtkWindow)(window.Native())

	ret := C.gtk_window_get_icon_name(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// MnemonicsVisible gets the value of the Window:mnemonics-visible property.
func (window window) MnemonicsVisible() bool {
	var arg0 *C.GtkWindow

	arg0 = (*C.GtkWindow)(window.Native())

	ret := C.gtk_window_get_mnemonics_visible(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Modal returns whether the window is modal. See gtk_window_set_modal().
func (window window) Modal() bool {
	var arg0 *C.GtkWindow

	arg0 = (*C.GtkWindow)(window.Native())

	ret := C.gtk_window_get_modal(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Resizable gets the value set by gtk_window_set_resizable().
func (window window) Resizable() bool {
	var arg0 *C.GtkWindow

	arg0 = (*C.GtkWindow)(window.Native())

	ret := C.gtk_window_get_resizable(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Title retrieves the title of the window. See gtk_window_set_title().
func (window window) Title() string {
	var arg0 *C.GtkWindow

	arg0 = (*C.GtkWindow)(window.Native())

	ret := C.gtk_window_get_title(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Titlebar returns the custom titlebar that has been set with
// gtk_window_set_titlebar().
func (window window) Titlebar() Widget {
	var arg0 *C.GtkWindow

	arg0 = (*C.GtkWindow)(window.Native())

	ret := C.gtk_window_get_titlebar(arg0)

	var ret0 Widget

	ret0 = WrapWidget(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// TransientFor fetches the transient parent for this window. See
// gtk_window_set_transient_for().
func (window window) TransientFor() Window {
	var arg0 *C.GtkWindow

	arg0 = (*C.GtkWindow)(window.Native())

	ret := C.gtk_window_get_transient_for(arg0)

	var ret0 Window

	ret0 = WrapWindow(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// HasGroup returns whether @window has an explicit window group.
func (window window) HasGroup() bool {
	var arg0 *C.GtkWindow

	arg0 = (*C.GtkWindow)(window.Native())

	ret := C.gtk_window_has_group(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// IsActive returns whether the window is part of the current active
// toplevel. (That is, the toplevel window receiving keystrokes.) The return
// value is true if the window is active toplevel itself. You might use this
// function if you wanted to draw a widget differently in an active window
// from a widget in an inactive window.
func (window window) IsActive() bool {
	var arg0 *C.GtkWindow

	arg0 = (*C.GtkWindow)(window.Native())

	ret := C.gtk_window_is_active(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// IsFullscreen retrieves the current fullscreen state of @window.
//
// Note that since fullscreening is ultimately handled by the window manager
// and happens asynchronously to an application request, you shouldn’t
// assume the return value of this function changing immediately (or at
// all), as an effect of calling gtk_window_fullscreen() or
// gtk_window_unfullscreen().
//
// If the window isn't yet mapped, the value returned will whether the
// initial requested state is fullscreen.
func (window window) IsFullscreen() bool {
	var arg0 *C.GtkWindow

	arg0 = (*C.GtkWindow)(window.Native())

	ret := C.gtk_window_is_fullscreen(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// IsMaximized retrieves the current maximized state of @window.
//
// Note that since maximization is ultimately handled by the window manager
// and happens asynchronously to an application request, you shouldn’t
// assume the return value of this function changing immediately (or at
// all), as an effect of calling gtk_window_maximize() or
// gtk_window_unmaximize().
//
// If the window isn't yet mapped, the value returned will whether the
// initial requested state is maximized.
func (window window) IsMaximized() bool {
	var arg0 *C.GtkWindow

	arg0 = (*C.GtkWindow)(window.Native())

	ret := C.gtk_window_is_maximized(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Maximize asks to maximize @window, so that it fills the screen.
//
// Note that you shouldn’t assume the window is definitely maximized
// afterward, because other entities (e.g. the user or [window
// manager][gtk-X11-arch]) could unmaximize it again, and not all window
// managers support maximization.
//
// It’s permitted to call this function before showing a window, in which
// case the window will be maximized when it appears onscreen initially.
//
// You can track the result of this operation via the Toplevel:state
// property, or by listening to notifications on the Window:maximized
// property.
func (window window) Maximize() {
	var arg0 *C.GtkWindow

	arg0 = (*C.GtkWindow)(window.Native())

	C.gtk_window_maximize(arg0)
}

// Minimize asks to minimize the specified @window.
//
// Note that you shouldn’t assume the window is definitely minimized
// afterward, because the windowing system might not support this
// functionality; other entities (e.g. the user or the [window
// manager][gtk-X11-arch]) could unminimize it again, or there may not be a
// window manager in which case minimization isn’t possible, etc.
//
// It’s permitted to call this function before showing a window, in which
// case the window will be minimized before it ever appears onscreen.
//
// You can track result of this operation via the Toplevel:state property.
func (window window) Minimize() {
	var arg0 *C.GtkWindow

	arg0 = (*C.GtkWindow)(window.Native())

	C.gtk_window_minimize(arg0)
}

// Present presents a window to the user. This function should not be used
// as when it is called, it is too late to gather a valid timestamp to allow
// focus stealing prevention to work correctly.
func (window window) Present() {
	var arg0 *C.GtkWindow

	arg0 = (*C.GtkWindow)(window.Native())

	C.gtk_window_present(arg0)
}

// PresentWithTime presents a window to the user. This may mean raising the
// window in the stacking order, unminimizing it, moving it to the current
// desktop, and/or giving it the keyboard focus, possibly dependent on the
// user’s platform, window manager, and preferences.
//
// If @window is hidden, this function calls gtk_widget_show() as well.
//
// This function should be used when the user tries to open a window that’s
// already open. Say for example the preferences dialog is currently open,
// and the user chooses Preferences from the menu a second time; use
// gtk_window_present() to move the already-open dialog where the user can
// see it.
//
// Presents a window to the user in response to a user interaction. The
// timestamp should be gathered when the window was requested to be shown
// (when clicking a link for example), rather than once the window is ready
// to be shown.
func (window window) PresentWithTime(timestamp uint32) {
	var arg0 *C.GtkWindow
	var arg1 C.guint32

	arg0 = (*C.GtkWindow)(window.Native())
	arg1 = C.guint32(timestamp)

	C.gtk_window_present_with_time(arg0, arg1)
}

// SetApplication sets or unsets the Application associated with the window.
//
// The application will be kept alive for at least as long as it has any
// windows associated with it (see g_application_hold() for a way to keep it
// alive without windows).
//
// Normally, the connection between the application and the window will
// remain until the window is destroyed, but you can explicitly remove it by
// setting the @application to nil.
//
// This is equivalent to calling gtk_application_remove_window() and/or
// gtk_application_add_window() on the old/new applications as relevant.
func (window window) SetApplication(application Application) {
	var arg0 *C.GtkWindow
	var arg1 *C.GtkApplication

	arg0 = (*C.GtkWindow)(window.Native())
	arg1 = (*C.GtkApplication)(application.Native())

	C.gtk_window_set_application(arg0, arg1)
}

// SetChild sets the child widget of @window.
func (window window) SetChild(child Widget) {
	var arg0 *C.GtkWindow
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkWindow)(window.Native())
	arg1 = (*C.GtkWidget)(child.Native())

	C.gtk_window_set_child(arg0, arg1)
}

// SetDecorated: by default, windows are decorated with a title bar, resize
// controls, etc. Some [window managers][gtk-X11-arch] allow GTK to disable
// these decorations, creating a borderless window. If you set the decorated
// property to false using this function, GTK will do its best to convince
// the window manager not to decorate the window. Depending on the system,
// this function may not have any effect when called on a window that is
// already visible, so you should call it before calling gtk_widget_show().
//
// On Windows, this function always works, since there’s no window manager
// policy involved.
func (window window) SetDecorated(setting bool) {
	var arg0 *C.GtkWindow
	var arg1 C.gboolean

	arg0 = (*C.GtkWindow)(window.Native())
	arg1 = gextras.Cbool(setting)

	C.gtk_window_set_decorated(arg0, arg1)
}

// SetDefaultSize sets the default size of a window. If the window’s
// “natural” size (its size request) is larger than the default, the default
// will be ignored.
//
// Unlike gtk_widget_set_size_request(), which sets a size request for a
// widget and thus would keep users from shrinking the window, this function
// only sets the initial size, just as if the user had resized the window
// themselves. Users can still shrink the window again as they normally
// would. Setting a default size of -1 means to use the “natural” default
// size (the size request of the window).
//
// The default size of a window only affects the first time a window is
// shown; if a window is hidden and re-shown, it will remember the size it
// had prior to hiding, rather than using the default size.
//
// Windows can’t actually be 0x0 in size, they must be at least 1x1, but
// passing 0 for @width and @height is OK, resulting in a 1x1 default size.
//
// If you use this function to reestablish a previously saved window size,
// note that the appropriate size to save is the one returned by
// gtk_window_get_default_size(). Using the window allocation directly will
// not work in all circumstances and can lead to growing or shrinking
// windows.
func (window window) SetDefaultSize(width int, height int) {
	var arg0 *C.GtkWindow
	var arg1 C.int
	var arg2 C.int

	arg0 = (*C.GtkWindow)(window.Native())
	arg1 = C.int(width)
	arg2 = C.int(height)

	C.gtk_window_set_default_size(arg0, arg1, arg2)
}

// SetDefaultWidget: the default widget is the widget that’s activated when
// the user presses Enter in a dialog (for example). This function sets or
// unsets the default widget for a Window.
func (window window) SetDefaultWidget(defaultWidget Widget) {
	var arg0 *C.GtkWindow
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkWindow)(window.Native())
	arg1 = (*C.GtkWidget)(defaultWidget.Native())

	C.gtk_window_set_default_widget(arg0, arg1)
}

// SetDeletable: by default, windows have a close button in the window
// frame. Some [window managers][gtk-X11-arch] allow GTK to disable this
// button. If you set the deletable property to false using this function,
// GTK will do its best to convince the window manager not to show a close
// button. Depending on the system, this function may not have any effect
// when called on a window that is already visible, so you should call it
// before calling gtk_widget_show().
//
// On Windows, this function always works, since there’s no window manager
// policy involved.
func (window window) SetDeletable(setting bool) {
	var arg0 *C.GtkWindow
	var arg1 C.gboolean

	arg0 = (*C.GtkWindow)(window.Native())
	arg1 = gextras.Cbool(setting)

	C.gtk_window_set_deletable(arg0, arg1)
}

// SetDestroyWithParent: if @setting is true, then destroying the transient
// parent of @window will also destroy @window itself. This is useful for
// dialogs that shouldn’t persist beyond the lifetime of the main window
// they're associated with, for example.
func (window window) SetDestroyWithParent(setting bool) {
	var arg0 *C.GtkWindow
	var arg1 C.gboolean

	arg0 = (*C.GtkWindow)(window.Native())
	arg1 = gextras.Cbool(setting)

	C.gtk_window_set_destroy_with_parent(arg0, arg1)
}

// SetDisplay sets the Display where the @window is displayed; if the window
// is already mapped, it will be unmapped, and then remapped on the new
// display.
func (window window) SetDisplay(display gdk.Display) {
	var arg0 *C.GtkWindow
	var arg1 *C.GdkDisplay

	arg0 = (*C.GtkWindow)(window.Native())
	arg1 = (*C.GdkDisplay)(display.Native())

	C.gtk_window_set_display(arg0, arg1)
}

// SetFocus: if @focus is not the current focus widget, and is focusable,
// sets it as the focus widget for the window. If @focus is nil, unsets the
// focus widget for this window. To set the focus to a particular widget in
// the toplevel, it is usually more convenient to use
// gtk_widget_grab_focus() instead of this function.
func (window window) SetFocus(focus Widget) {
	var arg0 *C.GtkWindow
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkWindow)(window.Native())
	arg1 = (*C.GtkWidget)(focus.Native())

	C.gtk_window_set_focus(arg0, arg1)
}

// SetFocusVisible sets the Window:focus-visible property.
func (window window) SetFocusVisible(setting bool) {
	var arg0 *C.GtkWindow
	var arg1 C.gboolean

	arg0 = (*C.GtkWindow)(window.Native())
	arg1 = gextras.Cbool(setting)

	C.gtk_window_set_focus_visible(arg0, arg1)
}

// SetHideOnClose: if @setting is true, then clicking the close button on
// the window will not destroy it, but only hide it.
func (window window) SetHideOnClose(setting bool) {
	var arg0 *C.GtkWindow
	var arg1 C.gboolean

	arg0 = (*C.GtkWindow)(window.Native())
	arg1 = gextras.Cbool(setting)

	C.gtk_window_set_hide_on_close(arg0, arg1)
}

// SetIconName sets the icon for the window from a named themed icon. See
// the docs for IconTheme for more details. On some platforms, the window
// icon is not used at all.
//
// Note that this has nothing to do with the WM_ICON_NAME property which is
// mentioned in the ICCCM.
func (window window) SetIconName(name string) {
	var arg0 *C.GtkWindow
	var arg1 *C.char

	arg0 = (*C.GtkWindow)(window.Native())
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_window_set_icon_name(arg0, arg1)
}

// SetMnemonicsVisible sets the Window:mnemonics-visible property.
func (window window) SetMnemonicsVisible(setting bool) {
	var arg0 *C.GtkWindow
	var arg1 C.gboolean

	arg0 = (*C.GtkWindow)(window.Native())
	arg1 = gextras.Cbool(setting)

	C.gtk_window_set_mnemonics_visible(arg0, arg1)
}

// SetModal sets a window modal or non-modal. Modal windows prevent
// interaction with other windows in the same application. To keep modal
// dialogs on top of main application windows, use
// gtk_window_set_transient_for() to make the dialog transient for the
// parent; most [window managers][gtk-X11-arch] will then disallow lowering
// the dialog below the parent.
func (window window) SetModal(modal bool) {
	var arg0 *C.GtkWindow
	var arg1 C.gboolean

	arg0 = (*C.GtkWindow)(window.Native())
	arg1 = gextras.Cbool(modal)

	C.gtk_window_set_modal(arg0, arg1)
}

// SetResizable sets whether the user can resize a window.
//
// Windows are user resizable by default.
func (window window) SetResizable(resizable bool) {
	var arg0 *C.GtkWindow
	var arg1 C.gboolean

	arg0 = (*C.GtkWindow)(window.Native())
	arg1 = gextras.Cbool(resizable)

	C.gtk_window_set_resizable(arg0, arg1)
}

// SetStartupID: startup notification identifiers are used by desktop
// environment to track application startup, to provide user feedback and
// other features. This function changes the corresponding property on the
// underlying GdkSurface. Normally, startup identifier is managed
// automatically and you should only use this function in special cases like
// transferring focus from other processes. You should use this function
// before calling gtk_window_present() or any equivalent function generating
// a window map event.
//
// This function is only useful on X11, not with other GTK targets.
func (window window) SetStartupID(startupID string) {
	var arg0 *C.GtkWindow
	var arg1 *C.char

	arg0 = (*C.GtkWindow)(window.Native())
	arg1 = (*C.gchar)(C.CString(startupID))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_window_set_startup_id(arg0, arg1)
}

// SetTitle sets the title of the Window. The title of a window will be
// displayed in its title bar; on the X Window System, the title bar is
// rendered by the [window manager][gtk-X11-arch], so exactly how the title
// appears to users may vary according to a user’s exact configuration. The
// title should help a user distinguish this window from other windows they
// may have open. A good title might include the application name and
// current document filename, for example. document filename, for example.
//
// Passing nil does the same as setting the title to an empty string.
func (window window) SetTitle(title string) {
	var arg0 *C.GtkWindow
	var arg1 *C.char

	arg0 = (*C.GtkWindow)(window.Native())
	arg1 = (*C.gchar)(C.CString(title))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_window_set_title(arg0, arg1)
}

// SetTitlebar sets a custom titlebar for @window.
//
// A typical widget used here is HeaderBar, as it provides various features
// expected of a titlebar while allowing the addition of child widgets to
// it.
//
// If you set a custom titlebar, GTK will do its best to convince the window
// manager not to put its own titlebar on the window. Depending on the
// system, this function may not work for a window that is already visible,
// so you set the titlebar before calling gtk_widget_show().
func (window window) SetTitlebar(titlebar Widget) {
	var arg0 *C.GtkWindow
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkWindow)(window.Native())
	arg1 = (*C.GtkWidget)(titlebar.Native())

	C.gtk_window_set_titlebar(arg0, arg1)
}

// SetTransientFor: dialog windows should be set transient for the main
// application window they were spawned from. This allows [window
// managers][gtk-X11-arch] to e.g. keep the dialog on top of the main
// window, or center the dialog over the main window.
// gtk_dialog_new_with_buttons() and other convenience functions in GTK will
// sometimes call gtk_window_set_transient_for() on your behalf.
//
// Passing nil for @parent unsets the current transient window.
//
// On Windows, this function puts the child window on top of the parent,
// much as the window manager would have done on X.
func (window window) SetTransientFor(parent Window) {
	var arg0 *C.GtkWindow
	var arg1 *C.GtkWindow

	arg0 = (*C.GtkWindow)(window.Native())
	arg1 = (*C.GtkWindow)(parent.Native())

	C.gtk_window_set_transient_for(arg0, arg1)
}

// Unfullscreen asks to remove the fullscreen state for @window, and return
// to its previous state.
//
// Note that you shouldn’t assume the window is definitely not full screen
// afterward, because other entities (e.g. the user or [window
// manager][gtk-X11-arch]) could fullscreen it again, and not all window
// managers honor requests to unfullscreen windows; normally the window will
// end up restored to its normal state. Just don’t write code that crashes
// if not.
//
// You can track the result of this operation via the Toplevel:state
// property, or by listening to notifications of the Window:fullscreened
// property.
func (window window) Unfullscreen() {
	var arg0 *C.GtkWindow

	arg0 = (*C.GtkWindow)(window.Native())

	C.gtk_window_unfullscreen(arg0)
}

// Unmaximize asks to unmaximize @window.
//
// Note that you shouldn’t assume the window is definitely unmaximized
// afterward, because other entities (e.g. the user or [window
// manager][gtk-X11-arch]) could maximize it again, and not all window
// managers honor requests to unmaximize.
//
// You can track the result of this operation via the Toplevel:state
// property, or by listening to notifications on the Window:maximized
// property.
func (window window) Unmaximize() {
	var arg0 *C.GtkWindow

	arg0 = (*C.GtkWindow)(window.Native())

	C.gtk_window_unmaximize(arg0)
}

// Unminimize asks to unminimize the specified @window.
//
// Note that you shouldn’t assume the window is definitely unminimized
// afterward, because the windowing system might not support this
// functionality; other entities (e.g. the user or the [window
// manager][gtk-X11-arch]) could minimize it again, or there may not be a
// window manager in which case minimization isn’t possible, etc.
//
// You can track result of this operation via the Toplevel:state property.
func (window window) Unminimize() {
	var arg0 *C.GtkWindow

	arg0 = (*C.GtkWindow)(window.Native())

	C.gtk_window_unminimize(arg0)
}

// WindowControls gtkWindowControls shows window frame controls, such as
// minimize, maximize and close buttons, and the window icon.
//
// WindowControls only displays start or end side of the controls (see
// WindowControls:side), so it's intended to be always used in pair with another
// WindowControls using the opposite side, for example:
//
//
//    <object class="GtkBox">
//      <child>
//        <object class="GtkWindowControls">
//          <property name="side">start</property>
//        </object>
//      </child>
//
//      ...
//
//      <child>
//        <object class="GtkWindowControls">
//          <property name="side">end</property>
//        </object>
//      </child>
//    </object>
//    ]|
//
//
//
// CSS nodes
//
//
//    |[<!-- language="plain" -->
//    windowcontrols
//    ├── [image.icon]
//    ├── [button.minimize]
//    ├── [button.maximize]
//    ╰── [button.close]
//
//
// A WindowControls' CSS node is called windowcontrols. It contains subnodes
// corresponding to each title button. Which of the title buttons exist and
// where they are placed exactly depends on the desktop environment and
// WindowControls:decoration-layout value.
//
// When WindowControls:empty is true, it gets the .empty style class.
//
//
// Accessibility
//
// GtkWindowHandle uses the GTK_ACCESSIBLE_ROLE_GROUP role.
type WindowControls interface {
	Widget

	// DecorationLayout gets the decoration layout set with
	// gtk_window_controls_set_decoration_layout().
	DecorationLayout() string
	// Empty gets whether the widget has any window buttons.
	Empty() bool
	// Side gets the side set with gtk_window_controls_set_side().
	Side() PackType
	// SetDecorationLayout sets the decoration layout for the title buttons,
	// overriding the Settings:gtk-decoration-layout setting.
	//
	// The format of the string is button names, separated by commas. A colon
	// separates the buttons that should appear on the left from those on the
	// right. Recognized button names are minimize, maximize, close and icon
	// (the window icon).
	//
	// For example, “icon:minimize,maximize,close” specifies a icon on the left,
	// and minimize, maximize and close buttons on the right.
	//
	// If WindowControls:side value is @GTK_PACK_START, @self will display the
	// part before the colon, otherwise after that.
	SetDecorationLayout(layout string)
	// SetSide sets the side for @self, determining which part of decoration
	// layout it uses.
	//
	// See gtk_window_controls_set_decoration_layout()
	SetSide(side PackType)
}

type windowControls struct {
	widget
}

// WrapWindowControls wraps a GObject to the right type. It is
// primarily used internally.
func WrapWindowControls(obj *externglib.Object) WindowControls {
	return windowControls{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}
}

func marshalWindowControls(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapWindowControls(obj), nil
}

// NewWindowControls constructs a class WindowControls.
func NewWindowControls(side PackType) WindowControls {
	var arg1 C.GtkPackType

	arg1 = (C.GtkPackType)(side)

	ret := C.gtk_window_controls_new(arg1)

	var ret0 WindowControls

	ret0 = WrapWindowControls(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// DecorationLayout gets the decoration layout set with
// gtk_window_controls_set_decoration_layout().
func (self windowControls) DecorationLayout() string {
	var arg0 *C.GtkWindowControls

	arg0 = (*C.GtkWindowControls)(self.Native())

	ret := C.gtk_window_controls_get_decoration_layout(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Empty gets whether the widget has any window buttons.
func (self windowControls) Empty() bool {
	var arg0 *C.GtkWindowControls

	arg0 = (*C.GtkWindowControls)(self.Native())

	ret := C.gtk_window_controls_get_empty(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Side gets the side set with gtk_window_controls_set_side().
func (self windowControls) Side() PackType {
	var arg0 *C.GtkWindowControls

	arg0 = (*C.GtkWindowControls)(self.Native())

	ret := C.gtk_window_controls_get_side(arg0)

	var ret0 PackType

	ret0 = PackType(ret)

	return ret0
}

// SetDecorationLayout sets the decoration layout for the title buttons,
// overriding the Settings:gtk-decoration-layout setting.
//
// The format of the string is button names, separated by commas. A colon
// separates the buttons that should appear on the left from those on the
// right. Recognized button names are minimize, maximize, close and icon
// (the window icon).
//
// For example, “icon:minimize,maximize,close” specifies a icon on the left,
// and minimize, maximize and close buttons on the right.
//
// If WindowControls:side value is @GTK_PACK_START, @self will display the
// part before the colon, otherwise after that.
func (self windowControls) SetDecorationLayout(layout string) {
	var arg0 *C.GtkWindowControls
	var arg1 *C.char

	arg0 = (*C.GtkWindowControls)(self.Native())
	arg1 = (*C.gchar)(C.CString(layout))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_window_controls_set_decoration_layout(arg0, arg1)
}

// SetSide sets the side for @self, determining which part of decoration
// layout it uses.
//
// See gtk_window_controls_set_decoration_layout()
func (self windowControls) SetSide(side PackType) {
	var arg0 *C.GtkWindowControls
	var arg1 C.GtkPackType

	arg0 = (*C.GtkWindowControls)(self.Native())
	arg1 = (C.GtkPackType)(side)

	C.gtk_window_controls_set_side(arg0, arg1)
}

// WindowGroup: a WindowGroup restricts the effect of grabs to windows in the
// same group, thereby making window groups almost behave like separate
// applications.
//
// A window can be a member in at most one window group at a time. Windows that
// have not been explicitly assigned to a group are implicitly treated like
// windows of the default window group.
//
// GtkWindowGroup objects are referenced by each window in the group, so once
// you have added all windows to a GtkWindowGroup, you can drop the initial
// reference to the window group with g_object_unref(). If the windows in the
// window group are subsequently destroyed, then they will be removed from the
// window group and drop their references on the window group; when all window
// have been removed, the window group will be freed.
type WindowGroup interface {
	gextras.Objector

	// AddWindow adds a window to a WindowGroup.
	AddWindow(window Window)
	// ListWindows returns a list of the Windows that belong to @window_group.
	ListWindows() *glib.List
	// RemoveWindow removes a window from a WindowGroup.
	RemoveWindow(window Window)
}

type windowGroup struct {
	*externglib.Object
}

// WrapWindowGroup wraps a GObject to the right type. It is
// primarily used internally.
func WrapWindowGroup(obj *externglib.Object) WindowGroup {
	return windowGroup{*externglib.Object{obj}}
}

func marshalWindowGroup(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapWindowGroup(obj), nil
}

// NewWindowGroup constructs a class WindowGroup.
func NewWindowGroup() WindowGroup {

	ret := C.gtk_window_group_new()

	var ret0 WindowGroup

	ret0 = WrapWindowGroup(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// AddWindow adds a window to a WindowGroup.
func (windowGroup windowGroup) AddWindow(window Window) {
	var arg0 *C.GtkWindowGroup
	var arg1 *C.GtkWindow

	arg0 = (*C.GtkWindowGroup)(windowGroup.Native())
	arg1 = (*C.GtkWindow)(window.Native())

	C.gtk_window_group_add_window(arg0, arg1)
}

// ListWindows returns a list of the Windows that belong to @window_group.
func (windowGroup windowGroup) ListWindows() *glib.List {
	var arg0 *C.GtkWindowGroup

	arg0 = (*C.GtkWindowGroup)(windowGroup.Native())

	ret := C.gtk_window_group_list_windows(arg0)

	var ret0 *glib.List

	ret0 = glib.WrapList(ret)

	return ret0
}

// RemoveWindow removes a window from a WindowGroup.
func (windowGroup windowGroup) RemoveWindow(window Window) {
	var arg0 *C.GtkWindowGroup
	var arg1 *C.GtkWindow

	arg0 = (*C.GtkWindowGroup)(windowGroup.Native())
	arg1 = (*C.GtkWindow)(window.Native())

	C.gtk_window_group_remove_window(arg0, arg1)
}

// WindowHandle: gtkWindowHandle is a titlebar area widget. When added into a
// window, it can be dragged to move the window, and handles right click, double
// click and middle click as expected of a titlebar.
//
//
// CSS nodes
//
// WindowHandle has a single CSS node with the name `windowhandle`.
//
//
// Accessibility
//
// GtkWindowHandle uses the GTK_ACCESSIBLE_ROLE_GROUP role.
type WindowHandle interface {
	Widget

	// Child gets the child widget of @self.
	Child() Widget
	// SetChild sets the child widget of @self.
	SetChild(child Widget)
}

type windowHandle struct {
	widget
}

// WrapWindowHandle wraps a GObject to the right type. It is
// primarily used internally.
func WrapWindowHandle(obj *externglib.Object) WindowHandle {
	return windowHandle{widget{externglib.InitiallyUnowned{*externglib.Object{obj}}}}
}

func marshalWindowHandle(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapWindowHandle(obj), nil
}

// NewWindowHandle constructs a class WindowHandle.
func NewWindowHandle() WindowHandle {

	ret := C.gtk_window_handle_new()

	var ret0 WindowHandle

	ret0 = WrapWindowHandle(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Child gets the child widget of @self.
func (self windowHandle) Child() Widget {
	var arg0 *C.GtkWindowHandle

	arg0 = (*C.GtkWindowHandle)(self.Native())

	ret := C.gtk_window_handle_get_child(arg0)

	var ret0 Widget

	ret0 = WrapWidget(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// SetChild sets the child widget of @self.
func (self windowHandle) SetChild(child Widget) {
	var arg0 *C.GtkWindowHandle
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkWindowHandle)(self.Native())
	arg1 = (*C.GtkWidget)(child.Native())

	C.gtk_window_handle_set_child(arg0, arg1)
}
