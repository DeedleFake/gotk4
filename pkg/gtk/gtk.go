// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/internal/gextras"
	"github.com/diamondburned/gotk4/pkg/cairo"
	"github.com/diamondburned/gotk4/pkg/gdk"
	"github.com/diamondburned/gotk4/pkg/gdkpixbuf"
	"github.com/diamondburned/gotk4/pkg/gio"
	"github.com/diamondburned/gotk4/pkg/glib"
	"github.com/diamondburned/gotk4/pkg/graphene"
	"github.com/diamondburned/gotk4/pkg/pango"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gtk4
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <gtk/gtk.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		// Enums
		{T: externglib.Type(C.gtk_accessible_autocomplete_get_type()), F: marshalAccessibleAutocomplete},
		{T: externglib.Type(C.gtk_accessible_invalid_state_get_type()), F: marshalAccessibleInvalidState},
		{T: externglib.Type(C.gtk_accessible_property_get_type()), F: marshalAccessibleProperty},
		{T: externglib.Type(C.gtk_accessible_relation_get_type()), F: marshalAccessibleRelation},
		{T: externglib.Type(C.gtk_accessible_role_get_type()), F: marshalAccessibleRole},
		{T: externglib.Type(C.gtk_accessible_sort_get_type()), F: marshalAccessibleSort},
		{T: externglib.Type(C.gtk_accessible_state_get_type()), F: marshalAccessibleState},
		{T: externglib.Type(C.gtk_accessible_tristate_get_type()), F: marshalAccessibleTristate},
		{T: externglib.Type(C.gtk_align_get_type()), F: marshalAlign},
		{T: externglib.Type(C.gtk_arrow_type_get_type()), F: marshalArrowType},
		{T: externglib.Type(C.gtk_assistant_page_type_get_type()), F: marshalAssistantPageType},
		{T: externglib.Type(C.gtk_baseline_position_get_type()), F: marshalBaselinePosition},
		{T: externglib.Type(C.gtk_border_style_get_type()), F: marshalBorderStyle},
		{T: externglib.Type(C.gtk_builder_error_get_type()), F: marshalBuilderError},
		{T: externglib.Type(C.gtk_buttons_type_get_type()), F: marshalButtonsType},
		{T: externglib.Type(C.gtk_cell_renderer_accel_mode_get_type()), F: marshalCellRendererAccelMode},
		{T: externglib.Type(C.gtk_cell_renderer_mode_get_type()), F: marshalCellRendererMode},
		{T: externglib.Type(C.gtk_constraint_attribute_get_type()), F: marshalConstraintAttribute},
		{T: externglib.Type(C.gtk_constraint_relation_get_type()), F: marshalConstraintRelation},
		{T: externglib.Type(C.gtk_constraint_strength_get_type()), F: marshalConstraintStrength},
		{T: externglib.Type(C.gtk_constraint_vfl_parser_error_get_type()), F: marshalConstraintVflParserError},
		{T: externglib.Type(C.gtk_corner_type_get_type()), F: marshalCornerType},
		// Skipped CssParserError.
		// Skipped CssParserWarning.
		{T: externglib.Type(C.gtk_delete_type_get_type()), F: marshalDeleteType},
		{T: externglib.Type(C.gtk_direction_type_get_type()), F: marshalDirectionType},
		{T: externglib.Type(C.gtk_editable_properties_get_type()), F: marshalEditableProperties},
		{T: externglib.Type(C.gtk_entry_icon_position_get_type()), F: marshalEntryIconPosition},
		{T: externglib.Type(C.gtk_event_sequence_state_get_type()), F: marshalEventSequenceState},
		{T: externglib.Type(C.gtk_file_chooser_action_get_type()), F: marshalFileChooserAction},
		{T: externglib.Type(C.gtk_file_chooser_error_get_type()), F: marshalFileChooserError},
		{T: externglib.Type(C.gtk_filter_change_get_type()), F: marshalFilterChange},
		{T: externglib.Type(C.gtk_filter_match_get_type()), F: marshalFilterMatch},
		{T: externglib.Type(C.gtk_icon_size_get_type()), F: marshalIconSize},
		{T: externglib.Type(C.gtk_icon_theme_error_get_type()), F: marshalIconThemeError},
		{T: externglib.Type(C.gtk_icon_view_drop_position_get_type()), F: marshalIconViewDropPosition},
		{T: externglib.Type(C.gtk_image_type_get_type()), F: marshalImageType},
		{T: externglib.Type(C.gtk_input_purpose_get_type()), F: marshalInputPurpose},
		{T: externglib.Type(C.gtk_justification_get_type()), F: marshalJustification},
		{T: externglib.Type(C.gtk_level_bar_mode_get_type()), F: marshalLevelBarMode},
		{T: externglib.Type(C.gtk_license_get_type()), F: marshalLicense},
		{T: externglib.Type(C.gtk_message_type_get_type()), F: marshalMessageType},
		{T: externglib.Type(C.gtk_movement_step_get_type()), F: marshalMovementStep},
		{T: externglib.Type(C.gtk_notebook_tab_get_type()), F: marshalNotebookTab},
		{T: externglib.Type(C.gtk_number_up_layout_get_type()), F: marshalNumberUpLayout},
		{T: externglib.Type(C.gtk_ordering_get_type()), F: marshalOrdering},
		{T: externglib.Type(C.gtk_orientation_get_type()), F: marshalOrientation},
		{T: externglib.Type(C.gtk_overflow_get_type()), F: marshalOverflow},
		{T: externglib.Type(C.gtk_pack_type_get_type()), F: marshalPackType},
		{T: externglib.Type(C.gtk_pad_action_type_get_type()), F: marshalPadActionType},
		{T: externglib.Type(C.gtk_page_orientation_get_type()), F: marshalPageOrientation},
		{T: externglib.Type(C.gtk_page_set_get_type()), F: marshalPageSet},
		{T: externglib.Type(C.gtk_pan_direction_get_type()), F: marshalPanDirection},
		{T: externglib.Type(C.gtk_policy_type_get_type()), F: marshalPolicyType},
		{T: externglib.Type(C.gtk_position_type_get_type()), F: marshalPositionType},
		{T: externglib.Type(C.gtk_print_duplex_get_type()), F: marshalPrintDuplex},
		{T: externglib.Type(C.gtk_print_error_get_type()), F: marshalPrintError},
		{T: externglib.Type(C.gtk_print_operation_action_get_type()), F: marshalPrintOperationAction},
		{T: externglib.Type(C.gtk_print_operation_result_get_type()), F: marshalPrintOperationResult},
		{T: externglib.Type(C.gtk_print_pages_get_type()), F: marshalPrintPages},
		{T: externglib.Type(C.gtk_print_quality_get_type()), F: marshalPrintQuality},
		{T: externglib.Type(C.gtk_print_status_get_type()), F: marshalPrintStatus},
		{T: externglib.Type(C.gtk_propagation_limit_get_type()), F: marshalPropagationLimit},
		{T: externglib.Type(C.gtk_propagation_phase_get_type()), F: marshalPropagationPhase},
		{T: externglib.Type(C.gtk_recent_manager_error_get_type()), F: marshalRecentManagerError},
		{T: externglib.Type(C.gtk_response_type_get_type()), F: marshalResponseType},
		{T: externglib.Type(C.gtk_revealer_transition_type_get_type()), F: marshalRevealerTransitionType},
		{T: externglib.Type(C.gtk_scroll_step_get_type()), F: marshalScrollStep},
		{T: externglib.Type(C.gtk_scroll_type_get_type()), F: marshalScrollType},
		{T: externglib.Type(C.gtk_scrollable_policy_get_type()), F: marshalScrollablePolicy},
		{T: externglib.Type(C.gtk_selection_mode_get_type()), F: marshalSelectionMode},
		{T: externglib.Type(C.gtk_sensitivity_type_get_type()), F: marshalSensitivityType},
		{T: externglib.Type(C.gtk_shortcut_scope_get_type()), F: marshalShortcutScope},
		{T: externglib.Type(C.gtk_shortcut_type_get_type()), F: marshalShortcutType},
		{T: externglib.Type(C.gtk_size_group_mode_get_type()), F: marshalSizeGroupMode},
		{T: externglib.Type(C.gtk_size_request_mode_get_type()), F: marshalSizeRequestMode},
		{T: externglib.Type(C.gtk_sort_type_get_type()), F: marshalSortType},
		{T: externglib.Type(C.gtk_sorter_change_get_type()), F: marshalSorterChange},
		{T: externglib.Type(C.gtk_sorter_order_get_type()), F: marshalSorterOrder},
		{T: externglib.Type(C.gtk_spin_button_update_policy_get_type()), F: marshalSpinButtonUpdatePolicy},
		{T: externglib.Type(C.gtk_spin_type_get_type()), F: marshalSpinType},
		{T: externglib.Type(C.gtk_stack_transition_type_get_type()), F: marshalStackTransitionType},
		{T: externglib.Type(C.gtk_string_filter_match_mode_get_type()), F: marshalStringFilterMatchMode},
		{T: externglib.Type(C.gtk_system_setting_get_type()), F: marshalSystemSetting},
		{T: externglib.Type(C.gtk_text_direction_get_type()), F: marshalTextDirection},
		{T: externglib.Type(C.gtk_text_extend_selection_get_type()), F: marshalTextExtendSelection},
		{T: externglib.Type(C.gtk_text_view_layer_get_type()), F: marshalTextViewLayer},
		{T: externglib.Type(C.gtk_text_window_type_get_type()), F: marshalTextWindowType},
		{T: externglib.Type(C.gtk_tree_view_column_sizing_get_type()), F: marshalTreeViewColumnSizing},
		{T: externglib.Type(C.gtk_tree_view_drop_position_get_type()), F: marshalTreeViewDropPosition},
		{T: externglib.Type(C.gtk_tree_view_grid_lines_get_type()), F: marshalTreeViewGridLines},
		{T: externglib.Type(C.gtk_unit_get_type()), F: marshalUnit},
		{T: externglib.Type(C.gtk_wrap_mode_get_type()), F: marshalWrapMode},

		// Records
		// Skipped ATContextClass.
		// Skipped AccessibleInterface.
		// Skipped ActionableInterface.
		// Skipped ActivateActionClass.
		// Skipped AdjustmentClass.
		// Skipped AlternativeTriggerClass.
		// Skipped AnyFilterClass.
		// Skipped ApplicationClass.
		// Skipped ApplicationWindowClass.
		// Skipped BinLayoutClass.
		{T: externglib.Type(C.gtk_bitset_get_type()), F: marshalBitset},
		// Skipped BitsetIter.
		// Skipped BookmarkListClass.
		// Skipped BoolFilterClass.
		{T: externglib.Type(C.gtk_border_get_type()), F: marshalBorder},
		// Skipped BoxClass.
		// Skipped BoxLayoutClass.
		// Skipped BuildableIface.
		// Skipped BuildableParseContext.
		// Skipped BuildableParser.
		// Skipped BuilderCScopeClass.
		// Skipped BuilderClass.
		// Skipped BuilderListItemFactoryClass.
		// Skipped BuilderScopeInterface.
		// Skipped ButtonClass.
		// Skipped ButtonPrivate.
		// Skipped CallbackActionClass.
		// Skipped CellAreaClass.
		// Skipped CellAreaContextClass.
		// Skipped CellAreaContextPrivate.
		// Skipped CellEditableIface.
		// Skipped CellLayoutIface.
		// Skipped CellRendererClass.
		// Skipped CellRendererClassPrivate.
		// Skipped CellRendererPrivate.
		// Skipped CellRendererTextClass.
		// Skipped CenterBoxClass.
		// Skipped CenterLayoutClass.
		// Skipped CheckButtonClass.
		// Skipped ColorChooserInterface.
		// Skipped ColumnViewClass.
		// Skipped ColumnViewColumnClass.
		// Skipped ComboBoxClass.
		// Skipped ConstraintClass.
		// Skipped ConstraintGuideClass.
		// Skipped ConstraintLayoutChildClass.
		// Skipped ConstraintLayoutClass.
		// Skipped ConstraintTargetInterface.
		// Skipped CssLocation.
		// Skipped CssProviderClass.
		// Skipped CssProviderPrivate.
		{T: externglib.Type(C.gtk_css_section_get_type()), F: marshalCSSSection},
		// Skipped CssStyleChange.
		// Skipped CustomFilterClass.
		// Skipped CustomLayoutClass.
		// Skipped CustomSorterClass.
		// Skipped DialogClass.
		// Skipped DirectoryListClass.
		// Skipped DragIconClass.
		// Skipped DragSourceClass.
		// Skipped DrawingAreaClass.
		// Skipped DropControllerMotionClass.
		// Skipped DropDownClass.
		// Skipped DropTargetAsyncClass.
		// Skipped DropTargetClass.
		// Skipped EditableInterface.
		// Skipped EditableLabelClass.
		// Skipped EmojiChooserClass.
		// Skipped EntryBufferClass.
		// Skipped EntryClass.
		// Skipped EventControllerClass.
		// Skipped EventControllerFocusClass.
		// Skipped EventControllerKeyClass.
		// Skipped EventControllerLegacyClass.
		// Skipped EventControllerMotionClass.
		// Skipped EventControllerScrollClass.
		// Skipped EveryFilterClass.
		// Skipped ExpressionWatch.
		// Skipped FileChooserNativeClass.
		// Skipped FilterClass.
		// Skipped FilterListModelClass.
		// Skipped FixedClass.
		// Skipped FixedLayoutChildClass.
		// Skipped FixedLayoutClass.
		// Skipped FlattenListModelClass.
		// Skipped FlowBoxChildClass.
		// Skipped FontChooserIface.
		// Skipped FrameClass.
		// Skipped GLAreaClass.
		// Skipped GestureClass.
		// Skipped GestureClickClass.
		// Skipped GestureDragClass.
		// Skipped GestureLongPressClass.
		// Skipped GesturePanClass.
		// Skipped GestureRotateClass.
		// Skipped GestureSingleClass.
		// Skipped GestureStylusClass.
		// Skipped GestureSwipeClass.
		// Skipped GestureZoomClass.
		// Skipped GridClass.
		// Skipped GridLayoutChildClass.
		// Skipped GridLayoutClass.
		// Skipped GridViewClass.
		// Skipped IMContextClass.
		// Skipped IMContextSimpleClass.
		// Skipped IMContextSimplePrivate.
		// Skipped IMMulticontextClass.
		// Skipped IMMulticontextPrivate.
		// Skipped KeyvalTriggerClass.
		// Skipped LayoutChildClass.
		// Skipped LayoutManagerClass.
		// Skipped ListBaseClass.
		// Skipped ListBoxRowClass.
		// Skipped ListItemClass.
		// Skipped ListItemFactoryClass.
		// Skipped ListStoreClass.
		// Skipped ListStorePrivate.
		// Skipped ListViewClass.
		// Skipped MapListModelClass.
		// Skipped MediaControlsClass.
		// Skipped MediaFileClass.
		// Skipped MediaStreamClass.
		// Skipped MessageDialogClass.
		// Skipped MnemonicActionClass.
		// Skipped MnemonicTriggerClass.
		// Skipped MountOperationClass.
		// Skipped MountOperationPrivate.
		// Skipped MultiFilterClass.
		// Skipped MultiSelectionClass.
		// Skipped MultiSorterClass.
		// Skipped NamedActionClass.
		// Skipped NativeDialogClass.
		// Skipped NativeInterface.
		// Skipped NeverTriggerClass.
		// Skipped NoSelectionClass.
		// Skipped NothingActionClass.
		// Skipped NumericSorterClass.
		// Skipped OrientableIface.
		// Skipped OverlayLayoutChildClass.
		// Skipped OverlayLayoutClass.
		// Skipped PadActionEntry.
		// Skipped PadControllerClass.
		// Skipped PageRange.
		{T: externglib.Type(C.gtk_paper_size_get_type()), F: marshalPaperSize},
		// Skipped PasswordEntryClass.
		// Skipped PictureClass.
		// Skipped PopoverClass.
		// Skipped PrintOperationClass.
		// Skipped PrintOperationPreviewIface.
		// Skipped PrintOperationPrivate.
		// Skipped RangeClass.
		// Skipped RecentData.
		{T: externglib.Type(C.gtk_recent_info_get_type()), F: marshalRecentInfo},
		// Skipped RecentManagerClass.
		// Skipped RecentManagerPrivate.
		// Skipped RequestedSize.
		{T: externglib.Type(C.gtk_requisition_get_type()), F: marshalRequisition},
		// Skipped RootInterface.
		// Skipped ScaleButtonClass.
		// Skipped ScaleClass.
		// Skipped ScrollableInterface.
		// Skipped SelectionFilterModelClass.
		// Skipped SelectionModelInterface.
		// Skipped SettingsValue.
		// Skipped ShortcutActionClass.
		// Skipped ShortcutClass.
		// Skipped ShortcutControllerClass.
		// Skipped ShortcutLabelClass.
		// Skipped ShortcutManagerInterface.
		// Skipped ShortcutTriggerClass.
		// Skipped ShortcutsGroupClass.
		// Skipped ShortcutsSectionClass.
		// Skipped ShortcutsShortcutClass.
		// Skipped SignalActionClass.
		// Skipped SignalListItemFactoryClass.
		// Skipped SingleSelectionClass.
		// Skipped SliceListModelClass.
		// Skipped SnapshotClass.
		// Skipped SortListModelClass.
		// Skipped SorterClass.
		// Skipped StringFilterClass.
		// Skipped StringListClass.
		// Skipped StringObjectClass.
		// Skipped StringSorterClass.
		// Skipped StyleContextClass.
		// Skipped TextBTree.
		// Skipped TextBufferClass.
		// Skipped TextBufferPrivate.
		// Skipped TextChildAnchorClass.
		{T: externglib.Type(C.gtk_text_iter_get_type()), F: marshalTextIter},
		// Skipped TextMarkClass.
		// Skipped TextTagClass.
		// Skipped TextTagPrivate.
		// Skipped TextViewClass.
		// Skipped TextViewPrivate.
		// Skipped ToggleButtonClass.
		// Skipped TreeDragDestIface.
		// Skipped TreeDragSourceIface.
		// Skipped TreeExpanderClass.
		{T: externglib.Type(C.gtk_tree_iter_get_type()), F: marshalTreeIter},
		// Skipped TreeListModelClass.
		// Skipped TreeListRowClass.
		// Skipped TreeListRowSorterClass.
		// Skipped TreeModelFilterClass.
		// Skipped TreeModelFilterPrivate.
		// Skipped TreeModelIface.
		// Skipped TreeModelSortClass.
		// Skipped TreeModelSortPrivate.
		{T: externglib.Type(C.gtk_tree_path_get_type()), F: marshalTreePath},
		{T: externglib.Type(C.gtk_tree_row_reference_get_type()), F: marshalTreeRowReference},
		// Skipped TreeSortableIface.
		// Skipped TreeStoreClass.
		// Skipped TreeStorePrivate.
		// Skipped TreeViewClass.
		// Skipped VideoClass.
		// Skipped WidgetClass.
		// Skipped WidgetClassPrivate.
		// Skipped WidgetPaintableClass.
		// Skipped WidgetPrivate.
		// Skipped WindowClass.
		// Skipped WindowControlsClass.
		// Skipped WindowGroupClass.
		// Skipped WindowGroupPrivate.
		// Skipped WindowHandleClass.

		// Classes
		{T: externglib.Type(C.gtk_at_context_get_type()), F: marshalATContext},
		{T: externglib.Type(C.gtk_about_dialog_get_type()), F: marshalAboutDialog},
		{T: externglib.Type(C.gtk_action_bar_get_type()), F: marshalActionBar},
		{T: externglib.Type(C.gtk_activate_action_get_type()), F: marshalActivateAction},
		{T: externglib.Type(C.gtk_adjustment_get_type()), F: marshalAdjustment},
		{T: externglib.Type(C.gtk_alternative_trigger_get_type()), F: marshalAlternativeTrigger},
		{T: externglib.Type(C.gtk_any_filter_get_type()), F: marshalAnyFilter},
		{T: externglib.Type(C.gtk_app_chooser_button_get_type()), F: marshalAppChooserButton},
		{T: externglib.Type(C.gtk_app_chooser_dialog_get_type()), F: marshalAppChooserDialog},
		{T: externglib.Type(C.gtk_app_chooser_widget_get_type()), F: marshalAppChooserWidget},
		{T: externglib.Type(C.gtk_application_get_type()), F: marshalApplication},
		{T: externglib.Type(C.gtk_application_window_get_type()), F: marshalApplicationWindow},
		{T: externglib.Type(C.gtk_aspect_frame_get_type()), F: marshalAspectFrame},
		{T: externglib.Type(C.gtk_assistant_get_type()), F: marshalAssistant},
		{T: externglib.Type(C.gtk_assistant_page_get_type()), F: marshalAssistantPage},
		{T: externglib.Type(C.gtk_bin_layout_get_type()), F: marshalBinLayout},
		{T: externglib.Type(C.gtk_bookmark_list_get_type()), F: marshalBookmarkList},
		{T: externglib.Type(C.gtk_bool_filter_get_type()), F: marshalBoolFilter},
		{T: externglib.Type(C.gtk_box_get_type()), F: marshalBox},
		{T: externglib.Type(C.gtk_box_layout_get_type()), F: marshalBoxLayout},
		{T: externglib.Type(C.gtk_builder_get_type()), F: marshalBuilder},
		{T: externglib.Type(C.gtk_builder_cscope_get_type()), F: marshalBuilderCScope},
		{T: externglib.Type(C.gtk_builder_list_item_factory_get_type()), F: marshalBuilderListItemFactory},
		{T: externglib.Type(C.gtk_button_get_type()), F: marshalButton},
		{T: externglib.Type(C.gtk_cclosure_expression_get_type()), F: marshalCClosureExpression},
		{T: externglib.Type(C.gtk_calendar_get_type()), F: marshalCalendar},
		{T: externglib.Type(C.gtk_callback_action_get_type()), F: marshalCallbackAction},
		{T: externglib.Type(C.gtk_cell_area_get_type()), F: marshalCellArea},
		{T: externglib.Type(C.gtk_cell_area_box_get_type()), F: marshalCellAreaBox},
		{T: externglib.Type(C.gtk_cell_area_context_get_type()), F: marshalCellAreaContext},
		{T: externglib.Type(C.gtk_cell_renderer_get_type()), F: marshalCellRenderer},
		{T: externglib.Type(C.gtk_cell_renderer_accel_get_type()), F: marshalCellRendererAccel},
		{T: externglib.Type(C.gtk_cell_renderer_combo_get_type()), F: marshalCellRendererCombo},
		{T: externglib.Type(C.gtk_cell_renderer_pixbuf_get_type()), F: marshalCellRendererPixbuf},
		{T: externglib.Type(C.gtk_cell_renderer_progress_get_type()), F: marshalCellRendererProgress},
		{T: externglib.Type(C.gtk_cell_renderer_spin_get_type()), F: marshalCellRendererSpin},
		{T: externglib.Type(C.gtk_cell_renderer_spinner_get_type()), F: marshalCellRendererSpinner},
		{T: externglib.Type(C.gtk_cell_renderer_text_get_type()), F: marshalCellRendererText},
		{T: externglib.Type(C.gtk_cell_renderer_toggle_get_type()), F: marshalCellRendererToggle},
		{T: externglib.Type(C.gtk_cell_view_get_type()), F: marshalCellView},
		{T: externglib.Type(C.gtk_center_box_get_type()), F: marshalCenterBox},
		{T: externglib.Type(C.gtk_center_layout_get_type()), F: marshalCenterLayout},
		{T: externglib.Type(C.gtk_check_button_get_type()), F: marshalCheckButton},
		{T: externglib.Type(C.gtk_closure_expression_get_type()), F: marshalClosureExpression},
		{T: externglib.Type(C.gtk_color_button_get_type()), F: marshalColorButton},
		{T: externglib.Type(C.gtk_color_chooser_dialog_get_type()), F: marshalColorChooserDialog},
		{T: externglib.Type(C.gtk_color_chooser_widget_get_type()), F: marshalColorChooserWidget},
		{T: externglib.Type(C.gtk_column_view_get_type()), F: marshalColumnView},
		{T: externglib.Type(C.gtk_column_view_column_get_type()), F: marshalColumnViewColumn},
		{T: externglib.Type(C.gtk_combo_box_get_type()), F: marshalComboBox},
		{T: externglib.Type(C.gtk_combo_box_text_get_type()), F: marshalComboBoxText},
		{T: externglib.Type(C.gtk_constant_expression_get_type()), F: marshalConstantExpression},
		{T: externglib.Type(C.gtk_constraint_get_type()), F: marshalConstraint},
		{T: externglib.Type(C.gtk_constraint_guide_get_type()), F: marshalConstraintGuide},
		{T: externglib.Type(C.gtk_constraint_layout_get_type()), F: marshalConstraintLayout},
		{T: externglib.Type(C.gtk_constraint_layout_child_get_type()), F: marshalConstraintLayoutChild},
		{T: externglib.Type(C.gtk_css_provider_get_type()), F: marshalCSSProvider},
		{T: externglib.Type(C.gtk_custom_filter_get_type()), F: marshalCustomFilter},
		{T: externglib.Type(C.gtk_custom_layout_get_type()), F: marshalCustomLayout},
		{T: externglib.Type(C.gtk_custom_sorter_get_type()), F: marshalCustomSorter},
		{T: externglib.Type(C.gtk_dialog_get_type()), F: marshalDialog},
		{T: externglib.Type(C.gtk_directory_list_get_type()), F: marshalDirectoryList},
		{T: externglib.Type(C.gtk_drag_icon_get_type()), F: marshalDragIcon},
		{T: externglib.Type(C.gtk_drag_source_get_type()), F: marshalDragSource},
		{T: externglib.Type(C.gtk_drawing_area_get_type()), F: marshalDrawingArea},
		{T: externglib.Type(C.gtk_drop_controller_motion_get_type()), F: marshalDropControllerMotion},
		{T: externglib.Type(C.gtk_drop_down_get_type()), F: marshalDropDown},
		{T: externglib.Type(C.gtk_drop_target_get_type()), F: marshalDropTarget},
		{T: externglib.Type(C.gtk_drop_target_async_get_type()), F: marshalDropTargetAsync},
		{T: externglib.Type(C.gtk_editable_label_get_type()), F: marshalEditableLabel},
		{T: externglib.Type(C.gtk_emoji_chooser_get_type()), F: marshalEmojiChooser},
		{T: externglib.Type(C.gtk_entry_get_type()), F: marshalEntry},
		{T: externglib.Type(C.gtk_entry_buffer_get_type()), F: marshalEntryBuffer},
		{T: externglib.Type(C.gtk_entry_completion_get_type()), F: marshalEntryCompletion},
		{T: externglib.Type(C.gtk_event_controller_get_type()), F: marshalEventController},
		{T: externglib.Type(C.gtk_event_controller_focus_get_type()), F: marshalEventControllerFocus},
		{T: externglib.Type(C.gtk_event_controller_key_get_type()), F: marshalEventControllerKey},
		{T: externglib.Type(C.gtk_event_controller_legacy_get_type()), F: marshalEventControllerLegacy},
		{T: externglib.Type(C.gtk_event_controller_motion_get_type()), F: marshalEventControllerMotion},
		{T: externglib.Type(C.gtk_event_controller_scroll_get_type()), F: marshalEventControllerScroll},
		{T: externglib.Type(C.gtk_every_filter_get_type()), F: marshalEveryFilter},
		{T: externglib.Type(C.gtk_expander_get_type()), F: marshalExpander},
		// Skipped Expression.
		{T: externglib.Type(C.gtk_file_chooser_dialog_get_type()), F: marshalFileChooserDialog},
		{T: externglib.Type(C.gtk_file_chooser_native_get_type()), F: marshalFileChooserNative},
		{T: externglib.Type(C.gtk_file_chooser_widget_get_type()), F: marshalFileChooserWidget},
		{T: externglib.Type(C.gtk_file_filter_get_type()), F: marshalFileFilter},
		{T: externglib.Type(C.gtk_filter_get_type()), F: marshalFilter},
		{T: externglib.Type(C.gtk_filter_list_model_get_type()), F: marshalFilterListModel},
		{T: externglib.Type(C.gtk_fixed_get_type()), F: marshalFixed},
		{T: externglib.Type(C.gtk_fixed_layout_get_type()), F: marshalFixedLayout},
		{T: externglib.Type(C.gtk_fixed_layout_child_get_type()), F: marshalFixedLayoutChild},
		{T: externglib.Type(C.gtk_flatten_list_model_get_type()), F: marshalFlattenListModel},
		{T: externglib.Type(C.gtk_flow_box_get_type()), F: marshalFlowBox},
		{T: externglib.Type(C.gtk_flow_box_child_get_type()), F: marshalFlowBoxChild},
		{T: externglib.Type(C.gtk_font_button_get_type()), F: marshalFontButton},
		{T: externglib.Type(C.gtk_font_chooser_dialog_get_type()), F: marshalFontChooserDialog},
		{T: externglib.Type(C.gtk_font_chooser_widget_get_type()), F: marshalFontChooserWidget},
		{T: externglib.Type(C.gtk_frame_get_type()), F: marshalFrame},
		{T: externglib.Type(C.gtk_gl_area_get_type()), F: marshalGLArea},
		{T: externglib.Type(C.gtk_gesture_get_type()), F: marshalGesture},
		{T: externglib.Type(C.gtk_gesture_click_get_type()), F: marshalGestureClick},
		{T: externglib.Type(C.gtk_gesture_drag_get_type()), F: marshalGestureDrag},
		{T: externglib.Type(C.gtk_gesture_long_press_get_type()), F: marshalGestureLongPress},
		{T: externglib.Type(C.gtk_gesture_pan_get_type()), F: marshalGesturePan},
		{T: externglib.Type(C.gtk_gesture_rotate_get_type()), F: marshalGestureRotate},
		{T: externglib.Type(C.gtk_gesture_single_get_type()), F: marshalGestureSingle},
		{T: externglib.Type(C.gtk_gesture_stylus_get_type()), F: marshalGestureStylus},
		{T: externglib.Type(C.gtk_gesture_swipe_get_type()), F: marshalGestureSwipe},
		{T: externglib.Type(C.gtk_gesture_zoom_get_type()), F: marshalGestureZoom},
		{T: externglib.Type(C.gtk_grid_get_type()), F: marshalGrid},
		{T: externglib.Type(C.gtk_grid_layout_get_type()), F: marshalGridLayout},
		{T: externglib.Type(C.gtk_grid_layout_child_get_type()), F: marshalGridLayoutChild},
		{T: externglib.Type(C.gtk_grid_view_get_type()), F: marshalGridView},
		{T: externglib.Type(C.gtk_header_bar_get_type()), F: marshalHeaderBar},
		{T: externglib.Type(C.gtk_im_context_get_type()), F: marshalIMContext},
		{T: externglib.Type(C.gtk_im_context_simple_get_type()), F: marshalIMContextSimple},
		{T: externglib.Type(C.gtk_im_multicontext_get_type()), F: marshalIMMulticontext},
		{T: externglib.Type(C.gtk_icon_paintable_get_type()), F: marshalIconPaintable},
		{T: externglib.Type(C.gtk_icon_theme_get_type()), F: marshalIconTheme},
		{T: externglib.Type(C.gtk_icon_view_get_type()), F: marshalIconView},
		{T: externglib.Type(C.gtk_image_get_type()), F: marshalImage},
		{T: externglib.Type(C.gtk_info_bar_get_type()), F: marshalInfoBar},
		{T: externglib.Type(C.gtk_keyval_trigger_get_type()), F: marshalKeyvalTrigger},
		{T: externglib.Type(C.gtk_label_get_type()), F: marshalLabel},
		{T: externglib.Type(C.gtk_layout_child_get_type()), F: marshalLayoutChild},
		{T: externglib.Type(C.gtk_layout_manager_get_type()), F: marshalLayoutManager},
		{T: externglib.Type(C.gtk_level_bar_get_type()), F: marshalLevelBar},
		{T: externglib.Type(C.gtk_link_button_get_type()), F: marshalLinkButton},
		{T: externglib.Type(C.gtk_list_base_get_type()), F: marshalListBase},
		{T: externglib.Type(C.gtk_list_box_get_type()), F: marshalListBox},
		{T: externglib.Type(C.gtk_list_box_row_get_type()), F: marshalListBoxRow},
		{T: externglib.Type(C.gtk_list_item_get_type()), F: marshalListItem},
		{T: externglib.Type(C.gtk_list_item_factory_get_type()), F: marshalListItemFactory},
		{T: externglib.Type(C.gtk_list_store_get_type()), F: marshalListStore},
		{T: externglib.Type(C.gtk_list_view_get_type()), F: marshalListView},
		{T: externglib.Type(C.gtk_lock_button_get_type()), F: marshalLockButton},
		{T: externglib.Type(C.gtk_map_list_model_get_type()), F: marshalMapListModel},
		{T: externglib.Type(C.gtk_media_controls_get_type()), F: marshalMediaControls},
		{T: externglib.Type(C.gtk_media_file_get_type()), F: marshalMediaFile},
		{T: externglib.Type(C.gtk_media_stream_get_type()), F: marshalMediaStream},
		{T: externglib.Type(C.gtk_menu_button_get_type()), F: marshalMenuButton},
		{T: externglib.Type(C.gtk_message_dialog_get_type()), F: marshalMessageDialog},
		{T: externglib.Type(C.gtk_mnemonic_action_get_type()), F: marshalMnemonicAction},
		{T: externglib.Type(C.gtk_mnemonic_trigger_get_type()), F: marshalMnemonicTrigger},
		{T: externglib.Type(C.gtk_mount_operation_get_type()), F: marshalMountOperation},
		{T: externglib.Type(C.gtk_multi_filter_get_type()), F: marshalMultiFilter},
		{T: externglib.Type(C.gtk_multi_selection_get_type()), F: marshalMultiSelection},
		{T: externglib.Type(C.gtk_multi_sorter_get_type()), F: marshalMultiSorter},
		{T: externglib.Type(C.gtk_named_action_get_type()), F: marshalNamedAction},
		{T: externglib.Type(C.gtk_native_dialog_get_type()), F: marshalNativeDialog},
		{T: externglib.Type(C.gtk_never_trigger_get_type()), F: marshalNeverTrigger},
		{T: externglib.Type(C.gtk_no_selection_get_type()), F: marshalNoSelection},
		{T: externglib.Type(C.gtk_notebook_get_type()), F: marshalNotebook},
		{T: externglib.Type(C.gtk_notebook_page_get_type()), F: marshalNotebookPage},
		{T: externglib.Type(C.gtk_nothing_action_get_type()), F: marshalNothingAction},
		{T: externglib.Type(C.gtk_numeric_sorter_get_type()), F: marshalNumericSorter},
		{T: externglib.Type(C.gtk_object_expression_get_type()), F: marshalObjectExpression},
		{T: externglib.Type(C.gtk_overlay_get_type()), F: marshalOverlay},
		{T: externglib.Type(C.gtk_overlay_layout_get_type()), F: marshalOverlayLayout},
		{T: externglib.Type(C.gtk_overlay_layout_child_get_type()), F: marshalOverlayLayoutChild},
		{T: externglib.Type(C.gtk_pad_controller_get_type()), F: marshalPadController},
		{T: externglib.Type(C.gtk_page_setup_get_type()), F: marshalPageSetup},
		{T: externglib.Type(C.gtk_paned_get_type()), F: marshalPaned},
		// Skipped ParamSpecExpression.
		{T: externglib.Type(C.gtk_password_entry_get_type()), F: marshalPasswordEntry},
		{T: externglib.Type(C.gtk_picture_get_type()), F: marshalPicture},
		{T: externglib.Type(C.gtk_popover_get_type()), F: marshalPopover},
		{T: externglib.Type(C.gtk_popover_menu_get_type()), F: marshalPopoverMenu},
		{T: externglib.Type(C.gtk_popover_menu_bar_get_type()), F: marshalPopoverMenuBar},
		{T: externglib.Type(C.gtk_print_context_get_type()), F: marshalPrintContext},
		{T: externglib.Type(C.gtk_print_operation_get_type()), F: marshalPrintOperation},
		{T: externglib.Type(C.gtk_print_settings_get_type()), F: marshalPrintSettings},
		{T: externglib.Type(C.gtk_progress_bar_get_type()), F: marshalProgressBar},
		{T: externglib.Type(C.gtk_property_expression_get_type()), F: marshalPropertyExpression},
		{T: externglib.Type(C.gtk_range_get_type()), F: marshalRange},
		{T: externglib.Type(C.gtk_recent_manager_get_type()), F: marshalRecentManager},
		{T: externglib.Type(C.gtk_revealer_get_type()), F: marshalRevealer},
		{T: externglib.Type(C.gtk_scale_get_type()), F: marshalScale},
		{T: externglib.Type(C.gtk_scale_button_get_type()), F: marshalScaleButton},
		{T: externglib.Type(C.gtk_scrollbar_get_type()), F: marshalScrollbar},
		{T: externglib.Type(C.gtk_scrolled_window_get_type()), F: marshalScrolledWindow},
		{T: externglib.Type(C.gtk_search_bar_get_type()), F: marshalSearchBar},
		{T: externglib.Type(C.gtk_search_entry_get_type()), F: marshalSearchEntry},
		{T: externglib.Type(C.gtk_selection_filter_model_get_type()), F: marshalSelectionFilterModel},
		{T: externglib.Type(C.gtk_separator_get_type()), F: marshalSeparator},
		{T: externglib.Type(C.gtk_settings_get_type()), F: marshalSettings},
		{T: externglib.Type(C.gtk_shortcut_get_type()), F: marshalShortcut},
		{T: externglib.Type(C.gtk_shortcut_action_get_type()), F: marshalShortcutAction},
		{T: externglib.Type(C.gtk_shortcut_controller_get_type()), F: marshalShortcutController},
		{T: externglib.Type(C.gtk_shortcut_label_get_type()), F: marshalShortcutLabel},
		{T: externglib.Type(C.gtk_shortcut_trigger_get_type()), F: marshalShortcutTrigger},
		{T: externglib.Type(C.gtk_shortcuts_group_get_type()), F: marshalShortcutsGroup},
		{T: externglib.Type(C.gtk_shortcuts_section_get_type()), F: marshalShortcutsSection},
		{T: externglib.Type(C.gtk_shortcuts_shortcut_get_type()), F: marshalShortcutsShortcut},
		{T: externglib.Type(C.gtk_shortcuts_window_get_type()), F: marshalShortcutsWindow},
		{T: externglib.Type(C.gtk_signal_action_get_type()), F: marshalSignalAction},
		{T: externglib.Type(C.gtk_signal_list_item_factory_get_type()), F: marshalSignalListItemFactory},
		{T: externglib.Type(C.gtk_single_selection_get_type()), F: marshalSingleSelection},
		{T: externglib.Type(C.gtk_size_group_get_type()), F: marshalSizeGroup},
		{T: externglib.Type(C.gtk_slice_list_model_get_type()), F: marshalSliceListModel},
		{T: externglib.Type(C.gtk_snapshot_get_type()), F: marshalSnapshot},
		{T: externglib.Type(C.gtk_sort_list_model_get_type()), F: marshalSortListModel},
		{T: externglib.Type(C.gtk_sorter_get_type()), F: marshalSorter},
		{T: externglib.Type(C.gtk_spin_button_get_type()), F: marshalSpinButton},
		{T: externglib.Type(C.gtk_spinner_get_type()), F: marshalSpinner},
		{T: externglib.Type(C.gtk_stack_get_type()), F: marshalStack},
		{T: externglib.Type(C.gtk_stack_page_get_type()), F: marshalStackPage},
		{T: externglib.Type(C.gtk_stack_sidebar_get_type()), F: marshalStackSidebar},
		{T: externglib.Type(C.gtk_stack_switcher_get_type()), F: marshalStackSwitcher},
		{T: externglib.Type(C.gtk_statusbar_get_type()), F: marshalStatusbar},
		{T: externglib.Type(C.gtk_string_filter_get_type()), F: marshalStringFilter},
		{T: externglib.Type(C.gtk_string_list_get_type()), F: marshalStringList},
		{T: externglib.Type(C.gtk_string_object_get_type()), F: marshalStringObject},
		{T: externglib.Type(C.gtk_string_sorter_get_type()), F: marshalStringSorter},
		{T: externglib.Type(C.gtk_style_context_get_type()), F: marshalStyleContext},
		{T: externglib.Type(C.gtk_switch_get_type()), F: marshalSwitch},
		{T: externglib.Type(C.gtk_text_get_type()), F: marshalText},
		{T: externglib.Type(C.gtk_text_buffer_get_type()), F: marshalTextBuffer},
		{T: externglib.Type(C.gtk_text_child_anchor_get_type()), F: marshalTextChildAnchor},
		{T: externglib.Type(C.gtk_text_mark_get_type()), F: marshalTextMark},
		{T: externglib.Type(C.gtk_text_tag_get_type()), F: marshalTextTag},
		{T: externglib.Type(C.gtk_text_tag_table_get_type()), F: marshalTextTagTable},
		{T: externglib.Type(C.gtk_text_view_get_type()), F: marshalTextView},
		{T: externglib.Type(C.gtk_toggle_button_get_type()), F: marshalToggleButton},
		{T: externglib.Type(C.gtk_tooltip_get_type()), F: marshalTooltip},
		{T: externglib.Type(C.gtk_tree_expander_get_type()), F: marshalTreeExpander},
		{T: externglib.Type(C.gtk_tree_list_model_get_type()), F: marshalTreeListModel},
		{T: externglib.Type(C.gtk_tree_list_row_get_type()), F: marshalTreeListRow},
		{T: externglib.Type(C.gtk_tree_list_row_sorter_get_type()), F: marshalTreeListRowSorter},
		{T: externglib.Type(C.gtk_tree_model_filter_get_type()), F: marshalTreeModelFilter},
		{T: externglib.Type(C.gtk_tree_model_sort_get_type()), F: marshalTreeModelSort},
		{T: externglib.Type(C.gtk_tree_selection_get_type()), F: marshalTreeSelection},
		{T: externglib.Type(C.gtk_tree_store_get_type()), F: marshalTreeStore},
		{T: externglib.Type(C.gtk_tree_view_get_type()), F: marshalTreeView},
		{T: externglib.Type(C.gtk_tree_view_column_get_type()), F: marshalTreeViewColumn},
		{T: externglib.Type(C.gtk_video_get_type()), F: marshalVideo},
		{T: externglib.Type(C.gtk_viewport_get_type()), F: marshalViewport},
		{T: externglib.Type(C.gtk_volume_button_get_type()), F: marshalVolumeButton},
		{T: externglib.Type(C.gtk_widget_get_type()), F: marshalWidget},
		{T: externglib.Type(C.gtk_widget_paintable_get_type()), F: marshalWidgetPaintable},
		{T: externglib.Type(C.gtk_window_get_type()), F: marshalWindow},
		{T: externglib.Type(C.gtk_window_controls_get_type()), F: marshalWindowControls},
		{T: externglib.Type(C.gtk_window_group_get_type()), F: marshalWindowGroup},
		{T: externglib.Type(C.gtk_window_handle_get_type()), F: marshalWindowHandle},
	})
}

// Allocation: a Allocation-struct of a widget represents region which has been
// allocated to the widget by its parent. It is a subregion of its parents
// allocation. See [GtkWidget’s geometry management
// section][geometry-management] for more information.
type Allocation gdk.Rectangle

// AccessibleAutocomplete: the possible values for the
// GTK_ACCESSIBLE_PROPERTY_AUTOCOMPLETE accessible property.
type AccessibleAutocomplete int

const (
	// AccessibleAutocompleteNone: automatic suggestions are not displayed.
	AccessibleAutocompleteNone AccessibleAutocomplete = 0
	// AccessibleAutocompleteInline: when a user is providing input, text
	// suggesting one way to complete the provided input may be dynamically
	// inserted after the caret.
	AccessibleAutocompleteInline AccessibleAutocomplete = 1
	// AccessibleAutocompleteList: when a user is providing input, an element
	// containing a collection of values that could complete the provided input
	// may be displayed.
	AccessibleAutocompleteList AccessibleAutocomplete = 2
	// AccessibleAutocompleteBoth: when a user is providing input, an element
	// containing a collection of values that could complete the provided input
	// may be displayed. If displayed, one value in the collection is
	// automatically selected, and the text needed to complete the automatically
	// selected value appears after the caret in the input.
	AccessibleAutocompleteBoth AccessibleAutocomplete = 3
)

func marshalAccessibleAutocomplete(p uintptr) (interface{}, error) {
	return AccessibleAutocomplete(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AccessibleInvalidState: the possible values for the
// GTK_ACCESSIBLE_STATE_INVALID accessible state.
//
// Note that the GTK_ACCESSIBLE_INVALID_FALSE and GTK_ACCESSIBLE_INVALID_TRUE
// have the same values as false and true.
type AccessibleInvalidState int

const (
	// AccessibleInvalidStateFalse: there are no detected errors in the value
	AccessibleInvalidStateFalse AccessibleInvalidState = 0
	// AccessibleInvalidStateTrue: the value entered by the user has failed
	// validation
	AccessibleInvalidStateTrue AccessibleInvalidState = 1
	// AccessibleInvalidStateGrammar: a grammatical error was detected
	AccessibleInvalidStateGrammar AccessibleInvalidState = 2
	// AccessibleInvalidStateSpelling: a spelling error was detected
	AccessibleInvalidStateSpelling AccessibleInvalidState = 3
)

func marshalAccessibleInvalidState(p uintptr) (interface{}, error) {
	return AccessibleInvalidState(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AccessibleProperty: the possible accessible properties of a Accessible.
type AccessibleProperty int

const (
	// AccessiblePropertyAutocomplete: indicates whether inputting text could
	// trigger display of one or more predictions of the user's intended value
	// for a combobox, searchbox, or textbox and specifies how predictions would
	// be presented if they were made. Value type: AccessibleAutocomplete
	AccessiblePropertyAutocomplete AccessibleProperty = 0
	// AccessiblePropertyDescription: defines a string value that describes or
	// annotates the current element. Value type: string
	AccessiblePropertyDescription AccessibleProperty = 1
	// AccessiblePropertyHasPopup: indicates the availability and type of
	// interactive popup element, such as menu or dialog, that can be triggered
	// by an element.
	AccessiblePropertyHasPopup AccessibleProperty = 2
	// AccessiblePropertyKeyShortcuts: indicates keyboard shortcuts that an
	// author has implemented to activate or give focus to an element. Value
	// type: string
	AccessiblePropertyKeyShortcuts AccessibleProperty = 3
	// AccessiblePropertyLabel: defines a string value that labels the current
	// element. Value type: string
	AccessiblePropertyLabel AccessibleProperty = 4
	// AccessiblePropertyLevel: defines the hierarchical level of an element
	// within a structure. Value type: integer
	AccessiblePropertyLevel AccessibleProperty = 5
	// AccessiblePropertyModal: indicates whether an element is modal when
	// displayed. Value type: boolean
	AccessiblePropertyModal AccessibleProperty = 6
	// AccessiblePropertyMultiLine: indicates whether a text box accepts
	// multiple lines of input or only a single line. Value type: boolean
	AccessiblePropertyMultiLine AccessibleProperty = 7
	// AccessiblePropertyMultiSelectable: indicates that the user may select
	// more than one item from the current selectable descendants. Value type:
	// boolean
	AccessiblePropertyMultiSelectable AccessibleProperty = 8
	// AccessiblePropertyOrientation: indicates whether the element's
	// orientation is horizontal, vertical, or unknown/ambiguous. Value type:
	// Orientation
	AccessiblePropertyOrientation AccessibleProperty = 9
	// AccessiblePropertyPlaceholder: defines a short hint (a word or short
	// phrase) intended to aid the user with data entry when the control has no
	// value. A hint could be a sample value or a brief description of the
	// expected format. Value type: string
	AccessiblePropertyPlaceholder AccessibleProperty = 10
	// AccessiblePropertyReadOnly: indicates that the element is not editable,
	// but is otherwise operable. Value type: boolean
	AccessiblePropertyReadOnly AccessibleProperty = 11
	// AccessiblePropertyRequired: indicates that user input is required on the
	// element before a form may be submitted. Value type: boolean
	AccessiblePropertyRequired AccessibleProperty = 12
	// AccessiblePropertyRoleDescription: defines a human-readable,
	// author-localized description for the role of an element. Value type:
	// string
	AccessiblePropertyRoleDescription AccessibleProperty = 13
	// AccessiblePropertySort: indicates if items in a table or grid are sorted
	// in ascending or descending order. Possible property values are in the
	// AccessibleSort enumeration. Value type: AccessibleSort
	AccessiblePropertySort AccessibleProperty = 14
	// AccessiblePropertyValueMax: defines the maximum allowed value for a range
	// widget. Value type: double
	AccessiblePropertyValueMax AccessibleProperty = 15
	// AccessiblePropertyValueMin: defines the minimum allowed value for a range
	// widget. Value type: double
	AccessiblePropertyValueMin AccessibleProperty = 16
	// AccessiblePropertyValueNow: defines the current value for a range widget.
	// Value type: double
	AccessiblePropertyValueNow AccessibleProperty = 17
	// AccessiblePropertyValueText: defines the human readable text alternative
	// of aria-valuenow for a range widget. Value type: string
	AccessiblePropertyValueText AccessibleProperty = 18
)

func marshalAccessibleProperty(p uintptr) (interface{}, error) {
	return AccessibleProperty(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AccessibleRelation: the possible accessible relations of a Accessible.
// Accessible relations can be references to other widgets, integers or strings.
type AccessibleRelation int

const (
	// AccessibleRelationActiveDescendant: identifies the currently active
	// element when focus is on a composite widget, combobox, textbox, group, or
	// application. Value type: reference
	AccessibleRelationActiveDescendant AccessibleRelation = 0
	// AccessibleRelationColCount: defines the total number of columns in a
	// table, grid, or treegrid. Value type: integer
	AccessibleRelationColCount AccessibleRelation = 1
	// AccessibleRelationColIndex: defines an element's column index or position
	// with respect to the total number of columns within a table, grid, or
	// treegrid. Value type: integer
	AccessibleRelationColIndex AccessibleRelation = 2
	// AccessibleRelationColIndexText: defines a human readable text alternative
	// of GTK_ACCESSIBLE_RELATION_COL_INDEX. Value type: string
	AccessibleRelationColIndexText AccessibleRelation = 3
	// AccessibleRelationColSpan: defines the number of columns spanned by a
	// cell or gridcell within a table, grid, or treegrid. Value type: integer
	AccessibleRelationColSpan AccessibleRelation = 4
	// AccessibleRelationControls: identifies the element (or elements) whose
	// contents or presence are controlled by the current element. Value type:
	// reference
	AccessibleRelationControls AccessibleRelation = 5
	// AccessibleRelationDescribedBy: identifies the element (or elements) that
	// describes the object. Value type: reference
	AccessibleRelationDescribedBy AccessibleRelation = 6
	// AccessibleRelationDetails: identifies the element (or elements) that
	// provide additional information related to the object. Value type:
	// reference
	AccessibleRelationDetails AccessibleRelation = 7
	// AccessibleRelationErrorMessage: identifies the element that provides an
	// error message for an object. Value type: reference
	AccessibleRelationErrorMessage AccessibleRelation = 8
	// AccessibleRelationFlowTo: identifies the next element (or elements) in an
	// alternate reading order of content which, at the user's discretion,
	// allows assistive technology to override the general default of reading in
	// document source order. Value type: reference
	AccessibleRelationFlowTo AccessibleRelation = 9
	// AccessibleRelationLabelledBy: identifies the element (or elements) that
	// labels the current element. Value type: reference
	AccessibleRelationLabelledBy AccessibleRelation = 10
	// AccessibleRelationOwns: identifies an element (or elements) in order to
	// define a visual, functional, or contextual parent/child relationship
	// between elements where the widget hierarchy cannot be used to represent
	// the relationship. Value type: reference
	AccessibleRelationOwns AccessibleRelation = 11
	// AccessibleRelationPosInSet: defines an element's number or position in
	// the current set of listitems or treeitems. Value type: integer
	AccessibleRelationPosInSet AccessibleRelation = 12
	// AccessibleRelationRowCount: defines the total number of rows in a table,
	// grid, or treegrid. Value type: integer
	AccessibleRelationRowCount AccessibleRelation = 13
	// AccessibleRelationRowIndex: defines an element's row index or position
	// with respect to the total number of rows within a table, grid, or
	// treegrid. Value type: integer
	AccessibleRelationRowIndex AccessibleRelation = 14
	// AccessibleRelationRowIndexText: defines a human readable text alternative
	// of aria-rowindex. Value type: string
	AccessibleRelationRowIndexText AccessibleRelation = 15
	// AccessibleRelationRowSpan: defines the number of rows spanned by a cell
	// or gridcell within a table, grid, or treegrid. Value type: integer
	AccessibleRelationRowSpan AccessibleRelation = 16
	// AccessibleRelationSetSize: defines the number of items in the current set
	// of listitems or treeitems. Value type: integer
	AccessibleRelationSetSize AccessibleRelation = 17
)

func marshalAccessibleRelation(p uintptr) (interface{}, error) {
	return AccessibleRelation(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AccessibleRole: the accessible role for a Accessible implementation.
//
// Abstract roles are only used as part of the ontology; application developers
// must not use abstract roles in their code.
type AccessibleRole int

const (
	// AccessibleRoleAlert: an element with important, and usually
	// time-sensitive, information
	AccessibleRoleAlert AccessibleRole = 0
	// AccessibleRoleAlertDialog: a type of dialog that contains an alert
	// message
	AccessibleRoleAlertDialog AccessibleRole = 1
	// AccessibleRoleBanner: unused
	AccessibleRoleBanner AccessibleRole = 2
	// AccessibleRoleButton: an input element that allows for user-triggered
	// actions when clicked or pressed
	AccessibleRoleButton AccessibleRole = 3
	// AccessibleRoleCaption: unused
	AccessibleRoleCaption AccessibleRole = 4
	// AccessibleRoleCell: unused
	AccessibleRoleCell AccessibleRole = 5
	// AccessibleRoleCheckbox: a checkable input element that has three possible
	// values: `true`, `false`, or `mixed`
	AccessibleRoleCheckbox AccessibleRole = 6
	// AccessibleRoleColumnHeader: a header in a columned list.
	AccessibleRoleColumnHeader AccessibleRole = 7
	// AccessibleRoleComboBox: an input that controls another element, such as a
	// list or a grid, that can dynamically pop up to help the user set the
	// value of the input
	AccessibleRoleComboBox AccessibleRole = 8
	// AccessibleRoleCommand: abstract role.
	AccessibleRoleCommand AccessibleRole = 9
	// AccessibleRoleComposite: abstract role.
	AccessibleRoleComposite AccessibleRole = 10
	// AccessibleRoleDialog: a dialog is a window that is designed to interrupt
	// the current processing of an application in order to prompt the user to
	// enter information or require a response.
	AccessibleRoleDialog AccessibleRole = 11
	// AccessibleRoleDocument: unused
	AccessibleRoleDocument AccessibleRole = 12
	// AccessibleRoleFeed: unused
	AccessibleRoleFeed AccessibleRole = 13
	// AccessibleRoleForm: unused
	AccessibleRoleForm AccessibleRole = 14
	// AccessibleRoleGeneric: unused
	AccessibleRoleGeneric AccessibleRole = 15
	// AccessibleRoleGrid: a grid of items.
	AccessibleRoleGrid AccessibleRole = 16
	// AccessibleRoleGridCell: an item in a grid or tree grid.
	AccessibleRoleGridCell AccessibleRole = 17
	// AccessibleRoleGroup: an element that groups multiple widgets. GTK uses
	// this role for various containers, like Box, Viewport, and HeaderBar.
	AccessibleRoleGroup AccessibleRole = 18
	// AccessibleRoleHeading: unused
	AccessibleRoleHeading AccessibleRole = 19
	// AccessibleRoleImg: an image.
	AccessibleRoleImg AccessibleRole = 20
	// AccessibleRoleInput: abstract role.
	AccessibleRoleInput AccessibleRole = 21
	// AccessibleRoleLabel: a visible name or caption for a user interface
	// component.
	AccessibleRoleLabel AccessibleRole = 22
	// AccessibleRoleLandmark: abstract role.
	AccessibleRoleLandmark AccessibleRole = 23
	// AccessibleRoleLegend: unused
	AccessibleRoleLegend AccessibleRole = 24
	// AccessibleRoleLink: a clickable link.
	AccessibleRoleLink AccessibleRole = 25
	// AccessibleRoleList: a list of items.
	AccessibleRoleList AccessibleRole = 26
	// AccessibleRoleListBox: unused.
	AccessibleRoleListBox AccessibleRole = 27
	// AccessibleRoleListItem: an item in a list.
	AccessibleRoleListItem AccessibleRole = 28
	// AccessibleRoleLog: unused
	AccessibleRoleLog AccessibleRole = 29
	// AccessibleRoleMain: unused
	AccessibleRoleMain AccessibleRole = 30
	// AccessibleRoleMarquee: unused
	AccessibleRoleMarquee AccessibleRole = 31
	// AccessibleRoleMath: unused
	AccessibleRoleMath AccessibleRole = 32
	// AccessibleRoleMeter: an element that represents a value within a known
	// range.
	AccessibleRoleMeter AccessibleRole = 33
	// AccessibleRoleMenu: a menu.
	AccessibleRoleMenu AccessibleRole = 34
	// AccessibleRoleMenuBar: a menubar.
	AccessibleRoleMenuBar AccessibleRole = 35
	// AccessibleRoleMenuItem: an item in a menu.
	AccessibleRoleMenuItem AccessibleRole = 36
	// AccessibleRoleMenuItemCheckbox: a check item in a menu.
	AccessibleRoleMenuItemCheckbox AccessibleRole = 37
	// AccessibleRoleMenuItemRadio: a radio item in a menu.
	AccessibleRoleMenuItemRadio AccessibleRole = 38
	// AccessibleRoleNavigation: unused
	AccessibleRoleNavigation AccessibleRole = 39
	// AccessibleRoleNone: an element that is not represented to accessibility
	// technologies.
	AccessibleRoleNone AccessibleRole = 40
	// AccessibleRoleNote: unused
	AccessibleRoleNote AccessibleRole = 41
	// AccessibleRoleOption: unused
	AccessibleRoleOption AccessibleRole = 42
	// AccessibleRolePresentation: an element that is not represented to
	// accessibility technologies.
	AccessibleRolePresentation AccessibleRole = 43
	// AccessibleRoleProgressBar: an element that displays the progress status
	// for tasks that take a long time.
	AccessibleRoleProgressBar AccessibleRole = 44
	// AccessibleRoleRadio: a checkable input in a group of radio roles, only
	// one of which can be checked at a time.
	AccessibleRoleRadio AccessibleRole = 45
	// AccessibleRoleRadioGroup: unused
	AccessibleRoleRadioGroup AccessibleRole = 46
	// AccessibleRoleRange: abstract role.
	AccessibleRoleRange AccessibleRole = 47
	// AccessibleRoleRegion: unused
	AccessibleRoleRegion AccessibleRole = 48
	// AccessibleRoleRow: a row in a columned list.
	AccessibleRoleRow AccessibleRole = 49
	// AccessibleRoleRowGroup: unused
	AccessibleRoleRowGroup AccessibleRole = 50
	// AccessibleRoleRowHeader: unused
	AccessibleRoleRowHeader AccessibleRole = 51
	// AccessibleRoleScrollbar: a graphical object that controls the scrolling
	// of content within a viewing area, regardless of whether the content is
	// fully displayed within the viewing area.
	AccessibleRoleScrollbar AccessibleRole = 52
	// AccessibleRoleSearch: unused
	AccessibleRoleSearch AccessibleRole = 53
	// AccessibleRoleSearchBox: a type of textbox intended for specifying search
	// criteria.
	AccessibleRoleSearchBox AccessibleRole = 54
	// AccessibleRoleSection: abstract role.
	AccessibleRoleSection AccessibleRole = 55
	// AccessibleRoleSectionHead: abstract role.
	AccessibleRoleSectionHead AccessibleRole = 56
	// AccessibleRoleSelect: abstract role.
	AccessibleRoleSelect AccessibleRole = 57
	// AccessibleRoleSeparator: a divider that separates and distinguishes
	// sections of content or groups of menuitems.
	AccessibleRoleSeparator AccessibleRole = 58
	// AccessibleRoleSlider: a user input where the user selects a value from
	// within a given range.
	AccessibleRoleSlider AccessibleRole = 59
	// AccessibleRoleSpinButton: a form of range that expects the user to select
	// from among discrete choices.
	AccessibleRoleSpinButton AccessibleRole = 60
	// AccessibleRoleStatus: unused
	AccessibleRoleStatus AccessibleRole = 61
	// AccessibleRoleStructure: abstract role.
	AccessibleRoleStructure AccessibleRole = 62
	// AccessibleRoleSwitch: a type of checkbox that represents on/off values,
	// as opposed to checked/unchecked values.
	AccessibleRoleSwitch AccessibleRole = 63
	// AccessibleRoleTab: an item in a list of tab used for switching pages.
	AccessibleRoleTab AccessibleRole = 64
	// AccessibleRoleTable: unused
	AccessibleRoleTable AccessibleRole = 65
	// AccessibleRoleTabList: a list of tabs for switching pages.
	AccessibleRoleTabList AccessibleRole = 66
	// AccessibleRoleTabPanel: a page in a notebook or stack.
	AccessibleRoleTabPanel AccessibleRole = 67
	// AccessibleRoleTextBox: a type of input that allows free-form text as its
	// value.
	AccessibleRoleTextBox AccessibleRole = 68
	// AccessibleRoleTime: unused
	AccessibleRoleTime AccessibleRole = 69
	// AccessibleRoleTimer: unused
	AccessibleRoleTimer AccessibleRole = 70
	// AccessibleRoleToolbar: unused
	AccessibleRoleToolbar AccessibleRole = 71
	// AccessibleRoleTooltip: unused
	AccessibleRoleTooltip AccessibleRole = 72
	// AccessibleRoleTree: unused
	AccessibleRoleTree AccessibleRole = 73
	// AccessibleRoleTreeGrid: a treeview-like, columned list.
	AccessibleRoleTreeGrid AccessibleRole = 74
	// AccessibleRoleTreeItem: unused
	AccessibleRoleTreeItem AccessibleRole = 75
	// AccessibleRoleWidget: an interactive component of a graphical user
	// interface. This is the role that GTK uses by default for widgets.
	AccessibleRoleWidget AccessibleRole = 76
	// AccessibleRoleWindow: an application window.
	AccessibleRoleWindow AccessibleRole = 77
)

func marshalAccessibleRole(p uintptr) (interface{}, error) {
	return AccessibleRole(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AccessibleSort: the possible values for the GTK_ACCESSIBLE_PROPERTY_SORT
// accessible property.
type AccessibleSort int

const (
	// AccessibleSortNone: there is no defined sort applied to the column.
	AccessibleSortNone AccessibleSort = 0
	// AccessibleSortAscending: items are sorted in ascending order by this
	// column.
	AccessibleSortAscending AccessibleSort = 1
	// AccessibleSortDescending: items are sorted in descending order by this
	// column.
	AccessibleSortDescending AccessibleSort = 2
	// AccessibleSortOther: a sort algorithm other than ascending or descending
	// has been applied.
	AccessibleSortOther AccessibleSort = 3
)

func marshalAccessibleSort(p uintptr) (interface{}, error) {
	return AccessibleSort(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AccessibleState: the possible accessible states of a Accessible.
type AccessibleState int

const (
	// AccessibleStateBusy: a “busy” state. This state has boolean values
	AccessibleStateBusy AccessibleState = 0
	// AccessibleStateChecked: a “checked” state; indicates the current state of
	// a CheckButton. Value type: AccessibleTristate
	AccessibleStateChecked AccessibleState = 1
	// AccessibleStateDisabled: a “disabled” state; corresponds to the
	// Widget:sensitive property on Widget. It indicates a UI element that is
	// perceivable, but not editable or operable. Value type: boolean
	AccessibleStateDisabled AccessibleState = 2
	// AccessibleStateExpanded: an “expanded” state; corresponds to the
	// Expander:expanded property on Expander. Value type: boolean or undefined
	AccessibleStateExpanded AccessibleState = 3
	// AccessibleStateHidden: a “hidden” state; corresponds to the
	// Widget:visible property on Widget. You can use this state explicitly on
	// UI elements that should not be exposed to an assistive technology. Value
	// type: boolean See also: GTK_ACCESSIBLE_STATE_DISABLED
	AccessibleStateHidden AccessibleState = 4
	// AccessibleStateInvalid: an “invalid” state; set when a widget is showing
	// an error. Value type: AccessibleInvalidState
	AccessibleStateInvalid AccessibleState = 5
	// AccessibleStatePressed: a “pressed” state; indicates the current state of
	// a ToggleButton. Value type: AccessibleTristate enumeration
	AccessibleStatePressed AccessibleState = 6
	// AccessibleStateSelected: a “selected” state; set when a widget is
	// selected. Value type: boolean or undefined
	AccessibleStateSelected AccessibleState = 7
)

func marshalAccessibleState(p uintptr) (interface{}, error) {
	return AccessibleState(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AccessibleTristate: the possible values for the GTK_ACCESSIBLE_STATE_PRESSED
// accessible state.
//
// Note that the GTK_ACCESSIBLE_TRISTATE_FALSE and GTK_ACCESSIBLE_TRISTATE_TRUE
// have the same values as false and true.
type AccessibleTristate int

const (
	// AccessibleTristateFalse: the state is `false`
	AccessibleTristateFalse AccessibleTristate = 0
	// AccessibleTristateTrue: the state is `true`
	AccessibleTristateTrue AccessibleTristate = 1
	// AccessibleTristateMixed: the state is `mixed`
	AccessibleTristateMixed AccessibleTristate = 2
)

func marshalAccessibleTristate(p uintptr) (interface{}, error) {
	return AccessibleTristate(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// Align: controls how a widget deals with extra space in a single (x or y)
// dimension.
//
// Alignment only matters if the widget receives a “too large” allocation, for
// example if you packed the widget with the Widget:hexpand property inside a
// Box, then the widget might get extra space. If you have for example a 16x16
// icon inside a 32x32 space, the icon could be scaled and stretched, it could
// be centered, or it could be positioned to one side of the space.
//
// Note that in horizontal context GTK_ALIGN_START and GTK_ALIGN_END are
// interpreted relative to text direction.
//
// GTK_ALIGN_BASELINE support is optional for containers and widgets, and it is
// only supported for vertical alignment. When it's not supported by a child or
// a container it is treated as GTK_ALIGN_FILL.
type Align int

const (
	// AlignFill: stretch to fill all space if possible, center if no meaningful
	// way to stretch
	AlignFill Align = 0
	// AlignStart: snap to left or top side, leaving space on right or bottom
	AlignStart Align = 1
	// AlignEnd: snap to right or bottom side, leaving space on left or top
	AlignEnd Align = 2
	// AlignCenter: center natural width of widget inside the allocation
	AlignCenter Align = 3
	// AlignBaseline: align the widget according to the baseline. See Widget
	AlignBaseline Align = 4
)

func marshalAlign(p uintptr) (interface{}, error) {
	return Align(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ArrowType: used to indicate the direction in which an arrow should point.
type ArrowType int

const (
	// ArrowTypeUp: represents an upward pointing arrow.
	ArrowTypeUp ArrowType = 0
	// ArrowTypeDown: represents a downward pointing arrow.
	ArrowTypeDown ArrowType = 1
	// ArrowTypeLeft: represents a left pointing arrow.
	ArrowTypeLeft ArrowType = 2
	// ArrowTypeRight: represents a right pointing arrow.
	ArrowTypeRight ArrowType = 3
	// ArrowTypeNone: no arrow.
	ArrowTypeNone ArrowType = 4
)

func marshalArrowType(p uintptr) (interface{}, error) {
	return ArrowType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AssistantPageType: an enum for determining the page role inside the
// Assistant. It's used to handle buttons sensitivity and visibility.
//
// Note that an assistant needs to end its page flow with a page of type
// GTK_ASSISTANT_PAGE_CONFIRM, GTK_ASSISTANT_PAGE_SUMMARY or
// GTK_ASSISTANT_PAGE_PROGRESS to be correct.
//
// The Cancel button will only be shown if the page isn’t “committed”. See
// gtk_assistant_commit() for details.
type AssistantPageType int

const (
	// AssistantPageTypeContent: the page has regular contents. Both the Back
	// and forward buttons will be shown.
	AssistantPageTypeContent AssistantPageType = 0
	// AssistantPageTypeIntro: the page contains an introduction to the
	// assistant task. Only the Forward button will be shown if there is a next
	// page.
	AssistantPageTypeIntro AssistantPageType = 1
	// AssistantPageTypeConfirm: the page lets the user confirm or deny the
	// changes. The Back and Apply buttons will be shown.
	AssistantPageTypeConfirm AssistantPageType = 2
	// AssistantPageTypeSummary: the page informs the user of the changes done.
	// Only the Close button will be shown.
	AssistantPageTypeSummary AssistantPageType = 3
	// AssistantPageTypeProgress: used for tasks that take a long time to
	// complete, blocks the assistant until the page is marked as complete. Only
	// the back button will be shown.
	AssistantPageTypeProgress AssistantPageType = 4
	// AssistantPageTypeCustom: used for when other page types are not
	// appropriate. No buttons will be shown, and the application must add its
	// own buttons through gtk_assistant_add_action_widget().
	AssistantPageTypeCustom AssistantPageType = 5
)

func marshalAssistantPageType(p uintptr) (interface{}, error) {
	return AssistantPageType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// BaselinePosition: whenever a container has some form of natural row it may
// align children in that row along a common typographical baseline. If the
// amount of vertical space in the row is taller than the total requested height
// of the baseline-aligned children then it can use a BaselinePosition to select
// where to put the baseline inside the extra available space.
type BaselinePosition int

const (
	// BaselinePositionTop: align the baseline at the top
	BaselinePositionTop BaselinePosition = 0
	// BaselinePositionCenter: center the baseline
	BaselinePositionCenter BaselinePosition = 1
	// BaselinePositionBottom: align the baseline at the bottom
	BaselinePositionBottom BaselinePosition = 2
)

func marshalBaselinePosition(p uintptr) (interface{}, error) {
	return BaselinePosition(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// BorderStyle: describes how the border of a UI element should be rendered.
type BorderStyle int

const (
	// BorderStyleNone: no visible border
	BorderStyleNone BorderStyle = 0
	// BorderStyleHidden: same as GTK_BORDER_STYLE_NONE
	BorderStyleHidden BorderStyle = 1
	// BorderStyleSolid: a single line segment
	BorderStyleSolid BorderStyle = 2
	// BorderStyleInset: looks as if the content is sunken into the canvas
	BorderStyleInset BorderStyle = 3
	// BorderStyleOutset: looks as if the content is coming out of the canvas
	BorderStyleOutset BorderStyle = 4
	// BorderStyleDotted: a series of round dots
	BorderStyleDotted BorderStyle = 5
	// BorderStyleDashed: a series of square-ended dashes
	BorderStyleDashed BorderStyle = 6
	// BorderStyleDouble: two parallel lines with some space between them
	BorderStyleDouble BorderStyle = 7
	// BorderStyleGroove: looks as if it were carved in the canvas
	BorderStyleGroove BorderStyle = 8
	// BorderStyleRidge: looks as if it were coming out of the canvas
	BorderStyleRidge BorderStyle = 9
)

func marshalBorderStyle(p uintptr) (interface{}, error) {
	return BorderStyle(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// BuilderError: error codes that identify various errors that can occur while
// using Builder.
type BuilderError int

const (
	// BuilderErrorInvalidTypeFunction: a type-func attribute didn’t name a
	// function that returns a #GType.
	BuilderErrorInvalidTypeFunction BuilderError = 0
	// BuilderErrorUnhandledTag: the input contained a tag that Builder can’t
	// handle.
	BuilderErrorUnhandledTag BuilderError = 1
	// BuilderErrorMissingAttribute: an attribute that is required by Builder
	// was missing.
	BuilderErrorMissingAttribute BuilderError = 2
	// BuilderErrorInvalidAttribute: builder found an attribute that it doesn’t
	// understand.
	BuilderErrorInvalidAttribute BuilderError = 3
	// BuilderErrorInvalidTag: builder found a tag that it doesn’t understand.
	BuilderErrorInvalidTag BuilderError = 4
	// BuilderErrorMissingPropertyValue: a required property value was missing.
	BuilderErrorMissingPropertyValue BuilderError = 5
	// BuilderErrorInvalidValue: builder couldn’t parse some attribute value.
	BuilderErrorInvalidValue BuilderError = 6
	// BuilderErrorVersionMismatch: the input file requires a newer version of
	// GTK.
	BuilderErrorVersionMismatch BuilderError = 7
	// BuilderErrorDuplicateID: an object id occurred twice.
	BuilderErrorDuplicateID BuilderError = 8
	// BuilderErrorObjectTypeRefused: a specified object type is of the same
	// type or derived from the type of the composite class being extended with
	// builder XML.
	BuilderErrorObjectTypeRefused BuilderError = 9
	// BuilderErrorTemplateMismatch: the wrong type was specified in a composite
	// class’s template XML
	BuilderErrorTemplateMismatch BuilderError = 10
	// BuilderErrorInvalidProperty: the specified property is unknown for the
	// object class.
	BuilderErrorInvalidProperty BuilderError = 11
	// BuilderErrorInvalidSignal: the specified signal is unknown for the object
	// class.
	BuilderErrorInvalidSignal BuilderError = 12
	// BuilderErrorInvalidID: an object id is unknown.
	BuilderErrorInvalidID BuilderError = 13
	// BuilderErrorInvalidFunction: a function could not be found. This often
	// happens when symbols are set to be kept private. Compiling code with
	// -rdynamic or using the `gmodule-export-2.0` pkgconfig module can fix this
	// problem.
	BuilderErrorInvalidFunction BuilderError = 14
)

func marshalBuilderError(p uintptr) (interface{}, error) {
	return BuilderError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ButtonsType: prebuilt sets of buttons for the dialog. If none of these
// choices are appropriate, simply use GTK_BUTTONS_NONE then call
// gtk_dialog_add_buttons().
//
// > Please note that GTK_BUTTONS_OK, GTK_BUTTONS_YES_NO > and
// GTK_BUTTONS_OK_CANCEL are discouraged by the > [GNOME Human Interface
// Guidelines](http://library.gnome.org/devel/hig-book/stable/).
type ButtonsType int

const (
	// ButtonsTypeNone: no buttons at all
	ButtonsTypeNone ButtonsType = 0
	// ButtonsTypeOk: an OK button
	ButtonsTypeOk ButtonsType = 1
	// ButtonsTypeClose: a Close button
	ButtonsTypeClose ButtonsType = 2
	// ButtonsTypeCancel: a Cancel button
	ButtonsTypeCancel ButtonsType = 3
	// ButtonsTypeYesNo: yes and No buttons
	ButtonsTypeYesNo ButtonsType = 4
	// ButtonsTypeOkCancel: OK and Cancel buttons
	ButtonsTypeOkCancel ButtonsType = 5
)

func marshalButtonsType(p uintptr) (interface{}, error) {
	return ButtonsType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// CellRendererAccelMode: determines if the edited accelerators are GTK
// accelerators. If they are, consumed modifiers are suppressed, only
// accelerators accepted by GTK are allowed, and the accelerators are rendered
// in the same way as they are in menus.
type CellRendererAccelMode int

const (
	// CellRendererAccelModeGTK: GTK accelerators mode
	CellRendererAccelModeGTK CellRendererAccelMode = 0
	// CellRendererAccelModeOther: other accelerator mode
	CellRendererAccelModeOther CellRendererAccelMode = 1
)

func marshalCellRendererAccelMode(p uintptr) (interface{}, error) {
	return CellRendererAccelMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// CellRendererMode: identifies how the user can interact with a particular
// cell.
type CellRendererMode int

const (
	// CellRendererModeInert: the cell is just for display and cannot be
	// interacted with. Note that this doesn’t mean that eg. the row being drawn
	// can’t be selected -- just that a particular element of it cannot be
	// individually modified.
	CellRendererModeInert CellRendererMode = 0
	// CellRendererModeActivatable: the cell can be clicked.
	CellRendererModeActivatable CellRendererMode = 1
	// CellRendererModeEditable: the cell can be edited or otherwise modified.
	CellRendererModeEditable CellRendererMode = 2
)

func marshalCellRendererMode(p uintptr) (interface{}, error) {
	return CellRendererMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ConstraintAttribute: the widget attributes that can be used when creating a
// Constraint.
type ConstraintAttribute int

const (
	// ConstraintAttributeNone: no attribute, used for constant relations
	ConstraintAttributeNone ConstraintAttribute = 0
	// ConstraintAttributeLeft: the left edge of a widget, regardless of text
	// direction
	ConstraintAttributeLeft ConstraintAttribute = 1
	// ConstraintAttributeRight: the right edge of a widget, regardless of text
	// direction
	ConstraintAttributeRight ConstraintAttribute = 2
	// ConstraintAttributeTop: the top edge of a widget
	ConstraintAttributeTop ConstraintAttribute = 3
	// ConstraintAttributeBottom: the bottom edge of a widget
	ConstraintAttributeBottom ConstraintAttribute = 4
	// ConstraintAttributeStart: the leading edge of a widget, depending on text
	// direction; equivalent to GTK_CONSTRAINT_ATTRIBUTE_LEFT for LTR languages,
	// and GTK_CONSTRAINT_ATTRIBUTE_RIGHT for RTL ones
	ConstraintAttributeStart ConstraintAttribute = 5
	// ConstraintAttributeEnd: the trailing edge of a widget, depending on text
	// direction; equivalent to GTK_CONSTRAINT_ATTRIBUTE_RIGHT for LTR
	// languages, and GTK_CONSTRAINT_ATTRIBUTE_LEFT for RTL ones
	ConstraintAttributeEnd ConstraintAttribute = 6
	// ConstraintAttributeWidth: the width of a widget
	ConstraintAttributeWidth ConstraintAttribute = 7
	// ConstraintAttributeHeight: the height of a widget
	ConstraintAttributeHeight ConstraintAttribute = 8
	// ConstraintAttributeCenterX: the center of a widget, on the horizontal
	// axis
	ConstraintAttributeCenterX ConstraintAttribute = 9
	// ConstraintAttributeCenterY: the center of a widget, on the vertical axis
	ConstraintAttributeCenterY ConstraintAttribute = 10
	// ConstraintAttributeBaseline: the baseline of a widget
	ConstraintAttributeBaseline ConstraintAttribute = 11
)

func marshalConstraintAttribute(p uintptr) (interface{}, error) {
	return ConstraintAttribute(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ConstraintRelation: the relation between two terms of a constraint.
type ConstraintRelation int

const (
	// ConstraintRelationLe: less than, or equal
	ConstraintRelationLe ConstraintRelation = -1
	// ConstraintRelationEq: equal
	ConstraintRelationEq ConstraintRelation = 0
	// ConstraintRelationGe: greater than, or equal
	ConstraintRelationGe ConstraintRelation = 1
)

func marshalConstraintRelation(p uintptr) (interface{}, error) {
	return ConstraintRelation(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ConstraintStrength: the strength of a constraint, expressed as a symbolic
// constant.
//
// The strength of a Constraint can be expressed with any positive integer; the
// values of this enumeration can be used for readability.
type ConstraintStrength int

const (
	// ConstraintStrengthRequired: the constraint is required towards solving
	// the layout
	ConstraintStrengthRequired ConstraintStrength = 1001001000
	// ConstraintStrengthStrong: a strong constraint
	ConstraintStrengthStrong ConstraintStrength = 1000000000
	// ConstraintStrengthMedium: a medium constraint
	ConstraintStrengthMedium ConstraintStrength = 1000
	// ConstraintStrengthWeak: a weak constraint
	ConstraintStrengthWeak ConstraintStrength = 1
)

func marshalConstraintStrength(p uintptr) (interface{}, error) {
	return ConstraintStrength(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ConstraintVflParserError: domain for VFL parsing errors.
type ConstraintVflParserError int

const (
	// ConstraintVflParserErrorSymbol: invalid or unknown symbol
	ConstraintVflParserErrorSymbol ConstraintVflParserError = 0
	// ConstraintVflParserErrorAttribute: invalid or unknown attribute
	ConstraintVflParserErrorAttribute ConstraintVflParserError = 1
	// ConstraintVflParserErrorView: invalid or unknown view
	ConstraintVflParserErrorView ConstraintVflParserError = 2
	// ConstraintVflParserErrorMetric: invalid or unknown metric
	ConstraintVflParserErrorMetric ConstraintVflParserError = 3
	// ConstraintVflParserErrorPriority: invalid or unknown priority
	ConstraintVflParserErrorPriority ConstraintVflParserError = 4
	// ConstraintVflParserErrorRelation: invalid or unknown relation
	ConstraintVflParserErrorRelation ConstraintVflParserError = 5
)

func marshalConstraintVflParserError(p uintptr) (interface{}, error) {
	return ConstraintVflParserError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// CornerType: specifies which corner a child widget should be placed in when
// packed into a ScrolledWindow. This is effectively the opposite of where the
// scroll bars are placed.
type CornerType int

const (
	// CornerTypeTopLeft: place the scrollbars on the right and bottom of the
	// widget (default behaviour).
	CornerTypeTopLeft CornerType = 0
	// CornerTypeBottomLeft: place the scrollbars on the top and right of the
	// widget.
	CornerTypeBottomLeft CornerType = 1
	// CornerTypeTopRight: place the scrollbars on the left and bottom of the
	// widget.
	CornerTypeTopRight CornerType = 2
	// CornerTypeBottomRight: place the scrollbars on the top and left of the
	// widget.
	CornerTypeBottomRight CornerType = 3
)

func marshalCornerType(p uintptr) (interface{}, error) {
	return CornerType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// CSSParserError: errors that can occur while parsing CSS.
//
// These errors are unexpected and will cause parts of the given CSS to be
// ignored.
type CSSParserError int

const (
	// CSSParserErrorFailed: unknown failure.
	CSSParserErrorFailed CSSParserError = 0
	// CSSParserErrorSyntax: the given text does not form valid syntax
	CSSParserErrorSyntax CSSParserError = 1
	// CSSParserErrorImport: failed to import a resource
	CSSParserErrorImport CSSParserError = 2
	// CSSParserErrorName: the given name has not been defined
	CSSParserErrorName CSSParserError = 3
	// CSSParserErrorUnknownValue: the given value is not correct
	CSSParserErrorUnknownValue CSSParserError = 4
)

// CSSParserWarning: warnings that can occur while parsing CSS.
//
// Unlike CssParserErrors, warnings do not cause the parser to skip any input,
// but they indicate issues that should be fixed.
type CSSParserWarning int

const (
	// CSSParserWarningDeprecated: the given construct is deprecated and will be
	// removed in a future version
	CSSParserWarningDeprecated CSSParserWarning = 0
	// CSSParserWarningSyntax: a syntax construct was used that should be
	// avoided
	CSSParserWarningSyntax CSSParserWarning = 1
	// CSSParserWarningUnimplemented: a feature is not implemented
	CSSParserWarningUnimplemented CSSParserWarning = 2
)

// DeleteType: see also: Entry::delete-from-cursor.
type DeleteType int

const (
	// DeleteTypeChars: delete characters.
	DeleteTypeChars DeleteType = 0
	// DeleteTypeWordEnds: delete only the portion of the word to the left/right
	// of cursor if we’re in the middle of a word.
	DeleteTypeWordEnds DeleteType = 1
	// DeleteTypeWords: delete words.
	DeleteTypeWords DeleteType = 2
	// DeleteTypeDisplayLines: delete display-lines. Display-lines refers to the
	// visible lines, with respect to the current line breaks. As opposed to
	// paragraphs, which are defined by line breaks in the input.
	DeleteTypeDisplayLines DeleteType = 3
	// DeleteTypeDisplayLineEnds: delete only the portion of the display-line to
	// the left/right of cursor.
	DeleteTypeDisplayLineEnds DeleteType = 4
	// DeleteTypeParagraphEnds: delete to the end of the paragraph. Like C-k in
	// Emacs (or its reverse).
	DeleteTypeParagraphEnds DeleteType = 5
	// DeleteTypeParagraphs: delete entire line. Like C-k in pico.
	DeleteTypeParagraphs DeleteType = 6
	// DeleteTypeWhitespace: delete only whitespace. Like M-\ in Emacs.
	DeleteTypeWhitespace DeleteType = 7
)

func marshalDeleteType(p uintptr) (interface{}, error) {
	return DeleteType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DirectionType: focus movement types.
type DirectionType int

const (
	// DirectionTypeTabForward: move forward.
	DirectionTypeTabForward DirectionType = 0
	// DirectionTypeTabBackward: move backward.
	DirectionTypeTabBackward DirectionType = 1
	// DirectionTypeUp: move up.
	DirectionTypeUp DirectionType = 2
	// DirectionTypeDown: move down.
	DirectionTypeDown DirectionType = 3
	// DirectionTypeLeft: move left.
	DirectionTypeLeft DirectionType = 4
	// DirectionTypeRight: move right.
	DirectionTypeRight DirectionType = 5
)

func marshalDirectionType(p uintptr) (interface{}, error) {
	return DirectionType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

type EditableProperties int

const (
	EditablePropertiesPropText EditableProperties = 0

	EditablePropertiesPropCursorPosition EditableProperties = 1

	EditablePropertiesPropSelectionBound EditableProperties = 2

	EditablePropertiesPropEditable EditableProperties = 3

	EditablePropertiesPropWidthChars EditableProperties = 4

	EditablePropertiesPropMaxWidthChars EditableProperties = 5

	EditablePropertiesPropXalign EditableProperties = 6

	EditablePropertiesPropEnableUndo EditableProperties = 7

	EditablePropertiesNumProperties EditableProperties = 8
)

func marshalEditableProperties(p uintptr) (interface{}, error) {
	return EditableProperties(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// EntryIconPosition: specifies the side of the entry at which an icon is
// placed.
type EntryIconPosition int

const (
	// EntryIconPositionPrimary: at the beginning of the entry (depending on the
	// text direction).
	EntryIconPositionPrimary EntryIconPosition = 0
	// EntryIconPositionSecondary: at the end of the entry (depending on the
	// text direction).
	EntryIconPositionSecondary EntryIconPosition = 1
)

func marshalEntryIconPosition(p uintptr) (interface{}, error) {
	return EntryIconPosition(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// EventSequenceState: describes the state of a EventSequence in a Gesture.
type EventSequenceState int

const (
	// EventSequenceStateNone: the sequence is handled, but not grabbed.
	EventSequenceStateNone EventSequenceState = 0
	// EventSequenceStateClaimed: the sequence is handled and grabbed.
	EventSequenceStateClaimed EventSequenceState = 1
	// EventSequenceStateDenied: the sequence is denied.
	EventSequenceStateDenied EventSequenceState = 2
)

func marshalEventSequenceState(p uintptr) (interface{}, error) {
	return EventSequenceState(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FileChooserAction: describes whether a FileChooser is being used to open
// existing files or to save to a possibly new file.
type FileChooserAction int

const (
	// FileChooserActionOpen: indicates open mode. The file chooser will only
	// let the user pick an existing file.
	FileChooserActionOpen FileChooserAction = 0
	// FileChooserActionSave: indicates save mode. The file chooser will let the
	// user pick an existing file, or type in a new filename.
	FileChooserActionSave FileChooserAction = 1
	// FileChooserActionSelectFolder: indicates an Open mode for selecting
	// folders. The file chooser will let the user pick an existing folder.
	FileChooserActionSelectFolder FileChooserAction = 2
)

func marshalFileChooserAction(p uintptr) (interface{}, error) {
	return FileChooserAction(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FileChooserError: these identify the various errors that can occur while
// calling FileChooser functions.
type FileChooserError int

const (
	// FileChooserErrorNonexistent: indicates that a file does not exist.
	FileChooserErrorNonexistent FileChooserError = 0
	// FileChooserErrorBadFilename: indicates a malformed filename.
	FileChooserErrorBadFilename FileChooserError = 1
	// FileChooserErrorAlreadyExists: indicates a duplicate path (e.g. when
	// adding a bookmark).
	FileChooserErrorAlreadyExists FileChooserError = 2
	// FileChooserErrorIncompleteHostname: indicates an incomplete hostname
	// (e.g. "http://foo" without a slash after that).
	FileChooserErrorIncompleteHostname FileChooserError = 3
)

func marshalFileChooserError(p uintptr) (interface{}, error) {
	return FileChooserError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FilterChange: describes changes in a filter in more detail and allows objects
// using the filter to optimize refiltering items.
//
// If you are writing an implementation and are not sure which value to pass,
// GTK_FILTER_CHANGE_DIFFERENT is always a correct choice.
type FilterChange int

const (
	// FilterChangeDifferent: the filter change cannot be described with any of
	// the other enumeration values.
	FilterChangeDifferent FilterChange = 0
	// FilterChangeLessStrict: the filter is less strict than it was before: All
	// items that it used to return true for still return true, others now may,
	// too.
	FilterChangeLessStrict FilterChange = 1
	// FilterChangeMoreStrict: the filter is more strict than it was before: All
	// items that it used to return false for still return false, others now
	// may, too.
	FilterChangeMoreStrict FilterChange = 2
)

func marshalFilterChange(p uintptr) (interface{}, error) {
	return FilterChange(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FilterMatch: describes the known strictness of a filter.
//
// Note that for filters where the strictness is not known,
// GTK_FILTER_MATCH_SOME is always an acceptable value, even if a filter does
// match all or no items.
type FilterMatch int

const (
	// FilterMatchSome: the filter matches some items, gtk_filter_match() may
	// return true or false
	FilterMatchSome FilterMatch = 0
	// FilterMatchNone: the filter does not match any item, gtk_filter_match()
	// will always return false.
	FilterMatchNone FilterMatch = 1
	// FilterMatchAll: the filter matches all items, gtk_filter_match() will
	// alays return true.
	FilterMatchAll FilterMatch = 2
)

func marshalFilterMatch(p uintptr) (interface{}, error) {
	return FilterMatch(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// IconSize: built-in icon sizes.
//
// Icon sizes default to being inherited. Where they cannot be inherited, text
// size is the default.
//
// All widgets which use GtkIconSize set the normal-icons or large-icons style
// classes correspondingly, and let themes determine the actual size to be used
// with the -gtk-icon-size CSS property.
type IconSize int

const (
	// IconSizeInherit: keep the size of the parent element
	IconSizeInherit IconSize = 0
	// IconSizeNormal: size similar to text size
	IconSizeNormal IconSize = 1
	// IconSizeLarge: large size, for example in an icon view
	IconSizeLarge IconSize = 2
)

func marshalIconSize(p uintptr) (interface{}, error) {
	return IconSize(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// IconThemeError: error codes for GtkIconTheme operations.
type IconThemeError int

const (
	// IconThemeErrorNotFound: the icon specified does not exist in the theme
	IconThemeErrorNotFound IconThemeError = 0
	// IconThemeErrorFailed: an unspecified error occurred.
	IconThemeErrorFailed IconThemeError = 1
)

func marshalIconThemeError(p uintptr) (interface{}, error) {
	return IconThemeError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// IconViewDropPosition: an enum for determining where a dropped item goes.
type IconViewDropPosition int

const (
	// IconViewDropPositionNoDrop: no drop possible
	IconViewDropPositionNoDrop IconViewDropPosition = 0
	// IconViewDropPositionDropInto: dropped item replaces the item
	IconViewDropPositionDropInto IconViewDropPosition = 1
	// IconViewDropPositionDropLeft: dropped item is inserted to the left
	IconViewDropPositionDropLeft IconViewDropPosition = 2
	// IconViewDropPositionDropRight: dropped item is inserted to the right
	IconViewDropPositionDropRight IconViewDropPosition = 3
	// IconViewDropPositionDropAbove: dropped item is inserted above
	IconViewDropPositionDropAbove IconViewDropPosition = 4
	// IconViewDropPositionDropBelow: dropped item is inserted below
	IconViewDropPositionDropBelow IconViewDropPosition = 5
)

func marshalIconViewDropPosition(p uintptr) (interface{}, error) {
	return IconViewDropPosition(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ImageType: describes the image data representation used by a Image. If you
// want to get the image from the widget, you can only get the currently-stored
// representation. e.g. if the gtk_image_get_storage_type() returns
// K_IMAGE_PAINTABLE, then you can call gtk_image_get_paintable(). For empty
// images, you can request any storage type (call any of the "get" functions),
// but they will all return nil values.
type ImageType int

const (
	// ImageTypeEmpty: there is no image displayed by the widget
	ImageTypeEmpty ImageType = 0
	// ImageTypeIconName: the widget contains a named icon
	ImageTypeIconName ImageType = 1
	// ImageTypeGicon: the widget contains a #GIcon
	ImageTypeGicon ImageType = 2
	// ImageTypePaintable: the widget contains a Paintable
	ImageTypePaintable ImageType = 3
)

func marshalImageType(p uintptr) (interface{}, error) {
	return ImageType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// InputPurpose: describes primary purpose of the input widget. This information
// is useful for on-screen keyboards and similar input methods to decide which
// keys should be presented to the user.
//
// Note that the purpose is not meant to impose a totally strict rule about
// allowed characters, and does not replace input validation. It is fine for an
// on-screen keyboard to let the user override the character set restriction
// that is expressed by the purpose. The application is expected to validate the
// entry contents, even if it specified a purpose.
//
// The difference between GTK_INPUT_PURPOSE_DIGITS and GTK_INPUT_PURPOSE_NUMBER
// is that the former accepts only digits while the latter also some punctuation
// (like commas or points, plus, minus) and “e” or “E” as in 3.14E+000.
//
// This enumeration may be extended in the future; input methods should
// interpret unknown values as “free form”.
type InputPurpose int

const (
	// InputPurposeFreeForm: allow any character
	InputPurposeFreeForm InputPurpose = 0
	// InputPurposeAlpha: allow only alphabetic characters
	InputPurposeAlpha InputPurpose = 1
	// InputPurposeDigits: allow only digits
	InputPurposeDigits InputPurpose = 2
	// InputPurposeNumber: edited field expects numbers
	InputPurposeNumber InputPurpose = 3
	// InputPurposePhone: edited field expects phone number
	InputPurposePhone InputPurpose = 4
	// InputPurposeURL: edited field expects URL
	InputPurposeURL InputPurpose = 5
	// InputPurposeEmail: edited field expects email address
	InputPurposeEmail InputPurpose = 6
	// InputPurposeName: edited field expects the name of a person
	InputPurposeName InputPurpose = 7
	// InputPurposePassword: like GTK_INPUT_PURPOSE_FREE_FORM, but characters
	// are hidden
	InputPurposePassword InputPurpose = 8
	// InputPurposePin: like GTK_INPUT_PURPOSE_DIGITS, but characters are hidden
	InputPurposePin InputPurpose = 9
	// InputPurposeTerminal: allow any character, in addition to control codes
	InputPurposeTerminal InputPurpose = 10
)

func marshalInputPurpose(p uintptr) (interface{}, error) {
	return InputPurpose(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// Justification: used for justifying the text inside a Label widget.
type Justification int

const (
	// JustificationLeft: the text is placed at the left edge of the label.
	JustificationLeft Justification = 0
	// JustificationRight: the text is placed at the right edge of the label.
	JustificationRight Justification = 1
	// JustificationCenter: the text is placed in the center of the label.
	JustificationCenter Justification = 2
	// JustificationFill: the text is placed is distributed across the label.
	JustificationFill Justification = 3
)

func marshalJustification(p uintptr) (interface{}, error) {
	return Justification(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// LevelBarMode: describes how LevelBar contents should be rendered. Note that
// this enumeration could be extended with additional modes in the future.
type LevelBarMode int

const (
	// LevelBarModeContinuous: the bar has a continuous mode
	LevelBarModeContinuous LevelBarMode = 0
	// LevelBarModeDiscrete: the bar has a discrete mode
	LevelBarModeDiscrete LevelBarMode = 1
)

func marshalLevelBarMode(p uintptr) (interface{}, error) {
	return LevelBarMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// License: the type of license for an application.
//
// This enumeration can be expanded at later date.
type License int

const (
	// LicenseUnknown: no license specified
	LicenseUnknown License = 0
	// LicenseCustom: a license text is going to be specified by the developer
	LicenseCustom License = 1
	// LicenseGpl20: the GNU General Public License, version 2.0 or later
	LicenseGpl20 License = 2
	// LicenseGpl30: the GNU General Public License, version 3.0 or later
	LicenseGpl30 License = 3
	// LicenseLgpl21: the GNU Lesser General Public License, version 2.1 or
	// later
	LicenseLgpl21 License = 4
	// LicenseLgpl30: the GNU Lesser General Public License, version 3.0 or
	// later
	LicenseLgpl30 License = 5
	// LicenseBsd: the BSD standard license
	LicenseBsd License = 6
	// LicenseMitX11: the MIT/X11 standard license
	LicenseMitX11 License = 7
	// LicenseArtistic: the Artistic License, version 2.0
	LicenseArtistic License = 8
	// LicenseGpl20Only: the GNU General Public License, version 2.0 only
	LicenseGpl20Only License = 9
	// LicenseGpl30Only: the GNU General Public License, version 3.0 only
	LicenseGpl30Only License = 10
	// LicenseLgpl21Only: the GNU Lesser General Public License, version 2.1
	// only
	LicenseLgpl21Only License = 11
	// LicenseLgpl30Only: the GNU Lesser General Public License, version 3.0
	// only
	LicenseLgpl30Only License = 12
	// LicenseAgpl30: the GNU Affero General Public License, version 3.0 or
	// later
	LicenseAgpl30 License = 13
	// LicenseAgpl30Only: the GNU Affero General Public License, version 3.0
	// only
	LicenseAgpl30Only License = 14
	// LicenseBsd3: the 3-clause BSD licence
	LicenseBsd3 License = 15
	// LicenseApache20: the Apache License, version 2.0
	LicenseApache20 License = 16
	// LicenseMpl20: the Mozilla Public License, version 2.0
	LicenseMpl20 License = 17
)

func marshalLicense(p uintptr) (interface{}, error) {
	return License(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// MessageType: the type of message being displayed in the dialog.
type MessageType int

const (
	// MessageTypeInfo: informational message
	MessageTypeInfo MessageType = 0
	// MessageTypeWarning: non-fatal warning message
	MessageTypeWarning MessageType = 1
	// MessageTypeQuestion: question requiring a choice
	MessageTypeQuestion MessageType = 2
	// MessageTypeError: fatal error message
	MessageTypeError MessageType = 3
	// MessageTypeOther: none of the above
	MessageTypeOther MessageType = 4
)

func marshalMessageType(p uintptr) (interface{}, error) {
	return MessageType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

type MovementStep int

const (
	// MovementStepLogicalPositions: move forward or back by graphemes
	MovementStepLogicalPositions MovementStep = 0
	// MovementStepVisualPositions: move left or right by graphemes
	MovementStepVisualPositions MovementStep = 1
	// MovementStepWords: move forward or back by words
	MovementStepWords MovementStep = 2
	// MovementStepDisplayLines: move up or down lines (wrapped lines)
	MovementStepDisplayLines MovementStep = 3
	// MovementStepDisplayLineEnds: move to either end of a line
	MovementStepDisplayLineEnds MovementStep = 4
	// MovementStepParagraphs: move up or down paragraphs (newline-ended lines)
	MovementStepParagraphs MovementStep = 5
	// MovementStepParagraphEnds: move to either end of a paragraph
	MovementStepParagraphEnds MovementStep = 6
	// MovementStepPages: move by pages
	MovementStepPages MovementStep = 7
	// MovementStepBufferEnds: move to ends of the buffer
	MovementStepBufferEnds MovementStep = 8
	// MovementStepHorizontalPages: move horizontally by pages
	MovementStepHorizontalPages MovementStep = 9
)

func marshalMovementStep(p uintptr) (interface{}, error) {
	return MovementStep(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// NotebookTab: the parameter used in the action signals of Notebook.
type NotebookTab int

const (
	// NotebookTabFirst: the first tab in the notebook
	NotebookTabFirst NotebookTab = 0
	// NotebookTabLast: the last tab in the notebook
	NotebookTabLast NotebookTab = 1
)

func marshalNotebookTab(p uintptr) (interface{}, error) {
	return NotebookTab(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// NumberUpLayout: used to determine the layout of pages on a sheet when
// printing multiple pages per sheet.
type NumberUpLayout int

const (
	// NumberUpLayoutLrtb: ![](layout-lrtb.png)
	NumberUpLayoutLrtb NumberUpLayout = 0
	// NumberUpLayoutLrbt: ![](layout-lrbt.png)
	NumberUpLayoutLrbt NumberUpLayout = 1
	// NumberUpLayoutRltb: ![](layout-rltb.png)
	NumberUpLayoutRltb NumberUpLayout = 2
	// NumberUpLayoutRlbt: ![](layout-rlbt.png)
	NumberUpLayoutRlbt NumberUpLayout = 3
	// NumberUpLayoutTblr: ![](layout-tblr.png)
	NumberUpLayoutTblr NumberUpLayout = 4
	// NumberUpLayoutTbrl: ![](layout-tbrl.png)
	NumberUpLayoutTbrl NumberUpLayout = 5
	// NumberUpLayoutBtlr: ![](layout-btlr.png)
	NumberUpLayoutBtlr NumberUpLayout = 6
	// NumberUpLayoutBtrl: ![](layout-btrl.png)
	NumberUpLayoutBtrl NumberUpLayout = 7
)

func marshalNumberUpLayout(p uintptr) (interface{}, error) {
	return NumberUpLayout(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// Ordering: describes the way two values can be compared.
//
// These values can be used with a Func. However, a Func is allowed to return
// any integer values. For converting such a value to a Ordering, use
// gtk_ordering_from_cmpfunc().
type Ordering int

const (
	// OrderingSmaller: the first value is smaller than the second
	OrderingSmaller Ordering = -1
	// OrderingEqual: the two values are equal
	OrderingEqual Ordering = 0
	// OrderingLarger: the first value is larger than the second
	OrderingLarger Ordering = 1
)

func marshalOrdering(p uintptr) (interface{}, error) {
	return Ordering(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// Orientation: represents the orientation of widgets and other objects which
// can be switched between horizontal and vertical orientation on the fly, like
// Box or GesturePan.
type Orientation int

const (
	// OrientationHorizontal: the element is in horizontal orientation.
	OrientationHorizontal Orientation = 0
	// OrientationVertical: the element is in vertical orientation.
	OrientationVertical Orientation = 1
)

func marshalOrientation(p uintptr) (interface{}, error) {
	return Orientation(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// Overflow: defines how content overflowing a given area should be handled,
// such as with gtk_widget_set_overflow(). This property is modeled after the
// CSS overflow property, but implements it only partially.
type Overflow int

const (
	// OverflowVisible: no change is applied. Content is drawn at the specified
	// position.
	OverflowVisible Overflow = 0
	// OverflowHidden: content is clipped to the bounds of the area. Content
	// outside the area is not drawn and cannot be interacted with.
	OverflowHidden Overflow = 1
)

func marshalOverflow(p uintptr) (interface{}, error) {
	return Overflow(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PackType: represents the packing location of a children in its parent. See
// WindowControls for example.
type PackType int

const (
	// PackTypeStart: the child is packed into the start of the widget
	PackTypeStart PackType = 0
	// PackTypeEnd: the child is packed into the end of the widget
	PackTypeEnd PackType = 1
)

func marshalPackType(p uintptr) (interface{}, error) {
	return PackType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PadActionType: the type of a pad action.
type PadActionType int

const (
	// PadActionTypeButton: action is triggered by a pad button
	PadActionTypeButton PadActionType = 0
	// PadActionTypeRing: action is triggered by a pad ring
	PadActionTypeRing PadActionType = 1
	// PadActionTypeStrip: action is triggered by a pad strip
	PadActionTypeStrip PadActionType = 2
)

func marshalPadActionType(p uintptr) (interface{}, error) {
	return PadActionType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PageOrientation: see also gtk_print_settings_set_orientation().
type PageOrientation int

const (
	// PageOrientationPortrait: portrait mode.
	PageOrientationPortrait PageOrientation = 0
	// PageOrientationLandscape: landscape mode.
	PageOrientationLandscape PageOrientation = 1
	// PageOrientationReversePortrait: reverse portrait mode.
	PageOrientationReversePortrait PageOrientation = 2
	// PageOrientationReverseLandscape: reverse landscape mode.
	PageOrientationReverseLandscape PageOrientation = 3
)

func marshalPageOrientation(p uintptr) (interface{}, error) {
	return PageOrientation(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PageSet: see also gtk_print_job_set_page_set().
type PageSet int

const (
	// PageSetAll: all pages.
	PageSetAll PageSet = 0
	// PageSetEven: even pages.
	PageSetEven PageSet = 1
	// PageSetOdd: odd pages.
	PageSetOdd PageSet = 2
)

func marshalPageSet(p uintptr) (interface{}, error) {
	return PageSet(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PanDirection: describes the panning direction of a GesturePan
type PanDirection int

const (
	// PanDirectionLeft: panned towards the left
	PanDirectionLeft PanDirection = 0
	// PanDirectionRight: panned towards the right
	PanDirectionRight PanDirection = 1
	// PanDirectionUp: panned upwards
	PanDirectionUp PanDirection = 2
	// PanDirectionDown: panned downwards
	PanDirectionDown PanDirection = 3
)

func marshalPanDirection(p uintptr) (interface{}, error) {
	return PanDirection(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PolicyType: determines how the size should be computed to achieve the one of
// the visibility mode for the scrollbars.
type PolicyType int

const (
	// PolicyTypeAlways: the scrollbar is always visible. The view size is
	// independent of the content.
	PolicyTypeAlways PolicyType = 0
	// PolicyTypeAutomatic: the scrollbar will appear and disappear as
	// necessary. For example, when all of a TreeView can not be seen.
	PolicyTypeAutomatic PolicyType = 1
	// PolicyTypeNever: the scrollbar should never appear. In this mode the
	// content determines the size.
	PolicyTypeNever PolicyType = 2
	// PolicyTypeExternal: don't show a scrollbar, but don't force the size to
	// follow the content. This can be used e.g. to make multiple scrolled
	// windows share a scrollbar.
	PolicyTypeExternal PolicyType = 3
)

func marshalPolicyType(p uintptr) (interface{}, error) {
	return PolicyType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PositionType: describes which edge of a widget a certain feature is
// positioned at, e.g. the tabs of a Notebook, or the label of a Scale.
type PositionType int

const (
	// PositionTypeLeft: the feature is at the left edge.
	PositionTypeLeft PositionType = 0
	// PositionTypeRight: the feature is at the right edge.
	PositionTypeRight PositionType = 1
	// PositionTypeTop: the feature is at the top edge.
	PositionTypeTop PositionType = 2
	// PositionTypeBottom: the feature is at the bottom edge.
	PositionTypeBottom PositionType = 3
)

func marshalPositionType(p uintptr) (interface{}, error) {
	return PositionType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PrintDuplex: see also gtk_print_settings_set_duplex().
type PrintDuplex int

const (
	// PrintDuplexSimplex: no duplex.
	PrintDuplexSimplex PrintDuplex = 0
	// PrintDuplexHorizontal: horizontal duplex.
	PrintDuplexHorizontal PrintDuplex = 1
	// PrintDuplexVertical: vertical duplex.
	PrintDuplexVertical PrintDuplex = 2
)

func marshalPrintDuplex(p uintptr) (interface{}, error) {
	return PrintDuplex(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PrintError: error codes that identify various errors that can occur while
// using the GTK printing support.
type PrintError int

const (
	// PrintErrorGeneral: an unspecified error occurred.
	PrintErrorGeneral PrintError = 0
	// PrintErrorInternalError: an internal error occurred.
	PrintErrorInternalError PrintError = 1
	// PrintErrorNomem: a memory allocation failed.
	PrintErrorNomem PrintError = 2
	// PrintErrorInvalidFile: an error occurred while loading a page setup or
	// paper size from a key file.
	PrintErrorInvalidFile PrintError = 3
)

func marshalPrintError(p uintptr) (interface{}, error) {
	return PrintError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PrintOperationAction: the @action parameter to gtk_print_operation_run()
// determines what action the print operation should perform.
type PrintOperationAction int

const (
	// PrintOperationActionPrintDialog: show the print dialog.
	PrintOperationActionPrintDialog PrintOperationAction = 0
	// PrintOperationActionPrint: start to print without showing the print
	// dialog, based on the current print settings.
	PrintOperationActionPrint PrintOperationAction = 1
	// PrintOperationActionPreview: show the print preview.
	PrintOperationActionPreview PrintOperationAction = 2
	// PrintOperationActionExport: export to a file. This requires the
	// export-filename property to be set.
	PrintOperationActionExport PrintOperationAction = 3
)

func marshalPrintOperationAction(p uintptr) (interface{}, error) {
	return PrintOperationAction(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PrintOperationResult: a value of this type is returned by
// gtk_print_operation_run().
type PrintOperationResult int

const (
	// PrintOperationResultError: an error has occurred.
	PrintOperationResultError PrintOperationResult = 0
	// PrintOperationResultApply: the print settings should be stored.
	PrintOperationResultApply PrintOperationResult = 1
	// PrintOperationResultCancel: the print operation has been canceled, the
	// print settings should not be stored.
	PrintOperationResultCancel PrintOperationResult = 2
	// PrintOperationResultInProgress: the print operation is not complete yet.
	// This value will only be returned when running asynchronously.
	PrintOperationResultInProgress PrintOperationResult = 3
)

func marshalPrintOperationResult(p uintptr) (interface{}, error) {
	return PrintOperationResult(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PrintPages: see also gtk_print_job_set_pages()
type PrintPages int

const (
	// PrintPagesAll: all pages.
	PrintPagesAll PrintPages = 0
	// PrintPagesCurrent: current page.
	PrintPagesCurrent PrintPages = 1
	// PrintPagesRanges: range of pages.
	PrintPagesRanges PrintPages = 2
	// PrintPagesSelection: selected pages.
	PrintPagesSelection PrintPages = 3
)

func marshalPrintPages(p uintptr) (interface{}, error) {
	return PrintPages(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PrintQuality: see also gtk_print_settings_set_quality().
type PrintQuality int

const (
	// PrintQualityLow: low quality.
	PrintQualityLow PrintQuality = 0
	// PrintQualityNormal: normal quality.
	PrintQualityNormal PrintQuality = 1
	// PrintQualityHigh: high quality.
	PrintQualityHigh PrintQuality = 2
	// PrintQualityDraft: draft quality.
	PrintQualityDraft PrintQuality = 3
)

func marshalPrintQuality(p uintptr) (interface{}, error) {
	return PrintQuality(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PrintStatus: the status gives a rough indication of the completion of a
// running print operation.
type PrintStatus int

const (
	// PrintStatusInitial: the printing has not started yet; this status is set
	// initially, and while the print dialog is shown.
	PrintStatusInitial PrintStatus = 0
	// PrintStatusPreparing: this status is set while the begin-print signal is
	// emitted and during pagination.
	PrintStatusPreparing PrintStatus = 1
	// PrintStatusGeneratingData: this status is set while the pages are being
	// rendered.
	PrintStatusGeneratingData PrintStatus = 2
	// PrintStatusSendingData: the print job is being sent off to the printer.
	PrintStatusSendingData PrintStatus = 3
	// PrintStatusPending: the print job has been sent to the printer, but is
	// not printed for some reason, e.g. the printer may be stopped.
	PrintStatusPending PrintStatus = 4
	// PrintStatusPendingIssue: some problem has occurred during printing, e.g.
	// a paper jam.
	PrintStatusPendingIssue PrintStatus = 5
	// PrintStatusPrinting: the printer is processing the print job.
	PrintStatusPrinting PrintStatus = 6
	// PrintStatusFinished: the printing has been completed successfully.
	PrintStatusFinished PrintStatus = 7
	// PrintStatusFinishedAborted: the printing has been aborted.
	PrintStatusFinishedAborted PrintStatus = 8
)

func marshalPrintStatus(p uintptr) (interface{}, error) {
	return PrintStatus(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PropagationLimit: describes limits of a EventController for handling events
// targeting other widgets.
type PropagationLimit int

const (
	// PropagationLimitNone: events are handled regardless of what their target
	// is.
	PropagationLimitNone PropagationLimit = 0
	// PropagationLimitSameNative: events are only handled if their target is in
	// the same Native as the event controllers widget. Note that some event
	// types have two targets (origin and destination).
	PropagationLimitSameNative PropagationLimit = 1
)

func marshalPropagationLimit(p uintptr) (interface{}, error) {
	return PropagationLimit(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PropagationPhase: describes the stage at which events are fed into a
// EventController.
type PropagationPhase int

const (
	// PropagationPhaseNone: events are not delivered.
	PropagationPhaseNone PropagationPhase = 0
	// PropagationPhaseCapture: events are delivered in the capture phase. The
	// capture phase happens before the bubble phase, runs from the toplevel
	// down to the event widget. This option should only be used on containers
	// that might possibly handle events before their children do.
	PropagationPhaseCapture PropagationPhase = 1
	// PropagationPhaseBubble: events are delivered in the bubble phase. The
	// bubble phase happens after the capture phase, and before the default
	// handlers are run. This phase runs from the event widget, up to the
	// toplevel.
	PropagationPhaseBubble PropagationPhase = 2
	// PropagationPhaseTarget: events are delivered in the default widget event
	// handlers, note that widget implementations must chain up on button,
	// motion, touch and grab broken handlers for controllers in this phase to
	// be run.
	PropagationPhaseTarget PropagationPhase = 3
)

func marshalPropagationPhase(p uintptr) (interface{}, error) {
	return PropagationPhase(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// RecentManagerError: error codes for RecentManager operations
type RecentManagerError int

const (
	// RecentManagerErrorNotFound: the URI specified does not exists in the
	// recently used resources list.
	RecentManagerErrorNotFound RecentManagerError = 0
	// RecentManagerErrorInvalidURI: the URI specified is not valid.
	RecentManagerErrorInvalidURI RecentManagerError = 1
	// RecentManagerErrorInvalidEncoding: the supplied string is not UTF-8
	// encoded.
	RecentManagerErrorInvalidEncoding RecentManagerError = 2
	// RecentManagerErrorNotRegistered: no application has registered the
	// specified item.
	RecentManagerErrorNotRegistered RecentManagerError = 3
	// RecentManagerErrorRead: failure while reading the recently used resources
	// file.
	RecentManagerErrorRead RecentManagerError = 4
	// RecentManagerErrorWrite: failure while writing the recently used
	// resources file.
	RecentManagerErrorWrite RecentManagerError = 5
	// RecentManagerErrorUnknown: unspecified error.
	RecentManagerErrorUnknown RecentManagerError = 6
)

func marshalRecentManagerError(p uintptr) (interface{}, error) {
	return RecentManagerError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ResponseType: predefined values for use as response ids in
// gtk_dialog_add_button(). All predefined values are negative; GTK leaves
// values of 0 or greater for application-defined response ids.
type ResponseType int

const (
	// ResponseTypeNone: returned if an action widget has no response id, or if
	// the dialog gets programmatically hidden or destroyed
	ResponseTypeNone ResponseType = -1
	// ResponseTypeReject: generic response id, not used by GTK dialogs
	ResponseTypeReject ResponseType = -2
	// ResponseTypeAccept: generic response id, not used by GTK dialogs
	ResponseTypeAccept ResponseType = -3
	// ResponseTypeDeleteEvent: returned if the dialog is deleted
	ResponseTypeDeleteEvent ResponseType = -4
	// ResponseTypeOk: returned by OK buttons in GTK dialogs
	ResponseTypeOk ResponseType = -5
	// ResponseTypeCancel: returned by Cancel buttons in GTK dialogs
	ResponseTypeCancel ResponseType = -6
	// ResponseTypeClose: returned by Close buttons in GTK dialogs
	ResponseTypeClose ResponseType = -7
	// ResponseTypeYes: returned by Yes buttons in GTK dialogs
	ResponseTypeYes ResponseType = -8
	// ResponseTypeNo: returned by No buttons in GTK dialogs
	ResponseTypeNo ResponseType = -9
	// ResponseTypeApply: returned by Apply buttons in GTK dialogs
	ResponseTypeApply ResponseType = -10
	// ResponseTypeHelp: returned by Help buttons in GTK dialogs
	ResponseTypeHelp ResponseType = -11
)

func marshalResponseType(p uintptr) (interface{}, error) {
	return ResponseType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// RevealerTransitionType: these enumeration values describe the possible
// transitions when the child of a Revealer widget is shown or hidden.
type RevealerTransitionType int

const (
	// RevealerTransitionTypeNone: no transition
	RevealerTransitionTypeNone RevealerTransitionType = 0
	// RevealerTransitionTypeCrossfade: fade in
	RevealerTransitionTypeCrossfade RevealerTransitionType = 1
	// RevealerTransitionTypeSlideRight: slide in from the left
	RevealerTransitionTypeSlideRight RevealerTransitionType = 2
	// RevealerTransitionTypeSlideLeft: slide in from the right
	RevealerTransitionTypeSlideLeft RevealerTransitionType = 3
	// RevealerTransitionTypeSlideUp: slide in from the bottom
	RevealerTransitionTypeSlideUp RevealerTransitionType = 4
	// RevealerTransitionTypeSlideDown: slide in from the top
	RevealerTransitionTypeSlideDown RevealerTransitionType = 5
	// RevealerTransitionTypeSwingRight: floop in from the left
	RevealerTransitionTypeSwingRight RevealerTransitionType = 6
	// RevealerTransitionTypeSwingLeft: floop in from the right
	RevealerTransitionTypeSwingLeft RevealerTransitionType = 7
	// RevealerTransitionTypeSwingUp: floop in from the bottom
	RevealerTransitionTypeSwingUp RevealerTransitionType = 8
	// RevealerTransitionTypeSwingDown: floop in from the top
	RevealerTransitionTypeSwingDown RevealerTransitionType = 9
)

func marshalRevealerTransitionType(p uintptr) (interface{}, error) {
	return RevealerTransitionType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

type ScrollStep int

const (
	// ScrollStepSteps: scroll in steps.
	ScrollStepSteps ScrollStep = 0
	// ScrollStepPages: scroll by pages.
	ScrollStepPages ScrollStep = 1
	// ScrollStepEnds: scroll to ends.
	ScrollStepEnds ScrollStep = 2
	// ScrollStepHorizontalSteps: scroll in horizontal steps.
	ScrollStepHorizontalSteps ScrollStep = 3
	// ScrollStepHorizontalPages: scroll by horizontal pages.
	ScrollStepHorizontalPages ScrollStep = 4
	// ScrollStepHorizontalEnds: scroll to the horizontal ends.
	ScrollStepHorizontalEnds ScrollStep = 5
)

func marshalScrollStep(p uintptr) (interface{}, error) {
	return ScrollStep(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ScrollType: scrolling types.
type ScrollType int

const (
	// ScrollTypeNone: no scrolling.
	ScrollTypeNone ScrollType = 0
	// ScrollTypeJump: jump to new location.
	ScrollTypeJump ScrollType = 1
	// ScrollTypeStepBackward: step backward.
	ScrollTypeStepBackward ScrollType = 2
	// ScrollTypeStepForward: step forward.
	ScrollTypeStepForward ScrollType = 3
	// ScrollTypePageBackward: page backward.
	ScrollTypePageBackward ScrollType = 4
	// ScrollTypePageForward: page forward.
	ScrollTypePageForward ScrollType = 5
	// ScrollTypeStepUp: step up.
	ScrollTypeStepUp ScrollType = 6
	// ScrollTypeStepDown: step down.
	ScrollTypeStepDown ScrollType = 7
	// ScrollTypePageUp: page up.
	ScrollTypePageUp ScrollType = 8
	// ScrollTypePageDown: page down.
	ScrollTypePageDown ScrollType = 9
	// ScrollTypeStepLeft: step to the left.
	ScrollTypeStepLeft ScrollType = 10
	// ScrollTypeStepRight: step to the right.
	ScrollTypeStepRight ScrollType = 11
	// ScrollTypePageLeft: page to the left.
	ScrollTypePageLeft ScrollType = 12
	// ScrollTypePageRight: page to the right.
	ScrollTypePageRight ScrollType = 13
	// ScrollTypeStart: scroll to start.
	ScrollTypeStart ScrollType = 14
	// ScrollTypeEnd: scroll to end.
	ScrollTypeEnd ScrollType = 15
)

func marshalScrollType(p uintptr) (interface{}, error) {
	return ScrollType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ScrollablePolicy: defines the policy to be used in a scrollable widget when
// updating the scrolled window adjustments in a given orientation.
type ScrollablePolicy int

const (
	// ScrollablePolicyMinimum: scrollable adjustments are based on the minimum
	// size
	ScrollablePolicyMinimum ScrollablePolicy = 0
	// ScrollablePolicyNatural: scrollable adjustments are based on the natural
	// size
	ScrollablePolicyNatural ScrollablePolicy = 1
)

func marshalScrollablePolicy(p uintptr) (interface{}, error) {
	return ScrollablePolicy(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SelectionMode: used to control what selections users are allowed to make.
type SelectionMode int

const (
	// SelectionModeNone: no selection is possible.
	SelectionModeNone SelectionMode = 0
	// SelectionModeSingle: zero or one element may be selected.
	SelectionModeSingle SelectionMode = 1
	// SelectionModeBrowse: exactly one element is selected. In some
	// circumstances, such as initially or during a search operation, it’s
	// possible for no element to be selected with GTK_SELECTION_BROWSE. What is
	// really enforced is that the user can’t deselect a currently selected
	// element except by selecting another element.
	SelectionModeBrowse SelectionMode = 2
	// SelectionModeMultiple: any number of elements may be selected. The Ctrl
	// key may be used to enlarge the selection, and Shift key to select between
	// the focus and the child pointed to. Some widgets may also allow
	// Click-drag to select a range of elements.
	SelectionModeMultiple SelectionMode = 3
)

func marshalSelectionMode(p uintptr) (interface{}, error) {
	return SelectionMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SensitivityType: determines how GTK handles the sensitivity of various
// controls, such as combo box buttons.
type SensitivityType int

const (
	// SensitivityTypeAuto: the control is made insensitive if no action can be
	// triggered
	SensitivityTypeAuto SensitivityType = 0
	// SensitivityTypeOn: the control is always sensitive
	SensitivityTypeOn SensitivityType = 1
	// SensitivityTypeOff: the control is always insensitive
	SensitivityTypeOff SensitivityType = 2
)

func marshalSensitivityType(p uintptr) (interface{}, error) {
	return SensitivityType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ShortcutScope: describes where Shortcuts added to a ShortcutController get
// handled.
type ShortcutScope int

const (
	// ShortcutScopeLocal: shortcuts are handled inside the widget the
	// controller belongs to.
	ShortcutScopeLocal ShortcutScope = 0
	// ShortcutScopeManaged: shortcuts are handled by the first ancestor that is
	// a ShortcutManager
	ShortcutScopeManaged ShortcutScope = 1
	// ShortcutScopeGlobal: shortcuts are handled by the root widget.
	ShortcutScopeGlobal ShortcutScope = 2
)

func marshalShortcutScope(p uintptr) (interface{}, error) {
	return ShortcutScope(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ShortcutType: gtkShortcutType specifies the kind of shortcut that is being
// described. More values may be added to this enumeration over time.
type ShortcutType int

const (
	// ShortcutTypeAccelerator: the shortcut is a keyboard accelerator. The
	// ShortcutsShortcut:accelerator property will be used.
	ShortcutTypeAccelerator ShortcutType = 0
	// ShortcutTypeGesturePinch: the shortcut is a pinch gesture. GTK+ provides
	// an icon and subtitle.
	ShortcutTypeGesturePinch ShortcutType = 1
	// ShortcutTypeGestureStretch: the shortcut is a stretch gesture. GTK+
	// provides an icon and subtitle.
	ShortcutTypeGestureStretch ShortcutType = 2
	// ShortcutTypeGestureRotateClockwise: the shortcut is a clockwise rotation
	// gesture. GTK+ provides an icon and subtitle.
	ShortcutTypeGestureRotateClockwise ShortcutType = 3
	// ShortcutTypeGestureRotateCounterclockwise: the shortcut is a
	// counterclockwise rotation gesture. GTK+ provides an icon and subtitle.
	ShortcutTypeGestureRotateCounterclockwise ShortcutType = 4
	// ShortcutTypeGestureTwoFingerSwipeLeft: the shortcut is a two-finger swipe
	// gesture. GTK+ provides an icon and subtitle.
	ShortcutTypeGestureTwoFingerSwipeLeft ShortcutType = 5
	// ShortcutTypeGestureTwoFingerSwipeRight: the shortcut is a two-finger
	// swipe gesture. GTK+ provides an icon and subtitle.
	ShortcutTypeGestureTwoFingerSwipeRight ShortcutType = 6
	// ShortcutTypeGesture: the shortcut is a gesture. The
	// ShortcutsShortcut:icon property will be used.
	ShortcutTypeGesture ShortcutType = 7
	// ShortcutTypeGestureSwipeLeft: the shortcut is a swipe gesture. GTK+
	// provides an icon and subtitle.
	ShortcutTypeGestureSwipeLeft ShortcutType = 8
	// ShortcutTypeGestureSwipeRight: the shortcut is a swipe gesture. GTK+
	// provides an icon and subtitle.
	ShortcutTypeGestureSwipeRight ShortcutType = 9
)

func marshalShortcutType(p uintptr) (interface{}, error) {
	return ShortcutType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SizeGroupMode: the mode of the size group determines the directions in which
// the size group affects the requested sizes of its component widgets.
type SizeGroupMode int

const (
	// SizeGroupModeNone: group has no effect
	SizeGroupModeNone SizeGroupMode = 0
	// SizeGroupModeHorizontal: group affects horizontal requisition
	SizeGroupModeHorizontal SizeGroupMode = 1
	// SizeGroupModeVertical: group affects vertical requisition
	SizeGroupModeVertical SizeGroupMode = 2
	// SizeGroupModeBoth: group affects both horizontal and vertical requisition
	SizeGroupModeBoth SizeGroupMode = 3
)

func marshalSizeGroupMode(p uintptr) (interface{}, error) {
	return SizeGroupMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SizeRequestMode: specifies a preference for height-for-width or
// width-for-height geometry management.
type SizeRequestMode int

const (
	// SizeRequestModeHeightForWidth: prefer height-for-width geometry
	// management
	SizeRequestModeHeightForWidth SizeRequestMode = 0
	// SizeRequestModeWidthForHeight: prefer width-for-height geometry
	// management
	SizeRequestModeWidthForHeight SizeRequestMode = 1
	// SizeRequestModeConstantSize: don’t trade height-for-width or
	// width-for-height
	SizeRequestModeConstantSize SizeRequestMode = 2
)

func marshalSizeRequestMode(p uintptr) (interface{}, error) {
	return SizeRequestMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SortType: determines the direction of a sort.
type SortType int

const (
	// SortTypeAscending: sorting is in ascending order.
	SortTypeAscending SortType = 0
	// SortTypeDescending: sorting is in descending order.
	SortTypeDescending SortType = 1
)

func marshalSortType(p uintptr) (interface{}, error) {
	return SortType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SorterChange: describes changes in a sorter in more detail and allows users
// to optimize resorting.
type SorterChange int

const (
	// SorterChangeDifferent: the sorter change cannot be described by any of
	// the other enumeration values
	SorterChangeDifferent SorterChange = 0
	// SorterChangeInverted: the sort order was inverted. Comparisons that
	// returned GTK_ORDERING_SMALLER now return GTK_ORDERING_LARGER and vice
	// versa. Other comparisons return the same values as before.
	SorterChangeInverted SorterChange = 1
	// SorterChangeLessStrict: the sorter is less strict: Comparisons may now
	// return GTK_ORDERING_EQUAL that did not do so before.
	SorterChangeLessStrict SorterChange = 2
	// SorterChangeMoreStrict: the sorter is more strict: Comparisons that did
	// return GTK_ORDERING_EQUAL may not do so anymore.
	SorterChangeMoreStrict SorterChange = 3
)

func marshalSorterChange(p uintptr) (interface{}, error) {
	return SorterChange(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SorterOrder: describes the type of order that a Sorter may describe.
type SorterOrder int

const (
	// SorterOrderPartial: a partial order. Any Ordering is possible.
	SorterOrderPartial SorterOrder = 0
	// SorterOrderNone: no order, all elements are considered equal.
	// gtk_sorter_compare() will only return GTK_ORDERING_EQUAL.
	SorterOrderNone SorterOrder = 1
	// SorterOrderTotal: a total order. gtk_sorter_compare() will only return
	// GTK_ORDERING_EQUAL if an item is compared with itself. Two different
	// items will never cause this value to be returned.
	SorterOrderTotal SorterOrder = 2
)

func marshalSorterOrder(p uintptr) (interface{}, error) {
	return SorterOrder(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SpinButtonUpdatePolicy: the spin button update policy determines whether the
// spin button displays values even if they are outside the bounds of its
// adjustment. See gtk_spin_button_set_update_policy().
type SpinButtonUpdatePolicy int

const (
	// SpinButtonUpdatePolicyAlways: when refreshing your SpinButton, the value
	// is always displayed
	SpinButtonUpdatePolicyAlways SpinButtonUpdatePolicy = 0
	// SpinButtonUpdatePolicyIfValid: when refreshing your SpinButton, the value
	// is only displayed if it is valid within the bounds of the spin button's
	// adjustment
	SpinButtonUpdatePolicyIfValid SpinButtonUpdatePolicy = 1
)

func marshalSpinButtonUpdatePolicy(p uintptr) (interface{}, error) {
	return SpinButtonUpdatePolicy(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SpinType: the values of the GtkSpinType enumeration are used to specify the
// change to make in gtk_spin_button_spin().
type SpinType int

const (
	// SpinTypeStepForward: increment by the adjustments step increment.
	SpinTypeStepForward SpinType = 0
	// SpinTypeStepBackward: decrement by the adjustments step increment.
	SpinTypeStepBackward SpinType = 1
	// SpinTypePageForward: increment by the adjustments page increment.
	SpinTypePageForward SpinType = 2
	// SpinTypePageBackward: decrement by the adjustments page increment.
	SpinTypePageBackward SpinType = 3
	// SpinTypeHome: go to the adjustments lower bound.
	SpinTypeHome SpinType = 4
	// SpinTypeEnd: go to the adjustments upper bound.
	SpinTypeEnd SpinType = 5
	// SpinTypeUserDefined: change by a specified amount.
	SpinTypeUserDefined SpinType = 6
)

func marshalSpinType(p uintptr) (interface{}, error) {
	return SpinType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// StackTransitionType: these enumeration values describe the possible
// transitions between pages in a Stack widget.
//
// New values may be added to this enumeration over time.
type StackTransitionType int

const (
	// StackTransitionTypeNone: no transition
	StackTransitionTypeNone StackTransitionType = 0
	// StackTransitionTypeCrossfade: a cross-fade
	StackTransitionTypeCrossfade StackTransitionType = 1
	// StackTransitionTypeSlideRight: slide from left to right
	StackTransitionTypeSlideRight StackTransitionType = 2
	// StackTransitionTypeSlideLeft: slide from right to left
	StackTransitionTypeSlideLeft StackTransitionType = 3
	// StackTransitionTypeSlideUp: slide from bottom up
	StackTransitionTypeSlideUp StackTransitionType = 4
	// StackTransitionTypeSlideDown: slide from top down
	StackTransitionTypeSlideDown StackTransitionType = 5
	// StackTransitionTypeSlideLeftRight: slide from left or right according to
	// the children order
	StackTransitionTypeSlideLeftRight StackTransitionType = 6
	// StackTransitionTypeSlideUpDown: slide from top down or bottom up
	// according to the order
	StackTransitionTypeSlideUpDown StackTransitionType = 7
	// StackTransitionTypeOverUp: cover the old page by sliding up
	StackTransitionTypeOverUp StackTransitionType = 8
	// StackTransitionTypeOverDown: cover the old page by sliding down
	StackTransitionTypeOverDown StackTransitionType = 9
	// StackTransitionTypeOverLeft: cover the old page by sliding to the left
	StackTransitionTypeOverLeft StackTransitionType = 10
	// StackTransitionTypeOverRight: cover the old page by sliding to the right
	StackTransitionTypeOverRight StackTransitionType = 11
	// StackTransitionTypeUnderUp: uncover the new page by sliding up
	StackTransitionTypeUnderUp StackTransitionType = 12
	// StackTransitionTypeUnderDown: uncover the new page by sliding down
	StackTransitionTypeUnderDown StackTransitionType = 13
	// StackTransitionTypeUnderLeft: uncover the new page by sliding to the left
	StackTransitionTypeUnderLeft StackTransitionType = 14
	// StackTransitionTypeUnderRight: uncover the new page by sliding to the
	// right
	StackTransitionTypeUnderRight StackTransitionType = 15
	// StackTransitionTypeOverUpDown: cover the old page sliding up or uncover
	// the new page sliding down, according to order
	StackTransitionTypeOverUpDown StackTransitionType = 16
	// StackTransitionTypeOverDownUp: cover the old page sliding down or uncover
	// the new page sliding up, according to order
	StackTransitionTypeOverDownUp StackTransitionType = 17
	// StackTransitionTypeOverLeftRight: cover the old page sliding left or
	// uncover the new page sliding right, according to order
	StackTransitionTypeOverLeftRight StackTransitionType = 18
	// StackTransitionTypeOverRightLeft: cover the old page sliding right or
	// uncover the new page sliding left, according to order
	StackTransitionTypeOverRightLeft StackTransitionType = 19
	// StackTransitionTypeRotateLeft: pretend the pages are sides of a cube and
	// rotate that cube to the left
	StackTransitionTypeRotateLeft StackTransitionType = 20
	// StackTransitionTypeRotateRight: pretend the pages are sides of a cube and
	// rotate that cube to the right
	StackTransitionTypeRotateRight StackTransitionType = 21
	// StackTransitionTypeRotateLeftRight: pretend the pages are sides of a cube
	// and rotate that cube to the left or right according to the children order
	StackTransitionTypeRotateLeftRight StackTransitionType = 22
)

func marshalStackTransitionType(p uintptr) (interface{}, error) {
	return StackTransitionType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// StringFilterMatchMode: specifies how search strings are matched inside text.
type StringFilterMatchMode int

const (
	// StringFilterMatchModeExact: the search string and text must match
	// exactly.
	StringFilterMatchModeExact StringFilterMatchMode = 0
	// StringFilterMatchModeSubstring: the search string must be contained as a
	// substring inside the text.
	StringFilterMatchModeSubstring StringFilterMatchMode = 1
	// StringFilterMatchModePrefix: the text must begin with the search string.
	StringFilterMatchModePrefix StringFilterMatchMode = 2
)

func marshalStringFilterMatchMode(p uintptr) (interface{}, error) {
	return StringFilterMatchMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SystemSetting: values that can be passed to the
// GtkWidgetClass.system_setting_changed vfunc to indicate that a system setting
// has changed and widgets may need to drop caches, or react otherwise.
//
// Most of the values correspond to Settings properties.
//
// More values may be added over time.
type SystemSetting int

const (
	// SystemSettingDPI: the Settings:gtk-xft-dpi setting has changed
	SystemSettingDPI SystemSetting = 0
	// SystemSettingFontName: the Settings:gtk-font-name setting has changed
	SystemSettingFontName SystemSetting = 1
	// SystemSettingFontConfig: the font configuration has changed in a way that
	// requires text to be redrawn. This can be any of the
	// Settings:gtk-xft-antialias, Settings:gtk-xft-hinting,
	// Settings:gtk-xft-hintstyle, Settings:gtk-xft-rgba or
	// Settings:gtk-fontconfig-timestamp settings
	SystemSettingFontConfig SystemSetting = 2
	// SystemSettingDisplay: the display has changed
	SystemSettingDisplay SystemSetting = 3
	// SystemSettingIconTheme: the icon theme has changed in a way that requires
	// icons to be looked up again
	SystemSettingIconTheme SystemSetting = 4
)

func marshalSystemSetting(p uintptr) (interface{}, error) {
	return SystemSetting(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TextDirection: reading directions for text.
type TextDirection int

const (
	// TextDirectionNone: no direction.
	TextDirectionNone TextDirection = 0
	// TextDirectionLTR: left to right text direction.
	TextDirectionLTR TextDirection = 1
	// TextDirectionRTL: right to left text direction.
	TextDirectionRTL TextDirection = 2
)

func marshalTextDirection(p uintptr) (interface{}, error) {
	return TextDirection(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TextExtendSelection: granularity types that extend the text selection. Use
// the TextView::extend-selection signal to customize the selection.
type TextExtendSelection int

const (
	// TextExtendSelectionWord: selects the current word. It is triggered by a
	// double-click for example.
	TextExtendSelectionWord TextExtendSelection = 0
	// TextExtendSelectionLine: selects the current line. It is triggered by a
	// triple-click for example.
	TextExtendSelectionLine TextExtendSelection = 1
)

func marshalTextExtendSelection(p uintptr) (interface{}, error) {
	return TextExtendSelection(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TextViewLayer: used to reference the layers of TextView for the purpose of
// customized drawing with the ::snapshot_layer vfunc.
type TextViewLayer int

const (
	// TextViewLayerBelowText: the layer rendered below the text (but above the
	// background).
	TextViewLayerBelowText TextViewLayer = 0
	// TextViewLayerAboveText: the layer rendered above the text.
	TextViewLayerAboveText TextViewLayer = 1
)

func marshalTextViewLayer(p uintptr) (interface{}, error) {
	return TextViewLayer(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TextWindowType: used to reference the parts of TextView.
type TextWindowType int

const (
	// TextWindowTypeWidget: window that floats over scrolling areas.
	TextWindowTypeWidget TextWindowType = 1
	// TextWindowTypeText: scrollable text window.
	TextWindowTypeText TextWindowType = 2
	// TextWindowTypeLeft: left side border window.
	TextWindowTypeLeft TextWindowType = 3
	// TextWindowTypeRight: right side border window.
	TextWindowTypeRight TextWindowType = 4
	// TextWindowTypeTop: top border window.
	TextWindowTypeTop TextWindowType = 5
	// TextWindowTypeBottom: bottom border window.
	TextWindowTypeBottom TextWindowType = 6
)

func marshalTextWindowType(p uintptr) (interface{}, error) {
	return TextWindowType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TreeViewColumnSizing: the sizing method the column uses to determine its
// width. Please note that GTK_TREE_VIEW_COLUMN_AUTOSIZE are inefficient for
// large views, and can make columns appear choppy.
type TreeViewColumnSizing int

const (
	// TreeViewColumnSizingGrowOnly: columns only get bigger in reaction to
	// changes in the model
	TreeViewColumnSizingGrowOnly TreeViewColumnSizing = 0
	// TreeViewColumnSizingAutosize: columns resize to be the optimal size every
	// time the model changes.
	TreeViewColumnSizingAutosize TreeViewColumnSizing = 1
	// TreeViewColumnSizingFixed: columns are a fixed numbers of pixels wide.
	TreeViewColumnSizingFixed TreeViewColumnSizing = 2
)

func marshalTreeViewColumnSizing(p uintptr) (interface{}, error) {
	return TreeViewColumnSizing(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TreeViewDropPosition: an enum for determining where a dropped row goes.
type TreeViewDropPosition int

const (
	// TreeViewDropPositionBefore: dropped row is inserted before
	TreeViewDropPositionBefore TreeViewDropPosition = 0
	// TreeViewDropPositionAfter: dropped row is inserted after
	TreeViewDropPositionAfter TreeViewDropPosition = 1
	// TreeViewDropPositionIntoOrBefore: dropped row becomes a child or is
	// inserted before
	TreeViewDropPositionIntoOrBefore TreeViewDropPosition = 2
	// TreeViewDropPositionIntoOrAfter: dropped row becomes a child or is
	// inserted after
	TreeViewDropPositionIntoOrAfter TreeViewDropPosition = 3
)

func marshalTreeViewDropPosition(p uintptr) (interface{}, error) {
	return TreeViewDropPosition(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TreeViewGridLines: used to indicate which grid lines to draw in a tree view.
type TreeViewGridLines int

const (
	// TreeViewGridLinesNone: no grid lines.
	TreeViewGridLinesNone TreeViewGridLines = 0
	// TreeViewGridLinesHorizontal: horizontal grid lines.
	TreeViewGridLinesHorizontal TreeViewGridLines = 1
	// TreeViewGridLinesVertical: vertical grid lines.
	TreeViewGridLinesVertical TreeViewGridLines = 2
	// TreeViewGridLinesBoth: horizontal and vertical grid lines.
	TreeViewGridLinesBoth TreeViewGridLines = 3
)

func marshalTreeViewGridLines(p uintptr) (interface{}, error) {
	return TreeViewGridLines(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// Unit: see also gtk_print_settings_set_paper_width().
type Unit int

const (
	// UnitNone: no units.
	UnitNone Unit = 0
	// UnitPoints: dimensions in points.
	UnitPoints Unit = 1
	// UnitInch: dimensions in inches.
	UnitInch Unit = 2
	// UnitMm: dimensions in millimeters
	UnitMm Unit = 3
)

func marshalUnit(p uintptr) (interface{}, error) {
	return Unit(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// WrapMode: describes a type of line wrapping.
type WrapMode int

const (
	// WrapModeNone: do not wrap lines; just make the text area wider
	WrapModeNone WrapMode = 0
	// WrapModeChar: wrap text, breaking lines anywhere the cursor can appear
	// (between characters, usually - if you want to be technical, between
	// graphemes, see pango_get_log_attrs())
	WrapModeChar WrapMode = 1
	// WrapModeWord: wrap text, breaking lines in between words
	WrapModeWord WrapMode = 2
	// WrapModeWordChar: wrap text, breaking lines in between words, or if that
	// is not enough, also between graphemes
	WrapModeWordChar WrapMode = 3
)

func marshalWrapMode(p uintptr) (interface{}, error) {
	return WrapMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ApplicationInhibitFlags: types of user actions that may be blocked by
// gtk_application_inhibit().
type ApplicationInhibitFlags int

const (
	// ApplicationInhibitFlagsLogout: inhibit ending the user session by logging
	// out or by shutting down the computer
	ApplicationInhibitFlagsLogout ApplicationInhibitFlags = 0b1
	// ApplicationInhibitFlagsSwitch: inhibit user switching
	ApplicationInhibitFlagsSwitch ApplicationInhibitFlags = 0b10
	// ApplicationInhibitFlagsSuspend: inhibit suspending the session or
	// computer
	ApplicationInhibitFlagsSuspend ApplicationInhibitFlags = 0b100
	// ApplicationInhibitFlagsIdle: inhibit the session being marked as idle
	// (and possibly locked)
	ApplicationInhibitFlagsIdle ApplicationInhibitFlags = 0b1000
)

func marshalApplicationInhibitFlags(p uintptr) (interface{}, error) {
	return ApplicationInhibitFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// BuilderClosureFlags: the list of flags that can be passed to
// gtk_builder_create_closure(). New values may be added in the future for new
// features, so external implementations of GtkBuilderScopeInterface should test
// the flags for unknown values and raise a GTK_BUILDER_ERROR_INVALID_ATTRIBUTE
// error when they encounter one.
type BuilderClosureFlags int

const (
	// BuilderClosureFlagsSwapped: the closure should be created swapped. See
	// g_cclosure_new_swap() for details.
	BuilderClosureFlagsSwapped BuilderClosureFlags = 0b1
)

func marshalBuilderClosureFlags(p uintptr) (interface{}, error) {
	return BuilderClosureFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// CellRendererState: tells how a cell is to be rendered.
type CellRendererState int

const (
	// CellRendererStateSelected: the cell is currently selected, and probably
	// has a selection colored background to render to.
	CellRendererStateSelected CellRendererState = 0b1
	// CellRendererStatePrelit: the mouse is hovering over the cell.
	CellRendererStatePrelit CellRendererState = 0b10
	// CellRendererStateInsensitive: the cell is drawn in an insensitive manner
	CellRendererStateInsensitive CellRendererState = 0b100
	// CellRendererStateSorted: the cell is in a sorted row
	CellRendererStateSorted CellRendererState = 0b1000
	// CellRendererStateFocused: the cell is in the focus row.
	CellRendererStateFocused CellRendererState = 0b10000
	// CellRendererStateExpandable: the cell is in a row that can be expanded
	CellRendererStateExpandable CellRendererState = 0b100000
	// CellRendererStateExpanded: the cell is in a row that is expanded
	CellRendererStateExpanded CellRendererState = 0b1000000
)

func marshalCellRendererState(p uintptr) (interface{}, error) {
	return CellRendererState(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

type DebugFlags int

const (
	DebugFlagsText DebugFlags = 0b1

	DebugFlagsTree DebugFlags = 0b10

	DebugFlagsKeybindings DebugFlags = 0b100

	DebugFlagsModules DebugFlags = 0b1000

	DebugFlagsGeometry DebugFlags = 0b10000

	DebugFlagsIcontheme DebugFlags = 0b100000

	DebugFlagsPrinting DebugFlags = 0b1000000

	DebugFlagsBuilder DebugFlags = 0b10000000

	DebugFlagsSizeRequest DebugFlags = 0b100000000

	DebugFlagsNoCSSCache DebugFlags = 0b1000000000

	DebugFlagsInteractive DebugFlags = 0b10000000000

	DebugFlagsTouchscreen DebugFlags = 0b100000000000

	DebugFlagsActions DebugFlags = 0b1000000000000

	DebugFlagsLayout DebugFlags = 0b10000000000000

	DebugFlagsSnapshot DebugFlags = 0b100000000000000

	DebugFlagsConstraints DebugFlags = 0b1000000000000000

	DebugFlagsBuilderObjects DebugFlags = 0b10000000000000000

	DebugFlagsA11Y DebugFlags = 0b100000000000000000
)

func marshalDebugFlags(p uintptr) (interface{}, error) {
	return DebugFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DialogFlags: flags used to influence dialog construction.
type DialogFlags int

const (
	// DialogFlagsModal: make the constructed dialog modal, see
	// gtk_window_set_modal()
	DialogFlagsModal DialogFlags = 0b1
	// DialogFlagsDestroyWithParent: destroy the dialog when its parent is
	// destroyed, see gtk_window_set_destroy_with_parent()
	DialogFlagsDestroyWithParent DialogFlags = 0b10
	// DialogFlagsUseHeaderBar: create dialog with actions in header bar instead
	// of action area
	DialogFlagsUseHeaderBar DialogFlags = 0b100
)

func marshalDialogFlags(p uintptr) (interface{}, error) {
	return DialogFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// EventControllerScrollFlags: describes the behavior of a
// EventControllerScroll.
type EventControllerScrollFlags int

const (
	// EventControllerScrollFlagsNone: don't emit scroll.
	EventControllerScrollFlagsNone EventControllerScrollFlags = 0b0
	// EventControllerScrollFlagsVertical: emit scroll with vertical deltas.
	EventControllerScrollFlagsVertical EventControllerScrollFlags = 0b1
	// EventControllerScrollFlagsHorizontal: emit scroll with horizontal deltas.
	EventControllerScrollFlagsHorizontal EventControllerScrollFlags = 0b10
	// EventControllerScrollFlagsDiscrete: only emit deltas that are multiples
	// of 1.
	EventControllerScrollFlagsDiscrete EventControllerScrollFlags = 0b100
	// EventControllerScrollFlagsKinetic: emit EventControllerScroll::decelerate
	// after continuous scroll finishes.
	EventControllerScrollFlagsKinetic EventControllerScrollFlags = 0b1000
	// EventControllerScrollFlagsBothAxes: emit scroll on both axes.
	EventControllerScrollFlagsBothAxes EventControllerScrollFlags = 0b11
)

func marshalEventControllerScrollFlags(p uintptr) (interface{}, error) {
	return EventControllerScrollFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FontChooserLevel: this enumeration specifies the granularity of font
// selection that is desired in a font chooser.
//
// This enumeration may be extended in the future; applications should ignore
// unknown values.
type FontChooserLevel int

const (
	// FontChooserLevelFamily: allow selecting a font family
	FontChooserLevelFamily FontChooserLevel = 0b0
	// FontChooserLevelStyle: allow selecting a specific font face
	FontChooserLevelStyle FontChooserLevel = 0b1
	// FontChooserLevelSize: allow selecting a specific font size
	FontChooserLevelSize FontChooserLevel = 0b10
	// FontChooserLevelVariations: allow changing OpenType font variation axes
	FontChooserLevelVariations FontChooserLevel = 0b100
	// FontChooserLevelFeatures: allow selecting specific OpenType font features
	FontChooserLevelFeatures FontChooserLevel = 0b1000
)

func marshalFontChooserLevel(p uintptr) (interface{}, error) {
	return FontChooserLevel(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// IconLookupFlags: used to specify options for gtk_icon_theme_lookup_icon()
type IconLookupFlags int

const (
	// IconLookupFlagsForceRegular: try to always load regular icons, even when
	// symbolic icon names are given
	IconLookupFlagsForceRegular IconLookupFlags = 0b1
	// IconLookupFlagsForceSymbolic: try to always load symbolic icons, even
	// when regular icon names are given
	IconLookupFlagsForceSymbolic IconLookupFlags = 0b10
	// IconLookupFlagsPreload: starts loading the texture in the background so
	// it is ready when later needed.
	IconLookupFlagsPreload IconLookupFlags = 0b100
)

func marshalIconLookupFlags(p uintptr) (interface{}, error) {
	return IconLookupFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// InputHints: describes hints that might be taken into account by input methods
// or applications. Note that input methods may already tailor their behaviour
// according to the InputPurpose of the entry.
//
// Some common sense is expected when using these flags - mixing
// GTK_INPUT_HINT_LOWERCASE with any of the uppercase hints makes no sense.
//
// This enumeration may be extended in the future; input methods should ignore
// unknown values.
type InputHints int

const (
	// InputHintsNone: no special behaviour suggested
	InputHintsNone InputHints = 0b0
	// InputHintsSpellcheck: suggest checking for typos
	InputHintsSpellcheck InputHints = 0b1
	// InputHintsNoSpellcheck: suggest not checking for typos
	InputHintsNoSpellcheck InputHints = 0b10
	// InputHintsWordCompletion: suggest word completion
	InputHintsWordCompletion InputHints = 0b100
	// InputHintsLowercase: suggest to convert all text to lowercase
	InputHintsLowercase InputHints = 0b1000
	// InputHintsUppercaseChars: suggest to capitalize all text
	InputHintsUppercaseChars InputHints = 0b10000
	// InputHintsUppercaseWords: suggest to capitalize the first character of
	// each word
	InputHintsUppercaseWords InputHints = 0b100000
	// InputHintsUppercaseSentences: suggest to capitalize the first word of
	// each sentence
	InputHintsUppercaseSentences InputHints = 0b1000000
	// InputHintsInhibitOsk: suggest to not show an onscreen keyboard (e.g for a
	// calculator that already has all the keys).
	InputHintsInhibitOsk InputHints = 0b10000000
	// InputHintsVerticalWriting: the text is vertical
	InputHintsVerticalWriting InputHints = 0b100000000
	// InputHintsEmoji: suggest offering Emoji support
	InputHintsEmoji InputHints = 0b1000000000
	// InputHintsNoEmoji: suggest not offering Emoji support
	InputHintsNoEmoji InputHints = 0b10000000000
	// InputHintsPrivate: request that the input method should not update
	// personalized data (like typing history)
	InputHintsPrivate InputHints = 0b100000000000
)

func marshalInputHints(p uintptr) (interface{}, error) {
	return InputHints(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PickFlags: flags that influence the behavior of gtk_widget_pick()
type PickFlags int

const (
	// PickFlagsDefault: the default behavior, include widgets that are
	// receiving events
	PickFlagsDefault PickFlags = 0b0
	// PickFlagsInsensitive: include widgets that are insensitive
	PickFlagsInsensitive PickFlags = 0b1
	// PickFlagsNonTargetable: include widgets that are marked as
	// non-targetable. See Widget:can-target
	PickFlagsNonTargetable PickFlags = 0b10
)

func marshalPickFlags(p uintptr) (interface{}, error) {
	return PickFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PopoverMenuFlags: flags that affect how popover menus are created from a menu
// model.
type PopoverMenuFlags int

const (
	// PopoverMenuFlagsNested: create submenus as nested popovers. Without this
	// flag, submenus are created as sliding pages that replace the main menu.
	PopoverMenuFlagsNested PopoverMenuFlags = 0b1
)

func marshalPopoverMenuFlags(p uintptr) (interface{}, error) {
	return PopoverMenuFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ShortcutActionFlags: list of flags that can be passed to action activation.
// More flags may be added in the future.
type ShortcutActionFlags int

const (
	// ShortcutActionFlagsExclusive: the action is the only action that can be
	// activated. If this flag is not set, a future activation may select a
	// different action.
	ShortcutActionFlagsExclusive ShortcutActionFlags = 0b1
)

func marshalShortcutActionFlags(p uintptr) (interface{}, error) {
	return ShortcutActionFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// StateFlags: describes a widget state. Widget states are used to match the
// widget against CSS pseudo-classes. Note that GTK extends the regular CSS
// classes and sometimes uses different names.
type StateFlags int

const (
	// StateFlagsNormal: state during normal operation
	StateFlagsNormal StateFlags = 0b0
	// StateFlagsActive: widget is active
	StateFlagsActive StateFlags = 0b1
	// StateFlagsPrelight: widget has a mouse pointer over it
	StateFlagsPrelight StateFlags = 0b10
	// StateFlagsSelected: widget is selected
	StateFlagsSelected StateFlags = 0b100
	// StateFlagsInsensitive: widget is insensitive
	StateFlagsInsensitive StateFlags = 0b1000
	// StateFlagsInconsistent: widget is inconsistent
	StateFlagsInconsistent StateFlags = 0b10000
	// StateFlagsFocused: widget has the keyboard focus
	StateFlagsFocused StateFlags = 0b100000
	// StateFlagsBackdrop: widget is in a background toplevel window
	StateFlagsBackdrop StateFlags = 0b1000000
	// StateFlagsDirLTR: widget is in left-to-right text direction
	StateFlagsDirLTR StateFlags = 0b10000000
	// StateFlagsDirRTL: widget is in right-to-left text direction
	StateFlagsDirRTL StateFlags = 0b100000000
	// StateFlagsLink: widget is a link
	StateFlagsLink StateFlags = 0b1000000000
	// StateFlagsVisited: the location the widget points to has already been
	// visited
	StateFlagsVisited StateFlags = 0b10000000000
	// StateFlagsChecked: widget is checked
	StateFlagsChecked StateFlags = 0b100000000000
	// StateFlagsDropActive: widget is highlighted as a drop target for DND
	StateFlagsDropActive StateFlags = 0b1000000000000
	// StateFlagsFocusVisible: widget has the visible focus
	StateFlagsFocusVisible StateFlags = 0b10000000000000
	// StateFlagsFocusWithin: widget contains the keyboard focus
	StateFlagsFocusWithin StateFlags = 0b100000000000000
)

func marshalStateFlags(p uintptr) (interface{}, error) {
	return StateFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// StyleContextPrintFlags: flags that modify the behavior of
// gtk_style_context_to_string(). New values may be added to this enumeration.
type StyleContextPrintFlags int

const (
	// StyleContextPrintFlagsNone: default value.
	StyleContextPrintFlagsNone StyleContextPrintFlags = 0b0
	// StyleContextPrintFlagsRecurse: print the entire tree of CSS nodes
	// starting at the style context's node
	StyleContextPrintFlagsRecurse StyleContextPrintFlags = 0b1
	// StyleContextPrintFlagsShowStyle: show the values of the CSS properties
	// for each node
	StyleContextPrintFlagsShowStyle StyleContextPrintFlags = 0b10
	// StyleContextPrintFlagsShowChange: show information about what changes
	// affect the styles
	StyleContextPrintFlagsShowChange StyleContextPrintFlags = 0b100
)

func marshalStyleContextPrintFlags(p uintptr) (interface{}, error) {
	return StyleContextPrintFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TextSearchFlags: flags affecting how a search is done.
//
// If neither K_TEXT_SEARCH_VISIBLE_ONLY nor K_TEXT_SEARCH_TEXT_ONLY are
// enabled, the match must be exact; the special 0xFFFC character will match
// embedded paintables or child widgets.
type TextSearchFlags int

const (
	// TextSearchFlagsVisibleOnly: search only visible data. A search match may
	// have invisible text interspersed.
	TextSearchFlagsVisibleOnly TextSearchFlags = 0b1
	// TextSearchFlagsTextOnly: search only text. A match may have paintables or
	// child widgets mixed inside the matched range.
	TextSearchFlagsTextOnly TextSearchFlags = 0b10
	// TextSearchFlagsCaseInsensitive: the text will be matched regardless of
	// what case it is in.
	TextSearchFlagsCaseInsensitive TextSearchFlags = 0b100
)

func marshalTextSearchFlags(p uintptr) (interface{}, error) {
	return TextSearchFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TreeModelFlags: these flags indicate various properties of a TreeModel.
//
// They are returned by gtk_tree_model_get_flags(), and must be static for the
// lifetime of the object. A more complete description of
// K_TREE_MODEL_ITERS_PERSIST can be found in the overview of this section.
type TreeModelFlags int

const (
	// TreeModelFlagsItersPersist: iterators survive all signals emitted by the
	// tree
	TreeModelFlagsItersPersist TreeModelFlags = 0b1
	// TreeModelFlagsListOnly: the model is a list only, and never has children
	TreeModelFlagsListOnly TreeModelFlags = 0b10
)

func marshalTreeModelFlags(p uintptr) (interface{}, error) {
	return TreeModelFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

type AssistantPageFunc func(currentPage int) int

//export cAssistantPageFunc
func cAssistantPageFunc(arg0 C.int, arg1 C.gpointer) C.int

type CellAllocCallback func(renderer CellRenderer, cellArea *gdk.Rectangle, cellBackground *gdk.Rectangle) bool

//export cCellAllocCallback
func cCellAllocCallback(arg0 *C.GtkCellRenderer, arg1 *C.GdkRectangle, arg2 *C.GdkRectangle, arg3 C.gpointer) C.gboolean

type CellCallback func(renderer CellRenderer) bool

//export cCellCallback
func cCellCallback(arg0 *C.GtkCellRenderer, arg1 C.gpointer) C.gboolean

type CellLayoutDataFunc func(cellLayout CellLayout, cell CellRenderer, treeModel TreeModel, iter *TreeIter)

//export cCellLayoutDataFunc
func cCellLayoutDataFunc(arg0 *C.GtkCellLayout, arg1 *C.GtkCellRenderer, arg2 *C.GtkTreeModel, arg3 *C.GtkTreeIter, arg4 C.gpointer)

type CustomAllocateFunc func(widget Widget, width int, height int, baseline int)

//export cCustomAllocateFunc
func cCustomAllocateFunc(arg0 *C.GtkWidget, arg1 C.int, arg2 C.int, arg3 C.int)

type CustomFilterFunc func(item interface{}) bool

//export cCustomFilterFunc
func cCustomFilterFunc(arg0 C.gpointer, arg1 C.gpointer) C.gboolean

type CustomMeasureFunc func(widget Widget, orientation Orientation, forSize int) (minimum int, natural int, minimumBaseline int, naturalBaseline int)

//export cCustomMeasureFunc
func cCustomMeasureFunc(arg0 *C.GtkWidget, arg1 C.GtkOrientation, arg2 C.int, arg3 *C.int, arg4 *C.int, arg5 *C.int, arg6 *C.int)

type CustomRequestModeFunc func(widget Widget) SizeRequestMode

//export cCustomRequestModeFunc
func cCustomRequestModeFunc(arg0 *C.GtkWidget) C.GtkSizeRequestMode

type DrawingAreaDrawFunc func(drawingArea DrawingArea, cr *cairo.Context, width int, height int)

//export cDrawingAreaDrawFunc
func cDrawingAreaDrawFunc(arg0 *C.GtkDrawingArea, arg1 *C.cairo_t, arg2 C.int, arg3 C.int, arg4 C.gpointer)

type EntryCompletionMatchFunc func(completion EntryCompletion, key string, iter *TreeIter) bool

//export cEntryCompletionMatchFunc
func cEntryCompletionMatchFunc(arg0 *C.GtkEntryCompletion, arg1 *C.char, arg2 *C.GtkTreeIter, arg3 C.gpointer) C.gboolean

type ExpressionNotify func()

//export cExpressionNotify
func cExpressionNotify(arg0 C.gpointer)

type FlowBoxCreateWidgetFunc func(item interface{}) Widget

//export cFlowBoxCreateWidgetFunc
func cFlowBoxCreateWidgetFunc(arg0 C.gpointer, arg1 C.gpointer) *C.GtkWidget

type FlowBoxFilterFunc func(child FlowBoxChild) bool

//export cFlowBoxFilterFunc
func cFlowBoxFilterFunc(arg0 *C.GtkFlowBoxChild, arg1 C.gpointer) C.gboolean

type FlowBoxForeachFunc func(box FlowBox, child FlowBoxChild)

//export cFlowBoxForeachFunc
func cFlowBoxForeachFunc(arg0 *C.GtkFlowBox, arg1 *C.GtkFlowBoxChild, arg2 C.gpointer)

type FlowBoxSortFunc func(child1 FlowBoxChild, child2 FlowBoxChild) int

//export cFlowBoxSortFunc
func cFlowBoxSortFunc(arg0 *C.GtkFlowBoxChild, arg1 *C.GtkFlowBoxChild, arg2 C.gpointer) C.int

type FontFilterFunc func(family pango.FontFamily, face pango.FontFace) bool

//export cFontFilterFunc
func cFontFilterFunc(arg0 *C.PangoFontFamily, arg1 *C.PangoFontFace, arg2 C.gpointer) C.gboolean

type IconViewForeachFunc func(iconView IconView, path *TreePath)

//export cIconViewForeachFunc
func cIconViewForeachFunc(arg0 *C.GtkIconView, arg1 *C.GtkTreePath, arg2 C.gpointer)

type ListBoxCreateWidgetFunc func(item interface{}) Widget

//export cListBoxCreateWidgetFunc
func cListBoxCreateWidgetFunc(arg0 C.gpointer, arg1 C.gpointer) *C.GtkWidget

type ListBoxFilterFunc func(row ListBoxRow) bool

//export cListBoxFilterFunc
func cListBoxFilterFunc(arg0 *C.GtkListBoxRow, arg1 C.gpointer) C.gboolean

type ListBoxForeachFunc func(box ListBox, row ListBoxRow)

//export cListBoxForeachFunc
func cListBoxForeachFunc(arg0 *C.GtkListBox, arg1 *C.GtkListBoxRow, arg2 C.gpointer)

type ListBoxSortFunc func(row1 ListBoxRow, row2 ListBoxRow) int

//export cListBoxSortFunc
func cListBoxSortFunc(arg0 *C.GtkListBoxRow, arg1 *C.GtkListBoxRow, arg2 C.gpointer) C.int

type ListBoxUpdateHeaderFunc func(row ListBoxRow, before ListBoxRow)

//export cListBoxUpdateHeaderFunc
func cListBoxUpdateHeaderFunc(arg0 *C.GtkListBoxRow, arg1 *C.GtkListBoxRow, arg2 C.gpointer)

type MapListModelMapFunc func(item interface{}) interface{}

//export cMapListModelMapFunc
func cMapListModelMapFunc(arg0 C.gpointer, arg1 C.gpointer) C.gpointer

type MenuButtonCreatePopupFunc func(menuButton MenuButton)

//export cMenuButtonCreatePopupFunc
func cMenuButtonCreatePopupFunc(arg0 *C.GtkMenuButton, arg1 C.gpointer)

type PageSetupDoneFunc func(pageSetup PageSetup)

//export cPageSetupDoneFunc
func cPageSetupDoneFunc(arg0 *C.GtkPageSetup, arg1 C.gpointer)

type PrintSettingsFunc func(key string, value string)

//export cPrintSettingsFunc
func cPrintSettingsFunc(arg0 *C.char, arg1 *C.char, arg2 C.gpointer)

type ScaleFormatValueFunc func(scale Scale, value float64) string

//export cScaleFormatValueFunc
func cScaleFormatValueFunc(arg0 *C.GtkScale, arg1 C.double, arg2 C.gpointer) *C.char

type ShortcutFunc func(widget Widget, args *glib.Variant) bool

//export cShortcutFunc
func cShortcutFunc(arg0 *C.GtkWidget, arg1 *C.GVariant, arg2 C.gpointer) C.gboolean

type TextCharPredicate func(ch uint32) bool

//export cTextCharPredicate
func cTextCharPredicate(arg0 C.gunichar, arg1 C.gpointer) C.gboolean

type TextTagTableForeach func(tag TextTag)

//export cTextTagTableForeach
func cTextTagTableForeach(arg0 *C.GtkTextTag, arg1 C.gpointer)

type TickCallback func(widget Widget, frameClock gdk.FrameClock) bool

//export cTickCallback
func cTickCallback(arg0 *C.GtkWidget, arg1 *C.GdkFrameClock, arg2 C.gpointer) C.gboolean

type TreeCellDataFunc func(treeColumn TreeViewColumn, cell CellRenderer, treeModel TreeModel, iter *TreeIter)

//export cTreeCellDataFunc
func cTreeCellDataFunc(arg0 *C.GtkTreeViewColumn, arg1 *C.GtkCellRenderer, arg2 *C.GtkTreeModel, arg3 *C.GtkTreeIter, arg4 C.gpointer)

type TreeIterCompareFunc func(model TreeModel, a *TreeIter, b *TreeIter) int

//export cTreeIterCompareFunc
func cTreeIterCompareFunc(arg0 *C.GtkTreeModel, arg1 *C.GtkTreeIter, arg2 *C.GtkTreeIter, arg3 C.gpointer) C.int

type TreeListModelCreateModelFunc func(item interface{}) gio.ListModel

//export cTreeListModelCreateModelFunc
func cTreeListModelCreateModelFunc(arg0 C.gpointer, arg1 C.gpointer) *C.GListModel

type TreeModelFilterModifyFunc func(model TreeModel, iter *TreeIter, column int) externglib.Value

//export cTreeModelFilterModifyFunc
func cTreeModelFilterModifyFunc(arg0 *C.GtkTreeModel, arg1 *C.GtkTreeIter, arg2 *C.GValue, arg3 C.int, arg4 C.gpointer)

type TreeModelFilterVisibleFunc func(model TreeModel, iter *TreeIter) bool

//export cTreeModelFilterVisibleFunc
func cTreeModelFilterVisibleFunc(arg0 *C.GtkTreeModel, arg1 *C.GtkTreeIter, arg2 C.gpointer) C.gboolean

type TreeModelForeachFunc func(model TreeModel, path *TreePath, iter *TreeIter) bool

//export cTreeModelForeachFunc
func cTreeModelForeachFunc(arg0 *C.GtkTreeModel, arg1 *C.GtkTreePath, arg2 *C.GtkTreeIter, arg3 C.gpointer) C.gboolean

type TreeSelectionForeachFunc func(model TreeModel, path *TreePath, iter *TreeIter)

//export cTreeSelectionForeachFunc
func cTreeSelectionForeachFunc(arg0 *C.GtkTreeModel, arg1 *C.GtkTreePath, arg2 *C.GtkTreeIter, arg3 C.gpointer)

type TreeSelectionFunc func(selection TreeSelection, model TreeModel, path *TreePath, pathCurrentlySelected bool) bool

//export cTreeSelectionFunc
func cTreeSelectionFunc(arg0 *C.GtkTreeSelection, arg1 *C.GtkTreeModel, arg2 *C.GtkTreePath, arg3 C.gboolean, arg4 C.gpointer) C.gboolean

type TreeViewColumnDropFunc func(treeView TreeView, column TreeViewColumn, prevColumn TreeViewColumn, nextColumn TreeViewColumn) bool

//export cTreeViewColumnDropFunc
func cTreeViewColumnDropFunc(arg0 *C.GtkTreeView, arg1 *C.GtkTreeViewColumn, arg2 *C.GtkTreeViewColumn, arg3 *C.GtkTreeViewColumn, arg4 C.gpointer) C.gboolean

type TreeViewMappingFunc func(treeView TreeView, path *TreePath)

//export cTreeViewMappingFunc
func cTreeViewMappingFunc(arg0 *C.GtkTreeView, arg1 *C.GtkTreePath, arg2 C.gpointer)

type TreeViewRowSeparatorFunc func(model TreeModel, iter *TreeIter) bool

//export cTreeViewRowSeparatorFunc
func cTreeViewRowSeparatorFunc(arg0 *C.GtkTreeModel, arg1 *C.GtkTreeIter, arg2 C.gpointer) C.gboolean

type TreeViewSearchEqualFunc func(model TreeModel, column int, key string, iter *TreeIter) bool

//export cTreeViewSearchEqualFunc
func cTreeViewSearchEqualFunc(arg0 *C.GtkTreeModel, arg1 C.int, arg2 *C.char, arg3 *C.GtkTreeIter, arg4 C.gpointer) C.gboolean

type WidgetActionActivateFunc func(widget Widget, actionName string, parameter *glib.Variant)

//export cWidgetActionActivateFunc
func cWidgetActionActivateFunc(arg0 *C.GtkWidget, arg1 *C.char, arg2 *C.GVariant)

// AcceleratorGetDefaultModMask: gets the modifier mask.
//
// The modifier mask determines which modifiers are considered significant for
// keyboard accelerators. This includes all keyboard modifiers except for
// GDK_LOCK_MASK.
func AcceleratorGetDefaultModMask() gdk.ModifierType {
	ret := C.gtk_accelerator_get_default_mod_mask()

	var ret0 gdk.ModifierType
	ret0 = ModifierType(ret)

	return ret0
}

// AcceleratorGetLabel: converts an accelerator keyval and modifier mask into a
// string which can be used to represent the accelerator to the user.
func AcceleratorGetLabel(acceleratorKey uint, acceleratorMods gdk.ModifierType) string {
	var arg0 uint
	arg0 = uint(acceleratorKey)

	var arg1 gdk.ModifierType
	arg1 = ModifierType(acceleratorMods)

	ret := C.gtk_accelerator_get_label(arg0, arg1)

	var ret0 string
	ret0 = C.GoString(ret)
	defer C.free(unsafe.Pointer(ret))

	return ret0
}

// AcceleratorGetLabelWithKeycode: converts an accelerator keyval and modifier
// mask into a (possibly translated) string that can be displayed to a user,
// similarly to gtk_accelerator_get_label(), but handling keycodes.
//
// This is only useful for system-level components, applications should use
// gtk_accelerator_parse() instead.
func AcceleratorGetLabelWithKeycode(display gdk.Display, acceleratorKey uint, keycode uint, acceleratorMods gdk.ModifierType) string {
	var arg0 gdk.Display
	arg0 = wrapDisplay(display)

	var arg1 uint
	arg1 = uint(acceleratorKey)

	var arg2 uint
	arg2 = uint(keycode)

	var arg3 gdk.ModifierType
	arg3 = ModifierType(acceleratorMods)

	ret := C.gtk_accelerator_get_label_with_keycode(arg0, arg1, arg2, arg3)

	var ret0 string
	ret0 = C.GoString(ret)
	defer C.free(unsafe.Pointer(ret))

	return ret0
}

// AcceleratorName: converts an accelerator keyval and modifier mask into a
// string parseable by gtk_accelerator_parse(). For example, if you pass in
// K_KEY_q and K_CONTROL_MASK, this function returns “<Control>q”.
//
// If you need to display accelerators in the user interface, see
// gtk_accelerator_get_label().
func AcceleratorName(acceleratorKey uint, acceleratorMods gdk.ModifierType) string {
	var arg0 uint
	arg0 = uint(acceleratorKey)

	var arg1 gdk.ModifierType
	arg1 = ModifierType(acceleratorMods)

	ret := C.gtk_accelerator_name(arg0, arg1)

	var ret0 string
	ret0 = C.GoString(ret)
	defer C.free(unsafe.Pointer(ret))

	return ret0
}

// AcceleratorNameWithKeycode: converts an accelerator keyval and modifier mask
// into a string parseable by gtk_accelerator_parse_with_keycode(), similarly to
// gtk_accelerator_name() but handling keycodes. This is only useful for
// system-level components, applications should use gtk_accelerator_parse()
// instead.
func AcceleratorNameWithKeycode(display gdk.Display, acceleratorKey uint, keycode uint, acceleratorMods gdk.ModifierType) string {
	var arg0 gdk.Display
	arg0 = wrapDisplay(display)

	var arg1 uint
	arg1 = uint(acceleratorKey)

	var arg2 uint
	arg2 = uint(keycode)

	var arg3 gdk.ModifierType
	arg3 = ModifierType(acceleratorMods)

	ret := C.gtk_accelerator_name_with_keycode(arg0, arg1, arg2, arg3)

	var ret0 string
	ret0 = C.GoString(ret)
	defer C.free(unsafe.Pointer(ret))

	return ret0
}

// AcceleratorParse: parses a string representing an accelerator. The format
// looks like “<Control>a” or “<Shift><Alt>F1”.
//
// The parser is fairly liberal and allows lower or upper case, and also
// abbreviations such as “<Ctl>” and “<Ctrl>”. Key names are parsed using
// gdk_keyval_from_name(). For character keys the name is not the symbol, but
// the lowercase name, e.g. one would use “<Ctrl>minus” instead of “<Ctrl>-”.
//
// If the parse fails, @accelerator_key and @accelerator_mods will be set to 0
// (zero).
func AcceleratorParse(accelerator string) (acceleratorKey uint, acceleratorMods gdk.ModifierType, ok bool) {
	var arg0 string
	arg0 = C.GoString(accelerator)
	defer C.free(unsafe.Pointer(accelerator))

	var arg1 *C.guint // out

	var arg2 *C.GdkModifierType // out

	ret := C.gtk_accelerator_parse(arg0, &arg1, &arg2)

	var ret0 uint
	ret0 = uint(arg1)

	var ret1 *gdk.ModifierType
	ret1 = ModifierType(arg2)

	var ret2 bool
	ret2 = gextras.Gobool(ret)

	return ret0, ret1, ret2
}

// AcceleratorParseWithKeycode: parses a string representing an accelerator,
// similarly to gtk_accelerator_parse() but handles keycodes as well. This is
// only useful for system-level components, applications should use
// gtk_accelerator_parse() instead.
//
// If @accelerator_codes is given and the result stored in it is non-nil, the
// result must be freed with g_free().
//
// If a keycode is present in the accelerator and no @accelerator_codes is
// given, the parse will fail.
//
// If the parse fails, @accelerator_key, @accelerator_mods and
// @accelerator_codes will be set to 0 (zero).
func AcceleratorParseWithKeycode(accelerator string, display gdk.Display) (acceleratorKey uint, acceleratorCodes []uint, acceleratorMods gdk.ModifierType, ok bool) {
	var arg0 string
	arg0 = C.GoString(accelerator)
	defer C.free(unsafe.Pointer(accelerator))

	var arg1 gdk.Display
	arg1 = wrapDisplay(display)

	var arg2 *C.guint // out

	var arg3 **C.guint // out

	var arg4 *C.GdkModifierType // out

	ret := C.gtk_accelerator_parse_with_keycode(arg0, arg1, &arg2, &arg3, &arg4)

	var ret0 uint
	ret0 = uint(arg2)

	var ret1 []uint
	ret1 = ([0]uint)(arg3)

	var ret2 *gdk.ModifierType
	ret2 = ModifierType(arg4)

	var ret3 bool
	ret3 = gextras.Gobool(ret)

	return ret0, ret1, ret2, ret3
}

// AcceleratorValid: determines whether a given keyval and modifier mask
// constitute a valid keyboard accelerator. For example, the K_KEY_a keyval plus
// K_CONTROL_MASK is valid - this is a “Ctrl+a” accelerator. But, you can't, for
// instance, use the K_KEY_Control_L keyval as an accelerator.
func AcceleratorValid(keyval uint, modifiers gdk.ModifierType) bool {
	var arg0 uint
	arg0 = uint(keyval)

	var arg1 gdk.ModifierType
	arg1 = ModifierType(modifiers)

	ret := C.gtk_accelerator_valid(arg0, arg1)

	var ret0 bool
	ret0 = gextras.Gobool(ret)

	return ret0
}

func AccessiblePropertyInitValue(property AccessibleProperty, value *externglib.Value) {
	var arg0 AccessibleProperty
	arg0 = AccessibleProperty(property)

	C.gtk_accessible_property_init_value(arg0)
}

func AccessibleRelationInitValue(relation AccessibleRelation, value *externglib.Value) {
	var arg0 AccessibleRelation
	arg0 = AccessibleRelation(relation)

	C.gtk_accessible_relation_init_value(arg0)
}

func AccessibleStateInitValue(state AccessibleState, value *externglib.Value) {
	var arg0 AccessibleState
	arg0 = AccessibleState(state)

	C.gtk_accessible_state_init_value(arg0)
}

// BitsetIterInitAt: initializes @iter to point to @target. If @target is not
// found, finds the next value after it. If no value >= @target exists in @set,
// this function returns false.
func BitsetIterInitAt(set *Bitset, target uint) (iter BitsetIter, value uint, ok bool) {
	var arg0 *C.GtkBitsetIter // out

	var arg1 *Bitset
	arg1 = wrapBitset(set)

	var arg2 uint
	arg2 = uint(target)

	var arg3 *C.guint // out

	ret := C.gtk_bitset_iter_init_at(&arg0, arg1, arg2, &arg3)

	var ret0 *BitsetIter
	ret0 = wrapBitsetIter(arg0)

	var ret1 uint
	ret1 = uint(arg3)

	var ret2 bool
	ret2 = gextras.Gobool(ret)

	return ret0, ret1, ret2
}

// BitsetIterInitFirst: initializes an iterator for @set and points it to the
// first value in @set. If @set is empty, false is returned and @value is set to
// G_MAXUINT.
func BitsetIterInitFirst(set *Bitset) (iter BitsetIter, value uint, ok bool) {
	var arg0 *C.GtkBitsetIter // out

	var arg1 *Bitset
	arg1 = wrapBitset(set)

	var arg2 *C.guint // out

	ret := C.gtk_bitset_iter_init_first(&arg0, arg1, &arg2)

	var ret0 *BitsetIter
	ret0 = wrapBitsetIter(arg0)

	var ret1 uint
	ret1 = uint(arg2)

	var ret2 bool
	ret2 = gextras.Gobool(ret)

	return ret0, ret1, ret2
}

// BitsetIterInitLast: initializes an iterator for @set and points it to the
// last value in @set. If @set is empty, false is returned.
func BitsetIterInitLast(set *Bitset) (iter BitsetIter, value uint, ok bool) {
	var arg0 *C.GtkBitsetIter // out

	var arg1 *Bitset
	arg1 = wrapBitset(set)

	var arg2 *C.guint // out

	ret := C.gtk_bitset_iter_init_last(&arg0, arg1, &arg2)

	var ret0 *BitsetIter
	ret0 = wrapBitsetIter(arg0)

	var ret1 uint
	ret1 = uint(arg2)

	var ret2 bool
	ret2 = gextras.Gobool(ret)

	return ret0, ret1, ret2
}

func BuilderErrorQuark() glib.Quark {
	ret := C.gtk_builder_error_quark()

	var ret0 glib.Quark
	{
		tmp := uint32(ret)
		ret0 = Quark(tmp)
	}

	return ret0
}

// CheckVersion: checks that the GTK library in use is compatible with the given
// version. Generally you would pass in the constants GTK_MAJOR_VERSION,
// GTK_MINOR_VERSION, GTK_MICRO_VERSION as the three arguments to this function;
// that produces a check that the library in use is compatible with the version
// of GTK the application or module was compiled against.
//
// Compatibility is defined by two things: first the version of the running
// library is newer than the version
// @required_major.required_minor.@required_micro. Second the running library
// must be binary compatible with the version
// @required_major.required_minor.@required_micro (same major version.)
//
// This function is primarily for GTK modules; the module can call this function
// to check that it wasn’t loaded into an incompatible version of GTK. However,
// such a check isn’t completely reliable, since the module may be linked
// against an old version of GTK and calling the old version of
// gtk_check_version(), but still get loaded into an application using a newer
// version of GTK.
func CheckVersion(requiredMajor uint, requiredMinor uint, requiredMicro uint) string {
	var arg0 uint
	arg0 = uint(requiredMajor)

	var arg1 uint
	arg1 = uint(requiredMinor)

	var arg2 uint
	arg2 = uint(requiredMicro)

	ret := C.gtk_check_version(arg0, arg1, arg2)

	var ret0 string
	ret0 = C.GoString(ret)
	defer C.free(unsafe.Pointer(ret))

	return ret0
}

func ConstraintVflParserErrorQuark() glib.Quark {
	ret := C.gtk_constraint_vfl_parser_error_quark()

	var ret0 glib.Quark
	{
		tmp := uint32(ret)
		ret0 = Quark(tmp)
	}

	return ret0
}

func CSSParserErrorQuark() glib.Quark {
	ret := C.gtk_css_parser_error_quark()

	var ret0 glib.Quark
	{
		tmp := uint32(ret)
		ret0 = Quark(tmp)
	}

	return ret0
}

func CSSParserWarningQuark() glib.Quark {
	ret := C.gtk_css_parser_warning_quark()

	var ret0 glib.Quark
	{
		tmp := uint32(ret)
		ret0 = Quark(tmp)
	}

	return ret0
}

// DisableSetlocale: prevents gtk_init(), gtk_init_check() and gtk_parse_args()
// from automatically calling `setlocale (LC_ALL, "")`. You would want to use
// this function if you wanted to set the locale for your program to something
// other than the user’s locale, or if you wanted to set different values for
// different locale categories.
//
// Most programs should not need to call this function.
func DisableSetlocale() {
	C.gtk_disable_setlocale()
}

// DistributeNaturalAllocation: distributes @extra_space to child @sizes by
// bringing smaller children up to natural size first.
//
// The remaining space will be added to the @minimum_size member of the
// GtkRequestedSize struct. If all sizes reach their natural size then the
// remaining space is returned.
func DistributeNaturalAllocation(extraSpace int, nRequestedSizes uint, sizes *RequestedSize) int {
	var arg0 int
	arg0 = int(extraSpace)

	var arg1 uint
	arg1 = uint(nRequestedSizes)

	var arg2 *RequestedSize
	arg2 = wrapRequestedSize(sizes)

	ret := C.gtk_distribute_natural_allocation(arg0, arg1, arg2)

	var ret0 int
	ret0 = int(ret)

	return ret0
}

// FileChooserErrorQuark: registers an error quark for FileChooser if necessary.
func FileChooserErrorQuark() glib.Quark {
	ret := C.gtk_file_chooser_error_quark()

	var ret0 glib.Quark
	{
		tmp := uint32(ret)
		ret0 = Quark(tmp)
	}

	return ret0
}

// GetBinaryAge: returns the binary age as passed to `libtool` when building the
// GTK library the process is running against. If `libtool` means nothing to
// you, don't worry about it.
func GetBinaryAge() uint {
	ret := C.gtk_get_binary_age()

	var ret0 uint
	ret0 = uint(ret)

	return ret0
}

// GetDebugFlags: returns the GTK debug flags that are currently active.
//
// This function is intended for GTK modules that want to adjust their debug
// output based on GTK debug flags.
func GetDebugFlags() DebugFlags {
	ret := C.gtk_get_debug_flags()

	var ret0 DebugFlags
	ret0 = DebugFlags(ret)

	return ret0
}

// GetDefaultLanguage: returns the Language for the default language currently
// in effect. (Note that this can change over the life of an application.) The
// default language is derived from the current locale. It determines, for
// example, whether GTK uses the right-to-left or left-to-right text direction.
//
// This function is equivalent to pango_language_get_default(). See that
// function for details.
func GetDefaultLanguage() *pango.Language {
	ret := C.gtk_get_default_language()

	var ret0 *pango.Language
	ret0 = wrapLanguage(ret)

	return ret0
}

// GetInterfaceAge: returns the interface age as passed to `libtool` when
// building the GTK library the process is running against. If `libtool` means
// nothing to you, don't worry about it.
func GetInterfaceAge() uint {
	ret := C.gtk_get_interface_age()

	var ret0 uint
	ret0 = uint(ret)

	return ret0
}

// GetLocaleDirection: get the direction of the current locale. This is the
// expected reading direction for text and UI.
//
// This function depends on the current locale being set with setlocale() and
// will default to setting the GTK_TEXT_DIR_LTR direction otherwise.
// GTK_TEXT_DIR_NONE will never be returned.
//
// GTK sets the default text direction according to the locale during
// gtk_init(), and you should normally use gtk_widget_get_direction() or
// gtk_widget_get_default_direction() to obtain the current direction.
//
// This function is only needed rare cases when the locale is changed after GTK
// has already been initialized. In this case, you can use it to update the
// default text direction as follows:
//
//    setlocale (LC_ALL, new_locale);
//    direction = gtk_get_locale_direction ();
//    gtk_widget_set_default_direction (direction);
func GetLocaleDirection() TextDirection {
	ret := C.gtk_get_locale_direction()

	var ret0 TextDirection
	ret0 = TextDirection(ret)

	return ret0
}

// GetMajorVersion: returns the major version number of the GTK library. (e.g.
// in GTK version 3.1.5 this is 3.)
//
// This function is in the library, so it represents the GTK library your code
// is running against. Contrast with the GTK_MAJOR_VERSION macro, which
// represents the major version of the GTK headers you have included when
// compiling your code.
func GetMajorVersion() uint {
	ret := C.gtk_get_major_version()

	var ret0 uint
	ret0 = uint(ret)

	return ret0
}

// GetMicroVersion: returns the micro version number of the GTK library. (e.g.
// in GTK version 3.1.5 this is 5.)
//
// This function is in the library, so it represents the GTK library your code
// is are running against. Contrast with the GTK_MICRO_VERSION macro, which
// represents the micro version of the GTK headers you have included when
// compiling your code.
func GetMicroVersion() uint {
	ret := C.gtk_get_micro_version()

	var ret0 uint
	ret0 = uint(ret)

	return ret0
}

// GetMinorVersion: returns the minor version number of the GTK library. (e.g.
// in GTK version 3.1.5 this is 1.)
//
// This function is in the library, so it represents the GTK library your code
// is are running against. Contrast with the GTK_MINOR_VERSION macro, which
// represents the minor version of the GTK headers you have included when
// compiling your code.
func GetMinorVersion() uint {
	ret := C.gtk_get_minor_version()

	var ret0 uint
	ret0 = uint(ret)

	return ret0
}

// HSVToRGB: converts a color from HSV space to RGB.
//
// Input values must be in the [0.0, 1.0] range; output values will be in the
// same range.
func HSVToRGB(h float32, s float32, v float32) (r float32, g float32, b float32) {
	var arg0 float32
	arg0 = float32(h)

	var arg1 float32
	arg1 = float32(s)

	var arg2 float32
	arg2 = float32(v)

	var arg3 *C.float // out

	var arg4 *C.float // out

	var arg5 *C.float // out

	ret := C.gtk_hsv_to_rgb(arg0, arg1, arg2, &arg3, &arg4, &arg5)

	var ret0 float32
	ret0 = float32(arg3)

	var ret1 float32
	ret1 = float32(arg4)

	var ret2 float32
	ret2 = float32(arg5)

	return ret0, ret1, ret2
}

func IconThemeErrorQuark() glib.Quark {
	ret := C.gtk_icon_theme_error_quark()

	var ret0 glib.Quark
	{
		tmp := uint32(ret)
		ret0 = Quark(tmp)
	}

	return ret0
}

func ImModulesInit() {
	C.gtk_im_modules_init()
}

// Init: call this function before using any other GTK functions in your GUI
// applications. It will initialize everything needed to operate the toolkit and
// parses some standard command line options.
//
// If you are using Application, you don't have to call gtk_init() or
// gtk_init_check(); the #GApplication::startup handler does it for you.
//
// This function will terminate your program if it was unable to initialize the
// windowing system for some reason. If you want your program to fall back to a
// textual interface you want to call gtk_init_check() instead.
//
// GTK calls `signal (SIGPIPE, SIG_IGN)` during initialization, to ignore
// SIGPIPE signals, since these are almost never wanted in graphical
// applications. If you do need to handle SIGPIPE for some reason, reset the
// handler after gtk_init(), but notice that other libraries (e.g. libdbus or
// gvfs) might do similar things.
func Init() {
	C.gtk_init()
}

// InitCheck: this function does the same work as gtk_init() with only a single
// change: It does not terminate the program if the windowing system can’t be
// initialized. Instead it returns false on failure.
//
// This way the application can fall back to some other means of communication
// with the user - for example a curses or command line interface.
func InitCheck() bool {
	ret := C.gtk_init_check()

	var ret0 bool
	ret0 = gextras.Gobool(ret)

	return ret0
}

// IsInitialized: use this function to check if GTK has been initialized with
// gtk_init() or gtk_init_check().
func IsInitialized() bool {
	ret := C.gtk_is_initialized()

	var ret0 bool
	ret0 = gextras.Gobool(ret)

	return ret0
}

// NativeGetForSurface: finds the GtkNative associated with the surface.
func NativeGetForSurface(surface gdk.Surface) Native {
	var arg0 gdk.Surface
	arg0 = wrapSurface(surface)

	ret := C.gtk_native_get_for_surface(arg0)

	var ret0 Native
	ret0 = wrapNative(ret)

	return ret0
}

// PaperSizeGetDefault: returns the name of the default paper size, which
// depends on the current locale.
func PaperSizeGetDefault() string {
	ret := C.gtk_paper_size_get_default()

	var ret0 string
	ret0 = C.GoString(ret)
	defer C.free(unsafe.Pointer(ret))

	return ret0
}

// PaperSizeGetPaperSizes: creates a list of known paper sizes.
func PaperSizeGetPaperSizes(includeCustom bool) *glib.List {
	var arg0 bool
	arg0 = gextras.Gobool(includeCustom)

	ret := C.gtk_paper_size_get_paper_sizes(arg0)

	var ret0 *glib.List
	ret0 = wrapList(ret)

	return ret0
}

// PrintErrorQuark: registers an error quark for PrintOperation if necessary.
func PrintErrorQuark() glib.Quark {
	ret := C.gtk_print_error_quark()

	var ret0 glib.Quark
	{
		tmp := uint32(ret)
		ret0 = Quark(tmp)
	}

	return ret0
}

// PrintRunPageSetupDialog: runs a page setup dialog, letting the user modify
// the values from @page_setup. If the user cancels the dialog, the returned
// PageSetup is identical to the passed in @page_setup, otherwise it contains
// the modifications done in the dialog.
//
// Note that this function may use a recursive mainloop to show the page setup
// dialog. See gtk_print_run_page_setup_dialog_async() if this is a problem.
func PrintRunPageSetupDialog(parent Window, pageSetup PageSetup, settings PrintSettings) PageSetup {
	var arg0 Window
	arg0 = wrapWindow(parent)

	var arg1 PageSetup
	arg1 = wrapPageSetup(pageSetup)

	var arg2 PrintSettings
	arg2 = wrapPrintSettings(settings)

	ret := C.gtk_print_run_page_setup_dialog(arg0, arg1, arg2)

	var ret0 PageSetup
	ret0 = wrapPageSetup(ret)

	return ret0
}

// PrintRunPageSetupDialogAsync: runs a page setup dialog, letting the user
// modify the values from @page_setup.
//
// In contrast to gtk_print_run_page_setup_dialog(), this function returns after
// showing the page setup dialog on platforms that support this, and calls
// @done_cb from a signal handler for the ::response signal of the dialog.
func PrintRunPageSetupDialogAsync(parent Window, pageSetup PageSetup, settings PrintSettings, doneCb PageSetupDoneFunc) {
	var arg0 Window
	arg0 = wrapWindow(parent)

	var arg1 PageSetup
	arg1 = wrapPageSetup(pageSetup)

	var arg2 PrintSettings
	arg2 = wrapPrintSettings(settings)

	var arg3 PageSetupDoneFunc
	arg3 = wrapPageSetupDoneFunc(doneCb)

	C.gtk_print_run_page_setup_dialog_async(arg0, arg1, arg2, arg3)
}

func RecentManagerErrorQuark() glib.Quark {
	ret := C.gtk_recent_manager_error_quark()

	var ret0 glib.Quark
	{
		tmp := uint32(ret)
		ret0 = Quark(tmp)
	}

	return ret0
}

// RenderActivity: renders an activity indicator (such as in Spinner). The state
// GTK_STATE_FLAG_CHECKED determines whether there is activity going on.
func RenderActivity(context StyleContext, cr *cairo.Context, x float64, y float64, width float64, height float64) {
	var arg0 StyleContext
	arg0 = wrapStyleContext(context)

	var arg1 *cairo.Context
	arg1 = wrapContext(cr)

	var arg2 float64
	arg2 = float64(x)

	var arg3 float64
	arg3 = float64(y)

	var arg4 float64
	arg4 = float64(width)

	var arg5 float64
	arg5 = float64(height)

	C.gtk_render_activity(arg0, arg1, arg2, arg3, arg4, arg5)
}

// RenderArrow: renders an arrow pointing to @angle.
//
// Typical arrow rendering at 0, 1⁄2 π;, π; and 3⁄2 π:
//
// ![](arrows.png)
func RenderArrow(context StyleContext, cr *cairo.Context, angle float64, x float64, y float64, size float64) {
	var arg0 StyleContext
	arg0 = wrapStyleContext(context)

	var arg1 *cairo.Context
	arg1 = wrapContext(cr)

	var arg2 float64
	arg2 = float64(angle)

	var arg3 float64
	arg3 = float64(x)

	var arg4 float64
	arg4 = float64(y)

	var arg5 float64
	arg5 = float64(size)

	C.gtk_render_arrow(arg0, arg1, arg2, arg3, arg4, arg5)
}

// RenderBackground: renders the background of an element.
//
// Typical background rendering, showing the effect of `background-image`,
// `border-width` and `border-radius`:
//
// ![](background.png)
func RenderBackground(context StyleContext, cr *cairo.Context, x float64, y float64, width float64, height float64) {
	var arg0 StyleContext
	arg0 = wrapStyleContext(context)

	var arg1 *cairo.Context
	arg1 = wrapContext(cr)

	var arg2 float64
	arg2 = float64(x)

	var arg3 float64
	arg3 = float64(y)

	var arg4 float64
	arg4 = float64(width)

	var arg5 float64
	arg5 = float64(height)

	C.gtk_render_background(arg0, arg1, arg2, arg3, arg4, arg5)
}

// RenderCheck: renders a checkmark (as in a CheckButton).
//
// The GTK_STATE_FLAG_CHECKED state determines whether the check is on or off,
// and GTK_STATE_FLAG_INCONSISTENT determines whether it should be marked as
// undefined.
//
// Typical checkmark rendering:
//
// ![](checks.png)
func RenderCheck(context StyleContext, cr *cairo.Context, x float64, y float64, width float64, height float64) {
	var arg0 StyleContext
	arg0 = wrapStyleContext(context)

	var arg1 *cairo.Context
	arg1 = wrapContext(cr)

	var arg2 float64
	arg2 = float64(x)

	var arg3 float64
	arg3 = float64(y)

	var arg4 float64
	arg4 = float64(width)

	var arg5 float64
	arg5 = float64(height)

	C.gtk_render_check(arg0, arg1, arg2, arg3, arg4, arg5)
}

// RenderExpander: renders an expander (as used in TreeView and Expander) in the
// area defined by @x, @y, @width, @height. The state GTK_STATE_FLAG_CHECKED
// determines whether the expander is collapsed or expanded.
//
// Typical expander rendering:
//
// ![](expanders.png)
func RenderExpander(context StyleContext, cr *cairo.Context, x float64, y float64, width float64, height float64) {
	var arg0 StyleContext
	arg0 = wrapStyleContext(context)

	var arg1 *cairo.Context
	arg1 = wrapContext(cr)

	var arg2 float64
	arg2 = float64(x)

	var arg3 float64
	arg3 = float64(y)

	var arg4 float64
	arg4 = float64(width)

	var arg5 float64
	arg5 = float64(height)

	C.gtk_render_expander(arg0, arg1, arg2, arg3, arg4, arg5)
}

// RenderFocus: renders a focus indicator on the rectangle determined by @x, @y,
// @width, @height.
//
// Typical focus rendering:
//
// ![](focus.png)
func RenderFocus(context StyleContext, cr *cairo.Context, x float64, y float64, width float64, height float64) {
	var arg0 StyleContext
	arg0 = wrapStyleContext(context)

	var arg1 *cairo.Context
	arg1 = wrapContext(cr)

	var arg2 float64
	arg2 = float64(x)

	var arg3 float64
	arg3 = float64(y)

	var arg4 float64
	arg4 = float64(width)

	var arg5 float64
	arg5 = float64(height)

	C.gtk_render_focus(arg0, arg1, arg2, arg3, arg4, arg5)
}

// RenderFrame: renders a frame around the rectangle defined by @x, @y, @width,
// @height.
//
// Examples of frame rendering, showing the effect of `border-image`,
// `border-color`, `border-width`, `border-radius` and junctions:
//
// ![](frames.png)
func RenderFrame(context StyleContext, cr *cairo.Context, x float64, y float64, width float64, height float64) {
	var arg0 StyleContext
	arg0 = wrapStyleContext(context)

	var arg1 *cairo.Context
	arg1 = wrapContext(cr)

	var arg2 float64
	arg2 = float64(x)

	var arg3 float64
	arg3 = float64(y)

	var arg4 float64
	arg4 = float64(width)

	var arg5 float64
	arg5 = float64(height)

	C.gtk_render_frame(arg0, arg1, arg2, arg3, arg4, arg5)
}

// RenderHandle: renders a handle (as in Paned and Window’s resize grip), in the
// rectangle determined by @x, @y, @width, @height.
//
// Handles rendered for the paned and grip classes:
//
// ![](handles.png)
func RenderHandle(context StyleContext, cr *cairo.Context, x float64, y float64, width float64, height float64) {
	var arg0 StyleContext
	arg0 = wrapStyleContext(context)

	var arg1 *cairo.Context
	arg1 = wrapContext(cr)

	var arg2 float64
	arg2 = float64(x)

	var arg3 float64
	arg3 = float64(y)

	var arg4 float64
	arg4 = float64(width)

	var arg5 float64
	arg5 = float64(height)

	C.gtk_render_handle(arg0, arg1, arg2, arg3, arg4, arg5)
}

// RenderIcon: renders the icon in @texture at the specified @x and @y
// coordinates.
//
// This function will render the icon in @texture at exactly its size,
// regardless of scaling factors, which may not be appropriate when drawing on
// displays with high pixel densities.
func RenderIcon(context StyleContext, cr *cairo.Context, texture gdk.Texture, x float64, y float64) {
	var arg0 StyleContext
	arg0 = wrapStyleContext(context)

	var arg1 *cairo.Context
	arg1 = wrapContext(cr)

	var arg2 gdk.Texture
	arg2 = wrapTexture(texture)

	var arg3 float64
	arg3 = float64(x)

	var arg4 float64
	arg4 = float64(y)

	C.gtk_render_icon(arg0, arg1, arg2, arg3, arg4)
}

// RenderLayout: renders @layout on the coordinates @x, @y
func RenderLayout(context StyleContext, cr *cairo.Context, x float64, y float64, layout pango.Layout) {
	var arg0 StyleContext
	arg0 = wrapStyleContext(context)

	var arg1 *cairo.Context
	arg1 = wrapContext(cr)

	var arg2 float64
	arg2 = float64(x)

	var arg3 float64
	arg3 = float64(y)

	var arg4 pango.Layout
	arg4 = wrapLayout(layout)

	C.gtk_render_layout(arg0, arg1, arg2, arg3, arg4)
}

// RenderLine: renders a line from (x0, y0) to (x1, y1).
func RenderLine(context StyleContext, cr *cairo.Context, x0 float64, y0 float64, x1 float64, y1 float64) {
	var arg0 StyleContext
	arg0 = wrapStyleContext(context)

	var arg1 *cairo.Context
	arg1 = wrapContext(cr)

	var arg2 float64
	arg2 = float64(x0)

	var arg3 float64
	arg3 = float64(y0)

	var arg4 float64
	arg4 = float64(x1)

	var arg5 float64
	arg5 = float64(y1)

	C.gtk_render_line(arg0, arg1, arg2, arg3, arg4, arg5)
}

// RenderOption: renders an option mark (as in a radio button), the
// GTK_STATE_FLAG_CHECKED state will determine whether the option is on or off,
// and GTK_STATE_FLAG_INCONSISTENT whether it should be marked as undefined.
//
// Typical option mark rendering:
//
// ![](options.png)
func RenderOption(context StyleContext, cr *cairo.Context, x float64, y float64, width float64, height float64) {
	var arg0 StyleContext
	arg0 = wrapStyleContext(context)

	var arg1 *cairo.Context
	arg1 = wrapContext(cr)

	var arg2 float64
	arg2 = float64(x)

	var arg3 float64
	arg3 = float64(y)

	var arg4 float64
	arg4 = float64(width)

	var arg5 float64
	arg5 = float64(height)

	C.gtk_render_option(arg0, arg1, arg2, arg3, arg4, arg5)
}

// RGBToHSV: converts a color from RGB space to HSV.
//
// Input values must be in the [0.0, 1.0] range; output values will be in the
// same range.
func RGBToHSV(r float32, g float32, b float32) (h float32, s float32, v float32) {
	var arg0 float32
	arg0 = float32(r)

	var arg1 float32
	arg1 = float32(g)

	var arg2 float32
	arg2 = float32(b)

	var arg3 *C.float // out

	var arg4 *C.float // out

	var arg5 *C.float // out

	ret := C.gtk_rgb_to_hsv(arg0, arg1, arg2, &arg3, &arg4, &arg5)

	var ret0 float32
	ret0 = float32(arg3)

	var ret1 float32
	ret1 = float32(arg4)

	var ret2 float32
	ret2 = float32(arg5)

	return ret0, ret1, ret2
}

// SetDebugFlags: sets the GTK debug flags.
func SetDebugFlags(flags DebugFlags) {
	var arg0 DebugFlags
	arg0 = DebugFlags(flags)

	C.gtk_set_debug_flags(arg0)
}

// ShowURI: this function launches the default application for showing a given
// uri, or shows an error dialog if that fails.
func ShowURI(parent Window, uri string, timestamp uint32) {
	var arg0 Window
	arg0 = wrapWindow(parent)

	var arg1 string
	arg1 = C.GoString(uri)
	defer C.free(unsafe.Pointer(uri))

	var arg2 uint32
	arg2 = uint32(timestamp)

	C.gtk_show_uri(arg0, arg1, arg2)
}

// ShowURIFull: this function launches the default application for showing a
// given uri.
//
// The @callback will be called when the launch is completed. It should call
// gtk_show_uri_full_finish() to obtain the result.
//
// This is the recommended call to be used as it passes information necessary
// for sandbox helpers to parent their dialogs properly.
func ShowURIFull(parent Window, uri string, timestamp uint32, cancellable gio.Cancellable, callback gio.AsyncReadyCallback) {
	var arg0 Window
	arg0 = wrapWindow(parent)

	var arg1 string
	arg1 = C.GoString(uri)
	defer C.free(unsafe.Pointer(uri))

	var arg2 uint32
	arg2 = uint32(timestamp)

	var arg3 gio.Cancellable
	arg3 = wrapCancellable(cancellable)

	var arg4 gio.AsyncReadyCallback
	arg4 = wrapAsyncReadyCallback(callback)

	C.gtk_show_uri_full(arg0, arg1, arg2, arg3, arg4)
}

// ShowURIFullFinish: finishes the gtk_show_uri() call and returns the result of
// the operation.
func ShowURIFullFinish(parent Window, result gio.AsyncResult) bool {
	var arg0 Window
	arg0 = wrapWindow(parent)

	var arg1 gio.AsyncResult
	arg1 = wrapAsyncResult(result)

	ret := C.gtk_show_uri_full_finish(arg0, arg1)

	var ret0 bool
	ret0 = gextras.Gobool(ret)

	return ret0
}

func TestAccessibleAssertionMessageRole(domain string, file string, line int, _func string, expr string, accessible Accessible, expectedRole AccessibleRole, actualRole AccessibleRole) {
	var arg0 string
	arg0 = C.GoString(domain)
	defer C.free(unsafe.Pointer(domain))

	var arg1 string
	arg1 = C.GoString(file)
	defer C.free(unsafe.Pointer(file))

	var arg2 int
	arg2 = int(line)

	var arg3 string
	arg3 = C.GoString(_func)
	defer C.free(unsafe.Pointer(_func))

	var arg4 string
	arg4 = C.GoString(expr)
	defer C.free(unsafe.Pointer(expr))

	var arg5 Accessible
	arg5 = wrapAccessible(accessible)

	var arg6 AccessibleRole
	arg6 = AccessibleRole(expectedRole)

	var arg7 AccessibleRole
	arg7 = AccessibleRole(actualRole)

	C.gtk_test_accessible_assertion_message_role(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7)
}

// TestAccessibleHasProperty: checks whether the Accessible has @property set.
func TestAccessibleHasProperty(accessible Accessible, property AccessibleProperty) bool {
	var arg0 Accessible
	arg0 = wrapAccessible(accessible)

	var arg1 AccessibleProperty
	arg1 = AccessibleProperty(property)

	ret := C.gtk_test_accessible_has_property(arg0, arg1)

	var ret0 bool
	ret0 = gextras.Gobool(ret)

	return ret0
}

// TestAccessibleHasRelation: checks whether the Accessible has @relation set.
func TestAccessibleHasRelation(accessible Accessible, relation AccessibleRelation) bool {
	var arg0 Accessible
	arg0 = wrapAccessible(accessible)

	var arg1 AccessibleRelation
	arg1 = AccessibleRelation(relation)

	ret := C.gtk_test_accessible_has_relation(arg0, arg1)

	var ret0 bool
	ret0 = gextras.Gobool(ret)

	return ret0
}

// TestAccessibleHasRole: checks whether the Accessible:accessible-role of the
// accessible is @role.
func TestAccessibleHasRole(accessible Accessible, role AccessibleRole) bool {
	var arg0 Accessible
	arg0 = wrapAccessible(accessible)

	var arg1 AccessibleRole
	arg1 = AccessibleRole(role)

	ret := C.gtk_test_accessible_has_role(arg0, arg1)

	var ret0 bool
	ret0 = gextras.Gobool(ret)

	return ret0
}

// TestAccessibleHasState: checks whether the Accessible has @state set.
func TestAccessibleHasState(accessible Accessible, state AccessibleState) bool {
	var arg0 Accessible
	arg0 = wrapAccessible(accessible)

	var arg1 AccessibleState
	arg1 = AccessibleState(state)

	ret := C.gtk_test_accessible_has_state(arg0, arg1)

	var ret0 bool
	ret0 = gextras.Gobool(ret)

	return ret0
}

// TestListAllTypes: return the type ids that have been registered after calling
// gtk_test_register_all_types().
func TestListAllTypes() (nTypes uint, gTypes []externglib.Type) {
	var arg0 *C.guint // out

	ret := C.gtk_test_list_all_types(&arg0)

	var ret0 uint
	ret0 = uint(arg0)

	var ret1 []externglib.Type

	return ret0, ret1
}

// TestRegisterAllTypes: force registration of all core GTK object types.
//
// This allowes to refer to any of those object types via g_type_from_name()
// after calling this function.
func TestRegisterAllTypes() {
	C.gtk_test_register_all_types()
}

// TestWidgetWaitForDraw: enters the main loop and waits for @widget to be
// “drawn”. In this context that means it waits for the frame clock of @widget
// to have run a full styling, layout and drawing cycle.
//
// This function is intended to be used for syncing with actions that depend on
// @widget relayouting or on interaction with the display server.
func TestWidgetWaitForDraw(widget Widget) {
	var arg0 Widget
	arg0 = wrapWidget(widget)

	C.gtk_test_widget_wait_for_draw(arg0)
}

// TreeCreateRowDragContent: creates a content provider for dragging @path from
// @tree_model.
func TreeCreateRowDragContent(treeModel TreeModel, path *TreePath) gdk.ContentProvider {
	var arg0 TreeModel
	arg0 = wrapTreeModel(treeModel)

	var arg1 *TreePath
	arg1 = wrapTreePath(path)

	ret := C.gtk_tree_create_row_drag_content(arg0, arg1)

	var ret0 gdk.ContentProvider
	ret0 = wrapContentProvider(ret)

	return ret0
}

// TreeGetRowDragData: obtains a @tree_model and @path from value of target type
// GTK_TYPE_TREE_ROW_DATA.
//
// The returned path must be freed with gtk_tree_path_free().
func TreeGetRowDragData(value *externglib.Value) (treeModel TreeModel, path *TreePath, ok bool) {
	var arg1 **C.GtkTreeModel // out

	var arg2 **C.GtkTreePath // out

	ret := C.gtk_tree_get_row_drag_data(&arg1, &arg2)

	var ret0 *TreeModel
	ret0 = wrapTreeModel(arg1)

	var ret1 **TreePath
	ret1 = wrapTreePath(arg2)

	var ret2 bool
	ret2 = gextras.Gobool(ret)

	return ret0, ret1, ret2
}

// TreeRowReferenceDeleted: lets a set of row reference created by
// gtk_tree_row_reference_new_proxy() know that the model emitted the
// TreeModel::row-deleted signal.
func TreeRowReferenceDeleted(proxy gextras.Objector, path *TreePath) {
	var arg0 gextras.Objector
	arg0 = glib.Take(proxy)

	var arg1 *TreePath
	arg1 = wrapTreePath(path)

	C.gtk_tree_row_reference_deleted(arg0, arg1)
}

// TreeRowReferenceInserted: lets a set of row reference created by
// gtk_tree_row_reference_new_proxy() know that the model emitted the
// TreeModel::row-inserted signal.
func TreeRowReferenceInserted(proxy gextras.Objector, path *TreePath) {
	var arg0 gextras.Objector
	arg0 = glib.Take(proxy)

	var arg1 *TreePath
	arg1 = wrapTreePath(path)

	C.gtk_tree_row_reference_inserted(arg0, arg1)
}

// TreeRowReferenceReordered: lets a set of row reference created by
// gtk_tree_row_reference_new_proxy() know that the model emitted the
// TreeModel::rows-reordered signal.
func TreeRowReferenceReordered(proxy gextras.Objector, path *TreePath, iter *TreeIter, newOrder []int) {
	var arg0 gextras.Objector
	arg0 = glib.Take(proxy)

	var arg1 *TreePath
	arg1 = wrapTreePath(path)

	var arg2 *TreeIter
	arg2 = wrapTreeIter(iter)

	var arg3 []int
	arg3 = ([0]int)(newOrder)

	C.gtk_tree_row_reference_reordered(arg0, arg1, arg2, arg3)
}

// ValueDupExpression: retrieves the Expression stored inside the given @value,
// and acquires a reference to it.
func ValueDupExpression(value *externglib.Value) Expression {
	ret := C.gtk_value_dup_expression()

	var ret0 Expression
	ret0 = wrapExpression(ret)

	return ret0
}

// ValueGetExpression: retrieves the Expression stored inside the given @value.
func ValueGetExpression(value *externglib.Value) Expression {
	ret := C.gtk_value_get_expression()

	var ret0 Expression
	ret0 = wrapExpression(ret)

	return ret0
}

// ValueSetExpression: stores the given Expression inside @value.
//
// The #GValue will acquire a reference to the @expression.
func ValueSetExpression(value *externglib.Value, expression Expression) {
	var arg1 Expression
	arg1 = wrapExpression(expression)

	C.gtk_value_set_expression(arg1)
}

// ValueTakeExpression: stores the given Expression inside @value.
//
// This function transfers the ownership of the @expression to the #GValue.
func ValueTakeExpression(value *externglib.Value, expression Expression) {
	var arg1 Expression
	arg1 = wrapExpression(expression)

	C.gtk_value_take_expression(arg1)
}

// Accessible: gtkAccessible provides an interface for describing a UI element,
// like a Widget, in a way that can be consumed by Assistive Technologies, or
// “AT”. Every accessible implementation has:
//
// - a “role”, represented by a value of the AccessibleRole enumeration - an
// “attribute”, represented by a set of AccessibleState, AccessibleProperty and
// AccessibleRelation values
//
// The role cannot be changed after instantiating a Accessible implementation.
//
// The attributes are updated every time a UI element's state changes in a way
// that should be reflected by assistive technologies. For instance, if a Widget
// visibility changes, the GTK_ACCESSIBLE_STATE_HIDDEN state will also change to
// reflect the Widget:visible property.
type Accessible interface {
	GetAccessibleRole() AccessibleRole
	ResetProperty(property AccessibleProperty)
	ResetRelation(relation AccessibleRelation)
	ResetState(state AccessibleState)
	UpdatePropertyValue(nProperties int, properties []AccessibleProperty, values []*externglib.Value)
	UpdateRelationValue(nRelations int, relations []AccessibleRelation, values []*externglib.Value)
	UpdateStateValue(nStates int, states []AccessibleState, values []*externglib.Value)
}

// Actionable: this interface provides a convenient way of associating widgets
// with actions on a ApplicationWindow or Application.
//
// It primarily consists of two properties: Actionable:action-name and
// Actionable:action-target. There are also some convenience APIs for setting
// these properties.
//
// The action will be looked up in action groups that are found among the
// widgets ancestors. Most commonly, these will be the actions with the “win.”
// or “app.” prefix that are associated with the ApplicationWindow or
// Application, but other action groups that are added with
// gtk_widget_insert_action_group() will be consulted as well.
type Actionable interface {
	GetActionName() string
	GetActionTargetValue() *glib.Variant
	SetActionName(actionName string)
	SetActionTargetValue(targetValue *glib.Variant)
	SetDetailedActionName(detailedActionName string)
}

// AppChooser is an interface that can be implemented by widgets which allow the
// user to choose an application (typically for the purpose of opening a file).
// The main objects that implement this interface are AppChooserWidget,
// AppChooserDialog and AppChooserButton.
//
// Applications are represented by GIO Info objects here. GIO has a concept of
// recommended and fallback applications for a given content type. Recommended
// applications are those that claim to handle the content type itself, while
// fallback also includes applications that handle a more generic content type.
// GIO also knows the default and last-used application for a given content
// type. The AppChooserWidget provides detailed control over whether the shown
// list of applications should include default, recommended or fallback
// applications.
//
// To obtain the application that has been selected in a AppChooser, use
// gtk_app_chooser_get_app_info().
type AppChooser interface {
	GetAppInfo() gio.AppInfo
	GetContentType() string
	Refresh()
}

// Buildable: gtkBuildable allows objects to extend and customize their
// deserialization from [GtkBuilder UI descriptions][BUILDER-UI]. The interface
// includes methods for setting names and properties of objects, parsing custom
// tags and constructing child objects.
//
// The GtkBuildable interface is implemented by all widgets and many of the
// non-widget objects that are provided by GTK. The main user of this interface
// is Builder. There should be very little need for applications to call any of
// these functions directly.
//
// An object only needs to implement this interface if it needs to extend the
// Builder format or run any extra routines at deserialization time.
type Buildable interface {
	GetBuildableID() string
}

// CellEditable: the CellEditable interface must be implemented for widgets to
// be usable to edit the contents of a TreeView cell. It provides a way to
// specify how temporary widgets should be configured for editing, get the new
// value, etc.
type CellEditable interface {
	EditingDone()
	RemoveWidget()
	StartEditing(event gdk.Event)
}

// CellLayout is an interface to be implemented by all objects which want to
// provide a TreeViewColumn like API for packing cells, setting attributes and
// data funcs.
//
// One of the notable features provided by implementations of GtkCellLayout are
// attributes. Attributes let you set the properties in flexible ways. They can
// just be set to constant values like regular properties. But they can also be
// mapped to a column of the underlying tree model with
// gtk_cell_layout_set_attributes(), which means that the value of the attribute
// can change from cell to cell as they are rendered by the cell renderer.
// Finally, it is possible to specify a function with
// gtk_cell_layout_set_cell_data_func() that is called to determine the value of
// the attribute for each cell that is rendered.
//
//
// GtkCellLayouts as GtkBuildable
//
// Implementations of GtkCellLayout which also implement the GtkBuildable
// interface (CellView, IconView, ComboBox, EntryCompletion, TreeViewColumn)
// accept GtkCellRenderer objects as <child> elements in UI definitions. They
// support a custom <attributes> element for their children, which can contain
// multiple <attribute> elements. Each <attribute> element has a name attribute
// which specifies a property of the cell renderer; the content of the element
// is the attribute value.
//
//
//    <object class="GtkCellView">
//      <child>
//        <object class="GtkCellRendererText"/>
//        <attributes>
//          <attribute name="text">0</attribute>
//        </attributes>
//      </child>"
//    </object>
//
// Furthermore for implementations of GtkCellLayout that use a CellArea to lay
// out cells (all GtkCellLayouts in GTK use a GtkCellArea) [cell
// properties][cell-properties] can also be defined in the format by specifying
// the custom <cell-packing> attribute which can contain multiple <property>
// elements defined in the normal way.
//
// Here is a UI definition fragment specifying cell properties:
//
//
//    <object class="GtkTreeViewColumn">
//      <child>
//        <object class="GtkCellRendererText"/>
//        <cell-packing>
//          <property name="align">True</property>
//          <property name="expand">False</property>
//        </cell-packing>
//      </child>"
//    </object>
//
//
// Subclassing GtkCellLayout implementations
//
// When subclassing a widget that implements CellLayout like IconView or
// ComboBox, there are some considerations related to the fact that these
// widgets internally use a CellArea. The cell area is exposed as a
// construct-only property by these widgets. This means that it is possible to
// e.g. do
//
//    combo = g_object_new (GTK_TYPE_COMBO_BOX, "cell-area", my_cell_area, NULL);
//
// to use a custom cell area with a combo box. But construct properties are only
// initialized after instance init() functions have run, which means that using
// functions which rely on the existence of the cell area in your subclass’
// init() function will cause the default cell area to be instantiated. In this
// case, a provided construct property value will be ignored (with a warning, to
// alert you to the problem).
//
//    static void
//    my_combo_box_init (MyComboBox *b)
//    {
//      GtkCellRenderer *cell;
//
//      cell = gtk_cell_renderer_pixbuf_new ();
//      // The following call causes the default cell area for combo boxes,
//      // a GtkCellAreaBox, to be instantiated
//      gtk_cell_layout_pack_start (GTK_CELL_LAYOUT (b), cell, FALSE);
//      ...
//    }
//
//    GtkWidget *
//    my_combo_box_new (GtkCellArea *area)
//    {
//      // This call is going to cause a warning about area being ignored
//      return g_object_new (MY_TYPE_COMBO_BOX, "cell-area", area, NULL);
//    }
//
//
// If supporting alternative cell areas with your derived widget is not
// important, then this does not have to concern you. If you want to support
// alternative cell areas, you can do so by moving the problematic calls out of
// init() and into a constructor() for your class.
type CellLayout interface {
	AddAttribute(cell CellRenderer, attribute string, column int)
	Clear()
	ClearAttributes(cell CellRenderer)
	GetArea() CellArea
	GetCells() *glib.List
	PackEnd(cell CellRenderer, expand bool)
	PackStart(cell CellRenderer, expand bool)
	Reorder(cell CellRenderer, position int)
	SetCellDataFunc(cell CellRenderer, _func CellLayoutDataFunc)
}

// ColorChooser is an interface that is implemented by widgets for choosing
// colors. Depending on the situation, colors may be allowed to have alpha
// (translucency).
//
// In GTK, the main widgets that implement this interface are
// ColorChooserWidget, ColorChooserDialog and ColorButton.
type ColorChooser interface {
	AddPalette(orientation Orientation, colorsPerLine int, nColors int, colors []gdk.RGBA)
	GetRgba() gdk.RGBA
	GetUseAlpha() bool
	SetRgba(color *gdk.RGBA)
	SetUseAlpha(useAlpha bool)
}

// Editable: the Editable interface is an interface which should be implemented
// by text editing widgets, such as Entry and SpinButton. It contains functions
// for generically manipulating an editable widget, a large number of action
// signals used for key bindings, and several signals that an application can
// connect to modify the behavior of a widget.
//
// As an example of the latter usage, by connecting the following handler to
// Editable::insert-text, an application can convert all entry into a widget
// into uppercase.
//
// Forcing entry to uppercase
//
//    #include <ctype.h>
//
//    void
//    insert_text_handler (GtkEditable *editable,
//                         const char  *text,
//                         int          length,
//                         int         *position,
//                         gpointer     data)
//    {
//      char *result = g_utf8_strup (text, length);
//
//      g_signal_handlers_block_by_func (editable,
//                                   (gpointer) insert_text_handler, data);
//      gtk_editable_insert_text (editable, result, length, position);
//      g_signal_handlers_unblock_by_func (editable,
//                                         (gpointer) insert_text_handler, data);
//
//      g_signal_stop_emission_by_name (editable, "insert_text");
//
//      g_free (result);
//    }
//
//
//
// Implementing GtkEditable
//
// The most likely scenario for implementing GtkEditable on your own widget is
// that you will embed a Text inside a complex widget, and want to delegate the
// editable functionality to that text widget. GtkEditable provides some utility
// functions to make this easy.
//
// In your class_init function, call gtk_editable_install_properties(), passing
// the first available property ID:
//
//
//    static void
//    my_class_init (MyClass *class)
//    {
//       ...
//       g_object_class_install_properties (object_class, NUM_PROPERTIES, props);
//       gtk_editable_install_properties (object_clas, NUM_PROPERTIES);
//       ...
//    }
//
// In your interface_init function for the GtkEditable interface, provide an
// implementation for the get_delegate vfunc that returns your text widget:
//
//
//    GtkEditable *
//    get_editable_delegate (GtkEditable *editable)
//    {
//      return GTK_EDITABLE (MY_WIDGET (editable)->text_widget);
//    }
//
//    static void
//    my_editable_init (GtkEditableInterface *iface)
//    {
//      iface->get_delegate = get_editable_delegate;
//    }
//
//
// You don't need to provide any other vfuncs. The default implementations work
// by forwarding to the delegate that the EditableInterface.get_delegate() vfunc
// returns.
//
// In your instance_init function, create your text widget, and then call
// gtk_editable_init_delegate():
//
//
//    static void
//    my_widget_init (MyWidget *self)
//    {
//      ...
//      self->text_widget = gtk_text_new ();
//      gtk_editable_init_delegate (GTK_EDITABLE (self));
//      ...
//    }
//
// In your dispose function, call gtk_editable_finish_delegate() before
// destroying your text widget:
//
//
//    static void
//    my_widget_dispose (GObject *object)
//    {
//      ...
//      gtk_editable_finish_delegate (GTK_EDITABLE (self));
//      g_clear_pointer (&self->text_widget, gtk_widget_unparent);
//      ...
//    }
//
// Finally, use gtk_editable_delegate_set_property() in your `set_property`
// function (and similar for `get_property`), to set the editable properties:
//
//
//      ...
//      if (gtk_editable_delegate_set_property (object, prop_id, value, pspec))
//        return;
//
//      switch (prop_id)
//      ...
//
//
// It is important to note that if you create a GtkEditable that uses a
// delegate, the low level Editable::insert-text and Editable::delete-text
// signals will be propagated from the "wrapper" editable to the delegate, but
// they will not be propagated from the delegate to the "wrapper" editable, as
// they would cause an infinite recursion. If you wish to connect to the
// Editable::insert-text and Editable::delete-text signals, you will need to
// connect to them on the delegate obtained via gtk_editable_get_delegate().
type Editable interface {
	DeleteSelection()
	DeleteText(startPos int, endPos int)
	FinishDelegate()
	GetAlignment() float32
	GetChars(startPos int, endPos int) string
	GetDelegate() Editable
	GetEditable() bool
	GetEnableUndo() bool
	GetMaxWidthChars() int
	GetPosition() int
	GetSelectionBounds() (startPos int, endPos int, ok bool)
	GetText() string
	GetWidthChars() int
	InitDelegate()
	InsertText(text string, length int, position int)
	SelectRegion(startPos int, endPos int)
	SetAlignment(xalign float32)
	SetEditable(isEditable bool)
	SetEnableUndo(enableUndo bool)
	SetMaxWidthChars(nChars int)
	SetPosition(position int)
	SetText(text string)
	SetWidthChars(nChars int)
}

// FileChooser is an interface that can be implemented by file selection
// widgets. In GTK, the main objects that implement this interface are
// FileChooserWidget and FileChooserDialog. You do not need to write an object
// that implements the FileChooser interface unless you are trying to adapt an
// existing file selector to expose a standard programming interface.
//
// FileChooser allows for shortcuts to various places in the filesystem. In the
// default implementation these are displayed in the left pane. It may be a bit
// confusing at first that these shortcuts come from various sources and in
// various flavours, so lets explain the terminology here:
//
// - Bookmarks: are created by the user, by dragging folders from the right pane
// to the left pane, or by using the “Add”. Bookmarks can be renamed and deleted
// by the user.
//
// - Shortcuts: can be provided by the application. For example, a Paint program
// may want to add a shortcut for a Clipart folder. Shortcuts cannot be modified
// by the user.
//
// - Volumes: are provided by the underlying filesystem abstraction. They are
// the “roots” of the filesystem.
//
//
// File Names and Encodings
//
// When the user is finished selecting files in a FileChooser, your program can
// get the selected filenames as #GFiles.
//
//
// Adding options
//
// You can add extra widgets to a file chooser to provide options that are not
// present in the default design, by using gtk_file_chooser_add_choice(). Each
// choice has an identifier and a user visible label; additionally, each choice
// can have multiple options. If a choice has no option, it will be rendered as
// a check button with the given label; if a choice has options, it will be
// rendered as a combo box.
type FileChooser interface {
	AddChoice(id string, label string, options []string, optionLabels []string)
	AddFilter(filter FileFilter)
	AddShortcutFolder(folder gio.File) bool
	GetAction() FileChooserAction
	GetChoice(id string) string
	GetCreateFolders() bool
	GetCurrentFolder() gio.File
	GetCurrentName() string
	GetFile() gio.File
	GetFiles() gio.ListModel
	GetFilter() FileFilter
	GetFilters() gio.ListModel
	GetSelectMultiple() bool
	GetShortcutFolders() gio.ListModel
	RemoveChoice(id string)
	RemoveFilter(filter FileFilter)
	RemoveShortcutFolder(folder gio.File) bool
	SetAction(action FileChooserAction)
	SetChoice(id string, option string)
	SetCreateFolders(createFolders bool)
	SetCurrentFolder(file gio.File) bool
	SetCurrentName(name string)
	SetFile(file gio.File) bool
	SetFilter(filter FileFilter)
	SetSelectMultiple(selectMultiple bool)
}

// FontChooser is an interface that can be implemented by widgets displaying the
// list of fonts. In GTK, the main objects that implement this interface are
// FontChooserWidget, FontChooserDialog and FontButton.
type FontChooser interface {
	GetFont() string
	GetFontDesc() *pango.FontDescription
	GetFontFace() pango.FontFace
	GetFontFamily() pango.FontFamily
	GetFontFeatures() string
	GetFontMap() pango.FontMap
	GetFontSize() int
	GetLanguage() string
	GetLevel() FontChooserLevel
	GetPreviewText() string
	GetShowPreviewEntry() bool
	SetFilterFunc(filter FontFilterFunc)
	SetFont(fontname string)
	SetFontDesc(fontDesc *pango.FontDescription)
	SetFontMap(fontmap pango.FontMap)
	SetLanguage(language string)
	SetLevel(level FontChooserLevel)
	SetPreviewText(text string)
	SetShowPreviewEntry(showPreviewEntry bool)
}

// Native is the interface implemented by all widgets that can provide a
// GdkSurface for widgets to render on.
//
// The obvious example of a Native is Window.
type Native interface {
	GetRenderer() gsk.Renderer
	GetSurface() gdk.Surface
	GetSurfaceTransform() (x float64, y float64)
	Realize()
	Unrealize()
}

// Orientable: the Orientable interface is implemented by all widgets that can
// be oriented horizontally or vertically. Orientable is more flexible in that
// it allows the orientation to be changed at runtime, allowing the widgets to
// “flip”.
type Orientable interface {
	GetOrientation() Orientation
	SetOrientation(orientation Orientation)
}

type PrintOperationPreview interface {
	EndPreview()
	IsSelected(pageNr int) bool
	RenderPage(pageNr int)
}

// Root is the interface implemented by all widgets that can act as a toplevel
// widget to a hierarchy of widgets. The root widget takes care of providing the
// connection to the windowing system and manages layout, drawing and event
// delivery for its widget hierarchy.
//
// The obvious example of a Root is Window.
type Root interface {
	GetDisplay() gdk.Display
	GetFocus() Widget
	SetFocus(focus Widget)
}

// Scrollable is an interface that is implemented by widgets with native
// scrolling ability.
//
// To implement this interface you should override the Scrollable:hadjustment
// and Scrollable:vadjustment properties.
//
//
// Creating a scrollable widget
//
// All scrollable widgets should do the following.
//
// - When a parent widget sets the scrollable child widget’s adjustments, the
// widget should populate the adjustments’ Adjustment:lower, Adjustment:upper,
// Adjustment:step-increment, Adjustment:page-increment and Adjustment:page-size
// properties and connect to the Adjustment::value-changed signal.
//
// - Because its preferred size is the size for a fully expanded widget, the
// scrollable widget must be able to cope with underallocations. This means that
// it must accept any value passed to its WidgetClass.size_allocate() function.
//
// - When the parent allocates space to the scrollable child widget, the widget
// should update the adjustments’ properties with new values.
//
// - When any of the adjustments emits the Adjustment::value-changed signal, the
// scrollable widget should scroll its contents.
type Scrollable interface {
	GetBorder() (border Border, ok bool)
	GetHadjustment() Adjustment
	GetHscrollPolicy() ScrollablePolicy
	GetVadjustment() Adjustment
	GetVscrollPolicy() ScrollablePolicy
	SetHadjustment(hadjustment Adjustment)
	SetHscrollPolicy(policy ScrollablePolicy)
	SetVadjustment(vadjustment Adjustment)
	SetVscrollPolicy(policy ScrollablePolicy)
}

// SelectionModel is an interface that extends the Model interface by adding
// support for selections. This support is then used by widgets using list
// models to add the ability to select and unselect various items.
//
// GTK provides default implementations of the most common selection modes such
// as SingleSelection, so you will only need to implement this interface if you
// want detailed control about how selections should be handled.
//
// A SelectionModel supports a single boolean per item indicating if an item is
// selected or not. This can be queried via gtk_selection_model_is_selected().
// When the selected state of one or more items changes, the model will emit the
// SelectionModel::selection-changed signal by calling the
// gtk_selection_model_selection_changed() function. The positions given in that
// signal may have their selection state changed, though that is not a
// requirement. If new items added to the model via the Model::items-changed
// signal are selected or not is up to the implementation.
//
// Note that items added via Model::items-changed may already be selected and no
// SelectionModel::selection-changed will be emitted for them. So to track which
// items are selected, it is necessary to listen to both signals.
//
// Additionally, the interface can expose functionality to select and unselect
// items. If these functions are implemented, GTK's list widgets will allow
// users to select and unselect items. However, SelectionModels are free to only
// implement them partially or not at all. In that case the widgets will not
// support the unimplemented operations.
//
// When selecting or unselecting is supported by a model, the return values of
// the selection functions do *not* indicate if selection or unselection
// happened. They are only meant to indicate complete failure, like when this
// mode of selecting is not supported by the model.
//
// Selections may happen asynchronously, so the only reliable way to find out
// when an item was selected is to listen to the signals that indicate
// selection.
type SelectionModel interface {
	GetSelection() *Bitset
	GetSelectionInRange(position uint, nItems uint) *Bitset
	IsSelected(position uint) bool
	SelectAll() bool
	SelectItem(position uint, unselectRest bool) bool
	SelectRange(position uint, nItems uint, unselectRest bool) bool
	SelectionChanged(position uint, nItems uint)
	SetSelection(selected *Bitset, mask *Bitset) bool
	UnselectAll() bool
	UnselectItem(position uint) bool
	UnselectRange(position uint, nItems uint) bool
}

type TreeDragDest interface {
	DragDataReceived(dest *TreePath, value *externglib.Value) bool
	RowDropPossible(destPath *TreePath, value *externglib.Value) bool
}

type TreeDragSource interface {
	DragDataDelete(path *TreePath) bool
	DragDataGet(path *TreePath) gdk.ContentProvider
	RowDraggable(path *TreePath) bool
}

// TreeModel: the TreeModel interface defines a generic tree interface for use
// by the TreeView widget. It is an abstract interface, and is designed to be
// usable with any appropriate data structure. The programmer just has to
// implement this interface on their own data type for it to be viewable by a
// TreeView widget.
//
// The model is represented as a hierarchical tree of strongly-typed, columned
// data. In other words, the model can be seen as a tree where every node has
// different values depending on which column is being queried. The type of data
// found in a column is determined by using the GType system (ie. TYPE_INT,
// K_TYPE_BUTTON, TYPE_POINTER, etc). The types are homogeneous per column
// across all nodes. It is important to note that this interface only provides a
// way of examining a model and observing changes. The implementation of each
// individual model decides how and if changes are made.
//
// In order to make life simpler for programmers who do not need to write their
// own specialized model, two generic models are provided — the TreeStore and
// the ListStore. To use these, the developer simply pushes data into these
// models as necessary. These models provide the data structure as well as all
// appropriate tree interfaces. As a result, implementing drag and drop,
// sorting, and storing data is trivial. For the vast majority of trees and
// lists, these two models are sufficient.
//
// Models are accessed on a node/column level of granularity. One can query for
// the value of a model at a certain node and a certain column on that node.
// There are two structures used to reference a particular node in a model. They
// are the TreePath-struct and the TreeIter-struct (“iter” is short for
// iterator). Most of the interface consists of operations on a TreeIter-struct.
//
// A path is essentially a potential node. It is a location on a model that may
// or may not actually correspond to a node on a specific model. The
// TreePath-struct can be converted into either an array of unsigned integers or
// a string. The string form is a list of numbers separated by a colon. Each
// number refers to the offset at that level. Thus, the path `0` refers to the
// root node and the path `2:4` refers to the fifth child of the third node.
//
// By contrast, a TreeIter-struct is a reference to a specific node on a
// specific model. It is a generic struct with an integer and three generic
// pointers. These are filled in by the model in a model-specific way. One can
// convert a path to an iterator by calling gtk_tree_model_get_iter(). These
// iterators are the primary way of accessing a model and are similar to the
// iterators used by TextBuffer. They are generally statically allocated on the
// stack and only used for a short time. The model interface defines a set of
// operations using them for navigating the model.
//
// It is expected that models fill in the iterator with private data. For
// example, the ListStore model, which is internally a simple linked list,
// stores a list node in one of the pointers. The TreeModelSort stores an array
// and an offset in two of the pointers. Additionally, there is an integer
// field. This field is generally filled with a unique stamp per model. This
// stamp is for catching errors resulting from using invalid iterators with a
// model.
//
// The lifecycle of an iterator can be a little confusing at first. Iterators
// are expected to always be valid for as long as the model is unchanged (and
// doesn’t emit a signal). The model is considered to own all outstanding
// iterators and nothing needs to be done to free them from the user’s point of
// view. Additionally, some models guarantee that an iterator is valid for as
// long as the node it refers to is valid (most notably the TreeStore and
// ListStore). Although generally uninteresting, as one always has to allow for
// the case where iterators do not persist beyond a signal, some very important
// performance enhancements were made in the sort model. As a result, the
// K_TREE_MODEL_ITERS_PERSIST flag was added to indicate this behavior.
//
// To help show some common operation of a model, some examples are provided.
// The first example shows three ways of getting the iter at the location
// `3:2:5`. While the first method shown is easier, the second is much more
// common, as you often get paths from callbacks.
//
// Acquiring a TreeIter-struct
//
//    // Three ways of getting the iter pointing to the location
//    GtkTreePath *path;
//    GtkTreeIter iter;
//    GtkTreeIter parent_iter;
//
//    // get the iterator from a string
//    gtk_tree_model_get_iter_from_string (model,
//                                         &iter,
//                                         "3:2:5");
//
//    // get the iterator from a path
//    path = gtk_tree_path_new_from_string ("3:2:5");
//    gtk_tree_model_get_iter (model, &iter, path);
//    gtk_tree_path_free (path);
//
//    // walk the tree to find the iterator
//    gtk_tree_model_iter_nth_child (model, &iter,
//                                   NULL, 3);
//    parent_iter = iter;
//    gtk_tree_model_iter_nth_child (model, &iter,
//                                   &parent_iter, 2);
//    parent_iter = iter;
//    gtk_tree_model_iter_nth_child (model, &iter,
//                                   &parent_iter, 5);
//
//
// This second example shows a quick way of iterating through a list and getting
// a string and an integer from each row. The populate_model() function used
// below is not shown, as it is specific to the ListStore. For information on
// how to write such a function, see the ListStore documentation.
//
// Reading data from a TreeModel
//
//    enum
//    {
//      STRING_COLUMN,
//      INT_COLUMN,
//      N_COLUMNS
//    };
//
//    ...
//
//    GtkTreeModel *list_store;
//    GtkTreeIter iter;
//    gboolean valid;
//    int row_count = 0;
//
//    // make a new list_store
//    list_store = gtk_list_store_new (N_COLUMNS,
//                                     G_TYPE_STRING,
//                                     G_TYPE_INT);
//
//    // Fill the list store with data
//    populate_model (list_store);
//
//    // Get the first iter in the list, check it is valid and walk
//    // through the list, reading each row.
//
//    valid = gtk_tree_model_get_iter_first (list_store,
//                                           &iter);
//    while (valid)
//     {
//       char *str_data;
//       int    int_data;
//
//       // Make sure you terminate calls to gtk_tree_model_get() with a “-1” value
//       gtk_tree_model_get (list_store, &iter,
//                           STRING_COLUMN, &str_data,
//                           INT_COLUMN, &int_data,
//                           -1);
//
//       // Do something with the data
//       g_print ("Row d: (s,d)\n",
//                row_count, str_data, int_data);
//       g_free (str_data);
//
//       valid = gtk_tree_model_iter_next (list_store,
//                                         &iter);
//       row_count++;
//     }
//
//
// The TreeModel interface contains two methods for reference counting:
// gtk_tree_model_ref_node() and gtk_tree_model_unref_node(). These two methods
// are optional to implement. The reference counting is meant as a way for views
// to let models know when nodes are being displayed. TreeView will take a
// reference on a node when it is visible, which means the node is either in the
// toplevel or expanded. Being displayed does not mean that the node is
// currently directly visible to the user in the viewport. Based on this
// reference counting scheme a caching model, for example, can decide whether or
// not to cache a node based on the reference count. A file-system based model
// would not want to keep the entire file hierarchy in memory, but just the
// folders that are currently expanded in every current view.
//
// When working with reference counting, the following rules must be taken into
// account:
//
// - Never take a reference on a node without owning a reference on its parent.
// This means that all parent nodes of a referenced node must be referenced as
// well.
//
// - Outstanding references on a deleted node are not released. This is not
// possible because the node has already been deleted by the time the
// row-deleted signal is received.
//
// - Models are not obligated to emit a signal on rows of which none of its
// siblings are referenced. To phrase this differently, signals are only
// required for levels in which nodes are referenced. For the root level
// however, signals must be emitted at all times (however the root level is
// always referenced when any view is attached).
type TreeModel interface {
	NewFilter(root *TreePath) TreeModel
	Foreach(_func TreeModelForeachFunc)
	GetColumnType(index_ int) externglib.Type
	GetFlags() TreeModelFlags
	GetIter(path *TreePath) (iter TreeIter, ok bool)
	GetIterFirst() (iter TreeIter, ok bool)
	GetIterFromString(pathString string) (iter TreeIter, ok bool)
	GetNColumns() int
	GetPath(iter *TreeIter) *TreePath
	GetStringFromIter(iter *TreeIter) string
	GetValue(iter *TreeIter, column int) externglib.Value
	IterChildren(parent *TreeIter) (iter TreeIter, ok bool)
	IterHasChild(iter *TreeIter) bool
	IterNChildren(iter *TreeIter) int
	IterNext(iter *TreeIter) bool
	IterNthChild(parent *TreeIter, n int) (iter TreeIter, ok bool)
	IterParent(child *TreeIter) (iter TreeIter, ok bool)
	IterPrevious(iter *TreeIter) bool
	RefNode(iter *TreeIter)
	RowChanged(path *TreePath, iter *TreeIter)
	RowDeleted(path *TreePath)
	RowHasChildToggled(path *TreePath, iter *TreeIter)
	RowInserted(path *TreePath, iter *TreeIter)
	RowsReordered(path *TreePath, iter *TreeIter, newOrder int)
	RowsReorderedWithLength(path *TreePath, iter *TreeIter, newOrder []int)
	UnrefNode(iter *TreeIter)
}

// TreeSortable is an interface to be implemented by tree models which support
// sorting. The TreeView uses the methods provided by this interface to sort the
// model.
type TreeSortable interface {
	GetSortColumnID() (sortColumnID int, order SortType, ok bool)
	HasDefaultSortFunc() bool
	SetDefaultSortFunc(sortFunc TreeIterCompareFunc)
	SetSortColumnID(sortColumnID int, order SortType)
	SetSortFunc(sortColumnID int, sortFunc TreeIterCompareFunc)
	SortColumnChanged()
}

// Bitset is a data structure for representing a set of unsigned integers.
// Another name for this data structure is "bitmap".
//
// The current implementation is based on [roaring
// bitmaps](https://roaringbitmap.org/).
//
// A bitset allows adding a set of integers and provides support for set
// operations like unions, intersections and checks for equality or if a value
// is contained in the set. Bitset also contains various functions to query
// metadata about the bitset, such as the minimum or maximum values or its size.
//
// The fastest way to iterate values in a bitset is BitsetIter.
//
// The main use case for Bitset is implementing complex selections for
// SelectionModel.
type Bitset struct {
	native *C.GtkBitset
}

func wrapBitset(p *C.GtkBitset) *Bitset {
	v := Bitset{native: p}

	runtime.SetFinalizer(&v, nil)
	runtime.SetFinalizer(&v, (*Bitset).free)

	return &v
}

func marshalBitset(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	c := (*C.GtkBitset)(unsafe.Pointer(b))

	return wrapBitset(c)
}

func (b *Bitset) free() {}

// Native returns the pointer to *C.GtkBitset. The caller is expected to
// cast.
func (b *Bitset) Native() unsafe.Pointer {
	return unsafe.Pointer(b.native)
}

func NewBitset() *Bitset

func NewBitset(start uint, nItems uint) *Bitset

// BitsetIter: an opaque, stack-allocated struct for iterating over the elements
// of a Bitset. Before a GtkBitsetIter can be used, it needs to be initialized
// with gtk_bitset_iter_init_first(), gtk_bitset_iter_init_last() or
// gtk_bitset_iter_init_at().
type BitsetIter struct {
	native *C.GtkBitsetIter
}

func wrapBitsetIter(p *C.GtkBitsetIter) *BitsetIter {
	v := BitsetIter{native: p}

	runtime.SetFinalizer(&v, nil)
	runtime.SetFinalizer(&v, (*BitsetIter).free)

	return &v
}

func marshalBitsetIter(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	c := (*C.GtkBitsetIter)(unsafe.Pointer(b))

	return wrapBitsetIter(c)
}

func (b *BitsetIter) free() {}

// Native returns the pointer to *C.GtkBitsetIter. The caller is expected to
// cast.
func (b *BitsetIter) Native() unsafe.Pointer {
	return unsafe.Pointer(b.native)
}

// Border: a struct that specifies a border around a rectangular area that can
// be of different width on each side.
type Border struct {
	// Left: the width of the left border
	Left int16
	// Right: the width of the right border
	Right int16
	// Top: the width of the top border
	Top int16
	// Bottom: the width of the bottom border
	Bottom int16

	native *C.GtkBorder
}

func wrapBorder(p *C.GtkBorder) *Border {
	var v Border

	v.Left = int16(p.left)
	v.Right = int16(p.right)
	v.Top = int16(p.top)
	v.Bottom = int16(p.bottom)

	return &v
}

func marshalBorder(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	c := (*C.GtkBorder)(unsafe.Pointer(b))

	return wrapBorder(c)
}

// Native returns the pointer to *C.GtkBorder. The caller is expected to
// cast.
func (b *Border) Native() unsafe.Pointer {
	return unsafe.Pointer(b.native)
}

func NewBorder() *Border

// BuildableParser: a sub-parser for Buildable implementations.
type BuildableParser struct {
	native *C.GtkBuildableParser
}

func wrapBuildableParser(p *C.GtkBuildableParser) *BuildableParser {
	v := BuildableParser{native: p}

	runtime.SetFinalizer(&v, nil)
	runtime.SetFinalizer(&v, (*BuildableParser).free)

	return &v
}

func marshalBuildableParser(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	c := (*C.GtkBuildableParser)(unsafe.Pointer(b))

	return wrapBuildableParser(c)
}

func (b *BuildableParser) free() {}

// Native returns the pointer to *C.GtkBuildableParser. The caller is expected to
// cast.
func (b *BuildableParser) Native() unsafe.Pointer {
	return unsafe.Pointer(b.native)
}

// CSSLocation is used to present a location in a file - or other source of data
// parsed by the CSS engine.
//
// The @bytes and @line_bytes offsets are meant to be used to programmatically
// match data. The @lines and @line_chars offsets can be used for printing the
// location in a file.
//
// Note that the @lines parameter starts from 0 and is increased whenever a CSS
// line break is encountered. (CSS defines the C character sequences "\r\n",
// "\r", "\n" and "\f" as newlines.) If your document uses different rules for
// line breaking, you might want run into problems here.
type CSSLocation struct {
	// Bytes: number of bytes parsed since the beginning
	Bytes uint
	// Chars: number of characters parsed since the beginning
	Chars uint
	// Lines: number of full lines that have been parsed If you want to display
	// this as a line number, you need to add 1 to this.
	Lines uint
	// LineBytes: number of bytes parsed since the last line break
	LineBytes uint
	// LineChars: number of characters parsed since the last line break
	LineChars uint

	native *C.GtkCssLocation
}

func wrapCSSLocation(p *C.GtkCssLocation) *CSSLocation {
	var v CSSLocation

	v.Bytes = uint(p.bytes)
	v.Chars = uint(p.chars)
	v.Lines = uint(p.lines)
	v.LineBytes = uint(p.line_bytes)
	v.LineChars = uint(p.line_chars)

	return &v
}

func marshalCSSLocation(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	c := (*C.GtkCssLocation)(unsafe.Pointer(b))

	return wrapCSSLocation(c)
}

// Native returns the pointer to *C.GtkCssLocation. The caller is expected to
// cast.
func (c *CSSLocation) Native() unsafe.Pointer {
	return unsafe.Pointer(c.native)
}

// CSSSection: defines a part of a CSS document. Because sections are nested
// into one another, you can use gtk_css_section_get_parent() to get the
// containing region.
type CSSSection struct {
	native *C.GtkCssSection
}

func wrapCSSSection(p *C.GtkCssSection) *CSSSection {
	v := CSSSection{native: p}

	runtime.SetFinalizer(&v, nil)
	runtime.SetFinalizer(&v, (*CSSSection).free)

	return &v
}

func marshalCSSSection(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	c := (*C.GtkCssSection)(unsafe.Pointer(b))

	return wrapCSSSection(c)
}

func (c *CSSSection) free() {}

// Native returns the pointer to *C.GtkCssSection. The caller is expected to
// cast.
func (c *CSSSection) Native() unsafe.Pointer {
	return unsafe.Pointer(c.native)
}

func NewCSSSection(file gio.File, start *CSSLocation, end *CSSLocation) *CSSSection

// PadActionEntry: struct defining a pad action entry.
type PadActionEntry struct {
	// Type: the type of pad feature that will trigger this action entry.
	Type PadActionType
	// Index: the 0-indexed button/ring/strip number that will trigger this
	// action entry.
	Index int
	// Mode: the mode that will trigger this action entry, or -1 for all modes.
	Mode int
	// Label: human readable description of this action entry, this string
	// should be deemed user-visible.
	Label string
	// ActionName: action name that will be activated in the Group.
	ActionName string

	native *C.GtkPadActionEntry
}

func wrapPadActionEntry(p *C.GtkPadActionEntry) *PadActionEntry {
	var v PadActionEntry

	v.Type = PadActionType(p._type)
	v.Index = int(p.index)
	v.Mode = int(p.mode)
	v.Label = C.GoString(p.label)
	defer C.free(unsafe.Pointer(p.label))
	v.ActionName = C.GoString(p.action_name)
	defer C.free(unsafe.Pointer(p.action_name))

	return &v
}

func marshalPadActionEntry(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	c := (*C.GtkPadActionEntry)(unsafe.Pointer(b))

	return wrapPadActionEntry(c)
}

// Native returns the pointer to *C.GtkPadActionEntry. The caller is expected to
// cast.
func (p *PadActionEntry) Native() unsafe.Pointer {
	return unsafe.Pointer(p.native)
}

// PageRange: see also gtk_print_settings_set_page_ranges().
type PageRange struct {
	// Start: start of page range.
	Start int
	// End: end of page range.
	End int

	native *C.GtkPageRange
}

func wrapPageRange(p *C.GtkPageRange) *PageRange {
	var v PageRange

	v.Start = int(p.start)
	v.End = int(p.end)

	return &v
}

func marshalPageRange(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	c := (*C.GtkPageRange)(unsafe.Pointer(b))

	return wrapPageRange(c)
}

// Native returns the pointer to *C.GtkPageRange. The caller is expected to
// cast.
func (p *PageRange) Native() unsafe.Pointer {
	return unsafe.Pointer(p.native)
}

// PaperSize: gtkPaperSize handles paper sizes. It uses the standard called [PWG
// 5101.1-2002 PWG: Standard for Media Standardized
// Names](http://www.pwg.org/standards.html) to name the paper sizes (and to get
// the data for the page sizes). In addition to standard paper sizes,
// GtkPaperSize allows to construct custom paper sizes with arbitrary
// dimensions.
//
// The PaperSize object stores not only the dimensions (width and height) of a
// paper size and its name, it also provides default [print
// margins][print-margins].
type PaperSize struct {
	native *C.GtkPaperSize
}

func wrapPaperSize(p *C.GtkPaperSize) *PaperSize {
	v := PaperSize{native: p}

	runtime.SetFinalizer(&v, nil)
	runtime.SetFinalizer(&v, (*PaperSize).free)

	return &v
}

func marshalPaperSize(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	c := (*C.GtkPaperSize)(unsafe.Pointer(b))

	return wrapPaperSize(c)
}

func (p *PaperSize) free() {}

// Native returns the pointer to *C.GtkPaperSize. The caller is expected to
// cast.
func (p *PaperSize) Native() unsafe.Pointer {
	return unsafe.Pointer(p.native)
}

func NewPaperSize(name string) *PaperSize

func NewPaperSize(name string, displayName string, width float64, height float64, unit Unit) *PaperSize

func NewPaperSize(variant *glib.Variant) *PaperSize

func NewPaperSize(ippName string, width float64, height float64) *PaperSize

func NewPaperSize(keyFile *glib.KeyFile, groupName string) *PaperSize

func NewPaperSize(ppdName string, ppdDisplayName string, width float64, height float64) *PaperSize

// RecentData: meta-data to be passed to gtk_recent_manager_add_full() when
// registering a recently used resource.
type RecentData struct {
	// DisplayName: a UTF-8 encoded string, containing the name of the recently
	// used resource to be displayed, or nil;
	DisplayName string
	// Description: a UTF-8 encoded string, containing a short description of
	// the resource, or nil;
	Description string
	// MIMEType: the MIME type of the resource;
	MIMEType string
	// AppName: the name of the application that is registering this recently
	// used resource;
	AppName string
	// AppExec: command line used to launch this resource; may contain the “\f”
	// and “\u” escape characters which will be expanded to the resource file
	// path and URI respectively when the command line is retrieved;
	AppExec string
	// Groups: a vector of strings containing groups names;
	Groups []string
	// IsPrivate: whether this resource should be displayed only by the
	// applications that have registered it or not.
	IsPrivate bool

	native *C.GtkRecentData
}

func wrapRecentData(p *C.GtkRecentData) *RecentData {
	var v RecentData

	v.DisplayName = C.GoString(p.display_name)
	defer C.free(unsafe.Pointer(p.display_name))
	v.Description = C.GoString(p.description)
	defer C.free(unsafe.Pointer(p.description))
	v.MIMEType = C.GoString(p.mime_type)
	defer C.free(unsafe.Pointer(p.mime_type))
	v.AppName = C.GoString(p.app_name)
	defer C.free(unsafe.Pointer(p.app_name))
	v.AppExec = C.GoString(p.app_exec)
	defer C.free(unsafe.Pointer(p.app_exec))
	v.Groups = ([0]string)(p.groups)
	v.IsPrivate = gextras.Gobool(p.is_private)

	return &v
}

func marshalRecentData(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	c := (*C.GtkRecentData)(unsafe.Pointer(b))

	return wrapRecentData(c)
}

// Native returns the pointer to *C.GtkRecentData. The caller is expected to
// cast.
func (r *RecentData) Native() unsafe.Pointer {
	return unsafe.Pointer(r.native)
}

// RecentInfo contains private data only, and should be accessed using the
// provided API.
//
// RecentInfo contains all the meta-data associated with an entry in the
// recently used files list.
type RecentInfo struct {
	native *C.GtkRecentInfo
}

func wrapRecentInfo(p *C.GtkRecentInfo) *RecentInfo {
	v := RecentInfo{native: p}

	runtime.SetFinalizer(&v, nil)
	runtime.SetFinalizer(&v, (*RecentInfo).free)

	return &v
}

func marshalRecentInfo(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	c := (*C.GtkRecentInfo)(unsafe.Pointer(b))

	return wrapRecentInfo(c)
}

func (r *RecentInfo) free() {}

// Native returns the pointer to *C.GtkRecentInfo. The caller is expected to
// cast.
func (r *RecentInfo) Native() unsafe.Pointer {
	return unsafe.Pointer(r.native)
}

// RequestedSize: represents a request of a screen object in a given
// orientation. These are primarily used in container implementations when
// allocating a natural size for children calling. See
// gtk_distribute_natural_allocation().
type RequestedSize struct {
	// Data: a client pointer
	Data interface{}
	// MinimumSize: the minimum size needed for allocation in a given
	// orientation
	MinimumSize int
	// NaturalSize: the natural size for allocation in a given orientation
	NaturalSize int

	native *C.GtkRequestedSize
}

func wrapRequestedSize(p *C.GtkRequestedSize) *RequestedSize {
	var v RequestedSize

	v.Data = unsafe.Pointer(p.data)
	v.MinimumSize = int(p.minimum_size)
	v.NaturalSize = int(p.natural_size)

	return &v
}

func marshalRequestedSize(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	c := (*C.GtkRequestedSize)(unsafe.Pointer(b))

	return wrapRequestedSize(c)
}

// Native returns the pointer to *C.GtkRequestedSize. The caller is expected to
// cast.
func (r *RequestedSize) Native() unsafe.Pointer {
	return unsafe.Pointer(r.native)
}

// Requisition: a Requisition-struct represents the desired size of a widget.
// See [GtkWidget’s geometry management section][geometry-management] for more
// information.
type Requisition struct {
	// Width: the widget’s desired width
	Width int
	// Height: the widget’s desired height
	Height int

	native *C.GtkRequisition
}

func wrapRequisition(p *C.GtkRequisition) *Requisition {
	var v Requisition

	v.Width = int(p.width)
	v.Height = int(p.height)

	return &v
}

func marshalRequisition(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	c := (*C.GtkRequisition)(unsafe.Pointer(b))

	return wrapRequisition(c)
}

// Native returns the pointer to *C.GtkRequisition. The caller is expected to
// cast.
func (r *Requisition) Native() unsafe.Pointer {
	return unsafe.Pointer(r.native)
}

func NewRequisition() *Requisition

type SettingsValue struct {
	// Origin: origin should be something like “filename:linenumber” for rc
	// files, or e.g. “XProperty” for other sources.
	Origin string
	// Value: valid types are LONG, DOUBLE and STRING corresponding to the token
	// parsed, or a GSTRING holding an unparsed statement
	Value *externglib.Value

	native *C.GtkSettingsValue
}

func wrapSettingsValue(p *C.GtkSettingsValue) *SettingsValue {
	var v SettingsValue

	v.Origin = C.GoString(p.origin)
	defer C.free(unsafe.Pointer(p.origin))

	return &v
}

func marshalSettingsValue(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	c := (*C.GtkSettingsValue)(unsafe.Pointer(b))

	return wrapSettingsValue(c)
}

// Native returns the pointer to *C.GtkSettingsValue. The caller is expected to
// cast.
func (s *SettingsValue) Native() unsafe.Pointer {
	return unsafe.Pointer(s.native)
}

// TextIter: you may wish to begin by reading the [text widget conceptual
// overview][TextWidget] which gives an overview of all the objects and data
// types related to the text widget and how they work together.
type TextIter struct {
	native *C.GtkTextIter
}

func wrapTextIter(p *C.GtkTextIter) *TextIter {
	v := TextIter{native: p}

	runtime.SetFinalizer(&v, nil)
	runtime.SetFinalizer(&v, (*TextIter).free)

	return &v
}

func marshalTextIter(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	c := (*C.GtkTextIter)(unsafe.Pointer(b))

	return wrapTextIter(c)
}

func (t *TextIter) free() {}

// Native returns the pointer to *C.GtkTextIter. The caller is expected to
// cast.
func (t *TextIter) Native() unsafe.Pointer {
	return unsafe.Pointer(t.native)
}

// TreeIter: the TreeIter is the primary structure for accessing a TreeModel.
// Models are expected to put a unique integer in the @stamp member, and put
// model-specific data in the three @user_data members.
type TreeIter struct {
	// Stamp: a unique stamp to catch invalid iterators
	Stamp int
	// UserData: model-specific data
	UserData interface{}
	// UserData2: model-specific data
	UserData2 interface{}
	// UserData3: model-specific data
	UserData3 interface{}

	native *C.GtkTreeIter
}

func wrapTreeIter(p *C.GtkTreeIter) *TreeIter {
	var v TreeIter

	v.Stamp = int(p.stamp)
	v.UserData = unsafe.Pointer(p.user_data)
	v.UserData2 = unsafe.Pointer(p.user_data2)
	v.UserData3 = unsafe.Pointer(p.user_data3)

	return &v
}

func marshalTreeIter(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	c := (*C.GtkTreeIter)(unsafe.Pointer(b))

	return wrapTreeIter(c)
}

// Native returns the pointer to *C.GtkTreeIter. The caller is expected to
// cast.
func (t *TreeIter) Native() unsafe.Pointer {
	return unsafe.Pointer(t.native)
}

type TreePath struct {
	native *C.GtkTreePath
}

func wrapTreePath(p *C.GtkTreePath) *TreePath {
	v := TreePath{native: p}

	runtime.SetFinalizer(&v, nil)
	runtime.SetFinalizer(&v, (*TreePath).free)

	return &v
}

func marshalTreePath(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	c := (*C.GtkTreePath)(unsafe.Pointer(b))

	return wrapTreePath(c)
}

func (t *TreePath) free() {}

// Native returns the pointer to *C.GtkTreePath. The caller is expected to
// cast.
func (t *TreePath) Native() unsafe.Pointer {
	return unsafe.Pointer(t.native)
}

func NewTreePath() *TreePath

func NewTreePath() *TreePath

func NewTreePath(indices []int) *TreePath

func NewTreePath(path string) *TreePath

// TreeRowReference: a GtkTreeRowReference tracks model changes so that it
// always refers to the same row (a TreePath refers to a position, not a fixed
// row). Create a new GtkTreeRowReference with gtk_tree_row_reference_new().
type TreeRowReference struct {
	native *C.GtkTreeRowReference
}

func wrapTreeRowReference(p *C.GtkTreeRowReference) *TreeRowReference {
	v := TreeRowReference{native: p}

	runtime.SetFinalizer(&v, nil)
	runtime.SetFinalizer(&v, (*TreeRowReference).free)

	return &v
}

func marshalTreeRowReference(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	c := (*C.GtkTreeRowReference)(unsafe.Pointer(b))

	return wrapTreeRowReference(c)
}

func (t *TreeRowReference) free() {}

// Native returns the pointer to *C.GtkTreeRowReference. The caller is expected to
// cast.
func (t *TreeRowReference) Native() unsafe.Pointer {
	return unsafe.Pointer(t.native)
}

func NewTreeRowReference(model TreeModel, path *TreePath) *TreeRowReference

func NewTreeRowReference(proxy gextras.Objector, model TreeModel, path *TreePath) *TreeRowReference

// ATContext: gtkATContext is an abstract class provided by GTK to communicate
// to platform-specific assistive technologies API.
//
// Each platform supported by GTK implements a ATContext subclass, and is
// responsible for updating the accessible state in response to state changes in
// Accessible.
type ATContext interface {
	gextras.Objector

	// Accessible: retrieves the Accessible using this context.
	Accessible() Accessible
	// AccessibleRole: retrieves the accessible role of this context.
	AccessibleRole() AccessibleRole
}

type atContext struct {
	*externglib.Object
}

func wrapATContext(obj *externglib.Object) ATContext {
	return atContext{*externglib.Object{obj}}
}

func marshalATContext(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewATContext(accessibleRole AccessibleRole, accessible Accessible, display gdk.Display) ATContext

func (a atContext) Accessible() Accessible

func (a atContext) AccessibleRole() AccessibleRole

// AboutDialog: the GtkAboutDialog offers a simple way to display information
// about a program like its logo, name, copyright, website and license. It is
// also possible to give credits to the authors, documenters, translators and
// artists who have worked on the program. An about dialog is typically opened
// when the user selects the `About` option from the `Help` menu. All parts of
// the dialog are optional.
//
// About dialogs often contain links and email addresses. GtkAboutDialog
// displays these as clickable links. By default, it calls gtk_show_uri() when a
// user clicks one. The behaviour can be overridden with the
// AboutDialog::activate-link signal.
//
// To specify a person with an email address, use a string like "Edgar Allan Poe
// <edgar\@poe.com>". To specify a website with a title, use a string like "GTK
// team http://www.gtk.org".
//
// To make constructing a GtkAboutDialog as convenient as possible, you can use
// the function gtk_show_about_dialog() which constructs and shows a dialog and
// keeps it around so that it can be shown again.
//
// Note that GTK sets a default title of `_("About s")` on the dialog window
// (where \s is replaced by the name of the application, but in order to ensure
// proper translation of the title, applications should set the title property
// explicitly when constructing a GtkAboutDialog, as shown in the following
// example: |[<!-- language="C" --> GFile *logo_file = g_file_new_for_path
// ("./logo.png"); GdkTexture *example_logo = gdk_texture_new_from_file
// (logo_file, NULL); g_object_unref (logo_file);
//
//    gtk_show_about_dialog (NULL,
//                           "program-name", "ExampleCode",
//                           "logo", example_logo,
//                           "title", _("About ExampleCode"),
//                           NULL);
//
//
//    # CSS nodes
//
//    GtkAboutDialog has a single CSS node with the name window and style
//    class .aboutdialog.
type AboutDialog interface {
	Window

	// AddCreditSection: creates a new section in the Credits page.
	AddCreditSection(sectionName string, people []string)
	// Artists: returns the string which are displayed in the artists tab of the
	// secondary credits dialog.
	Artists() []string
	// Authors: returns the string which are displayed in the authors tab of the
	// secondary credits dialog.
	Authors() []string
	// Comments: returns the comments string.
	Comments() string
	// Copyright: returns the copyright string.
	Copyright() string
	// Documenters: returns the string which are displayed in the documenters
	// tab of the secondary credits dialog.
	Documenters() []string
	// License: returns the license information.
	License() string
	// LicenseType: retrieves the license set using
	// gtk_about_dialog_set_license_type()
	LicenseType() License
	// Logo: returns the paintable displayed as logo in the about dialog.
	Logo() gdk.Paintable
	// LogoIconName: returns the icon name displayed as logo in the about
	// dialog.
	LogoIconName() string
	// ProgramName: returns the program name displayed in the about dialog.
	ProgramName() string
	// SystemInformation: returns the system information that is shown in the
	// about dialog.
	SystemInformation() string
	// TranslatorCredits: returns the translator credits string which is
	// displayed in the translators tab of the secondary credits dialog.
	TranslatorCredits() string
	// Version: returns the version string.
	Version() string
	// Website: returns the website URL.
	Website() string
	// WebsiteLabel: returns the label used for the website link.
	WebsiteLabel() string
	// WrapLicense: returns whether the license text in @about is automatically
	// wrapped.
	WrapLicense() bool
	// SetArtists: sets the strings which are displayed in the artists tab of
	// the secondary credits dialog.
	SetArtists(artists []string)
	// SetAuthors: sets the strings which are displayed in the authors tab of
	// the secondary credits dialog.
	SetAuthors(authors []string)
	// SetComments: sets the comments string to display in the about dialog.
	// This should be a short string of one or two lines.
	SetComments(comments string)
	// SetCopyright: sets the copyright string to display in the about dialog.
	// This should be a short string of one or two lines.
	SetCopyright(copyright string)
	// SetDocumenters: sets the strings which are displayed in the documenters
	// tab of the credits dialog.
	SetDocumenters(documenters []string)
	// SetLicense: sets the license information to be displayed in the secondary
	// license dialog. If @license is nil, the license button is hidden.
	SetLicense(license string)
	// SetLicenseType: sets the license of the application showing the @about
	// dialog from a list of known licenses.
	//
	// This function overrides the license set using
	// gtk_about_dialog_set_license().
	SetLicenseType(licenseType License)
	// SetLogo: sets the logo in the about dialog.
	SetLogo(logo gdk.Paintable)
	// SetLogoIconName: sets the icon name to be displayed as logo in the about
	// dialog.
	SetLogoIconName(iconName string)
	// SetProgramName: sets the name to display in the about dialog. If this is
	// not set, it defaults to g_get_application_name().
	SetProgramName(name string)
	// SetSystemInformation: sets the system information to be displayed in the
	// about dialog. If @system_information is nil, the system information tab
	// is hidden.
	//
	// See AboutDialog:system-information.
	SetSystemInformation(systemInformation string)
	// SetTranslatorCredits: sets the translator credits string which is
	// displayed in the translators tab of the secondary credits dialog.
	//
	// The intended use for this string is to display the translator of the
	// language which is currently used in the user interface. Using gettext(),
	// a simple way to achieve that is to mark the string for translation:
	// |[<!-- language="C" --> GtkWidget *about = gtk_about_dialog_new ();
	// gtk_about_dialog_set_translator_credits (GTK_ABOUT_DIALOG (about),
	// _("translator-credits")); ]| It is a good idea to use the customary msgid
	// “translator-credits” for this purpose, since translators will already
	// know the purpose of that msgid, and since AboutDialog will detect if
	// “translator-credits” is untranslated and hide the tab.
	SetTranslatorCredits(translatorCredits string)
	// SetVersion: sets the version string to display in the about dialog.
	SetVersion(version string)
	// SetWebsite: sets the URL to use for the website link.
	SetWebsite(website string)
	// SetWebsiteLabel: sets the label to be used for the website link.
	SetWebsiteLabel(websiteLabel string)
	// SetWrapLicense: sets whether the license text in @about is automatically
	// wrapped.
	SetWrapLicense(wrapLicense bool)
}

type aboutDialog struct {
	window
}

func wrapAboutDialog(obj *externglib.Object) AboutDialog {
	return aboutDialog{window{widget{externglib.InitiallyUnowned{obj}}}}
}

func marshalAboutDialog(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewAboutDialog() AboutDialog

func (a aboutDialog) AddCreditSection(sectionName string, people []string)

func (a aboutDialog) Artists() []string

func (a aboutDialog) Authors() []string

func (a aboutDialog) Comments() string

func (a aboutDialog) Copyright() string

func (a aboutDialog) Documenters() []string

func (a aboutDialog) License() string

func (a aboutDialog) LicenseType() License

func (a aboutDialog) Logo() gdk.Paintable

func (a aboutDialog) LogoIconName() string

func (a aboutDialog) ProgramName() string

func (a aboutDialog) SystemInformation() string

func (a aboutDialog) TranslatorCredits() string

func (a aboutDialog) Version() string

func (a aboutDialog) Website() string

func (a aboutDialog) WebsiteLabel() string

func (a aboutDialog) WrapLicense() bool

func (a aboutDialog) SetArtists(artists []string)

func (a aboutDialog) SetAuthors(authors []string)

func (a aboutDialog) SetComments(comments string)

func (a aboutDialog) SetCopyright(copyright string)

func (a aboutDialog) SetDocumenters(documenters []string)

func (a aboutDialog) SetLicense(license string)

func (a aboutDialog) SetLicenseType(licenseType License)

func (a aboutDialog) SetLogo(logo gdk.Paintable)

func (a aboutDialog) SetLogoIconName(iconName string)

func (a aboutDialog) SetProgramName(name string)

func (a aboutDialog) SetSystemInformation(systemInformation string)

func (a aboutDialog) SetTranslatorCredits(translatorCredits string)

func (a aboutDialog) SetVersion(version string)

func (a aboutDialog) SetWebsite(website string)

func (a aboutDialog) SetWebsiteLabel(websiteLabel string)

func (a aboutDialog) SetWrapLicense(wrapLicense bool)

// ActionBar: gtkActionBar is designed to present contextual actions. It is
// expected to be displayed below the content and expand horizontally to fill
// the area.
//
// It allows placing children at the start or the end. In addition, it contains
// an internal centered box which is centered with respect to the full width of
// the box, even if the children at either side take up different amounts of
// space.
//
//
// CSS nodes
//
// GtkActionBar has a single CSS node with name actionbar.
type ActionBar interface {
	Widget

	// CenterWidget: retrieves the center bar widget of the bar.
	CenterWidget() Widget
	// Revealed: gets the value of the ActionBar:revealed property.
	Revealed() bool
	// PackEnd: adds @child to @action_bar, packed with reference to the end of
	// the @action_bar.
	PackEnd(child Widget)
	// PackStart: adds @child to @action_bar, packed with reference to the start
	// of the @action_bar.
	PackStart(child Widget)
	// Remove: removes a child from @action_bar.
	Remove(child Widget)
	// SetCenterWidget: sets the center widget for the ActionBar.
	SetCenterWidget(centerWidget Widget)
	// SetRevealed: sets the ActionBar:revealed property to @revealed. Changing
	// this will make @action_bar reveal (true) or conceal (false) itself via a
	// sliding transition.
	//
	// Note: this does not show or hide @action_bar in the Widget:visible sense,
	// so revealing has no effect if Widget:visible is false.
	SetRevealed(revealed bool)
}

type actionBar struct {
	widget
}

func wrapActionBar(obj *externglib.Object) ActionBar {
	return actionBar{widget{externglib.InitiallyUnowned{obj}}}
}

func marshalActionBar(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewActionBar() ActionBar

func (a actionBar) CenterWidget() Widget

func (a actionBar) Revealed() bool

func (a actionBar) PackEnd(child Widget)

func (a actionBar) PackStart(child Widget)

func (a actionBar) Remove(child Widget)

func (a actionBar) SetCenterWidget(centerWidget Widget)

func (a actionBar) SetRevealed(revealed bool)

// ActivateAction: a ShortcutAction that calls gtk_widget_activate().
type ActivateAction interface {
	ShortcutAction
}

type activateAction struct {
	shortcutAction
}

func wrapActivateAction(obj *externglib.Object) ActivateAction {
	return activateAction{shortcutAction{*externglib.Object{obj}}}
}

func marshalActivateAction(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// Adjustment: the Adjustment object represents a value which has an associated
// lower and upper bound, together with step and page increments, and a page
// size. It is used within several GTK+ widgets, including SpinButton, Viewport,
// and Range (which is a base class for Scrollbar and Scale).
//
// The Adjustment object does not update the value itself. Instead it is left up
// to the owner of the Adjustment to control the value.
type Adjustment interface {
	gextras.Objector

	// ClampPage: updates the Adjustment:value property to ensure that the range
	// between @lower and @upper is in the current page (i.e. between
	// Adjustment:value and Adjustment:value + Adjustment:page-size). If the
	// range is larger than the page size, then only the start of it will be in
	// the current page.
	//
	// A Adjustment::value-changed signal will be emitted if the value is
	// changed.
	ClampPage(lower float64, upper float64)
	// Configure: sets all properties of the adjustment at once.
	//
	// Use this function to avoid multiple emissions of the Adjustment::changed
	// signal. See gtk_adjustment_set_lower() for an alternative way of
	// compressing multiple emissions of Adjustment::changed into one.
	Configure(value float64, lower float64, upper float64, stepIncrement float64, pageIncrement float64, pageSize float64)
	// Lower: retrieves the minimum value of the adjustment.
	Lower() float64
	// MinimumIncrement: gets the smaller of step increment and page increment.
	MinimumIncrement() float64
	// PageIncrement: retrieves the page increment of the adjustment.
	PageIncrement() float64
	// PageSize: retrieves the page size of the adjustment.
	PageSize() float64
	// StepIncrement: retrieves the step increment of the adjustment.
	StepIncrement() float64
	// Upper: retrieves the maximum value of the adjustment.
	Upper() float64
	// Value: gets the current value of the adjustment. See
	// gtk_adjustment_set_value().
	Value() float64
	// SetLower: sets the minimum value of the adjustment.
	//
	// When setting multiple adjustment properties via their individual setters,
	// multiple Adjustment::changed signals will be emitted. However, since the
	// emission of the Adjustment::changed signal is tied to the emission of the
	// #GObject::notify signals of the changed properties, it’s possible to
	// compress the Adjustment::changed signals into one by calling
	// g_object_freeze_notify() and g_object_thaw_notify() around the calls to
	// the individual setters.
	//
	// Alternatively, using a single g_object_set() for all the properties to
	// change, or using gtk_adjustment_configure() has the same effect of
	// compressing Adjustment::changed emissions.
	SetLower(lower float64)
	// SetPageIncrement: sets the page increment of the adjustment.
	//
	// See gtk_adjustment_set_lower() about how to compress multiple emissions
	// of the Adjustment::changed signal when setting multiple adjustment
	// properties.
	SetPageIncrement(pageIncrement float64)
	// SetPageSize: sets the page size of the adjustment.
	//
	// See gtk_adjustment_set_lower() about how to compress multiple emissions
	// of the GtkAdjustment::changed signal when setting multiple adjustment
	// properties.
	SetPageSize(pageSize float64)
	// SetStepIncrement: sets the step increment of the adjustment.
	//
	// See gtk_adjustment_set_lower() about how to compress multiple emissions
	// of the Adjustment::changed signal when setting multiple adjustment
	// properties.
	SetStepIncrement(stepIncrement float64)
	// SetUpper: sets the maximum value of the adjustment.
	//
	// Note that values will be restricted by `upper - page-size` if the
	// page-size property is nonzero.
	//
	// See gtk_adjustment_set_lower() about how to compress multiple emissions
	// of the Adjustment::changed signal when setting multiple adjustment
	// properties.
	SetUpper(upper float64)
	// SetValue: sets the Adjustment value. The value is clamped to lie between
	// Adjustment:lower and Adjustment:upper.
	//
	// Note that for adjustments which are used in a Scrollbar, the effective
	// range of allowed values goes from Adjustment:lower to Adjustment:upper -
	// Adjustment:page-size.
	SetValue(value float64)
}

type adjustment struct {
	externglib.InitiallyUnowned
}

func wrapAdjustment(obj *externglib.Object) Adjustment {
	return adjustment{externglib.InitiallyUnowned{obj}}
}

func marshalAdjustment(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewAdjustment(value float64, lower float64, upper float64, stepIncrement float64, pageIncrement float64, pageSize float64) Adjustment

func (a adjustment) ClampPage(lower float64, upper float64)

func (a adjustment) Configure(value float64, lower float64, upper float64, stepIncrement float64, pageIncrement float64, pageSize float64)

func (a adjustment) Lower() float64

func (a adjustment) MinimumIncrement() float64

func (a adjustment) PageIncrement() float64

func (a adjustment) PageSize() float64

func (a adjustment) StepIncrement() float64

func (a adjustment) Upper() float64

func (a adjustment) Value() float64

func (a adjustment) SetLower(lower float64)

func (a adjustment) SetPageIncrement(pageIncrement float64)

func (a adjustment) SetPageSize(pageSize float64)

func (a adjustment) SetStepIncrement(stepIncrement float64)

func (a adjustment) SetUpper(upper float64)

func (a adjustment) SetValue(value float64)

// AlternativeTrigger: a ShortcutTrigger that triggers when either of two
// ShortcutTriggers trigger.
type AlternativeTrigger interface {
	ShortcutTrigger

	// First: gets the first of the two alternative triggers that may trigger
	// @self. gtk_alternative_trigger_get_second() will return the other one.
	First() ShortcutTrigger
	// Second: gets the second of the two alternative triggers that may trigger
	// @self. gtk_alternative_trigger_get_first() will return the other one.
	Second() ShortcutTrigger
}

type alternativeTrigger struct {
	shortcutTrigger
}

func wrapAlternativeTrigger(obj *externglib.Object) AlternativeTrigger {
	return alternativeTrigger{shortcutTrigger{*externglib.Object{obj}}}
}

func marshalAlternativeTrigger(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewAlternativeTrigger(first ShortcutTrigger, second ShortcutTrigger) AlternativeTrigger

func (a alternativeTrigger) First() ShortcutTrigger

func (a alternativeTrigger) Second() ShortcutTrigger

type AnyFilter interface {
	MultiFilter
}

type anyFilter struct {
	multiFilter
}

func wrapAnyFilter(obj *externglib.Object) AnyFilter {
	return anyFilter{multiFilter{filter{*externglib.Object{obj}}}}
}

func marshalAnyFilter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewAnyFilter() AnyFilter

// AppChooserButton: the AppChooserButton is a widget that lets the user select
// an application. It implements the AppChooser interface.
//
// Initially, a AppChooserButton selects the first application in its list,
// which will either be the most-recently used application or, if
// AppChooserButton:show-default-item is true, the default application.
//
// The list of applications shown in a AppChooserButton includes the recommended
// applications for the given content type. When
// AppChooserButton:show-default-item is set, the default application is also
// included. To let the user chooser other applications, you can set the
// AppChooserButton:show-dialog-item property, which allows to open a full
// AppChooserDialog.
//
// It is possible to add custom items to the list, using
// gtk_app_chooser_button_append_custom_item(). These items cause the
// AppChooserButton::custom-item-activated signal to be emitted when they are
// selected.
//
// To track changes in the selected application, use the
// AppChooserButton::changed signal.
//
//
// CSS nodes
//
// GtkAppChooserButton has a single CSS node with the name “appchooserbutton”.
type AppChooserButton interface {
	Widget

	// AppendCustomItem: appends a custom item to the list of applications that
	// is shown in the popup; the item name must be unique per-widget. Clients
	// can use the provided name as a detail for the
	// AppChooserButton::custom-item-activated signal, to add a callback for the
	// activation of a particular custom item in the list. See also
	// gtk_app_chooser_button_append_separator().
	AppendCustomItem(name string, label string, icon gio.Icon)
	// AppendSeparator: appends a separator to the list of applications that is
	// shown in the popup.
	AppendSeparator()
	// Heading: returns the text to display at the top of the dialog.
	Heading() string
	// Modal: gets whether the dialog is modal.
	Modal() bool
	// ShowDefaultItem: returns the current value of the
	// AppChooserButton:show-default-item property.
	ShowDefaultItem() bool
	// ShowDialogItem: returns the current value of the
	// AppChooserButton:show-dialog-item property.
	ShowDialogItem() bool
	// SetActiveCustomItem: selects a custom item previously added with
	// gtk_app_chooser_button_append_custom_item().
	//
	// Use gtk_app_chooser_refresh() to bring the selection to its initial
	// state.
	SetActiveCustomItem(name string)
	// SetHeading: sets the text to display at the top of the dialog. If the
	// heading is not set, the dialog displays a default text.
	SetHeading(heading string)
	// SetModal: sets whether the dialog should be modal.
	SetModal(modal bool)
	// SetShowDefaultItem: sets whether the dropdown menu of this button should
	// show the default application for the given content type at top.
	SetShowDefaultItem(setting bool)
	// SetShowDialogItem: sets whether the dropdown menu of this button should
	// show an entry to trigger a AppChooserDialog.
	SetShowDialogItem(setting bool)
}

type appChooserButton struct {
	widget
}

func wrapAppChooserButton(obj *externglib.Object) AppChooserButton {
	return appChooserButton{widget{externglib.InitiallyUnowned{obj}}}
}

func marshalAppChooserButton(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewAppChooserButton(contentType string) AppChooserButton

func (a appChooserButton) AppendCustomItem(name string, label string, icon gio.Icon)

func (a appChooserButton) AppendSeparator()

func (a appChooserButton) Heading() string

func (a appChooserButton) Modal() bool

func (a appChooserButton) ShowDefaultItem() bool

func (a appChooserButton) ShowDialogItem() bool

func (a appChooserButton) SetActiveCustomItem(name string)

func (a appChooserButton) SetHeading(heading string)

func (a appChooserButton) SetModal(modal bool)

func (a appChooserButton) SetShowDefaultItem(setting bool)

func (a appChooserButton) SetShowDialogItem(setting bool)

// AppChooserDialog shows a AppChooserWidget inside a Dialog.
//
// Note that AppChooserDialog does not have any interesting methods of its own.
// Instead, you should get the embedded AppChooserWidget using
// gtk_app_chooser_dialog_get_widget() and call its methods if the generic
// AppChooser interface is not sufficient for your needs.
//
// To set the heading that is shown above the AppChooserWidget, use
// gtk_app_chooser_dialog_set_heading().
type AppChooserDialog interface {
	Dialog

	// Heading: returns the text to display at the top of the dialog.
	Heading() string
	// Widget: returns the AppChooserWidget of this dialog.
	Widget() Widget
	// SetHeading: sets the text to display at the top of the dialog. If the
	// heading is not set, the dialog displays a default text.
	SetHeading(heading string)
}

type appChooserDialog struct {
	dialog
}

func wrapAppChooserDialog(obj *externglib.Object) AppChooserDialog {
	return appChooserDialog{dialog{window{widget{externglib.InitiallyUnowned{obj}}}}}
}

func marshalAppChooserDialog(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewAppChooserDialog(parent Window, flags DialogFlags, file gio.File) AppChooserDialog

func NewAppChooserDialog(parent Window, flags DialogFlags, contentType string) AppChooserDialog

func (a appChooserDialog) Heading() string

func (a appChooserDialog) Widget() Widget

func (a appChooserDialog) SetHeading(heading string)

// AppChooserWidget is a widget for selecting applications. It is the main
// building block for AppChooserDialog. Most applications only need to use the
// latter; but you can use this widget as part of a larger widget if you have
// special needs.
//
// AppChooserWidget offers detailed control over what applications are shown,
// using the AppChooserWidget:show-default, AppChooserWidget:show-recommended,
// AppChooserWidget:show-fallback, AppChooserWidget:show-other and
// AppChooserWidget:show-all properties. See the AppChooser documentation for
// more information about these groups of applications.
//
// To keep track of the selected application, use the
// AppChooserWidget::application-selected and
// AppChooserWidget::application-activated signals.
//
//
// CSS nodes
//
// GtkAppChooserWidget has a single CSS node with name appchooser.
type AppChooserWidget interface {
	Widget

	// DefaultText: returns the text that is shown if there are not applications
	// that can handle the content type.
	DefaultText() string
	// ShowAll: returns the current value of the AppChooserWidget:show-all
	// property.
	ShowAll() bool
	// ShowDefault: returns the current value of the
	// AppChooserWidget:show-default property.
	ShowDefault() bool
	// ShowFallback: returns the current value of the
	// AppChooserWidget:show-fallback property.
	ShowFallback() bool
	// ShowOther: returns the current value of the AppChooserWidget:show-other
	// property.
	ShowOther() bool
	// ShowRecommended: returns the current value of the
	// AppChooserWidget:show-recommended property.
	ShowRecommended() bool
	// SetDefaultText: sets the text that is shown if there are not applications
	// that can handle the content type.
	SetDefaultText(text string)
	// SetShowAll: sets whether the app chooser should show all applications in
	// a flat list.
	SetShowAll(setting bool)
	// SetShowDefault: sets whether the app chooser should show the default
	// handler for the content type in a separate section.
	SetShowDefault(setting bool)
	// SetShowFallback: sets whether the app chooser should show related
	// applications for the content type in a separate section.
	SetShowFallback(setting bool)
	// SetShowOther: sets whether the app chooser should show applications which
	// are unrelated to the content type.
	SetShowOther(setting bool)
	// SetShowRecommended: sets whether the app chooser should show recommended
	// applications for the content type in a separate section.
	SetShowRecommended(setting bool)
}

type appChooserWidget struct {
	widget
}

func wrapAppChooserWidget(obj *externglib.Object) AppChooserWidget {
	return appChooserWidget{widget{externglib.InitiallyUnowned{obj}}}
}

func marshalAppChooserWidget(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewAppChooserWidget(contentType string) AppChooserWidget

func (a appChooserWidget) DefaultText() string

func (a appChooserWidget) ShowAll() bool

func (a appChooserWidget) ShowDefault() bool

func (a appChooserWidget) ShowFallback() bool

func (a appChooserWidget) ShowOther() bool

func (a appChooserWidget) ShowRecommended() bool

func (a appChooserWidget) SetDefaultText(text string)

func (a appChooserWidget) SetShowAll(setting bool)

func (a appChooserWidget) SetShowDefault(setting bool)

func (a appChooserWidget) SetShowFallback(setting bool)

func (a appChooserWidget) SetShowOther(setting bool)

func (a appChooserWidget) SetShowRecommended(setting bool)

// Application is a class that handles many important aspects of a GTK+
// application in a convenient fashion, without enforcing a one-size-fits-all
// application model.
//
// Currently, GtkApplication handles GTK initialization, application uniqueness,
// session management, provides some basic scriptability and desktop shell
// integration by exporting actions and menus and manages a list of toplevel
// windows whose life-cycle is automatically tied to the life-cycle of your
// application.
//
// While GtkApplication works fine with plain Windows, it is recommended to use
// it together with ApplicationWindow.
//
// When GDK threads are enabled, GtkApplication will acquire the GDK lock when
// invoking actions that arrive from other processes. The GDK lock is not
// touched for local action invocations. In order to have actions invoked in a
// predictable context it is therefore recommended that the GDK lock be held
// while invoking actions locally with g_action_group_activate_action(). The
// same applies to actions associated with ApplicationWindow and to the
// “activate” and “open” #GApplication methods.
//
// Automatic resources {#automatic-resources}
//
// Application will automatically load menus from the Builder resource located
// at "gtk/menus.ui", relative to the application's resource base path (see
// g_application_set_resource_base_path()). The menu with the ID "menubar" is
// taken as the application's menubar. Additional menus (most interesting
// submenus) can be named and accessed via gtk_application_get_menu_by_id()
// which allows for dynamic population of a part of the menu structure.
//
// It is also possible to provide the menubar manually using
// gtk_application_set_menubar().
//
// Application will also automatically setup an icon search path for the default
// icon theme by appending "icons" to the resource base path. This allows your
// application to easily store its icons as resources. See
// gtk_icon_theme_add_resource_path() for more information.
//
// If there is a resource located at "gtk/help-overlay.ui" which defines a
// ShortcutsWindow with ID "help_overlay" then GtkApplication associates an
// instance of this shortcuts window with each ApplicationWindow and sets up the
// keyboard accelerator Control-? to open it. To create a menu item that
// displays the shortcuts window, associate the item with the action
// win.show-help-overlay.
//
// A simple application {#gtkapplication}
//
// [A simple
// example](https://gitlab.gnome.org/GNOME/gtk/tree/master/examples/bp/bloatpad.c)
//
// GtkApplication optionally registers with a session manager of the users
// session (if you set the Application:register-session property) and offers
// various functionality related to the session life-cycle.
//
// An application can block various ways to end the session with the
// gtk_application_inhibit() function. Typical use cases for this kind of
// inhibiting are long-running, uninterruptible operations, such as burning a CD
// or performing a disk backup. The session manager may not honor the inhibitor,
// but it can be expected to inform the user about the negative consequences of
// ending the session while inhibitors are present.
//
// See Also {#seealso} [HowDoI: Using
// GtkApplication](https://wiki.gnome.org/HowDoI/GtkApplication), [Getting
// Started with GTK:
// Basics](https://developer.gnome.org/gtk3/stable/gtk-getting-started.html#id-1.2.3.3)
type Application interface {
	gio.Application

	// AddWindow: adds a window to @application.
	//
	// This call can only happen after the @application has started; typically,
	// you should add new application windows in response to the emission of the
	// #GApplication::activate signal.
	//
	// This call is equivalent to setting the Window:application property of
	// @window to @application.
	//
	// Normally, the connection between the application and the window will
	// remain until the window is destroyed, but you can explicitly remove it
	// with gtk_application_remove_window().
	//
	// GTK+ will keep the @application running as long as it has any windows.
	AddWindow(window Window)
	// AccelsForAction: gets the accelerators that are currently associated with
	// the given action.
	AccelsForAction(detailedActionName string) []string
	// ActionsForAccel: returns the list of actions (possibly empty) that @accel
	// maps to. Each item in the list is a detailed action name in the usual
	// form.
	//
	// This might be useful to discover if an accel already exists in order to
	// prevent installation of a conflicting accelerator (from an accelerator
	// editor or a plugin system, for example). Note that having more than one
	// action per accelerator may not be a bad thing and might make sense in
	// cases where the actions never appear in the same context.
	//
	// In case there are no actions for a given accelerator, an empty array is
	// returned. nil is never returned.
	//
	// It is a programmer error to pass an invalid accelerator string. If you
	// are unsure, check it with gtk_accelerator_parse() first.
	ActionsForAccel(accel string) []string
	// ActiveWindow: gets the “active” window for the application.
	//
	// The active window is the one that was most recently focused (within the
	// application). This window may not have the focus at the moment if another
	// application has it — this is just the most recently-focused window within
	// this application.
	ActiveWindow() Window
	// MenuByID: gets a menu from automatically loaded resources. See [Automatic
	// resources][automatic-resources] for more information.
	MenuByID(id string) gio.Menu
	// Menubar: returns the menu model that has been set with
	// gtk_application_set_menubar().
	Menubar() gio.MenuModel
	// WindowByID: returns the ApplicationWindow with the given ID.
	//
	// The ID of a ApplicationWindow can be retrieved with
	// gtk_application_window_get_id().
	WindowByID(id uint) Window
	// Windows: gets a list of the Windows associated with @application.
	//
	// The list is sorted by most recently focused window, such that the first
	// element is the currently focused window. (Useful for choosing a parent
	// for a transient window.)
	//
	// The list that is returned should not be modified in any way. It will only
	// remain valid until the next focus change or window creation or deletion.
	Windows() *glib.List
	// Inhibit: inform the session manager that certain types of actions should
	// be inhibited. This is not guaranteed to work on all platforms and for all
	// types of actions.
	//
	// Applications should invoke this method when they begin an operation that
	// should not be interrupted, such as creating a CD or DVD. The types of
	// actions that may be blocked are specified by the @flags parameter. When
	// the application completes the operation it should call
	// gtk_application_uninhibit() to remove the inhibitor. Note that an
	// application can have multiple inhibitors, and all of them must be
	// individually removed. Inhibitors are also cleared when the application
	// exits.
	//
	// Applications should not expect that they will always be able to block the
	// action. In most cases, users will be given the option to force the action
	// to take place.
	//
	// Reasons should be short and to the point.
	//
	// If @window is given, the session manager may point the user to this
	// window to find out more about why the action is inhibited.
	Inhibit(window Window, flags ApplicationInhibitFlags, reason string) uint
	// ListActionDescriptions: lists the detailed action names which have
	// associated accelerators. See gtk_application_set_accels_for_action().
	ListActionDescriptions() []string
	// RemoveWindow: remove a window from @application.
	//
	// If @window belongs to @application then this call is equivalent to
	// setting the Window:application property of @window to nil.
	//
	// The application may stop running as a result of a call to this function.
	RemoveWindow(window Window)
	// SetAccelsForAction: sets zero or more keyboard accelerators that will
	// trigger the given action. The first item in @accels will be the primary
	// accelerator, which may be displayed in the UI.
	//
	// To remove all accelerators for an action, use an empty, zero-terminated
	// array for @accels.
	//
	// For the @detailed_action_name, see g_action_parse_detailed_name() and
	// g_action_print_detailed_name().
	SetAccelsForAction(detailedActionName string, accels []string)
	// SetMenubar: sets or unsets the menubar for windows of @application.
	//
	// This is a menubar in the traditional sense.
	//
	// This can only be done in the primary instance of the application, after
	// it has been registered. #GApplication::startup is a good place to call
	// this.
	//
	// Depending on the desktop environment, this may appear at the top of each
	// window, or at the top of the screen. In some environments, if both the
	// application menu and the menubar are set, the application menu will be
	// presented as if it were the first item of the menubar. Other environments
	// treat the two as completely separate — for example, the application menu
	// may be rendered by the desktop shell while the menubar (if set) remains
	// in each individual window.
	//
	// Use the base Map interface to add actions, to respond to the user
	// selecting these menu items.
	SetMenubar(menubar gio.MenuModel)
	// Uninhibit: removes an inhibitor that has been established with
	// gtk_application_inhibit(). Inhibitors are also cleared when the
	// application exits.
	Uninhibit(cookie uint)
}

type application struct {
	gio.application
}

func wrapApplication(obj *externglib.Object) Application {
	return application{gio.application{*externglib.Object{obj}}}
}

func marshalApplication(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewApplication(applicationID string, flags gio.ApplicationFlags) Application

func (a application) AddWindow(window Window)

func (a application) AccelsForAction(detailedActionName string) []string

func (a application) ActionsForAccel(accel string) []string

func (a application) ActiveWindow() Window

func (a application) MenuByID(id string) gio.Menu

func (a application) Menubar() gio.MenuModel

func (a application) WindowByID(id uint) Window

func (a application) Windows() *glib.List

func (a application) Inhibit(window Window, flags ApplicationInhibitFlags, reason string) uint

func (a application) ListActionDescriptions() []string

func (a application) RemoveWindow(window Window)

func (a application) SetAccelsForAction(detailedActionName string, accels []string)

func (a application) SetMenubar(menubar gio.MenuModel)

func (a application) Uninhibit(cookie uint)

// ApplicationWindow is a Window subclass that offers some extra functionality
// for better integration with Application features. Notably, it can handle an
// application menubar. See gtk_application_set_menubar().
//
// This class implements the Group and Map interfaces, to let you add
// window-specific actions that will be exported by the associated Application,
// together with its application-wide actions. Window-specific actions are
// prefixed with the “win.” prefix and application-wide actions are prefixed
// with the “app.” prefix. Actions must be addressed with the prefixed name when
// referring to them from a Model.
//
// Note that widgets that are placed inside a ApplicationWindow can also
// activate these actions, if they implement the Actionable interface.
//
// As with Application, the GDK lock will be acquired when processing actions
// arriving from other processes and should therefore be held when activating
// actions locally (if GDK threads are enabled).
//
// The settings Settings:gtk-shell-shows-app-menu and
// Settings:gtk-shell-shows-menubar tell GTK+ whether the desktop environment is
// showing the application menu and menubar models outside the application as
// part of the desktop shell. For instance, on OS X, both menus will be
// displayed remotely; on Windows neither will be. gnome-shell (starting with
// version 3.4) will display the application menu, but not the menubar.
//
// If the desktop environment does not display the menubar, then
// ApplicationWindow will automatically show a menubar for it. This behaviour
// can be overridden with the ApplicationWindow:show-menubar property. If the
// desktop environment does not display the application menu, then it will
// automatically be included in the menubar or in the windows client-side
// decorations.
//
// See PopoverMenu for information about the XML language used by Builder for
// menu models.
//
// A GtkApplicationWindow with a menubar
//
//    GtkApplication *app = gtk_application_new ("org.gtk.test", 0);
//
//    GtkBuilder *builder = gtk_builder_new_from_string (
//        "<interface>"
//        "  <menu id='menubar'>"
//        "    <submenu>"
//        "      <attribute name='label' translatable='yes'>_Edit</attribute>"
//        "      <item>"
//        "        <attribute name='label' translatable='yes'>_Copy</attribute>"
//        "        <attribute name='action'>win.copy</attribute>"
//        "      </item>"
//        "      <item>"
//        "        <attribute name='label' translatable='yes'>_Paste</attribute>"
//        "        <attribute name='action'>win.paste</attribute>"
//        "      </item>"
//        "    </submenu>"
//        "  </menu>"
//        "</interface>",
//        -1);
//
//    GMenuModel *menubar = G_MENU_MODEL (gtk_builder_get_object (builder,
//                                                               "menubar"));
//    gtk_application_set_menubar (GTK_APPLICATION (app), menubar);
//    g_object_unref (builder);
//
//    // ...
//
//    GtkWidget *window = gtk_application_window_new (app);
//
type ApplicationWindow interface {
	Window

	// HelpOverlay: gets the ShortcutsWindow that has been set up with a prior
	// call to gtk_application_window_set_help_overlay().
	HelpOverlay() ShortcutsWindow
	// ID: returns the unique ID of the window. If the window has not yet been
	// added to a Application, returns `0`.
	ID() uint
	// ShowMenubar: returns whether the window will display a menubar for the
	// app menu and menubar as needed.
	ShowMenubar() bool
	// SetHelpOverlay: associates a shortcuts window with the application
	// window, and sets up an action with the name win.show-help-overlay to
	// present it.
	//
	// @window takes responsibility for destroying @help_overlay.
	SetHelpOverlay(helpOverlay ShortcutsWindow)
	// SetShowMenubar: sets whether the window will display a menubar for the
	// app menu and menubar as needed.
	SetShowMenubar(showMenubar bool)
}

type applicationWindow struct {
	window
}

func wrapApplicationWindow(obj *externglib.Object) ApplicationWindow {
	return applicationWindow{window{widget{externglib.InitiallyUnowned{obj}}}}
}

func marshalApplicationWindow(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewApplicationWindow(application Application) ApplicationWindow

func (a applicationWindow) HelpOverlay() ShortcutsWindow

func (a applicationWindow) ID() uint

func (a applicationWindow) ShowMenubar() bool

func (a applicationWindow) SetHelpOverlay(helpOverlay ShortcutsWindow)

func (a applicationWindow) SetShowMenubar(showMenubar bool)

// AspectFrame: gtkAspectFrame is useful when you want pack a widget so that it
// can resize while retaining the same aspect ratio. For instance, one might be
// drawing a small preview of a larger image.
//
// The frame can respect the aspect ratio of the child widget, or use its own
// aspect ratio.
//
//
// CSS nodes
//
// GtkAspectFrame uses a CSS node with name `frame`.
type AspectFrame interface {
	Widget

	// Child: gets the child widget of @self.
	Child() Widget
	// ObeyChild: returns whether the child's size request should override the
	// set aspect ratio of the AspectFrame.
	ObeyChild() bool
	// Ratio: returns the desired aspect ratio of the child set using
	// gtk_aspect_frame_set_ratio().
	Ratio() float32
	// Xalign: returns the horizontal alignment of the child within the
	// allocation of the AspectFrame.
	Xalign() float32
	// Yalign: returns the vertical alignment of the child within the allocation
	// of the AspectFrame.
	Yalign() float32
	// SetChild: sets the child widget of @self.
	SetChild(child Widget)
	// SetObeyChild: sets whether the aspect ratio of the child's size request
	// should override the set aspect ratio of the AspectFrame.
	SetObeyChild(obeyChild bool)
	// SetRatio: sets the desired aspect ratio of the child.
	SetRatio(ratio float32)
	// SetXalign: sets the horizontal alignment of the child within the
	// allocation of the AspectFrame.
	SetXalign(xalign float32)
	// SetYalign: sets the vertical alignment of the child within the allocation
	// of the AspectFrame.
	SetYalign(yalign float32)
}

type aspectFrame struct {
	widget
}

func wrapAspectFrame(obj *externglib.Object) AspectFrame {
	return aspectFrame{widget{externglib.InitiallyUnowned{obj}}}
}

func marshalAspectFrame(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewAspectFrame(xalign float32, yalign float32, ratio float32, obeyChild bool) AspectFrame

func (a aspectFrame) Child() Widget

func (a aspectFrame) ObeyChild() bool

func (a aspectFrame) Ratio() float32

func (a aspectFrame) Xalign() float32

func (a aspectFrame) Yalign() float32

func (a aspectFrame) SetChild(child Widget)

func (a aspectFrame) SetObeyChild(obeyChild bool)

func (a aspectFrame) SetRatio(ratio float32)

func (a aspectFrame) SetXalign(xalign float32)

func (a aspectFrame) SetYalign(yalign float32)

// Assistant: a Assistant is a widget used to represent a generally complex
// operation split up into several steps. Each step consists of one or more
// pages. GtkAssistant guides the user through the pages, and controls the page
// flow to collect the data needed for the operation.
//
// GtkAssistant handles which buttons to show and to make sensitive based on
// page sequence knowledge and the [type][GtkAssistantPageType] of each page in
// addition to state information like the
// [completion][gtk-assistant-set-page-complete] and
// [committed][gtk-assistant-commit] page statuses.
//
// If you have a case that doesn’t quite fit in Assistants way of handling
// buttons, you can use the K_ASSISTANT_PAGE_CUSTOM page type and handle buttons
// yourself.
//
// GtkAssistant maintains a AssistantPage object for each added child, which
// holds additional per-child properties. You obtain the AssistantPage for a
// child with gtk_assistant_get_page().
//
//
// GtkAssistant as GtkBuildable
//
// The GtkAssistant implementation of the Buildable interface exposes the
// @action_area as internal children with the name “action_area”.
//
// To add pages to an assistant in Builder, simply add it as a child to the
// GtkAssistant object. If you need to set per-object properties, create a
// AssistantPage object explicitly, and set the child widget as a property on
// it.
//
//
// CSS nodes
//
// GtkAssistant has a single CSS node with the name window and style class
// .assistant.
type Assistant interface {
	Window

	// AddActionWidget: adds a widget to the action area of a Assistant.
	AddActionWidget(child Widget)
	// AppendPage: appends a page to the @assistant.
	AppendPage(page Widget) int
	// Commit: erases the visited page history so the back button is not shown
	// on the current page, and removes the cancel button from subsequent pages.
	//
	// Use this when the information provided up to the current page is
	// hereafter deemed permanent and cannot be modified or undone. For example,
	// showing a progress page to track a long-running, unreversible operation
	// after the user has clicked apply on a confirmation page.
	Commit()
	// CurrentPage: returns the page number of the current page.
	CurrentPage() int
	// NPages: returns the number of pages in the @assistant
	NPages() int
	// NthPage: returns the child widget contained in page number @page_num.
	NthPage(pageNum int) Widget
	// Page: returns the AssistantPage object for @child.
	Page(child Widget) AssistantPage
	// PageComplete: gets whether @page is complete.
	PageComplete(page Widget) bool
	// PageTitle: gets the title for @page.
	PageTitle(page Widget) string
	// PageType: gets the page type of @page.
	PageType(page Widget) AssistantPageType
	// Pages: gets a list model of the assistant pages.
	Pages() gio.ListModel
	// InsertPage: inserts a page in the @assistant at a given position.
	InsertPage(page Widget, position int) int
	// NextPage: navigate to the next page.
	//
	// It is a programming error to call this function when there is no next
	// page.
	//
	// This function is for use when creating pages of the
	// K_ASSISTANT_PAGE_CUSTOM type.
	NextPage()
	// PrependPage: prepends a page to the @assistant.
	PrependPage(page Widget) int
	// PreviousPage: navigate to the previous visited page.
	//
	// It is a programming error to call this function when no previous page is
	// available.
	//
	// This function is for use when creating pages of the
	// K_ASSISTANT_PAGE_CUSTOM type.
	PreviousPage()
	// RemoveActionWidget: removes a widget from the action area of a Assistant.
	RemoveActionWidget(child Widget)
	// RemovePage: removes the @page_num’s page from @assistant.
	RemovePage(pageNum int)
	// SetCurrentPage: switches the page to @page_num.
	//
	// Note that this will only be necessary in custom buttons, as the
	// @assistant flow can be set with gtk_assistant_set_forward_page_func().
	SetCurrentPage(pageNum int)
	// SetForwardPageFunc: sets the page forwarding function to be @page_func.
	//
	// This function will be used to determine what will be the next page when
	// the user presses the forward button. Setting @page_func to nil will make
	// the assistant to use the default forward function, which just goes to the
	// next visible page.
	SetForwardPageFunc(pageFunc AssistantPageFunc)
	// SetPageComplete: sets whether @page contents are complete.
	//
	// This will make @assistant update the buttons state to be able to continue
	// the task.
	SetPageComplete(page Widget, complete bool)
	// SetPageTitle: sets a title for @page.
	//
	// The title is displayed in the header area of the assistant when @page is
	// the current page.
	SetPageTitle(page Widget, title string)
	// SetPageType: sets the page type for @page.
	//
	// The page type determines the page behavior in the @assistant.
	SetPageType(page Widget, _type AssistantPageType)
	// UpdateButtonsState: forces @assistant to recompute the buttons state.
	//
	// GTK automatically takes care of this in most situations, e.g. when the
	// user goes to a different page, or when the visibility or completeness of
	// a page changes.
	//
	// One situation where it can be necessary to call this function is when
	// changing a value on the current page affects the future page flow of the
	// assistant.
	UpdateButtonsState()
}

type assistant struct {
	window
}

func wrapAssistant(obj *externglib.Object) Assistant {
	return assistant{window{widget{externglib.InitiallyUnowned{obj}}}}
}

func marshalAssistant(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewAssistant() Assistant

func (a assistant) AddActionWidget(child Widget)

func (a assistant) AppendPage(page Widget) int

func (a assistant) Commit()

func (a assistant) CurrentPage() int

func (a assistant) NPages() int

func (a assistant) NthPage(pageNum int) Widget

func (a assistant) Page(child Widget) AssistantPage

func (a assistant) PageComplete(page Widget) bool

func (a assistant) PageTitle(page Widget) string

func (a assistant) PageType(page Widget) AssistantPageType

func (a assistant) Pages() gio.ListModel

func (a assistant) InsertPage(page Widget, position int) int

func (a assistant) NextPage()

func (a assistant) PrependPage(page Widget) int

func (a assistant) PreviousPage()

func (a assistant) RemoveActionWidget(child Widget)

func (a assistant) RemovePage(pageNum int)

func (a assistant) SetCurrentPage(pageNum int)

func (a assistant) SetForwardPageFunc(pageFunc AssistantPageFunc)

func (a assistant) SetPageComplete(page Widget, complete bool)

func (a assistant) SetPageTitle(page Widget, title string)

func (a assistant) SetPageType(page Widget, _type AssistantPageType)

func (a assistant) UpdateButtonsState()

type AssistantPage interface {
	gextras.Objector

	// Child: returns the child to which @page belongs.
	Child() Widget
}

type assistantPage struct {
	*externglib.Object
}

func wrapAssistantPage(obj *externglib.Object) AssistantPage {
	return assistantPage{*externglib.Object{obj}}
}

func marshalAssistantPage(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func (a assistantPage) Child() Widget

// BinLayout: gtkBinLayout is a LayoutManager subclass useful for create "bins"
// of widgets. GtkBinLayout will stack each child of a widget on top of each
// other, using the Widget:hexpand, Widget:vexpand, Widget:halign, and
// Widget:valign properties of each child to determine where they should be
// positioned.
type BinLayout interface {
	LayoutManager
}

type binLayout struct {
	layoutManager
}

func wrapBinLayout(obj *externglib.Object) BinLayout {
	return binLayout{layoutManager{*externglib.Object{obj}}}
}

func marshalBinLayout(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewBinLayout() BinLayout

// BookmarkList is a list model that wraps GBookmarkFile. It presents a Model
// and fills it asynchronously with the Infos returned from that function.
//
// The Infos in the list have some attributes in the recent namespace added:
// recent::private (boolean) and recent:applications (stringv).
type BookmarkList interface {
	gextras.Objector

	// Attributes: gets the attributes queried on the children.
	Attributes() string
	// Filename: returns the filename of the bookmark file that this list is
	// loading.
	Filename() string
	// IOPriority: gets the IO priority set via
	// gtk_bookmark_list_set_io_priority().
	IOPriority() int
	// IsLoading: returns true if the files are currently being loaded.
	//
	// Files will be added to @self from time to time while loading is going on.
	// The order in which are added is undefined and may change in between runs.
	IsLoading() bool
	// SetAttributes: sets the @attributes to be enumerated and starts the
	// enumeration.
	//
	// If @attributes is nil, no attributes will be queried, but a list of Infos
	// will still be created.
	SetAttributes(attributes string)
	// SetIOPriority: sets the IO priority to use while loading files.
	//
	// The default IO priority is G_PRIORITY_DEFAULT.
	SetIOPriority(ioPriority int)
}

type bookmarkList struct {
	*externglib.Object
}

func wrapBookmarkList(obj *externglib.Object) BookmarkList {
	return bookmarkList{*externglib.Object{obj}}
}

func marshalBookmarkList(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewBookmarkList(filename string, attributes string) BookmarkList

func (b bookmarkList) Attributes() string

func (b bookmarkList) Filename() string

func (b bookmarkList) IOPriority() int

func (b bookmarkList) IsLoading() bool

func (b bookmarkList) SetAttributes(attributes string)

func (b bookmarkList) SetIOPriority(ioPriority int)

// BoolFilter: gtkBoolFilter is a simple filter that takes a boolean Expression
// to determine whether to include items.
type BoolFilter interface {
	Filter

	// Expression: gets the expression that the filter uses to evaluate if an
	// item should be filtered.
	Expression() Expression
	// Invert: returns whether the filter inverts the expression.
	Invert() bool
	// SetExpression: sets the expression that the filter uses to check if items
	// should be filtered. The expression must have a value type of
	// TYPE_BOOLEAN.
	SetExpression(expression Expression)
	// SetInvert: sets whether the filter should invert the expression.
	SetInvert(invert bool)
}

type boolFilter struct {
	filter
}

func wrapBoolFilter(obj *externglib.Object) BoolFilter {
	return boolFilter{filter{*externglib.Object{obj}}}
}

func marshalBoolFilter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewBoolFilter(expression Expression) BoolFilter

func (b boolFilter) Expression() Expression

func (b boolFilter) Invert() bool

func (b boolFilter) SetExpression(expression Expression)

func (b boolFilter) SetInvert(invert bool)

// Box: the GtkBox widget arranges child widgets into a single row or column,
// depending upon the value of its Orientable:orientation property. Within the
// other dimension, all children are allocated the same size. Of course, the
// Widget:halign and Widget:valign properties can be used on the children to
// influence their allocation.
//
// Use repeated calls to gtk_box_append() to pack widgets into a GtkBox from
// start to end. Use gtk_box_remove() to remove widgets from the GtkBox.
// gtk_box_insert_child_after() can be used to add a child at a particular
// position.
//
// Use gtk_box_set_homogeneous() to specify whether or not all children of the
// GtkBox are forced to get the same amount of space.
//
// Use gtk_box_set_spacing() to determine how much space will be minimally
// placed between all children in the GtkBox. Note that spacing is added between
// the children.
//
// Use gtk_box_reorder_child_after() to move a child to a different place in the
// box.
//
//
// CSS nodes
//
// GtkBox uses a single CSS node with name box.
//
//
// Accessibility
//
// GtkBox uses the GTK_ACCESSIBLE_ROLE_GROUP role.
type Box interface {
	Widget

	// Append: adds @child as the last child to @box.
	Append(child Widget)
	// BaselinePosition: gets the value set by gtk_box_set_baseline_position().
	BaselinePosition() BaselinePosition
	// Homogeneous: returns whether the box is homogeneous (all children are the
	// same size). See gtk_box_set_homogeneous().
	Homogeneous() bool
	// Spacing: gets the value set by gtk_box_set_spacing().
	Spacing() int
	// InsertChildAfter: inserts @child in the position after @sibling in the
	// list of @box children. If @sibling is nil, insert @child at the first
	// position.
	InsertChildAfter(child Widget, sibling Widget)
	// Prepend: adds @child as the first child to @box.
	Prepend(child Widget)
	// Remove: removes a child widget from @box, after it has been added with
	// gtk_box_append(), gtk_box_prepend(), or gtk_box_insert_child_after().
	Remove(child Widget)
	// ReorderChildAfter: moves @child to the position after @sibling in the
	// list of @box children. If @sibling is nil, move @child to the first
	// position.
	ReorderChildAfter(child Widget, sibling Widget)
	// SetBaselinePosition: sets the baseline position of a box. This affects
	// only horizontal boxes with at least one baseline aligned child. If there
	// is more vertical space available than requested, and the baseline is not
	// allocated by the parent then @position is used to allocate the baseline
	// wrt the extra space available.
	SetBaselinePosition(position BaselinePosition)
	// SetHomogeneous: sets the Box:homogeneous property of @box, controlling
	// whether or not all children of @box are given equal space in the box.
	SetHomogeneous(homogeneous bool)
	// SetSpacing: sets the Box:spacing property of @box, which is the number of
	// pixels to place between children of @box.
	SetSpacing(spacing int)
}

type box struct {
	widget
}

func wrapBox(obj *externglib.Object) Box {
	return box{widget{externglib.InitiallyUnowned{obj}}}
}

func marshalBox(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewBox(orientation Orientation, spacing int) Box

func (b box) Append(child Widget)

func (b box) BaselinePosition() BaselinePosition

func (b box) Homogeneous() bool

func (b box) Spacing() int

func (b box) InsertChildAfter(child Widget, sibling Widget)

func (b box) Prepend(child Widget)

func (b box) Remove(child Widget)

func (b box) ReorderChildAfter(child Widget, sibling Widget)

func (b box) SetBaselinePosition(position BaselinePosition)

func (b box) SetHomogeneous(homogeneous bool)

func (b box) SetSpacing(spacing int)

// BoxLayout: a GtkBoxLayout is a layout manager that arranges the children of
// any widget using it into a single row or column, depending on the value of
// its Orientable:orientation property. Within the other dimension all children
// all allocated the same size. The GtkBoxLayout will respect the Widget:halign
// and Widget:valign properties of each child widget.
//
// If you want all children to be assigned the same size, you can use the
// BoxLayout:homogeneous property.
//
// If you want to specify the amount of space placed between each child, you can
// use the BoxLayout:spacing property.
type BoxLayout interface {
	LayoutManager

	// BaselinePosition: gets the value set by
	// gtk_box_layout_set_baseline_position().
	BaselinePosition() BaselinePosition
	// Homogeneous: returns whether the layout is set to be homogeneous.
	Homogeneous() bool
	// Spacing: returns the space that @box_layout puts between children.
	Spacing() uint
	// SetBaselinePosition: sets the baseline position of a box layout.
	//
	// The baseline position affects only horizontal boxes with at least one
	// baseline aligned child. If there is more vertical space available than
	// requested, and the baseline is not allocated by the parent then the given
	// @position is used to allocate the baseline within the extra space
	// available.
	SetBaselinePosition(position BaselinePosition)
	// SetHomogeneous: sets whether the box layout will allocate the same size
	// to all children.
	SetHomogeneous(homogeneous bool)
	// SetSpacing: sets how much spacing to put between children.
	SetSpacing(spacing uint)
}

type boxLayout struct {
	layoutManager
}

func wrapBoxLayout(obj *externglib.Object) BoxLayout {
	return boxLayout{layoutManager{*externglib.Object{obj}}}
}

func marshalBoxLayout(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewBoxLayout(orientation Orientation) BoxLayout

func (b boxLayout) BaselinePosition() BaselinePosition

func (b boxLayout) Homogeneous() bool

func (b boxLayout) Spacing() uint

func (b boxLayout) SetBaselinePosition(position BaselinePosition)

func (b boxLayout) SetHomogeneous(homogeneous bool)

func (b boxLayout) SetSpacing(spacing uint)

// Builder: a GtkBuilder is an auxiliary object that reads textual descriptions
// of a user interface and instantiates the described objects. To create a
// GtkBuilder from a user interface description, call
// gtk_builder_new_from_file(), gtk_builder_new_from_resource() or
// gtk_builder_new_from_string().
//
// In the (unusual) case that you want to add user interface descriptions from
// multiple sources to the same GtkBuilder you can call gtk_builder_new() to get
// an empty builder and populate it by (multiple) calls to
// gtk_builder_add_from_file(), gtk_builder_add_from_resource() or
// gtk_builder_add_from_string().
//
// A GtkBuilder holds a reference to all objects that it has constructed and
// drops these references when it is finalized. This finalization can cause the
// destruction of non-widget objects or widgets which are not contained in a
// toplevel window. For toplevel windows constructed by a builder, it is the
// responsibility of the user to call gtk_window_destroy() to get rid of them
// and all the widgets they contain.
//
// The functions gtk_builder_get_object() and gtk_builder_get_objects() can be
// used to access the widgets in the interface by the names assigned to them
// inside the UI description. Toplevel windows returned by these functions will
// stay around until the user explicitly destroys them with
// gtk_window_destroy(). Other widgets will either be part of a larger hierarchy
// constructed by the builder (in which case you should not have to worry about
// their lifecycle), or without a parent, in which case they have to be added to
// some container to make use of them. Non-widget objects need to be reffed with
// g_object_ref() to keep them beyond the lifespan of the builder.
//
// GtkBuilder UI Definitions {ILDER-UI}
//
// GtkBuilder parses textual descriptions of user interfaces which are specified
// in XML format. We refer to these descriptions as “GtkBuilder UI definitions”
// or just “UI definitions” if the context is clear.
//
// The toplevel element is `<interface>`. It optionally takes a “domain”
// attribute, which will make the builder look for translated strings using
// `dgettext()` in the domain specified. This can also be done by calling
// gtk_builder_set_translation_domain() on the builder. Objects are described by
// `<object>` elements, which can contain <property> elements to set properties,
// `<signal>` elements which connect signals to handlers, and `<child>`
// elements, which describe child objects (most often widgets inside a
// container, but also e.g. actions in an action group, or columns in a tree
// model). A `<child>` element contains an `<object>` element which describes
// the child object. The target toolkit version(s) are described by <requires>
// elements, the “lib” attribute specifies the widget library in question
// (currently the only supported value is “gtk”) and the “version” attribute
// specifies the target version in the form “`<major>`.`<minor>`”. The builder
// will error out if the version requirements are not met.
//
// Typically, the specific kind of object represented by an `<object>` element
// is specified by the “class” attribute. If the type has not been loaded yet,
// GTK tries to find the `get_type()` function from the class name by applying
// heuristics. This works in most cases, but if necessary, it is possible to
// specify the name of the `get_type()` function explicitly with the "type-func"
// attribute.
//
// Objects may be given a name with the “id” attribute, which allows the
// application to retrieve them from the builder with gtk_builder_get_object().
// An id is also necessary to use the object as property value in other parts of
// the UI definition. GTK reserves ids starting and ending with `___` (three
// consecutive underscores) for its own purposes.
//
// Setting properties of objects is pretty straightforward with the <property>
// element: the “name” attribute specifies the name of the property, and the
// content of the element specifies the value. If the “translatable” attribute
// is set to a true value, GTK uses `gettext()` (or `dgettext()` if the builder
// has a translation domain set) to find a translation for the value. This
// happens before the value is parsed, so it can be used for properties of any
// type, but it is probably most useful for string properties. It is also
// possible to specify a context to disambiguate short strings, and comments
// which may help the translators.
//
// Builder can parse textual representations for the most common property types:
// characters, strings, integers, floating-point numbers, booleans (strings like
// “TRUE”, “t”, “yes”, “y”, “1” are interpreted as true, strings like “FALSE”,
// “f”, “no”, “n”, “0” are interpreted as false), enumerations (can be specified
// by their name, nick or integer value), flags (can be specified by their name,
// nick, integer value, optionally combined with “|”, e.g.
// “GTK_INPUT_HINT_EMOJI|GTK_INPUT_HINT_LOWERCASE”) and colors (in a format
// understood by gdk_rgba_parse()).
//
// GVariants can be specified in the format understood by g_variant_parse(), and
// pixbufs can be specified as a filename of an image file to load.
//
// Objects can be referred to by their name and by default refer to objects
// declared in the local XML fragment and objects exposed via
// gtk_builder_expose_object(). In general, GtkBuilder allows forward references
// to objects — declared in the local XML; an object doesn’t have to be
// constructed before it can be referred to. The exception to this rule is that
// an object has to be constructed before it can be used as the value of a
// construct-only property.
//
// It is also possible to bind a property value to another object's property
// value using the attributes "bind-source" to specify the source object of the
// binding, and optionally, "bind-property" and "bind-flags" to specify the
// source property and source binding flags respectively. Internally builder
// implements this using #GBinding objects. For more information see
// g_object_bind_property()
//
// Sometimes it is necessary to refer to widgets which have implicitly been
// constructed by GTK as part of a composite widget, to set properties on them
// or to add further children (e.g. the content area of a Dialog). This can be
// achieved by setting the “internal-child” property of the `<child>` element to
// a true value. Note that Builder still requires an `<object>` element for the
// internal child, even if it has already been constructed.
//
// A number of widgets have different places where a child can be added (e.g.
// tabs vs. page content in notebooks). This can be reflected in a UI definition
// by specifying the “type” attribute on a `<child>` The possible values for the
// “type” attribute are described in the sections describing the widget-specific
// portions of UI definitions.
//
//
// Signal handlers and function pointers
//
// Signal handlers are set up with the <signal> element. The “name” attribute
// specifies the name of the signal, and the “handler” attribute specifies the
// function to connect to the signal. The remaining attributes, “after”,
// “swapped” and “object”, have the same meaning as the corresponding parameters
// of the g_signal_connect_object() or g_signal_connect_data() functions. A
// “last_modification_time” attribute is also allowed, but it does not have a
// meaning to the builder.
//
// If you rely on #GModule support to lookup callbacks in the symbol table, the
// following details should be noted:
//
// When compiling applications for Windows, you must declare signal callbacks
// with MODULE_EXPORT, or they will not be put in the symbol table. On Linux and
// Unices, this is not necessary; applications should instead be compiled with
// the -Wl,--export-dynamic CFLAGS, and linked against gmodule-export-2.0.
//
// A GtkBuilder UI Definition
//
//
//    <interface>
//      <object class="GtkDialog" id="dialog1">
//        <child internal-child="vbox">
//          <object class="GtkBox" id="vbox1">
//            <child internal-child="action_area">
//              <object class="GtkBox" id="hbuttonbox1">
//                <child>
//                  <object class="GtkButton" id="ok_button">
//                    <property name="label">gtk-ok</property>
//                    <signal name="clicked" handler="ok_button_clicked"/>
//                  </object>
//                </child>
//              </object>
//            </child>
//          </object>
//        </child>
//      </object>
//    </interface>
//
// Beyond this general structure, several object classes define their own XML
// DTD fragments for filling in the ANY placeholders in the DTD above. Note that
// a custom element in a <child> element gets parsed by the custom tag handler
// of the parent object, while a custom element in an <object> element gets
// parsed by the custom tag handler of the object.
//
// These XML fragments are explained in the documentation of the respective
// objects.
//
// Additionally, since 3.10 a special <template> tag has been added to the
// format allowing one to define a widget class’s components. See the [GtkWidget
// documentation][composite-templates] for details.
type Builder interface {
	gextras.Objector

	// AddFromFile: parses a file containing a [GtkBuilder UI
	// definition][BUILDER-UI] and merges it with the current contents of
	// @builder.
	//
	// This function is useful if you need to call
	// gtk_builder_set_current_object() to add user data to callbacks before
	// loading GtkBuilder UI. Otherwise, you probably want
	// gtk_builder_new_from_file() instead.
	//
	// If an error occurs, 0 will be returned and @error will be assigned a
	// #GError from the K_BUILDER_ERROR, MARKUP_ERROR or FILE_ERROR domain.
	//
	// It’s not really reasonable to attempt to handle failures of this call.
	// You should not use this function with untrusted files (ie: files that are
	// not part of your application). Broken Builder files can easily crash your
	// program, and it’s possible that memory was leaked leading up to the
	// reported failure. The only reasonable thing to do when an error is
	// detected is to call g_error().
	AddFromFile(filename string) bool
	// AddFromResource: parses a resource file containing a [GtkBuilder UI
	// definition][BUILDER-UI] and merges it with the current contents of
	// @builder.
	//
	// This function is useful if you need to call
	// gtk_builder_set_current_object() to add user data to callbacks before
	// loading GtkBuilder UI. Otherwise, you probably want
	// gtk_builder_new_from_resource() instead.
	//
	// If an error occurs, 0 will be returned and @error will be assigned a
	// #GError from the K_BUILDER_ERROR, MARKUP_ERROR or RESOURCE_ERROR domain.
	//
	// It’s not really reasonable to attempt to handle failures of this call.
	// The only reasonable thing to do when an error is detected is to call
	// g_error().
	AddFromResource(resourcePath string) bool
	// AddFromString: parses a string containing a [GtkBuilder UI
	// definition][BUILDER-UI] and merges it with the current contents of
	// @builder.
	//
	// This function is useful if you need to call
	// gtk_builder_set_current_object() to add user data to callbacks before
	// loading GtkBuilder UI. Otherwise, you probably want
	// gtk_builder_new_from_string() instead.
	//
	// Upon errors false will be returned and @error will be assigned a #GError
	// from the K_BUILDER_ERROR, MARKUP_ERROR or VARIANT_PARSE_ERROR domain.
	//
	// It’s not really reasonable to attempt to handle failures of this call.
	// The only reasonable thing to do when an error is detected is to call
	// g_error().
	AddFromString(buffer string, length int) bool
	// AddObjectsFromFile: parses a file containing a [GtkBuilder UI
	// definition][BUILDER-UI] building only the requested objects and merges
	// them with the current contents of @builder.
	//
	// Upon errors 0 will be returned and @error will be assigned a #GError from
	// the K_BUILDER_ERROR, MARKUP_ERROR or FILE_ERROR domain.
	//
	// If you are adding an object that depends on an object that is not its
	// child (for instance a TreeView that depends on its TreeModel), you have
	// to explicitly list all of them in @object_ids.
	AddObjectsFromFile(filename string, objectIds []string) bool
	// AddObjectsFromResource: parses a resource file containing a [GtkBuilder
	// UI definition][BUILDER-UI] building only the requested objects and merges
	// them with the current contents of @builder.
	//
	// Upon errors 0 will be returned and @error will be assigned a #GError from
	// the K_BUILDER_ERROR, MARKUP_ERROR or RESOURCE_ERROR domain.
	//
	// If you are adding an object that depends on an object that is not its
	// child (for instance a TreeView that depends on its TreeModel), you have
	// to explicitly list all of them in @object_ids.
	AddObjectsFromResource(resourcePath string, objectIds []string) bool
	// AddObjectsFromString: parses a string containing a [GtkBuilder UI
	// definition][BUILDER-UI] building only the requested objects and merges
	// them with the current contents of @builder.
	//
	// Upon errors false will be returned and @error will be assigned a #GError
	// from the K_BUILDER_ERROR or MARKUP_ERROR domain.
	//
	// If you are adding an object that depends on an object that is not its
	// child (for instance a TreeView that depends on its TreeModel), you have
	// to explicitly list all of them in @object_ids.
	AddObjectsFromString(buffer string, length int, objectIds []string) bool
	// CreateClosure: creates a closure to invoke the function called
	// @function_name, by using the create_closure() implementation of
	// @builder's BuilderScope.
	//
	// If no closure could be created, nil will be returned and @error will be
	// set.
	CreateClosure(functionName string, flags BuilderClosureFlags, object gextras.Objector) *externglib.Closure
	// ExposeObject: add @object to the @builder object pool so it can be
	// referenced just like any other object built by builder.
	ExposeObject(name string, object gextras.Objector)
	// ExtendWithTemplate: main private entry point for building composite
	// container components from template XML.
	//
	// This is exported purely to let gtk-builder-tool validate templates,
	// applications have no need to call this function.
	ExtendWithTemplate(object gextras.Objector, templateType externglib.Type, buffer string, length int) bool
	// CurrentObject: gets the current object set via
	// gtk_builder_set_current_object().
	CurrentObject() gextras.Objector
	// Object: gets the object named @name. Note that this function does not
	// increment the reference count of the returned object.
	Object(name string) gextras.Objector
	// Objects: gets all objects that have been constructed by @builder. Note
	// that this function does not increment the reference counts of the
	// returned objects.
	Objects() *glib.SList
	// Scope: gets the scope in use that was set via gtk_builder_set_scope().
	//
	// See the BuilderScope documentation for details.
	Scope() BuilderScope
	// TranslationDomain: gets the translation domain of @builder.
	TranslationDomain() string
	// TypeFromName: looks up a type by name, using the virtual function that
	// Builder has for that purpose. This is mainly used when implementing the
	// Buildable interface on a type.
	TypeFromName(typeName string) externglib.Type
	// SetCurrentObject: sets the current object for the @builder. The current
	// object can be thought of as the `this` object that the builder is working
	// for and will often be used as the default object when an object is
	// optional.
	//
	// gtk_widget_init_template() for example will set the current object to the
	// widget the template is inited for. For functions like
	// gtk_builder_new_from_resource(), the current object will be nil.
	SetCurrentObject(currentObject gextras.Objector)
	// SetScope: sets the scope the builder should operate in.
	//
	// If @scope is nil a new BuilderCScope will be created.
	//
	// See the BuilderScope documentation for details.
	SetScope(scope BuilderScope)
	// SetTranslationDomain: sets the translation domain of @builder. See
	// Builder:translation-domain.
	SetTranslationDomain(domain string)
	// ValueFromStringType: like gtk_builder_value_from_string(), this function
	// demarshals a value from a string, but takes a #GType instead of Spec.
	// This function calls g_value_init() on the @value argument, so it need not
	// be initialised beforehand.
	//
	// Upon errors false will be returned and @error will be assigned a #GError
	// from the K_BUILDER_ERROR domain.
	ValueFromStringType(_type externglib.Type, string string) (value externglib.Value, ok bool)
}

type builder struct {
	*externglib.Object
}

func wrapBuilder(obj *externglib.Object) Builder {
	return builder{*externglib.Object{obj}}
}

func marshalBuilder(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewBuilder() Builder

func NewBuilder(filename string) Builder

func NewBuilder(resourcePath string) Builder

func NewBuilder(string string, length int) Builder

func (b builder) AddFromFile(filename string) bool

func (b builder) AddFromResource(resourcePath string) bool

func (b builder) AddFromString(buffer string, length int) bool

func (b builder) AddObjectsFromFile(filename string, objectIds []string) bool

func (b builder) AddObjectsFromResource(resourcePath string, objectIds []string) bool

func (b builder) AddObjectsFromString(buffer string, length int, objectIds []string) bool

func (b builder) CreateClosure(functionName string, flags BuilderClosureFlags, object gextras.Objector) *externglib.Closure

func (b builder) ExposeObject(name string, object gextras.Objector)

func (b builder) ExtendWithTemplate(object gextras.Objector, templateType externglib.Type, buffer string, length int) bool

func (b builder) CurrentObject() gextras.Objector

func (b builder) Object(name string) gextras.Objector

func (b builder) Objects() *glib.SList

func (b builder) Scope() BuilderScope

func (b builder) TranslationDomain() string

func (b builder) TypeFromName(typeName string) externglib.Type

func (b builder) SetCurrentObject(currentObject gextras.Objector)

func (b builder) SetScope(scope BuilderScope)

func (b builder) SetTranslationDomain(domain string)

func (b builder) ValueFromStringType(_type externglib.Type, string string) (value externglib.Value, ok bool)

type BuilderCScope interface {
	gextras.Objector

	// AddCallbackSymbol: adds the @callback_symbol to the scope of @builder
	// under the given @callback_name.
	//
	// Using this function overrides the behavior of
	// gtk_builder_create_closure() for any callback symbols that are added.
	// Using this method allows for better encapsulation as it does not require
	// that callback symbols be declared in the global namespace.
	AddCallbackSymbol(callbackName string, callbackSymbol interface{})
	// LookupCallbackSymbol: fetches a symbol previously added to @self with
	// gtk_builder_cscope_add_callback_symbol().
	LookupCallbackSymbol(callbackName string) interface{}
}

type builderCScope struct {
	*externglib.Object
}

func wrapBuilderCScope(obj *externglib.Object) BuilderCScope {
	return builderCScope{*externglib.Object{obj}}
}

func marshalBuilderCScope(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewBuilderCScope() BuilderCScope

func (b builderCScope) AddCallbackSymbol(callbackName string, callbackSymbol interface{})

func (b builderCScope) LookupCallbackSymbol(callbackName string) interface{}

// BuilderListItemFactory is a ListItemFactory that creates widgets by
// instantiating Builder UI templates. The templates must be extending ListItem,
// and typically use Expressions to obtain data from the items in the model.
//
//
//      <interface>
//        <template class="GtkListItem">
//          <property name="child">
//            <object class="GtkLabel">
//              <property name="xalign">0</property>
//              <binding name="label">
//                <lookup name="name" type="SettingsKey">
//                  <lookup name="item">GtkListItem</lookup>
//                </lookup>
//              </binding>
//            </object>
//          </property>
//        </template>
//      </interface>
type BuilderListItemFactory interface {
	ListItemFactory

	// Bytes: gets the data used as the Builder UI template for constructing
	// listitems.
	Bytes() *glib.Bytes
	// Resource: if the data references a resource, gets the path of that
	// resource.
	Resource() string
	// Scope: gets the scope used when constructing listitems.
	Scope() BuilderScope
}

type builderListItemFactory struct {
	listItemFactory
}

func wrapBuilderListItemFactory(obj *externglib.Object) BuilderListItemFactory {
	return builderListItemFactory{listItemFactory{*externglib.Object{obj}}}
}

func marshalBuilderListItemFactory(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewBuilderListItemFactory(scope BuilderScope, bytes *glib.Bytes) BuilderListItemFactory

func NewBuilderListItemFactory(scope BuilderScope, resourcePath string) BuilderListItemFactory

func (b builderListItemFactory) Bytes() *glib.Bytes

func (b builderListItemFactory) Resource() string

func (b builderListItemFactory) Scope() BuilderScope

// Button: the Button widget is generally used to trigger a callback function
// that is called when the button is pressed. The various signals and how to use
// them are outlined below.
//
// The Button widget can hold any valid child widget. That is, it can hold
// almost any other standard Widget. The most commonly used child is the Label.
//
//
// CSS nodes
//
// GtkButton has a single CSS node with name button. The node will get the style
// classes .image-button or .text-button, if the content is just an image or
// label, respectively. It may also receive the .flat style class.
//
// Other style classes that are commonly used with GtkButton include
// .suggested-action and .destructive-action. In special cases, buttons can be
// made round by adding the .circular style class.
//
// Button-like widgets like ToggleButton, MenuButton, VolumeButton, LockButton,
// ColorButton or FontButton use style classes such as .toggle, .popup, .scale,
// .lock, .color on the button node to differentiate themselves from a plain
// GtkButton.
//
//
// Accessibility
//
// GtkButton uses the K_ACCESSIBLE_ROLE_BUTTON role.
type Button interface {
	Widget

	// Child: gets the child widget of @button.
	Child() Widget
	// HasFrame: returns whether the button has a frame.
	HasFrame() bool
	// IconName: returns the icon name set via gtk_button_set_icon_name().
	IconName() string
	// Label: fetches the text from the label of the button, as set by
	// gtk_button_set_label(). If the label text has not been set the return
	// value will be nil. This will be the case if you create an empty button
	// with gtk_button_new() to use as a container.
	Label() string
	// UseUnderline: returns whether an embedded underline in the button label
	// indicates a mnemonic. See gtk_button_set_use_underline().
	UseUnderline() bool
	// SetChild: sets the child widget of @button.
	SetChild(child Widget)
	// SetHasFrame: sets the style of the button. Buttons can has a flat
	// appearance or have a frame drawn around them.
	SetHasFrame(hasFrame bool)
	// SetIconName: adds a Image with the given icon name as a child. If @button
	// already contains a child widget, that child widget will be removed and
	// replaced with the image.
	SetIconName(iconName string)
	// SetLabel: sets the text of the label of the button to @label.
	//
	// This will also clear any previously set labels.
	SetLabel(label string)
	// SetUseUnderline: if true, an underline in the text of the button label
	// indicates the next character should be used for the mnemonic accelerator
	// key.
	SetUseUnderline(useUnderline bool)
}

type button struct {
	widget
}

func wrapButton(obj *externglib.Object) Button {
	return button{widget{externglib.InitiallyUnowned{obj}}}
}

func marshalButton(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewButton() Button

func NewButton(iconName string) Button

func NewButton(label string) Button

func NewButton(label string) Button

func (b button) Child() Widget

func (b button) HasFrame() bool

func (b button) IconName() string

func (b button) Label() string

func (b button) UseUnderline() bool

func (b button) SetChild(child Widget)

func (b button) SetHasFrame(hasFrame bool)

func (b button) SetIconName(iconName string)

func (b button) SetLabel(label string)

func (b button) SetUseUnderline(useUnderline bool)

type CClosureExpression interface {
	Expression
}

type cClosureExpression struct {
	expression
}

func wrapCClosureExpression(obj *externglib.Object) CClosureExpression {
	return cClosureExpression{expression{obj}}
}

func marshalCClosureExpression(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// Calendar is a widget that displays a Gregorian calendar, one month at a time.
// It can be created with gtk_calendar_new().
//
// The date that is currently displayed can be altered with
// gtk_calendar_select_day().
//
// To place a visual marker on a particular day, use gtk_calendar_mark_day() and
// to remove the marker, gtk_calendar_unmark_day(). Alternative, all marks can
// be cleared with gtk_calendar_clear_marks().
//
// The selected date can be retrieved from a Calendar using
// gtk_calendar_get_date().
//
// Users should be aware that, although the Gregorian calendar is the legal
// calendar in most countries, it was adopted progressively between 1582 and
// 1929. Display before these dates is likely to be historically incorrect.
//
// CSS nodes
//
//    calendar.view
//    ├── header
//    │   ├── button
//    │   ├── stack.month
//    │   ├── button
//    │   ├── button
//    │   ├── label.year
//    │   ╰── button
//    ╰── grid
//        ╰── label[.day-name][.week-number][.day-number][.other-month][.today]
//
// GtkCalendar has a main node with name calendar. It contains a subnode called
// header containing the widgets for switching between years and months.
//
// The grid subnode contains all day labels, including week numbers on the left
// (marked with the .week-number css class) and day names on top (marked with
// the .day-name css class).
//
// Day labels that belong to the previous or next month get the .other-month
// style class. The label of the current day get the .today style class.
//
// Marked day labels get the :selected state assigned.
type Calendar interface {
	Widget

	// ClearMarks: remove all visual markers.
	ClearMarks()
	// Date: returns a Time representing the shown year, month and the selected
	// day, in the local time zone.
	Date() *glib.DateTime
	// DayIsMarked: returns if the @day of the @calendar is already marked.
	DayIsMarked(day uint) bool
	// ShowDayNames: returns whether @self is currently showing the names of the
	// week days above the day numbers, i.e. the value of the
	// Calendar:show-day-names property.
	ShowDayNames() bool
	// ShowHeading: returns whether @self is currently showing the heading, i.e.
	// the value of the Calendar:show-heading property.
	ShowHeading() bool
	// ShowWeekNumbers: returns whether @self is showing week numbers right now,
	// i.e. the value of the Calendar:show-week-numbers property.
	ShowWeekNumbers() bool
	// MarkDay: places a visual marker on a particular day.
	MarkDay(day uint)
	// SelectDay: will switch to @date's year and month and select its day.
	SelectDay(date *glib.DateTime)
	// SetShowDayNames: sets whether the calendar shows day names.
	SetShowDayNames(value bool)
	// SetShowHeading: sets whether the calendar should show a heading
	// containing the current year and month as well as buttons for changing
	// both.
	SetShowHeading(value bool)
	// SetShowWeekNumbers: sets whether week numbers are shown in the calendar.
	SetShowWeekNumbers(value bool)
	// UnmarkDay: removes the visual marker from a particular day.
	UnmarkDay(day uint)
}

type calendar struct {
	widget
}

func wrapCalendar(obj *externglib.Object) Calendar {
	return calendar{widget{externglib.InitiallyUnowned{obj}}}
}

func marshalCalendar(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewCalendar() Calendar

func (c calendar) ClearMarks()

func (c calendar) Date() *glib.DateTime

func (c calendar) DayIsMarked(day uint) bool

func (c calendar) ShowDayNames() bool

func (c calendar) ShowHeading() bool

func (c calendar) ShowWeekNumbers() bool

func (c calendar) MarkDay(day uint)

func (c calendar) SelectDay(date *glib.DateTime)

func (c calendar) SetShowDayNames(value bool)

func (c calendar) SetShowHeading(value bool)

func (c calendar) SetShowWeekNumbers(value bool)

func (c calendar) UnmarkDay(day uint)

// CallbackAction: a ShortcutAction that invokes a callback.
type CallbackAction interface {
	ShortcutAction
}

type callbackAction struct {
	shortcutAction
}

func wrapCallbackAction(obj *externglib.Object) CallbackAction {
	return callbackAction{shortcutAction{*externglib.Object{obj}}}
}

func marshalCallbackAction(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewCallbackAction(callback ShortcutFunc) CallbackAction

// CellArea: the CellArea is an abstract class for CellLayout widgets (also
// referred to as "layouting widgets") to interface with an arbitrary number of
// CellRenderers and interact with the user for a given TreeModel row.
//
// The cell area handles events, focus navigation, drawing and size requests and
// allocations for a given row of data.
//
// Usually users dont have to interact with the CellArea directly unless they
// are implementing a cell-layouting widget themselves.
//
//
// Requesting area sizes
//
// As outlined in [GtkWidget’s geometry management
// section][geometry-management], GTK uses a height-for-width geometry
// management system to compute the sizes of widgets and user interfaces.
// CellArea uses the same semantics to calculate the size of an area for an
// arbitrary number of TreeModel rows.
//
// When requesting the size of a cell area one needs to calculate the size for a
// handful of rows, and this will be done differently by different layouting
// widgets. For instance a TreeViewColumn always lines up the areas from top to
// bottom while a IconView on the other hand might enforce that all areas
// received the same width and wrap the areas around, requesting height for more
// cell areas when allocated less width.
//
// It’s also important for areas to maintain some cell alignments with areas
// rendered for adjacent rows (cells can appear “columnized” inside an area even
// when the size of cells are different in each row). For this reason the
// CellArea uses a CellAreaContext object to store the alignments and sizes
// along the way (as well as the overall largest minimum and natural size for
// all the rows which have been calculated with the said context).
//
// The CellAreaContext is an opaque object specific to the CellArea which
// created it (see gtk_cell_area_create_context()). The owning cell-layouting
// widget can create as many contexts as it wishes to calculate sizes of rows
// which should receive the same size in at least one orientation (horizontally
// or vertically), However, it’s important that the same CellAreaContext which
// was used to request the sizes for a given TreeModel row be used when
// rendering or processing events for that row.
//
// In order to request the width of all the rows at the root level of a
// TreeModel one would do the following:
//
//    GtkTreeIter iter;
//    int         minimum_width;
//    int         natural_width;
//
//    valid = gtk_tree_model_get_iter_first (model, &iter);
//    while (valid)
//      {
//        gtk_cell_area_apply_attributes (area, model, &iter, FALSE, FALSE);
//        gtk_cell_area_get_preferred_width (area, context, widget, NULL, NULL);
//
//        valid = gtk_tree_model_iter_next (model, &iter);
//      }
//    gtk_cell_area_context_get_preferred_width (context, &minimum_width, &natural_width);
//
//
// Note that in this example it’s not important to observe the returned minimum
// and natural width of the area for each row unless the cell-layouting object
// is actually interested in the widths of individual rows. The overall width is
// however stored in the accompanying CellAreaContext object and can be
// consulted at any time.
//
// This can be useful since CellLayout widgets usually have to support
// requesting and rendering rows in treemodels with an exceedingly large amount
// of rows. The CellLayout widget in that case would calculate the required
// width of the rows in an idle or timeout source (see g_timeout_add()) and when
// the widget is requested its actual width in WidgetClass.measure() it can
// simply consult the width accumulated so far in the CellAreaContext object.
//
// A simple example where rows are rendered from top to bottom and take up the
// full width of the layouting widget would look like:
//
//    static void
//    foo_get_preferred_width (GtkWidget       *widget,
//                             int             *minimum_size,
//                             int             *natural_size)
//    {
//      Foo        *foo  = FOO (widget);
//      FooPrivate *priv = foo->priv;
//
//      foo_ensure_at_least_one_handfull_of_rows_have_been_requested (foo);
//
//      gtk_cell_area_context_get_preferred_width (priv->context, minimum_size, natural_size);
//    }
//
//
// In the above example the Foo widget has to make sure that some row sizes have
// been calculated (the amount of rows that Foo judged was appropriate to
// request space for in a single timeout iteration) before simply returning the
// amount of space required by the area via the CellAreaContext.
//
// Requesting the height for width (or width for height) of an area is a similar
// task except in this case the CellAreaContext does not store the data
// (actually, it does not know how much space the layouting widget plans to
// allocate it for every row. It’s up to the layouting widget to render each row
// of data with the appropriate height and width which was requested by the
// CellArea).
//
// In order to request the height for width of all the rows at the root level of
// a TreeModel one would do the following:
//
//    GtkTreeIter iter;
//    int         minimum_height;
//    int         natural_height;
//    int         full_minimum_height = 0;
//    int         full_natural_height = 0;
//
//    valid = gtk_tree_model_get_iter_first (model, &iter);
//    while (valid)
//      {
//        gtk_cell_area_apply_attributes (area, model, &iter, FALSE, FALSE);
//        gtk_cell_area_get_preferred_height_for_width (area, context, widget,
//                                                      width, &minimum_height, &natural_height);
//
//        if (width_is_for_allocation)
//           cache_row_height (&iter, minimum_height, natural_height);
//
//        full_minimum_height += minimum_height;
//        full_natural_height += natural_height;
//
//        valid = gtk_tree_model_iter_next (model, &iter);
//      }
//
//
// Note that in the above example we would need to cache the heights returned
// for each row so that we would know what sizes to render the areas for each
// row. However we would only want to really cache the heights if the request is
// intended for the layouting widgets real allocation.
//
// In some cases the layouting widget is requested the height for an arbitrary
// for_width, this is a special case for layouting widgets who need to request
// size for tens of thousands of rows. For this case it’s only important that
// the layouting widget calculate one reasonably sized chunk of rows and return
// that height synchronously. The reasoning here is that any layouting widget is
// at least capable of synchronously calculating enough height to fill the
// screen height (or scrolled window height) in response to a single call to
// WidgetClass.measure(). Returning a perfect height for width that is larger
// than the screen area is inconsequential since after the layouting receives an
// allocation from a scrolled window it simply continues to drive the scrollbar
// values while more and more height is required for the row heights that are
// calculated in the background.
//
//
// Rendering Areas
//
// Once area sizes have been acquired at least for the rows in the visible area
// of the layouting widget they can be rendered at WidgetClass.snapshot() time.
//
// A crude example of how to render all the rows at the root level runs as
// follows:
//
//    GtkAllocation allocation;
//    GdkRectangle  cell_area = { 0, };
//    GtkTreeIter   iter;
//    int           minimum_width;
//    int           natural_width;
//
//    gtk_widget_get_allocation (widget, &allocation);
//    cell_area.width = allocation.width;
//
//    valid = gtk_tree_model_get_iter_first (model, &iter);
//    while (valid)
//      {
//        cell_area.height = get_cached_height_for_row (&iter);
//
//        gtk_cell_area_apply_attributes (area, model, &iter, FALSE, FALSE);
//        gtk_cell_area_render (area, context, widget, cr,
//                              &cell_area, &cell_area, state_flags, FALSE);
//
//        cell_area.y += cell_area.height;
//
//        valid = gtk_tree_model_iter_next (model, &iter);
//      }
//
//
// Note that the cached height in this example really depends on how the
// layouting widget works. The layouting widget might decide to give every row
// its minimum or natural height or, if the model content is expected to fit
// inside the layouting widget without scrolling, it would make sense to
// calculate the allocation for each row at the time the widget is allocated
// using gtk_distribute_natural_allocation().
//
//
// Handling Events and Driving Keyboard Focus
//
// Passing events to the area is as simple as handling events on any normal
// widget and then passing them to the gtk_cell_area_event() API as they come
// in. Usually CellArea is only interested in button events, however some
// customized derived areas can be implemented who are interested in handling
// other events. Handling an event can trigger the CellArea::focus-changed
// signal to fire; as well as CellArea::add-editable in the case that an
// editable cell was clicked and needs to start editing. You can call
// gtk_cell_area_stop_editing() at any time to cancel any cell editing that is
// currently in progress.
//
// The CellArea drives keyboard focus from cell to cell in a way similar to
// Widget. For layouting widgets that support giving focus to cells it’s
// important to remember to pass GTK_CELL_RENDERER_FOCUSED to the area functions
// for the row that has focus and to tell the area to paint the focus at render
// time.
//
// Layouting widgets that accept focus on cells should implement the
// WidgetClass.focus() virtual method. The layouting widget is always
// responsible for knowing where TreeModel rows are rendered inside the widget,
// so at WidgetClass.focus() time the layouting widget should use the CellArea
// methods to navigate focus inside the area and then observe the
// GtkDirectionType to pass the focus to adjacent rows and areas.
//
// A basic example of how the WidgetClass.focus() virtual method should be
// implemented:
//
//    static gboolean
//    foo_focus (GtkWidget       *widget,
//               GtkDirectionType direction)
//    {
//      Foo        *foo  = FOO (widget);
//      FooPrivate *priv = foo->priv;
//      int         focus_row;
//      gboolean    have_focus = FALSE;
//
//      focus_row = priv->focus_row;
//
//      if (!gtk_widget_has_focus (widget))
//        gtk_widget_grab_focus (widget);
//
//      valid = gtk_tree_model_iter_nth_child (priv->model, &iter, NULL, priv->focus_row);
//      while (valid)
//        {
//          gtk_cell_area_apply_attributes (priv->area, priv->model, &iter, FALSE, FALSE);
//
//          if (gtk_cell_area_focus (priv->area, direction))
//            {
//               priv->focus_row = focus_row;
//               have_focus = TRUE;
//               break;
//            }
//          else
//            {
//              if (direction == GTK_DIR_RIGHT ||
//                  direction == GTK_DIR_LEFT)
//                break;
//              else if (direction == GTK_DIR_UP ||
//                       direction == GTK_DIR_TAB_BACKWARD)
//               {
//                  if (focus_row == 0)
//                    break;
//                  else
//                   {
//                      focus_row--;
//                      valid = gtk_tree_model_iter_nth_child (priv->model, &iter, NULL, focus_row);
//                   }
//                }
//              else
//                {
//                  if (focus_row == last_row)
//                    break;
//                  else
//                    {
//                      focus_row++;
//                      valid = gtk_tree_model_iter_next (priv->model, &iter);
//                    }
//                }
//            }
//        }
//        return have_focus;
//    }
//
//
// Note that the layouting widget is responsible for matching the
// GtkDirectionType values to the way it lays out its cells.
//
//
// Cell Properties
//
// The CellArea introduces cell properties for CellRenderers. This provides some
// general interfaces for defining the relationship cell areas have with their
// cells. For instance in a CellAreaBox a cell might “expand” and receive extra
// space when the area is allocated more than its full natural request, or a
// cell might be configured to “align” with adjacent rows which were requested
// and rendered with the same CellAreaContext.
//
// Use gtk_cell_area_class_install_cell_property() to install cell properties
// for a cell area class and gtk_cell_area_class_find_cell_property() or
// gtk_cell_area_class_list_cell_properties() to get information about existing
// cell properties.
//
// To set the value of a cell property, use gtk_cell_area_cell_set_property(),
// gtk_cell_area_cell_set() or gtk_cell_area_cell_set_valist(). To obtain the
// value of a cell property, use gtk_cell_area_cell_get_property(),
// gtk_cell_area_cell_get() or gtk_cell_area_cell_get_valist().
type CellArea interface {
	gextras.Objector

	// Activate: activates @area, usually by activating the currently focused
	// cell, however some subclasses which embed widgets in the area can also
	// activate a widget if it currently has the focus.
	Activate(context CellAreaContext, widget Widget, cellArea *gdk.Rectangle, flags CellRendererState, editOnly bool) bool
	// ActivateCell: this is used by CellArea subclasses when handling events to
	// activate cells, the base CellArea class activates cells for keyboard
	// events for free in its own GtkCellArea->activate() implementation.
	ActivateCell(widget Widget, renderer CellRenderer, event gdk.Event, cellArea *gdk.Rectangle, flags CellRendererState) bool
	// Add: adds @renderer to @area with the default child cell properties.
	Add(renderer CellRenderer)
	// AddFocusSibling: adds @sibling to @renderer’s focusable area, focus will
	// be drawn around @renderer and all of its siblings if @renderer can focus
	// for a given row.
	//
	// Events handled by focus siblings can also activate the given focusable
	// @renderer.
	AddFocusSibling(renderer CellRenderer, sibling CellRenderer)
	// ApplyAttributes: applies any connected attributes to the renderers in
	// @area by pulling the values from @tree_model.
	ApplyAttributes(treeModel TreeModel, iter *TreeIter, isExpander bool, isExpanded bool)
	// AttributeConnect: connects an @attribute to apply values from @column for
	// the TreeModel in use.
	AttributeConnect(renderer CellRenderer, attribute string, column int)
	// AttributeDisconnect: disconnects @attribute for the @renderer in @area so
	// that attribute will no longer be updated with values from the model.
	AttributeDisconnect(renderer CellRenderer, attribute string)
	// AttributeGetColumn: returns the model column that an attribute has been
	// mapped to, or -1 if the attribute is not mapped.
	AttributeGetColumn(renderer CellRenderer, attribute string) int
	// CellGetProperty: gets the value of a cell property for @renderer in
	// @area.
	CellGetProperty(renderer CellRenderer, propertyName string, value *externglib.Value)
	// CellSetProperty: sets a cell property for @renderer in @area.
	CellSetProperty(renderer CellRenderer, propertyName string, value *externglib.Value)
	// CopyContext: this is sometimes needed for cases where rows need to share
	// alignments in one orientation but may be separately grouped in the
	// opposing orientation.
	//
	// For instance, IconView creates all icons (rows) to have the same width
	// and the cells theirin to have the same horizontal alignments. However
	// each row of icons may have a separate collective height. IconView uses
	// this to request the heights of each row based on a context which was
	// already used to request all the row widths that are to be displayed.
	CopyContext(context CellAreaContext) CellAreaContext
	// CreateContext: creates a CellAreaContext to be used with @area for all
	// purposes. CellAreaContext stores geometry information for rows for which
	// it was operated on, it is important to use the same context for the same
	// row of data at all times (i.e. one should render and handle events with
	// the same CellAreaContext which was used to request the size of those rows
	// of data).
	CreateContext() CellAreaContext
	// Event: delegates event handling to a CellArea.
	Event(context CellAreaContext, widget Widget, event gdk.Event, cellArea *gdk.Rectangle, flags CellRendererState) int
	// Focus: this should be called by the @area’s owning layout widget when
	// focus is to be passed to @area, or moved within @area for a given
	// @direction and row data.
	//
	// Implementing CellArea classes should implement this method to receive and
	// navigate focus in its own way particular to how it lays out cells.
	Focus(direction DirectionType) bool
	// Foreach: calls @callback for every CellRenderer in @area.
	Foreach(callback CellCallback)
	// ForeachAlloc: calls @callback for every CellRenderer in @area with the
	// allocated rectangle inside @cell_area.
	ForeachAlloc(context CellAreaContext, widget Widget, cellArea *gdk.Rectangle, backgroundArea *gdk.Rectangle, callback CellAllocCallback)
	// CellAllocation: derives the allocation of @renderer inside @area if @area
	// were to be renderered in @cell_area.
	CellAllocation(context CellAreaContext, widget Widget, renderer CellRenderer, cellArea *gdk.Rectangle) gdk.Rectangle
	// CellAtPosition: gets the CellRenderer at @x and @y coordinates inside
	// @area and optionally returns the full cell allocation for it inside
	// @cell_area.
	CellAtPosition(context CellAreaContext, widget Widget, cellArea *gdk.Rectangle, x int, y int) (allocArea gdk.Rectangle, cellRenderer CellRenderer)
	// CurrentPathString: gets the current TreePath string for the currently
	// applied TreeIter, this is implicitly updated when
	// gtk_cell_area_apply_attributes() is called and can be used to interact
	// with renderers from CellArea subclasses.
	CurrentPathString() string
	// EditWidget: gets the CellEditable widget currently used to edit the
	// currently edited cell.
	EditWidget() CellEditable
	// EditedCell: gets the CellRenderer in @area that is currently being
	// edited.
	EditedCell() CellRenderer
	// FocusCell: retrieves the currently focused cell for @area
	FocusCell() CellRenderer
	// FocusFromSibling: gets the CellRenderer which is expected to be focusable
	// for which @renderer is, or may be a sibling.
	//
	// This is handy for CellArea subclasses when handling events, after
	// determining the renderer at the event location it can then chose to
	// activate the focus cell for which the event cell may have been a sibling.
	FocusFromSibling(renderer CellRenderer) CellRenderer
	// FocusSiblings: gets the focus sibling cell renderers for @renderer.
	FocusSiblings(renderer CellRenderer) *glib.List
	// PreferredHeight: retrieves a cell area’s initial minimum and natural
	// height.
	//
	// @area will store some geometrical information in @context along the way;
	// when requesting sizes over an arbitrary number of rows, it’s not
	// important to check the @minimum_height and @natural_height of this call
	// but rather to consult gtk_cell_area_context_get_preferred_height() after
	// a series of requests.
	PreferredHeight(context CellAreaContext, widget Widget) (minimumHeight int, naturalHeight int)
	// PreferredHeightForWidth: retrieves a cell area’s minimum and natural
	// height if it would be given the specified @width.
	//
	// @area stores some geometrical information in @context along the way while
	// calling gtk_cell_area_get_preferred_width(). It’s important to perform a
	// series of gtk_cell_area_get_preferred_width() requests with @context
	// first and then call gtk_cell_area_get_preferred_height_for_width() on
	// each cell area individually to get the height for width of each fully
	// requested row.
	//
	// If at some point, the width of a single row changes, it should be
	// requested with gtk_cell_area_get_preferred_width() again and then the
	// full width of the requested rows checked again with
	// gtk_cell_area_context_get_preferred_width().
	PreferredHeightForWidth(context CellAreaContext, widget Widget, width int) (minimumHeight int, naturalHeight int)
	// PreferredWidth: retrieves a cell area’s initial minimum and natural
	// width.
	//
	// @area will store some geometrical information in @context along the way;
	// when requesting sizes over an arbitrary number of rows, it’s not
	// important to check the @minimum_width and @natural_width of this call but
	// rather to consult gtk_cell_area_context_get_preferred_width() after a
	// series of requests.
	PreferredWidth(context CellAreaContext, widget Widget) (minimumWidth int, naturalWidth int)
	// PreferredWidthForHeight: retrieves a cell area’s minimum and natural
	// width if it would be given the specified @height.
	//
	// @area stores some geometrical information in @context along the way while
	// calling gtk_cell_area_get_preferred_height(). It’s important to perform a
	// series of gtk_cell_area_get_preferred_height() requests with @context
	// first and then call gtk_cell_area_get_preferred_width_for_height() on
	// each cell area individually to get the height for width of each fully
	// requested row.
	//
	// If at some point, the height of a single row changes, it should be
	// requested with gtk_cell_area_get_preferred_height() again and then the
	// full height of the requested rows checked again with
	// gtk_cell_area_context_get_preferred_height().
	PreferredWidthForHeight(context CellAreaContext, widget Widget, height int) (minimumWidth int, naturalWidth int)
	// RequestMode: gets whether the area prefers a height-for-width layout or a
	// width-for-height layout.
	RequestMode() SizeRequestMode
	// HasRenderer: checks if @area contains @renderer.
	HasRenderer(renderer CellRenderer) bool
	// InnerCellArea: this is a convenience function for CellArea
	// implementations to get the inner area where a given CellRenderer will be
	// rendered. It removes any padding previously added by
	// gtk_cell_area_request_renderer().
	InnerCellArea(widget Widget, cellArea *gdk.Rectangle) gdk.Rectangle
	// IsActivatable: returns whether the area can do anything when activated,
	// after applying new attributes to @area.
	IsActivatable() bool
	// IsFocusSibling: returns whether @sibling is one of @renderer’s focus
	// siblings (see gtk_cell_area_add_focus_sibling()).
	IsFocusSibling(renderer CellRenderer, sibling CellRenderer) bool
	// Remove: removes @renderer from @area.
	Remove(renderer CellRenderer)
	// RemoveFocusSibling: removes @sibling from @renderer’s focus sibling list
	// (see gtk_cell_area_add_focus_sibling()).
	RemoveFocusSibling(renderer CellRenderer, sibling CellRenderer)
	// RequestRenderer: this is a convenience function for CellArea
	// implementations to request size for cell renderers. It’s important to use
	// this function to request size and then use
	// gtk_cell_area_inner_cell_area() at render and event time since this
	// function will add padding around the cell for focus painting.
	RequestRenderer(renderer CellRenderer, orientation Orientation, widget Widget, forSize int) (minimumSize int, naturalSize int)
	// SetFocusCell: explicitly sets the currently focused cell to @renderer.
	//
	// This is generally called by implementations of CellAreaClass.focus() or
	// CellAreaClass.event(), however it can also be used to implement functions
	// such as gtk_tree_view_set_cursor_on_cell().
	SetFocusCell(renderer CellRenderer)
	// Snapshot: snapshots @area’s cells according to @area’s layout onto at the
	// given coordinates.
	Snapshot(context CellAreaContext, widget Widget, snapshot Snapshot, backgroundArea *gdk.Rectangle, cellArea *gdk.Rectangle, flags CellRendererState, paintFocus bool)
	// StopEditing: explicitly stops the editing of the currently edited cell.
	//
	// If @canceled is true, the currently edited cell renderer will emit the
	// ::editing-canceled signal, otherwise the the ::editing-done signal will
	// be emitted on the current edit widget.
	//
	// See gtk_cell_area_get_edited_cell() and gtk_cell_area_get_edit_widget().
	StopEditing(canceled bool)
}

type cellArea struct {
	externglib.InitiallyUnowned
}

func wrapCellArea(obj *externglib.Object) CellArea {
	return cellArea{externglib.InitiallyUnowned{obj}}
}

func marshalCellArea(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func (c cellArea) Activate(context CellAreaContext, widget Widget, cellArea *gdk.Rectangle, flags CellRendererState, editOnly bool) bool

func (c cellArea) ActivateCell(widget Widget, renderer CellRenderer, event gdk.Event, cellArea *gdk.Rectangle, flags CellRendererState) bool

func (c cellArea) Add(renderer CellRenderer)

func (c cellArea) AddFocusSibling(renderer CellRenderer, sibling CellRenderer)

func (c cellArea) ApplyAttributes(treeModel TreeModel, iter *TreeIter, isExpander bool, isExpanded bool)

func (c cellArea) AttributeConnect(renderer CellRenderer, attribute string, column int)

func (c cellArea) AttributeDisconnect(renderer CellRenderer, attribute string)

func (c cellArea) AttributeGetColumn(renderer CellRenderer, attribute string) int

func (c cellArea) CellGetProperty(renderer CellRenderer, propertyName string, value *externglib.Value)

func (c cellArea) CellSetProperty(renderer CellRenderer, propertyName string, value *externglib.Value)

func (c cellArea) CopyContext(context CellAreaContext) CellAreaContext

func (c cellArea) CreateContext() CellAreaContext

func (c cellArea) Event(context CellAreaContext, widget Widget, event gdk.Event, cellArea *gdk.Rectangle, flags CellRendererState) int

func (c cellArea) Focus(direction DirectionType) bool

func (c cellArea) Foreach(callback CellCallback)

func (c cellArea) ForeachAlloc(context CellAreaContext, widget Widget, cellArea *gdk.Rectangle, backgroundArea *gdk.Rectangle, callback CellAllocCallback)

func (c cellArea) CellAllocation(context CellAreaContext, widget Widget, renderer CellRenderer, cellArea *gdk.Rectangle) gdk.Rectangle

func (c cellArea) CellAtPosition(context CellAreaContext, widget Widget, cellArea *gdk.Rectangle, x int, y int) (allocArea gdk.Rectangle, cellRenderer CellRenderer)

func (c cellArea) CurrentPathString() string

func (c cellArea) EditWidget() CellEditable

func (c cellArea) EditedCell() CellRenderer

func (c cellArea) FocusCell() CellRenderer

func (c cellArea) FocusFromSibling(renderer CellRenderer) CellRenderer

func (c cellArea) FocusSiblings(renderer CellRenderer) *glib.List

func (c cellArea) PreferredHeight(context CellAreaContext, widget Widget) (minimumHeight int, naturalHeight int)

func (c cellArea) PreferredHeightForWidth(context CellAreaContext, widget Widget, width int) (minimumHeight int, naturalHeight int)

func (c cellArea) PreferredWidth(context CellAreaContext, widget Widget) (minimumWidth int, naturalWidth int)

func (c cellArea) PreferredWidthForHeight(context CellAreaContext, widget Widget, height int) (minimumWidth int, naturalWidth int)

func (c cellArea) RequestMode() SizeRequestMode

func (c cellArea) HasRenderer(renderer CellRenderer) bool

func (c cellArea) InnerCellArea(widget Widget, cellArea *gdk.Rectangle) gdk.Rectangle

func (c cellArea) IsActivatable() bool

func (c cellArea) IsFocusSibling(renderer CellRenderer, sibling CellRenderer) bool

func (c cellArea) Remove(renderer CellRenderer)

func (c cellArea) RemoveFocusSibling(renderer CellRenderer, sibling CellRenderer)

func (c cellArea) RequestRenderer(renderer CellRenderer, orientation Orientation, widget Widget, forSize int) (minimumSize int, naturalSize int)

func (c cellArea) SetFocusCell(renderer CellRenderer)

func (c cellArea) Snapshot(context CellAreaContext, widget Widget, snapshot Snapshot, backgroundArea *gdk.Rectangle, cellArea *gdk.Rectangle, flags CellRendererState, paintFocus bool)

func (c cellArea) StopEditing(canceled bool)

// CellAreaBox: the CellAreaBox renders cell renderers into a row or a column
// depending on its Orientation.
//
// GtkCellAreaBox uses a notion of packing. Packing refers to adding cell
// renderers with reference to a particular position in a CellAreaBox. There are
// two reference positions: the start and the end of the box. When the
// CellAreaBox is oriented in the GTK_ORIENTATION_VERTICAL orientation, the
// start is defined as the top of the box and the end is defined as the bottom.
// In the GTK_ORIENTATION_HORIZONTAL orientation start is defined as the left
// side and the end is defined as the right side.
//
// Alignments of CellRenderers rendered in adjacent rows can be configured by
// configuring the CellAreaBox align child cell property with
// gtk_cell_area_cell_set_property() or by specifying the "align" argument to
// gtk_cell_area_box_pack_start() and gtk_cell_area_box_pack_end().
type CellAreaBox interface {
	CellArea

	// Spacing: gets the spacing added between cell renderers.
	Spacing() int
	// PackEnd: adds @renderer to @box, packed with reference to the end of
	// @box.
	//
	// The @renderer is packed after (away from end of) any other CellRenderer
	// packed with reference to the end of @box.
	PackEnd(renderer CellRenderer, expand bool, align bool, fixed bool)
	// PackStart: adds @renderer to @box, packed with reference to the start of
	// @box.
	//
	// The @renderer is packed after any other CellRenderer packed with
	// reference to the start of @box.
	PackStart(renderer CellRenderer, expand bool, align bool, fixed bool)
	// SetSpacing: sets the spacing to add between cell renderers in @box.
	SetSpacing(spacing int)
}

type cellAreaBox struct {
	cellArea
}

func wrapCellAreaBox(obj *externglib.Object) CellAreaBox {
	return cellAreaBox{cellArea{externglib.InitiallyUnowned{obj}}}
}

func marshalCellAreaBox(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewCellAreaBox() CellAreaBox

func (c cellAreaBox) Spacing() int

func (c cellAreaBox) PackEnd(renderer CellRenderer, expand bool, align bool, fixed bool)

func (c cellAreaBox) PackStart(renderer CellRenderer, expand bool, align bool, fixed bool)

func (c cellAreaBox) SetSpacing(spacing int)

// CellAreaContext: the CellAreaContext object is created by a given CellArea
// implementation via its CellAreaClass.create_context() virtual method and is
// used to store cell sizes and alignments for a series of TreeModel rows that
// are requested and rendered in the same context.
//
// CellLayout widgets can create any number of contexts in which to request and
// render groups of data rows. However, it’s important that the same context
// which was used to request sizes for a given TreeModel row also be used for
// the same row when calling other CellArea APIs such as gtk_cell_area_render()
// and gtk_cell_area_event().
type CellAreaContext interface {
	gextras.Objector

	// Allocate: allocates a width and/or a height for all rows which are to be
	// rendered with @context.
	//
	// Usually allocation is performed only horizontally or sometimes vertically
	// since a group of rows are usually rendered side by side vertically or
	// horizontally and share either the same width or the same height.
	// Sometimes they are allocated in both horizontal and vertical orientations
	// producing a homogeneous effect of the rows. This is generally the case
	// for TreeView when TreeView:fixed-height-mode is enabled.
	Allocate(width int, height int)
	// Allocation: fetches the current allocation size for @context.
	//
	// If the context was not allocated in width or height, or if the context
	// was recently reset with gtk_cell_area_context_reset(), the returned value
	// will be -1.
	Allocation() (width int, height int)
	// Area: fetches the CellArea this @context was created by.
	//
	// This is generally unneeded by layouting widgets; however, it is important
	// for the context implementation itself to fetch information about the area
	// it is being used for.
	//
	// For instance at CellAreaContextClass.allocate() time it’s important to
	// know details about any cell spacing that the CellArea is configured with
	// in order to compute a proper allocation.
	Area() CellArea
	// PreferredHeight: gets the accumulative preferred height for all rows
	// which have been requested with this context.
	//
	// After gtk_cell_area_context_reset() is called and/or before ever
	// requesting the size of a CellArea, the returned values are 0.
	PreferredHeight() (minimumHeight int, naturalHeight int)
	// PreferredHeightForWidth: gets the accumulative preferred height for
	// @width for all rows which have been requested for the same said @width
	// with this context.
	//
	// After gtk_cell_area_context_reset() is called and/or before ever
	// requesting the size of a CellArea, the returned values are -1.
	PreferredHeightForWidth(width int) (minimumHeight int, naturalHeight int)
	// PreferredWidth: gets the accumulative preferred width for all rows which
	// have been requested with this context.
	//
	// After gtk_cell_area_context_reset() is called and/or before ever
	// requesting the size of a CellArea, the returned values are 0.
	PreferredWidth() (minimumWidth int, naturalWidth int)
	// PreferredWidthForHeight: gets the accumulative preferred width for
	// @height for all rows which have been requested for the same said @height
	// with this context.
	//
	// After gtk_cell_area_context_reset() is called and/or before ever
	// requesting the size of a CellArea, the returned values are -1.
	PreferredWidthForHeight(height int) (minimumWidth int, naturalWidth int)
	// PushPreferredHeight: causes the minimum and/or natural height to grow if
	// the new proposed sizes exceed the current minimum and natural height.
	//
	// This is used by CellAreaContext implementations during the request
	// process over a series of TreeModel rows to progressively push the
	// requested height over a series of gtk_cell_area_get_preferred_height()
	// requests.
	PushPreferredHeight(minimumHeight int, naturalHeight int)
	// PushPreferredWidth: causes the minimum and/or natural width to grow if
	// the new proposed sizes exceed the current minimum and natural width.
	//
	// This is used by CellAreaContext implementations during the request
	// process over a series of TreeModel rows to progressively push the
	// requested width over a series of gtk_cell_area_get_preferred_width()
	// requests.
	PushPreferredWidth(minimumWidth int, naturalWidth int)
	// Reset: resets any previously cached request and allocation data.
	//
	// When underlying TreeModel data changes its important to reset the context
	// if the content size is allowed to shrink. If the content size is only
	// allowed to grow (this is usually an option for views rendering large data
	// stores as a measure of optimization), then only the row that changed or
	// was inserted needs to be (re)requested with
	// gtk_cell_area_get_preferred_width().
	//
	// When the new overall size of the context requires that the allocated size
	// changes (or whenever this allocation changes at all), the variable row
	// sizes need to be re-requested for every row.
	//
	// For instance, if the rows are displayed all with the same width from top
	// to bottom then a change in the allocated width necessitates a
	// recalculation of all the displayed row heights using
	// gtk_cell_area_get_preferred_height_for_width().
	Reset()
}

type cellAreaContext struct {
	*externglib.Object
}

func wrapCellAreaContext(obj *externglib.Object) CellAreaContext {
	return cellAreaContext{*externglib.Object{obj}}
}

func marshalCellAreaContext(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func (c cellAreaContext) Allocate(width int, height int)

func (c cellAreaContext) Allocation() (width int, height int)

func (c cellAreaContext) Area() CellArea

func (c cellAreaContext) PreferredHeight() (minimumHeight int, naturalHeight int)

func (c cellAreaContext) PreferredHeightForWidth(width int) (minimumHeight int, naturalHeight int)

func (c cellAreaContext) PreferredWidth() (minimumWidth int, naturalWidth int)

func (c cellAreaContext) PreferredWidthForHeight(height int) (minimumWidth int, naturalWidth int)

func (c cellAreaContext) PushPreferredHeight(minimumHeight int, naturalHeight int)

func (c cellAreaContext) PushPreferredWidth(minimumWidth int, naturalWidth int)

func (c cellAreaContext) Reset()

// CellRenderer: the CellRenderer is a base class of a set of objects used for
// rendering a cell to a #cairo_t. These objects are used primarily by the
// TreeView widget, though they aren’t tied to them in any specific way. It is
// worth noting that CellRenderer is not a Widget and cannot be treated as such.
//
// The primary use of a CellRenderer is for drawing a certain graphical elements
// on a #cairo_t. Typically, one cell renderer is used to draw many cells on the
// screen. To this extent, it isn’t expected that a CellRenderer keep any
// permanent state around. Instead, any state is set just prior to use using
// #GObjects property system. Then, the cell is measured using
// gtk_cell_renderer_get_preferred_size(). Finally, the cell is rendered in the
// correct location using gtk_cell_renderer_snapshot().
//
// There are a number of rules that must be followed when writing a new
// CellRenderer. First and foremost, it’s important that a certain set of
// properties will always yield a cell renderer of the same size, barring a
// style change. The CellRenderer also has a number of generic properties that
// are expected to be honored by all children.
//
// Beyond merely rendering a cell, cell renderers can optionally provide active
// user interface elements. A cell renderer can be “activatable” like
// CellRendererToggle, which toggles when it gets activated by a mouse click, or
// it can be “editable” like CellRendererText, which allows the user to edit the
// text using a widget implementing the CellEditable interface, e.g. Entry. To
// make a cell renderer activatable or editable, you have to implement the
// CellRendererClass.activate or CellRendererClass.start_editing virtual
// functions, respectively.
//
// Many properties of CellRenderer and its subclasses have a corresponding “set”
// property, e.g. “cell-background-set” corresponds to “cell-background”. These
// “set” properties reflect whether a property has been set or not. You should
// not set them independently.
type CellRenderer interface {
	gextras.Objector

	// Activate: passes an activate event to the cell renderer for possible
	// processing. Some cell renderers may use events; for example,
	// CellRendererToggle toggles when it gets a mouse click.
	Activate(event gdk.Event, widget Widget, path string, backgroundArea *gdk.Rectangle, cellArea *gdk.Rectangle, flags CellRendererState) bool
	// AlignedArea: gets the aligned area used by @cell inside @cell_area. Used
	// for finding the appropriate edit and focus rectangle.
	AlignedArea(widget Widget, flags CellRendererState, cellArea *gdk.Rectangle) gdk.Rectangle
	// Alignment: fills in @xalign and @yalign with the appropriate values of
	// @cell.
	Alignment() (xalign float32, yalign float32)
	// FixedSize: fills in @width and @height with the appropriate size of
	// @cell.
	FixedSize() (width int, height int)
	// IsExpanded: checks whether the given CellRenderer is expanded.
	IsExpanded() bool
	// IsExpander: checks whether the given CellRenderer is an expander.
	IsExpander() bool
	// Padding: fills in @xpad and @ypad with the appropriate values of @cell.
	Padding() (xpad int, ypad int)
	// PreferredHeight: retrieves a renderer’s natural size when rendered to
	// @widget.
	PreferredHeight(widget Widget) (minimumSize int, naturalSize int)
	// PreferredHeightForWidth: retrieves a cell renderers’s minimum and natural
	// height if it were rendered to @widget with the specified @width.
	PreferredHeightForWidth(widget Widget, width int) (minimumHeight int, naturalHeight int)
	// PreferredSize: retrieves the minimum and natural size of a cell taking
	// into account the widget’s preference for height-for-width management.
	PreferredSize(widget Widget) (minimumSize Requisition, naturalSize Requisition)
	// PreferredWidth: retrieves a renderer’s natural size when rendered to
	// @widget.
	PreferredWidth(widget Widget) (minimumSize int, naturalSize int)
	// PreferredWidthForHeight: retrieves a cell renderers’s minimum and natural
	// width if it were rendered to @widget with the specified @height.
	PreferredWidthForHeight(widget Widget, height int) (minimumWidth int, naturalWidth int)
	// RequestMode: gets whether the cell renderer prefers a height-for-width
	// layout or a width-for-height layout.
	RequestMode() SizeRequestMode
	// Sensitive: returns the cell renderer’s sensitivity.
	Sensitive() bool
	// State: translates the cell renderer state to StateFlags, based on the
	// cell renderer and widget sensitivity, and the given CellRendererState.
	State(widget Widget, cellState CellRendererState) StateFlags
	// Visible: returns the cell renderer’s visibility.
	Visible() bool
	// IsActivatable: checks whether the cell renderer can do something when
	// activated.
	IsActivatable() bool
	// SetAlignment: sets the renderer’s alignment within its available space.
	SetAlignment(xalign float32, yalign float32)
	// SetFixedSize: sets the renderer size to be explicit, independent of the
	// properties set.
	SetFixedSize(width int, height int)
	// SetIsExpanded: sets whether the given CellRenderer is expanded.
	SetIsExpanded(isExpanded bool)
	// SetIsExpander: sets whether the given CellRenderer is an expander.
	SetIsExpander(isExpander bool)
	// SetPadding: sets the renderer’s padding.
	SetPadding(xpad int, ypad int)
	// SetSensitive: sets the cell renderer’s sensitivity.
	SetSensitive(sensitive bool)
	// SetVisible: sets the cell renderer’s visibility.
	SetVisible(visible bool)
	// Snapshot: invokes the virtual render function of the CellRenderer. The
	// three passed-in rectangles are areas in @cr. Most renderers will draw
	// within @cell_area; the xalign, yalign, xpad, and ypad fields of the
	// CellRenderer should be honored with respect to @cell_area.
	// @background_area includes the blank space around the cell, and also the
	// area containing the tree expander; so the @background_area rectangles for
	// all cells tile to cover the entire @window.
	Snapshot(snapshot Snapshot, widget Widget, backgroundArea *gdk.Rectangle, cellArea *gdk.Rectangle, flags CellRendererState)
	// StartEditing: starts editing the contents of this @cell, through a new
	// CellEditable widget created by the CellRendererClass.start_editing
	// virtual function.
	StartEditing(event gdk.Event, widget Widget, path string, backgroundArea *gdk.Rectangle, cellArea *gdk.Rectangle, flags CellRendererState) CellEditable
	// StopEditing: informs the cell renderer that the editing is stopped. If
	// @canceled is true, the cell renderer will emit the
	// CellRenderer::editing-canceled signal.
	//
	// This function should be called by cell renderer implementations in
	// response to the CellEditable::editing-done signal of CellEditable.
	StopEditing(canceled bool)
}

type cellRenderer struct {
	externglib.InitiallyUnowned
}

func wrapCellRenderer(obj *externglib.Object) CellRenderer {
	return cellRenderer{externglib.InitiallyUnowned{obj}}
}

func marshalCellRenderer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func (c cellRenderer) Activate(event gdk.Event, widget Widget, path string, backgroundArea *gdk.Rectangle, cellArea *gdk.Rectangle, flags CellRendererState) bool

func (c cellRenderer) AlignedArea(widget Widget, flags CellRendererState, cellArea *gdk.Rectangle) gdk.Rectangle

func (c cellRenderer) Alignment() (xalign float32, yalign float32)

func (c cellRenderer) FixedSize() (width int, height int)

func (c cellRenderer) IsExpanded() bool

func (c cellRenderer) IsExpander() bool

func (c cellRenderer) Padding() (xpad int, ypad int)

func (c cellRenderer) PreferredHeight(widget Widget) (minimumSize int, naturalSize int)

func (c cellRenderer) PreferredHeightForWidth(widget Widget, width int) (minimumHeight int, naturalHeight int)

func (c cellRenderer) PreferredSize(widget Widget) (minimumSize Requisition, naturalSize Requisition)

func (c cellRenderer) PreferredWidth(widget Widget) (minimumSize int, naturalSize int)

func (c cellRenderer) PreferredWidthForHeight(widget Widget, height int) (minimumWidth int, naturalWidth int)

func (c cellRenderer) RequestMode() SizeRequestMode

func (c cellRenderer) Sensitive() bool

func (c cellRenderer) State(widget Widget, cellState CellRendererState) StateFlags

func (c cellRenderer) Visible() bool

func (c cellRenderer) IsActivatable() bool

func (c cellRenderer) SetAlignment(xalign float32, yalign float32)

func (c cellRenderer) SetFixedSize(width int, height int)

func (c cellRenderer) SetIsExpanded(isExpanded bool)

func (c cellRenderer) SetIsExpander(isExpander bool)

func (c cellRenderer) SetPadding(xpad int, ypad int)

func (c cellRenderer) SetSensitive(sensitive bool)

func (c cellRenderer) SetVisible(visible bool)

func (c cellRenderer) Snapshot(snapshot Snapshot, widget Widget, backgroundArea *gdk.Rectangle, cellArea *gdk.Rectangle, flags CellRendererState)

func (c cellRenderer) StartEditing(event gdk.Event, widget Widget, path string, backgroundArea *gdk.Rectangle, cellArea *gdk.Rectangle, flags CellRendererState) CellEditable

func (c cellRenderer) StopEditing(canceled bool)

// CellRendererAccel displays a keyboard accelerator (i.e. a key combination
// like `Control + a`). If the cell renderer is editable, the accelerator can be
// changed by simply typing the new combination.
type CellRendererAccel interface {
	CellRendererText
}

type cellRendererAccel struct {
	cellRendererText
}

func wrapCellRendererAccel(obj *externglib.Object) CellRendererAccel {
	return cellRendererAccel{cellRendererText{cellRenderer{externglib.InitiallyUnowned{obj}}}}
}

func marshalCellRendererAccel(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewCellRendererAccel() CellRendererAccel

// CellRendererCombo renders text in a cell like CellRendererText from which it
// is derived. But while CellRendererText offers a simple entry to edit the
// text, CellRendererCombo offers a ComboBox widget to edit the text. The values
// to display in the combo box are taken from the tree model specified in the
// CellRendererCombo:model property.
//
// The combo cell renderer takes care of adding a text cell renderer to the
// combo box and sets it to display the column specified by its
// CellRendererCombo:text-column property. Further properties of the combo box
// can be set in a handler for the CellRenderer::editing-started signal.
type CellRendererCombo interface {
	CellRendererText
}

type cellRendererCombo struct {
	cellRendererText
}

func wrapCellRendererCombo(obj *externglib.Object) CellRendererCombo {
	return cellRendererCombo{cellRendererText{cellRenderer{externglib.InitiallyUnowned{obj}}}}
}

func marshalCellRendererCombo(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewCellRendererCombo() CellRendererCombo

// CellRendererPixbuf: a CellRendererPixbuf can be used to render an image in a
// cell. It allows to render either a given Pixbuf (set via the
// CellRendererPixbuf:pixbuf property) or a named icon (set via the
// CellRendererPixbuf:icon-name property).
//
// To support the tree view, CellRendererPixbuf also supports rendering two
// alternative pixbufs, when the CellRenderer:is-expander property is true. If
// the CellRenderer:is-expanded property is true and the
// CellRendererPixbuf:pixbuf-expander-open property is set to a pixbuf, it
// renders that pixbuf, if the CellRenderer:is-expanded property is false and
// the CellRendererPixbuf:pixbuf-expander-closed property is set to a pixbuf, it
// renders that one.
type CellRendererPixbuf interface {
	CellRenderer
}

type cellRendererPixbuf struct {
	cellRenderer
}

func wrapCellRendererPixbuf(obj *externglib.Object) CellRendererPixbuf {
	return cellRendererPixbuf{cellRenderer{externglib.InitiallyUnowned{obj}}}
}

func marshalCellRendererPixbuf(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewCellRendererPixbuf() CellRendererPixbuf

// CellRendererProgress renders a numeric value as a progress par in a cell.
// Additionally, it can display a text on top of the progress bar.
type CellRendererProgress interface {
	CellRenderer
}

type cellRendererProgress struct {
	cellRenderer
}

func wrapCellRendererProgress(obj *externglib.Object) CellRendererProgress {
	return cellRendererProgress{cellRenderer{externglib.InitiallyUnowned{obj}}}
}

func marshalCellRendererProgress(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewCellRendererProgress() CellRendererProgress

// CellRendererSpin renders text in a cell like CellRendererText from which it
// is derived. But while CellRendererText offers a simple entry to edit the
// text, CellRendererSpin offers a SpinButton widget. Of course, that means that
// the text has to be parseable as a floating point number.
//
// The range of the spinbutton is taken from the adjustment property of the cell
// renderer, which can be set explicitly or mapped to a column in the tree
// model, like all properties of cell renders. CellRendererSpin also has
// properties for the CellRendererSpin:climb-rate and the number of
// CellRendererSpin:digits to display. Other SpinButton properties can be set in
// a handler for the CellRenderer::editing-started signal.
//
// The CellRendererSpin cell renderer was added in GTK 2.10.
type CellRendererSpin interface {
	CellRendererText
}

type cellRendererSpin struct {
	cellRendererText
}

func wrapCellRendererSpin(obj *externglib.Object) CellRendererSpin {
	return cellRendererSpin{cellRendererText{cellRenderer{externglib.InitiallyUnowned{obj}}}}
}

func marshalCellRendererSpin(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewCellRendererSpin() CellRendererSpin

// CellRendererSpinner: gtkCellRendererSpinner renders a spinning animation in a
// cell, very similar to Spinner. It can often be used as an alternative to a
// CellRendererProgress for displaying indefinite activity, instead of actual
// progress.
//
// To start the animation in a cell, set the CellRendererSpinner:active property
// to true and increment the CellRendererSpinner:pulse property at regular
// intervals. The usual way to set the cell renderer properties for each cell is
// to bind them to columns in your tree model using e.g.
// gtk_tree_view_column_add_attribute().
type CellRendererSpinner interface {
	CellRenderer
}

type cellRendererSpinner struct {
	cellRenderer
}

func wrapCellRendererSpinner(obj *externglib.Object) CellRendererSpinner {
	return cellRendererSpinner{cellRenderer{externglib.InitiallyUnowned{obj}}}
}

func marshalCellRendererSpinner(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewCellRendererSpinner() CellRendererSpinner

// CellRendererText: a CellRendererText renders a given text in its cell, using
// the font, color and style information provided by its properties. The text
// will be ellipsized if it is too long and the CellRendererText:ellipsize
// property allows it.
//
// If the CellRenderer:mode is GTK_CELL_RENDERER_MODE_EDITABLE, the
// CellRendererText allows to edit its text using an entry.
type CellRendererText interface {
	CellRenderer

	// SetFixedHeightFromFont: sets the height of a renderer to explicitly be
	// determined by the “font” and “y_pad” property set on it. Further changes
	// in these properties do not affect the height, so they must be accompanied
	// by a subsequent call to this function. Using this function is inflexible,
	// and should really only be used if calculating the size of a cell is too
	// slow (ie, a massive number of cells displayed). If @number_of_rows is -1,
	// then the fixed height is unset, and the height is determined by the
	// properties again.
	SetFixedHeightFromFont(numberOfRows int)
}

type cellRendererText struct {
	cellRenderer
}

func wrapCellRendererText(obj *externglib.Object) CellRendererText {
	return cellRendererText{cellRenderer{externglib.InitiallyUnowned{obj}}}
}

func marshalCellRendererText(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewCellRendererText() CellRendererText

func (c cellRendererText) SetFixedHeightFromFont(numberOfRows int)

// CellRendererToggle renders a toggle button in a cell. The button is drawn as
// a radio or a checkbutton, depending on the CellRendererToggle:radio property.
// When activated, it emits the CellRendererToggle::toggled signal.
type CellRendererToggle interface {
	CellRenderer

	// Activatable: returns whether the cell renderer is activatable. See
	// gtk_cell_renderer_toggle_set_activatable().
	Activatable() bool
	// Active: returns whether the cell renderer is active. See
	// gtk_cell_renderer_toggle_set_active().
	Active() bool
	// Radio: returns whether we’re rendering radio toggles rather than
	// checkboxes.
	Radio() bool
	// SetActivatable: makes the cell renderer activatable.
	SetActivatable(setting bool)
	// SetActive: activates or deactivates a cell renderer.
	SetActive(setting bool)
	// SetRadio: if @radio is true, the cell renderer renders a radio toggle
	// (i.e. a toggle in a group of mutually-exclusive toggles). If false, it
	// renders a check toggle (a standalone boolean option). This can be set
	// globally for the cell renderer, or changed just before rendering each
	// cell in the model (for TreeView, you set up a per-row setting using
	// TreeViewColumn to associate model columns with cell renderer properties).
	SetRadio(radio bool)
}

type cellRendererToggle struct {
	cellRenderer
}

func wrapCellRendererToggle(obj *externglib.Object) CellRendererToggle {
	return cellRendererToggle{cellRenderer{externglib.InitiallyUnowned{obj}}}
}

func marshalCellRendererToggle(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewCellRendererToggle() CellRendererToggle

func (c cellRendererToggle) Activatable() bool

func (c cellRendererToggle) Active() bool

func (c cellRendererToggle) Radio() bool

func (c cellRendererToggle) SetActivatable(setting bool)

func (c cellRendererToggle) SetActive(setting bool)

func (c cellRendererToggle) SetRadio(radio bool)

// CellView: a CellView displays a single row of a TreeModel using a CellArea
// and CellAreaContext. A CellAreaContext can be provided to the CellView at
// construction time in order to keep the cellview in context of a group of cell
// views, this ensures that the renderers displayed will be properly aligned
// with each other (like the aligned cells in the menus of ComboBox).
//
// CellView is Orientable in order to decide in which orientation the underlying
// CellAreaContext should be allocated. Taking the ComboBox menu as an example,
// cellviews should be oriented horizontally if the menus are listed
// top-to-bottom and thus all share the same width but may have separate
// individual heights (left-to-right menus should be allocated vertically since
// they all share the same height but may have variable widths).
//
//
// CSS nodes
//
// GtkCellView has a single CSS node with name cellview.
type CellView interface {
	Widget

	// DisplayedRow: returns a TreePath referring to the currently displayed
	// row. If no row is currently displayed, nil is returned.
	DisplayedRow() *TreePath
	// DrawSensitive: gets whether @cell_view is configured to draw all of its
	// cells in a sensitive state.
	DrawSensitive() bool
	// FitModel: gets whether @cell_view is configured to request space to fit
	// the entire TreeModel.
	FitModel() bool
	// Model: returns the model for @cell_view. If no model is used nil is
	// returned.
	Model() TreeModel
	// SetDisplayedRow: sets the row of the model that is currently displayed by
	// the CellView. If the path is unset, then the contents of the cellview
	// “stick” at their last value; this is not normally a desired result, but
	// may be a needed intermediate state if say, the model for the CellView
	// becomes temporarily empty.
	SetDisplayedRow(path *TreePath)
	// SetDrawSensitive: sets whether @cell_view should draw all of its cells in
	// a sensitive state, this is used by ComboBox menus to ensure that rows
	// with insensitive cells that contain children appear sensitive in the
	// parent menu item.
	SetDrawSensitive(drawSensitive bool)
	// SetFitModel: sets whether @cell_view should request space to fit the
	// entire TreeModel.
	//
	// This is used by ComboBox to ensure that the cell view displayed on the
	// combo box’s button always gets enough space and does not resize when
	// selection changes.
	SetFitModel(fitModel bool)
	// SetModel: sets the model for @cell_view. If @cell_view already has a
	// model set, it will remove it before setting the new model. If @model is
	// nil, then it will unset the old model.
	SetModel(model TreeModel)
}

type cellView struct {
	widget
}

func wrapCellView(obj *externglib.Object) CellView {
	return cellView{widget{externglib.InitiallyUnowned{obj}}}
}

func marshalCellView(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewCellView() CellView

func NewCellView(area CellArea, context CellAreaContext) CellView

func NewCellView(markup string) CellView

func NewCellView(text string) CellView

func NewCellView(texture gdk.Texture) CellView

func (c cellView) DisplayedRow() *TreePath

func (c cellView) DrawSensitive() bool

func (c cellView) FitModel() bool

func (c cellView) Model() TreeModel

func (c cellView) SetDisplayedRow(path *TreePath)

func (c cellView) SetDrawSensitive(drawSensitive bool)

func (c cellView) SetFitModel(fitModel bool)

func (c cellView) SetModel(model TreeModel)

// CenterBox: the GtkCenterBox widget arranges three children in a horizontal or
// vertical arrangement, keeping the middle child centered as well as possible.
//
// To add children to GtkCenterBox, use gtk_center_box_set_start_widget(),
// gtk_center_box_set_center_widget() and gtk_center_box_set_end_widget().
//
// The sizing and positioning of children can be influenced with the align and
// expand properties of the children.
//
//
// GtkCenterBox as GtkBuildable
//
// The GtkCenterBox implementation of the Buildable interface supports placing
// children in the 3 positions by specifying “start”, “center” or “end” as the
// “type” attribute of a <child> element.
//
//
// CSS nodes
//
// GtkCenterBox uses a single CSS node with the name “box”,
//
// The first child of the CenterBox will be allocated depending on the text
// direction, i.e. in left-to-right layouts it will be allocated on the left and
// in right-to-left layouts on the right.
//
// In vertical orientation, the nodes of the children are arranged from top to
// bottom.
//
//
// Accessibility
//
// GtkCenterBox uses the GTK_ACCESSIBLE_ROLE_GROUP role.
type CenterBox interface {
	Widget

	// BaselinePosition: gets the value set by
	// gtk_center_box_set_baseline_position().
	BaselinePosition() BaselinePosition
	// CenterWidget: gets the center widget, or nil if there is none.
	CenterWidget() Widget
	// EndWidget: gets the end widget, or nil if there is none.
	EndWidget() Widget
	// StartWidget: gets the start widget, or nil if there is none.
	StartWidget() Widget
	// SetBaselinePosition: sets the baseline position of a center box.
	//
	// This affects only horizontal boxes with at least one baseline aligned
	// child. If there is more vertical space available than requested, and the
	// baseline is not allocated by the parent then @position is used to
	// allocate the baseline wrt. the extra space available.
	SetBaselinePosition(position BaselinePosition)
	// SetCenterWidget: sets the center widget. To remove the existing center
	// widget, pas nil.
	SetCenterWidget(child Widget)
	// SetEndWidget: sets the end widget. To remove the existing end widget,
	// pass nil.
	SetEndWidget(child Widget)
	// SetStartWidget: sets the start widget. To remove the existing start
	// widget, pass nil.
	SetStartWidget(child Widget)
}

type centerBox struct {
	widget
}

func wrapCenterBox(obj *externglib.Object) CenterBox {
	return centerBox{widget{externglib.InitiallyUnowned{obj}}}
}

func marshalCenterBox(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewCenterBox() CenterBox

func (c centerBox) BaselinePosition() BaselinePosition

func (c centerBox) CenterWidget() Widget

func (c centerBox) EndWidget() Widget

func (c centerBox) StartWidget() Widget

func (c centerBox) SetBaselinePosition(position BaselinePosition)

func (c centerBox) SetCenterWidget(child Widget)

func (c centerBox) SetEndWidget(child Widget)

func (c centerBox) SetStartWidget(child Widget)

// CenterLayout: a CenterLayout is a layout manager that manages up to three
// children. The start widget is allocated at the start of the layout (left in
// LRT layouts and right in RTL ones), and the end widget at the end.
//
// The center widget is centered regarding the full width of the layout's.
type CenterLayout interface {
	LayoutManager

	// BaselinePosition: returns the baseline position of the layout.
	BaselinePosition() BaselinePosition
	// CenterWidget: returns the center widget of the layout.
	CenterWidget() Widget
	// EndWidget: returns the end widget of the layout.
	EndWidget() Widget
	// Orientation: gets the current orienration of the layout manager.
	Orientation() Orientation
	// StartWidget: returns the start widget fo the layout.
	StartWidget() Widget
	// SetBaselinePosition: sets the new baseline position of @self
	SetBaselinePosition(baselinePosition BaselinePosition)
	// SetCenterWidget: sets the new center widget of @self.
	//
	// To remove the existing center widget, pass nil.
	SetCenterWidget(widget Widget)
	// SetEndWidget: sets the new end widget of @self.
	//
	// To remove the existing center widget, pass nil.
	SetEndWidget(widget Widget)
	// SetOrientation: sets the orientation of @self.
	SetOrientation(orientation Orientation)
	// SetStartWidget: sets the new start widget of @self.
	//
	// To remove the existing start widget, pass nil.
	SetStartWidget(widget Widget)
}

type centerLayout struct {
	layoutManager
}

func wrapCenterLayout(obj *externglib.Object) CenterLayout {
	return centerLayout{layoutManager{*externglib.Object{obj}}}
}

func marshalCenterLayout(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewCenterLayout() CenterLayout

func (c centerLayout) BaselinePosition() BaselinePosition

func (c centerLayout) CenterWidget() Widget

func (c centerLayout) EndWidget() Widget

func (c centerLayout) Orientation() Orientation

func (c centerLayout) StartWidget() Widget

func (c centerLayout) SetBaselinePosition(baselinePosition BaselinePosition)

func (c centerLayout) SetCenterWidget(widget Widget)

func (c centerLayout) SetEndWidget(widget Widget)

func (c centerLayout) SetOrientation(orientation Orientation)

func (c centerLayout) SetStartWidget(widget Widget)

// CheckButton: a CheckButton places a label next to an indicator.
//
// CSS nodes
//
//    checkbutton[.text-button]
//    ├── check
//    ╰── [label]
//
// A CheckButton has a main node with name checkbutton. If the CheckButton:label
// property is set, it contains a label child. The indicator node is named check
// when no group is set, and radio if the checkbutton is grouped together with
// other checkbuttons.
//
//
// Accessibility
//
// GtkCheckButton uses the K_ACCESSIBLE_ROLE_CHECKBOX role.
type CheckButton interface {
	Widget

	// Active: returns the current value of the CheckButton:active property.
	Active() bool
	// Inconsistent: returns whether the check button is in an inconsistent
	// state.
	Inconsistent() bool
	// Label: returns the label of the checkbutton.
	Label() string
	// UseUnderline: returns the current value of the CheckButton:use-underline
	// property.
	UseUnderline() bool
	// SetActive: sets the new value of the CheckButton:active property. See
	// also gtk_check_button_get_active().
	//
	// Setting CheckButton:active to true will add the `:checked:` state to both
	// the checkbutton and the indicator CSS node.
	SetActive(setting bool)
	// SetGroup: adds @self to the group of @group. In a group of multiple check
	// buttons, only one button can be active at a time.
	//
	// Setting the group of a check button also changes the css name of the
	// indicator widget's CSS node to 'radio'.
	//
	// The behavior of a checkbutton in a group is also commonly known as a
	// 'radio button'.
	//
	// Note that the same effect can be achieved via the Actionable api, by
	// using the same action with parameter type and state type 's' for all
	// buttons in the group, and giving each button its own target value.
	SetGroup(group CheckButton)
	// SetInconsistent: if the user has selected a range of elements (such as
	// some text or spreadsheet cells) that are affected by a check button, and
	// the current values in that range are inconsistent, you may want to
	// display the toggle in an "in between" state. Normally you would turn off
	// the inconsistent state again if the user checks the check button. This
	// has to be done manually, gtk_check_button_set_inconsistent only affects
	// visual appearance, not the semantics of the button.
	SetInconsistent(inconsistent bool)
	// SetLabel: sets the text of @self. If CheckButton:use-underline is true,
	// the underscore in @label is interpreted as mnemonic indicator, see
	// gtk_check_button_set_use_underline() for details on this behavior.
	SetLabel(label string)
	// SetUseUnderline: sets the new value of the CheckButton:use-underline
	// property. See also gtk_check_button_get_use_underline().
	//
	// If @setting is true, an underscore character in @self's label indicates a
	// mnemonic accelerator key. This behavior is similar to
	// Label:use-underline.
	SetUseUnderline(setting bool)
}

type checkButton struct {
	widget
}

func wrapCheckButton(obj *externglib.Object) CheckButton {
	return checkButton{widget{externglib.InitiallyUnowned{obj}}}
}

func marshalCheckButton(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewCheckButton() CheckButton

func NewCheckButton(label string) CheckButton

func NewCheckButton(label string) CheckButton

func (c checkButton) Active() bool

func (c checkButton) Inconsistent() bool

func (c checkButton) Label() string

func (c checkButton) UseUnderline() bool

func (c checkButton) SetActive(setting bool)

func (c checkButton) SetGroup(group CheckButton)

func (c checkButton) SetInconsistent(inconsistent bool)

func (c checkButton) SetLabel(label string)

func (c checkButton) SetUseUnderline(setting bool)

type ClosureExpression interface {
	Expression
}

type closureExpression struct {
	expression
}

func wrapClosureExpression(obj *externglib.Object) ClosureExpression {
	return closureExpression{expression{obj}}
}

func marshalClosureExpression(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewClosureExpression(valueType externglib.Type, closure *externglib.Closure, nParams uint, params []Expression) ClosureExpression

// ColorButton: the ColorButton is a button which displays the currently
// selected color and allows to open a color selection dialog to change the
// color. It is suitable widget for selecting a color in a preference dialog.
//
// CSS nodes
//
//    colorbutton
//    ╰── button.color
//        ╰── [content]
//
// GtkColorButton has a single CSS node with name colorbutton which contains a
// button node. To differentiate it from a plain Button, it gets the .color
// style class.
type ColorButton interface {
	Widget

	// Modal: gets whether the dialog is modal.
	Modal() bool
	// Title: gets the title of the color selection dialog.
	Title() string
	// SetModal: sets whether the dialog should be modal.
	SetModal(modal bool)
	// SetTitle: sets the title for the color selection dialog.
	SetTitle(title string)
}

type colorButton struct {
	widget
}

func wrapColorButton(obj *externglib.Object) ColorButton {
	return colorButton{widget{externglib.InitiallyUnowned{obj}}}
}

func marshalColorButton(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewColorButton() ColorButton

func NewColorButton(rgba *gdk.RGBA) ColorButton

func (c colorButton) Modal() bool

func (c colorButton) Title() string

func (c colorButton) SetModal(modal bool)

func (c colorButton) SetTitle(title string)

// ColorChooserDialog: the ColorChooserDialog widget is a dialog for choosing a
// color. It implements the ColorChooser interface.
type ColorChooserDialog interface {
	Dialog
}

type colorChooserDialog struct {
	dialog
}

func wrapColorChooserDialog(obj *externglib.Object) ColorChooserDialog {
	return colorChooserDialog{dialog{window{widget{externglib.InitiallyUnowned{obj}}}}}
}

func marshalColorChooserDialog(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewColorChooserDialog(title string, parent Window) ColorChooserDialog

// ColorChooserWidget: the ColorChooserWidget widget lets the user select a
// color. By default, the chooser presents a predefined palette of colors, plus
// a small number of settable custom colors. It is also possible to select a
// different color with the single-color editor. To enter the single-color
// editing mode, use the context menu of any color of the palette, or use the
// '+' button to add a new custom color.
//
// The chooser automatically remembers the last selection, as well as custom
// colors.
//
// To change the initially selected color, use gtk_color_chooser_set_rgba(). To
// get the selected color use gtk_color_chooser_get_rgba().
//
// The ColorChooserWidget is used in the ColorChooserDialog to provide a dialog
// for selecting colors.
//
//
// CSS names
//
// GtkColorChooserWidget has a single CSS node with name colorchooser.
type ColorChooserWidget interface {
	Widget
}

type colorChooserWidget struct {
	widget
}

func wrapColorChooserWidget(obj *externglib.Object) ColorChooserWidget {
	return colorChooserWidget{widget{externglib.InitiallyUnowned{obj}}}
}

func marshalColorChooserWidget(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewColorChooserWidget() ColorChooserWidget

// ColumnView: gtkColumnView is a widget to present a view into a large dynamic
// list of items using multiple columns with headers.
//
// GtkColumnView uses the factories of its columns to generate a cell widget for
// each column, for each visible item and displays them together as the row for
// this item. The ColumnView:show-row-separators and
// ColumnView:show-column-separators properties offer a simple way to display
// separators between the rows or columns.
//
// GtkColumnView allows the user to select items according to the selection
// characteristics of the model. For models that allow multiple selected items,
// it is possible to turn on *rubberband selection*, using
// ColumnView:enable-rubberband.
//
// The column view supports sorting that can be customized by the user by
// clicking on column headers. To set this up, the Sorter returned by
// gtk_column_view_get_sorter() must be attached to a sort model for the data
// that the view is showing, and the columns must have sorters attached to them
// by calling gtk_column_view_column_set_sorter(). The initial sort order can be
// set with gtk_column_view_sort_by_column().
//
// The column view also supports interactive resizing and reordering of columns,
// via Drag-and-Drop of the column headers. This can be enabled or disabled with
// the ColumnView:reorderable and ColumnViewColumn:resizable properties.
//
// To learn more about the list widget framework, see the [overview](Widget).
//
// CSS nodes
//
//    columnview[.column-separators][.rich-list][.navigation-sidebar][.data-table]
//    ├── header
//    │   ├── <column header>
//    ┊   ┊
//    │   ╰── <column header>
//    │
//    ├── listview
//    │
//    ┊
//    ╰── [rubberband]
//
//
//
// GtkColumnView uses a single CSS node named columnview. It may carry the
// .column-separators style class, when ColumnView:show-column-separators
// property is set. Header widets appear below a node with name header. The rows
// are contained in a GtkListView widget, so there is a listview node with the
// same structure as for a standalone GtkListView widget. If
// ColumnView:show-row-separators is set, it will be passed on to the list view,
// causing its CSS node to carry the .separators style class. For rubberband
// selection, a node with name rubberband is used.
//
// The main columnview node may also carry style classes to select the style of
// [list presentation](ListContainers.html#list-styles): .rich-list,
// .navigation-sidebar or .data-table.
//
//
// Accessibility
//
// GtkColumnView uses the K_ACCESSIBLE_ROLE_TREE_GRID role, header title widgets
// are using the K_ACCESSIBLE_ROLE_COLUMN_HEADER role. The row widgets are using
// the K_ACCESSIBLE_ROLE_ROW role, and individual cells are using the
// K_ACCESSIBLE_ROLE_GRID_CELL role
type ColumnView interface {
	Widget

	// AppendColumn: appends the @column to the end of the columns in @self.
	AppendColumn(column ColumnViewColumn)
	// Columns: gets the list of columns in this column view. This list is
	// constant over the lifetime of @self and can be used to monitor changes to
	// the columns of @self by connecting to the Model:items-changed signal.
	Columns() gio.ListModel
	// EnableRubberband: returns whether rows can be selected by dragging with
	// the mouse.
	EnableRubberband() bool
	// Model: gets the model that's currently used to read the items displayed.
	Model() SelectionModel
	// Reorderable: returns whether columns are reorderable.
	Reorderable() bool
	// ShowColumnSeparators: returns whether the list should show separators
	// between columns.
	ShowColumnSeparators() bool
	// ShowRowSeparators: returns whether the list should show separators
	// between rows.
	ShowRowSeparators() bool
	// SingleClickActivate: returns whether rows will be activated on single
	// click and selected on hover.
	SingleClickActivate() bool
	// Sorter: returns a special sorter that reflects the users sorting choices
	// in the column view.
	//
	// To allow users to customizable sorting by clicking on column headers,
	// this sorter needs to be set on the sort model underneath the model that
	// is displayed by the view.
	//
	// See gtk_column_view_column_set_sorter() for setting up per-column
	// sorting.
	//
	//
	//      gtk_column_view_column_set_sorter (column, sorter);
	//      gtk_column_view_append_column (view, column);
	//      sorter = g_object_ref (gtk_column_view_get_sorter (view)));
	//      model = gtk_sort_list_model_new (store, sorter);
	//      selection = gtk_no_selection_new (model);
	//      gtk_column_view_set_model (view, selection);
	Sorter() Sorter
	// InsertColumn: inserts a column at the given position in the columns of
	// @self.
	//
	// If @column is already a column of @self, it will be repositioned.
	InsertColumn(position uint, column ColumnViewColumn)
	// RemoveColumn: removes the @column from the list of columns of @self.
	RemoveColumn(column ColumnViewColumn)
	// SetEnableRubberband: sets whether selections can be changed by dragging
	// with the mouse.
	SetEnableRubberband(enableRubberband bool)
	// SetModel: sets the SelectionModel to use.
	SetModel(model SelectionModel)
	// SetReorderable: sets whether columns should be reorderable by dragging.
	SetReorderable(reorderable bool)
	// SetShowColumnSeparators: sets whether the list should show separators
	// between columns.
	SetShowColumnSeparators(showColumnSeparators bool)
	// SetShowRowSeparators: sets whether the list should show separators
	// between rows.
	SetShowRowSeparators(showRowSeparators bool)
	// SetSingleClickActivate: sets whether rows should be activated on single
	// click and selected on hover.
	SetSingleClickActivate(singleClickActivate bool)
	// SortByColumn: sets the sorting of the view.
	//
	// This function should be used to set up the initial sorting. At runtime,
	// users can change the sorting of a column view by clicking on the list
	// headers.
	//
	// This call only has an effect if the sorter returned by
	// gtk_column_view_get_sorter() is set on a sort model, and
	// gtk_column_view_column_set_sorter() has been called on @column to
	// associate a sorter with the column.
	//
	// If @column is nil, the view will be unsorted.
	SortByColumn(column ColumnViewColumn, direction SortType)
}

type columnView struct {
	widget
}

func wrapColumnView(obj *externglib.Object) ColumnView {
	return columnView{widget{externglib.InitiallyUnowned{obj}}}
}

func marshalColumnView(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewColumnView(model SelectionModel) ColumnView

func (c columnView) AppendColumn(column ColumnViewColumn)

func (c columnView) Columns() gio.ListModel

func (c columnView) EnableRubberband() bool

func (c columnView) Model() SelectionModel

func (c columnView) Reorderable() bool

func (c columnView) ShowColumnSeparators() bool

func (c columnView) ShowRowSeparators() bool

func (c columnView) SingleClickActivate() bool

func (c columnView) Sorter() Sorter

func (c columnView) InsertColumn(position uint, column ColumnViewColumn)

func (c columnView) RemoveColumn(column ColumnViewColumn)

func (c columnView) SetEnableRubberband(enableRubberband bool)

func (c columnView) SetModel(model SelectionModel)

func (c columnView) SetReorderable(reorderable bool)

func (c columnView) SetShowColumnSeparators(showColumnSeparators bool)

func (c columnView) SetShowRowSeparators(showRowSeparators bool)

func (c columnView) SetSingleClickActivate(singleClickActivate bool)

func (c columnView) SortByColumn(column ColumnViewColumn, direction SortType)

// ColumnViewColumn: gtkColumnViewColumn represents the columns being added to
// ColumnView.
//
// Columns have a title, and can optionally have a header menu set with
// gtk_column_view_column_set_header_menu().
//
// A sorter can be associated with a column using
// gtk_column_view_column_set_sorter(), to let users influence sorting by
// clicking on the column header.
type ColumnViewColumn interface {
	gextras.Objector

	// ColumnView: gets the column view that's currently displaying this column.
	//
	// If @self has not been added to a column view yet, nil is returned.
	ColumnView() ColumnView
	// Expand: returns whether this column should expand.
	Expand() bool
	// Factory: gets the factory that's currently used to populate list items
	// for this column.
	Factory() ListItemFactory
	// FixedWidth: gets the fixed width of the column.
	FixedWidth() int
	// HeaderMenu: gets the menu model that is used to create the context menu
	// for the column header.
	HeaderMenu() gio.MenuModel
	// Resizable: returns whether this column is resizable.
	Resizable() bool
	// Sorter: returns the sorter that is associated with the column.
	Sorter() Sorter
	// Title: returns the title set with gtk_column_view_column_set_title().
	Title() string
	// Visible: returns whether this column is visible.
	Visible() bool
	// SetExpand: sets the column to take available extra space.
	//
	// The extra space is shared equally amongst all columns that have the
	// expand set to true.
	SetExpand(expand bool)
	// SetFactory: sets the ListItemFactory to use for populating list items for
	// this column.
	SetFactory(factory ListItemFactory)
	// SetFixedWidth: if @fixed_width is not -1, sets the fixed width of
	// @column; otherwise unsets it.
	//
	// Setting a fixed width overrides the automatically calculated width.
	// Interactive resizing also sets the “fixed-width” property.
	SetFixedWidth(fixedWidth int)
	// SetHeaderMenu: sets the menu model that is used to create the context
	// menu for the column header.
	SetHeaderMenu(menu gio.MenuModel)
	// SetResizable: sets whether this column should be resizable by dragging.
	SetResizable(resizable bool)
	// SetSorter: associates a sorter with the column.
	//
	// If @sorter is nil, the column will not let users change the sorting by
	// clicking on its header.
	//
	// This sorter can be made active by clicking on the column header, or by
	// calling gtk_column_view_sort_by_column().
	//
	// See gtk_column_view_get_sorter() for the necessary steps for setting up
	// customizable sorting for ColumnView.
	SetSorter(sorter Sorter)
	// SetTitle: sets the title of this column. The title is displayed in the
	// header of a ColumnView for this column and is therefore user-facing text
	// that should be translated.
	SetTitle(title string)
	// SetVisible: sets whether this column should be visible in views.
	SetVisible(visible bool)
}

type columnViewColumn struct {
	*externglib.Object
}

func wrapColumnViewColumn(obj *externglib.Object) ColumnViewColumn {
	return columnViewColumn{*externglib.Object{obj}}
}

func marshalColumnViewColumn(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewColumnViewColumn(title string, factory ListItemFactory) ColumnViewColumn

func (c columnViewColumn) ColumnView() ColumnView

func (c columnViewColumn) Expand() bool

func (c columnViewColumn) Factory() ListItemFactory

func (c columnViewColumn) FixedWidth() int

func (c columnViewColumn) HeaderMenu() gio.MenuModel

func (c columnViewColumn) Resizable() bool

func (c columnViewColumn) Sorter() Sorter

func (c columnViewColumn) Title() string

func (c columnViewColumn) Visible() bool

func (c columnViewColumn) SetExpand(expand bool)

func (c columnViewColumn) SetFactory(factory ListItemFactory)

func (c columnViewColumn) SetFixedWidth(fixedWidth int)

func (c columnViewColumn) SetHeaderMenu(menu gio.MenuModel)

func (c columnViewColumn) SetResizable(resizable bool)

func (c columnViewColumn) SetSorter(sorter Sorter)

func (c columnViewColumn) SetTitle(title string)

func (c columnViewColumn) SetVisible(visible bool)

// ComboBox: a GtkComboBox is a widget that allows the user to choose from a
// list of valid choices. The GtkComboBox displays the selected choice. When
// activated, the GtkComboBox displays a popup which allows the user to make a
// new choice. The style in which the selected value is displayed, and the style
// of the popup is determined by the current theme. It may be similar to a
// Windows-style combo box.
//
// The GtkComboBox uses the model-view pattern; the list of valid choices is
// specified in the form of a tree model, and the display of the choices can be
// adapted to the data in the model by using cell renderers, as you would in a
// tree view. This is possible since GtkComboBox implements the CellLayout
// interface. The tree model holding the valid choices is not restricted to a
// flat list, it can be a real tree, and the popup will reflect the tree
// structure.
//
// To allow the user to enter values not in the model, the “has-entry” property
// allows the GtkComboBox to contain a Entry. This entry can be accessed by
// calling gtk_combo_box_get_child() on the combo box.
//
// For a simple list of textual choices, the model-view API of GtkComboBox can
// be a bit overwhelming. In this case, ComboBoxText offers a simple
// alternative. Both GtkComboBox and ComboBoxText can contain an entry.
//
// CSS nodes
//
//    combobox
//    ├── box.linked
//    │   ╰── button.combo
//    │       ╰── box
//    │           ├── cellview
//    │           ╰── arrow
//    ╰── window.popup
//
// A normal combobox contains a box with the .linked class, a button with the
// .combo class and inside those buttons, there are a cellview and an arrow.
//
//    combobox
//    ├── box.linked
//    │   ├── entry.combo
//    │   ╰── button.combo
//    │       ╰── box
//    │           ╰── arrow
//    ╰── window.popup
//
// A GtkComboBox with an entry has a single CSS node with name combobox. It
// contains a box with the .linked class. That box contains an entry and a
// button, both with the .combo class added. The button also contains another
// node with name arrow.
//
//
// Accessibility
//
// GtkComboBox uses the K_ACCESSIBLE_ROLE_COMBO_BOX role.
type ComboBox interface {
	Widget

	// Active: returns the index of the currently active item, or -1 if there’s
	// no active item. If the model is a non-flat treemodel, and the active item
	// is not an immediate child of the root of the tree, this function returns
	// `gtk_tree_path_get_indices (path)[0]`, where `path` is the TreePath of
	// the active item.
	Active() int
	// ActiveID: returns the ID of the active row of @combo_box. This value is
	// taken from the active row and the column specified by the
	// ComboBox:id-column property of @combo_box (see
	// gtk_combo_box_set_id_column()).
	//
	// The returned value is an interned string which means that you can compare
	// the pointer by value to other interned strings and that you must not free
	// it.
	//
	// If the ComboBox:id-column property of @combo_box is not set, or if no row
	// is active, or if the active row has a nil ID value, then nil is returned.
	ActiveID() string
	// ActiveIter: sets @iter to point to the currently active item, if any item
	// is active. Otherwise, @iter is left unchanged.
	ActiveIter() (iter TreeIter, ok bool)
	// ButtonSensitivity: returns whether the combo box sets the dropdown button
	// sensitive or not when there are no items in the model.
	ButtonSensitivity() SensitivityType
	// Child: gets the child widget of @combo_box.
	Child() Widget
	// EntryTextColumn: returns the column which @combo_box is using to get the
	// strings from to display in the internal entry.
	EntryTextColumn() int
	// HasEntry: returns whether the combo box has an entry.
	HasEntry() bool
	// IDColumn: returns the column which @combo_box is using to get string IDs
	// for values from.
	IDColumn() int
	// Model: returns the TreeModel which is acting as data source for
	// @combo_box.
	Model() TreeModel
	// PopupFixedWidth: gets whether the popup uses a fixed width matching the
	// allocated width of the combo box.
	PopupFixedWidth() bool
	// RowSeparatorFunc: returns the current row separator function.
	RowSeparatorFunc() TreeViewRowSeparatorFunc
	// Popdown: hides the menu or dropdown list of @combo_box.
	//
	// This function is mostly intended for use by accessibility technologies;
	// applications should have little use for it.
	Popdown()
	// Popup: pops up the menu or dropdown list of @combo_box.
	//
	// This function is mostly intended for use by accessibility technologies;
	// applications should have little use for it.
	//
	// Before calling this, @combo_box must be mapped, or nothing will happen.
	Popup()
	// PopupForDevice: pops up the menu of @combo_box. Note that currently this
	// does not do anything with the device, as it was previously only used for
	// list-mode combo boxes, and those were removed in GTK 4. However, it is
	// retained in case similar functionality is added back later.
	PopupForDevice(device gdk.Device)
	// SetActive: sets the active item of @combo_box to be the item at @index.
	SetActive(index_ int)
	// SetActiveID: changes the active row of @combo_box to the one that has an
	// ID equal to @active_id, or unsets the active row if @active_id is nil.
	// Rows having a nil ID string cannot be made active by this function.
	//
	// If the ComboBox:id-column property of @combo_box is unset or if no row
	// has the given ID then the function does nothing and returns false.
	SetActiveID(activeID string) bool
	// SetActiveIter: sets the current active item to be the one referenced by
	// @iter, or unsets the active item if @iter is nil.
	SetActiveIter(iter *TreeIter)
	// SetButtonSensitivity: sets whether the dropdown button of the combo box
	// should be always sensitive (GTK_SENSITIVITY_ON), never sensitive
	// (GTK_SENSITIVITY_OFF) or only if there is at least one item to display
	// (GTK_SENSITIVITY_AUTO).
	SetButtonSensitivity(sensitivity SensitivityType)
	// SetChild: sets the child widget of @combo_box.
	SetChild(child Widget)
	// SetEntryTextColumn: sets the model column which @combo_box should use to
	// get strings from to be @text_column. The column @text_column in the model
	// of @combo_box must be of type G_TYPE_STRING.
	//
	// This is only relevant if @combo_box has been created with
	// ComboBox:has-entry as true.
	SetEntryTextColumn(textColumn int)
	// SetIDColumn: sets the model column which @combo_box should use to get
	// string IDs for values from. The column @id_column in the model of
	// @combo_box must be of type G_TYPE_STRING.
	SetIDColumn(idColumn int)
	// SetModel: sets the model used by @combo_box to be @model. Will unset a
	// previously set model (if applicable). If model is nil, then it will unset
	// the model.
	//
	// Note that this function does not clear the cell renderers, you have to
	// call gtk_cell_layout_clear() yourself if you need to set up different
	// cell renderers for the new model.
	SetModel(model TreeModel)
	// SetPopupFixedWidth: specifies whether the popup’s width should be a fixed
	// width matching the allocated width of the combo box.
	SetPopupFixedWidth(fixed bool)
	// SetRowSeparatorFunc: sets the row separator function, which is used to
	// determine whether a row should be drawn as a separator. If the row
	// separator function is nil, no separators are drawn. This is the default
	// value.
	SetRowSeparatorFunc(_func TreeViewRowSeparatorFunc)
}

type comboBox struct {
	widget
}

func wrapComboBox(obj *externglib.Object) ComboBox {
	return comboBox{widget{externglib.InitiallyUnowned{obj}}}
}

func marshalComboBox(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewComboBox() ComboBox

func NewComboBox() ComboBox

func NewComboBox(model TreeModel) ComboBox

func NewComboBox(model TreeModel) ComboBox

func (c comboBox) Active() int

func (c comboBox) ActiveID() string

func (c comboBox) ActiveIter() (iter TreeIter, ok bool)

func (c comboBox) ButtonSensitivity() SensitivityType

func (c comboBox) Child() Widget

func (c comboBox) EntryTextColumn() int

func (c comboBox) HasEntry() bool

func (c comboBox) IDColumn() int

func (c comboBox) Model() TreeModel

func (c comboBox) PopupFixedWidth() bool

func (c comboBox) RowSeparatorFunc() TreeViewRowSeparatorFunc

func (c comboBox) Popdown()

func (c comboBox) Popup()

func (c comboBox) PopupForDevice(device gdk.Device)

func (c comboBox) SetActive(index_ int)

func (c comboBox) SetActiveID(activeID string) bool

func (c comboBox) SetActiveIter(iter *TreeIter)

func (c comboBox) SetButtonSensitivity(sensitivity SensitivityType)

func (c comboBox) SetChild(child Widget)

func (c comboBox) SetEntryTextColumn(textColumn int)

func (c comboBox) SetIDColumn(idColumn int)

func (c comboBox) SetModel(model TreeModel)

func (c comboBox) SetPopupFixedWidth(fixed bool)

func (c comboBox) SetRowSeparatorFunc(_func TreeViewRowSeparatorFunc)

// ComboBoxText: a GtkComboBoxText is a simple variant of ComboBox that hides
// the model-view complexity for simple text-only use cases.
//
// To create a GtkComboBoxText, use gtk_combo_box_text_new() or
// gtk_combo_box_text_new_with_entry().
//
// You can add items to a GtkComboBoxText with gtk_combo_box_text_append_text(),
// gtk_combo_box_text_insert_text() or gtk_combo_box_text_prepend_text() and
// remove options with gtk_combo_box_text_remove().
//
// If the GtkComboBoxText contains an entry (via the “has-entry” property), its
// contents can be retrieved using gtk_combo_box_text_get_active_text(). The
// entry itself can be accessed by calling gtk_bin_get_child() on the combo box.
//
// You should not call gtk_combo_box_set_model() or attempt to pack more cells
// into this combo box via its GtkCellLayout interface.
//
//
// GtkComboBoxText as GtkBuildable
//
// The GtkComboBoxText implementation of the GtkBuildable interface supports
// adding items directly using the <items> element and specifying <item>
// elements for each item. Each <item> element can specify the “id”
// corresponding to the appended text and also supports the regular translation
// attributes “translatable”, “context” and “comments”.
//
//
//    <object class="GtkComboBoxText">
//      <items>
//        <item translatable="yes" id="factory">Factory</item>
//        <item translatable="yes" id="home">Home</item>
//        <item translatable="yes" id="subway">Subway</item>
//      </items>
//    </object>
//
// CSS nodes
//
//    combobox
//    ╰── box.linked
//        ├── entry.combo
//        ├── button.combo
//        ╰── window.popup
//
// GtkComboBoxText has a single CSS node with name combobox. It adds the style
// class .combo to the main CSS nodes of its entry and button children, and the
// .linked class to the node of its internal box.
type ComboBoxText interface {
	ComboBox

	// Append: appends @text to the list of strings stored in @combo_box. If @id
	// is non-nil then it is used as the ID of the row.
	//
	// This is the same as calling gtk_combo_box_text_insert() with a position
	// of -1.
	Append(id string, text string)
	// AppendText: appends @text to the list of strings stored in @combo_box.
	//
	// This is the same as calling gtk_combo_box_text_insert_text() with a
	// position of -1.
	AppendText(text string)
	// ActiveText: returns the currently active string in @combo_box, or nil if
	// none is selected. If @combo_box contains an entry, this function will
	// return its contents (which will not necessarily be an item from the
	// list).
	ActiveText() string
	// Insert: inserts @text at @position in the list of strings stored in
	// @combo_box. If @id is non-nil then it is used as the ID of the row. See
	// ComboBox:id-column.
	//
	// If @position is negative then @text is appended.
	Insert(position int, id string, text string)
	// InsertText: inserts @text at @position in the list of strings stored in
	// @combo_box.
	//
	// If @position is negative then @text is appended.
	//
	// This is the same as calling gtk_combo_box_text_insert() with a nil ID
	// string.
	InsertText(position int, text string)
	// Prepend: prepends @text to the list of strings stored in @combo_box. If
	// @id is non-nil then it is used as the ID of the row.
	//
	// This is the same as calling gtk_combo_box_text_insert() with a position
	// of 0.
	Prepend(id string, text string)
	// PrependText: prepends @text to the list of strings stored in @combo_box.
	//
	// This is the same as calling gtk_combo_box_text_insert_text() with a
	// position of 0.
	PrependText(text string)
	// Remove: removes the string at @position from @combo_box.
	Remove(position int)
	// RemoveAll: removes all the text entries from the combo box.
	RemoveAll()
}

type comboBoxText struct {
	comboBox
}

func wrapComboBoxText(obj *externglib.Object) ComboBoxText {
	return comboBoxText{comboBox{widget{externglib.InitiallyUnowned{obj}}}}
}

func marshalComboBoxText(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewComboBoxText() ComboBoxText

func NewComboBoxText() ComboBoxText

func (c comboBoxText) Append(id string, text string)

func (c comboBoxText) AppendText(text string)

func (c comboBoxText) ActiveText() string

func (c comboBoxText) Insert(position int, id string, text string)

func (c comboBoxText) InsertText(position int, text string)

func (c comboBoxText) Prepend(id string, text string)

func (c comboBoxText) PrependText(text string)

func (c comboBoxText) Remove(position int)

func (c comboBoxText) RemoveAll()

type ConstantExpression interface {
	Expression

	// Value: gets the value that a constant expression evaluates to.
	Value() *externglib.Value
}

type constantExpression struct {
	expression
}

func wrapConstantExpression(obj *externglib.Object) ConstantExpression {
	return constantExpression{expression{obj}}
}

func marshalConstantExpression(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewConstantExpression(value *externglib.Value) ConstantExpression

func (c constantExpression) Value() *externglib.Value

// Constraint describes a constraint between an attribute on a widget and
// another attribute on another widget, expressed as a linear equation like:
//
//
//      target.attr1 = source.attr2 × multiplier + constant
//
// Each Constraint is part of a system that will be solved by a ConstraintLayout
// in order to allocate and position each child widget.
//
// The source and target widgets, as well as their attributes, of a Constraint
// instance are immutable after creation.
type Constraint interface {
	gextras.Objector

	// Constant: retrieves the constant factor added to the source attributes'
	// value.
	Constant() float64
	// Multiplier: retrieves the multiplication factor applied to the source
	// attribute's value.
	Multiplier() float64
	// Relation: the order relation between the terms of the @constraint.
	Relation() ConstraintRelation
	// Source: retrieves the ConstraintTarget used as the source for
	// @constraint.
	//
	// If the Constraint:source property is set to nil, the @constraint will use
	// the ConstraintLayout's widget.
	Source() ConstraintTarget
	// SourceAttribute: retrieves the attribute of the source to be read by the
	// @constraint.
	SourceAttribute() ConstraintAttribute
	// Strength: retrieves the strength of the constraint.
	Strength() int
	// Target: retrieves the ConstraintTarget used as the target for
	// @constraint.
	//
	// If the Constraint:target property is set to nil, the @constraint will use
	// the ConstraintLayout's widget.
	Target() ConstraintTarget
	// TargetAttribute: retrieves the attribute of the target to be set by the
	// @constraint.
	TargetAttribute() ConstraintAttribute
	// IsAttached: checks whether the @constraint is attached to a
	// ConstraintLayout, and it is contributing to the layout.
	IsAttached() bool
	// IsConstant: checks whether the @constraint describes a relation between
	// an attribute on the Constraint:target and a constant value.
	IsConstant() bool
	// IsRequired: checks whether the @constraint is a required relation for
	// solving the constraint layout.
	IsRequired() bool
}

type constraint struct {
	*externglib.Object
}

func wrapConstraint(obj *externglib.Object) Constraint {
	return constraint{*externglib.Object{obj}}
}

func marshalConstraint(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewConstraint(target interface{}, targetAttribute ConstraintAttribute, relation ConstraintRelation, source interface{}, sourceAttribute ConstraintAttribute, multiplier float64, constant float64, strength int) Constraint

func NewConstraint(target interface{}, targetAttribute ConstraintAttribute, relation ConstraintRelation, constant float64, strength int) Constraint

func (c constraint) Constant() float64

func (c constraint) Multiplier() float64

func (c constraint) Relation() ConstraintRelation

func (c constraint) Source() ConstraintTarget

func (c constraint) SourceAttribute() ConstraintAttribute

func (c constraint) Strength() int

func (c constraint) Target() ConstraintTarget

func (c constraint) TargetAttribute() ConstraintAttribute

func (c constraint) IsAttached() bool

func (c constraint) IsConstant() bool

func (c constraint) IsRequired() bool

// ConstraintGuide: a ConstraintGuide is an invisible layout element that can be
// used by widgets inside a ConstraintLayout as a source or a target of a
// Constraint. Guides can be used like guidelines or as flexible space.
//
// Unlike a Widget, a ConstraintGuide will not be drawn.
type ConstraintGuide interface {
	gextras.Objector

	// MaxSize: gets the maximum size of @guide.
	MaxSize(width int, height int)
	// MinSize: gets the minimum size of @guide.
	MinSize(width int, height int)
	// Name: retrieves the name set using gtk_constraint_guide_set_name().
	Name() string
	// NatSize: gets the natural size of @guide.
	NatSize(width int, height int)
	// Strength: retrieves the strength set using
	// gtk_constraint_guide_set_strength().
	Strength() ConstraintStrength
	// SetMaxSize: sets the maximum size of @guide.
	//
	// If @guide is attached to a ConstraintLayout, the constraints will be
	// updated to reflect the new size.
	SetMaxSize(width int, height int)
	// SetMinSize: sets the minimum size of @guide.
	//
	// If @guide is attached to a ConstraintLayout, the constraints will be
	// updated to reflect the new size.
	SetMinSize(width int, height int)
	// SetName: sets a name for the given ConstraintGuide.
	//
	// The name is useful for debugging purposes.
	SetName(name string)
	// SetNatSize: sets the natural size of @guide.
	//
	// If @guide is attached to a ConstraintLayout, the constraints will be
	// updated to reflect the new size.
	SetNatSize(width int, height int)
	// SetStrength: sets the strength of the constraint on the natural size of
	// the given ConstraintGuide.
	SetStrength(strength ConstraintStrength)
}

type constraintGuide struct {
	*externglib.Object
}

func wrapConstraintGuide(obj *externglib.Object) ConstraintGuide {
	return constraintGuide{*externglib.Object{obj}}
}

func marshalConstraintGuide(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewConstraintGuide() ConstraintGuide

func (c constraintGuide) MaxSize(width int, height int)

func (c constraintGuide) MinSize(width int, height int)

func (c constraintGuide) Name() string

func (c constraintGuide) NatSize(width int, height int)

func (c constraintGuide) Strength() ConstraintStrength

func (c constraintGuide) SetMaxSize(width int, height int)

func (c constraintGuide) SetMinSize(width int, height int)

func (c constraintGuide) SetName(name string)

func (c constraintGuide) SetNatSize(width int, height int)

func (c constraintGuide) SetStrength(strength ConstraintStrength)

// ConstraintLayout: gtkConstraintLayout is a layout manager that uses relations
// between widget attributes, expressed via Constraint instances, to measure and
// allocate widgets.
//
//
// How do constraints work
//
// Constraints are objects defining the relationship between attributes of a
// widget; you can read the description of the Constraint class to have a more
// in depth definition.
//
// By taking multiple constraints and applying them to the children of a widget
// using ConstraintLayout, it's possible to describe complex layout policies;
// each constraint applied to a child or to the parent widgets contributes to
// the full description of the layout, in terms of parameters for resolving the
// value of each attribute.
//
// It is important to note that a layout is defined by the totality of
// constraints; removing a child, or a constraint, from an existing layout
// without changing the remaining constraints may result in an unstable or
// unsolvable layout.
//
// Constraints have an implicit "reading order"; you should start describing
// each edge of each child, as well as their relationship with the parent
// container, from the top left (or top right, in RTL languages), horizontally
// first, and then vertically.
//
// A constraint-based layout with too few constraints can become "unstable",
// that is: have more than one solution. The behavior of an unstable layout is
// undefined.
//
// A constraint-based layout with conflicting constraints may be unsolvable, and
// lead to an unstable layout. You can use the Constraint:strength property of
// Constraint to "nudge" the layout towards a solution.
//
//
// GtkConstraintLayout as GtkBuildable
//
// GtkConstraintLayout implements the Buildable interface and has a custom
// "constraints" element which allows describing constraints in a GtkBuilder UI
// file.
//
// An example of a UI definition fragment specifying a constraint:
//
//
//      <object class="GtkConstraintLayout">
//        <constraints>
//          <constraint target="button" target-attribute="start"
//                      relation="eq"
//                      source="super" source-attribute="start"
//                      constant="12"
//                      strength="required" />
//          <constraint target="button" target-attribute="width"
//                      relation="ge"
//                      constant="250"
//                      strength="strong" />
//        </constraints>
//      </object>
//
// The definition above will add two constraints to the GtkConstraintLayout:
//
// - a required constraint between the leading edge of "button" and the leading
// edge of the widget using the constraint layout, plus 12 pixels - a strong,
// constant constraint making the width of "button" greater than, or equal to
// 250 pixels
//
// The "target" and "target-attribute" attributes are required.
//
// The "source" and "source-attribute" attributes of the "constraint" element
// are optional; if they are not specified, the constraint is assumed to be a
// constant.
//
// The "relation" attribute is optional; if not specified, the constraint is
// assumed to be an equality.
//
// The "strength" attribute is optional; if not specified, the constraint is
// assumed to be required.
//
// The "source" and "target" attributes can be set to "super" to indicate that
// the constraint target is the widget using the GtkConstraintLayout.
//
// There can be "constant" and "multiplier" attributes.
//
// Additionally, the "constraints" element can also contain a description of the
// ConstraintGuides used by the layout:
//
//
//      <constraints>
//        <guide min-width="100" max-width="500" name="hspace"/>
//        <guide min-height="64" nat-height="128" name="vspace" strength="strong"/>
//      </constraints>
//
// The "guide" element has the following optional attributes:
//
// - "min-width", "nat-width", and "max-width", describe the minimum, natural,
// and maximum width of the guide, respectively - "min-height", "nat-height",
// and "max-height", describe the minimum, natural, and maximum height of the
// guide, respectively - "strength" describes the strength of the constraint on
// the natural size of the guide; if not specified, the constraint is assumed to
// have a medium strength - "name" describes a name for the guide, useful when
// debugging
//
//
// Using the Visual Format Language
//
// Complex constraints can be described using a compact syntax called VFL, or
// *Visual Format Language*.
//
// The Visual Format Language describes all the constraints on a row or column,
// typically starting from the leading edge towards the trailing one. Each
// element of the layout is composed by "views", which identify a
// ConstraintTarget.
//
// For instance:
//
//
//      [button]-[textField]
//
// Describes a constraint that binds the trailing edge of "button" to the
// leading edge of "textField", leaving a default space between the two.
//
// Using VFL is also possible to specify predicates that describe constraints on
// attributes like width and height:
//
//
//      // Width must be greater than, or equal to 50
//      [button(>=50)]
//
//      // Width of button1 must be equal to width of button2
//      [button1(==button2)]
//
//
// The default orientation for a VFL description is horizontal, unless otherwise
// specified:
//
//
//      // horizontal orientation, default attribute: width
//      H:[button(>=150)]
//
//      // vertical orientation, default attribute: height
//      V:[button1(==button2)]
//
//
// It's also possible to specify multiple predicates, as well as their strength:
//
//
//      // minimum width of button must be 150
//      // natural width of button can be 250
//      [button(>=150@required, ==250@medium)]
//
// Finally, it's also possible to use simple arithmetic operators:
//
//
//      // width of button1 must be equal to width of button2
//      // divided by 2 plus 12
//      [button1(button2 / 2 + 12)]
type ConstraintLayout interface {
	LayoutManager

	// AddConstraint: adds a Constraint to the layout manager.
	//
	// The Constraint:source and Constraint:target properties of @constraint can
	// be:
	//
	// - set to nil to indicate that the constraint refers to the widget using
	// @layout - set to the Widget using @layout - set to a child of the Widget
	// using @layout - set to a guide that is part of @layout
	//
	// The @layout acquires the ownership of @constraint after calling this
	// function.
	AddConstraint(constraint Constraint)
	// AddConstraintsFromDescriptionv: creates a list of constraints from a
	// formal description using a compact description syntax called VFL, or
	// "Visual Format Language".
	//
	// The Visual Format Language is based on Apple's AutoLayout
	// [VFL](https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/VisualFormatLanguage.html).
	//
	// The @views dictionary is used to match ConstraintTargets to the symbolic
	// view name inside the VFL.
	//
	// The VFL grammar is:
	//
	//         <visualFormatString> = (<orientation>)?
	//                                (<superview><connection>)?
	//                                <view>(<connection><view>)*
	//                                (<connection><superview>)?
	//                <orientation> = 'H' | 'V'
	//                  <superview> = '|'
	//                 <connection> = '' | '-' <predicateList> '-' | '-'
	//              <predicateList> = <simplePredicate> | <predicateListWithParens>
	//            <simplePredicate> = <metricName> | <positiveNumber>
	//    <predicateListWithParens> = '(' <predicate> (',' <predicate>)* ')'
	//                  <predicate> = (<relation>)? <objectOfPredicate> (<operatorList>)? ('@' <priority>)?
	//                   <relation> = '==' | '<=' | '>='
	//          <objectOfPredicate> = <constant> | <viewName> | ('.' <attributeName>)?
	//                   <priority> = <positiveNumber> | 'required' | 'strong' | 'medium' | 'weak'
	//                   <constant> = <number>
	//               <operatorList> = (<multiplyOperator>)? (<addOperator>)?
	//           <multiplyOperator> = [ '*' | '/' ] <positiveNumber>
	//                <addOperator> = [ '+' | '-' ] <positiveNumber>
	//                   <viewName> = [A-Za-z_]([A-Za-z0-9_]*) // A C identifier
	//                 <metricName> = [A-Za-z_]([A-Za-z0-9_]*) // A C identifier
	//              <attributeName> = 'top' | 'bottom' | 'left' | 'right' | 'width' | 'height' |
	//                                'start' | 'end' | 'centerX' | 'centerY' | 'baseline'
	//             <positiveNumber> // A positive real number parseable by g_ascii_strtod()
	//                     <number> // A real number parseable by g_ascii_strtod()
	//
	// **Note**: The VFL grammar used by GTK is slightly different than the one
	// defined by Apple, as it can use symbolic values for the constraint's
	// strength instead of numeric values; additionally, GTK allows adding
	// simple arithmetic operations inside predicates.
	//
	// Examples of VFL descriptions are:
	//
	//      // Default spacing
	//      [button]-[textField]
	//
	//      // Width constraint
	//      [button(>=50)]
	//
	//      // Connection to super view
	//      |-50-[purpleBox]-50-|
	//
	//      // Vertical layout
	//      V:[topField]-10-[bottomField]
	//
	//      // Flush views
	//      [maroonView][blueView]
	//
	//      // Priority
	//      [button(100@strong)]
	//
	//      // Equal widths
	//      [button1(==button2)]
	//
	//      // Multiple predicates
	//      [flexibleButton(>=70,<=100)]
	//
	//      // A complete line of layout
	//      |-[find]-[findNext]-[findField(>=20)]-|
	//
	//      // Operators
	//      [button1(button2 / 3 + 50)]
	//
	//      // Named attributes
	//      [button1(==button2.height)]
	//
	AddConstraintsFromDescriptionv(lines []string, hspacing int, vspacing int, views *glib.HashTable) *glib.List
	// AddGuide: adds a guide to @layout. A guide can be used as the source or
	// target of constraints, like a widget, but it is not visible.
	//
	// The @layout acquires the ownership of @guide after calling this function.
	AddGuide(guide ConstraintGuide)
	// ObserveConstraints: returns a Model to track the constraints that are
	// part of @layout.
	//
	// Calling this function will enable extra internal bookkeeping to track
	// constraints and emit signals on the returned listmodel. It may slow down
	// operations a lot.
	//
	// Applications should try hard to avoid calling this function because of
	// the slowdowns.
	ObserveConstraints() gio.ListModel
	// ObserveGuides: returns a Model to track the guides that are part of
	// @layout.
	//
	// Calling this function will enable extra internal bookkeeping to track
	// guides and emit signals on the returned listmodel. It may slow down
	// operations a lot.
	//
	// Applications should try hard to avoid calling this function because of
	// the slowdowns.
	ObserveGuides() gio.ListModel
	// RemoveAllConstraints: removes all constraints from the layout manager.
	RemoveAllConstraints()
	// RemoveConstraint: removes @constraint from the layout manager, so that it
	// no longer influences the layout.
	RemoveConstraint(constraint Constraint)
	// RemoveGuide: removes @guide from the layout manager, so that it no longer
	// influences the layout.
	RemoveGuide(guide ConstraintGuide)
}

type constraintLayout struct {
	layoutManager
}

func wrapConstraintLayout(obj *externglib.Object) ConstraintLayout {
	return constraintLayout{layoutManager{*externglib.Object{obj}}}
}

func marshalConstraintLayout(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewConstraintLayout() ConstraintLayout

func (c constraintLayout) AddConstraint(constraint Constraint)

func (c constraintLayout) AddConstraintsFromDescriptionv(lines []string, hspacing int, vspacing int, views *glib.HashTable) *glib.List

func (c constraintLayout) AddGuide(guide ConstraintGuide)

func (c constraintLayout) ObserveConstraints() gio.ListModel

func (c constraintLayout) ObserveGuides() gio.ListModel

func (c constraintLayout) RemoveAllConstraints()

func (c constraintLayout) RemoveConstraint(constraint Constraint)

func (c constraintLayout) RemoveGuide(guide ConstraintGuide)

// ConstraintLayoutChild: a LayoutChild in a ConstraintLayout.
type ConstraintLayoutChild interface {
	LayoutChild
}

type constraintLayoutChild struct {
	layoutChild
}

func wrapConstraintLayoutChild(obj *externglib.Object) ConstraintLayoutChild {
	return constraintLayoutChild{layoutChild{*externglib.Object{obj}}}
}

func marshalConstraintLayoutChild(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// CSSProvider: gtkCssProvider is an object implementing the StyleProvider
// interface. It is able to parse [CSS-like][css-overview] input in order to
// style widgets.
//
// An application can make GTK parse a specific CSS style sheet by calling
// gtk_css_provider_load_from_file() or gtk_css_provider_load_from_resource()
// and adding the provider with gtk_style_context_add_provider() or
// gtk_style_context_add_provider_for_display().
//
// In addition, certain files will be read when GTK is initialized. First, the
// file `$XDG_CONFIG_HOME/gtk-4.0/gtk.css` is loaded if it exists. Then, GTK
// loads the first existing file among
// `XDG_DATA_HOME/themes/THEME/gtk-VERSION/gtk-VARIANT.css`,
// `$HOME/.themes/THEME/gtk-VERSION/gtk-VARIANT.css`,
// `$XDG_DATA_DIRS/themes/THEME/gtk-VERSION/gtk-VARIANT.css` and
// `DATADIR/share/themes/THEME/gtk-VERSION/gtk-VARIANT.css`, where `THEME` is
// the name of the current theme (see the Settings:gtk-theme-name setting),
// VARIANT is the variant to load (see the
// Settings:gtk-application-prefer-dark-theme setting), `DATADIR` is the prefix
// configured when GTK was compiled (unless overridden by the `GTK_DATA_PREFIX`
// environment variable), and `VERSION` is the GTK version number. If no file is
// found for the current version, GTK tries older versions all the way back to
// 4.0.
type CSSProvider interface {
	gextras.Objector

	// LoadFromData: loads @data into @css_provider, and by doing so clears any
	// previously loaded information.
	LoadFromData(data []uint8)
	// LoadFromFile: loads the data contained in @file into @css_provider,
	// making it clear any previously loaded information.
	LoadFromFile(file gio.File)
	// LoadFromPath: loads the data contained in @path into @css_provider,
	// making it clear any previously loaded information.
	LoadFromPath(path string)
	// LoadFromResource: loads the data contained in the resource at
	// @resource_path into the CssProvider, clearing any previously loaded
	// information.
	//
	// To track errors while loading CSS, connect to the
	// CssProvider::parsing-error signal.
	LoadFromResource(resourcePath string)
	// LoadNamed: loads a theme from the usual theme paths. The actual process
	// of finding the theme might change between releases, but it is guaranteed
	// that this function uses the same mechanism to load the theme that GTK
	// uses for loading its own theme.
	LoadNamed(name string, variant string)
	// ToString: converts the @provider into a string representation in CSS
	// format.
	//
	// Using gtk_css_provider_load_from_data() with the return value from this
	// function on a new provider created with gtk_css_provider_new() will
	// basically create a duplicate of this @provider.
	ToString() string
}

type cssProvider struct {
	*externglib.Object
}

func wrapCSSProvider(obj *externglib.Object) CSSProvider {
	return cssProvider{*externglib.Object{obj}}
}

func marshalCSSProvider(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewCSSProvider() CSSProvider

func (c cssProvider) LoadFromData(data []uint8)

func (c cssProvider) LoadFromFile(file gio.File)

func (c cssProvider) LoadFromPath(path string)

func (c cssProvider) LoadFromResource(resourcePath string)

func (c cssProvider) LoadNamed(name string, variant string)

func (c cssProvider) ToString() string

// CustomFilter is a Filter that uses a callback to determine whether to include
// an item or not.
type CustomFilter interface {
	Filter

	// SetFilterFunc: sets (or unsets) the function used for filtering items.
	//
	// If @match_func is nil, the filter matches all items.
	//
	// If the filter func changes its filtering behavior, gtk_filter_changed()
	// needs to be called.
	//
	// If a previous function was set, its @user_destroy will be called now.
	SetFilterFunc(matchFunc CustomFilterFunc)
}

type customFilter struct {
	filter
}

func wrapCustomFilter(obj *externglib.Object) CustomFilter {
	return customFilter{filter{*externglib.Object{obj}}}
}

func marshalCustomFilter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewCustomFilter(matchFunc CustomFilterFunc) CustomFilter

func (c customFilter) SetFilterFunc(matchFunc CustomFilterFunc)

// CustomLayout is a convenience type meant to be used as a transition mechanism
// between Widgets implementing a layout policy, and LayoutManager classes.
//
// A CustomLayout uses closures matching to the old Widget virtual functions for
// size negotiation, as a convenience API to ease the porting towards the
// corresponding LayoutManager virtual functions.
type CustomLayout interface {
	LayoutManager
}

type customLayout struct {
	layoutManager
}

func wrapCustomLayout(obj *externglib.Object) CustomLayout {
	return customLayout{layoutManager{*externglib.Object{obj}}}
}

func marshalCustomLayout(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewCustomLayout(requestMode CustomRequestModeFunc, measure CustomMeasureFunc, allocate CustomAllocateFunc) CustomLayout

// CustomSorter: gtkCustomSorter is a Sorter implementation that sorts via a
// traditional DataFunc callback.
type CustomSorter interface {
	Sorter

	// SetSortFunc: sets (or unsets) the function used for sorting items.
	//
	// If @sort_func is nil, all items are considered equal.
	//
	// If the sort func changes its sorting behavior, gtk_sorter_changed() needs
	// to be called.
	//
	// If a previous function was set, its @user_destroy will be called now.
	SetSortFunc(sortFunc glib.CompareDataFunc)
}

type customSorter struct {
	sorter
}

func wrapCustomSorter(obj *externglib.Object) CustomSorter {
	return customSorter{sorter{*externglib.Object{obj}}}
}

func marshalCustomSorter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewCustomSorter(sortFunc glib.CompareDataFunc) CustomSorter

func (c customSorter) SetSortFunc(sortFunc glib.CompareDataFunc)

// Dialog: dialogs are a convenient way to prompt the user for a small amount of
// input, e.g. to display a message, ask a question, or anything else that does
// not require extensive effort on the user’s part.
//
// The main area of a GtkDialog is called the "content area", and is yours to
// populate with widgets such a Label or Entry, to present your information,
// questions, or tasks to the user. In addition, dialogs allow you to add
// "action widgets". Most commonly, action widgets are buttons. Depending on the
// platform, action widgets may be presented in the header bar at the top of the
// window, or at the bottom of the window. To add action widgets, use GtkDialog
// using gtk_dialog_new_with_buttons(), gtk_dialog_add_button(),
// gtk_dialog_add_buttons(), or gtk_dialog_add_action_widget().
//
// Clicking a button that was added as an action widget will emit the
// Dialog::response signal with a response ID that you specified. GTK will never
// assign a meaning to positive response IDs; these are entirely user-defined.
// But for convenience, you can use the response IDs in the ResponseType
// enumeration (these all have values less than zero). If a dialog receives a
// delete event, the Dialog::response signal will be emitted with the
// K_RESPONSE_DELETE_EVENT response ID.
//
// Dialogs are created with a call to gtk_dialog_new() or
// gtk_dialog_new_with_buttons(). gtk_dialog_new_with_buttons() is recommended;
// it allows you to set the dialog title, some convenient flags, and add simple
// buttons.
//
// A “modal” dialog (that is, one which freezes the rest of the application from
// user input), can be created by calling gtk_window_set_modal() on the dialog.
// Use the GTK_WINDOW() macro to cast the widget returned from gtk_dialog_new()
// into a Window. When using gtk_dialog_new_with_buttons() you can also pass the
// K_DIALOG_MODAL flag to make a dialog modal.
//
// For the simple dialog in the following example, a MessageDialog would save
// some effort. But you’d need to create the dialog contents manually if you had
// more than a simple message in the dialog.
//
// An example for simple GtkDialog usage: |[<!-- language="C" --> // Function to
// open a dialog box with a message void quick_message (GtkWindow *parent, char
// *message) { GtkWidget *dialog, *label, *content_area; GtkDialogFlags flags;
//
// // Create the widgets flags = GTK_DIALOG_DESTROY_WITH_PARENT; dialog =
// // gtk_dialog_new_with_buttons ("Message", parent, flags, _("_OK"),
// // GTK_RESPONSE_NONE, NULL); content_area = gtk_dialog_get_content_area
// // (GTK_DIALOG (dialog)); label = gtk_label_new (message);
//
// // Ensure that the dialog box is destroyed when the user responds
//
// g_signal_connect_swapped (dialog, "response", G_CALLBACK
// (gtk_window_destroy), dialog);
//
// // Add the label, and show everything we’ve added
//
//     gtk_box_append (GTK_BOX (content_area), label);
//     gtk_widget_show (dialog);
//    }
//
//
//    # GtkDialog as GtkBuildable
//
//    The GtkDialog implementation of the Buildable interface exposes the
//    @content_area as an internal child with the name “content_area”.
//
//    GtkDialog supports a custom <action-widgets> element, which can contain
//    multiple <action-widget> elements. The “response” attribute specifies a
//    numeric response, and the content of the element is the id of widget
//    (which should be a child of the dialogs @action_area). To mark a response
//    as default, set the “default“ attribute of the <action-widget> element
//    to true.
//
//    GtkDialog supports adding action widgets by specifying “action“ as
//    the “type“ attribute of a <child> element. The widget will be added
//    either to the action area or the headerbar of the dialog, depending
//    on the “use-header-bar“ property. The response id has to be associated
//    with the action widget using the <action-widgets> element.
//
//
//    <object class="GtkDialog" id="dialog1">
//      <child type="action">
//        <object class="GtkButton" id="button_cancel"/>
//      </child>
//      <child type="action">
//        <object class="GtkButton" id="button_ok">
//        </object>
//      </child>
//      <action-widgets>
//        <action-widget response="cancel">button_cancel</action-widget>
//        <action-widget response="ok" default="true">button_ok</action-widget>
//      </action-widgets>
//    </object>
//
//
// Accessibility
//
// GtkDialog uses the K_ACCESSIBLE_ROLE_DIALOG role.
type Dialog interface {
	Window

	// AddActionWidget: adds an activatable widget to the action area of a
	// Dialog, connecting a signal handler that will emit the Dialog::response
	// signal on the dialog when the widget is activated. The widget is appended
	// to the end of the dialog’s action area. If you want to add a
	// non-activatable widget, simply pack it into the @action_area field of the
	// Dialog struct.
	AddActionWidget(child Widget, responseID int)
	// AddButton: adds a button with the given text and sets things up so that
	// clicking the button will emit the Dialog::response signal with the given
	// @response_id. The button is appended to the end of the dialog’s action
	// area. The button widget is returned, but usually you don’t need it.
	AddButton(buttonText string, responseID int) Widget
	// ContentArea: returns the content area of @dialog.
	ContentArea() Widget
	// HeaderBar: returns the header bar of @dialog. Note that the headerbar is
	// only used by the dialog if the Dialog:use-header-bar property is true.
	HeaderBar() Widget
	// ResponseForWidget: gets the response id of a widget in the action area of
	// a dialog.
	ResponseForWidget(widget Widget) int
	// WidgetForResponse: gets the widget button that uses the given response ID
	// in the action area of a dialog.
	WidgetForResponse(responseID int) Widget
	// Response: emits the Dialog::response signal with the given response ID.
	//
	// Used to indicate that the user has responded to the dialog in some way.
	Response(responseID int)
	// SetDefaultResponse: sets the last widget in the dialog’s action area with
	// the given @response_id as the default widget for the dialog. Pressing
	// “Enter” normally activates the default widget.
	SetDefaultResponse(responseID int)
	// SetResponseSensitive: calls `gtk_widget_set_sensitive (widget, @setting)`
	// for each widget in the dialog’s action area with the given @response_id.
	// A convenient way to sensitize/desensitize dialog buttons.
	SetResponseSensitive(responseID int, setting bool)
}

type dialog struct {
	window
}

func wrapDialog(obj *externglib.Object) Dialog {
	return dialog{window{widget{externglib.InitiallyUnowned{obj}}}}
}

func marshalDialog(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewDialog() Dialog

func (d dialog) AddActionWidget(child Widget, responseID int)

func (d dialog) AddButton(buttonText string, responseID int) Widget

func (d dialog) ContentArea() Widget

func (d dialog) HeaderBar() Widget

func (d dialog) ResponseForWidget(widget Widget) int

func (d dialog) WidgetForResponse(responseID int) Widget

func (d dialog) Response(responseID int)

func (d dialog) SetDefaultResponse(responseID int)

func (d dialog) SetResponseSensitive(responseID int, setting bool)

// DirectoryList is a list model that wraps g_file_enumerate_children_async().
// It presents a Model and fills it asynchronously with the Infos returned from
// that function.
//
// Enumeration will start automatically when a the DirectoryList:file property
// is set.
//
// While the DirectoryList is being filled, the DirectoryList:loading property
// will be set to true. You can listen to that property if you want to show
// information like a Spinner or a "Loading..." text.
//
// If loading fails at any point, the DirectoryList:error property will be set
// to give more indication about the failure.
//
// The Infos returned from a DirectoryList have the "standard::file" attribute
// set to the #GFile they refer to. This way you can get at the file that is
// referred to in the same way you would via g_file_enumerator_get_child(). This
// means you do not need access to the DirectoryList but can access the #GFile
// directly from the Info when operating with a ListView or similar.
type DirectoryList interface {
	gextras.Objector

	// Attributes: gets the attributes queried on the children.
	Attributes() string
	// Error: gets the loading error, if any.
	//
	// If an error occurs during the loading process, the loading process will
	// finish and this property allows querying the error that happened. This
	// error will persist until a file is loaded again.
	//
	// An error being set does not mean that no files were loaded, and all
	// successfully queried files will remain in the list.
	Error() *glib.Error
	// File: gets the file whose children are currently enumerated.
	File() gio.File
	// IOPriority: gets the IO priority set via
	// gtk_directory_list_set_io_priority().
	IOPriority() int
	// Monitored: returns whether the directory list is monitoring the directory
	// for changes.
	Monitored() bool
	// IsLoading: returns true if the children enumeration is currently in
	// progress.
	//
	// Files will be added to @self from time to time while loading is going on.
	// The order in which are added is undefined and may change in between runs.
	IsLoading() bool
	// SetAttributes: sets the @attributes to be enumerated and starts the
	// enumeration.
	//
	// If @attributes is nil, no attributes will be queried, but a list of Infos
	// will still be created.
	SetAttributes(attributes string)
	// SetFile: sets the @file to be enumerated and starts the enumeration.
	//
	// If @file is nil, the result will be an empty list.
	SetFile(file gio.File)
	// SetIOPriority: sets the IO priority to use while loading directories.
	//
	// Setting the priority while @self is loading will reprioritize the ongoing
	// load as soon as possible.
	//
	// The default IO priority is G_PRIORITY_DEFAULT, which is higher than the
	// GTK redraw priority. If you are loading a lot of directories in parallel,
	// lowering it to something like G_PRIORITY_DEFAULT_IDLE may increase
	// responsiveness.
	SetIOPriority(ioPriority int)
	// SetMonitored: sets whether the directory list will monitor the directory
	// for changes. If monitoring is enabled, the Model::items-changed signal
	// will be emitted when the directory contents change.
	//
	// When monitoring is turned on after the initial creation of the directory
	// list, the directory is reloaded to avoid missing files that appeared
	// between the initial loading and when monitoring was turned on.
	SetMonitored(monitored bool)
}

type directoryList struct {
	*externglib.Object
}

func wrapDirectoryList(obj *externglib.Object) DirectoryList {
	return directoryList{*externglib.Object{obj}}
}

func marshalDirectoryList(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewDirectoryList(attributes string, file gio.File) DirectoryList

func (d directoryList) Attributes() string

func (d directoryList) Error() *glib.Error

func (d directoryList) File() gio.File

func (d directoryList) IOPriority() int

func (d directoryList) Monitored() bool

func (d directoryList) IsLoading() bool

func (d directoryList) SetAttributes(attributes string)

func (d directoryList) SetFile(file gio.File)

func (d directoryList) SetIOPriority(ioPriority int)

func (d directoryList) SetMonitored(monitored bool)

// DragIcon: gtkDragIcon is a Root implementation with the sole purpose to serve
// as a drag icon during DND operations. A drag icon moves with the pointer
// during a drag operation and is destroyed when the drag ends.
//
// To set up a drag icon and associate it with an ongoing drag operation, use
// gtk_drag_icon_get_for_drag() to get the icon for a drag. You can then use it
// like any other widget and use gtk_drag_icon_set_child() to set whatever
// widget should be used for the drag icon.
//
// Keep in mind that drag icons do not allow user input.
type DragIcon interface {
	Widget

	// Child: gets the widget currently used as drag icon.
	Child() Widget
	// SetChild: sets the widget to display as the drag icon.
	SetChild(child Widget)
}

type dragIcon struct {
	widget
}

func wrapDragIcon(obj *externglib.Object) DragIcon {
	return dragIcon{widget{externglib.InitiallyUnowned{obj}}}
}

func marshalDragIcon(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func (d dragIcon) Child() Widget

func (d dragIcon) SetChild(child Widget)

// DragSource: gtkDragSource is an auxiliary object that is used to initiate
// Drag-And-Drop operations. It can be set up with the necessary ingredients for
// a DND operation ahead of time. This includes the source for the data that is
// being transferred, in the form of a ContentProvider, the desired action, and
// the icon to use during the drag operation. After setting it up, the drag
// source must be added to a widget as an event controller, using
// gtk_widget_add_controller().
//
//    static void
//    my_widget_init (MyWidget *self)
//    {
//      GtkDragSource *drag_source = gtk_drag_source_new ();
//
//      g_signal_connect (drag_source, "prepare", G_CALLBACK (on_drag_prepare), self);
//      g_signal_connect (drag_source, "drag-begin", G_CALLBACK (on_drag_begin), self);
//
//      gtk_widget_add_controller (GTK_WIDGET (self), GTK_EVENT_CONTROLLER (drag_source));
//    }
//
//
// Setting up the content provider and icon ahead of time only makes sense when
// the data does not change. More commonly, you will want to set them up just in
// time. To do so, DragSource has DragSource::prepare and DragSource::drag-begin
// signals.
//
// The ::prepare signal is emitted before a drag is started, and can be used to
// set the content provider and actions that the drag should be started with.
//
//    static GdkContentProvider *
//    on_drag_prepare (GtkDragSource *source,
//                     double         x,
//                     double         y,
//                     MyWidget      *self)
//    {
//      // This widget supports two types of content: GFile objects
//      // and GdkPixbuf objects; GTK will handle the serialization
//      // of these types automatically
//      GFile *file = my_widget_get_file (self);
//      GdkPixbuf *pixbuf = my_widget_get_pixbuf (self);
//
//      return gdk_content_provider_new_union ((GdkContentProvider *[2]) {
//          gdk_content_provider_new_typed (G_TYPE_FILE, file),
//          gdk_content_provider_new_typed (GDK_TYPE_PIXBUF, pixbuf),
//        }, 2);
//    }
//
//
// The ::drag-begin signal is emitted after the Drag object has been created,
// and can be used to set up the drag icon.
//
//    static void
//    on_drag_begin (GtkDragSource *source,
//                   GtkDrag       *drag,
//                   MyWidget      *self)
//    {
//      // Set the widget as the drag icon
//      GdkPaintable *paintable = gtk_widget_paintable_new (GTK_WIDGET (self));
//      gtk_drag_source_set_icon (source, paintable, 0, 0);
//      g_object_unref (paintable);
//    }
//
// During the DND operation, GtkDragSource emits signals that can be used to
// obtain updates about the status of the operation, but it is not normally
// necessary to connect to any signals, except for one case: when the supported
// actions include GDK_ACTION_MOVE, you need to listen for the
// DragSource::drag-end signal and delete the data after it has been
// transferred.
type DragSource interface {
	GestureSingle

	// DragCancel: cancels a currently ongoing drag operation.
	DragCancel()
	// Actions: gets the actions that are currently set on the DragSource.
	Actions() gdk.DragAction
	// Content: gets the current content provider of a DragSource.
	Content() gdk.ContentProvider
	// Drag: returns the underlying Drag object for an ongoing drag.
	Drag() gdk.Drag
	// SetActions: sets the actions on the DragSource.
	//
	// During a DND operation, the actions are offered to potential drop
	// targets. If @actions include GDK_ACTION_MOVE, you need to listen to the
	// DragSource::drag-end signal and handle @delete_data being true.
	//
	// This function can be called before a drag is started, or in a handler for
	// the DragSource::prepare signal.
	SetActions(actions gdk.DragAction)
	// SetContent: sets a content provider on a DragSource.
	//
	// When the data is requested in the cause of a DND operation, it will be
	// obtained from the content provider.
	//
	// This function can be called before a drag is started, or in a handler for
	// the DragSource::prepare signal.
	//
	// You may consider setting the content provider back to nil in a
	// DragSource::drag-end signal handler.
	SetContent(content gdk.ContentProvider)
	// SetIcon: sets a paintable to use as icon during DND operations.
	//
	// The hotspot coordinates determine the point on the icon that gets aligned
	// with the hotspot of the cursor.
	//
	// If @paintable is nil, a default icon is used.
	//
	// This function can be called before a drag is started, or in a
	// DragSource::prepare or DragSource::drag-begin signal handler.
	SetIcon(paintable gdk.Paintable, hotX int, hotY int)
}

type dragSource struct {
	gestureSingle
}

func wrapDragSource(obj *externglib.Object) DragSource {
	return dragSource{gestureSingle{gesture{eventController{*externglib.Object{obj}}}}}
}

func marshalDragSource(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewDragSource() DragSource

func (d dragSource) DragCancel()

func (d dragSource) Actions() gdk.DragAction

func (d dragSource) Content() gdk.ContentProvider

func (d dragSource) Drag() gdk.Drag

func (d dragSource) SetActions(actions gdk.DragAction)

func (d dragSource) SetContent(content gdk.ContentProvider)

func (d dragSource) SetIcon(paintable gdk.Paintable, hotX int, hotY int)

// DrawingArea: the DrawingArea widget is used for creating custom user
// interface elements. It’s essentially a blank widget; you can draw on it.
// After creating a drawing area, the application may want to connect to:
//
// - The Widget::realize signal to take any necessary actions when the widget is
// instantiated on a particular display. (Create GDK resources in response to
// this signal.)
//
// - The DrawingArea::resize signal to take any necessary actions when the
// widget changes size.
//
// - Call gtk_drawing_area_set_draw_func() to handle redrawing the contents of
// the widget.
//
// The following code portion demonstrates using a drawing area to display a
// circle in the normal widget foreground color.
//
// Simple GtkDrawingArea usage
//
//    static void
//    draw_function (GtkDrawingArea *area,
//                   cairo_t        *cr,
//                   int             width,
//                   int             height,
//                   gpointer        data)
//    {
//      GdkRGBA color;
//      GtkStyleContext *context;
//
//      context = gtk_widget_get_style_context (GTK_WIDGET (area));
//
//      cairo_arc (cr,
//                 width / 2.0, height / 2.0,
//                 MIN (width, height) / 2.0,
//                 0, 2 * G_PI);
//
//      gtk_style_context_get_color (context,
//                                   &color);
//      gdk_cairo_set_source_rgba (cr, &color);
//
//      cairo_fill (cr);
//    }
//
//    int
//    main (int argc, char **argv)
//    {
//      gtk_init ();
//
//      GtkWidget *area = gtk_drawing_area_new ();
//      gtk_drawing_area_set_content_width (GTK_DRAWING_AREA (area), 100);
//      gtk_drawing_area_set_content_height (GTK_DRAWING_AREA (area), 100);
//      gtk_drawing_area_set_draw_func (GTK_DRAWING_AREA (area),
//                                      draw_function,
//                                      NULL, NULL);
//      return 0;
//    }
//
//
// The draw function is normally called when a drawing area first comes
// onscreen, or when it’s covered by another window and then uncovered. You can
// also force a redraw by adding to the “damage region” of the drawing area’s
// window using gtk_widget_queue_draw(). This will cause the drawing area to
// call the draw function again.
//
// The available routines for drawing are documented on the [GDK Drawing
// Primitives][gdk4-Cairo-Interaction] page and the cairo documentation.
//
// To receive mouse events on a drawing area, you will need to use event
// controllers. To receive keyboard events, you will need to set the “can-focus”
// property on the drawing area, and you should probably draw some user-visible
// indication that the drawing area is focused.
//
// If you need more complex control over your widget, you should consider
// creating your own Widget subclass.
type DrawingArea interface {
	Widget

	// ContentHeight: retrieves the value previously set via
	// gtk_drawing_area_set_content_height().
	ContentHeight() int
	// ContentWidth: retrieves the value previously set via
	// gtk_drawing_area_set_content_width().
	ContentWidth() int
	// SetContentHeight: sets the desired height of the contents of the drawing
	// area. Note that because widgets may be allocated larger sizes than they
	// requested, it is possible that the actual height passed to your draw
	// function is larger than the height set here. You can use
	// gtk_widget_set_valign() to avoid that.
	//
	// If the height is set to 0 (the default), the drawing area may disappear.
	SetContentHeight(height int)
	// SetContentWidth: sets the desired width of the contents of the drawing
	// area. Note that because widgets may be allocated larger sizes than they
	// requested, it is possible that the actual width passed to your draw
	// function is larger than the width set here. You can use
	// gtk_widget_set_halign() to avoid that.
	//
	// If the width is set to 0 (the default), the drawing area may disappear.
	SetContentWidth(width int)
	// SetDrawFunc: setting a draw function is the main thing you want to do
	// when using a drawing area. It is called whenever GTK needs to draw the
	// contents of the drawing area to the screen.
	//
	// The draw function will be called during the drawing stage of GTK. In the
	// drawing stage it is not allowed to change properties of any GTK widgets
	// or call any functions that would cause any properties to be changed. You
	// should restrict yourself exclusively to drawing your contents in the draw
	// function.
	//
	// If what you are drawing does change, call gtk_widget_queue_draw() on the
	// drawing area. This will cause a redraw and will call @draw_func again.
	SetDrawFunc(drawFunc DrawingAreaDrawFunc)
}

type drawingArea struct {
	widget
}

func wrapDrawingArea(obj *externglib.Object) DrawingArea {
	return drawingArea{widget{externglib.InitiallyUnowned{obj}}}
}

func marshalDrawingArea(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewDrawingArea() DrawingArea

func (d drawingArea) ContentHeight() int

func (d drawingArea) ContentWidth() int

func (d drawingArea) SetContentHeight(height int)

func (d drawingArea) SetContentWidth(width int)

func (d drawingArea) SetDrawFunc(drawFunc DrawingAreaDrawFunc)

// DropControllerMotion is an event controller meant for tracking the pointer
// hovering over a widget during a drag and drop operation.
//
// It is modeled after EventControllerMotion so if you have used that, this
// should feel really familiar.
//
// The drop controller is not able to accept drops, use DropTarget for that
// purpose.
type DropControllerMotion interface {
	EventController

	// ContainsPointer: returns the value of the
	// GtkDropControllerMotion:contains-pointer property.
	ContainsPointer() bool
	// Drop: returns the value of the GtkDropControllerMotion:drop property.
	Drop() gdk.Drop
	// IsPointer: returns the value of the GtkDropControllerMotion:is-pointer
	// property.
	IsPointer() bool
}

type dropControllerMotion struct {
	eventController
}

func wrapDropControllerMotion(obj *externglib.Object) DropControllerMotion {
	return dropControllerMotion{eventController{*externglib.Object{obj}}}
}

func marshalDropControllerMotion(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewDropControllerMotion() DropControllerMotion

func (d dropControllerMotion) ContainsPointer() bool

func (d dropControllerMotion) Drop() gdk.Drop

func (d dropControllerMotion) IsPointer() bool

// DropDown: gtkDropDown is a widget that allows the user to choose an item from
// a list of options. The GtkDropDown displays the selected choice.
//
// The options are given to GtkDropDown in the form of Model, and how the
// individual options are represented is determined by a ListItemFactory. The
// default factory displays simple strings.
//
// GtkDropDown knows how to obtain strings from the items in a StringList; for
// other models, you have to provide an expression to find the strings via
// gtk_drop_down_set_expression().
//
// GtkDropDown can optionally allow search in the popup, which is useful if the
// list of options is long. To enable the search entry, use
// gtk_drop_down_set_enable_search().
//
//
// CSS nodes
//
// GtkDropDown has a single CSS node with name dropdown, with the button and
// popover nodes as children.
//
//
// Accessibility
//
// GtkDropDown uses the K_ACCESSIBLE_ROLE_COMBO_BOX role.
type DropDown interface {
	Widget

	// EnableSearch: returns whether search is enabled.
	EnableSearch() bool
	// Expression: gets the expression set with gtk_drop_down_set_expression().
	Expression() Expression
	// Factory: gets the factory that's currently used to populate list items.
	//
	// The factory returned by this function is always used for the item in the
	// button. It is also used for items in the popup if DropDown:list-factory
	// is not set.
	Factory() ListItemFactory
	// ListFactory: gets the factory that's currently used to populate list
	// items in the popup.
	ListFactory() ListItemFactory
	// Model: gets the model that provides the displayed items.
	Model() gio.ListModel
	// Selected: gets the position of the selected item.
	Selected() uint
	// SelectedItem: gets the selected item. If no item is selected, nil is
	// returned.
	SelectedItem() interface{}
	// SetEnableSearch: sets whether a search entry will be shown in the popup
	// that allows to search for items in the list.
	//
	// Note that DropDown:expression must be set for search to work.
	SetEnableSearch(enableSearch bool)
	// SetExpression: sets the expression that gets evaluated to obtain strings
	// from items when searching in the popup. The expression must have a value
	// type of TYPE_STRING.
	SetExpression(expression Expression)
	// SetFactory: sets the ListItemFactory to use for populating list items.
	SetFactory(factory ListItemFactory)
	// SetListFactory: sets the ListItemFactory to use for populating list items
	// in the popup.
	SetListFactory(factory ListItemFactory)
	// SetModel: sets the Model to use.
	SetModel(model gio.ListModel)
	// SetSelected: selects the item at the given position.
	SetSelected(position uint)
}

type dropDown struct {
	widget
}

func wrapDropDown(obj *externglib.Object) DropDown {
	return dropDown{widget{externglib.InitiallyUnowned{obj}}}
}

func marshalDropDown(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewDropDown(model gio.ListModel, expression Expression) DropDown

func NewDropDown(strings []string) DropDown

func (d dropDown) EnableSearch() bool

func (d dropDown) Expression() Expression

func (d dropDown) Factory() ListItemFactory

func (d dropDown) ListFactory() ListItemFactory

func (d dropDown) Model() gio.ListModel

func (d dropDown) Selected() uint

func (d dropDown) SelectedItem() interface{}

func (d dropDown) SetEnableSearch(enableSearch bool)

func (d dropDown) SetExpression(expression Expression)

func (d dropDown) SetFactory(factory ListItemFactory)

func (d dropDown) SetListFactory(factory ListItemFactory)

func (d dropDown) SetModel(model gio.ListModel)

func (d dropDown) SetSelected(position uint)

// DropTarget: gtkDropTarget is an event controller implementing a simple way to
// receive Drag-and-Drop operations.
//
// The most basic way to use a DropTarget to receive drops on a widget is to
// create it via gtk_drop_target_new() passing in the #GType of the data you
// want to receive and connect to the DropTarget::drop signal to receive the
// data:
//
//    static gboolean
//    on_drop (GtkDropTarget *target,
//             const GValue  *value,
//             double         x,
//             double         y,
//             gpointer       data)
//    {
//      MyWidget *self = data;
//
//      // Call the appropriate setter depending on the type of data
//      // that we received
//      if (G_VALUE_HOLDS (value, G_TYPE_FILE))
//        my_widget_set_file (self, g_value_get_object (value));
//      else if (G_VALUE_HOLDS (value, GDK_TYPE_PIXBUF))
//        my_widget_set_pixbuf (self, g_value_get_object (value));
//      else
//        return FALSE;
//
//      return TRUE;
//    }
//
//    static void
//    my_widget_init (MyWidget *self)
//    {
//      GtkDropTarget *target =
//        gtk_drop_target_new (G_TYPE_INVALID, GDK_ACTION_COPY);
//
//      // This widget accepts two types of drop types: GFile objects
//      // and GdkPixbuf objects
//      gtk_drop_target_set_gtypes (target, (GTypes [2]) {
//        G_TYPE_FILE,
//        GDK_TYPE_PIXBUF,
//      }, 2);
//
//      gtk_widget_add_controller (GTK_WIDGET (self), GTK_EVENT_CONTROLLER (target));
//    }
//
//
// DropTarget supports more options, such as:
//
// * rejecting potential drops via the DropTarget::accept signal and the
// gtk_drop_target_reject() function to let other drop targets handle the drop *
// tracking an ongoing drag operation before the drop via the DropTarget::enter,
// DropTarget::motion and DropTarget::leave signals * configuring how to receive
// data by setting the DropTarget:preload property and listening for its
// availability via the DropTarget:value property
//
// However, DropTarget is ultimately modeled in a synchronous way and only
// supports data transferred via #GType. If you want full control over an
// ongoing drop, the DropTargetAsync object gives you this ability.
//
// While a pointer is dragged over the drop target's widget and the drop has not
// been rejected, that widget will receive the GTK_STATE_FLAG_DROP_ACTIVE state,
// which can be used to style the widget.
type DropTarget interface {
	EventController

	// Actions: gets the actions that this drop target supports.
	Actions() gdk.DragAction
	// Drop: gets the currently handled drop operation.
	//
	// If no drop operation is going on, nil is returned.
	Drop() gdk.Drop
	// Formats: gets the data formats that this drop target accepts.
	//
	// If the result is nil, all formats are expected to be supported.
	Formats() *gdk.ContentFormats
	// GTypes: gets the list of supported #GTypes for @self. If no type have
	// been set, nil will be returned.
	GTypes() (nTypes uint, gTypes []externglib.Type)
	// Preload: gets the value of the GtkDropTarget:preload property.
	Preload() bool
	// Value: gets the value of the GtkDropTarget:value property.
	Value() *externglib.Value
	// Reject: rejects the ongoing drop operation.
	//
	// If no drop operation is ongoing - when GdkDropTarget:drop returns nil -
	// this function does nothing.
	//
	// This function should be used when delaying the decision on whether to
	// accept a drag or not until after reading the data.
	Reject()
	// SetActions: sets the actions that this drop target supports.
	SetActions(actions gdk.DragAction)
	// SetGTypes: sets the supported #GTypes for this drop target.
	SetGTypes(types []externglib.Type)
	// SetPreload: sets the GtkDropTarget:preload property.
	SetPreload(preload bool)
}

type dropTarget struct {
	eventController
}

func wrapDropTarget(obj *externglib.Object) DropTarget {
	return dropTarget{eventController{*externglib.Object{obj}}}
}

func marshalDropTarget(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewDropTarget(_type externglib.Type, actions gdk.DragAction) DropTarget

func (d dropTarget) Actions() gdk.DragAction

func (d dropTarget) Drop() gdk.Drop

func (d dropTarget) Formats() *gdk.ContentFormats

func (d dropTarget) GTypes() (nTypes uint, gTypes []externglib.Type)

func (d dropTarget) Preload() bool

func (d dropTarget) Value() *externglib.Value

func (d dropTarget) Reject()

func (d dropTarget) SetActions(actions gdk.DragAction)

func (d dropTarget) SetGTypes(types []externglib.Type)

func (d dropTarget) SetPreload(preload bool)

// DropTargetAsync: gtkDropTargetAsync is an auxiliary object that can be used
// to receive Drag-and-Drop operations. It is the more complete but also more
// complex method of handling drop operations compared to DropTarget and you
// should only use it if DropTarget doesn't provide all the features you need.
//
// To use a DropTargetAsync to receive drops on a widget, you create a
// DropTargetAsync object, configure which data formats and actions you support,
// connect to its signals, and then attach it to the widget with
// gtk_widget_add_controller().
//
// During a drag operation, the first signal that a GtkDropTargetAsync emits is
// DropTargetAsync::accept, which is meant to determine whether the target is a
// possible drop site for the ongoing drop. The default handler for the ::accept
// signal accepts the drop if it finds a compatible data format and an action
// that is supported on both sides.
//
// If it is, and the widget becomes a target, you will receive a
// DropTargetAsync::drag-enter signal, followed by DropTargetAsync::drag-motion
// signals as the pointer moves, optionally a DropTargetAsync::drop signal when
// a drop happens, and finally a DropTargetAsync::drag-leave signal when the
// pointer moves off the widget.
//
// The ::drag-enter and ::drag-motion handler return a DragAction to update the
// status of the ongoing operation. The ::drop handler should decide if it
// ultimately accepts the drop and if it does, it should initiate the data
// transfer and finish the operation by calling gdk_drop_finish().
//
// Between the ::drag-enter and ::drag-leave signals the widget is a current
// drop target, and will receive the GTK_STATE_FLAG_DROP_ACTIVE state, which can
// be used by themes to style the widget as a drop target.
type DropTargetAsync interface {
	EventController

	// Actions: gets the actions that this drop target supports.
	Actions() gdk.DragAction
	// Formats: gets the data formats that this drop target accepts.
	//
	// If the result is nil, all formats are expected to be supported.
	Formats() *gdk.ContentFormats
	// RejectDrop: sets the @drop as not accepted on this drag site.
	//
	// This function should be used when delaying the decision on whether to
	// accept a drag or not until after reading the data.
	RejectDrop(drop gdk.Drop)
	// SetActions: sets the actions that this drop target supports.
	SetActions(actions gdk.DragAction)
	// SetFormats: sets the data formats that this drop target will accept.
	SetFormats(formats *gdk.ContentFormats)
}

type dropTargetAsync struct {
	eventController
}

func wrapDropTargetAsync(obj *externglib.Object) DropTargetAsync {
	return dropTargetAsync{eventController{*externglib.Object{obj}}}
}

func marshalDropTargetAsync(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewDropTargetAsync(formats *gdk.ContentFormats, actions gdk.DragAction) DropTargetAsync

func (d dropTargetAsync) Actions() gdk.DragAction

func (d dropTargetAsync) Formats() *gdk.ContentFormats

func (d dropTargetAsync) RejectDrop(drop gdk.Drop)

func (d dropTargetAsync) SetActions(actions gdk.DragAction)

func (d dropTargetAsync) SetFormats(formats *gdk.ContentFormats)

// EditableLabel: a GtkEditableLabel is a Label that allows users to edit the
// text by switching the widget to an “edit mode”.
//
// GtkEditableLabel does not have API of its own, but it implements the Editable
// interface.
//
// The default bindings for activating the edit mode is to click or press the
// Enter key. The default bindings for leaving the edit mode are the Enter key
// (to save the results) or the Escape key (to cancel the editing).
//
// CSS nodes
//
//    editablelabel[.editing]
//    ╰── stack
//        ├── label
//        ╰── text
//
// GtkEditableLabel has a main node with the name editablelabel. When the entry
// is in editing mode, it gets the .editing style class.
//
// For all the subnodes added to the text node in various situations, see Text.
type EditableLabel interface {
	Widget

	// Editing: returns whether the label is currently in “editing mode”.
	Editing() bool
	// StartEditing: switches the label into “editing mode”.
	StartEditing()
	// StopEditing: switches the label out of “editing mode”. If @commit is
	// true, the resulting text is kept as the Editable:text property value,
	// otherwise the resulting text is discarded and the label will keep its
	// previous Editable:text property value.
	StopEditing(commit bool)
}

type editableLabel struct {
	widget
}

func wrapEditableLabel(obj *externglib.Object) EditableLabel {
	return editableLabel{widget{externglib.InitiallyUnowned{obj}}}
}

func marshalEditableLabel(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewEditableLabel(str string) EditableLabel

func (e editableLabel) Editing() bool

func (e editableLabel) StartEditing()

func (e editableLabel) StopEditing(commit bool)

// EmojiChooser: the EmojiChooser popover is used by text widgets such as Entry
// or TextView to offer users a convenient way to insert Emoji characters.
//
// GtkEmojiChooser emits the EmojiChooser::emoji-picked signal when an Emoji is
// selected.
//
//    popover
//    ├── box.emoji-searchbar
//    │   ╰── entry.search
//    ╰── box.emoji-toolbar
//        ├── button.image-button.emoji-section
//        ├── ...
//        ╰── button.image-button.emoji-section
//
// Every EmojiChooser consists of a main node called popover. The contents of
// the popover are largely implementation defined and supposed to inherit
// general styles. The top searchbar used to search emoji and gets the
// .emoji-searchbar style class itself. The bottom toolbar used to switch
// between different emoji categories consists of buttons with the
// .emoji-section style class and gets the .emoji-toolbar style class itself.
type EmojiChooser interface {
	Popover
}

type emojiChooser struct {
	popover
}

func wrapEmojiChooser(obj *externglib.Object) EmojiChooser {
	return emojiChooser{popover{widget{externglib.InitiallyUnowned{obj}}}}
}

func marshalEmojiChooser(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewEmojiChooser() EmojiChooser

// Entry: the Entry widget is a single line text entry widget. A fairly large
// set of key bindings are supported by default. If the entered text is longer
// than the allocation of the widget, the widget will scroll so that the cursor
// position is visible.
//
// When using an entry for passwords and other sensitive information, it can be
// put into “password mode” using gtk_entry_set_visibility(). In this mode,
// entered text is displayed using a “invisible” character. By default, GTK
// picks the best invisible character that is available in the current font, but
// it can be changed with gtk_entry_set_invisible_char().
//
// GtkEntry has the ability to display progress or activity information behind
// the text. To make an entry display such information, use
// gtk_entry_set_progress_fraction() or gtk_entry_set_progress_pulse_step().
//
// Additionally, GtkEntry can show icons at either side of the entry. These
// icons can be activatable by clicking, can be set up as drag source and can
// have tooltips. To add an icon, use gtk_entry_set_icon_from_gicon() or one of
// the various other functions that set an icon from an icon name or a
// paintable. To trigger an action when the user clicks an icon, connect to the
// Entry::icon-press signal. To allow DND operations from an icon, use
// gtk_entry_set_icon_drag_source(). To set a tooltip on an icon, use
// gtk_entry_set_icon_tooltip_text() or the corresponding function for markup.
//
// Note that functionality or information that is only available by clicking on
// an icon in an entry may not be accessible at all to users which are not able
// to use a mouse or other pointing device. It is therefore recommended that any
// such functionality should also be available by other means, e.g. via the
// context menu of the entry.
//
// CSS nodes
//
//    entry[.flat][.warning][.error]
//    ├── text[.readonly]
//    ├── image.left
//    ├── image.right
//    ╰── [progress[.pulse]]
//
// GtkEntry has a main node with the name entry. Depending on the properties of
// the entry, the style classes .read-only and .flat may appear. The style
// classes .warning and .error may also be used with entries.
//
// When the entry shows icons, it adds subnodes with the name image and the
// style class .left or .right, depending on where the icon appears.
//
// When the entry shows progress, it adds a subnode with the name progress. The
// node has the style class .pulse when the shown progress is pulsing.
//
// For all the subnodes added to the text node in various situations, see Text.
//
//
// GtkEntry as GtkBuildable
//
// The GtkEntry implementation of the GtkBuildable interface supports a custom
// <attributes> element, which supports any number of <attribute> elements. The
// <attribute> element has attributes named “name“, “value“, “start“ and “end“
// and allows you to specify Attribute values for this label.
//
//
//    <object class="GtkEnry">
//      <attributes>
//        <attribute name="weight" value="PANGO_WEIGHT_BOLD"/>
//        <attribute name="background" value="red" start="5" end="10"/>
//      </attributes>
//    </object>
//
// The start and end attributes specify the range of characters to which the
// Pango attribute applies. If start and end are not specified, the attribute is
// applied to the whole text. Note that specifying ranges does not make much
// sense with translatable attributes. Use markup embedded in the translatable
// content instead.
//
//
// Accessibility
//
// GtkEntry uses the K_ACCESSIBLE_ROLE_TEXT_BOX role.
type Entry interface {
	Widget

	// ActivatesDefault: retrieves the value set by
	// gtk_entry_set_activates_default().
	ActivatesDefault() bool
	// Alignment: gets the value set by gtk_entry_set_alignment().
	Alignment() float32
	// Attributes: gets the attribute list that was set on the entry using
	// gtk_entry_set_attributes(), if any.
	Attributes() *pango.AttrList
	// Buffer: get the EntryBuffer object which holds the text for this widget.
	Buffer() EntryBuffer
	// Completion: returns the auxiliary completion object currently in use by
	// @entry.
	Completion() EntryCompletion
	// CurrentIconDragSource: returns the index of the icon which is the source
	// of the current DND operation, or -1.
	CurrentIconDragSource() int
	// ExtraMenu: gets the menu model set with gtk_entry_set_extra_menu().
	ExtraMenu() gio.MenuModel
	// HasFrame: gets the value set by gtk_entry_set_has_frame().
	HasFrame() bool
	// IconActivatable: returns whether the icon is activatable.
	IconActivatable(iconPos EntryIconPosition) bool
	// IconArea: gets the area where entry’s icon at @icon_pos is drawn. This
	// function is useful when drawing something to the entry in a draw
	// callback.
	//
	// If the entry is not realized or has no icon at the given position,
	// @icon_area is filled with zeros. Otherwise, @icon_area will be filled
	// with the icon's allocation, relative to @entry's allocation.
	IconArea(iconPos EntryIconPosition) gdk.Rectangle
	// IconAtPos: finds the icon at the given position and return its index. The
	// position’s coordinates are relative to the @entry’s top left corner. If
	// @x, @y doesn’t lie inside an icon, -1 is returned. This function is
	// intended for use in a Widget::query-tooltip signal handler.
	IconAtPos(x int, y int) int
	// IconGicon: retrieves the #GIcon used for the icon, or nil if there is no
	// icon or if the icon was set by some other method (e.g., by paintable or
	// icon name).
	IconGicon(iconPos EntryIconPosition) gio.Icon
	// IconName: retrieves the icon name used for the icon, or nil if there is
	// no icon or if the icon was set by some other method (e.g., by paintable
	// or gicon).
	IconName(iconPos EntryIconPosition) string
	// IconPaintable: retrieves the Paintable used for the icon.
	//
	// If no Paintable was used for the icon, nil is returned.
	IconPaintable(iconPos EntryIconPosition) gdk.Paintable
	// IconSensitive: returns whether the icon appears sensitive or insensitive.
	IconSensitive(iconPos EntryIconPosition) bool
	// IconStorageType: gets the type of representation being used by the icon
	// to store image data. If the icon has no image data, the return value will
	// be GTK_IMAGE_EMPTY.
	IconStorageType(iconPos EntryIconPosition) ImageType
	// IconTooltipMarkup: gets the contents of the tooltip on the icon at the
	// specified position in @entry.
	IconTooltipMarkup(iconPos EntryIconPosition) string
	// IconTooltipText: gets the contents of the tooltip on the icon at the
	// specified position in @entry.
	IconTooltipText(iconPos EntryIconPosition) string
	// InputHints: gets the value of the Entry:input-hints property.
	InputHints() InputHints
	// InputPurpose: gets the value of the Entry:input-purpose property.
	InputPurpose() InputPurpose
	// InvisibleChar: retrieves the character displayed in place of the real
	// characters for entries with visibility set to false. See
	// gtk_entry_set_invisible_char().
	InvisibleChar() uint32
	// MaxLength: retrieves the maximum allowed length of the text in @entry.
	// See gtk_entry_set_max_length().
	//
	// This is equivalent to getting @entry's EntryBuffer and calling
	// gtk_entry_buffer_get_max_length() on it.
	MaxLength() int
	// OverwriteMode: gets the value set by gtk_entry_set_overwrite_mode().
	OverwriteMode() bool
	// PlaceholderText: retrieves the text that will be displayed when @entry is
	// empty and unfocused
	PlaceholderText() string
	// ProgressFraction: returns the current fraction of the task that’s been
	// completed. See gtk_entry_set_progress_fraction().
	ProgressFraction() float64
	// ProgressPulseStep: retrieves the pulse step set with
	// gtk_entry_set_progress_pulse_step().
	ProgressPulseStep() float64
	// Tabs: gets the tabstops that were set on the entry using
	// gtk_entry_set_tabs(), if any.
	Tabs() *pango.TabArray
	// TextLength: retrieves the current length of the text in @entry.
	//
	// This is equivalent to getting @entry's EntryBuffer and calling
	// gtk_entry_buffer_get_length() on it.
	TextLength() uint16
	// Visibility: retrieves whether the text in @entry is visible. See
	// gtk_entry_set_visibility().
	Visibility() bool
	// GrabFocusWithoutSelecting: causes @entry to have keyboard focus.
	//
	// It behaves like gtk_widget_grab_focus(), except that it doesn't select
	// the contents of the entry. You only want to call this on some special
	// entries which the user usually doesn't want to replace all text in, such
	// as search-as-you-type entries.
	GrabFocusWithoutSelecting() bool
	// ProgressPulse: indicates that some progress is made, but you don’t know
	// how much. Causes the entry’s progress indicator to enter “activity mode,”
	// where a block bounces back and forth. Each call to
	// gtk_entry_progress_pulse() causes the block to move by a little bit (the
	// amount of movement per pulse is determined by
	// gtk_entry_set_progress_pulse_step()).
	ProgressPulse()
	// ResetImContext: reset the input method context of the entry if needed.
	//
	// This can be necessary in the case where modifying the buffer would
	// confuse on-going input method behavior.
	ResetImContext()
	// SetActivatesDefault: if @setting is true, pressing Enter in the @entry
	// will activate the default widget for the window containing the entry.
	// This usually means that the dialog box containing the entry will be
	// closed, since the default widget is usually one of the dialog buttons.
	SetActivatesDefault(setting bool)
	// SetAlignment: sets the alignment for the contents of the entry. This
	// controls the horizontal positioning of the contents when the displayed
	// text is shorter than the width of the entry.
	SetAlignment(xalign float32)
	// SetAttributes: sets a AttrList; the attributes in the list are applied to
	// the entry text.
	SetAttributes(attrs *pango.AttrList)
	// SetBuffer: set the EntryBuffer object which holds the text for this
	// widget.
	SetBuffer(buffer EntryBuffer)
	// SetCompletion: sets @completion to be the auxiliary completion object to
	// use with @entry. All further configuration of the completion mechanism is
	// done on @completion using the EntryCompletion API. Completion is disabled
	// if @completion is set to nil.
	SetCompletion(completion EntryCompletion)
	// SetExtraMenu: sets a menu model to add when constructing the context menu
	// for @entry.
	SetExtraMenu(model gio.MenuModel)
	// SetHasFrame: sets whether the entry has a beveled frame around it.
	SetHasFrame(setting bool)
	// SetIconActivatable: sets whether the icon is activatable.
	SetIconActivatable(iconPos EntryIconPosition, activatable bool)
	// SetIconDragSource: sets up the icon at the given position so that GTK
	// will start a drag operation when the user clicks and drags the icon.
	SetIconDragSource(iconPos EntryIconPosition, provider gdk.ContentProvider, actions gdk.DragAction)
	// SetIconFromGicon: sets the icon shown in the entry at the specified
	// position from the current icon theme. If the icon isn’t known, a “broken
	// image” icon will be displayed instead.
	//
	// If @icon is nil, no icon will be shown in the specified position.
	SetIconFromGicon(iconPos EntryIconPosition, icon gio.Icon)
	// SetIconFromIconName: sets the icon shown in the entry at the specified
	// position from the current icon theme.
	//
	// If the icon name isn’t known, a “broken image” icon will be displayed
	// instead.
	//
	// If @icon_name is nil, no icon will be shown in the specified position.
	SetIconFromIconName(iconPos EntryIconPosition, iconName string)
	// SetIconFromPaintable: sets the icon shown in the specified position using
	// a Paintable
	//
	// If @paintable is nil, no icon will be shown in the specified position.
	SetIconFromPaintable(iconPos EntryIconPosition, paintable gdk.Paintable)
	// SetIconSensitive: sets the sensitivity for the specified icon.
	SetIconSensitive(iconPos EntryIconPosition, sensitive bool)
	// SetIconTooltipMarkup: sets @tooltip as the contents of the tooltip for
	// the icon at the specified position. @tooltip is assumed to be marked up
	// with the [Pango text markup language][PangoMarkupFormat].
	//
	// Use nil for @tooltip to remove an existing tooltip.
	//
	// See also gtk_widget_set_tooltip_markup() and
	// gtk_entry_set_icon_tooltip_text().
	SetIconTooltipMarkup(iconPos EntryIconPosition, tooltip string)
	// SetIconTooltipText: sets @tooltip as the contents of the tooltip for the
	// icon at the specified position.
	//
	// Use nil for @tooltip to remove an existing tooltip.
	//
	// See also gtk_widget_set_tooltip_text() and
	// gtk_entry_set_icon_tooltip_markup().
	//
	// If you unset the widget tooltip via gtk_widget_set_tooltip_text() or
	// gtk_widget_set_tooltip_markup(), this sets GtkWidget:has-tooltip to
	// false, which suppresses icon tooltips too. You can resolve this by then
	// calling gtk_widget_set_has_tooltip() to set GtkWidget:has-tooltip back to
	// true, or setting at least one non-empty tooltip on any icon achieves the
	// same result.
	SetIconTooltipText(iconPos EntryIconPosition, tooltip string)
	// SetInputHints: sets the Entry:input-hints property, which allows input
	// methods to fine-tune their behaviour.
	SetInputHints(hints InputHints)
	// SetInputPurpose: sets the Entry:input-purpose property which can be used
	// by on-screen keyboards and other input methods to adjust their behaviour.
	SetInputPurpose(purpose InputPurpose)
	// SetInvisibleChar: sets the character to use in place of the actual text
	// when gtk_entry_set_visibility() has been called to set text visibility to
	// false. i.e. this is the character used in “password mode” to show the
	// user how many characters have been typed. By default, GTK picks the best
	// invisible char available in the current font. If you set the invisible
	// char to 0, then the user will get no feedback at all; there will be no
	// text on the screen as they type.
	SetInvisibleChar(ch uint32)
	// SetMaxLength: sets the maximum allowed length of the contents of the
	// widget. If the current contents are longer than the given length, then
	// they will be truncated to fit.
	//
	// This is equivalent to getting @entry's EntryBuffer and calling
	// gtk_entry_buffer_set_max_length() on it.
	SetMaxLength(max int)
	// SetOverwriteMode: sets whether the text is overwritten when typing in the
	// Entry.
	SetOverwriteMode(overwrite bool)
	// SetPlaceholderText: sets text to be displayed in @entry when it is empty.
	// This can be used to give a visual hint of the expected contents of the
	// Entry.
	SetPlaceholderText(text string)
	// SetProgressFraction: causes the entry’s progress indicator to “fill in”
	// the given fraction of the bar. The fraction should be between 0.0 and
	// 1.0, inclusive.
	SetProgressFraction(fraction float64)
	// SetProgressPulseStep: sets the fraction of total entry width to move the
	// progress bouncing block for each call to gtk_entry_progress_pulse().
	SetProgressPulseStep(fraction float64)
	// SetTabs: sets a TabArray; the tabstops in the array are applied to the
	// entry text.
	SetTabs(tabs *pango.TabArray)
	// SetVisibility: sets whether the contents of the entry are visible or not.
	// When visibility is set to false, characters are displayed as the
	// invisible char, and will also appear that way when the text in the entry
	// widget is copied elsewhere.
	//
	// By default, GTK picks the best invisible character available in the
	// current font, but it can be changed with gtk_entry_set_invisible_char().
	//
	// Note that you probably want to set Entry:input-purpose to
	// GTK_INPUT_PURPOSE_PASSWORD or GTK_INPUT_PURPOSE_PIN to inform input
	// methods about the purpose of this entry, in addition to setting
	// visibility to false.
	SetVisibility(visible bool)
	// UnsetInvisibleChar: unsets the invisible char previously set with
	// gtk_entry_set_invisible_char(). So that the default invisible char is
	// used again.
	UnsetInvisibleChar()
}

type entry struct {
	widget
}

func wrapEntry(obj *externglib.Object) Entry {
	return entry{widget{externglib.InitiallyUnowned{obj}}}
}

func marshalEntry(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewEntry() Entry

func NewEntry(buffer EntryBuffer) Entry

func (e entry) ActivatesDefault() bool

func (e entry) Alignment() float32

func (e entry) Attributes() *pango.AttrList

func (e entry) Buffer() EntryBuffer

func (e entry) Completion() EntryCompletion

func (e entry) CurrentIconDragSource() int

func (e entry) ExtraMenu() gio.MenuModel

func (e entry) HasFrame() bool

func (e entry) IconActivatable(iconPos EntryIconPosition) bool

func (e entry) IconArea(iconPos EntryIconPosition) gdk.Rectangle

func (e entry) IconAtPos(x int, y int) int

func (e entry) IconGicon(iconPos EntryIconPosition) gio.Icon

func (e entry) IconName(iconPos EntryIconPosition) string

func (e entry) IconPaintable(iconPos EntryIconPosition) gdk.Paintable

func (e entry) IconSensitive(iconPos EntryIconPosition) bool

func (e entry) IconStorageType(iconPos EntryIconPosition) ImageType

func (e entry) IconTooltipMarkup(iconPos EntryIconPosition) string

func (e entry) IconTooltipText(iconPos EntryIconPosition) string

func (e entry) InputHints() InputHints

func (e entry) InputPurpose() InputPurpose

func (e entry) InvisibleChar() uint32

func (e entry) MaxLength() int

func (e entry) OverwriteMode() bool

func (e entry) PlaceholderText() string

func (e entry) ProgressFraction() float64

func (e entry) ProgressPulseStep() float64

func (e entry) Tabs() *pango.TabArray

func (e entry) TextLength() uint16

func (e entry) Visibility() bool

func (e entry) GrabFocusWithoutSelecting() bool

func (e entry) ProgressPulse()

func (e entry) ResetImContext()

func (e entry) SetActivatesDefault(setting bool)

func (e entry) SetAlignment(xalign float32)

func (e entry) SetAttributes(attrs *pango.AttrList)

func (e entry) SetBuffer(buffer EntryBuffer)

func (e entry) SetCompletion(completion EntryCompletion)

func (e entry) SetExtraMenu(model gio.MenuModel)

func (e entry) SetHasFrame(setting bool)

func (e entry) SetIconActivatable(iconPos EntryIconPosition, activatable bool)

func (e entry) SetIconDragSource(iconPos EntryIconPosition, provider gdk.ContentProvider, actions gdk.DragAction)

func (e entry) SetIconFromGicon(iconPos EntryIconPosition, icon gio.Icon)

func (e entry) SetIconFromIconName(iconPos EntryIconPosition, iconName string)

func (e entry) SetIconFromPaintable(iconPos EntryIconPosition, paintable gdk.Paintable)

func (e entry) SetIconSensitive(iconPos EntryIconPosition, sensitive bool)

func (e entry) SetIconTooltipMarkup(iconPos EntryIconPosition, tooltip string)

func (e entry) SetIconTooltipText(iconPos EntryIconPosition, tooltip string)

func (e entry) SetInputHints(hints InputHints)

func (e entry) SetInputPurpose(purpose InputPurpose)

func (e entry) SetInvisibleChar(ch uint32)

func (e entry) SetMaxLength(max int)

func (e entry) SetOverwriteMode(overwrite bool)

func (e entry) SetPlaceholderText(text string)

func (e entry) SetProgressFraction(fraction float64)

func (e entry) SetProgressPulseStep(fraction float64)

func (e entry) SetTabs(tabs *pango.TabArray)

func (e entry) SetVisibility(visible bool)

func (e entry) UnsetInvisibleChar()

// EntryBuffer: the EntryBuffer class contains the actual text displayed in a
// Entry widget.
//
// A single EntryBuffer object can be shared by multiple Entry widgets which
// will then share the same text content, but not the cursor position,
// visibility attributes, icon etc.
//
// EntryBuffer may be derived from. Such a derived class might allow text to be
// stored in an alternate location, such as non-pageable memory, useful in the
// case of important passwords. Or a derived class could integrate with an
// application’s concept of undo/redo.
type EntryBuffer interface {
	gextras.Objector

	// DeleteText: deletes a sequence of characters from the buffer. @n_chars
	// characters are deleted starting at @position. If @n_chars is negative,
	// then all characters until the end of the text are deleted.
	//
	// If @position or @n_chars are out of bounds, then they are coerced to sane
	// values.
	//
	// Note that the positions are specified in characters, not bytes.
	DeleteText(position uint, nChars int) uint
	// EmitDeletedText: used when subclassing EntryBuffer
	EmitDeletedText(position uint, nChars uint)
	// EmitInsertedText: used when subclassing EntryBuffer
	EmitInsertedText(position uint, chars string, nChars uint)
	// Bytes: retrieves the length in bytes of the buffer. See
	// gtk_entry_buffer_get_length().
	Bytes() uint
	// Length: retrieves the length in characters of the buffer.
	Length() uint
	// MaxLength: retrieves the maximum allowed length of the text in @buffer.
	// See gtk_entry_buffer_set_max_length().
	MaxLength() int
	// Text: retrieves the contents of the buffer.
	//
	// The memory pointer returned by this call will not change unless this
	// object emits a signal, or is finalized.
	Text() string
	// InsertText: inserts @n_chars characters of @chars into the contents of
	// the buffer, at position @position.
	//
	// If @n_chars is negative, then characters from chars will be inserted
	// until a null-terminator is found. If @position or @n_chars are out of
	// bounds, or the maximum buffer text length is exceeded, then they are
	// coerced to sane values.
	//
	// Note that the position and length are in characters, not in bytes.
	InsertText(position uint, chars string, nChars int) uint
	// SetMaxLength: sets the maximum allowed length of the contents of the
	// buffer. If the current contents are longer than the given length, then
	// they will be truncated to fit.
	SetMaxLength(maxLength int)
	// SetText: sets the text in the buffer.
	//
	// This is roughly equivalent to calling gtk_entry_buffer_delete_text() and
	// gtk_entry_buffer_insert_text().
	//
	// Note that @n_chars is in characters, not in bytes.
	SetText(chars string, nChars int)
}

type entryBuffer struct {
	*externglib.Object
}

func wrapEntryBuffer(obj *externglib.Object) EntryBuffer {
	return entryBuffer{*externglib.Object{obj}}
}

func marshalEntryBuffer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewEntryBuffer(initialChars string, nInitialChars int) EntryBuffer

func (e entryBuffer) DeleteText(position uint, nChars int) uint

func (e entryBuffer) EmitDeletedText(position uint, nChars uint)

func (e entryBuffer) EmitInsertedText(position uint, chars string, nChars uint)

func (e entryBuffer) Bytes() uint

func (e entryBuffer) Length() uint

func (e entryBuffer) MaxLength() int

func (e entryBuffer) Text() string

func (e entryBuffer) InsertText(position uint, chars string, nChars int) uint

func (e entryBuffer) SetMaxLength(maxLength int)

func (e entryBuffer) SetText(chars string, nChars int)

// EntryCompletion is an auxiliary object to be used in conjunction with Entry
// to provide the completion functionality. It implements the CellLayout
// interface, to allow the user to add extra cells to the TreeView with
// completion matches.
//
// “Completion functionality” means that when the user modifies the text in the
// entry, EntryCompletion checks which rows in the model match the current
// content of the entry, and displays a list of matches. By default, the
// matching is done by comparing the entry text case-insensitively against the
// text column of the model (see gtk_entry_completion_set_text_column()), but
// this can be overridden with a custom match function (see
// gtk_entry_completion_set_match_func()).
//
// When the user selects a completion, the content of the entry is updated. By
// default, the content of the entry is replaced by the text column of the
// model, but this can be overridden by connecting to the
// EntryCompletion::match-selected signal and updating the entry in the signal
// handler. Note that you should return true from the signal handler to suppress
// the default behaviour.
//
// To add completion functionality to an entry, use gtk_entry_set_completion().
//
// GtkEntryCompletion uses a TreeModelFilter model to represent the subset of
// the entire model that is currently matching. While the GtkEntryCompletion
// signals EntryCompletion::match-selected and EntryCompletion::cursor-on-match
// take the original model and an iter pointing to that model as arguments,
// other callbacks and signals (such as CellLayoutDataFuncs or
// CellArea::apply-attributes) will generally take the filter model as argument.
// As long as you are only calling gtk_tree_model_get(), this will make no
// difference to you. If for some reason, you need the original model, use
// gtk_tree_model_filter_get_model(). Don’t forget to use
// gtk_tree_model_filter_convert_iter_to_child_iter() to obtain a matching iter.
type EntryCompletion interface {
	gextras.Objector

	// Complete: requests a completion operation, or in other words a
	// refiltering of the current list with completions, using the current key.
	// The completion list view will be updated accordingly.
	Complete()
	// ComputePrefix: computes the common prefix that is shared by all rows in
	// @completion that start with @key. If no row matches @key, nil will be
	// returned. Note that a text column must have been set for this function to
	// work, see gtk_entry_completion_set_text_column() for details.
	ComputePrefix(key string) string
	// CompletionPrefix: get the original text entered by the user that
	// triggered the completion or nil if there’s no completion ongoing.
	CompletionPrefix() string
	// Entry: gets the entry @completion has been attached to.
	Entry() Widget
	// InlineCompletion: returns whether the common prefix of the possible
	// completions should be automatically inserted in the entry.
	InlineCompletion() bool
	// InlineSelection: returns true if inline-selection mode is turned on.
	InlineSelection() bool
	// MinimumKeyLength: returns the minimum key length as set for @completion.
	MinimumKeyLength() int
	// Model: returns the model the EntryCompletion is using as data source.
	// Returns nil if the model is unset.
	Model() TreeModel
	// PopupCompletion: returns whether the completions should be presented in a
	// popup window.
	PopupCompletion() bool
	// PopupSetWidth: returns whether the completion popup window will be
	// resized to the width of the entry.
	PopupSetWidth() bool
	// PopupSingleMatch: returns whether the completion popup window will appear
	// even if there is only a single match.
	PopupSingleMatch() bool
	// TextColumn: returns the column in the model of @completion to get strings
	// from.
	TextColumn() int
	// InsertPrefix: requests a prefix insertion.
	InsertPrefix()
	// SetInlineCompletion: sets whether the common prefix of the possible
	// completions should be automatically inserted in the entry.
	SetInlineCompletion(inlineCompletion bool)
	// SetInlineSelection: sets whether it is possible to cycle through the
	// possible completions inside the entry.
	SetInlineSelection(inlineSelection bool)
	// SetMatchFunc: sets the match function for @completion to be @func. The
	// match function is used to determine if a row should or should not be in
	// the completion list.
	SetMatchFunc(_func EntryCompletionMatchFunc)
	// SetMinimumKeyLength: requires the length of the search key for
	// @completion to be at least @length. This is useful for long lists, where
	// completing using a small key takes a lot of time and will come up with
	// meaningless results anyway (ie, a too large dataset).
	SetMinimumKeyLength(length int)
	// SetModel: sets the model for a EntryCompletion. If @completion already
	// has a model set, it will remove it before setting the new model. If model
	// is nil, then it will unset the model.
	SetModel(model TreeModel)
	// SetPopupCompletion: sets whether the completions should be presented in a
	// popup window.
	SetPopupCompletion(popupCompletion bool)
	// SetPopupSetWidth: sets whether the completion popup window will be
	// resized to be the same width as the entry.
	SetPopupSetWidth(popupSetWidth bool)
	// SetPopupSingleMatch: sets whether the completion popup window will appear
	// even if there is only a single match. You may want to set this to false
	// if you are using [inline
	// completion][GtkEntryCompletion--inline-completion].
	SetPopupSingleMatch(popupSingleMatch bool)
	// SetTextColumn: convenience function for setting up the most used case of
	// this code: a completion list with just strings. This function will set up
	// @completion to have a list displaying all (and just) strings in the
	// completion list, and to get those strings from @column in the model of
	// @completion.
	//
	// This functions creates and adds a CellRendererText for the selected
	// column. If you need to set the text column, but don't want the cell
	// renderer, use g_object_set() to set the EntryCompletion:text-column
	// property directly.
	SetTextColumn(column int)
}

type entryCompletion struct {
	*externglib.Object
}

func wrapEntryCompletion(obj *externglib.Object) EntryCompletion {
	return entryCompletion{*externglib.Object{obj}}
}

func marshalEntryCompletion(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewEntryCompletion() EntryCompletion

func NewEntryCompletion(area CellArea) EntryCompletion

func (e entryCompletion) Complete()

func (e entryCompletion) ComputePrefix(key string) string

func (e entryCompletion) CompletionPrefix() string

func (e entryCompletion) Entry() Widget

func (e entryCompletion) InlineCompletion() bool

func (e entryCompletion) InlineSelection() bool

func (e entryCompletion) MinimumKeyLength() int

func (e entryCompletion) Model() TreeModel

func (e entryCompletion) PopupCompletion() bool

func (e entryCompletion) PopupSetWidth() bool

func (e entryCompletion) PopupSingleMatch() bool

func (e entryCompletion) TextColumn() int

func (e entryCompletion) InsertPrefix()

func (e entryCompletion) SetInlineCompletion(inlineCompletion bool)

func (e entryCompletion) SetInlineSelection(inlineSelection bool)

func (e entryCompletion) SetMatchFunc(_func EntryCompletionMatchFunc)

func (e entryCompletion) SetMinimumKeyLength(length int)

func (e entryCompletion) SetModel(model TreeModel)

func (e entryCompletion) SetPopupCompletion(popupCompletion bool)

func (e entryCompletion) SetPopupSetWidth(popupSetWidth bool)

func (e entryCompletion) SetPopupSingleMatch(popupSingleMatch bool)

func (e entryCompletion) SetTextColumn(column int)

// EventController is a base, low-level implementation for event controllers.
// Those react to a series of Events, and possibly trigger actions as a
// consequence of those.
type EventController interface {
	gextras.Objector

	// CurrentEvent: returns the event that is currently being handled by the
	// controller, and nil at other times.
	CurrentEvent() gdk.Event
	// CurrentEventDevice: returns the device of the event that is currently
	// being handled by the controller, and nil otherwise.
	CurrentEventDevice() gdk.Device
	// CurrentEventState: returns the modifier state of the event that is
	// currently being handled by the controller, and 0 otherwise.
	CurrentEventState() gdk.ModifierType
	// CurrentEventTime: returns the timestamp of the event that is currently
	// being handled by the controller, and 0 otherwise.
	CurrentEventTime() uint32
	// Name: gets the name of @controller.
	Name() string
	// PropagationLimit: gets the propagation limit of the event controller.
	PropagationLimit() PropagationLimit
	// PropagationPhase: gets the propagation phase at which @controller handles
	// events.
	PropagationPhase() PropagationPhase
	// Widget: returns the Widget this controller relates to.
	Widget() Widget
	// Reset: resets the @controller to a clean state. Every interaction the
	// controller did through gtk_event_controller_handle_event() will be
	// dropped at this point.
	Reset()
	// SetName: sets a name on the controller that can be used for debugging.
	SetName(name string)
	// SetPropagationLimit: sets the event propagation limit on the event
	// controller.
	//
	// If the limit is set to GTK_LIMIT_SAME_NATIVE, the controller won't handle
	// events that are targeted at widgets on a different surface, such as
	// popovers.
	SetPropagationLimit(limit PropagationLimit)
	// SetPropagationPhase: sets the propagation phase at which a controller
	// handles events.
	//
	// If @phase is GTK_PHASE_NONE, no automatic event handling will be
	// performed, but other additional gesture maintenance will. In that phase,
	// the events can be managed by calling gtk_event_controller_handle_event().
	SetPropagationPhase(phase PropagationPhase)
}

type eventController struct {
	*externglib.Object
}

func wrapEventController(obj *externglib.Object) EventController {
	return eventController{*externglib.Object{obj}}
}

func marshalEventController(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func (e eventController) CurrentEvent() gdk.Event

func (e eventController) CurrentEventDevice() gdk.Device

func (e eventController) CurrentEventState() gdk.ModifierType

func (e eventController) CurrentEventTime() uint32

func (e eventController) Name() string

func (e eventController) PropagationLimit() PropagationLimit

func (e eventController) PropagationPhase() PropagationPhase

func (e eventController) Widget() Widget

func (e eventController) Reset()

func (e eventController) SetName(name string)

func (e eventController) SetPropagationLimit(limit PropagationLimit)

func (e eventController) SetPropagationPhase(phase PropagationPhase)

// EventControllerFocus is an event controller meant for situations where you
// need to know where the focus is.
type EventControllerFocus interface {
	EventController

	// ContainsFocus: returns the value of the
	// GtkEventControllerFocus:contains-focus property.
	ContainsFocus() bool
	// IsFocus: returns the value of the GtkEventControllerFocus:is-focus
	// property.
	IsFocus() bool
}

type eventControllerFocus struct {
	eventController
}

func wrapEventControllerFocus(obj *externglib.Object) EventControllerFocus {
	return eventControllerFocus{eventController{*externglib.Object{obj}}}
}

func marshalEventControllerFocus(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewEventControllerFocus() EventControllerFocus

func (e eventControllerFocus) ContainsFocus() bool

func (e eventControllerFocus) IsFocus() bool

// EventControllerKey is an event controller meant for situations where you need
// access to key events.
type EventControllerKey interface {
	EventController

	// Forward: forwards the current event of this @controller to a @widget.
	//
	// This function can only be used in handlers for the
	// EventControllerKey::key-pressed, EventControllerKey::key-released or
	// EventControllerKey::modifiers signals.
	Forward(widget Widget) bool
	// Group: gets the key group of the current event of this @controller. See
	// gdk_key_event_get_group().
	Group() uint
	// ImContext: gets the input method context of the key @controller.
	ImContext() IMContext
	// SetImContext: sets the input method context of the key @controller.
	SetImContext(imContext IMContext)
}

type eventControllerKey struct {
	eventController
}

func wrapEventControllerKey(obj *externglib.Object) EventControllerKey {
	return eventControllerKey{eventController{*externglib.Object{obj}}}
}

func marshalEventControllerKey(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewEventControllerKey() EventControllerKey

func (e eventControllerKey) Forward(widget Widget) bool

func (e eventControllerKey) Group() uint

func (e eventControllerKey) ImContext() IMContext

func (e eventControllerKey) SetImContext(imContext IMContext)

// EventControllerLegacy is an event controller that gives you direct access to
// the event stream. It should only be used as a last resort if none of the
// other event controllers or gestures do the job.
type EventControllerLegacy interface {
	EventController
}

type eventControllerLegacy struct {
	eventController
}

func wrapEventControllerLegacy(obj *externglib.Object) EventControllerLegacy {
	return eventControllerLegacy{eventController{*externglib.Object{obj}}}
}

func marshalEventControllerLegacy(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewEventControllerLegacy() EventControllerLegacy

// EventControllerMotion is an event controller meant for situations where you
// need to track the position of the pointer.
type EventControllerMotion interface {
	EventController

	// ContainsPointer: returns the value of the
	// GtkEventControllerMotion:contains-pointer property.
	ContainsPointer() bool
	// IsPointer: returns the value of the GtkEventControllerMotion:is-pointer
	// property.
	IsPointer() bool
}

type eventControllerMotion struct {
	eventController
}

func wrapEventControllerMotion(obj *externglib.Object) EventControllerMotion {
	return eventControllerMotion{eventController{*externglib.Object{obj}}}
}

func marshalEventControllerMotion(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewEventControllerMotion() EventControllerMotion

func (e eventControllerMotion) ContainsPointer() bool

func (e eventControllerMotion) IsPointer() bool

// EventControllerScroll is an event controller meant to handle scroll events
// from mice and touchpads. It is capable of handling both discrete and
// continuous scroll events, abstracting them both on the
// EventControllerScroll::scroll signal (deltas in the discrete case are
// multiples of 1).
//
// In the case of continuous scroll events, EventControllerScroll encloses all
// EventControllerScroll::scroll events between two
// EventControllerScroll::scroll-begin and EventControllerScroll::scroll-end
// signals.
//
// The behavior of the event controller can be modified by the flags given at
// creation time, or modified at a later point through
// gtk_event_controller_scroll_set_flags() (e.g. because the scrolling
// conditions of the widget changed).
//
// The controller can be set up to emit motion for either/both vertical and
// horizontal scroll events through K_EVENT_CONTROLLER_SCROLL_VERTICAL,
// K_EVENT_CONTROLLER_SCROLL_HORIZONTAL and K_EVENT_CONTROLLER_SCROLL_BOTH_AXES.
// If any axis is disabled, the respective EventControllerScroll::scroll delta
// will be 0. Vertical scroll events will be translated to horizontal motion for
// the devices incapable of horizontal scrolling.
//
// The event controller can also be forced to emit discrete events on all
// devices through K_EVENT_CONTROLLER_SCROLL_DISCRETE. This can be used to
// implement discrete actions triggered through scroll events (e.g. switching
// across combobox options).
//
// The K_EVENT_CONTROLLER_SCROLL_KINETIC flag toggles the emission of the
// EventControllerScroll::decelerate signal, emitted at the end of scrolling
// with two X/Y velocity arguments that are consistent with the motion that was
// received.
type EventControllerScroll interface {
	EventController

	// Flags: gets the flags conditioning the scroll controller behavior.
	Flags() EventControllerScrollFlags
	// SetFlags: sets the flags conditioning scroll controller behavior.
	SetFlags(flags EventControllerScrollFlags)
}

type eventControllerScroll struct {
	eventController
}

func wrapEventControllerScroll(obj *externglib.Object) EventControllerScroll {
	return eventControllerScroll{eventController{*externglib.Object{obj}}}
}

func marshalEventControllerScroll(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewEventControllerScroll(flags EventControllerScrollFlags) EventControllerScroll

func (e eventControllerScroll) Flags() EventControllerScrollFlags

func (e eventControllerScroll) SetFlags(flags EventControllerScrollFlags)

type EveryFilter interface {
	MultiFilter
}

type everyFilter struct {
	multiFilter
}

func wrapEveryFilter(obj *externglib.Object) EveryFilter {
	return everyFilter{multiFilter{filter{*externglib.Object{obj}}}}
}

func marshalEveryFilter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewEveryFilter() EveryFilter

// Expander: a Expander allows the user to hide or show its child by clicking on
// an expander triangle similar to the triangles used in a TreeView.
//
// Normally you use an expander as you would use a frame; you create the child
// widget and use gtk_expander_set_child() to add it to the expander. When the
// expander is toggled, it will take care of showing and hiding the child
// automatically.
//
//
// Special Usage
//
// There are situations in which you may prefer to show and hide the expanded
// widget yourself, such as when you want to actually create the widget at
// expansion time. In this case, create a Expander but do not add a child to it.
// The expander widget has an Expander:expanded property which can be used to
// monitor its expansion state. You should watch this property with a signal
// connection as follows:
//
//    static void
//    expander_callback (GObject    *object,
//                       GParamSpec *param_spec,
//                       gpointer    user_data)
//    {
//      GtkExpander *expander;
//
//      expander = GTK_EXPANDER (object);
//
//      if (gtk_expander_get_expanded (expander))
//        {
//          // Show or create widgets
//        }
//      else
//        {
//          // Hide or destroy widgets
//        }
//    }
//
//    static void
//    create_expander (void)
//    {
//      GtkWidget *expander = gtk_expander_new_with_mnemonic ("_More Options");
//      g_signal_connect (expander, "notify::expanded",
//                        G_CALLBACK (expander_callback), NULL);
//
//      // ...
//    }
//
//
//
// GtkExpander as GtkBuildable
//
// The GtkExpander implementation of the GtkBuildable interface supports placing
// a child in the label position by specifying “label” as the “type” attribute
// of a <child> element. A normal content child can be specified without
// specifying a <child> type attribute.
//
//
//    <object class="GtkExpander">
//      <child type="label">
//        <object class="GtkLabel" id="expander-label"/>
//      </child>
//      <child>
//        <object class="GtkEntry" id="expander-content"/>
//      </child>
//    </object>
//
// CSS nodes
//
//    expander
//    ╰── box
//        ├── title
//        │   ├── arrow
//        │   ╰── <label widget>
//        ╰── <child>
//
// GtkExpander has three CSS nodes, the main node with the name expander, a
// subnode with name title and node below it with name arrow. The arrow of an
// expander that is showing its child gets the :checked pseudoclass added to it.
//
//
// Accessibility
//
// GtkExpander uses the K_ACCESSIBLE_ROLE_BUTTON role.
type Expander interface {
	Widget

	// Child: gets the child widget of @expander.
	Child() Widget
	// Expanded: queries a Expander and returns its current state. Returns true
	// if the child widget is revealed.
	//
	// See gtk_expander_set_expanded().
	Expanded() bool
	// Label: fetches the text from a label widget including any embedded
	// underlines indicating mnemonics and Pango markup, as set by
	// gtk_expander_set_label(). If the label text has not been set the return
	// value will be nil. This will be the case if you create an empty button
	// with gtk_button_new() to use as a container.
	//
	// Note that this function behaved differently in versions prior to 2.14 and
	// used to return the label text stripped of embedded underlines indicating
	// mnemonics and Pango markup. This problem can be avoided by fetching the
	// label text directly from the label widget.
	Label() string
	// LabelWidget: retrieves the label widget for the frame. See
	// gtk_expander_set_label_widget().
	LabelWidget() Widget
	// ResizeToplevel: returns whether the expander will resize the toplevel
	// widget containing the expander upon resizing and collpasing.
	ResizeToplevel() bool
	// UseMarkup: returns whether the label’s text is interpreted as marked up
	// with the [Pango text markup language][PangoMarkupFormat]. See
	// gtk_expander_set_use_markup().
	UseMarkup() bool
	// UseUnderline: returns whether an embedded underline in the expander label
	// indicates a mnemonic. See gtk_expander_set_use_underline().
	UseUnderline() bool
	// SetChild: sets the child widget of @expander.
	SetChild(child Widget)
	// SetExpanded: sets the state of the expander. Set to true, if you want the
	// child widget to be revealed, and false if you want the child widget to be
	// hidden.
	SetExpanded(expanded bool)
	// SetLabel: sets the text of the label of the expander to @label.
	//
	// This will also clear any previously set labels.
	SetLabel(label string)
	// SetLabelWidget: set the label widget for the expander. This is the widget
	// that will appear embedded alongside the expander arrow.
	SetLabelWidget(labelWidget Widget)
	// SetResizeToplevel: sets whether the expander will resize the toplevel
	// widget containing the expander upon resizing and collpasing.
	SetResizeToplevel(resizeToplevel bool)
	// SetUseMarkup: sets whether the text of the label contains markup in
	// [Pango’s text markup language][PangoMarkupFormat]. See
	// gtk_label_set_markup().
	SetUseMarkup(useMarkup bool)
	// SetUseUnderline: if true, an underline in the text of the expander label
	// indicates the next character should be used for the mnemonic accelerator
	// key.
	SetUseUnderline(useUnderline bool)
}

type expander struct {
	widget
}

func wrapExpander(obj *externglib.Object) Expander {
	return expander{widget{externglib.InitiallyUnowned{obj}}}
}

func marshalExpander(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewExpander(label string) Expander

func NewExpander(label string) Expander

func (e expander) Child() Widget

func (e expander) Expanded() bool

func (e expander) Label() string

func (e expander) LabelWidget() Widget

func (e expander) ResizeToplevel() bool

func (e expander) UseMarkup() bool

func (e expander) UseUnderline() bool

func (e expander) SetChild(child Widget)

func (e expander) SetExpanded(expanded bool)

func (e expander) SetLabel(label string)

func (e expander) SetLabelWidget(labelWidget Widget)

func (e expander) SetResizeToplevel(resizeToplevel bool)

func (e expander) SetUseMarkup(useMarkup bool)

func (e expander) SetUseUnderline(useUnderline bool)

// FileChooserDialog is a dialog box suitable for use with “File Open” or “File
// Save” commands. This widget works by putting a FileChooserWidget inside a
// Dialog. It exposes the FileChooser interface, so you can use all of the
// FileChooser functions on the file chooser dialog as well as those for Dialog.
//
// Note that FileChooserDialog does not have any methods of its own. Instead,
// you should use the functions that work on a FileChooser.
//
// If you want to integrate well with the platform you should use the
// FileChooserNative API, which will use a platform-specific dialog if available
// and fall back to GtkFileChooserDialog otherwise.
//
// Typical usage {#gtkfilechooser-typical-usage}
//
// In the simplest of cases, you can the following code to use FileChooserDialog
// to select a file for opening:
//
//
//    static void
//    on_open_response (GtkDialog *dialog,
//                      int        response)
//    {
//      if (response == GTK_RESPONSE_ACCEPT)
//        {
//          GtkFileChooser *chooser = GTK_FILE_CHOOSER (dialog);
//
//          g_autoptr(GFile) file = gtk_file_chooser_get_file (chooser);
//
//          open_file (file);
//        }
//
//      gtk_window_destroy (GTK_WINDOW (dialog));
//    }
//
//      // ...
//      GtkWidget *dialog;
//      GtkFileChooserAction action = GTK_FILE_CHOOSER_ACTION_OPEN;
//
//      dialog = gtk_file_chooser_dialog_new ("Open File",
//                                            parent_window,
//                                            action,
//                                            _("_Cancel"),
//                                            GTK_RESPONSE_CANCEL,
//                                            _("_Open"),
//                                            GTK_RESPONSE_ACCEPT,
//                                            NULL);
//
//      gtk_widget_show (dialog);
//
//      g_signal_connect (dialog, "response",
//                        G_CALLBACK (on_open_response),
//                        NULL);
//
//
// To use a dialog for saving, you can use this:
//
//
//    static void
//    on_save_response (GtkDialog *dialog,
//                      int        response)
//    {
//      if (response == GTK_RESPONSE_ACCEPT)
//        {
//          GtkFileChooser *chooser = GTK_FILE_CHOOSER (dialog);
//
//          g_autoptr(GFile) file = gtk_file_chooser_get_file (chooser);
//
//          save_to_file (file);
//        }
//
//      gtk_window_destroy (GTK_WINDOW (dialog));
//    }
//
//      // ...
//      GtkWidget *dialog;
//      GtkFileChooser *chooser;
//      GtkFileChooserAction action = GTK_FILE_CHOOSER_ACTION_SAVE;
//
//      dialog = gtk_file_chooser_dialog_new ("Save File",
//                                            parent_window,
//                                            action,
//                                            _("_Cancel"),
//                                            GTK_RESPONSE_CANCEL,
//                                            _("_Save"),
//                                            GTK_RESPONSE_ACCEPT,
//                                            NULL);
//      chooser = GTK_FILE_CHOOSER (dialog);
//
//      if (user_edited_a_new_document)
//        gtk_file_chooser_set_current_name (chooser, _("Untitled document"));
//      else
//        gtk_file_chooser_set_file (chooser, existing_filename);
//
//      gtk_widget_show (dialog);
//
//      g_signal_connect (dialog, "response",
//                        G_CALLBACK (on_save_response),
//                        NULL);
//
//
// Setting up a file chooser dialog {#gtkfilechooserdialog-setting-up}
//
// There are various cases in which you may need to use a FileChooserDialog:
//
// - To select a file for opening. Use K_FILE_CHOOSER_ACTION_OPEN.
//
// - To save a file for the first time. Use K_FILE_CHOOSER_ACTION_SAVE, and
// suggest a name such as “Untitled” with gtk_file_chooser_set_current_name().
//
// - To save a file under a different name. Use K_FILE_CHOOSER_ACTION_SAVE, and
// set the existing file with gtk_file_chooser_set_file().
//
// - To choose a folder instead of a file. Use
// K_FILE_CHOOSER_ACTION_SELECT_FOLDER.
//
// Note that old versions of the file chooser’s documentation suggested using
// gtk_file_chooser_set_current_folder() in various situations, with the
// intention of letting the application suggest a reasonable default folder.
// This is no longer considered to be a good policy, as now the file chooser is
// able to make good suggestions on its own. In general, you should only cause
// the file chooser to show a specific folder when it is appropriate to use
// gtk_file_chooser_set_file(), i.e. when you are doing a Save As command and
// you already have a file saved somewhere.
//
// Response Codes {#gtkfilechooserdialog-responses}
//
// FileChooserDialog inherits from Dialog, so buttons that go in its action area
// have response codes such as K_RESPONSE_ACCEPT and K_RESPONSE_CANCEL. For
// example, you could call gtk_file_chooser_dialog_new() as follows:
//
//
//    GtkWidget *dialog;
//    GtkFileChooserAction action = GTK_FILE_CHOOSER_ACTION_OPEN;
//
//    dialog = gtk_file_chooser_dialog_new ("Open File",
//                                          parent_window,
//                                          action,
//                                          _("_Cancel"),
//                                          GTK_RESPONSE_CANCEL,
//                                          _("_Open"),
//                                          GTK_RESPONSE_ACCEPT,
//                                          NULL);
//
//
// This will create buttons for “Cancel” and “Open” that use predefined response
// identifiers from ResponseType. For most dialog boxes you can use your own
// custom response codes rather than the ones in ResponseType, but
// FileChooserDialog assumes that its “accept”-type action, e.g. an “Open” or
// “Save” button, will have one of the following response codes:
//
// - K_RESPONSE_ACCEPT - K_RESPONSE_OK - K_RESPONSE_YES - K_RESPONSE_APPLY
//
// This is because FileChooserDialog must intercept responses and switch to
// folders if appropriate, rather than letting the dialog terminate — the
// implementation uses these known response codes to know which responses can be
// blocked if appropriate.
//
// To summarize, make sure you use a [predefined response
// code][gtkfilechooserdialog-responses] when you use FileChooserDialog to
// ensure proper operation.
type FileChooserDialog interface {
	Dialog
}

type fileChooserDialog struct {
	dialog
}

func wrapFileChooserDialog(obj *externglib.Object) FileChooserDialog {
	return fileChooserDialog{dialog{window{widget{externglib.InitiallyUnowned{obj}}}}}
}

func marshalFileChooserDialog(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// FileChooserNative is an abstraction of a dialog box suitable for use with
// “File Open” or “File Save as” commands. By default, this just uses a
// FileChooserDialog to implement the actual dialog. However, on certain
// platforms, such as Windows and macOS, the native platform file chooser is
// used instead. When the application is running in a sandboxed environment
// without direct filesystem access (such as Flatpak), FileChooserNative may
// call the proper APIs (portals) to let the user choose a file and make it
// available to the application.
//
// While the API of FileChooserNative closely mirrors FileChooserDialog, the
// main difference is that there is no access to any Window or Widget for the
// dialog. This is required, as there may not be one in the case of a platform
// native dialog.
//
// Showing, hiding and running the dialog is handled by the NativeDialog
// functions.
//
// Note that unlike FileChooserDialog, FileChooserNative objects are not
// toplevel widgets, and GTK does not keep them alive. It is your responsibility
// to keep a reference until you are done with the object.
//
// Typical usage {#gtkfilechoosernative-typical-usage}
//
// In the simplest of cases, you can the following code to use FileChooserDialog
// to select a file for opening:
//
//    static void
//    on_response (GtkNativeDialog *native,
//                 int              response)
//    {
//      if (response == GTK_RESPONSE_ACCEPT)
//        {
//          GtkFileChooser *chooser = GTK_FILE_CHOOSER (native);
//          GFile *file = gtk_file_chooser_get_file (chooser);
//
//          open_file (file);
//
//          g_object_unref (file);
//        }
//
//      g_object_unref (native);
//    }
//
//      // ...
//      GtkFileChooserNative *native;
//      GtkFileChooserAction action = GTK_FILE_CHOOSER_ACTION_OPEN;
//
//      native = gtk_file_chooser_native_new ("Open File",
//                                            parent_window,
//                                            action,
//                                            "_Open",
//                                            "_Cancel");
//
//      g_signal_connect (native, "response", G_CALLBACK (on_response), NULL);
//      gtk_native_dialog_show (GTK_NATIVE_DIALOG (native));
//
//
// To use a dialog for saving, you can use this:
//
//    static void
//    on_response (GtkNativeDialog *native,
//                 int              response)
//    {
//      if (response == GTK_RESPONSE_ACCEPT)
//        {
//          GtkFileChooser *chooser = GTK_FILE_CHOOSER (native);
//          GFile *file = gtk_file_chooser_get_file (chooser);
//
//          save_to_file (file);
//
//          g_object_unref (file);
//        }
//
//      g_object_unref (native);
//    }
//
//      // ...
//      GtkFileChooserNative *native;
//      GtkFileChooser *chooser;
//      GtkFileChooserAction action = GTK_FILE_CHOOSER_ACTION_SAVE;
//
//      native = gtk_file_chooser_native_new ("Save File",
//                                            parent_window,
//                                            action,
//                                            "_Save",
//                                            "_Cancel");
//      chooser = GTK_FILE_CHOOSER (native);
//
//      if (user_edited_a_new_document)
//        gtk_file_chooser_set_current_name (chooser, _("Untitled document"));
//      else
//        gtk_file_chooser_set_file (chooser, existing_file, NULL);
//
//      g_signal_connect (native, "response", G_CALLBACK (on_response), NULL);
//      gtk_native_dialog_show (GTK_NATIVE_DIALOG (native));
//
//
// For more information on how to best set up a file dialog, see
// FileChooserDialog.
//
// Response Codes {#gtkfilechooserdialognative-responses}
//
// FileChooserNative inherits from NativeDialog, which means it will return
// K_RESPONSE_ACCEPT if the user accepted, and K_RESPONSE_CANCEL if he pressed
// cancel. It can also return K_RESPONSE_DELETE_EVENT if the window was
// unexpectedly closed.
//
// Differences from FileChooserDialog {#gtkfilechooserdialognative-differences}
//
// There are a few things in the GtkFileChooser API that are not possible to use
// with FileChooserNative, as such use would prohibit the use of a native
// dialog.
//
// No operations that change the dialog work while the dialog is visible. Set
// all the properties that are required before showing the dialog.
//
// Win32 details {#gtkfilechooserdialognative-win32}
//
// On windows the IFileDialog implementation (added in Windows Vista) is used.
// It supports many of the features that FileChooserDialog does, but there are
// some things it does not handle:
//
// * Any FileFilter added using a mimetype
//
// If any of these features are used the regular FileChooserDialog will be used
// in place of the native one.
//
// Portal details {#gtkfilechooserdialognative-portal}
//
// When the org.freedesktop.portal.FileChooser portal is available on the
// session bus, it is used to bring up an out-of-process file chooser. Depending
// on the kind of session the application is running in, this may or may not be
// a GTK file chooser.
//
// macOS details {#gtkfilechooserdialognative-macos}
//
// On macOS the NSSavePanel and NSOpenPanel classes are used to provide native
// file chooser dialogs. Some features provided by FileChooserDialog are not
// supported:
//
// * Shortcut folders.
type FileChooserNative interface {
	NativeDialog

	// AcceptLabel: retrieves the custom label text for the accept button.
	AcceptLabel() string
	// CancelLabel: retrieves the custom label text for the cancel button.
	CancelLabel() string
	// SetAcceptLabel: sets the custom label text for the accept button.
	//
	// If characters in @label are preceded by an underscore, they are
	// underlined. If you need a literal underscore character in a label, use
	// “__” (two underscores). The first underlined character represents a
	// keyboard accelerator called a mnemonic. Pressing Alt and that key
	// activates the button.
	SetAcceptLabel(acceptLabel string)
	// SetCancelLabel: sets the custom label text for the cancel button.
	//
	// If characters in @label are preceded by an underscore, they are
	// underlined. If you need a literal underscore character in a label, use
	// “__” (two underscores). The first underlined character represents a
	// keyboard accelerator called a mnemonic. Pressing Alt and that key
	// activates the button.
	SetCancelLabel(cancelLabel string)
}

type fileChooserNative struct {
	nativeDialog
}

func wrapFileChooserNative(obj *externglib.Object) FileChooserNative {
	return fileChooserNative{nativeDialog{*externglib.Object{obj}}}
}

func marshalFileChooserNative(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewFileChooserNative(title string, parent Window, action FileChooserAction, acceptLabel string, cancelLabel string) FileChooserNative

func (f fileChooserNative) AcceptLabel() string

func (f fileChooserNative) CancelLabel() string

func (f fileChooserNative) SetAcceptLabel(acceptLabel string)

func (f fileChooserNative) SetCancelLabel(cancelLabel string)

// FileChooserWidget is a widget for choosing files. It exposes the FileChooser
// interface, and you should use the methods of this interface to interact with
// the widget.
//
//
// CSS nodes
//
// GtkFileChooserWidget has a single CSS node with name filechooser.
type FileChooserWidget interface {
	Widget
}

type fileChooserWidget struct {
	widget
}

func wrapFileChooserWidget(obj *externglib.Object) FileChooserWidget {
	return fileChooserWidget{widget{externglib.InitiallyUnowned{obj}}}
}

func marshalFileChooserWidget(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewFileChooserWidget(action FileChooserAction) FileChooserWidget

// FileFilter: a GtkFileFilter can be used to restrict the files being shown in
// a FileChooser. Files can be filtered based on their name (with
// gtk_file_filter_add_pattern()) or on their mime type (with
// gtk_file_filter_add_mime_type()).
//
// Filtering by mime types handles aliasing and subclassing of mime types; e.g.
// a filter for text/plain also matches a file with mime type application/rtf,
// since application/rtf is a subclass of text/plain. Note that FileFilter
// allows wildcards for the subtype of a mime type, so you can e.g. filter for
// image/\*.
//
// Normally, file filters are used by adding them to a FileChooser (see
// gtk_file_chooser_add_filter()), but it is also possible to manually use a
// file filter on any FilterListModel containing Info objects.
//
//
// GtkFileFilter as GtkBuildable
//
// The GtkFileFilter implementation of the GtkBuildable interface supports
// adding rules using the <mime-types> and <patterns> elements and listing the
// rules within. Specifying a <mime-type> or <pattern> has the same effect as as
// calling gtk_file_filter_add_mime_type() or gtk_file_filter_add_pattern().
//
//
//    <object class="GtkFileFilter">
//      <property name="name" translatable="yes">Text and Images</property>
//      <mime-types>
//        <mime-type>text/plain</mime-type>
//        <mime-type>image/ *</mime-type>
//      </mime-types>
//      <patterns>
//        <pattern>*.txt</pattern>
//        <pattern>*.png</pattern>
//      </patterns>
//    </object>
type FileFilter interface {
	Filter

	// AddMIMEType: adds a rule allowing a given mime type to @filter.
	AddMIMEType(mimeType string)
	// AddPattern: adds a rule allowing a shell style glob to a filter.
	AddPattern(pattern string)
	// AddPixbufFormats: adds a rule allowing image files in the formats
	// supported by GdkPixbuf.
	//
	// This is equivalent to calling gtk_file_filter_add_mime_type() for all the
	// supported mime types.
	AddPixbufFormats()
	// Attributes: gets the attributes that need to be filled in for the Info
	// passed to this filter.
	//
	// This function will not typically be used by applications; it is intended
	// principally for use in the implementation of FileChooser.
	Attributes() []string
	// Name: gets the human-readable name for the filter. See
	// gtk_file_filter_set_name().
	Name() string
	// SetName: sets a human-readable name of the filter; this is the string
	// that will be displayed in the file chooser if there is a selectable list
	// of filters.
	SetName(name string)
	// ToGvariant: serialize a file filter to an a{sv} variant.
	ToGvariant() *glib.Variant
}

type fileFilter struct {
	filter
}

func wrapFileFilter(obj *externglib.Object) FileFilter {
	return fileFilter{filter{*externglib.Object{obj}}}
}

func marshalFileFilter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewFileFilter() FileFilter

func NewFileFilter(variant *glib.Variant) FileFilter

func (f fileFilter) AddMIMEType(mimeType string)

func (f fileFilter) AddPattern(pattern string)

func (f fileFilter) AddPixbufFormats()

func (f fileFilter) Attributes() []string

func (f fileFilter) Name() string

func (f fileFilter) SetName(name string)

func (f fileFilter) ToGvariant() *glib.Variant

// Filter: a Filter object describes the filtering to be performed by a
// FilterListModel.
//
// The model will use the filter to determine if it should include items or not
// by calling gtk_filter_match() for each item and only keeping the ones that
// the function returns true for.
//
// Filters may change what items they match through their lifetime. In that
// case, they will emit the Filter::changed signal to notify that previous
// filter results are no longer valid and that items should be checked again via
// gtk_filter_match().
//
// GTK provides various pre-made filter implementations for common filtering
// operations. These filters often include properties that can be linked to
// various widgets to easily allow searches.
//
// However, in particular for large lists or complex search methods, it is also
// possible to subclass Filter and provide one's own filter.
type Filter interface {
	gextras.Objector

	// Changed: emits the Filter::changed signal to notify all users of the
	// filter that the filter changed. Users of the filter should then check
	// items again via gtk_filter_match().
	//
	// Depending on the @change parameter, not all items need to be changed, but
	// only some. Refer to the FilterChange documentation for details.
	//
	// This function is intended for implementors of Filter subclasses and
	// should not be called from other functions.
	Changed(change FilterChange)
	// Strictness: gets the known strictness of @filters. If the strictness is
	// not known, GTK_FILTER_MATCH_SOME is returned.
	//
	// This value may change after emission of the Filter::changed signal.
	//
	// This function is meant purely for optimization purposes, filters can
	// choose to omit implementing it, but FilterListModel uses it.
	Strictness() FilterMatch
	// Match: checks if the given @item is matched by the filter or not.
	Match(item interface{}) bool
}

type filter struct {
	*externglib.Object
}

func wrapFilter(obj *externglib.Object) Filter {
	return filter{*externglib.Object{obj}}
}

func marshalFilter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func (f filter) Changed(change FilterChange)

func (f filter) Strictness() FilterMatch

func (f filter) Match(item interface{}) bool

// FilterListModel is a list model that filters a given other listmodel. It
// hides some elements from the other model according to criteria given by a
// Filter.
//
// The model can be set up to do incremental searching, so that filtering long
// lists doesn't block the UI. See gtk_filter_list_model_set_incremental() for
// details.
type FilterListModel interface {
	gextras.Objector

	// Filter: gets the Filter currently set on @self.
	Filter() Filter
	// Incremental: returns whether incremental filtering was enabled via
	// gtk_filter_list_model_set_incremental().
	Incremental() bool
	// Model: gets the model currently filtered or nil if none.
	Model() gio.ListModel
	// Pending: returns the number of items that have not been filtered yet.
	//
	// You can use this value to check if @self is busy filtering by comparing
	// the return value to 0 or you can compute the percentage of the filter
	// remaining by dividing the return value by the total number of items in
	// the underlying model:
	//
	//
	//      pending = gtk_filter_list_model_get_pending (self);
	//      model = gtk_filter_list_model_get_model (self);
	//      percentage = pending / (double) g_list_model_get_n_items (model);
	//
	// If no filter operation is ongoing - in particular when
	// FilterListModel:incremental is false - this function returns 0.
	Pending() uint
	// SetFilter: sets the filter used to filter items.
	SetFilter(filter Filter)
	// SetIncremental: when incremental filtering is enabled, the
	// GtkFilterListModel will not run filters immediately, but will instead
	// queue an idle handler that incrementally filters the items and adds them
	// to the list. This of course means that items are not instantly added to
	// the list, but only appear incrementally.
	//
	// When your filter blocks the UI while filtering, you might consider
	// turning this on. Depending on your model and filters, this may become
	// interesting around 10,000 to 100,000 items.
	//
	// By default, incremental filtering is disabled.
	//
	// See gtk_filter_list_model_get_pending() for progress information about an
	// ongoing incremental filtering operation.
	SetIncremental(incremental bool)
	// SetModel: sets the model to be filtered.
	//
	// Note that GTK makes no effort to ensure that @model conforms to the item
	// type of @self. It assumes that the caller knows what they are doing and
	// have set up an appropriate filter to ensure that item types match.
	SetModel(model gio.ListModel)
}

type filterListModel struct {
	*externglib.Object
}

func wrapFilterListModel(obj *externglib.Object) FilterListModel {
	return filterListModel{*externglib.Object{obj}}
}

func marshalFilterListModel(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewFilterListModel(model gio.ListModel, filter Filter) FilterListModel

func (f filterListModel) Filter() Filter

func (f filterListModel) Incremental() bool

func (f filterListModel) Model() gio.ListModel

func (f filterListModel) Pending() uint

func (f filterListModel) SetFilter(filter Filter)

func (f filterListModel) SetIncremental(incremental bool)

func (f filterListModel) SetModel(model gio.ListModel)

// Fixed: the Fixed widget is a container which can place child widgets at fixed
// positions and with fixed sizes, given in pixels. Fixed performs no automatic
// layout management.
//
// For most applications, you should not use this container! It keeps you from
// having to learn about the other GTK+ containers, but it results in broken
// applications. With Fixed, the following things will result in truncated text,
// overlapping widgets, and other display bugs:
//
// - Themes, which may change widget sizes.
//
// - Fonts other than the one you used to write the app will of course change
// the size of widgets containing text; keep in mind that users may use a larger
// font because of difficulty reading the default, or they may be using a
// different OS that provides different fonts.
//
// - Translation of text into other languages changes its size. Also, display of
// non-English text will use a different font in many cases.
//
// In addition, Fixed does not pay attention to text direction and thus may
// produce unwanted results if your app is run under right-to-left languages
// such as Hebrew or Arabic. That is: normally GTK will order containers
// appropriately for the text direction, e.g. to put labels to the right of the
// thing they label when using an RTL language, but it can’t do that with Fixed.
// So if you need to reorder widgets depending on the text direction, you would
// need to manually detect it and adjust child positions accordingly.
//
// Finally, fixed positioning makes it kind of annoying to add/remove GUI
// elements, since you have to reposition all the other elements. This is a
// long-term maintenance problem for your application.
//
// If you know none of these things are an issue for your application, and
// prefer the simplicity of Fixed, by all means use the widget. But you should
// be aware of the tradeoffs.
type Fixed interface {
	Widget

	// ChildPosition: retrieves the translation transformation of the given
	// child Widget in the given Fixed container.
	//
	// See also: gtk_fixed_get_child_transform().
	ChildPosition(widget Widget) (x float64, y float64)
	// ChildTransform: retrieves the transformation for @widget set using
	// gtk_fixed_set_child_transform().
	ChildTransform(widget Widget) *gsk.Transform
	// Move: sets a translation transformation to the given @x and @y
	// coordinates to the child @widget of the given Fixed container.
	Move(widget Widget, x float64, y float64)
	// Put: adds a widget to a Fixed container and assigns a translation
	// transformation to the given @x and @y coordinates to it.
	Put(widget Widget, x float64, y float64)
	// Remove: removes a child from @fixed, after it has been added with
	// gtk_fixed_put().
	Remove(widget Widget)
	// SetChildTransform: sets the transformation for @widget.
	//
	// This is a convenience function that retrieves the FixedLayoutChild
	// instance associated to @widget and calls
	// gtk_fixed_layout_child_set_transform().
	SetChildTransform(widget Widget, transform *gsk.Transform)
}

type fixed struct {
	widget
}

func wrapFixed(obj *externglib.Object) Fixed {
	return fixed{widget{externglib.InitiallyUnowned{obj}}}
}

func marshalFixed(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewFixed() Fixed

func (f fixed) ChildPosition(widget Widget) (x float64, y float64)

func (f fixed) ChildTransform(widget Widget) *gsk.Transform

func (f fixed) Move(widget Widget, x float64, y float64)

func (f fixed) Put(widget Widget, x float64, y float64)

func (f fixed) Remove(widget Widget)

func (f fixed) SetChildTransform(widget Widget, transform *gsk.Transform)

// FixedLayout is a layout manager which can place child widgets at fixed
// positions, and with fixed sizes.
//
// Most applications should never use this layout manager; fixed positioning and
// sizing requires constant recalculations on where children need to be
// positioned and sized. Other layout managers perform this kind of work
// internally so that application developers don't need to do it. Specifically,
// widgets positioned in a fixed layout manager will need to take into account:
//
// - Themes, which may change widget sizes.
//
// - Fonts other than the one you used to write the app will of course change
// the size of widgets containing text; keep in mind that users may use a larger
// font because of difficulty reading the default, or they may be using a
// different OS that provides different fonts.
//
// - Translation of text into other languages changes its size. Also, display of
// non-English text will use a different font in many cases.
//
// In addition, FixedLayout does not pay attention to text direction and thus
// may produce unwanted results if your app is run under right-to-left languages
// such as Hebrew or Arabic. That is: normally GTK will order containers
// appropriately depending on the text direction, e.g. to put labels to the
// right of the thing they label when using an RTL language; FixedLayout won't
// be able to do that for you.
//
// Finally, fixed positioning makes it kind of annoying to add/remove GUI
// elements, since you have to reposition all the other elements. This is a
// long-term maintenance problem for your application.
type FixedLayout interface {
	LayoutManager
}

type fixedLayout struct {
	layoutManager
}

func wrapFixedLayout(obj *externglib.Object) FixedLayout {
	return fixedLayout{layoutManager{*externglib.Object{obj}}}
}

func marshalFixedLayout(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewFixedLayout() FixedLayout

type FixedLayoutChild interface {
	LayoutChild

	// Transform: retrieves the transformation of the child of a FixedLayout.
	Transform() *gsk.Transform
	// SetTransform: sets the transformation of the child of a FixedLayout.
	SetTransform(transform *gsk.Transform)
}

type fixedLayoutChild struct {
	layoutChild
}

func wrapFixedLayoutChild(obj *externglib.Object) FixedLayoutChild {
	return fixedLayoutChild{layoutChild{*externglib.Object{obj}}}
}

func marshalFixedLayoutChild(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func (f fixedLayoutChild) Transform() *gsk.Transform

func (f fixedLayoutChild) SetTransform(transform *gsk.Transform)

// FlattenListModel is a list model that takes a list model containing list
// models and flattens it into a single model.
//
// Another term for this is concatenation: FlattenListModel takes a list of
// lists and concatenates them into a single list.
type FlattenListModel interface {
	gextras.Objector

	// Model: gets the model set via gtk_flatten_list_model_set_model().
	Model() gio.ListModel
	// ModelForItem: returns the model containing the item at the given
	// position.
	ModelForItem(position uint) gio.ListModel
	// SetModel: sets a new model to be flattened.
	SetModel(model gio.ListModel)
}

type flattenListModel struct {
	*externglib.Object
}

func wrapFlattenListModel(obj *externglib.Object) FlattenListModel {
	return flattenListModel{*externglib.Object{obj}}
}

func marshalFlattenListModel(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewFlattenListModel(model gio.ListModel) FlattenListModel

func (f flattenListModel) Model() gio.ListModel

func (f flattenListModel) ModelForItem(position uint) gio.ListModel

func (f flattenListModel) SetModel(model gio.ListModel)

// FlowBox: a GtkFlowBox positions child widgets in sequence according to its
// orientation.
//
// For instance, with the horizontal orientation, the widgets will be arranged
// from left to right, starting a new row under the previous row when necessary.
// Reducing the width in this case will require more rows, so a larger height
// will be requested.
//
// Likewise, with the vertical orientation, the widgets will be arranged from
// top to bottom, starting a new column to the right when necessary. Reducing
// the height will require more columns, so a larger width will be requested.
//
// The size request of a GtkFlowBox alone may not be what you expect; if you
// need to be able to shrink it along both axes and dynamically reflow its
// children, you may have to wrap it in a ScrolledWindow to enable that.
//
// The children of a GtkFlowBox can be dynamically sorted and filtered.
//
// Although a GtkFlowBox must have only FlowBoxChild children, you can add any
// kind of widget to it via gtk_flow_box_insert(), and a GtkFlowBoxChild widget
// will automatically be inserted between the box and the widget.
//
// Also see ListBox.
//
// CSS nodes
//
//    flowbox
//    ├── flowboxchild
//    │   ╰── <child>
//    ├── flowboxchild
//    │   ╰── <child>
//    ┊
//    ╰── [rubberband]
//
// GtkFlowBox uses a single CSS node with name flowbox. GtkFlowBoxChild uses a
// single CSS node with name flowboxchild. For rubberband selection, a subnode
// with name rubberband is used.
//
//
// Accessibility
//
// GtkFlowBox uses the K_ACCESSIBLE_ROLE_GRID role, and GtkFlowBoxChild uses the
// K_ACCESSIBLE_ROLE_GRID_CELL role.
type FlowBox interface {
	Widget

	// BindModel: binds @model to @box.
	//
	// If @box was already bound to a model, that previous binding is destroyed.
	//
	// The contents of @box are cleared and then filled with widgets that
	// represent items from @model. @box is updated whenever @model changes. If
	// @model is nil, @box is left empty.
	//
	// It is undefined to add or remove widgets directly (for example, with
	// gtk_flow_box_insert()) while @box is bound to a model.
	//
	// Note that using a model is incompatible with the filtering and sorting
	// functionality in GtkFlowBox. When using a model, filtering and sorting
	// should be implemented by the model.
	BindModel(model gio.ListModel, createWidgetFunc FlowBoxCreateWidgetFunc)
	// ActivateOnSingleClick: returns whether children activate on single
	// clicks.
	ActivateOnSingleClick() bool
	// ChildAtIndex: gets the nth child in the @box.
	ChildAtIndex(idx int) FlowBoxChild
	// ChildAtPos: gets the child in the (@x, @y) position. Both @x and @y are
	// assumed to be relative to the origin of @box.
	ChildAtPos(x int, y int) FlowBoxChild
	// ColumnSpacing: gets the horizontal spacing.
	ColumnSpacing() uint
	// Homogeneous: returns whether the box is homogeneous (all children are the
	// same size). See gtk_box_set_homogeneous().
	Homogeneous() bool
	// MaxChildrenPerLine: gets the maximum number of children per line.
	MaxChildrenPerLine() uint
	// MinChildrenPerLine: gets the minimum number of children per line.
	MinChildrenPerLine() uint
	// RowSpacing: gets the vertical spacing.
	RowSpacing() uint
	// SelectedChildren: creates a list of all selected children.
	SelectedChildren() *glib.List
	// SelectionMode: gets the selection mode of @box.
	SelectionMode() SelectionMode
	// Insert: inserts the @widget into @box at @position.
	//
	// If a sort function is set, the widget will actually be inserted at the
	// calculated position.
	//
	// If @position is -1, or larger than the total number of children in the
	// @box, then the @widget will be appended to the end.
	Insert(widget Widget, position int)
	// InvalidateFilter: updates the filtering for all children.
	//
	// Call this function when the result of the filter function on the @box is
	// changed due ot an external factor. For instance, this would be used if
	// the filter function just looked for a specific search term, and the entry
	// with the string has changed.
	InvalidateFilter()
	// InvalidateSort: updates the sorting for all children.
	//
	// Call this when the result of the sort function on @box is changed due to
	// an external factor.
	InvalidateSort()
	// Remove: removes a child from @box.
	Remove(widget Widget)
	// SelectAll: select all children of @box, if the selection mode allows it.
	SelectAll()
	// SelectChild: selects a single child of @box, if the selection mode allows
	// it.
	SelectChild(child FlowBoxChild)
	// SelectedForeach: calls a function for each selected child.
	//
	// Note that the selection cannot be modified from within this function.
	SelectedForeach(_func FlowBoxForeachFunc)
	// SetActivateOnSingleClick: if @single is true, children will be activated
	// when you click on them, otherwise you need to double-click.
	SetActivateOnSingleClick(single bool)
	// SetColumnSpacing: sets the horizontal space to add between children. See
	// the FlowBox:column-spacing property.
	SetColumnSpacing(spacing uint)
	// SetFilterFunc: by setting a filter function on the @box one can decide
	// dynamically which of the children to show. For instance, to implement a
	// search function that only shows the children matching the search terms.
	//
	// The @filter_func will be called for each child after the call, and it
	// will continue to be called each time a child changes (via
	// gtk_flow_box_child_changed()) or when gtk_flow_box_invalidate_filter() is
	// called.
	//
	// Note that using a filter function is incompatible with using a model (see
	// gtk_flow_box_bind_model()).
	SetFilterFunc(filterFunc FlowBoxFilterFunc)
	// SetHadjustment: hooks up an adjustment to focus handling in @box. The
	// adjustment is also used for autoscrolling during rubberband selection.
	// See gtk_scrolled_window_get_hadjustment() for a typical way of obtaining
	// the adjustment, and gtk_flow_box_set_vadjustment()for setting the
	// vertical adjustment.
	//
	// The adjustments have to be in pixel units and in the same coordinate
	// system as the allocation for immediate children of the box.
	SetHadjustment(adjustment Adjustment)
	// SetHomogeneous: sets the FlowBox:homogeneous property of @box,
	// controlling whether or not all children of @box are given equal space in
	// the box.
	SetHomogeneous(homogeneous bool)
	// SetMaxChildrenPerLine: sets the maximum number of children to request and
	// allocate space for in @box’s orientation.
	//
	// Setting the maximum number of children per line limits the overall
	// natural size request to be no more than @n_children children long in the
	// given orientation.
	SetMaxChildrenPerLine(nChildren uint)
	// SetMinChildrenPerLine: sets the minimum number of children to line up in
	// @box’s orientation before flowing.
	SetMinChildrenPerLine(nChildren uint)
	// SetRowSpacing: sets the vertical space to add between children. See the
	// FlowBox:row-spacing property.
	SetRowSpacing(spacing uint)
	// SetSelectionMode: sets how selection works in @box. See SelectionMode for
	// details.
	SetSelectionMode(mode SelectionMode)
	// SetSortFunc: by setting a sort function on the @box, one can dynamically
	// reorder the children of the box, based on the contents of the children.
	//
	// The @sort_func will be called for each child after the call, and will
	// continue to be called each time a child changes (via
	// gtk_flow_box_child_changed()) and when gtk_flow_box_invalidate_sort() is
	// called.
	//
	// Note that using a sort function is incompatible with using a model (see
	// gtk_flow_box_bind_model()).
	SetSortFunc(sortFunc FlowBoxSortFunc)
	// SetVadjustment: hooks up an adjustment to focus handling in @box. The
	// adjustment is also used for autoscrolling during rubberband selection.
	// See gtk_scrolled_window_get_vadjustment() for a typical way of obtaining
	// the adjustment, and gtk_flow_box_set_hadjustment()for setting the
	// horizontal adjustment.
	//
	// The adjustments have to be in pixel units and in the same coordinate
	// system as the allocation for immediate children of the box.
	SetVadjustment(adjustment Adjustment)
	// UnselectAll: unselect all children of @box, if the selection mode allows
	// it.
	UnselectAll()
	// UnselectChild: unselects a single child of @box, if the selection mode
	// allows it.
	UnselectChild(child FlowBoxChild)
}

type flowBox struct {
	widget
}

func wrapFlowBox(obj *externglib.Object) FlowBox {
	return flowBox{widget{externglib.InitiallyUnowned{obj}}}
}

func marshalFlowBox(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewFlowBox() FlowBox

func (f flowBox) BindModel(model gio.ListModel, createWidgetFunc FlowBoxCreateWidgetFunc)

func (f flowBox) ActivateOnSingleClick() bool

func (f flowBox) ChildAtIndex(idx int) FlowBoxChild

func (f flowBox) ChildAtPos(x int, y int) FlowBoxChild

func (f flowBox) ColumnSpacing() uint

func (f flowBox) Homogeneous() bool

func (f flowBox) MaxChildrenPerLine() uint

func (f flowBox) MinChildrenPerLine() uint

func (f flowBox) RowSpacing() uint

func (f flowBox) SelectedChildren() *glib.List

func (f flowBox) SelectionMode() SelectionMode

func (f flowBox) Insert(widget Widget, position int)

func (f flowBox) InvalidateFilter()

func (f flowBox) InvalidateSort()

func (f flowBox) Remove(widget Widget)

func (f flowBox) SelectAll()

func (f flowBox) SelectChild(child FlowBoxChild)

func (f flowBox) SelectedForeach(_func FlowBoxForeachFunc)

func (f flowBox) SetActivateOnSingleClick(single bool)

func (f flowBox) SetColumnSpacing(spacing uint)

func (f flowBox) SetFilterFunc(filterFunc FlowBoxFilterFunc)

func (f flowBox) SetHadjustment(adjustment Adjustment)

func (f flowBox) SetHomogeneous(homogeneous bool)

func (f flowBox) SetMaxChildrenPerLine(nChildren uint)

func (f flowBox) SetMinChildrenPerLine(nChildren uint)

func (f flowBox) SetRowSpacing(spacing uint)

func (f flowBox) SetSelectionMode(mode SelectionMode)

func (f flowBox) SetSortFunc(sortFunc FlowBoxSortFunc)

func (f flowBox) SetVadjustment(adjustment Adjustment)

func (f flowBox) UnselectAll()

func (f flowBox) UnselectChild(child FlowBoxChild)

type FlowBoxChild interface {
	Widget

	// Changed: marks @child as changed, causing any state that depends on this
	// to be updated. This affects sorting and filtering.
	//
	// Note that calls to this method must be in sync with the data used for the
	// sorting and filtering functions. For instance, if the list is mirroring
	// some external data set, and *two* children changed in the external data
	// set when you call gtk_flow_box_child_changed() on the first child, the
	// sort function must only read the new data for the first of the two
	// changed children, otherwise the resorting of the children will be wrong.
	//
	// This generally means that if you don’t fully control the data model, you
	// have to duplicate the data that affects the sorting and filtering
	// functions into the widgets themselves. Another alternative is to call
	// gtk_flow_box_invalidate_sort() on any model change, but that is more
	// expensive.
	Changed()
	// Child: gets the child widget of @self.
	Child() Widget
	// Index: gets the current index of the @child in its FlowBox container.
	Index() int
	// IsSelected: returns whether the @child is currently selected in its
	// FlowBox container.
	IsSelected() bool
	// SetChild: sets the child widget of @self.
	SetChild(child Widget)
}

type flowBoxChild struct {
	widget
}

func wrapFlowBoxChild(obj *externglib.Object) FlowBoxChild {
	return flowBoxChild{widget{externglib.InitiallyUnowned{obj}}}
}

func marshalFlowBoxChild(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewFlowBoxChild() FlowBoxChild

func (f flowBoxChild) Changed()

func (f flowBoxChild) Child() Widget

func (f flowBoxChild) Index() int

func (f flowBoxChild) IsSelected() bool

func (f flowBoxChild) SetChild(child Widget)

// FontButton: the FontButton is a button which displays the currently selected
// font an allows to open a font chooser dialog to change the font. It is
// suitable widget for selecting a font in a preference dialog.
//
// CSS nodes
//
//    fontbutton
//    ╰── button.font
//        ╰── [content]
//
// GtkFontButton has a single CSS node with name fontbutton which contains a
// button node with the .font style class.
type FontButton interface {
	Widget

	// Modal: gets whether the dialog is modal.
	Modal() bool
	// Title: retrieves the title of the font chooser dialog.
	Title() string
	// UseFont: returns whether the selected font is used in the label.
	UseFont() bool
	// UseSize: returns whether the selected size is used in the label.
	UseSize() bool
	// SetModal: sets whether the dialog should be modal.
	SetModal(modal bool)
	// SetTitle: sets the title for the font chooser dialog.
	SetTitle(title string)
	// SetUseFont: if @use_font is true, the font name will be written using the
	// selected font.
	SetUseFont(useFont bool)
	// SetUseSize: if @use_size is true, the font name will be written using the
	// selected size.
	SetUseSize(useSize bool)
}

type fontButton struct {
	widget
}

func wrapFontButton(obj *externglib.Object) FontButton {
	return fontButton{widget{externglib.InitiallyUnowned{obj}}}
}

func marshalFontButton(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewFontButton() FontButton

func NewFontButton(fontname string) FontButton

func (f fontButton) Modal() bool

func (f fontButton) Title() string

func (f fontButton) UseFont() bool

func (f fontButton) UseSize() bool

func (f fontButton) SetModal(modal bool)

func (f fontButton) SetTitle(title string)

func (f fontButton) SetUseFont(useFont bool)

func (f fontButton) SetUseSize(useSize bool)

// FontChooserDialog: the FontChooserDialog widget is a dialog for selecting a
// font. It implements the FontChooser interface.
//
//
// GtkFontChooserDialog as GtkBuildable
//
// The GtkFontChooserDialog implementation of the Buildable interface exposes
// the buttons with the names “select_button” and “cancel_button”.
type FontChooserDialog interface {
	Dialog
}

type fontChooserDialog struct {
	dialog
}

func wrapFontChooserDialog(obj *externglib.Object) FontChooserDialog {
	return fontChooserDialog{dialog{window{widget{externglib.InitiallyUnowned{obj}}}}}
}

func marshalFontChooserDialog(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewFontChooserDialog(title string, parent Window) FontChooserDialog

// FontChooserWidget: the FontChooserWidget widget lists the available fonts,
// styles and sizes, allowing the user to select a font. It is used in the
// FontChooserDialog widget to provide a dialog box for selecting fonts.
//
// To set the font which is initially selected, use gtk_font_chooser_set_font()
// or gtk_font_chooser_set_font_desc().
//
// To get the selected font use gtk_font_chooser_get_font() or
// gtk_font_chooser_get_font_desc().
//
// To change the text which is shown in the preview area, use
// gtk_font_chooser_set_preview_text().
//
//
// CSS nodes
//
// GtkFontChooserWidget has a single CSS node with name fontchooser.
type FontChooserWidget interface {
	Widget
}

type fontChooserWidget struct {
	widget
}

func wrapFontChooserWidget(obj *externglib.Object) FontChooserWidget {
	return fontChooserWidget{widget{externglib.InitiallyUnowned{obj}}}
}

func marshalFontChooserWidget(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewFontChooserWidget() FontChooserWidget

// Frame: the frame widget is a widget that surrounds its child with a
// decorative frame and an optional label. If present, the label is drawn inside
// the top edge of the frame. The horizontal position of the label can be
// controlled with gtk_frame_set_label_align().
//
// GtkFrame clips its child. You can use this to add rounded corners to widgets,
// but be aware that it also cuts off shadows.
//
//
// GtkFrame as GtkBuildable
//
// The GtkFrame implementation of the GtkBuildable interface supports placing a
// child in the label position by specifying “label” as the “type” attribute of
// a <child> element. A normal content child can be specified without specifying
// a <child> type attribute.
//
//
//    <object class="GtkFrame">
//      <child type="label">
//        <object class="GtkLabel" id="frame_label"/>
//      </child>
//      <child>
//        <object class="GtkEntry" id="frame_content"/>
//      </child>
//    </object>
//
// CSS nodes
//
//    frame
//    ├── <label widget>
//    ╰── <child>
//
// GtkFrame has a main CSS node with name “frame”, which is used to draw the
// visible border. You can set the appearance of the border using CSS properties
// like “border-style” on this node.
type Frame interface {
	Widget

	// Child: gets the child widget of @frame.
	Child() Widget
	// Label: if the frame’s label widget is a Label, returns the text in the
	// label widget. (The frame will have a Label for the label widget if a
	// non-nil argument was passed to gtk_frame_new().)
	Label() string
	// LabelAlign: retrieves the X alignment of the frame’s label. See
	// gtk_frame_set_label_align().
	LabelAlign() float32
	// LabelWidget: retrieves the label widget for the frame. See
	// gtk_frame_set_label_widget().
	LabelWidget() Widget
	// SetChild: sets the child widget of @frame.
	SetChild(child Widget)
	// SetLabel: removes the current Frame:label-widget. If @label is not nil,
	// creates a new Label with that text and adds it as the Frame:label-widget.
	SetLabel(label string)
	// SetLabelAlign: sets the X alignment of the frame widget’s label. The
	// default value for a newly created frame is 0.0.
	SetLabelAlign(xalign float32)
	// SetLabelWidget: sets the Frame:label-widget for the frame. This is the
	// widget that will appear embedded in the top edge of the frame as a title.
	SetLabelWidget(labelWidget Widget)
}

type frame struct {
	widget
}

func wrapFrame(obj *externglib.Object) Frame {
	return frame{widget{externglib.InitiallyUnowned{obj}}}
}

func marshalFrame(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewFrame(label string) Frame

func (f frame) Child() Widget

func (f frame) Label() string

func (f frame) LabelAlign() float32

func (f frame) LabelWidget() Widget

func (f frame) SetChild(child Widget)

func (f frame) SetLabel(label string)

func (f frame) SetLabelAlign(xalign float32)

func (f frame) SetLabelWidget(labelWidget Widget)

// GLArea is a widget that allows drawing with OpenGL.
//
// GLArea sets up its own GLContext for the window it creates, and creates a
// custom GL framebuffer that the widget will do GL rendering onto. It also
// ensures that this framebuffer is the default GL rendering target when
// rendering.
//
// In order to draw, you have to connect to the GLArea::render signal, or
// subclass GLArea and override the @GtkGLAreaClass.render() virtual function.
//
// The GLArea widget ensures that the GLContext is associated with the widget's
// drawing area, and it is kept updated when the size and position of the
// drawing area changes.
//
// Drawing with GtkGLArea ##
//
// The simplest way to draw using OpenGL commands in a GLArea is to create a
// widget instance and connect to the GLArea::render signal:
//
//    <!-- language="C" -->
//
//
//
// The `render()` function will be called when the GLArea is ready for you to
// draw its content:
//
//      static gboolean
//      render (GtkGLArea *area, GdkGLContext *context)
//      {
//        // inside this function it's safe to use GL; the given
//        // GLContext has been made current to the drawable
//        // surface used by the GLArea and the viewport has
//        // already been set to be the size of the allocation
//
//        // we can start by clearing the buffer
//        glClearColor (0, 0, 0, 0);
//        glClear (GL_COLOR_BUFFER_BIT);
//
//        // draw your object
//        // draw_an_object ();
//
//        // we completed our drawing; the draw commands will be
//        // flushed at the end of the signal emission chain, and
//        // the buffers will be drawn on the window
//        return TRUE;
//      }
//
//      void setup_glarea (void)
//      {
//        // create a GtkGLArea instance
//        GtkWidget *gl_area = gtk_gl_area_new ();
//
//        // connect to the "render" signal
//        g_signal_connect (gl_area, "render", G_CALLBACK (render), NULL);
//      }
//
//
// If you need to initialize OpenGL state, e.g. buffer objects or shaders, you
// should use the Widget::realize signal; you can use the Widget::unrealize
// signal to clean up. Since the GLContext creation and initialization may fail,
// you will need to check for errors, using gtk_gl_area_get_error(). An example
// of how to safely initialize the GL state is:
//
//      static void
//      on_realize (GtkGLarea *area)
//      {
//        // We need to make the context current if we want to
//        // call GL API
//        gtk_gl_area_make_current (area);
//
//        // If there were errors during the initialization or
//        // when trying to make the context current, this
//        // function will return a #GError for you to catch
//        if (gtk_gl_area_get_error (area) != NULL)
//          return;
//
//        // You can also use gtk_gl_area_set_error() in order
//        // to show eventual initialization errors on the
//        // GtkGLArea widget itself
//        GError *internal_error = NULL;
//        init_buffer_objects (&error);
//        if (error != NULL)
//          {
//            gtk_gl_area_set_error (area, error);
//            g_error_free (error);
//            return;
//          }
//
//        init_shaders (&error);
//        if (error != NULL)
//          {
//            gtk_gl_area_set_error (area, error);
//            g_error_free (error);
//            return;
//          }
//      }
//
//
// If you need to change the options for creating the GLContext you should use
// the GLArea::create-context signal.
type GLArea interface {
	Widget

	// AttachBuffers: ensures that the @area framebuffer object is made the
	// current draw and read target, and that all the required buffers for the
	// @area are created and bound to the framebuffer.
	//
	// This function is automatically called before emitting the GLArea::render
	// signal, and doesn't normally need to be called by application code.
	AttachBuffers()
	// AutoRender: returns whether the area is in auto render mode or not.
	AutoRender() bool
	// Context: retrieves the GLContext used by @area.
	Context() gdk.GLContext
	// Error: gets the current error set on the @area.
	Error() *glib.Error
	// HasDepthBuffer: returns whether the area has a depth buffer.
	HasDepthBuffer() bool
	// HasStencilBuffer: returns whether the area has a stencil buffer.
	HasStencilBuffer() bool
	// RequiredVersion: retrieves the required version of OpenGL set using
	// gtk_gl_area_set_required_version().
	RequiredVersion() (major int, minor int)
	// UseES: retrieves the value set by gtk_gl_area_set_use_es().
	UseES() bool
	// MakeCurrent: ensures that the GLContext used by @area is associated with
	// the GLArea.
	//
	// This function is automatically called before emitting the GLArea::render
	// signal, and doesn't normally need to be called by application code.
	MakeCurrent()
	// QueueRender: marks the currently rendered data (if any) as invalid, and
	// queues a redraw of the widget, ensuring that the GLArea::render signal is
	// emitted during the draw.
	//
	// This is only needed when the gtk_gl_area_set_auto_render() has been
	// called with a false value. The default behaviour is to emit
	// GLArea::render on each draw.
	QueueRender()
	// SetAutoRender: if @auto_render is true the GLArea::render signal will be
	// emitted every time the widget draws. This is the default and is useful if
	// drawing the widget is faster.
	//
	// If @auto_render is false the data from previous rendering is kept around
	// and will be used for drawing the widget the next time, unless the window
	// is resized. In order to force a rendering gtk_gl_area_queue_render() must
	// be called. This mode is useful when the scene changes seldom, but takes a
	// long time to redraw.
	SetAutoRender(autoRender bool)
	// SetError: sets an error on the area which will be shown instead of the GL
	// rendering. This is useful in the GLArea::create-context signal if GL
	// context creation fails.
	SetError(error *glib.Error)
	// SetHasDepthBuffer: if @has_depth_buffer is true the widget will allocate
	// and enable a depth buffer for the target framebuffer. Otherwise there
	// will be none.
	SetHasDepthBuffer(hasDepthBuffer bool)
	// SetHasStencilBuffer: if @has_stencil_buffer is true the widget will
	// allocate and enable a stencil buffer for the target framebuffer.
	// Otherwise there will be none.
	SetHasStencilBuffer(hasStencilBuffer bool)
	// SetRequiredVersion: sets the required version of OpenGL to be used when
	// creating the context for the widget.
	//
	// This function must be called before the area has been realized.
	SetRequiredVersion(major int, minor int)
	// SetUseES: sets whether the @area should create an OpenGL or an OpenGL ES
	// context.
	//
	// You should check the capabilities of the GLContext before drawing with
	// either API.
	SetUseES(useES bool)
}

type glArea struct {
	widget
}

func wrapGLArea(obj *externglib.Object) GLArea {
	return glArea{widget{externglib.InitiallyUnowned{obj}}}
}

func marshalGLArea(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewGLArea() GLArea

func (g glArea) AttachBuffers()

func (g glArea) AutoRender() bool

func (g glArea) Context() gdk.GLContext

func (g glArea) Error() *glib.Error

func (g glArea) HasDepthBuffer() bool

func (g glArea) HasStencilBuffer() bool

func (g glArea) RequiredVersion() (major int, minor int)

func (g glArea) UseES() bool

func (g glArea) MakeCurrent()

func (g glArea) QueueRender()

func (g glArea) SetAutoRender(autoRender bool)

func (g glArea) SetError(error *glib.Error)

func (g glArea) SetHasDepthBuffer(hasDepthBuffer bool)

func (g glArea) SetHasStencilBuffer(hasStencilBuffer bool)

func (g glArea) SetRequiredVersion(major int, minor int)

func (g glArea) SetUseES(useES bool)

// Gesture is the base object for gesture recognition, although this object is
// quite generalized to serve as a base for multi-touch gestures, it is suitable
// to implement single-touch and pointer-based gestures (using the special nil
// EventSequence value for these).
//
// The number of touches that a Gesture need to be recognized is controlled by
// the Gesture:n-points property, if a gesture is keeping track of less or more
// than that number of sequences, it won't check whether the gesture is
// recognized.
//
// As soon as the gesture has the expected number of touches, it will check
// regularly if it is recognized, the criteria to consider a gesture as
// "recognized" is left to Gesture subclasses.
//
// A recognized gesture will then emit the following signals: - Gesture::begin
// when the gesture is recognized. - A number of Gesture::update, whenever an
// input event is processed. - Gesture::end when the gesture is no longer
// recognized.
//
//
// Event propagation
//
// In order to receive events, a gesture needs to set a propagation phase
// through gtk_event_controller_set_propagation_phase().
//
// In the capture phase, events are propagated from the toplevel down to the
// target widget, and gestures that are attached to containers above the widget
// get a chance to interact with the event before it reaches the target.
//
// In the bubble phase, events are propagated up from the target widget to the
// toplevel, and gestures that are attached to containers above the widget get a
// chance to interact with events that have not been handled yet.
//
// States of a sequence {#touch-sequence-states}
//
// Whenever input interaction happens, a single event may trigger a cascade of
// Gestures, both across the parents of the widget receiving the event and in
// parallel within an individual widget. It is a responsibility of the widgets
// using those gestures to set the state of touch sequences accordingly in order
// to enable cooperation of gestures around the EventSequences triggering those.
//
// Within a widget, gestures can be grouped through gtk_gesture_group(), grouped
// gestures synchronize the state of sequences, so calling
// gtk_gesture_set_sequence_state() on one will effectively propagate the state
// throughout the group.
//
// By default, all sequences start out in the K_EVENT_SEQUENCE_NONE state,
// sequences in this state trigger the gesture event handler, but event
// propagation will continue unstopped by gestures.
//
// If a sequence enters into the K_EVENT_SEQUENCE_DENIED state, the gesture
// group will effectively ignore the sequence, letting events go unstopped
// through the gesture, but the "slot" will still remain occupied while the
// touch is active.
//
// If a sequence enters in the K_EVENT_SEQUENCE_CLAIMED state, the gesture group
// will grab all interaction on the sequence, by: - Setting the same sequence to
// K_EVENT_SEQUENCE_DENIED on every other gesture group within the widget, and
// every gesture on parent widgets in the propagation chain. - calling
// Gesture::cancel on every gesture in widgets underneath in the propagation
// chain. - Stopping event propagation after the gesture group handles the
// event.
//
// Note: if a sequence is set early to K_EVENT_SEQUENCE_CLAIMED on
// K_TOUCH_BEGIN/K_BUTTON_PRESS (so those events are captured before reaching
// the event widget, this implies K_PHASE_CAPTURE), one similar event will
// emulated if the sequence changes to K_EVENT_SEQUENCE_DENIED. This way event
// coherence is preserved before event propagation is unstopped again.
//
// Sequence states can't be changed freely, see gtk_gesture_set_sequence_state()
// to know about the possible lifetimes of a EventSequence.
//
//
// Touchpad gestures
//
// On the platforms that support it, Gesture will handle transparently touchpad
// gesture events. The only precautions users of Gesture should do to enable
// this support are: - Enabling GDK_TOUCHPAD_GESTURE_MASK on their Surfaces - If
// the gesture has GTK_PHASE_NONE, ensuring events of type GDK_TOUCHPAD_SWIPE
// and GDK_TOUCHPAD_PINCH are handled by the Gesture
type Gesture interface {
	EventController

	// BoundingBox: if there are touch sequences being currently handled by
	// @gesture, this function returns true and fills in @rect with the bounding
	// box containing all active touches. Otherwise, false will be returned.
	//
	// Note: This function will yield unexpected results on touchpad gestures.
	// Since there is no correlation between physical and pixel distances, these
	// will look as if constrained in an infinitely small area, @rect width and
	// height will thus be 0 regardless of the number of touchpoints.
	BoundingBox() (rect gdk.Rectangle, ok bool)
	// BoundingBoxCenter: if there are touch sequences being currently handled
	// by @gesture, this function returns true and fills in @x and @y with the
	// center of the bounding box containing all active touches. Otherwise,
	// false will be returned.
	BoundingBoxCenter() (x float64, y float64, ok bool)
	// Device: returns the logical Device that is currently operating on
	// @gesture, or nil if the gesture is not being interacted.
	Device() gdk.Device
	// GetGroup: returns all gestures in the group of @gesture
	GetGroup() *glib.List
	// LastEvent: returns the last event that was processed for @sequence.
	//
	// Note that the returned pointer is only valid as long as the @sequence is
	// still interpreted by the @gesture. If in doubt, you should make a copy of
	// the event.
	LastEvent(sequence *gdk.EventSequence) gdk.Event
	// LastUpdatedSequence: returns the EventSequence that was last updated on
	// @gesture.
	LastUpdatedSequence() *gdk.EventSequence
	// Point: if @sequence is currently being interpreted by @gesture, this
	// function returns true and fills in @x and @y with the last coordinates
	// stored for that event sequence. The coordinates are always relative to
	// the widget allocation.
	Point(sequence *gdk.EventSequence) (x float64, y float64, ok bool)
	// SequenceState: returns the @sequence state, as seen by @gesture.
	SequenceState(sequence *gdk.EventSequence) EventSequenceState
	// Sequences: returns the list of EventSequences currently being interpreted
	// by @gesture.
	Sequences() *glib.List
	// Group: adds @gesture to the same group than @group_gesture. Gestures are
	// by default isolated in their own groups.
	//
	// Both gestures must have been added to the same widget before they can be
	// grouped.
	//
	// When gestures are grouped, the state of EventSequences is kept in sync
	// for all of those, so calling gtk_gesture_set_sequence_state(), on one
	// will transfer the same value to the others.
	//
	// Groups also perform an "implicit grabbing" of sequences, if a
	// EventSequence state is set to K_EVENT_SEQUENCE_CLAIMED on one group,
	// every other gesture group attached to the same Widget will switch the
	// state for that sequence to K_EVENT_SEQUENCE_DENIED.
	Group(gesture Gesture)
	// HandlesSequence: returns true if @gesture is currently handling events
	// corresponding to @sequence.
	HandlesSequence(sequence *gdk.EventSequence) bool
	// IsActive: returns true if the gesture is currently active. A gesture is
	// active meanwhile there are touch sequences interacting with it.
	IsActive() bool
	// IsGroupedWith: returns true if both gestures pertain to the same group.
	IsGroupedWith(other Gesture) bool
	// IsRecognized: returns true if the gesture is currently recognized. A
	// gesture is recognized if there are as many interacting touch sequences as
	// required by @gesture.
	IsRecognized() bool
	// SetSequenceState: sets the state of @sequence in @gesture. Sequences
	// start in state K_EVENT_SEQUENCE_NONE, and whenever they change state,
	// they can never go back to that state. Likewise, sequences in state
	// K_EVENT_SEQUENCE_DENIED cannot turn back to a not denied state. With
	// these rules, the lifetime of an event sequence is constrained to the next
	// four:
	//
	// * None * None → Denied * None → Claimed * None → Claimed → Denied
	//
	// Note: Due to event handling ordering, it may be unsafe to set the state
	// on another gesture within a Gesture::begin signal handler, as the
	// callback might be executed before the other gesture knows about the
	// sequence. A safe way to perform this could be:
	//
	//
	//    static void
	//    first_gesture_begin_cb (GtkGesture       *first_gesture,
	//                            GdkEventSequence *sequence,
	//                            gpointer          user_data)
	//    {
	//      gtk_gesture_set_sequence_state (first_gesture, sequence, GTK_EVENT_SEQUENCE_CLAIMED);
	//      gtk_gesture_set_sequence_state (second_gesture, sequence, GTK_EVENT_SEQUENCE_DENIED);
	//    }
	//
	//    static void
	//    second_gesture_begin_cb (GtkGesture       *second_gesture,
	//                             GdkEventSequence *sequence,
	//                             gpointer          user_data)
	//    {
	//      if (gtk_gesture_get_sequence_state (first_gesture, sequence) == GTK_EVENT_SEQUENCE_CLAIMED)
	//        gtk_gesture_set_sequence_state (second_gesture, sequence, GTK_EVENT_SEQUENCE_DENIED);
	//    }
	//
	//
	// If both gestures are in the same group, just set the state on the gesture
	// emitting the event, the sequence will be already be initialized to the
	// group's global state when the second gesture processes the event.
	SetSequenceState(sequence *gdk.EventSequence, state EventSequenceState) bool
	// SetState: sets the state of all sequences that @gesture is currently
	// interacting with. See gtk_gesture_set_sequence_state() for more details
	// on sequence states.
	SetState(state EventSequenceState) bool
	// Ungroup: separates @gesture into an isolated group.
	Ungroup()
}

type gesture struct {
	eventController
}

func wrapGesture(obj *externglib.Object) Gesture {
	return gesture{eventController{*externglib.Object{obj}}}
}

func marshalGesture(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func (g gesture) BoundingBox() (rect gdk.Rectangle, ok bool)

func (g gesture) BoundingBoxCenter() (x float64, y float64, ok bool)

func (g gesture) Device() gdk.Device

func (g gesture) GetGroup() *glib.List

func (g gesture) LastEvent(sequence *gdk.EventSequence) gdk.Event

func (g gesture) LastUpdatedSequence() *gdk.EventSequence

func (g gesture) Point(sequence *gdk.EventSequence) (x float64, y float64, ok bool)

func (g gesture) SequenceState(sequence *gdk.EventSequence) EventSequenceState

func (g gesture) Sequences() *glib.List

func (g gesture) Group(gesture Gesture)

func (g gesture) HandlesSequence(sequence *gdk.EventSequence) bool

func (g gesture) IsActive() bool

func (g gesture) IsGroupedWith(other Gesture) bool

func (g gesture) IsRecognized() bool

func (g gesture) SetSequenceState(sequence *gdk.EventSequence, state EventSequenceState) bool

func (g gesture) SetState(state EventSequenceState) bool

func (g gesture) Ungroup()

// GestureClick is a Gesture implementation able to recognize multiple clicks on
// a nearby zone, which can be listened for through the GestureClick::pressed
// signal. Whenever time or distance between clicks exceed the GTK defaults,
// GestureClick::stopped is emitted, and the click counter is reset.
type GestureClick interface {
	GestureSingle
}

type gestureClick struct {
	gestureSingle
}

func wrapGestureClick(obj *externglib.Object) GestureClick {
	return gestureClick{gestureSingle{gesture{eventController{*externglib.Object{obj}}}}}
}

func marshalGestureClick(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewGestureClick() GestureClick

// GestureDrag is a Gesture implementation that recognizes drag operations. The
// drag operation itself can be tracked throughout the GestureDrag::drag-begin,
// GestureDrag::drag-update and GestureDrag::drag-end signals, or the relevant
// coordinates be extracted through gtk_gesture_drag_get_offset() and
// gtk_gesture_drag_get_start_point().
type GestureDrag interface {
	GestureSingle

	// Offset: if the @gesture is active, this function returns true and fills
	// in @x and @y with the coordinates of the current point, as an offset to
	// the starting drag point.
	Offset() (x float64, y float64, ok bool)
	// StartPoint: if the @gesture is active, this function returns true and
	// fills in @x and @y with the drag start coordinates, in window-relative
	// coordinates.
	StartPoint() (x float64, y float64, ok bool)
}

type gestureDrag struct {
	gestureSingle
}

func wrapGestureDrag(obj *externglib.Object) GestureDrag {
	return gestureDrag{gestureSingle{gesture{eventController{*externglib.Object{obj}}}}}
}

func marshalGestureDrag(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewGestureDrag() GestureDrag

func (g gestureDrag) Offset() (x float64, y float64, ok bool)

func (g gestureDrag) StartPoint() (x float64, y float64, ok bool)

// GestureLongPress is a Gesture implementation able to recognize long presses,
// triggering the GestureLongPress::pressed after the timeout is exceeded.
//
// If the touchpoint is lifted before the timeout passes, or if it drifts too
// far of the initial press point, the GestureLongPress::cancelled signal will
// be emitted.
type GestureLongPress interface {
	GestureSingle

	// DelayFactor: returns the delay factor as set by
	// gtk_gesture_long_press_set_delay_factor().
	DelayFactor() float64
	// SetDelayFactor: applies the given delay factor. The default long press
	// time will be multiplied by this value. Valid values are in the range
	// [0.5..2.0].
	SetDelayFactor(delayFactor float64)
}

type gestureLongPress struct {
	gestureSingle
}

func wrapGestureLongPress(obj *externglib.Object) GestureLongPress {
	return gestureLongPress{gestureSingle{gesture{eventController{*externglib.Object{obj}}}}}
}

func marshalGestureLongPress(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewGestureLongPress() GestureLongPress

func (g gestureLongPress) DelayFactor() float64

func (g gestureLongPress) SetDelayFactor(delayFactor float64)

// GesturePan is a Gesture implementation able to recognize pan gestures, those
// are drags that are locked to happen along one axis. The axis that a
// GesturePan handles is defined at construct time, and can be changed through
// gtk_gesture_pan_set_orientation().
//
// When the gesture starts to be recognized, GesturePan will attempt to
// determine as early as possible whether the sequence is moving in the expected
// direction, and denying the sequence if this does not happen.
//
// Once a panning gesture along the expected axis is recognized, the
// GesturePan::pan signal will be emitted as input events are received,
// containing the offset in the given axis.
type GesturePan interface {
	GestureDrag

	// Orientation: returns the orientation of the pan gestures that this
	// @gesture expects.
	Orientation() Orientation
	// SetOrientation: sets the orientation to be expected on pan gestures.
	SetOrientation(orientation Orientation)
}

type gesturePan struct {
	gestureDrag
}

func wrapGesturePan(obj *externglib.Object) GesturePan {
	return gesturePan{gestureDrag{gestureSingle{gesture{eventController{*externglib.Object{obj}}}}}}
}

func marshalGesturePan(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewGesturePan(orientation Orientation) GesturePan

func (g gesturePan) Orientation() Orientation

func (g gesturePan) SetOrientation(orientation Orientation)

// GestureRotate is a Gesture implementation able to recognize 2-finger
// rotations, whenever the angle between both handled sequences changes, the
// GestureRotate::angle-changed signal is emitted.
type GestureRotate interface {
	Gesture

	// AngleDelta: if @gesture is active, this function returns the angle
	// difference in radians since the gesture was first recognized. If @gesture
	// is not active, 0 is returned.
	AngleDelta() float64
}

type gestureRotate struct {
	gesture
}

func wrapGestureRotate(obj *externglib.Object) GestureRotate {
	return gestureRotate{gesture{eventController{*externglib.Object{obj}}}}
}

func marshalGestureRotate(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewGestureRotate() GestureRotate

func (g gestureRotate) AngleDelta() float64

// GestureSingle is a subclass of Gesture, optimized (although not restricted)
// for dealing with mouse and single-touch gestures. Under interaction, these
// gestures stick to the first interacting sequence, which is accessible through
// gtk_gesture_single_get_current_sequence() while the gesture is being
// interacted with.
//
// By default gestures react to both GDK_BUTTON_PRIMARY and touch events,
// gtk_gesture_single_set_touch_only() can be used to change the touch behavior.
// Callers may also specify a different mouse button number to interact with
// through gtk_gesture_single_set_button(), or react to any mouse button by
// setting 0. While the gesture is active, the button being currently pressed
// can be known through gtk_gesture_single_get_current_button().
type GestureSingle interface {
	Gesture

	// Button: returns the button number @gesture listens for, or 0 if @gesture
	// reacts to any button press.
	Button() uint
	// CurrentButton: returns the button number currently interacting with
	// @gesture, or 0 if there is none.
	CurrentButton() uint
	// CurrentSequence: returns the event sequence currently interacting with
	// @gesture. This is only meaningful if gtk_gesture_is_active() returns
	// true.
	CurrentSequence() *gdk.EventSequence
	// Exclusive: gets whether a gesture is exclusive. For more information, see
	// gtk_gesture_single_set_exclusive().
	Exclusive() bool
	// TouchOnly: returns true if the gesture is only triggered by touch events.
	TouchOnly() bool
	// SetButton: sets the button number @gesture listens to. If non-0, every
	// button press from a different button number will be ignored. Touch events
	// implicitly match with button 1.
	SetButton(button uint)
	// SetExclusive: sets whether @gesture is exclusive. An exclusive gesture
	// will only handle pointer and "pointer emulated" touch events, so at any
	// given time, there is only one sequence able to interact with those.
	SetExclusive(exclusive bool)
	// SetTouchOnly: if @touch_only is true, @gesture will only handle events of
	// type K_TOUCH_BEGIN, K_TOUCH_UPDATE or K_TOUCH_END. If false, mouse events
	// will be handled too.
	SetTouchOnly(touchOnly bool)
}

type gestureSingle struct {
	gesture
}

func wrapGestureSingle(obj *externglib.Object) GestureSingle {
	return gestureSingle{gesture{eventController{*externglib.Object{obj}}}}
}

func marshalGestureSingle(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func (g gestureSingle) Button() uint

func (g gestureSingle) CurrentButton() uint

func (g gestureSingle) CurrentSequence() *gdk.EventSequence

func (g gestureSingle) Exclusive() bool

func (g gestureSingle) TouchOnly() bool

func (g gestureSingle) SetButton(button uint)

func (g gestureSingle) SetExclusive(exclusive bool)

func (g gestureSingle) SetTouchOnly(touchOnly bool)

// GestureStylus is a Gesture implementation specific to stylus input. The
// provided signals just relay the basic information of the stylus events.
type GestureStylus interface {
	GestureSingle

	// Axes: returns the current values for the requested @axes. This function
	// must be called from either the GestureStylus::down,
	// GestureStylus::motion, GestureStylus::up or GestureStylus::proximity
	// signals.
	Axes(axes []gdk.AxisUse) (values []float64, ok bool)
	// Axis: returns the current value for the requested @axis.
	//
	// This function must be called from the handler of one of the
	// GestureStylus::down, GestureStylus::motion, GestureStylus::up or
	// GestureStylus::proximity signals.
	Axis(axis gdk.AxisUse) (value float64, ok bool)
	// Backlog: by default, GTK will limit rate of input events. On stylus input
	// where accuracy of strokes is paramount, this function returns the
	// accumulated coordinate/timing state before the emission of the current
	// GestureStylus::motion signal.
	//
	// This function may only be called within a GestureStylus::motion signal
	// handler, the state given in this signal and obtainable through
	// gtk_gesture_stylus_get_axis() call express the latest (most up-to-date)
	// state in motion history.
	//
	// The @backlog is provided in chronological order.
	Backlog() (backlog []*gdk.TimeCoord, nElems uint, ok bool)
	// DeviceTool: returns the DeviceTool currently driving input through this
	// gesture. This function must be called from either the
	// GestureStylus::down, GestureStylus::motion, GestureStylus::up or
	// GestureStylus::proximity signal handlers.
	DeviceTool() gdk.DeviceTool
}

type gestureStylus struct {
	gestureSingle
}

func wrapGestureStylus(obj *externglib.Object) GestureStylus {
	return gestureStylus{gestureSingle{gesture{eventController{*externglib.Object{obj}}}}}
}

func marshalGestureStylus(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewGestureStylus() GestureStylus

func (g gestureStylus) Axes(axes []gdk.AxisUse) (values []float64, ok bool)

func (g gestureStylus) Axis(axis gdk.AxisUse) (value float64, ok bool)

func (g gestureStylus) Backlog() (backlog []*gdk.TimeCoord, nElems uint, ok bool)

func (g gestureStylus) DeviceTool() gdk.DeviceTool

// GestureSwipe is a Gesture implementation able to recognize swipes, after a
// press/move/.../move/release sequence happens, the GestureSwipe::swipe signal
// will be emitted, providing the velocity and directionality of the sequence at
// the time it was lifted.
//
// If the velocity is desired in intermediate points,
// gtk_gesture_swipe_get_velocity() can be called on eg. a Gesture::update
// handler.
//
// All velocities are reported in pixels/sec units.
type GestureSwipe interface {
	GestureSingle

	// Velocity: if the gesture is recognized, this function returns true and
	// fill in @velocity_x and @velocity_y with the recorded velocity, as per
	// the last event(s) processed.
	Velocity() (velocityX float64, velocityY float64, ok bool)
}

type gestureSwipe struct {
	gestureSingle
}

func wrapGestureSwipe(obj *externglib.Object) GestureSwipe {
	return gestureSwipe{gestureSingle{gesture{eventController{*externglib.Object{obj}}}}}
}

func marshalGestureSwipe(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewGestureSwipe() GestureSwipe

func (g gestureSwipe) Velocity() (velocityX float64, velocityY float64, ok bool)

// GestureZoom is a Gesture implementation able to recognize pinch/zoom
// gestures, whenever the distance between both tracked sequences changes, the
// GestureZoom::scale-changed signal is emitted to report the scale factor.
type GestureZoom interface {
	Gesture

	// ScaleDelta: if @gesture is active, this function returns the zooming
	// difference since the gesture was recognized (hence the starting point is
	// considered 1:1). If @gesture is not active, 1 is returned.
	ScaleDelta() float64
}

type gestureZoom struct {
	gesture
}

func wrapGestureZoom(obj *externglib.Object) GestureZoom {
	return gestureZoom{gesture{eventController{*externglib.Object{obj}}}}
}

func marshalGestureZoom(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewGestureZoom() GestureZoom

func (g gestureZoom) ScaleDelta() float64

// Grid: gtkGrid is a container which arranges its child widgets in rows and
// columns, with arbitrary positions and horizontal/vertical spans.
//
// Children are added using gtk_grid_attach(). They can span multiple rows or
// columns. It is also possible to add a child next to an existing child, using
// gtk_grid_attach_next_to(). To remove a child from the grid, use
// gtk_grid_remove(). The behaviour of GtkGrid when several children occupy the
// same grid cell is undefined.
//
//
// CSS nodes
//
// GtkGrid uses a single CSS node with name `grid`.
//
//
// Accessibility
//
// GtkGrid uses the GTK_ACCESSIBLE_ROLE_GROUP role.
type Grid interface {
	Widget

	// Attach: adds a widget to the grid.
	//
	// The position of @child is determined by @column and @row. The number of
	// “cells” that @child will occupy is determined by @width and @height.
	Attach(child Widget, column int, row int, width int, height int)
	// AttachNextTo: adds a widget to the grid.
	//
	// The widget is placed next to @sibling, on the side determined by @side.
	// When @sibling is nil, the widget is placed in row (for left or right
	// placement) or column 0 (for top or bottom placement), at the end
	// indicated by @side.
	//
	// Attaching widgets labeled [1], [2], [3] with @sibling == nil and @side ==
	// GTK_POS_LEFT yields a layout of [3][2][1].
	AttachNextTo(child Widget, sibling Widget, side PositionType, width int, height int)
	// BaselineRow: returns which row defines the global baseline of @grid.
	BaselineRow() int
	// ChildAt: gets the child of @grid whose area covers the grid cell at
	// @column, @row.
	ChildAt(column int, row int) Widget
	// ColumnHomogeneous: returns whether all columns of @grid have the same
	// width.
	ColumnHomogeneous() bool
	// ColumnSpacing: returns the amount of space between the columns of @grid.
	ColumnSpacing() uint
	// RowBaselinePosition: returns the baseline position of @row as set by
	// gtk_grid_set_row_baseline_position() or the default value
	// GTK_BASELINE_POSITION_CENTER.
	RowBaselinePosition(row int) BaselinePosition
	// RowHomogeneous: returns whether all rows of @grid have the same height.
	RowHomogeneous() bool
	// RowSpacing: returns the amount of space between the rows of @grid.
	RowSpacing() uint
	// InsertColumn: inserts a column at the specified position.
	//
	// Children which are attached at or to the right of this position are moved
	// one column to the right. Children which span across this position are
	// grown to span the new column.
	InsertColumn(position int)
	// InsertNextTo: inserts a row or column at the specified position.
	//
	// The new row or column is placed next to @sibling, on the side determined
	// by @side. If @side is GTK_POS_TOP or GTK_POS_BOTTOM, a row is inserted.
	// If @side is GTK_POS_LEFT of GTK_POS_RIGHT, a column is inserted.
	InsertNextTo(sibling Widget, side PositionType)
	// InsertRow: inserts a row at the specified position.
	//
	// Children which are attached at or below this position are moved one row
	// down. Children which span across this position are grown to span the new
	// row.
	InsertRow(position int)
	// QueryChild: queries the attach points and spans of @child inside the
	// given Grid.
	QueryChild(child Widget) (column int, row int, width int, height int)
	// Remove: removes a child from @grid, after it has been added with
	// gtk_grid_attach() or gtk_grid_attach_next_to().
	Remove(child Widget)
	// RemoveColumn: removes a column from the grid.
	//
	// Children that are placed in this column are removed, spanning children
	// that overlap this column have their width reduced by one, and children
	// after the column are moved to the left.
	RemoveColumn(position int)
	// RemoveRow: removes a row from the grid.
	//
	// Children that are placed in this row are removed, spanning children that
	// overlap this row have their height reduced by one, and children below the
	// row are moved up.
	RemoveRow(position int)
	// SetBaselineRow: sets which row defines the global baseline for the entire
	// grid. Each row in the grid can have its own local baseline, but only one
	// of those is global, meaning it will be the baseline in the parent of the
	// @grid.
	SetBaselineRow(row int)
	// SetColumnHomogeneous: sets whether all columns of @grid will have the
	// same width.
	SetColumnHomogeneous(homogeneous bool)
	// SetColumnSpacing: sets the amount of space between columns of @grid.
	SetColumnSpacing(spacing uint)
	// SetRowBaselinePosition: sets how the baseline should be positioned on
	// @row of the grid, in case that row is assigned more space than is
	// requested.
	SetRowBaselinePosition(row int, pos BaselinePosition)
	// SetRowHomogeneous: sets whether all rows of @grid will have the same
	// height.
	SetRowHomogeneous(homogeneous bool)
	// SetRowSpacing: sets the amount of space between rows of @grid.
	SetRowSpacing(spacing uint)
}

type grid struct {
	widget
}

func wrapGrid(obj *externglib.Object) Grid {
	return grid{widget{externglib.InitiallyUnowned{obj}}}
}

func marshalGrid(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewGrid() Grid

func (g grid) Attach(child Widget, column int, row int, width int, height int)

func (g grid) AttachNextTo(child Widget, sibling Widget, side PositionType, width int, height int)

func (g grid) BaselineRow() int

func (g grid) ChildAt(column int, row int) Widget

func (g grid) ColumnHomogeneous() bool

func (g grid) ColumnSpacing() uint

func (g grid) RowBaselinePosition(row int) BaselinePosition

func (g grid) RowHomogeneous() bool

func (g grid) RowSpacing() uint

func (g grid) InsertColumn(position int)

func (g grid) InsertNextTo(sibling Widget, side PositionType)

func (g grid) InsertRow(position int)

func (g grid) QueryChild(child Widget) (column int, row int, width int, height int)

func (g grid) Remove(child Widget)

func (g grid) RemoveColumn(position int)

func (g grid) RemoveRow(position int)

func (g grid) SetBaselineRow(row int)

func (g grid) SetColumnHomogeneous(homogeneous bool)

func (g grid) SetColumnSpacing(spacing uint)

func (g grid) SetRowBaselinePosition(row int, pos BaselinePosition)

func (g grid) SetRowHomogeneous(homogeneous bool)

func (g grid) SetRowSpacing(spacing uint)

// GridLayout: gtkGridLayout is a layout manager which arranges child widgets in
// rows and columns, with arbitrary positions and horizontal/vertical spans.
//
// Children have an "attach point" defined by the horizontal and vertical index
// of the cell they occupy; children can span multiple rows or columns. The
// layout properties for setting the attach points and spans are set using the
// GridLayoutChild associated to each child widget.
//
// The behaviour of GtkGrid when several children occupy the same grid cell is
// undefined.
//
// GtkGridLayout can be used like a BoxLayout if all children are attached to
// the same row or column; however, if you only ever need a single row or
// column, you should consider using BoxLayout.
type GridLayout interface {
	LayoutManager

	// BaselineRow: retrieves the row set with
	// gtk_grid_layout_set_baseline_row().
	BaselineRow() int
	// ColumnHomogeneous: checks whether all columns of @grid should have the
	// same width.
	ColumnHomogeneous() bool
	// ColumnSpacing: retrieves the spacing set with
	// gtk_grid_layout_set_column_spacing().
	ColumnSpacing() uint
	// RowBaselinePosition: returns the baseline position of @row as set by
	// gtk_grid_layout_set_row_baseline_position(), or the default value of
	// GTK_BASELINE_POSITION_CENTER.
	RowBaselinePosition(row int) BaselinePosition
	// RowHomogeneous: checks whether all rows of @grid should have the same
	// height.
	RowHomogeneous() bool
	// RowSpacing: retrieves the spacing set with
	// gtk_grid_layout_set_row_spacing().
	RowSpacing() uint
	// SetBaselineRow: sets which row defines the global baseline for the entire
	// grid.
	//
	// Each row in the grid can have its own local baseline, but only one of
	// those is global, meaning it will be the baseline in the parent of the
	// @grid.
	SetBaselineRow(row int)
	// SetColumnHomogeneous: sets whether all columns of @grid should have the
	// same width.
	SetColumnHomogeneous(homogeneous bool)
	// SetColumnSpacing: sets the amount of space to insert between consecutive
	// columns.
	SetColumnSpacing(spacing uint)
	// SetRowBaselinePosition: sets how the baseline should be positioned on
	// @row of the grid, in case that row is assigned more space than is
	// requested.
	SetRowBaselinePosition(row int, pos BaselinePosition)
	// SetRowHomogeneous: sets whether all rows of @grid should have the same
	// height.
	SetRowHomogeneous(homogeneous bool)
	// SetRowSpacing: sets the amount of space to insert between consecutive
	// rows.
	SetRowSpacing(spacing uint)
}

type gridLayout struct {
	layoutManager
}

func wrapGridLayout(obj *externglib.Object) GridLayout {
	return gridLayout{layoutManager{*externglib.Object{obj}}}
}

func marshalGridLayout(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewGridLayout() GridLayout

func (g gridLayout) BaselineRow() int

func (g gridLayout) ColumnHomogeneous() bool

func (g gridLayout) ColumnSpacing() uint

func (g gridLayout) RowBaselinePosition(row int) BaselinePosition

func (g gridLayout) RowHomogeneous() bool

func (g gridLayout) RowSpacing() uint

func (g gridLayout) SetBaselineRow(row int)

func (g gridLayout) SetColumnHomogeneous(homogeneous bool)

func (g gridLayout) SetColumnSpacing(spacing uint)

func (g gridLayout) SetRowBaselinePosition(row int, pos BaselinePosition)

func (g gridLayout) SetRowHomogeneous(homogeneous bool)

func (g gridLayout) SetRowSpacing(spacing uint)

// GridLayoutChild: layout properties for children of GridLayout.
type GridLayoutChild interface {
	LayoutChild

	// Column: retrieves the column number to which @child attaches its left
	// side.
	Column() int
	// ColumnSpan: retrieves the number of columns that @child spans to.
	ColumnSpan() int
	// Row: retrieves the row number to which @child attaches its top side.
	Row() int
	// RowSpan: retrieves the number of rows that @child spans to.
	RowSpan() int
	// SetColumn: sets the column number to attach the left side of @child.
	SetColumn(column int)
	// SetColumnSpan: sets the number of columns @child spans to.
	SetColumnSpan(span int)
	// SetRow: sets the row to place @child in.
	SetRow(row int)
	// SetRowSpan: sets the number of rows @child spans to.
	SetRowSpan(span int)
}

type gridLayoutChild struct {
	layoutChild
}

func wrapGridLayoutChild(obj *externglib.Object) GridLayoutChild {
	return gridLayoutChild{layoutChild{*externglib.Object{obj}}}
}

func marshalGridLayoutChild(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func (g gridLayoutChild) Column() int

func (g gridLayoutChild) ColumnSpan() int

func (g gridLayoutChild) Row() int

func (g gridLayoutChild) RowSpan() int

func (g gridLayoutChild) SetColumn(column int)

func (g gridLayoutChild) SetColumnSpan(span int)

func (g gridLayoutChild) SetRow(row int)

func (g gridLayoutChild) SetRowSpan(span int)

// GridView: gtkGridView is a widget to present a view into a large dynamic grid
// of items.
//
// GtkGridView uses its factory to generate one child widget for each visible
// item and shows them in a grid. The orientation of the grid view determines if
// the grid reflows vertically or horizontally.
//
// GtkGridView allows the user to select items according to the selection
// characteristics of the model. For models that allow multiple selected items,
// it is possible to turn on _rubberband selection_, using
// GridView:enable-rubberband.
//
// To learn more about the list widget framework, see the [overview](Widget).
//
// CSS nodes
//
//    gridview
//    ├── child
//    │
//    ├── child
//    │
//    ┊
//    ╰── [rubberband]
//
// GtkGridView uses a single CSS node with name gridview. Each child uses a
// single CSS node with name child. For rubberband selection, a subnode with
// name rubberband is used.
//
//
// Accessibility
//
// GtkGridView uses the K_ACCESSIBLE_ROLE_GRID role, and the items use the
// K_ACCESSIBLE_ROLE_GRID_CELL role.
type GridView interface {
	ListBase

	// EnableRubberband: returns whether rows can be selected by dragging with
	// the mouse.
	EnableRubberband() bool
	// Factory: gets the factory that's currently used to populate list items.
	Factory() ListItemFactory
	// MaxColumns: gets the maximum number of columns that the grid will use.
	MaxColumns() uint
	// MinColumns: gets the minimum number of columns that the grid will use.
	MinColumns() uint
	// Model: gets the model that's currently used to read the items displayed.
	Model() SelectionModel
	// SingleClickActivate: returns whether items will be activated on single
	// click and selected on hover.
	SingleClickActivate() bool
	// SetEnableRubberband: sets whether selections can be changed by dragging
	// with the mouse.
	SetEnableRubberband(enableRubberband bool)
	// SetFactory: sets the ListItemFactory to use for populating list items.
	SetFactory(factory ListItemFactory)
	// SetMaxColumns: sets the maximum number of columns to use. This number
	// must be at least 1.
	//
	// If @max_columns is smaller than the minimum set via
	// gtk_grid_view_set_min_columns(), that value is used instead.
	SetMaxColumns(maxColumns uint)
	// SetMinColumns: sets the minimum number of columns to use. This number
	// must be at least 1.
	//
	// If @min_columns is smaller than the minimum set via
	// gtk_grid_view_set_max_columns(), that value is ignored.
	SetMinColumns(minColumns uint)
	// SetModel: sets the SelectionModel to use for
	SetModel(model SelectionModel)
	// SetSingleClickActivate: sets whether items should be activated on single
	// click and selected on hover.
	SetSingleClickActivate(singleClickActivate bool)
}

type gridView struct {
	listBase
}

func wrapGridView(obj *externglib.Object) GridView {
	return gridView{listBase{widget{externglib.InitiallyUnowned{obj}}}}
}

func marshalGridView(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewGridView(model SelectionModel, factory ListItemFactory) GridView

func (g gridView) EnableRubberband() bool

func (g gridView) Factory() ListItemFactory

func (g gridView) MaxColumns() uint

func (g gridView) MinColumns() uint

func (g gridView) Model() SelectionModel

func (g gridView) SingleClickActivate() bool

func (g gridView) SetEnableRubberband(enableRubberband bool)

func (g gridView) SetFactory(factory ListItemFactory)

func (g gridView) SetMaxColumns(maxColumns uint)

func (g gridView) SetMinColumns(minColumns uint)

func (g gridView) SetModel(model SelectionModel)

func (g gridView) SetSingleClickActivate(singleClickActivate bool)

// HeaderBar: gtkHeaderBar is similar to a horizontal Box. It allows children to
// be placed at the start or the end. In addition, it allows the window title to
// be displayed. The title will be centered with respect to the width of the
// box, even if the children at either side take up different amounts of space.
//
// GtkHeaderBar can add typical window frame controls, such as minimize,
// maximize and close buttons, or the window icon.
//
// For these reasons, GtkHeaderBar is the natural choice for use as the custom
// titlebar widget of a Window (see gtk_window_set_titlebar()), as it gives
// features typical of titlebars while allowing the addition of child widgets.
//
// The GtkHeaderBar implementation of the Buildable interface supports adding
// children at the start or end sides by specifying “start” or “end” as the
// “type” attribute of a <child> element, or setting the title widget by
// specifying “title” value.
//
// By default the GtkHeaderBar uses a Label displaying the title of the window
// it is contained in as the title widget, equivalent to the following UI
// definition:
//
//
//    <object class="GtkHeaderBar">
//      <property name="title-widget">
//        <object class="GtkLabel">
//          <property name="label" translatable="yes">Label</property>
//          <property name="single-line-mode">True</property>
//          <property name="ellipsize">end</property>
//          <property name="width-chars">5</property>
//          <style>
//            <class name="title"/>
//          </style>
//        </object>
//      </property>
//    </object>
//
// CSS nodes
//
//    headerbar
//    ╰── windowhandle
//        ╰── box
//            ├── box.start
//            │   ├── windowcontrols.start
//            │   ╰── [other children]
//            ├── [Title Widget]
//            ╰── box.end
//                ├── [other children]
//                ╰── windowcontrols.end
//
// A HeaderBar's CSS node is called `headerbar`. It contains a `windowhandle`
// subnode, which contains a `box` subnode, which contains two `box` subnodes at
// the start and end of the header bar, as well as a center node that represents
// the title.
//
// Each of the boxes contains a `windowcontrols` subnode, see WindowControls for
// details, as well as other children.
//
//
// Accessibility
//
// GtkHeaderBar uses the GTK_ACCESSIBLE_ROLE_GROUP role.
type HeaderBar interface {
	Widget

	// DecorationLayout: gets the decoration layout set with
	// gtk_header_bar_set_decoration_layout().
	DecorationLayout() string
	// ShowTitleButtons: returns whether this header bar shows the standard
	// window title buttons.
	ShowTitleButtons() bool
	// TitleWidget: retrieves the title widget of the header. See
	// gtk_header_bar_set_title_widget().
	TitleWidget() Widget
	// PackEnd: adds @child to @bar, packed with reference to the end of the
	// @bar.
	PackEnd(child Widget)
	// PackStart: adds @child to @bar, packed with reference to the start of the
	// @bar.
	PackStart(child Widget)
	// Remove: removes a child from @bar, after it has been added with
	// gtk_header_bar_pack_start(), gtk_header_bar_pack_end() or
	// gtk_header_bar_set_title_widget().
	Remove(child Widget)
	// SetDecorationLayout: sets the decoration layout for this header bar,
	// overriding the Settings:gtk-decoration-layout setting.
	//
	// There can be valid reasons for overriding the setting, such as a header
	// bar design that does not allow for buttons to take room on the right, or
	// only offers room for a single close button. Split header bars are another
	// example for overriding the setting.
	//
	// The format of the string is button names, separated by commas. A colon
	// separates the buttons that should appear on the left from those on the
	// right. Recognized button names are minimize, maximize, close and icon
	// (the window icon).
	//
	// For example, “icon:minimize,maximize,close” specifies a icon on the left,
	// and minimize, maximize and close buttons on the right.
	SetDecorationLayout(layout string)
	// SetShowTitleButtons: sets whether this header bar shows the standard
	// window title buttons including close, maximize, and minimize.
	SetShowTitleButtons(setting bool)
	// SetTitleWidget: sets the title for the HeaderBar.
	//
	// When set to nil, the headerbar will display the title of the window it is
	// contained in.
	//
	// The title should help a user identify the current view. To achieve the
	// same style as the builtin title, use the “title” style class.
	//
	// You should set the title widget to nil, for the window title label to be
	// visible again.
	SetTitleWidget(titleWidget Widget)
}

type headerBar struct {
	widget
}

func wrapHeaderBar(obj *externglib.Object) HeaderBar {
	return headerBar{widget{externglib.InitiallyUnowned{obj}}}
}

func marshalHeaderBar(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewHeaderBar() HeaderBar

func (h headerBar) DecorationLayout() string

func (h headerBar) ShowTitleButtons() bool

func (h headerBar) TitleWidget() Widget

func (h headerBar) PackEnd(child Widget)

func (h headerBar) PackStart(child Widget)

func (h headerBar) Remove(child Widget)

func (h headerBar) SetDecorationLayout(layout string)

func (h headerBar) SetShowTitleButtons(setting bool)

func (h headerBar) SetTitleWidget(titleWidget Widget)

// IMContext defines the interface for GTK input methods. An input method is
// used by GTK text input widgets like Entry to map from key events to Unicode
// character strings.
//
// The default input method can be set programmatically via the
// Settings:gtk-im-module GtkSettings property. Alternatively, you may set the
// GTK_IM_MODULE environment variable as documented in [Running GTK
// Applications][gtk-running].
//
// The Entry Entry:im-module and TextView TextView:im-module properties may also
// be used to set input methods for specific widget instances. For instance, a
// certain entry widget might be expected to contain certain characters which
// would be easier to input with a certain input method.
//
// An input method may consume multiple key events in sequence and finally
// output the composed result. This is called preediting, and an input method
// may provide feedback about this process by displaying the intermediate
// composition states as preedit text. For instance, the default GTK input
// method implements the input of arbitrary Unicode code points by holding down
// the Control and Shift keys and then typing “U” followed by the hexadecimal
// digits of the code point. When releasing the Control and Shift keys,
// preediting ends and the character is inserted as text. Ctrl+Shift+u20AC for
// example results in the € sign.
//
// Additional input methods can be made available for use by GTK widgets as
// loadable modules. An input method module is a small shared library which
// implements a subclass of IMContext or IMContextSimple and exports these four
// functions:
//
//    void im_module_init(GTypeModule *module);
//    ]|
//    This function should register the #GType of the IMContext subclass which
//    implements the input method by means of g_type_module_register_type(). Note
//    that g_type_register_static() cannot be used as the type needs to be
//    registered dynamically.
//
//    void im_module_exit(void);
//    ]|
//    Here goes any cleanup code your input method might require on module unload.
//
//    void im_module_list(const GtkIMContextInfo ***contexts, int *n_contexts)
//    {
//      *contexts = info_list;
//      *n_contexts = G_N_ELEMENTS (info_list);
//    }
//    ]|
//    This function returns the list of input methods provided by the module. The
//    example implementation above shows a common solution and simply returns a
//    pointer to statically defined array of IMContextInfo items for each
//    provided input method.
//
//    GtkIMContext * im_module_create(const char *context_id);
//    ]|
//    This function should return a pointer to a newly created instance of the
//    IMContext subclass identified by @context_id. The context ID is the same
//    as specified in the IMContextInfo array returned by im_module_list().
//
// After a new loadable input method module has been installed on the system,
// the configuration file `gtk.immodules` needs to be regenerated by
// [gtk-query-immodules-3.0][gtk-query-immodules-3.0], in order for the new
// input method to become available to GTK applications.
type IMContext interface {
	gextras.Objector

	// DeleteSurrounding: asks the widget that the input context is attached to
	// delete characters around the cursor position by emitting the
	// GtkIMContext::delete_surrounding signal. Note that @offset and @n_chars
	// are in characters not in bytes which differs from the usage other places
	// in IMContext.
	//
	// In order to use this function, you should first call
	// gtk_im_context_get_surrounding() to get the current context, and call
	// this function immediately afterwards to make sure that you know what you
	// are deleting. You should also account for the fact that even if the
	// signal was handled, the input context might not have deleted all the
	// characters that were requested to be deleted.
	//
	// This function is used by an input method that wants to make subsitutions
	// in the existing text in response to new input. It is not useful for
	// applications.
	DeleteSurrounding(offset int, nChars int) bool
	// FilterKey: allow an input method to forward key press and release events
	// to another input method, without necessarily having a GdkEvent available.
	FilterKey(press bool, surface gdk.Surface, device gdk.Device, time uint32, keycode uint, state gdk.ModifierType, group int) bool
	// FilterKeypress: allow an input method to internally handle key press and
	// release events. If this function returns true, then no further processing
	// should be done for this key event.
	FilterKeypress(event gdk.Event) bool
	// FocusIn: notify the input method that the widget to which this input
	// context corresponds has gained focus. The input method may, for example,
	// change the displayed feedback to reflect this change.
	FocusIn()
	// FocusOut: notify the input method that the widget to which this input
	// context corresponds has lost focus. The input method may, for example,
	// change the displayed feedback or reset the contexts state to reflect this
	// change.
	FocusOut()
	// PreeditString: retrieve the current preedit string for the input context,
	// and a list of attributes to apply to the string. This string should be
	// displayed inserted at the insertion point.
	PreeditString() (str string, attrs *pango.AttrList, cursorPos int)
	// Surrounding: retrieves context around the insertion point. Input methods
	// typically want context in order to constrain input text based on existing
	// text; this is important for languages such as Thai where only some
	// sequences of characters are allowed.
	//
	// This function is implemented by emitting the
	// GtkIMContext::retrieve_surrounding signal on the input method; in
	// response to this signal, a widget should provide as much context as is
	// available, up to an entire paragraph, by calling
	// gtk_im_context_set_surrounding(). Note that there is no obligation for a
	// widget to respond to the ::retrieve_surrounding signal, so input methods
	// must be prepared to function without context.
	Surrounding() (text string, cursorIndex int, ok bool)
	// Reset: notify the input method that a change such as a change in cursor
	// position has been made. This will typically cause the input method to
	// clear the preedit state.
	Reset()
	// SetClientWidget: set the client window for the input context; this is the
	// Widget holding the input focus. This widget is used in order to correctly
	// position status windows, and may also be used for purposes internal to
	// the input method.
	SetClientWidget(widget Widget)
	// SetCursorLocation: notify the input method that a change in cursor
	// position has been made. The location is relative to the client window.
	SetCursorLocation(area *gdk.Rectangle)
	// SetSurrounding: sets surrounding context around the insertion point and
	// preedit string. This function is expected to be called in response to the
	// GtkIMContext::retrieve_surrounding signal, and will likely have no effect
	// if called at other times.
	SetSurrounding(text string, len int, cursorIndex int)
	// SetUsePreedit: sets whether the IM context should use the preedit string
	// to display feedback. If @use_preedit is FALSE (default is TRUE), then the
	// IM context may use some other method to display feedback, such as
	// displaying it in a child of the root window.
	SetUsePreedit(usePreedit bool)
}

type imContext struct {
	*externglib.Object
}

func wrapIMContext(obj *externglib.Object) IMContext {
	return imContext{*externglib.Object{obj}}
}

func marshalIMContext(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func (i imContext) DeleteSurrounding(offset int, nChars int) bool

func (i imContext) FilterKey(press bool, surface gdk.Surface, device gdk.Device, time uint32, keycode uint, state gdk.ModifierType, group int) bool

func (i imContext) FilterKeypress(event gdk.Event) bool

func (i imContext) FocusIn()

func (i imContext) FocusOut()

func (i imContext) PreeditString() (str string, attrs *pango.AttrList, cursorPos int)

func (i imContext) Surrounding() (text string, cursorIndex int, ok bool)

func (i imContext) Reset()

func (i imContext) SetClientWidget(widget Widget)

func (i imContext) SetCursorLocation(area *gdk.Rectangle)

func (i imContext) SetSurrounding(text string, len int, cursorIndex int)

func (i imContext) SetUsePreedit(usePreedit bool)

// IMContextSimple: gtkIMContextSimple is a simple input method context
// supporting table-based input methods. It has a built-in table of compose
// sequences that is derived from the X11 Compose files.
//
// GtkIMContextSimple reads additional compose sequences from the first of the
// following files that is found: ~/.config/gtk-4.0/Compose, ~/.XCompose,
// /usr/share/X11/locale/$locale/Compose (for locales that have a nontrivial
// Compose file). The syntax of these files is described in the Compose(5)
// manual page.
//
//
// Unicode characters
//
// GtkIMContextSimple also supports numeric entry of Unicode characters by
// typing Ctrl-Shift-u, followed by a hexadecimal Unicode codepoint. For
// example, Ctrl-Shift-u 1 2 3 Enter yields U+0123 LATIN SMALL LETTER G WITH
// CEDILLA, i.e. ģ.
type IMContextSimple interface {
	IMContext

	// AddComposeFile: adds an additional table from the X11 compose file.
	AddComposeFile(composeFile string)
	// AddTable: adds an additional table to search to the input context. Each
	// row of the table consists of @max_seq_len key symbols followed by two
	// #guint16 interpreted as the high and low words of a #gunicode value.
	// Tables are searched starting from the last added.
	//
	// The table must be sorted in dictionary order on the numeric value of the
	// key symbol fields. (Values beyond the length of the sequence should be
	// zero.)
	AddTable(data []uint16, maxSeqLen int, nSeqs int)
}

type imContextSimple struct {
	imContext
}

func wrapIMContextSimple(obj *externglib.Object) IMContextSimple {
	return imContextSimple{imContext{*externglib.Object{obj}}}
}

func marshalIMContextSimple(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewIMContextSimple() IMContextSimple

func (i imContextSimple) AddComposeFile(composeFile string)

func (i imContextSimple) AddTable(data []uint16, maxSeqLen int, nSeqs int)

type IMMulticontext interface {
	IMContext

	// ContextID: gets the id of the currently active delegate of the @context.
	ContextID() string
	// SetContextID: sets the context id for @context.
	//
	// This causes the currently active delegate of @context to be replaced by
	// the delegate corresponding to the new context id.
	SetContextID(contextID string)
}

type imMulticontext struct {
	imContext
}

func wrapIMMulticontext(obj *externglib.Object) IMMulticontext {
	return imMulticontext{imContext{*externglib.Object{obj}}}
}

func marshalIMMulticontext(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewIMMulticontext() IMMulticontext

func (i imMulticontext) ContextID() string

func (i imMulticontext) SetContextID(contextID string)

// IconPaintable: contains information found when looking up an icon in an icon
// theme and supports painting it as a Paintable.
type IconPaintable interface {
	gextras.Objector

	// File: gets the #GFile that was used to load the icon, or nil if the icon
	// was not loaded from a file.
	File() gio.File
	// IconName: get the icon name being used for this icon.
	//
	// When an icon looked up in the icon theme was not available, the icon
	// theme may use fallback icons - either those specified to
	// gtk_icon_theme_lookup_icon() or the always-available "image-missing". The
	// icon chosen is returned by this function.
	//
	// If the icon was created without an icon theme, this function returns nil.
	IconName() string
	// IsSymbolic: checks if the icon is symbolic or not. This currently uses
	// only the file name and not the file contents for determining this. This
	// behaviour may change in the future.
	//
	// Note that to render a symbolic IconPaintable properly (with recoloring),
	// you have to set its icon name on a Image.
	IsSymbolic() bool
}

type iconPaintable struct {
	*externglib.Object
}

func wrapIconPaintable(obj *externglib.Object) IconPaintable {
	return iconPaintable{*externglib.Object{obj}}
}

func marshalIconPaintable(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewIconPaintable(file gio.File, size int, scale int) IconPaintable

func (i iconPaintable) File() gio.File

func (i iconPaintable) IconName() string

func (i iconPaintable) IsSymbolic() bool

// IconTheme provides a facility for looking up icons by name and size. The main
// reason for using a name rather than simply providing a filename is to allow
// different icons to be used depending on what “icon theme” is selected by the
// user. The operation of icon themes on Linux and Unix follows the [Icon Theme
// Specification](http://www.freedesktop.org/Standards/icon-theme-spec) There is
// a fallback icon theme, named `hicolor`, where applications should install
// their icons, but additional icon themes can be installed as operating system
// vendors and users choose.
//
// In many cases, named themes are used indirectly, via Image rather than
// directly, but looking up icons directly is also simple. The IconTheme object
// acts as a database of all the icons in the current theme. You can create new
// IconTheme objects, but it’s much more efficient to use the standard icon
// theme of the Widget so that the icon information is shared with other people
// looking up icons. |[<!-- language="C" --> GtkIconTheme *icon_theme;
// GtkIconPaintable *icon; GdkPaintable *paintable;
//
//    icon_theme = gtk_icon_theme_get_for_display (gtk_widget_get_display (my_widget));
//    icon = gtk_icon_theme_lookup_icon (icon_theme,
//                                       "my-icon-name", // icon name
//                                       48, // icon size
//                                       1,  // scale
//                                       0,  // flags);
//     paintable = GDK_PAINTABLE (icon);
//     // Use the paintable
//     g_object_unref (icon);
//
type IconTheme interface {
	gextras.Objector

	// AddResourcePath: adds a resource path that will be looked at when looking
	// for icons, similar to search paths.
	//
	// See gtk_icon_theme_set_resource_path().
	//
	// This function should be used to make application-specific icons available
	// as part of the icon theme.
	AddResourcePath(path string)
	// AddSearchPath: appends a directory to the search path. See
	// gtk_icon_theme_set_search_path().
	AddSearchPath(path string)
	// Display: returns the display that the GtkIconTheme object was created
	// for.
	Display() gdk.Display
	// IconNames: lists the names of icons in the current icon theme.
	IconNames() []string
	// IconSizes: returns an array of integers describing the sizes at which the
	// icon is available without scaling. A size of -1 means that the icon is
	// available in a scalable format. The array is zero-terminated.
	IconSizes(iconName string) []int
	// ResourcePath: gets the current resource path.
	//
	// See gtk_icon_theme_set_resource_path().
	ResourcePath() []string
	// SearchPath: gets the current search path. See
	// gtk_icon_theme_set_search_path().
	SearchPath() []string
	// ThemeName: gets the current icon theme name.
	//
	// Returns (transfer full): the current icon theme name,
	ThemeName() string
	// HasIcon: checks whether an icon theme includes an icon for a particular
	// name.
	HasIcon(iconName string) bool
	// LookupByGicon: looks up a icon for a desired size and window scale,
	// returning a IconPaintable. The icon can then be rendered by using it as a
	// Paintable, or you can get information such as the filename and size.
	LookupByGicon(icon gio.Icon, size int, scale int, direction TextDirection, flags IconLookupFlags) IconPaintable
	// LookupIcon: looks up a named icon for a desired size and window scale,
	// returning a IconPaintable. The icon can then be rendered by using it as a
	// Paintable, or you can get information such as the filename and size.
	//
	// If the available @icon_name is not available and @fallbacks are provided,
	// they will be tried in order.
	//
	// If no matching icon is found, then a paintable that renders the "missing
	// icon" icon is returned. If you need to do something else for missing
	// icons you need to use gtk_icon_theme_has_icon().
	//
	// Note that you probably want to listen for icon theme changes and update
	// the icon. This is usually done by overriding the
	// WidgetClass.css-changed() function.
	LookupIcon(iconName string, fallbacks []string, size int, scale int, direction TextDirection, flags IconLookupFlags) IconPaintable
	// SetResourcePath: sets the resource paths that will be looked at when
	// looking for icons, similar to search paths.
	//
	// The resources are considered as part of the hicolor icon theme and must
	// be located in subdirectories that are defined in the hicolor icon theme,
	// such as `@path/16x16/actions/run.png` or
	// `@path/scalable/actions/run.svg`.
	//
	// Icons that are directly placed in the resource path instead of a
	// subdirectory are also considered as ultimate fallback, but they are
	// treated like unthemed icons.
	SetResourcePath(path string)
	// SetSearchPath: sets the search path for the icon theme object. When
	// looking for an icon theme, GTK will search for a subdirectory of one or
	// more of the directories in @path with the same name as the icon theme
	// containing an index.theme file. (Themes from multiple of the path
	// elements are combined to allow themes to be extended by adding icons in
	// the user’s home directory.)
	//
	// In addition if an icon found isn’t found either in the current icon theme
	// or the default icon theme, and an image file with the right name is found
	// directly in one of the elements of @path, then that image will be used
	// for the icon name. (This is legacy feature, and new icons should be put
	// into the fallback icon theme, which is called hicolor, rather than
	// directly on the icon path.)
	SetSearchPath(path []string)
	// SetThemeName: sets the name of the icon theme that the IconTheme object
	// uses overriding system configuration. This function cannot be called on
	// the icon theme objects returned from gtk_icon_theme_get_for_display().
	SetThemeName(themeName string)
}

type iconTheme struct {
	*externglib.Object
}

func wrapIconTheme(obj *externglib.Object) IconTheme {
	return iconTheme{*externglib.Object{obj}}
}

func marshalIconTheme(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewIconTheme() IconTheme

func (i iconTheme) AddResourcePath(path string)

func (i iconTheme) AddSearchPath(path string)

func (i iconTheme) Display() gdk.Display

func (i iconTheme) IconNames() []string

func (i iconTheme) IconSizes(iconName string) []int

func (i iconTheme) ResourcePath() []string

func (i iconTheme) SearchPath() []string

func (i iconTheme) ThemeName() string

func (i iconTheme) HasIcon(iconName string) bool

func (i iconTheme) LookupByGicon(icon gio.Icon, size int, scale int, direction TextDirection, flags IconLookupFlags) IconPaintable

func (i iconTheme) LookupIcon(iconName string, fallbacks []string, size int, scale int, direction TextDirection, flags IconLookupFlags) IconPaintable

func (i iconTheme) SetResourcePath(path string)

func (i iconTheme) SetSearchPath(path []string)

func (i iconTheme) SetThemeName(themeName string)

// IconView provides an alternative view on a TreeModel. It displays the model
// as a grid of icons with labels. Like TreeView, it allows to select one or
// multiple items (depending on the selection mode, see
// gtk_icon_view_set_selection_mode()). In addition to selection with the arrow
// keys, IconView supports rubberband selection, which is controlled by dragging
// the pointer.
//
// Note that if the tree model is backed by an actual tree store (as opposed to
// a flat list where the mapping to icons is obvious), IconView will only
// display the first level of the tree and ignore the tree’s branches.
//
// CSS nodes
//
//    iconview.view
//    ╰── [rubberband]
//
// GtkIconView has a single CSS node with name iconview and style class .view.
// For rubberband selection, a subnode with name rubberband is used.
type IconView interface {
	Widget

	// CreateDragIcon: creates a #cairo_surface_t representation of the item at
	// @path. This image is used for a drag icon.
	CreateDragIcon(path *TreePath) gdk.Paintable
	// EnableModelDragDest: turns @icon_view into a drop destination for
	// automatic DND. Calling this method sets IconView:reorderable to false.
	EnableModelDragDest(formats *gdk.ContentFormats, actions gdk.DragAction)
	// EnableModelDragSource: turns @icon_view into a drag source for automatic
	// DND. Calling this method sets IconView:reorderable to false.
	EnableModelDragSource(startButtonMask gdk.ModifierType, formats *gdk.ContentFormats, actions gdk.DragAction)
	// ActivateOnSingleClick: gets the setting set by
	// gtk_icon_view_set_activate_on_single_click().
	ActivateOnSingleClick() bool
	// CellRect: fills the bounding rectangle in widget coordinates for the cell
	// specified by @path and @cell. If @cell is nil the main cell area is used.
	//
	// This function is only valid if @icon_view is realized.
	CellRect(path *TreePath, cell CellRenderer) (rect gdk.Rectangle, ok bool)
	// ColumnSpacing: returns the value of the ::column-spacing property.
	ColumnSpacing() int
	// Columns: returns the value of the ::columns property.
	Columns() int
	// Cursor: fills in @path and @cell with the current cursor path and cell.
	// If the cursor isn’t currently set, then *@path will be nil. If no cell
	// currently has focus, then *@cell will be nil.
	//
	// The returned TreePath must be freed with gtk_tree_path_free().
	Cursor() (path *TreePath, cell CellRenderer, ok bool)
	// DestItemAtPos: determines the destination item for a given position.
	DestItemAtPos(dragX int, dragY int) (path *TreePath, pos IconViewDropPosition, ok bool)
	// DragDestItem: gets information about the item that is highlighted for
	// feedback.
	DragDestItem() (path *TreePath, pos IconViewDropPosition)
	// ItemAtPos: gets the path and cell for the icon at the given position.
	ItemAtPos(x int, y int) (path *TreePath, cell CellRenderer, ok bool)
	// ItemColumn: gets the column in which the item @path is currently
	// displayed. Column numbers start at 0.
	ItemColumn(path *TreePath) int
	// ItemOrientation: returns the value of the ::item-orientation property
	// which determines whether the labels are drawn beside the icons instead of
	// below.
	ItemOrientation() Orientation
	// ItemPadding: returns the value of the ::item-padding property.
	ItemPadding() int
	// ItemRow: gets the row in which the item @path is currently displayed. Row
	// numbers start at 0.
	ItemRow(path *TreePath) int
	// ItemWidth: returns the value of the ::item-width property.
	ItemWidth() int
	// Margin: returns the value of the ::margin property.
	Margin() int
	// MarkupColumn: returns the column with markup text for @icon_view.
	MarkupColumn() int
	// Model: returns the model the IconView is based on. Returns nil if the
	// model is unset.
	Model() TreeModel
	// PathAtPos: gets the path for the icon at the given position.
	PathAtPos(x int, y int) *TreePath
	// PixbufColumn: returns the column with pixbufs for @icon_view.
	PixbufColumn() int
	// Reorderable: retrieves whether the user can reorder the list via
	// drag-and-drop. See gtk_icon_view_set_reorderable().
	Reorderable() bool
	// RowSpacing: returns the value of the ::row-spacing property.
	RowSpacing() int
	// SelectedItems: creates a list of paths of all selected items.
	// Additionally, if you are planning on modifying the model after calling
	// this function, you may want to convert the returned list into a list of
	// TreeRowReferences. To do this, you can use gtk_tree_row_reference_new().
	//
	//    g_list_free_full (list, (GDestroyNotify) gtk_tree_path_free);
	SelectedItems() *glib.List
	// SelectionMode: gets the selection mode of the @icon_view.
	SelectionMode() SelectionMode
	// Spacing: returns the value of the ::spacing property.
	Spacing() int
	// TextColumn: returns the column with text for @icon_view.
	TextColumn() int
	// TooltipColumn: returns the column of @icon_view’s model which is being
	// used for displaying tooltips on @icon_view’s rows.
	TooltipColumn() int
	// TooltipContext: this function is supposed to be used in a
	// Widget::query-tooltip signal handler for IconView. The @x, @y and
	// @keyboard_tip values which are received in the signal handler, should be
	// passed to this function without modification.
	//
	// The return value indicates whether there is an icon view item at the
	// given coordinates (true) or not (false) for mouse tooltips. For keyboard
	// tooltips the item returned will be the cursor item. When true, then any
	// of @model, @path and @iter which have been provided will be set to point
	// to that row and the corresponding model.
	TooltipContext(x int, y int, keyboardTip bool) (model TreeModel, path *TreePath, iter TreeIter, ok bool)
	// VisibleRange: sets @start_path and @end_path to be the first and last
	// visible path. Note that there may be invisible paths in between.
	//
	// Both paths should be freed with gtk_tree_path_free() after use.
	VisibleRange() (startPath *TreePath, endPath *TreePath, ok bool)
	// ItemActivated: activates the item determined by @path.
	ItemActivated(path *TreePath)
	// PathIsSelected: returns true if the icon pointed to by @path is currently
	// selected. If @path does not point to a valid location, false is returned.
	PathIsSelected(path *TreePath) bool
	// ScrollToPath: moves the alignments of @icon_view to the position
	// specified by @path. @row_align determines where the row is placed, and
	// @col_align determines where @column is placed. Both are expected to be
	// between 0.0 and 1.0. 0.0 means left/top alignment, 1.0 means right/bottom
	// alignment, 0.5 means center.
	//
	// If @use_align is false, then the alignment arguments are ignored, and the
	// tree does the minimum amount of work to scroll the item onto the screen.
	// This means that the item will be scrolled to the edge closest to its
	// current position. If the item is currently visible on the screen, nothing
	// is done.
	//
	// This function only works if the model is set, and @path is a valid row on
	// the model. If the model changes before the @icon_view is realized, the
	// centered path will be modified to reflect this change.
	ScrollToPath(path *TreePath, useAlign bool, rowAlign float32, colAlign float32)
	// SelectAll: selects all the icons. @icon_view must has its selection mode
	// set to K_SELECTION_MULTIPLE.
	SelectAll()
	// SelectPath: selects the row at @path.
	SelectPath(path *TreePath)
	// SelectedForeach: calls a function for each selected icon. Note that the
	// model or selection cannot be modified from within this function.
	SelectedForeach(_func IconViewForeachFunc)
	// SetActivateOnSingleClick: causes the IconView::item-activated signal to
	// be emitted on a single click instead of a double click.
	SetActivateOnSingleClick(single bool)
	// SetColumnSpacing: sets the ::column-spacing property which specifies the
	// space which is inserted between the columns of the icon view.
	SetColumnSpacing(columnSpacing int)
	// SetColumns: sets the ::columns property which determines in how many
	// columns the icons are arranged. If @columns is -1, the number of columns
	// will be chosen automatically to fill the available area.
	SetColumns(columns int)
	// SetCursor: sets the current keyboard focus to be at @path, and selects
	// it. This is useful when you want to focus the user’s attention on a
	// particular item. If @cell is not nil, then focus is given to the cell
	// specified by it. Additionally, if @start_editing is true, then editing
	// should be started in the specified cell.
	//
	// This function is often followed by `gtk_widget_grab_focus (icon_view)` in
	// order to give keyboard focus to the widget. Please note that editing can
	// only happen when the widget is realized.
	SetCursor(path *TreePath, cell CellRenderer, startEditing bool)
	// SetDragDestItem: sets the item that is highlighted for feedback.
	SetDragDestItem(path *TreePath, pos IconViewDropPosition)
	// SetItemOrientation: sets the ::item-orientation property which determines
	// whether the labels are drawn beside the icons instead of below.
	SetItemOrientation(orientation Orientation)
	// SetItemPadding: sets the IconView:item-padding property which specifies
	// the padding around each of the icon view’s items.
	SetItemPadding(itemPadding int)
	// SetItemWidth: sets the ::item-width property which specifies the width to
	// use for each item. If it is set to -1, the icon view will automatically
	// determine a suitable item size.
	SetItemWidth(itemWidth int)
	// SetMargin: sets the ::margin property which specifies the space which is
	// inserted at the top, bottom, left and right of the icon view.
	SetMargin(margin int)
	// SetMarkupColumn: sets the column with markup information for @icon_view
	// to be @column. The markup column must be of type TYPE_STRING. If the
	// markup column is set to something, it overrides the text column set by
	// gtk_icon_view_set_text_column().
	SetMarkupColumn(column int)
	// SetModel: sets the model for a IconView. If the @icon_view already has a
	// model set, it will remove it before setting the new model. If @model is
	// nil, then it will unset the old model.
	SetModel(model TreeModel)
	// SetPixbufColumn: sets the column with pixbufs for @icon_view to be
	// @column. The pixbuf column must be of type K_TYPE_PIXBUF
	SetPixbufColumn(column int)
	// SetReorderable: this function is a convenience function to allow you to
	// reorder models that support the TreeDragSourceIface and the
	// TreeDragDestIface. Both TreeStore and ListStore support these. If
	// @reorderable is true, then the user can reorder the model by dragging and
	// dropping rows. The developer can listen to these changes by connecting to
	// the model's row_inserted and row_deleted signals. The reordering is
	// implemented by setting up the icon view as a drag source and destination.
	// Therefore, drag and drop can not be used in a reorderable view for any
	// other purpose.
	//
	// This function does not give you any degree of control over the order --
	// any reordering is allowed. If more control is needed, you should probably
	// handle drag and drop manually.
	SetReorderable(reorderable bool)
	// SetRowSpacing: sets the ::row-spacing property which specifies the space
	// which is inserted between the rows of the icon view.
	SetRowSpacing(rowSpacing int)
	// SetSelectionMode: sets the selection mode of the @icon_view.
	SetSelectionMode(mode SelectionMode)
	// SetSpacing: sets the ::spacing property which specifies the space which
	// is inserted between the cells (i.e. the icon and the text) of an item.
	SetSpacing(spacing int)
	// SetTextColumn: sets the column with text for @icon_view to be @column.
	// The text column must be of type TYPE_STRING.
	SetTextColumn(column int)
	// SetTooltipCell: sets the tip area of @tooltip to the area which @cell
	// occupies in the item pointed to by @path. See also
	// gtk_tooltip_set_tip_area().
	//
	// See also gtk_icon_view_set_tooltip_column() for a simpler alternative.
	SetTooltipCell(tooltip Tooltip, path *TreePath, cell CellRenderer)
	// SetTooltipColumn: if you only plan to have simple (text-only) tooltips on
	// full items, you can use this function to have IconView handle these
	// automatically for you. @column should be set to the column in
	// @icon_view’s model containing the tooltip texts, or -1 to disable this
	// feature.
	//
	// When enabled, Widget:has-tooltip will be set to true and @icon_view will
	// connect a Widget::query-tooltip signal handler.
	//
	// Note that the signal handler sets the text with gtk_tooltip_set_markup(),
	// so &, <, etc have to be escaped in the text.
	SetTooltipColumn(column int)
	// SetTooltipItem: sets the tip area of @tooltip to be the area covered by
	// the item at @path. See also gtk_icon_view_set_tooltip_column() for a
	// simpler alternative. See also gtk_tooltip_set_tip_area().
	SetTooltipItem(tooltip Tooltip, path *TreePath)
	// UnselectAll: unselects all the icons.
	UnselectAll()
	// UnselectPath: unselects the row at @path.
	UnselectPath(path *TreePath)
	// UnsetModelDragDest: undoes the effect of
	// gtk_icon_view_enable_model_drag_dest(). Calling this method sets
	// IconView:reorderable to false.
	UnsetModelDragDest()
	// UnsetModelDragSource: undoes the effect of
	// gtk_icon_view_enable_model_drag_source(). Calling this method sets
	// IconView:reorderable to false.
	UnsetModelDragSource()
}

type iconView struct {
	widget
}

func wrapIconView(obj *externglib.Object) IconView {
	return iconView{widget{externglib.InitiallyUnowned{obj}}}
}

func marshalIconView(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewIconView() IconView

func NewIconView(area CellArea) IconView

func NewIconView(model TreeModel) IconView

func (i iconView) CreateDragIcon(path *TreePath) gdk.Paintable

func (i iconView) EnableModelDragDest(formats *gdk.ContentFormats, actions gdk.DragAction)

func (i iconView) EnableModelDragSource(startButtonMask gdk.ModifierType, formats *gdk.ContentFormats, actions gdk.DragAction)

func (i iconView) ActivateOnSingleClick() bool

func (i iconView) CellRect(path *TreePath, cell CellRenderer) (rect gdk.Rectangle, ok bool)

func (i iconView) ColumnSpacing() int

func (i iconView) Columns() int

func (i iconView) Cursor() (path *TreePath, cell CellRenderer, ok bool)

func (i iconView) DestItemAtPos(dragX int, dragY int) (path *TreePath, pos IconViewDropPosition, ok bool)

func (i iconView) DragDestItem() (path *TreePath, pos IconViewDropPosition)

func (i iconView) ItemAtPos(x int, y int) (path *TreePath, cell CellRenderer, ok bool)

func (i iconView) ItemColumn(path *TreePath) int

func (i iconView) ItemOrientation() Orientation

func (i iconView) ItemPadding() int

func (i iconView) ItemRow(path *TreePath) int

func (i iconView) ItemWidth() int

func (i iconView) Margin() int

func (i iconView) MarkupColumn() int

func (i iconView) Model() TreeModel

func (i iconView) PathAtPos(x int, y int) *TreePath

func (i iconView) PixbufColumn() int

func (i iconView) Reorderable() bool

func (i iconView) RowSpacing() int

func (i iconView) SelectedItems() *glib.List

func (i iconView) SelectionMode() SelectionMode

func (i iconView) Spacing() int

func (i iconView) TextColumn() int

func (i iconView) TooltipColumn() int

func (i iconView) TooltipContext(x int, y int, keyboardTip bool) (model TreeModel, path *TreePath, iter TreeIter, ok bool)

func (i iconView) VisibleRange() (startPath *TreePath, endPath *TreePath, ok bool)

func (i iconView) ItemActivated(path *TreePath)

func (i iconView) PathIsSelected(path *TreePath) bool

func (i iconView) ScrollToPath(path *TreePath, useAlign bool, rowAlign float32, colAlign float32)

func (i iconView) SelectAll()

func (i iconView) SelectPath(path *TreePath)

func (i iconView) SelectedForeach(_func IconViewForeachFunc)

func (i iconView) SetActivateOnSingleClick(single bool)

func (i iconView) SetColumnSpacing(columnSpacing int)

func (i iconView) SetColumns(columns int)

func (i iconView) SetCursor(path *TreePath, cell CellRenderer, startEditing bool)

func (i iconView) SetDragDestItem(path *TreePath, pos IconViewDropPosition)

func (i iconView) SetItemOrientation(orientation Orientation)

func (i iconView) SetItemPadding(itemPadding int)

func (i iconView) SetItemWidth(itemWidth int)

func (i iconView) SetMargin(margin int)

func (i iconView) SetMarkupColumn(column int)

func (i iconView) SetModel(model TreeModel)

func (i iconView) SetPixbufColumn(column int)

func (i iconView) SetReorderable(reorderable bool)

func (i iconView) SetRowSpacing(rowSpacing int)

func (i iconView) SetSelectionMode(mode SelectionMode)

func (i iconView) SetSpacing(spacing int)

func (i iconView) SetTextColumn(column int)

func (i iconView) SetTooltipCell(tooltip Tooltip, path *TreePath, cell CellRenderer)

func (i iconView) SetTooltipColumn(column int)

func (i iconView) SetTooltipItem(tooltip Tooltip, path *TreePath)

func (i iconView) UnselectAll()

func (i iconView) UnselectPath(path *TreePath)

func (i iconView) UnsetModelDragDest()

func (i iconView) UnsetModelDragSource()

// Image: the Image widget displays an image. Various kinds of object can be
// displayed as an image; most typically, you would load a Texture from a file,
// and then display that. There’s a convenience function to do this,
// gtk_image_new_from_file(), used as follows: |[<!-- language="C" --> GtkWidget
// *image; image = gtk_image_new_from_file ("myfile.png"); ]| If the file isn’t
// loaded successfully, the image will contain a “broken image” icon similar to
// that used in many web browsers. If you want to handle errors in loading the
// file yourself, for example by displaying an error message, then load the
// image with gdk_texture_new_from_file(), then create the Image with
// gtk_image_new_from_paintable().
//
// Sometimes an application will want to avoid depending on external data files,
// such as image files. See the documentation of #GResource for details. In this
// case, the Image:resource, gtk_image_new_from_resource() and
// gtk_image_set_from_resource() should be used.
//
// GtkImage displays its image as an icon, with a size that is determined by the
// application. See Picture if you want to show an image at is actual size.
//
//
// CSS nodes
//
// GtkImage has a single CSS node with the name image. The style classes
// .normal-icons or .large-icons may appear, depending on the Image:icon-size
// property.
//
//
// Accessibility
//
// GtkImage uses the K_ACCESSIBLE_ROLE_IMG role.
type Image interface {
	Widget

	// Clear: resets the image to be empty.
	Clear()
	// Gicon: gets the #GIcon and size being displayed by the Image. The storage
	// type of the image must be GTK_IMAGE_EMPTY or GTK_IMAGE_GICON (see
	// gtk_image_get_storage_type()). The caller of this function does not own a
	// reference to the returned #GIcon.
	//
	// Note: This function was changed in 3.94 not to use out parameters
	// anymore, but return the GIcon directly. See gtk_image_get_icon_size() for
	// a way to get the icon size.
	Gicon() gio.Icon
	// IconName: gets the icon name and size being displayed by the Image. The
	// storage type of the image must be GTK_IMAGE_EMPTY or GTK_IMAGE_ICON_NAME
	// (see gtk_image_get_storage_type()). The returned string is owned by the
	// Image and should not be freed.
	//
	// Note: This function was changed in 3.94 not to use out parameters
	// anymore, but return the icon name directly. See gtk_image_get_icon_size()
	// for a way to get the icon size.
	IconName() string
	// IconSize: gets the icon size used by the @image when rendering icons.
	IconSize() IconSize
	// Paintable: gets the image Paintable being displayed by the Image. The
	// storage type of the image must be GTK_IMAGE_EMPTY or GTK_IMAGE_PAINTABLE
	// (see gtk_image_get_storage_type()). The caller of this function does not
	// own a reference to the returned paintable.
	Paintable() gdk.Paintable
	// PixelSize: gets the pixel size used for named icons.
	PixelSize() int
	// StorageType: gets the type of representation being used by the Image to
	// store image data. If the Image has no image data, the return value will
	// be GTK_IMAGE_EMPTY.
	StorageType() ImageType
	// SetFromFile: see gtk_image_new_from_file() for details.
	SetFromFile(filename string)
	// SetFromGicon: see gtk_image_new_from_gicon() for details.
	//
	// Note: Before 3.94, this function was taking an extra icon size argument.
	// See gtk_image_set_icon_size() for another way to set the icon size.
	SetFromGicon(icon gio.Icon)
	// SetFromIconName: see gtk_image_new_from_icon_name() for details.
	//
	// Note: Before 3.94, this function was taking an extra icon size argument.
	// See gtk_image_set_icon_size() for another way to set the icon size.
	SetFromIconName(iconName string)
	// SetFromPaintable: see gtk_image_new_from_paintable() for details.
	SetFromPaintable(paintable gdk.Paintable)
	// SetFromPixbuf: see gtk_image_new_from_pixbuf() for details.
	//
	// Note: This is a helper for gtk_image_set_from_paintable(), and you can't
	// get back the exact pixbuf once this is called, only a paintable.
	SetFromPixbuf(pixbuf gdkpixbuf.Pixbuf)
	// SetFromResource: see gtk_image_new_from_resource() for details.
	SetFromResource(resourcePath string)
	// SetIconSize: suggests an icon size to the theme for named icons.
	SetIconSize(iconSize IconSize)
	// SetPixelSize: sets the pixel size to use for named icons. If the pixel
	// size is set to a value != -1, it is used instead of the icon size set by
	// gtk_image_set_from_icon_name().
	SetPixelSize(pixelSize int)
}

type image struct {
	widget
}

func wrapImage(obj *externglib.Object) Image {
	return image{widget{externglib.InitiallyUnowned{obj}}}
}

func marshalImage(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewImage() Image

func NewImage(filename string) Image

func NewImage(icon gio.Icon) Image

func NewImage(iconName string) Image

func NewImage(paintable gdk.Paintable) Image

func NewImage(pixbuf gdkpixbuf.Pixbuf) Image

func NewImage(resourcePath string) Image

func (i image) Clear()

func (i image) Gicon() gio.Icon

func (i image) IconName() string

func (i image) IconSize() IconSize

func (i image) Paintable() gdk.Paintable

func (i image) PixelSize() int

func (i image) StorageType() ImageType

func (i image) SetFromFile(filename string)

func (i image) SetFromGicon(icon gio.Icon)

func (i image) SetFromIconName(iconName string)

func (i image) SetFromPaintable(paintable gdk.Paintable)

func (i image) SetFromPixbuf(pixbuf gdkpixbuf.Pixbuf)

func (i image) SetFromResource(resourcePath string)

func (i image) SetIconSize(iconSize IconSize)

func (i image) SetPixelSize(pixelSize int)

// InfoBar is a widget that can be used to show messages to the user without
// showing a dialog. It is often temporarily shown at the top or bottom of a
// document. In contrast to Dialog, which has an action area at the bottom,
// InfoBar has an action area at the side.
//
// The API of InfoBar is very similar to Dialog, allowing you to add buttons to
// the action area with gtk_info_bar_add_button() or
// gtk_info_bar_new_with_buttons(). The sensitivity of action widgets can be
// controlled with gtk_info_bar_set_response_sensitive().
//
// To add widgets to the main content area of a InfoBar, use
// gtk_info_bar_add_child().
//
// Similar to MessageDialog, the contents of a InfoBar can by classified as
// error message, warning, informational message, etc, by using
// gtk_info_bar_set_message_type(). GTK may use the message type to determine
// how the message is displayed.
//
// A simple example for using a InfoBar: |[<!-- language="C" --> GtkWidget
// *message_label; GtkWidget *widget; GtkWidget *grid; GtkInfoBar *bar;
//
// // set up info bar widget = gtk_info_bar_new (); bar = GTK_INFO_BAR (widget);
// // grid = gtk_grid_new ();
//
// message_label = gtk_label_new (""); gtk_info_bar_add_child (bar,
// message_label); gtk_info_bar_add_button (bar, _("_OK"), GTK_RESPONSE_OK);
// g_signal_connect (bar, "response", G_CALLBACK (gtk_widget_hide), NULL);
// gtk_grid_attach (GTK_GRID (grid), widget, 0, 2, 1, 1);
//
// // ...
//
//    // show an error message
//    gtk_label_set_text (GTK_LABEL (message_label), "An error occurred!");
//    gtk_info_bar_set_message_type (bar, GTK_MESSAGE_ERROR);
//    gtk_widget_show (bar);
//
//
//    # GtkInfoBar as GtkBuildable
//
//    The GtkInfoBar implementation of the GtkBuildable interface exposes
//    the content area and action area as internal children with the names
//    “content_area” and “action_area”.
//
//    GtkInfoBar supports a custom <action-widgets> element, which can contain
//    multiple <action-widget> elements. The “response” attribute specifies a
//    numeric response, and the content of the element is the id of widget
//    (which should be a child of the dialogs @action_area).
//
//    # CSS nodes
//
//    GtkInfoBar has a single CSS node with name infobar. The node may get
//    one of the style classes .info, .warning, .error or .question, depending
//    on the message type.
//    If the info bar shows a close button, that button will have the .close
//    style class applied.
type InfoBar interface {
	Widget

	// AddActionWidget: add an activatable widget to the action area of a
	// InfoBar, connecting a signal handler that will emit the InfoBar::response
	// signal on the message area when the widget is activated. The widget is
	// appended to the end of the message areas action area.
	AddActionWidget(child Widget, responseID int)
	// AddButton: adds a button with the given text and sets things up so that
	// clicking the button will emit the “response” signal with the given
	// response_id. The button is appended to the end of the info bars's action
	// area. The button widget is returned, but usually you don't need it.
	AddButton(buttonText string, responseID int) Widget
	// AddChild: adds a widget to the content area of the info bar.
	AddChild(widget Widget)
	// MessageType: returns the message type of the message area.
	MessageType() MessageType
	// Revealed: returns whether the info bar is currently revealed.
	Revealed() bool
	// ShowCloseButton: returns whether the widget will display a standard close
	// button.
	ShowCloseButton() bool
	// RemoveActionWidget: removes a widget from the action area of @info_bar,
	// after it been put there by a call to gtk_info_bar_add_action_widget() or
	// gtk_info_bar_add_button().
	RemoveActionWidget(widget Widget)
	// RemoveChild: removes a widget from the content area of the info bar,
	// after it has been added with gtk_info_bar_add_child().
	RemoveChild(widget Widget)
	// Response: emits the “response” signal with the given @response_id.
	Response(responseID int)
	// SetDefaultResponse: sets the last widget in the info bar’s action area
	// with the given response_id as the default widget for the dialog. Pressing
	// “Enter” normally activates the default widget.
	//
	// Note that this function currently requires @info_bar to be added to a
	// widget hierarchy.
	SetDefaultResponse(responseID int)
	// SetMessageType: sets the message type of the message area.
	//
	// GTK uses this type to determine how the message is displayed.
	SetMessageType(messageType MessageType)
	// SetResponseSensitive: calls gtk_widget_set_sensitive (widget, setting)
	// for each widget in the info bars’s action area with the given
	// response_id. A convenient way to sensitize/desensitize dialog buttons.
	SetResponseSensitive(responseID int, setting bool)
	// SetRevealed: sets the InfoBar:revealed property to @revealed. Changing
	// this will make @info_bar reveal (true) or conceal (false) itself via a
	// sliding transition.
	//
	// Note: this does not show or hide @info_bar in the Widget:visible sense,
	// so revealing has no effect if Widget:visible is false.
	SetRevealed(revealed bool)
	// SetShowCloseButton: if true, a standard close button is shown. When
	// clicked it emits the response GTK_RESPONSE_CLOSE.
	SetShowCloseButton(setting bool)
}

type infoBar struct {
	widget
}

func wrapInfoBar(obj *externglib.Object) InfoBar {
	return infoBar{widget{externglib.InitiallyUnowned{obj}}}
}

func marshalInfoBar(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewInfoBar() InfoBar

func (i infoBar) AddActionWidget(child Widget, responseID int)

func (i infoBar) AddButton(buttonText string, responseID int) Widget

func (i infoBar) AddChild(widget Widget)

func (i infoBar) MessageType() MessageType

func (i infoBar) Revealed() bool

func (i infoBar) ShowCloseButton() bool

func (i infoBar) RemoveActionWidget(widget Widget)

func (i infoBar) RemoveChild(widget Widget)

func (i infoBar) Response(responseID int)

func (i infoBar) SetDefaultResponse(responseID int)

func (i infoBar) SetMessageType(messageType MessageType)

func (i infoBar) SetResponseSensitive(responseID int, setting bool)

func (i infoBar) SetRevealed(revealed bool)

func (i infoBar) SetShowCloseButton(setting bool)

// KeyvalTrigger: a ShortcutTrigger that triggers when a specific keyval and
// (optionally) modifiers are pressed.
type KeyvalTrigger interface {
	ShortcutTrigger

	// Keyval: gets the keyval that must be pressed to succeed triggering @self.
	Keyval() uint
	// Modifiers: gets the modifiers that must be present to succeed triggering
	// @self.
	Modifiers() gdk.ModifierType
}

type keyvalTrigger struct {
	shortcutTrigger
}

func wrapKeyvalTrigger(obj *externglib.Object) KeyvalTrigger {
	return keyvalTrigger{shortcutTrigger{*externglib.Object{obj}}}
}

func marshalKeyvalTrigger(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewKeyvalTrigger(keyval uint, modifiers gdk.ModifierType) KeyvalTrigger

func (k keyvalTrigger) Keyval() uint

func (k keyvalTrigger) Modifiers() gdk.ModifierType

// Label: the Label widget displays a small amount of text. As the name implies,
// most labels are used to label another widget such as a Button.
//
// CSS nodes
//
//    label
//    ├── [selection]
//    ├── [link]
//    ┊
//    ╰── [link]
//
// GtkLabel has a single CSS node with the name label. A wide variety of style
// classes may be applied to labels, such as .title, .subtitle, .dim-label, etc.
// In the ShortcutsWindow, labels are used with the .keycap style class.
//
// If the label has a selection, it gets a subnode with name selection.
//
// If the label has links, there is one subnode per link. These subnodes carry
// the link or visited state depending on whether they have been visited. In
// this case, label node also gets a .link style class.
//
//
// GtkLabel as GtkBuildable
//
// The GtkLabel implementation of the GtkBuildable interface supports a custom
// <attributes> element, which supports any number of <attribute> elements. The
// <attribute> element has attributes named “name“, “value“, “start“ and “end“
// and allows you to specify Attribute values for this label.
//
//
//    <object class="GtkLabel">
//      <attributes>
//        <attribute name="weight" value="PANGO_WEIGHT_BOLD"/>
//        <attribute name="background" value="red" start="5" end="10"/>
//      </attributes>
//    </object>
//
// The start and end attributes specify the range of characters to which the
// Pango attribute applies. If start and end are not specified, the attribute is
// applied to the whole text. Note that specifying ranges does not make much
// sense with translatable attributes. Use markup embedded in the translatable
// content instead.
//
//
// Accessibility
//
// GtkLabel uses the K_ACCESSIBLE_ROLE_LABEL role.
//
//
// Mnemonics
//
// Labels may contain “mnemonics”. Mnemonics are underlined characters in the
// label, used for keyboard navigation. Mnemonics are created by providing a
// string with an underscore before the mnemonic character, such as `"_File"`,
// to the functions gtk_label_new_with_mnemonic() or
// gtk_label_set_text_with_mnemonic().
//
// Mnemonics automatically activate any activatable widget the label is inside,
// such as a Button; if the label is not inside the mnemonic’s target widget,
// you have to tell the label about the target using
// gtk_label_set_mnemonic_widget(). Here’s a simple example where the label is
// inside a button:
//
//    // Pressing Alt+H will activate this button
//    GtkWidget *button = gtk_button_new ();
//    GtkWidget *label = gtk_label_new_with_mnemonic ("_Hello");
//    gtk_button_set_child (GTK_BUTTON (button), label);
//
// There’s a convenience function to create buttons with a mnemonic label
// already inside:
//
//    // Pressing Alt+H will activate this button
//    GtkWidget *button = gtk_button_new_with_mnemonic ("_Hello");
//
// To create a mnemonic for a widget alongside the label, such as a Entry, you
// have to point the label at the entry with gtk_label_set_mnemonic_widget():
//
//    // Pressing Alt+H will focus the entry
//    GtkWidget *entry = gtk_entry_new ();
//    GtkWidget *label = gtk_label_new_with_mnemonic ("_Hello");
//    gtk_label_set_mnemonic_widget (GTK_LABEL (label), entry);
//
// Markup (styled text)
//
// To make it easy to format text in a label (changing colors, fonts, etc.),
// label text can be provided in a simple [markup format][PangoMarkupFormat].
//
//    GtkWidget *label = gtk_label_new (NULL);
//    gtk_label_set_markup (GTK_LABEL (label), "<small>Small text</small>");
//
// (See [complete documentation][PangoMarkupFormat] of available tags in the
// Pango manual.)
//
// The markup passed to gtk_label_set_markup() must be valid; for example,
// literal <, > and & characters must be escaped as &lt;, &gt;, and &amp;. If
// you pass text obtained from the user, file, or a network to
// gtk_label_set_markup(), you’ll want to escape it with g_markup_escape_text()
// or g_markup_printf_escaped().
//
// Markup strings are just a convenient way to set the AttrList on a label;
// gtk_label_set_attributes() may be a simpler way to set attributes in some
// cases. Be careful though; AttrList tends to cause internationalization
// problems, unless you’re applying attributes to the entire string (i.e. unless
// you set the range of each attribute to [0, G_MAXINT)). The reason is that
// specifying the start_index and end_index for a Attribute requires knowledge
// of the exact string being displayed, so translations will cause problems.
//
//
// Selectable labels
//
// Labels can be made selectable with gtk_label_set_selectable(). Selectable
// labels allow the user to copy the label contents to the clipboard. Only
// labels that contain useful-to-copy information — such as error messages —
// should be made selectable.
//
// Text layout {#label-text-layout}
//
// A label can contain any number of paragraphs, but will have performance
// problems if it contains more than a small number. Paragraphs are separated by
// newlines or other paragraph separators understood by Pango.
//
// Labels can automatically wrap text if you call gtk_label_set_wrap().
//
// gtk_label_set_justify() sets how the lines in a label align with one another.
// If you want to set how the label as a whole aligns in its available space,
// see the Widget:halign and Widget:valign properties.
//
// The Label:width-chars and Label:max-width-chars properties can be used to
// control the size allocation of ellipsized or wrapped labels. For ellipsizing
// labels, if either is specified (and less than the actual text size), it is
// used as the minimum width, and the actual text size is used as the natural
// width of the label. For wrapping labels, width-chars is used as the minimum
// width, if specified, and max-width-chars is used as the natural width. Even
// if max-width-chars specified, wrapping labels will be rewrapped to use all of
// the available width.
//
// Note that the interpretation of Label:width-chars and Label:max-width-chars
// has changed a bit with the introduction of [width-for-height geometry
// management.][geometry-management]
//
//
// Links
//
// GTK supports markup for clickable hyperlinks in addition to regular Pango
// markup. The markup for links is borrowed from HTML, using the `<a>` with
// “href“, “title“ and “class“ attributes. GTK renders links similar to the way
// they appear in web browsers, with colored, underlined text. The “title“
// attribute is displayed as a tooltip on the link. The “class“ attribute is
// used as style class on the CSS node for the link.
//
// An example looks like this:
//
//    const char *text =
//    "Go to the"
//    "<a href=\"http://www.gtk.org title=\"&lt;i&gt;Our&lt;/i&gt; website\">"
//    "GTK website</a> for more...";
//    GtkWidget *label = gtk_label_new (NULL);
//    gtk_label_set_markup (GTK_LABEL (label), text);
//
// It is possible to implement custom handling for links and their tooltips with
// the Label::activate-link signal and the gtk_label_get_current_uri() function.
type Label interface {
	Widget

	// Attributes: gets the attribute list that was set on the label using
	// gtk_label_set_attributes(), if any. This function does not reflect
	// attributes that come from the labels markup (see gtk_label_set_markup()).
	// If you want to get the effective attributes for the label, use
	// pango_layout_get_attribute (gtk_label_get_layout (self)).
	Attributes() *pango.AttrList
	// CurrentURI: returns the URI for the currently active link in the label.
	// The active link is the one under the mouse pointer or, in a selectable
	// label, the link in which the text cursor is currently positioned.
	//
	// This function is intended for use in a Label::activate-link handler or
	// for use in a Widget::query-tooltip handler.
	CurrentURI() string
	// Ellipsize: returns the ellipsizing position of the label. See
	// gtk_label_set_ellipsize().
	Ellipsize() pango.EllipsizeMode
	// ExtraMenu: gets the menu model set with gtk_label_set_extra_menu().
	ExtraMenu() gio.MenuModel
	// Justify: returns the justification of the label. See
	// gtk_label_set_justify().
	Justify() Justification
	// Label: fetches the text from a label widget including any embedded
	// underlines indicating mnemonics and Pango markup. (See
	// gtk_label_get_text()).
	Label() string
	// Layout: gets the Layout used to display the label. The layout is useful
	// to e.g. convert text positions to pixel positions, in combination with
	// gtk_label_get_layout_offsets(). The returned layout is owned by the
	// @label so need not be freed by the caller. The @label is free to recreate
	// its layout at any time, so it should be considered read-only.
	Layout() pango.Layout
	// LayoutOffsets: obtains the coordinates where the label will draw the
	// Layout representing the text in the label; useful to convert mouse events
	// into coordinates inside the Layout, e.g. to take some action if some part
	// of the label is clicked. Remember when using the Layout functions you
	// need to convert to and from pixels using PANGO_PIXELS() or NGO_SCALE.
	LayoutOffsets() (x int, y int)
	// Lines: gets the number of lines to which an ellipsized, wrapping label
	// should be limited. See gtk_label_set_lines().
	Lines() int
	// MaxWidthChars: retrieves the desired maximum width of @label, in
	// characters. See gtk_label_set_width_chars().
	MaxWidthChars() int
	// MnemonicKeyval: if the label has been set so that it has a mnemonic key
	// this function returns the keyval used for the mnemonic accelerator. If
	// there is no mnemonic set up it returns K_KEY_VoidSymbol.
	MnemonicKeyval() uint
	// MnemonicWidget: retrieves the target of the mnemonic (keyboard shortcut)
	// of this label. See gtk_label_set_mnemonic_widget().
	MnemonicWidget() Widget
	// Selectable: gets the value set by gtk_label_set_selectable().
	Selectable() bool
	// SelectionBounds: gets the selected range of characters in the label,
	// returning true if there’s a selection.
	SelectionBounds() (start int, end int, ok bool)
	// SingleLineMode: returns whether the label is in single line mode.
	SingleLineMode() bool
	// Text: fetches the text from a label widget, as displayed on the screen.
	// This does not include any embedded underlines indicating mnemonics or
	// Pango markup. (See gtk_label_get_label())
	Text() string
	// UseMarkup: returns whether the label’s text is interpreted as marked up
	// with the [Pango text markup language][PangoMarkupFormat]. See
	// gtk_label_set_use_markup ().
	UseMarkup() bool
	// UseUnderline: returns whether an embedded underline in the label
	// indicates a mnemonic. See gtk_label_set_use_underline().
	UseUnderline() bool
	// WidthChars: retrieves the desired width of @label, in characters. See
	// gtk_label_set_width_chars().
	WidthChars() int
	// Wrap: returns whether lines in the label are automatically wrapped. See
	// gtk_label_set_wrap().
	Wrap() bool
	// WrapMode: returns line wrap mode used by the label. See
	// gtk_label_set_wrap_mode().
	WrapMode() pango.WrapMode
	// Xalign: gets the Label:xalign property for @label.
	Xalign() float32
	// Yalign: gets the Label:yalign property for @label.
	Yalign() float32
	// SelectRegion: selects a range of characters in the label, if the label is
	// selectable. See gtk_label_set_selectable(). If the label is not
	// selectable, this function has no effect. If @start_offset or @end_offset
	// are -1, then the end of the label will be substituted.
	SelectRegion(startOffset int, endOffset int)
	// SetAttributes: sets a AttrList; the attributes in the list are applied to
	// the label text.
	//
	// The attributes set with this function will be applied and merged with any
	// other attributes previously effected by way of the Label:use-underline or
	// Label:use-markup properties. While it is not recommended to mix markup
	// strings with manually set attributes, if you must; know that the
	// attributes will be applied to the label after the markup string is
	// parsed.
	SetAttributes(attrs *pango.AttrList)
	// SetEllipsize: sets the mode used to ellipsize (add an ellipsis: "...") to
	// the text if there is not enough space to render the entire string.
	SetEllipsize(mode pango.EllipsizeMode)
	// SetExtraMenu: sets a menu model to add when constructing the context menu
	// for @label.
	SetExtraMenu(model gio.MenuModel)
	// SetJustify: sets the alignment of the lines in the text of the label
	// relative to each other. GTK_JUSTIFY_LEFT is the default value when the
	// widget is first created with gtk_label_new(). If you instead want to set
	// the alignment of the label as a whole, use gtk_widget_set_halign()
	// instead. gtk_label_set_justify() has no effect on labels containing only
	// a single line.
	SetJustify(jtype Justification)
	// SetLabel: sets the text of the label. The label is interpreted as
	// including embedded underlines and/or Pango markup depending on the values
	// of the Label:use-underline and Label:use-markup properties.
	SetLabel(str string)
	// SetLines: sets the number of lines to which an ellipsized, wrapping label
	// should be limited. This has no effect if the label is not wrapping or
	// ellipsized. Set this to -1 if you don’t want to limit the number of
	// lines.
	SetLines(lines int)
	// SetMarkup: parses @str which is marked up with the [Pango text markup
	// language][PangoMarkupFormat], setting the label’s text and attribute list
	// based on the parse results.
	//
	// If the @str is external data, you may need to escape it with
	// g_markup_escape_text() or g_markup_printf_escaped():
	//
	//    GtkWidget *self = gtk_label_new (NULL);
	//    const char *str = "...";
	//    const char *format = "<span style=\"italic\">\s</span>";
	//    char *markup;
	//
	//    markup = g_markup_printf_escaped (format, str);
	//    gtk_label_set_markup (GTK_LABEL (self), markup);
	//    g_free (markup);
	//
	//
	// This function will set the Label:use-markup property to true as a side
	// effect.
	//
	// If you set the label contents using the Label:label property you should
	// also ensure that you set the Label:use-markup property accordingly.
	//
	// See also: gtk_label_set_text()
	SetMarkup(str string)
	// SetMarkupWithMnemonic: parses @str which is marked up with the [Pango
	// text markup language][PangoMarkupFormat], setting the label’s text and
	// attribute list based on the parse results. If characters in @str are
	// preceded by an underscore, they are underlined indicating that they
	// represent a keyboard accelerator called a mnemonic.
	//
	// The mnemonic key can be used to activate another widget, chosen
	// automatically, or explicitly using gtk_label_set_mnemonic_widget().
	SetMarkupWithMnemonic(str string)
	// SetMaxWidthChars: sets the desired maximum width in characters of @label
	// to @n_chars.
	SetMaxWidthChars(nChars int)
	// SetMnemonicWidget: if the label has been set so that it has a mnemonic
	// key (using i.e. gtk_label_set_markup_with_mnemonic(),
	// gtk_label_set_text_with_mnemonic(), gtk_label_new_with_mnemonic() or the
	// “use_underline” property) the label can be associated with a widget that
	// is the target of the mnemonic. When the label is inside a widget (like a
	// Button or a Notebook tab) it is automatically associated with the correct
	// widget, but sometimes (i.e. when the target is a Entry next to the label)
	// you need to set it explicitly using this function.
	//
	// The target widget will be accelerated by emitting the
	// GtkWidget::mnemonic-activate signal on it. The default handler for this
	// signal will activate the widget if there are no mnemonic collisions and
	// toggle focus between the colliding widgets otherwise.
	SetMnemonicWidget(widget Widget)
	// SetSelectable: selectable labels allow the user to select text from the
	// label, for copy-and-paste.
	SetSelectable(setting bool)
	// SetSingleLineMode: sets whether the label is in single line mode.
	SetSingleLineMode(singleLineMode bool)
	// SetText: sets the text within the Label widget. It overwrites any text
	// that was there before.
	//
	// This function will clear any previously set mnemonic accelerators, and
	// set the Label:use-underline property to false as a side effect.
	//
	// This function will set the Label:use-markup property to false as a side
	// effect.
	//
	// See also: gtk_label_set_markup()
	SetText(str string)
	// SetTextWithMnemonic: sets the label’s text from the string @str. If
	// characters in @str are preceded by an underscore, they are underlined
	// indicating that they represent a keyboard accelerator called a mnemonic.
	// The mnemonic key can be used to activate another widget, chosen
	// automatically, or explicitly using gtk_label_set_mnemonic_widget().
	SetTextWithMnemonic(str string)
	// SetUseMarkup: sets whether the text of the label contains markup in
	// [Pango’s text markup language][PangoMarkupFormat]. See
	// gtk_label_set_markup().
	SetUseMarkup(setting bool)
	// SetUseUnderline: if true, an underline in the text indicates the next
	// character should be used for the mnemonic accelerator key.
	SetUseUnderline(setting bool)
	// SetWidthChars: sets the desired width in characters of @label to
	// @n_chars.
	SetWidthChars(nChars int)
	// SetWrap: toggles line wrapping within the Label widget. true makes it
	// break lines if text exceeds the widget’s size. false lets the text get
	// cut off by the edge of the widget if it exceeds the widget size.
	//
	// Note that setting line wrapping to true does not make the label wrap at
	// its parent container’s width, because GTK widgets conceptually can’t make
	// their requisition depend on the parent container’s size. For a label that
	// wraps at a specific position, set the label’s width using
	// gtk_widget_set_size_request().
	SetWrap(wrap bool)
	// SetWrapMode: if line wrapping is on (see gtk_label_set_wrap()) this
	// controls how the line wrapping is done. The default is PANGO_WRAP_WORD
	// which means wrap on word boundaries.
	SetWrapMode(wrapMode pango.WrapMode)
	// SetXalign: sets the Label:xalign property for @label.
	SetXalign(xalign float32)
	// SetYalign: sets the Label:yalign property for @label.
	SetYalign(yalign float32)
}

type label struct {
	widget
}

func wrapLabel(obj *externglib.Object) Label {
	return label{widget{externglib.InitiallyUnowned{obj}}}
}

func marshalLabel(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewLabel(str string) Label

func NewLabel(str string) Label

func (l label) Attributes() *pango.AttrList

func (l label) CurrentURI() string

func (l label) Ellipsize() pango.EllipsizeMode

func (l label) ExtraMenu() gio.MenuModel

func (l label) Justify() Justification

func (l label) Label() string

func (l label) Layout() pango.Layout

func (l label) LayoutOffsets() (x int, y int)

func (l label) Lines() int

func (l label) MaxWidthChars() int

func (l label) MnemonicKeyval() uint

func (l label) MnemonicWidget() Widget

func (l label) Selectable() bool

func (l label) SelectionBounds() (start int, end int, ok bool)

func (l label) SingleLineMode() bool

func (l label) Text() string

func (l label) UseMarkup() bool

func (l label) UseUnderline() bool

func (l label) WidthChars() int

func (l label) Wrap() bool

func (l label) WrapMode() pango.WrapMode

func (l label) Xalign() float32

func (l label) Yalign() float32

func (l label) SelectRegion(startOffset int, endOffset int)

func (l label) SetAttributes(attrs *pango.AttrList)

func (l label) SetEllipsize(mode pango.EllipsizeMode)

func (l label) SetExtraMenu(model gio.MenuModel)

func (l label) SetJustify(jtype Justification)

func (l label) SetLabel(str string)

func (l label) SetLines(lines int)

func (l label) SetMarkup(str string)

func (l label) SetMarkupWithMnemonic(str string)

func (l label) SetMaxWidthChars(nChars int)

func (l label) SetMnemonicWidget(widget Widget)

func (l label) SetSelectable(setting bool)

func (l label) SetSingleLineMode(singleLineMode bool)

func (l label) SetText(str string)

func (l label) SetTextWithMnemonic(str string)

func (l label) SetUseMarkup(setting bool)

func (l label) SetUseUnderline(setting bool)

func (l label) SetWidthChars(nChars int)

func (l label) SetWrap(wrap bool)

func (l label) SetWrapMode(wrapMode pango.WrapMode)

func (l label) SetXalign(xalign float32)

func (l label) SetYalign(yalign float32)

// LayoutChild is the base class for objects that are meant to hold layout
// properties. If a LayoutManager has per-child properties, like their packing
// type, or the horizontal and vertical span, or the icon name, then the layout
// manager should use a LayoutChild implementation to store those properties.
//
// A LayoutChild instance is only ever valid while a widget is part of a layout.
type LayoutChild interface {
	gextras.Objector

	// ChildWidget: retrieves the Widget associated to the given @layout_child.
	ChildWidget() Widget
	// LayoutManager: retrieves the LayoutManager instance that created the
	// given @layout_child.
	LayoutManager() LayoutManager
}

type layoutChild struct {
	*externglib.Object
}

func wrapLayoutChild(obj *externglib.Object) LayoutChild {
	return layoutChild{*externglib.Object{obj}}
}

func marshalLayoutChild(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func (l layoutChild) ChildWidget() Widget

func (l layoutChild) LayoutManager() LayoutManager

// LayoutManager: layout managers are delegate classes that handle the preferred
// size and the allocation of a container widget.
//
// You typically subclass LayoutManager if you want to implement a layout policy
// for the children of a widget, or if you want to determine the size of a
// widget depending on its contents.
//
// Each Widget can only have a LayoutManager instance associated to it at any
// given time; it is possible, though, to replace the layout manager instance
// using gtk_widget_set_layout_manager().
//
//
// Layout properties
//
// A layout manager can expose properties for controlling the layout of each
// child, by creating an object type derived from LayoutChild and installing the
// properties on it as normal GObject properties.
//
// Each LayoutChild instance storing the layout properties for a specific child
// is created through the gtk_layout_manager_get_layout_child() method; a
// LayoutManager controls the creation of its LayoutChild instances by
// overriding the GtkLayoutManagerClass.create_layout_child() virtual function.
// The typical implementation should look like:
//
//    static GtkLayoutChild *
//    create_layout_child (GtkLayoutManager *manager,
//                         GtkWidget        *container,
//                         GtkWidget        *child)
//    {
//      return g_object_new (your_layout_child_get_type (),
//                           "layout-manager", manager,
//                           "child-widget", child,
//                           NULL);
//    }
//
// The LayoutChild:layout-manager and LayoutChild:child-widget properties on the
// newly created LayoutChild instance are mandatory. The LayoutManager will
// cache the newly created LayoutChild instance until the widget is removed from
// its parent, or the parent removes the layout manager.
//
// Each LayoutManager instance creating a LayoutChild should use
// gtk_layout_manager_get_layout_child() every time it needs to query the layout
// properties; each LayoutChild instance should call
// gtk_layout_manager_layout_changed() every time a property is updated, in
// order to queue a new size measuring and allocation.
type LayoutManager interface {
	gextras.Objector

	// Allocate: this function assigns the given @width, @height, and @baseline
	// to a @widget, and computes the position and sizes of the children of the
	// @widget using the layout management policy of @manager.
	Allocate(widget Widget, width int, height int, baseline int)
	// LayoutChild: retrieves a LayoutChild instance for the LayoutManager,
	// creating one if necessary.
	//
	// The @child widget must be a child of the widget using @manager.
	//
	// The LayoutChild instance is owned by the LayoutManager, and is guaranteed
	// to exist as long as @child is a child of the Widget using the given
	// LayoutManager.
	LayoutChild(child Widget) LayoutChild
	// RequestMode: retrieves the request mode of @manager.
	RequestMode() SizeRequestMode
	// Widget: retrieves the Widget using the given LayoutManager.
	Widget() Widget
	// LayoutChanged: queues a resize on the Widget using @manager, if any.
	//
	// This function should be called by subclasses of LayoutManager in response
	// to changes to their layout management policies.
	LayoutChanged()
	// Measure: measures the size of the @widget using @manager, for the given
	// @orientation and size.
	//
	// See [GtkWidget's geometry management section][geometry-management] for
	// more details.
	Measure(widget Widget, orientation Orientation, forSize int) (minimum int, natural int, minimumBaseline int, naturalBaseline int)
}

type layoutManager struct {
	*externglib.Object
}

func wrapLayoutManager(obj *externglib.Object) LayoutManager {
	return layoutManager{*externglib.Object{obj}}
}

func marshalLayoutManager(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func (l layoutManager) Allocate(widget Widget, width int, height int, baseline int)

func (l layoutManager) LayoutChild(child Widget) LayoutChild

func (l layoutManager) RequestMode() SizeRequestMode

func (l layoutManager) Widget() Widget

func (l layoutManager) LayoutChanged()

func (l layoutManager) Measure(widget Widget, orientation Orientation, forSize int) (minimum int, natural int, minimumBaseline int, naturalBaseline int)

// LevelBar: the LevelBar is a bar widget that can be used as a level indicator.
// Typical use cases are displaying the strength of a password, or showing the
// charge level of a battery.
//
// Use gtk_level_bar_set_value() to set the current value, and
// gtk_level_bar_add_offset_value() to set the value offsets at which the bar
// will be considered in a different state. GTK will add a few offsets by
// default on the level bar: K_LEVEL_BAR_OFFSET_LOW, K_LEVEL_BAR_OFFSET_HIGH and
// K_LEVEL_BAR_OFFSET_FULL, with values 0.25, 0.75 and 1.0 respectively.
//
// Note that it is your responsibility to update preexisting offsets when
// changing the minimum or maximum value. GTK will simply clamp them to the new
// range.
//
// Adding a custom offset on the bar
//
//    <!-- language="C" -->
//
//    static GtkWidget *
//    create_level_bar (void)
//    {
//      GtkWidget *widget;
//      GtkLevelBar *bar;
//
//      widget = gtk_level_bar_new ();
//      bar = GTK_LEVEL_BAR (widget);
//
//      // This changes the value of the default low offset
//
//      gtk_level_bar_add_offset_value (bar,
//                                      GTK_LEVEL_BAR_OFFSET_LOW,
//                                      0.10);
//
//      // This adds a new offset to the bar; the application will
//      // be able to change its color CSS like this:
//      //
//      // levelbar block.my-offset {
//      //   background-color: magenta;
//      //   border-style: solid;
//      //   border-color: black;
//      //   border-style: 1px;
//      // }
//
//      gtk_level_bar_add_offset_value (bar, "my-offset", 0.60);
//
//      return widget;
//    }
//
//
// The default interval of values is between zero and one, but it’s possible to
// modify the interval using gtk_level_bar_set_min_value() and
// gtk_level_bar_set_max_value(). The value will be always drawn in proportion
// to the admissible interval, i.e. a value of 15 with a specified interval
// between 10 and 20 is equivalent to a value of 0.5 with an interval between 0
// and 1. When K_LEVEL_BAR_MODE_DISCRETE is used, the bar level is rendered as a
// finite number of separated blocks instead of a single one. The number of
// blocks that will be rendered is equal to the number of units specified by the
// admissible interval.
//
// For instance, to build a bar rendered with five blocks, it’s sufficient to
// set the minimum value to 0 and the maximum value to 5 after changing the
// indicator mode to discrete.
//
//
// GtkLevelBar as GtkBuildable
//
// The GtkLevelBar implementation of the GtkBuildable interface supports a
// custom <offsets> element, which can contain any number of <offset> elements,
// each of which must have name and value attributes.
//
// CSS nodes
//
//    levelbar[.discrete]
//    ╰── trough
//        ├── block.filled.level-name
//        ┊
//        ├── block.empty
//        ┊
//
// GtkLevelBar has a main CSS node with name levelbar and one of the style
// classes .discrete or .continuous and a subnode with name trough. Below the
// trough node are a number of nodes with name block and style class .filled or
// .empty. In continuous mode, there is exactly one node of each, in discrete
// mode, the number of filled and unfilled nodes corresponds to blocks that are
// drawn. The block.filled nodes also get a style class .level-name
// corresponding to the level for the current value.
//
// In horizontal orientation, the nodes are always arranged from left to right,
// regardless of text direction.
//
//
// Accessibility
//
// GtkLevelBar uses the K_ACCESSIBLE_ROLE_METER role.
type LevelBar interface {
	Widget

	// AddOffsetValue: adds a new offset marker on @self at the position
	// specified by @value. When the bar value is in the interval topped by
	// @value (or between @value and LevelBar:max-value in case the offset is
	// the last one on the bar) a style class named `level-`@name will be
	// applied when rendering the level bar fill. If another offset marker named
	// @name exists, its value will be replaced by @value.
	AddOffsetValue(name string, value float64)
	// Inverted: return the value of the LevelBar:inverted property.
	Inverted() bool
	// MaxValue: returns the value of the LevelBar:max-value property.
	MaxValue() float64
	// MinValue: returns the value of the LevelBar:min-value property.
	MinValue() float64
	// Mode: returns the value of the LevelBar:mode property.
	Mode() LevelBarMode
	// OffsetValue: fetches the value specified for the offset marker @name in
	// @self, returning true in case an offset named @name was found.
	OffsetValue(name string) (value float64, ok bool)
	// Value: returns the value of the LevelBar:value property.
	Value() float64
	// RemoveOffsetValue: removes an offset marker previously added with
	// gtk_level_bar_add_offset_value().
	RemoveOffsetValue(name string)
	// SetInverted: sets the value of the LevelBar:inverted property.
	SetInverted(inverted bool)
	// SetMaxValue: sets the value of the LevelBar:max-value property.
	//
	// You probably want to update preexisting level offsets after calling this
	// function.
	SetMaxValue(value float64)
	// SetMinValue: sets the value of the LevelBar:min-value property.
	//
	// You probably want to update preexisting level offsets after calling this
	// function.
	SetMinValue(value float64)
	// SetMode: sets the value of the LevelBar:mode property.
	SetMode(mode LevelBarMode)
	// SetValue: sets the value of the LevelBar:value property.
	SetValue(value float64)
}

type levelBar struct {
	widget
}

func wrapLevelBar(obj *externglib.Object) LevelBar {
	return levelBar{widget{externglib.InitiallyUnowned{obj}}}
}

func marshalLevelBar(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewLevelBar() LevelBar

func NewLevelBar(minValue float64, maxValue float64) LevelBar

func (l levelBar) AddOffsetValue(name string, value float64)

func (l levelBar) Inverted() bool

func (l levelBar) MaxValue() float64

func (l levelBar) MinValue() float64

func (l levelBar) Mode() LevelBarMode

func (l levelBar) OffsetValue(name string) (value float64, ok bool)

func (l levelBar) Value() float64

func (l levelBar) RemoveOffsetValue(name string)

func (l levelBar) SetInverted(inverted bool)

func (l levelBar) SetMaxValue(value float64)

func (l levelBar) SetMinValue(value float64)

func (l levelBar) SetMode(mode LevelBarMode)

func (l levelBar) SetValue(value float64)

// LinkButton: a GtkLinkButton is a Button with a hyperlink, similar to the one
// used by web browsers, which triggers an action when clicked. It is useful to
// show quick links to resources.
//
// A link button is created by calling either gtk_link_button_new() or
// gtk_link_button_new_with_label(). If using the former, the URI you pass to
// the constructor is used as a label for the widget.
//
// The URI bound to a GtkLinkButton can be set specifically using
// gtk_link_button_set_uri(), and retrieved using gtk_link_button_get_uri().
//
// By default, GtkLinkButton calls gtk_show_uri() when the button is clicked.
// This behaviour can be overridden by connecting to the
// LinkButton::activate-link signal and returning true from the signal handler.
//
//
// CSS nodes
//
// GtkLinkButton has a single CSS node with name button. To differentiate it
// from a plain Button, it gets the .link style class.
//
//
// Accessibility
//
// GtkLinkButton uses the K_ACCESSIBLE_ROLE_LINK role.
type LinkButton interface {
	Button

	// URI: retrieves the URI set using gtk_link_button_set_uri().
	URI() string
	// Visited: retrieves the “visited” state of the URI where the LinkButton
	// points. The button becomes visited when it is clicked. If the URI is
	// changed on the button, the “visited” state is unset again.
	//
	// The state may also be changed using gtk_link_button_set_visited().
	Visited() bool
	// SetURI: sets @uri as the URI where the LinkButton points. As a
	// side-effect this unsets the “visited” state of the button.
	SetURI(uri string)
	// SetVisited: sets the “visited” state of the URI where the LinkButton
	// points. See gtk_link_button_get_visited() for more details.
	SetVisited(visited bool)
}

type linkButton struct {
	button
}

func wrapLinkButton(obj *externglib.Object) LinkButton {
	return linkButton{button{widget{externglib.InitiallyUnowned{obj}}}}
}

func marshalLinkButton(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewLinkButton(uri string) LinkButton

func NewLinkButton(uri string, label string) LinkButton

func (l linkButton) URI() string

func (l linkButton) Visited() bool

func (l linkButton) SetURI(uri string)

func (l linkButton) SetVisited(visited bool)

// ListBase: gtkListBase is the abstract base class for GTK's list widgets.
type ListBase interface {
	Widget
}

type listBase struct {
	widget
}

func wrapListBase(obj *externglib.Object) ListBase {
	return listBase{widget{externglib.InitiallyUnowned{obj}}}
}

func marshalListBase(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// ListBox: a GtkListBox is a vertical container that contains GtkListBoxRow
// children. These rows can by dynamically sorted and filtered, and headers can
// be added dynamically depending on the row content. It also allows keyboard
// and mouse navigation and selection like a typical list.
//
// Using GtkListBox is often an alternative to TreeView, especially when the
// list contents has a more complicated layout than what is allowed by a
// CellRenderer, or when the contents is interactive (i.e. has a button in it).
//
// Although a ListBox must have only ListBoxRow children you can add any kind of
// widget to it via gtk_list_box_prepend(), gtk_list_box_append() and
// gtk_list_box_insert() and a ListBoxRow widget will automatically be inserted
// between the list and the widget.
//
// ListBoxRows can be marked as activatable or selectable. If a row is
// activatable, ListBox::row-activated will be emitted for it when the user
// tries to activate it. If it is selectable, the row will be marked as selected
// when the user tries to select it.
//
//
// GtkListBox as GtkBuildable
//
// The GtkListBox implementation of the Buildable interface supports setting a
// child as the placeholder by specifying “placeholder” as the “type” attribute
// of a <child> element. See gtk_list_box_set_placeholder() for info.
//
// CSS nodes
//
//    list[.separators][.rich-list][.navigation-sidebar]
//    ╰── row[.activatable]
//
// GtkListBox uses a single CSS node named list. It may carry the .separators
// style class, when the ListBox:show-separators property is set. Each
// GtkListBoxRow uses a single CSS node named row. The row nodes get the
// .activatable style class added when appropriate.
//
// The main list node may also carry style classes to select the style of [list
// presentation](ListContainers.html#list-styles): .rich-list,
// .navigation-sidebar or .data-table.
//
//
// Accessibility
//
// GtkListBox uses the K_ACCESSIBLE_ROLE_LIST role and GtkListBoxRow uses the
// K_ACCESSIBLE_ROLE_LIST_ITEM role.
type ListBox interface {
	Widget

	// Append: append a widget to the list. If a sort function is set, the
	// widget will actually be inserted at the calculated position.
	Append(child Widget)
	// BindModel: binds @model to @box.
	//
	// If @box was already bound to a model, that previous binding is destroyed.
	//
	// The contents of @box are cleared and then filled with widgets that
	// represent items from @model. @box is updated whenever @model changes. If
	// @model is nil, @box is left empty.
	//
	// It is undefined to add or remove widgets directly (for example, with
	// gtk_list_box_insert()) while @box is bound to a model.
	//
	// Note that using a model is incompatible with the filtering and sorting
	// functionality in GtkListBox. When using a model, filtering and sorting
	// should be implemented by the model.
	BindModel(model gio.ListModel, createWidgetFunc ListBoxCreateWidgetFunc)
	// DragHighlightRow: this is a helper function for implementing DnD onto a
	// ListBox. The passed in @row will be highlighted by setting the
	// K_STATE_FLAG_DROP_ACTIVE state and any previously highlighted row will be
	// unhighlighted.
	//
	// The row will also be unhighlighted when the widget gets a drag leave
	// event.
	DragHighlightRow(row ListBoxRow)
	// DragUnhighlightRow: if a row has previously been highlighted via
	// gtk_list_box_drag_highlight_row() it will have the highlight removed.
	DragUnhighlightRow()
	// ActivateOnSingleClick: returns whether rows activate on single clicks.
	ActivateOnSingleClick() bool
	// Adjustment: gets the adjustment (if any) that the widget uses to for
	// vertical scrolling.
	Adjustment() Adjustment
	// RowAtIndex: gets the n-th child in the list (not counting headers). If
	// @_index is negative or larger than the number of items in the list, nil
	// is returned.
	RowAtIndex(index_ int) ListBoxRow
	// RowAtY: gets the row at the @y position.
	RowAtY(y int) ListBoxRow
	// SelectedRow: gets the selected row.
	//
	// Note that the box may allow multiple selection, in which case you should
	// use gtk_list_box_selected_foreach() to find all selected rows.
	SelectedRow() ListBoxRow
	// SelectedRows: creates a list of all selected children.
	SelectedRows() *glib.List
	// SelectionMode: gets the selection mode of the listbox.
	SelectionMode() SelectionMode
	// ShowSeparators: returns whether the list box should show separators
	// between rows.
	ShowSeparators() bool
	// Insert: insert the @child into the @box at @position. If a sort function
	// is set, the widget will actually be inserted at the calculated position.
	//
	// If @position is -1, or larger than the total number of items in the @box,
	// then the @child will be appended to the end.
	Insert(child Widget, position int)
	// InvalidateFilter: update the filtering for all rows. Call this when
	// result of the filter function on the @box is changed due to an external
	// factor. For instance, this would be used if the filter function just
	// looked for a specific search string and the entry with the search string
	// has changed.
	InvalidateFilter()
	// InvalidateHeaders: update the separators for all rows. Call this when
	// result of the header function on the @box is changed due to an external
	// factor.
	InvalidateHeaders()
	// InvalidateSort: update the sorting for all rows. Call this when result of
	// the sort function on the @box is changed due to an external factor.
	InvalidateSort()
	// Prepend: prepend a widget to the list. If a sort function is set, the
	// widget will actually be inserted at the calculated position.
	Prepend(child Widget)
	// Remove: removes a child from @box.
	Remove(child Widget)
	// SelectAll: select all children of @box, if the selection mode allows it.
	SelectAll()
	// SelectRow: make @row the currently selected row.
	SelectRow(row ListBoxRow)
	// SelectedForeach: calls a function for each selected child.
	//
	// Note that the selection cannot be modified from within this function.
	SelectedForeach(_func ListBoxForeachFunc)
	// SetActivateOnSingleClick: if @single is true, rows will be activated when
	// you click on them, otherwise you need to double-click.
	SetActivateOnSingleClick(single bool)
	// SetAdjustment: sets the adjustment (if any) that the widget uses to for
	// vertical scrolling. For instance, this is used to get the page size for
	// PageUp/Down key handling.
	//
	// In the normal case when the @box is packed inside a ScrolledWindow the
	// adjustment from that will be picked up automatically, so there is no need
	// to manually do that.
	SetAdjustment(adjustment Adjustment)
	// SetFilterFunc: by setting a filter function on the @box one can decide
	// dynamically which of the rows to show. For instance, to implement a
	// search function on a list that filters the original list to only show the
	// matching rows.
	//
	// The @filter_func will be called for each row after the call, and it will
	// continue to be called each time a row changes (via
	// gtk_list_box_row_changed()) or when gtk_list_box_invalidate_filter() is
	// called.
	//
	// Note that using a filter function is incompatible with using a model (see
	// gtk_list_box_bind_model()).
	SetFilterFunc(filterFunc ListBoxFilterFunc)
	// SetHeaderFunc: by setting a header function on the @box one can
	// dynamically add headers in front of rows, depending on the contents of
	// the row and its position in the list. For instance, one could use it to
	// add headers in front of the first item of a new kind, in a list sorted by
	// the kind.
	//
	// The @update_header can look at the current header widget using
	// gtk_list_box_row_get_header() and either update the state of the widget
	// as needed, or set a new one using gtk_list_box_row_set_header(). If no
	// header is needed, set the header to nil.
	//
	// Note that you may get many calls @update_header to this for a particular
	// row when e.g. changing things that don’t affect the header. In this case
	// it is important for performance to not blindly replace an existing header
	// with an identical one.
	//
	// The @update_header function will be called for each row after the call,
	// and it will continue to be called each time a row changes (via
	// gtk_list_box_row_changed()) and when the row before changes (either by
	// gtk_list_box_row_changed() on the previous row, or when the previous row
	// becomes a different row). It is also called for all rows when
	// gtk_list_box_invalidate_headers() is called.
	SetHeaderFunc(updateHeader ListBoxUpdateHeaderFunc)
	// SetPlaceholder: sets the placeholder widget that is shown in the list
	// when it doesn't display any visible children.
	SetPlaceholder(placeholder Widget)
	// SetSelectionMode: sets how selection works in the listbox. See
	// SelectionMode for details.
	SetSelectionMode(mode SelectionMode)
	// SetShowSeparators: sets whether the list box should show separators
	// between rows.
	SetShowSeparators(showSeparators bool)
	// SetSortFunc: by setting a sort function on the @box one can dynamically
	// reorder the rows of the list, based on the contents of the rows.
	//
	// The @sort_func will be called for each row after the call, and will
	// continue to be called each time a row changes (via
	// gtk_list_box_row_changed()) and when gtk_list_box_invalidate_sort() is
	// called.
	//
	// Note that using a sort function is incompatible with using a model (see
	// gtk_list_box_bind_model()).
	SetSortFunc(sortFunc ListBoxSortFunc)
	// UnselectAll: unselect all children of @box, if the selection mode allows
	// it.
	UnselectAll()
	// UnselectRow: unselects a single row of @box, if the selection mode allows
	// it.
	UnselectRow(row ListBoxRow)
}

type listBox struct {
	widget
}

func wrapListBox(obj *externglib.Object) ListBox {
	return listBox{widget{externglib.InitiallyUnowned{obj}}}
}

func marshalListBox(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewListBox() ListBox

func (l listBox) Append(child Widget)

func (l listBox) BindModel(model gio.ListModel, createWidgetFunc ListBoxCreateWidgetFunc)

func (l listBox) DragHighlightRow(row ListBoxRow)

func (l listBox) DragUnhighlightRow()

func (l listBox) ActivateOnSingleClick() bool

func (l listBox) Adjustment() Adjustment

func (l listBox) RowAtIndex(index_ int) ListBoxRow

func (l listBox) RowAtY(y int) ListBoxRow

func (l listBox) SelectedRow() ListBoxRow

func (l listBox) SelectedRows() *glib.List

func (l listBox) SelectionMode() SelectionMode

func (l listBox) ShowSeparators() bool

func (l listBox) Insert(child Widget, position int)

func (l listBox) InvalidateFilter()

func (l listBox) InvalidateHeaders()

func (l listBox) InvalidateSort()

func (l listBox) Prepend(child Widget)

func (l listBox) Remove(child Widget)

func (l listBox) SelectAll()

func (l listBox) SelectRow(row ListBoxRow)

func (l listBox) SelectedForeach(_func ListBoxForeachFunc)

func (l listBox) SetActivateOnSingleClick(single bool)

func (l listBox) SetAdjustment(adjustment Adjustment)

func (l listBox) SetFilterFunc(filterFunc ListBoxFilterFunc)

func (l listBox) SetHeaderFunc(updateHeader ListBoxUpdateHeaderFunc)

func (l listBox) SetPlaceholder(placeholder Widget)

func (l listBox) SetSelectionMode(mode SelectionMode)

func (l listBox) SetShowSeparators(showSeparators bool)

func (l listBox) SetSortFunc(sortFunc ListBoxSortFunc)

func (l listBox) UnselectAll()

func (l listBox) UnselectRow(row ListBoxRow)

type ListBoxRow interface {
	Widget

	// Changed: marks @row as changed, causing any state that depends on this to
	// be updated. This affects sorting, filtering and headers.
	//
	// Note that calls to this method must be in sync with the data used for the
	// row functions. For instance, if the list is mirroring some external data
	// set, and *two* rows changed in the external data set then when you call
	// gtk_list_box_row_changed() on the first row the sort function must only
	// read the new data for the first of the two changed rows, otherwise the
	// resorting of the rows will be wrong.
	//
	// This generally means that if you don’t fully control the data model you
	// have to duplicate the data that affects the listbox row functions into
	// the row widgets themselves. Another alternative is to call
	// gtk_list_box_invalidate_sort() on any model change, but that is more
	// expensive.
	Changed()
	// Activatable: gets the value of the ListBoxRow:activatable property for
	// this row.
	Activatable() bool
	// Child: gets the child widget of @row.
	Child() Widget
	// Header: returns the current header of the @row. This can be used in a
	// ListBoxUpdateHeaderFunc to see if there is a header set already, and if
	// so to update the state of it.
	Header() Widget
	// Index: gets the current index of the @row in its ListBox container.
	Index() int
	// Selectable: gets the value of the ListBoxRow:selectable property for this
	// row.
	Selectable() bool
	// IsSelected: returns whether the child is currently selected in its
	// ListBox container.
	IsSelected() bool
	// SetActivatable: set the ListBoxRow:activatable property for this row.
	SetActivatable(activatable bool)
	// SetChild: sets the child widget of @self.
	SetChild(child Widget)
	// SetHeader: sets the current header of the @row. This is only allowed to
	// be called from a ListBoxUpdateHeaderFunc. It will replace any existing
	// header in the row, and be shown in front of the row in the listbox.
	SetHeader(header Widget)
	// SetSelectable: set the ListBoxRow:selectable property for this row.
	SetSelectable(selectable bool)
}

type listBoxRow struct {
	widget
}

func wrapListBoxRow(obj *externglib.Object) ListBoxRow {
	return listBoxRow{widget{externglib.InitiallyUnowned{obj}}}
}

func marshalListBoxRow(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewListBoxRow() ListBoxRow

func (l listBoxRow) Changed()

func (l listBoxRow) Activatable() bool

func (l listBoxRow) Child() Widget

func (l listBoxRow) Header() Widget

func (l listBoxRow) Index() int

func (l listBoxRow) Selectable() bool

func (l listBoxRow) IsSelected() bool

func (l listBoxRow) SetActivatable(activatable bool)

func (l listBoxRow) SetChild(child Widget)

func (l listBoxRow) SetHeader(header Widget)

func (l listBoxRow) SetSelectable(selectable bool)

// ListItem is the object that list-handling containers such as ListView use to
// represent items in a Model. They are managed by the container and cannot be
// created by application code.
//
// ListItems need to be populated by application code. This is done by calling
// gtk_list_item_set_child().
//
// ListItems exist in 2 stages:
//
// 1. The unbound stage where the listitem is not currently connected to an item
// in the list. In that case, the ListItem:item property is set to nil.
//
// 2. The bound stage where the listitem references an item from the list. The
// ListItem:item property is not nil.
type ListItem interface {
	gextras.Objector

	// Activatable: checks if a list item has been set to be activatable via
	// gtk_list_item_set_activatable().
	Activatable() bool
	// Child: gets the child previously set via gtk_list_item_set_child() or nil
	// if none was set.
	Child() Widget
	// Item: gets the item that is currently displayed in model that @self is
	// currently bound to or nil if @self is unbound.
	Item() interface{}
	// Position: gets the position in the model that @self currently displays.
	// If @self is unbound, GTK_INVALID_LIST_POSITION is returned.
	Position() uint
	// Selectable: checks if a list item has been set to be selectable via
	// gtk_list_item_set_selectable().
	//
	// Do not confuse this function with gtk_list_item_get_selected().
	Selectable() bool
	// Selected: checks if the item is displayed as selected. The selected state
	// is maintained by the container and its list model and cannot be set
	// otherwise.
	Selected() bool
	// SetActivatable: sets @self to be activatable.
	//
	// If an item is activatable, double-clicking on the item, using the Return
	// key or calling gtk_widget_activate() will activate the item. Activating
	// instructs the containing view to handle activation. ListView for example
	// will be emitting the ListView::activate signal.
	//
	// By default, list items are activatable
	SetActivatable(activatable bool)
	// SetChild: sets the child to be used for this listitem.
	//
	// This function is typically called by applications when setting up a
	// listitem so that the widget can be reused when binding it multiple times.
	SetChild(child Widget)
	// SetSelectable: sets @self to be selectable. If an item is selectable,
	// clicking on the item or using the keyboard will try to select or unselect
	// the item. If this succeeds is up to the model to determine, as it is
	// managing the selected state.
	//
	// Note that this means that making an item non-selectable has no influence
	// on the selected state at all. A non-selectable item may still be
	// selected.
	//
	// By default, list items are selectable. When rebinding them to a new item,
	// they will also be reset to be selectable by GTK.
	SetSelectable(selectable bool)
}

type listItem struct {
	*externglib.Object
}

func wrapListItem(obj *externglib.Object) ListItem {
	return listItem{*externglib.Object{obj}}
}

func marshalListItem(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func (l listItem) Activatable() bool

func (l listItem) Child() Widget

func (l listItem) Item() interface{}

func (l listItem) Position() uint

func (l listItem) Selectable() bool

func (l listItem) Selected() bool

func (l listItem) SetActivatable(activatable bool)

func (l listItem) SetChild(child Widget)

func (l listItem) SetSelectable(selectable bool)

// ListItemFactory is one of the core concepts of handling list widgets. It is
// the object tasked with creating widgets for items taken from a Model when the
// views need them and updating them as the items displayed by the view change.
//
// A view is usually only able to display anything after both a factory and a
// model have been set on the view. So it is important that you do not skip this
// step when setting up your first view.
//
// Because views do not display the whole list at once but only a few items,
// they only need to maintain a few widgets at a time. They will instruct the
// ListItemFactory to create these widgets and bind them to the items that are
// currently displayed. As the list model changes or the user scrolls to the
// list, the items will change and the view will instruct the factory to bind
// the widgets to those new items.
//
// The actual widgets used for displaying those widgets is provided by you.
//
// When the factory needs widgets created, it will create a ListItem and hand it
// to your code to set up a widget for. This list item will provide various
// properties with information about what item to display and provide you with
// some opportunities to configure its behavior. See the ListItem documentation
// for further details.
//
// Various implementations of ListItemFactory exist to allow you different ways
// to provide those widgets. The most common implementations are
// BuilderListItemFactory which takes a Builder .ui file and then creates
// widgets and manages everything automatically from the information in that
// file and SignalListItemFactory which allows you to connect to signals with
// your own code and retain full control over how the widgets are setup and
// managed.
//
// A ListItemFactory is supposed to be final - that means its behavior should
// not change and the first widget created from it should behave the same way as
// the last widget created from it. If you intend to do changes to the behavior,
// it is recommended that you create a new ListItemFactory which will allow the
// views to recreate its widgets.
//
// Once you have chosen your factory and created it, you need to set it on the
// view widget you want to use it with, such as via gtk_list_view_set_factory().
// Reusing factories across different views is allowed, but very uncommon.
type ListItemFactory interface {
	gextras.Objector
}

type listItemFactory struct {
	*externglib.Object
}

func wrapListItemFactory(obj *externglib.Object) ListItemFactory {
	return listItemFactory{*externglib.Object{obj}}
}

func marshalListItemFactory(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// ListStore: the ListStore object is a list model for use with a TreeView
// widget. It implements the TreeModel interface, and consequentialy, can use
// all of the methods available there. It also implements the TreeSortable
// interface so it can be sorted by the view. Finally, it also implements the
// tree [drag and drop][gtk4-GtkTreeView-drag-and-drop] interfaces.
//
// The ListStore can accept most GObject types as a column type, though it can’t
// accept all custom types. Internally, it will keep a copy of data passed in
// (such as a string or a boxed pointer). Columns that accept #GObjects are
// handled a little differently. The ListStore will keep a reference to the
// object instead of copying the value. As a result, if the object is modified,
// it is up to the application writer to call gtk_tree_model_row_changed() to
// emit the TreeModel::row_changed signal. This most commonly affects lists with
// Textures stored.
//
// An example for creating a simple list store: |[<!-- language="C" --> enum {
// COLUMN_STRING, COLUMN_INT, COLUMN_BOOLEAN, N_COLUMNS };
//
// { GtkListStore *list_store; GtkTreePath *path; GtkTreeIter iter; int i;
//
// list_store = gtk_list_store_new (N_COLUMNS, G_TYPE_STRING, G_TYPE_INT,
// G_TYPE_BOOLEAN);
//
// for (i = 0; i < 10; i++) { char *some_data;
//
// some_data = get_some_data (i);
//
// // Add a new row to the model gtk_list_store_append (list_store, &iter);
// // gtk_list_store_set (list_store, &iter, COLUMN_STRING, some_data, COLUMN_INT,
// // i, COLUMN_BOOLEAN, FALSE, -1);
//
// // As the store will keep a copy of the string internally, // we free
// // some_data. g_free (some_data); }
//
//      // Modify a particular row
//      path = gtk_tree_path_new_from_string ("4");
//      gtk_tree_model_get_iter (GTK_TREE_MODEL (list_store),
//                               &iter,
//                               path);
//      gtk_tree_path_free (path);
//      gtk_list_store_set (list_store, &iter,
//                          COLUMN_BOOLEAN, TRUE,
//                          -1);
//    }
//
//
//    # Performance Considerations
//
//    Internally, the ListStore was originally implemented with a linked list
//    with a tail pointer.  As a result, it was fast at data insertion and deletion,
//    and not fast at random data access.  The ListStore sets the
//    K_TREE_MODEL_ITERS_PERSIST flag, which means that TreeIters can be
//    cached while the row exists.  Thus, if access to a particular row is needed
//    often and your code is expected to run on older versions of GTK, it is worth
//    keeping the iter around.
//
//    # Atomic Operations
//
//    It is important to note that only the methods
//    gtk_list_store_insert_with_values() and gtk_list_store_insert_with_valuesv()
//    are atomic, in the sense that the row is being appended to the store and the
//    values filled in in a single operation with regard to TreeModel signaling.
//    In contrast, using e.g. gtk_list_store_append() and then gtk_list_store_set()
//    will first create a row, which triggers the TreeModel::row-inserted signal
//    on ListStore. The row, however, is still empty, and any signal handler
//    connecting to TreeModel::row-inserted on this particular store should be prepared
//    for the situation that the row might be empty. This is especially important
//    if you are wrapping the ListStore inside a TreeModelFilter and are
//    using a TreeModelFilterVisibleFunc. Using any of the non-atomic operations
//    to append rows to the ListStore will cause the
//    TreeModelFilterVisibleFunc to be visited with an empty row first; the
//    function must be prepared for that.
//
//    # GtkListStore as GtkBuildable
//
//    The GtkListStore implementation of the GtkBuildable interface allows
//    to specify the model columns with a <columns> element that may contain
//    multiple <column> elements, each specifying one model column. The “type”
//    attribute specifies the data type for the column.
//
//    Additionally, it is possible to specify content for the list store
//    in the UI definition, with the <data> element. It can contain multiple
//    <row> elements, each specifying to content for one row of the list model.
//    Inside a <row>, the <col> elements specify the content for individual cells.
//
//    Note that it is probably more common to define your models in the code,
//    and one might consider it a layering violation to specify the content of
//    a list store in a UI definition, data, not presentation, and common wisdom
//    is to separate the two, as far as possible.
//
//    <object class="GtkListStore">
//      <columns>
//        <column type="gchararray"/>
//        <column type="gchararray"/>
//        <column type="gint"/>
//      </columns>
//      <data>
//        <row>
//          <col id="0">John</col>
//          <col id="1">Doe</col>
//          <col id="2">25</col>
//        </row>
//        <row>
//          <col id="0">Johan</col>
//          <col id="1">Dahlin</col>
//          <col id="2">50</col>
//        </row>
//      </data>
//    </object>
type ListStore interface {
	gextras.Objector

	// Append: appends a new row to @list_store. @iter will be changed to point
	// to this new row. The row will be empty after this function is called. To
	// fill in values, you need to call gtk_list_store_set() or
	// gtk_list_store_set_value().
	Append() TreeIter
	// Clear: removes all rows from the list store.
	Clear()
	// Insert: creates a new row at @position. @iter will be changed to point to
	// this new row. If @position is -1 or is larger than the number of rows on
	// the list, then the new row will be appended to the list. The row will be
	// empty after this function is called. To fill in values, you need to call
	// gtk_list_store_set() or gtk_list_store_set_value().
	Insert(position int) TreeIter
	// InsertAfter: inserts a new row after @sibling. If @sibling is nil, then
	// the row will be prepended to the beginning of the list. @iter will be
	// changed to point to this new row. The row will be empty after this
	// function is called. To fill in values, you need to call
	// gtk_list_store_set() or gtk_list_store_set_value().
	InsertAfter(sibling *TreeIter) TreeIter
	// InsertBefore: inserts a new row before @sibling. If @sibling is nil, then
	// the row will be appended to the end of the list. @iter will be changed to
	// point to this new row. The row will be empty after this function is
	// called. To fill in values, you need to call gtk_list_store_set() or
	// gtk_list_store_set_value().
	InsertBefore(sibling *TreeIter) TreeIter
	// InsertWithValuesv: a variant of gtk_list_store_insert_with_values() which
	// takes the columns and values as two arrays, instead of varargs. This
	// function is mainly intended for language-bindings.
	InsertWithValuesv(position int, columns []int, values []*externglib.Value) TreeIter
	// IterIsValid: > This function is slow. Only use it for debugging and/or
	// testing > purposes.
	//
	// Checks if the given iter is a valid iter for this ListStore.
	IterIsValid(iter *TreeIter) bool
	// MoveAfter: moves @iter in @store to the position after @position. Note
	// that this function only works with unsorted stores. If @position is nil,
	// @iter will be moved to the start of the list.
	MoveAfter(iter *TreeIter, position *TreeIter)
	// MoveBefore: moves @iter in @store to the position before @position. Note
	// that this function only works with unsorted stores. If @position is nil,
	// @iter will be moved to the end of the list.
	MoveBefore(iter *TreeIter, position *TreeIter)
	// Prepend: prepends a new row to @list_store. @iter will be changed to
	// point to this new row. The row will be empty after this function is
	// called. To fill in values, you need to call gtk_list_store_set() or
	// gtk_list_store_set_value().
	Prepend() TreeIter
	// Remove: removes the given row from the list store. After being removed,
	// @iter is set to be the next valid row, or invalidated if it pointed to
	// the last row in @list_store.
	Remove(iter *TreeIter) bool
	// Reorder: reorders @store to follow the order indicated by @new_order.
	// Note that this function only works with unsorted stores.
	Reorder(newOrder []int)
	// SetColumnTypes: this function is meant primarily for #GObjects that
	// inherit from ListStore, and should only be used when constructing a new
	// ListStore. It will not function after a row has been added, or a method
	// on the TreeModel interface is called.
	SetColumnTypes(nColumns int, types []externglib.Type)
	// SetValue: sets the data in the cell specified by @iter and @column. The
	// type of @value must be convertible to the type of the column.
	SetValue(iter *TreeIter, column int, value *externglib.Value)
	// SetValuesv: a variant of gtk_list_store_set_valist() which takes the
	// columns and values as two arrays, instead of varargs. This function is
	// mainly intended for language-bindings and in case the number of columns
	// to change is not known until run-time.
	SetValuesv(iter *TreeIter, columns []int, values []*externglib.Value)
	// Swap: swaps @a and @b in @store. Note that this function only works with
	// unsorted stores.
	Swap(a *TreeIter, b *TreeIter)
}

type listStore struct {
	*externglib.Object
}

func wrapListStore(obj *externglib.Object) ListStore {
	return listStore{*externglib.Object{obj}}
}

func marshalListStore(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewListStore(nColumns int, types []externglib.Type) ListStore

func (l listStore) Append() TreeIter

func (l listStore) Clear()

func (l listStore) Insert(position int) TreeIter

func (l listStore) InsertAfter(sibling *TreeIter) TreeIter

func (l listStore) InsertBefore(sibling *TreeIter) TreeIter

func (l listStore) InsertWithValuesv(position int, columns []int, values []*externglib.Value) TreeIter

func (l listStore) IterIsValid(iter *TreeIter) bool

func (l listStore) MoveAfter(iter *TreeIter, position *TreeIter)

func (l listStore) MoveBefore(iter *TreeIter, position *TreeIter)

func (l listStore) Prepend() TreeIter

func (l listStore) Remove(iter *TreeIter) bool

func (l listStore) Reorder(newOrder []int)

func (l listStore) SetColumnTypes(nColumns int, types []externglib.Type)

func (l listStore) SetValue(iter *TreeIter, column int, value *externglib.Value)

func (l listStore) SetValuesv(iter *TreeIter, columns []int, values []*externglib.Value)

func (l listStore) Swap(a *TreeIter, b *TreeIter)

// ListView: gtkListView is a widget to present a view into a large dynamic list
// of items.
//
// GtkListView uses its factory to generate one row widget for each visible item
// and shows them in a linear display, either vertically or horizontally. The
// ListView:show-separators property offers a simple way to display separators
// between the rows.
//
// GtkListView allows the user to select items according to the selection
// characteristics of the model. For models that allow multiple selected items,
// it is possible to turn on _rubberband selection_, using
// ListView:enable-rubberband.
//
// If you need multiple columns with headers, see ColumnView.
//
// To learn more about the list widget framework, see the [overview](Widget).
//
// An example of using GtkListView: |[ static void setup_listitem_cb
// (GtkListItemFactory *factory, GtkListItem *list_item) { GtkWidget *image;
//
// image = gtk_image_new (); gtk_image_set_icon_size (GTK_IMAGE (image),
// GTK_ICON_SIZE_LARGE); gtk_list_item_set_child (list_item, image); }
//
// static void bind_listitem_cb (GtkListItemFactory *factory, GtkListItem
// *list_item) { GtkWidget *image; GAppInfo *app_info;
//
// image = gtk_list_item_get_child (list_item); app_info =
// gtk_list_item_get_item (list_item); gtk_image_set_from_gicon (GTK_IMAGE
// (image), g_app_info_get_icon (app_info)); }
//
// static void activate_cb (GtkListView *list, guint position, gpointer unused)
// { GAppInfo *app_info;
//
// app_info = g_list_model_get_item (G_LIST_MODEL (gtk_list_view_get_model
// (list)), position); g_app_info_launch (app_info, NULL, NULL, NULL);
// g_object_unref (app_info); }
//
// ...
//
// model = create_application_list ();
//
// factory = gtk_signal_list_item_factory_new (); g_signal_connect (factory,
// "setup", G_CALLBACK (setup_listitem_cb), NULL); g_signal_connect (factory,
// "bind", G_CALLBACK (bind_listitem_cb), NULL);
//
// list = gtk_list_view_new (GTK_SELECTION_MODEL (gtk_single_selection_new
// (model)), factory);
//
// g_signal_connect (list, "activate", G_CALLBACK (activate_cb), NULL);
//
//      gtk_scrolled_window_set_child (GTK_SCROLLED_WINDOW (sw), list);
//
//
//    # CSS nodes
//
//    listview[.separators][.rich-list][.navigation-sidebar][.data-table]
//    ├── row
//    │
//    ├── row
//    │
//    ┊
//    ╰── [rubberband]
//
//
//
//    GtkListView uses a single CSS node named listview. It may carry the
//    .separators style class, when ListView:show-separators property
//    is set. Each child widget uses a single CSS node named row. For
//    rubberband selection, a node with name rubberband is used.
//
//    The main listview node may also carry style classes to select
//    the style of [list presentation](ListContainers.html#list-styles):
//    .rich-list, .navigation-sidebar or .data-table.
//
//    # Accessibility
//
//    GtkListView uses the K_ACCESSIBLE_ROLE_LIST role, and the list
//    items use the K_ACCESSIBLE_ROLE_LIST_ITEM role.
type ListView interface {
	ListBase

	// EnableRubberband: returns whether rows can be selected by dragging with
	// the mouse.
	EnableRubberband() bool
	// Factory: gets the factory that's currently used to populate list items.
	Factory() ListItemFactory
	// Model: gets the model that's currently used to read the items displayed.
	Model() SelectionModel
	// ShowSeparators: returns whether the list box should show separators
	// between rows.
	ShowSeparators() bool
	// SingleClickActivate: returns whether rows will be activated on single
	// click and selected on hover.
	SingleClickActivate() bool
	// SetEnableRubberband: sets whether selections can be changed by dragging
	// with the mouse.
	SetEnableRubberband(enableRubberband bool)
	// SetFactory: sets the ListItemFactory to use for populating list items.
	SetFactory(factory ListItemFactory)
	// SetModel: sets the SelectionModel to use.
	SetModel(model SelectionModel)
	// SetShowSeparators: sets whether the list box should show separators
	// between rows.
	SetShowSeparators(showSeparators bool)
	// SetSingleClickActivate: sets whether rows should be activated on single
	// click and selected on hover.
	SetSingleClickActivate(singleClickActivate bool)
}

type listView struct {
	listBase
}

func wrapListView(obj *externglib.Object) ListView {
	return listView{listBase{widget{externglib.InitiallyUnowned{obj}}}}
}

func marshalListView(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewListView(model SelectionModel, factory ListItemFactory) ListView

func (l listView) EnableRubberband() bool

func (l listView) Factory() ListItemFactory

func (l listView) Model() SelectionModel

func (l listView) ShowSeparators() bool

func (l listView) SingleClickActivate() bool

func (l listView) SetEnableRubberband(enableRubberband bool)

func (l listView) SetFactory(factory ListItemFactory)

func (l listView) SetModel(model SelectionModel)

func (l listView) SetShowSeparators(showSeparators bool)

func (l listView) SetSingleClickActivate(singleClickActivate bool)

// LockButton: gtkLockButton is a widget that can be used in control panels or
// preference dialogs to allow users to obtain and revoke authorizations needed
// to operate the controls. The required authorization is represented by a
// #GPermission object. Concrete implementations of #GPermission may use
// PolicyKit or some other authorization framework. To obtain a PolicyKit-based
// #GPermission, use polkit_permission_new().
//
// If the user is not currently allowed to perform the action, but can obtain
// the permission, the widget looks like this:
//
// ![](lockbutton-locked.png)
//
// and the user can click the button to request the permission. Depending on the
// platform, this may pop up an authentication dialog or ask the user to
// authenticate in some other way. Once the user has obtained the permission,
// the widget changes to this:
//
// ![](lockbutton-unlocked.png)
//
// and the permission can be dropped again by clicking the button. If the user
// is not able to obtain the permission at all, the widget looks like this:
//
// ![](lockbutton-sorry.png)
//
// If the user has the permission and cannot drop it, the button is hidden.
//
// The text (and tooltips) that are shown in the various cases can be adjusted
// with the LockButton:text-lock, LockButton:text-unlock,
// LockButton:tooltip-lock, LockButton:tooltip-unlock and
// LockButton:tooltip-not-authorized properties.
type LockButton interface {
	Button

	// Permission: obtains the #GPermission object that controls @button.
	Permission() gio.Permission
	// SetPermission: sets the #GPermission object that controls @button.
	SetPermission(permission gio.Permission)
}

type lockButton struct {
	button
}

func wrapLockButton(obj *externglib.Object) LockButton {
	return lockButton{button{widget{externglib.InitiallyUnowned{obj}}}}
}

func marshalLockButton(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewLockButton(permission gio.Permission) LockButton

func (l lockButton) Permission() gio.Permission

func (l lockButton) SetPermission(permission gio.Permission)

// MapListModel is a list model that takes a list model and maps the items in
// that model to different items according to a MapListModelMapFunc.
//
// Example: Create a list of EventControllers |[ static gpointer
// map_to_controllers (gpointer widget, gpointer data) { gpointer result =
// gtk_widget_observe_controllers (widget); g_object_unref (widget); return
// result; }
//
// widgets = gtk_widget_observe_children (widget);
//
// controllers = gtk_map_list_model_new (G_TYPE_LIST_MODEL, widgets,
// map_to_controllers, NULL, NULL);
//
//      model = gtk_flatten_list_model_new (GTK_TYPE_EVENT_CONTROLLER,
//                                          controllers);
//
//
//    MapListModel will attempt to discard the mapped objects as soon as
//    they are no longer needed and recreate them if necessary.
type MapListModel interface {
	gextras.Objector

	// Model: gets the model that is currently being mapped or nil if none.
	Model() gio.ListModel
	// HasMap: checks if a map function is currently set on @self
	HasMap() bool
	// SetMapFunc: sets the function used to map items. The function will be
	// called whenever an item needs to be mapped and must return the item to
	// use for the given input item.
	//
	// Note that MapListModel may call this function multiple times on the same
	// item, because it may delete items it doesn't need anymore.
	//
	// GTK makes no effort to ensure that @map_func conforms to the item type of
	// @self. It assumes that the caller knows what they are doing and the map
	// function returns items of the appropriate type.
	SetMapFunc(mapFunc MapListModelMapFunc)
	// SetModel: sets the model to be mapped.
	//
	// GTK makes no effort to ensure that @model conforms to the item type
	// expected by the map function. It assumes that the caller knows what they
	// are doing and have set up an appropriate map function.
	SetModel(model gio.ListModel)
}

type mapListModel struct {
	*externglib.Object
}

func wrapMapListModel(obj *externglib.Object) MapListModel {
	return mapListModel{*externglib.Object{obj}}
}

func marshalMapListModel(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewMapListModel(model gio.ListModel, mapFunc MapListModelMapFunc) MapListModel

func (m mapListModel) Model() gio.ListModel

func (m mapListModel) HasMap() bool

func (m mapListModel) SetMapFunc(mapFunc MapListModelMapFunc)

func (m mapListModel) SetModel(model gio.ListModel)

// MediaControls: gtkMediaControls is a widget to show controls for a
// MediaStream and giving users a way to use it.
type MediaControls interface {
	Widget

	// MediaStream: gets the media stream managed by @controls or nil if none.
	MediaStream() MediaStream
	// SetMediaStream: sets the stream that is controlled by @controls.
	SetMediaStream(stream MediaStream)
}

type mediaControls struct {
	widget
}

func wrapMediaControls(obj *externglib.Object) MediaControls {
	return mediaControls{widget{externglib.InitiallyUnowned{obj}}}
}

func marshalMediaControls(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewMediaControls(stream MediaStream) MediaControls

func (m mediaControls) MediaStream() MediaStream

func (m mediaControls) SetMediaStream(stream MediaStream)

// MediaFile is the implementation for media file usage with MediaStream.
//
// This provides a simple way to play back video files with GTK.
//
// GTK provides a GIO extension point for MediaFile implementations to allow for
// external implementations using various media frameworks. GTK itself includes
// implementations using GStreamer and ffmpeg.
type MediaFile interface {
	MediaStream

	// Clear: resets the media file to be empty.
	Clear()
	// File: returns the file that @self is currently playing from.
	//
	// When @self is not playing or not playing from a file, nil is returned.
	File() gio.File
	// InputStream: returns the stream that @self is currently playing from.
	//
	// When @self is not playing or not playing from a stream, nil is returned.
	InputStream() gio.InputStream
	// SetFile: if any file is still playing, stop playing it.
	//
	// Then start playing the given @file.
	SetFile(file gio.File)
	// SetFilename: this is a utility function that converts the given @filename
	// to a #GFile and calls gtk_media_file_set_file().
	SetFilename(filename string)
	// SetInputStream: if anything is still playing, stop playing it. Then start
	// playing the given @stream.
	//
	// Full control about the @stream is assumed for the duration of playback.
	// The stream will not bt be closed.
	SetInputStream(stream gio.InputStream)
	// SetResource: this is a utility function that converts the given
	// @resource_path to a #GFile and calls gtk_media_file_set_file().
	SetResource(resourcePath string)
}

type mediaFile struct {
	mediaStream
}

func wrapMediaFile(obj *externglib.Object) MediaFile {
	return mediaFile{mediaStream{*externglib.Object{obj}}}
}

func marshalMediaFile(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewMediaFile() MediaFile

func NewMediaFile(file gio.File) MediaFile

func NewMediaFile(filename string) MediaFile

func NewMediaFile(stream gio.InputStream) MediaFile

func NewMediaFile(resourcePath string) MediaFile

func (m mediaFile) Clear()

func (m mediaFile) File() gio.File

func (m mediaFile) InputStream() gio.InputStream

func (m mediaFile) SetFile(file gio.File)

func (m mediaFile) SetFilename(filename string)

func (m mediaFile) SetInputStream(stream gio.InputStream)

func (m mediaFile) SetResource(resourcePath string)

// MediaStream is the integration point for media playback inside GTK.
//
// GTK provides an implementation of the MediaStream interface that is called
// MediaFile.
//
// Apart from application-facing API for stream playback, MediaStream has a
// number of APIs that are only useful for implementations and should not be
// used in applications: gtk_media_stream_prepared(),
// gtk_media_stream_unprepared(), gtk_media_stream_update(),
// gtk_media_stream_ended(), gtk_media_stream_seek_success(),
// gtk_media_stream_seek_failed(), gtk_media_stream_gerror(),
// gtk_media_stream_error(), gtk_media_stream_error_valist().
type MediaStream interface {
	gextras.Objector

	// Ended: pauses the media stream and marks it as ended. This is a hint
	// only, calls to GtkMediaStream.play() may still happen.
	Ended()
	// Gerror: sets @self into an error state. This will pause the stream (you
	// can check for an error via gtk_media_stream_get_error() in your
	// GtkMediaStream.pause() implementation), abort pending seeks and mark the
	// stream as prepared.
	//
	// if the stream is already in an error state, this call will be ignored and
	// the existing error will be retained. FIXME: Or do we want to set the new
	// error?
	//
	// To unset an error, the stream must be reset via a call to
	// gtk_media_stream_unprepared().
	Gerror(error *glib.Error)
	// Duration: gets the duration of the stream. If the duration is not known,
	// 0 will be returned.
	Duration() int64
	// GetEnded: returns whether the streams playback is finished.
	GetEnded() bool
	// Error: if the stream is in an error state, returns the #GError explaining
	// that state. Any type of error can be reported here depending on the
	// implementation of the media stream.
	//
	// A media stream in an error cannot be operated on, calls like
	// gtk_media_stream_play() or gtk_media_stream_seek() will not have any
	// effect.
	//
	// MediaStream itself does not provide a way to unset an error, but
	// implementations may provide options. For example, a MediaFile will unset
	// errors when a new source is set with ie gtk_media_file_set_file().
	Error() *glib.Error
	// Loop: returns whether the stream is set to loop. See
	// gtk_media_stream_set_loop() for details.
	Loop() bool
	// Muted: returns whether the audio for the stream is muted. See
	// gtk_media_stream_set_muted() for details.
	Muted() bool
	// Playing: return whether the stream is currently playing.
	Playing() bool
	// Timestamp: returns the current presentation timestamp in microseconds.
	Timestamp() int64
	// Volume: returns the volume of the audio for the stream. See
	// gtk_media_stream_set_volume() for details.
	Volume() float64
	// HasAudio: returns whether the stream has audio.
	HasAudio() bool
	// HasVideo: returns whether the stream has video.
	HasVideo() bool
	// IsPrepared: returns whether the stream has finished initializing and
	// existence of audio and video is known.
	IsPrepared() bool
	// IsSeekable: checks if a stream may be seekable.
	//
	// This is meant to be a hint. Streams may not allow seeking even if this
	// function returns true. However, if this function returns false, streams
	// are guaranteed to not be seekable and user interfaces may hide controls
	// that allow seeking.
	//
	// It is allowed to call gtk_media_stream_seek() on a non-seekable stream,
	// though it will not do anything.
	IsSeekable() bool
	// IsSeeking: checks if there is currently a seek operation going on.
	IsSeeking() bool
	// Pause: pauses playback of the stream. If the stream is not playing, do
	// nothing.
	Pause()
	// Play: starts playing the stream. If the stream is in error or already
	// playing, do nothing.
	Play()
	// Prepared: called by MediaStream implementations to advertise the stream
	// being ready to play and providing details about the stream.
	//
	// Note that the arguments are hints. If the stream implementation cannot
	// determine the correct values, it is better to err on the side of caution
	// and return true. User interfaces will use those values to determine what
	// controls to show.
	//
	// This function may not be called again until the stream has been reset via
	// gtk_media_stream_unprepared().
	Prepared(hasAudio bool, hasVideo bool, seekable bool, duration int64)
	// Realize: called by users to attach the media stream to a Surface they
	// manage. The stream can then access the resources of @surface for its
	// rendering purposes. In particular, media streams might want to create
	// GLContexts or sync to the FrameClock.
	//
	// Whoever calls this function is responsible for calling
	// gtk_media_stream_unrealize() before either the stream or @surface get
	// destroyed.
	//
	// Multiple calls to this function may happen from different users of the
	// video, even with the same @surface. Each of these calls must be followed
	// by its own call to gtk_media_stream_unrealize().
	//
	// It is not required to call this function to make a media stream work.
	Realize(surface gdk.Surface)
	// Seek: start a seek operation on @self to @timestamp. If @timestamp is out
	// of range, it will be clamped.
	//
	// Seek operations may not finish instantly. While a seek operation is in
	// process, the GtkMediaStream:seeking property will be set.
	//
	// When calling gtk_media_stream_seek() during an ongoing seek operation,
	// the new seek will override any pending seek.
	Seek(timestamp int64)
	// SeekFailed: ends a seek operation started via GtkMediaStream.seek() as a
	// failure. This will not cause an error on the stream and will assume that
	// playback continues as if no seek had happened.
	//
	// See gtk_media_stream_seek_success() for the other way of ending a seek.
	SeekFailed()
	// SeekSuccess: ends a seek operation started via GtkMediaStream.seek()
	// successfully. This function will unset the GtkMediaStream:ended property
	// if it was set.
	//
	// See gtk_media_stream_seek_failed() for the other way of ending a seek.
	SeekSuccess()
	// SetLoop: sets whether the stream should loop, ie restart playback from
	// the beginning instead of stopping at the end.
	//
	// Not all streams may support looping, in particular non-seekable streams.
	// Those streams will ignore the loop setting and just end.
	SetLoop(loop bool)
	// SetMuted: sets whether the audio stream should be muted. Muting a stream
	// will cause no audio to be played, but it does not modify the volume. This
	// means that muting and then unmuting the stream will restore the volume
	// settings.
	//
	// If the stream has no audio, calling this function will still work but it
	// will not have an audible effect.
	SetMuted(muted bool)
	// SetPlaying: starts or pauses playback of the stream.
	SetPlaying(playing bool)
	// SetVolume: sets the volume of the audio stream. This function call will
	// work even if the stream is muted.
	//
	// The given @volume should range from 0.0 for silence to 1.0 for as loud as
	// possible. Values outside of this range will be clamped to the nearest
	// value.
	//
	// If the stream has no audio or is muted, calling this function will still
	// work but it will not have an immediate audible effect. When the stream is
	// unmuted, the new volume setting will take effect.
	SetVolume(volume float64)
	// Unprepared: resets a given media stream implementation.
	// gtk_media_stream_prepared() can now be called again.
	//
	// This function will also reset any error state the stream was in.
	Unprepared()
	// Unrealize: undoes a previous call to gtk_media_stream_realize() and
	// causes the stream to release all resources it had allocated from
	// @surface.
	Unrealize(surface gdk.Surface)
	// Update: media stream implementations should regularly call this function
	// to update the timestamp reported by the stream. It is up to
	// implementations to call this at the frequency they deem appropriate.
	Update(timestamp int64)
}

type mediaStream struct {
	*externglib.Object
}

func wrapMediaStream(obj *externglib.Object) MediaStream {
	return mediaStream{*externglib.Object{obj}}
}

func marshalMediaStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func (m mediaStream) Ended()

func (m mediaStream) Gerror(error *glib.Error)

func (m mediaStream) Duration() int64

func (m mediaStream) GetEnded() bool

func (m mediaStream) Error() *glib.Error

func (m mediaStream) Loop() bool

func (m mediaStream) Muted() bool

func (m mediaStream) Playing() bool

func (m mediaStream) Timestamp() int64

func (m mediaStream) Volume() float64

func (m mediaStream) HasAudio() bool

func (m mediaStream) HasVideo() bool

func (m mediaStream) IsPrepared() bool

func (m mediaStream) IsSeekable() bool

func (m mediaStream) IsSeeking() bool

func (m mediaStream) Pause()

func (m mediaStream) Play()

func (m mediaStream) Prepared(hasAudio bool, hasVideo bool, seekable bool, duration int64)

func (m mediaStream) Realize(surface gdk.Surface)

func (m mediaStream) Seek(timestamp int64)

func (m mediaStream) SeekFailed()

func (m mediaStream) SeekSuccess()

func (m mediaStream) SetLoop(loop bool)

func (m mediaStream) SetMuted(muted bool)

func (m mediaStream) SetPlaying(playing bool)

func (m mediaStream) SetVolume(volume float64)

func (m mediaStream) Unprepared()

func (m mediaStream) Unrealize(surface gdk.Surface)

func (m mediaStream) Update(timestamp int64)

// MenuButton: the MenuButton widget is used to display a popup when clicked on.
// This popup can be provided either as a Popover or as an abstract Model.
//
// The MenuButton widget can show either an icon (set with the
// MenuButton:icon-name property) or a label (set with the MenuButton:label
// property). If neither is explicitly set, a Image is automatically created,
// using an arrow image oriented according to MenuButton:direction or the
// generic “open-menu-symbolic” icon if the direction is not set.
//
// The positioning of the popup is determined by the MenuButton:direction
// property of the menu button.
//
// For menus, the Widget:halign and Widget:valign properties of the menu are
// also taken into account. For example, when the direction is GTK_ARROW_DOWN
// and the horizontal alignment is GTK_ALIGN_START, the menu will be positioned
// below the button, with the starting edge (depending on the text direction) of
// the menu aligned with the starting edge of the button. If there is not enough
// space below the button, the menu is popped up above the button instead. If
// the alignment would move part of the menu offscreen, it is “pushed in”.
//
// Direction = Down
//
// - halign = start
//
// ![](down-start.png)
//
// - halign = center
//
// ![](down-center.png)
//
// - halign = end
//
// ![](down-end.png)
//
// Direction = Up
//
// - halign = start
//
// ![](up-start.png)
//
// - halign = center
//
// ![](up-center.png)
//
// - halign = end
//
// ![](up-end.png)
//
// Direction = Left
//
// - valign = start
//
// ![](left-start.png)
//
// - valign = center
//
// ![](left-center.png)
//
// - valign = end
//
// ![](left-end.png)
//
// Direction = Right
//
// - valign = start
//
// ![](right-start.png)
//
// - valign = center
//
// ![](right-center.png)
//
// - valign = end
//
// ![](right-end.png)
//
// CSS nodes
//
//    menubutton
//    ╰── button.toggle
//        ╰── [content]
//
// GtkMenuButton has a single CSS node with name menubutton which contains a
// toggle button node.
//
//
// Accessibility
//
// GtkMenuButton uses the K_ACCESSIBLE_ROLE_BUTTON role.
type MenuButton interface {
	Widget

	// Direction: returns the direction the popup will be pointing at when
	// popped up.
	Direction() ArrowType
	// HasFrame: returns whether the button has a frame.
	HasFrame() bool
	// IconName: gets the name of the icon shown in the button.
	IconName() string
	// Label: gets the label shown in the button
	Label() string
	// MenuModel: returns the Model used to generate the popup.
	MenuModel() gio.MenuModel
	// Popover: returns the Popover that pops out of the button. If the button
	// is not using a Popover, this function returns nil.
	Popover() Popover
	// UseUnderline: returns whether an embedded underline in the text indicates
	// a mnemonic. See gtk_menu_button_set_use_underline().
	UseUnderline() bool
	// Popdown: dismiss the menu.
	Popdown()
	// Popup: pop up the menu.
	Popup()
	// SetCreatePopupFunc: sets @func to be called when a popup is about to be
	// shown. @func should use one of
	//
	// - gtk_menu_button_set_popover() - gtk_menu_button_set_menu_model()
	//
	// to set a popup for @menu_button. If @func is non-nil, @menu_button will
	// always be sensitive.
	//
	// Using this function will not reset the menu widget attached to
	// @menu_button. Instead, this can be done manually in @func.
	SetCreatePopupFunc(_func MenuButtonCreatePopupFunc)
	// SetDirection: sets the direction in which the popup will be popped up, as
	// well as changing the arrow’s direction. The child will not be changed to
	// an arrow if it was customized.
	//
	// If the does not fit in the available space in the given direction, GTK
	// will its best to keep it inside the screen and fully visible.
	//
	// If you pass GTK_ARROW_NONE for a @direction, the popup will behave as if
	// you passed GTK_ARROW_DOWN (although you won’t see any arrows).
	SetDirection(direction ArrowType)
	// SetHasFrame: sets the style of the button.
	SetHasFrame(hasFrame bool)
	// SetIconName: sets the name of an icon to show inside the menu button.
	SetIconName(iconName string)
	// SetLabel: sets the label to show inside the menu button.
	SetLabel(label string)
	// SetMenuModel: sets the Model from which the popup will be constructed, or
	// nil to dissociate any existing menu model and disable the button.
	//
	// A Popover will be created from the menu model with
	// gtk_popover_menu_new_from_model(). Actions will be connected as
	// documented for this function.
	//
	// If MenuButton:popover is already set, it will be dissociated from the
	// @menu_button, and the property is set to nil.
	SetMenuModel(menuModel gio.MenuModel)
	// SetPopover: sets the Popover that will be popped up when the @menu_button
	// is clicked, or nil to dissociate any existing popover and disable the
	// button.
	//
	// If MenuButton:menu-model is set, the menu model is dissociated from the
	// @menu_button, and the property is set to nil.
	SetPopover(popover Widget)
	// SetUseUnderline: if true, an underline in the text indicates the next
	// character should be used for the mnemonic accelerator key.
	SetUseUnderline(useUnderline bool)
}

type menuButton struct {
	widget
}

func wrapMenuButton(obj *externglib.Object) MenuButton {
	return menuButton{widget{externglib.InitiallyUnowned{obj}}}
}

func marshalMenuButton(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewMenuButton() MenuButton

func (m menuButton) Direction() ArrowType

func (m menuButton) HasFrame() bool

func (m menuButton) IconName() string

func (m menuButton) Label() string

func (m menuButton) MenuModel() gio.MenuModel

func (m menuButton) Popover() Popover

func (m menuButton) UseUnderline() bool

func (m menuButton) Popdown()

func (m menuButton) Popup()

func (m menuButton) SetCreatePopupFunc(_func MenuButtonCreatePopupFunc)

func (m menuButton) SetDirection(direction ArrowType)

func (m menuButton) SetHasFrame(hasFrame bool)

func (m menuButton) SetIconName(iconName string)

func (m menuButton) SetLabel(label string)

func (m menuButton) SetMenuModel(menuModel gio.MenuModel)

func (m menuButton) SetPopover(popover Widget)

func (m menuButton) SetUseUnderline(useUnderline bool)

// MessageDialog presents a dialog with some message text. It’s simply a
// convenience widget; you could construct the equivalent of MessageDialog from
// Dialog without too much effort, but MessageDialog saves typing.
//
// The easiest way to do a modal message dialog is to use the GTK_DIALOG_MODAL
// flag, which will call gtk_window_set_modal() internally. The dialog will
// prevent interaction with the parent window until it's hidden or destroyed.
// You can use the Dialog::response signal to know when the user dismissed the
// dialog.
//
// An example for using a modal dialog: |[<!-- language="C" --> GtkDialogFlags
// flags = GTK_DIALOG_DESTROY_WITH_PARENT | GTK_DIALOG_MODAL; dialog =
// gtk_message_dialog_new (parent_window, flags, GTK_MESSAGE_ERROR,
// GTK_BUTTONS_CLOSE, "Error reading “s”: s", filename, g_strerror (errno)); //
// Destroy the dialog when the user responds to it // (e.g. clicks a button)
//
//     g_signal_connect (dialog, "response",
//                       G_CALLBACK (gtk_window_destroy),
//                       NULL);
//
//
//    You might do a non-modal MessageDialog simply by omitting the
//    GTK_DIALOG_MODAL flag:
//
//     GtkDialogFlags flags = GTK_DIALOG_DESTROY_WITH_PARENT;
//     dialog = gtk_message_dialog_new (parent_window,
//                                      flags,
//                                      GTK_MESSAGE_ERROR,
//                                      GTK_BUTTONS_CLOSE,
//                                      "Error reading “s”: s",
//                                      filename,
//                                      g_strerror (errno));
//
//     // Destroy the dialog when the user responds to it
//     // (e.g. clicks a button)
//     g_signal_connect (dialog, "response",
//                       G_CALLBACK (gtk_window_destroy),
//                       NULL);
//
//
//    # GtkMessageDialog as GtkBuildable
//
//    The GtkMessageDialog implementation of the GtkBuildable interface exposes
//    the message area as an internal child with the name “message_area”.
type MessageDialog interface {
	Dialog

	// MessageArea: returns the message area of the dialog. This is the box
	// where the dialog’s primary and secondary labels are packed. You can add
	// your own extra content to that box and it will appear below those labels.
	// See gtk_dialog_get_content_area() for the corresponding function in the
	// parent Dialog.
	MessageArea() Widget
	// SetMarkup: sets the text of the message dialog to be @str, which is
	// marked up with the [Pango text markup language][PangoMarkupFormat].
	SetMarkup(str string)
}

type messageDialog struct {
	dialog
}

func wrapMessageDialog(obj *externglib.Object) MessageDialog {
	return messageDialog{dialog{window{widget{externglib.InitiallyUnowned{obj}}}}}
}

func marshalMessageDialog(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func (m messageDialog) MessageArea() Widget

func (m messageDialog) SetMarkup(str string)

// MnemonicAction: a ShortcutAction that calls gtk_widget_mnemonic_activate().
type MnemonicAction interface {
	ShortcutAction
}

type mnemonicAction struct {
	shortcutAction
}

func wrapMnemonicAction(obj *externglib.Object) MnemonicAction {
	return mnemonicAction{shortcutAction{*externglib.Object{obj}}}
}

func marshalMnemonicAction(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// MnemonicTrigger: a ShortcutTrigger that triggers when a specific mnemonic is
// pressed.
type MnemonicTrigger interface {
	ShortcutTrigger

	// Keyval: gets the keyval that must be pressed to succeed triggering @self.
	Keyval() uint
}

type mnemonicTrigger struct {
	shortcutTrigger
}

func wrapMnemonicTrigger(obj *externglib.Object) MnemonicTrigger {
	return mnemonicTrigger{shortcutTrigger{*externglib.Object{obj}}}
}

func marshalMnemonicTrigger(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewMnemonicTrigger(keyval uint) MnemonicTrigger

func (m mnemonicTrigger) Keyval() uint

// MountOperation: this should not be accessed directly. Use the accessor
// functions below.
type MountOperation interface {
	gio.MountOperation

	// Display: gets the display on which windows of the MountOperation will be
	// shown.
	Display() gdk.Display
	// Parent: gets the transient parent used by the MountOperation
	Parent() Window
	// IsShowing: returns whether the MountOperation is currently displaying a
	// window.
	IsShowing() bool
	// SetDisplay: sets the display to show windows of the MountOperation on.
	SetDisplay(display gdk.Display)
	// SetParent: sets the transient parent for windows shown by the
	// MountOperation.
	SetParent(parent Window)
}

type mountOperation struct {
	gio.mountOperation
}

func wrapMountOperation(obj *externglib.Object) MountOperation {
	return mountOperation{gio.mountOperation{*externglib.Object{obj}}}
}

func marshalMountOperation(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewMountOperation(parent Window) MountOperation

func (m mountOperation) Display() gdk.Display

func (m mountOperation) Parent() Window

func (m mountOperation) IsShowing() bool

func (m mountOperation) SetDisplay(display gdk.Display)

func (m mountOperation) SetParent(parent Window)

// MultiFilter: gtkMultiFilter is the base type that implements support for
// handling multiple filters.
//
// GtkAnyFilter is a subclass of GtkMultiFilter that matches an item when at
// least one of its filters matches.
//
// GtkEveryFilter is a subclass of GtkMultiFilter that matches an item when each
// of its filters matches.
type MultiFilter interface {
	Filter

	// Append: adds a @filter to @self to use for matching.
	Append(filter Filter)
	// Remove: removes the filter at the given @position from the list of
	// filters used by @self. If @position is larger than the number of filters,
	// nothing happens and the function returns.
	Remove(position uint)
}

type multiFilter struct {
	filter
}

func wrapMultiFilter(obj *externglib.Object) MultiFilter {
	return multiFilter{filter{*externglib.Object{obj}}}
}

func marshalMultiFilter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func (m multiFilter) Append(filter Filter)

func (m multiFilter) Remove(position uint)

// MultiSelection: gtkMultiSelection is an implementation of the SelectionModel
// interface that allows selecting multiple elements.
type MultiSelection interface {
	gextras.Objector

	// Model: returns the underlying model of @self.
	Model() gio.ListModel
	// SetModel: sets the model that @self should wrap. If @model is nil, @self
	// will be empty.
	SetModel(model gio.ListModel)
}

type multiSelection struct {
	*externglib.Object
}

func wrapMultiSelection(obj *externglib.Object) MultiSelection {
	return multiSelection{*externglib.Object{obj}}
}

func marshalMultiSelection(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewMultiSelection(model gio.ListModel) MultiSelection

func (m multiSelection) Model() gio.ListModel

func (m multiSelection) SetModel(model gio.ListModel)

// MultiSorter: gtkMultiSorter combines multiple sorters by trying them in turn.
// If the first sorter compares two items as equal, the second is tried next,
// and so on.
type MultiSorter interface {
	Sorter

	// Append: add @sorter to @self to use for sorting at the end. @self will
	// consult all existing sorters before it will sort with the given @sorter.
	Append(sorter Sorter)
	// Remove: removes the sorter at the given @position from the list of sorter
	// used by @self.
	//
	// If @position is larger than the number of sorters, nothing happens.
	Remove(position uint)
}

type multiSorter struct {
	sorter
}

func wrapMultiSorter(obj *externglib.Object) MultiSorter {
	return multiSorter{sorter{*externglib.Object{obj}}}
}

func marshalMultiSorter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewMultiSorter() MultiSorter

func (m multiSorter) Append(sorter Sorter)

func (m multiSorter) Remove(position uint)

// NamedAction: a ShortcutAction that activates an action by name.
type NamedAction interface {
	ShortcutAction

	// ActionName: returns the name of the action that will be activated.
	ActionName() string
}

type namedAction struct {
	shortcutAction
}

func wrapNamedAction(obj *externglib.Object) NamedAction {
	return namedAction{shortcutAction{*externglib.Object{obj}}}
}

func marshalNamedAction(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewNamedAction(name string) NamedAction

func (n namedAction) ActionName() string

// NativeDialog: native dialogs are platform dialogs that don't use Dialog or
// Window. They are used in order to integrate better with a platform, by
// looking the same as other native applications and supporting platform
// specific features.
//
// The Dialog functions cannot be used on such objects, but we need a similar
// API in order to drive them. The NativeDialog object is an API that allows you
// to do this. It allows you to set various common properties on the dialog, as
// well as show and hide it and get a NativeDialog::response signal when the
// user finished with the dialog.
//
// Note that unlike Dialog, NativeDialog objects are not toplevel widgets, and
// GTK does not keep them alive. It is your responsibility to keep a reference
// until you are done with the object.
type NativeDialog interface {
	gextras.Objector

	// Destroy: destroys a dialog.
	//
	// When a dialog is destroyed, it will break any references it holds to
	// other objects. If it is visible it will be hidden and any underlying
	// window system resources will be destroyed.
	//
	// Note that this does not release any reference to the object (as opposed
	// to destroying a GtkWindow) because there is no reference from the
	// windowing system to the NativeDialog.
	Destroy()
	// Modal: returns whether the dialog is modal. See
	// gtk_native_dialog_set_modal().
	Modal() bool
	// Title: gets the title of the NativeDialog.
	Title() string
	// TransientFor: fetches the transient parent for this window. See
	// gtk_native_dialog_set_transient_for().
	TransientFor() Window
	// Visible: determines whether the dialog is visible.
	Visible() bool
	// Hide: hides the dialog if it is visilbe, aborting any interaction. Once
	// this is called the NativeDialog::response signal will not be emitted
	// until after the next call to gtk_native_dialog_show().
	//
	// If the dialog is not visible this does nothing.
	Hide()
	// SetModal: sets a dialog modal or non-modal. Modal dialogs prevent
	// interaction with other windows in the same application. To keep modal
	// dialogs on top of main application windows, use
	// gtk_native_dialog_set_transient_for() to make the dialog transient for
	// the parent; most [window managers][gtk-X11-arch] will then disallow
	// lowering the dialog below the parent.
	SetModal(modal bool)
	// SetTitle: sets the title of the NativeDialog.
	SetTitle(title string)
	// SetTransientFor: dialog windows should be set transient for the main
	// application window they were spawned from. This allows [window
	// managers][gtk-X11-arch] to e.g. keep the dialog on top of the main
	// window, or center the dialog over the main window.
	//
	// Passing nil for @parent unsets the current transient window.
	SetTransientFor(parent Window)
	// Show: shows the dialog on the display, allowing the user to interact with
	// it. When the user accepts the state of the dialog the dialog will be
	// automatically hidden and the NativeDialog::response signal will be
	// emitted.
	//
	// Multiple calls while the dialog is visible will be ignored.
	Show()
}

type nativeDialog struct {
	*externglib.Object
}

func wrapNativeDialog(obj *externglib.Object) NativeDialog {
	return nativeDialog{*externglib.Object{obj}}
}

func marshalNativeDialog(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func (n nativeDialog) Destroy()

func (n nativeDialog) Modal() bool

func (n nativeDialog) Title() string

func (n nativeDialog) TransientFor() Window

func (n nativeDialog) Visible() bool

func (n nativeDialog) Hide()

func (n nativeDialog) SetModal(modal bool)

func (n nativeDialog) SetTitle(title string)

func (n nativeDialog) SetTransientFor(parent Window)

func (n nativeDialog) Show()

// NeverTrigger: a ShortcutTrigger that never triggers.
type NeverTrigger interface {
	ShortcutTrigger
}

type neverTrigger struct {
	shortcutTrigger
}

func wrapNeverTrigger(obj *externglib.Object) NeverTrigger {
	return neverTrigger{shortcutTrigger{*externglib.Object{obj}}}
}

func marshalNeverTrigger(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// NoSelection: gtkNoSelection is an implementation of the SelectionModel
// interface that does not allow selecting anything.
//
// This model is meant to be used as a simple wrapper to Models when a
// SelectionModel is required.
type NoSelection interface {
	gextras.Objector

	// Model: gets the model that @self is wrapping.
	Model() gio.ListModel
	// SetModel: sets the model that @self should wrap. If @model is nil, this
	// model will be empty.
	SetModel(model gio.ListModel)
}

type noSelection struct {
	*externglib.Object
}

func wrapNoSelection(obj *externglib.Object) NoSelection {
	return noSelection{*externglib.Object{obj}}
}

func marshalNoSelection(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewNoSelection(model gio.ListModel) NoSelection

func (n noSelection) Model() gio.ListModel

func (n noSelection) SetModel(model gio.ListModel)

// Notebook: the Notebook widget is a layout container whose children are pages
// that can be switched between using tab labels along one edge.
//
// There are many configuration options for GtkNotebook. Among other things, you
// can choose on which edge the tabs appear (see gtk_notebook_set_tab_pos()),
// whether, if there are too many tabs to fit the notebook should be made bigger
// or scrolling arrows added (see gtk_notebook_set_scrollable()), and whether
// there will be a popup menu allowing the users to switch pages. (see
// gtk_notebook_popup_enable(), gtk_notebook_popup_disable())
//
//
// GtkNotebook as GtkBuildable
//
// The GtkNotebook implementation of the Buildable interface supports placing
// children into tabs by specifying “tab” as the “type” attribute of a <child>
// element. Note that the content of the tab must be created before the tab can
// be filled. A tab child can be specified without specifying a <child> type
// attribute.
//
// To add a child widget in the notebooks action area, specify "action-start" or
// “action-end” as the “type” attribute of the <child> element.
//
//
//    <object class="GtkNotebook">
//      <child>
//        <object class="GtkLabel" id="notebook-content">
//          <property name="label">Content</property>
//        </object>
//      </child>
//      <child type="tab">
//        <object class="GtkLabel" id="notebook-tab">
//          <property name="label">Tab</property>
//        </object>
//      </child>
//    </object>
//
// CSS nodes
//
//    notebook
//    ├── header.top
//    │   ├── [<action widget>]
//    │   ├── tabs
//    │   │   ├── [arrow]
//    │   │   ├── tab
//    │   │   │   ╰── <tab label>
//    ┊   ┊   ┊
//    │   │   ├── tab[.reorderable-page]
//    │   │   │   ╰── <tab label>
//    │   │   ╰── [arrow]
//    │   ╰── [<action widget>]
//    │
//    ╰── stack
//        ├── <child>
//        ┊
//        ╰── <child>
//
// GtkNotebook has a main CSS node with name `notebook`, a subnode with name
// `header` and below that a subnode with name `tabs` which contains one subnode
// per tab with name `tab`.
//
// If action widgets are present, their CSS nodes are placed next to the `tabs`
// node. If the notebook is scrollable, CSS nodes with name `arrow` are placed
// as first and last child of the `tabs` node.
//
// The main node gets the `.frame` style class when the notebook has a border
// (see gtk_notebook_set_show_border()).
//
// The header node gets one of the style class `.top`, `.bottom`, `.left` or
// `.right`, depending on where the tabs are placed. For reorderable pages, the
// tab node gets the `.reorderable-page` class.
//
// A `tab` node gets the `.dnd` style class while it is moved with
// drag-and-drop.
//
// The nodes are always arranged from left-to-right, regardless of text
// direction.
//
//
// Accessibility
//
// GtkNotebook uses the following roles:
//
// - GTK_ACCESSIBLE_ROLE_GROUP for the notebook widget -
// GTK_ACCESSIBLE_ROLE_TAB_LIST for the list of tabs - GTK_ACCESSIBLE_ROLE_TAB
// role for each tab - GTK_ACCESSIBLE_ROLE_TAB_PANEL for each page
type Notebook interface {
	Widget

	// AppendPage: appends a page to @notebook.
	AppendPage(child Widget, tabLabel Widget) int
	// AppendPageMenu: appends a page to @notebook, specifying the widget to use
	// as the label in the popup menu.
	AppendPageMenu(child Widget, tabLabel Widget, menuLabel Widget) int
	// DetachTab: removes the child from the notebook.
	//
	// This function is very similar to gtk_notebook_remove_page(), but
	// additionally informs the notebook that the removal is happening as part
	// of a tab DND operation, which should not be cancelled.
	DetachTab(child Widget)
	// ActionWidget: gets one of the action widgets. See
	// gtk_notebook_set_action_widget().
	ActionWidget(packType PackType) Widget
	// CurrentPage: returns the page number of the current page.
	CurrentPage() int
	// GroupName: gets the current group name for @notebook.
	GroupName() string
	// MenuLabel: retrieves the menu label widget of the page containing @child.
	MenuLabel(child Widget) Widget
	// MenuLabelText: retrieves the text of the menu label for the page
	// containing @child.
	MenuLabelText(child Widget) string
	// NPages: gets the number of pages in a notebook.
	NPages() int
	// NthPage: returns the child widget contained in page number @page_num.
	NthPage(pageNum int) Widget
	// Page: returns the NotebookPage for @child.
	Page(child Widget) NotebookPage
	// Pages: returns a Model that contains the pages of the notebook, and can
	// be used to keep an up-to-date view.
	Pages() gio.ListModel
	// Scrollable: returns whether the tab label area has arrows for scrolling.
	// See gtk_notebook_set_scrollable().
	Scrollable() bool
	// ShowBorder: returns whether a bevel will be drawn around the notebook
	// pages. See gtk_notebook_set_show_border().
	ShowBorder() bool
	// ShowTabs: returns whether the tabs of the notebook are shown. See
	// gtk_notebook_set_show_tabs().
	ShowTabs() bool
	// TabDetachable: returns whether the tab contents can be detached from
	// @notebook.
	TabDetachable(child Widget) bool
	// TabLabel: returns the tab label widget for the page @child. nil is
	// returned if @child is not in @notebook or if no tab label has
	// specifically been set for @child.
	TabLabel(child Widget) Widget
	// TabLabelText: retrieves the text of the tab label for the page containing
	// @child.
	TabLabelText(child Widget) string
	// TabPos: gets the edge at which the tabs for switching pages in the
	// notebook are drawn.
	TabPos() PositionType
	// TabReorderable: gets whether the tab can be reordered via drag and drop
	// or not.
	TabReorderable(child Widget) bool
	// InsertPage: insert a page into @notebook at the given position.
	InsertPage(child Widget, tabLabel Widget, position int) int
	// InsertPageMenu: insert a page into @notebook at the given position,
	// specifying the widget to use as the label in the popup menu.
	InsertPageMenu(child Widget, tabLabel Widget, menuLabel Widget, position int) int
	// NextPage: switches to the next page. Nothing happens if the current page
	// is the last page.
	NextPage()
	// PageNum: finds the index of the page which contains the given child
	// widget.
	PageNum(child Widget) int
	// PopupDisable: disables the popup menu.
	PopupDisable()
	// PopupEnable: enables the popup menu: if the user clicks with the right
	// mouse button on the tab labels, a menu with all the pages will be popped
	// up.
	PopupEnable()
	// PrependPage: prepends a page to @notebook.
	PrependPage(child Widget, tabLabel Widget) int
	// PrependPageMenu: prepends a page to @notebook, specifying the widget to
	// use as the label in the popup menu.
	PrependPageMenu(child Widget, tabLabel Widget, menuLabel Widget) int
	// PrevPage: switches to the previous page. Nothing happens if the current
	// page is the first page.
	PrevPage()
	// RemovePage: removes a page from the notebook given its index in the
	// notebook.
	RemovePage(pageNum int)
	// ReorderChild: reorders the page containing @child, so that it appears in
	// position @position. If @position is greater than or equal to the number
	// of children in the list or negative, @child will be moved to the end of
	// the list.
	ReorderChild(child Widget, position int)
	// SetActionWidget: sets @widget as one of the action widgets. Depending on
	// the pack type the widget will be placed before or after the tabs. You can
	// use a Box if you need to pack more than one widget on the same side.
	SetActionWidget(widget Widget, packType PackType)
	// SetCurrentPage: switches to the page number @page_num.
	//
	// Note that due to historical reasons, GtkNotebook refuses to switch to a
	// page unless the child widget is visible. Therefore, it is recommended to
	// show child widgets before adding them to a notebook.
	SetCurrentPage(pageNum int)
	// SetGroupName: sets a group name for @notebook.
	//
	// Notebooks with the same name will be able to exchange tabs via drag and
	// drop. A notebook with a nil group name will not be able to exchange tabs
	// with any other notebook.
	SetGroupName(groupName string)
	// SetMenuLabel: changes the menu label for the page containing @child.
	SetMenuLabel(child Widget, menuLabel Widget)
	// SetMenuLabelText: creates a new label and sets it as the menu label of
	// @child.
	SetMenuLabelText(child Widget, menuText string)
	// SetScrollable: sets whether the tab label area will have arrows for
	// scrolling if there are too many tabs to fit in the area.
	SetScrollable(scrollable bool)
	// SetShowBorder: sets whether a bevel will be drawn around the notebook
	// pages. This only has a visual effect when the tabs are not shown. See
	// gtk_notebook_set_show_tabs().
	SetShowBorder(showBorder bool)
	// SetShowTabs: sets whether to show the tabs for the notebook or not.
	SetShowTabs(showTabs bool)
	// SetTabDetachable: sets whether the tab can be detached from @notebook to
	// another notebook or widget.
	//
	// Note that 2 notebooks must share a common group identificator (see
	// gtk_notebook_set_group_name()) to allow automatic tabs interchange
	// between them.
	//
	// If you want a widget to interact with a notebook through DnD (i.e.:
	// accept dragged tabs from it) it must be set as a drop destination and
	// accept the target “GTK_NOTEBOOK_TAB”. The notebook will fill the
	// selection with a GtkWidget** pointing to the child widget that
	// corresponds to the dropped tab.
	//
	// Note that you should use gtk_notebook_detach_tab() instead of
	// gtk_notebook_remove_page() if you want to remove the tab from the source
	// notebook as part of accepting a drop. Otherwise, the source notebook will
	// think that the dragged tab was removed from underneath the ongoing drag
	// operation, and will initiate a drag cancel animation.
	//
	//     static void
	//     on_drag_data_received (GtkWidget        *widget,
	//                            GdkDrop          *drop,
	//                            GtkSelectionData *data,
	//                            guint             time,
	//                            gpointer          user_data)
	//     {
	//       GtkDrag *drag;
	//       GtkWidget *notebook;
	//       GtkWidget **child;
	//
	//       drag = gtk_drop_get_drag (drop);
	//       notebook = g_object_get_data (drag, "gtk-notebook-drag-origin");
	//       child = (void*) gtk_selection_data_get_data (data);
	//
	//       // process_widget (*child);
	//
	//       gtk_notebook_detach_tab (GTK_NOTEBOOK (notebook), *child);
	//     }
	//
	//
	// If you want a notebook to accept drags from other widgets, you will have
	// to set your own DnD code to do it.
	SetTabDetachable(child Widget, detachable bool)
	// SetTabLabel: changes the tab label for @child. If nil is specified for
	// @tab_label, then the page will have the label “page N”.
	SetTabLabel(child Widget, tabLabel Widget)
	// SetTabLabelText: creates a new label and sets it as the tab label for the
	// page containing @child.
	SetTabLabelText(child Widget, tabText string)
	// SetTabPos: sets the edge at which the tabs for switching pages in the
	// notebook are drawn.
	SetTabPos(pos PositionType)
	// SetTabReorderable: sets whether the notebook tab can be reordered via
	// drag and drop or not.
	SetTabReorderable(child Widget, reorderable bool)
}

type notebook struct {
	widget
}

func wrapNotebook(obj *externglib.Object) Notebook {
	return notebook{widget{externglib.InitiallyUnowned{obj}}}
}

func marshalNotebook(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewNotebook() Notebook

func (n notebook) AppendPage(child Widget, tabLabel Widget) int

func (n notebook) AppendPageMenu(child Widget, tabLabel Widget, menuLabel Widget) int

func (n notebook) DetachTab(child Widget)

func (n notebook) ActionWidget(packType PackType) Widget

func (n notebook) CurrentPage() int

func (n notebook) GroupName() string

func (n notebook) MenuLabel(child Widget) Widget

func (n notebook) MenuLabelText(child Widget) string

func (n notebook) NPages() int

func (n notebook) NthPage(pageNum int) Widget

func (n notebook) Page(child Widget) NotebookPage

func (n notebook) Pages() gio.ListModel

func (n notebook) Scrollable() bool

func (n notebook) ShowBorder() bool

func (n notebook) ShowTabs() bool

func (n notebook) TabDetachable(child Widget) bool

func (n notebook) TabLabel(child Widget) Widget

func (n notebook) TabLabelText(child Widget) string

func (n notebook) TabPos() PositionType

func (n notebook) TabReorderable(child Widget) bool

func (n notebook) InsertPage(child Widget, tabLabel Widget, position int) int

func (n notebook) InsertPageMenu(child Widget, tabLabel Widget, menuLabel Widget, position int) int

func (n notebook) NextPage()

func (n notebook) PageNum(child Widget) int

func (n notebook) PopupDisable()

func (n notebook) PopupEnable()

func (n notebook) PrependPage(child Widget, tabLabel Widget) int

func (n notebook) PrependPageMenu(child Widget, tabLabel Widget, menuLabel Widget) int

func (n notebook) PrevPage()

func (n notebook) RemovePage(pageNum int)

func (n notebook) ReorderChild(child Widget, position int)

func (n notebook) SetActionWidget(widget Widget, packType PackType)

func (n notebook) SetCurrentPage(pageNum int)

func (n notebook) SetGroupName(groupName string)

func (n notebook) SetMenuLabel(child Widget, menuLabel Widget)

func (n notebook) SetMenuLabelText(child Widget, menuText string)

func (n notebook) SetScrollable(scrollable bool)

func (n notebook) SetShowBorder(showBorder bool)

func (n notebook) SetShowTabs(showTabs bool)

func (n notebook) SetTabDetachable(child Widget, detachable bool)

func (n notebook) SetTabLabel(child Widget, tabLabel Widget)

func (n notebook) SetTabLabelText(child Widget, tabText string)

func (n notebook) SetTabPos(pos PositionType)

func (n notebook) SetTabReorderable(child Widget, reorderable bool)

// NotebookPage: a page in the Notebook.
//
// The `GtkNotebookPage` structure only contains private data.
type NotebookPage interface {
	gextras.Objector

	// Child: returns the notebook child to which @page belongs.
	Child() Widget
}

type notebookPage struct {
	*externglib.Object
}

func wrapNotebookPage(obj *externglib.Object) NotebookPage {
	return notebookPage{*externglib.Object{obj}}
}

func marshalNotebookPage(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func (n notebookPage) Child() Widget

// NothingAction: a ShortcutAction that does nothing.
type NothingAction interface {
	ShortcutAction
}

type nothingAction struct {
	shortcutAction
}

func wrapNothingAction(obj *externglib.Object) NothingAction {
	return nothingAction{shortcutAction{*externglib.Object{obj}}}
}

func marshalNothingAction(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// NumericSorter: gtkNumericSorter is a Sorter that compares numbers.
//
// To obtain the numbers to compare, this sorter evaluates a Expression.
type NumericSorter interface {
	Sorter

	// Expression: gets the expression that is evaluated to obtain numbers from
	// items.
	Expression() Expression
	// SortOrder: gets whether this sorter will sort smaller numbers first.
	SortOrder() SortType
	// SetExpression: sets the expression that is evaluated to obtain numbers
	// from items.
	//
	// Unless an expression is set on @self, the sorter will always compare
	// items as invalid.
	//
	// The expression must have a return type that can be compared numerically,
	// such as TYPE_INT or TYPE_DOUBLE.
	SetExpression(expression Expression)
	// SetSortOrder: sets whether to sort smaller numbers before larger ones.
	SetSortOrder(sortOrder SortType)
}

type numericSorter struct {
	sorter
}

func wrapNumericSorter(obj *externglib.Object) NumericSorter {
	return numericSorter{sorter{*externglib.Object{obj}}}
}

func marshalNumericSorter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewNumericSorter(expression Expression) NumericSorter

func (n numericSorter) Expression() Expression

func (n numericSorter) SortOrder() SortType

func (n numericSorter) SetExpression(expression Expression)

func (n numericSorter) SetSortOrder(sortOrder SortType)

type ObjectExpression interface {
	Expression

	// Object: gets the object that the expression evaluates to.
	Object() gextras.Objector
}

type objectExpression struct {
	expression
}

func wrapObjectExpression(obj *externglib.Object) ObjectExpression {
	return objectExpression{expression{obj}}
}

func marshalObjectExpression(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewObjectExpression(object gextras.Objector) ObjectExpression

func (o objectExpression) Object() gextras.Objector

// Overlay: gtkOverlay is a container which contains a single main child, on top
// of which it can place “overlay” widgets. The position of each overlay widget
// is determined by its Widget:halign and Widget:valign properties. E.g. a
// widget with both alignments set to GTK_ALIGN_START will be placed at the top
// left corner of the GtkOverlay container, whereas an overlay with halign set
// to GTK_ALIGN_CENTER and valign set to GTK_ALIGN_END will be placed a the
// bottom edge of the GtkOverlay, horizontally centered. The position can be
// adjusted by setting the margin properties of the child to non-zero values.
//
// More complicated placement of overlays is possible by connecting to the
// Overlay::get-child-position signal.
//
// An overlay’s minimum and natural sizes are those of its main child. The sizes
// of overlay children are not considered when measuring these preferred sizes.
//
//
// GtkOverlay as GtkBuildable
//
// The GtkOverlay implementation of the GtkBuildable interface supports placing
// a child as an overlay by specifying “overlay” as the “type” attribute of a
// `<child>` element.
//
//
// CSS nodes
//
// GtkOverlay has a single CSS node with the name “overlay”. Overlay children
// whose alignments cause them to be positioned at an edge get the style classes
// “.left”, “.right”, “.top”, and/or “.bottom” according to their position.
type Overlay interface {
	Widget

	// AddOverlay: adds @widget to @overlay.
	//
	// The widget will be stacked on top of the main widget added with
	// gtk_overlay_set_child().
	//
	// The position at which @widget is placed is determined from its
	// Widget:halign and Widget:valign properties.
	AddOverlay(widget Widget)
	// Child: gets the child widget of @overlay.
	Child() Widget
	// ClipOverlay: gets whether @widget should be clipped within the parent.
	ClipOverlay(widget Widget) bool
	// MeasureOverlay: gets whether @widget's size is included in the
	// measurement of @overlay.
	MeasureOverlay(widget Widget) bool
	// RemoveOverlay: removes an overlay that was added with
	// gtk_overlay_add_overlay().
	RemoveOverlay(widget Widget)
	// SetChild: sets the child widget of @overlay.
	SetChild(child Widget)
	// SetClipOverlay: sets whether @widget should be clipped within the parent.
	SetClipOverlay(widget Widget, clipOverlay bool)
	// SetMeasureOverlay: sets whether @widget is included in the measured size
	// of @overlay.
	//
	// The overlay will request the size of the largest child that has this
	// property set to true. Children who are not included may be drawn outside
	// of @overlay's allocation if they are too large.
	SetMeasureOverlay(widget Widget, measure bool)
}

type overlay struct {
	widget
}

func wrapOverlay(obj *externglib.Object) Overlay {
	return overlay{widget{externglib.InitiallyUnowned{obj}}}
}

func marshalOverlay(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewOverlay() Overlay

func (o overlay) AddOverlay(widget Widget)

func (o overlay) Child() Widget

func (o overlay) ClipOverlay(widget Widget) bool

func (o overlay) MeasureOverlay(widget Widget) bool

func (o overlay) RemoveOverlay(widget Widget)

func (o overlay) SetChild(child Widget)

func (o overlay) SetClipOverlay(widget Widget, clipOverlay bool)

func (o overlay) SetMeasureOverlay(widget Widget, measure bool)

// OverlayLayout: gtkOverlayLayout is the layout manager used by Overlay. It
// places widgets as overlays on top of the main child.
//
// This is not a reusable layout manager, since it expects its widget to be a
// Overlay. It only listed here so that its layout properties get documented.
type OverlayLayout interface {
	LayoutManager
}

type overlayLayout struct {
	layoutManager
}

func wrapOverlayLayout(obj *externglib.Object) OverlayLayout {
	return overlayLayout{layoutManager{*externglib.Object{obj}}}
}

func marshalOverlayLayout(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewOverlayLayout() OverlayLayout

type OverlayLayoutChild interface {
	LayoutChild

	// ClipOverlay: retrieves whether the child is clipped.
	ClipOverlay() bool
	// Measure: retrieves whether the child is measured.
	Measure() bool
	// SetClipOverlay: sets whether to clip this child.
	SetClipOverlay(clipOverlay bool)
	// SetMeasure: sets whether to measure this child.
	SetMeasure(measure bool)
}

type overlayLayoutChild struct {
	layoutChild
}

func wrapOverlayLayoutChild(obj *externglib.Object) OverlayLayoutChild {
	return overlayLayoutChild{layoutChild{*externglib.Object{obj}}}
}

func marshalOverlayLayoutChild(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func (o overlayLayoutChild) ClipOverlay() bool

func (o overlayLayoutChild) Measure() bool

func (o overlayLayoutChild) SetClipOverlay(clipOverlay bool)

func (o overlayLayoutChild) SetMeasure(measure bool)

// PadController is an event controller for the pads found in drawing tablets
// (The collection of buttons and tactile sensors often found around the
// stylus-sensitive area).
//
// These buttons and sensors have no implicit meaning, and by default they
// perform no action, this event controller is provided to map those to #GAction
// objects, thus letting the application give those a more semantic meaning.
//
// Buttons and sensors are not constrained to triggering a single action, some
// GDK_SOURCE_TABLET_PAD devices feature multiple "modes", all these input
// elements have one current mode, which may determine the final action being
// triggered. Pad devices often divide buttons and sensors into groups, all
// elements in a group share the same current mode, but different groups may
// have different modes. See gdk_device_pad_get_n_groups() and
// gdk_device_pad_get_group_n_modes().
//
// Each of the actions that a given button/strip/ring performs for a given mode
// is defined by PadActionEntry, it contains an action name that will be looked
// up in the given Group and activated whenever the specified input element and
// mode are triggered.
//
// A simple example of PadController usage, assigning button 1 in all modes and
// pad devices to an "invert-selection" action: |[ GtkPadActionEntry
// *pad_actions[] = { { GTK_PAD_ACTION_BUTTON, 1, -1, "Invert selection",
// "pad-actions.invert-selection" }, … };
//
//      …
//      action_group = g_simple_action_group_new ();
//      action = g_simple_action_new ("pad-actions.invert-selection", NULL);
//      g_signal_connect (action, "activate", on_invert_selection_activated, NULL);
//      g_action_map_add_action (G_ACTION_MAP (action_group), action);
//      …
//      pad_controller = gtk_pad_controller_new (action_group, NULL);
//
//
//    The actions belonging to rings/strips will be activated with a parameter
//    of type G_VARIANT_TYPE_DOUBLE bearing the value of the given axis, it
//    is required that those are made stateful and accepting this Type.
type PadController interface {
	EventController

	// SetAction: adds an individual action to @controller. This action will
	// only be activated if the given button/ring/strip number in @index is
	// interacted while the current mode is @mode. -1 may be used for simple
	// cases, so the action is triggered on all modes.
	//
	// The given @label should be considered user-visible, so
	// internationalization rules apply. Some windowing systems may be able to
	// use those for user feedback.
	SetAction(_type PadActionType, index int, mode int, label string, actionName string)
	// SetActionEntries: this is a convenience function to add a group of action
	// entries on @controller. See PadActionEntry and
	// gtk_pad_controller_set_action().
	SetActionEntries(entries []PadActionEntry)
}

type padController struct {
	eventController
}

func wrapPadController(obj *externglib.Object) PadController {
	return padController{eventController{*externglib.Object{obj}}}
}

func marshalPadController(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewPadController(group gio.ActionGroup, pad gdk.Device) PadController

func (p padController) SetAction(_type PadActionType, index int, mode int, label string, actionName string)

func (p padController) SetActionEntries(entries []PadActionEntry)

// PageSetup: a GtkPageSetup object stores the page size, orientation and
// margins. The idea is that you can get one of these from the page setup dialog
// and then pass it to the PrintOperation when printing. The benefit of
// splitting this out of the PrintSettings is that these affect the actual
// layout of the page, and thus need to be set long before user prints.
//
// Margins {#print-margins} The margins specified in this object are the “print
// margins”, i.e. the parts of the page that the printer cannot print on. These
// are different from the layout margins that a word processor uses; they are
// typically used to determine the minimal size for the layout margins
//
// To obtain a PageSetup use gtk_page_setup_new() to get the defaults, or use
// gtk_print_run_page_setup_dialog() to show the page setup dialog and receive
// the resulting page setup.
//
// A page setup dialog
//
//    static GtkPrintSettings *settings = NULL;
//    static GtkPageSetup *page_setup = NULL;
//
//    static void
//    do_page_setup (void)
//    {
//      GtkPageSetup *new_page_setup;
//
//      if (settings == NULL)
//        settings = gtk_print_settings_new ();
//
//      new_page_setup = gtk_print_run_page_setup_dialog (GTK_WINDOW (main_window),
//                                                        page_setup, settings);
//
//      if (page_setup)
//        g_object_unref (page_setup);
//
//      page_setup = new_page_setup;
//    }
//
type PageSetup interface {
	gextras.Objector

	// Copy: copies a PageSetup.
	Copy() PageSetup
	// BottomMargin: gets the bottom margin in units of @unit.
	BottomMargin(unit Unit) float64
	// LeftMargin: gets the left margin in units of @unit.
	LeftMargin(unit Unit) float64
	// Orientation: gets the page orientation of the PageSetup.
	Orientation() PageOrientation
	// PageHeight: returns the page height in units of @unit.
	//
	// Note that this function takes orientation and margins into consideration.
	// See gtk_page_setup_get_paper_height().
	PageHeight(unit Unit) float64
	// PageWidth: returns the page width in units of @unit.
	//
	// Note that this function takes orientation and margins into consideration.
	// See gtk_page_setup_get_paper_width().
	PageWidth(unit Unit) float64
	// PaperHeight: returns the paper height in units of @unit.
	//
	// Note that this function takes orientation, but not margins into
	// consideration. See gtk_page_setup_get_page_height().
	PaperHeight(unit Unit) float64
	// PaperSize: gets the paper size of the PageSetup.
	PaperSize() *PaperSize
	// PaperWidth: returns the paper width in units of @unit.
	//
	// Note that this function takes orientation, but not margins into
	// consideration. See gtk_page_setup_get_page_width().
	PaperWidth(unit Unit) float64
	// RightMargin: gets the right margin in units of @unit.
	RightMargin(unit Unit) float64
	// TopMargin: gets the top margin in units of @unit.
	TopMargin(unit Unit) float64
	// LoadFile: reads the page setup from the file @file_name. See
	// gtk_page_setup_to_file().
	LoadFile(fileName string) bool
	// LoadKeyFile: reads the page setup from the group @group_name in the key
	// file @key_file.
	LoadKeyFile(keyFile *glib.KeyFile, groupName string) bool
	// SetBottomMargin: sets the bottom margin of the PageSetup.
	SetBottomMargin(margin float64, unit Unit)
	// SetLeftMargin: sets the left margin of the PageSetup.
	SetLeftMargin(margin float64, unit Unit)
	// SetOrientation: sets the page orientation of the PageSetup.
	SetOrientation(orientation PageOrientation)
	// SetPaperSize: sets the paper size of the PageSetup without changing the
	// margins. See gtk_page_setup_set_paper_size_and_default_margins().
	SetPaperSize(size *PaperSize)
	// SetPaperSizeAndDefaultMargins: sets the paper size of the PageSetup and
	// modifies the margins according to the new paper size.
	SetPaperSizeAndDefaultMargins(size *PaperSize)
	// SetRightMargin: sets the right margin of the PageSetup.
	SetRightMargin(margin float64, unit Unit)
	// SetTopMargin: sets the top margin of the PageSetup.
	SetTopMargin(margin float64, unit Unit)
	// ToFile: this function saves the information from @setup to @file_name.
	ToFile(fileName string) bool
	// ToGvariant: serialize page setup to an a{sv} variant.
	ToGvariant() *glib.Variant
	// ToKeyFile: this function adds the page setup from @setup to @key_file.
	ToKeyFile(keyFile *glib.KeyFile, groupName string)
}

type pageSetup struct {
	*externglib.Object
}

func wrapPageSetup(obj *externglib.Object) PageSetup {
	return pageSetup{*externglib.Object{obj}}
}

func marshalPageSetup(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewPageSetup() PageSetup

func NewPageSetup(fileName string) PageSetup

func NewPageSetup(variant *glib.Variant) PageSetup

func NewPageSetup(keyFile *glib.KeyFile, groupName string) PageSetup

func (p pageSetup) Copy() PageSetup

func (p pageSetup) BottomMargin(unit Unit) float64

func (p pageSetup) LeftMargin(unit Unit) float64

func (p pageSetup) Orientation() PageOrientation

func (p pageSetup) PageHeight(unit Unit) float64

func (p pageSetup) PageWidth(unit Unit) float64

func (p pageSetup) PaperHeight(unit Unit) float64

func (p pageSetup) PaperSize() *PaperSize

func (p pageSetup) PaperWidth(unit Unit) float64

func (p pageSetup) RightMargin(unit Unit) float64

func (p pageSetup) TopMargin(unit Unit) float64

func (p pageSetup) LoadFile(fileName string) bool

func (p pageSetup) LoadKeyFile(keyFile *glib.KeyFile, groupName string) bool

func (p pageSetup) SetBottomMargin(margin float64, unit Unit)

func (p pageSetup) SetLeftMargin(margin float64, unit Unit)

func (p pageSetup) SetOrientation(orientation PageOrientation)

func (p pageSetup) SetPaperSize(size *PaperSize)

func (p pageSetup) SetPaperSizeAndDefaultMargins(size *PaperSize)

func (p pageSetup) SetRightMargin(margin float64, unit Unit)

func (p pageSetup) SetTopMargin(margin float64, unit Unit)

func (p pageSetup) ToFile(fileName string) bool

func (p pageSetup) ToGvariant() *glib.Variant

func (p pageSetup) ToKeyFile(keyFile *glib.KeyFile, groupName string)

// Paned has two panes, arranged either horizontally or vertically. The division
// between the two panes is adjustable by the user by dragging a handle.
//
// Child widgets are added to the panes of the widget with
// gtk_paned_set_start_child() and gtk_paned_set_end_child(). The division
// between the two children is set by default from the size requests of the
// children, but it can be adjusted by the user.
//
// A paned widget draws a separator between the two child widgets and a small
// handle that the user can drag to adjust the division. It does not draw any
// relief around the children or around the separator. (The space in which the
// separator is called the gutter.) Often, it is useful to put each child inside
// a Frame so that the gutter appears as a ridge. No separator is drawn if one
// of the children is missing.
//
// Each child has two options that can be set, @resize and @shrink. If @resize
// is true, then when the Paned is resized, that child will expand or shrink
// along with the paned widget. If @shrink is true, then that child can be made
// smaller than its requisition by the user. Setting @shrink to false allows the
// application to set a minimum size. If @resize is false for both children,
// then this is treated as if @resize is true for both children.
//
// The application can set the position of the slider as if it were set by the
// user, by calling gtk_paned_set_position().
//
// CSS nodes
//
//    paned
//    ├── <child>
//    ├── separator[.wide]
//    ╰── <child>
//
// GtkPaned has a main CSS node with name paned, and a subnode for the separator
// with name separator. The subnode gets a .wide style class when the paned is
// supposed to be wide.
//
// In horizontal orientation, the nodes are arranged based on the text
// direction, so in left-to-right mode, :first-child will select the leftmost
// child, while it will select the rightmost child in RTL layouts.
//
// Creating a paned widget with minimum sizes
//
//    GtkWidget *hpaned = gtk_paned_new (GTK_ORIENTATION_HORIZONTAL);
//    GtkWidget *frame1 = gtk_frame_new (NULL);
//    GtkWidget *frame2 = gtk_frame_new (NULL);
//
//    gtk_widget_set_size_request (hpaned, 200, -1);
//
//    gtk_paned_set_start_child (GTK_PANED (hpaned), frame1);
//    gtk_paned_set_start_child_resize (GTK_PANED (hpaned), TRUE);
//    gtk_paned_set_start_child_shrink (GTK_PANED (hpaned), FALSE);
//    gtk_widget_set_size_request (frame1, 50, -1);
//
//    gtk_paned_set_end_child (GTK_PANED (hpaned), frame2);
//    gtk_paned_set_end_child_resize (GTK_PANED (hpaned), FALSE);
//    gtk_paned_set_end_child_shrink (GTK_PANED (hpaned), FALSE);
//    gtk_widget_set_size_request (frame2, 50, -1);
//
type Paned interface {
	Widget

	// EndChild: retrieves the end child of the given Paned.
	//
	// See also: Paned:end-child
	EndChild() Widget
	// Position: obtains the position of the divider between the two panes.
	Position() int
	// ResizeEndChild: returns whether the end child can be resized.
	ResizeEndChild() bool
	// ResizeStartChild: returns whether the start child can be resized.
	ResizeStartChild() bool
	// ShrinkEndChild: returns whether the end child can be shrunk.
	ShrinkEndChild() bool
	// ShrinkStartChild: returns whether the start child can be shrunk.
	ShrinkStartChild() bool
	// StartChild: retrieves the start child of the given Paned.
	//
	// See also: Paned:start-child
	StartChild() Widget
	// WideHandle: gets the Paned:wide-handle property.
	WideHandle() bool
	// SetEndChild: sets the end child of @paned to @child.
	SetEndChild(child Widget)
	// SetPosition: sets the position of the divider between the two panes.
	SetPosition(position int)
	// SetResizeEndChild: sets the Paned:resize-end-child property
	SetResizeEndChild(resize bool)
	// SetResizeStartChild: sets the Paned:resize-start-child property
	SetResizeStartChild(resize bool)
	// SetShrinkEndChild: sets the Paned:shrink-end-child property
	SetShrinkEndChild(resize bool)
	// SetShrinkStartChild: sets the Paned:shrink-start-child property
	SetShrinkStartChild(resize bool)
	// SetStartChild: sets the start child of @paned to @child.
	SetStartChild(child Widget)
	// SetWideHandle: sets the Paned:wide-handle property.
	SetWideHandle(wide bool)
}

type paned struct {
	widget
}

func wrapPaned(obj *externglib.Object) Paned {
	return paned{widget{externglib.InitiallyUnowned{obj}}}
}

func marshalPaned(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewPaned(orientation Orientation) Paned

func (p paned) EndChild() Widget

func (p paned) Position() int

func (p paned) ResizeEndChild() bool

func (p paned) ResizeStartChild() bool

func (p paned) ShrinkEndChild() bool

func (p paned) ShrinkStartChild() bool

func (p paned) StartChild() Widget

func (p paned) WideHandle() bool

func (p paned) SetEndChild(child Widget)

func (p paned) SetPosition(position int)

func (p paned) SetResizeEndChild(resize bool)

func (p paned) SetResizeStartChild(resize bool)

func (p paned) SetShrinkEndChild(resize bool)

func (p paned) SetShrinkStartChild(resize bool)

func (p paned) SetStartChild(child Widget)

func (p paned) SetWideHandle(wide bool)

// PasswordEntry is entry that has been tailored for entering secrets. It does
// not show its contents in clear text, does not allow to copy it to the
// clipboard, and it shows a warning when Caps Lock is engaged. If the
// underlying platform allows it, GtkPasswordEntry will also place the text in a
// non-pageable memory area, to avoid it being written out to disk by the
// operating system.
//
// Optionally, it can offer a way to reveal the contents in clear text.
//
// GtkPasswordEntry provides only minimal API and should be used with the
// Editable API.
//
// CSS Nodes
//
//    entry.password
//    ╰── text
//        ├── image.caps-lock-indicator
//        ┊
//
// GtkPasswordEntry has a single CSS node with name entry that carries a
// .passwordstyle class. The text Css node below it has a child with name image
// and style class .caps-lock-indicator for the Caps Lock icon, and possibly
// other children.
//
//
// Accessibility
//
// GtkPasswordEntry uses the K_ACCESSIBLE_ROLE_TEXT_BOX role.
type PasswordEntry interface {
	Widget

	// ExtraMenu: gets the menu model set with
	// gtk_password_entry_set_extra_menu().
	ExtraMenu() gio.MenuModel
	// ShowPeekIcon: returns whether the entry is showing a clickable icon to
	// reveal the contents of the entry in clear text.
	ShowPeekIcon() bool
	// SetExtraMenu: sets a menu model to add when constructing the context menu
	// for @entry.
	SetExtraMenu(model gio.MenuModel)
	// SetShowPeekIcon: sets whether the entry should have a clickable icon to
	// show the contents of the entry in clear text.
	//
	// Setting this to false also hides the text again.
	SetShowPeekIcon(showPeekIcon bool)
}

type passwordEntry struct {
	widget
}

func wrapPasswordEntry(obj *externglib.Object) PasswordEntry {
	return passwordEntry{widget{externglib.InitiallyUnowned{obj}}}
}

func marshalPasswordEntry(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewPasswordEntry() PasswordEntry

func (p passwordEntry) ExtraMenu() gio.MenuModel

func (p passwordEntry) ShowPeekIcon() bool

func (p passwordEntry) SetExtraMenu(model gio.MenuModel)

func (p passwordEntry) SetShowPeekIcon(showPeekIcon bool)

// Picture: the Picture widget displays a Paintable. Many convenience functions
// are provided to make pictures simple to use. For example, if you want to load
// an image from a file, and then display that, there’s a convenience function
// to do this: |[<!-- language="C" --> GtkWidget *widget; widget =
// gtk_picture_new_for_filename ("myfile.png"); ]| If the file isn’t loaded
// successfully, the picture will contain a “broken image” icon similar to that
// used in many web browsers. If you want to handle errors in loading the file
// yourself, for example by displaying an error message, then load the image
// with gdk_texture_new_from_file(), then create the Picture with
// gtk_picture_new_for_paintable().
//
// Sometimes an application will want to avoid depending on external data files,
// such as image files. See the documentation of #GResource for details. In this
// case, gtk_picture_new_for_resource() and gtk_picture_set_resource() should be
// used.
//
// GtkPicture displays an image at its natural size. See Image if you want to
// display a fixed-size image, such as an icon.
//
//
// Sizing the paintable
//
// You can influence how the paintable is displayed inside the Picture. By
// turning off Picture:keep-aspect-ratio you can allow the paintable to get
// stretched. Picture:can-shrink can be unset to make sure that paintables are
// never made smaller than their ideal size - but be careful if you do not know
// the size of the paintable in use (like when displaying user-loaded images).
// This can easily cause the picture to grow larger than the screen. And
// Widget:halign and Widget:valign can be used to make sure the paintable
// doesn't fill all available space but is instead displayed at its original
// size.
//
//
// CSS nodes
//
// GtkPicture has a single CSS node with the name picture.
//
//
// Accessibility
//
// GtkPicture uses the K_ACCESSIBLE_ROLE_IMG role.
type Picture interface {
	Widget

	// AlternativeText: gets the alternative textual description of the picture
	// or returns nil if the picture cannot be described textually.
	AlternativeText() string
	// CanShrink: gets the value set via gtk_picture_set_can_shrink().
	CanShrink() bool
	// File: gets the #GFile currently displayed if @self is displaying a file.
	// If @self is not displaying a file, for example when
	// gtk_picture_set_paintable() was used, then nil is returned.
	File() gio.File
	// KeepAspectRatio: gets the value set via
	// gtk_picture_set_keep_aspect_ratio().
	KeepAspectRatio() bool
	// Paintable: gets the Paintable being displayed by the Picture.
	Paintable() gdk.Paintable
	// SetAlternativeText: sets an alternative textual description for the
	// picture contents. It is equivalent to the "alt" attribute for images on
	// websites.
	//
	// This text will be made available to accessibility tools.
	//
	// If the picture cannot be described textually, set this property to nil.
	SetAlternativeText(alternativeText string)
	// SetCanShrink: if set to true, the @self can be made smaller than its
	// contents. The contents will then be scaled down when rendering.
	//
	// If you want to still force a minimum size manually, consider using
	// gtk_widget_set_size_request().
	//
	// Also of note is that a similar function for growing does not exist
	// because the grow behavior can be controlled via gtk_widget_set_halign()
	// and gtk_widget_set_valign().
	SetCanShrink(canShrink bool)
	// SetFile: makes @self load and display @file.
	//
	// See gtk_picture_new_for_file() for details.
	SetFile(file gio.File)
	// SetFilename: makes @self load and display the given @filename.
	//
	// This is a utility function that calls gtk_picture_set_file().
	SetFilename(filename string)
	// SetKeepAspectRatio: if set to true, the @self will render its contents
	// according to their aspect ratio. That means that empty space may show up
	// at the top/bottom or left/right of @self.
	//
	// If set to false or if the contents provide no aspect ratio, the contents
	// will be stretched over the picture's whole area.
	SetKeepAspectRatio(keepAspectRatio bool)
	// SetPaintable: makes @self display the given @paintable. If @paintable is
	// nil, nothing will be displayed.
	//
	// See gtk_picture_new_for_paintable() for details.
	SetPaintable(paintable gdk.Paintable)
	// SetPixbuf: see gtk_picture_new_for_pixbuf() for details.
	//
	// This is a utility function that calls gtk_picture_set_paintable(),
	SetPixbuf(pixbuf gdkpixbuf.Pixbuf)
	// SetResource: makes @self load and display the resource at the given
	// @resource_path.
	//
	// This is a utility function that calls gtk_picture_set_file(),
	SetResource(resourcePath string)
}

type picture struct {
	widget
}

func wrapPicture(obj *externglib.Object) Picture {
	return picture{widget{externglib.InitiallyUnowned{obj}}}
}

func marshalPicture(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewPicture() Picture

func NewPicture(file gio.File) Picture

func NewPicture(filename string) Picture

func NewPicture(paintable gdk.Paintable) Picture

func NewPicture(pixbuf gdkpixbuf.Pixbuf) Picture

func NewPicture(resourcePath string) Picture

func (p picture) AlternativeText() string

func (p picture) CanShrink() bool

func (p picture) File() gio.File

func (p picture) KeepAspectRatio() bool

func (p picture) Paintable() gdk.Paintable

func (p picture) SetAlternativeText(alternativeText string)

func (p picture) SetCanShrink(canShrink bool)

func (p picture) SetFile(file gio.File)

func (p picture) SetFilename(filename string)

func (p picture) SetKeepAspectRatio(keepAspectRatio bool)

func (p picture) SetPaintable(paintable gdk.Paintable)

func (p picture) SetPixbuf(pixbuf gdkpixbuf.Pixbuf)

func (p picture) SetResource(resourcePath string)

// Popover: gtkPopover is a bubble-like context window, primarily meant to
// provide context-dependent information or options. Popovers are attached to a
// widget, set with gtk_widget_set_parent(). By default they will point to the
// whole widget area, although this behavior can be changed through
// gtk_popover_set_pointing_to().
//
// The position of a popover relative to the widget it is attached to can also
// be changed through gtk_popover_set_position().
//
// By default, Popover performs a grab, in order to ensure input events get
// redirected to it while it is shown, and also so the popover is dismissed in
// the expected situations (clicks outside the popover, or the Escape key being
// pressed). If no such modal behavior is desired on a popover,
// gtk_popover_set_autohide() may be called on it to tweak its behavior.
//
//
// GtkPopover as menu replacement
//
// GtkPopover is often used to replace menus. The best was to do this is to use
// the PopoverMenu subclass which supports being populated from a Model with
// gtk_popover_menu_new_from_model().
//
//
//    <section>
//      <attribute name="display-hint">horizontal-buttons</attribute>
//      <item>
//        <attribute name="label">Cut</attribute>
//        <attribute name="action">app.cut</attribute>
//        <attribute name="verb-icon">edit-cut-symbolic</attribute>
//      </item>
//      <item>
//        <attribute name="label">Copy</attribute>
//        <attribute name="action">app.copy</attribute>
//        <attribute name="verb-icon">edit-copy-symbolic</attribute>
//      </item>
//      <item>
//        <attribute name="label">Paste</attribute>
//        <attribute name="action">app.paste</attribute>
//        <attribute name="verb-icon">edit-paste-symbolic</attribute>
//      </item>
//    </section>
//
// CSS nodes
//
//    popover[.menu]
//    ├── arrow
//    ╰── contents.background
//        ╰── <child>
//
// The contents child node always gets the .background style class and the
// popover itself gets the .menu style class if the popover is menu-like (i.e.
// PopoverMenu).
//
// Particular uses of GtkPopover, such as touch selection popups or magnifiers
// in Entry or TextView get style classes like .touch-selection or .magnifier to
// differentiate from plain popovers.
//
// When styling a popover directly, the popover node should usually not have any
// background.
//
// Note that, in order to accomplish appropriate arrow visuals, Popover uses
// custom drawing for the arrow node. This makes it possible for the arrow to
// change its shape dynamically, but it also limits the possibilities of styling
// it using CSS. In particular, the arrow gets drawn over the content node's
// border so they look like one shape, which means that the border-width of the
// content node and the arrow node should be the same. The arrow also does not
// support any border shape other than solid, no border-radius, only one border
// width (border-bottom-width is used) and no box-shadow.
type Popover interface {
	Widget

	// Autohide: returns whether the popover is modal.
	//
	// See gtk_popover_set_autohide() for the implications of this.
	Autohide() bool
	// CascadePopdown: returns whether the popover will close after a modal
	// child is closed.
	CascadePopdown() bool
	// Child: gets the child widget of @popover.
	Child() Widget
	// HasArrow: gets whether this popover is showing an arrow pointing at the
	// widget that it is relative to.
	HasArrow() bool
	// MnemonicsVisible: gets the value of the Popover:mnemonics-visible
	// property.
	MnemonicsVisible() bool
	// Offset: gets the offset previous set with gtk_popover_set_offset().
	Offset() (xOffset int, yOffset int)
	// PointingTo: if a rectangle to point to has been set, this function will
	// return true and fill in @rect with such rectangle, otherwise it will
	// return false and fill in @rect with the attached widget coordinates.
	PointingTo() (rect gdk.Rectangle, ok bool)
	// Position: returns the preferred position of @popover.
	Position() PositionType
	// Popdown: pops @popover down.This is different than a gtk_widget_hide()
	// call in that it shows the popover with a transition. If you want to hide
	// the popover without a transition, use gtk_widget_hide().
	Popdown()
	// Popup: pops @popover up. This is different than a gtk_widget_show() call
	// in that it shows the popover with a transition. If you want to show the
	// popover without a transition, use gtk_widget_show().
	Popup()
	// Present: presents the popover to the user.
	Present()
	// SetAutohide: sets whether @popover is modal.
	//
	// A modal popover will grab the keyboard focus on it when being displayed.
	// Clicking outside the popover area or pressing Esc will dismiss the
	// popover.
	//
	// Called this function on an already showing popup with a new autohide
	// value different from the current one, will cause the popup to be hidden.
	SetAutohide(autohide bool)
	// SetCascadePopdown: if @cascade_popdown is UE, the popover will be closed
	// when a child modal popover is closed. If LSE, @popover will stay visible.
	SetCascadePopdown(cascadePopdown bool)
	// SetChild: sets the child widget of @popover.
	SetChild(child Widget)
	// SetDefaultWidget: the default widget is the widget that’s activated when
	// the user presses Enter in a dialog (for example). This function sets or
	// unsets the default widget for a Popover.
	SetDefaultWidget(widget Widget)
	// SetHasArrow: sets whether this popover should draw an arrow pointing at
	// the widget it is relative to.
	SetHasArrow(hasArrow bool)
	// SetMnemonicsVisible: sets the Popover:mnemonics-visible property.
	SetMnemonicsVisible(mnemonicsVisible bool)
	// SetOffset: sets the offset to use when calculating the position of the
	// popover.
	//
	// These values are used when preparing the PopupLayout for positioning the
	// popover.
	SetOffset(xOffset int, yOffset int)
	// SetPointingTo: sets the rectangle that @popover will point to, in the
	// coordinate space of the @popover parent.
	SetPointingTo(rect *gdk.Rectangle)
	// SetPosition: sets the preferred position for @popover to appear. If the
	// @popover is currently visible, it will be immediately updated.
	//
	// This preference will be respected where possible, although on lack of
	// space (eg. if close to the window edges), the Popover may choose to
	// appear on the opposite side
	SetPosition(position PositionType)
}

type popover struct {
	widget
}

func wrapPopover(obj *externglib.Object) Popover {
	return popover{widget{externglib.InitiallyUnowned{obj}}}
}

func marshalPopover(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewPopover() Popover

func (p popover) Autohide() bool

func (p popover) CascadePopdown() bool

func (p popover) Child() Widget

func (p popover) HasArrow() bool

func (p popover) MnemonicsVisible() bool

func (p popover) Offset() (xOffset int, yOffset int)

func (p popover) PointingTo() (rect gdk.Rectangle, ok bool)

func (p popover) Position() PositionType

func (p popover) Popdown()

func (p popover) Popup()

func (p popover) Present()

func (p popover) SetAutohide(autohide bool)

func (p popover) SetCascadePopdown(cascadePopdown bool)

func (p popover) SetChild(child Widget)

func (p popover) SetDefaultWidget(widget Widget)

func (p popover) SetHasArrow(hasArrow bool)

func (p popover) SetMnemonicsVisible(mnemonicsVisible bool)

func (p popover) SetOffset(xOffset int, yOffset int)

func (p popover) SetPointingTo(rect *gdk.Rectangle)

func (p popover) SetPosition(position PositionType)

// PopoverMenu: gtkPopoverMenu is a subclass of Popover that treats its children
// like menus and allows switching between them. It can open submenus as
// traditional, nested submenus, or in a more touch-friendly sliding fashion.
//
// GtkPopoverMenu is meant to be used primarily with menu models, using
// gtk_popover_menu_new_from_model(). If you need to put other widgets such as
// SpinButton or Switch into a popover, use a plain Popover.
//
//
// Menu models
//
// The XML format understood by Builder for Model consists of a toplevel
// `<menu>` element, which contains one or more `<item>` elements. Each `<item>`
// element contains `<attribute>` and `<link>` elements with a mandatory name
// attribute. `<link>` elements have the same content model as `<menu>`. Instead
// of `<link name="submenu>` or `<link name="section">`, you can use `<submenu>`
// or `<section>` elements.
//
//    <menu id='app-menu'>
//      <section>
//        <item>
//          <attribute name='label' translatable='yes'>_New Window</attribute>
//          <attribute name='action'>app.new</attribute>
//        </item>
//        <item>
//          <attribute name='label' translatable='yes'>_About Sunny</attribute>
//          <attribute name='action'>app.about</attribute>
//        </item>
//        <item>
//          <attribute name='label' translatable='yes'>_Quit</attribute>
//          <attribute name='action'>app.quit</attribute>
//        </item>
//      </section>
//    </menu>
//
// Attribute values can be translated using gettext, like other Builder content.
// `<attribute>` elements can be marked for translation with a
// `translatable="yes"` attribute. It is also possible to specify message
// context and translator comments, using the context and comments attributes.
// To make use of this, the Builder must have been given the gettext domain to
// use.
//
// The following attributes are used when constructing menu items: - "label": a
// user-visible string to display - "action": the prefixed name of the action to
// trigger - "target": the parameter to use when activating the action - "icon"
// and "verb-icon": names of icons that may be displayed - "submenu-action":
// name of an action that may be used to determine if a submenu can be opened -
// "hidden-when": a string used to determine when the item will be hidden.
// Possible values include "action-disabled", "action-missing", "macos-menubar".
// This is mainly useful for exported menus, see gtk_application_set_menubar().
// - "custom": a string used to match against the ID of a custom child added
// with gtk_popover_menu_add_child(), gtk_popover_menu_bar_add_child(), or in
// the ui file with `<child type="ID">`.
//
// The following attributes are used when constructing sections: - "label": a
// user-visible string to use as section heading - "display-hint": a string used
// to determine special formatting for the section. Possible values include
// "horizontal-buttons", "circular-buttons" and "inline-buttons". They all
// indicate that section should be displayed as a horizontal row of buttons. -
// "text-direction": a string used to determine the TextDirection to use when
// "display-hint" is set to "horizontal-buttons". Possible values include "rtl",
// "ltr", and "none".
//
// The following attributes are used when constructing submenus: - "label": a
// user-visible string to display - "icon": icon name to display
//
// Menu items will also show accelerators, which are usually associated with
// actions via gtk_application_set_accels_for_action(),
// gtk_widget_class_add_binding_action() or
// gtk_shortcut_controller_add_shortcut().
//
//
// CSS Nodes
//
// PopoverMenu is just a subclass of Popover that adds custom content to it,
// therefore it has the same CSS nodes. It is one of the cases that add a .menu
// style class to the popover's main node.
//
//
// Accessibility
//
// GtkPopoverMenu uses the K_ACCESSIBLE_ROLE_MENU role, and its items use the
// K_ACCESSIBLE_ROLE_MENU_ITEM, K_ACCESSIBLE_ROLE_MENU_ITEM_CHECKBOX or
// K_ACCESSIBLE_ROLE_MENU_ITEM_RADIO roles, depending on the action they are
// connected to.
type PopoverMenu interface {
	Popover

	// AddChild: adds a custom widget to a generated menu.
	//
	// For this to work, the menu model of @popover must have an item with a
	// `custom` attribute that matches @id.
	AddChild(child Widget, id string) bool
	// MenuModel: returns the menu model used to populate the popover.
	MenuModel() gio.MenuModel
	// RemoveChild: removes a widget that has previously been added with
	// gtk_popover_menu_add_child().
	RemoveChild(child Widget) bool
	// SetMenuModel: sets a new menu model on @popover.
	//
	// The existing contents of @popover are removed, and the @popover is
	// populated with new contents according to @model.
	SetMenuModel(model gio.MenuModel)
}

type popoverMenu struct {
	popover
}

func wrapPopoverMenu(obj *externglib.Object) PopoverMenu {
	return popoverMenu{popover{widget{externglib.InitiallyUnowned{obj}}}}
}

func marshalPopoverMenu(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewPopoverMenu(model gio.MenuModel) PopoverMenu

func NewPopoverMenu(model gio.MenuModel, flags PopoverMenuFlags) PopoverMenu

func (p popoverMenu) AddChild(child Widget, id string) bool

func (p popoverMenu) MenuModel() gio.MenuModel

func (p popoverMenu) RemoveChild(child Widget) bool

func (p popoverMenu) SetMenuModel(model gio.MenuModel)

// PopoverMenuBar: gtkPopoverMenuBar presents a horizontal bar of items that pop
// up popover menus when clicked.
//
// The only way to create instances of GtkPopoverMenuBar is from a Model.
//
// CSS nodes
//
//    menubar
//    ├── item[.active]
//    ┊   ╰── popover
//    ╰── item
//        ╰── popover
//
// GtkPopoverMenuBar has a single CSS node with name menubar, below which each
// item has its CSS node, and below that the corresponding popover.
//
// The item whose popover is currently open gets the .active style class.
//
//
// Accessibility
//
// GtkPopoverMenuBar uses the K_ACCESSIBLE_ROLE_MENU_BAR role, the menu items
// use the K_ACCESSIBLE_ROLE_MENU_ITEM role and the menus use the
// K_ACCESSIBLE_ROLE_MENU role.
type PopoverMenuBar interface {
	Widget

	// AddChild: adds a custom widget to a generated menubar.
	//
	// For this to work, the menu model of @bar must have an item with a
	// `custom` attribute that matches @id.
	AddChild(child Widget, id string) bool
	// MenuModel: returns the model from which the contents of @bar are taken.
	MenuModel() gio.MenuModel
	// RemoveChild: removes a widget that has previously been added with
	// gtk_popover_menu_bar_add_child().
	RemoveChild(child Widget) bool
	// SetMenuModel: sets a menu model from which @bar should take its contents.
	SetMenuModel(model gio.MenuModel)
}

type popoverMenuBar struct {
	widget
}

func wrapPopoverMenuBar(obj *externglib.Object) PopoverMenuBar {
	return popoverMenuBar{widget{externglib.InitiallyUnowned{obj}}}
}

func marshalPopoverMenuBar(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewPopoverMenuBar(model gio.MenuModel) PopoverMenuBar

func (p popoverMenuBar) AddChild(child Widget, id string) bool

func (p popoverMenuBar) MenuModel() gio.MenuModel

func (p popoverMenuBar) RemoveChild(child Widget) bool

func (p popoverMenuBar) SetMenuModel(model gio.MenuModel)

// PrintContext: a GtkPrintContext encapsulates context information that is
// required when drawing pages for printing, such as the cairo context and
// important parameters like page size and resolution. It also lets you easily
// create Layout and Context objects that match the font metrics of the cairo
// surface.
//
// GtkPrintContext objects gets passed to the PrintOperation::begin-print,
// PrintOperation::end-print, PrintOperation::request-page-setup and
// PrintOperation::draw-page signals on the PrintOperation.
//
// Using GtkPrintContext in a PrintOperation::draw-page callback
//
//    static void
//    draw_page (GtkPrintOperation *operation,
//    	   GtkPrintContext   *context,
//    	   int                page_nr)
//    {
//      cairo_t *cr;
//      PangoLayout *layout;
//      PangoFontDescription *desc;
//
//      cr = gtk_print_context_get_cairo_context (context);
//
//      // Draw a red rectangle, as wide as the paper (inside the margins)
//      cairo_set_source_rgb (cr, 1.0, 0, 0);
//      cairo_rectangle (cr, 0, 0, gtk_print_context_get_width (context), 50);
//
//      cairo_fill (cr);
//
//      // Draw some lines
//      cairo_move_to (cr, 20, 10);
//      cairo_line_to (cr, 40, 20);
//      cairo_arc (cr, 60, 60, 20, 0, M_PI);
//      cairo_line_to (cr, 80, 20);
//
//      cairo_set_source_rgb (cr, 0, 0, 0);
//      cairo_set_line_width (cr, 5);
//      cairo_set_line_cap (cr, CAIRO_LINE_CAP_ROUND);
//      cairo_set_line_join (cr, CAIRO_LINE_JOIN_ROUND);
//
//      cairo_stroke (cr);
//
//      // Draw some text
//      layout = gtk_print_context_create_pango_layout (context);
//      pango_layout_set_text (layout, "Hello World! Printing is easy", -1);
//      desc = pango_font_description_from_string ("sans 28");
//      pango_layout_set_font_description (layout, desc);
//      pango_font_description_free (desc);
//
//      cairo_move_to (cr, 30, 20);
//      pango_cairo_layout_path (cr, layout);
//
//      // Font Outline
//      cairo_set_source_rgb (cr, 0.93, 1.0, 0.47);
//      cairo_set_line_width (cr, 0.5);
//      cairo_stroke_preserve (cr);
//
//      // Font Fill
//      cairo_set_source_rgb (cr, 0, 0.0, 1.0);
//      cairo_fill (cr);
//
//      g_object_unref (layout);
//    }
//
type PrintContext interface {
	gextras.Objector

	// CreatePangoContext: creates a new Context that can be used with the
	// PrintContext.
	CreatePangoContext() pango.Context
	// CreatePangoLayout: creates a new Layout that is suitable for use with the
	// PrintContext.
	CreatePangoLayout() pango.Layout
	// CairoContext: obtains the cairo context that is associated with the
	// PrintContext.
	CairoContext() *cairo.Context
	// DPIX: obtains the horizontal resolution of the PrintContext, in dots per
	// inch.
	DPIX() float64
	// DPIY: obtains the vertical resolution of the PrintContext, in dots per
	// inch.
	DPIY() float64
	// HardMargins: obtains the hardware printer margins of the PrintContext, in
	// units.
	HardMargins() (top float64, bottom float64, left float64, right float64, ok bool)
	// Height: obtains the height of the PrintContext, in pixels.
	Height() float64
	// PageSetup: obtains the PageSetup that determines the page dimensions of
	// the PrintContext.
	PageSetup() PageSetup
	// PangoFontmap: returns a FontMap that is suitable for use with the
	// PrintContext.
	PangoFontmap() pango.FontMap
	// Width: obtains the width of the PrintContext, in pixels.
	Width() float64
	// SetCairoContext: sets a new cairo context on a print context.
	//
	// This function is intended to be used when implementing an internal print
	// preview, it is not needed for printing, since GTK itself creates a
	// suitable cairo context in that case.
	SetCairoContext(cr *cairo.Context, dpiX float64, dpiY float64)
}

type printContext struct {
	*externglib.Object
}

func wrapPrintContext(obj *externglib.Object) PrintContext {
	return printContext{*externglib.Object{obj}}
}

func marshalPrintContext(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func (p printContext) CreatePangoContext() pango.Context

func (p printContext) CreatePangoLayout() pango.Layout

func (p printContext) CairoContext() *cairo.Context

func (p printContext) DPIX() float64

func (p printContext) DPIY() float64

func (p printContext) HardMargins() (top float64, bottom float64, left float64, right float64, ok bool)

func (p printContext) Height() float64

func (p printContext) PageSetup() PageSetup

func (p printContext) PangoFontmap() pango.FontMap

func (p printContext) Width() float64

func (p printContext) SetCairoContext(cr *cairo.Context, dpiX float64, dpiY float64)

// PrintOperation: gtkPrintOperation is the high-level, portable printing API.
// It looks a bit different than other GTK dialogs such as the FileChooser,
// since some platforms don’t expose enough infrastructure to implement a good
// print dialog. On such platforms, GtkPrintOperation uses the native print
// dialog. On platforms which do not provide a native print dialog, GTK uses its
// own, see PrintUnixDialog.
//
// The typical way to use the high-level printing API is to create a
// GtkPrintOperation object with gtk_print_operation_new() when the user selects
// to print. Then you set some properties on it, e.g. the page size, any
// PrintSettings from previous print operations, the number of pages, the
// current page, etc.
//
// Then you start the print operation by calling gtk_print_operation_run(). It
// will then show a dialog, let the user select a printer and options. When the
// user finished the dialog various signals will be emitted on the
// PrintOperation, the main one being PrintOperation::draw-page, which you are
// supposed to catch and render the page on the provided PrintContext using
// Cairo.
//
// The high-level printing API
//
//    static GtkPrintSettings *settings = NULL;
//
//    static void
//    do_print (void)
//    {
//      GtkPrintOperation *print;
//      GtkPrintOperationResult res;
//
//      print = gtk_print_operation_new ();
//
//      if (settings != NULL)
//        gtk_print_operation_set_print_settings (print, settings);
//
//      g_signal_connect (print, "begin_print", G_CALLBACK (begin_print), NULL);
//      g_signal_connect (print, "draw_page", G_CALLBACK (draw_page), NULL);
//
//      res = gtk_print_operation_run (print, GTK_PRINT_OPERATION_ACTION_PRINT_DIALOG,
//                                     GTK_WINDOW (main_window), NULL);
//
//      if (res == GTK_PRINT_OPERATION_RESULT_APPLY)
//        {
//          if (settings != NULL)
//            g_object_unref (settings);
//          settings = g_object_ref (gtk_print_operation_get_print_settings (print));
//        }
//
//      g_object_unref (print);
//    }
//
//
// By default GtkPrintOperation uses an external application to do print
// preview. To implement a custom print preview, an application must connect to
// the preview signal. The functions gtk_print_operation_preview_render_page(),
// gtk_print_operation_preview_end_preview() and
// gtk_print_operation_preview_is_selected() are useful when implementing a
// print preview.
type PrintOperation interface {
	gextras.Objector

	// Cancel: cancels a running print operation. This function may be called
	// from a PrintOperation::begin-print, PrintOperation::paginate or
	// PrintOperation::draw-page signal handler to stop the currently running
	// print operation.
	Cancel()
	// DrawPageFinish: signalize that drawing of particular page is complete.
	//
	// It is called after completion of page drawing (e.g. drawing in another
	// thread). If gtk_print_operation_set_defer_drawing() was called before,
	// then this function has to be called by application. In another case it is
	// called by the library itself.
	DrawPageFinish()
	// DefaultPageSetup: returns the default page setup, see
	// gtk_print_operation_set_default_page_setup().
	DefaultPageSetup() PageSetup
	// EmbedPageSetup: gets the value of PrintOperation:embed-page-setup
	// property.
	EmbedPageSetup() bool
	// Error: call this when the result of a print operation is
	// GTK_PRINT_OPERATION_RESULT_ERROR, either as returned by
	// gtk_print_operation_run(), or in the PrintOperation::done signal handler.
	// The returned #GError will contain more details on what went wrong.
	Error()
	// HasSelection: gets the value of PrintOperation:has-selection property.
	HasSelection() bool
	// NPagesToPrint: returns the number of pages that will be printed.
	//
	// Note that this value is set during print preparation phase
	// (GTK_PRINT_STATUS_PREPARING), so this function should never be called
	// before the data generation phase (GTK_PRINT_STATUS_GENERATING_DATA). You
	// can connect to the PrintOperation::status-changed signal and call
	// gtk_print_operation_get_n_pages_to_print() when print status is
	// GTK_PRINT_STATUS_GENERATING_DATA. This is typically used to track the
	// progress of print operation.
	NPagesToPrint() int
	// PrintSettings: returns the current print settings.
	//
	// Note that the return value is nil until either
	// gtk_print_operation_set_print_settings() or gtk_print_operation_run()
	// have been called.
	PrintSettings() PrintSettings
	// Status: returns the status of the print operation. Also see
	// gtk_print_operation_get_status_string().
	Status() PrintStatus
	// StatusString: returns a string representation of the status of the print
	// operation. The string is translated and suitable for displaying the print
	// status e.g. in a Statusbar.
	//
	// Use gtk_print_operation_get_status() to obtain a status value that is
	// suitable for programmatic use.
	StatusString() string
	// SupportSelection: gets the value of PrintOperation:support-selection
	// property.
	SupportSelection() bool
	// IsFinished: a convenience function to find out if the print operation is
	// finished, either successfully (GTK_PRINT_STATUS_FINISHED) or
	// unsuccessfully (GTK_PRINT_STATUS_FINISHED_ABORTED).
	//
	// Note: when you enable print status tracking the print operation can be in
	// a non-finished state even after done has been called, as the operation
	// status then tracks the print job status on the printer.
	IsFinished() bool
	// Run: runs the print operation, by first letting the user modify print
	// settings in the print dialog, and then print the document.
	//
	// Normally that this function does not return until the rendering of all
	// pages is complete. You can connect to the PrintOperation::status-changed
	// signal on @op to obtain some information about the progress of the print
	// operation. Furthermore, it may use a recursive mainloop to show the print
	// dialog.
	//
	//    if (settings != NULL)
	//      gtk_print_operation_set_print_settings (print, settings);
	//
	//    if (page_setup != NULL)
	//      gtk_print_operation_set_default_page_setup (print, page_setup);
	//
	//    g_signal_connect (print, "begin-print",
	//                      G_CALLBACK (begin_print), &data);
	//    g_signal_connect (print, "draw-page",
	//                      G_CALLBACK (draw_page), &data);
	//
	//    res = gtk_print_operation_run (print,
	//                                   GTK_PRINT_OPERATION_ACTION_PRINT_DIALOG,
	//                                   parent,
	//                                   &error);
	//
	//    if (res == GTK_PRINT_OPERATION_RESULT_ERROR)
	//     {
	//       error_dialog = gtk_message_dialog_new (GTK_WINDOW (parent),
	//      			                     GTK_DIALOG_DESTROY_WITH_PARENT,
	//    					     GTK_MESSAGE_ERROR,
	//    					     GTK_BUTTONS_CLOSE,
	//    					     "Error printing file:\ns",
	//    					     error->message);
	//       g_signal_connect (error_dialog, "response",
	//                         G_CALLBACK (gtk_window_destroy), NULL);
	//       gtk_widget_show (error_dialog);
	//       g_error_free (error);
	//     }
	//    else if (res == GTK_PRINT_OPERATION_RESULT_APPLY)
	//     {
	//       if (settings != NULL)
	//    g_object_unref (settings);
	//       settings = g_object_ref (gtk_print_operation_get_print_settings (print));
	//     }
	//
	// Note that gtk_print_operation_run() can only be called once on a given
	// PrintOperation.
	Run(action PrintOperationAction, parent Window) PrintOperationResult
	// SetAllowAsync: sets whether the gtk_print_operation_run() may return
	// before the print operation is completed. Note that some platforms may not
	// allow asynchronous operation.
	SetAllowAsync(allowAsync bool)
	// SetCurrentPage: sets the current page.
	//
	// If this is called before gtk_print_operation_run(), the user will be able
	// to select to print only the current page.
	//
	// Note that this only makes sense for pre-paginated documents.
	SetCurrentPage(currentPage int)
	// SetCustomTabLabel: sets the label for the tab holding custom widgets.
	SetCustomTabLabel(label string)
	// SetDefaultPageSetup: makes @default_page_setup the default page setup for
	// @op.
	//
	// This page setup will be used by gtk_print_operation_run(), but it can be
	// overridden on a per-page basis by connecting to the
	// PrintOperation::request-page-setup signal.
	SetDefaultPageSetup(defaultPageSetup PageSetup)
	// SetDeferDrawing: sets up the PrintOperation to wait for calling of
	// gtk_print_operation_draw_page_finish() from application. It can be used
	// for drawing page in another thread.
	//
	// This function must be called in the callback of “draw-page” signal.
	SetDeferDrawing()
	// SetEmbedPageSetup: embed page size combo box and orientation combo box
	// into page setup page. Selected page setup is stored as default page setup
	// in PrintOperation.
	SetEmbedPageSetup(embed bool)
	// SetExportFilename: sets up the PrintOperation to generate a file instead
	// of showing the print dialog. The intended use of this function is for
	// implementing “Export to PDF” actions. Currently, PDF is the only
	// supported format.
	//
	// “Print to PDF” support is independent of this and is done by letting the
	// user pick the “Print to PDF” item from the list of printers in the print
	// dialog.
	SetExportFilename(filename string)
	// SetHasSelection: sets whether there is a selection to print.
	//
	// Application has to set number of pages to which the selection will draw
	// by gtk_print_operation_set_n_pages() in a callback of
	// PrintOperation::begin-print.
	SetHasSelection(hasSelection bool)
	// SetJobName: sets the name of the print job. The name is used to identify
	// the job (e.g. in monitoring applications like eggcups).
	//
	// If you don’t set a job name, GTK picks a default one by numbering
	// successive print jobs.
	SetJobName(jobName string)
	// SetNPages: sets the number of pages in the document.
	//
	// This must be set to a positive number before the rendering starts. It may
	// be set in a PrintOperation::begin-print signal handler.
	//
	// Note that the page numbers passed to the
	// PrintOperation::request-page-setup and PrintOperation::draw-page signals
	// are 0-based, i.e. if the user chooses to print all pages, the last
	// ::draw-page signal will be for page @n_pages - 1.
	SetNPages(nPages int)
	// SetPrintSettings: sets the print settings for @op. This is typically used
	// to re-establish print settings from a previous print operation, see
	// gtk_print_operation_run().
	SetPrintSettings(printSettings PrintSettings)
	// SetShowProgress: if @show_progress is true, the print operation will show
	// a progress dialog during the print operation.
	SetShowProgress(showProgress bool)
	// SetSupportSelection: sets whether selection is supported by
	// PrintOperation.
	SetSupportSelection(supportSelection bool)
	// SetTrackPrintStatus: if track_status is true, the print operation will
	// try to continue report on the status of the print job in the printer
	// queues and printer. This can allow your application to show things like
	// “out of paper” issues, and when the print job actually reaches the
	// printer.
	//
	// This function is often implemented using some form of polling, so it
	// should not be enabled unless needed.
	SetTrackPrintStatus(trackStatus bool)
	// SetUnit: sets up the transformation for the cairo context obtained from
	// PrintContext in such a way that distances are measured in units of @unit.
	SetUnit(unit Unit)
	// SetUseFullPage: if @full_page is true, the transformation for the cairo
	// context obtained from PrintContext puts the origin at the top left corner
	// of the page (which may not be the top left corner of the sheet, depending
	// on page orientation and the number of pages per sheet). Otherwise, the
	// origin is at the top left corner of the imageable area (i.e. inside the
	// margins).
	SetUseFullPage(fullPage bool)
}

type printOperation struct {
	*externglib.Object
}

func wrapPrintOperation(obj *externglib.Object) PrintOperation {
	return printOperation{*externglib.Object{obj}}
}

func marshalPrintOperation(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewPrintOperation() PrintOperation

func (p printOperation) Cancel()

func (p printOperation) DrawPageFinish()

func (p printOperation) DefaultPageSetup() PageSetup

func (p printOperation) EmbedPageSetup() bool

func (p printOperation) Error()

func (p printOperation) HasSelection() bool

func (p printOperation) NPagesToPrint() int

func (p printOperation) PrintSettings() PrintSettings

func (p printOperation) Status() PrintStatus

func (p printOperation) StatusString() string

func (p printOperation) SupportSelection() bool

func (p printOperation) IsFinished() bool

func (p printOperation) Run(action PrintOperationAction, parent Window) PrintOperationResult

func (p printOperation) SetAllowAsync(allowAsync bool)

func (p printOperation) SetCurrentPage(currentPage int)

func (p printOperation) SetCustomTabLabel(label string)

func (p printOperation) SetDefaultPageSetup(defaultPageSetup PageSetup)

func (p printOperation) SetDeferDrawing()

func (p printOperation) SetEmbedPageSetup(embed bool)

func (p printOperation) SetExportFilename(filename string)

func (p printOperation) SetHasSelection(hasSelection bool)

func (p printOperation) SetJobName(jobName string)

func (p printOperation) SetNPages(nPages int)

func (p printOperation) SetPrintSettings(printSettings PrintSettings)

func (p printOperation) SetShowProgress(showProgress bool)

func (p printOperation) SetSupportSelection(supportSelection bool)

func (p printOperation) SetTrackPrintStatus(trackStatus bool)

func (p printOperation) SetUnit(unit Unit)

func (p printOperation) SetUseFullPage(fullPage bool)

// PrintSettings: a GtkPrintSettings object represents the settings of a print
// dialog in a system-independent way. The main use for this object is that once
// you’ve printed you can get a settings object that represents the settings the
// user chose, and the next time you print you can pass that object in so that
// the user doesn’t have to re-set all his settings.
//
// Its also possible to enumerate the settings so that you can easily save the
// settings for the next time your app runs, or even store them in a document.
// The predefined keys try to use shared values as much as possible so that
// moving such a document between systems still works.
type PrintSettings interface {
	gextras.Objector

	// Copy: copies a PrintSettings object.
	Copy() PrintSettings
	// Foreach: calls @func for each key-value pair of @settings.
	Foreach(_func PrintSettingsFunc)
	// Get: looks up the string value associated with @key.
	Get(key string) string
	// Bool: returns the boolean represented by the value that is associated
	// with @key.
	//
	// The string “true” represents true, any other string false.
	Bool(key string) bool
	// Collate: gets the value of GTK_PRINT_SETTINGS_COLLATE.
	Collate() bool
	// DefaultSource: gets the value of GTK_PRINT_SETTINGS_DEFAULT_SOURCE.
	DefaultSource() string
	// Dither: gets the value of GTK_PRINT_SETTINGS_DITHER.
	Dither() string
	// Double: returns the double value associated with @key, or 0.
	Double(key string) float64
	// DoubleWithDefault: returns the floating point number represented by the
	// value that is associated with @key, or @default_val if the value does not
	// represent a floating point number.
	//
	// Floating point numbers are parsed with g_ascii_strtod().
	DoubleWithDefault(key string, def float64) float64
	// Duplex: gets the value of GTK_PRINT_SETTINGS_DUPLEX.
	Duplex() PrintDuplex
	// Finishings: gets the value of GTK_PRINT_SETTINGS_FINISHINGS.
	Finishings() string
	// Int: returns the integer value of @key, or 0.
	Int(key string) int
	// IntWithDefault: returns the value of @key, interpreted as an integer, or
	// the default value.
	IntWithDefault(key string, def int) int
	// Length: returns the value associated with @key, interpreted as a length.
	// The returned value is converted to @units.
	Length(key string, unit Unit) float64
	// MediaType: gets the value of GTK_PRINT_SETTINGS_MEDIA_TYPE.
	//
	// The set of media types is defined in PWG 5101.1-2002 PWG.
	MediaType() string
	// NCopies: gets the value of GTK_PRINT_SETTINGS_N_COPIES.
	NCopies() int
	// NumberUp: gets the value of GTK_PRINT_SETTINGS_NUMBER_UP.
	NumberUp() int
	// NumberUpLayout: gets the value of GTK_PRINT_SETTINGS_NUMBER_UP_LAYOUT.
	NumberUpLayout() NumberUpLayout
	// Orientation: get the value of GTK_PRINT_SETTINGS_ORIENTATION, converted
	// to a PageOrientation.
	Orientation() PageOrientation
	// OutputBin: gets the value of GTK_PRINT_SETTINGS_OUTPUT_BIN.
	OutputBin() string
	// PageRanges: gets the value of GTK_PRINT_SETTINGS_PAGE_RANGES.
	PageRanges() (numRanges int, pageRanges []PageRange)
	// PageSet: gets the value of GTK_PRINT_SETTINGS_PAGE_SET.
	PageSet() PageSet
	// PaperHeight: gets the value of GTK_PRINT_SETTINGS_PAPER_HEIGHT, converted
	// to @unit.
	PaperHeight(unit Unit) float64
	// PaperSize: gets the value of GTK_PRINT_SETTINGS_PAPER_FORMAT, converted
	// to a PaperSize.
	PaperSize() *PaperSize
	// PaperWidth: gets the value of GTK_PRINT_SETTINGS_PAPER_WIDTH, converted
	// to @unit.
	PaperWidth(unit Unit) float64
	// PrintPages: gets the value of GTK_PRINT_SETTINGS_PRINT_PAGES.
	PrintPages() PrintPages
	// Printer: convenience function to obtain the value of
	// GTK_PRINT_SETTINGS_PRINTER.
	Printer() string
	// PrinterLpi: gets the value of GTK_PRINT_SETTINGS_PRINTER_LPI.
	PrinterLpi() float64
	// Quality: gets the value of GTK_PRINT_SETTINGS_QUALITY.
	Quality() PrintQuality
	// Resolution: gets the value of GTK_PRINT_SETTINGS_RESOLUTION.
	Resolution() int
	// ResolutionX: gets the value of GTK_PRINT_SETTINGS_RESOLUTION_X.
	ResolutionX() int
	// ResolutionY: gets the value of GTK_PRINT_SETTINGS_RESOLUTION_Y.
	ResolutionY() int
	// Reverse: gets the value of GTK_PRINT_SETTINGS_REVERSE.
	Reverse() bool
	// Scale: gets the value of GTK_PRINT_SETTINGS_SCALE.
	Scale() float64
	// UseColor: gets the value of GTK_PRINT_SETTINGS_USE_COLOR.
	UseColor() bool
	// HasKey: returns true, if a value is associated with @key.
	HasKey(key string) bool
	// LoadFile: reads the print settings from @file_name. If the file could not
	// be loaded then error is set to either a Error or FileError. See
	// gtk_print_settings_to_file().
	LoadFile(fileName string) bool
	// LoadKeyFile: reads the print settings from the group @group_name in
	// @key_file. If the file could not be loaded then error is set to either a
	// Error or FileError.
	LoadKeyFile(keyFile *glib.KeyFile, groupName string) bool
	// Set: associates @value with @key.
	Set(key string, value string)
	// SetBool: sets @key to a boolean value.
	SetBool(key string, value bool)
	// SetCollate: sets the value of GTK_PRINT_SETTINGS_COLLATE.
	SetCollate(collate bool)
	// SetDefaultSource: sets the value of GTK_PRINT_SETTINGS_DEFAULT_SOURCE.
	SetDefaultSource(defaultSource string)
	// SetDither: sets the value of GTK_PRINT_SETTINGS_DITHER.
	SetDither(dither string)
	// SetDouble: sets @key to a double value.
	SetDouble(key string, value float64)
	// SetDuplex: sets the value of GTK_PRINT_SETTINGS_DUPLEX.
	SetDuplex(duplex PrintDuplex)
	// SetFinishings: sets the value of GTK_PRINT_SETTINGS_FINISHINGS.
	SetFinishings(finishings string)
	// SetInt: sets @key to an integer value.
	SetInt(key string, value int)
	// SetLength: associates a length in units of @unit with @key.
	SetLength(key string, value float64, unit Unit)
	// SetMediaType: sets the value of GTK_PRINT_SETTINGS_MEDIA_TYPE.
	//
	// The set of media types is defined in PWG 5101.1-2002 PWG.
	SetMediaType(mediaType string)
	// SetNCopies: sets the value of GTK_PRINT_SETTINGS_N_COPIES.
	SetNCopies(numCopies int)
	// SetNumberUp: sets the value of GTK_PRINT_SETTINGS_NUMBER_UP.
	SetNumberUp(numberUp int)
	// SetNumberUpLayout: sets the value of GTK_PRINT_SETTINGS_NUMBER_UP_LAYOUT.
	SetNumberUpLayout(numberUpLayout NumberUpLayout)
	// SetOrientation: sets the value of GTK_PRINT_SETTINGS_ORIENTATION.
	SetOrientation(orientation PageOrientation)
	// SetOutputBin: sets the value of GTK_PRINT_SETTINGS_OUTPUT_BIN.
	SetOutputBin(outputBin string)
	// SetPageRanges: sets the value of GTK_PRINT_SETTINGS_PAGE_RANGES.
	SetPageRanges(pageRanges []PageRange)
	// SetPageSet: sets the value of GTK_PRINT_SETTINGS_PAGE_SET.
	SetPageSet(pageSet PageSet)
	// SetPaperHeight: sets the value of GTK_PRINT_SETTINGS_PAPER_HEIGHT.
	SetPaperHeight(height float64, unit Unit)
	// SetPaperSize: sets the value of GTK_PRINT_SETTINGS_PAPER_FORMAT,
	// GTK_PRINT_SETTINGS_PAPER_WIDTH and GTK_PRINT_SETTINGS_PAPER_HEIGHT.
	SetPaperSize(paperSize *PaperSize)
	// SetPaperWidth: sets the value of GTK_PRINT_SETTINGS_PAPER_WIDTH.
	SetPaperWidth(width float64, unit Unit)
	// SetPrintPages: sets the value of GTK_PRINT_SETTINGS_PRINT_PAGES.
	SetPrintPages(pages PrintPages)
	// SetPrinter: convenience function to set GTK_PRINT_SETTINGS_PRINTER to
	// @printer.
	SetPrinter(printer string)
	// SetPrinterLpi: sets the value of GTK_PRINT_SETTINGS_PRINTER_LPI.
	SetPrinterLpi(lpi float64)
	// SetQuality: sets the value of GTK_PRINT_SETTINGS_QUALITY.
	SetQuality(quality PrintQuality)
	// SetResolution: sets the values of GTK_PRINT_SETTINGS_RESOLUTION,
	// GTK_PRINT_SETTINGS_RESOLUTION_X and GTK_PRINT_SETTINGS_RESOLUTION_Y.
	SetResolution(resolution int)
	// SetResolutionXY: sets the values of GTK_PRINT_SETTINGS_RESOLUTION,
	// GTK_PRINT_SETTINGS_RESOLUTION_X and GTK_PRINT_SETTINGS_RESOLUTION_Y.
	SetResolutionXY(resolutionX int, resolutionY int)
	// SetReverse: sets the value of GTK_PRINT_SETTINGS_REVERSE.
	SetReverse(reverse bool)
	// SetScale: sets the value of GTK_PRINT_SETTINGS_SCALE.
	SetScale(scale float64)
	// SetUseColor: sets the value of GTK_PRINT_SETTINGS_USE_COLOR.
	SetUseColor(useColor bool)
	// ToFile: this function saves the print settings from @settings to
	// @file_name. If the file could not be loaded then error is set to either a
	// Error or FileError.
	ToFile(fileName string) bool
	// ToGvariant: serialize print settings to an a{sv} variant.
	ToGvariant() *glib.Variant
	// ToKeyFile: this function adds the print settings from @settings to
	// @key_file.
	ToKeyFile(keyFile *glib.KeyFile, groupName string)
	// Unset: removes any value associated with @key. This has the same effect
	// as setting the value to nil.
	Unset(key string)
}

type printSettings struct {
	*externglib.Object
}

func wrapPrintSettings(obj *externglib.Object) PrintSettings {
	return printSettings{*externglib.Object{obj}}
}

func marshalPrintSettings(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewPrintSettings() PrintSettings

func NewPrintSettings(fileName string) PrintSettings

func NewPrintSettings(variant *glib.Variant) PrintSettings

func NewPrintSettings(keyFile *glib.KeyFile, groupName string) PrintSettings

func (p printSettings) Copy() PrintSettings

func (p printSettings) Foreach(_func PrintSettingsFunc)

func (p printSettings) Get(key string) string

func (p printSettings) Bool(key string) bool

func (p printSettings) Collate() bool

func (p printSettings) DefaultSource() string

func (p printSettings) Dither() string

func (p printSettings) Double(key string) float64

func (p printSettings) DoubleWithDefault(key string, def float64) float64

func (p printSettings) Duplex() PrintDuplex

func (p printSettings) Finishings() string

func (p printSettings) Int(key string) int

func (p printSettings) IntWithDefault(key string, def int) int

func (p printSettings) Length(key string, unit Unit) float64

func (p printSettings) MediaType() string

func (p printSettings) NCopies() int

func (p printSettings) NumberUp() int

func (p printSettings) NumberUpLayout() NumberUpLayout

func (p printSettings) Orientation() PageOrientation

func (p printSettings) OutputBin() string

func (p printSettings) PageRanges() (numRanges int, pageRanges []PageRange)

func (p printSettings) PageSet() PageSet

func (p printSettings) PaperHeight(unit Unit) float64

func (p printSettings) PaperSize() *PaperSize

func (p printSettings) PaperWidth(unit Unit) float64

func (p printSettings) PrintPages() PrintPages

func (p printSettings) Printer() string

func (p printSettings) PrinterLpi() float64

func (p printSettings) Quality() PrintQuality

func (p printSettings) Resolution() int

func (p printSettings) ResolutionX() int

func (p printSettings) ResolutionY() int

func (p printSettings) Reverse() bool

func (p printSettings) Scale() float64

func (p printSettings) UseColor() bool

func (p printSettings) HasKey(key string) bool

func (p printSettings) LoadFile(fileName string) bool

func (p printSettings) LoadKeyFile(keyFile *glib.KeyFile, groupName string) bool

func (p printSettings) Set(key string, value string)

func (p printSettings) SetBool(key string, value bool)

func (p printSettings) SetCollate(collate bool)

func (p printSettings) SetDefaultSource(defaultSource string)

func (p printSettings) SetDither(dither string)

func (p printSettings) SetDouble(key string, value float64)

func (p printSettings) SetDuplex(duplex PrintDuplex)

func (p printSettings) SetFinishings(finishings string)

func (p printSettings) SetInt(key string, value int)

func (p printSettings) SetLength(key string, value float64, unit Unit)

func (p printSettings) SetMediaType(mediaType string)

func (p printSettings) SetNCopies(numCopies int)

func (p printSettings) SetNumberUp(numberUp int)

func (p printSettings) SetNumberUpLayout(numberUpLayout NumberUpLayout)

func (p printSettings) SetOrientation(orientation PageOrientation)

func (p printSettings) SetOutputBin(outputBin string)

func (p printSettings) SetPageRanges(pageRanges []PageRange)

func (p printSettings) SetPageSet(pageSet PageSet)

func (p printSettings) SetPaperHeight(height float64, unit Unit)

func (p printSettings) SetPaperSize(paperSize *PaperSize)

func (p printSettings) SetPaperWidth(width float64, unit Unit)

func (p printSettings) SetPrintPages(pages PrintPages)

func (p printSettings) SetPrinter(printer string)

func (p printSettings) SetPrinterLpi(lpi float64)

func (p printSettings) SetQuality(quality PrintQuality)

func (p printSettings) SetResolution(resolution int)

func (p printSettings) SetResolutionXY(resolutionX int, resolutionY int)

func (p printSettings) SetReverse(reverse bool)

func (p printSettings) SetScale(scale float64)

func (p printSettings) SetUseColor(useColor bool)

func (p printSettings) ToFile(fileName string) bool

func (p printSettings) ToGvariant() *glib.Variant

func (p printSettings) ToKeyFile(keyFile *glib.KeyFile, groupName string)

func (p printSettings) Unset(key string)

// ProgressBar: the ProgressBar is typically used to display the progress of a
// long running operation. It provides a visual clue that processing is
// underway. The GtkProgressBar can be used in two different modes: percentage
// mode and activity mode.
//
// When an application can determine how much work needs to take place (e.g.
// read a fixed number of bytes from a file) and can monitor its progress, it
// can use the GtkProgressBar in percentage mode and the user sees a growing bar
// indicating the percentage of the work that has been completed. In this mode,
// the application is required to call gtk_progress_bar_set_fraction()
// periodically to update the progress bar.
//
// When an application has no accurate way of knowing the amount of work to do,
// it can use the ProgressBar in activity mode, which shows activity by a block
// moving back and forth within the progress area. In this mode, the application
// is required to call gtk_progress_bar_pulse() periodically to update the
// progress bar.
//
// There is quite a bit of flexibility provided to control the appearance of the
// ProgressBar. Functions are provided to control the orientation of the bar,
// optional text can be displayed along with the bar, and the step size used in
// activity mode can be set.
//
// CSS nodes
//
//    progressbar[.osd]
//    ├── [text]
//    ╰── trough[.empty][.full]
//        ╰── progress[.pulse]
//
// GtkProgressBar has a main CSS node with name progressbar and subnodes with
// names text and trough, of which the latter has a subnode named progress. The
// text subnode is only present if text is shown. The progress subnode has the
// style class .pulse when in activity mode. It gets the style classes .left,
// .right, .top or .bottom added when the progress 'touches' the corresponding
// end of the GtkProgressBar. The .osd class on the progressbar node is for use
// in overlays like the one Epiphany has for page loading progress.
//
//
// Accessibility
//
// GtkProgressBar uses the K_ACCESSIBLE_ROLE_PROGRESS_BAR role.
type ProgressBar interface {
	Widget

	// Ellipsize: returns the ellipsizing position of the progress bar. See
	// gtk_progress_bar_set_ellipsize().
	Ellipsize() pango.EllipsizeMode
	// Fraction: returns the current fraction of the task that’s been completed.
	Fraction() float64
	// Inverted: gets the value set by gtk_progress_bar_set_inverted().
	Inverted() bool
	// PulseStep: retrieves the pulse step set with
	// gtk_progress_bar_set_pulse_step().
	PulseStep() float64
	// ShowText: gets the value of the ProgressBar:show-text property. See
	// gtk_progress_bar_set_show_text().
	ShowText() bool
	// Text: retrieves the text that is displayed with the progress bar, if any,
	// otherwise nil. The return value is a reference to the text, not a copy of
	// it, so will become invalid if you change the text in the progress bar.
	Text() string
	// Pulse: indicates that some progress has been made, but you don’t know how
	// much. Causes the progress bar to enter “activity mode,” where a block
	// bounces back and forth. Each call to gtk_progress_bar_pulse() causes the
	// block to move by a little bit (the amount of movement per pulse is
	// determined by gtk_progress_bar_set_pulse_step()).
	Pulse()
	// SetEllipsize: sets the mode used to ellipsize (add an ellipsis: "...")
	// the text if there is not enough space to render the entire string.
	SetEllipsize(mode pango.EllipsizeMode)
	// SetFraction: causes the progress bar to “fill in” the given fraction of
	// the bar. The fraction should be between 0.0 and 1.0, inclusive.
	SetFraction(fraction float64)
	// SetInverted: progress bars normally grow from top to bottom or left to
	// right. Inverted progress bars grow in the opposite direction.
	SetInverted(inverted bool)
	// SetPulseStep: sets the fraction of total progress bar length to move the
	// bouncing block for each call to gtk_progress_bar_pulse().
	SetPulseStep(fraction float64)
	// SetShowText: sets whether the progress bar will show text next to the
	// bar. The shown text is either the value of the ProgressBar:text property
	// or, if that is nil, the ProgressBar:fraction value, as a percentage.
	//
	// To make a progress bar that is styled and sized suitably for containing
	// text (even if the actual text is blank), set ProgressBar:show-text to
	// true and ProgressBar:text to the empty string (not nil).
	SetShowText(showText bool)
	// SetText: causes the given @text to appear next to the progress bar.
	//
	// If @text is nil and ProgressBar:show-text is true, the current value of
	// ProgressBar:fraction will be displayed as a percentage.
	//
	// If @text is non-nil and ProgressBar:show-text is true, the text will be
	// displayed. In this case, it will not display the progress percentage. If
	// @text is the empty string, the progress bar will still be styled and
	// sized suitably for containing text, as long as ProgressBar:show-text is
	// true.
	SetText(text string)
}

type progressBar struct {
	widget
}

func wrapProgressBar(obj *externglib.Object) ProgressBar {
	return progressBar{widget{externglib.InitiallyUnowned{obj}}}
}

func marshalProgressBar(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewProgressBar() ProgressBar

func (p progressBar) Ellipsize() pango.EllipsizeMode

func (p progressBar) Fraction() float64

func (p progressBar) Inverted() bool

func (p progressBar) PulseStep() float64

func (p progressBar) ShowText() bool

func (p progressBar) Text() string

func (p progressBar) Pulse()

func (p progressBar) SetEllipsize(mode pango.EllipsizeMode)

func (p progressBar) SetFraction(fraction float64)

func (p progressBar) SetInverted(inverted bool)

func (p progressBar) SetPulseStep(fraction float64)

func (p progressBar) SetShowText(showText bool)

func (p progressBar) SetText(text string)

type PropertyExpression interface {
	Expression

	// Expression: gets the expression specifying the object of a property
	// expression.
	Expression() Expression
}

type propertyExpression struct {
	expression
}

func wrapPropertyExpression(obj *externglib.Object) PropertyExpression {
	return propertyExpression{expression{obj}}
}

func marshalPropertyExpression(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewPropertyExpression(thisType externglib.Type, expression Expression, propertyName string) PropertyExpression

func (p propertyExpression) Expression() Expression

// Range is the common base class for widgets which visualize an adjustment, e.g
// Scale or Scrollbar.
//
// Apart from signals for monitoring the parameters of the adjustment, Range
// provides properties and methods for setting a “fill level” on range widgets.
// See gtk_range_set_fill_level().
type Range interface {
	Widget

	// Adjustment: get the Adjustment which is the “model” object for Range. See
	// gtk_range_set_adjustment() for details. The return value does not have a
	// reference added, so should not be unreferenced.
	Adjustment() Adjustment
	// FillLevel: gets the current position of the fill level indicator.
	FillLevel() float64
	// Flippable: gets the value set by gtk_range_set_flippable().
	Flippable() bool
	// Inverted: gets the value set by gtk_range_set_inverted().
	Inverted() bool
	// RangeRect: this function returns the area that contains the range’s
	// trough, in coordinates relative to @range's origin.
	//
	// This function is useful mainly for Range subclasses.
	RangeRect() gdk.Rectangle
	// RestrictToFillLevel: gets whether the range is restricted to the fill
	// level.
	RestrictToFillLevel() bool
	// RoundDigits: gets the number of digits to round the value to when it
	// changes. See Range::change-value.
	RoundDigits() int
	// ShowFillLevel: gets whether the range displays the fill level
	// graphically.
	ShowFillLevel() bool
	// SliderRange: this function returns sliders range along the long
	// dimension, in widget->window coordinates.
	//
	// This function is useful mainly for Range subclasses.
	SliderRange() (sliderStart int, sliderEnd int)
	// SliderSizeFixed: this function is useful mainly for Range subclasses.
	//
	// See gtk_range_set_slider_size_fixed().
	SliderSizeFixed() bool
	// Value: gets the current value of the range.
	Value() float64
	// SetAdjustment: sets the adjustment to be used as the “model” object for
	// this range widget. The adjustment indicates the current range value, the
	// minimum and maximum range values, the step/page increments used for
	// keybindings and scrolling, and the page size. The page size is normally 0
	// for Scale and nonzero for Scrollbar, and indicates the size of the
	// visible area of the widget being scrolled. The page size affects the size
	// of the scrollbar slider.
	SetAdjustment(adjustment Adjustment)
	// SetFillLevel: set the new position of the fill level indicator.
	//
	// The “fill level” is probably best described by its most prominent use
	// case, which is an indicator for the amount of pre-buffering in a
	// streaming media player. In that use case, the value of the range would
	// indicate the current play position, and the fill level would be the
	// position up to which the file/stream has been downloaded.
	//
	// This amount of prebuffering can be displayed on the range’s trough and is
	// themeable separately from the trough. To enable fill level display, use
	// gtk_range_set_show_fill_level(). The range defaults to not showing the
	// fill level.
	//
	// Additionally, it’s possible to restrict the range’s slider position to
	// values which are smaller than the fill level. This is controller by
	// gtk_range_set_restrict_to_fill_level() and is by default enabled.
	SetFillLevel(fillLevel float64)
	// SetFlippable: if a range is flippable, it will switch its direction if it
	// is horizontal and its direction is GTK_TEXT_DIR_RTL.
	//
	// See gtk_widget_get_direction().
	SetFlippable(flippable bool)
	// SetIncrements: sets the step and page sizes for the range. The step size
	// is used when the user clicks the Scrollbar arrows or moves Scale via
	// arrow keys. The page size is used for example when moving via Page Up or
	// Page Down keys.
	SetIncrements(step float64, page float64)
	// SetInverted: ranges normally move from lower to higher values as the
	// slider moves from top to bottom or left to right. Inverted ranges have
	// higher values at the top or on the right rather than on the bottom or
	// left.
	SetInverted(setting bool)
	// SetRange: sets the allowable values in the Range, and clamps the range
	// value to be between @min and @max. (If the range has a non-zero page
	// size, it is clamped between @min and @max - page-size.)
	SetRange(min float64, max float64)
	// SetRestrictToFillLevel: sets whether the slider is restricted to the fill
	// level. See gtk_range_set_fill_level() for a general description of the
	// fill level concept.
	SetRestrictToFillLevel(restrictToFillLevel bool)
	// SetRoundDigits: sets the number of digits to round the value to when it
	// changes. See Range::change-value.
	SetRoundDigits(roundDigits int)
	// SetShowFillLevel: sets whether a graphical fill level is show on the
	// trough. See gtk_range_set_fill_level() for a general description of the
	// fill level concept.
	SetShowFillLevel(showFillLevel bool)
	// SetSliderSizeFixed: sets whether the range’s slider has a fixed size, or
	// a size that depends on its adjustment’s page size.
	//
	// This function is useful mainly for Range subclasses.
	SetSliderSizeFixed(sizeFixed bool)
	// SetValue: sets the current value of the range; if the value is outside
	// the minimum or maximum range values, it will be clamped to fit inside
	// them. The range emits the Range::value-changed signal if the value
	// changes.
	SetValue(value float64)
}

type _range struct {
	widget
}

func wrapRange(obj *externglib.Object) Range {
	return _range{widget{externglib.InitiallyUnowned{obj}}}
}

func marshalRange(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func (_ _range) Adjustment() Adjustment

func (_ _range) FillLevel() float64

func (_ _range) Flippable() bool

func (_ _range) Inverted() bool

func (_ _range) RangeRect() gdk.Rectangle

func (_ _range) RestrictToFillLevel() bool

func (_ _range) RoundDigits() int

func (_ _range) ShowFillLevel() bool

func (_ _range) SliderRange() (sliderStart int, sliderEnd int)

func (_ _range) SliderSizeFixed() bool

func (_ _range) Value() float64

func (_ _range) SetAdjustment(adjustment Adjustment)

func (_ _range) SetFillLevel(fillLevel float64)

func (_ _range) SetFlippable(flippable bool)

func (_ _range) SetIncrements(step float64, page float64)

func (_ _range) SetInverted(setting bool)

func (_ _range) SetRange(min float64, max float64)

func (_ _range) SetRestrictToFillLevel(restrictToFillLevel bool)

func (_ _range) SetRoundDigits(roundDigits int)

func (_ _range) SetShowFillLevel(showFillLevel bool)

func (_ _range) SetSliderSizeFixed(sizeFixed bool)

func (_ _range) SetValue(value float64)

// RecentManager provides a facility for adding, removing and looking up
// recently used files. Each recently used file is identified by its URI, and
// has meta-data associated to it, like the names and command lines of the
// applications that have registered it, the number of time each application has
// registered the same file, the mime type of the file and whether the file
// should be displayed only by the applications that have registered it.
//
// The recently used files list is per user.
//
// The RecentManager acts like a database of all the recently used files. You
// can create new RecentManager objects, but it is more efficient to use the
// default manager created by GTK
//
// Adding a new recently used file is as simple as:
//
//    GtkRecentManager *manager;
//
//    manager = gtk_recent_manager_get_default ();
//    gtk_recent_manager_add_item (manager, file_uri);
//
//
// The RecentManager will try to gather all the needed information from the file
// itself through GIO.
//
// Looking up the meta-data associated with a recently used file given its URI
// requires calling gtk_recent_manager_lookup_item():
//
//    GtkRecentManager *manager;
//    GtkRecentInfo *info;
//    GError *error = NULL;
//
//    manager = gtk_recent_manager_get_default ();
//    info = gtk_recent_manager_lookup_item (manager, file_uri, &error);
//    if (error)
//      {
//        g_warning ("Could not find the file: s", error->message);
//        g_error_free (error);
//      }
//    else
//     {
//       // Use the info object
//       gtk_recent_info_unref (info);
//     }
//
//
// In order to retrieve the list of recently used files, you can use
// gtk_recent_manager_get_items(), which returns a list of RecentInfo.
//
// A RecentManager is the model used to populate the contents of one, or more
// RecentChooser implementations.
//
// Note that the maximum age of the recently used files list is controllable
// through the Settings:gtk-recent-files-max-age property.
type RecentManager interface {
	gextras.Objector

	// AddFull: adds a new resource, pointed by @uri, into the recently used
	// resources list, using the metadata specified inside the RecentData passed
	// in @recent_data.
	//
	// The passed URI will be used to identify this resource inside the list.
	//
	// In order to register the new recently used resource, metadata about the
	// resource must be passed as well as the URI; the metadata is stored in a
	// RecentData, which must contain the MIME type of the resource pointed by
	// the URI; the name of the application that is registering the item, and a
	// command line to be used when launching the item.
	//
	// Optionally, a RecentData might contain a UTF-8 string to be used when
	// viewing the item instead of the last component of the URI; a short
	// description of the item; whether the item should be considered private -
	// that is, should be displayed only by the applications that have
	// registered it.
	AddFull(uri string, recentData *RecentData) bool
	// AddItem: adds a new resource, pointed by @uri, into the recently used
	// resources list.
	//
	// This function automatically retrieves some of the needed metadata and
	// setting other metadata to common default values; it then feeds the data
	// to gtk_recent_manager_add_full().
	//
	// See gtk_recent_manager_add_full() if you want to explicitly define the
	// metadata for the resource pointed by @uri.
	AddItem(uri string) bool
	// Items: gets the list of recently used resources.
	Items() *glib.List
	// HasItem: checks whether there is a recently used resource registered with
	// @uri inside the recent manager.
	HasItem(uri string) bool
	// LookupItem: searches for a URI inside the recently used resources list,
	// and returns a RecentInfo containing information about the resource like
	// its MIME type, or its display name.
	LookupItem(uri string) *RecentInfo
	// MoveItem: changes the location of a recently used resource from @uri to
	// @new_uri.
	//
	// Please note that this function will not affect the resource pointed by
	// the URIs, but only the URI used in the recently used resources list.
	MoveItem(uri string, newURI string) bool
	// PurgeItems: purges every item from the recently used resources list.
	PurgeItems() int
	// RemoveItem: removes a resource pointed by @uri from the recently used
	// resources list handled by a recent manager.
	RemoveItem(uri string) bool
}

type recentManager struct {
	*externglib.Object
}

func wrapRecentManager(obj *externglib.Object) RecentManager {
	return recentManager{*externglib.Object{obj}}
}

func marshalRecentManager(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewRecentManager() RecentManager

func (r recentManager) AddFull(uri string, recentData *RecentData) bool

func (r recentManager) AddItem(uri string) bool

func (r recentManager) Items() *glib.List

func (r recentManager) HasItem(uri string) bool

func (r recentManager) LookupItem(uri string) *RecentInfo

func (r recentManager) MoveItem(uri string, newURI string) bool

func (r recentManager) PurgeItems() int

func (r recentManager) RemoveItem(uri string) bool

// Revealer: the GtkRevealer widget is a container which animates the transition
// of its child from invisible to visible.
//
// The style of transition can be controlled with
// gtk_revealer_set_transition_type().
//
// These animations respect the Settings:gtk-enable-animations setting.
//
//
// CSS nodes
//
// GtkRevealer has a single CSS node with name revealer. When styling Revealer
// using CSS, remember that it only hides its contents, not itself. That means
// applied margin, padding and borders will be visible even when the
// Revealer:reveal-child property is set to false.
//
//
// Accessibility
//
// GtkRevealer uses the GTK_ACCESSIBLE_ROLE_GROUP role.
//
// The child of GtkRevealer, if set, is always available in the accessibility
// tree, regardless of the state of the revealer widget.
type Revealer interface {
	Widget

	// Child: gets the child widget of @revealer.
	Child() Widget
	// ChildRevealed: returns whether the child is fully revealed, in other
	// words whether the transition to the revealed state is completed.
	ChildRevealed() bool
	// RevealChild: returns whether the child is currently revealed. See
	// gtk_revealer_set_reveal_child().
	//
	// This function returns true as soon as the transition is to the revealed
	// state is started. To learn whether the child is fully revealed (ie the
	// transition is completed), use gtk_revealer_get_child_revealed().
	RevealChild() bool
	// TransitionDuration: returns the amount of time (in milliseconds) that
	// transitions will take.
	TransitionDuration() uint
	// TransitionType: gets the type of animation that will be used for
	// transitions in @revealer.
	TransitionType() RevealerTransitionType
	// SetChild: sets the child widget of @revealer.
	SetChild(child Widget)
	// SetRevealChild: tells the Revealer to reveal or conceal its child.
	//
	// The transition will be animated with the current transition type of
	// @revealer.
	SetRevealChild(revealChild bool)
	// SetTransitionDuration: sets the duration that transitions will take.
	SetTransitionDuration(duration uint)
	// SetTransitionType: sets the type of animation that will be used for
	// transitions in @revealer. Available types include various kinds of fades
	// and slides.
	SetTransitionType(transition RevealerTransitionType)
}

type revealer struct {
	widget
}

func wrapRevealer(obj *externglib.Object) Revealer {
	return revealer{widget{externglib.InitiallyUnowned{obj}}}
}

func marshalRevealer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewRevealer() Revealer

func (r revealer) Child() Widget

func (r revealer) ChildRevealed() bool

func (r revealer) RevealChild() bool

func (r revealer) TransitionDuration() uint

func (r revealer) TransitionType() RevealerTransitionType

func (r revealer) SetChild(child Widget)

func (r revealer) SetRevealChild(revealChild bool)

func (r revealer) SetTransitionDuration(duration uint)

func (r revealer) SetTransitionType(transition RevealerTransitionType)

// Scale: a GtkScale is a slider control used to select a numeric value. To use
// it, you’ll probably want to investigate the methods on its base class, Range,
// in addition to the methods for GtkScale itself. To set the value of a scale,
// you would normally use gtk_range_set_value(). To detect changes to the value,
// you would normally use the Range::value-changed signal.
//
// Note that using the same upper and lower bounds for the Scale (through the
// Range methods) will hide the slider itself. This is useful for applications
// that want to show an undeterminate value on the scale, without changing the
// layout of the application (such as movie or music players).
//
//
// GtkScale as GtkBuildable
//
// GtkScale supports a custom <marks> element, which can contain multiple <mark>
// elements. The “value” and “position” attributes have the same meaning as
// gtk_scale_add_mark() parameters of the same name. If the element is not
// empty, its content is taken as the markup to show at the mark. It can be
// translated with the usual ”translatable” and “context” attributes.
//
// CSS nodes
//
//    scale[.fine-tune][.marks-before][.marks-after]
//    ├── [value][.top][.right][.bottom][.left]
//    ├── marks.top
//    │   ├── mark
//    │   ┊    ├── [label]
//    │   ┊    ╰── indicator
//    ┊   ┊
//    │   ╰── mark
//    ├── marks.bottom
//    │   ├── mark
//    │   ┊    ├── indicator
//    │   ┊    ╰── [label]
//    ┊   ┊
//    │   ╰── mark
//    ╰── trough
//        ├── [fill]
//        ├── [highlight]
//        ╰── slider
//
// GtkScale has a main CSS node with name scale and a subnode for its contents,
// with subnodes named trough and slider.
//
// The main node gets the style class .fine-tune added when the scale is in
// 'fine-tuning' mode.
//
// If the scale has an origin (see gtk_scale_set_has_origin()), there is a
// subnode with name highlight below the trough node that is used for rendering
// the highlighted part of the trough.
//
// If the scale is showing a fill level (see gtk_range_set_show_fill_level()),
// there is a subnode with name fill below the trough node that is used for
// rendering the filled in part of the trough.
//
// If marks are present, there is a marks subnode before or after the trough
// node, below which each mark gets a node with name mark. The marks nodes get
// either the .top or .bottom style class.
//
// The mark node has a subnode named indicator. If the mark has text, it also
// has a subnode named label. When the mark is either above or left of the
// scale, the label subnode is the first when present. Otherwise, the indicator
// subnode is the first.
//
// The main CSS node gets the 'marks-before' and/or 'marks-after' style classes
// added depending on what marks are present.
//
// If the scale is displaying the value (see Scale:draw-value), there is subnode
// with name value. This node will get the .top or .bottom style classes similar
// to the marks node.
//
//
// Accessibility
//
// GtkScale uses the K_ACCESSIBLE_ROLE_SLIDER role.
type Scale interface {
	Range

	// AddMark: adds a mark at @value.
	//
	// A mark is indicated visually by drawing a tick mark next to the scale,
	// and GTK makes it easy for the user to position the scale exactly at the
	// marks value.
	//
	// If @markup is not nil, text is shown next to the tick mark.
	//
	// To remove marks from a scale, use gtk_scale_clear_marks().
	AddMark(value float64, position PositionType, markup string)
	// ClearMarks: removes any marks that have been added with
	// gtk_scale_add_mark().
	ClearMarks()
	// Digits: gets the number of decimal places that are displayed in the
	// value.
	Digits() int
	// DrawValue: returns whether the current value is displayed as a string
	// next to the slider.
	DrawValue() bool
	// HasOrigin: returns whether the scale has an origin.
	HasOrigin() bool
	// Layout: gets the Layout used to display the scale. The returned object is
	// owned by the scale so does not need to be freed by the caller.
	Layout() pango.Layout
	// LayoutOffsets: obtains the coordinates where the scale will draw the
	// Layout representing the text in the scale. Remember when using the Layout
	// function you need to convert to and from pixels using PANGO_PIXELS() or
	// NGO_SCALE.
	//
	// If the Scale:draw-value property is false, the return values are
	// undefined.
	LayoutOffsets() (x int, y int)
	// ValuePos: gets the position in which the current value is displayed.
	ValuePos() PositionType
	// SetDigits: sets the number of decimal places that are displayed in the
	// value. Also causes the value of the adjustment to be rounded to this
	// number of digits, so the retrieved value matches the displayed one, if
	// Scale:draw-value is true when the value changes. If you want to enforce
	// rounding the value when Scale:draw-value is false, you can set
	// Range:round-digits instead.
	//
	// Note that rounding to a small number of digits can interfere with the
	// smooth autoscrolling that is built into Scale. As an alternative, you can
	// use gtk_scale_set_format_value_func() to format the displayed value
	// yourself.
	SetDigits(digits int)
	// SetDrawValue: specifies whether the current value is displayed as a
	// string next to the slider.
	SetDrawValue(drawValue bool)
	// SetFormatValueFunc: @func allows you to change how the scale value is
	// displayed. The given function will return an allocated string
	// representing @value. That string will then be used to display the scale's
	// value.
	//
	// If LL is passed as @func, the value will be displayed on its own, rounded
	// according to the value of the Scale:digits property.
	SetFormatValueFunc(_func ScaleFormatValueFunc)
	// SetHasOrigin: if Scale:has-origin is set to true (the default), the scale
	// will highlight the part of the trough between the origin (bottom or left
	// side) and the current value.
	SetHasOrigin(hasOrigin bool)
	// SetValuePos: sets the position in which the current value is displayed.
	SetValuePos(pos PositionType)
}

type scale struct {
	_range
}

func wrapScale(obj *externglib.Object) Scale {
	return scale{_range{widget{externglib.InitiallyUnowned{obj}}}}
}

func marshalScale(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewScale(orientation Orientation, adjustment Adjustment) Scale

func NewScale(orientation Orientation, min float64, max float64, step float64) Scale

func (s scale) AddMark(value float64, position PositionType, markup string)

func (s scale) ClearMarks()

func (s scale) Digits() int

func (s scale) DrawValue() bool

func (s scale) HasOrigin() bool

func (s scale) Layout() pango.Layout

func (s scale) LayoutOffsets() (x int, y int)

func (s scale) ValuePos() PositionType

func (s scale) SetDigits(digits int)

func (s scale) SetDrawValue(drawValue bool)

func (s scale) SetFormatValueFunc(_func ScaleFormatValueFunc)

func (s scale) SetHasOrigin(hasOrigin bool)

func (s scale) SetValuePos(pos PositionType)

// ScaleButton provides a button which pops up a scale widget. This kind of
// widget is commonly used for volume controls in multimedia applications, and
// GTK provides a VolumeButton subclass that is tailored for this use case.
//
//
// CSS nodes
//
// GtkScaleButton has a single CSS node with name button. To differentiate it
// from a plain Button, it gets the .scale style class.
type ScaleButton interface {
	Widget

	// Adjustment: gets the Adjustment associated with the ScaleButton’s scale.
	// See gtk_range_get_adjustment() for details.
	Adjustment() Adjustment
	// MinusButton: retrieves the minus button of the ScaleButton.
	MinusButton() Widget
	// PlusButton: retrieves the plus button of the ScaleButton.
	PlusButton() Widget
	// Popup: retrieves the popup of the ScaleButton.
	Popup() Widget
	// Value: gets the current value of the scale button.
	Value() float64
	// SetAdjustment: sets the Adjustment to be used as a model for the
	// ScaleButton’s scale. See gtk_range_set_adjustment() for details.
	SetAdjustment(adjustment Adjustment)
	// SetIcons: sets the icons to be used by the scale button. For details, see
	// the ScaleButton:icons property.
	SetIcons(icons []string)
	// SetValue: sets the current value of the scale; if the value is outside
	// the minimum or maximum range values, it will be clamped to fit inside
	// them. The scale button emits the ScaleButton::value-changed signal if the
	// value changes.
	SetValue(value float64)
}

type scaleButton struct {
	widget
}

func wrapScaleButton(obj *externglib.Object) ScaleButton {
	return scaleButton{widget{externglib.InitiallyUnowned{obj}}}
}

func marshalScaleButton(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewScaleButton(min float64, max float64, step float64, icons []string) ScaleButton

func (s scaleButton) Adjustment() Adjustment

func (s scaleButton) MinusButton() Widget

func (s scaleButton) PlusButton() Widget

func (s scaleButton) Popup() Widget

func (s scaleButton) Value() float64

func (s scaleButton) SetAdjustment(adjustment Adjustment)

func (s scaleButton) SetIcons(icons []string)

func (s scaleButton) SetValue(value float64)

// Scrollbar: the Scrollbar widget is a horizontal or vertical scrollbar,
// depending on the value of the Orientable:orientation property.
//
// Its position and movement are controlled by the adjustment that is passed to
// or created by gtk_scrollbar_new(). See Adjustment for more details. The
// Adjustment:value field sets the position of the thumb and must be between
// Adjustment:lower and Adjustment:upper - Adjustment:page-size. The
// Adjustment:page-size represents the size of the visible scrollable area. The
// fields Adjustment:step-increment and Adjustment:page-increment fields are
// added to or subtracted from the Adjustment:value when the user asks to move
// by a step (using e.g. the cursor arrow keys) or by a page (using e.g. the
// Page Down/Up keys).
//
// CSS nodes
//
//    scrollbar
//    ╰── range[.fine-tune]
//        ╰── trough
//            ╰── slider
//
// GtkScrollbar has a main CSS node with name scrollbar and a subnode for its
// contents. The main node gets the .horizontal or .vertical style classes
// applied, depending on the scrollbar's orientation.
//
// The range node gets the style class .fine-tune added when the scrollbar is in
// 'fine-tuning' mode.
//
// Other style classes that may be added to scrollbars inside ScrolledWindow
// include the positional classes (.left, .right, .top, .bottom) and style
// classes related to overlay scrolling (.overlay-indicator, .dragging,
// .hovering).
//
//
// Accessibility
//
// GtkScrollbar uses the K_ACCESSIBLE_ROLE_SCROLLBAR role.
type Scrollbar interface {
	Widget

	// Adjustment: returns the scrollbar's adjustment.
	Adjustment() Adjustment
	// SetAdjustment: makes the scrollbar use the given adjustment.
	SetAdjustment(adjustment Adjustment)
}

type scrollbar struct {
	widget
}

func wrapScrollbar(obj *externglib.Object) Scrollbar {
	return scrollbar{widget{externglib.InitiallyUnowned{obj}}}
}

func marshalScrollbar(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewScrollbar(orientation Orientation, adjustment Adjustment) Scrollbar

func (s scrollbar) Adjustment() Adjustment

func (s scrollbar) SetAdjustment(adjustment Adjustment)

// ScrolledWindow: gtkScrolledWindow is a container that accepts a single child
// widget, makes that child scrollable using either internally added scrollbars
// or externally associated adjustments, and optionally draws a frame around the
// child.
//
// Widgets with native scrolling support, i.e. those whose classes implement the
// Scrollable interface, are added directly. For other types of widget, the
// class Viewport acts as an adaptor, giving scrollability to other widgets.
// gtk_scrolled_window_set_child() intelligently accounts for whether or not the
// added child is a Scrollable. If it isn’t, ScrolledWindow wraps the child in a
// Viewport and adds that for you. Therefore, you can just add any child widget
// and not worry about the details.
//
// If gtk_scrolled_window_set_child() has added a Viewport for you, you can
// remove both your added child widget from the Viewport, and the Viewport from
// the GtkScrolledWindow, like this:
//
//    GtkWidget *scrolled_window = gtk_scrolled_window_new ();
//    GtkWidget *child_widget = gtk_button_new ();
//
//    // GtkButton is not a GtkScrollable, so GtkScrolledWindow will automatically
//    // add a GtkViewport.
//    gtk_box_append (GTK_BOX (scrolled_window),
//                       child_widget);
//
//    // Either of these will result in child_widget being unparented:
//    gtk_box_remove (GTK_BOX (scrolled_window),
//                          child_widget);
//    // or
//    gtk_box_remove (GTK_BOX (scrolled_window),
//                          gtk_bin_get_child (GTK_BIN (scrolled_window)));
//
//
// Unless ScrolledWindow:hscrollbar-policy and ScrolledWindow:vscrollbar-policy
// are GTK_POLICY_NEVER or GTK_POLICY_EXTERNAL, GtkScrolledWindow adds internal
// Scrollbar widgets around its child. The scroll position of the child, and if
// applicable the scrollbars, is controlled by the ScrolledWindow:hadjustment
// and ScrolledWindow:vadjustment that are associated with the
// GtkScrolledWindow. See the docs on Scrollbar for the details, but note that
// the “step_increment” and “page_increment” fields are only effective if the
// policy causes scrollbars to be present.
//
// If a GtkScrolledWindow doesn’t behave quite as you would like, or doesn’t
// have exactly the right layout, it’s very possible to set up your own
// scrolling with Scrollbar and for example a Grid.
//
//
// Touch support
//
// GtkScrolledWindow has built-in support for touch devices. When a touchscreen
// is used, swiping will move the scrolled window, and will expose 'kinetic'
// behavior. This can be turned off with the ScrolledWindow:kinetic-scrolling
// property if it is undesired.
//
// GtkScrolledWindow also displays visual 'overshoot' indication when the
// content is pulled beyond the end, and this situation can be captured with the
// ScrolledWindow::edge-overshot signal.
//
// If no mouse device is present, the scrollbars will overlaid as narrow,
// auto-hiding indicators over the content. If traditional scrollbars are
// desired although no mouse is present, this behaviour can be turned off with
// the ScrolledWindow:overlay-scrolling property.
//
//
// CSS nodes
//
// GtkScrolledWindow has a main CSS node with name scrolledwindow. It gets a
// .frame style class added when ScrolledWindow:has-frame is true.
//
// It uses subnodes with names overshoot and undershoot to draw the overflow and
// underflow indications. These nodes get the .left, .right, .top or .bottom
// style class added depending on where the indication is drawn.
//
// GtkScrolledWindow also sets the positional style classes (.left, .right,
// .top, .bottom) and style classes related to overlay scrolling
// (.overlay-indicator, .dragging, .hovering) on its scrollbars.
//
// If both scrollbars are visible, the area where they meet is drawn with a
// subnode named junction.
//
//
// Accessibility
//
// GtkScrolledWindow uses the GTK_ACCESSIBLE_ROLE_GROUP role.
type ScrolledWindow interface {
	Widget

	// Child: gets the child widget of @scrolled_window.
	Child() Widget
	// Hadjustment: returns the horizontal scrollbar’s adjustment, used to
	// connect the horizontal scrollbar to the child widget’s horizontal scroll
	// functionality.
	Hadjustment() Adjustment
	// HasFrame: gets whether the scrolled window draws a frame. See
	// gtk_scrolled_window_set_has_frame().
	HasFrame() bool
	// Hscrollbar: returns the horizontal scrollbar of @scrolled_window.
	Hscrollbar() Widget
	// KineticScrolling: returns the specified kinetic scrolling behavior.
	KineticScrolling() bool
	// MaxContentHeight: returns the maximum content height set.
	MaxContentHeight() int
	// MaxContentWidth: returns the maximum content width set.
	MaxContentWidth() int
	// MinContentHeight: gets the minimal content height of @scrolled_window, or
	// -1 if not set.
	MinContentHeight() int
	// MinContentWidth: gets the minimum content width of @scrolled_window, or
	// -1 if not set.
	MinContentWidth() int
	// OverlayScrolling: returns whether overlay scrolling is enabled for this
	// scrolled window.
	OverlayScrolling() bool
	// Placement: gets the placement of the contents with respect to the
	// scrollbars for the scrolled window. See
	// gtk_scrolled_window_set_placement().
	Placement() CornerType
	// Policy: retrieves the current policy values for the horizontal and
	// vertical scrollbars. See gtk_scrolled_window_set_policy().
	Policy() (hscrollbarPolicy PolicyType, vscrollbarPolicy PolicyType)
	// PropagateNaturalHeight: reports whether the natural height of the child
	// will be calculated and propagated through the scrolled window’s requested
	// natural height.
	PropagateNaturalHeight() bool
	// PropagateNaturalWidth: reports whether the natural width of the child
	// will be calculated and propagated through the scrolled window’s requested
	// natural width.
	PropagateNaturalWidth() bool
	// Vadjustment: returns the vertical scrollbar’s adjustment, used to connect
	// the vertical scrollbar to the child widget’s vertical scroll
	// functionality.
	Vadjustment() Adjustment
	// Vscrollbar: returns the vertical scrollbar of @scrolled_window.
	Vscrollbar() Widget
	// SetChild: sets the child widget of @scrolled_window.
	SetChild(child Widget)
	// SetHadjustment: sets the Adjustment for the horizontal scrollbar.
	SetHadjustment(hadjustment Adjustment)
	// SetHasFrame: changes the frame drawn around the contents of
	// @scrolled_window.
	SetHasFrame(hasFrame bool)
	// SetKineticScrolling: turns kinetic scrolling on or off. Kinetic scrolling
	// only applies to devices with source GDK_SOURCE_TOUCHSCREEN.
	SetKineticScrolling(kineticScrolling bool)
	// SetMaxContentHeight: sets the maximum height that @scrolled_window should
	// keep visible. The @scrolled_window will grow up to this height before it
	// starts scrolling the content.
	//
	// It is a programming error to set the maximum content height to a value
	// smaller than ScrolledWindow:min-content-height.
	SetMaxContentHeight(height int)
	// SetMaxContentWidth: sets the maximum width that @scrolled_window should
	// keep visible. The @scrolled_window will grow up to this width before it
	// starts scrolling the content.
	//
	// It is a programming error to set the maximum content width to a value
	// smaller than ScrolledWindow:min-content-width.
	SetMaxContentWidth(width int)
	// SetMinContentHeight: sets the minimum height that @scrolled_window should
	// keep visible. Note that this can and (usually will) be smaller than the
	// minimum size of the content.
	//
	// It is a programming error to set the minimum content height to a value
	// greater than ScrolledWindow:max-content-height.
	SetMinContentHeight(height int)
	// SetMinContentWidth: sets the minimum width that @scrolled_window should
	// keep visible. Note that this can and (usually will) be smaller than the
	// minimum size of the content.
	//
	// It is a programming error to set the minimum content width to a value
	// greater than ScrolledWindow:max-content-width.
	SetMinContentWidth(width int)
	// SetOverlayScrolling: enables or disables overlay scrolling for this
	// scrolled window.
	SetOverlayScrolling(overlayScrolling bool)
	// SetPlacement: sets the placement of the contents with respect to the
	// scrollbars for the scrolled window.
	//
	// The default is GTK_CORNER_TOP_LEFT, meaning the child is in the top left,
	// with the scrollbars underneath and to the right. Other values in
	// CornerType are GTK_CORNER_TOP_RIGHT, GTK_CORNER_BOTTOM_LEFT, and
	// GTK_CORNER_BOTTOM_RIGHT.
	//
	// See also gtk_scrolled_window_get_placement() and
	// gtk_scrolled_window_unset_placement().
	SetPlacement(windowPlacement CornerType)
	// SetPolicy: sets the scrollbar policy for the horizontal and vertical
	// scrollbars.
	//
	// The policy determines when the scrollbar should appear; it is a value
	// from the PolicyType enumeration. If GTK_POLICY_ALWAYS, the scrollbar is
	// always present; if GTK_POLICY_NEVER, the scrollbar is never present; if
	// GTK_POLICY_AUTOMATIC, the scrollbar is present only if needed (that is,
	// if the slider part of the bar would be smaller than the trough — the
	// display is larger than the page size).
	SetPolicy(hscrollbarPolicy PolicyType, vscrollbarPolicy PolicyType)
	// SetPropagateNaturalHeight: sets whether the natural height of the child
	// should be calculated and propagated through the scrolled window’s
	// requested natural height.
	SetPropagateNaturalHeight(propagate bool)
	// SetPropagateNaturalWidth: sets whether the natural width of the child
	// should be calculated and propagated through the scrolled window’s
	// requested natural width.
	SetPropagateNaturalWidth(propagate bool)
	// SetVadjustment: sets the Adjustment for the vertical scrollbar.
	SetVadjustment(vadjustment Adjustment)
	// UnsetPlacement: unsets the placement of the contents with respect to the
	// scrollbars for the scrolled window. If no window placement is set for a
	// scrolled window, it defaults to GTK_CORNER_TOP_LEFT.
	//
	// See also gtk_scrolled_window_set_placement() and
	// gtk_scrolled_window_get_placement().
	UnsetPlacement()
}

type scrolledWindow struct {
	widget
}

func wrapScrolledWindow(obj *externglib.Object) ScrolledWindow {
	return scrolledWindow{widget{externglib.InitiallyUnowned{obj}}}
}

func marshalScrolledWindow(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewScrolledWindow() ScrolledWindow

func (s scrolledWindow) Child() Widget

func (s scrolledWindow) Hadjustment() Adjustment

func (s scrolledWindow) HasFrame() bool

func (s scrolledWindow) Hscrollbar() Widget

func (s scrolledWindow) KineticScrolling() bool

func (s scrolledWindow) MaxContentHeight() int

func (s scrolledWindow) MaxContentWidth() int

func (s scrolledWindow) MinContentHeight() int

func (s scrolledWindow) MinContentWidth() int

func (s scrolledWindow) OverlayScrolling() bool

func (s scrolledWindow) Placement() CornerType

func (s scrolledWindow) Policy() (hscrollbarPolicy PolicyType, vscrollbarPolicy PolicyType)

func (s scrolledWindow) PropagateNaturalHeight() bool

func (s scrolledWindow) PropagateNaturalWidth() bool

func (s scrolledWindow) Vadjustment() Adjustment

func (s scrolledWindow) Vscrollbar() Widget

func (s scrolledWindow) SetChild(child Widget)

func (s scrolledWindow) SetHadjustment(hadjustment Adjustment)

func (s scrolledWindow) SetHasFrame(hasFrame bool)

func (s scrolledWindow) SetKineticScrolling(kineticScrolling bool)

func (s scrolledWindow) SetMaxContentHeight(height int)

func (s scrolledWindow) SetMaxContentWidth(width int)

func (s scrolledWindow) SetMinContentHeight(height int)

func (s scrolledWindow) SetMinContentWidth(width int)

func (s scrolledWindow) SetOverlayScrolling(overlayScrolling bool)

func (s scrolledWindow) SetPlacement(windowPlacement CornerType)

func (s scrolledWindow) SetPolicy(hscrollbarPolicy PolicyType, vscrollbarPolicy PolicyType)

func (s scrolledWindow) SetPropagateNaturalHeight(propagate bool)

func (s scrolledWindow) SetPropagateNaturalWidth(propagate bool)

func (s scrolledWindow) SetVadjustment(vadjustment Adjustment)

func (s scrolledWindow) UnsetPlacement()

// SearchBar is a container made to have a search entry (possibly with
// additional connex widgets, such as drop-down menus, or buttons) built-in. The
// search bar would appear when a search is started through typing on the
// keyboard, or the application’s search mode is toggled on.
//
// For keyboard presses to start a search, the search bar must be told of a
// widget to capture key events from through
// gtk_search_bar_set_key_capture_widget(). This widget will typically be the
// top-level window, or a parent container of the search bar. Common shortcuts
// such as Ctrl+F should be handled as an application action, or through the
// menu items.
//
// You will also need to tell the search bar about which entry you are using as
// your search entry using gtk_search_bar_connect_entry(). The following example
// shows you how to create a more complex search entry.
//
//
// Creating a search bar
//
// [A simple
// example](https://gitlab.gnome.org/GNOME/gtk/tree/master/examples/search-bar.c)
//
// CSS nodes
//
//    searchbar
//    ╰── revealer
//        ╰── box
//             ├── [child]
//             ╰── [button.close]
//
// GtkSearchBar has a main CSS node with name searchbar. It has a child node
// with name revealer that contains a node with name box. The box node contains
// both the CSS node of the child widget as well as an optional button node
// which gets the .close style class applied.
//
//
// Accessibility
//
// GtkSearchBar uses the GTK_ACCESSIBLE_ROLE_SEARCH role.
type SearchBar interface {
	Widget

	// ConnectEntry: connects the Entry widget passed as the one to be used in
	// this search bar. The entry should be a descendant of the search bar. This
	// is only required if the entry isn’t the direct child of the search bar
	// (as in our main example).
	ConnectEntry(entry Editable)
	// Child: gets the child widget of @bar.
	Child() Widget
	// KeyCaptureWidget: gets the widget that @bar is capturing key events from.
	KeyCaptureWidget() Widget
	// SearchMode: returns whether the search mode is on or off.
	SearchMode() bool
	// ShowCloseButton: returns whether the close button is shown.
	ShowCloseButton() bool
	// SetChild: sets the child widget of @bar.
	SetChild(child Widget)
	// SetKeyCaptureWidget: sets @widget as the widget that @bar will capture
	// key events from.
	//
	// If key events are handled by the search bar, the bar will be shown, and
	// the entry populated with the entered text.
	SetKeyCaptureWidget(widget Widget)
	// SetSearchMode: switches the search mode on or off.
	SetSearchMode(searchMode bool)
	// SetShowCloseButton: shows or hides the close button. Applications that
	// already have a “search” toggle button should not show a close button in
	// their search bar, as it duplicates the role of the toggle button.
	SetShowCloseButton(visible bool)
}

type searchBar struct {
	widget
}

func wrapSearchBar(obj *externglib.Object) SearchBar {
	return searchBar{widget{externglib.InitiallyUnowned{obj}}}
}

func marshalSearchBar(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewSearchBar() SearchBar

func (s searchBar) ConnectEntry(entry Editable)

func (s searchBar) Child() Widget

func (s searchBar) KeyCaptureWidget() Widget

func (s searchBar) SearchMode() bool

func (s searchBar) ShowCloseButton() bool

func (s searchBar) SetChild(child Widget)

func (s searchBar) SetKeyCaptureWidget(widget Widget)

func (s searchBar) SetSearchMode(searchMode bool)

func (s searchBar) SetShowCloseButton(visible bool)

// SearchEntry is an entry widget that has been tailored for use as a search
// entry. The main aPI for interacting with a GtkSearchEntry as entry is the
// Editable interface.
//
// It will show an inactive symbolic “find” icon when the search entry is empty,
// and a symbolic “clear” icon when there is text. Clicking on the “clear” icon
// will empty the search entry.
//
// To make filtering appear more reactive, it is a good idea to not react to
// every change in the entry text immediately, but only after a short delay. To
// support this, SearchEntry emits the SearchEntry::search-changed signal which
// can be used instead of the Editable::changed signal.
//
// The SearchEntry::previous-match, SearchEntry::next-match and
// SearchEntry::stop-search signals can be used to implement moving between
// search results and ending the search.
//
// Often, GtkSearchEntry will be fed events by means of being placed inside a
// SearchBar. If that is not the case, you can use
// gtk_search_entry_set_key_capture_widget() to let it capture key input from
// another widget.
//
// CSS Nodes
//
//    entry.search
//    ╰── text
//
// GtkSearchEntry has a single CSS node with name entry that carries a .sarch
// style class, and the text node is a child of that.
//
//
// Accessibility
//
// GtkSearchEntry uses the K_ACCESSIBLE_ROLE_SEARCH_BOX role.
type SearchEntry interface {
	Widget

	// KeyCaptureWidget: gets the widget that @entry is capturing key events
	// from.
	KeyCaptureWidget() Widget
	// SetKeyCaptureWidget: sets @widget as the widget that @entry will capture
	// key events from.
	//
	// Key events are consumed by the search entry to start or continue a
	// search.
	//
	// If the entry is part of a SearchBar, it is preferable to call
	// gtk_search_bar_set_key_capture_widget() instead, which will reveal the
	// entry in addition to triggering the search entry.
	SetKeyCaptureWidget(widget Widget)
}

type searchEntry struct {
	widget
}

func wrapSearchEntry(obj *externglib.Object) SearchEntry {
	return searchEntry{widget{externglib.InitiallyUnowned{obj}}}
}

func marshalSearchEntry(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewSearchEntry() SearchEntry

func (s searchEntry) KeyCaptureWidget() Widget

func (s searchEntry) SetKeyCaptureWidget(widget Widget)

// SelectionFilterModel is a list model that presents the selected items in a
// SelectionModel as its own list model.
type SelectionFilterModel interface {
	gextras.Objector

	// Model: gets the model currently filtered or nil if none.
	Model() SelectionModel
	// SetModel: sets the model to be filtered.
	//
	// Note that GTK makes no effort to ensure that @model conforms to the item
	// type of @self. It assumes that the caller knows what they are doing and
	// have set up an appropriate filter to ensure that item types match.
	SetModel(model SelectionModel)
}

type selectionFilterModel struct {
	*externglib.Object
}

func wrapSelectionFilterModel(obj *externglib.Object) SelectionFilterModel {
	return selectionFilterModel{*externglib.Object{obj}}
}

func marshalSelectionFilterModel(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewSelectionFilterModel(model SelectionModel) SelectionFilterModel

func (s selectionFilterModel) Model() SelectionModel

func (s selectionFilterModel) SetModel(model SelectionModel)

// Separator: gtkSeparator is a horizontal or vertical separator widget,
// depending on the value of the Orientable:orientation property, used to group
// the widgets within a window. It displays a line with a shadow to make it
// appear sunken into the interface.
//
//
// CSS nodes
//
// GtkSeparator has a single CSS node with name separator. The node gets one of
// the .horizontal or .vertical style classes.
//
//
// Accessibility
//
// GtkSeparator uses the K_ACCESSIBLE_ROLE_SEPARATOR role.
type Separator interface {
	Widget
}

type separator struct {
	widget
}

func wrapSeparator(obj *externglib.Object) Separator {
	return separator{widget{externglib.InitiallyUnowned{obj}}}
}

func marshalSeparator(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewSeparator(orientation Orientation) Separator

// Settings: gtkSettings provide a mechanism to share global settings between
// applications.
//
// On the X window system, this sharing is realized by an
// [XSettings](http://www.freedesktop.org/wiki/Specifications/xsettings-spec)
// manager that is usually part of the desktop environment, along with utilities
// that let the user change these settings.
//
// On Wayland, the settings are obtained either via a settings portal, or by
// reading desktop settings from DConf.
//
// In the absence of these sharing mechanisms, GTK reads default values for
// settings from `settings.ini` files in `/etc/gtk-4.0`,
// `$XDG_CONFIG_DIRS/gtk-4.0` and `$XDG_CONFIG_HOME/gtk-4.0`. These files must
// be valid key files (see File), and have a section called Settings. Themes can
// also provide default values for settings by installing a `settings.ini` file
// next to their `gtk.css` file.
//
// Applications can override system-wide settings by setting the property of the
// GtkSettings object with g_object_set(). This should be restricted to special
// cases though; GtkSettings are not meant as an application configuration
// facility.
//
// There is one GtkSettings instance per display. It can be obtained with
// gtk_settings_get_for_display(), but in many cases, it is more convenient to
// use gtk_widget_get_settings().
type Settings interface {
	gextras.Objector

	// ResetProperty: undoes the effect of calling g_object_set() to install an
	// application-specific value for a setting. After this call, the setting
	// will again follow the session-wide value for this setting.
	ResetProperty(name string)
}

type settings struct {
	*externglib.Object
}

func wrapSettings(obj *externglib.Object) Settings {
	return settings{*externglib.Object{obj}}
}

func marshalSettings(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func (s settings) ResetProperty(name string)

// Shortcut: gtkShortcut is the low level object used for managing keyboard
// shortcuts.
//
// It contains a description of how to trigger the shortcut via a
// ShortcutTrigger and a way to activate the shortcut on a widget via
// ShortcutAction.
//
// The actual work is usually done via ShortcutController, which decides if and
// when to activate a shortcut. Using that controller directly however is rarely
// necessary as various higher level convenience APIs exist on Widgets that make
// it easier to use shortcuts in GTK.
//
// Shortcut does provide functionality to make it easy for users to work with
// shortcuts, either by providing informational strings for display purposes or
// by allowing shortcuts to be configured.
type Shortcut interface {
	gextras.Objector

	// Action: gets the action that is activated by this shortcut.
	Action() ShortcutAction
	// Arguments: gets the arguments that are passed when activating the
	// shortcut.
	Arguments() *glib.Variant
	// Trigger: gets the trigger used to trigger @self.
	Trigger() ShortcutTrigger
	// SetAction: sets the new action for @self to be @action.
	SetAction(action ShortcutAction)
	// SetArguments: sets the arguments to pass when activating the shortcut.
	SetArguments(args *glib.Variant)
	// SetTrigger: sets the new trigger for @self to be @trigger.
	SetTrigger(trigger ShortcutTrigger)
}

type shortcut struct {
	*externglib.Object
}

func wrapShortcut(obj *externglib.Object) Shortcut {
	return shortcut{*externglib.Object{obj}}
}

func marshalShortcut(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewShortcut(trigger ShortcutTrigger, action ShortcutAction) Shortcut

func (s shortcut) Action() ShortcutAction

func (s shortcut) Arguments() *glib.Variant

func (s shortcut) Trigger() ShortcutTrigger

func (s shortcut) SetAction(action ShortcutAction)

func (s shortcut) SetArguments(args *glib.Variant)

func (s shortcut) SetTrigger(trigger ShortcutTrigger)

// ShortcutAction is the object used to describe what a Shortcut should do when
// triggered. To activate a ShortcutAction manually,
// gtk_shortcut_action_activate() can be called.
//
// ShortcutActions contain functions that allow easy presentation to end users
// as well as being printed for debugging.
//
// All ShortcutActions are immutable, you can only specify their properties
// during construction. If you want to change a action, you have to replace it
// with a new one. If you need to pass arguments to an action, these are
// specified by the higher-level Shortcut object.
//
// GTK provides various actions:
//
// - MnemonicAction: a shortcut action that calls gtk_widget_mnemonic_activate()
// - CallbackAction: a shortcut action that invokes a given callback -
// SignalAction: a shortcut action that emits a given signal - ActivateAction: a
// shortcut action that calls gtk_widget_activate() - NamedAction: a shortcut
// action that calls gtk_widget_activate_action() - NothingAction: a shortcut
// action that does nothing
//
//
// GtkShortcutAction as GtkBuildable
//
// GtkShortcut
type ShortcutAction interface {
	gextras.Objector

	// Activate: activates the action on the @widget with the given @args.
	//
	// Note that some actions ignore the passed in @flags, @widget or @args.
	//
	// Activation of an action can fail for various reasons. If the action is
	// not supported by the @widget, if the @args don't match the action or if
	// the activation otherwise had no effect, false will be returned.
	Activate(flags ShortcutActionFlags, widget Widget, args *glib.Variant) bool
	// Print: prints the given action into a string for the developer. This is
	// meant for debugging and logging.
	//
	// The form of the representation may change at any time and is not
	// guaranteed to stay identical.
	Print(string *glib.String)
	// ToString: prints the given action into a human-readable string. This is a
	// small wrapper around gtk_shortcut_action_print() to help when debugging.
	ToString() string
}

type shortcutAction struct {
	*externglib.Object
}

func wrapShortcutAction(obj *externglib.Object) ShortcutAction {
	return shortcutAction{*externglib.Object{obj}}
}

func marshalShortcutAction(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewShortcutAction(string string) ShortcutAction

func (s shortcutAction) Activate(flags ShortcutActionFlags, widget Widget, args *glib.Variant) bool

func (s shortcutAction) Print(string *glib.String)

func (s shortcutAction) ToString() string

// ShortcutController is an event controller that manages shortcuts.
//
// Most common shortcuts are using this controller implicitly, e.g. by adding a
// mnemonic underline to a Label, or by installing a key binding using
// gtk_widget_class_add_binding(), or by adding accelerators to global actions
// using gtk_application_set_accels_for_action().
//
// But it is possible to create your own shortcut controller, and add shortcuts
// to it.
//
// ShortcutController implements Model for querying the shortcuts that have been
// added to it.
//
//
// GtkShortcutController as a GtkBuildable
//
// GtkShortcutControllers can be creates in ui files to set up shortcuts in the
// same place as the widgets.
//
//
//      <object class='GtkButton'>
//        <child>
//          <object class='GtkShortcutController'>
//            <property name='scope'>managed</property>
//            <child>
//              <object class='GtkShortcut'>
//                <property name='trigger'>&amp;lt;Control&amp;gt;k</property>
//                <property name='action'>activate</property>
//              </object>
//            </child>
//          </object>
//        </child>
//      </object>
//
// This example creates a ActivateAction for triggering the `activate` signal of
// the GtkButton. See gtk_shortcut_action_parse_string() for the syntax for
// other kinds of ShortcutAction. See gtk_shortcut_trigger_parse_string() to
// learn more about the syntax for triggers.
type ShortcutController interface {
	EventController

	// AddShortcut: adds @shortcut to the list of shortcuts handled by @self.
	//
	// If this controller uses an external shortcut list, this function does
	// nothing.
	AddShortcut(shortcut Shortcut)
	// MnemonicsModifiers: gets the mnemonics modifiers for when this controller
	// activates its shortcuts. See
	// gtk_shortcut_controller_set_mnemonics_modifiers() for details.
	MnemonicsModifiers() gdk.ModifierType
	// Scope: gets the scope for when this controller activates its shortcuts.
	// See gtk_shortcut_controller_set_scope() for details.
	Scope() ShortcutScope
	// RemoveShortcut: removes @shortcut from the list of shortcuts handled by
	// @self.
	//
	// If @shortcut had not been added to @controller or this controller uses an
	// external shortcut list, this function does nothing.
	RemoveShortcut(shortcut Shortcut)
	// SetMnemonicsModifiers: sets the controller to have the given
	// @mnemonics_modifiers.
	//
	// The mnemonics modifiers determines which modifiers need to be pressed to
	// allow activation of shortcuts with mnemonics triggers.
	//
	// GTK normally uses the Alt modifier for mnemonics, except in PopoverMenus,
	// where mnemonics can be triggered without any modifiers. It should be very
	// rarely necessary to change this, and doing so is likely to interfere with
	// other shortcuts.
	//
	// This value is only relevant for local shortcut controllers. Global and
	// managed shortcut controllers will have their shortcuts activated from
	// other places which have their own modifiers for activating mnemonics.
	SetMnemonicsModifiers(modifiers gdk.ModifierType)
	// SetScope: sets the controller to have the given @scope.
	//
	// The scope allows shortcuts to be activated outside of the normal event
	// propagation. In particular, it allows installing global keyboard
	// shortcuts that can be activated even when a widget does not have focus.
	//
	// With GTK_SHORTCUT_SCOPE_LOCAL, shortcuts will only be activated when the
	// widget has focus.
	SetScope(scope ShortcutScope)
}

type shortcutController struct {
	eventController
}

func wrapShortcutController(obj *externglib.Object) ShortcutController {
	return shortcutController{eventController{*externglib.Object{obj}}}
}

func marshalShortcutController(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewShortcutController() ShortcutController

func NewShortcutController(model gio.ListModel) ShortcutController

func (s shortcutController) AddShortcut(shortcut Shortcut)

func (s shortcutController) MnemonicsModifiers() gdk.ModifierType

func (s shortcutController) Scope() ShortcutScope

func (s shortcutController) RemoveShortcut(shortcut Shortcut)

func (s shortcutController) SetMnemonicsModifiers(modifiers gdk.ModifierType)

func (s shortcutController) SetScope(scope ShortcutScope)

// ShortcutLabel is a widget that represents a single keyboard shortcut or
// gesture in the user interface.
type ShortcutLabel interface {
	Widget

	// Accelerator: retrieves the current accelerator of @self.
	Accelerator() string
	// DisabledText: retrieves the text that is displayed when no accelerator is
	// set.
	DisabledText() string
	// SetAccelerator: sets the accelerator to be displayed by @self.
	SetAccelerator(accelerator string)
	// SetDisabledText: sets the text to be displayed by @self when no
	// accelerator is set.
	SetDisabledText(disabledText string)
}

type shortcutLabel struct {
	widget
}

func wrapShortcutLabel(obj *externglib.Object) ShortcutLabel {
	return shortcutLabel{widget{externglib.InitiallyUnowned{obj}}}
}

func marshalShortcutLabel(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewShortcutLabel(accelerator string) ShortcutLabel

func (s shortcutLabel) Accelerator() string

func (s shortcutLabel) DisabledText() string

func (s shortcutLabel) SetAccelerator(accelerator string)

func (s shortcutLabel) SetDisabledText(disabledText string)

// ShortcutTrigger is the object used to track if a Shortcut should be
// activated. For this purpose, gtk_shortcut_trigger_trigger() can be called on
// a Event.
//
// ShortcutTriggers contain functions that allow easy presentation to end users
// as well as being printed for debugging.
//
// All ShortcutTriggers are immutable, you can only specify their properties
// during construction. If you want to change a trigger, you have to replace it
// with a new one.
type ShortcutTrigger interface {
	gextras.Objector

	// Compare: the types of @trigger1 and @trigger2 are #gconstpointer only to
	// allow use of this function as a Func. They must each be a
	// ShortcutTrigger.
	Compare(trigger2 interface{}) int
	// Equal: checks if @trigger1 and @trigger2 trigger under the same
	// conditions.
	//
	// The types of @one and @two are #gconstpointer only to allow use of this
	// function with Table. They must each be a ShortcutTrigger.
	Equal(trigger2 interface{}) bool
	// Hash: generates a hash value for a ShortcutTrigger.
	//
	// The output of this function is guaranteed to be the same for a given
	// value only per-process. It may change between different processor
	// architectures or even different versions of GTK. Do not use this function
	// as a basis for building protocols or file formats.
	//
	// The types of @trigger is #gconstpointer only to allow use of this
	// function with Table. They must each be a ShortcutTrigger.
	Hash() uint
	// Print: prints the given trigger into a string for the developer. This is
	// meant for debugging and logging.
	//
	// The form of the representation may change at any time and is not
	// guaranteed to stay identical.
	Print(string *glib.String)
	// PrintLabel: prints the given trigger into a string. This function is
	// returning a translated string for presentation to end users for example
	// in menu items or in help texts.
	//
	// The @display in use may influence the resulting string in various forms,
	// such as resolving hardware keycodes or by causing display-specific
	// modifier names.
	//
	// The form of the representation may change at any time and is not
	// guaranteed to stay identical.
	PrintLabel(display gdk.Display, string *glib.String) bool
	// ToLabel: gets textual representation for the given trigger. This function
	// is returning a translated string for presentation to end users for
	// example in menu items or in help texts.
	//
	// The @display in use may influence the resulting string in various forms,
	// such as resolving hardware keycodes or by causing display-specific
	// modifier names.
	//
	// The form of the representation may change at any time and is not
	// guaranteed to stay identical.
	ToLabel(display gdk.Display) string
	// ToString: prints the given trigger into a human-readable string. This is
	// a small wrapper around gtk_shortcut_trigger_print() to help when
	// debugging.
	ToString() string
	// Trigger: checks if the given @event triggers @self.
	Trigger(event gdk.Event, enableMnemonics bool) gdk.KeyMatch
}

type shortcutTrigger struct {
	*externglib.Object
}

func wrapShortcutTrigger(obj *externglib.Object) ShortcutTrigger {
	return shortcutTrigger{*externglib.Object{obj}}
}

func marshalShortcutTrigger(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewShortcutTrigger(string string) ShortcutTrigger

func (s shortcutTrigger) Compare(trigger2 interface{}) int

func (s shortcutTrigger) Equal(trigger2 interface{}) bool

func (s shortcutTrigger) Hash() uint

func (s shortcutTrigger) Print(string *glib.String)

func (s shortcutTrigger) PrintLabel(display gdk.Display, string *glib.String) bool

func (s shortcutTrigger) ToLabel(display gdk.Display) string

func (s shortcutTrigger) ToString() string

func (s shortcutTrigger) Trigger(event gdk.Event, enableMnemonics bool) gdk.KeyMatch

// ShortcutsGroup: a GtkShortcutsGroup represents a group of related keyboard
// shortcuts or gestures. The group has a title. It may optionally be associated
// with a view of the application, which can be used to show only relevant
// shortcuts depending on the application context.
//
// This widget is only meant to be used with ShortcutsWindow.
type ShortcutsGroup interface {
	Box
}

type shortcutsGroup struct {
	box
}

func wrapShortcutsGroup(obj *externglib.Object) ShortcutsGroup {
	return shortcutsGroup{box{widget{externglib.InitiallyUnowned{obj}}}}
}

func marshalShortcutsGroup(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// ShortcutsSection: a GtkShortcutsSection collects all the keyboard shortcuts
// and gestures for a major application mode. If your application needs multiple
// sections, you should give each section a unique ShortcutsSection:section-name
// and a ShortcutsSection:title that can be shown in the section selector of the
// GtkShortcutsWindow.
//
// The ShortcutsSection:max-height property can be used to influence how the
// groups in the section are distributed over pages and columns.
//
// This widget is only meant to be used with ShortcutsWindow.
type ShortcutsSection interface {
	Box
}

type shortcutsSection struct {
	box
}

func wrapShortcutsSection(obj *externglib.Object) ShortcutsSection {
	return shortcutsSection{box{widget{externglib.InitiallyUnowned{obj}}}}
}

func marshalShortcutsSection(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// ShortcutsShortcut: a GtkShortcutsShortcut represents a single keyboard
// shortcut or gesture with a short text. This widget is only meant to be used
// with ShortcutsWindow.
type ShortcutsShortcut interface {
	Widget
}

type shortcutsShortcut struct {
	widget
}

func wrapShortcutsShortcut(obj *externglib.Object) ShortcutsShortcut {
	return shortcutsShortcut{widget{externglib.InitiallyUnowned{obj}}}
}

func marshalShortcutsShortcut(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// ShortcutsWindow: a GtkShortcutsWindow shows brief information about the
// keyboard shortcuts and gestures of an application. The shortcuts can be
// grouped, and you can have multiple sections in this window, corresponding to
// the major modes of your application.
//
// Additionally, the shortcuts can be filtered by the current view, to avoid
// showing information that is not relevant in the current application context.
//
// The recommended way to construct a GtkShortcutsWindow is with GtkBuilder, by
// populating a ShortcutsWindow with one or more ShortcutsSection objects, which
// contain ShortcutsGroups that in turn contain objects of class
// ShortcutsShortcut.
//
// A simple example:
//
// ![](gedit-shortcuts.png)
//
// This example has as single section. As you can see, the shortcut groups are
// arranged in columns, and spread across several pages if there are too many to
// find on a single page.
//
// The .ui file for this example can be found
// [here](https://gitlab.gnome.org/GNOME/gtk/tree/master/demos/gtk-demo/shortcuts-gedit.ui).
//
// An example with multiple views:
//
// ![](clocks-shortcuts.png)
//
// This example shows a ShortcutsWindow that has been configured to show only
// the shortcuts relevant to the "stopwatch" view.
//
// The .ui file for this example can be found
// [here](https://gitlab.gnome.org/GNOME/gtk/tree/master/demos/gtk-demo/shortcuts-clocks.ui).
//
// An example with multiple sections:
//
// ![](builder-shortcuts.png)
//
// This example shows a ShortcutsWindow with two sections, "Editor Shortcuts"
// and "Terminal Shortcuts".
//
// The .ui file for this example can be found
// [here](https://gitlab.gnome.org/GNOME/gtk/tree/master/demos/gtk-demo/shortcuts-builder.ui).
type ShortcutsWindow interface {
	Window
}

type shortcutsWindow struct {
	window
}

func wrapShortcutsWindow(obj *externglib.Object) ShortcutsWindow {
	return shortcutsWindow{window{widget{externglib.InitiallyUnowned{obj}}}}
}

func marshalShortcutsWindow(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// SignalAction: a ShortcutAction that emits a signal.
//
// Signals that are used in this way are referred to as keybinding signals, and
// they are expected to be defined with the G_SIGNAL_ACTION flag.
type SignalAction interface {
	ShortcutAction

	// SignalName: returns the name of the signal that will be emitted.
	SignalName() string
}

type signalAction struct {
	shortcutAction
}

func wrapSignalAction(obj *externglib.Object) SignalAction {
	return signalAction{shortcutAction{*externglib.Object{obj}}}
}

func marshalSignalAction(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewSignalAction(signalName string) SignalAction

func (s signalAction) SignalName() string

// SignalListItemFactory is a ListItemFactory that provides signals that user
// code can connect to to manage listitems. Signals are emitted for every
// listitem in the same order:
//
// 1. SignalListItemFactory::setup is emitted to set up permanent things on the
// listitem. This usually means constructing the widgets used in the row and
// adding them to the listitem.
//
// 2. SignalListItemFactory::bind is emitted to bind the item passed via
// ListItem:item to the widgets that have been created in step 1 or to add
// item-specific widgets. Signals are connected to listen to changes - both to
// changes in the item to update the widgets or to changes in the widgets to
// update the item. After this signal has been called, the listitem may be shown
// in a list widget.
//
// 3. SignalListItemFactory::unbind is emitted to undo everything done in step
// 2. Usually this means disconnecting signal handlers. Once this signal has
// been called, the listitem will no longer be used in a list widget.
//
// 4. SignalListItemFactory::bind and SignalListItemFactory::unbind may be
// emitted multiple times again to bind the listitem for use with new items. By
// reusing listitems, potentially costly setup can be avoided. However, it means
// code needs to make sure to properly clean up the listitem in step 3 so that
// no information from the previous use leaks into the next use.
//
// 5. SignalListItemFactory::teardown is emitted to allow undoing the effects of
// SignalListItemFactory::setup. After this signal was emitted on a listitem,
// the listitem will be destroyed and not be used again.
//
// Note that during the signal emissions, changing properties on the ListItems
// passed will not trigger notify signals as the listitem's notifications are
// frozen. See g_object_freeze_notify() for details.
//
// For tracking changes in other properties in the ListItem, the
// ListItem::notify signal is recommended. The signal can be connected in the
// SignalListItemFactory::setup signal and removed again during
// SignalListItemFactory::teardown.
type SignalListItemFactory interface {
	ListItemFactory
}

type signalListItemFactory struct {
	listItemFactory
}

func wrapSignalListItemFactory(obj *externglib.Object) SignalListItemFactory {
	return signalListItemFactory{listItemFactory{*externglib.Object{obj}}}
}

func marshalSignalListItemFactory(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewSignalListItemFactory() SignalListItemFactory

// SingleSelection: gtkSingleSelection is an implementation of the
// SelectionModel interface that allows selecting a single element. It is the
// default selection method used by list widgets in GTK.
//
// Note that the selection is *persistent* -- if the selected item is removed
// and re-added in the same Model::items-changed emission, it stays selected. In
// particular, this means that changing the sort order of an underlying sort
// model will preserve the selection.
type SingleSelection interface {
	gextras.Objector

	// Autoselect: checks if autoselect has been enabled or disabled via
	// gtk_single_selection_set_autoselect().
	Autoselect() bool
	// CanUnselect: if true, gtk_selection_model_unselect_item() is supported
	// and allows unselecting the selected item.
	CanUnselect() bool
	// Model: gets the model that @self is wrapping.
	Model() gio.ListModel
	// Selected: gets the position of the selected item. If no item is selected,
	// K_INVALID_LIST_POSITION is returned.
	Selected() uint
	// SelectedItem: gets the selected item.
	//
	// If no item is selected, nil is returned.
	SelectedItem() interface{}
	// SetAutoselect: if @autoselect is true, @self will enforce that an item is
	// always selected. It will select a new item when the currently selected
	// item is deleted and it will disallow unselecting the current item.
	SetAutoselect(autoselect bool)
	// SetCanUnselect: if true, unselecting the current item via
	// gtk_selection_model_unselect_item() is supported.
	//
	// Note that setting SingleSelection:autoselect will cause the unselecting
	// to not work, so it practically makes no sense to set both at the same
	// time the same time.
	SetCanUnselect(canUnselect bool)
	// SetModel: sets the model that @self should wrap. If @model is nil, @self
	// will be empty.
	SetModel(model gio.ListModel)
	// SetSelected: selects the item at the given position.
	//
	// If the list does not have an item at @position or K_INVALID_LIST_POSITION
	// is given, the behavior depends on the value of the
	// SingleSelection:autoselect property: If it is set, no change will occur
	// and the old item will stay selected. If it is unset, the selection will
	// be unset and no item will be selected.
	SetSelected(position uint)
}

type singleSelection struct {
	*externglib.Object
}

func wrapSingleSelection(obj *externglib.Object) SingleSelection {
	return singleSelection{*externglib.Object{obj}}
}

func marshalSingleSelection(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewSingleSelection(model gio.ListModel) SingleSelection

func (s singleSelection) Autoselect() bool

func (s singleSelection) CanUnselect() bool

func (s singleSelection) Model() gio.ListModel

func (s singleSelection) Selected() uint

func (s singleSelection) SelectedItem() interface{}

func (s singleSelection) SetAutoselect(autoselect bool)

func (s singleSelection) SetCanUnselect(canUnselect bool)

func (s singleSelection) SetModel(model gio.ListModel)

func (s singleSelection) SetSelected(position uint)

// SizeGroup provides a mechanism for grouping a number of widgets together so
// they all request the same amount of space. This is typically useful when you
// want a column of widgets to have the same size, but you can’t use a Grid
// widget.
//
// In detail, the size requested for each widget in a SizeGroup is the maximum
// of the sizes that would have been requested for each widget in the size group
// if they were not in the size group. The mode of the size group (see
// gtk_size_group_set_mode()) determines whether this applies to the horizontal
// size, the vertical size, or both sizes.
//
// Note that size groups only affect the amount of space requested, not the size
// that the widgets finally receive. If you want the widgets in a SizeGroup to
// actually be the same size, you need to pack them in such a way that they get
// the size they request and not more. For example, if you are packing your
// widgets into a table, you would not include the GTK_FILL flag.
//
// SizeGroup objects are referenced by each widget in the size group, so once
// you have added all widgets to a SizeGroup, you can drop the initial reference
// to the size group with g_object_unref(). If the widgets in the size group are
// subsequently destroyed, then they will be removed from the size group and
// drop their references on the size group; when all widgets have been removed,
// the size group will be freed.
//
// Widgets can be part of multiple size groups; GTK will compute the horizontal
// size of a widget from the horizontal requisition of all widgets that can be
// reached from the widget by a chain of size groups of type
// GTK_SIZE_GROUP_HORIZONTAL or GTK_SIZE_GROUP_BOTH, and the vertical size from
// the vertical requisition of all widgets that can be reached from the widget
// by a chain of size groups of type GTK_SIZE_GROUP_VERTICAL or
// GTK_SIZE_GROUP_BOTH.
//
// Note that only non-contextual sizes of every widget are ever consulted by
// size groups (since size groups have no knowledge of what size a widget will
// be allocated in one dimension, it cannot derive how much height a widget will
// receive for a given width). When grouping widgets that trade height for width
// in mode GTK_SIZE_GROUP_VERTICAL or GTK_SIZE_GROUP_BOTH: the height for the
// minimum width will be the requested height for all widgets in the group. The
// same is of course true when horizontally grouping width for height widgets.
//
// Widgets that trade height-for-width should set a reasonably large minimum
// width by way of Label:width-chars for instance. Widgets with static sizes as
// well as widgets that grow (such as ellipsizing text) need no such
// considerations.
//
//
// GtkSizeGroup as GtkBuildable
//
// Size groups can be specified in a UI definition by placing an <object>
// element with `class="GtkSizeGroup"` somewhere in the UI definition. The
// widgets that belong to the size group are specified by a <widgets> element
// that may contain multiple <widget> elements, one for each member of the size
// group. The ”name” attribute gives the id of the widget.
//
//
//    <object class="GtkSizeGroup">
//      <property name="mode">horizontal</property>
//      <widgets>
//        <widget name="radio1"/>
//        <widget name="radio2"/>
//      </widgets>
//    </object>
type SizeGroup interface {
	gextras.Objector

	// AddWidget: adds a widget to a SizeGroup. In the future, the requisition
	// of the widget will be determined as the maximum of its requisition and
	// the requisition of the other widgets in the size group. Whether this
	// applies horizontally, vertically, or in both directions depends on the
	// mode of the size group. See gtk_size_group_set_mode().
	//
	// When the widget is destroyed or no longer referenced elsewhere, it will
	// be removed from the size group.
	AddWidget(widget Widget)
	// Mode: gets the current mode of the size group. See
	// gtk_size_group_set_mode().
	Mode() SizeGroupMode
	// Widgets: returns the list of widgets associated with @size_group.
	Widgets() *glib.SList
	// RemoveWidget: removes a widget from a SizeGroup.
	RemoveWidget(widget Widget)
	// SetMode: sets the SizeGroupMode of the size group. The mode of the size
	// group determines whether the widgets in the size group should all have
	// the same horizontal requisition (GTK_SIZE_GROUP_HORIZONTAL) all have the
	// same vertical requisition (GTK_SIZE_GROUP_VERTICAL), or should all have
	// the same requisition in both directions (GTK_SIZE_GROUP_BOTH).
	SetMode(mode SizeGroupMode)
}

type sizeGroup struct {
	*externglib.Object
}

func wrapSizeGroup(obj *externglib.Object) SizeGroup {
	return sizeGroup{*externglib.Object{obj}}
}

func marshalSizeGroup(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewSizeGroup(mode SizeGroupMode) SizeGroup

func (s sizeGroup) AddWidget(widget Widget)

func (s sizeGroup) Mode() SizeGroupMode

func (s sizeGroup) Widgets() *glib.SList

func (s sizeGroup) RemoveWidget(widget Widget)

func (s sizeGroup) SetMode(mode SizeGroupMode)

// SliceListModel is a list model that takes a list model and presents a slice
// of that model.
//
// This is useful when implementing paging by setting the size to the number of
// elements per page and updating the offset whenever a different page is
// opened.
type SliceListModel interface {
	gextras.Objector

	// Model: gets the model that is currently being used or nil if none.
	Model() gio.ListModel
	// Offset: gets the offset set via gtk_slice_list_model_set_offset()
	Offset() uint
	// Size: gets the size set via gtk_slice_list_model_set_size().
	Size() uint
	// SetModel: sets the model to show a slice of. The model's item type must
	// conform to @self's item type.
	SetModel(model gio.ListModel)
	// SetOffset: sets the offset into the original model for this slice.
	//
	// If the offset is too large for the sliced model, @self will end up empty.
	SetOffset(offset uint)
	// SetSize: sets the maximum size. @self will never have more items than
	// @size.
	//
	// It can however have fewer items if the offset is too large or the model
	// sliced from doesn't have enough items.
	SetSize(size uint)
}

type sliceListModel struct {
	*externglib.Object
}

func wrapSliceListModel(obj *externglib.Object) SliceListModel {
	return sliceListModel{*externglib.Object{obj}}
}

func marshalSliceListModel(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewSliceListModel(model gio.ListModel, offset uint, size uint) SliceListModel

func (s sliceListModel) Model() gio.ListModel

func (s sliceListModel) Offset() uint

func (s sliceListModel) Size() uint

func (s sliceListModel) SetModel(model gio.ListModel)

func (s sliceListModel) SetOffset(offset uint)

func (s sliceListModel) SetSize(size uint)

// Snapshot: gtkSnapshot is an auxiliary object that assists in creating
// RenderNodes in the PaintableInterface.snapshot() vfunc. It functions in a
// similar way to a cairo context, and maintains a stack of render nodes and
// their associated transformations.
//
// The node at the top of the stack is the the one that gtk_snapshot_append_…
// functions operate on. Use the gtk_snapshot_push_… functions and
// gtk_snapshot_pop() to change the current node.
//
// The typical way to obtain a GtkSnapshot object is as an argument to the
// WidgetClass.snapshot() vfunc. If you need to create your own GtkSnapshot, use
// gtk_snapshot_new().
type Snapshot interface {
	gdk.Snapshot

	// AppendBorder: appends a stroked border rectangle inside the given
	// @outline. The 4 sides of the border can have different widths and colors.
	AppendBorder(outline *gsk.RoundedRect, borderWidth [4]float32, borderColor [4]gdk.RGBA)
	// AppendCairo: creates a new render node and appends it to the current
	// render node of @snapshot, without changing the current node.
	AppendCairo(bounds *graphene.Rect) *cairo.Context
	// AppendColor: creates a new render node drawing the @color into the given
	// @bounds and appends it to the current render node of @snapshot.
	//
	// You should try to avoid calling this function if @color is transparent.
	AppendColor(color *gdk.RGBA, bounds *graphene.Rect)
	// AppendConicGradient: appends a conic gradient node with the given stops
	// to @snapshot.
	AppendConicGradient(bounds *graphene.Rect, center *graphene.Point, rotation float32, stops []gsk.ColorStop)
	// AppendInsetShadow: appends an inset shadow into the box given by
	// @outline.
	AppendInsetShadow(outline *gsk.RoundedRect, color *gdk.RGBA, dx float32, dy float32, spread float32, blurRadius float32)

	AppendLayout(layout pango.Layout, color *gdk.RGBA)
	// AppendLinearGradient: appends a linear gradient node with the given stops
	// to @snapshot.
	AppendLinearGradient(bounds *graphene.Rect, startPoint *graphene.Point, endPoint *graphene.Point, stops []gsk.ColorStop)
	// AppendNode: appends @node to the current render node of @snapshot,
	// without changing the current node. If @snapshot does not have a current
	// node yet, @node will become the initial node.
	AppendNode(node gsk.RenderNode)
	// AppendOutsetShadow: appends an outset shadow node around the box given by
	// @outline.
	AppendOutsetShadow(outline *gsk.RoundedRect, color *gdk.RGBA, dx float32, dy float32, spread float32, blurRadius float32)
	// AppendRadialGradient: appends a radial gradient node with the given stops
	// to @snapshot.
	AppendRadialGradient(bounds *graphene.Rect, center *graphene.Point, hradius float32, vradius float32, start float32, end float32, stops []gsk.ColorStop)
	// AppendRepeatingLinearGradient: appends a repeating linear gradient node
	// with the given stops to @snapshot.
	AppendRepeatingLinearGradient(bounds *graphene.Rect, startPoint *graphene.Point, endPoint *graphene.Point, stops []gsk.ColorStop)
	// AppendRepeatingRadialGradient: appends a repeating radial gradient node
	// with the given stops to @snapshot.
	AppendRepeatingRadialGradient(bounds *graphene.Rect, center *graphene.Point, hradius float32, vradius float32, start float32, end float32, stops []gsk.ColorStop)
	// AppendTexture: creates a new render node drawing the @texture into the
	// given @bounds and appends it to the current render node of @snapshot.
	AppendTexture(texture gdk.Texture, bounds *graphene.Rect)
	// FreeToNode: returns the node that was constructed by @snapshot and frees
	// @snapshot.
	FreeToNode() gsk.RenderNode
	// FreeToPaintable: returns a paintable for the node that was constructed by
	// @snapshot and frees @snapshot.
	FreeToPaintable(size *graphene.Size) gdk.Paintable
	// GLShaderPopTexture: removes the top element from the stack of render
	// nodes and adds it to the nearest GskGLShaderNode below it. This must be
	// called the same number of times as the number of textures is needed for
	// the shader in gtk_snapshot_push_gl_shader().
	GLShaderPopTexture()
	// Perspective: applies a perspective projection transform.
	//
	// See gsk_transform_perspective() for a discussion on the details.
	Perspective(depth float32)
	// Pop: removes the top element from the stack of render nodes, and appends
	// it to the node underneath it.
	Pop()
	// PushBlend: blends together 2 images with the given blend mode.
	//
	// Until the first call to gtk_snapshot_pop(), the bottom image for the
	// blend operation will be recorded. After that call, the top image to be
	// blended will be recorded until the second call to gtk_snapshot_pop().
	//
	// Calling this function requires 2 subsequent calls to gtk_snapshot_pop().
	PushBlend(blendMode gsk.BlendMode)
	// PushBlur: blurs an image.
	//
	// The image is recorded until the next call to gtk_snapshot_pop().
	PushBlur(radius float64)
	// PushClip: clips an image to a rectangle.
	//
	// The image is recorded until the next call to gtk_snapshot_pop().
	PushClip(bounds *graphene.Rect)
	// PushColorMatrix: modifies the colors of an image by applying an affine
	// transformation in RGB space.
	//
	// The image is recorded until the next call to gtk_snapshot_pop().
	PushColorMatrix(colorMatrix *graphene.Matrix, colorOffset *graphene.Vec4)
	// PushCrossFade: snapshots a cross-fade operation between two images with
	// the given @progress.
	//
	// Until the first call to gtk_snapshot_pop(), the start image will be
	// snapshot. After that call, the end image will be recorded until the
	// second call to gtk_snapshot_pop().
	//
	// Calling this function requires 2 calls to gtk_snapshot_pop().
	PushCrossFade(progress float64)
	// PushGLShader: push a GLShaderNode with a specific GLShader and a set of
	// uniform values to use while rendering. Additionally this takes a list of
	// @n_children other nodes which will be passed to the GLShaderNode.
	//
	// The @take_args argument is a block of data to use for uniform arguments,
	// as per types and offsets defined by the @shader. Normally this is
	// generated by gsk_gl_shader_format_args() or GLShaderArgBuilder. The
	// snapshotter takes ownership of @take_args, so the caller should not free
	// it after this.
	//
	// If the renderer doesn't support GL shaders, or if there is any problem
	// when compiling the shader, then the node will draw pink. You should use
	// gsk_gl_shader_compile() to ensure the @shader will work for the renderer
	// before using it.
	//
	// If the shader requires textures (see gsk_gl_shader_get_n_textures()),
	// then it is expected that you call gtk_snapshot_gl_shader_pop_texture()
	// the number of times that are required. Each of these calls will generate
	// a node that is added as a child to the gl shader node, which in turn will
	// render these offscreen and pass as a texture to the shader.
	//
	// Once all textures (if any) are pop:ed, you must call the regular
	// gtk_snapshot_pop().
	//
	// If you want to use pre-existing textures as input to the shader rather
	// than rendering new ones, use gtk_snapshot_append_texture() to push a
	// texture node. These will be used directly rather than being re-rendered.
	//
	// For details on how to write shaders, see GLShader.
	PushGLShader(shader gsk.GLShader, bounds *graphene.Rect, takeArgs *glib.Bytes)
	// PushOpacity: modifies the opacity of an image.
	//
	// The image is recorded until the next call to gtk_snapshot_pop().
	PushOpacity(opacity float64)
	// PushRepeat: creates a node that repeats the child node.
	//
	// The child is recorded until the next call to gtk_snapshot_pop().
	PushRepeat(bounds *graphene.Rect, childBounds *graphene.Rect)
	// PushRoundedClip: clips an image to a rounded rectangle.
	//
	// The image is recorded until the next call to gtk_snapshot_pop().
	PushRoundedClip(bounds *gsk.RoundedRect)
	// PushShadow: applies a shadow to an image.
	//
	// The image is recorded until the next call to gtk_snapshot_pop().
	PushShadow(shadow *gsk.Shadow, nShadows uint)
	// RenderBackground: creates a render node for the CSS background according
	// to @context, and appends it to the current node of @snapshot, without
	// changing the current node.
	RenderBackground(context StyleContext, x float64, y float64, width float64, height float64)
	// RenderFocus: creates a render node for the focus outline according to
	// @context, and appends it to the current node of @snapshot, without
	// changing the current node.
	RenderFocus(context StyleContext, x float64, y float64, width float64, height float64)
	// RenderFrame: creates a render node for the CSS border according to
	// @context, and appends it to the current node of @snapshot, without
	// changing the current node.
	RenderFrame(context StyleContext, x float64, y float64, width float64, height float64)
	// RenderInsertionCursor: draws a text caret using @snapshot at the
	// specified index of @layout.
	RenderInsertionCursor(context StyleContext, x float64, y float64, layout pango.Layout, index int, direction pango.Direction)
	// RenderLayout: creates a render node for rendering @layout according to
	// the style information in @context, and appends it to the current node of
	// @snapshot, without changing the current node.
	RenderLayout(context StyleContext, x float64, y float64, layout pango.Layout)
	// Restore: restores @snapshot to the state saved by a preceding call to
	// gtk_snapshot_save() and removes that state from the stack of saved
	// states.
	Restore()
	// Rotate: rotates @@snapshot's coordinate system by @angle degrees in 2D
	// space - or in 3D speak, rotates around the z axis.
	Rotate(angle float32)
	// Rotate3D: rotates @snapshot's coordinate system by @angle degrees around
	// @axis.
	//
	// For a rotation in 2D space, use gsk_transform_rotate().
	Rotate3D(angle float32, axis *graphene.Vec3)
	// Save: makes a copy of the current state of @snapshot and saves it on an
	// internal stack of saved states for @snapshot. When gtk_snapshot_restore()
	// is called, @snapshot will be restored to the saved state. Multiple calls
	// to gtk_snapshot_save() and gtk_snapshot_restore() can be nested; each
	// call to gtk_snapshot_restore() restores the state from the matching
	// paired gtk_snapshot_save().
	//
	// It is necessary to clear all saved states with corresponding calls to
	// gtk_snapshot_restore().
	Save()
	// Scale: scales @snapshot's coordinate system in 2-dimensional space by the
	// given factors.
	//
	// Use gtk_snapshot_scale_3d() to scale in all 3 dimensions.
	Scale(factorX float32, factorY float32)
	// Scale3D: scales @snapshot's coordinate system by the given factors.
	Scale3D(factorX float32, factorY float32, factorZ float32)
	// ToNode: returns the render node that was constructed by @snapshot. After
	// calling this function, it is no longer possible to add more nodes to
	// @snapshot. The only function that should be called after this is
	// g_object_unref().
	ToNode() gsk.RenderNode
	// ToPaintable: returns a paintable encapsulating the render node that was
	// constructed by @snapshot. After calling this function, it is no longer
	// possible to add more nodes to @snapshot. The only function that should be
	// called after this is g_object_unref().
	ToPaintable(size *graphene.Size) gdk.Paintable
	// Transform: transforms @snapshot's coordinate system with the given
	// @transform.
	Transform(transform *gsk.Transform)
	// TransformMatrix: transforms @snapshot's coordinate system with the given
	// @matrix.
	TransformMatrix(matrix *graphene.Matrix)
	// Translate: translates @snapshot's coordinate system by @point in
	// 2-dimensional space.
	Translate(point *graphene.Point)
	// Translate3D: translates @snapshot's coordinate system by @point.
	Translate3D(point *graphene.Point3D)
}

type snapshot struct {
	gdk.snapshot
}

func wrapSnapshot(obj *externglib.Object) Snapshot {
	return snapshot{gdk.snapshot{*externglib.Object{obj}}}
}

func marshalSnapshot(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewSnapshot() Snapshot

func (s snapshot) AppendBorder(outline *gsk.RoundedRect, borderWidth [4]float32, borderColor [4]gdk.RGBA)

func (s snapshot) AppendCairo(bounds *graphene.Rect) *cairo.Context

func (s snapshot) AppendColor(color *gdk.RGBA, bounds *graphene.Rect)

func (s snapshot) AppendConicGradient(bounds *graphene.Rect, center *graphene.Point, rotation float32, stops []gsk.ColorStop)

func (s snapshot) AppendInsetShadow(outline *gsk.RoundedRect, color *gdk.RGBA, dx float32, dy float32, spread float32, blurRadius float32)

func (s snapshot) AppendLayout(layout pango.Layout, color *gdk.RGBA)

func (s snapshot) AppendLinearGradient(bounds *graphene.Rect, startPoint *graphene.Point, endPoint *graphene.Point, stops []gsk.ColorStop)

func (s snapshot) AppendNode(node gsk.RenderNode)

func (s snapshot) AppendOutsetShadow(outline *gsk.RoundedRect, color *gdk.RGBA, dx float32, dy float32, spread float32, blurRadius float32)

func (s snapshot) AppendRadialGradient(bounds *graphene.Rect, center *graphene.Point, hradius float32, vradius float32, start float32, end float32, stops []gsk.ColorStop)

func (s snapshot) AppendRepeatingLinearGradient(bounds *graphene.Rect, startPoint *graphene.Point, endPoint *graphene.Point, stops []gsk.ColorStop)

func (s snapshot) AppendRepeatingRadialGradient(bounds *graphene.Rect, center *graphene.Point, hradius float32, vradius float32, start float32, end float32, stops []gsk.ColorStop)

func (s snapshot) AppendTexture(texture gdk.Texture, bounds *graphene.Rect)

func (s snapshot) FreeToNode() gsk.RenderNode

func (s snapshot) FreeToPaintable(size *graphene.Size) gdk.Paintable

func (s snapshot) GLShaderPopTexture()

func (s snapshot) Perspective(depth float32)

func (s snapshot) Pop()

func (s snapshot) PushBlend(blendMode gsk.BlendMode)

func (s snapshot) PushBlur(radius float64)

func (s snapshot) PushClip(bounds *graphene.Rect)

func (s snapshot) PushColorMatrix(colorMatrix *graphene.Matrix, colorOffset *graphene.Vec4)

func (s snapshot) PushCrossFade(progress float64)

func (s snapshot) PushGLShader(shader gsk.GLShader, bounds *graphene.Rect, takeArgs *glib.Bytes)

func (s snapshot) PushOpacity(opacity float64)

func (s snapshot) PushRepeat(bounds *graphene.Rect, childBounds *graphene.Rect)

func (s snapshot) PushRoundedClip(bounds *gsk.RoundedRect)

func (s snapshot) PushShadow(shadow *gsk.Shadow, nShadows uint)

func (s snapshot) RenderBackground(context StyleContext, x float64, y float64, width float64, height float64)

func (s snapshot) RenderFocus(context StyleContext, x float64, y float64, width float64, height float64)

func (s snapshot) RenderFrame(context StyleContext, x float64, y float64, width float64, height float64)

func (s snapshot) RenderInsertionCursor(context StyleContext, x float64, y float64, layout pango.Layout, index int, direction pango.Direction)

func (s snapshot) RenderLayout(context StyleContext, x float64, y float64, layout pango.Layout)

func (s snapshot) Restore()

func (s snapshot) Rotate(angle float32)

func (s snapshot) Rotate3D(angle float32, axis *graphene.Vec3)

func (s snapshot) Save()

func (s snapshot) Scale(factorX float32, factorY float32)

func (s snapshot) Scale3D(factorX float32, factorY float32, factorZ float32)

func (s snapshot) ToNode() gsk.RenderNode

func (s snapshot) ToPaintable(size *graphene.Size) gdk.Paintable

func (s snapshot) Transform(transform *gsk.Transform)

func (s snapshot) TransformMatrix(matrix *graphene.Matrix)

func (s snapshot) Translate(point *graphene.Point)

func (s snapshot) Translate3D(point *graphene.Point3D)

// SortListModel is a list model that takes a list model and sorts its elements
// according to a Sorter.
//
// The model can be set up to do incremental sorting, so that sorting long lists
// doesn't block the UI. See gtk_sort_list_model_set_incremental() for details.
//
// SortListModel is a generic model and because of that it cannot take advantage
// of any external knowledge when sorting. If you run into performance issues
// with SortListModel, it is strongly recommended that you write your own
// sorting list model.
type SortListModel interface {
	gextras.Objector

	// Incremental: returns whether incremental sorting was enabled via
	// gtk_sort_list_model_set_incremental().
	Incremental() bool
	// Model: gets the model currently sorted or nil if none.
	Model() gio.ListModel
	// Pending: estimates progress of an ongoing sorting operation
	//
	// The estimate is the number of items that would still need to be sorted to
	// finish the sorting operation if this was a linear algorithm. So this
	// number is not related to how many items are already correctly sorted.
	//
	//    pending = gtk_sort_list_model_get_pending (self);
	//    model = gtk_sort_list_model_get_model (self);
	//    progress = 1.0 - pending / (double) MAX (1, g_list_model_get_n_items (model));
	//
	// If no sort operation is ongoing - in particular when
	// SortListModel:incremental is false - this function returns 0.
	Pending() uint
	// Sorter: gets the sorter that is used to sort @self.
	Sorter() Sorter
	// SetIncremental: sets the sort model to do an incremental sort.
	//
	// When incremental sorting is enabled, the sortlistmodel will not do a
	// complete sort immediately, but will instead queue an idle handler that
	// incrementally sorts the items towards their correct position. This of
	// course means that items do not instantly appear in the right place. It
	// also means that the total sorting time is a lot slower.
	//
	// When your filter blocks the UI while sorting, you might consider turning
	// this on. Depending on your model and sorters, this may become interesting
	// around 10,000 to 100,000 items.
	//
	// By default, incremental sorting is disabled.
	//
	// See gtk_sort_list_model_get_pending() for progress information about an
	// ongoing incremental sorting operation.
	SetIncremental(incremental bool)
	// SetModel: sets the model to be sorted. The @model's item type must
	// conform to the item type of @self.
	SetModel(model gio.ListModel)
	// SetSorter: sets a new sorter on @self.
	SetSorter(sorter Sorter)
}

type sortListModel struct {
	*externglib.Object
}

func wrapSortListModel(obj *externglib.Object) SortListModel {
	return sortListModel{*externglib.Object{obj}}
}

func marshalSortListModel(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewSortListModel(model gio.ListModel, sorter Sorter) SortListModel

func (s sortListModel) Incremental() bool

func (s sortListModel) Model() gio.ListModel

func (s sortListModel) Pending() uint

func (s sortListModel) Sorter() Sorter

func (s sortListModel) SetIncremental(incremental bool)

func (s sortListModel) SetModel(model gio.ListModel)

func (s sortListModel) SetSorter(sorter Sorter)

// Sorter is the way to describe sorting criteria. Its primary user is
// SortListModel.
//
// The model will use a sorter to determine the order in which its items should
// appear by calling gtk_sorter_compare() for pairs of items.
//
// Sorters may change their sorting behavior through their lifetime. In that
// case, they will emit the Sorter::changed signal to notify that the sort order
// is no longer valid and should be updated by calling gtk_sorter_compare()
// again.
//
// GTK provides various pre-made sorter implementations for common sorting
// operations. ColumnView has built-in support for sorting lists via the
// ColumnViewColumn:sorter property, where the user can change the sorting by
// clicking on list headers.
//
// Of course, in particular for large lists, it is also possible to subclass
// Sorter and provide one's own sorter.
type Sorter interface {
	gextras.Objector

	// Changed: emits the Sorter::changed signal to notify all users of the
	// sorter that it has changed. Users of the sorter should then update the
	// sort order via gtk_sorter_compare().
	//
	// Depending on the @change parameter, it may be possible to update the sort
	// order without a full resorting. Refer to the SorterChange documentation
	// for details.
	//
	// This function is intended for implementors of Sorter subclasses and
	// should not be called from other functions.
	Changed(change SorterChange)
	// Compare: compares two given items according to the sort order implemented
	// by the sorter.
	//
	// Sorters implement a partial order: * It is reflexive, ie a = a * It is
	// antisymmetric, ie if a < b and b < a, then a = b * It is transitive, ie
	// given any 3 items with a ≤ b and b ≤ c, then a ≤ c
	//
	// The sorter may signal it conforms to additional constraints via the
	// return value of gtk_sorter_get_order().
	Compare(item1 interface{}, item2 interface{}) Ordering
	// Order: gets the order that @self conforms to. See SorterOrder for details
	// of the possible return values.
	//
	// This function is intended to allow optimizations.
	Order() SorterOrder
}

type sorter struct {
	*externglib.Object
}

func wrapSorter(obj *externglib.Object) Sorter {
	return sorter{*externglib.Object{obj}}
}

func marshalSorter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func (s sorter) Changed(change SorterChange)

func (s sorter) Compare(item1 interface{}, item2 interface{}) Ordering

func (s sorter) Order() SorterOrder

// SpinButton: a SpinButton is an ideal way to allow the user to set the value
// of some attribute. Rather than having to directly type a number into a Entry,
// GtkSpinButton allows the user to click on one of two arrows to increment or
// decrement the displayed value. A value can still be typed in, with the bonus
// that it can be checked to ensure it is in a given range.
//
// The main properties of a GtkSpinButton are through an adjustment. See the
// Adjustment section for more details about an adjustment's properties.
//
// Note that GtkSpinButton will by default make its entry large enough to
// accommodate the lower and upper bounds of the adjustment. If this is not
// desired, the automatic sizing can be turned off by explicitly setting
// Editable::width-chars to a value != -1.
//
// Using a GtkSpinButton to get an integer
//
//    // Provides a function to retrieve an integer value from a GtkSpinButton
//    // and creates a spin button to model percentage values.
//
//    int
//    grab_int_value (GtkSpinButton *button,
//                    gpointer       user_data)
//    {
//      return gtk_spin_button_get_value_as_int (button);
//    }
//
//    void
//    create_integer_spin_button (void)
//    {
//
//      GtkWidget *window, *button;
//      GtkAdjustment *adjustment;
//
//      adjustment = gtk_adjustment_new (50.0, 0.0, 100.0, 1.0, 5.0, 0.0);
//
//      window = gtk_window_new ();
//
//      // creates the spinbutton, with no decimal places
//      button = gtk_spin_button_new (adjustment, 1.0, 0);
//      gtk_window_set_child (GTK_WINDOW (window), button);
//
//      gtk_widget_show (window);
//    }
//
//
// Using a GtkSpinButton to get a floating point value
//
//    // Provides a function to retrieve a floating point value from a
//    // GtkSpinButton, and creates a high precision spin button.
//
//    float
//    grab_float_value (GtkSpinButton *button,
//                      gpointer       user_data)
//    {
//      return gtk_spin_button_get_value (button);
//    }
//
//    void
//    create_floating_spin_button (void)
//    {
//      GtkWidget *window, *button;
//      GtkAdjustment *adjustment;
//
//      adjustment = gtk_adjustment_new (2.500, 0.0, 5.0, 0.001, 0.1, 0.0);
//
//      window = gtk_window_new ();
//
//      // creates the spinbutton, with three decimal places
//      button = gtk_spin_button_new (adjustment, 0.001, 3);
//      gtk_window_set_child (GTK_WINDOW (window), button);
//
//      gtk_widget_show (window);
//    }
//
//
// CSS nodes
//
//    spinbutton.horizontal
//    ├── text
//    │    ├── undershoot.left
//    │    ╰── undershoot.right
//    ├── button.down
//    ╰── button.up
//
//    spinbutton.vertical
//    ├── button.up
//    ├── text
//    │    ├── undershoot.left
//    │    ╰── undershoot.right
//    ╰── button.down
//
// GtkSpinButtons main CSS node has the name spinbutton. It creates subnodes for
// the entry and the two buttons, with these names. The button nodes have the
// style classes .up and .down. The GtkText subnodes (if present) are put below
// the text node. The orientation of the spin button is reflected in the
// .vertical or .horizontal style class on the main node.
//
//
// Accessiblity
//
// GtkSpinButton uses the K_ACCESSIBLE_ROLE_SPIN_BUTTON role.
type SpinButton interface {
	Widget

	// Configure: changes the properties of an existing spin button. The
	// adjustment, climb rate, and number of decimal places are updated
	// accordingly.
	Configure(adjustment Adjustment, climbRate float64, digits uint)
	// Adjustment: get the adjustment associated with a SpinButton
	Adjustment() Adjustment
	// ClimbRate: returns the acceleration rate for repeated changes.
	ClimbRate() float64
	// Digits: fetches the precision of @spin_button. See
	// gtk_spin_button_set_digits().
	Digits() uint
	// Increments: gets the current step and page the increments used by
	// @spin_button. See gtk_spin_button_set_increments().
	Increments() (step float64, page float64)
	// Numeric: returns whether non-numeric text can be typed into the spin
	// button. See gtk_spin_button_set_numeric().
	Numeric() bool
	// Range: gets the range allowed for @spin_button. See
	// gtk_spin_button_set_range().
	Range() (min float64, max float64)
	// SnapToTicks: returns whether the values are corrected to the nearest
	// step. See gtk_spin_button_set_snap_to_ticks().
	SnapToTicks() bool
	// UpdatePolicy: gets the update behavior of a spin button. See
	// gtk_spin_button_set_update_policy().
	UpdatePolicy() SpinButtonUpdatePolicy
	// Value: get the value in the @spin_button.
	Value() float64
	// ValueAsInt: get the value @spin_button represented as an integer.
	ValueAsInt() int
	// Wrap: returns whether the spin button’s value wraps around to the
	// opposite limit when the upper or lower limit of the range is exceeded.
	// See gtk_spin_button_set_wrap().
	Wrap() bool
	// SetAdjustment: replaces the Adjustment associated with @spin_button.
	SetAdjustment(adjustment Adjustment)
	// SetClimbRate: sets the acceleration rate for repeated changes when you
	// hold down a button or key.
	SetClimbRate(climbRate float64)
	// SetDigits: set the precision to be displayed by @spin_button. Up to 20
	// digit precision is allowed.
	SetDigits(digits uint)
	// SetIncrements: sets the step and page increments for spin_button. This
	// affects how quickly the value changes when the spin button’s arrows are
	// activated.
	SetIncrements(step float64, page float64)
	// SetNumeric: sets the flag that determines if non-numeric text can be
	// typed into the spin button.
	SetNumeric(numeric bool)
	// SetRange: sets the minimum and maximum allowable values for @spin_button.
	//
	// If the current value is outside this range, it will be adjusted to fit
	// within the range, otherwise it will remain unchanged.
	SetRange(min float64, max float64)
	// SetSnapToTicks: sets the policy as to whether values are corrected to the
	// nearest step increment when a spin button is activated after providing an
	// invalid value.
	SetSnapToTicks(snapToTicks bool)
	// SetUpdatePolicy: sets the update behavior of a spin button. This
	// determines whether the spin button is always updated or only when a valid
	// value is set.
	SetUpdatePolicy(policy SpinButtonUpdatePolicy)
	// SetValue: sets the value of @spin_button.
	SetValue(value float64)
	// SetWrap: sets the flag that determines if a spin button value wraps
	// around to the opposite limit when the upper or lower limit of the range
	// is exceeded.
	SetWrap(wrap bool)
	// Spin: increment or decrement a spin button’s value in a specified
	// direction by a specified amount.
	Spin(direction SpinType, increment float64)
	// Update: manually force an update of the spin button.
	Update()
}

type spinButton struct {
	widget
}

func wrapSpinButton(obj *externglib.Object) SpinButton {
	return spinButton{widget{externglib.InitiallyUnowned{obj}}}
}

func marshalSpinButton(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewSpinButton(adjustment Adjustment, climbRate float64, digits uint) SpinButton

func NewSpinButton(min float64, max float64, step float64) SpinButton

func (s spinButton) Configure(adjustment Adjustment, climbRate float64, digits uint)

func (s spinButton) Adjustment() Adjustment

func (s spinButton) ClimbRate() float64

func (s spinButton) Digits() uint

func (s spinButton) Increments() (step float64, page float64)

func (s spinButton) Numeric() bool

func (s spinButton) Range() (min float64, max float64)

func (s spinButton) SnapToTicks() bool

func (s spinButton) UpdatePolicy() SpinButtonUpdatePolicy

func (s spinButton) Value() float64

func (s spinButton) ValueAsInt() int

func (s spinButton) Wrap() bool

func (s spinButton) SetAdjustment(adjustment Adjustment)

func (s spinButton) SetClimbRate(climbRate float64)

func (s spinButton) SetDigits(digits uint)

func (s spinButton) SetIncrements(step float64, page float64)

func (s spinButton) SetNumeric(numeric bool)

func (s spinButton) SetRange(min float64, max float64)

func (s spinButton) SetSnapToTicks(snapToTicks bool)

func (s spinButton) SetUpdatePolicy(policy SpinButtonUpdatePolicy)

func (s spinButton) SetValue(value float64)

func (s spinButton) SetWrap(wrap bool)

func (s spinButton) Spin(direction SpinType, increment float64)

func (s spinButton) Update()

// Spinner: a GtkSpinner widget displays an icon-size spinning animation. It is
// often used as an alternative to a ProgressBar for displaying indefinite
// activity, instead of actual progress.
//
// To start the animation, use gtk_spinner_start(), to stop it use
// gtk_spinner_stop().
//
//
// CSS nodes
//
// GtkSpinner has a single CSS node with the name spinner. When the animation is
// active, the :checked pseudoclass is added to this node.
type Spinner interface {
	Widget

	// Spinning: returns whether the spinner is spinning.
	Spinning() bool
	// SetSpinning: sets the activity of the spinner.
	SetSpinning(spinning bool)
	// Start: starts the animation of the spinner.
	Start()
	// Stop: stops the animation of the spinner.
	Stop()
}

type spinner struct {
	widget
}

func wrapSpinner(obj *externglib.Object) Spinner {
	return spinner{widget{externglib.InitiallyUnowned{obj}}}
}

func marshalSpinner(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewSpinner() Spinner

func (s spinner) Spinning() bool

func (s spinner) SetSpinning(spinning bool)

func (s spinner) Start()

func (s spinner) Stop()

// Stack: the GtkStack widget is a container which only shows one of its
// children at a time. In contrast to GtkNotebook, GtkStack does not provide a
// means for users to change the visible child. Instead, the StackSwitcher
// widget can be used with GtkStack to provide this functionality.
//
// Transitions between pages can be animated as slides or fades. This can be
// controlled with gtk_stack_set_transition_type(). These animations respect the
// Settings:gtk-enable-animations setting.
//
// GtkStack maintains a StackPage object for each added child, which holds
// additional per-child properties. You obtain the StackPage for a child with
// gtk_stack_get_page().
//
// GtkStack as GtkBuildable
//
//
//      <object class="GtkStack" id="stack">
//        <child>
//          <object class="GtkStackPage">
//            <property name="name">page1</property>
//            <property name="title">In the beginning…</property>
//            <property name="child">
//              <object class="GtkLabel">
//                <property name="label">It was dark</property>
//              </object>
//            </property>
//          </object>
//        </child>
//
//
// CSS nodes
//
// GtkStack has a single CSS node named stack.
//
//
// Accessibility
//
// GtkStack uses the K_ACCESSIBLE_ROLE_TAB_PANEL for the stack pages, which are
// the accessible parent objects of the child widgets.
type Stack interface {
	Widget

	// AddChild: adds a child to @stack.
	AddChild(child Widget) StackPage
	// AddNamed: adds a child to @stack. The child is identified by the @name.
	AddNamed(child Widget, name string) StackPage
	// AddTitled: adds a child to @stack. The child is identified by the @name.
	// The @title will be used by StackSwitcher to represent @child in a tab
	// bar, so it should be short.
	AddTitled(child Widget, name string, title string) StackPage
	// ChildByName: finds the child of the Stack with the name given as the
	// argument. Returns nil if there is no child with this name.
	ChildByName(name string) Widget
	// Hhomogeneous: gets whether @stack is horizontally homogeneous. See
	// gtk_stack_set_hhomogeneous().
	Hhomogeneous() bool
	// InterpolateSize: returns whether the Stack is set up to interpolate
	// between the sizes of children on page switch.
	InterpolateSize() bool
	// Page: returns the StackPage object for @child.
	Page(child Widget) StackPage
	// Pages: returns a Model that contains the pages of the stack, and can be
	// used to keep an up-to-date view. The model also implements SelectionModel
	// and can be used to track and modify the visible page.
	Pages() SelectionModel
	// TransitionDuration: returns the amount of time (in milliseconds) that
	// transitions between pages in @stack will take.
	TransitionDuration() uint
	// TransitionRunning: returns whether the @stack is currently in a
	// transition from one page to another.
	TransitionRunning() bool
	// TransitionType: gets the type of animation that will be used for
	// transitions between pages in @stack.
	TransitionType() StackTransitionType
	// Vhomogeneous: gets whether @stack is vertically homogeneous. See
	// gtk_stack_set_vhomogeneous().
	Vhomogeneous() bool
	// VisibleChild: gets the currently visible child of @stack, or nil if there
	// are no visible children.
	VisibleChild() Widget
	// VisibleChildName: returns the name of the currently visible child of
	// @stack, or nil if there is no visible child.
	VisibleChildName() string
	// Remove: removes a child widget from @stack.
	Remove(child Widget)
	// SetHhomogeneous: sets the Stack to be horizontally homogeneous or not. If
	// it is homogeneous, the Stack will request the same width for all its
	// children. If it isn't, the stack may change width when a different child
	// becomes visible.
	SetHhomogeneous(hhomogeneous bool)
	// SetInterpolateSize: sets whether or not @stack will interpolate its size
	// when changing the visible child. If the Stack:interpolate-size property
	// is set to true, @stack will interpolate its size between the current one
	// and the one it'll take after changing the visible child, according to the
	// set transition duration.
	SetInterpolateSize(interpolateSize bool)
	// SetTransitionDuration: sets the duration that transitions between pages
	// in @stack will take.
	SetTransitionDuration(duration uint)
	// SetTransitionType: sets the type of animation that will be used for
	// transitions between pages in @stack. Available types include various
	// kinds of fades and slides.
	//
	// The transition type can be changed without problems at runtime, so it is
	// possible to change the animation based on the page that is about to
	// become current.
	SetTransitionType(transition StackTransitionType)
	// SetVhomogeneous: sets the Stack to be vertically homogeneous or not. If
	// it is homogeneous, the Stack will request the same height for all its
	// children. If it isn't, the stack may change height when a different child
	// becomes visible.
	SetVhomogeneous(vhomogeneous bool)
	// SetVisibleChild: makes @child the visible child of @stack.
	//
	// If @child is different from the currently visible child, the transition
	// between the two will be animated with the current transition type of
	// @stack.
	//
	// Note that the @child widget has to be visible itself (see
	// gtk_widget_show()) in order to become the visible child of @stack.
	SetVisibleChild(child Widget)
	// SetVisibleChildFull: makes the child with the given name visible.
	//
	// Note that the child widget has to be visible itself (see
	// gtk_widget_show()) in order to become the visible child of @stack.
	SetVisibleChildFull(name string, transition StackTransitionType)
	// SetVisibleChildName: makes the child with the given name visible.
	//
	// If @child is different from the currently visible child, the transition
	// between the two will be animated with the current transition type of
	// @stack.
	//
	// Note that the child widget has to be visible itself (see
	// gtk_widget_show()) in order to become the visible child of @stack.
	SetVisibleChildName(name string)
}

type stack struct {
	widget
}

func wrapStack(obj *externglib.Object) Stack {
	return stack{widget{externglib.InitiallyUnowned{obj}}}
}

func marshalStack(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewStack() Stack

func (s stack) AddChild(child Widget) StackPage

func (s stack) AddNamed(child Widget, name string) StackPage

func (s stack) AddTitled(child Widget, name string, title string) StackPage

func (s stack) ChildByName(name string) Widget

func (s stack) Hhomogeneous() bool

func (s stack) InterpolateSize() bool

func (s stack) Page(child Widget) StackPage

func (s stack) Pages() SelectionModel

func (s stack) TransitionDuration() uint

func (s stack) TransitionRunning() bool

func (s stack) TransitionType() StackTransitionType

func (s stack) Vhomogeneous() bool

func (s stack) VisibleChild() Widget

func (s stack) VisibleChildName() string

func (s stack) Remove(child Widget)

func (s stack) SetHhomogeneous(hhomogeneous bool)

func (s stack) SetInterpolateSize(interpolateSize bool)

func (s stack) SetTransitionDuration(duration uint)

func (s stack) SetTransitionType(transition StackTransitionType)

func (s stack) SetVhomogeneous(vhomogeneous bool)

func (s stack) SetVisibleChild(child Widget)

func (s stack) SetVisibleChildFull(name string, transition StackTransitionType)

func (s stack) SetVisibleChildName(name string)

type StackPage interface {
	gextras.Objector

	// Child: returns the stack child to which @self belongs.
	Child() Widget
	// IconName: returns the current value of the StackPage:icon-name property.
	IconName() string
	// Name: returns the current value of the StackPage:name property.
	Name() string
	// NeedsAttention: returns the current value of the
	// StackPage:needs-attention property.
	NeedsAttention() bool
	// Title: returns the current value of the StackPage:title property.
	Title() string
	// UseUnderline: returns the current value of the StackPage:use-underline
	// property.
	UseUnderline() bool
	// Visible: returns whether @page is visible in its Stack. This is
	// independent from the Widget:visible value of its Widget.
	Visible() bool
	// SetIconName: sets the new value of the StackPage:icon-name property. See
	// also gtk_stack_page_get_icon_name()
	SetIconName(setting string)
	// SetName: sets the new value of the StackPage:name property. See also
	// gtk_stack_page_get_name()
	SetName(setting string)
	// SetNeedsAttention: sets the new value of the StackPage:needs-attention
	// property. See also gtk_stack_page_get_needs_attention()
	SetNeedsAttention(setting bool)
	// SetTitle: sets the new value of the StackPage:title property. See also
	// gtk_stack_page_get_title()
	SetTitle(setting string)
	// SetUseUnderline: sets the new value of the StackPage:use-underline
	// property. See also gtk_stack_page_get_use_underline()
	SetUseUnderline(setting bool)
	// SetVisible: sets the new value of the StackPage:visible property to
	// @visible.
	SetVisible(visible bool)
}

type stackPage struct {
	*externglib.Object
}

func wrapStackPage(obj *externglib.Object) StackPage {
	return stackPage{*externglib.Object{obj}}
}

func marshalStackPage(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func (s stackPage) Child() Widget

func (s stackPage) IconName() string

func (s stackPage) Name() string

func (s stackPage) NeedsAttention() bool

func (s stackPage) Title() string

func (s stackPage) UseUnderline() bool

func (s stackPage) Visible() bool

func (s stackPage) SetIconName(setting string)

func (s stackPage) SetName(setting string)

func (s stackPage) SetNeedsAttention(setting bool)

func (s stackPage) SetTitle(setting string)

func (s stackPage) SetUseUnderline(setting bool)

func (s stackPage) SetVisible(visible bool)

// StackSidebar: a GtkStackSidebar enables you to quickly and easily provide a
// consistent "sidebar" object for your user interface.
//
// In order to use a GtkStackSidebar, you simply use a GtkStack to organize your
// UI flow, and add the sidebar to your sidebar area. You can use
// gtk_stack_sidebar_set_stack() to connect the StackSidebar to the Stack.
//
//
// CSS nodes
//
// GtkStackSidebar has a single CSS node with name stacksidebar and style class
// .sidebar.
//
// When circumstances require it, GtkStackSidebar adds the .needs-attention
// style class to the widgets representing the stack pages.
type StackSidebar interface {
	Widget

	// Stack: retrieves the stack. See gtk_stack_sidebar_set_stack().
	Stack() Stack
	// SetStack: set the Stack associated with this StackSidebar.
	//
	// The sidebar widget will automatically update according to the order
	// (packing) and items within the given Stack.
	SetStack(stack Stack)
}

type stackSidebar struct {
	widget
}

func wrapStackSidebar(obj *externglib.Object) StackSidebar {
	return stackSidebar{widget{externglib.InitiallyUnowned{obj}}}
}

func marshalStackSidebar(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewStackSidebar() StackSidebar

func (s stackSidebar) Stack() Stack

func (s stackSidebar) SetStack(stack Stack)

// StackSwitcher: the GtkStackSwitcher widget acts as a controller for a Stack;
// it shows a row of buttons to switch between the various pages of the
// associated stack widget.
//
// All the content for the buttons comes from the child properties of the Stack;
// the button visibility in a StackSwitcher widget is controlled by the
// visibility of the child in the Stack.
//
// It is possible to associate multiple StackSwitcher widgets with the same
// Stack widget.
//
//
// CSS nodes
//
// GtkStackSwitcher has a single CSS node named stackswitcher and style class
// .stack-switcher.
//
// When circumstances require it, GtkStackSwitcher adds the .needs-attention
// style class to the widgets representing the stack pages.
//
//
// Accessibility
//
// GtkStackSwitcher uses the K_ACCESSIBLE_ROLE_TAB_LIST role and uses the
// K_ACCESSIBLE_ROLE_TAB for its buttons.
type StackSwitcher interface {
	Widget

	// Stack: retrieves the stack. See gtk_stack_switcher_set_stack().
	Stack() Stack
	// SetStack: sets the stack to control.
	SetStack(stack Stack)
}

type stackSwitcher struct {
	widget
}

func wrapStackSwitcher(obj *externglib.Object) StackSwitcher {
	return stackSwitcher{widget{externglib.InitiallyUnowned{obj}}}
}

func marshalStackSwitcher(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewStackSwitcher() StackSwitcher

func (s stackSwitcher) Stack() Stack

func (s stackSwitcher) SetStack(stack Stack)

// Statusbar: a Statusbar is usually placed along the bottom of an application's
// main Window. It may provide a regular commentary of the application's status
// (as is usually the case in a web browser, for example), or may be used to
// simply output a message when the status changes, (when an upload is complete
// in an FTP client, for example).
//
// Status bars in GTK+ maintain a stack of messages. The message at the top of
// the each bar’s stack is the one that will currently be displayed.
//
// Any messages added to a statusbar’s stack must specify a context id that is
// used to uniquely identify the source of a message. This context id can be
// generated by gtk_statusbar_get_context_id(), given a message and the
// statusbar that it will be added to. Note that messages are stored in a stack,
// and when choosing which message to display, the stack structure is adhered
// to, regardless of the context identifier of a message.
//
// One could say that a statusbar maintains one stack of messages for display
// purposes, but allows multiple message producers to maintain sub-stacks of the
// messages they produced (via context ids).
//
// Status bars are created using gtk_statusbar_new().
//
// Messages are added to the bar’s stack with gtk_statusbar_push().
//
// The message at the top of the stack can be removed using gtk_statusbar_pop().
// A message can be removed from anywhere in the stack if its message id was
// recorded at the time it was added. This is done using gtk_statusbar_remove().
//
//
// CSS node
//
// GtkStatusbar has a single CSS node with name statusbar.
type Statusbar interface {
	Widget

	// ContextID: returns a new context identifier, given a description of the
	// actual context. Note that the description is not shown in the UI.
	ContextID(contextDescription string) uint
	// Pop: removes the first message in the Statusbar’s stack with the given
	// context id.
	//
	// Note that this may not change the displayed message, if the message at
	// the top of the stack has a different context id.
	Pop(contextID uint)
	// Push: pushes a new message onto a statusbar’s stack.
	Push(contextID uint, text string) uint
	// Remove: forces the removal of a message from a statusbar’s stack. The
	// exact @context_id and @message_id must be specified.
	Remove(contextID uint, messageID uint)
	// RemoveAll: forces the removal of all messages from a statusbar's stack
	// with the exact @context_id.
	RemoveAll(contextID uint)
}

type statusbar struct {
	widget
}

func wrapStatusbar(obj *externglib.Object) Statusbar {
	return statusbar{widget{externglib.InitiallyUnowned{obj}}}
}

func marshalStatusbar(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewStatusbar() Statusbar

func (s statusbar) ContextID(contextDescription string) uint

func (s statusbar) Pop(contextID uint)

func (s statusbar) Push(contextID uint, text string) uint

func (s statusbar) Remove(contextID uint, messageID uint)

func (s statusbar) RemoveAll(contextID uint)

// StringFilter: gtkStringFilter determines whether to include items by looking
// at strings and comparing them to a fixed search term. The strings are
// obtained from the items by evaluating a Expression.
//
// GtkStringFilter has several different modes of comparison - it can match the
// whole string, just a prefix, or any substring.
type StringFilter interface {
	Filter

	// Expression: gets the expression that the string filter uses to obtain
	// strings from items.
	Expression() Expression
	// IgnoreCase: returns whether the filter ignores case differences.
	IgnoreCase() bool
	// MatchMode: returns the match mode that the filter is using.
	MatchMode() StringFilterMatchMode
	// Search: gets the search string set via gtk_string_filter_set_search().
	Search() string
	// SetExpression: sets the expression that the string filter uses to obtain
	// strings from items. The expression must have a value type of TYPE_STRING.
	SetExpression(expression Expression)
	// SetIgnoreCase: sets whether the filter ignores case differences.
	SetIgnoreCase(ignoreCase bool)
	// SetMatchMode: sets the match mode for the filter.
	SetMatchMode(mode StringFilterMatchMode)
	// SetSearch: sets the string to search for.
	SetSearch(search string)
}

type stringFilter struct {
	filter
}

func wrapStringFilter(obj *externglib.Object) StringFilter {
	return stringFilter{filter{*externglib.Object{obj}}}
}

func marshalStringFilter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewStringFilter(expression Expression) StringFilter

func (s stringFilter) Expression() Expression

func (s stringFilter) IgnoreCase() bool

func (s stringFilter) MatchMode() StringFilterMatchMode

func (s stringFilter) Search() string

func (s stringFilter) SetExpression(expression Expression)

func (s stringFilter) SetIgnoreCase(ignoreCase bool)

func (s stringFilter) SetMatchMode(mode StringFilterMatchMode)

func (s stringFilter) SetSearch(search string)

// StringList is a list model that wraps an array of strings.
//
// The objects in the model have a "string" property.
//
// GtkStringList is well-suited for any place where you would typically use a
// `char*[]`, but need a list model.
//
//
// GtkStringList as GtkBuildable
//
// The GtkStringList implementation of the GtkBuildable interface supports
// adding items directly using the <items> element and specifying <item>
// elements for each item. Each <item> element supports the regular translation
// attributes “translatable”, “context” and “comments”.
//
//
//    <object class="GtkStringList">
//      <items>
//        <item translatable="yes">Factory</item>
//        <item translatable="yes">Home</item>
//        <item translatable="yes">Subway</item>
//      </items>
//    </object>
type StringList interface {
	gextras.Objector

	// Append: appends @string to @self.
	//
	// The @string will be copied. See gtk_string_list_take() for a way to avoid
	// that.
	Append(string string)
	// String: gets the string that is at @position in @self. If @self does not
	// contain @position items, nil is returned.
	//
	// This function returns the const char *. To get the object wrapping it,
	// use g_list_model_get_item().
	String(position uint) string
	// Remove: removes the string at @position from @self. @position must be
	// smaller than the current length of the list.
	Remove(position uint)
	// Splice: changes @self by removing @n_removals strings and adding
	// @additions to it.
	//
	// This function is more efficient than gtk_string_list_append() and
	// gtk_string_list_remove(), because it only emits Model::items-changed once
	// for the change.
	//
	// This function copies the strings in @additions.
	//
	// The parameters @position and @n_removals must be correct (ie: @position +
	// @n_removals must be less than or equal to the length of the list at the
	// time this function is called).
	Splice(position uint, nRemovals uint, additions []string)
	// Take: adds @string to self at the end, and takes ownership of it.
	//
	// This variant of gtk_string_list_append() is convenient for formatting
	// strings:
	//
	//
	//    gtk_string_list_take (self, g_strdup_print ("d dollars", lots));
	Take(string string)
}

type stringList struct {
	*externglib.Object
}

func wrapStringList(obj *externglib.Object) StringList {
	return stringList{*externglib.Object{obj}}
}

func marshalStringList(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewStringList(strings []string) StringList

func (s stringList) Append(string string)

func (s stringList) String(position uint) string

func (s stringList) Remove(position uint)

func (s stringList) Splice(position uint, nRemovals uint, additions []string)

func (s stringList) Take(string string)

type StringObject interface {
	gextras.Objector

	// String: returns the string contained in a StringObject.
	String() string
}

type stringObject struct {
	*externglib.Object
}

func wrapStringObject(obj *externglib.Object) StringObject {
	return stringObject{*externglib.Object{obj}}
}

func marshalStringObject(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewStringObject(string string) StringObject

func (s stringObject) String() string

// StringSorter: gtkStringSorter is a Sorter that compares strings. It does the
// comparison in a linguistically correct way using the current locale by
// normalizing Unicode strings and possibly case-folding them before performing
// the comparison.
//
// To obtain the strings to compare, this sorter evaluates a Expression.
type StringSorter interface {
	Sorter

	// Expression: gets the expression that is evaluated to obtain strings from
	// items.
	Expression() Expression
	// IgnoreCase: gets whether the sorter ignores case differences.
	IgnoreCase() bool
	// SetExpression: sets the expression that is evaluated to obtain strings
	// from items.
	//
	// The expression must have the type G_TYPE_STRING.
	SetExpression(expression Expression)
	// SetIgnoreCase: sets whether the sorter will ignore case differences.
	SetIgnoreCase(ignoreCase bool)
}

type stringSorter struct {
	sorter
}

func wrapStringSorter(obj *externglib.Object) StringSorter {
	return stringSorter{sorter{*externglib.Object{obj}}}
}

func marshalStringSorter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewStringSorter(expression Expression) StringSorter

func (s stringSorter) Expression() Expression

func (s stringSorter) IgnoreCase() bool

func (s stringSorter) SetExpression(expression Expression)

func (s stringSorter) SetIgnoreCase(ignoreCase bool)

// StyleContext is an object that stores styling information affecting a widget.
//
// In order to construct the final style information, StyleContext queries
// information from all attached StyleProviders. Style providers can be either
// attached explicitly to the context through gtk_style_context_add_provider(),
// or to the display through gtk_style_context_add_provider_for_display(). The
// resulting style is a combination of all providers’ information in priority
// order.
//
// For GTK widgets, any StyleContext returned by gtk_widget_get_style_context()
// will already have a Display and RTL/LTR information set. The style context
// will also be updated automatically if any of these settings change on the
// widget.
//
// Style Classes {#gtkstylecontext-classes}
//
// Widgets can add style classes to their context, which can be used to
// associate different styles by class. The documentation for individual widgets
// lists which style classes it uses itself, and which style classes may be
// added by applications to affect their appearance.
//
// GTK defines macros for a number of style classes.
//
//
// Custom styling in UI libraries and applications
//
// If you are developing a library with custom Widgets that render differently
// than standard components, you may need to add a StyleProvider yourself with
// the GTK_STYLE_PROVIDER_PRIORITY_FALLBACK priority, either a CssProvider or a
// custom object implementing the StyleProvider interface. This way themes may
// still attempt to style your UI elements in a different way if needed so.
//
// If you are using custom styling on an applications, you probably want then to
// make your style information prevail to the theme’s, so you must use a
// StyleProvider with the GTK_STYLE_PROVIDER_PRIORITY_APPLICATION priority, keep
// in mind that the user settings in `XDG_CONFIG_HOME/gtk-4.0/gtk.css` will
// still take precedence over your changes, as it uses the
// GTK_STYLE_PROVIDER_PRIORITY_USER priority.
type StyleContext interface {
	gextras.Objector

	// AddClass: adds a style class to @context, so later uses of the style
	// context will make use of this new class for styling.
	//
	// In the CSS file format, a Entry defining a “search” class, would be
	// matched by:
	//
	//     <!-- language="CSS" -->
	//    entry.search { ... }
	//
	//     <!-- language="CSS" -->
	//    .search { ... }
	AddClass(className string)
	// AddProvider: adds a style provider to @context, to be used in style
	// construction. Note that a style provider added by this function only
	// affects the style of the widget to which @context belongs. If you want to
	// affect the style of all widgets, use
	// gtk_style_context_add_provider_for_display().
	//
	// Note: If both priorities are the same, a StyleProvider added through this
	// function takes precedence over another added through
	// gtk_style_context_add_provider_for_display().
	AddProvider(provider StyleProvider, priority uint)
	// Border: gets the border for a given state as a Border.
	Border() Border
	// Color: gets the foreground color for a given state.
	Color() gdk.RGBA
	// Display: returns the Display to which @context is attached.
	Display() gdk.Display
	// Margin: gets the margin for a given state as a Border.
	Margin() Border
	// Padding: gets the padding for a given state as a Border.
	Padding() Border
	// Scale: returns the scale used for assets.
	Scale() int
	// State: returns the state used for style matching.
	//
	// This method should only be used to retrieve the StateFlags to pass to
	// StyleContext methods, like gtk_style_context_get_padding(). If you need
	// to retrieve the current state of a Widget, use
	// gtk_widget_get_state_flags().
	State() StateFlags
	// HasClass: returns true if @context currently has defined the given class
	// name.
	HasClass(className string) bool
	// LookupColor: looks up and resolves a color name in the @context color
	// map.
	LookupColor(colorName string) (color gdk.RGBA, ok bool)
	// RemoveClass: removes @class_name from @context.
	RemoveClass(className string)
	// RemoveProvider: removes @provider from the style providers list in
	// @context.
	RemoveProvider(provider StyleProvider)
	// Restore: restores @context state to a previous stage. See
	// gtk_style_context_save().
	Restore()
	// Save: saves the @context state, so temporary modifications done through
	// gtk_style_context_add_class(), gtk_style_context_remove_class(),
	// gtk_style_context_set_state(), etc. can quickly be reverted in one go
	// through gtk_style_context_restore().
	//
	// The matching call to gtk_style_context_restore() must be done before GTK
	// returns to the main loop.
	Save()
	// SetDisplay: attaches @context to the given display.
	//
	// The display is used to add style information from “global” style
	// providers, such as the display's Settings instance.
	//
	// If you are using a StyleContext returned from
	// gtk_widget_get_style_context(), you do not need to call this yourself.
	SetDisplay(display gdk.Display)
	// SetScale: sets the scale to use when getting image assets for the style.
	SetScale(scale int)
	// SetState: sets the state to be used for style matching.
	SetState(flags StateFlags)
	// ToString: converts the style context into a string representation.
	//
	// The string representation always includes information about the name,
	// state, id, visibility and style classes of the CSS node that is backing
	// @context. Depending on the flags, more information may be included.
	//
	// This function is intended for testing and debugging of the CSS
	// implementation in GTK. There are no guarantees about the format of the
	// returned string, it may change.
	ToString(flags StyleContextPrintFlags) string
}

type styleContext struct {
	*externglib.Object
}

func wrapStyleContext(obj *externglib.Object) StyleContext {
	return styleContext{*externglib.Object{obj}}
}

func marshalStyleContext(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func (s styleContext) AddClass(className string)

func (s styleContext) AddProvider(provider StyleProvider, priority uint)

func (s styleContext) Border() Border

func (s styleContext) Color() gdk.RGBA

func (s styleContext) Display() gdk.Display

func (s styleContext) Margin() Border

func (s styleContext) Padding() Border

func (s styleContext) Scale() int

func (s styleContext) State() StateFlags

func (s styleContext) HasClass(className string) bool

func (s styleContext) LookupColor(colorName string) (color gdk.RGBA, ok bool)

func (s styleContext) RemoveClass(className string)

func (s styleContext) RemoveProvider(provider StyleProvider)

func (s styleContext) Restore()

func (s styleContext) Save()

func (s styleContext) SetDisplay(display gdk.Display)

func (s styleContext) SetScale(scale int)

func (s styleContext) SetState(flags StateFlags)

func (s styleContext) ToString(flags StyleContextPrintFlags) string

// Switch is a widget that has two states: on or off. The user can control which
// state should be active by clicking the empty area, or by dragging the handle.
//
// GtkSwitch can also handle situations where the underlying state changes with
// a delay. See Switch::state-set for details.
//
// CSS nodes
//
//    switch
//    ├── label
//    ├── label
//    ╰── slider
//
// GtkSwitch has four css nodes, the main node with the name switch and subnodes
// for the slider and the on and off labels. Neither of them is using any style
// classes.
//
//
// Accessibility
//
// GtkSwitch uses the K_ACCESSIBLE_ROLE_SWITCH role.
type Switch interface {
	Widget

	// Active: gets whether the Switch is in its “on” or “off” state.
	Active() bool
	// State: gets the underlying state of the Switch.
	State() bool
	// SetActive: changes the state of @self to the desired one.
	SetActive(isActive bool)
	// SetState: sets the underlying state of the Switch.
	//
	// Normally, this is the same as Switch:active, unless the switch is set up
	// for delayed state changes. This function is typically called from a
	// Switch::state-set signal handler.
	//
	// See Switch::state-set for details.
	SetState(state bool)
}

type _switch struct {
	widget
}

func wrapSwitch(obj *externglib.Object) Switch {
	return _switch{widget{externglib.InitiallyUnowned{obj}}}
}

func marshalSwitch(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewSwitch() Switch

func (_ _switch) Active() bool

func (_ _switch) State() bool

func (_ _switch) SetActive(isActive bool)

func (_ _switch) SetState(state bool)

// Text: the Text widget is a single line text entry widget.
//
// A fairly large set of key bindings are supported by default. If the entered
// text is longer than the allocation of the widget, the widget will scroll so
// that the cursor position is visible.
//
// When using an entry for passwords and other sensitive information, it can be
// put into “password mode” using gtk_text_set_visibility(). In this mode,
// entered text is displayed using a “invisible” character. By default, GTK
// picks the best invisible character that is available in the current font, but
// it can be changed with gtk_text_set_invisible_char().
//
// If you are looking to add icons or progress display in an entry, look at
// Entry. There other alternatives for more specialized use cases, such as
// SearchEntry.
//
// If you need multi-line editable text, look at TextView.
//
// CSS nodes
//
//    text[.read-only]
//    ├── placeholder
//    ├── undershoot.left
//    ├── undershoot.right
//    ├── [selection]
//    ├── [block-cursor]
//    ╰── [window.popup]
//
// GtkText has a main node with the name text. Depending on the properties of
// the widget, the .read-only style class may appear.
//
// When the entry has a selection, it adds a subnode with the name selection.
//
// When the entry is in overwrite mode, it adds a subnode with the name
// block-cursor that determines how the block cursor is drawn.
//
// The CSS node for a context menu is added as a subnode below text as well.
//
// The undershoot nodes are used to draw the underflow indication when content
// is scrolled out of view. These nodes get the .left and .right style classes
// added depending on where the indication is drawn.
//
// When touch is used and touch selection handles are shown, they are using CSS
// nodes with name cursor-handle. They get the .top or .bottom style class
// depending on where they are shown in relation to the selection. If there is
// just a single handle for the text cursor, it gets the style class
// .insertion-cursor.
//
//
// Accessibility
//
// GtkText uses the K_ACCESSIBLE_ROLE_NONE role, which causes it to be skipped
// for accessibility. This is because GtkText is expected to be used as a
// delegate for a Editable implementation that will be represented to
// accessibility.
type Text interface {
	Widget

	// ActivatesDefault: retrieves the value set by
	// gtk_text_set_activates_default().
	ActivatesDefault() bool
	// Attributes: gets the attribute list that was set on the self using
	// gtk_text_set_attributes(), if any.
	Attributes() *pango.AttrList
	// Buffer: get the EntryBuffer object which holds the text for this self.
	Buffer() EntryBuffer
	// EnableEmojiCompletion: returns whether Emoji completion is enabled for
	// this GtkText widget.
	EnableEmojiCompletion() bool
	// ExtraMenu: gets the menu model set with gtk_text_set_extra_menu().
	ExtraMenu() gio.MenuModel
	// InputHints: gets the value of the Text:input-hints property.
	InputHints() InputHints
	// InputPurpose: gets the value of the Text:input-purpose property.
	InputPurpose() InputPurpose
	// InvisibleChar: retrieves the character displayed in place of the real
	// characters for entries with visibility set to false. Note that GTK does
	// not compute this value unless it needs it, so the value returned by this
	// function is not very useful unless it has been explicitly set with
	// gtk_text_set_invisible_char()
	InvisibleChar() uint32
	// MaxLength: retrieves the maximum allowed length of the text in @self. See
	// gtk_text_set_max_length().
	//
	// This is equivalent to getting @self's EntryBuffer and calling
	// gtk_entry_buffer_get_max_length() on it.
	MaxLength() int
	// OverwriteMode: gets the value set by gtk_text_set_overwrite_mode().
	OverwriteMode() bool
	// PlaceholderText: retrieves the text that will be displayed when @self is
	// empty and unfocused
	PlaceholderText() string
	// PropagateTextWidth: returns whether the Text will grow and shrink with
	// the content.
	PropagateTextWidth() bool
	// Tabs: gets the tabstops that were set on the self using
	// gtk_text_set_tabs(), if any.
	Tabs() *pango.TabArray
	// TextLength: retrieves the current length of the text in @self.
	//
	// This is equivalent to getting @self's EntryBuffer and calling
	// gtk_entry_buffer_get_length() on it.
	TextLength() uint16
	// TruncateMultiline: returns whether the Text will truncate multi-line text
	// that is pasted into the widget
	TruncateMultiline() bool
	// Visibility: retrieves whether the text in @self is visible. See
	// gtk_text_set_visibility().
	Visibility() bool
	// GrabFocusWithoutSelecting: causes @self to have keyboard focus.
	//
	// It behaves like gtk_widget_grab_focus(), except that it doesn't select
	// the contents of @self. You only want to call this on some special entries
	// which the user usually doesn't want to replace all text in, such as
	// search-as-you-type entries.
	GrabFocusWithoutSelecting() bool
	// SetActivatesDefault: if @activates is true, pressing Enter in the @self
	// will activate the default widget for the window containing the self. This
	// usually means that the dialog box containing the self will be closed,
	// since the default widget is usually one of the dialog buttons.
	SetActivatesDefault(activates bool)
	// SetAttributes: sets a AttrList; the attributes in the list are applied to
	// the text.
	SetAttributes(attrs *pango.AttrList)
	// SetBuffer: set the EntryBuffer object which holds the text for this
	// widget.
	SetBuffer(buffer EntryBuffer)
	// SetEnableEmojiCompletion: sets whether Emoji completion is enabled. If it
	// is, typing ':', followed by a recognized keyword, will pop up a window
	// with suggested Emojis matching the keyword.
	SetEnableEmojiCompletion(enableEmojiCompletion bool)
	// SetExtraMenu: sets a menu model to add when constructing the context menu
	// for @self.
	SetExtraMenu(model gio.MenuModel)
	// SetInputHints: sets the Text:input-hints property, which allows input
	// methods to fine-tune their behaviour.
	SetInputHints(hints InputHints)
	// SetInputPurpose: sets the Text:input-purpose property which can be used
	// by on-screen keyboards and other input methods to adjust their behaviour.
	SetInputPurpose(purpose InputPurpose)
	// SetInvisibleChar: sets the character to use in place of the actual text
	// when gtk_text_set_visibility() has been called to set text visibility to
	// false. i.e. this is the character used in “password mode” to show the
	// user how many characters have been typed.
	//
	// By default, GTK picks the best invisible char available in the current
	// font. If you set the invisible char to 0, then the user will get no
	// feedback at all; there will be no text on the screen as they type.
	SetInvisibleChar(ch uint32)
	// SetMaxLength: sets the maximum allowed length of the contents of the
	// widget.
	//
	// If the current contents are longer than the given length, then they will
	// be truncated to fit.
	//
	//    This is equivalent to getting @self's EntryBuffer and
	//    calling gtk_entry_buffer_set_max_length() on it.
	//
	SetMaxLength(length int)
	// SetOverwriteMode: sets whether the text is overwritten when typing in the
	// Text.
	SetOverwriteMode(overwrite bool)
	// SetPlaceholderText: sets text to be displayed in @self when it is empty.
	//
	// This can be used to give a visual hint of the expected contents of the
	// self.
	SetPlaceholderText(text string)
	// SetPropagateTextWidth: sets whether the GtkText should grow and shrink
	// with the content.
	SetPropagateTextWidth(propagateTextWidth bool)
	// SetTabs: sets a TabArray; the tabstops in the array are applied to the
	// self text.
	SetTabs(tabs *pango.TabArray)
	// SetTruncateMultiline: sets whether the GtkText should truncate multi-line
	// text that is pasted into the widget.
	SetTruncateMultiline(truncateMultiline bool)
	// SetVisibility: sets whether the contents of the self are visible or not.
	// When visibility is set to false, characters are displayed as the
	// invisible char, and will also appear that way when the text in the self
	// widget is copied to the clipboard.
	//
	// By default, GTK picks the best invisible character available in the
	// current font, but it can be changed with gtk_text_set_invisible_char().
	//
	// Note that you probably want to set Text:input-purpose to
	// GTK_INPUT_PURPOSE_PASSWORD or GTK_INPUT_PURPOSE_PIN to inform input
	// methods about the purpose of this self, in addition to setting visibility
	// to false.
	SetVisibility(visible bool)
	// UnsetInvisibleChar: unsets the invisible char previously set with
	// gtk_text_set_invisible_char(). So that the default invisible char is used
	// again.
	UnsetInvisibleChar()
}

type text struct {
	widget
}

func wrapText(obj *externglib.Object) Text {
	return text{widget{externglib.InitiallyUnowned{obj}}}
}

func marshalText(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewText() Text

func NewText(buffer EntryBuffer) Text

func (t text) ActivatesDefault() bool

func (t text) Attributes() *pango.AttrList

func (t text) Buffer() EntryBuffer

func (t text) EnableEmojiCompletion() bool

func (t text) ExtraMenu() gio.MenuModel

func (t text) InputHints() InputHints

func (t text) InputPurpose() InputPurpose

func (t text) InvisibleChar() uint32

func (t text) MaxLength() int

func (t text) OverwriteMode() bool

func (t text) PlaceholderText() string

func (t text) PropagateTextWidth() bool

func (t text) Tabs() *pango.TabArray

func (t text) TextLength() uint16

func (t text) TruncateMultiline() bool

func (t text) Visibility() bool

func (t text) GrabFocusWithoutSelecting() bool

func (t text) SetActivatesDefault(activates bool)

func (t text) SetAttributes(attrs *pango.AttrList)

func (t text) SetBuffer(buffer EntryBuffer)

func (t text) SetEnableEmojiCompletion(enableEmojiCompletion bool)

func (t text) SetExtraMenu(model gio.MenuModel)

func (t text) SetInputHints(hints InputHints)

func (t text) SetInputPurpose(purpose InputPurpose)

func (t text) SetInvisibleChar(ch uint32)

func (t text) SetMaxLength(length int)

func (t text) SetOverwriteMode(overwrite bool)

func (t text) SetPlaceholderText(text string)

func (t text) SetPropagateTextWidth(propagateTextWidth bool)

func (t text) SetTabs(tabs *pango.TabArray)

func (t text) SetTruncateMultiline(truncateMultiline bool)

func (t text) SetVisibility(visible bool)

func (t text) UnsetInvisibleChar()

// TextBuffer: you may wish to begin by reading the [text widget conceptual
// overview][TextWidget] which gives an overview of all the objects and data
// types related to the text widget and how they work together.
type TextBuffer interface {
	gextras.Objector

	// AddMark: adds the mark at position @where. The mark must not be added to
	// another buffer, and if its name is not nil then there must not be another
	// mark in the buffer with the same name.
	//
	// Emits the TextBuffer::mark-set signal as notification of the mark's
	// initial placement.
	AddMark(mark TextMark, where *TextIter)
	// AddSelectionClipboard: adds @clipboard to the list of clipboards in which
	// the selection contents of @buffer are available. In most cases,
	// @clipboard will be the Clipboard returned by
	// gtk_widget_get_primary_clipboard() for a view of @buffer.
	AddSelectionClipboard(clipboard gdk.Clipboard)
	// ApplyTag: emits the “apply-tag” signal on @buffer. The default handler
	// for the signal applies @tag to the given range. @start and @end do not
	// have to be in order.
	ApplyTag(tag TextTag, start *TextIter, end *TextIter)
	// ApplyTagByName: calls gtk_text_tag_table_lookup() on the buffer’s tag
	// table to get a TextTag, then calls gtk_text_buffer_apply_tag().
	ApplyTagByName(name string, start *TextIter, end *TextIter)
	// Backspace: performs the appropriate action as if the user hit the delete
	// key with the cursor at the position specified by @iter. In the normal
	// case a single character will be deleted, but when combining accents are
	// involved, more than one character can be deleted, and when precomposed
	// character and accent combinations are involved, less than one character
	// will be deleted.
	//
	// Because the buffer is modified, all outstanding iterators become invalid
	// after calling this function; however, the @iter will be re-initialized to
	// point to the location where text was deleted.
	Backspace(iter *TextIter, interactive bool, defaultEditable bool) bool
	// BeginIrreversibleAction: denotes the beginning of an action that may not
	// be undone. This will cause any previous operations in the undo/redo queue
	// to be cleared.
	//
	// This should be paired with a call to
	// gtk_text_buffer_end_irreversible_action() after the irreversible action
	// has completed.
	//
	// You may nest calls to gtk_text_buffer_begin_irreversible_action() and
	// gtk_text_buffer_end_irreversible_action() pairs.
	BeginIrreversibleAction()
	// BeginUserAction: called to indicate that the buffer operations between
	// here and a call to gtk_text_buffer_end_user_action() are part of a single
	// user-visible operation. The operations between
	// gtk_text_buffer_begin_user_action() and gtk_text_buffer_end_user_action()
	// can then be grouped when creating an undo stack. TextBuffer maintains a
	// count of calls to gtk_text_buffer_begin_user_action() that have not been
	// closed with a call to gtk_text_buffer_end_user_action(), and emits the
	// “begin-user-action” and “end-user-action” signals only for the outermost
	// pair of calls. This allows you to build user actions from other user
	// actions.
	//
	// The “interactive” buffer mutation functions, such as
	// gtk_text_buffer_insert_interactive(), automatically call begin/end user
	// action around the buffer operations they perform, so there's no need to
	// add extra calls if you user action consists solely of a single call to
	// one of those functions.
	BeginUserAction()
	// CopyClipboard: copies the currently-selected text to a clipboard.
	CopyClipboard(clipboard gdk.Clipboard)
	// CreateChildAnchor: this is a convenience function which simply creates a
	// child anchor with gtk_text_child_anchor_new() and inserts it into the
	// buffer with gtk_text_buffer_insert_child_anchor(). The new anchor is
	// owned by the buffer; no reference count is returned to the caller of
	// gtk_text_buffer_create_child_anchor().
	CreateChildAnchor(iter *TextIter) TextChildAnchor
	// CreateMark: creates a mark at position @where. If @mark_name is nil, the
	// mark is anonymous; otherwise, the mark can be retrieved by name using
	// gtk_text_buffer_get_mark(). If a mark has left gravity, and text is
	// inserted at the mark’s current location, the mark will be moved to the
	// left of the newly-inserted text. If the mark has right gravity
	// (@left_gravity = false), the mark will end up on the right of
	// newly-inserted text. The standard left-to-right cursor is a mark with
	// right gravity (when you type, the cursor stays on the right side of the
	// text you’re typing).
	//
	// The caller of this function does not own a reference to the returned
	// TextMark, so you can ignore the return value if you like. Marks are owned
	// by the buffer and go away when the buffer does.
	//
	// Emits the TextBuffer::mark-set signal as notification of the mark's
	// initial placement.
	CreateMark(markName string, where *TextIter, leftGravity bool) TextMark
	// CutClipboard: copies the currently-selected text to a clipboard, then
	// deletes said text if it’s editable.
	CutClipboard(clipboard gdk.Clipboard, defaultEditable bool)
	// Delete: deletes text between @start and @end. The order of @start and
	// @end is not actually relevant; gtk_text_buffer_delete() will reorder
	// them. This function actually emits the “delete-range” signal, and the
	// default handler of that signal deletes the text. Because the buffer is
	// modified, all outstanding iterators become invalid after calling this
	// function; however, the @start and @end will be re-initialized to point to
	// the location where text was deleted.
	Delete(start *TextIter, end *TextIter)
	// DeleteInteractive: deletes all editable text in the given range. Calls
	// gtk_text_buffer_delete() for each editable sub-range of [@start,@end).
	// @start and @end are revalidated to point to the location of the last
	// deleted range, or left untouched if no text was deleted.
	DeleteInteractive(startIter *TextIter, endIter *TextIter, defaultEditable bool) bool
	// DeleteMark: deletes @mark, so that it’s no longer located anywhere in the
	// buffer. Removes the reference the buffer holds to the mark, so if you
	// haven’t called g_object_ref() on the mark, it will be freed. Even if the
	// mark isn’t freed, most operations on @mark become invalid, until it gets
	// added to a buffer again with gtk_text_buffer_add_mark(). Use
	// gtk_text_mark_get_deleted() to find out if a mark has been removed from
	// its buffer. The TextBuffer::mark-deleted signal will be emitted as
	// notification after the mark is deleted.
	DeleteMark(mark TextMark)
	// DeleteMarkByName: deletes the mark named @name; the mark must exist. See
	// gtk_text_buffer_delete_mark() for details.
	DeleteMarkByName(name string)
	// DeleteSelection: deletes the range between the “insert” and
	// “selection_bound” marks, that is, the currently-selected text. If
	// @interactive is true, the editability of the selection will be considered
	// (users can’t delete uneditable text).
	DeleteSelection(interactive bool, defaultEditable bool) bool
	// EndIrreversibleAction: denotes the end of an action that may not be
	// undone. This will cause any previous operations in the undo/redo queue to
	// be cleared.
	//
	// This should be called after completing modifications to the text buffer
	// after gtk_text_buffer_begin_irreversible_action() was called.
	//
	// You may nest calls to gtk_text_buffer_begin_irreversible_action() and
	// gtk_text_buffer_end_irreversible_action() pairs.
	EndIrreversibleAction()
	// EndUserAction: should be paired with a call to
	// gtk_text_buffer_begin_user_action(). See that function for a full
	// explanation.
	EndUserAction()
	// Bounds: retrieves the first and last iterators in the buffer, i.e. the
	// entire buffer lies within the range [@start,@end).
	Bounds() (start TextIter, end TextIter)
	// CanRedo: gets whether there is a redoable action in the history.
	CanRedo() bool
	// CanUndo: gets whether there is an undoable action in the history.
	CanUndo() bool
	// CharCount: gets the number of characters in the buffer; note that
	// characters and bytes are not the same, you can’t e.g. expect the contents
	// of the buffer in string form to be this many bytes long. The character
	// count is cached, so this function is very fast.
	CharCount() int
	// EnableUndo: gets whether the buffer is saving modifications to the buffer
	// to allow for undo and redo actions.
	//
	// See gtk_text_buffer_begin_irreversible_action() and
	// gtk_text_buffer_end_irreversible_action() to create changes to the buffer
	// that cannot be undone.
	EnableUndo() bool
	// EndIter: initializes @iter with the “end iterator,” one past the last
	// valid character in the text buffer. If dereferenced with
	// gtk_text_iter_get_char(), the end iterator has a character value of 0.
	// The entire buffer lies in the range from the first position in the buffer
	// (call gtk_text_buffer_get_start_iter() to get character position 0) to
	// the end iterator.
	EndIter() TextIter
	// HasSelection: indicates whether the buffer has some text currently
	// selected.
	HasSelection() bool
	// GetInsert: returns the mark that represents the cursor (insertion point).
	// Equivalent to calling gtk_text_buffer_get_mark() to get the mark named
	// “insert”, but very slightly more efficient, and involves less typing.
	GetInsert() TextMark
	// IterAtChildAnchor: obtains the location of @anchor within @buffer.
	IterAtChildAnchor(anchor TextChildAnchor) TextIter
	// IterAtLine: initializes @iter to the start of the given line. If
	// @line_number is greater than the number of lines in the @buffer, the end
	// iterator is returned.
	IterAtLine(lineNumber int) (iter TextIter, ok bool)
	// IterAtLineIndex: obtains an iterator pointing to @byte_index within the
	// given line. @byte_index must be the start of a UTF-8 character. Note
	// bytes, not characters; UTF-8 may encode one character as multiple bytes.
	//
	// If @line_number is greater than the number of lines in the @buffer, the
	// end iterator is returned. And if @byte_index is off the end of the line,
	// the iterator at the end of the line is returned.
	IterAtLineIndex(lineNumber int, byteIndex int) (iter TextIter, ok bool)
	// IterAtLineOffset: obtains an iterator pointing to @char_offset within the
	// given line. Note characters, not bytes; UTF-8 may encode one character as
	// multiple bytes.
	//
	// Before the 3.20 version, it was not allowed to pass an invalid location.
	//
	// If @line_number is greater than the number of lines in the @buffer, the
	// end iterator is returned. And if @char_offset is off the end of the line,
	// the iterator at the end of the line is returned.
	IterAtLineOffset(lineNumber int, charOffset int) (iter TextIter, ok bool)
	// IterAtMark: initializes @iter with the current position of @mark.
	IterAtMark(mark TextMark) TextIter
	// IterAtOffset: initializes @iter to a position @char_offset chars from the
	// start of the entire buffer. If @char_offset is -1 or greater than the
	// number of characters in the buffer, @iter is initialized to the end
	// iterator, the iterator one past the last valid character in the buffer.
	IterAtOffset(charOffset int) TextIter
	// LineCount: obtains the number of lines in the buffer. This value is
	// cached, so the function is very fast.
	LineCount() int
	// Mark: returns the mark named @name in buffer @buffer, or nil if no such
	// mark exists in the buffer.
	Mark(name string) TextMark
	// MaxUndoLevels: gets the maximum number of undo levels to perform. If 0,
	// unlimited undo actions may be performed. Note that this may have a memory
	// usage impact as it requires storing an additional copy of the inserted or
	// removed text within the text buffer.
	MaxUndoLevels() uint
	// Modified: indicates whether the buffer has been modified since the last
	// call to gtk_text_buffer_set_modified() set the modification flag to
	// false. Used for example to enable a “save” function in a text editor.
	Modified() bool
	// SelectionBound: returns the mark that represents the selection bound.
	// Equivalent to calling gtk_text_buffer_get_mark() to get the mark named
	// “selection_bound”, but very slightly more efficient, and involves less
	// typing.
	//
	// The currently-selected text in @buffer is the region between the
	// “selection_bound” and “insert” marks. If “selection_bound” and “insert”
	// are in the same place, then there is no current selection.
	// gtk_text_buffer_get_selection_bounds() is another convenient function for
	// handling the selection, if you just want to know whether there’s a
	// selection and what its bounds are.
	SelectionBound() TextMark
	// SelectionBounds: returns true if some text is selected; places the bounds
	// of the selection in @start and @end (if the selection has length 0, then
	// @start and @end are filled in with the same value). @start and @end will
	// be in ascending order. If @start and @end are NULL, then they are not
	// filled in, but the return value still indicates whether text is selected.
	SelectionBounds() (start TextIter, end TextIter, ok bool)
	// SelectionContent: get a content provider for this buffer. It can be used
	// to make the content of @buffer available in a Clipboard, see
	// gdk_clipboard_set_content().
	SelectionContent() gdk.ContentProvider
	// Slice: returns the text in the range [@start,@end). Excludes undisplayed
	// text (text marked with tags that set the invisibility attribute) if
	// @include_hidden_chars is false. The returned string includes a 0xFFFC
	// character whenever the buffer contains embedded images, so byte and
	// character indexes into the returned string do correspond to byte and
	// character indexes into the buffer. Contrast with
	// gtk_text_buffer_get_text(). Note that 0xFFFC can occur in normal text as
	// well, so it is not a reliable indicator that a paintable or widget is in
	// the buffer.
	Slice(start *TextIter, end *TextIter, includeHiddenChars bool) string
	// StartIter: initialized @iter with the first position in the text buffer.
	// This is the same as using gtk_text_buffer_get_iter_at_offset() to get the
	// iter at character offset 0.
	StartIter() TextIter
	// TagTable: get the TextTagTable associated with this buffer.
	TagTable() TextTagTable
	// Text: returns the text in the range [@start,@end). Excludes undisplayed
	// text (text marked with tags that set the invisibility attribute) if
	// @include_hidden_chars is false. Does not include characters representing
	// embedded images, so byte and character indexes into the returned string
	// do not correspond to byte and character indexes into the buffer. Contrast
	// with gtk_text_buffer_get_slice().
	Text(start *TextIter, end *TextIter, includeHiddenChars bool) string
	// Insert: inserts @len bytes of @text at position @iter. If @len is -1,
	// @text must be nul-terminated and will be inserted in its entirety. Emits
	// the “insert-text” signal; insertion actually occurs in the default
	// handler for the signal. @iter is invalidated when insertion occurs
	// (because the buffer contents change), but the default signal handler
	// revalidates it to point to the end of the inserted text.
	Insert(iter *TextIter, text string, len int)
	// InsertAtCursor: simply calls gtk_text_buffer_insert(), using the current
	// cursor position as the insertion point.
	InsertAtCursor(text string, len int)
	// InsertChildAnchor: inserts a child widget anchor into the text buffer at
	// @iter. The anchor will be counted as one character in character counts,
	// and when obtaining the buffer contents as a string, will be represented
	// by the Unicode “object replacement character” 0xFFFC. Note that the
	// “slice” variants for obtaining portions of the buffer as a string include
	// this character for child anchors, but the “text” variants do not. E.g.
	// see gtk_text_buffer_get_slice() and gtk_text_buffer_get_text(). Consider
	// gtk_text_buffer_create_child_anchor() as a more convenient alternative to
	// this function. The buffer will add a reference to the anchor, so you can
	// unref it after insertion.
	InsertChildAnchor(iter *TextIter, anchor TextChildAnchor)
	// InsertInteractive: like gtk_text_buffer_insert(), but the insertion will
	// not occur if @iter is at a non-editable location in the buffer. Usually
	// you want to prevent insertions at ineditable locations if the insertion
	// results from a user action (is interactive).
	//
	// @default_editable indicates the editability of text that doesn't have a
	// tag affecting editability applied to it. Typically the result of
	// gtk_text_view_get_editable() is appropriate here.
	InsertInteractive(iter *TextIter, text string, len int, defaultEditable bool) bool
	// InsertInteractiveAtCursor: calls gtk_text_buffer_insert_interactive() at
	// the cursor position.
	//
	// @default_editable indicates the editability of text that doesn't have a
	// tag affecting editability applied to it. Typically the result of
	// gtk_text_view_get_editable() is appropriate here.
	InsertInteractiveAtCursor(text string, len int, defaultEditable bool) bool
	// InsertMarkup: inserts the text in @markup at position @iter. @markup will
	// be inserted in its entirety and must be nul-terminated and valid UTF-8.
	// Emits the TextBuffer::insert-text signal, possibly multiple times;
	// insertion actually occurs in the default handler for the signal. @iter
	// will point to the end of the inserted text on return.
	InsertMarkup(iter *TextIter, markup string, len int)
	// InsertPaintable: inserts an image into the text buffer at @iter. The
	// image will be counted as one character in character counts, and when
	// obtaining the buffer contents as a string, will be represented by the
	// Unicode “object replacement character” 0xFFFC. Note that the “slice”
	// variants for obtaining portions of the buffer as a string include this
	// character for paintable, but the “text” variants do not. e.g. see
	// gtk_text_buffer_get_slice() and gtk_text_buffer_get_text().
	InsertPaintable(iter *TextIter, paintable gdk.Paintable)
	// InsertRange: copies text, tags, and paintables between @start and @end
	// (the order of @start and @end doesn’t matter) and inserts the copy at
	// @iter. Used instead of simply getting/inserting text because it preserves
	// images and tags. If @start and @end are in a different buffer from
	// @buffer, the two buffers must share the same tag table.
	//
	// Implemented via emissions of the insert_text and apply_tag signals, so
	// expect those.
	InsertRange(iter *TextIter, start *TextIter, end *TextIter)
	// InsertRangeInteractive: same as gtk_text_buffer_insert_range(), but does
	// nothing if the insertion point isn’t editable. The @default_editable
	// parameter indicates whether the text is editable at @iter if no tags
	// enclosing @iter affect editability. Typically the result of
	// gtk_text_view_get_editable() is appropriate here.
	InsertRangeInteractive(iter *TextIter, start *TextIter, end *TextIter, defaultEditable bool) bool
	// MoveMark: moves @mark to the new location @where. Emits the
	// TextBuffer::mark-set signal as notification of the move.
	MoveMark(mark TextMark, where *TextIter)
	// MoveMarkByName: moves the mark named @name (which must exist) to location
	// @where. See gtk_text_buffer_move_mark() for details.
	MoveMarkByName(name string, where *TextIter)
	// PasteClipboard: pastes the contents of a clipboard. If @override_location
	// is nil, the pasted text will be inserted at the cursor position, or the
	// buffer selection will be replaced if the selection is non-empty.
	//
	// Note: pasting is asynchronous, that is, we’ll ask for the paste data and
	// return, and at some point later after the main loop runs, the paste data
	// will be inserted.
	PasteClipboard(clipboard gdk.Clipboard, overrideLocation *TextIter, defaultEditable bool)
	// PlaceCursor: this function moves the “insert” and “selection_bound” marks
	// simultaneously. If you move them to the same place in two steps with
	// gtk_text_buffer_move_mark(), you will temporarily select a region in
	// between their old and new locations, which can be pretty inefficient
	// since the temporarily-selected region will force stuff to be
	// recalculated. This function moves them as a unit, which can be optimized.
	PlaceCursor(where *TextIter)
	// Redo: redoes the next redoable action on the buffer, if there is one.
	Redo()
	// RemoveAllTags: removes all tags in the range between @start and @end. Be
	// careful with this function; it could remove tags added in code unrelated
	// to the code you’re currently writing. That is, using this function is
	// probably a bad idea if you have two or more unrelated code sections that
	// add tags.
	RemoveAllTags(start *TextIter, end *TextIter)
	// RemoveSelectionClipboard: removes a Clipboard added with
	// gtk_text_buffer_add_selection_clipboard().
	RemoveSelectionClipboard(clipboard gdk.Clipboard)
	// RemoveTag: emits the “remove-tag” signal. The default handler for the
	// signal removes all occurrences of @tag from the given range. @start and
	// @end don’t have to be in order.
	RemoveTag(tag TextTag, start *TextIter, end *TextIter)
	// RemoveTagByName: calls gtk_text_tag_table_lookup() on the buffer’s tag
	// table to get a TextTag, then calls gtk_text_buffer_remove_tag().
	RemoveTagByName(name string, start *TextIter, end *TextIter)
	// SelectRange: this function moves the “insert” and “selection_bound” marks
	// simultaneously. If you move them in two steps with
	// gtk_text_buffer_move_mark(), you will temporarily select a region in
	// between their old and new locations, which can be pretty inefficient
	// since the temporarily-selected region will force stuff to be
	// recalculated. This function moves them as a unit, which can be optimized.
	SelectRange(ins *TextIter, bound *TextIter)
	// SetEnableUndo: sets whether or not to enable undoable actions in the text
	// buffer. If enabled, the user will be able to undo the last number of
	// actions up to gtk_text_buffer_get_max_undo_levels().
	//
	// See gtk_text_buffer_begin_irreversible_action() and
	// gtk_text_buffer_end_irreversible_action() to create changes to the buffer
	// that cannot be undone.
	SetEnableUndo(enableUndo bool)
	// SetMaxUndoLevels: sets the maximum number of undo levels to perform. If
	// 0, unlimited undo actions may be performed. Note that this may have a
	// memory usage impact as it requires storing an additional copy of the
	// inserted or removed text within the text buffer.
	SetMaxUndoLevels(maxUndoLevels uint)
	// SetModified: used to keep track of whether the buffer has been modified
	// since the last time it was saved. Whenever the buffer is saved to disk,
	// call gtk_text_buffer_set_modified (@buffer, FALSE). When the buffer is
	// modified, it will automatically toggled on the modified bit again. When
	// the modified bit flips, the buffer emits the TextBuffer::modified-changed
	// signal.
	SetModified(setting bool)
	// SetText: deletes current contents of @buffer, and inserts @text instead.
	// If @len is -1, @text must be nul-terminated. @text must be valid UTF-8.
	SetText(text string, len int)
	// Undo: undoes the last undoable action on the buffer, if there is one.
	Undo()
}

type textBuffer struct {
	*externglib.Object
}

func wrapTextBuffer(obj *externglib.Object) TextBuffer {
	return textBuffer{*externglib.Object{obj}}
}

func marshalTextBuffer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewTextBuffer(table TextTagTable) TextBuffer

func (t textBuffer) AddMark(mark TextMark, where *TextIter)

func (t textBuffer) AddSelectionClipboard(clipboard gdk.Clipboard)

func (t textBuffer) ApplyTag(tag TextTag, start *TextIter, end *TextIter)

func (t textBuffer) ApplyTagByName(name string, start *TextIter, end *TextIter)

func (t textBuffer) Backspace(iter *TextIter, interactive bool, defaultEditable bool) bool

func (t textBuffer) BeginIrreversibleAction()

func (t textBuffer) BeginUserAction()

func (t textBuffer) CopyClipboard(clipboard gdk.Clipboard)

func (t textBuffer) CreateChildAnchor(iter *TextIter) TextChildAnchor

func (t textBuffer) CreateMark(markName string, where *TextIter, leftGravity bool) TextMark

func (t textBuffer) CutClipboard(clipboard gdk.Clipboard, defaultEditable bool)

func (t textBuffer) Delete(start *TextIter, end *TextIter)

func (t textBuffer) DeleteInteractive(startIter *TextIter, endIter *TextIter, defaultEditable bool) bool

func (t textBuffer) DeleteMark(mark TextMark)

func (t textBuffer) DeleteMarkByName(name string)

func (t textBuffer) DeleteSelection(interactive bool, defaultEditable bool) bool

func (t textBuffer) EndIrreversibleAction()

func (t textBuffer) EndUserAction()

func (t textBuffer) Bounds() (start TextIter, end TextIter)

func (t textBuffer) CanRedo() bool

func (t textBuffer) CanUndo() bool

func (t textBuffer) CharCount() int

func (t textBuffer) EnableUndo() bool

func (t textBuffer) EndIter() TextIter

func (t textBuffer) HasSelection() bool

func (t textBuffer) GetInsert() TextMark

func (t textBuffer) IterAtChildAnchor(anchor TextChildAnchor) TextIter

func (t textBuffer) IterAtLine(lineNumber int) (iter TextIter, ok bool)

func (t textBuffer) IterAtLineIndex(lineNumber int, byteIndex int) (iter TextIter, ok bool)

func (t textBuffer) IterAtLineOffset(lineNumber int, charOffset int) (iter TextIter, ok bool)

func (t textBuffer) IterAtMark(mark TextMark) TextIter

func (t textBuffer) IterAtOffset(charOffset int) TextIter

func (t textBuffer) LineCount() int

func (t textBuffer) Mark(name string) TextMark

func (t textBuffer) MaxUndoLevels() uint

func (t textBuffer) Modified() bool

func (t textBuffer) SelectionBound() TextMark

func (t textBuffer) SelectionBounds() (start TextIter, end TextIter, ok bool)

func (t textBuffer) SelectionContent() gdk.ContentProvider

func (t textBuffer) Slice(start *TextIter, end *TextIter, includeHiddenChars bool) string

func (t textBuffer) StartIter() TextIter

func (t textBuffer) TagTable() TextTagTable

func (t textBuffer) Text(start *TextIter, end *TextIter, includeHiddenChars bool) string

func (t textBuffer) Insert(iter *TextIter, text string, len int)

func (t textBuffer) InsertAtCursor(text string, len int)

func (t textBuffer) InsertChildAnchor(iter *TextIter, anchor TextChildAnchor)

func (t textBuffer) InsertInteractive(iter *TextIter, text string, len int, defaultEditable bool) bool

func (t textBuffer) InsertInteractiveAtCursor(text string, len int, defaultEditable bool) bool

func (t textBuffer) InsertMarkup(iter *TextIter, markup string, len int)

func (t textBuffer) InsertPaintable(iter *TextIter, paintable gdk.Paintable)

func (t textBuffer) InsertRange(iter *TextIter, start *TextIter, end *TextIter)

func (t textBuffer) InsertRangeInteractive(iter *TextIter, start *TextIter, end *TextIter, defaultEditable bool) bool

func (t textBuffer) MoveMark(mark TextMark, where *TextIter)

func (t textBuffer) MoveMarkByName(name string, where *TextIter)

func (t textBuffer) PasteClipboard(clipboard gdk.Clipboard, overrideLocation *TextIter, defaultEditable bool)

func (t textBuffer) PlaceCursor(where *TextIter)

func (t textBuffer) Redo()

func (t textBuffer) RemoveAllTags(start *TextIter, end *TextIter)

func (t textBuffer) RemoveSelectionClipboard(clipboard gdk.Clipboard)

func (t textBuffer) RemoveTag(tag TextTag, start *TextIter, end *TextIter)

func (t textBuffer) RemoveTagByName(name string, start *TextIter, end *TextIter)

func (t textBuffer) SelectRange(ins *TextIter, bound *TextIter)

func (t textBuffer) SetEnableUndo(enableUndo bool)

func (t textBuffer) SetMaxUndoLevels(maxUndoLevels uint)

func (t textBuffer) SetModified(setting bool)

func (t textBuffer) SetText(text string, len int)

func (t textBuffer) Undo()

// TextChildAnchor: a TextChildAnchor is a spot in the buffer where child
// widgets can be “anchored” (inserted inline, as if they were characters). The
// anchor can have multiple widgets anchored, to allow for multiple views.
type TextChildAnchor interface {
	gextras.Objector

	// Deleted: determines whether a child anchor has been deleted from the
	// buffer. Keep in mind that the child anchor will be unreferenced when
	// removed from the buffer, so you need to hold your own reference (with
	// g_object_ref()) if you plan to use this function — otherwise all deleted
	// child anchors will also be finalized.
	Deleted() bool
	// Widgets: gets a list of all widgets anchored at this child anchor.
	//
	// The order in which the widgets are returned is not defined.
	Widgets() (outLen uint, widgets []Widget)
}

type textChildAnchor struct {
	*externglib.Object
}

func wrapTextChildAnchor(obj *externglib.Object) TextChildAnchor {
	return textChildAnchor{*externglib.Object{obj}}
}

func marshalTextChildAnchor(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewTextChildAnchor() TextChildAnchor

func (t textChildAnchor) Deleted() bool

func (t textChildAnchor) Widgets() (outLen uint, widgets []Widget)

// TextMark: you may wish to begin by reading the [text widget conceptual
// overview][TextWidget] which gives an overview of all the objects and data
// types related to the text widget and how they work together.
//
// A TextMark is like a bookmark in a text buffer; it preserves a position in
// the text. You can convert the mark to an iterator using
// gtk_text_buffer_get_iter_at_mark(). Unlike iterators, marks remain valid
// across buffer mutations, because their behavior is defined when text is
// inserted or deleted. When text containing a mark is deleted, the mark remains
// in the position originally occupied by the deleted text. When text is
// inserted at a mark, a mark with “left gravity” will be moved to the beginning
// of the newly-inserted text, and a mark with “right gravity” will be moved to
// the end.
//
// Note that “left” and “right” here refer to logical direction (left is the
// toward the start of the buffer); in some languages such as Hebrew the
// logically-leftmost text is not actually on the left when displayed.
//
// Marks are reference counted, but the reference count only controls the
// validity of the memory; marks can be deleted from the buffer at any time with
// gtk_text_buffer_delete_mark(). Once deleted from the buffer, a mark is
// essentially useless.
//
// Marks optionally have names; these can be convenient to avoid passing the
// TextMark object around.
//
// Marks are typically created using the gtk_text_buffer_create_mark() function.
type TextMark interface {
	gextras.Objector

	// Buffer: gets the buffer this mark is located inside, or nil if the mark
	// is deleted.
	Buffer() TextBuffer
	// Deleted: returns true if the mark has been removed from its buffer with
	// gtk_text_buffer_delete_mark(). See gtk_text_buffer_add_mark() for a way
	// to add it to a buffer again.
	Deleted() bool
	// LeftGravity: determines whether the mark has left gravity.
	LeftGravity() bool
	// Name: returns the mark name; returns NULL for anonymous marks.
	Name() string
	// Visible: returns true if the mark is visible (i.e. a cursor is displayed
	// for it).
	Visible() bool

	SetVisible(setting bool)
}

type textMark struct {
	*externglib.Object
}

func wrapTextMark(obj *externglib.Object) TextMark {
	return textMark{*externglib.Object{obj}}
}

func marshalTextMark(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewTextMark(name string, leftGravity bool) TextMark

func (t textMark) Buffer() TextBuffer

func (t textMark) Deleted() bool

func (t textMark) LeftGravity() bool

func (t textMark) Name() string

func (t textMark) Visible() bool

func (t textMark) SetVisible(setting bool)

// TextTag: you may wish to begin by reading the [text widget conceptual
// overview][TextWidget] which gives an overview of all the objects and data
// types related to the text widget and how they work together.
//
// Tags should be in the TextTagTable for a given TextBuffer before using them
// with that buffer.
//
// gtk_text_buffer_create_tag() is the best way to create tags. See “gtk4-demo”
// for numerous examples.
//
// For each property of TextTag, there is a “set” property, e.g. “font-set”
// corresponds to “font”. These “set” properties reflect whether a property has
// been set or not. They are maintained by GTK+ and you should not set them
// independently.
type TextTag interface {
	gextras.Objector

	// Changed: emits the TextTagTable::tag-changed signal on the TextTagTable
	// where the tag is included.
	//
	// The signal is already emitted when setting a TextTag property. This
	// function is useful for a TextTag subclass.
	Changed(sizeChanged bool)
	// Priority: get the tag priority.
	Priority() int
	// SetPriority: sets the priority of a TextTag. Valid priorities start at 0
	// and go to one less than gtk_text_tag_table_get_size(). Each tag in a
	// table has a unique priority; setting the priority of one tag shifts the
	// priorities of all the other tags in the table to maintain a unique
	// priority for each tag. Higher priority tags “win” if two tags both set
	// the same text attribute. When adding a tag to a tag table, it will be
	// assigned the highest priority in the table by default; so normally the
	// precedence of a set of tags is the order in which they were added to the
	// table, or created with gtk_text_buffer_create_tag(), which adds the tag
	// to the buffer’s table automatically.
	SetPriority(priority int)
}

type textTag struct {
	*externglib.Object
}

func wrapTextTag(obj *externglib.Object) TextTag {
	return textTag{*externglib.Object{obj}}
}

func marshalTextTag(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewTextTag(name string) TextTag

func (t textTag) Changed(sizeChanged bool)

func (t textTag) Priority() int

func (t textTag) SetPriority(priority int)

// TextTagTable: you may wish to begin by reading the [text widget conceptual
// overview][TextWidget] which gives an overview of all the objects and data
// types related to the text widget and how they work together.
//
//
// GtkTextTagTables as GtkBuildable
//
// The GtkTextTagTable implementation of the GtkBuildable interface supports
// adding tags by specifying “tag” as the “type” attribute of a <child> element.
//
//
//    <object class="GtkTextTagTable">
//     <child type="tag">
//       <object class="GtkTextTag"/>
//     </child>
//    </object>
type TextTagTable interface {
	gextras.Objector

	// Add: add a tag to the table. The tag is assigned the highest priority in
	// the table.
	//
	// @tag must not be in a tag table already, and may not have the same name
	// as an already-added tag.
	Add(tag TextTag) bool
	// Foreach: calls @func on each tag in @table, with user data @data. Note
	// that the table may not be modified while iterating over it (you can’t
	// add/remove tags).
	Foreach(_func TextTagTableForeach)
	// Size: returns the size of the table (number of tags)
	Size() int
	// Lookup: look up a named tag.
	Lookup(name string) TextTag
	// Remove: remove a tag from the table. If a TextBuffer has @table as its
	// tag table, the tag is removed from the buffer. The table’s reference to
	// the tag is removed, so the tag will end up destroyed if you don’t have a
	// reference to it.
	Remove(tag TextTag)
}

type textTagTable struct {
	*externglib.Object
}

func wrapTextTagTable(obj *externglib.Object) TextTagTable {
	return textTagTable{*externglib.Object{obj}}
}

func marshalTextTagTable(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewTextTagTable() TextTagTable

func (t textTagTable) Add(tag TextTag) bool

func (t textTagTable) Foreach(_func TextTagTableForeach)

func (t textTagTable) Size() int

func (t textTagTable) Lookup(name string) TextTag

func (t textTagTable) Remove(tag TextTag)

// TextView: you may wish to begin by reading the [text widget conceptual
// overview][TextWidget] which gives an overview of all the objects and data
// types related to the text widget and how they work together.
//
// CSS nodes
//
//    textview.view
//    ├── border.top
//    ├── border.left
//    ├── text
//    │   ╰── [selection]
//    ├── border.right
//    ├── border.bottom
//    ╰── [window.popup]
//
// GtkTextView has a main css node with name textview and style class .view, and
// subnodes for each of the border windows, and the main text area, with names
// border and text, respectively. The border nodes each get one of the style
// classes .left, .right, .top or .bottom.
//
// A node representing the selection will appear below the text node.
//
// If a context menu is opened, the window node will appear as a subnode of the
// main node.
//
//
// Accessibility
//
// GtkTextView uses the K_ACCESSIBLE_ROLE_TEXT_BOX role.
type TextView interface {
	Widget

	// AddChildAtAnchor: adds a child widget in the text buffer, at the given
	// @anchor.
	AddChildAtAnchor(child Widget, anchor TextChildAnchor)
	// AddOverlay: adds @child at a fixed coordinate in the TextView's text
	// window. The @xpos and @ypos must be in buffer coordinates (see
	// gtk_text_view_get_iter_location() to convert to buffer coordinates).
	//
	// @child will scroll with the text view.
	//
	// If instead you want a widget that will not move with the TextView
	// contents see Overlay.
	AddOverlay(child Widget, xpos int, ypos int)
	// BackwardDisplayLine: moves the given @iter backward by one display
	// (wrapped) line. A display line is different from a paragraph. Paragraphs
	// are separated by newlines or other paragraph separator characters.
	// Display lines are created by line-wrapping a paragraph. If wrapping is
	// turned off, display lines and paragraphs will be the same. Display lines
	// are divided differently for each view, since they depend on the view’s
	// width; paragraphs are the same in all views, since they depend on the
	// contents of the TextBuffer.
	BackwardDisplayLine(iter *TextIter) bool
	// BackwardDisplayLineStart: moves the given @iter backward to the next
	// display line start. A display line is different from a paragraph.
	// Paragraphs are separated by newlines or other paragraph separator
	// characters. Display lines are created by line-wrapping a paragraph. If
	// wrapping is turned off, display lines and paragraphs will be the same.
	// Display lines are divided differently for each view, since they depend on
	// the view’s width; paragraphs are the same in all views, since they depend
	// on the contents of the TextBuffer.
	BackwardDisplayLineStart(iter *TextIter) bool
	// BufferToWindowCoords: converts coordinate (@buffer_x, @buffer_y) to
	// coordinates for the window @win, and stores the result in (@window_x,
	// @window_y).
	BufferToWindowCoords(win TextWindowType, bufferX int, bufferY int) (windowX int, windowY int)
	// ForwardDisplayLine: moves the given @iter forward by one display
	// (wrapped) line. A display line is different from a paragraph. Paragraphs
	// are separated by newlines or other paragraph separator characters.
	// Display lines are created by line-wrapping a paragraph. If wrapping is
	// turned off, display lines and paragraphs will be the same. Display lines
	// are divided differently for each view, since they depend on the view’s
	// width; paragraphs are the same in all views, since they depend on the
	// contents of the TextBuffer.
	ForwardDisplayLine(iter *TextIter) bool
	// ForwardDisplayLineEnd: moves the given @iter forward to the next display
	// line end. A display line is different from a paragraph. Paragraphs are
	// separated by newlines or other paragraph separator characters. Display
	// lines are created by line-wrapping a paragraph. If wrapping is turned
	// off, display lines and paragraphs will be the same. Display lines are
	// divided differently for each view, since they depend on the view’s width;
	// paragraphs are the same in all views, since they depend on the contents
	// of the TextBuffer.
	ForwardDisplayLineEnd(iter *TextIter) bool
	// AcceptsTab: returns whether pressing the Tab key inserts a tab
	// characters. gtk_text_view_set_accepts_tab().
	AcceptsTab() bool
	// BottomMargin: gets the bottom margin for text in the @text_view.
	BottomMargin() int
	// Buffer: returns the TextBuffer being displayed by this text view. The
	// reference count on the buffer is not incremented; the caller of this
	// function won’t own a new reference.
	Buffer() TextBuffer
	// CursorLocations: given an @iter within a text layout, determine the
	// positions of the strong and weak cursors if the insertion point is at
	// that iterator. The position of each cursor is stored as a zero-width
	// rectangle. The strong cursor location is the location where characters of
	// the directionality equal to the base direction of the paragraph are
	// inserted. The weak cursor location is the location where characters of
	// the directionality opposite to the base direction of the paragraph are
	// inserted.
	//
	// If @iter is nil, the actual cursor position is used.
	//
	// Note that if @iter happens to be the actual cursor position, and there is
	// currently an IM preedit sequence being entered, the returned locations
	// will be adjusted to account for the preedit cursor’s offset within the
	// preedit sequence.
	//
	// The rectangle position is in buffer coordinates; use
	// gtk_text_view_buffer_to_window_coords() to convert these coordinates to
	// coordinates for one of the windows in the text view.
	CursorLocations(iter *TextIter) (strong gdk.Rectangle, weak gdk.Rectangle)
	// CursorVisible: find out whether the cursor should be displayed.
	CursorVisible() bool
	// Editable: returns the default editability of the TextView. Tags in the
	// buffer may override this setting for some ranges of text.
	Editable() bool
	// ExtraMenu: gets the menu model set with gtk_text_view_set_extra_menu() or
	// nil if none has been set.
	ExtraMenu() gio.MenuModel
	// Gutter: gets a Widget that has previously been set with
	// gtk_text_view_set_gutter().
	//
	// @win must be one of GTK_TEXT_WINDOW_LEFT, GTK_TEXT_WINDOW_RIGHT,
	// GTK_TEXT_WINDOW_TOP, or GTK_TEXT_WINDOW_BOTTOM.
	Gutter(win TextWindowType) Widget
	// Indent: gets the default indentation of paragraphs in @text_view. Tags in
	// the view’s buffer may override the default. The indentation may be
	// negative.
	Indent() int
	// InputHints: gets the value of the TextView:input-hints property.
	InputHints() InputHints
	// InputPurpose: gets the value of the TextView:input-purpose property.
	InputPurpose() InputPurpose
	// IterAtLocation: retrieves the iterator at buffer coordinates @x and @y.
	// Buffer coordinates are coordinates for the entire buffer, not just the
	// currently-displayed portion. If you have coordinates from an event, you
	// have to convert those to buffer coordinates with
	// gtk_text_view_window_to_buffer_coords().
	IterAtLocation(x int, y int) (iter TextIter, ok bool)
	// IterAtPosition: retrieves the iterator pointing to the character at
	// buffer coordinates @x and @y. Buffer coordinates are coordinates for the
	// entire buffer, not just the currently-displayed portion. If you have
	// coordinates from an event, you have to convert those to buffer
	// coordinates with gtk_text_view_window_to_buffer_coords().
	//
	// Note that this is different from gtk_text_view_get_iter_at_location(),
	// which returns cursor locations, i.e. positions between characters.
	IterAtPosition(x int, y int) (iter TextIter, trailing int, ok bool)
	// IterLocation: gets a rectangle which roughly contains the character at
	// @iter. The rectangle position is in buffer coordinates; use
	// gtk_text_view_buffer_to_window_coords() to convert these coordinates to
	// coordinates for one of the windows in the text view.
	IterLocation(iter *TextIter) gdk.Rectangle
	// Justification: gets the default justification of paragraphs in
	// @text_view. Tags in the buffer may override the default.
	Justification() Justification
	// LeftMargin: gets the default left margin size of paragraphs in the
	// @text_view. Tags in the buffer may override the default.
	LeftMargin() int
	// LineAtY: gets the TextIter at the start of the line containing the
	// coordinate @y. @y is in buffer coordinates, convert from window
	// coordinates with gtk_text_view_window_to_buffer_coords(). If non-nil,
	// @line_top will be filled with the coordinate of the top edge of the line.
	LineAtY(y int) (targetIter TextIter, lineTop int)
	// LineYrange: gets the y coordinate of the top of the line containing
	// @iter, and the height of the line. The coordinate is a buffer coordinate;
	// convert to window coordinates with
	// gtk_text_view_buffer_to_window_coords().
	LineYrange(iter *TextIter) (y int, height int)
	// Monospace: gets the value of the TextView:monospace property.
	Monospace() bool
	// Overwrite: returns whether the TextView is in overwrite mode or not.
	Overwrite() bool
	// PixelsAboveLines: gets the default number of pixels to put above
	// paragraphs. Adding this function with
	// gtk_text_view_get_pixels_below_lines() is equal to the line space between
	// each paragraph.
	PixelsAboveLines() int
	// PixelsBelowLines: gets the value set by
	// gtk_text_view_set_pixels_below_lines().
	//
	// The line space is the sum of the value returned by this function and the
	// value returned by gtk_text_view_get_pixels_above_lines().
	PixelsBelowLines() int
	// PixelsInsideWrap: gets the value set by
	// gtk_text_view_set_pixels_inside_wrap().
	PixelsInsideWrap() int
	// RightMargin: gets the default right margin for text in @text_view. Tags
	// in the buffer may override the default.
	RightMargin() int
	// Tabs: gets the default tabs for @text_view. Tags in the buffer may
	// override the defaults. The returned array will be nil if “standard”
	// (8-space) tabs are used. Free the return value with
	// pango_tab_array_free().
	Tabs() *pango.TabArray
	// TopMargin: gets the top margin for text in the @text_view.
	TopMargin() int
	// VisibleRect: fills @visible_rect with the currently-visible region of the
	// buffer, in buffer coordinates. Convert to window coordinates with
	// gtk_text_view_buffer_to_window_coords().
	VisibleRect() gdk.Rectangle
	// WrapMode: gets the line wrapping for the view.
	WrapMode() WrapMode
	// ImContextFilterKeypress: allow the TextView input method to internally
	// handle key press and release events. If this function returns true, then
	// no further processing should be done for this key event. See
	// gtk_im_context_filter_keypress().
	//
	// Note that you are expected to call this function from your handler when
	// overriding key event handling. This is needed in the case when you need
	// to insert your own key handling between the input method and the default
	// key event handling of the TextView.
	//
	//    static gboolean
	//    gtk_foo_bar_key_press_event (GtkWidget *widget,
	//                                 GdkEvent  *event)
	//    {
	//      guint keyval;
	//
	//      gdk_event_get_keyval ((GdkEvent*)event, &keyval);
	//
	//      if (keyval == GDK_KEY_Return || keyval == GDK_KEY_KP_Enter)
	//        {
	//          if (gtk_text_view_im_context_filter_keypress (GTK_TEXT_VIEW (widget), event))
	//            return TRUE;
	//        }
	//
	//      // Do some stuff
	//
	//      return GTK_WIDGET_CLASS (gtk_foo_bar_parent_class)->key_press_event (widget, event);
	//    }
	//
	ImContextFilterKeypress(event gdk.Event) bool
	// MoveMarkOnscreen: moves a mark within the buffer so that it's located
	// within the currently-visible text area.
	MoveMarkOnscreen(mark TextMark) bool
	// MoveOverlay: updates the position of a child, as for
	// gtk_text_view_add_overlay().
	MoveOverlay(child Widget, xpos int, ypos int)
	// MoveVisually: move the iterator a given number of characters visually,
	// treating it as the strong cursor position. If @count is positive, then
	// the new strong cursor position will be @count positions to the right of
	// the old cursor position. If @count is negative then the new strong cursor
	// position will be @count positions to the left of the old cursor position.
	//
	// In the presence of bi-directional text, the correspondence between
	// logical and visual order will depend on the direction of the current run,
	// and there may be jumps when the cursor is moved off of the end of a run.
	MoveVisually(iter *TextIter, count int) bool
	// PlaceCursorOnscreen: moves the cursor to the currently visible region of
	// the buffer, if it isn’t there already.
	PlaceCursorOnscreen() bool
	// Remove: removes a child widget from @text_view.
	Remove(child Widget)
	// ResetCursorBlink: ensures that the cursor is shown (i.e. not in an 'off'
	// blink interval) and resets the time that it will stay blinking (or
	// visible, in case blinking is disabled).
	//
	// This function should be called in response to user input (e.g. from
	// derived classes that override the textview's event handlers).
	ResetCursorBlink()
	// ResetImContext: reset the input method context of the text view if
	// needed.
	//
	// This can be necessary in the case where modifying the buffer would
	// confuse on-going input method behavior.
	ResetImContext()
	// ScrollMarkOnscreen: scrolls @text_view the minimum distance such that
	// @mark is contained within the visible area of the widget.
	ScrollMarkOnscreen(mark TextMark)
	// ScrollToIter: scrolls @text_view so that @iter is on the screen in the
	// position indicated by @xalign and @yalign. An alignment of 0.0 indicates
	// left or top, 1.0 indicates right or bottom, 0.5 means center. If
	// @use_align is false, the text scrolls the minimal distance to get the
	// mark onscreen, possibly not scrolling at all. The effective screen for
	// purposes of this function is reduced by a margin of size @within_margin.
	//
	// Note that this function uses the currently-computed height of the lines
	// in the text buffer. Line heights are computed in an idle handler; so this
	// function may not have the desired effect if it’s called before the height
	// computations. To avoid oddness, consider using
	// gtk_text_view_scroll_to_mark() which saves a point to be scrolled to
	// after line validation.
	ScrollToIter(iter *TextIter, withinMargin float64, useAlign bool, xalign float64, yalign float64) bool
	// ScrollToMark: scrolls @text_view so that @mark is on the screen in the
	// position indicated by @xalign and @yalign. An alignment of 0.0 indicates
	// left or top, 1.0 indicates right or bottom, 0.5 means center. If
	// @use_align is false, the text scrolls the minimal distance to get the
	// mark onscreen, possibly not scrolling at all. The effective screen for
	// purposes of this function is reduced by a margin of size @within_margin.
	ScrollToMark(mark TextMark, withinMargin float64, useAlign bool, xalign float64, yalign float64)
	// SetAcceptsTab: sets the behavior of the text widget when the Tab key is
	// pressed. If @accepts_tab is true, a tab character is inserted. If
	// @accepts_tab is false the keyboard focus is moved to the next widget in
	// the focus chain.
	SetAcceptsTab(acceptsTab bool)
	// SetBottomMargin: sets the bottom margin for text in @text_view.
	//
	// Note that this function is confusingly named. In CSS terms, the value set
	// here is padding.
	SetBottomMargin(bottomMargin int)
	// SetBuffer: sets @buffer as the buffer being displayed by @text_view. The
	// previous buffer displayed by the text view is unreferenced, and a
	// reference is added to @buffer. If you owned a reference to @buffer before
	// passing it to this function, you must remove that reference yourself;
	// TextView will not “adopt” it.
	SetBuffer(buffer TextBuffer)
	// SetCursorVisible: toggles whether the insertion point should be
	// displayed. A buffer with no editable text probably shouldn’t have a
	// visible cursor, so you may want to turn the cursor off.
	//
	// Note that this property may be overridden by the
	// Settings:gtk-keynav-use-caret settings.
	SetCursorVisible(setting bool)
	// SetEditable: sets the default editability of the TextView. You can
	// override this default setting with tags in the buffer, using the
	// “editable” attribute of tags.
	SetEditable(setting bool)
	// SetExtraMenu: sets a menu model to add when constructing the context menu
	// for @text_view. You can pass nil to remove a previously set extra menu.
	SetExtraMenu(model gio.MenuModel)
	// SetGutter: places @widget into the gutter specified by @win.
	//
	// @win must be one of GTK_TEXT_WINDOW_LEFT, GTK_TEXT_WINDOW_RIGHT,
	// GTK_TEXT_WINDOW_TOP, or GTK_TEXT_WINDOW_BOTTOM.
	SetGutter(win TextWindowType, widget Widget)
	// SetIndent: sets the default indentation for paragraphs in @text_view.
	// Tags in the buffer may override the default.
	SetIndent(indent int)
	// SetInputHints: sets the TextView:input-hints property, which allows input
	// methods to fine-tune their behaviour.
	SetInputHints(hints InputHints)
	// SetInputPurpose: sets the TextView:input-purpose property which can be
	// used by on-screen keyboards and other input methods to adjust their
	// behaviour.
	SetInputPurpose(purpose InputPurpose)
	// SetJustification: sets the default justification of text in @text_view.
	// Tags in the view’s buffer may override the default.
	SetJustification(justification Justification)
	// SetLeftMargin: sets the default left margin for text in @text_view. Tags
	// in the buffer may override the default.
	//
	// Note that this function is confusingly named. In CSS terms, the value set
	// here is padding.
	SetLeftMargin(leftMargin int)
	// SetMonospace: sets the TextView:monospace property, which indicates that
	// the text view should use monospace fonts.
	SetMonospace(monospace bool)
	// SetOverwrite: changes the TextView overwrite mode.
	SetOverwrite(overwrite bool)
	// SetPixelsAboveLines: sets the default number of blank pixels above
	// paragraphs in @text_view. Tags in the buffer for @text_view may override
	// the defaults.
	SetPixelsAboveLines(pixelsAboveLines int)
	// SetPixelsBelowLines: sets the default number of pixels of blank space to
	// put below paragraphs in @text_view. May be overridden by tags applied to
	// @text_view’s buffer.
	SetPixelsBelowLines(pixelsBelowLines int)
	// SetPixelsInsideWrap: sets the default number of pixels of blank space to
	// leave between display/wrapped lines within a paragraph. May be overridden
	// by tags in @text_view’s buffer.
	SetPixelsInsideWrap(pixelsInsideWrap int)
	// SetRightMargin: sets the default right margin for text in the text view.
	// Tags in the buffer may override the default.
	//
	// Note that this function is confusingly named. In CSS terms, the value set
	// here is padding.
	SetRightMargin(rightMargin int)
	// SetTabs: sets the default tab stops for paragraphs in @text_view. Tags in
	// the buffer may override the default.
	SetTabs(tabs *pango.TabArray)
	// SetTopMargin: sets the top margin for text in @text_view.
	//
	// Note that this function is confusingly named. In CSS terms, the value set
	// here is padding.
	SetTopMargin(topMargin int)
	// SetWrapMode: sets the line wrapping for the view.
	SetWrapMode(wrapMode WrapMode)
	// StartsDisplayLine: determines whether @iter is at the start of a display
	// line. See gtk_text_view_forward_display_line() for an explanation of
	// display lines vs. paragraphs.
	StartsDisplayLine(iter *TextIter) bool
	// WindowToBufferCoords: converts coordinates on the window identified by
	// @win to buffer coordinates, storing the result in (@buffer_x,@buffer_y).
	WindowToBufferCoords(win TextWindowType, windowX int, windowY int) (bufferX int, bufferY int)
}

type textView struct {
	widget
}

func wrapTextView(obj *externglib.Object) TextView {
	return textView{widget{externglib.InitiallyUnowned{obj}}}
}

func marshalTextView(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewTextView() TextView

func NewTextView(buffer TextBuffer) TextView

func (t textView) AddChildAtAnchor(child Widget, anchor TextChildAnchor)

func (t textView) AddOverlay(child Widget, xpos int, ypos int)

func (t textView) BackwardDisplayLine(iter *TextIter) bool

func (t textView) BackwardDisplayLineStart(iter *TextIter) bool

func (t textView) BufferToWindowCoords(win TextWindowType, bufferX int, bufferY int) (windowX int, windowY int)

func (t textView) ForwardDisplayLine(iter *TextIter) bool

func (t textView) ForwardDisplayLineEnd(iter *TextIter) bool

func (t textView) AcceptsTab() bool

func (t textView) BottomMargin() int

func (t textView) Buffer() TextBuffer

func (t textView) CursorLocations(iter *TextIter) (strong gdk.Rectangle, weak gdk.Rectangle)

func (t textView) CursorVisible() bool

func (t textView) Editable() bool

func (t textView) ExtraMenu() gio.MenuModel

func (t textView) Gutter(win TextWindowType) Widget

func (t textView) Indent() int

func (t textView) InputHints() InputHints

func (t textView) InputPurpose() InputPurpose

func (t textView) IterAtLocation(x int, y int) (iter TextIter, ok bool)

func (t textView) IterAtPosition(x int, y int) (iter TextIter, trailing int, ok bool)

func (t textView) IterLocation(iter *TextIter) gdk.Rectangle

func (t textView) Justification() Justification

func (t textView) LeftMargin() int

func (t textView) LineAtY(y int) (targetIter TextIter, lineTop int)

func (t textView) LineYrange(iter *TextIter) (y int, height int)

func (t textView) Monospace() bool

func (t textView) Overwrite() bool

func (t textView) PixelsAboveLines() int

func (t textView) PixelsBelowLines() int

func (t textView) PixelsInsideWrap() int

func (t textView) RightMargin() int

func (t textView) Tabs() *pango.TabArray

func (t textView) TopMargin() int

func (t textView) VisibleRect() gdk.Rectangle

func (t textView) WrapMode() WrapMode

func (t textView) ImContextFilterKeypress(event gdk.Event) bool

func (t textView) MoveMarkOnscreen(mark TextMark) bool

func (t textView) MoveOverlay(child Widget, xpos int, ypos int)

func (t textView) MoveVisually(iter *TextIter, count int) bool

func (t textView) PlaceCursorOnscreen() bool

func (t textView) Remove(child Widget)

func (t textView) ResetCursorBlink()

func (t textView) ResetImContext()

func (t textView) ScrollMarkOnscreen(mark TextMark)

func (t textView) ScrollToIter(iter *TextIter, withinMargin float64, useAlign bool, xalign float64, yalign float64) bool

func (t textView) ScrollToMark(mark TextMark, withinMargin float64, useAlign bool, xalign float64, yalign float64)

func (t textView) SetAcceptsTab(acceptsTab bool)

func (t textView) SetBottomMargin(bottomMargin int)

func (t textView) SetBuffer(buffer TextBuffer)

func (t textView) SetCursorVisible(setting bool)

func (t textView) SetEditable(setting bool)

func (t textView) SetExtraMenu(model gio.MenuModel)

func (t textView) SetGutter(win TextWindowType, widget Widget)

func (t textView) SetIndent(indent int)

func (t textView) SetInputHints(hints InputHints)

func (t textView) SetInputPurpose(purpose InputPurpose)

func (t textView) SetJustification(justification Justification)

func (t textView) SetLeftMargin(leftMargin int)

func (t textView) SetMonospace(monospace bool)

func (t textView) SetOverwrite(overwrite bool)

func (t textView) SetPixelsAboveLines(pixelsAboveLines int)

func (t textView) SetPixelsBelowLines(pixelsBelowLines int)

func (t textView) SetPixelsInsideWrap(pixelsInsideWrap int)

func (t textView) SetRightMargin(rightMargin int)

func (t textView) SetTabs(tabs *pango.TabArray)

func (t textView) SetTopMargin(topMargin int)

func (t textView) SetWrapMode(wrapMode WrapMode)

func (t textView) StartsDisplayLine(iter *TextIter) bool

func (t textView) WindowToBufferCoords(win TextWindowType, windowX int, windowY int) (bufferX int, bufferY int)

// ToggleButton: a ToggleButton is a Button which will remain “pressed-in” when
// clicked. Clicking again will cause the toggle button to return to its normal
// state.
//
// A toggle button is created by calling either gtk_toggle_button_new() or
// gtk_toggle_button_new_with_label(). If using the former, it is advisable to
// pack a widget, (such as a Label and/or a Image), into the toggle button’s
// container. (See Button for more information).
//
// The state of a ToggleButton can be set specifically using
// gtk_toggle_button_set_active(), and retrieved using
// gtk_toggle_button_get_active().
//
// To simply switch the state of a toggle button, use
// gtk_toggle_button_toggled().
//
//
// CSS nodes
//
// GtkToggleButton has a single CSS node with name button. To differentiate it
// from a plain Button, it gets the .toggle style class.
//
// Creating two ToggleButton widgets
//
//    static void output_state (GtkToggleButton *source, gpointer user_data) {
//      printf ("Active: d\n", gtk_toggle_button_get_active (source));
//    }
//
//    void make_toggles (void) {
//      GtkWidget *window, *toggle1, *toggle2;
//      GtkWidget *box;
//      const char *text;
//
//      window = gtk_window_new ();
//      box = gtk_box_new (GTK_ORIENTATION_VERTICAL, 12);
//
//      text = "Hi, I’m a toggle button.";
//      toggle1 = gtk_toggle_button_new_with_label (text);
//
//      g_signal_connect (toggle1, "toggled",
//                        G_CALLBACK (output_state),
//                        NULL);
//      gtk_box_append (GTK_BOX (box), toggle1);
//
//      text = "Hi, I’m a toggle button.";
//      toggle2 = gtk_toggle_button_new_with_label (text);
//      g_signal_connect (toggle2, "toggled",
//                        G_CALLBACK (output_state),
//                        NULL);
//      gtk_box_append (GTK_BOX (box), toggle2);
//
//      gtk_window_set_child (GTK_WINDOW (window), box);
//      gtk_widget_show (window);
//    }
//
type ToggleButton interface {
	Button

	// Active: queries a ToggleButton and returns its current state. Returns
	// true if the toggle button is pressed in and false if it is raised.
	Active() bool
	// SetActive: sets the status of the toggle button. Set to true if you want
	// the GtkToggleButton to be “pressed in”, and false to raise it.
	//
	// If the status of the button changes, this action causes the
	// ToggleButton::toggled signal to be emitted.
	SetActive(isActive bool)
	// SetGroup: adds @self to the group of @group. In a group of multiple
	// toggle buttons, only one button can be active at a time.
	//
	// Note that the same effect can be achieved via the Actionable api, by
	// using the same action with parameter type and state type 's' for all
	// buttons in the group, and giving each button its own target value.
	SetGroup(group ToggleButton)
	// Toggled: emits the ToggleButton::toggled signal on the ToggleButton.
	// There is no good reason for an application ever to call this function.
	Toggled()
}

type toggleButton struct {
	button
}

func wrapToggleButton(obj *externglib.Object) ToggleButton {
	return toggleButton{button{widget{externglib.InitiallyUnowned{obj}}}}
}

func marshalToggleButton(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewToggleButton() ToggleButton

func NewToggleButton(label string) ToggleButton

func NewToggleButton(label string) ToggleButton

func (t toggleButton) Active() bool

func (t toggleButton) SetActive(isActive bool)

func (t toggleButton) SetGroup(group ToggleButton)

func (t toggleButton) Toggled()

// Tooltip: basic tooltips can be realized simply by using
// gtk_widget_set_tooltip_text() or gtk_widget_set_tooltip_markup() without any
// explicit tooltip object.
//
// When you need a tooltip with a little more fancy contents, like adding an
// image, or you want the tooltip to have different contents per TreeView row or
// cell, you will have to do a little more work:
//
// - Set the Widget:has-tooltip property to true, this will make GTK monitor the
// widget for motion and related events which are needed to determine when and
// where to show a tooltip.
//
// - Connect to the Widget::query-tooltip signal. This signal will be emitted
// when a tooltip is supposed to be shown. One of the arguments passed to the
// signal handler is a GtkTooltip object. This is the object that we are about
// to display as a tooltip, and can be manipulated in your callback using
// functions like gtk_tooltip_set_icon(). There are functions for setting the
// tooltip’s markup, setting an image from a named icon, or even putting in a
// custom widget.
//
// Return true from your query-tooltip handler. This causes the tooltip to be
// show. If you return false, it will not be shown.
type Tooltip interface {
	gextras.Objector

	// SetCustom: replaces the widget packed into the tooltip with
	// @custom_widget. @custom_widget does not get destroyed when the tooltip
	// goes away. By default a box with a Image and Label is embedded in the
	// tooltip, which can be configured using gtk_tooltip_set_markup() and
	// gtk_tooltip_set_icon().
	SetCustom(customWidget Widget)
	// SetIcon: sets the icon of the tooltip (which is in front of the text) to
	// be @paintable. If @paintable is nil, the image will be hidden.
	SetIcon(paintable gdk.Paintable)
	// SetIconFromGicon: sets the icon of the tooltip (which is in front of the
	// text) to be the icon indicated by @gicon with the size indicated by
	// @size. If @gicon is nil, the image will be hidden.
	SetIconFromGicon(gicon gio.Icon)
	// SetIconFromIconName: sets the icon of the tooltip (which is in front of
	// the text) to be the icon indicated by @icon_name with the size indicated
	// by @size. If @icon_name is nil, the image will be hidden.
	SetIconFromIconName(iconName string)
	// SetMarkup: sets the text of the tooltip to be @markup, which is marked up
	// with the [Pango text markup language][PangoMarkupFormat]. If @markup is
	// nil, the label will be hidden.
	SetMarkup(markup string)
	// SetText: sets the text of the tooltip to be @text. If @text is nil, the
	// label will be hidden. See also gtk_tooltip_set_markup().
	SetText(text string)
	// SetTipArea: sets the area of the widget, where the contents of this
	// tooltip apply, to be @rect (in widget coordinates). This is especially
	// useful for properly setting tooltips on TreeView rows and cells,
	// IconViews, etc.
	//
	// For setting tooltips on TreeView, please refer to the convenience
	// functions for this: gtk_tree_view_set_tooltip_row() and
	// gtk_tree_view_set_tooltip_cell().
	SetTipArea(rect *gdk.Rectangle)
}

type tooltip struct {
	*externglib.Object
}

func wrapTooltip(obj *externglib.Object) Tooltip {
	return tooltip{*externglib.Object{obj}}
}

func marshalTooltip(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func (t tooltip) SetCustom(customWidget Widget)

func (t tooltip) SetIcon(paintable gdk.Paintable)

func (t tooltip) SetIconFromGicon(gicon gio.Icon)

func (t tooltip) SetIconFromIconName(iconName string)

func (t tooltip) SetMarkup(markup string)

func (t tooltip) SetText(text string)

func (t tooltip) SetTipArea(rect *gdk.Rectangle)

// TreeExpander: gtkTreeExpander is a widget that provides an expander for a
// list.
//
// It is typically placed as a bottommost child into a ListView to allow users
// to expand and collapse children in a list with a TreeListModel. It will
// provide the common UI elements, gestures and keybindings for this purpose.
//
// On top of this, the "listitem.expand", "listitem.collapse" and
// "listitem.toggle-expand" actions are provided to allow adding custom UI for
// managing expanded state.
//
// The TreeListModel must be set to not be passthrough. Then it will provide
// TreeListRow items which can be set via gtk_tree_expander_set_list_row() on
// the expander. The expander will then watch that row item automatically.
// gtk_tree_expander_set_child() sets the widget that displays the actual row
// contents.
//
// CSS nodes
//
//    treeexpander
//    ├── [indent]*
//    ├── [expander]
//    ╰── <child>
//
// GtkTreeExpander has zero or one CSS nodes with the name "expander" that
// should display the expander icon. The node will be `:checked` when it is
// expanded. If the node is not expandable, an "indent" node will be displayed
// instead.
//
// For every level of depth, another "indent" node is prepended.
//
//
// Accessibility
//
// GtkTreeExpander uses the GTK_ACCESSIBLE_ROLE_GROUP role. The expander icon is
// represented as a GTK_ACCESSIBLE_ROLE_BUTTON, labelled by the expander's
// child, and toggling it will change the GTK_ACCESSIBLE_STATE_EXPANDED state.
type TreeExpander interface {
	Widget

	// Child: gets the child widget displayed by @self.
	Child() Widget
	// Item: forwards the item set on the TreeListRow that @self is managing.
	//
	// This call is essentially equivalent to calling:
	//
	//    gtk_tree_list_row_get_item (gtk_tree_expander_get_list_row (@self));
	Item() interface{}
	// ListRow: gets the list row managed by @self.
	ListRow() TreeListRow
	// SetChild: sets the content widget to display.
	SetChild(child Widget)
	// SetListRow: sets the tree list row that this expander should manage.
	SetListRow(listRow TreeListRow)
}

type treeExpander struct {
	widget
}

func wrapTreeExpander(obj *externglib.Object) TreeExpander {
	return treeExpander{widget{externglib.InitiallyUnowned{obj}}}
}

func marshalTreeExpander(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewTreeExpander() TreeExpander

func (t treeExpander) Child() Widget

func (t treeExpander) Item() interface{}

func (t treeExpander) ListRow() TreeListRow

func (t treeExpander) SetChild(child Widget)

func (t treeExpander) SetListRow(listRow TreeListRow)

// TreeListModel is a Model implementation that can expand rows by creating new
// child list models on demand.
type TreeListModel interface {
	gextras.Objector

	// Autoexpand: gets whether the model is set to automatically expand new
	// rows that get added. This can be either rows added by changes to the
	// underlying models or via gtk_tree_list_row_set_expanded().
	Autoexpand() bool
	// ChildRow: gets the row item corresponding to the child at index @position
	// for @self's root model.
	//
	// If @position is greater than the number of children in the root model,
	// nil is returned.
	//
	// Do not confuse this function with gtk_tree_list_model_get_row().
	ChildRow(position uint) TreeListRow
	// Model: gets the root model that @self was created with.
	Model() gio.ListModel
	// Passthrough: if this function returns false, the Model functions for
	// @self return custom TreeListRow objects. You need to call
	// gtk_tree_list_row_get_item() on these objects to get the original item.
	//
	// If true, the values of the child models are passed through in their
	// original state. You then need to call gtk_tree_list_model_get_row() to
	// get the custom TreeListRows.
	Passthrough() bool
	// Row: gets the row object for the given row. If @position is greater than
	// the number of items in @self, nil is returned.
	//
	// The row object can be used to expand and collapse rows as well as to
	// inspect its position in the tree. See its documentation for details.
	//
	// This row object is persistent and will refer to the current item as long
	// as the row is present in @self, independent of other rows being added or
	// removed.
	//
	// If @self is set to not be passthrough, this function is equivalent to
	// calling g_list_model_get_item().
	//
	// Do not confuse this function with gtk_tree_list_model_get_child_row().
	Row(position uint) TreeListRow
	// SetAutoexpand: if set to true, the model will recursively expand all rows
	// that get added to the model. This can be either rows added by changes to
	// the underlying models or via gtk_tree_list_row_set_expanded().
	SetAutoexpand(autoexpand bool)
}

type treeListModel struct {
	*externglib.Object
}

func wrapTreeListModel(obj *externglib.Object) TreeListModel {
	return treeListModel{*externglib.Object{obj}}
}

func marshalTreeListModel(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewTreeListModel(root gio.ListModel, passthrough bool, autoexpand bool, createFunc TreeListModelCreateModelFunc) TreeListModel

func (t treeListModel) Autoexpand() bool

func (t treeListModel) ChildRow(position uint) TreeListRow

func (t treeListModel) Model() gio.ListModel

func (t treeListModel) Passthrough() bool

func (t treeListModel) Row(position uint) TreeListRow

func (t treeListModel) SetAutoexpand(autoexpand bool)

// TreeListRow is the object used by TreeListModel to represent items. It allows
// navigating the model as a tree and modify the state of rows.
//
// TreeListRow instances are created by a TreeListModel only when the
// TreeListModel:passthrough property is not set.
//
// There are various support objects that can make use of TreeListRow objects,
// such as the TreeExpander widget that allows displaying an icon to expand or
// collapse a row or TreeListRowSorter that makes it possible to sort trees
// properly.
type TreeListRow interface {
	gextras.Objector

	// ChildRow: if @self is not expanded or @position is greater than the
	// number of children, nil is returned.
	ChildRow(position uint) TreeListRow
	// Children: if the row is expanded, gets the model holding the children of
	// @self.
	//
	// This model is the model created by the TreeListModelCreateModelFunc and
	// contains the original items, no matter what value
	// TreeListModel:passthrough is set to.
	Children() gio.ListModel
	// Depth: gets the depth of this row. Rows that correspond to items in the
	// root model have a depth of zero, rows corresponding to items of models of
	// direct children of the root model have a depth of 1 and so on.
	//
	// The depth of a row never changes until the row is destroyed.
	Depth() uint
	// Expanded: gets if a row is currently expanded.
	Expanded() bool
	// Item: gets the item corresponding to this row,
	//
	// The value returned by this function never changes until the row is
	// destroyed.
	Item() interface{}
	// Parent: gets the row representing the parent for @self. That is the row
	// that would need to be collapsed to make this row disappear.
	//
	// If @self is a row corresponding to the root model, nil is returned.
	//
	// The value returned by this function never changes until the row is
	// destroyed.
	Parent() TreeListRow
	// Position: returns the position in the TreeListModel that @self occupies
	// at the moment.
	Position() uint
	// IsExpandable: checks if a row can be expanded. This does not mean that
	// the row is actually expanded, this can be checked with
	// gtk_tree_list_row_get_expanded()
	//
	// If a row is expandable never changes until the row is destroyed.
	IsExpandable() bool
	// SetExpanded: expands or collapses a row.
	//
	// If a row is expanded, the model of calling the
	// TreeListModelCreateModelFunc for the row's item will be inserted after
	// this row. If a row is collapsed, those items will be removed from the
	// model.
	//
	// If the row is not expandable, this function does nothing.
	SetExpanded(expanded bool)
}

type treeListRow struct {
	*externglib.Object
}

func wrapTreeListRow(obj *externglib.Object) TreeListRow {
	return treeListRow{*externglib.Object{obj}}
}

func marshalTreeListRow(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func (t treeListRow) ChildRow(position uint) TreeListRow

func (t treeListRow) Children() gio.ListModel

func (t treeListRow) Depth() uint

func (t treeListRow) Expanded() bool

func (t treeListRow) Item() interface{}

func (t treeListRow) Parent() TreeListRow

func (t treeListRow) Position() uint

func (t treeListRow) IsExpandable() bool

func (t treeListRow) SetExpanded(expanded bool)

// TreeListRowSorter is a special-purpose sorter that will apply a given sorter
// to the levels in a tree, while respecting the tree structure.
//
// Here is an example for setting up a column view with a tree model and a
// GtkTreeListSorter:
//
//
//    column_sorter = gtk_column_view_get_sorter (view);
//    sorter = gtk_tree_list_row_sorter_new (g_object_ref (column_sorter));
//    sort_model = gtk_sort_list_model_new (tree_model, sorter);
//    selection = gtk_single_selection_new (sort_model);
//    gtk_column_view_set_model (view, G_LIST_MODEL (selection));
type TreeListRowSorter interface {
	Sorter

	// Sorter: returns the sorter used by @self.
	Sorter() Sorter
	// SetSorter: sets the sorter to use for items with the same parent.
	//
	// This sorter will be passed the TreeListRow:item of the tree list rows
	// passed to @self.
	SetSorter(sorter Sorter)
}

type treeListRowSorter struct {
	sorter
}

func wrapTreeListRowSorter(obj *externglib.Object) TreeListRowSorter {
	return treeListRowSorter{sorter{*externglib.Object{obj}}}
}

func marshalTreeListRowSorter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewTreeListRowSorter(sorter Sorter) TreeListRowSorter

func (t treeListRowSorter) Sorter() Sorter

func (t treeListRowSorter) SetSorter(sorter Sorter)

// TreeModelFilter: a TreeModelFilter is a tree model which wraps another tree
// model, and can do the following things:
//
// - Filter specific rows, based on data from a “visible column”, a column
// storing booleans indicating whether the row should be filtered or not, or
// based on the return value of a “visible function”, which gets a model, iter
// and user_data and returns a boolean indicating whether the row should be
// filtered or not.
//
// - Modify the “appearance” of the model, using a modify function. This is
// extremely powerful and allows for just changing some values and also for
// creating a completely different model based on the given child model.
//
// - Set a different root node, also known as a “virtual root”. You can pass in
// a TreePath indicating the root node for the filter at construction time.
//
// The basic API is similar to TreeModelSort. For an example on its usage, see
// the section on TreeModelSort.
//
// When using TreeModelFilter, it is important to realize that TreeModelFilter
// maintains an internal cache of all nodes which are visible in its clients.
// The cache is likely to be a subtree of the tree exposed by the child model.
// TreeModelFilter will not cache the entire child model when unnecessary to not
// compromise the caching mechanism that is exposed by the reference counting
// scheme. If the child model implements reference counting, unnecessary signals
// may not be emitted because of reference counting rule 3, see the TreeModel
// documentation. (Note that e.g. TreeStore does not implement reference
// counting and will always emit all signals, even when the receiving node is
// not visible).
//
// Because of this, limitations for possible visible functions do apply. In
// general, visible functions should only use data or properties from the node
// for which the visibility state must be determined, its siblings or its
// parents. Usually, having a dependency on the state of any child node is not
// possible, unless references are taken on these explicitly. When no such
// reference exists, no signals may be received for these child nodes (see
// reference counting rule number 3 in the TreeModel section).
//
// Determining the visibility state of a given node based on the state of its
// child nodes is a frequently occurring use case. Therefore, TreeModelFilter
// explicitly supports this. For example, when a node does not have any
// children, you might not want the node to be visible. As soon as the first row
// is added to the node’s child level (or the last row removed), the node’s
// visibility should be updated.
//
// This introduces a dependency from the node on its child nodes. In order to
// accommodate this, TreeModelFilter must make sure the necessary signals are
// received from the child model. This is achieved by building, for all nodes
// which are exposed as visible nodes to TreeModelFilter's clients, the child
// level (if any) and take a reference on the first node in this level.
// Furthermore, for every row-inserted, row-changed or row-deleted signal (also
// these which were not handled because the node was not cached),
// TreeModelFilter will check if the visibility state of any parent node has
// changed.
//
// Beware, however, that this explicit support is limited to these two cases.
// For example, if you want a node to be visible only if two nodes in a child’s
// child level (2 levels deeper) are visible, you are on your own. In this case,
// either rely on TreeStore to emit all signals because it does not implement
// reference counting, or for models that do implement reference counting,
// obtain references on these child levels yourself.
type TreeModelFilter interface {
	gextras.Objector

	// ClearCache: this function should almost never be called. It clears the
	// @filter of any cached iterators that haven’t been reffed with
	// gtk_tree_model_ref_node(). This might be useful if the child model being
	// filtered is static (and doesn’t change often) and there has been a lot of
	// unreffed access to nodes. As a side effect of this function, all unreffed
	// iters will be invalid.
	ClearCache()
	// ConvertChildIterToIter: sets @filter_iter to point to the row in @filter
	// that corresponds to the row pointed at by @child_iter. If @filter_iter
	// was not set, false is returned.
	ConvertChildIterToIter(childIter *TreeIter) (filterIter TreeIter, ok bool)
	// ConvertChildPathToPath: converts @child_path to a path relative to
	// @filter. That is, @child_path points to a path in the child model. The
	// rerturned path will point to the same row in the filtered model. If
	// @child_path isn’t a valid path on the child model or points to a row
	// which is not visible in @filter, then nil is returned.
	ConvertChildPathToPath(childPath *TreePath) *TreePath
	// ConvertIterToChildIter: sets @child_iter to point to the row pointed to
	// by @filter_iter.
	ConvertIterToChildIter(filterIter *TreeIter) TreeIter
	// ConvertPathToChildPath: converts @filter_path to a path on the child
	// model of @filter. That is, @filter_path points to a location in @filter.
	// The returned path will point to the same location in the model not being
	// filtered. If @filter_path does not point to a location in the child
	// model, nil is returned.
	ConvertPathToChildPath(filterPath *TreePath) *TreePath
	// Model: returns a pointer to the child model of @filter.
	Model() TreeModel
	// Refilter: emits ::row_changed for each row in the child model, which
	// causes the filter to re-evaluate whether a row is visible or not.
	Refilter()
	// SetModifyFunc: with the @n_columns and @types parameters, you give an
	// array of column types for this model (which will be exposed to the parent
	// model/view). The @func, @data and @destroy parameters are for specifying
	// the modify function. The modify function will get called for each data
	// access, the goal of the modify function is to return the data which
	// should be displayed at the location specified using the parameters of the
	// modify function.
	//
	// Note that gtk_tree_model_filter_set_modify_func() can only be called once
	// for a given filter model.
	SetModifyFunc(nColumns int, types []externglib.Type, _func TreeModelFilterModifyFunc)
	// SetVisibleColumn: sets @column of the child_model to be the column where
	// @filter should look for visibility information. @columns should be a
	// column of type G_TYPE_BOOLEAN, where true means that a row is visible,
	// and false if not.
	//
	// Note that gtk_tree_model_filter_set_visible_func() or
	// gtk_tree_model_filter_set_visible_column() can only be called once for a
	// given filter model.
	SetVisibleColumn(column int)
	// SetVisibleFunc: sets the visible function used when filtering the @filter
	// to be @func. The function should return true if the given row should be
	// visible and false otherwise.
	//
	// If the condition calculated by the function changes over time (e.g.
	// because it depends on some global parameters), you must call
	// gtk_tree_model_filter_refilter() to keep the visibility information of
	// the model up-to-date.
	//
	// Note that @func is called whenever a row is inserted, when it may still
	// be empty. The visible function should therefore take special care of
	// empty rows, like in the example below.
	//
	//    static gboolean
	//    visible_func (GtkTreeModel *model,
	//                  GtkTreeIter  *iter,
	//                  gpointer      data)
	//    {
	//      // Visible if row is non-empty and first column is “HI”
	//      char *str;
	//      gboolean visible = FALSE;
	//
	//      gtk_tree_model_get (model, iter, 0, &str, -1);
	//      if (str && strcmp (str, "HI") == 0)
	//        visible = TRUE;
	//      g_free (str);
	//
	//      return visible;
	//    }
	//
	//
	// Note that gtk_tree_model_filter_set_visible_func() or
	// gtk_tree_model_filter_set_visible_column() can only be called once for a
	// given filter model.
	SetVisibleFunc(_func TreeModelFilterVisibleFunc)
}

type treeModelFilter struct {
	*externglib.Object
}

func wrapTreeModelFilter(obj *externglib.Object) TreeModelFilter {
	return treeModelFilter{*externglib.Object{obj}}
}

func marshalTreeModelFilter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func (t treeModelFilter) ClearCache()

func (t treeModelFilter) ConvertChildIterToIter(childIter *TreeIter) (filterIter TreeIter, ok bool)

func (t treeModelFilter) ConvertChildPathToPath(childPath *TreePath) *TreePath

func (t treeModelFilter) ConvertIterToChildIter(filterIter *TreeIter) TreeIter

func (t treeModelFilter) ConvertPathToChildPath(filterPath *TreePath) *TreePath

func (t treeModelFilter) Model() TreeModel

func (t treeModelFilter) Refilter()

func (t treeModelFilter) SetModifyFunc(nColumns int, types []externglib.Type, _func TreeModelFilterModifyFunc)

func (t treeModelFilter) SetVisibleColumn(column int)

func (t treeModelFilter) SetVisibleFunc(_func TreeModelFilterVisibleFunc)

// TreeModelSort: the TreeModelSort is a model which implements the TreeSortable
// interface. It does not hold any data itself, but rather is created with a
// child model and proxies its data. It has identical column types to this child
// model, and the changes in the child are propagated. The primary purpose of
// this model is to provide a way to sort a different model without modifying
// it. Note that the sort function used by TreeModelSort is not guaranteed to be
// stable.
//
// The use of this is best demonstrated through an example. In the following
// sample code we create two TreeView widgets each with a view of the same data.
// As the model is wrapped here by a TreeModelSort, the two TreeViews can each
// sort their view of the data without affecting the other. By contrast, if we
// simply put the same model in each widget, then sorting the first would sort
// the second.
//
// Using a TreeModelSort
//
//    {
//      GtkTreeView *tree_view1;
//      GtkTreeView *tree_view2;
//      GtkTreeModel *sort_model1;
//      GtkTreeModel *sort_model2;
//      GtkTreeModel *child_model;
//
//      // get the child model
//      child_model = get_my_model ();
//
//      // Create the first tree
//      sort_model1 = gtk_tree_model_sort_new_with_model (child_model);
//      tree_view1 = gtk_tree_view_new_with_model (sort_model1);
//
//      // Create the second tree
//      sort_model2 = gtk_tree_model_sort_new_with_model (child_model);
//      tree_view2 = gtk_tree_view_new_with_model (sort_model2);
//
//      // Now we can sort the two models independently
//      gtk_tree_sortable_set_sort_column_id (GTK_TREE_SORTABLE (sort_model1),
//                                            COLUMN_1, GTK_SORT_ASCENDING);
//      gtk_tree_sortable_set_sort_column_id (GTK_TREE_SORTABLE (sort_model2),
//                                            COLUMN_1, GTK_SORT_DESCENDING);
//    }
//
//
// To demonstrate how to access the underlying child model from the sort model,
// the next example will be a callback for the TreeSelection
// TreeSelection::changed signal. In this callback, we get a string from
// COLUMN_1 of the model. We then modify the string, find the same selected row
// on the child model, and change the row there.
//
// Accessing the child model of in a selection changed callback
//
//    void
//    selection_changed (GtkTreeSelection *selection, gpointer data)
//    {
//      GtkTreeModel *sort_model = NULL;
//      GtkTreeModel *child_model;
//      GtkTreeIter sort_iter;
//      GtkTreeIter child_iter;
//      char *some_data = NULL;
//      char *modified_data;
//
//      // Get the current selected row and the model.
//      if (! gtk_tree_selection_get_selected (selection,
//                                             &sort_model,
//                                             &sort_iter))
//        return;
//
//      // Look up the current value on the selected row and get
//      // a new value to change it to.
//      gtk_tree_model_get (GTK_TREE_MODEL (sort_model), &sort_iter,
//                          COLUMN_1, &some_data,
//                          -1);
//
//      modified_data = change_the_data (some_data);
//      g_free (some_data);
//
//      // Get an iterator on the child model, instead of the sort model.
//      gtk_tree_model_sort_convert_iter_to_child_iter (GTK_TREE_MODEL_SORT (sort_model),
//                                                      &child_iter,
//                                                      &sort_iter);
//
//      // Get the child model and change the value of the row. In this
//      // example, the child model is a GtkListStore. It could be any other
//      // type of model, though.
//      child_model = gtk_tree_model_sort_get_model (GTK_TREE_MODEL_SORT (sort_model));
//      gtk_list_store_set (GTK_LIST_STORE (child_model), &child_iter,
//                          COLUMN_1, &modified_data,
//                          -1);
//      g_free (modified_data);
//    }
//
type TreeModelSort interface {
	gextras.Objector

	// ClearCache: this function should almost never be called. It clears the
	// @tree_model_sort of any cached iterators that haven’t been reffed with
	// gtk_tree_model_ref_node(). This might be useful if the child model being
	// sorted is static (and doesn’t change often) and there has been a lot of
	// unreffed access to nodes. As a side effect of this function, all unreffed
	// iters will be invalid.
	ClearCache()
	// ConvertChildIterToIter: sets @sort_iter to point to the row in
	// @tree_model_sort that corresponds to the row pointed at by @child_iter.
	// If @sort_iter was not set, false is returned. Note: a boolean is only
	// returned since 2.14.
	ConvertChildIterToIter(childIter *TreeIter) (sortIter TreeIter, ok bool)
	// ConvertChildPathToPath: converts @child_path to a path relative to
	// @tree_model_sort. That is, @child_path points to a path in the child
	// model. The returned path will point to the same row in the sorted model.
	// If @child_path isn’t a valid path on the child model, then nil is
	// returned.
	ConvertChildPathToPath(childPath *TreePath) *TreePath
	// ConvertIterToChildIter: sets @child_iter to point to the row pointed to
	// by @sorted_iter.
	ConvertIterToChildIter(sortedIter *TreeIter) TreeIter
	// ConvertPathToChildPath: converts @sorted_path to a path on the child
	// model of @tree_model_sort. That is, @sorted_path points to a location in
	// @tree_model_sort. The returned path will point to the same location in
	// the model not being sorted. If @sorted_path does not point to a location
	// in the child model, nil is returned.
	ConvertPathToChildPath(sortedPath *TreePath) *TreePath
	// Model: returns the model the TreeModelSort is sorting.
	Model() TreeModel
	// IterIsValid: > This function is slow. Only use it for debugging and/or
	// testing > purposes.
	//
	// Checks if the given iter is a valid iter for this TreeModelSort.
	IterIsValid(iter *TreeIter) bool
	// ResetDefaultSortFunc: this resets the default sort function to be in the
	// “unsorted” state. That is, it is in the same order as the child model. It
	// will re-sort the model to be in the same order as the child model only if
	// the TreeModelSort is in “unsorted” state.
	ResetDefaultSortFunc()
}

type treeModelSort struct {
	*externglib.Object
}

func wrapTreeModelSort(obj *externglib.Object) TreeModelSort {
	return treeModelSort{*externglib.Object{obj}}
}

func marshalTreeModelSort(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewTreeModelSort(childModel TreeModel) TreeModelSort

func (t treeModelSort) ClearCache()

func (t treeModelSort) ConvertChildIterToIter(childIter *TreeIter) (sortIter TreeIter, ok bool)

func (t treeModelSort) ConvertChildPathToPath(childPath *TreePath) *TreePath

func (t treeModelSort) ConvertIterToChildIter(sortedIter *TreeIter) TreeIter

func (t treeModelSort) ConvertPathToChildPath(sortedPath *TreePath) *TreePath

func (t treeModelSort) Model() TreeModel

func (t treeModelSort) IterIsValid(iter *TreeIter) bool

func (t treeModelSort) ResetDefaultSortFunc()

// TreeSelection: the TreeSelection object is a helper object to manage the
// selection for a TreeView widget. The TreeSelection object is automatically
// created when a new TreeView widget is created, and cannot exist independently
// of this widget. The primary reason the TreeSelection objects exists is for
// cleanliness of code and API. That is, there is no conceptual reason all these
// functions could not be methods on the TreeView widget instead of a separate
// function.
//
// The TreeSelection object is gotten from a TreeView by calling
// gtk_tree_view_get_selection(). It can be manipulated to check the selection
// status of the tree, as well as select and deselect individual rows. Selection
// is done completely view side. As a result, multiple views of the same model
// can have completely different selections. Additionally, you cannot change the
// selection of a row on the model that is not currently displayed by the view
// without expanding its parents first.
//
// One of the important things to remember when monitoring the selection of a
// view is that the TreeSelection::changed signal is mostly a hint. That is, it
// may only emit one signal when a range of rows is selected. Additionally, it
// may on occasion emit a TreeSelection::changed signal when nothing has
// happened (mostly as a result of programmers calling select_row on an already
// selected row).
type TreeSelection interface {
	gextras.Objector

	// CountSelectedRows: returns the number of rows that have been selected in
	// @tree.
	CountSelectedRows() int
	// Mode: gets the selection mode for @selection. See
	// gtk_tree_selection_set_mode().
	Mode() SelectionMode
	// SelectFunction: returns the current selection function.
	SelectFunction() TreeSelectionFunc
	// Selected: sets @iter to the currently selected node if @selection is set
	// to K_SELECTION_SINGLE or K_SELECTION_BROWSE. @iter may be NULL if you
	// just want to test if @selection has any selected nodes. @model is filled
	// with the current model as a convenience. This function will not work if
	// you use @selection is K_SELECTION_MULTIPLE.
	Selected() (model TreeModel, iter TreeIter, ok bool)
	// SelectedRows: creates a list of path of all selected rows. Additionally,
	// if you are planning on modifying the model after calling this function,
	// you may want to convert the returned list into a list of
	// TreeRowReferences. To do this, you can use gtk_tree_row_reference_new().
	//
	//    g_list_free_full (list, (GDestroyNotify) gtk_tree_path_free);
	SelectedRows() (model TreeModel, list *glib.List)
	// TreeView: returns the tree view associated with @selection.
	TreeView() TreeView
	// UserData: returns the user data for the selection function.
	UserData() interface{}
	// IterIsSelected: returns true if the row at @iter is currently selected.
	IterIsSelected(iter *TreeIter) bool
	// PathIsSelected: returns true if the row pointed to by @path is currently
	// selected. If @path does not point to a valid location, false is returned
	PathIsSelected(path *TreePath) bool
	// SelectAll: selects all the nodes. @selection must be set to
	// K_SELECTION_MULTIPLE mode.
	SelectAll()
	// SelectIter: selects the specified iterator.
	SelectIter(iter *TreeIter)
	// SelectPath: select the row at @path.
	SelectPath(path *TreePath)
	// SelectRange: selects a range of nodes, determined by @start_path and
	// @end_path inclusive. @selection must be set to K_SELECTION_MULTIPLE mode.
	SelectRange(startPath *TreePath, endPath *TreePath)
	// SelectedForeach: calls a function for each selected node. Note that you
	// cannot modify the tree or selection from within this function. As a
	// result, gtk_tree_selection_get_selected_rows() might be more useful.
	SelectedForeach(_func TreeSelectionForeachFunc)
	// SetMode: sets the selection mode of the @selection. If the previous type
	// was K_SELECTION_MULTIPLE, then the anchor is kept selected, if it was
	// previously selected.
	SetMode(_type SelectionMode)
	// SetSelectFunction: sets the selection function.
	//
	// If set, this function is called before any node is selected or
	// unselected, giving some control over which nodes are selected. The select
	// function should return true if the state of the node may be toggled, and
	// false if the state of the node should be left unchanged.
	SetSelectFunction(_func TreeSelectionFunc)
	// UnselectAll: unselects all the nodes.
	UnselectAll()
	// UnselectIter: unselects the specified iterator.
	UnselectIter(iter *TreeIter)
	// UnselectPath: unselects the row at @path.
	UnselectPath(path *TreePath)
	// UnselectRange: unselects a range of nodes, determined by @start_path and
	// @end_path inclusive.
	UnselectRange(startPath *TreePath, endPath *TreePath)
}

type treeSelection struct {
	*externglib.Object
}

func wrapTreeSelection(obj *externglib.Object) TreeSelection {
	return treeSelection{*externglib.Object{obj}}
}

func marshalTreeSelection(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func (t treeSelection) CountSelectedRows() int

func (t treeSelection) Mode() SelectionMode

func (t treeSelection) SelectFunction() TreeSelectionFunc

func (t treeSelection) Selected() (model TreeModel, iter TreeIter, ok bool)

func (t treeSelection) SelectedRows() (model TreeModel, list *glib.List)

func (t treeSelection) TreeView() TreeView

func (t treeSelection) UserData() interface{}

func (t treeSelection) IterIsSelected(iter *TreeIter) bool

func (t treeSelection) PathIsSelected(path *TreePath) bool

func (t treeSelection) SelectAll()

func (t treeSelection) SelectIter(iter *TreeIter)

func (t treeSelection) SelectPath(path *TreePath)

func (t treeSelection) SelectRange(startPath *TreePath, endPath *TreePath)

func (t treeSelection) SelectedForeach(_func TreeSelectionForeachFunc)

func (t treeSelection) SetMode(_type SelectionMode)

func (t treeSelection) SetSelectFunction(_func TreeSelectionFunc)

func (t treeSelection) UnselectAll()

func (t treeSelection) UnselectIter(iter *TreeIter)

func (t treeSelection) UnselectPath(path *TreePath)

func (t treeSelection) UnselectRange(startPath *TreePath, endPath *TreePath)

// TreeStore: the TreeStore object is a list model for use with a TreeView
// widget. It implements the TreeModel interface, and consequently, can use all
// of the methods available there. It also implements the TreeSortable interface
// so it can be sorted by the view. Finally, it also implements the tree [drag
// and drop][gtk3-GtkTreeView-drag-and-drop] interfaces.
//
//
// GtkTreeStore as GtkBuildable
//
// The GtkTreeStore implementation of the Buildable interface allows to specify
// the model columns with a <columns> element that may contain multiple <column>
// elements, each specifying one model column. The “type” attribute specifies
// the data type for the column.
//
//
//    <object class="GtkTreeStore">
//      <columns>
//        <column type="gchararray"/>
//        <column type="gchararray"/>
//        <column type="gint"/>
//      </columns>
//    </object>
type TreeStore interface {
	gextras.Objector

	// Append: appends a new row to @tree_store. If @parent is non-nil, then it
	// will append the new row after the last child of @parent, otherwise it
	// will append a row to the top level. @iter will be changed to point to
	// this new row. The row will be empty after this function is called. To
	// fill in values, you need to call gtk_tree_store_set() or
	// gtk_tree_store_set_value().
	Append(parent *TreeIter) TreeIter
	// Clear: removes all rows from @tree_store
	Clear()
	// Insert: creates a new row at @position. If parent is non-nil, then the
	// row will be made a child of @parent. Otherwise, the row will be created
	// at the toplevel. If @position is -1 or is larger than the number of rows
	// at that level, then the new row will be inserted to the end of the list.
	// @iter will be changed to point to this new row. The row will be empty
	// after this function is called. To fill in values, you need to call
	// gtk_tree_store_set() or gtk_tree_store_set_value().
	Insert(parent *TreeIter, position int) TreeIter
	// InsertAfter: inserts a new row after @sibling. If @sibling is nil, then
	// the row will be prepended to @parent ’s children. If @parent and @sibling
	// are nil, then the row will be prepended to the toplevel. If both @sibling
	// and @parent are set, then @parent must be the parent of @sibling. When
	// @sibling is set, @parent is optional.
	//
	// @iter will be changed to point to this new row. The row will be empty
	// after this function is called. To fill in values, you need to call
	// gtk_tree_store_set() or gtk_tree_store_set_value().
	InsertAfter(parent *TreeIter, sibling *TreeIter) TreeIter
	// InsertBefore: inserts a new row before @sibling. If @sibling is nil, then
	// the row will be appended to @parent ’s children. If @parent and @sibling
	// are nil, then the row will be appended to the toplevel. If both @sibling
	// and @parent are set, then @parent must be the parent of @sibling. When
	// @sibling is set, @parent is optional.
	//
	// @iter will be changed to point to this new row. The row will be empty
	// after this function is called. To fill in values, you need to call
	// gtk_tree_store_set() or gtk_tree_store_set_value().
	InsertBefore(parent *TreeIter, sibling *TreeIter) TreeIter
	// InsertWithValuesv: a variant of gtk_tree_store_insert_with_values() which
	// takes the columns and values as two arrays, instead of varargs. This
	// function is mainly intended for language bindings.
	InsertWithValuesv(parent *TreeIter, position int, columns []int, values []*externglib.Value) TreeIter
	// IsAncestor: returns true if @iter is an ancestor of @descendant. That is,
	// @iter is the parent (or grandparent or great-grandparent) of @descendant.
	IsAncestor(iter *TreeIter, descendant *TreeIter) bool
	// IterDepth: returns the depth of @iter. This will be 0 for anything on the
	// root level, 1 for anything down a level, etc.
	IterDepth(iter *TreeIter) int
	// IterIsValid: WARNING: This function is slow. Only use it for debugging
	// and/or testing purposes.
	//
	// Checks if the given iter is a valid iter for this TreeStore.
	IterIsValid(iter *TreeIter) bool
	// MoveAfter: moves @iter in @tree_store to the position after @position.
	// @iter and @position should be in the same level. Note that this function
	// only works with unsorted stores. If @position is nil, @iter will be moved
	// to the start of the level.
	MoveAfter(iter *TreeIter, position *TreeIter)
	// MoveBefore: moves @iter in @tree_store to the position before @position.
	// @iter and @position should be in the same level. Note that this function
	// only works with unsorted stores. If @position is nil, @iter will be moved
	// to the end of the level.
	MoveBefore(iter *TreeIter, position *TreeIter)
	// Prepend: prepends a new row to @tree_store. If @parent is non-nil, then
	// it will prepend the new row before the first child of @parent, otherwise
	// it will prepend a row to the top level. @iter will be changed to point to
	// this new row. The row will be empty after this function is called. To
	// fill in values, you need to call gtk_tree_store_set() or
	// gtk_tree_store_set_value().
	Prepend(parent *TreeIter) TreeIter
	// Remove: removes @iter from @tree_store. After being removed, @iter is set
	// to the next valid row at that level, or invalidated if it previously
	// pointed to the last one.
	Remove(iter *TreeIter) bool
	// Reorder: reorders the children of @parent in @tree_store to follow the
	// order indicated by @new_order. Note that this function only works with
	// unsorted stores.
	Reorder(parent *TreeIter, newOrder []int)
	// SetColumnTypes: this function is meant primarily for #GObjects that
	// inherit from TreeStore, and should only be used when constructing a new
	// TreeStore. It will not function after a row has been added, or a method
	// on the TreeModel interface is called.
	SetColumnTypes(nColumns int, types []externglib.Type)
	// SetValue: sets the data in the cell specified by @iter and @column. The
	// type of @value must be convertible to the type of the column.
	SetValue(iter *TreeIter, column int, value *externglib.Value)
	// SetValuesv: a variant of gtk_tree_store_set_valist() which takes the
	// columns and values as two arrays, instead of varargs. This function is
	// mainly intended for language bindings or in case the number of columns to
	// change is not known until run-time.
	SetValuesv(iter *TreeIter, columns []int, values []*externglib.Value)
	// Swap: swaps @a and @b in the same level of @tree_store. Note that this
	// function only works with unsorted stores.
	Swap(a *TreeIter, b *TreeIter)
}

type treeStore struct {
	*externglib.Object
}

func wrapTreeStore(obj *externglib.Object) TreeStore {
	return treeStore{*externglib.Object{obj}}
}

func marshalTreeStore(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewTreeStore(nColumns int, types []externglib.Type) TreeStore

func (t treeStore) Append(parent *TreeIter) TreeIter

func (t treeStore) Clear()

func (t treeStore) Insert(parent *TreeIter, position int) TreeIter

func (t treeStore) InsertAfter(parent *TreeIter, sibling *TreeIter) TreeIter

func (t treeStore) InsertBefore(parent *TreeIter, sibling *TreeIter) TreeIter

func (t treeStore) InsertWithValuesv(parent *TreeIter, position int, columns []int, values []*externglib.Value) TreeIter

func (t treeStore) IsAncestor(iter *TreeIter, descendant *TreeIter) bool

func (t treeStore) IterDepth(iter *TreeIter) int

func (t treeStore) IterIsValid(iter *TreeIter) bool

func (t treeStore) MoveAfter(iter *TreeIter, position *TreeIter)

func (t treeStore) MoveBefore(iter *TreeIter, position *TreeIter)

func (t treeStore) Prepend(parent *TreeIter) TreeIter

func (t treeStore) Remove(iter *TreeIter) bool

func (t treeStore) Reorder(parent *TreeIter, newOrder []int)

func (t treeStore) SetColumnTypes(nColumns int, types []externglib.Type)

func (t treeStore) SetValue(iter *TreeIter, column int, value *externglib.Value)

func (t treeStore) SetValuesv(iter *TreeIter, columns []int, values []*externglib.Value)

func (t treeStore) Swap(a *TreeIter, b *TreeIter)

// TreeView: widget that displays any object that implements the TreeModel
// interface.
//
// Please refer to the [tree widget conceptual overview][TreeWidget] for an
// overview of all the objects and data types related to the tree widget and how
// they work together.
//
// Several different coordinate systems are exposed in the GtkTreeView API.
// These are:
//
// ![](tree-view-coordinates.png)
//
// Coordinate systems in GtkTreeView API:
//
// - Widget coordinates: Coordinates relative to the widget (usually
// `widget->window`).
//
// - Bin window coordinates: Coordinates relative to the window that GtkTreeView
// renders to.
//
// - Tree coordinates: Coordinates relative to the entire scrollable area of
// GtkTreeView. These coordinates start at (0, 0) for row 0 of the tree.
//
// Several functions are available for converting between the different
// coordinate systems. The most common translations are between widget and bin
// window coordinates and between bin window and tree coordinates. For the
// former you can use gtk_tree_view_convert_widget_to_bin_window_coords() (and
// vice versa), for the latter gtk_tree_view_convert_bin_window_to_tree_coords()
// (and vice versa).
//
//
// GtkTreeView as GtkBuildable
//
// The GtkTreeView implementation of the GtkBuildable interface accepts
// TreeViewColumn objects as <child> elements and exposes the internal
// TreeSelection in UI definitions.
//
//
//    <object class="GtkTreeView" id="treeview">
//      <property name="model">liststore1</property>
//      <child>
//        <object class="GtkTreeViewColumn" id="test-column">
//          <property name="title">Test</property>
//          <child>
//            <object class="GtkCellRendererText" id="test-renderer"/>
//            <attributes>
//              <attribute name="text">1</attribute>
//            </attributes>
//          </child>
//        </object>
//      </child>
//      <child internal-child="selection">
//        <object class="GtkTreeSelection" id="selection">
//          <signal name="changed" handler="on_treeview_selection_changed"/>
//        </object>
//      </child>
//    </object>
//
// CSS nodes
//
//    treeview.view
//    ├── header
//    │   ├── <column header>
//    ┊   ┊
//    │   ╰── <column header>
//    │
//    ├── [rubberband]
//    ╰── [dndtarget]
//
// GtkTreeView has a main CSS node with name treeview and style class .view. It
// has a subnode with name header, which is the parent for all the column header
// widgets' CSS nodes.
//
// For rubberband selection, a subnode with name rubberband is used.
//
// For the drop target location during DND, a subnode with name dndtarget is
// used.
type TreeView interface {
	Widget

	// AppendColumn: appends @column to the list of columns. If @tree_view has
	// “fixed_height” mode enabled, then @column must have its “sizing” property
	// set to be GTK_TREE_VIEW_COLUMN_FIXED.
	AppendColumn(column TreeViewColumn) int
	// CollapseAll: recursively collapses all visible, expanded nodes in
	// @tree_view.
	CollapseAll()
	// CollapseRow: collapses a row (hides its child rows, if they exist).
	CollapseRow(path *TreePath) bool
	// ColumnsAutosize: resizes all columns to their optimal width. Only works
	// after the treeview has been realized.
	ColumnsAutosize()
	// ConvertBinWindowToTreeCoords: converts bin_window coordinates to
	// coordinates for the tree (the full scrollable area of the tree).
	ConvertBinWindowToTreeCoords(bx int, by int) (tx int, ty int)
	// ConvertBinWindowToWidgetCoords: converts bin_window coordinates to widget
	// relative coordinates.
	ConvertBinWindowToWidgetCoords(bx int, by int) (wx int, wy int)
	// ConvertTreeToBinWindowCoords: converts tree coordinates (coordinates in
	// full scrollable area of the tree) to bin_window coordinates.
	ConvertTreeToBinWindowCoords(tx int, ty int) (bx int, by int)
	// ConvertTreeToWidgetCoords: converts tree coordinates (coordinates in full
	// scrollable area of the tree) to widget coordinates.
	ConvertTreeToWidgetCoords(tx int, ty int) (wx int, wy int)
	// ConvertWidgetToBinWindowCoords: converts widget coordinates to
	// coordinates for the bin_window.
	ConvertWidgetToBinWindowCoords(wx int, wy int) (bx int, by int)
	// ConvertWidgetToTreeCoords: converts widget coordinates to coordinates for
	// the tree (the full scrollable area of the tree).
	ConvertWidgetToTreeCoords(wx int, wy int) (tx int, ty int)
	// CreateRowDragIcon: creates a #cairo_surface_t representation of the row
	// at @path. This image is used for a drag icon.
	CreateRowDragIcon(path *TreePath) gdk.Paintable
	// EnableModelDragDest: turns @tree_view into a drop destination for
	// automatic DND. Calling this method sets TreeView:reorderable to false.
	EnableModelDragDest(formats *gdk.ContentFormats, actions gdk.DragAction)
	// EnableModelDragSource: turns @tree_view into a drag source for automatic
	// DND. Calling this method sets TreeView:reorderable to false.
	EnableModelDragSource(startButtonMask gdk.ModifierType, formats *gdk.ContentFormats, actions gdk.DragAction)
	// ExpandAll: recursively expands all nodes in the @tree_view.
	ExpandAll()
	// ExpandRow: opens the row so its children are visible.
	ExpandRow(path *TreePath, openAll bool) bool
	// ExpandToPath: expands the row at @path. This will also expand all parent
	// rows of @path as necessary.
	ExpandToPath(path *TreePath)
	// ActivateOnSingleClick: gets the setting set by
	// gtk_tree_view_set_activate_on_single_click().
	ActivateOnSingleClick() bool
	// BackgroundArea: fills the bounding rectangle in bin_window coordinates
	// for the cell at the row specified by @path and the column specified by
	// @column. If @path is nil, or points to a node not found in the tree, the
	// @y and @height fields of the rectangle will be filled with 0. If @column
	// is nil, the @x and @width fields will be filled with 0. The returned
	// rectangle is equivalent to the @background_area passed to
	// gtk_cell_renderer_render(). These background areas tile to cover the
	// entire bin window. Contrast with the @cell_area, returned by
	// gtk_tree_view_get_cell_area(), which returns only the cell itself,
	// excluding surrounding borders and the tree expander area.
	BackgroundArea(path *TreePath, column TreeViewColumn) gdk.Rectangle
	// CellArea: fills the bounding rectangle in bin_window coordinates for the
	// cell at the row specified by @path and the column specified by @column.
	// If @path is nil, or points to a path not currently displayed, the @y and
	// @height fields of the rectangle will be filled with 0. If @column is nil,
	// the @x and @width fields will be filled with 0. The sum of all cell rects
	// does not cover the entire tree; there are extra pixels in between rows,
	// for example. The returned rectangle is equivalent to the @cell_area
	// passed to gtk_cell_renderer_render(). This function is only valid if
	// @tree_view is realized.
	CellArea(path *TreePath, column TreeViewColumn) gdk.Rectangle
	// Column: gets the TreeViewColumn at the given position in the #tree_view.
	Column(n int) TreeViewColumn
	// Columns: returns a #GList of all the TreeViewColumn s currently in
	// @tree_view. The returned list must be freed with g_list_free ().
	Columns() *glib.List
	// Cursor: fills in @path and @focus_column with the current path and focus
	// column. If the cursor isn’t currently set, then *@path will be nil. If no
	// column currently has focus, then *@focus_column will be nil.
	//
	// The returned TreePath must be freed with gtk_tree_path_free() when you
	// are done with it.
	Cursor() (path *TreePath, focusColumn TreeViewColumn)
	// DestRowAtPos: determines the destination row for a given position.
	// @drag_x and @drag_y are expected to be in widget coordinates. This
	// function is only meaningful if @tree_view is realized. Therefore this
	// function will always return false if @tree_view is not realized or does
	// not have a model.
	DestRowAtPos(dragX int, dragY int) (path *TreePath, pos TreeViewDropPosition, ok bool)
	// DragDestRow: gets information about the row that is highlighted for
	// feedback.
	DragDestRow() (path *TreePath, pos TreeViewDropPosition)
	// EnableSearch: returns whether or not the tree allows to start interactive
	// searching by typing in text.
	EnableSearch() bool
	// EnableTreeLines: returns whether or not tree lines are drawn in
	// @tree_view.
	EnableTreeLines() bool
	// ExpanderColumn: returns the column that is the current expander column,
	// or nil if none has been set. This column has the expander arrow drawn
	// next to it.
	ExpanderColumn() TreeViewColumn
	// FixedHeightMode: returns whether fixed height mode is turned on for
	// @tree_view.
	FixedHeightMode() bool
	// GridLines: returns which grid lines are enabled in @tree_view.
	GridLines() TreeViewGridLines
	// HeadersClickable: returns whether all header columns are clickable.
	HeadersClickable() bool
	// HeadersVisible: returns true if the headers on the @tree_view are
	// visible.
	HeadersVisible() bool
	// HoverExpand: returns whether hover expansion mode is turned on for
	// @tree_view.
	HoverExpand() bool
	// HoverSelection: returns whether hover selection mode is turned on for
	// @tree_view.
	HoverSelection() bool
	// LevelIndentation: returns the amount, in pixels, of extra indentation for
	// child levels in @tree_view.
	LevelIndentation() int
	// Model: returns the model the TreeView is based on. Returns nil if the
	// model is unset.
	Model() TreeModel
	// NColumns: queries the number of columns in the given @tree_view.
	NColumns() uint
	// PathAtPos: finds the path at the point (@x, @y), relative to bin_window
	// coordinates. That is, @x and @y are relative to an events coordinates.
	// Widget-relative coordinates must be converted using
	// gtk_tree_view_convert_widget_to_bin_window_coords(). It is primarily for
	// things like popup menus. If @path is non-nil, then it will be filled with
	// the TreePath at that point. This path should be freed with
	// gtk_tree_path_free(). If @column is non-nil, then it will be filled with
	// the column at that point. @cell_x and @cell_y return the coordinates
	// relative to the cell background (i.e. the @background_area passed to
	// gtk_cell_renderer_render()). This function is only meaningful if
	// @tree_view is realized. Therefore this function will always return false
	// if @tree_view is not realized or does not have a model.
	//
	// For converting widget coordinates (eg. the ones you get from
	// GtkWidget::query-tooltip), please see
	// gtk_tree_view_convert_widget_to_bin_window_coords().
	PathAtPos(x int, y int) (path *TreePath, column TreeViewColumn, cellX int, cellY int, ok bool)
	// Reorderable: retrieves whether the user can reorder the tree via
	// drag-and-drop. See gtk_tree_view_set_reorderable().
	Reorderable() bool
	// RowSeparatorFunc: returns the current row separator function.
	RowSeparatorFunc() TreeViewRowSeparatorFunc
	// RubberBanding: returns whether rubber banding is turned on for
	// @tree_view. If the selection mode is K_SELECTION_MULTIPLE, rubber banding
	// will allow the user to select multiple rows by dragging the mouse.
	RubberBanding() bool
	// SearchColumn: gets the column searched on by the interactive search code.
	SearchColumn() int
	// SearchEntry: returns the Entry which is currently in use as interactive
	// search entry for @tree_view. In case the built-in entry is being used,
	// nil will be returned.
	SearchEntry() Editable
	// SearchEqualFunc: returns the compare function currently in use.
	SearchEqualFunc() TreeViewSearchEqualFunc
	// Selection: gets the TreeSelection associated with @tree_view.
	Selection() TreeSelection
	// ShowExpanders: returns whether or not expanders are drawn in @tree_view.
	ShowExpanders() bool
	// TooltipColumn: returns the column of @tree_view’s model which is being
	// used for displaying tooltips on @tree_view’s rows.
	TooltipColumn() int
	// TooltipContext: this function is supposed to be used in a
	// Widget::query-tooltip signal handler for TreeView. The @x, @y and
	// @keyboard_tip values which are received in the signal handler, should be
	// passed to this function without modification.
	//
	// The return value indicates whether there is a tree view row at the given
	// coordinates (true) or not (false) for mouse tooltips. For keyboard
	// tooltips the row returned will be the cursor row. When true, then any of
	// @model, @path and @iter which have been provided will be set to point to
	// that row and the corresponding model. @x and @y will always be converted
	// to be relative to @tree_view’s bin_window if @keyboard_tooltip is false.
	TooltipContext(x int, y int, keyboardTip bool) (model TreeModel, path *TreePath, iter TreeIter, ok bool)
	// VisibleRange: sets @start_path and @end_path to be the first and last
	// visible path. Note that there may be invisible paths in between.
	//
	// The paths should be freed with gtk_tree_path_free() after use.
	VisibleRange() (startPath *TreePath, endPath *TreePath, ok bool)
	// VisibleRect: fills @visible_rect with the currently-visible region of the
	// buffer, in tree coordinates. Convert to bin_window coordinates with
	// gtk_tree_view_convert_tree_to_bin_window_coords(). Tree coordinates start
	// at 0,0 for row 0 of the tree, and cover the entire scrollable area of the
	// tree.
	VisibleRect() gdk.Rectangle
	// InsertColumn: this inserts the @column into the @tree_view at @position.
	// If @position is -1, then the column is inserted at the end. If @tree_view
	// has “fixed_height” mode enabled, then @column must have its “sizing”
	// property set to be GTK_TREE_VIEW_COLUMN_FIXED.
	InsertColumn(column TreeViewColumn, position int) int
	// InsertColumnWithDataFunc: convenience function that inserts a new column
	// into the TreeView with the given cell renderer and a TreeCellDataFunc to
	// set cell renderer attributes (normally using data from the model). See
	// also gtk_tree_view_column_set_cell_data_func(),
	// gtk_tree_view_column_pack_start(). If @tree_view has “fixed_height” mode
	// enabled, then the new column will have its “sizing” property set to be
	// GTK_TREE_VIEW_COLUMN_FIXED.
	InsertColumnWithDataFunc(position int, title string, cell CellRenderer, _func TreeCellDataFunc) int
	// IsBlankAtPos: determine whether the point (@x, @y) in @tree_view is
	// blank, that is no cell content nor an expander arrow is drawn at the
	// location. If so, the location can be considered as the background. You
	// might wish to take special action on clicks on the background, such as
	// clearing a current selection, having a custom context menu or starting
	// rubber banding.
	//
	// The @x and @y coordinate that are provided must be relative to bin_window
	// coordinates. Widget-relative coordinates must be converted using
	// gtk_tree_view_convert_widget_to_bin_window_coords().
	//
	// For converting widget coordinates (eg. the ones you get from
	// GtkWidget::query-tooltip), please see
	// gtk_tree_view_convert_widget_to_bin_window_coords().
	//
	// The @path, @column, @cell_x and @cell_y arguments will be filled in
	// likewise as for gtk_tree_view_get_path_at_pos(). Please see
	// gtk_tree_view_get_path_at_pos() for more information.
	IsBlankAtPos(x int, y int) (path *TreePath, column TreeViewColumn, cellX int, cellY int, ok bool)
	// IsRubberBandingActive: returns whether a rubber banding operation is
	// currently being done in @tree_view.
	IsRubberBandingActive() bool
	// MapExpandedRows: calls @func on all expanded rows.
	MapExpandedRows(_func TreeViewMappingFunc)
	// MoveColumnAfter: moves @column to be after to @base_column. If
	// @base_column is nil, then @column is placed in the first position.
	MoveColumnAfter(column TreeViewColumn, baseColumn TreeViewColumn)
	// RemoveColumn: removes @column from @tree_view.
	RemoveColumn(column TreeViewColumn) int
	// RowActivated: activates the cell determined by @path and @column.
	RowActivated(path *TreePath, column TreeViewColumn)
	// RowExpanded: returns true if the node pointed to by @path is expanded in
	// @tree_view.
	RowExpanded(path *TreePath) bool
	// ScrollToCell: moves the alignments of @tree_view to the position
	// specified by @column and @path. If @column is nil, then no horizontal
	// scrolling occurs. Likewise, if @path is nil no vertical scrolling occurs.
	// At a minimum, one of @column or @path need to be non-nil. @row_align
	// determines where the row is placed, and @col_align determines where
	// @column is placed. Both are expected to be between 0.0 and 1.0. 0.0 means
	// left/top alignment, 1.0 means right/bottom alignment, 0.5 means center.
	//
	// If @use_align is false, then the alignment arguments are ignored, and the
	// tree does the minimum amount of work to scroll the cell onto the screen.
	// This means that the cell will be scrolled to the edge closest to its
	// current position. If the cell is currently visible on the screen, nothing
	// is done.
	//
	// This function only works if the model is set, and @path is a valid row on
	// the model. If the model changes before the @tree_view is realized, the
	// centered path will be modified to reflect this change.
	ScrollToCell(path *TreePath, column TreeViewColumn, useAlign bool, rowAlign float32, colAlign float32)
	// ScrollToPoint: scrolls the tree view such that the top-left corner of the
	// visible area is @tree_x, @tree_y, where @tree_x and @tree_y are specified
	// in tree coordinates. The @tree_view must be realized before this function
	// is called. If it isn't, you probably want to be using
	// gtk_tree_view_scroll_to_cell().
	//
	// If either @tree_x or @tree_y are -1, then that direction isn’t scrolled.
	ScrollToPoint(treeX int, treeY int)
	// SetActivateOnSingleClick: cause the TreeView::row-activated signal to be
	// emitted on a single click instead of a double click.
	SetActivateOnSingleClick(single bool)
	// SetColumnDragFunction: sets a user function for determining where a
	// column may be dropped when dragged. This function is called on every
	// column pair in turn at the beginning of a column drag to determine where
	// a drop can take place. The arguments passed to @func are: the @tree_view,
	// the TreeViewColumn being dragged, the two TreeViewColumn s determining
	// the drop spot, and @user_data. If either of the TreeViewColumn arguments
	// for the drop spot are nil, then they indicate an edge. If @func is set to
	// be nil, then @tree_view reverts to the default behavior of allowing all
	// columns to be dropped everywhere.
	SetColumnDragFunction(_func TreeViewColumnDropFunc)
	// SetCursor: sets the current keyboard focus to be at @path, and selects
	// it. This is useful when you want to focus the user’s attention on a
	// particular row. If @focus_column is not nil, then focus is given to the
	// column specified by it. Additionally, if @focus_column is specified, and
	// @start_editing is true, then editing should be started in the specified
	// cell. This function is often followed by @gtk_widget_grab_focus
	// (@tree_view) in order to give keyboard focus to the widget. Please note
	// that editing can only happen when the widget is realized.
	//
	// If @path is invalid for @model, the current cursor (if any) will be unset
	// and the function will return without failing.
	SetCursor(path *TreePath, focusColumn TreeViewColumn, startEditing bool)
	// SetCursorOnCell: sets the current keyboard focus to be at @path, and
	// selects it. This is useful when you want to focus the user’s attention on
	// a particular row. If @focus_column is not nil, then focus is given to the
	// column specified by it. If @focus_column and @focus_cell are not nil, and
	// @focus_column contains 2 or more editable or activatable cells, then
	// focus is given to the cell specified by @focus_cell. Additionally, if
	// @focus_column is specified, and @start_editing is true, then editing
	// should be started in the specified cell. This function is often followed
	// by @gtk_widget_grab_focus (@tree_view) in order to give keyboard focus to
	// the widget. Please note that editing can only happen when the widget is
	// realized.
	//
	// If @path is invalid for @model, the current cursor (if any) will be unset
	// and the function will return without failing.
	SetCursorOnCell(path *TreePath, focusColumn TreeViewColumn, focusCell CellRenderer, startEditing bool)
	// SetDragDestRow: sets the row that is highlighted for feedback. If @path
	// is nil, an existing highlight is removed.
	SetDragDestRow(path *TreePath, pos TreeViewDropPosition)
	// SetEnableSearch: if @enable_search is set, then the user can type in text
	// to search through the tree interactively (this is sometimes called
	// "typeahead find").
	//
	// Note that even if this is false, the user can still initiate a search
	// using the “start-interactive-search” key binding.
	SetEnableSearch(enableSearch bool)
	// SetEnableTreeLines: sets whether to draw lines interconnecting the
	// expanders in @tree_view. This does not have any visible effects for
	// lists.
	SetEnableTreeLines(enabled bool)
	// SetExpanderColumn: sets the column to draw the expander arrow at. It must
	// be in @tree_view. If @column is nil, then the expander arrow is always at
	// the first visible column.
	//
	// If you do not want expander arrow to appear in your tree, set the
	// expander column to a hidden column.
	SetExpanderColumn(column TreeViewColumn)
	// SetFixedHeightMode: enables or disables the fixed height mode of
	// @tree_view. Fixed height mode speeds up TreeView by assuming that all
	// rows have the same height. Only enable this option if all rows are the
	// same height and all columns are of type GTK_TREE_VIEW_COLUMN_FIXED.
	SetFixedHeightMode(enable bool)
	// SetGridLines: sets which grid lines to draw in @tree_view.
	SetGridLines(gridLines TreeViewGridLines)
	// SetHeadersClickable: allow the column title buttons to be clicked.
	SetHeadersClickable(setting bool)
	// SetHeadersVisible: sets the visibility state of the headers.
	SetHeadersVisible(headersVisible bool)
	// SetHoverExpand: enables or disables the hover expansion mode of
	// @tree_view. Hover expansion makes rows expand or collapse if the pointer
	// moves over them.
	SetHoverExpand(expand bool)
	// SetHoverSelection: enables or disables the hover selection mode of
	// @tree_view. Hover selection makes the selected row follow the pointer.
	// Currently, this works only for the selection modes GTK_SELECTION_SINGLE
	// and GTK_SELECTION_BROWSE.
	SetHoverSelection(hover bool)
	// SetLevelIndentation: sets the amount of extra indentation for child
	// levels to use in @tree_view in addition to the default indentation. The
	// value should be specified in pixels, a value of 0 disables this feature
	// and in this case only the default indentation will be used. This does not
	// have any visible effects for lists.
	SetLevelIndentation(indentation int)
	// SetModel: sets the model for a TreeView. If the @tree_view already has a
	// model set, it will remove it before setting the new model. If @model is
	// nil, then it will unset the old model.
	SetModel(model TreeModel)
	// SetReorderable: this function is a convenience function to allow you to
	// reorder models that support the TreeDragSourceIface and the
	// TreeDragDestIface. Both TreeStore and ListStore support these. If
	// @reorderable is true, then the user can reorder the model by dragging and
	// dropping rows. The developer can listen to these changes by connecting to
	// the model’s TreeModel::row-inserted and TreeModel::row-deleted signals.
	// The reordering is implemented by setting up the tree view as a drag
	// source and destination. Therefore, drag and drop can not be used in a
	// reorderable view for any other purpose.
	//
	// This function does not give you any degree of control over the order --
	// any reordering is allowed. If more control is needed, you should probably
	// handle drag and drop manually.
	SetReorderable(reorderable bool)
	// SetRowSeparatorFunc: sets the row separator function, which is used to
	// determine whether a row should be drawn as a separator. If the row
	// separator function is nil, no separators are drawn. This is the default
	// value.
	SetRowSeparatorFunc(_func TreeViewRowSeparatorFunc)
	// SetRubberBanding: enables or disables rubber banding in @tree_view. If
	// the selection mode is K_SELECTION_MULTIPLE, rubber banding will allow the
	// user to select multiple rows by dragging the mouse.
	SetRubberBanding(enable bool)
	// SetSearchColumn: sets @column as the column where the interactive search
	// code should search in for the current model.
	//
	// If the search column is set, users can use the “start-interactive-search”
	// key binding to bring up search popup. The enable-search property controls
	// whether simply typing text will also start an interactive search.
	//
	// Note that @column refers to a column of the current model. The search
	// column is reset to -1 when the model is changed.
	SetSearchColumn(column int)
	// SetSearchEntry: sets the entry which the interactive search code will use
	// for this @tree_view. This is useful when you want to provide a search
	// entry in our interface at all time at a fixed position. Passing nil for
	// @entry will make the interactive search code use the built-in popup entry
	// again.
	SetSearchEntry(entry Editable)
	// SetSearchEqualFunc: sets the compare function for the interactive search
	// capabilities; note that somewhat like strcmp() returning 0 for equality
	// TreeViewSearchEqualFunc returns false on matches.
	SetSearchEqualFunc(searchEqualFunc TreeViewSearchEqualFunc)
	// SetShowExpanders: sets whether to draw and enable expanders and indent
	// child rows in @tree_view. When disabled there will be no expanders
	// visible in trees and there will be no way to expand and collapse rows by
	// default. Also note that hiding the expanders will disable the default
	// indentation. You can set a custom indentation in this case using
	// gtk_tree_view_set_level_indentation(). This does not have any visible
	// effects for lists.
	SetShowExpanders(enabled bool)
	// SetTooltipCell: sets the tip area of @tooltip to the area @path, @column
	// and @cell have in common. For example if @path is nil and @column is set,
	// the tip area will be set to the full area covered by @column. See also
	// gtk_tooltip_set_tip_area().
	//
	// Note that if @path is not specified and @cell is set and part of a column
	// containing the expander, the tooltip might not show and hide at the
	// correct position. In such cases @path must be set to the current node
	// under the mouse cursor for this function to operate correctly.
	//
	// See also gtk_tree_view_set_tooltip_column() for a simpler alternative.
	SetTooltipCell(tooltip Tooltip, path *TreePath, column TreeViewColumn, cell CellRenderer)
	// SetTooltipColumn: if you only plan to have simple (text-only) tooltips on
	// full rows, you can use this function to have TreeView handle these
	// automatically for you. @column should be set to the column in
	// @tree_view’s model containing the tooltip texts, or -1 to disable this
	// feature.
	//
	// When enabled, Widget:has-tooltip will be set to true and @tree_view will
	// connect a Widget::query-tooltip signal handler.
	//
	// Note that the signal handler sets the text with gtk_tooltip_set_markup(),
	// so &, <, etc have to be escaped in the text.
	SetTooltipColumn(column int)
	// SetTooltipRow: sets the tip area of @tooltip to be the area covered by
	// the row at @path. See also gtk_tree_view_set_tooltip_column() for a
	// simpler alternative. See also gtk_tooltip_set_tip_area().
	SetTooltipRow(tooltip Tooltip, path *TreePath)
	// UnsetRowsDragDest: undoes the effect of
	// gtk_tree_view_enable_model_drag_dest(). Calling this method sets
	// TreeView:reorderable to false.
	UnsetRowsDragDest()
	// UnsetRowsDragSource: undoes the effect of
	// gtk_tree_view_enable_model_drag_source(). Calling this method sets
	// TreeView:reorderable to false.
	UnsetRowsDragSource()
}

type treeView struct {
	widget
}

func wrapTreeView(obj *externglib.Object) TreeView {
	return treeView{widget{externglib.InitiallyUnowned{obj}}}
}

func marshalTreeView(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewTreeView() TreeView

func NewTreeView(model TreeModel) TreeView

func (t treeView) AppendColumn(column TreeViewColumn) int

func (t treeView) CollapseAll()

func (t treeView) CollapseRow(path *TreePath) bool

func (t treeView) ColumnsAutosize()

func (t treeView) ConvertBinWindowToTreeCoords(bx int, by int) (tx int, ty int)

func (t treeView) ConvertBinWindowToWidgetCoords(bx int, by int) (wx int, wy int)

func (t treeView) ConvertTreeToBinWindowCoords(tx int, ty int) (bx int, by int)

func (t treeView) ConvertTreeToWidgetCoords(tx int, ty int) (wx int, wy int)

func (t treeView) ConvertWidgetToBinWindowCoords(wx int, wy int) (bx int, by int)

func (t treeView) ConvertWidgetToTreeCoords(wx int, wy int) (tx int, ty int)

func (t treeView) CreateRowDragIcon(path *TreePath) gdk.Paintable

func (t treeView) EnableModelDragDest(formats *gdk.ContentFormats, actions gdk.DragAction)

func (t treeView) EnableModelDragSource(startButtonMask gdk.ModifierType, formats *gdk.ContentFormats, actions gdk.DragAction)

func (t treeView) ExpandAll()

func (t treeView) ExpandRow(path *TreePath, openAll bool) bool

func (t treeView) ExpandToPath(path *TreePath)

func (t treeView) ActivateOnSingleClick() bool

func (t treeView) BackgroundArea(path *TreePath, column TreeViewColumn) gdk.Rectangle

func (t treeView) CellArea(path *TreePath, column TreeViewColumn) gdk.Rectangle

func (t treeView) Column(n int) TreeViewColumn

func (t treeView) Columns() *glib.List

func (t treeView) Cursor() (path *TreePath, focusColumn TreeViewColumn)

func (t treeView) DestRowAtPos(dragX int, dragY int) (path *TreePath, pos TreeViewDropPosition, ok bool)

func (t treeView) DragDestRow() (path *TreePath, pos TreeViewDropPosition)

func (t treeView) EnableSearch() bool

func (t treeView) EnableTreeLines() bool

func (t treeView) ExpanderColumn() TreeViewColumn

func (t treeView) FixedHeightMode() bool

func (t treeView) GridLines() TreeViewGridLines

func (t treeView) HeadersClickable() bool

func (t treeView) HeadersVisible() bool

func (t treeView) HoverExpand() bool

func (t treeView) HoverSelection() bool

func (t treeView) LevelIndentation() int

func (t treeView) Model() TreeModel

func (t treeView) NColumns() uint

func (t treeView) PathAtPos(x int, y int) (path *TreePath, column TreeViewColumn, cellX int, cellY int, ok bool)

func (t treeView) Reorderable() bool

func (t treeView) RowSeparatorFunc() TreeViewRowSeparatorFunc

func (t treeView) RubberBanding() bool

func (t treeView) SearchColumn() int

func (t treeView) SearchEntry() Editable

func (t treeView) SearchEqualFunc() TreeViewSearchEqualFunc

func (t treeView) Selection() TreeSelection

func (t treeView) ShowExpanders() bool

func (t treeView) TooltipColumn() int

func (t treeView) TooltipContext(x int, y int, keyboardTip bool) (model TreeModel, path *TreePath, iter TreeIter, ok bool)

func (t treeView) VisibleRange() (startPath *TreePath, endPath *TreePath, ok bool)

func (t treeView) VisibleRect() gdk.Rectangle

func (t treeView) InsertColumn(column TreeViewColumn, position int) int

func (t treeView) InsertColumnWithDataFunc(position int, title string, cell CellRenderer, _func TreeCellDataFunc) int

func (t treeView) IsBlankAtPos(x int, y int) (path *TreePath, column TreeViewColumn, cellX int, cellY int, ok bool)

func (t treeView) IsRubberBandingActive() bool

func (t treeView) MapExpandedRows(_func TreeViewMappingFunc)

func (t treeView) MoveColumnAfter(column TreeViewColumn, baseColumn TreeViewColumn)

func (t treeView) RemoveColumn(column TreeViewColumn) int

func (t treeView) RowActivated(path *TreePath, column TreeViewColumn)

func (t treeView) RowExpanded(path *TreePath) bool

func (t treeView) ScrollToCell(path *TreePath, column TreeViewColumn, useAlign bool, rowAlign float32, colAlign float32)

func (t treeView) ScrollToPoint(treeX int, treeY int)

func (t treeView) SetActivateOnSingleClick(single bool)

func (t treeView) SetColumnDragFunction(_func TreeViewColumnDropFunc)

func (t treeView) SetCursor(path *TreePath, focusColumn TreeViewColumn, startEditing bool)

func (t treeView) SetCursorOnCell(path *TreePath, focusColumn TreeViewColumn, focusCell CellRenderer, startEditing bool)

func (t treeView) SetDragDestRow(path *TreePath, pos TreeViewDropPosition)

func (t treeView) SetEnableSearch(enableSearch bool)

func (t treeView) SetEnableTreeLines(enabled bool)

func (t treeView) SetExpanderColumn(column TreeViewColumn)

func (t treeView) SetFixedHeightMode(enable bool)

func (t treeView) SetGridLines(gridLines TreeViewGridLines)

func (t treeView) SetHeadersClickable(setting bool)

func (t treeView) SetHeadersVisible(headersVisible bool)

func (t treeView) SetHoverExpand(expand bool)

func (t treeView) SetHoverSelection(hover bool)

func (t treeView) SetLevelIndentation(indentation int)

func (t treeView) SetModel(model TreeModel)

func (t treeView) SetReorderable(reorderable bool)

func (t treeView) SetRowSeparatorFunc(_func TreeViewRowSeparatorFunc)

func (t treeView) SetRubberBanding(enable bool)

func (t treeView) SetSearchColumn(column int)

func (t treeView) SetSearchEntry(entry Editable)

func (t treeView) SetSearchEqualFunc(searchEqualFunc TreeViewSearchEqualFunc)

func (t treeView) SetShowExpanders(enabled bool)

func (t treeView) SetTooltipCell(tooltip Tooltip, path *TreePath, column TreeViewColumn, cell CellRenderer)

func (t treeView) SetTooltipColumn(column int)

func (t treeView) SetTooltipRow(tooltip Tooltip, path *TreePath)

func (t treeView) UnsetRowsDragDest()

func (t treeView) UnsetRowsDragSource()

// TreeViewColumn: the GtkTreeViewColumn object represents a visible column in a
// TreeView widget. It allows to set properties of the column header, and
// functions as a holding pen for the cell renderers which determine how the
// data in the column is displayed.
//
// Please refer to the [tree widget conceptual overview][TreeWidget] for an
// overview of all the objects and data types related to the tree widget and how
// they work together.
type TreeViewColumn interface {
	gextras.Objector

	// AddAttribute: adds an attribute mapping to the list in @tree_column. The
	// @column is the column of the model to get a value from, and the
	// @attribute is the parameter on @cell_renderer to be set from the value.
	// So for example if column 2 of the model contains strings, you could have
	// the “text” attribute of a CellRendererText get its values from column 2.
	AddAttribute(cellRenderer CellRenderer, attribute string, column int)
	// CellGetPosition: obtains the horizontal position and size of a cell in a
	// column. If the cell is not found in the column, @start_pos and @width are
	// not changed and false is returned.
	CellGetPosition(cellRenderer CellRenderer) (xOffset int, width int, ok bool)
	// CellGetSize: obtains the width and height needed to render the column.
	// This is used primarily by the TreeView.
	CellGetSize() (xOffset int, yOffset int, width int, height int)
	// CellIsVisible: returns true if any of the cells packed into the
	// @tree_column are visible. For this to be meaningful, you must first
	// initialize the cells with gtk_tree_view_column_cell_set_cell_data()
	CellIsVisible() bool
	// CellSetCellData: sets the cell renderer based on the @tree_model and
	// @iter. That is, for every attribute mapping in @tree_column, it will get
	// a value from the set column on the @iter, and use that value to set the
	// attribute on the cell renderer. This is used primarily by the TreeView.
	CellSetCellData(treeModel TreeModel, iter *TreeIter, isExpander bool, isExpanded bool)
	// Clear: unsets all the mappings on all renderers on the @tree_column.
	Clear()
	// ClearAttributes: clears all existing attributes previously set with
	// gtk_tree_view_column_set_attributes().
	ClearAttributes(cellRenderer CellRenderer)
	// Clicked: emits the “clicked” signal on the column. This function will
	// only work if @tree_column is clickable.
	Clicked()
	// FocusCell: sets the current keyboard focus to be at @cell, if the column
	// contains 2 or more editable and activatable cells.
	FocusCell(cell CellRenderer)
	// Alignment: returns the current x alignment of @tree_column. This value
	// can range between 0.0 and 1.0.
	Alignment() float32
	// Button: returns the button used in the treeview column header
	Button() Widget
	// Clickable: returns true if the user can click on the header for the
	// column.
	Clickable() bool
	// Expand: returns true if the column expands to fill available space.
	Expand() bool
	// FixedWidth: gets the fixed width of the column. This may not be the
	// actual displayed width of the column; for that, use
	// gtk_tree_view_column_get_width().
	FixedWidth() int
	// MaxWidth: returns the maximum width in pixels of the @tree_column, or -1
	// if no maximum width is set.
	MaxWidth() int
	// MinWidth: returns the minimum width in pixels of the @tree_column, or -1
	// if no minimum width is set.
	MinWidth() int
	// Reorderable: returns true if the @tree_column can be reordered by the
	// user.
	Reorderable() bool
	// Resizable: returns true if the @tree_column can be resized by the end
	// user.
	Resizable() bool
	// Sizing: returns the current type of @tree_column.
	Sizing() TreeViewColumnSizing
	// SortColumnID: gets the logical @sort_column_id that the model sorts on
	// when this column is selected for sorting. See
	// gtk_tree_view_column_set_sort_column_id().
	SortColumnID() int
	// SortIndicator: gets the value set by
	// gtk_tree_view_column_set_sort_indicator().
	SortIndicator() bool
	// SortOrder: gets the value set by gtk_tree_view_column_set_sort_order().
	SortOrder() SortType
	// Spacing: returns the spacing of @tree_column.
	Spacing() int
	// Title: returns the title of the widget.
	Title() string
	// TreeView: returns the TreeView wherein @tree_column has been inserted. If
	// @column is currently not inserted in any tree view, nil is returned.
	TreeView() Widget
	// Visible: returns true if @tree_column is visible.
	Visible() bool
	// Widget: returns the Widget in the button on the column header. If a
	// custom widget has not been set then nil is returned.
	Widget() Widget
	// Width: returns the current size of @tree_column in pixels.
	Width() int
	// XOffset: returns the current X offset of @tree_column in pixels.
	XOffset() int
	// PackEnd: adds the @cell to end of the column. If @expand is false, then
	// the @cell is allocated no more space than it needs. Any unused space is
	// divided evenly between cells for which @expand is true.
	PackEnd(cell CellRenderer, expand bool)
	// PackStart: packs the @cell into the beginning of the column. If @expand
	// is false, then the @cell is allocated no more space than it needs. Any
	// unused space is divided evenly between cells for which @expand is true.
	PackStart(cell CellRenderer, expand bool)
	// QueueResize: flags the column, and the cell renderers added to this
	// column, to have their sizes renegotiated.
	QueueResize()
	// SetAlignment: sets the alignment of the title or custom widget inside the
	// column header. The alignment determines its location inside the button --
	// 0.0 for left, 0.5 for center, 1.0 for right.
	SetAlignment(xalign float32)
	// SetCellDataFunc: sets the TreeCellDataFunc to use for the column. This
	// function is used instead of the standard attributes mapping for setting
	// the column value, and should set the value of @tree_column's cell
	// renderer as appropriate. @func may be nil to remove an older one.
	SetCellDataFunc(cellRenderer CellRenderer, _func TreeCellDataFunc)
	// SetClickable: sets the header to be active if @clickable is true. When
	// the header is active, then it can take keyboard focus, and can be
	// clicked.
	SetClickable(clickable bool)
	// SetExpand: sets the column to take available extra space. This space is
	// shared equally amongst all columns that have the expand set to true. If
	// no column has this option set, then the last column gets all extra space.
	// By default, every column is created with this false.
	//
	// Along with “fixed-width”, the “expand” property changes when the column
	// is resized by the user.
	SetExpand(expand bool)
	// SetFixedWidth: if @fixed_width is not -1, sets the fixed width of
	// @tree_column; otherwise unsets it. The effective value of @fixed_width is
	// clamped between the minimum and maximum width of the column; however, the
	// value stored in the “fixed-width” property is not clamped. If the column
	// sizing is K_TREE_VIEW_COLUMN_GROW_ONLY or K_TREE_VIEW_COLUMN_AUTOSIZE,
	// setting a fixed width overrides the automatically calculated width. Note
	// that @fixed_width is only a hint to GTK; the width actually allocated to
	// the column may be greater or less than requested.
	//
	// Along with “expand”, the “fixed-width” property changes when the column
	// is resized by the user.
	SetFixedWidth(fixedWidth int)
	// SetMaxWidth: sets the maximum width of the @tree_column. If @max_width is
	// -1, then the maximum width is unset. Note, the column can actually be
	// wider than max width if it’s the last column in a view. In this case, the
	// column expands to fill any extra space.
	SetMaxWidth(maxWidth int)
	// SetMinWidth: sets the minimum width of the @tree_column. If @min_width is
	// -1, then the minimum width is unset.
	SetMinWidth(minWidth int)
	// SetReorderable: if @reorderable is true, then the column can be reordered
	// by the end user dragging the header.
	SetReorderable(reorderable bool)
	// SetResizable: if @resizable is true, then the user can explicitly resize
	// the column by grabbing the outer edge of the column button. If resizable
	// is true and sizing mode of the column is K_TREE_VIEW_COLUMN_AUTOSIZE,
	// then the sizing mode is changed to K_TREE_VIEW_COLUMN_GROW_ONLY.
	SetResizable(resizable bool)
	// SetSizing: sets the growth behavior of @tree_column to @type.
	SetSizing(_type TreeViewColumnSizing)
	// SetSortColumnID: sets the logical @sort_column_id that this column sorts
	// on when this column is selected for sorting. Doing so makes the column
	// header clickable.
	SetSortColumnID(sortColumnID int)
	// SetSortIndicator: call this function with a @setting of true to display
	// an arrow in the header button indicating the column is sorted. Call
	// gtk_tree_view_column_set_sort_order() to change the direction of the
	// arrow.
	SetSortIndicator(setting bool)
	// SetSortOrder: changes the appearance of the sort indicator.
	//
	// This does not actually sort the model. Use
	// gtk_tree_view_column_set_sort_column_id() if you want automatic sorting
	// support. This function is primarily for custom sorting behavior, and
	// should be used in conjunction with gtk_tree_sortable_set_sort_column_id()
	// to do that. For custom models, the mechanism will vary.
	//
	// The sort indicator changes direction to indicate normal sort or reverse
	// sort. Note that you must have the sort indicator enabled to see anything
	// when calling this function; see
	// gtk_tree_view_column_set_sort_indicator().
	SetSortOrder(order SortType)
	// SetSpacing: sets the spacing field of @tree_column, which is the number
	// of pixels to place between cell renderers packed into it.
	SetSpacing(spacing int)
	// SetTitle: sets the title of the @tree_column. If a custom widget has been
	// set, then this value is ignored.
	SetTitle(title string)
	// SetVisible: sets the visibility of @tree_column.
	SetVisible(visible bool)
	// SetWidget: sets the widget in the header to be @widget. If widget is nil,
	// then the header button is set with a Label set to the title of
	// @tree_column.
	SetWidget(widget Widget)
}

type treeViewColumn struct {
	externglib.InitiallyUnowned
}

func wrapTreeViewColumn(obj *externglib.Object) TreeViewColumn {
	return treeViewColumn{externglib.InitiallyUnowned{obj}}
}

func marshalTreeViewColumn(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewTreeViewColumn() TreeViewColumn

func NewTreeViewColumn(area CellArea) TreeViewColumn

func (t treeViewColumn) AddAttribute(cellRenderer CellRenderer, attribute string, column int)

func (t treeViewColumn) CellGetPosition(cellRenderer CellRenderer) (xOffset int, width int, ok bool)

func (t treeViewColumn) CellGetSize() (xOffset int, yOffset int, width int, height int)

func (t treeViewColumn) CellIsVisible() bool

func (t treeViewColumn) CellSetCellData(treeModel TreeModel, iter *TreeIter, isExpander bool, isExpanded bool)

func (t treeViewColumn) Clear()

func (t treeViewColumn) ClearAttributes(cellRenderer CellRenderer)

func (t treeViewColumn) Clicked()

func (t treeViewColumn) FocusCell(cell CellRenderer)

func (t treeViewColumn) Alignment() float32

func (t treeViewColumn) Button() Widget

func (t treeViewColumn) Clickable() bool

func (t treeViewColumn) Expand() bool

func (t treeViewColumn) FixedWidth() int

func (t treeViewColumn) MaxWidth() int

func (t treeViewColumn) MinWidth() int

func (t treeViewColumn) Reorderable() bool

func (t treeViewColumn) Resizable() bool

func (t treeViewColumn) Sizing() TreeViewColumnSizing

func (t treeViewColumn) SortColumnID() int

func (t treeViewColumn) SortIndicator() bool

func (t treeViewColumn) SortOrder() SortType

func (t treeViewColumn) Spacing() int

func (t treeViewColumn) Title() string

func (t treeViewColumn) TreeView() Widget

func (t treeViewColumn) Visible() bool

func (t treeViewColumn) Widget() Widget

func (t treeViewColumn) Width() int

func (t treeViewColumn) XOffset() int

func (t treeViewColumn) PackEnd(cell CellRenderer, expand bool)

func (t treeViewColumn) PackStart(cell CellRenderer, expand bool)

func (t treeViewColumn) QueueResize()

func (t treeViewColumn) SetAlignment(xalign float32)

func (t treeViewColumn) SetCellDataFunc(cellRenderer CellRenderer, _func TreeCellDataFunc)

func (t treeViewColumn) SetClickable(clickable bool)

func (t treeViewColumn) SetExpand(expand bool)

func (t treeViewColumn) SetFixedWidth(fixedWidth int)

func (t treeViewColumn) SetMaxWidth(maxWidth int)

func (t treeViewColumn) SetMinWidth(minWidth int)

func (t treeViewColumn) SetReorderable(reorderable bool)

func (t treeViewColumn) SetResizable(resizable bool)

func (t treeViewColumn) SetSizing(_type TreeViewColumnSizing)

func (t treeViewColumn) SetSortColumnID(sortColumnID int)

func (t treeViewColumn) SetSortIndicator(setting bool)

func (t treeViewColumn) SetSortOrder(order SortType)

func (t treeViewColumn) SetSpacing(spacing int)

func (t treeViewColumn) SetTitle(title string)

func (t treeViewColumn) SetVisible(visible bool)

func (t treeViewColumn) SetWidget(widget Widget)

// Video: gtkVideo is a widget to show a MediaStream with media controls as
// provided by MediaControls. If you just want to display a video without
// controls, you can treat it like any other paintable and for example put it
// into a Picture.
//
// GtkVideo aims to cover use cases such as previews, embedded animations, etc.
// It supports autoplay, looping, and simple media controls. It does not have
// support for video overlays, multichannel audio, device selection, or input.
// If you are writing a full-fledged video player, you may want to use the
// Paintable API and a media framework such as Gstreamer directly.
type Video interface {
	Widget

	// Autoplay: returns true if videos have been set to loop via
	// gtk_video_set_loop().
	Autoplay() bool
	// File: gets the file played by @self or nil if not playing back a file.
	File() gio.File
	// Loop: returns true if videos have been set to loop via
	// gtk_video_set_loop().
	Loop() bool
	// MediaStream: gets the media stream managed by @self or nil if none.
	MediaStream() MediaStream
	// SetAutoplay: sets whether @self automatically starts playback when it
	// becomes visible or when a new file gets loaded.
	SetAutoplay(autoplay bool)
	// SetFile: makes @self play the given @file.
	SetFile(file gio.File)
	// SetFilename: makes @self play the given @filename.
	//
	// This is a utility function that calls gtk_video_set_file(),
	SetFilename(filename string)
	// SetLoop: sets whether new files loaded by @self should be set to loop.
	SetLoop(loop bool)
	// SetMediaStream: sets the media stream to be played back. @self will take
	// full control of managing the media stream. If you want to manage a media
	// stream yourself, consider using a Image for display.
	//
	// If you want to display a file, consider using gtk_video_set_file()
	// instead.
	SetMediaStream(stream MediaStream)
	// SetResource: makes @self play the resource at the given @resource_path.
	//
	// This is a utility function that calls gtk_video_set_file(),
	SetResource(resourcePath string)
}

type video struct {
	widget
}

func wrapVideo(obj *externglib.Object) Video {
	return video{widget{externglib.InitiallyUnowned{obj}}}
}

func marshalVideo(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewVideo() Video

func NewVideo(file gio.File) Video

func NewVideo(filename string) Video

func NewVideo(stream MediaStream) Video

func NewVideo(resourcePath string) Video

func (v video) Autoplay() bool

func (v video) File() gio.File

func (v video) Loop() bool

func (v video) MediaStream() MediaStream

func (v video) SetAutoplay(autoplay bool)

func (v video) SetFile(file gio.File)

func (v video) SetFilename(filename string)

func (v video) SetLoop(loop bool)

func (v video) SetMediaStream(stream MediaStream)

func (v video) SetResource(resourcePath string)

// Viewport: the Viewport widget acts as an adaptor class, implementing
// scrollability for child widgets that lack their own scrolling capabilities.
// Use GtkViewport to scroll child widgets such as Grid, Box, and so on.
//
// The GtkViewport will start scrolling content only if allocated less than the
// child widget’s minimum size in a given orientation.
//
//
// CSS nodes
//
// GtkViewport has a single CSS node with name `viewport`.
//
//
// Accessibility
//
// GtkViewport uses the GTK_ACCESSIBLE_ROLE_GROUP role.
type Viewport interface {
	Widget

	// Child: gets the child widget of @viewport.
	Child() Widget
	// ScrollToFocus: gets whether the viewport is scrolling to keep the focused
	// child in view. See gtk_viewport_set_scroll_to_focus().
	ScrollToFocus() bool
	// SetChild: sets the child widget of @viewport.
	SetChild(child Widget)
	// SetScrollToFocus: sets whether the viewport should automatically scroll
	// to keep the focused child in view.
	SetScrollToFocus(scrollToFocus bool)
}

type viewport struct {
	widget
}

func wrapViewport(obj *externglib.Object) Viewport {
	return viewport{widget{externglib.InitiallyUnowned{obj}}}
}

func marshalViewport(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewViewport(hadjustment Adjustment, vadjustment Adjustment) Viewport

func (v viewport) Child() Widget

func (v viewport) ScrollToFocus() bool

func (v viewport) SetChild(child Widget)

func (v viewport) SetScrollToFocus(scrollToFocus bool)

// VolumeButton is a subclass of ScaleButton that has been tailored for use as a
// volume control widget with suitable icons, tooltips and accessible labels.
type VolumeButton interface {
	ScaleButton
}

type volumeButton struct {
	scaleButton
}

func wrapVolumeButton(obj *externglib.Object) VolumeButton {
	return volumeButton{scaleButton{widget{externglib.InitiallyUnowned{obj}}}}
}

func marshalVolumeButton(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewVolumeButton() VolumeButton

// Widget: gtkWidget is the base class all widgets in GTK derive from. It
// manages the widget lifecycle, states and style.
//
// Height-for-width Geometry Management {#geometry-management}
//
// GTK uses a height-for-width (and width-for-height) geometry management
// system. Height-for-width means that a widget can change how much vertical
// space it needs, depending on the amount of horizontal space that it is given
// (and similar for width-for-height). The most common example is a label that
// reflows to fill up the available width, wraps to fewer lines, and therefore
// needs less height.
//
// Height-for-width geometry management is implemented in GTK by way of two
// virtual methods:
//
// - WidgetClass.get_request_mode() - WidgetClass.measure()
//
// There are some important things to keep in mind when implementing
// height-for-width and when using it in widget implementations.
//
// If you implement a direct Widget subclass that supports height-for-width or
// width-for-height geometry management for itself or its child widgets, the
// WidgetClass.get_request_mode() virtual function must be implemented as well
// and return the widget's preferred request mode. The default implementation of
// this virtual function returns GTK_SIZE_REQUEST_CONSTANT_SIZE, which means
// that the widget will only ever get -1 passed as the for_size value to its
// WidgetClass.measure() implementation.
//
// The geometry management system will query a widget hierarchy in only one
// orientation at a time. When widgets are initially queried for their minimum
// sizes it is generally done in two initial passes in the SizeRequestMode
// chosen by the toplevel.
//
// For example, when queried in the normal GTK_SIZE_REQUEST_HEIGHT_FOR_WIDTH
// mode: First, the default minimum and natural width for each widget in the
// interface will be computed using gtk_widget_measure() with an orientation of
// GTK_ORIENTATION_HORIZONTAL and a for_size of -1. Because the preferred widths
// for each widget depend on the preferred widths of their children, this
// information propagates up the hierarchy, and finally a minimum and natural
// width is determined for the entire toplevel. Next, the toplevel will use the
// minimum width to query for the minimum height contextual to that width using
// gtk_widget_measure() with an orientation of GTK_ORIENTATION_VERTICAL and a
// for_size of the just computed width. This will also be a highly recursive
// operation. The minimum height for the minimum width is normally used to set
// the minimum size constraint on the toplevel.
//
// After the toplevel window has initially requested its size in both dimensions
// it can go on to allocate itself a reasonable size (or a size previously
// specified with gtk_window_set_default_size()). During the recursive
// allocation process it’s important to note that request cycles will be
// recursively executed while widgets allocate their children. Each widget, once
// allocated a size, will go on to first share the space in one orientation
// among its children and then request each child's height for its target
// allocated width or its width for allocated height, depending. In this way a
// Widget will typically be requested its size a number of times before actually
// being allocated a size. The size a widget is finally allocated can of course
// differ from the size it has requested. For this reason, Widget caches a small
// number of results to avoid re-querying for the same sizes in one allocation
// cycle.
//
// If a widget does move content around to intelligently use up the allocated
// size then it must support the request in both SizeRequestModes even if the
// widget in question only trades sizes in a single orientation.
//
// For instance, a Label that does height-for-width word wrapping will not
// expect to have WidgetClass.measure() with an orientation of
// GTK_ORIENTATION_VERTICAL called because that call is specific to a
// width-for-height request. In this case the label must return the height
// required for its own minimum possible width. By following this rule any
// widget that handles height-for-width or width-for-height requests will always
// be allocated at least enough space to fit its own content.
//
// Here are some examples of how a GTK_SIZE_REQUEST_HEIGHT_FOR_WIDTH widget
// generally deals with width-for-height requests:
//
//    static void
//    foo_widget_measure (GtkWidget      *widget,
//                        GtkOrientation  orientation,
//                        int             for_size,
//                        int            *minimum_size,
//                        int            *natural_size,
//                        int            *minimum_baseline,
//                        int            *natural_baseline)
//    {
//      if (orientation == GTK_ORIENTATION_HORIZONTAL)
//        {
//          // Calculate minimum and natural width
//        }
//      else // VERTICAL
//        {
//           if (i_am_in_height_for_width_mode)
//             {
//               int min_width, dummy;
//
//               // First, get the minimum width of our widget
//               GTK_WIDGET_GET_CLASS (widget)->measure (widget, GTK_ORIENTATION_HORIZONTAL, -1,
//                                                       &min_width, &dummy, &dummy, &dummy);
//
//               // Now use the minimum width to retrieve the minimum and natural height to display
//               // that width.
//               GTK_WIDGET_GET_CLASS (widget)->measure (widget, GTK_ORIENTATION_VERTICAL, min_width,
//                                                       minimum_size, natural_size, &dummy, &dummy);
//             }
//           else
//             {
//               // ... some widgets do both.
//             }
//       }
//    }
//
//
// Often a widget needs to get its own request during size request or
// allocation. For example, when computing height it may need to also compute
// width. Or when deciding how to use an allocation, the widget may need to know
// its natural size. In these cases, the widget should be careful to call its
// virtual methods directly, like in the code example above.
//
// It will not work to use the wrapper function gtk_widget_measure() inside your
// own WidgetClass.size-allocate() implementation. These return a request
// adjusted by SizeGroup, the widget's align and expand flags as well as its CSS
// style. If a widget used the wrappers inside its virtual method
// implementations, then the adjustments (such as widget margins) would be
// applied twice. GTK therefore does not allow this and will warn if you try to
// do it.
//
// Of course if you are getting the size request for another widget, such as a
// child widget, you must use gtk_widget_measure(). Otherwise, you would not
// properly consider widget margins, SizeGroup, and so forth.
//
// GTK also supports baseline vertical alignment of widgets. This means that
// widgets are positioned such that the typographical baseline of widgets in the
// same row are aligned. This happens if a widget supports baselines, has a
// vertical alignment of GTK_ALIGN_BASELINE, and is inside a widget that
// supports baselines and has a natural “row” that it aligns to the baseline, or
// a baseline assigned to it by the grandparent.
//
// Baseline alignment support for a widget is also done by the
// WidgetClass.measure() virtual function. It allows you to report both a
// minimum and natural size.
//
// If a widget ends up baseline aligned it will be allocated all the space in
// the parent as if it was GTK_ALIGN_FILL, but the selected baseline can be
// found via gtk_widget_get_allocated_baseline(). If this has a value other than
// -1 you need to align the widget such that the baseline appears at the
// position.
//
//
// GtkWidget as GtkBuildable
//
// The GtkWidget implementation of the Buildable interface supports a custom
// elements to specify various aspects of widgets that are not directly
// expressed as properties.
//
// If the parent widget uses a LayoutManager, Widget supports a custom
// `<layout>` element, used to define layout properties:
//
//    <object class="MyGrid" id="grid1">
//      <child>
//        <object class="GtkLabel" id="label1">
//          <property name="label">Description</property>
//          <layout>
//            <property name="column">0</property>
//            <property name="row">0</property>
//            <property name="row-span">1</property>
//            <property name="column-span">1</property>
//          </layout>
//        </object>
//      </child>
//      <child>
//        <object class="GtkEntry" id="description_entry">
//          <layout>
//            <property name="column">1</property>
//            <property name="row">0</property>
//            <property name="row-span">1</property>
//            <property name="column-span">1</property>
//          </layout>
//        </object>
//      </child>
//    </object>
//
// GtkWidget allows style information such as style classes to be associated
// with widgets, using the custom `<style>` element:
//
//    <object class="GtkButton" id="button1">
//      <style>
//        <class name="my-special-button-class"/>
//        <class name="dark-button"/>
//      </style>
//    </object>
//
// GtkWidget allows defining accessibility information, such as properties,
// relations, and states, using the custom `<accessibility>` element:
//
//    <object class="GtkButton" id="button1">
//      <accessibility>
//        <property name="label">Download</property>
//        <relation name="labelled-by">label1</relation>
//      </accessibility>
//    </object>
//
// Building composite widgets from template XML {#composite-templates}
//
// GtkWidget exposes some facilities to automate the procedure of creating
// composite widgets using Builder interface description language.
//
// To create composite widgets with Builder XML, one must associate the
// interface description with the widget class at class initialization time
// using gtk_widget_class_set_template().
//
// The interface description semantics expected in composite template
// descriptions is slightly different from regular Builder XML.
//
// Unlike regular interface descriptions, gtk_widget_class_set_template() will
// expect a `<template>` tag as a direct child of the toplevel `<interface>`
// tag. The `<template>` tag must specify the “class” attribute which must be
// the type name of the widget. Optionally, the “parent” attribute may be
// specified to specify the direct parent type of the widget type, this is
// ignored by the GtkBuilder but required for Glade to introspect what kind of
// properties and internal children exist for a given type when the actual type
// does not exist.
//
// The XML which is contained inside the `<template>` tag behaves as if it were
// added to the `<object>` tag defining @widget itself. You may set properties
// on @widget by inserting `<property>` tags into the `<template>` tag, and also
// add `<child>` tags to add children and extend @widget in the normal way you
// would with `<object>` tags.
//
// Additionally, `<object>` tags can also be added before and after the initial
// `<template>` tag in the normal way, allowing one to define auxiliary objects
// which might be referenced by other widgets declared as children of the
// `<template>` tag.
//
// An example of a GtkBuilder Template Definition:
//
//    <interface>
//      <template class="FooWidget" parent="GtkBox">
//        <property name="orientation">horizontal</property>
//        <property name="spacing">4</property>
//        <child>
//          <object class="GtkButton" id="hello_button">
//            <property name="label">Hello World</property>
//            <signal name="clicked" handler="hello_button_clicked" object="FooWidget" swapped="yes"/>
//          </object>
//        </child>
//        <child>
//          <object class="GtkButton" id="goodbye_button">
//            <property name="label">Goodbye World</property>
//          </object>
//        </child>
//      </template>
//    </interface>
//
// Typically, you'll place the template fragment into a file that is bundled
// with your project, using #GResource. In order to load the template, you need
// to call gtk_widget_class_set_template_from_resource() from the class
// initialization of your Widget type:
//
//    static void
//    foo_widget_class_init (FooWidgetClass *klass)
//    {
//      // ...
//
//      gtk_widget_class_set_template_from_resource (GTK_WIDGET_CLASS (klass),
//                                                   "/com/example/ui/foowidget.ui");
//    }
//
//
// You will also need to call gtk_widget_init_template() from the instance
// initialization function:
//
//    static void
//    foo_widget_init (FooWidget *self)
//    {
//      // ...
//      gtk_widget_init_template (GTK_WIDGET (self));
//    }
//
// You can access widgets defined in the template using the
// gtk_widget_get_template_child() function, but you will typically declare a
// pointer in the instance private data structure of your type using the same
// name as the widget in the template definition, and call
// gtk_widget_class_bind_template_child_private() with that name, e.g.
//
//    typedef struct {
//      GtkWidget *hello_button;
//      GtkWidget *goodbye_button;
//    } FooWidgetPrivate;
//
//    G_DEFINE_TYPE_WITH_PRIVATE (FooWidget, foo_widget, GTK_TYPE_BOX)
//
//    static void
//    foo_widget_class_init (FooWidgetClass *klass)
//    {
//      // ...
//      gtk_widget_class_set_template_from_resource (GTK_WIDGET_CLASS (klass),
//                                                   "/com/example/ui/foowidget.ui");
//      gtk_widget_class_bind_template_child_private (GTK_WIDGET_CLASS (klass),
//                                                    FooWidget, hello_button);
//      gtk_widget_class_bind_template_child_private (GTK_WIDGET_CLASS (klass),
//                                                    FooWidget, goodbye_button);
//    }
//
//    static void
//    foo_widget_init (FooWidget *widget)
//    {
//
//    }
//
//
// You can also use gtk_widget_class_bind_template_callback() to connect a
// signal callback defined in the template with a function visible in the scope
// of the class, e.g.
//
//    // the signal handler has the instance and user data swapped
//    // because of the swapped="yes" attribute in the template XML
//    static void
//    hello_button_clicked (FooWidget *self,
//                          GtkButton *button)
//    {
//      g_print ("Hello, world!\n");
//    }
//
//    static void
//    foo_widget_class_init (FooWidgetClass *klass)
//    {
//      // ...
//      gtk_widget_class_set_template_from_resource (GTK_WIDGET_CLASS (klass),
//                                                   "/com/example/ui/foowidget.ui");
//      gtk_widget_class_bind_template_callback (GTK_WIDGET_CLASS (klass), hello_button_clicked);
//    }
//
type Widget interface {
	gextras.Objector

	// ActionSetEnabled: enable or disable an action installed with
	// gtk_widget_class_install_action().
	ActionSetEnabled(actionName string, enabled bool)
	// Activate: for widgets that can be “activated” (buttons, menu items, etc.)
	// this function activates them. The activation will emit the signal set
	// using gtk_widget_class_set_activate_signal() during class initialization.
	//
	// Activation is what happens when you press Enter on a widget during key
	// navigation.
	//
	// If you wish to handle the activation keybinding yourself, it is
	// recommended to use gtk_widget_class_add_shortcut() with an action created
	// with gtk_signal_action_new().
	//
	// If @widget isn't activatable, the function returns false.
	Activate() bool
	// ActivateActionVariant: looks up the action in the action groups
	// associated with @widget and its ancestors, and activates it.
	//
	// If the action is in an action group added with
	// gtk_widget_insert_action_group(), the @name is expected to be prefixed
	// with the prefix that was used when the group was inserted.
	//
	// The arguments must match the actions expected parameter type, as returned
	// by g_action_get_parameter_type().
	ActivateActionVariant(name string, args *glib.Variant) bool
	// ActivateDefault: activate the default.activate action from @widget.
	ActivateDefault()
	// AddController: adds @controller to @widget so that it will receive
	// events. You will usually want to call this function right after creating
	// any kind of EventController.
	AddController(controller EventController)
	// AddCSSClass: adds @css_class to @widget. After calling this function,
	// @widget's style will match for @css_class, after the CSS matching rules.
	AddCSSClass(cssClass string)
	// AddMnemonicLabel: adds a widget to the list of mnemonic labels for this
	// widget. (See gtk_widget_list_mnemonic_labels()). Note the list of
	// mnemonic labels for the widget is cleared when the widget is destroyed,
	// so the caller must make sure to update its internal state at this point
	// as well, by using a connection to the Widget::destroy signal or a weak
	// notifier.
	AddMnemonicLabel(label Widget)
	// AddTickCallback: queues an animation frame update and adds a callback to
	// be called before each frame. Until the tick callback is removed, it will
	// be called frequently (usually at the frame rate of the output device or
	// as quickly as the application can be repainted, whichever is slower). For
	// this reason, is most suitable for handling graphics that change every
	// frame or every few frames. The tick callback does not automatically imply
	// a relayout or repaint. If you want a repaint or relayout, and aren’t
	// changing widget properties that would trigger that (for example, changing
	// the text of a Label), then you will have to call
	// gtk_widget_queue_resize() or gtk_widget_queue_draw() yourself.
	//
	// gdk_frame_clock_get_frame_time() should generally be used for timing
	// continuous animations and
	// gdk_frame_timings_get_predicted_presentation_time() if you are trying to
	// display isolated frames at particular times.
	//
	// This is a more convenient alternative to connecting directly to the
	// FrameClock::update signal of FrameClock, since you don't have to worry
	// about when a FrameClock is assigned to a widget.
	AddTickCallback(callback TickCallback) uint
	// Allocate: this function is only used by Widget subclasses, to assign a
	// size, position and (optionally) baseline to their child widgets.
	//
	// In this function, the allocation and baseline may be adjusted. The given
	// allocation will be forced to be bigger than the widget's minimum size, as
	// well as at least 0×0 in size.
	//
	// For a version that does not take a transform, see
	// gtk_widget_size_allocate()
	Allocate(width int, height int, baseline int, transform *gsk.Transform)
	// ChildFocus: this function is used by custom widget implementations; if
	// you're writing an app, you’d use gtk_widget_grab_focus() to move the
	// focus to a particular widget.
	//
	// gtk_widget_child_focus() is called by widgets as the user moves around
	// the window using keyboard shortcuts. @direction indicates what kind of
	// motion is taking place (up, down, left, right, tab forward, tab
	// backward). gtk_widget_child_focus() calls the WidgetClass.focus() vfunc;
	// widgets override this vfunc in order to implement appropriate focus
	// behavior.
	//
	// The default focus() vfunc for a widget should return true if moving in
	// @direction left the focus on a focusable location inside that widget, and
	// false if moving in @direction moved the focus outside the widget. If
	// returning true, widgets normally call gtk_widget_grab_focus() to place
	// the focus accordingly; if returning false, they don’t modify the current
	// focus location.
	ChildFocus(direction DirectionType) bool
	// ComputeBounds: computes the bounds for @widget in the coordinate space of
	// @target. FIXME: Explain what "bounds" are.
	//
	// If the operation is successful, true is returned. If @widget has no
	// bounds or the bounds cannot be expressed in @target's coordinate space
	// (for example if both widgets are in different windows), false is returned
	// and @bounds is set to the zero rectangle.
	//
	// It is valid for @widget and @target to be the same widget.
	ComputeBounds(target Widget) (outBounds graphene.Rect, ok bool)
	// ComputeExpand: computes whether a container should give this widget extra
	// space when possible. Containers should check this, rather than looking at
	// gtk_widget_get_hexpand() or gtk_widget_get_vexpand().
	//
	// This function already checks whether the widget is visible, so visibility
	// does not need to be checked separately. Non-visible widgets are not
	// expanded.
	//
	// The computed expand value uses either the expand setting explicitly set
	// on the widget itself, or, if none has been explicitly set, the widget may
	// expand if some of its children do.
	ComputeExpand(orientation Orientation) bool
	// ComputePoint: translates the given @point in @widget's coordinates to
	// coordinates relative to @target’s coordinate system. In order to perform
	// this operation, both widgets must share a common root.
	ComputePoint(target Widget, point *graphene.Point) (outPoint graphene.Point, ok bool)
	// ComputeTransform: computes a matrix suitable to describe a transformation
	// from @widget's coordinate system into @target's coordinate system.
	ComputeTransform(target Widget) (outTransform graphene.Matrix, ok bool)
	// Contains: tests if the point at (@x, @y) is contained in @widget.
	//
	// The coordinates for (@x, @y) must be in widget coordinates, so (0, 0) is
	// assumed to be the top left of @widget's content area.
	Contains(x float64, y float64) bool
	// CreatePangoContext: creates a new Context with the appropriate font map,
	// font options, font description, and base direction for drawing text for
	// this widget. See also gtk_widget_get_pango_context().
	CreatePangoContext() pango.Context
	// CreatePangoLayout: creates a new Layout with the appropriate font map,
	// font description, and base direction for drawing text for this widget.
	//
	// If you keep a Layout created in this way around, you need to re-create it
	// when the widget Context is replaced. This can be tracked by listening to
	// changes of the Widget:root property on the widget.
	CreatePangoLayout(text string) pango.Layout
	// DragCheckThreshold: checks to see if a mouse drag starting at (@start_x,
	// @start_y) and ending at (@current_x, @current_y) has passed the GTK drag
	// threshold, and thus should trigger the beginning of a drag-and-drop
	// operation.
	DragCheckThreshold(startX int, startY int, currentX int, currentY int) bool
	// ErrorBell: notifies the user about an input-related error on this widget.
	// If the Settings:gtk-error-bell setting is true, it calls
	// gdk_surface_beep(), otherwise it does nothing.
	//
	// Note that the effect of gdk_surface_beep() can be configured in many
	// ways, depending on the windowing backend and the desktop environment or
	// window manager that is used.
	ErrorBell()
	// AllocatedBaseline: returns the baseline that has currently been allocated
	// to @widget. This function is intended to be used when implementing
	// handlers for the WidgetClass.snapshot() function, and when allocating
	// child widgets in WidgetClass.size_allocate().
	AllocatedBaseline() int
	// AllocatedHeight: returns the height that has currently been allocated to
	// @widget.
	AllocatedHeight() int
	// AllocatedWidth: returns the width that has currently been allocated to
	// @widget.
	AllocatedWidth() int
	// Allocation: retrieves the widget’s allocation.
	//
	// Note, when implementing a layout container: a widget’s allocation will be
	// its “adjusted” allocation, that is, the widget’s parent typically calls
	// gtk_widget_size_allocate() with an allocation, and that allocation is
	// then adjusted (to handle margin and alignment for example) before
	// assignment to the widget. gtk_widget_get_allocation() returns the
	// adjusted allocation that was actually assigned to the widget. The
	// adjusted allocation is guaranteed to be completely contained within the
	// gtk_widget_size_allocate() allocation, however.
	//
	// So a layout container is guaranteed that its children stay inside the
	// assigned bounds, but not that they have exactly the bounds the container
	// assigned.
	Allocation() Allocation
	// Ancestor: gets the first ancestor of @widget with type @widget_type. For
	// example, `gtk_widget_get_ancestor (widget, GTK_TYPE_BOX)` gets the first
	// Box that’s an ancestor of @widget. No reference will be added to the
	// returned widget; it should not be unreferenced.
	//
	// Note that unlike gtk_widget_is_ancestor(), gtk_widget_get_ancestor()
	// considers @widget to be an ancestor of itself.
	Ancestor(widgetType externglib.Type) Widget
	// CanFocus: determines whether the input focus can enter @widget or any of
	// its children.
	//
	// See gtk_widget_set_focusable().
	CanFocus() bool
	// CanTarget: queries whether @widget can be the target of pointer events.
	CanTarget() bool
	// ChildVisible: gets the value set with gtk_widget_set_child_visible(). If
	// you feel a need to use this function, your code probably needs
	// reorganization.
	//
	// This function is only useful for container implementations and never
	// should be called by an application.
	ChildVisible() bool
	// Clipboard: this is a utility function to get the clipboard object for the
	// Display that @widget is using.
	//
	// Note that this function always works, even when @widget is not realized
	// yet.
	Clipboard() gdk.Clipboard
	// CSSClasses: returns the list of css classes applied to @widget.
	CSSClasses() []string
	// CSSName: returns the CSS name that is used for @self.
	CSSName() string
	// Cursor: queries the cursor set via gtk_widget_set_cursor(). See that
	// function for details.
	Cursor() gdk.Cursor
	// Direction: gets the reading direction for a particular widget. See
	// gtk_widget_set_direction().
	Direction() TextDirection
	// Display: get the Display for the toplevel window associated with this
	// widget. This function can only be called after the widget has been added
	// to a widget hierarchy with a Window at the top.
	//
	// In general, you should only create display specific resources when a
	// widget has been realized, and you should free those resources when the
	// widget is unrealized.
	Display() gdk.Display
	// FirstChild: returns the widgets first child.
	//
	// This API is primarily meant for widget implementations.
	FirstChild() Widget
	// FocusChild: returns the current focus child of @widget.
	FocusChild() Widget
	// FocusOnClick: returns whether the widget should grab focus when it is
	// clicked with the mouse. See gtk_widget_set_focus_on_click().
	FocusOnClick() bool
	// Focusable: determines whether @widget can own the input focus. See
	// gtk_widget_set_focusable().
	Focusable() bool
	// FontMap: gets the font map that has been set with
	// gtk_widget_set_font_map().
	FontMap() pango.FontMap
	// FontOptions: returns the #cairo_font_options_t used for Pango rendering.
	// When not set, the defaults font options for the Display will be used.
	FontOptions() *cairo.FontOptions
	// FrameClock: obtains the frame clock for a widget. The frame clock is a
	// global “ticker” that can be used to drive animations and repaints. The
	// most common reason to get the frame clock is to call
	// gdk_frame_clock_get_frame_time(), in order to get a time to use for
	// animating. For example you might record the start of the animation with
	// an initial value from gdk_frame_clock_get_frame_time(), and then update
	// the animation by calling gdk_frame_clock_get_frame_time() again during
	// each repaint.
	//
	// gdk_frame_clock_request_phase() will result in a new frame on the clock,
	// but won’t necessarily repaint any widgets. To repaint a widget, you have
	// to use gtk_widget_queue_draw() which invalidates the widget (thus
	// scheduling it to receive a draw on the next frame).
	// gtk_widget_queue_draw() will also end up requesting a frame on the
	// appropriate frame clock.
	//
	// A widget’s frame clock will not change while the widget is mapped.
	// Reparenting a widget (which implies a temporary unmap) can change the
	// widget’s frame clock.
	//
	// Unrealized widgets do not have a frame clock.
	FrameClock() gdk.FrameClock
	// Halign: gets the value of the Widget:halign property.
	//
	// For backwards compatibility reasons this method will never return
	// GTK_ALIGN_BASELINE, but instead it will convert it to GTK_ALIGN_FILL.
	// Baselines are not supported for horizontal alignment.
	Halign() Align
	// HasTooltip: returns the current value of the has-tooltip property. See
	// Widget:has-tooltip for more information.
	HasTooltip() bool
	// Height: returns the content height of the widget, as passed to its
	// size-allocate implementation. This is the size you should be using in
	// GtkWidgetClass.snapshot(). For pointer events, see gtk_widget_contains().
	Height() int
	// Hexpand: gets whether the widget would like any available extra
	// horizontal space. When a user resizes a Window, widgets with expand=TRUE
	// generally receive the extra space. For example, a list or scrollable area
	// or document in your window would often be set to expand.
	//
	// Containers should use gtk_widget_compute_expand() rather than this
	// function, to see whether a widget, or any of its children, has the expand
	// flag set. If any child of a widget wants to expand, the parent may ask to
	// expand also.
	//
	// This function only looks at the widget’s own hexpand flag, rather than
	// computing whether the entire widget tree rooted at this widget wants to
	// expand.
	Hexpand() bool
	// HexpandSet: gets whether gtk_widget_set_hexpand() has been used to
	// explicitly set the expand flag on this widget.
	//
	// If hexpand is set, then it overrides any computed expand value based on
	// child widgets. If hexpand is not set, then the expand value depends on
	// whether any children of the widget would like to expand.
	//
	// There are few reasons to use this function, but it’s here for
	// completeness and consistency.
	HexpandSet() bool
	// LastChild: returns the widgets last child.
	//
	// This API is primarily meant for widget implementations.
	LastChild() Widget
	// LayoutManager: retrieves the layout manager set using
	// gtk_widget_set_layout_manager().
	LayoutManager() LayoutManager
	// Mapped: whether the widget is mapped.
	Mapped() bool
	// MarginBottom: gets the value of the Widget:margin-bottom property.
	MarginBottom() int
	// MarginEnd: gets the value of the Widget:margin-end property.
	MarginEnd() int
	// MarginStart: gets the value of the Widget:margin-start property.
	MarginStart() int
	// MarginTop: gets the value of the Widget:margin-top property.
	MarginTop() int
	// Name: retrieves the name of a widget. See gtk_widget_set_name() for the
	// significance of widget names.
	Name() string
	// Native: returns the GtkNative widget that contains @widget, or nil if the
	// widget is not contained inside a widget tree with a native ancestor.
	//
	// Native widgets will return themselves here.
	Native() Native
	// NextSibling: returns the widgets next sibling.
	//
	// This API is primarily meant for widget implementations.
	NextSibling() Widget
	// Opacity: fetches the requested opacity for this widget. See
	// gtk_widget_set_opacity().
	Opacity() float64
	// Overflow: returns the value set via gtk_widget_set_overflow().
	Overflow() Overflow
	// PangoContext: gets a Context with the appropriate font map, font
	// description, and base direction for this widget. Unlike the context
	// returned by gtk_widget_create_pango_context(), this context is owned by
	// the widget (it can be used until the screen for the widget changes or the
	// widget is removed from its toplevel), and will be updated to match any
	// changes to the widget’s attributes. This can be tracked by listening to
	// changes of the Widget:root property on the widget.
	PangoContext() pango.Context
	// Parent: returns the parent widget of @widget.
	Parent() Widget
	// PreferredSize: retrieves the minimum and natural size of a widget, taking
	// into account the widget’s preference for height-for-width management.
	//
	// This is used to retrieve a suitable size by container widgets which do
	// not impose any restrictions on the child placement. It can be used to
	// deduce toplevel window and menu sizes as well as child widgets in
	// free-form containers such as GtkLayout.
	//
	// Handle with care. Note that the natural height of a height-for-width
	// widget will generally be a smaller size than the minimum height, since
	// the required height for the natural width is generally smaller than the
	// required height for the minimum width.
	//
	// Use gtk_widget_measure() if you want to support baseline alignment.
	PreferredSize() (minimumSize Requisition, naturalSize Requisition)
	// PrevSibling: returns the widgets previous sibling.
	//
	// This API is primarily meant for widget implementations.
	PrevSibling() Widget
	// PrimaryClipboard: this is a utility function to get the primary clipboard
	// object for the Display that @widget is using.
	//
	// Note that this function always works, even when @widget is not realized
	// yet.
	PrimaryClipboard() gdk.Clipboard
	// Realized: determines whether @widget is realized.
	Realized() bool
	// ReceivesDefault: determines whether @widget is always treated as the
	// default widget within its toplevel when it has the focus, even if another
	// widget is the default.
	//
	// See gtk_widget_set_receives_default().
	ReceivesDefault() bool
	// RequestMode: gets whether the widget prefers a height-for-width layout or
	// a width-for-height layout.
	//
	// Bin widgets generally propagate the preference of their child, container
	// widgets need to request something either in context of their children or
	// in context of their allocation capabilities.
	RequestMode() SizeRequestMode
	// Root: returns the Root widget of @widget or nil if the widget is not
	// contained inside a widget tree with a root widget.
	//
	// Root widgets will return themselves here.
	Root() Root
	// ScaleFactor: retrieves the internal scale factor that maps from window
	// coordinates to the actual device pixels. On traditional systems this is
	// 1, on high density outputs, it can be a higher value (typically 2).
	//
	// See gdk_surface_get_scale_factor().
	ScaleFactor() int
	// Sensitive: returns the widget’s sensitivity (in the sense of returning
	// the value that has been set using gtk_widget_set_sensitive()).
	//
	// The effective sensitivity of a widget is however determined by both its
	// own and its parent widget’s sensitivity. See gtk_widget_is_sensitive().
	Sensitive() bool
	// Settings: gets the settings object holding the settings used for this
	// widget.
	//
	// Note that this function can only be called when the Widget is attached to
	// a toplevel, since the settings object is specific to a particular
	// Display. If you want to monitor the widget for changes in its settings,
	// connect to notify::display.
	Settings() Settings
	// Size: returns the content width or height of the widget, depending on
	// @orientation. This is equivalent to calling gtk_widget_get_width() for
	// GTK_ORIENTATION_HORIZONTAL or gtk_widget_get_height() for
	// GTK_ORIENTATION_VERTICAL, but can be used when writing
	// orientation-independent code, such as when implementing Orientable
	// widgets.
	Size(orientation Orientation) int
	// SizeRequest: gets the size request that was explicitly set for the widget
	// using gtk_widget_set_size_request(). A value of -1 stored in @width or
	// @height indicates that that dimension has not been set explicitly and the
	// natural requisition of the widget will be used instead. See
	// gtk_widget_set_size_request(). To get the size a widget will actually
	// request, call gtk_widget_measure() instead of this function.
	SizeRequest() (width int, height int)
	// StateFlags: returns the widget state as a flag set. It is worth
	// mentioning that the effective GTK_STATE_FLAG_INSENSITIVE state will be
	// returned, that is, also based on parent insensitivity, even if @widget
	// itself is sensitive.
	//
	// Also note that if you are looking for a way to obtain the StateFlags to
	// pass to a StyleContext method, you should look at
	// gtk_style_context_get_state().
	StateFlags() StateFlags
	// StyleContext: returns the style context associated to @widget. The
	// returned object is guaranteed to be the same for the lifetime of @widget.
	StyleContext() StyleContext
	// TemplateChild: fetch an object build from the template XML for
	// @widget_type in this @widget instance.
	//
	// This will only report children which were previously declared with
	// gtk_widget_class_bind_template_child_full() or one of its variants.
	//
	// This function is only meant to be called for code which is private to the
	// @widget_type which declared the child and is meant for language bindings
	// which cannot easily make use of the GObject structure offsets.
	TemplateChild(widgetType externglib.Type, name string) gextras.Objector
	// TooltipMarkup: gets the contents of the tooltip for @widget set using
	// gtk_widget_set_tooltip_markup().
	TooltipMarkup() string
	// TooltipText: gets the contents of the tooltip for @widget.
	//
	// If the @widget's tooltip was set using gtk_widget_set_tooltip_markup(),
	// this function will return the escaped text.
	TooltipText() string
	// Valign: gets the value of the Widget:valign property.
	Valign() Align
	// Vexpand: gets whether the widget would like any available extra vertical
	// space.
	//
	// See gtk_widget_get_hexpand() for more detail.
	Vexpand() bool
	// VexpandSet: gets whether gtk_widget_set_vexpand() has been used to
	// explicitly set the expand flag on this widget.
	//
	// See gtk_widget_get_hexpand_set() for more detail.
	VexpandSet() bool
	// Visible: determines whether the widget is visible. If you want to take
	// into account whether the widget’s parent is also marked as visible, use
	// gtk_widget_is_visible() instead.
	//
	// This function does not check if the widget is obscured in any way.
	//
	// See gtk_widget_set_visible().
	Visible() bool
	// Width: returns the content width of the widget, as passed to its
	// size-allocate implementation. This is the size you should be using in
	// GtkWidgetClass.snapshot(). For pointer events, see gtk_widget_contains().
	Width() int
	// GrabFocus: causes @widget (or one of its descendents) to have the
	// keyboard focus for the Window it's inside.
	//
	// If @widget is not focusable, or its ::grab_focus implementation cannot
	// transfer the focus to a descendant of @widget that is focusable, it will
	// not take focus and false will be returned.
	//
	// Calling gtk_widget_grab_focus() on an already focused widget is allowed,
	// should not have an effect, and return true.
	GrabFocus() bool
	// HasCSSClass: returns whether @css_class is currently applied to @widget.
	HasCSSClass(cssClass string) bool
	// HasDefault: determines whether @widget is the current default widget
	// within its toplevel.
	HasDefault() bool
	// HasFocus: determines if the widget has the global input focus. See
	// gtk_widget_is_focus() for the difference between having the global input
	// focus, and only having the focus within a toplevel.
	HasFocus() bool
	// HasVisibleFocus: determines if the widget should show a visible
	// indication that it has the global input focus. This is a convenience
	// function that takes into account whether focus indication should
	// currently be shown in the toplevel window of @widget. See
	// gtk_window_get_focus_visible() for more information about focus
	// indication.
	//
	// To find out if the widget has the global input focus, use
	// gtk_widget_has_focus().
	HasVisibleFocus() bool
	// Hide: reverses the effects of gtk_widget_show(), causing the widget to be
	// hidden (invisible to the user).
	Hide()
	// InDestruction: returns whether the widget is currently being destroyed.
	// This information can sometimes be used to avoid doing unnecessary work.
	InDestruction() bool
	// InitTemplate: creates and initializes child widgets defined in templates.
	// This function must be called in the instance initializer for any class
	// which assigned itself a template using gtk_widget_class_set_template()
	//
	// It is important to call this function in the instance initializer of a
	// Widget subclass and not in #GObject.constructed() or
	// #GObject.constructor() for two reasons.
	//
	// One reason is that generally derived widgets will assume that parent
	// class composite widgets have been created in their instance initializers.
	//
	// Another reason is that when calling g_object_new() on a widget with
	// composite templates, it’s important to build the composite widgets before
	// the construct properties are set. Properties passed to g_object_new()
	// should take precedence over properties set in the private template XML.
	InitTemplate()
	// InsertActionGroup: inserts @group into @widget. Children of @widget that
	// implement Actionable can then be associated with actions in @group by
	// setting their “action-name” to @prefix.`action-name`.
	//
	// Note that inheritance is defined for individual actions. I.e. even if you
	// insert a group with prefix @prefix, actions with the same prefix will
	// still be inherited from the parent, unless the group contains an action
	// with the same name.
	//
	// If @group is nil, a previously inserted group for @name is removed from
	// @widget.
	InsertActionGroup(name string, group gio.ActionGroup)
	// InsertAfter: inserts @widget into the child widget list of @parent.
	//
	// It will be placed after @previous_sibling, or at the beginning if
	// @previous_sibling is nil.
	//
	// After calling this function, gtk_widget_get_prev_sibling(widget) will
	// return @previous_sibling.
	//
	// If @parent is already set as the parent widget of @widget, this function
	// can also be used to reorder @widget in the child widget list of @parent.
	//
	// This API is primarily meant for widget implementations; if you are just
	// using a widget, you *must* use its own API for adding children.
	InsertAfter(parent Widget, previousSibling Widget)
	// InsertBefore: inserts @widget into the child widget list of @parent.
	//
	// It will be placed before @next_sibling, or at the end if @next_sibling is
	// nil.
	//
	// After calling this function, gtk_widget_get_next_sibling(widget) will
	// return @next_sibling.
	//
	// If @parent is already set as the parent widget of @widget, this function
	// can also be used to reorder @widget in the child widget list of @parent.
	//
	// This API is primarily meant for widget implementations; if you are just
	// using a widget, you *must* use its own API for adding children.
	InsertBefore(parent Widget, nextSibling Widget)
	// IsAncestor: determines whether @widget is somewhere inside @ancestor,
	// possibly with intermediate containers.
	IsAncestor(ancestor Widget) bool
	// IsDrawable: determines whether @widget can be drawn to. A widget can be
	// drawn if it is mapped and visible.
	IsDrawable() bool
	// IsFocus: determines if the widget is the focus widget within its
	// toplevel. (This does not mean that the Widget:has-focus property is
	// necessarily set; Widget:has-focus will only be set if the toplevel widget
	// additionally has the global input focus.)
	IsFocus() bool
	// IsSensitive: returns the widget’s effective sensitivity, which means it
	// is sensitive itself and also its parent widget is sensitive
	IsSensitive() bool
	// IsVisible: determines whether the widget and all its parents are marked
	// as visible.
	//
	// This function does not check if the widget is obscured in any way.
	//
	// See also gtk_widget_get_visible() and gtk_widget_set_visible()
	IsVisible() bool
	// KeynavFailed: this function should be called whenever keyboard navigation
	// within a single widget hits a boundary. The function emits the
	// Widget::keynav-failed signal on the widget and its return value should be
	// interpreted in a way similar to the return value of
	// gtk_widget_child_focus():
	//
	// When true is returned, stay in the widget, the failed keyboard navigation
	// is OK and/or there is nowhere we can/should move the focus to.
	//
	// When false is returned, the caller should continue with keyboard
	// navigation outside the widget, e.g. by calling gtk_widget_child_focus()
	// on the widget’s toplevel.
	//
	// The default ::keynav-failed handler returns false for GTK_DIR_TAB_FORWARD
	// and GTK_DIR_TAB_BACKWARD. For the other values of DirectionType it
	// returns true.
	//
	// Whenever the default handler returns true, it also calls
	// gtk_widget_error_bell() to notify the user of the failed keyboard
	// navigation.
	//
	// A use case for providing an own implementation of ::keynav-failed (either
	// by connecting to it or by overriding it) would be a row of Entry widgets
	// where the user should be able to navigate the entire row with the cursor
	// keys, as e.g. known from user interfaces that require entering license
	// keys.
	KeynavFailed(direction DirectionType) bool
	// ListMnemonicLabels: returns a newly allocated list of the widgets,
	// normally labels, for which this widget is the target of a mnemonic (see
	// for example, gtk_label_set_mnemonic_widget()).
	//
	// The widgets in the list are not individually referenced. If you want to
	// iterate through the list and perform actions involving callbacks that
	// might destroy the widgets, you must call `g_list_foreach (result,
	// (GFunc)g_object_ref, NULL)` first, and then unref all the widgets
	// afterwards.
	ListMnemonicLabels() *glib.List
	// Map: this function is only for use in widget implementations. Causes a
	// widget to be mapped if it isn’t already.
	Map()
	// Measure: measures @widget in the orientation @orientation and for the
	// given @for_size. As an example, if @orientation is
	// GTK_ORIENTATION_HORIZONTAL and @for_size is 300, this functions will
	// compute the minimum and natural width of @widget if it is allocated at a
	// height of 300 pixels.
	//
	// See [GtkWidget’s geometry management section][geometry-management] for a
	// more details on implementing WidgetClass.measure().
	Measure(orientation Orientation, forSize int) (minimum int, natural int, minimumBaseline int, naturalBaseline int)
	// MnemonicActivate: emits the Widget::mnemonic-activate signal.
	MnemonicActivate(groupCycling bool) bool
	// ObserveChildren: returns a Model to track the children of @widget.
	//
	// Calling this function will enable extra internal bookkeeping to track
	// children and emit signals on the returned listmodel. It may slow down
	// operations a lot.
	//
	// Applications should try hard to avoid calling this function because of
	// the slowdowns.
	ObserveChildren() gio.ListModel
	// ObserveControllers: returns a Model to track the EventControllers of
	// @widget.
	//
	// Calling this function will enable extra internal bookkeeping to track
	// controllers and emit signals on the returned listmodel. It may slow down
	// operations a lot.
	//
	// Applications should try hard to avoid calling this function because of
	// the slowdowns.
	ObserveControllers() gio.ListModel
	// Pick: finds the descendant of @widget (including @widget itself) closest
	// to the screen at the point (@x, @y). The point must be given in widget
	// coordinates, so (0, 0) is assumed to be the top left of @widget's content
	// area.
	//
	// Usually widgets will return nil if the given coordinate is not contained
	// in @widget checked via gtk_widget_contains(). Otherwise they will
	// recursively try to find a child that does not return nil. Widgets are
	// however free to customize their picking algorithm.
	//
	// This function is used on the toplevel to determine the widget below the
	// mouse cursor for purposes of hover highlighting and delivering events.
	Pick(x float64, y float64, flags PickFlags) Widget
	// QueueAllocate: this function is only for use in widget implementations.
	//
	// Flags the widget for a rerun of the GtkWidgetClass::size_allocate
	// function. Use this function instead of gtk_widget_queue_resize() when the
	// @widget's size request didn't change but it wants to reposition its
	// contents.
	//
	// An example user of this function is gtk_widget_set_halign().
	QueueAllocate()
	// QueueDraw: schedules this widget to be redrawn in paint phase of the
	// current or the next frame. This means @widget's GtkWidgetClass.snapshot()
	// implementation will be called.
	QueueDraw()
	// QueueResize: this function is only for use in widget implementations.
	// Flags a widget to have its size renegotiated; should be called when a
	// widget for some reason has a new size request. For example, when you
	// change the text in a Label, Label queues a resize to ensure there’s
	// enough space for the new text.
	//
	// Note that you cannot call gtk_widget_queue_resize() on a widget from
	// inside its implementation of the GtkWidgetClass::size_allocate virtual
	// method. Calls to gtk_widget_queue_resize() from inside
	// GtkWidgetClass::size_allocate will be silently ignored.
	QueueResize()
	// Realize: creates the GDK (windowing system) resources associated with a
	// widget. Normally realization happens implicitly; if you show a widget and
	// all its parent containers, then the widget will be realized and mapped
	// automatically.
	//
	// Realizing a widget requires all the widget’s parent widgets to be
	// realized; calling gtk_widget_realize() realizes the widget’s parents in
	// addition to @widget itself. If a widget is not yet inside a toplevel
	// window when you realize it, bad things will happen.
	//
	// This function is primarily used in widget implementations, and isn’t very
	// useful otherwise. Many times when you think you might need it, a better
	// approach is to connect to a signal that will be called after the widget
	// is realized automatically, such as Widget::realize.
	Realize()
	// RemoveController: removes @controller from @widget, so that it doesn't
	// process events anymore. It should not be used again.
	//
	// Widgets will remove all event controllers automatically when they are
	// destroyed, there is normally no need to call this function.
	RemoveController(controller EventController)
	// RemoveCSSClass: removes @css_class from @widget. After this, the style of
	// @widget will stop matching for @css_class.
	RemoveCSSClass(cssClass string)
	// RemoveMnemonicLabel: removes a widget from the list of mnemonic labels
	// for this widget. (See gtk_widget_list_mnemonic_labels()). The widget must
	// have previously been added to the list with
	// gtk_widget_add_mnemonic_label().
	RemoveMnemonicLabel(label Widget)
	// RemoveTickCallback: removes a tick callback previously registered with
	// gtk_widget_add_tick_callback().
	RemoveTickCallback(id uint)
	// SetCanFocus: specifies whether the input focus can enter the widget or
	// any of its children.
	//
	// Applications should set @can_focus to false to mark a widget as for
	// pointer/touch use only.
	//
	// Note that having @can_focus be true is only one of the necessary
	// conditions for being focusable. A widget must also be sensitive and
	// focusable and not have an ancestor that is marked as not can-focus in
	// order to receive input focus.
	//
	// See gtk_widget_grab_focus() for actually setting the input focus on a
	// widget.
	SetCanFocus(canFocus bool)
	// SetCanTarget: sets whether @widget can be the target of pointer events.
	SetCanTarget(canTarget bool)
	// SetChildVisible: sets whether @widget should be mapped along with its
	// when its parent is mapped and @widget has been shown with
	// gtk_widget_show().
	//
	// The child visibility can be set for widget before it is added to a
	// container with gtk_widget_set_parent(), to avoid mapping children
	// unnecessary before immediately unmapping them. However it will be reset
	// to its default state of true when the widget is removed from a container.
	//
	// Note that changing the child visibility of a widget does not queue a
	// resize on the widget. Most of the time, the size of a widget is computed
	// from all visible children, whether or not they are mapped. If this is not
	// the case, the container can queue a resize itself.
	//
	// This function is only useful for container implementations and never
	// should be called by an application.
	SetChildVisible(childVisible bool)
	// SetCSSClasses: will clear all css classes applied to @widget and replace
	// them with @classes.
	SetCSSClasses(classes []string)
	// SetCursor: sets the cursor to be shown when pointer devices point towards
	// @widget.
	//
	// If the @cursor is NULL, @widget will use the cursor inherited from the
	// parent widget.
	SetCursor(cursor gdk.Cursor)
	// SetCursorFromName: sets a named cursor to be shown when pointer devices
	// point towards @widget.
	//
	// This is a utility function that creates a cursor via
	// gdk_cursor_new_from_name() and then sets it on @widget with
	// gtk_widget_set_cursor(). See those 2 functions for details.
	//
	// On top of that, this function allows @name to be nil, which will do the
	// same as calling gtk_widget_set_cursor() with a nil cursor.
	SetCursorFromName(name string)
	// SetDirection: sets the reading direction on a particular widget. This
	// direction controls the primary direction for widgets containing text, and
	// also the direction in which the children of a container are packed. The
	// ability to set the direction is present in order so that correct
	// localization into languages with right-to-left reading directions can be
	// done. Generally, applications will let the default reading direction
	// present, except for containers where the containers are arranged in an
	// order that is explicitly visual rather than logical (such as buttons for
	// text justification).
	//
	// If the direction is set to GTK_TEXT_DIR_NONE, then the value set by
	// gtk_widget_set_default_direction() will be used.
	SetDirection(dir TextDirection)
	// SetFocusChild: set @child as the current focus child of @widget. The
	// previous focus child will be unset.
	//
	// This function is only suitable for widget implementations. If you want a
	// certain widget to get the input focus, call gtk_widget_grab_focus() on
	// it.
	SetFocusChild(child Widget)
	// SetFocusOnClick: sets whether the widget should grab focus when it is
	// clicked with the mouse. Making mouse clicks not grab focus is useful in
	// places like toolbars where you don’t want the keyboard focus removed from
	// the main area of the application.
	SetFocusOnClick(focusOnClick bool)
	// SetFocusable: specifies whether @widget can own the input focus.
	//
	// Widget implementations should set @focusable to true in their init()
	// function if they want to receive keyboard input.
	//
	// Note that having @focusable be true is only one of the necessary
	// conditions for being focusable. A widget must also be sensitive and
	// can-focus and not have an ancestor that is marked as not can-focus in
	// order to receive input focus.
	//
	// See gtk_widget_grab_focus() for actually setting the input focus on a
	// widget.
	SetFocusable(focusable bool)
	// SetFontMap: sets the font map to use for Pango rendering. The font map is
	// the object that is used to look up fonts. Setting a custom font map can
	// be useful in special situations, e.g. when you need to add
	// application-specific fonts to the set of available fonts.
	//
	// When not set, the widget will inherit the font map from its parent.
	SetFontMap(fontMap pango.FontMap)
	// SetFontOptions: sets the #cairo_font_options_t used for Pango rendering
	// in this widget. When not set, the default font options for the Display
	// will be used.
	SetFontOptions(options *cairo.FontOptions)
	// SetHalign: sets the horizontal alignment of @widget. See the
	// Widget:halign property.
	SetHalign(align Align)
	// SetHasTooltip: sets the has-tooltip property on @widget to @has_tooltip.
	// See Widget:has-tooltip for more information.
	SetHasTooltip(hasTooltip bool)
	// SetHexpand: sets whether the widget would like any available extra
	// horizontal space. When a user resizes a Window, widgets with expand=TRUE
	// generally receive the extra space. For example, a list or scrollable area
	// or document in your window would often be set to expand.
	//
	// Call this function to set the expand flag if you would like your widget
	// to become larger horizontally when the window has extra room.
	//
	// By default, widgets automatically expand if any of their children want to
	// expand. (To see if a widget will automatically expand given its current
	// children and state, call gtk_widget_compute_expand(). A container can
	// decide how the expandability of children affects the expansion of the
	// container by overriding the compute_expand virtual method on Widget.).
	//
	// Setting hexpand explicitly with this function will override the automatic
	// expand behavior.
	//
	// This function forces the widget to expand or not to expand, regardless of
	// children. The override occurs because gtk_widget_set_hexpand() sets the
	// hexpand-set property (see gtk_widget_set_hexpand_set()) which causes the
	// widget’s hexpand value to be used, rather than looking at children and
	// widget state.
	SetHexpand(expand bool)
	// SetHexpandSet: sets whether the hexpand flag (see
	// gtk_widget_get_hexpand()) will be used.
	//
	// The hexpand-set property will be set automatically when you call
	// gtk_widget_set_hexpand() to set hexpand, so the most likely reason to use
	// this function would be to unset an explicit expand flag.
	//
	// If hexpand is set, then it overrides any computed expand value based on
	// child widgets. If hexpand is not set, then the expand value depends on
	// whether any children of the widget would like to expand.
	//
	// There are few reasons to use this function, but it’s here for
	// completeness and consistency.
	SetHexpandSet(set bool)
	// SetLayoutManager: sets the layout manager delegate instance that provides
	// an implementation for measuring and allocating the children of @widget.
	SetLayoutManager(layoutManager LayoutManager)
	// SetMarginBottom: sets the bottom margin of @widget. See the
	// Widget:margin-bottom property.
	SetMarginBottom(margin int)
	// SetMarginEnd: sets the end margin of @widget. See the Widget:margin-end
	// property.
	SetMarginEnd(margin int)
	// SetMarginStart: sets the start margin of @widget. See the
	// Widget:margin-start property.
	SetMarginStart(margin int)
	// SetMarginTop: sets the top margin of @widget. See the Widget:margin-top
	// property.
	SetMarginTop(margin int)
	// SetName: widgets can be named, which allows you to refer to them from a
	// CSS file. You can apply a style to widgets with a particular name in the
	// CSS file. See the documentation for the CSS syntax (on the same page as
	// the docs for StyleContext).
	//
	// Note that the CSS syntax has certain special characters to delimit and
	// represent elements in a selector (period, #, >, *...), so using these
	// will make your widget impossible to match by name. Any combination of
	// alphanumeric symbols, dashes and underscores will suffice.
	SetName(name string)
	// SetOpacity: request the @widget to be rendered partially transparent,
	// with opacity 0 being fully transparent and 1 fully opaque. (Opacity
	// values are clamped to the [0,1] range).
	//
	// Opacity works on both toplevel widgets and child widgets, although there
	// are some limitations: For toplevel widgets, applying opacity depends on
	// the capabilities of the windowing system. On X11, this has any effect
	// only on X displays with a compositing manager, see
	// gdk_display_is_composited(). On Windows and Wayland it should always
	// work, although setting a window’s opacity after the window has been shown
	// may cause some flicker.
	//
	// Note that the opacity is inherited through inclusion — if you set a
	// toplevel to be partially translucent, all of its content will appear
	// translucent, since it is ultimatively rendered on that toplevel. The
	// opacity value itself is not inherited by child widgets (since that would
	// make widgets deeper in the hierarchy progressively more translucent). As
	// a consequence, Popovers and other Native widgets with their own surface
	// will use their own opacity value, and thus by default appear
	// non-translucent, even if they are attached to a toplevel that is
	// translucent.
	SetOpacity(opacity float64)
	// SetOverflow: sets how @widget treats content that is drawn outside the
	// widget's content area. See the definition of Overflow for details.
	//
	// This setting is provided for widget implementations and should not be
	// used by application code.
	//
	// The default value is GTK_OVERFLOW_VISIBLE.
	SetOverflow(overflow Overflow)
	// SetParent: this function is useful only when implementing subclasses of
	// Widget.
	//
	// Sets @parent as the parent widget of @widget, and takes care of some
	// details such as updating the state and style of the child to reflect its
	// new location and resizing the parent. The opposite function is
	// gtk_widget_unparent().
	SetParent(parent Widget)
	// SetReceivesDefault: specifies whether @widget will be treated as the
	// default widget within its toplevel when it has the focus, even if another
	// widget is the default.
	SetReceivesDefault(receivesDefault bool)
	// SetSensitive: sets the sensitivity of a widget. A widget is sensitive if
	// the user can interact with it. Insensitive widgets are “grayed out” and
	// the user can’t interact with them. Insensitive widgets are known as
	// “inactive”, “disabled”, or “ghosted” in some other toolkits.
	SetSensitive(sensitive bool)
	// SetSizeRequest: sets the minimum size of a widget; that is, the widget’s
	// size request will be at least @width by @height. You can use this
	// function to force a widget to be larger than it normally would be.
	//
	// In most cases, gtk_window_set_default_size() is a better choice for
	// toplevel windows than this function; setting the default size will still
	// allow users to shrink the window. Setting the size request will force
	// them to leave the window at least as large as the size request. When
	// dealing with window sizes, gtk_window_set_geometry_hints() can be a
	// useful function as well.
	//
	// Note the inherent danger of setting any fixed size - themes, translations
	// into other languages, different fonts, and user action can all change the
	// appropriate size for a given widget. So, it's basically impossible to
	// hardcode a size that will always be correct.
	//
	// The size request of a widget is the smallest size a widget can accept
	// while still functioning well and drawing itself correctly. However in
	// some strange cases a widget may be allocated less than its requested
	// size, and in many cases a widget may be allocated more space than it
	// requested.
	//
	// If the size request in a given direction is -1 (unset), then the
	// “natural” size request of the widget will be used instead.
	//
	// The size request set here does not include any margin from the Widget
	// properties margin-left, margin-right, margin-top, and margin-bottom, but
	// it does include pretty much all other padding or border properties set by
	// any subclass of Widget.
	SetSizeRequest(width int, height int)
	// SetStateFlags: this function is for use in widget implementations. Turns
	// on flag values in the current widget state (insensitive, prelighted,
	// etc.).
	//
	// This function accepts the values GTK_STATE_FLAG_DIR_LTR and
	// GTK_STATE_FLAG_DIR_RTL but ignores them. If you want to set the widget's
	// direction, use gtk_widget_set_direction().
	SetStateFlags(flags StateFlags, clear bool)
	// SetTooltipMarkup: sets @markup as the contents of the tooltip, which is
	// marked up with the [Pango text markup language][PangoMarkupFormat].
	//
	// This function will take care of setting the Widget:has-tooltip as a side
	// effect, and of the default handler for the Widget::query-tooltip signal.
	//
	// See also the Widget:tooltip-markup property and gtk_tooltip_set_markup().
	SetTooltipMarkup(markup string)
	// SetTooltipText: sets @text as the contents of the tooltip.
	//
	// If @text contains any markup, it will be escaped.
	//
	// This function will take care of setting Widget:has-tooltip as a side
	// effect, and of the default handler for the Widget::query-tooltip signal.
	//
	// See also the Widget:tooltip-text property and gtk_tooltip_set_text().
	SetTooltipText(text string)
	// SetValign: sets the vertical alignment of @widget. See the Widget:valign
	// property.
	SetValign(align Align)
	// SetVexpand: sets whether the widget would like any available extra
	// vertical space.
	//
	// See gtk_widget_set_hexpand() for more detail.
	SetVexpand(expand bool)
	// SetVexpandSet: sets whether the vexpand flag (see
	// gtk_widget_get_vexpand()) will be used.
	//
	// See gtk_widget_set_hexpand_set() for more detail.
	SetVexpandSet(set bool)
	// SetVisible: sets the visibility state of @widget. Note that setting this
	// to true doesn’t mean the widget is actually viewable, see
	// gtk_widget_get_visible().
	//
	// This function simply calls gtk_widget_show() or gtk_widget_hide() but is
	// nicer to use when the visibility of the widget depends on some condition.
	SetVisible(visible bool)
	// ShouldLayout: returns whether @widget should contribute to the measuring
	// and allocation of its parent. This is false for invisible children, but
	// also for children that have their own surface.
	ShouldLayout() bool
	// Show: flags a widget to be displayed. Any widget that isn’t shown will
	// not appear on the screen.
	//
	// Remember that you have to show the containers containing a widget, in
	// addition to the widget itself, before it will appear onscreen.
	//
	// When a toplevel container is shown, it is immediately realized and
	// mapped; other shown widgets are realized and mapped when their toplevel
	// container is realized and mapped.
	Show()
	// SizeAllocate: this is a simple form of gtk_widget_allocate() that takes
	// the new position of @widget as part of @allocation.
	SizeAllocate(allocation *Allocation, baseline int)
	// SnapshotChild: when a widget receives a call to the snapshot function, it
	// must send synthetic WidgetClass.snapshot() calls to all children. This
	// function provides a convenient way of doing this. A widget, when it
	// receives a call to its WidgetClass.snapshot() function, calls
	// gtk_widget_snapshot_child() once for each child, passing in the @snapshot
	// the widget received.
	//
	// gtk_widget_snapshot_child() takes care of translating the origin of
	// @snapshot, and deciding whether the child needs to be snapshot.
	//
	// This function does nothing for children that implement Native.
	SnapshotChild(child Widget, snapshot Snapshot)
	// TranslateCoordinates: translate coordinates relative to @src_widget’s
	// allocation to coordinates relative to @dest_widget’s allocations. In
	// order to perform this operation, both widget must share a common
	// toplevel.
	TranslateCoordinates(destWidget Widget, srcX float64, srcY float64) (destX float64, destY float64, ok bool)
	// TriggerTooltipQuery: triggers a tooltip query on the display where the
	// toplevel of @widget is located.
	TriggerTooltipQuery()
	// Unmap: this function is only for use in widget implementations. Causes a
	// widget to be unmapped if it’s currently mapped.
	Unmap()
	// Unparent: this function is only for use in widget implementations. It
	// should be called by parent widgets to dissociate @widget from the parent,
	// typically in dispose.
	Unparent()
	// Unrealize: this function is only useful in widget implementations. Causes
	// a widget to be unrealized (frees all GDK resources associated with the
	// widget).
	Unrealize()
	// UnsetStateFlags: this function is for use in widget implementations.
	// Turns off flag values for the current widget state (insensitive,
	// prelighted, etc.). See gtk_widget_set_state_flags().
	UnsetStateFlags(flags StateFlags)
}

type widget struct {
	externglib.InitiallyUnowned
}

func wrapWidget(obj *externglib.Object) Widget {
	return widget{externglib.InitiallyUnowned{obj}}
}

func marshalWidget(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func (w widget) ActionSetEnabled(actionName string, enabled bool)

func (w widget) Activate() bool

func (w widget) ActivateActionVariant(name string, args *glib.Variant) bool

func (w widget) ActivateDefault()

func (w widget) AddController(controller EventController)

func (w widget) AddCSSClass(cssClass string)

func (w widget) AddMnemonicLabel(label Widget)

func (w widget) AddTickCallback(callback TickCallback) uint

func (w widget) Allocate(width int, height int, baseline int, transform *gsk.Transform)

func (w widget) ChildFocus(direction DirectionType) bool

func (w widget) ComputeBounds(target Widget) (outBounds graphene.Rect, ok bool)

func (w widget) ComputeExpand(orientation Orientation) bool

func (w widget) ComputePoint(target Widget, point *graphene.Point) (outPoint graphene.Point, ok bool)

func (w widget) ComputeTransform(target Widget) (outTransform graphene.Matrix, ok bool)

func (w widget) Contains(x float64, y float64) bool

func (w widget) CreatePangoContext() pango.Context

func (w widget) CreatePangoLayout(text string) pango.Layout

func (w widget) DragCheckThreshold(startX int, startY int, currentX int, currentY int) bool

func (w widget) ErrorBell()

func (w widget) AllocatedBaseline() int

func (w widget) AllocatedHeight() int

func (w widget) AllocatedWidth() int

func (w widget) Allocation() Allocation

func (w widget) Ancestor(widgetType externglib.Type) Widget

func (w widget) CanFocus() bool

func (w widget) CanTarget() bool

func (w widget) ChildVisible() bool

func (w widget) Clipboard() gdk.Clipboard

func (w widget) CSSClasses() []string

func (w widget) CSSName() string

func (w widget) Cursor() gdk.Cursor

func (w widget) Direction() TextDirection

func (w widget) Display() gdk.Display

func (w widget) FirstChild() Widget

func (w widget) FocusChild() Widget

func (w widget) FocusOnClick() bool

func (w widget) Focusable() bool

func (w widget) FontMap() pango.FontMap

func (w widget) FontOptions() *cairo.FontOptions

func (w widget) FrameClock() gdk.FrameClock

func (w widget) Halign() Align

func (w widget) HasTooltip() bool

func (w widget) Height() int

func (w widget) Hexpand() bool

func (w widget) HexpandSet() bool

func (w widget) LastChild() Widget

func (w widget) LayoutManager() LayoutManager

func (w widget) Mapped() bool

func (w widget) MarginBottom() int

func (w widget) MarginEnd() int

func (w widget) MarginStart() int

func (w widget) MarginTop() int

func (w widget) Name() string

func (w widget) Native() Native

func (w widget) NextSibling() Widget

func (w widget) Opacity() float64

func (w widget) Overflow() Overflow

func (w widget) PangoContext() pango.Context

func (w widget) Parent() Widget

func (w widget) PreferredSize() (minimumSize Requisition, naturalSize Requisition)

func (w widget) PrevSibling() Widget

func (w widget) PrimaryClipboard() gdk.Clipboard

func (w widget) Realized() bool

func (w widget) ReceivesDefault() bool

func (w widget) RequestMode() SizeRequestMode

func (w widget) Root() Root

func (w widget) ScaleFactor() int

func (w widget) Sensitive() bool

func (w widget) Settings() Settings

func (w widget) Size(orientation Orientation) int

func (w widget) SizeRequest() (width int, height int)

func (w widget) StateFlags() StateFlags

func (w widget) StyleContext() StyleContext

func (w widget) TemplateChild(widgetType externglib.Type, name string) gextras.Objector

func (w widget) TooltipMarkup() string

func (w widget) TooltipText() string

func (w widget) Valign() Align

func (w widget) Vexpand() bool

func (w widget) VexpandSet() bool

func (w widget) Visible() bool

func (w widget) Width() int

func (w widget) GrabFocus() bool

func (w widget) HasCSSClass(cssClass string) bool

func (w widget) HasDefault() bool

func (w widget) HasFocus() bool

func (w widget) HasVisibleFocus() bool

func (w widget) Hide()

func (w widget) InDestruction() bool

func (w widget) InitTemplate()

func (w widget) InsertActionGroup(name string, group gio.ActionGroup)

func (w widget) InsertAfter(parent Widget, previousSibling Widget)

func (w widget) InsertBefore(parent Widget, nextSibling Widget)

func (w widget) IsAncestor(ancestor Widget) bool

func (w widget) IsDrawable() bool

func (w widget) IsFocus() bool

func (w widget) IsSensitive() bool

func (w widget) IsVisible() bool

func (w widget) KeynavFailed(direction DirectionType) bool

func (w widget) ListMnemonicLabels() *glib.List

func (w widget) Map()

func (w widget) Measure(orientation Orientation, forSize int) (minimum int, natural int, minimumBaseline int, naturalBaseline int)

func (w widget) MnemonicActivate(groupCycling bool) bool

func (w widget) ObserveChildren() gio.ListModel

func (w widget) ObserveControllers() gio.ListModel

func (w widget) Pick(x float64, y float64, flags PickFlags) Widget

func (w widget) QueueAllocate()

func (w widget) QueueDraw()

func (w widget) QueueResize()

func (w widget) Realize()

func (w widget) RemoveController(controller EventController)

func (w widget) RemoveCSSClass(cssClass string)

func (w widget) RemoveMnemonicLabel(label Widget)

func (w widget) RemoveTickCallback(id uint)

func (w widget) SetCanFocus(canFocus bool)

func (w widget) SetCanTarget(canTarget bool)

func (w widget) SetChildVisible(childVisible bool)

func (w widget) SetCSSClasses(classes []string)

func (w widget) SetCursor(cursor gdk.Cursor)

func (w widget) SetCursorFromName(name string)

func (w widget) SetDirection(dir TextDirection)

func (w widget) SetFocusChild(child Widget)

func (w widget) SetFocusOnClick(focusOnClick bool)

func (w widget) SetFocusable(focusable bool)

func (w widget) SetFontMap(fontMap pango.FontMap)

func (w widget) SetFontOptions(options *cairo.FontOptions)

func (w widget) SetHalign(align Align)

func (w widget) SetHasTooltip(hasTooltip bool)

func (w widget) SetHexpand(expand bool)

func (w widget) SetHexpandSet(set bool)

func (w widget) SetLayoutManager(layoutManager LayoutManager)

func (w widget) SetMarginBottom(margin int)

func (w widget) SetMarginEnd(margin int)

func (w widget) SetMarginStart(margin int)

func (w widget) SetMarginTop(margin int)

func (w widget) SetName(name string)

func (w widget) SetOpacity(opacity float64)

func (w widget) SetOverflow(overflow Overflow)

func (w widget) SetParent(parent Widget)

func (w widget) SetReceivesDefault(receivesDefault bool)

func (w widget) SetSensitive(sensitive bool)

func (w widget) SetSizeRequest(width int, height int)

func (w widget) SetStateFlags(flags StateFlags, clear bool)

func (w widget) SetTooltipMarkup(markup string)

func (w widget) SetTooltipText(text string)

func (w widget) SetValign(align Align)

func (w widget) SetVexpand(expand bool)

func (w widget) SetVexpandSet(set bool)

func (w widget) SetVisible(visible bool)

func (w widget) ShouldLayout() bool

func (w widget) Show()

func (w widget) SizeAllocate(allocation *Allocation, baseline int)

func (w widget) SnapshotChild(child Widget, snapshot Snapshot)

func (w widget) TranslateCoordinates(destWidget Widget, srcX float64, srcY float64) (destX float64, destY float64, ok bool)

func (w widget) TriggerTooltipQuery()

func (w widget) Unmap()

func (w widget) Unparent()

func (w widget) Unrealize()

func (w widget) UnsetStateFlags(flags StateFlags)

// WidgetPaintable: gtkWidgetPaintable is an implementation of the Paintable
// interface that allows displaying the contents of a Widget.
//
// GtkWidgetPaintable will also take care of the widget not being in a state
// where it can be drawn (like when it isn't shown) and just draw nothing or
// where it does not have a size (like when it is hidden) and report no size in
// that case.
//
// Of course, GtkWidgetPaintable allows you to monitor widgets for size changes
// by emitting the Paintable::invalidate-size signal whenever the size of the
// widget changes as well as for visual changes by emitting the
// Paintable::invalidate-contents signal whenever the widget changes.
//
// You can of course use a GtkWidgetPaintable everywhere a Paintable is allowed,
// including using it on a Picture (or one of its parents) that it was set on
// itself via gtk_picture_set_paintable(). The paintable will take care of
// recursion when this happens. If you do this however, ensure the
// Picture:can-shrink property is set to true or you might end up with an
// infinitely growing widget.
type WidgetPaintable interface {
	gextras.Objector

	// Widget: returns the widget that is observed or nil if none.
	Widget() Widget
	// SetWidget: sets the widget that should be observed.
	SetWidget(widget Widget)
}

type widgetPaintable struct {
	*externglib.Object
}

func wrapWidgetPaintable(obj *externglib.Object) WidgetPaintable {
	return widgetPaintable{*externglib.Object{obj}}
}

func marshalWidgetPaintable(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewWidgetPaintable(widget Widget) WidgetPaintable

func (w widgetPaintable) Widget() Widget

func (w widgetPaintable) SetWidget(widget Widget)

// Window: a GtkWindow is a toplevel window which can contain other widgets.
// Windows normally have decorations that are under the control of the windowing
// system and allow the user to manipulate the window (resize it, move it, close
// it,...).
//
//
// GtkWindow as GtkBuildable
//
// The GtkWindow implementation of the Buildable interface supports setting a
// child as the titlebar by specifying “titlebar” as the “type” attribute of a
// <child> element.
//
// CSS nodes
//
//    window.background
//    ├── <child>
//    ╰── <titlebar child>.titlebar [.default-decoration]
//
// GtkWindow has a main CSS node with name window and style class .background.
//
// Style classes that are typically used with the main CSS node are .csd (when
// client-side decorations are in use), .solid-csd (for client-side decorations
// without invisible borders), .ssd (used by mutter when rendering server-side
// decorations). GtkWindow also represents window states with the following
// style classes on the main node: .tiled, .maximized, .fullscreen. Specialized
// types of window often add their own discriminating style classes, such as
// .popup or .tooltip.
//
// Generally, some CSS properties don't make sense on the toplevel window node,
// such as margins or padding. When client-side decorations without invisible
// borders are in use (i.e. the .solid-csd style class is added to the main
// window node), the CSS border of the toplevel window is used for resize drags.
// In the .csd case, the shadow area outside of the window can be used to resize
// it.
//
// GtkWindow adds the .titlebar and .default-decoration style classes to the
// widget that is added as a titlebar child.
//
//
// Accessibility
//
// GtkWindow uses the GTK_ACCESSIBLE_ROLE_WINDOW role.
type Window interface {
	Widget

	// Close: requests that the window is closed, similar to what happens when a
	// window manager close button is clicked.
	//
	// This function can be used with close buttons in custom titlebars.
	Close()
	// Destroy: drop the internal reference GTK holds on toplevel windows.
	Destroy()
	// Fullscreen: asks to place @window in the fullscreen state.
	//
	// Note that you shouldn’t assume the window is definitely full screen
	// afterward, because other entities (e.g. the user or [window
	// manager][gtk-X11-arch]) could unfullscreen it again, and not all window
	// managers honor requests to fullscreen windows.
	//
	// You can track the result of this operation via the Toplevel:state
	// property, or by listening to notifications of the Window:fullscreened
	// property.
	Fullscreen()
	// FullscreenOnMonitor: asks to place @window in the fullscreen state on the
	// given @monitor.
	//
	// Note that you shouldn't assume the window is definitely full screen
	// afterward, or that the windowing system allows fullscreen windows on any
	// given monitor.
	//
	// You can track the result of this operation via the Toplevel:state
	// property, or by listening to notifications of the Window:fullscreened
	// property.
	FullscreenOnMonitor(monitor gdk.Monitor)
	// Application: gets the Application associated with the window (if any).
	Application() Application
	// Child: gets the child widget of @window.
	Child() Widget
	// Decorated: returns whether the window has been set to have decorations
	// such as a title bar via gtk_window_set_decorated().
	Decorated() bool
	// DefaultSize: gets the default size of the window. A value of 0 for the
	// width or height indicates that a default size has not been explicitly set
	// for that dimension, so the “natural” size of the window will be used.
	DefaultSize() (width int, height int)
	// DefaultWidget: returns the default widget for @window.
	//
	// See gtk_window_set_default_widget() for more details.
	DefaultWidget() Widget
	// Deletable: returns whether the window has been set to have a close button
	// via gtk_window_set_deletable().
	Deletable() bool
	// DestroyWithParent: returns whether the window will be destroyed with its
	// transient parent. See gtk_window_set_destroy_with_parent ().
	DestroyWithParent() bool
	// Focus: retrieves the current focused widget within the window. Note that
	// this is the widget that would have the focus if the toplevel window
	// focused; if the toplevel window is not focused then `gtk_widget_has_focus
	// (widget)` will not be true for the widget.
	Focus() Widget
	// FocusVisible: gets the value of the Window:focus-visible property.
	FocusVisible() bool
	// Group: returns the group for @window or the default group, if @window is
	// nil or if @window does not have an explicit window group.
	Group() WindowGroup
	// HideOnClose: returns whether the window will be hidden when the close
	// button is clicked.
	HideOnClose() bool
	// IconName: returns the name of the themed icon for the window, see
	// gtk_window_set_icon_name().
	IconName() string
	// MnemonicsVisible: gets the value of the Window:mnemonics-visible
	// property.
	MnemonicsVisible() bool
	// Modal: returns whether the window is modal. See gtk_window_set_modal().
	Modal() bool
	// Resizable: gets the value set by gtk_window_set_resizable().
	Resizable() bool
	// Title: retrieves the title of the window. See gtk_window_set_title().
	Title() string
	// Titlebar: returns the custom titlebar that has been set with
	// gtk_window_set_titlebar().
	Titlebar() Widget
	// TransientFor: fetches the transient parent for this window. See
	// gtk_window_set_transient_for().
	TransientFor() Window
	// HasGroup: returns whether @window has an explicit window group.
	HasGroup() bool
	// IsActive: returns whether the window is part of the current active
	// toplevel. (That is, the toplevel window receiving keystrokes.) The return
	// value is true if the window is active toplevel itself. You might use this
	// function if you wanted to draw a widget differently in an active window
	// from a widget in an inactive window.
	IsActive() bool
	// IsFullscreen: retrieves the current fullscreen state of @window.
	//
	// Note that since fullscreening is ultimately handled by the window manager
	// and happens asynchronously to an application request, you shouldn’t
	// assume the return value of this function changing immediately (or at
	// all), as an effect of calling gtk_window_fullscreen() or
	// gtk_window_unfullscreen().
	//
	// If the window isn't yet mapped, the value returned will whether the
	// initial requested state is fullscreen.
	IsFullscreen() bool
	// IsMaximized: retrieves the current maximized state of @window.
	//
	// Note that since maximization is ultimately handled by the window manager
	// and happens asynchronously to an application request, you shouldn’t
	// assume the return value of this function changing immediately (or at
	// all), as an effect of calling gtk_window_maximize() or
	// gtk_window_unmaximize().
	//
	// If the window isn't yet mapped, the value returned will whether the
	// initial requested state is maximized.
	IsMaximized() bool
	// Maximize: asks to maximize @window, so that it fills the screen.
	//
	// Note that you shouldn’t assume the window is definitely maximized
	// afterward, because other entities (e.g. the user or [window
	// manager][gtk-X11-arch]) could unmaximize it again, and not all window
	// managers support maximization.
	//
	// It’s permitted to call this function before showing a window, in which
	// case the window will be maximized when it appears onscreen initially.
	//
	// You can track the result of this operation via the Toplevel:state
	// property, or by listening to notifications on the Window:maximized
	// property.
	Maximize()
	// Minimize: asks to minimize the specified @window.
	//
	// Note that you shouldn’t assume the window is definitely minimized
	// afterward, because the windowing system might not support this
	// functionality; other entities (e.g. the user or the [window
	// manager][gtk-X11-arch]) could unminimize it again, or there may not be a
	// window manager in which case minimization isn’t possible, etc.
	//
	// It’s permitted to call this function before showing a window, in which
	// case the window will be minimized before it ever appears onscreen.
	//
	// You can track result of this operation via the Toplevel:state property.
	Minimize()
	// Present: presents a window to the user. This function should not be used
	// as when it is called, it is too late to gather a valid timestamp to allow
	// focus stealing prevention to work correctly.
	Present()
	// PresentWithTime: presents a window to the user. This may mean raising the
	// window in the stacking order, unminimizing it, moving it to the current
	// desktop, and/or giving it the keyboard focus, possibly dependent on the
	// user’s platform, window manager, and preferences.
	//
	// If @window is hidden, this function calls gtk_widget_show() as well.
	//
	// This function should be used when the user tries to open a window that’s
	// already open. Say for example the preferences dialog is currently open,
	// and the user chooses Preferences from the menu a second time; use
	// gtk_window_present() to move the already-open dialog where the user can
	// see it.
	//
	// Presents a window to the user in response to a user interaction. The
	// timestamp should be gathered when the window was requested to be shown
	// (when clicking a link for example), rather than once the window is ready
	// to be shown.
	PresentWithTime(timestamp uint32)
	// SetApplication: sets or unsets the Application associated with the
	// window.
	//
	// The application will be kept alive for at least as long as it has any
	// windows associated with it (see g_application_hold() for a way to keep it
	// alive without windows).
	//
	// Normally, the connection between the application and the window will
	// remain until the window is destroyed, but you can explicitly remove it by
	// setting the @application to nil.
	//
	// This is equivalent to calling gtk_application_remove_window() and/or
	// gtk_application_add_window() on the old/new applications as relevant.
	SetApplication(application Application)
	// SetChild: sets the child widget of @window.
	SetChild(child Widget)
	// SetDecorated: by default, windows are decorated with a title bar, resize
	// controls, etc. Some [window managers][gtk-X11-arch] allow GTK to disable
	// these decorations, creating a borderless window. If you set the decorated
	// property to false using this function, GTK will do its best to convince
	// the window manager not to decorate the window. Depending on the system,
	// this function may not have any effect when called on a window that is
	// already visible, so you should call it before calling gtk_widget_show().
	//
	// On Windows, this function always works, since there’s no window manager
	// policy involved.
	SetDecorated(setting bool)
	// SetDefaultSize: sets the default size of a window. If the window’s
	// “natural” size (its size request) is larger than the default, the default
	// will be ignored.
	//
	// Unlike gtk_widget_set_size_request(), which sets a size request for a
	// widget and thus would keep users from shrinking the window, this function
	// only sets the initial size, just as if the user had resized the window
	// themselves. Users can still shrink the window again as they normally
	// would. Setting a default size of -1 means to use the “natural” default
	// size (the size request of the window).
	//
	// The default size of a window only affects the first time a window is
	// shown; if a window is hidden and re-shown, it will remember the size it
	// had prior to hiding, rather than using the default size.
	//
	// Windows can’t actually be 0x0 in size, they must be at least 1x1, but
	// passing 0 for @width and @height is OK, resulting in a 1x1 default size.
	//
	// If you use this function to reestablish a previously saved window size,
	// note that the appropriate size to save is the one returned by
	// gtk_window_get_default_size(). Using the window allocation directly will
	// not work in all circumstances and can lead to growing or shrinking
	// windows.
	SetDefaultSize(width int, height int)
	// SetDefaultWidget: the default widget is the widget that’s activated when
	// the user presses Enter in a dialog (for example). This function sets or
	// unsets the default widget for a Window.
	SetDefaultWidget(defaultWidget Widget)
	// SetDeletable: by default, windows have a close button in the window
	// frame. Some [window managers][gtk-X11-arch] allow GTK to disable this
	// button. If you set the deletable property to false using this function,
	// GTK will do its best to convince the window manager not to show a close
	// button. Depending on the system, this function may not have any effect
	// when called on a window that is already visible, so you should call it
	// before calling gtk_widget_show().
	//
	// On Windows, this function always works, since there’s no window manager
	// policy involved.
	SetDeletable(setting bool)
	// SetDestroyWithParent: if @setting is true, then destroying the transient
	// parent of @window will also destroy @window itself. This is useful for
	// dialogs that shouldn’t persist beyond the lifetime of the main window
	// they're associated with, for example.
	SetDestroyWithParent(setting bool)
	// SetDisplay: sets the Display where the @window is displayed; if the
	// window is already mapped, it will be unmapped, and then remapped on the
	// new display.
	SetDisplay(display gdk.Display)
	// SetFocus: if @focus is not the current focus widget, and is focusable,
	// sets it as the focus widget for the window. If @focus is nil, unsets the
	// focus widget for this window. To set the focus to a particular widget in
	// the toplevel, it is usually more convenient to use
	// gtk_widget_grab_focus() instead of this function.
	SetFocus(focus Widget)
	// SetFocusVisible: sets the Window:focus-visible property.
	SetFocusVisible(setting bool)
	// SetHideOnClose: if @setting is true, then clicking the close button on
	// the window will not destroy it, but only hide it.
	SetHideOnClose(setting bool)
	// SetIconName: sets the icon for the window from a named themed icon. See
	// the docs for IconTheme for more details. On some platforms, the window
	// icon is not used at all.
	//
	// Note that this has nothing to do with the WM_ICON_NAME property which is
	// mentioned in the ICCCM.
	SetIconName(name string)
	// SetMnemonicsVisible: sets the Window:mnemonics-visible property.
	SetMnemonicsVisible(setting bool)
	// SetModal: sets a window modal or non-modal. Modal windows prevent
	// interaction with other windows in the same application. To keep modal
	// dialogs on top of main application windows, use
	// gtk_window_set_transient_for() to make the dialog transient for the
	// parent; most [window managers][gtk-X11-arch] will then disallow lowering
	// the dialog below the parent.
	SetModal(modal bool)
	// SetResizable: sets whether the user can resize a window.
	//
	// Windows are user resizable by default.
	SetResizable(resizable bool)
	// SetStartupID: startup notification identifiers are used by desktop
	// environment to track application startup, to provide user feedback and
	// other features. This function changes the corresponding property on the
	// underlying GdkSurface. Normally, startup identifier is managed
	// automatically and you should only use this function in special cases like
	// transferring focus from other processes. You should use this function
	// before calling gtk_window_present() or any equivalent function generating
	// a window map event.
	//
	// This function is only useful on X11, not with other GTK targets.
	SetStartupID(startupID string)
	// SetTitle: sets the title of the Window. The title of a window will be
	// displayed in its title bar; on the X Window System, the title bar is
	// rendered by the [window manager][gtk-X11-arch], so exactly how the title
	// appears to users may vary according to a user’s exact configuration. The
	// title should help a user distinguish this window from other windows they
	// may have open. A good title might include the application name and
	// current document filename, for example. document filename, for example.
	//
	// Passing nil does the same as setting the title to an empty string.
	SetTitle(title string)
	// SetTitlebar: sets a custom titlebar for @window.
	//
	// A typical widget used here is HeaderBar, as it provides various features
	// expected of a titlebar while allowing the addition of child widgets to
	// it.
	//
	// If you set a custom titlebar, GTK will do its best to convince the window
	// manager not to put its own titlebar on the window. Depending on the
	// system, this function may not work for a window that is already visible,
	// so you set the titlebar before calling gtk_widget_show().
	SetTitlebar(titlebar Widget)
	// SetTransientFor: dialog windows should be set transient for the main
	// application window they were spawned from. This allows [window
	// managers][gtk-X11-arch] to e.g. keep the dialog on top of the main
	// window, or center the dialog over the main window.
	// gtk_dialog_new_with_buttons() and other convenience functions in GTK will
	// sometimes call gtk_window_set_transient_for() on your behalf.
	//
	// Passing nil for @parent unsets the current transient window.
	//
	// On Windows, this function puts the child window on top of the parent,
	// much as the window manager would have done on X.
	SetTransientFor(parent Window)
	// Unfullscreen: asks to remove the fullscreen state for @window, and return
	// to its previous state.
	//
	// Note that you shouldn’t assume the window is definitely not full screen
	// afterward, because other entities (e.g. the user or [window
	// manager][gtk-X11-arch]) could fullscreen it again, and not all window
	// managers honor requests to unfullscreen windows; normally the window will
	// end up restored to its normal state. Just don’t write code that crashes
	// if not.
	//
	// You can track the result of this operation via the Toplevel:state
	// property, or by listening to notifications of the Window:fullscreened
	// property.
	Unfullscreen()
	// Unmaximize: asks to unmaximize @window.
	//
	// Note that you shouldn’t assume the window is definitely unmaximized
	// afterward, because other entities (e.g. the user or [window
	// manager][gtk-X11-arch]) could maximize it again, and not all window
	// managers honor requests to unmaximize.
	//
	// You can track the result of this operation via the Toplevel:state
	// property, or by listening to notifications on the Window:maximized
	// property.
	Unmaximize()
	// Unminimize: asks to unminimize the specified @window.
	//
	// Note that you shouldn’t assume the window is definitely unminimized
	// afterward, because the windowing system might not support this
	// functionality; other entities (e.g. the user or the [window
	// manager][gtk-X11-arch]) could minimize it again, or there may not be a
	// window manager in which case minimization isn’t possible, etc.
	//
	// You can track result of this operation via the Toplevel:state property.
	Unminimize()
}

type window struct {
	widget
}

func wrapWindow(obj *externglib.Object) Window {
	return window{widget{externglib.InitiallyUnowned{obj}}}
}

func marshalWindow(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewWindow() Window

func (w window) Close()

func (w window) Destroy()

func (w window) Fullscreen()

func (w window) FullscreenOnMonitor(monitor gdk.Monitor)

func (w window) Application() Application

func (w window) Child() Widget

func (w window) Decorated() bool

func (w window) DefaultSize() (width int, height int)

func (w window) DefaultWidget() Widget

func (w window) Deletable() bool

func (w window) DestroyWithParent() bool

func (w window) Focus() Widget

func (w window) FocusVisible() bool

func (w window) Group() WindowGroup

func (w window) HideOnClose() bool

func (w window) IconName() string

func (w window) MnemonicsVisible() bool

func (w window) Modal() bool

func (w window) Resizable() bool

func (w window) Title() string

func (w window) Titlebar() Widget

func (w window) TransientFor() Window

func (w window) HasGroup() bool

func (w window) IsActive() bool

func (w window) IsFullscreen() bool

func (w window) IsMaximized() bool

func (w window) Maximize()

func (w window) Minimize()

func (w window) Present()

func (w window) PresentWithTime(timestamp uint32)

func (w window) SetApplication(application Application)

func (w window) SetChild(child Widget)

func (w window) SetDecorated(setting bool)

func (w window) SetDefaultSize(width int, height int)

func (w window) SetDefaultWidget(defaultWidget Widget)

func (w window) SetDeletable(setting bool)

func (w window) SetDestroyWithParent(setting bool)

func (w window) SetDisplay(display gdk.Display)

func (w window) SetFocus(focus Widget)

func (w window) SetFocusVisible(setting bool)

func (w window) SetHideOnClose(setting bool)

func (w window) SetIconName(name string)

func (w window) SetMnemonicsVisible(setting bool)

func (w window) SetModal(modal bool)

func (w window) SetResizable(resizable bool)

func (w window) SetStartupID(startupID string)

func (w window) SetTitle(title string)

func (w window) SetTitlebar(titlebar Widget)

func (w window) SetTransientFor(parent Window)

func (w window) Unfullscreen()

func (w window) Unmaximize()

func (w window) Unminimize()

// WindowControls: gtkWindowControls shows window frame controls, such as
// minimize, maximize and close buttons, and the window icon.
//
// WindowControls only displays start or end side of the controls (see
// WindowControls:side), so it's intended to be always used in pair with another
// WindowControls using the opposite side, for example:
//
//
//    <object class="GtkBox">
//      <child>
//        <object class="GtkWindowControls">
//          <property name="side">start</property>
//        </object>
//      </child>
//
//      ...
//
//      <child>
//        <object class="GtkWindowControls">
//          <property name="side">end</property>
//        </object>
//      </child>
//    </object>
//
//
// CSS nodes
//
//    windowcontrols
//    ├── [image.icon]
//    ├── [button.minimize]
//    ├── [button.maximize]
//    ╰── [button.close]
//
// A WindowControls' CSS node is called windowcontrols. It contains subnodes
// corresponding to each title button. Which of the title buttons exist and
// where they are placed exactly depends on the desktop environment and
// WindowControls:decoration-layout value.
//
// When WindowControls:empty is true, it gets the .empty style class.
//
//
// Accessibility
//
// GtkWindowHandle uses the GTK_ACCESSIBLE_ROLE_GROUP role.
type WindowControls interface {
	Widget

	// DecorationLayout: gets the decoration layout set with
	// gtk_window_controls_set_decoration_layout().
	DecorationLayout() string
	// Empty: gets whether the widget has any window buttons.
	Empty() bool
	// Side: gets the side set with gtk_window_controls_set_side().
	Side() PackType
	// SetDecorationLayout: sets the decoration layout for the title buttons,
	// overriding the Settings:gtk-decoration-layout setting.
	//
	// The format of the string is button names, separated by commas. A colon
	// separates the buttons that should appear on the left from those on the
	// right. Recognized button names are minimize, maximize, close and icon
	// (the window icon).
	//
	// For example, “icon:minimize,maximize,close” specifies a icon on the left,
	// and minimize, maximize and close buttons on the right.
	//
	// If WindowControls:side value is @GTK_PACK_START, @self will display the
	// part before the colon, otherwise after that.
	SetDecorationLayout(layout string)
	// SetSide: sets the side for @self, determining which part of decoration
	// layout it uses.
	//
	// See gtk_window_controls_set_decoration_layout()
	SetSide(side PackType)
}

type windowControls struct {
	widget
}

func wrapWindowControls(obj *externglib.Object) WindowControls {
	return windowControls{widget{externglib.InitiallyUnowned{obj}}}
}

func marshalWindowControls(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewWindowControls(side PackType) WindowControls

func (w windowControls) DecorationLayout() string

func (w windowControls) Empty() bool

func (w windowControls) Side() PackType

func (w windowControls) SetDecorationLayout(layout string)

func (w windowControls) SetSide(side PackType)

// WindowGroup: a WindowGroup restricts the effect of grabs to windows in the
// same group, thereby making window groups almost behave like separate
// applications.
//
// A window can be a member in at most one window group at a time. Windows that
// have not been explicitly assigned to a group are implicitly treated like
// windows of the default window group.
//
// GtkWindowGroup objects are referenced by each window in the group, so once
// you have added all windows to a GtkWindowGroup, you can drop the initial
// reference to the window group with g_object_unref(). If the windows in the
// window group are subsequently destroyed, then they will be removed from the
// window group and drop their references on the window group; when all window
// have been removed, the window group will be freed.
type WindowGroup interface {
	gextras.Objector

	// AddWindow: adds a window to a WindowGroup.
	AddWindow(window Window)
	// ListWindows: returns a list of the Windows that belong to @window_group.
	ListWindows() *glib.List
	// RemoveWindow: removes a window from a WindowGroup.
	RemoveWindow(window Window)
}

type windowGroup struct {
	*externglib.Object
}

func wrapWindowGroup(obj *externglib.Object) WindowGroup {
	return windowGroup{*externglib.Object{obj}}
}

func marshalWindowGroup(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewWindowGroup() WindowGroup

func (w windowGroup) AddWindow(window Window)

func (w windowGroup) ListWindows() *glib.List

func (w windowGroup) RemoveWindow(window Window)

// WindowHandle: gtkWindowHandle is a titlebar area widget. When added into a
// window, it can be dragged to move the window, and handles right click, double
// click and middle click as expected of a titlebar.
//
//
// CSS nodes
//
// WindowHandle has a single CSS node with the name `windowhandle`.
//
//
// Accessibility
//
// GtkWindowHandle uses the GTK_ACCESSIBLE_ROLE_GROUP role.
type WindowHandle interface {
	Widget

	// Child: gets the child widget of @self.
	Child() Widget
	// SetChild: sets the child widget of @self.
	SetChild(child Widget)
}

type windowHandle struct {
	widget
}

func wrapWindowHandle(obj *externglib.Object) WindowHandle {
	return windowHandle{widget{externglib.InitiallyUnowned{obj}}}
}

func marshalWindowHandle(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewWindowHandle() WindowHandle

func (w windowHandle) Child() Widget

func (w windowHandle) SetChild(child Widget)
