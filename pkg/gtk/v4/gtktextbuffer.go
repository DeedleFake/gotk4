// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"unsafe"

	"github.com/diamondburned/gotk4/internal/gextras"
	"github.com/diamondburned/gotk4/pkg/gdk/v4"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config:
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <gtk/gtk.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_text_buffer_get_type()), F: marshalTextBuffer},
	})
}

// TextBuffer: you may wish to begin by reading the [text widget conceptual
// overview][TextWidget] which gives an overview of all the objects and data
// types related to the text widget and how they work together.
type TextBuffer interface {
	gextras.Objector

	// AddMark adds the mark at position @where. The mark must not be added to
	// another buffer, and if its name is not nil then there must not be another
	// mark in the buffer with the same name.
	//
	// Emits the TextBuffer::mark-set signal as notification of the mark's
	// initial placement.
	AddMark(mark TextMark, where *TextIter)
	// AddSelectionClipboard adds @clipboard to the list of clipboards in which
	// the selection contents of @buffer are available. In most cases,
	// @clipboard will be the Clipboard returned by
	// gtk_widget_get_primary_clipboard() for a view of @buffer.
	AddSelectionClipboard(clipboard gdk.Clipboard)
	// ApplyTag emits the “apply-tag” signal on @buffer. The default handler for
	// the signal applies @tag to the given range. @start and @end do not have
	// to be in order.
	ApplyTag(tag TextTag, start *TextIter, end *TextIter)
	// ApplyTagByName calls gtk_text_tag_table_lookup() on the buffer’s tag
	// table to get a TextTag, then calls gtk_text_buffer_apply_tag().
	ApplyTagByName(name string, start *TextIter, end *TextIter)
	// Backspace performs the appropriate action as if the user hit the delete
	// key with the cursor at the position specified by @iter. In the normal
	// case a single character will be deleted, but when combining accents are
	// involved, more than one character can be deleted, and when precomposed
	// character and accent combinations are involved, less than one character
	// will be deleted.
	//
	// Because the buffer is modified, all outstanding iterators become invalid
	// after calling this function; however, the @iter will be re-initialized to
	// point to the location where text was deleted.
	Backspace(iter *TextIter, interactive bool, defaultEditable bool) bool
	// BeginIrreversibleAction denotes the beginning of an action that may not
	// be undone. This will cause any previous operations in the undo/redo queue
	// to be cleared.
	//
	// This should be paired with a call to
	// gtk_text_buffer_end_irreversible_action() after the irreversible action
	// has completed.
	//
	// You may nest calls to gtk_text_buffer_begin_irreversible_action() and
	// gtk_text_buffer_end_irreversible_action() pairs.
	BeginIrreversibleAction()
	// BeginUserAction: called to indicate that the buffer operations between
	// here and a call to gtk_text_buffer_end_user_action() are part of a single
	// user-visible operation. The operations between
	// gtk_text_buffer_begin_user_action() and gtk_text_buffer_end_user_action()
	// can then be grouped when creating an undo stack. TextBuffer maintains a
	// count of calls to gtk_text_buffer_begin_user_action() that have not been
	// closed with a call to gtk_text_buffer_end_user_action(), and emits the
	// “begin-user-action” and “end-user-action” signals only for the outermost
	// pair of calls. This allows you to build user actions from other user
	// actions.
	//
	// The “interactive” buffer mutation functions, such as
	// gtk_text_buffer_insert_interactive(), automatically call begin/end user
	// action around the buffer operations they perform, so there's no need to
	// add extra calls if you user action consists solely of a single call to
	// one of those functions.
	BeginUserAction()
	// CopyClipboard copies the currently-selected text to a clipboard.
	CopyClipboard(clipboard gdk.Clipboard)
	// CreateChildAnchor: this is a convenience function which simply creates a
	// child anchor with gtk_text_child_anchor_new() and inserts it into the
	// buffer with gtk_text_buffer_insert_child_anchor(). The new anchor is
	// owned by the buffer; no reference count is returned to the caller of
	// gtk_text_buffer_create_child_anchor().
	CreateChildAnchor(iter *TextIter) TextChildAnchor
	// CreateMark creates a mark at position @where. If @mark_name is nil, the
	// mark is anonymous; otherwise, the mark can be retrieved by name using
	// gtk_text_buffer_get_mark(). If a mark has left gravity, and text is
	// inserted at the mark’s current location, the mark will be moved to the
	// left of the newly-inserted text. If the mark has right gravity
	// (@left_gravity = false), the mark will end up on the right of
	// newly-inserted text. The standard left-to-right cursor is a mark with
	// right gravity (when you type, the cursor stays on the right side of the
	// text you’re typing).
	//
	// The caller of this function does not own a reference to the returned
	// TextMark, so you can ignore the return value if you like. Marks are owned
	// by the buffer and go away when the buffer does.
	//
	// Emits the TextBuffer::mark-set signal as notification of the mark's
	// initial placement.
	CreateMark(markName string, where *TextIter, leftGravity bool) TextMark
	// CutClipboard copies the currently-selected text to a clipboard, then
	// deletes said text if it’s editable.
	CutClipboard(clipboard gdk.Clipboard, defaultEditable bool)
	// Delete deletes text between @start and @end. The order of @start and @end
	// is not actually relevant; gtk_text_buffer_delete() will reorder them.
	// This function actually emits the “delete-range” signal, and the default
	// handler of that signal deletes the text. Because the buffer is modified,
	// all outstanding iterators become invalid after calling this function;
	// however, the @start and @end will be re-initialized to point to the
	// location where text was deleted.
	Delete(start *TextIter, end *TextIter)
	// DeleteInteractive deletes all editable text in the given range. Calls
	// gtk_text_buffer_delete() for each editable sub-range of [@start,@end).
	// @start and @end are revalidated to point to the location of the last
	// deleted range, or left untouched if no text was deleted.
	DeleteInteractive(startIter *TextIter, endIter *TextIter, defaultEditable bool) bool
	// DeleteMark deletes @mark, so that it’s no longer located anywhere in the
	// buffer. Removes the reference the buffer holds to the mark, so if you
	// haven’t called g_object_ref() on the mark, it will be freed. Even if the
	// mark isn’t freed, most operations on @mark become invalid, until it gets
	// added to a buffer again with gtk_text_buffer_add_mark(). Use
	// gtk_text_mark_get_deleted() to find out if a mark has been removed from
	// its buffer. The TextBuffer::mark-deleted signal will be emitted as
	// notification after the mark is deleted.
	DeleteMark(mark TextMark)
	// DeleteMarkByName deletes the mark named @name; the mark must exist. See
	// gtk_text_buffer_delete_mark() for details.
	DeleteMarkByName(name string)
	// DeleteSelection deletes the range between the “insert” and
	// “selection_bound” marks, that is, the currently-selected text. If
	// @interactive is true, the editability of the selection will be considered
	// (users can’t delete uneditable text).
	DeleteSelection(interactive bool, defaultEditable bool) bool
	// EndIrreversibleAction denotes the end of an action that may not be
	// undone. This will cause any previous operations in the undo/redo queue to
	// be cleared.
	//
	// This should be called after completing modifications to the text buffer
	// after gtk_text_buffer_begin_irreversible_action() was called.
	//
	// You may nest calls to gtk_text_buffer_begin_irreversible_action() and
	// gtk_text_buffer_end_irreversible_action() pairs.
	EndIrreversibleAction()
	// EndUserAction: should be paired with a call to
	// gtk_text_buffer_begin_user_action(). See that function for a full
	// explanation.
	EndUserAction()
	// Bounds retrieves the first and last iterators in the buffer, i.e. the
	// entire buffer lies within the range [@start,@end).
	Bounds() (start TextIter, end TextIter)
	// CanRedo gets whether there is a redoable action in the history.
	CanRedo() bool
	// CanUndo gets whether there is an undoable action in the history.
	CanUndo() bool
	// CharCount gets the number of characters in the buffer; note that
	// characters and bytes are not the same, you can’t e.g. expect the contents
	// of the buffer in string form to be this many bytes long. The character
	// count is cached, so this function is very fast.
	CharCount() int
	// EnableUndo gets whether the buffer is saving modifications to the buffer
	// to allow for undo and redo actions.
	//
	// See gtk_text_buffer_begin_irreversible_action() and
	// gtk_text_buffer_end_irreversible_action() to create changes to the buffer
	// that cannot be undone.
	EnableUndo() bool
	// EndIter initializes @iter with the “end iterator,” one past the last
	// valid character in the text buffer. If dereferenced with
	// gtk_text_iter_get_char(), the end iterator has a character value of 0.
	// The entire buffer lies in the range from the first position in the buffer
	// (call gtk_text_buffer_get_start_iter() to get character position 0) to
	// the end iterator.
	EndIter() TextIter
	// HasSelection indicates whether the buffer has some text currently
	// selected.
	HasSelection() bool
	// GetInsert returns the mark that represents the cursor (insertion point).
	// Equivalent to calling gtk_text_buffer_get_mark() to get the mark named
	// “insert”, but very slightly more efficient, and involves less typing.
	GetInsert() TextMark
	// IterAtChildAnchor obtains the location of @anchor within @buffer.
	IterAtChildAnchor(anchor TextChildAnchor) TextIter
	// IterAtLine initializes @iter to the start of the given line. If
	// @line_number is greater than the number of lines in the @buffer, the end
	// iterator is returned.
	IterAtLine(lineNumber int) (iter TextIter, ok bool)
	// IterAtLineIndex obtains an iterator pointing to @byte_index within the
	// given line. @byte_index must be the start of a UTF-8 character. Note
	// bytes, not characters; UTF-8 may encode one character as multiple bytes.
	//
	// If @line_number is greater than the number of lines in the @buffer, the
	// end iterator is returned. And if @byte_index is off the end of the line,
	// the iterator at the end of the line is returned.
	IterAtLineIndex(lineNumber int, byteIndex int) (iter TextIter, ok bool)
	// IterAtLineOffset obtains an iterator pointing to @char_offset within the
	// given line. Note characters, not bytes; UTF-8 may encode one character as
	// multiple bytes.
	//
	// Before the 3.20 version, it was not allowed to pass an invalid location.
	//
	// If @line_number is greater than the number of lines in the @buffer, the
	// end iterator is returned. And if @char_offset is off the end of the line,
	// the iterator at the end of the line is returned.
	IterAtLineOffset(lineNumber int, charOffset int) (iter TextIter, ok bool)
	// IterAtMark initializes @iter with the current position of @mark.
	IterAtMark(mark TextMark) TextIter
	// IterAtOffset initializes @iter to a position @char_offset chars from the
	// start of the entire buffer. If @char_offset is -1 or greater than the
	// number of characters in the buffer, @iter is initialized to the end
	// iterator, the iterator one past the last valid character in the buffer.
	IterAtOffset(charOffset int) TextIter
	// LineCount obtains the number of lines in the buffer. This value is
	// cached, so the function is very fast.
	LineCount() int
	// Mark returns the mark named @name in buffer @buffer, or nil if no such
	// mark exists in the buffer.
	Mark(name string) TextMark
	// MaxUndoLevels gets the maximum number of undo levels to perform. If 0,
	// unlimited undo actions may be performed. Note that this may have a memory
	// usage impact as it requires storing an additional copy of the inserted or
	// removed text within the text buffer.
	MaxUndoLevels() uint
	// Modified indicates whether the buffer has been modified since the last
	// call to gtk_text_buffer_set_modified() set the modification flag to
	// false. Used for example to enable a “save” function in a text editor.
	Modified() bool
	// SelectionBound returns the mark that represents the selection bound.
	// Equivalent to calling gtk_text_buffer_get_mark() to get the mark named
	// “selection_bound”, but very slightly more efficient, and involves less
	// typing.
	//
	// The currently-selected text in @buffer is the region between the
	// “selection_bound” and “insert” marks. If “selection_bound” and “insert”
	// are in the same place, then there is no current selection.
	// gtk_text_buffer_get_selection_bounds() is another convenient function for
	// handling the selection, if you just want to know whether there’s a
	// selection and what its bounds are.
	SelectionBound() TextMark
	// SelectionBounds returns true if some text is selected; places the bounds
	// of the selection in @start and @end (if the selection has length 0, then
	// @start and @end are filled in with the same value). @start and @end will
	// be in ascending order. If @start and @end are NULL, then they are not
	// filled in, but the return value still indicates whether text is selected.
	SelectionBounds() (start TextIter, end TextIter, ok bool)
	// SelectionContent: get a content provider for this buffer. It can be used
	// to make the content of @buffer available in a Clipboard, see
	// gdk_clipboard_set_content().
	SelectionContent() gdk.ContentProvider
	// Slice returns the text in the range [@start,@end). Excludes undisplayed
	// text (text marked with tags that set the invisibility attribute) if
	// @include_hidden_chars is false. The returned string includes a 0xFFFC
	// character whenever the buffer contains embedded images, so byte and
	// character indexes into the returned string do correspond to byte and
	// character indexes into the buffer. Contrast with
	// gtk_text_buffer_get_text(). Note that 0xFFFC can occur in normal text as
	// well, so it is not a reliable indicator that a paintable or widget is in
	// the buffer.
	Slice(start *TextIter, end *TextIter, includeHiddenChars bool) string
	// StartIter: initialized @iter with the first position in the text buffer.
	// This is the same as using gtk_text_buffer_get_iter_at_offset() to get the
	// iter at character offset 0.
	StartIter() TextIter
	// TagTable: get the TextTagTable associated with this buffer.
	TagTable() TextTagTable
	// Text returns the text in the range [@start,@end). Excludes undisplayed
	// text (text marked with tags that set the invisibility attribute) if
	// @include_hidden_chars is false. Does not include characters representing
	// embedded images, so byte and character indexes into the returned string
	// do not correspond to byte and character indexes into the buffer. Contrast
	// with gtk_text_buffer_get_slice().
	Text(start *TextIter, end *TextIter, includeHiddenChars bool) string
	// Insert inserts @len bytes of @text at position @iter. If @len is -1,
	// @text must be nul-terminated and will be inserted in its entirety. Emits
	// the “insert-text” signal; insertion actually occurs in the default
	// handler for the signal. @iter is invalidated when insertion occurs
	// (because the buffer contents change), but the default signal handler
	// revalidates it to point to the end of the inserted text.
	Insert(iter *TextIter, text string, len int)
	// InsertAtCursor: simply calls gtk_text_buffer_insert(), using the current
	// cursor position as the insertion point.
	InsertAtCursor(text string, len int)
	// InsertChildAnchor inserts a child widget anchor into the text buffer at
	// @iter. The anchor will be counted as one character in character counts,
	// and when obtaining the buffer contents as a string, will be represented
	// by the Unicode “object replacement character” 0xFFFC. Note that the
	// “slice” variants for obtaining portions of the buffer as a string include
	// this character for child anchors, but the “text” variants do not. E.g.
	// see gtk_text_buffer_get_slice() and gtk_text_buffer_get_text(). Consider
	// gtk_text_buffer_create_child_anchor() as a more convenient alternative to
	// this function. The buffer will add a reference to the anchor, so you can
	// unref it after insertion.
	InsertChildAnchor(iter *TextIter, anchor TextChildAnchor)
	// InsertInteractive: like gtk_text_buffer_insert(), but the insertion will
	// not occur if @iter is at a non-editable location in the buffer. Usually
	// you want to prevent insertions at ineditable locations if the insertion
	// results from a user action (is interactive).
	//
	// @default_editable indicates the editability of text that doesn't have a
	// tag affecting editability applied to it. Typically the result of
	// gtk_text_view_get_editable() is appropriate here.
	InsertInteractive(iter *TextIter, text string, len int, defaultEditable bool) bool
	// InsertInteractiveAtCursor calls gtk_text_buffer_insert_interactive() at
	// the cursor position.
	//
	// @default_editable indicates the editability of text that doesn't have a
	// tag affecting editability applied to it. Typically the result of
	// gtk_text_view_get_editable() is appropriate here.
	InsertInteractiveAtCursor(text string, len int, defaultEditable bool) bool
	// InsertMarkup inserts the text in @markup at position @iter. @markup will
	// be inserted in its entirety and must be nul-terminated and valid UTF-8.
	// Emits the TextBuffer::insert-text signal, possibly multiple times;
	// insertion actually occurs in the default handler for the signal. @iter
	// will point to the end of the inserted text on return.
	InsertMarkup(iter *TextIter, markup string, len int)
	// InsertPaintable inserts an image into the text buffer at @iter. The image
	// will be counted as one character in character counts, and when obtaining
	// the buffer contents as a string, will be represented by the Unicode
	// “object replacement character” 0xFFFC. Note that the “slice” variants for
	// obtaining portions of the buffer as a string include this character for
	// paintable, but the “text” variants do not. e.g. see
	// gtk_text_buffer_get_slice() and gtk_text_buffer_get_text().
	InsertPaintable(iter *TextIter, paintable gdk.Paintable)
	// InsertRange copies text, tags, and paintables between @start and @end
	// (the order of @start and @end doesn’t matter) and inserts the copy at
	// @iter. Used instead of simply getting/inserting text because it preserves
	// images and tags. If @start and @end are in a different buffer from
	// @buffer, the two buffers must share the same tag table.
	//
	// Implemented via emissions of the insert_text and apply_tag signals, so
	// expect those.
	InsertRange(iter *TextIter, start *TextIter, end *TextIter)
	// InsertRangeInteractive: same as gtk_text_buffer_insert_range(), but does
	// nothing if the insertion point isn’t editable. The @default_editable
	// parameter indicates whether the text is editable at @iter if no tags
	// enclosing @iter affect editability. Typically the result of
	// gtk_text_view_get_editable() is appropriate here.
	InsertRangeInteractive(iter *TextIter, start *TextIter, end *TextIter, defaultEditable bool) bool
	// MoveMark moves @mark to the new location @where. Emits the
	// TextBuffer::mark-set signal as notification of the move.
	MoveMark(mark TextMark, where *TextIter)
	// MoveMarkByName moves the mark named @name (which must exist) to location
	// @where. See gtk_text_buffer_move_mark() for details.
	MoveMarkByName(name string, where *TextIter)
	// PasteClipboard pastes the contents of a clipboard. If @override_location
	// is nil, the pasted text will be inserted at the cursor position, or the
	// buffer selection will be replaced if the selection is non-empty.
	//
	// Note: pasting is asynchronous, that is, we’ll ask for the paste data and
	// return, and at some point later after the main loop runs, the paste data
	// will be inserted.
	PasteClipboard(clipboard gdk.Clipboard, overrideLocation *TextIter, defaultEditable bool)
	// PlaceCursor: this function moves the “insert” and “selection_bound” marks
	// simultaneously. If you move them to the same place in two steps with
	// gtk_text_buffer_move_mark(), you will temporarily select a region in
	// between their old and new locations, which can be pretty inefficient
	// since the temporarily-selected region will force stuff to be
	// recalculated. This function moves them as a unit, which can be optimized.
	PlaceCursor(where *TextIter)
	// Redo redoes the next redoable action on the buffer, if there is one.
	Redo()
	// RemoveAllTags removes all tags in the range between @start and @end. Be
	// careful with this function; it could remove tags added in code unrelated
	// to the code you’re currently writing. That is, using this function is
	// probably a bad idea if you have two or more unrelated code sections that
	// add tags.
	RemoveAllTags(start *TextIter, end *TextIter)
	// RemoveSelectionClipboard removes a Clipboard added with
	// gtk_text_buffer_add_selection_clipboard().
	RemoveSelectionClipboard(clipboard gdk.Clipboard)
	// RemoveTag emits the “remove-tag” signal. The default handler for the
	// signal removes all occurrences of @tag from the given range. @start and
	// @end don’t have to be in order.
	RemoveTag(tag TextTag, start *TextIter, end *TextIter)
	// RemoveTagByName calls gtk_text_tag_table_lookup() on the buffer’s tag
	// table to get a TextTag, then calls gtk_text_buffer_remove_tag().
	RemoveTagByName(name string, start *TextIter, end *TextIter)
	// SelectRange: this function moves the “insert” and “selection_bound” marks
	// simultaneously. If you move them in two steps with
	// gtk_text_buffer_move_mark(), you will temporarily select a region in
	// between their old and new locations, which can be pretty inefficient
	// since the temporarily-selected region will force stuff to be
	// recalculated. This function moves them as a unit, which can be optimized.
	SelectRange(ins *TextIter, bound *TextIter)
	// SetEnableUndo sets whether or not to enable undoable actions in the text
	// buffer. If enabled, the user will be able to undo the last number of
	// actions up to gtk_text_buffer_get_max_undo_levels().
	//
	// See gtk_text_buffer_begin_irreversible_action() and
	// gtk_text_buffer_end_irreversible_action() to create changes to the buffer
	// that cannot be undone.
	SetEnableUndo(enableUndo bool)
	// SetMaxUndoLevels sets the maximum number of undo levels to perform. If 0,
	// unlimited undo actions may be performed. Note that this may have a memory
	// usage impact as it requires storing an additional copy of the inserted or
	// removed text within the text buffer.
	SetMaxUndoLevels(maxUndoLevels uint)
	// SetModified: used to keep track of whether the buffer has been modified
	// since the last time it was saved. Whenever the buffer is saved to disk,
	// call gtk_text_buffer_set_modified (@buffer, FALSE). When the buffer is
	// modified, it will automatically toggled on the modified bit again. When
	// the modified bit flips, the buffer emits the TextBuffer::modified-changed
	// signal.
	SetModified(setting bool)
	// SetText deletes current contents of @buffer, and inserts @text instead.
	// If @len is -1, @text must be nul-terminated. @text must be valid UTF-8.
	SetText(text string, len int)
	// Undo undoes the last undoable action on the buffer, if there is one.
	Undo()
}

// textBuffer implements the TextBuffer interface.
type textBuffer struct {
	gextras.Objector
}

var _ TextBuffer = (*textBuffer)(nil)

// WrapTextBuffer wraps a GObject to the right type. It is
// primarily used internally.
func WrapTextBuffer(obj *externglib.Object) TextBuffer {
	return TextBuffer{
		Objector: obj,
	}
}

func marshalTextBuffer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTextBuffer(obj), nil
}

// NewTextBuffer constructs a class TextBuffer.
func NewTextBuffer(table TextTagTable) TextBuffer {
	var arg1 *C.GtkTextTagTable

	arg1 = (*C.GtkTextTagTable)(unsafe.Pointer(table.Native()))

	var cret C.GtkTextBuffer

	cret = C.gtk_text_buffer_new(arg1)

	var textBuffer TextBuffer

	textBuffer = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(TextBuffer)

	return textBuffer
}

// AddMark adds the mark at position @where. The mark must not be added to
// another buffer, and if its name is not nil then there must not be another
// mark in the buffer with the same name.
//
// Emits the TextBuffer::mark-set signal as notification of the mark's
// initial placement.
func (b textBuffer) AddMark(mark TextMark, where *TextIter) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextMark
	var arg2 *C.GtkTextIter

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg1 = (*C.GtkTextMark)(unsafe.Pointer(mark.Native()))
	arg2 = (*C.GtkTextIter)(unsafe.Pointer(where.Native()))

	C.gtk_text_buffer_add_mark(arg0, arg1, arg2)
}

// AddSelectionClipboard adds @clipboard to the list of clipboards in which
// the selection contents of @buffer are available. In most cases,
// @clipboard will be the Clipboard returned by
// gtk_widget_get_primary_clipboard() for a view of @buffer.
func (b textBuffer) AddSelectionClipboard(clipboard gdk.Clipboard) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GdkClipboard

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg1 = (*C.GdkClipboard)(unsafe.Pointer(clipboard.Native()))

	C.gtk_text_buffer_add_selection_clipboard(arg0, arg1)
}

// ApplyTag emits the “apply-tag” signal on @buffer. The default handler for
// the signal applies @tag to the given range. @start and @end do not have
// to be in order.
func (b textBuffer) ApplyTag(tag TextTag, start *TextIter, end *TextIter) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextTag
	var arg2 *C.GtkTextIter
	var arg3 *C.GtkTextIter

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg1 = (*C.GtkTextTag)(unsafe.Pointer(tag.Native()))
	arg2 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
	arg3 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

	C.gtk_text_buffer_apply_tag(arg0, arg1, arg2, arg3)
}

// ApplyTagByName calls gtk_text_tag_table_lookup() on the buffer’s tag
// table to get a TextTag, then calls gtk_text_buffer_apply_tag().
func (b textBuffer) ApplyTagByName(name string, start *TextIter, end *TextIter) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.char
	var arg2 *C.GtkTextIter
	var arg3 *C.GtkTextIter

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
	arg3 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

	C.gtk_text_buffer_apply_tag_by_name(arg0, arg1, arg2, arg3)
}

// Backspace performs the appropriate action as if the user hit the delete
// key with the cursor at the position specified by @iter. In the normal
// case a single character will be deleted, but when combining accents are
// involved, more than one character can be deleted, and when precomposed
// character and accent combinations are involved, less than one character
// will be deleted.
//
// Because the buffer is modified, all outstanding iterators become invalid
// after calling this function; however, the @iter will be re-initialized to
// point to the location where text was deleted.
func (b textBuffer) Backspace(iter *TextIter, interactive bool, defaultEditable bool) bool {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextIter
	var arg2 C.gboolean
	var arg3 C.gboolean

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))
	if interactive {
		arg2 = C.gboolean(1)
	}
	if defaultEditable {
		arg3 = C.gboolean(1)
	}

	var cret C.gboolean

	cret = C.gtk_text_buffer_backspace(arg0, arg1, arg2, arg3)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// BeginIrreversibleAction denotes the beginning of an action that may not
// be undone. This will cause any previous operations in the undo/redo queue
// to be cleared.
//
// This should be paired with a call to
// gtk_text_buffer_end_irreversible_action() after the irreversible action
// has completed.
//
// You may nest calls to gtk_text_buffer_begin_irreversible_action() and
// gtk_text_buffer_end_irreversible_action() pairs.
func (b textBuffer) BeginIrreversibleAction() {
	var arg0 *C.GtkTextBuffer

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	C.gtk_text_buffer_begin_irreversible_action(arg0)
}

// BeginUserAction: called to indicate that the buffer operations between
// here and a call to gtk_text_buffer_end_user_action() are part of a single
// user-visible operation. The operations between
// gtk_text_buffer_begin_user_action() and gtk_text_buffer_end_user_action()
// can then be grouped when creating an undo stack. TextBuffer maintains a
// count of calls to gtk_text_buffer_begin_user_action() that have not been
// closed with a call to gtk_text_buffer_end_user_action(), and emits the
// “begin-user-action” and “end-user-action” signals only for the outermost
// pair of calls. This allows you to build user actions from other user
// actions.
//
// The “interactive” buffer mutation functions, such as
// gtk_text_buffer_insert_interactive(), automatically call begin/end user
// action around the buffer operations they perform, so there's no need to
// add extra calls if you user action consists solely of a single call to
// one of those functions.
func (b textBuffer) BeginUserAction() {
	var arg0 *C.GtkTextBuffer

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	C.gtk_text_buffer_begin_user_action(arg0)
}

// CopyClipboard copies the currently-selected text to a clipboard.
func (b textBuffer) CopyClipboard(clipboard gdk.Clipboard) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GdkClipboard

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg1 = (*C.GdkClipboard)(unsafe.Pointer(clipboard.Native()))

	C.gtk_text_buffer_copy_clipboard(arg0, arg1)
}

// CreateChildAnchor: this is a convenience function which simply creates a
// child anchor with gtk_text_child_anchor_new() and inserts it into the
// buffer with gtk_text_buffer_insert_child_anchor(). The new anchor is
// owned by the buffer; no reference count is returned to the caller of
// gtk_text_buffer_create_child_anchor().
func (b textBuffer) CreateChildAnchor(iter *TextIter) TextChildAnchor {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextIter

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))

	var cret *C.GtkTextChildAnchor

	cret = C.gtk_text_buffer_create_child_anchor(arg0, arg1)

	var textChildAnchor TextChildAnchor

	textChildAnchor = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(TextChildAnchor)

	return textChildAnchor
}

// CreateMark creates a mark at position @where. If @mark_name is nil, the
// mark is anonymous; otherwise, the mark can be retrieved by name using
// gtk_text_buffer_get_mark(). If a mark has left gravity, and text is
// inserted at the mark’s current location, the mark will be moved to the
// left of the newly-inserted text. If the mark has right gravity
// (@left_gravity = false), the mark will end up on the right of
// newly-inserted text. The standard left-to-right cursor is a mark with
// right gravity (when you type, the cursor stays on the right side of the
// text you’re typing).
//
// The caller of this function does not own a reference to the returned
// TextMark, so you can ignore the return value if you like. Marks are owned
// by the buffer and go away when the buffer does.
//
// Emits the TextBuffer::mark-set signal as notification of the mark's
// initial placement.
func (b textBuffer) CreateMark(markName string, where *TextIter, leftGravity bool) TextMark {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.char
	var arg2 *C.GtkTextIter
	var arg3 C.gboolean

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg1 = (*C.char)(C.CString(markName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GtkTextIter)(unsafe.Pointer(where.Native()))
	if leftGravity {
		arg3 = C.gboolean(1)
	}

	var cret *C.GtkTextMark

	cret = C.gtk_text_buffer_create_mark(arg0, arg1, arg2, arg3)

	var textMark TextMark

	textMark = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(TextMark)

	return textMark
}

// CutClipboard copies the currently-selected text to a clipboard, then
// deletes said text if it’s editable.
func (b textBuffer) CutClipboard(clipboard gdk.Clipboard, defaultEditable bool) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GdkClipboard
	var arg2 C.gboolean

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg1 = (*C.GdkClipboard)(unsafe.Pointer(clipboard.Native()))
	if defaultEditable {
		arg2 = C.gboolean(1)
	}

	C.gtk_text_buffer_cut_clipboard(arg0, arg1, arg2)
}

// Delete deletes text between @start and @end. The order of @start and @end
// is not actually relevant; gtk_text_buffer_delete() will reorder them.
// This function actually emits the “delete-range” signal, and the default
// handler of that signal deletes the text. Because the buffer is modified,
// all outstanding iterators become invalid after calling this function;
// however, the @start and @end will be re-initialized to point to the
// location where text was deleted.
func (b textBuffer) Delete(start *TextIter, end *TextIter) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextIter
	var arg2 *C.GtkTextIter

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg1 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
	arg2 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

	C.gtk_text_buffer_delete(arg0, arg1, arg2)
}

// DeleteInteractive deletes all editable text in the given range. Calls
// gtk_text_buffer_delete() for each editable sub-range of [@start,@end).
// @start and @end are revalidated to point to the location of the last
// deleted range, or left untouched if no text was deleted.
func (b textBuffer) DeleteInteractive(startIter *TextIter, endIter *TextIter, defaultEditable bool) bool {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextIter
	var arg2 *C.GtkTextIter
	var arg3 C.gboolean

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg1 = (*C.GtkTextIter)(unsafe.Pointer(startIter.Native()))
	arg2 = (*C.GtkTextIter)(unsafe.Pointer(endIter.Native()))
	if defaultEditable {
		arg3 = C.gboolean(1)
	}

	var cret C.gboolean

	cret = C.gtk_text_buffer_delete_interactive(arg0, arg1, arg2, arg3)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// DeleteMark deletes @mark, so that it’s no longer located anywhere in the
// buffer. Removes the reference the buffer holds to the mark, so if you
// haven’t called g_object_ref() on the mark, it will be freed. Even if the
// mark isn’t freed, most operations on @mark become invalid, until it gets
// added to a buffer again with gtk_text_buffer_add_mark(). Use
// gtk_text_mark_get_deleted() to find out if a mark has been removed from
// its buffer. The TextBuffer::mark-deleted signal will be emitted as
// notification after the mark is deleted.
func (b textBuffer) DeleteMark(mark TextMark) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextMark

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg1 = (*C.GtkTextMark)(unsafe.Pointer(mark.Native()))

	C.gtk_text_buffer_delete_mark(arg0, arg1)
}

// DeleteMarkByName deletes the mark named @name; the mark must exist. See
// gtk_text_buffer_delete_mark() for details.
func (b textBuffer) DeleteMarkByName(name string) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.char

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_text_buffer_delete_mark_by_name(arg0, arg1)
}

// DeleteSelection deletes the range between the “insert” and
// “selection_bound” marks, that is, the currently-selected text. If
// @interactive is true, the editability of the selection will be considered
// (users can’t delete uneditable text).
func (b textBuffer) DeleteSelection(interactive bool, defaultEditable bool) bool {
	var arg0 *C.GtkTextBuffer
	var arg1 C.gboolean
	var arg2 C.gboolean

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	if interactive {
		arg1 = C.gboolean(1)
	}
	if defaultEditable {
		arg2 = C.gboolean(1)
	}

	var cret C.gboolean

	cret = C.gtk_text_buffer_delete_selection(arg0, arg1, arg2)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// EndIrreversibleAction denotes the end of an action that may not be
// undone. This will cause any previous operations in the undo/redo queue to
// be cleared.
//
// This should be called after completing modifications to the text buffer
// after gtk_text_buffer_begin_irreversible_action() was called.
//
// You may nest calls to gtk_text_buffer_begin_irreversible_action() and
// gtk_text_buffer_end_irreversible_action() pairs.
func (b textBuffer) EndIrreversibleAction() {
	var arg0 *C.GtkTextBuffer

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	C.gtk_text_buffer_end_irreversible_action(arg0)
}

// EndUserAction: should be paired with a call to
// gtk_text_buffer_begin_user_action(). See that function for a full
// explanation.
func (b textBuffer) EndUserAction() {
	var arg0 *C.GtkTextBuffer

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	C.gtk_text_buffer_end_user_action(arg0)
}

// Bounds retrieves the first and last iterators in the buffer, i.e. the
// entire buffer lies within the range [@start,@end).
func (b textBuffer) Bounds() (start TextIter, end TextIter) {
	var arg0 *C.GtkTextBuffer

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	var start TextIter
	var end TextIter

	C.gtk_text_buffer_get_bounds(arg0, (*C.GtkTextIter)(unsafe.Pointer(&start)), (*C.GtkTextIter)(unsafe.Pointer(&end)))

	return start, end
}

// CanRedo gets whether there is a redoable action in the history.
func (b textBuffer) CanRedo() bool {
	var arg0 *C.GtkTextBuffer

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	var cret C.gboolean

	cret = C.gtk_text_buffer_get_can_redo(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// CanUndo gets whether there is an undoable action in the history.
func (b textBuffer) CanUndo() bool {
	var arg0 *C.GtkTextBuffer

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	var cret C.gboolean

	cret = C.gtk_text_buffer_get_can_undo(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// CharCount gets the number of characters in the buffer; note that
// characters and bytes are not the same, you can’t e.g. expect the contents
// of the buffer in string form to be this many bytes long. The character
// count is cached, so this function is very fast.
func (b textBuffer) CharCount() int {
	var arg0 *C.GtkTextBuffer

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	var cret C.int

	cret = C.gtk_text_buffer_get_char_count(arg0)

	var gint int

	gint = (int)(cret)

	return gint
}

// EnableUndo gets whether the buffer is saving modifications to the buffer
// to allow for undo and redo actions.
//
// See gtk_text_buffer_begin_irreversible_action() and
// gtk_text_buffer_end_irreversible_action() to create changes to the buffer
// that cannot be undone.
func (b textBuffer) EnableUndo() bool {
	var arg0 *C.GtkTextBuffer

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	var cret C.gboolean

	cret = C.gtk_text_buffer_get_enable_undo(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// EndIter initializes @iter with the “end iterator,” one past the last
// valid character in the text buffer. If dereferenced with
// gtk_text_iter_get_char(), the end iterator has a character value of 0.
// The entire buffer lies in the range from the first position in the buffer
// (call gtk_text_buffer_get_start_iter() to get character position 0) to
// the end iterator.
func (b textBuffer) EndIter() TextIter {
	var arg0 *C.GtkTextBuffer

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	var iter TextIter

	C.gtk_text_buffer_get_end_iter(arg0, (*C.GtkTextIter)(unsafe.Pointer(&iter)))

	return iter
}

// HasSelection indicates whether the buffer has some text currently
// selected.
func (b textBuffer) HasSelection() bool {
	var arg0 *C.GtkTextBuffer

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	var cret C.gboolean

	cret = C.gtk_text_buffer_get_has_selection(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// GetInsert returns the mark that represents the cursor (insertion point).
// Equivalent to calling gtk_text_buffer_get_mark() to get the mark named
// “insert”, but very slightly more efficient, and involves less typing.
func (b textBuffer) GetInsert() TextMark {
	var arg0 *C.GtkTextBuffer

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	var cret *C.GtkTextMark

	cret = C.gtk_text_buffer_get_insert(arg0)

	var textMark TextMark

	textMark = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(TextMark)

	return textMark
}

// IterAtChildAnchor obtains the location of @anchor within @buffer.
func (b textBuffer) IterAtChildAnchor(anchor TextChildAnchor) TextIter {
	var arg0 *C.GtkTextBuffer
	var arg2 *C.GtkTextChildAnchor

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg2 = (*C.GtkTextChildAnchor)(unsafe.Pointer(anchor.Native()))

	var iter TextIter

	C.gtk_text_buffer_get_iter_at_child_anchor(arg0, arg2, (*C.GtkTextIter)(unsafe.Pointer(&iter)))

	return iter
}

// IterAtLine initializes @iter to the start of the given line. If
// @line_number is greater than the number of lines in the @buffer, the end
// iterator is returned.
func (b textBuffer) IterAtLine(lineNumber int) (iter TextIter, ok bool) {
	var arg0 *C.GtkTextBuffer
	var arg2 C.int

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg2 = C.int(lineNumber)

	var iter TextIter
	var cret C.gboolean

	cret = C.gtk_text_buffer_get_iter_at_line(arg0, arg2, (*C.GtkTextIter)(unsafe.Pointer(&iter)))

	var ok bool

	if cret {
		ok = true
	}

	return iter, ok
}

// IterAtLineIndex obtains an iterator pointing to @byte_index within the
// given line. @byte_index must be the start of a UTF-8 character. Note
// bytes, not characters; UTF-8 may encode one character as multiple bytes.
//
// If @line_number is greater than the number of lines in the @buffer, the
// end iterator is returned. And if @byte_index is off the end of the line,
// the iterator at the end of the line is returned.
func (b textBuffer) IterAtLineIndex(lineNumber int, byteIndex int) (iter TextIter, ok bool) {
	var arg0 *C.GtkTextBuffer
	var arg2 C.int
	var arg3 C.int

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg2 = C.int(lineNumber)
	arg3 = C.int(byteIndex)

	var iter TextIter
	var cret C.gboolean

	cret = C.gtk_text_buffer_get_iter_at_line_index(arg0, arg2, arg3, (*C.GtkTextIter)(unsafe.Pointer(&iter)))

	var ok bool

	if cret {
		ok = true
	}

	return iter, ok
}

// IterAtLineOffset obtains an iterator pointing to @char_offset within the
// given line. Note characters, not bytes; UTF-8 may encode one character as
// multiple bytes.
//
// Before the 3.20 version, it was not allowed to pass an invalid location.
//
// If @line_number is greater than the number of lines in the @buffer, the
// end iterator is returned. And if @char_offset is off the end of the line,
// the iterator at the end of the line is returned.
func (b textBuffer) IterAtLineOffset(lineNumber int, charOffset int) (iter TextIter, ok bool) {
	var arg0 *C.GtkTextBuffer
	var arg2 C.int
	var arg3 C.int

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg2 = C.int(lineNumber)
	arg3 = C.int(charOffset)

	var iter TextIter
	var cret C.gboolean

	cret = C.gtk_text_buffer_get_iter_at_line_offset(arg0, arg2, arg3, (*C.GtkTextIter)(unsafe.Pointer(&iter)))

	var ok bool

	if cret {
		ok = true
	}

	return iter, ok
}

// IterAtMark initializes @iter with the current position of @mark.
func (b textBuffer) IterAtMark(mark TextMark) TextIter {
	var arg0 *C.GtkTextBuffer
	var arg2 *C.GtkTextMark

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg2 = (*C.GtkTextMark)(unsafe.Pointer(mark.Native()))

	var iter TextIter

	C.gtk_text_buffer_get_iter_at_mark(arg0, arg2, (*C.GtkTextIter)(unsafe.Pointer(&iter)))

	return iter
}

// IterAtOffset initializes @iter to a position @char_offset chars from the
// start of the entire buffer. If @char_offset is -1 or greater than the
// number of characters in the buffer, @iter is initialized to the end
// iterator, the iterator one past the last valid character in the buffer.
func (b textBuffer) IterAtOffset(charOffset int) TextIter {
	var arg0 *C.GtkTextBuffer
	var arg2 C.int

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg2 = C.int(charOffset)

	var iter TextIter

	C.gtk_text_buffer_get_iter_at_offset(arg0, arg2, (*C.GtkTextIter)(unsafe.Pointer(&iter)))

	return iter
}

// LineCount obtains the number of lines in the buffer. This value is
// cached, so the function is very fast.
func (b textBuffer) LineCount() int {
	var arg0 *C.GtkTextBuffer

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	var cret C.int

	cret = C.gtk_text_buffer_get_line_count(arg0)

	var gint int

	gint = (int)(cret)

	return gint
}

// Mark returns the mark named @name in buffer @buffer, or nil if no such
// mark exists in the buffer.
func (b textBuffer) Mark(name string) TextMark {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.char

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	var cret *C.GtkTextMark

	cret = C.gtk_text_buffer_get_mark(arg0, arg1)

	var textMark TextMark

	textMark = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(TextMark)

	return textMark
}

// MaxUndoLevels gets the maximum number of undo levels to perform. If 0,
// unlimited undo actions may be performed. Note that this may have a memory
// usage impact as it requires storing an additional copy of the inserted or
// removed text within the text buffer.
func (b textBuffer) MaxUndoLevels() uint {
	var arg0 *C.GtkTextBuffer

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	var cret C.guint

	cret = C.gtk_text_buffer_get_max_undo_levels(arg0)

	var guint uint

	guint = (uint)(cret)

	return guint
}

// Modified indicates whether the buffer has been modified since the last
// call to gtk_text_buffer_set_modified() set the modification flag to
// false. Used for example to enable a “save” function in a text editor.
func (b textBuffer) Modified() bool {
	var arg0 *C.GtkTextBuffer

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	var cret C.gboolean

	cret = C.gtk_text_buffer_get_modified(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// SelectionBound returns the mark that represents the selection bound.
// Equivalent to calling gtk_text_buffer_get_mark() to get the mark named
// “selection_bound”, but very slightly more efficient, and involves less
// typing.
//
// The currently-selected text in @buffer is the region between the
// “selection_bound” and “insert” marks. If “selection_bound” and “insert”
// are in the same place, then there is no current selection.
// gtk_text_buffer_get_selection_bounds() is another convenient function for
// handling the selection, if you just want to know whether there’s a
// selection and what its bounds are.
func (b textBuffer) SelectionBound() TextMark {
	var arg0 *C.GtkTextBuffer

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	var cret *C.GtkTextMark

	cret = C.gtk_text_buffer_get_selection_bound(arg0)

	var textMark TextMark

	textMark = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(TextMark)

	return textMark
}

// SelectionBounds returns true if some text is selected; places the bounds
// of the selection in @start and @end (if the selection has length 0, then
// @start and @end are filled in with the same value). @start and @end will
// be in ascending order. If @start and @end are NULL, then they are not
// filled in, but the return value still indicates whether text is selected.
func (b textBuffer) SelectionBounds() (start TextIter, end TextIter, ok bool) {
	var arg0 *C.GtkTextBuffer

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	var start TextIter
	var end TextIter
	var cret C.gboolean

	cret = C.gtk_text_buffer_get_selection_bounds(arg0, (*C.GtkTextIter)(unsafe.Pointer(&start)), (*C.GtkTextIter)(unsafe.Pointer(&end)))

	var ok bool

	if cret {
		ok = true
	}

	return start, end, ok
}

// SelectionContent: get a content provider for this buffer. It can be used
// to make the content of @buffer available in a Clipboard, see
// gdk_clipboard_set_content().
func (b textBuffer) SelectionContent() gdk.ContentProvider {
	var arg0 *C.GtkTextBuffer

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	var cret *C.GdkContentProvider

	cret = C.gtk_text_buffer_get_selection_content(arg0)

	var contentProvider gdk.ContentProvider

	contentProvider = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(gdk.ContentProvider)

	return contentProvider
}

// Slice returns the text in the range [@start,@end). Excludes undisplayed
// text (text marked with tags that set the invisibility attribute) if
// @include_hidden_chars is false. The returned string includes a 0xFFFC
// character whenever the buffer contains embedded images, so byte and
// character indexes into the returned string do correspond to byte and
// character indexes into the buffer. Contrast with
// gtk_text_buffer_get_text(). Note that 0xFFFC can occur in normal text as
// well, so it is not a reliable indicator that a paintable or widget is in
// the buffer.
func (b textBuffer) Slice(start *TextIter, end *TextIter, includeHiddenChars bool) string {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextIter
	var arg2 *C.GtkTextIter
	var arg3 C.gboolean

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg1 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
	arg2 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))
	if includeHiddenChars {
		arg3 = C.gboolean(1)
	}

	var cret *C.char

	cret = C.gtk_text_buffer_get_slice(arg0, arg1, arg2, arg3)

	var utf8 string

	utf8 = C.GoString(cret)
	defer C.free(unsafe.Pointer(cret))

	return utf8
}

// StartIter: initialized @iter with the first position in the text buffer.
// This is the same as using gtk_text_buffer_get_iter_at_offset() to get the
// iter at character offset 0.
func (b textBuffer) StartIter() TextIter {
	var arg0 *C.GtkTextBuffer

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	var iter TextIter

	C.gtk_text_buffer_get_start_iter(arg0, (*C.GtkTextIter)(unsafe.Pointer(&iter)))

	return iter
}

// TagTable: get the TextTagTable associated with this buffer.
func (b textBuffer) TagTable() TextTagTable {
	var arg0 *C.GtkTextBuffer

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	var cret *C.GtkTextTagTable

	cret = C.gtk_text_buffer_get_tag_table(arg0)

	var textTagTable TextTagTable

	textTagTable = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(TextTagTable)

	return textTagTable
}

// Text returns the text in the range [@start,@end). Excludes undisplayed
// text (text marked with tags that set the invisibility attribute) if
// @include_hidden_chars is false. Does not include characters representing
// embedded images, so byte and character indexes into the returned string
// do not correspond to byte and character indexes into the buffer. Contrast
// with gtk_text_buffer_get_slice().
func (b textBuffer) Text(start *TextIter, end *TextIter, includeHiddenChars bool) string {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextIter
	var arg2 *C.GtkTextIter
	var arg3 C.gboolean

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg1 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
	arg2 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))
	if includeHiddenChars {
		arg3 = C.gboolean(1)
	}

	var cret *C.char

	cret = C.gtk_text_buffer_get_text(arg0, arg1, arg2, arg3)

	var utf8 string

	utf8 = C.GoString(cret)
	defer C.free(unsafe.Pointer(cret))

	return utf8
}

// Insert inserts @len bytes of @text at position @iter. If @len is -1,
// @text must be nul-terminated and will be inserted in its entirety. Emits
// the “insert-text” signal; insertion actually occurs in the default
// handler for the signal. @iter is invalidated when insertion occurs
// (because the buffer contents change), but the default signal handler
// revalidates it to point to the end of the inserted text.
func (b textBuffer) Insert(iter *TextIter, text string, len int) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextIter
	var arg2 *C.char
	var arg3 C.int

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))
	arg2 = (*C.char)(C.CString(text))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = C.int(len)

	C.gtk_text_buffer_insert(arg0, arg1, arg2, arg3)
}

// InsertAtCursor: simply calls gtk_text_buffer_insert(), using the current
// cursor position as the insertion point.
func (b textBuffer) InsertAtCursor(text string, len int) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.char
	var arg2 C.int

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg1 = (*C.char)(C.CString(text))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.int(len)

	C.gtk_text_buffer_insert_at_cursor(arg0, arg1, arg2)
}

// InsertChildAnchor inserts a child widget anchor into the text buffer at
// @iter. The anchor will be counted as one character in character counts,
// and when obtaining the buffer contents as a string, will be represented
// by the Unicode “object replacement character” 0xFFFC. Note that the
// “slice” variants for obtaining portions of the buffer as a string include
// this character for child anchors, but the “text” variants do not. E.g.
// see gtk_text_buffer_get_slice() and gtk_text_buffer_get_text(). Consider
// gtk_text_buffer_create_child_anchor() as a more convenient alternative to
// this function. The buffer will add a reference to the anchor, so you can
// unref it after insertion.
func (b textBuffer) InsertChildAnchor(iter *TextIter, anchor TextChildAnchor) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextIter
	var arg2 *C.GtkTextChildAnchor

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))
	arg2 = (*C.GtkTextChildAnchor)(unsafe.Pointer(anchor.Native()))

	C.gtk_text_buffer_insert_child_anchor(arg0, arg1, arg2)
}

// InsertInteractive: like gtk_text_buffer_insert(), but the insertion will
// not occur if @iter is at a non-editable location in the buffer. Usually
// you want to prevent insertions at ineditable locations if the insertion
// results from a user action (is interactive).
//
// @default_editable indicates the editability of text that doesn't have a
// tag affecting editability applied to it. Typically the result of
// gtk_text_view_get_editable() is appropriate here.
func (b textBuffer) InsertInteractive(iter *TextIter, text string, len int, defaultEditable bool) bool {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextIter
	var arg2 *C.char
	var arg3 C.int
	var arg4 C.gboolean

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))
	arg2 = (*C.char)(C.CString(text))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = C.int(len)
	if defaultEditable {
		arg4 = C.gboolean(1)
	}

	var cret C.gboolean

	cret = C.gtk_text_buffer_insert_interactive(arg0, arg1, arg2, arg3, arg4)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// InsertInteractiveAtCursor calls gtk_text_buffer_insert_interactive() at
// the cursor position.
//
// @default_editable indicates the editability of text that doesn't have a
// tag affecting editability applied to it. Typically the result of
// gtk_text_view_get_editable() is appropriate here.
func (b textBuffer) InsertInteractiveAtCursor(text string, len int, defaultEditable bool) bool {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.char
	var arg2 C.int
	var arg3 C.gboolean

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg1 = (*C.char)(C.CString(text))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.int(len)
	if defaultEditable {
		arg3 = C.gboolean(1)
	}

	var cret C.gboolean

	cret = C.gtk_text_buffer_insert_interactive_at_cursor(arg0, arg1, arg2, arg3)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// InsertMarkup inserts the text in @markup at position @iter. @markup will
// be inserted in its entirety and must be nul-terminated and valid UTF-8.
// Emits the TextBuffer::insert-text signal, possibly multiple times;
// insertion actually occurs in the default handler for the signal. @iter
// will point to the end of the inserted text on return.
func (b textBuffer) InsertMarkup(iter *TextIter, markup string, len int) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextIter
	var arg2 *C.char
	var arg3 C.int

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))
	arg2 = (*C.char)(C.CString(markup))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = C.int(len)

	C.gtk_text_buffer_insert_markup(arg0, arg1, arg2, arg3)
}

// InsertPaintable inserts an image into the text buffer at @iter. The image
// will be counted as one character in character counts, and when obtaining
// the buffer contents as a string, will be represented by the Unicode
// “object replacement character” 0xFFFC. Note that the “slice” variants for
// obtaining portions of the buffer as a string include this character for
// paintable, but the “text” variants do not. e.g. see
// gtk_text_buffer_get_slice() and gtk_text_buffer_get_text().
func (b textBuffer) InsertPaintable(iter *TextIter, paintable gdk.Paintable) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextIter
	var arg2 *C.GdkPaintable

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))
	arg2 = (*C.GdkPaintable)(unsafe.Pointer(paintable.Native()))

	C.gtk_text_buffer_insert_paintable(arg0, arg1, arg2)
}

// InsertRange copies text, tags, and paintables between @start and @end
// (the order of @start and @end doesn’t matter) and inserts the copy at
// @iter. Used instead of simply getting/inserting text because it preserves
// images and tags. If @start and @end are in a different buffer from
// @buffer, the two buffers must share the same tag table.
//
// Implemented via emissions of the insert_text and apply_tag signals, so
// expect those.
func (b textBuffer) InsertRange(iter *TextIter, start *TextIter, end *TextIter) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextIter
	var arg2 *C.GtkTextIter
	var arg3 *C.GtkTextIter

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))
	arg2 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
	arg3 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

	C.gtk_text_buffer_insert_range(arg0, arg1, arg2, arg3)
}

// InsertRangeInteractive: same as gtk_text_buffer_insert_range(), but does
// nothing if the insertion point isn’t editable. The @default_editable
// parameter indicates whether the text is editable at @iter if no tags
// enclosing @iter affect editability. Typically the result of
// gtk_text_view_get_editable() is appropriate here.
func (b textBuffer) InsertRangeInteractive(iter *TextIter, start *TextIter, end *TextIter, defaultEditable bool) bool {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextIter
	var arg2 *C.GtkTextIter
	var arg3 *C.GtkTextIter
	var arg4 C.gboolean

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))
	arg2 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
	arg3 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))
	if defaultEditable {
		arg4 = C.gboolean(1)
	}

	var cret C.gboolean

	cret = C.gtk_text_buffer_insert_range_interactive(arg0, arg1, arg2, arg3, arg4)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// MoveMark moves @mark to the new location @where. Emits the
// TextBuffer::mark-set signal as notification of the move.
func (b textBuffer) MoveMark(mark TextMark, where *TextIter) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextMark
	var arg2 *C.GtkTextIter

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg1 = (*C.GtkTextMark)(unsafe.Pointer(mark.Native()))
	arg2 = (*C.GtkTextIter)(unsafe.Pointer(where.Native()))

	C.gtk_text_buffer_move_mark(arg0, arg1, arg2)
}

// MoveMarkByName moves the mark named @name (which must exist) to location
// @where. See gtk_text_buffer_move_mark() for details.
func (b textBuffer) MoveMarkByName(name string, where *TextIter) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.char
	var arg2 *C.GtkTextIter

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GtkTextIter)(unsafe.Pointer(where.Native()))

	C.gtk_text_buffer_move_mark_by_name(arg0, arg1, arg2)
}

// PasteClipboard pastes the contents of a clipboard. If @override_location
// is nil, the pasted text will be inserted at the cursor position, or the
// buffer selection will be replaced if the selection is non-empty.
//
// Note: pasting is asynchronous, that is, we’ll ask for the paste data and
// return, and at some point later after the main loop runs, the paste data
// will be inserted.
func (b textBuffer) PasteClipboard(clipboard gdk.Clipboard, overrideLocation *TextIter, defaultEditable bool) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GdkClipboard
	var arg2 *C.GtkTextIter
	var arg3 C.gboolean

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg1 = (*C.GdkClipboard)(unsafe.Pointer(clipboard.Native()))
	arg2 = (*C.GtkTextIter)(unsafe.Pointer(overrideLocation.Native()))
	if defaultEditable {
		arg3 = C.gboolean(1)
	}

	C.gtk_text_buffer_paste_clipboard(arg0, arg1, arg2, arg3)
}

// PlaceCursor: this function moves the “insert” and “selection_bound” marks
// simultaneously. If you move them to the same place in two steps with
// gtk_text_buffer_move_mark(), you will temporarily select a region in
// between their old and new locations, which can be pretty inefficient
// since the temporarily-selected region will force stuff to be
// recalculated. This function moves them as a unit, which can be optimized.
func (b textBuffer) PlaceCursor(where *TextIter) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextIter

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg1 = (*C.GtkTextIter)(unsafe.Pointer(where.Native()))

	C.gtk_text_buffer_place_cursor(arg0, arg1)
}

// Redo redoes the next redoable action on the buffer, if there is one.
func (b textBuffer) Redo() {
	var arg0 *C.GtkTextBuffer

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	C.gtk_text_buffer_redo(arg0)
}

// RemoveAllTags removes all tags in the range between @start and @end. Be
// careful with this function; it could remove tags added in code unrelated
// to the code you’re currently writing. That is, using this function is
// probably a bad idea if you have two or more unrelated code sections that
// add tags.
func (b textBuffer) RemoveAllTags(start *TextIter, end *TextIter) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextIter
	var arg2 *C.GtkTextIter

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg1 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
	arg2 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

	C.gtk_text_buffer_remove_all_tags(arg0, arg1, arg2)
}

// RemoveSelectionClipboard removes a Clipboard added with
// gtk_text_buffer_add_selection_clipboard().
func (b textBuffer) RemoveSelectionClipboard(clipboard gdk.Clipboard) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GdkClipboard

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg1 = (*C.GdkClipboard)(unsafe.Pointer(clipboard.Native()))

	C.gtk_text_buffer_remove_selection_clipboard(arg0, arg1)
}

// RemoveTag emits the “remove-tag” signal. The default handler for the
// signal removes all occurrences of @tag from the given range. @start and
// @end don’t have to be in order.
func (b textBuffer) RemoveTag(tag TextTag, start *TextIter, end *TextIter) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextTag
	var arg2 *C.GtkTextIter
	var arg3 *C.GtkTextIter

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg1 = (*C.GtkTextTag)(unsafe.Pointer(tag.Native()))
	arg2 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
	arg3 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

	C.gtk_text_buffer_remove_tag(arg0, arg1, arg2, arg3)
}

// RemoveTagByName calls gtk_text_tag_table_lookup() on the buffer’s tag
// table to get a TextTag, then calls gtk_text_buffer_remove_tag().
func (b textBuffer) RemoveTagByName(name string, start *TextIter, end *TextIter) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.char
	var arg2 *C.GtkTextIter
	var arg3 *C.GtkTextIter

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
	arg3 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

	C.gtk_text_buffer_remove_tag_by_name(arg0, arg1, arg2, arg3)
}

// SelectRange: this function moves the “insert” and “selection_bound” marks
// simultaneously. If you move them in two steps with
// gtk_text_buffer_move_mark(), you will temporarily select a region in
// between their old and new locations, which can be pretty inefficient
// since the temporarily-selected region will force stuff to be
// recalculated. This function moves them as a unit, which can be optimized.
func (b textBuffer) SelectRange(ins *TextIter, bound *TextIter) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.GtkTextIter
	var arg2 *C.GtkTextIter

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg1 = (*C.GtkTextIter)(unsafe.Pointer(ins.Native()))
	arg2 = (*C.GtkTextIter)(unsafe.Pointer(bound.Native()))

	C.gtk_text_buffer_select_range(arg0, arg1, arg2)
}

// SetEnableUndo sets whether or not to enable undoable actions in the text
// buffer. If enabled, the user will be able to undo the last number of
// actions up to gtk_text_buffer_get_max_undo_levels().
//
// See gtk_text_buffer_begin_irreversible_action() and
// gtk_text_buffer_end_irreversible_action() to create changes to the buffer
// that cannot be undone.
func (b textBuffer) SetEnableUndo(enableUndo bool) {
	var arg0 *C.GtkTextBuffer
	var arg1 C.gboolean

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	if enableUndo {
		arg1 = C.gboolean(1)
	}

	C.gtk_text_buffer_set_enable_undo(arg0, arg1)
}

// SetMaxUndoLevels sets the maximum number of undo levels to perform. If 0,
// unlimited undo actions may be performed. Note that this may have a memory
// usage impact as it requires storing an additional copy of the inserted or
// removed text within the text buffer.
func (b textBuffer) SetMaxUndoLevels(maxUndoLevels uint) {
	var arg0 *C.GtkTextBuffer
	var arg1 C.guint

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg1 = C.guint(maxUndoLevels)

	C.gtk_text_buffer_set_max_undo_levels(arg0, arg1)
}

// SetModified: used to keep track of whether the buffer has been modified
// since the last time it was saved. Whenever the buffer is saved to disk,
// call gtk_text_buffer_set_modified (@buffer, FALSE). When the buffer is
// modified, it will automatically toggled on the modified bit again. When
// the modified bit flips, the buffer emits the TextBuffer::modified-changed
// signal.
func (b textBuffer) SetModified(setting bool) {
	var arg0 *C.GtkTextBuffer
	var arg1 C.gboolean

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	if setting {
		arg1 = C.gboolean(1)
	}

	C.gtk_text_buffer_set_modified(arg0, arg1)
}

// SetText deletes current contents of @buffer, and inserts @text instead.
// If @len is -1, @text must be nul-terminated. @text must be valid UTF-8.
func (b textBuffer) SetText(text string, len int) {
	var arg0 *C.GtkTextBuffer
	var arg1 *C.char
	var arg2 C.int

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	arg1 = (*C.char)(C.CString(text))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.int(len)

	C.gtk_text_buffer_set_text(arg0, arg1, arg2)
}

// Undo undoes the last undoable action on the buffer, if there is one.
func (b textBuffer) Undo() {
	var arg0 *C.GtkTextBuffer

	arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	C.gtk_text_buffer_undo(arg0)
}

type TextBTree struct {
	native C.GtkTextBTree
}

// WrapTextBTree wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTextBTree(ptr unsafe.Pointer) *TextBTree {
	if ptr == nil {
		return nil
	}

	return (*TextBTree)(ptr)
}

func marshalTextBTree(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapTextBTree(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *TextBTree) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}
