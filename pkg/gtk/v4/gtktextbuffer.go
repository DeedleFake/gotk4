// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/gdk/v4"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gtk4 glib-2.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <gtk/gtk.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_text_buffer_get_type()), F: marshalTextBuffer},
	})
}

// TextBuffer stores text and attributes for display in a `GtkTextView`.
//
// You may wish to begin by reading the text widget conceptual overview
// (section-text-widget.html), which gives an overview of all the objects and
// data types related to the text widget and how they work together.
type TextBuffer interface {
	gextras.Objector

	// AddMark adds the mark at position @where.
	//
	// The mark must not be added to another buffer, and if its name is not nil
	// then there must not be another mark in the buffer with the same name.
	//
	// Emits the `GtkTextBuffer`::mark-set signal as notification of the mark's
	// initial placement.
	AddMark(mark TextMark, where *TextIter)
	// AddSelectionClipboard adds @clipboard to the list of clipboards in which
	// the selection contents of @buffer are available.
	//
	// In most cases, @clipboard will be the `GdkClipboard` returned by
	// [method@Gtk.Widget.get_primary_clipboard] for a view of @buffer.
	AddSelectionClipboard(clipboard gdk.Clipboard)
	// ApplyTag emits the “apply-tag” signal on @buffer.
	//
	// The default handler for the signal applies @tag to the given range.
	// @start and @end do not have to be in order.
	ApplyTag(tag TextTag, start *TextIter, end *TextIter)
	// ApplyTagByName emits the “apply-tag” signal on @buffer.
	//
	// Calls [method@Gtk.TextTagTable.lookup] on the buffer’s tag table to get a
	// `GtkTextTag`, then calls [method@Gtk.TextBuffer.apply_tag].
	ApplyTagByName(name string, start *TextIter, end *TextIter)
	// Backspace performs the appropriate action as if the user hit the delete
	// key with the cursor at the position specified by @iter.
	//
	// In the normal case a single character will be deleted, but when combining
	// accents are involved, more than one character can be deleted, and when
	// precomposed character and accent combinations are involved, less than one
	// character will be deleted.
	//
	// Because the buffer is modified, all outstanding iterators become invalid
	// after calling this function; however, the @iter will be re-initialized to
	// point to the location where text was deleted.
	Backspace(iter *TextIter, interactive bool, defaultEditable bool) bool
	// BeginIrreversibleAction denotes the beginning of an action that may not
	// be undone.
	//
	// This will cause any previous operations in the undo/redo queue to be
	// cleared.
	//
	// This should be paired with a call to
	// [method@Gtk.TextBuffer.end_irreversible_action] after the irreversible
	// action has completed.
	//
	// You may nest calls to gtk_text_buffer_begin_irreversible_action() and
	// gtk_text_buffer_end_irreversible_action() pairs.
	BeginIrreversibleAction()
	// BeginUserAction: called to indicate that the buffer operations between
	// here and a call to gtk_text_buffer_end_user_action() are part of a single
	// user-visible operation.
	//
	// The operations between gtk_text_buffer_begin_user_action() and
	// gtk_text_buffer_end_user_action() can then be grouped when creating an
	// undo stack. `GtkTextBuffer` maintains a count of calls to
	// gtk_text_buffer_begin_user_action() that have not been closed with a call
	// to gtk_text_buffer_end_user_action(), and emits the “begin-user-action”
	// and “end-user-action” signals only for the outermost pair of calls. This
	// allows you to build user actions from other user actions.
	//
	// The “interactive” buffer mutation functions, such as
	// [method@Gtk.TextBuffer.insert_interactive], automatically call begin/end
	// user action around the buffer operations they perform, so there's no need
	// to add extra calls if you user action consists solely of a single call to
	// one of those functions.
	BeginUserAction()
	// CopyClipboard copies the currently-selected text to a clipboard.
	CopyClipboard(clipboard gdk.Clipboard)
	// CutClipboard copies the currently-selected text to a clipboard, then
	// deletes said text if it’s editable.
	CutClipboard(clipboard gdk.Clipboard, defaultEditable bool)
	// Delete deletes text between @start and @end.
	//
	// The order of @start and @end is not actually relevant;
	// gtk_text_buffer_delete() will reorder them.
	//
	// This function actually emits the “delete-range” signal, and the default
	// handler of that signal deletes the text. Because the buffer is modified,
	// all outstanding iterators become invalid after calling this function;
	// however, the @start and @end will be re-initialized to point to the
	// location where text was deleted.
	Delete(start *TextIter, end *TextIter)
	// DeleteInteractive deletes all editable text in the given range.
	//
	// Calls [method@Gtk.TextBuffer.delete] for each editable sub-range of
	// [@start,@end). @start and @end are revalidated to point to the location
	// of the last deleted range, or left untouched if no text was deleted.
	DeleteInteractive(startIter *TextIter, endIter *TextIter, defaultEditable bool) bool
	// DeleteMark deletes @mark, so that it’s no longer located anywhere in the
	// buffer.
	//
	// Removes the reference the buffer holds to the mark, so if you haven’t
	// called g_object_ref() on the mark, it will be freed. Even if the mark
	// isn’t freed, most operations on @mark become invalid, until it gets added
	// to a buffer again with [method@Gtk.TextBuffer.add_mark]. Use
	// [method@Gtk.TextMark.get_deleted] to find out if a mark has been removed
	// from its buffer.
	//
	// The [signal@Gtk.TextBuffer::mark-deleted] signal will be emitted as
	// notification after the mark is deleted.
	DeleteMark(mark TextMark)
	// DeleteMarkByName deletes the mark named @name; the mark must exist.
	//
	// See [method@Gtk.TextBuffer.delete_mark] for details.
	DeleteMarkByName(name string)
	// DeleteSelection deletes the range between the “insert” and
	// “selection_bound” marks, that is, the currently-selected text.
	//
	// If @interactive is true, the editability of the selection will be
	// considered (users can’t delete uneditable text).
	DeleteSelection(interactive bool, defaultEditable bool) bool
	// EndIrreversibleAction denotes the end of an action that may not be
	// undone.
	//
	// This will cause any previous operations in the undo/redo queue to be
	// cleared.
	//
	// This should be called after completing modifications to the text buffer
	// after gtk_text_buffer_begin_irreversible_action() was called.
	//
	// You may nest calls to gtk_text_buffer_begin_irreversible_action() and
	// gtk_text_buffer_end_irreversible_action() pairs.
	EndIrreversibleAction()
	// EndUserAction ends a user-visible operation.
	//
	// Should be paired with a call to
	// [method@Gtk.TextBuffer.begin_user_action]. See that function for a full
	// explanation.
	EndUserAction()
	// Bounds retrieves the first and last iterators in the buffer, i.e. the
	// entire buffer lies within the range [@start,@end).
	Bounds() (start TextIter, end TextIter)
	// CanRedo gets whether there is a redoable action in the history.
	CanRedo() bool
	// CanUndo gets whether there is an undoable action in the history.
	CanUndo() bool
	// CharCount gets the number of characters in the buffer.
	//
	// Note that characters and bytes are not the same, you can’t e.g. expect
	// the contents of the buffer in string form to be this many bytes long.
	//
	// The character count is cached, so this function is very fast.
	CharCount() int
	// EnableUndo gets whether the buffer is saving modifications to the buffer
	// to allow for undo and redo actions.
	//
	// See [method@Gtk.TextBuffer.begin_irreversible_action] and
	// [method@Gtk.TextBuffer.end_irreversible_action] to create changes to the
	// buffer that cannot be undone.
	EnableUndo() bool
	// EndIter initializes @iter with the “end iterator,” one past the last
	// valid character in the text buffer.
	//
	// If dereferenced with [method@Gtk.TextIter.get_char], the end iterator has
	// a character value of 0. The entire buffer lies in the range from the
	// first position in the buffer (call [method@Gtk.TextBuffer.get_start_iter]
	// to get character position 0) to the end iterator.
	EndIter() TextIter
	// HasSelection indicates whether the buffer has some text currently
	// selected.
	HasSelection() bool
	// IterAtChildAnchor obtains the location of @anchor within @buffer.
	IterAtChildAnchor(anchor TextChildAnchor) TextIter
	// IterAtLine initializes @iter to the start of the given line.
	//
	// If @line_number is greater than or equal to the number of lines in the
	// @buffer, the end iterator is returned.
	IterAtLine(lineNumber int) (TextIter, bool)
	// IterAtLineIndex obtains an iterator pointing to @byte_index within the
	// given line.
	//
	// @byte_index must be the start of a UTF-8 character. Note bytes, not
	// characters; UTF-8 may encode one character as multiple bytes.
	//
	// If @line_number is greater than or equal to the number of lines in the
	// @buffer, the end iterator is returned. And if @byte_index is off the end
	// of the line, the iterator at the end of the line is returned.
	IterAtLineIndex(lineNumber int, byteIndex int) (TextIter, bool)
	// IterAtLineOffset obtains an iterator pointing to @char_offset within the
	// given line.
	//
	// Note characters, not bytes; UTF-8 may encode one character as multiple
	// bytes.
	//
	// If @line_number is greater than or equal to the number of lines in the
	// @buffer, the end iterator is returned. And if @char_offset is off the end
	// of the line, the iterator at the end of the line is returned.
	IterAtLineOffset(lineNumber int, charOffset int) (TextIter, bool)
	// IterAtMark initializes @iter with the current position of @mark.
	IterAtMark(mark TextMark) TextIter
	// IterAtOffset initializes @iter to a position @char_offset chars from the
	// start of the entire buffer.
	//
	// If @char_offset is -1 or greater than the number of characters in the
	// buffer, @iter is initialized to the end iterator, the iterator one past
	// the last valid character in the buffer.
	IterAtOffset(charOffset int) TextIter
	// LineCount obtains the number of lines in the buffer.
	//
	// This value is cached, so the function is very fast.
	LineCount() int
	// MaxUndoLevels gets the maximum number of undo levels to perform.
	//
	// If 0, unlimited undo actions may be performed. Note that this may have a
	// memory usage impact as it requires storing an additional copy of the
	// inserted or removed text within the text buffer.
	MaxUndoLevels() uint
	// Modified indicates whether the buffer has been modified since the last
	// call to [method@Gtk.TextBuffer.set_modified] set the modification flag to
	// false.
	//
	// Used for example to enable a “save” function in a text editor.
	Modified() bool
	// SelectionBounds returns true if some text is selected; places the bounds
	// of the selection in @start and @end.
	//
	// If the selection has length 0, then @start and @end are filled in with
	// the same value. @start and @end will be in ascending order. If @start and
	// @end are nil, then they are not filled in, but the return value still
	// indicates whether text is selected.
	SelectionBounds() (start TextIter, end TextIter, ok bool)
	// Slice returns the text in the range [@start,@end).
	//
	// Excludes undisplayed text (text marked with tags that set the
	// invisibility attribute) if @include_hidden_chars is false. The returned
	// string includes a 0xFFFC character whenever the buffer contains embedded
	// images, so byte and character indexes into the returned string do
	// correspond to byte and character indexes into the buffer. Contrast with
	// [method@Gtk.TextBuffer.get_text]. Note that 0xFFFC can occur in normal
	// text as well, so it is not a reliable indicator that a paintable or
	// widget is in the buffer.
	Slice(start *TextIter, end *TextIter, includeHiddenChars bool) string
	// StartIter: initialized @iter with the first position in the text buffer.
	//
	// This is the same as using [method@Gtk.TextBuffer.get_iter_at_offset] to
	// get the iter at character offset 0.
	StartIter() TextIter
	// Text returns the text in the range [@start,@end).
	//
	// Excludes undisplayed text (text marked with tags that set the
	// invisibility attribute) if @include_hidden_chars is false. Does not
	// include characters representing embedded images, so byte and character
	// indexes into the returned string do not correspond to byte and character
	// indexes into the buffer. Contrast with [method@Gtk.TextBuffer.get_slice].
	Text(start *TextIter, end *TextIter, includeHiddenChars bool) string
	// Insert inserts @len bytes of @text at position @iter.
	//
	// If @len is -1, @text must be nul-terminated and will be inserted in its
	// entirety. Emits the “insert-text” signal; insertion actually occurs in
	// the default handler for the signal. @iter is invalidated when insertion
	// occurs (because the buffer contents change), but the default signal
	// handler revalidates it to point to the end of the inserted text.
	Insert(iter *TextIter, text string, len int)
	// InsertAtCursor inserts @text in @buffer.
	//
	// Simply calls [method@Gtk.TextBuffer.insert], using the current cursor
	// position as the insertion point.
	InsertAtCursor(text string, len int)
	// InsertChildAnchor inserts a child widget anchor into the text buffer at
	// @iter.
	//
	// The anchor will be counted as one character in character counts, and when
	// obtaining the buffer contents as a string, will be represented by the
	// Unicode “object replacement character” 0xFFFC. Note that the “slice”
	// variants for obtaining portions of the buffer as a string include this
	// character for child anchors, but the “text” variants do not. E.g. see
	// [method@Gtk.TextBuffer.get_slice] and [method@Gtk.TextBuffer.get_text].
	//
	// Consider [method@Gtk.TextBuffer.create_child_anchor] as a more convenient
	// alternative to this function. The buffer will add a reference to the
	// anchor, so you can unref it after insertion.
	InsertChildAnchor(iter *TextIter, anchor TextChildAnchor)
	// InsertInteractive inserts @text in @buffer.
	//
	// Like [method@Gtk.TextBuffer.insert], but the insertion will not occur if
	// @iter is at a non-editable location in the buffer. Usually you want to
	// prevent insertions at ineditable locations if the insertion results from
	// a user action (is interactive).
	//
	// @default_editable indicates the editability of text that doesn't have a
	// tag affecting editability applied to it. Typically the result of
	// [method@Gtk.TextView.get_editable] is appropriate here.
	InsertInteractive(iter *TextIter, text string, len int, defaultEditable bool) bool
	// InsertInteractiveAtCursor inserts @text in @buffer.
	//
	// Calls [method@Gtk.TextBuffer.insert_interactive] at the cursor position.
	//
	// @default_editable indicates the editability of text that doesn't have a
	// tag affecting editability applied to it. Typically the result of
	// [method@Gtk.TextView.get_editable] is appropriate here.
	InsertInteractiveAtCursor(text string, len int, defaultEditable bool) bool
	// InsertMarkup inserts the text in @markup at position @iter.
	//
	// @markup will be inserted in its entirety and must be nul-terminated and
	// valid UTF-8. Emits the [signal@Gtk.TextBuffer::insert-text] signal,
	// possibly multiple times; insertion actually occurs in the default handler
	// for the signal. @iter will point to the end of the inserted text on
	// return.
	InsertMarkup(iter *TextIter, markup string, len int)
	// InsertPaintable inserts an image into the text buffer at @iter.
	//
	// The image will be counted as one character in character counts, and when
	// obtaining the buffer contents as a string, will be represented by the
	// Unicode “object replacement character” 0xFFFC. Note that the “slice”
	// variants for obtaining portions of the buffer as a string include this
	// character for paintable, but the “text” variants do not. e.g. see
	// [method@Gtk.TextBuffer.get_slice] and [method@Gtk.TextBuffer.get_text].
	InsertPaintable(iter *TextIter, paintable gdk.Paintable)
	// InsertRange copies text, tags, and paintables between @start and @end and
	// inserts the copy at @iter.
	//
	// The order of @start and @end doesn’t matter.
	//
	// Used instead of simply getting/inserting text because it preserves images
	// and tags. If @start and @end are in a different buffer from @buffer, the
	// two buffers must share the same tag table.
	//
	// Implemented via emissions of the insert_text and apply_tag signals, so
	// expect those.
	InsertRange(iter *TextIter, start *TextIter, end *TextIter)
	// InsertRangeInteractive copies text, tags, and paintables between @start
	// and @end and inserts the copy at @iter.
	//
	// Same as [method@Gtk.TextBuffer.insert_range], but does nothing if the
	// insertion point isn’t editable. The @default_editable parameter indicates
	// whether the text is editable at @iter if no tags enclosing @iter affect
	// editability. Typically the result of [method@Gtk.TextView.get_editable]
	// is appropriate here.
	InsertRangeInteractive(iter *TextIter, start *TextIter, end *TextIter, defaultEditable bool) bool
	// MoveMark moves @mark to the new location @where.
	//
	// Emits the `GtkTextBuffer`::mark-set signal as notification of the move.
	MoveMark(mark TextMark, where *TextIter)
	// MoveMarkByName moves the mark named @name (which must exist) to location
	// @where.
	//
	// See [method@Gtk.TextBuffer.move_mark] for details.
	MoveMarkByName(name string, where *TextIter)
	// PasteClipboard pastes the contents of a clipboard.
	//
	// If @override_location is nil, the pasted text will be inserted at the
	// cursor position, or the buffer selection will be replaced if the
	// selection is non-empty.
	//
	// Note: pasting is asynchronous, that is, we’ll ask for the paste data and
	// return, and at some point later after the main loop runs, the paste data
	// will be inserted.
	PasteClipboard(clipboard gdk.Clipboard, overrideLocation *TextIter, defaultEditable bool)
	// PlaceCursor: this function moves the “insert” and “selection_bound” marks
	// simultaneously.
	//
	// If you move them to the same place in two steps with
	// [method@Gtk.TextBuffer.move_mark], you will temporarily select a region
	// in between their old and new locations, which can be pretty inefficient
	// since the temporarily-selected region will force stuff to be
	// recalculated. This function moves them as a unit, which can be optimized.
	PlaceCursor(where *TextIter)
	// Redo redoes the next redoable action on the buffer, if there is one.
	Redo()
	// RemoveAllTags removes all tags in the range between @start and @end.
	//
	// Be careful with this function; it could remove tags added in code
	// unrelated to the code you’re currently writing. That is, using this
	// function is probably a bad idea if you have two or more unrelated code
	// sections that add tags.
	RemoveAllTags(start *TextIter, end *TextIter)
	// RemoveSelectionClipboard removes a `GdkClipboard` added with
	// gtk_text_buffer_add_selection_clipboard().
	RemoveSelectionClipboard(clipboard gdk.Clipboard)
	// RemoveTag emits the “remove-tag” signal.
	//
	// The default handler for the signal removes all occurrences of @tag from
	// the given range. @start and @end don’t have to be in order.
	RemoveTag(tag TextTag, start *TextIter, end *TextIter)
	// RemoveTagByName emits the “remove-tag” signal.
	//
	// Calls [method@Gtk.TextTagTable.lookup] on the buffer’s tag table to get a
	// `GtkTextTag`, then calls [method@Gtk.TextBuffer.remove_tag].
	RemoveTagByName(name string, start *TextIter, end *TextIter)
	// SelectRange: this function moves the “insert” and “selection_bound” marks
	// simultaneously.
	//
	// If you move them in two steps with [method@Gtk.TextBuffer.move_mark], you
	// will temporarily select a region in between their old and new locations,
	// which can be pretty inefficient since the temporarily-selected region
	// will force stuff to be recalculated. This function moves them as a unit,
	// which can be optimized.
	SelectRange(ins *TextIter, bound *TextIter)
	// SetEnableUndo sets whether or not to enable undoable actions in the text
	// buffer.
	//
	// If enabled, the user will be able to undo the last number of actions up
	// to [method@Gtk.TextBuffer.get_max_undo_levels].
	//
	// See [method@Gtk.TextBuffer.begin_irreversible_action] and
	// [method@Gtk.TextBuffer.end_irreversible_action] to create changes to the
	// buffer that cannot be undone.
	SetEnableUndo(enableUndo bool)
	// SetMaxUndoLevels sets the maximum number of undo levels to perform.
	//
	// If 0, unlimited undo actions may be performed. Note that this may have a
	// memory usage impact as it requires storing an additional copy of the
	// inserted or removed text within the text buffer.
	SetMaxUndoLevels(maxUndoLevels uint)
	// SetModified: used to keep track of whether the buffer has been modified
	// since the last time it was saved.
	//
	// Whenever the buffer is saved to disk, call `gtk_text_buffer_set_modified
	// (@buffer, FALSE)`. When the buffer is modified, it will automatically
	// toggled on the modified bit again. When the modified bit flips, the
	// buffer emits the [signal@Gtk.TextBuffer::modified-changed] signal.
	SetModified(setting bool)
	// SetText deletes current contents of @buffer, and inserts @text instead.
	//
	// If @len is -1, @text must be nul-terminated. @text must be valid UTF-8.
	SetText(text string, len int)
	// Undo undoes the last undoable action on the buffer, if there is one.
	Undo()
}

// textBuffer implements the TextBuffer interface.
type textBuffer struct {
	gextras.Objector
}

var _ TextBuffer = (*textBuffer)(nil)

// WrapTextBuffer wraps a GObject to the right type. It is
// primarily used internally.
func WrapTextBuffer(obj *externglib.Object) TextBuffer {
	return TextBuffer{
		Objector: obj,
	}
}

func marshalTextBuffer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTextBuffer(obj), nil
}

// AddMark adds the mark at position @where.
//
// The mark must not be added to another buffer, and if its name is not nil
// then there must not be another mark in the buffer with the same name.
//
// Emits the `GtkTextBuffer`::mark-set signal as notification of the mark's
// initial placement.
func (b textBuffer) AddMark(mark TextMark, where *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextMark   // out
	var _arg2 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkTextMark)(unsafe.Pointer(mark.Native()))
	_arg2 = (*C.GtkTextIter)(unsafe.Pointer(where.Native()))

	C.gtk_text_buffer_add_mark(_arg0, _arg1, _arg2)
}

// AddSelectionClipboard adds @clipboard to the list of clipboards in which
// the selection contents of @buffer are available.
//
// In most cases, @clipboard will be the `GdkClipboard` returned by
// [method@Gtk.Widget.get_primary_clipboard] for a view of @buffer.
func (b textBuffer) AddSelectionClipboard(clipboard gdk.Clipboard) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GdkClipboard  // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GdkClipboard)(unsafe.Pointer(clipboard.Native()))

	C.gtk_text_buffer_add_selection_clipboard(_arg0, _arg1)
}

// ApplyTag emits the “apply-tag” signal on @buffer.
//
// The default handler for the signal applies @tag to the given range.
// @start and @end do not have to be in order.
func (b textBuffer) ApplyTag(tag TextTag, start *TextIter, end *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextTag    // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkTextTag)(unsafe.Pointer(tag.Native()))
	_arg2 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
	_arg3 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

	C.gtk_text_buffer_apply_tag(_arg0, _arg1, _arg2, _arg3)
}

// ApplyTagByName emits the “apply-tag” signal on @buffer.
//
// Calls [method@Gtk.TextTagTable.lookup] on the buffer’s tag table to get a
// `GtkTextTag`, then calls [method@Gtk.TextBuffer.apply_tag].
func (b textBuffer) ApplyTagByName(name string, start *TextIter, end *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.char          // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
	_arg3 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

	C.gtk_text_buffer_apply_tag_by_name(_arg0, _arg1, _arg2, _arg3)
}

// Backspace performs the appropriate action as if the user hit the delete
// key with the cursor at the position specified by @iter.
//
// In the normal case a single character will be deleted, but when combining
// accents are involved, more than one character can be deleted, and when
// precomposed character and accent combinations are involved, less than one
// character will be deleted.
//
// Because the buffer is modified, all outstanding iterators become invalid
// after calling this function; however, the @iter will be re-initialized to
// point to the location where text was deleted.
func (b textBuffer) Backspace(iter *TextIter, interactive bool, defaultEditable bool) bool {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 C.gboolean       // out
	var _arg3 C.gboolean       // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))
	if interactive {
		_arg2 = C.gboolean(1)
	}
	if defaultEditable {
		_arg3 = C.gboolean(1)
	}

	var _cret C.gboolean // in

	_cret = C.gtk_text_buffer_backspace(_arg0, _arg1, _arg2, _arg3)

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _ok
}

// BeginIrreversibleAction denotes the beginning of an action that may not
// be undone.
//
// This will cause any previous operations in the undo/redo queue to be
// cleared.
//
// This should be paired with a call to
// [method@Gtk.TextBuffer.end_irreversible_action] after the irreversible
// action has completed.
//
// You may nest calls to gtk_text_buffer_begin_irreversible_action() and
// gtk_text_buffer_end_irreversible_action() pairs.
func (b textBuffer) BeginIrreversibleAction() {
	var _arg0 *C.GtkTextBuffer // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	C.gtk_text_buffer_begin_irreversible_action(_arg0)
}

// BeginUserAction: called to indicate that the buffer operations between
// here and a call to gtk_text_buffer_end_user_action() are part of a single
// user-visible operation.
//
// The operations between gtk_text_buffer_begin_user_action() and
// gtk_text_buffer_end_user_action() can then be grouped when creating an
// undo stack. `GtkTextBuffer` maintains a count of calls to
// gtk_text_buffer_begin_user_action() that have not been closed with a call
// to gtk_text_buffer_end_user_action(), and emits the “begin-user-action”
// and “end-user-action” signals only for the outermost pair of calls. This
// allows you to build user actions from other user actions.
//
// The “interactive” buffer mutation functions, such as
// [method@Gtk.TextBuffer.insert_interactive], automatically call begin/end
// user action around the buffer operations they perform, so there's no need
// to add extra calls if you user action consists solely of a single call to
// one of those functions.
func (b textBuffer) BeginUserAction() {
	var _arg0 *C.GtkTextBuffer // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	C.gtk_text_buffer_begin_user_action(_arg0)
}

// CopyClipboard copies the currently-selected text to a clipboard.
func (b textBuffer) CopyClipboard(clipboard gdk.Clipboard) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GdkClipboard  // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GdkClipboard)(unsafe.Pointer(clipboard.Native()))

	C.gtk_text_buffer_copy_clipboard(_arg0, _arg1)
}

// CutClipboard copies the currently-selected text to a clipboard, then
// deletes said text if it’s editable.
func (b textBuffer) CutClipboard(clipboard gdk.Clipboard, defaultEditable bool) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GdkClipboard  // out
	var _arg2 C.gboolean       // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GdkClipboard)(unsafe.Pointer(clipboard.Native()))
	if defaultEditable {
		_arg2 = C.gboolean(1)
	}

	C.gtk_text_buffer_cut_clipboard(_arg0, _arg1, _arg2)
}

// Delete deletes text between @start and @end.
//
// The order of @start and @end is not actually relevant;
// gtk_text_buffer_delete() will reorder them.
//
// This function actually emits the “delete-range” signal, and the default
// handler of that signal deletes the text. Because the buffer is modified,
// all outstanding iterators become invalid after calling this function;
// however, the @start and @end will be re-initialized to point to the
// location where text was deleted.
func (b textBuffer) Delete(start *TextIter, end *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
	_arg2 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

	C.gtk_text_buffer_delete(_arg0, _arg1, _arg2)
}

// DeleteInteractive deletes all editable text in the given range.
//
// Calls [method@Gtk.TextBuffer.delete] for each editable sub-range of
// [@start,@end). @start and @end are revalidated to point to the location
// of the last deleted range, or left untouched if no text was deleted.
func (b textBuffer) DeleteInteractive(startIter *TextIter, endIter *TextIter, defaultEditable bool) bool {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 C.gboolean       // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(startIter.Native()))
	_arg2 = (*C.GtkTextIter)(unsafe.Pointer(endIter.Native()))
	if defaultEditable {
		_arg3 = C.gboolean(1)
	}

	var _cret C.gboolean // in

	_cret = C.gtk_text_buffer_delete_interactive(_arg0, _arg1, _arg2, _arg3)

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _ok
}

// DeleteMark deletes @mark, so that it’s no longer located anywhere in the
// buffer.
//
// Removes the reference the buffer holds to the mark, so if you haven’t
// called g_object_ref() on the mark, it will be freed. Even if the mark
// isn’t freed, most operations on @mark become invalid, until it gets added
// to a buffer again with [method@Gtk.TextBuffer.add_mark]. Use
// [method@Gtk.TextMark.get_deleted] to find out if a mark has been removed
// from its buffer.
//
// The [signal@Gtk.TextBuffer::mark-deleted] signal will be emitted as
// notification after the mark is deleted.
func (b textBuffer) DeleteMark(mark TextMark) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextMark   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkTextMark)(unsafe.Pointer(mark.Native()))

	C.gtk_text_buffer_delete_mark(_arg0, _arg1)
}

// DeleteMarkByName deletes the mark named @name; the mark must exist.
//
// See [method@Gtk.TextBuffer.delete_mark] for details.
func (b textBuffer) DeleteMarkByName(name string) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.char          // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_text_buffer_delete_mark_by_name(_arg0, _arg1)
}

// DeleteSelection deletes the range between the “insert” and
// “selection_bound” marks, that is, the currently-selected text.
//
// If @interactive is true, the editability of the selection will be
// considered (users can’t delete uneditable text).
func (b textBuffer) DeleteSelection(interactive bool, defaultEditable bool) bool {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 C.gboolean       // out
	var _arg2 C.gboolean       // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	if interactive {
		_arg1 = C.gboolean(1)
	}
	if defaultEditable {
		_arg2 = C.gboolean(1)
	}

	var _cret C.gboolean // in

	_cret = C.gtk_text_buffer_delete_selection(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _ok
}

// EndIrreversibleAction denotes the end of an action that may not be
// undone.
//
// This will cause any previous operations in the undo/redo queue to be
// cleared.
//
// This should be called after completing modifications to the text buffer
// after gtk_text_buffer_begin_irreversible_action() was called.
//
// You may nest calls to gtk_text_buffer_begin_irreversible_action() and
// gtk_text_buffer_end_irreversible_action() pairs.
func (b textBuffer) EndIrreversibleAction() {
	var _arg0 *C.GtkTextBuffer // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	C.gtk_text_buffer_end_irreversible_action(_arg0)
}

// EndUserAction ends a user-visible operation.
//
// Should be paired with a call to
// [method@Gtk.TextBuffer.begin_user_action]. See that function for a full
// explanation.
func (b textBuffer) EndUserAction() {
	var _arg0 *C.GtkTextBuffer // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	C.gtk_text_buffer_end_user_action(_arg0)
}

// Bounds retrieves the first and last iterators in the buffer, i.e. the
// entire buffer lies within the range [@start,@end).
func (b textBuffer) Bounds() (start TextIter, end TextIter) {
	var _arg0 *C.GtkTextBuffer // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	var _start TextIter
	var _end TextIter

	C.gtk_text_buffer_get_bounds(_arg0, (*C.GtkTextIter)(unsafe.Pointer(&_start)), (*C.GtkTextIter)(unsafe.Pointer(&_end)))

	return _start, _end
}

// CanRedo gets whether there is a redoable action in the history.
func (b textBuffer) CanRedo() bool {
	var _arg0 *C.GtkTextBuffer // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	var _cret C.gboolean // in

	_cret = C.gtk_text_buffer_get_can_redo(_arg0)

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _ok
}

// CanUndo gets whether there is an undoable action in the history.
func (b textBuffer) CanUndo() bool {
	var _arg0 *C.GtkTextBuffer // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	var _cret C.gboolean // in

	_cret = C.gtk_text_buffer_get_can_undo(_arg0)

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _ok
}

// CharCount gets the number of characters in the buffer.
//
// Note that characters and bytes are not the same, you can’t e.g. expect
// the contents of the buffer in string form to be this many bytes long.
//
// The character count is cached, so this function is very fast.
func (b textBuffer) CharCount() int {
	var _arg0 *C.GtkTextBuffer // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	var _cret C.int // in

	_cret = C.gtk_text_buffer_get_char_count(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// EnableUndo gets whether the buffer is saving modifications to the buffer
// to allow for undo and redo actions.
//
// See [method@Gtk.TextBuffer.begin_irreversible_action] and
// [method@Gtk.TextBuffer.end_irreversible_action] to create changes to the
// buffer that cannot be undone.
func (b textBuffer) EnableUndo() bool {
	var _arg0 *C.GtkTextBuffer // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	var _cret C.gboolean // in

	_cret = C.gtk_text_buffer_get_enable_undo(_arg0)

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _ok
}

// EndIter initializes @iter with the “end iterator,” one past the last
// valid character in the text buffer.
//
// If dereferenced with [method@Gtk.TextIter.get_char], the end iterator has
// a character value of 0. The entire buffer lies in the range from the
// first position in the buffer (call [method@Gtk.TextBuffer.get_start_iter]
// to get character position 0) to the end iterator.
func (b textBuffer) EndIter() TextIter {
	var _arg0 *C.GtkTextBuffer // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	var _iter TextIter

	C.gtk_text_buffer_get_end_iter(_arg0, (*C.GtkTextIter)(unsafe.Pointer(&_iter)))

	return _iter
}

// HasSelection indicates whether the buffer has some text currently
// selected.
func (b textBuffer) HasSelection() bool {
	var _arg0 *C.GtkTextBuffer // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	var _cret C.gboolean // in

	_cret = C.gtk_text_buffer_get_has_selection(_arg0)

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _ok
}

// IterAtChildAnchor obtains the location of @anchor within @buffer.
func (b textBuffer) IterAtChildAnchor(anchor TextChildAnchor) TextIter {
	var _arg0 *C.GtkTextBuffer      // out
	var _arg2 *C.GtkTextChildAnchor // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg2 = (*C.GtkTextChildAnchor)(unsafe.Pointer(anchor.Native()))

	var _iter TextIter

	C.gtk_text_buffer_get_iter_at_child_anchor(_arg0, _arg2, (*C.GtkTextIter)(unsafe.Pointer(&_iter)))

	return _iter
}

// IterAtLine initializes @iter to the start of the given line.
//
// If @line_number is greater than or equal to the number of lines in the
// @buffer, the end iterator is returned.
func (b textBuffer) IterAtLine(lineNumber int) (TextIter, bool) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg2 C.int            // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg2 = C.int(lineNumber)

	var _iter TextIter
	var _cret C.gboolean // in

	_cret = C.gtk_text_buffer_get_iter_at_line(_arg0, _arg2, (*C.GtkTextIter)(unsafe.Pointer(&_iter)))

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _iter, _ok
}

// IterAtLineIndex obtains an iterator pointing to @byte_index within the
// given line.
//
// @byte_index must be the start of a UTF-8 character. Note bytes, not
// characters; UTF-8 may encode one character as multiple bytes.
//
// If @line_number is greater than or equal to the number of lines in the
// @buffer, the end iterator is returned. And if @byte_index is off the end
// of the line, the iterator at the end of the line is returned.
func (b textBuffer) IterAtLineIndex(lineNumber int, byteIndex int) (TextIter, bool) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg2 C.int            // out
	var _arg3 C.int            // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg2 = C.int(lineNumber)
	_arg3 = C.int(byteIndex)

	var _iter TextIter
	var _cret C.gboolean // in

	_cret = C.gtk_text_buffer_get_iter_at_line_index(_arg0, _arg2, _arg3, (*C.GtkTextIter)(unsafe.Pointer(&_iter)))

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _iter, _ok
}

// IterAtLineOffset obtains an iterator pointing to @char_offset within the
// given line.
//
// Note characters, not bytes; UTF-8 may encode one character as multiple
// bytes.
//
// If @line_number is greater than or equal to the number of lines in the
// @buffer, the end iterator is returned. And if @char_offset is off the end
// of the line, the iterator at the end of the line is returned.
func (b textBuffer) IterAtLineOffset(lineNumber int, charOffset int) (TextIter, bool) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg2 C.int            // out
	var _arg3 C.int            // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg2 = C.int(lineNumber)
	_arg3 = C.int(charOffset)

	var _iter TextIter
	var _cret C.gboolean // in

	_cret = C.gtk_text_buffer_get_iter_at_line_offset(_arg0, _arg2, _arg3, (*C.GtkTextIter)(unsafe.Pointer(&_iter)))

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _iter, _ok
}

// IterAtMark initializes @iter with the current position of @mark.
func (b textBuffer) IterAtMark(mark TextMark) TextIter {
	var _arg0 *C.GtkTextBuffer // out
	var _arg2 *C.GtkTextMark   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg2 = (*C.GtkTextMark)(unsafe.Pointer(mark.Native()))

	var _iter TextIter

	C.gtk_text_buffer_get_iter_at_mark(_arg0, _arg2, (*C.GtkTextIter)(unsafe.Pointer(&_iter)))

	return _iter
}

// IterAtOffset initializes @iter to a position @char_offset chars from the
// start of the entire buffer.
//
// If @char_offset is -1 or greater than the number of characters in the
// buffer, @iter is initialized to the end iterator, the iterator one past
// the last valid character in the buffer.
func (b textBuffer) IterAtOffset(charOffset int) TextIter {
	var _arg0 *C.GtkTextBuffer // out
	var _arg2 C.int            // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg2 = C.int(charOffset)

	var _iter TextIter

	C.gtk_text_buffer_get_iter_at_offset(_arg0, _arg2, (*C.GtkTextIter)(unsafe.Pointer(&_iter)))

	return _iter
}

// LineCount obtains the number of lines in the buffer.
//
// This value is cached, so the function is very fast.
func (b textBuffer) LineCount() int {
	var _arg0 *C.GtkTextBuffer // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	var _cret C.int // in

	_cret = C.gtk_text_buffer_get_line_count(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// MaxUndoLevels gets the maximum number of undo levels to perform.
//
// If 0, unlimited undo actions may be performed. Note that this may have a
// memory usage impact as it requires storing an additional copy of the
// inserted or removed text within the text buffer.
func (b textBuffer) MaxUndoLevels() uint {
	var _arg0 *C.GtkTextBuffer // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	var _cret C.guint // in

	_cret = C.gtk_text_buffer_get_max_undo_levels(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

// Modified indicates whether the buffer has been modified since the last
// call to [method@Gtk.TextBuffer.set_modified] set the modification flag to
// false.
//
// Used for example to enable a “save” function in a text editor.
func (b textBuffer) Modified() bool {
	var _arg0 *C.GtkTextBuffer // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	var _cret C.gboolean // in

	_cret = C.gtk_text_buffer_get_modified(_arg0)

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _ok
}

// SelectionBounds returns true if some text is selected; places the bounds
// of the selection in @start and @end.
//
// If the selection has length 0, then @start and @end are filled in with
// the same value. @start and @end will be in ascending order. If @start and
// @end are nil, then they are not filled in, but the return value still
// indicates whether text is selected.
func (b textBuffer) SelectionBounds() (start TextIter, end TextIter, ok bool) {
	var _arg0 *C.GtkTextBuffer // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	var _start TextIter
	var _end TextIter
	var _cret C.gboolean // in

	_cret = C.gtk_text_buffer_get_selection_bounds(_arg0, (*C.GtkTextIter)(unsafe.Pointer(&_start)), (*C.GtkTextIter)(unsafe.Pointer(&_end)))

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _start, _end, _ok
}

// Slice returns the text in the range [@start,@end).
//
// Excludes undisplayed text (text marked with tags that set the
// invisibility attribute) if @include_hidden_chars is false. The returned
// string includes a 0xFFFC character whenever the buffer contains embedded
// images, so byte and character indexes into the returned string do
// correspond to byte and character indexes into the buffer. Contrast with
// [method@Gtk.TextBuffer.get_text]. Note that 0xFFFC can occur in normal
// text as well, so it is not a reliable indicator that a paintable or
// widget is in the buffer.
func (b textBuffer) Slice(start *TextIter, end *TextIter, includeHiddenChars bool) string {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 C.gboolean       // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
	_arg2 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))
	if includeHiddenChars {
		_arg3 = C.gboolean(1)
	}

	var _cret *C.char // in

	_cret = C.gtk_text_buffer_get_slice(_arg0, _arg1, _arg2, _arg3)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// StartIter: initialized @iter with the first position in the text buffer.
//
// This is the same as using [method@Gtk.TextBuffer.get_iter_at_offset] to
// get the iter at character offset 0.
func (b textBuffer) StartIter() TextIter {
	var _arg0 *C.GtkTextBuffer // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	var _iter TextIter

	C.gtk_text_buffer_get_start_iter(_arg0, (*C.GtkTextIter)(unsafe.Pointer(&_iter)))

	return _iter
}

// Text returns the text in the range [@start,@end).
//
// Excludes undisplayed text (text marked with tags that set the
// invisibility attribute) if @include_hidden_chars is false. Does not
// include characters representing embedded images, so byte and character
// indexes into the returned string do not correspond to byte and character
// indexes into the buffer. Contrast with [method@Gtk.TextBuffer.get_slice].
func (b textBuffer) Text(start *TextIter, end *TextIter, includeHiddenChars bool) string {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 C.gboolean       // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
	_arg2 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))
	if includeHiddenChars {
		_arg3 = C.gboolean(1)
	}

	var _cret *C.char // in

	_cret = C.gtk_text_buffer_get_text(_arg0, _arg1, _arg2, _arg3)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Insert inserts @len bytes of @text at position @iter.
//
// If @len is -1, @text must be nul-terminated and will be inserted in its
// entirety. Emits the “insert-text” signal; insertion actually occurs in
// the default handler for the signal. @iter is invalidated when insertion
// occurs (because the buffer contents change), but the default signal
// handler revalidates it to point to the end of the inserted text.
func (b textBuffer) Insert(iter *TextIter, text string, len int) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.char          // out
	var _arg3 C.int            // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))
	_arg2 = (*C.char)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = C.int(len)

	C.gtk_text_buffer_insert(_arg0, _arg1, _arg2, _arg3)
}

// InsertAtCursor inserts @text in @buffer.
//
// Simply calls [method@Gtk.TextBuffer.insert], using the current cursor
// position as the insertion point.
func (b textBuffer) InsertAtCursor(text string, len int) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.char          // out
	var _arg2 C.int            // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.char)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.int(len)

	C.gtk_text_buffer_insert_at_cursor(_arg0, _arg1, _arg2)
}

// InsertChildAnchor inserts a child widget anchor into the text buffer at
// @iter.
//
// The anchor will be counted as one character in character counts, and when
// obtaining the buffer contents as a string, will be represented by the
// Unicode “object replacement character” 0xFFFC. Note that the “slice”
// variants for obtaining portions of the buffer as a string include this
// character for child anchors, but the “text” variants do not. E.g. see
// [method@Gtk.TextBuffer.get_slice] and [method@Gtk.TextBuffer.get_text].
//
// Consider [method@Gtk.TextBuffer.create_child_anchor] as a more convenient
// alternative to this function. The buffer will add a reference to the
// anchor, so you can unref it after insertion.
func (b textBuffer) InsertChildAnchor(iter *TextIter, anchor TextChildAnchor) {
	var _arg0 *C.GtkTextBuffer      // out
	var _arg1 *C.GtkTextIter        // out
	var _arg2 *C.GtkTextChildAnchor // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))
	_arg2 = (*C.GtkTextChildAnchor)(unsafe.Pointer(anchor.Native()))

	C.gtk_text_buffer_insert_child_anchor(_arg0, _arg1, _arg2)
}

// InsertInteractive inserts @text in @buffer.
//
// Like [method@Gtk.TextBuffer.insert], but the insertion will not occur if
// @iter is at a non-editable location in the buffer. Usually you want to
// prevent insertions at ineditable locations if the insertion results from
// a user action (is interactive).
//
// @default_editable indicates the editability of text that doesn't have a
// tag affecting editability applied to it. Typically the result of
// [method@Gtk.TextView.get_editable] is appropriate here.
func (b textBuffer) InsertInteractive(iter *TextIter, text string, len int, defaultEditable bool) bool {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.char          // out
	var _arg3 C.int            // out
	var _arg4 C.gboolean       // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))
	_arg2 = (*C.char)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = C.int(len)
	if defaultEditable {
		_arg4 = C.gboolean(1)
	}

	var _cret C.gboolean // in

	_cret = C.gtk_text_buffer_insert_interactive(_arg0, _arg1, _arg2, _arg3, _arg4)

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _ok
}

// InsertInteractiveAtCursor inserts @text in @buffer.
//
// Calls [method@Gtk.TextBuffer.insert_interactive] at the cursor position.
//
// @default_editable indicates the editability of text that doesn't have a
// tag affecting editability applied to it. Typically the result of
// [method@Gtk.TextView.get_editable] is appropriate here.
func (b textBuffer) InsertInteractiveAtCursor(text string, len int, defaultEditable bool) bool {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.char          // out
	var _arg2 C.int            // out
	var _arg3 C.gboolean       // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.char)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.int(len)
	if defaultEditable {
		_arg3 = C.gboolean(1)
	}

	var _cret C.gboolean // in

	_cret = C.gtk_text_buffer_insert_interactive_at_cursor(_arg0, _arg1, _arg2, _arg3)

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _ok
}

// InsertMarkup inserts the text in @markup at position @iter.
//
// @markup will be inserted in its entirety and must be nul-terminated and
// valid UTF-8. Emits the [signal@Gtk.TextBuffer::insert-text] signal,
// possibly multiple times; insertion actually occurs in the default handler
// for the signal. @iter will point to the end of the inserted text on
// return.
func (b textBuffer) InsertMarkup(iter *TextIter, markup string, len int) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.char          // out
	var _arg3 C.int            // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))
	_arg2 = (*C.char)(C.CString(markup))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = C.int(len)

	C.gtk_text_buffer_insert_markup(_arg0, _arg1, _arg2, _arg3)
}

// InsertPaintable inserts an image into the text buffer at @iter.
//
// The image will be counted as one character in character counts, and when
// obtaining the buffer contents as a string, will be represented by the
// Unicode “object replacement character” 0xFFFC. Note that the “slice”
// variants for obtaining portions of the buffer as a string include this
// character for paintable, but the “text” variants do not. e.g. see
// [method@Gtk.TextBuffer.get_slice] and [method@Gtk.TextBuffer.get_text].
func (b textBuffer) InsertPaintable(iter *TextIter, paintable gdk.Paintable) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.GdkPaintable  // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))
	_arg2 = (*C.GdkPaintable)(unsafe.Pointer(paintable.Native()))

	C.gtk_text_buffer_insert_paintable(_arg0, _arg1, _arg2)
}

// InsertRange copies text, tags, and paintables between @start and @end and
// inserts the copy at @iter.
//
// The order of @start and @end doesn’t matter.
//
// Used instead of simply getting/inserting text because it preserves images
// and tags. If @start and @end are in a different buffer from @buffer, the
// two buffers must share the same tag table.
//
// Implemented via emissions of the insert_text and apply_tag signals, so
// expect those.
func (b textBuffer) InsertRange(iter *TextIter, start *TextIter, end *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))
	_arg2 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
	_arg3 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

	C.gtk_text_buffer_insert_range(_arg0, _arg1, _arg2, _arg3)
}

// InsertRangeInteractive copies text, tags, and paintables between @start
// and @end and inserts the copy at @iter.
//
// Same as [method@Gtk.TextBuffer.insert_range], but does nothing if the
// insertion point isn’t editable. The @default_editable parameter indicates
// whether the text is editable at @iter if no tags enclosing @iter affect
// editability. Typically the result of [method@Gtk.TextView.get_editable]
// is appropriate here.
func (b textBuffer) InsertRangeInteractive(iter *TextIter, start *TextIter, end *TextIter, defaultEditable bool) bool {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 *C.GtkTextIter   // out
	var _arg4 C.gboolean       // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))
	_arg2 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
	_arg3 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))
	if defaultEditable {
		_arg4 = C.gboolean(1)
	}

	var _cret C.gboolean // in

	_cret = C.gtk_text_buffer_insert_range_interactive(_arg0, _arg1, _arg2, _arg3, _arg4)

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _ok
}

// MoveMark moves @mark to the new location @where.
//
// Emits the `GtkTextBuffer`::mark-set signal as notification of the move.
func (b textBuffer) MoveMark(mark TextMark, where *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextMark   // out
	var _arg2 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkTextMark)(unsafe.Pointer(mark.Native()))
	_arg2 = (*C.GtkTextIter)(unsafe.Pointer(where.Native()))

	C.gtk_text_buffer_move_mark(_arg0, _arg1, _arg2)
}

// MoveMarkByName moves the mark named @name (which must exist) to location
// @where.
//
// See [method@Gtk.TextBuffer.move_mark] for details.
func (b textBuffer) MoveMarkByName(name string, where *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.char          // out
	var _arg2 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GtkTextIter)(unsafe.Pointer(where.Native()))

	C.gtk_text_buffer_move_mark_by_name(_arg0, _arg1, _arg2)
}

// PasteClipboard pastes the contents of a clipboard.
//
// If @override_location is nil, the pasted text will be inserted at the
// cursor position, or the buffer selection will be replaced if the
// selection is non-empty.
//
// Note: pasting is asynchronous, that is, we’ll ask for the paste data and
// return, and at some point later after the main loop runs, the paste data
// will be inserted.
func (b textBuffer) PasteClipboard(clipboard gdk.Clipboard, overrideLocation *TextIter, defaultEditable bool) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GdkClipboard  // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 C.gboolean       // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GdkClipboard)(unsafe.Pointer(clipboard.Native()))
	_arg2 = (*C.GtkTextIter)(unsafe.Pointer(overrideLocation.Native()))
	if defaultEditable {
		_arg3 = C.gboolean(1)
	}

	C.gtk_text_buffer_paste_clipboard(_arg0, _arg1, _arg2, _arg3)
}

// PlaceCursor: this function moves the “insert” and “selection_bound” marks
// simultaneously.
//
// If you move them to the same place in two steps with
// [method@Gtk.TextBuffer.move_mark], you will temporarily select a region
// in between their old and new locations, which can be pretty inefficient
// since the temporarily-selected region will force stuff to be
// recalculated. This function moves them as a unit, which can be optimized.
func (b textBuffer) PlaceCursor(where *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(where.Native()))

	C.gtk_text_buffer_place_cursor(_arg0, _arg1)
}

// Redo redoes the next redoable action on the buffer, if there is one.
func (b textBuffer) Redo() {
	var _arg0 *C.GtkTextBuffer // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	C.gtk_text_buffer_redo(_arg0)
}

// RemoveAllTags removes all tags in the range between @start and @end.
//
// Be careful with this function; it could remove tags added in code
// unrelated to the code you’re currently writing. That is, using this
// function is probably a bad idea if you have two or more unrelated code
// sections that add tags.
func (b textBuffer) RemoveAllTags(start *TextIter, end *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
	_arg2 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

	C.gtk_text_buffer_remove_all_tags(_arg0, _arg1, _arg2)
}

// RemoveSelectionClipboard removes a `GdkClipboard` added with
// gtk_text_buffer_add_selection_clipboard().
func (b textBuffer) RemoveSelectionClipboard(clipboard gdk.Clipboard) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GdkClipboard  // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GdkClipboard)(unsafe.Pointer(clipboard.Native()))

	C.gtk_text_buffer_remove_selection_clipboard(_arg0, _arg1)
}

// RemoveTag emits the “remove-tag” signal.
//
// The default handler for the signal removes all occurrences of @tag from
// the given range. @start and @end don’t have to be in order.
func (b textBuffer) RemoveTag(tag TextTag, start *TextIter, end *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextTag    // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkTextTag)(unsafe.Pointer(tag.Native()))
	_arg2 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
	_arg3 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

	C.gtk_text_buffer_remove_tag(_arg0, _arg1, _arg2, _arg3)
}

// RemoveTagByName emits the “remove-tag” signal.
//
// Calls [method@Gtk.TextTagTable.lookup] on the buffer’s tag table to get a
// `GtkTextTag`, then calls [method@Gtk.TextBuffer.remove_tag].
func (b textBuffer) RemoveTagByName(name string, start *TextIter, end *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.char          // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
	_arg3 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

	C.gtk_text_buffer_remove_tag_by_name(_arg0, _arg1, _arg2, _arg3)
}

// SelectRange: this function moves the “insert” and “selection_bound” marks
// simultaneously.
//
// If you move them in two steps with [method@Gtk.TextBuffer.move_mark], you
// will temporarily select a region in between their old and new locations,
// which can be pretty inefficient since the temporarily-selected region
// will force stuff to be recalculated. This function moves them as a unit,
// which can be optimized.
func (b textBuffer) SelectRange(ins *TextIter, bound *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(ins.Native()))
	_arg2 = (*C.GtkTextIter)(unsafe.Pointer(bound.Native()))

	C.gtk_text_buffer_select_range(_arg0, _arg1, _arg2)
}

// SetEnableUndo sets whether or not to enable undoable actions in the text
// buffer.
//
// If enabled, the user will be able to undo the last number of actions up
// to [method@Gtk.TextBuffer.get_max_undo_levels].
//
// See [method@Gtk.TextBuffer.begin_irreversible_action] and
// [method@Gtk.TextBuffer.end_irreversible_action] to create changes to the
// buffer that cannot be undone.
func (b textBuffer) SetEnableUndo(enableUndo bool) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	if enableUndo {
		_arg1 = C.gboolean(1)
	}

	C.gtk_text_buffer_set_enable_undo(_arg0, _arg1)
}

// SetMaxUndoLevels sets the maximum number of undo levels to perform.
//
// If 0, unlimited undo actions may be performed. Note that this may have a
// memory usage impact as it requires storing an additional copy of the
// inserted or removed text within the text buffer.
func (b textBuffer) SetMaxUndoLevels(maxUndoLevels uint) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 C.guint          // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = C.guint(maxUndoLevels)

	C.gtk_text_buffer_set_max_undo_levels(_arg0, _arg1)
}

// SetModified: used to keep track of whether the buffer has been modified
// since the last time it was saved.
//
// Whenever the buffer is saved to disk, call `gtk_text_buffer_set_modified
// (@buffer, FALSE)`. When the buffer is modified, it will automatically
// toggled on the modified bit again. When the modified bit flips, the
// buffer emits the [signal@Gtk.TextBuffer::modified-changed] signal.
func (b textBuffer) SetModified(setting bool) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	if setting {
		_arg1 = C.gboolean(1)
	}

	C.gtk_text_buffer_set_modified(_arg0, _arg1)
}

// SetText deletes current contents of @buffer, and inserts @text instead.
//
// If @len is -1, @text must be nul-terminated. @text must be valid UTF-8.
func (b textBuffer) SetText(text string, len int) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.char          // out
	var _arg2 C.int            // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.char)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.int(len)

	C.gtk_text_buffer_set_text(_arg0, _arg1, _arg2)
}

// Undo undoes the last undoable action on the buffer, if there is one.
func (b textBuffer) Undo() {
	var _arg0 *C.GtkTextBuffer // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	C.gtk_text_buffer_undo(_arg0)
}
