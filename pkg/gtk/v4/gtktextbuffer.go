// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"unsafe"

	"github.com/diamondburned/gotk4/core/gextras"
	"github.com/diamondburned/gotk4/pkg/gdk/v4"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gtk4
// #cgo CFLAGS: -Wno-deprecated-declarations
//
// #include <glib-object.h>
// #include <gtk/gtk.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_text_buffer_get_type()), F: marshalTextBuffer},
	})
}

// TextBuffer stores text and attributes for display in a `GtkTextView`.
//
// You may wish to begin by reading the text widget conceptual overview
// (section-text-widget.html), which gives an overview of all the objects and
// data types related to the text widget and how they work together.
type TextBuffer interface {
	gextras.Objector

	// AddMarkTextBuffer:
	AddMarkTextBuffer(mark TextMark, where *TextIter)
	// AddSelectionClipboardTextBuffer:
	AddSelectionClipboardTextBuffer(clipboard gdk.Clipboard)
	// ApplyTagTextBuffer:
	ApplyTagTextBuffer(tag TextTag, start *TextIter, end *TextIter)
	// ApplyTagByNameTextBuffer:
	ApplyTagByNameTextBuffer(name string, start *TextIter, end *TextIter)
	// BackspaceTextBuffer:
	BackspaceTextBuffer(iter *TextIter, interactive bool, defaultEditable bool) bool
	// BeginIrreversibleActionTextBuffer:
	BeginIrreversibleActionTextBuffer()
	// BeginUserActionTextBuffer:
	BeginUserActionTextBuffer()
	// CopyClipboardTextBuffer:
	CopyClipboardTextBuffer(clipboard gdk.Clipboard)
	// CreateChildAnchorTextBuffer:
	CreateChildAnchorTextBuffer(iter *TextIter) TextChildAnchor
	// CreateMarkTextBuffer:
	CreateMarkTextBuffer(markName string, where *TextIter, leftGravity bool) TextMark
	// CutClipboardTextBuffer:
	CutClipboardTextBuffer(clipboard gdk.Clipboard, defaultEditable bool)
	// DeleteTextBuffer:
	DeleteTextBuffer(start *TextIter, end *TextIter)
	// DeleteInteractiveTextBuffer:
	DeleteInteractiveTextBuffer(startIter *TextIter, endIter *TextIter, defaultEditable bool) bool
	// DeleteMarkTextBuffer:
	DeleteMarkTextBuffer(mark TextMark)
	// DeleteMarkByNameTextBuffer:
	DeleteMarkByNameTextBuffer(name string)
	// DeleteSelectionTextBuffer:
	DeleteSelectionTextBuffer(interactive bool, defaultEditable bool) bool
	// EndIrreversibleActionTextBuffer:
	EndIrreversibleActionTextBuffer()
	// EndUserActionTextBuffer:
	EndUserActionTextBuffer()
	// Bounds:
	Bounds() (start TextIter, end TextIter)
	// CanRedo:
	CanRedo() bool
	// CanUndo:
	CanUndo() bool
	// CharCount:
	CharCount() int
	// EnableUndo:
	EnableUndo() bool
	// EndIter:
	EndIter() TextIter
	// HasSelection:
	HasSelection() bool
	// GetInsert:
	GetInsert() TextMark
	// IterAtChildAnchor:
	IterAtChildAnchor(anchor TextChildAnchor) TextIter
	// IterAtLine:
	IterAtLine(lineNumber int) (TextIter, bool)
	// IterAtLineIndex:
	IterAtLineIndex(lineNumber int, byteIndex int) (TextIter, bool)
	// IterAtLineOffset:
	IterAtLineOffset(lineNumber int, charOffset int) (TextIter, bool)
	// IterAtMark:
	IterAtMark(mark TextMark) TextIter
	// IterAtOffset:
	IterAtOffset(charOffset int) TextIter
	// LineCount:
	LineCount() int
	// Mark:
	Mark(name string) TextMark
	// MaxUndoLevels:
	MaxUndoLevels() uint
	// Modified:
	Modified() bool
	// SelectionBound:
	SelectionBound() TextMark
	// SelectionBounds:
	SelectionBounds() (start TextIter, end TextIter, ok bool)
	// SelectionContent:
	SelectionContent() gdk.ContentProvider
	// Slice:
	Slice(start *TextIter, end *TextIter, includeHiddenChars bool) string
	// StartIter:
	StartIter() TextIter
	// TagTable:
	TagTable() TextTagTable
	// Text:
	Text(start *TextIter, end *TextIter, includeHiddenChars bool) string
	// InsertTextBuffer:
	InsertTextBuffer(iter *TextIter, text string, len int)
	// InsertAtCursorTextBuffer:
	InsertAtCursorTextBuffer(text string, len int)
	// InsertChildAnchorTextBuffer:
	InsertChildAnchorTextBuffer(iter *TextIter, anchor TextChildAnchor)
	// InsertInteractiveTextBuffer:
	InsertInteractiveTextBuffer(iter *TextIter, text string, len int, defaultEditable bool) bool
	// InsertInteractiveAtCursorTextBuffer:
	InsertInteractiveAtCursorTextBuffer(text string, len int, defaultEditable bool) bool
	// InsertMarkupTextBuffer:
	InsertMarkupTextBuffer(iter *TextIter, markup string, len int)
	// InsertPaintableTextBuffer:
	InsertPaintableTextBuffer(iter *TextIter, paintable gdk.Paintable)
	// InsertRangeTextBuffer:
	InsertRangeTextBuffer(iter *TextIter, start *TextIter, end *TextIter)
	// InsertRangeInteractiveTextBuffer:
	InsertRangeInteractiveTextBuffer(iter *TextIter, start *TextIter, end *TextIter, defaultEditable bool) bool
	// MoveMarkTextBuffer:
	MoveMarkTextBuffer(mark TextMark, where *TextIter)
	// MoveMarkByNameTextBuffer:
	MoveMarkByNameTextBuffer(name string, where *TextIter)
	// PasteClipboardTextBuffer:
	PasteClipboardTextBuffer(clipboard gdk.Clipboard, overrideLocation *TextIter, defaultEditable bool)
	// PlaceCursorTextBuffer:
	PlaceCursorTextBuffer(where *TextIter)
	// RedoTextBuffer:
	RedoTextBuffer()
	// RemoveAllTagsTextBuffer:
	RemoveAllTagsTextBuffer(start *TextIter, end *TextIter)
	// RemoveSelectionClipboardTextBuffer:
	RemoveSelectionClipboardTextBuffer(clipboard gdk.Clipboard)
	// RemoveTagTextBuffer:
	RemoveTagTextBuffer(tag TextTag, start *TextIter, end *TextIter)
	// RemoveTagByNameTextBuffer:
	RemoveTagByNameTextBuffer(name string, start *TextIter, end *TextIter)
	// SelectRangeTextBuffer:
	SelectRangeTextBuffer(ins *TextIter, bound *TextIter)
	// SetEnableUndoTextBuffer:
	SetEnableUndoTextBuffer(enableUndo bool)
	// SetMaxUndoLevelsTextBuffer:
	SetMaxUndoLevelsTextBuffer(maxUndoLevels uint)
	// SetModifiedTextBuffer:
	SetModifiedTextBuffer(setting bool)
	// SetTextTextBuffer:
	SetTextTextBuffer(text string, len int)
	// UndoTextBuffer:
	UndoTextBuffer()
}

// textBuffer implements the TextBuffer class.
type textBuffer struct {
	gextras.Objector
}

// WrapTextBuffer wraps a GObject to the right type. It is
// primarily used internally.
func WrapTextBuffer(obj *externglib.Object) TextBuffer {
	return textBuffer{
		Objector: obj,
	}
}

func marshalTextBuffer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTextBuffer(obj), nil
}

// NewTextBuffer:
func NewTextBuffer(table TextTagTable) TextBuffer {
	var _arg1 *C.GtkTextTagTable // out
	var _cret *C.GtkTextBuffer   // in

	_arg1 = (*C.GtkTextTagTable)(unsafe.Pointer(table.Native()))

	_cret = C.gtk_text_buffer_new(_arg1)

	var _textBuffer TextBuffer // out

	_textBuffer = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(TextBuffer)

	return _textBuffer
}

func (b textBuffer) AddMarkTextBuffer(mark TextMark, where *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextMark   // out
	var _arg2 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkTextMark)(unsafe.Pointer(mark.Native()))
	_arg2 = (*C.GtkTextIter)(unsafe.Pointer(where.Native()))

	C.gtk_text_buffer_add_mark(_arg0, _arg1, _arg2)
}

func (b textBuffer) AddSelectionClipboardTextBuffer(clipboard gdk.Clipboard) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GdkClipboard  // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GdkClipboard)(unsafe.Pointer(clipboard.Native()))

	C.gtk_text_buffer_add_selection_clipboard(_arg0, _arg1)
}

func (b textBuffer) ApplyTagTextBuffer(tag TextTag, start *TextIter, end *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextTag    // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkTextTag)(unsafe.Pointer(tag.Native()))
	_arg2 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
	_arg3 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

	C.gtk_text_buffer_apply_tag(_arg0, _arg1, _arg2, _arg3)
}

func (b textBuffer) ApplyTagByNameTextBuffer(name string, start *TextIter, end *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.char          // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
	_arg3 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

	C.gtk_text_buffer_apply_tag_by_name(_arg0, _arg1, _arg2, _arg3)
}

func (b textBuffer) BackspaceTextBuffer(iter *TextIter, interactive bool, defaultEditable bool) bool {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 C.gboolean       // out
	var _arg3 C.gboolean       // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))
	if interactive {
		_arg2 = C.TRUE
	}
	if defaultEditable {
		_arg3 = C.TRUE
	}

	_cret = C.gtk_text_buffer_backspace(_arg0, _arg1, _arg2, _arg3)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (b textBuffer) BeginIrreversibleActionTextBuffer() {
	var _arg0 *C.GtkTextBuffer // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	C.gtk_text_buffer_begin_irreversible_action(_arg0)
}

func (b textBuffer) BeginUserActionTextBuffer() {
	var _arg0 *C.GtkTextBuffer // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	C.gtk_text_buffer_begin_user_action(_arg0)
}

func (b textBuffer) CopyClipboardTextBuffer(clipboard gdk.Clipboard) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GdkClipboard  // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GdkClipboard)(unsafe.Pointer(clipboard.Native()))

	C.gtk_text_buffer_copy_clipboard(_arg0, _arg1)
}

func (b textBuffer) CreateChildAnchorTextBuffer(iter *TextIter) TextChildAnchor {
	var _arg0 *C.GtkTextBuffer      // out
	var _arg1 *C.GtkTextIter        // out
	var _cret *C.GtkTextChildAnchor // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))

	_cret = C.gtk_text_buffer_create_child_anchor(_arg0, _arg1)

	var _textChildAnchor TextChildAnchor // out

	_textChildAnchor = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TextChildAnchor)

	return _textChildAnchor
}

func (b textBuffer) CreateMarkTextBuffer(markName string, where *TextIter, leftGravity bool) TextMark {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.char          // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 C.gboolean       // out
	var _cret *C.GtkTextMark   // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.char)(C.CString(markName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GtkTextIter)(unsafe.Pointer(where.Native()))
	if leftGravity {
		_arg3 = C.TRUE
	}

	_cret = C.gtk_text_buffer_create_mark(_arg0, _arg1, _arg2, _arg3)

	var _textMark TextMark // out

	_textMark = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TextMark)

	return _textMark
}

func (b textBuffer) CutClipboardTextBuffer(clipboard gdk.Clipboard, defaultEditable bool) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GdkClipboard  // out
	var _arg2 C.gboolean       // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GdkClipboard)(unsafe.Pointer(clipboard.Native()))
	if defaultEditable {
		_arg2 = C.TRUE
	}

	C.gtk_text_buffer_cut_clipboard(_arg0, _arg1, _arg2)
}

func (b textBuffer) DeleteTextBuffer(start *TextIter, end *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
	_arg2 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

	C.gtk_text_buffer_delete(_arg0, _arg1, _arg2)
}

func (b textBuffer) DeleteInteractiveTextBuffer(startIter *TextIter, endIter *TextIter, defaultEditable bool) bool {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 C.gboolean       // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(startIter.Native()))
	_arg2 = (*C.GtkTextIter)(unsafe.Pointer(endIter.Native()))
	if defaultEditable {
		_arg3 = C.TRUE
	}

	_cret = C.gtk_text_buffer_delete_interactive(_arg0, _arg1, _arg2, _arg3)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (b textBuffer) DeleteMarkTextBuffer(mark TextMark) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextMark   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkTextMark)(unsafe.Pointer(mark.Native()))

	C.gtk_text_buffer_delete_mark(_arg0, _arg1)
}

func (b textBuffer) DeleteMarkByNameTextBuffer(name string) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.char          // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_text_buffer_delete_mark_by_name(_arg0, _arg1)
}

func (b textBuffer) DeleteSelectionTextBuffer(interactive bool, defaultEditable bool) bool {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 C.gboolean       // out
	var _arg2 C.gboolean       // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	if interactive {
		_arg1 = C.TRUE
	}
	if defaultEditable {
		_arg2 = C.TRUE
	}

	_cret = C.gtk_text_buffer_delete_selection(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (b textBuffer) EndIrreversibleActionTextBuffer() {
	var _arg0 *C.GtkTextBuffer // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	C.gtk_text_buffer_end_irreversible_action(_arg0)
}

func (b textBuffer) EndUserActionTextBuffer() {
	var _arg0 *C.GtkTextBuffer // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	C.gtk_text_buffer_end_user_action(_arg0)
}

func (b textBuffer) Bounds() (start TextIter, end TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 C.GtkTextIter    // in
	var _arg2 C.GtkTextIter    // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	C.gtk_text_buffer_get_bounds(_arg0, &_arg1, &_arg2)

	var _start TextIter // out
	var _end TextIter   // out

	{
		var refTmpIn *C.GtkTextIter
		var refTmpOut *TextIter

		in0 := &_arg1
		refTmpIn = in0

		refTmpOut = (*TextIter)(unsafe.Pointer(refTmpIn))

		_start = *refTmpOut
	}
	{
		var refTmpIn *C.GtkTextIter
		var refTmpOut *TextIter

		in0 := &_arg2
		refTmpIn = in0

		refTmpOut = (*TextIter)(unsafe.Pointer(refTmpIn))

		_end = *refTmpOut
	}

	return _start, _end
}

func (b textBuffer) CanRedo() bool {
	var _arg0 *C.GtkTextBuffer // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_text_buffer_get_can_redo(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (b textBuffer) CanUndo() bool {
	var _arg0 *C.GtkTextBuffer // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_text_buffer_get_can_undo(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (b textBuffer) CharCount() int {
	var _arg0 *C.GtkTextBuffer // out
	var _cret C.int            // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_text_buffer_get_char_count(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

func (b textBuffer) EnableUndo() bool {
	var _arg0 *C.GtkTextBuffer // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_text_buffer_get_enable_undo(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (b textBuffer) EndIter() TextIter {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 C.GtkTextIter    // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	C.gtk_text_buffer_get_end_iter(_arg0, &_arg1)

	var _iter TextIter // out

	{
		var refTmpIn *C.GtkTextIter
		var refTmpOut *TextIter

		in0 := &_arg1
		refTmpIn = in0

		refTmpOut = (*TextIter)(unsafe.Pointer(refTmpIn))

		_iter = *refTmpOut
	}

	return _iter
}

func (b textBuffer) HasSelection() bool {
	var _arg0 *C.GtkTextBuffer // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_text_buffer_get_has_selection(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (b textBuffer) GetInsert() TextMark {
	var _arg0 *C.GtkTextBuffer // out
	var _cret *C.GtkTextMark   // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_text_buffer_get_insert(_arg0)

	var _textMark TextMark // out

	_textMark = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TextMark)

	return _textMark
}

func (b textBuffer) IterAtChildAnchor(anchor TextChildAnchor) TextIter {
	var _arg0 *C.GtkTextBuffer      // out
	var _arg1 C.GtkTextIter         // in
	var _arg2 *C.GtkTextChildAnchor // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg2 = (*C.GtkTextChildAnchor)(unsafe.Pointer(anchor.Native()))

	C.gtk_text_buffer_get_iter_at_child_anchor(_arg0, &_arg1, _arg2)

	var _iter TextIter // out

	{
		var refTmpIn *C.GtkTextIter
		var refTmpOut *TextIter

		in0 := &_arg1
		refTmpIn = in0

		refTmpOut = (*TextIter)(unsafe.Pointer(refTmpIn))

		_iter = *refTmpOut
	}

	return _iter
}

func (b textBuffer) IterAtLine(lineNumber int) (TextIter, bool) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 C.GtkTextIter    // in
	var _arg2 C.int            // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg2 = C.int(lineNumber)

	_cret = C.gtk_text_buffer_get_iter_at_line(_arg0, &_arg1, _arg2)

	var _iter TextIter // out
	var _ok bool       // out

	{
		var refTmpIn *C.GtkTextIter
		var refTmpOut *TextIter

		in0 := &_arg1
		refTmpIn = in0

		refTmpOut = (*TextIter)(unsafe.Pointer(refTmpIn))

		_iter = *refTmpOut
	}
	if _cret != 0 {
		_ok = true
	}

	return _iter, _ok
}

func (b textBuffer) IterAtLineIndex(lineNumber int, byteIndex int) (TextIter, bool) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 C.GtkTextIter    // in
	var _arg2 C.int            // out
	var _arg3 C.int            // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg2 = C.int(lineNumber)
	_arg3 = C.int(byteIndex)

	_cret = C.gtk_text_buffer_get_iter_at_line_index(_arg0, &_arg1, _arg2, _arg3)

	var _iter TextIter // out
	var _ok bool       // out

	{
		var refTmpIn *C.GtkTextIter
		var refTmpOut *TextIter

		in0 := &_arg1
		refTmpIn = in0

		refTmpOut = (*TextIter)(unsafe.Pointer(refTmpIn))

		_iter = *refTmpOut
	}
	if _cret != 0 {
		_ok = true
	}

	return _iter, _ok
}

func (b textBuffer) IterAtLineOffset(lineNumber int, charOffset int) (TextIter, bool) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 C.GtkTextIter    // in
	var _arg2 C.int            // out
	var _arg3 C.int            // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg2 = C.int(lineNumber)
	_arg3 = C.int(charOffset)

	_cret = C.gtk_text_buffer_get_iter_at_line_offset(_arg0, &_arg1, _arg2, _arg3)

	var _iter TextIter // out
	var _ok bool       // out

	{
		var refTmpIn *C.GtkTextIter
		var refTmpOut *TextIter

		in0 := &_arg1
		refTmpIn = in0

		refTmpOut = (*TextIter)(unsafe.Pointer(refTmpIn))

		_iter = *refTmpOut
	}
	if _cret != 0 {
		_ok = true
	}

	return _iter, _ok
}

func (b textBuffer) IterAtMark(mark TextMark) TextIter {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 C.GtkTextIter    // in
	var _arg2 *C.GtkTextMark   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg2 = (*C.GtkTextMark)(unsafe.Pointer(mark.Native()))

	C.gtk_text_buffer_get_iter_at_mark(_arg0, &_arg1, _arg2)

	var _iter TextIter // out

	{
		var refTmpIn *C.GtkTextIter
		var refTmpOut *TextIter

		in0 := &_arg1
		refTmpIn = in0

		refTmpOut = (*TextIter)(unsafe.Pointer(refTmpIn))

		_iter = *refTmpOut
	}

	return _iter
}

func (b textBuffer) IterAtOffset(charOffset int) TextIter {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 C.GtkTextIter    // in
	var _arg2 C.int            // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg2 = C.int(charOffset)

	C.gtk_text_buffer_get_iter_at_offset(_arg0, &_arg1, _arg2)

	var _iter TextIter // out

	{
		var refTmpIn *C.GtkTextIter
		var refTmpOut *TextIter

		in0 := &_arg1
		refTmpIn = in0

		refTmpOut = (*TextIter)(unsafe.Pointer(refTmpIn))

		_iter = *refTmpOut
	}

	return _iter
}

func (b textBuffer) LineCount() int {
	var _arg0 *C.GtkTextBuffer // out
	var _cret C.int            // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_text_buffer_get_line_count(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

func (b textBuffer) Mark(name string) TextMark {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.char          // out
	var _cret *C.GtkTextMark   // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_text_buffer_get_mark(_arg0, _arg1)

	var _textMark TextMark // out

	_textMark = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TextMark)

	return _textMark
}

func (b textBuffer) MaxUndoLevels() uint {
	var _arg0 *C.GtkTextBuffer // out
	var _cret C.guint          // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_text_buffer_get_max_undo_levels(_arg0)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

func (b textBuffer) Modified() bool {
	var _arg0 *C.GtkTextBuffer // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_text_buffer_get_modified(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (b textBuffer) SelectionBound() TextMark {
	var _arg0 *C.GtkTextBuffer // out
	var _cret *C.GtkTextMark   // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_text_buffer_get_selection_bound(_arg0)

	var _textMark TextMark // out

	_textMark = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TextMark)

	return _textMark
}

func (b textBuffer) SelectionBounds() (start TextIter, end TextIter, ok bool) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 C.GtkTextIter    // in
	var _arg2 C.GtkTextIter    // in
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_text_buffer_get_selection_bounds(_arg0, &_arg1, &_arg2)

	var _start TextIter // out
	var _end TextIter   // out
	var _ok bool        // out

	{
		var refTmpIn *C.GtkTextIter
		var refTmpOut *TextIter

		in0 := &_arg1
		refTmpIn = in0

		refTmpOut = (*TextIter)(unsafe.Pointer(refTmpIn))

		_start = *refTmpOut
	}
	{
		var refTmpIn *C.GtkTextIter
		var refTmpOut *TextIter

		in0 := &_arg2
		refTmpIn = in0

		refTmpOut = (*TextIter)(unsafe.Pointer(refTmpIn))

		_end = *refTmpOut
	}
	if _cret != 0 {
		_ok = true
	}

	return _start, _end, _ok
}

func (b textBuffer) SelectionContent() gdk.ContentProvider {
	var _arg0 *C.GtkTextBuffer      // out
	var _cret *C.GdkContentProvider // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_text_buffer_get_selection_content(_arg0)

	var _contentProvider gdk.ContentProvider // out

	_contentProvider = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gdk.ContentProvider)

	return _contentProvider
}

func (b textBuffer) Slice(start *TextIter, end *TextIter, includeHiddenChars bool) string {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 C.gboolean       // out
	var _cret *C.char          // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
	_arg2 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))
	if includeHiddenChars {
		_arg3 = C.TRUE
	}

	_cret = C.gtk_text_buffer_get_slice(_arg0, _arg1, _arg2, _arg3)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

func (b textBuffer) StartIter() TextIter {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 C.GtkTextIter    // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	C.gtk_text_buffer_get_start_iter(_arg0, &_arg1)

	var _iter TextIter // out

	{
		var refTmpIn *C.GtkTextIter
		var refTmpOut *TextIter

		in0 := &_arg1
		refTmpIn = in0

		refTmpOut = (*TextIter)(unsafe.Pointer(refTmpIn))

		_iter = *refTmpOut
	}

	return _iter
}

func (b textBuffer) TagTable() TextTagTable {
	var _arg0 *C.GtkTextBuffer   // out
	var _cret *C.GtkTextTagTable // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	_cret = C.gtk_text_buffer_get_tag_table(_arg0)

	var _textTagTable TextTagTable // out

	_textTagTable = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TextTagTable)

	return _textTagTable
}

func (b textBuffer) Text(start *TextIter, end *TextIter, includeHiddenChars bool) string {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 C.gboolean       // out
	var _cret *C.char          // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
	_arg2 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))
	if includeHiddenChars {
		_arg3 = C.TRUE
	}

	_cret = C.gtk_text_buffer_get_text(_arg0, _arg1, _arg2, _arg3)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

func (b textBuffer) InsertTextBuffer(iter *TextIter, text string, len int) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.char          // out
	var _arg3 C.int            // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))
	_arg2 = (*C.char)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = C.int(len)

	C.gtk_text_buffer_insert(_arg0, _arg1, _arg2, _arg3)
}

func (b textBuffer) InsertAtCursorTextBuffer(text string, len int) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.char          // out
	var _arg2 C.int            // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.char)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.int(len)

	C.gtk_text_buffer_insert_at_cursor(_arg0, _arg1, _arg2)
}

func (b textBuffer) InsertChildAnchorTextBuffer(iter *TextIter, anchor TextChildAnchor) {
	var _arg0 *C.GtkTextBuffer      // out
	var _arg1 *C.GtkTextIter        // out
	var _arg2 *C.GtkTextChildAnchor // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))
	_arg2 = (*C.GtkTextChildAnchor)(unsafe.Pointer(anchor.Native()))

	C.gtk_text_buffer_insert_child_anchor(_arg0, _arg1, _arg2)
}

func (b textBuffer) InsertInteractiveTextBuffer(iter *TextIter, text string, len int, defaultEditable bool) bool {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.char          // out
	var _arg3 C.int            // out
	var _arg4 C.gboolean       // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))
	_arg2 = (*C.char)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = C.int(len)
	if defaultEditable {
		_arg4 = C.TRUE
	}

	_cret = C.gtk_text_buffer_insert_interactive(_arg0, _arg1, _arg2, _arg3, _arg4)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (b textBuffer) InsertInteractiveAtCursorTextBuffer(text string, len int, defaultEditable bool) bool {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.char          // out
	var _arg2 C.int            // out
	var _arg3 C.gboolean       // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.char)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.int(len)
	if defaultEditable {
		_arg3 = C.TRUE
	}

	_cret = C.gtk_text_buffer_insert_interactive_at_cursor(_arg0, _arg1, _arg2, _arg3)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (b textBuffer) InsertMarkupTextBuffer(iter *TextIter, markup string, len int) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.char          // out
	var _arg3 C.int            // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))
	_arg2 = (*C.char)(C.CString(markup))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = C.int(len)

	C.gtk_text_buffer_insert_markup(_arg0, _arg1, _arg2, _arg3)
}

func (b textBuffer) InsertPaintableTextBuffer(iter *TextIter, paintable gdk.Paintable) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.GdkPaintable  // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))
	_arg2 = (*C.GdkPaintable)(unsafe.Pointer(paintable.Native()))

	C.gtk_text_buffer_insert_paintable(_arg0, _arg1, _arg2)
}

func (b textBuffer) InsertRangeTextBuffer(iter *TextIter, start *TextIter, end *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))
	_arg2 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
	_arg3 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

	C.gtk_text_buffer_insert_range(_arg0, _arg1, _arg2, _arg3)
}

func (b textBuffer) InsertRangeInteractiveTextBuffer(iter *TextIter, start *TextIter, end *TextIter, defaultEditable bool) bool {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 *C.GtkTextIter   // out
	var _arg4 C.gboolean       // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))
	_arg2 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
	_arg3 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))
	if defaultEditable {
		_arg4 = C.TRUE
	}

	_cret = C.gtk_text_buffer_insert_range_interactive(_arg0, _arg1, _arg2, _arg3, _arg4)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (b textBuffer) MoveMarkTextBuffer(mark TextMark, where *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextMark   // out
	var _arg2 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkTextMark)(unsafe.Pointer(mark.Native()))
	_arg2 = (*C.GtkTextIter)(unsafe.Pointer(where.Native()))

	C.gtk_text_buffer_move_mark(_arg0, _arg1, _arg2)
}

func (b textBuffer) MoveMarkByNameTextBuffer(name string, where *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.char          // out
	var _arg2 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GtkTextIter)(unsafe.Pointer(where.Native()))

	C.gtk_text_buffer_move_mark_by_name(_arg0, _arg1, _arg2)
}

func (b textBuffer) PasteClipboardTextBuffer(clipboard gdk.Clipboard, overrideLocation *TextIter, defaultEditable bool) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GdkClipboard  // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 C.gboolean       // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GdkClipboard)(unsafe.Pointer(clipboard.Native()))
	_arg2 = (*C.GtkTextIter)(unsafe.Pointer(overrideLocation.Native()))
	if defaultEditable {
		_arg3 = C.TRUE
	}

	C.gtk_text_buffer_paste_clipboard(_arg0, _arg1, _arg2, _arg3)
}

func (b textBuffer) PlaceCursorTextBuffer(where *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(where.Native()))

	C.gtk_text_buffer_place_cursor(_arg0, _arg1)
}

func (b textBuffer) RedoTextBuffer() {
	var _arg0 *C.GtkTextBuffer // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	C.gtk_text_buffer_redo(_arg0)
}

func (b textBuffer) RemoveAllTagsTextBuffer(start *TextIter, end *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
	_arg2 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

	C.gtk_text_buffer_remove_all_tags(_arg0, _arg1, _arg2)
}

func (b textBuffer) RemoveSelectionClipboardTextBuffer(clipboard gdk.Clipboard) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GdkClipboard  // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GdkClipboard)(unsafe.Pointer(clipboard.Native()))

	C.gtk_text_buffer_remove_selection_clipboard(_arg0, _arg1)
}

func (b textBuffer) RemoveTagTextBuffer(tag TextTag, start *TextIter, end *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextTag    // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkTextTag)(unsafe.Pointer(tag.Native()))
	_arg2 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
	_arg3 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

	C.gtk_text_buffer_remove_tag(_arg0, _arg1, _arg2, _arg3)
}

func (b textBuffer) RemoveTagByNameTextBuffer(name string, start *TextIter, end *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.char          // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
	_arg3 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

	C.gtk_text_buffer_remove_tag_by_name(_arg0, _arg1, _arg2, _arg3)
}

func (b textBuffer) SelectRangeTextBuffer(ins *TextIter, bound *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(ins.Native()))
	_arg2 = (*C.GtkTextIter)(unsafe.Pointer(bound.Native()))

	C.gtk_text_buffer_select_range(_arg0, _arg1, _arg2)
}

func (b textBuffer) SetEnableUndoTextBuffer(enableUndo bool) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	if enableUndo {
		_arg1 = C.TRUE
	}

	C.gtk_text_buffer_set_enable_undo(_arg0, _arg1)
}

func (b textBuffer) SetMaxUndoLevelsTextBuffer(maxUndoLevels uint) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 C.guint          // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = C.guint(maxUndoLevels)

	C.gtk_text_buffer_set_max_undo_levels(_arg0, _arg1)
}

func (b textBuffer) SetModifiedTextBuffer(setting bool) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_text_buffer_set_modified(_arg0, _arg1)
}

func (b textBuffer) SetTextTextBuffer(text string, len int) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.char          // out
	var _arg2 C.int            // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.char)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.int(len)

	C.gtk_text_buffer_set_text(_arg0, _arg1, _arg2)
}

func (b textBuffer) UndoTextBuffer() {
	var _arg0 *C.GtkTextBuffer // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

	C.gtk_text_buffer_undo(_arg0)
}
