// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/internal/gerror"
	"github.com/diamondburned/gotk4/internal/gextras"
	"github.com/diamondburned/gotk4/internal/ptr"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config:
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <gtk/gtk.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_recent_manager_get_type()), F: marshalRecentManager},
		{T: externglib.Type(C.gtk_recent_info_get_type()), F: marshalRecentInfo},
	})
}

// RecentManager: `GtkRecentManager` manages and looks up recently used files.
//
// Each recently used file is identified by its URI, and has meta-data
// associated to it, like the names and command lines of the applications that
// have registered it, the number of time each application has registered the
// same file, the mime type of the file and whether the file should be displayed
// only by the applications that have registered it.
//
// The recently used files list is per user.
//
// `GtkRecentManager` acts like a database of all the recently used files. You
// can create new `GtkRecentManager` objects, but it is more efficient to use
// the default manager created by GTK.
//
// Adding a new recently used file is as simple as:
//
// “`c GtkRecentManager *manager;
//
// manager = gtk_recent_manager_get_default (); gtk_recent_manager_add_item
// (manager, file_uri); “`
//
// The `GtkRecentManager` will try to gather all the needed information from the
// file itself through GIO.
//
// Looking up the meta-data associated with a recently used file given its URI
// requires calling [method@Gtk.RecentManager.lookup_item]:
//
// “`c GtkRecentManager *manager; GtkRecentInfo *info; GError *error = NULL;
//
// manager = gtk_recent_manager_get_default (); info =
// gtk_recent_manager_lookup_item (manager, file_uri, &error); if (error) {
// g_warning ("Could not find the file: s", error->message); g_error_free
// (error); } else { // Use the info object gtk_recent_info_unref (info); } “`
//
// In order to retrieve the list of recently used files, you can use
// [method@Gtk.RecentManager.get_items], which returns a list of
// [struct@Gtk.RecentInfo].
//
// Note that the maximum age of the recently used files list is controllable
// through the [property@Gtk.Settings:gtk-recent-files-max-age] property.
type RecentManager interface {
	gextras.Objector

	// AddFull adds a new resource, pointed by @uri, into the recently used
	// resources list, using the metadata specified inside the `GtkRecentData`
	// passed in @recent_data.
	//
	// The passed URI will be used to identify this resource inside the list.
	//
	// In order to register the new recently used resource, metadata about the
	// resource must be passed as well as the URI; the metadata is stored in a
	// `GtkRecentData`, which must contain the MIME type of the resource pointed
	// by the URI; the name of the application that is registering the item, and
	// a command line to be used when launching the item.
	//
	// Optionally, a `GtkRecentData` might contain a UTF-8 string to be used
	// when viewing the item instead of the last component of the URI; a short
	// description of the item; whether the item should be considered private -
	// that is, should be displayed only by the applications that have
	// registered it.
	AddFull(uri string, recentData *RecentData) bool
	// AddItem adds a new resource, pointed by @uri, into the recently used
	// resources list.
	//
	// This function automatically retrieves some of the needed metadata and
	// setting other metadata to common default values; it then feeds the data
	// to [method@Gtk.RecentManager.add_full].
	//
	// See [method@Gtk.RecentManager.add_full] if you want to explicitly define
	// the metadata for the resource pointed by @uri.
	AddItem(uri string) bool
	// Items gets the list of recently used resources.
	Items() *glib.List
	// HasItem checks whether there is a recently used resource registered with
	// @uri inside the recent manager.
	HasItem(uri string) bool
	// LookupItem searches for a URI inside the recently used resources list,
	// and returns a `GtkRecentInfo` containing information about the resource
	// like its MIME type, or its display name.
	LookupItem(uri string) (*RecentInfo, error)
	// MoveItem changes the location of a recently used resource from @uri to
	// @new_uri.
	//
	// Please note that this function will not affect the resource pointed by
	// the URIs, but only the URI used in the recently used resources list.
	MoveItem(uri string, newUri string) error
	// PurgeItems purges every item from the recently used resources list.
	PurgeItems() (int, error)
	// RemoveItem removes a resource pointed by @uri from the recently used
	// resources list handled by a recent manager.
	RemoveItem(uri string) error
}

// recentManager implements the RecentManager interface.
type recentManager struct {
	gextras.Objector
}

var _ RecentManager = (*recentManager)(nil)

// WrapRecentManager wraps a GObject to the right type. It is
// primarily used internally.
func WrapRecentManager(obj *externglib.Object) RecentManager {
	return RecentManager{
		Objector: obj,
	}
}

func marshalRecentManager(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapRecentManager(obj), nil
}

// NewRecentManager constructs a class RecentManager.
func NewRecentManager() RecentManager {
	var _cret C.GtkRecentManager

	cret = C.gtk_recent_manager_new()

	var _recentManager RecentManager

	_recentManager = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret.Native()))).(RecentManager)

	return _recentManager
}

// AddFull adds a new resource, pointed by @uri, into the recently used
// resources list, using the metadata specified inside the `GtkRecentData`
// passed in @recent_data.
//
// The passed URI will be used to identify this resource inside the list.
//
// In order to register the new recently used resource, metadata about the
// resource must be passed as well as the URI; the metadata is stored in a
// `GtkRecentData`, which must contain the MIME type of the resource pointed
// by the URI; the name of the application that is registering the item, and
// a command line to be used when launching the item.
//
// Optionally, a `GtkRecentData` might contain a UTF-8 string to be used
// when viewing the item instead of the last component of the URI; a short
// description of the item; whether the item should be considered private -
// that is, should be displayed only by the applications that have
// registered it.
func (m recentManager) AddFull(uri string, recentData *RecentData) bool {
	var _arg0 *C.GtkRecentManager
	var _arg1 *C.char
	var _arg2 *C.GtkRecentData

	_arg0 = (*C.GtkRecentManager)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.char)(C.CString(uri))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GtkRecentData)(unsafe.Pointer(recentData.Native()))

	var _cret C.gboolean

	cret = C.gtk_recent_manager_add_full(_arg0, _arg1, _arg2)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// AddItem adds a new resource, pointed by @uri, into the recently used
// resources list.
//
// This function automatically retrieves some of the needed metadata and
// setting other metadata to common default values; it then feeds the data
// to [method@Gtk.RecentManager.add_full].
//
// See [method@Gtk.RecentManager.add_full] if you want to explicitly define
// the metadata for the resource pointed by @uri.
func (m recentManager) AddItem(uri string) bool {
	var _arg0 *C.GtkRecentManager
	var _arg1 *C.char

	_arg0 = (*C.GtkRecentManager)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.char)(C.CString(uri))
	defer C.free(unsafe.Pointer(_arg1))

	var _cret C.gboolean

	cret = C.gtk_recent_manager_add_item(_arg0, _arg1)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// Items gets the list of recently used resources.
func (m recentManager) Items() *glib.List {
	var _arg0 *C.GtkRecentManager

	_arg0 = (*C.GtkRecentManager)(unsafe.Pointer(m.Native()))

	var _cret *C.GList

	cret = C.gtk_recent_manager_get_items(_arg0)

	var _list *glib.List

	_list = glib.WrapList(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_list, func(v *glib.List) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _list
}

// HasItem checks whether there is a recently used resource registered with
// @uri inside the recent manager.
func (m recentManager) HasItem(uri string) bool {
	var _arg0 *C.GtkRecentManager
	var _arg1 *C.char

	_arg0 = (*C.GtkRecentManager)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.char)(C.CString(uri))
	defer C.free(unsafe.Pointer(_arg1))

	var _cret C.gboolean

	cret = C.gtk_recent_manager_has_item(_arg0, _arg1)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// LookupItem searches for a URI inside the recently used resources list,
// and returns a `GtkRecentInfo` containing information about the resource
// like its MIME type, or its display name.
func (m recentManager) LookupItem(uri string) (*RecentInfo, error) {
	var _arg0 *C.GtkRecentManager
	var _arg1 *C.char

	_arg0 = (*C.GtkRecentManager)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.char)(C.CString(uri))
	defer C.free(unsafe.Pointer(_arg1))

	var _cret *C.GtkRecentInfo
	var _cerr *C.GError

	cret = C.gtk_recent_manager_lookup_item(_arg0, _arg1, _cerr)

	var _recentInfo *RecentInfo
	var _goerr error

	_recentInfo = WrapRecentInfo(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_recentInfo, func(v *RecentInfo) {
		C.free(unsafe.Pointer(v.Native()))
	})
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _recentInfo, _goerr
}

// MoveItem changes the location of a recently used resource from @uri to
// @new_uri.
//
// Please note that this function will not affect the resource pointed by
// the URIs, but only the URI used in the recently used resources list.
func (m recentManager) MoveItem(uri string, newUri string) error {
	var _arg0 *C.GtkRecentManager
	var _arg1 *C.char
	var _arg2 *C.char

	_arg0 = (*C.GtkRecentManager)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.char)(C.CString(uri))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.char)(C.CString(newUri))
	defer C.free(unsafe.Pointer(_arg2))

	var _cerr *C.GError

	C.gtk_recent_manager_move_item(_arg0, _arg1, _arg2, _cerr)

	var _goerr error

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// PurgeItems purges every item from the recently used resources list.
func (m recentManager) PurgeItems() (int, error) {
	var _arg0 *C.GtkRecentManager

	_arg0 = (*C.GtkRecentManager)(unsafe.Pointer(m.Native()))

	var _cret C.int
	var _cerr *C.GError

	cret = C.gtk_recent_manager_purge_items(_arg0, _cerr)

	var _gint int
	var _goerr error

	_gint = (int)(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _gint, _goerr
}

// RemoveItem removes a resource pointed by @uri from the recently used
// resources list handled by a recent manager.
func (m recentManager) RemoveItem(uri string) error {
	var _arg0 *C.GtkRecentManager
	var _arg1 *C.char

	_arg0 = (*C.GtkRecentManager)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.char)(C.CString(uri))
	defer C.free(unsafe.Pointer(_arg1))

	var _cerr *C.GError

	C.gtk_recent_manager_remove_item(_arg0, _arg1, _cerr)

	var _goerr error

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// RecentData: meta-data to be passed to gtk_recent_manager_add_full() when
// registering a recently used resource.
type RecentData struct {
	native C.GtkRecentData
}

// WrapRecentData wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapRecentData(ptr unsafe.Pointer) *RecentData {
	if ptr == nil {
		return nil
	}

	return (*RecentData)(ptr)
}

func marshalRecentData(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapRecentData(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (r *RecentData) Native() unsafe.Pointer {
	return unsafe.Pointer(&r.native)
}

// DisplayName gets the field inside the struct.
func (r *RecentData) DisplayName() string {
	var v string
	v = C.GoString(r.native.display_name)
	return v
}

// Description gets the field inside the struct.
func (r *RecentData) Description() string {
	var v string
	v = C.GoString(r.native.description)
	return v
}

// MIMEType gets the field inside the struct.
func (r *RecentData) MIMEType() string {
	var v string
	v = C.GoString(r.native.mime_type)
	return v
}

// AppName gets the field inside the struct.
func (r *RecentData) AppName() string {
	var v string
	v = C.GoString(r.native.app_name)
	return v
}

// AppExec gets the field inside the struct.
func (r *RecentData) AppExec() string {
	var v string
	v = C.GoString(r.native.app_exec)
	return v
}

// Groups gets the field inside the struct.
func (r *RecentData) Groups() []string {
	var v []string
	{
		var length int
		for p := r.native.groups; *p != 0; p = (**C.char)(ptr.Add(unsafe.Pointer(p), unsafe.Sizeof(int(0)))) {
			length++
			if length < 0 {
				panic(`length overflow`)
			}
		}

		var src []*C.char
		ptr.SetSlice(unsafe.Pointer(&src), unsafe.Pointer(r.native.groups), int(length))

		v = make([]string, length)
		for i := uintptr(0); i < uintptr(length); i += unsafe.Sizeof(int(0)) {
			v = C.GoString(r.native.groups)
		}
	}
	return v
}

// IsPrivate gets the field inside the struct.
func (r *RecentData) IsPrivate() bool {
	var v bool
	if r.native.is_private {
		v = true
	}
	return v
}

// RecentInfo: `GtkRecentInfo` contains the metadata associated with an item in
// the recently used files list.
type RecentInfo struct {
	native C.GtkRecentInfo
}

// WrapRecentInfo wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapRecentInfo(ptr unsafe.Pointer) *RecentInfo {
	if ptr == nil {
		return nil
	}

	return (*RecentInfo)(ptr)
}

func marshalRecentInfo(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapRecentInfo(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (r *RecentInfo) Native() unsafe.Pointer {
	return unsafe.Pointer(&r.native)
}

// CreateAppInfo creates a `GAppInfo` for the specified `GtkRecentInfo`
func (i *RecentInfo) CreateAppInfo(appName string) (gio.AppInfo, error) {
	var _arg0 *C.GtkRecentInfo
	var _arg1 *C.char

	_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.char)(C.CString(appName))
	defer C.free(unsafe.Pointer(_arg1))

	var _cret *C.GAppInfo
	var _cerr *C.GError

	cret = C.gtk_recent_info_create_app_info(_arg0, _arg1, _cerr)

	var _appInfo gio.AppInfo
	var _goerr error

	_appInfo = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret.Native()))).(gio.AppInfo)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _appInfo, _goerr
}

// Exists checks whether the resource pointed by @info still exists. At the
// moment this check is done only on resources pointing to local files.
func (i *RecentInfo) Exists() bool {
	var _arg0 *C.GtkRecentInfo

	_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))

	var _cret C.gboolean

	cret = C.gtk_recent_info_exists(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// Added gets the the time when the resource was added to the recently used
// resources list.
func (i *RecentInfo) Added() *glib.DateTime {
	var _arg0 *C.GtkRecentInfo

	_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))

	var _cret *C.GDateTime

	cret = C.gtk_recent_info_get_added(_arg0)

	var _dateTime *glib.DateTime

	_dateTime = glib.WrapDateTime(unsafe.Pointer(_cret))

	return _dateTime
}

// Age gets the number of days elapsed since the last update of the resource
// pointed by @info.
func (i *RecentInfo) Age() int {
	var _arg0 *C.GtkRecentInfo

	_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))

	var _cret C.int

	cret = C.gtk_recent_info_get_age(_arg0)

	var _gint int

	_gint = (int)(_cret)

	return _gint
}

// ApplicationInfo gets the data regarding the application that has registered
// the resource pointed by @info.
//
// If the command line contains any escape characters defined inside the storage
// specification, they will be expanded.
func (i *RecentInfo) ApplicationInfo(appName string) (string, uint, *glib.DateTime, bool) {
	var _arg0 *C.GtkRecentInfo
	var _arg1 *C.char

	_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.char)(C.CString(appName))
	defer C.free(unsafe.Pointer(_arg1))

	var _arg2 **C.char
	var _arg3 C.guint
	var _arg4 **C.GDateTime
	var _cret C.gboolean

	cret = C.gtk_recent_info_get_application_info(_arg0, _arg1, _arg2, &_arg3, _arg4)

	var _appExec string
	var _count uint
	var _stamp *glib.DateTime
	var _ok bool

	_appExec = C.GoString(_arg2)
	_count = (uint)(_arg3)
	_stamp = glib.WrapDateTime(unsafe.Pointer(_arg4))
	if _cret {
		_ok = true
	}

	return _appExec, _count, _stamp, _ok
}

// Applications retrieves the list of applications that have registered this
// resource.
func (i *RecentInfo) Applications() []string {
	var _arg0 *C.GtkRecentInfo

	_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))

	var _cret **C.char
	var _arg1 *C.gsize

	cret = C.gtk_recent_info_get_applications(_arg0)

	var _utf8s []string

	{
		var src []*C.gchar
		ptr.SetSlice(unsafe.Pointer(&src), unsafe.Pointer(_cret), int(_arg1))

		_utf8s = make([]string, _arg1)
		for i := 0; i < uintptr(_arg1); i++ {
			_utf8s = C.GoString(_cret)
			defer C.free(unsafe.Pointer(_cret))
		}
	}

	return _utf8s
}

// Description gets the (short) description of the resource.
func (i *RecentInfo) Description() string {
	var _arg0 *C.GtkRecentInfo

	_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))

	var _cret *C.char

	cret = C.gtk_recent_info_get_description(_arg0)

	var _utf8 string

	_utf8 = C.GoString(_cret)

	return _utf8
}

// DisplayName gets the name of the resource.
//
// If none has been defined, the basename of the resource is obtained.
func (i *RecentInfo) DisplayName() string {
	var _arg0 *C.GtkRecentInfo

	_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))

	var _cret *C.char

	cret = C.gtk_recent_info_get_display_name(_arg0)

	var _utf8 string

	_utf8 = C.GoString(_cret)

	return _utf8
}

// GIcon retrieves the icon associated to the resource MIME type.
func (i *RecentInfo) GIcon() gio.Icon {
	var _arg0 *C.GtkRecentInfo

	_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))

	var _cret *C.GIcon

	cret = C.gtk_recent_info_get_gicon(_arg0)

	var _icon gio.Icon

	_icon = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret.Native()))).(gio.Icon)

	return _icon
}

// Groups returns all groups registered for the recently used item @info.
//
// The array of returned group names will be nil terminated, so length might
// optionally be nil.
func (i *RecentInfo) Groups() []string {
	var _arg0 *C.GtkRecentInfo

	_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))

	var _cret **C.char
	var _arg1 *C.gsize

	cret = C.gtk_recent_info_get_groups(_arg0)

	var _utf8s []string

	{
		var src []*C.gchar
		ptr.SetSlice(unsafe.Pointer(&src), unsafe.Pointer(_cret), int(_arg1))

		_utf8s = make([]string, _arg1)
		for i := 0; i < uintptr(_arg1); i++ {
			_utf8s = C.GoString(_cret)
			defer C.free(unsafe.Pointer(_cret))
		}
	}

	return _utf8s
}

// MIMEType gets the MIME type of the resource.
func (i *RecentInfo) MIMEType() string {
	var _arg0 *C.GtkRecentInfo

	_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))

	var _cret *C.char

	cret = C.gtk_recent_info_get_mime_type(_arg0)

	var _utf8 string

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Modified gets the time when the meta-data for the resource was last modified.
func (i *RecentInfo) Modified() *glib.DateTime {
	var _arg0 *C.GtkRecentInfo

	_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))

	var _cret *C.GDateTime

	cret = C.gtk_recent_info_get_modified(_arg0)

	var _dateTime *glib.DateTime

	_dateTime = glib.WrapDateTime(unsafe.Pointer(_cret))

	return _dateTime
}

// PrivateHint gets the value of the “private” flag.
//
// Resources in the recently used list that have this flag set to true should
// only be displayed by the applications that have registered them.
func (i *RecentInfo) PrivateHint() bool {
	var _arg0 *C.GtkRecentInfo

	_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))

	var _cret C.gboolean

	cret = C.gtk_recent_info_get_private_hint(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// ShortName computes a valid UTF-8 string that can be used as the name of the
// item in a menu or list.
//
// For example, calling this function on an item that refers to
// “file:///foo/bar.txt” will yield “bar.txt”.
func (i *RecentInfo) ShortName() string {
	var _arg0 *C.GtkRecentInfo

	_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))

	var _cret *C.char

	cret = C.gtk_recent_info_get_short_name(_arg0)

	var _utf8 string

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// URI gets the URI of the resource.
func (i *RecentInfo) URI() string {
	var _arg0 *C.GtkRecentInfo

	_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))

	var _cret *C.char

	cret = C.gtk_recent_info_get_uri(_arg0)

	var _utf8 string

	_utf8 = C.GoString(_cret)

	return _utf8
}

// URIDisplay gets a displayable version of the resource’s URI.
//
// If the resource is local, it returns a local path; if the resource is not
// local, it returns the UTF-8 encoded content of
// [method@Gtk.RecentInfo.get_uri].
func (i *RecentInfo) URIDisplay() string {
	var _arg0 *C.GtkRecentInfo

	_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))

	var _cret *C.char

	cret = C.gtk_recent_info_get_uri_display(_arg0)

	var _utf8 string

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Visited gets the time when the meta-data for the resource was last visited.
func (i *RecentInfo) Visited() *glib.DateTime {
	var _arg0 *C.GtkRecentInfo

	_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))

	var _cret *C.GDateTime

	cret = C.gtk_recent_info_get_visited(_arg0)

	var _dateTime *glib.DateTime

	_dateTime = glib.WrapDateTime(unsafe.Pointer(_cret))

	return _dateTime
}

// HasApplication checks whether an application registered this resource using
// @app_name.
func (i *RecentInfo) HasApplication(appName string) bool {
	var _arg0 *C.GtkRecentInfo
	var _arg1 *C.char

	_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.char)(C.CString(appName))
	defer C.free(unsafe.Pointer(_arg1))

	var _cret C.gboolean

	cret = C.gtk_recent_info_has_application(_arg0, _arg1)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// HasGroup checks whether @group_name appears inside the groups registered for
// the recently used item @info.
func (i *RecentInfo) HasGroup(groupName string) bool {
	var _arg0 *C.GtkRecentInfo
	var _arg1 *C.char

	_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.char)(C.CString(groupName))
	defer C.free(unsafe.Pointer(_arg1))

	var _cret C.gboolean

	cret = C.gtk_recent_info_has_group(_arg0, _arg1)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// IsLocal checks whether the resource is local or not by looking at the scheme
// of its URI.
func (i *RecentInfo) IsLocal() bool {
	var _arg0 *C.GtkRecentInfo

	_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))

	var _cret C.gboolean

	cret = C.gtk_recent_info_is_local(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// LastApplication gets the name of the last application that have registered
// the recently used resource represented by @info.
func (i *RecentInfo) LastApplication() string {
	var _arg0 *C.GtkRecentInfo

	_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))

	var _cret *C.char

	cret = C.gtk_recent_info_last_application(_arg0)

	var _utf8 string

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Match checks whether two `GtkRecentInfo` point to the same resource.
func (i *RecentInfo) Match(infoB *RecentInfo) bool {
	var _arg0 *C.GtkRecentInfo
	var _arg1 *C.GtkRecentInfo

	_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GtkRecentInfo)(unsafe.Pointer(infoB.Native()))

	var _cret C.gboolean

	cret = C.gtk_recent_info_match(_arg0, _arg1)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// Ref increases the reference count of @recent_info by one.
func (i *RecentInfo) Ref() *RecentInfo {
	var _arg0 *C.GtkRecentInfo

	_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))

	var _cret *C.GtkRecentInfo

	cret = C.gtk_recent_info_ref(_arg0)

	var _recentInfo *RecentInfo

	_recentInfo = WrapRecentInfo(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_recentInfo, func(v *RecentInfo) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _recentInfo
}

// Unref decreases the reference count of @info by one.
//
// If the reference count reaches zero, @info is deallocated, and the memory
// freed.
func (i *RecentInfo) Unref() {
	var _arg0 *C.GtkRecentInfo

	_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))

	C.gtk_recent_info_unref(_arg0)
}
