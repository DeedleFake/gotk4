// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"unsafe"

	"github.com/diamondburned/gotk4/internal/gextras"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config:
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <stdbool.h>
// #include <gtk/gtk.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_constraint_target_get_type()), F: marshalConstraintTarget},
		{T: externglib.Type(C.gtk_constraint_get_type()), F: marshalConstraint},
	})
}

// ConstraintTarget: the GtkConstraintTarget interface is implemented by objects
// that can be used as source or target in Constraints. Besides Widget, it is
// also implemented by ConstraintGuide.
type ConstraintTarget interface {
	gextras.Objector
}

// constraintTarget implements the ConstraintTarget interface.
type constraintTarget struct {
	gextras.Objector
}

var _ ConstraintTarget = (*constraintTarget)(nil)

// WrapConstraintTarget wraps a GObject to a type that implements interface
// ConstraintTarget. It is primarily used internally.
func WrapConstraintTarget(obj *externglib.Object) ConstraintTarget {
	return ConstraintTarget{
		Objector: obj,
	}
}

func marshalConstraintTarget(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapConstraintTarget(obj), nil
}

// Constraint describes a constraint between an attribute on a widget and
// another attribute on another widget, expressed as a linear equation like:
//
//    target.attr1 = source.attr2 Ã— multiplier + constant
//
// Each Constraint is part of a system that will be solved by a ConstraintLayout
// in order to allocate and position each child widget.
//
// The source and target widgets, as well as their attributes, of a Constraint
// instance are immutable after creation.
type Constraint interface {
	gextras.Objector

	// Constant retrieves the constant factor added to the source attributes'
	// value.
	Constant() float64
	// Multiplier retrieves the multiplication factor applied to the source
	// attribute's value.
	Multiplier() float64
	// Relation: the order relation between the terms of the @constraint.
	Relation() ConstraintRelation
	// Source retrieves the ConstraintTarget used as the source for @constraint.
	//
	// If the Constraint:source property is set to nil, the @constraint will use
	// the ConstraintLayout's widget.
	Source() ConstraintTarget
	// SourceAttribute retrieves the attribute of the source to be read by the
	// @constraint.
	SourceAttribute() ConstraintAttribute
	// Strength retrieves the strength of the constraint.
	Strength() int
	// Target retrieves the ConstraintTarget used as the target for @constraint.
	//
	// If the Constraint:target property is set to nil, the @constraint will use
	// the ConstraintLayout's widget.
	Target() ConstraintTarget
	// TargetAttribute retrieves the attribute of the target to be set by the
	// @constraint.
	TargetAttribute() ConstraintAttribute
	// IsAttached checks whether the @constraint is attached to a
	// ConstraintLayout, and it is contributing to the layout.
	IsAttached() bool
	// IsConstant checks whether the @constraint describes a relation between an
	// attribute on the Constraint:target and a constant value.
	IsConstant() bool
	// IsRequired checks whether the @constraint is a required relation for
	// solving the constraint layout.
	IsRequired() bool
}

// constraint implements the Constraint interface.
type constraint struct {
	gextras.Objector
}

var _ Constraint = (*constraint)(nil)

// WrapConstraint wraps a GObject to the right type. It is
// primarily used internally.
func WrapConstraint(obj *externglib.Object) Constraint {
	return Constraint{
		Objector: obj,
	}
}

func marshalConstraint(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapConstraint(obj), nil
}

// NewConstraint constructs a class Constraint.
func NewConstraint(target ConstraintTarget, targetAttribute ConstraintAttribute, relation ConstraintRelation, source ConstraintTarget, sourceAttribute ConstraintAttribute, multiplier float64, constant float64, strength int) Constraint {
	var arg1 C.gpointer
	var arg2 C.GtkConstraintAttribute
	var arg3 C.GtkConstraintRelation
	var arg4 C.gpointer
	var arg5 C.GtkConstraintAttribute
	var arg6 C.double
	var arg7 C.double
	var arg8 C.int

	arg1 = (C.gpointer)(unsafe.Pointer(target.Native()))
	arg2 = (C.GtkConstraintAttribute)(targetAttribute)
	arg3 = (C.GtkConstraintRelation)(relation)
	arg4 = (C.gpointer)(unsafe.Pointer(source.Native()))
	arg5 = (C.GtkConstraintAttribute)(sourceAttribute)
	arg6 = C.double(multiplier)
	arg7 = C.double(constant)
	arg8 = C.int(strength)

	var cret C.GtkConstraint
	var ret1 Constraint

	cret = C.gtk_constraint_new(target, targetAttribute, relation, source, sourceAttribute, multiplier, constant, strength)

	ret1 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(Constraint)

	return ret1
}

// NewConstraintConstant constructs a class Constraint.
func NewConstraintConstant(target ConstraintTarget, targetAttribute ConstraintAttribute, relation ConstraintRelation, constant float64, strength int) Constraint {
	var arg1 C.gpointer
	var arg2 C.GtkConstraintAttribute
	var arg3 C.GtkConstraintRelation
	var arg4 C.double
	var arg5 C.int

	arg1 = (C.gpointer)(unsafe.Pointer(target.Native()))
	arg2 = (C.GtkConstraintAttribute)(targetAttribute)
	arg3 = (C.GtkConstraintRelation)(relation)
	arg4 = C.double(constant)
	arg5 = C.int(strength)

	var cret C.GtkConstraint
	var ret1 Constraint

	cret = C.gtk_constraint_new_constant(target, targetAttribute, relation, constant, strength)

	ret1 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(Constraint)

	return ret1
}

// Constant retrieves the constant factor added to the source attributes'
// value.
func (c constraint) Constant() float64 {
	var arg0 *C.GtkConstraint

	arg0 = (*C.GtkConstraint)(unsafe.Pointer(c.Native()))

	var cret C.double
	var ret1 float64

	cret = C.gtk_constraint_get_constant(arg0)

	ret1 = C.double(cret)

	return ret1
}

// Multiplier retrieves the multiplication factor applied to the source
// attribute's value.
func (c constraint) Multiplier() float64 {
	var arg0 *C.GtkConstraint

	arg0 = (*C.GtkConstraint)(unsafe.Pointer(c.Native()))

	var cret C.double
	var ret1 float64

	cret = C.gtk_constraint_get_multiplier(arg0)

	ret1 = C.double(cret)

	return ret1
}

// Relation: the order relation between the terms of the @constraint.
func (c constraint) Relation() ConstraintRelation {
	var arg0 *C.GtkConstraint

	arg0 = (*C.GtkConstraint)(unsafe.Pointer(c.Native()))

	var cret C.GtkConstraintRelation
	var ret1 ConstraintRelation

	cret = C.gtk_constraint_get_relation(arg0)

	ret1 = ConstraintRelation(cret)

	return ret1
}

// Source retrieves the ConstraintTarget used as the source for @constraint.
//
// If the Constraint:source property is set to nil, the @constraint will use
// the ConstraintLayout's widget.
func (c constraint) Source() ConstraintTarget {
	var arg0 *C.GtkConstraint

	arg0 = (*C.GtkConstraint)(unsafe.Pointer(c.Native()))

	var cret *C.GtkConstraintTarget
	var ret1 ConstraintTarget

	cret = C.gtk_constraint_get_source(arg0)

	ret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(ConstraintTarget)

	return ret1
}

// SourceAttribute retrieves the attribute of the source to be read by the
// @constraint.
func (c constraint) SourceAttribute() ConstraintAttribute {
	var arg0 *C.GtkConstraint

	arg0 = (*C.GtkConstraint)(unsafe.Pointer(c.Native()))

	var cret C.GtkConstraintAttribute
	var ret1 ConstraintAttribute

	cret = C.gtk_constraint_get_source_attribute(arg0)

	ret1 = ConstraintAttribute(cret)

	return ret1
}

// Strength retrieves the strength of the constraint.
func (c constraint) Strength() int {
	var arg0 *C.GtkConstraint

	arg0 = (*C.GtkConstraint)(unsafe.Pointer(c.Native()))

	var cret C.int
	var ret1 int

	cret = C.gtk_constraint_get_strength(arg0)

	ret1 = C.int(cret)

	return ret1
}

// Target retrieves the ConstraintTarget used as the target for @constraint.
//
// If the Constraint:target property is set to nil, the @constraint will use
// the ConstraintLayout's widget.
func (c constraint) Target() ConstraintTarget {
	var arg0 *C.GtkConstraint

	arg0 = (*C.GtkConstraint)(unsafe.Pointer(c.Native()))

	var cret *C.GtkConstraintTarget
	var ret1 ConstraintTarget

	cret = C.gtk_constraint_get_target(arg0)

	ret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(ConstraintTarget)

	return ret1
}

// TargetAttribute retrieves the attribute of the target to be set by the
// @constraint.
func (c constraint) TargetAttribute() ConstraintAttribute {
	var arg0 *C.GtkConstraint

	arg0 = (*C.GtkConstraint)(unsafe.Pointer(c.Native()))

	var cret C.GtkConstraintAttribute
	var ret1 ConstraintAttribute

	cret = C.gtk_constraint_get_target_attribute(arg0)

	ret1 = ConstraintAttribute(cret)

	return ret1
}

// IsAttached checks whether the @constraint is attached to a
// ConstraintLayout, and it is contributing to the layout.
func (c constraint) IsAttached() bool {
	var arg0 *C.GtkConstraint

	arg0 = (*C.GtkConstraint)(unsafe.Pointer(c.Native()))

	var cret C.gboolean
	var ret1 bool

	cret = C.gtk_constraint_is_attached(arg0)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// IsConstant checks whether the @constraint describes a relation between an
// attribute on the Constraint:target and a constant value.
func (c constraint) IsConstant() bool {
	var arg0 *C.GtkConstraint

	arg0 = (*C.GtkConstraint)(unsafe.Pointer(c.Native()))

	var cret C.gboolean
	var ret1 bool

	cret = C.gtk_constraint_is_constant(arg0)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// IsRequired checks whether the @constraint is a required relation for
// solving the constraint layout.
func (c constraint) IsRequired() bool {
	var arg0 *C.GtkConstraint

	arg0 = (*C.GtkConstraint)(unsafe.Pointer(c.Native()))

	var cret C.gboolean
	var ret1 bool

	cret = C.gtk_constraint_is_required(arg0)

	ret1 = C.bool(cret) != C.false

	return ret1
}
