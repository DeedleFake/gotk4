// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"unsafe"

	"github.com/diamondburned/gotk4/internal/box"
	"github.com/diamondburned/gotk4/internal/gextras"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gtk4
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <stdbool.h>
// #include <gtk/gtk.h>
//
// gboolean gotk4_ShortcutFunc(GtkWidget*, GVariant*, gpointer);
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_activate_action_get_type()), F: marshalActivateAction},
		{T: externglib.Type(C.gtk_callback_action_get_type()), F: marshalCallbackAction},
		{T: externglib.Type(C.gtk_mnemonic_action_get_type()), F: marshalMnemonicAction},
		{T: externglib.Type(C.gtk_named_action_get_type()), F: marshalNamedAction},
		{T: externglib.Type(C.gtk_nothing_action_get_type()), F: marshalNothingAction},
		{T: externglib.Type(C.gtk_shortcut_action_get_type()), F: marshalShortcutAction},
		{T: externglib.Type(C.gtk_signal_action_get_type()), F: marshalSignalAction},
	})
}

// ShortcutFunc: prototype for shortcuts based on user callbacks.
type ShortcutFunc func(widget Widget, args *glib.Variant) bool

//export gotk4_ShortcutFunc
func gotk4_ShortcutFunc(arg0 *C.GtkWidget, arg1 *C.GVariant, arg2 C.gpointer) C.gboolean {
	v := box.Get(uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var widget Widget
	var args *glib.Variant

	widget = gextras.CastObject(externglib.Take(unsafe.Pointer(arg0.Native()))).(Widget)

	{
		args = glib.WrapVariant(unsafe.Pointer(arg1))
	}

	ok := v.(ShortcutFunc)(widget, args)
}

// ActivateAction: a `GtkShortcutAction` that calls gtk_widget_activate().
type ActivateAction interface {
	ShortcutAction
}

// activateAction implements the ActivateAction interface.
type activateAction struct {
	ShortcutAction
}

var _ ActivateAction = (*activateAction)(nil)

// WrapActivateAction wraps a GObject to the right type. It is
// primarily used internally.
func WrapActivateAction(obj *externglib.Object) ActivateAction {
	return ActivateAction{
		ShortcutAction: WrapShortcutAction(obj),
	}
}

func marshalActivateAction(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapActivateAction(obj), nil
}

// CallbackAction: a `GtkShortcutAction` that invokes a callback.
type CallbackAction interface {
	ShortcutAction
}

// callbackAction implements the CallbackAction interface.
type callbackAction struct {
	ShortcutAction
}

var _ CallbackAction = (*callbackAction)(nil)

// WrapCallbackAction wraps a GObject to the right type. It is
// primarily used internally.
func WrapCallbackAction(obj *externglib.Object) CallbackAction {
	return CallbackAction{
		ShortcutAction: WrapShortcutAction(obj),
	}
}

func marshalCallbackAction(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCallbackAction(obj), nil
}

// NewCallbackAction constructs a class CallbackAction.
func NewCallbackAction(callback ShortcutFunc) CallbackAction {
	var arg1 C.GtkShortcutFunc
	var arg2 C.gpointer
	var arg3 C.GDestroyNotify

	ret := C.gtk_callback_action_new(arg1, arg2, arg3)

	var ret0 CallbackAction

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(CallbackAction)

	return ret0
}

// MnemonicAction: a `GtkShortcutAction` that calls
// gtk_widget_mnemonic_activate().
type MnemonicAction interface {
	ShortcutAction
}

// mnemonicAction implements the MnemonicAction interface.
type mnemonicAction struct {
	ShortcutAction
}

var _ MnemonicAction = (*mnemonicAction)(nil)

// WrapMnemonicAction wraps a GObject to the right type. It is
// primarily used internally.
func WrapMnemonicAction(obj *externglib.Object) MnemonicAction {
	return MnemonicAction{
		ShortcutAction: WrapShortcutAction(obj),
	}
}

func marshalMnemonicAction(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapMnemonicAction(obj), nil
}

// NamedAction: a `GtkShortcutAction` that activates an action by name.
type NamedAction interface {
	ShortcutAction

	// ActionName returns the name of the action that will be activated.
	ActionName() string
}

// namedAction implements the NamedAction interface.
type namedAction struct {
	ShortcutAction
}

var _ NamedAction = (*namedAction)(nil)

// WrapNamedAction wraps a GObject to the right type. It is
// primarily used internally.
func WrapNamedAction(obj *externglib.Object) NamedAction {
	return NamedAction{
		ShortcutAction: WrapShortcutAction(obj),
	}
}

func marshalNamedAction(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapNamedAction(obj), nil
}

// NewNamedAction constructs a class NamedAction.
func NewNamedAction(name string) NamedAction {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_named_action_new(arg1)

	var ret0 NamedAction

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(NamedAction)

	return ret0
}

// ActionName returns the name of the action that will be activated.
func (s namedAction) ActionName() string {
	var arg0 *C.GtkNamedAction

	arg0 = (*C.GtkNamedAction)(s.Native())

	ret := C.gtk_named_action_get_action_name(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// NothingAction: a `GtkShortcutAction` that does nothing.
type NothingAction interface {
	ShortcutAction
}

// nothingAction implements the NothingAction interface.
type nothingAction struct {
	ShortcutAction
}

var _ NothingAction = (*nothingAction)(nil)

// WrapNothingAction wraps a GObject to the right type. It is
// primarily used internally.
func WrapNothingAction(obj *externglib.Object) NothingAction {
	return NothingAction{
		ShortcutAction: WrapShortcutAction(obj),
	}
}

func marshalNothingAction(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapNothingAction(obj), nil
}

// ShortcutAction: `GtkShortcutAction` encodes an action that can be triggered
// by a keyboard shortcut.
//
// `GtkShortcutActions` contain functions that allow easy presentation to end
// users as well as being printed for debugging.
//
// All `GtkShortcutActions` are immutable, you can only specify their properties
// during construction. If you want to change a action, you have to replace it
// with a new one. If you need to pass arguments to an action, these are
// specified by the higher-level `GtkShortcut` object.
//
// To activate a `GtkShortcutAction` manually,
// [method@Gtk.ShortcutAction.activate] can be called.
//
// GTK provides various actions:
//
//    - [class@Gtk.MnemonicAction]: a shortcut action that calls
//      gtk_widget_mnemonic_activate()
//    - [class@Gtk.CallbackAction]: a shortcut action that invokes
//      a given callback
//    - [class@Gtk.SignalAction]: a shortcut action that emits a
//      given signal
//    - [class@Gtk.ActivateAction]: a shortcut action that calls
//      gtk_widget_activate()
//    - [class@Gtk.NamedAction]: a shortcut action that calls
//      gtk_widget_activate_action()
//    - [class@Gtk.NothingAction]: a shortcut action that does nothing
type ShortcutAction interface {
	gextras.Objector

	// Activate activates the action on the @widget with the given @args.
	//
	// Note that some actions ignore the passed in @flags, @widget or @args.
	//
	// Activation of an action can fail for various reasons. If the action is
	// not supported by the @widget, if the @args don't match the action or if
	// the activation otherwise had no effect, false will be returned.
	Activate(flags ShortcutActionFlags, widget Widget, args *glib.Variant) bool
	// Print prints the given action into a string for the developer.
	//
	// This is meant for debugging and logging.
	//
	// The form of the representation may change at any time and is not
	// guaranteed to stay identical.
	Print(string *glib.String)
	// String prints the given action into a human-readable string.
	//
	// This is a small wrapper around [method@Gtk.ShortcutAction.print] to help
	// when debugging.
	String() string
}

// shortcutAction implements the ShortcutAction interface.
type shortcutAction struct {
	gextras.Objector
}

var _ ShortcutAction = (*shortcutAction)(nil)

// WrapShortcutAction wraps a GObject to the right type. It is
// primarily used internally.
func WrapShortcutAction(obj *externglib.Object) ShortcutAction {
	return ShortcutAction{
		Objector: obj,
	}
}

func marshalShortcutAction(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapShortcutAction(obj), nil
}

// NewShortcutActionParseString constructs a class ShortcutAction.
func NewShortcutActionParseString(string string) ShortcutAction {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(string))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_shortcut_action_parse_string(arg1)

	var ret0 ShortcutAction

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(ShortcutAction)

	return ret0
}

// Activate activates the action on the @widget with the given @args.
//
// Note that some actions ignore the passed in @flags, @widget or @args.
//
// Activation of an action can fail for various reasons. If the action is
// not supported by the @widget, if the @args don't match the action or if
// the activation otherwise had no effect, false will be returned.
func (s shortcutAction) Activate(flags ShortcutActionFlags, widget Widget, args *glib.Variant) bool {
	var arg0 *C.GtkShortcutAction
	var arg1 C.GtkShortcutActionFlags
	var arg2 *C.GtkWidget
	var arg3 *C.GVariant

	arg0 = (*C.GtkShortcutAction)(s.Native())
	arg1 = (C.GtkShortcutActionFlags)(flags)
	arg2 = (*C.GtkWidget)(widget.Native())
	arg3 = (*C.GVariant)(args.Native())

	ret := C.gtk_shortcut_action_activate(arg0, arg1, arg2, arg3)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// Print prints the given action into a string for the developer.
//
// This is meant for debugging and logging.
//
// The form of the representation may change at any time and is not
// guaranteed to stay identical.
func (s shortcutAction) Print(string *glib.String) {
	var arg0 *C.GtkShortcutAction
	var arg1 *C.GString

	arg0 = (*C.GtkShortcutAction)(s.Native())
	arg1 = (*C.GString)(string.Native())

	C.gtk_shortcut_action_print(arg0, arg1)
}

// String prints the given action into a human-readable string.
//
// This is a small wrapper around [method@Gtk.ShortcutAction.print] to help
// when debugging.
func (s shortcutAction) String() string {
	var arg0 *C.GtkShortcutAction

	arg0 = (*C.GtkShortcutAction)(s.Native())

	ret := C.gtk_shortcut_action_to_string(arg0)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// SignalAction: a `GtkShortcut`Action that emits a signal.
//
// Signals that are used in this way are referred to as keybinding signals, and
// they are expected to be defined with the G_SIGNAL_ACTION flag.
type SignalAction interface {
	ShortcutAction

	// SignalName returns the name of the signal that will be emitted.
	SignalName() string
}

// signalAction implements the SignalAction interface.
type signalAction struct {
	ShortcutAction
}

var _ SignalAction = (*signalAction)(nil)

// WrapSignalAction wraps a GObject to the right type. It is
// primarily used internally.
func WrapSignalAction(obj *externglib.Object) SignalAction {
	return SignalAction{
		ShortcutAction: WrapShortcutAction(obj),
	}
}

func marshalSignalAction(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSignalAction(obj), nil
}

// NewSignalAction constructs a class SignalAction.
func NewSignalAction(signalName string) SignalAction {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(signalName))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_signal_action_new(arg1)

	var ret0 SignalAction

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(SignalAction)

	return ret0
}

// SignalName returns the name of the signal that will be emitted.
func (s signalAction) SignalName() string {
	var arg0 *C.GtkSignalAction

	arg0 = (*C.GtkSignalAction)(s.Native())

	ret := C.gtk_signal_action_get_signal_name(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}
