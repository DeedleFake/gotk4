// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/box"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gtk4
// #cgo CFLAGS: -Wno-deprecated-declarations
//
// #include <glib-object.h>
// #include <gtk/gtk.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_shortcut_action_flags_get_type()), F: marshalShortcutActionFlags},
		{T: externglib.Type(C.gtk_activate_action_get_type()), F: marshalActivateAction},
		{T: externglib.Type(C.gtk_callback_action_get_type()), F: marshalCallbackAction},
		{T: externglib.Type(C.gtk_mnemonic_action_get_type()), F: marshalMnemonicAction},
		{T: externglib.Type(C.gtk_named_action_get_type()), F: marshalNamedAction},
		{T: externglib.Type(C.gtk_nothing_action_get_type()), F: marshalNothingAction},
		{T: externglib.Type(C.gtk_shortcut_action_get_type()), F: marshalShortcutAction},
		{T: externglib.Type(C.gtk_signal_action_get_type()), F: marshalSignalAction},
	})
}

// ShortcutActionFlags: list of flags that can be passed to action activation.
//
// More flags may be added in the future.
type ShortcutActionFlags int

const (
	// ShortcutActionFlagsExclusive: the action is the only action that can be
	// activated. If this flag is not set, a future activation may select a
	// different action.
	ShortcutActionFlagsExclusive ShortcutActionFlags = 0b1
)

func marshalShortcutActionFlags(p uintptr) (interface{}, error) {
	return ShortcutActionFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ShortcutFunc: prototype for shortcuts based on user callbacks.
type ShortcutFunc func(widget Widget, args *glib.Variant) (ok bool)

//export gotk4_ShortcutFunc
func gotk4_ShortcutFunc(arg0 *C.GtkWidget, arg1 *C.GVariant, arg2 C.gpointer) (cret C.gboolean) {
	v := box.Get(uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var widget Widget      // out
	var args *glib.Variant // out

	widget = gextras.CastObject(externglib.Take(unsafe.Pointer(arg0))).(Widget)
	args = (*glib.Variant)(unsafe.Pointer(arg1))
	C.g_variant_ref(arg1)
	runtime.SetFinalizer(args, func(v *glib.Variant) {
		C.g_variant_unref((*C.GVariant)(unsafe.Pointer(v)))
	})

	fn := v.(ShortcutFunc)
	ok := fn(widget, args)

	if ok {
		cret = C.TRUE
	}

	return cret
}

// ActivateAction: `GtkShortcutAction` that calls gtk_widget_activate().
type ActivateAction interface {
	gextras.Objector

	privateActivateActionClass()
}

// ActivateActionClass implements the ActivateAction interface.
type ActivateActionClass struct {
	ShortcutActionClass
}

var _ ActivateAction = (*ActivateActionClass)(nil)

func wrapActivateAction(obj *externglib.Object) ActivateAction {
	return &ActivateActionClass{
		ShortcutActionClass: ShortcutActionClass{
			Object: obj,
		},
	}
}

func marshalActivateAction(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapActivateAction(obj), nil
}

func (*ActivateActionClass) privateActivateActionClass() {}

// CallbackAction: `GtkShortcutAction` that invokes a callback.
type CallbackAction interface {
	gextras.Objector

	privateCallbackActionClass()
}

// CallbackActionClass implements the CallbackAction interface.
type CallbackActionClass struct {
	ShortcutActionClass
}

var _ CallbackAction = (*CallbackActionClass)(nil)

func wrapCallbackAction(obj *externglib.Object) CallbackAction {
	return &CallbackActionClass{
		ShortcutActionClass: ShortcutActionClass{
			Object: obj,
		},
	}
}

func marshalCallbackAction(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapCallbackAction(obj), nil
}

func (*CallbackActionClass) privateCallbackActionClass() {}

// MnemonicAction: `GtkShortcutAction` that calls
// gtk_widget_mnemonic_activate().
type MnemonicAction interface {
	gextras.Objector

	privateMnemonicActionClass()
}

// MnemonicActionClass implements the MnemonicAction interface.
type MnemonicActionClass struct {
	ShortcutActionClass
}

var _ MnemonicAction = (*MnemonicActionClass)(nil)

func wrapMnemonicAction(obj *externglib.Object) MnemonicAction {
	return &MnemonicActionClass{
		ShortcutActionClass: ShortcutActionClass{
			Object: obj,
		},
	}
}

func marshalMnemonicAction(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapMnemonicAction(obj), nil
}

func (*MnemonicActionClass) privateMnemonicActionClass() {}

// NamedAction: `GtkShortcutAction` that activates an action by name.
type NamedAction interface {
	gextras.Objector

	// ActionName returns the name of the action that will be activated.
	ActionName() string
}

// NamedActionClass implements the NamedAction interface.
type NamedActionClass struct {
	ShortcutActionClass
}

var _ NamedAction = (*NamedActionClass)(nil)

func wrapNamedAction(obj *externglib.Object) NamedAction {
	return &NamedActionClass{
		ShortcutActionClass: ShortcutActionClass{
			Object: obj,
		},
	}
}

func marshalNamedAction(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapNamedAction(obj), nil
}

// NewNamedAction creates an action that when activated, activates the named
// action on the widget.
//
// It also passes the given arguments to it.
//
// See [method@Gtk.Widget.insert_action_group] for how to add actions to
// widgets.
func NewNamedAction(name string) NamedAction {
	var _arg1 *C.char              // out
	var _cret *C.GtkShortcutAction // in

	_arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_named_action_new(_arg1)

	var _namedAction NamedAction // out

	_namedAction = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(NamedAction)

	return _namedAction
}

// ActionName returns the name of the action that will be activated.
func (s *NamedActionClass) ActionName() string {
	var _arg0 *C.GtkNamedAction // out
	var _cret *C.char           // in

	_arg0 = (*C.GtkNamedAction)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_named_action_get_action_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// NothingAction: `GtkShortcutAction` that does nothing.
type NothingAction interface {
	gextras.Objector

	privateNothingActionClass()
}

// NothingActionClass implements the NothingAction interface.
type NothingActionClass struct {
	ShortcutActionClass
}

var _ NothingAction = (*NothingActionClass)(nil)

func wrapNothingAction(obj *externglib.Object) NothingAction {
	return &NothingActionClass{
		ShortcutActionClass: ShortcutActionClass{
			Object: obj,
		},
	}
}

func marshalNothingAction(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapNothingAction(obj), nil
}

func (*NothingActionClass) privateNothingActionClass() {}

// ShortcutAction: `GtkShortcutAction` encodes an action that can be triggered
// by a keyboard shortcut.
//
// `GtkShortcutActions` contain functions that allow easy presentation to end
// users as well as being printed for debugging.
//
// All `GtkShortcutActions` are immutable, you can only specify their properties
// during construction. If you want to change a action, you have to replace it
// with a new one. If you need to pass arguments to an action, these are
// specified by the higher-level `GtkShortcut` object.
//
// To activate a `GtkShortcutAction` manually,
// [method@Gtk.ShortcutAction.activate] can be called.
//
// GTK provides various actions:
//
//    - [class@Gtk.MnemonicAction]: a shortcut action that calls
//      gtk_widget_mnemonic_activate()
//    - [class@Gtk.CallbackAction]: a shortcut action that invokes
//      a given callback
//    - [class@Gtk.SignalAction]: a shortcut action that emits a
//      given signal
//    - [class@Gtk.ActivateAction]: a shortcut action that calls
//      gtk_widget_activate()
//    - [class@Gtk.NamedAction]: a shortcut action that calls
//      gtk_widget_activate_action()
//    - [class@Gtk.NothingAction]: a shortcut action that does nothing
type ShortcutAction interface {
	gextras.Objector

	// Activate activates the action on the @widget with the given @args.
	//
	// Note that some actions ignore the passed in @flags, @widget or @args.
	//
	// Activation of an action can fail for various reasons. If the action is
	// not supported by the @widget, if the @args don't match the action or if
	// the activation otherwise had no effect, false will be returned.
	Activate(flags ShortcutActionFlags, widget Widget, args *glib.Variant) bool
	// String prints the given action into a human-readable string.
	//
	// This is a small wrapper around [method@Gtk.ShortcutAction.print] to help
	// when debugging.
	String() string
}

// ShortcutActionClass implements the ShortcutAction interface.
type ShortcutActionClass struct {
	*externglib.Object
}

var _ ShortcutAction = (*ShortcutActionClass)(nil)

func wrapShortcutAction(obj *externglib.Object) ShortcutAction {
	return &ShortcutActionClass{
		Object: obj,
	}
}

func marshalShortcutAction(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapShortcutAction(obj), nil
}

// NewShortcutActionParseString tries to parse the given string into an action.
//
// On success, the parsed action is returned. When parsing failed, nil is
// returned.
//
// The accepted strings are:
//
// - `nothing`, for `GtkNothingAction` - `activate`, for `GtkActivateAction` -
// `mnemonic-activate`, for `GtkMnemonicAction` - `action(NAME)`, for a
// `GtkNamedAction` for the action named `NAME` - `signal(NAME)`, for a
// `GtkSignalAction` for the signal `NAME`
func NewShortcutActionParseString(_string string) ShortcutAction {
	var _arg1 *C.char              // out
	var _cret *C.GtkShortcutAction // in

	_arg1 = (*C.char)(C.CString(_string))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_shortcut_action_parse_string(_arg1)

	var _shortcutAction ShortcutAction // out

	_shortcutAction = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(ShortcutAction)

	return _shortcutAction
}

// Activate activates the action on the @widget with the given @args.
//
// Note that some actions ignore the passed in @flags, @widget or @args.
//
// Activation of an action can fail for various reasons. If the action is not
// supported by the @widget, if the @args don't match the action or if the
// activation otherwise had no effect, false will be returned.
func (s *ShortcutActionClass) Activate(flags ShortcutActionFlags, widget Widget, args *glib.Variant) bool {
	var _arg0 *C.GtkShortcutAction     // out
	var _arg1 C.GtkShortcutActionFlags // out
	var _arg2 *C.GtkWidget             // out
	var _arg3 *C.GVariant              // out
	var _cret C.gboolean               // in

	_arg0 = (*C.GtkShortcutAction)(unsafe.Pointer(s.Native()))
	_arg1 = C.GtkShortcutActionFlags(flags)
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg3 = (*C.GVariant)(unsafe.Pointer(args))

	_cret = C.gtk_shortcut_action_activate(_arg0, _arg1, _arg2, _arg3)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// String prints the given action into a human-readable string.
//
// This is a small wrapper around [method@Gtk.ShortcutAction.print] to help when
// debugging.
func (s *ShortcutActionClass) String() string {
	var _arg0 *C.GtkShortcutAction // out
	var _cret *C.char              // in

	_arg0 = (*C.GtkShortcutAction)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_shortcut_action_to_string(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// SignalAction: `GtkShortcut`Action that emits a signal.
//
// Signals that are used in this way are referred to as keybinding signals, and
// they are expected to be defined with the G_SIGNAL_ACTION flag.
type SignalAction interface {
	gextras.Objector

	// SignalName returns the name of the signal that will be emitted.
	SignalName() string
}

// SignalActionClass implements the SignalAction interface.
type SignalActionClass struct {
	ShortcutActionClass
}

var _ SignalAction = (*SignalActionClass)(nil)

func wrapSignalAction(obj *externglib.Object) SignalAction {
	return &SignalActionClass{
		ShortcutActionClass: ShortcutActionClass{
			Object: obj,
		},
	}
}

func marshalSignalAction(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapSignalAction(obj), nil
}

// NewSignalAction creates an action that when activated, emits the given action
// signal on the provided widget.
//
// It will also unpack the args into arguments passed to the signal.
func NewSignalAction(signalName string) SignalAction {
	var _arg1 *C.char              // out
	var _cret *C.GtkShortcutAction // in

	_arg1 = (*C.char)(C.CString(signalName))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_signal_action_new(_arg1)

	var _signalAction SignalAction // out

	_signalAction = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(SignalAction)

	return _signalAction
}

// SignalName returns the name of the signal that will be emitted.
func (s *SignalActionClass) SignalName() string {
	var _arg0 *C.GtkSignalAction // out
	var _cret *C.char            // in

	_arg0 = (*C.GtkSignalAction)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_signal_action_get_signal_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}
