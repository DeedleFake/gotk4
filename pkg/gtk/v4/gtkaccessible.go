// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"unsafe"

	"github.com/diamondburned/gotk4/core/gextras"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gtk4
// #cgo CFLAGS: -Wno-deprecated-declarations
//
// #include <glib-object.h>
// #include <gtk/gtk.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_accessible_get_type()), F: marshalAccessible},
	})
}

// Accessible: `GtkAccessible` is an interface for describing UI elements for
// Assistive Technologies.
//
// Every accessible implementation has:
//
//    - a “role”, represented by a value of the [enum@Gtk.AccessibleRole]
//      enumeration
//    - an “attribute”, represented by a set of [enum@Gtk.AccessibleState],
//      [enum@Gtk.AccessibleProperty] and [enum@Gtk.AccessibleRelation] values
//
// The role cannot be changed after instantiating a `GtkAccessible`
// implementation.
//
// The attributes are updated every time a UI element's state changes in a way
// that should be reflected by assistive technologies. For instance, if a
// `GtkWidget` visibility changes, the GTK_ACCESSIBLE_STATE_HIDDEN state will
// also change to reflect the [property@Gtk.Widget:visible] property.
type Accessible interface {
	gextras.Objector

	// AccessibleRole updates an array of accessible states.
	//
	// This function should be called by `GtkWidget` types whenever an
	// accessible state change must be communicated to assistive technologies.
	//
	// This function is meant to be used by language bindings.
	AccessibleRole() AccessibleRole
	// ResetProperty updates an array of accessible states.
	//
	// This function should be called by `GtkWidget` types whenever an
	// accessible state change must be communicated to assistive technologies.
	//
	// This function is meant to be used by language bindings.
	ResetProperty(property AccessibleProperty)
	// ResetRelation updates an array of accessible states.
	//
	// This function should be called by `GtkWidget` types whenever an
	// accessible state change must be communicated to assistive technologies.
	//
	// This function is meant to be used by language bindings.
	ResetRelation(relation AccessibleRelation)
	// ResetState updates an array of accessible states.
	//
	// This function should be called by `GtkWidget` types whenever an
	// accessible state change must be communicated to assistive technologies.
	//
	// This function is meant to be used by language bindings.
	ResetState(state AccessibleState)
	// UpdatePropertyValue updates an array of accessible states.
	//
	// This function should be called by `GtkWidget` types whenever an
	// accessible state change must be communicated to assistive technologies.
	//
	// This function is meant to be used by language bindings.
	UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value)
	// UpdateRelationValue updates an array of accessible states.
	//
	// This function should be called by `GtkWidget` types whenever an
	// accessible state change must be communicated to assistive technologies.
	//
	// This function is meant to be used by language bindings.
	UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value)
	// UpdateStateValue updates an array of accessible states.
	//
	// This function should be called by `GtkWidget` types whenever an
	// accessible state change must be communicated to assistive technologies.
	//
	// This function is meant to be used by language bindings.
	UpdateStateValue(states []AccessibleState, values []externglib.Value)
}

// accessible implements the Accessible interface.
type accessible struct {
	gextras.Objector
}

var _ Accessible = (*accessible)(nil)

// WrapAccessible wraps a GObject to a type that implements
// interface Accessible. It is primarily used internally.
func WrapAccessible(obj *externglib.Object) Accessible {
	return accessible{
		Objector: obj,
	}
}

func marshalAccessible(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapAccessible(obj), nil
}

func (s accessible) AccessibleRole() AccessibleRole {
	var _arg0 *C.GtkAccessible    // out
	var _cret C.GtkAccessibleRole // in

	_arg0 = (*C.GtkAccessible)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_accessible_get_accessible_role(_arg0)

	var _accessibleRole AccessibleRole // out

	_accessibleRole = AccessibleRole(_cret)

	return _accessibleRole
}

func (s accessible) ResetProperty(property AccessibleProperty) {
	var _arg0 *C.GtkAccessible        // out
	var _arg1 C.GtkAccessibleProperty // out

	_arg0 = (*C.GtkAccessible)(unsafe.Pointer(s.Native()))
	_arg1 = C.GtkAccessibleProperty(property)

	C.gtk_accessible_reset_property(_arg0, _arg1)
}

func (s accessible) ResetRelation(relation AccessibleRelation) {
	var _arg0 *C.GtkAccessible        // out
	var _arg1 C.GtkAccessibleRelation // out

	_arg0 = (*C.GtkAccessible)(unsafe.Pointer(s.Native()))
	_arg1 = C.GtkAccessibleRelation(relation)

	C.gtk_accessible_reset_relation(_arg0, _arg1)
}

func (s accessible) ResetState(state AccessibleState) {
	var _arg0 *C.GtkAccessible     // out
	var _arg1 C.GtkAccessibleState // out

	_arg0 = (*C.GtkAccessible)(unsafe.Pointer(s.Native()))
	_arg1 = C.GtkAccessibleState(state)

	C.gtk_accessible_reset_state(_arg0, _arg1)
}

func (s accessible) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	var _arg0 *C.GtkAccessible // out
	var _arg2 *C.GtkAccessibleProperty
	var _arg1 C.int
	var _arg3 *C.GValue
	var _arg1 C.int

	_arg0 = (*C.GtkAccessible)(unsafe.Pointer(s.Native()))
	_arg1 = C.int(len(properties))
	_arg2 = (*C.GtkAccessibleProperty)(C.malloc(C.ulong(len(properties)) * C.ulong(C.sizeof_GtkAccessibleProperty)))
	defer C.free(unsafe.Pointer(_arg2))
	{
		out := unsafe.Slice(_arg2, len(properties))
		for i := range properties {
			out[i] = C.GtkAccessibleProperty(properties[i])
		}
	}
	_arg1 = C.int(len(values))
	_arg3 = (*C.GValue)(C.malloc(C.ulong(len(values)) * C.ulong(C.sizeof_GValue)))
	defer C.free(unsafe.Pointer(_arg3))
	{
		out := unsafe.Slice(_arg3, len(values))
		for i := range values {
			{
				var refTmpIn *externglib.Value
				var refTmpOut *C.GValue

				in0 := &values[i]
				refTmpIn = in0

				refTmpOut = (*C.GValue)(unsafe.Pointer(&refTmpIn.GValue))

				out[i] = *refTmpOut
			}
		}
	}

	C.gtk_accessible_update_property_value(_arg0, _arg1, _arg2, _arg3)
}

func (s accessible) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	var _arg0 *C.GtkAccessible // out
	var _arg2 *C.GtkAccessibleRelation
	var _arg1 C.int
	var _arg3 *C.GValue
	var _arg1 C.int

	_arg0 = (*C.GtkAccessible)(unsafe.Pointer(s.Native()))
	_arg1 = C.int(len(relations))
	_arg2 = (*C.GtkAccessibleRelation)(C.malloc(C.ulong(len(relations)) * C.ulong(C.sizeof_GtkAccessibleRelation)))
	defer C.free(unsafe.Pointer(_arg2))
	{
		out := unsafe.Slice(_arg2, len(relations))
		for i := range relations {
			out[i] = C.GtkAccessibleRelation(relations[i])
		}
	}
	_arg1 = C.int(len(values))
	_arg3 = (*C.GValue)(C.malloc(C.ulong(len(values)) * C.ulong(C.sizeof_GValue)))
	defer C.free(unsafe.Pointer(_arg3))
	{
		out := unsafe.Slice(_arg3, len(values))
		for i := range values {
			{
				var refTmpIn *externglib.Value
				var refTmpOut *C.GValue

				in0 := &values[i]
				refTmpIn = in0

				refTmpOut = (*C.GValue)(unsafe.Pointer(&refTmpIn.GValue))

				out[i] = *refTmpOut
			}
		}
	}

	C.gtk_accessible_update_relation_value(_arg0, _arg1, _arg2, _arg3)
}

func (s accessible) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	var _arg0 *C.GtkAccessible // out
	var _arg2 *C.GtkAccessibleState
	var _arg1 C.int
	var _arg3 *C.GValue
	var _arg1 C.int

	_arg0 = (*C.GtkAccessible)(unsafe.Pointer(s.Native()))
	_arg1 = C.int(len(states))
	_arg2 = (*C.GtkAccessibleState)(C.malloc(C.ulong(len(states)) * C.ulong(C.sizeof_GtkAccessibleState)))
	defer C.free(unsafe.Pointer(_arg2))
	{
		out := unsafe.Slice(_arg2, len(states))
		for i := range states {
			out[i] = C.GtkAccessibleState(states[i])
		}
	}
	_arg1 = C.int(len(values))
	_arg3 = (*C.GValue)(C.malloc(C.ulong(len(values)) * C.ulong(C.sizeof_GValue)))
	defer C.free(unsafe.Pointer(_arg3))
	{
		out := unsafe.Slice(_arg3, len(values))
		for i := range values {
			{
				var refTmpIn *externglib.Value
				var refTmpOut *C.GValue

				in0 := &values[i]
				refTmpIn = in0

				refTmpOut = (*C.GValue)(unsafe.Pointer(&refTmpIn.GValue))

				out[i] = *refTmpOut
			}
		}
	}

	C.gtk_accessible_update_state_value(_arg0, _arg1, _arg2, _arg3)
}
