// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/box"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/pango"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gtk4
// #cgo CFLAGS: -Wno-deprecated-declarations
//
// #include <glib-object.h>
// #include <gtk/gtk.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_scale_get_type()), F: marshalScale},
	})
}

type ScaleFormatValueFunc func(scale Scale, value float64, utf8 string)

//export gotk4_ScaleFormatValueFunc
func gotk4_ScaleFormatValueFunc(arg0 *C.GtkScale, arg1 C.double, arg2 C.gpointer) *C.char {
	v := box.Get(uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var scale Scale   // out
	var value float64 // out

	scale = gextras.CastObject(externglib.Take(unsafe.Pointer(arg0))).(Scale)
	value = float64(arg1)

	fn := v.(ScaleFormatValueFunc)
	utf8 := fn(scale, value)

	var cret *C.char // out

	cret = (*C.char)(C.CString(utf8))

	return cret
}

// Scale: a `GtkScale` is a slider control used to select a numeric value.
//
// !An example GtkScale (scales.png)
//
// To use it, you’ll probably want to investigate the methods on its base class,
// [class@GtkRange], in addition to the methods for `GtkScale` itself. To set
// the value of a scale, you would normally use [method@Gtk.Range.set_value]. To
// detect changes to the value, you would normally use the
// [signal@Gtk.Range::value-changed] signal.
//
// Note that using the same upper and lower bounds for the `GtkScale` (through
// the `GtkRange` methods) will hide the slider itself. This is useful for
// applications that want to show an undeterminate value on the scale, without
// changing the layout of the application (such as movie or music players).
//
//
// GtkScale as GtkBuildable
//
// `GtkScale` supports a custom <marks> element, which can contain multiple
// <mark\> elements. The “value” and “position” attributes have the same meaning
// as [method@Gtk.Scale.add_mark] parameters of the same name. If the element is
// not empty, its content is taken as the markup to show at the mark. It can be
// translated with the usual ”translatable” and “context” attributes.
//
//
// CSS nodes
//
// “` scale[.fine-tune][.marks-before][.marks-after] ├──
// [value][.top][.right][.bottom][.left] ├── marks.top │ ├── mark │ ┊ ├──
// [label] │ ┊ ╰── indicator ┊ ┊ │ ╰── mark ├── marks.bottom │ ├── mark │ ┊ ├──
// indicator │ ┊ ╰── [label] ┊ ┊ │ ╰── mark ╰── trough ├── [fill] ├──
// [highlight] ╰── slider “`
//
// `GtkScale` has a main CSS node with name scale and a subnode for its
// contents, with subnodes named trough and slider.
//
// The main node gets the style class .fine-tune added when the scale is in
// 'fine-tuning' mode.
//
// If the scale has an origin (see [method@Gtk.Scale.set_has_origin]), there is
// a subnode with name highlight below the trough node that is used for
// rendering the highlighted part of the trough.
//
// If the scale is showing a fill level (see
// [method@Gtk.Range.set_show_fill_level]), there is a subnode with name fill
// below the trough node that is used for rendering the filled in part of the
// trough.
//
// If marks are present, there is a marks subnode before or after the trough
// node, below which each mark gets a node with name mark. The marks nodes get
// either the .top or .bottom style class.
//
// The mark node has a subnode named indicator. If the mark has text, it also
// has a subnode named label. When the mark is either above or left of the
// scale, the label subnode is the first when present. Otherwise, the indicator
// subnode is the first.
//
// The main CSS node gets the 'marks-before' and/or 'marks-after' style classes
// added depending on what marks are present.
//
// If the scale is displaying the value (see [property@Gtk.Scale:draw-value]),
// there is subnode with name value. This node will get the .top or .bottom
// style classes similar to the marks node.
//
//
// Accessibility
//
// `GtkScale` uses the GTK_ACCESSIBLE_ROLE_SLIDER role.
type Scale interface {
	Range

	AddMarkScale(value float64, position PositionType, markup string)

	ClearMarksScale()

	Digits() int

	DrawValue() bool

	HasOrigin() bool

	Layout() pango.Layout

	LayoutOffsets() (x int, y int)

	ValuePos() PositionType

	SetDigitsScale(digits int)

	SetDrawValueScale(drawValue bool)

	SetHasOriginScale(hasOrigin bool)

	SetValuePosScale(pos PositionType)
}

// scale implements the Scale class.
type scale struct {
	Range
}

// WrapScale wraps a GObject to the right type. It is
// primarily used internally.
func WrapScale(obj *externglib.Object) Scale {
	return scale{
		Range: WrapRange(obj),
	}
}

func marshalScale(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapScale(obj), nil
}

func NewScale(orientation Orientation, adjustment Adjustment) Scale {
	var _arg1 C.GtkOrientation // out
	var _arg2 *C.GtkAdjustment // out
	var _cret *C.GtkWidget     // in

	_arg1 = C.GtkOrientation(orientation)
	_arg2 = (*C.GtkAdjustment)(unsafe.Pointer(adjustment.Native()))

	_cret = C.gtk_scale_new(_arg1, _arg2)

	var _scale Scale // out

	_scale = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Scale)

	return _scale
}

func NewScaleWithRange(orientation Orientation, min float64, max float64, step float64) Scale {
	var _arg1 C.GtkOrientation // out
	var _arg2 C.double         // out
	var _arg3 C.double         // out
	var _arg4 C.double         // out
	var _cret *C.GtkWidget     // in

	_arg1 = C.GtkOrientation(orientation)
	_arg2 = C.double(min)
	_arg3 = C.double(max)
	_arg4 = C.double(step)

	_cret = C.gtk_scale_new_with_range(_arg1, _arg2, _arg3, _arg4)

	var _scale Scale // out

	_scale = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Scale)

	return _scale
}

func (s scale) AddMarkScale(value float64, position PositionType, markup string) {
	var _arg0 *C.GtkScale       // out
	var _arg1 C.double          // out
	var _arg2 C.GtkPositionType // out
	var _arg3 *C.char           // out

	_arg0 = (*C.GtkScale)(unsafe.Pointer(s.Native()))
	_arg1 = C.double(value)
	_arg2 = C.GtkPositionType(position)
	_arg3 = (*C.char)(C.CString(markup))
	defer C.free(unsafe.Pointer(_arg3))

	C.gtk_scale_add_mark(_arg0, _arg1, _arg2, _arg3)
}

func (s scale) ClearMarksScale() {
	var _arg0 *C.GtkScale // out

	_arg0 = (*C.GtkScale)(unsafe.Pointer(s.Native()))

	C.gtk_scale_clear_marks(_arg0)
}

func (s scale) Digits() int {
	var _arg0 *C.GtkScale // out
	var _cret C.int       // in

	_arg0 = (*C.GtkScale)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_scale_get_digits(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

func (s scale) DrawValue() bool {
	var _arg0 *C.GtkScale // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkScale)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_scale_get_draw_value(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s scale) HasOrigin() bool {
	var _arg0 *C.GtkScale // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkScale)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_scale_get_has_origin(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s scale) Layout() pango.Layout {
	var _arg0 *C.GtkScale    // out
	var _cret *C.PangoLayout // in

	_arg0 = (*C.GtkScale)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_scale_get_layout(_arg0)

	var _layout pango.Layout // out

	_layout = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(pango.Layout)

	return _layout
}

func (s scale) LayoutOffsets() (x int, y int) {
	var _arg0 *C.GtkScale // out
	var _arg1 C.int       // in
	var _arg2 C.int       // in

	_arg0 = (*C.GtkScale)(unsafe.Pointer(s.Native()))

	C.gtk_scale_get_layout_offsets(_arg0, &_arg1, &_arg2)

	var _x int // out
	var _y int // out

	_x = int(_arg1)
	_y = int(_arg2)

	return _x, _y
}

func (s scale) ValuePos() PositionType {
	var _arg0 *C.GtkScale       // out
	var _cret C.GtkPositionType // in

	_arg0 = (*C.GtkScale)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_scale_get_value_pos(_arg0)

	var _positionType PositionType // out

	_positionType = PositionType(_cret)

	return _positionType
}

func (s scale) SetDigitsScale(digits int) {
	var _arg0 *C.GtkScale // out
	var _arg1 C.int       // out

	_arg0 = (*C.GtkScale)(unsafe.Pointer(s.Native()))
	_arg1 = C.int(digits)

	C.gtk_scale_set_digits(_arg0, _arg1)
}

func (s scale) SetDrawValueScale(drawValue bool) {
	var _arg0 *C.GtkScale // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GtkScale)(unsafe.Pointer(s.Native()))
	if drawValue {
		_arg1 = C.TRUE
	}

	C.gtk_scale_set_draw_value(_arg0, _arg1)
}

func (s scale) SetHasOriginScale(hasOrigin bool) {
	var _arg0 *C.GtkScale // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GtkScale)(unsafe.Pointer(s.Native()))
	if hasOrigin {
		_arg1 = C.TRUE
	}

	C.gtk_scale_set_has_origin(_arg0, _arg1)
}

func (s scale) SetValuePosScale(pos PositionType) {
	var _arg0 *C.GtkScale       // out
	var _arg1 C.GtkPositionType // out

	_arg0 = (*C.GtkScale)(unsafe.Pointer(s.Native()))
	_arg1 = C.GtkPositionType(pos)

	C.gtk_scale_set_value_pos(_arg0, _arg1)
}

func (s scale) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s scale) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s scale) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s scale) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s scale) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s scale) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s scale) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b scale) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}

func (o scale) Orientation() Orientation {
	return WrapOrientable(gextras.InternObject(o)).Orientation()
}

func (o scale) SetOrientation(orientation Orientation) {
	WrapOrientable(gextras.InternObject(o)).SetOrientation(orientation)
}
