// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"unsafe"

	"github.com/diamondburned/gotk4/core/box"
	"github.com/diamondburned/gotk4/core/gextras"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gtk4
// #cgo CFLAGS: -Wno-deprecated-declarations
//
// #include <glib-object.h>
// #include <gtk/gtk.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_menu_button_get_type()), F: marshalMenuButton},
	})
}

// MenuButtonCreatePopupFunc: user-provided callback function to create a popup
// for a `GtkMenuButton` on demand.
//
// This function is called when the popup of @menu_button is shown, but none has
// been provided via [method@Gtk.MenuButton.set_popover] or
// [method@Gtk.MenuButton.set_menu_model].
type MenuButtonCreatePopupFunc func(menuButton MenuButton)

//export gotk4_MenuButtonCreatePopupFunc
func _MenuButtonCreatePopupFunc(arg0 *C.GtkMenuButton, arg1 C.gpointer) {
	v := box.Get(uintptr(arg1))
	if v == nil {
		panic(`callback not found`)
	}

	var menuButton MenuButton // out

	menuButton = gextras.CastObject(externglib.Take(unsafe.Pointer(arg0))).(MenuButton)

	fn := v.(MenuButtonCreatePopupFunc)
	fn(menuButton)
}

// MenuButton: the `GtkMenuButton` widget is used to display a popup when
// clicked.
//
// !An example GtkMenuButton (menu-button.png)
//
// This popup can be provided either as a `GtkPopover` or as an abstract
// `GMenuModel`.
//
// The `GtkMenuButton` widget can show either an icon (set with the
// [property@Gtk.MenuButton:icon-name] property) or a label (set with the
// [property@Gtk.MenuButton:label] property). If neither is explicitly set, a
// [class@Gtk.Image] is automatically created, using an arrow image oriented
// according to [property@Gtk.MenuButton:direction] or the generic
// “open-menu-symbolic” icon if the direction is not set.
//
// The positioning of the popup is determined by the
// [property@Gtk.MenuButton:direction] property of the menu button.
//
// For menus, the [property@Gtk.Widget:halign] and [property@Gtk.Widget:valign]
// properties of the menu are also taken into account. For example, when the
// direction is GTK_ARROW_DOWN and the horizontal alignment is GTK_ALIGN_START,
// the menu will be positioned below the button, with the starting edge
// (depending on the text direction) of the menu aligned with the starting edge
// of the button. If there is not enough space below the button, the menu is
// popped up above the button instead. If the alignment would move part of the
// menu offscreen, it is “pushed in”.
//
// | | start | center | end | | - | --- | --- | --- | | **down** | !
// (down-start.png) | ! (down-center.png) | ! (down-end.png) | | **up** | !
// (up-start.png) | ! (up-center.png) | ! (up-end.png) | | **left** | !
// (left-start.png) | ! (left-center.png) | ! (left-end.png) | | **right** | !
// (right-start.png) | ! (right-center.png) | ! (right-end.png) |
//
//
// CSS nodes
//
// “` menubutton ╰── button.toggle ╰── <content> ╰── [arrow] “`
//
// `GtkMenuButton` has a single CSS node with name `menubutton` which contains a
// `button` node with a `.toggle` style class.
//
// Inside the toggle button content, there is an `arrow` node for the indicator,
// which will carry one of the `.none`, `.up`, `.down`, `.left` or `.right`
// style classes to indicate the direction that the menu will appear in. The CSS
// is expected to provide a suitable image for each of these cases using the
// `-gtk-icon-source` property.
//
// Optionally, the `menubutton` node can carry the `.circular` style class to
// request a round appearance.
//
//
// Accessibility
//
// `GtkMenuButton` uses the K_ACCESSIBLE_ROLE_BUTTON role.
type MenuButton interface {
	Widget

	Direction() ArrowType

	HasFrame() bool

	IconName() string

	Label() string

	MenuModel() gio.MenuModel

	Popover() Popover

	UseUnderline() bool

	PopdownMenuButton()

	PopupMenuButton()

	SetDirectionMenuButton(direction ArrowType)

	SetHasFrameMenuButton(hasFrame bool)

	SetIconNameMenuButton(iconName string)

	SetLabelMenuButton(label string)

	SetMenuModelMenuButton(menuModel gio.MenuModel)

	SetPopoverMenuButton(popover Widget)

	SetUseUnderlineMenuButton(useUnderline bool)
}

// menuButton implements the MenuButton class.
type menuButton struct {
	Widget
}

// WrapMenuButton wraps a GObject to the right type. It is
// primarily used internally.
func WrapMenuButton(obj *externglib.Object) MenuButton {
	return menuButton{
		Widget: WrapWidget(obj),
	}
}

func marshalMenuButton(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapMenuButton(obj), nil
}

func NewMenuButton() MenuButton {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_menu_button_new()

	var _menuButton MenuButton // out

	_menuButton = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(MenuButton)

	return _menuButton
}

func (m menuButton) Direction() ArrowType {
	var _arg0 *C.GtkMenuButton // out
	var _cret C.GtkArrowType   // in

	_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))

	_cret = C.gtk_menu_button_get_direction(_arg0)

	var _arrowType ArrowType // out

	_arrowType = ArrowType(_cret)

	return _arrowType
}

func (m menuButton) HasFrame() bool {
	var _arg0 *C.GtkMenuButton // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))

	_cret = C.gtk_menu_button_get_has_frame(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (m menuButton) IconName() string {
	var _arg0 *C.GtkMenuButton // out
	var _cret *C.char          // in

	_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))

	_cret = C.gtk_menu_button_get_icon_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (m menuButton) Label() string {
	var _arg0 *C.GtkMenuButton // out
	var _cret *C.char          // in

	_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))

	_cret = C.gtk_menu_button_get_label(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (m menuButton) MenuModel() gio.MenuModel {
	var _arg0 *C.GtkMenuButton // out
	var _cret *C.GMenuModel    // in

	_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))

	_cret = C.gtk_menu_button_get_menu_model(_arg0)

	var _menuModel gio.MenuModel // out

	_menuModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.MenuModel)

	return _menuModel
}

func (m menuButton) Popover() Popover {
	var _arg0 *C.GtkMenuButton // out
	var _cret *C.GtkPopover    // in

	_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))

	_cret = C.gtk_menu_button_get_popover(_arg0)

	var _popover Popover // out

	_popover = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Popover)

	return _popover
}

func (m menuButton) UseUnderline() bool {
	var _arg0 *C.GtkMenuButton // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))

	_cret = C.gtk_menu_button_get_use_underline(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (m menuButton) PopdownMenuButton() {
	var _arg0 *C.GtkMenuButton // out

	_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))

	C.gtk_menu_button_popdown(_arg0)
}

func (m menuButton) PopupMenuButton() {
	var _arg0 *C.GtkMenuButton // out

	_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))

	C.gtk_menu_button_popup(_arg0)
}

func (m menuButton) SetDirectionMenuButton(direction ArrowType) {
	var _arg0 *C.GtkMenuButton // out
	var _arg1 C.GtkArrowType   // out

	_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))
	_arg1 = C.GtkArrowType(direction)

	C.gtk_menu_button_set_direction(_arg0, _arg1)
}

func (m menuButton) SetHasFrameMenuButton(hasFrame bool) {
	var _arg0 *C.GtkMenuButton // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))
	if hasFrame {
		_arg1 = C.TRUE
	}

	C.gtk_menu_button_set_has_frame(_arg0, _arg1)
}

func (m menuButton) SetIconNameMenuButton(iconName string) {
	var _arg0 *C.GtkMenuButton // out
	var _arg1 *C.char          // out

	_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.char)(C.CString(iconName))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_menu_button_set_icon_name(_arg0, _arg1)
}

func (m menuButton) SetLabelMenuButton(label string) {
	var _arg0 *C.GtkMenuButton // out
	var _arg1 *C.char          // out

	_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.char)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_menu_button_set_label(_arg0, _arg1)
}

func (m menuButton) SetMenuModelMenuButton(menuModel gio.MenuModel) {
	var _arg0 *C.GtkMenuButton // out
	var _arg1 *C.GMenuModel    // out

	_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.GMenuModel)(unsafe.Pointer(menuModel.Native()))

	C.gtk_menu_button_set_menu_model(_arg0, _arg1)
}

func (m menuButton) SetPopoverMenuButton(popover Widget) {
	var _arg0 *C.GtkMenuButton // out
	var _arg1 *C.GtkWidget     // out

	_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(popover.Native()))

	C.gtk_menu_button_set_popover(_arg0, _arg1)
}

func (m menuButton) SetUseUnderlineMenuButton(useUnderline bool) {
	var _arg0 *C.GtkMenuButton // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))
	if useUnderline {
		_arg1 = C.TRUE
	}

	C.gtk_menu_button_set_use_underline(_arg0, _arg1)
}

func (s menuButton) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s menuButton) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s menuButton) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s menuButton) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s menuButton) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s menuButton) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s menuButton) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b menuButton) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}
