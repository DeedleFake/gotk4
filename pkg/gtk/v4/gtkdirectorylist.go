// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gtk4
// #cgo CFLAGS: -Wno-deprecated-declarations
//
// #include <glib-object.h>
// #include <gtk/gtk.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_directory_list_get_type()), F: marshalDirectoryList},
	})
}

// DirectoryList: `GtkDirectoryList` is a list model that wraps
// g_file_enumerate_children_async().
//
// It presents a `GListModel` and fills it asynchronously with the `GFileInfo`s
// returned from that function.
//
// Enumeration will start automatically when a the
// [property@Gtk.DirectoryList:file] property is set.
//
// While the `GtkDirectoryList` is being filled, the
// [property@Gtk.DirectoryList:loading] property will be set to true. You can
// listen to that property if you want to show information like a `GtkSpinner`
// or a "Loading..." text.
//
// If loading fails at any point, the [property@Gtk.DirectoryList:error]
// property will be set to give more indication about the failure.
//
// The `GFileInfo`s returned from a `GtkDirectoryList` have the "standard::file"
// attribute set to the `GFile` they refer to. This way you can get at the file
// that is referred to in the same way you would via
// g_file_enumerator_get_child(). This means you do not need access to the
// `GtkDirectoryList`, but can access the `GFile` directly from the `GFileInfo`
// when operating with a `GtkListView` or similar.
type DirectoryList interface {
	gextras.Objector

	// Attributes gets the attributes queried on the children.
	Attributes() string
	// Error gets the loading error, if any.
	//
	// If an error occurs during the loading process, the loading process will
	// finish and this property allows querying the error that happened. This
	// error will persist until a file is loaded again.
	//
	// An error being set does not mean that no files were loaded, and all
	// successfully queried files will remain in the list.
	Error() error
	// IOPriority gets the IO priority set via
	// gtk_directory_list_set_io_priority().
	IOPriority() int
	// Monitored returns whether the directory list is monitoring the directory
	// for changes.
	Monitored() bool
	// IsLoading returns true if the children enumeration is currently in
	// progress.
	//
	// Files will be added to @self from time to time while loading is going on.
	// The order in which are added is undefined and may change in between runs.
	IsLoading() bool
	// SetAttributes sets the @attributes to be enumerated and starts the
	// enumeration.
	//
	// If @attributes is nil, no attributes will be queried, but a list of
	// `GFileInfo`s will still be created.
	SetAttributes(attributes string)
	// SetIOPriority sets the IO priority to use while loading directories.
	//
	// Setting the priority while @self is loading will reprioritize the ongoing
	// load as soon as possible.
	//
	// The default IO priority is G_PRIORITY_DEFAULT, which is higher than the
	// GTK redraw priority. If you are loading a lot of directories in parallel,
	// lowering it to something like G_PRIORITY_DEFAULT_IDLE may increase
	// responsiveness.
	SetIOPriority(ioPriority int)
	// SetMonitored sets whether the directory list will monitor the directory
	// for changes. If monitoring is enabled, the ::items-changed signal will be
	// emitted when the directory contents change.
	//
	// When monitoring is turned on after the initial creation of the directory
	// list, the directory is reloaded to avoid missing files that appeared
	// between the initial loading and when monitoring was turned on.
	SetMonitored(monitored bool)
}

// DirectoryListClass implements the DirectoryList interface.
type DirectoryListClass struct {
	*externglib.Object
}

var _ DirectoryList = (*DirectoryListClass)(nil)

func wrapDirectoryList(obj *externglib.Object) DirectoryList {
	return &DirectoryListClass{
		Object: obj,
	}
}

func marshalDirectoryList(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapDirectoryList(obj), nil
}

// Attributes gets the attributes queried on the children.
func (s *DirectoryListClass) Attributes() string {
	var _arg0 *C.GtkDirectoryList // out
	var _cret *C.char             // in

	_arg0 = (*C.GtkDirectoryList)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_directory_list_get_attributes(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Error gets the loading error, if any.
//
// If an error occurs during the loading process, the loading process will
// finish and this property allows querying the error that happened. This error
// will persist until a file is loaded again.
//
// An error being set does not mean that no files were loaded, and all
// successfully queried files will remain in the list.
func (s *DirectoryListClass) Error() error {
	var _arg0 *C.GtkDirectoryList // out
	var _cret *C.GError           // in

	_arg0 = (*C.GtkDirectoryList)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_directory_list_get_error(_arg0)

	var _err error // out

	_err = gerror.Take(unsafe.Pointer(_cret))

	return _err
}

// IOPriority gets the IO priority set via gtk_directory_list_set_io_priority().
func (s *DirectoryListClass) IOPriority() int {
	var _arg0 *C.GtkDirectoryList // out
	var _cret C.int               // in

	_arg0 = (*C.GtkDirectoryList)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_directory_list_get_io_priority(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Monitored returns whether the directory list is monitoring the directory for
// changes.
func (s *DirectoryListClass) Monitored() bool {
	var _arg0 *C.GtkDirectoryList // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkDirectoryList)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_directory_list_get_monitored(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsLoading returns true if the children enumeration is currently in progress.
//
// Files will be added to @self from time to time while loading is going on. The
// order in which are added is undefined and may change in between runs.
func (s *DirectoryListClass) IsLoading() bool {
	var _arg0 *C.GtkDirectoryList // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkDirectoryList)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_directory_list_is_loading(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetAttributes sets the @attributes to be enumerated and starts the
// enumeration.
//
// If @attributes is nil, no attributes will be queried, but a list of
// `GFileInfo`s will still be created.
func (s *DirectoryListClass) SetAttributes(attributes string) {
	var _arg0 *C.GtkDirectoryList // out
	var _arg1 *C.char             // out

	_arg0 = (*C.GtkDirectoryList)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(attributes))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_directory_list_set_attributes(_arg0, _arg1)
}

// SetIOPriority sets the IO priority to use while loading directories.
//
// Setting the priority while @self is loading will reprioritize the ongoing
// load as soon as possible.
//
// The default IO priority is G_PRIORITY_DEFAULT, which is higher than the GTK
// redraw priority. If you are loading a lot of directories in parallel,
// lowering it to something like G_PRIORITY_DEFAULT_IDLE may increase
// responsiveness.
func (s *DirectoryListClass) SetIOPriority(ioPriority int) {
	var _arg0 *C.GtkDirectoryList // out
	var _arg1 C.int               // out

	_arg0 = (*C.GtkDirectoryList)(unsafe.Pointer(s.Native()))
	_arg1 = C.int(ioPriority)

	C.gtk_directory_list_set_io_priority(_arg0, _arg1)
}

// SetMonitored sets whether the directory list will monitor the directory for
// changes. If monitoring is enabled, the ::items-changed signal will be emitted
// when the directory contents change.
//
// When monitoring is turned on after the initial creation of the directory
// list, the directory is reloaded to avoid missing files that appeared between
// the initial loading and when monitoring was turned on.
func (s *DirectoryListClass) SetMonitored(monitored bool) {
	var _arg0 *C.GtkDirectoryList // out
	var _arg1 C.gboolean          // out

	_arg0 = (*C.GtkDirectoryList)(unsafe.Pointer(s.Native()))
	if monitored {
		_arg1 = C.TRUE
	}

	C.gtk_directory_list_set_monitored(_arg0, _arg1)
}
