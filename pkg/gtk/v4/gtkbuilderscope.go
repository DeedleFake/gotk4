// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"unsafe"

	"github.com/diamondburned/gotk4/internal/gextras"
	"github.com/diamondburned/gotk4/pkg/gobject/v2"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config:
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <gtk/gtk.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_builder_scope_get_type()), F: marshalBuilderScope},
		{T: externglib.Type(C.gtk_builder_cscope_get_type()), F: marshalBuilderCScope},
	})
}

// BuilderScopeOverrider contains methods that are overridable. This
// interface is a subset of the interface BuilderScope.
type BuilderScopeOverrider interface {
	TypeFromFunction(builder Builder, functionName string) externglib.Type

	TypeFromName(builder Builder, typeName string) externglib.Type
}

// BuilderScope is an interface to provide support to Builder, primarily for
// looking up programming-language-specific values for strings that are given in
// a Builder UI file.
//
// The primary intended audience is bindings that want to provide deeper
// integration of Builder into the language.
//
// A BuilderScope instance may be used with multiple Builder objects, even at
// once.
//
// By default, GTK will use its own implementation of BuilderScope for the C
// language which can be created via gtk_builder_cscope_new().
//
// BuilderCScope instances use symbols explicitly added to @builder with prior
// calls to gtk_builder_cscope_add_callback_symbol(). If developers want to do
// that, they are encouraged to create their own scopes for that purpose.
//
// In the case that symbols are not explicitly added; GTK will uses #GModule’s
// introspective features (by opening the module nil) to look at the
// application’s symbol table. From here it tries to match the signal function
// names given in the interface description with symbols in the application.
//
// Note that unless gtk_builder_cscope_add_callback_symbol() is called for all
// signal callbacks which are referenced by the loaded XML, this functionality
// will require that #GModule be supported on the platform.
type BuilderScope interface {
	gextras.Objector
	BuilderScopeOverrider
}

// builderScope implements the BuilderScope interface.
type builderScope struct {
	gextras.Objector
}

var _ BuilderScope = (*builderScope)(nil)

// WrapBuilderScope wraps a GObject to a type that implements interface
// BuilderScope. It is primarily used internally.
func WrapBuilderScope(obj *externglib.Object) BuilderScope {
	return BuilderScope{
		Objector: obj,
	}
}

func marshalBuilderScope(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapBuilderScope(obj), nil
}

type BuilderCScope interface {
	gextras.Objector
	BuilderScope
}

// builderCScope implements the BuilderCScope interface.
type builderCScope struct {
	gextras.Objector
	BuilderScope
}

var _ BuilderCScope = (*builderCScope)(nil)

// WrapBuilderCScope wraps a GObject to the right type. It is
// primarily used internally.
func WrapBuilderCScope(obj *externglib.Object) BuilderCScope {
	return BuilderCScope{
		Objector:     obj,
		BuilderScope: WrapBuilderScope(obj),
	}
}

func marshalBuilderCScope(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapBuilderCScope(obj), nil
}

// NewBuilderCScope constructs a class BuilderCScope.
func NewBuilderCScope() BuilderCScope {
	var cret C.GtkBuilderCScope
	var goret1 BuilderCScope

	cret = C.gtk_builder_cscope_new()

	goret1 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(BuilderCScope)

	return goret1
}
