// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"unsafe"

	"github.com/diamondburned/gotk4/internal/gextras"
	"github.com/diamondburned/gotk4/internal/ptr"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config:
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <gtk/gtk.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_application_get_type()), F: marshalApplication},
	})
}

// Application: `GtkApplication` is a high-level API for writing applications.
//
// It supports many aspects of writing a GTK application in a convenient
// fashion, without enforcing a one-size-fits-all model.
//
// Currently, `GtkApplication` handles GTK initialization, application
// uniqueness, session management, provides some basic scriptability and desktop
// shell integration by exporting actions and menus and manages a list of
// toplevel windows whose life-cycle is automatically tied to the life-cycle of
// your application.
//
// While `GtkApplication` works fine with plain [class@Gtk.Window]s, it is
// recommended to use it together with [class@Gtk.ApplicationWindow].
//
//
// Automatic resources
//
// `GtkApplication` will automatically load menus from the `GtkBuilder` resource
// located at "gtk/menus.ui", relative to the application's resource base path
// (see `g_application_set_resource_base_path()`). The menu with the ID
// "menubar" is taken as the application's menubar. Additional menus (most
// interesting submenus) can be named and accessed via
// [method@Gtk.Application.get_menu_by_id] which allows for dynamic population
// of a part of the menu structure.
//
// It is also possible to provide the menubar manually using
// [method@Gtk.Application.set_menubar].
//
// `GtkApplication` will also automatically setup an icon search path for the
// default icon theme by appending "icons" to the resource base path. This
// allows your application to easily store its icons as resources. See
// [method@Gtk.IconTheme.add_resource_path] for more information.
//
// If there is a resource located at "gtk/help-overlay.ui" which defines a
// [class@Gtk.ShortcutsWindow] with ID "help_overlay" then `GtkApplication`
// associates an instance of this shortcuts window with each
// [class@Gtk.ApplicationWindow] and sets up the keyboard accelerator
// <kbd>Control</kbd>+<kbd>?</kbd> to open it. To create a menu item that
// displays the shortcuts window, associate the item with the action
// `win.show-help-overlay`.
//
//
// A simple application
//
// A simple example
// (https://gitlab.gnome.org/GNOME/gtk/tree/master/examples/bp/bloatpad.c) is
// available in the GTK source code repository
//
// `GtkApplication` optionally registers with a session manager of the users
// session (if you set the [property@Gtk.Application:register-session] property)
// and offers various functionality related to the session life-cycle.
//
// An application can block various ways to end the session with the
// [method@Gtk.Application.inhibit] function. Typical use cases for this kind of
// inhibiting are long-running, uninterruptible operations, such as burning a CD
// or performing a disk backup. The session manager may not honor the inhibitor,
// but it can be expected to inform the user about the negative consequences of
// ending the session while inhibitors are present.
//
//
// See Also
//
// HowDoI: Using GtkApplication (https://wiki.gnome.org/HowDoI/GtkApplication),
// Getting Started with GTK: Basics (getting_started.html#basics)
type Application interface {
	gio.Application
	gio.ActionGroup
	gio.ActionMap

	// AddWindow adds a window to `application`.
	//
	// This call can only happen after the `application` has started; typically,
	// you should add new application windows in response to the emission of the
	// `GApplication::activate` signal.
	//
	// This call is equivalent to setting the [property@Gtk.Window:application]
	// property of `window` to `application`.
	//
	// Normally, the connection between the application and the window will
	// remain until the window is destroyed, but you can explicitly remove it
	// with [method@Gtk.Application.remove_window].
	//
	// GTK will keep the `application` running as long as it has any windows.
	AddWindow(window Window)
	// AccelsForAction gets the accelerators that are currently associated with
	// the given action.
	AccelsForAction(detailedActionName string) []string
	// ActionsForAccel returns the list of actions (possibly empty) that `accel`
	// maps to.
	//
	// Each item in the list is a detailed action name in the usual form.
	//
	// This might be useful to discover if an accel already exists in order to
	// prevent installation of a conflicting accelerator (from an accelerator
	// editor or a plugin system, for example). Note that having more than one
	// action per accelerator may not be a bad thing and might make sense in
	// cases where the actions never appear in the same context.
	//
	// In case there are no actions for a given accelerator, an empty array is
	// returned. `NULL` is never returned.
	//
	// It is a programmer error to pass an invalid accelerator string.
	//
	// If you are unsure, check it with [func@Gtk.accelerator_parse] first.
	ActionsForAccel(accel string) []string
	// ActiveWindow gets the “active” window for the application.
	//
	// The active window is the one that was most recently focused (within the
	// application). This window may not have the focus at the moment if another
	// application has it — this is just the most recently-focused window within
	// this application.
	ActiveWindow() Window
	// MenuByID gets a menu from automatically loaded resources.
	//
	// See the section on Automatic resources
	// (class.Application.html#automatic-resources) for more information.
	MenuByID(iD string) gio.Menu
	// Menubar returns the menu model that has been set with
	// [method@Gtk.Application.set_menubar].
	Menubar() gio.MenuModel
	// WindowByID returns the [class@Gtk.ApplicationWindow] with the given ID.
	//
	// The ID of a `GtkApplicationWindow` can be retrieved with
	// [method@Gtk.ApplicationWindow.get_id].
	WindowByID(iD uint) Window
	// Windows gets a list of the [class@Gtk.Window] instances associated with
	// `application`.
	//
	// The list is sorted by most recently focused window, such that the first
	// element is the currently focused window. (Useful for choosing a parent
	// for a transient window.)
	//
	// The list that is returned should not be modified in any way. It will only
	// remain valid until the next focus change or window creation or deletion.
	Windows() *glib.List
	// Inhibit: inform the session manager that certain types of actions should
	// be inhibited.
	//
	// This is not guaranteed to work on all platforms and for all types of
	// actions.
	//
	// Applications should invoke this method when they begin an operation that
	// should not be interrupted, such as creating a CD or DVD. The types of
	// actions that may be blocked are specified by the `flags` parameter. When
	// the application completes the operation it should call
	// [method@Gtk.Application.uninhibit] to remove the inhibitor. Note that an
	// application can have multiple inhibitors, and all of them must be
	// individually removed. Inhibitors are also cleared when the application
	// exits.
	//
	// Applications should not expect that they will always be able to block the
	// action. In most cases, users will be given the option to force the action
	// to take place.
	//
	// The `reason` message should be short and to the point.
	//
	// If `window` is given, the session manager may point the user to this
	// window to find out more about why the action is inhibited.
	Inhibit(window Window, flags ApplicationInhibitFlags, reason string) uint
	// ListActionDescriptions lists the detailed action names which have
	// associated accelerators.
	//
	// See [method@Gtk.Application.set_accels_for_action].
	ListActionDescriptions() []string
	// RemoveWindow: remove a window from `application`.
	//
	// If `window` belongs to `application` then this call is equivalent to
	// setting the [property@Gtk.Window:application] property of `window` to
	// `NULL`.
	//
	// The application may stop running as a result of a call to this function,
	// if `window` was the last window of the `application`.
	RemoveWindow(window Window)
	// SetAccelsForAction sets zero or more keyboard accelerators that will
	// trigger the given action.
	//
	// The first item in `accels` will be the primary accelerator, which may be
	// displayed in the UI.
	//
	// To remove all accelerators for an action, use an empty, zero-terminated
	// array for `accels`.
	//
	// For the `detailed_action_name`, see `g_action_parse_detailed_name()` and
	// `g_action_print_detailed_name()`.
	SetAccelsForAction(detailedActionName string, accels []string)
	// SetMenubar sets or unsets the menubar for windows of `application`.
	//
	// This is a menubar in the traditional sense.
	//
	// This can only be done in the primary instance of the application, after
	// it has been registered. `GApplication::startup` is a good place to call
	// this.
	//
	// Depending on the desktop environment, this may appear at the top of each
	// window, or at the top of the screen. In some environments, if both the
	// application menu and the menubar are set, the application menu will be
	// presented as if it were the first item of the menubar. Other environments
	// treat the two as completely separate — for example, the application menu
	// may be rendered by the desktop shell while the menubar (if set) remains
	// in each individual window.
	//
	// Use the base `GActionMap` interface to add actions, to respond to the
	// user selecting these menu items.
	SetMenubar(menubar gio.MenuModel)
	// Uninhibit removes an inhibitor that has been previously established.
	//
	// See [method@Gtk.Application.inhibit].
	//
	// Inhibitors are also cleared when the application exits.
	Uninhibit(cookie uint)
}

// application implements the Application interface.
type application struct {
	gio.Application
	gio.ActionGroup
	gio.ActionMap
}

var _ Application = (*application)(nil)

// WrapApplication wraps a GObject to the right type. It is
// primarily used internally.
func WrapApplication(obj *externglib.Object) Application {
	return Application{
		gio.Application: gio.WrapApplication(obj),
		gio.ActionGroup: gio.WrapActionGroup(obj),
		gio.ActionMap:   gio.WrapActionMap(obj),
	}
}

func marshalApplication(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapApplication(obj), nil
}

// NewApplication constructs a class Application.
func NewApplication(applicationID string, flags gio.ApplicationFlags) Application {
	var arg1 *C.char
	var arg2 C.GApplicationFlags

	arg1 = (*C.char)(C.CString(applicationID))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (C.GApplicationFlags)(flags)

	cret := new(C.GtkApplication)
	var goret Application

	cret = C.gtk_application_new(arg1, arg2)

	goret = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(Application)

	return goret
}

// AddWindow adds a window to `application`.
//
// This call can only happen after the `application` has started; typically,
// you should add new application windows in response to the emission of the
// `GApplication::activate` signal.
//
// This call is equivalent to setting the [property@Gtk.Window:application]
// property of `window` to `application`.
//
// Normally, the connection between the application and the window will
// remain until the window is destroyed, but you can explicitly remove it
// with [method@Gtk.Application.remove_window].
//
// GTK will keep the `application` running as long as it has any windows.
func (a application) AddWindow(window Window) {
	var arg0 *C.GtkApplication
	var arg1 *C.GtkWindow

	arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))
	arg1 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	C.gtk_application_add_window(arg0, arg1)
}

// AccelsForAction gets the accelerators that are currently associated with
// the given action.
func (a application) AccelsForAction(detailedActionName string) []string {
	var arg0 *C.GtkApplication
	var arg1 *C.char

	arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))
	arg1 = (*C.char)(C.CString(detailedActionName))
	defer C.free(unsafe.Pointer(arg1))

	var cret **C.char
	var goret []string

	cret = C.gtk_application_get_accels_for_action(arg0, arg1)

	{
		var length int
		for p := cret; *p != 0; p = (**C.char)(ptr.Add(unsafe.Pointer(p), unsafe.Sizeof(int(0)))) {
			length++
			if length < 0 {
				panic(`length overflow`)
			}
		}

		goret = make([]string, length)
		for i := uintptr(0); i < uintptr(length); i += unsafe.Sizeof(int(0)) {
			src := (*C.gchar)(ptr.Add(unsafe.Pointer(cret), i))
			goret[i] = C.GoString(src)
			defer C.free(unsafe.Pointer(src))
		}
	}

	return goret
}

// ActionsForAccel returns the list of actions (possibly empty) that `accel`
// maps to.
//
// Each item in the list is a detailed action name in the usual form.
//
// This might be useful to discover if an accel already exists in order to
// prevent installation of a conflicting accelerator (from an accelerator
// editor or a plugin system, for example). Note that having more than one
// action per accelerator may not be a bad thing and might make sense in
// cases where the actions never appear in the same context.
//
// In case there are no actions for a given accelerator, an empty array is
// returned. `NULL` is never returned.
//
// It is a programmer error to pass an invalid accelerator string.
//
// If you are unsure, check it with [func@Gtk.accelerator_parse] first.
func (a application) ActionsForAccel(accel string) []string {
	var arg0 *C.GtkApplication
	var arg1 *C.char

	arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))
	arg1 = (*C.char)(C.CString(accel))
	defer C.free(unsafe.Pointer(arg1))

	var cret **C.char
	var goret []string

	cret = C.gtk_application_get_actions_for_accel(arg0, arg1)

	{
		var length int
		for p := cret; *p != 0; p = (**C.char)(ptr.Add(unsafe.Pointer(p), unsafe.Sizeof(int(0)))) {
			length++
			if length < 0 {
				panic(`length overflow`)
			}
		}

		goret = make([]string, length)
		for i := uintptr(0); i < uintptr(length); i += unsafe.Sizeof(int(0)) {
			src := (*C.gchar)(ptr.Add(unsafe.Pointer(cret), i))
			goret[i] = C.GoString(src)
			defer C.free(unsafe.Pointer(src))
		}
	}

	return goret
}

// ActiveWindow gets the “active” window for the application.
//
// The active window is the one that was most recently focused (within the
// application). This window may not have the focus at the moment if another
// application has it — this is just the most recently-focused window within
// this application.
func (a application) ActiveWindow() Window {
	var arg0 *C.GtkApplication

	arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))

	var cret *C.GtkWindow
	var goret Window

	cret = C.gtk_application_get_active_window(arg0)

	goret = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Window)

	return goret
}

// MenuByID gets a menu from automatically loaded resources.
//
// See the section on Automatic resources
// (class.Application.html#automatic-resources) for more information.
func (a application) MenuByID(iD string) gio.Menu {
	var arg0 *C.GtkApplication
	var arg1 *C.char

	arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))
	arg1 = (*C.char)(C.CString(iD))
	defer C.free(unsafe.Pointer(arg1))

	var cret *C.GMenu
	var goret gio.Menu

	cret = C.gtk_application_get_menu_by_id(arg0, arg1)

	goret = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(gio.Menu)

	return goret
}

// Menubar returns the menu model that has been set with
// [method@Gtk.Application.set_menubar].
func (a application) Menubar() gio.MenuModel {
	var arg0 *C.GtkApplication

	arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))

	var cret *C.GMenuModel
	var goret gio.MenuModel

	cret = C.gtk_application_get_menubar(arg0)

	goret = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(gio.MenuModel)

	return goret
}

// WindowByID returns the [class@Gtk.ApplicationWindow] with the given ID.
//
// The ID of a `GtkApplicationWindow` can be retrieved with
// [method@Gtk.ApplicationWindow.get_id].
func (a application) WindowByID(iD uint) Window {
	var arg0 *C.GtkApplication
	var arg1 C.guint

	arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))
	arg1 = C.guint(iD)

	var cret *C.GtkWindow
	var goret Window

	cret = C.gtk_application_get_window_by_id(arg0, arg1)

	goret = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Window)

	return goret
}

// Windows gets a list of the [class@Gtk.Window] instances associated with
// `application`.
//
// The list is sorted by most recently focused window, such that the first
// element is the currently focused window. (Useful for choosing a parent
// for a transient window.)
//
// The list that is returned should not be modified in any way. It will only
// remain valid until the next focus change or window creation or deletion.
func (a application) Windows() *glib.List {
	var arg0 *C.GtkApplication

	arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))

	var cret *C.GList
	var goret *glib.List

	cret = C.gtk_application_get_windows(arg0)

	goret = glib.WrapList(unsafe.Pointer(cret))

	return goret
}

// Inhibit: inform the session manager that certain types of actions should
// be inhibited.
//
// This is not guaranteed to work on all platforms and for all types of
// actions.
//
// Applications should invoke this method when they begin an operation that
// should not be interrupted, such as creating a CD or DVD. The types of
// actions that may be blocked are specified by the `flags` parameter. When
// the application completes the operation it should call
// [method@Gtk.Application.uninhibit] to remove the inhibitor. Note that an
// application can have multiple inhibitors, and all of them must be
// individually removed. Inhibitors are also cleared when the application
// exits.
//
// Applications should not expect that they will always be able to block the
// action. In most cases, users will be given the option to force the action
// to take place.
//
// The `reason` message should be short and to the point.
//
// If `window` is given, the session manager may point the user to this
// window to find out more about why the action is inhibited.
func (a application) Inhibit(window Window, flags ApplicationInhibitFlags, reason string) uint {
	var arg0 *C.GtkApplication
	var arg1 *C.GtkWindow
	var arg2 C.GtkApplicationInhibitFlags
	var arg3 *C.char

	arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))
	arg1 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	arg2 = (C.GtkApplicationInhibitFlags)(flags)
	arg3 = (*C.char)(C.CString(reason))
	defer C.free(unsafe.Pointer(arg3))

	var cret C.guint
	var goret uint

	cret = C.gtk_application_inhibit(arg0, arg1, arg2, arg3)

	goret = uint(cret)

	return goret
}

// ListActionDescriptions lists the detailed action names which have
// associated accelerators.
//
// See [method@Gtk.Application.set_accels_for_action].
func (a application) ListActionDescriptions() []string {
	var arg0 *C.GtkApplication

	arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))

	var cret **C.char
	var goret []string

	cret = C.gtk_application_list_action_descriptions(arg0)

	{
		var length int
		for p := cret; *p != 0; p = (**C.char)(ptr.Add(unsafe.Pointer(p), unsafe.Sizeof(int(0)))) {
			length++
			if length < 0 {
				panic(`length overflow`)
			}
		}

		goret = make([]string, length)
		for i := uintptr(0); i < uintptr(length); i += unsafe.Sizeof(int(0)) {
			src := (*C.gchar)(ptr.Add(unsafe.Pointer(cret), i))
			goret[i] = C.GoString(src)
			defer C.free(unsafe.Pointer(src))
		}
	}

	return goret
}

// RemoveWindow: remove a window from `application`.
//
// If `window` belongs to `application` then this call is equivalent to
// setting the [property@Gtk.Window:application] property of `window` to
// `NULL`.
//
// The application may stop running as a result of a call to this function,
// if `window` was the last window of the `application`.
func (a application) RemoveWindow(window Window) {
	var arg0 *C.GtkApplication
	var arg1 *C.GtkWindow

	arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))
	arg1 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	C.gtk_application_remove_window(arg0, arg1)
}

// SetAccelsForAction sets zero or more keyboard accelerators that will
// trigger the given action.
//
// The first item in `accels` will be the primary accelerator, which may be
// displayed in the UI.
//
// To remove all accelerators for an action, use an empty, zero-terminated
// array for `accels`.
//
// For the `detailed_action_name`, see `g_action_parse_detailed_name()` and
// `g_action_print_detailed_name()`.
func (a application) SetAccelsForAction(detailedActionName string, accels []string) {
	var arg0 *C.GtkApplication
	var arg1 *C.char
	var arg2 **C.char

	arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))
	arg1 = (*C.char)(C.CString(detailedActionName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (**C.char)(C.malloc((len(accels) + 1) * unsafe.Sizeof(int(0))))
	defer C.free(unsafe.Pointer(arg2))

	{
		var out []*C.char
		ptr.SetSlice(unsafe.Pointer(&dst), unsafe.Pointer(arg2), int(len(accels)))

		for i := range accels {
			out[i] = (*C.char)(C.CString(accels[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	C.gtk_application_set_accels_for_action(arg0, arg1, arg2)
}

// SetMenubar sets or unsets the menubar for windows of `application`.
//
// This is a menubar in the traditional sense.
//
// This can only be done in the primary instance of the application, after
// it has been registered. `GApplication::startup` is a good place to call
// this.
//
// Depending on the desktop environment, this may appear at the top of each
// window, or at the top of the screen. In some environments, if both the
// application menu and the menubar are set, the application menu will be
// presented as if it were the first item of the menubar. Other environments
// treat the two as completely separate — for example, the application menu
// may be rendered by the desktop shell while the menubar (if set) remains
// in each individual window.
//
// Use the base `GActionMap` interface to add actions, to respond to the
// user selecting these menu items.
func (a application) SetMenubar(menubar gio.MenuModel) {
	var arg0 *C.GtkApplication
	var arg1 *C.GMenuModel

	arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))
	arg1 = (*C.GMenuModel)(unsafe.Pointer(menubar.Native()))

	C.gtk_application_set_menubar(arg0, arg1)
}

// Uninhibit removes an inhibitor that has been previously established.
//
// See [method@Gtk.Application.inhibit].
//
// Inhibitors are also cleared when the application exits.
func (a application) Uninhibit(cookie uint) {
	var arg0 *C.GtkApplication
	var arg1 C.guint

	arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))
	arg1 = C.guint(cookie)

	C.gtk_application_uninhibit(arg0, arg1)
}
