// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"unsafe"

	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config:
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <gtk/gtk.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_bitset_get_type()), F: marshalBitset},
	})
}

// Bitset: a `GtkBitset` represents a set of unsigned integers.
//
// Another name for this data structure is "bitmap".
//
// The current implementation is based on roaring bitmaps
// (https://roaringbitmap.org/).
//
// A bitset allows adding a set of integers and provides support for set
// operations like unions, intersections and checks for equality or if a value
// is contained in the set. `GtkBitset` also contains various functions to query
// metadata about the bitset, such as the minimum or maximum values or its size.
//
// The fastest way to iterate values in a bitset is [struct@Gtk.BitsetIter].
//
// The main use case for `GtkBitset` is implementing complex selections for
// [iface@Gtk.SelectionModel].
type Bitset struct {
	native C.GtkBitset
}

// WrapBitset wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapBitset(ptr unsafe.Pointer) *Bitset {
	if ptr == nil {
		return nil
	}

	return (*Bitset)(ptr)
}

func marshalBitset(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapBitset(unsafe.Pointer(b)), nil
}

// NewBitsetEmpty constructs a struct Bitset.
func NewBitsetEmpty() *Bitset {
	cret := new(C.GtkBitset)
	var goret *Bitset

	cret = C.gtk_bitset_new_empty()

	goret = WrapBitset(unsafe.Pointer(cret))
	runtime.SetFinalizer(goret, func(v *Bitset) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return goret
}

// NewBitsetRange constructs a struct Bitset.
func NewBitsetRange(start uint, nItems uint) *Bitset {
	var arg1 C.guint
	var arg2 C.guint

	arg1 = C.guint(start)
	arg2 = C.guint(nItems)

	cret := new(C.GtkBitset)
	var goret *Bitset

	cret = C.gtk_bitset_new_range(arg1, arg2)

	goret = WrapBitset(unsafe.Pointer(cret))
	runtime.SetFinalizer(goret, func(v *Bitset) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return goret
}

// Native returns the underlying C source pointer.
func (b *Bitset) Native() unsafe.Pointer {
	return unsafe.Pointer(&b.native)
}

// Add adds @value to @self if it wasn't part of it before.
func (s *Bitset) Add(value uint) bool {
	var arg0 *C.GtkBitset
	var arg1 C.guint

	arg0 = (*C.GtkBitset)(unsafe.Pointer(s.Native()))
	arg1 = C.guint(value)

	var cret C.gboolean
	var goret bool

	cret = C.gtk_bitset_add(arg0, arg1)

	if cret {
		goret = true
	}

	return goret
}

// AddRange adds all values from @start (inclusive) to @start + @n_items
// (exclusive) in @self.
func (s *Bitset) AddRange(start uint, nItems uint) {
	var arg0 *C.GtkBitset
	var arg1 C.guint
	var arg2 C.guint

	arg0 = (*C.GtkBitset)(unsafe.Pointer(s.Native()))
	arg1 = C.guint(start)
	arg2 = C.guint(nItems)

	C.gtk_bitset_add_range(arg0, arg1, arg2)
}

// AddRangeClosed adds the closed range [@first, @last], so @first, @last and
// all values in between. @first must be smaller than @last.
func (s *Bitset) AddRangeClosed(first uint, last uint) {
	var arg0 *C.GtkBitset
	var arg1 C.guint
	var arg2 C.guint

	arg0 = (*C.GtkBitset)(unsafe.Pointer(s.Native()))
	arg1 = C.guint(first)
	arg2 = C.guint(last)

	C.gtk_bitset_add_range_closed(arg0, arg1, arg2)
}

// AddRectangle interprets the values as a 2-dimensional boolean grid with the
// given @stride and inside that grid, adds a rectangle with the given @width
// and @height.
func (s *Bitset) AddRectangle(start uint, width uint, height uint, stride uint) {
	var arg0 *C.GtkBitset
	var arg1 C.guint
	var arg2 C.guint
	var arg3 C.guint
	var arg4 C.guint

	arg0 = (*C.GtkBitset)(unsafe.Pointer(s.Native()))
	arg1 = C.guint(start)
	arg2 = C.guint(width)
	arg3 = C.guint(height)
	arg4 = C.guint(stride)

	C.gtk_bitset_add_rectangle(arg0, arg1, arg2, arg3, arg4)
}

// Contains checks if the given @value has been added to @self
func (s *Bitset) Contains(value uint) bool {
	var arg0 *C.GtkBitset
	var arg1 C.guint

	arg0 = (*C.GtkBitset)(unsafe.Pointer(s.Native()))
	arg1 = C.guint(value)

	var cret C.gboolean
	var goret bool

	cret = C.gtk_bitset_contains(arg0, arg1)

	if cret {
		goret = true
	}

	return goret
}

// Copy creates a copy of @self.
func (s *Bitset) Copy() *Bitset {
	var arg0 *C.GtkBitset

	arg0 = (*C.GtkBitset)(unsafe.Pointer(s.Native()))

	cret := new(C.GtkBitset)
	var goret *Bitset

	cret = C.gtk_bitset_copy(arg0)

	goret = WrapBitset(unsafe.Pointer(cret))
	runtime.SetFinalizer(goret, func(v *Bitset) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return goret
}

// Difference sets @self to be the symmetric difference of @self and @other.
//
// The symmetric difference is set @self to contain all values that were either
// contained in @self or in @other, but not in both. This operation is also
// called an XOR.
//
// It is allowed for @self and @other to be the same bitset. The bitset will be
// emptied in that case.
func (s *Bitset) Difference(other *Bitset) {
	var arg0 *C.GtkBitset
	var arg1 *C.GtkBitset

	arg0 = (*C.GtkBitset)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GtkBitset)(unsafe.Pointer(other.Native()))

	C.gtk_bitset_difference(arg0, arg1)
}

// Equals returns true if @self and @other contain the same values.
func (s *Bitset) Equals(other *Bitset) bool {
	var arg0 *C.GtkBitset
	var arg1 *C.GtkBitset

	arg0 = (*C.GtkBitset)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GtkBitset)(unsafe.Pointer(other.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.gtk_bitset_equals(arg0, arg1)

	if cret {
		goret = true
	}

	return goret
}

// Maximum returns the largest value in @self.
//
// If @self is empty, 0 is returned.
func (s *Bitset) Maximum() uint {
	var arg0 *C.GtkBitset

	arg0 = (*C.GtkBitset)(unsafe.Pointer(s.Native()))

	var cret C.guint
	var goret uint

	cret = C.gtk_bitset_get_maximum(arg0)

	goret = uint(cret)

	return goret
}

// Minimum returns the smallest value in @self.
//
// If @self is empty, `G_MAXUINT` is returned.
func (s *Bitset) Minimum() uint {
	var arg0 *C.GtkBitset

	arg0 = (*C.GtkBitset)(unsafe.Pointer(s.Native()))

	var cret C.guint
	var goret uint

	cret = C.gtk_bitset_get_minimum(arg0)

	goret = uint(cret)

	return goret
}

// Nth returns the value of the @nth item in self.
//
// If @nth is >= the size of @self, 0 is returned.
func (s *Bitset) Nth(nth uint) uint {
	var arg0 *C.GtkBitset
	var arg1 C.guint

	arg0 = (*C.GtkBitset)(unsafe.Pointer(s.Native()))
	arg1 = C.guint(nth)

	var cret C.guint
	var goret uint

	cret = C.gtk_bitset_get_nth(arg0, arg1)

	goret = uint(cret)

	return goret
}

// Size gets the number of values that were added to the set.
//
// For example, if the set is empty, 0 is returned.
//
// Note that this function returns a `guint64`, because when all values are set,
// the return value is `G_MAXUINT + 1`. Unless you are sure this cannot happen
// (it can't with `GListModel`), be sure to use a 64bit type.
func (s *Bitset) Size() uint64 {
	var arg0 *C.GtkBitset

	arg0 = (*C.GtkBitset)(unsafe.Pointer(s.Native()))

	var cret C.guint64
	var goret uint64

	cret = C.gtk_bitset_get_size(arg0)

	goret = uint64(cret)

	return goret
}

// SizeInRange gets the number of values that are part of the set from @first to
// @last (inclusive).
//
// Note that this function returns a `guint64`, because when all values are set,
// the return value is `G_MAXUINT + 1`. Unless you are sure this cannot happen
// (it can't with `GListModel`), be sure to use a 64bit type.
func (s *Bitset) SizeInRange(first uint, last uint) uint64 {
	var arg0 *C.GtkBitset
	var arg1 C.guint
	var arg2 C.guint

	arg0 = (*C.GtkBitset)(unsafe.Pointer(s.Native()))
	arg1 = C.guint(first)
	arg2 = C.guint(last)

	var cret C.guint64
	var goret uint64

	cret = C.gtk_bitset_get_size_in_range(arg0, arg1, arg2)

	goret = uint64(cret)

	return goret
}

// Intersect sets @self to be the intersection of @self and @other.
//
// In other words, remove all values from @self that are not part of @other.
//
// It is allowed for @self and @other to be the same bitset. Nothing will happen
// in that case.
func (s *Bitset) Intersect(other *Bitset) {
	var arg0 *C.GtkBitset
	var arg1 *C.GtkBitset

	arg0 = (*C.GtkBitset)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GtkBitset)(unsafe.Pointer(other.Native()))

	C.gtk_bitset_intersect(arg0, arg1)
}

// IsEmpty: check if no value is contained in bitset.
func (s *Bitset) IsEmpty() bool {
	var arg0 *C.GtkBitset

	arg0 = (*C.GtkBitset)(unsafe.Pointer(s.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.gtk_bitset_is_empty(arg0)

	if cret {
		goret = true
	}

	return goret
}

// Ref acquires a reference on the given `GtkBitset`.
func (s *Bitset) Ref() *Bitset {
	var arg0 *C.GtkBitset

	arg0 = (*C.GtkBitset)(unsafe.Pointer(s.Native()))

	var cret *C.GtkBitset
	var goret *Bitset

	cret = C.gtk_bitset_ref(arg0)

	goret = WrapBitset(unsafe.Pointer(cret))

	return goret
}

// Remove removes @value from @self if it was part of it before.
func (s *Bitset) Remove(value uint) bool {
	var arg0 *C.GtkBitset
	var arg1 C.guint

	arg0 = (*C.GtkBitset)(unsafe.Pointer(s.Native()))
	arg1 = C.guint(value)

	var cret C.gboolean
	var goret bool

	cret = C.gtk_bitset_remove(arg0, arg1)

	if cret {
		goret = true
	}

	return goret
}

// RemoveAll removes all values from the bitset so that it is empty again.
func (s *Bitset) RemoveAll() {
	var arg0 *C.GtkBitset

	arg0 = (*C.GtkBitset)(unsafe.Pointer(s.Native()))

	C.gtk_bitset_remove_all(arg0)
}

// RemoveRange removes all values from @start (inclusive) to @start + @n_items
// (exclusive) in @self.
func (s *Bitset) RemoveRange(start uint, nItems uint) {
	var arg0 *C.GtkBitset
	var arg1 C.guint
	var arg2 C.guint

	arg0 = (*C.GtkBitset)(unsafe.Pointer(s.Native()))
	arg1 = C.guint(start)
	arg2 = C.guint(nItems)

	C.gtk_bitset_remove_range(arg0, arg1, arg2)
}

// RemoveRangeClosed removes the closed range [@first, @last], so @first, @last
// and all values in between. @first must be smaller than @last.
func (s *Bitset) RemoveRangeClosed(first uint, last uint) {
	var arg0 *C.GtkBitset
	var arg1 C.guint
	var arg2 C.guint

	arg0 = (*C.GtkBitset)(unsafe.Pointer(s.Native()))
	arg1 = C.guint(first)
	arg2 = C.guint(last)

	C.gtk_bitset_remove_range_closed(arg0, arg1, arg2)
}

// RemoveRectangle interprets the values as a 2-dimensional boolean grid with
// the given @stride and inside that grid, removes a rectangle with the given
// @width and @height.
func (s *Bitset) RemoveRectangle(start uint, width uint, height uint, stride uint) {
	var arg0 *C.GtkBitset
	var arg1 C.guint
	var arg2 C.guint
	var arg3 C.guint
	var arg4 C.guint

	arg0 = (*C.GtkBitset)(unsafe.Pointer(s.Native()))
	arg1 = C.guint(start)
	arg2 = C.guint(width)
	arg3 = C.guint(height)
	arg4 = C.guint(stride)

	C.gtk_bitset_remove_rectangle(arg0, arg1, arg2, arg3, arg4)
}

// ShiftLeft shifts all values in @self to the left by @amount.
//
// Values smaller than @amount are discarded.
func (s *Bitset) ShiftLeft(amount uint) {
	var arg0 *C.GtkBitset
	var arg1 C.guint

	arg0 = (*C.GtkBitset)(unsafe.Pointer(s.Native()))
	arg1 = C.guint(amount)

	C.gtk_bitset_shift_left(arg0, arg1)
}

// ShiftRight shifts all values in @self to the right by @amount.
//
// Values that end up too large to be held in a #guint are discarded.
func (s *Bitset) ShiftRight(amount uint) {
	var arg0 *C.GtkBitset
	var arg1 C.guint

	arg0 = (*C.GtkBitset)(unsafe.Pointer(s.Native()))
	arg1 = C.guint(amount)

	C.gtk_bitset_shift_right(arg0, arg1)
}

// Splice: this is a support function for `GListModel` handling, by mirroring
// the `GlistModel::items-changed` signal.
//
// First, it "cuts" the values from @position to @removed from the bitset. That
// is, it removes all those values and shifts all larger values to the left by
// @removed places.
//
// Then, it "pastes" new room into the bitset by shifting all values larger than
// @position by @added spaces to the right. This frees up space that can then be
// filled.
func (s *Bitset) Splice(position uint, removed uint, added uint) {
	var arg0 *C.GtkBitset
	var arg1 C.guint
	var arg2 C.guint
	var arg3 C.guint

	arg0 = (*C.GtkBitset)(unsafe.Pointer(s.Native()))
	arg1 = C.guint(position)
	arg2 = C.guint(removed)
	arg3 = C.guint(added)

	C.gtk_bitset_splice(arg0, arg1, arg2, arg3)
}

// Subtract sets @self to be the subtraction of @other from @self.
//
// In other words, remove all values from @self that are part of @other.
//
// It is allowed for @self and @other to be the same bitset. The bitset will be
// emptied in that case.
func (s *Bitset) Subtract(other *Bitset) {
	var arg0 *C.GtkBitset
	var arg1 *C.GtkBitset

	arg0 = (*C.GtkBitset)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GtkBitset)(unsafe.Pointer(other.Native()))

	C.gtk_bitset_subtract(arg0, arg1)
}

// Union sets @self to be the union of @self and @other.
//
// That is, add all values from @other into @self that weren't part of it.
//
// It is allowed for @self and @other to be the same bitset. Nothing will happen
// in that case.
func (s *Bitset) Union(other *Bitset) {
	var arg0 *C.GtkBitset
	var arg1 *C.GtkBitset

	arg0 = (*C.GtkBitset)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GtkBitset)(unsafe.Pointer(other.Native()))

	C.gtk_bitset_union(arg0, arg1)
}

// Unref releases a reference on the given `GtkBitset`.
//
// If the reference was the last, the resources associated to the @self are
// freed.
func (s *Bitset) Unref() {
	var arg0 *C.GtkBitset

	arg0 = (*C.GtkBitset)(unsafe.Pointer(s.Native()))

	C.gtk_bitset_unref(arg0)
}

type CSSStyleChange struct {
	native C.GtkCssStyleChange
}

// WrapCSSStyleChange wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapCSSStyleChange(ptr unsafe.Pointer) *CSSStyleChange {
	if ptr == nil {
		return nil
	}

	return (*CSSStyleChange)(ptr)
}

func marshalCSSStyleChange(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapCSSStyleChange(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (c *CSSStyleChange) Native() unsafe.Pointer {
	return unsafe.Pointer(&c.native)
}
