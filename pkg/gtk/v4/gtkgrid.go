// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"unsafe"

	"github.com/diamondburned/gotk4/internal/gextras"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config:
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <stdbool.h>
// #include <glib-object.h>
// #include <gtk/gtk.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_grid_get_type()), F: marshalGrid},
	})
}

// Grid: gtkGrid is a container which arranges its child widgets in rows and
// columns, with arbitrary positions and horizontal/vertical spans.
//
// Children are added using gtk_grid_attach(). They can span multiple rows or
// columns. It is also possible to add a child next to an existing child, using
// gtk_grid_attach_next_to(). To remove a child from the grid, use
// gtk_grid_remove(). The behaviour of GtkGrid when several children occupy the
// same grid cell is undefined.
//
//
// CSS nodes
//
// GtkGrid uses a single CSS node with name `grid`.
//
//
// Accessibility
//
// GtkGrid uses the GTK_ACCESSIBLE_ROLE_GROUP role.
type Grid interface {
	Widget
	Accessible
	Buildable
	ConstraintTarget
	Orientable

	// Attach adds a widget to the grid.
	//
	// The position of @child is determined by @column and @row. The number of
	// “cells” that @child will occupy is determined by @width and @height.
	Attach(child Widget, column int, row int, width int, height int)
	// AttachNextTo adds a widget to the grid.
	//
	// The widget is placed next to @sibling, on the side determined by @side.
	// When @sibling is nil, the widget is placed in row (for left or right
	// placement) or column 0 (for top or bottom placement), at the end
	// indicated by @side.
	//
	// Attaching widgets labeled [1], [2], [3] with @sibling == nil and @side ==
	// GTK_POS_LEFT yields a layout of [3][2][1].
	AttachNextTo(child Widget, sibling Widget, side PositionType, width int, height int)
	// BaselineRow returns which row defines the global baseline of @grid.
	BaselineRow() int
	// ChildAt gets the child of @grid whose area covers the grid cell at
	// @column, @row.
	ChildAt(column int, row int) Widget
	// ColumnHomogeneous returns whether all columns of @grid have the same
	// width.
	ColumnHomogeneous() bool
	// ColumnSpacing returns the amount of space between the columns of @grid.
	ColumnSpacing() uint
	// RowBaselinePosition returns the baseline position of @row as set by
	// gtk_grid_set_row_baseline_position() or the default value
	// GTK_BASELINE_POSITION_CENTER.
	RowBaselinePosition(row int) BaselinePosition
	// RowHomogeneous returns whether all rows of @grid have the same height.
	RowHomogeneous() bool
	// RowSpacing returns the amount of space between the rows of @grid.
	RowSpacing() uint
	// InsertColumn inserts a column at the specified position.
	//
	// Children which are attached at or to the right of this position are moved
	// one column to the right. Children which span across this position are
	// grown to span the new column.
	InsertColumn(position int)
	// InsertNextTo inserts a row or column at the specified position.
	//
	// The new row or column is placed next to @sibling, on the side determined
	// by @side. If @side is GTK_POS_TOP or GTK_POS_BOTTOM, a row is inserted.
	// If @side is GTK_POS_LEFT of GTK_POS_RIGHT, a column is inserted.
	InsertNextTo(sibling Widget, side PositionType)
	// InsertRow inserts a row at the specified position.
	//
	// Children which are attached at or below this position are moved one row
	// down. Children which span across this position are grown to span the new
	// row.
	InsertRow(position int)
	// QueryChild queries the attach points and spans of @child inside the given
	// Grid.
	QueryChild(child Widget) (column int, row int, width int, height int)
	// Remove removes a child from @grid, after it has been added with
	// gtk_grid_attach() or gtk_grid_attach_next_to().
	Remove(child Widget)
	// RemoveColumn removes a column from the grid.
	//
	// Children that are placed in this column are removed, spanning children
	// that overlap this column have their width reduced by one, and children
	// after the column are moved to the left.
	RemoveColumn(position int)
	// RemoveRow removes a row from the grid.
	//
	// Children that are placed in this row are removed, spanning children that
	// overlap this row have their height reduced by one, and children below the
	// row are moved up.
	RemoveRow(position int)
	// SetBaselineRow sets which row defines the global baseline for the entire
	// grid. Each row in the grid can have its own local baseline, but only one
	// of those is global, meaning it will be the baseline in the parent of the
	// @grid.
	SetBaselineRow(row int)
	// SetColumnHomogeneous sets whether all columns of @grid will have the same
	// width.
	SetColumnHomogeneous(homogeneous bool)
	// SetColumnSpacing sets the amount of space between columns of @grid.
	SetColumnSpacing(spacing uint)
	// SetRowBaselinePosition sets how the baseline should be positioned on @row
	// of the grid, in case that row is assigned more space than is requested.
	SetRowBaselinePosition(row int, pos BaselinePosition)
	// SetRowHomogeneous sets whether all rows of @grid will have the same
	// height.
	SetRowHomogeneous(homogeneous bool)
	// SetRowSpacing sets the amount of space between rows of @grid.
	SetRowSpacing(spacing uint)
}

// grid implements the Grid interface.
type grid struct {
	Widget
	Accessible
	Buildable
	ConstraintTarget
	Orientable
}

var _ Grid = (*grid)(nil)

// WrapGrid wraps a GObject to the right type. It is
// primarily used internally.
func WrapGrid(obj *externglib.Object) Grid {
	return Grid{
		Widget:           WrapWidget(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
		Orientable:       WrapOrientable(obj),
	}
}

func marshalGrid(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapGrid(obj), nil
}

// NewGrid constructs a class Grid.
func NewGrid() Grid {
	var cret C.GtkGrid
	var ret1 Grid

	cret = C.gtk_grid_new()

	ret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Grid)

	return ret1
}

// Attach adds a widget to the grid.
//
// The position of @child is determined by @column and @row. The number of
// “cells” that @child will occupy is determined by @width and @height.
func (g grid) Attach(child Widget, column int, row int, width int, height int) {
	var arg0 *C.GtkGrid
	var arg1 *C.GtkWidget
	var arg2 C.int
	var arg3 C.int
	var arg4 C.int
	var arg5 C.int

	arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	arg2 = C.int(column)
	arg3 = C.int(row)
	arg4 = C.int(width)
	arg5 = C.int(height)

	C.gtk_grid_attach(arg0, child, column, row, width, height)
}

// AttachNextTo adds a widget to the grid.
//
// The widget is placed next to @sibling, on the side determined by @side.
// When @sibling is nil, the widget is placed in row (for left or right
// placement) or column 0 (for top or bottom placement), at the end
// indicated by @side.
//
// Attaching widgets labeled [1], [2], [3] with @sibling == nil and @side ==
// GTK_POS_LEFT yields a layout of [3][2][1].
func (g grid) AttachNextTo(child Widget, sibling Widget, side PositionType, width int, height int) {
	var arg0 *C.GtkGrid
	var arg1 *C.GtkWidget
	var arg2 *C.GtkWidget
	var arg3 C.GtkPositionType
	var arg4 C.int
	var arg5 C.int

	arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	arg2 = (*C.GtkWidget)(unsafe.Pointer(sibling.Native()))
	arg3 = (C.GtkPositionType)(side)
	arg4 = C.int(width)
	arg5 = C.int(height)

	C.gtk_grid_attach_next_to(arg0, child, sibling, side, width, height)
}

// BaselineRow returns which row defines the global baseline of @grid.
func (g grid) BaselineRow() int {
	var arg0 *C.GtkGrid

	arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))

	var cret C.int
	var ret1 int

	cret = C.gtk_grid_get_baseline_row(arg0)

	ret1 = C.int(cret)

	return ret1
}

// ChildAt gets the child of @grid whose area covers the grid cell at
// @column, @row.
func (g grid) ChildAt(column int, row int) Widget {
	var arg0 *C.GtkGrid
	var arg1 C.int
	var arg2 C.int

	arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))
	arg1 = C.int(column)
	arg2 = C.int(row)

	var cret *C.GtkWidget
	var ret1 Widget

	cret = C.gtk_grid_get_child_at(arg0, column, row)

	ret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Widget)

	return ret1
}

// ColumnHomogeneous returns whether all columns of @grid have the same
// width.
func (g grid) ColumnHomogeneous() bool {
	var arg0 *C.GtkGrid

	arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))

	var cret C.gboolean
	var ret1 bool

	cret = C.gtk_grid_get_column_homogeneous(arg0)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// ColumnSpacing returns the amount of space between the columns of @grid.
func (g grid) ColumnSpacing() uint {
	var arg0 *C.GtkGrid

	arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))

	var cret C.guint
	var ret1 uint

	cret = C.gtk_grid_get_column_spacing(arg0)

	ret1 = C.guint(cret)

	return ret1
}

// RowBaselinePosition returns the baseline position of @row as set by
// gtk_grid_set_row_baseline_position() or the default value
// GTK_BASELINE_POSITION_CENTER.
func (g grid) RowBaselinePosition(row int) BaselinePosition {
	var arg0 *C.GtkGrid
	var arg1 C.int

	arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))
	arg1 = C.int(row)

	var cret C.GtkBaselinePosition
	var ret1 BaselinePosition

	cret = C.gtk_grid_get_row_baseline_position(arg0, row)

	ret1 = BaselinePosition(cret)

	return ret1
}

// RowHomogeneous returns whether all rows of @grid have the same height.
func (g grid) RowHomogeneous() bool {
	var arg0 *C.GtkGrid

	arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))

	var cret C.gboolean
	var ret1 bool

	cret = C.gtk_grid_get_row_homogeneous(arg0)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// RowSpacing returns the amount of space between the rows of @grid.
func (g grid) RowSpacing() uint {
	var arg0 *C.GtkGrid

	arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))

	var cret C.guint
	var ret1 uint

	cret = C.gtk_grid_get_row_spacing(arg0)

	ret1 = C.guint(cret)

	return ret1
}

// InsertColumn inserts a column at the specified position.
//
// Children which are attached at or to the right of this position are moved
// one column to the right. Children which span across this position are
// grown to span the new column.
func (g grid) InsertColumn(position int) {
	var arg0 *C.GtkGrid
	var arg1 C.int

	arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))
	arg1 = C.int(position)

	C.gtk_grid_insert_column(arg0, position)
}

// InsertNextTo inserts a row or column at the specified position.
//
// The new row or column is placed next to @sibling, on the side determined
// by @side. If @side is GTK_POS_TOP or GTK_POS_BOTTOM, a row is inserted.
// If @side is GTK_POS_LEFT of GTK_POS_RIGHT, a column is inserted.
func (g grid) InsertNextTo(sibling Widget, side PositionType) {
	var arg0 *C.GtkGrid
	var arg1 *C.GtkWidget
	var arg2 C.GtkPositionType

	arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(sibling.Native()))
	arg2 = (C.GtkPositionType)(side)

	C.gtk_grid_insert_next_to(arg0, sibling, side)
}

// InsertRow inserts a row at the specified position.
//
// Children which are attached at or below this position are moved one row
// down. Children which span across this position are grown to span the new
// row.
func (g grid) InsertRow(position int) {
	var arg0 *C.GtkGrid
	var arg1 C.int

	arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))
	arg1 = C.int(position)

	C.gtk_grid_insert_row(arg0, position)
}

// QueryChild queries the attach points and spans of @child inside the given
// Grid.
func (g grid) QueryChild(child Widget) (column int, row int, width int, height int) {
	var arg0 *C.GtkGrid
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	var arg2 C.int
	var ret2 int
	var arg3 C.int
	var ret3 int
	var arg4 C.int
	var ret4 int
	var arg5 C.int
	var ret5 int

	C.gtk_grid_query_child(arg0, child, &arg2, &arg3, &arg4, &arg5)

	*ret2 = C.int(arg2)
	*ret3 = C.int(arg3)
	*ret4 = C.int(arg4)
	*ret5 = C.int(arg5)

	return ret2, ret3, ret4, ret5
}

// Remove removes a child from @grid, after it has been added with
// gtk_grid_attach() or gtk_grid_attach_next_to().
func (g grid) Remove(child Widget) {
	var arg0 *C.GtkGrid
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_grid_remove(arg0, child)
}

// RemoveColumn removes a column from the grid.
//
// Children that are placed in this column are removed, spanning children
// that overlap this column have their width reduced by one, and children
// after the column are moved to the left.
func (g grid) RemoveColumn(position int) {
	var arg0 *C.GtkGrid
	var arg1 C.int

	arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))
	arg1 = C.int(position)

	C.gtk_grid_remove_column(arg0, position)
}

// RemoveRow removes a row from the grid.
//
// Children that are placed in this row are removed, spanning children that
// overlap this row have their height reduced by one, and children below the
// row are moved up.
func (g grid) RemoveRow(position int) {
	var arg0 *C.GtkGrid
	var arg1 C.int

	arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))
	arg1 = C.int(position)

	C.gtk_grid_remove_row(arg0, position)
}

// SetBaselineRow sets which row defines the global baseline for the entire
// grid. Each row in the grid can have its own local baseline, but only one
// of those is global, meaning it will be the baseline in the parent of the
// @grid.
func (g grid) SetBaselineRow(row int) {
	var arg0 *C.GtkGrid
	var arg1 C.int

	arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))
	arg1 = C.int(row)

	C.gtk_grid_set_baseline_row(arg0, row)
}

// SetColumnHomogeneous sets whether all columns of @grid will have the same
// width.
func (g grid) SetColumnHomogeneous(homogeneous bool) {
	var arg0 *C.GtkGrid
	var arg1 C.gboolean

	arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))
	if homogeneous {
		arg1 = C.gboolean(1)
	}

	C.gtk_grid_set_column_homogeneous(arg0, homogeneous)
}

// SetColumnSpacing sets the amount of space between columns of @grid.
func (g grid) SetColumnSpacing(spacing uint) {
	var arg0 *C.GtkGrid
	var arg1 C.guint

	arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))
	arg1 = C.guint(spacing)

	C.gtk_grid_set_column_spacing(arg0, spacing)
}

// SetRowBaselinePosition sets how the baseline should be positioned on @row
// of the grid, in case that row is assigned more space than is requested.
func (g grid) SetRowBaselinePosition(row int, pos BaselinePosition) {
	var arg0 *C.GtkGrid
	var arg1 C.int
	var arg2 C.GtkBaselinePosition

	arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))
	arg1 = C.int(row)
	arg2 = (C.GtkBaselinePosition)(pos)

	C.gtk_grid_set_row_baseline_position(arg0, row, pos)
}

// SetRowHomogeneous sets whether all rows of @grid will have the same
// height.
func (g grid) SetRowHomogeneous(homogeneous bool) {
	var arg0 *C.GtkGrid
	var arg1 C.gboolean

	arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))
	if homogeneous {
		arg1 = C.gboolean(1)
	}

	C.gtk_grid_set_row_homogeneous(arg0, homogeneous)
}

// SetRowSpacing sets the amount of space between rows of @grid.
func (g grid) SetRowSpacing(spacing uint) {
	var arg0 *C.GtkGrid
	var arg1 C.guint

	arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))
	arg1 = C.guint(spacing)

	C.gtk_grid_set_row_spacing(arg0, spacing)
}
