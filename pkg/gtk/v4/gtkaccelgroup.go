// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/gdk/v4"
)

// #cgo pkg-config: gtk4
// #cgo CFLAGS: -Wno-deprecated-declarations
//
// #include <gtk/gtk.h>
import "C"

// AcceleratorGetDefaultModMask gets the modifier mask.
//
// The modifier mask determines which modifiers are considered significant for
// keyboard accelerators. This includes all keyboard modifiers except for
// GDK_LOCK_MASK.
func AcceleratorGetDefaultModMask() gdk.ModifierType {
	var _cret C.GdkModifierType // in

	_cret = C.gtk_accelerator_get_default_mod_mask()

	var _modifierType gdk.ModifierType // out

	_modifierType = (gdk.ModifierType)(_cret)

	return _modifierType
}

// AcceleratorParse parses a string representing an accelerator.
//
// The format looks like “<Control>a” or “<Shift><Alt>F1”.
//
// The parser is fairly liberal and allows lower or upper case, and also
// abbreviations such as “<Ctl>” and “<Ctrl>”. Key names are parsed using
// [func@Gdk.keyval_from_name]. For character keys the name is not the symbol,
// but the lowercase name, e.g. one would use “<Ctrl>minus” instead of
// “<Ctrl>-”.
//
// If the parse fails, @accelerator_key and @accelerator_mods will be set to 0
// (zero).
func AcceleratorParse(accelerator string) (uint, gdk.ModifierType, bool) {
	var _arg1 *C.char           // out
	var _arg2 C.guint           // in
	var _arg3 C.GdkModifierType // in
	var _cret C.gboolean        // in

	_arg1 = (*C.char)(C.CString(accelerator))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_accelerator_parse(_arg1, &_arg2, &_arg3)

	var _acceleratorKey uint              // out
	var _acceleratorMods gdk.ModifierType // out
	var _ok bool                          // out

	_acceleratorKey = uint(_arg2)
	_acceleratorMods = (gdk.ModifierType)(_arg3)
	if _cret != 0 {
		_ok = true
	}

	return _acceleratorKey, _acceleratorMods, _ok
}

// AcceleratorParseWithKeycode parses a string representing an accelerator.
//
// This is similar to [func@Gtk.accelerator_parse] but handles keycodes as well.
// This is only useful for system-level components, applications should use
// gtk_accelerator_parse() instead.
//
// If @accelerator_codes is given and the result stored in it is non-nil, the
// result must be freed with g_free().
//
// If a keycode is present in the accelerator and no @accelerator_codes is
// given, the parse will fail.
//
// If the parse fails, @accelerator_key, @accelerator_mods and
// @accelerator_codes will be set to 0 (zero).
func AcceleratorParseWithKeycode(accelerator string, display gdk.Displayyer) (uint, []uint, gdk.ModifierType, bool) {
	var _arg1 *C.char       // out
	var _arg2 *C.GdkDisplay // out
	var _arg3 C.guint       // in
	var _arg4 *C.guint
	var _arg5 C.GdkModifierType // in
	var _cret C.gboolean        // in

	_arg1 = (*C.char)(C.CString(accelerator))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GdkDisplay)(unsafe.Pointer((display).(gextras.Nativer).Native()))

	_cret = C.gtk_accelerator_parse_with_keycode(_arg1, _arg2, &_arg3, &_arg4, &_arg5)

	var _acceleratorKey uint // out
	var _acceleratorCodes []uint
	var _acceleratorMods gdk.ModifierType // out
	var _ok bool                          // out

	_acceleratorKey = uint(_arg3)
	{
		var i int
		var z C.guint
		for p := _arg4; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_arg4, i)
		_acceleratorCodes = make([]uint, i)
		for i := range src {
			_acceleratorCodes[i] = uint(src[i])
		}
	}
	_acceleratorMods = (gdk.ModifierType)(_arg5)
	if _cret != 0 {
		_ok = true
	}

	return _acceleratorKey, _acceleratorCodes, _acceleratorMods, _ok
}
