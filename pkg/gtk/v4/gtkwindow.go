// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/cairo"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/gdk/v4"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
	"github.com/diamondburned/gotk4/pkg/graphene"
	"github.com/diamondburned/gotk4/pkg/gsk/v4"
	"github.com/diamondburned/gotk4/pkg/pango"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gtk4
// #cgo CFLAGS: -Wno-deprecated-declarations
//
// #include <glib-object.h>
// #include <gtk/gtk.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_window_get_type()), F: marshalWindow},
	})
}

// Window: `GtkWindow` is a toplevel window which can contain other widgets.
//
// !An example GtkWindow (window.png)
//
// Windows normally have decorations that are under the control of the windowing
// system and allow the user to manipulate the window (resize it, move it, close
// it,...).
//
//
// GtkWindow as GtkBuildable
//
// The `GtkWindow` implementation of the [iface@Gtk.Buildable] interface
// supports setting a child as the titlebar by specifying “titlebar” as the
// “type” attribute of a <child> element.
//
//
// CSS nodes
//
// “` window.background [.csd / .solid-csd / .ssd] [.maximized / .fullscreen /
// .tiled] ├── <child> ╰── <titlebar child>.titlebar [.default-decoration] “`
//
// `GtkWindow` has a main CSS node with name window and style class .background.
//
// Style classes that are typically used with the main CSS node are .csd (when
// client-side decorations are in use), .solid-csd (for client-side decorations
// without invisible borders), .ssd (used by mutter when rendering server-side
// decorations). GtkWindow also represents window states with the following
// style classes on the main node: .maximized, .fullscreen, .tiled (when
// supported, also .tiled-top, .tiled-left, .tiled-right, .tiled-bottom).
//
// `GtkWindow` subclasses often add their own discriminating style classes, such
// as .dialog, .popup or .tooltip.
//
// Generally, some CSS properties don't make sense on the toplevel window node,
// such as margins or padding. When client-side decorations without invisible
// borders are in use (i.e. the .solid-csd style class is added to the main
// window node), the CSS border of the toplevel window is used for resize drags.
// In the .csd case, the shadow area outside of the window can be used to resize
// it.
//
// `GtkWindow` adds the .titlebar and .default-decoration style classes to the
// widget that is added as a titlebar child.
//
//
// Accessibility
//
// `GtkWindow` uses the GTK_ACCESSIBLE_ROLE_WINDOW role.
type Window interface {
	gextras.Objector

	// AsWidget casts the class to the Widget interface.
	AsWidget() Widget
	// AsAccessible casts the class to the Accessible interface.
	AsAccessible() Accessible
	// AsBuildable casts the class to the Buildable interface.
	AsBuildable() Buildable
	// AsConstraintTarget casts the class to the ConstraintTarget interface.
	AsConstraintTarget() ConstraintTarget
	// AsNative casts the class to the Native interface.
	AsNative() Native
	// AsRoot casts the class to the Root interface.
	AsRoot() Root
	// AsShortcutManager casts the class to the ShortcutManager interface.
	AsShortcutManager() ShortcutManager

	// ActionSetEnabled: enable or disable an action installed with
	// gtk_widget_class_install_action().
	//
	// This method is inherited from Widget
	ActionSetEnabled(actionName string, enabled bool)
	// Activate: for widgets that can be “activated” (buttons, menu items, etc.)
	// this function activates them.
	//
	// The activation will emit the signal set using
	// gtk_widget_class_set_activate_signal() during class initialization.
	//
	// Activation is what happens when you press Enter on a widget during key
	// navigation.
	//
	// If you wish to handle the activation keybinding yourself, it is
	// recommended to use gtk_widget_class_add_shortcut() with an action created
	// with gtk_signal_action_new().
	//
	// If @widget isn't activatable, the function returns false.
	//
	// This method is inherited from Widget
	Activate() bool
	// ActivateActionVariant looks up the action in the action groups associated
	// with @widget and its ancestors, and activates it.
	//
	// If the action is in an action group added with
	// [method@Gtk.Widget.insert_action_group], the @name is expected to be
	// prefixed with the prefix that was used when the group was inserted.
	//
	// The arguments must match the actions expected parameter type, as returned
	// by `g_action_get_parameter_type()`.
	//
	// This method is inherited from Widget
	ActivateActionVariant(name string, args *glib.Variant) bool
	// ActivateDefault activates the `default.activate` action from @widget.
	//
	// This method is inherited from Widget
	ActivateDefault()
	// AddController adds @controller to @widget so that it will receive events.
	//
	// You will usually want to call this function right after creating any kind
	// of [class@Gtk.EventController].
	//
	// This method is inherited from Widget
	AddController(controller EventController)
	// AddCSSClass adds a style class to @widget.
	//
	// After calling this function, the widgets style will match for @css_class,
	// according to CSS matching rules.
	//
	// Use [method@Gtk.Widget.remove_css_class] to remove the style again.
	//
	// This method is inherited from Widget
	AddCSSClass(cssClass string)
	// AddMnemonicLabel adds a widget to the list of mnemonic labels for this
	// widget.
	//
	// See [method@Gtk.Widget.list_mnemonic_labels]. Note the list of mnemonic
	// labels for the widget is cleared when the widget is destroyed, so the
	// caller must make sure to update its internal state at this point as well,
	// by using a connection to the [signal@Gtk.Widget::destroy] signal or a
	// weak notifier.
	//
	// This method is inherited from Widget
	AddMnemonicLabel(label Widget)
	// Allocate: this function is only used by `GtkWidget` subclasses, to assign
	// a size, position and (optionally) baseline to their child widgets.
	//
	// In this function, the allocation and baseline may be adjusted. The given
	// allocation will be forced to be bigger than the widget's minimum size, as
	// well as at least 0×0 in size.
	//
	// For a version that does not take a transform, see
	// [method@Gtk.Widget.size_allocate].
	//
	// This method is inherited from Widget
	Allocate(width int, height int, baseline int, transform *gsk.Transform)
	// ChildFocus: called by widgets as the user moves around the window using
	// keyboard shortcuts.
	//
	// The @direction argument indicates what kind of motion is taking place
	// (up, down, left, right, tab forward, tab backward).
	//
	// This function calls the [vfunc@Gtk.Widget.focus] virtual function;
	// widgets can override the virtual function in order to implement
	// appropriate focus behavior.
	//
	// The default `focus()` virtual function for a widget should return `TRUE`
	// if moving in @direction left the focus on a focusable location inside
	// that widget, and `FALSE` if moving in @direction moved the focus outside
	// the widget. When returning `TRUE`, widgets normallycall
	// [method@Gtk.Widget.grab_focus] to place the focus accordingly; when
	// returning `FALSE`, they don’t modify the current focus location.
	//
	// This function is used by custom widget implementations; if you're writing
	// an app, you’d use [method@Gtk.Widget.grab_focus] to move the focus to a
	// particular widget.
	//
	// This method is inherited from Widget
	ChildFocus(direction DirectionType) bool
	// ComputeBounds computes the bounds for @widget in the coordinate space of
	// @target.
	//
	// FIXME: Explain what "bounds" are.
	//
	// If the operation is successful, true is returned. If @widget has no
	// bounds or the bounds cannot be expressed in @target's coordinate space
	// (for example if both widgets are in different windows), false is returned
	// and @bounds is set to the zero rectangle.
	//
	// It is valid for @widget and @target to be the same widget.
	//
	// This method is inherited from Widget
	ComputeBounds(target Widget) (graphene.Rect, bool)
	// ComputeExpand computes whether a container should give this widget extra
	// space when possible.
	//
	// Containers should check this, rather than looking at
	// [method@Gtk.Widget.get_hexpand] or [method@Gtk.Widget.get_vexpand].
	//
	// This function already checks whether the widget is visible, so visibility
	// does not need to be checked separately. Non-visible widgets are not
	// expanded.
	//
	// The computed expand value uses either the expand setting explicitly set
	// on the widget itself, or, if none has been explicitly set, the widget may
	// expand if some of its children do.
	//
	// This method is inherited from Widget
	ComputeExpand(orientation Orientation) bool
	// ComputePoint translates the given @point in @widget's coordinates to
	// coordinates relative to @target’s coordinate system.
	//
	// In order to perform this operation, both widgets must share a common
	// ancestor.
	//
	// This method is inherited from Widget
	ComputePoint(target Widget, point *graphene.Point) (graphene.Point, bool)
	// ComputeTransform computes a matrix suitable to describe a transformation
	// from @widget's coordinate system into @target's coordinate system.
	//
	// This method is inherited from Widget
	ComputeTransform(target Widget) (graphene.Matrix, bool)
	// Contains tests if the point at (@x, @y) is contained in @widget.
	//
	// The coordinates for (@x, @y) must be in widget coordinates, so (0, 0) is
	// assumed to be the top left of @widget's content area.
	//
	// This method is inherited from Widget
	Contains(x float64, y float64) bool
	// CreatePangoContext creates a new `PangoContext` with the appropriate font
	// map, font options, font description, and base direction for drawing text
	// for this widget.
	//
	// See also [method@Gtk.Widget.get_pango_context].
	//
	// This method is inherited from Widget
	CreatePangoContext() pango.Context
	// CreatePangoLayout creates a new `PangoLayout` with the appropriate font
	// map, font description, and base direction for drawing text for this
	// widget.
	//
	// If you keep a `PangoLayout` created in this way around, you need to
	// re-create it when the widget `PangoContext` is replaced. This can be
	// tracked by listening to changes of the [property@Gtk.Widget:root]
	// property on the widget.
	//
	// This method is inherited from Widget
	CreatePangoLayout(text string) pango.Layout
	// DragCheckThreshold checks to see if a drag movement has passed the GTK
	// drag threshold.
	//
	// This method is inherited from Widget
	DragCheckThreshold(startX int, startY int, currentX int, currentY int) bool
	// ErrorBell notifies the user about an input-related error on this widget.
	//
	// If the [property@Gtk.Settings:gtk-error-bell] setting is true, it calls
	// [method@Gdk.Surface.beep], otherwise it does nothing.
	//
	// Note that the effect of [method@Gdk.Surface.beep] can be configured in
	// many ways, depending on the windowing backend and the desktop environment
	// or window manager that is used.
	//
	// This method is inherited from Widget
	ErrorBell()
	// GetAllocatedBaseline returns the baseline that has currently been
	// allocated to @widget.
	//
	// This function is intended to be used when implementing handlers for the
	// `GtkWidget`Class.snapshot() function, and when allocating child widgets
	// in `GtkWidget`Class.size_allocate().
	//
	// This method is inherited from Widget
	GetAllocatedBaseline() int
	// GetAllocatedHeight returns the height that has currently been allocated
	// to @widget.
	//
	// This method is inherited from Widget
	GetAllocatedHeight() int
	// GetAllocatedWidth returns the width that has currently been allocated to
	// @widget.
	//
	// This method is inherited from Widget
	GetAllocatedWidth() int
	// GetAncestor gets the first ancestor of @widget with type @widget_type.
	//
	// For example, `gtk_widget_get_ancestor (widget, GTK_TYPE_BOX)` gets the
	// first `GtkBox` that’s an ancestor of @widget. No reference will be added
	// to the returned widget; it should not be unreferenced.
	//
	// Note that unlike [method@Gtk.Widget.is_ancestor], this function considers
	// @widget to be an ancestor of itself.
	//
	// This method is inherited from Widget
	GetAncestor(widgetType externglib.Type) Widget
	// GetCanFocus determines whether the input focus can enter @widget or any
	// of its children.
	//
	// See [method@Gtk.Widget.set_focusable].
	//
	// This method is inherited from Widget
	GetCanFocus() bool
	// GetCanTarget queries whether @widget can be the target of pointer events.
	//
	// This method is inherited from Widget
	GetCanTarget() bool
	// GetChildVisible gets the value set with gtk_widget_set_child_visible().
	//
	// If you feel a need to use this function, your code probably needs
	// reorganization.
	//
	// This function is only useful for container implementations and should
	// never be called by an application.
	//
	// This method is inherited from Widget
	GetChildVisible() bool
	// GetClipboard gets the clipboard object for @widget.
	//
	// This is a utility function to get the clipboard object for the
	// `GdkDisplay` that @widget is using.
	//
	// Note that this function always works, even when @widget is not realized
	// yet.
	//
	// This method is inherited from Widget
	GetClipboard() gdk.Clipboard
	// GetCSSClasses returns the list of style classes applied to @widget.
	//
	// This method is inherited from Widget
	GetCSSClasses() []string
	// GetCSSName returns the CSS name that is used for @self.
	//
	// This method is inherited from Widget
	GetCSSName() string
	// GetCursor queries the cursor set on @widget.
	//
	// See [method@Gtk.Widget.set_cursor] for details.
	//
	// This method is inherited from Widget
	GetCursor() gdk.Cursor
	// GetDirection gets the reading direction for a particular widget.
	//
	// See [method@Gtk.Widget.set_direction].
	//
	// This method is inherited from Widget
	GetDirection() TextDirection
	// GetDisplay: get the `GdkDisplay` for the toplevel window associated with
	// this widget.
	//
	// This function can only be called after the widget has been added to a
	// widget hierarchy with a `GtkWindow` at the top.
	//
	// In general, you should only create display specific resources when a
	// widget has been realized, and you should free those resources when the
	// widget is unrealized.
	//
	// This method is inherited from Widget
	GetDisplay() gdk.Display
	// GetFirstChild returns the widgets first child.
	//
	// This API is primarily meant for widget implementations.
	//
	// This method is inherited from Widget
	GetFirstChild() Widget
	// GetFocusChild returns the current focus child of @widget.
	//
	// This method is inherited from Widget
	GetFocusChild() Widget
	// GetFocusOnClick returns whether the widget should grab focus when it is
	// clicked with the mouse.
	//
	// See [method@Gtk.Widget.set_focus_on_click].
	//
	// This method is inherited from Widget
	GetFocusOnClick() bool
	// GetFocusable determines whether @widget can own the input focus.
	//
	// See [method@Gtk.Widget.set_focusable].
	//
	// This method is inherited from Widget
	GetFocusable() bool
	// GetFontMap gets the font map of @widget.
	//
	// See [method@Gtk.Widget.set_font_map].
	//
	// This method is inherited from Widget
	GetFontMap() pango.FontMap
	// GetFontOptions returns the `cairo_font_options_t` used for Pango
	// rendering.
	//
	// When not set, the defaults font options for the `GdkDisplay` will be
	// used.
	//
	// This method is inherited from Widget
	GetFontOptions() *cairo.FontOptions
	// GetFrameClock obtains the frame clock for a widget.
	//
	// The frame clock is a global “ticker” that can be used to drive animations
	// and repaints. The most common reason to get the frame clock is to call
	// [method@Gdk.FrameClock.get_frame_time], in order to get a time to use for
	// animating. For example you might record the start of the animation with
	// an initial value from [method@Gdk.FrameClock.get_frame_time], and then
	// update the animation by calling [method@Gdk.FrameClock.get_frame_time]
	// again during each repaint.
	//
	// [method@Gdk.FrameClock.request_phase] will result in a new frame on the
	// clock, but won’t necessarily repaint any widgets. To repaint a widget,
	// you have to use [method@Gtk.Widget.queue_draw] which invalidates the
	// widget (thus scheduling it to receive a draw on the next frame).
	// gtk_widget_queue_draw() will also end up requesting a frame on the
	// appropriate frame clock.
	//
	// A widget’s frame clock will not change while the widget is mapped.
	// Reparenting a widget (which implies a temporary unmap) can change the
	// widget’s frame clock.
	//
	// Unrealized widgets do not have a frame clock.
	//
	// This method is inherited from Widget
	GetFrameClock() gdk.FrameClock
	// GetHAlign gets the horizontal alignment of @widget.
	//
	// For backwards compatibility reasons this method will never return
	// GTK_ALIGN_BASELINE, but instead it will convert it to GTK_ALIGN_FILL.
	// Baselines are not supported for horizontal alignment.
	//
	// This method is inherited from Widget
	GetHAlign() Align
	// GetHasTooltip returns the current value of the `has-tooltip` property.
	//
	// This method is inherited from Widget
	GetHasTooltip() bool
	// GetHeight returns the content height of the widget.
	//
	// This function returns the size passed to its size-allocate
	// implementation, which is the size you should be using in
	// GtkWidgetClass.snapshot().
	//
	// For pointer events, see [method@Gtk.Widget.contains].
	//
	// This method is inherited from Widget
	GetHeight() int
	// GetHExpand gets whether the widget would like any available extra
	// horizontal space.
	//
	// When a user resizes a `GtkWindow`, widgets with expand=TRUE generally
	// receive the extra space. For example, a list or scrollable area or
	// document in your window would often be set to expand.
	//
	// Containers should use [method@Gtk.Widget.compute_expand] rather than this
	// function, to see whether a widget, or any of its children, has the expand
	// flag set. If any child of a widget wants to expand, the parent may ask to
	// expand also.
	//
	// This function only looks at the widget’s own hexpand flag, rather than
	// computing whether the entire widget tree rooted at this widget wants to
	// expand.
	//
	// This method is inherited from Widget
	GetHExpand() bool
	// GetHExpandSet gets whether gtk_widget_set_hexpand() has been used to
	// explicitly set the expand flag on this widget.
	//
	// If [property@Gtk.Widget:hexpand] property is set, then it overrides any
	// computed expand value based on child widgets. If `hexpand` is not set,
	// then the expand value depends on whether any children of the widget would
	// like to expand.
	//
	// There are few reasons to use this function, but it’s here for
	// completeness and consistency.
	//
	// This method is inherited from Widget
	GetHExpandSet() bool
	// GetLastChild returns the widgets last child.
	//
	// This API is primarily meant for widget implementations.
	//
	// This method is inherited from Widget
	GetLastChild() Widget
	// GetLayoutManager retrieves the layout manager used by @widget
	//
	// See [method@Gtk.Widget.set_layout_manager].
	//
	// This method is inherited from Widget
	GetLayoutManager() LayoutManager
	// GetMapped: whether the widget is mapped.
	//
	// This method is inherited from Widget
	GetMapped() bool
	// GetMarginBottom gets the bottom margin of @widget.
	//
	// This method is inherited from Widget
	GetMarginBottom() int
	// GetMarginEnd gets the end margin of @widget.
	//
	// This method is inherited from Widget
	GetMarginEnd() int
	// GetMarginStart gets the start margin of @widget.
	//
	// This method is inherited from Widget
	GetMarginStart() int
	// GetMarginTop gets the top margin of @widget.
	//
	// This method is inherited from Widget
	GetMarginTop() int
	// GetName retrieves the name of a widget.
	//
	// See [method@Gtk.Widget.set_name] for the significance of widget names.
	//
	// This method is inherited from Widget
	GetName() string
	// GetNative returns the `GtkNative` widget that contains @widget.
	//
	// This function will return nil if the widget is not contained inside a
	// widget tree with a native ancestor.
	//
	// `GtkNative` widgets will return themselves here.
	//
	// This method is inherited from Widget
	GetNative() Native
	// GetNextSibling returns the widgets next sibling.
	//
	// This API is primarily meant for widget implementations.
	//
	// This method is inherited from Widget
	GetNextSibling() Widget
	// GetOpacity the requested opacity for this widget.
	//
	// See [method@Gtk.Widget.set_opacity].
	//
	// This method is inherited from Widget
	GetOpacity() float64
	// GetOverflow returns the widgets overflow value.
	//
	// This method is inherited from Widget
	GetOverflow() Overflow
	// GetPangoContext gets a `PangoContext` with the appropriate font map, font
	// description, and base direction for this widget.
	//
	// Unlike the context returned by [method@Gtk.Widget.create_pango_context],
	// this context is owned by the widget (it can be used until the screen for
	// the widget changes or the widget is removed from its toplevel), and will
	// be updated to match any changes to the widget’s attributes. This can be
	// tracked by listening to changes of the [property@Gtk.Widget:root]
	// property on the widget.
	//
	// This method is inherited from Widget
	GetPangoContext() pango.Context
	// GetParent returns the parent widget of @widget.
	//
	// This method is inherited from Widget
	GetParent() Widget
	// GetPreferredSize retrieves the minimum and natural size of a widget,
	// taking into account the widget’s preference for height-for-width
	// management.
	//
	// This is used to retrieve a suitable size by container widgets which do
	// not impose any restrictions on the child placement. It can be used to
	// deduce toplevel window and menu sizes as well as child widgets in
	// free-form containers such as `GtkFixed`.
	//
	// Handle with care. Note that the natural height of a height-for-width
	// widget will generally be a smaller size than the minimum height, since
	// the required height for the natural width is generally smaller than the
	// required height for the minimum width.
	//
	// Use [id@gtk_widget_measure] if you want to support baseline alignment.
	//
	// This method is inherited from Widget
	GetPreferredSize() (minimumSize Requisition, naturalSize Requisition)
	// GetPrevSibling returns the widgets previous sibling.
	//
	// This API is primarily meant for widget implementations.
	//
	// This method is inherited from Widget
	GetPrevSibling() Widget
	// GetPrimaryClipboard gets the primary clipboard of @widget.
	//
	// This is a utility function to get the primary clipboard object for the
	// `GdkDisplay` that @widget is using.
	//
	// Note that this function always works, even when @widget is not realized
	// yet.
	//
	// This method is inherited from Widget
	GetPrimaryClipboard() gdk.Clipboard
	// GetRealized determines whether @widget is realized.
	//
	// This method is inherited from Widget
	GetRealized() bool
	// GetReceivesDefault determines whether @widget is always treated as the
	// default widget within its toplevel when it has the focus, even if another
	// widget is the default.
	//
	// See [method@Gtk.Widget.set_receives_default].
	//
	// This method is inherited from Widget
	GetReceivesDefault() bool
	// GetRequestMode gets whether the widget prefers a height-for-width layout
	// or a width-for-height layout.
	//
	// Single-child widgets generally propagate the preference of their child,
	// more complex widgets need to request something either in context of their
	// children or in context of their allocation capabilities.
	//
	// This method is inherited from Widget
	GetRequestMode() SizeRequestMode
	// GetRoot returns the `GtkRoot` widget of @widget.
	//
	// This function will return nil if the widget is not contained inside a
	// widget tree with a root widget.
	//
	// `GtkRoot` widgets will return themselves here.
	//
	// This method is inherited from Widget
	GetRoot() Root
	// GetScaleFactor retrieves the internal scale factor that maps from window
	// coordinates to the actual device pixels.
	//
	// On traditional systems this is 1, on high density outputs, it can be a
	// higher value (typically 2).
	//
	// See [method@Gdk.Surface.get_scale_factor].
	//
	// This method is inherited from Widget
	GetScaleFactor() int
	// GetSensitive returns the widget’s sensitivity.
	//
	// This function returns the value that has been set using
	// [method@Gtk.Widget.set_sensitive]).
	//
	// The effective sensitivity of a widget is however determined by both its
	// own and its parent widget’s sensitivity. See
	// [method@Gtk.Widget.is_sensitive].
	//
	// This method is inherited from Widget
	GetSensitive() bool
	// GetSettings gets the settings object holding the settings used for this
	// widget.
	//
	// Note that this function can only be called when the `GtkWidget` is
	// attached to a toplevel, since the settings object is specific to a
	// particular `GdkDisplay`. If you want to monitor the widget for changes in
	// its settings, connect to notify::display.
	//
	// This method is inherited from Widget
	GetSettings() Settings
	// GetSize returns the content width or height of the widget.
	//
	// Which dimension is returned depends on @orientation.
	//
	// This is equivalent to calling [method@Gtk.Widget.get_width] for
	// GTK_ORIENTATION_HORIZONTAL or [method@Gtk.Widget.get_height] for
	// GTK_ORIENTATION_VERTICAL, but can be used when writing
	// orientation-independent code, such as when implementing
	// [iface@Gtk.Orientable] widgets.
	//
	// This method is inherited from Widget
	GetSize(orientation Orientation) int
	// GetSizeRequest gets the size request that was explicitly set for the
	// widget using gtk_widget_set_size_request().
	//
	// A value of -1 stored in @width or @height indicates that that dimension
	// has not been set explicitly and the natural requisition of the widget
	// will be used instead. See [method@Gtk.Widget.set_size_request]. To get
	// the size a widget will actually request, call [method@Gtk.Widget.measure]
	// instead of this function.
	//
	// This method is inherited from Widget
	GetSizeRequest() (width int, height int)
	// GetStateFlags returns the widget state as a flag set.
	//
	// It is worth mentioning that the effective GTK_STATE_FLAG_INSENSITIVE
	// state will be returned, that is, also based on parent insensitivity, even
	// if @widget itself is sensitive.
	//
	// Also note that if you are looking for a way to obtain the
	// [flags@Gtk.StateFlags] to pass to a [class@Gtk.StyleContext] method, you
	// should look at [method@Gtk.StyleContext.get_state].
	//
	// This method is inherited from Widget
	GetStateFlags() StateFlags
	// GetStyleContext returns the style context associated to @widget.
	//
	// The returned object is guaranteed to be the same for the lifetime of
	// @widget.
	//
	// This method is inherited from Widget
	GetStyleContext() StyleContext
	// GetTemplateChild: fetch an object build from the template XML for
	// @widget_type in this @widget instance.
	//
	// This will only report children which were previously declared with
	// [method@Gtk.WidgetClass.bind_template_child_full] or one of its variants.
	//
	// This function is only meant to be called for code which is private to the
	// @widget_type which declared the child and is meant for language bindings
	// which cannot easily make use of the GObject structure offsets.
	//
	// This method is inherited from Widget
	GetTemplateChild(widgetType externglib.Type, name string) gextras.Objector
	// GetTooltipMarkup gets the contents of the tooltip for @widget.
	//
	// If the tooltip has not been set using
	// [method@Gtk.Widget.set_tooltip_markup], this function returns nil.
	//
	// This method is inherited from Widget
	GetTooltipMarkup() string
	// GetTooltipText gets the contents of the tooltip for @widget.
	//
	// If the @widget's tooltip was set using
	// [method@Gtk.Widget.set_tooltip_markup], this function will return the
	// escaped text.
	//
	// This method is inherited from Widget
	GetTooltipText() string
	// GetVAlign gets the vertical alignment of @widget.
	//
	// This method is inherited from Widget
	GetVAlign() Align
	// GetVExpand gets whether the widget would like any available extra
	// vertical space.
	//
	// See [method@Gtk.Widget.get_hexpand] for more detail.
	//
	// This method is inherited from Widget
	GetVExpand() bool
	// GetVExpandSet gets whether gtk_widget_set_vexpand() has been used to
	// explicitly set the expand flag on this widget.
	//
	// See [method@Gtk.Widget.get_hexpand_set] for more detail.
	//
	// This method is inherited from Widget
	GetVExpandSet() bool
	// GetVisible determines whether the widget is visible.
	//
	// If you want to take into account whether the widget’s parent is also
	// marked as visible, use [method@Gtk.Widget.is_visible] instead.
	//
	// This function does not check if the widget is obscured in any way.
	//
	// See [method@Gtk.Widget.set_visible].
	//
	// This method is inherited from Widget
	GetVisible() bool
	// GetWidth returns the content width of the widget.
	//
	// This function returns the size passed to its size-allocate
	// implementation, which is the size you should be using in
	// GtkWidgetClass.snapshot().
	//
	// For pointer events, see [method@Gtk.Widget.contains].
	//
	// This method is inherited from Widget
	GetWidth() int
	// GrabFocus causes @widget to have the keyboard focus for the `GtkWindow`
	// it's inside.
	//
	// If @widget is not focusable, or its ::grab_focus implementation cannot
	// transfer the focus to a descendant of @widget that is focusable, it will
	// not take focus and false will be returned.
	//
	// Calling [method@Gtk.Widget.grab_focus] on an already focused widget is
	// allowed, should not have an effect, and return true.
	//
	// This method is inherited from Widget
	GrabFocus() bool
	// HasCSSClass returns whether @css_class is currently applied to @widget.
	//
	// This method is inherited from Widget
	HasCSSClass(cssClass string) bool
	// HasDefault determines whether @widget is the current default widget
	// within its toplevel.
	//
	// This method is inherited from Widget
	HasDefault() bool
	// HasFocus determines if the widget has the global input focus.
	//
	// See [method@Gtk.Widget.is_focus] for the difference between having the
	// global input focus, and only having the focus within a toplevel.
	//
	// This method is inherited from Widget
	HasFocus() bool
	// HasVisibleFocus determines if the widget should show a visible indication
	// that it has the global input focus.
	//
	// This is a convenience function that takes into account whether focus
	// indication should currently be shown in the toplevel window of @widget.
	// See [method@Gtk.Window.get_focus_visible] for more information about
	// focus indication.
	//
	// To find out if the widget has the global input focus, use
	// [method@Gtk.Widget.has_focus].
	//
	// This method is inherited from Widget
	HasVisibleFocus() bool
	// Hide reverses the effects of gtk_widget_show().
	//
	// This is causing the widget to be hidden (invisible to the user).
	//
	// This method is inherited from Widget
	Hide()
	// InDestruction returns whether the widget is currently being destroyed.
	//
	// This information can sometimes be used to avoid doing unnecessary work.
	//
	// This method is inherited from Widget
	InDestruction() bool
	// InitTemplate creates and initializes child widgets defined in templates.
	//
	// This function must be called in the instance initializer for any class
	// which assigned itself a template using
	// [method@Gtk.WidgetClass.set_template].
	//
	// It is important to call this function in the instance initializer of a
	// `GtkWidget` subclass and not in `GObject.constructed()` or
	// `GObject.constructor()` for two reasons:
	//
	//    - derived widgets will assume that the composite widgets
	//      defined by its parent classes have been created in their
	//      relative instance initializers
	//    - when calling `g_object_new()` on a widget with composite templates,
	//      it’s important to build the composite widgets before the construct
	//      properties are set. Properties passed to `g_object_new()` should
	//      take precedence over properties set in the private template XML
	//
	// A good rule of thumb is to call this function as the first thing in an
	// instance initialization function.
	//
	// This method is inherited from Widget
	InitTemplate()
	// InsertAfter inserts @widget into the child widget list of @parent.
	//
	// It will be placed after @previous_sibling, or at the beginning if
	// @previous_sibling is nil.
	//
	// After calling this function, `gtk_widget_get_prev_sibling(widget)` will
	// return @previous_sibling.
	//
	// If @parent is already set as the parent widget of @widget, this function
	// can also be used to reorder @widget in the child widget list of @parent.
	//
	// This API is primarily meant for widget implementations; if you are just
	// using a widget, you *must* use its own API for adding children.
	//
	// This method is inherited from Widget
	InsertAfter(parent Widget, previousSibling Widget)
	// InsertBefore inserts @widget into the child widget list of @parent.
	//
	// It will be placed before @next_sibling, or at the end if @next_sibling is
	// nil.
	//
	// After calling this function, `gtk_widget_get_next_sibling(widget)` will
	// return @next_sibling.
	//
	// If @parent is already set as the parent widget of @widget, this function
	// can also be used to reorder @widget in the child widget list of @parent.
	//
	// This API is primarily meant for widget implementations; if you are just
	// using a widget, you *must* use its own API for adding children.
	//
	// This method is inherited from Widget
	InsertBefore(parent Widget, nextSibling Widget)
	// IsAncestor determines whether @widget is somewhere inside @ancestor,
	// possibly with intermediate containers.
	//
	// This method is inherited from Widget
	IsAncestor(ancestor Widget) bool
	// IsDrawable determines whether @widget can be drawn to.
	//
	// A widget can be drawn if it is mapped and visible.
	//
	// This method is inherited from Widget
	IsDrawable() bool
	// IsFocus determines if the widget is the focus widget within its toplevel.
	//
	// This does not mean that the [property@Gtk.Widget:has-focus] property is
	// necessarily set; [property@Gtk,Widget:has-focus] will only be set if the
	// toplevel widget additionally has the global input focus.)
	//
	// This method is inherited from Widget
	IsFocus() bool
	// IsSensitive returns the widget’s effective sensitivity.
	//
	// This means it is sensitive itself and also its parent widget is
	// sensitive.
	//
	// This method is inherited from Widget
	IsSensitive() bool
	// IsVisible determines whether the widget and all its parents are marked as
	// visible.
	//
	// This function does not check if the widget is obscured in any way.
	//
	// See also [method@Gtk.Widget.get_visible] and
	// [method@Gtk.Widget.set_visible].
	//
	// This method is inherited from Widget
	IsVisible() bool
	// KeynavFailed emits the `::keynav-failed` signal on the widget.
	//
	// This function should be called whenever keyboard navigation within a
	// single widget hits a boundary.
	//
	// The return value of this function should be interpreted in a way similar
	// to the return value of [method@Gtk.Widget.child_focus]. When true is
	// returned, stay in the widget, the failed keyboard navigation is OK and/or
	// there is nowhere we can/should move the focus to. When false is returned,
	// the caller should continue with keyboard navigation outside the widget,
	// e.g. by calling [method@Gtk.Widget.child_focus] on the widget’s toplevel.
	//
	// The default [signal@Gtk.Widget::keynav-failed] handler returns false for
	// GTK_DIR_TAB_FORWARD and GTK_DIR_TAB_BACKWARD. For the other values of
	// DirectionType it returns true.
	//
	// Whenever the default handler returns true, it also calls
	// [method@Gtk.Widget.error_bell] to notify the user of the failed keyboard
	// navigation.
	//
	// A use case for providing an own implementation of ::keynav-failed (either
	// by connecting to it or by overriding it) would be a row of
	// [class@Gtk.Entry] widgets where the user should be able to navigate the
	// entire row with the cursor keys, as e.g. known from user interfaces that
	// require entering license keys.
	//
	// This method is inherited from Widget
	KeynavFailed(direction DirectionType) bool
	// Map causes a widget to be mapped if it isn’t already.
	//
	// This function is only for use in widget implementations.
	//
	// This method is inherited from Widget
	Map()
	// Measure measures @widget in the orientation @orientation and for the
	// given @for_size.
	//
	// As an example, if @orientation is GTK_ORIENTATION_HORIZONTAL and
	// @for_size is 300, this functions will compute the minimum and natural
	// width of @widget if it is allocated at a height of 300 pixels.
	//
	// See GtkWidget’s geometry management section
	// (class.Widget.html#height-for-width-geometry-management) for a more
	// details on implementing WidgetClass.measure().
	//
	// This method is inherited from Widget
	Measure(orientation Orientation, forSize int) (minimum int, natural int, minimumBaseline int, naturalBaseline int)
	// MnemonicActivate emits the `GtkWidget`::mnemonic-activate signal.
	//
	// This method is inherited from Widget
	MnemonicActivate(groupCycling bool) bool
	// Pick finds the descendant of @widget closest to the screen at the point
	// (@x, @y).
	//
	// The point must be given in widget coordinates, so (0, 0) is assumed to be
	// the top left of @widget's content area.
	//
	// Usually widgets will return nil if the given coordinate is not contained
	// in @widget checked via [method@Gtk.Widget.contains]. Otherwise they will
	// recursively try to find a child that does not return nil. Widgets are
	// however free to customize their picking algorithm.
	//
	// This function is used on the toplevel to determine the widget below the
	// mouse cursor for purposes of hover highlighting and delivering events.
	//
	// This method is inherited from Widget
	Pick(x float64, y float64, flags PickFlags) Widget
	// QueueAllocate flags the widget for a rerun of the
	// GtkWidgetClass::size_allocate function.
	//
	// Use this function instead of [method@Gtk.Widget.queue_resize] when the
	// @widget's size request didn't change but it wants to reposition its
	// contents.
	//
	// An example user of this function is [method@Gtk.Widget.set_halign].
	//
	// This function is only for use in widget implementations.
	//
	// This method is inherited from Widget
	QueueAllocate()
	// QueueDraw schedules this widget to be redrawn in paint phase of the
	// current or the next frame.
	//
	// This means @widget's GtkWidgetClass.snapshot() implementation will be
	// called.
	//
	// This method is inherited from Widget
	QueueDraw()
	// QueueResize flags a widget to have its size renegotiated.
	//
	// This should be called when a widget for some reason has a new size
	// request. For example, when you change the text in a [class@Gtk.Label],
	// the label queues a resize to ensure there’s enough space for the new
	// text.
	//
	// Note that you cannot call gtk_widget_queue_resize() on a widget from
	// inside its implementation of the GtkWidgetClass::size_allocate virtual
	// method. Calls to gtk_widget_queue_resize() from inside
	// GtkWidgetClass::size_allocate will be silently ignored.
	//
	// This function is only for use in widget implementations.
	//
	// This method is inherited from Widget
	QueueResize()
	// Realize creates the GDK resources associated with a widget.
	//
	// Normally realization happens implicitly; if you show a widget and all its
	// parent containers, then the widget will be realized and mapped
	// automatically.
	//
	// Realizing a widget requires all the widget’s parent widgets to be
	// realized; calling this function realizes the widget’s parents in addition
	// to @widget itself. If a widget is not yet inside a toplevel window when
	// you realize it, bad things will happen.
	//
	// This function is primarily used in widget implementations, and isn’t very
	// useful otherwise. Many times when you think you might need it, a better
	// approach is to connect to a signal that will be called after the widget
	// is realized automatically, such as [signal@Gtk.Widget::realize].
	//
	// This method is inherited from Widget
	Realize()
	// RemoveController removes @controller from @widget, so that it doesn't
	// process events anymore.
	//
	// It should not be used again.
	//
	// Widgets will remove all event controllers automatically when they are
	// destroyed, there is normally no need to call this function.
	//
	// This method is inherited from Widget
	RemoveController(controller EventController)
	// RemoveCSSClass removes a style from @widget.
	//
	// After this, the style of @widget will stop matching for @css_class.
	//
	// This method is inherited from Widget
	RemoveCSSClass(cssClass string)
	// RemoveMnemonicLabel removes a widget from the list of mnemonic labels for
	// this widget.
	//
	// See [method@Gtk.Widget.list_mnemonic_labels]. The widget must have
	// previously been added to the list with
	// [method@Gtk.Widget.add_mnemonic_label].
	//
	// This method is inherited from Widget
	RemoveMnemonicLabel(label Widget)
	// RemoveTickCallback removes a tick callback previously registered with
	// gtk_widget_add_tick_callback().
	//
	// This method is inherited from Widget
	RemoveTickCallback(id uint)
	// SetCanFocus specifies whether the input focus can enter the widget or any
	// of its children.
	//
	// Applications should set @can_focus to false to mark a widget as for
	// pointer/touch use only.
	//
	// Note that having @can_focus be true is only one of the necessary
	// conditions for being focusable. A widget must also be sensitive and
	// focusable and not have an ancestor that is marked as not can-focus in
	// order to receive input focus.
	//
	// See [method@Gtk.Widget.grab_focus] for actually setting the input focus
	// on a widget.
	//
	// This method is inherited from Widget
	SetCanFocus(canFocus bool)
	// SetCanTarget sets whether @widget can be the target of pointer events.
	//
	// This method is inherited from Widget
	SetCanTarget(canTarget bool)
	// SetChildVisible sets whether @widget should be mapped along with its
	// parent.
	//
	// The child visibility can be set for widget before it is added to a
	// container with [method@Gtk.Widget.set_parent], to avoid mapping children
	// unnecessary before immediately unmapping them. However it will be reset
	// to its default state of true when the widget is removed from a container.
	//
	// Note that changing the child visibility of a widget does not queue a
	// resize on the widget. Most of the time, the size of a widget is computed
	// from all visible children, whether or not they are mapped. If this is not
	// the case, the container can queue a resize itself.
	//
	// This function is only useful for container implementations and should
	// never be called by an application.
	//
	// This method is inherited from Widget
	SetChildVisible(childVisible bool)
	// SetCSSClasses: will clear all style classes applied to @widget and
	// replace them with @classes.
	//
	// This method is inherited from Widget
	SetCSSClasses(classes []string)
	// SetCursor sets the cursor to be shown when pointer devices point towards
	// @widget.
	//
	// If the @cursor is NULL, @widget will use the cursor inherited from the
	// parent widget.
	//
	// This method is inherited from Widget
	SetCursor(cursor gdk.Cursor)
	// SetCursorFromName sets a named cursor to be shown when pointer devices
	// point towards @widget.
	//
	// This is a utility function that creates a cursor via
	// [ctor@Gdk.Cursor.new_from_name] and then sets it on @widget with
	// [method@Gtk.Widget.set_cursor]. See those functions for details.
	//
	// On top of that, this function allows @name to be nil, which will do the
	// same as calling [method@Gtk.Widget.set_cursor] with a nil cursor.
	//
	// This method is inherited from Widget
	SetCursorFromName(name string)
	// SetDirection sets the reading direction on a particular widget.
	//
	// This direction controls the primary direction for widgets containing
	// text, and also the direction in which the children of a container are
	// packed. The ability to set the direction is present in order so that
	// correct localization into languages with right-to-left reading directions
	// can be done. Generally, applications will let the default reading
	// direction present, except for containers where the containers are
	// arranged in an order that is explicitly visual rather than logical (such
	// as buttons for text justification).
	//
	// If the direction is set to GTK_TEXT_DIR_NONE, then the value set by
	// [func@Gtk.Widget.set_default_direction] will be used.
	//
	// This method is inherited from Widget
	SetDirection(dir TextDirection)
	// SetFocusChild: set @child as the current focus child of @widget.
	//
	// The previous focus child will be unset.
	//
	// This function is only suitable for widget implementations. If you want a
	// certain widget to get the input focus, call
	// [method@Gtk.Widget.grab_focus] on it.
	//
	// This method is inherited from Widget
	SetFocusChild(child Widget)
	// SetFocusOnClick sets whether the widget should grab focus when it is
	// clicked with the mouse.
	//
	// Making mouse clicks not grab focus is useful in places like toolbars
	// where you don’t want the keyboard focus removed from the main area of the
	// application.
	//
	// This method is inherited from Widget
	SetFocusOnClick(focusOnClick bool)
	// SetFocusable specifies whether @widget can own the input focus.
	//
	// Widget implementations should set @focusable to true in their init()
	// function if they want to receive keyboard input.
	//
	// Note that having @focusable be true is only one of the necessary
	// conditions for being focusable. A widget must also be sensitive and
	// can-focus and not have an ancestor that is marked as not can-focus in
	// order to receive input focus.
	//
	// See [method@Gtk.Widget.grab_focus] for actually setting the input focus
	// on a widget.
	//
	// This method is inherited from Widget
	SetFocusable(focusable bool)
	// SetFontMap sets the font map to use for Pango rendering.
	//
	// The font map is the object that is used to look up fonts. Setting a
	// custom font map can be useful in special situations, e.g. when you need
	// to add application-specific fonts to the set of available fonts.
	//
	// When not set, the widget will inherit the font map from its parent.
	//
	// This method is inherited from Widget
	SetFontMap(fontMap pango.FontMap)
	// SetFontOptions sets the `cairo_font_options_t` used for Pango rendering
	// in this widget.
	//
	// When not set, the default font options for the `GdkDisplay` will be used.
	//
	// This method is inherited from Widget
	SetFontOptions(options *cairo.FontOptions)
	// SetHAlign sets the horizontal alignment of @widget.
	//
	// This method is inherited from Widget
	SetHAlign(align Align)
	// SetHasTooltip sets the `has-tooltip` property on @widget to @has_tooltip.
	//
	// This method is inherited from Widget
	SetHasTooltip(hasTooltip bool)
	// SetHExpand sets whether the widget would like any available extra
	// horizontal space.
	//
	// When a user resizes a `GtkWindow`, widgets with expand=TRUE generally
	// receive the extra space. For example, a list or scrollable area or
	// document in your window would often be set to expand.
	//
	// Call this function to set the expand flag if you would like your widget
	// to become larger horizontally when the window has extra room.
	//
	// By default, widgets automatically expand if any of their children want to
	// expand. (To see if a widget will automatically expand given its current
	// children and state, call [method@Gtk.Widget.compute_expand]. A container
	// can decide how the expandability of children affects the expansion of the
	// container by overriding the compute_expand virtual method on
	// `GtkWidget`.).
	//
	// Setting hexpand explicitly with this function will override the automatic
	// expand behavior.
	//
	// This function forces the widget to expand or not to expand, regardless of
	// children. The override occurs because [method@Gtk.Widget.set_hexpand]
	// sets the hexpand-set property (see [method@Gtk.Widget.set_hexpand_set])
	// which causes the widget’s hexpand value to be used, rather than looking
	// at children and widget state.
	//
	// This method is inherited from Widget
	SetHExpand(expand bool)
	// SetHExpandSet sets whether the hexpand flag will be used.
	//
	// The [property@Gtk.Widget:hexpand-set] property will be set automatically
	// when you call [method@Gtk.Widget.set_hexpand] to set hexpand, so the most
	// likely reason to use this function would be to unset an explicit expand
	// flag.
	//
	// If hexpand is set, then it overrides any computed expand value based on
	// child widgets. If hexpand is not set, then the expand value depends on
	// whether any children of the widget would like to expand.
	//
	// There are few reasons to use this function, but it’s here for
	// completeness and consistency.
	//
	// This method is inherited from Widget
	SetHExpandSet(set bool)
	// SetLayoutManager sets the layout manager delegate instance that provides
	// an implementation for measuring and allocating the children of @widget.
	//
	// This method is inherited from Widget
	SetLayoutManager(layoutManager LayoutManager)
	// SetMarginBottom sets the bottom margin of @widget.
	//
	// This method is inherited from Widget
	SetMarginBottom(margin int)
	// SetMarginEnd sets the end margin of @widget.
	//
	// This method is inherited from Widget
	SetMarginEnd(margin int)
	// SetMarginStart sets the start margin of @widget.
	//
	// This method is inherited from Widget
	SetMarginStart(margin int)
	// SetMarginTop sets the top margin of @widget.
	//
	// This method is inherited from Widget
	SetMarginTop(margin int)
	// SetName sets a widgets name.
	//
	// Setting a name allows you to refer to the widget from a CSS file. You can
	// apply a style to widgets with a particular name in the CSS file. See the
	// documentation for the CSS syntax (on the same page as the docs for
	// [class@Gtk.StyleContext].
	//
	// Note that the CSS syntax has certain special characters to delimit and
	// represent elements in a selector (period, #, >, *...), so using these
	// will make your widget impossible to match by name. Any combination of
	// alphanumeric symbols, dashes and underscores will suffice.
	//
	// This method is inherited from Widget
	SetName(name string)
	// SetOpacity: request the @widget to be rendered partially transparent.
	//
	// An opacity of 0 is fully transparent and an opacity of 1 is fully opaque.
	//
	// Opacity works on both toplevel widgets and child widgets, although there
	// are some limitations: For toplevel widgets, applying opacity depends on
	// the capabilities of the windowing system. On X11, this has any effect
	// only on X displays with a compositing manager, see
	// gdk_display_is_composited(). On Windows and Wayland it should always
	// work, although setting a window’s opacity after the window has been shown
	// may cause some flicker.
	//
	// Note that the opacity is inherited through inclusion — if you set a
	// toplevel to be partially translucent, all of its content will appear
	// translucent, since it is ultimatively rendered on that toplevel. The
	// opacity value itself is not inherited by child widgets (since that would
	// make widgets deeper in the hierarchy progressively more translucent). As
	// a consequence, [class@Gtk.Popover]s and other [class@Gtk.Native] widgets
	// with their own surface will use their own opacity value, and thus by
	// default appear non-translucent, even if they are attached to a toplevel
	// that is translucent.
	//
	// This method is inherited from Widget
	SetOpacity(opacity float64)
	// SetOverflow sets how @widget treats content that is drawn outside the
	// widget's content area.
	//
	// See the definition of [enum@Gtk.Overflow] for details.
	//
	// This setting is provided for widget implementations and should not be
	// used by application code.
	//
	// The default value is GTK_OVERFLOW_VISIBLE.
	//
	// This method is inherited from Widget
	SetOverflow(overflow Overflow)
	// SetParent sets @parent as the parent widget of @widget.
	//
	// This takes care of details such as updating the state and style of the
	// child to reflect its new location and resizing the parent. The opposite
	// function is [method@Gtk.Widget.unparent].
	//
	// This function is useful only when implementing subclasses of `GtkWidget`.
	//
	// This method is inherited from Widget
	SetParent(parent Widget)
	// SetReceivesDefault specifies whether @widget will be treated as the
	// default widget within its toplevel when it has the focus, even if another
	// widget is the default.
	//
	// This method is inherited from Widget
	SetReceivesDefault(receivesDefault bool)
	// SetSensitive sets the sensitivity of a widget.
	//
	// A widget is sensitive if the user can interact with it. Insensitive
	// widgets are “grayed out” and the user can’t interact with them.
	// Insensitive widgets are known as “inactive”, “disabled”, or “ghosted” in
	// some other toolkits.
	//
	// This method is inherited from Widget
	SetSensitive(sensitive bool)
	// SetSizeRequest sets the minimum size of a widget.
	//
	// That is, the widget’s size request will be at least @width by @height.
	// You can use this function to force a widget to be larger than it normally
	// would be.
	//
	// In most cases, [method@Gtk.Window.set_default_size] is a better choice
	// for toplevel windows than this function; setting the default size will
	// still allow users to shrink the window. Setting the size request will
	// force them to leave the window at least as large as the size request.
	//
	// Note the inherent danger of setting any fixed size - themes, translations
	// into other languages, different fonts, and user action can all change the
	// appropriate size for a given widget. So, it's basically impossible to
	// hardcode a size that will always be correct.
	//
	// The size request of a widget is the smallest size a widget can accept
	// while still functioning well and drawing itself correctly. However in
	// some strange cases a widget may be allocated less than its requested
	// size, and in many cases a widget may be allocated more space than it
	// requested.
	//
	// If the size request in a given direction is -1 (unset), then the
	// “natural” size request of the widget will be used instead.
	//
	// The size request set here does not include any margin from the properties
	// [property@Gtk.Widget:margin-start], [property@Gtk.Widget:margin-end],
	// [property@Gtk.Widget:margin-top], and
	// [property@Gtk.Widget:margin-bottom], but it does include pretty much all
	// other padding or border properties set by any subclass of `GtkWidget`.
	//
	// This method is inherited from Widget
	SetSizeRequest(width int, height int)
	// SetStateFlags turns on flag values in the current widget state.
	//
	// Typical widget states are insensitive, prelighted, etc.
	//
	// This function accepts the values GTK_STATE_FLAG_DIR_LTR and
	// GTK_STATE_FLAG_DIR_RTL but ignores them. If you want to set the widget's
	// direction, use [method@Gtk.Widget.set_direction].
	//
	// This function is for use in widget implementations.
	//
	// This method is inherited from Widget
	SetStateFlags(flags StateFlags, clear bool)
	// SetTooltipMarkup sets @markup as the contents of the tooltip, which is
	// marked up with Pango markup.
	//
	// This function will take care of setting the
	// [property@Gtk.Widget:has-tooltip] as a side effect, and of the default
	// handler for the [signal@Gtk.Widget::query-tooltip] signal.
	//
	// See also [method@Gtk.Tooltip.set_markup].
	//
	// This method is inherited from Widget
	SetTooltipMarkup(markup string)
	// SetTooltipText sets @text as the contents of the tooltip.
	//
	// If @text contains any markup, it will be escaped.
	//
	// This function will take care of setting [property@Gtk.Widget:has-tooltip]
	// as a side effect, and of the default handler for the
	// [signal@Gtk.Widget::query-tooltip] signal.
	//
	// See also [method@Gtk.Tooltip.set_text].
	//
	// This method is inherited from Widget
	SetTooltipText(text string)
	// SetVAlign sets the vertical alignment of @widget.
	//
	// This method is inherited from Widget
	SetVAlign(align Align)
	// SetVExpand sets whether the widget would like any available extra
	// vertical space.
	//
	// See [method@Gtk.Widget.set_hexpand] for more detail.
	//
	// This method is inherited from Widget
	SetVExpand(expand bool)
	// SetVExpandSet sets whether the vexpand flag will be used.
	//
	// See [method@Gtk.Widget.set_hexpand_set] for more detail.
	//
	// This method is inherited from Widget
	SetVExpandSet(set bool)
	// SetVisible sets the visibility state of @widget.
	//
	// Note that setting this to true doesn’t mean the widget is actually
	// viewable, see [method@Gtk.Widget.get_visible].
	//
	// This function simply calls [method@Gtk.Widget.show] or
	// [method@Gtk.Widget.hide] but is nicer to use when the visibility of the
	// widget depends on some condition.
	//
	// This method is inherited from Widget
	SetVisible(visible bool)
	// ShouldLayout returns whether @widget should contribute to the measuring
	// and allocation of its parent.
	//
	// This is false for invisible children, but also for children that have
	// their own surface.
	//
	// This method is inherited from Widget
	ShouldLayout() bool
	// Show flags a widget to be displayed.
	//
	// Any widget that isn’t shown will not appear on the screen.
	//
	// Remember that you have to show the containers containing a widget, in
	// addition to the widget itself, before it will appear onscreen.
	//
	// When a toplevel container is shown, it is immediately realized and
	// mapped; other shown widgets are realized and mapped when their toplevel
	// container is realized and mapped.
	//
	// This method is inherited from Widget
	Show()
	// SnapshotChild: snapshot the a child of @widget.
	//
	// When a widget receives a call to the snapshot function, it must send
	// synthetic `GtkWidget`Class.snapshot() calls to all children. This
	// function provides a convenient way of doing this. A widget, when it
	// receives a call to its `GtkWidget`Class.snapshot() function, calls
	// gtk_widget_snapshot_child() once for each child, passing in the @snapshot
	// the widget received.
	//
	// gtk_widget_snapshot_child() takes care of translating the origin of
	// @snapshot, and deciding whether the child needs to be snapshot.
	//
	// This function does nothing for children that implement `GtkNative`.
	//
	// This method is inherited from Widget
	SnapshotChild(child Widget, snapshot Snapshot)
	// TranslateCoordinates: translate coordinates relative to @src_widget’s
	// allocation to coordinates relative to @dest_widget’s allocations.
	//
	// In order to perform this operation, both widget must share a common
	// ancestor.
	//
	// This method is inherited from Widget
	TranslateCoordinates(destWidget Widget, srcX float64, srcY float64) (destX float64, destY float64, ok bool)
	// TriggerTooltipQuery triggers a tooltip query on the display where the
	// toplevel of @widget is located.
	//
	// This method is inherited from Widget
	TriggerTooltipQuery()
	// Unmap causes a widget to be unmapped if it’s currently mapped.
	//
	// This function is only for use in widget implementations.
	//
	// This method is inherited from Widget
	Unmap()
	// Unparent: dissociate @widget from its parent.
	//
	// This function is only for use in widget implementations, typically in
	// dispose.
	//
	// This method is inherited from Widget
	Unparent()
	// Unrealize causes a widget to be unrealized (frees all GDK resources
	// associated with the widget).
	//
	// This function is only useful in widget implementations.
	//
	// This method is inherited from Widget
	Unrealize()
	// UnsetStateFlags turns off flag values for the current widget state.
	//
	// See [method@Gtk.Widget.set_state_flags].
	//
	// This function is for use in widget implementations.
	//
	// This method is inherited from Widget
	UnsetStateFlags(flags StateFlags)
	// GetAccessibleRole retrieves the `GtkAccessibleRole` for the given
	// `GtkAccessible`.
	//
	// This method is inherited from Accessible
	GetAccessibleRole() AccessibleRole
	// ResetProperty resets the accessible @property to its default value.
	//
	// This method is inherited from Accessible
	ResetProperty(property AccessibleProperty)
	// ResetRelation resets the accessible @relation to its default value.
	//
	// This method is inherited from Accessible
	ResetRelation(relation AccessibleRelation)
	// ResetState resets the accessible @state to its default value.
	//
	// This method is inherited from Accessible
	ResetState(state AccessibleState)
	// UpdatePropertyValue updates an array of accessible properties.
	//
	// This function should be called by `GtkWidget` types whenever an
	// accessible property change must be communicated to assistive
	// technologies.
	//
	// This function is meant to be used by language bindings.
	//
	// This method is inherited from Accessible
	UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value)
	// UpdateRelationValue updates an array of accessible relations.
	//
	// This function should be called by `GtkWidget` types whenever an
	// accessible relation change must be communicated to assistive
	// technologies.
	//
	// This function is meant to be used by language bindings.
	//
	// This method is inherited from Accessible
	UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value)
	// UpdateStateValue updates an array of accessible states.
	//
	// This function should be called by `GtkWidget` types whenever an
	// accessible state change must be communicated to assistive technologies.
	//
	// This function is meant to be used by language bindings.
	//
	// This method is inherited from Accessible
	UpdateStateValue(states []AccessibleState, values []externglib.Value)
	// GetBuildableID gets the ID of the @buildable object.
	//
	// `GtkBuilder` sets the name based on the ID attribute of the <object> tag
	// used to construct the @buildable.
	//
	// This method is inherited from Buildable
	GetBuildableID() string
	// GetAccessibleRole retrieves the `GtkAccessibleRole` for the given
	// `GtkAccessible`.
	//
	// This method is inherited from Accessible
	GetAccessibleRole() AccessibleRole
	// ResetProperty resets the accessible @property to its default value.
	//
	// This method is inherited from Accessible
	ResetProperty(property AccessibleProperty)
	// ResetRelation resets the accessible @relation to its default value.
	//
	// This method is inherited from Accessible
	ResetRelation(relation AccessibleRelation)
	// ResetState resets the accessible @state to its default value.
	//
	// This method is inherited from Accessible
	ResetState(state AccessibleState)
	// UpdatePropertyValue updates an array of accessible properties.
	//
	// This function should be called by `GtkWidget` types whenever an
	// accessible property change must be communicated to assistive
	// technologies.
	//
	// This function is meant to be used by language bindings.
	//
	// This method is inherited from Accessible
	UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value)
	// UpdateRelationValue updates an array of accessible relations.
	//
	// This function should be called by `GtkWidget` types whenever an
	// accessible relation change must be communicated to assistive
	// technologies.
	//
	// This function is meant to be used by language bindings.
	//
	// This method is inherited from Accessible
	UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value)
	// UpdateStateValue updates an array of accessible states.
	//
	// This function should be called by `GtkWidget` types whenever an
	// accessible state change must be communicated to assistive technologies.
	//
	// This function is meant to be used by language bindings.
	//
	// This method is inherited from Accessible
	UpdateStateValue(states []AccessibleState, values []externglib.Value)
	// GetBuildableID gets the ID of the @buildable object.
	//
	// `GtkBuilder` sets the name based on the ID attribute of the <object> tag
	// used to construct the @buildable.
	//
	// This method is inherited from Buildable
	GetBuildableID() string
	// GetRenderer returns the renderer that is used for this `GtkNative`.
	//
	// This method is inherited from Native
	GetRenderer() gsk.Renderer
	// GetSurface returns the surface of this `GtkNative`.
	//
	// This method is inherited from Native
	GetSurface() gdk.Surface
	// GetSurfaceTransform retrieves the surface transform of @self.
	//
	// This is the translation from @self's surface coordinates into @self's
	// widget coordinates.
	//
	// This method is inherited from Native
	GetSurfaceTransform() (x float64, y float64)
	// Realize realizes a `GtkNative`.
	//
	// This should only be used by subclasses.
	//
	// This method is inherited from Native
	Realize()
	// Unrealize unrealizes a `GtkNative`.
	//
	// This should only be used by subclasses.
	//
	// This method is inherited from Native
	Unrealize()
	// ActionSetEnabled: enable or disable an action installed with
	// gtk_widget_class_install_action().
	//
	// This method is inherited from Widget
	ActionSetEnabled(actionName string, enabled bool)
	// Activate: for widgets that can be “activated” (buttons, menu items, etc.)
	// this function activates them.
	//
	// The activation will emit the signal set using
	// gtk_widget_class_set_activate_signal() during class initialization.
	//
	// Activation is what happens when you press Enter on a widget during key
	// navigation.
	//
	// If you wish to handle the activation keybinding yourself, it is
	// recommended to use gtk_widget_class_add_shortcut() with an action created
	// with gtk_signal_action_new().
	//
	// If @widget isn't activatable, the function returns false.
	//
	// This method is inherited from Widget
	Activate() bool
	// ActivateActionVariant looks up the action in the action groups associated
	// with @widget and its ancestors, and activates it.
	//
	// If the action is in an action group added with
	// [method@Gtk.Widget.insert_action_group], the @name is expected to be
	// prefixed with the prefix that was used when the group was inserted.
	//
	// The arguments must match the actions expected parameter type, as returned
	// by `g_action_get_parameter_type()`.
	//
	// This method is inherited from Widget
	ActivateActionVariant(name string, args *glib.Variant) bool
	// ActivateDefault activates the `default.activate` action from @widget.
	//
	// This method is inherited from Widget
	ActivateDefault()
	// AddController adds @controller to @widget so that it will receive events.
	//
	// You will usually want to call this function right after creating any kind
	// of [class@Gtk.EventController].
	//
	// This method is inherited from Widget
	AddController(controller EventController)
	// AddCSSClass adds a style class to @widget.
	//
	// After calling this function, the widgets style will match for @css_class,
	// according to CSS matching rules.
	//
	// Use [method@Gtk.Widget.remove_css_class] to remove the style again.
	//
	// This method is inherited from Widget
	AddCSSClass(cssClass string)
	// AddMnemonicLabel adds a widget to the list of mnemonic labels for this
	// widget.
	//
	// See [method@Gtk.Widget.list_mnemonic_labels]. Note the list of mnemonic
	// labels for the widget is cleared when the widget is destroyed, so the
	// caller must make sure to update its internal state at this point as well,
	// by using a connection to the [signal@Gtk.Widget::destroy] signal or a
	// weak notifier.
	//
	// This method is inherited from Widget
	AddMnemonicLabel(label Widget)
	// Allocate: this function is only used by `GtkWidget` subclasses, to assign
	// a size, position and (optionally) baseline to their child widgets.
	//
	// In this function, the allocation and baseline may be adjusted. The given
	// allocation will be forced to be bigger than the widget's minimum size, as
	// well as at least 0×0 in size.
	//
	// For a version that does not take a transform, see
	// [method@Gtk.Widget.size_allocate].
	//
	// This method is inherited from Widget
	Allocate(width int, height int, baseline int, transform *gsk.Transform)
	// ChildFocus: called by widgets as the user moves around the window using
	// keyboard shortcuts.
	//
	// The @direction argument indicates what kind of motion is taking place
	// (up, down, left, right, tab forward, tab backward).
	//
	// This function calls the [vfunc@Gtk.Widget.focus] virtual function;
	// widgets can override the virtual function in order to implement
	// appropriate focus behavior.
	//
	// The default `focus()` virtual function for a widget should return `TRUE`
	// if moving in @direction left the focus on a focusable location inside
	// that widget, and `FALSE` if moving in @direction moved the focus outside
	// the widget. When returning `TRUE`, widgets normallycall
	// [method@Gtk.Widget.grab_focus] to place the focus accordingly; when
	// returning `FALSE`, they don’t modify the current focus location.
	//
	// This function is used by custom widget implementations; if you're writing
	// an app, you’d use [method@Gtk.Widget.grab_focus] to move the focus to a
	// particular widget.
	//
	// This method is inherited from Widget
	ChildFocus(direction DirectionType) bool
	// ComputeBounds computes the bounds for @widget in the coordinate space of
	// @target.
	//
	// FIXME: Explain what "bounds" are.
	//
	// If the operation is successful, true is returned. If @widget has no
	// bounds or the bounds cannot be expressed in @target's coordinate space
	// (for example if both widgets are in different windows), false is returned
	// and @bounds is set to the zero rectangle.
	//
	// It is valid for @widget and @target to be the same widget.
	//
	// This method is inherited from Widget
	ComputeBounds(target Widget) (graphene.Rect, bool)
	// ComputeExpand computes whether a container should give this widget extra
	// space when possible.
	//
	// Containers should check this, rather than looking at
	// [method@Gtk.Widget.get_hexpand] or [method@Gtk.Widget.get_vexpand].
	//
	// This function already checks whether the widget is visible, so visibility
	// does not need to be checked separately. Non-visible widgets are not
	// expanded.
	//
	// The computed expand value uses either the expand setting explicitly set
	// on the widget itself, or, if none has been explicitly set, the widget may
	// expand if some of its children do.
	//
	// This method is inherited from Widget
	ComputeExpand(orientation Orientation) bool
	// ComputePoint translates the given @point in @widget's coordinates to
	// coordinates relative to @target’s coordinate system.
	//
	// In order to perform this operation, both widgets must share a common
	// ancestor.
	//
	// This method is inherited from Widget
	ComputePoint(target Widget, point *graphene.Point) (graphene.Point, bool)
	// ComputeTransform computes a matrix suitable to describe a transformation
	// from @widget's coordinate system into @target's coordinate system.
	//
	// This method is inherited from Widget
	ComputeTransform(target Widget) (graphene.Matrix, bool)
	// Contains tests if the point at (@x, @y) is contained in @widget.
	//
	// The coordinates for (@x, @y) must be in widget coordinates, so (0, 0) is
	// assumed to be the top left of @widget's content area.
	//
	// This method is inherited from Widget
	Contains(x float64, y float64) bool
	// CreatePangoContext creates a new `PangoContext` with the appropriate font
	// map, font options, font description, and base direction for drawing text
	// for this widget.
	//
	// See also [method@Gtk.Widget.get_pango_context].
	//
	// This method is inherited from Widget
	CreatePangoContext() pango.Context
	// CreatePangoLayout creates a new `PangoLayout` with the appropriate font
	// map, font description, and base direction for drawing text for this
	// widget.
	//
	// If you keep a `PangoLayout` created in this way around, you need to
	// re-create it when the widget `PangoContext` is replaced. This can be
	// tracked by listening to changes of the [property@Gtk.Widget:root]
	// property on the widget.
	//
	// This method is inherited from Widget
	CreatePangoLayout(text string) pango.Layout
	// DragCheckThreshold checks to see if a drag movement has passed the GTK
	// drag threshold.
	//
	// This method is inherited from Widget
	DragCheckThreshold(startX int, startY int, currentX int, currentY int) bool
	// ErrorBell notifies the user about an input-related error on this widget.
	//
	// If the [property@Gtk.Settings:gtk-error-bell] setting is true, it calls
	// [method@Gdk.Surface.beep], otherwise it does nothing.
	//
	// Note that the effect of [method@Gdk.Surface.beep] can be configured in
	// many ways, depending on the windowing backend and the desktop environment
	// or window manager that is used.
	//
	// This method is inherited from Widget
	ErrorBell()
	// GetAllocatedBaseline returns the baseline that has currently been
	// allocated to @widget.
	//
	// This function is intended to be used when implementing handlers for the
	// `GtkWidget`Class.snapshot() function, and when allocating child widgets
	// in `GtkWidget`Class.size_allocate().
	//
	// This method is inherited from Widget
	GetAllocatedBaseline() int
	// GetAllocatedHeight returns the height that has currently been allocated
	// to @widget.
	//
	// This method is inherited from Widget
	GetAllocatedHeight() int
	// GetAllocatedWidth returns the width that has currently been allocated to
	// @widget.
	//
	// This method is inherited from Widget
	GetAllocatedWidth() int
	// GetAncestor gets the first ancestor of @widget with type @widget_type.
	//
	// For example, `gtk_widget_get_ancestor (widget, GTK_TYPE_BOX)` gets the
	// first `GtkBox` that’s an ancestor of @widget. No reference will be added
	// to the returned widget; it should not be unreferenced.
	//
	// Note that unlike [method@Gtk.Widget.is_ancestor], this function considers
	// @widget to be an ancestor of itself.
	//
	// This method is inherited from Widget
	GetAncestor(widgetType externglib.Type) Widget
	// GetCanFocus determines whether the input focus can enter @widget or any
	// of its children.
	//
	// See [method@Gtk.Widget.set_focusable].
	//
	// This method is inherited from Widget
	GetCanFocus() bool
	// GetCanTarget queries whether @widget can be the target of pointer events.
	//
	// This method is inherited from Widget
	GetCanTarget() bool
	// GetChildVisible gets the value set with gtk_widget_set_child_visible().
	//
	// If you feel a need to use this function, your code probably needs
	// reorganization.
	//
	// This function is only useful for container implementations and should
	// never be called by an application.
	//
	// This method is inherited from Widget
	GetChildVisible() bool
	// GetClipboard gets the clipboard object for @widget.
	//
	// This is a utility function to get the clipboard object for the
	// `GdkDisplay` that @widget is using.
	//
	// Note that this function always works, even when @widget is not realized
	// yet.
	//
	// This method is inherited from Widget
	GetClipboard() gdk.Clipboard
	// GetCSSClasses returns the list of style classes applied to @widget.
	//
	// This method is inherited from Widget
	GetCSSClasses() []string
	// GetCSSName returns the CSS name that is used for @self.
	//
	// This method is inherited from Widget
	GetCSSName() string
	// GetCursor queries the cursor set on @widget.
	//
	// See [method@Gtk.Widget.set_cursor] for details.
	//
	// This method is inherited from Widget
	GetCursor() gdk.Cursor
	// GetDirection gets the reading direction for a particular widget.
	//
	// See [method@Gtk.Widget.set_direction].
	//
	// This method is inherited from Widget
	GetDirection() TextDirection
	// GetDisplay: get the `GdkDisplay` for the toplevel window associated with
	// this widget.
	//
	// This function can only be called after the widget has been added to a
	// widget hierarchy with a `GtkWindow` at the top.
	//
	// In general, you should only create display specific resources when a
	// widget has been realized, and you should free those resources when the
	// widget is unrealized.
	//
	// This method is inherited from Widget
	GetDisplay() gdk.Display
	// GetFirstChild returns the widgets first child.
	//
	// This API is primarily meant for widget implementations.
	//
	// This method is inherited from Widget
	GetFirstChild() Widget
	// GetFocusChild returns the current focus child of @widget.
	//
	// This method is inherited from Widget
	GetFocusChild() Widget
	// GetFocusOnClick returns whether the widget should grab focus when it is
	// clicked with the mouse.
	//
	// See [method@Gtk.Widget.set_focus_on_click].
	//
	// This method is inherited from Widget
	GetFocusOnClick() bool
	// GetFocusable determines whether @widget can own the input focus.
	//
	// See [method@Gtk.Widget.set_focusable].
	//
	// This method is inherited from Widget
	GetFocusable() bool
	// GetFontMap gets the font map of @widget.
	//
	// See [method@Gtk.Widget.set_font_map].
	//
	// This method is inherited from Widget
	GetFontMap() pango.FontMap
	// GetFontOptions returns the `cairo_font_options_t` used for Pango
	// rendering.
	//
	// When not set, the defaults font options for the `GdkDisplay` will be
	// used.
	//
	// This method is inherited from Widget
	GetFontOptions() *cairo.FontOptions
	// GetFrameClock obtains the frame clock for a widget.
	//
	// The frame clock is a global “ticker” that can be used to drive animations
	// and repaints. The most common reason to get the frame clock is to call
	// [method@Gdk.FrameClock.get_frame_time], in order to get a time to use for
	// animating. For example you might record the start of the animation with
	// an initial value from [method@Gdk.FrameClock.get_frame_time], and then
	// update the animation by calling [method@Gdk.FrameClock.get_frame_time]
	// again during each repaint.
	//
	// [method@Gdk.FrameClock.request_phase] will result in a new frame on the
	// clock, but won’t necessarily repaint any widgets. To repaint a widget,
	// you have to use [method@Gtk.Widget.queue_draw] which invalidates the
	// widget (thus scheduling it to receive a draw on the next frame).
	// gtk_widget_queue_draw() will also end up requesting a frame on the
	// appropriate frame clock.
	//
	// A widget’s frame clock will not change while the widget is mapped.
	// Reparenting a widget (which implies a temporary unmap) can change the
	// widget’s frame clock.
	//
	// Unrealized widgets do not have a frame clock.
	//
	// This method is inherited from Widget
	GetFrameClock() gdk.FrameClock
	// GetHAlign gets the horizontal alignment of @widget.
	//
	// For backwards compatibility reasons this method will never return
	// GTK_ALIGN_BASELINE, but instead it will convert it to GTK_ALIGN_FILL.
	// Baselines are not supported for horizontal alignment.
	//
	// This method is inherited from Widget
	GetHAlign() Align
	// GetHasTooltip returns the current value of the `has-tooltip` property.
	//
	// This method is inherited from Widget
	GetHasTooltip() bool
	// GetHeight returns the content height of the widget.
	//
	// This function returns the size passed to its size-allocate
	// implementation, which is the size you should be using in
	// GtkWidgetClass.snapshot().
	//
	// For pointer events, see [method@Gtk.Widget.contains].
	//
	// This method is inherited from Widget
	GetHeight() int
	// GetHExpand gets whether the widget would like any available extra
	// horizontal space.
	//
	// When a user resizes a `GtkWindow`, widgets with expand=TRUE generally
	// receive the extra space. For example, a list or scrollable area or
	// document in your window would often be set to expand.
	//
	// Containers should use [method@Gtk.Widget.compute_expand] rather than this
	// function, to see whether a widget, or any of its children, has the expand
	// flag set. If any child of a widget wants to expand, the parent may ask to
	// expand also.
	//
	// This function only looks at the widget’s own hexpand flag, rather than
	// computing whether the entire widget tree rooted at this widget wants to
	// expand.
	//
	// This method is inherited from Widget
	GetHExpand() bool
	// GetHExpandSet gets whether gtk_widget_set_hexpand() has been used to
	// explicitly set the expand flag on this widget.
	//
	// If [property@Gtk.Widget:hexpand] property is set, then it overrides any
	// computed expand value based on child widgets. If `hexpand` is not set,
	// then the expand value depends on whether any children of the widget would
	// like to expand.
	//
	// There are few reasons to use this function, but it’s here for
	// completeness and consistency.
	//
	// This method is inherited from Widget
	GetHExpandSet() bool
	// GetLastChild returns the widgets last child.
	//
	// This API is primarily meant for widget implementations.
	//
	// This method is inherited from Widget
	GetLastChild() Widget
	// GetLayoutManager retrieves the layout manager used by @widget
	//
	// See [method@Gtk.Widget.set_layout_manager].
	//
	// This method is inherited from Widget
	GetLayoutManager() LayoutManager
	// GetMapped: whether the widget is mapped.
	//
	// This method is inherited from Widget
	GetMapped() bool
	// GetMarginBottom gets the bottom margin of @widget.
	//
	// This method is inherited from Widget
	GetMarginBottom() int
	// GetMarginEnd gets the end margin of @widget.
	//
	// This method is inherited from Widget
	GetMarginEnd() int
	// GetMarginStart gets the start margin of @widget.
	//
	// This method is inherited from Widget
	GetMarginStart() int
	// GetMarginTop gets the top margin of @widget.
	//
	// This method is inherited from Widget
	GetMarginTop() int
	// GetName retrieves the name of a widget.
	//
	// See [method@Gtk.Widget.set_name] for the significance of widget names.
	//
	// This method is inherited from Widget
	GetName() string
	// GetNative returns the `GtkNative` widget that contains @widget.
	//
	// This function will return nil if the widget is not contained inside a
	// widget tree with a native ancestor.
	//
	// `GtkNative` widgets will return themselves here.
	//
	// This method is inherited from Widget
	GetNative() Native
	// GetNextSibling returns the widgets next sibling.
	//
	// This API is primarily meant for widget implementations.
	//
	// This method is inherited from Widget
	GetNextSibling() Widget
	// GetOpacity the requested opacity for this widget.
	//
	// See [method@Gtk.Widget.set_opacity].
	//
	// This method is inherited from Widget
	GetOpacity() float64
	// GetOverflow returns the widgets overflow value.
	//
	// This method is inherited from Widget
	GetOverflow() Overflow
	// GetPangoContext gets a `PangoContext` with the appropriate font map, font
	// description, and base direction for this widget.
	//
	// Unlike the context returned by [method@Gtk.Widget.create_pango_context],
	// this context is owned by the widget (it can be used until the screen for
	// the widget changes or the widget is removed from its toplevel), and will
	// be updated to match any changes to the widget’s attributes. This can be
	// tracked by listening to changes of the [property@Gtk.Widget:root]
	// property on the widget.
	//
	// This method is inherited from Widget
	GetPangoContext() pango.Context
	// GetParent returns the parent widget of @widget.
	//
	// This method is inherited from Widget
	GetParent() Widget
	// GetPreferredSize retrieves the minimum and natural size of a widget,
	// taking into account the widget’s preference for height-for-width
	// management.
	//
	// This is used to retrieve a suitable size by container widgets which do
	// not impose any restrictions on the child placement. It can be used to
	// deduce toplevel window and menu sizes as well as child widgets in
	// free-form containers such as `GtkFixed`.
	//
	// Handle with care. Note that the natural height of a height-for-width
	// widget will generally be a smaller size than the minimum height, since
	// the required height for the natural width is generally smaller than the
	// required height for the minimum width.
	//
	// Use [id@gtk_widget_measure] if you want to support baseline alignment.
	//
	// This method is inherited from Widget
	GetPreferredSize() (minimumSize Requisition, naturalSize Requisition)
	// GetPrevSibling returns the widgets previous sibling.
	//
	// This API is primarily meant for widget implementations.
	//
	// This method is inherited from Widget
	GetPrevSibling() Widget
	// GetPrimaryClipboard gets the primary clipboard of @widget.
	//
	// This is a utility function to get the primary clipboard object for the
	// `GdkDisplay` that @widget is using.
	//
	// Note that this function always works, even when @widget is not realized
	// yet.
	//
	// This method is inherited from Widget
	GetPrimaryClipboard() gdk.Clipboard
	// GetRealized determines whether @widget is realized.
	//
	// This method is inherited from Widget
	GetRealized() bool
	// GetReceivesDefault determines whether @widget is always treated as the
	// default widget within its toplevel when it has the focus, even if another
	// widget is the default.
	//
	// See [method@Gtk.Widget.set_receives_default].
	//
	// This method is inherited from Widget
	GetReceivesDefault() bool
	// GetRequestMode gets whether the widget prefers a height-for-width layout
	// or a width-for-height layout.
	//
	// Single-child widgets generally propagate the preference of their child,
	// more complex widgets need to request something either in context of their
	// children or in context of their allocation capabilities.
	//
	// This method is inherited from Widget
	GetRequestMode() SizeRequestMode
	// GetRoot returns the `GtkRoot` widget of @widget.
	//
	// This function will return nil if the widget is not contained inside a
	// widget tree with a root widget.
	//
	// `GtkRoot` widgets will return themselves here.
	//
	// This method is inherited from Widget
	GetRoot() Root
	// GetScaleFactor retrieves the internal scale factor that maps from window
	// coordinates to the actual device pixels.
	//
	// On traditional systems this is 1, on high density outputs, it can be a
	// higher value (typically 2).
	//
	// See [method@Gdk.Surface.get_scale_factor].
	//
	// This method is inherited from Widget
	GetScaleFactor() int
	// GetSensitive returns the widget’s sensitivity.
	//
	// This function returns the value that has been set using
	// [method@Gtk.Widget.set_sensitive]).
	//
	// The effective sensitivity of a widget is however determined by both its
	// own and its parent widget’s sensitivity. See
	// [method@Gtk.Widget.is_sensitive].
	//
	// This method is inherited from Widget
	GetSensitive() bool
	// GetSettings gets the settings object holding the settings used for this
	// widget.
	//
	// Note that this function can only be called when the `GtkWidget` is
	// attached to a toplevel, since the settings object is specific to a
	// particular `GdkDisplay`. If you want to monitor the widget for changes in
	// its settings, connect to notify::display.
	//
	// This method is inherited from Widget
	GetSettings() Settings
	// GetSize returns the content width or height of the widget.
	//
	// Which dimension is returned depends on @orientation.
	//
	// This is equivalent to calling [method@Gtk.Widget.get_width] for
	// GTK_ORIENTATION_HORIZONTAL or [method@Gtk.Widget.get_height] for
	// GTK_ORIENTATION_VERTICAL, but can be used when writing
	// orientation-independent code, such as when implementing
	// [iface@Gtk.Orientable] widgets.
	//
	// This method is inherited from Widget
	GetSize(orientation Orientation) int
	// GetSizeRequest gets the size request that was explicitly set for the
	// widget using gtk_widget_set_size_request().
	//
	// A value of -1 stored in @width or @height indicates that that dimension
	// has not been set explicitly and the natural requisition of the widget
	// will be used instead. See [method@Gtk.Widget.set_size_request]. To get
	// the size a widget will actually request, call [method@Gtk.Widget.measure]
	// instead of this function.
	//
	// This method is inherited from Widget
	GetSizeRequest() (width int, height int)
	// GetStateFlags returns the widget state as a flag set.
	//
	// It is worth mentioning that the effective GTK_STATE_FLAG_INSENSITIVE
	// state will be returned, that is, also based on parent insensitivity, even
	// if @widget itself is sensitive.
	//
	// Also note that if you are looking for a way to obtain the
	// [flags@Gtk.StateFlags] to pass to a [class@Gtk.StyleContext] method, you
	// should look at [method@Gtk.StyleContext.get_state].
	//
	// This method is inherited from Widget
	GetStateFlags() StateFlags
	// GetStyleContext returns the style context associated to @widget.
	//
	// The returned object is guaranteed to be the same for the lifetime of
	// @widget.
	//
	// This method is inherited from Widget
	GetStyleContext() StyleContext
	// GetTemplateChild: fetch an object build from the template XML for
	// @widget_type in this @widget instance.
	//
	// This will only report children which were previously declared with
	// [method@Gtk.WidgetClass.bind_template_child_full] or one of its variants.
	//
	// This function is only meant to be called for code which is private to the
	// @widget_type which declared the child and is meant for language bindings
	// which cannot easily make use of the GObject structure offsets.
	//
	// This method is inherited from Widget
	GetTemplateChild(widgetType externglib.Type, name string) gextras.Objector
	// GetTooltipMarkup gets the contents of the tooltip for @widget.
	//
	// If the tooltip has not been set using
	// [method@Gtk.Widget.set_tooltip_markup], this function returns nil.
	//
	// This method is inherited from Widget
	GetTooltipMarkup() string
	// GetTooltipText gets the contents of the tooltip for @widget.
	//
	// If the @widget's tooltip was set using
	// [method@Gtk.Widget.set_tooltip_markup], this function will return the
	// escaped text.
	//
	// This method is inherited from Widget
	GetTooltipText() string
	// GetVAlign gets the vertical alignment of @widget.
	//
	// This method is inherited from Widget
	GetVAlign() Align
	// GetVExpand gets whether the widget would like any available extra
	// vertical space.
	//
	// See [method@Gtk.Widget.get_hexpand] for more detail.
	//
	// This method is inherited from Widget
	GetVExpand() bool
	// GetVExpandSet gets whether gtk_widget_set_vexpand() has been used to
	// explicitly set the expand flag on this widget.
	//
	// See [method@Gtk.Widget.get_hexpand_set] for more detail.
	//
	// This method is inherited from Widget
	GetVExpandSet() bool
	// GetVisible determines whether the widget is visible.
	//
	// If you want to take into account whether the widget’s parent is also
	// marked as visible, use [method@Gtk.Widget.is_visible] instead.
	//
	// This function does not check if the widget is obscured in any way.
	//
	// See [method@Gtk.Widget.set_visible].
	//
	// This method is inherited from Widget
	GetVisible() bool
	// GetWidth returns the content width of the widget.
	//
	// This function returns the size passed to its size-allocate
	// implementation, which is the size you should be using in
	// GtkWidgetClass.snapshot().
	//
	// For pointer events, see [method@Gtk.Widget.contains].
	//
	// This method is inherited from Widget
	GetWidth() int
	// GrabFocus causes @widget to have the keyboard focus for the `GtkWindow`
	// it's inside.
	//
	// If @widget is not focusable, or its ::grab_focus implementation cannot
	// transfer the focus to a descendant of @widget that is focusable, it will
	// not take focus and false will be returned.
	//
	// Calling [method@Gtk.Widget.grab_focus] on an already focused widget is
	// allowed, should not have an effect, and return true.
	//
	// This method is inherited from Widget
	GrabFocus() bool
	// HasCSSClass returns whether @css_class is currently applied to @widget.
	//
	// This method is inherited from Widget
	HasCSSClass(cssClass string) bool
	// HasDefault determines whether @widget is the current default widget
	// within its toplevel.
	//
	// This method is inherited from Widget
	HasDefault() bool
	// HasFocus determines if the widget has the global input focus.
	//
	// See [method@Gtk.Widget.is_focus] for the difference between having the
	// global input focus, and only having the focus within a toplevel.
	//
	// This method is inherited from Widget
	HasFocus() bool
	// HasVisibleFocus determines if the widget should show a visible indication
	// that it has the global input focus.
	//
	// This is a convenience function that takes into account whether focus
	// indication should currently be shown in the toplevel window of @widget.
	// See [method@Gtk.Window.get_focus_visible] for more information about
	// focus indication.
	//
	// To find out if the widget has the global input focus, use
	// [method@Gtk.Widget.has_focus].
	//
	// This method is inherited from Widget
	HasVisibleFocus() bool
	// Hide reverses the effects of gtk_widget_show().
	//
	// This is causing the widget to be hidden (invisible to the user).
	//
	// This method is inherited from Widget
	Hide()
	// InDestruction returns whether the widget is currently being destroyed.
	//
	// This information can sometimes be used to avoid doing unnecessary work.
	//
	// This method is inherited from Widget
	InDestruction() bool
	// InitTemplate creates and initializes child widgets defined in templates.
	//
	// This function must be called in the instance initializer for any class
	// which assigned itself a template using
	// [method@Gtk.WidgetClass.set_template].
	//
	// It is important to call this function in the instance initializer of a
	// `GtkWidget` subclass and not in `GObject.constructed()` or
	// `GObject.constructor()` for two reasons:
	//
	//    - derived widgets will assume that the composite widgets
	//      defined by its parent classes have been created in their
	//      relative instance initializers
	//    - when calling `g_object_new()` on a widget with composite templates,
	//      it’s important to build the composite widgets before the construct
	//      properties are set. Properties passed to `g_object_new()` should
	//      take precedence over properties set in the private template XML
	//
	// A good rule of thumb is to call this function as the first thing in an
	// instance initialization function.
	//
	// This method is inherited from Widget
	InitTemplate()
	// InsertAfter inserts @widget into the child widget list of @parent.
	//
	// It will be placed after @previous_sibling, or at the beginning if
	// @previous_sibling is nil.
	//
	// After calling this function, `gtk_widget_get_prev_sibling(widget)` will
	// return @previous_sibling.
	//
	// If @parent is already set as the parent widget of @widget, this function
	// can also be used to reorder @widget in the child widget list of @parent.
	//
	// This API is primarily meant for widget implementations; if you are just
	// using a widget, you *must* use its own API for adding children.
	//
	// This method is inherited from Widget
	InsertAfter(parent Widget, previousSibling Widget)
	// InsertBefore inserts @widget into the child widget list of @parent.
	//
	// It will be placed before @next_sibling, or at the end if @next_sibling is
	// nil.
	//
	// After calling this function, `gtk_widget_get_next_sibling(widget)` will
	// return @next_sibling.
	//
	// If @parent is already set as the parent widget of @widget, this function
	// can also be used to reorder @widget in the child widget list of @parent.
	//
	// This API is primarily meant for widget implementations; if you are just
	// using a widget, you *must* use its own API for adding children.
	//
	// This method is inherited from Widget
	InsertBefore(parent Widget, nextSibling Widget)
	// IsAncestor determines whether @widget is somewhere inside @ancestor,
	// possibly with intermediate containers.
	//
	// This method is inherited from Widget
	IsAncestor(ancestor Widget) bool
	// IsDrawable determines whether @widget can be drawn to.
	//
	// A widget can be drawn if it is mapped and visible.
	//
	// This method is inherited from Widget
	IsDrawable() bool
	// IsFocus determines if the widget is the focus widget within its toplevel.
	//
	// This does not mean that the [property@Gtk.Widget:has-focus] property is
	// necessarily set; [property@Gtk,Widget:has-focus] will only be set if the
	// toplevel widget additionally has the global input focus.)
	//
	// This method is inherited from Widget
	IsFocus() bool
	// IsSensitive returns the widget’s effective sensitivity.
	//
	// This means it is sensitive itself and also its parent widget is
	// sensitive.
	//
	// This method is inherited from Widget
	IsSensitive() bool
	// IsVisible determines whether the widget and all its parents are marked as
	// visible.
	//
	// This function does not check if the widget is obscured in any way.
	//
	// See also [method@Gtk.Widget.get_visible] and
	// [method@Gtk.Widget.set_visible].
	//
	// This method is inherited from Widget
	IsVisible() bool
	// KeynavFailed emits the `::keynav-failed` signal on the widget.
	//
	// This function should be called whenever keyboard navigation within a
	// single widget hits a boundary.
	//
	// The return value of this function should be interpreted in a way similar
	// to the return value of [method@Gtk.Widget.child_focus]. When true is
	// returned, stay in the widget, the failed keyboard navigation is OK and/or
	// there is nowhere we can/should move the focus to. When false is returned,
	// the caller should continue with keyboard navigation outside the widget,
	// e.g. by calling [method@Gtk.Widget.child_focus] on the widget’s toplevel.
	//
	// The default [signal@Gtk.Widget::keynav-failed] handler returns false for
	// GTK_DIR_TAB_FORWARD and GTK_DIR_TAB_BACKWARD. For the other values of
	// DirectionType it returns true.
	//
	// Whenever the default handler returns true, it also calls
	// [method@Gtk.Widget.error_bell] to notify the user of the failed keyboard
	// navigation.
	//
	// A use case for providing an own implementation of ::keynav-failed (either
	// by connecting to it or by overriding it) would be a row of
	// [class@Gtk.Entry] widgets where the user should be able to navigate the
	// entire row with the cursor keys, as e.g. known from user interfaces that
	// require entering license keys.
	//
	// This method is inherited from Widget
	KeynavFailed(direction DirectionType) bool
	// Map causes a widget to be mapped if it isn’t already.
	//
	// This function is only for use in widget implementations.
	//
	// This method is inherited from Widget
	Map()
	// Measure measures @widget in the orientation @orientation and for the
	// given @for_size.
	//
	// As an example, if @orientation is GTK_ORIENTATION_HORIZONTAL and
	// @for_size is 300, this functions will compute the minimum and natural
	// width of @widget if it is allocated at a height of 300 pixels.
	//
	// See GtkWidget’s geometry management section
	// (class.Widget.html#height-for-width-geometry-management) for a more
	// details on implementing WidgetClass.measure().
	//
	// This method is inherited from Widget
	Measure(orientation Orientation, forSize int) (minimum int, natural int, minimumBaseline int, naturalBaseline int)
	// MnemonicActivate emits the `GtkWidget`::mnemonic-activate signal.
	//
	// This method is inherited from Widget
	MnemonicActivate(groupCycling bool) bool
	// Pick finds the descendant of @widget closest to the screen at the point
	// (@x, @y).
	//
	// The point must be given in widget coordinates, so (0, 0) is assumed to be
	// the top left of @widget's content area.
	//
	// Usually widgets will return nil if the given coordinate is not contained
	// in @widget checked via [method@Gtk.Widget.contains]. Otherwise they will
	// recursively try to find a child that does not return nil. Widgets are
	// however free to customize their picking algorithm.
	//
	// This function is used on the toplevel to determine the widget below the
	// mouse cursor for purposes of hover highlighting and delivering events.
	//
	// This method is inherited from Widget
	Pick(x float64, y float64, flags PickFlags) Widget
	// QueueAllocate flags the widget for a rerun of the
	// GtkWidgetClass::size_allocate function.
	//
	// Use this function instead of [method@Gtk.Widget.queue_resize] when the
	// @widget's size request didn't change but it wants to reposition its
	// contents.
	//
	// An example user of this function is [method@Gtk.Widget.set_halign].
	//
	// This function is only for use in widget implementations.
	//
	// This method is inherited from Widget
	QueueAllocate()
	// QueueDraw schedules this widget to be redrawn in paint phase of the
	// current or the next frame.
	//
	// This means @widget's GtkWidgetClass.snapshot() implementation will be
	// called.
	//
	// This method is inherited from Widget
	QueueDraw()
	// QueueResize flags a widget to have its size renegotiated.
	//
	// This should be called when a widget for some reason has a new size
	// request. For example, when you change the text in a [class@Gtk.Label],
	// the label queues a resize to ensure there’s enough space for the new
	// text.
	//
	// Note that you cannot call gtk_widget_queue_resize() on a widget from
	// inside its implementation of the GtkWidgetClass::size_allocate virtual
	// method. Calls to gtk_widget_queue_resize() from inside
	// GtkWidgetClass::size_allocate will be silently ignored.
	//
	// This function is only for use in widget implementations.
	//
	// This method is inherited from Widget
	QueueResize()
	// Realize creates the GDK resources associated with a widget.
	//
	// Normally realization happens implicitly; if you show a widget and all its
	// parent containers, then the widget will be realized and mapped
	// automatically.
	//
	// Realizing a widget requires all the widget’s parent widgets to be
	// realized; calling this function realizes the widget’s parents in addition
	// to @widget itself. If a widget is not yet inside a toplevel window when
	// you realize it, bad things will happen.
	//
	// This function is primarily used in widget implementations, and isn’t very
	// useful otherwise. Many times when you think you might need it, a better
	// approach is to connect to a signal that will be called after the widget
	// is realized automatically, such as [signal@Gtk.Widget::realize].
	//
	// This method is inherited from Widget
	Realize()
	// RemoveController removes @controller from @widget, so that it doesn't
	// process events anymore.
	//
	// It should not be used again.
	//
	// Widgets will remove all event controllers automatically when they are
	// destroyed, there is normally no need to call this function.
	//
	// This method is inherited from Widget
	RemoveController(controller EventController)
	// RemoveCSSClass removes a style from @widget.
	//
	// After this, the style of @widget will stop matching for @css_class.
	//
	// This method is inherited from Widget
	RemoveCSSClass(cssClass string)
	// RemoveMnemonicLabel removes a widget from the list of mnemonic labels for
	// this widget.
	//
	// See [method@Gtk.Widget.list_mnemonic_labels]. The widget must have
	// previously been added to the list with
	// [method@Gtk.Widget.add_mnemonic_label].
	//
	// This method is inherited from Widget
	RemoveMnemonicLabel(label Widget)
	// RemoveTickCallback removes a tick callback previously registered with
	// gtk_widget_add_tick_callback().
	//
	// This method is inherited from Widget
	RemoveTickCallback(id uint)
	// SetCanFocus specifies whether the input focus can enter the widget or any
	// of its children.
	//
	// Applications should set @can_focus to false to mark a widget as for
	// pointer/touch use only.
	//
	// Note that having @can_focus be true is only one of the necessary
	// conditions for being focusable. A widget must also be sensitive and
	// focusable and not have an ancestor that is marked as not can-focus in
	// order to receive input focus.
	//
	// See [method@Gtk.Widget.grab_focus] for actually setting the input focus
	// on a widget.
	//
	// This method is inherited from Widget
	SetCanFocus(canFocus bool)
	// SetCanTarget sets whether @widget can be the target of pointer events.
	//
	// This method is inherited from Widget
	SetCanTarget(canTarget bool)
	// SetChildVisible sets whether @widget should be mapped along with its
	// parent.
	//
	// The child visibility can be set for widget before it is added to a
	// container with [method@Gtk.Widget.set_parent], to avoid mapping children
	// unnecessary before immediately unmapping them. However it will be reset
	// to its default state of true when the widget is removed from a container.
	//
	// Note that changing the child visibility of a widget does not queue a
	// resize on the widget. Most of the time, the size of a widget is computed
	// from all visible children, whether or not they are mapped. If this is not
	// the case, the container can queue a resize itself.
	//
	// This function is only useful for container implementations and should
	// never be called by an application.
	//
	// This method is inherited from Widget
	SetChildVisible(childVisible bool)
	// SetCSSClasses: will clear all style classes applied to @widget and
	// replace them with @classes.
	//
	// This method is inherited from Widget
	SetCSSClasses(classes []string)
	// SetCursor sets the cursor to be shown when pointer devices point towards
	// @widget.
	//
	// If the @cursor is NULL, @widget will use the cursor inherited from the
	// parent widget.
	//
	// This method is inherited from Widget
	SetCursor(cursor gdk.Cursor)
	// SetCursorFromName sets a named cursor to be shown when pointer devices
	// point towards @widget.
	//
	// This is a utility function that creates a cursor via
	// [ctor@Gdk.Cursor.new_from_name] and then sets it on @widget with
	// [method@Gtk.Widget.set_cursor]. See those functions for details.
	//
	// On top of that, this function allows @name to be nil, which will do the
	// same as calling [method@Gtk.Widget.set_cursor] with a nil cursor.
	//
	// This method is inherited from Widget
	SetCursorFromName(name string)
	// SetDirection sets the reading direction on a particular widget.
	//
	// This direction controls the primary direction for widgets containing
	// text, and also the direction in which the children of a container are
	// packed. The ability to set the direction is present in order so that
	// correct localization into languages with right-to-left reading directions
	// can be done. Generally, applications will let the default reading
	// direction present, except for containers where the containers are
	// arranged in an order that is explicitly visual rather than logical (such
	// as buttons for text justification).
	//
	// If the direction is set to GTK_TEXT_DIR_NONE, then the value set by
	// [func@Gtk.Widget.set_default_direction] will be used.
	//
	// This method is inherited from Widget
	SetDirection(dir TextDirection)
	// SetFocusChild: set @child as the current focus child of @widget.
	//
	// The previous focus child will be unset.
	//
	// This function is only suitable for widget implementations. If you want a
	// certain widget to get the input focus, call
	// [method@Gtk.Widget.grab_focus] on it.
	//
	// This method is inherited from Widget
	SetFocusChild(child Widget)
	// SetFocusOnClick sets whether the widget should grab focus when it is
	// clicked with the mouse.
	//
	// Making mouse clicks not grab focus is useful in places like toolbars
	// where you don’t want the keyboard focus removed from the main area of the
	// application.
	//
	// This method is inherited from Widget
	SetFocusOnClick(focusOnClick bool)
	// SetFocusable specifies whether @widget can own the input focus.
	//
	// Widget implementations should set @focusable to true in their init()
	// function if they want to receive keyboard input.
	//
	// Note that having @focusable be true is only one of the necessary
	// conditions for being focusable. A widget must also be sensitive and
	// can-focus and not have an ancestor that is marked as not can-focus in
	// order to receive input focus.
	//
	// See [method@Gtk.Widget.grab_focus] for actually setting the input focus
	// on a widget.
	//
	// This method is inherited from Widget
	SetFocusable(focusable bool)
	// SetFontMap sets the font map to use for Pango rendering.
	//
	// The font map is the object that is used to look up fonts. Setting a
	// custom font map can be useful in special situations, e.g. when you need
	// to add application-specific fonts to the set of available fonts.
	//
	// When not set, the widget will inherit the font map from its parent.
	//
	// This method is inherited from Widget
	SetFontMap(fontMap pango.FontMap)
	// SetFontOptions sets the `cairo_font_options_t` used for Pango rendering
	// in this widget.
	//
	// When not set, the default font options for the `GdkDisplay` will be used.
	//
	// This method is inherited from Widget
	SetFontOptions(options *cairo.FontOptions)
	// SetHAlign sets the horizontal alignment of @widget.
	//
	// This method is inherited from Widget
	SetHAlign(align Align)
	// SetHasTooltip sets the `has-tooltip` property on @widget to @has_tooltip.
	//
	// This method is inherited from Widget
	SetHasTooltip(hasTooltip bool)
	// SetHExpand sets whether the widget would like any available extra
	// horizontal space.
	//
	// When a user resizes a `GtkWindow`, widgets with expand=TRUE generally
	// receive the extra space. For example, a list or scrollable area or
	// document in your window would often be set to expand.
	//
	// Call this function to set the expand flag if you would like your widget
	// to become larger horizontally when the window has extra room.
	//
	// By default, widgets automatically expand if any of their children want to
	// expand. (To see if a widget will automatically expand given its current
	// children and state, call [method@Gtk.Widget.compute_expand]. A container
	// can decide how the expandability of children affects the expansion of the
	// container by overriding the compute_expand virtual method on
	// `GtkWidget`.).
	//
	// Setting hexpand explicitly with this function will override the automatic
	// expand behavior.
	//
	// This function forces the widget to expand or not to expand, regardless of
	// children. The override occurs because [method@Gtk.Widget.set_hexpand]
	// sets the hexpand-set property (see [method@Gtk.Widget.set_hexpand_set])
	// which causes the widget’s hexpand value to be used, rather than looking
	// at children and widget state.
	//
	// This method is inherited from Widget
	SetHExpand(expand bool)
	// SetHExpandSet sets whether the hexpand flag will be used.
	//
	// The [property@Gtk.Widget:hexpand-set] property will be set automatically
	// when you call [method@Gtk.Widget.set_hexpand] to set hexpand, so the most
	// likely reason to use this function would be to unset an explicit expand
	// flag.
	//
	// If hexpand is set, then it overrides any computed expand value based on
	// child widgets. If hexpand is not set, then the expand value depends on
	// whether any children of the widget would like to expand.
	//
	// There are few reasons to use this function, but it’s here for
	// completeness and consistency.
	//
	// This method is inherited from Widget
	SetHExpandSet(set bool)
	// SetLayoutManager sets the layout manager delegate instance that provides
	// an implementation for measuring and allocating the children of @widget.
	//
	// This method is inherited from Widget
	SetLayoutManager(layoutManager LayoutManager)
	// SetMarginBottom sets the bottom margin of @widget.
	//
	// This method is inherited from Widget
	SetMarginBottom(margin int)
	// SetMarginEnd sets the end margin of @widget.
	//
	// This method is inherited from Widget
	SetMarginEnd(margin int)
	// SetMarginStart sets the start margin of @widget.
	//
	// This method is inherited from Widget
	SetMarginStart(margin int)
	// SetMarginTop sets the top margin of @widget.
	//
	// This method is inherited from Widget
	SetMarginTop(margin int)
	// SetName sets a widgets name.
	//
	// Setting a name allows you to refer to the widget from a CSS file. You can
	// apply a style to widgets with a particular name in the CSS file. See the
	// documentation for the CSS syntax (on the same page as the docs for
	// [class@Gtk.StyleContext].
	//
	// Note that the CSS syntax has certain special characters to delimit and
	// represent elements in a selector (period, #, >, *...), so using these
	// will make your widget impossible to match by name. Any combination of
	// alphanumeric symbols, dashes and underscores will suffice.
	//
	// This method is inherited from Widget
	SetName(name string)
	// SetOpacity: request the @widget to be rendered partially transparent.
	//
	// An opacity of 0 is fully transparent and an opacity of 1 is fully opaque.
	//
	// Opacity works on both toplevel widgets and child widgets, although there
	// are some limitations: For toplevel widgets, applying opacity depends on
	// the capabilities of the windowing system. On X11, this has any effect
	// only on X displays with a compositing manager, see
	// gdk_display_is_composited(). On Windows and Wayland it should always
	// work, although setting a window’s opacity after the window has been shown
	// may cause some flicker.
	//
	// Note that the opacity is inherited through inclusion — if you set a
	// toplevel to be partially translucent, all of its content will appear
	// translucent, since it is ultimatively rendered on that toplevel. The
	// opacity value itself is not inherited by child widgets (since that would
	// make widgets deeper in the hierarchy progressively more translucent). As
	// a consequence, [class@Gtk.Popover]s and other [class@Gtk.Native] widgets
	// with their own surface will use their own opacity value, and thus by
	// default appear non-translucent, even if they are attached to a toplevel
	// that is translucent.
	//
	// This method is inherited from Widget
	SetOpacity(opacity float64)
	// SetOverflow sets how @widget treats content that is drawn outside the
	// widget's content area.
	//
	// See the definition of [enum@Gtk.Overflow] for details.
	//
	// This setting is provided for widget implementations and should not be
	// used by application code.
	//
	// The default value is GTK_OVERFLOW_VISIBLE.
	//
	// This method is inherited from Widget
	SetOverflow(overflow Overflow)
	// SetParent sets @parent as the parent widget of @widget.
	//
	// This takes care of details such as updating the state and style of the
	// child to reflect its new location and resizing the parent. The opposite
	// function is [method@Gtk.Widget.unparent].
	//
	// This function is useful only when implementing subclasses of `GtkWidget`.
	//
	// This method is inherited from Widget
	SetParent(parent Widget)
	// SetReceivesDefault specifies whether @widget will be treated as the
	// default widget within its toplevel when it has the focus, even if another
	// widget is the default.
	//
	// This method is inherited from Widget
	SetReceivesDefault(receivesDefault bool)
	// SetSensitive sets the sensitivity of a widget.
	//
	// A widget is sensitive if the user can interact with it. Insensitive
	// widgets are “grayed out” and the user can’t interact with them.
	// Insensitive widgets are known as “inactive”, “disabled”, or “ghosted” in
	// some other toolkits.
	//
	// This method is inherited from Widget
	SetSensitive(sensitive bool)
	// SetSizeRequest sets the minimum size of a widget.
	//
	// That is, the widget’s size request will be at least @width by @height.
	// You can use this function to force a widget to be larger than it normally
	// would be.
	//
	// In most cases, [method@Gtk.Window.set_default_size] is a better choice
	// for toplevel windows than this function; setting the default size will
	// still allow users to shrink the window. Setting the size request will
	// force them to leave the window at least as large as the size request.
	//
	// Note the inherent danger of setting any fixed size - themes, translations
	// into other languages, different fonts, and user action can all change the
	// appropriate size for a given widget. So, it's basically impossible to
	// hardcode a size that will always be correct.
	//
	// The size request of a widget is the smallest size a widget can accept
	// while still functioning well and drawing itself correctly. However in
	// some strange cases a widget may be allocated less than its requested
	// size, and in many cases a widget may be allocated more space than it
	// requested.
	//
	// If the size request in a given direction is -1 (unset), then the
	// “natural” size request of the widget will be used instead.
	//
	// The size request set here does not include any margin from the properties
	// [property@Gtk.Widget:margin-start], [property@Gtk.Widget:margin-end],
	// [property@Gtk.Widget:margin-top], and
	// [property@Gtk.Widget:margin-bottom], but it does include pretty much all
	// other padding or border properties set by any subclass of `GtkWidget`.
	//
	// This method is inherited from Widget
	SetSizeRequest(width int, height int)
	// SetStateFlags turns on flag values in the current widget state.
	//
	// Typical widget states are insensitive, prelighted, etc.
	//
	// This function accepts the values GTK_STATE_FLAG_DIR_LTR and
	// GTK_STATE_FLAG_DIR_RTL but ignores them. If you want to set the widget's
	// direction, use [method@Gtk.Widget.set_direction].
	//
	// This function is for use in widget implementations.
	//
	// This method is inherited from Widget
	SetStateFlags(flags StateFlags, clear bool)
	// SetTooltipMarkup sets @markup as the contents of the tooltip, which is
	// marked up with Pango markup.
	//
	// This function will take care of setting the
	// [property@Gtk.Widget:has-tooltip] as a side effect, and of the default
	// handler for the [signal@Gtk.Widget::query-tooltip] signal.
	//
	// See also [method@Gtk.Tooltip.set_markup].
	//
	// This method is inherited from Widget
	SetTooltipMarkup(markup string)
	// SetTooltipText sets @text as the contents of the tooltip.
	//
	// If @text contains any markup, it will be escaped.
	//
	// This function will take care of setting [property@Gtk.Widget:has-tooltip]
	// as a side effect, and of the default handler for the
	// [signal@Gtk.Widget::query-tooltip] signal.
	//
	// See also [method@Gtk.Tooltip.set_text].
	//
	// This method is inherited from Widget
	SetTooltipText(text string)
	// SetVAlign sets the vertical alignment of @widget.
	//
	// This method is inherited from Widget
	SetVAlign(align Align)
	// SetVExpand sets whether the widget would like any available extra
	// vertical space.
	//
	// See [method@Gtk.Widget.set_hexpand] for more detail.
	//
	// This method is inherited from Widget
	SetVExpand(expand bool)
	// SetVExpandSet sets whether the vexpand flag will be used.
	//
	// See [method@Gtk.Widget.set_hexpand_set] for more detail.
	//
	// This method is inherited from Widget
	SetVExpandSet(set bool)
	// SetVisible sets the visibility state of @widget.
	//
	// Note that setting this to true doesn’t mean the widget is actually
	// viewable, see [method@Gtk.Widget.get_visible].
	//
	// This function simply calls [method@Gtk.Widget.show] or
	// [method@Gtk.Widget.hide] but is nicer to use when the visibility of the
	// widget depends on some condition.
	//
	// This method is inherited from Widget
	SetVisible(visible bool)
	// ShouldLayout returns whether @widget should contribute to the measuring
	// and allocation of its parent.
	//
	// This is false for invisible children, but also for children that have
	// their own surface.
	//
	// This method is inherited from Widget
	ShouldLayout() bool
	// Show flags a widget to be displayed.
	//
	// Any widget that isn’t shown will not appear on the screen.
	//
	// Remember that you have to show the containers containing a widget, in
	// addition to the widget itself, before it will appear onscreen.
	//
	// When a toplevel container is shown, it is immediately realized and
	// mapped; other shown widgets are realized and mapped when their toplevel
	// container is realized and mapped.
	//
	// This method is inherited from Widget
	Show()
	// SnapshotChild: snapshot the a child of @widget.
	//
	// When a widget receives a call to the snapshot function, it must send
	// synthetic `GtkWidget`Class.snapshot() calls to all children. This
	// function provides a convenient way of doing this. A widget, when it
	// receives a call to its `GtkWidget`Class.snapshot() function, calls
	// gtk_widget_snapshot_child() once for each child, passing in the @snapshot
	// the widget received.
	//
	// gtk_widget_snapshot_child() takes care of translating the origin of
	// @snapshot, and deciding whether the child needs to be snapshot.
	//
	// This function does nothing for children that implement `GtkNative`.
	//
	// This method is inherited from Widget
	SnapshotChild(child Widget, snapshot Snapshot)
	// TranslateCoordinates: translate coordinates relative to @src_widget’s
	// allocation to coordinates relative to @dest_widget’s allocations.
	//
	// In order to perform this operation, both widget must share a common
	// ancestor.
	//
	// This method is inherited from Widget
	TranslateCoordinates(destWidget Widget, srcX float64, srcY float64) (destX float64, destY float64, ok bool)
	// TriggerTooltipQuery triggers a tooltip query on the display where the
	// toplevel of @widget is located.
	//
	// This method is inherited from Widget
	TriggerTooltipQuery()
	// Unmap causes a widget to be unmapped if it’s currently mapped.
	//
	// This function is only for use in widget implementations.
	//
	// This method is inherited from Widget
	Unmap()
	// Unparent: dissociate @widget from its parent.
	//
	// This function is only for use in widget implementations, typically in
	// dispose.
	//
	// This method is inherited from Widget
	Unparent()
	// Unrealize causes a widget to be unrealized (frees all GDK resources
	// associated with the widget).
	//
	// This function is only useful in widget implementations.
	//
	// This method is inherited from Widget
	Unrealize()
	// UnsetStateFlags turns off flag values for the current widget state.
	//
	// See [method@Gtk.Widget.set_state_flags].
	//
	// This function is for use in widget implementations.
	//
	// This method is inherited from Widget
	UnsetStateFlags(flags StateFlags)
	// GetAccessibleRole retrieves the `GtkAccessibleRole` for the given
	// `GtkAccessible`.
	//
	// This method is inherited from Accessible
	GetAccessibleRole() AccessibleRole
	// ResetProperty resets the accessible @property to its default value.
	//
	// This method is inherited from Accessible
	ResetProperty(property AccessibleProperty)
	// ResetRelation resets the accessible @relation to its default value.
	//
	// This method is inherited from Accessible
	ResetRelation(relation AccessibleRelation)
	// ResetState resets the accessible @state to its default value.
	//
	// This method is inherited from Accessible
	ResetState(state AccessibleState)
	// UpdatePropertyValue updates an array of accessible properties.
	//
	// This function should be called by `GtkWidget` types whenever an
	// accessible property change must be communicated to assistive
	// technologies.
	//
	// This function is meant to be used by language bindings.
	//
	// This method is inherited from Accessible
	UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value)
	// UpdateRelationValue updates an array of accessible relations.
	//
	// This function should be called by `GtkWidget` types whenever an
	// accessible relation change must be communicated to assistive
	// technologies.
	//
	// This function is meant to be used by language bindings.
	//
	// This method is inherited from Accessible
	UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value)
	// UpdateStateValue updates an array of accessible states.
	//
	// This function should be called by `GtkWidget` types whenever an
	// accessible state change must be communicated to assistive technologies.
	//
	// This function is meant to be used by language bindings.
	//
	// This method is inherited from Accessible
	UpdateStateValue(states []AccessibleState, values []externglib.Value)
	// GetBuildableID gets the ID of the @buildable object.
	//
	// `GtkBuilder` sets the name based on the ID attribute of the <object> tag
	// used to construct the @buildable.
	//
	// This method is inherited from Buildable
	GetBuildableID() string
	// GetDisplay returns the display that this `GtkRoot` is on.
	//
	// This method is inherited from Root
	GetDisplay() gdk.Display
	// GetFocus retrieves the current focused widget within the root.
	//
	// Note that this is the widget that would have the focus if the root is
	// active; if the root is not focused then `gtk_widget_has_focus (widget)`
	// will be false for the widget.
	//
	// This method is inherited from Root
	GetFocus() Widget
	// SetFocus: if @focus is not the current focus widget, and is focusable,
	// sets it as the focus widget for the root.
	//
	// If @focus is nil, unsets the focus widget for the root.
	//
	// To set the focus to a particular widget in the root, it is usually more
	// convenient to use [method@Gtk.Widget.grab_focus] instead of this
	// function.
	//
	// This method is inherited from Root
	SetFocus(focus Widget)
	// GetRenderer returns the renderer that is used for this `GtkNative`.
	//
	// This method is inherited from Native
	GetRenderer() gsk.Renderer
	// GetSurface returns the surface of this `GtkNative`.
	//
	// This method is inherited from Native
	GetSurface() gdk.Surface
	// GetSurfaceTransform retrieves the surface transform of @self.
	//
	// This is the translation from @self's surface coordinates into @self's
	// widget coordinates.
	//
	// This method is inherited from Native
	GetSurfaceTransform() (x float64, y float64)
	// Realize realizes a `GtkNative`.
	//
	// This should only be used by subclasses.
	//
	// This method is inherited from Native
	Realize()
	// Unrealize unrealizes a `GtkNative`.
	//
	// This should only be used by subclasses.
	//
	// This method is inherited from Native
	Unrealize()
	// ActionSetEnabled: enable or disable an action installed with
	// gtk_widget_class_install_action().
	//
	// This method is inherited from Widget
	ActionSetEnabled(actionName string, enabled bool)
	// Activate: for widgets that can be “activated” (buttons, menu items, etc.)
	// this function activates them.
	//
	// The activation will emit the signal set using
	// gtk_widget_class_set_activate_signal() during class initialization.
	//
	// Activation is what happens when you press Enter on a widget during key
	// navigation.
	//
	// If you wish to handle the activation keybinding yourself, it is
	// recommended to use gtk_widget_class_add_shortcut() with an action created
	// with gtk_signal_action_new().
	//
	// If @widget isn't activatable, the function returns false.
	//
	// This method is inherited from Widget
	Activate() bool
	// ActivateActionVariant looks up the action in the action groups associated
	// with @widget and its ancestors, and activates it.
	//
	// If the action is in an action group added with
	// [method@Gtk.Widget.insert_action_group], the @name is expected to be
	// prefixed with the prefix that was used when the group was inserted.
	//
	// The arguments must match the actions expected parameter type, as returned
	// by `g_action_get_parameter_type()`.
	//
	// This method is inherited from Widget
	ActivateActionVariant(name string, args *glib.Variant) bool
	// ActivateDefault activates the `default.activate` action from @widget.
	//
	// This method is inherited from Widget
	ActivateDefault()
	// AddController adds @controller to @widget so that it will receive events.
	//
	// You will usually want to call this function right after creating any kind
	// of [class@Gtk.EventController].
	//
	// This method is inherited from Widget
	AddController(controller EventController)
	// AddCSSClass adds a style class to @widget.
	//
	// After calling this function, the widgets style will match for @css_class,
	// according to CSS matching rules.
	//
	// Use [method@Gtk.Widget.remove_css_class] to remove the style again.
	//
	// This method is inherited from Widget
	AddCSSClass(cssClass string)
	// AddMnemonicLabel adds a widget to the list of mnemonic labels for this
	// widget.
	//
	// See [method@Gtk.Widget.list_mnemonic_labels]. Note the list of mnemonic
	// labels for the widget is cleared when the widget is destroyed, so the
	// caller must make sure to update its internal state at this point as well,
	// by using a connection to the [signal@Gtk.Widget::destroy] signal or a
	// weak notifier.
	//
	// This method is inherited from Widget
	AddMnemonicLabel(label Widget)
	// Allocate: this function is only used by `GtkWidget` subclasses, to assign
	// a size, position and (optionally) baseline to their child widgets.
	//
	// In this function, the allocation and baseline may be adjusted. The given
	// allocation will be forced to be bigger than the widget's minimum size, as
	// well as at least 0×0 in size.
	//
	// For a version that does not take a transform, see
	// [method@Gtk.Widget.size_allocate].
	//
	// This method is inherited from Widget
	Allocate(width int, height int, baseline int, transform *gsk.Transform)
	// ChildFocus: called by widgets as the user moves around the window using
	// keyboard shortcuts.
	//
	// The @direction argument indicates what kind of motion is taking place
	// (up, down, left, right, tab forward, tab backward).
	//
	// This function calls the [vfunc@Gtk.Widget.focus] virtual function;
	// widgets can override the virtual function in order to implement
	// appropriate focus behavior.
	//
	// The default `focus()` virtual function for a widget should return `TRUE`
	// if moving in @direction left the focus on a focusable location inside
	// that widget, and `FALSE` if moving in @direction moved the focus outside
	// the widget. When returning `TRUE`, widgets normallycall
	// [method@Gtk.Widget.grab_focus] to place the focus accordingly; when
	// returning `FALSE`, they don’t modify the current focus location.
	//
	// This function is used by custom widget implementations; if you're writing
	// an app, you’d use [method@Gtk.Widget.grab_focus] to move the focus to a
	// particular widget.
	//
	// This method is inherited from Widget
	ChildFocus(direction DirectionType) bool
	// ComputeBounds computes the bounds for @widget in the coordinate space of
	// @target.
	//
	// FIXME: Explain what "bounds" are.
	//
	// If the operation is successful, true is returned. If @widget has no
	// bounds or the bounds cannot be expressed in @target's coordinate space
	// (for example if both widgets are in different windows), false is returned
	// and @bounds is set to the zero rectangle.
	//
	// It is valid for @widget and @target to be the same widget.
	//
	// This method is inherited from Widget
	ComputeBounds(target Widget) (graphene.Rect, bool)
	// ComputeExpand computes whether a container should give this widget extra
	// space when possible.
	//
	// Containers should check this, rather than looking at
	// [method@Gtk.Widget.get_hexpand] or [method@Gtk.Widget.get_vexpand].
	//
	// This function already checks whether the widget is visible, so visibility
	// does not need to be checked separately. Non-visible widgets are not
	// expanded.
	//
	// The computed expand value uses either the expand setting explicitly set
	// on the widget itself, or, if none has been explicitly set, the widget may
	// expand if some of its children do.
	//
	// This method is inherited from Widget
	ComputeExpand(orientation Orientation) bool
	// ComputePoint translates the given @point in @widget's coordinates to
	// coordinates relative to @target’s coordinate system.
	//
	// In order to perform this operation, both widgets must share a common
	// ancestor.
	//
	// This method is inherited from Widget
	ComputePoint(target Widget, point *graphene.Point) (graphene.Point, bool)
	// ComputeTransform computes a matrix suitable to describe a transformation
	// from @widget's coordinate system into @target's coordinate system.
	//
	// This method is inherited from Widget
	ComputeTransform(target Widget) (graphene.Matrix, bool)
	// Contains tests if the point at (@x, @y) is contained in @widget.
	//
	// The coordinates for (@x, @y) must be in widget coordinates, so (0, 0) is
	// assumed to be the top left of @widget's content area.
	//
	// This method is inherited from Widget
	Contains(x float64, y float64) bool
	// CreatePangoContext creates a new `PangoContext` with the appropriate font
	// map, font options, font description, and base direction for drawing text
	// for this widget.
	//
	// See also [method@Gtk.Widget.get_pango_context].
	//
	// This method is inherited from Widget
	CreatePangoContext() pango.Context
	// CreatePangoLayout creates a new `PangoLayout` with the appropriate font
	// map, font description, and base direction for drawing text for this
	// widget.
	//
	// If you keep a `PangoLayout` created in this way around, you need to
	// re-create it when the widget `PangoContext` is replaced. This can be
	// tracked by listening to changes of the [property@Gtk.Widget:root]
	// property on the widget.
	//
	// This method is inherited from Widget
	CreatePangoLayout(text string) pango.Layout
	// DragCheckThreshold checks to see if a drag movement has passed the GTK
	// drag threshold.
	//
	// This method is inherited from Widget
	DragCheckThreshold(startX int, startY int, currentX int, currentY int) bool
	// ErrorBell notifies the user about an input-related error on this widget.
	//
	// If the [property@Gtk.Settings:gtk-error-bell] setting is true, it calls
	// [method@Gdk.Surface.beep], otherwise it does nothing.
	//
	// Note that the effect of [method@Gdk.Surface.beep] can be configured in
	// many ways, depending on the windowing backend and the desktop environment
	// or window manager that is used.
	//
	// This method is inherited from Widget
	ErrorBell()
	// GetAllocatedBaseline returns the baseline that has currently been
	// allocated to @widget.
	//
	// This function is intended to be used when implementing handlers for the
	// `GtkWidget`Class.snapshot() function, and when allocating child widgets
	// in `GtkWidget`Class.size_allocate().
	//
	// This method is inherited from Widget
	GetAllocatedBaseline() int
	// GetAllocatedHeight returns the height that has currently been allocated
	// to @widget.
	//
	// This method is inherited from Widget
	GetAllocatedHeight() int
	// GetAllocatedWidth returns the width that has currently been allocated to
	// @widget.
	//
	// This method is inherited from Widget
	GetAllocatedWidth() int
	// GetAncestor gets the first ancestor of @widget with type @widget_type.
	//
	// For example, `gtk_widget_get_ancestor (widget, GTK_TYPE_BOX)` gets the
	// first `GtkBox` that’s an ancestor of @widget. No reference will be added
	// to the returned widget; it should not be unreferenced.
	//
	// Note that unlike [method@Gtk.Widget.is_ancestor], this function considers
	// @widget to be an ancestor of itself.
	//
	// This method is inherited from Widget
	GetAncestor(widgetType externglib.Type) Widget
	// GetCanFocus determines whether the input focus can enter @widget or any
	// of its children.
	//
	// See [method@Gtk.Widget.set_focusable].
	//
	// This method is inherited from Widget
	GetCanFocus() bool
	// GetCanTarget queries whether @widget can be the target of pointer events.
	//
	// This method is inherited from Widget
	GetCanTarget() bool
	// GetChildVisible gets the value set with gtk_widget_set_child_visible().
	//
	// If you feel a need to use this function, your code probably needs
	// reorganization.
	//
	// This function is only useful for container implementations and should
	// never be called by an application.
	//
	// This method is inherited from Widget
	GetChildVisible() bool
	// GetClipboard gets the clipboard object for @widget.
	//
	// This is a utility function to get the clipboard object for the
	// `GdkDisplay` that @widget is using.
	//
	// Note that this function always works, even when @widget is not realized
	// yet.
	//
	// This method is inherited from Widget
	GetClipboard() gdk.Clipboard
	// GetCSSClasses returns the list of style classes applied to @widget.
	//
	// This method is inherited from Widget
	GetCSSClasses() []string
	// GetCSSName returns the CSS name that is used for @self.
	//
	// This method is inherited from Widget
	GetCSSName() string
	// GetCursor queries the cursor set on @widget.
	//
	// See [method@Gtk.Widget.set_cursor] for details.
	//
	// This method is inherited from Widget
	GetCursor() gdk.Cursor
	// GetDirection gets the reading direction for a particular widget.
	//
	// See [method@Gtk.Widget.set_direction].
	//
	// This method is inherited from Widget
	GetDirection() TextDirection
	// GetDisplay: get the `GdkDisplay` for the toplevel window associated with
	// this widget.
	//
	// This function can only be called after the widget has been added to a
	// widget hierarchy with a `GtkWindow` at the top.
	//
	// In general, you should only create display specific resources when a
	// widget has been realized, and you should free those resources when the
	// widget is unrealized.
	//
	// This method is inherited from Widget
	GetDisplay() gdk.Display
	// GetFirstChild returns the widgets first child.
	//
	// This API is primarily meant for widget implementations.
	//
	// This method is inherited from Widget
	GetFirstChild() Widget
	// GetFocusChild returns the current focus child of @widget.
	//
	// This method is inherited from Widget
	GetFocusChild() Widget
	// GetFocusOnClick returns whether the widget should grab focus when it is
	// clicked with the mouse.
	//
	// See [method@Gtk.Widget.set_focus_on_click].
	//
	// This method is inherited from Widget
	GetFocusOnClick() bool
	// GetFocusable determines whether @widget can own the input focus.
	//
	// See [method@Gtk.Widget.set_focusable].
	//
	// This method is inherited from Widget
	GetFocusable() bool
	// GetFontMap gets the font map of @widget.
	//
	// See [method@Gtk.Widget.set_font_map].
	//
	// This method is inherited from Widget
	GetFontMap() pango.FontMap
	// GetFontOptions returns the `cairo_font_options_t` used for Pango
	// rendering.
	//
	// When not set, the defaults font options for the `GdkDisplay` will be
	// used.
	//
	// This method is inherited from Widget
	GetFontOptions() *cairo.FontOptions
	// GetFrameClock obtains the frame clock for a widget.
	//
	// The frame clock is a global “ticker” that can be used to drive animations
	// and repaints. The most common reason to get the frame clock is to call
	// [method@Gdk.FrameClock.get_frame_time], in order to get a time to use for
	// animating. For example you might record the start of the animation with
	// an initial value from [method@Gdk.FrameClock.get_frame_time], and then
	// update the animation by calling [method@Gdk.FrameClock.get_frame_time]
	// again during each repaint.
	//
	// [method@Gdk.FrameClock.request_phase] will result in a new frame on the
	// clock, but won’t necessarily repaint any widgets. To repaint a widget,
	// you have to use [method@Gtk.Widget.queue_draw] which invalidates the
	// widget (thus scheduling it to receive a draw on the next frame).
	// gtk_widget_queue_draw() will also end up requesting a frame on the
	// appropriate frame clock.
	//
	// A widget’s frame clock will not change while the widget is mapped.
	// Reparenting a widget (which implies a temporary unmap) can change the
	// widget’s frame clock.
	//
	// Unrealized widgets do not have a frame clock.
	//
	// This method is inherited from Widget
	GetFrameClock() gdk.FrameClock
	// GetHAlign gets the horizontal alignment of @widget.
	//
	// For backwards compatibility reasons this method will never return
	// GTK_ALIGN_BASELINE, but instead it will convert it to GTK_ALIGN_FILL.
	// Baselines are not supported for horizontal alignment.
	//
	// This method is inherited from Widget
	GetHAlign() Align
	// GetHasTooltip returns the current value of the `has-tooltip` property.
	//
	// This method is inherited from Widget
	GetHasTooltip() bool
	// GetHeight returns the content height of the widget.
	//
	// This function returns the size passed to its size-allocate
	// implementation, which is the size you should be using in
	// GtkWidgetClass.snapshot().
	//
	// For pointer events, see [method@Gtk.Widget.contains].
	//
	// This method is inherited from Widget
	GetHeight() int
	// GetHExpand gets whether the widget would like any available extra
	// horizontal space.
	//
	// When a user resizes a `GtkWindow`, widgets with expand=TRUE generally
	// receive the extra space. For example, a list or scrollable area or
	// document in your window would often be set to expand.
	//
	// Containers should use [method@Gtk.Widget.compute_expand] rather than this
	// function, to see whether a widget, or any of its children, has the expand
	// flag set. If any child of a widget wants to expand, the parent may ask to
	// expand also.
	//
	// This function only looks at the widget’s own hexpand flag, rather than
	// computing whether the entire widget tree rooted at this widget wants to
	// expand.
	//
	// This method is inherited from Widget
	GetHExpand() bool
	// GetHExpandSet gets whether gtk_widget_set_hexpand() has been used to
	// explicitly set the expand flag on this widget.
	//
	// If [property@Gtk.Widget:hexpand] property is set, then it overrides any
	// computed expand value based on child widgets. If `hexpand` is not set,
	// then the expand value depends on whether any children of the widget would
	// like to expand.
	//
	// There are few reasons to use this function, but it’s here for
	// completeness and consistency.
	//
	// This method is inherited from Widget
	GetHExpandSet() bool
	// GetLastChild returns the widgets last child.
	//
	// This API is primarily meant for widget implementations.
	//
	// This method is inherited from Widget
	GetLastChild() Widget
	// GetLayoutManager retrieves the layout manager used by @widget
	//
	// See [method@Gtk.Widget.set_layout_manager].
	//
	// This method is inherited from Widget
	GetLayoutManager() LayoutManager
	// GetMapped: whether the widget is mapped.
	//
	// This method is inherited from Widget
	GetMapped() bool
	// GetMarginBottom gets the bottom margin of @widget.
	//
	// This method is inherited from Widget
	GetMarginBottom() int
	// GetMarginEnd gets the end margin of @widget.
	//
	// This method is inherited from Widget
	GetMarginEnd() int
	// GetMarginStart gets the start margin of @widget.
	//
	// This method is inherited from Widget
	GetMarginStart() int
	// GetMarginTop gets the top margin of @widget.
	//
	// This method is inherited from Widget
	GetMarginTop() int
	// GetName retrieves the name of a widget.
	//
	// See [method@Gtk.Widget.set_name] for the significance of widget names.
	//
	// This method is inherited from Widget
	GetName() string
	// GetNative returns the `GtkNative` widget that contains @widget.
	//
	// This function will return nil if the widget is not contained inside a
	// widget tree with a native ancestor.
	//
	// `GtkNative` widgets will return themselves here.
	//
	// This method is inherited from Widget
	GetNative() Native
	// GetNextSibling returns the widgets next sibling.
	//
	// This API is primarily meant for widget implementations.
	//
	// This method is inherited from Widget
	GetNextSibling() Widget
	// GetOpacity the requested opacity for this widget.
	//
	// See [method@Gtk.Widget.set_opacity].
	//
	// This method is inherited from Widget
	GetOpacity() float64
	// GetOverflow returns the widgets overflow value.
	//
	// This method is inherited from Widget
	GetOverflow() Overflow
	// GetPangoContext gets a `PangoContext` with the appropriate font map, font
	// description, and base direction for this widget.
	//
	// Unlike the context returned by [method@Gtk.Widget.create_pango_context],
	// this context is owned by the widget (it can be used until the screen for
	// the widget changes or the widget is removed from its toplevel), and will
	// be updated to match any changes to the widget’s attributes. This can be
	// tracked by listening to changes of the [property@Gtk.Widget:root]
	// property on the widget.
	//
	// This method is inherited from Widget
	GetPangoContext() pango.Context
	// GetParent returns the parent widget of @widget.
	//
	// This method is inherited from Widget
	GetParent() Widget
	// GetPreferredSize retrieves the minimum and natural size of a widget,
	// taking into account the widget’s preference for height-for-width
	// management.
	//
	// This is used to retrieve a suitable size by container widgets which do
	// not impose any restrictions on the child placement. It can be used to
	// deduce toplevel window and menu sizes as well as child widgets in
	// free-form containers such as `GtkFixed`.
	//
	// Handle with care. Note that the natural height of a height-for-width
	// widget will generally be a smaller size than the minimum height, since
	// the required height for the natural width is generally smaller than the
	// required height for the minimum width.
	//
	// Use [id@gtk_widget_measure] if you want to support baseline alignment.
	//
	// This method is inherited from Widget
	GetPreferredSize() (minimumSize Requisition, naturalSize Requisition)
	// GetPrevSibling returns the widgets previous sibling.
	//
	// This API is primarily meant for widget implementations.
	//
	// This method is inherited from Widget
	GetPrevSibling() Widget
	// GetPrimaryClipboard gets the primary clipboard of @widget.
	//
	// This is a utility function to get the primary clipboard object for the
	// `GdkDisplay` that @widget is using.
	//
	// Note that this function always works, even when @widget is not realized
	// yet.
	//
	// This method is inherited from Widget
	GetPrimaryClipboard() gdk.Clipboard
	// GetRealized determines whether @widget is realized.
	//
	// This method is inherited from Widget
	GetRealized() bool
	// GetReceivesDefault determines whether @widget is always treated as the
	// default widget within its toplevel when it has the focus, even if another
	// widget is the default.
	//
	// See [method@Gtk.Widget.set_receives_default].
	//
	// This method is inherited from Widget
	GetReceivesDefault() bool
	// GetRequestMode gets whether the widget prefers a height-for-width layout
	// or a width-for-height layout.
	//
	// Single-child widgets generally propagate the preference of their child,
	// more complex widgets need to request something either in context of their
	// children or in context of their allocation capabilities.
	//
	// This method is inherited from Widget
	GetRequestMode() SizeRequestMode
	// GetRoot returns the `GtkRoot` widget of @widget.
	//
	// This function will return nil if the widget is not contained inside a
	// widget tree with a root widget.
	//
	// `GtkRoot` widgets will return themselves here.
	//
	// This method is inherited from Widget
	GetRoot() Root
	// GetScaleFactor retrieves the internal scale factor that maps from window
	// coordinates to the actual device pixels.
	//
	// On traditional systems this is 1, on high density outputs, it can be a
	// higher value (typically 2).
	//
	// See [method@Gdk.Surface.get_scale_factor].
	//
	// This method is inherited from Widget
	GetScaleFactor() int
	// GetSensitive returns the widget’s sensitivity.
	//
	// This function returns the value that has been set using
	// [method@Gtk.Widget.set_sensitive]).
	//
	// The effective sensitivity of a widget is however determined by both its
	// own and its parent widget’s sensitivity. See
	// [method@Gtk.Widget.is_sensitive].
	//
	// This method is inherited from Widget
	GetSensitive() bool
	// GetSettings gets the settings object holding the settings used for this
	// widget.
	//
	// Note that this function can only be called when the `GtkWidget` is
	// attached to a toplevel, since the settings object is specific to a
	// particular `GdkDisplay`. If you want to monitor the widget for changes in
	// its settings, connect to notify::display.
	//
	// This method is inherited from Widget
	GetSettings() Settings
	// GetSize returns the content width or height of the widget.
	//
	// Which dimension is returned depends on @orientation.
	//
	// This is equivalent to calling [method@Gtk.Widget.get_width] for
	// GTK_ORIENTATION_HORIZONTAL or [method@Gtk.Widget.get_height] for
	// GTK_ORIENTATION_VERTICAL, but can be used when writing
	// orientation-independent code, such as when implementing
	// [iface@Gtk.Orientable] widgets.
	//
	// This method is inherited from Widget
	GetSize(orientation Orientation) int
	// GetSizeRequest gets the size request that was explicitly set for the
	// widget using gtk_widget_set_size_request().
	//
	// A value of -1 stored in @width or @height indicates that that dimension
	// has not been set explicitly and the natural requisition of the widget
	// will be used instead. See [method@Gtk.Widget.set_size_request]. To get
	// the size a widget will actually request, call [method@Gtk.Widget.measure]
	// instead of this function.
	//
	// This method is inherited from Widget
	GetSizeRequest() (width int, height int)
	// GetStateFlags returns the widget state as a flag set.
	//
	// It is worth mentioning that the effective GTK_STATE_FLAG_INSENSITIVE
	// state will be returned, that is, also based on parent insensitivity, even
	// if @widget itself is sensitive.
	//
	// Also note that if you are looking for a way to obtain the
	// [flags@Gtk.StateFlags] to pass to a [class@Gtk.StyleContext] method, you
	// should look at [method@Gtk.StyleContext.get_state].
	//
	// This method is inherited from Widget
	GetStateFlags() StateFlags
	// GetStyleContext returns the style context associated to @widget.
	//
	// The returned object is guaranteed to be the same for the lifetime of
	// @widget.
	//
	// This method is inherited from Widget
	GetStyleContext() StyleContext
	// GetTemplateChild: fetch an object build from the template XML for
	// @widget_type in this @widget instance.
	//
	// This will only report children which were previously declared with
	// [method@Gtk.WidgetClass.bind_template_child_full] or one of its variants.
	//
	// This function is only meant to be called for code which is private to the
	// @widget_type which declared the child and is meant for language bindings
	// which cannot easily make use of the GObject structure offsets.
	//
	// This method is inherited from Widget
	GetTemplateChild(widgetType externglib.Type, name string) gextras.Objector
	// GetTooltipMarkup gets the contents of the tooltip for @widget.
	//
	// If the tooltip has not been set using
	// [method@Gtk.Widget.set_tooltip_markup], this function returns nil.
	//
	// This method is inherited from Widget
	GetTooltipMarkup() string
	// GetTooltipText gets the contents of the tooltip for @widget.
	//
	// If the @widget's tooltip was set using
	// [method@Gtk.Widget.set_tooltip_markup], this function will return the
	// escaped text.
	//
	// This method is inherited from Widget
	GetTooltipText() string
	// GetVAlign gets the vertical alignment of @widget.
	//
	// This method is inherited from Widget
	GetVAlign() Align
	// GetVExpand gets whether the widget would like any available extra
	// vertical space.
	//
	// See [method@Gtk.Widget.get_hexpand] for more detail.
	//
	// This method is inherited from Widget
	GetVExpand() bool
	// GetVExpandSet gets whether gtk_widget_set_vexpand() has been used to
	// explicitly set the expand flag on this widget.
	//
	// See [method@Gtk.Widget.get_hexpand_set] for more detail.
	//
	// This method is inherited from Widget
	GetVExpandSet() bool
	// GetVisible determines whether the widget is visible.
	//
	// If you want to take into account whether the widget’s parent is also
	// marked as visible, use [method@Gtk.Widget.is_visible] instead.
	//
	// This function does not check if the widget is obscured in any way.
	//
	// See [method@Gtk.Widget.set_visible].
	//
	// This method is inherited from Widget
	GetVisible() bool
	// GetWidth returns the content width of the widget.
	//
	// This function returns the size passed to its size-allocate
	// implementation, which is the size you should be using in
	// GtkWidgetClass.snapshot().
	//
	// For pointer events, see [method@Gtk.Widget.contains].
	//
	// This method is inherited from Widget
	GetWidth() int
	// GrabFocus causes @widget to have the keyboard focus for the `GtkWindow`
	// it's inside.
	//
	// If @widget is not focusable, or its ::grab_focus implementation cannot
	// transfer the focus to a descendant of @widget that is focusable, it will
	// not take focus and false will be returned.
	//
	// Calling [method@Gtk.Widget.grab_focus] on an already focused widget is
	// allowed, should not have an effect, and return true.
	//
	// This method is inherited from Widget
	GrabFocus() bool
	// HasCSSClass returns whether @css_class is currently applied to @widget.
	//
	// This method is inherited from Widget
	HasCSSClass(cssClass string) bool
	// HasDefault determines whether @widget is the current default widget
	// within its toplevel.
	//
	// This method is inherited from Widget
	HasDefault() bool
	// HasFocus determines if the widget has the global input focus.
	//
	// See [method@Gtk.Widget.is_focus] for the difference between having the
	// global input focus, and only having the focus within a toplevel.
	//
	// This method is inherited from Widget
	HasFocus() bool
	// HasVisibleFocus determines if the widget should show a visible indication
	// that it has the global input focus.
	//
	// This is a convenience function that takes into account whether focus
	// indication should currently be shown in the toplevel window of @widget.
	// See [method@Gtk.Window.get_focus_visible] for more information about
	// focus indication.
	//
	// To find out if the widget has the global input focus, use
	// [method@Gtk.Widget.has_focus].
	//
	// This method is inherited from Widget
	HasVisibleFocus() bool
	// Hide reverses the effects of gtk_widget_show().
	//
	// This is causing the widget to be hidden (invisible to the user).
	//
	// This method is inherited from Widget
	Hide()
	// InDestruction returns whether the widget is currently being destroyed.
	//
	// This information can sometimes be used to avoid doing unnecessary work.
	//
	// This method is inherited from Widget
	InDestruction() bool
	// InitTemplate creates and initializes child widgets defined in templates.
	//
	// This function must be called in the instance initializer for any class
	// which assigned itself a template using
	// [method@Gtk.WidgetClass.set_template].
	//
	// It is important to call this function in the instance initializer of a
	// `GtkWidget` subclass and not in `GObject.constructed()` or
	// `GObject.constructor()` for two reasons:
	//
	//    - derived widgets will assume that the composite widgets
	//      defined by its parent classes have been created in their
	//      relative instance initializers
	//    - when calling `g_object_new()` on a widget with composite templates,
	//      it’s important to build the composite widgets before the construct
	//      properties are set. Properties passed to `g_object_new()` should
	//      take precedence over properties set in the private template XML
	//
	// A good rule of thumb is to call this function as the first thing in an
	// instance initialization function.
	//
	// This method is inherited from Widget
	InitTemplate()
	// InsertAfter inserts @widget into the child widget list of @parent.
	//
	// It will be placed after @previous_sibling, or at the beginning if
	// @previous_sibling is nil.
	//
	// After calling this function, `gtk_widget_get_prev_sibling(widget)` will
	// return @previous_sibling.
	//
	// If @parent is already set as the parent widget of @widget, this function
	// can also be used to reorder @widget in the child widget list of @parent.
	//
	// This API is primarily meant for widget implementations; if you are just
	// using a widget, you *must* use its own API for adding children.
	//
	// This method is inherited from Widget
	InsertAfter(parent Widget, previousSibling Widget)
	// InsertBefore inserts @widget into the child widget list of @parent.
	//
	// It will be placed before @next_sibling, or at the end if @next_sibling is
	// nil.
	//
	// After calling this function, `gtk_widget_get_next_sibling(widget)` will
	// return @next_sibling.
	//
	// If @parent is already set as the parent widget of @widget, this function
	// can also be used to reorder @widget in the child widget list of @parent.
	//
	// This API is primarily meant for widget implementations; if you are just
	// using a widget, you *must* use its own API for adding children.
	//
	// This method is inherited from Widget
	InsertBefore(parent Widget, nextSibling Widget)
	// IsAncestor determines whether @widget is somewhere inside @ancestor,
	// possibly with intermediate containers.
	//
	// This method is inherited from Widget
	IsAncestor(ancestor Widget) bool
	// IsDrawable determines whether @widget can be drawn to.
	//
	// A widget can be drawn if it is mapped and visible.
	//
	// This method is inherited from Widget
	IsDrawable() bool
	// IsFocus determines if the widget is the focus widget within its toplevel.
	//
	// This does not mean that the [property@Gtk.Widget:has-focus] property is
	// necessarily set; [property@Gtk,Widget:has-focus] will only be set if the
	// toplevel widget additionally has the global input focus.)
	//
	// This method is inherited from Widget
	IsFocus() bool
	// IsSensitive returns the widget’s effective sensitivity.
	//
	// This means it is sensitive itself and also its parent widget is
	// sensitive.
	//
	// This method is inherited from Widget
	IsSensitive() bool
	// IsVisible determines whether the widget and all its parents are marked as
	// visible.
	//
	// This function does not check if the widget is obscured in any way.
	//
	// See also [method@Gtk.Widget.get_visible] and
	// [method@Gtk.Widget.set_visible].
	//
	// This method is inherited from Widget
	IsVisible() bool
	// KeynavFailed emits the `::keynav-failed` signal on the widget.
	//
	// This function should be called whenever keyboard navigation within a
	// single widget hits a boundary.
	//
	// The return value of this function should be interpreted in a way similar
	// to the return value of [method@Gtk.Widget.child_focus]. When true is
	// returned, stay in the widget, the failed keyboard navigation is OK and/or
	// there is nowhere we can/should move the focus to. When false is returned,
	// the caller should continue with keyboard navigation outside the widget,
	// e.g. by calling [method@Gtk.Widget.child_focus] on the widget’s toplevel.
	//
	// The default [signal@Gtk.Widget::keynav-failed] handler returns false for
	// GTK_DIR_TAB_FORWARD and GTK_DIR_TAB_BACKWARD. For the other values of
	// DirectionType it returns true.
	//
	// Whenever the default handler returns true, it also calls
	// [method@Gtk.Widget.error_bell] to notify the user of the failed keyboard
	// navigation.
	//
	// A use case for providing an own implementation of ::keynav-failed (either
	// by connecting to it or by overriding it) would be a row of
	// [class@Gtk.Entry] widgets where the user should be able to navigate the
	// entire row with the cursor keys, as e.g. known from user interfaces that
	// require entering license keys.
	//
	// This method is inherited from Widget
	KeynavFailed(direction DirectionType) bool
	// Map causes a widget to be mapped if it isn’t already.
	//
	// This function is only for use in widget implementations.
	//
	// This method is inherited from Widget
	Map()
	// Measure measures @widget in the orientation @orientation and for the
	// given @for_size.
	//
	// As an example, if @orientation is GTK_ORIENTATION_HORIZONTAL and
	// @for_size is 300, this functions will compute the minimum and natural
	// width of @widget if it is allocated at a height of 300 pixels.
	//
	// See GtkWidget’s geometry management section
	// (class.Widget.html#height-for-width-geometry-management) for a more
	// details on implementing WidgetClass.measure().
	//
	// This method is inherited from Widget
	Measure(orientation Orientation, forSize int) (minimum int, natural int, minimumBaseline int, naturalBaseline int)
	// MnemonicActivate emits the `GtkWidget`::mnemonic-activate signal.
	//
	// This method is inherited from Widget
	MnemonicActivate(groupCycling bool) bool
	// Pick finds the descendant of @widget closest to the screen at the point
	// (@x, @y).
	//
	// The point must be given in widget coordinates, so (0, 0) is assumed to be
	// the top left of @widget's content area.
	//
	// Usually widgets will return nil if the given coordinate is not contained
	// in @widget checked via [method@Gtk.Widget.contains]. Otherwise they will
	// recursively try to find a child that does not return nil. Widgets are
	// however free to customize their picking algorithm.
	//
	// This function is used on the toplevel to determine the widget below the
	// mouse cursor for purposes of hover highlighting and delivering events.
	//
	// This method is inherited from Widget
	Pick(x float64, y float64, flags PickFlags) Widget
	// QueueAllocate flags the widget for a rerun of the
	// GtkWidgetClass::size_allocate function.
	//
	// Use this function instead of [method@Gtk.Widget.queue_resize] when the
	// @widget's size request didn't change but it wants to reposition its
	// contents.
	//
	// An example user of this function is [method@Gtk.Widget.set_halign].
	//
	// This function is only for use in widget implementations.
	//
	// This method is inherited from Widget
	QueueAllocate()
	// QueueDraw schedules this widget to be redrawn in paint phase of the
	// current or the next frame.
	//
	// This means @widget's GtkWidgetClass.snapshot() implementation will be
	// called.
	//
	// This method is inherited from Widget
	QueueDraw()
	// QueueResize flags a widget to have its size renegotiated.
	//
	// This should be called when a widget for some reason has a new size
	// request. For example, when you change the text in a [class@Gtk.Label],
	// the label queues a resize to ensure there’s enough space for the new
	// text.
	//
	// Note that you cannot call gtk_widget_queue_resize() on a widget from
	// inside its implementation of the GtkWidgetClass::size_allocate virtual
	// method. Calls to gtk_widget_queue_resize() from inside
	// GtkWidgetClass::size_allocate will be silently ignored.
	//
	// This function is only for use in widget implementations.
	//
	// This method is inherited from Widget
	QueueResize()
	// Realize creates the GDK resources associated with a widget.
	//
	// Normally realization happens implicitly; if you show a widget and all its
	// parent containers, then the widget will be realized and mapped
	// automatically.
	//
	// Realizing a widget requires all the widget’s parent widgets to be
	// realized; calling this function realizes the widget’s parents in addition
	// to @widget itself. If a widget is not yet inside a toplevel window when
	// you realize it, bad things will happen.
	//
	// This function is primarily used in widget implementations, and isn’t very
	// useful otherwise. Many times when you think you might need it, a better
	// approach is to connect to a signal that will be called after the widget
	// is realized automatically, such as [signal@Gtk.Widget::realize].
	//
	// This method is inherited from Widget
	Realize()
	// RemoveController removes @controller from @widget, so that it doesn't
	// process events anymore.
	//
	// It should not be used again.
	//
	// Widgets will remove all event controllers automatically when they are
	// destroyed, there is normally no need to call this function.
	//
	// This method is inherited from Widget
	RemoveController(controller EventController)
	// RemoveCSSClass removes a style from @widget.
	//
	// After this, the style of @widget will stop matching for @css_class.
	//
	// This method is inherited from Widget
	RemoveCSSClass(cssClass string)
	// RemoveMnemonicLabel removes a widget from the list of mnemonic labels for
	// this widget.
	//
	// See [method@Gtk.Widget.list_mnemonic_labels]. The widget must have
	// previously been added to the list with
	// [method@Gtk.Widget.add_mnemonic_label].
	//
	// This method is inherited from Widget
	RemoveMnemonicLabel(label Widget)
	// RemoveTickCallback removes a tick callback previously registered with
	// gtk_widget_add_tick_callback().
	//
	// This method is inherited from Widget
	RemoveTickCallback(id uint)
	// SetCanFocus specifies whether the input focus can enter the widget or any
	// of its children.
	//
	// Applications should set @can_focus to false to mark a widget as for
	// pointer/touch use only.
	//
	// Note that having @can_focus be true is only one of the necessary
	// conditions for being focusable. A widget must also be sensitive and
	// focusable and not have an ancestor that is marked as not can-focus in
	// order to receive input focus.
	//
	// See [method@Gtk.Widget.grab_focus] for actually setting the input focus
	// on a widget.
	//
	// This method is inherited from Widget
	SetCanFocus(canFocus bool)
	// SetCanTarget sets whether @widget can be the target of pointer events.
	//
	// This method is inherited from Widget
	SetCanTarget(canTarget bool)
	// SetChildVisible sets whether @widget should be mapped along with its
	// parent.
	//
	// The child visibility can be set for widget before it is added to a
	// container with [method@Gtk.Widget.set_parent], to avoid mapping children
	// unnecessary before immediately unmapping them. However it will be reset
	// to its default state of true when the widget is removed from a container.
	//
	// Note that changing the child visibility of a widget does not queue a
	// resize on the widget. Most of the time, the size of a widget is computed
	// from all visible children, whether or not they are mapped. If this is not
	// the case, the container can queue a resize itself.
	//
	// This function is only useful for container implementations and should
	// never be called by an application.
	//
	// This method is inherited from Widget
	SetChildVisible(childVisible bool)
	// SetCSSClasses: will clear all style classes applied to @widget and
	// replace them with @classes.
	//
	// This method is inherited from Widget
	SetCSSClasses(classes []string)
	// SetCursor sets the cursor to be shown when pointer devices point towards
	// @widget.
	//
	// If the @cursor is NULL, @widget will use the cursor inherited from the
	// parent widget.
	//
	// This method is inherited from Widget
	SetCursor(cursor gdk.Cursor)
	// SetCursorFromName sets a named cursor to be shown when pointer devices
	// point towards @widget.
	//
	// This is a utility function that creates a cursor via
	// [ctor@Gdk.Cursor.new_from_name] and then sets it on @widget with
	// [method@Gtk.Widget.set_cursor]. See those functions for details.
	//
	// On top of that, this function allows @name to be nil, which will do the
	// same as calling [method@Gtk.Widget.set_cursor] with a nil cursor.
	//
	// This method is inherited from Widget
	SetCursorFromName(name string)
	// SetDirection sets the reading direction on a particular widget.
	//
	// This direction controls the primary direction for widgets containing
	// text, and also the direction in which the children of a container are
	// packed. The ability to set the direction is present in order so that
	// correct localization into languages with right-to-left reading directions
	// can be done. Generally, applications will let the default reading
	// direction present, except for containers where the containers are
	// arranged in an order that is explicitly visual rather than logical (such
	// as buttons for text justification).
	//
	// If the direction is set to GTK_TEXT_DIR_NONE, then the value set by
	// [func@Gtk.Widget.set_default_direction] will be used.
	//
	// This method is inherited from Widget
	SetDirection(dir TextDirection)
	// SetFocusChild: set @child as the current focus child of @widget.
	//
	// The previous focus child will be unset.
	//
	// This function is only suitable for widget implementations. If you want a
	// certain widget to get the input focus, call
	// [method@Gtk.Widget.grab_focus] on it.
	//
	// This method is inherited from Widget
	SetFocusChild(child Widget)
	// SetFocusOnClick sets whether the widget should grab focus when it is
	// clicked with the mouse.
	//
	// Making mouse clicks not grab focus is useful in places like toolbars
	// where you don’t want the keyboard focus removed from the main area of the
	// application.
	//
	// This method is inherited from Widget
	SetFocusOnClick(focusOnClick bool)
	// SetFocusable specifies whether @widget can own the input focus.
	//
	// Widget implementations should set @focusable to true in their init()
	// function if they want to receive keyboard input.
	//
	// Note that having @focusable be true is only one of the necessary
	// conditions for being focusable. A widget must also be sensitive and
	// can-focus and not have an ancestor that is marked as not can-focus in
	// order to receive input focus.
	//
	// See [method@Gtk.Widget.grab_focus] for actually setting the input focus
	// on a widget.
	//
	// This method is inherited from Widget
	SetFocusable(focusable bool)
	// SetFontMap sets the font map to use for Pango rendering.
	//
	// The font map is the object that is used to look up fonts. Setting a
	// custom font map can be useful in special situations, e.g. when you need
	// to add application-specific fonts to the set of available fonts.
	//
	// When not set, the widget will inherit the font map from its parent.
	//
	// This method is inherited from Widget
	SetFontMap(fontMap pango.FontMap)
	// SetFontOptions sets the `cairo_font_options_t` used for Pango rendering
	// in this widget.
	//
	// When not set, the default font options for the `GdkDisplay` will be used.
	//
	// This method is inherited from Widget
	SetFontOptions(options *cairo.FontOptions)
	// SetHAlign sets the horizontal alignment of @widget.
	//
	// This method is inherited from Widget
	SetHAlign(align Align)
	// SetHasTooltip sets the `has-tooltip` property on @widget to @has_tooltip.
	//
	// This method is inherited from Widget
	SetHasTooltip(hasTooltip bool)
	// SetHExpand sets whether the widget would like any available extra
	// horizontal space.
	//
	// When a user resizes a `GtkWindow`, widgets with expand=TRUE generally
	// receive the extra space. For example, a list or scrollable area or
	// document in your window would often be set to expand.
	//
	// Call this function to set the expand flag if you would like your widget
	// to become larger horizontally when the window has extra room.
	//
	// By default, widgets automatically expand if any of their children want to
	// expand. (To see if a widget will automatically expand given its current
	// children and state, call [method@Gtk.Widget.compute_expand]. A container
	// can decide how the expandability of children affects the expansion of the
	// container by overriding the compute_expand virtual method on
	// `GtkWidget`.).
	//
	// Setting hexpand explicitly with this function will override the automatic
	// expand behavior.
	//
	// This function forces the widget to expand or not to expand, regardless of
	// children. The override occurs because [method@Gtk.Widget.set_hexpand]
	// sets the hexpand-set property (see [method@Gtk.Widget.set_hexpand_set])
	// which causes the widget’s hexpand value to be used, rather than looking
	// at children and widget state.
	//
	// This method is inherited from Widget
	SetHExpand(expand bool)
	// SetHExpandSet sets whether the hexpand flag will be used.
	//
	// The [property@Gtk.Widget:hexpand-set] property will be set automatically
	// when you call [method@Gtk.Widget.set_hexpand] to set hexpand, so the most
	// likely reason to use this function would be to unset an explicit expand
	// flag.
	//
	// If hexpand is set, then it overrides any computed expand value based on
	// child widgets. If hexpand is not set, then the expand value depends on
	// whether any children of the widget would like to expand.
	//
	// There are few reasons to use this function, but it’s here for
	// completeness and consistency.
	//
	// This method is inherited from Widget
	SetHExpandSet(set bool)
	// SetLayoutManager sets the layout manager delegate instance that provides
	// an implementation for measuring and allocating the children of @widget.
	//
	// This method is inherited from Widget
	SetLayoutManager(layoutManager LayoutManager)
	// SetMarginBottom sets the bottom margin of @widget.
	//
	// This method is inherited from Widget
	SetMarginBottom(margin int)
	// SetMarginEnd sets the end margin of @widget.
	//
	// This method is inherited from Widget
	SetMarginEnd(margin int)
	// SetMarginStart sets the start margin of @widget.
	//
	// This method is inherited from Widget
	SetMarginStart(margin int)
	// SetMarginTop sets the top margin of @widget.
	//
	// This method is inherited from Widget
	SetMarginTop(margin int)
	// SetName sets a widgets name.
	//
	// Setting a name allows you to refer to the widget from a CSS file. You can
	// apply a style to widgets with a particular name in the CSS file. See the
	// documentation for the CSS syntax (on the same page as the docs for
	// [class@Gtk.StyleContext].
	//
	// Note that the CSS syntax has certain special characters to delimit and
	// represent elements in a selector (period, #, >, *...), so using these
	// will make your widget impossible to match by name. Any combination of
	// alphanumeric symbols, dashes and underscores will suffice.
	//
	// This method is inherited from Widget
	SetName(name string)
	// SetOpacity: request the @widget to be rendered partially transparent.
	//
	// An opacity of 0 is fully transparent and an opacity of 1 is fully opaque.
	//
	// Opacity works on both toplevel widgets and child widgets, although there
	// are some limitations: For toplevel widgets, applying opacity depends on
	// the capabilities of the windowing system. On X11, this has any effect
	// only on X displays with a compositing manager, see
	// gdk_display_is_composited(). On Windows and Wayland it should always
	// work, although setting a window’s opacity after the window has been shown
	// may cause some flicker.
	//
	// Note that the opacity is inherited through inclusion — if you set a
	// toplevel to be partially translucent, all of its content will appear
	// translucent, since it is ultimatively rendered on that toplevel. The
	// opacity value itself is not inherited by child widgets (since that would
	// make widgets deeper in the hierarchy progressively more translucent). As
	// a consequence, [class@Gtk.Popover]s and other [class@Gtk.Native] widgets
	// with their own surface will use their own opacity value, and thus by
	// default appear non-translucent, even if they are attached to a toplevel
	// that is translucent.
	//
	// This method is inherited from Widget
	SetOpacity(opacity float64)
	// SetOverflow sets how @widget treats content that is drawn outside the
	// widget's content area.
	//
	// See the definition of [enum@Gtk.Overflow] for details.
	//
	// This setting is provided for widget implementations and should not be
	// used by application code.
	//
	// The default value is GTK_OVERFLOW_VISIBLE.
	//
	// This method is inherited from Widget
	SetOverflow(overflow Overflow)
	// SetParent sets @parent as the parent widget of @widget.
	//
	// This takes care of details such as updating the state and style of the
	// child to reflect its new location and resizing the parent. The opposite
	// function is [method@Gtk.Widget.unparent].
	//
	// This function is useful only when implementing subclasses of `GtkWidget`.
	//
	// This method is inherited from Widget
	SetParent(parent Widget)
	// SetReceivesDefault specifies whether @widget will be treated as the
	// default widget within its toplevel when it has the focus, even if another
	// widget is the default.
	//
	// This method is inherited from Widget
	SetReceivesDefault(receivesDefault bool)
	// SetSensitive sets the sensitivity of a widget.
	//
	// A widget is sensitive if the user can interact with it. Insensitive
	// widgets are “grayed out” and the user can’t interact with them.
	// Insensitive widgets are known as “inactive”, “disabled”, or “ghosted” in
	// some other toolkits.
	//
	// This method is inherited from Widget
	SetSensitive(sensitive bool)
	// SetSizeRequest sets the minimum size of a widget.
	//
	// That is, the widget’s size request will be at least @width by @height.
	// You can use this function to force a widget to be larger than it normally
	// would be.
	//
	// In most cases, [method@Gtk.Window.set_default_size] is a better choice
	// for toplevel windows than this function; setting the default size will
	// still allow users to shrink the window. Setting the size request will
	// force them to leave the window at least as large as the size request.
	//
	// Note the inherent danger of setting any fixed size - themes, translations
	// into other languages, different fonts, and user action can all change the
	// appropriate size for a given widget. So, it's basically impossible to
	// hardcode a size that will always be correct.
	//
	// The size request of a widget is the smallest size a widget can accept
	// while still functioning well and drawing itself correctly. However in
	// some strange cases a widget may be allocated less than its requested
	// size, and in many cases a widget may be allocated more space than it
	// requested.
	//
	// If the size request in a given direction is -1 (unset), then the
	// “natural” size request of the widget will be used instead.
	//
	// The size request set here does not include any margin from the properties
	// [property@Gtk.Widget:margin-start], [property@Gtk.Widget:margin-end],
	// [property@Gtk.Widget:margin-top], and
	// [property@Gtk.Widget:margin-bottom], but it does include pretty much all
	// other padding or border properties set by any subclass of `GtkWidget`.
	//
	// This method is inherited from Widget
	SetSizeRequest(width int, height int)
	// SetStateFlags turns on flag values in the current widget state.
	//
	// Typical widget states are insensitive, prelighted, etc.
	//
	// This function accepts the values GTK_STATE_FLAG_DIR_LTR and
	// GTK_STATE_FLAG_DIR_RTL but ignores them. If you want to set the widget's
	// direction, use [method@Gtk.Widget.set_direction].
	//
	// This function is for use in widget implementations.
	//
	// This method is inherited from Widget
	SetStateFlags(flags StateFlags, clear bool)
	// SetTooltipMarkup sets @markup as the contents of the tooltip, which is
	// marked up with Pango markup.
	//
	// This function will take care of setting the
	// [property@Gtk.Widget:has-tooltip] as a side effect, and of the default
	// handler for the [signal@Gtk.Widget::query-tooltip] signal.
	//
	// See also [method@Gtk.Tooltip.set_markup].
	//
	// This method is inherited from Widget
	SetTooltipMarkup(markup string)
	// SetTooltipText sets @text as the contents of the tooltip.
	//
	// If @text contains any markup, it will be escaped.
	//
	// This function will take care of setting [property@Gtk.Widget:has-tooltip]
	// as a side effect, and of the default handler for the
	// [signal@Gtk.Widget::query-tooltip] signal.
	//
	// See also [method@Gtk.Tooltip.set_text].
	//
	// This method is inherited from Widget
	SetTooltipText(text string)
	// SetVAlign sets the vertical alignment of @widget.
	//
	// This method is inherited from Widget
	SetVAlign(align Align)
	// SetVExpand sets whether the widget would like any available extra
	// vertical space.
	//
	// See [method@Gtk.Widget.set_hexpand] for more detail.
	//
	// This method is inherited from Widget
	SetVExpand(expand bool)
	// SetVExpandSet sets whether the vexpand flag will be used.
	//
	// See [method@Gtk.Widget.set_hexpand_set] for more detail.
	//
	// This method is inherited from Widget
	SetVExpandSet(set bool)
	// SetVisible sets the visibility state of @widget.
	//
	// Note that setting this to true doesn’t mean the widget is actually
	// viewable, see [method@Gtk.Widget.get_visible].
	//
	// This function simply calls [method@Gtk.Widget.show] or
	// [method@Gtk.Widget.hide] but is nicer to use when the visibility of the
	// widget depends on some condition.
	//
	// This method is inherited from Widget
	SetVisible(visible bool)
	// ShouldLayout returns whether @widget should contribute to the measuring
	// and allocation of its parent.
	//
	// This is false for invisible children, but also for children that have
	// their own surface.
	//
	// This method is inherited from Widget
	ShouldLayout() bool
	// Show flags a widget to be displayed.
	//
	// Any widget that isn’t shown will not appear on the screen.
	//
	// Remember that you have to show the containers containing a widget, in
	// addition to the widget itself, before it will appear onscreen.
	//
	// When a toplevel container is shown, it is immediately realized and
	// mapped; other shown widgets are realized and mapped when their toplevel
	// container is realized and mapped.
	//
	// This method is inherited from Widget
	Show()
	// SnapshotChild: snapshot the a child of @widget.
	//
	// When a widget receives a call to the snapshot function, it must send
	// synthetic `GtkWidget`Class.snapshot() calls to all children. This
	// function provides a convenient way of doing this. A widget, when it
	// receives a call to its `GtkWidget`Class.snapshot() function, calls
	// gtk_widget_snapshot_child() once for each child, passing in the @snapshot
	// the widget received.
	//
	// gtk_widget_snapshot_child() takes care of translating the origin of
	// @snapshot, and deciding whether the child needs to be snapshot.
	//
	// This function does nothing for children that implement `GtkNative`.
	//
	// This method is inherited from Widget
	SnapshotChild(child Widget, snapshot Snapshot)
	// TranslateCoordinates: translate coordinates relative to @src_widget’s
	// allocation to coordinates relative to @dest_widget’s allocations.
	//
	// In order to perform this operation, both widget must share a common
	// ancestor.
	//
	// This method is inherited from Widget
	TranslateCoordinates(destWidget Widget, srcX float64, srcY float64) (destX float64, destY float64, ok bool)
	// TriggerTooltipQuery triggers a tooltip query on the display where the
	// toplevel of @widget is located.
	//
	// This method is inherited from Widget
	TriggerTooltipQuery()
	// Unmap causes a widget to be unmapped if it’s currently mapped.
	//
	// This function is only for use in widget implementations.
	//
	// This method is inherited from Widget
	Unmap()
	// Unparent: dissociate @widget from its parent.
	//
	// This function is only for use in widget implementations, typically in
	// dispose.
	//
	// This method is inherited from Widget
	Unparent()
	// Unrealize causes a widget to be unrealized (frees all GDK resources
	// associated with the widget).
	//
	// This function is only useful in widget implementations.
	//
	// This method is inherited from Widget
	Unrealize()
	// UnsetStateFlags turns off flag values for the current widget state.
	//
	// See [method@Gtk.Widget.set_state_flags].
	//
	// This function is for use in widget implementations.
	//
	// This method is inherited from Widget
	UnsetStateFlags(flags StateFlags)
	// GetAccessibleRole retrieves the `GtkAccessibleRole` for the given
	// `GtkAccessible`.
	//
	// This method is inherited from Accessible
	GetAccessibleRole() AccessibleRole
	// ResetProperty resets the accessible @property to its default value.
	//
	// This method is inherited from Accessible
	ResetProperty(property AccessibleProperty)
	// ResetRelation resets the accessible @relation to its default value.
	//
	// This method is inherited from Accessible
	ResetRelation(relation AccessibleRelation)
	// ResetState resets the accessible @state to its default value.
	//
	// This method is inherited from Accessible
	ResetState(state AccessibleState)
	// UpdatePropertyValue updates an array of accessible properties.
	//
	// This function should be called by `GtkWidget` types whenever an
	// accessible property change must be communicated to assistive
	// technologies.
	//
	// This function is meant to be used by language bindings.
	//
	// This method is inherited from Accessible
	UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value)
	// UpdateRelationValue updates an array of accessible relations.
	//
	// This function should be called by `GtkWidget` types whenever an
	// accessible relation change must be communicated to assistive
	// technologies.
	//
	// This function is meant to be used by language bindings.
	//
	// This method is inherited from Accessible
	UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value)
	// UpdateStateValue updates an array of accessible states.
	//
	// This function should be called by `GtkWidget` types whenever an
	// accessible state change must be communicated to assistive technologies.
	//
	// This function is meant to be used by language bindings.
	//
	// This method is inherited from Accessible
	UpdateStateValue(states []AccessibleState, values []externglib.Value)
	// GetBuildableID gets the ID of the @buildable object.
	//
	// `GtkBuilder` sets the name based on the ID attribute of the <object> tag
	// used to construct the @buildable.
	//
	// This method is inherited from Buildable
	GetBuildableID() string
	// ActionSetEnabled: enable or disable an action installed with
	// gtk_widget_class_install_action().
	//
	// This method is inherited from Widget
	ActionSetEnabled(actionName string, enabled bool)
	// Activate: for widgets that can be “activated” (buttons, menu items, etc.)
	// this function activates them.
	//
	// The activation will emit the signal set using
	// gtk_widget_class_set_activate_signal() during class initialization.
	//
	// Activation is what happens when you press Enter on a widget during key
	// navigation.
	//
	// If you wish to handle the activation keybinding yourself, it is
	// recommended to use gtk_widget_class_add_shortcut() with an action created
	// with gtk_signal_action_new().
	//
	// If @widget isn't activatable, the function returns false.
	//
	// This method is inherited from Widget
	Activate() bool
	// ActivateActionVariant looks up the action in the action groups associated
	// with @widget and its ancestors, and activates it.
	//
	// If the action is in an action group added with
	// [method@Gtk.Widget.insert_action_group], the @name is expected to be
	// prefixed with the prefix that was used when the group was inserted.
	//
	// The arguments must match the actions expected parameter type, as returned
	// by `g_action_get_parameter_type()`.
	//
	// This method is inherited from Widget
	ActivateActionVariant(name string, args *glib.Variant) bool
	// ActivateDefault activates the `default.activate` action from @widget.
	//
	// This method is inherited from Widget
	ActivateDefault()
	// AddController adds @controller to @widget so that it will receive events.
	//
	// You will usually want to call this function right after creating any kind
	// of [class@Gtk.EventController].
	//
	// This method is inherited from Widget
	AddController(controller EventController)
	// AddCSSClass adds a style class to @widget.
	//
	// After calling this function, the widgets style will match for @css_class,
	// according to CSS matching rules.
	//
	// Use [method@Gtk.Widget.remove_css_class] to remove the style again.
	//
	// This method is inherited from Widget
	AddCSSClass(cssClass string)
	// AddMnemonicLabel adds a widget to the list of mnemonic labels for this
	// widget.
	//
	// See [method@Gtk.Widget.list_mnemonic_labels]. Note the list of mnemonic
	// labels for the widget is cleared when the widget is destroyed, so the
	// caller must make sure to update its internal state at this point as well,
	// by using a connection to the [signal@Gtk.Widget::destroy] signal or a
	// weak notifier.
	//
	// This method is inherited from Widget
	AddMnemonicLabel(label Widget)
	// Allocate: this function is only used by `GtkWidget` subclasses, to assign
	// a size, position and (optionally) baseline to their child widgets.
	//
	// In this function, the allocation and baseline may be adjusted. The given
	// allocation will be forced to be bigger than the widget's minimum size, as
	// well as at least 0×0 in size.
	//
	// For a version that does not take a transform, see
	// [method@Gtk.Widget.size_allocate].
	//
	// This method is inherited from Widget
	Allocate(width int, height int, baseline int, transform *gsk.Transform)
	// ChildFocus: called by widgets as the user moves around the window using
	// keyboard shortcuts.
	//
	// The @direction argument indicates what kind of motion is taking place
	// (up, down, left, right, tab forward, tab backward).
	//
	// This function calls the [vfunc@Gtk.Widget.focus] virtual function;
	// widgets can override the virtual function in order to implement
	// appropriate focus behavior.
	//
	// The default `focus()` virtual function for a widget should return `TRUE`
	// if moving in @direction left the focus on a focusable location inside
	// that widget, and `FALSE` if moving in @direction moved the focus outside
	// the widget. When returning `TRUE`, widgets normallycall
	// [method@Gtk.Widget.grab_focus] to place the focus accordingly; when
	// returning `FALSE`, they don’t modify the current focus location.
	//
	// This function is used by custom widget implementations; if you're writing
	// an app, you’d use [method@Gtk.Widget.grab_focus] to move the focus to a
	// particular widget.
	//
	// This method is inherited from Widget
	ChildFocus(direction DirectionType) bool
	// ComputeBounds computes the bounds for @widget in the coordinate space of
	// @target.
	//
	// FIXME: Explain what "bounds" are.
	//
	// If the operation is successful, true is returned. If @widget has no
	// bounds or the bounds cannot be expressed in @target's coordinate space
	// (for example if both widgets are in different windows), false is returned
	// and @bounds is set to the zero rectangle.
	//
	// It is valid for @widget and @target to be the same widget.
	//
	// This method is inherited from Widget
	ComputeBounds(target Widget) (graphene.Rect, bool)
	// ComputeExpand computes whether a container should give this widget extra
	// space when possible.
	//
	// Containers should check this, rather than looking at
	// [method@Gtk.Widget.get_hexpand] or [method@Gtk.Widget.get_vexpand].
	//
	// This function already checks whether the widget is visible, so visibility
	// does not need to be checked separately. Non-visible widgets are not
	// expanded.
	//
	// The computed expand value uses either the expand setting explicitly set
	// on the widget itself, or, if none has been explicitly set, the widget may
	// expand if some of its children do.
	//
	// This method is inherited from Widget
	ComputeExpand(orientation Orientation) bool
	// ComputePoint translates the given @point in @widget's coordinates to
	// coordinates relative to @target’s coordinate system.
	//
	// In order to perform this operation, both widgets must share a common
	// ancestor.
	//
	// This method is inherited from Widget
	ComputePoint(target Widget, point *graphene.Point) (graphene.Point, bool)
	// ComputeTransform computes a matrix suitable to describe a transformation
	// from @widget's coordinate system into @target's coordinate system.
	//
	// This method is inherited from Widget
	ComputeTransform(target Widget) (graphene.Matrix, bool)
	// Contains tests if the point at (@x, @y) is contained in @widget.
	//
	// The coordinates for (@x, @y) must be in widget coordinates, so (0, 0) is
	// assumed to be the top left of @widget's content area.
	//
	// This method is inherited from Widget
	Contains(x float64, y float64) bool
	// CreatePangoContext creates a new `PangoContext` with the appropriate font
	// map, font options, font description, and base direction for drawing text
	// for this widget.
	//
	// See also [method@Gtk.Widget.get_pango_context].
	//
	// This method is inherited from Widget
	CreatePangoContext() pango.Context
	// CreatePangoLayout creates a new `PangoLayout` with the appropriate font
	// map, font description, and base direction for drawing text for this
	// widget.
	//
	// If you keep a `PangoLayout` created in this way around, you need to
	// re-create it when the widget `PangoContext` is replaced. This can be
	// tracked by listening to changes of the [property@Gtk.Widget:root]
	// property on the widget.
	//
	// This method is inherited from Widget
	CreatePangoLayout(text string) pango.Layout
	// DragCheckThreshold checks to see if a drag movement has passed the GTK
	// drag threshold.
	//
	// This method is inherited from Widget
	DragCheckThreshold(startX int, startY int, currentX int, currentY int) bool
	// ErrorBell notifies the user about an input-related error on this widget.
	//
	// If the [property@Gtk.Settings:gtk-error-bell] setting is true, it calls
	// [method@Gdk.Surface.beep], otherwise it does nothing.
	//
	// Note that the effect of [method@Gdk.Surface.beep] can be configured in
	// many ways, depending on the windowing backend and the desktop environment
	// or window manager that is used.
	//
	// This method is inherited from Widget
	ErrorBell()
	// GetAllocatedBaseline returns the baseline that has currently been
	// allocated to @widget.
	//
	// This function is intended to be used when implementing handlers for the
	// `GtkWidget`Class.snapshot() function, and when allocating child widgets
	// in `GtkWidget`Class.size_allocate().
	//
	// This method is inherited from Widget
	GetAllocatedBaseline() int
	// GetAllocatedHeight returns the height that has currently been allocated
	// to @widget.
	//
	// This method is inherited from Widget
	GetAllocatedHeight() int
	// GetAllocatedWidth returns the width that has currently been allocated to
	// @widget.
	//
	// This method is inherited from Widget
	GetAllocatedWidth() int
	// GetAncestor gets the first ancestor of @widget with type @widget_type.
	//
	// For example, `gtk_widget_get_ancestor (widget, GTK_TYPE_BOX)` gets the
	// first `GtkBox` that’s an ancestor of @widget. No reference will be added
	// to the returned widget; it should not be unreferenced.
	//
	// Note that unlike [method@Gtk.Widget.is_ancestor], this function considers
	// @widget to be an ancestor of itself.
	//
	// This method is inherited from Widget
	GetAncestor(widgetType externglib.Type) Widget
	// GetCanFocus determines whether the input focus can enter @widget or any
	// of its children.
	//
	// See [method@Gtk.Widget.set_focusable].
	//
	// This method is inherited from Widget
	GetCanFocus() bool
	// GetCanTarget queries whether @widget can be the target of pointer events.
	//
	// This method is inherited from Widget
	GetCanTarget() bool
	// GetChildVisible gets the value set with gtk_widget_set_child_visible().
	//
	// If you feel a need to use this function, your code probably needs
	// reorganization.
	//
	// This function is only useful for container implementations and should
	// never be called by an application.
	//
	// This method is inherited from Widget
	GetChildVisible() bool
	// GetClipboard gets the clipboard object for @widget.
	//
	// This is a utility function to get the clipboard object for the
	// `GdkDisplay` that @widget is using.
	//
	// Note that this function always works, even when @widget is not realized
	// yet.
	//
	// This method is inherited from Widget
	GetClipboard() gdk.Clipboard
	// GetCSSClasses returns the list of style classes applied to @widget.
	//
	// This method is inherited from Widget
	GetCSSClasses() []string
	// GetCSSName returns the CSS name that is used for @self.
	//
	// This method is inherited from Widget
	GetCSSName() string
	// GetCursor queries the cursor set on @widget.
	//
	// See [method@Gtk.Widget.set_cursor] for details.
	//
	// This method is inherited from Widget
	GetCursor() gdk.Cursor
	// GetDirection gets the reading direction for a particular widget.
	//
	// See [method@Gtk.Widget.set_direction].
	//
	// This method is inherited from Widget
	GetDirection() TextDirection
	// GetDisplay: get the `GdkDisplay` for the toplevel window associated with
	// this widget.
	//
	// This function can only be called after the widget has been added to a
	// widget hierarchy with a `GtkWindow` at the top.
	//
	// In general, you should only create display specific resources when a
	// widget has been realized, and you should free those resources when the
	// widget is unrealized.
	//
	// This method is inherited from Widget
	GetDisplay() gdk.Display
	// GetFirstChild returns the widgets first child.
	//
	// This API is primarily meant for widget implementations.
	//
	// This method is inherited from Widget
	GetFirstChild() Widget
	// GetFocusChild returns the current focus child of @widget.
	//
	// This method is inherited from Widget
	GetFocusChild() Widget
	// GetFocusOnClick returns whether the widget should grab focus when it is
	// clicked with the mouse.
	//
	// See [method@Gtk.Widget.set_focus_on_click].
	//
	// This method is inherited from Widget
	GetFocusOnClick() bool
	// GetFocusable determines whether @widget can own the input focus.
	//
	// See [method@Gtk.Widget.set_focusable].
	//
	// This method is inherited from Widget
	GetFocusable() bool
	// GetFontMap gets the font map of @widget.
	//
	// See [method@Gtk.Widget.set_font_map].
	//
	// This method is inherited from Widget
	GetFontMap() pango.FontMap
	// GetFontOptions returns the `cairo_font_options_t` used for Pango
	// rendering.
	//
	// When not set, the defaults font options for the `GdkDisplay` will be
	// used.
	//
	// This method is inherited from Widget
	GetFontOptions() *cairo.FontOptions
	// GetFrameClock obtains the frame clock for a widget.
	//
	// The frame clock is a global “ticker” that can be used to drive animations
	// and repaints. The most common reason to get the frame clock is to call
	// [method@Gdk.FrameClock.get_frame_time], in order to get a time to use for
	// animating. For example you might record the start of the animation with
	// an initial value from [method@Gdk.FrameClock.get_frame_time], and then
	// update the animation by calling [method@Gdk.FrameClock.get_frame_time]
	// again during each repaint.
	//
	// [method@Gdk.FrameClock.request_phase] will result in a new frame on the
	// clock, but won’t necessarily repaint any widgets. To repaint a widget,
	// you have to use [method@Gtk.Widget.queue_draw] which invalidates the
	// widget (thus scheduling it to receive a draw on the next frame).
	// gtk_widget_queue_draw() will also end up requesting a frame on the
	// appropriate frame clock.
	//
	// A widget’s frame clock will not change while the widget is mapped.
	// Reparenting a widget (which implies a temporary unmap) can change the
	// widget’s frame clock.
	//
	// Unrealized widgets do not have a frame clock.
	//
	// This method is inherited from Widget
	GetFrameClock() gdk.FrameClock
	// GetHAlign gets the horizontal alignment of @widget.
	//
	// For backwards compatibility reasons this method will never return
	// GTK_ALIGN_BASELINE, but instead it will convert it to GTK_ALIGN_FILL.
	// Baselines are not supported for horizontal alignment.
	//
	// This method is inherited from Widget
	GetHAlign() Align
	// GetHasTooltip returns the current value of the `has-tooltip` property.
	//
	// This method is inherited from Widget
	GetHasTooltip() bool
	// GetHeight returns the content height of the widget.
	//
	// This function returns the size passed to its size-allocate
	// implementation, which is the size you should be using in
	// GtkWidgetClass.snapshot().
	//
	// For pointer events, see [method@Gtk.Widget.contains].
	//
	// This method is inherited from Widget
	GetHeight() int
	// GetHExpand gets whether the widget would like any available extra
	// horizontal space.
	//
	// When a user resizes a `GtkWindow`, widgets with expand=TRUE generally
	// receive the extra space. For example, a list or scrollable area or
	// document in your window would often be set to expand.
	//
	// Containers should use [method@Gtk.Widget.compute_expand] rather than this
	// function, to see whether a widget, or any of its children, has the expand
	// flag set. If any child of a widget wants to expand, the parent may ask to
	// expand also.
	//
	// This function only looks at the widget’s own hexpand flag, rather than
	// computing whether the entire widget tree rooted at this widget wants to
	// expand.
	//
	// This method is inherited from Widget
	GetHExpand() bool
	// GetHExpandSet gets whether gtk_widget_set_hexpand() has been used to
	// explicitly set the expand flag on this widget.
	//
	// If [property@Gtk.Widget:hexpand] property is set, then it overrides any
	// computed expand value based on child widgets. If `hexpand` is not set,
	// then the expand value depends on whether any children of the widget would
	// like to expand.
	//
	// There are few reasons to use this function, but it’s here for
	// completeness and consistency.
	//
	// This method is inherited from Widget
	GetHExpandSet() bool
	// GetLastChild returns the widgets last child.
	//
	// This API is primarily meant for widget implementations.
	//
	// This method is inherited from Widget
	GetLastChild() Widget
	// GetLayoutManager retrieves the layout manager used by @widget
	//
	// See [method@Gtk.Widget.set_layout_manager].
	//
	// This method is inherited from Widget
	GetLayoutManager() LayoutManager
	// GetMapped: whether the widget is mapped.
	//
	// This method is inherited from Widget
	GetMapped() bool
	// GetMarginBottom gets the bottom margin of @widget.
	//
	// This method is inherited from Widget
	GetMarginBottom() int
	// GetMarginEnd gets the end margin of @widget.
	//
	// This method is inherited from Widget
	GetMarginEnd() int
	// GetMarginStart gets the start margin of @widget.
	//
	// This method is inherited from Widget
	GetMarginStart() int
	// GetMarginTop gets the top margin of @widget.
	//
	// This method is inherited from Widget
	GetMarginTop() int
	// GetName retrieves the name of a widget.
	//
	// See [method@Gtk.Widget.set_name] for the significance of widget names.
	//
	// This method is inherited from Widget
	GetName() string
	// GetNative returns the `GtkNative` widget that contains @widget.
	//
	// This function will return nil if the widget is not contained inside a
	// widget tree with a native ancestor.
	//
	// `GtkNative` widgets will return themselves here.
	//
	// This method is inherited from Widget
	GetNative() Native
	// GetNextSibling returns the widgets next sibling.
	//
	// This API is primarily meant for widget implementations.
	//
	// This method is inherited from Widget
	GetNextSibling() Widget
	// GetOpacity the requested opacity for this widget.
	//
	// See [method@Gtk.Widget.set_opacity].
	//
	// This method is inherited from Widget
	GetOpacity() float64
	// GetOverflow returns the widgets overflow value.
	//
	// This method is inherited from Widget
	GetOverflow() Overflow
	// GetPangoContext gets a `PangoContext` with the appropriate font map, font
	// description, and base direction for this widget.
	//
	// Unlike the context returned by [method@Gtk.Widget.create_pango_context],
	// this context is owned by the widget (it can be used until the screen for
	// the widget changes or the widget is removed from its toplevel), and will
	// be updated to match any changes to the widget’s attributes. This can be
	// tracked by listening to changes of the [property@Gtk.Widget:root]
	// property on the widget.
	//
	// This method is inherited from Widget
	GetPangoContext() pango.Context
	// GetParent returns the parent widget of @widget.
	//
	// This method is inherited from Widget
	GetParent() Widget
	// GetPreferredSize retrieves the minimum and natural size of a widget,
	// taking into account the widget’s preference for height-for-width
	// management.
	//
	// This is used to retrieve a suitable size by container widgets which do
	// not impose any restrictions on the child placement. It can be used to
	// deduce toplevel window and menu sizes as well as child widgets in
	// free-form containers such as `GtkFixed`.
	//
	// Handle with care. Note that the natural height of a height-for-width
	// widget will generally be a smaller size than the minimum height, since
	// the required height for the natural width is generally smaller than the
	// required height for the minimum width.
	//
	// Use [id@gtk_widget_measure] if you want to support baseline alignment.
	//
	// This method is inherited from Widget
	GetPreferredSize() (minimumSize Requisition, naturalSize Requisition)
	// GetPrevSibling returns the widgets previous sibling.
	//
	// This API is primarily meant for widget implementations.
	//
	// This method is inherited from Widget
	GetPrevSibling() Widget
	// GetPrimaryClipboard gets the primary clipboard of @widget.
	//
	// This is a utility function to get the primary clipboard object for the
	// `GdkDisplay` that @widget is using.
	//
	// Note that this function always works, even when @widget is not realized
	// yet.
	//
	// This method is inherited from Widget
	GetPrimaryClipboard() gdk.Clipboard
	// GetRealized determines whether @widget is realized.
	//
	// This method is inherited from Widget
	GetRealized() bool
	// GetReceivesDefault determines whether @widget is always treated as the
	// default widget within its toplevel when it has the focus, even if another
	// widget is the default.
	//
	// See [method@Gtk.Widget.set_receives_default].
	//
	// This method is inherited from Widget
	GetReceivesDefault() bool
	// GetRequestMode gets whether the widget prefers a height-for-width layout
	// or a width-for-height layout.
	//
	// Single-child widgets generally propagate the preference of their child,
	// more complex widgets need to request something either in context of their
	// children or in context of their allocation capabilities.
	//
	// This method is inherited from Widget
	GetRequestMode() SizeRequestMode
	// GetRoot returns the `GtkRoot` widget of @widget.
	//
	// This function will return nil if the widget is not contained inside a
	// widget tree with a root widget.
	//
	// `GtkRoot` widgets will return themselves here.
	//
	// This method is inherited from Widget
	GetRoot() Root
	// GetScaleFactor retrieves the internal scale factor that maps from window
	// coordinates to the actual device pixels.
	//
	// On traditional systems this is 1, on high density outputs, it can be a
	// higher value (typically 2).
	//
	// See [method@Gdk.Surface.get_scale_factor].
	//
	// This method is inherited from Widget
	GetScaleFactor() int
	// GetSensitive returns the widget’s sensitivity.
	//
	// This function returns the value that has been set using
	// [method@Gtk.Widget.set_sensitive]).
	//
	// The effective sensitivity of a widget is however determined by both its
	// own and its parent widget’s sensitivity. See
	// [method@Gtk.Widget.is_sensitive].
	//
	// This method is inherited from Widget
	GetSensitive() bool
	// GetSettings gets the settings object holding the settings used for this
	// widget.
	//
	// Note that this function can only be called when the `GtkWidget` is
	// attached to a toplevel, since the settings object is specific to a
	// particular `GdkDisplay`. If you want to monitor the widget for changes in
	// its settings, connect to notify::display.
	//
	// This method is inherited from Widget
	GetSettings() Settings
	// GetSize returns the content width or height of the widget.
	//
	// Which dimension is returned depends on @orientation.
	//
	// This is equivalent to calling [method@Gtk.Widget.get_width] for
	// GTK_ORIENTATION_HORIZONTAL or [method@Gtk.Widget.get_height] for
	// GTK_ORIENTATION_VERTICAL, but can be used when writing
	// orientation-independent code, such as when implementing
	// [iface@Gtk.Orientable] widgets.
	//
	// This method is inherited from Widget
	GetSize(orientation Orientation) int
	// GetSizeRequest gets the size request that was explicitly set for the
	// widget using gtk_widget_set_size_request().
	//
	// A value of -1 stored in @width or @height indicates that that dimension
	// has not been set explicitly and the natural requisition of the widget
	// will be used instead. See [method@Gtk.Widget.set_size_request]. To get
	// the size a widget will actually request, call [method@Gtk.Widget.measure]
	// instead of this function.
	//
	// This method is inherited from Widget
	GetSizeRequest() (width int, height int)
	// GetStateFlags returns the widget state as a flag set.
	//
	// It is worth mentioning that the effective GTK_STATE_FLAG_INSENSITIVE
	// state will be returned, that is, also based on parent insensitivity, even
	// if @widget itself is sensitive.
	//
	// Also note that if you are looking for a way to obtain the
	// [flags@Gtk.StateFlags] to pass to a [class@Gtk.StyleContext] method, you
	// should look at [method@Gtk.StyleContext.get_state].
	//
	// This method is inherited from Widget
	GetStateFlags() StateFlags
	// GetStyleContext returns the style context associated to @widget.
	//
	// The returned object is guaranteed to be the same for the lifetime of
	// @widget.
	//
	// This method is inherited from Widget
	GetStyleContext() StyleContext
	// GetTemplateChild: fetch an object build from the template XML for
	// @widget_type in this @widget instance.
	//
	// This will only report children which were previously declared with
	// [method@Gtk.WidgetClass.bind_template_child_full] or one of its variants.
	//
	// This function is only meant to be called for code which is private to the
	// @widget_type which declared the child and is meant for language bindings
	// which cannot easily make use of the GObject structure offsets.
	//
	// This method is inherited from Widget
	GetTemplateChild(widgetType externglib.Type, name string) gextras.Objector
	// GetTooltipMarkup gets the contents of the tooltip for @widget.
	//
	// If the tooltip has not been set using
	// [method@Gtk.Widget.set_tooltip_markup], this function returns nil.
	//
	// This method is inherited from Widget
	GetTooltipMarkup() string
	// GetTooltipText gets the contents of the tooltip for @widget.
	//
	// If the @widget's tooltip was set using
	// [method@Gtk.Widget.set_tooltip_markup], this function will return the
	// escaped text.
	//
	// This method is inherited from Widget
	GetTooltipText() string
	// GetVAlign gets the vertical alignment of @widget.
	//
	// This method is inherited from Widget
	GetVAlign() Align
	// GetVExpand gets whether the widget would like any available extra
	// vertical space.
	//
	// See [method@Gtk.Widget.get_hexpand] for more detail.
	//
	// This method is inherited from Widget
	GetVExpand() bool
	// GetVExpandSet gets whether gtk_widget_set_vexpand() has been used to
	// explicitly set the expand flag on this widget.
	//
	// See [method@Gtk.Widget.get_hexpand_set] for more detail.
	//
	// This method is inherited from Widget
	GetVExpandSet() bool
	// GetVisible determines whether the widget is visible.
	//
	// If you want to take into account whether the widget’s parent is also
	// marked as visible, use [method@Gtk.Widget.is_visible] instead.
	//
	// This function does not check if the widget is obscured in any way.
	//
	// See [method@Gtk.Widget.set_visible].
	//
	// This method is inherited from Widget
	GetVisible() bool
	// GetWidth returns the content width of the widget.
	//
	// This function returns the size passed to its size-allocate
	// implementation, which is the size you should be using in
	// GtkWidgetClass.snapshot().
	//
	// For pointer events, see [method@Gtk.Widget.contains].
	//
	// This method is inherited from Widget
	GetWidth() int
	// GrabFocus causes @widget to have the keyboard focus for the `GtkWindow`
	// it's inside.
	//
	// If @widget is not focusable, or its ::grab_focus implementation cannot
	// transfer the focus to a descendant of @widget that is focusable, it will
	// not take focus and false will be returned.
	//
	// Calling [method@Gtk.Widget.grab_focus] on an already focused widget is
	// allowed, should not have an effect, and return true.
	//
	// This method is inherited from Widget
	GrabFocus() bool
	// HasCSSClass returns whether @css_class is currently applied to @widget.
	//
	// This method is inherited from Widget
	HasCSSClass(cssClass string) bool
	// HasDefault determines whether @widget is the current default widget
	// within its toplevel.
	//
	// This method is inherited from Widget
	HasDefault() bool
	// HasFocus determines if the widget has the global input focus.
	//
	// See [method@Gtk.Widget.is_focus] for the difference between having the
	// global input focus, and only having the focus within a toplevel.
	//
	// This method is inherited from Widget
	HasFocus() bool
	// HasVisibleFocus determines if the widget should show a visible indication
	// that it has the global input focus.
	//
	// This is a convenience function that takes into account whether focus
	// indication should currently be shown in the toplevel window of @widget.
	// See [method@Gtk.Window.get_focus_visible] for more information about
	// focus indication.
	//
	// To find out if the widget has the global input focus, use
	// [method@Gtk.Widget.has_focus].
	//
	// This method is inherited from Widget
	HasVisibleFocus() bool
	// Hide reverses the effects of gtk_widget_show().
	//
	// This is causing the widget to be hidden (invisible to the user).
	//
	// This method is inherited from Widget
	Hide()
	// InDestruction returns whether the widget is currently being destroyed.
	//
	// This information can sometimes be used to avoid doing unnecessary work.
	//
	// This method is inherited from Widget
	InDestruction() bool
	// InitTemplate creates and initializes child widgets defined in templates.
	//
	// This function must be called in the instance initializer for any class
	// which assigned itself a template using
	// [method@Gtk.WidgetClass.set_template].
	//
	// It is important to call this function in the instance initializer of a
	// `GtkWidget` subclass and not in `GObject.constructed()` or
	// `GObject.constructor()` for two reasons:
	//
	//    - derived widgets will assume that the composite widgets
	//      defined by its parent classes have been created in their
	//      relative instance initializers
	//    - when calling `g_object_new()` on a widget with composite templates,
	//      it’s important to build the composite widgets before the construct
	//      properties are set. Properties passed to `g_object_new()` should
	//      take precedence over properties set in the private template XML
	//
	// A good rule of thumb is to call this function as the first thing in an
	// instance initialization function.
	//
	// This method is inherited from Widget
	InitTemplate()
	// InsertAfter inserts @widget into the child widget list of @parent.
	//
	// It will be placed after @previous_sibling, or at the beginning if
	// @previous_sibling is nil.
	//
	// After calling this function, `gtk_widget_get_prev_sibling(widget)` will
	// return @previous_sibling.
	//
	// If @parent is already set as the parent widget of @widget, this function
	// can also be used to reorder @widget in the child widget list of @parent.
	//
	// This API is primarily meant for widget implementations; if you are just
	// using a widget, you *must* use its own API for adding children.
	//
	// This method is inherited from Widget
	InsertAfter(parent Widget, previousSibling Widget)
	// InsertBefore inserts @widget into the child widget list of @parent.
	//
	// It will be placed before @next_sibling, or at the end if @next_sibling is
	// nil.
	//
	// After calling this function, `gtk_widget_get_next_sibling(widget)` will
	// return @next_sibling.
	//
	// If @parent is already set as the parent widget of @widget, this function
	// can also be used to reorder @widget in the child widget list of @parent.
	//
	// This API is primarily meant for widget implementations; if you are just
	// using a widget, you *must* use its own API for adding children.
	//
	// This method is inherited from Widget
	InsertBefore(parent Widget, nextSibling Widget)
	// IsAncestor determines whether @widget is somewhere inside @ancestor,
	// possibly with intermediate containers.
	//
	// This method is inherited from Widget
	IsAncestor(ancestor Widget) bool
	// IsDrawable determines whether @widget can be drawn to.
	//
	// A widget can be drawn if it is mapped and visible.
	//
	// This method is inherited from Widget
	IsDrawable() bool
	// IsFocus determines if the widget is the focus widget within its toplevel.
	//
	// This does not mean that the [property@Gtk.Widget:has-focus] property is
	// necessarily set; [property@Gtk,Widget:has-focus] will only be set if the
	// toplevel widget additionally has the global input focus.)
	//
	// This method is inherited from Widget
	IsFocus() bool
	// IsSensitive returns the widget’s effective sensitivity.
	//
	// This means it is sensitive itself and also its parent widget is
	// sensitive.
	//
	// This method is inherited from Widget
	IsSensitive() bool
	// IsVisible determines whether the widget and all its parents are marked as
	// visible.
	//
	// This function does not check if the widget is obscured in any way.
	//
	// See also [method@Gtk.Widget.get_visible] and
	// [method@Gtk.Widget.set_visible].
	//
	// This method is inherited from Widget
	IsVisible() bool
	// KeynavFailed emits the `::keynav-failed` signal on the widget.
	//
	// This function should be called whenever keyboard navigation within a
	// single widget hits a boundary.
	//
	// The return value of this function should be interpreted in a way similar
	// to the return value of [method@Gtk.Widget.child_focus]. When true is
	// returned, stay in the widget, the failed keyboard navigation is OK and/or
	// there is nowhere we can/should move the focus to. When false is returned,
	// the caller should continue with keyboard navigation outside the widget,
	// e.g. by calling [method@Gtk.Widget.child_focus] on the widget’s toplevel.
	//
	// The default [signal@Gtk.Widget::keynav-failed] handler returns false for
	// GTK_DIR_TAB_FORWARD and GTK_DIR_TAB_BACKWARD. For the other values of
	// DirectionType it returns true.
	//
	// Whenever the default handler returns true, it also calls
	// [method@Gtk.Widget.error_bell] to notify the user of the failed keyboard
	// navigation.
	//
	// A use case for providing an own implementation of ::keynav-failed (either
	// by connecting to it or by overriding it) would be a row of
	// [class@Gtk.Entry] widgets where the user should be able to navigate the
	// entire row with the cursor keys, as e.g. known from user interfaces that
	// require entering license keys.
	//
	// This method is inherited from Widget
	KeynavFailed(direction DirectionType) bool
	// Map causes a widget to be mapped if it isn’t already.
	//
	// This function is only for use in widget implementations.
	//
	// This method is inherited from Widget
	Map()
	// Measure measures @widget in the orientation @orientation and for the
	// given @for_size.
	//
	// As an example, if @orientation is GTK_ORIENTATION_HORIZONTAL and
	// @for_size is 300, this functions will compute the minimum and natural
	// width of @widget if it is allocated at a height of 300 pixels.
	//
	// See GtkWidget’s geometry management section
	// (class.Widget.html#height-for-width-geometry-management) for a more
	// details on implementing WidgetClass.measure().
	//
	// This method is inherited from Widget
	Measure(orientation Orientation, forSize int) (minimum int, natural int, minimumBaseline int, naturalBaseline int)
	// MnemonicActivate emits the `GtkWidget`::mnemonic-activate signal.
	//
	// This method is inherited from Widget
	MnemonicActivate(groupCycling bool) bool
	// Pick finds the descendant of @widget closest to the screen at the point
	// (@x, @y).
	//
	// The point must be given in widget coordinates, so (0, 0) is assumed to be
	// the top left of @widget's content area.
	//
	// Usually widgets will return nil if the given coordinate is not contained
	// in @widget checked via [method@Gtk.Widget.contains]. Otherwise they will
	// recursively try to find a child that does not return nil. Widgets are
	// however free to customize their picking algorithm.
	//
	// This function is used on the toplevel to determine the widget below the
	// mouse cursor for purposes of hover highlighting and delivering events.
	//
	// This method is inherited from Widget
	Pick(x float64, y float64, flags PickFlags) Widget
	// QueueAllocate flags the widget for a rerun of the
	// GtkWidgetClass::size_allocate function.
	//
	// Use this function instead of [method@Gtk.Widget.queue_resize] when the
	// @widget's size request didn't change but it wants to reposition its
	// contents.
	//
	// An example user of this function is [method@Gtk.Widget.set_halign].
	//
	// This function is only for use in widget implementations.
	//
	// This method is inherited from Widget
	QueueAllocate()
	// QueueDraw schedules this widget to be redrawn in paint phase of the
	// current or the next frame.
	//
	// This means @widget's GtkWidgetClass.snapshot() implementation will be
	// called.
	//
	// This method is inherited from Widget
	QueueDraw()
	// QueueResize flags a widget to have its size renegotiated.
	//
	// This should be called when a widget for some reason has a new size
	// request. For example, when you change the text in a [class@Gtk.Label],
	// the label queues a resize to ensure there’s enough space for the new
	// text.
	//
	// Note that you cannot call gtk_widget_queue_resize() on a widget from
	// inside its implementation of the GtkWidgetClass::size_allocate virtual
	// method. Calls to gtk_widget_queue_resize() from inside
	// GtkWidgetClass::size_allocate will be silently ignored.
	//
	// This function is only for use in widget implementations.
	//
	// This method is inherited from Widget
	QueueResize()
	// Realize creates the GDK resources associated with a widget.
	//
	// Normally realization happens implicitly; if you show a widget and all its
	// parent containers, then the widget will be realized and mapped
	// automatically.
	//
	// Realizing a widget requires all the widget’s parent widgets to be
	// realized; calling this function realizes the widget’s parents in addition
	// to @widget itself. If a widget is not yet inside a toplevel window when
	// you realize it, bad things will happen.
	//
	// This function is primarily used in widget implementations, and isn’t very
	// useful otherwise. Many times when you think you might need it, a better
	// approach is to connect to a signal that will be called after the widget
	// is realized automatically, such as [signal@Gtk.Widget::realize].
	//
	// This method is inherited from Widget
	Realize()
	// RemoveController removes @controller from @widget, so that it doesn't
	// process events anymore.
	//
	// It should not be used again.
	//
	// Widgets will remove all event controllers automatically when they are
	// destroyed, there is normally no need to call this function.
	//
	// This method is inherited from Widget
	RemoveController(controller EventController)
	// RemoveCSSClass removes a style from @widget.
	//
	// After this, the style of @widget will stop matching for @css_class.
	//
	// This method is inherited from Widget
	RemoveCSSClass(cssClass string)
	// RemoveMnemonicLabel removes a widget from the list of mnemonic labels for
	// this widget.
	//
	// See [method@Gtk.Widget.list_mnemonic_labels]. The widget must have
	// previously been added to the list with
	// [method@Gtk.Widget.add_mnemonic_label].
	//
	// This method is inherited from Widget
	RemoveMnemonicLabel(label Widget)
	// RemoveTickCallback removes a tick callback previously registered with
	// gtk_widget_add_tick_callback().
	//
	// This method is inherited from Widget
	RemoveTickCallback(id uint)
	// SetCanFocus specifies whether the input focus can enter the widget or any
	// of its children.
	//
	// Applications should set @can_focus to false to mark a widget as for
	// pointer/touch use only.
	//
	// Note that having @can_focus be true is only one of the necessary
	// conditions for being focusable. A widget must also be sensitive and
	// focusable and not have an ancestor that is marked as not can-focus in
	// order to receive input focus.
	//
	// See [method@Gtk.Widget.grab_focus] for actually setting the input focus
	// on a widget.
	//
	// This method is inherited from Widget
	SetCanFocus(canFocus bool)
	// SetCanTarget sets whether @widget can be the target of pointer events.
	//
	// This method is inherited from Widget
	SetCanTarget(canTarget bool)
	// SetChildVisible sets whether @widget should be mapped along with its
	// parent.
	//
	// The child visibility can be set for widget before it is added to a
	// container with [method@Gtk.Widget.set_parent], to avoid mapping children
	// unnecessary before immediately unmapping them. However it will be reset
	// to its default state of true when the widget is removed from a container.
	//
	// Note that changing the child visibility of a widget does not queue a
	// resize on the widget. Most of the time, the size of a widget is computed
	// from all visible children, whether or not they are mapped. If this is not
	// the case, the container can queue a resize itself.
	//
	// This function is only useful for container implementations and should
	// never be called by an application.
	//
	// This method is inherited from Widget
	SetChildVisible(childVisible bool)
	// SetCSSClasses: will clear all style classes applied to @widget and
	// replace them with @classes.
	//
	// This method is inherited from Widget
	SetCSSClasses(classes []string)
	// SetCursor sets the cursor to be shown when pointer devices point towards
	// @widget.
	//
	// If the @cursor is NULL, @widget will use the cursor inherited from the
	// parent widget.
	//
	// This method is inherited from Widget
	SetCursor(cursor gdk.Cursor)
	// SetCursorFromName sets a named cursor to be shown when pointer devices
	// point towards @widget.
	//
	// This is a utility function that creates a cursor via
	// [ctor@Gdk.Cursor.new_from_name] and then sets it on @widget with
	// [method@Gtk.Widget.set_cursor]. See those functions for details.
	//
	// On top of that, this function allows @name to be nil, which will do the
	// same as calling [method@Gtk.Widget.set_cursor] with a nil cursor.
	//
	// This method is inherited from Widget
	SetCursorFromName(name string)
	// SetDirection sets the reading direction on a particular widget.
	//
	// This direction controls the primary direction for widgets containing
	// text, and also the direction in which the children of a container are
	// packed. The ability to set the direction is present in order so that
	// correct localization into languages with right-to-left reading directions
	// can be done. Generally, applications will let the default reading
	// direction present, except for containers where the containers are
	// arranged in an order that is explicitly visual rather than logical (such
	// as buttons for text justification).
	//
	// If the direction is set to GTK_TEXT_DIR_NONE, then the value set by
	// [func@Gtk.Widget.set_default_direction] will be used.
	//
	// This method is inherited from Widget
	SetDirection(dir TextDirection)
	// SetFocusChild: set @child as the current focus child of @widget.
	//
	// The previous focus child will be unset.
	//
	// This function is only suitable for widget implementations. If you want a
	// certain widget to get the input focus, call
	// [method@Gtk.Widget.grab_focus] on it.
	//
	// This method is inherited from Widget
	SetFocusChild(child Widget)
	// SetFocusOnClick sets whether the widget should grab focus when it is
	// clicked with the mouse.
	//
	// Making mouse clicks not grab focus is useful in places like toolbars
	// where you don’t want the keyboard focus removed from the main area of the
	// application.
	//
	// This method is inherited from Widget
	SetFocusOnClick(focusOnClick bool)
	// SetFocusable specifies whether @widget can own the input focus.
	//
	// Widget implementations should set @focusable to true in their init()
	// function if they want to receive keyboard input.
	//
	// Note that having @focusable be true is only one of the necessary
	// conditions for being focusable. A widget must also be sensitive and
	// can-focus and not have an ancestor that is marked as not can-focus in
	// order to receive input focus.
	//
	// See [method@Gtk.Widget.grab_focus] for actually setting the input focus
	// on a widget.
	//
	// This method is inherited from Widget
	SetFocusable(focusable bool)
	// SetFontMap sets the font map to use for Pango rendering.
	//
	// The font map is the object that is used to look up fonts. Setting a
	// custom font map can be useful in special situations, e.g. when you need
	// to add application-specific fonts to the set of available fonts.
	//
	// When not set, the widget will inherit the font map from its parent.
	//
	// This method is inherited from Widget
	SetFontMap(fontMap pango.FontMap)
	// SetFontOptions sets the `cairo_font_options_t` used for Pango rendering
	// in this widget.
	//
	// When not set, the default font options for the `GdkDisplay` will be used.
	//
	// This method is inherited from Widget
	SetFontOptions(options *cairo.FontOptions)
	// SetHAlign sets the horizontal alignment of @widget.
	//
	// This method is inherited from Widget
	SetHAlign(align Align)
	// SetHasTooltip sets the `has-tooltip` property on @widget to @has_tooltip.
	//
	// This method is inherited from Widget
	SetHasTooltip(hasTooltip bool)
	// SetHExpand sets whether the widget would like any available extra
	// horizontal space.
	//
	// When a user resizes a `GtkWindow`, widgets with expand=TRUE generally
	// receive the extra space. For example, a list or scrollable area or
	// document in your window would often be set to expand.
	//
	// Call this function to set the expand flag if you would like your widget
	// to become larger horizontally when the window has extra room.
	//
	// By default, widgets automatically expand if any of their children want to
	// expand. (To see if a widget will automatically expand given its current
	// children and state, call [method@Gtk.Widget.compute_expand]. A container
	// can decide how the expandability of children affects the expansion of the
	// container by overriding the compute_expand virtual method on
	// `GtkWidget`.).
	//
	// Setting hexpand explicitly with this function will override the automatic
	// expand behavior.
	//
	// This function forces the widget to expand or not to expand, regardless of
	// children. The override occurs because [method@Gtk.Widget.set_hexpand]
	// sets the hexpand-set property (see [method@Gtk.Widget.set_hexpand_set])
	// which causes the widget’s hexpand value to be used, rather than looking
	// at children and widget state.
	//
	// This method is inherited from Widget
	SetHExpand(expand bool)
	// SetHExpandSet sets whether the hexpand flag will be used.
	//
	// The [property@Gtk.Widget:hexpand-set] property will be set automatically
	// when you call [method@Gtk.Widget.set_hexpand] to set hexpand, so the most
	// likely reason to use this function would be to unset an explicit expand
	// flag.
	//
	// If hexpand is set, then it overrides any computed expand value based on
	// child widgets. If hexpand is not set, then the expand value depends on
	// whether any children of the widget would like to expand.
	//
	// There are few reasons to use this function, but it’s here for
	// completeness and consistency.
	//
	// This method is inherited from Widget
	SetHExpandSet(set bool)
	// SetLayoutManager sets the layout manager delegate instance that provides
	// an implementation for measuring and allocating the children of @widget.
	//
	// This method is inherited from Widget
	SetLayoutManager(layoutManager LayoutManager)
	// SetMarginBottom sets the bottom margin of @widget.
	//
	// This method is inherited from Widget
	SetMarginBottom(margin int)
	// SetMarginEnd sets the end margin of @widget.
	//
	// This method is inherited from Widget
	SetMarginEnd(margin int)
	// SetMarginStart sets the start margin of @widget.
	//
	// This method is inherited from Widget
	SetMarginStart(margin int)
	// SetMarginTop sets the top margin of @widget.
	//
	// This method is inherited from Widget
	SetMarginTop(margin int)
	// SetName sets a widgets name.
	//
	// Setting a name allows you to refer to the widget from a CSS file. You can
	// apply a style to widgets with a particular name in the CSS file. See the
	// documentation for the CSS syntax (on the same page as the docs for
	// [class@Gtk.StyleContext].
	//
	// Note that the CSS syntax has certain special characters to delimit and
	// represent elements in a selector (period, #, >, *...), so using these
	// will make your widget impossible to match by name. Any combination of
	// alphanumeric symbols, dashes and underscores will suffice.
	//
	// This method is inherited from Widget
	SetName(name string)
	// SetOpacity: request the @widget to be rendered partially transparent.
	//
	// An opacity of 0 is fully transparent and an opacity of 1 is fully opaque.
	//
	// Opacity works on both toplevel widgets and child widgets, although there
	// are some limitations: For toplevel widgets, applying opacity depends on
	// the capabilities of the windowing system. On X11, this has any effect
	// only on X displays with a compositing manager, see
	// gdk_display_is_composited(). On Windows and Wayland it should always
	// work, although setting a window’s opacity after the window has been shown
	// may cause some flicker.
	//
	// Note that the opacity is inherited through inclusion — if you set a
	// toplevel to be partially translucent, all of its content will appear
	// translucent, since it is ultimatively rendered on that toplevel. The
	// opacity value itself is not inherited by child widgets (since that would
	// make widgets deeper in the hierarchy progressively more translucent). As
	// a consequence, [class@Gtk.Popover]s and other [class@Gtk.Native] widgets
	// with their own surface will use their own opacity value, and thus by
	// default appear non-translucent, even if they are attached to a toplevel
	// that is translucent.
	//
	// This method is inherited from Widget
	SetOpacity(opacity float64)
	// SetOverflow sets how @widget treats content that is drawn outside the
	// widget's content area.
	//
	// See the definition of [enum@Gtk.Overflow] for details.
	//
	// This setting is provided for widget implementations and should not be
	// used by application code.
	//
	// The default value is GTK_OVERFLOW_VISIBLE.
	//
	// This method is inherited from Widget
	SetOverflow(overflow Overflow)
	// SetParent sets @parent as the parent widget of @widget.
	//
	// This takes care of details such as updating the state and style of the
	// child to reflect its new location and resizing the parent. The opposite
	// function is [method@Gtk.Widget.unparent].
	//
	// This function is useful only when implementing subclasses of `GtkWidget`.
	//
	// This method is inherited from Widget
	SetParent(parent Widget)
	// SetReceivesDefault specifies whether @widget will be treated as the
	// default widget within its toplevel when it has the focus, even if another
	// widget is the default.
	//
	// This method is inherited from Widget
	SetReceivesDefault(receivesDefault bool)
	// SetSensitive sets the sensitivity of a widget.
	//
	// A widget is sensitive if the user can interact with it. Insensitive
	// widgets are “grayed out” and the user can’t interact with them.
	// Insensitive widgets are known as “inactive”, “disabled”, or “ghosted” in
	// some other toolkits.
	//
	// This method is inherited from Widget
	SetSensitive(sensitive bool)
	// SetSizeRequest sets the minimum size of a widget.
	//
	// That is, the widget’s size request will be at least @width by @height.
	// You can use this function to force a widget to be larger than it normally
	// would be.
	//
	// In most cases, [method@Gtk.Window.set_default_size] is a better choice
	// for toplevel windows than this function; setting the default size will
	// still allow users to shrink the window. Setting the size request will
	// force them to leave the window at least as large as the size request.
	//
	// Note the inherent danger of setting any fixed size - themes, translations
	// into other languages, different fonts, and user action can all change the
	// appropriate size for a given widget. So, it's basically impossible to
	// hardcode a size that will always be correct.
	//
	// The size request of a widget is the smallest size a widget can accept
	// while still functioning well and drawing itself correctly. However in
	// some strange cases a widget may be allocated less than its requested
	// size, and in many cases a widget may be allocated more space than it
	// requested.
	//
	// If the size request in a given direction is -1 (unset), then the
	// “natural” size request of the widget will be used instead.
	//
	// The size request set here does not include any margin from the properties
	// [property@Gtk.Widget:margin-start], [property@Gtk.Widget:margin-end],
	// [property@Gtk.Widget:margin-top], and
	// [property@Gtk.Widget:margin-bottom], but it does include pretty much all
	// other padding or border properties set by any subclass of `GtkWidget`.
	//
	// This method is inherited from Widget
	SetSizeRequest(width int, height int)
	// SetStateFlags turns on flag values in the current widget state.
	//
	// Typical widget states are insensitive, prelighted, etc.
	//
	// This function accepts the values GTK_STATE_FLAG_DIR_LTR and
	// GTK_STATE_FLAG_DIR_RTL but ignores them. If you want to set the widget's
	// direction, use [method@Gtk.Widget.set_direction].
	//
	// This function is for use in widget implementations.
	//
	// This method is inherited from Widget
	SetStateFlags(flags StateFlags, clear bool)
	// SetTooltipMarkup sets @markup as the contents of the tooltip, which is
	// marked up with Pango markup.
	//
	// This function will take care of setting the
	// [property@Gtk.Widget:has-tooltip] as a side effect, and of the default
	// handler for the [signal@Gtk.Widget::query-tooltip] signal.
	//
	// See also [method@Gtk.Tooltip.set_markup].
	//
	// This method is inherited from Widget
	SetTooltipMarkup(markup string)
	// SetTooltipText sets @text as the contents of the tooltip.
	//
	// If @text contains any markup, it will be escaped.
	//
	// This function will take care of setting [property@Gtk.Widget:has-tooltip]
	// as a side effect, and of the default handler for the
	// [signal@Gtk.Widget::query-tooltip] signal.
	//
	// See also [method@Gtk.Tooltip.set_text].
	//
	// This method is inherited from Widget
	SetTooltipText(text string)
	// SetVAlign sets the vertical alignment of @widget.
	//
	// This method is inherited from Widget
	SetVAlign(align Align)
	// SetVExpand sets whether the widget would like any available extra
	// vertical space.
	//
	// See [method@Gtk.Widget.set_hexpand] for more detail.
	//
	// This method is inherited from Widget
	SetVExpand(expand bool)
	// SetVExpandSet sets whether the vexpand flag will be used.
	//
	// See [method@Gtk.Widget.set_hexpand_set] for more detail.
	//
	// This method is inherited from Widget
	SetVExpandSet(set bool)
	// SetVisible sets the visibility state of @widget.
	//
	// Note that setting this to true doesn’t mean the widget is actually
	// viewable, see [method@Gtk.Widget.get_visible].
	//
	// This function simply calls [method@Gtk.Widget.show] or
	// [method@Gtk.Widget.hide] but is nicer to use when the visibility of the
	// widget depends on some condition.
	//
	// This method is inherited from Widget
	SetVisible(visible bool)
	// ShouldLayout returns whether @widget should contribute to the measuring
	// and allocation of its parent.
	//
	// This is false for invisible children, but also for children that have
	// their own surface.
	//
	// This method is inherited from Widget
	ShouldLayout() bool
	// Show flags a widget to be displayed.
	//
	// Any widget that isn’t shown will not appear on the screen.
	//
	// Remember that you have to show the containers containing a widget, in
	// addition to the widget itself, before it will appear onscreen.
	//
	// When a toplevel container is shown, it is immediately realized and
	// mapped; other shown widgets are realized and mapped when their toplevel
	// container is realized and mapped.
	//
	// This method is inherited from Widget
	Show()
	// SnapshotChild: snapshot the a child of @widget.
	//
	// When a widget receives a call to the snapshot function, it must send
	// synthetic `GtkWidget`Class.snapshot() calls to all children. This
	// function provides a convenient way of doing this. A widget, when it
	// receives a call to its `GtkWidget`Class.snapshot() function, calls
	// gtk_widget_snapshot_child() once for each child, passing in the @snapshot
	// the widget received.
	//
	// gtk_widget_snapshot_child() takes care of translating the origin of
	// @snapshot, and deciding whether the child needs to be snapshot.
	//
	// This function does nothing for children that implement `GtkNative`.
	//
	// This method is inherited from Widget
	SnapshotChild(child Widget, snapshot Snapshot)
	// TranslateCoordinates: translate coordinates relative to @src_widget’s
	// allocation to coordinates relative to @dest_widget’s allocations.
	//
	// In order to perform this operation, both widget must share a common
	// ancestor.
	//
	// This method is inherited from Widget
	TranslateCoordinates(destWidget Widget, srcX float64, srcY float64) (destX float64, destY float64, ok bool)
	// TriggerTooltipQuery triggers a tooltip query on the display where the
	// toplevel of @widget is located.
	//
	// This method is inherited from Widget
	TriggerTooltipQuery()
	// Unmap causes a widget to be unmapped if it’s currently mapped.
	//
	// This function is only for use in widget implementations.
	//
	// This method is inherited from Widget
	Unmap()
	// Unparent: dissociate @widget from its parent.
	//
	// This function is only for use in widget implementations, typically in
	// dispose.
	//
	// This method is inherited from Widget
	Unparent()
	// Unrealize causes a widget to be unrealized (frees all GDK resources
	// associated with the widget).
	//
	// This function is only useful in widget implementations.
	//
	// This method is inherited from Widget
	Unrealize()
	// UnsetStateFlags turns off flag values for the current widget state.
	//
	// See [method@Gtk.Widget.set_state_flags].
	//
	// This function is for use in widget implementations.
	//
	// This method is inherited from Widget
	UnsetStateFlags(flags StateFlags)
	// GetAccessibleRole retrieves the `GtkAccessibleRole` for the given
	// `GtkAccessible`.
	//
	// This method is inherited from Accessible
	GetAccessibleRole() AccessibleRole
	// ResetProperty resets the accessible @property to its default value.
	//
	// This method is inherited from Accessible
	ResetProperty(property AccessibleProperty)
	// ResetRelation resets the accessible @relation to its default value.
	//
	// This method is inherited from Accessible
	ResetRelation(relation AccessibleRelation)
	// ResetState resets the accessible @state to its default value.
	//
	// This method is inherited from Accessible
	ResetState(state AccessibleState)
	// UpdatePropertyValue updates an array of accessible properties.
	//
	// This function should be called by `GtkWidget` types whenever an
	// accessible property change must be communicated to assistive
	// technologies.
	//
	// This function is meant to be used by language bindings.
	//
	// This method is inherited from Accessible
	UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value)
	// UpdateRelationValue updates an array of accessible relations.
	//
	// This function should be called by `GtkWidget` types whenever an
	// accessible relation change must be communicated to assistive
	// technologies.
	//
	// This function is meant to be used by language bindings.
	//
	// This method is inherited from Accessible
	UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value)
	// UpdateStateValue updates an array of accessible states.
	//
	// This function should be called by `GtkWidget` types whenever an
	// accessible state change must be communicated to assistive technologies.
	//
	// This function is meant to be used by language bindings.
	//
	// This method is inherited from Accessible
	UpdateStateValue(states []AccessibleState, values []externglib.Value)
	// GetBuildableID gets the ID of the @buildable object.
	//
	// `GtkBuilder` sets the name based on the ID attribute of the <object> tag
	// used to construct the @buildable.
	//
	// This method is inherited from Buildable
	GetBuildableID() string

	// Close requests that the window is closed.
	//
	// This is similar to what happens when a window manager close button is
	// clicked.
	//
	// This function can be used with close buttons in custom titlebars.
	Close()
	// Destroy: drop the internal reference GTK holds on toplevel windows.
	Destroy()
	// Fullscreen asks to place @window in the fullscreen state.
	//
	// Note that you shouldn’t assume the window is definitely fullscreen
	// afterward, because other entities (e.g. the user or window manager
	// unfullscreen it again, and not all window managers honor requests to
	// fullscreen windows.
	//
	// You can track the result of this operation via the
	// [property@Gdk.Toplevel:state] property, or by listening to notifications
	// of the [property@Gtk.Window:fullscreened] property.
	Fullscreen()
	// FullscreenOnMonitor asks to place @window in the fullscreen state on the
	// given @monitor.
	//
	// Note that you shouldn't assume the window is definitely fullscreen
	// afterward, or that the windowing system allows fullscreen windows on any
	// given monitor.
	//
	// You can track the result of this operation via the
	// [property@Gdk.Toplevel:state] property, or by listening to notifications
	// of the [property@Gtk.Window:fullscreened] property.
	FullscreenOnMonitor(monitor gdk.Monitor)
	// Application gets the `GtkApplication` associated with the window.
	Application() Application
	// Child gets the child widget of @window.
	Child() Widget
	// Decorated returns whether the window has been set to have decorations.
	Decorated() bool
	// DefaultSize gets the default size of the window.
	//
	// A value of 0 for the width or height indicates that a default size has
	// not been explicitly set for that dimension, so the “natural” size of the
	// window will be used.
	DefaultSize() (width int, height int)
	// DefaultWidget returns the default widget for @window.
	DefaultWidget() Widget
	// Deletable returns whether the window has been set to have a close button.
	Deletable() bool
	// DestroyWithParent returns whether the window will be destroyed with its
	// transient parent.
	DestroyWithParent() bool
	// Focus retrieves the current focused widget within the window.
	//
	// Note that this is the widget that would have the focus if the toplevel
	// window focused; if the toplevel window is not focused then
	// `gtk_widget_has_focus (widget)` will not be true for the widget.
	Focus() Widget
	// FocusVisible gets whether “focus rectangles” are supposed to be visible.
	FocusVisible() bool
	// Group returns the group for @window.
	//
	// If the window has no group, then the default group is returned.
	Group() WindowGroup
	// HandleMenubarAccel returns whether this window reacts to F10 key presses
	// by activating a menubar it contains.
	HandleMenubarAccel() bool
	// HideOnClose returns whether the window will be hidden when the close
	// button is clicked.
	HideOnClose() bool
	// IconName returns the name of the themed icon for the window.
	IconName() string
	// MnemonicsVisible gets whether mnemonics are supposed to be visible.
	MnemonicsVisible() bool
	// Modal returns whether the window is modal.
	Modal() bool
	// Resizable gets the value set by gtk_window_set_resizable().
	Resizable() bool
	// Title retrieves the title of the window.
	Title() string
	// Titlebar returns the custom titlebar that has been set with
	// gtk_window_set_titlebar().
	Titlebar() Widget
	// TransientFor fetches the transient parent for this window.
	TransientFor() Window
	// HasGroup returns whether @window has an explicit window group.
	HasGroup() bool
	// IsActive returns whether the window is part of the current active
	// toplevel.
	//
	// The active toplevel is the window receiving keystrokes.
	//
	// The return value is true if the window is active toplevel itself. You
	// might use this function if you wanted to draw a widget differently in an
	// active window from a widget in an inactive window.
	IsActive() bool
	// IsFullscreen retrieves the current fullscreen state of @window.
	//
	// Note that since fullscreening is ultimately handled by the window manager
	// and happens asynchronously to an application request, you shouldn’t
	// assume the return value of this function changing immediately (or at
	// all), as an effect of calling [method@Gtk.Window.fullscreen] or
	// [method@Gtk.Window.unfullscreen].
	//
	// If the window isn't yet mapped, the value returned will whether the
	// initial requested state is fullscreen.
	IsFullscreen() bool
	// IsMaximized retrieves the current maximized state of @window.
	//
	// Note that since maximization is ultimately handled by the window manager
	// and happens asynchronously to an application request, you shouldn’t
	// assume the return value of this function changing immediately (or at
	// all), as an effect of calling [method@Gtk.Window.maximize] or
	// [method@Gtk.Window.unmaximize].
	//
	// If the window isn't yet mapped, the value returned will whether the
	// initial requested state is maximized.
	IsMaximized() bool
	// Maximize asks to maximize @window, so that it fills the screen.
	//
	// Note that you shouldn’t assume the window is definitely maximized
	// afterward, because other entities (e.g. the user or window manager could
	// unmaximize it again, and not all window managers support maximization.
	//
	// It’s permitted to call this function before showing a window, in which
	// case the window will be maximized when it appears onscreen initially.
	//
	// You can track the result of this operation via the
	// [property@Gdk.Toplevel:state] property, or by listening to notifications
	// on the [property@Gtk.Window:maximized] property.
	Maximize()
	// Minimize asks to minimize the specified @window.
	//
	// Note that you shouldn’t assume the window is definitely minimized
	// afterward, because the windowing system might not support this
	// functionality; other entities (e.g. the user or the window manager could
	// unminimize it again, or there may not be a window manager in which case
	// minimization isn’t possible, etc.
	//
	// It’s permitted to call this function before showing a window, in which
	// case the window will be minimized before it ever appears onscreen.
	//
	// You can track result of this operation via the
	// [property@Gdk.Toplevel:state] property.
	Minimize()
	// Present presents a window to the user.
	//
	// This function should not be used as when it is called, it is too late to
	// gather a valid timestamp to allow focus stealing prevention to work
	// correctly.
	Present()
	// PresentWithTime presents a window to the user.
	//
	// This may mean raising the window in the stacking order, unminimizing it,
	// moving it to the current desktop, and/or giving it the keyboard focus,
	// possibly dependent on the user’s platform, window manager, and
	// preferences.
	//
	// If @window is hidden, this function calls [method@Gtk.Widget.show] as
	// well.
	//
	// This function should be used when the user tries to open a window that’s
	// already open. Say for example the preferences dialog is currently open,
	// and the user chooses Preferences from the menu a second time; use
	// [method@Gtk.Window.present] to move the already-open dialog where the
	// user can see it.
	//
	// Presents a window to the user in response to a user interaction. The
	// timestamp should be gathered when the window was requested to be shown
	// (when clicking a link for example), rather than once the window is ready
	// to be shown.
	PresentWithTime(timestamp uint32)
	// SetApplication sets or unsets the `GtkApplication` associated with the
	// window.
	//
	// The application will be kept alive for at least as long as it has any
	// windows associated with it (see g_application_hold() for a way to keep it
	// alive without windows).
	//
	// Normally, the connection between the application and the window will
	// remain until the window is destroyed, but you can explicitly remove it by
	// setting the @application to nil.
	//
	// This is equivalent to calling [method@Gtk.Application.remove_window]
	// and/or [method@Gtk.Application.add_window] on the old/new applications as
	// relevant.
	SetApplication(application Application)
	// SetChild sets the child widget of @window.
	SetChild(child Widget)
	// SetDecorated sets whether the window should be decorated.
	//
	// By default, windows are decorated with a title bar, resize controls, etc.
	// Some window managers allow GTK to disable these decorations, creating a
	// borderless window. If you set the decorated property to false using this
	// function, GTK will do its best to convince the window manager not to
	// decorate the window. Depending on the system, this function may not have
	// any effect when called on a window that is already visible, so you should
	// call it before calling [method@Gtk.Widget.show].
	//
	// On Windows, this function always works, since there’s no window manager
	// policy involved.
	SetDecorated(setting bool)
	// SetDefaultSize sets the default size of a window.
	//
	// If the window’s “natural” size (its size request) is larger than the
	// default, the default will be ignored.
	//
	// Unlike [method@Gtk.Widget.set_size_request], which sets a size request
	// for a widget and thus would keep users from shrinking the window, this
	// function only sets the initial size, just as if the user had resized the
	// window themselves. Users can still shrink the window again as they
	// normally would. Setting a default size of -1 means to use the “natural”
	// default size (the size request of the window).
	//
	// The default size of a window only affects the first time a window is
	// shown; if a window is hidden and re-shown, it will remember the size it
	// had prior to hiding, rather than using the default size.
	//
	// Windows can’t actually be 0x0 in size, they must be at least 1x1, but
	// passing 0 for @width and @height is OK, resulting in a 1x1 default size.
	//
	// If you use this function to reestablish a previously saved window size,
	// note that the appropriate size to save is the one returned by
	// [method@Gtk.Window.get_default_size]. Using the window allocation
	// directly will not work in all circumstances and can lead to growing or
	// shrinking windows.
	SetDefaultSize(width int, height int)
	// SetDefaultWidget sets the default widget.
	//
	// The default widget is the widget that is activated when the user presses
	// Enter in a dialog (for example).
	SetDefaultWidget(defaultWidget Widget)
	// SetDeletable sets whether the window should be deletable.
	//
	// By default, windows have a close button in the window frame. Some window
	// managers allow GTK to disable this button. If you set the deletable
	// property to false using this function, GTK will do its best to convince
	// the window manager not to show a close button. Depending on the system,
	// this function may not have any effect when called on a window that is
	// already visible, so you should call it before calling
	// [method@Gtk.Widget.show].
	//
	// On Windows, this function always works, since there’s no window manager
	// policy involved.
	SetDeletable(setting bool)
	// SetDestroyWithParent: if @setting is true, then destroying the transient
	// parent of @window will also destroy @window itself.
	//
	// This is useful for dialogs that shouldn’t persist beyond the lifetime of
	// the main window they are associated with, for example.
	SetDestroyWithParent(setting bool)
	// SetDisplay sets the `GdkDisplay` where the @window is displayed.
	//
	// If the window is already mapped, it will be unmapped, and then remapped
	// on the new display.
	SetDisplay(display gdk.Display)
	// SetFocus sets the focus widget.
	//
	// If @focus is not the current focus widget, and is focusable, sets it as
	// the focus widget for the window. If @focus is nil, unsets the focus
	// widget for this window. To set the focus to a particular widget in the
	// toplevel, it is usually more convenient to use
	// [method@Gtk.Widget.grab_focus] instead of this function.
	SetFocus(focus Widget)
	// SetFocusVisible sets whether “focus rectangles” are supposed to be
	// visible.
	SetFocusVisible(setting bool)
	// SetHandleMenubarAccel sets whether this window should react to F10 key
	// presses by activating a menubar it contains.
	SetHandleMenubarAccel(handleMenubarAccel bool)
	// SetHideOnClose: if @setting is true, then clicking the close button on
	// the window will not destroy it, but only hide it.
	SetHideOnClose(setting bool)
	// SetIconName sets the icon for the window from a named themed icon.
	//
	// See the docs for [class@Gtk.IconTheme] for more details. On some
	// platforms, the window icon is not used at all.
	//
	// Note that this has nothing to do with the WM_ICON_NAME property which is
	// mentioned in the ICCCM.
	SetIconName(name string)
	// SetMnemonicsVisible sets whether mnemonics are supposed to be visible.
	SetMnemonicsVisible(setting bool)
	// SetModal sets a window modal or non-modal.
	//
	// Modal windows prevent interaction with other windows in the same
	// application. To keep modal dialogs on top of main application windows,
	// use [method@Gtk.Window.set_transient_for] to make the dialog transient
	// for the parent; most window managers will then disallow lowering the
	// dialog below the parent.
	SetModal(modal bool)
	// SetResizable sets whether the user can resize a window.
	//
	// Windows are user resizable by default.
	SetResizable(resizable bool)
	// SetStartupID sets the startup notification ID.
	//
	// Startup notification identifiers are used by desktop environment to track
	// application startup, to provide user feedback and other features. This
	// function changes the corresponding property on the underlying
	// `GdkSurface`.
	//
	// Normally, startup identifier is managed automatically and you should only
	// use this function in special cases like transferring focus from other
	// processes. You should use this function before calling
	// [method@Gtk.Window.present] or any equivalent function generating a
	// window map event.
	//
	// This function is only useful on X11, not with other GTK targets.
	SetStartupID(startupId string)
	// SetTitle sets the title of the `GtkWindow`.
	//
	// The title of a window will be displayed in its title bar; on the X Window
	// System, the title bar is rendered by the window manager so exactly how
	// the title appears to users may vary according to a user’s exact
	// configuration. The title should help a user distinguish this window from
	// other windows they may have open. A good title might include the
	// application name and current document filename, for example.
	//
	// Passing nil does the same as setting the title to an empty string.
	SetTitle(title string)
	// SetTitlebar sets a custom titlebar for @window.
	//
	// A typical widget used here is [class@Gtk.HeaderBar], as it provides
	// various features expected of a titlebar while allowing the addition of
	// child widgets to it.
	//
	// If you set a custom titlebar, GTK will do its best to convince the window
	// manager not to put its own titlebar on the window. Depending on the
	// system, this function may not work for a window that is already visible,
	// so you set the titlebar before calling [method@Gtk.Widget.show].
	SetTitlebar(titlebar Widget)
	// SetTransientFor: dialog windows should be set transient for the main
	// application window they were spawned from. This allows window managers to
	// e.g. keep the dialog on top of the main window, or center the dialog over
	// the main window. [ctor@Gtk.Dialog.new_with_buttons] and other convenience
	// functions in GTK will sometimes call gtk_window_set_transient_for() on
	// your behalf.
	//
	// Passing nil for @parent unsets the current transient window.
	//
	// On Windows, this function puts the child window on top of the parent,
	// much as the window manager would have done on X.
	SetTransientFor(parent Window)
	// Unfullscreen asks to remove the fullscreen state for @window, and return
	// to its previous state.
	//
	// Note that you shouldn’t assume the window is definitely not fullscreen
	// afterward, because other entities (e.g. the user or window manager could
	// fullscreen it again, and not all window managers honor requests to
	// unfullscreen windows; normally the window will end up restored to its
	// normal state. Just don’t write code that crashes if not.
	//
	// You can track the result of this operation via the
	// [property@Gdk.Toplevel:state] property, or by listening to notifications
	// of the [property@Gtk.Window:fullscreened] property.
	Unfullscreen()
	// Unmaximize asks to unmaximize @window.
	//
	// Note that you shouldn’t assume the window is definitely unmaximized
	// afterward, because other entities (e.g. the user or window manager
	// maximize it again, and not all window managers honor requests to
	// unmaximize.
	//
	// You can track the result of this operation via the
	// [property@Gdk.Toplevel:state] property, or by listening to notifications
	// on the [property@Gtk.Window:maximized] property.
	Unmaximize()
	// Unminimize asks to unminimize the specified @window.
	//
	// Note that you shouldn’t assume the window is definitely unminimized
	// afterward, because the windowing system might not support this
	// functionality; other entities (e.g. the user or the window manager could
	// minimize it again, or there may not be a window manager in which case
	// minimization isn’t possible, etc.
	//
	// You can track result of this operation via the
	// [property@Gdk.Toplevel:state] property.
	Unminimize()
}

// window implements the Window interface.
type window struct {
	*externglib.Object
}

var _ Window = (*window)(nil)

// WrapWindow wraps a GObject to a type that implements
// interface Window. It is primarily used internally.
func WrapWindow(obj *externglib.Object) Window {
	return window{obj}
}

func marshalWindow(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapWindow(obj), nil
}

// NewWindow creates a new `GtkWindow`.
//
// To get an undecorated window (no window borders), use
// [method@Gtk.Window.set_decorated].
//
// All top-level windows created by gtk_window_new() are stored in an internal
// top-level window list. This list can be obtained from
// [func@Gtk.Window.list_toplevels]. Due to GTK keeping a reference to the
// window internally, gtk_window_new() does not return a reference to the
// caller.
//
// To delete a `GtkWindow`, call [method@Gtk.Window.destroy].
func NewWindow() Window {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_window_new()

	var _window Window // out

	_window = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Window)

	return _window
}

func (w window) AsWidget() Widget {
	return WrapWidget(gextras.InternObject(w))
}

func (w window) AsAccessible() Accessible {
	return WrapAccessible(gextras.InternObject(w))
}

func (w window) AsBuildable() Buildable {
	return WrapBuildable(gextras.InternObject(w))
}

func (w window) AsConstraintTarget() ConstraintTarget {
	return WrapConstraintTarget(gextras.InternObject(w))
}

func (w window) AsNative() Native {
	return WrapNative(gextras.InternObject(w))
}

func (w window) AsRoot() Root {
	return WrapRoot(gextras.InternObject(w))
}

func (w window) AsShortcutManager() ShortcutManager {
	return WrapShortcutManager(gextras.InternObject(w))
}

func (w window) ActionSetEnabled(actionName string, enabled bool) {
	WrapWidget(gextras.InternObject(w)).ActionSetEnabled(actionName, enabled)
}

func (w window) Activate() bool {
	return WrapWidget(gextras.InternObject(w)).Activate()
}

func (w window) ActivateActionVariant(name string, args *glib.Variant) bool {
	return WrapWidget(gextras.InternObject(w)).ActivateActionVariant(name, args)
}

func (w window) ActivateDefault() {
	WrapWidget(gextras.InternObject(w)).ActivateDefault()
}

func (w window) AddController(controller EventController) {
	WrapWidget(gextras.InternObject(w)).AddController(controller)
}

func (w window) AddCSSClass(cssClass string) {
	WrapWidget(gextras.InternObject(w)).AddCSSClass(cssClass)
}

func (w window) AddMnemonicLabel(label Widget) {
	WrapWidget(gextras.InternObject(w)).AddMnemonicLabel(label)
}

func (w window) Allocate(width int, height int, baseline int, transform *gsk.Transform) {
	WrapWidget(gextras.InternObject(w)).Allocate(width, height, baseline, transform)
}

func (w window) ChildFocus(direction DirectionType) bool {
	return WrapWidget(gextras.InternObject(w)).ChildFocus(direction)
}

func (w window) ComputeBounds(target Widget) (graphene.Rect, bool) {
	return WrapWidget(gextras.InternObject(w)).ComputeBounds(target)
}

func (w window) ComputeExpand(orientation Orientation) bool {
	return WrapWidget(gextras.InternObject(w)).ComputeExpand(orientation)
}

func (w window) ComputePoint(target Widget, point *graphene.Point) (graphene.Point, bool) {
	return WrapWidget(gextras.InternObject(w)).ComputePoint(target, point)
}

func (w window) ComputeTransform(target Widget) (graphene.Matrix, bool) {
	return WrapWidget(gextras.InternObject(w)).ComputeTransform(target)
}

func (w window) Contains(x float64, y float64) bool {
	return WrapWidget(gextras.InternObject(w)).Contains(x, y)
}

func (w window) CreatePangoContext() pango.Context {
	return WrapWidget(gextras.InternObject(w)).CreatePangoContext()
}

func (w window) CreatePangoLayout(text string) pango.Layout {
	return WrapWidget(gextras.InternObject(w)).CreatePangoLayout(text)
}

func (w window) DragCheckThreshold(startX int, startY int, currentX int, currentY int) bool {
	return WrapWidget(gextras.InternObject(w)).DragCheckThreshold(startX, startY, currentX, currentY)
}

func (w window) ErrorBell() {
	WrapWidget(gextras.InternObject(w)).ErrorBell()
}

func (w window) GetAllocatedBaseline() int {
	return WrapWidget(gextras.InternObject(w)).GetAllocatedBaseline()
}

func (w window) GetAllocatedHeight() int {
	return WrapWidget(gextras.InternObject(w)).GetAllocatedHeight()
}

func (w window) GetAllocatedWidth() int {
	return WrapWidget(gextras.InternObject(w)).GetAllocatedWidth()
}

func (w window) GetAncestor(widgetType externglib.Type) Widget {
	return WrapWidget(gextras.InternObject(w)).GetAncestor(widgetType)
}

func (w window) GetCanFocus() bool {
	return WrapWidget(gextras.InternObject(w)).GetCanFocus()
}

func (w window) GetCanTarget() bool {
	return WrapWidget(gextras.InternObject(w)).GetCanTarget()
}

func (w window) GetChildVisible() bool {
	return WrapWidget(gextras.InternObject(w)).GetChildVisible()
}

func (w window) GetClipboard() gdk.Clipboard {
	return WrapWidget(gextras.InternObject(w)).GetClipboard()
}

func (w window) GetCSSClasses() []string {
	return WrapWidget(gextras.InternObject(w)).GetCSSClasses()
}

func (s window) GetCSSName() string {
	return WrapWidget(gextras.InternObject(s)).GetCSSName()
}

func (w window) GetCursor() gdk.Cursor {
	return WrapWidget(gextras.InternObject(w)).GetCursor()
}

func (w window) GetDirection() TextDirection {
	return WrapWidget(gextras.InternObject(w)).GetDirection()
}

func (w window) GetDisplay() gdk.Display {
	return WrapWidget(gextras.InternObject(w)).GetDisplay()
}

func (w window) GetFirstChild() Widget {
	return WrapWidget(gextras.InternObject(w)).GetFirstChild()
}

func (w window) GetFocusChild() Widget {
	return WrapWidget(gextras.InternObject(w)).GetFocusChild()
}

func (w window) GetFocusOnClick() bool {
	return WrapWidget(gextras.InternObject(w)).GetFocusOnClick()
}

func (w window) GetFocusable() bool {
	return WrapWidget(gextras.InternObject(w)).GetFocusable()
}

func (w window) GetFontMap() pango.FontMap {
	return WrapWidget(gextras.InternObject(w)).GetFontMap()
}

func (w window) GetFontOptions() *cairo.FontOptions {
	return WrapWidget(gextras.InternObject(w)).GetFontOptions()
}

func (w window) GetFrameClock() gdk.FrameClock {
	return WrapWidget(gextras.InternObject(w)).GetFrameClock()
}

func (w window) GetHAlign() Align {
	return WrapWidget(gextras.InternObject(w)).GetHAlign()
}

func (w window) GetHasTooltip() bool {
	return WrapWidget(gextras.InternObject(w)).GetHasTooltip()
}

func (w window) GetHeight() int {
	return WrapWidget(gextras.InternObject(w)).GetHeight()
}

func (w window) GetHExpand() bool {
	return WrapWidget(gextras.InternObject(w)).GetHExpand()
}

func (w window) GetHExpandSet() bool {
	return WrapWidget(gextras.InternObject(w)).GetHExpandSet()
}

func (w window) GetLastChild() Widget {
	return WrapWidget(gextras.InternObject(w)).GetLastChild()
}

func (w window) GetLayoutManager() LayoutManager {
	return WrapWidget(gextras.InternObject(w)).GetLayoutManager()
}

func (w window) GetMapped() bool {
	return WrapWidget(gextras.InternObject(w)).GetMapped()
}

func (w window) GetMarginBottom() int {
	return WrapWidget(gextras.InternObject(w)).GetMarginBottom()
}

func (w window) GetMarginEnd() int {
	return WrapWidget(gextras.InternObject(w)).GetMarginEnd()
}

func (w window) GetMarginStart() int {
	return WrapWidget(gextras.InternObject(w)).GetMarginStart()
}

func (w window) GetMarginTop() int {
	return WrapWidget(gextras.InternObject(w)).GetMarginTop()
}

func (w window) GetName() string {
	return WrapWidget(gextras.InternObject(w)).GetName()
}

func (w window) GetNative() Native {
	return WrapWidget(gextras.InternObject(w)).GetNative()
}

func (w window) GetNextSibling() Widget {
	return WrapWidget(gextras.InternObject(w)).GetNextSibling()
}

func (w window) GetOpacity() float64 {
	return WrapWidget(gextras.InternObject(w)).GetOpacity()
}

func (w window) GetOverflow() Overflow {
	return WrapWidget(gextras.InternObject(w)).GetOverflow()
}

func (w window) GetPangoContext() pango.Context {
	return WrapWidget(gextras.InternObject(w)).GetPangoContext()
}

func (w window) GetParent() Widget {
	return WrapWidget(gextras.InternObject(w)).GetParent()
}

func (w window) GetPreferredSize() (minimumSize Requisition, naturalSize Requisition) {
	return WrapWidget(gextras.InternObject(w)).GetPreferredSize()
}

func (w window) GetPrevSibling() Widget {
	return WrapWidget(gextras.InternObject(w)).GetPrevSibling()
}

func (w window) GetPrimaryClipboard() gdk.Clipboard {
	return WrapWidget(gextras.InternObject(w)).GetPrimaryClipboard()
}

func (w window) GetRealized() bool {
	return WrapWidget(gextras.InternObject(w)).GetRealized()
}

func (w window) GetReceivesDefault() bool {
	return WrapWidget(gextras.InternObject(w)).GetReceivesDefault()
}

func (w window) GetRequestMode() SizeRequestMode {
	return WrapWidget(gextras.InternObject(w)).GetRequestMode()
}

func (w window) GetRoot() Root {
	return WrapWidget(gextras.InternObject(w)).GetRoot()
}

func (w window) GetScaleFactor() int {
	return WrapWidget(gextras.InternObject(w)).GetScaleFactor()
}

func (w window) GetSensitive() bool {
	return WrapWidget(gextras.InternObject(w)).GetSensitive()
}

func (w window) GetSettings() Settings {
	return WrapWidget(gextras.InternObject(w)).GetSettings()
}

func (w window) GetSize(orientation Orientation) int {
	return WrapWidget(gextras.InternObject(w)).GetSize(orientation)
}

func (w window) GetSizeRequest() (width int, height int) {
	return WrapWidget(gextras.InternObject(w)).GetSizeRequest()
}

func (w window) GetStateFlags() StateFlags {
	return WrapWidget(gextras.InternObject(w)).GetStateFlags()
}

func (w window) GetStyleContext() StyleContext {
	return WrapWidget(gextras.InternObject(w)).GetStyleContext()
}

func (w window) GetTemplateChild(widgetType externglib.Type, name string) gextras.Objector {
	return WrapWidget(gextras.InternObject(w)).GetTemplateChild(widgetType, name)
}

func (w window) GetTooltipMarkup() string {
	return WrapWidget(gextras.InternObject(w)).GetTooltipMarkup()
}

func (w window) GetTooltipText() string {
	return WrapWidget(gextras.InternObject(w)).GetTooltipText()
}

func (w window) GetVAlign() Align {
	return WrapWidget(gextras.InternObject(w)).GetVAlign()
}

func (w window) GetVExpand() bool {
	return WrapWidget(gextras.InternObject(w)).GetVExpand()
}

func (w window) GetVExpandSet() bool {
	return WrapWidget(gextras.InternObject(w)).GetVExpandSet()
}

func (w window) GetVisible() bool {
	return WrapWidget(gextras.InternObject(w)).GetVisible()
}

func (w window) GetWidth() int {
	return WrapWidget(gextras.InternObject(w)).GetWidth()
}

func (w window) GrabFocus() bool {
	return WrapWidget(gextras.InternObject(w)).GrabFocus()
}

func (w window) HasCSSClass(cssClass string) bool {
	return WrapWidget(gextras.InternObject(w)).HasCSSClass(cssClass)
}

func (w window) HasDefault() bool {
	return WrapWidget(gextras.InternObject(w)).HasDefault()
}

func (w window) HasFocus() bool {
	return WrapWidget(gextras.InternObject(w)).HasFocus()
}

func (w window) HasVisibleFocus() bool {
	return WrapWidget(gextras.InternObject(w)).HasVisibleFocus()
}

func (w window) Hide() {
	WrapWidget(gextras.InternObject(w)).Hide()
}

func (w window) InDestruction() bool {
	return WrapWidget(gextras.InternObject(w)).InDestruction()
}

func (w window) InitTemplate() {
	WrapWidget(gextras.InternObject(w)).InitTemplate()
}

func (w window) InsertAfter(parent Widget, previousSibling Widget) {
	WrapWidget(gextras.InternObject(w)).InsertAfter(parent, previousSibling)
}

func (w window) InsertBefore(parent Widget, nextSibling Widget) {
	WrapWidget(gextras.InternObject(w)).InsertBefore(parent, nextSibling)
}

func (w window) IsAncestor(ancestor Widget) bool {
	return WrapWidget(gextras.InternObject(w)).IsAncestor(ancestor)
}

func (w window) IsDrawable() bool {
	return WrapWidget(gextras.InternObject(w)).IsDrawable()
}

func (w window) IsFocus() bool {
	return WrapWidget(gextras.InternObject(w)).IsFocus()
}

func (w window) IsSensitive() bool {
	return WrapWidget(gextras.InternObject(w)).IsSensitive()
}

func (w window) IsVisible() bool {
	return WrapWidget(gextras.InternObject(w)).IsVisible()
}

func (w window) KeynavFailed(direction DirectionType) bool {
	return WrapWidget(gextras.InternObject(w)).KeynavFailed(direction)
}

func (w window) Map() {
	WrapWidget(gextras.InternObject(w)).Map()
}

func (w window) Measure(orientation Orientation, forSize int) (minimum int, natural int, minimumBaseline int, naturalBaseline int) {
	return WrapWidget(gextras.InternObject(w)).Measure(orientation, forSize)
}

func (w window) MnemonicActivate(groupCycling bool) bool {
	return WrapWidget(gextras.InternObject(w)).MnemonicActivate(groupCycling)
}

func (w window) Pick(x float64, y float64, flags PickFlags) Widget {
	return WrapWidget(gextras.InternObject(w)).Pick(x, y, flags)
}

func (w window) QueueAllocate() {
	WrapWidget(gextras.InternObject(w)).QueueAllocate()
}

func (w window) QueueDraw() {
	WrapWidget(gextras.InternObject(w)).QueueDraw()
}

func (w window) QueueResize() {
	WrapWidget(gextras.InternObject(w)).QueueResize()
}

func (w window) Realize() {
	WrapWidget(gextras.InternObject(w)).Realize()
}

func (w window) RemoveController(controller EventController) {
	WrapWidget(gextras.InternObject(w)).RemoveController(controller)
}

func (w window) RemoveCSSClass(cssClass string) {
	WrapWidget(gextras.InternObject(w)).RemoveCSSClass(cssClass)
}

func (w window) RemoveMnemonicLabel(label Widget) {
	WrapWidget(gextras.InternObject(w)).RemoveMnemonicLabel(label)
}

func (w window) RemoveTickCallback(id uint) {
	WrapWidget(gextras.InternObject(w)).RemoveTickCallback(id)
}

func (w window) SetCanFocus(canFocus bool) {
	WrapWidget(gextras.InternObject(w)).SetCanFocus(canFocus)
}

func (w window) SetCanTarget(canTarget bool) {
	WrapWidget(gextras.InternObject(w)).SetCanTarget(canTarget)
}

func (w window) SetChildVisible(childVisible bool) {
	WrapWidget(gextras.InternObject(w)).SetChildVisible(childVisible)
}

func (w window) SetCSSClasses(classes []string) {
	WrapWidget(gextras.InternObject(w)).SetCSSClasses(classes)
}

func (w window) SetCursor(cursor gdk.Cursor) {
	WrapWidget(gextras.InternObject(w)).SetCursor(cursor)
}

func (w window) SetCursorFromName(name string) {
	WrapWidget(gextras.InternObject(w)).SetCursorFromName(name)
}

func (w window) SetDirection(dir TextDirection) {
	WrapWidget(gextras.InternObject(w)).SetDirection(dir)
}

func (w window) SetFocusChild(child Widget) {
	WrapWidget(gextras.InternObject(w)).SetFocusChild(child)
}

func (w window) SetFocusOnClick(focusOnClick bool) {
	WrapWidget(gextras.InternObject(w)).SetFocusOnClick(focusOnClick)
}

func (w window) SetFocusable(focusable bool) {
	WrapWidget(gextras.InternObject(w)).SetFocusable(focusable)
}

func (w window) SetFontMap(fontMap pango.FontMap) {
	WrapWidget(gextras.InternObject(w)).SetFontMap(fontMap)
}

func (w window) SetFontOptions(options *cairo.FontOptions) {
	WrapWidget(gextras.InternObject(w)).SetFontOptions(options)
}

func (w window) SetHAlign(align Align) {
	WrapWidget(gextras.InternObject(w)).SetHAlign(align)
}

func (w window) SetHasTooltip(hasTooltip bool) {
	WrapWidget(gextras.InternObject(w)).SetHasTooltip(hasTooltip)
}

func (w window) SetHExpand(expand bool) {
	WrapWidget(gextras.InternObject(w)).SetHExpand(expand)
}

func (w window) SetHExpandSet(set bool) {
	WrapWidget(gextras.InternObject(w)).SetHExpandSet(set)
}

func (w window) SetLayoutManager(layoutManager LayoutManager) {
	WrapWidget(gextras.InternObject(w)).SetLayoutManager(layoutManager)
}

func (w window) SetMarginBottom(margin int) {
	WrapWidget(gextras.InternObject(w)).SetMarginBottom(margin)
}

func (w window) SetMarginEnd(margin int) {
	WrapWidget(gextras.InternObject(w)).SetMarginEnd(margin)
}

func (w window) SetMarginStart(margin int) {
	WrapWidget(gextras.InternObject(w)).SetMarginStart(margin)
}

func (w window) SetMarginTop(margin int) {
	WrapWidget(gextras.InternObject(w)).SetMarginTop(margin)
}

func (w window) SetName(name string) {
	WrapWidget(gextras.InternObject(w)).SetName(name)
}

func (w window) SetOpacity(opacity float64) {
	WrapWidget(gextras.InternObject(w)).SetOpacity(opacity)
}

func (w window) SetOverflow(overflow Overflow) {
	WrapWidget(gextras.InternObject(w)).SetOverflow(overflow)
}

func (w window) SetParent(parent Widget) {
	WrapWidget(gextras.InternObject(w)).SetParent(parent)
}

func (w window) SetReceivesDefault(receivesDefault bool) {
	WrapWidget(gextras.InternObject(w)).SetReceivesDefault(receivesDefault)
}

func (w window) SetSensitive(sensitive bool) {
	WrapWidget(gextras.InternObject(w)).SetSensitive(sensitive)
}

func (w window) SetSizeRequest(width int, height int) {
	WrapWidget(gextras.InternObject(w)).SetSizeRequest(width, height)
}

func (w window) SetStateFlags(flags StateFlags, clear bool) {
	WrapWidget(gextras.InternObject(w)).SetStateFlags(flags, clear)
}

func (w window) SetTooltipMarkup(markup string) {
	WrapWidget(gextras.InternObject(w)).SetTooltipMarkup(markup)
}

func (w window) SetTooltipText(text string) {
	WrapWidget(gextras.InternObject(w)).SetTooltipText(text)
}

func (w window) SetVAlign(align Align) {
	WrapWidget(gextras.InternObject(w)).SetVAlign(align)
}

func (w window) SetVExpand(expand bool) {
	WrapWidget(gextras.InternObject(w)).SetVExpand(expand)
}

func (w window) SetVExpandSet(set bool) {
	WrapWidget(gextras.InternObject(w)).SetVExpandSet(set)
}

func (w window) SetVisible(visible bool) {
	WrapWidget(gextras.InternObject(w)).SetVisible(visible)
}

func (w window) ShouldLayout() bool {
	return WrapWidget(gextras.InternObject(w)).ShouldLayout()
}

func (w window) Show() {
	WrapWidget(gextras.InternObject(w)).Show()
}

func (w window) SnapshotChild(child Widget, snapshot Snapshot) {
	WrapWidget(gextras.InternObject(w)).SnapshotChild(child, snapshot)
}

func (s window) TranslateCoordinates(destWidget Widget, srcX float64, srcY float64) (destX float64, destY float64, ok bool) {
	return WrapWidget(gextras.InternObject(s)).TranslateCoordinates(destWidget, srcX, srcY)
}

func (w window) TriggerTooltipQuery() {
	WrapWidget(gextras.InternObject(w)).TriggerTooltipQuery()
}

func (w window) Unmap() {
	WrapWidget(gextras.InternObject(w)).Unmap()
}

func (w window) Unparent() {
	WrapWidget(gextras.InternObject(w)).Unparent()
}

func (w window) Unrealize() {
	WrapWidget(gextras.InternObject(w)).Unrealize()
}

func (w window) UnsetStateFlags(flags StateFlags) {
	WrapWidget(gextras.InternObject(w)).UnsetStateFlags(flags)
}

func (s window) GetAccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).GetAccessibleRole()
}

func (s window) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s window) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s window) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s window) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s window) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s window) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b window) GetBuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).GetBuildableID()
}

func (s window) GetAccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).GetAccessibleRole()
}

func (s window) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s window) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s window) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s window) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s window) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s window) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b window) GetBuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).GetBuildableID()
}

func (s window) GetRenderer() gsk.Renderer {
	return WrapNative(gextras.InternObject(s)).GetRenderer()
}

func (s window) GetSurface() gdk.Surface {
	return WrapNative(gextras.InternObject(s)).GetSurface()
}

func (s window) GetSurfaceTransform() (x float64, y float64) {
	return WrapNative(gextras.InternObject(s)).GetSurfaceTransform()
}

func (s window) Realize() {
	WrapNative(gextras.InternObject(s)).Realize()
}

func (s window) Unrealize() {
	WrapNative(gextras.InternObject(s)).Unrealize()
}

func (w window) ActionSetEnabled(actionName string, enabled bool) {
	WrapWidget(gextras.InternObject(w)).ActionSetEnabled(actionName, enabled)
}

func (w window) Activate() bool {
	return WrapWidget(gextras.InternObject(w)).Activate()
}

func (w window) ActivateActionVariant(name string, args *glib.Variant) bool {
	return WrapWidget(gextras.InternObject(w)).ActivateActionVariant(name, args)
}

func (w window) ActivateDefault() {
	WrapWidget(gextras.InternObject(w)).ActivateDefault()
}

func (w window) AddController(controller EventController) {
	WrapWidget(gextras.InternObject(w)).AddController(controller)
}

func (w window) AddCSSClass(cssClass string) {
	WrapWidget(gextras.InternObject(w)).AddCSSClass(cssClass)
}

func (w window) AddMnemonicLabel(label Widget) {
	WrapWidget(gextras.InternObject(w)).AddMnemonicLabel(label)
}

func (w window) Allocate(width int, height int, baseline int, transform *gsk.Transform) {
	WrapWidget(gextras.InternObject(w)).Allocate(width, height, baseline, transform)
}

func (w window) ChildFocus(direction DirectionType) bool {
	return WrapWidget(gextras.InternObject(w)).ChildFocus(direction)
}

func (w window) ComputeBounds(target Widget) (graphene.Rect, bool) {
	return WrapWidget(gextras.InternObject(w)).ComputeBounds(target)
}

func (w window) ComputeExpand(orientation Orientation) bool {
	return WrapWidget(gextras.InternObject(w)).ComputeExpand(orientation)
}

func (w window) ComputePoint(target Widget, point *graphene.Point) (graphene.Point, bool) {
	return WrapWidget(gextras.InternObject(w)).ComputePoint(target, point)
}

func (w window) ComputeTransform(target Widget) (graphene.Matrix, bool) {
	return WrapWidget(gextras.InternObject(w)).ComputeTransform(target)
}

func (w window) Contains(x float64, y float64) bool {
	return WrapWidget(gextras.InternObject(w)).Contains(x, y)
}

func (w window) CreatePangoContext() pango.Context {
	return WrapWidget(gextras.InternObject(w)).CreatePangoContext()
}

func (w window) CreatePangoLayout(text string) pango.Layout {
	return WrapWidget(gextras.InternObject(w)).CreatePangoLayout(text)
}

func (w window) DragCheckThreshold(startX int, startY int, currentX int, currentY int) bool {
	return WrapWidget(gextras.InternObject(w)).DragCheckThreshold(startX, startY, currentX, currentY)
}

func (w window) ErrorBell() {
	WrapWidget(gextras.InternObject(w)).ErrorBell()
}

func (w window) GetAllocatedBaseline() int {
	return WrapWidget(gextras.InternObject(w)).GetAllocatedBaseline()
}

func (w window) GetAllocatedHeight() int {
	return WrapWidget(gextras.InternObject(w)).GetAllocatedHeight()
}

func (w window) GetAllocatedWidth() int {
	return WrapWidget(gextras.InternObject(w)).GetAllocatedWidth()
}

func (w window) GetAncestor(widgetType externglib.Type) Widget {
	return WrapWidget(gextras.InternObject(w)).GetAncestor(widgetType)
}

func (w window) GetCanFocus() bool {
	return WrapWidget(gextras.InternObject(w)).GetCanFocus()
}

func (w window) GetCanTarget() bool {
	return WrapWidget(gextras.InternObject(w)).GetCanTarget()
}

func (w window) GetChildVisible() bool {
	return WrapWidget(gextras.InternObject(w)).GetChildVisible()
}

func (w window) GetClipboard() gdk.Clipboard {
	return WrapWidget(gextras.InternObject(w)).GetClipboard()
}

func (w window) GetCSSClasses() []string {
	return WrapWidget(gextras.InternObject(w)).GetCSSClasses()
}

func (s window) GetCSSName() string {
	return WrapWidget(gextras.InternObject(s)).GetCSSName()
}

func (w window) GetCursor() gdk.Cursor {
	return WrapWidget(gextras.InternObject(w)).GetCursor()
}

func (w window) GetDirection() TextDirection {
	return WrapWidget(gextras.InternObject(w)).GetDirection()
}

func (w window) GetDisplay() gdk.Display {
	return WrapWidget(gextras.InternObject(w)).GetDisplay()
}

func (w window) GetFirstChild() Widget {
	return WrapWidget(gextras.InternObject(w)).GetFirstChild()
}

func (w window) GetFocusChild() Widget {
	return WrapWidget(gextras.InternObject(w)).GetFocusChild()
}

func (w window) GetFocusOnClick() bool {
	return WrapWidget(gextras.InternObject(w)).GetFocusOnClick()
}

func (w window) GetFocusable() bool {
	return WrapWidget(gextras.InternObject(w)).GetFocusable()
}

func (w window) GetFontMap() pango.FontMap {
	return WrapWidget(gextras.InternObject(w)).GetFontMap()
}

func (w window) GetFontOptions() *cairo.FontOptions {
	return WrapWidget(gextras.InternObject(w)).GetFontOptions()
}

func (w window) GetFrameClock() gdk.FrameClock {
	return WrapWidget(gextras.InternObject(w)).GetFrameClock()
}

func (w window) GetHAlign() Align {
	return WrapWidget(gextras.InternObject(w)).GetHAlign()
}

func (w window) GetHasTooltip() bool {
	return WrapWidget(gextras.InternObject(w)).GetHasTooltip()
}

func (w window) GetHeight() int {
	return WrapWidget(gextras.InternObject(w)).GetHeight()
}

func (w window) GetHExpand() bool {
	return WrapWidget(gextras.InternObject(w)).GetHExpand()
}

func (w window) GetHExpandSet() bool {
	return WrapWidget(gextras.InternObject(w)).GetHExpandSet()
}

func (w window) GetLastChild() Widget {
	return WrapWidget(gextras.InternObject(w)).GetLastChild()
}

func (w window) GetLayoutManager() LayoutManager {
	return WrapWidget(gextras.InternObject(w)).GetLayoutManager()
}

func (w window) GetMapped() bool {
	return WrapWidget(gextras.InternObject(w)).GetMapped()
}

func (w window) GetMarginBottom() int {
	return WrapWidget(gextras.InternObject(w)).GetMarginBottom()
}

func (w window) GetMarginEnd() int {
	return WrapWidget(gextras.InternObject(w)).GetMarginEnd()
}

func (w window) GetMarginStart() int {
	return WrapWidget(gextras.InternObject(w)).GetMarginStart()
}

func (w window) GetMarginTop() int {
	return WrapWidget(gextras.InternObject(w)).GetMarginTop()
}

func (w window) GetName() string {
	return WrapWidget(gextras.InternObject(w)).GetName()
}

func (w window) GetNative() Native {
	return WrapWidget(gextras.InternObject(w)).GetNative()
}

func (w window) GetNextSibling() Widget {
	return WrapWidget(gextras.InternObject(w)).GetNextSibling()
}

func (w window) GetOpacity() float64 {
	return WrapWidget(gextras.InternObject(w)).GetOpacity()
}

func (w window) GetOverflow() Overflow {
	return WrapWidget(gextras.InternObject(w)).GetOverflow()
}

func (w window) GetPangoContext() pango.Context {
	return WrapWidget(gextras.InternObject(w)).GetPangoContext()
}

func (w window) GetParent() Widget {
	return WrapWidget(gextras.InternObject(w)).GetParent()
}

func (w window) GetPreferredSize() (minimumSize Requisition, naturalSize Requisition) {
	return WrapWidget(gextras.InternObject(w)).GetPreferredSize()
}

func (w window) GetPrevSibling() Widget {
	return WrapWidget(gextras.InternObject(w)).GetPrevSibling()
}

func (w window) GetPrimaryClipboard() gdk.Clipboard {
	return WrapWidget(gextras.InternObject(w)).GetPrimaryClipboard()
}

func (w window) GetRealized() bool {
	return WrapWidget(gextras.InternObject(w)).GetRealized()
}

func (w window) GetReceivesDefault() bool {
	return WrapWidget(gextras.InternObject(w)).GetReceivesDefault()
}

func (w window) GetRequestMode() SizeRequestMode {
	return WrapWidget(gextras.InternObject(w)).GetRequestMode()
}

func (w window) GetRoot() Root {
	return WrapWidget(gextras.InternObject(w)).GetRoot()
}

func (w window) GetScaleFactor() int {
	return WrapWidget(gextras.InternObject(w)).GetScaleFactor()
}

func (w window) GetSensitive() bool {
	return WrapWidget(gextras.InternObject(w)).GetSensitive()
}

func (w window) GetSettings() Settings {
	return WrapWidget(gextras.InternObject(w)).GetSettings()
}

func (w window) GetSize(orientation Orientation) int {
	return WrapWidget(gextras.InternObject(w)).GetSize(orientation)
}

func (w window) GetSizeRequest() (width int, height int) {
	return WrapWidget(gextras.InternObject(w)).GetSizeRequest()
}

func (w window) GetStateFlags() StateFlags {
	return WrapWidget(gextras.InternObject(w)).GetStateFlags()
}

func (w window) GetStyleContext() StyleContext {
	return WrapWidget(gextras.InternObject(w)).GetStyleContext()
}

func (w window) GetTemplateChild(widgetType externglib.Type, name string) gextras.Objector {
	return WrapWidget(gextras.InternObject(w)).GetTemplateChild(widgetType, name)
}

func (w window) GetTooltipMarkup() string {
	return WrapWidget(gextras.InternObject(w)).GetTooltipMarkup()
}

func (w window) GetTooltipText() string {
	return WrapWidget(gextras.InternObject(w)).GetTooltipText()
}

func (w window) GetVAlign() Align {
	return WrapWidget(gextras.InternObject(w)).GetVAlign()
}

func (w window) GetVExpand() bool {
	return WrapWidget(gextras.InternObject(w)).GetVExpand()
}

func (w window) GetVExpandSet() bool {
	return WrapWidget(gextras.InternObject(w)).GetVExpandSet()
}

func (w window) GetVisible() bool {
	return WrapWidget(gextras.InternObject(w)).GetVisible()
}

func (w window) GetWidth() int {
	return WrapWidget(gextras.InternObject(w)).GetWidth()
}

func (w window) GrabFocus() bool {
	return WrapWidget(gextras.InternObject(w)).GrabFocus()
}

func (w window) HasCSSClass(cssClass string) bool {
	return WrapWidget(gextras.InternObject(w)).HasCSSClass(cssClass)
}

func (w window) HasDefault() bool {
	return WrapWidget(gextras.InternObject(w)).HasDefault()
}

func (w window) HasFocus() bool {
	return WrapWidget(gextras.InternObject(w)).HasFocus()
}

func (w window) HasVisibleFocus() bool {
	return WrapWidget(gextras.InternObject(w)).HasVisibleFocus()
}

func (w window) Hide() {
	WrapWidget(gextras.InternObject(w)).Hide()
}

func (w window) InDestruction() bool {
	return WrapWidget(gextras.InternObject(w)).InDestruction()
}

func (w window) InitTemplate() {
	WrapWidget(gextras.InternObject(w)).InitTemplate()
}

func (w window) InsertAfter(parent Widget, previousSibling Widget) {
	WrapWidget(gextras.InternObject(w)).InsertAfter(parent, previousSibling)
}

func (w window) InsertBefore(parent Widget, nextSibling Widget) {
	WrapWidget(gextras.InternObject(w)).InsertBefore(parent, nextSibling)
}

func (w window) IsAncestor(ancestor Widget) bool {
	return WrapWidget(gextras.InternObject(w)).IsAncestor(ancestor)
}

func (w window) IsDrawable() bool {
	return WrapWidget(gextras.InternObject(w)).IsDrawable()
}

func (w window) IsFocus() bool {
	return WrapWidget(gextras.InternObject(w)).IsFocus()
}

func (w window) IsSensitive() bool {
	return WrapWidget(gextras.InternObject(w)).IsSensitive()
}

func (w window) IsVisible() bool {
	return WrapWidget(gextras.InternObject(w)).IsVisible()
}

func (w window) KeynavFailed(direction DirectionType) bool {
	return WrapWidget(gextras.InternObject(w)).KeynavFailed(direction)
}

func (w window) Map() {
	WrapWidget(gextras.InternObject(w)).Map()
}

func (w window) Measure(orientation Orientation, forSize int) (minimum int, natural int, minimumBaseline int, naturalBaseline int) {
	return WrapWidget(gextras.InternObject(w)).Measure(orientation, forSize)
}

func (w window) MnemonicActivate(groupCycling bool) bool {
	return WrapWidget(gextras.InternObject(w)).MnemonicActivate(groupCycling)
}

func (w window) Pick(x float64, y float64, flags PickFlags) Widget {
	return WrapWidget(gextras.InternObject(w)).Pick(x, y, flags)
}

func (w window) QueueAllocate() {
	WrapWidget(gextras.InternObject(w)).QueueAllocate()
}

func (w window) QueueDraw() {
	WrapWidget(gextras.InternObject(w)).QueueDraw()
}

func (w window) QueueResize() {
	WrapWidget(gextras.InternObject(w)).QueueResize()
}

func (w window) Realize() {
	WrapWidget(gextras.InternObject(w)).Realize()
}

func (w window) RemoveController(controller EventController) {
	WrapWidget(gextras.InternObject(w)).RemoveController(controller)
}

func (w window) RemoveCSSClass(cssClass string) {
	WrapWidget(gextras.InternObject(w)).RemoveCSSClass(cssClass)
}

func (w window) RemoveMnemonicLabel(label Widget) {
	WrapWidget(gextras.InternObject(w)).RemoveMnemonicLabel(label)
}

func (w window) RemoveTickCallback(id uint) {
	WrapWidget(gextras.InternObject(w)).RemoveTickCallback(id)
}

func (w window) SetCanFocus(canFocus bool) {
	WrapWidget(gextras.InternObject(w)).SetCanFocus(canFocus)
}

func (w window) SetCanTarget(canTarget bool) {
	WrapWidget(gextras.InternObject(w)).SetCanTarget(canTarget)
}

func (w window) SetChildVisible(childVisible bool) {
	WrapWidget(gextras.InternObject(w)).SetChildVisible(childVisible)
}

func (w window) SetCSSClasses(classes []string) {
	WrapWidget(gextras.InternObject(w)).SetCSSClasses(classes)
}

func (w window) SetCursor(cursor gdk.Cursor) {
	WrapWidget(gextras.InternObject(w)).SetCursor(cursor)
}

func (w window) SetCursorFromName(name string) {
	WrapWidget(gextras.InternObject(w)).SetCursorFromName(name)
}

func (w window) SetDirection(dir TextDirection) {
	WrapWidget(gextras.InternObject(w)).SetDirection(dir)
}

func (w window) SetFocusChild(child Widget) {
	WrapWidget(gextras.InternObject(w)).SetFocusChild(child)
}

func (w window) SetFocusOnClick(focusOnClick bool) {
	WrapWidget(gextras.InternObject(w)).SetFocusOnClick(focusOnClick)
}

func (w window) SetFocusable(focusable bool) {
	WrapWidget(gextras.InternObject(w)).SetFocusable(focusable)
}

func (w window) SetFontMap(fontMap pango.FontMap) {
	WrapWidget(gextras.InternObject(w)).SetFontMap(fontMap)
}

func (w window) SetFontOptions(options *cairo.FontOptions) {
	WrapWidget(gextras.InternObject(w)).SetFontOptions(options)
}

func (w window) SetHAlign(align Align) {
	WrapWidget(gextras.InternObject(w)).SetHAlign(align)
}

func (w window) SetHasTooltip(hasTooltip bool) {
	WrapWidget(gextras.InternObject(w)).SetHasTooltip(hasTooltip)
}

func (w window) SetHExpand(expand bool) {
	WrapWidget(gextras.InternObject(w)).SetHExpand(expand)
}

func (w window) SetHExpandSet(set bool) {
	WrapWidget(gextras.InternObject(w)).SetHExpandSet(set)
}

func (w window) SetLayoutManager(layoutManager LayoutManager) {
	WrapWidget(gextras.InternObject(w)).SetLayoutManager(layoutManager)
}

func (w window) SetMarginBottom(margin int) {
	WrapWidget(gextras.InternObject(w)).SetMarginBottom(margin)
}

func (w window) SetMarginEnd(margin int) {
	WrapWidget(gextras.InternObject(w)).SetMarginEnd(margin)
}

func (w window) SetMarginStart(margin int) {
	WrapWidget(gextras.InternObject(w)).SetMarginStart(margin)
}

func (w window) SetMarginTop(margin int) {
	WrapWidget(gextras.InternObject(w)).SetMarginTop(margin)
}

func (w window) SetName(name string) {
	WrapWidget(gextras.InternObject(w)).SetName(name)
}

func (w window) SetOpacity(opacity float64) {
	WrapWidget(gextras.InternObject(w)).SetOpacity(opacity)
}

func (w window) SetOverflow(overflow Overflow) {
	WrapWidget(gextras.InternObject(w)).SetOverflow(overflow)
}

func (w window) SetParent(parent Widget) {
	WrapWidget(gextras.InternObject(w)).SetParent(parent)
}

func (w window) SetReceivesDefault(receivesDefault bool) {
	WrapWidget(gextras.InternObject(w)).SetReceivesDefault(receivesDefault)
}

func (w window) SetSensitive(sensitive bool) {
	WrapWidget(gextras.InternObject(w)).SetSensitive(sensitive)
}

func (w window) SetSizeRequest(width int, height int) {
	WrapWidget(gextras.InternObject(w)).SetSizeRequest(width, height)
}

func (w window) SetStateFlags(flags StateFlags, clear bool) {
	WrapWidget(gextras.InternObject(w)).SetStateFlags(flags, clear)
}

func (w window) SetTooltipMarkup(markup string) {
	WrapWidget(gextras.InternObject(w)).SetTooltipMarkup(markup)
}

func (w window) SetTooltipText(text string) {
	WrapWidget(gextras.InternObject(w)).SetTooltipText(text)
}

func (w window) SetVAlign(align Align) {
	WrapWidget(gextras.InternObject(w)).SetVAlign(align)
}

func (w window) SetVExpand(expand bool) {
	WrapWidget(gextras.InternObject(w)).SetVExpand(expand)
}

func (w window) SetVExpandSet(set bool) {
	WrapWidget(gextras.InternObject(w)).SetVExpandSet(set)
}

func (w window) SetVisible(visible bool) {
	WrapWidget(gextras.InternObject(w)).SetVisible(visible)
}

func (w window) ShouldLayout() bool {
	return WrapWidget(gextras.InternObject(w)).ShouldLayout()
}

func (w window) Show() {
	WrapWidget(gextras.InternObject(w)).Show()
}

func (w window) SnapshotChild(child Widget, snapshot Snapshot) {
	WrapWidget(gextras.InternObject(w)).SnapshotChild(child, snapshot)
}

func (s window) TranslateCoordinates(destWidget Widget, srcX float64, srcY float64) (destX float64, destY float64, ok bool) {
	return WrapWidget(gextras.InternObject(s)).TranslateCoordinates(destWidget, srcX, srcY)
}

func (w window) TriggerTooltipQuery() {
	WrapWidget(gextras.InternObject(w)).TriggerTooltipQuery()
}

func (w window) Unmap() {
	WrapWidget(gextras.InternObject(w)).Unmap()
}

func (w window) Unparent() {
	WrapWidget(gextras.InternObject(w)).Unparent()
}

func (w window) Unrealize() {
	WrapWidget(gextras.InternObject(w)).Unrealize()
}

func (w window) UnsetStateFlags(flags StateFlags) {
	WrapWidget(gextras.InternObject(w)).UnsetStateFlags(flags)
}

func (s window) GetAccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).GetAccessibleRole()
}

func (s window) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s window) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s window) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s window) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s window) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s window) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b window) GetBuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).GetBuildableID()
}

func (s window) GetDisplay() gdk.Display {
	return WrapRoot(gextras.InternObject(s)).GetDisplay()
}

func (s window) GetFocus() Widget {
	return WrapRoot(gextras.InternObject(s)).GetFocus()
}

func (s window) SetFocus(focus Widget) {
	WrapRoot(gextras.InternObject(s)).SetFocus(focus)
}

func (s window) GetRenderer() gsk.Renderer {
	return WrapNative(gextras.InternObject(s)).GetRenderer()
}

func (s window) GetSurface() gdk.Surface {
	return WrapNative(gextras.InternObject(s)).GetSurface()
}

func (s window) GetSurfaceTransform() (x float64, y float64) {
	return WrapNative(gextras.InternObject(s)).GetSurfaceTransform()
}

func (s window) Realize() {
	WrapNative(gextras.InternObject(s)).Realize()
}

func (s window) Unrealize() {
	WrapNative(gextras.InternObject(s)).Unrealize()
}

func (w window) ActionSetEnabled(actionName string, enabled bool) {
	WrapWidget(gextras.InternObject(w)).ActionSetEnabled(actionName, enabled)
}

func (w window) Activate() bool {
	return WrapWidget(gextras.InternObject(w)).Activate()
}

func (w window) ActivateActionVariant(name string, args *glib.Variant) bool {
	return WrapWidget(gextras.InternObject(w)).ActivateActionVariant(name, args)
}

func (w window) ActivateDefault() {
	WrapWidget(gextras.InternObject(w)).ActivateDefault()
}

func (w window) AddController(controller EventController) {
	WrapWidget(gextras.InternObject(w)).AddController(controller)
}

func (w window) AddCSSClass(cssClass string) {
	WrapWidget(gextras.InternObject(w)).AddCSSClass(cssClass)
}

func (w window) AddMnemonicLabel(label Widget) {
	WrapWidget(gextras.InternObject(w)).AddMnemonicLabel(label)
}

func (w window) Allocate(width int, height int, baseline int, transform *gsk.Transform) {
	WrapWidget(gextras.InternObject(w)).Allocate(width, height, baseline, transform)
}

func (w window) ChildFocus(direction DirectionType) bool {
	return WrapWidget(gextras.InternObject(w)).ChildFocus(direction)
}

func (w window) ComputeBounds(target Widget) (graphene.Rect, bool) {
	return WrapWidget(gextras.InternObject(w)).ComputeBounds(target)
}

func (w window) ComputeExpand(orientation Orientation) bool {
	return WrapWidget(gextras.InternObject(w)).ComputeExpand(orientation)
}

func (w window) ComputePoint(target Widget, point *graphene.Point) (graphene.Point, bool) {
	return WrapWidget(gextras.InternObject(w)).ComputePoint(target, point)
}

func (w window) ComputeTransform(target Widget) (graphene.Matrix, bool) {
	return WrapWidget(gextras.InternObject(w)).ComputeTransform(target)
}

func (w window) Contains(x float64, y float64) bool {
	return WrapWidget(gextras.InternObject(w)).Contains(x, y)
}

func (w window) CreatePangoContext() pango.Context {
	return WrapWidget(gextras.InternObject(w)).CreatePangoContext()
}

func (w window) CreatePangoLayout(text string) pango.Layout {
	return WrapWidget(gextras.InternObject(w)).CreatePangoLayout(text)
}

func (w window) DragCheckThreshold(startX int, startY int, currentX int, currentY int) bool {
	return WrapWidget(gextras.InternObject(w)).DragCheckThreshold(startX, startY, currentX, currentY)
}

func (w window) ErrorBell() {
	WrapWidget(gextras.InternObject(w)).ErrorBell()
}

func (w window) GetAllocatedBaseline() int {
	return WrapWidget(gextras.InternObject(w)).GetAllocatedBaseline()
}

func (w window) GetAllocatedHeight() int {
	return WrapWidget(gextras.InternObject(w)).GetAllocatedHeight()
}

func (w window) GetAllocatedWidth() int {
	return WrapWidget(gextras.InternObject(w)).GetAllocatedWidth()
}

func (w window) GetAncestor(widgetType externglib.Type) Widget {
	return WrapWidget(gextras.InternObject(w)).GetAncestor(widgetType)
}

func (w window) GetCanFocus() bool {
	return WrapWidget(gextras.InternObject(w)).GetCanFocus()
}

func (w window) GetCanTarget() bool {
	return WrapWidget(gextras.InternObject(w)).GetCanTarget()
}

func (w window) GetChildVisible() bool {
	return WrapWidget(gextras.InternObject(w)).GetChildVisible()
}

func (w window) GetClipboard() gdk.Clipboard {
	return WrapWidget(gextras.InternObject(w)).GetClipboard()
}

func (w window) GetCSSClasses() []string {
	return WrapWidget(gextras.InternObject(w)).GetCSSClasses()
}

func (s window) GetCSSName() string {
	return WrapWidget(gextras.InternObject(s)).GetCSSName()
}

func (w window) GetCursor() gdk.Cursor {
	return WrapWidget(gextras.InternObject(w)).GetCursor()
}

func (w window) GetDirection() TextDirection {
	return WrapWidget(gextras.InternObject(w)).GetDirection()
}

func (w window) GetDisplay() gdk.Display {
	return WrapWidget(gextras.InternObject(w)).GetDisplay()
}

func (w window) GetFirstChild() Widget {
	return WrapWidget(gextras.InternObject(w)).GetFirstChild()
}

func (w window) GetFocusChild() Widget {
	return WrapWidget(gextras.InternObject(w)).GetFocusChild()
}

func (w window) GetFocusOnClick() bool {
	return WrapWidget(gextras.InternObject(w)).GetFocusOnClick()
}

func (w window) GetFocusable() bool {
	return WrapWidget(gextras.InternObject(w)).GetFocusable()
}

func (w window) GetFontMap() pango.FontMap {
	return WrapWidget(gextras.InternObject(w)).GetFontMap()
}

func (w window) GetFontOptions() *cairo.FontOptions {
	return WrapWidget(gextras.InternObject(w)).GetFontOptions()
}

func (w window) GetFrameClock() gdk.FrameClock {
	return WrapWidget(gextras.InternObject(w)).GetFrameClock()
}

func (w window) GetHAlign() Align {
	return WrapWidget(gextras.InternObject(w)).GetHAlign()
}

func (w window) GetHasTooltip() bool {
	return WrapWidget(gextras.InternObject(w)).GetHasTooltip()
}

func (w window) GetHeight() int {
	return WrapWidget(gextras.InternObject(w)).GetHeight()
}

func (w window) GetHExpand() bool {
	return WrapWidget(gextras.InternObject(w)).GetHExpand()
}

func (w window) GetHExpandSet() bool {
	return WrapWidget(gextras.InternObject(w)).GetHExpandSet()
}

func (w window) GetLastChild() Widget {
	return WrapWidget(gextras.InternObject(w)).GetLastChild()
}

func (w window) GetLayoutManager() LayoutManager {
	return WrapWidget(gextras.InternObject(w)).GetLayoutManager()
}

func (w window) GetMapped() bool {
	return WrapWidget(gextras.InternObject(w)).GetMapped()
}

func (w window) GetMarginBottom() int {
	return WrapWidget(gextras.InternObject(w)).GetMarginBottom()
}

func (w window) GetMarginEnd() int {
	return WrapWidget(gextras.InternObject(w)).GetMarginEnd()
}

func (w window) GetMarginStart() int {
	return WrapWidget(gextras.InternObject(w)).GetMarginStart()
}

func (w window) GetMarginTop() int {
	return WrapWidget(gextras.InternObject(w)).GetMarginTop()
}

func (w window) GetName() string {
	return WrapWidget(gextras.InternObject(w)).GetName()
}

func (w window) GetNative() Native {
	return WrapWidget(gextras.InternObject(w)).GetNative()
}

func (w window) GetNextSibling() Widget {
	return WrapWidget(gextras.InternObject(w)).GetNextSibling()
}

func (w window) GetOpacity() float64 {
	return WrapWidget(gextras.InternObject(w)).GetOpacity()
}

func (w window) GetOverflow() Overflow {
	return WrapWidget(gextras.InternObject(w)).GetOverflow()
}

func (w window) GetPangoContext() pango.Context {
	return WrapWidget(gextras.InternObject(w)).GetPangoContext()
}

func (w window) GetParent() Widget {
	return WrapWidget(gextras.InternObject(w)).GetParent()
}

func (w window) GetPreferredSize() (minimumSize Requisition, naturalSize Requisition) {
	return WrapWidget(gextras.InternObject(w)).GetPreferredSize()
}

func (w window) GetPrevSibling() Widget {
	return WrapWidget(gextras.InternObject(w)).GetPrevSibling()
}

func (w window) GetPrimaryClipboard() gdk.Clipboard {
	return WrapWidget(gextras.InternObject(w)).GetPrimaryClipboard()
}

func (w window) GetRealized() bool {
	return WrapWidget(gextras.InternObject(w)).GetRealized()
}

func (w window) GetReceivesDefault() bool {
	return WrapWidget(gextras.InternObject(w)).GetReceivesDefault()
}

func (w window) GetRequestMode() SizeRequestMode {
	return WrapWidget(gextras.InternObject(w)).GetRequestMode()
}

func (w window) GetRoot() Root {
	return WrapWidget(gextras.InternObject(w)).GetRoot()
}

func (w window) GetScaleFactor() int {
	return WrapWidget(gextras.InternObject(w)).GetScaleFactor()
}

func (w window) GetSensitive() bool {
	return WrapWidget(gextras.InternObject(w)).GetSensitive()
}

func (w window) GetSettings() Settings {
	return WrapWidget(gextras.InternObject(w)).GetSettings()
}

func (w window) GetSize(orientation Orientation) int {
	return WrapWidget(gextras.InternObject(w)).GetSize(orientation)
}

func (w window) GetSizeRequest() (width int, height int) {
	return WrapWidget(gextras.InternObject(w)).GetSizeRequest()
}

func (w window) GetStateFlags() StateFlags {
	return WrapWidget(gextras.InternObject(w)).GetStateFlags()
}

func (w window) GetStyleContext() StyleContext {
	return WrapWidget(gextras.InternObject(w)).GetStyleContext()
}

func (w window) GetTemplateChild(widgetType externglib.Type, name string) gextras.Objector {
	return WrapWidget(gextras.InternObject(w)).GetTemplateChild(widgetType, name)
}

func (w window) GetTooltipMarkup() string {
	return WrapWidget(gextras.InternObject(w)).GetTooltipMarkup()
}

func (w window) GetTooltipText() string {
	return WrapWidget(gextras.InternObject(w)).GetTooltipText()
}

func (w window) GetVAlign() Align {
	return WrapWidget(gextras.InternObject(w)).GetVAlign()
}

func (w window) GetVExpand() bool {
	return WrapWidget(gextras.InternObject(w)).GetVExpand()
}

func (w window) GetVExpandSet() bool {
	return WrapWidget(gextras.InternObject(w)).GetVExpandSet()
}

func (w window) GetVisible() bool {
	return WrapWidget(gextras.InternObject(w)).GetVisible()
}

func (w window) GetWidth() int {
	return WrapWidget(gextras.InternObject(w)).GetWidth()
}

func (w window) GrabFocus() bool {
	return WrapWidget(gextras.InternObject(w)).GrabFocus()
}

func (w window) HasCSSClass(cssClass string) bool {
	return WrapWidget(gextras.InternObject(w)).HasCSSClass(cssClass)
}

func (w window) HasDefault() bool {
	return WrapWidget(gextras.InternObject(w)).HasDefault()
}

func (w window) HasFocus() bool {
	return WrapWidget(gextras.InternObject(w)).HasFocus()
}

func (w window) HasVisibleFocus() bool {
	return WrapWidget(gextras.InternObject(w)).HasVisibleFocus()
}

func (w window) Hide() {
	WrapWidget(gextras.InternObject(w)).Hide()
}

func (w window) InDestruction() bool {
	return WrapWidget(gextras.InternObject(w)).InDestruction()
}

func (w window) InitTemplate() {
	WrapWidget(gextras.InternObject(w)).InitTemplate()
}

func (w window) InsertAfter(parent Widget, previousSibling Widget) {
	WrapWidget(gextras.InternObject(w)).InsertAfter(parent, previousSibling)
}

func (w window) InsertBefore(parent Widget, nextSibling Widget) {
	WrapWidget(gextras.InternObject(w)).InsertBefore(parent, nextSibling)
}

func (w window) IsAncestor(ancestor Widget) bool {
	return WrapWidget(gextras.InternObject(w)).IsAncestor(ancestor)
}

func (w window) IsDrawable() bool {
	return WrapWidget(gextras.InternObject(w)).IsDrawable()
}

func (w window) IsFocus() bool {
	return WrapWidget(gextras.InternObject(w)).IsFocus()
}

func (w window) IsSensitive() bool {
	return WrapWidget(gextras.InternObject(w)).IsSensitive()
}

func (w window) IsVisible() bool {
	return WrapWidget(gextras.InternObject(w)).IsVisible()
}

func (w window) KeynavFailed(direction DirectionType) bool {
	return WrapWidget(gextras.InternObject(w)).KeynavFailed(direction)
}

func (w window) Map() {
	WrapWidget(gextras.InternObject(w)).Map()
}

func (w window) Measure(orientation Orientation, forSize int) (minimum int, natural int, minimumBaseline int, naturalBaseline int) {
	return WrapWidget(gextras.InternObject(w)).Measure(orientation, forSize)
}

func (w window) MnemonicActivate(groupCycling bool) bool {
	return WrapWidget(gextras.InternObject(w)).MnemonicActivate(groupCycling)
}

func (w window) Pick(x float64, y float64, flags PickFlags) Widget {
	return WrapWidget(gextras.InternObject(w)).Pick(x, y, flags)
}

func (w window) QueueAllocate() {
	WrapWidget(gextras.InternObject(w)).QueueAllocate()
}

func (w window) QueueDraw() {
	WrapWidget(gextras.InternObject(w)).QueueDraw()
}

func (w window) QueueResize() {
	WrapWidget(gextras.InternObject(w)).QueueResize()
}

func (w window) Realize() {
	WrapWidget(gextras.InternObject(w)).Realize()
}

func (w window) RemoveController(controller EventController) {
	WrapWidget(gextras.InternObject(w)).RemoveController(controller)
}

func (w window) RemoveCSSClass(cssClass string) {
	WrapWidget(gextras.InternObject(w)).RemoveCSSClass(cssClass)
}

func (w window) RemoveMnemonicLabel(label Widget) {
	WrapWidget(gextras.InternObject(w)).RemoveMnemonicLabel(label)
}

func (w window) RemoveTickCallback(id uint) {
	WrapWidget(gextras.InternObject(w)).RemoveTickCallback(id)
}

func (w window) SetCanFocus(canFocus bool) {
	WrapWidget(gextras.InternObject(w)).SetCanFocus(canFocus)
}

func (w window) SetCanTarget(canTarget bool) {
	WrapWidget(gextras.InternObject(w)).SetCanTarget(canTarget)
}

func (w window) SetChildVisible(childVisible bool) {
	WrapWidget(gextras.InternObject(w)).SetChildVisible(childVisible)
}

func (w window) SetCSSClasses(classes []string) {
	WrapWidget(gextras.InternObject(w)).SetCSSClasses(classes)
}

func (w window) SetCursor(cursor gdk.Cursor) {
	WrapWidget(gextras.InternObject(w)).SetCursor(cursor)
}

func (w window) SetCursorFromName(name string) {
	WrapWidget(gextras.InternObject(w)).SetCursorFromName(name)
}

func (w window) SetDirection(dir TextDirection) {
	WrapWidget(gextras.InternObject(w)).SetDirection(dir)
}

func (w window) SetFocusChild(child Widget) {
	WrapWidget(gextras.InternObject(w)).SetFocusChild(child)
}

func (w window) SetFocusOnClick(focusOnClick bool) {
	WrapWidget(gextras.InternObject(w)).SetFocusOnClick(focusOnClick)
}

func (w window) SetFocusable(focusable bool) {
	WrapWidget(gextras.InternObject(w)).SetFocusable(focusable)
}

func (w window) SetFontMap(fontMap pango.FontMap) {
	WrapWidget(gextras.InternObject(w)).SetFontMap(fontMap)
}

func (w window) SetFontOptions(options *cairo.FontOptions) {
	WrapWidget(gextras.InternObject(w)).SetFontOptions(options)
}

func (w window) SetHAlign(align Align) {
	WrapWidget(gextras.InternObject(w)).SetHAlign(align)
}

func (w window) SetHasTooltip(hasTooltip bool) {
	WrapWidget(gextras.InternObject(w)).SetHasTooltip(hasTooltip)
}

func (w window) SetHExpand(expand bool) {
	WrapWidget(gextras.InternObject(w)).SetHExpand(expand)
}

func (w window) SetHExpandSet(set bool) {
	WrapWidget(gextras.InternObject(w)).SetHExpandSet(set)
}

func (w window) SetLayoutManager(layoutManager LayoutManager) {
	WrapWidget(gextras.InternObject(w)).SetLayoutManager(layoutManager)
}

func (w window) SetMarginBottom(margin int) {
	WrapWidget(gextras.InternObject(w)).SetMarginBottom(margin)
}

func (w window) SetMarginEnd(margin int) {
	WrapWidget(gextras.InternObject(w)).SetMarginEnd(margin)
}

func (w window) SetMarginStart(margin int) {
	WrapWidget(gextras.InternObject(w)).SetMarginStart(margin)
}

func (w window) SetMarginTop(margin int) {
	WrapWidget(gextras.InternObject(w)).SetMarginTop(margin)
}

func (w window) SetName(name string) {
	WrapWidget(gextras.InternObject(w)).SetName(name)
}

func (w window) SetOpacity(opacity float64) {
	WrapWidget(gextras.InternObject(w)).SetOpacity(opacity)
}

func (w window) SetOverflow(overflow Overflow) {
	WrapWidget(gextras.InternObject(w)).SetOverflow(overflow)
}

func (w window) SetParent(parent Widget) {
	WrapWidget(gextras.InternObject(w)).SetParent(parent)
}

func (w window) SetReceivesDefault(receivesDefault bool) {
	WrapWidget(gextras.InternObject(w)).SetReceivesDefault(receivesDefault)
}

func (w window) SetSensitive(sensitive bool) {
	WrapWidget(gextras.InternObject(w)).SetSensitive(sensitive)
}

func (w window) SetSizeRequest(width int, height int) {
	WrapWidget(gextras.InternObject(w)).SetSizeRequest(width, height)
}

func (w window) SetStateFlags(flags StateFlags, clear bool) {
	WrapWidget(gextras.InternObject(w)).SetStateFlags(flags, clear)
}

func (w window) SetTooltipMarkup(markup string) {
	WrapWidget(gextras.InternObject(w)).SetTooltipMarkup(markup)
}

func (w window) SetTooltipText(text string) {
	WrapWidget(gextras.InternObject(w)).SetTooltipText(text)
}

func (w window) SetVAlign(align Align) {
	WrapWidget(gextras.InternObject(w)).SetVAlign(align)
}

func (w window) SetVExpand(expand bool) {
	WrapWidget(gextras.InternObject(w)).SetVExpand(expand)
}

func (w window) SetVExpandSet(set bool) {
	WrapWidget(gextras.InternObject(w)).SetVExpandSet(set)
}

func (w window) SetVisible(visible bool) {
	WrapWidget(gextras.InternObject(w)).SetVisible(visible)
}

func (w window) ShouldLayout() bool {
	return WrapWidget(gextras.InternObject(w)).ShouldLayout()
}

func (w window) Show() {
	WrapWidget(gextras.InternObject(w)).Show()
}

func (w window) SnapshotChild(child Widget, snapshot Snapshot) {
	WrapWidget(gextras.InternObject(w)).SnapshotChild(child, snapshot)
}

func (s window) TranslateCoordinates(destWidget Widget, srcX float64, srcY float64) (destX float64, destY float64, ok bool) {
	return WrapWidget(gextras.InternObject(s)).TranslateCoordinates(destWidget, srcX, srcY)
}

func (w window) TriggerTooltipQuery() {
	WrapWidget(gextras.InternObject(w)).TriggerTooltipQuery()
}

func (w window) Unmap() {
	WrapWidget(gextras.InternObject(w)).Unmap()
}

func (w window) Unparent() {
	WrapWidget(gextras.InternObject(w)).Unparent()
}

func (w window) Unrealize() {
	WrapWidget(gextras.InternObject(w)).Unrealize()
}

func (w window) UnsetStateFlags(flags StateFlags) {
	WrapWidget(gextras.InternObject(w)).UnsetStateFlags(flags)
}

func (s window) GetAccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).GetAccessibleRole()
}

func (s window) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s window) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s window) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s window) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s window) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s window) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b window) GetBuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).GetBuildableID()
}

func (w window) ActionSetEnabled(actionName string, enabled bool) {
	WrapWidget(gextras.InternObject(w)).ActionSetEnabled(actionName, enabled)
}

func (w window) Activate() bool {
	return WrapWidget(gextras.InternObject(w)).Activate()
}

func (w window) ActivateActionVariant(name string, args *glib.Variant) bool {
	return WrapWidget(gextras.InternObject(w)).ActivateActionVariant(name, args)
}

func (w window) ActivateDefault() {
	WrapWidget(gextras.InternObject(w)).ActivateDefault()
}

func (w window) AddController(controller EventController) {
	WrapWidget(gextras.InternObject(w)).AddController(controller)
}

func (w window) AddCSSClass(cssClass string) {
	WrapWidget(gextras.InternObject(w)).AddCSSClass(cssClass)
}

func (w window) AddMnemonicLabel(label Widget) {
	WrapWidget(gextras.InternObject(w)).AddMnemonicLabel(label)
}

func (w window) Allocate(width int, height int, baseline int, transform *gsk.Transform) {
	WrapWidget(gextras.InternObject(w)).Allocate(width, height, baseline, transform)
}

func (w window) ChildFocus(direction DirectionType) bool {
	return WrapWidget(gextras.InternObject(w)).ChildFocus(direction)
}

func (w window) ComputeBounds(target Widget) (graphene.Rect, bool) {
	return WrapWidget(gextras.InternObject(w)).ComputeBounds(target)
}

func (w window) ComputeExpand(orientation Orientation) bool {
	return WrapWidget(gextras.InternObject(w)).ComputeExpand(orientation)
}

func (w window) ComputePoint(target Widget, point *graphene.Point) (graphene.Point, bool) {
	return WrapWidget(gextras.InternObject(w)).ComputePoint(target, point)
}

func (w window) ComputeTransform(target Widget) (graphene.Matrix, bool) {
	return WrapWidget(gextras.InternObject(w)).ComputeTransform(target)
}

func (w window) Contains(x float64, y float64) bool {
	return WrapWidget(gextras.InternObject(w)).Contains(x, y)
}

func (w window) CreatePangoContext() pango.Context {
	return WrapWidget(gextras.InternObject(w)).CreatePangoContext()
}

func (w window) CreatePangoLayout(text string) pango.Layout {
	return WrapWidget(gextras.InternObject(w)).CreatePangoLayout(text)
}

func (w window) DragCheckThreshold(startX int, startY int, currentX int, currentY int) bool {
	return WrapWidget(gextras.InternObject(w)).DragCheckThreshold(startX, startY, currentX, currentY)
}

func (w window) ErrorBell() {
	WrapWidget(gextras.InternObject(w)).ErrorBell()
}

func (w window) GetAllocatedBaseline() int {
	return WrapWidget(gextras.InternObject(w)).GetAllocatedBaseline()
}

func (w window) GetAllocatedHeight() int {
	return WrapWidget(gextras.InternObject(w)).GetAllocatedHeight()
}

func (w window) GetAllocatedWidth() int {
	return WrapWidget(gextras.InternObject(w)).GetAllocatedWidth()
}

func (w window) GetAncestor(widgetType externglib.Type) Widget {
	return WrapWidget(gextras.InternObject(w)).GetAncestor(widgetType)
}

func (w window) GetCanFocus() bool {
	return WrapWidget(gextras.InternObject(w)).GetCanFocus()
}

func (w window) GetCanTarget() bool {
	return WrapWidget(gextras.InternObject(w)).GetCanTarget()
}

func (w window) GetChildVisible() bool {
	return WrapWidget(gextras.InternObject(w)).GetChildVisible()
}

func (w window) GetClipboard() gdk.Clipboard {
	return WrapWidget(gextras.InternObject(w)).GetClipboard()
}

func (w window) GetCSSClasses() []string {
	return WrapWidget(gextras.InternObject(w)).GetCSSClasses()
}

func (s window) GetCSSName() string {
	return WrapWidget(gextras.InternObject(s)).GetCSSName()
}

func (w window) GetCursor() gdk.Cursor {
	return WrapWidget(gextras.InternObject(w)).GetCursor()
}

func (w window) GetDirection() TextDirection {
	return WrapWidget(gextras.InternObject(w)).GetDirection()
}

func (w window) GetDisplay() gdk.Display {
	return WrapWidget(gextras.InternObject(w)).GetDisplay()
}

func (w window) GetFirstChild() Widget {
	return WrapWidget(gextras.InternObject(w)).GetFirstChild()
}

func (w window) GetFocusChild() Widget {
	return WrapWidget(gextras.InternObject(w)).GetFocusChild()
}

func (w window) GetFocusOnClick() bool {
	return WrapWidget(gextras.InternObject(w)).GetFocusOnClick()
}

func (w window) GetFocusable() bool {
	return WrapWidget(gextras.InternObject(w)).GetFocusable()
}

func (w window) GetFontMap() pango.FontMap {
	return WrapWidget(gextras.InternObject(w)).GetFontMap()
}

func (w window) GetFontOptions() *cairo.FontOptions {
	return WrapWidget(gextras.InternObject(w)).GetFontOptions()
}

func (w window) GetFrameClock() gdk.FrameClock {
	return WrapWidget(gextras.InternObject(w)).GetFrameClock()
}

func (w window) GetHAlign() Align {
	return WrapWidget(gextras.InternObject(w)).GetHAlign()
}

func (w window) GetHasTooltip() bool {
	return WrapWidget(gextras.InternObject(w)).GetHasTooltip()
}

func (w window) GetHeight() int {
	return WrapWidget(gextras.InternObject(w)).GetHeight()
}

func (w window) GetHExpand() bool {
	return WrapWidget(gextras.InternObject(w)).GetHExpand()
}

func (w window) GetHExpandSet() bool {
	return WrapWidget(gextras.InternObject(w)).GetHExpandSet()
}

func (w window) GetLastChild() Widget {
	return WrapWidget(gextras.InternObject(w)).GetLastChild()
}

func (w window) GetLayoutManager() LayoutManager {
	return WrapWidget(gextras.InternObject(w)).GetLayoutManager()
}

func (w window) GetMapped() bool {
	return WrapWidget(gextras.InternObject(w)).GetMapped()
}

func (w window) GetMarginBottom() int {
	return WrapWidget(gextras.InternObject(w)).GetMarginBottom()
}

func (w window) GetMarginEnd() int {
	return WrapWidget(gextras.InternObject(w)).GetMarginEnd()
}

func (w window) GetMarginStart() int {
	return WrapWidget(gextras.InternObject(w)).GetMarginStart()
}

func (w window) GetMarginTop() int {
	return WrapWidget(gextras.InternObject(w)).GetMarginTop()
}

func (w window) GetName() string {
	return WrapWidget(gextras.InternObject(w)).GetName()
}

func (w window) GetNative() Native {
	return WrapWidget(gextras.InternObject(w)).GetNative()
}

func (w window) GetNextSibling() Widget {
	return WrapWidget(gextras.InternObject(w)).GetNextSibling()
}

func (w window) GetOpacity() float64 {
	return WrapWidget(gextras.InternObject(w)).GetOpacity()
}

func (w window) GetOverflow() Overflow {
	return WrapWidget(gextras.InternObject(w)).GetOverflow()
}

func (w window) GetPangoContext() pango.Context {
	return WrapWidget(gextras.InternObject(w)).GetPangoContext()
}

func (w window) GetParent() Widget {
	return WrapWidget(gextras.InternObject(w)).GetParent()
}

func (w window) GetPreferredSize() (minimumSize Requisition, naturalSize Requisition) {
	return WrapWidget(gextras.InternObject(w)).GetPreferredSize()
}

func (w window) GetPrevSibling() Widget {
	return WrapWidget(gextras.InternObject(w)).GetPrevSibling()
}

func (w window) GetPrimaryClipboard() gdk.Clipboard {
	return WrapWidget(gextras.InternObject(w)).GetPrimaryClipboard()
}

func (w window) GetRealized() bool {
	return WrapWidget(gextras.InternObject(w)).GetRealized()
}

func (w window) GetReceivesDefault() bool {
	return WrapWidget(gextras.InternObject(w)).GetReceivesDefault()
}

func (w window) GetRequestMode() SizeRequestMode {
	return WrapWidget(gextras.InternObject(w)).GetRequestMode()
}

func (w window) GetRoot() Root {
	return WrapWidget(gextras.InternObject(w)).GetRoot()
}

func (w window) GetScaleFactor() int {
	return WrapWidget(gextras.InternObject(w)).GetScaleFactor()
}

func (w window) GetSensitive() bool {
	return WrapWidget(gextras.InternObject(w)).GetSensitive()
}

func (w window) GetSettings() Settings {
	return WrapWidget(gextras.InternObject(w)).GetSettings()
}

func (w window) GetSize(orientation Orientation) int {
	return WrapWidget(gextras.InternObject(w)).GetSize(orientation)
}

func (w window) GetSizeRequest() (width int, height int) {
	return WrapWidget(gextras.InternObject(w)).GetSizeRequest()
}

func (w window) GetStateFlags() StateFlags {
	return WrapWidget(gextras.InternObject(w)).GetStateFlags()
}

func (w window) GetStyleContext() StyleContext {
	return WrapWidget(gextras.InternObject(w)).GetStyleContext()
}

func (w window) GetTemplateChild(widgetType externglib.Type, name string) gextras.Objector {
	return WrapWidget(gextras.InternObject(w)).GetTemplateChild(widgetType, name)
}

func (w window) GetTooltipMarkup() string {
	return WrapWidget(gextras.InternObject(w)).GetTooltipMarkup()
}

func (w window) GetTooltipText() string {
	return WrapWidget(gextras.InternObject(w)).GetTooltipText()
}

func (w window) GetVAlign() Align {
	return WrapWidget(gextras.InternObject(w)).GetVAlign()
}

func (w window) GetVExpand() bool {
	return WrapWidget(gextras.InternObject(w)).GetVExpand()
}

func (w window) GetVExpandSet() bool {
	return WrapWidget(gextras.InternObject(w)).GetVExpandSet()
}

func (w window) GetVisible() bool {
	return WrapWidget(gextras.InternObject(w)).GetVisible()
}

func (w window) GetWidth() int {
	return WrapWidget(gextras.InternObject(w)).GetWidth()
}

func (w window) GrabFocus() bool {
	return WrapWidget(gextras.InternObject(w)).GrabFocus()
}

func (w window) HasCSSClass(cssClass string) bool {
	return WrapWidget(gextras.InternObject(w)).HasCSSClass(cssClass)
}

func (w window) HasDefault() bool {
	return WrapWidget(gextras.InternObject(w)).HasDefault()
}

func (w window) HasFocus() bool {
	return WrapWidget(gextras.InternObject(w)).HasFocus()
}

func (w window) HasVisibleFocus() bool {
	return WrapWidget(gextras.InternObject(w)).HasVisibleFocus()
}

func (w window) Hide() {
	WrapWidget(gextras.InternObject(w)).Hide()
}

func (w window) InDestruction() bool {
	return WrapWidget(gextras.InternObject(w)).InDestruction()
}

func (w window) InitTemplate() {
	WrapWidget(gextras.InternObject(w)).InitTemplate()
}

func (w window) InsertAfter(parent Widget, previousSibling Widget) {
	WrapWidget(gextras.InternObject(w)).InsertAfter(parent, previousSibling)
}

func (w window) InsertBefore(parent Widget, nextSibling Widget) {
	WrapWidget(gextras.InternObject(w)).InsertBefore(parent, nextSibling)
}

func (w window) IsAncestor(ancestor Widget) bool {
	return WrapWidget(gextras.InternObject(w)).IsAncestor(ancestor)
}

func (w window) IsDrawable() bool {
	return WrapWidget(gextras.InternObject(w)).IsDrawable()
}

func (w window) IsFocus() bool {
	return WrapWidget(gextras.InternObject(w)).IsFocus()
}

func (w window) IsSensitive() bool {
	return WrapWidget(gextras.InternObject(w)).IsSensitive()
}

func (w window) IsVisible() bool {
	return WrapWidget(gextras.InternObject(w)).IsVisible()
}

func (w window) KeynavFailed(direction DirectionType) bool {
	return WrapWidget(gextras.InternObject(w)).KeynavFailed(direction)
}

func (w window) Map() {
	WrapWidget(gextras.InternObject(w)).Map()
}

func (w window) Measure(orientation Orientation, forSize int) (minimum int, natural int, minimumBaseline int, naturalBaseline int) {
	return WrapWidget(gextras.InternObject(w)).Measure(orientation, forSize)
}

func (w window) MnemonicActivate(groupCycling bool) bool {
	return WrapWidget(gextras.InternObject(w)).MnemonicActivate(groupCycling)
}

func (w window) Pick(x float64, y float64, flags PickFlags) Widget {
	return WrapWidget(gextras.InternObject(w)).Pick(x, y, flags)
}

func (w window) QueueAllocate() {
	WrapWidget(gextras.InternObject(w)).QueueAllocate()
}

func (w window) QueueDraw() {
	WrapWidget(gextras.InternObject(w)).QueueDraw()
}

func (w window) QueueResize() {
	WrapWidget(gextras.InternObject(w)).QueueResize()
}

func (w window) Realize() {
	WrapWidget(gextras.InternObject(w)).Realize()
}

func (w window) RemoveController(controller EventController) {
	WrapWidget(gextras.InternObject(w)).RemoveController(controller)
}

func (w window) RemoveCSSClass(cssClass string) {
	WrapWidget(gextras.InternObject(w)).RemoveCSSClass(cssClass)
}

func (w window) RemoveMnemonicLabel(label Widget) {
	WrapWidget(gextras.InternObject(w)).RemoveMnemonicLabel(label)
}

func (w window) RemoveTickCallback(id uint) {
	WrapWidget(gextras.InternObject(w)).RemoveTickCallback(id)
}

func (w window) SetCanFocus(canFocus bool) {
	WrapWidget(gextras.InternObject(w)).SetCanFocus(canFocus)
}

func (w window) SetCanTarget(canTarget bool) {
	WrapWidget(gextras.InternObject(w)).SetCanTarget(canTarget)
}

func (w window) SetChildVisible(childVisible bool) {
	WrapWidget(gextras.InternObject(w)).SetChildVisible(childVisible)
}

func (w window) SetCSSClasses(classes []string) {
	WrapWidget(gextras.InternObject(w)).SetCSSClasses(classes)
}

func (w window) SetCursor(cursor gdk.Cursor) {
	WrapWidget(gextras.InternObject(w)).SetCursor(cursor)
}

func (w window) SetCursorFromName(name string) {
	WrapWidget(gextras.InternObject(w)).SetCursorFromName(name)
}

func (w window) SetDirection(dir TextDirection) {
	WrapWidget(gextras.InternObject(w)).SetDirection(dir)
}

func (w window) SetFocusChild(child Widget) {
	WrapWidget(gextras.InternObject(w)).SetFocusChild(child)
}

func (w window) SetFocusOnClick(focusOnClick bool) {
	WrapWidget(gextras.InternObject(w)).SetFocusOnClick(focusOnClick)
}

func (w window) SetFocusable(focusable bool) {
	WrapWidget(gextras.InternObject(w)).SetFocusable(focusable)
}

func (w window) SetFontMap(fontMap pango.FontMap) {
	WrapWidget(gextras.InternObject(w)).SetFontMap(fontMap)
}

func (w window) SetFontOptions(options *cairo.FontOptions) {
	WrapWidget(gextras.InternObject(w)).SetFontOptions(options)
}

func (w window) SetHAlign(align Align) {
	WrapWidget(gextras.InternObject(w)).SetHAlign(align)
}

func (w window) SetHasTooltip(hasTooltip bool) {
	WrapWidget(gextras.InternObject(w)).SetHasTooltip(hasTooltip)
}

func (w window) SetHExpand(expand bool) {
	WrapWidget(gextras.InternObject(w)).SetHExpand(expand)
}

func (w window) SetHExpandSet(set bool) {
	WrapWidget(gextras.InternObject(w)).SetHExpandSet(set)
}

func (w window) SetLayoutManager(layoutManager LayoutManager) {
	WrapWidget(gextras.InternObject(w)).SetLayoutManager(layoutManager)
}

func (w window) SetMarginBottom(margin int) {
	WrapWidget(gextras.InternObject(w)).SetMarginBottom(margin)
}

func (w window) SetMarginEnd(margin int) {
	WrapWidget(gextras.InternObject(w)).SetMarginEnd(margin)
}

func (w window) SetMarginStart(margin int) {
	WrapWidget(gextras.InternObject(w)).SetMarginStart(margin)
}

func (w window) SetMarginTop(margin int) {
	WrapWidget(gextras.InternObject(w)).SetMarginTop(margin)
}

func (w window) SetName(name string) {
	WrapWidget(gextras.InternObject(w)).SetName(name)
}

func (w window) SetOpacity(opacity float64) {
	WrapWidget(gextras.InternObject(w)).SetOpacity(opacity)
}

func (w window) SetOverflow(overflow Overflow) {
	WrapWidget(gextras.InternObject(w)).SetOverflow(overflow)
}

func (w window) SetParent(parent Widget) {
	WrapWidget(gextras.InternObject(w)).SetParent(parent)
}

func (w window) SetReceivesDefault(receivesDefault bool) {
	WrapWidget(gextras.InternObject(w)).SetReceivesDefault(receivesDefault)
}

func (w window) SetSensitive(sensitive bool) {
	WrapWidget(gextras.InternObject(w)).SetSensitive(sensitive)
}

func (w window) SetSizeRequest(width int, height int) {
	WrapWidget(gextras.InternObject(w)).SetSizeRequest(width, height)
}

func (w window) SetStateFlags(flags StateFlags, clear bool) {
	WrapWidget(gextras.InternObject(w)).SetStateFlags(flags, clear)
}

func (w window) SetTooltipMarkup(markup string) {
	WrapWidget(gextras.InternObject(w)).SetTooltipMarkup(markup)
}

func (w window) SetTooltipText(text string) {
	WrapWidget(gextras.InternObject(w)).SetTooltipText(text)
}

func (w window) SetVAlign(align Align) {
	WrapWidget(gextras.InternObject(w)).SetVAlign(align)
}

func (w window) SetVExpand(expand bool) {
	WrapWidget(gextras.InternObject(w)).SetVExpand(expand)
}

func (w window) SetVExpandSet(set bool) {
	WrapWidget(gextras.InternObject(w)).SetVExpandSet(set)
}

func (w window) SetVisible(visible bool) {
	WrapWidget(gextras.InternObject(w)).SetVisible(visible)
}

func (w window) ShouldLayout() bool {
	return WrapWidget(gextras.InternObject(w)).ShouldLayout()
}

func (w window) Show() {
	WrapWidget(gextras.InternObject(w)).Show()
}

func (w window) SnapshotChild(child Widget, snapshot Snapshot) {
	WrapWidget(gextras.InternObject(w)).SnapshotChild(child, snapshot)
}

func (s window) TranslateCoordinates(destWidget Widget, srcX float64, srcY float64) (destX float64, destY float64, ok bool) {
	return WrapWidget(gextras.InternObject(s)).TranslateCoordinates(destWidget, srcX, srcY)
}

func (w window) TriggerTooltipQuery() {
	WrapWidget(gextras.InternObject(w)).TriggerTooltipQuery()
}

func (w window) Unmap() {
	WrapWidget(gextras.InternObject(w)).Unmap()
}

func (w window) Unparent() {
	WrapWidget(gextras.InternObject(w)).Unparent()
}

func (w window) Unrealize() {
	WrapWidget(gextras.InternObject(w)).Unrealize()
}

func (w window) UnsetStateFlags(flags StateFlags) {
	WrapWidget(gextras.InternObject(w)).UnsetStateFlags(flags)
}

func (s window) GetAccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).GetAccessibleRole()
}

func (s window) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s window) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s window) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s window) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s window) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s window) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b window) GetBuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).GetBuildableID()
}

func (w window) Close() {
	var _arg0 *C.GtkWindow // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	C.gtk_window_close(_arg0)
}

func (w window) Destroy() {
	var _arg0 *C.GtkWindow // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	C.gtk_window_destroy(_arg0)
}

func (w window) Fullscreen() {
	var _arg0 *C.GtkWindow // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	C.gtk_window_fullscreen(_arg0)
}

func (w window) FullscreenOnMonitor(monitor gdk.Monitor) {
	var _arg0 *C.GtkWindow  // out
	var _arg1 *C.GdkMonitor // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GdkMonitor)(unsafe.Pointer(monitor.Native()))

	C.gtk_window_fullscreen_on_monitor(_arg0, _arg1)
}

func (w window) Application() Application {
	var _arg0 *C.GtkWindow      // out
	var _cret *C.GtkApplication // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_window_get_application(_arg0)

	var _application Application // out

	_application = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Application)

	return _application
}

func (w window) Child() Widget {
	var _arg0 *C.GtkWindow // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_window_get_child(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

func (w window) Decorated() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_window_get_decorated(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (w window) DefaultSize() (width int, height int) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.int        // in
	var _arg2 C.int        // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	C.gtk_window_get_default_size(_arg0, &_arg1, &_arg2)

	var _width int  // out
	var _height int // out

	_width = int(_arg1)
	_height = int(_arg2)

	return _width, _height
}

func (w window) DefaultWidget() Widget {
	var _arg0 *C.GtkWindow // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_window_get_default_widget(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

func (w window) Deletable() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_window_get_deletable(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (w window) DestroyWithParent() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_window_get_destroy_with_parent(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (w window) Focus() Widget {
	var _arg0 *C.GtkWindow // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_window_get_focus(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

func (w window) FocusVisible() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_window_get_focus_visible(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (w window) Group() WindowGroup {
	var _arg0 *C.GtkWindow      // out
	var _cret *C.GtkWindowGroup // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_window_get_group(_arg0)

	var _windowGroup WindowGroup // out

	_windowGroup = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(WindowGroup)

	return _windowGroup
}

func (w window) HandleMenubarAccel() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_window_get_handle_menubar_accel(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (w window) HideOnClose() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_window_get_hide_on_close(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (w window) IconName() string {
	var _arg0 *C.GtkWindow // out
	var _cret *C.char      // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_window_get_icon_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (w window) MnemonicsVisible() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_window_get_mnemonics_visible(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (w window) Modal() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_window_get_modal(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (w window) Resizable() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_window_get_resizable(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (w window) Title() string {
	var _arg0 *C.GtkWindow // out
	var _cret *C.char      // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_window_get_title(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (w window) Titlebar() Widget {
	var _arg0 *C.GtkWindow // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_window_get_titlebar(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

func (w window) TransientFor() Window {
	var _arg0 *C.GtkWindow // out
	var _cret *C.GtkWindow // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_window_get_transient_for(_arg0)

	var _ret Window // out

	_ret = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Window)

	return _ret
}

func (w window) HasGroup() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_window_has_group(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (w window) IsActive() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_window_is_active(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (w window) IsFullscreen() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_window_is_fullscreen(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (w window) IsMaximized() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	_cret = C.gtk_window_is_maximized(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (w window) Maximize() {
	var _arg0 *C.GtkWindow // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	C.gtk_window_maximize(_arg0)
}

func (w window) Minimize() {
	var _arg0 *C.GtkWindow // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	C.gtk_window_minimize(_arg0)
}

func (w window) Present() {
	var _arg0 *C.GtkWindow // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	C.gtk_window_present(_arg0)
}

func (w window) PresentWithTime(timestamp uint32) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.guint32    // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	_arg1 = C.guint32(timestamp)

	C.gtk_window_present_with_time(_arg0, _arg1)
}

func (w window) SetApplication(application Application) {
	var _arg0 *C.GtkWindow      // out
	var _arg1 *C.GtkApplication // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GtkApplication)(unsafe.Pointer(application.Native()))

	C.gtk_window_set_application(_arg0, _arg1)
}

func (w window) SetChild(child Widget) {
	var _arg0 *C.GtkWindow // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_window_set_child(_arg0, _arg1)
}

func (w window) SetDecorated(setting bool) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_decorated(_arg0, _arg1)
}

func (w window) SetDefaultSize(width int, height int) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.int        // out
	var _arg2 C.int        // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	_arg1 = C.int(width)
	_arg2 = C.int(height)

	C.gtk_window_set_default_size(_arg0, _arg1, _arg2)
}

func (w window) SetDefaultWidget(defaultWidget Widget) {
	var _arg0 *C.GtkWindow // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(defaultWidget.Native()))

	C.gtk_window_set_default_widget(_arg0, _arg1)
}

func (w window) SetDeletable(setting bool) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_deletable(_arg0, _arg1)
}

func (w window) SetDestroyWithParent(setting bool) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_destroy_with_parent(_arg0, _arg1)
}

func (w window) SetDisplay(display gdk.Display) {
	var _arg0 *C.GtkWindow  // out
	var _arg1 *C.GdkDisplay // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GdkDisplay)(unsafe.Pointer(display.Native()))

	C.gtk_window_set_display(_arg0, _arg1)
}

func (w window) SetFocus(focus Widget) {
	var _arg0 *C.GtkWindow // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(focus.Native()))

	C.gtk_window_set_focus(_arg0, _arg1)
}

func (w window) SetFocusVisible(setting bool) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_focus_visible(_arg0, _arg1)
}

func (w window) SetHandleMenubarAccel(handleMenubarAccel bool) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	if handleMenubarAccel {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_handle_menubar_accel(_arg0, _arg1)
}

func (w window) SetHideOnClose(setting bool) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_hide_on_close(_arg0, _arg1)
}

func (w window) SetIconName(name string) {
	var _arg0 *C.GtkWindow // out
	var _arg1 *C.char      // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_window_set_icon_name(_arg0, _arg1)
}

func (w window) SetMnemonicsVisible(setting bool) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_mnemonics_visible(_arg0, _arg1)
}

func (w window) SetModal(modal bool) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	if modal {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_modal(_arg0, _arg1)
}

func (w window) SetResizable(resizable bool) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	if resizable {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_resizable(_arg0, _arg1)
}

func (w window) SetStartupID(startupId string) {
	var _arg0 *C.GtkWindow // out
	var _arg1 *C.char      // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.char)(C.CString(startupId))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_window_set_startup_id(_arg0, _arg1)
}

func (w window) SetTitle(title string) {
	var _arg0 *C.GtkWindow // out
	var _arg1 *C.char      // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.char)(C.CString(title))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_window_set_title(_arg0, _arg1)
}

func (w window) SetTitlebar(titlebar Widget) {
	var _arg0 *C.GtkWindow // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(titlebar.Native()))

	C.gtk_window_set_titlebar(_arg0, _arg1)
}

func (w window) SetTransientFor(parent Window) {
	var _arg0 *C.GtkWindow // out
	var _arg1 *C.GtkWindow // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
	_arg1 = (*C.GtkWindow)(unsafe.Pointer(parent.Native()))

	C.gtk_window_set_transient_for(_arg0, _arg1)
}

func (w window) Unfullscreen() {
	var _arg0 *C.GtkWindow // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	C.gtk_window_unfullscreen(_arg0)
}

func (w window) Unmaximize() {
	var _arg0 *C.GtkWindow // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	C.gtk_window_unmaximize(_arg0)
}

func (w window) Unminimize() {
	var _arg0 *C.GtkWindow // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

	C.gtk_window_unminimize(_arg0)
}
