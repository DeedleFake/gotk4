// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"github.com/diamondburned/gotk4/pkg/gdk/v4"
	"github.com/diamondburned/gotk4/pkg/gobject/v2"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config:
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <gtk/gtk.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_accessible_autocomplete_get_type()), F: marshalAccessibleAutocomplete},
		{T: externglib.Type(C.gtk_accessible_invalid_state_get_type()), F: marshalAccessibleInvalidState},
		{T: externglib.Type(C.gtk_accessible_property_get_type()), F: marshalAccessibleProperty},
		{T: externglib.Type(C.gtk_accessible_relation_get_type()), F: marshalAccessibleRelation},
		{T: externglib.Type(C.gtk_accessible_role_get_type()), F: marshalAccessibleRole},
		{T: externglib.Type(C.gtk_accessible_sort_get_type()), F: marshalAccessibleSort},
		{T: externglib.Type(C.gtk_accessible_state_get_type()), F: marshalAccessibleState},
		{T: externglib.Type(C.gtk_accessible_tristate_get_type()), F: marshalAccessibleTristate},
		{T: externglib.Type(C.gtk_align_get_type()), F: marshalAlign},
		{T: externglib.Type(C.gtk_arrow_type_get_type()), F: marshalArrowType},
		{T: externglib.Type(C.gtk_assistant_page_type_get_type()), F: marshalAssistantPageType},
		{T: externglib.Type(C.gtk_baseline_position_get_type()), F: marshalBaselinePosition},
		{T: externglib.Type(C.gtk_border_style_get_type()), F: marshalBorderStyle},
		{T: externglib.Type(C.gtk_builder_error_get_type()), F: marshalBuilderError},
		{T: externglib.Type(C.gtk_buttons_type_get_type()), F: marshalButtonsType},
		{T: externglib.Type(C.gtk_cell_renderer_accel_mode_get_type()), F: marshalCellRendererAccelMode},
		{T: externglib.Type(C.gtk_cell_renderer_mode_get_type()), F: marshalCellRendererMode},
		{T: externglib.Type(C.gtk_constraint_attribute_get_type()), F: marshalConstraintAttribute},
		{T: externglib.Type(C.gtk_constraint_relation_get_type()), F: marshalConstraintRelation},
		{T: externglib.Type(C.gtk_constraint_strength_get_type()), F: marshalConstraintStrength},
		{T: externglib.Type(C.gtk_constraint_vfl_parser_error_get_type()), F: marshalConstraintVflParserError},
		{T: externglib.Type(C.gtk_corner_type_get_type()), F: marshalCornerType},
		{T: externglib.Type(C.gtk_delete_type_get_type()), F: marshalDeleteType},
		{T: externglib.Type(C.gtk_direction_type_get_type()), F: marshalDirectionType},
		{T: externglib.Type(C.gtk_editable_properties_get_type()), F: marshalEditableProperties},
		{T: externglib.Type(C.gtk_entry_icon_position_get_type()), F: marshalEntryIconPosition},
		{T: externglib.Type(C.gtk_event_sequence_state_get_type()), F: marshalEventSequenceState},
		{T: externglib.Type(C.gtk_file_chooser_action_get_type()), F: marshalFileChooserAction},
		{T: externglib.Type(C.gtk_file_chooser_error_get_type()), F: marshalFileChooserError},
		{T: externglib.Type(C.gtk_filter_change_get_type()), F: marshalFilterChange},
		{T: externglib.Type(C.gtk_filter_match_get_type()), F: marshalFilterMatch},
		{T: externglib.Type(C.gtk_icon_size_get_type()), F: marshalIconSize},
		{T: externglib.Type(C.gtk_icon_theme_error_get_type()), F: marshalIconThemeError},
		{T: externglib.Type(C.gtk_icon_view_drop_position_get_type()), F: marshalIconViewDropPosition},
		{T: externglib.Type(C.gtk_image_type_get_type()), F: marshalImageType},
		{T: externglib.Type(C.gtk_input_purpose_get_type()), F: marshalInputPurpose},
		{T: externglib.Type(C.gtk_justification_get_type()), F: marshalJustification},
		{T: externglib.Type(C.gtk_level_bar_mode_get_type()), F: marshalLevelBarMode},
		{T: externglib.Type(C.gtk_license_get_type()), F: marshalLicense},
		{T: externglib.Type(C.gtk_message_type_get_type()), F: marshalMessageType},
		{T: externglib.Type(C.gtk_movement_step_get_type()), F: marshalMovementStep},
		{T: externglib.Type(C.gtk_notebook_tab_get_type()), F: marshalNotebookTab},
		{T: externglib.Type(C.gtk_number_up_layout_get_type()), F: marshalNumberUpLayout},
		{T: externglib.Type(C.gtk_ordering_get_type()), F: marshalOrdering},
		{T: externglib.Type(C.gtk_orientation_get_type()), F: marshalOrientation},
		{T: externglib.Type(C.gtk_overflow_get_type()), F: marshalOverflow},
		{T: externglib.Type(C.gtk_pack_type_get_type()), F: marshalPackType},
		{T: externglib.Type(C.gtk_pad_action_type_get_type()), F: marshalPadActionType},
		{T: externglib.Type(C.gtk_page_orientation_get_type()), F: marshalPageOrientation},
		{T: externglib.Type(C.gtk_page_set_get_type()), F: marshalPageSet},
		{T: externglib.Type(C.gtk_pan_direction_get_type()), F: marshalPanDirection},
		{T: externglib.Type(C.gtk_policy_type_get_type()), F: marshalPolicyType},
		{T: externglib.Type(C.gtk_position_type_get_type()), F: marshalPositionType},
		{T: externglib.Type(C.gtk_print_duplex_get_type()), F: marshalPrintDuplex},
		{T: externglib.Type(C.gtk_print_error_get_type()), F: marshalPrintError},
		{T: externglib.Type(C.gtk_print_operation_action_get_type()), F: marshalPrintOperationAction},
		{T: externglib.Type(C.gtk_print_operation_result_get_type()), F: marshalPrintOperationResult},
		{T: externglib.Type(C.gtk_print_pages_get_type()), F: marshalPrintPages},
		{T: externglib.Type(C.gtk_print_quality_get_type()), F: marshalPrintQuality},
		{T: externglib.Type(C.gtk_print_status_get_type()), F: marshalPrintStatus},
		{T: externglib.Type(C.gtk_propagation_limit_get_type()), F: marshalPropagationLimit},
		{T: externglib.Type(C.gtk_propagation_phase_get_type()), F: marshalPropagationPhase},
		{T: externglib.Type(C.gtk_recent_manager_error_get_type()), F: marshalRecentManagerError},
		{T: externglib.Type(C.gtk_response_type_get_type()), F: marshalResponseType},
		{T: externglib.Type(C.gtk_revealer_transition_type_get_type()), F: marshalRevealerTransitionType},
		{T: externglib.Type(C.gtk_scroll_step_get_type()), F: marshalScrollStep},
		{T: externglib.Type(C.gtk_scroll_type_get_type()), F: marshalScrollType},
		{T: externglib.Type(C.gtk_scrollable_policy_get_type()), F: marshalScrollablePolicy},
		{T: externglib.Type(C.gtk_selection_mode_get_type()), F: marshalSelectionMode},
		{T: externglib.Type(C.gtk_sensitivity_type_get_type()), F: marshalSensitivityType},
		{T: externglib.Type(C.gtk_shortcut_scope_get_type()), F: marshalShortcutScope},
		{T: externglib.Type(C.gtk_shortcut_type_get_type()), F: marshalShortcutType},
		{T: externglib.Type(C.gtk_size_group_mode_get_type()), F: marshalSizeGroupMode},
		{T: externglib.Type(C.gtk_size_request_mode_get_type()), F: marshalSizeRequestMode},
		{T: externglib.Type(C.gtk_sort_type_get_type()), F: marshalSortType},
		{T: externglib.Type(C.gtk_sorter_change_get_type()), F: marshalSorterChange},
		{T: externglib.Type(C.gtk_sorter_order_get_type()), F: marshalSorterOrder},
		{T: externglib.Type(C.gtk_spin_button_update_policy_get_type()), F: marshalSpinButtonUpdatePolicy},
		{T: externglib.Type(C.gtk_spin_type_get_type()), F: marshalSpinType},
		{T: externglib.Type(C.gtk_stack_transition_type_get_type()), F: marshalStackTransitionType},
		{T: externglib.Type(C.gtk_string_filter_match_mode_get_type()), F: marshalStringFilterMatchMode},
		{T: externglib.Type(C.gtk_system_setting_get_type()), F: marshalSystemSetting},
		{T: externglib.Type(C.gtk_text_direction_get_type()), F: marshalTextDirection},
		{T: externglib.Type(C.gtk_text_extend_selection_get_type()), F: marshalTextExtendSelection},
		{T: externglib.Type(C.gtk_text_view_layer_get_type()), F: marshalTextViewLayer},
		{T: externglib.Type(C.gtk_text_window_type_get_type()), F: marshalTextWindowType},
		{T: externglib.Type(C.gtk_tree_view_column_sizing_get_type()), F: marshalTreeViewColumnSizing},
		{T: externglib.Type(C.gtk_tree_view_drop_position_get_type()), F: marshalTreeViewDropPosition},
		{T: externglib.Type(C.gtk_tree_view_grid_lines_get_type()), F: marshalTreeViewGridLines},
		{T: externglib.Type(C.gtk_unit_get_type()), F: marshalUnit},
		{T: externglib.Type(C.gtk_wrap_mode_get_type()), F: marshalWrapMode},
		{T: externglib.Type(C.gtk_application_inhibit_flags_get_type()), F: marshalApplicationInhibitFlags},
		{T: externglib.Type(C.gtk_builder_closure_flags_get_type()), F: marshalBuilderClosureFlags},
		{T: externglib.Type(C.gtk_cell_renderer_state_get_type()), F: marshalCellRendererState},
		{T: externglib.Type(C.gtk_debug_flags_get_type()), F: marshalDebugFlags},
		{T: externglib.Type(C.gtk_dialog_flags_get_type()), F: marshalDialogFlags},
		{T: externglib.Type(C.gtk_event_controller_scroll_flags_get_type()), F: marshalEventControllerScrollFlags},
		{T: externglib.Type(C.gtk_font_chooser_level_get_type()), F: marshalFontChooserLevel},
		{T: externglib.Type(C.gtk_icon_lookup_flags_get_type()), F: marshalIconLookupFlags},
		{T: externglib.Type(C.gtk_input_hints_get_type()), F: marshalInputHints},
		{T: externglib.Type(C.gtk_pick_flags_get_type()), F: marshalPickFlags},
		{T: externglib.Type(C.gtk_popover_menu_flags_get_type()), F: marshalPopoverMenuFlags},
		{T: externglib.Type(C.gtk_print_capabilities_get_type()), F: marshalPrintCapabilities},
		{T: externglib.Type(C.gtk_shortcut_action_flags_get_type()), F: marshalShortcutActionFlags},
		{T: externglib.Type(C.gtk_state_flags_get_type()), F: marshalStateFlags},
		{T: externglib.Type(C.gtk_style_context_print_flags_get_type()), F: marshalStyleContextPrintFlags},
		{T: externglib.Type(C.gtk_text_search_flags_get_type()), F: marshalTextSearchFlags},
		{T: externglib.Type(C.gtk_tree_model_flags_get_type()), F: marshalTreeModelFlags},
		{T: externglib.Type(C.gtk_app_chooser_get_type()), F: marshalAppChooser},
		{T: externglib.Type(C.gtk_file_chooser_get_type()), F: marshalFileChooser},
		{T: externglib.Type(C.gtk_style_provider_get_type()), F: marshalStyleProvider},
		{T: externglib.Type(C.gtk_about_dialog_get_type()), F: marshalAboutDialog},
		{T: externglib.Type(C.gtk_action_bar_get_type()), F: marshalActionBar},
		{T: externglib.Type(C.gtk_app_chooser_button_get_type()), F: marshalAppChooserButton},
		{T: externglib.Type(C.gtk_app_chooser_dialog_get_type()), F: marshalAppChooserDialog},
		{T: externglib.Type(C.gtk_app_chooser_widget_get_type()), F: marshalAppChooserWidget},
		{T: externglib.Type(C.gtk_aspect_frame_get_type()), F: marshalAspectFrame},
		{T: externglib.Type(C.gtk_assistant_get_type()), F: marshalAssistant},
		{T: externglib.Type(C.gtk_assistant_page_get_type()), F: marshalAssistantPage},
		{T: externglib.Type(C.gtk_calendar_get_type()), F: marshalCalendar},
		{T: externglib.Type(C.gtk_cell_area_box_get_type()), F: marshalCellAreaBox},
		{T: externglib.Type(C.gtk_cell_renderer_accel_get_type()), F: marshalCellRendererAccel},
		{T: externglib.Type(C.gtk_cell_renderer_combo_get_type()), F: marshalCellRendererCombo},
		{T: externglib.Type(C.gtk_cell_renderer_pixbuf_get_type()), F: marshalCellRendererPixbuf},
		{T: externglib.Type(C.gtk_cell_renderer_progress_get_type()), F: marshalCellRendererProgress},
		{T: externglib.Type(C.gtk_cell_renderer_spin_get_type()), F: marshalCellRendererSpin},
		{T: externglib.Type(C.gtk_cell_renderer_spinner_get_type()), F: marshalCellRendererSpinner},
		{T: externglib.Type(C.gtk_cell_renderer_toggle_get_type()), F: marshalCellRendererToggle},
		{T: externglib.Type(C.gtk_cell_view_get_type()), F: marshalCellView},
		{T: externglib.Type(C.gtk_color_button_get_type()), F: marshalColorButton},
		{T: externglib.Type(C.gtk_color_chooser_dialog_get_type()), F: marshalColorChooserDialog},
		{T: externglib.Type(C.gtk_color_chooser_widget_get_type()), F: marshalColorChooserWidget},
		{T: externglib.Type(C.gtk_combo_box_text_get_type()), F: marshalComboBoxText},
		{T: externglib.Type(C.gtk_entry_completion_get_type()), F: marshalEntryCompletion},
		{T: externglib.Type(C.gtk_expander_get_type()), F: marshalExpander},
		{T: externglib.Type(C.gtk_file_chooser_dialog_get_type()), F: marshalFileChooserDialog},
		{T: externglib.Type(C.gtk_file_chooser_widget_get_type()), F: marshalFileChooserWidget},
		{T: externglib.Type(C.gtk_file_filter_get_type()), F: marshalFileFilter},
		{T: externglib.Type(C.gtk_flow_box_get_type()), F: marshalFlowBox},
		{T: externglib.Type(C.gtk_font_button_get_type()), F: marshalFontButton},
		{T: externglib.Type(C.gtk_font_chooser_dialog_get_type()), F: marshalFontChooserDialog},
		{T: externglib.Type(C.gtk_font_chooser_widget_get_type()), F: marshalFontChooserWidget},
		{T: externglib.Type(C.gtk_header_bar_get_type()), F: marshalHeaderBar},
		{T: externglib.Type(C.gtk_icon_paintable_get_type()), F: marshalIconPaintable},
		{T: externglib.Type(C.gtk_icon_theme_get_type()), F: marshalIconTheme},
		{T: externglib.Type(C.gtk_icon_view_get_type()), F: marshalIconView},
		{T: externglib.Type(C.gtk_image_get_type()), F: marshalImage},
		{T: externglib.Type(C.gtk_info_bar_get_type()), F: marshalInfoBar},
		{T: externglib.Type(C.gtk_label_get_type()), F: marshalLabel},
		{T: externglib.Type(C.gtk_level_bar_get_type()), F: marshalLevelBar},
		{T: externglib.Type(C.gtk_link_button_get_type()), F: marshalLinkButton},
		{T: externglib.Type(C.gtk_list_box_get_type()), F: marshalListBox},
		{T: externglib.Type(C.gtk_lock_button_get_type()), F: marshalLockButton},
		{T: externglib.Type(C.gtk_menu_button_get_type()), F: marshalMenuButton},
		{T: externglib.Type(C.gtk_notebook_get_type()), F: marshalNotebook},
		{T: externglib.Type(C.gtk_notebook_page_get_type()), F: marshalNotebookPage},
		{T: externglib.Type(C.gtk_overlay_get_type()), F: marshalOverlay},
		{T: externglib.Type(C.gtk_page_setup_get_type()), F: marshalPageSetup},
		{T: externglib.Type(C.gtk_page_setup_unix_dialog_get_type()), F: marshalPageSetupUnixDialog},
		{T: externglib.Type(C.gtk_paned_get_type()), F: marshalPaned},
		{T: externglib.Type(C.gtk_popover_menu_get_type()), F: marshalPopoverMenu},
		{T: externglib.Type(C.gtk_popover_menu_bar_get_type()), F: marshalPopoverMenuBar},
		{T: externglib.Type(C.gtk_print_context_get_type()), F: marshalPrintContext},
		{T: externglib.Type(C.gtk_print_job_get_type()), F: marshalPrintJob},
		{T: externglib.Type(C.gtk_print_settings_get_type()), F: marshalPrintSettings},
		{T: externglib.Type(C.gtk_print_unix_dialog_get_type()), F: marshalPrintUnixDialog},
		{T: externglib.Type(C.gtk_printer_get_type()), F: marshalPrinter},
		{T: externglib.Type(C.gtk_progress_bar_get_type()), F: marshalProgressBar},
		{T: externglib.Type(C.gtk_revealer_get_type()), F: marshalRevealer},
		{T: externglib.Type(C.gtk_scrollbar_get_type()), F: marshalScrollbar},
		{T: externglib.Type(C.gtk_scrolled_window_get_type()), F: marshalScrolledWindow},
		{T: externglib.Type(C.gtk_search_bar_get_type()), F: marshalSearchBar},
		{T: externglib.Type(C.gtk_search_entry_get_type()), F: marshalSearchEntry},
		{T: externglib.Type(C.gtk_separator_get_type()), F: marshalSeparator},
		{T: externglib.Type(C.gtk_settings_get_type()), F: marshalSettings},
		{T: externglib.Type(C.gtk_shortcuts_window_get_type()), F: marshalShortcutsWindow},
		{T: externglib.Type(C.gtk_size_group_get_type()), F: marshalSizeGroup},
		{T: externglib.Type(C.gtk_spin_button_get_type()), F: marshalSpinButton},
		{T: externglib.Type(C.gtk_spinner_get_type()), F: marshalSpinner},
		{T: externglib.Type(C.gtk_stack_get_type()), F: marshalStack},
		{T: externglib.Type(C.gtk_stack_page_get_type()), F: marshalStackPage},
		{T: externglib.Type(C.gtk_stack_sidebar_get_type()), F: marshalStackSidebar},
		{T: externglib.Type(C.gtk_stack_switcher_get_type()), F: marshalStackSwitcher},
		{T: externglib.Type(C.gtk_statusbar_get_type()), F: marshalStatusbar},
		{T: externglib.Type(C.gtk_switch_get_type()), F: marshalSwitch},
		{T: externglib.Type(C.gtk_text_get_type()), F: marshalText},
		{T: externglib.Type(C.gtk_text_tag_table_get_type()), F: marshalTextTagTable},
		{T: externglib.Type(C.gtk_tooltip_get_type()), F: marshalTooltip},
		{T: externglib.Type(C.gtk_tree_selection_get_type()), F: marshalTreeSelection},
		{T: externglib.Type(C.gtk_tree_view_column_get_type()), F: marshalTreeViewColumn},
		{T: externglib.Type(C.gtk_viewport_get_type()), F: marshalViewport},
		{T: externglib.Type(C.gtk_volume_button_get_type()), F: marshalVolumeButton},
	})
}

// AccessibleAutocomplete: the possible values for the
// GTK_ACCESSIBLE_PROPERTY_AUTOCOMPLETE accessible property.
type AccessibleAutocomplete int

const (
	// AccessibleAutocompleteNone: automatic suggestions are not displayed.
	AccessibleAutocompleteNone AccessibleAutocomplete = 0
	// AccessibleAutocompleteInline: when a user is providing input, text
	// suggesting one way to complete the provided input may be dynamically
	// inserted after the caret.
	AccessibleAutocompleteInline AccessibleAutocomplete = 1
	// AccessibleAutocompleteList: when a user is providing input, an element
	// containing a collection of values that could complete the provided input
	// may be displayed.
	AccessibleAutocompleteList AccessibleAutocomplete = 2
	// AccessibleAutocompleteBoth: when a user is providing input, an element
	// containing a collection of values that could complete the provided input
	// may be displayed. If displayed, one value in the collection is
	// automatically selected, and the text needed to complete the automatically
	// selected value appears after the caret in the input.
	AccessibleAutocompleteBoth AccessibleAutocomplete = 3
)

func marshalAccessibleAutocomplete(p uintptr) (interface{}, error) {
	return AccessibleAutocomplete(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AccessibleInvalidState: the possible values for the
// GTK_ACCESSIBLE_STATE_INVALID accessible state.
//
// Note that the GTK_ACCESSIBLE_INVALID_FALSE and GTK_ACCESSIBLE_INVALID_TRUE
// have the same values as false and true.
type AccessibleInvalidState int

const (
	// AccessibleInvalidStateFalse: there are no detected errors in the value
	AccessibleInvalidStateFalse AccessibleInvalidState = 0
	// AccessibleInvalidStateTrue: the value entered by the user has failed
	// validation
	AccessibleInvalidStateTrue AccessibleInvalidState = 1
	// AccessibleInvalidStateGrammar: a grammatical error was detected
	AccessibleInvalidStateGrammar AccessibleInvalidState = 2
	// AccessibleInvalidStateSpelling: a spelling error was detected
	AccessibleInvalidStateSpelling AccessibleInvalidState = 3
)

func marshalAccessibleInvalidState(p uintptr) (interface{}, error) {
	return AccessibleInvalidState(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AccessibleProperty: the possible accessible properties of a `GtkAccessible`.
type AccessibleProperty int

const (
	// AccessiblePropertyAutocomplete indicates whether inputting text could
	// trigger display of one or more predictions of the user's intended value
	// for a combobox, searchbox, or textbox and specifies how predictions would
	// be presented if they were made. Value type: AccessibleAutocomplete
	AccessiblePropertyAutocomplete AccessibleProperty = 0
	// AccessiblePropertyDescription defines a string value that describes or
	// annotates the current element. Value type: string
	AccessiblePropertyDescription AccessibleProperty = 1
	// AccessiblePropertyHasPopup indicates the availability and type of
	// interactive popup element, such as menu or dialog, that can be triggered
	// by an element.
	AccessiblePropertyHasPopup AccessibleProperty = 2
	// AccessiblePropertyKeyShortcuts indicates keyboard shortcuts that an
	// author has implemented to activate or give focus to an element. Value
	// type: string
	AccessiblePropertyKeyShortcuts AccessibleProperty = 3
	// AccessiblePropertyLabel defines a string value that labels the current
	// element. Value type: string
	AccessiblePropertyLabel AccessibleProperty = 4
	// AccessiblePropertyLevel defines the hierarchical level of an element
	// within a structure. Value type: integer
	AccessiblePropertyLevel AccessibleProperty = 5
	// AccessiblePropertyModal indicates whether an element is modal when
	// displayed. Value type: boolean
	AccessiblePropertyModal AccessibleProperty = 6
	// AccessiblePropertyMultiLine indicates whether a text box accepts multiple
	// lines of input or only a single line. Value type: boolean
	AccessiblePropertyMultiLine AccessibleProperty = 7
	// AccessiblePropertyMultiSelectable indicates that the user may select more
	// than one item from the current selectable descendants. Value type:
	// boolean
	AccessiblePropertyMultiSelectable AccessibleProperty = 8
	// AccessiblePropertyOrientation indicates whether the element's orientation
	// is horizontal, vertical, or unknown/ambiguous. Value type: Orientation
	AccessiblePropertyOrientation AccessibleProperty = 9
	// AccessiblePropertyPlaceholder defines a short hint (a word or short
	// phrase) intended to aid the user with data entry when the control has no
	// value. A hint could be a sample value or a brief description of the
	// expected format. Value type: string
	AccessiblePropertyPlaceholder AccessibleProperty = 10
	// AccessiblePropertyReadOnly indicates that the element is not editable,
	// but is otherwise operable. Value type: boolean
	AccessiblePropertyReadOnly AccessibleProperty = 11
	// AccessiblePropertyRequired indicates that user input is required on the
	// element before a form may be submitted. Value type: boolean
	AccessiblePropertyRequired AccessibleProperty = 12
	// AccessiblePropertyRoleDescription defines a human-readable,
	// author-localized description for the role of an element. Value type:
	// string
	AccessiblePropertyRoleDescription AccessibleProperty = 13
	// AccessiblePropertySort indicates if items in a table or grid are sorted
	// in ascending or descending order. Possible property values are in the
	// AccessibleSort enumeration. Value type: AccessibleSort
	AccessiblePropertySort AccessibleProperty = 14
	// AccessiblePropertyValueMax defines the maximum allowed value for a range
	// widget. Value type: double
	AccessiblePropertyValueMax AccessibleProperty = 15
	// AccessiblePropertyValueMin defines the minimum allowed value for a range
	// widget. Value type: double
	AccessiblePropertyValueMin AccessibleProperty = 16
	// AccessiblePropertyValueNow defines the current value for a range widget.
	// Value type: double
	AccessiblePropertyValueNow AccessibleProperty = 17
	// AccessiblePropertyValueText defines the human readable text alternative
	// of aria-valuenow for a range widget. Value type: string
	AccessiblePropertyValueText AccessibleProperty = 18
)

func marshalAccessibleProperty(p uintptr) (interface{}, error) {
	return AccessibleProperty(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AccessibleRelation: the possible accessible relations of a `GtkAccessible`.
//
// Accessible relations can be references to other widgets, integers or strings.
type AccessibleRelation int

const (
	// AccessibleRelationActiveDescendant identifies the currently active
	// element when focus is on a composite widget, combobox, textbox, group, or
	// application. Value type: reference
	AccessibleRelationActiveDescendant AccessibleRelation = 0
	// AccessibleRelationColCount defines the total number of columns in a
	// table, grid, or treegrid. Value type: integer
	AccessibleRelationColCount AccessibleRelation = 1
	// AccessibleRelationColIndex defines an element's column index or position
	// with respect to the total number of columns within a table, grid, or
	// treegrid. Value type: integer
	AccessibleRelationColIndex AccessibleRelation = 2
	// AccessibleRelationColIndexText defines a human readable text alternative
	// of GTK_ACCESSIBLE_RELATION_COL_INDEX. Value type: string
	AccessibleRelationColIndexText AccessibleRelation = 3
	// AccessibleRelationColSpan defines the number of columns spanned by a cell
	// or gridcell within a table, grid, or treegrid. Value type: integer
	AccessibleRelationColSpan AccessibleRelation = 4
	// AccessibleRelationControls identifies the element (or elements) whose
	// contents or presence are controlled by the current element. Value type:
	// reference
	AccessibleRelationControls AccessibleRelation = 5
	// AccessibleRelationDescribedBy identifies the element (or elements) that
	// describes the object. Value type: reference
	AccessibleRelationDescribedBy AccessibleRelation = 6
	// AccessibleRelationDetails identifies the element (or elements) that
	// provide additional information related to the object. Value type:
	// reference
	AccessibleRelationDetails AccessibleRelation = 7
	// AccessibleRelationErrorMessage identifies the element that provides an
	// error message for an object. Value type: reference
	AccessibleRelationErrorMessage AccessibleRelation = 8
	// AccessibleRelationFlowTo identifies the next element (or elements) in an
	// alternate reading order of content which, at the user's discretion,
	// allows assistive technology to override the general default of reading in
	// document source order. Value type: reference
	AccessibleRelationFlowTo AccessibleRelation = 9
	// AccessibleRelationLabelledBy identifies the element (or elements) that
	// labels the current element. Value type: reference
	AccessibleRelationLabelledBy AccessibleRelation = 10
	// AccessibleRelationOwns identifies an element (or elements) in order to
	// define a visual, functional, or contextual parent/child relationship
	// between elements where the widget hierarchy cannot be used to represent
	// the relationship. Value type: reference
	AccessibleRelationOwns AccessibleRelation = 11
	// AccessibleRelationPosInSet defines an element's number or position in the
	// current set of listitems or treeitems. Value type: integer
	AccessibleRelationPosInSet AccessibleRelation = 12
	// AccessibleRelationRowCount defines the total number of rows in a table,
	// grid, or treegrid. Value type: integer
	AccessibleRelationRowCount AccessibleRelation = 13
	// AccessibleRelationRowIndex defines an element's row index or position
	// with respect to the total number of rows within a table, grid, or
	// treegrid. Value type: integer
	AccessibleRelationRowIndex AccessibleRelation = 14
	// AccessibleRelationRowIndexText defines a human readable text alternative
	// of aria-rowindex. Value type: string
	AccessibleRelationRowIndexText AccessibleRelation = 15
	// AccessibleRelationRowSpan defines the number of rows spanned by a cell or
	// gridcell within a table, grid, or treegrid. Value type: integer
	AccessibleRelationRowSpan AccessibleRelation = 16
	// AccessibleRelationSetSize defines the number of items in the current set
	// of listitems or treeitems. Value type: integer
	AccessibleRelationSetSize AccessibleRelation = 17
)

func marshalAccessibleRelation(p uintptr) (interface{}, error) {
	return AccessibleRelation(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AccessibleRole: the accessible role for a `GtkAccessible` implementation.
//
// Abstract roles are only used as part of the ontology; application developers
// must not use abstract roles in their code.
type AccessibleRole int

const (
	// AccessibleRoleAlert: an element with important, and usually
	// time-sensitive, information
	AccessibleRoleAlert AccessibleRole = 0
	// AccessibleRoleAlertDialog: a type of dialog that contains an alert
	// message
	AccessibleRoleAlertDialog AccessibleRole = 1
	// AccessibleRoleBanner: unused
	AccessibleRoleBanner AccessibleRole = 2
	// AccessibleRoleButton: an input element that allows for user-triggered
	// actions when clicked or pressed
	AccessibleRoleButton AccessibleRole = 3
	// AccessibleRoleCaption: unused
	AccessibleRoleCaption AccessibleRole = 4
	// AccessibleRoleCell: unused
	AccessibleRoleCell AccessibleRole = 5
	// AccessibleRoleCheckbox: a checkable input element that has three possible
	// values: `true`, `false`, or `mixed`
	AccessibleRoleCheckbox AccessibleRole = 6
	// AccessibleRoleColumnHeader: a header in a columned list.
	AccessibleRoleColumnHeader AccessibleRole = 7
	// AccessibleRoleComboBox: an input that controls another element, such as a
	// list or a grid, that can dynamically pop up to help the user set the
	// value of the input
	AccessibleRoleComboBox AccessibleRole = 8
	// AccessibleRoleCommand: abstract role.
	AccessibleRoleCommand AccessibleRole = 9
	// AccessibleRoleComposite: abstract role.
	AccessibleRoleComposite AccessibleRole = 10
	// AccessibleRoleDialog: a dialog is a window that is designed to interrupt
	// the current processing of an application in order to prompt the user to
	// enter information or require a response.
	AccessibleRoleDialog AccessibleRole = 11
	// AccessibleRoleDocument: unused
	AccessibleRoleDocument AccessibleRole = 12
	// AccessibleRoleFeed: unused
	AccessibleRoleFeed AccessibleRole = 13
	// AccessibleRoleForm: unused
	AccessibleRoleForm AccessibleRole = 14
	// AccessibleRoleGeneric: unused
	AccessibleRoleGeneric AccessibleRole = 15
	// AccessibleRoleGrid: a grid of items.
	AccessibleRoleGrid AccessibleRole = 16
	// AccessibleRoleGridCell: an item in a grid or tree grid.
	AccessibleRoleGridCell AccessibleRole = 17
	// AccessibleRoleGroup: an element that groups multiple widgets. GTK uses
	// this role for various containers, like Box, Viewport, and HeaderBar.
	AccessibleRoleGroup AccessibleRole = 18
	// AccessibleRoleHeading: unused
	AccessibleRoleHeading AccessibleRole = 19
	// AccessibleRoleImg: an image.
	AccessibleRoleImg AccessibleRole = 20
	// AccessibleRoleInput: abstract role.
	AccessibleRoleInput AccessibleRole = 21
	// AccessibleRoleLabel: a visible name or caption for a user interface
	// component.
	AccessibleRoleLabel AccessibleRole = 22
	// AccessibleRoleLandmark: abstract role.
	AccessibleRoleLandmark AccessibleRole = 23
	// AccessibleRoleLegend: unused
	AccessibleRoleLegend AccessibleRole = 24
	// AccessibleRoleLink: a clickable link.
	AccessibleRoleLink AccessibleRole = 25
	// AccessibleRoleList: a list of items.
	AccessibleRoleList AccessibleRole = 26
	// AccessibleRoleListBox: unused.
	AccessibleRoleListBox AccessibleRole = 27
	// AccessibleRoleListItem: an item in a list.
	AccessibleRoleListItem AccessibleRole = 28
	// AccessibleRoleLog: unused
	AccessibleRoleLog AccessibleRole = 29
	// AccessibleRoleMain: unused
	AccessibleRoleMain AccessibleRole = 30
	// AccessibleRoleMarquee: unused
	AccessibleRoleMarquee AccessibleRole = 31
	// AccessibleRoleMath: unused
	AccessibleRoleMath AccessibleRole = 32
	// AccessibleRoleMeter: an element that represents a value within a known
	// range.
	AccessibleRoleMeter AccessibleRole = 33
	// AccessibleRoleMenu: a menu.
	AccessibleRoleMenu AccessibleRole = 34
	// AccessibleRoleMenuBar: a menubar.
	AccessibleRoleMenuBar AccessibleRole = 35
	// AccessibleRoleMenuItem: an item in a menu.
	AccessibleRoleMenuItem AccessibleRole = 36
	// AccessibleRoleMenuItemCheckbox: a check item in a menu.
	AccessibleRoleMenuItemCheckbox AccessibleRole = 37
	// AccessibleRoleMenuItemRadio: a radio item in a menu.
	AccessibleRoleMenuItemRadio AccessibleRole = 38
	// AccessibleRoleNavigation: unused
	AccessibleRoleNavigation AccessibleRole = 39
	// AccessibleRoleNone: an element that is not represented to accessibility
	// technologies.
	AccessibleRoleNone AccessibleRole = 40
	// AccessibleRoleNote: unused
	AccessibleRoleNote AccessibleRole = 41
	// AccessibleRoleOption: unused
	AccessibleRoleOption AccessibleRole = 42
	// AccessibleRolePresentation: an element that is not represented to
	// accessibility technologies.
	AccessibleRolePresentation AccessibleRole = 43
	// AccessibleRoleProgressBar: an element that displays the progress status
	// for tasks that take a long time.
	AccessibleRoleProgressBar AccessibleRole = 44
	// AccessibleRoleRadio: a checkable input in a group of radio roles, only
	// one of which can be checked at a time.
	AccessibleRoleRadio AccessibleRole = 45
	// AccessibleRoleRadioGroup: unused
	AccessibleRoleRadioGroup AccessibleRole = 46
	// AccessibleRoleRange: abstract role.
	AccessibleRoleRange AccessibleRole = 47
	// AccessibleRoleRegion: unused
	AccessibleRoleRegion AccessibleRole = 48
	// AccessibleRoleRow: a row in a columned list.
	AccessibleRoleRow AccessibleRole = 49
	// AccessibleRoleRowGroup: unused
	AccessibleRoleRowGroup AccessibleRole = 50
	// AccessibleRoleRowHeader: unused
	AccessibleRoleRowHeader AccessibleRole = 51
	// AccessibleRoleScrollbar: a graphical object that controls the scrolling
	// of content within a viewing area, regardless of whether the content is
	// fully displayed within the viewing area.
	AccessibleRoleScrollbar AccessibleRole = 52
	// AccessibleRoleSearch: unused
	AccessibleRoleSearch AccessibleRole = 53
	// AccessibleRoleSearchBox: a type of textbox intended for specifying search
	// criteria.
	AccessibleRoleSearchBox AccessibleRole = 54
	// AccessibleRoleSection: abstract role.
	AccessibleRoleSection AccessibleRole = 55
	// AccessibleRoleSectionHead: abstract role.
	AccessibleRoleSectionHead AccessibleRole = 56
	// AccessibleRoleSelect: abstract role.
	AccessibleRoleSelect AccessibleRole = 57
	// AccessibleRoleSeparator: a divider that separates and distinguishes
	// sections of content or groups of menuitems.
	AccessibleRoleSeparator AccessibleRole = 58
	// AccessibleRoleSlider: a user input where the user selects a value from
	// within a given range.
	AccessibleRoleSlider AccessibleRole = 59
	// AccessibleRoleSpinButton: a form of range that expects the user to select
	// from among discrete choices.
	AccessibleRoleSpinButton AccessibleRole = 60
	// AccessibleRoleStatus: unused
	AccessibleRoleStatus AccessibleRole = 61
	// AccessibleRoleStructure: abstract role.
	AccessibleRoleStructure AccessibleRole = 62
	// AccessibleRoleSwitch: a type of checkbox that represents on/off values,
	// as opposed to checked/unchecked values.
	AccessibleRoleSwitch AccessibleRole = 63
	// AccessibleRoleTab: an item in a list of tab used for switching pages.
	AccessibleRoleTab AccessibleRole = 64
	// AccessibleRoleTable: unused
	AccessibleRoleTable AccessibleRole = 65
	// AccessibleRoleTabList: a list of tabs for switching pages.
	AccessibleRoleTabList AccessibleRole = 66
	// AccessibleRoleTabPanel: a page in a notebook or stack.
	AccessibleRoleTabPanel AccessibleRole = 67
	// AccessibleRoleTextBox: a type of input that allows free-form text as its
	// value.
	AccessibleRoleTextBox AccessibleRole = 68
	// AccessibleRoleTime: unused
	AccessibleRoleTime AccessibleRole = 69
	// AccessibleRoleTimer: unused
	AccessibleRoleTimer AccessibleRole = 70
	// AccessibleRoleToolbar: unused
	AccessibleRoleToolbar AccessibleRole = 71
	// AccessibleRoleTooltip: unused
	AccessibleRoleTooltip AccessibleRole = 72
	// AccessibleRoleTree: unused
	AccessibleRoleTree AccessibleRole = 73
	// AccessibleRoleTreeGrid: a treeview-like, columned list.
	AccessibleRoleTreeGrid AccessibleRole = 74
	// AccessibleRoleTreeItem: unused
	AccessibleRoleTreeItem AccessibleRole = 75
	// AccessibleRoleWidget: an interactive component of a graphical user
	// interface. This is the role that GTK uses by default for widgets.
	AccessibleRoleWidget AccessibleRole = 76
	// AccessibleRoleWindow: an application window.
	AccessibleRoleWindow AccessibleRole = 77
)

func marshalAccessibleRole(p uintptr) (interface{}, error) {
	return AccessibleRole(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AccessibleSort: the possible values for the GTK_ACCESSIBLE_PROPERTY_SORT
// accessible property.
type AccessibleSort int

const (
	// AccessibleSortNone: there is no defined sort applied to the column.
	AccessibleSortNone AccessibleSort = 0
	// AccessibleSortAscending items are sorted in ascending order by this
	// column.
	AccessibleSortAscending AccessibleSort = 1
	// AccessibleSortDescending items are sorted in descending order by this
	// column.
	AccessibleSortDescending AccessibleSort = 2
	// AccessibleSortOther: a sort algorithm other than ascending or descending
	// has been applied.
	AccessibleSortOther AccessibleSort = 3
)

func marshalAccessibleSort(p uintptr) (interface{}, error) {
	return AccessibleSort(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AccessibleState: the possible accessible states of a `GtkAccessible`.
type AccessibleState int

const (
	// AccessibleStateBusy: a “busy” state. This state has boolean values
	AccessibleStateBusy AccessibleState = 0
	// AccessibleStateChecked: a “checked” state; indicates the current state of
	// a CheckButton. Value type: AccessibleTristate
	AccessibleStateChecked AccessibleState = 1
	// AccessibleStateDisabled: a “disabled” state; corresponds to the
	// Widget:sensitive property on Widget. It indicates a UI element that is
	// perceivable, but not editable or operable. Value type: boolean
	AccessibleStateDisabled AccessibleState = 2
	// AccessibleStateExpanded: an “expanded” state; corresponds to the
	// Expander:expanded property on Expander. Value type: boolean or undefined
	AccessibleStateExpanded AccessibleState = 3
	// AccessibleStateHidden: a “hidden” state; corresponds to the
	// Widget:visible property on Widget. You can use this state explicitly on
	// UI elements that should not be exposed to an assistive technology. Value
	// type: boolean See also: GTK_ACCESSIBLE_STATE_DISABLED
	AccessibleStateHidden AccessibleState = 4
	// AccessibleStateInvalid: an “invalid” state; set when a widget is showing
	// an error. Value type: AccessibleInvalidState
	AccessibleStateInvalid AccessibleState = 5
	// AccessibleStatePressed: a “pressed” state; indicates the current state of
	// a ToggleButton. Value type: AccessibleTristate enumeration
	AccessibleStatePressed AccessibleState = 6
	// AccessibleStateSelected: a “selected” state; set when a widget is
	// selected. Value type: boolean or undefined
	AccessibleStateSelected AccessibleState = 7
)

func marshalAccessibleState(p uintptr) (interface{}, error) {
	return AccessibleState(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AccessibleTristate: the possible values for the GTK_ACCESSIBLE_STATE_PRESSED
// accessible state.
//
// Note that the GTK_ACCESSIBLE_TRISTATE_FALSE and GTK_ACCESSIBLE_TRISTATE_TRUE
// have the same values as false and true.
type AccessibleTristate int

const (
	// AccessibleTristateFalse: the state is `false`
	AccessibleTristateFalse AccessibleTristate = 0
	// AccessibleTristateTrue: the state is `true`
	AccessibleTristateTrue AccessibleTristate = 1
	// AccessibleTristateMixed: the state is `mixed`
	AccessibleTristateMixed AccessibleTristate = 2
)

func marshalAccessibleTristate(p uintptr) (interface{}, error) {
	return AccessibleTristate(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// Align controls how a widget deals with extra space in a single dimension.
//
// Alignment only matters if the widget receives a “too large” allocation, for
// example if you packed the widget with the [property@Gtk.Widget:hexpand]
// property inside a `GtkBox`, then the widget might get extra space. If you
// have for example a 16x16 icon inside a 32x32 space, the icon could be scaled
// and stretched, it could be centered, or it could be positioned to one side of
// the space.
//
// Note that in horizontal context GTK_ALIGN_START and GTK_ALIGN_END are
// interpreted relative to text direction.
//
// GTK_ALIGN_BASELINE support is optional for containers and widgets, and it is
// only supported for vertical alignment. When it's not supported by a child or
// a container it is treated as GTK_ALIGN_FILL.
type Align int

const (
	// AlignFill: stretch to fill all space if possible, center if no meaningful
	// way to stretch
	AlignFill Align = 0
	// AlignStart: snap to left or top side, leaving space on right or bottom
	AlignStart Align = 1
	// AlignEnd: snap to right or bottom side, leaving space on left or top
	AlignEnd Align = 2
	// AlignCenter: center natural width of widget inside the allocation
	AlignCenter Align = 3
	// AlignBaseline: align the widget according to the baseline. See Widget
	AlignBaseline Align = 4
)

func marshalAlign(p uintptr) (interface{}, error) {
	return Align(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ArrowType: used to indicate the direction in which an arrow should point.
type ArrowType int

const (
	// ArrowTypeUp represents an upward pointing arrow.
	ArrowTypeUp ArrowType = 0
	// ArrowTypeDown represents a downward pointing arrow.
	ArrowTypeDown ArrowType = 1
	// ArrowTypeLeft represents a left pointing arrow.
	ArrowTypeLeft ArrowType = 2
	// ArrowTypeRight represents a right pointing arrow.
	ArrowTypeRight ArrowType = 3
	// ArrowTypeNone: no arrow.
	ArrowTypeNone ArrowType = 4
)

func marshalArrowType(p uintptr) (interface{}, error) {
	return ArrowType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AssistantPageType determines the page role inside a `GtkAssistant`.
//
// The role is used to handle buttons sensitivity and visibility.
//
// Note that an assistant needs to end its page flow with a page of type
// GTK_ASSISTANT_PAGE_CONFIRM, GTK_ASSISTANT_PAGE_SUMMARY or
// GTK_ASSISTANT_PAGE_PROGRESS to be correct.
//
// The Cancel button will only be shown if the page isn’t “committed”. See
// gtk_assistant_commit() for details.
type AssistantPageType int

const (
	// AssistantPageTypeContent: the page has regular contents. Both the Back
	// and forward buttons will be shown.
	AssistantPageTypeContent AssistantPageType = 0
	// AssistantPageTypeIntro: the page contains an introduction to the
	// assistant task. Only the Forward button will be shown if there is a next
	// page.
	AssistantPageTypeIntro AssistantPageType = 1
	// AssistantPageTypeConfirm: the page lets the user confirm or deny the
	// changes. The Back and Apply buttons will be shown.
	AssistantPageTypeConfirm AssistantPageType = 2
	// AssistantPageTypeSummary: the page informs the user of the changes done.
	// Only the Close button will be shown.
	AssistantPageTypeSummary AssistantPageType = 3
	// AssistantPageTypeProgress: used for tasks that take a long time to
	// complete, blocks the assistant until the page is marked as complete. Only
	// the back button will be shown.
	AssistantPageTypeProgress AssistantPageType = 4
	// AssistantPageTypeCustom: used for when other page types are not
	// appropriate. No buttons will be shown, and the application must add its
	// own buttons through gtk_assistant_add_action_widget().
	AssistantPageTypeCustom AssistantPageType = 5
)

func marshalAssistantPageType(p uintptr) (interface{}, error) {
	return AssistantPageType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// BaselinePosition: baseline position in a row of widgets.
//
// Whenever a container has some form of natural row it may align children in
// that row along a common typographical baseline. If the amount of vertical
// space in the row is taller than the total requested height of the
// baseline-aligned children then it can use a `GtkBaselinePosition` to select
// where to put the baseline inside the extra available space.
type BaselinePosition int

const (
	// BaselinePositionTop: align the baseline at the top
	BaselinePositionTop BaselinePosition = 0
	// BaselinePositionCenter: center the baseline
	BaselinePositionCenter BaselinePosition = 1
	// BaselinePositionBottom: align the baseline at the bottom
	BaselinePositionBottom BaselinePosition = 2
)

func marshalBaselinePosition(p uintptr) (interface{}, error) {
	return BaselinePosition(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// BorderStyle describes how the border of a UI element should be rendered.
type BorderStyle int

const (
	// BorderStyleNone: no visible border
	BorderStyleNone BorderStyle = 0
	// BorderStyleHidden: same as GTK_BORDER_STYLE_NONE
	BorderStyleHidden BorderStyle = 1
	// BorderStyleSolid: a single line segment
	BorderStyleSolid BorderStyle = 2
	// BorderStyleInset looks as if the content is sunken into the canvas
	BorderStyleInset BorderStyle = 3
	// BorderStyleOutset looks as if the content is coming out of the canvas
	BorderStyleOutset BorderStyle = 4
	// BorderStyleDotted: a series of round dots
	BorderStyleDotted BorderStyle = 5
	// BorderStyleDashed: a series of square-ended dashes
	BorderStyleDashed BorderStyle = 6
	// BorderStyleDouble: two parallel lines with some space between them
	BorderStyleDouble BorderStyle = 7
	// BorderStyleGroove looks as if it were carved in the canvas
	BorderStyleGroove BorderStyle = 8
	// BorderStyleRidge looks as if it were coming out of the canvas
	BorderStyleRidge BorderStyle = 9
)

func marshalBorderStyle(p uintptr) (interface{}, error) {
	return BorderStyle(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// BuilderError: error codes that identify various errors that can occur while
// using Builder.
type BuilderError int

const (
	// BuilderErrorInvalidTypeFunction: a type-func attribute didn’t name a
	// function that returns a #GType.
	BuilderErrorInvalidTypeFunction BuilderError = 0
	// BuilderErrorUnhandledTag: the input contained a tag that Builder can’t
	// handle.
	BuilderErrorUnhandledTag BuilderError = 1
	// BuilderErrorMissingAttribute: an attribute that is required by Builder
	// was missing.
	BuilderErrorMissingAttribute BuilderError = 2
	// BuilderErrorInvalidAttribute: Builder found an attribute that it doesn’t
	// understand.
	BuilderErrorInvalidAttribute BuilderError = 3
	// BuilderErrorInvalidTag: Builder found a tag that it doesn’t understand.
	BuilderErrorInvalidTag BuilderError = 4
	// BuilderErrorMissingPropertyValue: a required property value was missing.
	BuilderErrorMissingPropertyValue BuilderError = 5
	// BuilderErrorInvalidValue: Builder couldn’t parse some attribute value.
	BuilderErrorInvalidValue BuilderError = 6
	// BuilderErrorVersionMismatch: the input file requires a newer version of
	// GTK.
	BuilderErrorVersionMismatch BuilderError = 7
	// BuilderErrorDuplicateID: an object id occurred twice.
	BuilderErrorDuplicateID BuilderError = 8
	// BuilderErrorObjectTypeRefused: a specified object type is of the same
	// type or derived from the type of the composite class being extended with
	// builder XML.
	BuilderErrorObjectTypeRefused BuilderError = 9
	// BuilderErrorTemplateMismatch: the wrong type was specified in a composite
	// class’s template XML
	BuilderErrorTemplateMismatch BuilderError = 10
	// BuilderErrorInvalidProperty: the specified property is unknown for the
	// object class.
	BuilderErrorInvalidProperty BuilderError = 11
	// BuilderErrorInvalidSignal: the specified signal is unknown for the object
	// class.
	BuilderErrorInvalidSignal BuilderError = 12
	// BuilderErrorInvalidID: an object id is unknown.
	BuilderErrorInvalidID BuilderError = 13
	// BuilderErrorInvalidFunction: a function could not be found. This often
	// happens when symbols are set to be kept private. Compiling code with
	// -rdynamic or using the `gmodule-export-2.0` pkgconfig module can fix this
	// problem.
	BuilderErrorInvalidFunction BuilderError = 14
)

func marshalBuilderError(p uintptr) (interface{}, error) {
	return BuilderError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ButtonsType: prebuilt sets of buttons for `GtkDialog`.
//
// If none of these choices are appropriate, simply use GTK_BUTTONS_NONE and
// call [method@Gtk.Dialog.add_buttons].
//
// > Please note that GTK_BUTTONS_OK, GTK_BUTTONS_YES_NO > and
// GTK_BUTTONS_OK_CANCEL are discouraged by the > GNOME Human Interface
// Guidelines (http://library.gnome.org/devel/hig-book/stable/).
type ButtonsType int

const (
	// ButtonsTypeNone: no buttons at all
	ButtonsTypeNone ButtonsType = 0
	// ButtonsTypeOk: an OK button
	ButtonsTypeOk ButtonsType = 1
	// ButtonsTypeClose: a Close button
	ButtonsTypeClose ButtonsType = 2
	// ButtonsTypeCancel: a Cancel button
	ButtonsTypeCancel ButtonsType = 3
	// ButtonsTypeYesNo yes and No buttons
	ButtonsTypeYesNo ButtonsType = 4
	// ButtonsTypeOkCancel: OK and Cancel buttons
	ButtonsTypeOkCancel ButtonsType = 5
)

func marshalButtonsType(p uintptr) (interface{}, error) {
	return ButtonsType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// CellRendererAccelMode determines if the edited accelerators are GTK
// accelerators. If they are, consumed modifiers are suppressed, only
// accelerators accepted by GTK are allowed, and the accelerators are rendered
// in the same way as they are in menus.
type CellRendererAccelMode int

const (
	// CellRendererAccelModeGTK: GTK accelerators mode
	CellRendererAccelModeGTK CellRendererAccelMode = 0
	// CellRendererAccelModeOther: other accelerator mode
	CellRendererAccelModeOther CellRendererAccelMode = 1
)

func marshalCellRendererAccelMode(p uintptr) (interface{}, error) {
	return CellRendererAccelMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// CellRendererMode identifies how the user can interact with a particular cell.
type CellRendererMode int

const (
	// CellRendererModeInert: the cell is just for display and cannot be
	// interacted with. Note that this doesn’t mean that eg. the row being drawn
	// can’t be selected -- just that a particular element of it cannot be
	// individually modified.
	CellRendererModeInert CellRendererMode = 0
	// CellRendererModeActivatable: the cell can be clicked.
	CellRendererModeActivatable CellRendererMode = 1
	// CellRendererModeEditable: the cell can be edited or otherwise modified.
	CellRendererModeEditable CellRendererMode = 2
)

func marshalCellRendererMode(p uintptr) (interface{}, error) {
	return CellRendererMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ConstraintAttribute: the widget attributes that can be used when creating a
// `GtkConstraint`.
type ConstraintAttribute int

const (
	// ConstraintAttributeNone: no attribute, used for constant relations
	ConstraintAttributeNone ConstraintAttribute = 0
	// ConstraintAttributeLeft: the left edge of a widget, regardless of text
	// direction
	ConstraintAttributeLeft ConstraintAttribute = 1
	// ConstraintAttributeRight: the right edge of a widget, regardless of text
	// direction
	ConstraintAttributeRight ConstraintAttribute = 2
	// ConstraintAttributeTop: the top edge of a widget
	ConstraintAttributeTop ConstraintAttribute = 3
	// ConstraintAttributeBottom: the bottom edge of a widget
	ConstraintAttributeBottom ConstraintAttribute = 4
	// ConstraintAttributeStart: the leading edge of a widget, depending on text
	// direction; equivalent to GTK_CONSTRAINT_ATTRIBUTE_LEFT for LTR languages,
	// and GTK_CONSTRAINT_ATTRIBUTE_RIGHT for RTL ones
	ConstraintAttributeStart ConstraintAttribute = 5
	// ConstraintAttributeEnd: the trailing edge of a widget, depending on text
	// direction; equivalent to GTK_CONSTRAINT_ATTRIBUTE_RIGHT for LTR
	// languages, and GTK_CONSTRAINT_ATTRIBUTE_LEFT for RTL ones
	ConstraintAttributeEnd ConstraintAttribute = 6
	// ConstraintAttributeWidth: the width of a widget
	ConstraintAttributeWidth ConstraintAttribute = 7
	// ConstraintAttributeHeight: the height of a widget
	ConstraintAttributeHeight ConstraintAttribute = 8
	// ConstraintAttributeCenterX: the center of a widget, on the horizontal
	// axis
	ConstraintAttributeCenterX ConstraintAttribute = 9
	// ConstraintAttributeCenterY: the center of a widget, on the vertical axis
	ConstraintAttributeCenterY ConstraintAttribute = 10
	// ConstraintAttributeBaseline: the baseline of a widget
	ConstraintAttributeBaseline ConstraintAttribute = 11
)

func marshalConstraintAttribute(p uintptr) (interface{}, error) {
	return ConstraintAttribute(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ConstraintRelation: the relation between two terms of a constraint.
type ConstraintRelation int

const (
	// ConstraintRelationLe less than, or equal
	ConstraintRelationLe ConstraintRelation = -1
	// ConstraintRelationEq: equal
	ConstraintRelationEq ConstraintRelation = 0
	// ConstraintRelationGe: greater than, or equal
	ConstraintRelationGe ConstraintRelation = 1
)

func marshalConstraintRelation(p uintptr) (interface{}, error) {
	return ConstraintRelation(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ConstraintStrength: the strength of a constraint, expressed as a symbolic
// constant.
//
// The strength of a Constraint can be expressed with any positive integer; the
// values of this enumeration can be used for readability.
type ConstraintStrength int

const (
	// ConstraintStrengthRequired: the constraint is required towards solving
	// the layout
	ConstraintStrengthRequired ConstraintStrength = 1001001000
	// ConstraintStrengthStrong: a strong constraint
	ConstraintStrengthStrong ConstraintStrength = 1000000000
	// ConstraintStrengthMedium: a medium constraint
	ConstraintStrengthMedium ConstraintStrength = 1000
	// ConstraintStrengthWeak: a weak constraint
	ConstraintStrengthWeak ConstraintStrength = 1
)

func marshalConstraintStrength(p uintptr) (interface{}, error) {
	return ConstraintStrength(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ConstraintVflParserError: domain for VFL parsing errors.
type ConstraintVflParserError int

const (
	// ConstraintVflParserErrorSymbol: invalid or unknown symbol
	ConstraintVflParserErrorSymbol ConstraintVflParserError = 0
	// ConstraintVflParserErrorAttribute: invalid or unknown attribute
	ConstraintVflParserErrorAttribute ConstraintVflParserError = 1
	// ConstraintVflParserErrorView: invalid or unknown view
	ConstraintVflParserErrorView ConstraintVflParserError = 2
	// ConstraintVflParserErrorMetric: invalid or unknown metric
	ConstraintVflParserErrorMetric ConstraintVflParserError = 3
	// ConstraintVflParserErrorPriority: invalid or unknown priority
	ConstraintVflParserErrorPriority ConstraintVflParserError = 4
	// ConstraintVflParserErrorRelation: invalid or unknown relation
	ConstraintVflParserErrorRelation ConstraintVflParserError = 5
)

func marshalConstraintVflParserError(p uintptr) (interface{}, error) {
	return ConstraintVflParserError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// CornerType specifies which corner a child widget should be placed in when
// packed into a `GtkScrolledWindow.`
//
// This is effectively the opposite of where the scroll bars are placed.
type CornerType int

const (
	// CornerTypeTopLeft: place the scrollbars on the right and bottom of the
	// widget (default behaviour).
	CornerTypeTopLeft CornerType = 0
	// CornerTypeBottomLeft: place the scrollbars on the top and right of the
	// widget.
	CornerTypeBottomLeft CornerType = 1
	// CornerTypeTopRight: place the scrollbars on the left and bottom of the
	// widget.
	CornerTypeTopRight CornerType = 2
	// CornerTypeBottomRight: place the scrollbars on the top and left of the
	// widget.
	CornerTypeBottomRight CornerType = 3
)

func marshalCornerType(p uintptr) (interface{}, error) {
	return CornerType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DeleteType: passed to various keybinding signals for deleting text.
type DeleteType int

const (
	// DeleteTypeChars: delete characters.
	DeleteTypeChars DeleteType = 0
	// DeleteTypeWordEnds: delete only the portion of the word to the left/right
	// of cursor if we’re in the middle of a word.
	DeleteTypeWordEnds DeleteType = 1
	// DeleteTypeWords: delete words.
	DeleteTypeWords DeleteType = 2
	// DeleteTypeDisplayLines: delete display-lines. Display-lines refers to the
	// visible lines, with respect to the current line breaks. As opposed to
	// paragraphs, which are defined by line breaks in the input.
	DeleteTypeDisplayLines DeleteType = 3
	// DeleteTypeDisplayLineEnds: delete only the portion of the display-line to
	// the left/right of cursor.
	DeleteTypeDisplayLineEnds DeleteType = 4
	// DeleteTypeParagraphEnds: delete to the end of the paragraph. Like C-k in
	// Emacs (or its reverse).
	DeleteTypeParagraphEnds DeleteType = 5
	// DeleteTypeParagraphs: delete entire line. Like C-k in pico.
	DeleteTypeParagraphs DeleteType = 6
	// DeleteTypeWhitespace: delete only whitespace. Like M-\ in Emacs.
	DeleteTypeWhitespace DeleteType = 7
)

func marshalDeleteType(p uintptr) (interface{}, error) {
	return DeleteType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DirectionType focus movement types.
type DirectionType int

const (
	// DirectionTypeTabForward: move forward.
	DirectionTypeTabForward DirectionType = 0
	// DirectionTypeTabBackward: move backward.
	DirectionTypeTabBackward DirectionType = 1
	// DirectionTypeUp: move up.
	DirectionTypeUp DirectionType = 2
	// DirectionTypeDown: move down.
	DirectionTypeDown DirectionType = 3
	// DirectionTypeLeft: move left.
	DirectionTypeLeft DirectionType = 4
	// DirectionTypeRight: move right.
	DirectionTypeRight DirectionType = 5
)

func marshalDirectionType(p uintptr) (interface{}, error) {
	return DirectionType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

type EditableProperties int

const (
	EditablePropertiesPropText           EditableProperties = 0
	EditablePropertiesPropCursorPosition EditableProperties = 1
	EditablePropertiesPropSelectionBound EditableProperties = 2
	EditablePropertiesPropEditable       EditableProperties = 3
	EditablePropertiesPropWidthChars     EditableProperties = 4
	EditablePropertiesPropMaxWidthChars  EditableProperties = 5
	EditablePropertiesPropXalign         EditableProperties = 6
	EditablePropertiesPropEnableUndo     EditableProperties = 7
	EditablePropertiesNumProperties      EditableProperties = 8
)

func marshalEditableProperties(p uintptr) (interface{}, error) {
	return EditableProperties(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// EntryIconPosition specifies the side of the entry at which an icon is placed.
type EntryIconPosition int

const (
	// EntryIconPositionPrimary: at the beginning of the entry (depending on the
	// text direction).
	EntryIconPositionPrimary EntryIconPosition = 0
	// EntryIconPositionSecondary: at the end of the entry (depending on the
	// text direction).
	EntryIconPositionSecondary EntryIconPosition = 1
)

func marshalEntryIconPosition(p uintptr) (interface{}, error) {
	return EntryIconPosition(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// EventSequenceState describes the state of a `GdkEventSequence` in a
// `GtkGesture`.
type EventSequenceState int

const (
	// EventSequenceStateNone: the sequence is handled, but not grabbed.
	EventSequenceStateNone EventSequenceState = 0
	// EventSequenceStateClaimed: the sequence is handled and grabbed.
	EventSequenceStateClaimed EventSequenceState = 1
	// EventSequenceStateDenied: the sequence is denied.
	EventSequenceStateDenied EventSequenceState = 2
)

func marshalEventSequenceState(p uintptr) (interface{}, error) {
	return EventSequenceState(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FileChooserAction describes whether a `GtkFileChooser` is being used to open
// existing files or to save to a possibly new file.
type FileChooserAction int

const (
	// FileChooserActionOpen indicates open mode. The file chooser will only let
	// the user pick an existing file.
	FileChooserActionOpen FileChooserAction = 0
	// FileChooserActionSave indicates save mode. The file chooser will let the
	// user pick an existing file, or type in a new filename.
	FileChooserActionSave FileChooserAction = 1
	// FileChooserActionSelectFolder indicates an Open mode for selecting
	// folders. The file chooser will let the user pick an existing folder.
	FileChooserActionSelectFolder FileChooserAction = 2
)

func marshalFileChooserAction(p uintptr) (interface{}, error) {
	return FileChooserAction(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FileChooserError: these identify the various errors that can occur while
// calling `GtkFileChooser` functions.
type FileChooserError int

const (
	// FileChooserErrorNonexistent indicates that a file does not exist.
	FileChooserErrorNonexistent FileChooserError = 0
	// FileChooserErrorBadFilename indicates a malformed filename.
	FileChooserErrorBadFilename FileChooserError = 1
	// FileChooserErrorAlreadyExists indicates a duplicate path (e.g. when
	// adding a bookmark).
	FileChooserErrorAlreadyExists FileChooserError = 2
	// FileChooserErrorIncompleteHostname indicates an incomplete hostname (e.g.
	// "http://foo" without a slash after that).
	FileChooserErrorIncompleteHostname FileChooserError = 3
)

func marshalFileChooserError(p uintptr) (interface{}, error) {
	return FileChooserError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FilterChange describes changes in a filter in more detail and allows objects
// using the filter to optimize refiltering items.
//
// If you are writing an implementation and are not sure which value to pass,
// GTK_FILTER_CHANGE_DIFFERENT is always a correct choice.
type FilterChange int

const (
	// FilterChangeDifferent: the filter change cannot be described with any of
	// the other enumeration values.
	FilterChangeDifferent FilterChange = 0
	// FilterChangeLessStrict: the filter is less strict than it was before: All
	// items that it used to return true for still return true, others now may,
	// too.
	FilterChangeLessStrict FilterChange = 1
	// FilterChangeMoreStrict: the filter is more strict than it was before: All
	// items that it used to return false for still return false, others now
	// may, too.
	FilterChangeMoreStrict FilterChange = 2
)

func marshalFilterChange(p uintptr) (interface{}, error) {
	return FilterChange(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FilterMatch describes the known strictness of a filter.
//
// Note that for filters where the strictness is not known,
// GTK_FILTER_MATCH_SOME is always an acceptable value, even if a filter does
// match all or no items.
type FilterMatch int

const (
	// FilterMatchSome: the filter matches some items, gtk_filter_match() may
	// return true or false
	FilterMatchSome FilterMatch = 0
	// FilterMatchNone: the filter does not match any item, gtk_filter_match()
	// will always return false.
	FilterMatchNone FilterMatch = 1
	// FilterMatchAll: the filter matches all items, gtk_filter_match() will
	// alays return true.
	FilterMatchAll FilterMatch = 2
)

func marshalFilterMatch(p uintptr) (interface{}, error) {
	return FilterMatch(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// IconSize: built-in icon sizes.
//
// Icon sizes default to being inherited. Where they cannot be inherited, text
// size is the default.
//
// All widgets which use `GtkIconSize` set the normal-icons or large-icons style
// classes correspondingly, and let themes determine the actual size to be used
// with the `-gtk-icon-size` CSS property.
type IconSize int

const (
	// IconSizeInherit: keep the size of the parent element
	IconSizeInherit IconSize = 0
	// IconSizeNormal: size similar to text size
	IconSizeNormal IconSize = 1
	// IconSizeLarge: large size, for example in an icon view
	IconSizeLarge IconSize = 2
)

func marshalIconSize(p uintptr) (interface{}, error) {
	return IconSize(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// IconThemeError: error codes for `GtkIconTheme` operations.
type IconThemeError int

const (
	// IconThemeErrorNotFound: the icon specified does not exist in the theme
	IconThemeErrorNotFound IconThemeError = 0
	// IconThemeErrorFailed: an unspecified error occurred.
	IconThemeErrorFailed IconThemeError = 1
)

func marshalIconThemeError(p uintptr) (interface{}, error) {
	return IconThemeError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// IconViewDropPosition: an enum for determining where a dropped item goes.
type IconViewDropPosition int

const (
	// IconViewDropPositionNoDrop: no drop possible
	IconViewDropPositionNoDrop IconViewDropPosition = 0
	// IconViewDropPositionDropInto: dropped item replaces the item
	IconViewDropPositionDropInto IconViewDropPosition = 1
	// IconViewDropPositionDropLeft: dropped item is inserted to the left
	IconViewDropPositionDropLeft IconViewDropPosition = 2
	// IconViewDropPositionDropRight: dropped item is inserted to the right
	IconViewDropPositionDropRight IconViewDropPosition = 3
	// IconViewDropPositionDropAbove: dropped item is inserted above
	IconViewDropPositionDropAbove IconViewDropPosition = 4
	// IconViewDropPositionDropBelow: dropped item is inserted below
	IconViewDropPositionDropBelow IconViewDropPosition = 5
)

func marshalIconViewDropPosition(p uintptr) (interface{}, error) {
	return IconViewDropPosition(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ImageType describes the image data representation used by a
// [class@Gtk.Image].
//
// If you want to get the image from the widget, you can only get the
// currently-stored representation; for instance, if the
// gtk_image_get_storage_type() returns GTK_IMAGE_PAINTABLE, then you can call
// gtk_image_get_paintable().
//
// For empty images, you can request any storage type (call any of the "get"
// functions), but they will all return nil values.
type ImageType int

const (
	// ImageTypeEmpty: there is no image displayed by the widget
	ImageTypeEmpty ImageType = 0
	// ImageTypeIconName: the widget contains a named icon
	ImageTypeIconName ImageType = 1
	// ImageTypeGIcon: the widget contains a #GIcon
	ImageTypeGIcon ImageType = 2
	// ImageTypePaintable: the widget contains a Paintable
	ImageTypePaintable ImageType = 3
)

func marshalImageType(p uintptr) (interface{}, error) {
	return ImageType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// InputPurpose describes primary purpose of the input widget.
//
// This information is useful for on-screen keyboards and similar input methods
// to decide which keys should be presented to the user.
//
// Note that the purpose is not meant to impose a totally strict rule about
// allowed characters, and does not replace input validation. It is fine for an
// on-screen keyboard to let the user override the character set restriction
// that is expressed by the purpose. The application is expected to validate the
// entry contents, even if it specified a purpose.
//
// The difference between GTK_INPUT_PURPOSE_DIGITS and GTK_INPUT_PURPOSE_NUMBER
// is that the former accepts only digits while the latter also some punctuation
// (like commas or points, plus, minus) and “e” or “E” as in 3.14E+000.
//
// This enumeration may be extended in the future; input methods should
// interpret unknown values as “free form”.
type InputPurpose int

const (
	// InputPurposeFreeForm: allow any character
	InputPurposeFreeForm InputPurpose = 0
	// InputPurposeAlpha: allow only alphabetic characters
	InputPurposeAlpha InputPurpose = 1
	// InputPurposeDigits: allow only digits
	InputPurposeDigits InputPurpose = 2
	// InputPurposeNumber: edited field expects numbers
	InputPurposeNumber InputPurpose = 3
	// InputPurposePhone: edited field expects phone number
	InputPurposePhone InputPurpose = 4
	// InputPurposeURL: edited field expects URL
	InputPurposeURL InputPurpose = 5
	// InputPurposeEmail: edited field expects email address
	InputPurposeEmail InputPurpose = 6
	// InputPurposeName: edited field expects the name of a person
	InputPurposeName InputPurpose = 7
	// InputPurposePassword: like GTK_INPUT_PURPOSE_FREE_FORM, but characters
	// are hidden
	InputPurposePassword InputPurpose = 8
	// InputPurposePin: like GTK_INPUT_PURPOSE_DIGITS, but characters are hidden
	InputPurposePin InputPurpose = 9
	// InputPurposeTerminal: allow any character, in addition to control codes
	InputPurposeTerminal InputPurpose = 10
)

func marshalInputPurpose(p uintptr) (interface{}, error) {
	return InputPurpose(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// Justification: used for justifying the text inside a `GtkLabel` widget.
type Justification int

const (
	// JustificationLeft: the text is placed at the left edge of the label.
	JustificationLeft Justification = 0
	// JustificationRight: the text is placed at the right edge of the label.
	JustificationRight Justification = 1
	// JustificationCenter: the text is placed in the center of the label.
	JustificationCenter Justification = 2
	// JustificationFill: the text is placed is distributed across the label.
	JustificationFill Justification = 3
)

func marshalJustification(p uintptr) (interface{}, error) {
	return Justification(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// LevelBarMode describes how `GtkLevelBar` contents should be rendered.
//
// Note that this enumeration could be extended with additional modes in the
// future.
type LevelBarMode int

const (
	// LevelBarModeContinuous: the bar has a continuous mode
	LevelBarModeContinuous LevelBarMode = 0
	// LevelBarModeDiscrete: the bar has a discrete mode
	LevelBarModeDiscrete LevelBarMode = 1
)

func marshalLevelBarMode(p uintptr) (interface{}, error) {
	return LevelBarMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// License: the type of license for an application.
//
// This enumeration can be expanded at later date.
type License int

const (
	// LicenseUnknown: no license specified
	LicenseUnknown License = 0
	// LicenseCustom: a license text is going to be specified by the developer
	LicenseCustom License = 1
	// LicenseGPL20: the GNU General Public License, version 2.0 or later
	LicenseGPL20 License = 2
	// LicenseGPL30: the GNU General Public License, version 3.0 or later
	LicenseGPL30 License = 3
	// LicenseLGPL21: the GNU Lesser General Public License, version 2.1 or
	// later
	LicenseLGPL21 License = 4
	// LicenseLGPL30: the GNU Lesser General Public License, version 3.0 or
	// later
	LicenseLGPL30 License = 5
	// LicenseBSD: the BSD standard license
	LicenseBSD License = 6
	// LicenseMITX11: the MIT/X11 standard license
	LicenseMITX11 License = 7
	// LicenseArtistic: the Artistic License, version 2.0
	LicenseArtistic License = 8
	// LicenseGPL20Only: the GNU General Public License, version 2.0 only
	LicenseGPL20Only License = 9
	// LicenseGPL30Only: the GNU General Public License, version 3.0 only
	LicenseGPL30Only License = 10
	// LicenseLGPL21Only: the GNU Lesser General Public License, version 2.1
	// only
	LicenseLGPL21Only License = 11
	// LicenseLGPL30Only: the GNU Lesser General Public License, version 3.0
	// only
	LicenseLGPL30Only License = 12
	// LicenseAGPL30: the GNU Affero General Public License, version 3.0 or
	// later
	LicenseAGPL30 License = 13
	// LicenseAGPL30Only: the GNU Affero General Public License, version 3.0
	// only
	LicenseAGPL30Only License = 14
	// LicenseBSD3: the 3-clause BSD licence
	LicenseBSD3 License = 15
	// LicenseApache20: the Apache License, version 2.0
	LicenseApache20 License = 16
	// LicenseMPL20: the Mozilla Public License, version 2.0
	LicenseMPL20 License = 17
)

func marshalLicense(p uintptr) (interface{}, error) {
	return License(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// MessageType: the type of message being displayed in a `GtkMessageDialog`.
type MessageType int

const (
	// MessageTypeInfo: informational message
	MessageTypeInfo MessageType = 0
	// MessageTypeWarning: non-fatal warning message
	MessageTypeWarning MessageType = 1
	// MessageTypeQuestion: question requiring a choice
	MessageTypeQuestion MessageType = 2
	// MessageTypeError: fatal error message
	MessageTypeError MessageType = 3
	// MessageTypeOther: none of the above
	MessageTypeOther MessageType = 4
)

func marshalMessageType(p uintptr) (interface{}, error) {
	return MessageType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// MovementStep: passed as argument to various keybinding signals for moving the
// cursor position.
type MovementStep int

const (
	// MovementStepLogicalPositions: move forward or back by graphemes
	MovementStepLogicalPositions MovementStep = 0
	// MovementStepVisualPositions: move left or right by graphemes
	MovementStepVisualPositions MovementStep = 1
	// MovementStepWords: move forward or back by words
	MovementStepWords MovementStep = 2
	// MovementStepDisplayLines: move up or down lines (wrapped lines)
	MovementStepDisplayLines MovementStep = 3
	// MovementStepDisplayLineEnds: move to either end of a line
	MovementStepDisplayLineEnds MovementStep = 4
	// MovementStepParagraphs: move up or down paragraphs (newline-ended lines)
	MovementStepParagraphs MovementStep = 5
	// MovementStepParagraphEnds: move to either end of a paragraph
	MovementStepParagraphEnds MovementStep = 6
	// MovementStepPages: move by pages
	MovementStepPages MovementStep = 7
	// MovementStepBufferEnds: move to ends of the buffer
	MovementStepBufferEnds MovementStep = 8
	// MovementStepHorizontalPages: move horizontally by pages
	MovementStepHorizontalPages MovementStep = 9
)

func marshalMovementStep(p uintptr) (interface{}, error) {
	return MovementStep(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// NotebookTab: the parameter used in the action signals of `GtkNotebook`.
type NotebookTab int

const (
	// NotebookTabFirst: the first tab in the notebook
	NotebookTabFirst NotebookTab = 0
	// NotebookTabLast: the last tab in the notebook
	NotebookTabLast NotebookTab = 1
)

func marshalNotebookTab(p uintptr) (interface{}, error) {
	return NotebookTab(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// NumberUpLayout: used to determine the layout of pages on a sheet when
// printing multiple pages per sheet.
type NumberUpLayout int

const (
	// NumberUpLayoutLrtb: ! (layout-lrtb.png)
	NumberUpLayoutLrtb NumberUpLayout = 0
	// NumberUpLayoutLrbt: ! (layout-lrbt.png)
	NumberUpLayoutLrbt NumberUpLayout = 1
	// NumberUpLayoutRltb: ! (layout-rltb.png)
	NumberUpLayoutRltb NumberUpLayout = 2
	// NumberUpLayoutRlbt: ! (layout-rlbt.png)
	NumberUpLayoutRlbt NumberUpLayout = 3
	// NumberUpLayoutTblr: ! (layout-tblr.png)
	NumberUpLayoutTblr NumberUpLayout = 4
	// NumberUpLayoutTbrl: ! (layout-tbrl.png)
	NumberUpLayoutTbrl NumberUpLayout = 5
	// NumberUpLayoutBtlr: ! (layout-btlr.png)
	NumberUpLayoutBtlr NumberUpLayout = 6
	// NumberUpLayoutBtrl: ! (layout-btrl.png)
	NumberUpLayoutBtrl NumberUpLayout = 7
)

func marshalNumberUpLayout(p uintptr) (interface{}, error) {
	return NumberUpLayout(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// Ordering describes the way two values can be compared.
//
// These values can be used with a `GCompareFunc`. However, a `GCompareFunc` is
// allowed to return any integer values. For converting such a value to a
// `GtkOrdering` value, use [func@Gtk.Ordering.from_cmpfunc].
type Ordering int

const (
	// OrderingSmaller: the first value is smaller than the second
	OrderingSmaller Ordering = -1
	// OrderingEqual: the two values are equal
	OrderingEqual Ordering = 0
	// OrderingLarger: the first value is larger than the second
	OrderingLarger Ordering = 1
)

func marshalOrdering(p uintptr) (interface{}, error) {
	return Ordering(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// Orientation represents the orientation of widgets and other objects.
//
// Typical examples are `GtkBox or `GtkGesturePan`.
type Orientation int

const (
	// OrientationHorizontal: the element is in horizontal orientation.
	OrientationHorizontal Orientation = 0
	// OrientationVertical: the element is in vertical orientation.
	OrientationVertical Orientation = 1
)

func marshalOrientation(p uintptr) (interface{}, error) {
	return Orientation(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// Overflow defines how content overflowing a given area should be handled.
//
// This is used in [method@Gtk.Widget.set_overflow]. The
// [property@Gtk.Widget:overflow] property is modeled after the CSS overflow
// property, but implements it only partially.
type Overflow int

const (
	// OverflowVisible: no change is applied. Content is drawn at the specified
	// position.
	OverflowVisible Overflow = 0
	// OverflowHidden: content is clipped to the bounds of the area. Content
	// outside the area is not drawn and cannot be interacted with.
	OverflowHidden Overflow = 1
)

func marshalOverflow(p uintptr) (interface{}, error) {
	return Overflow(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PackType represents the packing location of a children in its parent.
//
// See `GtkWindowControls` for example.
type PackType int

const (
	// PackTypeStart: the child is packed into the start of the widget
	PackTypeStart PackType = 0
	// PackTypeEnd: the child is packed into the end of the widget
	PackTypeEnd PackType = 1
)

func marshalPackType(p uintptr) (interface{}, error) {
	return PackType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PadActionType: the type of a pad action.
type PadActionType int

const (
	// PadActionTypeButton: action is triggered by a pad button
	PadActionTypeButton PadActionType = 0
	// PadActionTypeRing: action is triggered by a pad ring
	PadActionTypeRing PadActionType = 1
	// PadActionTypeStrip: action is triggered by a pad strip
	PadActionTypeStrip PadActionType = 2
)

func marshalPadActionType(p uintptr) (interface{}, error) {
	return PadActionType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PageOrientation: see also gtk_print_settings_set_orientation().
type PageOrientation int

const (
	// PageOrientationPortrait: portrait mode.
	PageOrientationPortrait PageOrientation = 0
	// PageOrientationLandscape: landscape mode.
	PageOrientationLandscape PageOrientation = 1
	// PageOrientationReversePortrait: reverse portrait mode.
	PageOrientationReversePortrait PageOrientation = 2
	// PageOrientationReverseLandscape: reverse landscape mode.
	PageOrientationReverseLandscape PageOrientation = 3
)

func marshalPageOrientation(p uintptr) (interface{}, error) {
	return PageOrientation(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PageSet: see also gtk_print_job_set_page_set().
type PageSet int

const (
	// PageSetAll: all pages.
	PageSetAll PageSet = 0
	// PageSetEven: even pages.
	PageSetEven PageSet = 1
	// PageSetOdd: odd pages.
	PageSetOdd PageSet = 2
)

func marshalPageSet(p uintptr) (interface{}, error) {
	return PageSet(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PanDirection describes the panning direction of a `GtkGesturePan`
type PanDirection int

const (
	// PanDirectionLeft: panned towards the left
	PanDirectionLeft PanDirection = 0
	// PanDirectionRight: panned towards the right
	PanDirectionRight PanDirection = 1
	// PanDirectionUp: panned upwards
	PanDirectionUp PanDirection = 2
	// PanDirectionDown: panned downwards
	PanDirectionDown PanDirection = 3
)

func marshalPanDirection(p uintptr) (interface{}, error) {
	return PanDirection(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PolicyType determines how the size should be computed to achieve the one of
// the visibility mode for the scrollbars.
type PolicyType int

const (
	// PolicyTypeAlways: the scrollbar is always visible. The view size is
	// independent of the content.
	PolicyTypeAlways PolicyType = 0
	// PolicyTypeAutomatic: the scrollbar will appear and disappear as
	// necessary. For example, when all of a `GtkTreeView` can not be seen.
	PolicyTypeAutomatic PolicyType = 1
	// PolicyTypeNever: the scrollbar should never appear. In this mode the
	// content determines the size.
	PolicyTypeNever PolicyType = 2
	// PolicyTypeExternal: don't show a scrollbar, but don't force the size to
	// follow the content. This can be used e.g. to make multiple scrolled
	// windows share a scrollbar.
	PolicyTypeExternal PolicyType = 3
)

func marshalPolicyType(p uintptr) (interface{}, error) {
	return PolicyType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PositionType describes which edge of a widget a certain feature is positioned
// at.
//
// For examples, see the tabs of a `GtkNotebook`, or the label of a `GtkScale`.
type PositionType int

const (
	// PositionTypeLeft: the feature is at the left edge.
	PositionTypeLeft PositionType = 0
	// PositionTypeRight: the feature is at the right edge.
	PositionTypeRight PositionType = 1
	// PositionTypeTop: the feature is at the top edge.
	PositionTypeTop PositionType = 2
	// PositionTypeBottom: the feature is at the bottom edge.
	PositionTypeBottom PositionType = 3
)

func marshalPositionType(p uintptr) (interface{}, error) {
	return PositionType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PrintDuplex: see also gtk_print_settings_set_duplex().
type PrintDuplex int

const (
	// PrintDuplexSimplex: no duplex.
	PrintDuplexSimplex PrintDuplex = 0
	// PrintDuplexHorizontal: horizontal duplex.
	PrintDuplexHorizontal PrintDuplex = 1
	// PrintDuplexVertical: vertical duplex.
	PrintDuplexVertical PrintDuplex = 2
)

func marshalPrintDuplex(p uintptr) (interface{}, error) {
	return PrintDuplex(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PrintError: error codes that identify various errors that can occur while
// using the GTK printing support.
type PrintError int

const (
	// PrintErrorGeneral: an unspecified error occurred.
	PrintErrorGeneral PrintError = 0
	// PrintErrorInternalError: an internal error occurred.
	PrintErrorInternalError PrintError = 1
	// PrintErrorNOMEM: a memory allocation failed.
	PrintErrorNOMEM PrintError = 2
	// PrintErrorInvalidFile: an error occurred while loading a page setup or
	// paper size from a key file.
	PrintErrorInvalidFile PrintError = 3
)

func marshalPrintError(p uintptr) (interface{}, error) {
	return PrintError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PrintOperationAction determines what action the print operation should
// perform.
//
// A parameter of this typs is passed to [method@Gtk.PrintOperation.run].
type PrintOperationAction int

const (
	// PrintOperationActionPrintDialog: show the print dialog.
	PrintOperationActionPrintDialog PrintOperationAction = 0
	// PrintOperationActionPrint: start to print without showing the print
	// dialog, based on the current print settings.
	PrintOperationActionPrint PrintOperationAction = 1
	// PrintOperationActionPreview: show the print preview.
	PrintOperationActionPreview PrintOperationAction = 2
	// PrintOperationActionExport: export to a file. This requires the
	// export-filename property to be set.
	PrintOperationActionExport PrintOperationAction = 3
)

func marshalPrintOperationAction(p uintptr) (interface{}, error) {
	return PrintOperationAction(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PrintOperationResult: the result of a print operation.
//
// A value of this type is returned by [method@Gtk.PrintOperation.run].
type PrintOperationResult int

const (
	// PrintOperationResultError: an error has occurred.
	PrintOperationResultError PrintOperationResult = 0
	// PrintOperationResultApply: the print settings should be stored.
	PrintOperationResultApply PrintOperationResult = 1
	// PrintOperationResultCancel: the print operation has been canceled, the
	// print settings should not be stored.
	PrintOperationResultCancel PrintOperationResult = 2
	// PrintOperationResultInProgress: the print operation is not complete yet.
	// This value will only be returned when running asynchronously.
	PrintOperationResultInProgress PrintOperationResult = 3
)

func marshalPrintOperationResult(p uintptr) (interface{}, error) {
	return PrintOperationResult(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PrintPages: see also gtk_print_job_set_pages()
type PrintPages int

const (
	// PrintPagesAll: all pages.
	PrintPagesAll PrintPages = 0
	// PrintPagesCurrent: current page.
	PrintPagesCurrent PrintPages = 1
	// PrintPagesRanges: range of pages.
	PrintPagesRanges PrintPages = 2
	// PrintPagesSelection: selected pages.
	PrintPagesSelection PrintPages = 3
)

func marshalPrintPages(p uintptr) (interface{}, error) {
	return PrintPages(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PrintQuality: see also gtk_print_settings_set_quality().
type PrintQuality int

const (
	// PrintQualityLow: low quality.
	PrintQualityLow PrintQuality = 0
	// PrintQualityNormal: normal quality.
	PrintQualityNormal PrintQuality = 1
	// PrintQualityHigh: high quality.
	PrintQualityHigh PrintQuality = 2
	// PrintQualityDraft: draft quality.
	PrintQualityDraft PrintQuality = 3
)

func marshalPrintQuality(p uintptr) (interface{}, error) {
	return PrintQuality(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PrintStatus: the status gives a rough indication of the completion of a
// running print operation.
type PrintStatus int

const (
	// PrintStatusInitial: the printing has not started yet; this status is set
	// initially, and while the print dialog is shown.
	PrintStatusInitial PrintStatus = 0
	// PrintStatusPreparing: this status is set while the begin-print signal is
	// emitted and during pagination.
	PrintStatusPreparing PrintStatus = 1
	// PrintStatusGeneratingData: this status is set while the pages are being
	// rendered.
	PrintStatusGeneratingData PrintStatus = 2
	// PrintStatusSendingData: the print job is being sent off to the printer.
	PrintStatusSendingData PrintStatus = 3
	// PrintStatusPending: the print job has been sent to the printer, but is
	// not printed for some reason, e.g. the printer may be stopped.
	PrintStatusPending PrintStatus = 4
	// PrintStatusPendingIssue: some problem has occurred during printing, e.g.
	// a paper jam.
	PrintStatusPendingIssue PrintStatus = 5
	// PrintStatusPrinting: the printer is processing the print job.
	PrintStatusPrinting PrintStatus = 6
	// PrintStatusFinished: the printing has been completed successfully.
	PrintStatusFinished PrintStatus = 7
	// PrintStatusFinishedAborted: the printing has been aborted.
	PrintStatusFinishedAborted PrintStatus = 8
)

func marshalPrintStatus(p uintptr) (interface{}, error) {
	return PrintStatus(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PropagationLimit describes limits of a `GtkEventController` for handling
// events targeting other widgets.
type PropagationLimit int

const (
	// PropagationLimitNone events are handled regardless of what their target
	// is.
	PropagationLimitNone PropagationLimit = 0
	// PropagationLimitSameNative events are only handled if their target is in
	// the same Native as the event controllers widget. Note that some event
	// types have two targets (origin and destination).
	PropagationLimitSameNative PropagationLimit = 1
)

func marshalPropagationLimit(p uintptr) (interface{}, error) {
	return PropagationLimit(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PropagationPhase describes the stage at which events are fed into a
// `GtkEventController`.
type PropagationPhase int

const (
	// PropagationPhaseNone events are not delivered.
	PropagationPhaseNone PropagationPhase = 0
	// PropagationPhaseCapture events are delivered in the capture phase. The
	// capture phase happens before the bubble phase, runs from the toplevel
	// down to the event widget. This option should only be used on containers
	// that might possibly handle events before their children do.
	PropagationPhaseCapture PropagationPhase = 1
	// PropagationPhaseBubble events are delivered in the bubble phase. The
	// bubble phase happens after the capture phase, and before the default
	// handlers are run. This phase runs from the event widget, up to the
	// toplevel.
	PropagationPhaseBubble PropagationPhase = 2
	// PropagationPhaseTarget events are delivered in the default widget event
	// handlers, note that widget implementations must chain up on button,
	// motion, touch and grab broken handlers for controllers in this phase to
	// be run.
	PropagationPhaseTarget PropagationPhase = 3
)

func marshalPropagationPhase(p uintptr) (interface{}, error) {
	return PropagationPhase(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// RecentManagerError: error codes for RecentManager operations
type RecentManagerError int

const (
	// RecentManagerErrorNotFound: the URI specified does not exists in the
	// recently used resources list.
	RecentManagerErrorNotFound RecentManagerError = 0
	// RecentManagerErrorInvalidURI: the URI specified is not valid.
	RecentManagerErrorInvalidURI RecentManagerError = 1
	// RecentManagerErrorInvalidEncoding: the supplied string is not UTF-8
	// encoded.
	RecentManagerErrorInvalidEncoding RecentManagerError = 2
	// RecentManagerErrorNotRegistered: no application has registered the
	// specified item.
	RecentManagerErrorNotRegistered RecentManagerError = 3
	// RecentManagerErrorRead: failure while reading the recently used resources
	// file.
	RecentManagerErrorRead RecentManagerError = 4
	// RecentManagerErrorWrite: failure while writing the recently used
	// resources file.
	RecentManagerErrorWrite RecentManagerError = 5
	// RecentManagerErrorUnknown: unspecified error.
	RecentManagerErrorUnknown RecentManagerError = 6
)

func marshalRecentManagerError(p uintptr) (interface{}, error) {
	return RecentManagerError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ResponseType: predefined values for use as response ids in
// gtk_dialog_add_button().
//
// All predefined values are negative; GTK leaves values of 0 or greater for
// application-defined response ids.
type ResponseType int

const (
	// ResponseTypeNone: returned if an action widget has no response id, or if
	// the dialog gets programmatically hidden or destroyed
	ResponseTypeNone ResponseType = -1
	// ResponseTypeReject: generic response id, not used by GTK dialogs
	ResponseTypeReject ResponseType = -2
	// ResponseTypeAccept: generic response id, not used by GTK dialogs
	ResponseTypeAccept ResponseType = -3
	// ResponseTypeDeleteEvent: returned if the dialog is deleted
	ResponseTypeDeleteEvent ResponseType = -4
	// ResponseTypeOk: returned by OK buttons in GTK dialogs
	ResponseTypeOk ResponseType = -5
	// ResponseTypeCancel: returned by Cancel buttons in GTK dialogs
	ResponseTypeCancel ResponseType = -6
	// ResponseTypeClose: returned by Close buttons in GTK dialogs
	ResponseTypeClose ResponseType = -7
	// ResponseTypeYes: returned by Yes buttons in GTK dialogs
	ResponseTypeYes ResponseType = -8
	// ResponseTypeNo: returned by No buttons in GTK dialogs
	ResponseTypeNo ResponseType = -9
	// ResponseTypeApply: returned by Apply buttons in GTK dialogs
	ResponseTypeApply ResponseType = -10
	// ResponseTypeHelp: returned by Help buttons in GTK dialogs
	ResponseTypeHelp ResponseType = -11
)

func marshalResponseType(p uintptr) (interface{}, error) {
	return ResponseType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// RevealerTransitionType: these enumeration values describe the possible
// transitions when the child of a `GtkRevealer` widget is shown or hidden.
type RevealerTransitionType int

const (
	// RevealerTransitionTypeNone: no transition
	RevealerTransitionTypeNone RevealerTransitionType = 0
	// RevealerTransitionTypeCrossfade: fade in
	RevealerTransitionTypeCrossfade RevealerTransitionType = 1
	// RevealerTransitionTypeSlideRight: slide in from the left
	RevealerTransitionTypeSlideRight RevealerTransitionType = 2
	// RevealerTransitionTypeSlideLeft: slide in from the right
	RevealerTransitionTypeSlideLeft RevealerTransitionType = 3
	// RevealerTransitionTypeSlideUp: slide in from the bottom
	RevealerTransitionTypeSlideUp RevealerTransitionType = 4
	// RevealerTransitionTypeSlideDown: slide in from the top
	RevealerTransitionTypeSlideDown RevealerTransitionType = 5
	// RevealerTransitionTypeSwingRight: floop in from the left
	RevealerTransitionTypeSwingRight RevealerTransitionType = 6
	// RevealerTransitionTypeSwingLeft: floop in from the right
	RevealerTransitionTypeSwingLeft RevealerTransitionType = 7
	// RevealerTransitionTypeSwingUp: floop in from the bottom
	RevealerTransitionTypeSwingUp RevealerTransitionType = 8
	// RevealerTransitionTypeSwingDown: floop in from the top
	RevealerTransitionTypeSwingDown RevealerTransitionType = 9
)

func marshalRevealerTransitionType(p uintptr) (interface{}, error) {
	return RevealerTransitionType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ScrollStep: passed as argument to various keybinding signals.
type ScrollStep int

const (
	// ScrollStepSteps: scroll in steps.
	ScrollStepSteps ScrollStep = 0
	// ScrollStepPages: scroll by pages.
	ScrollStepPages ScrollStep = 1
	// ScrollStepEnds: scroll to ends.
	ScrollStepEnds ScrollStep = 2
	// ScrollStepHorizontalSteps: scroll in horizontal steps.
	ScrollStepHorizontalSteps ScrollStep = 3
	// ScrollStepHorizontalPages: scroll by horizontal pages.
	ScrollStepHorizontalPages ScrollStep = 4
	// ScrollStepHorizontalEnds: scroll to the horizontal ends.
	ScrollStepHorizontalEnds ScrollStep = 5
)

func marshalScrollStep(p uintptr) (interface{}, error) {
	return ScrollStep(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ScrollType: scrolling types.
type ScrollType int

const (
	// ScrollTypeNone: no scrolling.
	ScrollTypeNone ScrollType = 0
	// ScrollTypeJump: jump to new location.
	ScrollTypeJump ScrollType = 1
	// ScrollTypeStepBackward: step backward.
	ScrollTypeStepBackward ScrollType = 2
	// ScrollTypeStepForward: step forward.
	ScrollTypeStepForward ScrollType = 3
	// ScrollTypePageBackward: page backward.
	ScrollTypePageBackward ScrollType = 4
	// ScrollTypePageForward: page forward.
	ScrollTypePageForward ScrollType = 5
	// ScrollTypeStepUp: step up.
	ScrollTypeStepUp ScrollType = 6
	// ScrollTypeStepDown: step down.
	ScrollTypeStepDown ScrollType = 7
	// ScrollTypePageUp: page up.
	ScrollTypePageUp ScrollType = 8
	// ScrollTypePageDown: page down.
	ScrollTypePageDown ScrollType = 9
	// ScrollTypeStepLeft: step to the left.
	ScrollTypeStepLeft ScrollType = 10
	// ScrollTypeStepRight: step to the right.
	ScrollTypeStepRight ScrollType = 11
	// ScrollTypePageLeft: page to the left.
	ScrollTypePageLeft ScrollType = 12
	// ScrollTypePageRight: page to the right.
	ScrollTypePageRight ScrollType = 13
	// ScrollTypeStart: scroll to start.
	ScrollTypeStart ScrollType = 14
	// ScrollTypeEnd: scroll to end.
	ScrollTypeEnd ScrollType = 15
)

func marshalScrollType(p uintptr) (interface{}, error) {
	return ScrollType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ScrollablePolicy defines the policy to be used in a scrollable widget when
// updating the scrolled window adjustments in a given orientation.
type ScrollablePolicy int

const (
	// ScrollablePolicyMinimum: scrollable adjustments are based on the minimum
	// size
	ScrollablePolicyMinimum ScrollablePolicy = 0
	// ScrollablePolicyNatural: scrollable adjustments are based on the natural
	// size
	ScrollablePolicyNatural ScrollablePolicy = 1
)

func marshalScrollablePolicy(p uintptr) (interface{}, error) {
	return ScrollablePolicy(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SelectionMode: used to control what selections users are allowed to make.
type SelectionMode int

const (
	// SelectionModeNone: no selection is possible.
	SelectionModeNone SelectionMode = 0
	// SelectionModeSingle: zero or one element may be selected.
	SelectionModeSingle SelectionMode = 1
	// SelectionModeBrowse: exactly one element is selected. In some
	// circumstances, such as initially or during a search operation, it’s
	// possible for no element to be selected with GTK_SELECTION_BROWSE. What is
	// really enforced is that the user can’t deselect a currently selected
	// element except by selecting another element.
	SelectionModeBrowse SelectionMode = 2
	// SelectionModeMultiple: any number of elements may be selected. The Ctrl
	// key may be used to enlarge the selection, and Shift key to select between
	// the focus and the child pointed to. Some widgets may also allow
	// Click-drag to select a range of elements.
	SelectionModeMultiple SelectionMode = 3
)

func marshalSelectionMode(p uintptr) (interface{}, error) {
	return SelectionMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SensitivityType determines how GTK handles the sensitivity of various
// controls, such as combo box buttons.
type SensitivityType int

const (
	// SensitivityTypeAuto: the control is made insensitive if no action can be
	// triggered
	SensitivityTypeAuto SensitivityType = 0
	// SensitivityTypeOn: the control is always sensitive
	SensitivityTypeOn SensitivityType = 1
	// SensitivityTypeOff: the control is always insensitive
	SensitivityTypeOff SensitivityType = 2
)

func marshalSensitivityType(p uintptr) (interface{}, error) {
	return SensitivityType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ShortcutScope describes where `GtkShortcut`s added to a
// `GtkShortcutController` get handled.
type ShortcutScope int

const (
	// ShortcutScopeLocal shortcuts are handled inside the widget the controller
	// belongs to.
	ShortcutScopeLocal ShortcutScope = 0
	// ShortcutScopeManaged shortcuts are handled by the first ancestor that is
	// a ShortcutManager
	ShortcutScopeManaged ShortcutScope = 1
	// ShortcutScopeGlobal shortcuts are handled by the root widget.
	ShortcutScopeGlobal ShortcutScope = 2
)

func marshalShortcutScope(p uintptr) (interface{}, error) {
	return ShortcutScope(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ShortcutType: gtkShortcutType specifies the kind of shortcut that is being
// described.
//
// More values may be added to this enumeration over time.
type ShortcutType int

const (
	// ShortcutTypeAccelerator: the shortcut is a keyboard accelerator. The
	// GtkShortcutsShortcut:accelerator property will be used.
	ShortcutTypeAccelerator ShortcutType = 0
	// ShortcutTypeGesturePinch: the shortcut is a pinch gesture. GTK provides
	// an icon and subtitle.
	ShortcutTypeGesturePinch ShortcutType = 1
	// ShortcutTypeGestureStretch: the shortcut is a stretch gesture. GTK
	// provides an icon and subtitle.
	ShortcutTypeGestureStretch ShortcutType = 2
	// ShortcutTypeGestureRotateClockwise: the shortcut is a clockwise rotation
	// gesture. GTK provides an icon and subtitle.
	ShortcutTypeGestureRotateClockwise ShortcutType = 3
	// ShortcutTypeGestureRotateCounterclockwise: the shortcut is a
	// counterclockwise rotation gesture. GTK provides an icon and subtitle.
	ShortcutTypeGestureRotateCounterclockwise ShortcutType = 4
	// ShortcutTypeGestureTwoFingerSwipeLeft: the shortcut is a two-finger swipe
	// gesture. GTK provides an icon and subtitle.
	ShortcutTypeGestureTwoFingerSwipeLeft ShortcutType = 5
	// ShortcutTypeGestureTwoFingerSwipeRight: the shortcut is a two-finger
	// swipe gesture. GTK provides an icon and subtitle.
	ShortcutTypeGestureTwoFingerSwipeRight ShortcutType = 6
	// ShortcutTypeGesture: the shortcut is a gesture. The
	// GtkShortcutsShortcut:icon property will be used.
	ShortcutTypeGesture ShortcutType = 7
	// ShortcutTypeGestureSwipeLeft: the shortcut is a swipe gesture. GTK
	// provides an icon and subtitle.
	ShortcutTypeGestureSwipeLeft ShortcutType = 8
	// ShortcutTypeGestureSwipeRight: the shortcut is a swipe gesture. GTK
	// provides an icon and subtitle.
	ShortcutTypeGestureSwipeRight ShortcutType = 9
)

func marshalShortcutType(p uintptr) (interface{}, error) {
	return ShortcutType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SizeGroupMode: the mode of the size group determines the directions in which
// the size group affects the requested sizes of its component widgets.
type SizeGroupMode int

const (
	// SizeGroupModeNone: group has no effect
	SizeGroupModeNone SizeGroupMode = 0
	// SizeGroupModeHorizontal: group affects horizontal requisition
	SizeGroupModeHorizontal SizeGroupMode = 1
	// SizeGroupModeVertical: group affects vertical requisition
	SizeGroupModeVertical SizeGroupMode = 2
	// SizeGroupModeBoth: group affects both horizontal and vertical requisition
	SizeGroupModeBoth SizeGroupMode = 3
)

func marshalSizeGroupMode(p uintptr) (interface{}, error) {
	return SizeGroupMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SizeRequestMode specifies a preference for height-for-width or
// width-for-height geometry management.
type SizeRequestMode int

const (
	// SizeRequestModeHeightForWidth: prefer height-for-width geometry
	// management
	SizeRequestModeHeightForWidth SizeRequestMode = 0
	// SizeRequestModeWidthForHeight: prefer width-for-height geometry
	// management
	SizeRequestModeWidthForHeight SizeRequestMode = 1
	// SizeRequestModeConstantSize: don’t trade height-for-width or
	// width-for-height
	SizeRequestModeConstantSize SizeRequestMode = 2
)

func marshalSizeRequestMode(p uintptr) (interface{}, error) {
	return SizeRequestMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SortType determines the direction of a sort.
type SortType int

const (
	// SortTypeAscending: sorting is in ascending order.
	SortTypeAscending SortType = 0
	// SortTypeDescending: sorting is in descending order.
	SortTypeDescending SortType = 1
)

func marshalSortType(p uintptr) (interface{}, error) {
	return SortType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SorterChange describes changes in a sorter in more detail and allows users to
// optimize resorting.
type SorterChange int

const (
	// SorterChangeDifferent: the sorter change cannot be described by any of
	// the other enumeration values
	SorterChangeDifferent SorterChange = 0
	// SorterChangeInverted: the sort order was inverted. Comparisons that
	// returned GTK_ORDERING_SMALLER now return GTK_ORDERING_LARGER and vice
	// versa. Other comparisons return the same values as before.
	SorterChangeInverted SorterChange = 1
	// SorterChangeLessStrict: the sorter is less strict: Comparisons may now
	// return GTK_ORDERING_EQUAL that did not do so before.
	SorterChangeLessStrict SorterChange = 2
	// SorterChangeMoreStrict: the sorter is more strict: Comparisons that did
	// return GTK_ORDERING_EQUAL may not do so anymore.
	SorterChangeMoreStrict SorterChange = 3
)

func marshalSorterChange(p uintptr) (interface{}, error) {
	return SorterChange(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SorterOrder describes the type of order that a `GtkSorter` may produce.
type SorterOrder int

const (
	// SorterOrderPartial: a partial order. Any Ordering is possible.
	SorterOrderPartial SorterOrder = 0
	// SorterOrderNone: no order, all elements are considered equal.
	// gtk_sorter_compare() will only return GTK_ORDERING_EQUAL.
	SorterOrderNone SorterOrder = 1
	// SorterOrderTotal: a total order. gtk_sorter_compare() will only return
	// GTK_ORDERING_EQUAL if an item is compared with itself. Two different
	// items will never cause this value to be returned.
	SorterOrderTotal SorterOrder = 2
)

func marshalSorterOrder(p uintptr) (interface{}, error) {
	return SorterOrder(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SpinButtonUpdatePolicy determines whether the spin button displays values
// outside the adjustment bounds.
//
// See [method@Gtk.SpinButton.set_update_policy].
type SpinButtonUpdatePolicy int

const (
	// SpinButtonUpdatePolicyAlways: when refreshing your SpinButton, the value
	// is always displayed
	SpinButtonUpdatePolicyAlways SpinButtonUpdatePolicy = 0
	// SpinButtonUpdatePolicyIfValid: when refreshing your SpinButton, the value
	// is only displayed if it is valid within the bounds of the spin button's
	// adjustment
	SpinButtonUpdatePolicyIfValid SpinButtonUpdatePolicy = 1
)

func marshalSpinButtonUpdatePolicy(p uintptr) (interface{}, error) {
	return SpinButtonUpdatePolicy(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SpinType: the values of the GtkSpinType enumeration are used to specify the
// change to make in gtk_spin_button_spin().
type SpinType int

const (
	// SpinTypeStepForward: increment by the adjustments step increment.
	SpinTypeStepForward SpinType = 0
	// SpinTypeStepBackward: decrement by the adjustments step increment.
	SpinTypeStepBackward SpinType = 1
	// SpinTypePageForward: increment by the adjustments page increment.
	SpinTypePageForward SpinType = 2
	// SpinTypePageBackward: decrement by the adjustments page increment.
	SpinTypePageBackward SpinType = 3
	// SpinTypeHome: go to the adjustments lower bound.
	SpinTypeHome SpinType = 4
	// SpinTypeEnd: go to the adjustments upper bound.
	SpinTypeEnd SpinType = 5
	// SpinTypeUserDefined: change by a specified amount.
	SpinTypeUserDefined SpinType = 6
)

func marshalSpinType(p uintptr) (interface{}, error) {
	return SpinType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// StackTransitionType: possible transitions between pages in a `GtkStack`
// widget.
//
// New values may be added to this enumeration over time.
type StackTransitionType int

const (
	// StackTransitionTypeNone: no transition
	StackTransitionTypeNone StackTransitionType = 0
	// StackTransitionTypeCrossfade: a cross-fade
	StackTransitionTypeCrossfade StackTransitionType = 1
	// StackTransitionTypeSlideRight: slide from left to right
	StackTransitionTypeSlideRight StackTransitionType = 2
	// StackTransitionTypeSlideLeft: slide from right to left
	StackTransitionTypeSlideLeft StackTransitionType = 3
	// StackTransitionTypeSlideUp: slide from bottom up
	StackTransitionTypeSlideUp StackTransitionType = 4
	// StackTransitionTypeSlideDown: slide from top down
	StackTransitionTypeSlideDown StackTransitionType = 5
	// StackTransitionTypeSlideLeftRight: slide from left or right according to
	// the children order
	StackTransitionTypeSlideLeftRight StackTransitionType = 6
	// StackTransitionTypeSlideUpDown: slide from top down or bottom up
	// according to the order
	StackTransitionTypeSlideUpDown StackTransitionType = 7
	// StackTransitionTypeOverUp: cover the old page by sliding up
	StackTransitionTypeOverUp StackTransitionType = 8
	// StackTransitionTypeOverDown: cover the old page by sliding down
	StackTransitionTypeOverDown StackTransitionType = 9
	// StackTransitionTypeOverLeft: cover the old page by sliding to the left
	StackTransitionTypeOverLeft StackTransitionType = 10
	// StackTransitionTypeOverRight: cover the old page by sliding to the right
	StackTransitionTypeOverRight StackTransitionType = 11
	// StackTransitionTypeUnderUp: uncover the new page by sliding up
	StackTransitionTypeUnderUp StackTransitionType = 12
	// StackTransitionTypeUnderDown: uncover the new page by sliding down
	StackTransitionTypeUnderDown StackTransitionType = 13
	// StackTransitionTypeUnderLeft: uncover the new page by sliding to the left
	StackTransitionTypeUnderLeft StackTransitionType = 14
	// StackTransitionTypeUnderRight: uncover the new page by sliding to the
	// right
	StackTransitionTypeUnderRight StackTransitionType = 15
	// StackTransitionTypeOverUpDown: cover the old page sliding up or uncover
	// the new page sliding down, according to order
	StackTransitionTypeOverUpDown StackTransitionType = 16
	// StackTransitionTypeOverDownUp: cover the old page sliding down or uncover
	// the new page sliding up, according to order
	StackTransitionTypeOverDownUp StackTransitionType = 17
	// StackTransitionTypeOverLeftRight: cover the old page sliding left or
	// uncover the new page sliding right, according to order
	StackTransitionTypeOverLeftRight StackTransitionType = 18
	// StackTransitionTypeOverRightLeft: cover the old page sliding right or
	// uncover the new page sliding left, according to order
	StackTransitionTypeOverRightLeft StackTransitionType = 19
	// StackTransitionTypeRotateLeft: pretend the pages are sides of a cube and
	// rotate that cube to the left
	StackTransitionTypeRotateLeft StackTransitionType = 20
	// StackTransitionTypeRotateRight: pretend the pages are sides of a cube and
	// rotate that cube to the right
	StackTransitionTypeRotateRight StackTransitionType = 21
	// StackTransitionTypeRotateLeftRight: pretend the pages are sides of a cube
	// and rotate that cube to the left or right according to the children order
	StackTransitionTypeRotateLeftRight StackTransitionType = 22
)

func marshalStackTransitionType(p uintptr) (interface{}, error) {
	return StackTransitionType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// StringFilterMatchMode specifies how search strings are matched inside text.
type StringFilterMatchMode int

const (
	// StringFilterMatchModeExact: the search string and text must match
	// exactly.
	StringFilterMatchModeExact StringFilterMatchMode = 0
	// StringFilterMatchModeSubstring: the search string must be contained as a
	// substring inside the text.
	StringFilterMatchModeSubstring StringFilterMatchMode = 1
	// StringFilterMatchModePrefix: the text must begin with the search string.
	StringFilterMatchModePrefix StringFilterMatchMode = 2
)

func marshalStringFilterMatchMode(p uintptr) (interface{}, error) {
	return StringFilterMatchMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SystemSetting values that can be passed to the
// GtkWidgetClass.system_setting_changed vfunc.
//
// The values indicate which system setting has changed. Widgets may need to
// drop caches, or react otherwise.
//
// Most of the values correspond to `GtkSettings` properties.
//
// More values may be added over time.
type SystemSetting int

const (
	// SystemSettingDPI: the Settings:gtk-xft-dpi setting has changed
	SystemSettingDPI SystemSetting = 0
	// SystemSettingFontName: the Settings:gtk-font-name setting has changed
	SystemSettingFontName SystemSetting = 1
	// SystemSettingFontConfig: the font configuration has changed in a way that
	// requires text to be redrawn. This can be any of the
	// Settings:gtk-xft-antialias, Settings:gtk-xft-hinting,
	// Settings:gtk-xft-hintstyle, Settings:gtk-xft-rgba or
	// Settings:gtk-fontconfig-timestamp settings
	SystemSettingFontConfig SystemSetting = 2
	// SystemSettingDisplay: the display has changed
	SystemSettingDisplay SystemSetting = 3
	// SystemSettingIconTheme: the icon theme has changed in a way that requires
	// icons to be looked up again
	SystemSettingIconTheme SystemSetting = 4
)

func marshalSystemSetting(p uintptr) (interface{}, error) {
	return SystemSetting(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TextDirection: reading directions for text.
type TextDirection int

const (
	// TextDirectionNone: no direction.
	TextDirectionNone TextDirection = 0
	// TextDirectionLTR: left to right text direction.
	TextDirectionLTR TextDirection = 1
	// TextDirectionRTL: right to left text direction.
	TextDirectionRTL TextDirection = 2
)

func marshalTextDirection(p uintptr) (interface{}, error) {
	return TextDirection(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TextExtendSelection: granularity types that extend the text selection. Use
// the TextView::extend-selection signal to customize the selection.
type TextExtendSelection int

const (
	// TextExtendSelectionWord selects the current word. It is triggered by a
	// double-click for example.
	TextExtendSelectionWord TextExtendSelection = 0
	// TextExtendSelectionLine selects the current line. It is triggered by a
	// triple-click for example.
	TextExtendSelectionLine TextExtendSelection = 1
)

func marshalTextExtendSelection(p uintptr) (interface{}, error) {
	return TextExtendSelection(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TextViewLayer: used to reference the layers of TextView for the purpose of
// customized drawing with the ::snapshot_layer vfunc.
type TextViewLayer int

const (
	// TextViewLayerBelowText: the layer rendered below the text (but above the
	// background).
	TextViewLayerBelowText TextViewLayer = 0
	// TextViewLayerAboveText: the layer rendered above the text.
	TextViewLayerAboveText TextViewLayer = 1
)

func marshalTextViewLayer(p uintptr) (interface{}, error) {
	return TextViewLayer(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TextWindowType: used to reference the parts of TextView.
type TextWindowType int

const (
	// TextWindowTypeWidget: window that floats over scrolling areas.
	TextWindowTypeWidget TextWindowType = 1
	// TextWindowTypeText: scrollable text window.
	TextWindowTypeText TextWindowType = 2
	// TextWindowTypeLeft: left side border window.
	TextWindowTypeLeft TextWindowType = 3
	// TextWindowTypeRight: right side border window.
	TextWindowTypeRight TextWindowType = 4
	// TextWindowTypeTop: top border window.
	TextWindowTypeTop TextWindowType = 5
	// TextWindowTypeBottom: bottom border window.
	TextWindowTypeBottom TextWindowType = 6
)

func marshalTextWindowType(p uintptr) (interface{}, error) {
	return TextWindowType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TreeViewColumnSizing: the sizing method the column uses to determine its
// width. Please note that GTK_TREE_VIEW_COLUMN_AUTOSIZE are inefficient for
// large views, and can make columns appear choppy.
type TreeViewColumnSizing int

const (
	// TreeViewColumnSizingGrowOnly columns only get bigger in reaction to
	// changes in the model
	TreeViewColumnSizingGrowOnly TreeViewColumnSizing = 0
	// TreeViewColumnSizingAutosize columns resize to be the optimal size every
	// time the model changes.
	TreeViewColumnSizingAutosize TreeViewColumnSizing = 1
	// TreeViewColumnSizingFixed columns are a fixed numbers of pixels wide.
	TreeViewColumnSizingFixed TreeViewColumnSizing = 2
)

func marshalTreeViewColumnSizing(p uintptr) (interface{}, error) {
	return TreeViewColumnSizing(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TreeViewDropPosition: an enum for determining where a dropped row goes.
type TreeViewDropPosition int

const (
	// TreeViewDropPositionBefore: dropped row is inserted before
	TreeViewDropPositionBefore TreeViewDropPosition = 0
	// TreeViewDropPositionAfter: dropped row is inserted after
	TreeViewDropPositionAfter TreeViewDropPosition = 1
	// TreeViewDropPositionIntoOrBefore: dropped row becomes a child or is
	// inserted before
	TreeViewDropPositionIntoOrBefore TreeViewDropPosition = 2
	// TreeViewDropPositionIntoOrAfter: dropped row becomes a child or is
	// inserted after
	TreeViewDropPositionIntoOrAfter TreeViewDropPosition = 3
)

func marshalTreeViewDropPosition(p uintptr) (interface{}, error) {
	return TreeViewDropPosition(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TreeViewGridLines: used to indicate which grid lines to draw in a tree view.
type TreeViewGridLines int

const (
	// TreeViewGridLinesNone: no grid lines.
	TreeViewGridLinesNone TreeViewGridLines = 0
	// TreeViewGridLinesHorizontal: horizontal grid lines.
	TreeViewGridLinesHorizontal TreeViewGridLines = 1
	// TreeViewGridLinesVertical: vertical grid lines.
	TreeViewGridLinesVertical TreeViewGridLines = 2
	// TreeViewGridLinesBoth: horizontal and vertical grid lines.
	TreeViewGridLinesBoth TreeViewGridLines = 3
)

func marshalTreeViewGridLines(p uintptr) (interface{}, error) {
	return TreeViewGridLines(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// Unit: see also gtk_print_settings_set_paper_width().
type Unit int

const (
	// UnitNone: no units.
	UnitNone Unit = 0
	// UnitPoints dimensions in points.
	UnitPoints Unit = 1
	// UnitInch dimensions in inches.
	UnitInch Unit = 2
	// UnitMm dimensions in millimeters
	UnitMm Unit = 3
)

func marshalUnit(p uintptr) (interface{}, error) {
	return Unit(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// WrapMode describes a type of line wrapping.
type WrapMode int

const (
	// WrapModeNone: do not wrap lines; just make the text area wider
	WrapModeNone WrapMode = 0
	// WrapModeChar: wrap text, breaking lines anywhere the cursor can appear
	// (between characters, usually - if you want to be technical, between
	// graphemes, see pango_get_log_attrs())
	WrapModeChar WrapMode = 1
	// WrapModeWord: wrap text, breaking lines in between words
	WrapModeWord WrapMode = 2
	// WrapModeWordChar: wrap text, breaking lines in between words, or if that
	// is not enough, also between graphemes
	WrapModeWordChar WrapMode = 3
)

func marshalWrapMode(p uintptr) (interface{}, error) {
	return WrapMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ApplicationInhibitFlags types of user actions that may be blocked by
// `GtkApplication`.
//
// See [method@Gtk.Application.inhibit].
type ApplicationInhibitFlags int

const (
	// ApplicationInhibitFlagsLogout: inhibit ending the user session by logging
	// out or by shutting down the computer
	ApplicationInhibitFlagsLogout ApplicationInhibitFlags = 1
	// ApplicationInhibitFlagsSwitch: inhibit user switching
	ApplicationInhibitFlagsSwitch ApplicationInhibitFlags = 2
	// ApplicationInhibitFlagsSuspend: inhibit suspending the session or
	// computer
	ApplicationInhibitFlagsSuspend ApplicationInhibitFlags = 4
	// ApplicationInhibitFlagsIdle: inhibit the session being marked as idle
	// (and possibly locked)
	ApplicationInhibitFlagsIdle ApplicationInhibitFlags = 8
)

func marshalApplicationInhibitFlags(p uintptr) (interface{}, error) {
	return ApplicationInhibitFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// BuilderClosureFlags: the list of flags that can be passed to
// gtk_builder_create_closure().
//
// New values may be added in the future for new features, so external
// implementations of [interface@Gtk.BuilderScope] should test the flags for
// unknown values and raise a GTK_BUILDER_ERROR_INVALID_ATTRIBUTE error when
// they encounter one.
type BuilderClosureFlags int

const (
	// BuilderClosureFlagsSwapped: the closure should be created swapped. See
	// g_cclosure_new_swap() for details.
	BuilderClosureFlagsSwapped BuilderClosureFlags = 1
)

func marshalBuilderClosureFlags(p uintptr) (interface{}, error) {
	return BuilderClosureFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// CellRendererState tells how a cell is to be rendered.
type CellRendererState int

const (
	// CellRendererStateSelected: the cell is currently selected, and probably
	// has a selection colored background to render to.
	CellRendererStateSelected CellRendererState = 1
	// CellRendererStatePrelit: the mouse is hovering over the cell.
	CellRendererStatePrelit CellRendererState = 2
	// CellRendererStateInsensitive: the cell is drawn in an insensitive manner
	CellRendererStateInsensitive CellRendererState = 4
	// CellRendererStateSorted: the cell is in a sorted row
	CellRendererStateSorted CellRendererState = 8
	// CellRendererStateFocused: the cell is in the focus row.
	CellRendererStateFocused CellRendererState = 16
	// CellRendererStateExpandable: the cell is in a row that can be expanded
	CellRendererStateExpandable CellRendererState = 32
	// CellRendererStateExpanded: the cell is in a row that is expanded
	CellRendererStateExpanded CellRendererState = 64
)

func marshalCellRendererState(p uintptr) (interface{}, error) {
	return CellRendererState(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

type DebugFlags int

const (
	DebugFlagsText           DebugFlags = 1
	DebugFlagsTree           DebugFlags = 2
	DebugFlagsKeybindings    DebugFlags = 4
	DebugFlagsModules        DebugFlags = 8
	DebugFlagsGeometry       DebugFlags = 16
	DebugFlagsIcontheme      DebugFlags = 32
	DebugFlagsPrinting       DebugFlags = 64
	DebugFlagsBuilder        DebugFlags = 128
	DebugFlagsSizeRequest    DebugFlags = 256
	DebugFlagsNoCSSCache     DebugFlags = 512
	DebugFlagsInteractive    DebugFlags = 1024
	DebugFlagsTouchscreen    DebugFlags = 2048
	DebugFlagsActions        DebugFlags = 4096
	DebugFlagsLayout         DebugFlags = 8192
	DebugFlagsSnapshot       DebugFlags = 16384
	DebugFlagsConstraints    DebugFlags = 32768
	DebugFlagsBuilderObjects DebugFlags = 65536
	DebugFlagsA11Y           DebugFlags = 131072
	DebugFlagsIconfallback   DebugFlags = 262144
)

func marshalDebugFlags(p uintptr) (interface{}, error) {
	return DebugFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DialogFlags flags used to influence dialog construction.
type DialogFlags int

const (
	// DialogFlagsModal: make the constructed dialog modal
	DialogFlagsModal DialogFlags = 1
	// DialogFlagsDestroyWithParent: destroy the dialog when its parent is
	// destroyed
	DialogFlagsDestroyWithParent DialogFlags = 2
	// DialogFlagsUseHeaderBar: create dialog with actions in header bar instead
	// of action area
	DialogFlagsUseHeaderBar DialogFlags = 4
)

func marshalDialogFlags(p uintptr) (interface{}, error) {
	return DialogFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// EventControllerScrollFlags describes the behavior of a
// `GtkEventControllerScroll`.
type EventControllerScrollFlags int

const (
	// EventControllerScrollFlagsNone: don't emit scroll.
	EventControllerScrollFlagsNone EventControllerScrollFlags = 0
	// EventControllerScrollFlagsVertical: emit scroll with vertical deltas.
	EventControllerScrollFlagsVertical EventControllerScrollFlags = 1
	// EventControllerScrollFlagsHorizontal: emit scroll with horizontal deltas.
	EventControllerScrollFlagsHorizontal EventControllerScrollFlags = 2
	// EventControllerScrollFlagsDiscrete: only emit deltas that are multiples
	// of 1.
	EventControllerScrollFlagsDiscrete EventControllerScrollFlags = 4
	// EventControllerScrollFlagsKinetic: emit ::decelerate after continuous
	// scroll finishes.
	EventControllerScrollFlagsKinetic EventControllerScrollFlags = 8
	// EventControllerScrollFlagsBothAxes: emit scroll on both axes.
	EventControllerScrollFlagsBothAxes EventControllerScrollFlags = 3
)

func marshalEventControllerScrollFlags(p uintptr) (interface{}, error) {
	return EventControllerScrollFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FontChooserLevel specifies the granularity of font selection that is desired
// in a `GtkFontChooser`.
//
// This enumeration may be extended in the future; applications should ignore
// unknown values.
type FontChooserLevel int

const (
	// FontChooserLevelFamily: allow selecting a font family
	FontChooserLevelFamily FontChooserLevel = 0
	// FontChooserLevelStyle: allow selecting a specific font face
	FontChooserLevelStyle FontChooserLevel = 1
	// FontChooserLevelSize: allow selecting a specific font size
	FontChooserLevelSize FontChooserLevel = 2
	// FontChooserLevelVariations: allow changing OpenType font variation axes
	FontChooserLevelVariations FontChooserLevel = 4
	// FontChooserLevelFeatures: allow selecting specific OpenType font features
	FontChooserLevelFeatures FontChooserLevel = 8
)

func marshalFontChooserLevel(p uintptr) (interface{}, error) {
	return FontChooserLevel(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// IconLookupFlags: used to specify options for gtk_icon_theme_lookup_icon().
type IconLookupFlags int

const (
	// IconLookupFlagsForceRegular: try to always load regular icons, even when
	// symbolic icon names are given
	IconLookupFlagsForceRegular IconLookupFlags = 1
	// IconLookupFlagsForceSymbolic: try to always load symbolic icons, even
	// when regular icon names are given
	IconLookupFlagsForceSymbolic IconLookupFlags = 2
	// IconLookupFlagsPreload starts loading the texture in the background so it
	// is ready when later needed.
	IconLookupFlagsPreload IconLookupFlags = 4
)

func marshalIconLookupFlags(p uintptr) (interface{}, error) {
	return IconLookupFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// InputHints describes hints that might be taken into account by input methods
// or applications.
//
// Note that input methods may already tailor their behaviour according to the
// `GtkInputPurpose` of the entry.
//
// Some common sense is expected when using these flags - mixing
// GTK_INPUT_HINT_LOWERCASE with any of the uppercase hints makes no sense.
//
// This enumeration may be extended in the future; input methods should ignore
// unknown values.
type InputHints int

const (
	// InputHintsNone: no special behaviour suggested
	InputHintsNone InputHints = 0
	// InputHintsSpellcheck: suggest checking for typos
	InputHintsSpellcheck InputHints = 1
	// InputHintsNoSpellcheck: suggest not checking for typos
	InputHintsNoSpellcheck InputHints = 2
	// InputHintsWordCompletion: suggest word completion
	InputHintsWordCompletion InputHints = 4
	// InputHintsLowercase: suggest to convert all text to lowercase
	InputHintsLowercase InputHints = 8
	// InputHintsUppercaseChars: suggest to capitalize all text
	InputHintsUppercaseChars InputHints = 16
	// InputHintsUppercaseWords: suggest to capitalize the first character of
	// each word
	InputHintsUppercaseWords InputHints = 32
	// InputHintsUppercaseSentences: suggest to capitalize the first word of
	// each sentence
	InputHintsUppercaseSentences InputHints = 64
	// InputHintsInhibitOsk: suggest to not show an onscreen keyboard (e.g for a
	// calculator that already has all the keys).
	InputHintsInhibitOsk InputHints = 128
	// InputHintsVerticalWriting: the text is vertical
	InputHintsVerticalWriting InputHints = 256
	// InputHintsEmoji: suggest offering Emoji support
	InputHintsEmoji InputHints = 512
	// InputHintsNoEmoji: suggest not offering Emoji support
	InputHintsNoEmoji InputHints = 1024
	// InputHintsPrivate: request that the input method should not update
	// personalized data (like typing history)
	InputHintsPrivate InputHints = 2048
)

func marshalInputHints(p uintptr) (interface{}, error) {
	return InputHints(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PickFlags flags that influence the behavior of gtk_widget_pick().
type PickFlags int

const (
	// PickFlagsDefault: the default behavior, include widgets that are
	// receiving events
	PickFlagsDefault PickFlags = 0
	// PickFlagsInsensitive: include widgets that are insensitive
	PickFlagsInsensitive PickFlags = 1
	// PickFlagsNonTargetable: include widgets that are marked as
	// non-targetable. See Widget:can-target
	PickFlagsNonTargetable PickFlags = 2
)

func marshalPickFlags(p uintptr) (interface{}, error) {
	return PickFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PopoverMenuFlags flags that affect how popover menus are created from a menu
// model.
type PopoverMenuFlags int

const (
	// PopoverMenuFlagsNested: create submenus as nested popovers. Without this
	// flag, submenus are created as sliding pages that replace the main menu.
	PopoverMenuFlagsNested PopoverMenuFlags = 1
)

func marshalPopoverMenuFlags(p uintptr) (interface{}, error) {
	return PopoverMenuFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PrintCapabilities specifies which features the print dialog should offer.
//
// If neither GTK_PRINT_CAPABILITY_GENERATE_PDF nor
// GTK_PRINT_CAPABILITY_GENERATE_PS is specified, GTK assumes that all formats
// are supported.
type PrintCapabilities int

const (
	// PrintCapabilitiesPageSet: print dialog will offer printing even/odd
	// pages.
	PrintCapabilitiesPageSet PrintCapabilities = 1
	// PrintCapabilitiesCopies: print dialog will allow to print multiple
	// copies.
	PrintCapabilitiesCopies PrintCapabilities = 2
	// PrintCapabilitiesCollate: print dialog will allow to collate multiple
	// copies.
	PrintCapabilitiesCollate PrintCapabilities = 4
	// PrintCapabilitiesReverse: print dialog will allow to print pages in
	// reverse order.
	PrintCapabilitiesReverse PrintCapabilities = 8
	// PrintCapabilitiesScale: print dialog will allow to scale the output.
	PrintCapabilitiesScale PrintCapabilities = 16
	// PrintCapabilitiesGeneratePDF: the program will send the document to the
	// printer in PDF format
	PrintCapabilitiesGeneratePDF PrintCapabilities = 32
	// PrintCapabilitiesGeneratePS: the program will send the document to the
	// printer in Postscript format
	PrintCapabilitiesGeneratePS PrintCapabilities = 64
	// PrintCapabilitiesPreview: print dialog will offer a preview
	PrintCapabilitiesPreview PrintCapabilities = 128
	// PrintCapabilitiesNumberUp: print dialog will offer printing multiple
	// pages per sheet
	PrintCapabilitiesNumberUp PrintCapabilities = 256
	// PrintCapabilitiesNumberUpLayout: print dialog will allow to rearrange
	// pages when printing multiple pages per sheet
	PrintCapabilitiesNumberUpLayout PrintCapabilities = 512
)

func marshalPrintCapabilities(p uintptr) (interface{}, error) {
	return PrintCapabilities(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ShortcutActionFlags: list of flags that can be passed to action activation.
//
// More flags may be added in the future.
type ShortcutActionFlags int

const (
	// ShortcutActionFlagsExclusive: the action is the only action that can be
	// activated. If this flag is not set, a future activation may select a
	// different action.
	ShortcutActionFlagsExclusive ShortcutActionFlags = 1
)

func marshalShortcutActionFlags(p uintptr) (interface{}, error) {
	return ShortcutActionFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// StateFlags describes a widget state.
//
// Widget states are used to match the widget against CSS pseudo-classes. Note
// that GTK extends the regular CSS classes and sometimes uses different names.
type StateFlags int

const (
	// StateFlagsNormal: state during normal operation
	StateFlagsNormal StateFlags = 0
	// StateFlagsActive: widget is active
	StateFlagsActive StateFlags = 1
	// StateFlagsPrelight: widget has a mouse pointer over it
	StateFlagsPrelight StateFlags = 2
	// StateFlagsSelected: widget is selected
	StateFlagsSelected StateFlags = 4
	// StateFlagsInsensitive: widget is insensitive
	StateFlagsInsensitive StateFlags = 8
	// StateFlagsInconsistent: widget is inconsistent
	StateFlagsInconsistent StateFlags = 16
	// StateFlagsFocused: widget has the keyboard focus
	StateFlagsFocused StateFlags = 32
	// StateFlagsBackdrop: widget is in a background toplevel window
	StateFlagsBackdrop StateFlags = 64
	// StateFlagsDirLTR: widget is in left-to-right text direction
	StateFlagsDirLTR StateFlags = 128
	// StateFlagsDirRTL: widget is in right-to-left text direction
	StateFlagsDirRTL StateFlags = 256
	// StateFlagsLink: widget is a link
	StateFlagsLink StateFlags = 512
	// StateFlagsVisited: the location the widget points to has already been
	// visited
	StateFlagsVisited StateFlags = 1024
	// StateFlagsChecked: widget is checked
	StateFlagsChecked StateFlags = 2048
	// StateFlagsDropActive: widget is highlighted as a drop target for DND
	StateFlagsDropActive StateFlags = 4096
	// StateFlagsFocusVisible: widget has the visible focus
	StateFlagsFocusVisible StateFlags = 8192
	// StateFlagsFocusWithin: widget contains the keyboard focus
	StateFlagsFocusWithin StateFlags = 16384
)

func marshalStateFlags(p uintptr) (interface{}, error) {
	return StateFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// StyleContextPrintFlags flags that modify the behavior of
// gtk_style_context_to_string().
//
// New values may be added to this enumeration.
type StyleContextPrintFlags int

const (
	// StyleContextPrintFlagsNone: default value.
	StyleContextPrintFlagsNone StyleContextPrintFlags = 0
	// StyleContextPrintFlagsRecurse: print the entire tree of CSS nodes
	// starting at the style context's node
	StyleContextPrintFlagsRecurse StyleContextPrintFlags = 1
	// StyleContextPrintFlagsShowStyle: show the values of the CSS properties
	// for each node
	StyleContextPrintFlagsShowStyle StyleContextPrintFlags = 2
	// StyleContextPrintFlagsShowChange: show information about what changes
	// affect the styles
	StyleContextPrintFlagsShowChange StyleContextPrintFlags = 4
)

func marshalStyleContextPrintFlags(p uintptr) (interface{}, error) {
	return StyleContextPrintFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TextSearchFlags flags affecting how a search is done.
//
// If neither GTK_TEXT_SEARCH_VISIBLE_ONLY nor GTK_TEXT_SEARCH_TEXT_ONLY are
// enabled, the match must be exact; the special 0xFFFC character will match
// embedded paintables or child widgets.
type TextSearchFlags int

const (
	// TextSearchFlagsVisibleOnly: search only visible data. A search match may
	// have invisible text interspersed.
	TextSearchFlagsVisibleOnly TextSearchFlags = 1
	// TextSearchFlagsTextOnly: search only text. A match may have paintables or
	// child widgets mixed inside the matched range.
	TextSearchFlagsTextOnly TextSearchFlags = 2
	// TextSearchFlagsCaseInsensitive: the text will be matched regardless of
	// what case it is in.
	TextSearchFlagsCaseInsensitive TextSearchFlags = 4
)

func marshalTextSearchFlags(p uintptr) (interface{}, error) {
	return TextSearchFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TreeModelFlags: these flags indicate various properties of a TreeModel.
//
// They are returned by gtk_tree_model_get_flags(), and must be static for the
// lifetime of the object. A more complete description of
// K_TREE_MODEL_ITERS_PERSIST can be found in the overview of this section.
type TreeModelFlags int

const (
	// TreeModelFlagsItersPersist iterators survive all signals emitted by the
	// tree
	TreeModelFlagsItersPersist TreeModelFlags = 1
	// TreeModelFlagsListOnly: the model is a list only, and never has children
	TreeModelFlagsListOnly TreeModelFlags = 2
)

func marshalTreeModelFlags(p uintptr) (interface{}, error) {
	return TreeModelFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AppChooser: `GtkAppChooser` is an interface for widgets which allow the user
// to choose an application.
//
// The main objects that implement this interface are
// [class@Gtk.AppChooserWidget], [class@Gtk.AppChooserDialog] and
// [class@Gtk.AppChooserButton].
//
// Applications are represented by GIO `GAppInfo` objects here. GIO has a
// concept of recommended and fallback applications for a given content type.
// Recommended applications are those that claim to handle the content type
// itself, while fallback also includes applications that handle a more generic
// content type. GIO also knows the default and last-used application for a
// given content type. The `GtkAppChooserWidget` provides detailed control over
// whether the shown list of applications should include default, recommended or
// fallback applications.
//
// To obtain the application that has been selected in a `GtkAppChooser`, use
// [method@Gtk.AppChooser.get_app_info].
type AppChooser interface {
	Widget

	// ContentType returns the content type for which the `GtkAppChooser` shows
	// applications.
	ContentType() string
	// Refresh reloads the list of applications.
	Refresh()
}

// appChooser implements the AppChooser interface.
type appChooser struct {
	Widget
}

var _ AppChooser = (*appChooser)(nil)

// WrapAppChooser wraps a GObject to a type that implements interface
// AppChooser. It is primarily used internally.
func WrapAppChooser(obj *externglib.Object) AppChooser {
	return AppChooser{
		Widget: WrapWidget(obj),
	}
}

func marshalAppChooser(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapAppChooser(obj), nil
}

// ContentType returns the content type for which the `GtkAppChooser` shows
// applications.
func (s appChooser) ContentType() string {
	var _arg0 *C.GtkAppChooser

	_arg0 = (*C.GtkAppChooser)(unsafe.Pointer(s.Native()))

	var _cret *C.char

	_cret = C.gtk_app_chooser_get_content_type(_arg0)

	var _utf8 string

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Refresh reloads the list of applications.
func (s appChooser) Refresh() {
	var _arg0 *C.GtkAppChooser

	_arg0 = (*C.GtkAppChooser)(unsafe.Pointer(s.Native()))

	C.gtk_app_chooser_refresh(_arg0)
}

// FileChooser: `GtkFileChooser` is an interface that can be implemented by file
// selection widgets.
//
// In GTK, the main objects that implement this interface are
// [class@Gtk.FileChooserWidget] and [class@Gtk.FileChooserDialog].
//
// You do not need to write an object that implements the `GtkFileChooser`
// interface unless you are trying to adapt an existing file selector to expose
// a standard programming interface.
//
// `GtkFileChooser` allows for shortcuts to various places in the filesystem. In
// the default implementation these are displayed in the left pane. It may be a
// bit confusing at first that these shortcuts come from various sources and in
// various flavours, so lets explain the terminology here:
//
// - Bookmarks: are created by the user, by dragging folders from the right pane
// to the left pane, or by using the “Add”. Bookmarks can be renamed and deleted
// by the user.
//
// - Shortcuts: can be provided by the application. For example, a Paint program
// may want to add a shortcut for a Clipart folder. Shortcuts cannot be modified
// by the user.
//
// - Volumes: are provided by the underlying filesystem abstraction. They are
// the “roots” of the filesystem.
//
//
// File Names and Encodings
//
// When the user is finished selecting files in a `GtkFileChooser`, your program
// can get the selected filenames as `GFile`s.
//
//
// Adding options
//
// You can add extra widgets to a file chooser to provide options that are not
// present in the default design, by using [method@Gtk.FileChooser.add_choice].
// Each choice has an identifier and a user visible label; additionally, each
// choice can have multiple options. If a choice has no option, it will be
// rendered as a check button with the given label; if a choice has options, it
// will be rendered as a combo box.
type FileChooser interface {
	gextras.Objector

	// AddChoice adds a 'choice' to the file chooser.
	//
	// This is typically implemented as a combobox or, for boolean choices, as a
	// checkbutton. You can select a value using
	// [method@Gtk.FileChooser.set_choice] before the dialog is shown, and you
	// can obtain the user-selected value in the [signal@Gtk.Dialog::response]
	// signal handler using [method@Gtk.FileChooser.get_choice].
	AddChoice(id string, label string, options []string, optionLabels []string)
	// AddFilter adds @filter to the list of filters that the user can select
	// between.
	//
	// When a filter is selected, only files that are passed by that filter are
	// displayed.
	//
	// Note that the @chooser takes ownership of the filter if it is floating,
	// so you have to ref and sink it if you want to keep a reference.
	AddFilter(filter FileFilter)
	// AddShortcutFolder adds a folder to be displayed with the shortcut folders
	// in a file chooser.
	AddShortcutFolder(folder gio.File) error
	// Choice gets the currently selected option in the 'choice' with the given
	// ID.
	Choice(id string) string
	// CreateFolders gets whether file chooser will offer to create new folders.
	CreateFolders() bool
	// CurrentName gets the current name in the file selector, as entered by the
	// user.
	//
	// This is meant to be used in save dialogs, to get the currently typed
	// filename when the file itself does not exist yet.
	CurrentName() string
	// SelectMultiple gets whether multiple files can be selected in the file
	// chooser.
	SelectMultiple() bool
	// RemoveChoice removes a 'choice' that has been added with
	// gtk_file_chooser_add_choice().
	RemoveChoice(id string)
	// RemoveFilter removes @filter from the list of filters that the user can
	// select between.
	RemoveFilter(filter FileFilter)
	// RemoveShortcutFolder removes a folder from the shortcut folders in a file
	// chooser.
	RemoveShortcutFolder(folder gio.File) error
	// SetAction sets the type of operation that the chooser is performing.
	//
	// The user interface is adapted to suit the selected action.
	//
	// For example, an option to create a new folder might be shown if the
	// action is GTK_FILE_CHOOSER_ACTION_SAVE but not if the action is
	// GTK_FILE_CHOOSER_ACTION_OPEN.
	SetAction(action FileChooserAction)
	// SetChoice selects an option in a 'choice' that has been added with
	// gtk_file_chooser_add_choice().
	//
	// For a boolean choice, the possible options are "true" and "false".
	SetChoice(id string, option string)
	// SetCreateFolders sets whether file chooser will offer to create new
	// folders.
	//
	// This is only relevant if the action is not set to be
	// GTK_FILE_CHOOSER_ACTION_OPEN.
	SetCreateFolders(createFolders bool)
	// SetCurrentFolder sets the current folder for @chooser from a #GFile.
	SetCurrentFolder(file gio.File) error
	// SetCurrentName sets the current name in the file selector, as if entered
	// by the user.
	//
	// Note that the name passed in here is a UTF-8 string rather than a
	// filename. This function is meant for such uses as a suggested name in a
	// “Save As...” dialog. You can pass “Untitled.doc” or a similarly suitable
	// suggestion for the @name.
	//
	// If you want to preselect a particular existing file, you should use
	// [method@Gtk.FileChooser.set_file] instead.
	//
	// Please see the documentation for those functions for an example of using
	// [method@Gtk.FileChooser.set_current_name] as well.
	SetCurrentName(name string)
	// SetFile sets @file as the current filename for the file chooser.
	//
	// This includes changing to the file’s parent folder and actually selecting
	// the file in list. If the @chooser is in GTK_FILE_CHOOSER_ACTION_SAVE
	// mode, the file’s base name will also appear in the dialog’s file name
	// entry.
	//
	// If the file name isn’t in the current folder of @chooser, then the
	// current folder of @chooser will be changed to the folder containing
	// @filename.
	//
	// Note that the file must exist, or nothing will be done except for the
	// directory change.
	//
	// If you are implementing a save dialog, you should use this function if
	// you already have a file name to which the user may save; for example,
	// when the user opens an existing file and then does “Save As…”. If you
	// don’t have a file name already — for example, if the user just created a
	// new file and is saving it for the first time, do not call this function.
	//
	// Instead, use something similar to this:
	//
	// “`c static void prepare_file_chooser (GtkFileChooser *chooser, GFile
	// *existing_file) { gboolean document_is_new = (existing_file == NULL);
	//
	//    if (document_is_new)
	//      {
	//        GFile *default_file_for_saving = g_file_new_for_path ("./out.txt");
	//        // the user just created a new document
	//        gtk_file_chooser_set_current_folder (chooser, default_file_for_saving, NULL);
	//        gtk_file_chooser_set_current_name (chooser, "Untitled document");
	//        g_object_unref (default_file_for_saving);
	//      }
	//    else
	//      {
	//        // the user edited an existing document
	//        gtk_file_chooser_set_file (chooser, existing_file, NULL);
	//      }
	//
	// } “`
	SetFile(file gio.File) error
	// SetFilter sets the current filter.
	//
	// Only the files that pass the filter will be displayed. If the
	// user-selectable list of filters is non-empty, then the filter should be
	// one of the filters in that list.
	//
	// Setting the current filter when the list of filters is empty is useful if
	// you want to restrict the displayed set of files without letting the user
	// change it.
	SetFilter(filter FileFilter)
	// SetSelectMultiple sets whether multiple files can be selected in the file
	// chooser.
	//
	// This is only relevant if the action is set to be
	// GTK_FILE_CHOOSER_ACTION_OPEN or GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER.
	SetSelectMultiple(selectMultiple bool)
}

// fileChooser implements the FileChooser interface.
type fileChooser struct {
	gextras.Objector
}

var _ FileChooser = (*fileChooser)(nil)

// WrapFileChooser wraps a GObject to a type that implements interface
// FileChooser. It is primarily used internally.
func WrapFileChooser(obj *externglib.Object) FileChooser {
	return FileChooser{
		Objector: obj,
	}
}

func marshalFileChooser(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFileChooser(obj), nil
}

// AddChoice adds a 'choice' to the file chooser.
//
// This is typically implemented as a combobox or, for boolean choices, as a
// checkbutton. You can select a value using
// [method@Gtk.FileChooser.set_choice] before the dialog is shown, and you
// can obtain the user-selected value in the [signal@Gtk.Dialog::response]
// signal handler using [method@Gtk.FileChooser.get_choice].
func (c fileChooser) AddChoice(id string, label string, options []string, optionLabels []string) {
	var _arg0 *C.GtkFileChooser
	var _arg1 *C.char
	var _arg2 *C.char
	var _arg3 **C.char
	var _arg4 **C.char

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.char)(C.CString(id))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.char)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (**C.char)(C.malloc((len(options) + 1) * unsafe.Sizeof(int(0))))
	defer C.free(unsafe.Pointer(_arg3))

	{
		var out []*C.char
		ptr.SetSlice(unsafe.Pointer(&dst), unsafe.Pointer(_arg3), int(len(options)))

		for i := range options {
			_arg3 = (*C.char)(C.CString(options))
			defer C.free(unsafe.Pointer(_arg3))
		}
	}
	_arg4 = (**C.char)(C.malloc((len(optionLabels) + 1) * unsafe.Sizeof(int(0))))
	defer C.free(unsafe.Pointer(_arg4))

	{
		var out []*C.char
		ptr.SetSlice(unsafe.Pointer(&dst), unsafe.Pointer(_arg4), int(len(optionLabels)))

		for i := range optionLabels {
			_arg4 = (*C.char)(C.CString(optionLabels))
			defer C.free(unsafe.Pointer(_arg4))
		}
	}

	C.gtk_file_chooser_add_choice(_arg0, _arg1, _arg2, _arg3, _arg4)
}

// AddFilter adds @filter to the list of filters that the user can select
// between.
//
// When a filter is selected, only files that are passed by that filter are
// displayed.
//
// Note that the @chooser takes ownership of the filter if it is floating,
// so you have to ref and sink it if you want to keep a reference.
func (c fileChooser) AddFilter(filter FileFilter) {
	var _arg0 *C.GtkFileChooser
	var _arg1 *C.GtkFileFilter

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkFileFilter)(unsafe.Pointer(filter.Native()))

	C.gtk_file_chooser_add_filter(_arg0, _arg1)
}

// AddShortcutFolder adds a folder to be displayed with the shortcut folders
// in a file chooser.
func (c fileChooser) AddShortcutFolder(folder gio.File) error {
	var _arg0 *C.GtkFileChooser
	var _arg1 *C.GFile

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GFile)(unsafe.Pointer(folder.Native()))

	var _cerr *C.GError

	C.gtk_file_chooser_add_shortcut_folder(_arg0, _arg1, _cerr)

	var _goerr error

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// Choice gets the currently selected option in the 'choice' with the given
// ID.
func (c fileChooser) Choice(id string) string {
	var _arg0 *C.GtkFileChooser
	var _arg1 *C.char

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.char)(C.CString(id))
	defer C.free(unsafe.Pointer(_arg1))

	var _cret *C.char

	_cret = C.gtk_file_chooser_get_choice(_arg0, _arg1)

	var _utf8 string

	_utf8 = C.GoString(_cret)

	return _utf8
}

// CreateFolders gets whether file chooser will offer to create new folders.
func (c fileChooser) CreateFolders() bool {
	var _arg0 *C.GtkFileChooser

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

	var _cret C.gboolean

	_cret = C.gtk_file_chooser_get_create_folders(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// CurrentName gets the current name in the file selector, as entered by the
// user.
//
// This is meant to be used in save dialogs, to get the currently typed
// filename when the file itself does not exist yet.
func (c fileChooser) CurrentName() string {
	var _arg0 *C.GtkFileChooser

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

	var _cret *C.char

	_cret = C.gtk_file_chooser_get_current_name(_arg0)

	var _utf8 string

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// SelectMultiple gets whether multiple files can be selected in the file
// chooser.
func (c fileChooser) SelectMultiple() bool {
	var _arg0 *C.GtkFileChooser

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

	var _cret C.gboolean

	_cret = C.gtk_file_chooser_get_select_multiple(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// RemoveChoice removes a 'choice' that has been added with
// gtk_file_chooser_add_choice().
func (c fileChooser) RemoveChoice(id string) {
	var _arg0 *C.GtkFileChooser
	var _arg1 *C.char

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.char)(C.CString(id))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_file_chooser_remove_choice(_arg0, _arg1)
}

// RemoveFilter removes @filter from the list of filters that the user can
// select between.
func (c fileChooser) RemoveFilter(filter FileFilter) {
	var _arg0 *C.GtkFileChooser
	var _arg1 *C.GtkFileFilter

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkFileFilter)(unsafe.Pointer(filter.Native()))

	C.gtk_file_chooser_remove_filter(_arg0, _arg1)
}

// RemoveShortcutFolder removes a folder from the shortcut folders in a file
// chooser.
func (c fileChooser) RemoveShortcutFolder(folder gio.File) error {
	var _arg0 *C.GtkFileChooser
	var _arg1 *C.GFile

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GFile)(unsafe.Pointer(folder.Native()))

	var _cerr *C.GError

	C.gtk_file_chooser_remove_shortcut_folder(_arg0, _arg1, _cerr)

	var _goerr error

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// SetAction sets the type of operation that the chooser is performing.
//
// The user interface is adapted to suit the selected action.
//
// For example, an option to create a new folder might be shown if the
// action is GTK_FILE_CHOOSER_ACTION_SAVE but not if the action is
// GTK_FILE_CHOOSER_ACTION_OPEN.
func (c fileChooser) SetAction(action FileChooserAction) {
	var _arg0 *C.GtkFileChooser
	var _arg1 C.GtkFileChooserAction

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	_arg1 = (C.GtkFileChooserAction)(action)

	C.gtk_file_chooser_set_action(_arg0, _arg1)
}

// SetChoice selects an option in a 'choice' that has been added with
// gtk_file_chooser_add_choice().
//
// For a boolean choice, the possible options are "true" and "false".
func (c fileChooser) SetChoice(id string, option string) {
	var _arg0 *C.GtkFileChooser
	var _arg1 *C.char
	var _arg2 *C.char

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.char)(C.CString(id))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.char)(C.CString(option))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_file_chooser_set_choice(_arg0, _arg1, _arg2)
}

// SetCreateFolders sets whether file chooser will offer to create new
// folders.
//
// This is only relevant if the action is not set to be
// GTK_FILE_CHOOSER_ACTION_OPEN.
func (c fileChooser) SetCreateFolders(createFolders bool) {
	var _arg0 *C.GtkFileChooser
	var _arg1 C.gboolean

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	if createFolders {
		_arg1 = C.gboolean(1)
	}

	C.gtk_file_chooser_set_create_folders(_arg0, _arg1)
}

// SetCurrentFolder sets the current folder for @chooser from a #GFile.
func (c fileChooser) SetCurrentFolder(file gio.File) error {
	var _arg0 *C.GtkFileChooser
	var _arg1 *C.GFile

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GFile)(unsafe.Pointer(file.Native()))

	var _cerr *C.GError

	C.gtk_file_chooser_set_current_folder(_arg0, _arg1, _cerr)

	var _goerr error

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// SetCurrentName sets the current name in the file selector, as if entered
// by the user.
//
// Note that the name passed in here is a UTF-8 string rather than a
// filename. This function is meant for such uses as a suggested name in a
// “Save As...” dialog. You can pass “Untitled.doc” or a similarly suitable
// suggestion for the @name.
//
// If you want to preselect a particular existing file, you should use
// [method@Gtk.FileChooser.set_file] instead.
//
// Please see the documentation for those functions for an example of using
// [method@Gtk.FileChooser.set_current_name] as well.
func (c fileChooser) SetCurrentName(name string) {
	var _arg0 *C.GtkFileChooser
	var _arg1 *C.char

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_file_chooser_set_current_name(_arg0, _arg1)
}

// SetFile sets @file as the current filename for the file chooser.
//
// This includes changing to the file’s parent folder and actually selecting
// the file in list. If the @chooser is in GTK_FILE_CHOOSER_ACTION_SAVE
// mode, the file’s base name will also appear in the dialog’s file name
// entry.
//
// If the file name isn’t in the current folder of @chooser, then the
// current folder of @chooser will be changed to the folder containing
// @filename.
//
// Note that the file must exist, or nothing will be done except for the
// directory change.
//
// If you are implementing a save dialog, you should use this function if
// you already have a file name to which the user may save; for example,
// when the user opens an existing file and then does “Save As…”. If you
// don’t have a file name already — for example, if the user just created a
// new file and is saving it for the first time, do not call this function.
//
// Instead, use something similar to this:
//
// “`c static void prepare_file_chooser (GtkFileChooser *chooser, GFile
// *existing_file) { gboolean document_is_new = (existing_file == NULL);
//
//    if (document_is_new)
//      {
//        GFile *default_file_for_saving = g_file_new_for_path ("./out.txt");
//        // the user just created a new document
//        gtk_file_chooser_set_current_folder (chooser, default_file_for_saving, NULL);
//        gtk_file_chooser_set_current_name (chooser, "Untitled document");
//        g_object_unref (default_file_for_saving);
//      }
//    else
//      {
//        // the user edited an existing document
//        gtk_file_chooser_set_file (chooser, existing_file, NULL);
//      }
//
// } “`
func (c fileChooser) SetFile(file gio.File) error {
	var _arg0 *C.GtkFileChooser
	var _arg1 *C.GFile

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GFile)(unsafe.Pointer(file.Native()))

	var _cerr *C.GError

	C.gtk_file_chooser_set_file(_arg0, _arg1, _cerr)

	var _goerr error

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// SetFilter sets the current filter.
//
// Only the files that pass the filter will be displayed. If the
// user-selectable list of filters is non-empty, then the filter should be
// one of the filters in that list.
//
// Setting the current filter when the list of filters is empty is useful if
// you want to restrict the displayed set of files without letting the user
// change it.
func (c fileChooser) SetFilter(filter FileFilter) {
	var _arg0 *C.GtkFileChooser
	var _arg1 *C.GtkFileFilter

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkFileFilter)(unsafe.Pointer(filter.Native()))

	C.gtk_file_chooser_set_filter(_arg0, _arg1)
}

// SetSelectMultiple sets whether multiple files can be selected in the file
// chooser.
//
// This is only relevant if the action is set to be
// GTK_FILE_CHOOSER_ACTION_OPEN or GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER.
func (c fileChooser) SetSelectMultiple(selectMultiple bool) {
	var _arg0 *C.GtkFileChooser
	var _arg1 C.gboolean

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	if selectMultiple {
		_arg1 = C.gboolean(1)
	}

	C.gtk_file_chooser_set_select_multiple(_arg0, _arg1)
}

// StyleProvider: `GtkStyleProvider` is an interface for style information used
// by `GtkStyleContext`.
//
// See [method@Gtk.StyleContext.add_provider] and
// [func@Gtk.StyleContext.add_provider_for_display] for adding
// `GtkStyleProviders`.
//
// GTK uses the `GtkStyleProvider` implementation for CSS in
// [iface@Gtk.CssProvider].
type StyleProvider interface {
	gextras.Objector
}

// styleProvider implements the StyleProvider interface.
type styleProvider struct {
	gextras.Objector
}

var _ StyleProvider = (*styleProvider)(nil)

// WrapStyleProvider wraps a GObject to a type that implements interface
// StyleProvider. It is primarily used internally.
func WrapStyleProvider(obj *externglib.Object) StyleProvider {
	return StyleProvider{
		Objector: obj,
	}
}

func marshalStyleProvider(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapStyleProvider(obj), nil
}

// AboutDialog: the `GtkAboutDialog` offers a simple way to display information
// about a program.
//
// The shown information includes the programs' logo, name, copyright, website
// and license. It is also possible to give credits to the authors, documenters,
// translators and artists who have worked on the program.
//
// An about dialog is typically opened when the user selects the `About` option
// from the `Help` menu. All parts of the dialog are optional.
//
// !An example GtkAboutDialog (aboutdialog.png)
//
// About dialogs often contain links and email addresses. `GtkAboutDialog`
// displays these as clickable links. By default, it calls [func@Gtk.show_uri]
// when a user clicks one. The behaviour can be overridden with the
// [signal@Gtk.AboutDialog::activate-link] signal.
//
// To specify a person with an email address, use a string like `Edgar Allan Poe
// <edgar@poe.com>`. To specify a website with a title, use a string like `GTK
// team https://www.gtk.org`.
//
// To make constructing a `GtkAboutDialog` as convenient as possible, you can
// use the function [func@Gtk.show_about_dialog] which constructs and shows a
// dialog and keeps it around so that it can be shown again.
//
// Note that GTK sets a default title of `_("About s")` on the dialog window
// (where `s` is replaced by the name of the application, but in order to ensure
// proper translation of the title, applications should set the title property
// explicitly when constructing a `GtkAboutDialog`, as shown in the following
// example:
//
// “`c GFile *logo_file = g_file_new_for_path ("./logo.png"); GdkTexture
// *example_logo = gdk_texture_new_from_file (logo_file, NULL); g_object_unref
// (logo_file);
//
// gtk_show_about_dialog (NULL, "program-name", "ExampleCode", "logo",
// example_logo, "title", _("About ExampleCode"), NULL); “`
//
//
// CSS nodes
//
// `GtkAboutDialog` has a single CSS node with the name `window` and style class
// `.aboutdialog`.
type AboutDialog interface {
	Window
	Accessible
	Buildable
	ConstraintTarget
	Native
	Root
	ShortcutManager

	// AddCreditSection creates a new section in the "Credits" page.
	AddCreditSection(sectionName string, people []string)
	// Artists returns the string which are displayed in the "Artists" tab of
	// the secondary credits dialog.
	Artists() []string
	// Authors returns the string which are displayed in the authors tab of the
	// secondary credits dialog.
	Authors() []string
	// Comments returns the comments string.
	Comments() string
	// Copyright returns the copyright string.
	Copyright() string
	// Documenters returns the string which are displayed in the "Documenters"
	// tab of the secondary credits dialog.
	Documenters() []string
	// License returns the license information.
	License() string
	// LogoIconName returns the icon name displayed as logo in the about dialog.
	LogoIconName() string
	// ProgramName returns the program name displayed in the about dialog.
	ProgramName() string
	// SystemInformation returns the system information that is shown in the
	// about dialog.
	SystemInformation() string
	// TranslatorCredits returns the translator credits string which is
	// displayed in the translators tab of the secondary credits dialog.
	TranslatorCredits() string
	// Version returns the version string.
	Version() string
	// Website returns the website URL.
	Website() string
	// WebsiteLabel returns the label used for the website link.
	WebsiteLabel() string
	// WrapLicense returns whether the license text in the about dialog is
	// automatically wrapped.
	WrapLicense() bool
	// SetArtists sets the strings which are displayed in the "Artists" tab of
	// the secondary credits dialog.
	SetArtists(artists []string)
	// SetAuthors sets the strings which are displayed in the "Authors" tab of
	// the secondary credits dialog.
	SetAuthors(authors []string)
	// SetComments sets the comments string to display in the about dialog.
	//
	// This should be a short string of one or two lines.
	SetComments(comments string)
	// SetCopyright sets the copyright string to display in the about dialog.
	//
	// This should be a short string of one or two lines.
	SetCopyright(copyright string)
	// SetDocumenters sets the strings which are displayed in the "Documenters"
	// tab of the credits dialog.
	SetDocumenters(documenters []string)
	// SetLicense sets the license information to be displayed in the secondary
	// license dialog.
	//
	// If `license` is `NULL`, the license button is hidden.
	SetLicense(license string)
	// SetLicenseType sets the license of the application showing the about
	// dialog from a list of known licenses.
	//
	// This function overrides the license set using
	// [method@Gtk.AboutDialog.set_license].
	SetLicenseType(licenseType License)
	// SetLogo sets the logo in the about dialog.
	SetLogo(logo gdk.Paintable)
	// SetLogoIconName sets the icon name to be displayed as logo in the about
	// dialog.
	SetLogoIconName(iconName string)
	// SetProgramName sets the name to display in the about dialog.
	//
	// If `name` is not set, it defaults to `g_get_application_name()`.
	SetProgramName(name string)
	// SetSystemInformation sets the system information to be displayed in the
	// about dialog.
	//
	// If `system_information` is `NULL`, the system information tab is hidden.
	//
	// See [property@Gtk.AboutDialog:system-information].
	SetSystemInformation(systemInformation string)
	// SetTranslatorCredits sets the translator credits string which is
	// displayed in the translators tab of the secondary credits dialog.
	//
	// The intended use for this string is to display the translator of the
	// language which is currently used in the user interface. Using
	// `gettext()`, a simple way to achieve that is to mark the string for
	// translation:
	//
	// “`c GtkWidget *about = gtk_about_dialog_new ();
	// gtk_about_dialog_set_translator_credits (GTK_ABOUT_DIALOG (about),
	// _("translator-credits")); “`
	//
	// It is a good idea to use the customary `msgid` “translator-credits” for
	// this purpose, since translators will already know the purpose of that
	// `msgid`, and since `GtkAboutDialog` will detect if “translator-credits”
	// is untranslated and hide the tab.
	SetTranslatorCredits(translatorCredits string)
	// SetVersion sets the version string to display in the about dialog.
	SetVersion(version string)
	// SetWebsite sets the URL to use for the website link.
	SetWebsite(website string)
	// SetWebsiteLabel sets the label to be used for the website link.
	SetWebsiteLabel(websiteLabel string)
	// SetWrapLicense sets whether the license text in the about dialog should
	// be automatically wrapped.
	SetWrapLicense(wrapLicense bool)
}

// aboutDialog implements the AboutDialog interface.
type aboutDialog struct {
	Window
	Accessible
	Buildable
	ConstraintTarget
	Native
	Root
	ShortcutManager
}

var _ AboutDialog = (*aboutDialog)(nil)

// WrapAboutDialog wraps a GObject to the right type. It is
// primarily used internally.
func WrapAboutDialog(obj *externglib.Object) AboutDialog {
	return AboutDialog{
		Window:           WrapWindow(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
		Native:           WrapNative(obj),
		Root:             WrapRoot(obj),
		ShortcutManager:  WrapShortcutManager(obj),
	}
}

func marshalAboutDialog(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapAboutDialog(obj), nil
}

// AddCreditSection creates a new section in the "Credits" page.
func (a aboutDialog) AddCreditSection(sectionName string, people []string) {
	var _arg0 *C.GtkAboutDialog
	var _arg1 *C.char
	var _arg2 **C.char

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.char)(C.CString(sectionName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (**C.char)(C.malloc((len(people) + 1) * unsafe.Sizeof(int(0))))
	defer C.free(unsafe.Pointer(_arg2))

	{
		var out []*C.char
		ptr.SetSlice(unsafe.Pointer(&dst), unsafe.Pointer(_arg2), int(len(people)))

		for i := range people {
			_arg2 = (*C.char)(C.CString(people))
			defer C.free(unsafe.Pointer(_arg2))
		}
	}

	C.gtk_about_dialog_add_credit_section(_arg0, _arg1, _arg2)
}

// Artists returns the string which are displayed in the "Artists" tab of
// the secondary credits dialog.
func (a aboutDialog) Artists() []string {
	var _arg0 *C.GtkAboutDialog

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

	var _cret **C.char

	_cret = C.gtk_about_dialog_get_artists(_arg0)

	var _utf8s []string

	{
		var length int
		for p := _cret; *p != 0; p = (**C.char)(ptr.Add(unsafe.Pointer(p), unsafe.Sizeof(int(0)))) {
			length++
			if length < 0 {
				panic(`length overflow`)
			}
		}

		var src []*C.gchar
		ptr.SetSlice(unsafe.Pointer(&src), unsafe.Pointer(_cret), int(length))

		_utf8s = make([]string, length)
		for i := range src {
			_utf8s = C.GoString(_cret)
		}
	}

	return _utf8s
}

// Authors returns the string which are displayed in the authors tab of the
// secondary credits dialog.
func (a aboutDialog) Authors() []string {
	var _arg0 *C.GtkAboutDialog

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

	var _cret **C.char

	_cret = C.gtk_about_dialog_get_authors(_arg0)

	var _utf8s []string

	{
		var length int
		for p := _cret; *p != 0; p = (**C.char)(ptr.Add(unsafe.Pointer(p), unsafe.Sizeof(int(0)))) {
			length++
			if length < 0 {
				panic(`length overflow`)
			}
		}

		var src []*C.gchar
		ptr.SetSlice(unsafe.Pointer(&src), unsafe.Pointer(_cret), int(length))

		_utf8s = make([]string, length)
		for i := range src {
			_utf8s = C.GoString(_cret)
		}
	}

	return _utf8s
}

// Comments returns the comments string.
func (a aboutDialog) Comments() string {
	var _arg0 *C.GtkAboutDialog

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

	var _cret *C.char

	_cret = C.gtk_about_dialog_get_comments(_arg0)

	var _utf8 string

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Copyright returns the copyright string.
func (a aboutDialog) Copyright() string {
	var _arg0 *C.GtkAboutDialog

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

	var _cret *C.char

	_cret = C.gtk_about_dialog_get_copyright(_arg0)

	var _utf8 string

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Documenters returns the string which are displayed in the "Documenters"
// tab of the secondary credits dialog.
func (a aboutDialog) Documenters() []string {
	var _arg0 *C.GtkAboutDialog

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

	var _cret **C.char

	_cret = C.gtk_about_dialog_get_documenters(_arg0)

	var _utf8s []string

	{
		var length int
		for p := _cret; *p != 0; p = (**C.char)(ptr.Add(unsafe.Pointer(p), unsafe.Sizeof(int(0)))) {
			length++
			if length < 0 {
				panic(`length overflow`)
			}
		}

		var src []*C.gchar
		ptr.SetSlice(unsafe.Pointer(&src), unsafe.Pointer(_cret), int(length))

		_utf8s = make([]string, length)
		for i := range src {
			_utf8s = C.GoString(_cret)
		}
	}

	return _utf8s
}

// License returns the license information.
func (a aboutDialog) License() string {
	var _arg0 *C.GtkAboutDialog

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

	var _cret *C.char

	_cret = C.gtk_about_dialog_get_license(_arg0)

	var _utf8 string

	_utf8 = C.GoString(_cret)

	return _utf8
}

// LogoIconName returns the icon name displayed as logo in the about dialog.
func (a aboutDialog) LogoIconName() string {
	var _arg0 *C.GtkAboutDialog

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

	var _cret *C.char

	_cret = C.gtk_about_dialog_get_logo_icon_name(_arg0)

	var _utf8 string

	_utf8 = C.GoString(_cret)

	return _utf8
}

// ProgramName returns the program name displayed in the about dialog.
func (a aboutDialog) ProgramName() string {
	var _arg0 *C.GtkAboutDialog

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

	var _cret *C.char

	_cret = C.gtk_about_dialog_get_program_name(_arg0)

	var _utf8 string

	_utf8 = C.GoString(_cret)

	return _utf8
}

// SystemInformation returns the system information that is shown in the
// about dialog.
func (a aboutDialog) SystemInformation() string {
	var _arg0 *C.GtkAboutDialog

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

	var _cret *C.char

	_cret = C.gtk_about_dialog_get_system_information(_arg0)

	var _utf8 string

	_utf8 = C.GoString(_cret)

	return _utf8
}

// TranslatorCredits returns the translator credits string which is
// displayed in the translators tab of the secondary credits dialog.
func (a aboutDialog) TranslatorCredits() string {
	var _arg0 *C.GtkAboutDialog

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

	var _cret *C.char

	_cret = C.gtk_about_dialog_get_translator_credits(_arg0)

	var _utf8 string

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Version returns the version string.
func (a aboutDialog) Version() string {
	var _arg0 *C.GtkAboutDialog

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

	var _cret *C.char

	_cret = C.gtk_about_dialog_get_version(_arg0)

	var _utf8 string

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Website returns the website URL.
func (a aboutDialog) Website() string {
	var _arg0 *C.GtkAboutDialog

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

	var _cret *C.char

	_cret = C.gtk_about_dialog_get_website(_arg0)

	var _utf8 string

	_utf8 = C.GoString(_cret)

	return _utf8
}

// WebsiteLabel returns the label used for the website link.
func (a aboutDialog) WebsiteLabel() string {
	var _arg0 *C.GtkAboutDialog

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

	var _cret *C.char

	_cret = C.gtk_about_dialog_get_website_label(_arg0)

	var _utf8 string

	_utf8 = C.GoString(_cret)

	return _utf8
}

// WrapLicense returns whether the license text in the about dialog is
// automatically wrapped.
func (a aboutDialog) WrapLicense() bool {
	var _arg0 *C.GtkAboutDialog

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

	var _cret C.gboolean

	_cret = C.gtk_about_dialog_get_wrap_license(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// SetArtists sets the strings which are displayed in the "Artists" tab of
// the secondary credits dialog.
func (a aboutDialog) SetArtists(artists []string) {
	var _arg0 *C.GtkAboutDialog
	var _arg1 **C.char

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
	_arg1 = (**C.char)(C.malloc((len(artists) + 1) * unsafe.Sizeof(int(0))))
	defer C.free(unsafe.Pointer(_arg1))

	{
		var out []*C.char
		ptr.SetSlice(unsafe.Pointer(&dst), unsafe.Pointer(_arg1), int(len(artists)))

		for i := range artists {
			_arg1 = (*C.char)(C.CString(artists))
			defer C.free(unsafe.Pointer(_arg1))
		}
	}

	C.gtk_about_dialog_set_artists(_arg0, _arg1)
}

// SetAuthors sets the strings which are displayed in the "Authors" tab of
// the secondary credits dialog.
func (a aboutDialog) SetAuthors(authors []string) {
	var _arg0 *C.GtkAboutDialog
	var _arg1 **C.char

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
	_arg1 = (**C.char)(C.malloc((len(authors) + 1) * unsafe.Sizeof(int(0))))
	defer C.free(unsafe.Pointer(_arg1))

	{
		var out []*C.char
		ptr.SetSlice(unsafe.Pointer(&dst), unsafe.Pointer(_arg1), int(len(authors)))

		for i := range authors {
			_arg1 = (*C.char)(C.CString(authors))
			defer C.free(unsafe.Pointer(_arg1))
		}
	}

	C.gtk_about_dialog_set_authors(_arg0, _arg1)
}

// SetComments sets the comments string to display in the about dialog.
//
// This should be a short string of one or two lines.
func (a aboutDialog) SetComments(comments string) {
	var _arg0 *C.GtkAboutDialog
	var _arg1 *C.char

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.char)(C.CString(comments))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_about_dialog_set_comments(_arg0, _arg1)
}

// SetCopyright sets the copyright string to display in the about dialog.
//
// This should be a short string of one or two lines.
func (a aboutDialog) SetCopyright(copyright string) {
	var _arg0 *C.GtkAboutDialog
	var _arg1 *C.char

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.char)(C.CString(copyright))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_about_dialog_set_copyright(_arg0, _arg1)
}

// SetDocumenters sets the strings which are displayed in the "Documenters"
// tab of the credits dialog.
func (a aboutDialog) SetDocumenters(documenters []string) {
	var _arg0 *C.GtkAboutDialog
	var _arg1 **C.char

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
	_arg1 = (**C.char)(C.malloc((len(documenters) + 1) * unsafe.Sizeof(int(0))))
	defer C.free(unsafe.Pointer(_arg1))

	{
		var out []*C.char
		ptr.SetSlice(unsafe.Pointer(&dst), unsafe.Pointer(_arg1), int(len(documenters)))

		for i := range documenters {
			_arg1 = (*C.char)(C.CString(documenters))
			defer C.free(unsafe.Pointer(_arg1))
		}
	}

	C.gtk_about_dialog_set_documenters(_arg0, _arg1)
}

// SetLicense sets the license information to be displayed in the secondary
// license dialog.
//
// If `license` is `NULL`, the license button is hidden.
func (a aboutDialog) SetLicense(license string) {
	var _arg0 *C.GtkAboutDialog
	var _arg1 *C.char

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.char)(C.CString(license))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_about_dialog_set_license(_arg0, _arg1)
}

// SetLicenseType sets the license of the application showing the about
// dialog from a list of known licenses.
//
// This function overrides the license set using
// [method@Gtk.AboutDialog.set_license].
func (a aboutDialog) SetLicenseType(licenseType License) {
	var _arg0 *C.GtkAboutDialog
	var _arg1 C.GtkLicense

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
	_arg1 = (C.GtkLicense)(licenseType)

	C.gtk_about_dialog_set_license_type(_arg0, _arg1)
}

// SetLogo sets the logo in the about dialog.
func (a aboutDialog) SetLogo(logo gdk.Paintable) {
	var _arg0 *C.GtkAboutDialog
	var _arg1 *C.GdkPaintable

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GdkPaintable)(unsafe.Pointer(logo.Native()))

	C.gtk_about_dialog_set_logo(_arg0, _arg1)
}

// SetLogoIconName sets the icon name to be displayed as logo in the about
// dialog.
func (a aboutDialog) SetLogoIconName(iconName string) {
	var _arg0 *C.GtkAboutDialog
	var _arg1 *C.char

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.char)(C.CString(iconName))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_about_dialog_set_logo_icon_name(_arg0, _arg1)
}

// SetProgramName sets the name to display in the about dialog.
//
// If `name` is not set, it defaults to `g_get_application_name()`.
func (a aboutDialog) SetProgramName(name string) {
	var _arg0 *C.GtkAboutDialog
	var _arg1 *C.char

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_about_dialog_set_program_name(_arg0, _arg1)
}

// SetSystemInformation sets the system information to be displayed in the
// about dialog.
//
// If `system_information` is `NULL`, the system information tab is hidden.
//
// See [property@Gtk.AboutDialog:system-information].
func (a aboutDialog) SetSystemInformation(systemInformation string) {
	var _arg0 *C.GtkAboutDialog
	var _arg1 *C.char

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.char)(C.CString(systemInformation))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_about_dialog_set_system_information(_arg0, _arg1)
}

// SetTranslatorCredits sets the translator credits string which is
// displayed in the translators tab of the secondary credits dialog.
//
// The intended use for this string is to display the translator of the
// language which is currently used in the user interface. Using
// `gettext()`, a simple way to achieve that is to mark the string for
// translation:
//
// “`c GtkWidget *about = gtk_about_dialog_new ();
// gtk_about_dialog_set_translator_credits (GTK_ABOUT_DIALOG (about),
// _("translator-credits")); “`
//
// It is a good idea to use the customary `msgid` “translator-credits” for
// this purpose, since translators will already know the purpose of that
// `msgid`, and since `GtkAboutDialog` will detect if “translator-credits”
// is untranslated and hide the tab.
func (a aboutDialog) SetTranslatorCredits(translatorCredits string) {
	var _arg0 *C.GtkAboutDialog
	var _arg1 *C.char

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.char)(C.CString(translatorCredits))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_about_dialog_set_translator_credits(_arg0, _arg1)
}

// SetVersion sets the version string to display in the about dialog.
func (a aboutDialog) SetVersion(version string) {
	var _arg0 *C.GtkAboutDialog
	var _arg1 *C.char

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.char)(C.CString(version))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_about_dialog_set_version(_arg0, _arg1)
}

// SetWebsite sets the URL to use for the website link.
func (a aboutDialog) SetWebsite(website string) {
	var _arg0 *C.GtkAboutDialog
	var _arg1 *C.char

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.char)(C.CString(website))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_about_dialog_set_website(_arg0, _arg1)
}

// SetWebsiteLabel sets the label to be used for the website link.
func (a aboutDialog) SetWebsiteLabel(websiteLabel string) {
	var _arg0 *C.GtkAboutDialog
	var _arg1 *C.char

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.char)(C.CString(websiteLabel))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_about_dialog_set_website_label(_arg0, _arg1)
}

// SetWrapLicense sets whether the license text in the about dialog should
// be automatically wrapped.
func (a aboutDialog) SetWrapLicense(wrapLicense bool) {
	var _arg0 *C.GtkAboutDialog
	var _arg1 C.gboolean

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
	if wrapLicense {
		_arg1 = C.gboolean(1)
	}

	C.gtk_about_dialog_set_wrap_license(_arg0, _arg1)
}

// ActionBar: `GtkActionBar` is designed to present contextual actions.
//
// !An example GtkActionBar (action-bar.png)
//
// It is expected to be displayed below the content and expand horizontally to
// fill the area.
//
// It allows placing children at the start or the end. In addition, it contains
// an internal centered box which is centered with respect to the full width of
// the box, even if the children at either side take up different amounts of
// space.
//
//
// CSS nodes
//
// `GtkActionBar` has a single CSS node with name actionbar.
type ActionBar interface {
	Widget
	Accessible
	Buildable
	ConstraintTarget

	// Revealed gets whether the contents of the action bar are revealed.
	Revealed() bool
	// PackEnd adds @child to @action_bar, packed with reference to the end of
	// the @action_bar.
	PackEnd(child Widget)
	// PackStart adds @child to @action_bar, packed with reference to the start
	// of the @action_bar.
	PackStart(child Widget)
	// Remove removes a child from @action_bar.
	Remove(child Widget)
	// SetCenterWidget sets the center widget for the `GtkActionBar`.
	SetCenterWidget(centerWidget Widget)
	// SetRevealed reveals or conceals the content of the action bar.
	//
	// Note: this does not show or hide @action_bar in the
	// [property@Gtk.Widget:visible] sense, so revealing has no effect if the
	// action bar is hidden.
	SetRevealed(revealed bool)
}

// actionBar implements the ActionBar interface.
type actionBar struct {
	Widget
	Accessible
	Buildable
	ConstraintTarget
}

var _ ActionBar = (*actionBar)(nil)

// WrapActionBar wraps a GObject to the right type. It is
// primarily used internally.
func WrapActionBar(obj *externglib.Object) ActionBar {
	return ActionBar{
		Widget:           WrapWidget(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
	}
}

func marshalActionBar(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapActionBar(obj), nil
}

// Revealed gets whether the contents of the action bar are revealed.
func (a actionBar) Revealed() bool {
	var _arg0 *C.GtkActionBar

	_arg0 = (*C.GtkActionBar)(unsafe.Pointer(a.Native()))

	var _cret C.gboolean

	_cret = C.gtk_action_bar_get_revealed(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// PackEnd adds @child to @action_bar, packed with reference to the end of
// the @action_bar.
func (a actionBar) PackEnd(child Widget) {
	var _arg0 *C.GtkActionBar
	var _arg1 *C.GtkWidget

	_arg0 = (*C.GtkActionBar)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_action_bar_pack_end(_arg0, _arg1)
}

// PackStart adds @child to @action_bar, packed with reference to the start
// of the @action_bar.
func (a actionBar) PackStart(child Widget) {
	var _arg0 *C.GtkActionBar
	var _arg1 *C.GtkWidget

	_arg0 = (*C.GtkActionBar)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_action_bar_pack_start(_arg0, _arg1)
}

// Remove removes a child from @action_bar.
func (a actionBar) Remove(child Widget) {
	var _arg0 *C.GtkActionBar
	var _arg1 *C.GtkWidget

	_arg0 = (*C.GtkActionBar)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_action_bar_remove(_arg0, _arg1)
}

// SetCenterWidget sets the center widget for the `GtkActionBar`.
func (a actionBar) SetCenterWidget(centerWidget Widget) {
	var _arg0 *C.GtkActionBar
	var _arg1 *C.GtkWidget

	_arg0 = (*C.GtkActionBar)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(centerWidget.Native()))

	C.gtk_action_bar_set_center_widget(_arg0, _arg1)
}

// SetRevealed reveals or conceals the content of the action bar.
//
// Note: this does not show or hide @action_bar in the
// [property@Gtk.Widget:visible] sense, so revealing has no effect if the
// action bar is hidden.
func (a actionBar) SetRevealed(revealed bool) {
	var _arg0 *C.GtkActionBar
	var _arg1 C.gboolean

	_arg0 = (*C.GtkActionBar)(unsafe.Pointer(a.Native()))
	if revealed {
		_arg1 = C.gboolean(1)
	}

	C.gtk_action_bar_set_revealed(_arg0, _arg1)
}

// AppChooserButton: the `GtkAppChooserButton` lets the user select an
// application.
//
// !An example GtkAppChooserButton (appchooserbutton.png)
//
// Initially, a `GtkAppChooserButton` selects the first application in its list,
// which will either be the most-recently used application or, if
// [property@Gtk.AppChooserButton:show-default-item] is true, the default
// application.
//
// The list of applications shown in a `GtkAppChooserButton` includes the
// recommended applications for the given content type. When
// [property@Gtk.AppChooserButton:show-default-item] is set, the default
// application is also included. To let the user chooser other applications, you
// can set the [property@Gtk.AppChooserButton:show-dialog-item] property, which
// allows to open a full [class@Gtk.AppChooserDialog].
//
// It is possible to add custom items to the list, using
// [method@Gtk.AppChooserButton.append_custom_item]. These items cause the
// [signal@Gtk.AppChooserButton::custom-item-activated] signal to be emitted
// when they are selected.
//
// To track changes in the selected application, use the
// [signal@Gtk.AppChooserButton::changed] signal.
//
//
// CSS nodes
//
// `GtkAppChooserButton` has a single CSS node with the name “appchooserbutton”.
type AppChooserButton interface {
	Widget
	Accessible
	AppChooser
	Buildable
	ConstraintTarget

	// AppendCustomItem appends a custom item to the list of applications that
	// is shown in the popup.
	//
	// The item name must be unique per-widget. Clients can use the provided
	// name as a detail for the
	// [signal@Gtk.AppChooserButton::custom-item-activated] signal, to add a
	// callback for the activation of a particular custom item in the list.
	//
	// See also [method@Gtk.AppChooserButton.append_separator].
	AppendCustomItem(name string, label string, icon gio.Icon)
	// AppendSeparator appends a separator to the list of applications that is
	// shown in the popup.
	AppendSeparator()
	// Heading returns the text to display at the top of the dialog.
	Heading() string
	// Modal gets whether the dialog is modal.
	Modal() bool
	// ShowDefaultItem returns whether the dropdown menu should show the default
	// application at the top.
	ShowDefaultItem() bool
	// ShowDialogItem returns whether the dropdown menu shows an item for a
	// `GtkAppChooserDialog`.
	ShowDialogItem() bool
	// SetActiveCustomItem selects a custom item.
	//
	// See [method@Gtk.AppChooserButton.append_custom_item].
	//
	// Use [method@Gtk.AppChooser.refresh] to bring the selection to its initial
	// state.
	SetActiveCustomItem(name string)
	// SetHeading sets the text to display at the top of the dialog.
	//
	// If the heading is not set, the dialog displays a default text.
	SetHeading(heading string)
	// SetModal sets whether the dialog should be modal.
	SetModal(modal bool)
	// SetShowDefaultItem sets whether the dropdown menu of this button should
	// show the default application for the given content type at top.
	SetShowDefaultItem(setting bool)
	// SetShowDialogItem sets whether the dropdown menu of this button should
	// show an entry to trigger a `GtkAppChooserDialog`.
	SetShowDialogItem(setting bool)
}

// appChooserButton implements the AppChooserButton interface.
type appChooserButton struct {
	Widget
	Accessible
	AppChooser
	Buildable
	ConstraintTarget
}

var _ AppChooserButton = (*appChooserButton)(nil)

// WrapAppChooserButton wraps a GObject to the right type. It is
// primarily used internally.
func WrapAppChooserButton(obj *externglib.Object) AppChooserButton {
	return AppChooserButton{
		Widget:           WrapWidget(obj),
		Accessible:       WrapAccessible(obj),
		AppChooser:       WrapAppChooser(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
	}
}

func marshalAppChooserButton(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapAppChooserButton(obj), nil
}

// AppendCustomItem appends a custom item to the list of applications that
// is shown in the popup.
//
// The item name must be unique per-widget. Clients can use the provided
// name as a detail for the
// [signal@Gtk.AppChooserButton::custom-item-activated] signal, to add a
// callback for the activation of a particular custom item in the list.
//
// See also [method@Gtk.AppChooserButton.append_separator].
func (s appChooserButton) AppendCustomItem(name string, label string, icon gio.Icon) {
	var _arg0 *C.GtkAppChooserButton
	var _arg1 *C.char
	var _arg2 *C.char
	var _arg3 *C.GIcon

	_arg0 = (*C.GtkAppChooserButton)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.char)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.GIcon)(unsafe.Pointer(icon.Native()))

	C.gtk_app_chooser_button_append_custom_item(_arg0, _arg1, _arg2, _arg3)
}

// AppendSeparator appends a separator to the list of applications that is
// shown in the popup.
func (s appChooserButton) AppendSeparator() {
	var _arg0 *C.GtkAppChooserButton

	_arg0 = (*C.GtkAppChooserButton)(unsafe.Pointer(s.Native()))

	C.gtk_app_chooser_button_append_separator(_arg0)
}

// Heading returns the text to display at the top of the dialog.
func (s appChooserButton) Heading() string {
	var _arg0 *C.GtkAppChooserButton

	_arg0 = (*C.GtkAppChooserButton)(unsafe.Pointer(s.Native()))

	var _cret *C.char

	_cret = C.gtk_app_chooser_button_get_heading(_arg0)

	var _utf8 string

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Modal gets whether the dialog is modal.
func (s appChooserButton) Modal() bool {
	var _arg0 *C.GtkAppChooserButton

	_arg0 = (*C.GtkAppChooserButton)(unsafe.Pointer(s.Native()))

	var _cret C.gboolean

	_cret = C.gtk_app_chooser_button_get_modal(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// ShowDefaultItem returns whether the dropdown menu should show the default
// application at the top.
func (s appChooserButton) ShowDefaultItem() bool {
	var _arg0 *C.GtkAppChooserButton

	_arg0 = (*C.GtkAppChooserButton)(unsafe.Pointer(s.Native()))

	var _cret C.gboolean

	_cret = C.gtk_app_chooser_button_get_show_default_item(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// ShowDialogItem returns whether the dropdown menu shows an item for a
// `GtkAppChooserDialog`.
func (s appChooserButton) ShowDialogItem() bool {
	var _arg0 *C.GtkAppChooserButton

	_arg0 = (*C.GtkAppChooserButton)(unsafe.Pointer(s.Native()))

	var _cret C.gboolean

	_cret = C.gtk_app_chooser_button_get_show_dialog_item(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// SetActiveCustomItem selects a custom item.
//
// See [method@Gtk.AppChooserButton.append_custom_item].
//
// Use [method@Gtk.AppChooser.refresh] to bring the selection to its initial
// state.
func (s appChooserButton) SetActiveCustomItem(name string) {
	var _arg0 *C.GtkAppChooserButton
	var _arg1 *C.char

	_arg0 = (*C.GtkAppChooserButton)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_app_chooser_button_set_active_custom_item(_arg0, _arg1)
}

// SetHeading sets the text to display at the top of the dialog.
//
// If the heading is not set, the dialog displays a default text.
func (s appChooserButton) SetHeading(heading string) {
	var _arg0 *C.GtkAppChooserButton
	var _arg1 *C.char

	_arg0 = (*C.GtkAppChooserButton)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(heading))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_app_chooser_button_set_heading(_arg0, _arg1)
}

// SetModal sets whether the dialog should be modal.
func (s appChooserButton) SetModal(modal bool) {
	var _arg0 *C.GtkAppChooserButton
	var _arg1 C.gboolean

	_arg0 = (*C.GtkAppChooserButton)(unsafe.Pointer(s.Native()))
	if modal {
		_arg1 = C.gboolean(1)
	}

	C.gtk_app_chooser_button_set_modal(_arg0, _arg1)
}

// SetShowDefaultItem sets whether the dropdown menu of this button should
// show the default application for the given content type at top.
func (s appChooserButton) SetShowDefaultItem(setting bool) {
	var _arg0 *C.GtkAppChooserButton
	var _arg1 C.gboolean

	_arg0 = (*C.GtkAppChooserButton)(unsafe.Pointer(s.Native()))
	if setting {
		_arg1 = C.gboolean(1)
	}

	C.gtk_app_chooser_button_set_show_default_item(_arg0, _arg1)
}

// SetShowDialogItem sets whether the dropdown menu of this button should
// show an entry to trigger a `GtkAppChooserDialog`.
func (s appChooserButton) SetShowDialogItem(setting bool) {
	var _arg0 *C.GtkAppChooserButton
	var _arg1 C.gboolean

	_arg0 = (*C.GtkAppChooserButton)(unsafe.Pointer(s.Native()))
	if setting {
		_arg1 = C.gboolean(1)
	}

	C.gtk_app_chooser_button_set_show_dialog_item(_arg0, _arg1)
}

// AppChooserDialog: `GtkAppChooserDialog` shows a `GtkAppChooserWidget` inside
// a `GtkDialog`.
//
// !An example GtkAppChooserDialog (appchooserdialog.png)
//
// Note that `GtkAppChooserDialog` does not have any interesting methods of its
// own. Instead, you should get the embedded `GtkAppChooserWidget` using
// [method@Gtk.AppChooserDialog.get_widget] and call its methods if the generic
// [iface@Gtk.AppChooser] interface is not sufficient for your needs.
//
// To set the heading that is shown above the `GtkAppChooserWidget`, use
// [method@Gtk.AppChooserDialog.set_heading].
type AppChooserDialog interface {
	Dialog
	Accessible
	AppChooser
	Buildable
	ConstraintTarget
	Native
	Root
	ShortcutManager

	// Heading returns the text to display at the top of the dialog.
	Heading() string
	// SetHeading sets the text to display at the top of the dialog.
	//
	// If the heading is not set, the dialog displays a default text.
	SetHeading(heading string)
}

// appChooserDialog implements the AppChooserDialog interface.
type appChooserDialog struct {
	Dialog
	Accessible
	AppChooser
	Buildable
	ConstraintTarget
	Native
	Root
	ShortcutManager
}

var _ AppChooserDialog = (*appChooserDialog)(nil)

// WrapAppChooserDialog wraps a GObject to the right type. It is
// primarily used internally.
func WrapAppChooserDialog(obj *externglib.Object) AppChooserDialog {
	return AppChooserDialog{
		Dialog:           WrapDialog(obj),
		Accessible:       WrapAccessible(obj),
		AppChooser:       WrapAppChooser(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
		Native:           WrapNative(obj),
		Root:             WrapRoot(obj),
		ShortcutManager:  WrapShortcutManager(obj),
	}
}

func marshalAppChooserDialog(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapAppChooserDialog(obj), nil
}

// Heading returns the text to display at the top of the dialog.
func (s appChooserDialog) Heading() string {
	var _arg0 *C.GtkAppChooserDialog

	_arg0 = (*C.GtkAppChooserDialog)(unsafe.Pointer(s.Native()))

	var _cret *C.char

	_cret = C.gtk_app_chooser_dialog_get_heading(_arg0)

	var _utf8 string

	_utf8 = C.GoString(_cret)

	return _utf8
}

// SetHeading sets the text to display at the top of the dialog.
//
// If the heading is not set, the dialog displays a default text.
func (s appChooserDialog) SetHeading(heading string) {
	var _arg0 *C.GtkAppChooserDialog
	var _arg1 *C.char

	_arg0 = (*C.GtkAppChooserDialog)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(heading))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_app_chooser_dialog_set_heading(_arg0, _arg1)
}

// AppChooserWidget: `GtkAppChooserWidget` is a widget for selecting
// applications.
//
// It is the main building block for [class@Gtk.AppChooserDialog]. Most
// applications only need to use the latter; but you can use this widget as part
// of a larger widget if you have special needs.
//
// `GtkAppChooserWidget` offers detailed control over what applications are
// shown, using the [property@Gtk.AppChooserWidget:show-default],
// [property@Gtk.AppChooserWidget:show-recommended],
// [property@Gtk.AppChooserWidget:show-fallback],
// [property@Gtk.AppChooserWidget:show-other] and
// [property@Gtk.AppChooserWidget:show-all] properties. See the
// [iface@Gtk.AppChooser] documentation for more information about these groups
// of applications.
//
// To keep track of the selected application, use the
// [signal@Gtk.AppChooserWidget::application-selected] and
// [signal@Gtk.AppChooserWidget::application-activated] signals.
//
//
// CSS nodes
//
// `GtkAppChooserWidget` has a single CSS node with name appchooser.
type AppChooserWidget interface {
	Widget
	Accessible
	AppChooser
	Buildable
	ConstraintTarget

	// DefaultText returns the text that is shown if there are not applications
	// that can handle the content type.
	DefaultText() string
	// ShowAll gets whether the app chooser should show all applications in a
	// flat list.
	ShowAll() bool
	// ShowDefault gets whether the app chooser should show the default handler
	// for the content type in a separate section.
	ShowDefault() bool
	// ShowFallback gets whether the app chooser should show related
	// applications for the content type in a separate section.
	ShowFallback() bool
	// ShowOther gets whether the app chooser should show applications which are
	// unrelated to the content type.
	ShowOther() bool
	// ShowRecommended gets whether the app chooser should show recommended
	// applications for the content type in a separate section.
	ShowRecommended() bool
	// SetDefaultText sets the text that is shown if there are not applications
	// that can handle the content type.
	SetDefaultText(text string)
	// SetShowAll sets whether the app chooser should show all applications in a
	// flat list.
	SetShowAll(setting bool)
	// SetShowDefault sets whether the app chooser should show the default
	// handler for the content type in a separate section.
	SetShowDefault(setting bool)
	// SetShowFallback sets whether the app chooser should show related
	// applications for the content type in a separate section.
	SetShowFallback(setting bool)
	// SetShowOther sets whether the app chooser should show applications which
	// are unrelated to the content type.
	SetShowOther(setting bool)
	// SetShowRecommended sets whether the app chooser should show recommended
	// applications for the content type in a separate section.
	SetShowRecommended(setting bool)
}

// appChooserWidget implements the AppChooserWidget interface.
type appChooserWidget struct {
	Widget
	Accessible
	AppChooser
	Buildable
	ConstraintTarget
}

var _ AppChooserWidget = (*appChooserWidget)(nil)

// WrapAppChooserWidget wraps a GObject to the right type. It is
// primarily used internally.
func WrapAppChooserWidget(obj *externglib.Object) AppChooserWidget {
	return AppChooserWidget{
		Widget:           WrapWidget(obj),
		Accessible:       WrapAccessible(obj),
		AppChooser:       WrapAppChooser(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
	}
}

func marshalAppChooserWidget(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapAppChooserWidget(obj), nil
}

// DefaultText returns the text that is shown if there are not applications
// that can handle the content type.
func (s appChooserWidget) DefaultText() string {
	var _arg0 *C.GtkAppChooserWidget

	_arg0 = (*C.GtkAppChooserWidget)(unsafe.Pointer(s.Native()))

	var _cret *C.char

	_cret = C.gtk_app_chooser_widget_get_default_text(_arg0)

	var _utf8 string

	_utf8 = C.GoString(_cret)

	return _utf8
}

// ShowAll gets whether the app chooser should show all applications in a
// flat list.
func (s appChooserWidget) ShowAll() bool {
	var _arg0 *C.GtkAppChooserWidget

	_arg0 = (*C.GtkAppChooserWidget)(unsafe.Pointer(s.Native()))

	var _cret C.gboolean

	_cret = C.gtk_app_chooser_widget_get_show_all(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// ShowDefault gets whether the app chooser should show the default handler
// for the content type in a separate section.
func (s appChooserWidget) ShowDefault() bool {
	var _arg0 *C.GtkAppChooserWidget

	_arg0 = (*C.GtkAppChooserWidget)(unsafe.Pointer(s.Native()))

	var _cret C.gboolean

	_cret = C.gtk_app_chooser_widget_get_show_default(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// ShowFallback gets whether the app chooser should show related
// applications for the content type in a separate section.
func (s appChooserWidget) ShowFallback() bool {
	var _arg0 *C.GtkAppChooserWidget

	_arg0 = (*C.GtkAppChooserWidget)(unsafe.Pointer(s.Native()))

	var _cret C.gboolean

	_cret = C.gtk_app_chooser_widget_get_show_fallback(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// ShowOther gets whether the app chooser should show applications which are
// unrelated to the content type.
func (s appChooserWidget) ShowOther() bool {
	var _arg0 *C.GtkAppChooserWidget

	_arg0 = (*C.GtkAppChooserWidget)(unsafe.Pointer(s.Native()))

	var _cret C.gboolean

	_cret = C.gtk_app_chooser_widget_get_show_other(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// ShowRecommended gets whether the app chooser should show recommended
// applications for the content type in a separate section.
func (s appChooserWidget) ShowRecommended() bool {
	var _arg0 *C.GtkAppChooserWidget

	_arg0 = (*C.GtkAppChooserWidget)(unsafe.Pointer(s.Native()))

	var _cret C.gboolean

	_cret = C.gtk_app_chooser_widget_get_show_recommended(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// SetDefaultText sets the text that is shown if there are not applications
// that can handle the content type.
func (s appChooserWidget) SetDefaultText(text string) {
	var _arg0 *C.GtkAppChooserWidget
	var _arg1 *C.char

	_arg0 = (*C.GtkAppChooserWidget)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_app_chooser_widget_set_default_text(_arg0, _arg1)
}

// SetShowAll sets whether the app chooser should show all applications in a
// flat list.
func (s appChooserWidget) SetShowAll(setting bool) {
	var _arg0 *C.GtkAppChooserWidget
	var _arg1 C.gboolean

	_arg0 = (*C.GtkAppChooserWidget)(unsafe.Pointer(s.Native()))
	if setting {
		_arg1 = C.gboolean(1)
	}

	C.gtk_app_chooser_widget_set_show_all(_arg0, _arg1)
}

// SetShowDefault sets whether the app chooser should show the default
// handler for the content type in a separate section.
func (s appChooserWidget) SetShowDefault(setting bool) {
	var _arg0 *C.GtkAppChooserWidget
	var _arg1 C.gboolean

	_arg0 = (*C.GtkAppChooserWidget)(unsafe.Pointer(s.Native()))
	if setting {
		_arg1 = C.gboolean(1)
	}

	C.gtk_app_chooser_widget_set_show_default(_arg0, _arg1)
}

// SetShowFallback sets whether the app chooser should show related
// applications for the content type in a separate section.
func (s appChooserWidget) SetShowFallback(setting bool) {
	var _arg0 *C.GtkAppChooserWidget
	var _arg1 C.gboolean

	_arg0 = (*C.GtkAppChooserWidget)(unsafe.Pointer(s.Native()))
	if setting {
		_arg1 = C.gboolean(1)
	}

	C.gtk_app_chooser_widget_set_show_fallback(_arg0, _arg1)
}

// SetShowOther sets whether the app chooser should show applications which
// are unrelated to the content type.
func (s appChooserWidget) SetShowOther(setting bool) {
	var _arg0 *C.GtkAppChooserWidget
	var _arg1 C.gboolean

	_arg0 = (*C.GtkAppChooserWidget)(unsafe.Pointer(s.Native()))
	if setting {
		_arg1 = C.gboolean(1)
	}

	C.gtk_app_chooser_widget_set_show_other(_arg0, _arg1)
}

// SetShowRecommended sets whether the app chooser should show recommended
// applications for the content type in a separate section.
func (s appChooserWidget) SetShowRecommended(setting bool) {
	var _arg0 *C.GtkAppChooserWidget
	var _arg1 C.gboolean

	_arg0 = (*C.GtkAppChooserWidget)(unsafe.Pointer(s.Native()))
	if setting {
		_arg1 = C.gboolean(1)
	}

	C.gtk_app_chooser_widget_set_show_recommended(_arg0, _arg1)
}

// AspectFrame: `GtkAspectFrame` preserves the aspect ratio of its child.
//
// The frame can respect the aspect ratio of the child widget, or use its own
// aspect ratio.
//
//
// CSS nodes
//
// `GtkAspectFrame` uses a CSS node with name `frame`.
type AspectFrame interface {
	Widget
	Accessible
	Buildable
	ConstraintTarget

	// ObeyChild returns whether the child's size request should override the
	// set aspect ratio of the `GtkAspectFrame`.
	ObeyChild() bool
	// Ratio returns the desired aspect ratio of the child.
	Ratio() float32
	// Xalign returns the horizontal alignment of the child within the
	// allocation of the `GtkAspectFrame`.
	Xalign() float32
	// Yalign returns the vertical alignment of the child within the allocation
	// of the `GtkAspectFrame`.
	Yalign() float32
	// SetChild sets the child widget of @self.
	SetChild(child Widget)
	// SetObeyChild sets whether the aspect ratio of the child's size request
	// should override the set aspect ratio of the `GtkAspectFrame`.
	SetObeyChild(obeyChild bool)
	// SetRatio sets the desired aspect ratio of the child.
	SetRatio(ratio float32)
	// SetXalign sets the horizontal alignment of the child within the
	// allocation of the `GtkAspectFrame`.
	SetXalign(xalign float32)
	// SetYalign sets the vertical alignment of the child within the allocation
	// of the `GtkAspectFrame`.
	SetYalign(yalign float32)
}

// aspectFrame implements the AspectFrame interface.
type aspectFrame struct {
	Widget
	Accessible
	Buildable
	ConstraintTarget
}

var _ AspectFrame = (*aspectFrame)(nil)

// WrapAspectFrame wraps a GObject to the right type. It is
// primarily used internally.
func WrapAspectFrame(obj *externglib.Object) AspectFrame {
	return AspectFrame{
		Widget:           WrapWidget(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
	}
}

func marshalAspectFrame(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapAspectFrame(obj), nil
}

// ObeyChild returns whether the child's size request should override the
// set aspect ratio of the `GtkAspectFrame`.
func (s aspectFrame) ObeyChild() bool {
	var _arg0 *C.GtkAspectFrame

	_arg0 = (*C.GtkAspectFrame)(unsafe.Pointer(s.Native()))

	var _cret C.gboolean

	_cret = C.gtk_aspect_frame_get_obey_child(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// Ratio returns the desired aspect ratio of the child.
func (s aspectFrame) Ratio() float32 {
	var _arg0 *C.GtkAspectFrame

	_arg0 = (*C.GtkAspectFrame)(unsafe.Pointer(s.Native()))

	var _cret C.float

	_cret = C.gtk_aspect_frame_get_ratio(_arg0)

	var _gfloat float32

	_gfloat = (float32)(_cret)

	return _gfloat
}

// Xalign returns the horizontal alignment of the child within the
// allocation of the `GtkAspectFrame`.
func (s aspectFrame) Xalign() float32 {
	var _arg0 *C.GtkAspectFrame

	_arg0 = (*C.GtkAspectFrame)(unsafe.Pointer(s.Native()))

	var _cret C.float

	_cret = C.gtk_aspect_frame_get_xalign(_arg0)

	var _gfloat float32

	_gfloat = (float32)(_cret)

	return _gfloat
}

// Yalign returns the vertical alignment of the child within the allocation
// of the `GtkAspectFrame`.
func (s aspectFrame) Yalign() float32 {
	var _arg0 *C.GtkAspectFrame

	_arg0 = (*C.GtkAspectFrame)(unsafe.Pointer(s.Native()))

	var _cret C.float

	_cret = C.gtk_aspect_frame_get_yalign(_arg0)

	var _gfloat float32

	_gfloat = (float32)(_cret)

	return _gfloat
}

// SetChild sets the child widget of @self.
func (s aspectFrame) SetChild(child Widget) {
	var _arg0 *C.GtkAspectFrame
	var _arg1 *C.GtkWidget

	_arg0 = (*C.GtkAspectFrame)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_aspect_frame_set_child(_arg0, _arg1)
}

// SetObeyChild sets whether the aspect ratio of the child's size request
// should override the set aspect ratio of the `GtkAspectFrame`.
func (s aspectFrame) SetObeyChild(obeyChild bool) {
	var _arg0 *C.GtkAspectFrame
	var _arg1 C.gboolean

	_arg0 = (*C.GtkAspectFrame)(unsafe.Pointer(s.Native()))
	if obeyChild {
		_arg1 = C.gboolean(1)
	}

	C.gtk_aspect_frame_set_obey_child(_arg0, _arg1)
}

// SetRatio sets the desired aspect ratio of the child.
func (s aspectFrame) SetRatio(ratio float32) {
	var _arg0 *C.GtkAspectFrame
	var _arg1 C.float

	_arg0 = (*C.GtkAspectFrame)(unsafe.Pointer(s.Native()))
	_arg1 = C.float(ratio)

	C.gtk_aspect_frame_set_ratio(_arg0, _arg1)
}

// SetXalign sets the horizontal alignment of the child within the
// allocation of the `GtkAspectFrame`.
func (s aspectFrame) SetXalign(xalign float32) {
	var _arg0 *C.GtkAspectFrame
	var _arg1 C.float

	_arg0 = (*C.GtkAspectFrame)(unsafe.Pointer(s.Native()))
	_arg1 = C.float(xalign)

	C.gtk_aspect_frame_set_xalign(_arg0, _arg1)
}

// SetYalign sets the vertical alignment of the child within the allocation
// of the `GtkAspectFrame`.
func (s aspectFrame) SetYalign(yalign float32) {
	var _arg0 *C.GtkAspectFrame
	var _arg1 C.float

	_arg0 = (*C.GtkAspectFrame)(unsafe.Pointer(s.Native()))
	_arg1 = C.float(yalign)

	C.gtk_aspect_frame_set_yalign(_arg0, _arg1)
}

// Assistant: `GtkAssistant` is used to represent a complex as a series of
// steps.
//
// !An example GtkAssistant (assistant.png)
//
// Each step consists of one or more pages. `GtkAssistant` guides the user
// through the pages, and controls the page flow to collect the data needed for
// the operation.
//
// `GtkAssistant` handles which buttons to show and to make sensitive based on
// page sequence knowledge and the [enum@Gtk.AssistantPageType] of each page in
// addition to state information like the *completed* and *committed* page
// statuses.
//
// If you have a case that doesn’t quite fit in `GtkAssistant`s way of handling
// buttons, you can use the GTK_ASSISTANT_PAGE_CUSTOM page type and handle
// buttons yourself.
//
// `GtkAssistant` maintains a `GtkAssistantPage` object for each added child,
// which holds additional per-child properties. You obtain the
// `GtkAssistantPage` for a child with [method@Gtk.Assistant.get_page].
//
//
// GtkAssistant as GtkBuildable
//
// The `GtkAssistant` implementation of the `GtkBuildable` interface exposes the
// @action_area as internal children with the name “action_area”.
//
// To add pages to an assistant in `GtkBuilder`, simply add it as a child to the
// `GtkAssistant` object. If you need to set per-object properties, create a
// `GtkAssistantPage` object explicitly, and set the child widget as a property
// on it.
//
//
// CSS nodes
//
// `GtkAssistant` has a single CSS node with the name window and style class
// .assistant.
type Assistant interface {
	Window
	Accessible
	Buildable
	ConstraintTarget
	Native
	Root
	ShortcutManager

	// AddActionWidget adds a widget to the action area of a `GtkAssistant`.
	AddActionWidget(child Widget)
	// AppendPage appends a page to the @assistant.
	AppendPage(page Widget) int
	// Commit erases the visited page history.
	//
	// GTK will then hide the back button on the current page, and removes the
	// cancel button from subsequent pages.
	//
	// Use this when the information provided up to the current page is
	// hereafter deemed permanent and cannot be modified or undone. For example,
	// showing a progress page to track a long-running, unreversible operation
	// after the user has clicked apply on a confirmation page.
	Commit()
	// CurrentPage returns the page number of the current page.
	CurrentPage() int
	// NPages returns the number of pages in the @assistant
	NPages() int
	// PageComplete gets whether @page is complete.
	PageComplete(page Widget) bool
	// PageTitle gets the title for @page.
	PageTitle(page Widget) string
	// InsertPage inserts a page in the @assistant at a given position.
	InsertPage(page Widget, position int) int
	// NextPage: navigate to the next page.
	//
	// It is a programming error to call this function when there is no next
	// page.
	//
	// This function is for use when creating pages of the
	// GTK_ASSISTANT_PAGE_CUSTOM type.
	NextPage()
	// PrependPage prepends a page to the @assistant.
	PrependPage(page Widget) int
	// PreviousPage: navigate to the previous visited page.
	//
	// It is a programming error to call this function when no previous page is
	// available.
	//
	// This function is for use when creating pages of the
	// GTK_ASSISTANT_PAGE_CUSTOM type.
	PreviousPage()
	// RemoveActionWidget removes a widget from the action area of a
	// `GtkAssistant`.
	RemoveActionWidget(child Widget)
	// RemovePage removes the @page_num’s page from @assistant.
	RemovePage(pageNum int)
	// SetCurrentPage switches the page to @page_num.
	//
	// Note that this will only be necessary in custom buttons, as the
	// @assistant flow can be set with gtk_assistant_set_forward_page_func().
	SetCurrentPage(pageNum int)
	// SetPageComplete sets whether @page contents are complete.
	//
	// This will make @assistant update the buttons state to be able to continue
	// the task.
	SetPageComplete(page Widget, complete bool)
	// SetPageTitle sets a title for @page.
	//
	// The title is displayed in the header area of the assistant when @page is
	// the current page.
	SetPageTitle(page Widget, title string)
	// SetPageType sets the page type for @page.
	//
	// The page type determines the page behavior in the @assistant.
	SetPageType(page Widget, typ AssistantPageType)
	// UpdateButtonsState forces @assistant to recompute the buttons state.
	//
	// GTK automatically takes care of this in most situations, e.g. when the
	// user goes to a different page, or when the visibility or completeness of
	// a page changes.
	//
	// One situation where it can be necessary to call this function is when
	// changing a value on the current page affects the future page flow of the
	// assistant.
	UpdateButtonsState()
}

// assistant implements the Assistant interface.
type assistant struct {
	Window
	Accessible
	Buildable
	ConstraintTarget
	Native
	Root
	ShortcutManager
}

var _ Assistant = (*assistant)(nil)

// WrapAssistant wraps a GObject to the right type. It is
// primarily used internally.
func WrapAssistant(obj *externglib.Object) Assistant {
	return Assistant{
		Window:           WrapWindow(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
		Native:           WrapNative(obj),
		Root:             WrapRoot(obj),
		ShortcutManager:  WrapShortcutManager(obj),
	}
}

func marshalAssistant(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapAssistant(obj), nil
}

// AddActionWidget adds a widget to the action area of a `GtkAssistant`.
func (a assistant) AddActionWidget(child Widget) {
	var _arg0 *C.GtkAssistant
	var _arg1 *C.GtkWidget

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_assistant_add_action_widget(_arg0, _arg1)
}

// AppendPage appends a page to the @assistant.
func (a assistant) AppendPage(page Widget) int {
	var _arg0 *C.GtkAssistant
	var _arg1 *C.GtkWidget

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(page.Native()))

	var _cret C.int

	_cret = C.gtk_assistant_append_page(_arg0, _arg1)

	var _gint int

	_gint = (int)(_cret)

	return _gint
}

// Commit erases the visited page history.
//
// GTK will then hide the back button on the current page, and removes the
// cancel button from subsequent pages.
//
// Use this when the information provided up to the current page is
// hereafter deemed permanent and cannot be modified or undone. For example,
// showing a progress page to track a long-running, unreversible operation
// after the user has clicked apply on a confirmation page.
func (a assistant) Commit() {
	var _arg0 *C.GtkAssistant

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))

	C.gtk_assistant_commit(_arg0)
}

// CurrentPage returns the page number of the current page.
func (a assistant) CurrentPage() int {
	var _arg0 *C.GtkAssistant

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))

	var _cret C.int

	_cret = C.gtk_assistant_get_current_page(_arg0)

	var _gint int

	_gint = (int)(_cret)

	return _gint
}

// NPages returns the number of pages in the @assistant
func (a assistant) NPages() int {
	var _arg0 *C.GtkAssistant

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))

	var _cret C.int

	_cret = C.gtk_assistant_get_n_pages(_arg0)

	var _gint int

	_gint = (int)(_cret)

	return _gint
}

// PageComplete gets whether @page is complete.
func (a assistant) PageComplete(page Widget) bool {
	var _arg0 *C.GtkAssistant
	var _arg1 *C.GtkWidget

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(page.Native()))

	var _cret C.gboolean

	_cret = C.gtk_assistant_get_page_complete(_arg0, _arg1)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// PageTitle gets the title for @page.
func (a assistant) PageTitle(page Widget) string {
	var _arg0 *C.GtkAssistant
	var _arg1 *C.GtkWidget

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(page.Native()))

	var _cret *C.char

	_cret = C.gtk_assistant_get_page_title(_arg0, _arg1)

	var _utf8 string

	_utf8 = C.GoString(_cret)

	return _utf8
}

// InsertPage inserts a page in the @assistant at a given position.
func (a assistant) InsertPage(page Widget, position int) int {
	var _arg0 *C.GtkAssistant
	var _arg1 *C.GtkWidget
	var _arg2 C.int

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(page.Native()))
	_arg2 = C.int(position)

	var _cret C.int

	_cret = C.gtk_assistant_insert_page(_arg0, _arg1, _arg2)

	var _gint int

	_gint = (int)(_cret)

	return _gint
}

// NextPage: navigate to the next page.
//
// It is a programming error to call this function when there is no next
// page.
//
// This function is for use when creating pages of the
// GTK_ASSISTANT_PAGE_CUSTOM type.
func (a assistant) NextPage() {
	var _arg0 *C.GtkAssistant

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))

	C.gtk_assistant_next_page(_arg0)
}

// PrependPage prepends a page to the @assistant.
func (a assistant) PrependPage(page Widget) int {
	var _arg0 *C.GtkAssistant
	var _arg1 *C.GtkWidget

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(page.Native()))

	var _cret C.int

	_cret = C.gtk_assistant_prepend_page(_arg0, _arg1)

	var _gint int

	_gint = (int)(_cret)

	return _gint
}

// PreviousPage: navigate to the previous visited page.
//
// It is a programming error to call this function when no previous page is
// available.
//
// This function is for use when creating pages of the
// GTK_ASSISTANT_PAGE_CUSTOM type.
func (a assistant) PreviousPage() {
	var _arg0 *C.GtkAssistant

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))

	C.gtk_assistant_previous_page(_arg0)
}

// RemoveActionWidget removes a widget from the action area of a
// `GtkAssistant`.
func (a assistant) RemoveActionWidget(child Widget) {
	var _arg0 *C.GtkAssistant
	var _arg1 *C.GtkWidget

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_assistant_remove_action_widget(_arg0, _arg1)
}

// RemovePage removes the @page_num’s page from @assistant.
func (a assistant) RemovePage(pageNum int) {
	var _arg0 *C.GtkAssistant
	var _arg1 C.int

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
	_arg1 = C.int(pageNum)

	C.gtk_assistant_remove_page(_arg0, _arg1)
}

// SetCurrentPage switches the page to @page_num.
//
// Note that this will only be necessary in custom buttons, as the
// @assistant flow can be set with gtk_assistant_set_forward_page_func().
func (a assistant) SetCurrentPage(pageNum int) {
	var _arg0 *C.GtkAssistant
	var _arg1 C.int

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
	_arg1 = C.int(pageNum)

	C.gtk_assistant_set_current_page(_arg0, _arg1)
}

// SetPageComplete sets whether @page contents are complete.
//
// This will make @assistant update the buttons state to be able to continue
// the task.
func (a assistant) SetPageComplete(page Widget, complete bool) {
	var _arg0 *C.GtkAssistant
	var _arg1 *C.GtkWidget
	var _arg2 C.gboolean

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(page.Native()))
	if complete {
		_arg2 = C.gboolean(1)
	}

	C.gtk_assistant_set_page_complete(_arg0, _arg1, _arg2)
}

// SetPageTitle sets a title for @page.
//
// The title is displayed in the header area of the assistant when @page is
// the current page.
func (a assistant) SetPageTitle(page Widget, title string) {
	var _arg0 *C.GtkAssistant
	var _arg1 *C.GtkWidget
	var _arg2 *C.char

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(page.Native()))
	_arg2 = (*C.char)(C.CString(title))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_assistant_set_page_title(_arg0, _arg1, _arg2)
}

// SetPageType sets the page type for @page.
//
// The page type determines the page behavior in the @assistant.
func (a assistant) SetPageType(page Widget, typ AssistantPageType) {
	var _arg0 *C.GtkAssistant
	var _arg1 *C.GtkWidget
	var _arg2 C.GtkAssistantPageType

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(page.Native()))
	_arg2 = (C.GtkAssistantPageType)(typ)

	C.gtk_assistant_set_page_type(_arg0, _arg1, _arg2)
}

// UpdateButtonsState forces @assistant to recompute the buttons state.
//
// GTK automatically takes care of this in most situations, e.g. when the
// user goes to a different page, or when the visibility or completeness of
// a page changes.
//
// One situation where it can be necessary to call this function is when
// changing a value on the current page affects the future page flow of the
// assistant.
func (a assistant) UpdateButtonsState() {
	var _arg0 *C.GtkAssistant

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))

	C.gtk_assistant_update_buttons_state(_arg0)
}

// AssistantPage: `GtkAssistantPage` is an auxiliary object used by
// `GtkAssistant.
type AssistantPage interface {
	gextras.Objector
}

// assistantPage implements the AssistantPage interface.
type assistantPage struct {
	gextras.Objector
}

var _ AssistantPage = (*assistantPage)(nil)

// WrapAssistantPage wraps a GObject to the right type. It is
// primarily used internally.
func WrapAssistantPage(obj *externglib.Object) AssistantPage {
	return AssistantPage{
		Objector: obj,
	}
}

func marshalAssistantPage(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapAssistantPage(obj), nil
}

// Calendar: `GtkCalendar` is a widget that displays a Gregorian calendar, one
// month at a time.
//
// !An example GtkCalendar (calendar.png)
//
// A `GtkCalendar` can be created with [ctor@Gtk.Calendar.new].
//
// The date that is currently displayed can be altered with
// [method@Gtk.Calendar.select_day].
//
// To place a visual marker on a particular day, use
// [method@Gtk.Calendar.mark_day] and to remove the marker,
// [method@Gtk.Calendar.unmark_day]. Alternative, all marks can be cleared with
// [method@Gtk.Calendar.clear_marks].
//
// The selected date can be retrieved from a `GtkCalendar` using
// [method@Gtk.Calendar.get_date].
//
// Users should be aware that, although the Gregorian calendar is the legal
// calendar in most countries, it was adopted progressively between 1582 and
// 1929. Display before these dates is likely to be historically incorrect.
//
//
// CSS nodes
//
// “` calendar.view ├── header │ ├── button │ ├── stack.month │ ├── button │ ├──
// button │ ├── label.year │ ╰── button ╰── grid ╰──
// label[.day-name][.week-number][.day-number][.other-month][.today] “`
//
// `GtkCalendar` has a main node with name calendar. It contains a subnode
// called header containing the widgets for switching between years and months.
//
// The grid subnode contains all day labels, including week numbers on the left
// (marked with the .week-number css class) and day names on top (marked with
// the .day-name css class).
//
// Day labels that belong to the previous or next month get the .other-month
// style class. The label of the current day get the .today style class.
//
// Marked day labels get the :selected state assigned.
type Calendar interface {
	Widget
	Accessible
	Buildable
	ConstraintTarget

	// ClearMarks: remove all visual markers.
	ClearMarks()
	// DayIsMarked returns if the @day of the @calendar is already marked.
	DayIsMarked(day uint) bool
	// ShowDayNames returns whether @self is currently showing the names of the
	// week days.
	//
	// This is the value of the [property@Gtk.Calendar:show-day-names] property.
	ShowDayNames() bool
	// ShowHeading returns whether @self is currently showing the heading.
	//
	// This is the value of the [property@Gtk.Calendar:show-heading] property.
	ShowHeading() bool
	// ShowWeekNumbers returns whether @self is showing week numbers right now.
	//
	// This is the value of the [property@Gtk.Calendar:show-week-numbers]
	// property.
	ShowWeekNumbers() bool
	// MarkDay places a visual marker on a particular day.
	MarkDay(day uint)
	// SelectDay switches to @date's year and month and select its day.
	SelectDay(date *glib.DateTime)
	// SetShowDayNames sets whether the calendar shows day names.
	SetShowDayNames(value bool)
	// SetShowHeading sets whether the calendar should show a heading.
	//
	// The heading contains the current year and month as well as buttons for
	// changing both.
	SetShowHeading(value bool)
	// SetShowWeekNumbers sets whether week numbers are shown in the calendar.
	SetShowWeekNumbers(value bool)
	// UnmarkDay removes the visual marker from a particular day.
	UnmarkDay(day uint)
}

// calendar implements the Calendar interface.
type calendar struct {
	Widget
	Accessible
	Buildable
	ConstraintTarget
}

var _ Calendar = (*calendar)(nil)

// WrapCalendar wraps a GObject to the right type. It is
// primarily used internally.
func WrapCalendar(obj *externglib.Object) Calendar {
	return Calendar{
		Widget:           WrapWidget(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
	}
}

func marshalCalendar(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCalendar(obj), nil
}

// ClearMarks: remove all visual markers.
func (c calendar) ClearMarks() {
	var _arg0 *C.GtkCalendar

	_arg0 = (*C.GtkCalendar)(unsafe.Pointer(c.Native()))

	C.gtk_calendar_clear_marks(_arg0)
}

// DayIsMarked returns if the @day of the @calendar is already marked.
func (c calendar) DayIsMarked(day uint) bool {
	var _arg0 *C.GtkCalendar
	var _arg1 C.guint

	_arg0 = (*C.GtkCalendar)(unsafe.Pointer(c.Native()))
	_arg1 = C.guint(day)

	var _cret C.gboolean

	_cret = C.gtk_calendar_get_day_is_marked(_arg0, _arg1)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// ShowDayNames returns whether @self is currently showing the names of the
// week days.
//
// This is the value of the [property@Gtk.Calendar:show-day-names] property.
func (s calendar) ShowDayNames() bool {
	var _arg0 *C.GtkCalendar

	_arg0 = (*C.GtkCalendar)(unsafe.Pointer(s.Native()))

	var _cret C.gboolean

	_cret = C.gtk_calendar_get_show_day_names(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// ShowHeading returns whether @self is currently showing the heading.
//
// This is the value of the [property@Gtk.Calendar:show-heading] property.
func (s calendar) ShowHeading() bool {
	var _arg0 *C.GtkCalendar

	_arg0 = (*C.GtkCalendar)(unsafe.Pointer(s.Native()))

	var _cret C.gboolean

	_cret = C.gtk_calendar_get_show_heading(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// ShowWeekNumbers returns whether @self is showing week numbers right now.
//
// This is the value of the [property@Gtk.Calendar:show-week-numbers]
// property.
func (s calendar) ShowWeekNumbers() bool {
	var _arg0 *C.GtkCalendar

	_arg0 = (*C.GtkCalendar)(unsafe.Pointer(s.Native()))

	var _cret C.gboolean

	_cret = C.gtk_calendar_get_show_week_numbers(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// MarkDay places a visual marker on a particular day.
func (c calendar) MarkDay(day uint) {
	var _arg0 *C.GtkCalendar
	var _arg1 C.guint

	_arg0 = (*C.GtkCalendar)(unsafe.Pointer(c.Native()))
	_arg1 = C.guint(day)

	C.gtk_calendar_mark_day(_arg0, _arg1)
}

// SelectDay switches to @date's year and month and select its day.
func (s calendar) SelectDay(date *glib.DateTime) {
	var _arg0 *C.GtkCalendar
	var _arg1 *C.GDateTime

	_arg0 = (*C.GtkCalendar)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GDateTime)(unsafe.Pointer(date.Native()))

	C.gtk_calendar_select_day(_arg0, _arg1)
}

// SetShowDayNames sets whether the calendar shows day names.
func (s calendar) SetShowDayNames(value bool) {
	var _arg0 *C.GtkCalendar
	var _arg1 C.gboolean

	_arg0 = (*C.GtkCalendar)(unsafe.Pointer(s.Native()))
	if value {
		_arg1 = C.gboolean(1)
	}

	C.gtk_calendar_set_show_day_names(_arg0, _arg1)
}

// SetShowHeading sets whether the calendar should show a heading.
//
// The heading contains the current year and month as well as buttons for
// changing both.
func (s calendar) SetShowHeading(value bool) {
	var _arg0 *C.GtkCalendar
	var _arg1 C.gboolean

	_arg0 = (*C.GtkCalendar)(unsafe.Pointer(s.Native()))
	if value {
		_arg1 = C.gboolean(1)
	}

	C.gtk_calendar_set_show_heading(_arg0, _arg1)
}

// SetShowWeekNumbers sets whether week numbers are shown in the calendar.
func (s calendar) SetShowWeekNumbers(value bool) {
	var _arg0 *C.GtkCalendar
	var _arg1 C.gboolean

	_arg0 = (*C.GtkCalendar)(unsafe.Pointer(s.Native()))
	if value {
		_arg1 = C.gboolean(1)
	}

	C.gtk_calendar_set_show_week_numbers(_arg0, _arg1)
}

// UnmarkDay removes the visual marker from a particular day.
func (c calendar) UnmarkDay(day uint) {
	var _arg0 *C.GtkCalendar
	var _arg1 C.guint

	_arg0 = (*C.GtkCalendar)(unsafe.Pointer(c.Native()))
	_arg1 = C.guint(day)

	C.gtk_calendar_unmark_day(_arg0, _arg1)
}

// CellAreaBox: a cell area that renders GtkCellRenderers into a row or a column
//
// The CellAreaBox renders cell renderers into a row or a column depending on
// its Orientation.
//
// GtkCellAreaBox uses a notion of packing. Packing refers to adding cell
// renderers with reference to a particular position in a CellAreaBox. There are
// two reference positions: the start and the end of the box. When the
// CellAreaBox is oriented in the GTK_ORIENTATION_VERTICAL orientation, the
// start is defined as the top of the box and the end is defined as the bottom.
// In the GTK_ORIENTATION_HORIZONTAL orientation start is defined as the left
// side and the end is defined as the right side.
//
// Alignments of CellRenderers rendered in adjacent rows can be configured by
// configuring the CellAreaBox align child cell property with
// gtk_cell_area_cell_set_property() or by specifying the "align" argument to
// gtk_cell_area_box_pack_start() and gtk_cell_area_box_pack_end().
type CellAreaBox interface {
	CellArea
	Buildable
	CellLayout
	Orientable

	// Spacing gets the spacing added between cell renderers.
	Spacing() int
	// PackEnd adds @renderer to @box, packed with reference to the end of @box.
	//
	// The @renderer is packed after (away from end of) any other CellRenderer
	// packed with reference to the end of @box.
	PackEnd(renderer CellRenderer, expand bool, align bool, fixed bool)
	// PackStart adds @renderer to @box, packed with reference to the start of
	// @box.
	//
	// The @renderer is packed after any other CellRenderer packed with
	// reference to the start of @box.
	PackStart(renderer CellRenderer, expand bool, align bool, fixed bool)
	// SetSpacing sets the spacing to add between cell renderers in @box.
	SetSpacing(spacing int)
}

// cellAreaBox implements the CellAreaBox interface.
type cellAreaBox struct {
	CellArea
	Buildable
	CellLayout
	Orientable
}

var _ CellAreaBox = (*cellAreaBox)(nil)

// WrapCellAreaBox wraps a GObject to the right type. It is
// primarily used internally.
func WrapCellAreaBox(obj *externglib.Object) CellAreaBox {
	return CellAreaBox{
		CellArea:   WrapCellArea(obj),
		Buildable:  WrapBuildable(obj),
		CellLayout: WrapCellLayout(obj),
		Orientable: WrapOrientable(obj),
	}
}

func marshalCellAreaBox(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCellAreaBox(obj), nil
}

// Spacing gets the spacing added between cell renderers.
func (b cellAreaBox) Spacing() int {
	var _arg0 *C.GtkCellAreaBox

	_arg0 = (*C.GtkCellAreaBox)(unsafe.Pointer(b.Native()))

	var _cret C.int

	_cret = C.gtk_cell_area_box_get_spacing(_arg0)

	var _gint int

	_gint = (int)(_cret)

	return _gint
}

// PackEnd adds @renderer to @box, packed with reference to the end of @box.
//
// The @renderer is packed after (away from end of) any other CellRenderer
// packed with reference to the end of @box.
func (b cellAreaBox) PackEnd(renderer CellRenderer, expand bool, align bool, fixed bool) {
	var _arg0 *C.GtkCellAreaBox
	var _arg1 *C.GtkCellRenderer
	var _arg2 C.gboolean
	var _arg3 C.gboolean
	var _arg4 C.gboolean

	_arg0 = (*C.GtkCellAreaBox)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))
	if expand {
		_arg2 = C.gboolean(1)
	}
	if align {
		_arg3 = C.gboolean(1)
	}
	if fixed {
		_arg4 = C.gboolean(1)
	}

	C.gtk_cell_area_box_pack_end(_arg0, _arg1, _arg2, _arg3, _arg4)
}

// PackStart adds @renderer to @box, packed with reference to the start of
// @box.
//
// The @renderer is packed after any other CellRenderer packed with
// reference to the start of @box.
func (b cellAreaBox) PackStart(renderer CellRenderer, expand bool, align bool, fixed bool) {
	var _arg0 *C.GtkCellAreaBox
	var _arg1 *C.GtkCellRenderer
	var _arg2 C.gboolean
	var _arg3 C.gboolean
	var _arg4 C.gboolean

	_arg0 = (*C.GtkCellAreaBox)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))
	if expand {
		_arg2 = C.gboolean(1)
	}
	if align {
		_arg3 = C.gboolean(1)
	}
	if fixed {
		_arg4 = C.gboolean(1)
	}

	C.gtk_cell_area_box_pack_start(_arg0, _arg1, _arg2, _arg3, _arg4)
}

// SetSpacing sets the spacing to add between cell renderers in @box.
func (b cellAreaBox) SetSpacing(spacing int) {
	var _arg0 *C.GtkCellAreaBox
	var _arg1 C.int

	_arg0 = (*C.GtkCellAreaBox)(unsafe.Pointer(b.Native()))
	_arg1 = C.int(spacing)

	C.gtk_cell_area_box_set_spacing(_arg0, _arg1)
}

// CellRendererAccel renders a keyboard accelerator in a cell
//
// CellRendererAccel displays a keyboard accelerator (i.e. a key combination
// like `Control + a`). If the cell renderer is editable, the accelerator can be
// changed by simply typing the new combination.
type CellRendererAccel interface {
	CellRendererText
}

// cellRendererAccel implements the CellRendererAccel interface.
type cellRendererAccel struct {
	CellRendererText
}

var _ CellRendererAccel = (*cellRendererAccel)(nil)

// WrapCellRendererAccel wraps a GObject to the right type. It is
// primarily used internally.
func WrapCellRendererAccel(obj *externglib.Object) CellRendererAccel {
	return CellRendererAccel{
		CellRendererText: WrapCellRendererText(obj),
	}
}

func marshalCellRendererAccel(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCellRendererAccel(obj), nil
}

// CellRendererCombo renders a combobox in a cell
//
// CellRendererCombo renders text in a cell like CellRendererText from which it
// is derived. But while CellRendererText offers a simple entry to edit the
// text, CellRendererCombo offers a ComboBox widget to edit the text. The values
// to display in the combo box are taken from the tree model specified in the
// CellRendererCombo:model property.
//
// The combo cell renderer takes care of adding a text cell renderer to the
// combo box and sets it to display the column specified by its
// CellRendererCombo:text-column property. Further properties of the combo box
// can be set in a handler for the CellRenderer::editing-started signal.
type CellRendererCombo interface {
	CellRendererText
}

// cellRendererCombo implements the CellRendererCombo interface.
type cellRendererCombo struct {
	CellRendererText
}

var _ CellRendererCombo = (*cellRendererCombo)(nil)

// WrapCellRendererCombo wraps a GObject to the right type. It is
// primarily used internally.
func WrapCellRendererCombo(obj *externglib.Object) CellRendererCombo {
	return CellRendererCombo{
		CellRendererText: WrapCellRendererText(obj),
	}
}

func marshalCellRendererCombo(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCellRendererCombo(obj), nil
}

// CellRendererPixbuf renders a pixbuf in a cell
//
// A CellRendererPixbuf can be used to render an image in a cell. It allows to
// render either a given Pixbuf (set via the CellRendererPixbuf:pixbuf property)
// or a named icon (set via the CellRendererPixbuf:icon-name property).
//
// To support the tree view, CellRendererPixbuf also supports rendering two
// alternative pixbufs, when the CellRenderer:is-expander property is true. If
// the CellRenderer:is-expanded property is true and the
// CellRendererPixbuf:pixbuf-expander-open property is set to a pixbuf, it
// renders that pixbuf, if the CellRenderer:is-expanded property is false and
// the CellRendererPixbuf:pixbuf-expander-closed property is set to a pixbuf, it
// renders that one.
type CellRendererPixbuf interface {
	CellRenderer
}

// cellRendererPixbuf implements the CellRendererPixbuf interface.
type cellRendererPixbuf struct {
	CellRenderer
}

var _ CellRendererPixbuf = (*cellRendererPixbuf)(nil)

// WrapCellRendererPixbuf wraps a GObject to the right type. It is
// primarily used internally.
func WrapCellRendererPixbuf(obj *externglib.Object) CellRendererPixbuf {
	return CellRendererPixbuf{
		CellRenderer: WrapCellRenderer(obj),
	}
}

func marshalCellRendererPixbuf(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCellRendererPixbuf(obj), nil
}

// CellRendererProgress renders numbers as progress bars
//
// CellRendererProgress renders a numeric value as a progress par in a cell.
// Additionally, it can display a text on top of the progress bar.
type CellRendererProgress interface {
	CellRenderer
	Orientable
}

// cellRendererProgress implements the CellRendererProgress interface.
type cellRendererProgress struct {
	CellRenderer
	Orientable
}

var _ CellRendererProgress = (*cellRendererProgress)(nil)

// WrapCellRendererProgress wraps a GObject to the right type. It is
// primarily used internally.
func WrapCellRendererProgress(obj *externglib.Object) CellRendererProgress {
	return CellRendererProgress{
		CellRenderer: WrapCellRenderer(obj),
		Orientable:   WrapOrientable(obj),
	}
}

func marshalCellRendererProgress(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCellRendererProgress(obj), nil
}

// CellRendererSpin renders a spin button in a cell
//
// CellRendererSpin renders text in a cell like CellRendererText from which it
// is derived. But while CellRendererText offers a simple entry to edit the
// text, CellRendererSpin offers a SpinButton widget. Of course, that means that
// the text has to be parseable as a floating point number.
//
// The range of the spinbutton is taken from the adjustment property of the cell
// renderer, which can be set explicitly or mapped to a column in the tree
// model, like all properties of cell renders. CellRendererSpin also has
// properties for the CellRendererSpin:climb-rate and the number of
// CellRendererSpin:digits to display. Other SpinButton properties can be set in
// a handler for the CellRenderer::editing-started signal.
//
// The CellRendererSpin cell renderer was added in GTK 2.10.
type CellRendererSpin interface {
	CellRendererText
}

// cellRendererSpin implements the CellRendererSpin interface.
type cellRendererSpin struct {
	CellRendererText
}

var _ CellRendererSpin = (*cellRendererSpin)(nil)

// WrapCellRendererSpin wraps a GObject to the right type. It is
// primarily used internally.
func WrapCellRendererSpin(obj *externglib.Object) CellRendererSpin {
	return CellRendererSpin{
		CellRendererText: WrapCellRendererText(obj),
	}
}

func marshalCellRendererSpin(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCellRendererSpin(obj), nil
}

// CellRendererSpinner renders a spinning animation in a cell
//
// GtkCellRendererSpinner renders a spinning animation in a cell, very similar
// to Spinner. It can often be used as an alternative to a CellRendererProgress
// for displaying indefinite activity, instead of actual progress.
//
// To start the animation in a cell, set the CellRendererSpinner:active property
// to true and increment the CellRendererSpinner:pulse property at regular
// intervals. The usual way to set the cell renderer properties for each cell is
// to bind them to columns in your tree model using e.g.
// gtk_tree_view_column_add_attribute().
type CellRendererSpinner interface {
	CellRenderer
}

// cellRendererSpinner implements the CellRendererSpinner interface.
type cellRendererSpinner struct {
	CellRenderer
}

var _ CellRendererSpinner = (*cellRendererSpinner)(nil)

// WrapCellRendererSpinner wraps a GObject to the right type. It is
// primarily used internally.
func WrapCellRendererSpinner(obj *externglib.Object) CellRendererSpinner {
	return CellRendererSpinner{
		CellRenderer: WrapCellRenderer(obj),
	}
}

func marshalCellRendererSpinner(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCellRendererSpinner(obj), nil
}

// CellRendererToggle renders a toggle button in a cell
//
// CellRendererToggle renders a toggle button in a cell. The button is drawn as
// a radio or a checkbutton, depending on the CellRendererToggle:radio property.
// When activated, it emits the CellRendererToggle::toggled signal.
type CellRendererToggle interface {
	CellRenderer

	// Activatable returns whether the cell renderer is activatable. See
	// gtk_cell_renderer_toggle_set_activatable().
	Activatable() bool
	// Active returns whether the cell renderer is active. See
	// gtk_cell_renderer_toggle_set_active().
	Active() bool
	// Radio returns whether we’re rendering radio toggles rather than
	// checkboxes.
	Radio() bool
	// SetActivatable makes the cell renderer activatable.
	SetActivatable(setting bool)
	// SetActive activates or deactivates a cell renderer.
	SetActive(setting bool)
	// SetRadio: if @radio is true, the cell renderer renders a radio toggle
	// (i.e. a toggle in a group of mutually-exclusive toggles). If false, it
	// renders a check toggle (a standalone boolean option). This can be set
	// globally for the cell renderer, or changed just before rendering each
	// cell in the model (for TreeView, you set up a per-row setting using
	// TreeViewColumn to associate model columns with cell renderer properties).
	SetRadio(radio bool)
}

// cellRendererToggle implements the CellRendererToggle interface.
type cellRendererToggle struct {
	CellRenderer
}

var _ CellRendererToggle = (*cellRendererToggle)(nil)

// WrapCellRendererToggle wraps a GObject to the right type. It is
// primarily used internally.
func WrapCellRendererToggle(obj *externglib.Object) CellRendererToggle {
	return CellRendererToggle{
		CellRenderer: WrapCellRenderer(obj),
	}
}

func marshalCellRendererToggle(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCellRendererToggle(obj), nil
}

// Activatable returns whether the cell renderer is activatable. See
// gtk_cell_renderer_toggle_set_activatable().
func (t cellRendererToggle) Activatable() bool {
	var _arg0 *C.GtkCellRendererToggle

	_arg0 = (*C.GtkCellRendererToggle)(unsafe.Pointer(t.Native()))

	var _cret C.gboolean

	_cret = C.gtk_cell_renderer_toggle_get_activatable(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// Active returns whether the cell renderer is active. See
// gtk_cell_renderer_toggle_set_active().
func (t cellRendererToggle) Active() bool {
	var _arg0 *C.GtkCellRendererToggle

	_arg0 = (*C.GtkCellRendererToggle)(unsafe.Pointer(t.Native()))

	var _cret C.gboolean

	_cret = C.gtk_cell_renderer_toggle_get_active(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// Radio returns whether we’re rendering radio toggles rather than
// checkboxes.
func (t cellRendererToggle) Radio() bool {
	var _arg0 *C.GtkCellRendererToggle

	_arg0 = (*C.GtkCellRendererToggle)(unsafe.Pointer(t.Native()))

	var _cret C.gboolean

	_cret = C.gtk_cell_renderer_toggle_get_radio(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// SetActivatable makes the cell renderer activatable.
func (t cellRendererToggle) SetActivatable(setting bool) {
	var _arg0 *C.GtkCellRendererToggle
	var _arg1 C.gboolean

	_arg0 = (*C.GtkCellRendererToggle)(unsafe.Pointer(t.Native()))
	if setting {
		_arg1 = C.gboolean(1)
	}

	C.gtk_cell_renderer_toggle_set_activatable(_arg0, _arg1)
}

// SetActive activates or deactivates a cell renderer.
func (t cellRendererToggle) SetActive(setting bool) {
	var _arg0 *C.GtkCellRendererToggle
	var _arg1 C.gboolean

	_arg0 = (*C.GtkCellRendererToggle)(unsafe.Pointer(t.Native()))
	if setting {
		_arg1 = C.gboolean(1)
	}

	C.gtk_cell_renderer_toggle_set_active(_arg0, _arg1)
}

// SetRadio: if @radio is true, the cell renderer renders a radio toggle
// (i.e. a toggle in a group of mutually-exclusive toggles). If false, it
// renders a check toggle (a standalone boolean option). This can be set
// globally for the cell renderer, or changed just before rendering each
// cell in the model (for TreeView, you set up a per-row setting using
// TreeViewColumn to associate model columns with cell renderer properties).
func (t cellRendererToggle) SetRadio(radio bool) {
	var _arg0 *C.GtkCellRendererToggle
	var _arg1 C.gboolean

	_arg0 = (*C.GtkCellRendererToggle)(unsafe.Pointer(t.Native()))
	if radio {
		_arg1 = C.gboolean(1)
	}

	C.gtk_cell_renderer_toggle_set_radio(_arg0, _arg1)
}

// CellView: a widget displaying a single row of a GtkTreeModel
//
// A CellView displays a single row of a TreeModel using a CellArea and
// CellAreaContext. A CellAreaContext can be provided to the CellView at
// construction time in order to keep the cellview in context of a group of cell
// views, this ensures that the renderers displayed will be properly aligned
// with each other (like the aligned cells in the menus of ComboBox).
//
// CellView is Orientable in order to decide in which orientation the underlying
// CellAreaContext should be allocated. Taking the ComboBox menu as an example,
// cellviews should be oriented horizontally if the menus are listed
// top-to-bottom and thus all share the same width but may have separate
// individual heights (left-to-right menus should be allocated vertically since
// they all share the same height but may have variable widths).
//
//
// CSS nodes
//
// GtkCellView has a single CSS node with name cellview.
type CellView interface {
	Widget
	Accessible
	Buildable
	CellLayout
	ConstraintTarget
	Orientable

	// DrawSensitive gets whether @cell_view is configured to draw all of its
	// cells in a sensitive state.
	DrawSensitive() bool
	// FitModel gets whether @cell_view is configured to request space to fit
	// the entire TreeModel.
	FitModel() bool
	// SetDisplayedRow sets the row of the model that is currently displayed by
	// the CellView. If the path is unset, then the contents of the cellview
	// “stick” at their last value; this is not normally a desired result, but
	// may be a needed intermediate state if say, the model for the CellView
	// becomes temporarily empty.
	SetDisplayedRow(path *TreePath)
	// SetDrawSensitive sets whether @cell_view should draw all of its cells in
	// a sensitive state, this is used by ComboBox menus to ensure that rows
	// with insensitive cells that contain children appear sensitive in the
	// parent menu item.
	SetDrawSensitive(drawSensitive bool)
	// SetFitModel sets whether @cell_view should request space to fit the
	// entire TreeModel.
	//
	// This is used by ComboBox to ensure that the cell view displayed on the
	// combo box’s button always gets enough space and does not resize when
	// selection changes.
	SetFitModel(fitModel bool)
	// SetModel sets the model for @cell_view. If @cell_view already has a model
	// set, it will remove it before setting the new model. If @model is nil,
	// then it will unset the old model.
	SetModel(model TreeModel)
}

// cellView implements the CellView interface.
type cellView struct {
	Widget
	Accessible
	Buildable
	CellLayout
	ConstraintTarget
	Orientable
}

var _ CellView = (*cellView)(nil)

// WrapCellView wraps a GObject to the right type. It is
// primarily used internally.
func WrapCellView(obj *externglib.Object) CellView {
	return CellView{
		Widget:           WrapWidget(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		CellLayout:       WrapCellLayout(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
		Orientable:       WrapOrientable(obj),
	}
}

func marshalCellView(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCellView(obj), nil
}

// DrawSensitive gets whether @cell_view is configured to draw all of its
// cells in a sensitive state.
func (c cellView) DrawSensitive() bool {
	var _arg0 *C.GtkCellView

	_arg0 = (*C.GtkCellView)(unsafe.Pointer(c.Native()))

	var _cret C.gboolean

	_cret = C.gtk_cell_view_get_draw_sensitive(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// FitModel gets whether @cell_view is configured to request space to fit
// the entire TreeModel.
func (c cellView) FitModel() bool {
	var _arg0 *C.GtkCellView

	_arg0 = (*C.GtkCellView)(unsafe.Pointer(c.Native()))

	var _cret C.gboolean

	_cret = C.gtk_cell_view_get_fit_model(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// SetDisplayedRow sets the row of the model that is currently displayed by
// the CellView. If the path is unset, then the contents of the cellview
// “stick” at their last value; this is not normally a desired result, but
// may be a needed intermediate state if say, the model for the CellView
// becomes temporarily empty.
func (c cellView) SetDisplayedRow(path *TreePath) {
	var _arg0 *C.GtkCellView
	var _arg1 *C.GtkTreePath

	_arg0 = (*C.GtkCellView)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	C.gtk_cell_view_set_displayed_row(_arg0, _arg1)
}

// SetDrawSensitive sets whether @cell_view should draw all of its cells in
// a sensitive state, this is used by ComboBox menus to ensure that rows
// with insensitive cells that contain children appear sensitive in the
// parent menu item.
func (c cellView) SetDrawSensitive(drawSensitive bool) {
	var _arg0 *C.GtkCellView
	var _arg1 C.gboolean

	_arg0 = (*C.GtkCellView)(unsafe.Pointer(c.Native()))
	if drawSensitive {
		_arg1 = C.gboolean(1)
	}

	C.gtk_cell_view_set_draw_sensitive(_arg0, _arg1)
}

// SetFitModel sets whether @cell_view should request space to fit the
// entire TreeModel.
//
// This is used by ComboBox to ensure that the cell view displayed on the
// combo box’s button always gets enough space and does not resize when
// selection changes.
func (c cellView) SetFitModel(fitModel bool) {
	var _arg0 *C.GtkCellView
	var _arg1 C.gboolean

	_arg0 = (*C.GtkCellView)(unsafe.Pointer(c.Native()))
	if fitModel {
		_arg1 = C.gboolean(1)
	}

	C.gtk_cell_view_set_fit_model(_arg0, _arg1)
}

// SetModel sets the model for @cell_view. If @cell_view already has a model
// set, it will remove it before setting the new model. If @model is nil,
// then it will unset the old model.
func (c cellView) SetModel(model TreeModel) {
	var _arg0 *C.GtkCellView
	var _arg1 *C.GtkTreeModel

	_arg0 = (*C.GtkCellView)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkTreeModel)(unsafe.Pointer(model.Native()))

	C.gtk_cell_view_set_model(_arg0, _arg1)
}

// ColorButton: the `GtkColorButton` allows to open a color chooser dialog to
// change the color.
//
// !An example GtkColorButton (color-button.png)
//
// It is suitable widget for selecting a color in a preference dialog.
//
//
// CSS nodes
//
// “` colorbutton ╰── button.color ╰── [content] “`
//
// `GtkColorButton` has a single CSS node with name colorbutton which contains a
// button node. To differentiate it from a plain `GtkButton`, it gets the .color
// style class.
type ColorButton interface {
	Widget
	Accessible
	Buildable
	ColorChooser
	ConstraintTarget

	// Modal gets whether the dialog is modal.
	Modal() bool
	// Title gets the title of the color chooser dialog.
	Title() string
	// SetModal sets whether the dialog should be modal.
	SetModal(modal bool)
	// SetTitle sets the title for the color chooser dialog.
	SetTitle(title string)
}

// colorButton implements the ColorButton interface.
type colorButton struct {
	Widget
	Accessible
	Buildable
	ColorChooser
	ConstraintTarget
}

var _ ColorButton = (*colorButton)(nil)

// WrapColorButton wraps a GObject to the right type. It is
// primarily used internally.
func WrapColorButton(obj *externglib.Object) ColorButton {
	return ColorButton{
		Widget:           WrapWidget(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ColorChooser:     WrapColorChooser(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
	}
}

func marshalColorButton(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapColorButton(obj), nil
}

// Modal gets whether the dialog is modal.
func (b colorButton) Modal() bool {
	var _arg0 *C.GtkColorButton

	_arg0 = (*C.GtkColorButton)(unsafe.Pointer(b.Native()))

	var _cret C.gboolean

	_cret = C.gtk_color_button_get_modal(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// Title gets the title of the color chooser dialog.
func (b colorButton) Title() string {
	var _arg0 *C.GtkColorButton

	_arg0 = (*C.GtkColorButton)(unsafe.Pointer(b.Native()))

	var _cret *C.char

	_cret = C.gtk_color_button_get_title(_arg0)

	var _utf8 string

	_utf8 = C.GoString(_cret)

	return _utf8
}

// SetModal sets whether the dialog should be modal.
func (b colorButton) SetModal(modal bool) {
	var _arg0 *C.GtkColorButton
	var _arg1 C.gboolean

	_arg0 = (*C.GtkColorButton)(unsafe.Pointer(b.Native()))
	if modal {
		_arg1 = C.gboolean(1)
	}

	C.gtk_color_button_set_modal(_arg0, _arg1)
}

// SetTitle sets the title for the color chooser dialog.
func (b colorButton) SetTitle(title string) {
	var _arg0 *C.GtkColorButton
	var _arg1 *C.char

	_arg0 = (*C.GtkColorButton)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.char)(C.CString(title))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_color_button_set_title(_arg0, _arg1)
}

// ColorChooserDialog: a dialog for choosing a color.
//
// !An example GtkColorChooserDialog (colorchooser.png)
//
// `GtkColorChooserDialog` implements the [iface@Gtk.ColorChooser] interface and
// does not provide much API of its own.
//
// To create a `GtkColorChooserDialog`, use [ctor@Gtk.ColorChooserDialog.new].
//
// To change the initially selected color, use
// [method@Gtk.ColorChooser.set_rgba]. To get the selected color use
// [method@Gtk.ColorChooser.get_rgba].
type ColorChooserDialog interface {
	Dialog
	Accessible
	Buildable
	ColorChooser
	ConstraintTarget
	Native
	Root
	ShortcutManager
}

// colorChooserDialog implements the ColorChooserDialog interface.
type colorChooserDialog struct {
	Dialog
	Accessible
	Buildable
	ColorChooser
	ConstraintTarget
	Native
	Root
	ShortcutManager
}

var _ ColorChooserDialog = (*colorChooserDialog)(nil)

// WrapColorChooserDialog wraps a GObject to the right type. It is
// primarily used internally.
func WrapColorChooserDialog(obj *externglib.Object) ColorChooserDialog {
	return ColorChooserDialog{
		Dialog:           WrapDialog(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ColorChooser:     WrapColorChooser(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
		Native:           WrapNative(obj),
		Root:             WrapRoot(obj),
		ShortcutManager:  WrapShortcutManager(obj),
	}
}

func marshalColorChooserDialog(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapColorChooserDialog(obj), nil
}

// ColorChooserWidget: the `GtkColorChooserWidget` widget lets the user select a
// color.
//
// By default, the chooser presents a predefined palette of colors, plus a small
// number of settable custom colors. It is also possible to select a different
// color with the single-color editor.
//
// To enter the single-color editing mode, use the context menu of any color of
// the palette, or use the '+' button to add a new custom color.
//
// The chooser automatically remembers the last selection, as well as custom
// colors.
//
// To create a `GtkColorChooserWidget`, use [ctor@Gtk.ColorChooserWidget.new].
//
// To change the initially selected color, use
// [method@Gtk.ColorChooser.set_rgba]. To get the selected color use
// [method@Gtk.ColorChooser.get_rgba].
//
// The `GtkColorChooserWidget` is used in the [class@Gtk.ColorChooserDialog] to
// provide a dialog for selecting colors.
//
//
// CSS names
//
// `GtkColorChooserWidget` has a single CSS node with name colorchooser.
type ColorChooserWidget interface {
	Widget
	Accessible
	Buildable
	ColorChooser
	ConstraintTarget
}

// colorChooserWidget implements the ColorChooserWidget interface.
type colorChooserWidget struct {
	Widget
	Accessible
	Buildable
	ColorChooser
	ConstraintTarget
}

var _ ColorChooserWidget = (*colorChooserWidget)(nil)

// WrapColorChooserWidget wraps a GObject to the right type. It is
// primarily used internally.
func WrapColorChooserWidget(obj *externglib.Object) ColorChooserWidget {
	return ColorChooserWidget{
		Widget:           WrapWidget(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ColorChooser:     WrapColorChooser(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
	}
}

func marshalColorChooserWidget(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapColorChooserWidget(obj), nil
}

// ComboBoxText: a `GtkComboBoxText` is a simple variant of `GtkComboBox` for
// text-only use cases.
//
// !An example GtkComboBoxText (combo-box-text.png)
//
// `GtkComboBoxText` hides the model-view complexity of `GtkComboBox`.
//
// To create a `GtkComboBoxText`, use [ctor@Gtk.ComboBoxText.new] or
// [ctor@Gtk.ComboBoxText.new_with_entry].
//
// You can add items to a `GtkComboBoxText` with
// [method@Gtk.ComboBoxText.append_text], [method@Gtk.ComboBoxText.insert_text]
// or [method@Gtk.ComboBoxText.prepend_text] and remove options with
// [method@Gtk.ComboBoxText.remove].
//
// If the `GtkComboBoxText` contains an entry (via the
// [property@Gtk.ComboBox:has-entry] property), its contents can be retrieved
// using [method@Gtk.ComboBoxText.get_active_text].
//
// You should not call [method@Gtk.ComboBox.set_model] or attempt to pack more
// cells into this combo box via its [interface@Gtk.CellLayout] interface.
//
//
// GtkComboBoxText as GtkBuildable
//
// The `GtkComboBoxText` implementation of the `GtkBuildable` interface supports
// adding items directly using the <items> element and specifying <item>
// elements for each item. Each <item> element can specify the “id”
// corresponding to the appended text and also supports the regular translation
// attributes “translatable”, “context” and “comments”.
//
// Here is a UI definition fragment specifying `GtkComboBoxText` items: “`xml
// <object class="GtkComboBoxText"> <items> <item translatable="yes"
// id="factory">Factory</item> <item translatable="yes" id="home">Home</item>
// <item translatable="yes" id="subway">Subway</item> </items> </object> “`
//
//
// CSS nodes
//
// “` combobox ╰── box.linked ├── entry.combo ├── button.combo ╰── window.popup
// “`
//
// `GtkComboBoxText` has a single CSS node with name combobox. It adds the style
// class .combo to the main CSS nodes of its entry and button children, and the
// .linked class to the node of its internal box.
type ComboBoxText interface {
	ComboBox
	Accessible
	Buildable
	CellEditable
	CellLayout
	ConstraintTarget

	// Append appends @text to the list of strings stored in @combo_box.
	//
	// If @id is non-nil then it is used as the ID of the row.
	//
	// This is the same as calling [method@Gtk.ComboBoxText.insert] with a
	// position of -1.
	Append(id string, text string)
	// AppendText appends @text to the list of strings stored in @combo_box.
	//
	// This is the same as calling [method@Gtk.ComboBoxText.insert_text] with a
	// position of -1.
	AppendText(text string)
	// ActiveText returns the currently active string in @combo_box.
	//
	// If no row is currently selected, nil is returned. If @combo_box contains
	// an entry, this function will return its contents (which will not
	// necessarily be an item from the list).
	ActiveText() string
	// Insert inserts @text at @position in the list of strings stored in
	// @combo_box.
	//
	// If @id is non-nil then it is used as the ID of the row. See
	// [property@Gtk.ComboBox:id-column].
	//
	// If @position is negative then @text is appended.
	Insert(position int, id string, text string)
	// InsertText inserts @text at @position in the list of strings stored in
	// @combo_box.
	//
	// If @position is negative then @text is appended.
	//
	// This is the same as calling [method@Gtk.ComboBoxText.insert] with a nil
	// ID string.
	InsertText(position int, text string)
	// Prepend prepends @text to the list of strings stored in @combo_box.
	//
	// If @id is non-nil then it is used as the ID of the row.
	//
	// This is the same as calling [method@Gtk.ComboBoxText.insert] with a
	// position of 0.
	Prepend(id string, text string)
	// PrependText prepends @text to the list of strings stored in @combo_box.
	//
	// This is the same as calling [method@Gtk.ComboBoxText.insert_text] with a
	// position of 0.
	PrependText(text string)
	// Remove removes the string at @position from @combo_box.
	Remove(position int)
	// RemoveAll removes all the text entries from the combo box.
	RemoveAll()
}

// comboBoxText implements the ComboBoxText interface.
type comboBoxText struct {
	ComboBox
	Accessible
	Buildable
	CellEditable
	CellLayout
	ConstraintTarget
}

var _ ComboBoxText = (*comboBoxText)(nil)

// WrapComboBoxText wraps a GObject to the right type. It is
// primarily used internally.
func WrapComboBoxText(obj *externglib.Object) ComboBoxText {
	return ComboBoxText{
		ComboBox:         WrapComboBox(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		CellEditable:     WrapCellEditable(obj),
		CellLayout:       WrapCellLayout(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
	}
}

func marshalComboBoxText(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapComboBoxText(obj), nil
}

// Append appends @text to the list of strings stored in @combo_box.
//
// If @id is non-nil then it is used as the ID of the row.
//
// This is the same as calling [method@Gtk.ComboBoxText.insert] with a
// position of -1.
func (c comboBoxText) Append(id string, text string) {
	var _arg0 *C.GtkComboBoxText
	var _arg1 *C.char
	var _arg2 *C.char

	_arg0 = (*C.GtkComboBoxText)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.char)(C.CString(id))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.char)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_combo_box_text_append(_arg0, _arg1, _arg2)
}

// AppendText appends @text to the list of strings stored in @combo_box.
//
// This is the same as calling [method@Gtk.ComboBoxText.insert_text] with a
// position of -1.
func (c comboBoxText) AppendText(text string) {
	var _arg0 *C.GtkComboBoxText
	var _arg1 *C.char

	_arg0 = (*C.GtkComboBoxText)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.char)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_combo_box_text_append_text(_arg0, _arg1)
}

// ActiveText returns the currently active string in @combo_box.
//
// If no row is currently selected, nil is returned. If @combo_box contains
// an entry, this function will return its contents (which will not
// necessarily be an item from the list).
func (c comboBoxText) ActiveText() string {
	var _arg0 *C.GtkComboBoxText

	_arg0 = (*C.GtkComboBoxText)(unsafe.Pointer(c.Native()))

	var _cret *C.char

	_cret = C.gtk_combo_box_text_get_active_text(_arg0)

	var _utf8 string

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Insert inserts @text at @position in the list of strings stored in
// @combo_box.
//
// If @id is non-nil then it is used as the ID of the row. See
// [property@Gtk.ComboBox:id-column].
//
// If @position is negative then @text is appended.
func (c comboBoxText) Insert(position int, id string, text string) {
	var _arg0 *C.GtkComboBoxText
	var _arg1 C.int
	var _arg2 *C.char
	var _arg3 *C.char

	_arg0 = (*C.GtkComboBoxText)(unsafe.Pointer(c.Native()))
	_arg1 = C.int(position)
	_arg2 = (*C.char)(C.CString(id))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.char)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg3))

	C.gtk_combo_box_text_insert(_arg0, _arg1, _arg2, _arg3)
}

// InsertText inserts @text at @position in the list of strings stored in
// @combo_box.
//
// If @position is negative then @text is appended.
//
// This is the same as calling [method@Gtk.ComboBoxText.insert] with a nil
// ID string.
func (c comboBoxText) InsertText(position int, text string) {
	var _arg0 *C.GtkComboBoxText
	var _arg1 C.int
	var _arg2 *C.char

	_arg0 = (*C.GtkComboBoxText)(unsafe.Pointer(c.Native()))
	_arg1 = C.int(position)
	_arg2 = (*C.char)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_combo_box_text_insert_text(_arg0, _arg1, _arg2)
}

// Prepend prepends @text to the list of strings stored in @combo_box.
//
// If @id is non-nil then it is used as the ID of the row.
//
// This is the same as calling [method@Gtk.ComboBoxText.insert] with a
// position of 0.
func (c comboBoxText) Prepend(id string, text string) {
	var _arg0 *C.GtkComboBoxText
	var _arg1 *C.char
	var _arg2 *C.char

	_arg0 = (*C.GtkComboBoxText)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.char)(C.CString(id))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.char)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_combo_box_text_prepend(_arg0, _arg1, _arg2)
}

// PrependText prepends @text to the list of strings stored in @combo_box.
//
// This is the same as calling [method@Gtk.ComboBoxText.insert_text] with a
// position of 0.
func (c comboBoxText) PrependText(text string) {
	var _arg0 *C.GtkComboBoxText
	var _arg1 *C.char

	_arg0 = (*C.GtkComboBoxText)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.char)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_combo_box_text_prepend_text(_arg0, _arg1)
}

// Remove removes the string at @position from @combo_box.
func (c comboBoxText) Remove(position int) {
	var _arg0 *C.GtkComboBoxText
	var _arg1 C.int

	_arg0 = (*C.GtkComboBoxText)(unsafe.Pointer(c.Native()))
	_arg1 = C.int(position)

	C.gtk_combo_box_text_remove(_arg0, _arg1)
}

// RemoveAll removes all the text entries from the combo box.
func (c comboBoxText) RemoveAll() {
	var _arg0 *C.GtkComboBoxText

	_arg0 = (*C.GtkComboBoxText)(unsafe.Pointer(c.Native()))

	C.gtk_combo_box_text_remove_all(_arg0)
}

// EntryCompletion: `GtkEntryCompletion` is an auxiliary object to provide
// completion functionality for `GtkEntry`.
//
// It implements the [iface@Gtk.CellLayout] interface, to allow the user to add
// extra cells to the `GtkTreeView` with completion matches.
//
// “Completion functionality” means that when the user modifies the text in the
// entry, `GtkEntryCompletion` checks which rows in the model match the current
// content of the entry, and displays a list of matches. By default, the
// matching is done by comparing the entry text case-insensitively against the
// text column of the model (see [method@Gtk.EntryCompletion.set_text_column]),
// but this can be overridden with a custom match function (see
// [method@Gtk.EntryCompletion.set_match_func]).
//
// When the user selects a completion, the content of the entry is updated. By
// default, the content of the entry is replaced by the text column of the
// model, but this can be overridden by connecting to the
// [signal@Gtk.EntryCompletion::match-selected] signal and updating the entry in
// the signal handler. Note that you should return true from the signal handler
// to suppress the default behaviour.
//
// To add completion functionality to an entry, use
// [method@Gtk.Entry.set_completion].
//
// `GtkEntryCompletion` uses a [class@Gtk.TreeModelFilter] model to represent
// the subset of the entire model that is currently matching. While the
// `GtkEntryCompletion` signals [signal@Gtk.EntryCompletion::match-selected] and
// [signal@Gtk.EntryCompletion::cursor-on-match] take the original model and an
// iter pointing to that model as arguments, other callbacks and signals (such
// as `GtkCellLayoutDataFunc` or [signal@Gtk.CellArea::apply-attributes)] will
// generally take the filter model as argument. As long as you are only calling
// [method@Gtk.TreeModel.get], this will make no difference to you. If for some
// reason, you need the original model, use
// [method@Gtk.TreeModelFilter.get_model]. Don’t forget to use
// [method@Gtk.TreeModelFilter.convert_iter_to_child_iter] to obtain a matching
// iter.
type EntryCompletion interface {
	gextras.Objector
	Buildable
	CellLayout

	// Complete requests a completion operation, or in other words a refiltering
	// of the current list with completions, using the current key.
	//
	// The completion list view will be updated accordingly.
	Complete()
	// ComputePrefix computes the common prefix that is shared by all rows in
	// @completion that start with @key.
	//
	// If no row matches @key, nil will be returned. Note that a text column
	// must have been set for this function to work, see
	// [method@Gtk.EntryCompletion.set_text_column] for details.
	ComputePrefix(key string) string
	// CompletionPrefix: get the original text entered by the user that
	// triggered the completion or nil if there’s no completion ongoing.
	CompletionPrefix() string
	// InlineCompletion returns whether the common prefix of the possible
	// completions should be automatically inserted in the entry.
	InlineCompletion() bool
	// InlineSelection returns true if inline-selection mode is turned on.
	InlineSelection() bool
	// MinimumKeyLength returns the minimum key length as set for @completion.
	MinimumKeyLength() int
	// PopupCompletion returns whether the completions should be presented in a
	// popup window.
	PopupCompletion() bool
	// PopupSetWidth returns whether the completion popup window will be resized
	// to the width of the entry.
	PopupSetWidth() bool
	// PopupSingleMatch returns whether the completion popup window will appear
	// even if there is only a single match.
	PopupSingleMatch() bool
	// TextColumn returns the column in the model of @completion to get strings
	// from.
	TextColumn() int
	// InsertPrefix requests a prefix insertion.
	InsertPrefix()
	// SetInlineCompletion sets whether the common prefix of the possible
	// completions should be automatically inserted in the entry.
	SetInlineCompletion(inlineCompletion bool)
	// SetInlineSelection sets whether it is possible to cycle through the
	// possible completions inside the entry.
	SetInlineSelection(inlineSelection bool)
	// SetMinimumKeyLength requires the length of the search key for @completion
	// to be at least @length.
	//
	// This is useful for long lists, where completing using a small key takes a
	// lot of time and will come up with meaningless results anyway (ie, a too
	// large dataset).
	SetMinimumKeyLength(length int)
	// SetModel sets the model for a `GtkEntryCompletion`.
	//
	// If @completion already has a model set, it will remove it before setting
	// the new model. If model is nil, then it will unset the model.
	SetModel(model TreeModel)
	// SetPopupCompletion sets whether the completions should be presented in a
	// popup window.
	SetPopupCompletion(popupCompletion bool)
	// SetPopupSetWidth sets whether the completion popup window will be resized
	// to be the same width as the entry.
	SetPopupSetWidth(popupSetWidth bool)
	// SetPopupSingleMatch sets whether the completion popup window will appear
	// even if there is only a single match.
	//
	// You may want to set this to false if you are using
	// [property@Gtk.EntryCompletion:inline-completion].
	SetPopupSingleMatch(popupSingleMatch bool)
	// SetTextColumn: convenience function for setting up the most used case of
	// this code: a completion list with just strings.
	//
	// This function will set up @completion to have a list displaying all (and
	// just) strings in the completion list, and to get those strings from
	// @column in the model of @completion.
	//
	// This functions creates and adds a `GtkCellRendererText` for the selected
	// column. If you need to set the text column, but don't want the cell
	// renderer, use g_object_set() to set the
	// [property@Gtk.EntryCompletion:text-column] property directly.
	SetTextColumn(column int)
}

// entryCompletion implements the EntryCompletion interface.
type entryCompletion struct {
	gextras.Objector
	Buildable
	CellLayout
}

var _ EntryCompletion = (*entryCompletion)(nil)

// WrapEntryCompletion wraps a GObject to the right type. It is
// primarily used internally.
func WrapEntryCompletion(obj *externglib.Object) EntryCompletion {
	return EntryCompletion{
		Objector:   obj,
		Buildable:  WrapBuildable(obj),
		CellLayout: WrapCellLayout(obj),
	}
}

func marshalEntryCompletion(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapEntryCompletion(obj), nil
}

// Complete requests a completion operation, or in other words a refiltering
// of the current list with completions, using the current key.
//
// The completion list view will be updated accordingly.
func (c entryCompletion) Complete() {
	var _arg0 *C.GtkEntryCompletion

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))

	C.gtk_entry_completion_complete(_arg0)
}

// ComputePrefix computes the common prefix that is shared by all rows in
// @completion that start with @key.
//
// If no row matches @key, nil will be returned. Note that a text column
// must have been set for this function to work, see
// [method@Gtk.EntryCompletion.set_text_column] for details.
func (c entryCompletion) ComputePrefix(key string) string {
	var _arg0 *C.GtkEntryCompletion
	var _arg1 *C.char

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.char)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))

	var _cret *C.char

	_cret = C.gtk_entry_completion_compute_prefix(_arg0, _arg1)

	var _utf8 string

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// CompletionPrefix: get the original text entered by the user that
// triggered the completion or nil if there’s no completion ongoing.
func (c entryCompletion) CompletionPrefix() string {
	var _arg0 *C.GtkEntryCompletion

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))

	var _cret *C.char

	_cret = C.gtk_entry_completion_get_completion_prefix(_arg0)

	var _utf8 string

	_utf8 = C.GoString(_cret)

	return _utf8
}

// InlineCompletion returns whether the common prefix of the possible
// completions should be automatically inserted in the entry.
func (c entryCompletion) InlineCompletion() bool {
	var _arg0 *C.GtkEntryCompletion

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))

	var _cret C.gboolean

	_cret = C.gtk_entry_completion_get_inline_completion(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// InlineSelection returns true if inline-selection mode is turned on.
func (c entryCompletion) InlineSelection() bool {
	var _arg0 *C.GtkEntryCompletion

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))

	var _cret C.gboolean

	_cret = C.gtk_entry_completion_get_inline_selection(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// MinimumKeyLength returns the minimum key length as set for @completion.
func (c entryCompletion) MinimumKeyLength() int {
	var _arg0 *C.GtkEntryCompletion

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))

	var _cret C.int

	_cret = C.gtk_entry_completion_get_minimum_key_length(_arg0)

	var _gint int

	_gint = (int)(_cret)

	return _gint
}

// PopupCompletion returns whether the completions should be presented in a
// popup window.
func (c entryCompletion) PopupCompletion() bool {
	var _arg0 *C.GtkEntryCompletion

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))

	var _cret C.gboolean

	_cret = C.gtk_entry_completion_get_popup_completion(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// PopupSetWidth returns whether the completion popup window will be resized
// to the width of the entry.
func (c entryCompletion) PopupSetWidth() bool {
	var _arg0 *C.GtkEntryCompletion

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))

	var _cret C.gboolean

	_cret = C.gtk_entry_completion_get_popup_set_width(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// PopupSingleMatch returns whether the completion popup window will appear
// even if there is only a single match.
func (c entryCompletion) PopupSingleMatch() bool {
	var _arg0 *C.GtkEntryCompletion

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))

	var _cret C.gboolean

	_cret = C.gtk_entry_completion_get_popup_single_match(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// TextColumn returns the column in the model of @completion to get strings
// from.
func (c entryCompletion) TextColumn() int {
	var _arg0 *C.GtkEntryCompletion

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))

	var _cret C.int

	_cret = C.gtk_entry_completion_get_text_column(_arg0)

	var _gint int

	_gint = (int)(_cret)

	return _gint
}

// InsertPrefix requests a prefix insertion.
func (c entryCompletion) InsertPrefix() {
	var _arg0 *C.GtkEntryCompletion

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))

	C.gtk_entry_completion_insert_prefix(_arg0)
}

// SetInlineCompletion sets whether the common prefix of the possible
// completions should be automatically inserted in the entry.
func (c entryCompletion) SetInlineCompletion(inlineCompletion bool) {
	var _arg0 *C.GtkEntryCompletion
	var _arg1 C.gboolean

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))
	if inlineCompletion {
		_arg1 = C.gboolean(1)
	}

	C.gtk_entry_completion_set_inline_completion(_arg0, _arg1)
}

// SetInlineSelection sets whether it is possible to cycle through the
// possible completions inside the entry.
func (c entryCompletion) SetInlineSelection(inlineSelection bool) {
	var _arg0 *C.GtkEntryCompletion
	var _arg1 C.gboolean

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))
	if inlineSelection {
		_arg1 = C.gboolean(1)
	}

	C.gtk_entry_completion_set_inline_selection(_arg0, _arg1)
}

// SetMinimumKeyLength requires the length of the search key for @completion
// to be at least @length.
//
// This is useful for long lists, where completing using a small key takes a
// lot of time and will come up with meaningless results anyway (ie, a too
// large dataset).
func (c entryCompletion) SetMinimumKeyLength(length int) {
	var _arg0 *C.GtkEntryCompletion
	var _arg1 C.int

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))
	_arg1 = C.int(length)

	C.gtk_entry_completion_set_minimum_key_length(_arg0, _arg1)
}

// SetModel sets the model for a `GtkEntryCompletion`.
//
// If @completion already has a model set, it will remove it before setting
// the new model. If model is nil, then it will unset the model.
func (c entryCompletion) SetModel(model TreeModel) {
	var _arg0 *C.GtkEntryCompletion
	var _arg1 *C.GtkTreeModel

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkTreeModel)(unsafe.Pointer(model.Native()))

	C.gtk_entry_completion_set_model(_arg0, _arg1)
}

// SetPopupCompletion sets whether the completions should be presented in a
// popup window.
func (c entryCompletion) SetPopupCompletion(popupCompletion bool) {
	var _arg0 *C.GtkEntryCompletion
	var _arg1 C.gboolean

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))
	if popupCompletion {
		_arg1 = C.gboolean(1)
	}

	C.gtk_entry_completion_set_popup_completion(_arg0, _arg1)
}

// SetPopupSetWidth sets whether the completion popup window will be resized
// to be the same width as the entry.
func (c entryCompletion) SetPopupSetWidth(popupSetWidth bool) {
	var _arg0 *C.GtkEntryCompletion
	var _arg1 C.gboolean

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))
	if popupSetWidth {
		_arg1 = C.gboolean(1)
	}

	C.gtk_entry_completion_set_popup_set_width(_arg0, _arg1)
}

// SetPopupSingleMatch sets whether the completion popup window will appear
// even if there is only a single match.
//
// You may want to set this to false if you are using
// [property@Gtk.EntryCompletion:inline-completion].
func (c entryCompletion) SetPopupSingleMatch(popupSingleMatch bool) {
	var _arg0 *C.GtkEntryCompletion
	var _arg1 C.gboolean

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))
	if popupSingleMatch {
		_arg1 = C.gboolean(1)
	}

	C.gtk_entry_completion_set_popup_single_match(_arg0, _arg1)
}

// SetTextColumn: convenience function for setting up the most used case of
// this code: a completion list with just strings.
//
// This function will set up @completion to have a list displaying all (and
// just) strings in the completion list, and to get those strings from
// @column in the model of @completion.
//
// This functions creates and adds a `GtkCellRendererText` for the selected
// column. If you need to set the text column, but don't want the cell
// renderer, use g_object_set() to set the
// [property@Gtk.EntryCompletion:text-column] property directly.
func (c entryCompletion) SetTextColumn(column int) {
	var _arg0 *C.GtkEntryCompletion
	var _arg1 C.int

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))
	_arg1 = C.int(column)

	C.gtk_entry_completion_set_text_column(_arg0, _arg1)
}

// Expander: `GtkExpander` allows the user to reveal its child by clicking on an
// expander triangle.
//
// !An example GtkExpander (expander.png)
//
// This is similar to the triangles used in a `GtkTreeView`.
//
// Normally you use an expander as you would use a frame; you create the child
// widget and use [method@Gtk.Expander.set_child] to add it to the expander.
// When the expander is toggled, it will take care of showing and hiding the
// child automatically.
//
//
// Special Usage
//
// There are situations in which you may prefer to show and hide the expanded
// widget yourself, such as when you want to actually create the widget at
// expansion time. In this case, create a `GtkExpander` but do not add a child
// to it. The expander widget has an [property@Gtk.Expander:expanded[ property
// which can be used to monitor its expansion state. You should watch this
// property with a signal connection as follows:
//
// “`c static void expander_callback (GObject *object, GParamSpec *param_spec,
// gpointer user_data) { GtkExpander *expander;
//
//    expander = GTK_EXPANDER (object);
//
//    if (gtk_expander_get_expanded (expander))
//      {
//        // Show or create widgets
//      }
//    else
//      {
//        // Hide or destroy widgets
//      }
//
// }
//
// static void create_expander (void) { GtkWidget *expander =
// gtk_expander_new_with_mnemonic ("_More Options"); g_signal_connect (expander,
// "notify::expanded", G_CALLBACK (expander_callback), NULL);
//
//    // ...
//
// } “`
//
//
// GtkExpander as GtkBuildable
//
// The `GtkExpander` implementation of the `GtkBuildable` interface supports
// placing a child in the label position by specifying “label” as the “type”
// attribute of a <child> element. A normal content child can be specified
// without specifying a <child> type attribute.
//
// An example of a UI definition fragment with GtkExpander:
//
// “`xml <object class="GtkExpander"> <child type="label"> <object
// class="GtkLabel" id="expander-label"/> </child> <child> <object
// class="GtkEntry" id="expander-content"/> </child> </object> “`
//
//
// CSS nodes
//
// “` expander ╰── box ├── title │ ├── arrow │ ╰── <label widget> ╰── <child> “`
//
// `GtkExpander` has three CSS nodes, the main node with the name expander, a
// subnode with name title and node below it with name arrow. The arrow of an
// expander that is showing its child gets the :checked pseudoclass added to it.
//
//
// Accessibility
//
// `GtkExpander` uses the GTK_ACCESSIBLE_ROLE_BUTTON role.
type Expander interface {
	Widget
	Accessible
	Buildable
	ConstraintTarget

	// Expanded queries a Expander and returns its current state.
	//
	// Returns true if the child widget is revealed.
	Expanded() bool
	// Label fetches the text from a label widget.
	//
	// This is including any embedded underlines indicating mnemonics and Pango
	// markup, as set by [method@Gtk.Expander.set_label]. If the label text has
	// not been set the return value will be nil. This will be the case if you
	// create an empty button with gtk_button_new() to use as a container.
	Label() string
	// ResizeToplevel returns whether the expander will resize the toplevel
	// widget containing the expander upon resizing and collpasing.
	ResizeToplevel() bool
	// UseMarkup returns whether the label’s text is interpreted as Pango
	// markup.
	UseMarkup() bool
	// UseUnderline returns whether an underline in the text indicates a
	// mnemonic.
	UseUnderline() bool
	// SetChild sets the child widget of @expander.
	SetChild(child Widget)
	// SetExpanded sets the state of the expander.
	//
	// Set to true, if you want the child widget to be revealed, and false if
	// you want the child widget to be hidden.
	SetExpanded(expanded bool)
	// SetLabel sets the text of the label of the expander to @label.
	//
	// This will also clear any previously set labels.
	SetLabel(label string)
	// SetLabelWidget: set the label widget for the expander.
	//
	// This is the widget that will appear embedded alongside the expander
	// arrow.
	SetLabelWidget(labelWidget Widget)
	// SetResizeToplevel sets whether the expander will resize the toplevel
	// widget containing the expander upon resizing and collpasing.
	SetResizeToplevel(resizeToplevel bool)
	// SetUseMarkup sets whether the text of the label contains Pango markup.
	SetUseMarkup(useMarkup bool)
	// SetUseUnderline: if true, an underline in the text indicates a mnemonic.
	SetUseUnderline(useUnderline bool)
}

// expander implements the Expander interface.
type expander struct {
	Widget
	Accessible
	Buildable
	ConstraintTarget
}

var _ Expander = (*expander)(nil)

// WrapExpander wraps a GObject to the right type. It is
// primarily used internally.
func WrapExpander(obj *externglib.Object) Expander {
	return Expander{
		Widget:           WrapWidget(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
	}
}

func marshalExpander(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapExpander(obj), nil
}

// Expanded queries a Expander and returns its current state.
//
// Returns true if the child widget is revealed.
func (e expander) Expanded() bool {
	var _arg0 *C.GtkExpander

	_arg0 = (*C.GtkExpander)(unsafe.Pointer(e.Native()))

	var _cret C.gboolean

	_cret = C.gtk_expander_get_expanded(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// Label fetches the text from a label widget.
//
// This is including any embedded underlines indicating mnemonics and Pango
// markup, as set by [method@Gtk.Expander.set_label]. If the label text has
// not been set the return value will be nil. This will be the case if you
// create an empty button with gtk_button_new() to use as a container.
func (e expander) Label() string {
	var _arg0 *C.GtkExpander

	_arg0 = (*C.GtkExpander)(unsafe.Pointer(e.Native()))

	var _cret *C.char

	_cret = C.gtk_expander_get_label(_arg0)

	var _utf8 string

	_utf8 = C.GoString(_cret)

	return _utf8
}

// ResizeToplevel returns whether the expander will resize the toplevel
// widget containing the expander upon resizing and collpasing.
func (e expander) ResizeToplevel() bool {
	var _arg0 *C.GtkExpander

	_arg0 = (*C.GtkExpander)(unsafe.Pointer(e.Native()))

	var _cret C.gboolean

	_cret = C.gtk_expander_get_resize_toplevel(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// UseMarkup returns whether the label’s text is interpreted as Pango
// markup.
func (e expander) UseMarkup() bool {
	var _arg0 *C.GtkExpander

	_arg0 = (*C.GtkExpander)(unsafe.Pointer(e.Native()))

	var _cret C.gboolean

	_cret = C.gtk_expander_get_use_markup(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// UseUnderline returns whether an underline in the text indicates a
// mnemonic.
func (e expander) UseUnderline() bool {
	var _arg0 *C.GtkExpander

	_arg0 = (*C.GtkExpander)(unsafe.Pointer(e.Native()))

	var _cret C.gboolean

	_cret = C.gtk_expander_get_use_underline(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// SetChild sets the child widget of @expander.
func (e expander) SetChild(child Widget) {
	var _arg0 *C.GtkExpander
	var _arg1 *C.GtkWidget

	_arg0 = (*C.GtkExpander)(unsafe.Pointer(e.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_expander_set_child(_arg0, _arg1)
}

// SetExpanded sets the state of the expander.
//
// Set to true, if you want the child widget to be revealed, and false if
// you want the child widget to be hidden.
func (e expander) SetExpanded(expanded bool) {
	var _arg0 *C.GtkExpander
	var _arg1 C.gboolean

	_arg0 = (*C.GtkExpander)(unsafe.Pointer(e.Native()))
	if expanded {
		_arg1 = C.gboolean(1)
	}

	C.gtk_expander_set_expanded(_arg0, _arg1)
}

// SetLabel sets the text of the label of the expander to @label.
//
// This will also clear any previously set labels.
func (e expander) SetLabel(label string) {
	var _arg0 *C.GtkExpander
	var _arg1 *C.char

	_arg0 = (*C.GtkExpander)(unsafe.Pointer(e.Native()))
	_arg1 = (*C.char)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_expander_set_label(_arg0, _arg1)
}

// SetLabelWidget: set the label widget for the expander.
//
// This is the widget that will appear embedded alongside the expander
// arrow.
func (e expander) SetLabelWidget(labelWidget Widget) {
	var _arg0 *C.GtkExpander
	var _arg1 *C.GtkWidget

	_arg0 = (*C.GtkExpander)(unsafe.Pointer(e.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(labelWidget.Native()))

	C.gtk_expander_set_label_widget(_arg0, _arg1)
}

// SetResizeToplevel sets whether the expander will resize the toplevel
// widget containing the expander upon resizing and collpasing.
func (e expander) SetResizeToplevel(resizeToplevel bool) {
	var _arg0 *C.GtkExpander
	var _arg1 C.gboolean

	_arg0 = (*C.GtkExpander)(unsafe.Pointer(e.Native()))
	if resizeToplevel {
		_arg1 = C.gboolean(1)
	}

	C.gtk_expander_set_resize_toplevel(_arg0, _arg1)
}

// SetUseMarkup sets whether the text of the label contains Pango markup.
func (e expander) SetUseMarkup(useMarkup bool) {
	var _arg0 *C.GtkExpander
	var _arg1 C.gboolean

	_arg0 = (*C.GtkExpander)(unsafe.Pointer(e.Native()))
	if useMarkup {
		_arg1 = C.gboolean(1)
	}

	C.gtk_expander_set_use_markup(_arg0, _arg1)
}

// SetUseUnderline: if true, an underline in the text indicates a mnemonic.
func (e expander) SetUseUnderline(useUnderline bool) {
	var _arg0 *C.GtkExpander
	var _arg1 C.gboolean

	_arg0 = (*C.GtkExpander)(unsafe.Pointer(e.Native()))
	if useUnderline {
		_arg1 = C.gboolean(1)
	}

	C.gtk_expander_set_use_underline(_arg0, _arg1)
}

// FileChooserDialog: `GtkFileChooserDialog` is a dialog suitable for use with
// “File Open” or “File Save” commands.
//
// !An example GtkFileChooserDialog (filechooser.png)
//
// This widget works by putting a [class@Gtk.FileChooserWidget] inside a
// [class@Gtk.Dialog]. It exposes the [iface@Gtk.FileChooser] interface, so you
// can use all of the [iface@Gtk.FileChooser] functions on the file chooser
// dialog as well as those for [class@Gtk.Dialog].
//
// Note that `GtkFileChooserDialog` does not have any methods of its own.
// Instead, you should use the functions that work on a [iface@Gtk.FileChooser].
//
// If you want to integrate well with the platform you should use the
// [class@Gtk.FileChooserNative] API, which will use a platform-specific dialog
// if available and fall back to `GtkFileChooserDialog` otherwise.
//
//
// Typical usage
//
// In the simplest of cases, you can the following code to use
// `GtkFileChooserDialog` to select a file for opening:
//
// “`c static void on_open_response (GtkDialog *dialog, int response) { if
// (response == GTK_RESPONSE_ACCEPT) { GtkFileChooser *chooser =
// GTK_FILE_CHOOSER (dialog);
//
//        g_autoptr(GFile) file = gtk_file_chooser_get_file (chooser);
//
//        open_file (file);
//      }
//
//    gtk_window_destroy (GTK_WINDOW (dialog));
//
// }
//
//    // ...
//    GtkWidget *dialog;
//    GtkFileChooserAction action = GTK_FILE_CHOOSER_ACTION_OPEN;
//
//    dialog = gtk_file_chooser_dialog_new ("Open File",
//                                          parent_window,
//                                          action,
//                                          _("_Cancel"),
//                                          GTK_RESPONSE_CANCEL,
//                                          _("_Open"),
//                                          GTK_RESPONSE_ACCEPT,
//                                          NULL);
//
//    gtk_widget_show (dialog);
//
//    g_signal_connect (dialog, "response",
//                      G_CALLBACK (on_open_response),
//                      NULL);
//
// “`
//
// To use a dialog for saving, you can use this:
//
// “`c static void on_save_response (GtkDialog *dialog, int response) { if
// (response == GTK_RESPONSE_ACCEPT) { GtkFileChooser *chooser =
// GTK_FILE_CHOOSER (dialog);
//
//        g_autoptr(GFile) file = gtk_file_chooser_get_file (chooser);
//
//        save_to_file (file);
//      }
//
//    gtk_window_destroy (GTK_WINDOW (dialog));
//
// }
//
//    // ...
//    GtkWidget *dialog;
//    GtkFileChooser *chooser;
//    GtkFileChooserAction action = GTK_FILE_CHOOSER_ACTION_SAVE;
//
//    dialog = gtk_file_chooser_dialog_new ("Save File",
//                                          parent_window,
//                                          action,
//                                          _("_Cancel"),
//                                          GTK_RESPONSE_CANCEL,
//                                          _("_Save"),
//                                          GTK_RESPONSE_ACCEPT,
//                                          NULL);
//    chooser = GTK_FILE_CHOOSER (dialog);
//
//    if (user_edited_a_new_document)
//      gtk_file_chooser_set_current_name (chooser, _("Untitled document"));
//    else
//      gtk_file_chooser_set_file (chooser, existing_filename);
//
//    gtk_widget_show (dialog);
//
//    g_signal_connect (dialog, "response",
//                      G_CALLBACK (on_save_response),
//                      NULL);
//
// “`
//
//
// Setting up a file chooser dialog
//
// There are various cases in which you may need to use a
// `GtkFileChooserDialog`:
//
// - To select a file for opening, use GTK_FILE_CHOOSER_ACTION_OPEN.
//
// - To save a file for the first time, use GTK_FILE_CHOOSER_ACTION_SAVE, and
// suggest a name such as “Untitled” with
// [method@Gtk.FileChooser.set_current_name].
//
// - To save a file under a different name, use GTK_FILE_CHOOSER_ACTION_SAVE,
// and set the existing file with [method@Gtk.FileChooser.set_file].
//
// - To choose a folder instead of a filem use
// GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER.
//
// In general, you should only cause the file chooser to show a specific folder
// when it is appropriate to use [method@Gtk,FileChooser.set_file], i.e. when
// you are doing a “Save As” command and you already have a file saved
// somewhere.
//
//
// Response Codes
//
// `GtkFileChooserDialog` inherits from [class@Gtk.Dialog], so buttons that go
// in its action area have response codes such as GTK_RESPONSE_ACCEPT and
// GTK_RESPONSE_CANCEL. For example, you could call
// [ctor@Gtk.FileChooserDialog.new] as follows:
//
// “`c GtkWidget *dialog; GtkFileChooserAction action =
// GTK_FILE_CHOOSER_ACTION_OPEN;
//
// dialog = gtk_file_chooser_dialog_new ("Open File", parent_window, action,
// _("_Cancel"), GTK_RESPONSE_CANCEL, _("_Open"), GTK_RESPONSE_ACCEPT, NULL); “`
//
// This will create buttons for “Cancel” and “Open” that use predefined response
// identifiers from [enum@Gtk.ResponseType]. For most dialog boxes you can use
// your own custom response codes rather than the ones in
// [enum@Gtk.ResponseType], but `GtkFileChooserDialog` assumes that its
// “accept”-type action, e.g. an “Open” or “Save” button, will have one of the
// following response codes:
//
// - GTK_RESPONSE_ACCEPT - GTK_RESPONSE_OK - GTK_RESPONSE_YES -
// GTK_RESPONSE_APPLY
//
// This is because `GtkFileChooserDialog` must intercept responses and switch to
// folders if appropriate, rather than letting the dialog terminate — the
// implementation uses these known response codes to know which responses can be
// blocked if appropriate.
//
// To summarize, make sure you use a predefined response code when you use
// `GtkFileChooserDialog` to ensure proper operation.
type FileChooserDialog interface {
	Dialog
	Accessible
	Buildable
	ConstraintTarget
	FileChooser
	Native
	Root
	ShortcutManager
}

// fileChooserDialog implements the FileChooserDialog interface.
type fileChooserDialog struct {
	Dialog
	Accessible
	Buildable
	ConstraintTarget
	FileChooser
	Native
	Root
	ShortcutManager
}

var _ FileChooserDialog = (*fileChooserDialog)(nil)

// WrapFileChooserDialog wraps a GObject to the right type. It is
// primarily used internally.
func WrapFileChooserDialog(obj *externglib.Object) FileChooserDialog {
	return FileChooserDialog{
		Dialog:           WrapDialog(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
		FileChooser:      WrapFileChooser(obj),
		Native:           WrapNative(obj),
		Root:             WrapRoot(obj),
		ShortcutManager:  WrapShortcutManager(obj),
	}
}

func marshalFileChooserDialog(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFileChooserDialog(obj), nil
}

// FileChooserWidget: `GtkFileChooserWidget` is a widget for choosing files.
//
// It exposes the [iface@Gtk.FileChooser] interface, and you should use the
// methods of this interface to interact with the widget.
//
//
// CSS nodes
//
// `GtkFileChooserWidget` has a single CSS node with name filechooser.
type FileChooserWidget interface {
	Widget
	Accessible
	Buildable
	ConstraintTarget
	FileChooser
}

// fileChooserWidget implements the FileChooserWidget interface.
type fileChooserWidget struct {
	Widget
	Accessible
	Buildable
	ConstraintTarget
	FileChooser
}

var _ FileChooserWidget = (*fileChooserWidget)(nil)

// WrapFileChooserWidget wraps a GObject to the right type. It is
// primarily used internally.
func WrapFileChooserWidget(obj *externglib.Object) FileChooserWidget {
	return FileChooserWidget{
		Widget:           WrapWidget(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
		FileChooser:      WrapFileChooser(obj),
	}
}

func marshalFileChooserWidget(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFileChooserWidget(obj), nil
}

// FileFilter: `GtkFileFilter` filters files by name or mime type.
//
// `GtkFileFilter` can be used to restrict the files being shown in a
// `GtkFileChooser`. Files can be filtered based on their name (with
// [method@Gtk.FileFilter.add_pattern]) or on their mime type (with
// [method@Gtk.FileFilter.add_mime_type]).
//
// Filtering by mime types handles aliasing and subclassing of mime types; e.g.
// a filter for text/plain also matches a file with mime type application/rtf,
// since application/rtf is a subclass of text/plain. Note that `GtkFileFilter`
// allows wildcards for the subtype of a mime type, so you can e.g. filter for
// image/\*.
//
// Normally, file filters are used by adding them to a `GtkFileChooser` (see
// [method@Gtk.FileChooser.add_filter]), but it is also possible to manually use
// a file filter on any [class@Gtk.FilterListModel] containing `GFileInfo`
// objects.
//
//
// GtkFileFilter as GtkBuildable
//
// The `GtkFileFilter` implementation of the `GtkBuildable` interface supports
// adding rules using the <mime-types> and <patterns> elements and listing the
// rules within. Specifying a <mime-type> or <pattern> has the same effect as as
// calling [method@Gtk.FileFilter.add_mime_type] or
// [method@Gtk.FileFilter.add_pattern].
//
// An example of a UI definition fragment specifying `GtkFileFilter` rules:
// “`xml <object class="GtkFileFilter"> <property name="name"
// translatable="yes">Text and Images</property> <mime-types>
// <mime-type>text/plain</mime-type> <mime-type>image/ *</mime-type>
// </mime-types> <patterns> <pattern>*.txt</pattern> <pattern>*.png</pattern>
// </patterns> </object> “`
type FileFilter interface {
	Filter
	Buildable

	// AddMIMEType adds a rule allowing a given mime type to @filter.
	AddMIMEType(mimeType string)
	// AddPattern adds a rule allowing a shell style glob to a filter.
	AddPattern(pattern string)
	// AddPixbufFormats adds a rule allowing image files in the formats
	// supported by GdkPixbuf.
	//
	// This is equivalent to calling [method@Gtk.FileFilter.add_mime_type] for
	// all the supported mime types.
	AddPixbufFormats()
	// Attributes gets the attributes that need to be filled in for the
	// `GFileInfo` passed to this filter.
	//
	// This function will not typically be used by applications; it is intended
	// principally for use in the implementation of `GtkFileChooser`.
	Attributes() []string
	// Name gets the human-readable name for the filter.
	//
	// See [method@Gtk.FileFilter.set_name].
	Name() string
	// SetName sets a human-readable name of the filter.
	//
	// This is the string that will be displayed in the file chooser if there is
	// a selectable list of filters.
	SetName(name string)
}

// fileFilter implements the FileFilter interface.
type fileFilter struct {
	Filter
	Buildable
}

var _ FileFilter = (*fileFilter)(nil)

// WrapFileFilter wraps a GObject to the right type. It is
// primarily used internally.
func WrapFileFilter(obj *externglib.Object) FileFilter {
	return FileFilter{
		Filter:    WrapFilter(obj),
		Buildable: WrapBuildable(obj),
	}
}

func marshalFileFilter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFileFilter(obj), nil
}

// AddMIMEType adds a rule allowing a given mime type to @filter.
func (f fileFilter) AddMIMEType(mimeType string) {
	var _arg0 *C.GtkFileFilter
	var _arg1 *C.char

	_arg0 = (*C.GtkFileFilter)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.char)(C.CString(mimeType))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_file_filter_add_mime_type(_arg0, _arg1)
}

// AddPattern adds a rule allowing a shell style glob to a filter.
func (f fileFilter) AddPattern(pattern string) {
	var _arg0 *C.GtkFileFilter
	var _arg1 *C.char

	_arg0 = (*C.GtkFileFilter)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.char)(C.CString(pattern))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_file_filter_add_pattern(_arg0, _arg1)
}

// AddPixbufFormats adds a rule allowing image files in the formats
// supported by GdkPixbuf.
//
// This is equivalent to calling [method@Gtk.FileFilter.add_mime_type] for
// all the supported mime types.
func (f fileFilter) AddPixbufFormats() {
	var _arg0 *C.GtkFileFilter

	_arg0 = (*C.GtkFileFilter)(unsafe.Pointer(f.Native()))

	C.gtk_file_filter_add_pixbuf_formats(_arg0)
}

// Attributes gets the attributes that need to be filled in for the
// `GFileInfo` passed to this filter.
//
// This function will not typically be used by applications; it is intended
// principally for use in the implementation of `GtkFileChooser`.
func (f fileFilter) Attributes() []string {
	var _arg0 *C.GtkFileFilter

	_arg0 = (*C.GtkFileFilter)(unsafe.Pointer(f.Native()))

	var _cret **C.char

	_cret = C.gtk_file_filter_get_attributes(_arg0)

	var _utf8s []string

	{
		var length int
		for p := _cret; *p != 0; p = (**C.char)(ptr.Add(unsafe.Pointer(p), unsafe.Sizeof(int(0)))) {
			length++
			if length < 0 {
				panic(`length overflow`)
			}
		}

		var src []*C.gchar
		ptr.SetSlice(unsafe.Pointer(&src), unsafe.Pointer(_cret), int(length))

		_utf8s = make([]string, length)
		for i := range src {
			_utf8s = C.GoString(_cret)
		}
	}

	return _utf8s
}

// Name gets the human-readable name for the filter.
//
// See [method@Gtk.FileFilter.set_name].
func (f fileFilter) Name() string {
	var _arg0 *C.GtkFileFilter

	_arg0 = (*C.GtkFileFilter)(unsafe.Pointer(f.Native()))

	var _cret *C.char

	_cret = C.gtk_file_filter_get_name(_arg0)

	var _utf8 string

	_utf8 = C.GoString(_cret)

	return _utf8
}

// SetName sets a human-readable name of the filter.
//
// This is the string that will be displayed in the file chooser if there is
// a selectable list of filters.
func (f fileFilter) SetName(name string) {
	var _arg0 *C.GtkFileFilter
	var _arg1 *C.char

	_arg0 = (*C.GtkFileFilter)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_file_filter_set_name(_arg0, _arg1)
}

// FlowBox: a `GtkFlowBox` puts child widgets in reflowing grid.
//
// For instance, with the horizontal orientation, the widgets will be arranged
// from left to right, starting a new row under the previous row when necessary.
// Reducing the width in this case will require more rows, so a larger height
// will be requested.
//
// Likewise, with the vertical orientation, the widgets will be arranged from
// top to bottom, starting a new column to the right when necessary. Reducing
// the height will require more columns, so a larger width will be requested.
//
// The size request of a `GtkFlowBox` alone may not be what you expect; if you
// need to be able to shrink it along both axes and dynamically reflow its
// children, you may have to wrap it in a `GtkScrolledWindow` to enable that.
//
// The children of a `GtkFlowBox` can be dynamically sorted and filtered.
//
// Although a `GtkFlowBox` must have only `GtkFlowBoxChild` children, you can
// add any kind of widget to it via [method@Gtk.FlowBox.insert], and a
// `GtkFlowBoxChild` widget will automatically be inserted between the box and
// the widget.
//
// Also see [class@Gtk.ListBox].
//
//
// CSS nodes
//
// “` flowbox ├── flowboxchild │ ╰── <child> ├── flowboxchild │ ╰── <child> ┊
// ╰── [rubberband] “`
//
// `GtkFlowBox` uses a single CSS node with name flowbox. `GtkFlowBoxChild` uses
// a single CSS node with name flowboxchild. For rubberband selection, a subnode
// with name rubberband is used.
//
//
// Accessibility
//
// `GtkFlowBox` uses the GTK_ACCESSIBLE_ROLE_GRID role, and `GtkFlowBoxChild`
// uses the GTK_ACCESSIBLE_ROLE_GRID_CELL role.
type FlowBox interface {
	Widget
	Accessible
	Buildable
	ConstraintTarget
	Orientable

	// ActivateOnSingleClick returns whether children activate on single clicks.
	ActivateOnSingleClick() bool
	// ColumnSpacing gets the horizontal spacing.
	ColumnSpacing() uint
	// Homogeneous returns whether the box is homogeneous.
	Homogeneous() bool
	// MaxChildrenPerLine gets the maximum number of children per line.
	MaxChildrenPerLine() uint
	// MinChildrenPerLine gets the minimum number of children per line.
	MinChildrenPerLine() uint
	// RowSpacing gets the vertical spacing.
	RowSpacing() uint
	// Insert inserts the @widget into @box at @position.
	//
	// If a sort function is set, the widget will actually be inserted at the
	// calculated position.
	//
	// If @position is -1, or larger than the total number of children in the
	// @box, then the @widget will be appended to the end.
	Insert(widget Widget, position int)
	// InvalidateFilter updates the filtering for all children.
	//
	// Call this function when the result of the filter function on the @box is
	// changed due ot an external factor. For instance, this would be used if
	// the filter function just looked for a specific search term, and the entry
	// with the string has changed.
	InvalidateFilter()
	// InvalidateSort updates the sorting for all children.
	//
	// Call this when the result of the sort function on @box is changed due to
	// an external factor.
	InvalidateSort()
	// Remove removes a child from @box.
	Remove(widget Widget)
	// SelectAll: select all children of @box, if the selection mode allows it.
	SelectAll()
	// SelectChild selects a single child of @box, if the selection mode allows
	// it.
	SelectChild(child FlowBoxChild)
	// SelectedForeach calls a function for each selected child.
	//
	// Note that the selection cannot be modified from within this function.
	SelectedForeach(fn FlowBoxForeachFunc)
	// SetActivateOnSingleClick: if @single is true, children will be activated
	// when you click on them, otherwise you need to double-click.
	SetActivateOnSingleClick(single bool)
	// SetColumnSpacing sets the horizontal space to add between children.
	SetColumnSpacing(spacing uint)
	// SetHAdjustment hooks up an adjustment to focus handling in @box.
	//
	// The adjustment is also used for autoscrolling during rubberband
	// selection. See [method@Gtk.ScrolledWindow.get_hadjustment] for a typical
	// way of obtaining the adjustment, and [method@Gtk.FlowBox.set_vadjustment]
	// for setting the vertical adjustment.
	//
	// The adjustments have to be in pixel units and in the same coordinate
	// system as the allocation for immediate children of the box.
	SetHAdjustment(adjustment Adjustment)
	// SetHomogeneous sets whether or not all children of @box are given equal
	// space in the box.
	SetHomogeneous(homogeneous bool)
	// SetMaxChildrenPerLine sets the maximum number of children to request and
	// allocate space for in @box’s orientation.
	//
	// Setting the maximum number of children per line limits the overall
	// natural size request to be no more than @n_children children long in the
	// given orientation.
	SetMaxChildrenPerLine(nChildren uint)
	// SetMinChildrenPerLine sets the minimum number of children to line up in
	// @box’s orientation before flowing.
	SetMinChildrenPerLine(nChildren uint)
	// SetRowSpacing sets the vertical space to add between children.
	SetRowSpacing(spacing uint)
	// SetSelectionMode sets how selection works in @box.
	SetSelectionMode(mode SelectionMode)
	// SetVAdjustment hooks up an adjustment to focus handling in @box.
	//
	// The adjustment is also used for autoscrolling during rubberband
	// selection. See [method@Gtk.ScrolledWindow.get_vadjustment] for a typical
	// way of obtaining the adjustment, and [method@Gtk.FlowBox.set_hadjustment]
	// for setting the horizontal adjustment.
	//
	// The adjustments have to be in pixel units and in the same coordinate
	// system as the allocation for immediate children of the box.
	SetVAdjustment(adjustment Adjustment)
	// UnselectAll: unselect all children of @box, if the selection mode allows
	// it.
	UnselectAll()
	// UnselectChild unselects a single child of @box, if the selection mode
	// allows it.
	UnselectChild(child FlowBoxChild)
}

// flowBox implements the FlowBox interface.
type flowBox struct {
	Widget
	Accessible
	Buildable
	ConstraintTarget
	Orientable
}

var _ FlowBox = (*flowBox)(nil)

// WrapFlowBox wraps a GObject to the right type. It is
// primarily used internally.
func WrapFlowBox(obj *externglib.Object) FlowBox {
	return FlowBox{
		Widget:           WrapWidget(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
		Orientable:       WrapOrientable(obj),
	}
}

func marshalFlowBox(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFlowBox(obj), nil
}

// ActivateOnSingleClick returns whether children activate on single clicks.
func (b flowBox) ActivateOnSingleClick() bool {
	var _arg0 *C.GtkFlowBox

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))

	var _cret C.gboolean

	_cret = C.gtk_flow_box_get_activate_on_single_click(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// ColumnSpacing gets the horizontal spacing.
func (b flowBox) ColumnSpacing() uint {
	var _arg0 *C.GtkFlowBox

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))

	var _cret C.guint

	_cret = C.gtk_flow_box_get_column_spacing(_arg0)

	var _guint uint

	_guint = (uint)(_cret)

	return _guint
}

// Homogeneous returns whether the box is homogeneous.
func (b flowBox) Homogeneous() bool {
	var _arg0 *C.GtkFlowBox

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))

	var _cret C.gboolean

	_cret = C.gtk_flow_box_get_homogeneous(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// MaxChildrenPerLine gets the maximum number of children per line.
func (b flowBox) MaxChildrenPerLine() uint {
	var _arg0 *C.GtkFlowBox

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))

	var _cret C.guint

	_cret = C.gtk_flow_box_get_max_children_per_line(_arg0)

	var _guint uint

	_guint = (uint)(_cret)

	return _guint
}

// MinChildrenPerLine gets the minimum number of children per line.
func (b flowBox) MinChildrenPerLine() uint {
	var _arg0 *C.GtkFlowBox

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))

	var _cret C.guint

	_cret = C.gtk_flow_box_get_min_children_per_line(_arg0)

	var _guint uint

	_guint = (uint)(_cret)

	return _guint
}

// RowSpacing gets the vertical spacing.
func (b flowBox) RowSpacing() uint {
	var _arg0 *C.GtkFlowBox

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))

	var _cret C.guint

	_cret = C.gtk_flow_box_get_row_spacing(_arg0)

	var _guint uint

	_guint = (uint)(_cret)

	return _guint
}

// Insert inserts the @widget into @box at @position.
//
// If a sort function is set, the widget will actually be inserted at the
// calculated position.
//
// If @position is -1, or larger than the total number of children in the
// @box, then the @widget will be appended to the end.
func (b flowBox) Insert(widget Widget, position int) {
	var _arg0 *C.GtkFlowBox
	var _arg1 *C.GtkWidget
	var _arg2 C.int

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg2 = C.int(position)

	C.gtk_flow_box_insert(_arg0, _arg1, _arg2)
}

// InvalidateFilter updates the filtering for all children.
//
// Call this function when the result of the filter function on the @box is
// changed due ot an external factor. For instance, this would be used if
// the filter function just looked for a specific search term, and the entry
// with the string has changed.
func (b flowBox) InvalidateFilter() {
	var _arg0 *C.GtkFlowBox

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))

	C.gtk_flow_box_invalidate_filter(_arg0)
}

// InvalidateSort updates the sorting for all children.
//
// Call this when the result of the sort function on @box is changed due to
// an external factor.
func (b flowBox) InvalidateSort() {
	var _arg0 *C.GtkFlowBox

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))

	C.gtk_flow_box_invalidate_sort(_arg0)
}

// Remove removes a child from @box.
func (b flowBox) Remove(widget Widget) {
	var _arg0 *C.GtkFlowBox
	var _arg1 *C.GtkWidget

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	C.gtk_flow_box_remove(_arg0, _arg1)
}

// SelectAll: select all children of @box, if the selection mode allows it.
func (b flowBox) SelectAll() {
	var _arg0 *C.GtkFlowBox

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))

	C.gtk_flow_box_select_all(_arg0)
}

// SelectChild selects a single child of @box, if the selection mode allows
// it.
func (b flowBox) SelectChild(child FlowBoxChild) {
	var _arg0 *C.GtkFlowBox
	var _arg1 *C.GtkFlowBoxChild

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkFlowBoxChild)(unsafe.Pointer(child.Native()))

	C.gtk_flow_box_select_child(_arg0, _arg1)
}

// SelectedForeach calls a function for each selected child.
//
// Note that the selection cannot be modified from within this function.
func (b flowBox) SelectedForeach(fn FlowBoxForeachFunc) {
	var _arg0 *C.GtkFlowBox
	var _arg1 C.GtkFlowBoxForeachFunc
	var _arg2 C.gpointer

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
	_arg1 = (*[0]byte)(C.gotk4_FlowBoxForeachFunc)
	_arg2 = C.gpointer(box.Assign(fn))

	C.gtk_flow_box_selected_foreach(_arg0, _arg1, _arg2)
}

// SetActivateOnSingleClick: if @single is true, children will be activated
// when you click on them, otherwise you need to double-click.
func (b flowBox) SetActivateOnSingleClick(single bool) {
	var _arg0 *C.GtkFlowBox
	var _arg1 C.gboolean

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
	if single {
		_arg1 = C.gboolean(1)
	}

	C.gtk_flow_box_set_activate_on_single_click(_arg0, _arg1)
}

// SetColumnSpacing sets the horizontal space to add between children.
func (b flowBox) SetColumnSpacing(spacing uint) {
	var _arg0 *C.GtkFlowBox
	var _arg1 C.guint

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
	_arg1 = C.guint(spacing)

	C.gtk_flow_box_set_column_spacing(_arg0, _arg1)
}

// SetHAdjustment hooks up an adjustment to focus handling in @box.
//
// The adjustment is also used for autoscrolling during rubberband
// selection. See [method@Gtk.ScrolledWindow.get_hadjustment] for a typical
// way of obtaining the adjustment, and [method@Gtk.FlowBox.set_vadjustment]
// for setting the vertical adjustment.
//
// The adjustments have to be in pixel units and in the same coordinate
// system as the allocation for immediate children of the box.
func (b flowBox) SetHAdjustment(adjustment Adjustment) {
	var _arg0 *C.GtkFlowBox
	var _arg1 *C.GtkAdjustment

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(adjustment.Native()))

	C.gtk_flow_box_set_hadjustment(_arg0, _arg1)
}

// SetHomogeneous sets whether or not all children of @box are given equal
// space in the box.
func (b flowBox) SetHomogeneous(homogeneous bool) {
	var _arg0 *C.GtkFlowBox
	var _arg1 C.gboolean

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
	if homogeneous {
		_arg1 = C.gboolean(1)
	}

	C.gtk_flow_box_set_homogeneous(_arg0, _arg1)
}

// SetMaxChildrenPerLine sets the maximum number of children to request and
// allocate space for in @box’s orientation.
//
// Setting the maximum number of children per line limits the overall
// natural size request to be no more than @n_children children long in the
// given orientation.
func (b flowBox) SetMaxChildrenPerLine(nChildren uint) {
	var _arg0 *C.GtkFlowBox
	var _arg1 C.guint

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
	_arg1 = C.guint(nChildren)

	C.gtk_flow_box_set_max_children_per_line(_arg0, _arg1)
}

// SetMinChildrenPerLine sets the minimum number of children to line up in
// @box’s orientation before flowing.
func (b flowBox) SetMinChildrenPerLine(nChildren uint) {
	var _arg0 *C.GtkFlowBox
	var _arg1 C.guint

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
	_arg1 = C.guint(nChildren)

	C.gtk_flow_box_set_min_children_per_line(_arg0, _arg1)
}

// SetRowSpacing sets the vertical space to add between children.
func (b flowBox) SetRowSpacing(spacing uint) {
	var _arg0 *C.GtkFlowBox
	var _arg1 C.guint

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
	_arg1 = C.guint(spacing)

	C.gtk_flow_box_set_row_spacing(_arg0, _arg1)
}

// SetSelectionMode sets how selection works in @box.
func (b flowBox) SetSelectionMode(mode SelectionMode) {
	var _arg0 *C.GtkFlowBox
	var _arg1 C.GtkSelectionMode

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
	_arg1 = (C.GtkSelectionMode)(mode)

	C.gtk_flow_box_set_selection_mode(_arg0, _arg1)
}

// SetVAdjustment hooks up an adjustment to focus handling in @box.
//
// The adjustment is also used for autoscrolling during rubberband
// selection. See [method@Gtk.ScrolledWindow.get_vadjustment] for a typical
// way of obtaining the adjustment, and [method@Gtk.FlowBox.set_hadjustment]
// for setting the horizontal adjustment.
//
// The adjustments have to be in pixel units and in the same coordinate
// system as the allocation for immediate children of the box.
func (b flowBox) SetVAdjustment(adjustment Adjustment) {
	var _arg0 *C.GtkFlowBox
	var _arg1 *C.GtkAdjustment

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(adjustment.Native()))

	C.gtk_flow_box_set_vadjustment(_arg0, _arg1)
}

// UnselectAll: unselect all children of @box, if the selection mode allows
// it.
func (b flowBox) UnselectAll() {
	var _arg0 *C.GtkFlowBox

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))

	C.gtk_flow_box_unselect_all(_arg0)
}

// UnselectChild unselects a single child of @box, if the selection mode
// allows it.
func (b flowBox) UnselectChild(child FlowBoxChild) {
	var _arg0 *C.GtkFlowBox
	var _arg1 *C.GtkFlowBoxChild

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkFlowBoxChild)(unsafe.Pointer(child.Native()))

	C.gtk_flow_box_unselect_child(_arg0, _arg1)
}

// FontButton: the `GtkFontButton` allows to open a font chooser dialog to
// change the font.
//
// !An example GtkFontButton (font-button.png)
//
// It is suitable widget for selecting a font in a preference dialog.
//
//
// CSS nodes
//
// “` fontbutton ╰── button.font ╰── [content] “`
//
// `GtkFontButton` has a single CSS node with name fontbutton which contains a
// button node with the .font style class.
type FontButton interface {
	Widget
	Accessible
	Buildable
	ConstraintTarget
	FontChooser

	// Modal gets whether the dialog is modal.
	Modal() bool
	// Title retrieves the title of the font chooser dialog.
	Title() string
	// UseFont returns whether the selected font is used in the label.
	UseFont() bool
	// UseSize returns whether the selected size is used in the label.
	UseSize() bool
	// SetModal sets whether the dialog should be modal.
	SetModal(modal bool)
	// SetTitle sets the title for the font chooser dialog.
	SetTitle(title string)
	// SetUseFont: if @use_font is true, the font name will be written using the
	// selected font.
	SetUseFont(useFont bool)
	// SetUseSize: if @use_size is true, the font name will be written using the
	// selected size.
	SetUseSize(useSize bool)
}

// fontButton implements the FontButton interface.
type fontButton struct {
	Widget
	Accessible
	Buildable
	ConstraintTarget
	FontChooser
}

var _ FontButton = (*fontButton)(nil)

// WrapFontButton wraps a GObject to the right type. It is
// primarily used internally.
func WrapFontButton(obj *externglib.Object) FontButton {
	return FontButton{
		Widget:           WrapWidget(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
		FontChooser:      WrapFontChooser(obj),
	}
}

func marshalFontButton(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFontButton(obj), nil
}

// Modal gets whether the dialog is modal.
func (f fontButton) Modal() bool {
	var _arg0 *C.GtkFontButton

	_arg0 = (*C.GtkFontButton)(unsafe.Pointer(f.Native()))

	var _cret C.gboolean

	_cret = C.gtk_font_button_get_modal(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// Title retrieves the title of the font chooser dialog.
func (f fontButton) Title() string {
	var _arg0 *C.GtkFontButton

	_arg0 = (*C.GtkFontButton)(unsafe.Pointer(f.Native()))

	var _cret *C.char

	_cret = C.gtk_font_button_get_title(_arg0)

	var _utf8 string

	_utf8 = C.GoString(_cret)

	return _utf8
}

// UseFont returns whether the selected font is used in the label.
func (f fontButton) UseFont() bool {
	var _arg0 *C.GtkFontButton

	_arg0 = (*C.GtkFontButton)(unsafe.Pointer(f.Native()))

	var _cret C.gboolean

	_cret = C.gtk_font_button_get_use_font(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// UseSize returns whether the selected size is used in the label.
func (f fontButton) UseSize() bool {
	var _arg0 *C.GtkFontButton

	_arg0 = (*C.GtkFontButton)(unsafe.Pointer(f.Native()))

	var _cret C.gboolean

	_cret = C.gtk_font_button_get_use_size(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// SetModal sets whether the dialog should be modal.
func (f fontButton) SetModal(modal bool) {
	var _arg0 *C.GtkFontButton
	var _arg1 C.gboolean

	_arg0 = (*C.GtkFontButton)(unsafe.Pointer(f.Native()))
	if modal {
		_arg1 = C.gboolean(1)
	}

	C.gtk_font_button_set_modal(_arg0, _arg1)
}

// SetTitle sets the title for the font chooser dialog.
func (f fontButton) SetTitle(title string) {
	var _arg0 *C.GtkFontButton
	var _arg1 *C.char

	_arg0 = (*C.GtkFontButton)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.char)(C.CString(title))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_font_button_set_title(_arg0, _arg1)
}

// SetUseFont: if @use_font is true, the font name will be written using the
// selected font.
func (f fontButton) SetUseFont(useFont bool) {
	var _arg0 *C.GtkFontButton
	var _arg1 C.gboolean

	_arg0 = (*C.GtkFontButton)(unsafe.Pointer(f.Native()))
	if useFont {
		_arg1 = C.gboolean(1)
	}

	C.gtk_font_button_set_use_font(_arg0, _arg1)
}

// SetUseSize: if @use_size is true, the font name will be written using the
// selected size.
func (f fontButton) SetUseSize(useSize bool) {
	var _arg0 *C.GtkFontButton
	var _arg1 C.gboolean

	_arg0 = (*C.GtkFontButton)(unsafe.Pointer(f.Native()))
	if useSize {
		_arg1 = C.gboolean(1)
	}

	C.gtk_font_button_set_use_size(_arg0, _arg1)
}

// FontChooserDialog: the `GtkFontChooserDialog` widget is a dialog for
// selecting a font.
//
// !An example GtkFontChooserDialog (fontchooser.png)
//
// `GtkFontChooserDialog` implements the [iface@Gtk.FontChooser] interface and
// does not provide much API of its own.
//
// To create a `GtkFontChooserDialog`, use [ctor@Gtk.FontChooserDialog.new].
//
//
// GtkFontChooserDialog as GtkBuildable
//
// The `GtkFontChooserDialog` implementation of the `GtkBuildable` interface
// exposes the buttons with the names “select_button” and “cancel_button”.
type FontChooserDialog interface {
	Dialog
	Accessible
	Buildable
	ConstraintTarget
	FontChooser
	Native
	Root
	ShortcutManager
}

// fontChooserDialog implements the FontChooserDialog interface.
type fontChooserDialog struct {
	Dialog
	Accessible
	Buildable
	ConstraintTarget
	FontChooser
	Native
	Root
	ShortcutManager
}

var _ FontChooserDialog = (*fontChooserDialog)(nil)

// WrapFontChooserDialog wraps a GObject to the right type. It is
// primarily used internally.
func WrapFontChooserDialog(obj *externglib.Object) FontChooserDialog {
	return FontChooserDialog{
		Dialog:           WrapDialog(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
		FontChooser:      WrapFontChooser(obj),
		Native:           WrapNative(obj),
		Root:             WrapRoot(obj),
		ShortcutManager:  WrapShortcutManager(obj),
	}
}

func marshalFontChooserDialog(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFontChooserDialog(obj), nil
}

// FontChooserWidget: the `GtkFontChooserWidget` widget lets the user select a
// font.
//
// It is used in the `GtkFontChooserDialog` widget to provide a dialog for
// selecting fonts.
//
// To set the font which is initially selected, use
// [method@Gtk.FontChooser.set_font] or [method@Gtk.FontChooser.set_font_desc].
//
// To get the selected font use [method@Gtk.FontChooser.get_font] or
// [method@Gtk.FontChooser.get_font_desc].
//
// To change the text which is shown in the preview area, use
// [method@Gtk.FontChooser.set_preview_text].
//
//
// CSS nodes
//
// `GtkFontChooserWidget` has a single CSS node with name fontchooser.
type FontChooserWidget interface {
	Widget
	Accessible
	Buildable
	ConstraintTarget
	FontChooser
}

// fontChooserWidget implements the FontChooserWidget interface.
type fontChooserWidget struct {
	Widget
	Accessible
	Buildable
	ConstraintTarget
	FontChooser
}

var _ FontChooserWidget = (*fontChooserWidget)(nil)

// WrapFontChooserWidget wraps a GObject to the right type. It is
// primarily used internally.
func WrapFontChooserWidget(obj *externglib.Object) FontChooserWidget {
	return FontChooserWidget{
		Widget:           WrapWidget(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
		FontChooser:      WrapFontChooser(obj),
	}
}

func marshalFontChooserWidget(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFontChooserWidget(obj), nil
}

// HeaderBar: `GtkHeaderBar` is a widget for creating custom title bars for
// windows.
//
// !An example GtkHeaderBar (headerbar.png)
//
// `GtkHeaderBar` is similar to a horizontal `GtkCenterBox`. It allows children
// to be placed at the start or the end. In addition, it allows the window title
// to be displayed. The title will be centered with respect to the width of the
// box, even if the children at either side take up different amounts of space.
//
// `GtkHeaderBar` can add typical window frame controls, such as minimize,
// maximize and close buttons, or the window icon.
//
// For these reasons, `GtkHeaderBar` is the natural choice for use as the custom
// titlebar widget of a `GtkWindow (see [method@Gtk.Window.set_titlebar]), as it
// gives features typical of titlebars while allowing the addition of child
// widgets.
//
//
// GtkHeaderBar as GtkBuildable
//
// The `GtkHeaderBar` implementation of the `GtkBuildable` interface supports
// adding children at the start or end sides by specifying “start” or “end” as
// the “type” attribute of a <child> element, or setting the title widget by
// specifying “title” value.
//
// By default the `GtkHeaderBar` uses a `GtkLabel` displaying the title of the
// window it is contained in as the title widget, equivalent to the following UI
// definition:
//
// “`xml <object class="GtkHeaderBar"> <property name="title-widget"> <object
// class="GtkLabel"> <property name="label" translatable="yes">Label</property>
// <property name="single-line-mode">True</property> <property
// name="ellipsize">end</property> <property name="width-chars">5</property>
// <style> <class name="title"/> </style> </object> </property> </object> “`
//
//
// CSS nodes
//
// “` headerbar ╰── windowhandle ╰── box ├── box.start │ ├──
// windowcontrols.start │ ╰── [other children] ├── [Title Widget] ╰── box.end
// ├── [other children] ╰── windowcontrols.end “`
//
// A `GtkHeaderBar`'s CSS node is called `headerbar`. It contains a
// `windowhandle` subnode, which contains a `box` subnode, which contains two
// `box` subnodes at the start and end of the header bar, as well as a center
// node that represents the title.
//
// Each of the boxes contains a `windowcontrols` subnode, see
// [class@Gtk.WindowControls] for details, as well as other children.
//
//
// Accessibility
//
// `GtkHeaderBar` uses the GTK_ACCESSIBLE_ROLE_GROUP role.
type HeaderBar interface {
	Widget
	Accessible
	Buildable
	ConstraintTarget

	// DecorationLayout gets the decoration layout of the `GtkHeaderBar`.
	DecorationLayout() string
	// ShowTitleButtons returns whether this header bar shows the standard
	// window title buttons.
	ShowTitleButtons() bool
	// PackEnd adds @child to @bar, packed with reference to the end of the
	// @bar.
	PackEnd(child Widget)
	// PackStart adds @child to @bar, packed with reference to the start of the
	// @bar.
	PackStart(child Widget)
	// Remove removes a child from the `GtkHeaderBar`.
	//
	// The child must have been added with [method@Gtk.HeaderBar.pack_start],
	// [method@Gtk.HeaderBar.pack_end] or
	// [method@Gtk.HeaderBar.set_title_widget].
	Remove(child Widget)
	// SetDecorationLayout sets the decoration layout for this header bar.
	//
	// This property overrides the [property@Gtk.Settings:gtk-decoration-layout]
	// setting.
	//
	// There can be valid reasons for overriding the setting, such as a header
	// bar design that does not allow for buttons to take room on the right, or
	// only offers room for a single close button. Split header bars are another
	// example for overriding the setting.
	//
	// The format of the string is button names, separated by commas. A colon
	// separates the buttons that should appear on the left from those on the
	// right. Recognized button names are minimize, maximize, close and icon
	// (the window icon).
	//
	// For example, “icon:minimize,maximize,close” specifies a icon on the left,
	// and minimize, maximize and close buttons on the right.
	SetDecorationLayout(layout string)
	// SetShowTitleButtons sets whether this header bar shows the standard
	// window title buttons.
	SetShowTitleButtons(setting bool)
	// SetTitleWidget sets the title for the `GtkHeaderBar`.
	//
	// When set to nil, the headerbar will display the title of the window it is
	// contained in.
	//
	// The title should help a user identify the current view. To achieve the
	// same style as the builtin title, use the “title” style class.
	//
	// You should set the title widget to nil, for the window title label to be
	// visible again.
	SetTitleWidget(titleWidget Widget)
}

// headerBar implements the HeaderBar interface.
type headerBar struct {
	Widget
	Accessible
	Buildable
	ConstraintTarget
}

var _ HeaderBar = (*headerBar)(nil)

// WrapHeaderBar wraps a GObject to the right type. It is
// primarily used internally.
func WrapHeaderBar(obj *externglib.Object) HeaderBar {
	return HeaderBar{
		Widget:           WrapWidget(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
	}
}

func marshalHeaderBar(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapHeaderBar(obj), nil
}

// DecorationLayout gets the decoration layout of the `GtkHeaderBar`.
func (b headerBar) DecorationLayout() string {
	var _arg0 *C.GtkHeaderBar

	_arg0 = (*C.GtkHeaderBar)(unsafe.Pointer(b.Native()))

	var _cret *C.char

	_cret = C.gtk_header_bar_get_decoration_layout(_arg0)

	var _utf8 string

	_utf8 = C.GoString(_cret)

	return _utf8
}

// ShowTitleButtons returns whether this header bar shows the standard
// window title buttons.
func (b headerBar) ShowTitleButtons() bool {
	var _arg0 *C.GtkHeaderBar

	_arg0 = (*C.GtkHeaderBar)(unsafe.Pointer(b.Native()))

	var _cret C.gboolean

	_cret = C.gtk_header_bar_get_show_title_buttons(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// PackEnd adds @child to @bar, packed with reference to the end of the
// @bar.
func (b headerBar) PackEnd(child Widget) {
	var _arg0 *C.GtkHeaderBar
	var _arg1 *C.GtkWidget

	_arg0 = (*C.GtkHeaderBar)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_header_bar_pack_end(_arg0, _arg1)
}

// PackStart adds @child to @bar, packed with reference to the start of the
// @bar.
func (b headerBar) PackStart(child Widget) {
	var _arg0 *C.GtkHeaderBar
	var _arg1 *C.GtkWidget

	_arg0 = (*C.GtkHeaderBar)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_header_bar_pack_start(_arg0, _arg1)
}

// Remove removes a child from the `GtkHeaderBar`.
//
// The child must have been added with [method@Gtk.HeaderBar.pack_start],
// [method@Gtk.HeaderBar.pack_end] or
// [method@Gtk.HeaderBar.set_title_widget].
func (b headerBar) Remove(child Widget) {
	var _arg0 *C.GtkHeaderBar
	var _arg1 *C.GtkWidget

	_arg0 = (*C.GtkHeaderBar)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_header_bar_remove(_arg0, _arg1)
}

// SetDecorationLayout sets the decoration layout for this header bar.
//
// This property overrides the [property@Gtk.Settings:gtk-decoration-layout]
// setting.
//
// There can be valid reasons for overriding the setting, such as a header
// bar design that does not allow for buttons to take room on the right, or
// only offers room for a single close button. Split header bars are another
// example for overriding the setting.
//
// The format of the string is button names, separated by commas. A colon
// separates the buttons that should appear on the left from those on the
// right. Recognized button names are minimize, maximize, close and icon
// (the window icon).
//
// For example, “icon:minimize,maximize,close” specifies a icon on the left,
// and minimize, maximize and close buttons on the right.
func (b headerBar) SetDecorationLayout(layout string) {
	var _arg0 *C.GtkHeaderBar
	var _arg1 *C.char

	_arg0 = (*C.GtkHeaderBar)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.char)(C.CString(layout))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_header_bar_set_decoration_layout(_arg0, _arg1)
}

// SetShowTitleButtons sets whether this header bar shows the standard
// window title buttons.
func (b headerBar) SetShowTitleButtons(setting bool) {
	var _arg0 *C.GtkHeaderBar
	var _arg1 C.gboolean

	_arg0 = (*C.GtkHeaderBar)(unsafe.Pointer(b.Native()))
	if setting {
		_arg1 = C.gboolean(1)
	}

	C.gtk_header_bar_set_show_title_buttons(_arg0, _arg1)
}

// SetTitleWidget sets the title for the `GtkHeaderBar`.
//
// When set to nil, the headerbar will display the title of the window it is
// contained in.
//
// The title should help a user identify the current view. To achieve the
// same style as the builtin title, use the “title” style class.
//
// You should set the title widget to nil, for the window title label to be
// visible again.
func (b headerBar) SetTitleWidget(titleWidget Widget) {
	var _arg0 *C.GtkHeaderBar
	var _arg1 *C.GtkWidget

	_arg0 = (*C.GtkHeaderBar)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(titleWidget.Native()))

	C.gtk_header_bar_set_title_widget(_arg0, _arg1)
}

// IconPaintable contains information found when looking up an icon in
// `GtkIconTheme`.
//
// `GtkIconPaintable` implements `GdkPaintable`.
type IconPaintable interface {
	gextras.Objector
	gdk.Paintable

	// IconName: get the icon name being used for this icon.
	//
	// When an icon looked up in the icon theme was not available, the icon
	// theme may use fallback icons - either those specified to
	// gtk_icon_theme_lookup_icon() or the always-available "image-missing". The
	// icon chosen is returned by this function.
	//
	// If the icon was created without an icon theme, this function returns nil.
	IconName() *string
	// IsSymbolic checks if the icon is symbolic or not.
	//
	// This currently uses only the file name and not the file contents for
	// determining this. This behaviour may change in the future.
	//
	// Note that to render a symbolic `GtkIconPaintable` properly (with
	// recoloring), you have to set its icon name on a `GtkImage`.
	IsSymbolic() bool
}

// iconPaintable implements the IconPaintable interface.
type iconPaintable struct {
	gextras.Objector
	gdk.Paintable
}

var _ IconPaintable = (*iconPaintable)(nil)

// WrapIconPaintable wraps a GObject to the right type. It is
// primarily used internally.
func WrapIconPaintable(obj *externglib.Object) IconPaintable {
	return IconPaintable{
		Objector:      obj,
		gdk.Paintable: gdk.WrapPaintable(obj),
	}
}

func marshalIconPaintable(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapIconPaintable(obj), nil
}

// IconName: get the icon name being used for this icon.
//
// When an icon looked up in the icon theme was not available, the icon
// theme may use fallback icons - either those specified to
// gtk_icon_theme_lookup_icon() or the always-available "image-missing". The
// icon chosen is returned by this function.
//
// If the icon was created without an icon theme, this function returns nil.
func (s iconPaintable) IconName() *string {
	var _arg0 *C.GtkIconPaintable

	_arg0 = (*C.GtkIconPaintable)(unsafe.Pointer(s.Native()))

	var _cret *C.char

	_cret = C.gtk_icon_paintable_get_icon_name(_arg0)

	var _filename *string

	_filename = C.GoString(_cret)

	return _filename
}

// IsSymbolic checks if the icon is symbolic or not.
//
// This currently uses only the file name and not the file contents for
// determining this. This behaviour may change in the future.
//
// Note that to render a symbolic `GtkIconPaintable` properly (with
// recoloring), you have to set its icon name on a `GtkImage`.
func (s iconPaintable) IsSymbolic() bool {
	var _arg0 *C.GtkIconPaintable

	_arg0 = (*C.GtkIconPaintable)(unsafe.Pointer(s.Native()))

	var _cret C.gboolean

	_cret = C.gtk_icon_paintable_is_symbolic(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// IconTheme: `GtkIconTheme` provides a facility for loading themed icons.
//
// The main reason for using a name rather than simply providing a filename is
// to allow different icons to be used depending on what “icon theme” is
// selected by the user. The operation of icon themes on Linux and Unix follows
// the Icon Theme Specification
// (http://www.freedesktop.org/Standards/icon-theme-spec) There is a fallback
// icon theme, named `hicolor`, where applications should install their icons,
// but additional icon themes can be installed as operating system vendors and
// users choose.
//
// In many cases, named themes are used indirectly, via [class@Gtk.Image] rather
// than directly, but looking up icons directly is also simple. The
// `GtkIconTheme` object acts as a database of all the icons in the current
// theme. You can create new `GtkIconTheme` objects, but it’s much more
// efficient to use the standard icon theme of the `GtkWidget` so that the icon
// information is shared with other people looking up icons.
//
// “`c GtkIconTheme *icon_theme; GtkIconPaintable *icon; GdkPaintable
// *paintable;
//
// icon_theme = gtk_icon_theme_get_for_display (gtk_widget_get_display
// (my_widget)); icon = gtk_icon_theme_lookup_icon (icon_theme, "my-icon-name",
// // icon name 48, // icon size 1, // scale 0, // flags); paintable =
// GDK_PAINTABLE (icon); // Use the paintable g_object_unref (icon); “`
type IconTheme interface {
	gextras.Objector

	// AddResourcePath adds a resource path that will be looked at when looking
	// for icons, similar to search paths.
	//
	// See [method@Gtk.IconTheme.set_resource_path].
	//
	// This function should be used to make application-specific icons available
	// as part of the icon theme.
	AddResourcePath(path string)
	// AddSearchPath appends a directory to the search path.
	//
	// See [method@Gtk.IconTheme.set_search_path].
	AddSearchPath(path *string)
	// IconNames lists the names of icons in the current icon theme.
	IconNames() []string
	// IconSizes returns an array of integers describing the sizes at which the
	// icon is available without scaling.
	//
	// A size of -1 means that the icon is available in a scalable format. The
	// array is zero-terminated.
	IconSizes(iconName string) []int
	// ResourcePath gets the current resource path.
	//
	// See [method@Gtk.IconTheme.set_resource_path].
	ResourcePath() []string
	// SearchPath gets the current search path.
	//
	// See [method@Gtk.IconTheme.set_search_path].
	SearchPath() []*string
	// ThemeName gets the current icon theme name.
	//
	// Returns (transfer full): the current icon theme name,
	ThemeName() string
	// HasGIcon checks whether an icon theme includes an icon for a particular
	// `GIcon`.
	HasGIcon(gicon gio.Icon) bool
	// HasIcon checks whether an icon theme includes an icon for a particular
	// name.
	HasIcon(iconName string) bool
	// SetResourcePath sets the resource paths that will be looked at when
	// looking for icons, similar to search paths.
	//
	// The resources are considered as part of the hicolor icon theme and must
	// be located in subdirectories that are defined in the hicolor icon theme,
	// such as `@path/16x16/actions/run.png` or
	// `@path/scalable/actions/run.svg`.
	//
	// Icons that are directly placed in the resource path instead of a
	// subdirectory are also considered as ultimate fallback, but they are
	// treated like unthemed icons.
	SetResourcePath(path *string)
	// SetSearchPath sets the search path for the icon theme object.
	//
	// When looking for an icon theme, GTK will search for a subdirectory of one
	// or more of the directories in @path with the same name as the icon theme
	// containing an index.theme file. (Themes from multiple of the path
	// elements are combined to allow themes to be extended by adding icons in
	// the user’s home directory.)
	//
	// In addition if an icon found isn’t found either in the current icon theme
	// or the default icon theme, and an image file with the right name is found
	// directly in one of the elements of @path, then that image will be used
	// for the icon name. (This is legacy feature, and new icons should be put
	// into the fallback icon theme, which is called hicolor, rather than
	// directly on the icon path.)
	SetSearchPath(path []*string)
	// SetThemeName sets the name of the icon theme that the `GtkIconTheme`
	// object uses overriding system configuration.
	//
	// This function cannot be called on the icon theme objects returned from
	// [type_func@Gtk.IconTheme.get_for_display].
	SetThemeName(themeName string)
}

// iconTheme implements the IconTheme interface.
type iconTheme struct {
	gextras.Objector
}

var _ IconTheme = (*iconTheme)(nil)

// WrapIconTheme wraps a GObject to the right type. It is
// primarily used internally.
func WrapIconTheme(obj *externglib.Object) IconTheme {
	return IconTheme{
		Objector: obj,
	}
}

func marshalIconTheme(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapIconTheme(obj), nil
}

// AddResourcePath adds a resource path that will be looked at when looking
// for icons, similar to search paths.
//
// See [method@Gtk.IconTheme.set_resource_path].
//
// This function should be used to make application-specific icons available
// as part of the icon theme.
func (s iconTheme) AddResourcePath(path string) {
	var _arg0 *C.GtkIconTheme
	var _arg1 *C.char

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(path))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_icon_theme_add_resource_path(_arg0, _arg1)
}

// AddSearchPath appends a directory to the search path.
//
// See [method@Gtk.IconTheme.set_search_path].
func (s iconTheme) AddSearchPath(path *string) {
	var _arg0 *C.GtkIconTheme
	var _arg1 *C.char

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(path))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_icon_theme_add_search_path(_arg0, _arg1)
}

// IconNames lists the names of icons in the current icon theme.
func (s iconTheme) IconNames() []string {
	var _arg0 *C.GtkIconTheme

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(s.Native()))

	var _cret **C.char

	_cret = C.gtk_icon_theme_get_icon_names(_arg0)

	var _utf8s []string

	{
		var length int
		for p := _cret; *p != 0; p = (**C.char)(ptr.Add(unsafe.Pointer(p), unsafe.Sizeof(int(0)))) {
			length++
			if length < 0 {
				panic(`length overflow`)
			}
		}

		var src []*C.gchar
		ptr.SetSlice(unsafe.Pointer(&src), unsafe.Pointer(_cret), int(length))

		_utf8s = make([]string, length)
		for i := range src {
			_utf8s = C.GoString(_cret)
			defer C.free(unsafe.Pointer(_cret))
		}
	}

	return _utf8s
}

// IconSizes returns an array of integers describing the sizes at which the
// icon is available without scaling.
//
// A size of -1 means that the icon is available in a scalable format. The
// array is zero-terminated.
func (s iconTheme) IconSizes(iconName string) []int {
	var _arg0 *C.GtkIconTheme
	var _arg1 *C.char

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(iconName))
	defer C.free(unsafe.Pointer(_arg1))

	var _cret *C.int

	_cret = C.gtk_icon_theme_get_icon_sizes(_arg0, _arg1)

	var _gints []int

	{
		var length int
		for p := _cret; *p != 0; p = (*C.int)(ptr.Add(unsafe.Pointer(p), unsafe.Sizeof(int(0)))) {
			length++
			if length < 0 {
				panic(`length overflow`)
			}
		}

		var src []C.int
		ptr.SetSlice(unsafe.Pointer(&src), unsafe.Pointer(_cret), int(length))

		_gints = make([]int, length)
		for i := range src {
			_gints = (int)(_cret)
		}
	}

	return _gints
}

// ResourcePath gets the current resource path.
//
// See [method@Gtk.IconTheme.set_resource_path].
func (s iconTheme) ResourcePath() []string {
	var _arg0 *C.GtkIconTheme

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(s.Native()))

	var _cret **C.char

	_cret = C.gtk_icon_theme_get_resource_path(_arg0)

	var _utf8s []string

	{
		var length int
		for p := _cret; *p != 0; p = (**C.char)(ptr.Add(unsafe.Pointer(p), unsafe.Sizeof(int(0)))) {
			length++
			if length < 0 {
				panic(`length overflow`)
			}
		}

		var src []*C.gchar
		ptr.SetSlice(unsafe.Pointer(&src), unsafe.Pointer(_cret), int(length))

		_utf8s = make([]string, length)
		for i := range src {
			_utf8s = C.GoString(_cret)
			defer C.free(unsafe.Pointer(_cret))
		}
	}

	return _utf8s
}

// SearchPath gets the current search path.
//
// See [method@Gtk.IconTheme.set_search_path].
func (s iconTheme) SearchPath() []*string {
	var _arg0 *C.GtkIconTheme

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(s.Native()))

	var _cret **C.char

	_cret = C.gtk_icon_theme_get_search_path(_arg0)

	var _filenames []*string

	{
		var length int
		for p := _cret; *p != 0; p = (**C.char)(ptr.Add(unsafe.Pointer(p), unsafe.Sizeof(int(0)))) {
			length++
			if length < 0 {
				panic(`length overflow`)
			}
		}

		var src []*C.gchar
		ptr.SetSlice(unsafe.Pointer(&src), unsafe.Pointer(_cret), int(length))

		_filenames = make([]*string, length)
		for i := range src {
			_filenames = C.GoString(_cret)
			defer C.free(unsafe.Pointer(_cret))
		}
	}

	return _filenames
}

// ThemeName gets the current icon theme name.
//
// Returns (transfer full): the current icon theme name,
func (s iconTheme) ThemeName() string {
	var _arg0 *C.GtkIconTheme

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(s.Native()))

	var _cret *C.char

	_cret = C.gtk_icon_theme_get_theme_name(_arg0)

	var _utf8 string

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// HasGIcon checks whether an icon theme includes an icon for a particular
// `GIcon`.
func (s iconTheme) HasGIcon(gicon gio.Icon) bool {
	var _arg0 *C.GtkIconTheme
	var _arg1 *C.GIcon

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GIcon)(unsafe.Pointer(gicon.Native()))

	var _cret C.gboolean

	_cret = C.gtk_icon_theme_has_gicon(_arg0, _arg1)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// HasIcon checks whether an icon theme includes an icon for a particular
// name.
func (s iconTheme) HasIcon(iconName string) bool {
	var _arg0 *C.GtkIconTheme
	var _arg1 *C.char

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(iconName))
	defer C.free(unsafe.Pointer(_arg1))

	var _cret C.gboolean

	_cret = C.gtk_icon_theme_has_icon(_arg0, _arg1)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// SetResourcePath sets the resource paths that will be looked at when
// looking for icons, similar to search paths.
//
// The resources are considered as part of the hicolor icon theme and must
// be located in subdirectories that are defined in the hicolor icon theme,
// such as `@path/16x16/actions/run.png` or
// `@path/scalable/actions/run.svg`.
//
// Icons that are directly placed in the resource path instead of a
// subdirectory are also considered as ultimate fallback, but they are
// treated like unthemed icons.
func (s iconTheme) SetResourcePath(path *string) {
	var _arg0 *C.GtkIconTheme
	var _arg1 **C.char

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(s.Native()))
	_arg1 = (**C.char)(C.CString(path))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_icon_theme_set_resource_path(_arg0, _arg1)
}

// SetSearchPath sets the search path for the icon theme object.
//
// When looking for an icon theme, GTK will search for a subdirectory of one
// or more of the directories in @path with the same name as the icon theme
// containing an index.theme file. (Themes from multiple of the path
// elements are combined to allow themes to be extended by adding icons in
// the user’s home directory.)
//
// In addition if an icon found isn’t found either in the current icon theme
// or the default icon theme, and an image file with the right name is found
// directly in one of the elements of @path, then that image will be used
// for the icon name. (This is legacy feature, and new icons should be put
// into the fallback icon theme, which is called hicolor, rather than
// directly on the icon path.)
func (s iconTheme) SetSearchPath(path []*string) {
	var _arg0 *C.GtkIconTheme
	var _arg1 **C.char

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(s.Native()))
	_arg1 = (**C.char)(C.malloc((len(path) + 1) * unsafe.Sizeof(int(0))))
	defer C.free(unsafe.Pointer(_arg1))

	{
		var out []*C.gchar
		ptr.SetSlice(unsafe.Pointer(&dst), unsafe.Pointer(_arg1), int(len(path)))

		for i := range path {
			_arg1 = (*C.gchar)(C.CString(path))
			defer C.free(unsafe.Pointer(_arg1))
		}
	}

	C.gtk_icon_theme_set_search_path(_arg0, _arg1)
}

// SetThemeName sets the name of the icon theme that the `GtkIconTheme`
// object uses overriding system configuration.
//
// This function cannot be called on the icon theme objects returned from
// [type_func@Gtk.IconTheme.get_for_display].
func (s iconTheme) SetThemeName(themeName string) {
	var _arg0 *C.GtkIconTheme
	var _arg1 *C.char

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(themeName))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_icon_theme_set_theme_name(_arg0, _arg1)
}

// IconView: `GtkIconView` is a widget which displays data in a grid of icons.
//
// `GtkIconView` provides an alternative view on a `GtkTreeModel`. It displays
// the model as a grid of icons with labels. Like [class@Gtk.TreeView], it
// allows to select one or multiple items (depending on the selection mode, see
// [method@Gtk.IconView.set_selection_mode]). In addition to selection with the
// arrow keys, `GtkIconView` supports rubberband selection, which is controlled
// by dragging the pointer.
//
// Note that if the tree model is backed by an actual tree store (as opposed to
// a flat list where the mapping to icons is obvious), IconView will only
// display the first level of the tree and ignore the tree’s branches.
//
//
// CSS nodes
//
// “` iconview.view ╰── [rubberband] “`
//
// `GtkIconView` has a single CSS node with name iconview and style class .view.
// For rubberband selection, a subnode with name rubberband is used.
type IconView interface {
	Widget
	Accessible
	Buildable
	CellLayout
	ConstraintTarget
	Scrollable

	// EnableModelDragDest turns @icon_view into a drop destination for
	// automatic DND. Calling this method sets IconView:reorderable to false.
	EnableModelDragDest(formats *gdk.ContentFormats, actions gdk.DragAction)
	// EnableModelDragSource turns @icon_view into a drag source for automatic
	// DND. Calling this method sets IconView:reorderable to false.
	EnableModelDragSource(startButtonMask gdk.ModifierType, formats *gdk.ContentFormats, actions gdk.DragAction)
	// ActivateOnSingleClick gets the setting set by
	// gtk_icon_view_set_activate_on_single_click().
	ActivateOnSingleClick() bool
	// CellRect fills the bounding rectangle in widget coordinates for the cell
	// specified by @path and @cell. If @cell is nil the main cell area is used.
	//
	// This function is only valid if @icon_view is realized.
	CellRect(path *TreePath, cell CellRenderer) (gdk.Rectangle, bool)
	// ColumnSpacing returns the value of the ::column-spacing property.
	ColumnSpacing() int
	// Columns returns the value of the ::columns property.
	Columns() int
	// ItemColumn gets the column in which the item @path is currently
	// displayed. Column numbers start at 0.
	ItemColumn(path *TreePath) int
	// ItemPadding returns the value of the ::item-padding property.
	ItemPadding() int
	// ItemRow gets the row in which the item @path is currently displayed. Row
	// numbers start at 0.
	ItemRow(path *TreePath) int
	// ItemWidth returns the value of the ::item-width property.
	ItemWidth() int
	// Margin returns the value of the ::margin property.
	Margin() int
	// MarkupColumn returns the column with markup text for @icon_view.
	MarkupColumn() int
	// PixbufColumn returns the column with pixbufs for @icon_view.
	PixbufColumn() int
	// Reorderable retrieves whether the user can reorder the list via
	// drag-and-drop. See gtk_icon_view_set_reorderable().
	Reorderable() bool
	// RowSpacing returns the value of the ::row-spacing property.
	RowSpacing() int
	// Spacing returns the value of the ::spacing property.
	Spacing() int
	// TextColumn returns the column with text for @icon_view.
	TextColumn() int
	// TooltipColumn returns the column of @icon_view’s model which is being
	// used for displaying tooltips on @icon_view’s rows.
	TooltipColumn() int
	// VisibleRange sets @start_path and @end_path to be the first and last
	// visible path. Note that there may be invisible paths in between.
	//
	// Both paths should be freed with gtk_tree_path_free() after use.
	VisibleRange() (startPath *TreePath, endPath *TreePath, ok bool)
	// ItemActivated activates the item determined by @path.
	ItemActivated(path *TreePath)
	// PathIsSelected returns true if the icon pointed to by @path is currently
	// selected. If @path does not point to a valid location, false is returned.
	PathIsSelected(path *TreePath) bool
	// ScrollToPath moves the alignments of @icon_view to the position specified
	// by @path. @row_align determines where the row is placed, and @col_align
	// determines where @column is placed. Both are expected to be between 0.0
	// and 1.0. 0.0 means left/top alignment, 1.0 means right/bottom alignment,
	// 0.5 means center.
	//
	// If @use_align is false, then the alignment arguments are ignored, and the
	// tree does the minimum amount of work to scroll the item onto the screen.
	// This means that the item will be scrolled to the edge closest to its
	// current position. If the item is currently visible on the screen, nothing
	// is done.
	//
	// This function only works if the model is set, and @path is a valid row on
	// the model. If the model changes before the @icon_view is realized, the
	// centered path will be modified to reflect this change.
	ScrollToPath(path *TreePath, useAlign bool, rowAlign float32, colAlign float32)
	// SelectAll selects all the icons. @icon_view must has its selection mode
	// set to K_SELECTION_MULTIPLE.
	SelectAll()
	// SelectPath selects the row at @path.
	SelectPath(path *TreePath)
	// SelectedForeach calls a function for each selected icon. Note that the
	// model or selection cannot be modified from within this function.
	SelectedForeach(fn IconViewForeachFunc)
	// SetActivateOnSingleClick causes the IconView::item-activated signal to be
	// emitted on a single click instead of a double click.
	SetActivateOnSingleClick(single bool)
	// SetColumnSpacing sets the ::column-spacing property which specifies the
	// space which is inserted between the columns of the icon view.
	SetColumnSpacing(columnSpacing int)
	// SetColumns sets the ::columns property which determines in how many
	// columns the icons are arranged. If @columns is -1, the number of columns
	// will be chosen automatically to fill the available area.
	SetColumns(columns int)
	// SetCursor sets the current keyboard focus to be at @path, and selects it.
	// This is useful when you want to focus the user’s attention on a
	// particular item. If @cell is not nil, then focus is given to the cell
	// specified by it. Additionally, if @start_editing is true, then editing
	// should be started in the specified cell.
	//
	// This function is often followed by `gtk_widget_grab_focus (icon_view)` in
	// order to give keyboard focus to the widget. Please note that editing can
	// only happen when the widget is realized.
	SetCursor(path *TreePath, cell CellRenderer, startEditing bool)
	// SetDragDestItem sets the item that is highlighted for feedback.
	SetDragDestItem(path *TreePath, pos IconViewDropPosition)
	// SetItemOrientation sets the ::item-orientation property which determines
	// whether the labels are drawn beside the icons instead of below.
	SetItemOrientation(orientation Orientation)
	// SetItemPadding sets the IconView:item-padding property which specifies
	// the padding around each of the icon view’s items.
	SetItemPadding(itemPadding int)
	// SetItemWidth sets the ::item-width property which specifies the width to
	// use for each item. If it is set to -1, the icon view will automatically
	// determine a suitable item size.
	SetItemWidth(itemWidth int)
	// SetMargin sets the ::margin property which specifies the space which is
	// inserted at the top, bottom, left and right of the icon view.
	SetMargin(margin int)
	// SetMarkupColumn sets the column with markup information for @icon_view to
	// be @column. The markup column must be of type TYPE_STRING. If the markup
	// column is set to something, it overrides the text column set by
	// gtk_icon_view_set_text_column().
	SetMarkupColumn(column int)
	// SetModel sets the model for a IconView. If the @icon_view already has a
	// model set, it will remove it before setting the new model. If @model is
	// nil, then it will unset the old model.
	SetModel(model TreeModel)
	// SetPixbufColumn sets the column with pixbufs for @icon_view to be
	// @column. The pixbuf column must be of type K_TYPE_PIXBUF
	SetPixbufColumn(column int)
	// SetReorderable: this function is a convenience function to allow you to
	// reorder models that support the TreeDragSourceIface and the
	// TreeDragDestIface. Both TreeStore and ListStore support these. If
	// @reorderable is true, then the user can reorder the model by dragging and
	// dropping rows. The developer can listen to these changes by connecting to
	// the model's row_inserted and row_deleted signals. The reordering is
	// implemented by setting up the icon view as a drag source and destination.
	// Therefore, drag and drop can not be used in a reorderable view for any
	// other purpose.
	//
	// This function does not give you any degree of control over the order --
	// any reordering is allowed. If more control is needed, you should probably
	// handle drag and drop manually.
	SetReorderable(reorderable bool)
	// SetRowSpacing sets the ::row-spacing property which specifies the space
	// which is inserted between the rows of the icon view.
	SetRowSpacing(rowSpacing int)
	// SetSelectionMode sets the selection mode of the @icon_view.
	SetSelectionMode(mode SelectionMode)
	// SetSpacing sets the ::spacing property which specifies the space which is
	// inserted between the cells (i.e. the icon and the text) of an item.
	SetSpacing(spacing int)
	// SetTextColumn sets the column with text for @icon_view to be @column. The
	// text column must be of type TYPE_STRING.
	SetTextColumn(column int)
	// SetTooltipCell sets the tip area of @tooltip to the area which @cell
	// occupies in the item pointed to by @path. See also
	// gtk_tooltip_set_tip_area().
	//
	// See also gtk_icon_view_set_tooltip_column() for a simpler alternative.
	SetTooltipCell(tooltip Tooltip, path *TreePath, cell CellRenderer)
	// SetTooltipColumn: if you only plan to have simple (text-only) tooltips on
	// full items, you can use this function to have IconView handle these
	// automatically for you. @column should be set to the column in
	// @icon_view’s model containing the tooltip texts, or -1 to disable this
	// feature.
	//
	// When enabled, Widget:has-tooltip will be set to true and @icon_view will
	// connect a Widget::query-tooltip signal handler.
	//
	// Note that the signal handler sets the text with gtk_tooltip_set_markup(),
	// so &, <, etc have to be escaped in the text.
	SetTooltipColumn(column int)
	// SetTooltipItem sets the tip area of @tooltip to be the area covered by
	// the item at @path. See also gtk_icon_view_set_tooltip_column() for a
	// simpler alternative. See also gtk_tooltip_set_tip_area().
	SetTooltipItem(tooltip Tooltip, path *TreePath)
	// UnselectAll unselects all the icons.
	UnselectAll()
	// UnselectPath unselects the row at @path.
	UnselectPath(path *TreePath)
	// UnsetModelDragDest undoes the effect of
	// gtk_icon_view_enable_model_drag_dest(). Calling this method sets
	// IconView:reorderable to false.
	UnsetModelDragDest()
	// UnsetModelDragSource undoes the effect of
	// gtk_icon_view_enable_model_drag_source(). Calling this method sets
	// IconView:reorderable to false.
	UnsetModelDragSource()
}

// iconView implements the IconView interface.
type iconView struct {
	Widget
	Accessible
	Buildable
	CellLayout
	ConstraintTarget
	Scrollable
}

var _ IconView = (*iconView)(nil)

// WrapIconView wraps a GObject to the right type. It is
// primarily used internally.
func WrapIconView(obj *externglib.Object) IconView {
	return IconView{
		Widget:           WrapWidget(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		CellLayout:       WrapCellLayout(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
		Scrollable:       WrapScrollable(obj),
	}
}

func marshalIconView(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapIconView(obj), nil
}

// EnableModelDragDest turns @icon_view into a drop destination for
// automatic DND. Calling this method sets IconView:reorderable to false.
func (i iconView) EnableModelDragDest(formats *gdk.ContentFormats, actions gdk.DragAction) {
	var _arg0 *C.GtkIconView
	var _arg1 *C.GdkContentFormats
	var _arg2 C.GdkDragAction

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GdkContentFormats)(unsafe.Pointer(formats.Native()))
	_arg2 = (C.GdkDragAction)(actions)

	C.gtk_icon_view_enable_model_drag_dest(_arg0, _arg1, _arg2)
}

// EnableModelDragSource turns @icon_view into a drag source for automatic
// DND. Calling this method sets IconView:reorderable to false.
func (i iconView) EnableModelDragSource(startButtonMask gdk.ModifierType, formats *gdk.ContentFormats, actions gdk.DragAction) {
	var _arg0 *C.GtkIconView
	var _arg1 C.GdkModifierType
	var _arg2 *C.GdkContentFormats
	var _arg3 C.GdkDragAction

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = (C.GdkModifierType)(startButtonMask)
	_arg2 = (*C.GdkContentFormats)(unsafe.Pointer(formats.Native()))
	_arg3 = (C.GdkDragAction)(actions)

	C.gtk_icon_view_enable_model_drag_source(_arg0, _arg1, _arg2, _arg3)
}

// ActivateOnSingleClick gets the setting set by
// gtk_icon_view_set_activate_on_single_click().
func (i iconView) ActivateOnSingleClick() bool {
	var _arg0 *C.GtkIconView

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	var _cret C.gboolean

	_cret = C.gtk_icon_view_get_activate_on_single_click(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// CellRect fills the bounding rectangle in widget coordinates for the cell
// specified by @path and @cell. If @cell is nil the main cell area is used.
//
// This function is only valid if @icon_view is realized.
func (i iconView) CellRect(path *TreePath, cell CellRenderer) (gdk.Rectangle, bool) {
	var _arg0 *C.GtkIconView
	var _arg1 *C.GtkTreePath
	var _arg2 *C.GtkCellRenderer

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
	_arg2 = (*C.GtkCellRenderer)(unsafe.Pointer(cell.Native()))

	var _rect gdk.Rectangle
	var _cret C.gboolean

	_cret = C.gtk_icon_view_get_cell_rect(_arg0, _arg1, _arg2, (*C.GdkRectangle)(unsafe.Pointer(&_rect)))

	var _ok bool

	if _cret {
		_ok = true
	}

	return _rect, _ok
}

// ColumnSpacing returns the value of the ::column-spacing property.
func (i iconView) ColumnSpacing() int {
	var _arg0 *C.GtkIconView

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	var _cret C.int

	_cret = C.gtk_icon_view_get_column_spacing(_arg0)

	var _gint int

	_gint = (int)(_cret)

	return _gint
}

// Columns returns the value of the ::columns property.
func (i iconView) Columns() int {
	var _arg0 *C.GtkIconView

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	var _cret C.int

	_cret = C.gtk_icon_view_get_columns(_arg0)

	var _gint int

	_gint = (int)(_cret)

	return _gint
}

// ItemColumn gets the column in which the item @path is currently
// displayed. Column numbers start at 0.
func (i iconView) ItemColumn(path *TreePath) int {
	var _arg0 *C.GtkIconView
	var _arg1 *C.GtkTreePath

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	var _cret C.int

	_cret = C.gtk_icon_view_get_item_column(_arg0, _arg1)

	var _gint int

	_gint = (int)(_cret)

	return _gint
}

// ItemPadding returns the value of the ::item-padding property.
func (i iconView) ItemPadding() int {
	var _arg0 *C.GtkIconView

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	var _cret C.int

	_cret = C.gtk_icon_view_get_item_padding(_arg0)

	var _gint int

	_gint = (int)(_cret)

	return _gint
}

// ItemRow gets the row in which the item @path is currently displayed. Row
// numbers start at 0.
func (i iconView) ItemRow(path *TreePath) int {
	var _arg0 *C.GtkIconView
	var _arg1 *C.GtkTreePath

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	var _cret C.int

	_cret = C.gtk_icon_view_get_item_row(_arg0, _arg1)

	var _gint int

	_gint = (int)(_cret)

	return _gint
}

// ItemWidth returns the value of the ::item-width property.
func (i iconView) ItemWidth() int {
	var _arg0 *C.GtkIconView

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	var _cret C.int

	_cret = C.gtk_icon_view_get_item_width(_arg0)

	var _gint int

	_gint = (int)(_cret)

	return _gint
}

// Margin returns the value of the ::margin property.
func (i iconView) Margin() int {
	var _arg0 *C.GtkIconView

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	var _cret C.int

	_cret = C.gtk_icon_view_get_margin(_arg0)

	var _gint int

	_gint = (int)(_cret)

	return _gint
}

// MarkupColumn returns the column with markup text for @icon_view.
func (i iconView) MarkupColumn() int {
	var _arg0 *C.GtkIconView

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	var _cret C.int

	_cret = C.gtk_icon_view_get_markup_column(_arg0)

	var _gint int

	_gint = (int)(_cret)

	return _gint
}

// PixbufColumn returns the column with pixbufs for @icon_view.
func (i iconView) PixbufColumn() int {
	var _arg0 *C.GtkIconView

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	var _cret C.int

	_cret = C.gtk_icon_view_get_pixbuf_column(_arg0)

	var _gint int

	_gint = (int)(_cret)

	return _gint
}

// Reorderable retrieves whether the user can reorder the list via
// drag-and-drop. See gtk_icon_view_set_reorderable().
func (i iconView) Reorderable() bool {
	var _arg0 *C.GtkIconView

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	var _cret C.gboolean

	_cret = C.gtk_icon_view_get_reorderable(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// RowSpacing returns the value of the ::row-spacing property.
func (i iconView) RowSpacing() int {
	var _arg0 *C.GtkIconView

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	var _cret C.int

	_cret = C.gtk_icon_view_get_row_spacing(_arg0)

	var _gint int

	_gint = (int)(_cret)

	return _gint
}

// Spacing returns the value of the ::spacing property.
func (i iconView) Spacing() int {
	var _arg0 *C.GtkIconView

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	var _cret C.int

	_cret = C.gtk_icon_view_get_spacing(_arg0)

	var _gint int

	_gint = (int)(_cret)

	return _gint
}

// TextColumn returns the column with text for @icon_view.
func (i iconView) TextColumn() int {
	var _arg0 *C.GtkIconView

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	var _cret C.int

	_cret = C.gtk_icon_view_get_text_column(_arg0)

	var _gint int

	_gint = (int)(_cret)

	return _gint
}

// TooltipColumn returns the column of @icon_view’s model which is being
// used for displaying tooltips on @icon_view’s rows.
func (i iconView) TooltipColumn() int {
	var _arg0 *C.GtkIconView

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	var _cret C.int

	_cret = C.gtk_icon_view_get_tooltip_column(_arg0)

	var _gint int

	_gint = (int)(_cret)

	return _gint
}

// VisibleRange sets @start_path and @end_path to be the first and last
// visible path. Note that there may be invisible paths in between.
//
// Both paths should be freed with gtk_tree_path_free() after use.
func (i iconView) VisibleRange() (startPath *TreePath, endPath *TreePath, ok bool) {
	var _arg0 *C.GtkIconView

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	var _startPath *TreePath
	var _endPath *TreePath
	var _cret C.gboolean

	_cret = C.gtk_icon_view_get_visible_range(_arg0, (**C.GtkTreePath)(unsafe.Pointer(&_startPath)), (**C.GtkTreePath)(unsafe.Pointer(&_endPath)))

	var _ok bool

	if _cret {
		_ok = true
	}

	return _startPath, _endPath, _ok
}

// ItemActivated activates the item determined by @path.
func (i iconView) ItemActivated(path *TreePath) {
	var _arg0 *C.GtkIconView
	var _arg1 *C.GtkTreePath

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	C.gtk_icon_view_item_activated(_arg0, _arg1)
}

// PathIsSelected returns true if the icon pointed to by @path is currently
// selected. If @path does not point to a valid location, false is returned.
func (i iconView) PathIsSelected(path *TreePath) bool {
	var _arg0 *C.GtkIconView
	var _arg1 *C.GtkTreePath

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	var _cret C.gboolean

	_cret = C.gtk_icon_view_path_is_selected(_arg0, _arg1)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// ScrollToPath moves the alignments of @icon_view to the position specified
// by @path. @row_align determines where the row is placed, and @col_align
// determines where @column is placed. Both are expected to be between 0.0
// and 1.0. 0.0 means left/top alignment, 1.0 means right/bottom alignment,
// 0.5 means center.
//
// If @use_align is false, then the alignment arguments are ignored, and the
// tree does the minimum amount of work to scroll the item onto the screen.
// This means that the item will be scrolled to the edge closest to its
// current position. If the item is currently visible on the screen, nothing
// is done.
//
// This function only works if the model is set, and @path is a valid row on
// the model. If the model changes before the @icon_view is realized, the
// centered path will be modified to reflect this change.
func (i iconView) ScrollToPath(path *TreePath, useAlign bool, rowAlign float32, colAlign float32) {
	var _arg0 *C.GtkIconView
	var _arg1 *C.GtkTreePath
	var _arg2 C.gboolean
	var _arg3 C.float
	var _arg4 C.float

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
	if useAlign {
		_arg2 = C.gboolean(1)
	}
	_arg3 = C.float(rowAlign)
	_arg4 = C.float(colAlign)

	C.gtk_icon_view_scroll_to_path(_arg0, _arg1, _arg2, _arg3, _arg4)
}

// SelectAll selects all the icons. @icon_view must has its selection mode
// set to K_SELECTION_MULTIPLE.
func (i iconView) SelectAll() {
	var _arg0 *C.GtkIconView

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	C.gtk_icon_view_select_all(_arg0)
}

// SelectPath selects the row at @path.
func (i iconView) SelectPath(path *TreePath) {
	var _arg0 *C.GtkIconView
	var _arg1 *C.GtkTreePath

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	C.gtk_icon_view_select_path(_arg0, _arg1)
}

// SelectedForeach calls a function for each selected icon. Note that the
// model or selection cannot be modified from within this function.
func (i iconView) SelectedForeach(fn IconViewForeachFunc) {
	var _arg0 *C.GtkIconView
	var _arg1 C.GtkIconViewForeachFunc
	var _arg2 C.gpointer

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = (*[0]byte)(C.gotk4_IconViewForeachFunc)
	_arg2 = C.gpointer(box.Assign(fn))

	C.gtk_icon_view_selected_foreach(_arg0, _arg1, _arg2)
}

// SetActivateOnSingleClick causes the IconView::item-activated signal to be
// emitted on a single click instead of a double click.
func (i iconView) SetActivateOnSingleClick(single bool) {
	var _arg0 *C.GtkIconView
	var _arg1 C.gboolean

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	if single {
		_arg1 = C.gboolean(1)
	}

	C.gtk_icon_view_set_activate_on_single_click(_arg0, _arg1)
}

// SetColumnSpacing sets the ::column-spacing property which specifies the
// space which is inserted between the columns of the icon view.
func (i iconView) SetColumnSpacing(columnSpacing int) {
	var _arg0 *C.GtkIconView
	var _arg1 C.int

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = C.int(columnSpacing)

	C.gtk_icon_view_set_column_spacing(_arg0, _arg1)
}

// SetColumns sets the ::columns property which determines in how many
// columns the icons are arranged. If @columns is -1, the number of columns
// will be chosen automatically to fill the available area.
func (i iconView) SetColumns(columns int) {
	var _arg0 *C.GtkIconView
	var _arg1 C.int

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = C.int(columns)

	C.gtk_icon_view_set_columns(_arg0, _arg1)
}

// SetCursor sets the current keyboard focus to be at @path, and selects it.
// This is useful when you want to focus the user’s attention on a
// particular item. If @cell is not nil, then focus is given to the cell
// specified by it. Additionally, if @start_editing is true, then editing
// should be started in the specified cell.
//
// This function is often followed by `gtk_widget_grab_focus (icon_view)` in
// order to give keyboard focus to the widget. Please note that editing can
// only happen when the widget is realized.
func (i iconView) SetCursor(path *TreePath, cell CellRenderer, startEditing bool) {
	var _arg0 *C.GtkIconView
	var _arg1 *C.GtkTreePath
	var _arg2 *C.GtkCellRenderer
	var _arg3 C.gboolean

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
	_arg2 = (*C.GtkCellRenderer)(unsafe.Pointer(cell.Native()))
	if startEditing {
		_arg3 = C.gboolean(1)
	}

	C.gtk_icon_view_set_cursor(_arg0, _arg1, _arg2, _arg3)
}

// SetDragDestItem sets the item that is highlighted for feedback.
func (i iconView) SetDragDestItem(path *TreePath, pos IconViewDropPosition) {
	var _arg0 *C.GtkIconView
	var _arg1 *C.GtkTreePath
	var _arg2 C.GtkIconViewDropPosition

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
	_arg2 = (C.GtkIconViewDropPosition)(pos)

	C.gtk_icon_view_set_drag_dest_item(_arg0, _arg1, _arg2)
}

// SetItemOrientation sets the ::item-orientation property which determines
// whether the labels are drawn beside the icons instead of below.
func (i iconView) SetItemOrientation(orientation Orientation) {
	var _arg0 *C.GtkIconView
	var _arg1 C.GtkOrientation

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = (C.GtkOrientation)(orientation)

	C.gtk_icon_view_set_item_orientation(_arg0, _arg1)
}

// SetItemPadding sets the IconView:item-padding property which specifies
// the padding around each of the icon view’s items.
func (i iconView) SetItemPadding(itemPadding int) {
	var _arg0 *C.GtkIconView
	var _arg1 C.int

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = C.int(itemPadding)

	C.gtk_icon_view_set_item_padding(_arg0, _arg1)
}

// SetItemWidth sets the ::item-width property which specifies the width to
// use for each item. If it is set to -1, the icon view will automatically
// determine a suitable item size.
func (i iconView) SetItemWidth(itemWidth int) {
	var _arg0 *C.GtkIconView
	var _arg1 C.int

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = C.int(itemWidth)

	C.gtk_icon_view_set_item_width(_arg0, _arg1)
}

// SetMargin sets the ::margin property which specifies the space which is
// inserted at the top, bottom, left and right of the icon view.
func (i iconView) SetMargin(margin int) {
	var _arg0 *C.GtkIconView
	var _arg1 C.int

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = C.int(margin)

	C.gtk_icon_view_set_margin(_arg0, _arg1)
}

// SetMarkupColumn sets the column with markup information for @icon_view to
// be @column. The markup column must be of type TYPE_STRING. If the markup
// column is set to something, it overrides the text column set by
// gtk_icon_view_set_text_column().
func (i iconView) SetMarkupColumn(column int) {
	var _arg0 *C.GtkIconView
	var _arg1 C.int

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = C.int(column)

	C.gtk_icon_view_set_markup_column(_arg0, _arg1)
}

// SetModel sets the model for a IconView. If the @icon_view already has a
// model set, it will remove it before setting the new model. If @model is
// nil, then it will unset the old model.
func (i iconView) SetModel(model TreeModel) {
	var _arg0 *C.GtkIconView
	var _arg1 *C.GtkTreeModel

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GtkTreeModel)(unsafe.Pointer(model.Native()))

	C.gtk_icon_view_set_model(_arg0, _arg1)
}

// SetPixbufColumn sets the column with pixbufs for @icon_view to be
// @column. The pixbuf column must be of type K_TYPE_PIXBUF
func (i iconView) SetPixbufColumn(column int) {
	var _arg0 *C.GtkIconView
	var _arg1 C.int

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = C.int(column)

	C.gtk_icon_view_set_pixbuf_column(_arg0, _arg1)
}

// SetReorderable: this function is a convenience function to allow you to
// reorder models that support the TreeDragSourceIface and the
// TreeDragDestIface. Both TreeStore and ListStore support these. If
// @reorderable is true, then the user can reorder the model by dragging and
// dropping rows. The developer can listen to these changes by connecting to
// the model's row_inserted and row_deleted signals. The reordering is
// implemented by setting up the icon view as a drag source and destination.
// Therefore, drag and drop can not be used in a reorderable view for any
// other purpose.
//
// This function does not give you any degree of control over the order --
// any reordering is allowed. If more control is needed, you should probably
// handle drag and drop manually.
func (i iconView) SetReorderable(reorderable bool) {
	var _arg0 *C.GtkIconView
	var _arg1 C.gboolean

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	if reorderable {
		_arg1 = C.gboolean(1)
	}

	C.gtk_icon_view_set_reorderable(_arg0, _arg1)
}

// SetRowSpacing sets the ::row-spacing property which specifies the space
// which is inserted between the rows of the icon view.
func (i iconView) SetRowSpacing(rowSpacing int) {
	var _arg0 *C.GtkIconView
	var _arg1 C.int

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = C.int(rowSpacing)

	C.gtk_icon_view_set_row_spacing(_arg0, _arg1)
}

// SetSelectionMode sets the selection mode of the @icon_view.
func (i iconView) SetSelectionMode(mode SelectionMode) {
	var _arg0 *C.GtkIconView
	var _arg1 C.GtkSelectionMode

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = (C.GtkSelectionMode)(mode)

	C.gtk_icon_view_set_selection_mode(_arg0, _arg1)
}

// SetSpacing sets the ::spacing property which specifies the space which is
// inserted between the cells (i.e. the icon and the text) of an item.
func (i iconView) SetSpacing(spacing int) {
	var _arg0 *C.GtkIconView
	var _arg1 C.int

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = C.int(spacing)

	C.gtk_icon_view_set_spacing(_arg0, _arg1)
}

// SetTextColumn sets the column with text for @icon_view to be @column. The
// text column must be of type TYPE_STRING.
func (i iconView) SetTextColumn(column int) {
	var _arg0 *C.GtkIconView
	var _arg1 C.int

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = C.int(column)

	C.gtk_icon_view_set_text_column(_arg0, _arg1)
}

// SetTooltipCell sets the tip area of @tooltip to the area which @cell
// occupies in the item pointed to by @path. See also
// gtk_tooltip_set_tip_area().
//
// See also gtk_icon_view_set_tooltip_column() for a simpler alternative.
func (i iconView) SetTooltipCell(tooltip Tooltip, path *TreePath, cell CellRenderer) {
	var _arg0 *C.GtkIconView
	var _arg1 *C.GtkTooltip
	var _arg2 *C.GtkTreePath
	var _arg3 *C.GtkCellRenderer

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GtkTooltip)(unsafe.Pointer(tooltip.Native()))
	_arg2 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
	_arg3 = (*C.GtkCellRenderer)(unsafe.Pointer(cell.Native()))

	C.gtk_icon_view_set_tooltip_cell(_arg0, _arg1, _arg2, _arg3)
}

// SetTooltipColumn: if you only plan to have simple (text-only) tooltips on
// full items, you can use this function to have IconView handle these
// automatically for you. @column should be set to the column in
// @icon_view’s model containing the tooltip texts, or -1 to disable this
// feature.
//
// When enabled, Widget:has-tooltip will be set to true and @icon_view will
// connect a Widget::query-tooltip signal handler.
//
// Note that the signal handler sets the text with gtk_tooltip_set_markup(),
// so &, <, etc have to be escaped in the text.
func (i iconView) SetTooltipColumn(column int) {
	var _arg0 *C.GtkIconView
	var _arg1 C.int

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = C.int(column)

	C.gtk_icon_view_set_tooltip_column(_arg0, _arg1)
}

// SetTooltipItem sets the tip area of @tooltip to be the area covered by
// the item at @path. See also gtk_icon_view_set_tooltip_column() for a
// simpler alternative. See also gtk_tooltip_set_tip_area().
func (i iconView) SetTooltipItem(tooltip Tooltip, path *TreePath) {
	var _arg0 *C.GtkIconView
	var _arg1 *C.GtkTooltip
	var _arg2 *C.GtkTreePath

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GtkTooltip)(unsafe.Pointer(tooltip.Native()))
	_arg2 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	C.gtk_icon_view_set_tooltip_item(_arg0, _arg1, _arg2)
}

// UnselectAll unselects all the icons.
func (i iconView) UnselectAll() {
	var _arg0 *C.GtkIconView

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	C.gtk_icon_view_unselect_all(_arg0)
}

// UnselectPath unselects the row at @path.
func (i iconView) UnselectPath(path *TreePath) {
	var _arg0 *C.GtkIconView
	var _arg1 *C.GtkTreePath

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	C.gtk_icon_view_unselect_path(_arg0, _arg1)
}

// UnsetModelDragDest undoes the effect of
// gtk_icon_view_enable_model_drag_dest(). Calling this method sets
// IconView:reorderable to false.
func (i iconView) UnsetModelDragDest() {
	var _arg0 *C.GtkIconView

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	C.gtk_icon_view_unset_model_drag_dest(_arg0)
}

// UnsetModelDragSource undoes the effect of
// gtk_icon_view_enable_model_drag_source(). Calling this method sets
// IconView:reorderable to false.
func (i iconView) UnsetModelDragSource() {
	var _arg0 *C.GtkIconView

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	C.gtk_icon_view_unset_model_drag_source(_arg0)
}

// Image: the `GtkImage` widget displays an image.
//
// !An example GtkImage (image.png)
//
// Various kinds of object can be displayed as an image; most typically, you
// would load a `GdkTexture` from a file, using the convenience function
// [ctor@Gtk.Image.new_from_file], for instance:
//
// “`c GtkWidget *image = gtk_image_new_from_file ("myfile.png"); “`
//
// If the file isn’t loaded successfully, the image will contain a “broken
// image” icon similar to that used in many web browsers.
//
// If you want to handle errors in loading the file yourself, for example by
// displaying an error message, then load the image with
// [ctor@Gdk.Texture.new_from_file], then create the `GtkImage` with
// [ctor@Gtk.Image.new_from_paintable].
//
// Sometimes an application will want to avoid depending on external data files,
// such as image files. See the documentation of `GResource` inside GIO, for
// details. In this case, [property@Gtk.Image:resource],
// [ctor@Gtk.Image.new_from_resource], and [method@Gtk.Image.set_from_resource]
// should be used.
//
// `GtkImage` displays its image as an icon, with a size that is determined by
// the application. See [class@Gtk.Picture] if you want to show an image at is
// actual size.
//
//
// CSS nodes
//
// `GtkImage` has a single CSS node with the name `image`. The style classes
// `.normal-icons` or `.large-icons` may appear, depending on the
// [property@Gtk.Image:icon-size] property.
//
//
// Accessibility
//
// `GtkImage` uses the `GTK_ACCESSIBLE_ROLE_IMG` role.
type Image interface {
	Widget
	Accessible
	Buildable
	ConstraintTarget

	// Clear resets the image to be empty.
	Clear()
	// IconName gets the icon name and size being displayed by the `GtkImage`.
	//
	// The storage type of the image must be GTK_IMAGE_EMPTY or
	// GTK_IMAGE_ICON_NAME (see [method@Gtk.Image.get_storage_type]). The
	// returned string is owned by the `GtkImage` and should not be freed.
	IconName() string
	// PixelSize gets the pixel size used for named icons.
	PixelSize() int
	// SetFromFile sets a `GtkImage` to show a file.
	//
	// See [ctor@Gtk.Image.new_from_file] for details.
	SetFromFile(filename *string)
	// SetFromGIcon sets a `GtkImage` to show a `GIcon`.
	//
	// See [ctor@Gtk.Image.new_from_gicon] for details.
	SetFromGIcon(icon gio.Icon)
	// SetFromIconName sets a `GtkImage` to show a named icon.
	//
	// See [ctor@Gtk.Image.new_from_icon_name] for details.
	SetFromIconName(iconName string)
	// SetFromPaintable sets a `GtkImage` to show a `GdkPaintable`.
	//
	// See [ctor@Gtk.Image.new_from_paintable] for details.
	SetFromPaintable(paintable gdk.Paintable)
	// SetFromPixbuf sets a `GtkImage` to show a `GdkPixbuf`.
	//
	// See [ctor@Gtk.Image.new_from_pixbuf] for details.
	//
	// Note: This is a helper for [method@Gtk.Image.set_from_paintable], and you
	// can't get back the exact pixbuf once this is called, only a paintable.
	SetFromPixbuf(pixbuf gdkpixbuf.Pixbuf)
	// SetFromResource sets a `GtkImage` to show a resource.
	//
	// See [ctor@Gtk.Image.new_from_resource] for details.
	SetFromResource(resourcePath string)
	// SetIconSize suggests an icon size to the theme for named icons.
	SetIconSize(iconSize IconSize)
	// SetPixelSize sets the pixel size to use for named icons.
	//
	// If the pixel size is set to a value != -1, it is used instead of the icon
	// size set by [method@Gtk.Image.set_from_icon_name].
	SetPixelSize(pixelSize int)
}

// image implements the Image interface.
type image struct {
	Widget
	Accessible
	Buildable
	ConstraintTarget
}

var _ Image = (*image)(nil)

// WrapImage wraps a GObject to the right type. It is
// primarily used internally.
func WrapImage(obj *externglib.Object) Image {
	return Image{
		Widget:           WrapWidget(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
	}
}

func marshalImage(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapImage(obj), nil
}

// Clear resets the image to be empty.
func (i image) Clear() {
	var _arg0 *C.GtkImage

	_arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))

	C.gtk_image_clear(_arg0)
}

// IconName gets the icon name and size being displayed by the `GtkImage`.
//
// The storage type of the image must be GTK_IMAGE_EMPTY or
// GTK_IMAGE_ICON_NAME (see [method@Gtk.Image.get_storage_type]). The
// returned string is owned by the `GtkImage` and should not be freed.
func (i image) IconName() string {
	var _arg0 *C.GtkImage

	_arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))

	var _cret *C.char

	_cret = C.gtk_image_get_icon_name(_arg0)

	var _utf8 string

	_utf8 = C.GoString(_cret)

	return _utf8
}

// PixelSize gets the pixel size used for named icons.
func (i image) PixelSize() int {
	var _arg0 *C.GtkImage

	_arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))

	var _cret C.int

	_cret = C.gtk_image_get_pixel_size(_arg0)

	var _gint int

	_gint = (int)(_cret)

	return _gint
}

// SetFromFile sets a `GtkImage` to show a file.
//
// See [ctor@Gtk.Image.new_from_file] for details.
func (i image) SetFromFile(filename *string) {
	var _arg0 *C.GtkImage
	var _arg1 *C.char

	_arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.char)(C.CString(filename))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_image_set_from_file(_arg0, _arg1)
}

// SetFromGIcon sets a `GtkImage` to show a `GIcon`.
//
// See [ctor@Gtk.Image.new_from_gicon] for details.
func (i image) SetFromGIcon(icon gio.Icon) {
	var _arg0 *C.GtkImage
	var _arg1 *C.GIcon

	_arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GIcon)(unsafe.Pointer(icon.Native()))

	C.gtk_image_set_from_gicon(_arg0, _arg1)
}

// SetFromIconName sets a `GtkImage` to show a named icon.
//
// See [ctor@Gtk.Image.new_from_icon_name] for details.
func (i image) SetFromIconName(iconName string) {
	var _arg0 *C.GtkImage
	var _arg1 *C.char

	_arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.char)(C.CString(iconName))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_image_set_from_icon_name(_arg0, _arg1)
}

// SetFromPaintable sets a `GtkImage` to show a `GdkPaintable`.
//
// See [ctor@Gtk.Image.new_from_paintable] for details.
func (i image) SetFromPaintable(paintable gdk.Paintable) {
	var _arg0 *C.GtkImage
	var _arg1 *C.GdkPaintable

	_arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GdkPaintable)(unsafe.Pointer(paintable.Native()))

	C.gtk_image_set_from_paintable(_arg0, _arg1)
}

// SetFromPixbuf sets a `GtkImage` to show a `GdkPixbuf`.
//
// See [ctor@Gtk.Image.new_from_pixbuf] for details.
//
// Note: This is a helper for [method@Gtk.Image.set_from_paintable], and you
// can't get back the exact pixbuf once this is called, only a paintable.
func (i image) SetFromPixbuf(pixbuf gdkpixbuf.Pixbuf) {
	var _arg0 *C.GtkImage
	var _arg1 *C.GdkPixbuf

	_arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))

	C.gtk_image_set_from_pixbuf(_arg0, _arg1)
}

// SetFromResource sets a `GtkImage` to show a resource.
//
// See [ctor@Gtk.Image.new_from_resource] for details.
func (i image) SetFromResource(resourcePath string) {
	var _arg0 *C.GtkImage
	var _arg1 *C.char

	_arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.char)(C.CString(resourcePath))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_image_set_from_resource(_arg0, _arg1)
}

// SetIconSize suggests an icon size to the theme for named icons.
func (i image) SetIconSize(iconSize IconSize) {
	var _arg0 *C.GtkImage
	var _arg1 C.GtkIconSize

	_arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))
	_arg1 = (C.GtkIconSize)(iconSize)

	C.gtk_image_set_icon_size(_arg0, _arg1)
}

// SetPixelSize sets the pixel size to use for named icons.
//
// If the pixel size is set to a value != -1, it is used instead of the icon
// size set by [method@Gtk.Image.set_from_icon_name].
func (i image) SetPixelSize(pixelSize int) {
	var _arg0 *C.GtkImage
	var _arg1 C.int

	_arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))
	_arg1 = C.int(pixelSize)

	C.gtk_image_set_pixel_size(_arg0, _arg1)
}

// InfoBar: `GtkInfoBar` can be show messages to the user without a dialog.
//
// !An example GtkInfoBar (info-bar.png)
//
// It is often temporarily shown at the top or bottom of a document. In contrast
// to [class@Gtk.Dialog], which has an action area at the bottom, `GtkInfoBar`
// has an action area at the side.
//
// The API of `GtkInfoBar` is very similar to `GtkDialog`, allowing you to add
// buttons to the action area with [method@Gtk.InfoBar.add_button] or
// [ctor@Gtk.InfoBar.new_with_buttons]. The sensitivity of action widgets can be
// controlled with [method@Gtk.InfoBar.set_response_sensitive].
//
// To add widgets to the main content area of a `GtkInfoBar`, use
// [method@Gtk.InfoBar.add_child].
//
// Similar to [class@Gtk.MessageDialog], the contents of a `GtkInfoBar` can by
// classified as error message, warning, informational message, etc, by using
// [method@Gtk.InfoBar.set_message_type]. GTK may use the message type to
// determine how the message is displayed.
//
// A simple example for using a `GtkInfoBar`: “`c GtkWidget *message_label;
// GtkWidget *widget; GtkWidget *grid; GtkInfoBar *bar;
//
// // set up info bar widget = gtk_info_bar_new (); bar = GTK_INFO_BAR (widget);
// // grid = gtk_grid_new ();
//
// message_label = gtk_label_new (""); gtk_info_bar_add_child (bar,
// message_label); gtk_info_bar_add_button (bar, _("_OK"), GTK_RESPONSE_OK);
// g_signal_connect (bar, "response", G_CALLBACK (gtk_widget_hide), NULL);
// gtk_grid_attach (GTK_GRID (grid), widget, 0, 2, 1, 1);
//
// // ...
//
// // show an error message gtk_label_set_text (GTK_LABEL (message_label), "An
// // error occurred!"); gtk_info_bar_set_message_type (bar, GTK_MESSAGE_ERROR);
// // gtk_widget_show (bar); “`
//
//
// GtkInfoBar as GtkBuildable
//
// The `GtkInfoBar` implementation of the `GtkBuildable` interface exposes the
// content area and action area as internal children with the names
// “content_area” and “action_area”.
//
// `GtkInfoBar` supports a custom <action-widgets> element, which can contain
// multiple <action-widget> elements. The “response” attribute specifies a
// numeric response, and the content of the element is the id of widget (which
// should be a child of the dialogs @action_area).
//
//
// CSS nodes
//
// `GtkInfoBar` has a single CSS node with name infobar. The node may get one of
// the style classes .info, .warning, .error or .question, depending on the
// message type. If the info bar shows a close button, that button will have the
// .close style class applied.
type InfoBar interface {
	Widget
	Accessible
	Buildable
	ConstraintTarget

	// AddActionWidget: add an activatable widget to the action area of a
	// `GtkInfoBar`.
	//
	// This also connects a signal handler that will emit the
	// [signal@Gtk.InfoBar::response] signal on the message area when the widget
	// is activated. The widget is appended to the end of the message areas
	// action area.
	AddActionWidget(child Widget, responseId int)
	// AddChild adds a widget to the content area of the info bar.
	AddChild(widget Widget)
	// Revealed returns whether the info bar is currently revealed.
	Revealed() bool
	// ShowCloseButton returns whether the widget will display a standard close
	// button.
	ShowCloseButton() bool
	// RemoveActionWidget removes a widget from the action area of @info_bar.
	//
	// The widget must have been put there by a call to
	// [method@Gtk.InfoBar.add_action_widget] or
	// [method@Gtk.InfoBar.add_button].
	RemoveActionWidget(widget Widget)
	// RemoveChild removes a widget from the content area of the info bar.
	RemoveChild(widget Widget)
	// Response emits the “response” signal with the given @response_id.
	Response(responseId int)
	// SetDefaultResponse sets the last widget in the info bar’s action area
	// with the given response_id as the default widget for the dialog.
	//
	// Pressing “Enter” normally activates the default widget.
	//
	// Note that this function currently requires @info_bar to be added to a
	// widget hierarchy.
	SetDefaultResponse(responseId int)
	// SetMessageType sets the message type of the message area.
	//
	// GTK uses this type to determine how the message is displayed.
	SetMessageType(messageType MessageType)
	// SetResponseSensitive sets the sensitivity of action widgets for
	// @response_id.
	//
	// Calls `gtk_widget_set_sensitive (widget, setting)` for each widget in the
	// info bars’s action area with the given @response_id. A convenient way to
	// sensitize/desensitize buttons.
	SetResponseSensitive(responseId int, setting bool)
	// SetRevealed sets whether the `GtkInfoBar` is revealed.
	//
	// Changing this will make @info_bar reveal or conceal itself via a sliding
	// transition.
	//
	// Note: this does not show or hide @info_bar in the
	// [property@Gtk.Widget:visible] sense, so revealing has no effect if
	// [property@Gtk.Widget:visible] is false.
	SetRevealed(revealed bool)
	// SetShowCloseButton: if true, a standard close button is shown.
	//
	// When clicked it emits the response GTK_RESPONSE_CLOSE.
	SetShowCloseButton(setting bool)
}

// infoBar implements the InfoBar interface.
type infoBar struct {
	Widget
	Accessible
	Buildable
	ConstraintTarget
}

var _ InfoBar = (*infoBar)(nil)

// WrapInfoBar wraps a GObject to the right type. It is
// primarily used internally.
func WrapInfoBar(obj *externglib.Object) InfoBar {
	return InfoBar{
		Widget:           WrapWidget(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
	}
}

func marshalInfoBar(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapInfoBar(obj), nil
}

// AddActionWidget: add an activatable widget to the action area of a
// `GtkInfoBar`.
//
// This also connects a signal handler that will emit the
// [signal@Gtk.InfoBar::response] signal on the message area when the widget
// is activated. The widget is appended to the end of the message areas
// action area.
func (i infoBar) AddActionWidget(child Widget, responseId int) {
	var _arg0 *C.GtkInfoBar
	var _arg1 *C.GtkWidget
	var _arg2 C.int

	_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = C.int(responseId)

	C.gtk_info_bar_add_action_widget(_arg0, _arg1, _arg2)
}

// AddChild adds a widget to the content area of the info bar.
func (i infoBar) AddChild(widget Widget) {
	var _arg0 *C.GtkInfoBar
	var _arg1 *C.GtkWidget

	_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	C.gtk_info_bar_add_child(_arg0, _arg1)
}

// Revealed returns whether the info bar is currently revealed.
func (i infoBar) Revealed() bool {
	var _arg0 *C.GtkInfoBar

	_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))

	var _cret C.gboolean

	_cret = C.gtk_info_bar_get_revealed(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// ShowCloseButton returns whether the widget will display a standard close
// button.
func (i infoBar) ShowCloseButton() bool {
	var _arg0 *C.GtkInfoBar

	_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))

	var _cret C.gboolean

	_cret = C.gtk_info_bar_get_show_close_button(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// RemoveActionWidget removes a widget from the action area of @info_bar.
//
// The widget must have been put there by a call to
// [method@Gtk.InfoBar.add_action_widget] or
// [method@Gtk.InfoBar.add_button].
func (i infoBar) RemoveActionWidget(widget Widget) {
	var _arg0 *C.GtkInfoBar
	var _arg1 *C.GtkWidget

	_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	C.gtk_info_bar_remove_action_widget(_arg0, _arg1)
}

// RemoveChild removes a widget from the content area of the info bar.
func (i infoBar) RemoveChild(widget Widget) {
	var _arg0 *C.GtkInfoBar
	var _arg1 *C.GtkWidget

	_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	C.gtk_info_bar_remove_child(_arg0, _arg1)
}

// Response emits the “response” signal with the given @response_id.
func (i infoBar) Response(responseId int) {
	var _arg0 *C.GtkInfoBar
	var _arg1 C.int

	_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))
	_arg1 = C.int(responseId)

	C.gtk_info_bar_response(_arg0, _arg1)
}

// SetDefaultResponse sets the last widget in the info bar’s action area
// with the given response_id as the default widget for the dialog.
//
// Pressing “Enter” normally activates the default widget.
//
// Note that this function currently requires @info_bar to be added to a
// widget hierarchy.
func (i infoBar) SetDefaultResponse(responseId int) {
	var _arg0 *C.GtkInfoBar
	var _arg1 C.int

	_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))
	_arg1 = C.int(responseId)

	C.gtk_info_bar_set_default_response(_arg0, _arg1)
}

// SetMessageType sets the message type of the message area.
//
// GTK uses this type to determine how the message is displayed.
func (i infoBar) SetMessageType(messageType MessageType) {
	var _arg0 *C.GtkInfoBar
	var _arg1 C.GtkMessageType

	_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))
	_arg1 = (C.GtkMessageType)(messageType)

	C.gtk_info_bar_set_message_type(_arg0, _arg1)
}

// SetResponseSensitive sets the sensitivity of action widgets for
// @response_id.
//
// Calls `gtk_widget_set_sensitive (widget, setting)` for each widget in the
// info bars’s action area with the given @response_id. A convenient way to
// sensitize/desensitize buttons.
func (i infoBar) SetResponseSensitive(responseId int, setting bool) {
	var _arg0 *C.GtkInfoBar
	var _arg1 C.int
	var _arg2 C.gboolean

	_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))
	_arg1 = C.int(responseId)
	if setting {
		_arg2 = C.gboolean(1)
	}

	C.gtk_info_bar_set_response_sensitive(_arg0, _arg1, _arg2)
}

// SetRevealed sets whether the `GtkInfoBar` is revealed.
//
// Changing this will make @info_bar reveal or conceal itself via a sliding
// transition.
//
// Note: this does not show or hide @info_bar in the
// [property@Gtk.Widget:visible] sense, so revealing has no effect if
// [property@Gtk.Widget:visible] is false.
func (i infoBar) SetRevealed(revealed bool) {
	var _arg0 *C.GtkInfoBar
	var _arg1 C.gboolean

	_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))
	if revealed {
		_arg1 = C.gboolean(1)
	}

	C.gtk_info_bar_set_revealed(_arg0, _arg1)
}

// SetShowCloseButton: if true, a standard close button is shown.
//
// When clicked it emits the response GTK_RESPONSE_CLOSE.
func (i infoBar) SetShowCloseButton(setting bool) {
	var _arg0 *C.GtkInfoBar
	var _arg1 C.gboolean

	_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))
	if setting {
		_arg1 = C.gboolean(1)
	}

	C.gtk_info_bar_set_show_close_button(_arg0, _arg1)
}

// Label: the `GtkLabel` widget displays a small amount of text.
//
// As the name implies, most labels are used to label another widget such as a
// [class@Button].
//
// !An example GtkLabel (label.png)
//
//
// CSS nodes
//
// “` label ├── [selection] ├── [link] ┊ ╰── [link] “`
//
// `GtkLabel` has a single CSS node with the name label. A wide variety of style
// classes may be applied to labels, such as .title, .subtitle, .dim-label, etc.
// In the `GtkShortcutsWindow`, labels are used with the .keycap style class.
//
// If the label has a selection, it gets a subnode with name selection.
//
// If the label has links, there is one subnode per link. These subnodes carry
// the link or visited state depending on whether they have been visited. In
// this case, label node also gets a .link style class.
//
//
// GtkLabel as GtkBuildable
//
// The GtkLabel implementation of the GtkBuildable interface supports a custom
// <attributes> element, which supports any number of <attribute> elements. The
// <attribute> element has attributes named “name“, “value“, “start“ and “end“
// and allows you to specify [struct@Pango.Attribute] values for this label.
//
// An example of a UI definition fragment specifying Pango attributes: “`xml
// <object class="GtkLabel"> <attributes> <attribute name="weight"
// value="PANGO_WEIGHT_BOLD"/> <attribute name="background" value="red"
// start="5" end="10"/> </attributes> </object> “`
//
// The start and end attributes specify the range of characters to which the
// Pango attribute applies. If start and end are not specified, the attribute is
// applied to the whole text. Note that specifying ranges does not make much
// sense with translatable attributes. Use markup embedded in the translatable
// content instead.
//
//
// Accessibility
//
// `GtkLabel` uses the K_ACCESSIBLE_ROLE_LABEL role.
//
//
// Mnemonics
//
// Labels may contain “mnemonics”. Mnemonics are underlined characters in the
// label, used for keyboard navigation. Mnemonics are created by providing a
// string with an underscore before the mnemonic character, such as `"_File"`,
// to the functions [ctor@Gtk.Label.new_with_mnemonic] or
// [method@Gtk.Label.set_text_with_mnemonic].
//
// Mnemonics automatically activate any activatable widget the label is inside,
// such as a [class@Gtk.Button]; if the label is not inside the mnemonic’s
// target widget, you have to tell the label about the target using
// [class@Gtk.Label.set_mnemonic_widget]. Here’s a simple example where the
// label is inside a button:
//
// “`c // Pressing Alt+H will activate this button GtkWidget *button =
// gtk_button_new (); GtkWidget *label = gtk_label_new_with_mnemonic ("_Hello");
// gtk_button_set_child (GTK_BUTTON (button), label); “`
//
// There’s a convenience function to create buttons with a mnemonic label
// already inside:
//
// “`c // Pressing Alt+H will activate this button GtkWidget *button =
// gtk_button_new_with_mnemonic ("_Hello"); “`
//
// To create a mnemonic for a widget alongside the label, such as a
// [class@Gtk.Entry], you have to point the label at the entry with
// [method@Gtk.Label.set_mnemonic_widget]:
//
// “`c // Pressing Alt+H will focus the entry GtkWidget *entry = gtk_entry_new
// (); GtkWidget *label = gtk_label_new_with_mnemonic ("_Hello");
// gtk_label_set_mnemonic_widget (GTK_LABEL (label), entry); “`
//
// Markup (styled text)
//
// To make it easy to format text in a label (changing colors, fonts, etc.),
// label text can be provided in a simple markup format:
//
// Here’s how to create a label with a small font: “`c GtkWidget *label =
// gtk_label_new (NULL); gtk_label_set_markup (GTK_LABEL (label), "<small>Small
// text</small>"); “`
//
// (See the Pango manual for complete documentation] of available tags,
// [func@Pango.parse_markup])
//
// The markup passed to gtk_label_set_markup() must be valid; for example,
// literal <, > and & characters must be escaped as &lt;, &gt;, and &amp;. If
// you pass text obtained from the user, file, or a network to
// [method@Gtk.Label.set_markup], you’ll want to escape it with
// g_markup_escape_text() or g_markup_printf_escaped().
//
// Markup strings are just a convenient way to set the [struct@Pango.AttrList]
// on a label; [method@Gtk.Label.set_attributes] may be a simpler way to set
// attributes in some cases. Be careful though; [struct@Pango.AttrList] tends to
// cause internationalization problems, unless you’re applying attributes to the
// entire string (i.e. unless you set the range of each attribute to [0,
// G_MAXINT)). The reason is that specifying the start_index and end_index for a
// [struct@Pango.Attribute] requires knowledge of the exact string being
// displayed, so translations will cause problems.
//
//
// Selectable labels
//
// Labels can be made selectable with [method@Gtk.Label.set_selectable].
// Selectable labels allow the user to copy the label contents to the clipboard.
// Only labels that contain useful-to-copy information — such as error messages
// — should be made selectable.
//
//
// Text layout
//
// A label can contain any number of paragraphs, but will have performance
// problems if it contains more than a small number. Paragraphs are separated by
// newlines or other paragraph separators understood by Pango.
//
// Labels can automatically wrap text if you call [method@Gtk.Label.set_wrap].
//
// [method@Gtk.Label.set_justify] sets how the lines in a label align with one
// another. If you want to set how the label as a whole aligns in its available
// space, see the [property@Gtk.Widget:halign] and [property@Gtk.Widget:valign]
// properties.
//
// The [property@Gtk.Label:width-chars] and [property@Gtk.Label:max-width-chars]
// properties can be used to control the size allocation of ellipsized or
// wrapped labels. For ellipsizing labels, if either is specified (and less than
// the actual text size), it is used as the minimum width, and the actual text
// size is used as the natural width of the label. For wrapping labels,
// width-chars is used as the minimum width, if specified, and max-width-chars
// is used as the natural width. Even if max-width-chars specified, wrapping
// labels will be rewrapped to use all of the available width.
//
//
// Links
//
// GTK supports markup for clickable hyperlinks in addition to regular Pango
// markup. The markup for links is borrowed from HTML, using the `<a>` with
// “href“, “title“ and “class“ attributes. GTK renders links similar to the way
// they appear in web browsers, with colored, underlined text. The “title“
// attribute is displayed as a tooltip on the link. The “class“ attribute is
// used as style class on the CSS node for the link.
//
// An example looks like this:
//
// “`c const char *text = "Go to the" "<a href=\"http://www.gtk.org
// title=\"&lt;i&gt;Our&lt;/i&gt; website\">" "GTK website</a> for more...";
// GtkWidget *label = gtk_label_new (NULL); gtk_label_set_markup (GTK_LABEL
// (label), text); “`
//
// It is possible to implement custom handling for links and their tooltips with
// the [signal@Gtk.Label::activate-link] signal and the
// [method@Gtk.Label.get_current_uri] function.
type Label interface {
	Widget
	Accessible
	Buildable
	ConstraintTarget

	// CurrentURI returns the URI for the currently active link in the label.
	//
	// The active link is the one under the mouse pointer or, in a selectable
	// label, the link in which the text cursor is currently positioned.
	//
	// This function is intended for use in a [signal@Gtk.Label::activate-link]
	// handler or for use in a [signal@Gtk.Widget::query-tooltip] handler.
	CurrentURI() string
	// Label fetches the text from a label.
	//
	// The returned text includes any embedded underlines indicating mnemonics
	// and Pango markup. (See [method@Gtk.Label.get_text]).
	Label() string
	// LayoutOffsets obtains the coordinates where the label will draw its
	// `PangoLayout`.
	//
	// The coordinates are useful to convert mouse events into coordinates
	// inside the [class@Pango.Layout], e.g. to take some action if some part of
	// the label is clicked. Remember when using the [class@Pango.Layout]
	// functions you need to convert to and from pixels using PANGO_PIXELS() or
	// [constant@Pango.SCALE].
	LayoutOffsets() (x int, y int)
	// Lines gets the number of lines to which an ellipsized, wrapping label
	// should be limited.
	//
	// See [method@Gtk.Label.set_lines].
	Lines() int
	// MaxWidthChars retrieves the desired maximum width of @label, in
	// characters.
	//
	// See [method@Gtk.Label.set_width_chars].
	MaxWidthChars() int
	// MnemonicKeyval: return the mnemonic accelerator.
	//
	// If the label has been set so that it has a mnemonic key this function
	// returns the keyval used for the mnemonic accelerator. If there is no
	// mnemonic set up it returns `GDK_KEY_VoidSymbol`.
	MnemonicKeyval() uint
	// Selectable returns whether the label is selectable.
	Selectable() bool
	// SelectionBounds gets the selected range of characters in the label.
	SelectionBounds() (start int, end int, ok bool)
	// SingleLineMode returns whether the label is in single line mode.
	SingleLineMode() bool
	// Text fetches the text from a label.
	//
	// The returned text is as it appears on screen. This does not include any
	// embedded underlines indicating mnemonics or Pango markup. (See
	// [method@Gtk.Label.get_label])
	Text() string
	// UseMarkup returns whether the label’s text is interpreted as Pango
	// markup.
	//
	// See [method@Gtk.Label.set_use_markup].
	UseMarkup() bool
	// UseUnderline returns whether an embedded underlines in the label indicate
	// mnemonics.
	//
	// See [method@Gtk.Label.set_use_underline].
	UseUnderline() bool
	// WidthChars retrieves the desired width of @label, in characters.
	//
	// See [method@Gtk.Label.set_width_chars].
	WidthChars() int
	// Wrap returns whether lines in the label are automatically wrapped.
	//
	// See [method@Gtk.Label.set_wrap].
	Wrap() bool
	// Xalign gets the `xalign` of the label.
	//
	// See the [property@Gtk.Label:xalign] property.
	Xalign() float32
	// Yalign gets the `yalign` of the label.
	//
	// See the [property@Gtk.Label:yalign] property.
	Yalign() float32
	// SelectRegion selects a range of characters in the label, if the label is
	// selectable.
	//
	// See [method@Gtk.Label.set_selectable]. If the label is not selectable,
	// this function has no effect. If @start_offset or @end_offset are -1, then
	// the end of the label will be substituted.
	SelectRegion(startOffset int, endOffset int)
	// SetAttributes: apply attributes to the label text.
	//
	// The attributes set with this function will be applied and merged with any
	// other attributes previously effected by way of the
	// [property@Gtk.Label:use-underline] or [property@Gtk.Label:use-markup]
	// properties. While it is not recommended to mix markup strings with
	// manually set attributes, if you must; know that the attributes will be
	// applied to the label after the markup string is parsed.
	SetAttributes(attrs *pango.AttrList)
	// SetEllipsize sets the mode used to ellipsizei the text.
	//
	// The text will be ellipsized if there is not enough space to render the
	// entire string.
	SetEllipsize(mode pango.EllipsizeMode)
	// SetExtraMenu sets a menu model to add when constructing the context menu
	// for @label.
	SetExtraMenu(model gio.MenuModel)
	// SetJustify sets the alignment of the lines in the text of the label
	// relative to each other.
	//
	// GTK_JUSTIFY_LEFT is the default value when the widget is first created
	// with [ctor@Gtk.Label.new]. If you instead want to set the alignment of
	// the label as a whole, use [method@Gtk.Widget.set_halign] instead.
	// [method@Gtk.Label.set_justify] has no effect on labels containing only a
	// single line.
	SetJustify(jtype Justification)
	// SetLabel sets the text of the label.
	//
	// The label is interpreted as including embedded underlines and/or Pango
	// markup depending on the values of the [property@Gtk.Label:use-underline]
	// and [property@Gtk.Label:use-markup] properties.
	SetLabel(str string)
	// SetLines sets the number of lines to which an ellipsized, wrapping label
	// should be limited.
	//
	// This has no effect if the label is not wrapping or ellipsized. Set this
	// to -1 if you don’t want to limit the number of lines.
	SetLines(lines int)
	// SetMarkup sets the labels text and attributes from markup.
	//
	// The string must be marked up with Pango markup (see
	// [func@Pango.parse_markup]).
	//
	// If the @str is external data, you may need to escape it with
	// g_markup_escape_text() or g_markup_printf_escaped():
	//
	// “`c GtkWidget *self = gtk_label_new (NULL); const char *str = "...";
	// const char *format = "<span style=\"italic\">\s</span>"; char *markup;
	//
	// markup = g_markup_printf_escaped (format, str); gtk_label_set_markup
	// (GTK_LABEL (self), markup); g_free (markup); “`
	//
	// This function will set the [property@Gtk.Label:use-markup] property to
	// true as a side effect.
	//
	// If you set the label contents using the [property@Gtk.Label:label]
	// property you should also ensure that you set the
	// [property@Gtk.Label:use-markup] property accordingly.
	//
	// See also: [method@Gtk.Label.set_text]
	SetMarkup(str string)
	// SetMarkupWithMnemonic sets the labels text, attributes and mnemonic from
	// markup.
	//
	// Parses @str which is marked up with Pango markup (see
	// [func@Pango.parse_markup]), setting the label’s text and attribute list
	// based on the parse results. If characters in @str are preceded by an
	// underscore, they are underlined indicating that they represent a keyboard
	// accelerator called a mnemonic.
	//
	// The mnemonic key can be used to activate another widget, chosen
	// automatically, or explicitly using method@Gtk.Label.set_mnemonic_widget].
	SetMarkupWithMnemonic(str string)
	// SetMaxWidthChars sets the desired maximum width in characters of @label
	// to @n_chars.
	SetMaxWidthChars(nChars int)
	// SetMnemonicWidget: associate the label with its mnemonic target.
	//
	// If the label has been set so that it has a mnemonic key (using i.e.
	// [method@Gtk.Label.set_markup_with_mnemonic],
	// [method@Gtk.Label.set_text_with_mnemonic],
	// [ctor@Gtk.Label.new_with_mnemonic] or the
	// [property@Gtk.Label:use_underline] property) the label can be associated
	// with a widget that is the target of the mnemonic. When the label is
	// inside a widget (like a [class@Gtk.Button] or a [class@Gtk.Notebook] tab)
	// it is automatically associated with the correct widget, but sometimes
	// (i.e. when the target is a [class@Gtk.Entry] next to the label) you need
	// to set it explicitly using this function.
	//
	// The target widget will be accelerated by emitting the
	// [signal@GtkWidget::mnemonic-activate] signal on it. The default handler
	// for this signal will activate the widget if there are no mnemonic
	// collisions and toggle focus between the colliding widgets otherwise.
	SetMnemonicWidget(widget Widget)
	// SetSelectable makes text in the label selectable.
	//
	// Selectable labels allow the user to select text from the label, for
	// copy-and-paste.
	SetSelectable(setting bool)
	// SetSingleLineMode sets whether the label is in single line mode.
	SetSingleLineMode(singleLineMode bool)
	// SetText sets the text within the `GtkLabel` widget.
	//
	// It overwrites any text that was there before.
	//
	// This function will clear any previously set mnemonic accelerators, and
	// set the [property@Gtk.Label:use-underline property] to false as a side
	// effect.
	//
	// This function will set the [property@Gtk.Label:use-markup] property to
	// false as a side effect.
	//
	// See also: [method@Gtk.Label.set_markup]
	SetText(str string)
	// SetTextWithMnemonic sets the label’s text from the string @str.
	//
	// If characters in @str are preceded by an underscore, they are underlined
	// indicating that they represent a keyboard accelerator called a mnemonic.
	// The mnemonic key can be used to activate another widget, chosen
	// automatically, or explicitly using
	// [method@Gtk.Label.set_mnemonic_widget].
	SetTextWithMnemonic(str string)
	// SetUseMarkup sets whether the text of the label contains markup.
	//
	// See [method@Gtk.Label.set_markup].
	SetUseMarkup(setting bool)
	// SetUseUnderline sets whether underlines in the text indicate mnemonics.
	SetUseUnderline(setting bool)
	// SetWidthChars sets the desired width in characters of @label to @n_chars.
	SetWidthChars(nChars int)
	// SetWrap toggles line wrapping within the `GtkLabel` widget.
	//
	// true makes it break lines if text exceeds the widget’s size. false lets
	// the text get cut off by the edge of the widget if it exceeds the widget
	// size.
	//
	// Note that setting line wrapping to true does not make the label wrap at
	// its parent container’s width, because GTK widgets conceptually can’t make
	// their requisition depend on the parent container’s size. For a label that
	// wraps at a specific position, set the label’s width using
	// [method@Gtk.Widget.set_size_request].
	SetWrap(wrap bool)
	// SetWrapMode controls how line wrapping is done.
	//
	// This only affects the label if line wrapping is on. (See
	// [method@Gtk.Label.set_wrap]) The default is PANGO_WRAP_WORD which means
	// wrap on word boundaries.
	SetWrapMode(wrapMode pango.WrapMode)
	// SetXalign sets the `xalign` of the label.
	//
	// See the [property@Gtk.Label:xalign] property.
	SetXalign(xalign float32)
	// SetYalign sets the `yalign` of the label.
	//
	// See the [property@Gtk.Label:yalign] property.
	SetYalign(yalign float32)
}

// label implements the Label interface.
type label struct {
	Widget
	Accessible
	Buildable
	ConstraintTarget
}

var _ Label = (*label)(nil)

// WrapLabel wraps a GObject to the right type. It is
// primarily used internally.
func WrapLabel(obj *externglib.Object) Label {
	return Label{
		Widget:           WrapWidget(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
	}
}

func marshalLabel(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapLabel(obj), nil
}

// CurrentURI returns the URI for the currently active link in the label.
//
// The active link is the one under the mouse pointer or, in a selectable
// label, the link in which the text cursor is currently positioned.
//
// This function is intended for use in a [signal@Gtk.Label::activate-link]
// handler or for use in a [signal@Gtk.Widget::query-tooltip] handler.
func (s label) CurrentURI() string {
	var _arg0 *C.GtkLabel

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))

	var _cret *C.char

	_cret = C.gtk_label_get_current_uri(_arg0)

	var _utf8 string

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Label fetches the text from a label.
//
// The returned text includes any embedded underlines indicating mnemonics
// and Pango markup. (See [method@Gtk.Label.get_text]).
func (s label) Label() string {
	var _arg0 *C.GtkLabel

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))

	var _cret *C.char

	_cret = C.gtk_label_get_label(_arg0)

	var _utf8 string

	_utf8 = C.GoString(_cret)

	return _utf8
}

// LayoutOffsets obtains the coordinates where the label will draw its
// `PangoLayout`.
//
// The coordinates are useful to convert mouse events into coordinates
// inside the [class@Pango.Layout], e.g. to take some action if some part of
// the label is clicked. Remember when using the [class@Pango.Layout]
// functions you need to convert to and from pixels using PANGO_PIXELS() or
// [constant@Pango.SCALE].
func (s label) LayoutOffsets() (x int, y int) {
	var _arg0 *C.GtkLabel

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))

	var _arg1 C.int
	var _arg2 C.int

	C.gtk_label_get_layout_offsets(_arg0, &_arg1, &_arg2)

	var _x int
	var _y int

	_x = (int)(_arg1)
	_y = (int)(_arg2)

	return _x, _y
}

// Lines gets the number of lines to which an ellipsized, wrapping label
// should be limited.
//
// See [method@Gtk.Label.set_lines].
func (s label) Lines() int {
	var _arg0 *C.GtkLabel

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))

	var _cret C.int

	_cret = C.gtk_label_get_lines(_arg0)

	var _gint int

	_gint = (int)(_cret)

	return _gint
}

// MaxWidthChars retrieves the desired maximum width of @label, in
// characters.
//
// See [method@Gtk.Label.set_width_chars].
func (s label) MaxWidthChars() int {
	var _arg0 *C.GtkLabel

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))

	var _cret C.int

	_cret = C.gtk_label_get_max_width_chars(_arg0)

	var _gint int

	_gint = (int)(_cret)

	return _gint
}

// MnemonicKeyval: return the mnemonic accelerator.
//
// If the label has been set so that it has a mnemonic key this function
// returns the keyval used for the mnemonic accelerator. If there is no
// mnemonic set up it returns `GDK_KEY_VoidSymbol`.
func (s label) MnemonicKeyval() uint {
	var _arg0 *C.GtkLabel

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))

	var _cret C.guint

	_cret = C.gtk_label_get_mnemonic_keyval(_arg0)

	var _guint uint

	_guint = (uint)(_cret)

	return _guint
}

// Selectable returns whether the label is selectable.
func (s label) Selectable() bool {
	var _arg0 *C.GtkLabel

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))

	var _cret C.gboolean

	_cret = C.gtk_label_get_selectable(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// SelectionBounds gets the selected range of characters in the label.
func (s label) SelectionBounds() (start int, end int, ok bool) {
	var _arg0 *C.GtkLabel

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))

	var _arg1 C.int
	var _arg2 C.int
	var _cret C.gboolean

	_cret = C.gtk_label_get_selection_bounds(_arg0, &_arg1, &_arg2)

	var _start int
	var _end int
	var _ok bool

	_start = (int)(_arg1)
	_end = (int)(_arg2)
	if _cret {
		_ok = true
	}

	return _start, _end, _ok
}

// SingleLineMode returns whether the label is in single line mode.
func (s label) SingleLineMode() bool {
	var _arg0 *C.GtkLabel

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))

	var _cret C.gboolean

	_cret = C.gtk_label_get_single_line_mode(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// Text fetches the text from a label.
//
// The returned text is as it appears on screen. This does not include any
// embedded underlines indicating mnemonics or Pango markup. (See
// [method@Gtk.Label.get_label])
func (s label) Text() string {
	var _arg0 *C.GtkLabel

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))

	var _cret *C.char

	_cret = C.gtk_label_get_text(_arg0)

	var _utf8 string

	_utf8 = C.GoString(_cret)

	return _utf8
}

// UseMarkup returns whether the label’s text is interpreted as Pango
// markup.
//
// See [method@Gtk.Label.set_use_markup].
func (s label) UseMarkup() bool {
	var _arg0 *C.GtkLabel

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))

	var _cret C.gboolean

	_cret = C.gtk_label_get_use_markup(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// UseUnderline returns whether an embedded underlines in the label indicate
// mnemonics.
//
// See [method@Gtk.Label.set_use_underline].
func (s label) UseUnderline() bool {
	var _arg0 *C.GtkLabel

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))

	var _cret C.gboolean

	_cret = C.gtk_label_get_use_underline(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// WidthChars retrieves the desired width of @label, in characters.
//
// See [method@Gtk.Label.set_width_chars].
func (s label) WidthChars() int {
	var _arg0 *C.GtkLabel

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))

	var _cret C.int

	_cret = C.gtk_label_get_width_chars(_arg0)

	var _gint int

	_gint = (int)(_cret)

	return _gint
}

// Wrap returns whether lines in the label are automatically wrapped.
//
// See [method@Gtk.Label.set_wrap].
func (s label) Wrap() bool {
	var _arg0 *C.GtkLabel

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))

	var _cret C.gboolean

	_cret = C.gtk_label_get_wrap(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// Xalign gets the `xalign` of the label.
//
// See the [property@Gtk.Label:xalign] property.
func (s label) Xalign() float32 {
	var _arg0 *C.GtkLabel

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))

	var _cret C.float

	_cret = C.gtk_label_get_xalign(_arg0)

	var _gfloat float32

	_gfloat = (float32)(_cret)

	return _gfloat
}

// Yalign gets the `yalign` of the label.
//
// See the [property@Gtk.Label:yalign] property.
func (s label) Yalign() float32 {
	var _arg0 *C.GtkLabel

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))

	var _cret C.float

	_cret = C.gtk_label_get_yalign(_arg0)

	var _gfloat float32

	_gfloat = (float32)(_cret)

	return _gfloat
}

// SelectRegion selects a range of characters in the label, if the label is
// selectable.
//
// See [method@Gtk.Label.set_selectable]. If the label is not selectable,
// this function has no effect. If @start_offset or @end_offset are -1, then
// the end of the label will be substituted.
func (s label) SelectRegion(startOffset int, endOffset int) {
	var _arg0 *C.GtkLabel
	var _arg1 C.int
	var _arg2 C.int

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
	_arg1 = C.int(startOffset)
	_arg2 = C.int(endOffset)

	C.gtk_label_select_region(_arg0, _arg1, _arg2)
}

// SetAttributes: apply attributes to the label text.
//
// The attributes set with this function will be applied and merged with any
// other attributes previously effected by way of the
// [property@Gtk.Label:use-underline] or [property@Gtk.Label:use-markup]
// properties. While it is not recommended to mix markup strings with
// manually set attributes, if you must; know that the attributes will be
// applied to the label after the markup string is parsed.
func (s label) SetAttributes(attrs *pango.AttrList) {
	var _arg0 *C.GtkLabel
	var _arg1 *C.PangoAttrList

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.PangoAttrList)(unsafe.Pointer(attrs.Native()))

	C.gtk_label_set_attributes(_arg0, _arg1)
}

// SetEllipsize sets the mode used to ellipsizei the text.
//
// The text will be ellipsized if there is not enough space to render the
// entire string.
func (s label) SetEllipsize(mode pango.EllipsizeMode) {
	var _arg0 *C.GtkLabel
	var _arg1 C.PangoEllipsizeMode

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
	_arg1 = (C.PangoEllipsizeMode)(mode)

	C.gtk_label_set_ellipsize(_arg0, _arg1)
}

// SetExtraMenu sets a menu model to add when constructing the context menu
// for @label.
func (s label) SetExtraMenu(model gio.MenuModel) {
	var _arg0 *C.GtkLabel
	var _arg1 *C.GMenuModel

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GMenuModel)(unsafe.Pointer(model.Native()))

	C.gtk_label_set_extra_menu(_arg0, _arg1)
}

// SetJustify sets the alignment of the lines in the text of the label
// relative to each other.
//
// GTK_JUSTIFY_LEFT is the default value when the widget is first created
// with [ctor@Gtk.Label.new]. If you instead want to set the alignment of
// the label as a whole, use [method@Gtk.Widget.set_halign] instead.
// [method@Gtk.Label.set_justify] has no effect on labels containing only a
// single line.
func (s label) SetJustify(jtype Justification) {
	var _arg0 *C.GtkLabel
	var _arg1 C.GtkJustification

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkJustification)(jtype)

	C.gtk_label_set_justify(_arg0, _arg1)
}

// SetLabel sets the text of the label.
//
// The label is interpreted as including embedded underlines and/or Pango
// markup depending on the values of the [property@Gtk.Label:use-underline]
// and [property@Gtk.Label:use-markup] properties.
func (s label) SetLabel(str string) {
	var _arg0 *C.GtkLabel
	var _arg1 *C.char

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(str))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_label_set_label(_arg0, _arg1)
}

// SetLines sets the number of lines to which an ellipsized, wrapping label
// should be limited.
//
// This has no effect if the label is not wrapping or ellipsized. Set this
// to -1 if you don’t want to limit the number of lines.
func (s label) SetLines(lines int) {
	var _arg0 *C.GtkLabel
	var _arg1 C.int

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
	_arg1 = C.int(lines)

	C.gtk_label_set_lines(_arg0, _arg1)
}

// SetMarkup sets the labels text and attributes from markup.
//
// The string must be marked up with Pango markup (see
// [func@Pango.parse_markup]).
//
// If the @str is external data, you may need to escape it with
// g_markup_escape_text() or g_markup_printf_escaped():
//
// “`c GtkWidget *self = gtk_label_new (NULL); const char *str = "...";
// const char *format = "<span style=\"italic\">\s</span>"; char *markup;
//
// markup = g_markup_printf_escaped (format, str); gtk_label_set_markup
// (GTK_LABEL (self), markup); g_free (markup); “`
//
// This function will set the [property@Gtk.Label:use-markup] property to
// true as a side effect.
//
// If you set the label contents using the [property@Gtk.Label:label]
// property you should also ensure that you set the
// [property@Gtk.Label:use-markup] property accordingly.
//
// See also: [method@Gtk.Label.set_text]
func (s label) SetMarkup(str string) {
	var _arg0 *C.GtkLabel
	var _arg1 *C.char

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(str))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_label_set_markup(_arg0, _arg1)
}

// SetMarkupWithMnemonic sets the labels text, attributes and mnemonic from
// markup.
//
// Parses @str which is marked up with Pango markup (see
// [func@Pango.parse_markup]), setting the label’s text and attribute list
// based on the parse results. If characters in @str are preceded by an
// underscore, they are underlined indicating that they represent a keyboard
// accelerator called a mnemonic.
//
// The mnemonic key can be used to activate another widget, chosen
// automatically, or explicitly using method@Gtk.Label.set_mnemonic_widget].
func (s label) SetMarkupWithMnemonic(str string) {
	var _arg0 *C.GtkLabel
	var _arg1 *C.char

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(str))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_label_set_markup_with_mnemonic(_arg0, _arg1)
}

// SetMaxWidthChars sets the desired maximum width in characters of @label
// to @n_chars.
func (s label) SetMaxWidthChars(nChars int) {
	var _arg0 *C.GtkLabel
	var _arg1 C.int

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
	_arg1 = C.int(nChars)

	C.gtk_label_set_max_width_chars(_arg0, _arg1)
}

// SetMnemonicWidget: associate the label with its mnemonic target.
//
// If the label has been set so that it has a mnemonic key (using i.e.
// [method@Gtk.Label.set_markup_with_mnemonic],
// [method@Gtk.Label.set_text_with_mnemonic],
// [ctor@Gtk.Label.new_with_mnemonic] or the
// [property@Gtk.Label:use_underline] property) the label can be associated
// with a widget that is the target of the mnemonic. When the label is
// inside a widget (like a [class@Gtk.Button] or a [class@Gtk.Notebook] tab)
// it is automatically associated with the correct widget, but sometimes
// (i.e. when the target is a [class@Gtk.Entry] next to the label) you need
// to set it explicitly using this function.
//
// The target widget will be accelerated by emitting the
// [signal@GtkWidget::mnemonic-activate] signal on it. The default handler
// for this signal will activate the widget if there are no mnemonic
// collisions and toggle focus between the colliding widgets otherwise.
func (s label) SetMnemonicWidget(widget Widget) {
	var _arg0 *C.GtkLabel
	var _arg1 *C.GtkWidget

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	C.gtk_label_set_mnemonic_widget(_arg0, _arg1)
}

// SetSelectable makes text in the label selectable.
//
// Selectable labels allow the user to select text from the label, for
// copy-and-paste.
func (s label) SetSelectable(setting bool) {
	var _arg0 *C.GtkLabel
	var _arg1 C.gboolean

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
	if setting {
		_arg1 = C.gboolean(1)
	}

	C.gtk_label_set_selectable(_arg0, _arg1)
}

// SetSingleLineMode sets whether the label is in single line mode.
func (s label) SetSingleLineMode(singleLineMode bool) {
	var _arg0 *C.GtkLabel
	var _arg1 C.gboolean

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
	if singleLineMode {
		_arg1 = C.gboolean(1)
	}

	C.gtk_label_set_single_line_mode(_arg0, _arg1)
}

// SetText sets the text within the `GtkLabel` widget.
//
// It overwrites any text that was there before.
//
// This function will clear any previously set mnemonic accelerators, and
// set the [property@Gtk.Label:use-underline property] to false as a side
// effect.
//
// This function will set the [property@Gtk.Label:use-markup] property to
// false as a side effect.
//
// See also: [method@Gtk.Label.set_markup]
func (s label) SetText(str string) {
	var _arg0 *C.GtkLabel
	var _arg1 *C.char

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(str))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_label_set_text(_arg0, _arg1)
}

// SetTextWithMnemonic sets the label’s text from the string @str.
//
// If characters in @str are preceded by an underscore, they are underlined
// indicating that they represent a keyboard accelerator called a mnemonic.
// The mnemonic key can be used to activate another widget, chosen
// automatically, or explicitly using
// [method@Gtk.Label.set_mnemonic_widget].
func (s label) SetTextWithMnemonic(str string) {
	var _arg0 *C.GtkLabel
	var _arg1 *C.char

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(str))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_label_set_text_with_mnemonic(_arg0, _arg1)
}

// SetUseMarkup sets whether the text of the label contains markup.
//
// See [method@Gtk.Label.set_markup].
func (s label) SetUseMarkup(setting bool) {
	var _arg0 *C.GtkLabel
	var _arg1 C.gboolean

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
	if setting {
		_arg1 = C.gboolean(1)
	}

	C.gtk_label_set_use_markup(_arg0, _arg1)
}

// SetUseUnderline sets whether underlines in the text indicate mnemonics.
func (s label) SetUseUnderline(setting bool) {
	var _arg0 *C.GtkLabel
	var _arg1 C.gboolean

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
	if setting {
		_arg1 = C.gboolean(1)
	}

	C.gtk_label_set_use_underline(_arg0, _arg1)
}

// SetWidthChars sets the desired width in characters of @label to @n_chars.
func (s label) SetWidthChars(nChars int) {
	var _arg0 *C.GtkLabel
	var _arg1 C.int

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
	_arg1 = C.int(nChars)

	C.gtk_label_set_width_chars(_arg0, _arg1)
}

// SetWrap toggles line wrapping within the `GtkLabel` widget.
//
// true makes it break lines if text exceeds the widget’s size. false lets
// the text get cut off by the edge of the widget if it exceeds the widget
// size.
//
// Note that setting line wrapping to true does not make the label wrap at
// its parent container’s width, because GTK widgets conceptually can’t make
// their requisition depend on the parent container’s size. For a label that
// wraps at a specific position, set the label’s width using
// [method@Gtk.Widget.set_size_request].
func (s label) SetWrap(wrap bool) {
	var _arg0 *C.GtkLabel
	var _arg1 C.gboolean

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
	if wrap {
		_arg1 = C.gboolean(1)
	}

	C.gtk_label_set_wrap(_arg0, _arg1)
}

// SetWrapMode controls how line wrapping is done.
//
// This only affects the label if line wrapping is on. (See
// [method@Gtk.Label.set_wrap]) The default is PANGO_WRAP_WORD which means
// wrap on word boundaries.
func (s label) SetWrapMode(wrapMode pango.WrapMode) {
	var _arg0 *C.GtkLabel
	var _arg1 C.PangoWrapMode

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
	_arg1 = (C.PangoWrapMode)(wrapMode)

	C.gtk_label_set_wrap_mode(_arg0, _arg1)
}

// SetXalign sets the `xalign` of the label.
//
// See the [property@Gtk.Label:xalign] property.
func (s label) SetXalign(xalign float32) {
	var _arg0 *C.GtkLabel
	var _arg1 C.float

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
	_arg1 = C.float(xalign)

	C.gtk_label_set_xalign(_arg0, _arg1)
}

// SetYalign sets the `yalign` of the label.
//
// See the [property@Gtk.Label:yalign] property.
func (s label) SetYalign(yalign float32) {
	var _arg0 *C.GtkLabel
	var _arg1 C.float

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
	_arg1 = C.float(yalign)

	C.gtk_label_set_yalign(_arg0, _arg1)
}

// LevelBar: `GtkLevelBar` is a widget that can be used as a level indicator.
//
// Typical use cases are displaying the strength of a password, or showing the
// charge level of a battery.
//
// !An example GtkLevelBar (levelbar.png)
//
// Use [method@Gtk.LevelBar.set_value] to set the current value, and
// [method@Gtk.LevelBar.add_offset_value] to set the value offsets at which the
// bar will be considered in a different state. GTK will add a few offsets by
// default on the level bar: GTK_LEVEL_BAR_OFFSET_LOW, GTK_LEVEL_BAR_OFFSET_HIGH
// and GTK_LEVEL_BAR_OFFSET_FULL, with values 0.25, 0.75 and 1.0 respectively.
//
// Note that it is your responsibility to update preexisting offsets when
// changing the minimum or maximum value. GTK will simply clamp them to the new
// range.
//
//
// Adding a custom offset on the bar
//
// “`c static GtkWidget * create_level_bar (void) { GtkWidget *widget;
// GtkLevelBar *bar;
//
//    widget = gtk_level_bar_new ();
//    bar = GTK_LEVEL_BAR (widget);
//
//    // This changes the value of the default low offset
//
//    gtk_level_bar_add_offset_value (bar,
//                                    GTK_LEVEL_BAR_OFFSET_LOW,
//                                    0.10);
//
//    // This adds a new offset to the bar; the application will
//    // be able to change its color CSS like this:
//    //
//    // levelbar block.my-offset {
//    //   background-color: magenta;
//    //   border-style: solid;
//    //   border-color: black;
//    //   border-style: 1px;
//    // }
//
//    gtk_level_bar_add_offset_value (bar, "my-offset", 0.60);
//
//    return widget;
//
// } “`
//
// The default interval of values is between zero and one, but it’s possible to
// modify the interval using [method@Gtk.LevelBar.set_min_value] and
// [method@Gtk.LevelBar.set_max_value]. The value will be always drawn in
// proportion to the admissible interval, i.e. a value of 15 with a specified
// interval between 10 and 20 is equivalent to a value of 0.5 with an interval
// between 0 and 1. When K_LEVEL_BAR_MODE_DISCRETE is used, the bar level is
// rendered as a finite number of separated blocks instead of a single one. The
// number of blocks that will be rendered is equal to the number of units
// specified by the admissible interval.
//
// For instance, to build a bar rendered with five blocks, it’s sufficient to
// set the minimum value to 0 and the maximum value to 5 after changing the
// indicator mode to discrete.
//
//
// GtkLevelBar as GtkBuildable
//
// The `GtkLevelBar` implementation of the `GtkBuildable` interface supports a
// custom <offsets> element, which can contain any number of <offset> elements,
// each of which must have name and value attributes.
//
//
// CSS nodes
//
// “` levelbar[.discrete] ╰── trough ├── block.filled.level-name ┊ ├──
// block.empty ┊ “`
//
// `GtkLevelBar` has a main CSS node with name levelbar and one of the style
// classes .discrete or .continuous and a subnode with name trough. Below the
// trough node are a number of nodes with name block and style class .filled or
// .empty. In continuous mode, there is exactly one node of each, in discrete
// mode, the number of filled and unfilled nodes corresponds to blocks that are
// drawn. The block.filled nodes also get a style class .level-name
// corresponding to the level for the current value.
//
// In horizontal orientation, the nodes are always arranged from left to right,
// regardless of text direction.
//
//
// Accessibility
//
// `GtkLevelBar` uses the K_ACCESSIBLE_ROLE_METER role.
type LevelBar interface {
	Widget
	Accessible
	Buildable
	ConstraintTarget
	Orientable

	// AddOffsetValue adds a new offset marker on @self at the position
	// specified by @value.
	//
	// When the bar value is in the interval topped by @value (or between @value
	// and [property@Gtk.LevelBar:max-value] in case the offset is the last one
	// on the bar) a style class named `level-`@name will be applied when
	// rendering the level bar fill.
	//
	// If another offset marker named @name exists, its value will be replaced
	// by @value.
	AddOffsetValue(name string, value float64)
	// Inverted returns whether the levelbar is inverted.
	Inverted() bool
	// MaxValue returns the `max-value` of the `GtkLevelBar`.
	MaxValue() float64
	// MinValue returns the `min-value of the `GtkLevelBar`.
	MinValue() float64
	// OffsetValue fetches the value specified for the offset marker @name in
	// @self.
	OffsetValue(name string) (float64, bool)
	// Value returns the `value` of the `GtkLevelBar`.
	Value() float64
	// RemoveOffsetValue removes an offset marker from a `GtkLevelBar`.
	//
	// The marker must have been previously added with
	// [method@Gtk.LevelBar.add_offset_value].
	RemoveOffsetValue(name string)
	// SetInverted sets whether the `GtkLevelBar` is inverted.
	SetInverted(inverted bool)
	// SetMaxValue sets the `max-value` of the `GtkLevelBar`.
	//
	// You probably want to update preexisting level offsets after calling this
	// function.
	SetMaxValue(value float64)
	// SetMinValue sets the `min-value` of the `GtkLevelBar`.
	//
	// You probably want to update preexisting level offsets after calling this
	// function.
	SetMinValue(value float64)
	// SetMode sets the `mode` of the `GtkLevelBar`.
	SetMode(mode LevelBarMode)
	// SetValue sets the value of the `GtkLevelBar`.
	SetValue(value float64)
}

// levelBar implements the LevelBar interface.
type levelBar struct {
	Widget
	Accessible
	Buildable
	ConstraintTarget
	Orientable
}

var _ LevelBar = (*levelBar)(nil)

// WrapLevelBar wraps a GObject to the right type. It is
// primarily used internally.
func WrapLevelBar(obj *externglib.Object) LevelBar {
	return LevelBar{
		Widget:           WrapWidget(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
		Orientable:       WrapOrientable(obj),
	}
}

func marshalLevelBar(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapLevelBar(obj), nil
}

// AddOffsetValue adds a new offset marker on @self at the position
// specified by @value.
//
// When the bar value is in the interval topped by @value (or between @value
// and [property@Gtk.LevelBar:max-value] in case the offset is the last one
// on the bar) a style class named `level-`@name will be applied when
// rendering the level bar fill.
//
// If another offset marker named @name exists, its value will be replaced
// by @value.
func (s levelBar) AddOffsetValue(name string, value float64) {
	var _arg0 *C.GtkLevelBar
	var _arg1 *C.char
	var _arg2 C.double

	_arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.double(value)

	C.gtk_level_bar_add_offset_value(_arg0, _arg1, _arg2)
}

// Inverted returns whether the levelbar is inverted.
func (s levelBar) Inverted() bool {
	var _arg0 *C.GtkLevelBar

	_arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))

	var _cret C.gboolean

	_cret = C.gtk_level_bar_get_inverted(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// MaxValue returns the `max-value` of the `GtkLevelBar`.
func (s levelBar) MaxValue() float64 {
	var _arg0 *C.GtkLevelBar

	_arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))

	var _cret C.double

	_cret = C.gtk_level_bar_get_max_value(_arg0)

	var _gdouble float64

	_gdouble = (float64)(_cret)

	return _gdouble
}

// MinValue returns the `min-value of the `GtkLevelBar`.
func (s levelBar) MinValue() float64 {
	var _arg0 *C.GtkLevelBar

	_arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))

	var _cret C.double

	_cret = C.gtk_level_bar_get_min_value(_arg0)

	var _gdouble float64

	_gdouble = (float64)(_cret)

	return _gdouble
}

// OffsetValue fetches the value specified for the offset marker @name in
// @self.
func (s levelBar) OffsetValue(name string) (float64, bool) {
	var _arg0 *C.GtkLevelBar
	var _arg1 *C.char

	_arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	var _arg2 C.double
	var _cret C.gboolean

	_cret = C.gtk_level_bar_get_offset_value(_arg0, _arg1, &_arg2)

	var _value float64
	var _ok bool

	_value = (float64)(_arg2)
	if _cret {
		_ok = true
	}

	return _value, _ok
}

// Value returns the `value` of the `GtkLevelBar`.
func (s levelBar) Value() float64 {
	var _arg0 *C.GtkLevelBar

	_arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))

	var _cret C.double

	_cret = C.gtk_level_bar_get_value(_arg0)

	var _gdouble float64

	_gdouble = (float64)(_cret)

	return _gdouble
}

// RemoveOffsetValue removes an offset marker from a `GtkLevelBar`.
//
// The marker must have been previously added with
// [method@Gtk.LevelBar.add_offset_value].
func (s levelBar) RemoveOffsetValue(name string) {
	var _arg0 *C.GtkLevelBar
	var _arg1 *C.char

	_arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_level_bar_remove_offset_value(_arg0, _arg1)
}

// SetInverted sets whether the `GtkLevelBar` is inverted.
func (s levelBar) SetInverted(inverted bool) {
	var _arg0 *C.GtkLevelBar
	var _arg1 C.gboolean

	_arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))
	if inverted {
		_arg1 = C.gboolean(1)
	}

	C.gtk_level_bar_set_inverted(_arg0, _arg1)
}

// SetMaxValue sets the `max-value` of the `GtkLevelBar`.
//
// You probably want to update preexisting level offsets after calling this
// function.
func (s levelBar) SetMaxValue(value float64) {
	var _arg0 *C.GtkLevelBar
	var _arg1 C.double

	_arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))
	_arg1 = C.double(value)

	C.gtk_level_bar_set_max_value(_arg0, _arg1)
}

// SetMinValue sets the `min-value` of the `GtkLevelBar`.
//
// You probably want to update preexisting level offsets after calling this
// function.
func (s levelBar) SetMinValue(value float64) {
	var _arg0 *C.GtkLevelBar
	var _arg1 C.double

	_arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))
	_arg1 = C.double(value)

	C.gtk_level_bar_set_min_value(_arg0, _arg1)
}

// SetMode sets the `mode` of the `GtkLevelBar`.
func (s levelBar) SetMode(mode LevelBarMode) {
	var _arg0 *C.GtkLevelBar
	var _arg1 C.GtkLevelBarMode

	_arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkLevelBarMode)(mode)

	C.gtk_level_bar_set_mode(_arg0, _arg1)
}

// SetValue sets the value of the `GtkLevelBar`.
func (s levelBar) SetValue(value float64) {
	var _arg0 *C.GtkLevelBar
	var _arg1 C.double

	_arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))
	_arg1 = C.double(value)

	C.gtk_level_bar_set_value(_arg0, _arg1)
}

// LinkButton: a `GtkLinkButton` is a button with a hyperlink.
//
// !An example GtkLinkButton (link-button.png)
//
// It is useful to show quick links to resources.
//
// A link button is created by calling either [ctor@Gtk.LinkButton.new] or
// [ctor@Gtk.LinkButton.new_with_label]. If using the former, the URI you pass
// to the constructor is used as a label for the widget.
//
// The URI bound to a `GtkLinkButton` can be set specifically using
// [method@Gtk.LinkButton.set_uri].
//
// By default, `GtkLinkButton` calls [func@Gtk.show_uri] when the button is
// clicked. This behaviour can be overridden by connecting to the
// [signal@Gtk.LinkButton::activate-link] signal and returning true from the
// signal handler.
//
//
// CSS nodes
//
// `GtkLinkButton` has a single CSS node with name button. To differentiate it
// from a plain `GtkButton`, it gets the .link style class.
//
//
// Accessibility
//
// `GtkLinkButton` uses the K_ACCESSIBLE_ROLE_LINK role.
type LinkButton interface {
	Button
	Accessible
	Actionable
	Buildable
	ConstraintTarget

	// URI retrieves the URI of the `GtkLinkButton`.
	URI() string
	// Visited retrieves the “visited” state of the `GtkLinkButton`.
	//
	// The button becomes visited when it is clicked. If the URI is changed on
	// the button, the “visited” state is unset again.
	//
	// The state may also be changed using [method@Gtk.LinkButton.set_visited].
	Visited() bool
	// SetURI sets @uri as the URI where the `GtkLinkButton` points.
	//
	// As a side-effect this unsets the “visited” state of the button.
	SetURI(uri string)
	// SetVisited sets the “visited” state of the `GtkLinkButton`.
	//
	// See [method@Gtk.LinkButton.get_visited] for more details.
	SetVisited(visited bool)
}

// linkButton implements the LinkButton interface.
type linkButton struct {
	Button
	Accessible
	Actionable
	Buildable
	ConstraintTarget
}

var _ LinkButton = (*linkButton)(nil)

// WrapLinkButton wraps a GObject to the right type. It is
// primarily used internally.
func WrapLinkButton(obj *externglib.Object) LinkButton {
	return LinkButton{
		Button:           WrapButton(obj),
		Accessible:       WrapAccessible(obj),
		Actionable:       WrapActionable(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
	}
}

func marshalLinkButton(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapLinkButton(obj), nil
}

// URI retrieves the URI of the `GtkLinkButton`.
func (l linkButton) URI() string {
	var _arg0 *C.GtkLinkButton

	_arg0 = (*C.GtkLinkButton)(unsafe.Pointer(l.Native()))

	var _cret *C.char

	_cret = C.gtk_link_button_get_uri(_arg0)

	var _utf8 string

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Visited retrieves the “visited” state of the `GtkLinkButton`.
//
// The button becomes visited when it is clicked. If the URI is changed on
// the button, the “visited” state is unset again.
//
// The state may also be changed using [method@Gtk.LinkButton.set_visited].
func (l linkButton) Visited() bool {
	var _arg0 *C.GtkLinkButton

	_arg0 = (*C.GtkLinkButton)(unsafe.Pointer(l.Native()))

	var _cret C.gboolean

	_cret = C.gtk_link_button_get_visited(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// SetURI sets @uri as the URI where the `GtkLinkButton` points.
//
// As a side-effect this unsets the “visited” state of the button.
func (l linkButton) SetURI(uri string) {
	var _arg0 *C.GtkLinkButton
	var _arg1 *C.char

	_arg0 = (*C.GtkLinkButton)(unsafe.Pointer(l.Native()))
	_arg1 = (*C.char)(C.CString(uri))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_link_button_set_uri(_arg0, _arg1)
}

// SetVisited sets the “visited” state of the `GtkLinkButton`.
//
// See [method@Gtk.LinkButton.get_visited] for more details.
func (l linkButton) SetVisited(visited bool) {
	var _arg0 *C.GtkLinkButton
	var _arg1 C.gboolean

	_arg0 = (*C.GtkLinkButton)(unsafe.Pointer(l.Native()))
	if visited {
		_arg1 = C.gboolean(1)
	}

	C.gtk_link_button_set_visited(_arg0, _arg1)
}

// ListBox: `GtkListBox` is a vertical list.
//
// A `GtkListBox` only contains `GtkListBoxRow` children. These rows can by
// dynamically sorted and filtered, and headers can be added dynamically
// depending on the row content. It also allows keyboard and mouse navigation
// and selection like a typical list.
//
// Using `GtkListBox` is often an alternative to `GtkTreeView`, especially when
// the list contents has a more complicated layout than what is allowed by a
// `GtkCellRenderer`, or when the contents is interactive (i.e. has a button in
// it).
//
// Although a `GtkListBox` must have only `GtkListBoxRow` children, you can add
// any kind of widget to it via [method@Gtk.ListBox.prepend],
// [method@Gtk.ListBox.append] and [method@Gtk.ListBox.insert] and a
// `GtkListBoxRow` widget will automatically be inserted between the list and
// the widget.
//
// `GtkListBoxRows` can be marked as activatable or selectable. If a row is
// activatable, [signal@Gtk.ListBox::row-activated] will be emitted for it when
// the user tries to activate it. If it is selectable, the row will be marked as
// selected when the user tries to select it.
//
//
// GtkListBox as GtkBuildable
//
// The `GtkListBox` implementation of the `GtkBuildable` interface supports
// setting a child as the placeholder by specifying “placeholder” as the “type”
// attribute of a <child> element. See [method@Gtk.ListBox.set_placeholder] for
// info.
//
// CSS nodes
//
//    list[.separators][.rich-list][.navigation-sidebar]
//    ╰── row[.activatable]
//
// `GtkListBox` uses a single CSS node named list. It may carry the .separators
// style class, when the [property@Gtk.ListBox:show-separators] property is set.
// Each `GtkListBoxRow` uses a single CSS node named row. The row nodes get the
// .activatable style class added when appropriate.
//
// The main list node may also carry style classes to select the style of list
// presentation (section-list-widget.html#list-styles): .rich-list,
// .navigation-sidebar or .data-table.
//
//
// Accessibility
//
// `GtkListBox` uses the GTK_ACCESSIBLE_ROLE_LIST role and `GtkListBoxRow` uses
// the GTK_ACCESSIBLE_ROLE_LIST_ITEM role.
type ListBox interface {
	Widget
	Accessible
	Buildable
	ConstraintTarget

	// Append: append a widget to the list.
	//
	// If a sort function is set, the widget will actually be inserted at the
	// calculated position.
	Append(child Widget)
	// DragHighlightRow: add a drag highlight to a row.
	//
	// This is a helper function for implementing DnD onto a `GtkListBox`. The
	// passed in @row will be highlighted by setting the
	// GTK_STATE_FLAG_DROP_ACTIVE state and any previously highlighted row will
	// be unhighlighted.
	//
	// The row will also be unhighlighted when the widget gets a drag leave
	// event.
	DragHighlightRow(row ListBoxRow)
	// DragUnhighlightRow: if a row has previously been highlighted via
	// gtk_list_box_drag_highlight_row(), it will have the highlight removed.
	DragUnhighlightRow()
	// ActivateOnSingleClick returns whether rows activate on single clicks.
	ActivateOnSingleClick() bool
	// ShowSeparators returns whether the list box should show separators
	// between rows.
	ShowSeparators() bool
	// Insert: insert the @child into the @box at @position.
	//
	// If a sort function is set, the widget will actually be inserted at the
	// calculated position.
	//
	// If @position is -1, or larger than the total number of items in the @box,
	// then the @child will be appended to the end.
	Insert(child Widget, position int)
	// InvalidateFilter: update the filtering for all rows.
	//
	// Call this when result of the filter function on the @box is changed due
	// to an external factor. For instance, this would be used if the filter
	// function just looked for a specific search string and the entry with the
	// search string has changed.
	InvalidateFilter()
	// InvalidateHeaders: update the separators for all rows.
	//
	// Call this when result of the header function on the @box is changed due
	// to an external factor.
	InvalidateHeaders()
	// InvalidateSort: update the sorting for all rows.
	//
	// Call this when result of the sort function on the @box is changed due to
	// an external factor.
	InvalidateSort()
	// Prepend: prepend a widget to the list.
	//
	// If a sort function is set, the widget will actually be inserted at the
	// calculated position.
	Prepend(child Widget)
	// Remove removes a child from @box.
	Remove(child Widget)
	// SelectAll: select all children of @box, if the selection mode allows it.
	SelectAll()
	// SelectRow: make @row the currently selected row.
	SelectRow(row ListBoxRow)
	// SelectedForeach calls a function for each selected child.
	//
	// Note that the selection cannot be modified from within this function.
	SelectedForeach(fn ListBoxForeachFunc)
	// SetActivateOnSingleClick: if @single is true, rows will be activated when
	// you click on them, otherwise you need to double-click.
	SetActivateOnSingleClick(single bool)
	// SetAdjustment sets the adjustment (if any) that the widget uses to for
	// vertical scrolling.
	//
	// For instance, this is used to get the page size for PageUp/Down key
	// handling.
	//
	// In the normal case when the @box is packed inside a `GtkScrolledWindow`
	// the adjustment from that will be picked up automatically, so there is no
	// need to manually do that.
	SetAdjustment(adjustment Adjustment)
	// SetPlaceholder sets the placeholder widget that is shown in the list when
	// it doesn't display any visible children.
	SetPlaceholder(placeholder Widget)
	// SetSelectionMode sets how selection works in the listbox.
	SetSelectionMode(mode SelectionMode)
	// SetShowSeparators sets whether the list box should show separators
	// between rows.
	SetShowSeparators(showSeparators bool)
	// UnselectAll: unselect all children of @box, if the selection mode allows
	// it.
	UnselectAll()
	// UnselectRow unselects a single row of @box, if the selection mode allows
	// it.
	UnselectRow(row ListBoxRow)
}

// listBox implements the ListBox interface.
type listBox struct {
	Widget
	Accessible
	Buildable
	ConstraintTarget
}

var _ ListBox = (*listBox)(nil)

// WrapListBox wraps a GObject to the right type. It is
// primarily used internally.
func WrapListBox(obj *externglib.Object) ListBox {
	return ListBox{
		Widget:           WrapWidget(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
	}
}

func marshalListBox(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapListBox(obj), nil
}

// Append: append a widget to the list.
//
// If a sort function is set, the widget will actually be inserted at the
// calculated position.
func (b listBox) Append(child Widget) {
	var _arg0 *C.GtkListBox
	var _arg1 *C.GtkWidget

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_list_box_append(_arg0, _arg1)
}

// DragHighlightRow: add a drag highlight to a row.
//
// This is a helper function for implementing DnD onto a `GtkListBox`. The
// passed in @row will be highlighted by setting the
// GTK_STATE_FLAG_DROP_ACTIVE state and any previously highlighted row will
// be unhighlighted.
//
// The row will also be unhighlighted when the widget gets a drag leave
// event.
func (b listBox) DragHighlightRow(row ListBoxRow) {
	var _arg0 *C.GtkListBox
	var _arg1 *C.GtkListBoxRow

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkListBoxRow)(unsafe.Pointer(row.Native()))

	C.gtk_list_box_drag_highlight_row(_arg0, _arg1)
}

// DragUnhighlightRow: if a row has previously been highlighted via
// gtk_list_box_drag_highlight_row(), it will have the highlight removed.
func (b listBox) DragUnhighlightRow() {
	var _arg0 *C.GtkListBox

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))

	C.gtk_list_box_drag_unhighlight_row(_arg0)
}

// ActivateOnSingleClick returns whether rows activate on single clicks.
func (b listBox) ActivateOnSingleClick() bool {
	var _arg0 *C.GtkListBox

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))

	var _cret C.gboolean

	_cret = C.gtk_list_box_get_activate_on_single_click(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// ShowSeparators returns whether the list box should show separators
// between rows.
func (b listBox) ShowSeparators() bool {
	var _arg0 *C.GtkListBox

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))

	var _cret C.gboolean

	_cret = C.gtk_list_box_get_show_separators(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// Insert: insert the @child into the @box at @position.
//
// If a sort function is set, the widget will actually be inserted at the
// calculated position.
//
// If @position is -1, or larger than the total number of items in the @box,
// then the @child will be appended to the end.
func (b listBox) Insert(child Widget, position int) {
	var _arg0 *C.GtkListBox
	var _arg1 *C.GtkWidget
	var _arg2 C.int

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = C.int(position)

	C.gtk_list_box_insert(_arg0, _arg1, _arg2)
}

// InvalidateFilter: update the filtering for all rows.
//
// Call this when result of the filter function on the @box is changed due
// to an external factor. For instance, this would be used if the filter
// function just looked for a specific search string and the entry with the
// search string has changed.
func (b listBox) InvalidateFilter() {
	var _arg0 *C.GtkListBox

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))

	C.gtk_list_box_invalidate_filter(_arg0)
}

// InvalidateHeaders: update the separators for all rows.
//
// Call this when result of the header function on the @box is changed due
// to an external factor.
func (b listBox) InvalidateHeaders() {
	var _arg0 *C.GtkListBox

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))

	C.gtk_list_box_invalidate_headers(_arg0)
}

// InvalidateSort: update the sorting for all rows.
//
// Call this when result of the sort function on the @box is changed due to
// an external factor.
func (b listBox) InvalidateSort() {
	var _arg0 *C.GtkListBox

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))

	C.gtk_list_box_invalidate_sort(_arg0)
}

// Prepend: prepend a widget to the list.
//
// If a sort function is set, the widget will actually be inserted at the
// calculated position.
func (b listBox) Prepend(child Widget) {
	var _arg0 *C.GtkListBox
	var _arg1 *C.GtkWidget

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_list_box_prepend(_arg0, _arg1)
}

// Remove removes a child from @box.
func (b listBox) Remove(child Widget) {
	var _arg0 *C.GtkListBox
	var _arg1 *C.GtkWidget

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_list_box_remove(_arg0, _arg1)
}

// SelectAll: select all children of @box, if the selection mode allows it.
func (b listBox) SelectAll() {
	var _arg0 *C.GtkListBox

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))

	C.gtk_list_box_select_all(_arg0)
}

// SelectRow: make @row the currently selected row.
func (b listBox) SelectRow(row ListBoxRow) {
	var _arg0 *C.GtkListBox
	var _arg1 *C.GtkListBoxRow

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkListBoxRow)(unsafe.Pointer(row.Native()))

	C.gtk_list_box_select_row(_arg0, _arg1)
}

// SelectedForeach calls a function for each selected child.
//
// Note that the selection cannot be modified from within this function.
func (b listBox) SelectedForeach(fn ListBoxForeachFunc) {
	var _arg0 *C.GtkListBox
	var _arg1 C.GtkListBoxForeachFunc
	var _arg2 C.gpointer

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))
	_arg1 = (*[0]byte)(C.gotk4_ListBoxForeachFunc)
	_arg2 = C.gpointer(box.Assign(fn))

	C.gtk_list_box_selected_foreach(_arg0, _arg1, _arg2)
}

// SetActivateOnSingleClick: if @single is true, rows will be activated when
// you click on them, otherwise you need to double-click.
func (b listBox) SetActivateOnSingleClick(single bool) {
	var _arg0 *C.GtkListBox
	var _arg1 C.gboolean

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))
	if single {
		_arg1 = C.gboolean(1)
	}

	C.gtk_list_box_set_activate_on_single_click(_arg0, _arg1)
}

// SetAdjustment sets the adjustment (if any) that the widget uses to for
// vertical scrolling.
//
// For instance, this is used to get the page size for PageUp/Down key
// handling.
//
// In the normal case when the @box is packed inside a `GtkScrolledWindow`
// the adjustment from that will be picked up automatically, so there is no
// need to manually do that.
func (b listBox) SetAdjustment(adjustment Adjustment) {
	var _arg0 *C.GtkListBox
	var _arg1 *C.GtkAdjustment

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(adjustment.Native()))

	C.gtk_list_box_set_adjustment(_arg0, _arg1)
}

// SetPlaceholder sets the placeholder widget that is shown in the list when
// it doesn't display any visible children.
func (b listBox) SetPlaceholder(placeholder Widget) {
	var _arg0 *C.GtkListBox
	var _arg1 *C.GtkWidget

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(placeholder.Native()))

	C.gtk_list_box_set_placeholder(_arg0, _arg1)
}

// SetSelectionMode sets how selection works in the listbox.
func (b listBox) SetSelectionMode(mode SelectionMode) {
	var _arg0 *C.GtkListBox
	var _arg1 C.GtkSelectionMode

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))
	_arg1 = (C.GtkSelectionMode)(mode)

	C.gtk_list_box_set_selection_mode(_arg0, _arg1)
}

// SetShowSeparators sets whether the list box should show separators
// between rows.
func (b listBox) SetShowSeparators(showSeparators bool) {
	var _arg0 *C.GtkListBox
	var _arg1 C.gboolean

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))
	if showSeparators {
		_arg1 = C.gboolean(1)
	}

	C.gtk_list_box_set_show_separators(_arg0, _arg1)
}

// UnselectAll: unselect all children of @box, if the selection mode allows
// it.
func (b listBox) UnselectAll() {
	var _arg0 *C.GtkListBox

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))

	C.gtk_list_box_unselect_all(_arg0)
}

// UnselectRow unselects a single row of @box, if the selection mode allows
// it.
func (b listBox) UnselectRow(row ListBoxRow) {
	var _arg0 *C.GtkListBox
	var _arg1 *C.GtkListBoxRow

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkListBoxRow)(unsafe.Pointer(row.Native()))

	C.gtk_list_box_unselect_row(_arg0, _arg1)
}

// LockButton: `GtkLockButton` is a widget to obtain and revoke authorizations
// needed to operate the controls.
//
// !An example GtkLockButton (lock-button.png)
//
// It is typically used in preference dialogs or control panels.
//
// The required authorization is represented by a `GPermission` object. Concrete
// implementations of `GPermission` may use PolicyKit or some other
// authorization framework. To obtain a PolicyKit-based `GPermission`, use
// `polkit_permission_new()`.
//
// If the user is not currently allowed to perform the action, but can obtain
// the permission, the widget looks like this:
//
// ! (lockbutton-locked.png)
//
// and the user can click the button to request the permission. Depending on the
// platform, this may pop up an authentication dialog or ask the user to
// authenticate in some other way. Once the user has obtained the permission,
// the widget changes to this:
//
// ! (lockbutton-unlocked.png)
//
// and the permission can be dropped again by clicking the button. If the user
// is not able to obtain the permission at all, the widget looks like this:
//
// ! (lockbutton-sorry.png)
//
// If the user has the permission and cannot drop it, the button is hidden.
//
// The text (and tooltips) that are shown in the various cases can be adjusted
// with the [property@Gtk.LockButton:text-lock],
// [property@Gtk.LockButton:text-unlock],
// [property@Gtk.LockButton:tooltip-lock],
// [property@Gtk.LockButton:tooltip-unlock] and
// [property@Gtk.LockButton:tooltip-not-authorized] properties.
type LockButton interface {
	Button
	Accessible
	Actionable
	Buildable
	ConstraintTarget

	// SetPermission sets the `GPermission` object that controls @button.
	SetPermission(permission gio.Permission)
}

// lockButton implements the LockButton interface.
type lockButton struct {
	Button
	Accessible
	Actionable
	Buildable
	ConstraintTarget
}

var _ LockButton = (*lockButton)(nil)

// WrapLockButton wraps a GObject to the right type. It is
// primarily used internally.
func WrapLockButton(obj *externglib.Object) LockButton {
	return LockButton{
		Button:           WrapButton(obj),
		Accessible:       WrapAccessible(obj),
		Actionable:       WrapActionable(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
	}
}

func marshalLockButton(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapLockButton(obj), nil
}

// SetPermission sets the `GPermission` object that controls @button.
func (b lockButton) SetPermission(permission gio.Permission) {
	var _arg0 *C.GtkLockButton
	var _arg1 *C.GPermission

	_arg0 = (*C.GtkLockButton)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GPermission)(unsafe.Pointer(permission.Native()))

	C.gtk_lock_button_set_permission(_arg0, _arg1)
}

// MenuButton: the `GtkMenuButton` widget is used to display a popup when
// clicked.
//
// !An example GtkMenuButton (menu-button.png)
//
// This popup can be provided either as a `GtkPopover` or as an abstract
// `GMenuModel`.
//
// The `GtkMenuButton` widget can show either an icon (set with the
// [property@Gtk.MenuButton:icon-name] property) or a label (set with the
// [property@Gtk.MenuButton:label] property). If neither is explicitly set, a
// [class@Gtk.Image] is automatically created, using an arrow image oriented
// according to [property@Gtk.MenuButton:direction] or the generic
// “open-menu-symbolic” icon if the direction is not set.
//
// The positioning of the popup is determined by the
// [property@Gtk.MenuButton:direction] property of the menu button.
//
// For menus, the [property@Gtk.Widget:halign] and [property@Gtk.Widget:valign]
// properties of the menu are also taken into account. For example, when the
// direction is GTK_ARROW_DOWN and the horizontal alignment is GTK_ALIGN_START,
// the menu will be positioned below the button, with the starting edge
// (depending on the text direction) of the menu aligned with the starting edge
// of the button. If there is not enough space below the button, the menu is
// popped up above the button instead. If the alignment would move part of the
// menu offscreen, it is “pushed in”.
//
// | | start | center | end | | - | --- | --- | --- | | **down** | !
// (down-start.png) | ! (down-center.png) | ! (down-end.png) | | **up** | !
// (up-start.png) | ! (up-center.png) | ! (up-end.png) | | **left** | !
// (left-start.png) | ! (left-center.png) | ! (left-end.png) | | **right** | !
// (right-start.png) | ! (right-center.png) | ! (right-end.png) |
//
//
// CSS nodes
//
// “` menubutton ╰── button.toggle ╰── <content> ╰── [arrow] “`
//
// `GtkMenuButton` has a single CSS node with name `menubutton` which contains a
// `button` node with a `.toggle` style class.
//
// Inside the toggle button content, there is an `arrow` node for the indicator,
// which will carry one of the `.none`, `.up`, `.down`, `.left` or `.right`
// style classes to indicate the direction that the menu will appear in. The CSS
// is expected to provide a suitable image for each of these cases using the
// `-gtk-icon-source` property.
//
// Optionally, the `menubutton` node can carry the `.circular` style class to
// request a round appearance.
//
//
// Accessibility
//
// `GtkMenuButton` uses the K_ACCESSIBLE_ROLE_BUTTON role.
type MenuButton interface {
	Widget
	Accessible
	Buildable
	ConstraintTarget

	// HasFrame returns whether the button has a frame.
	HasFrame() bool
	// IconName gets the name of the icon shown in the button.
	IconName() string
	// Label gets the label shown in the button
	Label() string
	// UseUnderline returns whether an embedded underline in the text indicates
	// a mnemonic.
	UseUnderline() bool
	// Popdown dismiss the menu.
	Popdown()
	// Popup: pop up the menu.
	Popup()
	// SetDirection sets the direction in which the popup will be popped up.
	//
	// If the button is automatically populated with an arrow icon, its
	// direction will be changed to match.
	//
	// If the does not fit in the available space in the given direction, GTK
	// will its best to keep it inside the screen and fully visible.
	//
	// If you pass GTK_ARROW_NONE for a @direction, the popup will behave as if
	// you passed GTK_ARROW_DOWN (although you won’t see any arrows).
	SetDirection(direction ArrowType)
	// SetHasFrame sets the style of the button.
	SetHasFrame(hasFrame bool)
	// SetIconName sets the name of an icon to show inside the menu button.
	SetIconName(iconName string)
	// SetLabel sets the label to show inside the menu button.
	SetLabel(label string)
	// SetMenuModel sets the `GMenuModel` from which the popup will be
	// constructed.
	//
	// If @menu_model is nil, the button is disabled.
	//
	// A [class@Gtk.Popover] will be created from the menu model with
	// [ctor@Gtk.PopoverMenu.new_from_model]. Actions will be connected as
	// documented for this function.
	//
	// If [property@Gtk.MenuButton:popover] is already set, it will be
	// dissociated from the @menu_button, and the property is set to nil.
	SetMenuModel(menuModel gio.MenuModel)
	// SetPopover sets the `GtkPopover` that will be popped up when the
	// @menu_button is clicked.
	//
	// If @popover is nil, the button is disabled.
	//
	// If [property@Gtk.MenuButton:menu-model] is set, the menu model is
	// dissociated from the @menu_button, and the property is set to nil.
	SetPopover(popover Widget)
	// SetUseUnderline: if true, an underline in the text indicates a mnemonic.
	SetUseUnderline(useUnderline bool)
}

// menuButton implements the MenuButton interface.
type menuButton struct {
	Widget
	Accessible
	Buildable
	ConstraintTarget
}

var _ MenuButton = (*menuButton)(nil)

// WrapMenuButton wraps a GObject to the right type. It is
// primarily used internally.
func WrapMenuButton(obj *externglib.Object) MenuButton {
	return MenuButton{
		Widget:           WrapWidget(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
	}
}

func marshalMenuButton(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapMenuButton(obj), nil
}

// HasFrame returns whether the button has a frame.
func (m menuButton) HasFrame() bool {
	var _arg0 *C.GtkMenuButton

	_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))

	var _cret C.gboolean

	_cret = C.gtk_menu_button_get_has_frame(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// IconName gets the name of the icon shown in the button.
func (m menuButton) IconName() string {
	var _arg0 *C.GtkMenuButton

	_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))

	var _cret *C.char

	_cret = C.gtk_menu_button_get_icon_name(_arg0)

	var _utf8 string

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Label gets the label shown in the button
func (m menuButton) Label() string {
	var _arg0 *C.GtkMenuButton

	_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))

	var _cret *C.char

	_cret = C.gtk_menu_button_get_label(_arg0)

	var _utf8 string

	_utf8 = C.GoString(_cret)

	return _utf8
}

// UseUnderline returns whether an embedded underline in the text indicates
// a mnemonic.
func (m menuButton) UseUnderline() bool {
	var _arg0 *C.GtkMenuButton

	_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))

	var _cret C.gboolean

	_cret = C.gtk_menu_button_get_use_underline(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// Popdown dismiss the menu.
func (m menuButton) Popdown() {
	var _arg0 *C.GtkMenuButton

	_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))

	C.gtk_menu_button_popdown(_arg0)
}

// Popup: pop up the menu.
func (m menuButton) Popup() {
	var _arg0 *C.GtkMenuButton

	_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))

	C.gtk_menu_button_popup(_arg0)
}

// SetDirection sets the direction in which the popup will be popped up.
//
// If the button is automatically populated with an arrow icon, its
// direction will be changed to match.
//
// If the does not fit in the available space in the given direction, GTK
// will its best to keep it inside the screen and fully visible.
//
// If you pass GTK_ARROW_NONE for a @direction, the popup will behave as if
// you passed GTK_ARROW_DOWN (although you won’t see any arrows).
func (m menuButton) SetDirection(direction ArrowType) {
	var _arg0 *C.GtkMenuButton
	var _arg1 C.GtkArrowType

	_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))
	_arg1 = (C.GtkArrowType)(direction)

	C.gtk_menu_button_set_direction(_arg0, _arg1)
}

// SetHasFrame sets the style of the button.
func (m menuButton) SetHasFrame(hasFrame bool) {
	var _arg0 *C.GtkMenuButton
	var _arg1 C.gboolean

	_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))
	if hasFrame {
		_arg1 = C.gboolean(1)
	}

	C.gtk_menu_button_set_has_frame(_arg0, _arg1)
}

// SetIconName sets the name of an icon to show inside the menu button.
func (m menuButton) SetIconName(iconName string) {
	var _arg0 *C.GtkMenuButton
	var _arg1 *C.char

	_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.char)(C.CString(iconName))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_menu_button_set_icon_name(_arg0, _arg1)
}

// SetLabel sets the label to show inside the menu button.
func (m menuButton) SetLabel(label string) {
	var _arg0 *C.GtkMenuButton
	var _arg1 *C.char

	_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.char)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_menu_button_set_label(_arg0, _arg1)
}

// SetMenuModel sets the `GMenuModel` from which the popup will be
// constructed.
//
// If @menu_model is nil, the button is disabled.
//
// A [class@Gtk.Popover] will be created from the menu model with
// [ctor@Gtk.PopoverMenu.new_from_model]. Actions will be connected as
// documented for this function.
//
// If [property@Gtk.MenuButton:popover] is already set, it will be
// dissociated from the @menu_button, and the property is set to nil.
func (m menuButton) SetMenuModel(menuModel gio.MenuModel) {
	var _arg0 *C.GtkMenuButton
	var _arg1 *C.GMenuModel

	_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.GMenuModel)(unsafe.Pointer(menuModel.Native()))

	C.gtk_menu_button_set_menu_model(_arg0, _arg1)
}

// SetPopover sets the `GtkPopover` that will be popped up when the
// @menu_button is clicked.
//
// If @popover is nil, the button is disabled.
//
// If [property@Gtk.MenuButton:menu-model] is set, the menu model is
// dissociated from the @menu_button, and the property is set to nil.
func (m menuButton) SetPopover(popover Widget) {
	var _arg0 *C.GtkMenuButton
	var _arg1 *C.GtkWidget

	_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(popover.Native()))

	C.gtk_menu_button_set_popover(_arg0, _arg1)
}

// SetUseUnderline: if true, an underline in the text indicates a mnemonic.
func (m menuButton) SetUseUnderline(useUnderline bool) {
	var _arg0 *C.GtkMenuButton
	var _arg1 C.gboolean

	_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))
	if useUnderline {
		_arg1 = C.gboolean(1)
	}

	C.gtk_menu_button_set_use_underline(_arg0, _arg1)
}

// Notebook: `GtkNotebook` is a container whose children are pages switched
// between using tabs.
//
// !An example GtkNotebook (notebook.png)
//
// There are many configuration options for `GtkNotebook`. Among other things,
// you can choose on which edge the tabs appear (see
// [method@Gtk.Notebook.set_tab_pos]), whether, if there are too many tabs to
// fit the notebook should be made bigger or scrolling arrows added (see
// [method@Gtk.Notebook.set_scrollable]), and whether there will be a popup menu
// allowing the users to switch pages. (see [method@Gtk.Notebook.popup_enable]).
//
//
// GtkNotebook as GtkBuildable
//
// The `GtkNotebook` implementation of the `GtkBuildable` interface supports
// placing children into tabs by specifying “tab” as the “type” attribute of a
// <child> element. Note that the content of the tab must be created before the
// tab can be filled. A tab child can be specified without specifying a <child>
// type attribute.
//
// To add a child widget in the notebooks action area, specify "action-start" or
// “action-end” as the “type” attribute of the <child> element.
//
// An example of a UI definition fragment with `GtkNotebook`:
//
// “`xml <object class="GtkNotebook"> <child> <object class="GtkLabel"
// id="notebook-content"> <property name="label">Content</property> </object>
// </child> <child type="tab"> <object class="GtkLabel" id="notebook-tab">
// <property name="label">Tab</property> </object> </child> </object> “`
//
//
// CSS nodes
//
// “` notebook ├── header.top │ ├── [<action widget>] │ ├── tabs │ │ ├── [arrow]
// │ │ ├── tab │ │ │ ╰── <tab label> ┊ ┊ ┊ │ │ ├── tab[.reorderable-page] │ │ │
// ╰── <tab label> │ │ ╰── [arrow] │ ╰── [<action widget>] │ ╰── stack ├──
// <child> ┊ ╰── <child> “`
//
// `GtkNotebook` has a main CSS node with name `notebook`, a subnode with name
// `header` and below that a subnode with name `tabs` which contains one subnode
// per tab with name `tab`.
//
// If action widgets are present, their CSS nodes are placed next to the `tabs`
// node. If the notebook is scrollable, CSS nodes with name `arrow` are placed
// as first and last child of the `tabs` node.
//
// The main node gets the `.frame` style class when the notebook has a border
// (see [method@Gtk.Notebook.set_show_border]).
//
// The header node gets one of the style class `.top`, `.bottom`, `.left` or
// `.right`, depending on where the tabs are placed. For reorderable pages, the
// tab node gets the `.reorderable-page` class.
//
// A `tab` node gets the `.dnd` style class while it is moved with
// drag-and-drop.
//
// The nodes are always arranged from left-to-right, regardless of text
// direction.
//
//
// Accessibility
//
// `GtkNotebook` uses the following roles:
//
//    - GTK_ACCESSIBLE_ROLE_GROUP for the notebook widget
//    - GTK_ACCESSIBLE_ROLE_TAB_LIST for the list of tabs
//    - GTK_ACCESSIBLE_ROLE_TAB role for each tab
//    - GTK_ACCESSIBLE_ROLE_TAB_PANEL for each page
type Notebook interface {
	Widget
	Accessible
	Buildable
	ConstraintTarget

	// AppendPage appends a page to @notebook.
	AppendPage(child Widget, tabLabel Widget) int
	// AppendPageMenu appends a page to @notebook, specifying the widget to use
	// as the label in the popup menu.
	AppendPageMenu(child Widget, tabLabel Widget, menuLabel Widget) int
	// DetachTab removes the child from the notebook.
	//
	// This function is very similar to [method@Gtk.Notebook.remove_page], but
	// additionally informs the notebook that the removal is happening as part
	// of a tab DND operation, which should not be cancelled.
	DetachTab(child Widget)
	// CurrentPage returns the page number of the current page.
	CurrentPage() int
	// GroupName gets the current group name for @notebook.
	GroupName() string
	// MenuLabelText retrieves the text of the menu label for the page
	// containing @child.
	MenuLabelText(child Widget) string
	// NPages gets the number of pages in a notebook.
	NPages() int
	// Scrollable returns whether the tab label area has arrows for scrolling.
	Scrollable() bool
	// ShowBorder returns whether a bevel will be drawn around the notebook
	// pages.
	ShowBorder() bool
	// ShowTabs returns whether the tabs of the notebook are shown.
	ShowTabs() bool
	// TabDetachable returns whether the tab contents can be detached from
	// @notebook.
	TabDetachable(child Widget) bool
	// TabLabelText retrieves the text of the tab label for the page containing
	// @child.
	TabLabelText(child Widget) string
	// TabReorderable gets whether the tab can be reordered via drag and drop or
	// not.
	TabReorderable(child Widget) bool
	// InsertPage: insert a page into @notebook at the given position.
	InsertPage(child Widget, tabLabel Widget, position int) int
	// InsertPageMenu: insert a page into @notebook at the given position,
	// specifying the widget to use as the label in the popup menu.
	InsertPageMenu(child Widget, tabLabel Widget, menuLabel Widget, position int) int
	// NextPage switches to the next page.
	//
	// Nothing happens if the current page is the last page.
	NextPage()
	// PageNum finds the index of the page which contains the given child
	// widget.
	PageNum(child Widget) int
	// PopupDisable disables the popup menu.
	PopupDisable()
	// PopupEnable enables the popup menu.
	//
	// If the user clicks with the right mouse button on the tab labels, a menu
	// with all the pages will be popped up.
	PopupEnable()
	// PrependPage prepends a page to @notebook.
	PrependPage(child Widget, tabLabel Widget) int
	// PrependPageMenu prepends a page to @notebook, specifying the widget to
	// use as the label in the popup menu.
	PrependPageMenu(child Widget, tabLabel Widget, menuLabel Widget) int
	// PrevPage switches to the previous page.
	//
	// Nothing happens if the current page is the first page.
	PrevPage()
	// RemovePage removes a page from the notebook given its index in the
	// notebook.
	RemovePage(pageNum int)
	// ReorderChild reorders the page containing @child, so that it appears in
	// position @position.
	//
	// If @position is greater than or equal to the number of children in the
	// list or negative, @child will be moved to the end of the list.
	ReorderChild(child Widget, position int)
	// SetActionWidget sets @widget as one of the action widgets.
	//
	// Depending on the pack type the widget will be placed before or after the
	// tabs. You can use a `GtkBox` if you need to pack more than one widget on
	// the same side.
	SetActionWidget(widget Widget, packType PackType)
	// SetCurrentPage switches to the page number @page_num.
	//
	// Note that due to historical reasons, GtkNotebook refuses to switch to a
	// page unless the child widget is visible. Therefore, it is recommended to
	// show child widgets before adding them to a notebook.
	SetCurrentPage(pageNum int)
	// SetGroupName sets a group name for @notebook.
	//
	// Notebooks with the same name will be able to exchange tabs via drag and
	// drop. A notebook with a nil group name will not be able to exchange tabs
	// with any other notebook.
	SetGroupName(groupName string)
	// SetMenuLabel changes the menu label for the page containing @child.
	SetMenuLabel(child Widget, menuLabel Widget)
	// SetMenuLabelText creates a new label and sets it as the menu label of
	// @child.
	SetMenuLabelText(child Widget, menuText string)
	// SetScrollable sets whether the tab label area will have arrows for
	// scrolling if there are too many tabs to fit in the area.
	SetScrollable(scrollable bool)
	// SetShowBorder sets whether a bevel will be drawn around the notebook
	// pages.
	//
	// This only has a visual effect when the tabs are not shown.
	SetShowBorder(showBorder bool)
	// SetShowTabs sets whether to show the tabs for the notebook or not.
	SetShowTabs(showTabs bool)
	// SetTabDetachable sets whether the tab can be detached from @notebook to
	// another notebook or widget.
	//
	// Note that two notebooks must share a common group identificator (see
	// [method@Gtk.Notebook.set_group_name]) to allow automatic tabs interchange
	// between them.
	//
	// If you want a widget to interact with a notebook through DnD (i.e.:
	// accept dragged tabs from it) it must be set as a drop destination and
	// accept the target “GTK_NOTEBOOK_TAB”. The notebook will fill the
	// selection with a GtkWidget** pointing to the child widget that
	// corresponds to the dropped tab.
	//
	// Note that you should use [method@Gtk.Notebook.detach_tab] instead of
	// [method@Gtk.Notebook.remove_page] if you want to remove the tab from the
	// source notebook as part of accepting a drop. Otherwise, the source
	// notebook will think that the dragged tab was removed from underneath the
	// ongoing drag operation, and will initiate a drag cancel animation.
	//
	// “`c static void on_drag_data_received (GtkWidget *widget, GdkDrop *drop,
	// GtkSelectionData *data, guint time, gpointer user_data) { GtkDrag *drag;
	// GtkWidget *notebook; GtkWidget **child;
	//
	//    drag = gtk_drop_get_drag (drop);
	//    notebook = g_object_get_data (drag, "gtk-notebook-drag-origin");
	//    child = (void*) gtk_selection_data_get_data (data);
	//
	//    // process_widget (*child);
	//
	//    gtk_notebook_detach_tab (GTK_NOTEBOOK (notebook), *child);
	//
	// } “`
	//
	// If you want a notebook to accept drags from other widgets, you will have
	// to set your own DnD code to do it.
	SetTabDetachable(child Widget, detachable bool)
	// SetTabLabel changes the tab label for @child.
	//
	// If nil is specified for @tab_label, then the page will have the label
	// “page N”.
	SetTabLabel(child Widget, tabLabel Widget)
	// SetTabLabelText creates a new label and sets it as the tab label for the
	// page containing @child.
	SetTabLabelText(child Widget, tabText string)
	// SetTabPos sets the edge at which the tabs are drawn.
	SetTabPos(pos PositionType)
	// SetTabReorderable sets whether the notebook tab can be reordered via drag
	// and drop or not.
	SetTabReorderable(child Widget, reorderable bool)
}

// notebook implements the Notebook interface.
type notebook struct {
	Widget
	Accessible
	Buildable
	ConstraintTarget
}

var _ Notebook = (*notebook)(nil)

// WrapNotebook wraps a GObject to the right type. It is
// primarily used internally.
func WrapNotebook(obj *externglib.Object) Notebook {
	return Notebook{
		Widget:           WrapWidget(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
	}
}

func marshalNotebook(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapNotebook(obj), nil
}

// AppendPage appends a page to @notebook.
func (n notebook) AppendPage(child Widget, tabLabel Widget) int {
	var _arg0 *C.GtkNotebook
	var _arg1 *C.GtkWidget
	var _arg2 *C.GtkWidget

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(tabLabel.Native()))

	var _cret C.int

	_cret = C.gtk_notebook_append_page(_arg0, _arg1, _arg2)

	var _gint int

	_gint = (int)(_cret)

	return _gint
}

// AppendPageMenu appends a page to @notebook, specifying the widget to use
// as the label in the popup menu.
func (n notebook) AppendPageMenu(child Widget, tabLabel Widget, menuLabel Widget) int {
	var _arg0 *C.GtkNotebook
	var _arg1 *C.GtkWidget
	var _arg2 *C.GtkWidget
	var _arg3 *C.GtkWidget

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(tabLabel.Native()))
	_arg3 = (*C.GtkWidget)(unsafe.Pointer(menuLabel.Native()))

	var _cret C.int

	_cret = C.gtk_notebook_append_page_menu(_arg0, _arg1, _arg2, _arg3)

	var _gint int

	_gint = (int)(_cret)

	return _gint
}

// DetachTab removes the child from the notebook.
//
// This function is very similar to [method@Gtk.Notebook.remove_page], but
// additionally informs the notebook that the removal is happening as part
// of a tab DND operation, which should not be cancelled.
func (n notebook) DetachTab(child Widget) {
	var _arg0 *C.GtkNotebook
	var _arg1 *C.GtkWidget

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_notebook_detach_tab(_arg0, _arg1)
}

// CurrentPage returns the page number of the current page.
func (n notebook) CurrentPage() int {
	var _arg0 *C.GtkNotebook

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))

	var _cret C.int

	_cret = C.gtk_notebook_get_current_page(_arg0)

	var _gint int

	_gint = (int)(_cret)

	return _gint
}

// GroupName gets the current group name for @notebook.
func (n notebook) GroupName() string {
	var _arg0 *C.GtkNotebook

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))

	var _cret *C.char

	_cret = C.gtk_notebook_get_group_name(_arg0)

	var _utf8 string

	_utf8 = C.GoString(_cret)

	return _utf8
}

// MenuLabelText retrieves the text of the menu label for the page
// containing @child.
func (n notebook) MenuLabelText(child Widget) string {
	var _arg0 *C.GtkNotebook
	var _arg1 *C.GtkWidget

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	var _cret *C.char

	_cret = C.gtk_notebook_get_menu_label_text(_arg0, _arg1)

	var _utf8 string

	_utf8 = C.GoString(_cret)

	return _utf8
}

// NPages gets the number of pages in a notebook.
func (n notebook) NPages() int {
	var _arg0 *C.GtkNotebook

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))

	var _cret C.int

	_cret = C.gtk_notebook_get_n_pages(_arg0)

	var _gint int

	_gint = (int)(_cret)

	return _gint
}

// Scrollable returns whether the tab label area has arrows for scrolling.
func (n notebook) Scrollable() bool {
	var _arg0 *C.GtkNotebook

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))

	var _cret C.gboolean

	_cret = C.gtk_notebook_get_scrollable(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// ShowBorder returns whether a bevel will be drawn around the notebook
// pages.
func (n notebook) ShowBorder() bool {
	var _arg0 *C.GtkNotebook

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))

	var _cret C.gboolean

	_cret = C.gtk_notebook_get_show_border(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// ShowTabs returns whether the tabs of the notebook are shown.
func (n notebook) ShowTabs() bool {
	var _arg0 *C.GtkNotebook

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))

	var _cret C.gboolean

	_cret = C.gtk_notebook_get_show_tabs(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// TabDetachable returns whether the tab contents can be detached from
// @notebook.
func (n notebook) TabDetachable(child Widget) bool {
	var _arg0 *C.GtkNotebook
	var _arg1 *C.GtkWidget

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	var _cret C.gboolean

	_cret = C.gtk_notebook_get_tab_detachable(_arg0, _arg1)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// TabLabelText retrieves the text of the tab label for the page containing
// @child.
func (n notebook) TabLabelText(child Widget) string {
	var _arg0 *C.GtkNotebook
	var _arg1 *C.GtkWidget

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	var _cret *C.char

	_cret = C.gtk_notebook_get_tab_label_text(_arg0, _arg1)

	var _utf8 string

	_utf8 = C.GoString(_cret)

	return _utf8
}

// TabReorderable gets whether the tab can be reordered via drag and drop or
// not.
func (n notebook) TabReorderable(child Widget) bool {
	var _arg0 *C.GtkNotebook
	var _arg1 *C.GtkWidget

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	var _cret C.gboolean

	_cret = C.gtk_notebook_get_tab_reorderable(_arg0, _arg1)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// InsertPage: insert a page into @notebook at the given position.
func (n notebook) InsertPage(child Widget, tabLabel Widget, position int) int {
	var _arg0 *C.GtkNotebook
	var _arg1 *C.GtkWidget
	var _arg2 *C.GtkWidget
	var _arg3 C.int

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(tabLabel.Native()))
	_arg3 = C.int(position)

	var _cret C.int

	_cret = C.gtk_notebook_insert_page(_arg0, _arg1, _arg2, _arg3)

	var _gint int

	_gint = (int)(_cret)

	return _gint
}

// InsertPageMenu: insert a page into @notebook at the given position,
// specifying the widget to use as the label in the popup menu.
func (n notebook) InsertPageMenu(child Widget, tabLabel Widget, menuLabel Widget, position int) int {
	var _arg0 *C.GtkNotebook
	var _arg1 *C.GtkWidget
	var _arg2 *C.GtkWidget
	var _arg3 *C.GtkWidget
	var _arg4 C.int

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(tabLabel.Native()))
	_arg3 = (*C.GtkWidget)(unsafe.Pointer(menuLabel.Native()))
	_arg4 = C.int(position)

	var _cret C.int

	_cret = C.gtk_notebook_insert_page_menu(_arg0, _arg1, _arg2, _arg3, _arg4)

	var _gint int

	_gint = (int)(_cret)

	return _gint
}

// NextPage switches to the next page.
//
// Nothing happens if the current page is the last page.
func (n notebook) NextPage() {
	var _arg0 *C.GtkNotebook

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))

	C.gtk_notebook_next_page(_arg0)
}

// PageNum finds the index of the page which contains the given child
// widget.
func (n notebook) PageNum(child Widget) int {
	var _arg0 *C.GtkNotebook
	var _arg1 *C.GtkWidget

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	var _cret C.int

	_cret = C.gtk_notebook_page_num(_arg0, _arg1)

	var _gint int

	_gint = (int)(_cret)

	return _gint
}

// PopupDisable disables the popup menu.
func (n notebook) PopupDisable() {
	var _arg0 *C.GtkNotebook

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))

	C.gtk_notebook_popup_disable(_arg0)
}

// PopupEnable enables the popup menu.
//
// If the user clicks with the right mouse button on the tab labels, a menu
// with all the pages will be popped up.
func (n notebook) PopupEnable() {
	var _arg0 *C.GtkNotebook

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))

	C.gtk_notebook_popup_enable(_arg0)
}

// PrependPage prepends a page to @notebook.
func (n notebook) PrependPage(child Widget, tabLabel Widget) int {
	var _arg0 *C.GtkNotebook
	var _arg1 *C.GtkWidget
	var _arg2 *C.GtkWidget

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(tabLabel.Native()))

	var _cret C.int

	_cret = C.gtk_notebook_prepend_page(_arg0, _arg1, _arg2)

	var _gint int

	_gint = (int)(_cret)

	return _gint
}

// PrependPageMenu prepends a page to @notebook, specifying the widget to
// use as the label in the popup menu.
func (n notebook) PrependPageMenu(child Widget, tabLabel Widget, menuLabel Widget) int {
	var _arg0 *C.GtkNotebook
	var _arg1 *C.GtkWidget
	var _arg2 *C.GtkWidget
	var _arg3 *C.GtkWidget

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(tabLabel.Native()))
	_arg3 = (*C.GtkWidget)(unsafe.Pointer(menuLabel.Native()))

	var _cret C.int

	_cret = C.gtk_notebook_prepend_page_menu(_arg0, _arg1, _arg2, _arg3)

	var _gint int

	_gint = (int)(_cret)

	return _gint
}

// PrevPage switches to the previous page.
//
// Nothing happens if the current page is the first page.
func (n notebook) PrevPage() {
	var _arg0 *C.GtkNotebook

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))

	C.gtk_notebook_prev_page(_arg0)
}

// RemovePage removes a page from the notebook given its index in the
// notebook.
func (n notebook) RemovePage(pageNum int) {
	var _arg0 *C.GtkNotebook
	var _arg1 C.int

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	_arg1 = C.int(pageNum)

	C.gtk_notebook_remove_page(_arg0, _arg1)
}

// ReorderChild reorders the page containing @child, so that it appears in
// position @position.
//
// If @position is greater than or equal to the number of children in the
// list or negative, @child will be moved to the end of the list.
func (n notebook) ReorderChild(child Widget, position int) {
	var _arg0 *C.GtkNotebook
	var _arg1 *C.GtkWidget
	var _arg2 C.int

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = C.int(position)

	C.gtk_notebook_reorder_child(_arg0, _arg1, _arg2)
}

// SetActionWidget sets @widget as one of the action widgets.
//
// Depending on the pack type the widget will be placed before or after the
// tabs. You can use a `GtkBox` if you need to pack more than one widget on
// the same side.
func (n notebook) SetActionWidget(widget Widget, packType PackType) {
	var _arg0 *C.GtkNotebook
	var _arg1 *C.GtkWidget
	var _arg2 C.GtkPackType

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	_arg2 = (C.GtkPackType)(packType)

	C.gtk_notebook_set_action_widget(_arg0, _arg1, _arg2)
}

// SetCurrentPage switches to the page number @page_num.
//
// Note that due to historical reasons, GtkNotebook refuses to switch to a
// page unless the child widget is visible. Therefore, it is recommended to
// show child widgets before adding them to a notebook.
func (n notebook) SetCurrentPage(pageNum int) {
	var _arg0 *C.GtkNotebook
	var _arg1 C.int

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	_arg1 = C.int(pageNum)

	C.gtk_notebook_set_current_page(_arg0, _arg1)
}

// SetGroupName sets a group name for @notebook.
//
// Notebooks with the same name will be able to exchange tabs via drag and
// drop. A notebook with a nil group name will not be able to exchange tabs
// with any other notebook.
func (n notebook) SetGroupName(groupName string) {
	var _arg0 *C.GtkNotebook
	var _arg1 *C.char

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.char)(C.CString(groupName))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_notebook_set_group_name(_arg0, _arg1)
}

// SetMenuLabel changes the menu label for the page containing @child.
func (n notebook) SetMenuLabel(child Widget, menuLabel Widget) {
	var _arg0 *C.GtkNotebook
	var _arg1 *C.GtkWidget
	var _arg2 *C.GtkWidget

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(menuLabel.Native()))

	C.gtk_notebook_set_menu_label(_arg0, _arg1, _arg2)
}

// SetMenuLabelText creates a new label and sets it as the menu label of
// @child.
func (n notebook) SetMenuLabelText(child Widget, menuText string) {
	var _arg0 *C.GtkNotebook
	var _arg1 *C.GtkWidget
	var _arg2 *C.char

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.char)(C.CString(menuText))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_notebook_set_menu_label_text(_arg0, _arg1, _arg2)
}

// SetScrollable sets whether the tab label area will have arrows for
// scrolling if there are too many tabs to fit in the area.
func (n notebook) SetScrollable(scrollable bool) {
	var _arg0 *C.GtkNotebook
	var _arg1 C.gboolean

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	if scrollable {
		_arg1 = C.gboolean(1)
	}

	C.gtk_notebook_set_scrollable(_arg0, _arg1)
}

// SetShowBorder sets whether a bevel will be drawn around the notebook
// pages.
//
// This only has a visual effect when the tabs are not shown.
func (n notebook) SetShowBorder(showBorder bool) {
	var _arg0 *C.GtkNotebook
	var _arg1 C.gboolean

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	if showBorder {
		_arg1 = C.gboolean(1)
	}

	C.gtk_notebook_set_show_border(_arg0, _arg1)
}

// SetShowTabs sets whether to show the tabs for the notebook or not.
func (n notebook) SetShowTabs(showTabs bool) {
	var _arg0 *C.GtkNotebook
	var _arg1 C.gboolean

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	if showTabs {
		_arg1 = C.gboolean(1)
	}

	C.gtk_notebook_set_show_tabs(_arg0, _arg1)
}

// SetTabDetachable sets whether the tab can be detached from @notebook to
// another notebook or widget.
//
// Note that two notebooks must share a common group identificator (see
// [method@Gtk.Notebook.set_group_name]) to allow automatic tabs interchange
// between them.
//
// If you want a widget to interact with a notebook through DnD (i.e.:
// accept dragged tabs from it) it must be set as a drop destination and
// accept the target “GTK_NOTEBOOK_TAB”. The notebook will fill the
// selection with a GtkWidget** pointing to the child widget that
// corresponds to the dropped tab.
//
// Note that you should use [method@Gtk.Notebook.detach_tab] instead of
// [method@Gtk.Notebook.remove_page] if you want to remove the tab from the
// source notebook as part of accepting a drop. Otherwise, the source
// notebook will think that the dragged tab was removed from underneath the
// ongoing drag operation, and will initiate a drag cancel animation.
//
// “`c static void on_drag_data_received (GtkWidget *widget, GdkDrop *drop,
// GtkSelectionData *data, guint time, gpointer user_data) { GtkDrag *drag;
// GtkWidget *notebook; GtkWidget **child;
//
//    drag = gtk_drop_get_drag (drop);
//    notebook = g_object_get_data (drag, "gtk-notebook-drag-origin");
//    child = (void*) gtk_selection_data_get_data (data);
//
//    // process_widget (*child);
//
//    gtk_notebook_detach_tab (GTK_NOTEBOOK (notebook), *child);
//
// } “`
//
// If you want a notebook to accept drags from other widgets, you will have
// to set your own DnD code to do it.
func (n notebook) SetTabDetachable(child Widget, detachable bool) {
	var _arg0 *C.GtkNotebook
	var _arg1 *C.GtkWidget
	var _arg2 C.gboolean

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	if detachable {
		_arg2 = C.gboolean(1)
	}

	C.gtk_notebook_set_tab_detachable(_arg0, _arg1, _arg2)
}

// SetTabLabel changes the tab label for @child.
//
// If nil is specified for @tab_label, then the page will have the label
// “page N”.
func (n notebook) SetTabLabel(child Widget, tabLabel Widget) {
	var _arg0 *C.GtkNotebook
	var _arg1 *C.GtkWidget
	var _arg2 *C.GtkWidget

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(tabLabel.Native()))

	C.gtk_notebook_set_tab_label(_arg0, _arg1, _arg2)
}

// SetTabLabelText creates a new label and sets it as the tab label for the
// page containing @child.
func (n notebook) SetTabLabelText(child Widget, tabText string) {
	var _arg0 *C.GtkNotebook
	var _arg1 *C.GtkWidget
	var _arg2 *C.char

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.char)(C.CString(tabText))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_notebook_set_tab_label_text(_arg0, _arg1, _arg2)
}

// SetTabPos sets the edge at which the tabs are drawn.
func (n notebook) SetTabPos(pos PositionType) {
	var _arg0 *C.GtkNotebook
	var _arg1 C.GtkPositionType

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	_arg1 = (C.GtkPositionType)(pos)

	C.gtk_notebook_set_tab_pos(_arg0, _arg1)
}

// SetTabReorderable sets whether the notebook tab can be reordered via drag
// and drop or not.
func (n notebook) SetTabReorderable(child Widget, reorderable bool) {
	var _arg0 *C.GtkNotebook
	var _arg1 *C.GtkWidget
	var _arg2 C.gboolean

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	if reorderable {
		_arg2 = C.gboolean(1)
	}

	C.gtk_notebook_set_tab_reorderable(_arg0, _arg1, _arg2)
}

// NotebookPage: `GtkNotebookPage` is an auxiliary object used by `GtkNotebook`.
type NotebookPage interface {
	gextras.Objector
}

// notebookPage implements the NotebookPage interface.
type notebookPage struct {
	gextras.Objector
}

var _ NotebookPage = (*notebookPage)(nil)

// WrapNotebookPage wraps a GObject to the right type. It is
// primarily used internally.
func WrapNotebookPage(obj *externglib.Object) NotebookPage {
	return NotebookPage{
		Objector: obj,
	}
}

func marshalNotebookPage(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapNotebookPage(obj), nil
}

// Overlay: `GtkOverlay` is a container which contains a single main child, on
// top of which it can place “overlay” widgets.
//
// !An example GtkOverlay (overlay.png)
//
// The position of each overlay widget is determined by its
// [property@Gtk.Widget:halign] and [property@Gtk.Widget:valign] properties.
// E.g. a widget with both alignments set to GTK_ALIGN_START will be placed at
// the top left corner of the `GtkOverlay` container, whereas an overlay with
// halign set to GTK_ALIGN_CENTER and valign set to GTK_ALIGN_END will be placed
// a the bottom edge of the `GtkOverlay`, horizontally centered. The position
// can be adjusted by setting the margin properties of the child to non-zero
// values.
//
// More complicated placement of overlays is possible by connecting to the
// [signal@Gtk.Overlay::get-child-position] signal.
//
// An overlay’s minimum and natural sizes are those of its main child. The sizes
// of overlay children are not considered when measuring these preferred sizes.
//
//
// GtkOverlay as GtkBuildable
//
// The `GtkOverlay` implementation of the `GtkBuildable` interface supports
// placing a child as an overlay by specifying “overlay” as the “type” attribute
// of a `<child>` element.
//
//
// CSS nodes
//
// `GtkOverlay` has a single CSS node with the name “overlay”. Overlay children
// whose alignments cause them to be positioned at an edge get the style classes
// “.left”, “.right”, “.top”, and/or “.bottom” according to their position.
type Overlay interface {
	Widget
	Accessible
	Buildable
	ConstraintTarget

	// AddOverlay adds @widget to @overlay.
	//
	// The widget will be stacked on top of the main widget added with
	// [method@Gtk.Overlay.set_child].
	//
	// The position at which @widget is placed is determined from its
	// [property@Gtk.Widget:halign] and [property@Gtk.Widget:valign] properties.
	AddOverlay(widget Widget)
	// ClipOverlay gets whether @widget should be clipped within the parent.
	ClipOverlay(widget Widget) bool
	// MeasureOverlay gets whether @widget's size is included in the measurement
	// of @overlay.
	MeasureOverlay(widget Widget) bool
	// RemoveOverlay removes an overlay that was added with
	// gtk_overlay_add_overlay().
	RemoveOverlay(widget Widget)
	// SetChild sets the child widget of @overlay.
	SetChild(child Widget)
	// SetClipOverlay sets whether @widget should be clipped within the parent.
	SetClipOverlay(widget Widget, clipOverlay bool)
	// SetMeasureOverlay sets whether @widget is included in the measured size
	// of @overlay.
	//
	// The overlay will request the size of the largest child that has this
	// property set to true. Children who are not included may be drawn outside
	// of @overlay's allocation if they are too large.
	SetMeasureOverlay(widget Widget, measure bool)
}

// overlay implements the Overlay interface.
type overlay struct {
	Widget
	Accessible
	Buildable
	ConstraintTarget
}

var _ Overlay = (*overlay)(nil)

// WrapOverlay wraps a GObject to the right type. It is
// primarily used internally.
func WrapOverlay(obj *externglib.Object) Overlay {
	return Overlay{
		Widget:           WrapWidget(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
	}
}

func marshalOverlay(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapOverlay(obj), nil
}

// AddOverlay adds @widget to @overlay.
//
// The widget will be stacked on top of the main widget added with
// [method@Gtk.Overlay.set_child].
//
// The position at which @widget is placed is determined from its
// [property@Gtk.Widget:halign] and [property@Gtk.Widget:valign] properties.
func (o overlay) AddOverlay(widget Widget) {
	var _arg0 *C.GtkOverlay
	var _arg1 *C.GtkWidget

	_arg0 = (*C.GtkOverlay)(unsafe.Pointer(o.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	C.gtk_overlay_add_overlay(_arg0, _arg1)
}

// ClipOverlay gets whether @widget should be clipped within the parent.
func (o overlay) ClipOverlay(widget Widget) bool {
	var _arg0 *C.GtkOverlay
	var _arg1 *C.GtkWidget

	_arg0 = (*C.GtkOverlay)(unsafe.Pointer(o.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	var _cret C.gboolean

	_cret = C.gtk_overlay_get_clip_overlay(_arg0, _arg1)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// MeasureOverlay gets whether @widget's size is included in the measurement
// of @overlay.
func (o overlay) MeasureOverlay(widget Widget) bool {
	var _arg0 *C.GtkOverlay
	var _arg1 *C.GtkWidget

	_arg0 = (*C.GtkOverlay)(unsafe.Pointer(o.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	var _cret C.gboolean

	_cret = C.gtk_overlay_get_measure_overlay(_arg0, _arg1)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// RemoveOverlay removes an overlay that was added with
// gtk_overlay_add_overlay().
func (o overlay) RemoveOverlay(widget Widget) {
	var _arg0 *C.GtkOverlay
	var _arg1 *C.GtkWidget

	_arg0 = (*C.GtkOverlay)(unsafe.Pointer(o.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	C.gtk_overlay_remove_overlay(_arg0, _arg1)
}

// SetChild sets the child widget of @overlay.
func (o overlay) SetChild(child Widget) {
	var _arg0 *C.GtkOverlay
	var _arg1 *C.GtkWidget

	_arg0 = (*C.GtkOverlay)(unsafe.Pointer(o.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_overlay_set_child(_arg0, _arg1)
}

// SetClipOverlay sets whether @widget should be clipped within the parent.
func (o overlay) SetClipOverlay(widget Widget, clipOverlay bool) {
	var _arg0 *C.GtkOverlay
	var _arg1 *C.GtkWidget
	var _arg2 C.gboolean

	_arg0 = (*C.GtkOverlay)(unsafe.Pointer(o.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	if clipOverlay {
		_arg2 = C.gboolean(1)
	}

	C.gtk_overlay_set_clip_overlay(_arg0, _arg1, _arg2)
}

// SetMeasureOverlay sets whether @widget is included in the measured size
// of @overlay.
//
// The overlay will request the size of the largest child that has this
// property set to true. Children who are not included may be drawn outside
// of @overlay's allocation if they are too large.
func (o overlay) SetMeasureOverlay(widget Widget, measure bool) {
	var _arg0 *C.GtkOverlay
	var _arg1 *C.GtkWidget
	var _arg2 C.gboolean

	_arg0 = (*C.GtkOverlay)(unsafe.Pointer(o.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	if measure {
		_arg2 = C.gboolean(1)
	}

	C.gtk_overlay_set_measure_overlay(_arg0, _arg1, _arg2)
}

// PageSetup: a `GtkPageSetup` object stores the page size, orientation and
// margins.
//
// The idea is that you can get one of these from the page setup dialog and then
// pass it to the `GtkPrintOperation` when printing. The benefit of splitting
// this out of the `GtkPrintSettings` is that these affect the actual layout of
// the page, and thus need to be set long before user prints.
//
//
// Margins
//
// The margins specified in this object are the “print margins”, i.e. the parts
// of the page that the printer cannot print on. These are different from the
// layout margins that a word processor uses; they are typically used to
// determine the minimal size for the layout margins.
//
// To obtain a `GtkPageSetup` use [ctor@Gtk.PageSetup.new] to get the defaults,
// or use [func@Gtk.print_run_page_setup_dialog] to show the page setup dialog
// and receive the resulting page setup.
//
//
// A page setup dialog
//
// “`c static GtkPrintSettings *settings = NULL; static GtkPageSetup *page_setup
// = NULL;
//
// static void do_page_setup (void) { GtkPageSetup *new_page_setup;
//
//    if (settings == NULL)
//      settings = gtk_print_settings_new ();
//
//    new_page_setup = gtk_print_run_page_setup_dialog (GTK_WINDOW (main_window),
//                                                      page_setup, settings);
//
//    if (page_setup)
//      g_object_unref (page_setup);
//
//    page_setup = new_page_setup;
//
// } “`
type PageSetup interface {
	gextras.Objector

	// BottomMargin gets the bottom margin in units of @unit.
	BottomMargin(unit Unit) float64
	// LeftMargin gets the left margin in units of @unit.
	LeftMargin(unit Unit) float64
	// PageHeight returns the page height in units of @unit.
	//
	// Note that this function takes orientation and margins into consideration.
	// See [method@Gtk.PageSetup.get_paper_height].
	PageHeight(unit Unit) float64
	// PageWidth returns the page width in units of @unit.
	//
	// Note that this function takes orientation and margins into consideration.
	// See [method@Gtk.PageSetup.get_paper_width].
	PageWidth(unit Unit) float64
	// PaperHeight returns the paper height in units of @unit.
	//
	// Note that this function takes orientation, but not margins into
	// consideration. See [method@Gtk.PageSetup.get_page_height].
	PaperHeight(unit Unit) float64
	// PaperWidth returns the paper width in units of @unit.
	//
	// Note that this function takes orientation, but not margins into
	// consideration. See [method@Gtk.PageSetup.get_page_width].
	PaperWidth(unit Unit) float64
	// RightMargin gets the right margin in units of @unit.
	RightMargin(unit Unit) float64
	// TopMargin gets the top margin in units of @unit.
	TopMargin(unit Unit) float64
	// LoadFile reads the page setup from the file @file_name.
	//
	// See [method@Gtk.PageSetup.to_file].
	LoadFile(fileName *string) error
	// LoadKeyFile reads the page setup from the group @group_name in the key
	// file @key_file.
	LoadKeyFile(keyFile *glib.KeyFile, groupName string) error
	// SetBottomMargin sets the bottom margin of the `GtkPageSetup`.
	SetBottomMargin(margin float64, unit Unit)
	// SetLeftMargin sets the left margin of the `GtkPageSetup`.
	SetLeftMargin(margin float64, unit Unit)
	// SetOrientation sets the page orientation of the `GtkPageSetup`.
	SetOrientation(orientation PageOrientation)
	// SetPaperSize sets the paper size of the `GtkPageSetup` without changing
	// the margins.
	//
	// See [method@Gtk.PageSetup.set_paper_size_and_default_margins].
	SetPaperSize(size *PaperSize)
	// SetPaperSizeAndDefaultMargins sets the paper size of the `GtkPageSetup`
	// and modifies the margins according to the new paper size.
	SetPaperSizeAndDefaultMargins(size *PaperSize)
	// SetRightMargin sets the right margin of the `GtkPageSetup`.
	SetRightMargin(margin float64, unit Unit)
	// SetTopMargin sets the top margin of the `GtkPageSetup`.
	SetTopMargin(margin float64, unit Unit)
	// ToFile: this function saves the information from @setup to @file_name.
	ToFile(fileName *string) error
	// ToKeyFile: this function adds the page setup from @setup to @key_file.
	ToKeyFile(keyFile *glib.KeyFile, groupName string)
}

// pageSetup implements the PageSetup interface.
type pageSetup struct {
	gextras.Objector
}

var _ PageSetup = (*pageSetup)(nil)

// WrapPageSetup wraps a GObject to the right type. It is
// primarily used internally.
func WrapPageSetup(obj *externglib.Object) PageSetup {
	return PageSetup{
		Objector: obj,
	}
}

func marshalPageSetup(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPageSetup(obj), nil
}

// BottomMargin gets the bottom margin in units of @unit.
func (s pageSetup) BottomMargin(unit Unit) float64 {
	var _arg0 *C.GtkPageSetup
	var _arg1 C.GtkUnit

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkUnit)(unit)

	var _cret C.double

	_cret = C.gtk_page_setup_get_bottom_margin(_arg0, _arg1)

	var _gdouble float64

	_gdouble = (float64)(_cret)

	return _gdouble
}

// LeftMargin gets the left margin in units of @unit.
func (s pageSetup) LeftMargin(unit Unit) float64 {
	var _arg0 *C.GtkPageSetup
	var _arg1 C.GtkUnit

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkUnit)(unit)

	var _cret C.double

	_cret = C.gtk_page_setup_get_left_margin(_arg0, _arg1)

	var _gdouble float64

	_gdouble = (float64)(_cret)

	return _gdouble
}

// PageHeight returns the page height in units of @unit.
//
// Note that this function takes orientation and margins into consideration.
// See [method@Gtk.PageSetup.get_paper_height].
func (s pageSetup) PageHeight(unit Unit) float64 {
	var _arg0 *C.GtkPageSetup
	var _arg1 C.GtkUnit

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkUnit)(unit)

	var _cret C.double

	_cret = C.gtk_page_setup_get_page_height(_arg0, _arg1)

	var _gdouble float64

	_gdouble = (float64)(_cret)

	return _gdouble
}

// PageWidth returns the page width in units of @unit.
//
// Note that this function takes orientation and margins into consideration.
// See [method@Gtk.PageSetup.get_paper_width].
func (s pageSetup) PageWidth(unit Unit) float64 {
	var _arg0 *C.GtkPageSetup
	var _arg1 C.GtkUnit

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkUnit)(unit)

	var _cret C.double

	_cret = C.gtk_page_setup_get_page_width(_arg0, _arg1)

	var _gdouble float64

	_gdouble = (float64)(_cret)

	return _gdouble
}

// PaperHeight returns the paper height in units of @unit.
//
// Note that this function takes orientation, but not margins into
// consideration. See [method@Gtk.PageSetup.get_page_height].
func (s pageSetup) PaperHeight(unit Unit) float64 {
	var _arg0 *C.GtkPageSetup
	var _arg1 C.GtkUnit

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkUnit)(unit)

	var _cret C.double

	_cret = C.gtk_page_setup_get_paper_height(_arg0, _arg1)

	var _gdouble float64

	_gdouble = (float64)(_cret)

	return _gdouble
}

// PaperWidth returns the paper width in units of @unit.
//
// Note that this function takes orientation, but not margins into
// consideration. See [method@Gtk.PageSetup.get_page_width].
func (s pageSetup) PaperWidth(unit Unit) float64 {
	var _arg0 *C.GtkPageSetup
	var _arg1 C.GtkUnit

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkUnit)(unit)

	var _cret C.double

	_cret = C.gtk_page_setup_get_paper_width(_arg0, _arg1)

	var _gdouble float64

	_gdouble = (float64)(_cret)

	return _gdouble
}

// RightMargin gets the right margin in units of @unit.
func (s pageSetup) RightMargin(unit Unit) float64 {
	var _arg0 *C.GtkPageSetup
	var _arg1 C.GtkUnit

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkUnit)(unit)

	var _cret C.double

	_cret = C.gtk_page_setup_get_right_margin(_arg0, _arg1)

	var _gdouble float64

	_gdouble = (float64)(_cret)

	return _gdouble
}

// TopMargin gets the top margin in units of @unit.
func (s pageSetup) TopMargin(unit Unit) float64 {
	var _arg0 *C.GtkPageSetup
	var _arg1 C.GtkUnit

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkUnit)(unit)

	var _cret C.double

	_cret = C.gtk_page_setup_get_top_margin(_arg0, _arg1)

	var _gdouble float64

	_gdouble = (float64)(_cret)

	return _gdouble
}

// LoadFile reads the page setup from the file @file_name.
//
// See [method@Gtk.PageSetup.to_file].
func (s pageSetup) LoadFile(fileName *string) error {
	var _arg0 *C.GtkPageSetup
	var _arg1 *C.char

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(fileName))
	defer C.free(unsafe.Pointer(_arg1))

	var _cerr *C.GError

	C.gtk_page_setup_load_file(_arg0, _arg1, _cerr)

	var _goerr error

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// LoadKeyFile reads the page setup from the group @group_name in the key
// file @key_file.
func (s pageSetup) LoadKeyFile(keyFile *glib.KeyFile, groupName string) error {
	var _arg0 *C.GtkPageSetup
	var _arg1 *C.GKeyFile
	var _arg2 *C.char

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GKeyFile)(unsafe.Pointer(keyFile.Native()))
	_arg2 = (*C.char)(C.CString(groupName))
	defer C.free(unsafe.Pointer(_arg2))

	var _cerr *C.GError

	C.gtk_page_setup_load_key_file(_arg0, _arg1, _arg2, _cerr)

	var _goerr error

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// SetBottomMargin sets the bottom margin of the `GtkPageSetup`.
func (s pageSetup) SetBottomMargin(margin float64, unit Unit) {
	var _arg0 *C.GtkPageSetup
	var _arg1 C.double
	var _arg2 C.GtkUnit

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	_arg1 = C.double(margin)
	_arg2 = (C.GtkUnit)(unit)

	C.gtk_page_setup_set_bottom_margin(_arg0, _arg1, _arg2)
}

// SetLeftMargin sets the left margin of the `GtkPageSetup`.
func (s pageSetup) SetLeftMargin(margin float64, unit Unit) {
	var _arg0 *C.GtkPageSetup
	var _arg1 C.double
	var _arg2 C.GtkUnit

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	_arg1 = C.double(margin)
	_arg2 = (C.GtkUnit)(unit)

	C.gtk_page_setup_set_left_margin(_arg0, _arg1, _arg2)
}

// SetOrientation sets the page orientation of the `GtkPageSetup`.
func (s pageSetup) SetOrientation(orientation PageOrientation) {
	var _arg0 *C.GtkPageSetup
	var _arg1 C.GtkPageOrientation

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkPageOrientation)(orientation)

	C.gtk_page_setup_set_orientation(_arg0, _arg1)
}

// SetPaperSize sets the paper size of the `GtkPageSetup` without changing
// the margins.
//
// See [method@Gtk.PageSetup.set_paper_size_and_default_margins].
func (s pageSetup) SetPaperSize(size *PaperSize) {
	var _arg0 *C.GtkPageSetup
	var _arg1 *C.GtkPaperSize

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkPaperSize)(unsafe.Pointer(size.Native()))

	C.gtk_page_setup_set_paper_size(_arg0, _arg1)
}

// SetPaperSizeAndDefaultMargins sets the paper size of the `GtkPageSetup`
// and modifies the margins according to the new paper size.
func (s pageSetup) SetPaperSizeAndDefaultMargins(size *PaperSize) {
	var _arg0 *C.GtkPageSetup
	var _arg1 *C.GtkPaperSize

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkPaperSize)(unsafe.Pointer(size.Native()))

	C.gtk_page_setup_set_paper_size_and_default_margins(_arg0, _arg1)
}

// SetRightMargin sets the right margin of the `GtkPageSetup`.
func (s pageSetup) SetRightMargin(margin float64, unit Unit) {
	var _arg0 *C.GtkPageSetup
	var _arg1 C.double
	var _arg2 C.GtkUnit

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	_arg1 = C.double(margin)
	_arg2 = (C.GtkUnit)(unit)

	C.gtk_page_setup_set_right_margin(_arg0, _arg1, _arg2)
}

// SetTopMargin sets the top margin of the `GtkPageSetup`.
func (s pageSetup) SetTopMargin(margin float64, unit Unit) {
	var _arg0 *C.GtkPageSetup
	var _arg1 C.double
	var _arg2 C.GtkUnit

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	_arg1 = C.double(margin)
	_arg2 = (C.GtkUnit)(unit)

	C.gtk_page_setup_set_top_margin(_arg0, _arg1, _arg2)
}

// ToFile: this function saves the information from @setup to @file_name.
func (s pageSetup) ToFile(fileName *string) error {
	var _arg0 *C.GtkPageSetup
	var _arg1 *C.char

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(fileName))
	defer C.free(unsafe.Pointer(_arg1))

	var _cerr *C.GError

	C.gtk_page_setup_to_file(_arg0, _arg1, _cerr)

	var _goerr error

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// ToKeyFile: this function adds the page setup from @setup to @key_file.
func (s pageSetup) ToKeyFile(keyFile *glib.KeyFile, groupName string) {
	var _arg0 *C.GtkPageSetup
	var _arg1 *C.GKeyFile
	var _arg2 *C.char

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GKeyFile)(unsafe.Pointer(keyFile.Native()))
	_arg2 = (*C.char)(C.CString(groupName))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_page_setup_to_key_file(_arg0, _arg1, _arg2)
}

// PageSetupUnixDialog: `GtkPageSetupUnixDialog` implements a page setup dialog
// for platforms which don’t provide a native page setup dialog, like Unix.
//
// !An example GtkPageSetupUnixDialog (pagesetupdialog.png)
//
// It can be used very much like any other GTK dialog, at the cost of the
// portability offered by the high-level printing API in
// [class@Gtk.PrintOperation].
type PageSetupUnixDialog interface {
	Dialog
	Accessible
	Buildable
	ConstraintTarget
	Native
	Root
	ShortcutManager

	// SetPageSetup sets the `GtkPageSetup` from which the page setup dialog
	// takes its values.
	SetPageSetup(pageSetup PageSetup)
	// SetPrintSettings sets the `GtkPrintSettings` from which the page setup
	// dialog takes its values.
	SetPrintSettings(printSettings PrintSettings)
}

// pageSetupUnixDialog implements the PageSetupUnixDialog interface.
type pageSetupUnixDialog struct {
	Dialog
	Accessible
	Buildable
	ConstraintTarget
	Native
	Root
	ShortcutManager
}

var _ PageSetupUnixDialog = (*pageSetupUnixDialog)(nil)

// WrapPageSetupUnixDialog wraps a GObject to the right type. It is
// primarily used internally.
func WrapPageSetupUnixDialog(obj *externglib.Object) PageSetupUnixDialog {
	return PageSetupUnixDialog{
		Dialog:           WrapDialog(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
		Native:           WrapNative(obj),
		Root:             WrapRoot(obj),
		ShortcutManager:  WrapShortcutManager(obj),
	}
}

func marshalPageSetupUnixDialog(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPageSetupUnixDialog(obj), nil
}

// SetPageSetup sets the `GtkPageSetup` from which the page setup dialog
// takes its values.
func (d pageSetupUnixDialog) SetPageSetup(pageSetup PageSetup) {
	var _arg0 *C.GtkPageSetupUnixDialog
	var _arg1 *C.GtkPageSetup

	_arg0 = (*C.GtkPageSetupUnixDialog)(unsafe.Pointer(d.Native()))
	_arg1 = (*C.GtkPageSetup)(unsafe.Pointer(pageSetup.Native()))

	C.gtk_page_setup_unix_dialog_set_page_setup(_arg0, _arg1)
}

// SetPrintSettings sets the `GtkPrintSettings` from which the page setup
// dialog takes its values.
func (d pageSetupUnixDialog) SetPrintSettings(printSettings PrintSettings) {
	var _arg0 *C.GtkPageSetupUnixDialog
	var _arg1 *C.GtkPrintSettings

	_arg0 = (*C.GtkPageSetupUnixDialog)(unsafe.Pointer(d.Native()))
	_arg1 = (*C.GtkPrintSettings)(unsafe.Pointer(printSettings.Native()))

	C.gtk_page_setup_unix_dialog_set_print_settings(_arg0, _arg1)
}

// Paned: `GtkPaned` has two panes, arranged either horizontally or vertically.
//
// !An example GtkPaned (panes.png)
//
// The division between the two panes is adjustable by the user by dragging a
// handle.
//
// Child widgets are added to the panes of the widget with
// [method@Gtk.Paned.set_start_child] and [method@Gtk.Paned.set_end_child]. The
// division between the two children is set by default from the size requests of
// the children, but it can be adjusted by the user.
//
// A paned widget draws a separator between the two child widgets and a small
// handle that the user can drag to adjust the division. It does not draw any
// relief around the children or around the separator. (The space in which the
// separator is called the gutter.) Often, it is useful to put each child inside
// a [class@Gtk.Frame] so that the gutter appears as a ridge. No separator is
// drawn if one of the children is missing.
//
// Each child has two options that can be set, @resize and @shrink. If @resize
// is true, then when the `GtkPaned` is resized, that child will expand or
// shrink along with the paned widget. If @shrink is true, then that child can
// be made smaller than its requisition by the user. Setting @shrink to false
// allows the application to set a minimum size. If @resize is false for both
// children, then this is treated as if @resize is true for both children.
//
// The application can set the position of the slider as if it were set by the
// user, by calling [method@Gtk.Paned.set_position].
//
//
// CSS nodes
//
// “` paned ├── <child> ├── separator[.wide] ╰── <child> “`
//
// `GtkPaned` has a main CSS node with name paned, and a subnode for the
// separator with name separator. The subnode gets a .wide style class when the
// paned is supposed to be wide.
//
// In horizontal orientation, the nodes are arranged based on the text
// direction, so in left-to-right mode, :first-child will select the leftmost
// child, while it will select the rightmost child in RTL layouts.
//
// Creating a paned widget with minimum sizes.
//
// “`c GtkWidget *hpaned = gtk_paned_new (GTK_ORIENTATION_HORIZONTAL); GtkWidget
// *frame1 = gtk_frame_new (NULL); GtkWidget *frame2 = gtk_frame_new (NULL);
//
// gtk_widget_set_size_request (hpaned, 200, -1);
//
// gtk_paned_set_start_child (GTK_PANED (hpaned), frame1);
// gtk_paned_set_start_child_resize (GTK_PANED (hpaned), TRUE);
// gtk_paned_set_start_child_shrink (GTK_PANED (hpaned), FALSE);
// gtk_widget_set_size_request (frame1, 50, -1);
//
// gtk_paned_set_end_child (GTK_PANED (hpaned), frame2);
// gtk_paned_set_end_child_resize (GTK_PANED (hpaned), FALSE);
// gtk_paned_set_end_child_shrink (GTK_PANED (hpaned), FALSE);
// gtk_widget_set_size_request (frame2, 50, -1); “`
type Paned interface {
	Widget
	Accessible
	Buildable
	ConstraintTarget
	Orientable

	// Position obtains the position of the divider between the two panes.
	Position() int
	// ResizeEndChild returns whether the end child can be resized.
	ResizeEndChild() bool
	// ResizeStartChild returns whether the start child can be resized.
	ResizeStartChild() bool
	// ShrinkEndChild returns whether the end child can be shrunk.
	ShrinkEndChild() bool
	// ShrinkStartChild returns whether the start child can be shrunk.
	ShrinkStartChild() bool
	// WideHandle gets whether the separator should be wide.
	WideHandle() bool
	// SetEndChild sets the end child of @paned to @child.
	SetEndChild(child Widget)
	// SetPosition sets the position of the divider between the two panes.
	SetPosition(position int)
	// SetResizeEndChild sets the `GtkPaned`:resize-end-child property
	SetResizeEndChild(resize bool)
	// SetResizeStartChild sets the `GtkPaned`:resize-start-child property
	SetResizeStartChild(resize bool)
	// SetShrinkEndChild sets the `GtkPaned`:shrink-end-child property
	SetShrinkEndChild(resize bool)
	// SetShrinkStartChild sets the `GtkPaned`:shrink-start-child property
	SetShrinkStartChild(resize bool)
	// SetStartChild sets the start child of @paned to @child.
	SetStartChild(child Widget)
	// SetWideHandle sets whether the separator should be wide.
	SetWideHandle(wide bool)
}

// paned implements the Paned interface.
type paned struct {
	Widget
	Accessible
	Buildable
	ConstraintTarget
	Orientable
}

var _ Paned = (*paned)(nil)

// WrapPaned wraps a GObject to the right type. It is
// primarily used internally.
func WrapPaned(obj *externglib.Object) Paned {
	return Paned{
		Widget:           WrapWidget(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
		Orientable:       WrapOrientable(obj),
	}
}

func marshalPaned(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPaned(obj), nil
}

// Position obtains the position of the divider between the two panes.
func (p paned) Position() int {
	var _arg0 *C.GtkPaned

	_arg0 = (*C.GtkPaned)(unsafe.Pointer(p.Native()))

	var _cret C.int

	_cret = C.gtk_paned_get_position(_arg0)

	var _gint int

	_gint = (int)(_cret)

	return _gint
}

// ResizeEndChild returns whether the end child can be resized.
func (p paned) ResizeEndChild() bool {
	var _arg0 *C.GtkPaned

	_arg0 = (*C.GtkPaned)(unsafe.Pointer(p.Native()))

	var _cret C.gboolean

	_cret = C.gtk_paned_get_resize_end_child(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// ResizeStartChild returns whether the start child can be resized.
func (p paned) ResizeStartChild() bool {
	var _arg0 *C.GtkPaned

	_arg0 = (*C.GtkPaned)(unsafe.Pointer(p.Native()))

	var _cret C.gboolean

	_cret = C.gtk_paned_get_resize_start_child(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// ShrinkEndChild returns whether the end child can be shrunk.
func (p paned) ShrinkEndChild() bool {
	var _arg0 *C.GtkPaned

	_arg0 = (*C.GtkPaned)(unsafe.Pointer(p.Native()))

	var _cret C.gboolean

	_cret = C.gtk_paned_get_shrink_end_child(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// ShrinkStartChild returns whether the start child can be shrunk.
func (p paned) ShrinkStartChild() bool {
	var _arg0 *C.GtkPaned

	_arg0 = (*C.GtkPaned)(unsafe.Pointer(p.Native()))

	var _cret C.gboolean

	_cret = C.gtk_paned_get_shrink_start_child(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// WideHandle gets whether the separator should be wide.
func (p paned) WideHandle() bool {
	var _arg0 *C.GtkPaned

	_arg0 = (*C.GtkPaned)(unsafe.Pointer(p.Native()))

	var _cret C.gboolean

	_cret = C.gtk_paned_get_wide_handle(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// SetEndChild sets the end child of @paned to @child.
func (p paned) SetEndChild(child Widget) {
	var _arg0 *C.GtkPaned
	var _arg1 *C.GtkWidget

	_arg0 = (*C.GtkPaned)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_paned_set_end_child(_arg0, _arg1)
}

// SetPosition sets the position of the divider between the two panes.
func (p paned) SetPosition(position int) {
	var _arg0 *C.GtkPaned
	var _arg1 C.int

	_arg0 = (*C.GtkPaned)(unsafe.Pointer(p.Native()))
	_arg1 = C.int(position)

	C.gtk_paned_set_position(_arg0, _arg1)
}

// SetResizeEndChild sets the `GtkPaned`:resize-end-child property
func (p paned) SetResizeEndChild(resize bool) {
	var _arg0 *C.GtkPaned
	var _arg1 C.gboolean

	_arg0 = (*C.GtkPaned)(unsafe.Pointer(p.Native()))
	if resize {
		_arg1 = C.gboolean(1)
	}

	C.gtk_paned_set_resize_end_child(_arg0, _arg1)
}

// SetResizeStartChild sets the `GtkPaned`:resize-start-child property
func (p paned) SetResizeStartChild(resize bool) {
	var _arg0 *C.GtkPaned
	var _arg1 C.gboolean

	_arg0 = (*C.GtkPaned)(unsafe.Pointer(p.Native()))
	if resize {
		_arg1 = C.gboolean(1)
	}

	C.gtk_paned_set_resize_start_child(_arg0, _arg1)
}

// SetShrinkEndChild sets the `GtkPaned`:shrink-end-child property
func (p paned) SetShrinkEndChild(resize bool) {
	var _arg0 *C.GtkPaned
	var _arg1 C.gboolean

	_arg0 = (*C.GtkPaned)(unsafe.Pointer(p.Native()))
	if resize {
		_arg1 = C.gboolean(1)
	}

	C.gtk_paned_set_shrink_end_child(_arg0, _arg1)
}

// SetShrinkStartChild sets the `GtkPaned`:shrink-start-child property
func (p paned) SetShrinkStartChild(resize bool) {
	var _arg0 *C.GtkPaned
	var _arg1 C.gboolean

	_arg0 = (*C.GtkPaned)(unsafe.Pointer(p.Native()))
	if resize {
		_arg1 = C.gboolean(1)
	}

	C.gtk_paned_set_shrink_start_child(_arg0, _arg1)
}

// SetStartChild sets the start child of @paned to @child.
func (p paned) SetStartChild(child Widget) {
	var _arg0 *C.GtkPaned
	var _arg1 *C.GtkWidget

	_arg0 = (*C.GtkPaned)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_paned_set_start_child(_arg0, _arg1)
}

// SetWideHandle sets whether the separator should be wide.
func (p paned) SetWideHandle(wide bool) {
	var _arg0 *C.GtkPaned
	var _arg1 C.gboolean

	_arg0 = (*C.GtkPaned)(unsafe.Pointer(p.Native()))
	if wide {
		_arg1 = C.gboolean(1)
	}

	C.gtk_paned_set_wide_handle(_arg0, _arg1)
}

// PopoverMenu: `GtkPopoverMenu` is a subclass of `GtkPopover` that implements
// menu behavior.
//
// !An example GtkPopoverMenu (menu.png)
//
// `GtkPopoverMenu` treats its children like menus and allows switching between
// them. It can open submenus as traditional, nested submenus, or in a more
// touch-friendly sliding fashion.
//
// `GtkPopoverMenu` is meant to be used primarily with menu models, using
// [ctor@Gtk.PopoverMenu.new_from_model]. If you need to put other widgets such
// as a `GtkSpinButton` or a `GtkSwitch` into a popover, you can use
// [method@Gtk.PopoverMenu.add_child].
//
// For more dialog-like behavior, use a plain `GtkPopover`.
//
//
// Menu models
//
// The XML format understood by `GtkBuilder` for `GMenuModel` consists of a
// toplevel `<menu>` element, which contains one or more `<item>` elements. Each
// `<item>` element contains `<attribute>` and `<link>` elements with a
// mandatory name attribute. `<link>` elements have the same content model as
// `<menu>`. Instead of `<link name="submenu>` or `<link name="section">`, you
// can use `<submenu>` or `<section>` elements.
//
// “`xml <menu id='app-menu'> <section> <item> <attribute name='label'
// translatable='yes'>_New Window</attribute> <attribute
// name='action'>app.new</attribute> </item> <item> <attribute name='label'
// translatable='yes'>_About Sunny</attribute> <attribute
// name='action'>app.about</attribute> </item> <item> <attribute name='label'
// translatable='yes'>_Quit</attribute> <attribute
// name='action'>app.quit</attribute> </item> </section> </menu> “`
//
// Attribute values can be translated using gettext, like other `GtkBuilder`
// content. `<attribute>` elements can be marked for translation with a
// `translatable="yes"` attribute. It is also possible to specify message
// context and translator comments, using the context and comments attributes.
// To make use of this, the Builder must have been given the gettext domain to
// use.
//
// The following attributes are used when constructing menu items:
//
// - "label": a user-visible string to display - "action": the prefixed name of
// the action to trigger - "target": the parameter to use when activating the
// action - "icon" and "verb-icon": names of icons that may be displayed -
// "submenu-action": name of an action that may be used to determine if a
// submenu can be opened - "hidden-when": a string used to determine when the
// item will be hidden. Possible values include "action-disabled",
// "action-missing", "macos-menubar". This is mainly useful for exported menus,
// see [method@Gtk.Application.set_menubar]. - "custom": a string used to match
// against the ID of a custom child added with
// [method@Gtk.PopoverMenu.add_child], [method@Gtk.PopoverMenuBar.add_child], or
// in the ui file with `<child type="ID">`.
//
// The following attributes are used when constructing sections:
//
// - "label": a user-visible string to use as section heading - "display-hint":
// a string used to determine special formatting for the section. Possible
// values include "horizontal-buttons", "circular-buttons" and "inline-buttons".
// They all indicate that section should be displayed as a horizontal row of
// buttons. - "text-direction": a string used to determine the
// `GtkTextDirection` to use when "display-hint" is set to "horizontal-buttons".
// Possible values include "rtl", "ltr", and "none".
//
// The following attributes are used when constructing submenus:
//
// - "label": a user-visible string to display - "icon": icon name to display
//
// Menu items will also show accelerators, which are usually associated with
// actions via [method@Gtk.Application.set_accels_for_action],
// [id@gtk_widget_class_add_binding_action] or
// [method@Gtk.ShortcutController.add_shortcut].
//
//
// CSS Nodes
//
// `GtkPopoverMenu` is just a subclass of `GtkPopover` that adds custom content
// to it, therefore it has the same CSS nodes. It is one of the cases that add a
// .menu style class to the popover's main node.
//
//
// Accessibility
//
// `GtkPopoverMenu` uses the GTK_ACCESSIBLE_ROLE_MENU role, and its items use
// the GTK_ACCESSIBLE_ROLE_MENU_ITEM, GTK_ACCESSIBLE_ROLE_MENU_ITEM_CHECKBOX or
// GTK_ACCESSIBLE_ROLE_MENU_ITEM_RADIO roles, depending on the action they are
// connected to.
type PopoverMenu interface {
	Popover
	Accessible
	Buildable
	ConstraintTarget
	Native
	ShortcutManager

	// AddChild adds a custom widget to a generated menu.
	//
	// For this to work, the menu model of @popover must have an item with a
	// `custom` attribute that matches @id.
	AddChild(child Widget, id string) bool
	// RemoveChild removes a widget that has previously been added with
	// gtk_popover_menu_add_child().
	RemoveChild(child Widget) bool
	// SetMenuModel sets a new menu model on @popover.
	//
	// The existing contents of @popover are removed, and the @popover is
	// populated with new contents according to @model.
	SetMenuModel(model gio.MenuModel)
}

// popoverMenu implements the PopoverMenu interface.
type popoverMenu struct {
	Popover
	Accessible
	Buildable
	ConstraintTarget
	Native
	ShortcutManager
}

var _ PopoverMenu = (*popoverMenu)(nil)

// WrapPopoverMenu wraps a GObject to the right type. It is
// primarily used internally.
func WrapPopoverMenu(obj *externglib.Object) PopoverMenu {
	return PopoverMenu{
		Popover:          WrapPopover(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
		Native:           WrapNative(obj),
		ShortcutManager:  WrapShortcutManager(obj),
	}
}

func marshalPopoverMenu(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPopoverMenu(obj), nil
}

// AddChild adds a custom widget to a generated menu.
//
// For this to work, the menu model of @popover must have an item with a
// `custom` attribute that matches @id.
func (p popoverMenu) AddChild(child Widget, id string) bool {
	var _arg0 *C.GtkPopoverMenu
	var _arg1 *C.GtkWidget
	var _arg2 *C.char

	_arg0 = (*C.GtkPopoverMenu)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.char)(C.CString(id))
	defer C.free(unsafe.Pointer(_arg2))

	var _cret C.gboolean

	_cret = C.gtk_popover_menu_add_child(_arg0, _arg1, _arg2)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// RemoveChild removes a widget that has previously been added with
// gtk_popover_menu_add_child().
func (p popoverMenu) RemoveChild(child Widget) bool {
	var _arg0 *C.GtkPopoverMenu
	var _arg1 *C.GtkWidget

	_arg0 = (*C.GtkPopoverMenu)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	var _cret C.gboolean

	_cret = C.gtk_popover_menu_remove_child(_arg0, _arg1)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// SetMenuModel sets a new menu model on @popover.
//
// The existing contents of @popover are removed, and the @popover is
// populated with new contents according to @model.
func (p popoverMenu) SetMenuModel(model gio.MenuModel) {
	var _arg0 *C.GtkPopoverMenu
	var _arg1 *C.GMenuModel

	_arg0 = (*C.GtkPopoverMenu)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.GMenuModel)(unsafe.Pointer(model.Native()))

	C.gtk_popover_menu_set_menu_model(_arg0, _arg1)
}

// PopoverMenuBar: `GtkPopoverMenuBar` presents a horizontal bar of items that
// pop up popover menus when clicked.
//
// !An example GtkPopoverMenuBar (menubar.png)
//
// The only way to create instances of `GtkPopoverMenuBar` is from a
// `GMenuModel`.
//
//
// CSS nodes
//
// “` menubar ├── item[.active] ┊ ╰── popover ╰── item ╰── popover “`
//
// `GtkPopoverMenuBar` has a single CSS node with name menubar, below which each
// item has its CSS node, and below that the corresponding popover.
//
// The item whose popover is currently open gets the .active style class.
//
//
// Accessibility
//
// `GtkPopoverMenuBar` uses the GTK_ACCESSIBLE_ROLE_MENU_BAR role, the menu
// items use the GTK_ACCESSIBLE_ROLE_MENU_ITEM role and the menus use the
// GTK_ACCESSIBLE_ROLE_MENU role.
type PopoverMenuBar interface {
	Widget
	Accessible
	Buildable
	ConstraintTarget

	// AddChild adds a custom widget to a generated menubar.
	//
	// For this to work, the menu model of @bar must have an item with a
	// `custom` attribute that matches @id.
	AddChild(child Widget, id string) bool
	// RemoveChild removes a widget that has previously been added with
	// gtk_popover_menu_bar_add_child().
	RemoveChild(child Widget) bool
	// SetMenuModel sets a menu model from which @bar should take its contents.
	SetMenuModel(model gio.MenuModel)
}

// popoverMenuBar implements the PopoverMenuBar interface.
type popoverMenuBar struct {
	Widget
	Accessible
	Buildable
	ConstraintTarget
}

var _ PopoverMenuBar = (*popoverMenuBar)(nil)

// WrapPopoverMenuBar wraps a GObject to the right type. It is
// primarily used internally.
func WrapPopoverMenuBar(obj *externglib.Object) PopoverMenuBar {
	return PopoverMenuBar{
		Widget:           WrapWidget(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
	}
}

func marshalPopoverMenuBar(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPopoverMenuBar(obj), nil
}

// AddChild adds a custom widget to a generated menubar.
//
// For this to work, the menu model of @bar must have an item with a
// `custom` attribute that matches @id.
func (b popoverMenuBar) AddChild(child Widget, id string) bool {
	var _arg0 *C.GtkPopoverMenuBar
	var _arg1 *C.GtkWidget
	var _arg2 *C.char

	_arg0 = (*C.GtkPopoverMenuBar)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.char)(C.CString(id))
	defer C.free(unsafe.Pointer(_arg2))

	var _cret C.gboolean

	_cret = C.gtk_popover_menu_bar_add_child(_arg0, _arg1, _arg2)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// RemoveChild removes a widget that has previously been added with
// gtk_popover_menu_bar_add_child().
func (b popoverMenuBar) RemoveChild(child Widget) bool {
	var _arg0 *C.GtkPopoverMenuBar
	var _arg1 *C.GtkWidget

	_arg0 = (*C.GtkPopoverMenuBar)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	var _cret C.gboolean

	_cret = C.gtk_popover_menu_bar_remove_child(_arg0, _arg1)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// SetMenuModel sets a menu model from which @bar should take its contents.
func (b popoverMenuBar) SetMenuModel(model gio.MenuModel) {
	var _arg0 *C.GtkPopoverMenuBar
	var _arg1 *C.GMenuModel

	_arg0 = (*C.GtkPopoverMenuBar)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GMenuModel)(unsafe.Pointer(model.Native()))

	C.gtk_popover_menu_bar_set_menu_model(_arg0, _arg1)
}

// PrintContext: a `GtkPrintContext` encapsulates context information that is
// required when drawing pages for printing.
//
// This includes the cairo context and important parameters like page size and
// resolution. It also lets you easily create [class@Pango.Layout] and
// [class@Pango.Context] objects that match the font metrics of the cairo
// surface.
//
// `GtkPrintContext` objects get passed to the
// [signal@Gtk.PrintOperation::begin-print],
// [signal@Gtk.PrintOperation::end-print],
// [signal@Gtk.PrintOperation::request-page-setup] and
// [signal@Gtk.PrintOperation::draw-page] signals on the
// [class@Gtk.PrintOperation] object.
//
// Using GtkPrintContext in a ::draw-page callback
//
// “`c static void draw_page (GtkPrintOperation *operation, GtkPrintContext
// *context, int page_nr) { cairo_t *cr; PangoLayout *layout;
// PangoFontDescription *desc;
//
//    cr = gtk_print_context_get_cairo_context (context);
//
//    // Draw a red rectangle, as wide as the paper (inside the margins)
//    cairo_set_source_rgb (cr, 1.0, 0, 0);
//    cairo_rectangle (cr, 0, 0, gtk_print_context_get_width (context), 50);
//
//    cairo_fill (cr);
//
//    // Draw some lines
//    cairo_move_to (cr, 20, 10);
//    cairo_line_to (cr, 40, 20);
//    cairo_arc (cr, 60, 60, 20, 0, M_PI);
//    cairo_line_to (cr, 80, 20);
//
//    cairo_set_source_rgb (cr, 0, 0, 0);
//    cairo_set_line_width (cr, 5);
//    cairo_set_line_cap (cr, CAIRO_LINE_CAP_ROUND);
//    cairo_set_line_join (cr, CAIRO_LINE_JOIN_ROUND);
//
//    cairo_stroke (cr);
//
//    // Draw some text
//    layout = gtk_print_context_create_pango_layout (context);
//    pango_layout_set_text (layout, "Hello World! Printing is easy", -1);
//    desc = pango_font_description_from_string ("sans 28");
//    pango_layout_set_font_description (layout, desc);
//    pango_font_description_free (desc);
//
//    cairo_move_to (cr, 30, 20);
//    pango_cairo_layout_path (cr, layout);
//
//    // Font Outline
//    cairo_set_source_rgb (cr, 0.93, 1.0, 0.47);
//    cairo_set_line_width (cr, 0.5);
//    cairo_stroke_preserve (cr);
//
//    // Font Fill
//    cairo_set_source_rgb (cr, 0, 0.0, 1.0);
//    cairo_fill (cr);
//
//    g_object_unref (layout);
//
// } “`
type PrintContext interface {
	gextras.Objector

	// DPIX obtains the horizontal resolution of the `GtkPrintContext`, in dots
	// per inch.
	DPIX() float64
	// DPIY obtains the vertical resolution of the `GtkPrintContext`, in dots
	// per inch.
	DPIY() float64
	// HardMargins obtains the hardware printer margins of the
	// `GtkPrintContext`, in units.
	HardMargins() (top float64, bottom float64, left float64, right float64, ok bool)
	// Height obtains the height of the `GtkPrintContext`, in pixels.
	Height() float64
	// Width obtains the width of the `GtkPrintContext`, in pixels.
	Width() float64
	// SetCairoContext sets a new cairo context on a print context.
	//
	// This function is intended to be used when implementing an internal print
	// preview, it is not needed for printing, since GTK itself creates a
	// suitable cairo context in that case.
	SetCairoContext(cr *cairo.Context, dpiX float64, dpiY float64)
}

// printContext implements the PrintContext interface.
type printContext struct {
	gextras.Objector
}

var _ PrintContext = (*printContext)(nil)

// WrapPrintContext wraps a GObject to the right type. It is
// primarily used internally.
func WrapPrintContext(obj *externglib.Object) PrintContext {
	return PrintContext{
		Objector: obj,
	}
}

func marshalPrintContext(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPrintContext(obj), nil
}

// DPIX obtains the horizontal resolution of the `GtkPrintContext`, in dots
// per inch.
func (c printContext) DPIX() float64 {
	var _arg0 *C.GtkPrintContext

	_arg0 = (*C.GtkPrintContext)(unsafe.Pointer(c.Native()))

	var _cret C.double

	_cret = C.gtk_print_context_get_dpi_x(_arg0)

	var _gdouble float64

	_gdouble = (float64)(_cret)

	return _gdouble
}

// DPIY obtains the vertical resolution of the `GtkPrintContext`, in dots
// per inch.
func (c printContext) DPIY() float64 {
	var _arg0 *C.GtkPrintContext

	_arg0 = (*C.GtkPrintContext)(unsafe.Pointer(c.Native()))

	var _cret C.double

	_cret = C.gtk_print_context_get_dpi_y(_arg0)

	var _gdouble float64

	_gdouble = (float64)(_cret)

	return _gdouble
}

// HardMargins obtains the hardware printer margins of the
// `GtkPrintContext`, in units.
func (c printContext) HardMargins() (top float64, bottom float64, left float64, right float64, ok bool) {
	var _arg0 *C.GtkPrintContext

	_arg0 = (*C.GtkPrintContext)(unsafe.Pointer(c.Native()))

	var _arg1 C.double
	var _arg2 C.double
	var _arg3 C.double
	var _arg4 C.double
	var _cret C.gboolean

	_cret = C.gtk_print_context_get_hard_margins(_arg0, &_arg1, &_arg2, &_arg3, &_arg4)

	var _top float64
	var _bottom float64
	var _left float64
	var _right float64
	var _ok bool

	_top = (float64)(_arg1)
	_bottom = (float64)(_arg2)
	_left = (float64)(_arg3)
	_right = (float64)(_arg4)
	if _cret {
		_ok = true
	}

	return _top, _bottom, _left, _right, _ok
}

// Height obtains the height of the `GtkPrintContext`, in pixels.
func (c printContext) Height() float64 {
	var _arg0 *C.GtkPrintContext

	_arg0 = (*C.GtkPrintContext)(unsafe.Pointer(c.Native()))

	var _cret C.double

	_cret = C.gtk_print_context_get_height(_arg0)

	var _gdouble float64

	_gdouble = (float64)(_cret)

	return _gdouble
}

// Width obtains the width of the `GtkPrintContext`, in pixels.
func (c printContext) Width() float64 {
	var _arg0 *C.GtkPrintContext

	_arg0 = (*C.GtkPrintContext)(unsafe.Pointer(c.Native()))

	var _cret C.double

	_cret = C.gtk_print_context_get_width(_arg0)

	var _gdouble float64

	_gdouble = (float64)(_cret)

	return _gdouble
}

// SetCairoContext sets a new cairo context on a print context.
//
// This function is intended to be used when implementing an internal print
// preview, it is not needed for printing, since GTK itself creates a
// suitable cairo context in that case.
func (c printContext) SetCairoContext(cr *cairo.Context, dpiX float64, dpiY float64) {
	var _arg0 *C.GtkPrintContext
	var _arg1 *C.cairo_t
	var _arg2 C.double
	var _arg3 C.double

	_arg0 = (*C.GtkPrintContext)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg2 = C.double(dpiX)
	_arg3 = C.double(dpiY)

	C.gtk_print_context_set_cairo_context(_arg0, _arg1, _arg2, _arg3)
}

// PrintJob: a `GtkPrintJob` object represents a job that is sent to a printer.
//
// You only need to deal directly with print jobs if you use the non-portable
// [class@Gtk.PrintUnixDialog] API.
//
// Use [method@Gtk.PrintJob.get_surface] to obtain the cairo surface onto which
// the pages must be drawn. Use [method@Gtk.PrintJob.send] to send the finished
// job to the printer. If you don’t use cairo `GtkPrintJob` also supports
// printing of manually generated PostScript, via
// [method@Gtk.PrintJob.set_source_file].
type PrintJob interface {
	gextras.Objector

	// Collate gets whether this job is printed collated.
	Collate() bool
	// NUp gets the n-up setting for this job.
	NUp() uint
	// NumCopies gets the number of copies of this job.
	NumCopies() int
	// Reverse gets whether this job is printed reversed.
	Reverse() bool
	// Rotate gets whether the job is printed rotated.
	Rotate() bool
	// Scale gets the scale for this job.
	Scale() float64
	// Title gets the job title.
	Title() string
	// TrackPrintStatus returns whether jobs will be tracked after printing.
	//
	// For details, see [method@Gtk.PrintJob.set_track_print_status].
	TrackPrintStatus() bool
	// SetCollate sets whether this job is printed collated.
	SetCollate(collate bool)
	// SetNUp sets the n-up setting for this job.
	SetNUp(nUp uint)
	// SetNUpLayout sets the n-up layout setting for this job.
	SetNUpLayout(layout NumberUpLayout)
	// SetNumCopies sets the number of copies for this job.
	SetNumCopies(numCopies int)
	// SetPageRanges sets the page ranges for this job.
	SetPageRanges(ranges []PageRange)
	// SetPageSet sets the `GtkPageSet` setting for this job.
	SetPageSet(pageSet PageSet)
	// SetPages sets the `GtkPrintPages` setting for this job.
	SetPages(pages PrintPages)
	// SetReverse sets whether this job is printed reversed.
	SetReverse(reverse bool)
	// SetRotate sets whether this job is printed rotated.
	SetRotate(rotate bool)
	// SetScale sets the scale for this job.
	//
	// 1.0 means unscaled.
	SetScale(scale float64)
	// SetSourceFd: make the `GtkPrintJob` send an existing document to the
	// printing system.
	//
	// The file can be in any format understood by the platforms printing system
	// (typically PostScript, but on many platforms PDF may work too). See
	// [method@Gtk.Printer.accepts_pdf] and [method@Gtk.Printer.accepts_ps].
	//
	// This is similar to [method@Gtk.PrintJob.set_source_file], but takes
	// expects an open file descriptor for the file, instead of a filename.
	SetSourceFd(fd int) error
	// SetSourceFile: make the `GtkPrintJob` send an existing document to the
	// printing system.
	//
	// The file can be in any format understood by the platforms printing system
	// (typically PostScript, but on many platforms PDF may work too). See
	// [method@Gtk.Printer.accepts_pdf] and [method@Gtk.Printer.accepts_ps].
	SetSourceFile(filename *string) error
	// SetTrackPrintStatus: if track_status is true, the print job will try to
	// continue report on the status of the print job in the printer queues and
	// printer.
	//
	// This can allow your application to show things like “out of paper”
	// issues, and when the print job actually reaches the printer.
	//
	// This function is often implemented using some form of polling, so it
	// should not be enabled unless needed.
	SetTrackPrintStatus(trackStatus bool)
}

// printJob implements the PrintJob interface.
type printJob struct {
	gextras.Objector
}

var _ PrintJob = (*printJob)(nil)

// WrapPrintJob wraps a GObject to the right type. It is
// primarily used internally.
func WrapPrintJob(obj *externglib.Object) PrintJob {
	return PrintJob{
		Objector: obj,
	}
}

func marshalPrintJob(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPrintJob(obj), nil
}

// Collate gets whether this job is printed collated.
func (j printJob) Collate() bool {
	var _arg0 *C.GtkPrintJob

	_arg0 = (*C.GtkPrintJob)(unsafe.Pointer(j.Native()))

	var _cret C.gboolean

	_cret = C.gtk_print_job_get_collate(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// NUp gets the n-up setting for this job.
func (j printJob) NUp() uint {
	var _arg0 *C.GtkPrintJob

	_arg0 = (*C.GtkPrintJob)(unsafe.Pointer(j.Native()))

	var _cret C.guint

	_cret = C.gtk_print_job_get_n_up(_arg0)

	var _guint uint

	_guint = (uint)(_cret)

	return _guint
}

// NumCopies gets the number of copies of this job.
func (j printJob) NumCopies() int {
	var _arg0 *C.GtkPrintJob

	_arg0 = (*C.GtkPrintJob)(unsafe.Pointer(j.Native()))

	var _cret C.int

	_cret = C.gtk_print_job_get_num_copies(_arg0)

	var _gint int

	_gint = (int)(_cret)

	return _gint
}

// Reverse gets whether this job is printed reversed.
func (j printJob) Reverse() bool {
	var _arg0 *C.GtkPrintJob

	_arg0 = (*C.GtkPrintJob)(unsafe.Pointer(j.Native()))

	var _cret C.gboolean

	_cret = C.gtk_print_job_get_reverse(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// Rotate gets whether the job is printed rotated.
func (j printJob) Rotate() bool {
	var _arg0 *C.GtkPrintJob

	_arg0 = (*C.GtkPrintJob)(unsafe.Pointer(j.Native()))

	var _cret C.gboolean

	_cret = C.gtk_print_job_get_rotate(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// Scale gets the scale for this job.
func (j printJob) Scale() float64 {
	var _arg0 *C.GtkPrintJob

	_arg0 = (*C.GtkPrintJob)(unsafe.Pointer(j.Native()))

	var _cret C.double

	_cret = C.gtk_print_job_get_scale(_arg0)

	var _gdouble float64

	_gdouble = (float64)(_cret)

	return _gdouble
}

// Title gets the job title.
func (j printJob) Title() string {
	var _arg0 *C.GtkPrintJob

	_arg0 = (*C.GtkPrintJob)(unsafe.Pointer(j.Native()))

	var _cret *C.char

	_cret = C.gtk_print_job_get_title(_arg0)

	var _utf8 string

	_utf8 = C.GoString(_cret)

	return _utf8
}

// TrackPrintStatus returns whether jobs will be tracked after printing.
//
// For details, see [method@Gtk.PrintJob.set_track_print_status].
func (j printJob) TrackPrintStatus() bool {
	var _arg0 *C.GtkPrintJob

	_arg0 = (*C.GtkPrintJob)(unsafe.Pointer(j.Native()))

	var _cret C.gboolean

	_cret = C.gtk_print_job_get_track_print_status(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// SetCollate sets whether this job is printed collated.
func (j printJob) SetCollate(collate bool) {
	var _arg0 *C.GtkPrintJob
	var _arg1 C.gboolean

	_arg0 = (*C.GtkPrintJob)(unsafe.Pointer(j.Native()))
	if collate {
		_arg1 = C.gboolean(1)
	}

	C.gtk_print_job_set_collate(_arg0, _arg1)
}

// SetNUp sets the n-up setting for this job.
func (j printJob) SetNUp(nUp uint) {
	var _arg0 *C.GtkPrintJob
	var _arg1 C.guint

	_arg0 = (*C.GtkPrintJob)(unsafe.Pointer(j.Native()))
	_arg1 = C.guint(nUp)

	C.gtk_print_job_set_n_up(_arg0, _arg1)
}

// SetNUpLayout sets the n-up layout setting for this job.
func (j printJob) SetNUpLayout(layout NumberUpLayout) {
	var _arg0 *C.GtkPrintJob
	var _arg1 C.GtkNumberUpLayout

	_arg0 = (*C.GtkPrintJob)(unsafe.Pointer(j.Native()))
	_arg1 = (C.GtkNumberUpLayout)(layout)

	C.gtk_print_job_set_n_up_layout(_arg0, _arg1)
}

// SetNumCopies sets the number of copies for this job.
func (j printJob) SetNumCopies(numCopies int) {
	var _arg0 *C.GtkPrintJob
	var _arg1 C.int

	_arg0 = (*C.GtkPrintJob)(unsafe.Pointer(j.Native()))
	_arg1 = C.int(numCopies)

	C.gtk_print_job_set_num_copies(_arg0, _arg1)
}

// SetPageRanges sets the page ranges for this job.
func (j printJob) SetPageRanges(ranges []PageRange) {
	var _arg0 *C.GtkPrintJob
	var _arg1 *C.GtkPageRange
	var _arg2 C.int

	_arg0 = (*C.GtkPrintJob)(unsafe.Pointer(j.Native()))
	_arg2 = C.int(len(ranges))
	_arg1 = (*C.GtkPageRange)(C.malloc(len(ranges) * C.sizeof_struct_GtkPageRange))
	{
		var out []C.GtkPageRange
		ptr.SetSlice(unsafe.Pointer(&out), unsafe.Pointer(_arg1), int(len(ranges)))

		for i := range ranges {
			_arg1 = (C.GtkPageRange)(unsafe.Pointer(ranges.Native()))
		}
	}

	C.gtk_print_job_set_page_ranges(_arg0, _arg1, _arg2)
}

// SetPageSet sets the `GtkPageSet` setting for this job.
func (j printJob) SetPageSet(pageSet PageSet) {
	var _arg0 *C.GtkPrintJob
	var _arg1 C.GtkPageSet

	_arg0 = (*C.GtkPrintJob)(unsafe.Pointer(j.Native()))
	_arg1 = (C.GtkPageSet)(pageSet)

	C.gtk_print_job_set_page_set(_arg0, _arg1)
}

// SetPages sets the `GtkPrintPages` setting for this job.
func (j printJob) SetPages(pages PrintPages) {
	var _arg0 *C.GtkPrintJob
	var _arg1 C.GtkPrintPages

	_arg0 = (*C.GtkPrintJob)(unsafe.Pointer(j.Native()))
	_arg1 = (C.GtkPrintPages)(pages)

	C.gtk_print_job_set_pages(_arg0, _arg1)
}

// SetReverse sets whether this job is printed reversed.
func (j printJob) SetReverse(reverse bool) {
	var _arg0 *C.GtkPrintJob
	var _arg1 C.gboolean

	_arg0 = (*C.GtkPrintJob)(unsafe.Pointer(j.Native()))
	if reverse {
		_arg1 = C.gboolean(1)
	}

	C.gtk_print_job_set_reverse(_arg0, _arg1)
}

// SetRotate sets whether this job is printed rotated.
func (j printJob) SetRotate(rotate bool) {
	var _arg0 *C.GtkPrintJob
	var _arg1 C.gboolean

	_arg0 = (*C.GtkPrintJob)(unsafe.Pointer(j.Native()))
	if rotate {
		_arg1 = C.gboolean(1)
	}

	C.gtk_print_job_set_rotate(_arg0, _arg1)
}

// SetScale sets the scale for this job.
//
// 1.0 means unscaled.
func (j printJob) SetScale(scale float64) {
	var _arg0 *C.GtkPrintJob
	var _arg1 C.double

	_arg0 = (*C.GtkPrintJob)(unsafe.Pointer(j.Native()))
	_arg1 = C.double(scale)

	C.gtk_print_job_set_scale(_arg0, _arg1)
}

// SetSourceFd: make the `GtkPrintJob` send an existing document to the
// printing system.
//
// The file can be in any format understood by the platforms printing system
// (typically PostScript, but on many platforms PDF may work too). See
// [method@Gtk.Printer.accepts_pdf] and [method@Gtk.Printer.accepts_ps].
//
// This is similar to [method@Gtk.PrintJob.set_source_file], but takes
// expects an open file descriptor for the file, instead of a filename.
func (j printJob) SetSourceFd(fd int) error {
	var _arg0 *C.GtkPrintJob
	var _arg1 C.int

	_arg0 = (*C.GtkPrintJob)(unsafe.Pointer(j.Native()))
	_arg1 = C.int(fd)

	var _cerr *C.GError

	C.gtk_print_job_set_source_fd(_arg0, _arg1, _cerr)

	var _goerr error

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// SetSourceFile: make the `GtkPrintJob` send an existing document to the
// printing system.
//
// The file can be in any format understood by the platforms printing system
// (typically PostScript, but on many platforms PDF may work too). See
// [method@Gtk.Printer.accepts_pdf] and [method@Gtk.Printer.accepts_ps].
func (j printJob) SetSourceFile(filename *string) error {
	var _arg0 *C.GtkPrintJob
	var _arg1 *C.char

	_arg0 = (*C.GtkPrintJob)(unsafe.Pointer(j.Native()))
	_arg1 = (*C.char)(C.CString(filename))
	defer C.free(unsafe.Pointer(_arg1))

	var _cerr *C.GError

	C.gtk_print_job_set_source_file(_arg0, _arg1, _cerr)

	var _goerr error

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// SetTrackPrintStatus: if track_status is true, the print job will try to
// continue report on the status of the print job in the printer queues and
// printer.
//
// This can allow your application to show things like “out of paper”
// issues, and when the print job actually reaches the printer.
//
// This function is often implemented using some form of polling, so it
// should not be enabled unless needed.
func (j printJob) SetTrackPrintStatus(trackStatus bool) {
	var _arg0 *C.GtkPrintJob
	var _arg1 C.gboolean

	_arg0 = (*C.GtkPrintJob)(unsafe.Pointer(j.Native()))
	if trackStatus {
		_arg1 = C.gboolean(1)
	}

	C.gtk_print_job_set_track_print_status(_arg0, _arg1)
}

// PrintSettings: a `GtkPrintSettings` object represents the settings of a print
// dialog in a system-independent way.
//
// The main use for this object is that once you’ve printed you can get a
// settings object that represents the settings the user chose, and the next
// time you print you can pass that object in so that the user doesn’t have to
// re-set all his settings.
//
// Its also possible to enumerate the settings so that you can easily save the
// settings for the next time your app runs, or even store them in a document.
// The predefined keys try to use shared values as much as possible so that
// moving such a document between systems still works.
type PrintSettings interface {
	gextras.Objector

	// Foreach calls @func for each key-value pair of @settings.
	Foreach(fn PrintSettingsFunc)
	// Get looks up the string value associated with @key.
	Get(key string) string
	// Bool returns the boolean represented by the value that is associated with
	// @key.
	//
	// The string “true” represents true, any other string false.
	Bool(key string) bool
	// Collate gets the value of GTK_PRINT_SETTINGS_COLLATE.
	Collate() bool
	// DefaultSource gets the value of GTK_PRINT_SETTINGS_DEFAULT_SOURCE.
	DefaultSource() string
	// Dither gets the value of GTK_PRINT_SETTINGS_DITHER.
	Dither() string
	// Double returns the double value associated with @key, or 0.
	Double(key string) float64
	// DoubleWithDefault returns the floating point number represented by the
	// value that is associated with @key, or @default_val if the value does not
	// represent a floating point number.
	//
	// Floating point numbers are parsed with g_ascii_strtod().
	DoubleWithDefault(key string, def float64) float64
	// Finishings gets the value of GTK_PRINT_SETTINGS_FINISHINGS.
	Finishings() string
	// Int returns the integer value of @key, or 0.
	Int(key string) int
	// IntWithDefault returns the value of @key, interpreted as an integer, or
	// the default value.
	IntWithDefault(key string, def int) int
	// Length returns the value associated with @key, interpreted as a length.
	//
	// The returned value is converted to @units.
	Length(key string, unit Unit) float64
	// MediaType gets the value of GTK_PRINT_SETTINGS_MEDIA_TYPE.
	//
	// The set of media types is defined in PWG 5101.1-2002 PWG.
	MediaType() string
	// NCopies gets the value of GTK_PRINT_SETTINGS_N_COPIES.
	NCopies() int
	// NumberUp gets the value of GTK_PRINT_SETTINGS_NUMBER_UP.
	NumberUp() int
	// OutputBin gets the value of GTK_PRINT_SETTINGS_OUTPUT_BIN.
	OutputBin() string
	// PaperHeight gets the value of GTK_PRINT_SETTINGS_PAPER_HEIGHT, converted
	// to @unit.
	PaperHeight(unit Unit) float64
	// PaperWidth gets the value of GTK_PRINT_SETTINGS_PAPER_WIDTH, converted to
	// @unit.
	PaperWidth(unit Unit) float64
	// Printer: convenience function to obtain the value of
	// GTK_PRINT_SETTINGS_PRINTER.
	Printer() string
	// PrinterLpi gets the value of GTK_PRINT_SETTINGS_PRINTER_LPI.
	PrinterLpi() float64
	// Resolution gets the value of GTK_PRINT_SETTINGS_RESOLUTION.
	Resolution() int
	// ResolutionX gets the value of GTK_PRINT_SETTINGS_RESOLUTION_X.
	ResolutionX() int
	// ResolutionY gets the value of GTK_PRINT_SETTINGS_RESOLUTION_Y.
	ResolutionY() int
	// Reverse gets the value of GTK_PRINT_SETTINGS_REVERSE.
	Reverse() bool
	// Scale gets the value of GTK_PRINT_SETTINGS_SCALE.
	Scale() float64
	// UseColor gets the value of GTK_PRINT_SETTINGS_USE_COLOR.
	UseColor() bool
	// HasKey returns true, if a value is associated with @key.
	HasKey(key string) bool
	// LoadFile reads the print settings from @file_name.
	//
	// If the file could not be loaded then error is set to either a
	// `GFileError` or `GKeyFileError`.
	//
	// See [method@Gtk.PrintSettings.to_file].
	LoadFile(fileName *string) error
	// LoadKeyFile reads the print settings from the group @group_name in
	// @key_file.
	//
	// If the file could not be loaded then error is set to either a
	// `GFileError` or `GKeyFileError`.
	LoadKeyFile(keyFile *glib.KeyFile, groupName string) error
	// Set associates @value with @key.
	Set(key string, value string)
	// SetBool sets @key to a boolean value.
	SetBool(key string, value bool)
	// SetCollate sets the value of GTK_PRINT_SETTINGS_COLLATE.
	SetCollate(collate bool)
	// SetDefaultSource sets the value of GTK_PRINT_SETTINGS_DEFAULT_SOURCE.
	SetDefaultSource(defaultSource string)
	// SetDither sets the value of GTK_PRINT_SETTINGS_DITHER.
	SetDither(dither string)
	// SetDouble sets @key to a double value.
	SetDouble(key string, value float64)
	// SetDuplex sets the value of GTK_PRINT_SETTINGS_DUPLEX.
	SetDuplex(duplex PrintDuplex)
	// SetFinishings sets the value of GTK_PRINT_SETTINGS_FINISHINGS.
	SetFinishings(finishings string)
	// SetInt sets @key to an integer value.
	SetInt(key string, value int)
	// SetLength associates a length in units of @unit with @key.
	SetLength(key string, value float64, unit Unit)
	// SetMediaType sets the value of GTK_PRINT_SETTINGS_MEDIA_TYPE.
	//
	// The set of media types is defined in PWG 5101.1-2002 PWG.
	SetMediaType(mediaType string)
	// SetNCopies sets the value of GTK_PRINT_SETTINGS_N_COPIES.
	SetNCopies(numCopies int)
	// SetNumberUp sets the value of GTK_PRINT_SETTINGS_NUMBER_UP.
	SetNumberUp(numberUp int)
	// SetNumberUpLayout sets the value of GTK_PRINT_SETTINGS_NUMBER_UP_LAYOUT.
	SetNumberUpLayout(numberUpLayout NumberUpLayout)
	// SetOrientation sets the value of GTK_PRINT_SETTINGS_ORIENTATION.
	SetOrientation(orientation PageOrientation)
	// SetOutputBin sets the value of GTK_PRINT_SETTINGS_OUTPUT_BIN.
	SetOutputBin(outputBin string)
	// SetPageRanges sets the value of GTK_PRINT_SETTINGS_PAGE_RANGES.
	SetPageRanges(pageRanges []PageRange)
	// SetPageSet sets the value of GTK_PRINT_SETTINGS_PAGE_SET.
	SetPageSet(pageSet PageSet)
	// SetPaperHeight sets the value of GTK_PRINT_SETTINGS_PAPER_HEIGHT.
	SetPaperHeight(height float64, unit Unit)
	// SetPaperSize sets the value of GTK_PRINT_SETTINGS_PAPER_FORMAT,
	// GTK_PRINT_SETTINGS_PAPER_WIDTH and GTK_PRINT_SETTINGS_PAPER_HEIGHT.
	SetPaperSize(paperSize *PaperSize)
	// SetPaperWidth sets the value of GTK_PRINT_SETTINGS_PAPER_WIDTH.
	SetPaperWidth(width float64, unit Unit)
	// SetPrintPages sets the value of GTK_PRINT_SETTINGS_PRINT_PAGES.
	SetPrintPages(pages PrintPages)
	// SetPrinter: convenience function to set GTK_PRINT_SETTINGS_PRINTER to
	// @printer.
	SetPrinter(printer string)
	// SetPrinterLpi sets the value of GTK_PRINT_SETTINGS_PRINTER_LPI.
	SetPrinterLpi(lpi float64)
	// SetQuality sets the value of GTK_PRINT_SETTINGS_QUALITY.
	SetQuality(quality PrintQuality)
	// SetResolution sets the values of GTK_PRINT_SETTINGS_RESOLUTION,
	// GTK_PRINT_SETTINGS_RESOLUTION_X and GTK_PRINT_SETTINGS_RESOLUTION_Y.
	SetResolution(resolution int)
	// SetResolutionXY sets the values of GTK_PRINT_SETTINGS_RESOLUTION,
	// GTK_PRINT_SETTINGS_RESOLUTION_X and GTK_PRINT_SETTINGS_RESOLUTION_Y.
	SetResolutionXY(resolutionX int, resolutionY int)
	// SetReverse sets the value of GTK_PRINT_SETTINGS_REVERSE.
	SetReverse(reverse bool)
	// SetScale sets the value of GTK_PRINT_SETTINGS_SCALE.
	SetScale(scale float64)
	// SetUseColor sets the value of GTK_PRINT_SETTINGS_USE_COLOR.
	SetUseColor(useColor bool)
	// ToFile: this function saves the print settings from @settings to
	// @file_name.
	//
	// If the file could not be written then error is set to either a
	// `GFileError` or `GKeyFileError`.
	ToFile(fileName *string) error
	// ToKeyFile: this function adds the print settings from @settings to
	// @key_file.
	ToKeyFile(keyFile *glib.KeyFile, groupName string)
	// Unset removes any value associated with @key.
	//
	// This has the same effect as setting the value to nil.
	Unset(key string)
}

// printSettings implements the PrintSettings interface.
type printSettings struct {
	gextras.Objector
}

var _ PrintSettings = (*printSettings)(nil)

// WrapPrintSettings wraps a GObject to the right type. It is
// primarily used internally.
func WrapPrintSettings(obj *externglib.Object) PrintSettings {
	return PrintSettings{
		Objector: obj,
	}
}

func marshalPrintSettings(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPrintSettings(obj), nil
}

// Foreach calls @func for each key-value pair of @settings.
func (s printSettings) Foreach(fn PrintSettingsFunc) {
	var _arg0 *C.GtkPrintSettings
	var _arg1 C.GtkPrintSettingsFunc
	var _arg2 C.gpointer

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*[0]byte)(C.gotk4_PrintSettingsFunc)
	_arg2 = C.gpointer(box.Assign(fn))

	C.gtk_print_settings_foreach(_arg0, _arg1, _arg2)
}

// Get looks up the string value associated with @key.
func (s printSettings) Get(key string) string {
	var _arg0 *C.GtkPrintSettings
	var _arg1 *C.char

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))

	var _cret *C.char

	_cret = C.gtk_print_settings_get(_arg0, _arg1)

	var _utf8 string

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Bool returns the boolean represented by the value that is associated with
// @key.
//
// The string “true” represents true, any other string false.
func (s printSettings) Bool(key string) bool {
	var _arg0 *C.GtkPrintSettings
	var _arg1 *C.char

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))

	var _cret C.gboolean

	_cret = C.gtk_print_settings_get_bool(_arg0, _arg1)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// Collate gets the value of GTK_PRINT_SETTINGS_COLLATE.
func (s printSettings) Collate() bool {
	var _arg0 *C.GtkPrintSettings

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	var _cret C.gboolean

	_cret = C.gtk_print_settings_get_collate(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// DefaultSource gets the value of GTK_PRINT_SETTINGS_DEFAULT_SOURCE.
func (s printSettings) DefaultSource() string {
	var _arg0 *C.GtkPrintSettings

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	var _cret *C.char

	_cret = C.gtk_print_settings_get_default_source(_arg0)

	var _utf8 string

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Dither gets the value of GTK_PRINT_SETTINGS_DITHER.
func (s printSettings) Dither() string {
	var _arg0 *C.GtkPrintSettings

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	var _cret *C.char

	_cret = C.gtk_print_settings_get_dither(_arg0)

	var _utf8 string

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Double returns the double value associated with @key, or 0.
func (s printSettings) Double(key string) float64 {
	var _arg0 *C.GtkPrintSettings
	var _arg1 *C.char

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))

	var _cret C.double

	_cret = C.gtk_print_settings_get_double(_arg0, _arg1)

	var _gdouble float64

	_gdouble = (float64)(_cret)

	return _gdouble
}

// DoubleWithDefault returns the floating point number represented by the
// value that is associated with @key, or @default_val if the value does not
// represent a floating point number.
//
// Floating point numbers are parsed with g_ascii_strtod().
func (s printSettings) DoubleWithDefault(key string, def float64) float64 {
	var _arg0 *C.GtkPrintSettings
	var _arg1 *C.char
	var _arg2 C.double

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.double(def)

	var _cret C.double

	_cret = C.gtk_print_settings_get_double_with_default(_arg0, _arg1, _arg2)

	var _gdouble float64

	_gdouble = (float64)(_cret)

	return _gdouble
}

// Finishings gets the value of GTK_PRINT_SETTINGS_FINISHINGS.
func (s printSettings) Finishings() string {
	var _arg0 *C.GtkPrintSettings

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	var _cret *C.char

	_cret = C.gtk_print_settings_get_finishings(_arg0)

	var _utf8 string

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Int returns the integer value of @key, or 0.
func (s printSettings) Int(key string) int {
	var _arg0 *C.GtkPrintSettings
	var _arg1 *C.char

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))

	var _cret C.int

	_cret = C.gtk_print_settings_get_int(_arg0, _arg1)

	var _gint int

	_gint = (int)(_cret)

	return _gint
}

// IntWithDefault returns the value of @key, interpreted as an integer, or
// the default value.
func (s printSettings) IntWithDefault(key string, def int) int {
	var _arg0 *C.GtkPrintSettings
	var _arg1 *C.char
	var _arg2 C.int

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.int(def)

	var _cret C.int

	_cret = C.gtk_print_settings_get_int_with_default(_arg0, _arg1, _arg2)

	var _gint int

	_gint = (int)(_cret)

	return _gint
}

// Length returns the value associated with @key, interpreted as a length.
//
// The returned value is converted to @units.
func (s printSettings) Length(key string, unit Unit) float64 {
	var _arg0 *C.GtkPrintSettings
	var _arg1 *C.char
	var _arg2 C.GtkUnit

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.GtkUnit)(unit)

	var _cret C.double

	_cret = C.gtk_print_settings_get_length(_arg0, _arg1, _arg2)

	var _gdouble float64

	_gdouble = (float64)(_cret)

	return _gdouble
}

// MediaType gets the value of GTK_PRINT_SETTINGS_MEDIA_TYPE.
//
// The set of media types is defined in PWG 5101.1-2002 PWG.
func (s printSettings) MediaType() string {
	var _arg0 *C.GtkPrintSettings

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	var _cret *C.char

	_cret = C.gtk_print_settings_get_media_type(_arg0)

	var _utf8 string

	_utf8 = C.GoString(_cret)

	return _utf8
}

// NCopies gets the value of GTK_PRINT_SETTINGS_N_COPIES.
func (s printSettings) NCopies() int {
	var _arg0 *C.GtkPrintSettings

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	var _cret C.int

	_cret = C.gtk_print_settings_get_n_copies(_arg0)

	var _gint int

	_gint = (int)(_cret)

	return _gint
}

// NumberUp gets the value of GTK_PRINT_SETTINGS_NUMBER_UP.
func (s printSettings) NumberUp() int {
	var _arg0 *C.GtkPrintSettings

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	var _cret C.int

	_cret = C.gtk_print_settings_get_number_up(_arg0)

	var _gint int

	_gint = (int)(_cret)

	return _gint
}

// OutputBin gets the value of GTK_PRINT_SETTINGS_OUTPUT_BIN.
func (s printSettings) OutputBin() string {
	var _arg0 *C.GtkPrintSettings

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	var _cret *C.char

	_cret = C.gtk_print_settings_get_output_bin(_arg0)

	var _utf8 string

	_utf8 = C.GoString(_cret)

	return _utf8
}

// PaperHeight gets the value of GTK_PRINT_SETTINGS_PAPER_HEIGHT, converted
// to @unit.
func (s printSettings) PaperHeight(unit Unit) float64 {
	var _arg0 *C.GtkPrintSettings
	var _arg1 C.GtkUnit

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkUnit)(unit)

	var _cret C.double

	_cret = C.gtk_print_settings_get_paper_height(_arg0, _arg1)

	var _gdouble float64

	_gdouble = (float64)(_cret)

	return _gdouble
}

// PaperWidth gets the value of GTK_PRINT_SETTINGS_PAPER_WIDTH, converted to
// @unit.
func (s printSettings) PaperWidth(unit Unit) float64 {
	var _arg0 *C.GtkPrintSettings
	var _arg1 C.GtkUnit

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkUnit)(unit)

	var _cret C.double

	_cret = C.gtk_print_settings_get_paper_width(_arg0, _arg1)

	var _gdouble float64

	_gdouble = (float64)(_cret)

	return _gdouble
}

// Printer: convenience function to obtain the value of
// GTK_PRINT_SETTINGS_PRINTER.
func (s printSettings) Printer() string {
	var _arg0 *C.GtkPrintSettings

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	var _cret *C.char

	_cret = C.gtk_print_settings_get_printer(_arg0)

	var _utf8 string

	_utf8 = C.GoString(_cret)

	return _utf8
}

// PrinterLpi gets the value of GTK_PRINT_SETTINGS_PRINTER_LPI.
func (s printSettings) PrinterLpi() float64 {
	var _arg0 *C.GtkPrintSettings

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	var _cret C.double

	_cret = C.gtk_print_settings_get_printer_lpi(_arg0)

	var _gdouble float64

	_gdouble = (float64)(_cret)

	return _gdouble
}

// Resolution gets the value of GTK_PRINT_SETTINGS_RESOLUTION.
func (s printSettings) Resolution() int {
	var _arg0 *C.GtkPrintSettings

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	var _cret C.int

	_cret = C.gtk_print_settings_get_resolution(_arg0)

	var _gint int

	_gint = (int)(_cret)

	return _gint
}

// ResolutionX gets the value of GTK_PRINT_SETTINGS_RESOLUTION_X.
func (s printSettings) ResolutionX() int {
	var _arg0 *C.GtkPrintSettings

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	var _cret C.int

	_cret = C.gtk_print_settings_get_resolution_x(_arg0)

	var _gint int

	_gint = (int)(_cret)

	return _gint
}

// ResolutionY gets the value of GTK_PRINT_SETTINGS_RESOLUTION_Y.
func (s printSettings) ResolutionY() int {
	var _arg0 *C.GtkPrintSettings

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	var _cret C.int

	_cret = C.gtk_print_settings_get_resolution_y(_arg0)

	var _gint int

	_gint = (int)(_cret)

	return _gint
}

// Reverse gets the value of GTK_PRINT_SETTINGS_REVERSE.
func (s printSettings) Reverse() bool {
	var _arg0 *C.GtkPrintSettings

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	var _cret C.gboolean

	_cret = C.gtk_print_settings_get_reverse(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// Scale gets the value of GTK_PRINT_SETTINGS_SCALE.
func (s printSettings) Scale() float64 {
	var _arg0 *C.GtkPrintSettings

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	var _cret C.double

	_cret = C.gtk_print_settings_get_scale(_arg0)

	var _gdouble float64

	_gdouble = (float64)(_cret)

	return _gdouble
}

// UseColor gets the value of GTK_PRINT_SETTINGS_USE_COLOR.
func (s printSettings) UseColor() bool {
	var _arg0 *C.GtkPrintSettings

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	var _cret C.gboolean

	_cret = C.gtk_print_settings_get_use_color(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// HasKey returns true, if a value is associated with @key.
func (s printSettings) HasKey(key string) bool {
	var _arg0 *C.GtkPrintSettings
	var _arg1 *C.char

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))

	var _cret C.gboolean

	_cret = C.gtk_print_settings_has_key(_arg0, _arg1)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// LoadFile reads the print settings from @file_name.
//
// If the file could not be loaded then error is set to either a
// `GFileError` or `GKeyFileError`.
//
// See [method@Gtk.PrintSettings.to_file].
func (s printSettings) LoadFile(fileName *string) error {
	var _arg0 *C.GtkPrintSettings
	var _arg1 *C.char

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(fileName))
	defer C.free(unsafe.Pointer(_arg1))

	var _cerr *C.GError

	C.gtk_print_settings_load_file(_arg0, _arg1, _cerr)

	var _goerr error

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// LoadKeyFile reads the print settings from the group @group_name in
// @key_file.
//
// If the file could not be loaded then error is set to either a
// `GFileError` or `GKeyFileError`.
func (s printSettings) LoadKeyFile(keyFile *glib.KeyFile, groupName string) error {
	var _arg0 *C.GtkPrintSettings
	var _arg1 *C.GKeyFile
	var _arg2 *C.char

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GKeyFile)(unsafe.Pointer(keyFile.Native()))
	_arg2 = (*C.char)(C.CString(groupName))
	defer C.free(unsafe.Pointer(_arg2))

	var _cerr *C.GError

	C.gtk_print_settings_load_key_file(_arg0, _arg1, _arg2, _cerr)

	var _goerr error

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// Set associates @value with @key.
func (s printSettings) Set(key string, value string) {
	var _arg0 *C.GtkPrintSettings
	var _arg1 *C.char
	var _arg2 *C.char

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.char)(C.CString(value))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_print_settings_set(_arg0, _arg1, _arg2)
}

// SetBool sets @key to a boolean value.
func (s printSettings) SetBool(key string, value bool) {
	var _arg0 *C.GtkPrintSettings
	var _arg1 *C.char
	var _arg2 C.gboolean

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))
	if value {
		_arg2 = C.gboolean(1)
	}

	C.gtk_print_settings_set_bool(_arg0, _arg1, _arg2)
}

// SetCollate sets the value of GTK_PRINT_SETTINGS_COLLATE.
func (s printSettings) SetCollate(collate bool) {
	var _arg0 *C.GtkPrintSettings
	var _arg1 C.gboolean

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	if collate {
		_arg1 = C.gboolean(1)
	}

	C.gtk_print_settings_set_collate(_arg0, _arg1)
}

// SetDefaultSource sets the value of GTK_PRINT_SETTINGS_DEFAULT_SOURCE.
func (s printSettings) SetDefaultSource(defaultSource string) {
	var _arg0 *C.GtkPrintSettings
	var _arg1 *C.char

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(defaultSource))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_print_settings_set_default_source(_arg0, _arg1)
}

// SetDither sets the value of GTK_PRINT_SETTINGS_DITHER.
func (s printSettings) SetDither(dither string) {
	var _arg0 *C.GtkPrintSettings
	var _arg1 *C.char

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(dither))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_print_settings_set_dither(_arg0, _arg1)
}

// SetDouble sets @key to a double value.
func (s printSettings) SetDouble(key string, value float64) {
	var _arg0 *C.GtkPrintSettings
	var _arg1 *C.char
	var _arg2 C.double

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.double(value)

	C.gtk_print_settings_set_double(_arg0, _arg1, _arg2)
}

// SetDuplex sets the value of GTK_PRINT_SETTINGS_DUPLEX.
func (s printSettings) SetDuplex(duplex PrintDuplex) {
	var _arg0 *C.GtkPrintSettings
	var _arg1 C.GtkPrintDuplex

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkPrintDuplex)(duplex)

	C.gtk_print_settings_set_duplex(_arg0, _arg1)
}

// SetFinishings sets the value of GTK_PRINT_SETTINGS_FINISHINGS.
func (s printSettings) SetFinishings(finishings string) {
	var _arg0 *C.GtkPrintSettings
	var _arg1 *C.char

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(finishings))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_print_settings_set_finishings(_arg0, _arg1)
}

// SetInt sets @key to an integer value.
func (s printSettings) SetInt(key string, value int) {
	var _arg0 *C.GtkPrintSettings
	var _arg1 *C.char
	var _arg2 C.int

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.int(value)

	C.gtk_print_settings_set_int(_arg0, _arg1, _arg2)
}

// SetLength associates a length in units of @unit with @key.
func (s printSettings) SetLength(key string, value float64, unit Unit) {
	var _arg0 *C.GtkPrintSettings
	var _arg1 *C.char
	var _arg2 C.double
	var _arg3 C.GtkUnit

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.double(value)
	_arg3 = (C.GtkUnit)(unit)

	C.gtk_print_settings_set_length(_arg0, _arg1, _arg2, _arg3)
}

// SetMediaType sets the value of GTK_PRINT_SETTINGS_MEDIA_TYPE.
//
// The set of media types is defined in PWG 5101.1-2002 PWG.
func (s printSettings) SetMediaType(mediaType string) {
	var _arg0 *C.GtkPrintSettings
	var _arg1 *C.char

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(mediaType))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_print_settings_set_media_type(_arg0, _arg1)
}

// SetNCopies sets the value of GTK_PRINT_SETTINGS_N_COPIES.
func (s printSettings) SetNCopies(numCopies int) {
	var _arg0 *C.GtkPrintSettings
	var _arg1 C.int

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = C.int(numCopies)

	C.gtk_print_settings_set_n_copies(_arg0, _arg1)
}

// SetNumberUp sets the value of GTK_PRINT_SETTINGS_NUMBER_UP.
func (s printSettings) SetNumberUp(numberUp int) {
	var _arg0 *C.GtkPrintSettings
	var _arg1 C.int

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = C.int(numberUp)

	C.gtk_print_settings_set_number_up(_arg0, _arg1)
}

// SetNumberUpLayout sets the value of GTK_PRINT_SETTINGS_NUMBER_UP_LAYOUT.
func (s printSettings) SetNumberUpLayout(numberUpLayout NumberUpLayout) {
	var _arg0 *C.GtkPrintSettings
	var _arg1 C.GtkNumberUpLayout

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkNumberUpLayout)(numberUpLayout)

	C.gtk_print_settings_set_number_up_layout(_arg0, _arg1)
}

// SetOrientation sets the value of GTK_PRINT_SETTINGS_ORIENTATION.
func (s printSettings) SetOrientation(orientation PageOrientation) {
	var _arg0 *C.GtkPrintSettings
	var _arg1 C.GtkPageOrientation

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkPageOrientation)(orientation)

	C.gtk_print_settings_set_orientation(_arg0, _arg1)
}

// SetOutputBin sets the value of GTK_PRINT_SETTINGS_OUTPUT_BIN.
func (s printSettings) SetOutputBin(outputBin string) {
	var _arg0 *C.GtkPrintSettings
	var _arg1 *C.char

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(outputBin))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_print_settings_set_output_bin(_arg0, _arg1)
}

// SetPageRanges sets the value of GTK_PRINT_SETTINGS_PAGE_RANGES.
func (s printSettings) SetPageRanges(pageRanges []PageRange) {
	var _arg0 *C.GtkPrintSettings
	var _arg1 *C.GtkPageRange
	var _arg2 C.int

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg2 = C.int(len(pageRanges))
	_arg1 = (*C.GtkPageRange)(unsafe.Pointer(&pageRanges[0]))

	C.gtk_print_settings_set_page_ranges(_arg0, _arg1, _arg2)
}

// SetPageSet sets the value of GTK_PRINT_SETTINGS_PAGE_SET.
func (s printSettings) SetPageSet(pageSet PageSet) {
	var _arg0 *C.GtkPrintSettings
	var _arg1 C.GtkPageSet

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkPageSet)(pageSet)

	C.gtk_print_settings_set_page_set(_arg0, _arg1)
}

// SetPaperHeight sets the value of GTK_PRINT_SETTINGS_PAPER_HEIGHT.
func (s printSettings) SetPaperHeight(height float64, unit Unit) {
	var _arg0 *C.GtkPrintSettings
	var _arg1 C.double
	var _arg2 C.GtkUnit

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = C.double(height)
	_arg2 = (C.GtkUnit)(unit)

	C.gtk_print_settings_set_paper_height(_arg0, _arg1, _arg2)
}

// SetPaperSize sets the value of GTK_PRINT_SETTINGS_PAPER_FORMAT,
// GTK_PRINT_SETTINGS_PAPER_WIDTH and GTK_PRINT_SETTINGS_PAPER_HEIGHT.
func (s printSettings) SetPaperSize(paperSize *PaperSize) {
	var _arg0 *C.GtkPrintSettings
	var _arg1 *C.GtkPaperSize

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkPaperSize)(unsafe.Pointer(paperSize.Native()))

	C.gtk_print_settings_set_paper_size(_arg0, _arg1)
}

// SetPaperWidth sets the value of GTK_PRINT_SETTINGS_PAPER_WIDTH.
func (s printSettings) SetPaperWidth(width float64, unit Unit) {
	var _arg0 *C.GtkPrintSettings
	var _arg1 C.double
	var _arg2 C.GtkUnit

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = C.double(width)
	_arg2 = (C.GtkUnit)(unit)

	C.gtk_print_settings_set_paper_width(_arg0, _arg1, _arg2)
}

// SetPrintPages sets the value of GTK_PRINT_SETTINGS_PRINT_PAGES.
func (s printSettings) SetPrintPages(pages PrintPages) {
	var _arg0 *C.GtkPrintSettings
	var _arg1 C.GtkPrintPages

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkPrintPages)(pages)

	C.gtk_print_settings_set_print_pages(_arg0, _arg1)
}

// SetPrinter: convenience function to set GTK_PRINT_SETTINGS_PRINTER to
// @printer.
func (s printSettings) SetPrinter(printer string) {
	var _arg0 *C.GtkPrintSettings
	var _arg1 *C.char

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(printer))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_print_settings_set_printer(_arg0, _arg1)
}

// SetPrinterLpi sets the value of GTK_PRINT_SETTINGS_PRINTER_LPI.
func (s printSettings) SetPrinterLpi(lpi float64) {
	var _arg0 *C.GtkPrintSettings
	var _arg1 C.double

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = C.double(lpi)

	C.gtk_print_settings_set_printer_lpi(_arg0, _arg1)
}

// SetQuality sets the value of GTK_PRINT_SETTINGS_QUALITY.
func (s printSettings) SetQuality(quality PrintQuality) {
	var _arg0 *C.GtkPrintSettings
	var _arg1 C.GtkPrintQuality

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkPrintQuality)(quality)

	C.gtk_print_settings_set_quality(_arg0, _arg1)
}

// SetResolution sets the values of GTK_PRINT_SETTINGS_RESOLUTION,
// GTK_PRINT_SETTINGS_RESOLUTION_X and GTK_PRINT_SETTINGS_RESOLUTION_Y.
func (s printSettings) SetResolution(resolution int) {
	var _arg0 *C.GtkPrintSettings
	var _arg1 C.int

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = C.int(resolution)

	C.gtk_print_settings_set_resolution(_arg0, _arg1)
}

// SetResolutionXY sets the values of GTK_PRINT_SETTINGS_RESOLUTION,
// GTK_PRINT_SETTINGS_RESOLUTION_X and GTK_PRINT_SETTINGS_RESOLUTION_Y.
func (s printSettings) SetResolutionXY(resolutionX int, resolutionY int) {
	var _arg0 *C.GtkPrintSettings
	var _arg1 C.int
	var _arg2 C.int

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = C.int(resolutionX)
	_arg2 = C.int(resolutionY)

	C.gtk_print_settings_set_resolution_xy(_arg0, _arg1, _arg2)
}

// SetReverse sets the value of GTK_PRINT_SETTINGS_REVERSE.
func (s printSettings) SetReverse(reverse bool) {
	var _arg0 *C.GtkPrintSettings
	var _arg1 C.gboolean

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	if reverse {
		_arg1 = C.gboolean(1)
	}

	C.gtk_print_settings_set_reverse(_arg0, _arg1)
}

// SetScale sets the value of GTK_PRINT_SETTINGS_SCALE.
func (s printSettings) SetScale(scale float64) {
	var _arg0 *C.GtkPrintSettings
	var _arg1 C.double

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = C.double(scale)

	C.gtk_print_settings_set_scale(_arg0, _arg1)
}

// SetUseColor sets the value of GTK_PRINT_SETTINGS_USE_COLOR.
func (s printSettings) SetUseColor(useColor bool) {
	var _arg0 *C.GtkPrintSettings
	var _arg1 C.gboolean

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	if useColor {
		_arg1 = C.gboolean(1)
	}

	C.gtk_print_settings_set_use_color(_arg0, _arg1)
}

// ToFile: this function saves the print settings from @settings to
// @file_name.
//
// If the file could not be written then error is set to either a
// `GFileError` or `GKeyFileError`.
func (s printSettings) ToFile(fileName *string) error {
	var _arg0 *C.GtkPrintSettings
	var _arg1 *C.char

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(fileName))
	defer C.free(unsafe.Pointer(_arg1))

	var _cerr *C.GError

	C.gtk_print_settings_to_file(_arg0, _arg1, _cerr)

	var _goerr error

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// ToKeyFile: this function adds the print settings from @settings to
// @key_file.
func (s printSettings) ToKeyFile(keyFile *glib.KeyFile, groupName string) {
	var _arg0 *C.GtkPrintSettings
	var _arg1 *C.GKeyFile
	var _arg2 *C.char

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GKeyFile)(unsafe.Pointer(keyFile.Native()))
	_arg2 = (*C.char)(C.CString(groupName))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_print_settings_to_key_file(_arg0, _arg1, _arg2)
}

// Unset removes any value associated with @key.
//
// This has the same effect as setting the value to nil.
func (s printSettings) Unset(key string) {
	var _arg0 *C.GtkPrintSettings
	var _arg1 *C.char

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_print_settings_unset(_arg0, _arg1)
}

// PrintUnixDialog: `GtkPrintUnixDialog` implements a print dialog for platforms
// which don’t provide a native print dialog, like Unix.
//
// !An example GtkPrintUnixDialog (printdialog.png)
//
// It can be used very much like any other GTK dialog, at the cost of the
// portability offered by the high-level printing API with
// [class@Gtk.PrintOperation].
//
// In order to print something with `GtkPrintUnixDialog`, you need to use
// [method@Gtk.PrintUnixDialog.get_selected_printer] to obtain a
// [class@Gtk.Printer] object and use it to construct a [class@Gtk.PrintJob]
// using [ctor@Gtk.PrintJob.new].
//
// `GtkPrintUnixDialog` uses the following response values:
//
// - GTK_RESPONSE_OK: for the “Print” button - GTK_RESPONSE_APPLY: for the
// “Preview” button - GTK_RESPONSE_CANCEL: for the “Cancel” button
//
//
// GtkPrintUnixDialog as GtkBuildable
//
// The `GtkPrintUnixDialog` implementation of the `GtkBuildable` interface
// exposes its @notebook internal children with the name “notebook”.
//
// An example of a `GtkPrintUnixDialog` UI definition fragment:
//
// “`xml <object class="GtkPrintUnixDialog" id="dialog1"> <child
// internal-child="notebook"> <object class="GtkNotebook" id="notebook"> <child>
// <object type="GtkNotebookPage"> <property name="tab_expand">False</property>
// <property name="tab_fill">False</property> <property name="tab"> <object
// class="GtkLabel" id="tablabel"> <property name="label">Tab label</property>
// </object> </property> <property name="child"> <object class="GtkLabel"
// id="tabcontent"> <property name="label">Content on notebook tab</property>
// </object> </property> </object> </child> </object> </child> </object> “`
//
//
// CSS nodes
//
// `GtkPrintUnixDialog` has a single CSS node with name window. The style
// classes dialog and print are added.
type PrintUnixDialog interface {
	Dialog
	Accessible
	Buildable
	ConstraintTarget
	Native
	Root
	ShortcutManager

	// AddCustomTab adds a custom tab to the print dialog.
	AddCustomTab(child Widget, tabLabel Widget)
	// CurrentPage gets the current page of the `GtkPrintUnixDialog`.
	CurrentPage() int
	// EmbedPageSetup gets whether to embed the page setup.
	EmbedPageSetup() bool
	// HasSelection gets whether there is a selection.
	HasSelection() bool
	// PageSetupSet gets whether a page setup was set by the user.
	PageSetupSet() bool
	// SupportSelection gets whether the print dialog allows user to print a
	// selection.
	SupportSelection() bool
	// SetCurrentPage sets the current page number.
	//
	// If @current_page is not -1, this enables the current page choice for the
	// range of pages to print.
	SetCurrentPage(currentPage int)
	// SetEmbedPageSetup: embed page size combo box and orientation combo box
	// into page setup page.
	SetEmbedPageSetup(embed bool)
	// SetHasSelection sets whether a selection exists.
	SetHasSelection(hasSelection bool)
	// SetManualCapabilities: this lets you specify the printing capabilities
	// your application supports.
	//
	// For instance, if you can handle scaling the output then you pass
	// GTK_PRINT_CAPABILITY_SCALE. If you don’t pass that, then the dialog will
	// only let you select the scale if the printing system automatically
	// handles scaling.
	SetManualCapabilities(capabilities PrintCapabilities)
	// SetPageSetup sets the page setup of the `GtkPrintUnixDialog`.
	SetPageSetup(pageSetup PageSetup)
	// SetSettings sets the `GtkPrintSettings` for the `GtkPrintUnixDialog`.
	//
	// Typically, this is used to restore saved print settings from a previous
	// print operation before the print dialog is shown.
	SetSettings(settings PrintSettings)
	// SetSupportSelection sets whether the print dialog allows user to print a
	// selection.
	SetSupportSelection(supportSelection bool)
}

// printUnixDialog implements the PrintUnixDialog interface.
type printUnixDialog struct {
	Dialog
	Accessible
	Buildable
	ConstraintTarget
	Native
	Root
	ShortcutManager
}

var _ PrintUnixDialog = (*printUnixDialog)(nil)

// WrapPrintUnixDialog wraps a GObject to the right type. It is
// primarily used internally.
func WrapPrintUnixDialog(obj *externglib.Object) PrintUnixDialog {
	return PrintUnixDialog{
		Dialog:           WrapDialog(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
		Native:           WrapNative(obj),
		Root:             WrapRoot(obj),
		ShortcutManager:  WrapShortcutManager(obj),
	}
}

func marshalPrintUnixDialog(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPrintUnixDialog(obj), nil
}

// AddCustomTab adds a custom tab to the print dialog.
func (d printUnixDialog) AddCustomTab(child Widget, tabLabel Widget) {
	var _arg0 *C.GtkPrintUnixDialog
	var _arg1 *C.GtkWidget
	var _arg2 *C.GtkWidget

	_arg0 = (*C.GtkPrintUnixDialog)(unsafe.Pointer(d.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(tabLabel.Native()))

	C.gtk_print_unix_dialog_add_custom_tab(_arg0, _arg1, _arg2)
}

// CurrentPage gets the current page of the `GtkPrintUnixDialog`.
func (d printUnixDialog) CurrentPage() int {
	var _arg0 *C.GtkPrintUnixDialog

	_arg0 = (*C.GtkPrintUnixDialog)(unsafe.Pointer(d.Native()))

	var _cret C.int

	_cret = C.gtk_print_unix_dialog_get_current_page(_arg0)

	var _gint int

	_gint = (int)(_cret)

	return _gint
}

// EmbedPageSetup gets whether to embed the page setup.
func (d printUnixDialog) EmbedPageSetup() bool {
	var _arg0 *C.GtkPrintUnixDialog

	_arg0 = (*C.GtkPrintUnixDialog)(unsafe.Pointer(d.Native()))

	var _cret C.gboolean

	_cret = C.gtk_print_unix_dialog_get_embed_page_setup(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// HasSelection gets whether there is a selection.
func (d printUnixDialog) HasSelection() bool {
	var _arg0 *C.GtkPrintUnixDialog

	_arg0 = (*C.GtkPrintUnixDialog)(unsafe.Pointer(d.Native()))

	var _cret C.gboolean

	_cret = C.gtk_print_unix_dialog_get_has_selection(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// PageSetupSet gets whether a page setup was set by the user.
func (d printUnixDialog) PageSetupSet() bool {
	var _arg0 *C.GtkPrintUnixDialog

	_arg0 = (*C.GtkPrintUnixDialog)(unsafe.Pointer(d.Native()))

	var _cret C.gboolean

	_cret = C.gtk_print_unix_dialog_get_page_setup_set(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// SupportSelection gets whether the print dialog allows user to print a
// selection.
func (d printUnixDialog) SupportSelection() bool {
	var _arg0 *C.GtkPrintUnixDialog

	_arg0 = (*C.GtkPrintUnixDialog)(unsafe.Pointer(d.Native()))

	var _cret C.gboolean

	_cret = C.gtk_print_unix_dialog_get_support_selection(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// SetCurrentPage sets the current page number.
//
// If @current_page is not -1, this enables the current page choice for the
// range of pages to print.
func (d printUnixDialog) SetCurrentPage(currentPage int) {
	var _arg0 *C.GtkPrintUnixDialog
	var _arg1 C.int

	_arg0 = (*C.GtkPrintUnixDialog)(unsafe.Pointer(d.Native()))
	_arg1 = C.int(currentPage)

	C.gtk_print_unix_dialog_set_current_page(_arg0, _arg1)
}

// SetEmbedPageSetup: embed page size combo box and orientation combo box
// into page setup page.
func (d printUnixDialog) SetEmbedPageSetup(embed bool) {
	var _arg0 *C.GtkPrintUnixDialog
	var _arg1 C.gboolean

	_arg0 = (*C.GtkPrintUnixDialog)(unsafe.Pointer(d.Native()))
	if embed {
		_arg1 = C.gboolean(1)
	}

	C.gtk_print_unix_dialog_set_embed_page_setup(_arg0, _arg1)
}

// SetHasSelection sets whether a selection exists.
func (d printUnixDialog) SetHasSelection(hasSelection bool) {
	var _arg0 *C.GtkPrintUnixDialog
	var _arg1 C.gboolean

	_arg0 = (*C.GtkPrintUnixDialog)(unsafe.Pointer(d.Native()))
	if hasSelection {
		_arg1 = C.gboolean(1)
	}

	C.gtk_print_unix_dialog_set_has_selection(_arg0, _arg1)
}

// SetManualCapabilities: this lets you specify the printing capabilities
// your application supports.
//
// For instance, if you can handle scaling the output then you pass
// GTK_PRINT_CAPABILITY_SCALE. If you don’t pass that, then the dialog will
// only let you select the scale if the printing system automatically
// handles scaling.
func (d printUnixDialog) SetManualCapabilities(capabilities PrintCapabilities) {
	var _arg0 *C.GtkPrintUnixDialog
	var _arg1 C.GtkPrintCapabilities

	_arg0 = (*C.GtkPrintUnixDialog)(unsafe.Pointer(d.Native()))
	_arg1 = (C.GtkPrintCapabilities)(capabilities)

	C.gtk_print_unix_dialog_set_manual_capabilities(_arg0, _arg1)
}

// SetPageSetup sets the page setup of the `GtkPrintUnixDialog`.
func (d printUnixDialog) SetPageSetup(pageSetup PageSetup) {
	var _arg0 *C.GtkPrintUnixDialog
	var _arg1 *C.GtkPageSetup

	_arg0 = (*C.GtkPrintUnixDialog)(unsafe.Pointer(d.Native()))
	_arg1 = (*C.GtkPageSetup)(unsafe.Pointer(pageSetup.Native()))

	C.gtk_print_unix_dialog_set_page_setup(_arg0, _arg1)
}

// SetSettings sets the `GtkPrintSettings` for the `GtkPrintUnixDialog`.
//
// Typically, this is used to restore saved print settings from a previous
// print operation before the print dialog is shown.
func (d printUnixDialog) SetSettings(settings PrintSettings) {
	var _arg0 *C.GtkPrintUnixDialog
	var _arg1 *C.GtkPrintSettings

	_arg0 = (*C.GtkPrintUnixDialog)(unsafe.Pointer(d.Native()))
	_arg1 = (*C.GtkPrintSettings)(unsafe.Pointer(settings.Native()))

	C.gtk_print_unix_dialog_set_settings(_arg0, _arg1)
}

// SetSupportSelection sets whether the print dialog allows user to print a
// selection.
func (d printUnixDialog) SetSupportSelection(supportSelection bool) {
	var _arg0 *C.GtkPrintUnixDialog
	var _arg1 C.gboolean

	_arg0 = (*C.GtkPrintUnixDialog)(unsafe.Pointer(d.Native()))
	if supportSelection {
		_arg1 = C.gboolean(1)
	}

	C.gtk_print_unix_dialog_set_support_selection(_arg0, _arg1)
}

// Printer: a `GtkPrinter` object represents a printer.
//
// You only need to deal directly with printers if you use the non-portable
// [class@Gtk.PrintUnixDialog] API.
//
// A `GtkPrinter` allows to get status information about the printer, such as
// its description, its location, the number of queued jobs, etc. Most
// importantly, a `GtkPrinter` object can be used to create a
// [class@Gtk.PrintJob] object, which lets you print to the printer.
type Printer interface {
	gextras.Objector

	// AcceptsPDF returns whether the printer accepts input in PDF format.
	AcceptsPDF() bool
	// AcceptsPS returns whether the printer accepts input in PostScript format.
	AcceptsPS() bool
	// Compare compares two printers.
	Compare(b Printer) int
	// Description gets the description of the printer.
	Description() string
	// HardMargins: retrieve the hard margins of @printer.
	//
	// These are the margins that define the area at the borders of the paper
	// that the printer cannot print to.
	//
	// Note: This will not succeed unless the printer’s details are available,
	// see [method@Gtk.Printer.has_details] and
	// [method@Gtk.Printer.request_details].
	HardMargins() (top float64, bottom float64, left float64, right float64, ok bool)
	// HardMarginsForPaperSize: retrieve the hard margins of @printer for
	// @paper_size.
	//
	// These are the margins that define the area at the borders of the paper
	// that the printer cannot print to.
	//
	// Note: This will not succeed unless the printer’s details are available,
	// see [method@Gtk.Printer.has_details] and
	// [method@Gtk.Printer.request_details].
	HardMarginsForPaperSize(paperSize *PaperSize) (top float64, bottom float64, left float64, right float64, ok bool)
	// IconName gets the name of the icon to use for the printer.
	IconName() string
	// JobCount gets the number of jobs currently queued on the printer.
	JobCount() int
	// Location returns a description of the location of the printer.
	Location() string
	// Name returns the name of the printer.
	Name() string
	// StateMessage returns the state message describing the current state of
	// the printer.
	StateMessage() string
	// HasDetails returns whether the printer details are available.
	HasDetails() bool
	// IsAcceptingJobs returns whether the printer is accepting jobs
	IsAcceptingJobs() bool
	// IsActive returns whether the printer is currently active (i.e. accepts
	// new jobs).
	IsActive() bool
	// IsDefault returns whether the printer is the default printer.
	IsDefault() bool
	// IsPaused returns whether the printer is currently paused.
	//
	// A paused printer still accepts jobs, but it is not printing them.
	IsPaused() bool
	// IsVirtual returns whether the printer is virtual (i.e. does not represent
	// actual printer hardware, but something like a CUPS class).
	IsVirtual() bool
	// RequestDetails requests the printer details.
	//
	// When the details are available, the
	// [signal@Gtk.Printer::details-acquired] signal will be emitted on
	// @printer.
	RequestDetails()
}

// printer implements the Printer interface.
type printer struct {
	gextras.Objector
}

var _ Printer = (*printer)(nil)

// WrapPrinter wraps a GObject to the right type. It is
// primarily used internally.
func WrapPrinter(obj *externglib.Object) Printer {
	return Printer{
		Objector: obj,
	}
}

func marshalPrinter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPrinter(obj), nil
}

// AcceptsPDF returns whether the printer accepts input in PDF format.
func (p printer) AcceptsPDF() bool {
	var _arg0 *C.GtkPrinter

	_arg0 = (*C.GtkPrinter)(unsafe.Pointer(p.Native()))

	var _cret C.gboolean

	_cret = C.gtk_printer_accepts_pdf(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// AcceptsPS returns whether the printer accepts input in PostScript format.
func (p printer) AcceptsPS() bool {
	var _arg0 *C.GtkPrinter

	_arg0 = (*C.GtkPrinter)(unsafe.Pointer(p.Native()))

	var _cret C.gboolean

	_cret = C.gtk_printer_accepts_ps(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// Compare compares two printers.
func (a printer) Compare(b Printer) int {
	var _arg0 *C.GtkPrinter
	var _arg1 *C.GtkPrinter

	_arg0 = (*C.GtkPrinter)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkPrinter)(unsafe.Pointer(b.Native()))

	var _cret C.int

	_cret = C.gtk_printer_compare(_arg0, _arg1)

	var _gint int

	_gint = (int)(_cret)

	return _gint
}

// Description gets the description of the printer.
func (p printer) Description() string {
	var _arg0 *C.GtkPrinter

	_arg0 = (*C.GtkPrinter)(unsafe.Pointer(p.Native()))

	var _cret *C.char

	_cret = C.gtk_printer_get_description(_arg0)

	var _utf8 string

	_utf8 = C.GoString(_cret)

	return _utf8
}

// HardMargins: retrieve the hard margins of @printer.
//
// These are the margins that define the area at the borders of the paper
// that the printer cannot print to.
//
// Note: This will not succeed unless the printer’s details are available,
// see [method@Gtk.Printer.has_details] and
// [method@Gtk.Printer.request_details].
func (p printer) HardMargins() (top float64, bottom float64, left float64, right float64, ok bool) {
	var _arg0 *C.GtkPrinter

	_arg0 = (*C.GtkPrinter)(unsafe.Pointer(p.Native()))

	var _arg1 C.double
	var _arg2 C.double
	var _arg3 C.double
	var _arg4 C.double
	var _cret C.gboolean

	_cret = C.gtk_printer_get_hard_margins(_arg0, &_arg1, &_arg2, &_arg3, &_arg4)

	var _top float64
	var _bottom float64
	var _left float64
	var _right float64
	var _ok bool

	_top = (float64)(_arg1)
	_bottom = (float64)(_arg2)
	_left = (float64)(_arg3)
	_right = (float64)(_arg4)
	if _cret {
		_ok = true
	}

	return _top, _bottom, _left, _right, _ok
}

// HardMarginsForPaperSize: retrieve the hard margins of @printer for
// @paper_size.
//
// These are the margins that define the area at the borders of the paper
// that the printer cannot print to.
//
// Note: This will not succeed unless the printer’s details are available,
// see [method@Gtk.Printer.has_details] and
// [method@Gtk.Printer.request_details].
func (p printer) HardMarginsForPaperSize(paperSize *PaperSize) (top float64, bottom float64, left float64, right float64, ok bool) {
	var _arg0 *C.GtkPrinter
	var _arg1 *C.GtkPaperSize

	_arg0 = (*C.GtkPrinter)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.GtkPaperSize)(unsafe.Pointer(paperSize.Native()))

	var _arg2 C.double
	var _arg3 C.double
	var _arg4 C.double
	var _arg5 C.double
	var _cret C.gboolean

	_cret = C.gtk_printer_get_hard_margins_for_paper_size(_arg0, _arg1, &_arg2, &_arg3, &_arg4, &_arg5)

	var _top float64
	var _bottom float64
	var _left float64
	var _right float64
	var _ok bool

	_top = (float64)(_arg2)
	_bottom = (float64)(_arg3)
	_left = (float64)(_arg4)
	_right = (float64)(_arg5)
	if _cret {
		_ok = true
	}

	return _top, _bottom, _left, _right, _ok
}

// IconName gets the name of the icon to use for the printer.
func (p printer) IconName() string {
	var _arg0 *C.GtkPrinter

	_arg0 = (*C.GtkPrinter)(unsafe.Pointer(p.Native()))

	var _cret *C.char

	_cret = C.gtk_printer_get_icon_name(_arg0)

	var _utf8 string

	_utf8 = C.GoString(_cret)

	return _utf8
}

// JobCount gets the number of jobs currently queued on the printer.
func (p printer) JobCount() int {
	var _arg0 *C.GtkPrinter

	_arg0 = (*C.GtkPrinter)(unsafe.Pointer(p.Native()))

	var _cret C.int

	_cret = C.gtk_printer_get_job_count(_arg0)

	var _gint int

	_gint = (int)(_cret)

	return _gint
}

// Location returns a description of the location of the printer.
func (p printer) Location() string {
	var _arg0 *C.GtkPrinter

	_arg0 = (*C.GtkPrinter)(unsafe.Pointer(p.Native()))

	var _cret *C.char

	_cret = C.gtk_printer_get_location(_arg0)

	var _utf8 string

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Name returns the name of the printer.
func (p printer) Name() string {
	var _arg0 *C.GtkPrinter

	_arg0 = (*C.GtkPrinter)(unsafe.Pointer(p.Native()))

	var _cret *C.char

	_cret = C.gtk_printer_get_name(_arg0)

	var _utf8 string

	_utf8 = C.GoString(_cret)

	return _utf8
}

// StateMessage returns the state message describing the current state of
// the printer.
func (p printer) StateMessage() string {
	var _arg0 *C.GtkPrinter

	_arg0 = (*C.GtkPrinter)(unsafe.Pointer(p.Native()))

	var _cret *C.char

	_cret = C.gtk_printer_get_state_message(_arg0)

	var _utf8 string

	_utf8 = C.GoString(_cret)

	return _utf8
}

// HasDetails returns whether the printer details are available.
func (p printer) HasDetails() bool {
	var _arg0 *C.GtkPrinter

	_arg0 = (*C.GtkPrinter)(unsafe.Pointer(p.Native()))

	var _cret C.gboolean

	_cret = C.gtk_printer_has_details(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// IsAcceptingJobs returns whether the printer is accepting jobs
func (p printer) IsAcceptingJobs() bool {
	var _arg0 *C.GtkPrinter

	_arg0 = (*C.GtkPrinter)(unsafe.Pointer(p.Native()))

	var _cret C.gboolean

	_cret = C.gtk_printer_is_accepting_jobs(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// IsActive returns whether the printer is currently active (i.e. accepts
// new jobs).
func (p printer) IsActive() bool {
	var _arg0 *C.GtkPrinter

	_arg0 = (*C.GtkPrinter)(unsafe.Pointer(p.Native()))

	var _cret C.gboolean

	_cret = C.gtk_printer_is_active(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// IsDefault returns whether the printer is the default printer.
func (p printer) IsDefault() bool {
	var _arg0 *C.GtkPrinter

	_arg0 = (*C.GtkPrinter)(unsafe.Pointer(p.Native()))

	var _cret C.gboolean

	_cret = C.gtk_printer_is_default(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// IsPaused returns whether the printer is currently paused.
//
// A paused printer still accepts jobs, but it is not printing them.
func (p printer) IsPaused() bool {
	var _arg0 *C.GtkPrinter

	_arg0 = (*C.GtkPrinter)(unsafe.Pointer(p.Native()))

	var _cret C.gboolean

	_cret = C.gtk_printer_is_paused(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// IsVirtual returns whether the printer is virtual (i.e. does not represent
// actual printer hardware, but something like a CUPS class).
func (p printer) IsVirtual() bool {
	var _arg0 *C.GtkPrinter

	_arg0 = (*C.GtkPrinter)(unsafe.Pointer(p.Native()))

	var _cret C.gboolean

	_cret = C.gtk_printer_is_virtual(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// RequestDetails requests the printer details.
//
// When the details are available, the
// [signal@Gtk.Printer::details-acquired] signal will be emitted on
// @printer.
func (p printer) RequestDetails() {
	var _arg0 *C.GtkPrinter

	_arg0 = (*C.GtkPrinter)(unsafe.Pointer(p.Native()))

	C.gtk_printer_request_details(_arg0)
}

// ProgressBar: `GtkProgressBar` is typically used to display the progress of a
// long running operation.
//
// It provides a visual clue that processing is underway. `GtkProgressBar` can
// be used in two different modes: percentage mode and activity mode.
//
// !An example GtkProgressBar (progressbar.png)
//
// When an application can determine how much work needs to take place (e.g.
// read a fixed number of bytes from a file) and can monitor its progress, it
// can use the `GtkProgressBar` in percentage mode and the user sees a growing
// bar indicating the percentage of the work that has been completed. In this
// mode, the application is required to call
// [method@Gtk.ProgressBar.set_fraction] periodically to update the progress
// bar.
//
// When an application has no accurate way of knowing the amount of work to do,
// it can use the `GtkProgressBar` in activity mode, which shows activity by a
// block moving back and forth within the progress area. In this mode, the
// application is required to call [method@Gtk.ProgressBar.pulse] periodically
// to update the progress bar.
//
// There is quite a bit of flexibility provided to control the appearance of the
// `GtkProgressBar`. Functions are provided to control the orientation of the
// bar, optional text can be displayed along with the bar, and the step size
// used in activity mode can be set.
//
//
// CSS nodes
//
// “` progressbar[.osd] ├── [text] ╰── trough[.empty][.full] ╰──
// progress[.pulse] “`
//
// `GtkProgressBar` has a main CSS node with name progressbar and subnodes with
// names text and trough, of which the latter has a subnode named progress. The
// text subnode is only present if text is shown. The progress subnode has the
// style class .pulse when in activity mode. It gets the style classes .left,
// .right, .top or .bottom added when the progress 'touches' the corresponding
// end of the GtkProgressBar. The .osd class on the progressbar node is for use
// in overlays like the one Epiphany has for page loading progress.
//
//
// Accessibility
//
// `GtkProgressBar` uses the K_ACCESSIBLE_ROLE_PROGRESS_BAR role.
type ProgressBar interface {
	Widget
	Accessible
	Buildable
	ConstraintTarget
	Orientable

	// Fraction returns the current fraction of the task that’s been completed.
	Fraction() float64
	// Inverted returns whether the progress bar is inverted.
	Inverted() bool
	// PulseStep retrieves the pulse step.
	//
	// See [method@Gtk.ProgressBar.set_pulse_step].
	PulseStep() float64
	// ShowText returns whether the `GtkProgressBar` shows text.
	//
	// See [method@Gtk.ProgressBar.set_show_text].
	ShowText() bool
	// Text retrieves the text that is displayed with the progress bar.
	//
	// The return value is a reference to the text, not a copy of it, so will
	// become invalid if you change the text in the progress bar.
	Text() string
	// Pulse indicates that some progress has been made, but you don’t know how
	// much.
	//
	// Causes the progress bar to enter “activity mode,” where a block bounces
	// back and forth. Each call to [method@Gtk.ProgressBar.pulse] causes the
	// block to move by a little bit (the amount of movement per pulse is
	// determined by [method@Gtk.ProgressBar.set_pulse_step]).
	Pulse()
	// SetEllipsize sets the mode used to ellipsize the text.
	//
	// The text is ellipsized if there is not enough space to render the entire
	// string.
	SetEllipsize(mode pango.EllipsizeMode)
	// SetFraction causes the progress bar to “fill in” the given fraction of
	// the bar.
	//
	// The fraction should be between 0.0 and 1.0, inclusive.
	SetFraction(fraction float64)
	// SetInverted sets whether the progress bar is inverted.
	//
	// Progress bars normally grow from top to bottom or left to right. Inverted
	// progress bars grow in the opposite direction.
	SetInverted(inverted bool)
	// SetPulseStep sets the fraction of total progress bar length to move the
	// bouncing block.
	//
	// The bouncing block is moved when [method@Gtk.ProgressBar.pulse] is
	// called.
	SetPulseStep(fraction float64)
	// SetShowText sets whether the progress bar will show text next to the bar.
	//
	// The shown text is either the value of the [property@Gtk.ProgressBar:text]
	// property or, if that is nil, the [property@Gtk.ProgressBar:fraction]
	// value, as a percentage.
	//
	// To make a progress bar that is styled and sized suitably for containing
	// text (even if the actual text is blank), set
	// [property@Gtk.ProgressBar:show-text] to true and
	// [property@Gtk.ProgressBar:text] to the empty string (not nil).
	SetShowText(showText bool)
	// SetText causes the given @text to appear next to the progress bar.
	//
	// If @text is nil and [property@Gtk.ProgressBar:show-text] is true, the
	// current value of [property@Gtk.ProgressBar:fraction] will be displayed as
	// a percentage.
	//
	// If @text is non-nil and [property@Gtk.ProgressBar:show-text] is true, the
	// text will be displayed. In this case, it will not display the progress
	// percentage. If @text is the empty string, the progress bar will still be
	// styled and sized suitably for containing text, as long as
	// [property@Gtk.ProgressBar:show-text] is true.
	SetText(text string)
}

// progressBar implements the ProgressBar interface.
type progressBar struct {
	Widget
	Accessible
	Buildable
	ConstraintTarget
	Orientable
}

var _ ProgressBar = (*progressBar)(nil)

// WrapProgressBar wraps a GObject to the right type. It is
// primarily used internally.
func WrapProgressBar(obj *externglib.Object) ProgressBar {
	return ProgressBar{
		Widget:           WrapWidget(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
		Orientable:       WrapOrientable(obj),
	}
}

func marshalProgressBar(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapProgressBar(obj), nil
}

// Fraction returns the current fraction of the task that’s been completed.
func (p progressBar) Fraction() float64 {
	var _arg0 *C.GtkProgressBar

	_arg0 = (*C.GtkProgressBar)(unsafe.Pointer(p.Native()))

	var _cret C.double

	_cret = C.gtk_progress_bar_get_fraction(_arg0)

	var _gdouble float64

	_gdouble = (float64)(_cret)

	return _gdouble
}

// Inverted returns whether the progress bar is inverted.
func (p progressBar) Inverted() bool {
	var _arg0 *C.GtkProgressBar

	_arg0 = (*C.GtkProgressBar)(unsafe.Pointer(p.Native()))

	var _cret C.gboolean

	_cret = C.gtk_progress_bar_get_inverted(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// PulseStep retrieves the pulse step.
//
// See [method@Gtk.ProgressBar.set_pulse_step].
func (p progressBar) PulseStep() float64 {
	var _arg0 *C.GtkProgressBar

	_arg0 = (*C.GtkProgressBar)(unsafe.Pointer(p.Native()))

	var _cret C.double

	_cret = C.gtk_progress_bar_get_pulse_step(_arg0)

	var _gdouble float64

	_gdouble = (float64)(_cret)

	return _gdouble
}

// ShowText returns whether the `GtkProgressBar` shows text.
//
// See [method@Gtk.ProgressBar.set_show_text].
func (p progressBar) ShowText() bool {
	var _arg0 *C.GtkProgressBar

	_arg0 = (*C.GtkProgressBar)(unsafe.Pointer(p.Native()))

	var _cret C.gboolean

	_cret = C.gtk_progress_bar_get_show_text(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// Text retrieves the text that is displayed with the progress bar.
//
// The return value is a reference to the text, not a copy of it, so will
// become invalid if you change the text in the progress bar.
func (p progressBar) Text() string {
	var _arg0 *C.GtkProgressBar

	_arg0 = (*C.GtkProgressBar)(unsafe.Pointer(p.Native()))

	var _cret *C.char

	_cret = C.gtk_progress_bar_get_text(_arg0)

	var _utf8 string

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Pulse indicates that some progress has been made, but you don’t know how
// much.
//
// Causes the progress bar to enter “activity mode,” where a block bounces
// back and forth. Each call to [method@Gtk.ProgressBar.pulse] causes the
// block to move by a little bit (the amount of movement per pulse is
// determined by [method@Gtk.ProgressBar.set_pulse_step]).
func (p progressBar) Pulse() {
	var _arg0 *C.GtkProgressBar

	_arg0 = (*C.GtkProgressBar)(unsafe.Pointer(p.Native()))

	C.gtk_progress_bar_pulse(_arg0)
}

// SetEllipsize sets the mode used to ellipsize the text.
//
// The text is ellipsized if there is not enough space to render the entire
// string.
func (p progressBar) SetEllipsize(mode pango.EllipsizeMode) {
	var _arg0 *C.GtkProgressBar
	var _arg1 C.PangoEllipsizeMode

	_arg0 = (*C.GtkProgressBar)(unsafe.Pointer(p.Native()))
	_arg1 = (C.PangoEllipsizeMode)(mode)

	C.gtk_progress_bar_set_ellipsize(_arg0, _arg1)
}

// SetFraction causes the progress bar to “fill in” the given fraction of
// the bar.
//
// The fraction should be between 0.0 and 1.0, inclusive.
func (p progressBar) SetFraction(fraction float64) {
	var _arg0 *C.GtkProgressBar
	var _arg1 C.double

	_arg0 = (*C.GtkProgressBar)(unsafe.Pointer(p.Native()))
	_arg1 = C.double(fraction)

	C.gtk_progress_bar_set_fraction(_arg0, _arg1)
}

// SetInverted sets whether the progress bar is inverted.
//
// Progress bars normally grow from top to bottom or left to right. Inverted
// progress bars grow in the opposite direction.
func (p progressBar) SetInverted(inverted bool) {
	var _arg0 *C.GtkProgressBar
	var _arg1 C.gboolean

	_arg0 = (*C.GtkProgressBar)(unsafe.Pointer(p.Native()))
	if inverted {
		_arg1 = C.gboolean(1)
	}

	C.gtk_progress_bar_set_inverted(_arg0, _arg1)
}

// SetPulseStep sets the fraction of total progress bar length to move the
// bouncing block.
//
// The bouncing block is moved when [method@Gtk.ProgressBar.pulse] is
// called.
func (p progressBar) SetPulseStep(fraction float64) {
	var _arg0 *C.GtkProgressBar
	var _arg1 C.double

	_arg0 = (*C.GtkProgressBar)(unsafe.Pointer(p.Native()))
	_arg1 = C.double(fraction)

	C.gtk_progress_bar_set_pulse_step(_arg0, _arg1)
}

// SetShowText sets whether the progress bar will show text next to the bar.
//
// The shown text is either the value of the [property@Gtk.ProgressBar:text]
// property or, if that is nil, the [property@Gtk.ProgressBar:fraction]
// value, as a percentage.
//
// To make a progress bar that is styled and sized suitably for containing
// text (even if the actual text is blank), set
// [property@Gtk.ProgressBar:show-text] to true and
// [property@Gtk.ProgressBar:text] to the empty string (not nil).
func (p progressBar) SetShowText(showText bool) {
	var _arg0 *C.GtkProgressBar
	var _arg1 C.gboolean

	_arg0 = (*C.GtkProgressBar)(unsafe.Pointer(p.Native()))
	if showText {
		_arg1 = C.gboolean(1)
	}

	C.gtk_progress_bar_set_show_text(_arg0, _arg1)
}

// SetText causes the given @text to appear next to the progress bar.
//
// If @text is nil and [property@Gtk.ProgressBar:show-text] is true, the
// current value of [property@Gtk.ProgressBar:fraction] will be displayed as
// a percentage.
//
// If @text is non-nil and [property@Gtk.ProgressBar:show-text] is true, the
// text will be displayed. In this case, it will not display the progress
// percentage. If @text is the empty string, the progress bar will still be
// styled and sized suitably for containing text, as long as
// [property@Gtk.ProgressBar:show-text] is true.
func (p progressBar) SetText(text string) {
	var _arg0 *C.GtkProgressBar
	var _arg1 *C.char

	_arg0 = (*C.GtkProgressBar)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.char)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_progress_bar_set_text(_arg0, _arg1)
}

// Revealer: a `GtkRevealer` animates the transition of its child from invisible
// to visible.
//
// The style of transition can be controlled with
// [method@Gtk.Revealer.set_transition_type].
//
// These animations respect the [property@Gtk.Settings:gtk-enable-animations]
// setting.
//
//
// CSS nodes
//
// `GtkRevealer` has a single CSS node with name revealer. When styling
// `GtkRevealer` using CSS, remember that it only hides its contents, not
// itself. That means applied margin, padding and borders will be visible even
// when the [property@Gtk.Revealer:reveal-child] property is set to false.
//
//
// Accessibility
//
// `GtkRevealer` uses the GTK_ACCESSIBLE_ROLE_GROUP role.
//
// The child of `GtkRevealer`, if set, is always available in the accessibility
// tree, regardless of the state of the revealer widget.
type Revealer interface {
	Widget
	Accessible
	Buildable
	ConstraintTarget

	// ChildRevealed returns whether the child is fully revealed.
	//
	// In other words, this returns whether the transition to the revealed state
	// is completed.
	ChildRevealed() bool
	// RevealChild returns whether the child is currently revealed.
	//
	// This function returns true as soon as the transition is to the revealed
	// state is started. To learn whether the child is fully revealed (ie the
	// transition is completed), use [method@Gtk.Revealer.get_child_revealed].
	RevealChild() bool
	// TransitionDuration returns the amount of time (in milliseconds) that
	// transitions will take.
	TransitionDuration() uint
	// SetChild sets the child widget of @revealer.
	SetChild(child Widget)
	// SetRevealChild tells the `GtkRevealer` to reveal or conceal its child.
	//
	// The transition will be animated with the current transition type of
	// @revealer.
	SetRevealChild(revealChild bool)
	// SetTransitionDuration sets the duration that transitions will take.
	SetTransitionDuration(duration uint)
	// SetTransitionType sets the type of animation that will be used for
	// transitions in @revealer.
	//
	// Available types include various kinds of fades and slides.
	SetTransitionType(transition RevealerTransitionType)
}

// revealer implements the Revealer interface.
type revealer struct {
	Widget
	Accessible
	Buildable
	ConstraintTarget
}

var _ Revealer = (*revealer)(nil)

// WrapRevealer wraps a GObject to the right type. It is
// primarily used internally.
func WrapRevealer(obj *externglib.Object) Revealer {
	return Revealer{
		Widget:           WrapWidget(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
	}
}

func marshalRevealer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapRevealer(obj), nil
}

// ChildRevealed returns whether the child is fully revealed.
//
// In other words, this returns whether the transition to the revealed state
// is completed.
func (r revealer) ChildRevealed() bool {
	var _arg0 *C.GtkRevealer

	_arg0 = (*C.GtkRevealer)(unsafe.Pointer(r.Native()))

	var _cret C.gboolean

	_cret = C.gtk_revealer_get_child_revealed(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// RevealChild returns whether the child is currently revealed.
//
// This function returns true as soon as the transition is to the revealed
// state is started. To learn whether the child is fully revealed (ie the
// transition is completed), use [method@Gtk.Revealer.get_child_revealed].
func (r revealer) RevealChild() bool {
	var _arg0 *C.GtkRevealer

	_arg0 = (*C.GtkRevealer)(unsafe.Pointer(r.Native()))

	var _cret C.gboolean

	_cret = C.gtk_revealer_get_reveal_child(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// TransitionDuration returns the amount of time (in milliseconds) that
// transitions will take.
func (r revealer) TransitionDuration() uint {
	var _arg0 *C.GtkRevealer

	_arg0 = (*C.GtkRevealer)(unsafe.Pointer(r.Native()))

	var _cret C.guint

	_cret = C.gtk_revealer_get_transition_duration(_arg0)

	var _guint uint

	_guint = (uint)(_cret)

	return _guint
}

// SetChild sets the child widget of @revealer.
func (r revealer) SetChild(child Widget) {
	var _arg0 *C.GtkRevealer
	var _arg1 *C.GtkWidget

	_arg0 = (*C.GtkRevealer)(unsafe.Pointer(r.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_revealer_set_child(_arg0, _arg1)
}

// SetRevealChild tells the `GtkRevealer` to reveal or conceal its child.
//
// The transition will be animated with the current transition type of
// @revealer.
func (r revealer) SetRevealChild(revealChild bool) {
	var _arg0 *C.GtkRevealer
	var _arg1 C.gboolean

	_arg0 = (*C.GtkRevealer)(unsafe.Pointer(r.Native()))
	if revealChild {
		_arg1 = C.gboolean(1)
	}

	C.gtk_revealer_set_reveal_child(_arg0, _arg1)
}

// SetTransitionDuration sets the duration that transitions will take.
func (r revealer) SetTransitionDuration(duration uint) {
	var _arg0 *C.GtkRevealer
	var _arg1 C.guint

	_arg0 = (*C.GtkRevealer)(unsafe.Pointer(r.Native()))
	_arg1 = C.guint(duration)

	C.gtk_revealer_set_transition_duration(_arg0, _arg1)
}

// SetTransitionType sets the type of animation that will be used for
// transitions in @revealer.
//
// Available types include various kinds of fades and slides.
func (r revealer) SetTransitionType(transition RevealerTransitionType) {
	var _arg0 *C.GtkRevealer
	var _arg1 C.GtkRevealerTransitionType

	_arg0 = (*C.GtkRevealer)(unsafe.Pointer(r.Native()))
	_arg1 = (C.GtkRevealerTransitionType)(transition)

	C.gtk_revealer_set_transition_type(_arg0, _arg1)
}

// Scrollbar: the `GtkScrollbar` widget is a horizontal or vertical scrollbar.
//
// !An example GtkScrollbar (scrollbar.png)
//
// Its position and movement are controlled by the adjustment that is passed to
// or created by [ctor@Gtk.Scrollbar.new]. See [class.Gtk.Adjustment] for more
// details. The [property@Gtk.Adjustment:value] field sets the position of the
// thumb and must be between [property@Gtk.Adjustment:lower] and
// [property@Gtk.Adjustment:upper] - [property@Gtk.Adjustment:page-size]. The
// [property@Gtk.Adjustment:page-size] represents the size of the visible
// scrollable area.
//
// The fields [property@Gtk.Adjustment:step-increment] and
// [property@Gtk.Adjustment:page-increment] fields are added to or subtracted
// from the [property@Gtk.Adjustment:value] when the user asks to move by a step
// (using e.g. the cursor arrow keys) or by a page (using e.g. the Page Down/Up
// keys).
//
//
// CSS nodes
//
// “` scrollbar ╰── range[.fine-tune] ╰── trough ╰── slider “`
//
// `GtkScrollbar` has a main CSS node with name scrollbar and a subnode for its
// contents. The main node gets the .horizontal or .vertical style classes
// applied, depending on the scrollbar's orientation.
//
// The range node gets the style class .fine-tune added when the scrollbar is in
// 'fine-tuning' mode.
//
// Other style classes that may be added to scrollbars inside
// [class@Gtk.ScrolledWindow] include the positional classes (.left, .right,
// .top, .bottom) and style classes related to overlay scrolling
// (.overlay-indicator, .dragging, .hovering).
//
//
// Accessibility
//
// `GtkScrollbar` uses the GTK_ACCESSIBLE_ROLE_SCROLLBAR role.
type Scrollbar interface {
	Widget
	Accessible
	Buildable
	ConstraintTarget
	Orientable

	// SetAdjustment makes the scrollbar use the given adjustment.
	SetAdjustment(adjustment Adjustment)
}

// scrollbar implements the Scrollbar interface.
type scrollbar struct {
	Widget
	Accessible
	Buildable
	ConstraintTarget
	Orientable
}

var _ Scrollbar = (*scrollbar)(nil)

// WrapScrollbar wraps a GObject to the right type. It is
// primarily used internally.
func WrapScrollbar(obj *externglib.Object) Scrollbar {
	return Scrollbar{
		Widget:           WrapWidget(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
		Orientable:       WrapOrientable(obj),
	}
}

func marshalScrollbar(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapScrollbar(obj), nil
}

// SetAdjustment makes the scrollbar use the given adjustment.
func (s scrollbar) SetAdjustment(adjustment Adjustment) {
	var _arg0 *C.GtkScrollbar
	var _arg1 *C.GtkAdjustment

	_arg0 = (*C.GtkScrollbar)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(adjustment.Native()))

	C.gtk_scrollbar_set_adjustment(_arg0, _arg1)
}

// ScrolledWindow: `GtkScrolledWindow` is a container that makes its child
// scrollable.
//
// It does so using either internally added scrollbars or externally associated
// adjustments, and optionally draws a frame around the child.
//
// Widgets with native scrolling support, i.e. those whose classes implement the
// [iface@Gtk.Scrollable] interface, are added directly. For other types of
// widget, the class [class@Gtk.Viewport] acts as an adaptor, giving
// scrollability to other widgets. [method@Gtk.ScrolledWindow.set_child]
// intelligently accounts for whether or not the added child is a
// `GtkScrollable`. If it isn’t, then it wraps the child in a `GtkViewport`.
// Therefore, you can just add any child widget and not worry about the details.
//
// If [method@Gtk.ScrolledWindow.set_child] has added a `GtkViewport` for you,
// you can remove both your added child widget from the `GtkViewport`, and the
// `GtkViewport` from the `GtkScrolledWindow`, like this:
//
// “`c GtkWidget *scrolled_window = gtk_scrolled_window_new (); GtkWidget
// *child_widget = gtk_button_new ();
//
// // GtkButton is not a GtkScrollable, so GtkScrolledWindow will automatically
// // add a GtkViewport. gtk_box_append (GTK_BOX (scrolled_window),
// // child_widget);
//
// // Either of these will result in child_widget being unparented:
// // gtk_box_remove (GTK_BOX (scrolled_window), child_widget); // or
// // gtk_box_remove (GTK_BOX (scrolled_window), gtk_bin_get_child (GTK_BIN
// // (scrolled_window))); “`
//
// Unless [property@Gtk.ScrolledWindow:hscrollbar-policy] and
// [property@Gtk.ScrolledWindow:vscrollbar-policy] are GTK_POLICY_NEVER or
// GTK_POLICY_EXTERNAL, `GtkScrolledWindow` adds internal `GtkScrollbar` widgets
// around its child. The scroll position of the child, and if applicable the
// scrollbars, is controlled by the [property@Gtk.ScrolledWindow:hadjustment]
// and [property@Gtk.ScrolledWindow:vadjustment] that are associated with the
// `GtkScrolledWindow`. See the docs on [class@Gtk.Scrollbar] for the details,
// but note that the “step_increment” and “page_increment” fields are only
// effective if the policy causes scrollbars to be present.
//
// If a `GtkScrolledWindow` doesn’t behave quite as you would like, or doesn’t
// have exactly the right layout, it’s very possible to set up your own
// scrolling with `GtkScrollbar` and for example a `GtkGrid`.
//
//
// Touch support
//
// `GtkScrolledWindow` has built-in support for touch devices. When a
// touchscreen is used, swiping will move the scrolled window, and will expose
// 'kinetic' behavior. This can be turned off with the
// [property@Gtk.ScrolledWindow:kinetic-scrolling] property if it is undesired.
//
// `GtkScrolledWindow` also displays visual 'overshoot' indication when the
// content is pulled beyond the end, and this situation can be captured with the
// [signal@Gtk.ScrolledWindow::edge-overshot] signal.
//
// If no mouse device is present, the scrollbars will overlaid as narrow,
// auto-hiding indicators over the content. If traditional scrollbars are
// desired although no mouse is present, this behaviour can be turned off with
// the [property@Gtk.ScrolledWindow:overlay-scrolling] property.
//
//
// CSS nodes
//
// `GtkScrolledWindow` has a main CSS node with name scrolledwindow. It gets a
// .frame style class added when [property@Gtk.ScrolledWindow:has-frame] is
// true.
//
// It uses subnodes with names overshoot and undershoot to draw the overflow and
// underflow indications. These nodes get the .left, .right, .top or .bottom
// style class added depending on where the indication is drawn.
//
// `GtkScrolledWindow` also sets the positional style classes (.left, .right,
// .top, .bottom) and style classes related to overlay scrolling
// (.overlay-indicator, .dragging, .hovering) on its scrollbars.
//
// If both scrollbars are visible, the area where they meet is drawn with a
// subnode named junction.
//
//
// Accessibility
//
// `GtkScrolledWindow` uses the GTK_ACCESSIBLE_ROLE_GROUP role.
type ScrolledWindow interface {
	Widget
	Accessible
	Buildable
	ConstraintTarget

	// HasFrame gets whether the scrolled window draws a frame.
	HasFrame() bool
	// KineticScrolling returns the specified kinetic scrolling behavior.
	KineticScrolling() bool
	// MaxContentHeight returns the maximum content height set.
	MaxContentHeight() int
	// MaxContentWidth returns the maximum content width set.
	MaxContentWidth() int
	// MinContentHeight gets the minimal content height of @scrolled_window.
	MinContentHeight() int
	// MinContentWidth gets the minimum content width of @scrolled_window.
	MinContentWidth() int
	// OverlayScrolling returns whether overlay scrolling is enabled for this
	// scrolled window.
	OverlayScrolling() bool
	// PropagateNaturalHeight reports whether the natural height of the child
	// will be calculated and propagated through the scrolled window’s requested
	// natural height.
	PropagateNaturalHeight() bool
	// PropagateNaturalWidth reports whether the natural width of the child will
	// be calculated and propagated through the scrolled window’s requested
	// natural width.
	PropagateNaturalWidth() bool
	// SetChild sets the child widget of @scrolled_window.
	SetChild(child Widget)
	// SetHAdjustment sets the `GtkAdjustment` for the horizontal scrollbar.
	SetHAdjustment(hadjustment Adjustment)
	// SetHasFrame changes the frame drawn around the contents of
	// @scrolled_window.
	SetHasFrame(hasFrame bool)
	// SetKineticScrolling turns kinetic scrolling on or off.
	//
	// Kinetic scrolling only applies to devices with source
	// GDK_SOURCE_TOUCHSCREEN.
	SetKineticScrolling(kineticScrolling bool)
	// SetMaxContentHeight sets the maximum height that @scrolled_window should
	// keep visible.
	//
	// The @scrolled_window will grow up to this height before it starts
	// scrolling the content.
	//
	// It is a programming error to set the maximum content height to a value
	// smaller than [property@Gtk.ScrolledWindow:min-content-height].
	SetMaxContentHeight(height int)
	// SetMaxContentWidth sets the maximum width that @scrolled_window should
	// keep visible.
	//
	// The @scrolled_window will grow up to this width before it starts
	// scrolling the content.
	//
	// It is a programming error to set the maximum content width to a value
	// smaller than [property@Gtk.ScrolledWindow:min-content-width].
	SetMaxContentWidth(width int)
	// SetMinContentHeight sets the minimum height that @scrolled_window should
	// keep visible.
	//
	// Note that this can and (usually will) be smaller than the minimum size of
	// the content.
	//
	// It is a programming error to set the minimum content height to a value
	// greater than [property@Gtk.ScrolledWindow:max-content-height].
	SetMinContentHeight(height int)
	// SetMinContentWidth sets the minimum width that @scrolled_window should
	// keep visible.
	//
	// Note that this can and (usually will) be smaller than the minimum size of
	// the content.
	//
	// It is a programming error to set the minimum content width to a value
	// greater than [property@Gtk.ScrolledWindow:max-content-width].
	SetMinContentWidth(width int)
	// SetOverlayScrolling enables or disables overlay scrolling for this
	// scrolled window.
	SetOverlayScrolling(overlayScrolling bool)
	// SetPlacement sets the placement of the contents with respect to the
	// scrollbars for the scrolled window.
	//
	// The default is GTK_CORNER_TOP_LEFT, meaning the child is in the top left,
	// with the scrollbars underneath and to the right. Other values in
	// [enum@Gtk.CornerType] are GTK_CORNER_TOP_RIGHT, GTK_CORNER_BOTTOM_LEFT,
	// and GTK_CORNER_BOTTOM_RIGHT.
	//
	// See also [method@Gtk.ScrolledWindow.get_placement] and
	// [method@Gtk.ScrolledWindow.unset_placement].
	SetPlacement(windowPlacement CornerType)
	// SetPolicy sets the scrollbar policy for the horizontal and vertical
	// scrollbars.
	//
	// The policy determines when the scrollbar should appear; it is a value
	// from the [enum@Gtk.PolicyType] enumeration. If GTK_POLICY_ALWAYS, the
	// scrollbar is always present; if GTK_POLICY_NEVER, the scrollbar is never
	// present; if GTK_POLICY_AUTOMATIC, the scrollbar is present only if needed
	// (that is, if the slider part of the bar would be smaller than the trough
	// — the display is larger than the page size).
	SetPolicy(hscrollbarPolicy PolicyType, vscrollbarPolicy PolicyType)
	// SetPropagateNaturalHeight sets whether the natural height of the child
	// should be calculated and propagated through the scrolled window’s
	// requested natural height.
	SetPropagateNaturalHeight(propagate bool)
	// SetPropagateNaturalWidth sets whether the natural width of the child
	// should be calculated and propagated through the scrolled window’s
	// requested natural width.
	SetPropagateNaturalWidth(propagate bool)
	// SetVAdjustment sets the `GtkAdjustment` for the vertical scrollbar.
	SetVAdjustment(vadjustment Adjustment)
	// UnsetPlacement unsets the placement of the contents with respect to the
	// scrollbars.
	//
	// If no window placement is set for a scrolled window, it defaults to
	// GTK_CORNER_TOP_LEFT.
	UnsetPlacement()
}

// scrolledWindow implements the ScrolledWindow interface.
type scrolledWindow struct {
	Widget
	Accessible
	Buildable
	ConstraintTarget
}

var _ ScrolledWindow = (*scrolledWindow)(nil)

// WrapScrolledWindow wraps a GObject to the right type. It is
// primarily used internally.
func WrapScrolledWindow(obj *externglib.Object) ScrolledWindow {
	return ScrolledWindow{
		Widget:           WrapWidget(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
	}
}

func marshalScrolledWindow(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapScrolledWindow(obj), nil
}

// HasFrame gets whether the scrolled window draws a frame.
func (s scrolledWindow) HasFrame() bool {
	var _arg0 *C.GtkScrolledWindow

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

	var _cret C.gboolean

	_cret = C.gtk_scrolled_window_get_has_frame(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// KineticScrolling returns the specified kinetic scrolling behavior.
func (s scrolledWindow) KineticScrolling() bool {
	var _arg0 *C.GtkScrolledWindow

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

	var _cret C.gboolean

	_cret = C.gtk_scrolled_window_get_kinetic_scrolling(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// MaxContentHeight returns the maximum content height set.
func (s scrolledWindow) MaxContentHeight() int {
	var _arg0 *C.GtkScrolledWindow

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

	var _cret C.int

	_cret = C.gtk_scrolled_window_get_max_content_height(_arg0)

	var _gint int

	_gint = (int)(_cret)

	return _gint
}

// MaxContentWidth returns the maximum content width set.
func (s scrolledWindow) MaxContentWidth() int {
	var _arg0 *C.GtkScrolledWindow

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

	var _cret C.int

	_cret = C.gtk_scrolled_window_get_max_content_width(_arg0)

	var _gint int

	_gint = (int)(_cret)

	return _gint
}

// MinContentHeight gets the minimal content height of @scrolled_window.
func (s scrolledWindow) MinContentHeight() int {
	var _arg0 *C.GtkScrolledWindow

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

	var _cret C.int

	_cret = C.gtk_scrolled_window_get_min_content_height(_arg0)

	var _gint int

	_gint = (int)(_cret)

	return _gint
}

// MinContentWidth gets the minimum content width of @scrolled_window.
func (s scrolledWindow) MinContentWidth() int {
	var _arg0 *C.GtkScrolledWindow

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

	var _cret C.int

	_cret = C.gtk_scrolled_window_get_min_content_width(_arg0)

	var _gint int

	_gint = (int)(_cret)

	return _gint
}

// OverlayScrolling returns whether overlay scrolling is enabled for this
// scrolled window.
func (s scrolledWindow) OverlayScrolling() bool {
	var _arg0 *C.GtkScrolledWindow

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

	var _cret C.gboolean

	_cret = C.gtk_scrolled_window_get_overlay_scrolling(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// PropagateNaturalHeight reports whether the natural height of the child
// will be calculated and propagated through the scrolled window’s requested
// natural height.
func (s scrolledWindow) PropagateNaturalHeight() bool {
	var _arg0 *C.GtkScrolledWindow

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

	var _cret C.gboolean

	_cret = C.gtk_scrolled_window_get_propagate_natural_height(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// PropagateNaturalWidth reports whether the natural width of the child will
// be calculated and propagated through the scrolled window’s requested
// natural width.
func (s scrolledWindow) PropagateNaturalWidth() bool {
	var _arg0 *C.GtkScrolledWindow

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

	var _cret C.gboolean

	_cret = C.gtk_scrolled_window_get_propagate_natural_width(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// SetChild sets the child widget of @scrolled_window.
func (s scrolledWindow) SetChild(child Widget) {
	var _arg0 *C.GtkScrolledWindow
	var _arg1 *C.GtkWidget

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_scrolled_window_set_child(_arg0, _arg1)
}

// SetHAdjustment sets the `GtkAdjustment` for the horizontal scrollbar.
func (s scrolledWindow) SetHAdjustment(hadjustment Adjustment) {
	var _arg0 *C.GtkScrolledWindow
	var _arg1 *C.GtkAdjustment

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(hadjustment.Native()))

	C.gtk_scrolled_window_set_hadjustment(_arg0, _arg1)
}

// SetHasFrame changes the frame drawn around the contents of
// @scrolled_window.
func (s scrolledWindow) SetHasFrame(hasFrame bool) {
	var _arg0 *C.GtkScrolledWindow
	var _arg1 C.gboolean

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
	if hasFrame {
		_arg1 = C.gboolean(1)
	}

	C.gtk_scrolled_window_set_has_frame(_arg0, _arg1)
}

// SetKineticScrolling turns kinetic scrolling on or off.
//
// Kinetic scrolling only applies to devices with source
// GDK_SOURCE_TOUCHSCREEN.
func (s scrolledWindow) SetKineticScrolling(kineticScrolling bool) {
	var _arg0 *C.GtkScrolledWindow
	var _arg1 C.gboolean

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
	if kineticScrolling {
		_arg1 = C.gboolean(1)
	}

	C.gtk_scrolled_window_set_kinetic_scrolling(_arg0, _arg1)
}

// SetMaxContentHeight sets the maximum height that @scrolled_window should
// keep visible.
//
// The @scrolled_window will grow up to this height before it starts
// scrolling the content.
//
// It is a programming error to set the maximum content height to a value
// smaller than [property@Gtk.ScrolledWindow:min-content-height].
func (s scrolledWindow) SetMaxContentHeight(height int) {
	var _arg0 *C.GtkScrolledWindow
	var _arg1 C.int

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
	_arg1 = C.int(height)

	C.gtk_scrolled_window_set_max_content_height(_arg0, _arg1)
}

// SetMaxContentWidth sets the maximum width that @scrolled_window should
// keep visible.
//
// The @scrolled_window will grow up to this width before it starts
// scrolling the content.
//
// It is a programming error to set the maximum content width to a value
// smaller than [property@Gtk.ScrolledWindow:min-content-width].
func (s scrolledWindow) SetMaxContentWidth(width int) {
	var _arg0 *C.GtkScrolledWindow
	var _arg1 C.int

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
	_arg1 = C.int(width)

	C.gtk_scrolled_window_set_max_content_width(_arg0, _arg1)
}

// SetMinContentHeight sets the minimum height that @scrolled_window should
// keep visible.
//
// Note that this can and (usually will) be smaller than the minimum size of
// the content.
//
// It is a programming error to set the minimum content height to a value
// greater than [property@Gtk.ScrolledWindow:max-content-height].
func (s scrolledWindow) SetMinContentHeight(height int) {
	var _arg0 *C.GtkScrolledWindow
	var _arg1 C.int

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
	_arg1 = C.int(height)

	C.gtk_scrolled_window_set_min_content_height(_arg0, _arg1)
}

// SetMinContentWidth sets the minimum width that @scrolled_window should
// keep visible.
//
// Note that this can and (usually will) be smaller than the minimum size of
// the content.
//
// It is a programming error to set the minimum content width to a value
// greater than [property@Gtk.ScrolledWindow:max-content-width].
func (s scrolledWindow) SetMinContentWidth(width int) {
	var _arg0 *C.GtkScrolledWindow
	var _arg1 C.int

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
	_arg1 = C.int(width)

	C.gtk_scrolled_window_set_min_content_width(_arg0, _arg1)
}

// SetOverlayScrolling enables or disables overlay scrolling for this
// scrolled window.
func (s scrolledWindow) SetOverlayScrolling(overlayScrolling bool) {
	var _arg0 *C.GtkScrolledWindow
	var _arg1 C.gboolean

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
	if overlayScrolling {
		_arg1 = C.gboolean(1)
	}

	C.gtk_scrolled_window_set_overlay_scrolling(_arg0, _arg1)
}

// SetPlacement sets the placement of the contents with respect to the
// scrollbars for the scrolled window.
//
// The default is GTK_CORNER_TOP_LEFT, meaning the child is in the top left,
// with the scrollbars underneath and to the right. Other values in
// [enum@Gtk.CornerType] are GTK_CORNER_TOP_RIGHT, GTK_CORNER_BOTTOM_LEFT,
// and GTK_CORNER_BOTTOM_RIGHT.
//
// See also [method@Gtk.ScrolledWindow.get_placement] and
// [method@Gtk.ScrolledWindow.unset_placement].
func (s scrolledWindow) SetPlacement(windowPlacement CornerType) {
	var _arg0 *C.GtkScrolledWindow
	var _arg1 C.GtkCornerType

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkCornerType)(windowPlacement)

	C.gtk_scrolled_window_set_placement(_arg0, _arg1)
}

// SetPolicy sets the scrollbar policy for the horizontal and vertical
// scrollbars.
//
// The policy determines when the scrollbar should appear; it is a value
// from the [enum@Gtk.PolicyType] enumeration. If GTK_POLICY_ALWAYS, the
// scrollbar is always present; if GTK_POLICY_NEVER, the scrollbar is never
// present; if GTK_POLICY_AUTOMATIC, the scrollbar is present only if needed
// (that is, if the slider part of the bar would be smaller than the trough
// — the display is larger than the page size).
func (s scrolledWindow) SetPolicy(hscrollbarPolicy PolicyType, vscrollbarPolicy PolicyType) {
	var _arg0 *C.GtkScrolledWindow
	var _arg1 C.GtkPolicyType
	var _arg2 C.GtkPolicyType

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkPolicyType)(hscrollbarPolicy)
	_arg2 = (C.GtkPolicyType)(vscrollbarPolicy)

	C.gtk_scrolled_window_set_policy(_arg0, _arg1, _arg2)
}

// SetPropagateNaturalHeight sets whether the natural height of the child
// should be calculated and propagated through the scrolled window’s
// requested natural height.
func (s scrolledWindow) SetPropagateNaturalHeight(propagate bool) {
	var _arg0 *C.GtkScrolledWindow
	var _arg1 C.gboolean

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
	if propagate {
		_arg1 = C.gboolean(1)
	}

	C.gtk_scrolled_window_set_propagate_natural_height(_arg0, _arg1)
}

// SetPropagateNaturalWidth sets whether the natural width of the child
// should be calculated and propagated through the scrolled window’s
// requested natural width.
func (s scrolledWindow) SetPropagateNaturalWidth(propagate bool) {
	var _arg0 *C.GtkScrolledWindow
	var _arg1 C.gboolean

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
	if propagate {
		_arg1 = C.gboolean(1)
	}

	C.gtk_scrolled_window_set_propagate_natural_width(_arg0, _arg1)
}

// SetVAdjustment sets the `GtkAdjustment` for the vertical scrollbar.
func (s scrolledWindow) SetVAdjustment(vadjustment Adjustment) {
	var _arg0 *C.GtkScrolledWindow
	var _arg1 *C.GtkAdjustment

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(vadjustment.Native()))

	C.gtk_scrolled_window_set_vadjustment(_arg0, _arg1)
}

// UnsetPlacement unsets the placement of the contents with respect to the
// scrollbars.
//
// If no window placement is set for a scrolled window, it defaults to
// GTK_CORNER_TOP_LEFT.
func (s scrolledWindow) UnsetPlacement() {
	var _arg0 *C.GtkScrolledWindow

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

	C.gtk_scrolled_window_unset_placement(_arg0)
}

// SearchBar: `GtkSearchBar` is a container made to have a search entry.
//
// !An example GtkSearchBar (search-bar.png)
//
// It can also contain additional widgets, such as drop-down menus, or buttons.
// The search bar would appear when a search is started through typing on the
// keyboard, or the application’s search mode is toggled on.
//
// For keyboard presses to start a search, the search bar must be told of a
// widget to capture key events from through
// [method@Gtk.SearchBar.set_key_capture_widget]. This widget will typically be
// the top-level window, or a parent container of the search bar. Common
// shortcuts such as Ctrl+F should be handled as an application action, or
// through the menu items.
//
// You will also need to tell the search bar about which entry you are using as
// your search entry using [method@Gtk.SearchBar.connect_entry].
//
//
// Creating a search bar
//
// The following example shows you how to create a more complex search entry.
//
// A simple example
// (https://gitlab.gnome.org/GNOME/gtk/tree/master/examples/search-bar.c)
//
//
// CSS nodes
//
// “` searchbar ╰── revealer ╰── box ├── [child] ╰── [button.close] “`
//
// `GtkSearchBar` has a main CSS node with name searchbar. It has a child node
// with name revealer that contains a node with name box. The box node contains
// both the CSS node of the child widget as well as an optional button node
// which gets the .close style class applied.
//
//
// Accessibility
//
// `GtkSearchBar` uses the GTK_ACCESSIBLE_ROLE_SEARCH role.
type SearchBar interface {
	Widget
	Accessible
	Buildable
	ConstraintTarget

	// ConnectEntry connects the `GtkEditable widget passed as the one to be
	// used in this search bar.
	//
	// The entry should be a descendant of the search bar. Calling this function
	// manually is only required if the entry isn’t the direct child of the
	// search bar (as in our main example).
	ConnectEntry(entry Editable)
	// SearchMode returns whether the search mode is on or off.
	SearchMode() bool
	// ShowCloseButton returns whether the close button is shown.
	ShowCloseButton() bool
	// SetChild sets the child widget of @bar.
	SetChild(child Widget)
	// SetKeyCaptureWidget sets @widget as the widget that @bar will capture key
	// events from.
	//
	// If key events are handled by the search bar, the bar will be shown, and
	// the entry populated with the entered text.
	//
	// Note that despite the name of this function, the events are only
	// 'captured' in the bubble phase, which means that editable child widgets
	// of @widget will receive text input before it gets captured. If that is
	// not desired, you can capture and forward the events yourself with
	// [method@Gtk.EventControllerKey.forward].
	SetKeyCaptureWidget(widget Widget)
	// SetSearchMode switches the search mode on or off.
	SetSearchMode(searchMode bool)
	// SetShowCloseButton shows or hides the close button.
	//
	// Applications that already have a “search” toggle button should not show a
	// close button in their search bar, as it duplicates the role of the toggle
	// button.
	SetShowCloseButton(visible bool)
}

// searchBar implements the SearchBar interface.
type searchBar struct {
	Widget
	Accessible
	Buildable
	ConstraintTarget
}

var _ SearchBar = (*searchBar)(nil)

// WrapSearchBar wraps a GObject to the right type. It is
// primarily used internally.
func WrapSearchBar(obj *externglib.Object) SearchBar {
	return SearchBar{
		Widget:           WrapWidget(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
	}
}

func marshalSearchBar(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSearchBar(obj), nil
}

// ConnectEntry connects the `GtkEditable widget passed as the one to be
// used in this search bar.
//
// The entry should be a descendant of the search bar. Calling this function
// manually is only required if the entry isn’t the direct child of the
// search bar (as in our main example).
func (b searchBar) ConnectEntry(entry Editable) {
	var _arg0 *C.GtkSearchBar
	var _arg1 *C.GtkEditable

	_arg0 = (*C.GtkSearchBar)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkEditable)(unsafe.Pointer(entry.Native()))

	C.gtk_search_bar_connect_entry(_arg0, _arg1)
}

// SearchMode returns whether the search mode is on or off.
func (b searchBar) SearchMode() bool {
	var _arg0 *C.GtkSearchBar

	_arg0 = (*C.GtkSearchBar)(unsafe.Pointer(b.Native()))

	var _cret C.gboolean

	_cret = C.gtk_search_bar_get_search_mode(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// ShowCloseButton returns whether the close button is shown.
func (b searchBar) ShowCloseButton() bool {
	var _arg0 *C.GtkSearchBar

	_arg0 = (*C.GtkSearchBar)(unsafe.Pointer(b.Native()))

	var _cret C.gboolean

	_cret = C.gtk_search_bar_get_show_close_button(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// SetChild sets the child widget of @bar.
func (b searchBar) SetChild(child Widget) {
	var _arg0 *C.GtkSearchBar
	var _arg1 *C.GtkWidget

	_arg0 = (*C.GtkSearchBar)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_search_bar_set_child(_arg0, _arg1)
}

// SetKeyCaptureWidget sets @widget as the widget that @bar will capture key
// events from.
//
// If key events are handled by the search bar, the bar will be shown, and
// the entry populated with the entered text.
//
// Note that despite the name of this function, the events are only
// 'captured' in the bubble phase, which means that editable child widgets
// of @widget will receive text input before it gets captured. If that is
// not desired, you can capture and forward the events yourself with
// [method@Gtk.EventControllerKey.forward].
func (b searchBar) SetKeyCaptureWidget(widget Widget) {
	var _arg0 *C.GtkSearchBar
	var _arg1 *C.GtkWidget

	_arg0 = (*C.GtkSearchBar)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	C.gtk_search_bar_set_key_capture_widget(_arg0, _arg1)
}

// SetSearchMode switches the search mode on or off.
func (b searchBar) SetSearchMode(searchMode bool) {
	var _arg0 *C.GtkSearchBar
	var _arg1 C.gboolean

	_arg0 = (*C.GtkSearchBar)(unsafe.Pointer(b.Native()))
	if searchMode {
		_arg1 = C.gboolean(1)
	}

	C.gtk_search_bar_set_search_mode(_arg0, _arg1)
}

// SetShowCloseButton shows or hides the close button.
//
// Applications that already have a “search” toggle button should not show a
// close button in their search bar, as it duplicates the role of the toggle
// button.
func (b searchBar) SetShowCloseButton(visible bool) {
	var _arg0 *C.GtkSearchBar
	var _arg1 C.gboolean

	_arg0 = (*C.GtkSearchBar)(unsafe.Pointer(b.Native()))
	if visible {
		_arg1 = C.gboolean(1)
	}

	C.gtk_search_bar_set_show_close_button(_arg0, _arg1)
}

// SearchEntry: `GtkSearchEntry` is an entry widget that has been tailored for
// use as a search entry.
//
// The main API for interacting with a `GtkSearchEntry` as entry is the
// `GtkEditable` interface.
//
// !An example GtkSearchEntry (search-entry.png)
//
// It will show an inactive symbolic “find” icon when the search entry is empty,
// and a symbolic “clear” icon when there is text. Clicking on the “clear” icon
// will empty the search entry.
//
// To make filtering appear more reactive, it is a good idea to not react to
// every change in the entry text immediately, but only after a short delay. To
// support this, `GtkSearchEntry` emits the
// [signal@Gtk.SearchEntry::search-changed] signal which can be used instead of
// the [signal@Gtk.Editable::changed] signal.
//
// The [signal@Gtk.SearchEntry::previous-match],
// [signal@Gtk.SearchEntry::next-match] and
// [signal@Gtk.SearchEntry::stop-search] signals can be used to implement moving
// between search results and ending the search.
//
// Often, `GtkSearchEntry` will be fed events by means of being placed inside a
// [class@Gtk.SearchBar]. If that is not the case, you can use
// [method@Gtk.SearchEntry.set_key_capture_widget] to let it capture key input
// from another widget.
//
// `GtkSearchEntry` provides only minimal API and should be used with the
// [iface@Gtk.Editable] API.
//
//
// CSS Nodes
//
// “` entry.search ╰── text “`
//
// `GtkSearchEntry` has a single CSS node with name entry that carries a
// `.search` style class, and the text node is a child of that.
//
//
// Accessibility
//
// `GtkSearchEntry` uses the GTK_ACCESSIBLE_ROLE_SEARCH_BOX role.
type SearchEntry interface {
	Widget
	Accessible
	Buildable
	ConstraintTarget
	Editable

	// SetKeyCaptureWidget sets @widget as the widget that @entry will capture
	// key events from.
	//
	// Key events are consumed by the search entry to start or continue a
	// search.
	//
	// If the entry is part of a `GtkSearchBar`, it is preferable to call
	// [method@Gtk.SearchBar.set_key_capture_widget] instead, which will reveal
	// the entry in addition to triggering the search entry.
	//
	// Note that despite the name of this function, the events are only
	// 'captured' in the bubble phase, which means that editable child widgets
	// of @widget will receive text input before it gets captured. If that is
	// not desired, you can capture and forward the events yourself with
	// [method@Gtk.EventControllerKey.forward].
	SetKeyCaptureWidget(widget Widget)
}

// searchEntry implements the SearchEntry interface.
type searchEntry struct {
	Widget
	Accessible
	Buildable
	ConstraintTarget
	Editable
}

var _ SearchEntry = (*searchEntry)(nil)

// WrapSearchEntry wraps a GObject to the right type. It is
// primarily used internally.
func WrapSearchEntry(obj *externglib.Object) SearchEntry {
	return SearchEntry{
		Widget:           WrapWidget(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
		Editable:         WrapEditable(obj),
	}
}

func marshalSearchEntry(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSearchEntry(obj), nil
}

// SetKeyCaptureWidget sets @widget as the widget that @entry will capture
// key events from.
//
// Key events are consumed by the search entry to start or continue a
// search.
//
// If the entry is part of a `GtkSearchBar`, it is preferable to call
// [method@Gtk.SearchBar.set_key_capture_widget] instead, which will reveal
// the entry in addition to triggering the search entry.
//
// Note that despite the name of this function, the events are only
// 'captured' in the bubble phase, which means that editable child widgets
// of @widget will receive text input before it gets captured. If that is
// not desired, you can capture and forward the events yourself with
// [method@Gtk.EventControllerKey.forward].
func (e searchEntry) SetKeyCaptureWidget(widget Widget) {
	var _arg0 *C.GtkSearchEntry
	var _arg1 *C.GtkWidget

	_arg0 = (*C.GtkSearchEntry)(unsafe.Pointer(e.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	C.gtk_search_entry_set_key_capture_widget(_arg0, _arg1)
}

// Separator: `GtkSeparator` is a horizontal or vertical separator widget.
//
// !An example GtkSeparator (separators.png)
//
// A `GtkSeparator` can be used to group the widgets within a window. It
// displays a line with a shadow to make it appear sunken into the interface.
//
//
// CSS nodes
//
// `GtkSeparator` has a single CSS node with name separator. The node gets one
// of the .horizontal or .vertical style classes.
//
//
// Accessibility
//
// `GtkSeparator` uses the K_ACCESSIBLE_ROLE_SEPARATOR role.
type Separator interface {
	Widget
	Accessible
	Buildable
	ConstraintTarget
	Orientable
}

// separator implements the Separator interface.
type separator struct {
	Widget
	Accessible
	Buildable
	ConstraintTarget
	Orientable
}

var _ Separator = (*separator)(nil)

// WrapSeparator wraps a GObject to the right type. It is
// primarily used internally.
func WrapSeparator(obj *externglib.Object) Separator {
	return Separator{
		Widget:           WrapWidget(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
		Orientable:       WrapOrientable(obj),
	}
}

func marshalSeparator(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSeparator(obj), nil
}

// Settings: `GtkSettings` provides a mechanism to share global settings between
// applications.
//
// On the X window system, this sharing is realized by an XSettings
// (http://www.freedesktop.org/wiki/Specifications/xsettings-spec) manager that
// is usually part of the desktop environment, along with utilities that let the
// user change these settings.
//
// On Wayland, the settings are obtained either via a settings portal, or by
// reading desktop settings from DConf.
//
// In the absence of these sharing mechanisms, GTK reads default values for
// settings from `settings.ini` files in `/etc/gtk-4.0`,
// `$XDG_CONFIG_DIRS/gtk-4.0` and `$XDG_CONFIG_HOME/gtk-4.0`. These files must
// be valid key files (see `GKeyFile`), and have a section called Settings.
// Themes can also provide default values for settings by installing a
// `settings.ini` file next to their `gtk.css` file.
//
// Applications can override system-wide settings by setting the property of the
// `GtkSettings` object with g_object_set(). This should be restricted to
// special cases though; `GtkSettings` are not meant as an application
// configuration facility.
//
// There is one `GtkSettings` instance per display. It can be obtained with
// [type_func@GtkSettings.get_for_display], but in many cases, it is more
// convenient to use [method@Gtk.Widget.get_settings].
type Settings interface {
	gextras.Objector
	StyleProvider

	// ResetProperty undoes the effect of calling g_object_set() to install an
	// application-specific value for a setting.
	//
	// After this call, the setting will again follow the session-wide value for
	// this setting.
	ResetProperty(name string)
}

// settings implements the Settings interface.
type settings struct {
	gextras.Objector
	StyleProvider
}

var _ Settings = (*settings)(nil)

// WrapSettings wraps a GObject to the right type. It is
// primarily used internally.
func WrapSettings(obj *externglib.Object) Settings {
	return Settings{
		Objector:      obj,
		StyleProvider: WrapStyleProvider(obj),
	}
}

func marshalSettings(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSettings(obj), nil
}

// ResetProperty undoes the effect of calling g_object_set() to install an
// application-specific value for a setting.
//
// After this call, the setting will again follow the session-wide value for
// this setting.
func (s settings) ResetProperty(name string) {
	var _arg0 *C.GtkSettings
	var _arg1 *C.char

	_arg0 = (*C.GtkSettings)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_settings_reset_property(_arg0, _arg1)
}

// ShortcutsWindow: a `GtkShortcutsWindow` shows information about the keyboard
// shortcuts and gestures of an application.
//
// The shortcuts can be grouped, and you can have multiple sections in this
// window, corresponding to the major modes of your application.
//
// Additionally, the shortcuts can be filtered by the current view, to avoid
// showing information that is not relevant in the current application context.
//
// The recommended way to construct a `GtkShortcutsWindow` is with
// [class@Gtk.Builder], by populating a `GtkShortcutsWindow` with one or more
// `GtkShortcutsSection` objects, which contain `GtkShortcutsGroups` that in
// turn contain objects of class `GtkShortcutsShortcut`.
//
// A simple example:
//
// ! (gedit-shortcuts.png)
//
// This example has as single section. As you can see, the shortcut groups are
// arranged in columns, and spread across several pages if there are too many to
// find on a single page.
//
// The .ui file for this example can be found here
// (https://gitlab.gnome.org/GNOME/gtk/tree/master/demos/gtk-demo/shortcuts-gedit.ui).
//
// An example with multiple views:
//
// ! (clocks-shortcuts.png)
//
// This example shows a `GtkShortcutsWindow` that has been configured to show
// only the shortcuts relevant to the "stopwatch" view.
//
// The .ui file for this example can be found here
// (https://gitlab.gnome.org/GNOME/gtk/tree/master/demos/gtk-demo/shortcuts-clocks.ui).
//
// An example with multiple sections:
//
// ! (builder-shortcuts.png)
//
// This example shows a `GtkShortcutsWindow` with two sections, "Editor
// Shortcuts" and "Terminal Shortcuts".
//
// The .ui file for this example can be found here
// (https://gitlab.gnome.org/GNOME/gtk/tree/master/demos/gtk-demo/shortcuts-builder.ui).
type ShortcutsWindow interface {
	Window
	Accessible
	Buildable
	ConstraintTarget
	Native
	Root
	ShortcutManager
}

// shortcutsWindow implements the ShortcutsWindow interface.
type shortcutsWindow struct {
	Window
	Accessible
	Buildable
	ConstraintTarget
	Native
	Root
	ShortcutManager
}

var _ ShortcutsWindow = (*shortcutsWindow)(nil)

// WrapShortcutsWindow wraps a GObject to the right type. It is
// primarily used internally.
func WrapShortcutsWindow(obj *externglib.Object) ShortcutsWindow {
	return ShortcutsWindow{
		Window:           WrapWindow(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
		Native:           WrapNative(obj),
		Root:             WrapRoot(obj),
		ShortcutManager:  WrapShortcutManager(obj),
	}
}

func marshalShortcutsWindow(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapShortcutsWindow(obj), nil
}

// SizeGroup: `GtkSizeGroup` groups widgets together so they all request the
// same size.
//
// This is typically useful when you want a column of widgets to have the same
// size, but you can’t use a `GtkGrid`.
//
// In detail, the size requested for each widget in a `GtkSizeGroup` is the
// maximum of the sizes that would have been requested for each widget in the
// size group if they were not in the size group. The mode of the size group
// (see [method@Gtk.SizeGroup.set_mode]) determines whether this applies to the
// horizontal size, the vertical size, or both sizes.
//
// Note that size groups only affect the amount of space requested, not the size
// that the widgets finally receive. If you want the widgets in a `GtkSizeGroup`
// to actually be the same size, you need to pack them in such a way that they
// get the size they request and not more.
//
// `GtkSizeGroup` objects are referenced by each widget in the size group, so
// once you have added all widgets to a `GtkSizeGroup`, you can drop the initial
// reference to the size group with g_object_unref(). If the widgets in the size
// group are subsequently destroyed, then they will be removed from the size
// group and drop their references on the size group; when all widgets have been
// removed, the size group will be freed.
//
// Widgets can be part of multiple size groups; GTK will compute the horizontal
// size of a widget from the horizontal requisition of all widgets that can be
// reached from the widget by a chain of size groups of type
// GTK_SIZE_GROUP_HORIZONTAL or GTK_SIZE_GROUP_BOTH, and the vertical size from
// the vertical requisition of all widgets that can be reached from the widget
// by a chain of size groups of type GTK_SIZE_GROUP_VERTICAL or
// GTK_SIZE_GROUP_BOTH.
//
// Note that only non-contextual sizes of every widget are ever consulted by
// size groups (since size groups have no knowledge of what size a widget will
// be allocated in one dimension, it cannot derive how much height a widget will
// receive for a given width). When grouping widgets that trade height for width
// in mode GTK_SIZE_GROUP_VERTICAL or GTK_SIZE_GROUP_BOTH: the height for the
// minimum width will be the requested height for all widgets in the group. The
// same is of course true when horizontally grouping width for height widgets.
//
// Widgets that trade height-for-width should set a reasonably large minimum
// width by way of [property@Gtk.Label:width-chars] for instance. Widgets with
// static sizes as well as widgets that grow (such as ellipsizing text) need no
// such considerations.
//
//
// GtkSizeGroup as GtkBuildable
//
// Size groups can be specified in a UI definition by placing an <object>
// element with `class="GtkSizeGroup"` somewhere in the UI definition. The
// widgets that belong to the size group are specified by a <widgets> element
// that may contain multiple <widget> elements, one for each member of the size
// group. The ”name” attribute gives the id of the widget.
//
// An example of a UI definition fragment with `GtkSizeGroup`: “`xml <object
// class="GtkSizeGroup"> <property name="mode">horizontal</property> <widgets>
// <widget name="radio1"/> <widget name="radio2"/> </widgets> </object> “`
type SizeGroup interface {
	gextras.Objector
	Buildable

	// AddWidget adds a widget to a `GtkSizeGroup`.
	//
	// In the future, the requisition of the widget will be determined as the
	// maximum of its requisition and the requisition of the other widgets in
	// the size group. Whether this applies horizontally, vertically, or in both
	// directions depends on the mode of the size group. See
	// [method@Gtk.SizeGroup.set_mode].
	//
	// When the widget is destroyed or no longer referenced elsewhere, it will
	// be removed from the size group.
	AddWidget(widget Widget)
	// RemoveWidget removes a widget from a `GtkSizeGroup`.
	RemoveWidget(widget Widget)
	// SetMode sets the `GtkSizeGroupMode` of the size group.
	//
	// The mode of the size group determines whether the widgets in the size
	// group should all have the same horizontal requisition
	// (GTK_SIZE_GROUP_HORIZONTAL) all have the same vertical requisition
	// (GTK_SIZE_GROUP_VERTICAL), or should all have the same requisition in
	// both directions (GTK_SIZE_GROUP_BOTH).
	SetMode(mode SizeGroupMode)
}

// sizeGroup implements the SizeGroup interface.
type sizeGroup struct {
	gextras.Objector
	Buildable
}

var _ SizeGroup = (*sizeGroup)(nil)

// WrapSizeGroup wraps a GObject to the right type. It is
// primarily used internally.
func WrapSizeGroup(obj *externglib.Object) SizeGroup {
	return SizeGroup{
		Objector:  obj,
		Buildable: WrapBuildable(obj),
	}
}

func marshalSizeGroup(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSizeGroup(obj), nil
}

// AddWidget adds a widget to a `GtkSizeGroup`.
//
// In the future, the requisition of the widget will be determined as the
// maximum of its requisition and the requisition of the other widgets in
// the size group. Whether this applies horizontally, vertically, or in both
// directions depends on the mode of the size group. See
// [method@Gtk.SizeGroup.set_mode].
//
// When the widget is destroyed or no longer referenced elsewhere, it will
// be removed from the size group.
func (s sizeGroup) AddWidget(widget Widget) {
	var _arg0 *C.GtkSizeGroup
	var _arg1 *C.GtkWidget

	_arg0 = (*C.GtkSizeGroup)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	C.gtk_size_group_add_widget(_arg0, _arg1)
}

// RemoveWidget removes a widget from a `GtkSizeGroup`.
func (s sizeGroup) RemoveWidget(widget Widget) {
	var _arg0 *C.GtkSizeGroup
	var _arg1 *C.GtkWidget

	_arg0 = (*C.GtkSizeGroup)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	C.gtk_size_group_remove_widget(_arg0, _arg1)
}

// SetMode sets the `GtkSizeGroupMode` of the size group.
//
// The mode of the size group determines whether the widgets in the size
// group should all have the same horizontal requisition
// (GTK_SIZE_GROUP_HORIZONTAL) all have the same vertical requisition
// (GTK_SIZE_GROUP_VERTICAL), or should all have the same requisition in
// both directions (GTK_SIZE_GROUP_BOTH).
func (s sizeGroup) SetMode(mode SizeGroupMode) {
	var _arg0 *C.GtkSizeGroup
	var _arg1 C.GtkSizeGroupMode

	_arg0 = (*C.GtkSizeGroup)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkSizeGroupMode)(mode)

	C.gtk_size_group_set_mode(_arg0, _arg1)
}

// SpinButton: a `GtkSpinButton` is an ideal way to allow the user to set the
// value of some attribute.
//
// !An example GtkSpinButton (spinbutton.png)
//
// Rather than having to directly type a number into a `GtkEntry`,
// `GtkSpinButton` allows the user to click on one of two arrows to increment or
// decrement the displayed value. A value can still be typed in, with the bonus
// that it can be checked to ensure it is in a given range.
//
// The main properties of a `GtkSpinButton` are through an adjustment. See the
// [class@Gtk.Adjustment] documentation for more details about an adjustment's
// properties.
//
// Note that `GtkSpinButton` will by default make its entry large enough to
// accommodate the lower and upper bounds of the adjustment. If this is not
// desired, the automatic sizing can be turned off by explicitly setting
// [property@Gtk.Editable:width-chars] to a value != -1.
//
//
// Using a GtkSpinButton to get an integer
//
// “`c // Provides a function to retrieve an integer value from a GtkSpinButton
// // and creates a spin button to model percentage values.
//
// int grab_int_value (GtkSpinButton *button, gpointer user_data) { return
// gtk_spin_button_get_value_as_int (button); }
//
// void create_integer_spin_button (void) {
//
//    GtkWidget *window, *button;
//    GtkAdjustment *adjustment;
//
//    adjustment = gtk_adjustment_new (50.0, 0.0, 100.0, 1.0, 5.0, 0.0);
//
//    window = gtk_window_new ();
//
//    // creates the spinbutton, with no decimal places
//    button = gtk_spin_button_new (adjustment, 1.0, 0);
//    gtk_window_set_child (GTK_WINDOW (window), button);
//
//    gtk_widget_show (window);
//
// } “`
//
//
// Using a GtkSpinButton to get a floating point value
//
// “`c // Provides a function to retrieve a floating point value from a //
// GtkSpinButton, and creates a high precision spin button.
//
// float grab_float_value (GtkSpinButton *button, gpointer user_data) { return
// gtk_spin_button_get_value (button); }
//
// void create_floating_spin_button (void) { GtkWidget *window, *button;
// GtkAdjustment *adjustment;
//
//    adjustment = gtk_adjustment_new (2.500, 0.0, 5.0, 0.001, 0.1, 0.0);
//
//    window = gtk_window_new ();
//
//    // creates the spinbutton, with three decimal places
//    button = gtk_spin_button_new (adjustment, 0.001, 3);
//    gtk_window_set_child (GTK_WINDOW (window), button);
//
//    gtk_widget_show (window);
//
// } “`
//
//
// CSS nodes
//
// “` spinbutton.horizontal ├── text │ ├── undershoot.left │ ╰──
// undershoot.right ├── button.down ╰── button.up “`
//
// “` spinbutton.vertical ├── button.up ├── text │ ├── undershoot.left │ ╰──
// undershoot.right ╰── button.down “`
//
// `GtkSpinButton`s main CSS node has the name spinbutton. It creates subnodes
// for the entry and the two buttons, with these names. The button nodes have
// the style classes .up and .down. The `GtkText` subnodes (if present) are put
// below the text node. The orientation of the spin button is reflected in the
// .vertical or .horizontal style class on the main node.
//
//
// Accessiblity
//
// `GtkSpinButton` uses the GTK_ACCESSIBLE_ROLE_SPIN_BUTTON role.
type SpinButton interface {
	Widget
	Accessible
	Buildable
	CellEditable
	ConstraintTarget
	Editable
	Orientable

	// Configure changes the properties of an existing spin button.
	//
	// The adjustment, climb rate, and number of decimal places are updated
	// accordingly.
	Configure(adjustment Adjustment, climbRate float64, digits uint)
	// ClimbRate returns the acceleration rate for repeated changes.
	ClimbRate() float64
	// Digits fetches the precision of @spin_button.
	Digits() uint
	// Increments gets the current step and page the increments used by
	// @spin_button.
	//
	// See [method@Gtk.SpinButton.set_increments].
	Increments() (step float64, page float64)
	// Numeric returns whether non-numeric text can be typed into the spin
	// button.
	Numeric() bool
	// Range gets the range allowed for @spin_button.
	//
	// See [method@Gtk.SpinButton.set_range].
	Range() (min float64, max float64)
	// SnapToTicks returns whether the values are corrected to the nearest step.
	SnapToTicks() bool
	// Value: get the value in the @spin_button.
	Value() float64
	// ValueAsInt: get the value @spin_button represented as an integer.
	ValueAsInt() int
	// Wrap returns whether the spin button’s value wraps around to the opposite
	// limit when the upper or lower limit of the range is exceeded.
	Wrap() bool
	// SetAdjustment replaces the `GtkAdjustment` associated with @spin_button.
	SetAdjustment(adjustment Adjustment)
	// SetClimbRate sets the acceleration rate for repeated changes when you
	// hold down a button or key.
	SetClimbRate(climbRate float64)
	// SetDigits: set the precision to be displayed by @spin_button.
	//
	// Up to 20 digit precision is allowed.
	SetDigits(digits uint)
	// SetIncrements sets the step and page increments for spin_button.
	//
	// This affects how quickly the value changes when the spin button’s arrows
	// are activated.
	SetIncrements(step float64, page float64)
	// SetNumeric sets the flag that determines if non-numeric text can be typed
	// into the spin button.
	SetNumeric(numeric bool)
	// SetRange sets the minimum and maximum allowable values for @spin_button.
	//
	// If the current value is outside this range, it will be adjusted to fit
	// within the range, otherwise it will remain unchanged.
	SetRange(min float64, max float64)
	// SetSnapToTicks sets the policy as to whether values are corrected to the
	// nearest step increment when a spin button is activated after providing an
	// invalid value.
	SetSnapToTicks(snapToTicks bool)
	// SetUpdatePolicy sets the update behavior of a spin button.
	//
	// This determines whether the spin button is always updated or only when a
	// valid value is set.
	SetUpdatePolicy(policy SpinButtonUpdatePolicy)
	// SetValue sets the value of @spin_button.
	SetValue(value float64)
	// SetWrap sets the flag that determines if a spin button value wraps around
	// to the opposite limit when the upper or lower limit of the range is
	// exceeded.
	SetWrap(wrap bool)
	// Spin: increment or decrement a spin button’s value in a specified
	// direction by a specified amount.
	Spin(direction SpinType, increment float64)
	// Update: manually force an update of the spin button.
	Update()
}

// spinButton implements the SpinButton interface.
type spinButton struct {
	Widget
	Accessible
	Buildable
	CellEditable
	ConstraintTarget
	Editable
	Orientable
}

var _ SpinButton = (*spinButton)(nil)

// WrapSpinButton wraps a GObject to the right type. It is
// primarily used internally.
func WrapSpinButton(obj *externglib.Object) SpinButton {
	return SpinButton{
		Widget:           WrapWidget(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		CellEditable:     WrapCellEditable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
		Editable:         WrapEditable(obj),
		Orientable:       WrapOrientable(obj),
	}
}

func marshalSpinButton(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSpinButton(obj), nil
}

// Configure changes the properties of an existing spin button.
//
// The adjustment, climb rate, and number of decimal places are updated
// accordingly.
func (s spinButton) Configure(adjustment Adjustment, climbRate float64, digits uint) {
	var _arg0 *C.GtkSpinButton
	var _arg1 *C.GtkAdjustment
	var _arg2 C.double
	var _arg3 C.guint

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(adjustment.Native()))
	_arg2 = C.double(climbRate)
	_arg3 = C.guint(digits)

	C.gtk_spin_button_configure(_arg0, _arg1, _arg2, _arg3)
}

// ClimbRate returns the acceleration rate for repeated changes.
func (s spinButton) ClimbRate() float64 {
	var _arg0 *C.GtkSpinButton

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))

	var _cret C.double

	_cret = C.gtk_spin_button_get_climb_rate(_arg0)

	var _gdouble float64

	_gdouble = (float64)(_cret)

	return _gdouble
}

// Digits fetches the precision of @spin_button.
func (s spinButton) Digits() uint {
	var _arg0 *C.GtkSpinButton

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))

	var _cret C.guint

	_cret = C.gtk_spin_button_get_digits(_arg0)

	var _guint uint

	_guint = (uint)(_cret)

	return _guint
}

// Increments gets the current step and page the increments used by
// @spin_button.
//
// See [method@Gtk.SpinButton.set_increments].
func (s spinButton) Increments() (step float64, page float64) {
	var _arg0 *C.GtkSpinButton

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))

	var _arg1 C.double
	var _arg2 C.double

	C.gtk_spin_button_get_increments(_arg0, &_arg1, &_arg2)

	var _step float64
	var _page float64

	_step = (float64)(_arg1)
	_page = (float64)(_arg2)

	return _step, _page
}

// Numeric returns whether non-numeric text can be typed into the spin
// button.
func (s spinButton) Numeric() bool {
	var _arg0 *C.GtkSpinButton

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))

	var _cret C.gboolean

	_cret = C.gtk_spin_button_get_numeric(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// Range gets the range allowed for @spin_button.
//
// See [method@Gtk.SpinButton.set_range].
func (s spinButton) Range() (min float64, max float64) {
	var _arg0 *C.GtkSpinButton

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))

	var _arg1 C.double
	var _arg2 C.double

	C.gtk_spin_button_get_range(_arg0, &_arg1, &_arg2)

	var _min float64
	var _max float64

	_min = (float64)(_arg1)
	_max = (float64)(_arg2)

	return _min, _max
}

// SnapToTicks returns whether the values are corrected to the nearest step.
func (s spinButton) SnapToTicks() bool {
	var _arg0 *C.GtkSpinButton

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))

	var _cret C.gboolean

	_cret = C.gtk_spin_button_get_snap_to_ticks(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// Value: get the value in the @spin_button.
func (s spinButton) Value() float64 {
	var _arg0 *C.GtkSpinButton

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))

	var _cret C.double

	_cret = C.gtk_spin_button_get_value(_arg0)

	var _gdouble float64

	_gdouble = (float64)(_cret)

	return _gdouble
}

// ValueAsInt: get the value @spin_button represented as an integer.
func (s spinButton) ValueAsInt() int {
	var _arg0 *C.GtkSpinButton

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))

	var _cret C.int

	_cret = C.gtk_spin_button_get_value_as_int(_arg0)

	var _gint int

	_gint = (int)(_cret)

	return _gint
}

// Wrap returns whether the spin button’s value wraps around to the opposite
// limit when the upper or lower limit of the range is exceeded.
func (s spinButton) Wrap() bool {
	var _arg0 *C.GtkSpinButton

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))

	var _cret C.gboolean

	_cret = C.gtk_spin_button_get_wrap(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// SetAdjustment replaces the `GtkAdjustment` associated with @spin_button.
func (s spinButton) SetAdjustment(adjustment Adjustment) {
	var _arg0 *C.GtkSpinButton
	var _arg1 *C.GtkAdjustment

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(adjustment.Native()))

	C.gtk_spin_button_set_adjustment(_arg0, _arg1)
}

// SetClimbRate sets the acceleration rate for repeated changes when you
// hold down a button or key.
func (s spinButton) SetClimbRate(climbRate float64) {
	var _arg0 *C.GtkSpinButton
	var _arg1 C.double

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))
	_arg1 = C.double(climbRate)

	C.gtk_spin_button_set_climb_rate(_arg0, _arg1)
}

// SetDigits: set the precision to be displayed by @spin_button.
//
// Up to 20 digit precision is allowed.
func (s spinButton) SetDigits(digits uint) {
	var _arg0 *C.GtkSpinButton
	var _arg1 C.guint

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))
	_arg1 = C.guint(digits)

	C.gtk_spin_button_set_digits(_arg0, _arg1)
}

// SetIncrements sets the step and page increments for spin_button.
//
// This affects how quickly the value changes when the spin button’s arrows
// are activated.
func (s spinButton) SetIncrements(step float64, page float64) {
	var _arg0 *C.GtkSpinButton
	var _arg1 C.double
	var _arg2 C.double

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))
	_arg1 = C.double(step)
	_arg2 = C.double(page)

	C.gtk_spin_button_set_increments(_arg0, _arg1, _arg2)
}

// SetNumeric sets the flag that determines if non-numeric text can be typed
// into the spin button.
func (s spinButton) SetNumeric(numeric bool) {
	var _arg0 *C.GtkSpinButton
	var _arg1 C.gboolean

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))
	if numeric {
		_arg1 = C.gboolean(1)
	}

	C.gtk_spin_button_set_numeric(_arg0, _arg1)
}

// SetRange sets the minimum and maximum allowable values for @spin_button.
//
// If the current value is outside this range, it will be adjusted to fit
// within the range, otherwise it will remain unchanged.
func (s spinButton) SetRange(min float64, max float64) {
	var _arg0 *C.GtkSpinButton
	var _arg1 C.double
	var _arg2 C.double

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))
	_arg1 = C.double(min)
	_arg2 = C.double(max)

	C.gtk_spin_button_set_range(_arg0, _arg1, _arg2)
}

// SetSnapToTicks sets the policy as to whether values are corrected to the
// nearest step increment when a spin button is activated after providing an
// invalid value.
func (s spinButton) SetSnapToTicks(snapToTicks bool) {
	var _arg0 *C.GtkSpinButton
	var _arg1 C.gboolean

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))
	if snapToTicks {
		_arg1 = C.gboolean(1)
	}

	C.gtk_spin_button_set_snap_to_ticks(_arg0, _arg1)
}

// SetUpdatePolicy sets the update behavior of a spin button.
//
// This determines whether the spin button is always updated or only when a
// valid value is set.
func (s spinButton) SetUpdatePolicy(policy SpinButtonUpdatePolicy) {
	var _arg0 *C.GtkSpinButton
	var _arg1 C.GtkSpinButtonUpdatePolicy

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkSpinButtonUpdatePolicy)(policy)

	C.gtk_spin_button_set_update_policy(_arg0, _arg1)
}

// SetValue sets the value of @spin_button.
func (s spinButton) SetValue(value float64) {
	var _arg0 *C.GtkSpinButton
	var _arg1 C.double

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))
	_arg1 = C.double(value)

	C.gtk_spin_button_set_value(_arg0, _arg1)
}

// SetWrap sets the flag that determines if a spin button value wraps around
// to the opposite limit when the upper or lower limit of the range is
// exceeded.
func (s spinButton) SetWrap(wrap bool) {
	var _arg0 *C.GtkSpinButton
	var _arg1 C.gboolean

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))
	if wrap {
		_arg1 = C.gboolean(1)
	}

	C.gtk_spin_button_set_wrap(_arg0, _arg1)
}

// Spin: increment or decrement a spin button’s value in a specified
// direction by a specified amount.
func (s spinButton) Spin(direction SpinType, increment float64) {
	var _arg0 *C.GtkSpinButton
	var _arg1 C.GtkSpinType
	var _arg2 C.double

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkSpinType)(direction)
	_arg2 = C.double(increment)

	C.gtk_spin_button_spin(_arg0, _arg1, _arg2)
}

// Update: manually force an update of the spin button.
func (s spinButton) Update() {
	var _arg0 *C.GtkSpinButton

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))

	C.gtk_spin_button_update(_arg0)
}

// Spinner: a `GtkSpinner` widget displays an icon-size spinning animation.
//
// It is often used as an alternative to a [class@Gtk.ProgressBar] for
// displaying indefinite activity, instead of actual progress.
//
// !An example GtkSpinner (spinner.png)
//
// To start the animation, use [method@Gtk.Spinner.start], to stop it use
// [method@Gtk.Spinner.stop].
//
//
// CSS nodes
//
// `GtkSpinner` has a single CSS node with the name spinner. When the animation
// is active, the :checked pseudoclass is added to this node.
type Spinner interface {
	Widget
	Accessible
	Buildable
	ConstraintTarget

	// Spinning returns whether the spinner is spinning.
	Spinning() bool
	// SetSpinning sets the activity of the spinner.
	SetSpinning(spinning bool)
	// Start starts the animation of the spinner.
	Start()
	// Stop stops the animation of the spinner.
	Stop()
}

// spinner implements the Spinner interface.
type spinner struct {
	Widget
	Accessible
	Buildable
	ConstraintTarget
}

var _ Spinner = (*spinner)(nil)

// WrapSpinner wraps a GObject to the right type. It is
// primarily used internally.
func WrapSpinner(obj *externglib.Object) Spinner {
	return Spinner{
		Widget:           WrapWidget(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
	}
}

func marshalSpinner(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSpinner(obj), nil
}

// Spinning returns whether the spinner is spinning.
func (s spinner) Spinning() bool {
	var _arg0 *C.GtkSpinner

	_arg0 = (*C.GtkSpinner)(unsafe.Pointer(s.Native()))

	var _cret C.gboolean

	_cret = C.gtk_spinner_get_spinning(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// SetSpinning sets the activity of the spinner.
func (s spinner) SetSpinning(spinning bool) {
	var _arg0 *C.GtkSpinner
	var _arg1 C.gboolean

	_arg0 = (*C.GtkSpinner)(unsafe.Pointer(s.Native()))
	if spinning {
		_arg1 = C.gboolean(1)
	}

	C.gtk_spinner_set_spinning(_arg0, _arg1)
}

// Start starts the animation of the spinner.
func (s spinner) Start() {
	var _arg0 *C.GtkSpinner

	_arg0 = (*C.GtkSpinner)(unsafe.Pointer(s.Native()))

	C.gtk_spinner_start(_arg0)
}

// Stop stops the animation of the spinner.
func (s spinner) Stop() {
	var _arg0 *C.GtkSpinner

	_arg0 = (*C.GtkSpinner)(unsafe.Pointer(s.Native()))

	C.gtk_spinner_stop(_arg0)
}

// Stack: `GtkStack` is a container which only shows one of its children at a
// time.
//
// In contrast to `GtkNotebook`, `GtkStack` does not provide a means for users
// to change the visible child. Instead, a separate widget such as
// [class@Gtk.StackSwitcher] or [class@Gtk.StackSidebar] can be used with
// `GtkStack` to provide this functionality.
//
// Transitions between pages can be animated as slides or fades. This can be
// controlled with [method@Gtk.Stack.set_transition_type]. These animations
// respect the [property@Gtk.Settings:gtk-enable-animations] setting.
//
// `GtkStack` maintains a [class@Gtk.StackPage] object for each added child,
// which holds additional per-child properties. You obtain the `GtkStackPage`
// for a child with [method@Gtk.Stack.get_page] and you can obtain a
// `GtkSelectionModel` containing all the pages with
// [method@Gtk.Stack.get_pages].
//
//
// GtkStack as GtkBuildable
//
// To set child-specific properties in a .ui file, create `GtkStackPage` objects
// explicitly, and set the child widget as a property on it:
//
// “`xml <object class="GtkStack" id="stack"> <child> <object
// class="GtkStackPage"> <property name="name">page1</property> <property
// name="title">In the beginning…</property> <property name="child"> <object
// class="GtkLabel"> <property name="label">It was dark</property> </object>
// </property> </object> </child> “`
//
//
// CSS nodes
//
// `GtkStack` has a single CSS node named stack.
//
//
// Accessibility
//
// `GtkStack` uses the GTK_ACCESSIBLE_ROLE_TAB_PANEL for the stack pages, which
// are the accessible parent objects of the child widgets.
type Stack interface {
	Widget
	Accessible
	Buildable
	ConstraintTarget

	// Hhomogeneous gets whether @stack is horizontally homogeneous.
	Hhomogeneous() bool
	// InterpolateSize returns whether the Stack is set up to interpolate
	// between the sizes of children on page switch.
	InterpolateSize() bool
	// TransitionDuration returns the amount of time (in milliseconds) that
	// transitions between pages in @stack will take.
	TransitionDuration() uint
	// TransitionRunning returns whether the @stack is currently in a transition
	// from one page to another.
	TransitionRunning() bool
	// Vhomogeneous gets whether @stack is vertically homogeneous.
	Vhomogeneous() bool
	// VisibleChildName returns the name of the currently visible child of
	// @stack.
	//
	// Returns nil if there is no visible child.
	VisibleChildName() string
	// Remove removes a child widget from @stack.
	Remove(child Widget)
	// SetHhomogeneous sets the `GtkStack` to be horizontally homogeneous or
	// not.
	//
	// If it is homogeneous, the `GtkStack` will request the same width for all
	// its children. If it isn't, the stack may change width when a different
	// child becomes visible.
	SetHhomogeneous(hhomogeneous bool)
	// SetInterpolateSize sets whether or not @stack will interpolate its size
	// when changing the visible child.
	//
	// If the [property@Gtk.Stack:interpolate-size] property is set to true,
	// @stack will interpolate its size between the current one and the one
	// it'll take after changing the visible child, according to the set
	// transition duration.
	SetInterpolateSize(interpolateSize bool)
	// SetTransitionDuration sets the duration that transitions between pages in
	// @stack will take.
	SetTransitionDuration(duration uint)
	// SetTransitionType sets the type of animation that will be used for
	// transitions between pages in @stack.
	//
	// Available types include various kinds of fades and slides.
	//
	// The transition type can be changed without problems at runtime, so it is
	// possible to change the animation based on the page that is about to
	// become current.
	SetTransitionType(transition StackTransitionType)
	// SetVhomogeneous sets the Stack to be vertically homogeneous or not.
	//
	// If it is homogeneous, the `GtkStack` will request the same height for all
	// its children. If it isn't, the stack may change height when a different
	// child becomes visible.
	SetVhomogeneous(vhomogeneous bool)
	// SetVisibleChild makes @child the visible child of @stack.
	//
	// If @child is different from the currently visible child, the transition
	// between the two will be animated with the current transition type of
	// @stack.
	//
	// Note that the @child widget has to be visible itself (see
	// [method@Gtk.Widget.show]) in order to become the visible child of @stack.
	SetVisibleChild(child Widget)
	// SetVisibleChildFull makes the child with the given name visible.
	//
	// Note that the child widget has to be visible itself (see
	// [method@Gtk.Widget.show]) in order to become the visible child of @stack.
	SetVisibleChildFull(name string, transition StackTransitionType)
	// SetVisibleChildName makes the child with the given name visible.
	//
	// If @child is different from the currently visible child, the transition
	// between the two will be animated with the current transition type of
	// @stack.
	//
	// Note that the child widget has to be visible itself (see
	// [method@Gtk.Widget.show]) in order to become the visible child of @stack.
	SetVisibleChildName(name string)
}

// stack implements the Stack interface.
type stack struct {
	Widget
	Accessible
	Buildable
	ConstraintTarget
}

var _ Stack = (*stack)(nil)

// WrapStack wraps a GObject to the right type. It is
// primarily used internally.
func WrapStack(obj *externglib.Object) Stack {
	return Stack{
		Widget:           WrapWidget(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
	}
}

func marshalStack(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapStack(obj), nil
}

// Hhomogeneous gets whether @stack is horizontally homogeneous.
func (s stack) Hhomogeneous() bool {
	var _arg0 *C.GtkStack

	_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))

	var _cret C.gboolean

	_cret = C.gtk_stack_get_hhomogeneous(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// InterpolateSize returns whether the Stack is set up to interpolate
// between the sizes of children on page switch.
func (s stack) InterpolateSize() bool {
	var _arg0 *C.GtkStack

	_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))

	var _cret C.gboolean

	_cret = C.gtk_stack_get_interpolate_size(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// TransitionDuration returns the amount of time (in milliseconds) that
// transitions between pages in @stack will take.
func (s stack) TransitionDuration() uint {
	var _arg0 *C.GtkStack

	_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))

	var _cret C.guint

	_cret = C.gtk_stack_get_transition_duration(_arg0)

	var _guint uint

	_guint = (uint)(_cret)

	return _guint
}

// TransitionRunning returns whether the @stack is currently in a transition
// from one page to another.
func (s stack) TransitionRunning() bool {
	var _arg0 *C.GtkStack

	_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))

	var _cret C.gboolean

	_cret = C.gtk_stack_get_transition_running(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// Vhomogeneous gets whether @stack is vertically homogeneous.
func (s stack) Vhomogeneous() bool {
	var _arg0 *C.GtkStack

	_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))

	var _cret C.gboolean

	_cret = C.gtk_stack_get_vhomogeneous(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// VisibleChildName returns the name of the currently visible child of
// @stack.
//
// Returns nil if there is no visible child.
func (s stack) VisibleChildName() string {
	var _arg0 *C.GtkStack

	_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))

	var _cret *C.char

	_cret = C.gtk_stack_get_visible_child_name(_arg0)

	var _utf8 string

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Remove removes a child widget from @stack.
func (s stack) Remove(child Widget) {
	var _arg0 *C.GtkStack
	var _arg1 *C.GtkWidget

	_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_stack_remove(_arg0, _arg1)
}

// SetHhomogeneous sets the `GtkStack` to be horizontally homogeneous or
// not.
//
// If it is homogeneous, the `GtkStack` will request the same width for all
// its children. If it isn't, the stack may change width when a different
// child becomes visible.
func (s stack) SetHhomogeneous(hhomogeneous bool) {
	var _arg0 *C.GtkStack
	var _arg1 C.gboolean

	_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))
	if hhomogeneous {
		_arg1 = C.gboolean(1)
	}

	C.gtk_stack_set_hhomogeneous(_arg0, _arg1)
}

// SetInterpolateSize sets whether or not @stack will interpolate its size
// when changing the visible child.
//
// If the [property@Gtk.Stack:interpolate-size] property is set to true,
// @stack will interpolate its size between the current one and the one
// it'll take after changing the visible child, according to the set
// transition duration.
func (s stack) SetInterpolateSize(interpolateSize bool) {
	var _arg0 *C.GtkStack
	var _arg1 C.gboolean

	_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))
	if interpolateSize {
		_arg1 = C.gboolean(1)
	}

	C.gtk_stack_set_interpolate_size(_arg0, _arg1)
}

// SetTransitionDuration sets the duration that transitions between pages in
// @stack will take.
func (s stack) SetTransitionDuration(duration uint) {
	var _arg0 *C.GtkStack
	var _arg1 C.guint

	_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))
	_arg1 = C.guint(duration)

	C.gtk_stack_set_transition_duration(_arg0, _arg1)
}

// SetTransitionType sets the type of animation that will be used for
// transitions between pages in @stack.
//
// Available types include various kinds of fades and slides.
//
// The transition type can be changed without problems at runtime, so it is
// possible to change the animation based on the page that is about to
// become current.
func (s stack) SetTransitionType(transition StackTransitionType) {
	var _arg0 *C.GtkStack
	var _arg1 C.GtkStackTransitionType

	_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkStackTransitionType)(transition)

	C.gtk_stack_set_transition_type(_arg0, _arg1)
}

// SetVhomogeneous sets the Stack to be vertically homogeneous or not.
//
// If it is homogeneous, the `GtkStack` will request the same height for all
// its children. If it isn't, the stack may change height when a different
// child becomes visible.
func (s stack) SetVhomogeneous(vhomogeneous bool) {
	var _arg0 *C.GtkStack
	var _arg1 C.gboolean

	_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))
	if vhomogeneous {
		_arg1 = C.gboolean(1)
	}

	C.gtk_stack_set_vhomogeneous(_arg0, _arg1)
}

// SetVisibleChild makes @child the visible child of @stack.
//
// If @child is different from the currently visible child, the transition
// between the two will be animated with the current transition type of
// @stack.
//
// Note that the @child widget has to be visible itself (see
// [method@Gtk.Widget.show]) in order to become the visible child of @stack.
func (s stack) SetVisibleChild(child Widget) {
	var _arg0 *C.GtkStack
	var _arg1 *C.GtkWidget

	_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_stack_set_visible_child(_arg0, _arg1)
}

// SetVisibleChildFull makes the child with the given name visible.
//
// Note that the child widget has to be visible itself (see
// [method@Gtk.Widget.show]) in order to become the visible child of @stack.
func (s stack) SetVisibleChildFull(name string, transition StackTransitionType) {
	var _arg0 *C.GtkStack
	var _arg1 *C.char
	var _arg2 C.GtkStackTransitionType

	_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.GtkStackTransitionType)(transition)

	C.gtk_stack_set_visible_child_full(_arg0, _arg1, _arg2)
}

// SetVisibleChildName makes the child with the given name visible.
//
// If @child is different from the currently visible child, the transition
// between the two will be animated with the current transition type of
// @stack.
//
// Note that the child widget has to be visible itself (see
// [method@Gtk.Widget.show]) in order to become the visible child of @stack.
func (s stack) SetVisibleChildName(name string) {
	var _arg0 *C.GtkStack
	var _arg1 *C.char

	_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_stack_set_visible_child_name(_arg0, _arg1)
}

// StackPage: `GtkStackPage` is an auxiliary class used by `GtkStack`.
type StackPage interface {
	gextras.Objector
	Accessible

	// IconName returns the icon name of the page.
	IconName() string
	// Name returns the name of the page.
	Name() string
	// NeedsAttention returns whether the page is marked as “needs attention”.
	NeedsAttention() bool
	// Title gets the page title.
	Title() string
	// UseUnderline gets whether underlines in the page title indicate
	// mnemonics.
	UseUnderline() bool
	// Visible returns whether @page is visible in its `GtkStack`.
	//
	// This is independent from the [property@Gtk.Widget:visible] property of
	// its widget.
	Visible() bool
	// SetIconName sets the icon name of the page.
	SetIconName(setting string)
	// SetName sets the name of the page.
	SetName(setting string)
	// SetNeedsAttention sets whether the page is marked as “needs attention”.
	SetNeedsAttention(setting bool)
	// SetTitle sets the page title.
	SetTitle(setting string)
	// SetUseUnderline sets whether underlines in the page title indicate
	// mnemonics.
	SetUseUnderline(setting bool)
	// SetVisible sets whether @page is visible in its `GtkStack`.
	SetVisible(visible bool)
}

// stackPage implements the StackPage interface.
type stackPage struct {
	gextras.Objector
	Accessible
}

var _ StackPage = (*stackPage)(nil)

// WrapStackPage wraps a GObject to the right type. It is
// primarily used internally.
func WrapStackPage(obj *externglib.Object) StackPage {
	return StackPage{
		Objector:   obj,
		Accessible: WrapAccessible(obj),
	}
}

func marshalStackPage(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapStackPage(obj), nil
}

// IconName returns the icon name of the page.
func (s stackPage) IconName() string {
	var _arg0 *C.GtkStackPage

	_arg0 = (*C.GtkStackPage)(unsafe.Pointer(s.Native()))

	var _cret *C.char

	_cret = C.gtk_stack_page_get_icon_name(_arg0)

	var _utf8 string

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Name returns the name of the page.
func (s stackPage) Name() string {
	var _arg0 *C.GtkStackPage

	_arg0 = (*C.GtkStackPage)(unsafe.Pointer(s.Native()))

	var _cret *C.char

	_cret = C.gtk_stack_page_get_name(_arg0)

	var _utf8 string

	_utf8 = C.GoString(_cret)

	return _utf8
}

// NeedsAttention returns whether the page is marked as “needs attention”.
func (s stackPage) NeedsAttention() bool {
	var _arg0 *C.GtkStackPage

	_arg0 = (*C.GtkStackPage)(unsafe.Pointer(s.Native()))

	var _cret C.gboolean

	_cret = C.gtk_stack_page_get_needs_attention(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// Title gets the page title.
func (s stackPage) Title() string {
	var _arg0 *C.GtkStackPage

	_arg0 = (*C.GtkStackPage)(unsafe.Pointer(s.Native()))

	var _cret *C.char

	_cret = C.gtk_stack_page_get_title(_arg0)

	var _utf8 string

	_utf8 = C.GoString(_cret)

	return _utf8
}

// UseUnderline gets whether underlines in the page title indicate
// mnemonics.
func (s stackPage) UseUnderline() bool {
	var _arg0 *C.GtkStackPage

	_arg0 = (*C.GtkStackPage)(unsafe.Pointer(s.Native()))

	var _cret C.gboolean

	_cret = C.gtk_stack_page_get_use_underline(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// Visible returns whether @page is visible in its `GtkStack`.
//
// This is independent from the [property@Gtk.Widget:visible] property of
// its widget.
func (s stackPage) Visible() bool {
	var _arg0 *C.GtkStackPage

	_arg0 = (*C.GtkStackPage)(unsafe.Pointer(s.Native()))

	var _cret C.gboolean

	_cret = C.gtk_stack_page_get_visible(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// SetIconName sets the icon name of the page.
func (s stackPage) SetIconName(setting string) {
	var _arg0 *C.GtkStackPage
	var _arg1 *C.char

	_arg0 = (*C.GtkStackPage)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(setting))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_stack_page_set_icon_name(_arg0, _arg1)
}

// SetName sets the name of the page.
func (s stackPage) SetName(setting string) {
	var _arg0 *C.GtkStackPage
	var _arg1 *C.char

	_arg0 = (*C.GtkStackPage)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(setting))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_stack_page_set_name(_arg0, _arg1)
}

// SetNeedsAttention sets whether the page is marked as “needs attention”.
func (s stackPage) SetNeedsAttention(setting bool) {
	var _arg0 *C.GtkStackPage
	var _arg1 C.gboolean

	_arg0 = (*C.GtkStackPage)(unsafe.Pointer(s.Native()))
	if setting {
		_arg1 = C.gboolean(1)
	}

	C.gtk_stack_page_set_needs_attention(_arg0, _arg1)
}

// SetTitle sets the page title.
func (s stackPage) SetTitle(setting string) {
	var _arg0 *C.GtkStackPage
	var _arg1 *C.char

	_arg0 = (*C.GtkStackPage)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(setting))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_stack_page_set_title(_arg0, _arg1)
}

// SetUseUnderline sets whether underlines in the page title indicate
// mnemonics.
func (s stackPage) SetUseUnderline(setting bool) {
	var _arg0 *C.GtkStackPage
	var _arg1 C.gboolean

	_arg0 = (*C.GtkStackPage)(unsafe.Pointer(s.Native()))
	if setting {
		_arg1 = C.gboolean(1)
	}

	C.gtk_stack_page_set_use_underline(_arg0, _arg1)
}

// SetVisible sets whether @page is visible in its `GtkStack`.
func (s stackPage) SetVisible(visible bool) {
	var _arg0 *C.GtkStackPage
	var _arg1 C.gboolean

	_arg0 = (*C.GtkStackPage)(unsafe.Pointer(s.Native()))
	if visible {
		_arg1 = C.gboolean(1)
	}

	C.gtk_stack_page_set_visible(_arg0, _arg1)
}

// StackSidebar: a `GtkStackSidebar` uses a sidebar to switch between `GtkStack`
// pages.
//
// In order to use a `GtkStackSidebar`, you simply use a `GtkStack` to organize
// your UI flow, and add the sidebar to your sidebar area. You can use
// [method@Gtk.StackSidebar.set_stack] to connect the `GtkStackSidebar` to the
// `GtkStack`.
//
//
// CSS nodes
//
// `GtkStackSidebar` has a single CSS node with name stacksidebar and style
// class .sidebar.
//
// When circumstances require it, `GtkStackSidebar` adds the .needs-attention
// style class to the widgets representing the stack pages.
type StackSidebar interface {
	Widget
	Accessible
	Buildable
	ConstraintTarget

	// SetStack: set the `GtkStack` associated with this `GtkStackSidebar`.
	//
	// The sidebar widget will automatically update according to the order and
	// items within the given `GtkStack`.
	SetStack(stack Stack)
}

// stackSidebar implements the StackSidebar interface.
type stackSidebar struct {
	Widget
	Accessible
	Buildable
	ConstraintTarget
}

var _ StackSidebar = (*stackSidebar)(nil)

// WrapStackSidebar wraps a GObject to the right type. It is
// primarily used internally.
func WrapStackSidebar(obj *externglib.Object) StackSidebar {
	return StackSidebar{
		Widget:           WrapWidget(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
	}
}

func marshalStackSidebar(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapStackSidebar(obj), nil
}

// SetStack: set the `GtkStack` associated with this `GtkStackSidebar`.
//
// The sidebar widget will automatically update according to the order and
// items within the given `GtkStack`.
func (s stackSidebar) SetStack(stack Stack) {
	var _arg0 *C.GtkStackSidebar
	var _arg1 *C.GtkStack

	_arg0 = (*C.GtkStackSidebar)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkStack)(unsafe.Pointer(stack.Native()))

	C.gtk_stack_sidebar_set_stack(_arg0, _arg1)
}

// StackSwitcher: the `GtkStackSwitcher` shows a row of buttons to switch
// between `GtkStack` pages.
//
// !An example GtkStackSwitcher (stackswitcher.png)
//
// It acts as a controller for the associated `GtkStack`.
//
// All the content for the buttons comes from the properties of the stacks
// [class@Gtk.StackPage] objects; the button visibility in a `GtkStackSwitcher`
// widget is controlled by the visibility of the child in the `GtkStack`.
//
// It is possible to associate multiple `GtkStackSwitcher` widgets with the same
// `GtkStack` widget.
//
//
// CSS nodes
//
// `GtkStackSwitcher` has a single CSS node named stackswitcher and style class
// .stack-switcher.
//
// When circumstances require it, `GtkStackSwitcher` adds the .needs-attention
// style class to the widgets representing the stack pages.
//
//
// Accessibility
//
// `GtkStackSwitcher` uses the GTK_ACCESSIBLE_ROLE_TAB_LIST role and uses the
// GTK_ACCESSIBLE_ROLE_TAB for its buttons.
type StackSwitcher interface {
	Widget
	Accessible
	Buildable
	ConstraintTarget

	// SetStack sets the stack to control.
	SetStack(stack Stack)
}

// stackSwitcher implements the StackSwitcher interface.
type stackSwitcher struct {
	Widget
	Accessible
	Buildable
	ConstraintTarget
}

var _ StackSwitcher = (*stackSwitcher)(nil)

// WrapStackSwitcher wraps a GObject to the right type. It is
// primarily used internally.
func WrapStackSwitcher(obj *externglib.Object) StackSwitcher {
	return StackSwitcher{
		Widget:           WrapWidget(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
	}
}

func marshalStackSwitcher(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapStackSwitcher(obj), nil
}

// SetStack sets the stack to control.
func (s stackSwitcher) SetStack(stack Stack) {
	var _arg0 *C.GtkStackSwitcher
	var _arg1 *C.GtkStack

	_arg0 = (*C.GtkStackSwitcher)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkStack)(unsafe.Pointer(stack.Native()))

	C.gtk_stack_switcher_set_stack(_arg0, _arg1)
}

// Statusbar: a `GtkStatusbar` widget is usually placed along the bottom of an
// application's main [class@Gtk.Window].
//
// !An example GtkStatusbar (statusbar.png)
//
// A `GtkStatusBar` may provide a regular commentary of the application's status
// (as is usually the case in a web browser, for example), or may be used to
// simply output a message when the status changes, (when an upload is complete
// in an FTP client, for example).
//
// Status bars in GTK maintain a stack of messages. The message at the top of
// the each bar’s stack is the one that will currently be displayed.
//
// Any messages added to a statusbar’s stack must specify a context id that is
// used to uniquely identify the source of a message. This context id can be
// generated by [method@Gtk.Statusbar.get_context_id], given a message and the
// statusbar that it will be added to. Note that messages are stored in a stack,
// and when choosing which message to display, the stack structure is adhered
// to, regardless of the context identifier of a message.
//
// One could say that a statusbar maintains one stack of messages for display
// purposes, but allows multiple message producers to maintain sub-stacks of the
// messages they produced (via context ids).
//
// Status bars are created using [ctor@Gtk.Statusbar.new].
//
// Messages are added to the bar’s stack with [method@Gtk.Statusbar.push].
//
// The message at the top of the stack can be removed using
// [method@Gtk.Statusbar.pop]. A message can be removed from anywhere in the
// stack if its message id was recorded at the time it was added. This is done
// using [method@Gtk.Statusbar.remove].
//
//
// CSS node
//
// `GtkStatusbar` has a single CSS node with name `statusbar`.
type Statusbar interface {
	Widget
	Accessible
	Buildable
	ConstraintTarget

	// ContextID returns a new context identifier, given a description of the
	// actual context.
	//
	// Note that the description is not shown in the UI.
	ContextID(contextDescription string) uint
	// Pop removes the first message in the `GtkStatusbar`’s stack with the
	// given context id.
	//
	// Note that this may not change the displayed message, if the message at
	// the top of the stack has a different context id.
	Pop(contextId uint)
	// Push pushes a new message onto a statusbar’s stack.
	Push(contextId uint, text string) uint
	// Remove forces the removal of a message from a statusbar’s stack. The
	// exact @context_id and @message_id must be specified.
	Remove(contextId uint, messageId uint)
	// RemoveAll forces the removal of all messages from a statusbar's stack
	// with the exact @context_id.
	RemoveAll(contextId uint)
}

// statusbar implements the Statusbar interface.
type statusbar struct {
	Widget
	Accessible
	Buildable
	ConstraintTarget
}

var _ Statusbar = (*statusbar)(nil)

// WrapStatusbar wraps a GObject to the right type. It is
// primarily used internally.
func WrapStatusbar(obj *externglib.Object) Statusbar {
	return Statusbar{
		Widget:           WrapWidget(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
	}
}

func marshalStatusbar(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapStatusbar(obj), nil
}

// ContextID returns a new context identifier, given a description of the
// actual context.
//
// Note that the description is not shown in the UI.
func (s statusbar) ContextID(contextDescription string) uint {
	var _arg0 *C.GtkStatusbar
	var _arg1 *C.char

	_arg0 = (*C.GtkStatusbar)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(contextDescription))
	defer C.free(unsafe.Pointer(_arg1))

	var _cret C.guint

	_cret = C.gtk_statusbar_get_context_id(_arg0, _arg1)

	var _guint uint

	_guint = (uint)(_cret)

	return _guint
}

// Pop removes the first message in the `GtkStatusbar`’s stack with the
// given context id.
//
// Note that this may not change the displayed message, if the message at
// the top of the stack has a different context id.
func (s statusbar) Pop(contextId uint) {
	var _arg0 *C.GtkStatusbar
	var _arg1 C.guint

	_arg0 = (*C.GtkStatusbar)(unsafe.Pointer(s.Native()))
	_arg1 = C.guint(contextId)

	C.gtk_statusbar_pop(_arg0, _arg1)
}

// Push pushes a new message onto a statusbar’s stack.
func (s statusbar) Push(contextId uint, text string) uint {
	var _arg0 *C.GtkStatusbar
	var _arg1 C.guint
	var _arg2 *C.char

	_arg0 = (*C.GtkStatusbar)(unsafe.Pointer(s.Native()))
	_arg1 = C.guint(contextId)
	_arg2 = (*C.char)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg2))

	var _cret C.guint

	_cret = C.gtk_statusbar_push(_arg0, _arg1, _arg2)

	var _guint uint

	_guint = (uint)(_cret)

	return _guint
}

// Remove forces the removal of a message from a statusbar’s stack. The
// exact @context_id and @message_id must be specified.
func (s statusbar) Remove(contextId uint, messageId uint) {
	var _arg0 *C.GtkStatusbar
	var _arg1 C.guint
	var _arg2 C.guint

	_arg0 = (*C.GtkStatusbar)(unsafe.Pointer(s.Native()))
	_arg1 = C.guint(contextId)
	_arg2 = C.guint(messageId)

	C.gtk_statusbar_remove(_arg0, _arg1, _arg2)
}

// RemoveAll forces the removal of all messages from a statusbar's stack
// with the exact @context_id.
func (s statusbar) RemoveAll(contextId uint) {
	var _arg0 *C.GtkStatusbar
	var _arg1 C.guint

	_arg0 = (*C.GtkStatusbar)(unsafe.Pointer(s.Native()))
	_arg1 = C.guint(contextId)

	C.gtk_statusbar_remove_all(_arg0, _arg1)
}

// Switch: `GtkSwitch` is a "light switch" that has two states: on or off.
//
// !An example GtkSwitch (switch.png)
//
// The user can control which state should be active by clicking the empty area,
// or by dragging the handle.
//
// `GtkSwitch` can also handle situations where the underlying state changes
// with a delay. See [signal@GtkSwitch::state-set] for details.
//
//
// CSS nodes
//
// “` switch ├── label ├── label ╰── slider “`
//
// `GtkSwitch` has four css nodes, the main node with the name switch and
// subnodes for the slider and the on and off labels. Neither of them is using
// any style classes.
//
//
// Accessibility
//
// `GtkSwitch` uses the GTK_ACCESSIBLE_ROLE_SWITCH role.
type Switch interface {
	Widget
	Accessible
	Actionable
	Buildable
	ConstraintTarget

	// Active gets whether the `GtkSwitch` is in its “on” or “off” state.
	Active() bool
	// State gets the underlying state of the `GtkSwitch`.
	State() bool
	// SetActive changes the state of @self to the desired one.
	SetActive(isActive bool)
	// SetState sets the underlying state of the `GtkSwitch`.
	//
	// Normally, this is the same as [property@Gtk.Switch:active], unless the
	// switch is set up for delayed state changes. This function is typically
	// called from a [signal@Gtk.Switch`::state-set] signal handler.
	//
	// See [signal@Gtk.Switch::state-set] for details.
	SetState(state bool)
}

// _switch implements the Switch interface.
type _switch struct {
	Widget
	Accessible
	Actionable
	Buildable
	ConstraintTarget
}

var _ Switch = (*_switch)(nil)

// WrapSwitch wraps a GObject to the right type. It is
// primarily used internally.
func WrapSwitch(obj *externglib.Object) Switch {
	return Switch{
		Widget:           WrapWidget(obj),
		Accessible:       WrapAccessible(obj),
		Actionable:       WrapActionable(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
	}
}

func marshalSwitch(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSwitch(obj), nil
}

// Active gets whether the `GtkSwitch` is in its “on” or “off” state.
func (s _switch) Active() bool {
	var _arg0 *C.GtkSwitch

	_arg0 = (*C.GtkSwitch)(unsafe.Pointer(s.Native()))

	var _cret C.gboolean

	_cret = C.gtk_switch_get_active(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// State gets the underlying state of the `GtkSwitch`.
func (s _switch) State() bool {
	var _arg0 *C.GtkSwitch

	_arg0 = (*C.GtkSwitch)(unsafe.Pointer(s.Native()))

	var _cret C.gboolean

	_cret = C.gtk_switch_get_state(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// SetActive changes the state of @self to the desired one.
func (s _switch) SetActive(isActive bool) {
	var _arg0 *C.GtkSwitch
	var _arg1 C.gboolean

	_arg0 = (*C.GtkSwitch)(unsafe.Pointer(s.Native()))
	if isActive {
		_arg1 = C.gboolean(1)
	}

	C.gtk_switch_set_active(_arg0, _arg1)
}

// SetState sets the underlying state of the `GtkSwitch`.
//
// Normally, this is the same as [property@Gtk.Switch:active], unless the
// switch is set up for delayed state changes. This function is typically
// called from a [signal@Gtk.Switch`::state-set] signal handler.
//
// See [signal@Gtk.Switch::state-set] for details.
func (s _switch) SetState(state bool) {
	var _arg0 *C.GtkSwitch
	var _arg1 C.gboolean

	_arg0 = (*C.GtkSwitch)(unsafe.Pointer(s.Native()))
	if state {
		_arg1 = C.gboolean(1)
	}

	C.gtk_switch_set_state(_arg0, _arg1)
}

// Text: the `GtkText` widget is a single-line text entry widget.
//
// `GtkText` is the common implementation of single-line text editing that is
// shared between `GtkEntry`, `GtkPasswordEntry, `GtkSpinButton` and other
// widgets. In all of these, `GtkText` is used as the delegate for the
// [iface@Gtk.Editable] implementation.
//
// A fairly large set of key bindings are supported by default. If the entered
// text is longer than the allocation of the widget, the widget will scroll so
// that the cursor position is visible.
//
// When using an entry for passwords and other sensitive information, it can be
// put into “password mode” using [method@Gtk.Text.set_visibility]. In this
// mode, entered text is displayed using a “invisible” character. By default,
// GTK picks the best invisible character that is available in the current font,
// but it can be changed with [method@Gtk.Text.set_invisible_char].
//
// If you are looking to add icons or progress display in an entry, look at
// `GtkEntry`. There other alternatives for more specialized use cases, such as
// `GtkSearchEntry`.
//
// If you need multi-line editable text, look at `GtkTextView`.
//
//
// CSS nodes
//
// “` text[.read-only] ├── placeholder ├── undershoot.left ├── undershoot.right
// ├── [selection] ├── [block-cursor] ╰── [window.popup] “`
//
// `GtkText` has a main node with the name text. Depending on the properties of
// the widget, the .read-only style class may appear.
//
// When the entry has a selection, it adds a subnode with the name selection.
//
// When the entry is in overwrite mode, it adds a subnode with the name
// block-cursor that determines how the block cursor is drawn.
//
// The CSS node for a context menu is added as a subnode below text as well.
//
// The undershoot nodes are used to draw the underflow indication when content
// is scrolled out of view. These nodes get the .left and .right style classes
// added depending on where the indication is drawn.
//
// When touch is used and touch selection handles are shown, they are using CSS
// nodes with name cursor-handle. They get the .top or .bottom style class
// depending on where they are shown in relation to the selection. If there is
// just a single handle for the text cursor, it gets the style class
// .insertion-cursor.
//
//
// Accessibility
//
// `GtkText` uses the GTK_ACCESSIBLE_ROLE_NONE role, which causes it to be
// skipped for accessibility. This is because `GtkText` is expected to be used
// as a delegate for a `GtkEditable` implementation that will be represented to
// accessibility.
type Text interface {
	Widget
	Accessible
	Buildable
	ConstraintTarget
	Editable

	// ActivatesDefault retrieves the value set by
	// gtk_text_set_activates_default().
	ActivatesDefault() bool
	// EnableEmojiCompletion returns whether Emoji completion is enabled for
	// this `GtkText` widget.
	EnableEmojiCompletion() bool
	// InvisibleChar retrieves the character displayed in place of the real
	// characters for entries with visibility set to false.
	//
	// Note that GTK does not compute this value unless it needs it, so the
	// value returned by this function is not very useful unless it has been
	// explicitly set with [method@Gtk.Text.set_invisible_char].
	InvisibleChar() uint32
	// MaxLength retrieves the maximum allowed length of the text in @self.
	//
	// See [method@Gtk.Text.set_max_length].
	//
	// This is equivalent to getting @self's `GtkEntryBuffer` and calling
	// [method@Gtk.EntryBuffer.get_max_length] on it.
	MaxLength() int
	// OverwriteMode gets the value set by gtk_text_set_overwrite_mode().
	OverwriteMode() bool
	// PlaceholderText retrieves the text that will be displayed when @self is
	// empty and unfocused
	PlaceholderText() string
	// PropagateTextWidth returns whether the `GtkText` will grow and shrink
	// with the content.
	PropagateTextWidth() bool
	// TextLength retrieves the current length of the text in @self.
	//
	// This is equivalent to getting @self's `GtkEntryBuffer` and calling
	// [method@Gtk.EntryBuffer.get_length] on it.
	TextLength() uint16
	// TruncateMultiline returns whether the `GtkText` will truncate multi-line
	// text that is pasted into the widget
	TruncateMultiline() bool
	// Visibility retrieves whether the text in @self is visible.
	Visibility() bool
	// GrabFocusWithoutSelecting causes @self to have keyboard focus.
	//
	// It behaves like [method@Gtk.Widget.grab_focus], except that it doesn't
	// select the contents of @self. You only want to call this on some special
	// entries which the user usually doesn't want to replace all text in, such
	// as search-as-you-type entries.
	GrabFocusWithoutSelecting() bool
	// SetActivatesDefault: if @activates is true, pressing Enter in the @self
	// will activate the default widget for the window containing @self.
	//
	// This usually means that the dialog containing the `GtkText` will be
	// closed, since the default widget is usually one of the dialog buttons.
	SetActivatesDefault(activates bool)
	// SetAttributes sets attributes that are applied to the text.
	SetAttributes(attrs *pango.AttrList)
	// SetBuffer: set the `GtkEntryBuffer` object which holds the text for this
	// widget.
	SetBuffer(buffer EntryBuffer)
	// SetEnableEmojiCompletion sets whether Emoji completion is enabled.
	//
	// If it is, typing ':', followed by a recognized keyword, will pop up a
	// window with suggested Emojis matching the keyword.
	SetEnableEmojiCompletion(enableEmojiCompletion bool)
	// SetExtraMenu sets a menu model to add when constructing the context menu
	// for @self.
	SetExtraMenu(model gio.MenuModel)
	// SetInputHints sets input hints that allow input methods to fine-tune
	// their behaviour.
	SetInputHints(hints InputHints)
	// SetInputPurpose sets the input purpose of the `GtkText`.
	//
	// This can be used by on-screen keyboards and other input methods to adjust
	// their behaviour.
	SetInputPurpose(purpose InputPurpose)
	// SetInvisibleChar sets the character to use in place of the actual text
	// when in “password mode”.
	//
	// By default, GTK picks the best invisible char available in the current
	// font. If you set the invisible char to 0, then the user will get no
	// feedback at all; there will be no text on the screen as they type.
	SetInvisibleChar(ch uint32)
	// SetMaxLength sets the maximum allowed length of the contents of the
	// widget.
	//
	// If the current contents are longer than the given length, then they will
	// be truncated to fit.
	//
	// This is equivalent to getting @self's `GtkEntryBuffer` and calling
	// [method@Gtk.EntryBuffer.set_max_length] on it.
	SetMaxLength(length int)
	// SetOverwriteMode sets whether the text is overwritten when typing in the
	// `GtkText`.
	SetOverwriteMode(overwrite bool)
	// SetPlaceholderText sets text to be displayed in @self when it is empty.
	//
	// This can be used to give a visual hint of the expected contents of the
	// `GtkText`.
	SetPlaceholderText(text string)
	// SetPropagateTextWidth sets whether the `GtkText` should grow and shrink
	// with the content.
	SetPropagateTextWidth(propagateTextWidth bool)
	// SetTabs sets tabstops that are applied to the text.
	SetTabs(tabs *pango.TabArray)
	// SetTruncateMultiline sets whether the `GtkText` should truncate
	// multi-line text that is pasted into the widget.
	SetTruncateMultiline(truncateMultiline bool)
	// SetVisibility sets whether the contents of the `GtkText` are visible or
	// not.
	//
	// When visibility is set to false, characters are displayed as the
	// invisible char, and will also appear that way when the text in the widget
	// is copied to the clipboard.
	//
	// By default, GTK picks the best invisible character available in the
	// current font, but it can be changed with
	// [method@Gtk.Text.set_invisible_char].
	//
	// Note that you probably want to set [property@Gtk.Text:input-purpose] to
	// GTK_INPUT_PURPOSE_PASSWORD or GTK_INPUT_PURPOSE_PIN to inform input
	// methods about the purpose of this self, in addition to setting visibility
	// to false.
	SetVisibility(visible bool)
	// UnsetInvisibleChar unsets the invisible char.
	//
	// After calling this, the default invisible char is used again.
	UnsetInvisibleChar()
}

// text implements the Text interface.
type text struct {
	Widget
	Accessible
	Buildable
	ConstraintTarget
	Editable
}

var _ Text = (*text)(nil)

// WrapText wraps a GObject to the right type. It is
// primarily used internally.
func WrapText(obj *externglib.Object) Text {
	return Text{
		Widget:           WrapWidget(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
		Editable:         WrapEditable(obj),
	}
}

func marshalText(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapText(obj), nil
}

// ActivatesDefault retrieves the value set by
// gtk_text_set_activates_default().
func (s text) ActivatesDefault() bool {
	var _arg0 *C.GtkText

	_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))

	var _cret C.gboolean

	_cret = C.gtk_text_get_activates_default(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// EnableEmojiCompletion returns whether Emoji completion is enabled for
// this `GtkText` widget.
func (s text) EnableEmojiCompletion() bool {
	var _arg0 *C.GtkText

	_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))

	var _cret C.gboolean

	_cret = C.gtk_text_get_enable_emoji_completion(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// InvisibleChar retrieves the character displayed in place of the real
// characters for entries with visibility set to false.
//
// Note that GTK does not compute this value unless it needs it, so the
// value returned by this function is not very useful unless it has been
// explicitly set with [method@Gtk.Text.set_invisible_char].
func (s text) InvisibleChar() uint32 {
	var _arg0 *C.GtkText

	_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))

	var _cret C.gunichar

	_cret = C.gtk_text_get_invisible_char(_arg0)

	var _gunichar uint32

	_gunichar = (uint32)(_cret)

	return _gunichar
}

// MaxLength retrieves the maximum allowed length of the text in @self.
//
// See [method@Gtk.Text.set_max_length].
//
// This is equivalent to getting @self's `GtkEntryBuffer` and calling
// [method@Gtk.EntryBuffer.get_max_length] on it.
func (s text) MaxLength() int {
	var _arg0 *C.GtkText

	_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))

	var _cret C.int

	_cret = C.gtk_text_get_max_length(_arg0)

	var _gint int

	_gint = (int)(_cret)

	return _gint
}

// OverwriteMode gets the value set by gtk_text_set_overwrite_mode().
func (s text) OverwriteMode() bool {
	var _arg0 *C.GtkText

	_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))

	var _cret C.gboolean

	_cret = C.gtk_text_get_overwrite_mode(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// PlaceholderText retrieves the text that will be displayed when @self is
// empty and unfocused
func (s text) PlaceholderText() string {
	var _arg0 *C.GtkText

	_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))

	var _cret *C.char

	_cret = C.gtk_text_get_placeholder_text(_arg0)

	var _utf8 string

	_utf8 = C.GoString(_cret)

	return _utf8
}

// PropagateTextWidth returns whether the `GtkText` will grow and shrink
// with the content.
func (s text) PropagateTextWidth() bool {
	var _arg0 *C.GtkText

	_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))

	var _cret C.gboolean

	_cret = C.gtk_text_get_propagate_text_width(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// TextLength retrieves the current length of the text in @self.
//
// This is equivalent to getting @self's `GtkEntryBuffer` and calling
// [method@Gtk.EntryBuffer.get_length] on it.
func (s text) TextLength() uint16 {
	var _arg0 *C.GtkText

	_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))

	var _cret C.guint16

	_cret = C.gtk_text_get_text_length(_arg0)

	var _guint16 uint16

	_guint16 = (uint16)(_cret)

	return _guint16
}

// TruncateMultiline returns whether the `GtkText` will truncate multi-line
// text that is pasted into the widget
func (s text) TruncateMultiline() bool {
	var _arg0 *C.GtkText

	_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))

	var _cret C.gboolean

	_cret = C.gtk_text_get_truncate_multiline(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// Visibility retrieves whether the text in @self is visible.
func (s text) Visibility() bool {
	var _arg0 *C.GtkText

	_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))

	var _cret C.gboolean

	_cret = C.gtk_text_get_visibility(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// GrabFocusWithoutSelecting causes @self to have keyboard focus.
//
// It behaves like [method@Gtk.Widget.grab_focus], except that it doesn't
// select the contents of @self. You only want to call this on some special
// entries which the user usually doesn't want to replace all text in, such
// as search-as-you-type entries.
func (s text) GrabFocusWithoutSelecting() bool {
	var _arg0 *C.GtkText

	_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))

	var _cret C.gboolean

	_cret = C.gtk_text_grab_focus_without_selecting(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// SetActivatesDefault: if @activates is true, pressing Enter in the @self
// will activate the default widget for the window containing @self.
//
// This usually means that the dialog containing the `GtkText` will be
// closed, since the default widget is usually one of the dialog buttons.
func (s text) SetActivatesDefault(activates bool) {
	var _arg0 *C.GtkText
	var _arg1 C.gboolean

	_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))
	if activates {
		_arg1 = C.gboolean(1)
	}

	C.gtk_text_set_activates_default(_arg0, _arg1)
}

// SetAttributes sets attributes that are applied to the text.
func (s text) SetAttributes(attrs *pango.AttrList) {
	var _arg0 *C.GtkText
	var _arg1 *C.PangoAttrList

	_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.PangoAttrList)(unsafe.Pointer(attrs.Native()))

	C.gtk_text_set_attributes(_arg0, _arg1)
}

// SetBuffer: set the `GtkEntryBuffer` object which holds the text for this
// widget.
func (s text) SetBuffer(buffer EntryBuffer) {
	var _arg0 *C.GtkText
	var _arg1 *C.GtkEntryBuffer

	_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkEntryBuffer)(unsafe.Pointer(buffer.Native()))

	C.gtk_text_set_buffer(_arg0, _arg1)
}

// SetEnableEmojiCompletion sets whether Emoji completion is enabled.
//
// If it is, typing ':', followed by a recognized keyword, will pop up a
// window with suggested Emojis matching the keyword.
func (s text) SetEnableEmojiCompletion(enableEmojiCompletion bool) {
	var _arg0 *C.GtkText
	var _arg1 C.gboolean

	_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))
	if enableEmojiCompletion {
		_arg1 = C.gboolean(1)
	}

	C.gtk_text_set_enable_emoji_completion(_arg0, _arg1)
}

// SetExtraMenu sets a menu model to add when constructing the context menu
// for @self.
func (s text) SetExtraMenu(model gio.MenuModel) {
	var _arg0 *C.GtkText
	var _arg1 *C.GMenuModel

	_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GMenuModel)(unsafe.Pointer(model.Native()))

	C.gtk_text_set_extra_menu(_arg0, _arg1)
}

// SetInputHints sets input hints that allow input methods to fine-tune
// their behaviour.
func (s text) SetInputHints(hints InputHints) {
	var _arg0 *C.GtkText
	var _arg1 C.GtkInputHints

	_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkInputHints)(hints)

	C.gtk_text_set_input_hints(_arg0, _arg1)
}

// SetInputPurpose sets the input purpose of the `GtkText`.
//
// This can be used by on-screen keyboards and other input methods to adjust
// their behaviour.
func (s text) SetInputPurpose(purpose InputPurpose) {
	var _arg0 *C.GtkText
	var _arg1 C.GtkInputPurpose

	_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkInputPurpose)(purpose)

	C.gtk_text_set_input_purpose(_arg0, _arg1)
}

// SetInvisibleChar sets the character to use in place of the actual text
// when in “password mode”.
//
// By default, GTK picks the best invisible char available in the current
// font. If you set the invisible char to 0, then the user will get no
// feedback at all; there will be no text on the screen as they type.
func (s text) SetInvisibleChar(ch uint32) {
	var _arg0 *C.GtkText
	var _arg1 C.gunichar

	_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))
	_arg1 = C.gunichar(ch)

	C.gtk_text_set_invisible_char(_arg0, _arg1)
}

// SetMaxLength sets the maximum allowed length of the contents of the
// widget.
//
// If the current contents are longer than the given length, then they will
// be truncated to fit.
//
// This is equivalent to getting @self's `GtkEntryBuffer` and calling
// [method@Gtk.EntryBuffer.set_max_length] on it.
func (s text) SetMaxLength(length int) {
	var _arg0 *C.GtkText
	var _arg1 C.int

	_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))
	_arg1 = C.int(length)

	C.gtk_text_set_max_length(_arg0, _arg1)
}

// SetOverwriteMode sets whether the text is overwritten when typing in the
// `GtkText`.
func (s text) SetOverwriteMode(overwrite bool) {
	var _arg0 *C.GtkText
	var _arg1 C.gboolean

	_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))
	if overwrite {
		_arg1 = C.gboolean(1)
	}

	C.gtk_text_set_overwrite_mode(_arg0, _arg1)
}

// SetPlaceholderText sets text to be displayed in @self when it is empty.
//
// This can be used to give a visual hint of the expected contents of the
// `GtkText`.
func (s text) SetPlaceholderText(text string) {
	var _arg0 *C.GtkText
	var _arg1 *C.char

	_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_text_set_placeholder_text(_arg0, _arg1)
}

// SetPropagateTextWidth sets whether the `GtkText` should grow and shrink
// with the content.
func (s text) SetPropagateTextWidth(propagateTextWidth bool) {
	var _arg0 *C.GtkText
	var _arg1 C.gboolean

	_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))
	if propagateTextWidth {
		_arg1 = C.gboolean(1)
	}

	C.gtk_text_set_propagate_text_width(_arg0, _arg1)
}

// SetTabs sets tabstops that are applied to the text.
func (s text) SetTabs(tabs *pango.TabArray) {
	var _arg0 *C.GtkText
	var _arg1 *C.PangoTabArray

	_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.PangoTabArray)(unsafe.Pointer(tabs.Native()))

	C.gtk_text_set_tabs(_arg0, _arg1)
}

// SetTruncateMultiline sets whether the `GtkText` should truncate
// multi-line text that is pasted into the widget.
func (s text) SetTruncateMultiline(truncateMultiline bool) {
	var _arg0 *C.GtkText
	var _arg1 C.gboolean

	_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))
	if truncateMultiline {
		_arg1 = C.gboolean(1)
	}

	C.gtk_text_set_truncate_multiline(_arg0, _arg1)
}

// SetVisibility sets whether the contents of the `GtkText` are visible or
// not.
//
// When visibility is set to false, characters are displayed as the
// invisible char, and will also appear that way when the text in the widget
// is copied to the clipboard.
//
// By default, GTK picks the best invisible character available in the
// current font, but it can be changed with
// [method@Gtk.Text.set_invisible_char].
//
// Note that you probably want to set [property@Gtk.Text:input-purpose] to
// GTK_INPUT_PURPOSE_PASSWORD or GTK_INPUT_PURPOSE_PIN to inform input
// methods about the purpose of this self, in addition to setting visibility
// to false.
func (s text) SetVisibility(visible bool) {
	var _arg0 *C.GtkText
	var _arg1 C.gboolean

	_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))
	if visible {
		_arg1 = C.gboolean(1)
	}

	C.gtk_text_set_visibility(_arg0, _arg1)
}

// UnsetInvisibleChar unsets the invisible char.
//
// After calling this, the default invisible char is used again.
func (s text) UnsetInvisibleChar() {
	var _arg0 *C.GtkText

	_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))

	C.gtk_text_unset_invisible_char(_arg0)
}

// TextTagTable: the collection of tags in a `GtkTextBuffer`
//
// You may wish to begin by reading the text widget conceptual overview
// (section-text-widget.html), which gives an overview of all the objects and
// data types related to the text widget and how they work together.
//
//
// GtkTextTagTables as GtkBuildable
//
// The `GtkTextTagTable` implementation of the `GtkBuildable` interface supports
// adding tags by specifying “tag” as the “type” attribute of a <child> element.
//
// An example of a UI definition fragment specifying tags: “`xml <object
// class="GtkTextTagTable"> <child type="tag"> <object class="GtkTextTag"/>
// </child> </object> “`
type TextTagTable interface {
	gextras.Objector
	Buildable

	// Add: add a tag to the table.
	//
	// The tag is assigned the highest priority in the table.
	//
	// @tag must not be in a tag table already, and may not have the same name
	// as an already-added tag.
	Add(tag TextTag) bool
	// Foreach calls @func on each tag in @table, with user data @data.
	//
	// Note that the table may not be modified while iterating over it (you
	// can’t add/remove tags).
	Foreach(fn TextTagTableForeach)
	// Size returns the size of the table (number of tags)
	Size() int
	// Remove: remove a tag from the table.
	//
	// If a `GtkTextBuffer` has @table as its tag table, the tag is removed from
	// the buffer. The table’s reference to the tag is removed, so the tag will
	// end up destroyed if you don’t have a reference to it.
	Remove(tag TextTag)
}

// textTagTable implements the TextTagTable interface.
type textTagTable struct {
	gextras.Objector
	Buildable
}

var _ TextTagTable = (*textTagTable)(nil)

// WrapTextTagTable wraps a GObject to the right type. It is
// primarily used internally.
func WrapTextTagTable(obj *externglib.Object) TextTagTable {
	return TextTagTable{
		Objector:  obj,
		Buildable: WrapBuildable(obj),
	}
}

func marshalTextTagTable(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTextTagTable(obj), nil
}

// Add: add a tag to the table.
//
// The tag is assigned the highest priority in the table.
//
// @tag must not be in a tag table already, and may not have the same name
// as an already-added tag.
func (t textTagTable) Add(tag TextTag) bool {
	var _arg0 *C.GtkTextTagTable
	var _arg1 *C.GtkTextTag

	_arg0 = (*C.GtkTextTagTable)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTextTag)(unsafe.Pointer(tag.Native()))

	var _cret C.gboolean

	_cret = C.gtk_text_tag_table_add(_arg0, _arg1)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// Foreach calls @func on each tag in @table, with user data @data.
//
// Note that the table may not be modified while iterating over it (you
// can’t add/remove tags).
func (t textTagTable) Foreach(fn TextTagTableForeach) {
	var _arg0 *C.GtkTextTagTable
	var _arg1 C.GtkTextTagTableForeach
	var _arg2 C.gpointer

	_arg0 = (*C.GtkTextTagTable)(unsafe.Pointer(t.Native()))
	_arg1 = (*[0]byte)(C.gotk4_TextTagTableForeach)
	_arg2 = C.gpointer(box.Assign(fn))

	C.gtk_text_tag_table_foreach(_arg0, _arg1, _arg2)
}

// Size returns the size of the table (number of tags)
func (t textTagTable) Size() int {
	var _arg0 *C.GtkTextTagTable

	_arg0 = (*C.GtkTextTagTable)(unsafe.Pointer(t.Native()))

	var _cret C.int

	_cret = C.gtk_text_tag_table_get_size(_arg0)

	var _gint int

	_gint = (int)(_cret)

	return _gint
}

// Remove: remove a tag from the table.
//
// If a `GtkTextBuffer` has @table as its tag table, the tag is removed from
// the buffer. The table’s reference to the tag is removed, so the tag will
// end up destroyed if you don’t have a reference to it.
func (t textTagTable) Remove(tag TextTag) {
	var _arg0 *C.GtkTextTagTable
	var _arg1 *C.GtkTextTag

	_arg0 = (*C.GtkTextTagTable)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTextTag)(unsafe.Pointer(tag.Native()))

	C.gtk_text_tag_table_remove(_arg0, _arg1)
}

// Tooltip: `GtkTooltip` is an object representing a widget tooltip.
//
// Basic tooltips can be realized simply by using
// [method@Gtk.Widget.set_tooltip_text] or
// [method@Gtk.Widget.set_tooltip_markup] without any explicit tooltip object.
//
// When you need a tooltip with a little more fancy contents, like adding an
// image, or you want the tooltip to have different contents per `GtkTreeView`
// row or cell, you will have to do a little more work:
//
// - Set the [property@Gtk.Widget:has-tooltip] property to true. This will make
// GTK monitor the widget for motion and related events which are needed to
// determine when and where to show a tooltip.
//
// - Connect to the [signal@Gtk.Widget::query-tooltip] signal. This signal will
// be emitted when a tooltip is supposed to be shown. One of the arguments
// passed to the signal handler is a `GtkTooltip` object. This is the object
// that we are about to display as a tooltip, and can be manipulated in your
// callback using functions like [method@Gtk.Tooltip.set_icon]. There are
// functions for setting the tooltip’s markup, setting an image from a named
// icon, or even putting in a custom widget.
//
// - Return true from your ::query-tooltip handler. This causes the tooltip to
// be show. If you return false, it will not be shown.
type Tooltip interface {
	gextras.Objector

	// SetCustom replaces the widget packed into the tooltip with
	// @custom_widget. @custom_widget does not get destroyed when the tooltip
	// goes away. By default a box with a Image and Label is embedded in the
	// tooltip, which can be configured using gtk_tooltip_set_markup() and
	// gtk_tooltip_set_icon().
	SetCustom(customWidget Widget)
	// SetIcon sets the icon of the tooltip (which is in front of the text) to
	// be @paintable. If @paintable is nil, the image will be hidden.
	SetIcon(paintable gdk.Paintable)
	// SetIconFromGIcon sets the icon of the tooltip (which is in front of the
	// text) to be the icon indicated by @gicon with the size indicated by
	// @size. If @gicon is nil, the image will be hidden.
	SetIconFromGIcon(gicon gio.Icon)
	// SetIconFromIconName sets the icon of the tooltip (which is in front of
	// the text) to be the icon indicated by @icon_name with the size indicated
	// by @size. If @icon_name is nil, the image will be hidden.
	SetIconFromIconName(iconName string)
	// SetMarkup sets the text of the tooltip to be @markup.
	//
	// The string must be marked up with Pango markup. If @markup is nil, the
	// label will be hidden.
	SetMarkup(markup string)
	// SetText sets the text of the tooltip to be @text.
	//
	// If @text is nil, the label will be hidden. See also
	// [method@Gtk.Tooltip.set_markup].
	SetText(text string)
	// SetTipArea sets the area of the widget, where the contents of this
	// tooltip apply, to be @rect (in widget coordinates). This is especially
	// useful for properly setting tooltips on TreeView rows and cells,
	// IconViews, etc.
	//
	// For setting tooltips on TreeView, please refer to the convenience
	// functions for this: gtk_tree_view_set_tooltip_row() and
	// gtk_tree_view_set_tooltip_cell().
	SetTipArea(rect *gdk.Rectangle)
}

// tooltip implements the Tooltip interface.
type tooltip struct {
	gextras.Objector
}

var _ Tooltip = (*tooltip)(nil)

// WrapTooltip wraps a GObject to the right type. It is
// primarily used internally.
func WrapTooltip(obj *externglib.Object) Tooltip {
	return Tooltip{
		Objector: obj,
	}
}

func marshalTooltip(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTooltip(obj), nil
}

// SetCustom replaces the widget packed into the tooltip with
// @custom_widget. @custom_widget does not get destroyed when the tooltip
// goes away. By default a box with a Image and Label is embedded in the
// tooltip, which can be configured using gtk_tooltip_set_markup() and
// gtk_tooltip_set_icon().
func (t tooltip) SetCustom(customWidget Widget) {
	var _arg0 *C.GtkTooltip
	var _arg1 *C.GtkWidget

	_arg0 = (*C.GtkTooltip)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(customWidget.Native()))

	C.gtk_tooltip_set_custom(_arg0, _arg1)
}

// SetIcon sets the icon of the tooltip (which is in front of the text) to
// be @paintable. If @paintable is nil, the image will be hidden.
func (t tooltip) SetIcon(paintable gdk.Paintable) {
	var _arg0 *C.GtkTooltip
	var _arg1 *C.GdkPaintable

	_arg0 = (*C.GtkTooltip)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GdkPaintable)(unsafe.Pointer(paintable.Native()))

	C.gtk_tooltip_set_icon(_arg0, _arg1)
}

// SetIconFromGIcon sets the icon of the tooltip (which is in front of the
// text) to be the icon indicated by @gicon with the size indicated by
// @size. If @gicon is nil, the image will be hidden.
func (t tooltip) SetIconFromGIcon(gicon gio.Icon) {
	var _arg0 *C.GtkTooltip
	var _arg1 *C.GIcon

	_arg0 = (*C.GtkTooltip)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GIcon)(unsafe.Pointer(gicon.Native()))

	C.gtk_tooltip_set_icon_from_gicon(_arg0, _arg1)
}

// SetIconFromIconName sets the icon of the tooltip (which is in front of
// the text) to be the icon indicated by @icon_name with the size indicated
// by @size. If @icon_name is nil, the image will be hidden.
func (t tooltip) SetIconFromIconName(iconName string) {
	var _arg0 *C.GtkTooltip
	var _arg1 *C.char

	_arg0 = (*C.GtkTooltip)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.char)(C.CString(iconName))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_tooltip_set_icon_from_icon_name(_arg0, _arg1)
}

// SetMarkup sets the text of the tooltip to be @markup.
//
// The string must be marked up with Pango markup. If @markup is nil, the
// label will be hidden.
func (t tooltip) SetMarkup(markup string) {
	var _arg0 *C.GtkTooltip
	var _arg1 *C.char

	_arg0 = (*C.GtkTooltip)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.char)(C.CString(markup))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_tooltip_set_markup(_arg0, _arg1)
}

// SetText sets the text of the tooltip to be @text.
//
// If @text is nil, the label will be hidden. See also
// [method@Gtk.Tooltip.set_markup].
func (t tooltip) SetText(text string) {
	var _arg0 *C.GtkTooltip
	var _arg1 *C.char

	_arg0 = (*C.GtkTooltip)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.char)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_tooltip_set_text(_arg0, _arg1)
}

// SetTipArea sets the area of the widget, where the contents of this
// tooltip apply, to be @rect (in widget coordinates). This is especially
// useful for properly setting tooltips on TreeView rows and cells,
// IconViews, etc.
//
// For setting tooltips on TreeView, please refer to the convenience
// functions for this: gtk_tree_view_set_tooltip_row() and
// gtk_tree_view_set_tooltip_cell().
func (t tooltip) SetTipArea(rect *gdk.Rectangle) {
	var _arg0 *C.GtkTooltip
	var _arg1 *C.GdkRectangle

	_arg0 = (*C.GtkTooltip)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GdkRectangle)(unsafe.Pointer(rect.Native()))

	C.gtk_tooltip_set_tip_area(_arg0, _arg1)
}

// TreeSelection: the selection object for GtkTreeView
//
// The TreeSelection object is a helper object to manage the selection for a
// TreeView widget. The TreeSelection object is automatically created when a new
// TreeView widget is created, and cannot exist independently of this widget.
// The primary reason the TreeSelection objects exists is for cleanliness of
// code and API. That is, there is no conceptual reason all these functions
// could not be methods on the TreeView widget instead of a separate function.
//
// The TreeSelection object is gotten from a TreeView by calling
// gtk_tree_view_get_selection(). It can be manipulated to check the selection
// status of the tree, as well as select and deselect individual rows. Selection
// is done completely view side. As a result, multiple views of the same model
// can have completely different selections. Additionally, you cannot change the
// selection of a row on the model that is not currently displayed by the view
// without expanding its parents first.
//
// One of the important things to remember when monitoring the selection of a
// view is that the TreeSelection::changed signal is mostly a hint. That is, it
// may only emit one signal when a range of rows is selected. Additionally, it
// may on occasion emit a TreeSelection::changed signal when nothing has
// happened (mostly as a result of programmers calling select_row on an already
// selected row).
type TreeSelection interface {
	gextras.Objector

	// CountSelectedRows returns the number of rows that have been selected in
	// @tree.
	CountSelectedRows() int
	// UserData returns the user data for the selection function.
	UserData() interface{}
	// IterIsSelected returns true if the row at @iter is currently selected.
	IterIsSelected(iter *TreeIter) bool
	// PathIsSelected returns true if the row pointed to by @path is currently
	// selected. If @path does not point to a valid location, false is returned
	PathIsSelected(path *TreePath) bool
	// SelectAll selects all the nodes. @selection must be set to
	// K_SELECTION_MULTIPLE mode.
	SelectAll()
	// SelectIter selects the specified iterator.
	SelectIter(iter *TreeIter)
	// SelectPath: select the row at @path.
	SelectPath(path *TreePath)
	// SelectRange selects a range of nodes, determined by @start_path and
	// @end_path inclusive. @selection must be set to K_SELECTION_MULTIPLE mode.
	SelectRange(startPath *TreePath, endPath *TreePath)
	// SelectedForeach calls a function for each selected node. Note that you
	// cannot modify the tree or selection from within this function. As a
	// result, gtk_tree_selection_get_selected_rows() might be more useful.
	SelectedForeach(fn TreeSelectionForeachFunc)
	// SetMode sets the selection mode of the @selection. If the previous type
	// was K_SELECTION_MULTIPLE, then the anchor is kept selected, if it was
	// previously selected.
	SetMode(typ SelectionMode)
	// UnselectAll unselects all the nodes.
	UnselectAll()
	// UnselectIter unselects the specified iterator.
	UnselectIter(iter *TreeIter)
	// UnselectPath unselects the row at @path.
	UnselectPath(path *TreePath)
	// UnselectRange unselects a range of nodes, determined by @start_path and
	// @end_path inclusive.
	UnselectRange(startPath *TreePath, endPath *TreePath)
}

// treeSelection implements the TreeSelection interface.
type treeSelection struct {
	gextras.Objector
}

var _ TreeSelection = (*treeSelection)(nil)

// WrapTreeSelection wraps a GObject to the right type. It is
// primarily used internally.
func WrapTreeSelection(obj *externglib.Object) TreeSelection {
	return TreeSelection{
		Objector: obj,
	}
}

func marshalTreeSelection(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTreeSelection(obj), nil
}

// CountSelectedRows returns the number of rows that have been selected in
// @tree.
func (s treeSelection) CountSelectedRows() int {
	var _arg0 *C.GtkTreeSelection

	_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))

	var _cret C.int

	_cret = C.gtk_tree_selection_count_selected_rows(_arg0)

	var _gint int

	_gint = (int)(_cret)

	return _gint
}

// UserData returns the user data for the selection function.
func (s treeSelection) UserData() interface{} {
	var _arg0 *C.GtkTreeSelection

	_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))

	var _cret C.gpointer

	_cret = C.gtk_tree_selection_get_user_data(_arg0)

	var _gpointer interface{}

	_gpointer = (interface{})(_cret)

	return _gpointer
}

// IterIsSelected returns true if the row at @iter is currently selected.
func (s treeSelection) IterIsSelected(iter *TreeIter) bool {
	var _arg0 *C.GtkTreeSelection
	var _arg1 *C.GtkTreeIter

	_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

	var _cret C.gboolean

	_cret = C.gtk_tree_selection_iter_is_selected(_arg0, _arg1)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// PathIsSelected returns true if the row pointed to by @path is currently
// selected. If @path does not point to a valid location, false is returned
func (s treeSelection) PathIsSelected(path *TreePath) bool {
	var _arg0 *C.GtkTreeSelection
	var _arg1 *C.GtkTreePath

	_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	var _cret C.gboolean

	_cret = C.gtk_tree_selection_path_is_selected(_arg0, _arg1)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// SelectAll selects all the nodes. @selection must be set to
// K_SELECTION_MULTIPLE mode.
func (s treeSelection) SelectAll() {
	var _arg0 *C.GtkTreeSelection

	_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))

	C.gtk_tree_selection_select_all(_arg0)
}

// SelectIter selects the specified iterator.
func (s treeSelection) SelectIter(iter *TreeIter) {
	var _arg0 *C.GtkTreeSelection
	var _arg1 *C.GtkTreeIter

	_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

	C.gtk_tree_selection_select_iter(_arg0, _arg1)
}

// SelectPath: select the row at @path.
func (s treeSelection) SelectPath(path *TreePath) {
	var _arg0 *C.GtkTreeSelection
	var _arg1 *C.GtkTreePath

	_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	C.gtk_tree_selection_select_path(_arg0, _arg1)
}

// SelectRange selects a range of nodes, determined by @start_path and
// @end_path inclusive. @selection must be set to K_SELECTION_MULTIPLE mode.
func (s treeSelection) SelectRange(startPath *TreePath, endPath *TreePath) {
	var _arg0 *C.GtkTreeSelection
	var _arg1 *C.GtkTreePath
	var _arg2 *C.GtkTreePath

	_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(startPath.Native()))
	_arg2 = (*C.GtkTreePath)(unsafe.Pointer(endPath.Native()))

	C.gtk_tree_selection_select_range(_arg0, _arg1, _arg2)
}

// SelectedForeach calls a function for each selected node. Note that you
// cannot modify the tree or selection from within this function. As a
// result, gtk_tree_selection_get_selected_rows() might be more useful.
func (s treeSelection) SelectedForeach(fn TreeSelectionForeachFunc) {
	var _arg0 *C.GtkTreeSelection
	var _arg1 C.GtkTreeSelectionForeachFunc
	var _arg2 C.gpointer

	_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))
	_arg1 = (*[0]byte)(C.gotk4_TreeSelectionForeachFunc)
	_arg2 = C.gpointer(box.Assign(fn))

	C.gtk_tree_selection_selected_foreach(_arg0, _arg1, _arg2)
}

// SetMode sets the selection mode of the @selection. If the previous type
// was K_SELECTION_MULTIPLE, then the anchor is kept selected, if it was
// previously selected.
func (s treeSelection) SetMode(typ SelectionMode) {
	var _arg0 *C.GtkTreeSelection
	var _arg1 C.GtkSelectionMode

	_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GtkSelectionMode)(typ)

	C.gtk_tree_selection_set_mode(_arg0, _arg1)
}

// UnselectAll unselects all the nodes.
func (s treeSelection) UnselectAll() {
	var _arg0 *C.GtkTreeSelection

	_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))

	C.gtk_tree_selection_unselect_all(_arg0)
}

// UnselectIter unselects the specified iterator.
func (s treeSelection) UnselectIter(iter *TreeIter) {
	var _arg0 *C.GtkTreeSelection
	var _arg1 *C.GtkTreeIter

	_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

	C.gtk_tree_selection_unselect_iter(_arg0, _arg1)
}

// UnselectPath unselects the row at @path.
func (s treeSelection) UnselectPath(path *TreePath) {
	var _arg0 *C.GtkTreeSelection
	var _arg1 *C.GtkTreePath

	_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	C.gtk_tree_selection_unselect_path(_arg0, _arg1)
}

// UnselectRange unselects a range of nodes, determined by @start_path and
// @end_path inclusive.
func (s treeSelection) UnselectRange(startPath *TreePath, endPath *TreePath) {
	var _arg0 *C.GtkTreeSelection
	var _arg1 *C.GtkTreePath
	var _arg2 *C.GtkTreePath

	_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(startPath.Native()))
	_arg2 = (*C.GtkTreePath)(unsafe.Pointer(endPath.Native()))

	C.gtk_tree_selection_unselect_range(_arg0, _arg1, _arg2)
}

// TreeViewColumn: a visible column in a GtkTreeView widget
//
// The GtkTreeViewColumn object represents a visible column in a TreeView
// widget. It allows to set properties of the column header, and functions as a
// holding pen for the cell renderers which determine how the data in the column
// is displayed.
//
// Please refer to the [tree widget conceptual overview][TreeWidget] for an
// overview of all the objects and data types related to the tree widget and how
// they work together, and to the TreeView documentation for specifics about the
// CSS node structure for treeviews and their headers.
type TreeViewColumn interface {
	gextras.Objector
	Buildable
	CellLayout

	// AddAttribute adds an attribute mapping to the list in @tree_column. The
	// @column is the column of the model to get a value from, and the
	// @attribute is the parameter on @cell_renderer to be set from the value.
	// So for example if column 2 of the model contains strings, you could have
	// the “text” attribute of a CellRendererText get its values from column 2.
	AddAttribute(cellRenderer CellRenderer, attribute string, column int)
	// CellGetPosition obtains the horizontal position and size of a cell in a
	// column. If the cell is not found in the column, @start_pos and @width are
	// not changed and false is returned.
	CellGetPosition(cellRenderer CellRenderer) (xOffset int, width int, ok bool)
	// CellGetSize obtains the width and height needed to render the column.
	// This is used primarily by the TreeView.
	CellGetSize() (xOffset int, yOffset int, width int, height int)
	// CellIsVisible returns true if any of the cells packed into the
	// @tree_column are visible. For this to be meaningful, you must first
	// initialize the cells with gtk_tree_view_column_cell_set_cell_data()
	CellIsVisible() bool
	// CellSetCellData sets the cell renderer based on the @tree_model and
	// @iter. That is, for every attribute mapping in @tree_column, it will get
	// a value from the set column on the @iter, and use that value to set the
	// attribute on the cell renderer. This is used primarily by the TreeView.
	CellSetCellData(treeModel TreeModel, iter *TreeIter, isExpander bool, isExpanded bool)
	// Clear unsets all the mappings on all renderers on the @tree_column.
	Clear()
	// ClearAttributes clears all existing attributes previously set with
	// gtk_tree_view_column_set_attributes().
	ClearAttributes(cellRenderer CellRenderer)
	// Clicked emits the “clicked” signal on the column. This function will only
	// work if @tree_column is clickable.
	Clicked()
	// FocusCell sets the current keyboard focus to be at @cell, if the column
	// contains 2 or more editable and activatable cells.
	FocusCell(cell CellRenderer)
	// Alignment returns the current x alignment of @tree_column. This value can
	// range between 0.0 and 1.0.
	Alignment() float32
	// Clickable returns true if the user can click on the header for the
	// column.
	Clickable() bool
	// Expand returns true if the column expands to fill available space.
	Expand() bool
	// FixedWidth gets the fixed width of the column. This may not be the actual
	// displayed width of the column; for that, use
	// gtk_tree_view_column_get_width().
	FixedWidth() int
	// MaxWidth returns the maximum width in pixels of the @tree_column, or -1
	// if no maximum width is set.
	MaxWidth() int
	// MinWidth returns the minimum width in pixels of the @tree_column, or -1
	// if no minimum width is set.
	MinWidth() int
	// Reorderable returns true if the @tree_column can be reordered by the
	// user.
	Reorderable() bool
	// Resizable returns true if the @tree_column can be resized by the end
	// user.
	Resizable() bool
	// SortColumnID gets the logical @sort_column_id that the model sorts on
	// when this column is selected for sorting. See
	// gtk_tree_view_column_set_sort_column_id().
	SortColumnID() int
	// SortIndicator gets the value set by
	// gtk_tree_view_column_set_sort_indicator().
	SortIndicator() bool
	// Spacing returns the spacing of @tree_column.
	Spacing() int
	// Title returns the title of the widget.
	Title() string
	// Visible returns true if @tree_column is visible.
	Visible() bool
	// Width returns the current size of @tree_column in pixels.
	Width() int
	// XOffset returns the current X offset of @tree_column in pixels.
	XOffset() int
	// PackEnd adds the @cell to end of the column. If @expand is false, then
	// the @cell is allocated no more space than it needs. Any unused space is
	// divided evenly between cells for which @expand is true.
	PackEnd(cell CellRenderer, expand bool)
	// PackStart packs the @cell into the beginning of the column. If @expand is
	// false, then the @cell is allocated no more space than it needs. Any
	// unused space is divided evenly between cells for which @expand is true.
	PackStart(cell CellRenderer, expand bool)
	// QueueResize flags the column, and the cell renderers added to this
	// column, to have their sizes renegotiated.
	QueueResize()
	// SetAlignment sets the alignment of the title or custom widget inside the
	// column header. The alignment determines its location inside the button --
	// 0.0 for left, 0.5 for center, 1.0 for right.
	SetAlignment(xalign float32)
	// SetClickable sets the header to be active if @clickable is true. When the
	// header is active, then it can take keyboard focus, and can be clicked.
	SetClickable(clickable bool)
	// SetExpand sets the column to take available extra space. This space is
	// shared equally amongst all columns that have the expand set to true. If
	// no column has this option set, then the last column gets all extra space.
	// By default, every column is created with this false.
	//
	// Along with “fixed-width”, the “expand” property changes when the column
	// is resized by the user.
	SetExpand(expand bool)
	// SetFixedWidth: if @fixed_width is not -1, sets the fixed width of
	// @tree_column; otherwise unsets it. The effective value of @fixed_width is
	// clamped between the minimum and maximum width of the column; however, the
	// value stored in the “fixed-width” property is not clamped. If the column
	// sizing is K_TREE_VIEW_COLUMN_GROW_ONLY or K_TREE_VIEW_COLUMN_AUTOSIZE,
	// setting a fixed width overrides the automatically calculated width. Note
	// that @fixed_width is only a hint to GTK; the width actually allocated to
	// the column may be greater or less than requested.
	//
	// Along with “expand”, the “fixed-width” property changes when the column
	// is resized by the user.
	SetFixedWidth(fixedWidth int)
	// SetMaxWidth sets the maximum width of the @tree_column. If @max_width is
	// -1, then the maximum width is unset. Note, the column can actually be
	// wider than max width if it’s the last column in a view. In this case, the
	// column expands to fill any extra space.
	SetMaxWidth(maxWidth int)
	// SetMinWidth sets the minimum width of the @tree_column. If @min_width is
	// -1, then the minimum width is unset.
	SetMinWidth(minWidth int)
	// SetReorderable: if @reorderable is true, then the column can be reordered
	// by the end user dragging the header.
	SetReorderable(reorderable bool)
	// SetResizable: if @resizable is true, then the user can explicitly resize
	// the column by grabbing the outer edge of the column button. If resizable
	// is true and sizing mode of the column is K_TREE_VIEW_COLUMN_AUTOSIZE,
	// then the sizing mode is changed to K_TREE_VIEW_COLUMN_GROW_ONLY.
	SetResizable(resizable bool)
	// SetSizing sets the growth behavior of @tree_column to @type.
	SetSizing(typ TreeViewColumnSizing)
	// SetSortColumnID sets the logical @sort_column_id that this column sorts
	// on when this column is selected for sorting. Doing so makes the column
	// header clickable.
	SetSortColumnID(sortColumnId int)
	// SetSortIndicator: call this function with a @setting of true to display
	// an arrow in the header button indicating the column is sorted. Call
	// gtk_tree_view_column_set_sort_order() to change the direction of the
	// arrow.
	SetSortIndicator(setting bool)
	// SetSortOrder changes the appearance of the sort indicator.
	//
	// This does not actually sort the model. Use
	// gtk_tree_view_column_set_sort_column_id() if you want automatic sorting
	// support. This function is primarily for custom sorting behavior, and
	// should be used in conjunction with gtk_tree_sortable_set_sort_column_id()
	// to do that. For custom models, the mechanism will vary.
	//
	// The sort indicator changes direction to indicate normal sort or reverse
	// sort. Note that you must have the sort indicator enabled to see anything
	// when calling this function; see
	// gtk_tree_view_column_set_sort_indicator().
	SetSortOrder(order SortType)
	// SetSpacing sets the spacing field of @tree_column, which is the number of
	// pixels to place between cell renderers packed into it.
	SetSpacing(spacing int)
	// SetTitle sets the title of the @tree_column. If a custom widget has been
	// set, then this value is ignored.
	SetTitle(title string)
	// SetVisible sets the visibility of @tree_column.
	SetVisible(visible bool)
	// SetWidget sets the widget in the header to be @widget. If widget is nil,
	// then the header button is set with a Label set to the title of
	// @tree_column.
	SetWidget(widget Widget)
}

// treeViewColumn implements the TreeViewColumn interface.
type treeViewColumn struct {
	gextras.Objector
	Buildable
	CellLayout
}

var _ TreeViewColumn = (*treeViewColumn)(nil)

// WrapTreeViewColumn wraps a GObject to the right type. It is
// primarily used internally.
func WrapTreeViewColumn(obj *externglib.Object) TreeViewColumn {
	return TreeViewColumn{
		Objector:   obj,
		Buildable:  WrapBuildable(obj),
		CellLayout: WrapCellLayout(obj),
	}
}

func marshalTreeViewColumn(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTreeViewColumn(obj), nil
}

// AddAttribute adds an attribute mapping to the list in @tree_column. The
// @column is the column of the model to get a value from, and the
// @attribute is the parameter on @cell_renderer to be set from the value.
// So for example if column 2 of the model contains strings, you could have
// the “text” attribute of a CellRendererText get its values from column 2.
func (t treeViewColumn) AddAttribute(cellRenderer CellRenderer, attribute string, column int) {
	var _arg0 *C.GtkTreeViewColumn
	var _arg1 *C.GtkCellRenderer
	var _arg2 *C.char
	var _arg3 C.int

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(cellRenderer.Native()))
	_arg2 = (*C.char)(C.CString(attribute))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = C.int(column)

	C.gtk_tree_view_column_add_attribute(_arg0, _arg1, _arg2, _arg3)
}

// CellGetPosition obtains the horizontal position and size of a cell in a
// column. If the cell is not found in the column, @start_pos and @width are
// not changed and false is returned.
func (t treeViewColumn) CellGetPosition(cellRenderer CellRenderer) (xOffset int, width int, ok bool) {
	var _arg0 *C.GtkTreeViewColumn
	var _arg1 *C.GtkCellRenderer

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(cellRenderer.Native()))

	var _arg2 C.int
	var _arg3 C.int
	var _cret C.gboolean

	_cret = C.gtk_tree_view_column_cell_get_position(_arg0, _arg1, &_arg2, &_arg3)

	var _xOffset int
	var _width int
	var _ok bool

	_xOffset = (int)(_arg2)
	_width = (int)(_arg3)
	if _cret {
		_ok = true
	}

	return _xOffset, _width, _ok
}

// CellGetSize obtains the width and height needed to render the column.
// This is used primarily by the TreeView.
func (t treeViewColumn) CellGetSize() (xOffset int, yOffset int, width int, height int) {
	var _arg0 *C.GtkTreeViewColumn

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	var _arg1 C.int
	var _arg2 C.int
	var _arg3 C.int
	var _arg4 C.int

	C.gtk_tree_view_column_cell_get_size(_arg0, &_arg1, &_arg2, &_arg3, &_arg4)

	var _xOffset int
	var _yOffset int
	var _width int
	var _height int

	_xOffset = (int)(_arg1)
	_yOffset = (int)(_arg2)
	_width = (int)(_arg3)
	_height = (int)(_arg4)

	return _xOffset, _yOffset, _width, _height
}

// CellIsVisible returns true if any of the cells packed into the
// @tree_column are visible. For this to be meaningful, you must first
// initialize the cells with gtk_tree_view_column_cell_set_cell_data()
func (t treeViewColumn) CellIsVisible() bool {
	var _arg0 *C.GtkTreeViewColumn

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	var _cret C.gboolean

	_cret = C.gtk_tree_view_column_cell_is_visible(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// CellSetCellData sets the cell renderer based on the @tree_model and
// @iter. That is, for every attribute mapping in @tree_column, it will get
// a value from the set column on the @iter, and use that value to set the
// attribute on the cell renderer. This is used primarily by the TreeView.
func (t treeViewColumn) CellSetCellData(treeModel TreeModel, iter *TreeIter, isExpander bool, isExpanded bool) {
	var _arg0 *C.GtkTreeViewColumn
	var _arg1 *C.GtkTreeModel
	var _arg2 *C.GtkTreeIter
	var _arg3 C.gboolean
	var _arg4 C.gboolean

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreeModel)(unsafe.Pointer(treeModel.Native()))
	_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))
	if isExpander {
		_arg3 = C.gboolean(1)
	}
	if isExpanded {
		_arg4 = C.gboolean(1)
	}

	C.gtk_tree_view_column_cell_set_cell_data(_arg0, _arg1, _arg2, _arg3, _arg4)
}

// Clear unsets all the mappings on all renderers on the @tree_column.
func (t treeViewColumn) Clear() {
	var _arg0 *C.GtkTreeViewColumn

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	C.gtk_tree_view_column_clear(_arg0)
}

// ClearAttributes clears all existing attributes previously set with
// gtk_tree_view_column_set_attributes().
func (t treeViewColumn) ClearAttributes(cellRenderer CellRenderer) {
	var _arg0 *C.GtkTreeViewColumn
	var _arg1 *C.GtkCellRenderer

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(cellRenderer.Native()))

	C.gtk_tree_view_column_clear_attributes(_arg0, _arg1)
}

// Clicked emits the “clicked” signal on the column. This function will only
// work if @tree_column is clickable.
func (t treeViewColumn) Clicked() {
	var _arg0 *C.GtkTreeViewColumn

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	C.gtk_tree_view_column_clicked(_arg0)
}

// FocusCell sets the current keyboard focus to be at @cell, if the column
// contains 2 or more editable and activatable cells.
func (t treeViewColumn) FocusCell(cell CellRenderer) {
	var _arg0 *C.GtkTreeViewColumn
	var _arg1 *C.GtkCellRenderer

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(cell.Native()))

	C.gtk_tree_view_column_focus_cell(_arg0, _arg1)
}

// Alignment returns the current x alignment of @tree_column. This value can
// range between 0.0 and 1.0.
func (t treeViewColumn) Alignment() float32 {
	var _arg0 *C.GtkTreeViewColumn

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	var _cret C.float

	_cret = C.gtk_tree_view_column_get_alignment(_arg0)

	var _gfloat float32

	_gfloat = (float32)(_cret)

	return _gfloat
}

// Clickable returns true if the user can click on the header for the
// column.
func (t treeViewColumn) Clickable() bool {
	var _arg0 *C.GtkTreeViewColumn

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	var _cret C.gboolean

	_cret = C.gtk_tree_view_column_get_clickable(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// Expand returns true if the column expands to fill available space.
func (t treeViewColumn) Expand() bool {
	var _arg0 *C.GtkTreeViewColumn

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	var _cret C.gboolean

	_cret = C.gtk_tree_view_column_get_expand(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// FixedWidth gets the fixed width of the column. This may not be the actual
// displayed width of the column; for that, use
// gtk_tree_view_column_get_width().
func (t treeViewColumn) FixedWidth() int {
	var _arg0 *C.GtkTreeViewColumn

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	var _cret C.int

	_cret = C.gtk_tree_view_column_get_fixed_width(_arg0)

	var _gint int

	_gint = (int)(_cret)

	return _gint
}

// MaxWidth returns the maximum width in pixels of the @tree_column, or -1
// if no maximum width is set.
func (t treeViewColumn) MaxWidth() int {
	var _arg0 *C.GtkTreeViewColumn

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	var _cret C.int

	_cret = C.gtk_tree_view_column_get_max_width(_arg0)

	var _gint int

	_gint = (int)(_cret)

	return _gint
}

// MinWidth returns the minimum width in pixels of the @tree_column, or -1
// if no minimum width is set.
func (t treeViewColumn) MinWidth() int {
	var _arg0 *C.GtkTreeViewColumn

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	var _cret C.int

	_cret = C.gtk_tree_view_column_get_min_width(_arg0)

	var _gint int

	_gint = (int)(_cret)

	return _gint
}

// Reorderable returns true if the @tree_column can be reordered by the
// user.
func (t treeViewColumn) Reorderable() bool {
	var _arg0 *C.GtkTreeViewColumn

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	var _cret C.gboolean

	_cret = C.gtk_tree_view_column_get_reorderable(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// Resizable returns true if the @tree_column can be resized by the end
// user.
func (t treeViewColumn) Resizable() bool {
	var _arg0 *C.GtkTreeViewColumn

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	var _cret C.gboolean

	_cret = C.gtk_tree_view_column_get_resizable(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// SortColumnID gets the logical @sort_column_id that the model sorts on
// when this column is selected for sorting. See
// gtk_tree_view_column_set_sort_column_id().
func (t treeViewColumn) SortColumnID() int {
	var _arg0 *C.GtkTreeViewColumn

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	var _cret C.int

	_cret = C.gtk_tree_view_column_get_sort_column_id(_arg0)

	var _gint int

	_gint = (int)(_cret)

	return _gint
}

// SortIndicator gets the value set by
// gtk_tree_view_column_set_sort_indicator().
func (t treeViewColumn) SortIndicator() bool {
	var _arg0 *C.GtkTreeViewColumn

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	var _cret C.gboolean

	_cret = C.gtk_tree_view_column_get_sort_indicator(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// Spacing returns the spacing of @tree_column.
func (t treeViewColumn) Spacing() int {
	var _arg0 *C.GtkTreeViewColumn

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	var _cret C.int

	_cret = C.gtk_tree_view_column_get_spacing(_arg0)

	var _gint int

	_gint = (int)(_cret)

	return _gint
}

// Title returns the title of the widget.
func (t treeViewColumn) Title() string {
	var _arg0 *C.GtkTreeViewColumn

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	var _cret *C.char

	_cret = C.gtk_tree_view_column_get_title(_arg0)

	var _utf8 string

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Visible returns true if @tree_column is visible.
func (t treeViewColumn) Visible() bool {
	var _arg0 *C.GtkTreeViewColumn

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	var _cret C.gboolean

	_cret = C.gtk_tree_view_column_get_visible(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// Width returns the current size of @tree_column in pixels.
func (t treeViewColumn) Width() int {
	var _arg0 *C.GtkTreeViewColumn

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	var _cret C.int

	_cret = C.gtk_tree_view_column_get_width(_arg0)

	var _gint int

	_gint = (int)(_cret)

	return _gint
}

// XOffset returns the current X offset of @tree_column in pixels.
func (t treeViewColumn) XOffset() int {
	var _arg0 *C.GtkTreeViewColumn

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	var _cret C.int

	_cret = C.gtk_tree_view_column_get_x_offset(_arg0)

	var _gint int

	_gint = (int)(_cret)

	return _gint
}

// PackEnd adds the @cell to end of the column. If @expand is false, then
// the @cell is allocated no more space than it needs. Any unused space is
// divided evenly between cells for which @expand is true.
func (t treeViewColumn) PackEnd(cell CellRenderer, expand bool) {
	var _arg0 *C.GtkTreeViewColumn
	var _arg1 *C.GtkCellRenderer
	var _arg2 C.gboolean

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(cell.Native()))
	if expand {
		_arg2 = C.gboolean(1)
	}

	C.gtk_tree_view_column_pack_end(_arg0, _arg1, _arg2)
}

// PackStart packs the @cell into the beginning of the column. If @expand is
// false, then the @cell is allocated no more space than it needs. Any
// unused space is divided evenly between cells for which @expand is true.
func (t treeViewColumn) PackStart(cell CellRenderer, expand bool) {
	var _arg0 *C.GtkTreeViewColumn
	var _arg1 *C.GtkCellRenderer
	var _arg2 C.gboolean

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(cell.Native()))
	if expand {
		_arg2 = C.gboolean(1)
	}

	C.gtk_tree_view_column_pack_start(_arg0, _arg1, _arg2)
}

// QueueResize flags the column, and the cell renderers added to this
// column, to have their sizes renegotiated.
func (t treeViewColumn) QueueResize() {
	var _arg0 *C.GtkTreeViewColumn

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	C.gtk_tree_view_column_queue_resize(_arg0)
}

// SetAlignment sets the alignment of the title or custom widget inside the
// column header. The alignment determines its location inside the button --
// 0.0 for left, 0.5 for center, 1.0 for right.
func (t treeViewColumn) SetAlignment(xalign float32) {
	var _arg0 *C.GtkTreeViewColumn
	var _arg1 C.float

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	_arg1 = C.float(xalign)

	C.gtk_tree_view_column_set_alignment(_arg0, _arg1)
}

// SetClickable sets the header to be active if @clickable is true. When the
// header is active, then it can take keyboard focus, and can be clicked.
func (t treeViewColumn) SetClickable(clickable bool) {
	var _arg0 *C.GtkTreeViewColumn
	var _arg1 C.gboolean

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	if clickable {
		_arg1 = C.gboolean(1)
	}

	C.gtk_tree_view_column_set_clickable(_arg0, _arg1)
}

// SetExpand sets the column to take available extra space. This space is
// shared equally amongst all columns that have the expand set to true. If
// no column has this option set, then the last column gets all extra space.
// By default, every column is created with this false.
//
// Along with “fixed-width”, the “expand” property changes when the column
// is resized by the user.
func (t treeViewColumn) SetExpand(expand bool) {
	var _arg0 *C.GtkTreeViewColumn
	var _arg1 C.gboolean

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	if expand {
		_arg1 = C.gboolean(1)
	}

	C.gtk_tree_view_column_set_expand(_arg0, _arg1)
}

// SetFixedWidth: if @fixed_width is not -1, sets the fixed width of
// @tree_column; otherwise unsets it. The effective value of @fixed_width is
// clamped between the minimum and maximum width of the column; however, the
// value stored in the “fixed-width” property is not clamped. If the column
// sizing is K_TREE_VIEW_COLUMN_GROW_ONLY or K_TREE_VIEW_COLUMN_AUTOSIZE,
// setting a fixed width overrides the automatically calculated width. Note
// that @fixed_width is only a hint to GTK; the width actually allocated to
// the column may be greater or less than requested.
//
// Along with “expand”, the “fixed-width” property changes when the column
// is resized by the user.
func (t treeViewColumn) SetFixedWidth(fixedWidth int) {
	var _arg0 *C.GtkTreeViewColumn
	var _arg1 C.int

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	_arg1 = C.int(fixedWidth)

	C.gtk_tree_view_column_set_fixed_width(_arg0, _arg1)
}

// SetMaxWidth sets the maximum width of the @tree_column. If @max_width is
// -1, then the maximum width is unset. Note, the column can actually be
// wider than max width if it’s the last column in a view. In this case, the
// column expands to fill any extra space.
func (t treeViewColumn) SetMaxWidth(maxWidth int) {
	var _arg0 *C.GtkTreeViewColumn
	var _arg1 C.int

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	_arg1 = C.int(maxWidth)

	C.gtk_tree_view_column_set_max_width(_arg0, _arg1)
}

// SetMinWidth sets the minimum width of the @tree_column. If @min_width is
// -1, then the minimum width is unset.
func (t treeViewColumn) SetMinWidth(minWidth int) {
	var _arg0 *C.GtkTreeViewColumn
	var _arg1 C.int

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	_arg1 = C.int(minWidth)

	C.gtk_tree_view_column_set_min_width(_arg0, _arg1)
}

// SetReorderable: if @reorderable is true, then the column can be reordered
// by the end user dragging the header.
func (t treeViewColumn) SetReorderable(reorderable bool) {
	var _arg0 *C.GtkTreeViewColumn
	var _arg1 C.gboolean

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	if reorderable {
		_arg1 = C.gboolean(1)
	}

	C.gtk_tree_view_column_set_reorderable(_arg0, _arg1)
}

// SetResizable: if @resizable is true, then the user can explicitly resize
// the column by grabbing the outer edge of the column button. If resizable
// is true and sizing mode of the column is K_TREE_VIEW_COLUMN_AUTOSIZE,
// then the sizing mode is changed to K_TREE_VIEW_COLUMN_GROW_ONLY.
func (t treeViewColumn) SetResizable(resizable bool) {
	var _arg0 *C.GtkTreeViewColumn
	var _arg1 C.gboolean

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	if resizable {
		_arg1 = C.gboolean(1)
	}

	C.gtk_tree_view_column_set_resizable(_arg0, _arg1)
}

// SetSizing sets the growth behavior of @tree_column to @type.
func (t treeViewColumn) SetSizing(typ TreeViewColumnSizing) {
	var _arg0 *C.GtkTreeViewColumn
	var _arg1 C.GtkTreeViewColumnSizing

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	_arg1 = (C.GtkTreeViewColumnSizing)(typ)

	C.gtk_tree_view_column_set_sizing(_arg0, _arg1)
}

// SetSortColumnID sets the logical @sort_column_id that this column sorts
// on when this column is selected for sorting. Doing so makes the column
// header clickable.
func (t treeViewColumn) SetSortColumnID(sortColumnId int) {
	var _arg0 *C.GtkTreeViewColumn
	var _arg1 C.int

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	_arg1 = C.int(sortColumnId)

	C.gtk_tree_view_column_set_sort_column_id(_arg0, _arg1)
}

// SetSortIndicator: call this function with a @setting of true to display
// an arrow in the header button indicating the column is sorted. Call
// gtk_tree_view_column_set_sort_order() to change the direction of the
// arrow.
func (t treeViewColumn) SetSortIndicator(setting bool) {
	var _arg0 *C.GtkTreeViewColumn
	var _arg1 C.gboolean

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	if setting {
		_arg1 = C.gboolean(1)
	}

	C.gtk_tree_view_column_set_sort_indicator(_arg0, _arg1)
}

// SetSortOrder changes the appearance of the sort indicator.
//
// This does not actually sort the model. Use
// gtk_tree_view_column_set_sort_column_id() if you want automatic sorting
// support. This function is primarily for custom sorting behavior, and
// should be used in conjunction with gtk_tree_sortable_set_sort_column_id()
// to do that. For custom models, the mechanism will vary.
//
// The sort indicator changes direction to indicate normal sort or reverse
// sort. Note that you must have the sort indicator enabled to see anything
// when calling this function; see
// gtk_tree_view_column_set_sort_indicator().
func (t treeViewColumn) SetSortOrder(order SortType) {
	var _arg0 *C.GtkTreeViewColumn
	var _arg1 C.GtkSortType

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	_arg1 = (C.GtkSortType)(order)

	C.gtk_tree_view_column_set_sort_order(_arg0, _arg1)
}

// SetSpacing sets the spacing field of @tree_column, which is the number of
// pixels to place between cell renderers packed into it.
func (t treeViewColumn) SetSpacing(spacing int) {
	var _arg0 *C.GtkTreeViewColumn
	var _arg1 C.int

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	_arg1 = C.int(spacing)

	C.gtk_tree_view_column_set_spacing(_arg0, _arg1)
}

// SetTitle sets the title of the @tree_column. If a custom widget has been
// set, then this value is ignored.
func (t treeViewColumn) SetTitle(title string) {
	var _arg0 *C.GtkTreeViewColumn
	var _arg1 *C.char

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.char)(C.CString(title))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_tree_view_column_set_title(_arg0, _arg1)
}

// SetVisible sets the visibility of @tree_column.
func (t treeViewColumn) SetVisible(visible bool) {
	var _arg0 *C.GtkTreeViewColumn
	var _arg1 C.gboolean

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	if visible {
		_arg1 = C.gboolean(1)
	}

	C.gtk_tree_view_column_set_visible(_arg0, _arg1)
}

// SetWidget sets the widget in the header to be @widget. If widget is nil,
// then the header button is set with a Label set to the title of
// @tree_column.
func (t treeViewColumn) SetWidget(widget Widget) {
	var _arg0 *C.GtkTreeViewColumn
	var _arg1 *C.GtkWidget

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	C.gtk_tree_view_column_set_widget(_arg0, _arg1)
}

// Viewport: `GtkViewport` implements scrollability for widgets that lack their
// own scrolling capabilities.
//
// Use `GtkViewport` to scroll child widgets such as `GtkGrid`, `GtkBox`, and so
// on.
//
// The `GtkViewport` will start scrolling content only if allocated less than
// the child widget’s minimum size in a given orientation.
//
//
// CSS nodes
//
// `GtkViewport` has a single CSS node with name `viewport`.
//
//
// Accessibility
//
// `GtkViewport` uses the GTK_ACCESSIBLE_ROLE_GROUP role.
type Viewport interface {
	Widget
	Accessible
	Buildable
	ConstraintTarget
	Scrollable

	// ScrollToFocus gets whether the viewport is scrolling to keep the focused
	// child in view.
	ScrollToFocus() bool
	// SetChild sets the child widget of @viewport.
	SetChild(child Widget)
	// SetScrollToFocus sets whether the viewport should automatically scroll to
	// keep the focused child in view.
	SetScrollToFocus(scrollToFocus bool)
}

// viewport implements the Viewport interface.
type viewport struct {
	Widget
	Accessible
	Buildable
	ConstraintTarget
	Scrollable
}

var _ Viewport = (*viewport)(nil)

// WrapViewport wraps a GObject to the right type. It is
// primarily used internally.
func WrapViewport(obj *externglib.Object) Viewport {
	return Viewport{
		Widget:           WrapWidget(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
		Scrollable:       WrapScrollable(obj),
	}
}

func marshalViewport(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapViewport(obj), nil
}

// ScrollToFocus gets whether the viewport is scrolling to keep the focused
// child in view.
func (v viewport) ScrollToFocus() bool {
	var _arg0 *C.GtkViewport

	_arg0 = (*C.GtkViewport)(unsafe.Pointer(v.Native()))

	var _cret C.gboolean

	_cret = C.gtk_viewport_get_scroll_to_focus(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// SetChild sets the child widget of @viewport.
func (v viewport) SetChild(child Widget) {
	var _arg0 *C.GtkViewport
	var _arg1 *C.GtkWidget

	_arg0 = (*C.GtkViewport)(unsafe.Pointer(v.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_viewport_set_child(_arg0, _arg1)
}

// SetScrollToFocus sets whether the viewport should automatically scroll to
// keep the focused child in view.
func (v viewport) SetScrollToFocus(scrollToFocus bool) {
	var _arg0 *C.GtkViewport
	var _arg1 C.gboolean

	_arg0 = (*C.GtkViewport)(unsafe.Pointer(v.Native()))
	if scrollToFocus {
		_arg1 = C.gboolean(1)
	}

	C.gtk_viewport_set_scroll_to_focus(_arg0, _arg1)
}

// VolumeButton: `GtkVolumeButton` is a `GtkScaleButton` subclass tailored for
// volume control.
//
// !An example GtkVolumeButton (volumebutton.png)
type VolumeButton interface {
	ScaleButton
	Accessible
	Buildable
	ConstraintTarget
	Orientable
}

// volumeButton implements the VolumeButton interface.
type volumeButton struct {
	ScaleButton
	Accessible
	Buildable
	ConstraintTarget
	Orientable
}

var _ VolumeButton = (*volumeButton)(nil)

// WrapVolumeButton wraps a GObject to the right type. It is
// primarily used internally.
func WrapVolumeButton(obj *externglib.Object) VolumeButton {
	return VolumeButton{
		ScaleButton:      WrapScaleButton(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
		Orientable:       WrapOrientable(obj),
	}
}

func marshalVolumeButton(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapVolumeButton(obj), nil
}
