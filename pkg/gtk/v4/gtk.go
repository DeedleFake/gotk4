// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"github.com/diamondburned/gotk4/pkg/gdk/v4"
	"github.com/diamondburned/gotk4/pkg/gobject/v2"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config:
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <gtk/gtk.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_accessible_autocomplete_get_type()), F: marshalAccessibleAutocomplete},
		{T: externglib.Type(C.gtk_accessible_invalid_state_get_type()), F: marshalAccessibleInvalidState},
		{T: externglib.Type(C.gtk_accessible_property_get_type()), F: marshalAccessibleProperty},
		{T: externglib.Type(C.gtk_accessible_relation_get_type()), F: marshalAccessibleRelation},
		{T: externglib.Type(C.gtk_accessible_role_get_type()), F: marshalAccessibleRole},
		{T: externglib.Type(C.gtk_accessible_sort_get_type()), F: marshalAccessibleSort},
		{T: externglib.Type(C.gtk_accessible_state_get_type()), F: marshalAccessibleState},
		{T: externglib.Type(C.gtk_accessible_tristate_get_type()), F: marshalAccessibleTristate},
		{T: externglib.Type(C.gtk_align_get_type()), F: marshalAlign},
		{T: externglib.Type(C.gtk_arrow_type_get_type()), F: marshalArrowType},
		{T: externglib.Type(C.gtk_assistant_page_type_get_type()), F: marshalAssistantPageType},
		{T: externglib.Type(C.gtk_baseline_position_get_type()), F: marshalBaselinePosition},
		{T: externglib.Type(C.gtk_border_style_get_type()), F: marshalBorderStyle},
		{T: externglib.Type(C.gtk_builder_error_get_type()), F: marshalBuilderError},
		{T: externglib.Type(C.gtk_buttons_type_get_type()), F: marshalButtonsType},
		{T: externglib.Type(C.gtk_cell_renderer_accel_mode_get_type()), F: marshalCellRendererAccelMode},
		{T: externglib.Type(C.gtk_cell_renderer_mode_get_type()), F: marshalCellRendererMode},
		{T: externglib.Type(C.gtk_constraint_attribute_get_type()), F: marshalConstraintAttribute},
		{T: externglib.Type(C.gtk_constraint_relation_get_type()), F: marshalConstraintRelation},
		{T: externglib.Type(C.gtk_constraint_strength_get_type()), F: marshalConstraintStrength},
		{T: externglib.Type(C.gtk_constraint_vfl_parser_error_get_type()), F: marshalConstraintVflParserError},
		{T: externglib.Type(C.gtk_corner_type_get_type()), F: marshalCornerType},
		{T: externglib.Type(C.gtk_delete_type_get_type()), F: marshalDeleteType},
		{T: externglib.Type(C.gtk_direction_type_get_type()), F: marshalDirectionType},
		{T: externglib.Type(C.gtk_editable_properties_get_type()), F: marshalEditableProperties},
		{T: externglib.Type(C.gtk_entry_icon_position_get_type()), F: marshalEntryIconPosition},
		{T: externglib.Type(C.gtk_event_sequence_state_get_type()), F: marshalEventSequenceState},
		{T: externglib.Type(C.gtk_file_chooser_action_get_type()), F: marshalFileChooserAction},
		{T: externglib.Type(C.gtk_file_chooser_error_get_type()), F: marshalFileChooserError},
		{T: externglib.Type(C.gtk_filter_change_get_type()), F: marshalFilterChange},
		{T: externglib.Type(C.gtk_filter_match_get_type()), F: marshalFilterMatch},
		{T: externglib.Type(C.gtk_icon_size_get_type()), F: marshalIconSize},
		{T: externglib.Type(C.gtk_icon_theme_error_get_type()), F: marshalIconThemeError},
		{T: externglib.Type(C.gtk_icon_view_drop_position_get_type()), F: marshalIconViewDropPosition},
		{T: externglib.Type(C.gtk_image_type_get_type()), F: marshalImageType},
		{T: externglib.Type(C.gtk_input_purpose_get_type()), F: marshalInputPurpose},
		{T: externglib.Type(C.gtk_justification_get_type()), F: marshalJustification},
		{T: externglib.Type(C.gtk_level_bar_mode_get_type()), F: marshalLevelBarMode},
		{T: externglib.Type(C.gtk_license_get_type()), F: marshalLicense},
		{T: externglib.Type(C.gtk_message_type_get_type()), F: marshalMessageType},
		{T: externglib.Type(C.gtk_movement_step_get_type()), F: marshalMovementStep},
		{T: externglib.Type(C.gtk_notebook_tab_get_type()), F: marshalNotebookTab},
		{T: externglib.Type(C.gtk_number_up_layout_get_type()), F: marshalNumberUpLayout},
		{T: externglib.Type(C.gtk_ordering_get_type()), F: marshalOrdering},
		{T: externglib.Type(C.gtk_orientation_get_type()), F: marshalOrientation},
		{T: externglib.Type(C.gtk_overflow_get_type()), F: marshalOverflow},
		{T: externglib.Type(C.gtk_pack_type_get_type()), F: marshalPackType},
		{T: externglib.Type(C.gtk_pad_action_type_get_type()), F: marshalPadActionType},
		{T: externglib.Type(C.gtk_page_orientation_get_type()), F: marshalPageOrientation},
		{T: externglib.Type(C.gtk_page_set_get_type()), F: marshalPageSet},
		{T: externglib.Type(C.gtk_pan_direction_get_type()), F: marshalPanDirection},
		{T: externglib.Type(C.gtk_policy_type_get_type()), F: marshalPolicyType},
		{T: externglib.Type(C.gtk_position_type_get_type()), F: marshalPositionType},
		{T: externglib.Type(C.gtk_print_duplex_get_type()), F: marshalPrintDuplex},
		{T: externglib.Type(C.gtk_print_error_get_type()), F: marshalPrintError},
		{T: externglib.Type(C.gtk_print_operation_action_get_type()), F: marshalPrintOperationAction},
		{T: externglib.Type(C.gtk_print_operation_result_get_type()), F: marshalPrintOperationResult},
		{T: externglib.Type(C.gtk_print_pages_get_type()), F: marshalPrintPages},
		{T: externglib.Type(C.gtk_print_quality_get_type()), F: marshalPrintQuality},
		{T: externglib.Type(C.gtk_print_status_get_type()), F: marshalPrintStatus},
		{T: externglib.Type(C.gtk_propagation_limit_get_type()), F: marshalPropagationLimit},
		{T: externglib.Type(C.gtk_propagation_phase_get_type()), F: marshalPropagationPhase},
		{T: externglib.Type(C.gtk_recent_manager_error_get_type()), F: marshalRecentManagerError},
		{T: externglib.Type(C.gtk_response_type_get_type()), F: marshalResponseType},
		{T: externglib.Type(C.gtk_revealer_transition_type_get_type()), F: marshalRevealerTransitionType},
		{T: externglib.Type(C.gtk_scroll_step_get_type()), F: marshalScrollStep},
		{T: externglib.Type(C.gtk_scroll_type_get_type()), F: marshalScrollType},
		{T: externglib.Type(C.gtk_scrollable_policy_get_type()), F: marshalScrollablePolicy},
		{T: externglib.Type(C.gtk_selection_mode_get_type()), F: marshalSelectionMode},
		{T: externglib.Type(C.gtk_sensitivity_type_get_type()), F: marshalSensitivityType},
		{T: externglib.Type(C.gtk_shortcut_scope_get_type()), F: marshalShortcutScope},
		{T: externglib.Type(C.gtk_shortcut_type_get_type()), F: marshalShortcutType},
		{T: externglib.Type(C.gtk_size_group_mode_get_type()), F: marshalSizeGroupMode},
		{T: externglib.Type(C.gtk_size_request_mode_get_type()), F: marshalSizeRequestMode},
		{T: externglib.Type(C.gtk_sort_type_get_type()), F: marshalSortType},
		{T: externglib.Type(C.gtk_sorter_change_get_type()), F: marshalSorterChange},
		{T: externglib.Type(C.gtk_sorter_order_get_type()), F: marshalSorterOrder},
		{T: externglib.Type(C.gtk_spin_button_update_policy_get_type()), F: marshalSpinButtonUpdatePolicy},
		{T: externglib.Type(C.gtk_spin_type_get_type()), F: marshalSpinType},
		{T: externglib.Type(C.gtk_stack_transition_type_get_type()), F: marshalStackTransitionType},
		{T: externglib.Type(C.gtk_string_filter_match_mode_get_type()), F: marshalStringFilterMatchMode},
		{T: externglib.Type(C.gtk_system_setting_get_type()), F: marshalSystemSetting},
		{T: externglib.Type(C.gtk_text_direction_get_type()), F: marshalTextDirection},
		{T: externglib.Type(C.gtk_text_extend_selection_get_type()), F: marshalTextExtendSelection},
		{T: externglib.Type(C.gtk_text_view_layer_get_type()), F: marshalTextViewLayer},
		{T: externglib.Type(C.gtk_text_window_type_get_type()), F: marshalTextWindowType},
		{T: externglib.Type(C.gtk_tree_view_column_sizing_get_type()), F: marshalTreeViewColumnSizing},
		{T: externglib.Type(C.gtk_tree_view_drop_position_get_type()), F: marshalTreeViewDropPosition},
		{T: externglib.Type(C.gtk_tree_view_grid_lines_get_type()), F: marshalTreeViewGridLines},
		{T: externglib.Type(C.gtk_unit_get_type()), F: marshalUnit},
		{T: externglib.Type(C.gtk_wrap_mode_get_type()), F: marshalWrapMode},
		{T: externglib.Type(C.gtk_application_inhibit_flags_get_type()), F: marshalApplicationInhibitFlags},
		{T: externglib.Type(C.gtk_builder_closure_flags_get_type()), F: marshalBuilderClosureFlags},
		{T: externglib.Type(C.gtk_cell_renderer_state_get_type()), F: marshalCellRendererState},
		{T: externglib.Type(C.gtk_debug_flags_get_type()), F: marshalDebugFlags},
		{T: externglib.Type(C.gtk_dialog_flags_get_type()), F: marshalDialogFlags},
		{T: externglib.Type(C.gtk_event_controller_scroll_flags_get_type()), F: marshalEventControllerScrollFlags},
		{T: externglib.Type(C.gtk_font_chooser_level_get_type()), F: marshalFontChooserLevel},
		{T: externglib.Type(C.gtk_icon_lookup_flags_get_type()), F: marshalIconLookupFlags},
		{T: externglib.Type(C.gtk_input_hints_get_type()), F: marshalInputHints},
		{T: externglib.Type(C.gtk_pick_flags_get_type()), F: marshalPickFlags},
		{T: externglib.Type(C.gtk_popover_menu_flags_get_type()), F: marshalPopoverMenuFlags},
		{T: externglib.Type(C.gtk_shortcut_action_flags_get_type()), F: marshalShortcutActionFlags},
		{T: externglib.Type(C.gtk_state_flags_get_type()), F: marshalStateFlags},
		{T: externglib.Type(C.gtk_style_context_print_flags_get_type()), F: marshalStyleContextPrintFlags},
		{T: externglib.Type(C.gtk_text_search_flags_get_type()), F: marshalTextSearchFlags},
		{T: externglib.Type(C.gtk_tree_model_flags_get_type()), F: marshalTreeModelFlags},
		{T: externglib.Type(C.gtk_app_chooser_get_type()), F: marshalAppChooser},
		{T: externglib.Type(C.gtk_file_chooser_get_type()), F: marshalFileChooser},
		{T: externglib.Type(C.gtk_style_provider_get_type()), F: marshalStyleProvider},
		{T: externglib.Type(C.gtk_about_dialog_get_type()), F: marshalAboutDialog},
		{T: externglib.Type(C.gtk_action_bar_get_type()), F: marshalActionBar},
		{T: externglib.Type(C.gtk_app_chooser_button_get_type()), F: marshalAppChooserButton},
		{T: externglib.Type(C.gtk_app_chooser_dialog_get_type()), F: marshalAppChooserDialog},
		{T: externglib.Type(C.gtk_app_chooser_widget_get_type()), F: marshalAppChooserWidget},
		{T: externglib.Type(C.gtk_aspect_frame_get_type()), F: marshalAspectFrame},
		{T: externglib.Type(C.gtk_assistant_get_type()), F: marshalAssistant},
		{T: externglib.Type(C.gtk_assistant_page_get_type()), F: marshalAssistantPage},
		{T: externglib.Type(C.gtk_calendar_get_type()), F: marshalCalendar},
		{T: externglib.Type(C.gtk_cell_area_box_get_type()), F: marshalCellAreaBox},
		{T: externglib.Type(C.gtk_cell_renderer_accel_get_type()), F: marshalCellRendererAccel},
		{T: externglib.Type(C.gtk_cell_renderer_combo_get_type()), F: marshalCellRendererCombo},
		{T: externglib.Type(C.gtk_cell_renderer_pixbuf_get_type()), F: marshalCellRendererPixbuf},
		{T: externglib.Type(C.gtk_cell_renderer_progress_get_type()), F: marshalCellRendererProgress},
		{T: externglib.Type(C.gtk_cell_renderer_spin_get_type()), F: marshalCellRendererSpin},
		{T: externglib.Type(C.gtk_cell_renderer_spinner_get_type()), F: marshalCellRendererSpinner},
		{T: externglib.Type(C.gtk_cell_renderer_toggle_get_type()), F: marshalCellRendererToggle},
		{T: externglib.Type(C.gtk_cell_view_get_type()), F: marshalCellView},
		{T: externglib.Type(C.gtk_color_button_get_type()), F: marshalColorButton},
		{T: externglib.Type(C.gtk_color_chooser_dialog_get_type()), F: marshalColorChooserDialog},
		{T: externglib.Type(C.gtk_color_chooser_widget_get_type()), F: marshalColorChooserWidget},
		{T: externglib.Type(C.gtk_combo_box_text_get_type()), F: marshalComboBoxText},
		{T: externglib.Type(C.gtk_entry_completion_get_type()), F: marshalEntryCompletion},
		{T: externglib.Type(C.gtk_expander_get_type()), F: marshalExpander},
		{T: externglib.Type(C.gtk_file_chooser_dialog_get_type()), F: marshalFileChooserDialog},
		{T: externglib.Type(C.gtk_file_chooser_widget_get_type()), F: marshalFileChooserWidget},
		{T: externglib.Type(C.gtk_file_filter_get_type()), F: marshalFileFilter},
		{T: externglib.Type(C.gtk_flow_box_get_type()), F: marshalFlowBox},
		{T: externglib.Type(C.gtk_font_button_get_type()), F: marshalFontButton},
		{T: externglib.Type(C.gtk_font_chooser_dialog_get_type()), F: marshalFontChooserDialog},
		{T: externglib.Type(C.gtk_font_chooser_widget_get_type()), F: marshalFontChooserWidget},
		{T: externglib.Type(C.gtk_header_bar_get_type()), F: marshalHeaderBar},
		{T: externglib.Type(C.gtk_icon_paintable_get_type()), F: marshalIconPaintable},
		{T: externglib.Type(C.gtk_icon_theme_get_type()), F: marshalIconTheme},
		{T: externglib.Type(C.gtk_icon_view_get_type()), F: marshalIconView},
		{T: externglib.Type(C.gtk_image_get_type()), F: marshalImage},
		{T: externglib.Type(C.gtk_info_bar_get_type()), F: marshalInfoBar},
		{T: externglib.Type(C.gtk_label_get_type()), F: marshalLabel},
		{T: externglib.Type(C.gtk_level_bar_get_type()), F: marshalLevelBar},
		{T: externglib.Type(C.gtk_link_button_get_type()), F: marshalLinkButton},
		{T: externglib.Type(C.gtk_list_box_get_type()), F: marshalListBox},
		{T: externglib.Type(C.gtk_lock_button_get_type()), F: marshalLockButton},
		{T: externglib.Type(C.gtk_menu_button_get_type()), F: marshalMenuButton},
		{T: externglib.Type(C.gtk_notebook_get_type()), F: marshalNotebook},
		{T: externglib.Type(C.gtk_notebook_page_get_type()), F: marshalNotebookPage},
		{T: externglib.Type(C.gtk_overlay_get_type()), F: marshalOverlay},
		{T: externglib.Type(C.gtk_page_setup_get_type()), F: marshalPageSetup},
		{T: externglib.Type(C.gtk_paned_get_type()), F: marshalPaned},
		{T: externglib.Type(C.gtk_popover_menu_get_type()), F: marshalPopoverMenu},
		{T: externglib.Type(C.gtk_popover_menu_bar_get_type()), F: marshalPopoverMenuBar},
		{T: externglib.Type(C.gtk_print_context_get_type()), F: marshalPrintContext},
		{T: externglib.Type(C.gtk_print_settings_get_type()), F: marshalPrintSettings},
		{T: externglib.Type(C.gtk_progress_bar_get_type()), F: marshalProgressBar},
		{T: externglib.Type(C.gtk_revealer_get_type()), F: marshalRevealer},
		{T: externglib.Type(C.gtk_scrollbar_get_type()), F: marshalScrollbar},
		{T: externglib.Type(C.gtk_scrolled_window_get_type()), F: marshalScrolledWindow},
		{T: externglib.Type(C.gtk_search_bar_get_type()), F: marshalSearchBar},
		{T: externglib.Type(C.gtk_search_entry_get_type()), F: marshalSearchEntry},
		{T: externglib.Type(C.gtk_separator_get_type()), F: marshalSeparator},
		{T: externglib.Type(C.gtk_settings_get_type()), F: marshalSettings},
		{T: externglib.Type(C.gtk_shortcuts_window_get_type()), F: marshalShortcutsWindow},
		{T: externglib.Type(C.gtk_size_group_get_type()), F: marshalSizeGroup},
		{T: externglib.Type(C.gtk_spin_button_get_type()), F: marshalSpinButton},
		{T: externglib.Type(C.gtk_spinner_get_type()), F: marshalSpinner},
		{T: externglib.Type(C.gtk_stack_get_type()), F: marshalStack},
		{T: externglib.Type(C.gtk_stack_page_get_type()), F: marshalStackPage},
		{T: externglib.Type(C.gtk_stack_sidebar_get_type()), F: marshalStackSidebar},
		{T: externglib.Type(C.gtk_stack_switcher_get_type()), F: marshalStackSwitcher},
		{T: externglib.Type(C.gtk_statusbar_get_type()), F: marshalStatusbar},
		{T: externglib.Type(C.gtk_switch_get_type()), F: marshalSwitch},
		{T: externglib.Type(C.gtk_text_get_type()), F: marshalText},
		{T: externglib.Type(C.gtk_text_tag_table_get_type()), F: marshalTextTagTable},
		{T: externglib.Type(C.gtk_tooltip_get_type()), F: marshalTooltip},
		{T: externglib.Type(C.gtk_tree_selection_get_type()), F: marshalTreeSelection},
		{T: externglib.Type(C.gtk_tree_view_column_get_type()), F: marshalTreeViewColumn},
		{T: externglib.Type(C.gtk_viewport_get_type()), F: marshalViewport},
		{T: externglib.Type(C.gtk_volume_button_get_type()), F: marshalVolumeButton},
	})
}

// AccessibleAutocomplete: the possible values for the
// GTK_ACCESSIBLE_PROPERTY_AUTOCOMPLETE accessible property.
type AccessibleAutocomplete int

const (
	// AccessibleAutocompleteNone: automatic suggestions are not displayed.
	AccessibleAutocompleteNone AccessibleAutocomplete = 0
	// AccessibleAutocompleteInline: when a user is providing input, text
	// suggesting one way to complete the provided input may be dynamically
	// inserted after the caret.
	AccessibleAutocompleteInline AccessibleAutocomplete = 1
	// AccessibleAutocompleteList: when a user is providing input, an element
	// containing a collection of values that could complete the provided input
	// may be displayed.
	AccessibleAutocompleteList AccessibleAutocomplete = 2
	// AccessibleAutocompleteBoth: when a user is providing input, an element
	// containing a collection of values that could complete the provided input
	// may be displayed. If displayed, one value in the collection is
	// automatically selected, and the text needed to complete the automatically
	// selected value appears after the caret in the input.
	AccessibleAutocompleteBoth AccessibleAutocomplete = 3
)

func marshalAccessibleAutocomplete(p uintptr) (interface{}, error) {
	return AccessibleAutocomplete(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AccessibleInvalidState: the possible values for the
// GTK_ACCESSIBLE_STATE_INVALID accessible state.
//
// Note that the GTK_ACCESSIBLE_INVALID_FALSE and GTK_ACCESSIBLE_INVALID_TRUE
// have the same values as false and true.
type AccessibleInvalidState int

const (
	// AccessibleInvalidStateFalse: there are no detected errors in the value
	AccessibleInvalidStateFalse AccessibleInvalidState = 0
	// AccessibleInvalidStateTrue: the value entered by the user has failed
	// validation
	AccessibleInvalidStateTrue AccessibleInvalidState = 1
	// AccessibleInvalidStateGrammar: a grammatical error was detected
	AccessibleInvalidStateGrammar AccessibleInvalidState = 2
	// AccessibleInvalidStateSpelling: a spelling error was detected
	AccessibleInvalidStateSpelling AccessibleInvalidState = 3
)

func marshalAccessibleInvalidState(p uintptr) (interface{}, error) {
	return AccessibleInvalidState(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AccessibleProperty: the possible accessible properties of a Accessible.
type AccessibleProperty int

const (
	// AccessiblePropertyAutocomplete indicates whether inputting text could
	// trigger display of one or more predictions of the user's intended value
	// for a combobox, searchbox, or textbox and specifies how predictions would
	// be presented if they were made. Value type: AccessibleAutocomplete
	AccessiblePropertyAutocomplete AccessibleProperty = 0
	// AccessiblePropertyDescription defines a string value that describes or
	// annotates the current element. Value type: string
	AccessiblePropertyDescription AccessibleProperty = 1
	// AccessiblePropertyHasPopup indicates the availability and type of
	// interactive popup element, such as menu or dialog, that can be triggered
	// by an element.
	AccessiblePropertyHasPopup AccessibleProperty = 2
	// AccessiblePropertyKeyShortcuts indicates keyboard shortcuts that an
	// author has implemented to activate or give focus to an element. Value
	// type: string
	AccessiblePropertyKeyShortcuts AccessibleProperty = 3
	// AccessiblePropertyLabel defines a string value that labels the current
	// element. Value type: string
	AccessiblePropertyLabel AccessibleProperty = 4
	// AccessiblePropertyLevel defines the hierarchical level of an element
	// within a structure. Value type: integer
	AccessiblePropertyLevel AccessibleProperty = 5
	// AccessiblePropertyModal indicates whether an element is modal when
	// displayed. Value type: boolean
	AccessiblePropertyModal AccessibleProperty = 6
	// AccessiblePropertyMultiLine indicates whether a text box accepts multiple
	// lines of input or only a single line. Value type: boolean
	AccessiblePropertyMultiLine AccessibleProperty = 7
	// AccessiblePropertyMultiSelectable indicates that the user may select more
	// than one item from the current selectable descendants. Value type:
	// boolean
	AccessiblePropertyMultiSelectable AccessibleProperty = 8
	// AccessiblePropertyOrientation indicates whether the element's orientation
	// is horizontal, vertical, or unknown/ambiguous. Value type: Orientation
	AccessiblePropertyOrientation AccessibleProperty = 9
	// AccessiblePropertyPlaceholder defines a short hint (a word or short
	// phrase) intended to aid the user with data entry when the control has no
	// value. A hint could be a sample value or a brief description of the
	// expected format. Value type: string
	AccessiblePropertyPlaceholder AccessibleProperty = 10
	// AccessiblePropertyReadOnly indicates that the element is not editable,
	// but is otherwise operable. Value type: boolean
	AccessiblePropertyReadOnly AccessibleProperty = 11
	// AccessiblePropertyRequired indicates that user input is required on the
	// element before a form may be submitted. Value type: boolean
	AccessiblePropertyRequired AccessibleProperty = 12
	// AccessiblePropertyRoleDescription defines a human-readable,
	// author-localized description for the role of an element. Value type:
	// string
	AccessiblePropertyRoleDescription AccessibleProperty = 13
	// AccessiblePropertySort indicates if items in a table or grid are sorted
	// in ascending or descending order. Possible property values are in the
	// AccessibleSort enumeration. Value type: AccessibleSort
	AccessiblePropertySort AccessibleProperty = 14
	// AccessiblePropertyValueMax defines the maximum allowed value for a range
	// widget. Value type: double
	AccessiblePropertyValueMax AccessibleProperty = 15
	// AccessiblePropertyValueMin defines the minimum allowed value for a range
	// widget. Value type: double
	AccessiblePropertyValueMin AccessibleProperty = 16
	// AccessiblePropertyValueNow defines the current value for a range widget.
	// Value type: double
	AccessiblePropertyValueNow AccessibleProperty = 17
	// AccessiblePropertyValueText defines the human readable text alternative
	// of aria-valuenow for a range widget. Value type: string
	AccessiblePropertyValueText AccessibleProperty = 18
)

func marshalAccessibleProperty(p uintptr) (interface{}, error) {
	return AccessibleProperty(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AccessibleRelation: the possible accessible relations of a Accessible.
// Accessible relations can be references to other widgets, integers or strings.
type AccessibleRelation int

const (
	// AccessibleRelationActiveDescendant identifies the currently active
	// element when focus is on a composite widget, combobox, textbox, group, or
	// application. Value type: reference
	AccessibleRelationActiveDescendant AccessibleRelation = 0
	// AccessibleRelationColCount defines the total number of columns in a
	// table, grid, or treegrid. Value type: integer
	AccessibleRelationColCount AccessibleRelation = 1
	// AccessibleRelationColIndex defines an element's column index or position
	// with respect to the total number of columns within a table, grid, or
	// treegrid. Value type: integer
	AccessibleRelationColIndex AccessibleRelation = 2
	// AccessibleRelationColIndexText defines a human readable text alternative
	// of GTK_ACCESSIBLE_RELATION_COL_INDEX. Value type: string
	AccessibleRelationColIndexText AccessibleRelation = 3
	// AccessibleRelationColSpan defines the number of columns spanned by a cell
	// or gridcell within a table, grid, or treegrid. Value type: integer
	AccessibleRelationColSpan AccessibleRelation = 4
	// AccessibleRelationControls identifies the element (or elements) whose
	// contents or presence are controlled by the current element. Value type:
	// reference
	AccessibleRelationControls AccessibleRelation = 5
	// AccessibleRelationDescribedBy identifies the element (or elements) that
	// describes the object. Value type: reference
	AccessibleRelationDescribedBy AccessibleRelation = 6
	// AccessibleRelationDetails identifies the element (or elements) that
	// provide additional information related to the object. Value type:
	// reference
	AccessibleRelationDetails AccessibleRelation = 7
	// AccessibleRelationErrorMessage identifies the element that provides an
	// error message for an object. Value type: reference
	AccessibleRelationErrorMessage AccessibleRelation = 8
	// AccessibleRelationFlowTo identifies the next element (or elements) in an
	// alternate reading order of content which, at the user's discretion,
	// allows assistive technology to override the general default of reading in
	// document source order. Value type: reference
	AccessibleRelationFlowTo AccessibleRelation = 9
	// AccessibleRelationLabelledBy identifies the element (or elements) that
	// labels the current element. Value type: reference
	AccessibleRelationLabelledBy AccessibleRelation = 10
	// AccessibleRelationOwns identifies an element (or elements) in order to
	// define a visual, functional, or contextual parent/child relationship
	// between elements where the widget hierarchy cannot be used to represent
	// the relationship. Value type: reference
	AccessibleRelationOwns AccessibleRelation = 11
	// AccessibleRelationPosInSet defines an element's number or position in the
	// current set of listitems or treeitems. Value type: integer
	AccessibleRelationPosInSet AccessibleRelation = 12
	// AccessibleRelationRowCount defines the total number of rows in a table,
	// grid, or treegrid. Value type: integer
	AccessibleRelationRowCount AccessibleRelation = 13
	// AccessibleRelationRowIndex defines an element's row index or position
	// with respect to the total number of rows within a table, grid, or
	// treegrid. Value type: integer
	AccessibleRelationRowIndex AccessibleRelation = 14
	// AccessibleRelationRowIndexText defines a human readable text alternative
	// of aria-rowindex. Value type: string
	AccessibleRelationRowIndexText AccessibleRelation = 15
	// AccessibleRelationRowSpan defines the number of rows spanned by a cell or
	// gridcell within a table, grid, or treegrid. Value type: integer
	AccessibleRelationRowSpan AccessibleRelation = 16
	// AccessibleRelationSetSize defines the number of items in the current set
	// of listitems or treeitems. Value type: integer
	AccessibleRelationSetSize AccessibleRelation = 17
)

func marshalAccessibleRelation(p uintptr) (interface{}, error) {
	return AccessibleRelation(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AccessibleRole: the accessible role for a Accessible implementation.
//
// Abstract roles are only used as part of the ontology; application developers
// must not use abstract roles in their code.
type AccessibleRole int

const (
	// AccessibleRoleAlert: an element with important, and usually
	// time-sensitive, information
	AccessibleRoleAlert AccessibleRole = 0
	// AccessibleRoleAlertDialog: a type of dialog that contains an alert
	// message
	AccessibleRoleAlertDialog AccessibleRole = 1
	// AccessibleRoleBanner: unused
	AccessibleRoleBanner AccessibleRole = 2
	// AccessibleRoleButton: an input element that allows for user-triggered
	// actions when clicked or pressed
	AccessibleRoleButton AccessibleRole = 3
	// AccessibleRoleCaption: unused
	AccessibleRoleCaption AccessibleRole = 4
	// AccessibleRoleCell: unused
	AccessibleRoleCell AccessibleRole = 5
	// AccessibleRoleCheckbox: a checkable input element that has three possible
	// values: `true`, `false`, or `mixed`
	AccessibleRoleCheckbox AccessibleRole = 6
	// AccessibleRoleColumnHeader: a header in a columned list.
	AccessibleRoleColumnHeader AccessibleRole = 7
	// AccessibleRoleComboBox: an input that controls another element, such as a
	// list or a grid, that can dynamically pop up to help the user set the
	// value of the input
	AccessibleRoleComboBox AccessibleRole = 8
	// AccessibleRoleCommand: abstract role.
	AccessibleRoleCommand AccessibleRole = 9
	// AccessibleRoleComposite: abstract role.
	AccessibleRoleComposite AccessibleRole = 10
	// AccessibleRoleDialog: a dialog is a window that is designed to interrupt
	// the current processing of an application in order to prompt the user to
	// enter information or require a response.
	AccessibleRoleDialog AccessibleRole = 11
	// AccessibleRoleDocument: unused
	AccessibleRoleDocument AccessibleRole = 12
	// AccessibleRoleFeed: unused
	AccessibleRoleFeed AccessibleRole = 13
	// AccessibleRoleForm: unused
	AccessibleRoleForm AccessibleRole = 14
	// AccessibleRoleGeneric: unused
	AccessibleRoleGeneric AccessibleRole = 15
	// AccessibleRoleGrid: a grid of items.
	AccessibleRoleGrid AccessibleRole = 16
	// AccessibleRoleGridCell: an item in a grid or tree grid.
	AccessibleRoleGridCell AccessibleRole = 17
	// AccessibleRoleGroup: an element that groups multiple widgets. GTK uses
	// this role for various containers, like Box, Viewport, and HeaderBar.
	AccessibleRoleGroup AccessibleRole = 18
	// AccessibleRoleHeading: unused
	AccessibleRoleHeading AccessibleRole = 19
	// AccessibleRoleImg: an image.
	AccessibleRoleImg AccessibleRole = 20
	// AccessibleRoleInput: abstract role.
	AccessibleRoleInput AccessibleRole = 21
	// AccessibleRoleLabel: a visible name or caption for a user interface
	// component.
	AccessibleRoleLabel AccessibleRole = 22
	// AccessibleRoleLandmark: abstract role.
	AccessibleRoleLandmark AccessibleRole = 23
	// AccessibleRoleLegend: unused
	AccessibleRoleLegend AccessibleRole = 24
	// AccessibleRoleLink: a clickable link.
	AccessibleRoleLink AccessibleRole = 25
	// AccessibleRoleList: a list of items.
	AccessibleRoleList AccessibleRole = 26
	// AccessibleRoleListBox: unused.
	AccessibleRoleListBox AccessibleRole = 27
	// AccessibleRoleListItem: an item in a list.
	AccessibleRoleListItem AccessibleRole = 28
	// AccessibleRoleLog: unused
	AccessibleRoleLog AccessibleRole = 29
	// AccessibleRoleMain: unused
	AccessibleRoleMain AccessibleRole = 30
	// AccessibleRoleMarquee: unused
	AccessibleRoleMarquee AccessibleRole = 31
	// AccessibleRoleMath: unused
	AccessibleRoleMath AccessibleRole = 32
	// AccessibleRoleMeter: an element that represents a value within a known
	// range.
	AccessibleRoleMeter AccessibleRole = 33
	// AccessibleRoleMenu: a menu.
	AccessibleRoleMenu AccessibleRole = 34
	// AccessibleRoleMenuBar: a menubar.
	AccessibleRoleMenuBar AccessibleRole = 35
	// AccessibleRoleMenuItem: an item in a menu.
	AccessibleRoleMenuItem AccessibleRole = 36
	// AccessibleRoleMenuItemCheckbox: a check item in a menu.
	AccessibleRoleMenuItemCheckbox AccessibleRole = 37
	// AccessibleRoleMenuItemRadio: a radio item in a menu.
	AccessibleRoleMenuItemRadio AccessibleRole = 38
	// AccessibleRoleNavigation: unused
	AccessibleRoleNavigation AccessibleRole = 39
	// AccessibleRoleNone: an element that is not represented to accessibility
	// technologies.
	AccessibleRoleNone AccessibleRole = 40
	// AccessibleRoleNote: unused
	AccessibleRoleNote AccessibleRole = 41
	// AccessibleRoleOption: unused
	AccessibleRoleOption AccessibleRole = 42
	// AccessibleRolePresentation: an element that is not represented to
	// accessibility technologies.
	AccessibleRolePresentation AccessibleRole = 43
	// AccessibleRoleProgressBar: an element that displays the progress status
	// for tasks that take a long time.
	AccessibleRoleProgressBar AccessibleRole = 44
	// AccessibleRoleRadio: a checkable input in a group of radio roles, only
	// one of which can be checked at a time.
	AccessibleRoleRadio AccessibleRole = 45
	// AccessibleRoleRadioGroup: unused
	AccessibleRoleRadioGroup AccessibleRole = 46
	// AccessibleRoleRange: abstract role.
	AccessibleRoleRange AccessibleRole = 47
	// AccessibleRoleRegion: unused
	AccessibleRoleRegion AccessibleRole = 48
	// AccessibleRoleRow: a row in a columned list.
	AccessibleRoleRow AccessibleRole = 49
	// AccessibleRoleRowGroup: unused
	AccessibleRoleRowGroup AccessibleRole = 50
	// AccessibleRoleRowHeader: unused
	AccessibleRoleRowHeader AccessibleRole = 51
	// AccessibleRoleScrollbar: a graphical object that controls the scrolling
	// of content within a viewing area, regardless of whether the content is
	// fully displayed within the viewing area.
	AccessibleRoleScrollbar AccessibleRole = 52
	// AccessibleRoleSearch: unused
	AccessibleRoleSearch AccessibleRole = 53
	// AccessibleRoleSearchBox: a type of textbox intended for specifying search
	// criteria.
	AccessibleRoleSearchBox AccessibleRole = 54
	// AccessibleRoleSection: abstract role.
	AccessibleRoleSection AccessibleRole = 55
	// AccessibleRoleSectionHead: abstract role.
	AccessibleRoleSectionHead AccessibleRole = 56
	// AccessibleRoleSelect: abstract role.
	AccessibleRoleSelect AccessibleRole = 57
	// AccessibleRoleSeparator: a divider that separates and distinguishes
	// sections of content or groups of menuitems.
	AccessibleRoleSeparator AccessibleRole = 58
	// AccessibleRoleSlider: a user input where the user selects a value from
	// within a given range.
	AccessibleRoleSlider AccessibleRole = 59
	// AccessibleRoleSpinButton: a form of range that expects the user to select
	// from among discrete choices.
	AccessibleRoleSpinButton AccessibleRole = 60
	// AccessibleRoleStatus: unused
	AccessibleRoleStatus AccessibleRole = 61
	// AccessibleRoleStructure: abstract role.
	AccessibleRoleStructure AccessibleRole = 62
	// AccessibleRoleSwitch: a type of checkbox that represents on/off values,
	// as opposed to checked/unchecked values.
	AccessibleRoleSwitch AccessibleRole = 63
	// AccessibleRoleTab: an item in a list of tab used for switching pages.
	AccessibleRoleTab AccessibleRole = 64
	// AccessibleRoleTable: unused
	AccessibleRoleTable AccessibleRole = 65
	// AccessibleRoleTabList: a list of tabs for switching pages.
	AccessibleRoleTabList AccessibleRole = 66
	// AccessibleRoleTabPanel: a page in a notebook or stack.
	AccessibleRoleTabPanel AccessibleRole = 67
	// AccessibleRoleTextBox: a type of input that allows free-form text as its
	// value.
	AccessibleRoleTextBox AccessibleRole = 68
	// AccessibleRoleTime: unused
	AccessibleRoleTime AccessibleRole = 69
	// AccessibleRoleTimer: unused
	AccessibleRoleTimer AccessibleRole = 70
	// AccessibleRoleToolbar: unused
	AccessibleRoleToolbar AccessibleRole = 71
	// AccessibleRoleTooltip: unused
	AccessibleRoleTooltip AccessibleRole = 72
	// AccessibleRoleTree: unused
	AccessibleRoleTree AccessibleRole = 73
	// AccessibleRoleTreeGrid: a treeview-like, columned list.
	AccessibleRoleTreeGrid AccessibleRole = 74
	// AccessibleRoleTreeItem: unused
	AccessibleRoleTreeItem AccessibleRole = 75
	// AccessibleRoleWidget: an interactive component of a graphical user
	// interface. This is the role that GTK uses by default for widgets.
	AccessibleRoleWidget AccessibleRole = 76
	// AccessibleRoleWindow: an application window.
	AccessibleRoleWindow AccessibleRole = 77
)

func marshalAccessibleRole(p uintptr) (interface{}, error) {
	return AccessibleRole(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AccessibleSort: the possible values for the GTK_ACCESSIBLE_PROPERTY_SORT
// accessible property.
type AccessibleSort int

const (
	// AccessibleSortNone: there is no defined sort applied to the column.
	AccessibleSortNone AccessibleSort = 0
	// AccessibleSortAscending items are sorted in ascending order by this
	// column.
	AccessibleSortAscending AccessibleSort = 1
	// AccessibleSortDescending items are sorted in descending order by this
	// column.
	AccessibleSortDescending AccessibleSort = 2
	// AccessibleSortOther: a sort algorithm other than ascending or descending
	// has been applied.
	AccessibleSortOther AccessibleSort = 3
)

func marshalAccessibleSort(p uintptr) (interface{}, error) {
	return AccessibleSort(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AccessibleState: the possible accessible states of a Accessible.
type AccessibleState int

const (
	// AccessibleStateBusy: a “busy” state. This state has boolean values
	AccessibleStateBusy AccessibleState = 0
	// AccessibleStateChecked: a “checked” state; indicates the current state of
	// a CheckButton. Value type: AccessibleTristate
	AccessibleStateChecked AccessibleState = 1
	// AccessibleStateDisabled: a “disabled” state; corresponds to the
	// Widget:sensitive property on Widget. It indicates a UI element that is
	// perceivable, but not editable or operable. Value type: boolean
	AccessibleStateDisabled AccessibleState = 2
	// AccessibleStateExpanded: an “expanded” state; corresponds to the
	// Expander:expanded property on Expander. Value type: boolean or undefined
	AccessibleStateExpanded AccessibleState = 3
	// AccessibleStateHidden: a “hidden” state; corresponds to the
	// Widget:visible property on Widget. You can use this state explicitly on
	// UI elements that should not be exposed to an assistive technology. Value
	// type: boolean See also: GTK_ACCESSIBLE_STATE_DISABLED
	AccessibleStateHidden AccessibleState = 4
	// AccessibleStateInvalid: an “invalid” state; set when a widget is showing
	// an error. Value type: AccessibleInvalidState
	AccessibleStateInvalid AccessibleState = 5
	// AccessibleStatePressed: a “pressed” state; indicates the current state of
	// a ToggleButton. Value type: AccessibleTristate enumeration
	AccessibleStatePressed AccessibleState = 6
	// AccessibleStateSelected: a “selected” state; set when a widget is
	// selected. Value type: boolean or undefined
	AccessibleStateSelected AccessibleState = 7
)

func marshalAccessibleState(p uintptr) (interface{}, error) {
	return AccessibleState(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AccessibleTristate: the possible values for the GTK_ACCESSIBLE_STATE_PRESSED
// accessible state.
//
// Note that the GTK_ACCESSIBLE_TRISTATE_FALSE and GTK_ACCESSIBLE_TRISTATE_TRUE
// have the same values as false and true.
type AccessibleTristate int

const (
	// AccessibleTristateFalse: the state is `false`
	AccessibleTristateFalse AccessibleTristate = 0
	// AccessibleTristateTrue: the state is `true`
	AccessibleTristateTrue AccessibleTristate = 1
	// AccessibleTristateMixed: the state is `mixed`
	AccessibleTristateMixed AccessibleTristate = 2
)

func marshalAccessibleTristate(p uintptr) (interface{}, error) {
	return AccessibleTristate(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// Align controls how a widget deals with extra space in a single (x or y)
// dimension.
//
// Alignment only matters if the widget receives a “too large” allocation, for
// example if you packed the widget with the Widget:hexpand property inside a
// Box, then the widget might get extra space. If you have for example a 16x16
// icon inside a 32x32 space, the icon could be scaled and stretched, it could
// be centered, or it could be positioned to one side of the space.
//
// Note that in horizontal context GTK_ALIGN_START and GTK_ALIGN_END are
// interpreted relative to text direction.
//
// GTK_ALIGN_BASELINE support is optional for containers and widgets, and it is
// only supported for vertical alignment. When it's not supported by a child or
// a container it is treated as GTK_ALIGN_FILL.
type Align int

const (
	// AlignFill: stretch to fill all space if possible, center if no meaningful
	// way to stretch
	AlignFill Align = 0
	// AlignStart: snap to left or top side, leaving space on right or bottom
	AlignStart Align = 1
	// AlignEnd: snap to right or bottom side, leaving space on left or top
	AlignEnd Align = 2
	// AlignCenter: center natural width of widget inside the allocation
	AlignCenter Align = 3
	// AlignBaseline: align the widget according to the baseline. See Widget
	AlignBaseline Align = 4
)

func marshalAlign(p uintptr) (interface{}, error) {
	return Align(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ArrowType: used to indicate the direction in which an arrow should point.
type ArrowType int

const (
	// ArrowTypeUp represents an upward pointing arrow.
	ArrowTypeUp ArrowType = 0
	// ArrowTypeDown represents a downward pointing arrow.
	ArrowTypeDown ArrowType = 1
	// ArrowTypeLeft represents a left pointing arrow.
	ArrowTypeLeft ArrowType = 2
	// ArrowTypeRight represents a right pointing arrow.
	ArrowTypeRight ArrowType = 3
	// ArrowTypeNone: no arrow.
	ArrowTypeNone ArrowType = 4
)

func marshalArrowType(p uintptr) (interface{}, error) {
	return ArrowType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AssistantPageType: an enum for determining the page role inside the
// Assistant. It's used to handle buttons sensitivity and visibility.
//
// Note that an assistant needs to end its page flow with a page of type
// GTK_ASSISTANT_PAGE_CONFIRM, GTK_ASSISTANT_PAGE_SUMMARY or
// GTK_ASSISTANT_PAGE_PROGRESS to be correct.
//
// The Cancel button will only be shown if the page isn’t “committed”. See
// gtk_assistant_commit() for details.
type AssistantPageType int

const (
	// AssistantPageTypeContent: the page has regular contents. Both the Back
	// and forward buttons will be shown.
	AssistantPageTypeContent AssistantPageType = 0
	// AssistantPageTypeIntro: the page contains an introduction to the
	// assistant task. Only the Forward button will be shown if there is a next
	// page.
	AssistantPageTypeIntro AssistantPageType = 1
	// AssistantPageTypeConfirm: the page lets the user confirm or deny the
	// changes. The Back and Apply buttons will be shown.
	AssistantPageTypeConfirm AssistantPageType = 2
	// AssistantPageTypeSummary: the page informs the user of the changes done.
	// Only the Close button will be shown.
	AssistantPageTypeSummary AssistantPageType = 3
	// AssistantPageTypeProgress: used for tasks that take a long time to
	// complete, blocks the assistant until the page is marked as complete. Only
	// the back button will be shown.
	AssistantPageTypeProgress AssistantPageType = 4
	// AssistantPageTypeCustom: used for when other page types are not
	// appropriate. No buttons will be shown, and the application must add its
	// own buttons through gtk_assistant_add_action_widget().
	AssistantPageTypeCustom AssistantPageType = 5
)

func marshalAssistantPageType(p uintptr) (interface{}, error) {
	return AssistantPageType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// BaselinePosition: whenever a container has some form of natural row it may
// align children in that row along a common typographical baseline. If the
// amount of vertical space in the row is taller than the total requested height
// of the baseline-aligned children then it can use a BaselinePosition to select
// where to put the baseline inside the extra available space.
type BaselinePosition int

const (
	// BaselinePositionTop: align the baseline at the top
	BaselinePositionTop BaselinePosition = 0
	// BaselinePositionCenter: center the baseline
	BaselinePositionCenter BaselinePosition = 1
	// BaselinePositionBottom: align the baseline at the bottom
	BaselinePositionBottom BaselinePosition = 2
)

func marshalBaselinePosition(p uintptr) (interface{}, error) {
	return BaselinePosition(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// BorderStyle describes how the border of a UI element should be rendered.
type BorderStyle int

const (
	// BorderStyleNone: no visible border
	BorderStyleNone BorderStyle = 0
	// BorderStyleHidden: same as GTK_BORDER_STYLE_NONE
	BorderStyleHidden BorderStyle = 1
	// BorderStyleSolid: a single line segment
	BorderStyleSolid BorderStyle = 2
	// BorderStyleInset looks as if the content is sunken into the canvas
	BorderStyleInset BorderStyle = 3
	// BorderStyleOutset looks as if the content is coming out of the canvas
	BorderStyleOutset BorderStyle = 4
	// BorderStyleDotted: a series of round dots
	BorderStyleDotted BorderStyle = 5
	// BorderStyleDashed: a series of square-ended dashes
	BorderStyleDashed BorderStyle = 6
	// BorderStyleDouble: two parallel lines with some space between them
	BorderStyleDouble BorderStyle = 7
	// BorderStyleGroove looks as if it were carved in the canvas
	BorderStyleGroove BorderStyle = 8
	// BorderStyleRidge looks as if it were coming out of the canvas
	BorderStyleRidge BorderStyle = 9
)

func marshalBorderStyle(p uintptr) (interface{}, error) {
	return BorderStyle(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// BuilderError: error codes that identify various errors that can occur while
// using Builder.
type BuilderError int

const (
	// BuilderErrorInvalidTypeFunction: a type-func attribute didn’t name a
	// function that returns a #GType.
	BuilderErrorInvalidTypeFunction BuilderError = 0
	// BuilderErrorUnhandledTag: the input contained a tag that Builder can’t
	// handle.
	BuilderErrorUnhandledTag BuilderError = 1
	// BuilderErrorMissingAttribute: an attribute that is required by Builder
	// was missing.
	BuilderErrorMissingAttribute BuilderError = 2
	// BuilderErrorInvalidAttribute: Builder found an attribute that it doesn’t
	// understand.
	BuilderErrorInvalidAttribute BuilderError = 3
	// BuilderErrorInvalidTag: Builder found a tag that it doesn’t understand.
	BuilderErrorInvalidTag BuilderError = 4
	// BuilderErrorMissingPropertyValue: a required property value was missing.
	BuilderErrorMissingPropertyValue BuilderError = 5
	// BuilderErrorInvalidValue: Builder couldn’t parse some attribute value.
	BuilderErrorInvalidValue BuilderError = 6
	// BuilderErrorVersionMismatch: the input file requires a newer version of
	// GTK.
	BuilderErrorVersionMismatch BuilderError = 7
	// BuilderErrorDuplicateID: an object id occurred twice.
	BuilderErrorDuplicateID BuilderError = 8
	// BuilderErrorObjectTypeRefused: a specified object type is of the same
	// type or derived from the type of the composite class being extended with
	// builder XML.
	BuilderErrorObjectTypeRefused BuilderError = 9
	// BuilderErrorTemplateMismatch: the wrong type was specified in a composite
	// class’s template XML
	BuilderErrorTemplateMismatch BuilderError = 10
	// BuilderErrorInvalidProperty: the specified property is unknown for the
	// object class.
	BuilderErrorInvalidProperty BuilderError = 11
	// BuilderErrorInvalidSignal: the specified signal is unknown for the object
	// class.
	BuilderErrorInvalidSignal BuilderError = 12
	// BuilderErrorInvalidID: an object id is unknown.
	BuilderErrorInvalidID BuilderError = 13
	// BuilderErrorInvalidFunction: a function could not be found. This often
	// happens when symbols are set to be kept private. Compiling code with
	// -rdynamic or using the `gmodule-export-2.0` pkgconfig module can fix this
	// problem.
	BuilderErrorInvalidFunction BuilderError = 14
)

func marshalBuilderError(p uintptr) (interface{}, error) {
	return BuilderError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ButtonsType: prebuilt sets of buttons for the dialog. If none of these
// choices are appropriate, simply use GTK_BUTTONS_NONE then call
// gtk_dialog_add_buttons().
//
// > Please note that GTK_BUTTONS_OK, GTK_BUTTONS_YES_NO > and
// GTK_BUTTONS_OK_CANCEL are discouraged by the > GNOME Human Interface
// Guidelines (http://library.gnome.org/devel/hig-book/stable/).
type ButtonsType int

const (
	// ButtonsTypeNone: no buttons at all
	ButtonsTypeNone ButtonsType = 0
	// ButtonsTypeOk: an OK button
	ButtonsTypeOk ButtonsType = 1
	// ButtonsTypeClose: a Close button
	ButtonsTypeClose ButtonsType = 2
	// ButtonsTypeCancel: a Cancel button
	ButtonsTypeCancel ButtonsType = 3
	// ButtonsTypeYesNo yes and No buttons
	ButtonsTypeYesNo ButtonsType = 4
	// ButtonsTypeOkCancel: OK and Cancel buttons
	ButtonsTypeOkCancel ButtonsType = 5
)

func marshalButtonsType(p uintptr) (interface{}, error) {
	return ButtonsType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// CellRendererAccelMode determines if the edited accelerators are GTK
// accelerators. If they are, consumed modifiers are suppressed, only
// accelerators accepted by GTK are allowed, and the accelerators are rendered
// in the same way as they are in menus.
type CellRendererAccelMode int

const (
	// CellRendererAccelModeGTK: GTK accelerators mode
	CellRendererAccelModeGTK CellRendererAccelMode = 0
	// CellRendererAccelModeOther: other accelerator mode
	CellRendererAccelModeOther CellRendererAccelMode = 1
)

func marshalCellRendererAccelMode(p uintptr) (interface{}, error) {
	return CellRendererAccelMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// CellRendererMode identifies how the user can interact with a particular cell.
type CellRendererMode int

const (
	// CellRendererModeInert: the cell is just for display and cannot be
	// interacted with. Note that this doesn’t mean that eg. the row being drawn
	// can’t be selected -- just that a particular element of it cannot be
	// individually modified.
	CellRendererModeInert CellRendererMode = 0
	// CellRendererModeActivatable: the cell can be clicked.
	CellRendererModeActivatable CellRendererMode = 1
	// CellRendererModeEditable: the cell can be edited or otherwise modified.
	CellRendererModeEditable CellRendererMode = 2
)

func marshalCellRendererMode(p uintptr) (interface{}, error) {
	return CellRendererMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ConstraintAttribute: the widget attributes that can be used when creating a
// Constraint.
type ConstraintAttribute int

const (
	// ConstraintAttributeNone: no attribute, used for constant relations
	ConstraintAttributeNone ConstraintAttribute = 0
	// ConstraintAttributeLeft: the left edge of a widget, regardless of text
	// direction
	ConstraintAttributeLeft ConstraintAttribute = 1
	// ConstraintAttributeRight: the right edge of a widget, regardless of text
	// direction
	ConstraintAttributeRight ConstraintAttribute = 2
	// ConstraintAttributeTop: the top edge of a widget
	ConstraintAttributeTop ConstraintAttribute = 3
	// ConstraintAttributeBottom: the bottom edge of a widget
	ConstraintAttributeBottom ConstraintAttribute = 4
	// ConstraintAttributeStart: the leading edge of a widget, depending on text
	// direction; equivalent to GTK_CONSTRAINT_ATTRIBUTE_LEFT for LTR languages,
	// and GTK_CONSTRAINT_ATTRIBUTE_RIGHT for RTL ones
	ConstraintAttributeStart ConstraintAttribute = 5
	// ConstraintAttributeEnd: the trailing edge of a widget, depending on text
	// direction; equivalent to GTK_CONSTRAINT_ATTRIBUTE_RIGHT for LTR
	// languages, and GTK_CONSTRAINT_ATTRIBUTE_LEFT for RTL ones
	ConstraintAttributeEnd ConstraintAttribute = 6
	// ConstraintAttributeWidth: the width of a widget
	ConstraintAttributeWidth ConstraintAttribute = 7
	// ConstraintAttributeHeight: the height of a widget
	ConstraintAttributeHeight ConstraintAttribute = 8
	// ConstraintAttributeCenterX: the center of a widget, on the horizontal
	// axis
	ConstraintAttributeCenterX ConstraintAttribute = 9
	// ConstraintAttributeCenterY: the center of a widget, on the vertical axis
	ConstraintAttributeCenterY ConstraintAttribute = 10
	// ConstraintAttributeBaseline: the baseline of a widget
	ConstraintAttributeBaseline ConstraintAttribute = 11
)

func marshalConstraintAttribute(p uintptr) (interface{}, error) {
	return ConstraintAttribute(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ConstraintRelation: the relation between two terms of a constraint.
type ConstraintRelation int

const (
	// ConstraintRelationLe less than, or equal
	ConstraintRelationLe ConstraintRelation = -1
	// ConstraintRelationEq: equal
	ConstraintRelationEq ConstraintRelation = 0
	// ConstraintRelationGe: greater than, or equal
	ConstraintRelationGe ConstraintRelation = 1
)

func marshalConstraintRelation(p uintptr) (interface{}, error) {
	return ConstraintRelation(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ConstraintStrength: the strength of a constraint, expressed as a symbolic
// constant.
//
// The strength of a Constraint can be expressed with any positive integer; the
// values of this enumeration can be used for readability.
type ConstraintStrength int

const (
	// ConstraintStrengthRequired: the constraint is required towards solving
	// the layout
	ConstraintStrengthRequired ConstraintStrength = 1001001000
	// ConstraintStrengthStrong: a strong constraint
	ConstraintStrengthStrong ConstraintStrength = 1000000000
	// ConstraintStrengthMedium: a medium constraint
	ConstraintStrengthMedium ConstraintStrength = 1000
	// ConstraintStrengthWeak: a weak constraint
	ConstraintStrengthWeak ConstraintStrength = 1
)

func marshalConstraintStrength(p uintptr) (interface{}, error) {
	return ConstraintStrength(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ConstraintVflParserError: domain for VFL parsing errors.
type ConstraintVflParserError int

const (
	// ConstraintVflParserErrorSymbol: invalid or unknown symbol
	ConstraintVflParserErrorSymbol ConstraintVflParserError = 0
	// ConstraintVflParserErrorAttribute: invalid or unknown attribute
	ConstraintVflParserErrorAttribute ConstraintVflParserError = 1
	// ConstraintVflParserErrorView: invalid or unknown view
	ConstraintVflParserErrorView ConstraintVflParserError = 2
	// ConstraintVflParserErrorMetric: invalid or unknown metric
	ConstraintVflParserErrorMetric ConstraintVflParserError = 3
	// ConstraintVflParserErrorPriority: invalid or unknown priority
	ConstraintVflParserErrorPriority ConstraintVflParserError = 4
	// ConstraintVflParserErrorRelation: invalid or unknown relation
	ConstraintVflParserErrorRelation ConstraintVflParserError = 5
)

func marshalConstraintVflParserError(p uintptr) (interface{}, error) {
	return ConstraintVflParserError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// CornerType specifies which corner a child widget should be placed in when
// packed into a ScrolledWindow. This is effectively the opposite of where the
// scroll bars are placed.
type CornerType int

const (
	// CornerTypeTopLeft: place the scrollbars on the right and bottom of the
	// widget (default behaviour).
	CornerTypeTopLeft CornerType = 0
	// CornerTypeBottomLeft: place the scrollbars on the top and right of the
	// widget.
	CornerTypeBottomLeft CornerType = 1
	// CornerTypeTopRight: place the scrollbars on the left and bottom of the
	// widget.
	CornerTypeTopRight CornerType = 2
	// CornerTypeBottomRight: place the scrollbars on the top and left of the
	// widget.
	CornerTypeBottomRight CornerType = 3
)

func marshalCornerType(p uintptr) (interface{}, error) {
	return CornerType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DeleteType: see also: Entry::delete-from-cursor.
type DeleteType int

const (
	// DeleteTypeChars: delete characters.
	DeleteTypeChars DeleteType = 0
	// DeleteTypeWordEnds: delete only the portion of the word to the left/right
	// of cursor if we’re in the middle of a word.
	DeleteTypeWordEnds DeleteType = 1
	// DeleteTypeWords: delete words.
	DeleteTypeWords DeleteType = 2
	// DeleteTypeDisplayLines: delete display-lines. Display-lines refers to the
	// visible lines, with respect to the current line breaks. As opposed to
	// paragraphs, which are defined by line breaks in the input.
	DeleteTypeDisplayLines DeleteType = 3
	// DeleteTypeDisplayLineEnds: delete only the portion of the display-line to
	// the left/right of cursor.
	DeleteTypeDisplayLineEnds DeleteType = 4
	// DeleteTypeParagraphEnds: delete to the end of the paragraph. Like C-k in
	// Emacs (or its reverse).
	DeleteTypeParagraphEnds DeleteType = 5
	// DeleteTypeParagraphs: delete entire line. Like C-k in pico.
	DeleteTypeParagraphs DeleteType = 6
	// DeleteTypeWhitespace: delete only whitespace. Like M-\ in Emacs.
	DeleteTypeWhitespace DeleteType = 7
)

func marshalDeleteType(p uintptr) (interface{}, error) {
	return DeleteType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DirectionType focus movement types.
type DirectionType int

const (
	// DirectionTypeTabForward: move forward.
	DirectionTypeTabForward DirectionType = 0
	// DirectionTypeTabBackward: move backward.
	DirectionTypeTabBackward DirectionType = 1
	// DirectionTypeUp: move up.
	DirectionTypeUp DirectionType = 2
	// DirectionTypeDown: move down.
	DirectionTypeDown DirectionType = 3
	// DirectionTypeLeft: move left.
	DirectionTypeLeft DirectionType = 4
	// DirectionTypeRight: move right.
	DirectionTypeRight DirectionType = 5
)

func marshalDirectionType(p uintptr) (interface{}, error) {
	return DirectionType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

type EditableProperties int

const (
	EditablePropertiesPropText           EditableProperties = 0
	EditablePropertiesPropCursorPosition EditableProperties = 1
	EditablePropertiesPropSelectionBound EditableProperties = 2
	EditablePropertiesPropEditable       EditableProperties = 3
	EditablePropertiesPropWidthChars     EditableProperties = 4
	EditablePropertiesPropMaxWidthChars  EditableProperties = 5
	EditablePropertiesPropXalign         EditableProperties = 6
	EditablePropertiesPropEnableUndo     EditableProperties = 7
	EditablePropertiesNumProperties      EditableProperties = 8
)

func marshalEditableProperties(p uintptr) (interface{}, error) {
	return EditableProperties(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// EntryIconPosition specifies the side of the entry at which an icon is placed.
type EntryIconPosition int

const (
	// EntryIconPositionPrimary: at the beginning of the entry (depending on the
	// text direction).
	EntryIconPositionPrimary EntryIconPosition = 0
	// EntryIconPositionSecondary: at the end of the entry (depending on the
	// text direction).
	EntryIconPositionSecondary EntryIconPosition = 1
)

func marshalEntryIconPosition(p uintptr) (interface{}, error) {
	return EntryIconPosition(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// EventSequenceState describes the state of a EventSequence in a Gesture.
type EventSequenceState int

const (
	// EventSequenceStateNone: the sequence is handled, but not grabbed.
	EventSequenceStateNone EventSequenceState = 0
	// EventSequenceStateClaimed: the sequence is handled and grabbed.
	EventSequenceStateClaimed EventSequenceState = 1
	// EventSequenceStateDenied: the sequence is denied.
	EventSequenceStateDenied EventSequenceState = 2
)

func marshalEventSequenceState(p uintptr) (interface{}, error) {
	return EventSequenceState(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FileChooserAction describes whether a FileChooser is being used to open
// existing files or to save to a possibly new file.
type FileChooserAction int

const (
	// FileChooserActionOpen indicates open mode. The file chooser will only let
	// the user pick an existing file.
	FileChooserActionOpen FileChooserAction = 0
	// FileChooserActionSave indicates save mode. The file chooser will let the
	// user pick an existing file, or type in a new filename.
	FileChooserActionSave FileChooserAction = 1
	// FileChooserActionSelectFolder indicates an Open mode for selecting
	// folders. The file chooser will let the user pick an existing folder.
	FileChooserActionSelectFolder FileChooserAction = 2
)

func marshalFileChooserAction(p uintptr) (interface{}, error) {
	return FileChooserAction(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FileChooserError: these identify the various errors that can occur while
// calling FileChooser functions.
type FileChooserError int

const (
	// FileChooserErrorNonexistent indicates that a file does not exist.
	FileChooserErrorNonexistent FileChooserError = 0
	// FileChooserErrorBadFilename indicates a malformed filename.
	FileChooserErrorBadFilename FileChooserError = 1
	// FileChooserErrorAlreadyExists indicates a duplicate path (e.g. when
	// adding a bookmark).
	FileChooserErrorAlreadyExists FileChooserError = 2
	// FileChooserErrorIncompleteHostname indicates an incomplete hostname (e.g.
	// "http://foo" without a slash after that).
	FileChooserErrorIncompleteHostname FileChooserError = 3
)

func marshalFileChooserError(p uintptr) (interface{}, error) {
	return FileChooserError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FilterChange describes changes in a filter in more detail and allows objects
// using the filter to optimize refiltering items.
//
// If you are writing an implementation and are not sure which value to pass,
// GTK_FILTER_CHANGE_DIFFERENT is always a correct choice.
type FilterChange int

const (
	// FilterChangeDifferent: the filter change cannot be described with any of
	// the other enumeration values.
	FilterChangeDifferent FilterChange = 0
	// FilterChangeLessStrict: the filter is less strict than it was before: All
	// items that it used to return true for still return true, others now may,
	// too.
	FilterChangeLessStrict FilterChange = 1
	// FilterChangeMoreStrict: the filter is more strict than it was before: All
	// items that it used to return false for still return false, others now
	// may, too.
	FilterChangeMoreStrict FilterChange = 2
)

func marshalFilterChange(p uintptr) (interface{}, error) {
	return FilterChange(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FilterMatch describes the known strictness of a filter.
//
// Note that for filters where the strictness is not known,
// GTK_FILTER_MATCH_SOME is always an acceptable value, even if a filter does
// match all or no items.
type FilterMatch int

const (
	// FilterMatchSome: the filter matches some items, gtk_filter_match() may
	// return true or false
	FilterMatchSome FilterMatch = 0
	// FilterMatchNone: the filter does not match any item, gtk_filter_match()
	// will always return false.
	FilterMatchNone FilterMatch = 1
	// FilterMatchAll: the filter matches all items, gtk_filter_match() will
	// alays return true.
	FilterMatchAll FilterMatch = 2
)

func marshalFilterMatch(p uintptr) (interface{}, error) {
	return FilterMatch(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// IconSize: built-in icon sizes.
//
// Icon sizes default to being inherited. Where they cannot be inherited, text
// size is the default.
//
// All widgets which use GtkIconSize set the normal-icons or large-icons style
// classes correspondingly, and let themes determine the actual size to be used
// with the -gtk-icon-size CSS property.
type IconSize int

const (
	// IconSizeInherit: keep the size of the parent element
	IconSizeInherit IconSize = 0
	// IconSizeNormal: size similar to text size
	IconSizeNormal IconSize = 1
	// IconSizeLarge: large size, for example in an icon view
	IconSizeLarge IconSize = 2
)

func marshalIconSize(p uintptr) (interface{}, error) {
	return IconSize(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// IconThemeError: error codes for GtkIconTheme operations.
type IconThemeError int

const (
	// IconThemeErrorNotFound: the icon specified does not exist in the theme
	IconThemeErrorNotFound IconThemeError = 0
	// IconThemeErrorFailed: an unspecified error occurred.
	IconThemeErrorFailed IconThemeError = 1
)

func marshalIconThemeError(p uintptr) (interface{}, error) {
	return IconThemeError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// IconViewDropPosition: an enum for determining where a dropped item goes.
type IconViewDropPosition int

const (
	// IconViewDropPositionNoDrop: no drop possible
	IconViewDropPositionNoDrop IconViewDropPosition = 0
	// IconViewDropPositionDropInto: dropped item replaces the item
	IconViewDropPositionDropInto IconViewDropPosition = 1
	// IconViewDropPositionDropLeft: dropped item is inserted to the left
	IconViewDropPositionDropLeft IconViewDropPosition = 2
	// IconViewDropPositionDropRight: dropped item is inserted to the right
	IconViewDropPositionDropRight IconViewDropPosition = 3
	// IconViewDropPositionDropAbove: dropped item is inserted above
	IconViewDropPositionDropAbove IconViewDropPosition = 4
	// IconViewDropPositionDropBelow: dropped item is inserted below
	IconViewDropPositionDropBelow IconViewDropPosition = 5
)

func marshalIconViewDropPosition(p uintptr) (interface{}, error) {
	return IconViewDropPosition(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ImageType describes the image data representation used by a Image. If you
// want to get the image from the widget, you can only get the currently-stored
// representation. e.g. if the gtk_image_get_storage_type() returns
// K_IMAGE_PAINTABLE, then you can call gtk_image_get_paintable(). For empty
// images, you can request any storage type (call any of the "get" functions),
// but they will all return nil values.
type ImageType int

const (
	// ImageTypeEmpty: there is no image displayed by the widget
	ImageTypeEmpty ImageType = 0
	// ImageTypeIconName: the widget contains a named icon
	ImageTypeIconName ImageType = 1
	// ImageTypeGIcon: the widget contains a #GIcon
	ImageTypeGIcon ImageType = 2
	// ImageTypePaintable: the widget contains a Paintable
	ImageTypePaintable ImageType = 3
)

func marshalImageType(p uintptr) (interface{}, error) {
	return ImageType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// InputPurpose describes primary purpose of the input widget. This information
// is useful for on-screen keyboards and similar input methods to decide which
// keys should be presented to the user.
//
// Note that the purpose is not meant to impose a totally strict rule about
// allowed characters, and does not replace input validation. It is fine for an
// on-screen keyboard to let the user override the character set restriction
// that is expressed by the purpose. The application is expected to validate the
// entry contents, even if it specified a purpose.
//
// The difference between GTK_INPUT_PURPOSE_DIGITS and GTK_INPUT_PURPOSE_NUMBER
// is that the former accepts only digits while the latter also some punctuation
// (like commas or points, plus, minus) and “e” or “E” as in 3.14E+000.
//
// This enumeration may be extended in the future; input methods should
// interpret unknown values as “free form”.
type InputPurpose int

const (
	// InputPurposeFreeForm: allow any character
	InputPurposeFreeForm InputPurpose = 0
	// InputPurposeAlpha: allow only alphabetic characters
	InputPurposeAlpha InputPurpose = 1
	// InputPurposeDigits: allow only digits
	InputPurposeDigits InputPurpose = 2
	// InputPurposeNumber: edited field expects numbers
	InputPurposeNumber InputPurpose = 3
	// InputPurposePhone: edited field expects phone number
	InputPurposePhone InputPurpose = 4
	// InputPurposeURL: edited field expects URL
	InputPurposeURL InputPurpose = 5
	// InputPurposeEmail: edited field expects email address
	InputPurposeEmail InputPurpose = 6
	// InputPurposeName: edited field expects the name of a person
	InputPurposeName InputPurpose = 7
	// InputPurposePassword: like GTK_INPUT_PURPOSE_FREE_FORM, but characters
	// are hidden
	InputPurposePassword InputPurpose = 8
	// InputPurposePin: like GTK_INPUT_PURPOSE_DIGITS, but characters are hidden
	InputPurposePin InputPurpose = 9
	// InputPurposeTerminal: allow any character, in addition to control codes
	InputPurposeTerminal InputPurpose = 10
)

func marshalInputPurpose(p uintptr) (interface{}, error) {
	return InputPurpose(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// Justification: used for justifying the text inside a Label widget.
type Justification int

const (
	// JustificationLeft: the text is placed at the left edge of the label.
	JustificationLeft Justification = 0
	// JustificationRight: the text is placed at the right edge of the label.
	JustificationRight Justification = 1
	// JustificationCenter: the text is placed in the center of the label.
	JustificationCenter Justification = 2
	// JustificationFill: the text is placed is distributed across the label.
	JustificationFill Justification = 3
)

func marshalJustification(p uintptr) (interface{}, error) {
	return Justification(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// LevelBarMode describes how LevelBar contents should be rendered. Note that
// this enumeration could be extended with additional modes in the future.
type LevelBarMode int

const (
	// LevelBarModeContinuous: the bar has a continuous mode
	LevelBarModeContinuous LevelBarMode = 0
	// LevelBarModeDiscrete: the bar has a discrete mode
	LevelBarModeDiscrete LevelBarMode = 1
)

func marshalLevelBarMode(p uintptr) (interface{}, error) {
	return LevelBarMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// License: the type of license for an application.
//
// This enumeration can be expanded at later date.
type License int

const (
	// LicenseUnknown: no license specified
	LicenseUnknown License = 0
	// LicenseCustom: a license text is going to be specified by the developer
	LicenseCustom License = 1
	// LicenseGPL20: the GNU General Public License, version 2.0 or later
	LicenseGPL20 License = 2
	// LicenseGPL30: the GNU General Public License, version 3.0 or later
	LicenseGPL30 License = 3
	// LicenseLGPL21: the GNU Lesser General Public License, version 2.1 or
	// later
	LicenseLGPL21 License = 4
	// LicenseLGPL30: the GNU Lesser General Public License, version 3.0 or
	// later
	LicenseLGPL30 License = 5
	// LicenseBSD: the BSD standard license
	LicenseBSD License = 6
	// LicenseMITX11: the MIT/X11 standard license
	LicenseMITX11 License = 7
	// LicenseArtistic: the Artistic License, version 2.0
	LicenseArtistic License = 8
	// LicenseGPL20Only: the GNU General Public License, version 2.0 only
	LicenseGPL20Only License = 9
	// LicenseGPL30Only: the GNU General Public License, version 3.0 only
	LicenseGPL30Only License = 10
	// LicenseLGPL21Only: the GNU Lesser General Public License, version 2.1
	// only
	LicenseLGPL21Only License = 11
	// LicenseLGPL30Only: the GNU Lesser General Public License, version 3.0
	// only
	LicenseLGPL30Only License = 12
	// LicenseAGPL30: the GNU Affero General Public License, version 3.0 or
	// later
	LicenseAGPL30 License = 13
	// LicenseAGPL30Only: the GNU Affero General Public License, version 3.0
	// only
	LicenseAGPL30Only License = 14
	// LicenseBSD3: the 3-clause BSD licence
	LicenseBSD3 License = 15
	// LicenseApache20: the Apache License, version 2.0
	LicenseApache20 License = 16
	// LicenseMPL20: the Mozilla Public License, version 2.0
	LicenseMPL20 License = 17
)

func marshalLicense(p uintptr) (interface{}, error) {
	return License(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// MessageType: the type of message being displayed in the dialog.
type MessageType int

const (
	// MessageTypeInfo: informational message
	MessageTypeInfo MessageType = 0
	// MessageTypeWarning: non-fatal warning message
	MessageTypeWarning MessageType = 1
	// MessageTypeQuestion: question requiring a choice
	MessageTypeQuestion MessageType = 2
	// MessageTypeError: fatal error message
	MessageTypeError MessageType = 3
	// MessageTypeOther: none of the above
	MessageTypeOther MessageType = 4
)

func marshalMessageType(p uintptr) (interface{}, error) {
	return MessageType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

type MovementStep int

const (
	// MovementStepLogicalPositions: move forward or back by graphemes
	MovementStepLogicalPositions MovementStep = 0
	// MovementStepVisualPositions: move left or right by graphemes
	MovementStepVisualPositions MovementStep = 1
	// MovementStepWords: move forward or back by words
	MovementStepWords MovementStep = 2
	// MovementStepDisplayLines: move up or down lines (wrapped lines)
	MovementStepDisplayLines MovementStep = 3
	// MovementStepDisplayLineEnds: move to either end of a line
	MovementStepDisplayLineEnds MovementStep = 4
	// MovementStepParagraphs: move up or down paragraphs (newline-ended lines)
	MovementStepParagraphs MovementStep = 5
	// MovementStepParagraphEnds: move to either end of a paragraph
	MovementStepParagraphEnds MovementStep = 6
	// MovementStepPages: move by pages
	MovementStepPages MovementStep = 7
	// MovementStepBufferEnds: move to ends of the buffer
	MovementStepBufferEnds MovementStep = 8
	// MovementStepHorizontalPages: move horizontally by pages
	MovementStepHorizontalPages MovementStep = 9
)

func marshalMovementStep(p uintptr) (interface{}, error) {
	return MovementStep(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// NotebookTab: the parameter used in the action signals of Notebook.
type NotebookTab int

const (
	// NotebookTabFirst: the first tab in the notebook
	NotebookTabFirst NotebookTab = 0
	// NotebookTabLast: the last tab in the notebook
	NotebookTabLast NotebookTab = 1
)

func marshalNotebookTab(p uintptr) (interface{}, error) {
	return NotebookTab(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// NumberUpLayout: used to determine the layout of pages on a sheet when
// printing multiple pages per sheet.
type NumberUpLayout int

const (
	// NumberUpLayoutLrtb: ! (layout-lrtb.png)
	NumberUpLayoutLrtb NumberUpLayout = 0
	// NumberUpLayoutLrbt: ! (layout-lrbt.png)
	NumberUpLayoutLrbt NumberUpLayout = 1
	// NumberUpLayoutRltb: ! (layout-rltb.png)
	NumberUpLayoutRltb NumberUpLayout = 2
	// NumberUpLayoutRlbt: ! (layout-rlbt.png)
	NumberUpLayoutRlbt NumberUpLayout = 3
	// NumberUpLayoutTblr: ! (layout-tblr.png)
	NumberUpLayoutTblr NumberUpLayout = 4
	// NumberUpLayoutTbrl: ! (layout-tbrl.png)
	NumberUpLayoutTbrl NumberUpLayout = 5
	// NumberUpLayoutBtlr: ! (layout-btlr.png)
	NumberUpLayoutBtlr NumberUpLayout = 6
	// NumberUpLayoutBtrl: ! (layout-btrl.png)
	NumberUpLayoutBtrl NumberUpLayout = 7
)

func marshalNumberUpLayout(p uintptr) (interface{}, error) {
	return NumberUpLayout(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// Ordering describes the way two values can be compared.
//
// These values can be used with a Func. However, a Func is allowed to return
// any integer values. For converting such a value to a Ordering, use
// gtk_ordering_from_cmpfunc().
type Ordering int

const (
	// OrderingSmaller: the first value is smaller than the second
	OrderingSmaller Ordering = -1
	// OrderingEqual: the two values are equal
	OrderingEqual Ordering = 0
	// OrderingLarger: the first value is larger than the second
	OrderingLarger Ordering = 1
)

func marshalOrdering(p uintptr) (interface{}, error) {
	return Ordering(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// Orientation represents the orientation of widgets and other objects which can
// be switched between horizontal and vertical orientation on the fly, like Box
// or GesturePan.
type Orientation int

const (
	// OrientationHorizontal: the element is in horizontal orientation.
	OrientationHorizontal Orientation = 0
	// OrientationVertical: the element is in vertical orientation.
	OrientationVertical Orientation = 1
)

func marshalOrientation(p uintptr) (interface{}, error) {
	return Orientation(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// Overflow defines how content overflowing a given area should be handled, such
// as with gtk_widget_set_overflow(). This property is modeled after the CSS
// overflow property, but implements it only partially.
type Overflow int

const (
	// OverflowVisible: no change is applied. Content is drawn at the specified
	// position.
	OverflowVisible Overflow = 0
	// OverflowHidden: content is clipped to the bounds of the area. Content
	// outside the area is not drawn and cannot be interacted with.
	OverflowHidden Overflow = 1
)

func marshalOverflow(p uintptr) (interface{}, error) {
	return Overflow(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PackType represents the packing location of a children in its parent. See
// WindowControls for example.
type PackType int

const (
	// PackTypeStart: the child is packed into the start of the widget
	PackTypeStart PackType = 0
	// PackTypeEnd: the child is packed into the end of the widget
	PackTypeEnd PackType = 1
)

func marshalPackType(p uintptr) (interface{}, error) {
	return PackType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PadActionType: the type of a pad action.
type PadActionType int

const (
	// PadActionTypeButton: action is triggered by a pad button
	PadActionTypeButton PadActionType = 0
	// PadActionTypeRing: action is triggered by a pad ring
	PadActionTypeRing PadActionType = 1
	// PadActionTypeStrip: action is triggered by a pad strip
	PadActionTypeStrip PadActionType = 2
)

func marshalPadActionType(p uintptr) (interface{}, error) {
	return PadActionType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PageOrientation: see also gtk_print_settings_set_orientation().
type PageOrientation int

const (
	// PageOrientationPortrait: portrait mode.
	PageOrientationPortrait PageOrientation = 0
	// PageOrientationLandscape: landscape mode.
	PageOrientationLandscape PageOrientation = 1
	// PageOrientationReversePortrait: reverse portrait mode.
	PageOrientationReversePortrait PageOrientation = 2
	// PageOrientationReverseLandscape: reverse landscape mode.
	PageOrientationReverseLandscape PageOrientation = 3
)

func marshalPageOrientation(p uintptr) (interface{}, error) {
	return PageOrientation(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PageSet: see also gtk_print_job_set_page_set().
type PageSet int

const (
	// PageSetAll: all pages.
	PageSetAll PageSet = 0
	// PageSetEven: even pages.
	PageSetEven PageSet = 1
	// PageSetOdd: odd pages.
	PageSetOdd PageSet = 2
)

func marshalPageSet(p uintptr) (interface{}, error) {
	return PageSet(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PanDirection describes the panning direction of a GesturePan
type PanDirection int

const (
	// PanDirectionLeft: panned towards the left
	PanDirectionLeft PanDirection = 0
	// PanDirectionRight: panned towards the right
	PanDirectionRight PanDirection = 1
	// PanDirectionUp: panned upwards
	PanDirectionUp PanDirection = 2
	// PanDirectionDown: panned downwards
	PanDirectionDown PanDirection = 3
)

func marshalPanDirection(p uintptr) (interface{}, error) {
	return PanDirection(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PolicyType determines how the size should be computed to achieve the one of
// the visibility mode for the scrollbars.
type PolicyType int

const (
	// PolicyTypeAlways: the scrollbar is always visible. The view size is
	// independent of the content.
	PolicyTypeAlways PolicyType = 0
	// PolicyTypeAutomatic: the scrollbar will appear and disappear as
	// necessary. For example, when all of a TreeView can not be seen.
	PolicyTypeAutomatic PolicyType = 1
	// PolicyTypeNever: the scrollbar should never appear. In this mode the
	// content determines the size.
	PolicyTypeNever PolicyType = 2
	// PolicyTypeExternal: don't show a scrollbar, but don't force the size to
	// follow the content. This can be used e.g. to make multiple scrolled
	// windows share a scrollbar.
	PolicyTypeExternal PolicyType = 3
)

func marshalPolicyType(p uintptr) (interface{}, error) {
	return PolicyType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PositionType describes which edge of a widget a certain feature is positioned
// at, e.g. the tabs of a Notebook, or the label of a Scale.
type PositionType int

const (
	// PositionTypeLeft: the feature is at the left edge.
	PositionTypeLeft PositionType = 0
	// PositionTypeRight: the feature is at the right edge.
	PositionTypeRight PositionType = 1
	// PositionTypeTop: the feature is at the top edge.
	PositionTypeTop PositionType = 2
	// PositionTypeBottom: the feature is at the bottom edge.
	PositionTypeBottom PositionType = 3
)

func marshalPositionType(p uintptr) (interface{}, error) {
	return PositionType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PrintDuplex: see also gtk_print_settings_set_duplex().
type PrintDuplex int

const (
	// PrintDuplexSimplex: no duplex.
	PrintDuplexSimplex PrintDuplex = 0
	// PrintDuplexHorizontal: horizontal duplex.
	PrintDuplexHorizontal PrintDuplex = 1
	// PrintDuplexVertical: vertical duplex.
	PrintDuplexVertical PrintDuplex = 2
)

func marshalPrintDuplex(p uintptr) (interface{}, error) {
	return PrintDuplex(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PrintError: error codes that identify various errors that can occur while
// using the GTK printing support.
type PrintError int

const (
	// PrintErrorGeneral: an unspecified error occurred.
	PrintErrorGeneral PrintError = 0
	// PrintErrorInternalError: an internal error occurred.
	PrintErrorInternalError PrintError = 1
	// PrintErrorNOMEM: a memory allocation failed.
	PrintErrorNOMEM PrintError = 2
	// PrintErrorInvalidFile: an error occurred while loading a page setup or
	// paper size from a key file.
	PrintErrorInvalidFile PrintError = 3
)

func marshalPrintError(p uintptr) (interface{}, error) {
	return PrintError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PrintOperationAction: the @action parameter to gtk_print_operation_run()
// determines what action the print operation should perform.
type PrintOperationAction int

const (
	// PrintOperationActionPrintDialog: show the print dialog.
	PrintOperationActionPrintDialog PrintOperationAction = 0
	// PrintOperationActionPrint: start to print without showing the print
	// dialog, based on the current print settings.
	PrintOperationActionPrint PrintOperationAction = 1
	// PrintOperationActionPreview: show the print preview.
	PrintOperationActionPreview PrintOperationAction = 2
	// PrintOperationActionExport: export to a file. This requires the
	// export-filename property to be set.
	PrintOperationActionExport PrintOperationAction = 3
)

func marshalPrintOperationAction(p uintptr) (interface{}, error) {
	return PrintOperationAction(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PrintOperationResult: a value of this type is returned by
// gtk_print_operation_run().
type PrintOperationResult int

const (
	// PrintOperationResultError: an error has occurred.
	PrintOperationResultError PrintOperationResult = 0
	// PrintOperationResultApply: the print settings should be stored.
	PrintOperationResultApply PrintOperationResult = 1
	// PrintOperationResultCancel: the print operation has been canceled, the
	// print settings should not be stored.
	PrintOperationResultCancel PrintOperationResult = 2
	// PrintOperationResultInProgress: the print operation is not complete yet.
	// This value will only be returned when running asynchronously.
	PrintOperationResultInProgress PrintOperationResult = 3
)

func marshalPrintOperationResult(p uintptr) (interface{}, error) {
	return PrintOperationResult(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PrintPages: see also gtk_print_job_set_pages()
type PrintPages int

const (
	// PrintPagesAll: all pages.
	PrintPagesAll PrintPages = 0
	// PrintPagesCurrent: current page.
	PrintPagesCurrent PrintPages = 1
	// PrintPagesRanges: range of pages.
	PrintPagesRanges PrintPages = 2
	// PrintPagesSelection: selected pages.
	PrintPagesSelection PrintPages = 3
)

func marshalPrintPages(p uintptr) (interface{}, error) {
	return PrintPages(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PrintQuality: see also gtk_print_settings_set_quality().
type PrintQuality int

const (
	// PrintQualityLow: low quality.
	PrintQualityLow PrintQuality = 0
	// PrintQualityNormal: normal quality.
	PrintQualityNormal PrintQuality = 1
	// PrintQualityHigh: high quality.
	PrintQualityHigh PrintQuality = 2
	// PrintQualityDraft: draft quality.
	PrintQualityDraft PrintQuality = 3
)

func marshalPrintQuality(p uintptr) (interface{}, error) {
	return PrintQuality(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PrintStatus: the status gives a rough indication of the completion of a
// running print operation.
type PrintStatus int

const (
	// PrintStatusInitial: the printing has not started yet; this status is set
	// initially, and while the print dialog is shown.
	PrintStatusInitial PrintStatus = 0
	// PrintStatusPreparing: this status is set while the begin-print signal is
	// emitted and during pagination.
	PrintStatusPreparing PrintStatus = 1
	// PrintStatusGeneratingData: this status is set while the pages are being
	// rendered.
	PrintStatusGeneratingData PrintStatus = 2
	// PrintStatusSendingData: the print job is being sent off to the printer.
	PrintStatusSendingData PrintStatus = 3
	// PrintStatusPending: the print job has been sent to the printer, but is
	// not printed for some reason, e.g. the printer may be stopped.
	PrintStatusPending PrintStatus = 4
	// PrintStatusPendingIssue: some problem has occurred during printing, e.g.
	// a paper jam.
	PrintStatusPendingIssue PrintStatus = 5
	// PrintStatusPrinting: the printer is processing the print job.
	PrintStatusPrinting PrintStatus = 6
	// PrintStatusFinished: the printing has been completed successfully.
	PrintStatusFinished PrintStatus = 7
	// PrintStatusFinishedAborted: the printing has been aborted.
	PrintStatusFinishedAborted PrintStatus = 8
)

func marshalPrintStatus(p uintptr) (interface{}, error) {
	return PrintStatus(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PropagationLimit describes limits of a EventController for handling events
// targeting other widgets.
type PropagationLimit int

const (
	// PropagationLimitNone events are handled regardless of what their target
	// is.
	PropagationLimitNone PropagationLimit = 0
	// PropagationLimitSameNative events are only handled if their target is in
	// the same Native as the event controllers widget. Note that some event
	// types have two targets (origin and destination).
	PropagationLimitSameNative PropagationLimit = 1
)

func marshalPropagationLimit(p uintptr) (interface{}, error) {
	return PropagationLimit(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PropagationPhase describes the stage at which events are fed into a
// EventController.
type PropagationPhase int

const (
	// PropagationPhaseNone events are not delivered.
	PropagationPhaseNone PropagationPhase = 0
	// PropagationPhaseCapture events are delivered in the capture phase. The
	// capture phase happens before the bubble phase, runs from the toplevel
	// down to the event widget. This option should only be used on containers
	// that might possibly handle events before their children do.
	PropagationPhaseCapture PropagationPhase = 1
	// PropagationPhaseBubble events are delivered in the bubble phase. The
	// bubble phase happens after the capture phase, and before the default
	// handlers are run. This phase runs from the event widget, up to the
	// toplevel.
	PropagationPhaseBubble PropagationPhase = 2
	// PropagationPhaseTarget events are delivered in the default widget event
	// handlers, note that widget implementations must chain up on button,
	// motion, touch and grab broken handlers for controllers in this phase to
	// be run.
	PropagationPhaseTarget PropagationPhase = 3
)

func marshalPropagationPhase(p uintptr) (interface{}, error) {
	return PropagationPhase(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// RecentManagerError: error codes for RecentManager operations
type RecentManagerError int

const (
	// RecentManagerErrorNotFound: the URI specified does not exists in the
	// recently used resources list.
	RecentManagerErrorNotFound RecentManagerError = 0
	// RecentManagerErrorInvalidURI: the URI specified is not valid.
	RecentManagerErrorInvalidURI RecentManagerError = 1
	// RecentManagerErrorInvalidEncoding: the supplied string is not UTF-8
	// encoded.
	RecentManagerErrorInvalidEncoding RecentManagerError = 2
	// RecentManagerErrorNotRegistered: no application has registered the
	// specified item.
	RecentManagerErrorNotRegistered RecentManagerError = 3
	// RecentManagerErrorRead: failure while reading the recently used resources
	// file.
	RecentManagerErrorRead RecentManagerError = 4
	// RecentManagerErrorWrite: failure while writing the recently used
	// resources file.
	RecentManagerErrorWrite RecentManagerError = 5
	// RecentManagerErrorUnknown: unspecified error.
	RecentManagerErrorUnknown RecentManagerError = 6
)

func marshalRecentManagerError(p uintptr) (interface{}, error) {
	return RecentManagerError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ResponseType: predefined values for use as response ids in
// gtk_dialog_add_button(). All predefined values are negative; GTK leaves
// values of 0 or greater for application-defined response ids.
type ResponseType int

const (
	// ResponseTypeNone: returned if an action widget has no response id, or if
	// the dialog gets programmatically hidden or destroyed
	ResponseTypeNone ResponseType = -1
	// ResponseTypeReject: generic response id, not used by GTK dialogs
	ResponseTypeReject ResponseType = -2
	// ResponseTypeAccept: generic response id, not used by GTK dialogs
	ResponseTypeAccept ResponseType = -3
	// ResponseTypeDeleteEvent: returned if the dialog is deleted
	ResponseTypeDeleteEvent ResponseType = -4
	// ResponseTypeOk: returned by OK buttons in GTK dialogs
	ResponseTypeOk ResponseType = -5
	// ResponseTypeCancel: returned by Cancel buttons in GTK dialogs
	ResponseTypeCancel ResponseType = -6
	// ResponseTypeClose: returned by Close buttons in GTK dialogs
	ResponseTypeClose ResponseType = -7
	// ResponseTypeYes: returned by Yes buttons in GTK dialogs
	ResponseTypeYes ResponseType = -8
	// ResponseTypeNo: returned by No buttons in GTK dialogs
	ResponseTypeNo ResponseType = -9
	// ResponseTypeApply: returned by Apply buttons in GTK dialogs
	ResponseTypeApply ResponseType = -10
	// ResponseTypeHelp: returned by Help buttons in GTK dialogs
	ResponseTypeHelp ResponseType = -11
)

func marshalResponseType(p uintptr) (interface{}, error) {
	return ResponseType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// RevealerTransitionType: these enumeration values describe the possible
// transitions when the child of a Revealer widget is shown or hidden.
type RevealerTransitionType int

const (
	// RevealerTransitionTypeNone: no transition
	RevealerTransitionTypeNone RevealerTransitionType = 0
	// RevealerTransitionTypeCrossfade: fade in
	RevealerTransitionTypeCrossfade RevealerTransitionType = 1
	// RevealerTransitionTypeSlideRight: slide in from the left
	RevealerTransitionTypeSlideRight RevealerTransitionType = 2
	// RevealerTransitionTypeSlideLeft: slide in from the right
	RevealerTransitionTypeSlideLeft RevealerTransitionType = 3
	// RevealerTransitionTypeSlideUp: slide in from the bottom
	RevealerTransitionTypeSlideUp RevealerTransitionType = 4
	// RevealerTransitionTypeSlideDown: slide in from the top
	RevealerTransitionTypeSlideDown RevealerTransitionType = 5
	// RevealerTransitionTypeSwingRight: floop in from the left
	RevealerTransitionTypeSwingRight RevealerTransitionType = 6
	// RevealerTransitionTypeSwingLeft: floop in from the right
	RevealerTransitionTypeSwingLeft RevealerTransitionType = 7
	// RevealerTransitionTypeSwingUp: floop in from the bottom
	RevealerTransitionTypeSwingUp RevealerTransitionType = 8
	// RevealerTransitionTypeSwingDown: floop in from the top
	RevealerTransitionTypeSwingDown RevealerTransitionType = 9
)

func marshalRevealerTransitionType(p uintptr) (interface{}, error) {
	return RevealerTransitionType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

type ScrollStep int

const (
	// ScrollStepSteps: scroll in steps.
	ScrollStepSteps ScrollStep = 0
	// ScrollStepPages: scroll by pages.
	ScrollStepPages ScrollStep = 1
	// ScrollStepEnds: scroll to ends.
	ScrollStepEnds ScrollStep = 2
	// ScrollStepHorizontalSteps: scroll in horizontal steps.
	ScrollStepHorizontalSteps ScrollStep = 3
	// ScrollStepHorizontalPages: scroll by horizontal pages.
	ScrollStepHorizontalPages ScrollStep = 4
	// ScrollStepHorizontalEnds: scroll to the horizontal ends.
	ScrollStepHorizontalEnds ScrollStep = 5
)

func marshalScrollStep(p uintptr) (interface{}, error) {
	return ScrollStep(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ScrollType: scrolling types.
type ScrollType int

const (
	// ScrollTypeNone: no scrolling.
	ScrollTypeNone ScrollType = 0
	// ScrollTypeJump: jump to new location.
	ScrollTypeJump ScrollType = 1
	// ScrollTypeStepBackward: step backward.
	ScrollTypeStepBackward ScrollType = 2
	// ScrollTypeStepForward: step forward.
	ScrollTypeStepForward ScrollType = 3
	// ScrollTypePageBackward: page backward.
	ScrollTypePageBackward ScrollType = 4
	// ScrollTypePageForward: page forward.
	ScrollTypePageForward ScrollType = 5
	// ScrollTypeStepUp: step up.
	ScrollTypeStepUp ScrollType = 6
	// ScrollTypeStepDown: step down.
	ScrollTypeStepDown ScrollType = 7
	// ScrollTypePageUp: page up.
	ScrollTypePageUp ScrollType = 8
	// ScrollTypePageDown: page down.
	ScrollTypePageDown ScrollType = 9
	// ScrollTypeStepLeft: step to the left.
	ScrollTypeStepLeft ScrollType = 10
	// ScrollTypeStepRight: step to the right.
	ScrollTypeStepRight ScrollType = 11
	// ScrollTypePageLeft: page to the left.
	ScrollTypePageLeft ScrollType = 12
	// ScrollTypePageRight: page to the right.
	ScrollTypePageRight ScrollType = 13
	// ScrollTypeStart: scroll to start.
	ScrollTypeStart ScrollType = 14
	// ScrollTypeEnd: scroll to end.
	ScrollTypeEnd ScrollType = 15
)

func marshalScrollType(p uintptr) (interface{}, error) {
	return ScrollType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ScrollablePolicy defines the policy to be used in a scrollable widget when
// updating the scrolled window adjustments in a given orientation.
type ScrollablePolicy int

const (
	// ScrollablePolicyMinimum: scrollable adjustments are based on the minimum
	// size
	ScrollablePolicyMinimum ScrollablePolicy = 0
	// ScrollablePolicyNatural: scrollable adjustments are based on the natural
	// size
	ScrollablePolicyNatural ScrollablePolicy = 1
)

func marshalScrollablePolicy(p uintptr) (interface{}, error) {
	return ScrollablePolicy(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SelectionMode: used to control what selections users are allowed to make.
type SelectionMode int

const (
	// SelectionModeNone: no selection is possible.
	SelectionModeNone SelectionMode = 0
	// SelectionModeSingle: zero or one element may be selected.
	SelectionModeSingle SelectionMode = 1
	// SelectionModeBrowse: exactly one element is selected. In some
	// circumstances, such as initially or during a search operation, it’s
	// possible for no element to be selected with GTK_SELECTION_BROWSE. What is
	// really enforced is that the user can’t deselect a currently selected
	// element except by selecting another element.
	SelectionModeBrowse SelectionMode = 2
	// SelectionModeMultiple: any number of elements may be selected. The Ctrl
	// key may be used to enlarge the selection, and Shift key to select between
	// the focus and the child pointed to. Some widgets may also allow
	// Click-drag to select a range of elements.
	SelectionModeMultiple SelectionMode = 3
)

func marshalSelectionMode(p uintptr) (interface{}, error) {
	return SelectionMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SensitivityType determines how GTK handles the sensitivity of various
// controls, such as combo box buttons.
type SensitivityType int

const (
	// SensitivityTypeAuto: the control is made insensitive if no action can be
	// triggered
	SensitivityTypeAuto SensitivityType = 0
	// SensitivityTypeOn: the control is always sensitive
	SensitivityTypeOn SensitivityType = 1
	// SensitivityTypeOff: the control is always insensitive
	SensitivityTypeOff SensitivityType = 2
)

func marshalSensitivityType(p uintptr) (interface{}, error) {
	return SensitivityType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ShortcutScope describes where Shortcuts added to a ShortcutController get
// handled.
type ShortcutScope int

const (
	// ShortcutScopeLocal shortcuts are handled inside the widget the controller
	// belongs to.
	ShortcutScopeLocal ShortcutScope = 0
	// ShortcutScopeManaged shortcuts are handled by the first ancestor that is
	// a ShortcutManager
	ShortcutScopeManaged ShortcutScope = 1
	// ShortcutScopeGlobal shortcuts are handled by the root widget.
	ShortcutScopeGlobal ShortcutScope = 2
)

func marshalShortcutScope(p uintptr) (interface{}, error) {
	return ShortcutScope(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ShortcutType: gtkShortcutType specifies the kind of shortcut that is being
// described. More values may be added to this enumeration over time.
type ShortcutType int

const (
	// ShortcutTypeAccelerator: the shortcut is a keyboard accelerator. The
	// ShortcutsShortcut:accelerator property will be used.
	ShortcutTypeAccelerator ShortcutType = 0
	// ShortcutTypeGesturePinch: the shortcut is a pinch gesture. GTK+ provides
	// an icon and subtitle.
	ShortcutTypeGesturePinch ShortcutType = 1
	// ShortcutTypeGestureStretch: the shortcut is a stretch gesture. GTK+
	// provides an icon and subtitle.
	ShortcutTypeGestureStretch ShortcutType = 2
	// ShortcutTypeGestureRotateClockwise: the shortcut is a clockwise rotation
	// gesture. GTK+ provides an icon and subtitle.
	ShortcutTypeGestureRotateClockwise ShortcutType = 3
	// ShortcutTypeGestureRotateCounterclockwise: the shortcut is a
	// counterclockwise rotation gesture. GTK+ provides an icon and subtitle.
	ShortcutTypeGestureRotateCounterclockwise ShortcutType = 4
	// ShortcutTypeGestureTwoFingerSwipeLeft: the shortcut is a two-finger swipe
	// gesture. GTK+ provides an icon and subtitle.
	ShortcutTypeGestureTwoFingerSwipeLeft ShortcutType = 5
	// ShortcutTypeGestureTwoFingerSwipeRight: the shortcut is a two-finger
	// swipe gesture. GTK+ provides an icon and subtitle.
	ShortcutTypeGestureTwoFingerSwipeRight ShortcutType = 6
	// ShortcutTypeGesture: the shortcut is a gesture. The
	// ShortcutsShortcut:icon property will be used.
	ShortcutTypeGesture ShortcutType = 7
	// ShortcutTypeGestureSwipeLeft: the shortcut is a swipe gesture. GTK+
	// provides an icon and subtitle.
	ShortcutTypeGestureSwipeLeft ShortcutType = 8
	// ShortcutTypeGestureSwipeRight: the shortcut is a swipe gesture. GTK+
	// provides an icon and subtitle.
	ShortcutTypeGestureSwipeRight ShortcutType = 9
)

func marshalShortcutType(p uintptr) (interface{}, error) {
	return ShortcutType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SizeGroupMode: the mode of the size group determines the directions in which
// the size group affects the requested sizes of its component widgets.
type SizeGroupMode int

const (
	// SizeGroupModeNone: group has no effect
	SizeGroupModeNone SizeGroupMode = 0
	// SizeGroupModeHorizontal: group affects horizontal requisition
	SizeGroupModeHorizontal SizeGroupMode = 1
	// SizeGroupModeVertical: group affects vertical requisition
	SizeGroupModeVertical SizeGroupMode = 2
	// SizeGroupModeBoth: group affects both horizontal and vertical requisition
	SizeGroupModeBoth SizeGroupMode = 3
)

func marshalSizeGroupMode(p uintptr) (interface{}, error) {
	return SizeGroupMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SizeRequestMode specifies a preference for height-for-width or
// width-for-height geometry management.
type SizeRequestMode int

const (
	// SizeRequestModeHeightForWidth: prefer height-for-width geometry
	// management
	SizeRequestModeHeightForWidth SizeRequestMode = 0
	// SizeRequestModeWidthForHeight: prefer width-for-height geometry
	// management
	SizeRequestModeWidthForHeight SizeRequestMode = 1
	// SizeRequestModeConstantSize: don’t trade height-for-width or
	// width-for-height
	SizeRequestModeConstantSize SizeRequestMode = 2
)

func marshalSizeRequestMode(p uintptr) (interface{}, error) {
	return SizeRequestMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SortType determines the direction of a sort.
type SortType int

const (
	// SortTypeAscending: sorting is in ascending order.
	SortTypeAscending SortType = 0
	// SortTypeDescending: sorting is in descending order.
	SortTypeDescending SortType = 1
)

func marshalSortType(p uintptr) (interface{}, error) {
	return SortType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SorterChange describes changes in a sorter in more detail and allows users to
// optimize resorting.
type SorterChange int

const (
	// SorterChangeDifferent: the sorter change cannot be described by any of
	// the other enumeration values
	SorterChangeDifferent SorterChange = 0
	// SorterChangeInverted: the sort order was inverted. Comparisons that
	// returned GTK_ORDERING_SMALLER now return GTK_ORDERING_LARGER and vice
	// versa. Other comparisons return the same values as before.
	SorterChangeInverted SorterChange = 1
	// SorterChangeLessStrict: the sorter is less strict: Comparisons may now
	// return GTK_ORDERING_EQUAL that did not do so before.
	SorterChangeLessStrict SorterChange = 2
	// SorterChangeMoreStrict: the sorter is more strict: Comparisons that did
	// return GTK_ORDERING_EQUAL may not do so anymore.
	SorterChangeMoreStrict SorterChange = 3
)

func marshalSorterChange(p uintptr) (interface{}, error) {
	return SorterChange(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SorterOrder describes the type of order that a Sorter may describe.
type SorterOrder int

const (
	// SorterOrderPartial: a partial order. Any Ordering is possible.
	SorterOrderPartial SorterOrder = 0
	// SorterOrderNone: no order, all elements are considered equal.
	// gtk_sorter_compare() will only return GTK_ORDERING_EQUAL.
	SorterOrderNone SorterOrder = 1
	// SorterOrderTotal: a total order. gtk_sorter_compare() will only return
	// GTK_ORDERING_EQUAL if an item is compared with itself. Two different
	// items will never cause this value to be returned.
	SorterOrderTotal SorterOrder = 2
)

func marshalSorterOrder(p uintptr) (interface{}, error) {
	return SorterOrder(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SpinButtonUpdatePolicy: the spin button update policy determines whether the
// spin button displays values even if they are outside the bounds of its
// adjustment. See gtk_spin_button_set_update_policy().
type SpinButtonUpdatePolicy int

const (
	// SpinButtonUpdatePolicyAlways: when refreshing your SpinButton, the value
	// is always displayed
	SpinButtonUpdatePolicyAlways SpinButtonUpdatePolicy = 0
	// SpinButtonUpdatePolicyIfValid: when refreshing your SpinButton, the value
	// is only displayed if it is valid within the bounds of the spin button's
	// adjustment
	SpinButtonUpdatePolicyIfValid SpinButtonUpdatePolicy = 1
)

func marshalSpinButtonUpdatePolicy(p uintptr) (interface{}, error) {
	return SpinButtonUpdatePolicy(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SpinType: the values of the GtkSpinType enumeration are used to specify the
// change to make in gtk_spin_button_spin().
type SpinType int

const (
	// SpinTypeStepForward: increment by the adjustments step increment.
	SpinTypeStepForward SpinType = 0
	// SpinTypeStepBackward: decrement by the adjustments step increment.
	SpinTypeStepBackward SpinType = 1
	// SpinTypePageForward: increment by the adjustments page increment.
	SpinTypePageForward SpinType = 2
	// SpinTypePageBackward: decrement by the adjustments page increment.
	SpinTypePageBackward SpinType = 3
	// SpinTypeHome: go to the adjustments lower bound.
	SpinTypeHome SpinType = 4
	// SpinTypeEnd: go to the adjustments upper bound.
	SpinTypeEnd SpinType = 5
	// SpinTypeUserDefined: change by a specified amount.
	SpinTypeUserDefined SpinType = 6
)

func marshalSpinType(p uintptr) (interface{}, error) {
	return SpinType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// StackTransitionType: these enumeration values describe the possible
// transitions between pages in a Stack widget.
//
// New values may be added to this enumeration over time.
type StackTransitionType int

const (
	// StackTransitionTypeNone: no transition
	StackTransitionTypeNone StackTransitionType = 0
	// StackTransitionTypeCrossfade: a cross-fade
	StackTransitionTypeCrossfade StackTransitionType = 1
	// StackTransitionTypeSlideRight: slide from left to right
	StackTransitionTypeSlideRight StackTransitionType = 2
	// StackTransitionTypeSlideLeft: slide from right to left
	StackTransitionTypeSlideLeft StackTransitionType = 3
	// StackTransitionTypeSlideUp: slide from bottom up
	StackTransitionTypeSlideUp StackTransitionType = 4
	// StackTransitionTypeSlideDown: slide from top down
	StackTransitionTypeSlideDown StackTransitionType = 5
	// StackTransitionTypeSlideLeftRight: slide from left or right according to
	// the children order
	StackTransitionTypeSlideLeftRight StackTransitionType = 6
	// StackTransitionTypeSlideUpDown: slide from top down or bottom up
	// according to the order
	StackTransitionTypeSlideUpDown StackTransitionType = 7
	// StackTransitionTypeOverUp: cover the old page by sliding up
	StackTransitionTypeOverUp StackTransitionType = 8
	// StackTransitionTypeOverDown: cover the old page by sliding down
	StackTransitionTypeOverDown StackTransitionType = 9
	// StackTransitionTypeOverLeft: cover the old page by sliding to the left
	StackTransitionTypeOverLeft StackTransitionType = 10
	// StackTransitionTypeOverRight: cover the old page by sliding to the right
	StackTransitionTypeOverRight StackTransitionType = 11
	// StackTransitionTypeUnderUp: uncover the new page by sliding up
	StackTransitionTypeUnderUp StackTransitionType = 12
	// StackTransitionTypeUnderDown: uncover the new page by sliding down
	StackTransitionTypeUnderDown StackTransitionType = 13
	// StackTransitionTypeUnderLeft: uncover the new page by sliding to the left
	StackTransitionTypeUnderLeft StackTransitionType = 14
	// StackTransitionTypeUnderRight: uncover the new page by sliding to the
	// right
	StackTransitionTypeUnderRight StackTransitionType = 15
	// StackTransitionTypeOverUpDown: cover the old page sliding up or uncover
	// the new page sliding down, according to order
	StackTransitionTypeOverUpDown StackTransitionType = 16
	// StackTransitionTypeOverDownUp: cover the old page sliding down or uncover
	// the new page sliding up, according to order
	StackTransitionTypeOverDownUp StackTransitionType = 17
	// StackTransitionTypeOverLeftRight: cover the old page sliding left or
	// uncover the new page sliding right, according to order
	StackTransitionTypeOverLeftRight StackTransitionType = 18
	// StackTransitionTypeOverRightLeft: cover the old page sliding right or
	// uncover the new page sliding left, according to order
	StackTransitionTypeOverRightLeft StackTransitionType = 19
	// StackTransitionTypeRotateLeft: pretend the pages are sides of a cube and
	// rotate that cube to the left
	StackTransitionTypeRotateLeft StackTransitionType = 20
	// StackTransitionTypeRotateRight: pretend the pages are sides of a cube and
	// rotate that cube to the right
	StackTransitionTypeRotateRight StackTransitionType = 21
	// StackTransitionTypeRotateLeftRight: pretend the pages are sides of a cube
	// and rotate that cube to the left or right according to the children order
	StackTransitionTypeRotateLeftRight StackTransitionType = 22
)

func marshalStackTransitionType(p uintptr) (interface{}, error) {
	return StackTransitionType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// StringFilterMatchMode specifies how search strings are matched inside text.
type StringFilterMatchMode int

const (
	// StringFilterMatchModeExact: the search string and text must match
	// exactly.
	StringFilterMatchModeExact StringFilterMatchMode = 0
	// StringFilterMatchModeSubstring: the search string must be contained as a
	// substring inside the text.
	StringFilterMatchModeSubstring StringFilterMatchMode = 1
	// StringFilterMatchModePrefix: the text must begin with the search string.
	StringFilterMatchModePrefix StringFilterMatchMode = 2
)

func marshalStringFilterMatchMode(p uintptr) (interface{}, error) {
	return StringFilterMatchMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SystemSetting values that can be passed to the
// GtkWidgetClass.system_setting_changed vfunc to indicate that a system setting
// has changed and widgets may need to drop caches, or react otherwise.
//
// Most of the values correspond to Settings properties.
//
// More values may be added over time.
type SystemSetting int

const (
	// SystemSettingDPI: the Settings:gtk-xft-dpi setting has changed
	SystemSettingDPI SystemSetting = 0
	// SystemSettingFontName: the Settings:gtk-font-name setting has changed
	SystemSettingFontName SystemSetting = 1
	// SystemSettingFontConfig: the font configuration has changed in a way that
	// requires text to be redrawn. This can be any of the
	// Settings:gtk-xft-antialias, Settings:gtk-xft-hinting,
	// Settings:gtk-xft-hintstyle, Settings:gtk-xft-rgba or
	// Settings:gtk-fontconfig-timestamp settings
	SystemSettingFontConfig SystemSetting = 2
	// SystemSettingDisplay: the display has changed
	SystemSettingDisplay SystemSetting = 3
	// SystemSettingIconTheme: the icon theme has changed in a way that requires
	// icons to be looked up again
	SystemSettingIconTheme SystemSetting = 4
)

func marshalSystemSetting(p uintptr) (interface{}, error) {
	return SystemSetting(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TextDirection: reading directions for text.
type TextDirection int

const (
	// TextDirectionNone: no direction.
	TextDirectionNone TextDirection = 0
	// TextDirectionLTR: left to right text direction.
	TextDirectionLTR TextDirection = 1
	// TextDirectionRTL: right to left text direction.
	TextDirectionRTL TextDirection = 2
)

func marshalTextDirection(p uintptr) (interface{}, error) {
	return TextDirection(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TextExtendSelection: granularity types that extend the text selection. Use
// the TextView::extend-selection signal to customize the selection.
type TextExtendSelection int

const (
	// TextExtendSelectionWord selects the current word. It is triggered by a
	// double-click for example.
	TextExtendSelectionWord TextExtendSelection = 0
	// TextExtendSelectionLine selects the current line. It is triggered by a
	// triple-click for example.
	TextExtendSelectionLine TextExtendSelection = 1
)

func marshalTextExtendSelection(p uintptr) (interface{}, error) {
	return TextExtendSelection(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TextViewLayer: used to reference the layers of TextView for the purpose of
// customized drawing with the ::snapshot_layer vfunc.
type TextViewLayer int

const (
	// TextViewLayerBelowText: the layer rendered below the text (but above the
	// background).
	TextViewLayerBelowText TextViewLayer = 0
	// TextViewLayerAboveText: the layer rendered above the text.
	TextViewLayerAboveText TextViewLayer = 1
)

func marshalTextViewLayer(p uintptr) (interface{}, error) {
	return TextViewLayer(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TextWindowType: used to reference the parts of TextView.
type TextWindowType int

const (
	// TextWindowTypeWidget: window that floats over scrolling areas.
	TextWindowTypeWidget TextWindowType = 1
	// TextWindowTypeText: scrollable text window.
	TextWindowTypeText TextWindowType = 2
	// TextWindowTypeLeft: left side border window.
	TextWindowTypeLeft TextWindowType = 3
	// TextWindowTypeRight: right side border window.
	TextWindowTypeRight TextWindowType = 4
	// TextWindowTypeTop: top border window.
	TextWindowTypeTop TextWindowType = 5
	// TextWindowTypeBottom: bottom border window.
	TextWindowTypeBottom TextWindowType = 6
)

func marshalTextWindowType(p uintptr) (interface{}, error) {
	return TextWindowType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TreeViewColumnSizing: the sizing method the column uses to determine its
// width. Please note that GTK_TREE_VIEW_COLUMN_AUTOSIZE are inefficient for
// large views, and can make columns appear choppy.
type TreeViewColumnSizing int

const (
	// TreeViewColumnSizingGrowOnly columns only get bigger in reaction to
	// changes in the model
	TreeViewColumnSizingGrowOnly TreeViewColumnSizing = 0
	// TreeViewColumnSizingAutosize columns resize to be the optimal size every
	// time the model changes.
	TreeViewColumnSizingAutosize TreeViewColumnSizing = 1
	// TreeViewColumnSizingFixed columns are a fixed numbers of pixels wide.
	TreeViewColumnSizingFixed TreeViewColumnSizing = 2
)

func marshalTreeViewColumnSizing(p uintptr) (interface{}, error) {
	return TreeViewColumnSizing(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TreeViewDropPosition: an enum for determining where a dropped row goes.
type TreeViewDropPosition int

const (
	// TreeViewDropPositionBefore: dropped row is inserted before
	TreeViewDropPositionBefore TreeViewDropPosition = 0
	// TreeViewDropPositionAfter: dropped row is inserted after
	TreeViewDropPositionAfter TreeViewDropPosition = 1
	// TreeViewDropPositionIntoOrBefore: dropped row becomes a child or is
	// inserted before
	TreeViewDropPositionIntoOrBefore TreeViewDropPosition = 2
	// TreeViewDropPositionIntoOrAfter: dropped row becomes a child or is
	// inserted after
	TreeViewDropPositionIntoOrAfter TreeViewDropPosition = 3
)

func marshalTreeViewDropPosition(p uintptr) (interface{}, error) {
	return TreeViewDropPosition(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TreeViewGridLines: used to indicate which grid lines to draw in a tree view.
type TreeViewGridLines int

const (
	// TreeViewGridLinesNone: no grid lines.
	TreeViewGridLinesNone TreeViewGridLines = 0
	// TreeViewGridLinesHorizontal: horizontal grid lines.
	TreeViewGridLinesHorizontal TreeViewGridLines = 1
	// TreeViewGridLinesVertical: vertical grid lines.
	TreeViewGridLinesVertical TreeViewGridLines = 2
	// TreeViewGridLinesBoth: horizontal and vertical grid lines.
	TreeViewGridLinesBoth TreeViewGridLines = 3
)

func marshalTreeViewGridLines(p uintptr) (interface{}, error) {
	return TreeViewGridLines(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// Unit: see also gtk_print_settings_set_paper_width().
type Unit int

const (
	// UnitNone: no units.
	UnitNone Unit = 0
	// UnitPoints dimensions in points.
	UnitPoints Unit = 1
	// UnitInch dimensions in inches.
	UnitInch Unit = 2
	// UnitMm dimensions in millimeters
	UnitMm Unit = 3
)

func marshalUnit(p uintptr) (interface{}, error) {
	return Unit(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// WrapMode describes a type of line wrapping.
type WrapMode int

const (
	// WrapModeNone: do not wrap lines; just make the text area wider
	WrapModeNone WrapMode = 0
	// WrapModeChar: wrap text, breaking lines anywhere the cursor can appear
	// (between characters, usually - if you want to be technical, between
	// graphemes, see pango_get_log_attrs())
	WrapModeChar WrapMode = 1
	// WrapModeWord: wrap text, breaking lines in between words
	WrapModeWord WrapMode = 2
	// WrapModeWordChar: wrap text, breaking lines in between words, or if that
	// is not enough, also between graphemes
	WrapModeWordChar WrapMode = 3
)

func marshalWrapMode(p uintptr) (interface{}, error) {
	return WrapMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ApplicationInhibitFlags types of user actions that may be blocked by
// gtk_application_inhibit().
type ApplicationInhibitFlags int

const (
	// ApplicationInhibitFlagsLogout: inhibit ending the user session by logging
	// out or by shutting down the computer
	ApplicationInhibitFlagsLogout ApplicationInhibitFlags = 1
	// ApplicationInhibitFlagsSwitch: inhibit user switching
	ApplicationInhibitFlagsSwitch ApplicationInhibitFlags = 2
	// ApplicationInhibitFlagsSuspend: inhibit suspending the session or
	// computer
	ApplicationInhibitFlagsSuspend ApplicationInhibitFlags = 4
	// ApplicationInhibitFlagsIdle: inhibit the session being marked as idle
	// (and possibly locked)
	ApplicationInhibitFlagsIdle ApplicationInhibitFlags = 8
)

func marshalApplicationInhibitFlags(p uintptr) (interface{}, error) {
	return ApplicationInhibitFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// BuilderClosureFlags: the list of flags that can be passed to
// gtk_builder_create_closure(). New values may be added in the future for new
// features, so external implementations of GtkBuilderScopeInterface should test
// the flags for unknown values and raise a GTK_BUILDER_ERROR_INVALID_ATTRIBUTE
// error when they encounter one.
type BuilderClosureFlags int

const (
	// BuilderClosureFlagsSwapped: the closure should be created swapped. See
	// g_cclosure_new_swap() for details.
	BuilderClosureFlagsSwapped BuilderClosureFlags = 1
)

func marshalBuilderClosureFlags(p uintptr) (interface{}, error) {
	return BuilderClosureFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// CellRendererState tells how a cell is to be rendered.
type CellRendererState int

const (
	// CellRendererStateSelected: the cell is currently selected, and probably
	// has a selection colored background to render to.
	CellRendererStateSelected CellRendererState = 1
	// CellRendererStatePrelit: the mouse is hovering over the cell.
	CellRendererStatePrelit CellRendererState = 2
	// CellRendererStateInsensitive: the cell is drawn in an insensitive manner
	CellRendererStateInsensitive CellRendererState = 4
	// CellRendererStateSorted: the cell is in a sorted row
	CellRendererStateSorted CellRendererState = 8
	// CellRendererStateFocused: the cell is in the focus row.
	CellRendererStateFocused CellRendererState = 16
	// CellRendererStateExpandable: the cell is in a row that can be expanded
	CellRendererStateExpandable CellRendererState = 32
	// CellRendererStateExpanded: the cell is in a row that is expanded
	CellRendererStateExpanded CellRendererState = 64
)

func marshalCellRendererState(p uintptr) (interface{}, error) {
	return CellRendererState(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

type DebugFlags int

const (
	DebugFlagsText           DebugFlags = 1
	DebugFlagsTree           DebugFlags = 2
	DebugFlagsKeybindings    DebugFlags = 4
	DebugFlagsModules        DebugFlags = 8
	DebugFlagsGeometry       DebugFlags = 16
	DebugFlagsIcontheme      DebugFlags = 32
	DebugFlagsPrinting       DebugFlags = 64
	DebugFlagsBuilder        DebugFlags = 128
	DebugFlagsSizeRequest    DebugFlags = 256
	DebugFlagsNoCSSCache     DebugFlags = 512
	DebugFlagsInteractive    DebugFlags = 1024
	DebugFlagsTouchscreen    DebugFlags = 2048
	DebugFlagsActions        DebugFlags = 4096
	DebugFlagsLayout         DebugFlags = 8192
	DebugFlagsSnapshot       DebugFlags = 16384
	DebugFlagsConstraints    DebugFlags = 32768
	DebugFlagsBuilderObjects DebugFlags = 65536
	DebugFlagsA11Y           DebugFlags = 131072
)

func marshalDebugFlags(p uintptr) (interface{}, error) {
	return DebugFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DialogFlags flags used to influence dialog construction.
type DialogFlags int

const (
	// DialogFlagsModal: make the constructed dialog modal, see
	// gtk_window_set_modal()
	DialogFlagsModal DialogFlags = 1
	// DialogFlagsDestroyWithParent: destroy the dialog when its parent is
	// destroyed, see gtk_window_set_destroy_with_parent()
	DialogFlagsDestroyWithParent DialogFlags = 2
	// DialogFlagsUseHeaderBar: create dialog with actions in header bar instead
	// of action area
	DialogFlagsUseHeaderBar DialogFlags = 4
)

func marshalDialogFlags(p uintptr) (interface{}, error) {
	return DialogFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// EventControllerScrollFlags describes the behavior of a EventControllerScroll.
type EventControllerScrollFlags int

const (
	// EventControllerScrollFlagsNone: don't emit scroll.
	EventControllerScrollFlagsNone EventControllerScrollFlags = 0
	// EventControllerScrollFlagsVertical: emit scroll with vertical deltas.
	EventControllerScrollFlagsVertical EventControllerScrollFlags = 1
	// EventControllerScrollFlagsHorizontal: emit scroll with horizontal deltas.
	EventControllerScrollFlagsHorizontal EventControllerScrollFlags = 2
	// EventControllerScrollFlagsDiscrete: only emit deltas that are multiples
	// of 1.
	EventControllerScrollFlagsDiscrete EventControllerScrollFlags = 4
	// EventControllerScrollFlagsKinetic: emit EventControllerScroll::decelerate
	// after continuous scroll finishes.
	EventControllerScrollFlagsKinetic EventControllerScrollFlags = 8
	// EventControllerScrollFlagsBothAxes: emit scroll on both axes.
	EventControllerScrollFlagsBothAxes EventControllerScrollFlags = 3
)

func marshalEventControllerScrollFlags(p uintptr) (interface{}, error) {
	return EventControllerScrollFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FontChooserLevel: this enumeration specifies the granularity of font
// selection that is desired in a font chooser.
//
// This enumeration may be extended in the future; applications should ignore
// unknown values.
type FontChooserLevel int

const (
	// FontChooserLevelFamily: allow selecting a font family
	FontChooserLevelFamily FontChooserLevel = 0
	// FontChooserLevelStyle: allow selecting a specific font face
	FontChooserLevelStyle FontChooserLevel = 1
	// FontChooserLevelSize: allow selecting a specific font size
	FontChooserLevelSize FontChooserLevel = 2
	// FontChooserLevelVariations: allow changing OpenType font variation axes
	FontChooserLevelVariations FontChooserLevel = 4
	// FontChooserLevelFeatures: allow selecting specific OpenType font features
	FontChooserLevelFeatures FontChooserLevel = 8
)

func marshalFontChooserLevel(p uintptr) (interface{}, error) {
	return FontChooserLevel(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// IconLookupFlags: used to specify options for gtk_icon_theme_lookup_icon()
type IconLookupFlags int

const (
	// IconLookupFlagsForceRegular: try to always load regular icons, even when
	// symbolic icon names are given
	IconLookupFlagsForceRegular IconLookupFlags = 1
	// IconLookupFlagsForceSymbolic: try to always load symbolic icons, even
	// when regular icon names are given
	IconLookupFlagsForceSymbolic IconLookupFlags = 2
	// IconLookupFlagsPreload starts loading the texture in the background so it
	// is ready when later needed.
	IconLookupFlagsPreload IconLookupFlags = 4
)

func marshalIconLookupFlags(p uintptr) (interface{}, error) {
	return IconLookupFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// InputHints describes hints that might be taken into account by input methods
// or applications. Note that input methods may already tailor their behaviour
// according to the InputPurpose of the entry.
//
// Some common sense is expected when using these flags - mixing
// GTK_INPUT_HINT_LOWERCASE with any of the uppercase hints makes no sense.
//
// This enumeration may be extended in the future; input methods should ignore
// unknown values.
type InputHints int

const (
	// InputHintsNone: no special behaviour suggested
	InputHintsNone InputHints = 0
	// InputHintsSpellcheck: suggest checking for typos
	InputHintsSpellcheck InputHints = 1
	// InputHintsNoSpellcheck: suggest not checking for typos
	InputHintsNoSpellcheck InputHints = 2
	// InputHintsWordCompletion: suggest word completion
	InputHintsWordCompletion InputHints = 4
	// InputHintsLowercase: suggest to convert all text to lowercase
	InputHintsLowercase InputHints = 8
	// InputHintsUppercaseChars: suggest to capitalize all text
	InputHintsUppercaseChars InputHints = 16
	// InputHintsUppercaseWords: suggest to capitalize the first character of
	// each word
	InputHintsUppercaseWords InputHints = 32
	// InputHintsUppercaseSentences: suggest to capitalize the first word of
	// each sentence
	InputHintsUppercaseSentences InputHints = 64
	// InputHintsInhibitOsk: suggest to not show an onscreen keyboard (e.g for a
	// calculator that already has all the keys).
	InputHintsInhibitOsk InputHints = 128
	// InputHintsVerticalWriting: the text is vertical
	InputHintsVerticalWriting InputHints = 256
	// InputHintsEmoji: suggest offering Emoji support
	InputHintsEmoji InputHints = 512
	// InputHintsNoEmoji: suggest not offering Emoji support
	InputHintsNoEmoji InputHints = 1024
	// InputHintsPrivate: request that the input method should not update
	// personalized data (like typing history)
	InputHintsPrivate InputHints = 2048
)

func marshalInputHints(p uintptr) (interface{}, error) {
	return InputHints(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PickFlags flags that influence the behavior of gtk_widget_pick()
type PickFlags int

const (
	// PickFlagsDefault: the default behavior, include widgets that are
	// receiving events
	PickFlagsDefault PickFlags = 0
	// PickFlagsInsensitive: include widgets that are insensitive
	PickFlagsInsensitive PickFlags = 1
	// PickFlagsNonTargetable: include widgets that are marked as
	// non-targetable. See Widget:can-target
	PickFlagsNonTargetable PickFlags = 2
)

func marshalPickFlags(p uintptr) (interface{}, error) {
	return PickFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PopoverMenuFlags flags that affect how popover menus are created from a menu
// model.
type PopoverMenuFlags int

const (
	// PopoverMenuFlagsNested: create submenus as nested popovers. Without this
	// flag, submenus are created as sliding pages that replace the main menu.
	PopoverMenuFlagsNested PopoverMenuFlags = 1
)

func marshalPopoverMenuFlags(p uintptr) (interface{}, error) {
	return PopoverMenuFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ShortcutActionFlags: list of flags that can be passed to action activation.
// More flags may be added in the future.
type ShortcutActionFlags int

const (
	// ShortcutActionFlagsExclusive: the action is the only action that can be
	// activated. If this flag is not set, a future activation may select a
	// different action.
	ShortcutActionFlagsExclusive ShortcutActionFlags = 1
)

func marshalShortcutActionFlags(p uintptr) (interface{}, error) {
	return ShortcutActionFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// StateFlags describes a widget state. Widget states are used to match the
// widget against CSS pseudo-classes. Note that GTK extends the regular CSS
// classes and sometimes uses different names.
type StateFlags int

const (
	// StateFlagsNormal: state during normal operation
	StateFlagsNormal StateFlags = 0
	// StateFlagsActive: widget is active
	StateFlagsActive StateFlags = 1
	// StateFlagsPrelight: widget has a mouse pointer over it
	StateFlagsPrelight StateFlags = 2
	// StateFlagsSelected: widget is selected
	StateFlagsSelected StateFlags = 4
	// StateFlagsInsensitive: widget is insensitive
	StateFlagsInsensitive StateFlags = 8
	// StateFlagsInconsistent: widget is inconsistent
	StateFlagsInconsistent StateFlags = 16
	// StateFlagsFocused: widget has the keyboard focus
	StateFlagsFocused StateFlags = 32
	// StateFlagsBackdrop: widget is in a background toplevel window
	StateFlagsBackdrop StateFlags = 64
	// StateFlagsDirLTR: widget is in left-to-right text direction
	StateFlagsDirLTR StateFlags = 128
	// StateFlagsDirRTL: widget is in right-to-left text direction
	StateFlagsDirRTL StateFlags = 256
	// StateFlagsLink: widget is a link
	StateFlagsLink StateFlags = 512
	// StateFlagsVisited: the location the widget points to has already been
	// visited
	StateFlagsVisited StateFlags = 1024
	// StateFlagsChecked: widget is checked
	StateFlagsChecked StateFlags = 2048
	// StateFlagsDropActive: widget is highlighted as a drop target for DND
	StateFlagsDropActive StateFlags = 4096
	// StateFlagsFocusVisible: widget has the visible focus
	StateFlagsFocusVisible StateFlags = 8192
	// StateFlagsFocusWithin: widget contains the keyboard focus
	StateFlagsFocusWithin StateFlags = 16384
)

func marshalStateFlags(p uintptr) (interface{}, error) {
	return StateFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// StyleContextPrintFlags flags that modify the behavior of
// gtk_style_context_to_string(). New values may be added to this enumeration.
type StyleContextPrintFlags int

const (
	// StyleContextPrintFlagsNone: default value.
	StyleContextPrintFlagsNone StyleContextPrintFlags = 0
	// StyleContextPrintFlagsRecurse: print the entire tree of CSS nodes
	// starting at the style context's node
	StyleContextPrintFlagsRecurse StyleContextPrintFlags = 1
	// StyleContextPrintFlagsShowStyle: show the values of the CSS properties
	// for each node
	StyleContextPrintFlagsShowStyle StyleContextPrintFlags = 2
	// StyleContextPrintFlagsShowChange: show information about what changes
	// affect the styles
	StyleContextPrintFlagsShowChange StyleContextPrintFlags = 4
)

func marshalStyleContextPrintFlags(p uintptr) (interface{}, error) {
	return StyleContextPrintFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TextSearchFlags flags affecting how a search is done.
//
// If neither K_TEXT_SEARCH_VISIBLE_ONLY nor K_TEXT_SEARCH_TEXT_ONLY are
// enabled, the match must be exact; the special 0xFFFC character will match
// embedded paintables or child widgets.
type TextSearchFlags int

const (
	// TextSearchFlagsVisibleOnly: search only visible data. A search match may
	// have invisible text interspersed.
	TextSearchFlagsVisibleOnly TextSearchFlags = 1
	// TextSearchFlagsTextOnly: search only text. A match may have paintables or
	// child widgets mixed inside the matched range.
	TextSearchFlagsTextOnly TextSearchFlags = 2
	// TextSearchFlagsCaseInsensitive: the text will be matched regardless of
	// what case it is in.
	TextSearchFlagsCaseInsensitive TextSearchFlags = 4
)

func marshalTextSearchFlags(p uintptr) (interface{}, error) {
	return TextSearchFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TreeModelFlags: these flags indicate various properties of a TreeModel.
//
// They are returned by gtk_tree_model_get_flags(), and must be static for the
// lifetime of the object. A more complete description of
// K_TREE_MODEL_ITERS_PERSIST can be found in the overview of this section.
type TreeModelFlags int

const (
	// TreeModelFlagsItersPersist iterators survive all signals emitted by the
	// tree
	TreeModelFlagsItersPersist TreeModelFlags = 1
	// TreeModelFlagsListOnly: the model is a list only, and never has children
	TreeModelFlagsListOnly TreeModelFlags = 2
)

func marshalTreeModelFlags(p uintptr) (interface{}, error) {
	return TreeModelFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AppChooser is an interface that can be implemented by widgets which allow the
// user to choose an application (typically for the purpose of opening a file).
// The main objects that implement this interface are AppChooserWidget,
// AppChooserDialog and AppChooserButton.
//
// Applications are represented by GIO Info objects here. GIO has a concept of
// recommended and fallback applications for a given content type. Recommended
// applications are those that claim to handle the content type itself, while
// fallback also includes applications that handle a more generic content type.
// GIO also knows the default and last-used application for a given content
// type. The AppChooserWidget provides detailed control over whether the shown
// list of applications should include default, recommended or fallback
// applications.
//
// To obtain the application that has been selected in a AppChooser, use
// gtk_app_chooser_get_app_info().
type AppChooser interface {
	Widget

	// AppInfo returns the currently selected application.
	AppInfo() gio.AppInfo
	// ContentType returns the current value of the AppChooser:content-type
	// property.
	ContentType() string
	// Refresh reloads the list of applications.
	Refresh()
}

// appChooser implements the AppChooser interface.
type appChooser struct {
	Widget
}

var _ AppChooser = (*appChooser)(nil)

// WrapAppChooser wraps a GObject to a type that implements interface
// AppChooser. It is primarily used internally.
func WrapAppChooser(obj *externglib.Object) AppChooser {
	return AppChooser{
		Widget: WrapWidget(obj),
	}
}

func marshalAppChooser(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapAppChooser(obj), nil
}

// AppInfo returns the currently selected application.
func (s appChooser) AppInfo() gio.AppInfo {
	var arg0 *C.GtkAppChooser

	arg0 = (*C.GtkAppChooser)(unsafe.Pointer(s.Native()))

	var cret *C.GAppInfo

	cret = C.gtk_app_chooser_get_app_info(arg0)

	var appInfo gio.AppInfo

	appInfo = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(gio.AppInfo)

	return appInfo
}

// ContentType returns the current value of the AppChooser:content-type
// property.
func (s appChooser) ContentType() string {
	var arg0 *C.GtkAppChooser

	arg0 = (*C.GtkAppChooser)(unsafe.Pointer(s.Native()))

	var cret *C.char

	cret = C.gtk_app_chooser_get_content_type(arg0)

	var utf8 string

	utf8 = C.GoString(cret)
	defer C.free(unsafe.Pointer(cret))

	return utf8
}

// Refresh reloads the list of applications.
func (s appChooser) Refresh() {
	var arg0 *C.GtkAppChooser

	arg0 = (*C.GtkAppChooser)(unsafe.Pointer(s.Native()))

	C.gtk_app_chooser_refresh(arg0)
}

// FileChooser is an interface that can be implemented by file selection
// widgets. In GTK, the main objects that implement this interface are
// FileChooserWidget and FileChooserDialog. You do not need to write an object
// that implements the FileChooser interface unless you are trying to adapt an
// existing file selector to expose a standard programming interface.
//
// FileChooser allows for shortcuts to various places in the filesystem. In the
// default implementation these are displayed in the left pane. It may be a bit
// confusing at first that these shortcuts come from various sources and in
// various flavours, so lets explain the terminology here:
//
// - Bookmarks: are created by the user, by dragging folders from the right pane
// to the left pane, or by using the “Add”. Bookmarks can be renamed and deleted
// by the user.
//
// - Shortcuts: can be provided by the application. For example, a Paint program
// may want to add a shortcut for a Clipart folder. Shortcuts cannot be modified
// by the user.
//
// - Volumes: are provided by the underlying filesystem abstraction. They are
// the “roots” of the filesystem.
//
//
// File Names and Encodings
//
// When the user is finished selecting files in a FileChooser, your program can
// get the selected filenames as #GFiles.
//
//
// Adding options
//
// You can add extra widgets to a file chooser to provide options that are not
// present in the default design, by using gtk_file_chooser_add_choice(). Each
// choice has an identifier and a user visible label; additionally, each choice
// can have multiple options. If a choice has no option, it will be rendered as
// a check button with the given label; if a choice has options, it will be
// rendered as a combo box.
type FileChooser interface {
	gextras.Objector

	// AddChoice adds a 'choice' to the file chooser. This is typically
	// implemented as a combobox or, for boolean choices, as a checkbutton. You
	// can select a value using gtk_file_chooser_set_choice() before the dialog
	// is shown, and you can obtain the user-selected value in the ::response
	// signal handler using gtk_file_chooser_get_choice().
	AddChoice(id string, label string, options []string, optionLabels []string)
	// AddFilter adds @filter to the list of filters that the user can select
	// between. When a filter is selected, only files that are passed by that
	// filter are displayed.
	//
	// Note that the @chooser takes ownership of the filter if it is floating,
	// so you have to ref and sink it if you want to keep a reference.
	AddFilter(filter FileFilter)
	// AddShortcutFolder adds a folder to be displayed with the shortcut folders
	// in a file chooser.
	AddShortcutFolder(folder gio.File) error
	// Action gets the type of operation that the file chooser is performing;
	// see gtk_file_chooser_set_action().
	Action() FileChooserAction
	// Choice gets the currently selected option in the 'choice' with the given
	// ID.
	Choice(id string) string
	// CreateFolders gets whether file chooser will offer to create new folders.
	// See gtk_file_chooser_set_create_folders().
	CreateFolders() bool
	// CurrentFolder gets the current folder of @chooser as #GFile.
	CurrentFolder() gio.File
	// CurrentName gets the current name in the file selector, as entered by the
	// user in the text entry for “Name”.
	//
	// This is meant to be used in save dialogs, to get the currently typed
	// filename when the file itself does not exist yet.
	CurrentName() string
	// File gets the #GFile for the currently selected file in the file
	// selector. If multiple files are selected, one of the files will be
	// returned at random.
	//
	// If the file chooser is in folder mode, this function returns the selected
	// folder.
	File() gio.File
	// Files lists all the selected files and subfolders in the current folder
	// of @chooser as #GFile.
	Files() gio.ListModel
	// Filter gets the current filter; see gtk_file_chooser_set_filter().
	Filter() FileFilter
	// Filters gets the current set of user-selectable filters, as a list model;
	// see gtk_file_chooser_add_filter(), gtk_file_chooser_remove_filter().
	//
	// You should not modify the returned list model. Future changes to @chooser
	// may or may not affect the returned model.
	Filters() gio.ListModel
	// SelectMultiple gets whether multiple files can be selected in the file
	// selector. See gtk_file_chooser_set_select_multiple().
	SelectMultiple() bool
	// ShortcutFolders queries the list of shortcut folders in the file chooser,
	// as set by gtk_file_chooser_add_shortcut_folder().
	//
	// You should not modify the returned list model. Future changes to @chooser
	// may or may not affect the returned model.
	ShortcutFolders() gio.ListModel
	// RemoveChoice removes a 'choice' that has been added with
	// gtk_file_chooser_add_choice().
	RemoveChoice(id string)
	// RemoveFilter removes @filter from the list of filters that the user can
	// select between.
	RemoveFilter(filter FileFilter)
	// RemoveShortcutFolder removes a folder from the shortcut folders in a file
	// chooser.
	RemoveShortcutFolder(folder gio.File) error
	// SetAction sets the type of operation that the chooser is performing; the
	// user interface is adapted to suit the selected action. For example, an
	// option to create a new folder might be shown if the action is
	// GTK_FILE_CHOOSER_ACTION_SAVE but not if the action is
	// GTK_FILE_CHOOSER_ACTION_OPEN.
	SetAction(action FileChooserAction)
	// SetChoice selects an option in a 'choice' that has been added with
	// gtk_file_chooser_add_choice(). For a boolean choice, the possible options
	// are "true" and "false".
	SetChoice(id string, option string)
	// SetCreateFolders sets whether file chooser will offer to create new
	// folders. This is only relevant if the action is not set to be
	// GTK_FILE_CHOOSER_ACTION_OPEN.
	SetCreateFolders(createFolders bool)
	// SetCurrentFolder sets the current folder for @chooser from a #GFile.
	SetCurrentFolder(file gio.File) error
	// SetCurrentName sets the current name in the file selector, as if entered
	// by the user. Note that the name passed in here is a UTF-8 string rather
	// than a filename. This function is meant for such uses as a suggested name
	// in a “Save As...” dialog. You can pass “Untitled.doc” or a similarly
	// suitable suggestion for the @name.
	//
	// If you want to preselect a particular existing file, you should use
	// gtk_file_chooser_set_file() instead.
	//
	// Please see the documentation for those functions for an example of using
	// gtk_file_chooser_set_current_name() as well.
	SetCurrentName(name string)
	// SetFile sets @file as the current filename for the file chooser, by
	// changing to the file’s parent folder and actually selecting the file in
	// list. If the @chooser is in GTK_FILE_CHOOSER_ACTION_SAVE mode, the file’s
	// base name will also appear in the dialog’s file name entry.
	//
	// If the file name isn’t in the current folder of @chooser, then the
	// current folder of @chooser will be changed to the folder containing
	// @filename.
	//
	// Note that the file must exist, or nothing will be done except for the
	// directory change.
	//
	// If you are implementing a save dialog, you should use this function if
	// you already have a file name to which the user may save; for example,
	// when the user opens an existing file and then does Save As... If you
	// don’t have a file name already — for example, if the user just created a
	// new file and is saving it for the first time, do not call this function.
	// Instead, use something similar to this:
	//
	//    static void
	//    prepare_file_chooser (GtkFileChooser *chooser,
	//                          GFile          *existing_file)
	//    {
	//      gboolean document_is_new = (existing_file == NULL);
	//
	//      if (document_is_new)
	//        {
	//          GFile *default_file_for_saving = g_file_new_for_path ("./out.txt");
	//          // the user just created a new document
	//          gtk_file_chooser_set_current_folder (chooser, default_file_for_saving, NULL);
	//          gtk_file_chooser_set_current_name (chooser, "Untitled document");
	//          g_object_unref (default_file_for_saving);
	//        }
	//      else
	//        {
	//          // the user edited an existing document
	//          gtk_file_chooser_set_file (chooser, existing_file, NULL);
	//        }
	//    }
	SetFile(file gio.File) error
	// SetFilter sets the current filter; only the files that pass the filter
	// will be displayed. If the user-selectable list of filters is non-empty,
	// then the filter should be one of the filters in that list. Setting the
	// current filter when the list of filters is empty is useful if you want to
	// restrict the displayed set of files without letting the user change it.
	SetFilter(filter FileFilter)
	// SetSelectMultiple sets whether multiple files can be selected in the file
	// selector. This is only relevant if the action is set to be
	// GTK_FILE_CHOOSER_ACTION_OPEN or GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER.
	SetSelectMultiple(selectMultiple bool)
}

// fileChooser implements the FileChooser interface.
type fileChooser struct {
	gextras.Objector
}

var _ FileChooser = (*fileChooser)(nil)

// WrapFileChooser wraps a GObject to a type that implements interface
// FileChooser. It is primarily used internally.
func WrapFileChooser(obj *externglib.Object) FileChooser {
	return FileChooser{
		Objector: obj,
	}
}

func marshalFileChooser(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFileChooser(obj), nil
}

// AddChoice adds a 'choice' to the file chooser. This is typically
// implemented as a combobox or, for boolean choices, as a checkbutton. You
// can select a value using gtk_file_chooser_set_choice() before the dialog
// is shown, and you can obtain the user-selected value in the ::response
// signal handler using gtk_file_chooser_get_choice().
func (c fileChooser) AddChoice(id string, label string, options []string, optionLabels []string) {
	var arg0 *C.GtkFileChooser
	var arg1 *C.char
	var arg2 *C.char
	var arg3 **C.char
	var arg4 **C.char

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	arg1 = (*C.char)(C.CString(id))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.char)(C.CString(label))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (**C.char)(C.malloc((len(options) + 1) * unsafe.Sizeof(int(0))))
	defer C.free(unsafe.Pointer(arg3))

	{
		var out []*C.char
		ptr.SetSlice(unsafe.Pointer(&dst), unsafe.Pointer(arg3), int(len(options)))

		for i := range options {
			arg3 = (*C.char)(C.CString(options))
			defer C.free(unsafe.Pointer(arg3))
		}
	}
	arg4 = (**C.char)(C.malloc((len(optionLabels) + 1) * unsafe.Sizeof(int(0))))
	defer C.free(unsafe.Pointer(arg4))

	{
		var out []*C.char
		ptr.SetSlice(unsafe.Pointer(&dst), unsafe.Pointer(arg4), int(len(optionLabels)))

		for i := range optionLabels {
			arg4 = (*C.char)(C.CString(optionLabels))
			defer C.free(unsafe.Pointer(arg4))
		}
	}

	C.gtk_file_chooser_add_choice(arg0, arg1, arg2, arg3, arg4)
}

// AddFilter adds @filter to the list of filters that the user can select
// between. When a filter is selected, only files that are passed by that
// filter are displayed.
//
// Note that the @chooser takes ownership of the filter if it is floating,
// so you have to ref and sink it if you want to keep a reference.
func (c fileChooser) AddFilter(filter FileFilter) {
	var arg0 *C.GtkFileChooser
	var arg1 *C.GtkFileFilter

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	arg1 = (*C.GtkFileFilter)(unsafe.Pointer(filter.Native()))

	C.gtk_file_chooser_add_filter(arg0, arg1)
}

// AddShortcutFolder adds a folder to be displayed with the shortcut folders
// in a file chooser.
func (c fileChooser) AddShortcutFolder(folder gio.File) error {
	var arg0 *C.GtkFileChooser
	var arg1 *C.GFile

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	arg1 = (*C.GFile)(unsafe.Pointer(folder.Native()))

	var cerr *C.GError

	C.gtk_file_chooser_add_shortcut_folder(arg0, arg1, cerr)

	var goerr error

	goerr = gerror.Take(unsafe.Pointer(cerr))

	return goerr
}

// Action gets the type of operation that the file chooser is performing;
// see gtk_file_chooser_set_action().
func (c fileChooser) Action() FileChooserAction {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

	var cret C.GtkFileChooserAction

	cret = C.gtk_file_chooser_get_action(arg0)

	var fileChooserAction FileChooserAction

	fileChooserAction = FileChooserAction(cret)

	return fileChooserAction
}

// Choice gets the currently selected option in the 'choice' with the given
// ID.
func (c fileChooser) Choice(id string) string {
	var arg0 *C.GtkFileChooser
	var arg1 *C.char

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	arg1 = (*C.char)(C.CString(id))
	defer C.free(unsafe.Pointer(arg1))

	var cret *C.char

	cret = C.gtk_file_chooser_get_choice(arg0, arg1)

	var utf8 string

	utf8 = C.GoString(cret)

	return utf8
}

// CreateFolders gets whether file chooser will offer to create new folders.
// See gtk_file_chooser_set_create_folders().
func (c fileChooser) CreateFolders() bool {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

	var cret C.gboolean

	cret = C.gtk_file_chooser_get_create_folders(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// CurrentFolder gets the current folder of @chooser as #GFile.
func (c fileChooser) CurrentFolder() gio.File {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

	var cret *C.GFile

	cret = C.gtk_file_chooser_get_current_folder(arg0)

	var file gio.File

	file = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(gio.File)

	return file
}

// CurrentName gets the current name in the file selector, as entered by the
// user in the text entry for “Name”.
//
// This is meant to be used in save dialogs, to get the currently typed
// filename when the file itself does not exist yet.
func (c fileChooser) CurrentName() string {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

	var cret *C.char

	cret = C.gtk_file_chooser_get_current_name(arg0)

	var utf8 string

	utf8 = C.GoString(cret)
	defer C.free(unsafe.Pointer(cret))

	return utf8
}

// File gets the #GFile for the currently selected file in the file
// selector. If multiple files are selected, one of the files will be
// returned at random.
//
// If the file chooser is in folder mode, this function returns the selected
// folder.
func (c fileChooser) File() gio.File {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

	var cret *C.GFile

	cret = C.gtk_file_chooser_get_file(arg0)

	var file gio.File

	file = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(gio.File)

	return file
}

// Files lists all the selected files and subfolders in the current folder
// of @chooser as #GFile.
func (c fileChooser) Files() gio.ListModel {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

	var cret *C.GListModel

	cret = C.gtk_file_chooser_get_files(arg0)

	var listModel gio.ListModel

	listModel = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(gio.ListModel)

	return listModel
}

// Filter gets the current filter; see gtk_file_chooser_set_filter().
func (c fileChooser) Filter() FileFilter {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

	var cret *C.GtkFileFilter

	cret = C.gtk_file_chooser_get_filter(arg0)

	var fileFilter FileFilter

	fileFilter = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(FileFilter)

	return fileFilter
}

// Filters gets the current set of user-selectable filters, as a list model;
// see gtk_file_chooser_add_filter(), gtk_file_chooser_remove_filter().
//
// You should not modify the returned list model. Future changes to @chooser
// may or may not affect the returned model.
func (c fileChooser) Filters() gio.ListModel {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

	var cret *C.GListModel

	cret = C.gtk_file_chooser_get_filters(arg0)

	var listModel gio.ListModel

	listModel = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(gio.ListModel)

	return listModel
}

// SelectMultiple gets whether multiple files can be selected in the file
// selector. See gtk_file_chooser_set_select_multiple().
func (c fileChooser) SelectMultiple() bool {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

	var cret C.gboolean

	cret = C.gtk_file_chooser_get_select_multiple(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// ShortcutFolders queries the list of shortcut folders in the file chooser,
// as set by gtk_file_chooser_add_shortcut_folder().
//
// You should not modify the returned list model. Future changes to @chooser
// may or may not affect the returned model.
func (c fileChooser) ShortcutFolders() gio.ListModel {
	var arg0 *C.GtkFileChooser

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

	var cret *C.GListModel

	cret = C.gtk_file_chooser_get_shortcut_folders(arg0)

	var listModel gio.ListModel

	listModel = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(gio.ListModel)

	return listModel
}

// RemoveChoice removes a 'choice' that has been added with
// gtk_file_chooser_add_choice().
func (c fileChooser) RemoveChoice(id string) {
	var arg0 *C.GtkFileChooser
	var arg1 *C.char

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	arg1 = (*C.char)(C.CString(id))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_file_chooser_remove_choice(arg0, arg1)
}

// RemoveFilter removes @filter from the list of filters that the user can
// select between.
func (c fileChooser) RemoveFilter(filter FileFilter) {
	var arg0 *C.GtkFileChooser
	var arg1 *C.GtkFileFilter

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	arg1 = (*C.GtkFileFilter)(unsafe.Pointer(filter.Native()))

	C.gtk_file_chooser_remove_filter(arg0, arg1)
}

// RemoveShortcutFolder removes a folder from the shortcut folders in a file
// chooser.
func (c fileChooser) RemoveShortcutFolder(folder gio.File) error {
	var arg0 *C.GtkFileChooser
	var arg1 *C.GFile

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	arg1 = (*C.GFile)(unsafe.Pointer(folder.Native()))

	var cerr *C.GError

	C.gtk_file_chooser_remove_shortcut_folder(arg0, arg1, cerr)

	var goerr error

	goerr = gerror.Take(unsafe.Pointer(cerr))

	return goerr
}

// SetAction sets the type of operation that the chooser is performing; the
// user interface is adapted to suit the selected action. For example, an
// option to create a new folder might be shown if the action is
// GTK_FILE_CHOOSER_ACTION_SAVE but not if the action is
// GTK_FILE_CHOOSER_ACTION_OPEN.
func (c fileChooser) SetAction(action FileChooserAction) {
	var arg0 *C.GtkFileChooser
	var arg1 C.GtkFileChooserAction

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	arg1 = (C.GtkFileChooserAction)(action)

	C.gtk_file_chooser_set_action(arg0, arg1)
}

// SetChoice selects an option in a 'choice' that has been added with
// gtk_file_chooser_add_choice(). For a boolean choice, the possible options
// are "true" and "false".
func (c fileChooser) SetChoice(id string, option string) {
	var arg0 *C.GtkFileChooser
	var arg1 *C.char
	var arg2 *C.char

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	arg1 = (*C.char)(C.CString(id))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.char)(C.CString(option))
	defer C.free(unsafe.Pointer(arg2))

	C.gtk_file_chooser_set_choice(arg0, arg1, arg2)
}

// SetCreateFolders sets whether file chooser will offer to create new
// folders. This is only relevant if the action is not set to be
// GTK_FILE_CHOOSER_ACTION_OPEN.
func (c fileChooser) SetCreateFolders(createFolders bool) {
	var arg0 *C.GtkFileChooser
	var arg1 C.gboolean

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	if createFolders {
		arg1 = C.gboolean(1)
	}

	C.gtk_file_chooser_set_create_folders(arg0, arg1)
}

// SetCurrentFolder sets the current folder for @chooser from a #GFile.
func (c fileChooser) SetCurrentFolder(file gio.File) error {
	var arg0 *C.GtkFileChooser
	var arg1 *C.GFile

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	arg1 = (*C.GFile)(unsafe.Pointer(file.Native()))

	var cerr *C.GError

	C.gtk_file_chooser_set_current_folder(arg0, arg1, cerr)

	var goerr error

	goerr = gerror.Take(unsafe.Pointer(cerr))

	return goerr
}

// SetCurrentName sets the current name in the file selector, as if entered
// by the user. Note that the name passed in here is a UTF-8 string rather
// than a filename. This function is meant for such uses as a suggested name
// in a “Save As...” dialog. You can pass “Untitled.doc” or a similarly
// suitable suggestion for the @name.
//
// If you want to preselect a particular existing file, you should use
// gtk_file_chooser_set_file() instead.
//
// Please see the documentation for those functions for an example of using
// gtk_file_chooser_set_current_name() as well.
func (c fileChooser) SetCurrentName(name string) {
	var arg0 *C.GtkFileChooser
	var arg1 *C.char

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_file_chooser_set_current_name(arg0, arg1)
}

// SetFile sets @file as the current filename for the file chooser, by
// changing to the file’s parent folder and actually selecting the file in
// list. If the @chooser is in GTK_FILE_CHOOSER_ACTION_SAVE mode, the file’s
// base name will also appear in the dialog’s file name entry.
//
// If the file name isn’t in the current folder of @chooser, then the
// current folder of @chooser will be changed to the folder containing
// @filename.
//
// Note that the file must exist, or nothing will be done except for the
// directory change.
//
// If you are implementing a save dialog, you should use this function if
// you already have a file name to which the user may save; for example,
// when the user opens an existing file and then does Save As... If you
// don’t have a file name already — for example, if the user just created a
// new file and is saving it for the first time, do not call this function.
// Instead, use something similar to this:
//
//    static void
//    prepare_file_chooser (GtkFileChooser *chooser,
//                          GFile          *existing_file)
//    {
//      gboolean document_is_new = (existing_file == NULL);
//
//      if (document_is_new)
//        {
//          GFile *default_file_for_saving = g_file_new_for_path ("./out.txt");
//          // the user just created a new document
//          gtk_file_chooser_set_current_folder (chooser, default_file_for_saving, NULL);
//          gtk_file_chooser_set_current_name (chooser, "Untitled document");
//          g_object_unref (default_file_for_saving);
//        }
//      else
//        {
//          // the user edited an existing document
//          gtk_file_chooser_set_file (chooser, existing_file, NULL);
//        }
//    }
func (c fileChooser) SetFile(file gio.File) error {
	var arg0 *C.GtkFileChooser
	var arg1 *C.GFile

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	arg1 = (*C.GFile)(unsafe.Pointer(file.Native()))

	var cerr *C.GError

	C.gtk_file_chooser_set_file(arg0, arg1, cerr)

	var goerr error

	goerr = gerror.Take(unsafe.Pointer(cerr))

	return goerr
}

// SetFilter sets the current filter; only the files that pass the filter
// will be displayed. If the user-selectable list of filters is non-empty,
// then the filter should be one of the filters in that list. Setting the
// current filter when the list of filters is empty is useful if you want to
// restrict the displayed set of files without letting the user change it.
func (c fileChooser) SetFilter(filter FileFilter) {
	var arg0 *C.GtkFileChooser
	var arg1 *C.GtkFileFilter

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	arg1 = (*C.GtkFileFilter)(unsafe.Pointer(filter.Native()))

	C.gtk_file_chooser_set_filter(arg0, arg1)
}

// SetSelectMultiple sets whether multiple files can be selected in the file
// selector. This is only relevant if the action is set to be
// GTK_FILE_CHOOSER_ACTION_OPEN or GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER.
func (c fileChooser) SetSelectMultiple(selectMultiple bool) {
	var arg0 *C.GtkFileChooser
	var arg1 C.gboolean

	arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
	if selectMultiple {
		arg1 = C.gboolean(1)
	}

	C.gtk_file_chooser_set_select_multiple(arg0, arg1)
}

// StyleProvider: gtkStyleProvider is an interface used to provide style
// information to a StyleContext. See gtk_style_context_add_provider() and
// gtk_style_context_add_provider_for_display().
type StyleProvider interface {
	gextras.Objector
}

// styleProvider implements the StyleProvider interface.
type styleProvider struct {
	gextras.Objector
}

var _ StyleProvider = (*styleProvider)(nil)

// WrapStyleProvider wraps a GObject to a type that implements interface
// StyleProvider. It is primarily used internally.
func WrapStyleProvider(obj *externglib.Object) StyleProvider {
	return StyleProvider{
		Objector: obj,
	}
}

func marshalStyleProvider(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapStyleProvider(obj), nil
}

// AboutDialog: the GtkAboutDialog offers a simple way to display information
// about a program like its logo, name, copyright, website and license. It is
// also possible to give credits to the authors, documenters, translators and
// artists who have worked on the program. An about dialog is typically opened
// when the user selects the `About` option from the `Help` menu. All parts of
// the dialog are optional.
//
// About dialogs often contain links and email addresses. GtkAboutDialog
// displays these as clickable links. By default, it calls gtk_show_uri() when a
// user clicks one. The behaviour can be overridden with the
// AboutDialog::activate-link signal.
//
// To specify a person with an email address, use a string like "Edgar Allan Poe
// <edgar\@poe.com>". To specify a website with a title, use a string like "GTK
// team http://www.gtk.org".
//
// To make constructing a GtkAboutDialog as convenient as possible, you can use
// the function gtk_show_about_dialog() which constructs and shows a dialog and
// keeps it around so that it can be shown again.
//
// Note that GTK sets a default title of `_("About s")` on the dialog window
// (where \s is replaced by the name of the application, but in order to ensure
// proper translation of the title, applications should set the title property
// explicitly when constructing a GtkAboutDialog, as shown in the following
// example:
//
//    GFile *logo_file = g_file_new_for_path ("./logo.png");
//    GdkTexture *example_logo = gdk_texture_new_from_file (logo_file, NULL);
//    g_object_unref (logo_file);
//
//    gtk_show_about_dialog (NULL,
//                           "program-name", "ExampleCode",
//                           "logo", example_logo,
//                           "title", _("About ExampleCode"),
//                           NULL);
//
//
// CSS nodes
//
// GtkAboutDialog has a single CSS node with the name window and style class
// .aboutdialog.
type AboutDialog interface {
	Window
	Accessible
	Buildable
	ConstraintTarget
	Native
	Root
	ShortcutManager

	// AddCreditSection creates a new section in the Credits page.
	AddCreditSection(sectionName string, people []string)
	// Artists returns the string which are displayed in the artists tab of the
	// secondary credits dialog.
	Artists() []string
	// Authors returns the string which are displayed in the authors tab of the
	// secondary credits dialog.
	Authors() []string
	// Comments returns the comments string.
	Comments() string
	// Copyright returns the copyright string.
	Copyright() string
	// Documenters returns the string which are displayed in the documenters tab
	// of the secondary credits dialog.
	Documenters() []string
	// License returns the license information.
	License() string
	// LicenseType retrieves the license set using
	// gtk_about_dialog_set_license_type()
	LicenseType() License
	// Logo returns the paintable displayed as logo in the about dialog.
	Logo() gdk.Paintable
	// LogoIconName returns the icon name displayed as logo in the about dialog.
	LogoIconName() string
	// ProgramName returns the program name displayed in the about dialog.
	ProgramName() string
	// SystemInformation returns the system information that is shown in the
	// about dialog.
	SystemInformation() string
	// TranslatorCredits returns the translator credits string which is
	// displayed in the translators tab of the secondary credits dialog.
	TranslatorCredits() string
	// Version returns the version string.
	Version() string
	// Website returns the website URL.
	Website() string
	// WebsiteLabel returns the label used for the website link.
	WebsiteLabel() string
	// WrapLicense returns whether the license text in @about is automatically
	// wrapped.
	WrapLicense() bool
	// SetArtists sets the strings which are displayed in the artists tab of the
	// secondary credits dialog.
	SetArtists(artists []string)
	// SetAuthors sets the strings which are displayed in the authors tab of the
	// secondary credits dialog.
	SetAuthors(authors []string)
	// SetComments sets the comments string to display in the about dialog. This
	// should be a short string of one or two lines.
	SetComments(comments string)
	// SetCopyright sets the copyright string to display in the about dialog.
	// This should be a short string of one or two lines.
	SetCopyright(copyright string)
	// SetDocumenters sets the strings which are displayed in the documenters
	// tab of the credits dialog.
	SetDocumenters(documenters []string)
	// SetLicense sets the license information to be displayed in the secondary
	// license dialog. If @license is nil, the license button is hidden.
	SetLicense(license string)
	// SetLicenseType sets the license of the application showing the @about
	// dialog from a list of known licenses.
	//
	// This function overrides the license set using
	// gtk_about_dialog_set_license().
	SetLicenseType(licenseType License)
	// SetLogo sets the logo in the about dialog.
	SetLogo(logo gdk.Paintable)
	// SetLogoIconName sets the icon name to be displayed as logo in the about
	// dialog.
	SetLogoIconName(iconName string)
	// SetProgramName sets the name to display in the about dialog. If this is
	// not set, it defaults to g_get_application_name().
	SetProgramName(name string)
	// SetSystemInformation sets the system information to be displayed in the
	// about dialog. If @system_information is nil, the system information tab
	// is hidden.
	//
	// See AboutDialog:system-information.
	SetSystemInformation(systemInformation string)
	// SetTranslatorCredits sets the translator credits string which is
	// displayed in the translators tab of the secondary credits dialog.
	//
	// The intended use for this string is to display the translator of the
	// language which is currently used in the user interface. Using gettext(),
	// a simple way to achieve that is to mark the string for translation:
	//
	//    GtkWidget *about = gtk_about_dialog_new ();
	//     gtk_about_dialog_set_translator_credits (GTK_ABOUT_DIALOG (about),
	//                                              _("translator-credits"));
	//
	// It is a good idea to use the customary msgid “translator-credits” for
	// this purpose, since translators will already know the purpose of that
	// msgid, and since AboutDialog will detect if “translator-credits” is
	// untranslated and hide the tab.
	SetTranslatorCredits(translatorCredits string)
	// SetVersion sets the version string to display in the about dialog.
	SetVersion(version string)
	// SetWebsite sets the URL to use for the website link.
	SetWebsite(website string)
	// SetWebsiteLabel sets the label to be used for the website link.
	SetWebsiteLabel(websiteLabel string)
	// SetWrapLicense sets whether the license text in @about is automatically
	// wrapped.
	SetWrapLicense(wrapLicense bool)
}

// aboutDialog implements the AboutDialog interface.
type aboutDialog struct {
	Window
	Accessible
	Buildable
	ConstraintTarget
	Native
	Root
	ShortcutManager
}

var _ AboutDialog = (*aboutDialog)(nil)

// WrapAboutDialog wraps a GObject to the right type. It is
// primarily used internally.
func WrapAboutDialog(obj *externglib.Object) AboutDialog {
	return AboutDialog{
		Window:           WrapWindow(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
		Native:           WrapNative(obj),
		Root:             WrapRoot(obj),
		ShortcutManager:  WrapShortcutManager(obj),
	}
}

func marshalAboutDialog(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapAboutDialog(obj), nil
}

// NewAboutDialog constructs a class AboutDialog.
func NewAboutDialog() AboutDialog {
	var cret C.GtkAboutDialog

	cret = C.gtk_about_dialog_new()

	var aboutDialog AboutDialog

	aboutDialog = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(AboutDialog)

	return aboutDialog
}

// AddCreditSection creates a new section in the Credits page.
func (a aboutDialog) AddCreditSection(sectionName string, people []string) {
	var arg0 *C.GtkAboutDialog
	var arg1 *C.char
	var arg2 **C.char

	arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
	arg1 = (*C.char)(C.CString(sectionName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (**C.char)(C.malloc((len(people) + 1) * unsafe.Sizeof(int(0))))
	defer C.free(unsafe.Pointer(arg2))

	{
		var out []*C.char
		ptr.SetSlice(unsafe.Pointer(&dst), unsafe.Pointer(arg2), int(len(people)))

		for i := range people {
			arg2 = (*C.char)(C.CString(people))
			defer C.free(unsafe.Pointer(arg2))
		}
	}

	C.gtk_about_dialog_add_credit_section(arg0, arg1, arg2)
}

// Artists returns the string which are displayed in the artists tab of the
// secondary credits dialog.
func (a aboutDialog) Artists() []string {
	var arg0 *C.GtkAboutDialog

	arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

	var cret **C.char

	cret = C.gtk_about_dialog_get_artists(arg0)

	var utf8s []string

	{
		var length int
		for p := cret; *p != 0; p = (**C.char)(ptr.Add(unsafe.Pointer(p), unsafe.Sizeof(int(0)))) {
			length++
			if length < 0 {
				panic(`length overflow`)
			}
		}

		var src []*C.gchar
		ptr.SetSlice(unsafe.Pointer(&src), unsafe.Pointer(cret), int(length))

		utf8s = make([]string, length)
		for i := uintptr(0); i < uintptr(length); i += unsafe.Sizeof(int(0)) {
			utf8s = C.GoString(cret)
		}
	}

	return utf8s
}

// Authors returns the string which are displayed in the authors tab of the
// secondary credits dialog.
func (a aboutDialog) Authors() []string {
	var arg0 *C.GtkAboutDialog

	arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

	var cret **C.char

	cret = C.gtk_about_dialog_get_authors(arg0)

	var utf8s []string

	{
		var length int
		for p := cret; *p != 0; p = (**C.char)(ptr.Add(unsafe.Pointer(p), unsafe.Sizeof(int(0)))) {
			length++
			if length < 0 {
				panic(`length overflow`)
			}
		}

		var src []*C.gchar
		ptr.SetSlice(unsafe.Pointer(&src), unsafe.Pointer(cret), int(length))

		utf8s = make([]string, length)
		for i := uintptr(0); i < uintptr(length); i += unsafe.Sizeof(int(0)) {
			utf8s = C.GoString(cret)
		}
	}

	return utf8s
}

// Comments returns the comments string.
func (a aboutDialog) Comments() string {
	var arg0 *C.GtkAboutDialog

	arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

	var cret *C.char

	cret = C.gtk_about_dialog_get_comments(arg0)

	var utf8 string

	utf8 = C.GoString(cret)

	return utf8
}

// Copyright returns the copyright string.
func (a aboutDialog) Copyright() string {
	var arg0 *C.GtkAboutDialog

	arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

	var cret *C.char

	cret = C.gtk_about_dialog_get_copyright(arg0)

	var utf8 string

	utf8 = C.GoString(cret)

	return utf8
}

// Documenters returns the string which are displayed in the documenters tab
// of the secondary credits dialog.
func (a aboutDialog) Documenters() []string {
	var arg0 *C.GtkAboutDialog

	arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

	var cret **C.char

	cret = C.gtk_about_dialog_get_documenters(arg0)

	var utf8s []string

	{
		var length int
		for p := cret; *p != 0; p = (**C.char)(ptr.Add(unsafe.Pointer(p), unsafe.Sizeof(int(0)))) {
			length++
			if length < 0 {
				panic(`length overflow`)
			}
		}

		var src []*C.gchar
		ptr.SetSlice(unsafe.Pointer(&src), unsafe.Pointer(cret), int(length))

		utf8s = make([]string, length)
		for i := uintptr(0); i < uintptr(length); i += unsafe.Sizeof(int(0)) {
			utf8s = C.GoString(cret)
		}
	}

	return utf8s
}

// License returns the license information.
func (a aboutDialog) License() string {
	var arg0 *C.GtkAboutDialog

	arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

	var cret *C.char

	cret = C.gtk_about_dialog_get_license(arg0)

	var utf8 string

	utf8 = C.GoString(cret)

	return utf8
}

// LicenseType retrieves the license set using
// gtk_about_dialog_set_license_type()
func (a aboutDialog) LicenseType() License {
	var arg0 *C.GtkAboutDialog

	arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

	var cret C.GtkLicense

	cret = C.gtk_about_dialog_get_license_type(arg0)

	var license License

	license = License(cret)

	return license
}

// Logo returns the paintable displayed as logo in the about dialog.
func (a aboutDialog) Logo() gdk.Paintable {
	var arg0 *C.GtkAboutDialog

	arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

	var cret *C.GdkPaintable

	cret = C.gtk_about_dialog_get_logo(arg0)

	var paintable gdk.Paintable

	paintable = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(gdk.Paintable)

	return paintable
}

// LogoIconName returns the icon name displayed as logo in the about dialog.
func (a aboutDialog) LogoIconName() string {
	var arg0 *C.GtkAboutDialog

	arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

	var cret *C.char

	cret = C.gtk_about_dialog_get_logo_icon_name(arg0)

	var utf8 string

	utf8 = C.GoString(cret)

	return utf8
}

// ProgramName returns the program name displayed in the about dialog.
func (a aboutDialog) ProgramName() string {
	var arg0 *C.GtkAboutDialog

	arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

	var cret *C.char

	cret = C.gtk_about_dialog_get_program_name(arg0)

	var utf8 string

	utf8 = C.GoString(cret)

	return utf8
}

// SystemInformation returns the system information that is shown in the
// about dialog.
func (a aboutDialog) SystemInformation() string {
	var arg0 *C.GtkAboutDialog

	arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

	var cret *C.char

	cret = C.gtk_about_dialog_get_system_information(arg0)

	var utf8 string

	utf8 = C.GoString(cret)

	return utf8
}

// TranslatorCredits returns the translator credits string which is
// displayed in the translators tab of the secondary credits dialog.
func (a aboutDialog) TranslatorCredits() string {
	var arg0 *C.GtkAboutDialog

	arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

	var cret *C.char

	cret = C.gtk_about_dialog_get_translator_credits(arg0)

	var utf8 string

	utf8 = C.GoString(cret)

	return utf8
}

// Version returns the version string.
func (a aboutDialog) Version() string {
	var arg0 *C.GtkAboutDialog

	arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

	var cret *C.char

	cret = C.gtk_about_dialog_get_version(arg0)

	var utf8 string

	utf8 = C.GoString(cret)

	return utf8
}

// Website returns the website URL.
func (a aboutDialog) Website() string {
	var arg0 *C.GtkAboutDialog

	arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

	var cret *C.char

	cret = C.gtk_about_dialog_get_website(arg0)

	var utf8 string

	utf8 = C.GoString(cret)

	return utf8
}

// WebsiteLabel returns the label used for the website link.
func (a aboutDialog) WebsiteLabel() string {
	var arg0 *C.GtkAboutDialog

	arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

	var cret *C.char

	cret = C.gtk_about_dialog_get_website_label(arg0)

	var utf8 string

	utf8 = C.GoString(cret)

	return utf8
}

// WrapLicense returns whether the license text in @about is automatically
// wrapped.
func (a aboutDialog) WrapLicense() bool {
	var arg0 *C.GtkAboutDialog

	arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

	var cret C.gboolean

	cret = C.gtk_about_dialog_get_wrap_license(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// SetArtists sets the strings which are displayed in the artists tab of the
// secondary credits dialog.
func (a aboutDialog) SetArtists(artists []string) {
	var arg0 *C.GtkAboutDialog
	var arg1 **C.char

	arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
	arg1 = (**C.char)(C.malloc((len(artists) + 1) * unsafe.Sizeof(int(0))))
	defer C.free(unsafe.Pointer(arg1))

	{
		var out []*C.char
		ptr.SetSlice(unsafe.Pointer(&dst), unsafe.Pointer(arg1), int(len(artists)))

		for i := range artists {
			arg1 = (*C.char)(C.CString(artists))
			defer C.free(unsafe.Pointer(arg1))
		}
	}

	C.gtk_about_dialog_set_artists(arg0, arg1)
}

// SetAuthors sets the strings which are displayed in the authors tab of the
// secondary credits dialog.
func (a aboutDialog) SetAuthors(authors []string) {
	var arg0 *C.GtkAboutDialog
	var arg1 **C.char

	arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
	arg1 = (**C.char)(C.malloc((len(authors) + 1) * unsafe.Sizeof(int(0))))
	defer C.free(unsafe.Pointer(arg1))

	{
		var out []*C.char
		ptr.SetSlice(unsafe.Pointer(&dst), unsafe.Pointer(arg1), int(len(authors)))

		for i := range authors {
			arg1 = (*C.char)(C.CString(authors))
			defer C.free(unsafe.Pointer(arg1))
		}
	}

	C.gtk_about_dialog_set_authors(arg0, arg1)
}

// SetComments sets the comments string to display in the about dialog. This
// should be a short string of one or two lines.
func (a aboutDialog) SetComments(comments string) {
	var arg0 *C.GtkAboutDialog
	var arg1 *C.char

	arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
	arg1 = (*C.char)(C.CString(comments))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_about_dialog_set_comments(arg0, arg1)
}

// SetCopyright sets the copyright string to display in the about dialog.
// This should be a short string of one or two lines.
func (a aboutDialog) SetCopyright(copyright string) {
	var arg0 *C.GtkAboutDialog
	var arg1 *C.char

	arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
	arg1 = (*C.char)(C.CString(copyright))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_about_dialog_set_copyright(arg0, arg1)
}

// SetDocumenters sets the strings which are displayed in the documenters
// tab of the credits dialog.
func (a aboutDialog) SetDocumenters(documenters []string) {
	var arg0 *C.GtkAboutDialog
	var arg1 **C.char

	arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
	arg1 = (**C.char)(C.malloc((len(documenters) + 1) * unsafe.Sizeof(int(0))))
	defer C.free(unsafe.Pointer(arg1))

	{
		var out []*C.char
		ptr.SetSlice(unsafe.Pointer(&dst), unsafe.Pointer(arg1), int(len(documenters)))

		for i := range documenters {
			arg1 = (*C.char)(C.CString(documenters))
			defer C.free(unsafe.Pointer(arg1))
		}
	}

	C.gtk_about_dialog_set_documenters(arg0, arg1)
}

// SetLicense sets the license information to be displayed in the secondary
// license dialog. If @license is nil, the license button is hidden.
func (a aboutDialog) SetLicense(license string) {
	var arg0 *C.GtkAboutDialog
	var arg1 *C.char

	arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
	arg1 = (*C.char)(C.CString(license))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_about_dialog_set_license(arg0, arg1)
}

// SetLicenseType sets the license of the application showing the @about
// dialog from a list of known licenses.
//
// This function overrides the license set using
// gtk_about_dialog_set_license().
func (a aboutDialog) SetLicenseType(licenseType License) {
	var arg0 *C.GtkAboutDialog
	var arg1 C.GtkLicense

	arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
	arg1 = (C.GtkLicense)(licenseType)

	C.gtk_about_dialog_set_license_type(arg0, arg1)
}

// SetLogo sets the logo in the about dialog.
func (a aboutDialog) SetLogo(logo gdk.Paintable) {
	var arg0 *C.GtkAboutDialog
	var arg1 *C.GdkPaintable

	arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
	arg1 = (*C.GdkPaintable)(unsafe.Pointer(logo.Native()))

	C.gtk_about_dialog_set_logo(arg0, arg1)
}

// SetLogoIconName sets the icon name to be displayed as logo in the about
// dialog.
func (a aboutDialog) SetLogoIconName(iconName string) {
	var arg0 *C.GtkAboutDialog
	var arg1 *C.char

	arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
	arg1 = (*C.char)(C.CString(iconName))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_about_dialog_set_logo_icon_name(arg0, arg1)
}

// SetProgramName sets the name to display in the about dialog. If this is
// not set, it defaults to g_get_application_name().
func (a aboutDialog) SetProgramName(name string) {
	var arg0 *C.GtkAboutDialog
	var arg1 *C.char

	arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
	arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_about_dialog_set_program_name(arg0, arg1)
}

// SetSystemInformation sets the system information to be displayed in the
// about dialog. If @system_information is nil, the system information tab
// is hidden.
//
// See AboutDialog:system-information.
func (a aboutDialog) SetSystemInformation(systemInformation string) {
	var arg0 *C.GtkAboutDialog
	var arg1 *C.char

	arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
	arg1 = (*C.char)(C.CString(systemInformation))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_about_dialog_set_system_information(arg0, arg1)
}

// SetTranslatorCredits sets the translator credits string which is
// displayed in the translators tab of the secondary credits dialog.
//
// The intended use for this string is to display the translator of the
// language which is currently used in the user interface. Using gettext(),
// a simple way to achieve that is to mark the string for translation:
//
//    GtkWidget *about = gtk_about_dialog_new ();
//     gtk_about_dialog_set_translator_credits (GTK_ABOUT_DIALOG (about),
//                                              _("translator-credits"));
//
// It is a good idea to use the customary msgid “translator-credits” for
// this purpose, since translators will already know the purpose of that
// msgid, and since AboutDialog will detect if “translator-credits” is
// untranslated and hide the tab.
func (a aboutDialog) SetTranslatorCredits(translatorCredits string) {
	var arg0 *C.GtkAboutDialog
	var arg1 *C.char

	arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
	arg1 = (*C.char)(C.CString(translatorCredits))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_about_dialog_set_translator_credits(arg0, arg1)
}

// SetVersion sets the version string to display in the about dialog.
func (a aboutDialog) SetVersion(version string) {
	var arg0 *C.GtkAboutDialog
	var arg1 *C.char

	arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
	arg1 = (*C.char)(C.CString(version))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_about_dialog_set_version(arg0, arg1)
}

// SetWebsite sets the URL to use for the website link.
func (a aboutDialog) SetWebsite(website string) {
	var arg0 *C.GtkAboutDialog
	var arg1 *C.char

	arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
	arg1 = (*C.char)(C.CString(website))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_about_dialog_set_website(arg0, arg1)
}

// SetWebsiteLabel sets the label to be used for the website link.
func (a aboutDialog) SetWebsiteLabel(websiteLabel string) {
	var arg0 *C.GtkAboutDialog
	var arg1 *C.char

	arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
	arg1 = (*C.char)(C.CString(websiteLabel))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_about_dialog_set_website_label(arg0, arg1)
}

// SetWrapLicense sets whether the license text in @about is automatically
// wrapped.
func (a aboutDialog) SetWrapLicense(wrapLicense bool) {
	var arg0 *C.GtkAboutDialog
	var arg1 C.gboolean

	arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
	if wrapLicense {
		arg1 = C.gboolean(1)
	}

	C.gtk_about_dialog_set_wrap_license(arg0, arg1)
}

// ActionBar: gtkActionBar is designed to present contextual actions. It is
// expected to be displayed below the content and expand horizontally to fill
// the area.
//
// It allows placing children at the start or the end. In addition, it contains
// an internal centered box which is centered with respect to the full width of
// the box, even if the children at either side take up different amounts of
// space.
//
//
// CSS nodes
//
// GtkActionBar has a single CSS node with name actionbar.
type ActionBar interface {
	Widget
	Accessible
	Buildable
	ConstraintTarget

	// CenterWidget retrieves the center bar widget of the bar.
	CenterWidget() Widget
	// Revealed gets the value of the ActionBar:revealed property.
	Revealed() bool
	// PackEnd adds @child to @action_bar, packed with reference to the end of
	// the @action_bar.
	PackEnd(child Widget)
	// PackStart adds @child to @action_bar, packed with reference to the start
	// of the @action_bar.
	PackStart(child Widget)
	// Remove removes a child from @action_bar.
	Remove(child Widget)
	// SetCenterWidget sets the center widget for the ActionBar.
	SetCenterWidget(centerWidget Widget)
	// SetRevealed sets the ActionBar:revealed property to @revealed. Changing
	// this will make @action_bar reveal (true) or conceal (false) itself via a
	// sliding transition.
	//
	// Note: this does not show or hide @action_bar in the Widget:visible sense,
	// so revealing has no effect if Widget:visible is false.
	SetRevealed(revealed bool)
}

// actionBar implements the ActionBar interface.
type actionBar struct {
	Widget
	Accessible
	Buildable
	ConstraintTarget
}

var _ ActionBar = (*actionBar)(nil)

// WrapActionBar wraps a GObject to the right type. It is
// primarily used internally.
func WrapActionBar(obj *externglib.Object) ActionBar {
	return ActionBar{
		Widget:           WrapWidget(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
	}
}

func marshalActionBar(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapActionBar(obj), nil
}

// NewActionBar constructs a class ActionBar.
func NewActionBar() ActionBar {
	var cret C.GtkActionBar

	cret = C.gtk_action_bar_new()

	var actionBar ActionBar

	actionBar = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(ActionBar)

	return actionBar
}

// CenterWidget retrieves the center bar widget of the bar.
func (a actionBar) CenterWidget() Widget {
	var arg0 *C.GtkActionBar

	arg0 = (*C.GtkActionBar)(unsafe.Pointer(a.Native()))

	var cret *C.GtkWidget

	cret = C.gtk_action_bar_get_center_widget(arg0)

	var widget Widget

	widget = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Widget)

	return widget
}

// Revealed gets the value of the ActionBar:revealed property.
func (a actionBar) Revealed() bool {
	var arg0 *C.GtkActionBar

	arg0 = (*C.GtkActionBar)(unsafe.Pointer(a.Native()))

	var cret C.gboolean

	cret = C.gtk_action_bar_get_revealed(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// PackEnd adds @child to @action_bar, packed with reference to the end of
// the @action_bar.
func (a actionBar) PackEnd(child Widget) {
	var arg0 *C.GtkActionBar
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkActionBar)(unsafe.Pointer(a.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_action_bar_pack_end(arg0, arg1)
}

// PackStart adds @child to @action_bar, packed with reference to the start
// of the @action_bar.
func (a actionBar) PackStart(child Widget) {
	var arg0 *C.GtkActionBar
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkActionBar)(unsafe.Pointer(a.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_action_bar_pack_start(arg0, arg1)
}

// Remove removes a child from @action_bar.
func (a actionBar) Remove(child Widget) {
	var arg0 *C.GtkActionBar
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkActionBar)(unsafe.Pointer(a.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_action_bar_remove(arg0, arg1)
}

// SetCenterWidget sets the center widget for the ActionBar.
func (a actionBar) SetCenterWidget(centerWidget Widget) {
	var arg0 *C.GtkActionBar
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkActionBar)(unsafe.Pointer(a.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(centerWidget.Native()))

	C.gtk_action_bar_set_center_widget(arg0, arg1)
}

// SetRevealed sets the ActionBar:revealed property to @revealed. Changing
// this will make @action_bar reveal (true) or conceal (false) itself via a
// sliding transition.
//
// Note: this does not show or hide @action_bar in the Widget:visible sense,
// so revealing has no effect if Widget:visible is false.
func (a actionBar) SetRevealed(revealed bool) {
	var arg0 *C.GtkActionBar
	var arg1 C.gboolean

	arg0 = (*C.GtkActionBar)(unsafe.Pointer(a.Native()))
	if revealed {
		arg1 = C.gboolean(1)
	}

	C.gtk_action_bar_set_revealed(arg0, arg1)
}

// AppChooserButton: the AppChooserButton is a widget that lets the user select
// an application. It implements the AppChooser interface.
//
// Initially, a AppChooserButton selects the first application in its list,
// which will either be the most-recently used application or, if
// AppChooserButton:show-default-item is true, the default application.
//
// The list of applications shown in a AppChooserButton includes the recommended
// applications for the given content type. When
// AppChooserButton:show-default-item is set, the default application is also
// included. To let the user chooser other applications, you can set the
// AppChooserButton:show-dialog-item property, which allows to open a full
// AppChooserDialog.
//
// It is possible to add custom items to the list, using
// gtk_app_chooser_button_append_custom_item(). These items cause the
// AppChooserButton::custom-item-activated signal to be emitted when they are
// selected.
//
// To track changes in the selected application, use the
// AppChooserButton::changed signal.
//
//
// CSS nodes
//
// GtkAppChooserButton has a single CSS node with the name “appchooserbutton”.
type AppChooserButton interface {
	Widget
	Accessible
	AppChooser
	Buildable
	ConstraintTarget

	// AppendCustomItem appends a custom item to the list of applications that
	// is shown in the popup; the item name must be unique per-widget. Clients
	// can use the provided name as a detail for the
	// AppChooserButton::custom-item-activated signal, to add a callback for the
	// activation of a particular custom item in the list. See also
	// gtk_app_chooser_button_append_separator().
	AppendCustomItem(name string, label string, icon gio.Icon)
	// AppendSeparator appends a separator to the list of applications that is
	// shown in the popup.
	AppendSeparator()
	// Heading returns the text to display at the top of the dialog.
	Heading() string
	// Modal gets whether the dialog is modal.
	Modal() bool
	// ShowDefaultItem returns the current value of the
	// AppChooserButton:show-default-item property.
	ShowDefaultItem() bool
	// ShowDialogItem returns the current value of the
	// AppChooserButton:show-dialog-item property.
	ShowDialogItem() bool
	// SetActiveCustomItem selects a custom item previously added with
	// gtk_app_chooser_button_append_custom_item().
	//
	// Use gtk_app_chooser_refresh() to bring the selection to its initial
	// state.
	SetActiveCustomItem(name string)
	// SetHeading sets the text to display at the top of the dialog. If the
	// heading is not set, the dialog displays a default text.
	SetHeading(heading string)
	// SetModal sets whether the dialog should be modal.
	SetModal(modal bool)
	// SetShowDefaultItem sets whether the dropdown menu of this button should
	// show the default application for the given content type at top.
	SetShowDefaultItem(setting bool)
	// SetShowDialogItem sets whether the dropdown menu of this button should
	// show an entry to trigger a AppChooserDialog.
	SetShowDialogItem(setting bool)
}

// appChooserButton implements the AppChooserButton interface.
type appChooserButton struct {
	Widget
	Accessible
	AppChooser
	Buildable
	ConstraintTarget
}

var _ AppChooserButton = (*appChooserButton)(nil)

// WrapAppChooserButton wraps a GObject to the right type. It is
// primarily used internally.
func WrapAppChooserButton(obj *externglib.Object) AppChooserButton {
	return AppChooserButton{
		Widget:           WrapWidget(obj),
		Accessible:       WrapAccessible(obj),
		AppChooser:       WrapAppChooser(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
	}
}

func marshalAppChooserButton(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapAppChooserButton(obj), nil
}

// NewAppChooserButton constructs a class AppChooserButton.
func NewAppChooserButton(contentType string) AppChooserButton {
	var arg1 *C.char

	arg1 = (*C.char)(C.CString(contentType))
	defer C.free(unsafe.Pointer(arg1))

	var cret C.GtkAppChooserButton

	cret = C.gtk_app_chooser_button_new(arg1)

	var appChooserButton AppChooserButton

	appChooserButton = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(AppChooserButton)

	return appChooserButton
}

// AppendCustomItem appends a custom item to the list of applications that
// is shown in the popup; the item name must be unique per-widget. Clients
// can use the provided name as a detail for the
// AppChooserButton::custom-item-activated signal, to add a callback for the
// activation of a particular custom item in the list. See also
// gtk_app_chooser_button_append_separator().
func (s appChooserButton) AppendCustomItem(name string, label string, icon gio.Icon) {
	var arg0 *C.GtkAppChooserButton
	var arg1 *C.char
	var arg2 *C.char
	var arg3 *C.GIcon

	arg0 = (*C.GtkAppChooserButton)(unsafe.Pointer(s.Native()))
	arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.char)(C.CString(label))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.GIcon)(unsafe.Pointer(icon.Native()))

	C.gtk_app_chooser_button_append_custom_item(arg0, arg1, arg2, arg3)
}

// AppendSeparator appends a separator to the list of applications that is
// shown in the popup.
func (s appChooserButton) AppendSeparator() {
	var arg0 *C.GtkAppChooserButton

	arg0 = (*C.GtkAppChooserButton)(unsafe.Pointer(s.Native()))

	C.gtk_app_chooser_button_append_separator(arg0)
}

// Heading returns the text to display at the top of the dialog.
func (s appChooserButton) Heading() string {
	var arg0 *C.GtkAppChooserButton

	arg0 = (*C.GtkAppChooserButton)(unsafe.Pointer(s.Native()))

	var cret *C.char

	cret = C.gtk_app_chooser_button_get_heading(arg0)

	var utf8 string

	utf8 = C.GoString(cret)

	return utf8
}

// Modal gets whether the dialog is modal.
func (s appChooserButton) Modal() bool {
	var arg0 *C.GtkAppChooserButton

	arg0 = (*C.GtkAppChooserButton)(unsafe.Pointer(s.Native()))

	var cret C.gboolean

	cret = C.gtk_app_chooser_button_get_modal(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// ShowDefaultItem returns the current value of the
// AppChooserButton:show-default-item property.
func (s appChooserButton) ShowDefaultItem() bool {
	var arg0 *C.GtkAppChooserButton

	arg0 = (*C.GtkAppChooserButton)(unsafe.Pointer(s.Native()))

	var cret C.gboolean

	cret = C.gtk_app_chooser_button_get_show_default_item(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// ShowDialogItem returns the current value of the
// AppChooserButton:show-dialog-item property.
func (s appChooserButton) ShowDialogItem() bool {
	var arg0 *C.GtkAppChooserButton

	arg0 = (*C.GtkAppChooserButton)(unsafe.Pointer(s.Native()))

	var cret C.gboolean

	cret = C.gtk_app_chooser_button_get_show_dialog_item(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// SetActiveCustomItem selects a custom item previously added with
// gtk_app_chooser_button_append_custom_item().
//
// Use gtk_app_chooser_refresh() to bring the selection to its initial
// state.
func (s appChooserButton) SetActiveCustomItem(name string) {
	var arg0 *C.GtkAppChooserButton
	var arg1 *C.char

	arg0 = (*C.GtkAppChooserButton)(unsafe.Pointer(s.Native()))
	arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_app_chooser_button_set_active_custom_item(arg0, arg1)
}

// SetHeading sets the text to display at the top of the dialog. If the
// heading is not set, the dialog displays a default text.
func (s appChooserButton) SetHeading(heading string) {
	var arg0 *C.GtkAppChooserButton
	var arg1 *C.char

	arg0 = (*C.GtkAppChooserButton)(unsafe.Pointer(s.Native()))
	arg1 = (*C.char)(C.CString(heading))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_app_chooser_button_set_heading(arg0, arg1)
}

// SetModal sets whether the dialog should be modal.
func (s appChooserButton) SetModal(modal bool) {
	var arg0 *C.GtkAppChooserButton
	var arg1 C.gboolean

	arg0 = (*C.GtkAppChooserButton)(unsafe.Pointer(s.Native()))
	if modal {
		arg1 = C.gboolean(1)
	}

	C.gtk_app_chooser_button_set_modal(arg0, arg1)
}

// SetShowDefaultItem sets whether the dropdown menu of this button should
// show the default application for the given content type at top.
func (s appChooserButton) SetShowDefaultItem(setting bool) {
	var arg0 *C.GtkAppChooserButton
	var arg1 C.gboolean

	arg0 = (*C.GtkAppChooserButton)(unsafe.Pointer(s.Native()))
	if setting {
		arg1 = C.gboolean(1)
	}

	C.gtk_app_chooser_button_set_show_default_item(arg0, arg1)
}

// SetShowDialogItem sets whether the dropdown menu of this button should
// show an entry to trigger a AppChooserDialog.
func (s appChooserButton) SetShowDialogItem(setting bool) {
	var arg0 *C.GtkAppChooserButton
	var arg1 C.gboolean

	arg0 = (*C.GtkAppChooserButton)(unsafe.Pointer(s.Native()))
	if setting {
		arg1 = C.gboolean(1)
	}

	C.gtk_app_chooser_button_set_show_dialog_item(arg0, arg1)
}

// AppChooserDialog shows a AppChooserWidget inside a Dialog.
//
// Note that AppChooserDialog does not have any interesting methods of its own.
// Instead, you should get the embedded AppChooserWidget using
// gtk_app_chooser_dialog_get_widget() and call its methods if the generic
// AppChooser interface is not sufficient for your needs.
//
// To set the heading that is shown above the AppChooserWidget, use
// gtk_app_chooser_dialog_set_heading().
type AppChooserDialog interface {
	Dialog
	Accessible
	AppChooser
	Buildable
	ConstraintTarget
	Native
	Root
	ShortcutManager

	// Heading returns the text to display at the top of the dialog.
	Heading() string
	// Widget returns the AppChooserWidget of this dialog.
	Widget() Widget
	// SetHeading sets the text to display at the top of the dialog. If the
	// heading is not set, the dialog displays a default text.
	SetHeading(heading string)
}

// appChooserDialog implements the AppChooserDialog interface.
type appChooserDialog struct {
	Dialog
	Accessible
	AppChooser
	Buildable
	ConstraintTarget
	Native
	Root
	ShortcutManager
}

var _ AppChooserDialog = (*appChooserDialog)(nil)

// WrapAppChooserDialog wraps a GObject to the right type. It is
// primarily used internally.
func WrapAppChooserDialog(obj *externglib.Object) AppChooserDialog {
	return AppChooserDialog{
		Dialog:           WrapDialog(obj),
		Accessible:       WrapAccessible(obj),
		AppChooser:       WrapAppChooser(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
		Native:           WrapNative(obj),
		Root:             WrapRoot(obj),
		ShortcutManager:  WrapShortcutManager(obj),
	}
}

func marshalAppChooserDialog(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapAppChooserDialog(obj), nil
}

// NewAppChooserDialog constructs a class AppChooserDialog.
func NewAppChooserDialog(parent Window, flags DialogFlags, file gio.File) AppChooserDialog {
	var arg1 *C.GtkWindow
	var arg2 C.GtkDialogFlags
	var arg3 *C.GFile

	arg1 = (*C.GtkWindow)(unsafe.Pointer(parent.Native()))
	arg2 = (C.GtkDialogFlags)(flags)
	arg3 = (*C.GFile)(unsafe.Pointer(file.Native()))

	var cret C.GtkAppChooserDialog

	cret = C.gtk_app_chooser_dialog_new(arg1, arg2, arg3)

	var appChooserDialog AppChooserDialog

	appChooserDialog = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(AppChooserDialog)

	return appChooserDialog
}

// NewAppChooserDialogForContentType constructs a class AppChooserDialog.
func NewAppChooserDialogForContentType(parent Window, flags DialogFlags, contentType string) AppChooserDialog {
	var arg1 *C.GtkWindow
	var arg2 C.GtkDialogFlags
	var arg3 *C.char

	arg1 = (*C.GtkWindow)(unsafe.Pointer(parent.Native()))
	arg2 = (C.GtkDialogFlags)(flags)
	arg3 = (*C.char)(C.CString(contentType))
	defer C.free(unsafe.Pointer(arg3))

	var cret C.GtkAppChooserDialog

	cret = C.gtk_app_chooser_dialog_new_for_content_type(arg1, arg2, arg3)

	var appChooserDialog AppChooserDialog

	appChooserDialog = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(AppChooserDialog)

	return appChooserDialog
}

// Heading returns the text to display at the top of the dialog.
func (s appChooserDialog) Heading() string {
	var arg0 *C.GtkAppChooserDialog

	arg0 = (*C.GtkAppChooserDialog)(unsafe.Pointer(s.Native()))

	var cret *C.char

	cret = C.gtk_app_chooser_dialog_get_heading(arg0)

	var utf8 string

	utf8 = C.GoString(cret)

	return utf8
}

// Widget returns the AppChooserWidget of this dialog.
func (s appChooserDialog) Widget() Widget {
	var arg0 *C.GtkAppChooserDialog

	arg0 = (*C.GtkAppChooserDialog)(unsafe.Pointer(s.Native()))

	var cret *C.GtkWidget

	cret = C.gtk_app_chooser_dialog_get_widget(arg0)

	var widget Widget

	widget = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Widget)

	return widget
}

// SetHeading sets the text to display at the top of the dialog. If the
// heading is not set, the dialog displays a default text.
func (s appChooserDialog) SetHeading(heading string) {
	var arg0 *C.GtkAppChooserDialog
	var arg1 *C.char

	arg0 = (*C.GtkAppChooserDialog)(unsafe.Pointer(s.Native()))
	arg1 = (*C.char)(C.CString(heading))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_app_chooser_dialog_set_heading(arg0, arg1)
}

// AppChooserWidget is a widget for selecting applications. It is the main
// building block for AppChooserDialog. Most applications only need to use the
// latter; but you can use this widget as part of a larger widget if you have
// special needs.
//
// AppChooserWidget offers detailed control over what applications are shown,
// using the AppChooserWidget:show-default, AppChooserWidget:show-recommended,
// AppChooserWidget:show-fallback, AppChooserWidget:show-other and
// AppChooserWidget:show-all properties. See the AppChooser documentation for
// more information about these groups of applications.
//
// To keep track of the selected application, use the
// AppChooserWidget::application-selected and
// AppChooserWidget::application-activated signals.
//
//
// CSS nodes
//
// GtkAppChooserWidget has a single CSS node with name appchooser.
type AppChooserWidget interface {
	Widget
	Accessible
	AppChooser
	Buildable
	ConstraintTarget

	// DefaultText returns the text that is shown if there are not applications
	// that can handle the content type.
	DefaultText() string
	// ShowAll returns the current value of the AppChooserWidget:show-all
	// property.
	ShowAll() bool
	// ShowDefault returns the current value of the
	// AppChooserWidget:show-default property.
	ShowDefault() bool
	// ShowFallback returns the current value of the
	// AppChooserWidget:show-fallback property.
	ShowFallback() bool
	// ShowOther returns the current value of the AppChooserWidget:show-other
	// property.
	ShowOther() bool
	// ShowRecommended returns the current value of the
	// AppChooserWidget:show-recommended property.
	ShowRecommended() bool
	// SetDefaultText sets the text that is shown if there are not applications
	// that can handle the content type.
	SetDefaultText(text string)
	// SetShowAll sets whether the app chooser should show all applications in a
	// flat list.
	SetShowAll(setting bool)
	// SetShowDefault sets whether the app chooser should show the default
	// handler for the content type in a separate section.
	SetShowDefault(setting bool)
	// SetShowFallback sets whether the app chooser should show related
	// applications for the content type in a separate section.
	SetShowFallback(setting bool)
	// SetShowOther sets whether the app chooser should show applications which
	// are unrelated to the content type.
	SetShowOther(setting bool)
	// SetShowRecommended sets whether the app chooser should show recommended
	// applications for the content type in a separate section.
	SetShowRecommended(setting bool)
}

// appChooserWidget implements the AppChooserWidget interface.
type appChooserWidget struct {
	Widget
	Accessible
	AppChooser
	Buildable
	ConstraintTarget
}

var _ AppChooserWidget = (*appChooserWidget)(nil)

// WrapAppChooserWidget wraps a GObject to the right type. It is
// primarily used internally.
func WrapAppChooserWidget(obj *externglib.Object) AppChooserWidget {
	return AppChooserWidget{
		Widget:           WrapWidget(obj),
		Accessible:       WrapAccessible(obj),
		AppChooser:       WrapAppChooser(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
	}
}

func marshalAppChooserWidget(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapAppChooserWidget(obj), nil
}

// NewAppChooserWidget constructs a class AppChooserWidget.
func NewAppChooserWidget(contentType string) AppChooserWidget {
	var arg1 *C.char

	arg1 = (*C.char)(C.CString(contentType))
	defer C.free(unsafe.Pointer(arg1))

	var cret C.GtkAppChooserWidget

	cret = C.gtk_app_chooser_widget_new(arg1)

	var appChooserWidget AppChooserWidget

	appChooserWidget = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(AppChooserWidget)

	return appChooserWidget
}

// DefaultText returns the text that is shown if there are not applications
// that can handle the content type.
func (s appChooserWidget) DefaultText() string {
	var arg0 *C.GtkAppChooserWidget

	arg0 = (*C.GtkAppChooserWidget)(unsafe.Pointer(s.Native()))

	var cret *C.char

	cret = C.gtk_app_chooser_widget_get_default_text(arg0)

	var utf8 string

	utf8 = C.GoString(cret)

	return utf8
}

// ShowAll returns the current value of the AppChooserWidget:show-all
// property.
func (s appChooserWidget) ShowAll() bool {
	var arg0 *C.GtkAppChooserWidget

	arg0 = (*C.GtkAppChooserWidget)(unsafe.Pointer(s.Native()))

	var cret C.gboolean

	cret = C.gtk_app_chooser_widget_get_show_all(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// ShowDefault returns the current value of the
// AppChooserWidget:show-default property.
func (s appChooserWidget) ShowDefault() bool {
	var arg0 *C.GtkAppChooserWidget

	arg0 = (*C.GtkAppChooserWidget)(unsafe.Pointer(s.Native()))

	var cret C.gboolean

	cret = C.gtk_app_chooser_widget_get_show_default(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// ShowFallback returns the current value of the
// AppChooserWidget:show-fallback property.
func (s appChooserWidget) ShowFallback() bool {
	var arg0 *C.GtkAppChooserWidget

	arg0 = (*C.GtkAppChooserWidget)(unsafe.Pointer(s.Native()))

	var cret C.gboolean

	cret = C.gtk_app_chooser_widget_get_show_fallback(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// ShowOther returns the current value of the AppChooserWidget:show-other
// property.
func (s appChooserWidget) ShowOther() bool {
	var arg0 *C.GtkAppChooserWidget

	arg0 = (*C.GtkAppChooserWidget)(unsafe.Pointer(s.Native()))

	var cret C.gboolean

	cret = C.gtk_app_chooser_widget_get_show_other(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// ShowRecommended returns the current value of the
// AppChooserWidget:show-recommended property.
func (s appChooserWidget) ShowRecommended() bool {
	var arg0 *C.GtkAppChooserWidget

	arg0 = (*C.GtkAppChooserWidget)(unsafe.Pointer(s.Native()))

	var cret C.gboolean

	cret = C.gtk_app_chooser_widget_get_show_recommended(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// SetDefaultText sets the text that is shown if there are not applications
// that can handle the content type.
func (s appChooserWidget) SetDefaultText(text string) {
	var arg0 *C.GtkAppChooserWidget
	var arg1 *C.char

	arg0 = (*C.GtkAppChooserWidget)(unsafe.Pointer(s.Native()))
	arg1 = (*C.char)(C.CString(text))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_app_chooser_widget_set_default_text(arg0, arg1)
}

// SetShowAll sets whether the app chooser should show all applications in a
// flat list.
func (s appChooserWidget) SetShowAll(setting bool) {
	var arg0 *C.GtkAppChooserWidget
	var arg1 C.gboolean

	arg0 = (*C.GtkAppChooserWidget)(unsafe.Pointer(s.Native()))
	if setting {
		arg1 = C.gboolean(1)
	}

	C.gtk_app_chooser_widget_set_show_all(arg0, arg1)
}

// SetShowDefault sets whether the app chooser should show the default
// handler for the content type in a separate section.
func (s appChooserWidget) SetShowDefault(setting bool) {
	var arg0 *C.GtkAppChooserWidget
	var arg1 C.gboolean

	arg0 = (*C.GtkAppChooserWidget)(unsafe.Pointer(s.Native()))
	if setting {
		arg1 = C.gboolean(1)
	}

	C.gtk_app_chooser_widget_set_show_default(arg0, arg1)
}

// SetShowFallback sets whether the app chooser should show related
// applications for the content type in a separate section.
func (s appChooserWidget) SetShowFallback(setting bool) {
	var arg0 *C.GtkAppChooserWidget
	var arg1 C.gboolean

	arg0 = (*C.GtkAppChooserWidget)(unsafe.Pointer(s.Native()))
	if setting {
		arg1 = C.gboolean(1)
	}

	C.gtk_app_chooser_widget_set_show_fallback(arg0, arg1)
}

// SetShowOther sets whether the app chooser should show applications which
// are unrelated to the content type.
func (s appChooserWidget) SetShowOther(setting bool) {
	var arg0 *C.GtkAppChooserWidget
	var arg1 C.gboolean

	arg0 = (*C.GtkAppChooserWidget)(unsafe.Pointer(s.Native()))
	if setting {
		arg1 = C.gboolean(1)
	}

	C.gtk_app_chooser_widget_set_show_other(arg0, arg1)
}

// SetShowRecommended sets whether the app chooser should show recommended
// applications for the content type in a separate section.
func (s appChooserWidget) SetShowRecommended(setting bool) {
	var arg0 *C.GtkAppChooserWidget
	var arg1 C.gboolean

	arg0 = (*C.GtkAppChooserWidget)(unsafe.Pointer(s.Native()))
	if setting {
		arg1 = C.gboolean(1)
	}

	C.gtk_app_chooser_widget_set_show_recommended(arg0, arg1)
}

// AspectFrame: gtkAspectFrame is useful when you want pack a widget so that it
// can resize while retaining the same aspect ratio. For instance, one might be
// drawing a small preview of a larger image.
//
// The frame can respect the aspect ratio of the child widget, or use its own
// aspect ratio.
//
//
// CSS nodes
//
// GtkAspectFrame uses a CSS node with name `frame`.
type AspectFrame interface {
	Widget
	Accessible
	Buildable
	ConstraintTarget

	// Child gets the child widget of @self.
	Child() Widget
	// ObeyChild returns whether the child's size request should override the
	// set aspect ratio of the AspectFrame.
	ObeyChild() bool
	// Ratio returns the desired aspect ratio of the child set using
	// gtk_aspect_frame_set_ratio().
	Ratio() float32
	// Xalign returns the horizontal alignment of the child within the
	// allocation of the AspectFrame.
	Xalign() float32
	// Yalign returns the vertical alignment of the child within the allocation
	// of the AspectFrame.
	Yalign() float32
	// SetChild sets the child widget of @self.
	SetChild(child Widget)
	// SetObeyChild sets whether the aspect ratio of the child's size request
	// should override the set aspect ratio of the AspectFrame.
	SetObeyChild(obeyChild bool)
	// SetRatio sets the desired aspect ratio of the child.
	SetRatio(ratio float32)
	// SetXalign sets the horizontal alignment of the child within the
	// allocation of the AspectFrame.
	SetXalign(xalign float32)
	// SetYalign sets the vertical alignment of the child within the allocation
	// of the AspectFrame.
	SetYalign(yalign float32)
}

// aspectFrame implements the AspectFrame interface.
type aspectFrame struct {
	Widget
	Accessible
	Buildable
	ConstraintTarget
}

var _ AspectFrame = (*aspectFrame)(nil)

// WrapAspectFrame wraps a GObject to the right type. It is
// primarily used internally.
func WrapAspectFrame(obj *externglib.Object) AspectFrame {
	return AspectFrame{
		Widget:           WrapWidget(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
	}
}

func marshalAspectFrame(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapAspectFrame(obj), nil
}

// NewAspectFrame constructs a class AspectFrame.
func NewAspectFrame(xalign float32, yalign float32, ratio float32, obeyChild bool) AspectFrame {
	var arg1 C.float
	var arg2 C.float
	var arg3 C.float
	var arg4 C.gboolean

	arg1 = C.float(xalign)
	arg2 = C.float(yalign)
	arg3 = C.float(ratio)
	if obeyChild {
		arg4 = C.gboolean(1)
	}

	var cret C.GtkAspectFrame

	cret = C.gtk_aspect_frame_new(arg1, arg2, arg3, arg4)

	var aspectFrame AspectFrame

	aspectFrame = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(AspectFrame)

	return aspectFrame
}

// Child gets the child widget of @self.
func (s aspectFrame) Child() Widget {
	var arg0 *C.GtkAspectFrame

	arg0 = (*C.GtkAspectFrame)(unsafe.Pointer(s.Native()))

	var cret *C.GtkWidget

	cret = C.gtk_aspect_frame_get_child(arg0)

	var widget Widget

	widget = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Widget)

	return widget
}

// ObeyChild returns whether the child's size request should override the
// set aspect ratio of the AspectFrame.
func (s aspectFrame) ObeyChild() bool {
	var arg0 *C.GtkAspectFrame

	arg0 = (*C.GtkAspectFrame)(unsafe.Pointer(s.Native()))

	var cret C.gboolean

	cret = C.gtk_aspect_frame_get_obey_child(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// Ratio returns the desired aspect ratio of the child set using
// gtk_aspect_frame_set_ratio().
func (s aspectFrame) Ratio() float32 {
	var arg0 *C.GtkAspectFrame

	arg0 = (*C.GtkAspectFrame)(unsafe.Pointer(s.Native()))

	var cret C.float

	cret = C.gtk_aspect_frame_get_ratio(arg0)

	var gfloat float32

	gfloat = (float32)(cret)

	return gfloat
}

// Xalign returns the horizontal alignment of the child within the
// allocation of the AspectFrame.
func (s aspectFrame) Xalign() float32 {
	var arg0 *C.GtkAspectFrame

	arg0 = (*C.GtkAspectFrame)(unsafe.Pointer(s.Native()))

	var cret C.float

	cret = C.gtk_aspect_frame_get_xalign(arg0)

	var gfloat float32

	gfloat = (float32)(cret)

	return gfloat
}

// Yalign returns the vertical alignment of the child within the allocation
// of the AspectFrame.
func (s aspectFrame) Yalign() float32 {
	var arg0 *C.GtkAspectFrame

	arg0 = (*C.GtkAspectFrame)(unsafe.Pointer(s.Native()))

	var cret C.float

	cret = C.gtk_aspect_frame_get_yalign(arg0)

	var gfloat float32

	gfloat = (float32)(cret)

	return gfloat
}

// SetChild sets the child widget of @self.
func (s aspectFrame) SetChild(child Widget) {
	var arg0 *C.GtkAspectFrame
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkAspectFrame)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_aspect_frame_set_child(arg0, arg1)
}

// SetObeyChild sets whether the aspect ratio of the child's size request
// should override the set aspect ratio of the AspectFrame.
func (s aspectFrame) SetObeyChild(obeyChild bool) {
	var arg0 *C.GtkAspectFrame
	var arg1 C.gboolean

	arg0 = (*C.GtkAspectFrame)(unsafe.Pointer(s.Native()))
	if obeyChild {
		arg1 = C.gboolean(1)
	}

	C.gtk_aspect_frame_set_obey_child(arg0, arg1)
}

// SetRatio sets the desired aspect ratio of the child.
func (s aspectFrame) SetRatio(ratio float32) {
	var arg0 *C.GtkAspectFrame
	var arg1 C.float

	arg0 = (*C.GtkAspectFrame)(unsafe.Pointer(s.Native()))
	arg1 = C.float(ratio)

	C.gtk_aspect_frame_set_ratio(arg0, arg1)
}

// SetXalign sets the horizontal alignment of the child within the
// allocation of the AspectFrame.
func (s aspectFrame) SetXalign(xalign float32) {
	var arg0 *C.GtkAspectFrame
	var arg1 C.float

	arg0 = (*C.GtkAspectFrame)(unsafe.Pointer(s.Native()))
	arg1 = C.float(xalign)

	C.gtk_aspect_frame_set_xalign(arg0, arg1)
}

// SetYalign sets the vertical alignment of the child within the allocation
// of the AspectFrame.
func (s aspectFrame) SetYalign(yalign float32) {
	var arg0 *C.GtkAspectFrame
	var arg1 C.float

	arg0 = (*C.GtkAspectFrame)(unsafe.Pointer(s.Native()))
	arg1 = C.float(yalign)

	C.gtk_aspect_frame_set_yalign(arg0, arg1)
}

// Assistant: a Assistant is a widget used to represent a generally complex
// operation split up into several steps. Each step consists of one or more
// pages. GtkAssistant guides the user through the pages, and controls the page
// flow to collect the data needed for the operation.
//
// GtkAssistant handles which buttons to show and to make sensitive based on
// page sequence knowledge and the [type][GtkAssistantPageType] of each page in
// addition to state information like the
// [completion][gtk-assistant-set-page-complete] and
// [committed][gtk-assistant-commit] page statuses.
//
// If you have a case that doesn’t quite fit in Assistants way of handling
// buttons, you can use the K_ASSISTANT_PAGE_CUSTOM page type and handle buttons
// yourself.
//
// GtkAssistant maintains a AssistantPage object for each added child, which
// holds additional per-child properties. You obtain the AssistantPage for a
// child with gtk_assistant_get_page().
//
//
// GtkAssistant as GtkBuildable
//
// The GtkAssistant implementation of the Buildable interface exposes the
// @action_area as internal children with the name “action_area”.
//
// To add pages to an assistant in Builder, simply add it as a child to the
// GtkAssistant object. If you need to set per-object properties, create a
// AssistantPage object explicitly, and set the child widget as a property on
// it.
//
//
// CSS nodes
//
// GtkAssistant has a single CSS node with the name window and style class
// .assistant.
type Assistant interface {
	Window
	Accessible
	Buildable
	ConstraintTarget
	Native
	Root
	ShortcutManager

	// AddActionWidget adds a widget to the action area of a Assistant.
	AddActionWidget(child Widget)
	// AppendPage appends a page to the @assistant.
	AppendPage(page Widget) int
	// Commit erases the visited page history so the back button is not shown on
	// the current page, and removes the cancel button from subsequent pages.
	//
	// Use this when the information provided up to the current page is
	// hereafter deemed permanent and cannot be modified or undone. For example,
	// showing a progress page to track a long-running, unreversible operation
	// after the user has clicked apply on a confirmation page.
	Commit()
	// CurrentPage returns the page number of the current page.
	CurrentPage() int
	// NPages returns the number of pages in the @assistant
	NPages() int
	// NthPage returns the child widget contained in page number @page_num.
	NthPage(pageNum int) Widget
	// Page returns the AssistantPage object for @child.
	Page(child Widget) AssistantPage
	// PageComplete gets whether @page is complete.
	PageComplete(page Widget) bool
	// PageTitle gets the title for @page.
	PageTitle(page Widget) string
	// PageType gets the page type of @page.
	PageType(page Widget) AssistantPageType
	// Pages gets a list model of the assistant pages.
	Pages() gio.ListModel
	// InsertPage inserts a page in the @assistant at a given position.
	InsertPage(page Widget, position int) int
	// NextPage: navigate to the next page.
	//
	// It is a programming error to call this function when there is no next
	// page.
	//
	// This function is for use when creating pages of the
	// K_ASSISTANT_PAGE_CUSTOM type.
	NextPage()
	// PrependPage prepends a page to the @assistant.
	PrependPage(page Widget) int
	// PreviousPage: navigate to the previous visited page.
	//
	// It is a programming error to call this function when no previous page is
	// available.
	//
	// This function is for use when creating pages of the
	// K_ASSISTANT_PAGE_CUSTOM type.
	PreviousPage()
	// RemoveActionWidget removes a widget from the action area of a Assistant.
	RemoveActionWidget(child Widget)
	// RemovePage removes the @page_num’s page from @assistant.
	RemovePage(pageNum int)
	// SetCurrentPage switches the page to @page_num.
	//
	// Note that this will only be necessary in custom buttons, as the
	// @assistant flow can be set with gtk_assistant_set_forward_page_func().
	SetCurrentPage(pageNum int)
	// SetForwardPageFunc sets the page forwarding function to be @page_func.
	//
	// This function will be used to determine what will be the next page when
	// the user presses the forward button. Setting @page_func to nil will make
	// the assistant to use the default forward function, which just goes to the
	// next visible page.
	SetForwardPageFunc()
	// SetPageComplete sets whether @page contents are complete.
	//
	// This will make @assistant update the buttons state to be able to continue
	// the task.
	SetPageComplete(page Widget, complete bool)
	// SetPageTitle sets a title for @page.
	//
	// The title is displayed in the header area of the assistant when @page is
	// the current page.
	SetPageTitle(page Widget, title string)
	// SetPageType sets the page type for @page.
	//
	// The page type determines the page behavior in the @assistant.
	SetPageType(page Widget, typ AssistantPageType)
	// UpdateButtonsState forces @assistant to recompute the buttons state.
	//
	// GTK automatically takes care of this in most situations, e.g. when the
	// user goes to a different page, or when the visibility or completeness of
	// a page changes.
	//
	// One situation where it can be necessary to call this function is when
	// changing a value on the current page affects the future page flow of the
	// assistant.
	UpdateButtonsState()
}

// assistant implements the Assistant interface.
type assistant struct {
	Window
	Accessible
	Buildable
	ConstraintTarget
	Native
	Root
	ShortcutManager
}

var _ Assistant = (*assistant)(nil)

// WrapAssistant wraps a GObject to the right type. It is
// primarily used internally.
func WrapAssistant(obj *externglib.Object) Assistant {
	return Assistant{
		Window:           WrapWindow(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
		Native:           WrapNative(obj),
		Root:             WrapRoot(obj),
		ShortcutManager:  WrapShortcutManager(obj),
	}
}

func marshalAssistant(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapAssistant(obj), nil
}

// NewAssistant constructs a class Assistant.
func NewAssistant() Assistant {
	var cret C.GtkAssistant

	cret = C.gtk_assistant_new()

	var assistant Assistant

	assistant = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Assistant)

	return assistant
}

// AddActionWidget adds a widget to the action area of a Assistant.
func (a assistant) AddActionWidget(child Widget) {
	var arg0 *C.GtkAssistant
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_assistant_add_action_widget(arg0, arg1)
}

// AppendPage appends a page to the @assistant.
func (a assistant) AppendPage(page Widget) int {
	var arg0 *C.GtkAssistant
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(page.Native()))

	var cret C.int

	cret = C.gtk_assistant_append_page(arg0, arg1)

	var gint int

	gint = (int)(cret)

	return gint
}

// Commit erases the visited page history so the back button is not shown on
// the current page, and removes the cancel button from subsequent pages.
//
// Use this when the information provided up to the current page is
// hereafter deemed permanent and cannot be modified or undone. For example,
// showing a progress page to track a long-running, unreversible operation
// after the user has clicked apply on a confirmation page.
func (a assistant) Commit() {
	var arg0 *C.GtkAssistant

	arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))

	C.gtk_assistant_commit(arg0)
}

// CurrentPage returns the page number of the current page.
func (a assistant) CurrentPage() int {
	var arg0 *C.GtkAssistant

	arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))

	var cret C.int

	cret = C.gtk_assistant_get_current_page(arg0)

	var gint int

	gint = (int)(cret)

	return gint
}

// NPages returns the number of pages in the @assistant
func (a assistant) NPages() int {
	var arg0 *C.GtkAssistant

	arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))

	var cret C.int

	cret = C.gtk_assistant_get_n_pages(arg0)

	var gint int

	gint = (int)(cret)

	return gint
}

// NthPage returns the child widget contained in page number @page_num.
func (a assistant) NthPage(pageNum int) Widget {
	var arg0 *C.GtkAssistant
	var arg1 C.int

	arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
	arg1 = C.int(pageNum)

	var cret *C.GtkWidget

	cret = C.gtk_assistant_get_nth_page(arg0, arg1)

	var widget Widget

	widget = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Widget)

	return widget
}

// Page returns the AssistantPage object for @child.
func (a assistant) Page(child Widget) AssistantPage {
	var arg0 *C.GtkAssistant
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	var cret *C.GtkAssistantPage

	cret = C.gtk_assistant_get_page(arg0, arg1)

	var assistantPage AssistantPage

	assistantPage = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(AssistantPage)

	return assistantPage
}

// PageComplete gets whether @page is complete.
func (a assistant) PageComplete(page Widget) bool {
	var arg0 *C.GtkAssistant
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(page.Native()))

	var cret C.gboolean

	cret = C.gtk_assistant_get_page_complete(arg0, arg1)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// PageTitle gets the title for @page.
func (a assistant) PageTitle(page Widget) string {
	var arg0 *C.GtkAssistant
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(page.Native()))

	var cret *C.char

	cret = C.gtk_assistant_get_page_title(arg0, arg1)

	var utf8 string

	utf8 = C.GoString(cret)

	return utf8
}

// PageType gets the page type of @page.
func (a assistant) PageType(page Widget) AssistantPageType {
	var arg0 *C.GtkAssistant
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(page.Native()))

	var cret C.GtkAssistantPageType

	cret = C.gtk_assistant_get_page_type(arg0, arg1)

	var assistantPageType AssistantPageType

	assistantPageType = AssistantPageType(cret)

	return assistantPageType
}

// Pages gets a list model of the assistant pages.
func (a assistant) Pages() gio.ListModel {
	var arg0 *C.GtkAssistant

	arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))

	var cret *C.GListModel

	cret = C.gtk_assistant_get_pages(arg0)

	var listModel gio.ListModel

	listModel = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(gio.ListModel)

	return listModel
}

// InsertPage inserts a page in the @assistant at a given position.
func (a assistant) InsertPage(page Widget, position int) int {
	var arg0 *C.GtkAssistant
	var arg1 *C.GtkWidget
	var arg2 C.int

	arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(page.Native()))
	arg2 = C.int(position)

	var cret C.int

	cret = C.gtk_assistant_insert_page(arg0, arg1, arg2)

	var gint int

	gint = (int)(cret)

	return gint
}

// NextPage: navigate to the next page.
//
// It is a programming error to call this function when there is no next
// page.
//
// This function is for use when creating pages of the
// K_ASSISTANT_PAGE_CUSTOM type.
func (a assistant) NextPage() {
	var arg0 *C.GtkAssistant

	arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))

	C.gtk_assistant_next_page(arg0)
}

// PrependPage prepends a page to the @assistant.
func (a assistant) PrependPage(page Widget) int {
	var arg0 *C.GtkAssistant
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(page.Native()))

	var cret C.int

	cret = C.gtk_assistant_prepend_page(arg0, arg1)

	var gint int

	gint = (int)(cret)

	return gint
}

// PreviousPage: navigate to the previous visited page.
//
// It is a programming error to call this function when no previous page is
// available.
//
// This function is for use when creating pages of the
// K_ASSISTANT_PAGE_CUSTOM type.
func (a assistant) PreviousPage() {
	var arg0 *C.GtkAssistant

	arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))

	C.gtk_assistant_previous_page(arg0)
}

// RemoveActionWidget removes a widget from the action area of a Assistant.
func (a assistant) RemoveActionWidget(child Widget) {
	var arg0 *C.GtkAssistant
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_assistant_remove_action_widget(arg0, arg1)
}

// RemovePage removes the @page_num’s page from @assistant.
func (a assistant) RemovePage(pageNum int) {
	var arg0 *C.GtkAssistant
	var arg1 C.int

	arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
	arg1 = C.int(pageNum)

	C.gtk_assistant_remove_page(arg0, arg1)
}

// SetCurrentPage switches the page to @page_num.
//
// Note that this will only be necessary in custom buttons, as the
// @assistant flow can be set with gtk_assistant_set_forward_page_func().
func (a assistant) SetCurrentPage(pageNum int) {
	var arg0 *C.GtkAssistant
	var arg1 C.int

	arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
	arg1 = C.int(pageNum)

	C.gtk_assistant_set_current_page(arg0, arg1)
}

// SetForwardPageFunc sets the page forwarding function to be @page_func.
//
// This function will be used to determine what will be the next page when
// the user presses the forward button. Setting @page_func to nil will make
// the assistant to use the default forward function, which just goes to the
// next visible page.
func (a assistant) SetForwardPageFunc() {
	var arg0 *C.GtkAssistant

	arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))

	C.gtk_assistant_set_forward_page_func(arg0)
}

// SetPageComplete sets whether @page contents are complete.
//
// This will make @assistant update the buttons state to be able to continue
// the task.
func (a assistant) SetPageComplete(page Widget, complete bool) {
	var arg0 *C.GtkAssistant
	var arg1 *C.GtkWidget
	var arg2 C.gboolean

	arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(page.Native()))
	if complete {
		arg2 = C.gboolean(1)
	}

	C.gtk_assistant_set_page_complete(arg0, arg1, arg2)
}

// SetPageTitle sets a title for @page.
//
// The title is displayed in the header area of the assistant when @page is
// the current page.
func (a assistant) SetPageTitle(page Widget, title string) {
	var arg0 *C.GtkAssistant
	var arg1 *C.GtkWidget
	var arg2 *C.char

	arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(page.Native()))
	arg2 = (*C.char)(C.CString(title))
	defer C.free(unsafe.Pointer(arg2))

	C.gtk_assistant_set_page_title(arg0, arg1, arg2)
}

// SetPageType sets the page type for @page.
//
// The page type determines the page behavior in the @assistant.
func (a assistant) SetPageType(page Widget, typ AssistantPageType) {
	var arg0 *C.GtkAssistant
	var arg1 *C.GtkWidget
	var arg2 C.GtkAssistantPageType

	arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(page.Native()))
	arg2 = (C.GtkAssistantPageType)(typ)

	C.gtk_assistant_set_page_type(arg0, arg1, arg2)
}

// UpdateButtonsState forces @assistant to recompute the buttons state.
//
// GTK automatically takes care of this in most situations, e.g. when the
// user goes to a different page, or when the visibility or completeness of
// a page changes.
//
// One situation where it can be necessary to call this function is when
// changing a value on the current page affects the future page flow of the
// assistant.
func (a assistant) UpdateButtonsState() {
	var arg0 *C.GtkAssistant

	arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))

	C.gtk_assistant_update_buttons_state(arg0)
}

type AssistantPage interface {
	gextras.Objector

	// Child returns the child to which @page belongs.
	Child() Widget
}

// assistantPage implements the AssistantPage interface.
type assistantPage struct {
	gextras.Objector
}

var _ AssistantPage = (*assistantPage)(nil)

// WrapAssistantPage wraps a GObject to the right type. It is
// primarily used internally.
func WrapAssistantPage(obj *externglib.Object) AssistantPage {
	return AssistantPage{
		Objector: obj,
	}
}

func marshalAssistantPage(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapAssistantPage(obj), nil
}

// Child returns the child to which @page belongs.
func (p assistantPage) Child() Widget {
	var arg0 *C.GtkAssistantPage

	arg0 = (*C.GtkAssistantPage)(unsafe.Pointer(p.Native()))

	var cret *C.GtkWidget

	cret = C.gtk_assistant_page_get_child(arg0)

	var widget Widget

	widget = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Widget)

	return widget
}

// Calendar is a widget that displays a Gregorian calendar, one month at a time.
// It can be created with gtk_calendar_new().
//
// The date that is currently displayed can be altered with
// gtk_calendar_select_day().
//
// To place a visual marker on a particular day, use gtk_calendar_mark_day() and
// to remove the marker, gtk_calendar_unmark_day(). Alternative, all marks can
// be cleared with gtk_calendar_clear_marks().
//
// The selected date can be retrieved from a Calendar using
// gtk_calendar_get_date().
//
// Users should be aware that, although the Gregorian calendar is the legal
// calendar in most countries, it was adopted progressively between 1582 and
// 1929. Display before these dates is likely to be historically incorrect.
//
// CSS nodes
//
//    calendar.view
//    ├── header
//    │   ├── button
//    │   ├── stack.month
//    │   ├── button
//    │   ├── button
//    │   ├── label.year
//    │   ╰── button
//    ╰── grid
//        ╰── label[.day-name][.week-number][.day-number][.other-month][.today]
//
// GtkCalendar has a main node with name calendar. It contains a subnode called
// header containing the widgets for switching between years and months.
//
// The grid subnode contains all day labels, including week numbers on the left
// (marked with the .week-number css class) and day names on top (marked with
// the .day-name css class).
//
// Day labels that belong to the previous or next month get the .other-month
// style class. The label of the current day get the .today style class.
//
// Marked day labels get the :selected state assigned.
type Calendar interface {
	Widget
	Accessible
	Buildable
	ConstraintTarget

	// ClearMarks: remove all visual markers.
	ClearMarks()
	// Date returns a Time representing the shown year, month and the selected
	// day, in the local time zone.
	Date() *glib.DateTime
	// DayIsMarked returns if the @day of the @calendar is already marked.
	DayIsMarked(day uint) bool
	// ShowDayNames returns whether @self is currently showing the names of the
	// week days above the day numbers, i.e. the value of the
	// Calendar:show-day-names property.
	ShowDayNames() bool
	// ShowHeading returns whether @self is currently showing the heading, i.e.
	// the value of the Calendar:show-heading property.
	ShowHeading() bool
	// ShowWeekNumbers returns whether @self is showing week numbers right now,
	// i.e. the value of the Calendar:show-week-numbers property.
	ShowWeekNumbers() bool
	// MarkDay places a visual marker on a particular day.
	MarkDay(day uint)
	// SelectDay: will switch to @date's year and month and select its day.
	SelectDay(date *glib.DateTime)
	// SetShowDayNames sets whether the calendar shows day names.
	SetShowDayNames(value bool)
	// SetShowHeading sets whether the calendar should show a heading containing
	// the current year and month as well as buttons for changing both.
	SetShowHeading(value bool)
	// SetShowWeekNumbers sets whether week numbers are shown in the calendar.
	SetShowWeekNumbers(value bool)
	// UnmarkDay removes the visual marker from a particular day.
	UnmarkDay(day uint)
}

// calendar implements the Calendar interface.
type calendar struct {
	Widget
	Accessible
	Buildable
	ConstraintTarget
}

var _ Calendar = (*calendar)(nil)

// WrapCalendar wraps a GObject to the right type. It is
// primarily used internally.
func WrapCalendar(obj *externglib.Object) Calendar {
	return Calendar{
		Widget:           WrapWidget(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
	}
}

func marshalCalendar(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCalendar(obj), nil
}

// NewCalendar constructs a class Calendar.
func NewCalendar() Calendar {
	var cret C.GtkCalendar

	cret = C.gtk_calendar_new()

	var calendar Calendar

	calendar = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Calendar)

	return calendar
}

// ClearMarks: remove all visual markers.
func (c calendar) ClearMarks() {
	var arg0 *C.GtkCalendar

	arg0 = (*C.GtkCalendar)(unsafe.Pointer(c.Native()))

	C.gtk_calendar_clear_marks(arg0)
}

// Date returns a Time representing the shown year, month and the selected
// day, in the local time zone.
func (s calendar) Date() *glib.DateTime {
	var arg0 *C.GtkCalendar

	arg0 = (*C.GtkCalendar)(unsafe.Pointer(s.Native()))

	var cret *C.GDateTime

	cret = C.gtk_calendar_get_date(arg0)

	var dateTime *glib.DateTime

	dateTime = glib.WrapDateTime(unsafe.Pointer(cret))
	runtime.SetFinalizer(dateTime, func(v *glib.DateTime) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return dateTime
}

// DayIsMarked returns if the @day of the @calendar is already marked.
func (c calendar) DayIsMarked(day uint) bool {
	var arg0 *C.GtkCalendar
	var arg1 C.guint

	arg0 = (*C.GtkCalendar)(unsafe.Pointer(c.Native()))
	arg1 = C.guint(day)

	var cret C.gboolean

	cret = C.gtk_calendar_get_day_is_marked(arg0, arg1)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// ShowDayNames returns whether @self is currently showing the names of the
// week days above the day numbers, i.e. the value of the
// Calendar:show-day-names property.
func (s calendar) ShowDayNames() bool {
	var arg0 *C.GtkCalendar

	arg0 = (*C.GtkCalendar)(unsafe.Pointer(s.Native()))

	var cret C.gboolean

	cret = C.gtk_calendar_get_show_day_names(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// ShowHeading returns whether @self is currently showing the heading, i.e.
// the value of the Calendar:show-heading property.
func (s calendar) ShowHeading() bool {
	var arg0 *C.GtkCalendar

	arg0 = (*C.GtkCalendar)(unsafe.Pointer(s.Native()))

	var cret C.gboolean

	cret = C.gtk_calendar_get_show_heading(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// ShowWeekNumbers returns whether @self is showing week numbers right now,
// i.e. the value of the Calendar:show-week-numbers property.
func (s calendar) ShowWeekNumbers() bool {
	var arg0 *C.GtkCalendar

	arg0 = (*C.GtkCalendar)(unsafe.Pointer(s.Native()))

	var cret C.gboolean

	cret = C.gtk_calendar_get_show_week_numbers(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// MarkDay places a visual marker on a particular day.
func (c calendar) MarkDay(day uint) {
	var arg0 *C.GtkCalendar
	var arg1 C.guint

	arg0 = (*C.GtkCalendar)(unsafe.Pointer(c.Native()))
	arg1 = C.guint(day)

	C.gtk_calendar_mark_day(arg0, arg1)
}

// SelectDay: will switch to @date's year and month and select its day.
func (s calendar) SelectDay(date *glib.DateTime) {
	var arg0 *C.GtkCalendar
	var arg1 *C.GDateTime

	arg0 = (*C.GtkCalendar)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GDateTime)(unsafe.Pointer(date.Native()))

	C.gtk_calendar_select_day(arg0, arg1)
}

// SetShowDayNames sets whether the calendar shows day names.
func (s calendar) SetShowDayNames(value bool) {
	var arg0 *C.GtkCalendar
	var arg1 C.gboolean

	arg0 = (*C.GtkCalendar)(unsafe.Pointer(s.Native()))
	if value {
		arg1 = C.gboolean(1)
	}

	C.gtk_calendar_set_show_day_names(arg0, arg1)
}

// SetShowHeading sets whether the calendar should show a heading containing
// the current year and month as well as buttons for changing both.
func (s calendar) SetShowHeading(value bool) {
	var arg0 *C.GtkCalendar
	var arg1 C.gboolean

	arg0 = (*C.GtkCalendar)(unsafe.Pointer(s.Native()))
	if value {
		arg1 = C.gboolean(1)
	}

	C.gtk_calendar_set_show_heading(arg0, arg1)
}

// SetShowWeekNumbers sets whether week numbers are shown in the calendar.
func (s calendar) SetShowWeekNumbers(value bool) {
	var arg0 *C.GtkCalendar
	var arg1 C.gboolean

	arg0 = (*C.GtkCalendar)(unsafe.Pointer(s.Native()))
	if value {
		arg1 = C.gboolean(1)
	}

	C.gtk_calendar_set_show_week_numbers(arg0, arg1)
}

// UnmarkDay removes the visual marker from a particular day.
func (c calendar) UnmarkDay(day uint) {
	var arg0 *C.GtkCalendar
	var arg1 C.guint

	arg0 = (*C.GtkCalendar)(unsafe.Pointer(c.Native()))
	arg1 = C.guint(day)

	C.gtk_calendar_unmark_day(arg0, arg1)
}

// CellAreaBox: the CellAreaBox renders cell renderers into a row or a column
// depending on its Orientation.
//
// GtkCellAreaBox uses a notion of packing. Packing refers to adding cell
// renderers with reference to a particular position in a CellAreaBox. There are
// two reference positions: the start and the end of the box. When the
// CellAreaBox is oriented in the GTK_ORIENTATION_VERTICAL orientation, the
// start is defined as the top of the box and the end is defined as the bottom.
// In the GTK_ORIENTATION_HORIZONTAL orientation start is defined as the left
// side and the end is defined as the right side.
//
// Alignments of CellRenderers rendered in adjacent rows can be configured by
// configuring the CellAreaBox align child cell property with
// gtk_cell_area_cell_set_property() or by specifying the "align" argument to
// gtk_cell_area_box_pack_start() and gtk_cell_area_box_pack_end().
type CellAreaBox interface {
	CellArea
	Buildable
	CellLayout
	Orientable

	// Spacing gets the spacing added between cell renderers.
	Spacing() int
	// PackEnd adds @renderer to @box, packed with reference to the end of @box.
	//
	// The @renderer is packed after (away from end of) any other CellRenderer
	// packed with reference to the end of @box.
	PackEnd(renderer CellRenderer, expand bool, align bool, fixed bool)
	// PackStart adds @renderer to @box, packed with reference to the start of
	// @box.
	//
	// The @renderer is packed after any other CellRenderer packed with
	// reference to the start of @box.
	PackStart(renderer CellRenderer, expand bool, align bool, fixed bool)
	// SetSpacing sets the spacing to add between cell renderers in @box.
	SetSpacing(spacing int)
}

// cellAreaBox implements the CellAreaBox interface.
type cellAreaBox struct {
	CellArea
	Buildable
	CellLayout
	Orientable
}

var _ CellAreaBox = (*cellAreaBox)(nil)

// WrapCellAreaBox wraps a GObject to the right type. It is
// primarily used internally.
func WrapCellAreaBox(obj *externglib.Object) CellAreaBox {
	return CellAreaBox{
		CellArea:   WrapCellArea(obj),
		Buildable:  WrapBuildable(obj),
		CellLayout: WrapCellLayout(obj),
		Orientable: WrapOrientable(obj),
	}
}

func marshalCellAreaBox(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCellAreaBox(obj), nil
}

// NewCellAreaBox constructs a class CellAreaBox.
func NewCellAreaBox() CellAreaBox {
	var cret C.GtkCellAreaBox

	cret = C.gtk_cell_area_box_new()

	var cellAreaBox CellAreaBox

	cellAreaBox = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(CellAreaBox)

	return cellAreaBox
}

// Spacing gets the spacing added between cell renderers.
func (b cellAreaBox) Spacing() int {
	var arg0 *C.GtkCellAreaBox

	arg0 = (*C.GtkCellAreaBox)(unsafe.Pointer(b.Native()))

	var cret C.int

	cret = C.gtk_cell_area_box_get_spacing(arg0)

	var gint int

	gint = (int)(cret)

	return gint
}

// PackEnd adds @renderer to @box, packed with reference to the end of @box.
//
// The @renderer is packed after (away from end of) any other CellRenderer
// packed with reference to the end of @box.
func (b cellAreaBox) PackEnd(renderer CellRenderer, expand bool, align bool, fixed bool) {
	var arg0 *C.GtkCellAreaBox
	var arg1 *C.GtkCellRenderer
	var arg2 C.gboolean
	var arg3 C.gboolean
	var arg4 C.gboolean

	arg0 = (*C.GtkCellAreaBox)(unsafe.Pointer(b.Native()))
	arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))
	if expand {
		arg2 = C.gboolean(1)
	}
	if align {
		arg3 = C.gboolean(1)
	}
	if fixed {
		arg4 = C.gboolean(1)
	}

	C.gtk_cell_area_box_pack_end(arg0, arg1, arg2, arg3, arg4)
}

// PackStart adds @renderer to @box, packed with reference to the start of
// @box.
//
// The @renderer is packed after any other CellRenderer packed with
// reference to the start of @box.
func (b cellAreaBox) PackStart(renderer CellRenderer, expand bool, align bool, fixed bool) {
	var arg0 *C.GtkCellAreaBox
	var arg1 *C.GtkCellRenderer
	var arg2 C.gboolean
	var arg3 C.gboolean
	var arg4 C.gboolean

	arg0 = (*C.GtkCellAreaBox)(unsafe.Pointer(b.Native()))
	arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))
	if expand {
		arg2 = C.gboolean(1)
	}
	if align {
		arg3 = C.gboolean(1)
	}
	if fixed {
		arg4 = C.gboolean(1)
	}

	C.gtk_cell_area_box_pack_start(arg0, arg1, arg2, arg3, arg4)
}

// SetSpacing sets the spacing to add between cell renderers in @box.
func (b cellAreaBox) SetSpacing(spacing int) {
	var arg0 *C.GtkCellAreaBox
	var arg1 C.int

	arg0 = (*C.GtkCellAreaBox)(unsafe.Pointer(b.Native()))
	arg1 = C.int(spacing)

	C.gtk_cell_area_box_set_spacing(arg0, arg1)
}

// CellRendererAccel displays a keyboard accelerator (i.e. a key combination
// like `Control + a`). If the cell renderer is editable, the accelerator can be
// changed by simply typing the new combination.
type CellRendererAccel interface {
	CellRendererText
}

// cellRendererAccel implements the CellRendererAccel interface.
type cellRendererAccel struct {
	CellRendererText
}

var _ CellRendererAccel = (*cellRendererAccel)(nil)

// WrapCellRendererAccel wraps a GObject to the right type. It is
// primarily used internally.
func WrapCellRendererAccel(obj *externglib.Object) CellRendererAccel {
	return CellRendererAccel{
		CellRendererText: WrapCellRendererText(obj),
	}
}

func marshalCellRendererAccel(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCellRendererAccel(obj), nil
}

// NewCellRendererAccel constructs a class CellRendererAccel.
func NewCellRendererAccel() CellRendererAccel {
	var cret C.GtkCellRendererAccel

	cret = C.gtk_cell_renderer_accel_new()

	var cellRendererAccel CellRendererAccel

	cellRendererAccel = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(CellRendererAccel)

	return cellRendererAccel
}

// CellRendererCombo renders text in a cell like CellRendererText from which it
// is derived. But while CellRendererText offers a simple entry to edit the
// text, CellRendererCombo offers a ComboBox widget to edit the text. The values
// to display in the combo box are taken from the tree model specified in the
// CellRendererCombo:model property.
//
// The combo cell renderer takes care of adding a text cell renderer to the
// combo box and sets it to display the column specified by its
// CellRendererCombo:text-column property. Further properties of the combo box
// can be set in a handler for the CellRenderer::editing-started signal.
type CellRendererCombo interface {
	CellRendererText
}

// cellRendererCombo implements the CellRendererCombo interface.
type cellRendererCombo struct {
	CellRendererText
}

var _ CellRendererCombo = (*cellRendererCombo)(nil)

// WrapCellRendererCombo wraps a GObject to the right type. It is
// primarily used internally.
func WrapCellRendererCombo(obj *externglib.Object) CellRendererCombo {
	return CellRendererCombo{
		CellRendererText: WrapCellRendererText(obj),
	}
}

func marshalCellRendererCombo(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCellRendererCombo(obj), nil
}

// NewCellRendererCombo constructs a class CellRendererCombo.
func NewCellRendererCombo() CellRendererCombo {
	var cret C.GtkCellRendererCombo

	cret = C.gtk_cell_renderer_combo_new()

	var cellRendererCombo CellRendererCombo

	cellRendererCombo = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(CellRendererCombo)

	return cellRendererCombo
}

// CellRendererPixbuf: a CellRendererPixbuf can be used to render an image in a
// cell. It allows to render either a given Pixbuf (set via the
// CellRendererPixbuf:pixbuf property) or a named icon (set via the
// CellRendererPixbuf:icon-name property).
//
// To support the tree view, CellRendererPixbuf also supports rendering two
// alternative pixbufs, when the CellRenderer:is-expander property is true. If
// the CellRenderer:is-expanded property is true and the
// CellRendererPixbuf:pixbuf-expander-open property is set to a pixbuf, it
// renders that pixbuf, if the CellRenderer:is-expanded property is false and
// the CellRendererPixbuf:pixbuf-expander-closed property is set to a pixbuf, it
// renders that one.
type CellRendererPixbuf interface {
	CellRenderer
}

// cellRendererPixbuf implements the CellRendererPixbuf interface.
type cellRendererPixbuf struct {
	CellRenderer
}

var _ CellRendererPixbuf = (*cellRendererPixbuf)(nil)

// WrapCellRendererPixbuf wraps a GObject to the right type. It is
// primarily used internally.
func WrapCellRendererPixbuf(obj *externglib.Object) CellRendererPixbuf {
	return CellRendererPixbuf{
		CellRenderer: WrapCellRenderer(obj),
	}
}

func marshalCellRendererPixbuf(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCellRendererPixbuf(obj), nil
}

// NewCellRendererPixbuf constructs a class CellRendererPixbuf.
func NewCellRendererPixbuf() CellRendererPixbuf {
	var cret C.GtkCellRendererPixbuf

	cret = C.gtk_cell_renderer_pixbuf_new()

	var cellRendererPixbuf CellRendererPixbuf

	cellRendererPixbuf = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(CellRendererPixbuf)

	return cellRendererPixbuf
}

// CellRendererProgress renders a numeric value as a progress par in a cell.
// Additionally, it can display a text on top of the progress bar.
type CellRendererProgress interface {
	CellRenderer
	Orientable
}

// cellRendererProgress implements the CellRendererProgress interface.
type cellRendererProgress struct {
	CellRenderer
	Orientable
}

var _ CellRendererProgress = (*cellRendererProgress)(nil)

// WrapCellRendererProgress wraps a GObject to the right type. It is
// primarily used internally.
func WrapCellRendererProgress(obj *externglib.Object) CellRendererProgress {
	return CellRendererProgress{
		CellRenderer: WrapCellRenderer(obj),
		Orientable:   WrapOrientable(obj),
	}
}

func marshalCellRendererProgress(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCellRendererProgress(obj), nil
}

// NewCellRendererProgress constructs a class CellRendererProgress.
func NewCellRendererProgress() CellRendererProgress {
	var cret C.GtkCellRendererProgress

	cret = C.gtk_cell_renderer_progress_new()

	var cellRendererProgress CellRendererProgress

	cellRendererProgress = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(CellRendererProgress)

	return cellRendererProgress
}

// CellRendererSpin renders text in a cell like CellRendererText from which it
// is derived. But while CellRendererText offers a simple entry to edit the
// text, CellRendererSpin offers a SpinButton widget. Of course, that means that
// the text has to be parseable as a floating point number.
//
// The range of the spinbutton is taken from the adjustment property of the cell
// renderer, which can be set explicitly or mapped to a column in the tree
// model, like all properties of cell renders. CellRendererSpin also has
// properties for the CellRendererSpin:climb-rate and the number of
// CellRendererSpin:digits to display. Other SpinButton properties can be set in
// a handler for the CellRenderer::editing-started signal.
//
// The CellRendererSpin cell renderer was added in GTK 2.10.
type CellRendererSpin interface {
	CellRendererText
}

// cellRendererSpin implements the CellRendererSpin interface.
type cellRendererSpin struct {
	CellRendererText
}

var _ CellRendererSpin = (*cellRendererSpin)(nil)

// WrapCellRendererSpin wraps a GObject to the right type. It is
// primarily used internally.
func WrapCellRendererSpin(obj *externglib.Object) CellRendererSpin {
	return CellRendererSpin{
		CellRendererText: WrapCellRendererText(obj),
	}
}

func marshalCellRendererSpin(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCellRendererSpin(obj), nil
}

// NewCellRendererSpin constructs a class CellRendererSpin.
func NewCellRendererSpin() CellRendererSpin {
	var cret C.GtkCellRendererSpin

	cret = C.gtk_cell_renderer_spin_new()

	var cellRendererSpin CellRendererSpin

	cellRendererSpin = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(CellRendererSpin)

	return cellRendererSpin
}

// CellRendererSpinner: gtkCellRendererSpinner renders a spinning animation in a
// cell, very similar to Spinner. It can often be used as an alternative to a
// CellRendererProgress for displaying indefinite activity, instead of actual
// progress.
//
// To start the animation in a cell, set the CellRendererSpinner:active property
// to true and increment the CellRendererSpinner:pulse property at regular
// intervals. The usual way to set the cell renderer properties for each cell is
// to bind them to columns in your tree model using e.g.
// gtk_tree_view_column_add_attribute().
type CellRendererSpinner interface {
	CellRenderer
}

// cellRendererSpinner implements the CellRendererSpinner interface.
type cellRendererSpinner struct {
	CellRenderer
}

var _ CellRendererSpinner = (*cellRendererSpinner)(nil)

// WrapCellRendererSpinner wraps a GObject to the right type. It is
// primarily used internally.
func WrapCellRendererSpinner(obj *externglib.Object) CellRendererSpinner {
	return CellRendererSpinner{
		CellRenderer: WrapCellRenderer(obj),
	}
}

func marshalCellRendererSpinner(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCellRendererSpinner(obj), nil
}

// NewCellRendererSpinner constructs a class CellRendererSpinner.
func NewCellRendererSpinner() CellRendererSpinner {
	var cret C.GtkCellRendererSpinner

	cret = C.gtk_cell_renderer_spinner_new()

	var cellRendererSpinner CellRendererSpinner

	cellRendererSpinner = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(CellRendererSpinner)

	return cellRendererSpinner
}

// CellRendererToggle renders a toggle button in a cell. The button is drawn as
// a radio or a checkbutton, depending on the CellRendererToggle:radio property.
// When activated, it emits the CellRendererToggle::toggled signal.
type CellRendererToggle interface {
	CellRenderer

	// Activatable returns whether the cell renderer is activatable. See
	// gtk_cell_renderer_toggle_set_activatable().
	Activatable() bool
	// Active returns whether the cell renderer is active. See
	// gtk_cell_renderer_toggle_set_active().
	Active() bool
	// Radio returns whether we’re rendering radio toggles rather than
	// checkboxes.
	Radio() bool
	// SetActivatable makes the cell renderer activatable.
	SetActivatable(setting bool)
	// SetActive activates or deactivates a cell renderer.
	SetActive(setting bool)
	// SetRadio: if @radio is true, the cell renderer renders a radio toggle
	// (i.e. a toggle in a group of mutually-exclusive toggles). If false, it
	// renders a check toggle (a standalone boolean option). This can be set
	// globally for the cell renderer, or changed just before rendering each
	// cell in the model (for TreeView, you set up a per-row setting using
	// TreeViewColumn to associate model columns with cell renderer properties).
	SetRadio(radio bool)
}

// cellRendererToggle implements the CellRendererToggle interface.
type cellRendererToggle struct {
	CellRenderer
}

var _ CellRendererToggle = (*cellRendererToggle)(nil)

// WrapCellRendererToggle wraps a GObject to the right type. It is
// primarily used internally.
func WrapCellRendererToggle(obj *externglib.Object) CellRendererToggle {
	return CellRendererToggle{
		CellRenderer: WrapCellRenderer(obj),
	}
}

func marshalCellRendererToggle(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCellRendererToggle(obj), nil
}

// NewCellRendererToggle constructs a class CellRendererToggle.
func NewCellRendererToggle() CellRendererToggle {
	var cret C.GtkCellRendererToggle

	cret = C.gtk_cell_renderer_toggle_new()

	var cellRendererToggle CellRendererToggle

	cellRendererToggle = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(CellRendererToggle)

	return cellRendererToggle
}

// Activatable returns whether the cell renderer is activatable. See
// gtk_cell_renderer_toggle_set_activatable().
func (t cellRendererToggle) Activatable() bool {
	var arg0 *C.GtkCellRendererToggle

	arg0 = (*C.GtkCellRendererToggle)(unsafe.Pointer(t.Native()))

	var cret C.gboolean

	cret = C.gtk_cell_renderer_toggle_get_activatable(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// Active returns whether the cell renderer is active. See
// gtk_cell_renderer_toggle_set_active().
func (t cellRendererToggle) Active() bool {
	var arg0 *C.GtkCellRendererToggle

	arg0 = (*C.GtkCellRendererToggle)(unsafe.Pointer(t.Native()))

	var cret C.gboolean

	cret = C.gtk_cell_renderer_toggle_get_active(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// Radio returns whether we’re rendering radio toggles rather than
// checkboxes.
func (t cellRendererToggle) Radio() bool {
	var arg0 *C.GtkCellRendererToggle

	arg0 = (*C.GtkCellRendererToggle)(unsafe.Pointer(t.Native()))

	var cret C.gboolean

	cret = C.gtk_cell_renderer_toggle_get_radio(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// SetActivatable makes the cell renderer activatable.
func (t cellRendererToggle) SetActivatable(setting bool) {
	var arg0 *C.GtkCellRendererToggle
	var arg1 C.gboolean

	arg0 = (*C.GtkCellRendererToggle)(unsafe.Pointer(t.Native()))
	if setting {
		arg1 = C.gboolean(1)
	}

	C.gtk_cell_renderer_toggle_set_activatable(arg0, arg1)
}

// SetActive activates or deactivates a cell renderer.
func (t cellRendererToggle) SetActive(setting bool) {
	var arg0 *C.GtkCellRendererToggle
	var arg1 C.gboolean

	arg0 = (*C.GtkCellRendererToggle)(unsafe.Pointer(t.Native()))
	if setting {
		arg1 = C.gboolean(1)
	}

	C.gtk_cell_renderer_toggle_set_active(arg0, arg1)
}

// SetRadio: if @radio is true, the cell renderer renders a radio toggle
// (i.e. a toggle in a group of mutually-exclusive toggles). If false, it
// renders a check toggle (a standalone boolean option). This can be set
// globally for the cell renderer, or changed just before rendering each
// cell in the model (for TreeView, you set up a per-row setting using
// TreeViewColumn to associate model columns with cell renderer properties).
func (t cellRendererToggle) SetRadio(radio bool) {
	var arg0 *C.GtkCellRendererToggle
	var arg1 C.gboolean

	arg0 = (*C.GtkCellRendererToggle)(unsafe.Pointer(t.Native()))
	if radio {
		arg1 = C.gboolean(1)
	}

	C.gtk_cell_renderer_toggle_set_radio(arg0, arg1)
}

// CellView: a CellView displays a single row of a TreeModel using a CellArea
// and CellAreaContext. A CellAreaContext can be provided to the CellView at
// construction time in order to keep the cellview in context of a group of cell
// views, this ensures that the renderers displayed will be properly aligned
// with each other (like the aligned cells in the menus of ComboBox).
//
// CellView is Orientable in order to decide in which orientation the underlying
// CellAreaContext should be allocated. Taking the ComboBox menu as an example,
// cellviews should be oriented horizontally if the menus are listed
// top-to-bottom and thus all share the same width but may have separate
// individual heights (left-to-right menus should be allocated vertically since
// they all share the same height but may have variable widths).
//
//
// CSS nodes
//
// GtkCellView has a single CSS node with name cellview.
type CellView interface {
	Widget
	Accessible
	Buildable
	CellLayout
	ConstraintTarget
	Orientable

	// DisplayedRow returns a TreePath referring to the currently displayed row.
	// If no row is currently displayed, nil is returned.
	DisplayedRow() *TreePath
	// DrawSensitive gets whether @cell_view is configured to draw all of its
	// cells in a sensitive state.
	DrawSensitive() bool
	// FitModel gets whether @cell_view is configured to request space to fit
	// the entire TreeModel.
	FitModel() bool
	// Model returns the model for @cell_view. If no model is used nil is
	// returned.
	Model() TreeModel
	// SetDisplayedRow sets the row of the model that is currently displayed by
	// the CellView. If the path is unset, then the contents of the cellview
	// “stick” at their last value; this is not normally a desired result, but
	// may be a needed intermediate state if say, the model for the CellView
	// becomes temporarily empty.
	SetDisplayedRow(path *TreePath)
	// SetDrawSensitive sets whether @cell_view should draw all of its cells in
	// a sensitive state, this is used by ComboBox menus to ensure that rows
	// with insensitive cells that contain children appear sensitive in the
	// parent menu item.
	SetDrawSensitive(drawSensitive bool)
	// SetFitModel sets whether @cell_view should request space to fit the
	// entire TreeModel.
	//
	// This is used by ComboBox to ensure that the cell view displayed on the
	// combo box’s button always gets enough space and does not resize when
	// selection changes.
	SetFitModel(fitModel bool)
	// SetModel sets the model for @cell_view. If @cell_view already has a model
	// set, it will remove it before setting the new model. If @model is nil,
	// then it will unset the old model.
	SetModel(model TreeModel)
}

// cellView implements the CellView interface.
type cellView struct {
	Widget
	Accessible
	Buildable
	CellLayout
	ConstraintTarget
	Orientable
}

var _ CellView = (*cellView)(nil)

// WrapCellView wraps a GObject to the right type. It is
// primarily used internally.
func WrapCellView(obj *externglib.Object) CellView {
	return CellView{
		Widget:           WrapWidget(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		CellLayout:       WrapCellLayout(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
		Orientable:       WrapOrientable(obj),
	}
}

func marshalCellView(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCellView(obj), nil
}

// NewCellView constructs a class CellView.
func NewCellView() CellView {
	var cret C.GtkCellView

	cret = C.gtk_cell_view_new()

	var cellView CellView

	cellView = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(CellView)

	return cellView
}

// NewCellViewWithContext constructs a class CellView.
func NewCellViewWithContext(area CellArea, context CellAreaContext) CellView {
	var arg1 *C.GtkCellArea
	var arg2 *C.GtkCellAreaContext

	arg1 = (*C.GtkCellArea)(unsafe.Pointer(area.Native()))
	arg2 = (*C.GtkCellAreaContext)(unsafe.Pointer(context.Native()))

	var cret C.GtkCellView

	cret = C.gtk_cell_view_new_with_context(arg1, arg2)

	var cellView CellView

	cellView = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(CellView)

	return cellView
}

// NewCellViewWithMarkup constructs a class CellView.
func NewCellViewWithMarkup(markup string) CellView {
	var arg1 *C.char

	arg1 = (*C.char)(C.CString(markup))
	defer C.free(unsafe.Pointer(arg1))

	var cret C.GtkCellView

	cret = C.gtk_cell_view_new_with_markup(arg1)

	var cellView CellView

	cellView = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(CellView)

	return cellView
}

// NewCellViewWithText constructs a class CellView.
func NewCellViewWithText(text string) CellView {
	var arg1 *C.char

	arg1 = (*C.char)(C.CString(text))
	defer C.free(unsafe.Pointer(arg1))

	var cret C.GtkCellView

	cret = C.gtk_cell_view_new_with_text(arg1)

	var cellView CellView

	cellView = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(CellView)

	return cellView
}

// NewCellViewWithTexture constructs a class CellView.
func NewCellViewWithTexture(texture gdk.Texture) CellView {
	var arg1 *C.GdkTexture

	arg1 = (*C.GdkTexture)(unsafe.Pointer(texture.Native()))

	var cret C.GtkCellView

	cret = C.gtk_cell_view_new_with_texture(arg1)

	var cellView CellView

	cellView = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(CellView)

	return cellView
}

// DisplayedRow returns a TreePath referring to the currently displayed row.
// If no row is currently displayed, nil is returned.
func (c cellView) DisplayedRow() *TreePath {
	var arg0 *C.GtkCellView

	arg0 = (*C.GtkCellView)(unsafe.Pointer(c.Native()))

	var cret *C.GtkTreePath

	cret = C.gtk_cell_view_get_displayed_row(arg0)

	var treePath *TreePath

	treePath = WrapTreePath(unsafe.Pointer(cret))
	runtime.SetFinalizer(treePath, func(v *TreePath) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return treePath
}

// DrawSensitive gets whether @cell_view is configured to draw all of its
// cells in a sensitive state.
func (c cellView) DrawSensitive() bool {
	var arg0 *C.GtkCellView

	arg0 = (*C.GtkCellView)(unsafe.Pointer(c.Native()))

	var cret C.gboolean

	cret = C.gtk_cell_view_get_draw_sensitive(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// FitModel gets whether @cell_view is configured to request space to fit
// the entire TreeModel.
func (c cellView) FitModel() bool {
	var arg0 *C.GtkCellView

	arg0 = (*C.GtkCellView)(unsafe.Pointer(c.Native()))

	var cret C.gboolean

	cret = C.gtk_cell_view_get_fit_model(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// Model returns the model for @cell_view. If no model is used nil is
// returned.
func (c cellView) Model() TreeModel {
	var arg0 *C.GtkCellView

	arg0 = (*C.GtkCellView)(unsafe.Pointer(c.Native()))

	var cret *C.GtkTreeModel

	cret = C.gtk_cell_view_get_model(arg0)

	var treeModel TreeModel

	treeModel = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(TreeModel)

	return treeModel
}

// SetDisplayedRow sets the row of the model that is currently displayed by
// the CellView. If the path is unset, then the contents of the cellview
// “stick” at their last value; this is not normally a desired result, but
// may be a needed intermediate state if say, the model for the CellView
// becomes temporarily empty.
func (c cellView) SetDisplayedRow(path *TreePath) {
	var arg0 *C.GtkCellView
	var arg1 *C.GtkTreePath

	arg0 = (*C.GtkCellView)(unsafe.Pointer(c.Native()))
	arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	C.gtk_cell_view_set_displayed_row(arg0, arg1)
}

// SetDrawSensitive sets whether @cell_view should draw all of its cells in
// a sensitive state, this is used by ComboBox menus to ensure that rows
// with insensitive cells that contain children appear sensitive in the
// parent menu item.
func (c cellView) SetDrawSensitive(drawSensitive bool) {
	var arg0 *C.GtkCellView
	var arg1 C.gboolean

	arg0 = (*C.GtkCellView)(unsafe.Pointer(c.Native()))
	if drawSensitive {
		arg1 = C.gboolean(1)
	}

	C.gtk_cell_view_set_draw_sensitive(arg0, arg1)
}

// SetFitModel sets whether @cell_view should request space to fit the
// entire TreeModel.
//
// This is used by ComboBox to ensure that the cell view displayed on the
// combo box’s button always gets enough space and does not resize when
// selection changes.
func (c cellView) SetFitModel(fitModel bool) {
	var arg0 *C.GtkCellView
	var arg1 C.gboolean

	arg0 = (*C.GtkCellView)(unsafe.Pointer(c.Native()))
	if fitModel {
		arg1 = C.gboolean(1)
	}

	C.gtk_cell_view_set_fit_model(arg0, arg1)
}

// SetModel sets the model for @cell_view. If @cell_view already has a model
// set, it will remove it before setting the new model. If @model is nil,
// then it will unset the old model.
func (c cellView) SetModel(model TreeModel) {
	var arg0 *C.GtkCellView
	var arg1 *C.GtkTreeModel

	arg0 = (*C.GtkCellView)(unsafe.Pointer(c.Native()))
	arg1 = (*C.GtkTreeModel)(unsafe.Pointer(model.Native()))

	C.gtk_cell_view_set_model(arg0, arg1)
}

// ColorButton: the ColorButton is a button which displays the currently
// selected color and allows to open a color selection dialog to change the
// color. It is suitable widget for selecting a color in a preference dialog.
//
// CSS nodes
//
//    colorbutton
//    ╰── button.color
//        ╰── [content]
//
// GtkColorButton has a single CSS node with name colorbutton which contains a
// button node. To differentiate it from a plain Button, it gets the .color
// style class.
type ColorButton interface {
	Widget
	Accessible
	Buildable
	ColorChooser
	ConstraintTarget

	// Modal gets whether the dialog is modal.
	Modal() bool
	// Title gets the title of the color selection dialog.
	Title() string
	// SetModal sets whether the dialog should be modal.
	SetModal(modal bool)
	// SetTitle sets the title for the color selection dialog.
	SetTitle(title string)
}

// colorButton implements the ColorButton interface.
type colorButton struct {
	Widget
	Accessible
	Buildable
	ColorChooser
	ConstraintTarget
}

var _ ColorButton = (*colorButton)(nil)

// WrapColorButton wraps a GObject to the right type. It is
// primarily used internally.
func WrapColorButton(obj *externglib.Object) ColorButton {
	return ColorButton{
		Widget:           WrapWidget(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ColorChooser:     WrapColorChooser(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
	}
}

func marshalColorButton(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapColorButton(obj), nil
}

// NewColorButton constructs a class ColorButton.
func NewColorButton() ColorButton {
	var cret C.GtkColorButton

	cret = C.gtk_color_button_new()

	var colorButton ColorButton

	colorButton = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(ColorButton)

	return colorButton
}

// NewColorButtonWithRGBA constructs a class ColorButton.
func NewColorButtonWithRGBA(rgba *gdk.RGBA) ColorButton {
	var arg1 *C.GdkRGBA

	arg1 = (*C.GdkRGBA)(unsafe.Pointer(rgba.Native()))

	var cret C.GtkColorButton

	cret = C.gtk_color_button_new_with_rgba(arg1)

	var colorButton ColorButton

	colorButton = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(ColorButton)

	return colorButton
}

// Modal gets whether the dialog is modal.
func (b colorButton) Modal() bool {
	var arg0 *C.GtkColorButton

	arg0 = (*C.GtkColorButton)(unsafe.Pointer(b.Native()))

	var cret C.gboolean

	cret = C.gtk_color_button_get_modal(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// Title gets the title of the color selection dialog.
func (b colorButton) Title() string {
	var arg0 *C.GtkColorButton

	arg0 = (*C.GtkColorButton)(unsafe.Pointer(b.Native()))

	var cret *C.char

	cret = C.gtk_color_button_get_title(arg0)

	var utf8 string

	utf8 = C.GoString(cret)

	return utf8
}

// SetModal sets whether the dialog should be modal.
func (b colorButton) SetModal(modal bool) {
	var arg0 *C.GtkColorButton
	var arg1 C.gboolean

	arg0 = (*C.GtkColorButton)(unsafe.Pointer(b.Native()))
	if modal {
		arg1 = C.gboolean(1)
	}

	C.gtk_color_button_set_modal(arg0, arg1)
}

// SetTitle sets the title for the color selection dialog.
func (b colorButton) SetTitle(title string) {
	var arg0 *C.GtkColorButton
	var arg1 *C.char

	arg0 = (*C.GtkColorButton)(unsafe.Pointer(b.Native()))
	arg1 = (*C.char)(C.CString(title))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_color_button_set_title(arg0, arg1)
}

// ColorChooserDialog: the ColorChooserDialog widget is a dialog for choosing a
// color. It implements the ColorChooser interface.
type ColorChooserDialog interface {
	Dialog
	Accessible
	Buildable
	ColorChooser
	ConstraintTarget
	Native
	Root
	ShortcutManager
}

// colorChooserDialog implements the ColorChooserDialog interface.
type colorChooserDialog struct {
	Dialog
	Accessible
	Buildable
	ColorChooser
	ConstraintTarget
	Native
	Root
	ShortcutManager
}

var _ ColorChooserDialog = (*colorChooserDialog)(nil)

// WrapColorChooserDialog wraps a GObject to the right type. It is
// primarily used internally.
func WrapColorChooserDialog(obj *externglib.Object) ColorChooserDialog {
	return ColorChooserDialog{
		Dialog:           WrapDialog(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ColorChooser:     WrapColorChooser(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
		Native:           WrapNative(obj),
		Root:             WrapRoot(obj),
		ShortcutManager:  WrapShortcutManager(obj),
	}
}

func marshalColorChooserDialog(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapColorChooserDialog(obj), nil
}

// NewColorChooserDialog constructs a class ColorChooserDialog.
func NewColorChooserDialog(title string, parent Window) ColorChooserDialog {
	var arg1 *C.char
	var arg2 *C.GtkWindow

	arg1 = (*C.char)(C.CString(title))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GtkWindow)(unsafe.Pointer(parent.Native()))

	var cret C.GtkColorChooserDialog

	cret = C.gtk_color_chooser_dialog_new(arg1, arg2)

	var colorChooserDialog ColorChooserDialog

	colorChooserDialog = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(ColorChooserDialog)

	return colorChooserDialog
}

// ColorChooserWidget: the ColorChooserWidget widget lets the user select a
// color. By default, the chooser presents a predefined palette of colors, plus
// a small number of settable custom colors. It is also possible to select a
// different color with the single-color editor. To enter the single-color
// editing mode, use the context menu of any color of the palette, or use the
// '+' button to add a new custom color.
//
// The chooser automatically remembers the last selection, as well as custom
// colors.
//
// To change the initially selected color, use gtk_color_chooser_set_rgba(). To
// get the selected color use gtk_color_chooser_get_rgba().
//
// The ColorChooserWidget is used in the ColorChooserDialog to provide a dialog
// for selecting colors.
//
//
// CSS names
//
// GtkColorChooserWidget has a single CSS node with name colorchooser.
type ColorChooserWidget interface {
	Widget
	Accessible
	Buildable
	ColorChooser
	ConstraintTarget
}

// colorChooserWidget implements the ColorChooserWidget interface.
type colorChooserWidget struct {
	Widget
	Accessible
	Buildable
	ColorChooser
	ConstraintTarget
}

var _ ColorChooserWidget = (*colorChooserWidget)(nil)

// WrapColorChooserWidget wraps a GObject to the right type. It is
// primarily used internally.
func WrapColorChooserWidget(obj *externglib.Object) ColorChooserWidget {
	return ColorChooserWidget{
		Widget:           WrapWidget(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ColorChooser:     WrapColorChooser(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
	}
}

func marshalColorChooserWidget(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapColorChooserWidget(obj), nil
}

// NewColorChooserWidget constructs a class ColorChooserWidget.
func NewColorChooserWidget() ColorChooserWidget {
	var cret C.GtkColorChooserWidget

	cret = C.gtk_color_chooser_widget_new()

	var colorChooserWidget ColorChooserWidget

	colorChooserWidget = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(ColorChooserWidget)

	return colorChooserWidget
}

// ComboBoxText: a GtkComboBoxText is a simple variant of ComboBox that hides
// the model-view complexity for simple text-only use cases.
//
// To create a GtkComboBoxText, use gtk_combo_box_text_new() or
// gtk_combo_box_text_new_with_entry().
//
// You can add items to a GtkComboBoxText with gtk_combo_box_text_append_text(),
// gtk_combo_box_text_insert_text() or gtk_combo_box_text_prepend_text() and
// remove options with gtk_combo_box_text_remove().
//
// If the GtkComboBoxText contains an entry (via the “has-entry” property), its
// contents can be retrieved using gtk_combo_box_text_get_active_text(). The
// entry itself can be accessed by calling gtk_bin_get_child() on the combo box.
//
// You should not call gtk_combo_box_set_model() or attempt to pack more cells
// into this combo box via its GtkCellLayout interface.
//
//
// GtkComboBoxText as GtkBuildable
//
// The GtkComboBoxText implementation of the GtkBuildable interface supports
// adding items directly using the <items> element and specifying <item>
// elements for each item. Each <item> element can specify the “id”
// corresponding to the appended text and also supports the regular translation
// attributes “translatable”, “context” and “comments”.
//
// Here is a UI definition fragment specifying GtkComboBoxText items:
//
//    <object class="GtkComboBoxText">
//      <items>
//        <item translatable="yes" id="factory">Factory</item>
//        <item translatable="yes" id="home">Home</item>
//        <item translatable="yes" id="subway">Subway</item>
//      </items>
//    </object>
//
// CSS nodes
//
//    combobox
//    ╰── box.linked
//        ├── entry.combo
//        ├── button.combo
//        ╰── window.popup
//
// GtkComboBoxText has a single CSS node with name combobox. It adds the style
// class .combo to the main CSS nodes of its entry and button children, and the
// .linked class to the node of its internal box.
type ComboBoxText interface {
	ComboBox
	Accessible
	Buildable
	CellEditable
	CellLayout
	ConstraintTarget

	// Append appends @text to the list of strings stored in @combo_box. If @id
	// is non-nil then it is used as the ID of the row.
	//
	// This is the same as calling gtk_combo_box_text_insert() with a position
	// of -1.
	Append(id string, text string)
	// AppendText appends @text to the list of strings stored in @combo_box.
	//
	// This is the same as calling gtk_combo_box_text_insert_text() with a
	// position of -1.
	AppendText(text string)
	// ActiveText returns the currently active string in @combo_box, or nil if
	// none is selected. If @combo_box contains an entry, this function will
	// return its contents (which will not necessarily be an item from the
	// list).
	ActiveText() string
	// Insert inserts @text at @position in the list of strings stored in
	// @combo_box. If @id is non-nil then it is used as the ID of the row. See
	// ComboBox:id-column.
	//
	// If @position is negative then @text is appended.
	Insert(position int, id string, text string)
	// InsertText inserts @text at @position in the list of strings stored in
	// @combo_box.
	//
	// If @position is negative then @text is appended.
	//
	// This is the same as calling gtk_combo_box_text_insert() with a nil ID
	// string.
	InsertText(position int, text string)
	// Prepend prepends @text to the list of strings stored in @combo_box. If
	// @id is non-nil then it is used as the ID of the row.
	//
	// This is the same as calling gtk_combo_box_text_insert() with a position
	// of 0.
	Prepend(id string, text string)
	// PrependText prepends @text to the list of strings stored in @combo_box.
	//
	// This is the same as calling gtk_combo_box_text_insert_text() with a
	// position of 0.
	PrependText(text string)
	// Remove removes the string at @position from @combo_box.
	Remove(position int)
	// RemoveAll removes all the text entries from the combo box.
	RemoveAll()
}

// comboBoxText implements the ComboBoxText interface.
type comboBoxText struct {
	ComboBox
	Accessible
	Buildable
	CellEditable
	CellLayout
	ConstraintTarget
}

var _ ComboBoxText = (*comboBoxText)(nil)

// WrapComboBoxText wraps a GObject to the right type. It is
// primarily used internally.
func WrapComboBoxText(obj *externglib.Object) ComboBoxText {
	return ComboBoxText{
		ComboBox:         WrapComboBox(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		CellEditable:     WrapCellEditable(obj),
		CellLayout:       WrapCellLayout(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
	}
}

func marshalComboBoxText(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapComboBoxText(obj), nil
}

// NewComboBoxText constructs a class ComboBoxText.
func NewComboBoxText() ComboBoxText {
	var cret C.GtkComboBoxText

	cret = C.gtk_combo_box_text_new()

	var comboBoxText ComboBoxText

	comboBoxText = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(ComboBoxText)

	return comboBoxText
}

// NewComboBoxTextWithEntry constructs a class ComboBoxText.
func NewComboBoxTextWithEntry() ComboBoxText {
	var cret C.GtkComboBoxText

	cret = C.gtk_combo_box_text_new_with_entry()

	var comboBoxText ComboBoxText

	comboBoxText = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(ComboBoxText)

	return comboBoxText
}

// Append appends @text to the list of strings stored in @combo_box. If @id
// is non-nil then it is used as the ID of the row.
//
// This is the same as calling gtk_combo_box_text_insert() with a position
// of -1.
func (c comboBoxText) Append(id string, text string) {
	var arg0 *C.GtkComboBoxText
	var arg1 *C.char
	var arg2 *C.char

	arg0 = (*C.GtkComboBoxText)(unsafe.Pointer(c.Native()))
	arg1 = (*C.char)(C.CString(id))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.char)(C.CString(text))
	defer C.free(unsafe.Pointer(arg2))

	C.gtk_combo_box_text_append(arg0, arg1, arg2)
}

// AppendText appends @text to the list of strings stored in @combo_box.
//
// This is the same as calling gtk_combo_box_text_insert_text() with a
// position of -1.
func (c comboBoxText) AppendText(text string) {
	var arg0 *C.GtkComboBoxText
	var arg1 *C.char

	arg0 = (*C.GtkComboBoxText)(unsafe.Pointer(c.Native()))
	arg1 = (*C.char)(C.CString(text))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_combo_box_text_append_text(arg0, arg1)
}

// ActiveText returns the currently active string in @combo_box, or nil if
// none is selected. If @combo_box contains an entry, this function will
// return its contents (which will not necessarily be an item from the
// list).
func (c comboBoxText) ActiveText() string {
	var arg0 *C.GtkComboBoxText

	arg0 = (*C.GtkComboBoxText)(unsafe.Pointer(c.Native()))

	var cret *C.char

	cret = C.gtk_combo_box_text_get_active_text(arg0)

	var utf8 string

	utf8 = C.GoString(cret)
	defer C.free(unsafe.Pointer(cret))

	return utf8
}

// Insert inserts @text at @position in the list of strings stored in
// @combo_box. If @id is non-nil then it is used as the ID of the row. See
// ComboBox:id-column.
//
// If @position is negative then @text is appended.
func (c comboBoxText) Insert(position int, id string, text string) {
	var arg0 *C.GtkComboBoxText
	var arg1 C.int
	var arg2 *C.char
	var arg3 *C.char

	arg0 = (*C.GtkComboBoxText)(unsafe.Pointer(c.Native()))
	arg1 = C.int(position)
	arg2 = (*C.char)(C.CString(id))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.char)(C.CString(text))
	defer C.free(unsafe.Pointer(arg3))

	C.gtk_combo_box_text_insert(arg0, arg1, arg2, arg3)
}

// InsertText inserts @text at @position in the list of strings stored in
// @combo_box.
//
// If @position is negative then @text is appended.
//
// This is the same as calling gtk_combo_box_text_insert() with a nil ID
// string.
func (c comboBoxText) InsertText(position int, text string) {
	var arg0 *C.GtkComboBoxText
	var arg1 C.int
	var arg2 *C.char

	arg0 = (*C.GtkComboBoxText)(unsafe.Pointer(c.Native()))
	arg1 = C.int(position)
	arg2 = (*C.char)(C.CString(text))
	defer C.free(unsafe.Pointer(arg2))

	C.gtk_combo_box_text_insert_text(arg0, arg1, arg2)
}

// Prepend prepends @text to the list of strings stored in @combo_box. If
// @id is non-nil then it is used as the ID of the row.
//
// This is the same as calling gtk_combo_box_text_insert() with a position
// of 0.
func (c comboBoxText) Prepend(id string, text string) {
	var arg0 *C.GtkComboBoxText
	var arg1 *C.char
	var arg2 *C.char

	arg0 = (*C.GtkComboBoxText)(unsafe.Pointer(c.Native()))
	arg1 = (*C.char)(C.CString(id))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.char)(C.CString(text))
	defer C.free(unsafe.Pointer(arg2))

	C.gtk_combo_box_text_prepend(arg0, arg1, arg2)
}

// PrependText prepends @text to the list of strings stored in @combo_box.
//
// This is the same as calling gtk_combo_box_text_insert_text() with a
// position of 0.
func (c comboBoxText) PrependText(text string) {
	var arg0 *C.GtkComboBoxText
	var arg1 *C.char

	arg0 = (*C.GtkComboBoxText)(unsafe.Pointer(c.Native()))
	arg1 = (*C.char)(C.CString(text))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_combo_box_text_prepend_text(arg0, arg1)
}

// Remove removes the string at @position from @combo_box.
func (c comboBoxText) Remove(position int) {
	var arg0 *C.GtkComboBoxText
	var arg1 C.int

	arg0 = (*C.GtkComboBoxText)(unsafe.Pointer(c.Native()))
	arg1 = C.int(position)

	C.gtk_combo_box_text_remove(arg0, arg1)
}

// RemoveAll removes all the text entries from the combo box.
func (c comboBoxText) RemoveAll() {
	var arg0 *C.GtkComboBoxText

	arg0 = (*C.GtkComboBoxText)(unsafe.Pointer(c.Native()))

	C.gtk_combo_box_text_remove_all(arg0)
}

// EntryCompletion is an auxiliary object to be used in conjunction with Entry
// to provide the completion functionality. It implements the CellLayout
// interface, to allow the user to add extra cells to the TreeView with
// completion matches.
//
// “Completion functionality” means that when the user modifies the text in the
// entry, EntryCompletion checks which rows in the model match the current
// content of the entry, and displays a list of matches. By default, the
// matching is done by comparing the entry text case-insensitively against the
// text column of the model (see gtk_entry_completion_set_text_column()), but
// this can be overridden with a custom match function (see
// gtk_entry_completion_set_match_func()).
//
// When the user selects a completion, the content of the entry is updated. By
// default, the content of the entry is replaced by the text column of the
// model, but this can be overridden by connecting to the
// EntryCompletion::match-selected signal and updating the entry in the signal
// handler. Note that you should return true from the signal handler to suppress
// the default behaviour.
//
// To add completion functionality to an entry, use gtk_entry_set_completion().
//
// GtkEntryCompletion uses a TreeModelFilter model to represent the subset of
// the entire model that is currently matching. While the GtkEntryCompletion
// signals EntryCompletion::match-selected and EntryCompletion::cursor-on-match
// take the original model and an iter pointing to that model as arguments,
// other callbacks and signals (such as CellLayoutDataFuncs or
// CellArea::apply-attributes) will generally take the filter model as argument.
// As long as you are only calling gtk_tree_model_get(), this will make no
// difference to you. If for some reason, you need the original model, use
// gtk_tree_model_filter_get_model(). Don’t forget to use
// gtk_tree_model_filter_convert_iter_to_child_iter() to obtain a matching iter.
type EntryCompletion interface {
	gextras.Objector
	Buildable
	CellLayout

	// Complete requests a completion operation, or in other words a refiltering
	// of the current list with completions, using the current key. The
	// completion list view will be updated accordingly.
	Complete()
	// ComputePrefix computes the common prefix that is shared by all rows in
	// @completion that start with @key. If no row matches @key, nil will be
	// returned. Note that a text column must have been set for this function to
	// work, see gtk_entry_completion_set_text_column() for details.
	ComputePrefix(key string) string
	// CompletionPrefix: get the original text entered by the user that
	// triggered the completion or nil if there’s no completion ongoing.
	CompletionPrefix() string
	// Entry gets the entry @completion has been attached to.
	Entry() Widget
	// InlineCompletion returns whether the common prefix of the possible
	// completions should be automatically inserted in the entry.
	InlineCompletion() bool
	// InlineSelection returns true if inline-selection mode is turned on.
	InlineSelection() bool
	// MinimumKeyLength returns the minimum key length as set for @completion.
	MinimumKeyLength() int
	// Model returns the model the EntryCompletion is using as data source.
	// Returns nil if the model is unset.
	Model() TreeModel
	// PopupCompletion returns whether the completions should be presented in a
	// popup window.
	PopupCompletion() bool
	// PopupSetWidth returns whether the completion popup window will be resized
	// to the width of the entry.
	PopupSetWidth() bool
	// PopupSingleMatch returns whether the completion popup window will appear
	// even if there is only a single match.
	PopupSingleMatch() bool
	// TextColumn returns the column in the model of @completion to get strings
	// from.
	TextColumn() int
	// InsertPrefix requests a prefix insertion.
	InsertPrefix()
	// SetInlineCompletion sets whether the common prefix of the possible
	// completions should be automatically inserted in the entry.
	SetInlineCompletion(inlineCompletion bool)
	// SetInlineSelection sets whether it is possible to cycle through the
	// possible completions inside the entry.
	SetInlineSelection(inlineSelection bool)
	// SetMatchFunc sets the match function for @completion to be @func. The
	// match function is used to determine if a row should or should not be in
	// the completion list.
	SetMatchFunc()
	// SetMinimumKeyLength requires the length of the search key for @completion
	// to be at least @length. This is useful for long lists, where completing
	// using a small key takes a lot of time and will come up with meaningless
	// results anyway (ie, a too large dataset).
	SetMinimumKeyLength(length int)
	// SetModel sets the model for a EntryCompletion. If @completion already has
	// a model set, it will remove it before setting the new model. If model is
	// nil, then it will unset the model.
	SetModel(model TreeModel)
	// SetPopupCompletion sets whether the completions should be presented in a
	// popup window.
	SetPopupCompletion(popupCompletion bool)
	// SetPopupSetWidth sets whether the completion popup window will be resized
	// to be the same width as the entry.
	SetPopupSetWidth(popupSetWidth bool)
	// SetPopupSingleMatch sets whether the completion popup window will appear
	// even if there is only a single match. You may want to set this to false
	// if you are using [inline
	// completion][GtkEntryCompletion--inline-completion].
	SetPopupSingleMatch(popupSingleMatch bool)
	// SetTextColumn: convenience function for setting up the most used case of
	// this code: a completion list with just strings. This function will set up
	// @completion to have a list displaying all (and just) strings in the
	// completion list, and to get those strings from @column in the model of
	// @completion.
	//
	// This functions creates and adds a CellRendererText for the selected
	// column. If you need to set the text column, but don't want the cell
	// renderer, use g_object_set() to set the EntryCompletion:text-column
	// property directly.
	SetTextColumn(column int)
}

// entryCompletion implements the EntryCompletion interface.
type entryCompletion struct {
	gextras.Objector
	Buildable
	CellLayout
}

var _ EntryCompletion = (*entryCompletion)(nil)

// WrapEntryCompletion wraps a GObject to the right type. It is
// primarily used internally.
func WrapEntryCompletion(obj *externglib.Object) EntryCompletion {
	return EntryCompletion{
		Objector:   obj,
		Buildable:  WrapBuildable(obj),
		CellLayout: WrapCellLayout(obj),
	}
}

func marshalEntryCompletion(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapEntryCompletion(obj), nil
}

// NewEntryCompletion constructs a class EntryCompletion.
func NewEntryCompletion() EntryCompletion {
	var cret C.GtkEntryCompletion

	cret = C.gtk_entry_completion_new()

	var entryCompletion EntryCompletion

	entryCompletion = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(EntryCompletion)

	return entryCompletion
}

// NewEntryCompletionWithArea constructs a class EntryCompletion.
func NewEntryCompletionWithArea(area CellArea) EntryCompletion {
	var arg1 *C.GtkCellArea

	arg1 = (*C.GtkCellArea)(unsafe.Pointer(area.Native()))

	var cret C.GtkEntryCompletion

	cret = C.gtk_entry_completion_new_with_area(arg1)

	var entryCompletion EntryCompletion

	entryCompletion = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(EntryCompletion)

	return entryCompletion
}

// Complete requests a completion operation, or in other words a refiltering
// of the current list with completions, using the current key. The
// completion list view will be updated accordingly.
func (c entryCompletion) Complete() {
	var arg0 *C.GtkEntryCompletion

	arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))

	C.gtk_entry_completion_complete(arg0)
}

// ComputePrefix computes the common prefix that is shared by all rows in
// @completion that start with @key. If no row matches @key, nil will be
// returned. Note that a text column must have been set for this function to
// work, see gtk_entry_completion_set_text_column() for details.
func (c entryCompletion) ComputePrefix(key string) string {
	var arg0 *C.GtkEntryCompletion
	var arg1 *C.char

	arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))
	arg1 = (*C.char)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))

	var cret *C.char

	cret = C.gtk_entry_completion_compute_prefix(arg0, arg1)

	var utf8 string

	utf8 = C.GoString(cret)
	defer C.free(unsafe.Pointer(cret))

	return utf8
}

// CompletionPrefix: get the original text entered by the user that
// triggered the completion or nil if there’s no completion ongoing.
func (c entryCompletion) CompletionPrefix() string {
	var arg0 *C.GtkEntryCompletion

	arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))

	var cret *C.char

	cret = C.gtk_entry_completion_get_completion_prefix(arg0)

	var utf8 string

	utf8 = C.GoString(cret)

	return utf8
}

// Entry gets the entry @completion has been attached to.
func (c entryCompletion) Entry() Widget {
	var arg0 *C.GtkEntryCompletion

	arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))

	var cret *C.GtkWidget

	cret = C.gtk_entry_completion_get_entry(arg0)

	var widget Widget

	widget = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Widget)

	return widget
}

// InlineCompletion returns whether the common prefix of the possible
// completions should be automatically inserted in the entry.
func (c entryCompletion) InlineCompletion() bool {
	var arg0 *C.GtkEntryCompletion

	arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))

	var cret C.gboolean

	cret = C.gtk_entry_completion_get_inline_completion(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// InlineSelection returns true if inline-selection mode is turned on.
func (c entryCompletion) InlineSelection() bool {
	var arg0 *C.GtkEntryCompletion

	arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))

	var cret C.gboolean

	cret = C.gtk_entry_completion_get_inline_selection(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// MinimumKeyLength returns the minimum key length as set for @completion.
func (c entryCompletion) MinimumKeyLength() int {
	var arg0 *C.GtkEntryCompletion

	arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))

	var cret C.int

	cret = C.gtk_entry_completion_get_minimum_key_length(arg0)

	var gint int

	gint = (int)(cret)

	return gint
}

// Model returns the model the EntryCompletion is using as data source.
// Returns nil if the model is unset.
func (c entryCompletion) Model() TreeModel {
	var arg0 *C.GtkEntryCompletion

	arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))

	var cret *C.GtkTreeModel

	cret = C.gtk_entry_completion_get_model(arg0)

	var treeModel TreeModel

	treeModel = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(TreeModel)

	return treeModel
}

// PopupCompletion returns whether the completions should be presented in a
// popup window.
func (c entryCompletion) PopupCompletion() bool {
	var arg0 *C.GtkEntryCompletion

	arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))

	var cret C.gboolean

	cret = C.gtk_entry_completion_get_popup_completion(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// PopupSetWidth returns whether the completion popup window will be resized
// to the width of the entry.
func (c entryCompletion) PopupSetWidth() bool {
	var arg0 *C.GtkEntryCompletion

	arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))

	var cret C.gboolean

	cret = C.gtk_entry_completion_get_popup_set_width(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// PopupSingleMatch returns whether the completion popup window will appear
// even if there is only a single match.
func (c entryCompletion) PopupSingleMatch() bool {
	var arg0 *C.GtkEntryCompletion

	arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))

	var cret C.gboolean

	cret = C.gtk_entry_completion_get_popup_single_match(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// TextColumn returns the column in the model of @completion to get strings
// from.
func (c entryCompletion) TextColumn() int {
	var arg0 *C.GtkEntryCompletion

	arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))

	var cret C.int

	cret = C.gtk_entry_completion_get_text_column(arg0)

	var gint int

	gint = (int)(cret)

	return gint
}

// InsertPrefix requests a prefix insertion.
func (c entryCompletion) InsertPrefix() {
	var arg0 *C.GtkEntryCompletion

	arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))

	C.gtk_entry_completion_insert_prefix(arg0)
}

// SetInlineCompletion sets whether the common prefix of the possible
// completions should be automatically inserted in the entry.
func (c entryCompletion) SetInlineCompletion(inlineCompletion bool) {
	var arg0 *C.GtkEntryCompletion
	var arg1 C.gboolean

	arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))
	if inlineCompletion {
		arg1 = C.gboolean(1)
	}

	C.gtk_entry_completion_set_inline_completion(arg0, arg1)
}

// SetInlineSelection sets whether it is possible to cycle through the
// possible completions inside the entry.
func (c entryCompletion) SetInlineSelection(inlineSelection bool) {
	var arg0 *C.GtkEntryCompletion
	var arg1 C.gboolean

	arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))
	if inlineSelection {
		arg1 = C.gboolean(1)
	}

	C.gtk_entry_completion_set_inline_selection(arg0, arg1)
}

// SetMatchFunc sets the match function for @completion to be @func. The
// match function is used to determine if a row should or should not be in
// the completion list.
func (c entryCompletion) SetMatchFunc() {
	var arg0 *C.GtkEntryCompletion

	arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))

	C.gtk_entry_completion_set_match_func(arg0)
}

// SetMinimumKeyLength requires the length of the search key for @completion
// to be at least @length. This is useful for long lists, where completing
// using a small key takes a lot of time and will come up with meaningless
// results anyway (ie, a too large dataset).
func (c entryCompletion) SetMinimumKeyLength(length int) {
	var arg0 *C.GtkEntryCompletion
	var arg1 C.int

	arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))
	arg1 = C.int(length)

	C.gtk_entry_completion_set_minimum_key_length(arg0, arg1)
}

// SetModel sets the model for a EntryCompletion. If @completion already has
// a model set, it will remove it before setting the new model. If model is
// nil, then it will unset the model.
func (c entryCompletion) SetModel(model TreeModel) {
	var arg0 *C.GtkEntryCompletion
	var arg1 *C.GtkTreeModel

	arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))
	arg1 = (*C.GtkTreeModel)(unsafe.Pointer(model.Native()))

	C.gtk_entry_completion_set_model(arg0, arg1)
}

// SetPopupCompletion sets whether the completions should be presented in a
// popup window.
func (c entryCompletion) SetPopupCompletion(popupCompletion bool) {
	var arg0 *C.GtkEntryCompletion
	var arg1 C.gboolean

	arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))
	if popupCompletion {
		arg1 = C.gboolean(1)
	}

	C.gtk_entry_completion_set_popup_completion(arg0, arg1)
}

// SetPopupSetWidth sets whether the completion popup window will be resized
// to be the same width as the entry.
func (c entryCompletion) SetPopupSetWidth(popupSetWidth bool) {
	var arg0 *C.GtkEntryCompletion
	var arg1 C.gboolean

	arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))
	if popupSetWidth {
		arg1 = C.gboolean(1)
	}

	C.gtk_entry_completion_set_popup_set_width(arg0, arg1)
}

// SetPopupSingleMatch sets whether the completion popup window will appear
// even if there is only a single match. You may want to set this to false
// if you are using [inline
// completion][GtkEntryCompletion--inline-completion].
func (c entryCompletion) SetPopupSingleMatch(popupSingleMatch bool) {
	var arg0 *C.GtkEntryCompletion
	var arg1 C.gboolean

	arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))
	if popupSingleMatch {
		arg1 = C.gboolean(1)
	}

	C.gtk_entry_completion_set_popup_single_match(arg0, arg1)
}

// SetTextColumn: convenience function for setting up the most used case of
// this code: a completion list with just strings. This function will set up
// @completion to have a list displaying all (and just) strings in the
// completion list, and to get those strings from @column in the model of
// @completion.
//
// This functions creates and adds a CellRendererText for the selected
// column. If you need to set the text column, but don't want the cell
// renderer, use g_object_set() to set the EntryCompletion:text-column
// property directly.
func (c entryCompletion) SetTextColumn(column int) {
	var arg0 *C.GtkEntryCompletion
	var arg1 C.int

	arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))
	arg1 = C.int(column)

	C.gtk_entry_completion_set_text_column(arg0, arg1)
}

// Expander: a Expander allows the user to hide or show its child by clicking on
// an expander triangle similar to the triangles used in a TreeView.
//
// Normally you use an expander as you would use a frame; you create the child
// widget and use gtk_expander_set_child() to add it to the expander. When the
// expander is toggled, it will take care of showing and hiding the child
// automatically.
//
//
// Special Usage
//
// There are situations in which you may prefer to show and hide the expanded
// widget yourself, such as when you want to actually create the widget at
// expansion time. In this case, create a Expander but do not add a child to it.
// The expander widget has an Expander:expanded property which can be used to
// monitor its expansion state. You should watch this property with a signal
// connection as follows:
//
//    expander
//    ╰── box
//        ├── title
//        │   ├── arrow
//        │   ╰── <label widget>
//        ╰── <child>
//
// GtkExpander has three CSS nodes, the main node with the name expander, a
// subnode with name title and node below it with name arrow. The arrow of an
// expander that is showing its child gets the :checked pseudoclass added to it.
//
//
// Accessibility
//
// GtkExpander uses the K_ACCESSIBLE_ROLE_BUTTON role.
type Expander interface {
	Widget
	Accessible
	Buildable
	ConstraintTarget

	// Child gets the child widget of @expander.
	Child() Widget
	// Expanded queries a Expander and returns its current state. Returns true
	// if the child widget is revealed.
	//
	// See gtk_expander_set_expanded().
	Expanded() bool
	// Label fetches the text from a label widget including any embedded
	// underlines indicating mnemonics and Pango markup, as set by
	// gtk_expander_set_label(). If the label text has not been set the return
	// value will be nil. This will be the case if you create an empty button
	// with gtk_button_new() to use as a container.
	//
	// Note that this function behaved differently in versions prior to 2.14 and
	// used to return the label text stripped of embedded underlines indicating
	// mnemonics and Pango markup. This problem can be avoided by fetching the
	// label text directly from the label widget.
	Label() string
	// LabelWidget retrieves the label widget for the frame. See
	// gtk_expander_set_label_widget().
	LabelWidget() Widget
	// ResizeToplevel returns whether the expander will resize the toplevel
	// widget containing the expander upon resizing and collpasing.
	ResizeToplevel() bool
	// UseMarkup returns whether the label’s text is interpreted as marked up
	// with the [Pango text markup language][PangoMarkupFormat]. See
	// gtk_expander_set_use_markup().
	UseMarkup() bool
	// UseUnderline returns whether an embedded underline in the expander label
	// indicates a mnemonic. See gtk_expander_set_use_underline().
	UseUnderline() bool
	// SetChild sets the child widget of @expander.
	SetChild(child Widget)
	// SetExpanded sets the state of the expander. Set to true, if you want the
	// child widget to be revealed, and false if you want the child widget to be
	// hidden.
	SetExpanded(expanded bool)
	// SetLabel sets the text of the label of the expander to @label.
	//
	// This will also clear any previously set labels.
	SetLabel(label string)
	// SetLabelWidget: set the label widget for the expander. This is the widget
	// that will appear embedded alongside the expander arrow.
	SetLabelWidget(labelWidget Widget)
	// SetResizeToplevel sets whether the expander will resize the toplevel
	// widget containing the expander upon resizing and collpasing.
	SetResizeToplevel(resizeToplevel bool)
	// SetUseMarkup sets whether the text of the label contains markup in
	// [Pango’s text markup language][PangoMarkupFormat]. See
	// gtk_label_set_markup().
	SetUseMarkup(useMarkup bool)
	// SetUseUnderline: if true, an underline in the text of the expander label
	// indicates the next character should be used for the mnemonic accelerator
	// key.
	SetUseUnderline(useUnderline bool)
}

// expander implements the Expander interface.
type expander struct {
	Widget
	Accessible
	Buildable
	ConstraintTarget
}

var _ Expander = (*expander)(nil)

// WrapExpander wraps a GObject to the right type. It is
// primarily used internally.
func WrapExpander(obj *externglib.Object) Expander {
	return Expander{
		Widget:           WrapWidget(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
	}
}

func marshalExpander(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapExpander(obj), nil
}

// NewExpander constructs a class Expander.
func NewExpander(label string) Expander {
	var arg1 *C.char

	arg1 = (*C.char)(C.CString(label))
	defer C.free(unsafe.Pointer(arg1))

	var cret C.GtkExpander

	cret = C.gtk_expander_new(arg1)

	var expander Expander

	expander = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Expander)

	return expander
}

// NewExpanderWithMnemonic constructs a class Expander.
func NewExpanderWithMnemonic(label string) Expander {
	var arg1 *C.char

	arg1 = (*C.char)(C.CString(label))
	defer C.free(unsafe.Pointer(arg1))

	var cret C.GtkExpander

	cret = C.gtk_expander_new_with_mnemonic(arg1)

	var expander Expander

	expander = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Expander)

	return expander
}

// Child gets the child widget of @expander.
func (e expander) Child() Widget {
	var arg0 *C.GtkExpander

	arg0 = (*C.GtkExpander)(unsafe.Pointer(e.Native()))

	var cret *C.GtkWidget

	cret = C.gtk_expander_get_child(arg0)

	var widget Widget

	widget = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Widget)

	return widget
}

// Expanded queries a Expander and returns its current state. Returns true
// if the child widget is revealed.
//
// See gtk_expander_set_expanded().
func (e expander) Expanded() bool {
	var arg0 *C.GtkExpander

	arg0 = (*C.GtkExpander)(unsafe.Pointer(e.Native()))

	var cret C.gboolean

	cret = C.gtk_expander_get_expanded(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// Label fetches the text from a label widget including any embedded
// underlines indicating mnemonics and Pango markup, as set by
// gtk_expander_set_label(). If the label text has not been set the return
// value will be nil. This will be the case if you create an empty button
// with gtk_button_new() to use as a container.
//
// Note that this function behaved differently in versions prior to 2.14 and
// used to return the label text stripped of embedded underlines indicating
// mnemonics and Pango markup. This problem can be avoided by fetching the
// label text directly from the label widget.
func (e expander) Label() string {
	var arg0 *C.GtkExpander

	arg0 = (*C.GtkExpander)(unsafe.Pointer(e.Native()))

	var cret *C.char

	cret = C.gtk_expander_get_label(arg0)

	var utf8 string

	utf8 = C.GoString(cret)

	return utf8
}

// LabelWidget retrieves the label widget for the frame. See
// gtk_expander_set_label_widget().
func (e expander) LabelWidget() Widget {
	var arg0 *C.GtkExpander

	arg0 = (*C.GtkExpander)(unsafe.Pointer(e.Native()))

	var cret *C.GtkWidget

	cret = C.gtk_expander_get_label_widget(arg0)

	var widget Widget

	widget = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Widget)

	return widget
}

// ResizeToplevel returns whether the expander will resize the toplevel
// widget containing the expander upon resizing and collpasing.
func (e expander) ResizeToplevel() bool {
	var arg0 *C.GtkExpander

	arg0 = (*C.GtkExpander)(unsafe.Pointer(e.Native()))

	var cret C.gboolean

	cret = C.gtk_expander_get_resize_toplevel(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// UseMarkup returns whether the label’s text is interpreted as marked up
// with the [Pango text markup language][PangoMarkupFormat]. See
// gtk_expander_set_use_markup().
func (e expander) UseMarkup() bool {
	var arg0 *C.GtkExpander

	arg0 = (*C.GtkExpander)(unsafe.Pointer(e.Native()))

	var cret C.gboolean

	cret = C.gtk_expander_get_use_markup(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// UseUnderline returns whether an embedded underline in the expander label
// indicates a mnemonic. See gtk_expander_set_use_underline().
func (e expander) UseUnderline() bool {
	var arg0 *C.GtkExpander

	arg0 = (*C.GtkExpander)(unsafe.Pointer(e.Native()))

	var cret C.gboolean

	cret = C.gtk_expander_get_use_underline(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// SetChild sets the child widget of @expander.
func (e expander) SetChild(child Widget) {
	var arg0 *C.GtkExpander
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkExpander)(unsafe.Pointer(e.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_expander_set_child(arg0, arg1)
}

// SetExpanded sets the state of the expander. Set to true, if you want the
// child widget to be revealed, and false if you want the child widget to be
// hidden.
func (e expander) SetExpanded(expanded bool) {
	var arg0 *C.GtkExpander
	var arg1 C.gboolean

	arg0 = (*C.GtkExpander)(unsafe.Pointer(e.Native()))
	if expanded {
		arg1 = C.gboolean(1)
	}

	C.gtk_expander_set_expanded(arg0, arg1)
}

// SetLabel sets the text of the label of the expander to @label.
//
// This will also clear any previously set labels.
func (e expander) SetLabel(label string) {
	var arg0 *C.GtkExpander
	var arg1 *C.char

	arg0 = (*C.GtkExpander)(unsafe.Pointer(e.Native()))
	arg1 = (*C.char)(C.CString(label))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_expander_set_label(arg0, arg1)
}

// SetLabelWidget: set the label widget for the expander. This is the widget
// that will appear embedded alongside the expander arrow.
func (e expander) SetLabelWidget(labelWidget Widget) {
	var arg0 *C.GtkExpander
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkExpander)(unsafe.Pointer(e.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(labelWidget.Native()))

	C.gtk_expander_set_label_widget(arg0, arg1)
}

// SetResizeToplevel sets whether the expander will resize the toplevel
// widget containing the expander upon resizing and collpasing.
func (e expander) SetResizeToplevel(resizeToplevel bool) {
	var arg0 *C.GtkExpander
	var arg1 C.gboolean

	arg0 = (*C.GtkExpander)(unsafe.Pointer(e.Native()))
	if resizeToplevel {
		arg1 = C.gboolean(1)
	}

	C.gtk_expander_set_resize_toplevel(arg0, arg1)
}

// SetUseMarkup sets whether the text of the label contains markup in
// [Pango’s text markup language][PangoMarkupFormat]. See
// gtk_label_set_markup().
func (e expander) SetUseMarkup(useMarkup bool) {
	var arg0 *C.GtkExpander
	var arg1 C.gboolean

	arg0 = (*C.GtkExpander)(unsafe.Pointer(e.Native()))
	if useMarkup {
		arg1 = C.gboolean(1)
	}

	C.gtk_expander_set_use_markup(arg0, arg1)
}

// SetUseUnderline: if true, an underline in the text of the expander label
// indicates the next character should be used for the mnemonic accelerator
// key.
func (e expander) SetUseUnderline(useUnderline bool) {
	var arg0 *C.GtkExpander
	var arg1 C.gboolean

	arg0 = (*C.GtkExpander)(unsafe.Pointer(e.Native()))
	if useUnderline {
		arg1 = C.gboolean(1)
	}

	C.gtk_expander_set_use_underline(arg0, arg1)
}

// FileChooserDialog is a dialog box suitable for use with “File Open” or “File
// Save” commands. This widget works by putting a FileChooserWidget inside a
// Dialog. It exposes the FileChooser interface, so you can use all of the
// FileChooser functions on the file chooser dialog as well as those for Dialog.
//
// Note that FileChooserDialog does not have any methods of its own. Instead,
// you should use the functions that work on a FileChooser.
//
// If you want to integrate well with the platform you should use the
// FileChooserNative API, which will use a platform-specific dialog if available
// and fall back to GtkFileChooserDialog otherwise.
//
//
// Typical usage
//
// In the simplest of cases, you can the following code to use FileChooserDialog
// to select a file for opening:
//
//    static void
//    on_open_response (GtkDialog *dialog,
//                      int        response)
//    {
//      if (response == GTK_RESPONSE_ACCEPT)
//        {
//          GtkFileChooser *chooser = GTK_FILE_CHOOSER (dialog);
//
//          g_autoptr(GFile) file = gtk_file_chooser_get_file (chooser);
//
//          open_file (file);
//        }
//
//      gtk_window_destroy (GTK_WINDOW (dialog));
//    }
//
//      // ...
//      GtkWidget *dialog;
//      GtkFileChooserAction action = GTK_FILE_CHOOSER_ACTION_OPEN;
//
//      dialog = gtk_file_chooser_dialog_new ("Open File",
//                                            parent_window,
//                                            action,
//                                            _("_Cancel"),
//                                            GTK_RESPONSE_CANCEL,
//                                            _("_Open"),
//                                            GTK_RESPONSE_ACCEPT,
//                                            NULL);
//
//      gtk_widget_show (dialog);
//
//      g_signal_connect (dialog, "response",
//                        G_CALLBACK (on_open_response),
//                        NULL);
//
// To use a dialog for saving, you can use this:
//
//    static void
//    on_save_response (GtkDialog *dialog,
//                      int        response)
//    {
//      if (response == GTK_RESPONSE_ACCEPT)
//        {
//          GtkFileChooser *chooser = GTK_FILE_CHOOSER (dialog);
//
//          g_autoptr(GFile) file = gtk_file_chooser_get_file (chooser);
//
//          save_to_file (file);
//        }
//
//      gtk_window_destroy (GTK_WINDOW (dialog));
//    }
//
//      // ...
//      GtkWidget *dialog;
//      GtkFileChooser *chooser;
//      GtkFileChooserAction action = GTK_FILE_CHOOSER_ACTION_SAVE;
//
//      dialog = gtk_file_chooser_dialog_new ("Save File",
//                                            parent_window,
//                                            action,
//                                            _("_Cancel"),
//                                            GTK_RESPONSE_CANCEL,
//                                            _("_Save"),
//                                            GTK_RESPONSE_ACCEPT,
//                                            NULL);
//      chooser = GTK_FILE_CHOOSER (dialog);
//
//      if (user_edited_a_new_document)
//        gtk_file_chooser_set_current_name (chooser, _("Untitled document"));
//      else
//        gtk_file_chooser_set_file (chooser, existing_filename);
//
//      gtk_widget_show (dialog);
//
//      g_signal_connect (dialog, "response",
//                        G_CALLBACK (on_save_response),
//                        NULL);
//
//
// Setting up a file chooser dialog
//
// There are various cases in which you may need to use a FileChooserDialog:
//
// - To select a file for opening. Use K_FILE_CHOOSER_ACTION_OPEN.
//
// - To save a file for the first time. Use K_FILE_CHOOSER_ACTION_SAVE, and
// suggest a name such as “Untitled” with gtk_file_chooser_set_current_name().
//
// - To save a file under a different name. Use K_FILE_CHOOSER_ACTION_SAVE, and
// set the existing file with gtk_file_chooser_set_file().
//
// - To choose a folder instead of a file. Use
// K_FILE_CHOOSER_ACTION_SELECT_FOLDER.
//
// Note that old versions of the file chooser’s documentation suggested using
// gtk_file_chooser_set_current_folder() in various situations, with the
// intention of letting the application suggest a reasonable default folder.
// This is no longer considered to be a good policy, as now the file chooser is
// able to make good suggestions on its own. In general, you should only cause
// the file chooser to show a specific folder when it is appropriate to use
// gtk_file_chooser_set_file(), i.e. when you are doing a Save As command and
// you already have a file saved somewhere.
//
//
// Response Codes
//
// FileChooserDialog inherits from Dialog, so buttons that go in its action area
// have response codes such as K_RESPONSE_ACCEPT and K_RESPONSE_CANCEL. For
// example, you could call gtk_file_chooser_dialog_new() as follows:
//
//    GtkWidget *dialog;
//    GtkFileChooserAction action = GTK_FILE_CHOOSER_ACTION_OPEN;
//
//    dialog = gtk_file_chooser_dialog_new ("Open File",
//                                          parent_window,
//                                          action,
//                                          _("_Cancel"),
//                                          GTK_RESPONSE_CANCEL,
//                                          _("_Open"),
//                                          GTK_RESPONSE_ACCEPT,
//                                          NULL);
//
// This will create buttons for “Cancel” and “Open” that use predefined response
// identifiers from ResponseType. For most dialog boxes you can use your own
// custom response codes rather than the ones in ResponseType, but
// FileChooserDialog assumes that its “accept”-type action, e.g. an “Open” or
// “Save” button, will have one of the following response codes:
//
// - K_RESPONSE_ACCEPT - K_RESPONSE_OK - K_RESPONSE_YES - K_RESPONSE_APPLY
//
// This is because FileChooserDialog must intercept responses and switch to
// folders if appropriate, rather than letting the dialog terminate — the
// implementation uses these known response codes to know which responses can be
// blocked if appropriate.
//
// To summarize, make sure you use a [predefined response
// code][gtkfilechooserdialog-responses] when you use FileChooserDialog to
// ensure proper operation.
type FileChooserDialog interface {
	Dialog
	Accessible
	Buildable
	ConstraintTarget
	FileChooser
	Native
	Root
	ShortcutManager
}

// fileChooserDialog implements the FileChooserDialog interface.
type fileChooserDialog struct {
	Dialog
	Accessible
	Buildable
	ConstraintTarget
	FileChooser
	Native
	Root
	ShortcutManager
}

var _ FileChooserDialog = (*fileChooserDialog)(nil)

// WrapFileChooserDialog wraps a GObject to the right type. It is
// primarily used internally.
func WrapFileChooserDialog(obj *externglib.Object) FileChooserDialog {
	return FileChooserDialog{
		Dialog:           WrapDialog(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
		FileChooser:      WrapFileChooser(obj),
		Native:           WrapNative(obj),
		Root:             WrapRoot(obj),
		ShortcutManager:  WrapShortcutManager(obj),
	}
}

func marshalFileChooserDialog(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFileChooserDialog(obj), nil
}

// FileChooserWidget is a widget for choosing files. It exposes the FileChooser
// interface, and you should use the methods of this interface to interact with
// the widget.
//
//
// CSS nodes
//
// GtkFileChooserWidget has a single CSS node with name filechooser.
type FileChooserWidget interface {
	Widget
	Accessible
	Buildable
	ConstraintTarget
	FileChooser
}

// fileChooserWidget implements the FileChooserWidget interface.
type fileChooserWidget struct {
	Widget
	Accessible
	Buildable
	ConstraintTarget
	FileChooser
}

var _ FileChooserWidget = (*fileChooserWidget)(nil)

// WrapFileChooserWidget wraps a GObject to the right type. It is
// primarily used internally.
func WrapFileChooserWidget(obj *externglib.Object) FileChooserWidget {
	return FileChooserWidget{
		Widget:           WrapWidget(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
		FileChooser:      WrapFileChooser(obj),
	}
}

func marshalFileChooserWidget(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFileChooserWidget(obj), nil
}

// NewFileChooserWidget constructs a class FileChooserWidget.
func NewFileChooserWidget(action FileChooserAction) FileChooserWidget {
	var arg1 C.GtkFileChooserAction

	arg1 = (C.GtkFileChooserAction)(action)

	var cret C.GtkFileChooserWidget

	cret = C.gtk_file_chooser_widget_new(arg1)

	var fileChooserWidget FileChooserWidget

	fileChooserWidget = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(FileChooserWidget)

	return fileChooserWidget
}

// FileFilter: a GtkFileFilter can be used to restrict the files being shown in
// a FileChooser. Files can be filtered based on their name (with
// gtk_file_filter_add_pattern()) or on their mime type (with
// gtk_file_filter_add_mime_type()).
//
// Filtering by mime types handles aliasing and subclassing of mime types; e.g.
// a filter for text/plain also matches a file with mime type application/rtf,
// since application/rtf is a subclass of text/plain. Note that FileFilter
// allows wildcards for the subtype of a mime type, so you can e.g. filter for
// image/\*.
//
// Normally, file filters are used by adding them to a FileChooser (see
// gtk_file_chooser_add_filter()), but it is also possible to manually use a
// file filter on any FilterListModel containing Info objects.
//
//
// GtkFileFilter as GtkBuildable
//
// The GtkFileFilter implementation of the GtkBuildable interface supports
// adding rules using the <mime-types> and <patterns> elements and listing the
// rules within. Specifying a <mime-type> or <pattern> has the same effect as as
// calling gtk_file_filter_add_mime_type() or gtk_file_filter_add_pattern().
//
// An example of a UI definition fragment specifying GtkFileFilter rules:
//
//    <object class="GtkFileFilter">
//      <property name="name" translatable="yes">Text and Images</property>
//      <mime-types>
//        <mime-type>text/plain</mime-type>
//        <mime-type>image/ *</mime-type>
//      </mime-types>
//      <patterns>
//        <pattern>*.txt</pattern>
//        <pattern>*.png</pattern>
//      </patterns>
//    </object>
type FileFilter interface {
	Filter
	Buildable

	// AddMIMEType adds a rule allowing a given mime type to @filter.
	AddMIMEType(mimeType string)
	// AddPattern adds a rule allowing a shell style glob to a filter.
	AddPattern(pattern string)
	// AddPixbufFormats adds a rule allowing image files in the formats
	// supported by GdkPixbuf.
	//
	// This is equivalent to calling gtk_file_filter_add_mime_type() for all the
	// supported mime types.
	AddPixbufFormats()
	// Attributes gets the attributes that need to be filled in for the Info
	// passed to this filter.
	//
	// This function will not typically be used by applications; it is intended
	// principally for use in the implementation of FileChooser.
	Attributes() []string
	// Name gets the human-readable name for the filter. See
	// gtk_file_filter_set_name().
	Name() string
	// SetName sets a human-readable name of the filter; this is the string that
	// will be displayed in the file chooser if there is a selectable list of
	// filters.
	SetName(name string)
	// ToGVariant: serialize a file filter to an a{sv} variant.
	ToGVariant() *glib.Variant
}

// fileFilter implements the FileFilter interface.
type fileFilter struct {
	Filter
	Buildable
}

var _ FileFilter = (*fileFilter)(nil)

// WrapFileFilter wraps a GObject to the right type. It is
// primarily used internally.
func WrapFileFilter(obj *externglib.Object) FileFilter {
	return FileFilter{
		Filter:    WrapFilter(obj),
		Buildable: WrapBuildable(obj),
	}
}

func marshalFileFilter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFileFilter(obj), nil
}

// NewFileFilter constructs a class FileFilter.
func NewFileFilter() FileFilter {
	var cret C.GtkFileFilter

	cret = C.gtk_file_filter_new()

	var fileFilter FileFilter

	fileFilter = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(FileFilter)

	return fileFilter
}

// NewFileFilterFromGVariant constructs a class FileFilter.
func NewFileFilterFromGVariant(variant *glib.Variant) FileFilter {
	var arg1 *C.GVariant

	arg1 = (*C.GVariant)(unsafe.Pointer(variant.Native()))

	var cret C.GtkFileFilter

	cret = C.gtk_file_filter_new_from_gvariant(arg1)

	var fileFilter FileFilter

	fileFilter = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(FileFilter)

	return fileFilter
}

// AddMIMEType adds a rule allowing a given mime type to @filter.
func (f fileFilter) AddMIMEType(mimeType string) {
	var arg0 *C.GtkFileFilter
	var arg1 *C.char

	arg0 = (*C.GtkFileFilter)(unsafe.Pointer(f.Native()))
	arg1 = (*C.char)(C.CString(mimeType))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_file_filter_add_mime_type(arg0, arg1)
}

// AddPattern adds a rule allowing a shell style glob to a filter.
func (f fileFilter) AddPattern(pattern string) {
	var arg0 *C.GtkFileFilter
	var arg1 *C.char

	arg0 = (*C.GtkFileFilter)(unsafe.Pointer(f.Native()))
	arg1 = (*C.char)(C.CString(pattern))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_file_filter_add_pattern(arg0, arg1)
}

// AddPixbufFormats adds a rule allowing image files in the formats
// supported by GdkPixbuf.
//
// This is equivalent to calling gtk_file_filter_add_mime_type() for all the
// supported mime types.
func (f fileFilter) AddPixbufFormats() {
	var arg0 *C.GtkFileFilter

	arg0 = (*C.GtkFileFilter)(unsafe.Pointer(f.Native()))

	C.gtk_file_filter_add_pixbuf_formats(arg0)
}

// Attributes gets the attributes that need to be filled in for the Info
// passed to this filter.
//
// This function will not typically be used by applications; it is intended
// principally for use in the implementation of FileChooser.
func (f fileFilter) Attributes() []string {
	var arg0 *C.GtkFileFilter

	arg0 = (*C.GtkFileFilter)(unsafe.Pointer(f.Native()))

	var cret **C.char

	cret = C.gtk_file_filter_get_attributes(arg0)

	var utf8s []string

	{
		var length int
		for p := cret; *p != 0; p = (**C.char)(ptr.Add(unsafe.Pointer(p), unsafe.Sizeof(int(0)))) {
			length++
			if length < 0 {
				panic(`length overflow`)
			}
		}

		var src []*C.gchar
		ptr.SetSlice(unsafe.Pointer(&src), unsafe.Pointer(cret), int(length))

		utf8s = make([]string, length)
		for i := uintptr(0); i < uintptr(length); i += unsafe.Sizeof(int(0)) {
			utf8s = C.GoString(cret)
		}
	}

	return utf8s
}

// Name gets the human-readable name for the filter. See
// gtk_file_filter_set_name().
func (f fileFilter) Name() string {
	var arg0 *C.GtkFileFilter

	arg0 = (*C.GtkFileFilter)(unsafe.Pointer(f.Native()))

	var cret *C.char

	cret = C.gtk_file_filter_get_name(arg0)

	var utf8 string

	utf8 = C.GoString(cret)

	return utf8
}

// SetName sets a human-readable name of the filter; this is the string that
// will be displayed in the file chooser if there is a selectable list of
// filters.
func (f fileFilter) SetName(name string) {
	var arg0 *C.GtkFileFilter
	var arg1 *C.char

	arg0 = (*C.GtkFileFilter)(unsafe.Pointer(f.Native()))
	arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_file_filter_set_name(arg0, arg1)
}

// ToGVariant: serialize a file filter to an a{sv} variant.
func (f fileFilter) ToGVariant() *glib.Variant {
	var arg0 *C.GtkFileFilter

	arg0 = (*C.GtkFileFilter)(unsafe.Pointer(f.Native()))

	var cret *C.GVariant

	cret = C.gtk_file_filter_to_gvariant(arg0)

	var variant *glib.Variant

	variant = glib.WrapVariant(unsafe.Pointer(cret))

	return variant
}

// FlowBox: a GtkFlowBox positions child widgets in sequence according to its
// orientation.
//
// For instance, with the horizontal orientation, the widgets will be arranged
// from left to right, starting a new row under the previous row when necessary.
// Reducing the width in this case will require more rows, so a larger height
// will be requested.
//
// Likewise, with the vertical orientation, the widgets will be arranged from
// top to bottom, starting a new column to the right when necessary. Reducing
// the height will require more columns, so a larger width will be requested.
//
// The size request of a GtkFlowBox alone may not be what you expect; if you
// need to be able to shrink it along both axes and dynamically reflow its
// children, you may have to wrap it in a ScrolledWindow to enable that.
//
// The children of a GtkFlowBox can be dynamically sorted and filtered.
//
// Although a GtkFlowBox must have only FlowBoxChild children, you can add any
// kind of widget to it via gtk_flow_box_insert(), and a GtkFlowBoxChild widget
// will automatically be inserted between the box and the widget.
//
// Also see ListBox.
//
// CSS nodes
//
//    flowbox
//    ├── flowboxchild
//    │   ╰── <child>
//    ├── flowboxchild
//    │   ╰── <child>
//    ┊
//    ╰── [rubberband]
//
// GtkFlowBox uses a single CSS node with name flowbox. GtkFlowBoxChild uses a
// single CSS node with name flowboxchild. For rubberband selection, a subnode
// with name rubberband is used.
//
//
// Accessibility
//
// GtkFlowBox uses the K_ACCESSIBLE_ROLE_GRID role, and GtkFlowBoxChild uses the
// K_ACCESSIBLE_ROLE_GRID_CELL role.
type FlowBox interface {
	Widget
	Accessible
	Buildable
	ConstraintTarget
	Orientable

	// BindModel binds @model to @box.
	//
	// If @box was already bound to a model, that previous binding is destroyed.
	//
	// The contents of @box are cleared and then filled with widgets that
	// represent items from @model. @box is updated whenever @model changes. If
	// @model is nil, @box is left empty.
	//
	// It is undefined to add or remove widgets directly (for example, with
	// gtk_flow_box_insert()) while @box is bound to a model.
	//
	// Note that using a model is incompatible with the filtering and sorting
	// functionality in GtkFlowBox. When using a model, filtering and sorting
	// should be implemented by the model.
	BindModel()
	// ActivateOnSingleClick returns whether children activate on single clicks.
	ActivateOnSingleClick() bool
	// ChildAtIndex gets the nth child in the @box.
	ChildAtIndex(idx int) FlowBoxChild
	// ChildAtPos gets the child in the (@x, @y) position. Both @x and @y are
	// assumed to be relative to the origin of @box.
	ChildAtPos(x int, y int) FlowBoxChild
	// ColumnSpacing gets the horizontal spacing.
	ColumnSpacing() uint
	// Homogeneous returns whether the box is homogeneous (all children are the
	// same size). See gtk_box_set_homogeneous().
	Homogeneous() bool
	// MaxChildrenPerLine gets the maximum number of children per line.
	MaxChildrenPerLine() uint
	// MinChildrenPerLine gets the minimum number of children per line.
	MinChildrenPerLine() uint
	// RowSpacing gets the vertical spacing.
	RowSpacing() uint
	// SelectedChildren creates a list of all selected children.
	SelectedChildren() *glib.List
	// SelectionMode gets the selection mode of @box.
	SelectionMode() SelectionMode
	// Insert inserts the @widget into @box at @position.
	//
	// If a sort function is set, the widget will actually be inserted at the
	// calculated position.
	//
	// If @position is -1, or larger than the total number of children in the
	// @box, then the @widget will be appended to the end.
	Insert(widget Widget, position int)
	// InvalidateFilter updates the filtering for all children.
	//
	// Call this function when the result of the filter function on the @box is
	// changed due ot an external factor. For instance, this would be used if
	// the filter function just looked for a specific search term, and the entry
	// with the string has changed.
	InvalidateFilter()
	// InvalidateSort updates the sorting for all children.
	//
	// Call this when the result of the sort function on @box is changed due to
	// an external factor.
	InvalidateSort()
	// Remove removes a child from @box.
	Remove(widget Widget)
	// SelectAll: select all children of @box, if the selection mode allows it.
	SelectAll()
	// SelectChild selects a single child of @box, if the selection mode allows
	// it.
	SelectChild(child FlowBoxChild)
	// SelectedForeach calls a function for each selected child.
	//
	// Note that the selection cannot be modified from within this function.
	SelectedForeach()
	// SetActivateOnSingleClick: if @single is true, children will be activated
	// when you click on them, otherwise you need to double-click.
	SetActivateOnSingleClick(single bool)
	// SetColumnSpacing sets the horizontal space to add between children. See
	// the FlowBox:column-spacing property.
	SetColumnSpacing(spacing uint)
	// SetFilterFunc: by setting a filter function on the @box one can decide
	// dynamically which of the children to show. For instance, to implement a
	// search function that only shows the children matching the search terms.
	//
	// The @filter_func will be called for each child after the call, and it
	// will continue to be called each time a child changes (via
	// gtk_flow_box_child_changed()) or when gtk_flow_box_invalidate_filter() is
	// called.
	//
	// Note that using a filter function is incompatible with using a model (see
	// gtk_flow_box_bind_model()).
	SetFilterFunc()
	// SetHAdjustment hooks up an adjustment to focus handling in @box. The
	// adjustment is also used for autoscrolling during rubberband selection.
	// See gtk_scrolled_window_get_hadjustment() for a typical way of obtaining
	// the adjustment, and gtk_flow_box_set_vadjustment()for setting the
	// vertical adjustment.
	//
	// The adjustments have to be in pixel units and in the same coordinate
	// system as the allocation for immediate children of the box.
	SetHAdjustment(adjustment Adjustment)
	// SetHomogeneous sets the FlowBox:homogeneous property of @box, controlling
	// whether or not all children of @box are given equal space in the box.
	SetHomogeneous(homogeneous bool)
	// SetMaxChildrenPerLine sets the maximum number of children to request and
	// allocate space for in @box’s orientation.
	//
	// Setting the maximum number of children per line limits the overall
	// natural size request to be no more than @n_children children long in the
	// given orientation.
	SetMaxChildrenPerLine(nChildren uint)
	// SetMinChildrenPerLine sets the minimum number of children to line up in
	// @box’s orientation before flowing.
	SetMinChildrenPerLine(nChildren uint)
	// SetRowSpacing sets the vertical space to add between children. See the
	// FlowBox:row-spacing property.
	SetRowSpacing(spacing uint)
	// SetSelectionMode sets how selection works in @box. See SelectionMode for
	// details.
	SetSelectionMode(mode SelectionMode)
	// SetSortFunc: by setting a sort function on the @box, one can dynamically
	// reorder the children of the box, based on the contents of the children.
	//
	// The @sort_func will be called for each child after the call, and will
	// continue to be called each time a child changes (via
	// gtk_flow_box_child_changed()) and when gtk_flow_box_invalidate_sort() is
	// called.
	//
	// Note that using a sort function is incompatible with using a model (see
	// gtk_flow_box_bind_model()).
	SetSortFunc()
	// SetVAdjustment hooks up an adjustment to focus handling in @box. The
	// adjustment is also used for autoscrolling during rubberband selection.
	// See gtk_scrolled_window_get_vadjustment() for a typical way of obtaining
	// the adjustment, and gtk_flow_box_set_hadjustment()for setting the
	// horizontal adjustment.
	//
	// The adjustments have to be in pixel units and in the same coordinate
	// system as the allocation for immediate children of the box.
	SetVAdjustment(adjustment Adjustment)
	// UnselectAll: unselect all children of @box, if the selection mode allows
	// it.
	UnselectAll()
	// UnselectChild unselects a single child of @box, if the selection mode
	// allows it.
	UnselectChild(child FlowBoxChild)
}

// flowBox implements the FlowBox interface.
type flowBox struct {
	Widget
	Accessible
	Buildable
	ConstraintTarget
	Orientable
}

var _ FlowBox = (*flowBox)(nil)

// WrapFlowBox wraps a GObject to the right type. It is
// primarily used internally.
func WrapFlowBox(obj *externglib.Object) FlowBox {
	return FlowBox{
		Widget:           WrapWidget(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
		Orientable:       WrapOrientable(obj),
	}
}

func marshalFlowBox(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFlowBox(obj), nil
}

// NewFlowBox constructs a class FlowBox.
func NewFlowBox() FlowBox {
	var cret C.GtkFlowBox

	cret = C.gtk_flow_box_new()

	var flowBox FlowBox

	flowBox = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(FlowBox)

	return flowBox
}

// BindModel binds @model to @box.
//
// If @box was already bound to a model, that previous binding is destroyed.
//
// The contents of @box are cleared and then filled with widgets that
// represent items from @model. @box is updated whenever @model changes. If
// @model is nil, @box is left empty.
//
// It is undefined to add or remove widgets directly (for example, with
// gtk_flow_box_insert()) while @box is bound to a model.
//
// Note that using a model is incompatible with the filtering and sorting
// functionality in GtkFlowBox. When using a model, filtering and sorting
// should be implemented by the model.
func (b flowBox) BindModel() {
	var arg0 *C.GtkFlowBox

	arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))

	C.gtk_flow_box_bind_model(arg0)
}

// ActivateOnSingleClick returns whether children activate on single clicks.
func (b flowBox) ActivateOnSingleClick() bool {
	var arg0 *C.GtkFlowBox

	arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))

	var cret C.gboolean

	cret = C.gtk_flow_box_get_activate_on_single_click(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// ChildAtIndex gets the nth child in the @box.
func (b flowBox) ChildAtIndex(idx int) FlowBoxChild {
	var arg0 *C.GtkFlowBox
	var arg1 C.int

	arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
	arg1 = C.int(idx)

	var cret *C.GtkFlowBoxChild

	cret = C.gtk_flow_box_get_child_at_index(arg0, arg1)

	var flowBoxChild FlowBoxChild

	flowBoxChild = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(FlowBoxChild)

	return flowBoxChild
}

// ChildAtPos gets the child in the (@x, @y) position. Both @x and @y are
// assumed to be relative to the origin of @box.
func (b flowBox) ChildAtPos(x int, y int) FlowBoxChild {
	var arg0 *C.GtkFlowBox
	var arg1 C.int
	var arg2 C.int

	arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
	arg1 = C.int(x)
	arg2 = C.int(y)

	var cret *C.GtkFlowBoxChild

	cret = C.gtk_flow_box_get_child_at_pos(arg0, arg1, arg2)

	var flowBoxChild FlowBoxChild

	flowBoxChild = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(FlowBoxChild)

	return flowBoxChild
}

// ColumnSpacing gets the horizontal spacing.
func (b flowBox) ColumnSpacing() uint {
	var arg0 *C.GtkFlowBox

	arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))

	var cret C.guint

	cret = C.gtk_flow_box_get_column_spacing(arg0)

	var guint uint

	guint = (uint)(cret)

	return guint
}

// Homogeneous returns whether the box is homogeneous (all children are the
// same size). See gtk_box_set_homogeneous().
func (b flowBox) Homogeneous() bool {
	var arg0 *C.GtkFlowBox

	arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))

	var cret C.gboolean

	cret = C.gtk_flow_box_get_homogeneous(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// MaxChildrenPerLine gets the maximum number of children per line.
func (b flowBox) MaxChildrenPerLine() uint {
	var arg0 *C.GtkFlowBox

	arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))

	var cret C.guint

	cret = C.gtk_flow_box_get_max_children_per_line(arg0)

	var guint uint

	guint = (uint)(cret)

	return guint
}

// MinChildrenPerLine gets the minimum number of children per line.
func (b flowBox) MinChildrenPerLine() uint {
	var arg0 *C.GtkFlowBox

	arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))

	var cret C.guint

	cret = C.gtk_flow_box_get_min_children_per_line(arg0)

	var guint uint

	guint = (uint)(cret)

	return guint
}

// RowSpacing gets the vertical spacing.
func (b flowBox) RowSpacing() uint {
	var arg0 *C.GtkFlowBox

	arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))

	var cret C.guint

	cret = C.gtk_flow_box_get_row_spacing(arg0)

	var guint uint

	guint = (uint)(cret)

	return guint
}

// SelectedChildren creates a list of all selected children.
func (b flowBox) SelectedChildren() *glib.List {
	var arg0 *C.GtkFlowBox

	arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))

	var cret *C.GList

	cret = C.gtk_flow_box_get_selected_children(arg0)

	var list *glib.List

	list = glib.WrapList(unsafe.Pointer(cret))
	runtime.SetFinalizer(list, func(v *glib.List) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return list
}

// SelectionMode gets the selection mode of @box.
func (b flowBox) SelectionMode() SelectionMode {
	var arg0 *C.GtkFlowBox

	arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))

	var cret C.GtkSelectionMode

	cret = C.gtk_flow_box_get_selection_mode(arg0)

	var selectionMode SelectionMode

	selectionMode = SelectionMode(cret)

	return selectionMode
}

// Insert inserts the @widget into @box at @position.
//
// If a sort function is set, the widget will actually be inserted at the
// calculated position.
//
// If @position is -1, or larger than the total number of children in the
// @box, then the @widget will be appended to the end.
func (b flowBox) Insert(widget Widget, position int) {
	var arg0 *C.GtkFlowBox
	var arg1 *C.GtkWidget
	var arg2 C.int

	arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	arg2 = C.int(position)

	C.gtk_flow_box_insert(arg0, arg1, arg2)
}

// InvalidateFilter updates the filtering for all children.
//
// Call this function when the result of the filter function on the @box is
// changed due ot an external factor. For instance, this would be used if
// the filter function just looked for a specific search term, and the entry
// with the string has changed.
func (b flowBox) InvalidateFilter() {
	var arg0 *C.GtkFlowBox

	arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))

	C.gtk_flow_box_invalidate_filter(arg0)
}

// InvalidateSort updates the sorting for all children.
//
// Call this when the result of the sort function on @box is changed due to
// an external factor.
func (b flowBox) InvalidateSort() {
	var arg0 *C.GtkFlowBox

	arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))

	C.gtk_flow_box_invalidate_sort(arg0)
}

// Remove removes a child from @box.
func (b flowBox) Remove(widget Widget) {
	var arg0 *C.GtkFlowBox
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	C.gtk_flow_box_remove(arg0, arg1)
}

// SelectAll: select all children of @box, if the selection mode allows it.
func (b flowBox) SelectAll() {
	var arg0 *C.GtkFlowBox

	arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))

	C.gtk_flow_box_select_all(arg0)
}

// SelectChild selects a single child of @box, if the selection mode allows
// it.
func (b flowBox) SelectChild(child FlowBoxChild) {
	var arg0 *C.GtkFlowBox
	var arg1 *C.GtkFlowBoxChild

	arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
	arg1 = (*C.GtkFlowBoxChild)(unsafe.Pointer(child.Native()))

	C.gtk_flow_box_select_child(arg0, arg1)
}

// SelectedForeach calls a function for each selected child.
//
// Note that the selection cannot be modified from within this function.
func (b flowBox) SelectedForeach() {
	var arg0 *C.GtkFlowBox

	arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))

	C.gtk_flow_box_selected_foreach(arg0)
}

// SetActivateOnSingleClick: if @single is true, children will be activated
// when you click on them, otherwise you need to double-click.
func (b flowBox) SetActivateOnSingleClick(single bool) {
	var arg0 *C.GtkFlowBox
	var arg1 C.gboolean

	arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
	if single {
		arg1 = C.gboolean(1)
	}

	C.gtk_flow_box_set_activate_on_single_click(arg0, arg1)
}

// SetColumnSpacing sets the horizontal space to add between children. See
// the FlowBox:column-spacing property.
func (b flowBox) SetColumnSpacing(spacing uint) {
	var arg0 *C.GtkFlowBox
	var arg1 C.guint

	arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
	arg1 = C.guint(spacing)

	C.gtk_flow_box_set_column_spacing(arg0, arg1)
}

// SetFilterFunc: by setting a filter function on the @box one can decide
// dynamically which of the children to show. For instance, to implement a
// search function that only shows the children matching the search terms.
//
// The @filter_func will be called for each child after the call, and it
// will continue to be called each time a child changes (via
// gtk_flow_box_child_changed()) or when gtk_flow_box_invalidate_filter() is
// called.
//
// Note that using a filter function is incompatible with using a model (see
// gtk_flow_box_bind_model()).
func (b flowBox) SetFilterFunc() {
	var arg0 *C.GtkFlowBox

	arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))

	C.gtk_flow_box_set_filter_func(arg0)
}

// SetHAdjustment hooks up an adjustment to focus handling in @box. The
// adjustment is also used for autoscrolling during rubberband selection.
// See gtk_scrolled_window_get_hadjustment() for a typical way of obtaining
// the adjustment, and gtk_flow_box_set_vadjustment()for setting the
// vertical adjustment.
//
// The adjustments have to be in pixel units and in the same coordinate
// system as the allocation for immediate children of the box.
func (b flowBox) SetHAdjustment(adjustment Adjustment) {
	var arg0 *C.GtkFlowBox
	var arg1 *C.GtkAdjustment

	arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
	arg1 = (*C.GtkAdjustment)(unsafe.Pointer(adjustment.Native()))

	C.gtk_flow_box_set_hadjustment(arg0, arg1)
}

// SetHomogeneous sets the FlowBox:homogeneous property of @box, controlling
// whether or not all children of @box are given equal space in the box.
func (b flowBox) SetHomogeneous(homogeneous bool) {
	var arg0 *C.GtkFlowBox
	var arg1 C.gboolean

	arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
	if homogeneous {
		arg1 = C.gboolean(1)
	}

	C.gtk_flow_box_set_homogeneous(arg0, arg1)
}

// SetMaxChildrenPerLine sets the maximum number of children to request and
// allocate space for in @box’s orientation.
//
// Setting the maximum number of children per line limits the overall
// natural size request to be no more than @n_children children long in the
// given orientation.
func (b flowBox) SetMaxChildrenPerLine(nChildren uint) {
	var arg0 *C.GtkFlowBox
	var arg1 C.guint

	arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
	arg1 = C.guint(nChildren)

	C.gtk_flow_box_set_max_children_per_line(arg0, arg1)
}

// SetMinChildrenPerLine sets the minimum number of children to line up in
// @box’s orientation before flowing.
func (b flowBox) SetMinChildrenPerLine(nChildren uint) {
	var arg0 *C.GtkFlowBox
	var arg1 C.guint

	arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
	arg1 = C.guint(nChildren)

	C.gtk_flow_box_set_min_children_per_line(arg0, arg1)
}

// SetRowSpacing sets the vertical space to add between children. See the
// FlowBox:row-spacing property.
func (b flowBox) SetRowSpacing(spacing uint) {
	var arg0 *C.GtkFlowBox
	var arg1 C.guint

	arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
	arg1 = C.guint(spacing)

	C.gtk_flow_box_set_row_spacing(arg0, arg1)
}

// SetSelectionMode sets how selection works in @box. See SelectionMode for
// details.
func (b flowBox) SetSelectionMode(mode SelectionMode) {
	var arg0 *C.GtkFlowBox
	var arg1 C.GtkSelectionMode

	arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
	arg1 = (C.GtkSelectionMode)(mode)

	C.gtk_flow_box_set_selection_mode(arg0, arg1)
}

// SetSortFunc: by setting a sort function on the @box, one can dynamically
// reorder the children of the box, based on the contents of the children.
//
// The @sort_func will be called for each child after the call, and will
// continue to be called each time a child changes (via
// gtk_flow_box_child_changed()) and when gtk_flow_box_invalidate_sort() is
// called.
//
// Note that using a sort function is incompatible with using a model (see
// gtk_flow_box_bind_model()).
func (b flowBox) SetSortFunc() {
	var arg0 *C.GtkFlowBox

	arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))

	C.gtk_flow_box_set_sort_func(arg0)
}

// SetVAdjustment hooks up an adjustment to focus handling in @box. The
// adjustment is also used for autoscrolling during rubberband selection.
// See gtk_scrolled_window_get_vadjustment() for a typical way of obtaining
// the adjustment, and gtk_flow_box_set_hadjustment()for setting the
// horizontal adjustment.
//
// The adjustments have to be in pixel units and in the same coordinate
// system as the allocation for immediate children of the box.
func (b flowBox) SetVAdjustment(adjustment Adjustment) {
	var arg0 *C.GtkFlowBox
	var arg1 *C.GtkAdjustment

	arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
	arg1 = (*C.GtkAdjustment)(unsafe.Pointer(adjustment.Native()))

	C.gtk_flow_box_set_vadjustment(arg0, arg1)
}

// UnselectAll: unselect all children of @box, if the selection mode allows
// it.
func (b flowBox) UnselectAll() {
	var arg0 *C.GtkFlowBox

	arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))

	C.gtk_flow_box_unselect_all(arg0)
}

// UnselectChild unselects a single child of @box, if the selection mode
// allows it.
func (b flowBox) UnselectChild(child FlowBoxChild) {
	var arg0 *C.GtkFlowBox
	var arg1 *C.GtkFlowBoxChild

	arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
	arg1 = (*C.GtkFlowBoxChild)(unsafe.Pointer(child.Native()))

	C.gtk_flow_box_unselect_child(arg0, arg1)
}

// FontButton: the FontButton is a button which displays the currently selected
// font an allows to open a font chooser dialog to change the font. It is
// suitable widget for selecting a font in a preference dialog.
//
// CSS nodes
//
//    fontbutton
//    ╰── button.font
//        ╰── [content]
//
// GtkFontButton has a single CSS node with name fontbutton which contains a
// button node with the .font style class.
type FontButton interface {
	Widget
	Accessible
	Buildable
	ConstraintTarget
	FontChooser

	// Modal gets whether the dialog is modal.
	Modal() bool
	// Title retrieves the title of the font chooser dialog.
	Title() string
	// UseFont returns whether the selected font is used in the label.
	UseFont() bool
	// UseSize returns whether the selected size is used in the label.
	UseSize() bool
	// SetModal sets whether the dialog should be modal.
	SetModal(modal bool)
	// SetTitle sets the title for the font chooser dialog.
	SetTitle(title string)
	// SetUseFont: if @use_font is true, the font name will be written using the
	// selected font.
	SetUseFont(useFont bool)
	// SetUseSize: if @use_size is true, the font name will be written using the
	// selected size.
	SetUseSize(useSize bool)
}

// fontButton implements the FontButton interface.
type fontButton struct {
	Widget
	Accessible
	Buildable
	ConstraintTarget
	FontChooser
}

var _ FontButton = (*fontButton)(nil)

// WrapFontButton wraps a GObject to the right type. It is
// primarily used internally.
func WrapFontButton(obj *externglib.Object) FontButton {
	return FontButton{
		Widget:           WrapWidget(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
		FontChooser:      WrapFontChooser(obj),
	}
}

func marshalFontButton(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFontButton(obj), nil
}

// NewFontButton constructs a class FontButton.
func NewFontButton() FontButton {
	var cret C.GtkFontButton

	cret = C.gtk_font_button_new()

	var fontButton FontButton

	fontButton = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(FontButton)

	return fontButton
}

// NewFontButtonWithFont constructs a class FontButton.
func NewFontButtonWithFont(fontname string) FontButton {
	var arg1 *C.char

	arg1 = (*C.char)(C.CString(fontname))
	defer C.free(unsafe.Pointer(arg1))

	var cret C.GtkFontButton

	cret = C.gtk_font_button_new_with_font(arg1)

	var fontButton FontButton

	fontButton = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(FontButton)

	return fontButton
}

// Modal gets whether the dialog is modal.
func (f fontButton) Modal() bool {
	var arg0 *C.GtkFontButton

	arg0 = (*C.GtkFontButton)(unsafe.Pointer(f.Native()))

	var cret C.gboolean

	cret = C.gtk_font_button_get_modal(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// Title retrieves the title of the font chooser dialog.
func (f fontButton) Title() string {
	var arg0 *C.GtkFontButton

	arg0 = (*C.GtkFontButton)(unsafe.Pointer(f.Native()))

	var cret *C.char

	cret = C.gtk_font_button_get_title(arg0)

	var utf8 string

	utf8 = C.GoString(cret)

	return utf8
}

// UseFont returns whether the selected font is used in the label.
func (f fontButton) UseFont() bool {
	var arg0 *C.GtkFontButton

	arg0 = (*C.GtkFontButton)(unsafe.Pointer(f.Native()))

	var cret C.gboolean

	cret = C.gtk_font_button_get_use_font(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// UseSize returns whether the selected size is used in the label.
func (f fontButton) UseSize() bool {
	var arg0 *C.GtkFontButton

	arg0 = (*C.GtkFontButton)(unsafe.Pointer(f.Native()))

	var cret C.gboolean

	cret = C.gtk_font_button_get_use_size(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// SetModal sets whether the dialog should be modal.
func (f fontButton) SetModal(modal bool) {
	var arg0 *C.GtkFontButton
	var arg1 C.gboolean

	arg0 = (*C.GtkFontButton)(unsafe.Pointer(f.Native()))
	if modal {
		arg1 = C.gboolean(1)
	}

	C.gtk_font_button_set_modal(arg0, arg1)
}

// SetTitle sets the title for the font chooser dialog.
func (f fontButton) SetTitle(title string) {
	var arg0 *C.GtkFontButton
	var arg1 *C.char

	arg0 = (*C.GtkFontButton)(unsafe.Pointer(f.Native()))
	arg1 = (*C.char)(C.CString(title))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_font_button_set_title(arg0, arg1)
}

// SetUseFont: if @use_font is true, the font name will be written using the
// selected font.
func (f fontButton) SetUseFont(useFont bool) {
	var arg0 *C.GtkFontButton
	var arg1 C.gboolean

	arg0 = (*C.GtkFontButton)(unsafe.Pointer(f.Native()))
	if useFont {
		arg1 = C.gboolean(1)
	}

	C.gtk_font_button_set_use_font(arg0, arg1)
}

// SetUseSize: if @use_size is true, the font name will be written using the
// selected size.
func (f fontButton) SetUseSize(useSize bool) {
	var arg0 *C.GtkFontButton
	var arg1 C.gboolean

	arg0 = (*C.GtkFontButton)(unsafe.Pointer(f.Native()))
	if useSize {
		arg1 = C.gboolean(1)
	}

	C.gtk_font_button_set_use_size(arg0, arg1)
}

// FontChooserDialog: the FontChooserDialog widget is a dialog for selecting a
// font. It implements the FontChooser interface.
//
//
// GtkFontChooserDialog as GtkBuildable
//
// The GtkFontChooserDialog implementation of the Buildable interface exposes
// the buttons with the names “select_button” and “cancel_button”.
type FontChooserDialog interface {
	Dialog
	Accessible
	Buildable
	ConstraintTarget
	FontChooser
	Native
	Root
	ShortcutManager
}

// fontChooserDialog implements the FontChooserDialog interface.
type fontChooserDialog struct {
	Dialog
	Accessible
	Buildable
	ConstraintTarget
	FontChooser
	Native
	Root
	ShortcutManager
}

var _ FontChooserDialog = (*fontChooserDialog)(nil)

// WrapFontChooserDialog wraps a GObject to the right type. It is
// primarily used internally.
func WrapFontChooserDialog(obj *externglib.Object) FontChooserDialog {
	return FontChooserDialog{
		Dialog:           WrapDialog(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
		FontChooser:      WrapFontChooser(obj),
		Native:           WrapNative(obj),
		Root:             WrapRoot(obj),
		ShortcutManager:  WrapShortcutManager(obj),
	}
}

func marshalFontChooserDialog(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFontChooserDialog(obj), nil
}

// NewFontChooserDialog constructs a class FontChooserDialog.
func NewFontChooserDialog(title string, parent Window) FontChooserDialog {
	var arg1 *C.char
	var arg2 *C.GtkWindow

	arg1 = (*C.char)(C.CString(title))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GtkWindow)(unsafe.Pointer(parent.Native()))

	var cret C.GtkFontChooserDialog

	cret = C.gtk_font_chooser_dialog_new(arg1, arg2)

	var fontChooserDialog FontChooserDialog

	fontChooserDialog = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(FontChooserDialog)

	return fontChooserDialog
}

// FontChooserWidget: the FontChooserWidget widget lists the available fonts,
// styles and sizes, allowing the user to select a font. It is used in the
// FontChooserDialog widget to provide a dialog box for selecting fonts.
//
// To set the font which is initially selected, use gtk_font_chooser_set_font()
// or gtk_font_chooser_set_font_desc().
//
// To get the selected font use gtk_font_chooser_get_font() or
// gtk_font_chooser_get_font_desc().
//
// To change the text which is shown in the preview area, use
// gtk_font_chooser_set_preview_text().
//
//
// CSS nodes
//
// GtkFontChooserWidget has a single CSS node with name fontchooser.
type FontChooserWidget interface {
	Widget
	Accessible
	Buildable
	ConstraintTarget
	FontChooser
}

// fontChooserWidget implements the FontChooserWidget interface.
type fontChooserWidget struct {
	Widget
	Accessible
	Buildable
	ConstraintTarget
	FontChooser
}

var _ FontChooserWidget = (*fontChooserWidget)(nil)

// WrapFontChooserWidget wraps a GObject to the right type. It is
// primarily used internally.
func WrapFontChooserWidget(obj *externglib.Object) FontChooserWidget {
	return FontChooserWidget{
		Widget:           WrapWidget(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
		FontChooser:      WrapFontChooser(obj),
	}
}

func marshalFontChooserWidget(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFontChooserWidget(obj), nil
}

// NewFontChooserWidget constructs a class FontChooserWidget.
func NewFontChooserWidget() FontChooserWidget {
	var cret C.GtkFontChooserWidget

	cret = C.gtk_font_chooser_widget_new()

	var fontChooserWidget FontChooserWidget

	fontChooserWidget = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(FontChooserWidget)

	return fontChooserWidget
}

// HeaderBar: gtkHeaderBar is similar to a horizontal Box. It allows children to
// be placed at the start or the end. In addition, it allows the window title to
// be displayed. The title will be centered with respect to the width of the
// box, even if the children at either side take up different amounts of space.
//
// GtkHeaderBar can add typical window frame controls, such as minimize,
// maximize and close buttons, or the window icon.
//
// For these reasons, GtkHeaderBar is the natural choice for use as the custom
// titlebar widget of a Window (see gtk_window_set_titlebar()), as it gives
// features typical of titlebars while allowing the addition of child widgets.
//
// The GtkHeaderBar implementation of the Buildable interface supports adding
// children at the start or end sides by specifying “start” or “end” as the
// “type” attribute of a <child> element, or setting the title widget by
// specifying “title” value.
//
// By default the GtkHeaderBar uses a Label displaying the title of the window
// it is contained in as the title widget, equivalent to the following UI
// definition:
//
//    <object class="GtkHeaderBar">
//      <property name="title-widget">
//        <object class="GtkLabel">
//          <property name="label" translatable="yes">Label</property>
//          <property name="single-line-mode">True</property>
//          <property name="ellipsize">end</property>
//          <property name="width-chars">5</property>
//          <style>
//            <class name="title"/>
//          </style>
//        </object>
//      </property>
//    </object>
//
// CSS nodes
//
//    headerbar
//    ╰── windowhandle
//        ╰── box
//            ├── box.start
//            │   ├── windowcontrols.start
//            │   ╰── [other children]
//            ├── [Title Widget]
//            ╰── box.end
//                ├── [other children]
//                ╰── windowcontrols.end
//
// A HeaderBar's CSS node is called `headerbar`. It contains a `windowhandle`
// subnode, which contains a `box` subnode, which contains two `box` subnodes at
// the start and end of the header bar, as well as a center node that represents
// the title.
//
// Each of the boxes contains a `windowcontrols` subnode, see WindowControls for
// details, as well as other children.
//
//
// Accessibility
//
// GtkHeaderBar uses the GTK_ACCESSIBLE_ROLE_GROUP role.
type HeaderBar interface {
	Widget
	Accessible
	Buildable
	ConstraintTarget

	// DecorationLayout gets the decoration layout set with
	// gtk_header_bar_set_decoration_layout().
	DecorationLayout() string
	// ShowTitleButtons returns whether this header bar shows the standard
	// window title buttons.
	ShowTitleButtons() bool
	// TitleWidget retrieves the title widget of the header. See
	// gtk_header_bar_set_title_widget().
	TitleWidget() Widget
	// PackEnd adds @child to @bar, packed with reference to the end of the
	// @bar.
	PackEnd(child Widget)
	// PackStart adds @child to @bar, packed with reference to the start of the
	// @bar.
	PackStart(child Widget)
	// Remove removes a child from @bar, after it has been added with
	// gtk_header_bar_pack_start(), gtk_header_bar_pack_end() or
	// gtk_header_bar_set_title_widget().
	Remove(child Widget)
	// SetDecorationLayout sets the decoration layout for this header bar,
	// overriding the Settings:gtk-decoration-layout setting.
	//
	// There can be valid reasons for overriding the setting, such as a header
	// bar design that does not allow for buttons to take room on the right, or
	// only offers room for a single close button. Split header bars are another
	// example for overriding the setting.
	//
	// The format of the string is button names, separated by commas. A colon
	// separates the buttons that should appear on the left from those on the
	// right. Recognized button names are minimize, maximize, close and icon
	// (the window icon).
	//
	// For example, “icon:minimize,maximize,close” specifies a icon on the left,
	// and minimize, maximize and close buttons on the right.
	SetDecorationLayout(layout string)
	// SetShowTitleButtons sets whether this header bar shows the standard
	// window title buttons including close, maximize, and minimize.
	SetShowTitleButtons(setting bool)
	// SetTitleWidget sets the title for the HeaderBar.
	//
	// When set to nil, the headerbar will display the title of the window it is
	// contained in.
	//
	// The title should help a user identify the current view. To achieve the
	// same style as the builtin title, use the “title” style class.
	//
	// You should set the title widget to nil, for the window title label to be
	// visible again.
	SetTitleWidget(titleWidget Widget)
}

// headerBar implements the HeaderBar interface.
type headerBar struct {
	Widget
	Accessible
	Buildable
	ConstraintTarget
}

var _ HeaderBar = (*headerBar)(nil)

// WrapHeaderBar wraps a GObject to the right type. It is
// primarily used internally.
func WrapHeaderBar(obj *externglib.Object) HeaderBar {
	return HeaderBar{
		Widget:           WrapWidget(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
	}
}

func marshalHeaderBar(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapHeaderBar(obj), nil
}

// NewHeaderBar constructs a class HeaderBar.
func NewHeaderBar() HeaderBar {
	var cret C.GtkHeaderBar

	cret = C.gtk_header_bar_new()

	var headerBar HeaderBar

	headerBar = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(HeaderBar)

	return headerBar
}

// DecorationLayout gets the decoration layout set with
// gtk_header_bar_set_decoration_layout().
func (b headerBar) DecorationLayout() string {
	var arg0 *C.GtkHeaderBar

	arg0 = (*C.GtkHeaderBar)(unsafe.Pointer(b.Native()))

	var cret *C.char

	cret = C.gtk_header_bar_get_decoration_layout(arg0)

	var utf8 string

	utf8 = C.GoString(cret)

	return utf8
}

// ShowTitleButtons returns whether this header bar shows the standard
// window title buttons.
func (b headerBar) ShowTitleButtons() bool {
	var arg0 *C.GtkHeaderBar

	arg0 = (*C.GtkHeaderBar)(unsafe.Pointer(b.Native()))

	var cret C.gboolean

	cret = C.gtk_header_bar_get_show_title_buttons(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// TitleWidget retrieves the title widget of the header. See
// gtk_header_bar_set_title_widget().
func (b headerBar) TitleWidget() Widget {
	var arg0 *C.GtkHeaderBar

	arg0 = (*C.GtkHeaderBar)(unsafe.Pointer(b.Native()))

	var cret *C.GtkWidget

	cret = C.gtk_header_bar_get_title_widget(arg0)

	var widget Widget

	widget = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Widget)

	return widget
}

// PackEnd adds @child to @bar, packed with reference to the end of the
// @bar.
func (b headerBar) PackEnd(child Widget) {
	var arg0 *C.GtkHeaderBar
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkHeaderBar)(unsafe.Pointer(b.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_header_bar_pack_end(arg0, arg1)
}

// PackStart adds @child to @bar, packed with reference to the start of the
// @bar.
func (b headerBar) PackStart(child Widget) {
	var arg0 *C.GtkHeaderBar
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkHeaderBar)(unsafe.Pointer(b.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_header_bar_pack_start(arg0, arg1)
}

// Remove removes a child from @bar, after it has been added with
// gtk_header_bar_pack_start(), gtk_header_bar_pack_end() or
// gtk_header_bar_set_title_widget().
func (b headerBar) Remove(child Widget) {
	var arg0 *C.GtkHeaderBar
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkHeaderBar)(unsafe.Pointer(b.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_header_bar_remove(arg0, arg1)
}

// SetDecorationLayout sets the decoration layout for this header bar,
// overriding the Settings:gtk-decoration-layout setting.
//
// There can be valid reasons for overriding the setting, such as a header
// bar design that does not allow for buttons to take room on the right, or
// only offers room for a single close button. Split header bars are another
// example for overriding the setting.
//
// The format of the string is button names, separated by commas. A colon
// separates the buttons that should appear on the left from those on the
// right. Recognized button names are minimize, maximize, close and icon
// (the window icon).
//
// For example, “icon:minimize,maximize,close” specifies a icon on the left,
// and minimize, maximize and close buttons on the right.
func (b headerBar) SetDecorationLayout(layout string) {
	var arg0 *C.GtkHeaderBar
	var arg1 *C.char

	arg0 = (*C.GtkHeaderBar)(unsafe.Pointer(b.Native()))
	arg1 = (*C.char)(C.CString(layout))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_header_bar_set_decoration_layout(arg0, arg1)
}

// SetShowTitleButtons sets whether this header bar shows the standard
// window title buttons including close, maximize, and minimize.
func (b headerBar) SetShowTitleButtons(setting bool) {
	var arg0 *C.GtkHeaderBar
	var arg1 C.gboolean

	arg0 = (*C.GtkHeaderBar)(unsafe.Pointer(b.Native()))
	if setting {
		arg1 = C.gboolean(1)
	}

	C.gtk_header_bar_set_show_title_buttons(arg0, arg1)
}

// SetTitleWidget sets the title for the HeaderBar.
//
// When set to nil, the headerbar will display the title of the window it is
// contained in.
//
// The title should help a user identify the current view. To achieve the
// same style as the builtin title, use the “title” style class.
//
// You should set the title widget to nil, for the window title label to be
// visible again.
func (b headerBar) SetTitleWidget(titleWidget Widget) {
	var arg0 *C.GtkHeaderBar
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkHeaderBar)(unsafe.Pointer(b.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(titleWidget.Native()))

	C.gtk_header_bar_set_title_widget(arg0, arg1)
}

// IconPaintable contains information found when looking up an icon in an icon
// theme and supports painting it as a Paintable.
type IconPaintable interface {
	gextras.Objector
	gdk.Paintable

	// File gets the #GFile that was used to load the icon, or nil if the icon
	// was not loaded from a file.
	File() gio.File
	// IconName: get the icon name being used for this icon.
	//
	// When an icon looked up in the icon theme was not available, the icon
	// theme may use fallback icons - either those specified to
	// gtk_icon_theme_lookup_icon() or the always-available "image-missing". The
	// icon chosen is returned by this function.
	//
	// If the icon was created without an icon theme, this function returns nil.
	IconName() *string
	// IsSymbolic checks if the icon is symbolic or not. This currently uses
	// only the file name and not the file contents for determining this. This
	// behaviour may change in the future.
	//
	// Note that to render a symbolic IconPaintable properly (with recoloring),
	// you have to set its icon name on a Image.
	IsSymbolic() bool
}

// iconPaintable implements the IconPaintable interface.
type iconPaintable struct {
	gextras.Objector
	gdk.Paintable
}

var _ IconPaintable = (*iconPaintable)(nil)

// WrapIconPaintable wraps a GObject to the right type. It is
// primarily used internally.
func WrapIconPaintable(obj *externglib.Object) IconPaintable {
	return IconPaintable{
		Objector:      obj,
		gdk.Paintable: gdk.WrapPaintable(obj),
	}
}

func marshalIconPaintable(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapIconPaintable(obj), nil
}

// NewIconPaintableForFile constructs a class IconPaintable.
func NewIconPaintableForFile(file gio.File, size int, scale int) IconPaintable {
	var arg1 *C.GFile
	var arg2 C.int
	var arg3 C.int

	arg1 = (*C.GFile)(unsafe.Pointer(file.Native()))
	arg2 = C.int(size)
	arg3 = C.int(scale)

	var cret C.GtkIconPaintable

	cret = C.gtk_icon_paintable_new_for_file(arg1, arg2, arg3)

	var iconPaintable IconPaintable

	iconPaintable = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(IconPaintable)

	return iconPaintable
}

// File gets the #GFile that was used to load the icon, or nil if the icon
// was not loaded from a file.
func (s iconPaintable) File() gio.File {
	var arg0 *C.GtkIconPaintable

	arg0 = (*C.GtkIconPaintable)(unsafe.Pointer(s.Native()))

	var cret *C.GFile

	cret = C.gtk_icon_paintable_get_file(arg0)

	var file gio.File

	file = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(gio.File)

	return file
}

// IconName: get the icon name being used for this icon.
//
// When an icon looked up in the icon theme was not available, the icon
// theme may use fallback icons - either those specified to
// gtk_icon_theme_lookup_icon() or the always-available "image-missing". The
// icon chosen is returned by this function.
//
// If the icon was created without an icon theme, this function returns nil.
func (s iconPaintable) IconName() *string {
	var arg0 *C.GtkIconPaintable

	arg0 = (*C.GtkIconPaintable)(unsafe.Pointer(s.Native()))

	var cret *C.char

	cret = C.gtk_icon_paintable_get_icon_name(arg0)

	var filename *string

	filename = C.GoString(cret)

	return filename
}

// IsSymbolic checks if the icon is symbolic or not. This currently uses
// only the file name and not the file contents for determining this. This
// behaviour may change in the future.
//
// Note that to render a symbolic IconPaintable properly (with recoloring),
// you have to set its icon name on a Image.
func (s iconPaintable) IsSymbolic() bool {
	var arg0 *C.GtkIconPaintable

	arg0 = (*C.GtkIconPaintable)(unsafe.Pointer(s.Native()))

	var cret C.gboolean

	cret = C.gtk_icon_paintable_is_symbolic(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// IconTheme provides a facility for looking up icons by name and size. The main
// reason for using a name rather than simply providing a filename is to allow
// different icons to be used depending on what “icon theme” is selected by the
// user. The operation of icon themes on Linux and Unix follows the Icon Theme
// Specification (http://www.freedesktop.org/Standards/icon-theme-spec) There is
// a fallback icon theme, named `hicolor`, where applications should install
// their icons, but additional icon themes can be installed as operating system
// vendors and users choose.
//
// In many cases, named themes are used indirectly, via Image rather than
// directly, but looking up icons directly is also simple. The IconTheme object
// acts as a database of all the icons in the current theme. You can create new
// IconTheme objects, but it’s much more efficient to use the standard icon
// theme of the Widget so that the icon information is shared with other people
// looking up icons.
//
//    GtkIconTheme *icon_theme;
//    GtkIconPaintable *icon;
//    GdkPaintable *paintable;
//
//    icon_theme = gtk_icon_theme_get_for_display (gtk_widget_get_display (my_widget));
//    icon = gtk_icon_theme_lookup_icon (icon_theme,
//                                       "my-icon-name", // icon name
//                                       48, // icon size
//                                       1,  // scale
//                                       0,  // flags);
//     paintable = GDK_PAINTABLE (icon);
//     // Use the paintable
//     g_object_unref (icon);
type IconTheme interface {
	gextras.Objector

	// AddResourcePath adds a resource path that will be looked at when looking
	// for icons, similar to search paths.
	//
	// See gtk_icon_theme_set_resource_path().
	//
	// This function should be used to make application-specific icons available
	// as part of the icon theme.
	AddResourcePath(path string)
	// AddSearchPath appends a directory to the search path. See
	// gtk_icon_theme_set_search_path().
	AddSearchPath(path *string)
	// Display returns the display that the GtkIconTheme object was created for.
	Display() gdk.Display
	// IconNames lists the names of icons in the current icon theme.
	IconNames() []string
	// IconSizes returns an array of integers describing the sizes at which the
	// icon is available without scaling. A size of -1 means that the icon is
	// available in a scalable format. The array is zero-terminated.
	IconSizes(iconName string) []int
	// ResourcePath gets the current resource path.
	//
	// See gtk_icon_theme_set_resource_path().
	ResourcePath() []string
	// SearchPath gets the current search path. See
	// gtk_icon_theme_set_search_path().
	SearchPath() []*string
	// ThemeName gets the current icon theme name.
	//
	// Returns (transfer full): the current icon theme name,
	ThemeName() string
	// HasIcon checks whether an icon theme includes an icon for a particular
	// name.
	HasIcon(iconName string) bool
	// LookupByGIcon looks up a icon for a desired size and window scale,
	// returning a IconPaintable. The icon can then be rendered by using it as a
	// Paintable, or you can get information such as the filename and size.
	LookupByGIcon(icon gio.Icon, size int, scale int, direction TextDirection, flags IconLookupFlags) IconPaintable
	// LookupIcon looks up a named icon for a desired size and window scale,
	// returning a IconPaintable. The icon can then be rendered by using it as a
	// Paintable, or you can get information such as the filename and size.
	//
	// If the available @icon_name is not available and @fallbacks are provided,
	// they will be tried in order.
	//
	// If no matching icon is found, then a paintable that renders the "missing
	// icon" icon is returned. If you need to do something else for missing
	// icons you need to use gtk_icon_theme_has_icon().
	//
	// Note that you probably want to listen for icon theme changes and update
	// the icon. This is usually done by overriding the
	// WidgetClass.css-changed() function.
	LookupIcon(iconName string, fallbacks []string, size int, scale int, direction TextDirection, flags IconLookupFlags) IconPaintable
	// SetResourcePath sets the resource paths that will be looked at when
	// looking for icons, similar to search paths.
	//
	// The resources are considered as part of the hicolor icon theme and must
	// be located in subdirectories that are defined in the hicolor icon theme,
	// such as `@path/16x16/actions/run.png` or
	// `@path/scalable/actions/run.svg`.
	//
	// Icons that are directly placed in the resource path instead of a
	// subdirectory are also considered as ultimate fallback, but they are
	// treated like unthemed icons.
	SetResourcePath(path *string)
	// SetSearchPath sets the search path for the icon theme object. When
	// looking for an icon theme, GTK will search for a subdirectory of one or
	// more of the directories in @path with the same name as the icon theme
	// containing an index.theme file. (Themes from multiple of the path
	// elements are combined to allow themes to be extended by adding icons in
	// the user’s home directory.)
	//
	// In addition if an icon found isn’t found either in the current icon theme
	// or the default icon theme, and an image file with the right name is found
	// directly in one of the elements of @path, then that image will be used
	// for the icon name. (This is legacy feature, and new icons should be put
	// into the fallback icon theme, which is called hicolor, rather than
	// directly on the icon path.)
	SetSearchPath(path []*string)
	// SetThemeName sets the name of the icon theme that the IconTheme object
	// uses overriding system configuration. This function cannot be called on
	// the icon theme objects returned from gtk_icon_theme_get_for_display().
	SetThemeName(themeName string)
}

// iconTheme implements the IconTheme interface.
type iconTheme struct {
	gextras.Objector
}

var _ IconTheme = (*iconTheme)(nil)

// WrapIconTheme wraps a GObject to the right type. It is
// primarily used internally.
func WrapIconTheme(obj *externglib.Object) IconTheme {
	return IconTheme{
		Objector: obj,
	}
}

func marshalIconTheme(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapIconTheme(obj), nil
}

// NewIconTheme constructs a class IconTheme.
func NewIconTheme() IconTheme {
	var cret C.GtkIconTheme

	cret = C.gtk_icon_theme_new()

	var iconTheme IconTheme

	iconTheme = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(IconTheme)

	return iconTheme
}

// AddResourcePath adds a resource path that will be looked at when looking
// for icons, similar to search paths.
//
// See gtk_icon_theme_set_resource_path().
//
// This function should be used to make application-specific icons available
// as part of the icon theme.
func (s iconTheme) AddResourcePath(path string) {
	var arg0 *C.GtkIconTheme
	var arg1 *C.char

	arg0 = (*C.GtkIconTheme)(unsafe.Pointer(s.Native()))
	arg1 = (*C.char)(C.CString(path))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_icon_theme_add_resource_path(arg0, arg1)
}

// AddSearchPath appends a directory to the search path. See
// gtk_icon_theme_set_search_path().
func (s iconTheme) AddSearchPath(path *string) {
	var arg0 *C.GtkIconTheme
	var arg1 *C.char

	arg0 = (*C.GtkIconTheme)(unsafe.Pointer(s.Native()))
	arg1 = (*C.char)(C.CString(path))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_icon_theme_add_search_path(arg0, arg1)
}

// Display returns the display that the GtkIconTheme object was created for.
func (s iconTheme) Display() gdk.Display {
	var arg0 *C.GtkIconTheme

	arg0 = (*C.GtkIconTheme)(unsafe.Pointer(s.Native()))

	var cret *C.GdkDisplay

	cret = C.gtk_icon_theme_get_display(arg0)

	var display gdk.Display

	display = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(gdk.Display)

	return display
}

// IconNames lists the names of icons in the current icon theme.
func (s iconTheme) IconNames() []string {
	var arg0 *C.GtkIconTheme

	arg0 = (*C.GtkIconTheme)(unsafe.Pointer(s.Native()))

	var cret **C.char

	cret = C.gtk_icon_theme_get_icon_names(arg0)

	var utf8s []string

	{
		var length int
		for p := cret; *p != 0; p = (**C.char)(ptr.Add(unsafe.Pointer(p), unsafe.Sizeof(int(0)))) {
			length++
			if length < 0 {
				panic(`length overflow`)
			}
		}

		var src []*C.gchar
		ptr.SetSlice(unsafe.Pointer(&src), unsafe.Pointer(cret), int(length))

		utf8s = make([]string, length)
		for i := uintptr(0); i < uintptr(length); i += unsafe.Sizeof(int(0)) {
			utf8s = C.GoString(cret)
			defer C.free(unsafe.Pointer(cret))
		}
	}

	return utf8s
}

// IconSizes returns an array of integers describing the sizes at which the
// icon is available without scaling. A size of -1 means that the icon is
// available in a scalable format. The array is zero-terminated.
func (s iconTheme) IconSizes(iconName string) []int {
	var arg0 *C.GtkIconTheme
	var arg1 *C.char

	arg0 = (*C.GtkIconTheme)(unsafe.Pointer(s.Native()))
	arg1 = (*C.char)(C.CString(iconName))
	defer C.free(unsafe.Pointer(arg1))

	var cret *C.int

	cret = C.gtk_icon_theme_get_icon_sizes(arg0, arg1)

	var gints []int

	{
		var length int
		for p := cret; *p != 0; p = (*C.int)(ptr.Add(unsafe.Pointer(p), C.sizeof_int)) {
			length++
			if length < 0 {
				panic(`length overflow`)
			}
		}

		var src []C.int
		ptr.SetSlice(unsafe.Pointer(&src), unsafe.Pointer(cret), int(length))

		gints = make([]int, length)
		for i := uintptr(0); i < uintptr(length); i += C.sizeof_int {
			gints = (int)(cret)
		}
	}

	return gints
}

// ResourcePath gets the current resource path.
//
// See gtk_icon_theme_set_resource_path().
func (s iconTheme) ResourcePath() []string {
	var arg0 *C.GtkIconTheme

	arg0 = (*C.GtkIconTheme)(unsafe.Pointer(s.Native()))

	var cret **C.char

	cret = C.gtk_icon_theme_get_resource_path(arg0)

	var utf8s []string

	{
		var length int
		for p := cret; *p != 0; p = (**C.char)(ptr.Add(unsafe.Pointer(p), unsafe.Sizeof(int(0)))) {
			length++
			if length < 0 {
				panic(`length overflow`)
			}
		}

		var src []*C.gchar
		ptr.SetSlice(unsafe.Pointer(&src), unsafe.Pointer(cret), int(length))

		utf8s = make([]string, length)
		for i := uintptr(0); i < uintptr(length); i += unsafe.Sizeof(int(0)) {
			utf8s = C.GoString(cret)
			defer C.free(unsafe.Pointer(cret))
		}
	}

	return utf8s
}

// SearchPath gets the current search path. See
// gtk_icon_theme_set_search_path().
func (s iconTheme) SearchPath() []*string {
	var arg0 *C.GtkIconTheme

	arg0 = (*C.GtkIconTheme)(unsafe.Pointer(s.Native()))

	var cret **C.char

	cret = C.gtk_icon_theme_get_search_path(arg0)

	var filenames []*string

	{
		var length int
		for p := cret; *p != 0; p = (**C.char)(ptr.Add(unsafe.Pointer(p), unsafe.Sizeof(int(0)))) {
			length++
			if length < 0 {
				panic(`length overflow`)
			}
		}

		var src []*C.gchar
		ptr.SetSlice(unsafe.Pointer(&src), unsafe.Pointer(cret), int(length))

		filenames = make([]*string, length)
		for i := uintptr(0); i < uintptr(length); i += unsafe.Sizeof(int(0)) {
			filenames = C.GoString(cret)
			defer C.free(unsafe.Pointer(cret))
		}
	}

	return filenames
}

// ThemeName gets the current icon theme name.
//
// Returns (transfer full): the current icon theme name,
func (s iconTheme) ThemeName() string {
	var arg0 *C.GtkIconTheme

	arg0 = (*C.GtkIconTheme)(unsafe.Pointer(s.Native()))

	var cret *C.char

	cret = C.gtk_icon_theme_get_theme_name(arg0)

	var utf8 string

	utf8 = C.GoString(cret)
	defer C.free(unsafe.Pointer(cret))

	return utf8
}

// HasIcon checks whether an icon theme includes an icon for a particular
// name.
func (s iconTheme) HasIcon(iconName string) bool {
	var arg0 *C.GtkIconTheme
	var arg1 *C.char

	arg0 = (*C.GtkIconTheme)(unsafe.Pointer(s.Native()))
	arg1 = (*C.char)(C.CString(iconName))
	defer C.free(unsafe.Pointer(arg1))

	var cret C.gboolean

	cret = C.gtk_icon_theme_has_icon(arg0, arg1)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// LookupByGIcon looks up a icon for a desired size and window scale,
// returning a IconPaintable. The icon can then be rendered by using it as a
// Paintable, or you can get information such as the filename and size.
func (s iconTheme) LookupByGIcon(icon gio.Icon, size int, scale int, direction TextDirection, flags IconLookupFlags) IconPaintable {
	var arg0 *C.GtkIconTheme
	var arg1 *C.GIcon
	var arg2 C.int
	var arg3 C.int
	var arg4 C.GtkTextDirection
	var arg5 C.GtkIconLookupFlags

	arg0 = (*C.GtkIconTheme)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GIcon)(unsafe.Pointer(icon.Native()))
	arg2 = C.int(size)
	arg3 = C.int(scale)
	arg4 = (C.GtkTextDirection)(direction)
	arg5 = (C.GtkIconLookupFlags)(flags)

	var cret *C.GtkIconPaintable

	cret = C.gtk_icon_theme_lookup_by_gicon(arg0, arg1, arg2, arg3, arg4, arg5)

	var iconPaintable IconPaintable

	iconPaintable = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(IconPaintable)

	return iconPaintable
}

// LookupIcon looks up a named icon for a desired size and window scale,
// returning a IconPaintable. The icon can then be rendered by using it as a
// Paintable, or you can get information such as the filename and size.
//
// If the available @icon_name is not available and @fallbacks are provided,
// they will be tried in order.
//
// If no matching icon is found, then a paintable that renders the "missing
// icon" icon is returned. If you need to do something else for missing
// icons you need to use gtk_icon_theme_has_icon().
//
// Note that you probably want to listen for icon theme changes and update
// the icon. This is usually done by overriding the
// WidgetClass.css-changed() function.
func (s iconTheme) LookupIcon(iconName string, fallbacks []string, size int, scale int, direction TextDirection, flags IconLookupFlags) IconPaintable {
	var arg0 *C.GtkIconTheme
	var arg1 *C.char
	var arg2 **C.char
	var arg3 C.int
	var arg4 C.int
	var arg5 C.GtkTextDirection
	var arg6 C.GtkIconLookupFlags

	arg0 = (*C.GtkIconTheme)(unsafe.Pointer(s.Native()))
	arg1 = (*C.char)(C.CString(iconName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (**C.char)(C.malloc((len(fallbacks) + 1) * unsafe.Sizeof(int(0))))
	defer C.free(unsafe.Pointer(arg2))

	{
		var out []*C.char
		ptr.SetSlice(unsafe.Pointer(&dst), unsafe.Pointer(arg2), int(len(fallbacks)))

		for i := range fallbacks {
			arg2 = (*C.char)(C.CString(fallbacks))
			defer C.free(unsafe.Pointer(arg2))
		}
	}
	arg3 = C.int(size)
	arg4 = C.int(scale)
	arg5 = (C.GtkTextDirection)(direction)
	arg6 = (C.GtkIconLookupFlags)(flags)

	var cret *C.GtkIconPaintable

	cret = C.gtk_icon_theme_lookup_icon(arg0, arg1, arg2, arg3, arg4, arg5, arg6)

	var iconPaintable IconPaintable

	iconPaintable = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(IconPaintable)

	return iconPaintable
}

// SetResourcePath sets the resource paths that will be looked at when
// looking for icons, similar to search paths.
//
// The resources are considered as part of the hicolor icon theme and must
// be located in subdirectories that are defined in the hicolor icon theme,
// such as `@path/16x16/actions/run.png` or
// `@path/scalable/actions/run.svg`.
//
// Icons that are directly placed in the resource path instead of a
// subdirectory are also considered as ultimate fallback, but they are
// treated like unthemed icons.
func (s iconTheme) SetResourcePath(path *string) {
	var arg0 *C.GtkIconTheme
	var arg1 **C.char

	arg0 = (*C.GtkIconTheme)(unsafe.Pointer(s.Native()))
	arg1 = (**C.char)(C.CString(path))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_icon_theme_set_resource_path(arg0, arg1)
}

// SetSearchPath sets the search path for the icon theme object. When
// looking for an icon theme, GTK will search for a subdirectory of one or
// more of the directories in @path with the same name as the icon theme
// containing an index.theme file. (Themes from multiple of the path
// elements are combined to allow themes to be extended by adding icons in
// the user’s home directory.)
//
// In addition if an icon found isn’t found either in the current icon theme
// or the default icon theme, and an image file with the right name is found
// directly in one of the elements of @path, then that image will be used
// for the icon name. (This is legacy feature, and new icons should be put
// into the fallback icon theme, which is called hicolor, rather than
// directly on the icon path.)
func (s iconTheme) SetSearchPath(path []*string) {
	var arg0 *C.GtkIconTheme
	var arg1 **C.char

	arg0 = (*C.GtkIconTheme)(unsafe.Pointer(s.Native()))
	arg1 = (**C.char)(C.malloc((len(path) + 1) * unsafe.Sizeof(int(0))))
	defer C.free(unsafe.Pointer(arg1))

	{
		var out []*C.gchar
		ptr.SetSlice(unsafe.Pointer(&dst), unsafe.Pointer(arg1), int(len(path)))

		for i := range path {
			arg1 = (*C.gchar)(C.CString(path))
			defer C.free(unsafe.Pointer(arg1))
		}
	}

	C.gtk_icon_theme_set_search_path(arg0, arg1)
}

// SetThemeName sets the name of the icon theme that the IconTheme object
// uses overriding system configuration. This function cannot be called on
// the icon theme objects returned from gtk_icon_theme_get_for_display().
func (s iconTheme) SetThemeName(themeName string) {
	var arg0 *C.GtkIconTheme
	var arg1 *C.char

	arg0 = (*C.GtkIconTheme)(unsafe.Pointer(s.Native()))
	arg1 = (*C.char)(C.CString(themeName))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_icon_theme_set_theme_name(arg0, arg1)
}

// IconView provides an alternative view on a TreeModel. It displays the model
// as a grid of icons with labels. Like TreeView, it allows to select one or
// multiple items (depending on the selection mode, see
// gtk_icon_view_set_selection_mode()). In addition to selection with the arrow
// keys, IconView supports rubberband selection, which is controlled by dragging
// the pointer.
//
// Note that if the tree model is backed by an actual tree store (as opposed to
// a flat list where the mapping to icons is obvious), IconView will only
// display the first level of the tree and ignore the tree’s branches.
//
// CSS nodes
//
//    iconview.view
//    ╰── [rubberband]
//
// GtkIconView has a single CSS node with name iconview and style class .view.
// For rubberband selection, a subnode with name rubberband is used.
type IconView interface {
	Widget
	Accessible
	Buildable
	CellLayout
	ConstraintTarget
	Scrollable

	// CreateDragIcon creates a #cairo_surface_t representation of the item at
	// @path. This image is used for a drag icon.
	CreateDragIcon(path *TreePath) gdk.Paintable
	// EnableModelDragDest turns @icon_view into a drop destination for
	// automatic DND. Calling this method sets IconView:reorderable to false.
	EnableModelDragDest(formats *gdk.ContentFormats, actions gdk.DragAction)
	// EnableModelDragSource turns @icon_view into a drag source for automatic
	// DND. Calling this method sets IconView:reorderable to false.
	EnableModelDragSource(startButtonMask gdk.ModifierType, formats *gdk.ContentFormats, actions gdk.DragAction)
	// ActivateOnSingleClick gets the setting set by
	// gtk_icon_view_set_activate_on_single_click().
	ActivateOnSingleClick() bool
	// CellRect fills the bounding rectangle in widget coordinates for the cell
	// specified by @path and @cell. If @cell is nil the main cell area is used.
	//
	// This function is only valid if @icon_view is realized.
	CellRect(path *TreePath, cell CellRenderer) (rect gdk.Rectangle, ok bool)
	// ColumnSpacing returns the value of the ::column-spacing property.
	ColumnSpacing() int
	// Columns returns the value of the ::columns property.
	Columns() int
	// Cursor fills in @path and @cell with the current cursor path and cell. If
	// the cursor isn’t currently set, then *@path will be nil. If no cell
	// currently has focus, then *@cell will be nil.
	//
	// The returned TreePath must be freed with gtk_tree_path_free().
	Cursor() (path *TreePath, cell CellRenderer, ok bool)
	// DestItemAtPos determines the destination item for a given position.
	DestItemAtPos(dragX int, dragY int) (path *TreePath, pos IconViewDropPosition, ok bool)
	// DragDestItem gets information about the item that is highlighted for
	// feedback.
	DragDestItem() (path *TreePath, pos IconViewDropPosition)
	// ItemAtPos gets the path and cell for the icon at the given position.
	ItemAtPos(x int, y int) (path *TreePath, cell CellRenderer, ok bool)
	// ItemColumn gets the column in which the item @path is currently
	// displayed. Column numbers start at 0.
	ItemColumn(path *TreePath) int
	// ItemOrientation returns the value of the ::item-orientation property
	// which determines whether the labels are drawn beside the icons instead of
	// below.
	ItemOrientation() Orientation
	// ItemPadding returns the value of the ::item-padding property.
	ItemPadding() int
	// ItemRow gets the row in which the item @path is currently displayed. Row
	// numbers start at 0.
	ItemRow(path *TreePath) int
	// ItemWidth returns the value of the ::item-width property.
	ItemWidth() int
	// Margin returns the value of the ::margin property.
	Margin() int
	// MarkupColumn returns the column with markup text for @icon_view.
	MarkupColumn() int
	// Model returns the model the IconView is based on. Returns nil if the
	// model is unset.
	Model() TreeModel
	// PathAtPos gets the path for the icon at the given position.
	PathAtPos(x int, y int) *TreePath
	// PixbufColumn returns the column with pixbufs for @icon_view.
	PixbufColumn() int
	// Reorderable retrieves whether the user can reorder the list via
	// drag-and-drop. See gtk_icon_view_set_reorderable().
	Reorderable() bool
	// RowSpacing returns the value of the ::row-spacing property.
	RowSpacing() int
	// SelectedItems creates a list of paths of all selected items.
	// Additionally, if you are planning on modifying the model after calling
	// this function, you may want to convert the returned list into a list of
	// TreeRowReferences. To do this, you can use gtk_tree_row_reference_new().
	//
	// To free the return value, use:
	//
	//    g_list_free_full (list, (GDestroyNotify) gtk_tree_path_free);
	SelectedItems() *glib.List
	// SelectionMode gets the selection mode of the @icon_view.
	SelectionMode() SelectionMode
	// Spacing returns the value of the ::spacing property.
	Spacing() int
	// TextColumn returns the column with text for @icon_view.
	TextColumn() int
	// TooltipColumn returns the column of @icon_view’s model which is being
	// used for displaying tooltips on @icon_view’s rows.
	TooltipColumn() int
	// TooltipContext: this function is supposed to be used in a
	// Widget::query-tooltip signal handler for IconView. The @x, @y and
	// @keyboard_tip values which are received in the signal handler, should be
	// passed to this function without modification.
	//
	// The return value indicates whether there is an icon view item at the
	// given coordinates (true) or not (false) for mouse tooltips. For keyboard
	// tooltips the item returned will be the cursor item. When true, then any
	// of @model, @path and @iter which have been provided will be set to point
	// to that row and the corresponding model.
	TooltipContext(x int, y int, keyboardTip bool) (model TreeModel, path *TreePath, iter TreeIter, ok bool)
	// VisibleRange sets @start_path and @end_path to be the first and last
	// visible path. Note that there may be invisible paths in between.
	//
	// Both paths should be freed with gtk_tree_path_free() after use.
	VisibleRange() (startPath *TreePath, endPath *TreePath, ok bool)
	// ItemActivated activates the item determined by @path.
	ItemActivated(path *TreePath)
	// PathIsSelected returns true if the icon pointed to by @path is currently
	// selected. If @path does not point to a valid location, false is returned.
	PathIsSelected(path *TreePath) bool
	// ScrollToPath moves the alignments of @icon_view to the position specified
	// by @path. @row_align determines where the row is placed, and @col_align
	// determines where @column is placed. Both are expected to be between 0.0
	// and 1.0. 0.0 means left/top alignment, 1.0 means right/bottom alignment,
	// 0.5 means center.
	//
	// If @use_align is false, then the alignment arguments are ignored, and the
	// tree does the minimum amount of work to scroll the item onto the screen.
	// This means that the item will be scrolled to the edge closest to its
	// current position. If the item is currently visible on the screen, nothing
	// is done.
	//
	// This function only works if the model is set, and @path is a valid row on
	// the model. If the model changes before the @icon_view is realized, the
	// centered path will be modified to reflect this change.
	ScrollToPath(path *TreePath, useAlign bool, rowAlign float32, colAlign float32)
	// SelectAll selects all the icons. @icon_view must has its selection mode
	// set to K_SELECTION_MULTIPLE.
	SelectAll()
	// SelectPath selects the row at @path.
	SelectPath(path *TreePath)
	// SelectedForeach calls a function for each selected icon. Note that the
	// model or selection cannot be modified from within this function.
	SelectedForeach()
	// SetActivateOnSingleClick causes the IconView::item-activated signal to be
	// emitted on a single click instead of a double click.
	SetActivateOnSingleClick(single bool)
	// SetColumnSpacing sets the ::column-spacing property which specifies the
	// space which is inserted between the columns of the icon view.
	SetColumnSpacing(columnSpacing int)
	// SetColumns sets the ::columns property which determines in how many
	// columns the icons are arranged. If @columns is -1, the number of columns
	// will be chosen automatically to fill the available area.
	SetColumns(columns int)
	// SetCursor sets the current keyboard focus to be at @path, and selects it.
	// This is useful when you want to focus the user’s attention on a
	// particular item. If @cell is not nil, then focus is given to the cell
	// specified by it. Additionally, if @start_editing is true, then editing
	// should be started in the specified cell.
	//
	// This function is often followed by `gtk_widget_grab_focus (icon_view)` in
	// order to give keyboard focus to the widget. Please note that editing can
	// only happen when the widget is realized.
	SetCursor(path *TreePath, cell CellRenderer, startEditing bool)
	// SetDragDestItem sets the item that is highlighted for feedback.
	SetDragDestItem(path *TreePath, pos IconViewDropPosition)
	// SetItemOrientation sets the ::item-orientation property which determines
	// whether the labels are drawn beside the icons instead of below.
	SetItemOrientation(orientation Orientation)
	// SetItemPadding sets the IconView:item-padding property which specifies
	// the padding around each of the icon view’s items.
	SetItemPadding(itemPadding int)
	// SetItemWidth sets the ::item-width property which specifies the width to
	// use for each item. If it is set to -1, the icon view will automatically
	// determine a suitable item size.
	SetItemWidth(itemWidth int)
	// SetMargin sets the ::margin property which specifies the space which is
	// inserted at the top, bottom, left and right of the icon view.
	SetMargin(margin int)
	// SetMarkupColumn sets the column with markup information for @icon_view to
	// be @column. The markup column must be of type TYPE_STRING. If the markup
	// column is set to something, it overrides the text column set by
	// gtk_icon_view_set_text_column().
	SetMarkupColumn(column int)
	// SetModel sets the model for a IconView. If the @icon_view already has a
	// model set, it will remove it before setting the new model. If @model is
	// nil, then it will unset the old model.
	SetModel(model TreeModel)
	// SetPixbufColumn sets the column with pixbufs for @icon_view to be
	// @column. The pixbuf column must be of type K_TYPE_PIXBUF
	SetPixbufColumn(column int)
	// SetReorderable: this function is a convenience function to allow you to
	// reorder models that support the TreeDragSourceIface and the
	// TreeDragDestIface. Both TreeStore and ListStore support these. If
	// @reorderable is true, then the user can reorder the model by dragging and
	// dropping rows. The developer can listen to these changes by connecting to
	// the model's row_inserted and row_deleted signals. The reordering is
	// implemented by setting up the icon view as a drag source and destination.
	// Therefore, drag and drop can not be used in a reorderable view for any
	// other purpose.
	//
	// This function does not give you any degree of control over the order --
	// any reordering is allowed. If more control is needed, you should probably
	// handle drag and drop manually.
	SetReorderable(reorderable bool)
	// SetRowSpacing sets the ::row-spacing property which specifies the space
	// which is inserted between the rows of the icon view.
	SetRowSpacing(rowSpacing int)
	// SetSelectionMode sets the selection mode of the @icon_view.
	SetSelectionMode(mode SelectionMode)
	// SetSpacing sets the ::spacing property which specifies the space which is
	// inserted between the cells (i.e. the icon and the text) of an item.
	SetSpacing(spacing int)
	// SetTextColumn sets the column with text for @icon_view to be @column. The
	// text column must be of type TYPE_STRING.
	SetTextColumn(column int)
	// SetTooltipCell sets the tip area of @tooltip to the area which @cell
	// occupies in the item pointed to by @path. See also
	// gtk_tooltip_set_tip_area().
	//
	// See also gtk_icon_view_set_tooltip_column() for a simpler alternative.
	SetTooltipCell(tooltip Tooltip, path *TreePath, cell CellRenderer)
	// SetTooltipColumn: if you only plan to have simple (text-only) tooltips on
	// full items, you can use this function to have IconView handle these
	// automatically for you. @column should be set to the column in
	// @icon_view’s model containing the tooltip texts, or -1 to disable this
	// feature.
	//
	// When enabled, Widget:has-tooltip will be set to true and @icon_view will
	// connect a Widget::query-tooltip signal handler.
	//
	// Note that the signal handler sets the text with gtk_tooltip_set_markup(),
	// so &, <, etc have to be escaped in the text.
	SetTooltipColumn(column int)
	// SetTooltipItem sets the tip area of @tooltip to be the area covered by
	// the item at @path. See also gtk_icon_view_set_tooltip_column() for a
	// simpler alternative. See also gtk_tooltip_set_tip_area().
	SetTooltipItem(tooltip Tooltip, path *TreePath)
	// UnselectAll unselects all the icons.
	UnselectAll()
	// UnselectPath unselects the row at @path.
	UnselectPath(path *TreePath)
	// UnsetModelDragDest undoes the effect of
	// gtk_icon_view_enable_model_drag_dest(). Calling this method sets
	// IconView:reorderable to false.
	UnsetModelDragDest()
	// UnsetModelDragSource undoes the effect of
	// gtk_icon_view_enable_model_drag_source(). Calling this method sets
	// IconView:reorderable to false.
	UnsetModelDragSource()
}

// iconView implements the IconView interface.
type iconView struct {
	Widget
	Accessible
	Buildable
	CellLayout
	ConstraintTarget
	Scrollable
}

var _ IconView = (*iconView)(nil)

// WrapIconView wraps a GObject to the right type. It is
// primarily used internally.
func WrapIconView(obj *externglib.Object) IconView {
	return IconView{
		Widget:           WrapWidget(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		CellLayout:       WrapCellLayout(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
		Scrollable:       WrapScrollable(obj),
	}
}

func marshalIconView(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapIconView(obj), nil
}

// NewIconView constructs a class IconView.
func NewIconView() IconView {
	var cret C.GtkIconView

	cret = C.gtk_icon_view_new()

	var iconView IconView

	iconView = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(IconView)

	return iconView
}

// NewIconViewWithArea constructs a class IconView.
func NewIconViewWithArea(area CellArea) IconView {
	var arg1 *C.GtkCellArea

	arg1 = (*C.GtkCellArea)(unsafe.Pointer(area.Native()))

	var cret C.GtkIconView

	cret = C.gtk_icon_view_new_with_area(arg1)

	var iconView IconView

	iconView = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(IconView)

	return iconView
}

// NewIconViewWithModel constructs a class IconView.
func NewIconViewWithModel(model TreeModel) IconView {
	var arg1 *C.GtkTreeModel

	arg1 = (*C.GtkTreeModel)(unsafe.Pointer(model.Native()))

	var cret C.GtkIconView

	cret = C.gtk_icon_view_new_with_model(arg1)

	var iconView IconView

	iconView = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(IconView)

	return iconView
}

// CreateDragIcon creates a #cairo_surface_t representation of the item at
// @path. This image is used for a drag icon.
func (i iconView) CreateDragIcon(path *TreePath) gdk.Paintable {
	var arg0 *C.GtkIconView
	var arg1 *C.GtkTreePath

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	var cret *C.GdkPaintable

	cret = C.gtk_icon_view_create_drag_icon(arg0, arg1)

	var paintable gdk.Paintable

	paintable = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(gdk.Paintable)

	return paintable
}

// EnableModelDragDest turns @icon_view into a drop destination for
// automatic DND. Calling this method sets IconView:reorderable to false.
func (i iconView) EnableModelDragDest(formats *gdk.ContentFormats, actions gdk.DragAction) {
	var arg0 *C.GtkIconView
	var arg1 *C.GdkContentFormats
	var arg2 C.GdkDragAction

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	arg1 = (*C.GdkContentFormats)(unsafe.Pointer(formats.Native()))
	arg2 = (C.GdkDragAction)(actions)

	C.gtk_icon_view_enable_model_drag_dest(arg0, arg1, arg2)
}

// EnableModelDragSource turns @icon_view into a drag source for automatic
// DND. Calling this method sets IconView:reorderable to false.
func (i iconView) EnableModelDragSource(startButtonMask gdk.ModifierType, formats *gdk.ContentFormats, actions gdk.DragAction) {
	var arg0 *C.GtkIconView
	var arg1 C.GdkModifierType
	var arg2 *C.GdkContentFormats
	var arg3 C.GdkDragAction

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	arg1 = (C.GdkModifierType)(startButtonMask)
	arg2 = (*C.GdkContentFormats)(unsafe.Pointer(formats.Native()))
	arg3 = (C.GdkDragAction)(actions)

	C.gtk_icon_view_enable_model_drag_source(arg0, arg1, arg2, arg3)
}

// ActivateOnSingleClick gets the setting set by
// gtk_icon_view_set_activate_on_single_click().
func (i iconView) ActivateOnSingleClick() bool {
	var arg0 *C.GtkIconView

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	var cret C.gboolean

	cret = C.gtk_icon_view_get_activate_on_single_click(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// CellRect fills the bounding rectangle in widget coordinates for the cell
// specified by @path and @cell. If @cell is nil the main cell area is used.
//
// This function is only valid if @icon_view is realized.
func (i iconView) CellRect(path *TreePath, cell CellRenderer) (rect gdk.Rectangle, ok bool) {
	var arg0 *C.GtkIconView
	var arg1 *C.GtkTreePath
	var arg2 *C.GtkCellRenderer

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
	arg2 = (*C.GtkCellRenderer)(unsafe.Pointer(cell.Native()))

	var rect gdk.Rectangle
	var cret C.gboolean

	cret = C.gtk_icon_view_get_cell_rect(arg0, arg1, arg2, (*C.GdkRectangle)(unsafe.Pointer(&rect)))

	var ok bool

	if cret {
		ok = true
	}

	return rect, ok
}

// ColumnSpacing returns the value of the ::column-spacing property.
func (i iconView) ColumnSpacing() int {
	var arg0 *C.GtkIconView

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	var cret C.int

	cret = C.gtk_icon_view_get_column_spacing(arg0)

	var gint int

	gint = (int)(cret)

	return gint
}

// Columns returns the value of the ::columns property.
func (i iconView) Columns() int {
	var arg0 *C.GtkIconView

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	var cret C.int

	cret = C.gtk_icon_view_get_columns(arg0)

	var gint int

	gint = (int)(cret)

	return gint
}

// Cursor fills in @path and @cell with the current cursor path and cell. If
// the cursor isn’t currently set, then *@path will be nil. If no cell
// currently has focus, then *@cell will be nil.
//
// The returned TreePath must be freed with gtk_tree_path_free().
func (i iconView) Cursor() (path *TreePath, cell CellRenderer, ok bool) {
	var arg0 *C.GtkIconView

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	var path *TreePath
	var arg2 **C.GtkCellRenderer
	var cret C.gboolean

	cret = C.gtk_icon_view_get_cursor(arg0, (**C.GtkTreePath)(unsafe.Pointer(&path)), arg2)

	var cell CellRenderer
	var ok bool

	cell = gextras.CastObject(externglib.Take(unsafe.Pointer(arg2.Native()))).(CellRenderer)
	if cret {
		ok = true
	}

	return path, cell, ok
}

// DestItemAtPos determines the destination item for a given position.
func (i iconView) DestItemAtPos(dragX int, dragY int) (path *TreePath, pos IconViewDropPosition, ok bool) {
	var arg0 *C.GtkIconView
	var arg1 C.int
	var arg2 C.int

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	arg1 = C.int(dragX)
	arg2 = C.int(dragY)

	var path *TreePath
	var arg4 C.GtkIconViewDropPosition
	var cret C.gboolean

	cret = C.gtk_icon_view_get_dest_item_at_pos(arg0, arg1, arg2, (**C.GtkTreePath)(unsafe.Pointer(&path)), &arg4)

	var pos IconViewDropPosition
	var ok bool

	pos = IconViewDropPosition(arg4)
	if cret {
		ok = true
	}

	return path, pos, ok
}

// DragDestItem gets information about the item that is highlighted for
// feedback.
func (i iconView) DragDestItem() (path *TreePath, pos IconViewDropPosition) {
	var arg0 *C.GtkIconView

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	var path *TreePath
	var arg2 C.GtkIconViewDropPosition

	C.gtk_icon_view_get_drag_dest_item(arg0, (**C.GtkTreePath)(unsafe.Pointer(&path)), &arg2)

	var pos IconViewDropPosition

	pos = IconViewDropPosition(arg2)

	return path, pos
}

// ItemAtPos gets the path and cell for the icon at the given position.
func (i iconView) ItemAtPos(x int, y int) (path *TreePath, cell CellRenderer, ok bool) {
	var arg0 *C.GtkIconView
	var arg1 C.int
	var arg2 C.int

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	arg1 = C.int(x)
	arg2 = C.int(y)

	var path *TreePath
	var arg4 **C.GtkCellRenderer
	var cret C.gboolean

	cret = C.gtk_icon_view_get_item_at_pos(arg0, arg1, arg2, (**C.GtkTreePath)(unsafe.Pointer(&path)), arg4)

	var cell CellRenderer
	var ok bool

	cell = gextras.CastObject(externglib.Take(unsafe.Pointer(arg4.Native()))).(CellRenderer)
	if cret {
		ok = true
	}

	return path, cell, ok
}

// ItemColumn gets the column in which the item @path is currently
// displayed. Column numbers start at 0.
func (i iconView) ItemColumn(path *TreePath) int {
	var arg0 *C.GtkIconView
	var arg1 *C.GtkTreePath

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	var cret C.int

	cret = C.gtk_icon_view_get_item_column(arg0, arg1)

	var gint int

	gint = (int)(cret)

	return gint
}

// ItemOrientation returns the value of the ::item-orientation property
// which determines whether the labels are drawn beside the icons instead of
// below.
func (i iconView) ItemOrientation() Orientation {
	var arg0 *C.GtkIconView

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	var cret C.GtkOrientation

	cret = C.gtk_icon_view_get_item_orientation(arg0)

	var orientation Orientation

	orientation = Orientation(cret)

	return orientation
}

// ItemPadding returns the value of the ::item-padding property.
func (i iconView) ItemPadding() int {
	var arg0 *C.GtkIconView

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	var cret C.int

	cret = C.gtk_icon_view_get_item_padding(arg0)

	var gint int

	gint = (int)(cret)

	return gint
}

// ItemRow gets the row in which the item @path is currently displayed. Row
// numbers start at 0.
func (i iconView) ItemRow(path *TreePath) int {
	var arg0 *C.GtkIconView
	var arg1 *C.GtkTreePath

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	var cret C.int

	cret = C.gtk_icon_view_get_item_row(arg0, arg1)

	var gint int

	gint = (int)(cret)

	return gint
}

// ItemWidth returns the value of the ::item-width property.
func (i iconView) ItemWidth() int {
	var arg0 *C.GtkIconView

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	var cret C.int

	cret = C.gtk_icon_view_get_item_width(arg0)

	var gint int

	gint = (int)(cret)

	return gint
}

// Margin returns the value of the ::margin property.
func (i iconView) Margin() int {
	var arg0 *C.GtkIconView

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	var cret C.int

	cret = C.gtk_icon_view_get_margin(arg0)

	var gint int

	gint = (int)(cret)

	return gint
}

// MarkupColumn returns the column with markup text for @icon_view.
func (i iconView) MarkupColumn() int {
	var arg0 *C.GtkIconView

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	var cret C.int

	cret = C.gtk_icon_view_get_markup_column(arg0)

	var gint int

	gint = (int)(cret)

	return gint
}

// Model returns the model the IconView is based on. Returns nil if the
// model is unset.
func (i iconView) Model() TreeModel {
	var arg0 *C.GtkIconView

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	var cret *C.GtkTreeModel

	cret = C.gtk_icon_view_get_model(arg0)

	var treeModel TreeModel

	treeModel = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(TreeModel)

	return treeModel
}

// PathAtPos gets the path for the icon at the given position.
func (i iconView) PathAtPos(x int, y int) *TreePath {
	var arg0 *C.GtkIconView
	var arg1 C.int
	var arg2 C.int

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	arg1 = C.int(x)
	arg2 = C.int(y)

	var cret *C.GtkTreePath

	cret = C.gtk_icon_view_get_path_at_pos(arg0, arg1, arg2)

	var treePath *TreePath

	treePath = WrapTreePath(unsafe.Pointer(cret))
	runtime.SetFinalizer(treePath, func(v *TreePath) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return treePath
}

// PixbufColumn returns the column with pixbufs for @icon_view.
func (i iconView) PixbufColumn() int {
	var arg0 *C.GtkIconView

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	var cret C.int

	cret = C.gtk_icon_view_get_pixbuf_column(arg0)

	var gint int

	gint = (int)(cret)

	return gint
}

// Reorderable retrieves whether the user can reorder the list via
// drag-and-drop. See gtk_icon_view_set_reorderable().
func (i iconView) Reorderable() bool {
	var arg0 *C.GtkIconView

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	var cret C.gboolean

	cret = C.gtk_icon_view_get_reorderable(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// RowSpacing returns the value of the ::row-spacing property.
func (i iconView) RowSpacing() int {
	var arg0 *C.GtkIconView

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	var cret C.int

	cret = C.gtk_icon_view_get_row_spacing(arg0)

	var gint int

	gint = (int)(cret)

	return gint
}

// SelectedItems creates a list of paths of all selected items.
// Additionally, if you are planning on modifying the model after calling
// this function, you may want to convert the returned list into a list of
// TreeRowReferences. To do this, you can use gtk_tree_row_reference_new().
//
// To free the return value, use:
//
//    g_list_free_full (list, (GDestroyNotify) gtk_tree_path_free);
func (i iconView) SelectedItems() *glib.List {
	var arg0 *C.GtkIconView

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	var cret *C.GList

	cret = C.gtk_icon_view_get_selected_items(arg0)

	var list *glib.List

	list = glib.WrapList(unsafe.Pointer(cret))
	runtime.SetFinalizer(list, func(v *glib.List) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return list
}

// SelectionMode gets the selection mode of the @icon_view.
func (i iconView) SelectionMode() SelectionMode {
	var arg0 *C.GtkIconView

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	var cret C.GtkSelectionMode

	cret = C.gtk_icon_view_get_selection_mode(arg0)

	var selectionMode SelectionMode

	selectionMode = SelectionMode(cret)

	return selectionMode
}

// Spacing returns the value of the ::spacing property.
func (i iconView) Spacing() int {
	var arg0 *C.GtkIconView

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	var cret C.int

	cret = C.gtk_icon_view_get_spacing(arg0)

	var gint int

	gint = (int)(cret)

	return gint
}

// TextColumn returns the column with text for @icon_view.
func (i iconView) TextColumn() int {
	var arg0 *C.GtkIconView

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	var cret C.int

	cret = C.gtk_icon_view_get_text_column(arg0)

	var gint int

	gint = (int)(cret)

	return gint
}

// TooltipColumn returns the column of @icon_view’s model which is being
// used for displaying tooltips on @icon_view’s rows.
func (i iconView) TooltipColumn() int {
	var arg0 *C.GtkIconView

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	var cret C.int

	cret = C.gtk_icon_view_get_tooltip_column(arg0)

	var gint int

	gint = (int)(cret)

	return gint
}

// TooltipContext: this function is supposed to be used in a
// Widget::query-tooltip signal handler for IconView. The @x, @y and
// @keyboard_tip values which are received in the signal handler, should be
// passed to this function without modification.
//
// The return value indicates whether there is an icon view item at the
// given coordinates (true) or not (false) for mouse tooltips. For keyboard
// tooltips the item returned will be the cursor item. When true, then any
// of @model, @path and @iter which have been provided will be set to point
// to that row and the corresponding model.
func (i iconView) TooltipContext(x int, y int, keyboardTip bool) (model TreeModel, path *TreePath, iter TreeIter, ok bool) {
	var arg0 *C.GtkIconView
	var arg1 C.int
	var arg2 C.int
	var arg3 C.gboolean

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	arg1 = C.int(x)
	arg2 = C.int(y)
	if keyboardTip {
		arg3 = C.gboolean(1)
	}

	var arg4 **C.GtkTreeModel
	var path *TreePath
	var iter TreeIter
	var cret C.gboolean

	cret = C.gtk_icon_view_get_tooltip_context(arg0, arg1, arg2, arg3, arg4, (**C.GtkTreePath)(unsafe.Pointer(&path)), (*C.GtkTreeIter)(unsafe.Pointer(&iter)))

	var model TreeModel

	var ok bool

	model = gextras.CastObject(externglib.Take(unsafe.Pointer(arg4.Native()))).(TreeModel)

	if cret {
		ok = true
	}

	return model, path, iter, ok
}

// VisibleRange sets @start_path and @end_path to be the first and last
// visible path. Note that there may be invisible paths in between.
//
// Both paths should be freed with gtk_tree_path_free() after use.
func (i iconView) VisibleRange() (startPath *TreePath, endPath *TreePath, ok bool) {
	var arg0 *C.GtkIconView

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	var startPath *TreePath
	var endPath *TreePath
	var cret C.gboolean

	cret = C.gtk_icon_view_get_visible_range(arg0, (**C.GtkTreePath)(unsafe.Pointer(&startPath)), (**C.GtkTreePath)(unsafe.Pointer(&endPath)))

	var ok bool

	if cret {
		ok = true
	}

	return startPath, endPath, ok
}

// ItemActivated activates the item determined by @path.
func (i iconView) ItemActivated(path *TreePath) {
	var arg0 *C.GtkIconView
	var arg1 *C.GtkTreePath

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	C.gtk_icon_view_item_activated(arg0, arg1)
}

// PathIsSelected returns true if the icon pointed to by @path is currently
// selected. If @path does not point to a valid location, false is returned.
func (i iconView) PathIsSelected(path *TreePath) bool {
	var arg0 *C.GtkIconView
	var arg1 *C.GtkTreePath

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	var cret C.gboolean

	cret = C.gtk_icon_view_path_is_selected(arg0, arg1)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// ScrollToPath moves the alignments of @icon_view to the position specified
// by @path. @row_align determines where the row is placed, and @col_align
// determines where @column is placed. Both are expected to be between 0.0
// and 1.0. 0.0 means left/top alignment, 1.0 means right/bottom alignment,
// 0.5 means center.
//
// If @use_align is false, then the alignment arguments are ignored, and the
// tree does the minimum amount of work to scroll the item onto the screen.
// This means that the item will be scrolled to the edge closest to its
// current position. If the item is currently visible on the screen, nothing
// is done.
//
// This function only works if the model is set, and @path is a valid row on
// the model. If the model changes before the @icon_view is realized, the
// centered path will be modified to reflect this change.
func (i iconView) ScrollToPath(path *TreePath, useAlign bool, rowAlign float32, colAlign float32) {
	var arg0 *C.GtkIconView
	var arg1 *C.GtkTreePath
	var arg2 C.gboolean
	var arg3 C.float
	var arg4 C.float

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
	if useAlign {
		arg2 = C.gboolean(1)
	}
	arg3 = C.float(rowAlign)
	arg4 = C.float(colAlign)

	C.gtk_icon_view_scroll_to_path(arg0, arg1, arg2, arg3, arg4)
}

// SelectAll selects all the icons. @icon_view must has its selection mode
// set to K_SELECTION_MULTIPLE.
func (i iconView) SelectAll() {
	var arg0 *C.GtkIconView

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	C.gtk_icon_view_select_all(arg0)
}

// SelectPath selects the row at @path.
func (i iconView) SelectPath(path *TreePath) {
	var arg0 *C.GtkIconView
	var arg1 *C.GtkTreePath

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	C.gtk_icon_view_select_path(arg0, arg1)
}

// SelectedForeach calls a function for each selected icon. Note that the
// model or selection cannot be modified from within this function.
func (i iconView) SelectedForeach() {
	var arg0 *C.GtkIconView

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	C.gtk_icon_view_selected_foreach(arg0)
}

// SetActivateOnSingleClick causes the IconView::item-activated signal to be
// emitted on a single click instead of a double click.
func (i iconView) SetActivateOnSingleClick(single bool) {
	var arg0 *C.GtkIconView
	var arg1 C.gboolean

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	if single {
		arg1 = C.gboolean(1)
	}

	C.gtk_icon_view_set_activate_on_single_click(arg0, arg1)
}

// SetColumnSpacing sets the ::column-spacing property which specifies the
// space which is inserted between the columns of the icon view.
func (i iconView) SetColumnSpacing(columnSpacing int) {
	var arg0 *C.GtkIconView
	var arg1 C.int

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	arg1 = C.int(columnSpacing)

	C.gtk_icon_view_set_column_spacing(arg0, arg1)
}

// SetColumns sets the ::columns property which determines in how many
// columns the icons are arranged. If @columns is -1, the number of columns
// will be chosen automatically to fill the available area.
func (i iconView) SetColumns(columns int) {
	var arg0 *C.GtkIconView
	var arg1 C.int

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	arg1 = C.int(columns)

	C.gtk_icon_view_set_columns(arg0, arg1)
}

// SetCursor sets the current keyboard focus to be at @path, and selects it.
// This is useful when you want to focus the user’s attention on a
// particular item. If @cell is not nil, then focus is given to the cell
// specified by it. Additionally, if @start_editing is true, then editing
// should be started in the specified cell.
//
// This function is often followed by `gtk_widget_grab_focus (icon_view)` in
// order to give keyboard focus to the widget. Please note that editing can
// only happen when the widget is realized.
func (i iconView) SetCursor(path *TreePath, cell CellRenderer, startEditing bool) {
	var arg0 *C.GtkIconView
	var arg1 *C.GtkTreePath
	var arg2 *C.GtkCellRenderer
	var arg3 C.gboolean

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
	arg2 = (*C.GtkCellRenderer)(unsafe.Pointer(cell.Native()))
	if startEditing {
		arg3 = C.gboolean(1)
	}

	C.gtk_icon_view_set_cursor(arg0, arg1, arg2, arg3)
}

// SetDragDestItem sets the item that is highlighted for feedback.
func (i iconView) SetDragDestItem(path *TreePath, pos IconViewDropPosition) {
	var arg0 *C.GtkIconView
	var arg1 *C.GtkTreePath
	var arg2 C.GtkIconViewDropPosition

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
	arg2 = (C.GtkIconViewDropPosition)(pos)

	C.gtk_icon_view_set_drag_dest_item(arg0, arg1, arg2)
}

// SetItemOrientation sets the ::item-orientation property which determines
// whether the labels are drawn beside the icons instead of below.
func (i iconView) SetItemOrientation(orientation Orientation) {
	var arg0 *C.GtkIconView
	var arg1 C.GtkOrientation

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	arg1 = (C.GtkOrientation)(orientation)

	C.gtk_icon_view_set_item_orientation(arg0, arg1)
}

// SetItemPadding sets the IconView:item-padding property which specifies
// the padding around each of the icon view’s items.
func (i iconView) SetItemPadding(itemPadding int) {
	var arg0 *C.GtkIconView
	var arg1 C.int

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	arg1 = C.int(itemPadding)

	C.gtk_icon_view_set_item_padding(arg0, arg1)
}

// SetItemWidth sets the ::item-width property which specifies the width to
// use for each item. If it is set to -1, the icon view will automatically
// determine a suitable item size.
func (i iconView) SetItemWidth(itemWidth int) {
	var arg0 *C.GtkIconView
	var arg1 C.int

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	arg1 = C.int(itemWidth)

	C.gtk_icon_view_set_item_width(arg0, arg1)
}

// SetMargin sets the ::margin property which specifies the space which is
// inserted at the top, bottom, left and right of the icon view.
func (i iconView) SetMargin(margin int) {
	var arg0 *C.GtkIconView
	var arg1 C.int

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	arg1 = C.int(margin)

	C.gtk_icon_view_set_margin(arg0, arg1)
}

// SetMarkupColumn sets the column with markup information for @icon_view to
// be @column. The markup column must be of type TYPE_STRING. If the markup
// column is set to something, it overrides the text column set by
// gtk_icon_view_set_text_column().
func (i iconView) SetMarkupColumn(column int) {
	var arg0 *C.GtkIconView
	var arg1 C.int

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	arg1 = C.int(column)

	C.gtk_icon_view_set_markup_column(arg0, arg1)
}

// SetModel sets the model for a IconView. If the @icon_view already has a
// model set, it will remove it before setting the new model. If @model is
// nil, then it will unset the old model.
func (i iconView) SetModel(model TreeModel) {
	var arg0 *C.GtkIconView
	var arg1 *C.GtkTreeModel

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	arg1 = (*C.GtkTreeModel)(unsafe.Pointer(model.Native()))

	C.gtk_icon_view_set_model(arg0, arg1)
}

// SetPixbufColumn sets the column with pixbufs for @icon_view to be
// @column. The pixbuf column must be of type K_TYPE_PIXBUF
func (i iconView) SetPixbufColumn(column int) {
	var arg0 *C.GtkIconView
	var arg1 C.int

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	arg1 = C.int(column)

	C.gtk_icon_view_set_pixbuf_column(arg0, arg1)
}

// SetReorderable: this function is a convenience function to allow you to
// reorder models that support the TreeDragSourceIface and the
// TreeDragDestIface. Both TreeStore and ListStore support these. If
// @reorderable is true, then the user can reorder the model by dragging and
// dropping rows. The developer can listen to these changes by connecting to
// the model's row_inserted and row_deleted signals. The reordering is
// implemented by setting up the icon view as a drag source and destination.
// Therefore, drag and drop can not be used in a reorderable view for any
// other purpose.
//
// This function does not give you any degree of control over the order --
// any reordering is allowed. If more control is needed, you should probably
// handle drag and drop manually.
func (i iconView) SetReorderable(reorderable bool) {
	var arg0 *C.GtkIconView
	var arg1 C.gboolean

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	if reorderable {
		arg1 = C.gboolean(1)
	}

	C.gtk_icon_view_set_reorderable(arg0, arg1)
}

// SetRowSpacing sets the ::row-spacing property which specifies the space
// which is inserted between the rows of the icon view.
func (i iconView) SetRowSpacing(rowSpacing int) {
	var arg0 *C.GtkIconView
	var arg1 C.int

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	arg1 = C.int(rowSpacing)

	C.gtk_icon_view_set_row_spacing(arg0, arg1)
}

// SetSelectionMode sets the selection mode of the @icon_view.
func (i iconView) SetSelectionMode(mode SelectionMode) {
	var arg0 *C.GtkIconView
	var arg1 C.GtkSelectionMode

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	arg1 = (C.GtkSelectionMode)(mode)

	C.gtk_icon_view_set_selection_mode(arg0, arg1)
}

// SetSpacing sets the ::spacing property which specifies the space which is
// inserted between the cells (i.e. the icon and the text) of an item.
func (i iconView) SetSpacing(spacing int) {
	var arg0 *C.GtkIconView
	var arg1 C.int

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	arg1 = C.int(spacing)

	C.gtk_icon_view_set_spacing(arg0, arg1)
}

// SetTextColumn sets the column with text for @icon_view to be @column. The
// text column must be of type TYPE_STRING.
func (i iconView) SetTextColumn(column int) {
	var arg0 *C.GtkIconView
	var arg1 C.int

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	arg1 = C.int(column)

	C.gtk_icon_view_set_text_column(arg0, arg1)
}

// SetTooltipCell sets the tip area of @tooltip to the area which @cell
// occupies in the item pointed to by @path. See also
// gtk_tooltip_set_tip_area().
//
// See also gtk_icon_view_set_tooltip_column() for a simpler alternative.
func (i iconView) SetTooltipCell(tooltip Tooltip, path *TreePath, cell CellRenderer) {
	var arg0 *C.GtkIconView
	var arg1 *C.GtkTooltip
	var arg2 *C.GtkTreePath
	var arg3 *C.GtkCellRenderer

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	arg1 = (*C.GtkTooltip)(unsafe.Pointer(tooltip.Native()))
	arg2 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
	arg3 = (*C.GtkCellRenderer)(unsafe.Pointer(cell.Native()))

	C.gtk_icon_view_set_tooltip_cell(arg0, arg1, arg2, arg3)
}

// SetTooltipColumn: if you only plan to have simple (text-only) tooltips on
// full items, you can use this function to have IconView handle these
// automatically for you. @column should be set to the column in
// @icon_view’s model containing the tooltip texts, or -1 to disable this
// feature.
//
// When enabled, Widget:has-tooltip will be set to true and @icon_view will
// connect a Widget::query-tooltip signal handler.
//
// Note that the signal handler sets the text with gtk_tooltip_set_markup(),
// so &, <, etc have to be escaped in the text.
func (i iconView) SetTooltipColumn(column int) {
	var arg0 *C.GtkIconView
	var arg1 C.int

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	arg1 = C.int(column)

	C.gtk_icon_view_set_tooltip_column(arg0, arg1)
}

// SetTooltipItem sets the tip area of @tooltip to be the area covered by
// the item at @path. See also gtk_icon_view_set_tooltip_column() for a
// simpler alternative. See also gtk_tooltip_set_tip_area().
func (i iconView) SetTooltipItem(tooltip Tooltip, path *TreePath) {
	var arg0 *C.GtkIconView
	var arg1 *C.GtkTooltip
	var arg2 *C.GtkTreePath

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	arg1 = (*C.GtkTooltip)(unsafe.Pointer(tooltip.Native()))
	arg2 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	C.gtk_icon_view_set_tooltip_item(arg0, arg1, arg2)
}

// UnselectAll unselects all the icons.
func (i iconView) UnselectAll() {
	var arg0 *C.GtkIconView

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	C.gtk_icon_view_unselect_all(arg0)
}

// UnselectPath unselects the row at @path.
func (i iconView) UnselectPath(path *TreePath) {
	var arg0 *C.GtkIconView
	var arg1 *C.GtkTreePath

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
	arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	C.gtk_icon_view_unselect_path(arg0, arg1)
}

// UnsetModelDragDest undoes the effect of
// gtk_icon_view_enable_model_drag_dest(). Calling this method sets
// IconView:reorderable to false.
func (i iconView) UnsetModelDragDest() {
	var arg0 *C.GtkIconView

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	C.gtk_icon_view_unset_model_drag_dest(arg0)
}

// UnsetModelDragSource undoes the effect of
// gtk_icon_view_enable_model_drag_source(). Calling this method sets
// IconView:reorderable to false.
func (i iconView) UnsetModelDragSource() {
	var arg0 *C.GtkIconView

	arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

	C.gtk_icon_view_unset_model_drag_source(arg0)
}

// Image: the Image widget displays an image. Various kinds of object can be
// displayed as an image; most typically, you would load a Texture from a file,
// and then display that. There’s a convenience function to do this,
// gtk_image_new_from_file(), used as follows:
//
//    GtkWidget *image;
//    image = gtk_image_new_from_file ("myfile.png");
//
// If the file isn’t loaded successfully, the image will contain a “broken
// image” icon similar to that used in many web browsers. If you want to handle
// errors in loading the file yourself, for example by displaying an error
// message, then load the image with gdk_texture_new_from_file(), then create
// the Image with gtk_image_new_from_paintable().
//
// Sometimes an application will want to avoid depending on external data files,
// such as image files. See the documentation of #GResource for details. In this
// case, the Image:resource, gtk_image_new_from_resource() and
// gtk_image_set_from_resource() should be used.
//
// GtkImage displays its image as an icon, with a size that is determined by the
// application. See Picture if you want to show an image at is actual size.
//
//
// CSS nodes
//
// GtkImage has a single CSS node with the name image. The style classes
// .normal-icons or .large-icons may appear, depending on the Image:icon-size
// property.
//
//
// Accessibility
//
// GtkImage uses the K_ACCESSIBLE_ROLE_IMG role.
type Image interface {
	Widget
	Accessible
	Buildable
	ConstraintTarget

	// Clear resets the image to be empty.
	Clear()
	// GIcon gets the #GIcon and size being displayed by the Image. The storage
	// type of the image must be GTK_IMAGE_EMPTY or GTK_IMAGE_GICON (see
	// gtk_image_get_storage_type()). The caller of this function does not own a
	// reference to the returned #GIcon.
	//
	// Note: This function was changed in 3.94 not to use out parameters
	// anymore, but return the GIcon directly. See gtk_image_get_icon_size() for
	// a way to get the icon size.
	GIcon() gio.Icon
	// IconName gets the icon name and size being displayed by the Image. The
	// storage type of the image must be GTK_IMAGE_EMPTY or GTK_IMAGE_ICON_NAME
	// (see gtk_image_get_storage_type()). The returned string is owned by the
	// Image and should not be freed.
	//
	// Note: This function was changed in 3.94 not to use out parameters
	// anymore, but return the icon name directly. See gtk_image_get_icon_size()
	// for a way to get the icon size.
	IconName() string
	// IconSize gets the icon size used by the @image when rendering icons.
	IconSize() IconSize
	// Paintable gets the image Paintable being displayed by the Image. The
	// storage type of the image must be GTK_IMAGE_EMPTY or GTK_IMAGE_PAINTABLE
	// (see gtk_image_get_storage_type()). The caller of this function does not
	// own a reference to the returned paintable.
	Paintable() gdk.Paintable
	// PixelSize gets the pixel size used for named icons.
	PixelSize() int
	// StorageType gets the type of representation being used by the Image to
	// store image data. If the Image has no image data, the return value will
	// be GTK_IMAGE_EMPTY.
	StorageType() ImageType
	// SetFromFile: see gtk_image_new_from_file() for details.
	SetFromFile(filename *string)
	// SetFromGIcon: see gtk_image_new_from_gicon() for details.
	//
	// Note: Before 3.94, this function was taking an extra icon size argument.
	// See gtk_image_set_icon_size() for another way to set the icon size.
	SetFromGIcon(icon gio.Icon)
	// SetFromIconName: see gtk_image_new_from_icon_name() for details.
	//
	// Note: Before 3.94, this function was taking an extra icon size argument.
	// See gtk_image_set_icon_size() for another way to set the icon size.
	SetFromIconName(iconName string)
	// SetFromPaintable: see gtk_image_new_from_paintable() for details.
	SetFromPaintable(paintable gdk.Paintable)
	// SetFromPixbuf: see gtk_image_new_from_pixbuf() for details.
	//
	// Note: This is a helper for gtk_image_set_from_paintable(), and you can't
	// get back the exact pixbuf once this is called, only a paintable.
	SetFromPixbuf(pixbuf gdkpixbuf.Pixbuf)
	// SetFromResource: see gtk_image_new_from_resource() for details.
	SetFromResource(resourcePath string)
	// SetIconSize suggests an icon size to the theme for named icons.
	SetIconSize(iconSize IconSize)
	// SetPixelSize sets the pixel size to use for named icons. If the pixel
	// size is set to a value != -1, it is used instead of the icon size set by
	// gtk_image_set_from_icon_name().
	SetPixelSize(pixelSize int)
}

// image implements the Image interface.
type image struct {
	Widget
	Accessible
	Buildable
	ConstraintTarget
}

var _ Image = (*image)(nil)

// WrapImage wraps a GObject to the right type. It is
// primarily used internally.
func WrapImage(obj *externglib.Object) Image {
	return Image{
		Widget:           WrapWidget(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
	}
}

func marshalImage(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapImage(obj), nil
}

// NewImage constructs a class Image.
func NewImage() Image {
	var cret C.GtkImage

	cret = C.gtk_image_new()

	var image Image

	image = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Image)

	return image
}

// NewImageFromFile constructs a class Image.
func NewImageFromFile(filename *string) Image {
	var arg1 *C.char

	arg1 = (*C.char)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))

	var cret C.GtkImage

	cret = C.gtk_image_new_from_file(arg1)

	var image Image

	image = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Image)

	return image
}

// NewImageFromGIcon constructs a class Image.
func NewImageFromGIcon(icon gio.Icon) Image {
	var arg1 *C.GIcon

	arg1 = (*C.GIcon)(unsafe.Pointer(icon.Native()))

	var cret C.GtkImage

	cret = C.gtk_image_new_from_gicon(arg1)

	var image Image

	image = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Image)

	return image
}

// NewImageFromIconName constructs a class Image.
func NewImageFromIconName(iconName string) Image {
	var arg1 *C.char

	arg1 = (*C.char)(C.CString(iconName))
	defer C.free(unsafe.Pointer(arg1))

	var cret C.GtkImage

	cret = C.gtk_image_new_from_icon_name(arg1)

	var image Image

	image = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Image)

	return image
}

// NewImageFromPaintable constructs a class Image.
func NewImageFromPaintable(paintable gdk.Paintable) Image {
	var arg1 *C.GdkPaintable

	arg1 = (*C.GdkPaintable)(unsafe.Pointer(paintable.Native()))

	var cret C.GtkImage

	cret = C.gtk_image_new_from_paintable(arg1)

	var image Image

	image = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Image)

	return image
}

// NewImageFromPixbuf constructs a class Image.
func NewImageFromPixbuf(pixbuf gdkpixbuf.Pixbuf) Image {
	var arg1 *C.GdkPixbuf

	arg1 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))

	var cret C.GtkImage

	cret = C.gtk_image_new_from_pixbuf(arg1)

	var image Image

	image = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Image)

	return image
}

// NewImageFromResource constructs a class Image.
func NewImageFromResource(resourcePath string) Image {
	var arg1 *C.char

	arg1 = (*C.char)(C.CString(resourcePath))
	defer C.free(unsafe.Pointer(arg1))

	var cret C.GtkImage

	cret = C.gtk_image_new_from_resource(arg1)

	var image Image

	image = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Image)

	return image
}

// Clear resets the image to be empty.
func (i image) Clear() {
	var arg0 *C.GtkImage

	arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))

	C.gtk_image_clear(arg0)
}

// GIcon gets the #GIcon and size being displayed by the Image. The storage
// type of the image must be GTK_IMAGE_EMPTY or GTK_IMAGE_GICON (see
// gtk_image_get_storage_type()). The caller of this function does not own a
// reference to the returned #GIcon.
//
// Note: This function was changed in 3.94 not to use out parameters
// anymore, but return the GIcon directly. See gtk_image_get_icon_size() for
// a way to get the icon size.
func (i image) GIcon() gio.Icon {
	var arg0 *C.GtkImage

	arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))

	var cret *C.GIcon

	cret = C.gtk_image_get_gicon(arg0)

	var icon gio.Icon

	icon = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(gio.Icon)

	return icon
}

// IconName gets the icon name and size being displayed by the Image. The
// storage type of the image must be GTK_IMAGE_EMPTY or GTK_IMAGE_ICON_NAME
// (see gtk_image_get_storage_type()). The returned string is owned by the
// Image and should not be freed.
//
// Note: This function was changed in 3.94 not to use out parameters
// anymore, but return the icon name directly. See gtk_image_get_icon_size()
// for a way to get the icon size.
func (i image) IconName() string {
	var arg0 *C.GtkImage

	arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))

	var cret *C.char

	cret = C.gtk_image_get_icon_name(arg0)

	var utf8 string

	utf8 = C.GoString(cret)

	return utf8
}

// IconSize gets the icon size used by the @image when rendering icons.
func (i image) IconSize() IconSize {
	var arg0 *C.GtkImage

	arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))

	var cret C.GtkIconSize

	cret = C.gtk_image_get_icon_size(arg0)

	var iconSize IconSize

	iconSize = IconSize(cret)

	return iconSize
}

// Paintable gets the image Paintable being displayed by the Image. The
// storage type of the image must be GTK_IMAGE_EMPTY or GTK_IMAGE_PAINTABLE
// (see gtk_image_get_storage_type()). The caller of this function does not
// own a reference to the returned paintable.
func (i image) Paintable() gdk.Paintable {
	var arg0 *C.GtkImage

	arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))

	var cret *C.GdkPaintable

	cret = C.gtk_image_get_paintable(arg0)

	var paintable gdk.Paintable

	paintable = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(gdk.Paintable)

	return paintable
}

// PixelSize gets the pixel size used for named icons.
func (i image) PixelSize() int {
	var arg0 *C.GtkImage

	arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))

	var cret C.int

	cret = C.gtk_image_get_pixel_size(arg0)

	var gint int

	gint = (int)(cret)

	return gint
}

// StorageType gets the type of representation being used by the Image to
// store image data. If the Image has no image data, the return value will
// be GTK_IMAGE_EMPTY.
func (i image) StorageType() ImageType {
	var arg0 *C.GtkImage

	arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))

	var cret C.GtkImageType

	cret = C.gtk_image_get_storage_type(arg0)

	var imageType ImageType

	imageType = ImageType(cret)

	return imageType
}

// SetFromFile: see gtk_image_new_from_file() for details.
func (i image) SetFromFile(filename *string) {
	var arg0 *C.GtkImage
	var arg1 *C.char

	arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))
	arg1 = (*C.char)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_image_set_from_file(arg0, arg1)
}

// SetFromGIcon: see gtk_image_new_from_gicon() for details.
//
// Note: Before 3.94, this function was taking an extra icon size argument.
// See gtk_image_set_icon_size() for another way to set the icon size.
func (i image) SetFromGIcon(icon gio.Icon) {
	var arg0 *C.GtkImage
	var arg1 *C.GIcon

	arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))
	arg1 = (*C.GIcon)(unsafe.Pointer(icon.Native()))

	C.gtk_image_set_from_gicon(arg0, arg1)
}

// SetFromIconName: see gtk_image_new_from_icon_name() for details.
//
// Note: Before 3.94, this function was taking an extra icon size argument.
// See gtk_image_set_icon_size() for another way to set the icon size.
func (i image) SetFromIconName(iconName string) {
	var arg0 *C.GtkImage
	var arg1 *C.char

	arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))
	arg1 = (*C.char)(C.CString(iconName))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_image_set_from_icon_name(arg0, arg1)
}

// SetFromPaintable: see gtk_image_new_from_paintable() for details.
func (i image) SetFromPaintable(paintable gdk.Paintable) {
	var arg0 *C.GtkImage
	var arg1 *C.GdkPaintable

	arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))
	arg1 = (*C.GdkPaintable)(unsafe.Pointer(paintable.Native()))

	C.gtk_image_set_from_paintable(arg0, arg1)
}

// SetFromPixbuf: see gtk_image_new_from_pixbuf() for details.
//
// Note: This is a helper for gtk_image_set_from_paintable(), and you can't
// get back the exact pixbuf once this is called, only a paintable.
func (i image) SetFromPixbuf(pixbuf gdkpixbuf.Pixbuf) {
	var arg0 *C.GtkImage
	var arg1 *C.GdkPixbuf

	arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))
	arg1 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))

	C.gtk_image_set_from_pixbuf(arg0, arg1)
}

// SetFromResource: see gtk_image_new_from_resource() for details.
func (i image) SetFromResource(resourcePath string) {
	var arg0 *C.GtkImage
	var arg1 *C.char

	arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))
	arg1 = (*C.char)(C.CString(resourcePath))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_image_set_from_resource(arg0, arg1)
}

// SetIconSize suggests an icon size to the theme for named icons.
func (i image) SetIconSize(iconSize IconSize) {
	var arg0 *C.GtkImage
	var arg1 C.GtkIconSize

	arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))
	arg1 = (C.GtkIconSize)(iconSize)

	C.gtk_image_set_icon_size(arg0, arg1)
}

// SetPixelSize sets the pixel size to use for named icons. If the pixel
// size is set to a value != -1, it is used instead of the icon size set by
// gtk_image_set_from_icon_name().
func (i image) SetPixelSize(pixelSize int) {
	var arg0 *C.GtkImage
	var arg1 C.int

	arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))
	arg1 = C.int(pixelSize)

	C.gtk_image_set_pixel_size(arg0, arg1)
}

// InfoBar is a widget that can be used to show messages to the user without
// showing a dialog. It is often temporarily shown at the top or bottom of a
// document. In contrast to Dialog, which has an action area at the bottom,
// InfoBar has an action area at the side.
//
// The API of InfoBar is very similar to Dialog, allowing you to add buttons to
// the action area with gtk_info_bar_add_button() or
// gtk_info_bar_new_with_buttons(). The sensitivity of action widgets can be
// controlled with gtk_info_bar_set_response_sensitive().
//
// To add widgets to the main content area of a InfoBar, use
// gtk_info_bar_add_child().
//
// Similar to MessageDialog, the contents of a InfoBar can by classified as
// error message, warning, informational message, etc, by using
// gtk_info_bar_set_message_type(). GTK may use the message type to determine
// how the message is displayed.
//
// A simple example for using a InfoBar:
//
//    GtkWidget *message_label;
//    GtkWidget *widget;
//    GtkWidget *grid;
//    GtkInfoBar *bar;
//
//    // set up info bar
//    widget = gtk_info_bar_new ();
//    bar = GTK_INFO_BAR (widget);
//    grid = gtk_grid_new ();
//
//    message_label = gtk_label_new ("");
//    gtk_info_bar_add_child (bar, message_label);
//    gtk_info_bar_add_button (bar,
//                             _("_OK"),
//                             GTK_RESPONSE_OK);
//    g_signal_connect (bar,
//                      "response",
//                      G_CALLBACK (gtk_widget_hide),
//                      NULL);
//    gtk_grid_attach (GTK_GRID (grid),
//                     widget,
//                     0, 2, 1, 1);
//
//    // ...
//
//    // show an error message
//    gtk_label_set_text (GTK_LABEL (message_label), "An error occurred!");
//    gtk_info_bar_set_message_type (bar, GTK_MESSAGE_ERROR);
//    gtk_widget_show (bar);
//
//
// GtkInfoBar as GtkBuildable
//
// The GtkInfoBar implementation of the GtkBuildable interface exposes the
// content area and action area as internal children with the names
// “content_area” and “action_area”.
//
// GtkInfoBar supports a custom <action-widgets> element, which can contain
// multiple <action-widget> elements. The “response” attribute specifies a
// numeric response, and the content of the element is the id of widget (which
// should be a child of the dialogs @action_area).
//
//
// CSS nodes
//
// GtkInfoBar has a single CSS node with name infobar. The node may get one of
// the style classes .info, .warning, .error or .question, depending on the
// message type. If the info bar shows a close button, that button will have the
// .close style class applied.
type InfoBar interface {
	Widget
	Accessible
	Buildable
	ConstraintTarget

	// AddActionWidget: add an activatable widget to the action area of a
	// InfoBar, connecting a signal handler that will emit the InfoBar::response
	// signal on the message area when the widget is activated. The widget is
	// appended to the end of the message areas action area.
	AddActionWidget(child Widget, responseId int)
	// AddButton adds a button with the given text and sets things up so that
	// clicking the button will emit the “response” signal with the given
	// response_id. The button is appended to the end of the info bars's action
	// area. The button widget is returned, but usually you don't need it.
	AddButton(buttonText string, responseId int) Button
	// AddChild adds a widget to the content area of the info bar.
	AddChild(widget Widget)
	// MessageType returns the message type of the message area.
	MessageType() MessageType
	// Revealed returns whether the info bar is currently revealed.
	Revealed() bool
	// ShowCloseButton returns whether the widget will display a standard close
	// button.
	ShowCloseButton() bool
	// RemoveActionWidget removes a widget from the action area of @info_bar,
	// after it been put there by a call to gtk_info_bar_add_action_widget() or
	// gtk_info_bar_add_button().
	RemoveActionWidget(widget Widget)
	// RemoveChild removes a widget from the content area of the info bar, after
	// it has been added with gtk_info_bar_add_child().
	RemoveChild(widget Widget)
	// Response emits the “response” signal with the given @response_id.
	Response(responseId int)
	// SetDefaultResponse sets the last widget in the info bar’s action area
	// with the given response_id as the default widget for the dialog. Pressing
	// “Enter” normally activates the default widget.
	//
	// Note that this function currently requires @info_bar to be added to a
	// widget hierarchy.
	SetDefaultResponse(responseId int)
	// SetMessageType sets the message type of the message area.
	//
	// GTK uses this type to determine how the message is displayed.
	SetMessageType(messageType MessageType)
	// SetResponseSensitive calls gtk_widget_set_sensitive (widget, setting) for
	// each widget in the info bars’s action area with the given response_id. A
	// convenient way to sensitize/desensitize dialog buttons.
	SetResponseSensitive(responseId int, setting bool)
	// SetRevealed sets the InfoBar:revealed property to @revealed. Changing
	// this will make @info_bar reveal (true) or conceal (false) itself via a
	// sliding transition.
	//
	// Note: this does not show or hide @info_bar in the Widget:visible sense,
	// so revealing has no effect if Widget:visible is false.
	SetRevealed(revealed bool)
	// SetShowCloseButton: if true, a standard close button is shown. When
	// clicked it emits the response GTK_RESPONSE_CLOSE.
	SetShowCloseButton(setting bool)
}

// infoBar implements the InfoBar interface.
type infoBar struct {
	Widget
	Accessible
	Buildable
	ConstraintTarget
}

var _ InfoBar = (*infoBar)(nil)

// WrapInfoBar wraps a GObject to the right type. It is
// primarily used internally.
func WrapInfoBar(obj *externglib.Object) InfoBar {
	return InfoBar{
		Widget:           WrapWidget(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
	}
}

func marshalInfoBar(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapInfoBar(obj), nil
}

// NewInfoBar constructs a class InfoBar.
func NewInfoBar() InfoBar {
	var cret C.GtkInfoBar

	cret = C.gtk_info_bar_new()

	var infoBar InfoBar

	infoBar = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(InfoBar)

	return infoBar
}

// AddActionWidget: add an activatable widget to the action area of a
// InfoBar, connecting a signal handler that will emit the InfoBar::response
// signal on the message area when the widget is activated. The widget is
// appended to the end of the message areas action area.
func (i infoBar) AddActionWidget(child Widget, responseId int) {
	var arg0 *C.GtkInfoBar
	var arg1 *C.GtkWidget
	var arg2 C.int

	arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	arg2 = C.int(responseId)

	C.gtk_info_bar_add_action_widget(arg0, arg1, arg2)
}

// AddButton adds a button with the given text and sets things up so that
// clicking the button will emit the “response” signal with the given
// response_id. The button is appended to the end of the info bars's action
// area. The button widget is returned, but usually you don't need it.
func (i infoBar) AddButton(buttonText string, responseId int) Button {
	var arg0 *C.GtkInfoBar
	var arg1 *C.char
	var arg2 C.int

	arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))
	arg1 = (*C.char)(C.CString(buttonText))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.int(responseId)

	var cret *C.GtkWidget

	cret = C.gtk_info_bar_add_button(arg0, arg1, arg2)

	var button Button

	button = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Button)

	return button
}

// AddChild adds a widget to the content area of the info bar.
func (i infoBar) AddChild(widget Widget) {
	var arg0 *C.GtkInfoBar
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	C.gtk_info_bar_add_child(arg0, arg1)
}

// MessageType returns the message type of the message area.
func (i infoBar) MessageType() MessageType {
	var arg0 *C.GtkInfoBar

	arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))

	var cret C.GtkMessageType

	cret = C.gtk_info_bar_get_message_type(arg0)

	var messageType MessageType

	messageType = MessageType(cret)

	return messageType
}

// Revealed returns whether the info bar is currently revealed.
func (i infoBar) Revealed() bool {
	var arg0 *C.GtkInfoBar

	arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))

	var cret C.gboolean

	cret = C.gtk_info_bar_get_revealed(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// ShowCloseButton returns whether the widget will display a standard close
// button.
func (i infoBar) ShowCloseButton() bool {
	var arg0 *C.GtkInfoBar

	arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))

	var cret C.gboolean

	cret = C.gtk_info_bar_get_show_close_button(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// RemoveActionWidget removes a widget from the action area of @info_bar,
// after it been put there by a call to gtk_info_bar_add_action_widget() or
// gtk_info_bar_add_button().
func (i infoBar) RemoveActionWidget(widget Widget) {
	var arg0 *C.GtkInfoBar
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	C.gtk_info_bar_remove_action_widget(arg0, arg1)
}

// RemoveChild removes a widget from the content area of the info bar, after
// it has been added with gtk_info_bar_add_child().
func (i infoBar) RemoveChild(widget Widget) {
	var arg0 *C.GtkInfoBar
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	C.gtk_info_bar_remove_child(arg0, arg1)
}

// Response emits the “response” signal with the given @response_id.
func (i infoBar) Response(responseId int) {
	var arg0 *C.GtkInfoBar
	var arg1 C.int

	arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))
	arg1 = C.int(responseId)

	C.gtk_info_bar_response(arg0, arg1)
}

// SetDefaultResponse sets the last widget in the info bar’s action area
// with the given response_id as the default widget for the dialog. Pressing
// “Enter” normally activates the default widget.
//
// Note that this function currently requires @info_bar to be added to a
// widget hierarchy.
func (i infoBar) SetDefaultResponse(responseId int) {
	var arg0 *C.GtkInfoBar
	var arg1 C.int

	arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))
	arg1 = C.int(responseId)

	C.gtk_info_bar_set_default_response(arg0, arg1)
}

// SetMessageType sets the message type of the message area.
//
// GTK uses this type to determine how the message is displayed.
func (i infoBar) SetMessageType(messageType MessageType) {
	var arg0 *C.GtkInfoBar
	var arg1 C.GtkMessageType

	arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))
	arg1 = (C.GtkMessageType)(messageType)

	C.gtk_info_bar_set_message_type(arg0, arg1)
}

// SetResponseSensitive calls gtk_widget_set_sensitive (widget, setting) for
// each widget in the info bars’s action area with the given response_id. A
// convenient way to sensitize/desensitize dialog buttons.
func (i infoBar) SetResponseSensitive(responseId int, setting bool) {
	var arg0 *C.GtkInfoBar
	var arg1 C.int
	var arg2 C.gboolean

	arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))
	arg1 = C.int(responseId)
	if setting {
		arg2 = C.gboolean(1)
	}

	C.gtk_info_bar_set_response_sensitive(arg0, arg1, arg2)
}

// SetRevealed sets the InfoBar:revealed property to @revealed. Changing
// this will make @info_bar reveal (true) or conceal (false) itself via a
// sliding transition.
//
// Note: this does not show or hide @info_bar in the Widget:visible sense,
// so revealing has no effect if Widget:visible is false.
func (i infoBar) SetRevealed(revealed bool) {
	var arg0 *C.GtkInfoBar
	var arg1 C.gboolean

	arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))
	if revealed {
		arg1 = C.gboolean(1)
	}

	C.gtk_info_bar_set_revealed(arg0, arg1)
}

// SetShowCloseButton: if true, a standard close button is shown. When
// clicked it emits the response GTK_RESPONSE_CLOSE.
func (i infoBar) SetShowCloseButton(setting bool) {
	var arg0 *C.GtkInfoBar
	var arg1 C.gboolean

	arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))
	if setting {
		arg1 = C.gboolean(1)
	}

	C.gtk_info_bar_set_show_close_button(arg0, arg1)
}

// Label: the Label widget displays a small amount of text. As the name implies,
// most labels are used to label another widget such as a Button.
//
// CSS nodes
//
//    const char *text =
//    "Go to the"
//    "<a href=\"http://www.gtk.org title=\"&lt;i&gt;Our&lt;/i&gt; website\">"
//    "GTK website</a> for more...";
//    GtkWidget *label = gtk_label_new (NULL);
//    gtk_label_set_markup (GTK_LABEL (label), text);
//
// It is possible to implement custom handling for links and their tooltips with
// the Label::activate-link signal and the gtk_label_get_current_uri() function.
type Label interface {
	Widget
	Accessible
	Buildable
	ConstraintTarget

	// Attributes gets the attribute list that was set on the label using
	// gtk_label_set_attributes(), if any. This function does not reflect
	// attributes that come from the labels markup (see gtk_label_set_markup()).
	// If you want to get the effective attributes for the label, use
	// pango_layout_get_attribute (gtk_label_get_layout (self)).
	Attributes() *pango.AttrList
	// CurrentURI returns the URI for the currently active link in the label.
	// The active link is the one under the mouse pointer or, in a selectable
	// label, the link in which the text cursor is currently positioned.
	//
	// This function is intended for use in a Label::activate-link handler or
	// for use in a Widget::query-tooltip handler.
	CurrentURI() string
	// Ellipsize returns the ellipsizing position of the label. See
	// gtk_label_set_ellipsize().
	Ellipsize() pango.EllipsizeMode
	// ExtraMenu gets the menu model set with gtk_label_set_extra_menu().
	ExtraMenu() gio.MenuModel
	// Justify returns the justification of the label. See
	// gtk_label_set_justify().
	Justify() Justification
	// Label fetches the text from a label widget including any embedded
	// underlines indicating mnemonics and Pango markup. (See
	// gtk_label_get_text()).
	Label() string
	// Layout gets the Layout used to display the label. The layout is useful to
	// e.g. convert text positions to pixel positions, in combination with
	// gtk_label_get_layout_offsets(). The returned layout is owned by the
	// @label so need not be freed by the caller. The @label is free to recreate
	// its layout at any time, so it should be considered read-only.
	Layout() pango.Layout
	// LayoutOffsets obtains the coordinates where the label will draw the
	// Layout representing the text in the label; useful to convert mouse events
	// into coordinates inside the Layout, e.g. to take some action if some part
	// of the label is clicked. Remember when using the Layout functions you
	// need to convert to and from pixels using PANGO_PIXELS() or NGO_SCALE.
	LayoutOffsets() (x int, y int)
	// Lines gets the number of lines to which an ellipsized, wrapping label
	// should be limited. See gtk_label_set_lines().
	Lines() int
	// MaxWidthChars retrieves the desired maximum width of @label, in
	// characters. See gtk_label_set_width_chars().
	MaxWidthChars() int
	// MnemonicKeyval: if the label has been set so that it has a mnemonic key
	// this function returns the keyval used for the mnemonic accelerator. If
	// there is no mnemonic set up it returns K_KEY_VoidSymbol.
	MnemonicKeyval() uint
	// MnemonicWidget retrieves the target of the mnemonic (keyboard shortcut)
	// of this label. See gtk_label_set_mnemonic_widget().
	MnemonicWidget() Widget
	// Selectable gets the value set by gtk_label_set_selectable().
	Selectable() bool
	// SelectionBounds gets the selected range of characters in the label,
	// returning true if there’s a selection.
	SelectionBounds() (start int, end int, ok bool)
	// SingleLineMode returns whether the label is in single line mode.
	SingleLineMode() bool
	// Text fetches the text from a label widget, as displayed on the screen.
	// This does not include any embedded underlines indicating mnemonics or
	// Pango markup. (See gtk_label_get_label())
	Text() string
	// UseMarkup returns whether the label’s text is interpreted as marked up
	// with the [Pango text markup language][PangoMarkupFormat]. See
	// gtk_label_set_use_markup ().
	UseMarkup() bool
	// UseUnderline returns whether an embedded underline in the label indicates
	// a mnemonic. See gtk_label_set_use_underline().
	UseUnderline() bool
	// WidthChars retrieves the desired width of @label, in characters. See
	// gtk_label_set_width_chars().
	WidthChars() int
	// Wrap returns whether lines in the label are automatically wrapped. See
	// gtk_label_set_wrap().
	Wrap() bool
	// WrapMode returns line wrap mode used by the label. See
	// gtk_label_set_wrap_mode().
	WrapMode() pango.WrapMode
	// Xalign gets the Label:xalign property for @label.
	Xalign() float32
	// Yalign gets the Label:yalign property for @label.
	Yalign() float32
	// SelectRegion selects a range of characters in the label, if the label is
	// selectable. See gtk_label_set_selectable(). If the label is not
	// selectable, this function has no effect. If @start_offset or @end_offset
	// are -1, then the end of the label will be substituted.
	SelectRegion(startOffset int, endOffset int)
	// SetAttributes sets a AttrList; the attributes in the list are applied to
	// the label text.
	//
	// The attributes set with this function will be applied and merged with any
	// other attributes previously effected by way of the Label:use-underline or
	// Label:use-markup properties. While it is not recommended to mix markup
	// strings with manually set attributes, if you must; know that the
	// attributes will be applied to the label after the markup string is
	// parsed.
	SetAttributes(attrs *pango.AttrList)
	// SetEllipsize sets the mode used to ellipsize (add an ellipsis: "...") to
	// the text if there is not enough space to render the entire string.
	SetEllipsize(mode pango.EllipsizeMode)
	// SetExtraMenu sets a menu model to add when constructing the context menu
	// for @label.
	SetExtraMenu(model gio.MenuModel)
	// SetJustify sets the alignment of the lines in the text of the label
	// relative to each other. GTK_JUSTIFY_LEFT is the default value when the
	// widget is first created with gtk_label_new(). If you instead want to set
	// the alignment of the label as a whole, use gtk_widget_set_halign()
	// instead. gtk_label_set_justify() has no effect on labels containing only
	// a single line.
	SetJustify(jtype Justification)
	// SetLabel sets the text of the label. The label is interpreted as
	// including embedded underlines and/or Pango markup depending on the values
	// of the Label:use-underline and Label:use-markup properties.
	SetLabel(str string)
	// SetLines sets the number of lines to which an ellipsized, wrapping label
	// should be limited. This has no effect if the label is not wrapping or
	// ellipsized. Set this to -1 if you don’t want to limit the number of
	// lines.
	SetLines(lines int)
	// SetMarkup parses @str which is marked up with the [Pango text markup
	// language][PangoMarkupFormat], setting the label’s text and attribute list
	// based on the parse results.
	//
	// If the @str is external data, you may need to escape it with
	// g_markup_escape_text() or g_markup_printf_escaped():
	//
	//    GtkWidget *self = gtk_label_new (NULL);
	//    const char *str = "...";
	//    const char *format = "<span style=\"italic\">\s</span>";
	//    char *markup;
	//
	//    markup = g_markup_printf_escaped (format, str);
	//    gtk_label_set_markup (GTK_LABEL (self), markup);
	//    g_free (markup);
	//
	// This function will set the Label:use-markup property to true as a side
	// effect.
	//
	// If you set the label contents using the Label:label property you should
	// also ensure that you set the Label:use-markup property accordingly.
	//
	// See also: gtk_label_set_text()
	SetMarkup(str string)
	// SetMarkupWithMnemonic parses @str which is marked up with the [Pango text
	// markup language][PangoMarkupFormat], setting the label’s text and
	// attribute list based on the parse results. If characters in @str are
	// preceded by an underscore, they are underlined indicating that they
	// represent a keyboard accelerator called a mnemonic.
	//
	// The mnemonic key can be used to activate another widget, chosen
	// automatically, or explicitly using gtk_label_set_mnemonic_widget().
	SetMarkupWithMnemonic(str string)
	// SetMaxWidthChars sets the desired maximum width in characters of @label
	// to @n_chars.
	SetMaxWidthChars(nChars int)
	// SetMnemonicWidget: if the label has been set so that it has a mnemonic
	// key (using i.e. gtk_label_set_markup_with_mnemonic(),
	// gtk_label_set_text_with_mnemonic(), gtk_label_new_with_mnemonic() or the
	// “use_underline” property) the label can be associated with a widget that
	// is the target of the mnemonic. When the label is inside a widget (like a
	// Button or a Notebook tab) it is automatically associated with the correct
	// widget, but sometimes (i.e. when the target is a Entry next to the label)
	// you need to set it explicitly using this function.
	//
	// The target widget will be accelerated by emitting the
	// GtkWidget::mnemonic-activate signal on it. The default handler for this
	// signal will activate the widget if there are no mnemonic collisions and
	// toggle focus between the colliding widgets otherwise.
	SetMnemonicWidget(widget Widget)
	// SetSelectable: selectable labels allow the user to select text from the
	// label, for copy-and-paste.
	SetSelectable(setting bool)
	// SetSingleLineMode sets whether the label is in single line mode.
	SetSingleLineMode(singleLineMode bool)
	// SetText sets the text within the Label widget. It overwrites any text
	// that was there before.
	//
	// This function will clear any previously set mnemonic accelerators, and
	// set the Label:use-underline property to false as a side effect.
	//
	// This function will set the Label:use-markup property to false as a side
	// effect.
	//
	// See also: gtk_label_set_markup()
	SetText(str string)
	// SetTextWithMnemonic sets the label’s text from the string @str. If
	// characters in @str are preceded by an underscore, they are underlined
	// indicating that they represent a keyboard accelerator called a mnemonic.
	// The mnemonic key can be used to activate another widget, chosen
	// automatically, or explicitly using gtk_label_set_mnemonic_widget().
	SetTextWithMnemonic(str string)
	// SetUseMarkup sets whether the text of the label contains markup in
	// [Pango’s text markup language][PangoMarkupFormat]. See
	// gtk_label_set_markup().
	SetUseMarkup(setting bool)
	// SetUseUnderline: if true, an underline in the text indicates the next
	// character should be used for the mnemonic accelerator key.
	SetUseUnderline(setting bool)
	// SetWidthChars sets the desired width in characters of @label to @n_chars.
	SetWidthChars(nChars int)
	// SetWrap toggles line wrapping within the Label widget. true makes it
	// break lines if text exceeds the widget’s size. false lets the text get
	// cut off by the edge of the widget if it exceeds the widget size.
	//
	// Note that setting line wrapping to true does not make the label wrap at
	// its parent container’s width, because GTK widgets conceptually can’t make
	// their requisition depend on the parent container’s size. For a label that
	// wraps at a specific position, set the label’s width using
	// gtk_widget_set_size_request().
	SetWrap(wrap bool)
	// SetWrapMode: if line wrapping is on (see gtk_label_set_wrap()) this
	// controls how the line wrapping is done. The default is PANGO_WRAP_WORD
	// which means wrap on word boundaries.
	SetWrapMode(wrapMode pango.WrapMode)
	// SetXalign sets the Label:xalign property for @label.
	SetXalign(xalign float32)
	// SetYalign sets the Label:yalign property for @label.
	SetYalign(yalign float32)
}

// label implements the Label interface.
type label struct {
	Widget
	Accessible
	Buildable
	ConstraintTarget
}

var _ Label = (*label)(nil)

// WrapLabel wraps a GObject to the right type. It is
// primarily used internally.
func WrapLabel(obj *externglib.Object) Label {
	return Label{
		Widget:           WrapWidget(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
	}
}

func marshalLabel(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapLabel(obj), nil
}

// NewLabel constructs a class Label.
func NewLabel(str string) Label {
	var arg1 *C.char

	arg1 = (*C.char)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))

	var cret C.GtkLabel

	cret = C.gtk_label_new(arg1)

	var label Label

	label = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Label)

	return label
}

// NewLabelWithMnemonic constructs a class Label.
func NewLabelWithMnemonic(str string) Label {
	var arg1 *C.char

	arg1 = (*C.char)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))

	var cret C.GtkLabel

	cret = C.gtk_label_new_with_mnemonic(arg1)

	var label Label

	label = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Label)

	return label
}

// Attributes gets the attribute list that was set on the label using
// gtk_label_set_attributes(), if any. This function does not reflect
// attributes that come from the labels markup (see gtk_label_set_markup()).
// If you want to get the effective attributes for the label, use
// pango_layout_get_attribute (gtk_label_get_layout (self)).
func (s label) Attributes() *pango.AttrList {
	var arg0 *C.GtkLabel

	arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))

	var cret *C.PangoAttrList

	cret = C.gtk_label_get_attributes(arg0)

	var attrList *pango.AttrList

	attrList = pango.WrapAttrList(unsafe.Pointer(cret))

	return attrList
}

// CurrentURI returns the URI for the currently active link in the label.
// The active link is the one under the mouse pointer or, in a selectable
// label, the link in which the text cursor is currently positioned.
//
// This function is intended for use in a Label::activate-link handler or
// for use in a Widget::query-tooltip handler.
func (s label) CurrentURI() string {
	var arg0 *C.GtkLabel

	arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))

	var cret *C.char

	cret = C.gtk_label_get_current_uri(arg0)

	var utf8 string

	utf8 = C.GoString(cret)

	return utf8
}

// Ellipsize returns the ellipsizing position of the label. See
// gtk_label_set_ellipsize().
func (s label) Ellipsize() pango.EllipsizeMode {
	var arg0 *C.GtkLabel

	arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))

	var cret C.PangoEllipsizeMode

	cret = C.gtk_label_get_ellipsize(arg0)

	var ellipsizeMode pango.EllipsizeMode

	ellipsizeMode = pango.EllipsizeMode(cret)

	return ellipsizeMode
}

// ExtraMenu gets the menu model set with gtk_label_set_extra_menu().
func (s label) ExtraMenu() gio.MenuModel {
	var arg0 *C.GtkLabel

	arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))

	var cret *C.GMenuModel

	cret = C.gtk_label_get_extra_menu(arg0)

	var menuModel gio.MenuModel

	menuModel = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(gio.MenuModel)

	return menuModel
}

// Justify returns the justification of the label. See
// gtk_label_set_justify().
func (s label) Justify() Justification {
	var arg0 *C.GtkLabel

	arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))

	var cret C.GtkJustification

	cret = C.gtk_label_get_justify(arg0)

	var justification Justification

	justification = Justification(cret)

	return justification
}

// Label fetches the text from a label widget including any embedded
// underlines indicating mnemonics and Pango markup. (See
// gtk_label_get_text()).
func (s label) Label() string {
	var arg0 *C.GtkLabel

	arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))

	var cret *C.char

	cret = C.gtk_label_get_label(arg0)

	var utf8 string

	utf8 = C.GoString(cret)

	return utf8
}

// Layout gets the Layout used to display the label. The layout is useful to
// e.g. convert text positions to pixel positions, in combination with
// gtk_label_get_layout_offsets(). The returned layout is owned by the
// @label so need not be freed by the caller. The @label is free to recreate
// its layout at any time, so it should be considered read-only.
func (s label) Layout() pango.Layout {
	var arg0 *C.GtkLabel

	arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))

	var cret *C.PangoLayout

	cret = C.gtk_label_get_layout(arg0)

	var layout pango.Layout

	layout = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(pango.Layout)

	return layout
}

// LayoutOffsets obtains the coordinates where the label will draw the
// Layout representing the text in the label; useful to convert mouse events
// into coordinates inside the Layout, e.g. to take some action if some part
// of the label is clicked. Remember when using the Layout functions you
// need to convert to and from pixels using PANGO_PIXELS() or NGO_SCALE.
func (s label) LayoutOffsets() (x int, y int) {
	var arg0 *C.GtkLabel

	arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))

	var arg1 C.int
	var arg2 C.int

	C.gtk_label_get_layout_offsets(arg0, &arg1, &arg2)

	var x int
	var y int

	x = (int)(arg1)
	y = (int)(arg2)

	return x, y
}

// Lines gets the number of lines to which an ellipsized, wrapping label
// should be limited. See gtk_label_set_lines().
func (s label) Lines() int {
	var arg0 *C.GtkLabel

	arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))

	var cret C.int

	cret = C.gtk_label_get_lines(arg0)

	var gint int

	gint = (int)(cret)

	return gint
}

// MaxWidthChars retrieves the desired maximum width of @label, in
// characters. See gtk_label_set_width_chars().
func (s label) MaxWidthChars() int {
	var arg0 *C.GtkLabel

	arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))

	var cret C.int

	cret = C.gtk_label_get_max_width_chars(arg0)

	var gint int

	gint = (int)(cret)

	return gint
}

// MnemonicKeyval: if the label has been set so that it has a mnemonic key
// this function returns the keyval used for the mnemonic accelerator. If
// there is no mnemonic set up it returns K_KEY_VoidSymbol.
func (s label) MnemonicKeyval() uint {
	var arg0 *C.GtkLabel

	arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))

	var cret C.guint

	cret = C.gtk_label_get_mnemonic_keyval(arg0)

	var guint uint

	guint = (uint)(cret)

	return guint
}

// MnemonicWidget retrieves the target of the mnemonic (keyboard shortcut)
// of this label. See gtk_label_set_mnemonic_widget().
func (s label) MnemonicWidget() Widget {
	var arg0 *C.GtkLabel

	arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))

	var cret *C.GtkWidget

	cret = C.gtk_label_get_mnemonic_widget(arg0)

	var widget Widget

	widget = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Widget)

	return widget
}

// Selectable gets the value set by gtk_label_set_selectable().
func (s label) Selectable() bool {
	var arg0 *C.GtkLabel

	arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))

	var cret C.gboolean

	cret = C.gtk_label_get_selectable(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// SelectionBounds gets the selected range of characters in the label,
// returning true if there’s a selection.
func (s label) SelectionBounds() (start int, end int, ok bool) {
	var arg0 *C.GtkLabel

	arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))

	var arg1 C.int
	var arg2 C.int
	var cret C.gboolean

	cret = C.gtk_label_get_selection_bounds(arg0, &arg1, &arg2)

	var start int
	var end int
	var ok bool

	start = (int)(arg1)
	end = (int)(arg2)
	if cret {
		ok = true
	}

	return start, end, ok
}

// SingleLineMode returns whether the label is in single line mode.
func (s label) SingleLineMode() bool {
	var arg0 *C.GtkLabel

	arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))

	var cret C.gboolean

	cret = C.gtk_label_get_single_line_mode(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// Text fetches the text from a label widget, as displayed on the screen.
// This does not include any embedded underlines indicating mnemonics or
// Pango markup. (See gtk_label_get_label())
func (s label) Text() string {
	var arg0 *C.GtkLabel

	arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))

	var cret *C.char

	cret = C.gtk_label_get_text(arg0)

	var utf8 string

	utf8 = C.GoString(cret)

	return utf8
}

// UseMarkup returns whether the label’s text is interpreted as marked up
// with the [Pango text markup language][PangoMarkupFormat]. See
// gtk_label_set_use_markup ().
func (s label) UseMarkup() bool {
	var arg0 *C.GtkLabel

	arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))

	var cret C.gboolean

	cret = C.gtk_label_get_use_markup(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// UseUnderline returns whether an embedded underline in the label indicates
// a mnemonic. See gtk_label_set_use_underline().
func (s label) UseUnderline() bool {
	var arg0 *C.GtkLabel

	arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))

	var cret C.gboolean

	cret = C.gtk_label_get_use_underline(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// WidthChars retrieves the desired width of @label, in characters. See
// gtk_label_set_width_chars().
func (s label) WidthChars() int {
	var arg0 *C.GtkLabel

	arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))

	var cret C.int

	cret = C.gtk_label_get_width_chars(arg0)

	var gint int

	gint = (int)(cret)

	return gint
}

// Wrap returns whether lines in the label are automatically wrapped. See
// gtk_label_set_wrap().
func (s label) Wrap() bool {
	var arg0 *C.GtkLabel

	arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))

	var cret C.gboolean

	cret = C.gtk_label_get_wrap(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// WrapMode returns line wrap mode used by the label. See
// gtk_label_set_wrap_mode().
func (s label) WrapMode() pango.WrapMode {
	var arg0 *C.GtkLabel

	arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))

	var cret C.PangoWrapMode

	cret = C.gtk_label_get_wrap_mode(arg0)

	var wrapMode pango.WrapMode

	wrapMode = pango.WrapMode(cret)

	return wrapMode
}

// Xalign gets the Label:xalign property for @label.
func (s label) Xalign() float32 {
	var arg0 *C.GtkLabel

	arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))

	var cret C.float

	cret = C.gtk_label_get_xalign(arg0)

	var gfloat float32

	gfloat = (float32)(cret)

	return gfloat
}

// Yalign gets the Label:yalign property for @label.
func (s label) Yalign() float32 {
	var arg0 *C.GtkLabel

	arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))

	var cret C.float

	cret = C.gtk_label_get_yalign(arg0)

	var gfloat float32

	gfloat = (float32)(cret)

	return gfloat
}

// SelectRegion selects a range of characters in the label, if the label is
// selectable. See gtk_label_set_selectable(). If the label is not
// selectable, this function has no effect. If @start_offset or @end_offset
// are -1, then the end of the label will be substituted.
func (s label) SelectRegion(startOffset int, endOffset int) {
	var arg0 *C.GtkLabel
	var arg1 C.int
	var arg2 C.int

	arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
	arg1 = C.int(startOffset)
	arg2 = C.int(endOffset)

	C.gtk_label_select_region(arg0, arg1, arg2)
}

// SetAttributes sets a AttrList; the attributes in the list are applied to
// the label text.
//
// The attributes set with this function will be applied and merged with any
// other attributes previously effected by way of the Label:use-underline or
// Label:use-markup properties. While it is not recommended to mix markup
// strings with manually set attributes, if you must; know that the
// attributes will be applied to the label after the markup string is
// parsed.
func (s label) SetAttributes(attrs *pango.AttrList) {
	var arg0 *C.GtkLabel
	var arg1 *C.PangoAttrList

	arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
	arg1 = (*C.PangoAttrList)(unsafe.Pointer(attrs.Native()))

	C.gtk_label_set_attributes(arg0, arg1)
}

// SetEllipsize sets the mode used to ellipsize (add an ellipsis: "...") to
// the text if there is not enough space to render the entire string.
func (s label) SetEllipsize(mode pango.EllipsizeMode) {
	var arg0 *C.GtkLabel
	var arg1 C.PangoEllipsizeMode

	arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
	arg1 = (C.PangoEllipsizeMode)(mode)

	C.gtk_label_set_ellipsize(arg0, arg1)
}

// SetExtraMenu sets a menu model to add when constructing the context menu
// for @label.
func (s label) SetExtraMenu(model gio.MenuModel) {
	var arg0 *C.GtkLabel
	var arg1 *C.GMenuModel

	arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GMenuModel)(unsafe.Pointer(model.Native()))

	C.gtk_label_set_extra_menu(arg0, arg1)
}

// SetJustify sets the alignment of the lines in the text of the label
// relative to each other. GTK_JUSTIFY_LEFT is the default value when the
// widget is first created with gtk_label_new(). If you instead want to set
// the alignment of the label as a whole, use gtk_widget_set_halign()
// instead. gtk_label_set_justify() has no effect on labels containing only
// a single line.
func (s label) SetJustify(jtype Justification) {
	var arg0 *C.GtkLabel
	var arg1 C.GtkJustification

	arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
	arg1 = (C.GtkJustification)(jtype)

	C.gtk_label_set_justify(arg0, arg1)
}

// SetLabel sets the text of the label. The label is interpreted as
// including embedded underlines and/or Pango markup depending on the values
// of the Label:use-underline and Label:use-markup properties.
func (s label) SetLabel(str string) {
	var arg0 *C.GtkLabel
	var arg1 *C.char

	arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
	arg1 = (*C.char)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_label_set_label(arg0, arg1)
}

// SetLines sets the number of lines to which an ellipsized, wrapping label
// should be limited. This has no effect if the label is not wrapping or
// ellipsized. Set this to -1 if you don’t want to limit the number of
// lines.
func (s label) SetLines(lines int) {
	var arg0 *C.GtkLabel
	var arg1 C.int

	arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
	arg1 = C.int(lines)

	C.gtk_label_set_lines(arg0, arg1)
}

// SetMarkup parses @str which is marked up with the [Pango text markup
// language][PangoMarkupFormat], setting the label’s text and attribute list
// based on the parse results.
//
// If the @str is external data, you may need to escape it with
// g_markup_escape_text() or g_markup_printf_escaped():
//
//    GtkWidget *self = gtk_label_new (NULL);
//    const char *str = "...";
//    const char *format = "<span style=\"italic\">\s</span>";
//    char *markup;
//
//    markup = g_markup_printf_escaped (format, str);
//    gtk_label_set_markup (GTK_LABEL (self), markup);
//    g_free (markup);
//
// This function will set the Label:use-markup property to true as a side
// effect.
//
// If you set the label contents using the Label:label property you should
// also ensure that you set the Label:use-markup property accordingly.
//
// See also: gtk_label_set_text()
func (s label) SetMarkup(str string) {
	var arg0 *C.GtkLabel
	var arg1 *C.char

	arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
	arg1 = (*C.char)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_label_set_markup(arg0, arg1)
}

// SetMarkupWithMnemonic parses @str which is marked up with the [Pango text
// markup language][PangoMarkupFormat], setting the label’s text and
// attribute list based on the parse results. If characters in @str are
// preceded by an underscore, they are underlined indicating that they
// represent a keyboard accelerator called a mnemonic.
//
// The mnemonic key can be used to activate another widget, chosen
// automatically, or explicitly using gtk_label_set_mnemonic_widget().
func (s label) SetMarkupWithMnemonic(str string) {
	var arg0 *C.GtkLabel
	var arg1 *C.char

	arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
	arg1 = (*C.char)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_label_set_markup_with_mnemonic(arg0, arg1)
}

// SetMaxWidthChars sets the desired maximum width in characters of @label
// to @n_chars.
func (s label) SetMaxWidthChars(nChars int) {
	var arg0 *C.GtkLabel
	var arg1 C.int

	arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
	arg1 = C.int(nChars)

	C.gtk_label_set_max_width_chars(arg0, arg1)
}

// SetMnemonicWidget: if the label has been set so that it has a mnemonic
// key (using i.e. gtk_label_set_markup_with_mnemonic(),
// gtk_label_set_text_with_mnemonic(), gtk_label_new_with_mnemonic() or the
// “use_underline” property) the label can be associated with a widget that
// is the target of the mnemonic. When the label is inside a widget (like a
// Button or a Notebook tab) it is automatically associated with the correct
// widget, but sometimes (i.e. when the target is a Entry next to the label)
// you need to set it explicitly using this function.
//
// The target widget will be accelerated by emitting the
// GtkWidget::mnemonic-activate signal on it. The default handler for this
// signal will activate the widget if there are no mnemonic collisions and
// toggle focus between the colliding widgets otherwise.
func (s label) SetMnemonicWidget(widget Widget) {
	var arg0 *C.GtkLabel
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	C.gtk_label_set_mnemonic_widget(arg0, arg1)
}

// SetSelectable: selectable labels allow the user to select text from the
// label, for copy-and-paste.
func (s label) SetSelectable(setting bool) {
	var arg0 *C.GtkLabel
	var arg1 C.gboolean

	arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
	if setting {
		arg1 = C.gboolean(1)
	}

	C.gtk_label_set_selectable(arg0, arg1)
}

// SetSingleLineMode sets whether the label is in single line mode.
func (s label) SetSingleLineMode(singleLineMode bool) {
	var arg0 *C.GtkLabel
	var arg1 C.gboolean

	arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
	if singleLineMode {
		arg1 = C.gboolean(1)
	}

	C.gtk_label_set_single_line_mode(arg0, arg1)
}

// SetText sets the text within the Label widget. It overwrites any text
// that was there before.
//
// This function will clear any previously set mnemonic accelerators, and
// set the Label:use-underline property to false as a side effect.
//
// This function will set the Label:use-markup property to false as a side
// effect.
//
// See also: gtk_label_set_markup()
func (s label) SetText(str string) {
	var arg0 *C.GtkLabel
	var arg1 *C.char

	arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
	arg1 = (*C.char)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_label_set_text(arg0, arg1)
}

// SetTextWithMnemonic sets the label’s text from the string @str. If
// characters in @str are preceded by an underscore, they are underlined
// indicating that they represent a keyboard accelerator called a mnemonic.
// The mnemonic key can be used to activate another widget, chosen
// automatically, or explicitly using gtk_label_set_mnemonic_widget().
func (s label) SetTextWithMnemonic(str string) {
	var arg0 *C.GtkLabel
	var arg1 *C.char

	arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
	arg1 = (*C.char)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_label_set_text_with_mnemonic(arg0, arg1)
}

// SetUseMarkup sets whether the text of the label contains markup in
// [Pango’s text markup language][PangoMarkupFormat]. See
// gtk_label_set_markup().
func (s label) SetUseMarkup(setting bool) {
	var arg0 *C.GtkLabel
	var arg1 C.gboolean

	arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
	if setting {
		arg1 = C.gboolean(1)
	}

	C.gtk_label_set_use_markup(arg0, arg1)
}

// SetUseUnderline: if true, an underline in the text indicates the next
// character should be used for the mnemonic accelerator key.
func (s label) SetUseUnderline(setting bool) {
	var arg0 *C.GtkLabel
	var arg1 C.gboolean

	arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
	if setting {
		arg1 = C.gboolean(1)
	}

	C.gtk_label_set_use_underline(arg0, arg1)
}

// SetWidthChars sets the desired width in characters of @label to @n_chars.
func (s label) SetWidthChars(nChars int) {
	var arg0 *C.GtkLabel
	var arg1 C.int

	arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
	arg1 = C.int(nChars)

	C.gtk_label_set_width_chars(arg0, arg1)
}

// SetWrap toggles line wrapping within the Label widget. true makes it
// break lines if text exceeds the widget’s size. false lets the text get
// cut off by the edge of the widget if it exceeds the widget size.
//
// Note that setting line wrapping to true does not make the label wrap at
// its parent container’s width, because GTK widgets conceptually can’t make
// their requisition depend on the parent container’s size. For a label that
// wraps at a specific position, set the label’s width using
// gtk_widget_set_size_request().
func (s label) SetWrap(wrap bool) {
	var arg0 *C.GtkLabel
	var arg1 C.gboolean

	arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
	if wrap {
		arg1 = C.gboolean(1)
	}

	C.gtk_label_set_wrap(arg0, arg1)
}

// SetWrapMode: if line wrapping is on (see gtk_label_set_wrap()) this
// controls how the line wrapping is done. The default is PANGO_WRAP_WORD
// which means wrap on word boundaries.
func (s label) SetWrapMode(wrapMode pango.WrapMode) {
	var arg0 *C.GtkLabel
	var arg1 C.PangoWrapMode

	arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
	arg1 = (C.PangoWrapMode)(wrapMode)

	C.gtk_label_set_wrap_mode(arg0, arg1)
}

// SetXalign sets the Label:xalign property for @label.
func (s label) SetXalign(xalign float32) {
	var arg0 *C.GtkLabel
	var arg1 C.float

	arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
	arg1 = C.float(xalign)

	C.gtk_label_set_xalign(arg0, arg1)
}

// SetYalign sets the Label:yalign property for @label.
func (s label) SetYalign(yalign float32) {
	var arg0 *C.GtkLabel
	var arg1 C.float

	arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
	arg1 = C.float(yalign)

	C.gtk_label_set_yalign(arg0, arg1)
}

// LevelBar: the LevelBar is a bar widget that can be used as a level indicator.
// Typical use cases are displaying the strength of a password, or showing the
// charge level of a battery.
//
// Use gtk_level_bar_set_value() to set the current value, and
// gtk_level_bar_add_offset_value() to set the value offsets at which the bar
// will be considered in a different state. GTK will add a few offsets by
// default on the level bar: K_LEVEL_BAR_OFFSET_LOW, K_LEVEL_BAR_OFFSET_HIGH and
// K_LEVEL_BAR_OFFSET_FULL, with values 0.25, 0.75 and 1.0 respectively.
//
// Note that it is your responsibility to update preexisting offsets when
// changing the minimum or maximum value. GTK will simply clamp them to the new
// range.
//
// Adding a custom offset on the bar
//
//    levelbar[.discrete]
//    ╰── trough
//        ├── block.filled.level-name
//        ┊
//        ├── block.empty
//        ┊
//
// GtkLevelBar has a main CSS node with name levelbar and one of the style
// classes .discrete or .continuous and a subnode with name trough. Below the
// trough node are a number of nodes with name block and style class .filled or
// .empty. In continuous mode, there is exactly one node of each, in discrete
// mode, the number of filled and unfilled nodes corresponds to blocks that are
// drawn. The block.filled nodes also get a style class .level-name
// corresponding to the level for the current value.
//
// In horizontal orientation, the nodes are always arranged from left to right,
// regardless of text direction.
//
//
// Accessibility
//
// GtkLevelBar uses the K_ACCESSIBLE_ROLE_METER role.
type LevelBar interface {
	Widget
	Accessible
	Buildable
	ConstraintTarget
	Orientable

	// AddOffsetValue adds a new offset marker on @self at the position
	// specified by @value. When the bar value is in the interval topped by
	// @value (or between @value and LevelBar:max-value in case the offset is
	// the last one on the bar) a style class named `level-`@name will be
	// applied when rendering the level bar fill. If another offset marker named
	// @name exists, its value will be replaced by @value.
	AddOffsetValue(name string, value float64)
	// Inverted: return the value of the LevelBar:inverted property.
	Inverted() bool
	// MaxValue returns the value of the LevelBar:max-value property.
	MaxValue() float64
	// MinValue returns the value of the LevelBar:min-value property.
	MinValue() float64
	// Mode returns the value of the LevelBar:mode property.
	Mode() LevelBarMode
	// OffsetValue fetches the value specified for the offset marker @name in
	// @self, returning true in case an offset named @name was found.
	OffsetValue(name string) (value float64, ok bool)
	// Value returns the value of the LevelBar:value property.
	Value() float64
	// RemoveOffsetValue removes an offset marker previously added with
	// gtk_level_bar_add_offset_value().
	RemoveOffsetValue(name string)
	// SetInverted sets the value of the LevelBar:inverted property.
	SetInverted(inverted bool)
	// SetMaxValue sets the value of the LevelBar:max-value property.
	//
	// You probably want to update preexisting level offsets after calling this
	// function.
	SetMaxValue(value float64)
	// SetMinValue sets the value of the LevelBar:min-value property.
	//
	// You probably want to update preexisting level offsets after calling this
	// function.
	SetMinValue(value float64)
	// SetMode sets the value of the LevelBar:mode property.
	SetMode(mode LevelBarMode)
	// SetValue sets the value of the LevelBar:value property.
	SetValue(value float64)
}

// levelBar implements the LevelBar interface.
type levelBar struct {
	Widget
	Accessible
	Buildable
	ConstraintTarget
	Orientable
}

var _ LevelBar = (*levelBar)(nil)

// WrapLevelBar wraps a GObject to the right type. It is
// primarily used internally.
func WrapLevelBar(obj *externglib.Object) LevelBar {
	return LevelBar{
		Widget:           WrapWidget(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
		Orientable:       WrapOrientable(obj),
	}
}

func marshalLevelBar(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapLevelBar(obj), nil
}

// NewLevelBar constructs a class LevelBar.
func NewLevelBar() LevelBar {
	var cret C.GtkLevelBar

	cret = C.gtk_level_bar_new()

	var levelBar LevelBar

	levelBar = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(LevelBar)

	return levelBar
}

// NewLevelBarForInterval constructs a class LevelBar.
func NewLevelBarForInterval(minValue float64, maxValue float64) LevelBar {
	var arg1 C.double
	var arg2 C.double

	arg1 = C.double(minValue)
	arg2 = C.double(maxValue)

	var cret C.GtkLevelBar

	cret = C.gtk_level_bar_new_for_interval(arg1, arg2)

	var levelBar LevelBar

	levelBar = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(LevelBar)

	return levelBar
}

// AddOffsetValue adds a new offset marker on @self at the position
// specified by @value. When the bar value is in the interval topped by
// @value (or between @value and LevelBar:max-value in case the offset is
// the last one on the bar) a style class named `level-`@name will be
// applied when rendering the level bar fill. If another offset marker named
// @name exists, its value will be replaced by @value.
func (s levelBar) AddOffsetValue(name string, value float64) {
	var arg0 *C.GtkLevelBar
	var arg1 *C.char
	var arg2 C.double

	arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))
	arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.double(value)

	C.gtk_level_bar_add_offset_value(arg0, arg1, arg2)
}

// Inverted: return the value of the LevelBar:inverted property.
func (s levelBar) Inverted() bool {
	var arg0 *C.GtkLevelBar

	arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))

	var cret C.gboolean

	cret = C.gtk_level_bar_get_inverted(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// MaxValue returns the value of the LevelBar:max-value property.
func (s levelBar) MaxValue() float64 {
	var arg0 *C.GtkLevelBar

	arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))

	var cret C.double

	cret = C.gtk_level_bar_get_max_value(arg0)

	var gdouble float64

	gdouble = (float64)(cret)

	return gdouble
}

// MinValue returns the value of the LevelBar:min-value property.
func (s levelBar) MinValue() float64 {
	var arg0 *C.GtkLevelBar

	arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))

	var cret C.double

	cret = C.gtk_level_bar_get_min_value(arg0)

	var gdouble float64

	gdouble = (float64)(cret)

	return gdouble
}

// Mode returns the value of the LevelBar:mode property.
func (s levelBar) Mode() LevelBarMode {
	var arg0 *C.GtkLevelBar

	arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))

	var cret C.GtkLevelBarMode

	cret = C.gtk_level_bar_get_mode(arg0)

	var levelBarMode LevelBarMode

	levelBarMode = LevelBarMode(cret)

	return levelBarMode
}

// OffsetValue fetches the value specified for the offset marker @name in
// @self, returning true in case an offset named @name was found.
func (s levelBar) OffsetValue(name string) (value float64, ok bool) {
	var arg0 *C.GtkLevelBar
	var arg1 *C.char

	arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))
	arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	var arg2 C.double
	var cret C.gboolean

	cret = C.gtk_level_bar_get_offset_value(arg0, arg1, &arg2)

	var value float64
	var ok bool

	value = (float64)(arg2)
	if cret {
		ok = true
	}

	return value, ok
}

// Value returns the value of the LevelBar:value property.
func (s levelBar) Value() float64 {
	var arg0 *C.GtkLevelBar

	arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))

	var cret C.double

	cret = C.gtk_level_bar_get_value(arg0)

	var gdouble float64

	gdouble = (float64)(cret)

	return gdouble
}

// RemoveOffsetValue removes an offset marker previously added with
// gtk_level_bar_add_offset_value().
func (s levelBar) RemoveOffsetValue(name string) {
	var arg0 *C.GtkLevelBar
	var arg1 *C.char

	arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))
	arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_level_bar_remove_offset_value(arg0, arg1)
}

// SetInverted sets the value of the LevelBar:inverted property.
func (s levelBar) SetInverted(inverted bool) {
	var arg0 *C.GtkLevelBar
	var arg1 C.gboolean

	arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))
	if inverted {
		arg1 = C.gboolean(1)
	}

	C.gtk_level_bar_set_inverted(arg0, arg1)
}

// SetMaxValue sets the value of the LevelBar:max-value property.
//
// You probably want to update preexisting level offsets after calling this
// function.
func (s levelBar) SetMaxValue(value float64) {
	var arg0 *C.GtkLevelBar
	var arg1 C.double

	arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))
	arg1 = C.double(value)

	C.gtk_level_bar_set_max_value(arg0, arg1)
}

// SetMinValue sets the value of the LevelBar:min-value property.
//
// You probably want to update preexisting level offsets after calling this
// function.
func (s levelBar) SetMinValue(value float64) {
	var arg0 *C.GtkLevelBar
	var arg1 C.double

	arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))
	arg1 = C.double(value)

	C.gtk_level_bar_set_min_value(arg0, arg1)
}

// SetMode sets the value of the LevelBar:mode property.
func (s levelBar) SetMode(mode LevelBarMode) {
	var arg0 *C.GtkLevelBar
	var arg1 C.GtkLevelBarMode

	arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))
	arg1 = (C.GtkLevelBarMode)(mode)

	C.gtk_level_bar_set_mode(arg0, arg1)
}

// SetValue sets the value of the LevelBar:value property.
func (s levelBar) SetValue(value float64) {
	var arg0 *C.GtkLevelBar
	var arg1 C.double

	arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))
	arg1 = C.double(value)

	C.gtk_level_bar_set_value(arg0, arg1)
}

// LinkButton: a GtkLinkButton is a Button with a hyperlink, similar to the one
// used by web browsers, which triggers an action when clicked. It is useful to
// show quick links to resources.
//
// A link button is created by calling either gtk_link_button_new() or
// gtk_link_button_new_with_label(). If using the former, the URI you pass to
// the constructor is used as a label for the widget.
//
// The URI bound to a GtkLinkButton can be set specifically using
// gtk_link_button_set_uri(), and retrieved using gtk_link_button_get_uri().
//
// By default, GtkLinkButton calls gtk_show_uri() when the button is clicked.
// This behaviour can be overridden by connecting to the
// LinkButton::activate-link signal and returning true from the signal handler.
//
//
// CSS nodes
//
// GtkLinkButton has a single CSS node with name button. To differentiate it
// from a plain Button, it gets the .link style class.
//
//
// Accessibility
//
// GtkLinkButton uses the K_ACCESSIBLE_ROLE_LINK role.
type LinkButton interface {
	Button
	Accessible
	Actionable
	Buildable
	ConstraintTarget

	// URI retrieves the URI set using gtk_link_button_set_uri().
	URI() string
	// Visited retrieves the “visited” state of the URI where the LinkButton
	// points. The button becomes visited when it is clicked. If the URI is
	// changed on the button, the “visited” state is unset again.
	//
	// The state may also be changed using gtk_link_button_set_visited().
	Visited() bool
	// SetURI sets @uri as the URI where the LinkButton points. As a side-effect
	// this unsets the “visited” state of the button.
	SetURI(uri string)
	// SetVisited sets the “visited” state of the URI where the LinkButton
	// points. See gtk_link_button_get_visited() for more details.
	SetVisited(visited bool)
}

// linkButton implements the LinkButton interface.
type linkButton struct {
	Button
	Accessible
	Actionable
	Buildable
	ConstraintTarget
}

var _ LinkButton = (*linkButton)(nil)

// WrapLinkButton wraps a GObject to the right type. It is
// primarily used internally.
func WrapLinkButton(obj *externglib.Object) LinkButton {
	return LinkButton{
		Button:           WrapButton(obj),
		Accessible:       WrapAccessible(obj),
		Actionable:       WrapActionable(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
	}
}

func marshalLinkButton(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapLinkButton(obj), nil
}

// NewLinkButton constructs a class LinkButton.
func NewLinkButton(uri string) LinkButton {
	var arg1 *C.char

	arg1 = (*C.char)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))

	var cret C.GtkLinkButton

	cret = C.gtk_link_button_new(arg1)

	var linkButton LinkButton

	linkButton = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(LinkButton)

	return linkButton
}

// NewLinkButtonWithLabel constructs a class LinkButton.
func NewLinkButtonWithLabel(uri string, label string) LinkButton {
	var arg1 *C.char
	var arg2 *C.char

	arg1 = (*C.char)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.char)(C.CString(label))
	defer C.free(unsafe.Pointer(arg2))

	var cret C.GtkLinkButton

	cret = C.gtk_link_button_new_with_label(arg1, arg2)

	var linkButton LinkButton

	linkButton = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(LinkButton)

	return linkButton
}

// URI retrieves the URI set using gtk_link_button_set_uri().
func (l linkButton) URI() string {
	var arg0 *C.GtkLinkButton

	arg0 = (*C.GtkLinkButton)(unsafe.Pointer(l.Native()))

	var cret *C.char

	cret = C.gtk_link_button_get_uri(arg0)

	var utf8 string

	utf8 = C.GoString(cret)

	return utf8
}

// Visited retrieves the “visited” state of the URI where the LinkButton
// points. The button becomes visited when it is clicked. If the URI is
// changed on the button, the “visited” state is unset again.
//
// The state may also be changed using gtk_link_button_set_visited().
func (l linkButton) Visited() bool {
	var arg0 *C.GtkLinkButton

	arg0 = (*C.GtkLinkButton)(unsafe.Pointer(l.Native()))

	var cret C.gboolean

	cret = C.gtk_link_button_get_visited(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// SetURI sets @uri as the URI where the LinkButton points. As a side-effect
// this unsets the “visited” state of the button.
func (l linkButton) SetURI(uri string) {
	var arg0 *C.GtkLinkButton
	var arg1 *C.char

	arg0 = (*C.GtkLinkButton)(unsafe.Pointer(l.Native()))
	arg1 = (*C.char)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_link_button_set_uri(arg0, arg1)
}

// SetVisited sets the “visited” state of the URI where the LinkButton
// points. See gtk_link_button_get_visited() for more details.
func (l linkButton) SetVisited(visited bool) {
	var arg0 *C.GtkLinkButton
	var arg1 C.gboolean

	arg0 = (*C.GtkLinkButton)(unsafe.Pointer(l.Native()))
	if visited {
		arg1 = C.gboolean(1)
	}

	C.gtk_link_button_set_visited(arg0, arg1)
}

// ListBox: a GtkListBox is a vertical container that contains GtkListBoxRow
// children. These rows can by dynamically sorted and filtered, and headers can
// be added dynamically depending on the row content. It also allows keyboard
// and mouse navigation and selection like a typical list.
//
// Using GtkListBox is often an alternative to TreeView, especially when the
// list contents has a more complicated layout than what is allowed by a
// CellRenderer, or when the contents is interactive (i.e. has a button in it).
//
// Although a ListBox must have only ListBoxRow children you can add any kind of
// widget to it via gtk_list_box_prepend(), gtk_list_box_append() and
// gtk_list_box_insert() and a ListBoxRow widget will automatically be inserted
// between the list and the widget.
//
// ListBoxRows can be marked as activatable or selectable. If a row is
// activatable, ListBox::row-activated will be emitted for it when the user
// tries to activate it. If it is selectable, the row will be marked as selected
// when the user tries to select it.
//
//
// GtkListBox as GtkBuildable
//
// The GtkListBox implementation of the Buildable interface supports setting a
// child as the placeholder by specifying “placeholder” as the “type” attribute
// of a <child> element. See gtk_list_box_set_placeholder() for info.
//
// CSS nodes
//
//    list[.separators][.rich-list][.navigation-sidebar]
//    ╰── row[.activatable]
//
// GtkListBox uses a single CSS node named list. It may carry the .separators
// style class, when the ListBox:show-separators property is set. Each
// GtkListBoxRow uses a single CSS node named row. The row nodes get the
// .activatable style class added when appropriate.
//
// The main list node may also carry style classes to select the style of list
// presentation (ListContainers.html#list-styles): .rich-list,
// .navigation-sidebar or .data-table.
//
//
// Accessibility
//
// GtkListBox uses the K_ACCESSIBLE_ROLE_LIST role and GtkListBoxRow uses the
// K_ACCESSIBLE_ROLE_LIST_ITEM role.
type ListBox interface {
	Widget
	Accessible
	Buildable
	ConstraintTarget

	// Append: append a widget to the list. If a sort function is set, the
	// widget will actually be inserted at the calculated position.
	Append(child Widget)
	// BindModel binds @model to @box.
	//
	// If @box was already bound to a model, that previous binding is destroyed.
	//
	// The contents of @box are cleared and then filled with widgets that
	// represent items from @model. @box is updated whenever @model changes. If
	// @model is nil, @box is left empty.
	//
	// It is undefined to add or remove widgets directly (for example, with
	// gtk_list_box_insert()) while @box is bound to a model.
	//
	// Note that using a model is incompatible with the filtering and sorting
	// functionality in GtkListBox. When using a model, filtering and sorting
	// should be implemented by the model.
	BindModel()
	// DragHighlightRow: this is a helper function for implementing DnD onto a
	// ListBox. The passed in @row will be highlighted by setting the
	// K_STATE_FLAG_DROP_ACTIVE state and any previously highlighted row will be
	// unhighlighted.
	//
	// The row will also be unhighlighted when the widget gets a drag leave
	// event.
	DragHighlightRow(row ListBoxRow)
	// DragUnhighlightRow: if a row has previously been highlighted via
	// gtk_list_box_drag_highlight_row() it will have the highlight removed.
	DragUnhighlightRow()
	// ActivateOnSingleClick returns whether rows activate on single clicks.
	ActivateOnSingleClick() bool
	// Adjustment gets the adjustment (if any) that the widget uses to for
	// vertical scrolling.
	Adjustment() Adjustment
	// RowAtIndex gets the n-th child in the list (not counting headers). If
	// @_index is negative or larger than the number of items in the list, nil
	// is returned.
	RowAtIndex(index_ int) ListBoxRow
	// RowAtY gets the row at the @y position.
	RowAtY(y int) ListBoxRow
	// SelectedRow gets the selected row.
	//
	// Note that the box may allow multiple selection, in which case you should
	// use gtk_list_box_selected_foreach() to find all selected rows.
	SelectedRow() ListBoxRow
	// SelectedRows creates a list of all selected children.
	SelectedRows() *glib.List
	// SelectionMode gets the selection mode of the listbox.
	SelectionMode() SelectionMode
	// ShowSeparators returns whether the list box should show separators
	// between rows.
	ShowSeparators() bool
	// Insert: insert the @child into the @box at @position. If a sort function
	// is set, the widget will actually be inserted at the calculated position.
	//
	// If @position is -1, or larger than the total number of items in the @box,
	// then the @child will be appended to the end.
	Insert(child Widget, position int)
	// InvalidateFilter: update the filtering for all rows. Call this when
	// result of the filter function on the @box is changed due to an external
	// factor. For instance, this would be used if the filter function just
	// looked for a specific search string and the entry with the search string
	// has changed.
	InvalidateFilter()
	// InvalidateHeaders: update the separators for all rows. Call this when
	// result of the header function on the @box is changed due to an external
	// factor.
	InvalidateHeaders()
	// InvalidateSort: update the sorting for all rows. Call this when result of
	// the sort function on the @box is changed due to an external factor.
	InvalidateSort()
	// Prepend: prepend a widget to the list. If a sort function is set, the
	// widget will actually be inserted at the calculated position.
	Prepend(child Widget)
	// Remove removes a child from @box.
	Remove(child Widget)
	// SelectAll: select all children of @box, if the selection mode allows it.
	SelectAll()
	// SelectRow: make @row the currently selected row.
	SelectRow(row ListBoxRow)
	// SelectedForeach calls a function for each selected child.
	//
	// Note that the selection cannot be modified from within this function.
	SelectedForeach()
	// SetActivateOnSingleClick: if @single is true, rows will be activated when
	// you click on them, otherwise you need to double-click.
	SetActivateOnSingleClick(single bool)
	// SetAdjustment sets the adjustment (if any) that the widget uses to for
	// vertical scrolling. For instance, this is used to get the page size for
	// PageUp/Down key handling.
	//
	// In the normal case when the @box is packed inside a ScrolledWindow the
	// adjustment from that will be picked up automatically, so there is no need
	// to manually do that.
	SetAdjustment(adjustment Adjustment)
	// SetFilterFunc: by setting a filter function on the @box one can decide
	// dynamically which of the rows to show. For instance, to implement a
	// search function on a list that filters the original list to only show the
	// matching rows.
	//
	// The @filter_func will be called for each row after the call, and it will
	// continue to be called each time a row changes (via
	// gtk_list_box_row_changed()) or when gtk_list_box_invalidate_filter() is
	// called.
	//
	// Note that using a filter function is incompatible with using a model (see
	// gtk_list_box_bind_model()).
	SetFilterFunc()
	// SetHeaderFunc: by setting a header function on the @box one can
	// dynamically add headers in front of rows, depending on the contents of
	// the row and its position in the list. For instance, one could use it to
	// add headers in front of the first item of a new kind, in a list sorted by
	// the kind.
	//
	// The @update_header can look at the current header widget using
	// gtk_list_box_row_get_header() and either update the state of the widget
	// as needed, or set a new one using gtk_list_box_row_set_header(). If no
	// header is needed, set the header to nil.
	//
	// Note that you may get many calls @update_header to this for a particular
	// row when e.g. changing things that don’t affect the header. In this case
	// it is important for performance to not blindly replace an existing header
	// with an identical one.
	//
	// The @update_header function will be called for each row after the call,
	// and it will continue to be called each time a row changes (via
	// gtk_list_box_row_changed()) and when the row before changes (either by
	// gtk_list_box_row_changed() on the previous row, or when the previous row
	// becomes a different row). It is also called for all rows when
	// gtk_list_box_invalidate_headers() is called.
	SetHeaderFunc()
	// SetPlaceholder sets the placeholder widget that is shown in the list when
	// it doesn't display any visible children.
	SetPlaceholder(placeholder Widget)
	// SetSelectionMode sets how selection works in the listbox. See
	// SelectionMode for details.
	SetSelectionMode(mode SelectionMode)
	// SetShowSeparators sets whether the list box should show separators
	// between rows.
	SetShowSeparators(showSeparators bool)
	// SetSortFunc: by setting a sort function on the @box one can dynamically
	// reorder the rows of the list, based on the contents of the rows.
	//
	// The @sort_func will be called for each row after the call, and will
	// continue to be called each time a row changes (via
	// gtk_list_box_row_changed()) and when gtk_list_box_invalidate_sort() is
	// called.
	//
	// Note that using a sort function is incompatible with using a model (see
	// gtk_list_box_bind_model()).
	SetSortFunc()
	// UnselectAll: unselect all children of @box, if the selection mode allows
	// it.
	UnselectAll()
	// UnselectRow unselects a single row of @box, if the selection mode allows
	// it.
	UnselectRow(row ListBoxRow)
}

// listBox implements the ListBox interface.
type listBox struct {
	Widget
	Accessible
	Buildable
	ConstraintTarget
}

var _ ListBox = (*listBox)(nil)

// WrapListBox wraps a GObject to the right type. It is
// primarily used internally.
func WrapListBox(obj *externglib.Object) ListBox {
	return ListBox{
		Widget:           WrapWidget(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
	}
}

func marshalListBox(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapListBox(obj), nil
}

// NewListBox constructs a class ListBox.
func NewListBox() ListBox {
	var cret C.GtkListBox

	cret = C.gtk_list_box_new()

	var listBox ListBox

	listBox = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(ListBox)

	return listBox
}

// Append: append a widget to the list. If a sort function is set, the
// widget will actually be inserted at the calculated position.
func (b listBox) Append(child Widget) {
	var arg0 *C.GtkListBox
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_list_box_append(arg0, arg1)
}

// BindModel binds @model to @box.
//
// If @box was already bound to a model, that previous binding is destroyed.
//
// The contents of @box are cleared and then filled with widgets that
// represent items from @model. @box is updated whenever @model changes. If
// @model is nil, @box is left empty.
//
// It is undefined to add or remove widgets directly (for example, with
// gtk_list_box_insert()) while @box is bound to a model.
//
// Note that using a model is incompatible with the filtering and sorting
// functionality in GtkListBox. When using a model, filtering and sorting
// should be implemented by the model.
func (b listBox) BindModel() {
	var arg0 *C.GtkListBox

	arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))

	C.gtk_list_box_bind_model(arg0)
}

// DragHighlightRow: this is a helper function for implementing DnD onto a
// ListBox. The passed in @row will be highlighted by setting the
// K_STATE_FLAG_DROP_ACTIVE state and any previously highlighted row will be
// unhighlighted.
//
// The row will also be unhighlighted when the widget gets a drag leave
// event.
func (b listBox) DragHighlightRow(row ListBoxRow) {
	var arg0 *C.GtkListBox
	var arg1 *C.GtkListBoxRow

	arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))
	arg1 = (*C.GtkListBoxRow)(unsafe.Pointer(row.Native()))

	C.gtk_list_box_drag_highlight_row(arg0, arg1)
}

// DragUnhighlightRow: if a row has previously been highlighted via
// gtk_list_box_drag_highlight_row() it will have the highlight removed.
func (b listBox) DragUnhighlightRow() {
	var arg0 *C.GtkListBox

	arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))

	C.gtk_list_box_drag_unhighlight_row(arg0)
}

// ActivateOnSingleClick returns whether rows activate on single clicks.
func (b listBox) ActivateOnSingleClick() bool {
	var arg0 *C.GtkListBox

	arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))

	var cret C.gboolean

	cret = C.gtk_list_box_get_activate_on_single_click(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// Adjustment gets the adjustment (if any) that the widget uses to for
// vertical scrolling.
func (b listBox) Adjustment() Adjustment {
	var arg0 *C.GtkListBox

	arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))

	var cret *C.GtkAdjustment

	cret = C.gtk_list_box_get_adjustment(arg0)

	var adjustment Adjustment

	adjustment = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Adjustment)

	return adjustment
}

// RowAtIndex gets the n-th child in the list (not counting headers). If
// @_index is negative or larger than the number of items in the list, nil
// is returned.
func (b listBox) RowAtIndex(index_ int) ListBoxRow {
	var arg0 *C.GtkListBox
	var arg1 C.int

	arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))
	arg1 = C.int(index_)

	var cret *C.GtkListBoxRow

	cret = C.gtk_list_box_get_row_at_index(arg0, arg1)

	var listBoxRow ListBoxRow

	listBoxRow = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(ListBoxRow)

	return listBoxRow
}

// RowAtY gets the row at the @y position.
func (b listBox) RowAtY(y int) ListBoxRow {
	var arg0 *C.GtkListBox
	var arg1 C.int

	arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))
	arg1 = C.int(y)

	var cret *C.GtkListBoxRow

	cret = C.gtk_list_box_get_row_at_y(arg0, arg1)

	var listBoxRow ListBoxRow

	listBoxRow = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(ListBoxRow)

	return listBoxRow
}

// SelectedRow gets the selected row.
//
// Note that the box may allow multiple selection, in which case you should
// use gtk_list_box_selected_foreach() to find all selected rows.
func (b listBox) SelectedRow() ListBoxRow {
	var arg0 *C.GtkListBox

	arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))

	var cret *C.GtkListBoxRow

	cret = C.gtk_list_box_get_selected_row(arg0)

	var listBoxRow ListBoxRow

	listBoxRow = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(ListBoxRow)

	return listBoxRow
}

// SelectedRows creates a list of all selected children.
func (b listBox) SelectedRows() *glib.List {
	var arg0 *C.GtkListBox

	arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))

	var cret *C.GList

	cret = C.gtk_list_box_get_selected_rows(arg0)

	var list *glib.List

	list = glib.WrapList(unsafe.Pointer(cret))
	runtime.SetFinalizer(list, func(v *glib.List) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return list
}

// SelectionMode gets the selection mode of the listbox.
func (b listBox) SelectionMode() SelectionMode {
	var arg0 *C.GtkListBox

	arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))

	var cret C.GtkSelectionMode

	cret = C.gtk_list_box_get_selection_mode(arg0)

	var selectionMode SelectionMode

	selectionMode = SelectionMode(cret)

	return selectionMode
}

// ShowSeparators returns whether the list box should show separators
// between rows.
func (b listBox) ShowSeparators() bool {
	var arg0 *C.GtkListBox

	arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))

	var cret C.gboolean

	cret = C.gtk_list_box_get_show_separators(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// Insert: insert the @child into the @box at @position. If a sort function
// is set, the widget will actually be inserted at the calculated position.
//
// If @position is -1, or larger than the total number of items in the @box,
// then the @child will be appended to the end.
func (b listBox) Insert(child Widget, position int) {
	var arg0 *C.GtkListBox
	var arg1 *C.GtkWidget
	var arg2 C.int

	arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	arg2 = C.int(position)

	C.gtk_list_box_insert(arg0, arg1, arg2)
}

// InvalidateFilter: update the filtering for all rows. Call this when
// result of the filter function on the @box is changed due to an external
// factor. For instance, this would be used if the filter function just
// looked for a specific search string and the entry with the search string
// has changed.
func (b listBox) InvalidateFilter() {
	var arg0 *C.GtkListBox

	arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))

	C.gtk_list_box_invalidate_filter(arg0)
}

// InvalidateHeaders: update the separators for all rows. Call this when
// result of the header function on the @box is changed due to an external
// factor.
func (b listBox) InvalidateHeaders() {
	var arg0 *C.GtkListBox

	arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))

	C.gtk_list_box_invalidate_headers(arg0)
}

// InvalidateSort: update the sorting for all rows. Call this when result of
// the sort function on the @box is changed due to an external factor.
func (b listBox) InvalidateSort() {
	var arg0 *C.GtkListBox

	arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))

	C.gtk_list_box_invalidate_sort(arg0)
}

// Prepend: prepend a widget to the list. If a sort function is set, the
// widget will actually be inserted at the calculated position.
func (b listBox) Prepend(child Widget) {
	var arg0 *C.GtkListBox
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_list_box_prepend(arg0, arg1)
}

// Remove removes a child from @box.
func (b listBox) Remove(child Widget) {
	var arg0 *C.GtkListBox
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_list_box_remove(arg0, arg1)
}

// SelectAll: select all children of @box, if the selection mode allows it.
func (b listBox) SelectAll() {
	var arg0 *C.GtkListBox

	arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))

	C.gtk_list_box_select_all(arg0)
}

// SelectRow: make @row the currently selected row.
func (b listBox) SelectRow(row ListBoxRow) {
	var arg0 *C.GtkListBox
	var arg1 *C.GtkListBoxRow

	arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))
	arg1 = (*C.GtkListBoxRow)(unsafe.Pointer(row.Native()))

	C.gtk_list_box_select_row(arg0, arg1)
}

// SelectedForeach calls a function for each selected child.
//
// Note that the selection cannot be modified from within this function.
func (b listBox) SelectedForeach() {
	var arg0 *C.GtkListBox

	arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))

	C.gtk_list_box_selected_foreach(arg0)
}

// SetActivateOnSingleClick: if @single is true, rows will be activated when
// you click on them, otherwise you need to double-click.
func (b listBox) SetActivateOnSingleClick(single bool) {
	var arg0 *C.GtkListBox
	var arg1 C.gboolean

	arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))
	if single {
		arg1 = C.gboolean(1)
	}

	C.gtk_list_box_set_activate_on_single_click(arg0, arg1)
}

// SetAdjustment sets the adjustment (if any) that the widget uses to for
// vertical scrolling. For instance, this is used to get the page size for
// PageUp/Down key handling.
//
// In the normal case when the @box is packed inside a ScrolledWindow the
// adjustment from that will be picked up automatically, so there is no need
// to manually do that.
func (b listBox) SetAdjustment(adjustment Adjustment) {
	var arg0 *C.GtkListBox
	var arg1 *C.GtkAdjustment

	arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))
	arg1 = (*C.GtkAdjustment)(unsafe.Pointer(adjustment.Native()))

	C.gtk_list_box_set_adjustment(arg0, arg1)
}

// SetFilterFunc: by setting a filter function on the @box one can decide
// dynamically which of the rows to show. For instance, to implement a
// search function on a list that filters the original list to only show the
// matching rows.
//
// The @filter_func will be called for each row after the call, and it will
// continue to be called each time a row changes (via
// gtk_list_box_row_changed()) or when gtk_list_box_invalidate_filter() is
// called.
//
// Note that using a filter function is incompatible with using a model (see
// gtk_list_box_bind_model()).
func (b listBox) SetFilterFunc() {
	var arg0 *C.GtkListBox

	arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))

	C.gtk_list_box_set_filter_func(arg0)
}

// SetHeaderFunc: by setting a header function on the @box one can
// dynamically add headers in front of rows, depending on the contents of
// the row and its position in the list. For instance, one could use it to
// add headers in front of the first item of a new kind, in a list sorted by
// the kind.
//
// The @update_header can look at the current header widget using
// gtk_list_box_row_get_header() and either update the state of the widget
// as needed, or set a new one using gtk_list_box_row_set_header(). If no
// header is needed, set the header to nil.
//
// Note that you may get many calls @update_header to this for a particular
// row when e.g. changing things that don’t affect the header. In this case
// it is important for performance to not blindly replace an existing header
// with an identical one.
//
// The @update_header function will be called for each row after the call,
// and it will continue to be called each time a row changes (via
// gtk_list_box_row_changed()) and when the row before changes (either by
// gtk_list_box_row_changed() on the previous row, or when the previous row
// becomes a different row). It is also called for all rows when
// gtk_list_box_invalidate_headers() is called.
func (b listBox) SetHeaderFunc() {
	var arg0 *C.GtkListBox

	arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))

	C.gtk_list_box_set_header_func(arg0)
}

// SetPlaceholder sets the placeholder widget that is shown in the list when
// it doesn't display any visible children.
func (b listBox) SetPlaceholder(placeholder Widget) {
	var arg0 *C.GtkListBox
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(placeholder.Native()))

	C.gtk_list_box_set_placeholder(arg0, arg1)
}

// SetSelectionMode sets how selection works in the listbox. See
// SelectionMode for details.
func (b listBox) SetSelectionMode(mode SelectionMode) {
	var arg0 *C.GtkListBox
	var arg1 C.GtkSelectionMode

	arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))
	arg1 = (C.GtkSelectionMode)(mode)

	C.gtk_list_box_set_selection_mode(arg0, arg1)
}

// SetShowSeparators sets whether the list box should show separators
// between rows.
func (b listBox) SetShowSeparators(showSeparators bool) {
	var arg0 *C.GtkListBox
	var arg1 C.gboolean

	arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))
	if showSeparators {
		arg1 = C.gboolean(1)
	}

	C.gtk_list_box_set_show_separators(arg0, arg1)
}

// SetSortFunc: by setting a sort function on the @box one can dynamically
// reorder the rows of the list, based on the contents of the rows.
//
// The @sort_func will be called for each row after the call, and will
// continue to be called each time a row changes (via
// gtk_list_box_row_changed()) and when gtk_list_box_invalidate_sort() is
// called.
//
// Note that using a sort function is incompatible with using a model (see
// gtk_list_box_bind_model()).
func (b listBox) SetSortFunc() {
	var arg0 *C.GtkListBox

	arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))

	C.gtk_list_box_set_sort_func(arg0)
}

// UnselectAll: unselect all children of @box, if the selection mode allows
// it.
func (b listBox) UnselectAll() {
	var arg0 *C.GtkListBox

	arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))

	C.gtk_list_box_unselect_all(arg0)
}

// UnselectRow unselects a single row of @box, if the selection mode allows
// it.
func (b listBox) UnselectRow(row ListBoxRow) {
	var arg0 *C.GtkListBox
	var arg1 *C.GtkListBoxRow

	arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))
	arg1 = (*C.GtkListBoxRow)(unsafe.Pointer(row.Native()))

	C.gtk_list_box_unselect_row(arg0, arg1)
}

// LockButton: gtkLockButton is a widget that can be used in control panels or
// preference dialogs to allow users to obtain and revoke authorizations needed
// to operate the controls. The required authorization is represented by a
// #GPermission object. Concrete implementations of #GPermission may use
// PolicyKit or some other authorization framework. To obtain a PolicyKit-based
// #GPermission, use polkit_permission_new().
//
// If the user is not currently allowed to perform the action, but can obtain
// the permission, the widget looks like this:
//
// ! (lockbutton-locked.png)
//
// and the user can click the button to request the permission. Depending on the
// platform, this may pop up an authentication dialog or ask the user to
// authenticate in some other way. Once the user has obtained the permission,
// the widget changes to this:
//
// ! (lockbutton-unlocked.png)
//
// and the permission can be dropped again by clicking the button. If the user
// is not able to obtain the permission at all, the widget looks like this:
//
// ! (lockbutton-sorry.png)
//
// If the user has the permission and cannot drop it, the button is hidden.
//
// The text (and tooltips) that are shown in the various cases can be adjusted
// with the LockButton:text-lock, LockButton:text-unlock,
// LockButton:tooltip-lock, LockButton:tooltip-unlock and
// LockButton:tooltip-not-authorized properties.
type LockButton interface {
	Button
	Accessible
	Actionable
	Buildable
	ConstraintTarget

	// Permission obtains the #GPermission object that controls @button.
	Permission() gio.Permission
	// SetPermission sets the #GPermission object that controls @button.
	SetPermission(permission gio.Permission)
}

// lockButton implements the LockButton interface.
type lockButton struct {
	Button
	Accessible
	Actionable
	Buildable
	ConstraintTarget
}

var _ LockButton = (*lockButton)(nil)

// WrapLockButton wraps a GObject to the right type. It is
// primarily used internally.
func WrapLockButton(obj *externglib.Object) LockButton {
	return LockButton{
		Button:           WrapButton(obj),
		Accessible:       WrapAccessible(obj),
		Actionable:       WrapActionable(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
	}
}

func marshalLockButton(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapLockButton(obj), nil
}

// NewLockButton constructs a class LockButton.
func NewLockButton(permission gio.Permission) LockButton {
	var arg1 *C.GPermission

	arg1 = (*C.GPermission)(unsafe.Pointer(permission.Native()))

	var cret C.GtkLockButton

	cret = C.gtk_lock_button_new(arg1)

	var lockButton LockButton

	lockButton = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(LockButton)

	return lockButton
}

// Permission obtains the #GPermission object that controls @button.
func (b lockButton) Permission() gio.Permission {
	var arg0 *C.GtkLockButton

	arg0 = (*C.GtkLockButton)(unsafe.Pointer(b.Native()))

	var cret *C.GPermission

	cret = C.gtk_lock_button_get_permission(arg0)

	var permission gio.Permission

	permission = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(gio.Permission)

	return permission
}

// SetPermission sets the #GPermission object that controls @button.
func (b lockButton) SetPermission(permission gio.Permission) {
	var arg0 *C.GtkLockButton
	var arg1 *C.GPermission

	arg0 = (*C.GtkLockButton)(unsafe.Pointer(b.Native()))
	arg1 = (*C.GPermission)(unsafe.Pointer(permission.Native()))

	C.gtk_lock_button_set_permission(arg0, arg1)
}

// MenuButton: the MenuButton widget is used to display a popup when clicked on.
// This popup can be provided either as a Popover or as an abstract Model.
//
// The MenuButton widget can show either an icon (set with the
// MenuButton:icon-name property) or a label (set with the MenuButton:label
// property). If neither is explicitly set, a Image is automatically created,
// using an arrow image oriented according to MenuButton:direction or the
// generic “open-menu-symbolic” icon if the direction is not set.
//
// The positioning of the popup is determined by the MenuButton:direction
// property of the menu button.
//
// For menus, the Widget:halign and Widget:valign properties of the menu are
// also taken into account. For example, when the direction is GTK_ARROW_DOWN
// and the horizontal alignment is GTK_ALIGN_START, the menu will be positioned
// below the button, with the starting edge (depending on the text direction) of
// the menu aligned with the starting edge of the button. If there is not enough
// space below the button, the menu is popped up above the button instead. If
// the alignment would move part of the menu offscreen, it is “pushed in”.
//
// Direction = Down
//
// - halign = start
//
//    ! (down-start.png)
//
// - halign = center
//
//    ! (down-center.png)
//
// - halign = end
//
//    ! (down-end.png)
//
// Direction = Up
//
// - halign = start
//
//    ! (up-start.png)
//
// - halign = center
//
//    ! (up-center.png)
//
// - halign = end
//
//    ! (up-end.png)
//
// Direction = Left
//
// - valign = start
//
//    ! (left-start.png)
//
// - valign = center
//
//    ! (left-center.png)
//
// - valign = end
//
//    ! (left-end.png)
//
// Direction = Right
//
// - valign = start
//
//    ! (right-start.png)
//
// - valign = center
//
//    ! (right-center.png)
//
// - valign = end
//
//    ! (right-end.png)
//
// CSS nodes
//
//    menubutton
//    ╰── button.toggle
//        ╰── [content]
//
// GtkMenuButton has a single CSS node with name menubutton which contains a
// toggle button node.
//
//
// Accessibility
//
// GtkMenuButton uses the K_ACCESSIBLE_ROLE_BUTTON role.
type MenuButton interface {
	Widget
	Accessible
	Buildable
	ConstraintTarget

	// Direction returns the direction the popup will be pointing at when popped
	// up.
	Direction() ArrowType
	// HasFrame returns whether the button has a frame.
	HasFrame() bool
	// IconName gets the name of the icon shown in the button.
	IconName() string
	// Label gets the label shown in the button
	Label() string
	// MenuModel returns the Model used to generate the popup.
	MenuModel() gio.MenuModel
	// Popover returns the Popover that pops out of the button. If the button is
	// not using a Popover, this function returns nil.
	Popover() Popover
	// UseUnderline returns whether an embedded underline in the text indicates
	// a mnemonic. See gtk_menu_button_set_use_underline().
	UseUnderline() bool
	// Popdown dismiss the menu.
	Popdown()
	// Popup: pop up the menu.
	Popup()
	// SetCreatePopupFunc sets @func to be called when a popup is about to be
	// shown. @func should use one of
	//
	//    - gtk_menu_button_set_popover()
	//    - gtk_menu_button_set_menu_model()
	//
	// to set a popup for @menu_button. If @func is non-nil, @menu_button will
	// always be sensitive.
	//
	// Using this function will not reset the menu widget attached to
	// @menu_button. Instead, this can be done manually in @func.
	SetCreatePopupFunc()
	// SetDirection sets the direction in which the popup will be popped up, as
	// well as changing the arrow’s direction. The child will not be changed to
	// an arrow if it was customized.
	//
	// If the does not fit in the available space in the given direction, GTK
	// will its best to keep it inside the screen and fully visible.
	//
	// If you pass GTK_ARROW_NONE for a @direction, the popup will behave as if
	// you passed GTK_ARROW_DOWN (although you won’t see any arrows).
	SetDirection(direction ArrowType)
	// SetHasFrame sets the style of the button.
	SetHasFrame(hasFrame bool)
	// SetIconName sets the name of an icon to show inside the menu button.
	SetIconName(iconName string)
	// SetLabel sets the label to show inside the menu button.
	SetLabel(label string)
	// SetMenuModel sets the Model from which the popup will be constructed, or
	// nil to dissociate any existing menu model and disable the button.
	//
	// A Popover will be created from the menu model with
	// gtk_popover_menu_new_from_model(). Actions will be connected as
	// documented for this function.
	//
	// If MenuButton:popover is already set, it will be dissociated from the
	// @menu_button, and the property is set to nil.
	SetMenuModel(menuModel gio.MenuModel)
	// SetPopover sets the Popover that will be popped up when the @menu_button
	// is clicked, or nil to dissociate any existing popover and disable the
	// button.
	//
	// If MenuButton:menu-model is set, the menu model is dissociated from the
	// @menu_button, and the property is set to nil.
	SetPopover(popover Widget)
	// SetUseUnderline: if true, an underline in the text indicates the next
	// character should be used for the mnemonic accelerator key.
	SetUseUnderline(useUnderline bool)
}

// menuButton implements the MenuButton interface.
type menuButton struct {
	Widget
	Accessible
	Buildable
	ConstraintTarget
}

var _ MenuButton = (*menuButton)(nil)

// WrapMenuButton wraps a GObject to the right type. It is
// primarily used internally.
func WrapMenuButton(obj *externglib.Object) MenuButton {
	return MenuButton{
		Widget:           WrapWidget(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
	}
}

func marshalMenuButton(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapMenuButton(obj), nil
}

// NewMenuButton constructs a class MenuButton.
func NewMenuButton() MenuButton {
	var cret C.GtkMenuButton

	cret = C.gtk_menu_button_new()

	var menuButton MenuButton

	menuButton = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(MenuButton)

	return menuButton
}

// Direction returns the direction the popup will be pointing at when popped
// up.
func (m menuButton) Direction() ArrowType {
	var arg0 *C.GtkMenuButton

	arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))

	var cret C.GtkArrowType

	cret = C.gtk_menu_button_get_direction(arg0)

	var arrowType ArrowType

	arrowType = ArrowType(cret)

	return arrowType
}

// HasFrame returns whether the button has a frame.
func (m menuButton) HasFrame() bool {
	var arg0 *C.GtkMenuButton

	arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))

	var cret C.gboolean

	cret = C.gtk_menu_button_get_has_frame(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// IconName gets the name of the icon shown in the button.
func (m menuButton) IconName() string {
	var arg0 *C.GtkMenuButton

	arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))

	var cret *C.char

	cret = C.gtk_menu_button_get_icon_name(arg0)

	var utf8 string

	utf8 = C.GoString(cret)

	return utf8
}

// Label gets the label shown in the button
func (m menuButton) Label() string {
	var arg0 *C.GtkMenuButton

	arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))

	var cret *C.char

	cret = C.gtk_menu_button_get_label(arg0)

	var utf8 string

	utf8 = C.GoString(cret)

	return utf8
}

// MenuModel returns the Model used to generate the popup.
func (m menuButton) MenuModel() gio.MenuModel {
	var arg0 *C.GtkMenuButton

	arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))

	var cret *C.GMenuModel

	cret = C.gtk_menu_button_get_menu_model(arg0)

	var menuModel gio.MenuModel

	menuModel = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(gio.MenuModel)

	return menuModel
}

// Popover returns the Popover that pops out of the button. If the button is
// not using a Popover, this function returns nil.
func (m menuButton) Popover() Popover {
	var arg0 *C.GtkMenuButton

	arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))

	var cret *C.GtkPopover

	cret = C.gtk_menu_button_get_popover(arg0)

	var popover Popover

	popover = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Popover)

	return popover
}

// UseUnderline returns whether an embedded underline in the text indicates
// a mnemonic. See gtk_menu_button_set_use_underline().
func (m menuButton) UseUnderline() bool {
	var arg0 *C.GtkMenuButton

	arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))

	var cret C.gboolean

	cret = C.gtk_menu_button_get_use_underline(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// Popdown dismiss the menu.
func (m menuButton) Popdown() {
	var arg0 *C.GtkMenuButton

	arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))

	C.gtk_menu_button_popdown(arg0)
}

// Popup: pop up the menu.
func (m menuButton) Popup() {
	var arg0 *C.GtkMenuButton

	arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))

	C.gtk_menu_button_popup(arg0)
}

// SetCreatePopupFunc sets @func to be called when a popup is about to be
// shown. @func should use one of
//
//    - gtk_menu_button_set_popover()
//    - gtk_menu_button_set_menu_model()
//
// to set a popup for @menu_button. If @func is non-nil, @menu_button will
// always be sensitive.
//
// Using this function will not reset the menu widget attached to
// @menu_button. Instead, this can be done manually in @func.
func (m menuButton) SetCreatePopupFunc() {
	var arg0 *C.GtkMenuButton

	arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))

	C.gtk_menu_button_set_create_popup_func(arg0)
}

// SetDirection sets the direction in which the popup will be popped up, as
// well as changing the arrow’s direction. The child will not be changed to
// an arrow if it was customized.
//
// If the does not fit in the available space in the given direction, GTK
// will its best to keep it inside the screen and fully visible.
//
// If you pass GTK_ARROW_NONE for a @direction, the popup will behave as if
// you passed GTK_ARROW_DOWN (although you won’t see any arrows).
func (m menuButton) SetDirection(direction ArrowType) {
	var arg0 *C.GtkMenuButton
	var arg1 C.GtkArrowType

	arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))
	arg1 = (C.GtkArrowType)(direction)

	C.gtk_menu_button_set_direction(arg0, arg1)
}

// SetHasFrame sets the style of the button.
func (m menuButton) SetHasFrame(hasFrame bool) {
	var arg0 *C.GtkMenuButton
	var arg1 C.gboolean

	arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))
	if hasFrame {
		arg1 = C.gboolean(1)
	}

	C.gtk_menu_button_set_has_frame(arg0, arg1)
}

// SetIconName sets the name of an icon to show inside the menu button.
func (m menuButton) SetIconName(iconName string) {
	var arg0 *C.GtkMenuButton
	var arg1 *C.char

	arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))
	arg1 = (*C.char)(C.CString(iconName))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_menu_button_set_icon_name(arg0, arg1)
}

// SetLabel sets the label to show inside the menu button.
func (m menuButton) SetLabel(label string) {
	var arg0 *C.GtkMenuButton
	var arg1 *C.char

	arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))
	arg1 = (*C.char)(C.CString(label))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_menu_button_set_label(arg0, arg1)
}

// SetMenuModel sets the Model from which the popup will be constructed, or
// nil to dissociate any existing menu model and disable the button.
//
// A Popover will be created from the menu model with
// gtk_popover_menu_new_from_model(). Actions will be connected as
// documented for this function.
//
// If MenuButton:popover is already set, it will be dissociated from the
// @menu_button, and the property is set to nil.
func (m menuButton) SetMenuModel(menuModel gio.MenuModel) {
	var arg0 *C.GtkMenuButton
	var arg1 *C.GMenuModel

	arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))
	arg1 = (*C.GMenuModel)(unsafe.Pointer(menuModel.Native()))

	C.gtk_menu_button_set_menu_model(arg0, arg1)
}

// SetPopover sets the Popover that will be popped up when the @menu_button
// is clicked, or nil to dissociate any existing popover and disable the
// button.
//
// If MenuButton:menu-model is set, the menu model is dissociated from the
// @menu_button, and the property is set to nil.
func (m menuButton) SetPopover(popover Widget) {
	var arg0 *C.GtkMenuButton
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(popover.Native()))

	C.gtk_menu_button_set_popover(arg0, arg1)
}

// SetUseUnderline: if true, an underline in the text indicates the next
// character should be used for the mnemonic accelerator key.
func (m menuButton) SetUseUnderline(useUnderline bool) {
	var arg0 *C.GtkMenuButton
	var arg1 C.gboolean

	arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))
	if useUnderline {
		arg1 = C.gboolean(1)
	}

	C.gtk_menu_button_set_use_underline(arg0, arg1)
}

// Notebook: the Notebook widget is a layout container whose children are pages
// that can be switched between using tab labels along one edge.
//
// There are many configuration options for GtkNotebook. Among other things, you
// can choose on which edge the tabs appear (see gtk_notebook_set_tab_pos()),
// whether, if there are too many tabs to fit the notebook should be made bigger
// or scrolling arrows added (see gtk_notebook_set_scrollable()), and whether
// there will be a popup menu allowing the users to switch pages. (see
// gtk_notebook_popup_enable(), gtk_notebook_popup_disable())
//
//
// GtkNotebook as GtkBuildable
//
// The GtkNotebook implementation of the Buildable interface supports placing
// children into tabs by specifying “tab” as the “type” attribute of a <child>
// element. Note that the content of the tab must be created before the tab can
// be filled. A tab child can be specified without specifying a <child> type
// attribute.
//
// To add a child widget in the notebooks action area, specify "action-start" or
// “action-end” as the “type” attribute of the <child> element.
//
// An example of a UI definition fragment with GtkNotebook:
//
//    <object class="GtkNotebook">
//      <child>
//        <object class="GtkLabel" id="notebook-content">
//          <property name="label">Content</property>
//        </object>
//      </child>
//      <child type="tab">
//        <object class="GtkLabel" id="notebook-tab">
//          <property name="label">Tab</property>
//        </object>
//      </child>
//    </object>
//
// CSS nodes
//
//    notebook
//    ├── header.top
//    │   ├── [<action widget>]
//    │   ├── tabs
//    │   │   ├── [arrow]
//    │   │   ├── tab
//    │   │   │   ╰── <tab label>
//    ┊   ┊   ┊
//    │   │   ├── tab[.reorderable-page]
//    │   │   │   ╰── <tab label>
//    │   │   ╰── [arrow]
//    │   ╰── [<action widget>]
//    │
//    ╰── stack
//        ├── <child>
//        ┊
//        ╰── <child>
//
// GtkNotebook has a main CSS node with name `notebook`, a subnode with name
// `header` and below that a subnode with name `tabs` which contains one subnode
// per tab with name `tab`.
//
// If action widgets are present, their CSS nodes are placed next to the `tabs`
// node. If the notebook is scrollable, CSS nodes with name `arrow` are placed
// as first and last child of the `tabs` node.
//
// The main node gets the `.frame` style class when the notebook has a border
// (see gtk_notebook_set_show_border()).
//
// The header node gets one of the style class `.top`, `.bottom`, `.left` or
// `.right`, depending on where the tabs are placed. For reorderable pages, the
// tab node gets the `.reorderable-page` class.
//
// A `tab` node gets the `.dnd` style class while it is moved with
// drag-and-drop.
//
// The nodes are always arranged from left-to-right, regardless of text
// direction.
//
//
// Accessibility
//
// GtkNotebook uses the following roles:
//
//    - GTK_ACCESSIBLE_ROLE_GROUP for the notebook widget
//    - GTK_ACCESSIBLE_ROLE_TAB_LIST for the list of tabs
//    - GTK_ACCESSIBLE_ROLE_TAB role for each tab
//    - GTK_ACCESSIBLE_ROLE_TAB_PANEL for each page
type Notebook interface {
	Widget
	Accessible
	Buildable
	ConstraintTarget

	// AppendPage appends a page to @notebook.
	AppendPage(child Widget, tabLabel Widget) int
	// AppendPageMenu appends a page to @notebook, specifying the widget to use
	// as the label in the popup menu.
	AppendPageMenu(child Widget, tabLabel Widget, menuLabel Widget) int
	// DetachTab removes the child from the notebook.
	//
	// This function is very similar to gtk_notebook_remove_page(), but
	// additionally informs the notebook that the removal is happening as part
	// of a tab DND operation, which should not be cancelled.
	DetachTab(child Widget)
	// ActionWidget gets one of the action widgets. See
	// gtk_notebook_set_action_widget().
	ActionWidget(packType PackType) Widget
	// CurrentPage returns the page number of the current page.
	CurrentPage() int
	// GroupName gets the current group name for @notebook.
	GroupName() string
	// MenuLabel retrieves the menu label widget of the page containing @child.
	MenuLabel(child Widget) Widget
	// MenuLabelText retrieves the text of the menu label for the page
	// containing @child.
	MenuLabelText(child Widget) string
	// NPages gets the number of pages in a notebook.
	NPages() int
	// NthPage returns the child widget contained in page number @page_num.
	NthPage(pageNum int) Widget
	// Page returns the NotebookPage for @child.
	Page(child Widget) NotebookPage
	// Pages returns a Model that contains the pages of the notebook, and can be
	// used to keep an up-to-date view.
	Pages() gio.ListModel
	// Scrollable returns whether the tab label area has arrows for scrolling.
	// See gtk_notebook_set_scrollable().
	Scrollable() bool
	// ShowBorder returns whether a bevel will be drawn around the notebook
	// pages. See gtk_notebook_set_show_border().
	ShowBorder() bool
	// ShowTabs returns whether the tabs of the notebook are shown. See
	// gtk_notebook_set_show_tabs().
	ShowTabs() bool
	// TabDetachable returns whether the tab contents can be detached from
	// @notebook.
	TabDetachable(child Widget) bool
	// TabLabel returns the tab label widget for the page @child. nil is
	// returned if @child is not in @notebook or if no tab label has
	// specifically been set for @child.
	TabLabel(child Widget) Widget
	// TabLabelText retrieves the text of the tab label for the page containing
	// @child.
	TabLabelText(child Widget) string
	// TabPos gets the edge at which the tabs for switching pages in the
	// notebook are drawn.
	TabPos() PositionType
	// TabReorderable gets whether the tab can be reordered via drag and drop or
	// not.
	TabReorderable(child Widget) bool
	// InsertPage: insert a page into @notebook at the given position.
	InsertPage(child Widget, tabLabel Widget, position int) int
	// InsertPageMenu: insert a page into @notebook at the given position,
	// specifying the widget to use as the label in the popup menu.
	InsertPageMenu(child Widget, tabLabel Widget, menuLabel Widget, position int) int
	// NextPage switches to the next page. Nothing happens if the current page
	// is the last page.
	NextPage()
	// PageNum finds the index of the page which contains the given child
	// widget.
	PageNum(child Widget) int
	// PopupDisable disables the popup menu.
	PopupDisable()
	// PopupEnable enables the popup menu: if the user clicks with the right
	// mouse button on the tab labels, a menu with all the pages will be popped
	// up.
	PopupEnable()
	// PrependPage prepends a page to @notebook.
	PrependPage(child Widget, tabLabel Widget) int
	// PrependPageMenu prepends a page to @notebook, specifying the widget to
	// use as the label in the popup menu.
	PrependPageMenu(child Widget, tabLabel Widget, menuLabel Widget) int
	// PrevPage switches to the previous page. Nothing happens if the current
	// page is the first page.
	PrevPage()
	// RemovePage removes a page from the notebook given its index in the
	// notebook.
	RemovePage(pageNum int)
	// ReorderChild reorders the page containing @child, so that it appears in
	// position @position. If @position is greater than or equal to the number
	// of children in the list or negative, @child will be moved to the end of
	// the list.
	ReorderChild(child Widget, position int)
	// SetActionWidget sets @widget as one of the action widgets. Depending on
	// the pack type the widget will be placed before or after the tabs. You can
	// use a Box if you need to pack more than one widget on the same side.
	SetActionWidget(widget Widget, packType PackType)
	// SetCurrentPage switches to the page number @page_num.
	//
	// Note that due to historical reasons, GtkNotebook refuses to switch to a
	// page unless the child widget is visible. Therefore, it is recommended to
	// show child widgets before adding them to a notebook.
	SetCurrentPage(pageNum int)
	// SetGroupName sets a group name for @notebook.
	//
	// Notebooks with the same name will be able to exchange tabs via drag and
	// drop. A notebook with a nil group name will not be able to exchange tabs
	// with any other notebook.
	SetGroupName(groupName string)
	// SetMenuLabel changes the menu label for the page containing @child.
	SetMenuLabel(child Widget, menuLabel Widget)
	// SetMenuLabelText creates a new label and sets it as the menu label of
	// @child.
	SetMenuLabelText(child Widget, menuText string)
	// SetScrollable sets whether the tab label area will have arrows for
	// scrolling if there are too many tabs to fit in the area.
	SetScrollable(scrollable bool)
	// SetShowBorder sets whether a bevel will be drawn around the notebook
	// pages. This only has a visual effect when the tabs are not shown. See
	// gtk_notebook_set_show_tabs().
	SetShowBorder(showBorder bool)
	// SetShowTabs sets whether to show the tabs for the notebook or not.
	SetShowTabs(showTabs bool)
	// SetTabDetachable sets whether the tab can be detached from @notebook to
	// another notebook or widget.
	//
	// Note that 2 notebooks must share a common group identificator (see
	// gtk_notebook_set_group_name()) to allow automatic tabs interchange
	// between them.
	//
	// If you want a widget to interact with a notebook through DnD (i.e.:
	// accept dragged tabs from it) it must be set as a drop destination and
	// accept the target “GTK_NOTEBOOK_TAB”. The notebook will fill the
	// selection with a GtkWidget** pointing to the child widget that
	// corresponds to the dropped tab.
	//
	// Note that you should use gtk_notebook_detach_tab() instead of
	// gtk_notebook_remove_page() if you want to remove the tab from the source
	// notebook as part of accepting a drop. Otherwise, the source notebook will
	// think that the dragged tab was removed from underneath the ongoing drag
	// operation, and will initiate a drag cancel animation.
	//
	//     static void
	//     on_drag_data_received (GtkWidget        *widget,
	//                            GdkDrop          *drop,
	//                            GtkSelectionData *data,
	//                            guint             time,
	//                            gpointer          user_data)
	//     {
	//       GtkDrag *drag;
	//       GtkWidget *notebook;
	//       GtkWidget **child;
	//
	//       drag = gtk_drop_get_drag (drop);
	//       notebook = g_object_get_data (drag, "gtk-notebook-drag-origin");
	//       child = (void*) gtk_selection_data_get_data (data);
	//
	//       // process_widget (*child);
	//
	//       gtk_notebook_detach_tab (GTK_NOTEBOOK (notebook), *child);
	//     }
	//
	// If you want a notebook to accept drags from other widgets, you will have
	// to set your own DnD code to do it.
	SetTabDetachable(child Widget, detachable bool)
	// SetTabLabel changes the tab label for @child. If nil is specified for
	// @tab_label, then the page will have the label “page N”.
	SetTabLabel(child Widget, tabLabel Widget)
	// SetTabLabelText creates a new label and sets it as the tab label for the
	// page containing @child.
	SetTabLabelText(child Widget, tabText string)
	// SetTabPos sets the edge at which the tabs for switching pages in the
	// notebook are drawn.
	SetTabPos(pos PositionType)
	// SetTabReorderable sets whether the notebook tab can be reordered via drag
	// and drop or not.
	SetTabReorderable(child Widget, reorderable bool)
}

// notebook implements the Notebook interface.
type notebook struct {
	Widget
	Accessible
	Buildable
	ConstraintTarget
}

var _ Notebook = (*notebook)(nil)

// WrapNotebook wraps a GObject to the right type. It is
// primarily used internally.
func WrapNotebook(obj *externglib.Object) Notebook {
	return Notebook{
		Widget:           WrapWidget(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
	}
}

func marshalNotebook(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapNotebook(obj), nil
}

// NewNotebook constructs a class Notebook.
func NewNotebook() Notebook {
	var cret C.GtkNotebook

	cret = C.gtk_notebook_new()

	var notebook Notebook

	notebook = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Notebook)

	return notebook
}

// AppendPage appends a page to @notebook.
func (n notebook) AppendPage(child Widget, tabLabel Widget) int {
	var arg0 *C.GtkNotebook
	var arg1 *C.GtkWidget
	var arg2 *C.GtkWidget

	arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	arg2 = (*C.GtkWidget)(unsafe.Pointer(tabLabel.Native()))

	var cret C.int

	cret = C.gtk_notebook_append_page(arg0, arg1, arg2)

	var gint int

	gint = (int)(cret)

	return gint
}

// AppendPageMenu appends a page to @notebook, specifying the widget to use
// as the label in the popup menu.
func (n notebook) AppendPageMenu(child Widget, tabLabel Widget, menuLabel Widget) int {
	var arg0 *C.GtkNotebook
	var arg1 *C.GtkWidget
	var arg2 *C.GtkWidget
	var arg3 *C.GtkWidget

	arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	arg2 = (*C.GtkWidget)(unsafe.Pointer(tabLabel.Native()))
	arg3 = (*C.GtkWidget)(unsafe.Pointer(menuLabel.Native()))

	var cret C.int

	cret = C.gtk_notebook_append_page_menu(arg0, arg1, arg2, arg3)

	var gint int

	gint = (int)(cret)

	return gint
}

// DetachTab removes the child from the notebook.
//
// This function is very similar to gtk_notebook_remove_page(), but
// additionally informs the notebook that the removal is happening as part
// of a tab DND operation, which should not be cancelled.
func (n notebook) DetachTab(child Widget) {
	var arg0 *C.GtkNotebook
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_notebook_detach_tab(arg0, arg1)
}

// ActionWidget gets one of the action widgets. See
// gtk_notebook_set_action_widget().
func (n notebook) ActionWidget(packType PackType) Widget {
	var arg0 *C.GtkNotebook
	var arg1 C.GtkPackType

	arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	arg1 = (C.GtkPackType)(packType)

	var cret *C.GtkWidget

	cret = C.gtk_notebook_get_action_widget(arg0, arg1)

	var widget Widget

	widget = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Widget)

	return widget
}

// CurrentPage returns the page number of the current page.
func (n notebook) CurrentPage() int {
	var arg0 *C.GtkNotebook

	arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))

	var cret C.int

	cret = C.gtk_notebook_get_current_page(arg0)

	var gint int

	gint = (int)(cret)

	return gint
}

// GroupName gets the current group name for @notebook.
func (n notebook) GroupName() string {
	var arg0 *C.GtkNotebook

	arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))

	var cret *C.char

	cret = C.gtk_notebook_get_group_name(arg0)

	var utf8 string

	utf8 = C.GoString(cret)

	return utf8
}

// MenuLabel retrieves the menu label widget of the page containing @child.
func (n notebook) MenuLabel(child Widget) Widget {
	var arg0 *C.GtkNotebook
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	var cret *C.GtkWidget

	cret = C.gtk_notebook_get_menu_label(arg0, arg1)

	var widget Widget

	widget = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Widget)

	return widget
}

// MenuLabelText retrieves the text of the menu label for the page
// containing @child.
func (n notebook) MenuLabelText(child Widget) string {
	var arg0 *C.GtkNotebook
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	var cret *C.char

	cret = C.gtk_notebook_get_menu_label_text(arg0, arg1)

	var utf8 string

	utf8 = C.GoString(cret)

	return utf8
}

// NPages gets the number of pages in a notebook.
func (n notebook) NPages() int {
	var arg0 *C.GtkNotebook

	arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))

	var cret C.int

	cret = C.gtk_notebook_get_n_pages(arg0)

	var gint int

	gint = (int)(cret)

	return gint
}

// NthPage returns the child widget contained in page number @page_num.
func (n notebook) NthPage(pageNum int) Widget {
	var arg0 *C.GtkNotebook
	var arg1 C.int

	arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	arg1 = C.int(pageNum)

	var cret *C.GtkWidget

	cret = C.gtk_notebook_get_nth_page(arg0, arg1)

	var widget Widget

	widget = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Widget)

	return widget
}

// Page returns the NotebookPage for @child.
func (n notebook) Page(child Widget) NotebookPage {
	var arg0 *C.GtkNotebook
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	var cret *C.GtkNotebookPage

	cret = C.gtk_notebook_get_page(arg0, arg1)

	var notebookPage NotebookPage

	notebookPage = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(NotebookPage)

	return notebookPage
}

// Pages returns a Model that contains the pages of the notebook, and can be
// used to keep an up-to-date view.
func (n notebook) Pages() gio.ListModel {
	var arg0 *C.GtkNotebook

	arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))

	var cret *C.GListModel

	cret = C.gtk_notebook_get_pages(arg0)

	var listModel gio.ListModel

	listModel = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(gio.ListModel)

	return listModel
}

// Scrollable returns whether the tab label area has arrows for scrolling.
// See gtk_notebook_set_scrollable().
func (n notebook) Scrollable() bool {
	var arg0 *C.GtkNotebook

	arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))

	var cret C.gboolean

	cret = C.gtk_notebook_get_scrollable(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// ShowBorder returns whether a bevel will be drawn around the notebook
// pages. See gtk_notebook_set_show_border().
func (n notebook) ShowBorder() bool {
	var arg0 *C.GtkNotebook

	arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))

	var cret C.gboolean

	cret = C.gtk_notebook_get_show_border(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// ShowTabs returns whether the tabs of the notebook are shown. See
// gtk_notebook_set_show_tabs().
func (n notebook) ShowTabs() bool {
	var arg0 *C.GtkNotebook

	arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))

	var cret C.gboolean

	cret = C.gtk_notebook_get_show_tabs(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// TabDetachable returns whether the tab contents can be detached from
// @notebook.
func (n notebook) TabDetachable(child Widget) bool {
	var arg0 *C.GtkNotebook
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	var cret C.gboolean

	cret = C.gtk_notebook_get_tab_detachable(arg0, arg1)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// TabLabel returns the tab label widget for the page @child. nil is
// returned if @child is not in @notebook or if no tab label has
// specifically been set for @child.
func (n notebook) TabLabel(child Widget) Widget {
	var arg0 *C.GtkNotebook
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	var cret *C.GtkWidget

	cret = C.gtk_notebook_get_tab_label(arg0, arg1)

	var widget Widget

	widget = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Widget)

	return widget
}

// TabLabelText retrieves the text of the tab label for the page containing
// @child.
func (n notebook) TabLabelText(child Widget) string {
	var arg0 *C.GtkNotebook
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	var cret *C.char

	cret = C.gtk_notebook_get_tab_label_text(arg0, arg1)

	var utf8 string

	utf8 = C.GoString(cret)

	return utf8
}

// TabPos gets the edge at which the tabs for switching pages in the
// notebook are drawn.
func (n notebook) TabPos() PositionType {
	var arg0 *C.GtkNotebook

	arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))

	var cret C.GtkPositionType

	cret = C.gtk_notebook_get_tab_pos(arg0)

	var positionType PositionType

	positionType = PositionType(cret)

	return positionType
}

// TabReorderable gets whether the tab can be reordered via drag and drop or
// not.
func (n notebook) TabReorderable(child Widget) bool {
	var arg0 *C.GtkNotebook
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	var cret C.gboolean

	cret = C.gtk_notebook_get_tab_reorderable(arg0, arg1)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// InsertPage: insert a page into @notebook at the given position.
func (n notebook) InsertPage(child Widget, tabLabel Widget, position int) int {
	var arg0 *C.GtkNotebook
	var arg1 *C.GtkWidget
	var arg2 *C.GtkWidget
	var arg3 C.int

	arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	arg2 = (*C.GtkWidget)(unsafe.Pointer(tabLabel.Native()))
	arg3 = C.int(position)

	var cret C.int

	cret = C.gtk_notebook_insert_page(arg0, arg1, arg2, arg3)

	var gint int

	gint = (int)(cret)

	return gint
}

// InsertPageMenu: insert a page into @notebook at the given position,
// specifying the widget to use as the label in the popup menu.
func (n notebook) InsertPageMenu(child Widget, tabLabel Widget, menuLabel Widget, position int) int {
	var arg0 *C.GtkNotebook
	var arg1 *C.GtkWidget
	var arg2 *C.GtkWidget
	var arg3 *C.GtkWidget
	var arg4 C.int

	arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	arg2 = (*C.GtkWidget)(unsafe.Pointer(tabLabel.Native()))
	arg3 = (*C.GtkWidget)(unsafe.Pointer(menuLabel.Native()))
	arg4 = C.int(position)

	var cret C.int

	cret = C.gtk_notebook_insert_page_menu(arg0, arg1, arg2, arg3, arg4)

	var gint int

	gint = (int)(cret)

	return gint
}

// NextPage switches to the next page. Nothing happens if the current page
// is the last page.
func (n notebook) NextPage() {
	var arg0 *C.GtkNotebook

	arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))

	C.gtk_notebook_next_page(arg0)
}

// PageNum finds the index of the page which contains the given child
// widget.
func (n notebook) PageNum(child Widget) int {
	var arg0 *C.GtkNotebook
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	var cret C.int

	cret = C.gtk_notebook_page_num(arg0, arg1)

	var gint int

	gint = (int)(cret)

	return gint
}

// PopupDisable disables the popup menu.
func (n notebook) PopupDisable() {
	var arg0 *C.GtkNotebook

	arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))

	C.gtk_notebook_popup_disable(arg0)
}

// PopupEnable enables the popup menu: if the user clicks with the right
// mouse button on the tab labels, a menu with all the pages will be popped
// up.
func (n notebook) PopupEnable() {
	var arg0 *C.GtkNotebook

	arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))

	C.gtk_notebook_popup_enable(arg0)
}

// PrependPage prepends a page to @notebook.
func (n notebook) PrependPage(child Widget, tabLabel Widget) int {
	var arg0 *C.GtkNotebook
	var arg1 *C.GtkWidget
	var arg2 *C.GtkWidget

	arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	arg2 = (*C.GtkWidget)(unsafe.Pointer(tabLabel.Native()))

	var cret C.int

	cret = C.gtk_notebook_prepend_page(arg0, arg1, arg2)

	var gint int

	gint = (int)(cret)

	return gint
}

// PrependPageMenu prepends a page to @notebook, specifying the widget to
// use as the label in the popup menu.
func (n notebook) PrependPageMenu(child Widget, tabLabel Widget, menuLabel Widget) int {
	var arg0 *C.GtkNotebook
	var arg1 *C.GtkWidget
	var arg2 *C.GtkWidget
	var arg3 *C.GtkWidget

	arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	arg2 = (*C.GtkWidget)(unsafe.Pointer(tabLabel.Native()))
	arg3 = (*C.GtkWidget)(unsafe.Pointer(menuLabel.Native()))

	var cret C.int

	cret = C.gtk_notebook_prepend_page_menu(arg0, arg1, arg2, arg3)

	var gint int

	gint = (int)(cret)

	return gint
}

// PrevPage switches to the previous page. Nothing happens if the current
// page is the first page.
func (n notebook) PrevPage() {
	var arg0 *C.GtkNotebook

	arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))

	C.gtk_notebook_prev_page(arg0)
}

// RemovePage removes a page from the notebook given its index in the
// notebook.
func (n notebook) RemovePage(pageNum int) {
	var arg0 *C.GtkNotebook
	var arg1 C.int

	arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	arg1 = C.int(pageNum)

	C.gtk_notebook_remove_page(arg0, arg1)
}

// ReorderChild reorders the page containing @child, so that it appears in
// position @position. If @position is greater than or equal to the number
// of children in the list or negative, @child will be moved to the end of
// the list.
func (n notebook) ReorderChild(child Widget, position int) {
	var arg0 *C.GtkNotebook
	var arg1 *C.GtkWidget
	var arg2 C.int

	arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	arg2 = C.int(position)

	C.gtk_notebook_reorder_child(arg0, arg1, arg2)
}

// SetActionWidget sets @widget as one of the action widgets. Depending on
// the pack type the widget will be placed before or after the tabs. You can
// use a Box if you need to pack more than one widget on the same side.
func (n notebook) SetActionWidget(widget Widget, packType PackType) {
	var arg0 *C.GtkNotebook
	var arg1 *C.GtkWidget
	var arg2 C.GtkPackType

	arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	arg2 = (C.GtkPackType)(packType)

	C.gtk_notebook_set_action_widget(arg0, arg1, arg2)
}

// SetCurrentPage switches to the page number @page_num.
//
// Note that due to historical reasons, GtkNotebook refuses to switch to a
// page unless the child widget is visible. Therefore, it is recommended to
// show child widgets before adding them to a notebook.
func (n notebook) SetCurrentPage(pageNum int) {
	var arg0 *C.GtkNotebook
	var arg1 C.int

	arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	arg1 = C.int(pageNum)

	C.gtk_notebook_set_current_page(arg0, arg1)
}

// SetGroupName sets a group name for @notebook.
//
// Notebooks with the same name will be able to exchange tabs via drag and
// drop. A notebook with a nil group name will not be able to exchange tabs
// with any other notebook.
func (n notebook) SetGroupName(groupName string) {
	var arg0 *C.GtkNotebook
	var arg1 *C.char

	arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	arg1 = (*C.char)(C.CString(groupName))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_notebook_set_group_name(arg0, arg1)
}

// SetMenuLabel changes the menu label for the page containing @child.
func (n notebook) SetMenuLabel(child Widget, menuLabel Widget) {
	var arg0 *C.GtkNotebook
	var arg1 *C.GtkWidget
	var arg2 *C.GtkWidget

	arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	arg2 = (*C.GtkWidget)(unsafe.Pointer(menuLabel.Native()))

	C.gtk_notebook_set_menu_label(arg0, arg1, arg2)
}

// SetMenuLabelText creates a new label and sets it as the menu label of
// @child.
func (n notebook) SetMenuLabelText(child Widget, menuText string) {
	var arg0 *C.GtkNotebook
	var arg1 *C.GtkWidget
	var arg2 *C.char

	arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	arg2 = (*C.char)(C.CString(menuText))
	defer C.free(unsafe.Pointer(arg2))

	C.gtk_notebook_set_menu_label_text(arg0, arg1, arg2)
}

// SetScrollable sets whether the tab label area will have arrows for
// scrolling if there are too many tabs to fit in the area.
func (n notebook) SetScrollable(scrollable bool) {
	var arg0 *C.GtkNotebook
	var arg1 C.gboolean

	arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	if scrollable {
		arg1 = C.gboolean(1)
	}

	C.gtk_notebook_set_scrollable(arg0, arg1)
}

// SetShowBorder sets whether a bevel will be drawn around the notebook
// pages. This only has a visual effect when the tabs are not shown. See
// gtk_notebook_set_show_tabs().
func (n notebook) SetShowBorder(showBorder bool) {
	var arg0 *C.GtkNotebook
	var arg1 C.gboolean

	arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	if showBorder {
		arg1 = C.gboolean(1)
	}

	C.gtk_notebook_set_show_border(arg0, arg1)
}

// SetShowTabs sets whether to show the tabs for the notebook or not.
func (n notebook) SetShowTabs(showTabs bool) {
	var arg0 *C.GtkNotebook
	var arg1 C.gboolean

	arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	if showTabs {
		arg1 = C.gboolean(1)
	}

	C.gtk_notebook_set_show_tabs(arg0, arg1)
}

// SetTabDetachable sets whether the tab can be detached from @notebook to
// another notebook or widget.
//
// Note that 2 notebooks must share a common group identificator (see
// gtk_notebook_set_group_name()) to allow automatic tabs interchange
// between them.
//
// If you want a widget to interact with a notebook through DnD (i.e.:
// accept dragged tabs from it) it must be set as a drop destination and
// accept the target “GTK_NOTEBOOK_TAB”. The notebook will fill the
// selection with a GtkWidget** pointing to the child widget that
// corresponds to the dropped tab.
//
// Note that you should use gtk_notebook_detach_tab() instead of
// gtk_notebook_remove_page() if you want to remove the tab from the source
// notebook as part of accepting a drop. Otherwise, the source notebook will
// think that the dragged tab was removed from underneath the ongoing drag
// operation, and will initiate a drag cancel animation.
//
//     static void
//     on_drag_data_received (GtkWidget        *widget,
//                            GdkDrop          *drop,
//                            GtkSelectionData *data,
//                            guint             time,
//                            gpointer          user_data)
//     {
//       GtkDrag *drag;
//       GtkWidget *notebook;
//       GtkWidget **child;
//
//       drag = gtk_drop_get_drag (drop);
//       notebook = g_object_get_data (drag, "gtk-notebook-drag-origin");
//       child = (void*) gtk_selection_data_get_data (data);
//
//       // process_widget (*child);
//
//       gtk_notebook_detach_tab (GTK_NOTEBOOK (notebook), *child);
//     }
//
// If you want a notebook to accept drags from other widgets, you will have
// to set your own DnD code to do it.
func (n notebook) SetTabDetachable(child Widget, detachable bool) {
	var arg0 *C.GtkNotebook
	var arg1 *C.GtkWidget
	var arg2 C.gboolean

	arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	if detachable {
		arg2 = C.gboolean(1)
	}

	C.gtk_notebook_set_tab_detachable(arg0, arg1, arg2)
}

// SetTabLabel changes the tab label for @child. If nil is specified for
// @tab_label, then the page will have the label “page N”.
func (n notebook) SetTabLabel(child Widget, tabLabel Widget) {
	var arg0 *C.GtkNotebook
	var arg1 *C.GtkWidget
	var arg2 *C.GtkWidget

	arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	arg2 = (*C.GtkWidget)(unsafe.Pointer(tabLabel.Native()))

	C.gtk_notebook_set_tab_label(arg0, arg1, arg2)
}

// SetTabLabelText creates a new label and sets it as the tab label for the
// page containing @child.
func (n notebook) SetTabLabelText(child Widget, tabText string) {
	var arg0 *C.GtkNotebook
	var arg1 *C.GtkWidget
	var arg2 *C.char

	arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	arg2 = (*C.char)(C.CString(tabText))
	defer C.free(unsafe.Pointer(arg2))

	C.gtk_notebook_set_tab_label_text(arg0, arg1, arg2)
}

// SetTabPos sets the edge at which the tabs for switching pages in the
// notebook are drawn.
func (n notebook) SetTabPos(pos PositionType) {
	var arg0 *C.GtkNotebook
	var arg1 C.GtkPositionType

	arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	arg1 = (C.GtkPositionType)(pos)

	C.gtk_notebook_set_tab_pos(arg0, arg1)
}

// SetTabReorderable sets whether the notebook tab can be reordered via drag
// and drop or not.
func (n notebook) SetTabReorderable(child Widget, reorderable bool) {
	var arg0 *C.GtkNotebook
	var arg1 *C.GtkWidget
	var arg2 C.gboolean

	arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	if reorderable {
		arg2 = C.gboolean(1)
	}

	C.gtk_notebook_set_tab_reorderable(arg0, arg1, arg2)
}

// NotebookPage: a page in the Notebook.
//
// The `GtkNotebookPage` structure only contains private data.
type NotebookPage interface {
	gextras.Objector

	// Child returns the notebook child to which @page belongs.
	Child() Widget
}

// notebookPage implements the NotebookPage interface.
type notebookPage struct {
	gextras.Objector
}

var _ NotebookPage = (*notebookPage)(nil)

// WrapNotebookPage wraps a GObject to the right type. It is
// primarily used internally.
func WrapNotebookPage(obj *externglib.Object) NotebookPage {
	return NotebookPage{
		Objector: obj,
	}
}

func marshalNotebookPage(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapNotebookPage(obj), nil
}

// Child returns the notebook child to which @page belongs.
func (p notebookPage) Child() Widget {
	var arg0 *C.GtkNotebookPage

	arg0 = (*C.GtkNotebookPage)(unsafe.Pointer(p.Native()))

	var cret *C.GtkWidget

	cret = C.gtk_notebook_page_get_child(arg0)

	var widget Widget

	widget = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Widget)

	return widget
}

// Overlay: gtkOverlay is a container which contains a single main child, on top
// of which it can place “overlay” widgets. The position of each overlay widget
// is determined by its Widget:halign and Widget:valign properties. E.g. a
// widget with both alignments set to GTK_ALIGN_START will be placed at the top
// left corner of the GtkOverlay container, whereas an overlay with halign set
// to GTK_ALIGN_CENTER and valign set to GTK_ALIGN_END will be placed a the
// bottom edge of the GtkOverlay, horizontally centered. The position can be
// adjusted by setting the margin properties of the child to non-zero values.
//
// More complicated placement of overlays is possible by connecting to the
// Overlay::get-child-position signal.
//
// An overlay’s minimum and natural sizes are those of its main child. The sizes
// of overlay children are not considered when measuring these preferred sizes.
//
//
// GtkOverlay as GtkBuildable
//
// The GtkOverlay implementation of the GtkBuildable interface supports placing
// a child as an overlay by specifying “overlay” as the “type” attribute of a
// `<child>` element.
//
//
// CSS nodes
//
// GtkOverlay has a single CSS node with the name “overlay”. Overlay children
// whose alignments cause them to be positioned at an edge get the style classes
// “.left”, “.right”, “.top”, and/or “.bottom” according to their position.
type Overlay interface {
	Widget
	Accessible
	Buildable
	ConstraintTarget

	// AddOverlay adds @widget to @overlay.
	//
	// The widget will be stacked on top of the main widget added with
	// gtk_overlay_set_child().
	//
	// The position at which @widget is placed is determined from its
	// Widget:halign and Widget:valign properties.
	AddOverlay(widget Widget)
	// Child gets the child widget of @overlay.
	Child() Widget
	// ClipOverlay gets whether @widget should be clipped within the parent.
	ClipOverlay(widget Widget) bool
	// MeasureOverlay gets whether @widget's size is included in the measurement
	// of @overlay.
	MeasureOverlay(widget Widget) bool
	// RemoveOverlay removes an overlay that was added with
	// gtk_overlay_add_overlay().
	RemoveOverlay(widget Widget)
	// SetChild sets the child widget of @overlay.
	SetChild(child Widget)
	// SetClipOverlay sets whether @widget should be clipped within the parent.
	SetClipOverlay(widget Widget, clipOverlay bool)
	// SetMeasureOverlay sets whether @widget is included in the measured size
	// of @overlay.
	//
	// The overlay will request the size of the largest child that has this
	// property set to true. Children who are not included may be drawn outside
	// of @overlay's allocation if they are too large.
	SetMeasureOverlay(widget Widget, measure bool)
}

// overlay implements the Overlay interface.
type overlay struct {
	Widget
	Accessible
	Buildable
	ConstraintTarget
}

var _ Overlay = (*overlay)(nil)

// WrapOverlay wraps a GObject to the right type. It is
// primarily used internally.
func WrapOverlay(obj *externglib.Object) Overlay {
	return Overlay{
		Widget:           WrapWidget(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
	}
}

func marshalOverlay(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapOverlay(obj), nil
}

// NewOverlay constructs a class Overlay.
func NewOverlay() Overlay {
	var cret C.GtkOverlay

	cret = C.gtk_overlay_new()

	var overlay Overlay

	overlay = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Overlay)

	return overlay
}

// AddOverlay adds @widget to @overlay.
//
// The widget will be stacked on top of the main widget added with
// gtk_overlay_set_child().
//
// The position at which @widget is placed is determined from its
// Widget:halign and Widget:valign properties.
func (o overlay) AddOverlay(widget Widget) {
	var arg0 *C.GtkOverlay
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkOverlay)(unsafe.Pointer(o.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	C.gtk_overlay_add_overlay(arg0, arg1)
}

// Child gets the child widget of @overlay.
func (o overlay) Child() Widget {
	var arg0 *C.GtkOverlay

	arg0 = (*C.GtkOverlay)(unsafe.Pointer(o.Native()))

	var cret *C.GtkWidget

	cret = C.gtk_overlay_get_child(arg0)

	var widget Widget

	widget = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Widget)

	return widget
}

// ClipOverlay gets whether @widget should be clipped within the parent.
func (o overlay) ClipOverlay(widget Widget) bool {
	var arg0 *C.GtkOverlay
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkOverlay)(unsafe.Pointer(o.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	var cret C.gboolean

	cret = C.gtk_overlay_get_clip_overlay(arg0, arg1)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// MeasureOverlay gets whether @widget's size is included in the measurement
// of @overlay.
func (o overlay) MeasureOverlay(widget Widget) bool {
	var arg0 *C.GtkOverlay
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkOverlay)(unsafe.Pointer(o.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	var cret C.gboolean

	cret = C.gtk_overlay_get_measure_overlay(arg0, arg1)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// RemoveOverlay removes an overlay that was added with
// gtk_overlay_add_overlay().
func (o overlay) RemoveOverlay(widget Widget) {
	var arg0 *C.GtkOverlay
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkOverlay)(unsafe.Pointer(o.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	C.gtk_overlay_remove_overlay(arg0, arg1)
}

// SetChild sets the child widget of @overlay.
func (o overlay) SetChild(child Widget) {
	var arg0 *C.GtkOverlay
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkOverlay)(unsafe.Pointer(o.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_overlay_set_child(arg0, arg1)
}

// SetClipOverlay sets whether @widget should be clipped within the parent.
func (o overlay) SetClipOverlay(widget Widget, clipOverlay bool) {
	var arg0 *C.GtkOverlay
	var arg1 *C.GtkWidget
	var arg2 C.gboolean

	arg0 = (*C.GtkOverlay)(unsafe.Pointer(o.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	if clipOverlay {
		arg2 = C.gboolean(1)
	}

	C.gtk_overlay_set_clip_overlay(arg0, arg1, arg2)
}

// SetMeasureOverlay sets whether @widget is included in the measured size
// of @overlay.
//
// The overlay will request the size of the largest child that has this
// property set to true. Children who are not included may be drawn outside
// of @overlay's allocation if they are too large.
func (o overlay) SetMeasureOverlay(widget Widget, measure bool) {
	var arg0 *C.GtkOverlay
	var arg1 *C.GtkWidget
	var arg2 C.gboolean

	arg0 = (*C.GtkOverlay)(unsafe.Pointer(o.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	if measure {
		arg2 = C.gboolean(1)
	}

	C.gtk_overlay_set_measure_overlay(arg0, arg1, arg2)
}

// PageSetup: a GtkPageSetup object stores the page size, orientation and
// margins. The idea is that you can get one of these from the page setup dialog
// and then pass it to the PrintOperation when printing. The benefit of
// splitting this out of the PrintSettings is that these affect the actual
// layout of the page, and thus need to be set long before user prints.
//
//
// Margins
//
// The margins specified in this object are the “print margins”, i.e. the parts
// of the page that the printer cannot print on. These are different from the
// layout margins that a word processor uses; they are typically used to
// determine the minimal size for the layout margins.
//
// To obtain a PageSetup use gtk_page_setup_new() to get the defaults, or use
// gtk_print_run_page_setup_dialog() to show the page setup dialog and receive
// the resulting page setup.
//
// A page setup dialog
//
//    static GtkPrintSettings *settings = NULL;
//    static GtkPageSetup *page_setup = NULL;
//
//    static void
//    do_page_setup (void)
//    {
//      GtkPageSetup *new_page_setup;
//
//      if (settings == NULL)
//        settings = gtk_print_settings_new ();
//
//      new_page_setup = gtk_print_run_page_setup_dialog (GTK_WINDOW (main_window),
//                                                        page_setup, settings);
//
//      if (page_setup)
//        g_object_unref (page_setup);
//
//      page_setup = new_page_setup;
//    }
type PageSetup interface {
	gextras.Objector

	// Copy copies a PageSetup.
	Copy() PageSetup
	// BottomMargin gets the bottom margin in units of @unit.
	BottomMargin(unit Unit) float64
	// LeftMargin gets the left margin in units of @unit.
	LeftMargin(unit Unit) float64
	// Orientation gets the page orientation of the PageSetup.
	Orientation() PageOrientation
	// PageHeight returns the page height in units of @unit.
	//
	// Note that this function takes orientation and margins into consideration.
	// See gtk_page_setup_get_paper_height().
	PageHeight(unit Unit) float64
	// PageWidth returns the page width in units of @unit.
	//
	// Note that this function takes orientation and margins into consideration.
	// See gtk_page_setup_get_paper_width().
	PageWidth(unit Unit) float64
	// PaperHeight returns the paper height in units of @unit.
	//
	// Note that this function takes orientation, but not margins into
	// consideration. See gtk_page_setup_get_page_height().
	PaperHeight(unit Unit) float64
	// PaperSize gets the paper size of the PageSetup.
	PaperSize() *PaperSize
	// PaperWidth returns the paper width in units of @unit.
	//
	// Note that this function takes orientation, but not margins into
	// consideration. See gtk_page_setup_get_page_width().
	PaperWidth(unit Unit) float64
	// RightMargin gets the right margin in units of @unit.
	RightMargin(unit Unit) float64
	// TopMargin gets the top margin in units of @unit.
	TopMargin(unit Unit) float64
	// LoadFile reads the page setup from the file @file_name. See
	// gtk_page_setup_to_file().
	LoadFile(fileName *string) error
	// LoadKeyFile reads the page setup from the group @group_name in the key
	// file @key_file.
	LoadKeyFile(keyFile *glib.KeyFile, groupName string) error
	// SetBottomMargin sets the bottom margin of the PageSetup.
	SetBottomMargin(margin float64, unit Unit)
	// SetLeftMargin sets the left margin of the PageSetup.
	SetLeftMargin(margin float64, unit Unit)
	// SetOrientation sets the page orientation of the PageSetup.
	SetOrientation(orientation PageOrientation)
	// SetPaperSize sets the paper size of the PageSetup without changing the
	// margins. See gtk_page_setup_set_paper_size_and_default_margins().
	SetPaperSize(size *PaperSize)
	// SetPaperSizeAndDefaultMargins sets the paper size of the PageSetup and
	// modifies the margins according to the new paper size.
	SetPaperSizeAndDefaultMargins(size *PaperSize)
	// SetRightMargin sets the right margin of the PageSetup.
	SetRightMargin(margin float64, unit Unit)
	// SetTopMargin sets the top margin of the PageSetup.
	SetTopMargin(margin float64, unit Unit)
	// ToFile: this function saves the information from @setup to @file_name.
	ToFile(fileName *string) error
	// ToGVariant: serialize page setup to an a{sv} variant.
	ToGVariant() *glib.Variant
	// ToKeyFile: this function adds the page setup from @setup to @key_file.
	ToKeyFile(keyFile *glib.KeyFile, groupName string)
}

// pageSetup implements the PageSetup interface.
type pageSetup struct {
	gextras.Objector
}

var _ PageSetup = (*pageSetup)(nil)

// WrapPageSetup wraps a GObject to the right type. It is
// primarily used internally.
func WrapPageSetup(obj *externglib.Object) PageSetup {
	return PageSetup{
		Objector: obj,
	}
}

func marshalPageSetup(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPageSetup(obj), nil
}

// NewPageSetup constructs a class PageSetup.
func NewPageSetup() PageSetup {
	var cret C.GtkPageSetup

	cret = C.gtk_page_setup_new()

	var pageSetup PageSetup

	pageSetup = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(PageSetup)

	return pageSetup
}

// NewPageSetupFromFile constructs a class PageSetup.
func NewPageSetupFromFile(fileName *string) (pageSetup PageSetup, goerr error) {
	var arg1 *C.char

	arg1 = (*C.char)(C.CString(fileName))
	defer C.free(unsafe.Pointer(arg1))

	var cret C.GtkPageSetup
	var cerr *C.GError

	cret = C.gtk_page_setup_new_from_file(arg1, cerr)

	var pageSetup PageSetup
	var goerr error

	pageSetup = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(PageSetup)
	goerr = gerror.Take(unsafe.Pointer(cerr))

	return pageSetup, goerr
}

// NewPageSetupFromGVariant constructs a class PageSetup.
func NewPageSetupFromGVariant(variant *glib.Variant) PageSetup {
	var arg1 *C.GVariant

	arg1 = (*C.GVariant)(unsafe.Pointer(variant.Native()))

	var cret C.GtkPageSetup

	cret = C.gtk_page_setup_new_from_gvariant(arg1)

	var pageSetup PageSetup

	pageSetup = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(PageSetup)

	return pageSetup
}

// NewPageSetupFromKeyFile constructs a class PageSetup.
func NewPageSetupFromKeyFile(keyFile *glib.KeyFile, groupName string) (pageSetup PageSetup, goerr error) {
	var arg1 *C.GKeyFile
	var arg2 *C.char

	arg1 = (*C.GKeyFile)(unsafe.Pointer(keyFile.Native()))
	arg2 = (*C.char)(C.CString(groupName))
	defer C.free(unsafe.Pointer(arg2))

	var cret C.GtkPageSetup
	var cerr *C.GError

	cret = C.gtk_page_setup_new_from_key_file(arg1, arg2, cerr)

	var pageSetup PageSetup
	var goerr error

	pageSetup = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(PageSetup)
	goerr = gerror.Take(unsafe.Pointer(cerr))

	return pageSetup, goerr
}

// Copy copies a PageSetup.
func (o pageSetup) Copy() PageSetup {
	var arg0 *C.GtkPageSetup

	arg0 = (*C.GtkPageSetup)(unsafe.Pointer(o.Native()))

	var cret *C.GtkPageSetup

	cret = C.gtk_page_setup_copy(arg0)

	var pageSetup PageSetup

	pageSetup = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(PageSetup)

	return pageSetup
}

// BottomMargin gets the bottom margin in units of @unit.
func (s pageSetup) BottomMargin(unit Unit) float64 {
	var arg0 *C.GtkPageSetup
	var arg1 C.GtkUnit

	arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	arg1 = (C.GtkUnit)(unit)

	var cret C.double

	cret = C.gtk_page_setup_get_bottom_margin(arg0, arg1)

	var gdouble float64

	gdouble = (float64)(cret)

	return gdouble
}

// LeftMargin gets the left margin in units of @unit.
func (s pageSetup) LeftMargin(unit Unit) float64 {
	var arg0 *C.GtkPageSetup
	var arg1 C.GtkUnit

	arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	arg1 = (C.GtkUnit)(unit)

	var cret C.double

	cret = C.gtk_page_setup_get_left_margin(arg0, arg1)

	var gdouble float64

	gdouble = (float64)(cret)

	return gdouble
}

// Orientation gets the page orientation of the PageSetup.
func (s pageSetup) Orientation() PageOrientation {
	var arg0 *C.GtkPageSetup

	arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))

	var cret C.GtkPageOrientation

	cret = C.gtk_page_setup_get_orientation(arg0)

	var pageOrientation PageOrientation

	pageOrientation = PageOrientation(cret)

	return pageOrientation
}

// PageHeight returns the page height in units of @unit.
//
// Note that this function takes orientation and margins into consideration.
// See gtk_page_setup_get_paper_height().
func (s pageSetup) PageHeight(unit Unit) float64 {
	var arg0 *C.GtkPageSetup
	var arg1 C.GtkUnit

	arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	arg1 = (C.GtkUnit)(unit)

	var cret C.double

	cret = C.gtk_page_setup_get_page_height(arg0, arg1)

	var gdouble float64

	gdouble = (float64)(cret)

	return gdouble
}

// PageWidth returns the page width in units of @unit.
//
// Note that this function takes orientation and margins into consideration.
// See gtk_page_setup_get_paper_width().
func (s pageSetup) PageWidth(unit Unit) float64 {
	var arg0 *C.GtkPageSetup
	var arg1 C.GtkUnit

	arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	arg1 = (C.GtkUnit)(unit)

	var cret C.double

	cret = C.gtk_page_setup_get_page_width(arg0, arg1)

	var gdouble float64

	gdouble = (float64)(cret)

	return gdouble
}

// PaperHeight returns the paper height in units of @unit.
//
// Note that this function takes orientation, but not margins into
// consideration. See gtk_page_setup_get_page_height().
func (s pageSetup) PaperHeight(unit Unit) float64 {
	var arg0 *C.GtkPageSetup
	var arg1 C.GtkUnit

	arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	arg1 = (C.GtkUnit)(unit)

	var cret C.double

	cret = C.gtk_page_setup_get_paper_height(arg0, arg1)

	var gdouble float64

	gdouble = (float64)(cret)

	return gdouble
}

// PaperSize gets the paper size of the PageSetup.
func (s pageSetup) PaperSize() *PaperSize {
	var arg0 *C.GtkPageSetup

	arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))

	var cret *C.GtkPaperSize

	cret = C.gtk_page_setup_get_paper_size(arg0)

	var paperSize *PaperSize

	paperSize = WrapPaperSize(unsafe.Pointer(cret))

	return paperSize
}

// PaperWidth returns the paper width in units of @unit.
//
// Note that this function takes orientation, but not margins into
// consideration. See gtk_page_setup_get_page_width().
func (s pageSetup) PaperWidth(unit Unit) float64 {
	var arg0 *C.GtkPageSetup
	var arg1 C.GtkUnit

	arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	arg1 = (C.GtkUnit)(unit)

	var cret C.double

	cret = C.gtk_page_setup_get_paper_width(arg0, arg1)

	var gdouble float64

	gdouble = (float64)(cret)

	return gdouble
}

// RightMargin gets the right margin in units of @unit.
func (s pageSetup) RightMargin(unit Unit) float64 {
	var arg0 *C.GtkPageSetup
	var arg1 C.GtkUnit

	arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	arg1 = (C.GtkUnit)(unit)

	var cret C.double

	cret = C.gtk_page_setup_get_right_margin(arg0, arg1)

	var gdouble float64

	gdouble = (float64)(cret)

	return gdouble
}

// TopMargin gets the top margin in units of @unit.
func (s pageSetup) TopMargin(unit Unit) float64 {
	var arg0 *C.GtkPageSetup
	var arg1 C.GtkUnit

	arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	arg1 = (C.GtkUnit)(unit)

	var cret C.double

	cret = C.gtk_page_setup_get_top_margin(arg0, arg1)

	var gdouble float64

	gdouble = (float64)(cret)

	return gdouble
}

// LoadFile reads the page setup from the file @file_name. See
// gtk_page_setup_to_file().
func (s pageSetup) LoadFile(fileName *string) error {
	var arg0 *C.GtkPageSetup
	var arg1 *C.char

	arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	arg1 = (*C.char)(C.CString(fileName))
	defer C.free(unsafe.Pointer(arg1))

	var cerr *C.GError

	C.gtk_page_setup_load_file(arg0, arg1, cerr)

	var goerr error

	goerr = gerror.Take(unsafe.Pointer(cerr))

	return goerr
}

// LoadKeyFile reads the page setup from the group @group_name in the key
// file @key_file.
func (s pageSetup) LoadKeyFile(keyFile *glib.KeyFile, groupName string) error {
	var arg0 *C.GtkPageSetup
	var arg1 *C.GKeyFile
	var arg2 *C.char

	arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GKeyFile)(unsafe.Pointer(keyFile.Native()))
	arg2 = (*C.char)(C.CString(groupName))
	defer C.free(unsafe.Pointer(arg2))

	var cerr *C.GError

	C.gtk_page_setup_load_key_file(arg0, arg1, arg2, cerr)

	var goerr error

	goerr = gerror.Take(unsafe.Pointer(cerr))

	return goerr
}

// SetBottomMargin sets the bottom margin of the PageSetup.
func (s pageSetup) SetBottomMargin(margin float64, unit Unit) {
	var arg0 *C.GtkPageSetup
	var arg1 C.double
	var arg2 C.GtkUnit

	arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	arg1 = C.double(margin)
	arg2 = (C.GtkUnit)(unit)

	C.gtk_page_setup_set_bottom_margin(arg0, arg1, arg2)
}

// SetLeftMargin sets the left margin of the PageSetup.
func (s pageSetup) SetLeftMargin(margin float64, unit Unit) {
	var arg0 *C.GtkPageSetup
	var arg1 C.double
	var arg2 C.GtkUnit

	arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	arg1 = C.double(margin)
	arg2 = (C.GtkUnit)(unit)

	C.gtk_page_setup_set_left_margin(arg0, arg1, arg2)
}

// SetOrientation sets the page orientation of the PageSetup.
func (s pageSetup) SetOrientation(orientation PageOrientation) {
	var arg0 *C.GtkPageSetup
	var arg1 C.GtkPageOrientation

	arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	arg1 = (C.GtkPageOrientation)(orientation)

	C.gtk_page_setup_set_orientation(arg0, arg1)
}

// SetPaperSize sets the paper size of the PageSetup without changing the
// margins. See gtk_page_setup_set_paper_size_and_default_margins().
func (s pageSetup) SetPaperSize(size *PaperSize) {
	var arg0 *C.GtkPageSetup
	var arg1 *C.GtkPaperSize

	arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GtkPaperSize)(unsafe.Pointer(size.Native()))

	C.gtk_page_setup_set_paper_size(arg0, arg1)
}

// SetPaperSizeAndDefaultMargins sets the paper size of the PageSetup and
// modifies the margins according to the new paper size.
func (s pageSetup) SetPaperSizeAndDefaultMargins(size *PaperSize) {
	var arg0 *C.GtkPageSetup
	var arg1 *C.GtkPaperSize

	arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GtkPaperSize)(unsafe.Pointer(size.Native()))

	C.gtk_page_setup_set_paper_size_and_default_margins(arg0, arg1)
}

// SetRightMargin sets the right margin of the PageSetup.
func (s pageSetup) SetRightMargin(margin float64, unit Unit) {
	var arg0 *C.GtkPageSetup
	var arg1 C.double
	var arg2 C.GtkUnit

	arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	arg1 = C.double(margin)
	arg2 = (C.GtkUnit)(unit)

	C.gtk_page_setup_set_right_margin(arg0, arg1, arg2)
}

// SetTopMargin sets the top margin of the PageSetup.
func (s pageSetup) SetTopMargin(margin float64, unit Unit) {
	var arg0 *C.GtkPageSetup
	var arg1 C.double
	var arg2 C.GtkUnit

	arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	arg1 = C.double(margin)
	arg2 = (C.GtkUnit)(unit)

	C.gtk_page_setup_set_top_margin(arg0, arg1, arg2)
}

// ToFile: this function saves the information from @setup to @file_name.
func (s pageSetup) ToFile(fileName *string) error {
	var arg0 *C.GtkPageSetup
	var arg1 *C.char

	arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	arg1 = (*C.char)(C.CString(fileName))
	defer C.free(unsafe.Pointer(arg1))

	var cerr *C.GError

	C.gtk_page_setup_to_file(arg0, arg1, cerr)

	var goerr error

	goerr = gerror.Take(unsafe.Pointer(cerr))

	return goerr
}

// ToGVariant: serialize page setup to an a{sv} variant.
func (s pageSetup) ToGVariant() *glib.Variant {
	var arg0 *C.GtkPageSetup

	arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))

	var cret *C.GVariant

	cret = C.gtk_page_setup_to_gvariant(arg0)

	var variant *glib.Variant

	variant = glib.WrapVariant(unsafe.Pointer(cret))

	return variant
}

// ToKeyFile: this function adds the page setup from @setup to @key_file.
func (s pageSetup) ToKeyFile(keyFile *glib.KeyFile, groupName string) {
	var arg0 *C.GtkPageSetup
	var arg1 *C.GKeyFile
	var arg2 *C.char

	arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GKeyFile)(unsafe.Pointer(keyFile.Native()))
	arg2 = (*C.char)(C.CString(groupName))
	defer C.free(unsafe.Pointer(arg2))

	C.gtk_page_setup_to_key_file(arg0, arg1, arg2)
}

// Paned has two panes, arranged either horizontally or vertically. The division
// between the two panes is adjustable by the user by dragging a handle.
//
// Child widgets are added to the panes of the widget with
// gtk_paned_set_start_child() and gtk_paned_set_end_child(). The division
// between the two children is set by default from the size requests of the
// children, but it can be adjusted by the user.
//
// A paned widget draws a separator between the two child widgets and a small
// handle that the user can drag to adjust the division. It does not draw any
// relief around the children or around the separator. (The space in which the
// separator is called the gutter.) Often, it is useful to put each child inside
// a Frame so that the gutter appears as a ridge. No separator is drawn if one
// of the children is missing.
//
// Each child has two options that can be set, @resize and @shrink. If @resize
// is true, then when the Paned is resized, that child will expand or shrink
// along with the paned widget. If @shrink is true, then that child can be made
// smaller than its requisition by the user. Setting @shrink to false allows the
// application to set a minimum size. If @resize is false for both children,
// then this is treated as if @resize is true for both children.
//
// The application can set the position of the slider as if it were set by the
// user, by calling gtk_paned_set_position().
//
// CSS nodes
//
//    GtkWidget *hpaned = gtk_paned_new (GTK_ORIENTATION_HORIZONTAL);
//    GtkWidget *frame1 = gtk_frame_new (NULL);
//    GtkWidget *frame2 = gtk_frame_new (NULL);
//
//    gtk_widget_set_size_request (hpaned, 200, -1);
//
//    gtk_paned_set_start_child (GTK_PANED (hpaned), frame1);
//    gtk_paned_set_start_child_resize (GTK_PANED (hpaned), TRUE);
//    gtk_paned_set_start_child_shrink (GTK_PANED (hpaned), FALSE);
//    gtk_widget_set_size_request (frame1, 50, -1);
//
//    gtk_paned_set_end_child (GTK_PANED (hpaned), frame2);
//    gtk_paned_set_end_child_resize (GTK_PANED (hpaned), FALSE);
//    gtk_paned_set_end_child_shrink (GTK_PANED (hpaned), FALSE);
//    gtk_widget_set_size_request (frame2, 50, -1);
type Paned interface {
	Widget
	Accessible
	Buildable
	ConstraintTarget
	Orientable

	// EndChild retrieves the end child of the given Paned.
	//
	// See also: Paned:end-child
	EndChild() Widget
	// Position obtains the position of the divider between the two panes.
	Position() int
	// ResizeEndChild returns whether the end child can be resized.
	ResizeEndChild() bool
	// ResizeStartChild returns whether the start child can be resized.
	ResizeStartChild() bool
	// ShrinkEndChild returns whether the end child can be shrunk.
	ShrinkEndChild() bool
	// ShrinkStartChild returns whether the start child can be shrunk.
	ShrinkStartChild() bool
	// StartChild retrieves the start child of the given Paned.
	//
	// See also: Paned:start-child
	StartChild() Widget
	// WideHandle gets the Paned:wide-handle property.
	WideHandle() bool
	// SetEndChild sets the end child of @paned to @child.
	SetEndChild(child Widget)
	// SetPosition sets the position of the divider between the two panes.
	SetPosition(position int)
	// SetResizeEndChild sets the Paned:resize-end-child property
	SetResizeEndChild(resize bool)
	// SetResizeStartChild sets the Paned:resize-start-child property
	SetResizeStartChild(resize bool)
	// SetShrinkEndChild sets the Paned:shrink-end-child property
	SetShrinkEndChild(resize bool)
	// SetShrinkStartChild sets the Paned:shrink-start-child property
	SetShrinkStartChild(resize bool)
	// SetStartChild sets the start child of @paned to @child.
	SetStartChild(child Widget)
	// SetWideHandle sets the Paned:wide-handle property.
	SetWideHandle(wide bool)
}

// paned implements the Paned interface.
type paned struct {
	Widget
	Accessible
	Buildable
	ConstraintTarget
	Orientable
}

var _ Paned = (*paned)(nil)

// WrapPaned wraps a GObject to the right type. It is
// primarily used internally.
func WrapPaned(obj *externglib.Object) Paned {
	return Paned{
		Widget:           WrapWidget(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
		Orientable:       WrapOrientable(obj),
	}
}

func marshalPaned(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPaned(obj), nil
}

// NewPaned constructs a class Paned.
func NewPaned(orientation Orientation) Paned {
	var arg1 C.GtkOrientation

	arg1 = (C.GtkOrientation)(orientation)

	var cret C.GtkPaned

	cret = C.gtk_paned_new(arg1)

	var paned Paned

	paned = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Paned)

	return paned
}

// EndChild retrieves the end child of the given Paned.
//
// See also: Paned:end-child
func (p paned) EndChild() Widget {
	var arg0 *C.GtkPaned

	arg0 = (*C.GtkPaned)(unsafe.Pointer(p.Native()))

	var cret *C.GtkWidget

	cret = C.gtk_paned_get_end_child(arg0)

	var widget Widget

	widget = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Widget)

	return widget
}

// Position obtains the position of the divider between the two panes.
func (p paned) Position() int {
	var arg0 *C.GtkPaned

	arg0 = (*C.GtkPaned)(unsafe.Pointer(p.Native()))

	var cret C.int

	cret = C.gtk_paned_get_position(arg0)

	var gint int

	gint = (int)(cret)

	return gint
}

// ResizeEndChild returns whether the end child can be resized.
func (p paned) ResizeEndChild() bool {
	var arg0 *C.GtkPaned

	arg0 = (*C.GtkPaned)(unsafe.Pointer(p.Native()))

	var cret C.gboolean

	cret = C.gtk_paned_get_resize_end_child(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// ResizeStartChild returns whether the start child can be resized.
func (p paned) ResizeStartChild() bool {
	var arg0 *C.GtkPaned

	arg0 = (*C.GtkPaned)(unsafe.Pointer(p.Native()))

	var cret C.gboolean

	cret = C.gtk_paned_get_resize_start_child(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// ShrinkEndChild returns whether the end child can be shrunk.
func (p paned) ShrinkEndChild() bool {
	var arg0 *C.GtkPaned

	arg0 = (*C.GtkPaned)(unsafe.Pointer(p.Native()))

	var cret C.gboolean

	cret = C.gtk_paned_get_shrink_end_child(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// ShrinkStartChild returns whether the start child can be shrunk.
func (p paned) ShrinkStartChild() bool {
	var arg0 *C.GtkPaned

	arg0 = (*C.GtkPaned)(unsafe.Pointer(p.Native()))

	var cret C.gboolean

	cret = C.gtk_paned_get_shrink_start_child(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// StartChild retrieves the start child of the given Paned.
//
// See also: Paned:start-child
func (p paned) StartChild() Widget {
	var arg0 *C.GtkPaned

	arg0 = (*C.GtkPaned)(unsafe.Pointer(p.Native()))

	var cret *C.GtkWidget

	cret = C.gtk_paned_get_start_child(arg0)

	var widget Widget

	widget = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Widget)

	return widget
}

// WideHandle gets the Paned:wide-handle property.
func (p paned) WideHandle() bool {
	var arg0 *C.GtkPaned

	arg0 = (*C.GtkPaned)(unsafe.Pointer(p.Native()))

	var cret C.gboolean

	cret = C.gtk_paned_get_wide_handle(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// SetEndChild sets the end child of @paned to @child.
func (p paned) SetEndChild(child Widget) {
	var arg0 *C.GtkPaned
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkPaned)(unsafe.Pointer(p.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_paned_set_end_child(arg0, arg1)
}

// SetPosition sets the position of the divider between the two panes.
func (p paned) SetPosition(position int) {
	var arg0 *C.GtkPaned
	var arg1 C.int

	arg0 = (*C.GtkPaned)(unsafe.Pointer(p.Native()))
	arg1 = C.int(position)

	C.gtk_paned_set_position(arg0, arg1)
}

// SetResizeEndChild sets the Paned:resize-end-child property
func (p paned) SetResizeEndChild(resize bool) {
	var arg0 *C.GtkPaned
	var arg1 C.gboolean

	arg0 = (*C.GtkPaned)(unsafe.Pointer(p.Native()))
	if resize {
		arg1 = C.gboolean(1)
	}

	C.gtk_paned_set_resize_end_child(arg0, arg1)
}

// SetResizeStartChild sets the Paned:resize-start-child property
func (p paned) SetResizeStartChild(resize bool) {
	var arg0 *C.GtkPaned
	var arg1 C.gboolean

	arg0 = (*C.GtkPaned)(unsafe.Pointer(p.Native()))
	if resize {
		arg1 = C.gboolean(1)
	}

	C.gtk_paned_set_resize_start_child(arg0, arg1)
}

// SetShrinkEndChild sets the Paned:shrink-end-child property
func (p paned) SetShrinkEndChild(resize bool) {
	var arg0 *C.GtkPaned
	var arg1 C.gboolean

	arg0 = (*C.GtkPaned)(unsafe.Pointer(p.Native()))
	if resize {
		arg1 = C.gboolean(1)
	}

	C.gtk_paned_set_shrink_end_child(arg0, arg1)
}

// SetShrinkStartChild sets the Paned:shrink-start-child property
func (p paned) SetShrinkStartChild(resize bool) {
	var arg0 *C.GtkPaned
	var arg1 C.gboolean

	arg0 = (*C.GtkPaned)(unsafe.Pointer(p.Native()))
	if resize {
		arg1 = C.gboolean(1)
	}

	C.gtk_paned_set_shrink_start_child(arg0, arg1)
}

// SetStartChild sets the start child of @paned to @child.
func (p paned) SetStartChild(child Widget) {
	var arg0 *C.GtkPaned
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkPaned)(unsafe.Pointer(p.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_paned_set_start_child(arg0, arg1)
}

// SetWideHandle sets the Paned:wide-handle property.
func (p paned) SetWideHandle(wide bool) {
	var arg0 *C.GtkPaned
	var arg1 C.gboolean

	arg0 = (*C.GtkPaned)(unsafe.Pointer(p.Native()))
	if wide {
		arg1 = C.gboolean(1)
	}

	C.gtk_paned_set_wide_handle(arg0, arg1)
}

// PopoverMenu: gtkPopoverMenu is a subclass of Popover that treats its children
// like menus and allows switching between them. It can open submenus as
// traditional, nested submenus, or in a more touch-friendly sliding fashion.
//
// GtkPopoverMenu is meant to be used primarily with menu models, using
// gtk_popover_menu_new_from_model(). If you need to put other widgets such as
// SpinButton or Switch into a popover, use a plain Popover.
//
//
// Menu models
//
// The XML format understood by Builder for Model consists of a toplevel
// `<menu>` element, which contains one or more `<item>` elements. Each `<item>`
// element contains `<attribute>` and `<link>` elements with a mandatory name
// attribute. `<link>` elements have the same content model as `<menu>`. Instead
// of `<link name="submenu>` or `<link name="section">`, you can use `<submenu>`
// or `<section>` elements.
//
//    <menu id='app-menu'>
//      <section>
//        <item>
//          <attribute name='label' translatable='yes'>_New Window</attribute>
//          <attribute name='action'>app.new</attribute>
//        </item>
//        <item>
//          <attribute name='label' translatable='yes'>_About Sunny</attribute>
//          <attribute name='action'>app.about</attribute>
//        </item>
//        <item>
//          <attribute name='label' translatable='yes'>_Quit</attribute>
//          <attribute name='action'>app.quit</attribute>
//        </item>
//      </section>
//    </menu>
//
// Attribute values can be translated using gettext, like other Builder content.
// `<attribute>` elements can be marked for translation with a
// `translatable="yes"` attribute. It is also possible to specify message
// context and translator comments, using the context and comments attributes.
// To make use of this, the Builder must have been given the gettext domain to
// use.
//
// The following attributes are used when constructing menu items: - "label": a
// user-visible string to display - "action": the prefixed name of the action to
// trigger - "target": the parameter to use when activating the action - "icon"
// and "verb-icon": names of icons that may be displayed - "submenu-action":
// name of an action that may be used to determine if a submenu can be opened -
// "hidden-when": a string used to determine when the item will be hidden.
// Possible values include "action-disabled", "action-missing", "macos-menubar".
// This is mainly useful for exported menus, see gtk_application_set_menubar().
// - "custom": a string used to match against the ID of a custom child added
// with gtk_popover_menu_add_child(), gtk_popover_menu_bar_add_child(), or in
// the ui file with `<child type="ID">`.
//
// The following attributes are used when constructing sections: - "label": a
// user-visible string to use as section heading - "display-hint": a string used
// to determine special formatting for the section. Possible values include
// "horizontal-buttons", "circular-buttons" and "inline-buttons". They all
// indicate that section should be displayed as a horizontal row of buttons. -
// "text-direction": a string used to determine the TextDirection to use when
// "display-hint" is set to "horizontal-buttons". Possible values include "rtl",
// "ltr", and "none".
//
// The following attributes are used when constructing submenus: - "label": a
// user-visible string to display - "icon": icon name to display
//
// Menu items will also show accelerators, which are usually associated with
// actions via gtk_application_set_accels_for_action(),
// gtk_widget_class_add_binding_action() or
// gtk_shortcut_controller_add_shortcut().
//
//
// CSS Nodes
//
// PopoverMenu is just a subclass of Popover that adds custom content to it,
// therefore it has the same CSS nodes. It is one of the cases that add a .menu
// style class to the popover's main node.
//
//
// Accessibility
//
// GtkPopoverMenu uses the K_ACCESSIBLE_ROLE_MENU role, and its items use the
// K_ACCESSIBLE_ROLE_MENU_ITEM, K_ACCESSIBLE_ROLE_MENU_ITEM_CHECKBOX or
// K_ACCESSIBLE_ROLE_MENU_ITEM_RADIO roles, depending on the action they are
// connected to.
type PopoverMenu interface {
	Popover
	Accessible
	Buildable
	ConstraintTarget
	Native
	ShortcutManager

	// AddChild adds a custom widget to a generated menu.
	//
	// For this to work, the menu model of @popover must have an item with a
	// `custom` attribute that matches @id.
	AddChild(child Widget, id string) bool
	// MenuModel returns the menu model used to populate the popover.
	MenuModel() gio.MenuModel
	// RemoveChild removes a widget that has previously been added with
	// gtk_popover_menu_add_child().
	RemoveChild(child Widget) bool
	// SetMenuModel sets a new menu model on @popover.
	//
	// The existing contents of @popover are removed, and the @popover is
	// populated with new contents according to @model.
	SetMenuModel(model gio.MenuModel)
}

// popoverMenu implements the PopoverMenu interface.
type popoverMenu struct {
	Popover
	Accessible
	Buildable
	ConstraintTarget
	Native
	ShortcutManager
}

var _ PopoverMenu = (*popoverMenu)(nil)

// WrapPopoverMenu wraps a GObject to the right type. It is
// primarily used internally.
func WrapPopoverMenu(obj *externglib.Object) PopoverMenu {
	return PopoverMenu{
		Popover:          WrapPopover(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
		Native:           WrapNative(obj),
		ShortcutManager:  WrapShortcutManager(obj),
	}
}

func marshalPopoverMenu(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPopoverMenu(obj), nil
}

// NewPopoverMenuFromModel constructs a class PopoverMenu.
func NewPopoverMenuFromModel(model gio.MenuModel) PopoverMenu {
	var arg1 *C.GMenuModel

	arg1 = (*C.GMenuModel)(unsafe.Pointer(model.Native()))

	var cret C.GtkPopoverMenu

	cret = C.gtk_popover_menu_new_from_model(arg1)

	var popoverMenu PopoverMenu

	popoverMenu = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(PopoverMenu)

	return popoverMenu
}

// NewPopoverMenuFromModelFull constructs a class PopoverMenu.
func NewPopoverMenuFromModelFull(model gio.MenuModel, flags PopoverMenuFlags) PopoverMenu {
	var arg1 *C.GMenuModel
	var arg2 C.GtkPopoverMenuFlags

	arg1 = (*C.GMenuModel)(unsafe.Pointer(model.Native()))
	arg2 = (C.GtkPopoverMenuFlags)(flags)

	var cret C.GtkPopoverMenu

	cret = C.gtk_popover_menu_new_from_model_full(arg1, arg2)

	var popoverMenu PopoverMenu

	popoverMenu = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(PopoverMenu)

	return popoverMenu
}

// AddChild adds a custom widget to a generated menu.
//
// For this to work, the menu model of @popover must have an item with a
// `custom` attribute that matches @id.
func (p popoverMenu) AddChild(child Widget, id string) bool {
	var arg0 *C.GtkPopoverMenu
	var arg1 *C.GtkWidget
	var arg2 *C.char

	arg0 = (*C.GtkPopoverMenu)(unsafe.Pointer(p.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	arg2 = (*C.char)(C.CString(id))
	defer C.free(unsafe.Pointer(arg2))

	var cret C.gboolean

	cret = C.gtk_popover_menu_add_child(arg0, arg1, arg2)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// MenuModel returns the menu model used to populate the popover.
func (p popoverMenu) MenuModel() gio.MenuModel {
	var arg0 *C.GtkPopoverMenu

	arg0 = (*C.GtkPopoverMenu)(unsafe.Pointer(p.Native()))

	var cret *C.GMenuModel

	cret = C.gtk_popover_menu_get_menu_model(arg0)

	var menuModel gio.MenuModel

	menuModel = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(gio.MenuModel)

	return menuModel
}

// RemoveChild removes a widget that has previously been added with
// gtk_popover_menu_add_child().
func (p popoverMenu) RemoveChild(child Widget) bool {
	var arg0 *C.GtkPopoverMenu
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkPopoverMenu)(unsafe.Pointer(p.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	var cret C.gboolean

	cret = C.gtk_popover_menu_remove_child(arg0, arg1)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// SetMenuModel sets a new menu model on @popover.
//
// The existing contents of @popover are removed, and the @popover is
// populated with new contents according to @model.
func (p popoverMenu) SetMenuModel(model gio.MenuModel) {
	var arg0 *C.GtkPopoverMenu
	var arg1 *C.GMenuModel

	arg0 = (*C.GtkPopoverMenu)(unsafe.Pointer(p.Native()))
	arg1 = (*C.GMenuModel)(unsafe.Pointer(model.Native()))

	C.gtk_popover_menu_set_menu_model(arg0, arg1)
}

// PopoverMenuBar: gtkPopoverMenuBar presents a horizontal bar of items that pop
// up popover menus when clicked.
//
// The only way to create instances of GtkPopoverMenuBar is from a Model.
//
// CSS nodes
//
//    menubar
//    ├── item[.active]
//    ┊   ╰── popover
//    ╰── item
//        ╰── popover
//
// GtkPopoverMenuBar has a single CSS node with name menubar, below which each
// item has its CSS node, and below that the corresponding popover.
//
// The item whose popover is currently open gets the .active style class.
//
//
// Accessibility
//
// GtkPopoverMenuBar uses the K_ACCESSIBLE_ROLE_MENU_BAR role, the menu items
// use the K_ACCESSIBLE_ROLE_MENU_ITEM role and the menus use the
// K_ACCESSIBLE_ROLE_MENU role.
type PopoverMenuBar interface {
	Widget
	Accessible
	Buildable
	ConstraintTarget

	// AddChild adds a custom widget to a generated menubar.
	//
	// For this to work, the menu model of @bar must have an item with a
	// `custom` attribute that matches @id.
	AddChild(child Widget, id string) bool
	// MenuModel returns the model from which the contents of @bar are taken.
	MenuModel() gio.MenuModel
	// RemoveChild removes a widget that has previously been added with
	// gtk_popover_menu_bar_add_child().
	RemoveChild(child Widget) bool
	// SetMenuModel sets a menu model from which @bar should take its contents.
	SetMenuModel(model gio.MenuModel)
}

// popoverMenuBar implements the PopoverMenuBar interface.
type popoverMenuBar struct {
	Widget
	Accessible
	Buildable
	ConstraintTarget
}

var _ PopoverMenuBar = (*popoverMenuBar)(nil)

// WrapPopoverMenuBar wraps a GObject to the right type. It is
// primarily used internally.
func WrapPopoverMenuBar(obj *externglib.Object) PopoverMenuBar {
	return PopoverMenuBar{
		Widget:           WrapWidget(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
	}
}

func marshalPopoverMenuBar(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPopoverMenuBar(obj), nil
}

// NewPopoverMenuBarFromModel constructs a class PopoverMenuBar.
func NewPopoverMenuBarFromModel(model gio.MenuModel) PopoverMenuBar {
	var arg1 *C.GMenuModel

	arg1 = (*C.GMenuModel)(unsafe.Pointer(model.Native()))

	var cret C.GtkPopoverMenuBar

	cret = C.gtk_popover_menu_bar_new_from_model(arg1)

	var popoverMenuBar PopoverMenuBar

	popoverMenuBar = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(PopoverMenuBar)

	return popoverMenuBar
}

// AddChild adds a custom widget to a generated menubar.
//
// For this to work, the menu model of @bar must have an item with a
// `custom` attribute that matches @id.
func (b popoverMenuBar) AddChild(child Widget, id string) bool {
	var arg0 *C.GtkPopoverMenuBar
	var arg1 *C.GtkWidget
	var arg2 *C.char

	arg0 = (*C.GtkPopoverMenuBar)(unsafe.Pointer(b.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	arg2 = (*C.char)(C.CString(id))
	defer C.free(unsafe.Pointer(arg2))

	var cret C.gboolean

	cret = C.gtk_popover_menu_bar_add_child(arg0, arg1, arg2)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// MenuModel returns the model from which the contents of @bar are taken.
func (b popoverMenuBar) MenuModel() gio.MenuModel {
	var arg0 *C.GtkPopoverMenuBar

	arg0 = (*C.GtkPopoverMenuBar)(unsafe.Pointer(b.Native()))

	var cret *C.GMenuModel

	cret = C.gtk_popover_menu_bar_get_menu_model(arg0)

	var menuModel gio.MenuModel

	menuModel = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(gio.MenuModel)

	return menuModel
}

// RemoveChild removes a widget that has previously been added with
// gtk_popover_menu_bar_add_child().
func (b popoverMenuBar) RemoveChild(child Widget) bool {
	var arg0 *C.GtkPopoverMenuBar
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkPopoverMenuBar)(unsafe.Pointer(b.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	var cret C.gboolean

	cret = C.gtk_popover_menu_bar_remove_child(arg0, arg1)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// SetMenuModel sets a menu model from which @bar should take its contents.
func (b popoverMenuBar) SetMenuModel(model gio.MenuModel) {
	var arg0 *C.GtkPopoverMenuBar
	var arg1 *C.GMenuModel

	arg0 = (*C.GtkPopoverMenuBar)(unsafe.Pointer(b.Native()))
	arg1 = (*C.GMenuModel)(unsafe.Pointer(model.Native()))

	C.gtk_popover_menu_bar_set_menu_model(arg0, arg1)
}

// PrintContext: a GtkPrintContext encapsulates context information that is
// required when drawing pages for printing, such as the cairo context and
// important parameters like page size and resolution. It also lets you easily
// create Layout and Context objects that match the font metrics of the cairo
// surface.
//
// GtkPrintContext objects gets passed to the PrintOperation::begin-print,
// PrintOperation::end-print, PrintOperation::request-page-setup and
// PrintOperation::draw-page signals on the PrintOperation.
//
// Using GtkPrintContext in a PrintOperation::draw-page callback
//
//    static void
//    draw_page (GtkPrintOperation *operation,
//    	   GtkPrintContext   *context,
//    	   int                page_nr)
//    {
//      cairo_t *cr;
//      PangoLayout *layout;
//      PangoFontDescription *desc;
//
//      cr = gtk_print_context_get_cairo_context (context);
//
//      // Draw a red rectangle, as wide as the paper (inside the margins)
//      cairo_set_source_rgb (cr, 1.0, 0, 0);
//      cairo_rectangle (cr, 0, 0, gtk_print_context_get_width (context), 50);
//
//      cairo_fill (cr);
//
//      // Draw some lines
//      cairo_move_to (cr, 20, 10);
//      cairo_line_to (cr, 40, 20);
//      cairo_arc (cr, 60, 60, 20, 0, M_PI);
//      cairo_line_to (cr, 80, 20);
//
//      cairo_set_source_rgb (cr, 0, 0, 0);
//      cairo_set_line_width (cr, 5);
//      cairo_set_line_cap (cr, CAIRO_LINE_CAP_ROUND);
//      cairo_set_line_join (cr, CAIRO_LINE_JOIN_ROUND);
//
//      cairo_stroke (cr);
//
//      // Draw some text
//      layout = gtk_print_context_create_pango_layout (context);
//      pango_layout_set_text (layout, "Hello World! Printing is easy", -1);
//      desc = pango_font_description_from_string ("sans 28");
//      pango_layout_set_font_description (layout, desc);
//      pango_font_description_free (desc);
//
//      cairo_move_to (cr, 30, 20);
//      pango_cairo_layout_path (cr, layout);
//
//      // Font Outline
//      cairo_set_source_rgb (cr, 0.93, 1.0, 0.47);
//      cairo_set_line_width (cr, 0.5);
//      cairo_stroke_preserve (cr);
//
//      // Font Fill
//      cairo_set_source_rgb (cr, 0, 0.0, 1.0);
//      cairo_fill (cr);
//
//      g_object_unref (layout);
//    }
type PrintContext interface {
	gextras.Objector

	// CreatePangoContext creates a new Context that can be used with the
	// PrintContext.
	CreatePangoContext() pango.Context
	// CreatePangoLayout creates a new Layout that is suitable for use with the
	// PrintContext.
	CreatePangoLayout() pango.Layout
	// CairoContext obtains the cairo context that is associated with the
	// PrintContext.
	CairoContext() *cairo.Context
	// DPIX obtains the horizontal resolution of the PrintContext, in dots per
	// inch.
	DPIX() float64
	// DPIY obtains the vertical resolution of the PrintContext, in dots per
	// inch.
	DPIY() float64
	// HardMargins obtains the hardware printer margins of the PrintContext, in
	// units.
	HardMargins() (top float64, bottom float64, left float64, right float64, ok bool)
	// Height obtains the height of the PrintContext, in pixels.
	Height() float64
	// PageSetup obtains the PageSetup that determines the page dimensions of
	// the PrintContext.
	PageSetup() PageSetup
	// PangoFontmap returns a FontMap that is suitable for use with the
	// PrintContext.
	PangoFontmap() pango.FontMap
	// Width obtains the width of the PrintContext, in pixels.
	Width() float64
	// SetCairoContext sets a new cairo context on a print context.
	//
	// This function is intended to be used when implementing an internal print
	// preview, it is not needed for printing, since GTK itself creates a
	// suitable cairo context in that case.
	SetCairoContext(cr *cairo.Context, dpiX float64, dpiY float64)
}

// printContext implements the PrintContext interface.
type printContext struct {
	gextras.Objector
}

var _ PrintContext = (*printContext)(nil)

// WrapPrintContext wraps a GObject to the right type. It is
// primarily used internally.
func WrapPrintContext(obj *externglib.Object) PrintContext {
	return PrintContext{
		Objector: obj,
	}
}

func marshalPrintContext(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPrintContext(obj), nil
}

// CreatePangoContext creates a new Context that can be used with the
// PrintContext.
func (c printContext) CreatePangoContext() pango.Context {
	var arg0 *C.GtkPrintContext

	arg0 = (*C.GtkPrintContext)(unsafe.Pointer(c.Native()))

	var cret *C.PangoContext

	cret = C.gtk_print_context_create_pango_context(arg0)

	var ret pango.Context

	ret = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(pango.Context)

	return ret
}

// CreatePangoLayout creates a new Layout that is suitable for use with the
// PrintContext.
func (c printContext) CreatePangoLayout() pango.Layout {
	var arg0 *C.GtkPrintContext

	arg0 = (*C.GtkPrintContext)(unsafe.Pointer(c.Native()))

	var cret *C.PangoLayout

	cret = C.gtk_print_context_create_pango_layout(arg0)

	var layout pango.Layout

	layout = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(pango.Layout)

	return layout
}

// CairoContext obtains the cairo context that is associated with the
// PrintContext.
func (c printContext) CairoContext() *cairo.Context {
	var arg0 *C.GtkPrintContext

	arg0 = (*C.GtkPrintContext)(unsafe.Pointer(c.Native()))

	var cret *C.cairo_t

	cret = C.gtk_print_context_get_cairo_context(arg0)

	var ret *cairo.Context

	ret = cairo.WrapContext(unsafe.Pointer(cret))

	return ret
}

// DPIX obtains the horizontal resolution of the PrintContext, in dots per
// inch.
func (c printContext) DPIX() float64 {
	var arg0 *C.GtkPrintContext

	arg0 = (*C.GtkPrintContext)(unsafe.Pointer(c.Native()))

	var cret C.double

	cret = C.gtk_print_context_get_dpi_x(arg0)

	var gdouble float64

	gdouble = (float64)(cret)

	return gdouble
}

// DPIY obtains the vertical resolution of the PrintContext, in dots per
// inch.
func (c printContext) DPIY() float64 {
	var arg0 *C.GtkPrintContext

	arg0 = (*C.GtkPrintContext)(unsafe.Pointer(c.Native()))

	var cret C.double

	cret = C.gtk_print_context_get_dpi_y(arg0)

	var gdouble float64

	gdouble = (float64)(cret)

	return gdouble
}

// HardMargins obtains the hardware printer margins of the PrintContext, in
// units.
func (c printContext) HardMargins() (top float64, bottom float64, left float64, right float64, ok bool) {
	var arg0 *C.GtkPrintContext

	arg0 = (*C.GtkPrintContext)(unsafe.Pointer(c.Native()))

	var arg1 C.double
	var arg2 C.double
	var arg3 C.double
	var arg4 C.double
	var cret C.gboolean

	cret = C.gtk_print_context_get_hard_margins(arg0, &arg1, &arg2, &arg3, &arg4)

	var top float64
	var bottom float64
	var left float64
	var right float64
	var ok bool

	top = (float64)(arg1)
	bottom = (float64)(arg2)
	left = (float64)(arg3)
	right = (float64)(arg4)
	if cret {
		ok = true
	}

	return top, bottom, left, right, ok
}

// Height obtains the height of the PrintContext, in pixels.
func (c printContext) Height() float64 {
	var arg0 *C.GtkPrintContext

	arg0 = (*C.GtkPrintContext)(unsafe.Pointer(c.Native()))

	var cret C.double

	cret = C.gtk_print_context_get_height(arg0)

	var gdouble float64

	gdouble = (float64)(cret)

	return gdouble
}

// PageSetup obtains the PageSetup that determines the page dimensions of
// the PrintContext.
func (c printContext) PageSetup() PageSetup {
	var arg0 *C.GtkPrintContext

	arg0 = (*C.GtkPrintContext)(unsafe.Pointer(c.Native()))

	var cret *C.GtkPageSetup

	cret = C.gtk_print_context_get_page_setup(arg0)

	var pageSetup PageSetup

	pageSetup = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(PageSetup)

	return pageSetup
}

// PangoFontmap returns a FontMap that is suitable for use with the
// PrintContext.
func (c printContext) PangoFontmap() pango.FontMap {
	var arg0 *C.GtkPrintContext

	arg0 = (*C.GtkPrintContext)(unsafe.Pointer(c.Native()))

	var cret *C.PangoFontMap

	cret = C.gtk_print_context_get_pango_fontmap(arg0)

	var fontMap pango.FontMap

	fontMap = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(pango.FontMap)

	return fontMap
}

// Width obtains the width of the PrintContext, in pixels.
func (c printContext) Width() float64 {
	var arg0 *C.GtkPrintContext

	arg0 = (*C.GtkPrintContext)(unsafe.Pointer(c.Native()))

	var cret C.double

	cret = C.gtk_print_context_get_width(arg0)

	var gdouble float64

	gdouble = (float64)(cret)

	return gdouble
}

// SetCairoContext sets a new cairo context on a print context.
//
// This function is intended to be used when implementing an internal print
// preview, it is not needed for printing, since GTK itself creates a
// suitable cairo context in that case.
func (c printContext) SetCairoContext(cr *cairo.Context, dpiX float64, dpiY float64) {
	var arg0 *C.GtkPrintContext
	var arg1 *C.cairo_t
	var arg2 C.double
	var arg3 C.double

	arg0 = (*C.GtkPrintContext)(unsafe.Pointer(c.Native()))
	arg1 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	arg2 = C.double(dpiX)
	arg3 = C.double(dpiY)

	C.gtk_print_context_set_cairo_context(arg0, arg1, arg2, arg3)
}

// PrintSettings: a GtkPrintSettings object represents the settings of a print
// dialog in a system-independent way. The main use for this object is that once
// you’ve printed you can get a settings object that represents the settings the
// user chose, and the next time you print you can pass that object in so that
// the user doesn’t have to re-set all his settings.
//
// Its also possible to enumerate the settings so that you can easily save the
// settings for the next time your app runs, or even store them in a document.
// The predefined keys try to use shared values as much as possible so that
// moving such a document between systems still works.
type PrintSettings interface {
	gextras.Objector

	// Copy copies a PrintSettings object.
	Copy() PrintSettings
	// Foreach calls @func for each key-value pair of @settings.
	Foreach()
	// Get looks up the string value associated with @key.
	Get(key string) string
	// Bool returns the boolean represented by the value that is associated with
	// @key.
	//
	// The string “true” represents true, any other string false.
	Bool(key string) bool
	// Collate gets the value of GTK_PRINT_SETTINGS_COLLATE.
	Collate() bool
	// DefaultSource gets the value of GTK_PRINT_SETTINGS_DEFAULT_SOURCE.
	DefaultSource() string
	// Dither gets the value of GTK_PRINT_SETTINGS_DITHER.
	Dither() string
	// Double returns the double value associated with @key, or 0.
	Double(key string) float64
	// DoubleWithDefault returns the floating point number represented by the
	// value that is associated with @key, or @default_val if the value does not
	// represent a floating point number.
	//
	// Floating point numbers are parsed with g_ascii_strtod().
	DoubleWithDefault(key string, def float64) float64
	// Duplex gets the value of GTK_PRINT_SETTINGS_DUPLEX.
	Duplex() PrintDuplex
	// Finishings gets the value of GTK_PRINT_SETTINGS_FINISHINGS.
	Finishings() string
	// Int returns the integer value of @key, or 0.
	Int(key string) int
	// IntWithDefault returns the value of @key, interpreted as an integer, or
	// the default value.
	IntWithDefault(key string, def int) int
	// Length returns the value associated with @key, interpreted as a length.
	// The returned value is converted to @units.
	Length(key string, unit Unit) float64
	// MediaType gets the value of GTK_PRINT_SETTINGS_MEDIA_TYPE.
	//
	// The set of media types is defined in PWG 5101.1-2002 PWG.
	MediaType() string
	// NCopies gets the value of GTK_PRINT_SETTINGS_N_COPIES.
	NCopies() int
	// NumberUp gets the value of GTK_PRINT_SETTINGS_NUMBER_UP.
	NumberUp() int
	// NumberUpLayout gets the value of GTK_PRINT_SETTINGS_NUMBER_UP_LAYOUT.
	NumberUpLayout() NumberUpLayout
	// Orientation: get the value of GTK_PRINT_SETTINGS_ORIENTATION, converted
	// to a PageOrientation.
	Orientation() PageOrientation
	// OutputBin gets the value of GTK_PRINT_SETTINGS_OUTPUT_BIN.
	OutputBin() string
	// PageRanges gets the value of GTK_PRINT_SETTINGS_PAGE_RANGES.
	PageRanges() []PageRange
	// PageSet gets the value of GTK_PRINT_SETTINGS_PAGE_SET.
	PageSet() PageSet
	// PaperHeight gets the value of GTK_PRINT_SETTINGS_PAPER_HEIGHT, converted
	// to @unit.
	PaperHeight(unit Unit) float64
	// PaperSize gets the value of GTK_PRINT_SETTINGS_PAPER_FORMAT, converted to
	// a PaperSize.
	PaperSize() *PaperSize
	// PaperWidth gets the value of GTK_PRINT_SETTINGS_PAPER_WIDTH, converted to
	// @unit.
	PaperWidth(unit Unit) float64
	// PrintPages gets the value of GTK_PRINT_SETTINGS_PRINT_PAGES.
	PrintPages() PrintPages
	// Printer: convenience function to obtain the value of
	// GTK_PRINT_SETTINGS_PRINTER.
	Printer() string
	// PrinterLpi gets the value of GTK_PRINT_SETTINGS_PRINTER_LPI.
	PrinterLpi() float64
	// Quality gets the value of GTK_PRINT_SETTINGS_QUALITY.
	Quality() PrintQuality
	// Resolution gets the value of GTK_PRINT_SETTINGS_RESOLUTION.
	Resolution() int
	// ResolutionX gets the value of GTK_PRINT_SETTINGS_RESOLUTION_X.
	ResolutionX() int
	// ResolutionY gets the value of GTK_PRINT_SETTINGS_RESOLUTION_Y.
	ResolutionY() int
	// Reverse gets the value of GTK_PRINT_SETTINGS_REVERSE.
	Reverse() bool
	// Scale gets the value of GTK_PRINT_SETTINGS_SCALE.
	Scale() float64
	// UseColor gets the value of GTK_PRINT_SETTINGS_USE_COLOR.
	UseColor() bool
	// HasKey returns true, if a value is associated with @key.
	HasKey(key string) bool
	// LoadFile reads the print settings from @file_name. If the file could not
	// be loaded then error is set to either a Error or FileError. See
	// gtk_print_settings_to_file().
	LoadFile(fileName *string) error
	// LoadKeyFile reads the print settings from the group @group_name in
	// @key_file. If the file could not be loaded then error is set to either a
	// Error or FileError.
	LoadKeyFile(keyFile *glib.KeyFile, groupName string) error
	// Set associates @value with @key.
	Set(key string, value string)
	// SetBool sets @key to a boolean value.
	SetBool(key string, value bool)
	// SetCollate sets the value of GTK_PRINT_SETTINGS_COLLATE.
	SetCollate(collate bool)
	// SetDefaultSource sets the value of GTK_PRINT_SETTINGS_DEFAULT_SOURCE.
	SetDefaultSource(defaultSource string)
	// SetDither sets the value of GTK_PRINT_SETTINGS_DITHER.
	SetDither(dither string)
	// SetDouble sets @key to a double value.
	SetDouble(key string, value float64)
	// SetDuplex sets the value of GTK_PRINT_SETTINGS_DUPLEX.
	SetDuplex(duplex PrintDuplex)
	// SetFinishings sets the value of GTK_PRINT_SETTINGS_FINISHINGS.
	SetFinishings(finishings string)
	// SetInt sets @key to an integer value.
	SetInt(key string, value int)
	// SetLength associates a length in units of @unit with @key.
	SetLength(key string, value float64, unit Unit)
	// SetMediaType sets the value of GTK_PRINT_SETTINGS_MEDIA_TYPE.
	//
	// The set of media types is defined in PWG 5101.1-2002 PWG.
	SetMediaType(mediaType string)
	// SetNCopies sets the value of GTK_PRINT_SETTINGS_N_COPIES.
	SetNCopies(numCopies int)
	// SetNumberUp sets the value of GTK_PRINT_SETTINGS_NUMBER_UP.
	SetNumberUp(numberUp int)
	// SetNumberUpLayout sets the value of GTK_PRINT_SETTINGS_NUMBER_UP_LAYOUT.
	SetNumberUpLayout(numberUpLayout NumberUpLayout)
	// SetOrientation sets the value of GTK_PRINT_SETTINGS_ORIENTATION.
	SetOrientation(orientation PageOrientation)
	// SetOutputBin sets the value of GTK_PRINT_SETTINGS_OUTPUT_BIN.
	SetOutputBin(outputBin string)
	// SetPageRanges sets the value of GTK_PRINT_SETTINGS_PAGE_RANGES.
	SetPageRanges()
	// SetPageSet sets the value of GTK_PRINT_SETTINGS_PAGE_SET.
	SetPageSet(pageSet PageSet)
	// SetPaperHeight sets the value of GTK_PRINT_SETTINGS_PAPER_HEIGHT.
	SetPaperHeight(height float64, unit Unit)
	// SetPaperSize sets the value of GTK_PRINT_SETTINGS_PAPER_FORMAT,
	// GTK_PRINT_SETTINGS_PAPER_WIDTH and GTK_PRINT_SETTINGS_PAPER_HEIGHT.
	SetPaperSize(paperSize *PaperSize)
	// SetPaperWidth sets the value of GTK_PRINT_SETTINGS_PAPER_WIDTH.
	SetPaperWidth(width float64, unit Unit)
	// SetPrintPages sets the value of GTK_PRINT_SETTINGS_PRINT_PAGES.
	SetPrintPages(pages PrintPages)
	// SetPrinter: convenience function to set GTK_PRINT_SETTINGS_PRINTER to
	// @printer.
	SetPrinter(printer string)
	// SetPrinterLpi sets the value of GTK_PRINT_SETTINGS_PRINTER_LPI.
	SetPrinterLpi(lpi float64)
	// SetQuality sets the value of GTK_PRINT_SETTINGS_QUALITY.
	SetQuality(quality PrintQuality)
	// SetResolution sets the values of GTK_PRINT_SETTINGS_RESOLUTION,
	// GTK_PRINT_SETTINGS_RESOLUTION_X and GTK_PRINT_SETTINGS_RESOLUTION_Y.
	SetResolution(resolution int)
	// SetResolutionXY sets the values of GTK_PRINT_SETTINGS_RESOLUTION,
	// GTK_PRINT_SETTINGS_RESOLUTION_X and GTK_PRINT_SETTINGS_RESOLUTION_Y.
	SetResolutionXY(resolutionX int, resolutionY int)
	// SetReverse sets the value of GTK_PRINT_SETTINGS_REVERSE.
	SetReverse(reverse bool)
	// SetScale sets the value of GTK_PRINT_SETTINGS_SCALE.
	SetScale(scale float64)
	// SetUseColor sets the value of GTK_PRINT_SETTINGS_USE_COLOR.
	SetUseColor(useColor bool)
	// ToFile: this function saves the print settings from @settings to
	// @file_name. If the file could not be loaded then error is set to either a
	// Error or FileError.
	ToFile(fileName *string) error
	// ToGVariant: serialize print settings to an a{sv} variant.
	ToGVariant() *glib.Variant
	// ToKeyFile: this function adds the print settings from @settings to
	// @key_file.
	ToKeyFile(keyFile *glib.KeyFile, groupName string)
	// Unset removes any value associated with @key. This has the same effect as
	// setting the value to nil.
	Unset(key string)
}

// printSettings implements the PrintSettings interface.
type printSettings struct {
	gextras.Objector
}

var _ PrintSettings = (*printSettings)(nil)

// WrapPrintSettings wraps a GObject to the right type. It is
// primarily used internally.
func WrapPrintSettings(obj *externglib.Object) PrintSettings {
	return PrintSettings{
		Objector: obj,
	}
}

func marshalPrintSettings(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPrintSettings(obj), nil
}

// NewPrintSettings constructs a class PrintSettings.
func NewPrintSettings() PrintSettings {
	var cret C.GtkPrintSettings

	cret = C.gtk_print_settings_new()

	var printSettings PrintSettings

	printSettings = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(PrintSettings)

	return printSettings
}

// NewPrintSettingsFromFile constructs a class PrintSettings.
func NewPrintSettingsFromFile(fileName *string) (printSettings PrintSettings, goerr error) {
	var arg1 *C.char

	arg1 = (*C.char)(C.CString(fileName))
	defer C.free(unsafe.Pointer(arg1))

	var cret C.GtkPrintSettings
	var cerr *C.GError

	cret = C.gtk_print_settings_new_from_file(arg1, cerr)

	var printSettings PrintSettings
	var goerr error

	printSettings = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(PrintSettings)
	goerr = gerror.Take(unsafe.Pointer(cerr))

	return printSettings, goerr
}

// NewPrintSettingsFromGVariant constructs a class PrintSettings.
func NewPrintSettingsFromGVariant(variant *glib.Variant) PrintSettings {
	var arg1 *C.GVariant

	arg1 = (*C.GVariant)(unsafe.Pointer(variant.Native()))

	var cret C.GtkPrintSettings

	cret = C.gtk_print_settings_new_from_gvariant(arg1)

	var printSettings PrintSettings

	printSettings = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(PrintSettings)

	return printSettings
}

// NewPrintSettingsFromKeyFile constructs a class PrintSettings.
func NewPrintSettingsFromKeyFile(keyFile *glib.KeyFile, groupName string) (printSettings PrintSettings, goerr error) {
	var arg1 *C.GKeyFile
	var arg2 *C.char

	arg1 = (*C.GKeyFile)(unsafe.Pointer(keyFile.Native()))
	arg2 = (*C.char)(C.CString(groupName))
	defer C.free(unsafe.Pointer(arg2))

	var cret C.GtkPrintSettings
	var cerr *C.GError

	cret = C.gtk_print_settings_new_from_key_file(arg1, arg2, cerr)

	var printSettings PrintSettings
	var goerr error

	printSettings = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(PrintSettings)
	goerr = gerror.Take(unsafe.Pointer(cerr))

	return printSettings, goerr
}

// Copy copies a PrintSettings object.
func (o printSettings) Copy() PrintSettings {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(o.Native()))

	var cret *C.GtkPrintSettings

	cret = C.gtk_print_settings_copy(arg0)

	var printSettings PrintSettings

	printSettings = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(PrintSettings)

	return printSettings
}

// Foreach calls @func for each key-value pair of @settings.
func (s printSettings) Foreach() {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	C.gtk_print_settings_foreach(arg0)
}

// Get looks up the string value associated with @key.
func (s printSettings) Get(key string) string {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.char

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	arg1 = (*C.char)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))

	var cret *C.char

	cret = C.gtk_print_settings_get(arg0, arg1)

	var utf8 string

	utf8 = C.GoString(cret)

	return utf8
}

// Bool returns the boolean represented by the value that is associated with
// @key.
//
// The string “true” represents true, any other string false.
func (s printSettings) Bool(key string) bool {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.char

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	arg1 = (*C.char)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))

	var cret C.gboolean

	cret = C.gtk_print_settings_get_bool(arg0, arg1)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// Collate gets the value of GTK_PRINT_SETTINGS_COLLATE.
func (s printSettings) Collate() bool {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	var cret C.gboolean

	cret = C.gtk_print_settings_get_collate(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// DefaultSource gets the value of GTK_PRINT_SETTINGS_DEFAULT_SOURCE.
func (s printSettings) DefaultSource() string {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	var cret *C.char

	cret = C.gtk_print_settings_get_default_source(arg0)

	var utf8 string

	utf8 = C.GoString(cret)

	return utf8
}

// Dither gets the value of GTK_PRINT_SETTINGS_DITHER.
func (s printSettings) Dither() string {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	var cret *C.char

	cret = C.gtk_print_settings_get_dither(arg0)

	var utf8 string

	utf8 = C.GoString(cret)

	return utf8
}

// Double returns the double value associated with @key, or 0.
func (s printSettings) Double(key string) float64 {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.char

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	arg1 = (*C.char)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))

	var cret C.double

	cret = C.gtk_print_settings_get_double(arg0, arg1)

	var gdouble float64

	gdouble = (float64)(cret)

	return gdouble
}

// DoubleWithDefault returns the floating point number represented by the
// value that is associated with @key, or @default_val if the value does not
// represent a floating point number.
//
// Floating point numbers are parsed with g_ascii_strtod().
func (s printSettings) DoubleWithDefault(key string, def float64) float64 {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.char
	var arg2 C.double

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	arg1 = (*C.char)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.double(def)

	var cret C.double

	cret = C.gtk_print_settings_get_double_with_default(arg0, arg1, arg2)

	var gdouble float64

	gdouble = (float64)(cret)

	return gdouble
}

// Duplex gets the value of GTK_PRINT_SETTINGS_DUPLEX.
func (s printSettings) Duplex() PrintDuplex {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	var cret C.GtkPrintDuplex

	cret = C.gtk_print_settings_get_duplex(arg0)

	var printDuplex PrintDuplex

	printDuplex = PrintDuplex(cret)

	return printDuplex
}

// Finishings gets the value of GTK_PRINT_SETTINGS_FINISHINGS.
func (s printSettings) Finishings() string {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	var cret *C.char

	cret = C.gtk_print_settings_get_finishings(arg0)

	var utf8 string

	utf8 = C.GoString(cret)

	return utf8
}

// Int returns the integer value of @key, or 0.
func (s printSettings) Int(key string) int {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.char

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	arg1 = (*C.char)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))

	var cret C.int

	cret = C.gtk_print_settings_get_int(arg0, arg1)

	var gint int

	gint = (int)(cret)

	return gint
}

// IntWithDefault returns the value of @key, interpreted as an integer, or
// the default value.
func (s printSettings) IntWithDefault(key string, def int) int {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.char
	var arg2 C.int

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	arg1 = (*C.char)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.int(def)

	var cret C.int

	cret = C.gtk_print_settings_get_int_with_default(arg0, arg1, arg2)

	var gint int

	gint = (int)(cret)

	return gint
}

// Length returns the value associated with @key, interpreted as a length.
// The returned value is converted to @units.
func (s printSettings) Length(key string, unit Unit) float64 {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.char
	var arg2 C.GtkUnit

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	arg1 = (*C.char)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (C.GtkUnit)(unit)

	var cret C.double

	cret = C.gtk_print_settings_get_length(arg0, arg1, arg2)

	var gdouble float64

	gdouble = (float64)(cret)

	return gdouble
}

// MediaType gets the value of GTK_PRINT_SETTINGS_MEDIA_TYPE.
//
// The set of media types is defined in PWG 5101.1-2002 PWG.
func (s printSettings) MediaType() string {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	var cret *C.char

	cret = C.gtk_print_settings_get_media_type(arg0)

	var utf8 string

	utf8 = C.GoString(cret)

	return utf8
}

// NCopies gets the value of GTK_PRINT_SETTINGS_N_COPIES.
func (s printSettings) NCopies() int {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	var cret C.int

	cret = C.gtk_print_settings_get_n_copies(arg0)

	var gint int

	gint = (int)(cret)

	return gint
}

// NumberUp gets the value of GTK_PRINT_SETTINGS_NUMBER_UP.
func (s printSettings) NumberUp() int {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	var cret C.int

	cret = C.gtk_print_settings_get_number_up(arg0)

	var gint int

	gint = (int)(cret)

	return gint
}

// NumberUpLayout gets the value of GTK_PRINT_SETTINGS_NUMBER_UP_LAYOUT.
func (s printSettings) NumberUpLayout() NumberUpLayout {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	var cret C.GtkNumberUpLayout

	cret = C.gtk_print_settings_get_number_up_layout(arg0)

	var numberUpLayout NumberUpLayout

	numberUpLayout = NumberUpLayout(cret)

	return numberUpLayout
}

// Orientation: get the value of GTK_PRINT_SETTINGS_ORIENTATION, converted
// to a PageOrientation.
func (s printSettings) Orientation() PageOrientation {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	var cret C.GtkPageOrientation

	cret = C.gtk_print_settings_get_orientation(arg0)

	var pageOrientation PageOrientation

	pageOrientation = PageOrientation(cret)

	return pageOrientation
}

// OutputBin gets the value of GTK_PRINT_SETTINGS_OUTPUT_BIN.
func (s printSettings) OutputBin() string {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	var cret *C.char

	cret = C.gtk_print_settings_get_output_bin(arg0)

	var utf8 string

	utf8 = C.GoString(cret)

	return utf8
}

// PageRanges gets the value of GTK_PRINT_SETTINGS_PAGE_RANGES.
func (s printSettings) PageRanges() []PageRange {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	var cret *C.GtkPageRange
	var arg1 *C.int

	cret = C.gtk_print_settings_get_page_ranges(arg0)

	var pageRanges []PageRange

	ptr.SetSlice(unsafe.Pointer(&pageRanges), unsafe.Pointer(cret), int(arg1))
	runtime.SetFinalizer(&pageRanges, func(v *[]PageRange) {
		C.free(ptr.Slice(unsafe.Pointer(v)))
	})

	return pageRanges
}

// PageSet gets the value of GTK_PRINT_SETTINGS_PAGE_SET.
func (s printSettings) PageSet() PageSet {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	var cret C.GtkPageSet

	cret = C.gtk_print_settings_get_page_set(arg0)

	var pageSet PageSet

	pageSet = PageSet(cret)

	return pageSet
}

// PaperHeight gets the value of GTK_PRINT_SETTINGS_PAPER_HEIGHT, converted
// to @unit.
func (s printSettings) PaperHeight(unit Unit) float64 {
	var arg0 *C.GtkPrintSettings
	var arg1 C.GtkUnit

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	arg1 = (C.GtkUnit)(unit)

	var cret C.double

	cret = C.gtk_print_settings_get_paper_height(arg0, arg1)

	var gdouble float64

	gdouble = (float64)(cret)

	return gdouble
}

// PaperSize gets the value of GTK_PRINT_SETTINGS_PAPER_FORMAT, converted to
// a PaperSize.
func (s printSettings) PaperSize() *PaperSize {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	var cret *C.GtkPaperSize

	cret = C.gtk_print_settings_get_paper_size(arg0)

	var paperSize *PaperSize

	paperSize = WrapPaperSize(unsafe.Pointer(cret))
	runtime.SetFinalizer(paperSize, func(v *PaperSize) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return paperSize
}

// PaperWidth gets the value of GTK_PRINT_SETTINGS_PAPER_WIDTH, converted to
// @unit.
func (s printSettings) PaperWidth(unit Unit) float64 {
	var arg0 *C.GtkPrintSettings
	var arg1 C.GtkUnit

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	arg1 = (C.GtkUnit)(unit)

	var cret C.double

	cret = C.gtk_print_settings_get_paper_width(arg0, arg1)

	var gdouble float64

	gdouble = (float64)(cret)

	return gdouble
}

// PrintPages gets the value of GTK_PRINT_SETTINGS_PRINT_PAGES.
func (s printSettings) PrintPages() PrintPages {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	var cret C.GtkPrintPages

	cret = C.gtk_print_settings_get_print_pages(arg0)

	var printPages PrintPages

	printPages = PrintPages(cret)

	return printPages
}

// Printer: convenience function to obtain the value of
// GTK_PRINT_SETTINGS_PRINTER.
func (s printSettings) Printer() string {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	var cret *C.char

	cret = C.gtk_print_settings_get_printer(arg0)

	var utf8 string

	utf8 = C.GoString(cret)

	return utf8
}

// PrinterLpi gets the value of GTK_PRINT_SETTINGS_PRINTER_LPI.
func (s printSettings) PrinterLpi() float64 {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	var cret C.double

	cret = C.gtk_print_settings_get_printer_lpi(arg0)

	var gdouble float64

	gdouble = (float64)(cret)

	return gdouble
}

// Quality gets the value of GTK_PRINT_SETTINGS_QUALITY.
func (s printSettings) Quality() PrintQuality {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	var cret C.GtkPrintQuality

	cret = C.gtk_print_settings_get_quality(arg0)

	var printQuality PrintQuality

	printQuality = PrintQuality(cret)

	return printQuality
}

// Resolution gets the value of GTK_PRINT_SETTINGS_RESOLUTION.
func (s printSettings) Resolution() int {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	var cret C.int

	cret = C.gtk_print_settings_get_resolution(arg0)

	var gint int

	gint = (int)(cret)

	return gint
}

// ResolutionX gets the value of GTK_PRINT_SETTINGS_RESOLUTION_X.
func (s printSettings) ResolutionX() int {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	var cret C.int

	cret = C.gtk_print_settings_get_resolution_x(arg0)

	var gint int

	gint = (int)(cret)

	return gint
}

// ResolutionY gets the value of GTK_PRINT_SETTINGS_RESOLUTION_Y.
func (s printSettings) ResolutionY() int {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	var cret C.int

	cret = C.gtk_print_settings_get_resolution_y(arg0)

	var gint int

	gint = (int)(cret)

	return gint
}

// Reverse gets the value of GTK_PRINT_SETTINGS_REVERSE.
func (s printSettings) Reverse() bool {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	var cret C.gboolean

	cret = C.gtk_print_settings_get_reverse(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// Scale gets the value of GTK_PRINT_SETTINGS_SCALE.
func (s printSettings) Scale() float64 {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	var cret C.double

	cret = C.gtk_print_settings_get_scale(arg0)

	var gdouble float64

	gdouble = (float64)(cret)

	return gdouble
}

// UseColor gets the value of GTK_PRINT_SETTINGS_USE_COLOR.
func (s printSettings) UseColor() bool {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	var cret C.gboolean

	cret = C.gtk_print_settings_get_use_color(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// HasKey returns true, if a value is associated with @key.
func (s printSettings) HasKey(key string) bool {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.char

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	arg1 = (*C.char)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))

	var cret C.gboolean

	cret = C.gtk_print_settings_has_key(arg0, arg1)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// LoadFile reads the print settings from @file_name. If the file could not
// be loaded then error is set to either a Error or FileError. See
// gtk_print_settings_to_file().
func (s printSettings) LoadFile(fileName *string) error {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.char

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	arg1 = (*C.char)(C.CString(fileName))
	defer C.free(unsafe.Pointer(arg1))

	var cerr *C.GError

	C.gtk_print_settings_load_file(arg0, arg1, cerr)

	var goerr error

	goerr = gerror.Take(unsafe.Pointer(cerr))

	return goerr
}

// LoadKeyFile reads the print settings from the group @group_name in
// @key_file. If the file could not be loaded then error is set to either a
// Error or FileError.
func (s printSettings) LoadKeyFile(keyFile *glib.KeyFile, groupName string) error {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.GKeyFile
	var arg2 *C.char

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GKeyFile)(unsafe.Pointer(keyFile.Native()))
	arg2 = (*C.char)(C.CString(groupName))
	defer C.free(unsafe.Pointer(arg2))

	var cerr *C.GError

	C.gtk_print_settings_load_key_file(arg0, arg1, arg2, cerr)

	var goerr error

	goerr = gerror.Take(unsafe.Pointer(cerr))

	return goerr
}

// Set associates @value with @key.
func (s printSettings) Set(key string, value string) {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.char
	var arg2 *C.char

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	arg1 = (*C.char)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.char)(C.CString(value))
	defer C.free(unsafe.Pointer(arg2))

	C.gtk_print_settings_set(arg0, arg1, arg2)
}

// SetBool sets @key to a boolean value.
func (s printSettings) SetBool(key string, value bool) {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.char
	var arg2 C.gboolean

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	arg1 = (*C.char)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))
	if value {
		arg2 = C.gboolean(1)
	}

	C.gtk_print_settings_set_bool(arg0, arg1, arg2)
}

// SetCollate sets the value of GTK_PRINT_SETTINGS_COLLATE.
func (s printSettings) SetCollate(collate bool) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.gboolean

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	if collate {
		arg1 = C.gboolean(1)
	}

	C.gtk_print_settings_set_collate(arg0, arg1)
}

// SetDefaultSource sets the value of GTK_PRINT_SETTINGS_DEFAULT_SOURCE.
func (s printSettings) SetDefaultSource(defaultSource string) {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.char

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	arg1 = (*C.char)(C.CString(defaultSource))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_print_settings_set_default_source(arg0, arg1)
}

// SetDither sets the value of GTK_PRINT_SETTINGS_DITHER.
func (s printSettings) SetDither(dither string) {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.char

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	arg1 = (*C.char)(C.CString(dither))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_print_settings_set_dither(arg0, arg1)
}

// SetDouble sets @key to a double value.
func (s printSettings) SetDouble(key string, value float64) {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.char
	var arg2 C.double

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	arg1 = (*C.char)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.double(value)

	C.gtk_print_settings_set_double(arg0, arg1, arg2)
}

// SetDuplex sets the value of GTK_PRINT_SETTINGS_DUPLEX.
func (s printSettings) SetDuplex(duplex PrintDuplex) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.GtkPrintDuplex

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	arg1 = (C.GtkPrintDuplex)(duplex)

	C.gtk_print_settings_set_duplex(arg0, arg1)
}

// SetFinishings sets the value of GTK_PRINT_SETTINGS_FINISHINGS.
func (s printSettings) SetFinishings(finishings string) {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.char

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	arg1 = (*C.char)(C.CString(finishings))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_print_settings_set_finishings(arg0, arg1)
}

// SetInt sets @key to an integer value.
func (s printSettings) SetInt(key string, value int) {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.char
	var arg2 C.int

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	arg1 = (*C.char)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.int(value)

	C.gtk_print_settings_set_int(arg0, arg1, arg2)
}

// SetLength associates a length in units of @unit with @key.
func (s printSettings) SetLength(key string, value float64, unit Unit) {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.char
	var arg2 C.double
	var arg3 C.GtkUnit

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	arg1 = (*C.char)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.double(value)
	arg3 = (C.GtkUnit)(unit)

	C.gtk_print_settings_set_length(arg0, arg1, arg2, arg3)
}

// SetMediaType sets the value of GTK_PRINT_SETTINGS_MEDIA_TYPE.
//
// The set of media types is defined in PWG 5101.1-2002 PWG.
func (s printSettings) SetMediaType(mediaType string) {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.char

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	arg1 = (*C.char)(C.CString(mediaType))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_print_settings_set_media_type(arg0, arg1)
}

// SetNCopies sets the value of GTK_PRINT_SETTINGS_N_COPIES.
func (s printSettings) SetNCopies(numCopies int) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.int

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	arg1 = C.int(numCopies)

	C.gtk_print_settings_set_n_copies(arg0, arg1)
}

// SetNumberUp sets the value of GTK_PRINT_SETTINGS_NUMBER_UP.
func (s printSettings) SetNumberUp(numberUp int) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.int

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	arg1 = C.int(numberUp)

	C.gtk_print_settings_set_number_up(arg0, arg1)
}

// SetNumberUpLayout sets the value of GTK_PRINT_SETTINGS_NUMBER_UP_LAYOUT.
func (s printSettings) SetNumberUpLayout(numberUpLayout NumberUpLayout) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.GtkNumberUpLayout

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	arg1 = (C.GtkNumberUpLayout)(numberUpLayout)

	C.gtk_print_settings_set_number_up_layout(arg0, arg1)
}

// SetOrientation sets the value of GTK_PRINT_SETTINGS_ORIENTATION.
func (s printSettings) SetOrientation(orientation PageOrientation) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.GtkPageOrientation

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	arg1 = (C.GtkPageOrientation)(orientation)

	C.gtk_print_settings_set_orientation(arg0, arg1)
}

// SetOutputBin sets the value of GTK_PRINT_SETTINGS_OUTPUT_BIN.
func (s printSettings) SetOutputBin(outputBin string) {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.char

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	arg1 = (*C.char)(C.CString(outputBin))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_print_settings_set_output_bin(arg0, arg1)
}

// SetPageRanges sets the value of GTK_PRINT_SETTINGS_PAGE_RANGES.
func (s printSettings) SetPageRanges() {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	C.gtk_print_settings_set_page_ranges(arg0)
}

// SetPageSet sets the value of GTK_PRINT_SETTINGS_PAGE_SET.
func (s printSettings) SetPageSet(pageSet PageSet) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.GtkPageSet

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	arg1 = (C.GtkPageSet)(pageSet)

	C.gtk_print_settings_set_page_set(arg0, arg1)
}

// SetPaperHeight sets the value of GTK_PRINT_SETTINGS_PAPER_HEIGHT.
func (s printSettings) SetPaperHeight(height float64, unit Unit) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.double
	var arg2 C.GtkUnit

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	arg1 = C.double(height)
	arg2 = (C.GtkUnit)(unit)

	C.gtk_print_settings_set_paper_height(arg0, arg1, arg2)
}

// SetPaperSize sets the value of GTK_PRINT_SETTINGS_PAPER_FORMAT,
// GTK_PRINT_SETTINGS_PAPER_WIDTH and GTK_PRINT_SETTINGS_PAPER_HEIGHT.
func (s printSettings) SetPaperSize(paperSize *PaperSize) {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.GtkPaperSize

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GtkPaperSize)(unsafe.Pointer(paperSize.Native()))

	C.gtk_print_settings_set_paper_size(arg0, arg1)
}

// SetPaperWidth sets the value of GTK_PRINT_SETTINGS_PAPER_WIDTH.
func (s printSettings) SetPaperWidth(width float64, unit Unit) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.double
	var arg2 C.GtkUnit

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	arg1 = C.double(width)
	arg2 = (C.GtkUnit)(unit)

	C.gtk_print_settings_set_paper_width(arg0, arg1, arg2)
}

// SetPrintPages sets the value of GTK_PRINT_SETTINGS_PRINT_PAGES.
func (s printSettings) SetPrintPages(pages PrintPages) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.GtkPrintPages

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	arg1 = (C.GtkPrintPages)(pages)

	C.gtk_print_settings_set_print_pages(arg0, arg1)
}

// SetPrinter: convenience function to set GTK_PRINT_SETTINGS_PRINTER to
// @printer.
func (s printSettings) SetPrinter(printer string) {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.char

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	arg1 = (*C.char)(C.CString(printer))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_print_settings_set_printer(arg0, arg1)
}

// SetPrinterLpi sets the value of GTK_PRINT_SETTINGS_PRINTER_LPI.
func (s printSettings) SetPrinterLpi(lpi float64) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.double

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	arg1 = C.double(lpi)

	C.gtk_print_settings_set_printer_lpi(arg0, arg1)
}

// SetQuality sets the value of GTK_PRINT_SETTINGS_QUALITY.
func (s printSettings) SetQuality(quality PrintQuality) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.GtkPrintQuality

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	arg1 = (C.GtkPrintQuality)(quality)

	C.gtk_print_settings_set_quality(arg0, arg1)
}

// SetResolution sets the values of GTK_PRINT_SETTINGS_RESOLUTION,
// GTK_PRINT_SETTINGS_RESOLUTION_X and GTK_PRINT_SETTINGS_RESOLUTION_Y.
func (s printSettings) SetResolution(resolution int) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.int

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	arg1 = C.int(resolution)

	C.gtk_print_settings_set_resolution(arg0, arg1)
}

// SetResolutionXY sets the values of GTK_PRINT_SETTINGS_RESOLUTION,
// GTK_PRINT_SETTINGS_RESOLUTION_X and GTK_PRINT_SETTINGS_RESOLUTION_Y.
func (s printSettings) SetResolutionXY(resolutionX int, resolutionY int) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.int
	var arg2 C.int

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	arg1 = C.int(resolutionX)
	arg2 = C.int(resolutionY)

	C.gtk_print_settings_set_resolution_xy(arg0, arg1, arg2)
}

// SetReverse sets the value of GTK_PRINT_SETTINGS_REVERSE.
func (s printSettings) SetReverse(reverse bool) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.gboolean

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	if reverse {
		arg1 = C.gboolean(1)
	}

	C.gtk_print_settings_set_reverse(arg0, arg1)
}

// SetScale sets the value of GTK_PRINT_SETTINGS_SCALE.
func (s printSettings) SetScale(scale float64) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.double

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	arg1 = C.double(scale)

	C.gtk_print_settings_set_scale(arg0, arg1)
}

// SetUseColor sets the value of GTK_PRINT_SETTINGS_USE_COLOR.
func (s printSettings) SetUseColor(useColor bool) {
	var arg0 *C.GtkPrintSettings
	var arg1 C.gboolean

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	if useColor {
		arg1 = C.gboolean(1)
	}

	C.gtk_print_settings_set_use_color(arg0, arg1)
}

// ToFile: this function saves the print settings from @settings to
// @file_name. If the file could not be loaded then error is set to either a
// Error or FileError.
func (s printSettings) ToFile(fileName *string) error {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.char

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	arg1 = (*C.char)(C.CString(fileName))
	defer C.free(unsafe.Pointer(arg1))

	var cerr *C.GError

	C.gtk_print_settings_to_file(arg0, arg1, cerr)

	var goerr error

	goerr = gerror.Take(unsafe.Pointer(cerr))

	return goerr
}

// ToGVariant: serialize print settings to an a{sv} variant.
func (s printSettings) ToGVariant() *glib.Variant {
	var arg0 *C.GtkPrintSettings

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

	var cret *C.GVariant

	cret = C.gtk_print_settings_to_gvariant(arg0)

	var variant *glib.Variant

	variant = glib.WrapVariant(unsafe.Pointer(cret))

	return variant
}

// ToKeyFile: this function adds the print settings from @settings to
// @key_file.
func (s printSettings) ToKeyFile(keyFile *glib.KeyFile, groupName string) {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.GKeyFile
	var arg2 *C.char

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GKeyFile)(unsafe.Pointer(keyFile.Native()))
	arg2 = (*C.char)(C.CString(groupName))
	defer C.free(unsafe.Pointer(arg2))

	C.gtk_print_settings_to_key_file(arg0, arg1, arg2)
}

// Unset removes any value associated with @key. This has the same effect as
// setting the value to nil.
func (s printSettings) Unset(key string) {
	var arg0 *C.GtkPrintSettings
	var arg1 *C.char

	arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
	arg1 = (*C.char)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_print_settings_unset(arg0, arg1)
}

// ProgressBar: the ProgressBar is typically used to display the progress of a
// long running operation. It provides a visual clue that processing is
// underway. The GtkProgressBar can be used in two different modes: percentage
// mode and activity mode.
//
// When an application can determine how much work needs to take place (e.g.
// read a fixed number of bytes from a file) and can monitor its progress, it
// can use the GtkProgressBar in percentage mode and the user sees a growing bar
// indicating the percentage of the work that has been completed. In this mode,
// the application is required to call gtk_progress_bar_set_fraction()
// periodically to update the progress bar.
//
// When an application has no accurate way of knowing the amount of work to do,
// it can use the ProgressBar in activity mode, which shows activity by a block
// moving back and forth within the progress area. In this mode, the application
// is required to call gtk_progress_bar_pulse() periodically to update the
// progress bar.
//
// There is quite a bit of flexibility provided to control the appearance of the
// ProgressBar. Functions are provided to control the orientation of the bar,
// optional text can be displayed along with the bar, and the step size used in
// activity mode can be set.
//
// CSS nodes
//
//    progressbar[.osd]
//    ├── [text]
//    ╰── trough[.empty][.full]
//        ╰── progress[.pulse]
//
// GtkProgressBar has a main CSS node with name progressbar and subnodes with
// names text and trough, of which the latter has a subnode named progress. The
// text subnode is only present if text is shown. The progress subnode has the
// style class .pulse when in activity mode. It gets the style classes .left,
// .right, .top or .bottom added when the progress 'touches' the corresponding
// end of the GtkProgressBar. The .osd class on the progressbar node is for use
// in overlays like the one Epiphany has for page loading progress.
//
//
// Accessibility
//
// GtkProgressBar uses the K_ACCESSIBLE_ROLE_PROGRESS_BAR role.
type ProgressBar interface {
	Widget
	Accessible
	Buildable
	ConstraintTarget
	Orientable

	// Ellipsize returns the ellipsizing position of the progress bar. See
	// gtk_progress_bar_set_ellipsize().
	Ellipsize() pango.EllipsizeMode
	// Fraction returns the current fraction of the task that’s been completed.
	Fraction() float64
	// Inverted gets the value set by gtk_progress_bar_set_inverted().
	Inverted() bool
	// PulseStep retrieves the pulse step set with
	// gtk_progress_bar_set_pulse_step().
	PulseStep() float64
	// ShowText gets the value of the ProgressBar:show-text property. See
	// gtk_progress_bar_set_show_text().
	ShowText() bool
	// Text retrieves the text that is displayed with the progress bar, if any,
	// otherwise nil. The return value is a reference to the text, not a copy of
	// it, so will become invalid if you change the text in the progress bar.
	Text() string
	// Pulse indicates that some progress has been made, but you don’t know how
	// much. Causes the progress bar to enter “activity mode,” where a block
	// bounces back and forth. Each call to gtk_progress_bar_pulse() causes the
	// block to move by a little bit (the amount of movement per pulse is
	// determined by gtk_progress_bar_set_pulse_step()).
	Pulse()
	// SetEllipsize sets the mode used to ellipsize (add an ellipsis: "...") the
	// text if there is not enough space to render the entire string.
	SetEllipsize(mode pango.EllipsizeMode)
	// SetFraction causes the progress bar to “fill in” the given fraction of
	// the bar. The fraction should be between 0.0 and 1.0, inclusive.
	SetFraction(fraction float64)
	// SetInverted progress bars normally grow from top to bottom or left to
	// right. Inverted progress bars grow in the opposite direction.
	SetInverted(inverted bool)
	// SetPulseStep sets the fraction of total progress bar length to move the
	// bouncing block for each call to gtk_progress_bar_pulse().
	SetPulseStep(fraction float64)
	// SetShowText sets whether the progress bar will show text next to the bar.
	// The shown text is either the value of the ProgressBar:text property or,
	// if that is nil, the ProgressBar:fraction value, as a percentage.
	//
	// To make a progress bar that is styled and sized suitably for containing
	// text (even if the actual text is blank), set ProgressBar:show-text to
	// true and ProgressBar:text to the empty string (not nil).
	SetShowText(showText bool)
	// SetText causes the given @text to appear next to the progress bar.
	//
	// If @text is nil and ProgressBar:show-text is true, the current value of
	// ProgressBar:fraction will be displayed as a percentage.
	//
	// If @text is non-nil and ProgressBar:show-text is true, the text will be
	// displayed. In this case, it will not display the progress percentage. If
	// @text is the empty string, the progress bar will still be styled and
	// sized suitably for containing text, as long as ProgressBar:show-text is
	// true.
	SetText(text string)
}

// progressBar implements the ProgressBar interface.
type progressBar struct {
	Widget
	Accessible
	Buildable
	ConstraintTarget
	Orientable
}

var _ ProgressBar = (*progressBar)(nil)

// WrapProgressBar wraps a GObject to the right type. It is
// primarily used internally.
func WrapProgressBar(obj *externglib.Object) ProgressBar {
	return ProgressBar{
		Widget:           WrapWidget(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
		Orientable:       WrapOrientable(obj),
	}
}

func marshalProgressBar(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapProgressBar(obj), nil
}

// NewProgressBar constructs a class ProgressBar.
func NewProgressBar() ProgressBar {
	var cret C.GtkProgressBar

	cret = C.gtk_progress_bar_new()

	var progressBar ProgressBar

	progressBar = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(ProgressBar)

	return progressBar
}

// Ellipsize returns the ellipsizing position of the progress bar. See
// gtk_progress_bar_set_ellipsize().
func (p progressBar) Ellipsize() pango.EllipsizeMode {
	var arg0 *C.GtkProgressBar

	arg0 = (*C.GtkProgressBar)(unsafe.Pointer(p.Native()))

	var cret C.PangoEllipsizeMode

	cret = C.gtk_progress_bar_get_ellipsize(arg0)

	var ellipsizeMode pango.EllipsizeMode

	ellipsizeMode = pango.EllipsizeMode(cret)

	return ellipsizeMode
}

// Fraction returns the current fraction of the task that’s been completed.
func (p progressBar) Fraction() float64 {
	var arg0 *C.GtkProgressBar

	arg0 = (*C.GtkProgressBar)(unsafe.Pointer(p.Native()))

	var cret C.double

	cret = C.gtk_progress_bar_get_fraction(arg0)

	var gdouble float64

	gdouble = (float64)(cret)

	return gdouble
}

// Inverted gets the value set by gtk_progress_bar_set_inverted().
func (p progressBar) Inverted() bool {
	var arg0 *C.GtkProgressBar

	arg0 = (*C.GtkProgressBar)(unsafe.Pointer(p.Native()))

	var cret C.gboolean

	cret = C.gtk_progress_bar_get_inverted(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// PulseStep retrieves the pulse step set with
// gtk_progress_bar_set_pulse_step().
func (p progressBar) PulseStep() float64 {
	var arg0 *C.GtkProgressBar

	arg0 = (*C.GtkProgressBar)(unsafe.Pointer(p.Native()))

	var cret C.double

	cret = C.gtk_progress_bar_get_pulse_step(arg0)

	var gdouble float64

	gdouble = (float64)(cret)

	return gdouble
}

// ShowText gets the value of the ProgressBar:show-text property. See
// gtk_progress_bar_set_show_text().
func (p progressBar) ShowText() bool {
	var arg0 *C.GtkProgressBar

	arg0 = (*C.GtkProgressBar)(unsafe.Pointer(p.Native()))

	var cret C.gboolean

	cret = C.gtk_progress_bar_get_show_text(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// Text retrieves the text that is displayed with the progress bar, if any,
// otherwise nil. The return value is a reference to the text, not a copy of
// it, so will become invalid if you change the text in the progress bar.
func (p progressBar) Text() string {
	var arg0 *C.GtkProgressBar

	arg0 = (*C.GtkProgressBar)(unsafe.Pointer(p.Native()))

	var cret *C.char

	cret = C.gtk_progress_bar_get_text(arg0)

	var utf8 string

	utf8 = C.GoString(cret)

	return utf8
}

// Pulse indicates that some progress has been made, but you don’t know how
// much. Causes the progress bar to enter “activity mode,” where a block
// bounces back and forth. Each call to gtk_progress_bar_pulse() causes the
// block to move by a little bit (the amount of movement per pulse is
// determined by gtk_progress_bar_set_pulse_step()).
func (p progressBar) Pulse() {
	var arg0 *C.GtkProgressBar

	arg0 = (*C.GtkProgressBar)(unsafe.Pointer(p.Native()))

	C.gtk_progress_bar_pulse(arg0)
}

// SetEllipsize sets the mode used to ellipsize (add an ellipsis: "...") the
// text if there is not enough space to render the entire string.
func (p progressBar) SetEllipsize(mode pango.EllipsizeMode) {
	var arg0 *C.GtkProgressBar
	var arg1 C.PangoEllipsizeMode

	arg0 = (*C.GtkProgressBar)(unsafe.Pointer(p.Native()))
	arg1 = (C.PangoEllipsizeMode)(mode)

	C.gtk_progress_bar_set_ellipsize(arg0, arg1)
}

// SetFraction causes the progress bar to “fill in” the given fraction of
// the bar. The fraction should be between 0.0 and 1.0, inclusive.
func (p progressBar) SetFraction(fraction float64) {
	var arg0 *C.GtkProgressBar
	var arg1 C.double

	arg0 = (*C.GtkProgressBar)(unsafe.Pointer(p.Native()))
	arg1 = C.double(fraction)

	C.gtk_progress_bar_set_fraction(arg0, arg1)
}

// SetInverted progress bars normally grow from top to bottom or left to
// right. Inverted progress bars grow in the opposite direction.
func (p progressBar) SetInverted(inverted bool) {
	var arg0 *C.GtkProgressBar
	var arg1 C.gboolean

	arg0 = (*C.GtkProgressBar)(unsafe.Pointer(p.Native()))
	if inverted {
		arg1 = C.gboolean(1)
	}

	C.gtk_progress_bar_set_inverted(arg0, arg1)
}

// SetPulseStep sets the fraction of total progress bar length to move the
// bouncing block for each call to gtk_progress_bar_pulse().
func (p progressBar) SetPulseStep(fraction float64) {
	var arg0 *C.GtkProgressBar
	var arg1 C.double

	arg0 = (*C.GtkProgressBar)(unsafe.Pointer(p.Native()))
	arg1 = C.double(fraction)

	C.gtk_progress_bar_set_pulse_step(arg0, arg1)
}

// SetShowText sets whether the progress bar will show text next to the bar.
// The shown text is either the value of the ProgressBar:text property or,
// if that is nil, the ProgressBar:fraction value, as a percentage.
//
// To make a progress bar that is styled and sized suitably for containing
// text (even if the actual text is blank), set ProgressBar:show-text to
// true and ProgressBar:text to the empty string (not nil).
func (p progressBar) SetShowText(showText bool) {
	var arg0 *C.GtkProgressBar
	var arg1 C.gboolean

	arg0 = (*C.GtkProgressBar)(unsafe.Pointer(p.Native()))
	if showText {
		arg1 = C.gboolean(1)
	}

	C.gtk_progress_bar_set_show_text(arg0, arg1)
}

// SetText causes the given @text to appear next to the progress bar.
//
// If @text is nil and ProgressBar:show-text is true, the current value of
// ProgressBar:fraction will be displayed as a percentage.
//
// If @text is non-nil and ProgressBar:show-text is true, the text will be
// displayed. In this case, it will not display the progress percentage. If
// @text is the empty string, the progress bar will still be styled and
// sized suitably for containing text, as long as ProgressBar:show-text is
// true.
func (p progressBar) SetText(text string) {
	var arg0 *C.GtkProgressBar
	var arg1 *C.char

	arg0 = (*C.GtkProgressBar)(unsafe.Pointer(p.Native()))
	arg1 = (*C.char)(C.CString(text))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_progress_bar_set_text(arg0, arg1)
}

// Revealer: the GtkRevealer widget is a container which animates the transition
// of its child from invisible to visible.
//
// The style of transition can be controlled with
// gtk_revealer_set_transition_type().
//
// These animations respect the Settings:gtk-enable-animations setting.
//
//
// CSS nodes
//
// GtkRevealer has a single CSS node with name revealer. When styling Revealer
// using CSS, remember that it only hides its contents, not itself. That means
// applied margin, padding and borders will be visible even when the
// Revealer:reveal-child property is set to false.
//
//
// Accessibility
//
// GtkRevealer uses the GTK_ACCESSIBLE_ROLE_GROUP role.
//
// The child of GtkRevealer, if set, is always available in the accessibility
// tree, regardless of the state of the revealer widget.
type Revealer interface {
	Widget
	Accessible
	Buildable
	ConstraintTarget

	// Child gets the child widget of @revealer.
	Child() Widget
	// ChildRevealed returns whether the child is fully revealed, in other words
	// whether the transition to the revealed state is completed.
	ChildRevealed() bool
	// RevealChild returns whether the child is currently revealed. See
	// gtk_revealer_set_reveal_child().
	//
	// This function returns true as soon as the transition is to the revealed
	// state is started. To learn whether the child is fully revealed (ie the
	// transition is completed), use gtk_revealer_get_child_revealed().
	RevealChild() bool
	// TransitionDuration returns the amount of time (in milliseconds) that
	// transitions will take.
	TransitionDuration() uint
	// TransitionType gets the type of animation that will be used for
	// transitions in @revealer.
	TransitionType() RevealerTransitionType
	// SetChild sets the child widget of @revealer.
	SetChild(child Widget)
	// SetRevealChild tells the Revealer to reveal or conceal its child.
	//
	// The transition will be animated with the current transition type of
	// @revealer.
	SetRevealChild(revealChild bool)
	// SetTransitionDuration sets the duration that transitions will take.
	SetTransitionDuration(duration uint)
	// SetTransitionType sets the type of animation that will be used for
	// transitions in @revealer. Available types include various kinds of fades
	// and slides.
	SetTransitionType(transition RevealerTransitionType)
}

// revealer implements the Revealer interface.
type revealer struct {
	Widget
	Accessible
	Buildable
	ConstraintTarget
}

var _ Revealer = (*revealer)(nil)

// WrapRevealer wraps a GObject to the right type. It is
// primarily used internally.
func WrapRevealer(obj *externglib.Object) Revealer {
	return Revealer{
		Widget:           WrapWidget(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
	}
}

func marshalRevealer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapRevealer(obj), nil
}

// NewRevealer constructs a class Revealer.
func NewRevealer() Revealer {
	var cret C.GtkRevealer

	cret = C.gtk_revealer_new()

	var revealer Revealer

	revealer = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Revealer)

	return revealer
}

// Child gets the child widget of @revealer.
func (r revealer) Child() Widget {
	var arg0 *C.GtkRevealer

	arg0 = (*C.GtkRevealer)(unsafe.Pointer(r.Native()))

	var cret *C.GtkWidget

	cret = C.gtk_revealer_get_child(arg0)

	var widget Widget

	widget = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Widget)

	return widget
}

// ChildRevealed returns whether the child is fully revealed, in other words
// whether the transition to the revealed state is completed.
func (r revealer) ChildRevealed() bool {
	var arg0 *C.GtkRevealer

	arg0 = (*C.GtkRevealer)(unsafe.Pointer(r.Native()))

	var cret C.gboolean

	cret = C.gtk_revealer_get_child_revealed(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// RevealChild returns whether the child is currently revealed. See
// gtk_revealer_set_reveal_child().
//
// This function returns true as soon as the transition is to the revealed
// state is started. To learn whether the child is fully revealed (ie the
// transition is completed), use gtk_revealer_get_child_revealed().
func (r revealer) RevealChild() bool {
	var arg0 *C.GtkRevealer

	arg0 = (*C.GtkRevealer)(unsafe.Pointer(r.Native()))

	var cret C.gboolean

	cret = C.gtk_revealer_get_reveal_child(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// TransitionDuration returns the amount of time (in milliseconds) that
// transitions will take.
func (r revealer) TransitionDuration() uint {
	var arg0 *C.GtkRevealer

	arg0 = (*C.GtkRevealer)(unsafe.Pointer(r.Native()))

	var cret C.guint

	cret = C.gtk_revealer_get_transition_duration(arg0)

	var guint uint

	guint = (uint)(cret)

	return guint
}

// TransitionType gets the type of animation that will be used for
// transitions in @revealer.
func (r revealer) TransitionType() RevealerTransitionType {
	var arg0 *C.GtkRevealer

	arg0 = (*C.GtkRevealer)(unsafe.Pointer(r.Native()))

	var cret C.GtkRevealerTransitionType

	cret = C.gtk_revealer_get_transition_type(arg0)

	var revealerTransitionType RevealerTransitionType

	revealerTransitionType = RevealerTransitionType(cret)

	return revealerTransitionType
}

// SetChild sets the child widget of @revealer.
func (r revealer) SetChild(child Widget) {
	var arg0 *C.GtkRevealer
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkRevealer)(unsafe.Pointer(r.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_revealer_set_child(arg0, arg1)
}

// SetRevealChild tells the Revealer to reveal or conceal its child.
//
// The transition will be animated with the current transition type of
// @revealer.
func (r revealer) SetRevealChild(revealChild bool) {
	var arg0 *C.GtkRevealer
	var arg1 C.gboolean

	arg0 = (*C.GtkRevealer)(unsafe.Pointer(r.Native()))
	if revealChild {
		arg1 = C.gboolean(1)
	}

	C.gtk_revealer_set_reveal_child(arg0, arg1)
}

// SetTransitionDuration sets the duration that transitions will take.
func (r revealer) SetTransitionDuration(duration uint) {
	var arg0 *C.GtkRevealer
	var arg1 C.guint

	arg0 = (*C.GtkRevealer)(unsafe.Pointer(r.Native()))
	arg1 = C.guint(duration)

	C.gtk_revealer_set_transition_duration(arg0, arg1)
}

// SetTransitionType sets the type of animation that will be used for
// transitions in @revealer. Available types include various kinds of fades
// and slides.
func (r revealer) SetTransitionType(transition RevealerTransitionType) {
	var arg0 *C.GtkRevealer
	var arg1 C.GtkRevealerTransitionType

	arg0 = (*C.GtkRevealer)(unsafe.Pointer(r.Native()))
	arg1 = (C.GtkRevealerTransitionType)(transition)

	C.gtk_revealer_set_transition_type(arg0, arg1)
}

// Scrollbar: the Scrollbar widget is a horizontal or vertical scrollbar,
// depending on the value of the Orientable:orientation property.
//
// Its position and movement are controlled by the adjustment that is passed to
// or created by gtk_scrollbar_new(). See Adjustment for more details. The
// Adjustment:value field sets the position of the thumb and must be between
// Adjustment:lower and Adjustment:upper - Adjustment:page-size. The
// Adjustment:page-size represents the size of the visible scrollable area. The
// fields Adjustment:step-increment and Adjustment:page-increment fields are
// added to or subtracted from the Adjustment:value when the user asks to move
// by a step (using e.g. the cursor arrow keys) or by a page (using e.g. the
// Page Down/Up keys).
//
// CSS nodes
//
//    scrollbar
//    ╰── range[.fine-tune]
//        ╰── trough
//            ╰── slider
//
// GtkScrollbar has a main CSS node with name scrollbar and a subnode for its
// contents. The main node gets the .horizontal or .vertical style classes
// applied, depending on the scrollbar's orientation.
//
// The range node gets the style class .fine-tune added when the scrollbar is in
// 'fine-tuning' mode.
//
// Other style classes that may be added to scrollbars inside ScrolledWindow
// include the positional classes (.left, .right, .top, .bottom) and style
// classes related to overlay scrolling (.overlay-indicator, .dragging,
// .hovering).
//
//
// Accessibility
//
// GtkScrollbar uses the K_ACCESSIBLE_ROLE_SCROLLBAR role.
type Scrollbar interface {
	Widget
	Accessible
	Buildable
	ConstraintTarget
	Orientable

	// Adjustment returns the scrollbar's adjustment.
	Adjustment() Adjustment
	// SetAdjustment makes the scrollbar use the given adjustment.
	SetAdjustment(adjustment Adjustment)
}

// scrollbar implements the Scrollbar interface.
type scrollbar struct {
	Widget
	Accessible
	Buildable
	ConstraintTarget
	Orientable
}

var _ Scrollbar = (*scrollbar)(nil)

// WrapScrollbar wraps a GObject to the right type. It is
// primarily used internally.
func WrapScrollbar(obj *externglib.Object) Scrollbar {
	return Scrollbar{
		Widget:           WrapWidget(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
		Orientable:       WrapOrientable(obj),
	}
}

func marshalScrollbar(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapScrollbar(obj), nil
}

// NewScrollbar constructs a class Scrollbar.
func NewScrollbar(orientation Orientation, adjustment Adjustment) Scrollbar {
	var arg1 C.GtkOrientation
	var arg2 *C.GtkAdjustment

	arg1 = (C.GtkOrientation)(orientation)
	arg2 = (*C.GtkAdjustment)(unsafe.Pointer(adjustment.Native()))

	var cret C.GtkScrollbar

	cret = C.gtk_scrollbar_new(arg1, arg2)

	var scrollbar Scrollbar

	scrollbar = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Scrollbar)

	return scrollbar
}

// Adjustment returns the scrollbar's adjustment.
func (s scrollbar) Adjustment() Adjustment {
	var arg0 *C.GtkScrollbar

	arg0 = (*C.GtkScrollbar)(unsafe.Pointer(s.Native()))

	var cret *C.GtkAdjustment

	cret = C.gtk_scrollbar_get_adjustment(arg0)

	var adjustment Adjustment

	adjustment = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Adjustment)

	return adjustment
}

// SetAdjustment makes the scrollbar use the given adjustment.
func (s scrollbar) SetAdjustment(adjustment Adjustment) {
	var arg0 *C.GtkScrollbar
	var arg1 *C.GtkAdjustment

	arg0 = (*C.GtkScrollbar)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GtkAdjustment)(unsafe.Pointer(adjustment.Native()))

	C.gtk_scrollbar_set_adjustment(arg0, arg1)
}

// ScrolledWindow: gtkScrolledWindow is a container that accepts a single child
// widget, makes that child scrollable using either internally added scrollbars
// or externally associated adjustments, and optionally draws a frame around the
// child.
//
// Widgets with native scrolling support, i.e. those whose classes implement the
// Scrollable interface, are added directly. For other types of widget, the
// class Viewport acts as an adaptor, giving scrollability to other widgets.
// gtk_scrolled_window_set_child() intelligently accounts for whether or not the
// added child is a Scrollable. If it isn’t, ScrolledWindow wraps the child in a
// Viewport and adds that for you. Therefore, you can just add any child widget
// and not worry about the details.
//
// If gtk_scrolled_window_set_child() has added a Viewport for you, you can
// remove both your added child widget from the Viewport, and the Viewport from
// the GtkScrolledWindow, like this:
//
//    GtkWidget *scrolled_window = gtk_scrolled_window_new ();
//    GtkWidget *child_widget = gtk_button_new ();
//
//    // GtkButton is not a GtkScrollable, so GtkScrolledWindow will automatically
//    // add a GtkViewport.
//    gtk_box_append (GTK_BOX (scrolled_window),
//                       child_widget);
//
//    // Either of these will result in child_widget being unparented:
//    gtk_box_remove (GTK_BOX (scrolled_window),
//                          child_widget);
//    // or
//    gtk_box_remove (GTK_BOX (scrolled_window),
//                          gtk_bin_get_child (GTK_BIN (scrolled_window)));
//
// Unless ScrolledWindow:hscrollbar-policy and ScrolledWindow:vscrollbar-policy
// are GTK_POLICY_NEVER or GTK_POLICY_EXTERNAL, GtkScrolledWindow adds internal
// Scrollbar widgets around its child. The scroll position of the child, and if
// applicable the scrollbars, is controlled by the ScrolledWindow:hadjustment
// and ScrolledWindow:vadjustment that are associated with the
// GtkScrolledWindow. See the docs on Scrollbar for the details, but note that
// the “step_increment” and “page_increment” fields are only effective if the
// policy causes scrollbars to be present.
//
// If a GtkScrolledWindow doesn’t behave quite as you would like, or doesn’t
// have exactly the right layout, it’s very possible to set up your own
// scrolling with Scrollbar and for example a Grid.
//
//
// Touch support
//
// GtkScrolledWindow has built-in support for touch devices. When a touchscreen
// is used, swiping will move the scrolled window, and will expose 'kinetic'
// behavior. This can be turned off with the ScrolledWindow:kinetic-scrolling
// property if it is undesired.
//
// GtkScrolledWindow also displays visual 'overshoot' indication when the
// content is pulled beyond the end, and this situation can be captured with the
// ScrolledWindow::edge-overshot signal.
//
// If no mouse device is present, the scrollbars will overlaid as narrow,
// auto-hiding indicators over the content. If traditional scrollbars are
// desired although no mouse is present, this behaviour can be turned off with
// the ScrolledWindow:overlay-scrolling property.
//
//
// CSS nodes
//
// GtkScrolledWindow has a main CSS node with name scrolledwindow. It gets a
// .frame style class added when ScrolledWindow:has-frame is true.
//
// It uses subnodes with names overshoot and undershoot to draw the overflow and
// underflow indications. These nodes get the .left, .right, .top or .bottom
// style class added depending on where the indication is drawn.
//
// GtkScrolledWindow also sets the positional style classes (.left, .right,
// .top, .bottom) and style classes related to overlay scrolling
// (.overlay-indicator, .dragging, .hovering) on its scrollbars.
//
// If both scrollbars are visible, the area where they meet is drawn with a
// subnode named junction.
//
//
// Accessibility
//
// GtkScrolledWindow uses the GTK_ACCESSIBLE_ROLE_GROUP role.
type ScrolledWindow interface {
	Widget
	Accessible
	Buildable
	ConstraintTarget

	// Child gets the child widget of @scrolled_window.
	Child() Widget
	// HAdjustment returns the horizontal scrollbar’s adjustment, used to
	// connect the horizontal scrollbar to the child widget’s horizontal scroll
	// functionality.
	HAdjustment() Adjustment
	// HasFrame gets whether the scrolled window draws a frame. See
	// gtk_scrolled_window_set_has_frame().
	HasFrame() bool
	// HScrollbar returns the horizontal scrollbar of @scrolled_window.
	HScrollbar() Widget
	// KineticScrolling returns the specified kinetic scrolling behavior.
	KineticScrolling() bool
	// MaxContentHeight returns the maximum content height set.
	MaxContentHeight() int
	// MaxContentWidth returns the maximum content width set.
	MaxContentWidth() int
	// MinContentHeight gets the minimal content height of @scrolled_window, or
	// -1 if not set.
	MinContentHeight() int
	// MinContentWidth gets the minimum content width of @scrolled_window, or -1
	// if not set.
	MinContentWidth() int
	// OverlayScrolling returns whether overlay scrolling is enabled for this
	// scrolled window.
	OverlayScrolling() bool
	// Placement gets the placement of the contents with respect to the
	// scrollbars for the scrolled window. See
	// gtk_scrolled_window_set_placement().
	Placement() CornerType
	// Policy retrieves the current policy values for the horizontal and
	// vertical scrollbars. See gtk_scrolled_window_set_policy().
	Policy() (hscrollbarPolicy PolicyType, vscrollbarPolicy PolicyType)
	// PropagateNaturalHeight reports whether the natural height of the child
	// will be calculated and propagated through the scrolled window’s requested
	// natural height.
	PropagateNaturalHeight() bool
	// PropagateNaturalWidth reports whether the natural width of the child will
	// be calculated and propagated through the scrolled window’s requested
	// natural width.
	PropagateNaturalWidth() bool
	// VAdjustment returns the vertical scrollbar’s adjustment, used to connect
	// the vertical scrollbar to the child widget’s vertical scroll
	// functionality.
	VAdjustment() Adjustment
	// VScrollbar returns the vertical scrollbar of @scrolled_window.
	VScrollbar() Widget
	// SetChild sets the child widget of @scrolled_window.
	SetChild(child Widget)
	// SetHAdjustment sets the Adjustment for the horizontal scrollbar.
	SetHAdjustment(hadjustment Adjustment)
	// SetHasFrame changes the frame drawn around the contents of
	// @scrolled_window.
	SetHasFrame(hasFrame bool)
	// SetKineticScrolling turns kinetic scrolling on or off. Kinetic scrolling
	// only applies to devices with source GDK_SOURCE_TOUCHSCREEN.
	SetKineticScrolling(kineticScrolling bool)
	// SetMaxContentHeight sets the maximum height that @scrolled_window should
	// keep visible. The @scrolled_window will grow up to this height before it
	// starts scrolling the content.
	//
	// It is a programming error to set the maximum content height to a value
	// smaller than ScrolledWindow:min-content-height.
	SetMaxContentHeight(height int)
	// SetMaxContentWidth sets the maximum width that @scrolled_window should
	// keep visible. The @scrolled_window will grow up to this width before it
	// starts scrolling the content.
	//
	// It is a programming error to set the maximum content width to a value
	// smaller than ScrolledWindow:min-content-width.
	SetMaxContentWidth(width int)
	// SetMinContentHeight sets the minimum height that @scrolled_window should
	// keep visible. Note that this can and (usually will) be smaller than the
	// minimum size of the content.
	//
	// It is a programming error to set the minimum content height to a value
	// greater than ScrolledWindow:max-content-height.
	SetMinContentHeight(height int)
	// SetMinContentWidth sets the minimum width that @scrolled_window should
	// keep visible. Note that this can and (usually will) be smaller than the
	// minimum size of the content.
	//
	// It is a programming error to set the minimum content width to a value
	// greater than ScrolledWindow:max-content-width.
	SetMinContentWidth(width int)
	// SetOverlayScrolling enables or disables overlay scrolling for this
	// scrolled window.
	SetOverlayScrolling(overlayScrolling bool)
	// SetPlacement sets the placement of the contents with respect to the
	// scrollbars for the scrolled window.
	//
	// The default is GTK_CORNER_TOP_LEFT, meaning the child is in the top left,
	// with the scrollbars underneath and to the right. Other values in
	// CornerType are GTK_CORNER_TOP_RIGHT, GTK_CORNER_BOTTOM_LEFT, and
	// GTK_CORNER_BOTTOM_RIGHT.
	//
	// See also gtk_scrolled_window_get_placement() and
	// gtk_scrolled_window_unset_placement().
	SetPlacement(windowPlacement CornerType)
	// SetPolicy sets the scrollbar policy for the horizontal and vertical
	// scrollbars.
	//
	// The policy determines when the scrollbar should appear; it is a value
	// from the PolicyType enumeration. If GTK_POLICY_ALWAYS, the scrollbar is
	// always present; if GTK_POLICY_NEVER, the scrollbar is never present; if
	// GTK_POLICY_AUTOMATIC, the scrollbar is present only if needed (that is,
	// if the slider part of the bar would be smaller than the trough — the
	// display is larger than the page size).
	SetPolicy(hscrollbarPolicy PolicyType, vscrollbarPolicy PolicyType)
	// SetPropagateNaturalHeight sets whether the natural height of the child
	// should be calculated and propagated through the scrolled window’s
	// requested natural height.
	SetPropagateNaturalHeight(propagate bool)
	// SetPropagateNaturalWidth sets whether the natural width of the child
	// should be calculated and propagated through the scrolled window’s
	// requested natural width.
	SetPropagateNaturalWidth(propagate bool)
	// SetVAdjustment sets the Adjustment for the vertical scrollbar.
	SetVAdjustment(vadjustment Adjustment)
	// UnsetPlacement unsets the placement of the contents with respect to the
	// scrollbars for the scrolled window. If no window placement is set for a
	// scrolled window, it defaults to GTK_CORNER_TOP_LEFT.
	//
	// See also gtk_scrolled_window_set_placement() and
	// gtk_scrolled_window_get_placement().
	UnsetPlacement()
}

// scrolledWindow implements the ScrolledWindow interface.
type scrolledWindow struct {
	Widget
	Accessible
	Buildable
	ConstraintTarget
}

var _ ScrolledWindow = (*scrolledWindow)(nil)

// WrapScrolledWindow wraps a GObject to the right type. It is
// primarily used internally.
func WrapScrolledWindow(obj *externglib.Object) ScrolledWindow {
	return ScrolledWindow{
		Widget:           WrapWidget(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
	}
}

func marshalScrolledWindow(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapScrolledWindow(obj), nil
}

// NewScrolledWindow constructs a class ScrolledWindow.
func NewScrolledWindow() ScrolledWindow {
	var cret C.GtkScrolledWindow

	cret = C.gtk_scrolled_window_new()

	var scrolledWindow ScrolledWindow

	scrolledWindow = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(ScrolledWindow)

	return scrolledWindow
}

// Child gets the child widget of @scrolled_window.
func (s scrolledWindow) Child() Widget {
	var arg0 *C.GtkScrolledWindow

	arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

	var cret *C.GtkWidget

	cret = C.gtk_scrolled_window_get_child(arg0)

	var widget Widget

	widget = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Widget)

	return widget
}

// HAdjustment returns the horizontal scrollbar’s adjustment, used to
// connect the horizontal scrollbar to the child widget’s horizontal scroll
// functionality.
func (s scrolledWindow) HAdjustment() Adjustment {
	var arg0 *C.GtkScrolledWindow

	arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

	var cret *C.GtkAdjustment

	cret = C.gtk_scrolled_window_get_hadjustment(arg0)

	var adjustment Adjustment

	adjustment = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Adjustment)

	return adjustment
}

// HasFrame gets whether the scrolled window draws a frame. See
// gtk_scrolled_window_set_has_frame().
func (s scrolledWindow) HasFrame() bool {
	var arg0 *C.GtkScrolledWindow

	arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

	var cret C.gboolean

	cret = C.gtk_scrolled_window_get_has_frame(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// HScrollbar returns the horizontal scrollbar of @scrolled_window.
func (s scrolledWindow) HScrollbar() Widget {
	var arg0 *C.GtkScrolledWindow

	arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

	var cret *C.GtkWidget

	cret = C.gtk_scrolled_window_get_hscrollbar(arg0)

	var widget Widget

	widget = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Widget)

	return widget
}

// KineticScrolling returns the specified kinetic scrolling behavior.
func (s scrolledWindow) KineticScrolling() bool {
	var arg0 *C.GtkScrolledWindow

	arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

	var cret C.gboolean

	cret = C.gtk_scrolled_window_get_kinetic_scrolling(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// MaxContentHeight returns the maximum content height set.
func (s scrolledWindow) MaxContentHeight() int {
	var arg0 *C.GtkScrolledWindow

	arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

	var cret C.int

	cret = C.gtk_scrolled_window_get_max_content_height(arg0)

	var gint int

	gint = (int)(cret)

	return gint
}

// MaxContentWidth returns the maximum content width set.
func (s scrolledWindow) MaxContentWidth() int {
	var arg0 *C.GtkScrolledWindow

	arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

	var cret C.int

	cret = C.gtk_scrolled_window_get_max_content_width(arg0)

	var gint int

	gint = (int)(cret)

	return gint
}

// MinContentHeight gets the minimal content height of @scrolled_window, or
// -1 if not set.
func (s scrolledWindow) MinContentHeight() int {
	var arg0 *C.GtkScrolledWindow

	arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

	var cret C.int

	cret = C.gtk_scrolled_window_get_min_content_height(arg0)

	var gint int

	gint = (int)(cret)

	return gint
}

// MinContentWidth gets the minimum content width of @scrolled_window, or -1
// if not set.
func (s scrolledWindow) MinContentWidth() int {
	var arg0 *C.GtkScrolledWindow

	arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

	var cret C.int

	cret = C.gtk_scrolled_window_get_min_content_width(arg0)

	var gint int

	gint = (int)(cret)

	return gint
}

// OverlayScrolling returns whether overlay scrolling is enabled for this
// scrolled window.
func (s scrolledWindow) OverlayScrolling() bool {
	var arg0 *C.GtkScrolledWindow

	arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

	var cret C.gboolean

	cret = C.gtk_scrolled_window_get_overlay_scrolling(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// Placement gets the placement of the contents with respect to the
// scrollbars for the scrolled window. See
// gtk_scrolled_window_set_placement().
func (s scrolledWindow) Placement() CornerType {
	var arg0 *C.GtkScrolledWindow

	arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

	var cret C.GtkCornerType

	cret = C.gtk_scrolled_window_get_placement(arg0)

	var cornerType CornerType

	cornerType = CornerType(cret)

	return cornerType
}

// Policy retrieves the current policy values for the horizontal and
// vertical scrollbars. See gtk_scrolled_window_set_policy().
func (s scrolledWindow) Policy() (hscrollbarPolicy PolicyType, vscrollbarPolicy PolicyType) {
	var arg0 *C.GtkScrolledWindow

	arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

	var arg1 C.GtkPolicyType
	var arg2 C.GtkPolicyType

	C.gtk_scrolled_window_get_policy(arg0, &arg1, &arg2)

	var hscrollbarPolicy PolicyType
	var vscrollbarPolicy PolicyType

	hscrollbarPolicy = PolicyType(arg1)
	vscrollbarPolicy = PolicyType(arg2)

	return hscrollbarPolicy, vscrollbarPolicy
}

// PropagateNaturalHeight reports whether the natural height of the child
// will be calculated and propagated through the scrolled window’s requested
// natural height.
func (s scrolledWindow) PropagateNaturalHeight() bool {
	var arg0 *C.GtkScrolledWindow

	arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

	var cret C.gboolean

	cret = C.gtk_scrolled_window_get_propagate_natural_height(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// PropagateNaturalWidth reports whether the natural width of the child will
// be calculated and propagated through the scrolled window’s requested
// natural width.
func (s scrolledWindow) PropagateNaturalWidth() bool {
	var arg0 *C.GtkScrolledWindow

	arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

	var cret C.gboolean

	cret = C.gtk_scrolled_window_get_propagate_natural_width(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// VAdjustment returns the vertical scrollbar’s adjustment, used to connect
// the vertical scrollbar to the child widget’s vertical scroll
// functionality.
func (s scrolledWindow) VAdjustment() Adjustment {
	var arg0 *C.GtkScrolledWindow

	arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

	var cret *C.GtkAdjustment

	cret = C.gtk_scrolled_window_get_vadjustment(arg0)

	var adjustment Adjustment

	adjustment = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Adjustment)

	return adjustment
}

// VScrollbar returns the vertical scrollbar of @scrolled_window.
func (s scrolledWindow) VScrollbar() Widget {
	var arg0 *C.GtkScrolledWindow

	arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

	var cret *C.GtkWidget

	cret = C.gtk_scrolled_window_get_vscrollbar(arg0)

	var widget Widget

	widget = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Widget)

	return widget
}

// SetChild sets the child widget of @scrolled_window.
func (s scrolledWindow) SetChild(child Widget) {
	var arg0 *C.GtkScrolledWindow
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_scrolled_window_set_child(arg0, arg1)
}

// SetHAdjustment sets the Adjustment for the horizontal scrollbar.
func (s scrolledWindow) SetHAdjustment(hadjustment Adjustment) {
	var arg0 *C.GtkScrolledWindow
	var arg1 *C.GtkAdjustment

	arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GtkAdjustment)(unsafe.Pointer(hadjustment.Native()))

	C.gtk_scrolled_window_set_hadjustment(arg0, arg1)
}

// SetHasFrame changes the frame drawn around the contents of
// @scrolled_window.
func (s scrolledWindow) SetHasFrame(hasFrame bool) {
	var arg0 *C.GtkScrolledWindow
	var arg1 C.gboolean

	arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
	if hasFrame {
		arg1 = C.gboolean(1)
	}

	C.gtk_scrolled_window_set_has_frame(arg0, arg1)
}

// SetKineticScrolling turns kinetic scrolling on or off. Kinetic scrolling
// only applies to devices with source GDK_SOURCE_TOUCHSCREEN.
func (s scrolledWindow) SetKineticScrolling(kineticScrolling bool) {
	var arg0 *C.GtkScrolledWindow
	var arg1 C.gboolean

	arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
	if kineticScrolling {
		arg1 = C.gboolean(1)
	}

	C.gtk_scrolled_window_set_kinetic_scrolling(arg0, arg1)
}

// SetMaxContentHeight sets the maximum height that @scrolled_window should
// keep visible. The @scrolled_window will grow up to this height before it
// starts scrolling the content.
//
// It is a programming error to set the maximum content height to a value
// smaller than ScrolledWindow:min-content-height.
func (s scrolledWindow) SetMaxContentHeight(height int) {
	var arg0 *C.GtkScrolledWindow
	var arg1 C.int

	arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
	arg1 = C.int(height)

	C.gtk_scrolled_window_set_max_content_height(arg0, arg1)
}

// SetMaxContentWidth sets the maximum width that @scrolled_window should
// keep visible. The @scrolled_window will grow up to this width before it
// starts scrolling the content.
//
// It is a programming error to set the maximum content width to a value
// smaller than ScrolledWindow:min-content-width.
func (s scrolledWindow) SetMaxContentWidth(width int) {
	var arg0 *C.GtkScrolledWindow
	var arg1 C.int

	arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
	arg1 = C.int(width)

	C.gtk_scrolled_window_set_max_content_width(arg0, arg1)
}

// SetMinContentHeight sets the minimum height that @scrolled_window should
// keep visible. Note that this can and (usually will) be smaller than the
// minimum size of the content.
//
// It is a programming error to set the minimum content height to a value
// greater than ScrolledWindow:max-content-height.
func (s scrolledWindow) SetMinContentHeight(height int) {
	var arg0 *C.GtkScrolledWindow
	var arg1 C.int

	arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
	arg1 = C.int(height)

	C.gtk_scrolled_window_set_min_content_height(arg0, arg1)
}

// SetMinContentWidth sets the minimum width that @scrolled_window should
// keep visible. Note that this can and (usually will) be smaller than the
// minimum size of the content.
//
// It is a programming error to set the minimum content width to a value
// greater than ScrolledWindow:max-content-width.
func (s scrolledWindow) SetMinContentWidth(width int) {
	var arg0 *C.GtkScrolledWindow
	var arg1 C.int

	arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
	arg1 = C.int(width)

	C.gtk_scrolled_window_set_min_content_width(arg0, arg1)
}

// SetOverlayScrolling enables or disables overlay scrolling for this
// scrolled window.
func (s scrolledWindow) SetOverlayScrolling(overlayScrolling bool) {
	var arg0 *C.GtkScrolledWindow
	var arg1 C.gboolean

	arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
	if overlayScrolling {
		arg1 = C.gboolean(1)
	}

	C.gtk_scrolled_window_set_overlay_scrolling(arg0, arg1)
}

// SetPlacement sets the placement of the contents with respect to the
// scrollbars for the scrolled window.
//
// The default is GTK_CORNER_TOP_LEFT, meaning the child is in the top left,
// with the scrollbars underneath and to the right. Other values in
// CornerType are GTK_CORNER_TOP_RIGHT, GTK_CORNER_BOTTOM_LEFT, and
// GTK_CORNER_BOTTOM_RIGHT.
//
// See also gtk_scrolled_window_get_placement() and
// gtk_scrolled_window_unset_placement().
func (s scrolledWindow) SetPlacement(windowPlacement CornerType) {
	var arg0 *C.GtkScrolledWindow
	var arg1 C.GtkCornerType

	arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
	arg1 = (C.GtkCornerType)(windowPlacement)

	C.gtk_scrolled_window_set_placement(arg0, arg1)
}

// SetPolicy sets the scrollbar policy for the horizontal and vertical
// scrollbars.
//
// The policy determines when the scrollbar should appear; it is a value
// from the PolicyType enumeration. If GTK_POLICY_ALWAYS, the scrollbar is
// always present; if GTK_POLICY_NEVER, the scrollbar is never present; if
// GTK_POLICY_AUTOMATIC, the scrollbar is present only if needed (that is,
// if the slider part of the bar would be smaller than the trough — the
// display is larger than the page size).
func (s scrolledWindow) SetPolicy(hscrollbarPolicy PolicyType, vscrollbarPolicy PolicyType) {
	var arg0 *C.GtkScrolledWindow
	var arg1 C.GtkPolicyType
	var arg2 C.GtkPolicyType

	arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
	arg1 = (C.GtkPolicyType)(hscrollbarPolicy)
	arg2 = (C.GtkPolicyType)(vscrollbarPolicy)

	C.gtk_scrolled_window_set_policy(arg0, arg1, arg2)
}

// SetPropagateNaturalHeight sets whether the natural height of the child
// should be calculated and propagated through the scrolled window’s
// requested natural height.
func (s scrolledWindow) SetPropagateNaturalHeight(propagate bool) {
	var arg0 *C.GtkScrolledWindow
	var arg1 C.gboolean

	arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
	if propagate {
		arg1 = C.gboolean(1)
	}

	C.gtk_scrolled_window_set_propagate_natural_height(arg0, arg1)
}

// SetPropagateNaturalWidth sets whether the natural width of the child
// should be calculated and propagated through the scrolled window’s
// requested natural width.
func (s scrolledWindow) SetPropagateNaturalWidth(propagate bool) {
	var arg0 *C.GtkScrolledWindow
	var arg1 C.gboolean

	arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
	if propagate {
		arg1 = C.gboolean(1)
	}

	C.gtk_scrolled_window_set_propagate_natural_width(arg0, arg1)
}

// SetVAdjustment sets the Adjustment for the vertical scrollbar.
func (s scrolledWindow) SetVAdjustment(vadjustment Adjustment) {
	var arg0 *C.GtkScrolledWindow
	var arg1 *C.GtkAdjustment

	arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GtkAdjustment)(unsafe.Pointer(vadjustment.Native()))

	C.gtk_scrolled_window_set_vadjustment(arg0, arg1)
}

// UnsetPlacement unsets the placement of the contents with respect to the
// scrollbars for the scrolled window. If no window placement is set for a
// scrolled window, it defaults to GTK_CORNER_TOP_LEFT.
//
// See also gtk_scrolled_window_set_placement() and
// gtk_scrolled_window_get_placement().
func (s scrolledWindow) UnsetPlacement() {
	var arg0 *C.GtkScrolledWindow

	arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

	C.gtk_scrolled_window_unset_placement(arg0)
}

// SearchBar is a container made to have a search entry (possibly with
// additional connex widgets, such as drop-down menus, or buttons) built-in. The
// search bar would appear when a search is started through typing on the
// keyboard, or the application’s search mode is toggled on.
//
// For keyboard presses to start a search, the search bar must be told of a
// widget to capture key events from through
// gtk_search_bar_set_key_capture_widget(). This widget will typically be the
// top-level window, or a parent container of the search bar. Common shortcuts
// such as Ctrl+F should be handled as an application action, or through the
// menu items.
//
// You will also need to tell the search bar about which entry you are using as
// your search entry using gtk_search_bar_connect_entry(). The following example
// shows you how to create a more complex search entry.
//
//
// Creating a search bar
//
// A simple example
// (https://gitlab.gnome.org/GNOME/gtk/tree/master/examples/search-bar.c)
//
// CSS nodes
//
//    searchbar
//    ╰── revealer
//        ╰── box
//             ├── [child]
//             ╰── [button.close]
//
// GtkSearchBar has a main CSS node with name searchbar. It has a child node
// with name revealer that contains a node with name box. The box node contains
// both the CSS node of the child widget as well as an optional button node
// which gets the .close style class applied.
//
//
// Accessibility
//
// GtkSearchBar uses the GTK_ACCESSIBLE_ROLE_SEARCH role.
type SearchBar interface {
	Widget
	Accessible
	Buildable
	ConstraintTarget

	// ConnectEntry connects the Entry widget passed as the one to be used in
	// this search bar. The entry should be a descendant of the search bar. This
	// is only required if the entry isn’t the direct child of the search bar
	// (as in our main example).
	ConnectEntry(entry Editable)
	// Child gets the child widget of @bar.
	Child() Widget
	// KeyCaptureWidget gets the widget that @bar is capturing key events from.
	KeyCaptureWidget() Widget
	// SearchMode returns whether the search mode is on or off.
	SearchMode() bool
	// ShowCloseButton returns whether the close button is shown.
	ShowCloseButton() bool
	// SetChild sets the child widget of @bar.
	SetChild(child Widget)
	// SetKeyCaptureWidget sets @widget as the widget that @bar will capture key
	// events from.
	//
	// If key events are handled by the search bar, the bar will be shown, and
	// the entry populated with the entered text.
	SetKeyCaptureWidget(widget Widget)
	// SetSearchMode switches the search mode on or off.
	SetSearchMode(searchMode bool)
	// SetShowCloseButton shows or hides the close button. Applications that
	// already have a “search” toggle button should not show a close button in
	// their search bar, as it duplicates the role of the toggle button.
	SetShowCloseButton(visible bool)
}

// searchBar implements the SearchBar interface.
type searchBar struct {
	Widget
	Accessible
	Buildable
	ConstraintTarget
}

var _ SearchBar = (*searchBar)(nil)

// WrapSearchBar wraps a GObject to the right type. It is
// primarily used internally.
func WrapSearchBar(obj *externglib.Object) SearchBar {
	return SearchBar{
		Widget:           WrapWidget(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
	}
}

func marshalSearchBar(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSearchBar(obj), nil
}

// NewSearchBar constructs a class SearchBar.
func NewSearchBar() SearchBar {
	var cret C.GtkSearchBar

	cret = C.gtk_search_bar_new()

	var searchBar SearchBar

	searchBar = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(SearchBar)

	return searchBar
}

// ConnectEntry connects the Entry widget passed as the one to be used in
// this search bar. The entry should be a descendant of the search bar. This
// is only required if the entry isn’t the direct child of the search bar
// (as in our main example).
func (b searchBar) ConnectEntry(entry Editable) {
	var arg0 *C.GtkSearchBar
	var arg1 *C.GtkEditable

	arg0 = (*C.GtkSearchBar)(unsafe.Pointer(b.Native()))
	arg1 = (*C.GtkEditable)(unsafe.Pointer(entry.Native()))

	C.gtk_search_bar_connect_entry(arg0, arg1)
}

// Child gets the child widget of @bar.
func (b searchBar) Child() Widget {
	var arg0 *C.GtkSearchBar

	arg0 = (*C.GtkSearchBar)(unsafe.Pointer(b.Native()))

	var cret *C.GtkWidget

	cret = C.gtk_search_bar_get_child(arg0)

	var widget Widget

	widget = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Widget)

	return widget
}

// KeyCaptureWidget gets the widget that @bar is capturing key events from.
func (b searchBar) KeyCaptureWidget() Widget {
	var arg0 *C.GtkSearchBar

	arg0 = (*C.GtkSearchBar)(unsafe.Pointer(b.Native()))

	var cret *C.GtkWidget

	cret = C.gtk_search_bar_get_key_capture_widget(arg0)

	var widget Widget

	widget = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Widget)

	return widget
}

// SearchMode returns whether the search mode is on or off.
func (b searchBar) SearchMode() bool {
	var arg0 *C.GtkSearchBar

	arg0 = (*C.GtkSearchBar)(unsafe.Pointer(b.Native()))

	var cret C.gboolean

	cret = C.gtk_search_bar_get_search_mode(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// ShowCloseButton returns whether the close button is shown.
func (b searchBar) ShowCloseButton() bool {
	var arg0 *C.GtkSearchBar

	arg0 = (*C.GtkSearchBar)(unsafe.Pointer(b.Native()))

	var cret C.gboolean

	cret = C.gtk_search_bar_get_show_close_button(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// SetChild sets the child widget of @bar.
func (b searchBar) SetChild(child Widget) {
	var arg0 *C.GtkSearchBar
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkSearchBar)(unsafe.Pointer(b.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_search_bar_set_child(arg0, arg1)
}

// SetKeyCaptureWidget sets @widget as the widget that @bar will capture key
// events from.
//
// If key events are handled by the search bar, the bar will be shown, and
// the entry populated with the entered text.
func (b searchBar) SetKeyCaptureWidget(widget Widget) {
	var arg0 *C.GtkSearchBar
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkSearchBar)(unsafe.Pointer(b.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	C.gtk_search_bar_set_key_capture_widget(arg0, arg1)
}

// SetSearchMode switches the search mode on or off.
func (b searchBar) SetSearchMode(searchMode bool) {
	var arg0 *C.GtkSearchBar
	var arg1 C.gboolean

	arg0 = (*C.GtkSearchBar)(unsafe.Pointer(b.Native()))
	if searchMode {
		arg1 = C.gboolean(1)
	}

	C.gtk_search_bar_set_search_mode(arg0, arg1)
}

// SetShowCloseButton shows or hides the close button. Applications that
// already have a “search” toggle button should not show a close button in
// their search bar, as it duplicates the role of the toggle button.
func (b searchBar) SetShowCloseButton(visible bool) {
	var arg0 *C.GtkSearchBar
	var arg1 C.gboolean

	arg0 = (*C.GtkSearchBar)(unsafe.Pointer(b.Native()))
	if visible {
		arg1 = C.gboolean(1)
	}

	C.gtk_search_bar_set_show_close_button(arg0, arg1)
}

// SearchEntry is an entry widget that has been tailored for use as a search
// entry. The main aPI for interacting with a GtkSearchEntry as entry is the
// Editable interface.
//
// It will show an inactive symbolic “find” icon when the search entry is empty,
// and a symbolic “clear” icon when there is text. Clicking on the “clear” icon
// will empty the search entry.
//
// To make filtering appear more reactive, it is a good idea to not react to
// every change in the entry text immediately, but only after a short delay. To
// support this, SearchEntry emits the SearchEntry::search-changed signal which
// can be used instead of the Editable::changed signal.
//
// The SearchEntry::previous-match, SearchEntry::next-match and
// SearchEntry::stop-search signals can be used to implement moving between
// search results and ending the search.
//
// Often, GtkSearchEntry will be fed events by means of being placed inside a
// SearchBar. If that is not the case, you can use
// gtk_search_entry_set_key_capture_widget() to let it capture key input from
// another widget.
//
// CSS Nodes
//
//    entry.search
//    ╰── text
//
// GtkSearchEntry has a single CSS node with name entry that carries a .sarch
// style class, and the text node is a child of that.
//
//
// Accessibility
//
// GtkSearchEntry uses the K_ACCESSIBLE_ROLE_SEARCH_BOX role.
type SearchEntry interface {
	Widget
	Accessible
	Buildable
	ConstraintTarget
	Editable

	// KeyCaptureWidget gets the widget that @entry is capturing key events
	// from.
	KeyCaptureWidget() Widget
	// SetKeyCaptureWidget sets @widget as the widget that @entry will capture
	// key events from.
	//
	// Key events are consumed by the search entry to start or continue a
	// search.
	//
	// If the entry is part of a SearchBar, it is preferable to call
	// gtk_search_bar_set_key_capture_widget() instead, which will reveal the
	// entry in addition to triggering the search entry.
	SetKeyCaptureWidget(widget Widget)
}

// searchEntry implements the SearchEntry interface.
type searchEntry struct {
	Widget
	Accessible
	Buildable
	ConstraintTarget
	Editable
}

var _ SearchEntry = (*searchEntry)(nil)

// WrapSearchEntry wraps a GObject to the right type. It is
// primarily used internally.
func WrapSearchEntry(obj *externglib.Object) SearchEntry {
	return SearchEntry{
		Widget:           WrapWidget(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
		Editable:         WrapEditable(obj),
	}
}

func marshalSearchEntry(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSearchEntry(obj), nil
}

// NewSearchEntry constructs a class SearchEntry.
func NewSearchEntry() SearchEntry {
	var cret C.GtkSearchEntry

	cret = C.gtk_search_entry_new()

	var searchEntry SearchEntry

	searchEntry = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(SearchEntry)

	return searchEntry
}

// KeyCaptureWidget gets the widget that @entry is capturing key events
// from.
func (e searchEntry) KeyCaptureWidget() Widget {
	var arg0 *C.GtkSearchEntry

	arg0 = (*C.GtkSearchEntry)(unsafe.Pointer(e.Native()))

	var cret *C.GtkWidget

	cret = C.gtk_search_entry_get_key_capture_widget(arg0)

	var widget Widget

	widget = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Widget)

	return widget
}

// SetKeyCaptureWidget sets @widget as the widget that @entry will capture
// key events from.
//
// Key events are consumed by the search entry to start or continue a
// search.
//
// If the entry is part of a SearchBar, it is preferable to call
// gtk_search_bar_set_key_capture_widget() instead, which will reveal the
// entry in addition to triggering the search entry.
func (e searchEntry) SetKeyCaptureWidget(widget Widget) {
	var arg0 *C.GtkSearchEntry
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkSearchEntry)(unsafe.Pointer(e.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	C.gtk_search_entry_set_key_capture_widget(arg0, arg1)
}

// Separator: gtkSeparator is a horizontal or vertical separator widget,
// depending on the value of the Orientable:orientation property, used to group
// the widgets within a window. It displays a line with a shadow to make it
// appear sunken into the interface.
//
//
// CSS nodes
//
// GtkSeparator has a single CSS node with name separator. The node gets one of
// the .horizontal or .vertical style classes.
//
//
// Accessibility
//
// GtkSeparator uses the K_ACCESSIBLE_ROLE_SEPARATOR role.
type Separator interface {
	Widget
	Accessible
	Buildable
	ConstraintTarget
	Orientable
}

// separator implements the Separator interface.
type separator struct {
	Widget
	Accessible
	Buildable
	ConstraintTarget
	Orientable
}

var _ Separator = (*separator)(nil)

// WrapSeparator wraps a GObject to the right type. It is
// primarily used internally.
func WrapSeparator(obj *externglib.Object) Separator {
	return Separator{
		Widget:           WrapWidget(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
		Orientable:       WrapOrientable(obj),
	}
}

func marshalSeparator(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSeparator(obj), nil
}

// NewSeparator constructs a class Separator.
func NewSeparator(orientation Orientation) Separator {
	var arg1 C.GtkOrientation

	arg1 = (C.GtkOrientation)(orientation)

	var cret C.GtkSeparator

	cret = C.gtk_separator_new(arg1)

	var separator Separator

	separator = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Separator)

	return separator
}

// Settings gtkSettings provide a mechanism to share global settings between
// applications.
//
// On the X window system, this sharing is realized by an XSettings
// (http://www.freedesktop.org/wiki/Specifications/xsettings-spec) manager that
// is usually part of the desktop environment, along with utilities that let the
// user change these settings.
//
// On Wayland, the settings are obtained either via a settings portal, or by
// reading desktop settings from DConf.
//
// In the absence of these sharing mechanisms, GTK reads default values for
// settings from `settings.ini` files in `/etc/gtk-4.0`,
// `$XDG_CONFIG_DIRS/gtk-4.0` and `$XDG_CONFIG_HOME/gtk-4.0`. These files must
// be valid key files (see File), and have a section called Settings. Themes can
// also provide default values for settings by installing a `settings.ini` file
// next to their `gtk.css` file.
//
// Applications can override system-wide settings by setting the property of the
// GtkSettings object with g_object_set(). This should be restricted to special
// cases though; GtkSettings are not meant as an application configuration
// facility.
//
// There is one GtkSettings instance per display. It can be obtained with
// gtk_settings_get_for_display(), but in many cases, it is more convenient to
// use gtk_widget_get_settings().
type Settings interface {
	gextras.Objector
	StyleProvider

	// ResetProperty undoes the effect of calling g_object_set() to install an
	// application-specific value for a setting. After this call, the setting
	// will again follow the session-wide value for this setting.
	ResetProperty(name string)
}

// settings implements the Settings interface.
type settings struct {
	gextras.Objector
	StyleProvider
}

var _ Settings = (*settings)(nil)

// WrapSettings wraps a GObject to the right type. It is
// primarily used internally.
func WrapSettings(obj *externglib.Object) Settings {
	return Settings{
		Objector:      obj,
		StyleProvider: WrapStyleProvider(obj),
	}
}

func marshalSettings(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSettings(obj), nil
}

// ResetProperty undoes the effect of calling g_object_set() to install an
// application-specific value for a setting. After this call, the setting
// will again follow the session-wide value for this setting.
func (s settings) ResetProperty(name string) {
	var arg0 *C.GtkSettings
	var arg1 *C.char

	arg0 = (*C.GtkSettings)(unsafe.Pointer(s.Native()))
	arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_settings_reset_property(arg0, arg1)
}

// ShortcutsWindow: a GtkShortcutsWindow shows brief information about the
// keyboard shortcuts and gestures of an application. The shortcuts can be
// grouped, and you can have multiple sections in this window, corresponding to
// the major modes of your application.
//
// Additionally, the shortcuts can be filtered by the current view, to avoid
// showing information that is not relevant in the current application context.
//
// The recommended way to construct a GtkShortcutsWindow is with GtkBuilder, by
// populating a ShortcutsWindow with one or more ShortcutsSection objects, which
// contain ShortcutsGroups that in turn contain objects of class
// ShortcutsShortcut.
//
// A simple example:
//
// ! (gedit-shortcuts.png)
//
// This example has as single section. As you can see, the shortcut groups are
// arranged in columns, and spread across several pages if there are too many to
// find on a single page.
//
// The .ui file for this example can be found here
// (https://gitlab.gnome.org/GNOME/gtk/tree/master/demos/gtk-demo/shortcuts-gedit.ui).
//
// An example with multiple views:
//
// ! (clocks-shortcuts.png)
//
// This example shows a ShortcutsWindow that has been configured to show only
// the shortcuts relevant to the "stopwatch" view.
//
// The .ui file for this example can be found here
// (https://gitlab.gnome.org/GNOME/gtk/tree/master/demos/gtk-demo/shortcuts-clocks.ui).
//
// An example with multiple sections:
//
// ! (builder-shortcuts.png)
//
// This example shows a ShortcutsWindow with two sections, "Editor Shortcuts"
// and "Terminal Shortcuts".
//
// The .ui file for this example can be found here
// (https://gitlab.gnome.org/GNOME/gtk/tree/master/demos/gtk-demo/shortcuts-builder.ui).
type ShortcutsWindow interface {
	Window
	Accessible
	Buildable
	ConstraintTarget
	Native
	Root
	ShortcutManager
}

// shortcutsWindow implements the ShortcutsWindow interface.
type shortcutsWindow struct {
	Window
	Accessible
	Buildable
	ConstraintTarget
	Native
	Root
	ShortcutManager
}

var _ ShortcutsWindow = (*shortcutsWindow)(nil)

// WrapShortcutsWindow wraps a GObject to the right type. It is
// primarily used internally.
func WrapShortcutsWindow(obj *externglib.Object) ShortcutsWindow {
	return ShortcutsWindow{
		Window:           WrapWindow(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
		Native:           WrapNative(obj),
		Root:             WrapRoot(obj),
		ShortcutManager:  WrapShortcutManager(obj),
	}
}

func marshalShortcutsWindow(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapShortcutsWindow(obj), nil
}

// SizeGroup provides a mechanism for grouping a number of widgets together so
// they all request the same amount of space. This is typically useful when you
// want a column of widgets to have the same size, but you can’t use a Grid
// widget.
//
// In detail, the size requested for each widget in a SizeGroup is the maximum
// of the sizes that would have been requested for each widget in the size group
// if they were not in the size group. The mode of the size group (see
// gtk_size_group_set_mode()) determines whether this applies to the horizontal
// size, the vertical size, or both sizes.
//
// Note that size groups only affect the amount of space requested, not the size
// that the widgets finally receive. If you want the widgets in a SizeGroup to
// actually be the same size, you need to pack them in such a way that they get
// the size they request and not more. For example, if you are packing your
// widgets into a table, you would not include the GTK_FILL flag.
//
// SizeGroup objects are referenced by each widget in the size group, so once
// you have added all widgets to a SizeGroup, you can drop the initial reference
// to the size group with g_object_unref(). If the widgets in the size group are
// subsequently destroyed, then they will be removed from the size group and
// drop their references on the size group; when all widgets have been removed,
// the size group will be freed.
//
// Widgets can be part of multiple size groups; GTK will compute the horizontal
// size of a widget from the horizontal requisition of all widgets that can be
// reached from the widget by a chain of size groups of type
// GTK_SIZE_GROUP_HORIZONTAL or GTK_SIZE_GROUP_BOTH, and the vertical size from
// the vertical requisition of all widgets that can be reached from the widget
// by a chain of size groups of type GTK_SIZE_GROUP_VERTICAL or
// GTK_SIZE_GROUP_BOTH.
//
// Note that only non-contextual sizes of every widget are ever consulted by
// size groups (since size groups have no knowledge of what size a widget will
// be allocated in one dimension, it cannot derive how much height a widget will
// receive for a given width). When grouping widgets that trade height for width
// in mode GTK_SIZE_GROUP_VERTICAL or GTK_SIZE_GROUP_BOTH: the height for the
// minimum width will be the requested height for all widgets in the group. The
// same is of course true when horizontally grouping width for height widgets.
//
// Widgets that trade height-for-width should set a reasonably large minimum
// width by way of Label:width-chars for instance. Widgets with static sizes as
// well as widgets that grow (such as ellipsizing text) need no such
// considerations.
//
//
// GtkSizeGroup as GtkBuildable
//
// Size groups can be specified in a UI definition by placing an <object>
// element with `class="GtkSizeGroup"` somewhere in the UI definition. The
// widgets that belong to the size group are specified by a <widgets> element
// that may contain multiple <widget> elements, one for each member of the size
// group. The ”name” attribute gives the id of the widget.
//
// An example of a UI definition fragment with GtkSizeGroup:
//
//    <object class="GtkSizeGroup">
//      <property name="mode">horizontal</property>
//      <widgets>
//        <widget name="radio1"/>
//        <widget name="radio2"/>
//      </widgets>
//    </object>
type SizeGroup interface {
	gextras.Objector
	Buildable

	// AddWidget adds a widget to a SizeGroup. In the future, the requisition of
	// the widget will be determined as the maximum of its requisition and the
	// requisition of the other widgets in the size group. Whether this applies
	// horizontally, vertically, or in both directions depends on the mode of
	// the size group. See gtk_size_group_set_mode().
	//
	// When the widget is destroyed or no longer referenced elsewhere, it will
	// be removed from the size group.
	AddWidget(widget Widget)
	// Mode gets the current mode of the size group. See
	// gtk_size_group_set_mode().
	Mode() SizeGroupMode
	// Widgets returns the list of widgets associated with @size_group.
	Widgets() *glib.SList
	// RemoveWidget removes a widget from a SizeGroup.
	RemoveWidget(widget Widget)
	// SetMode sets the SizeGroupMode of the size group. The mode of the size
	// group determines whether the widgets in the size group should all have
	// the same horizontal requisition (GTK_SIZE_GROUP_HORIZONTAL) all have the
	// same vertical requisition (GTK_SIZE_GROUP_VERTICAL), or should all have
	// the same requisition in both directions (GTK_SIZE_GROUP_BOTH).
	SetMode(mode SizeGroupMode)
}

// sizeGroup implements the SizeGroup interface.
type sizeGroup struct {
	gextras.Objector
	Buildable
}

var _ SizeGroup = (*sizeGroup)(nil)

// WrapSizeGroup wraps a GObject to the right type. It is
// primarily used internally.
func WrapSizeGroup(obj *externglib.Object) SizeGroup {
	return SizeGroup{
		Objector:  obj,
		Buildable: WrapBuildable(obj),
	}
}

func marshalSizeGroup(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSizeGroup(obj), nil
}

// NewSizeGroup constructs a class SizeGroup.
func NewSizeGroup(mode SizeGroupMode) SizeGroup {
	var arg1 C.GtkSizeGroupMode

	arg1 = (C.GtkSizeGroupMode)(mode)

	var cret C.GtkSizeGroup

	cret = C.gtk_size_group_new(arg1)

	var sizeGroup SizeGroup

	sizeGroup = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(SizeGroup)

	return sizeGroup
}

// AddWidget adds a widget to a SizeGroup. In the future, the requisition of
// the widget will be determined as the maximum of its requisition and the
// requisition of the other widgets in the size group. Whether this applies
// horizontally, vertically, or in both directions depends on the mode of
// the size group. See gtk_size_group_set_mode().
//
// When the widget is destroyed or no longer referenced elsewhere, it will
// be removed from the size group.
func (s sizeGroup) AddWidget(widget Widget) {
	var arg0 *C.GtkSizeGroup
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkSizeGroup)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	C.gtk_size_group_add_widget(arg0, arg1)
}

// Mode gets the current mode of the size group. See
// gtk_size_group_set_mode().
func (s sizeGroup) Mode() SizeGroupMode {
	var arg0 *C.GtkSizeGroup

	arg0 = (*C.GtkSizeGroup)(unsafe.Pointer(s.Native()))

	var cret C.GtkSizeGroupMode

	cret = C.gtk_size_group_get_mode(arg0)

	var sizeGroupMode SizeGroupMode

	sizeGroupMode = SizeGroupMode(cret)

	return sizeGroupMode
}

// Widgets returns the list of widgets associated with @size_group.
func (s sizeGroup) Widgets() *glib.SList {
	var arg0 *C.GtkSizeGroup

	arg0 = (*C.GtkSizeGroup)(unsafe.Pointer(s.Native()))

	var cret *C.GSList

	cret = C.gtk_size_group_get_widgets(arg0)

	var sList *glib.SList

	sList = glib.WrapSList(unsafe.Pointer(cret))

	return sList
}

// RemoveWidget removes a widget from a SizeGroup.
func (s sizeGroup) RemoveWidget(widget Widget) {
	var arg0 *C.GtkSizeGroup
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkSizeGroup)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	C.gtk_size_group_remove_widget(arg0, arg1)
}

// SetMode sets the SizeGroupMode of the size group. The mode of the size
// group determines whether the widgets in the size group should all have
// the same horizontal requisition (GTK_SIZE_GROUP_HORIZONTAL) all have the
// same vertical requisition (GTK_SIZE_GROUP_VERTICAL), or should all have
// the same requisition in both directions (GTK_SIZE_GROUP_BOTH).
func (s sizeGroup) SetMode(mode SizeGroupMode) {
	var arg0 *C.GtkSizeGroup
	var arg1 C.GtkSizeGroupMode

	arg0 = (*C.GtkSizeGroup)(unsafe.Pointer(s.Native()))
	arg1 = (C.GtkSizeGroupMode)(mode)

	C.gtk_size_group_set_mode(arg0, arg1)
}

// SpinButton: a SpinButton is an ideal way to allow the user to set the value
// of some attribute. Rather than having to directly type a number into a Entry,
// GtkSpinButton allows the user to click on one of two arrows to increment or
// decrement the displayed value. A value can still be typed in, with the bonus
// that it can be checked to ensure it is in a given range.
//
// The main properties of a GtkSpinButton are through an adjustment. See the
// Adjustment section for more details about an adjustment's properties.
//
// Note that GtkSpinButton will by default make its entry large enough to
// accommodate the lower and upper bounds of the adjustment. If this is not
// desired, the automatic sizing can be turned off by explicitly setting
// Editable::width-chars to a value != -1.
//
// Using a GtkSpinButton to get an integer
//
//    spinbutton.vertical
//    ├── button.up
//    ├── text
//    │    ├── undershoot.left
//    │    ╰── undershoot.right
//    ╰── button.down
//
// GtkSpinButtons main CSS node has the name spinbutton. It creates subnodes for
// the entry and the two buttons, with these names. The button nodes have the
// style classes .up and .down. The GtkText subnodes (if present) are put below
// the text node. The orientation of the spin button is reflected in the
// .vertical or .horizontal style class on the main node.
//
//
// Accessiblity
//
// GtkSpinButton uses the K_ACCESSIBLE_ROLE_SPIN_BUTTON role.
type SpinButton interface {
	Widget
	Accessible
	Buildable
	CellEditable
	ConstraintTarget
	Editable
	Orientable

	// Configure changes the properties of an existing spin button. The
	// adjustment, climb rate, and number of decimal places are updated
	// accordingly.
	Configure(adjustment Adjustment, climbRate float64, digits uint)
	// Adjustment: get the adjustment associated with a SpinButton
	Adjustment() Adjustment
	// ClimbRate returns the acceleration rate for repeated changes.
	ClimbRate() float64
	// Digits fetches the precision of @spin_button. See
	// gtk_spin_button_set_digits().
	Digits() uint
	// Increments gets the current step and page the increments used by
	// @spin_button. See gtk_spin_button_set_increments().
	Increments() (step float64, page float64)
	// Numeric returns whether non-numeric text can be typed into the spin
	// button. See gtk_spin_button_set_numeric().
	Numeric() bool
	// Range gets the range allowed for @spin_button. See
	// gtk_spin_button_set_range().
	Range() (min float64, max float64)
	// SnapToTicks returns whether the values are corrected to the nearest step.
	// See gtk_spin_button_set_snap_to_ticks().
	SnapToTicks() bool
	// UpdatePolicy gets the update behavior of a spin button. See
	// gtk_spin_button_set_update_policy().
	UpdatePolicy() SpinButtonUpdatePolicy
	// Value: get the value in the @spin_button.
	Value() float64
	// ValueAsInt: get the value @spin_button represented as an integer.
	ValueAsInt() int
	// Wrap returns whether the spin button’s value wraps around to the opposite
	// limit when the upper or lower limit of the range is exceeded. See
	// gtk_spin_button_set_wrap().
	Wrap() bool
	// SetAdjustment replaces the Adjustment associated with @spin_button.
	SetAdjustment(adjustment Adjustment)
	// SetClimbRate sets the acceleration rate for repeated changes when you
	// hold down a button or key.
	SetClimbRate(climbRate float64)
	// SetDigits: set the precision to be displayed by @spin_button. Up to 20
	// digit precision is allowed.
	SetDigits(digits uint)
	// SetIncrements sets the step and page increments for spin_button. This
	// affects how quickly the value changes when the spin button’s arrows are
	// activated.
	SetIncrements(step float64, page float64)
	// SetNumeric sets the flag that determines if non-numeric text can be typed
	// into the spin button.
	SetNumeric(numeric bool)
	// SetRange sets the minimum and maximum allowable values for @spin_button.
	//
	// If the current value is outside this range, it will be adjusted to fit
	// within the range, otherwise it will remain unchanged.
	SetRange(min float64, max float64)
	// SetSnapToTicks sets the policy as to whether values are corrected to the
	// nearest step increment when a spin button is activated after providing an
	// invalid value.
	SetSnapToTicks(snapToTicks bool)
	// SetUpdatePolicy sets the update behavior of a spin button. This
	// determines whether the spin button is always updated or only when a valid
	// value is set.
	SetUpdatePolicy(policy SpinButtonUpdatePolicy)
	// SetValue sets the value of @spin_button.
	SetValue(value float64)
	// SetWrap sets the flag that determines if a spin button value wraps around
	// to the opposite limit when the upper or lower limit of the range is
	// exceeded.
	SetWrap(wrap bool)
	// Spin: increment or decrement a spin button’s value in a specified
	// direction by a specified amount.
	Spin(direction SpinType, increment float64)
	// Update: manually force an update of the spin button.
	Update()
}

// spinButton implements the SpinButton interface.
type spinButton struct {
	Widget
	Accessible
	Buildable
	CellEditable
	ConstraintTarget
	Editable
	Orientable
}

var _ SpinButton = (*spinButton)(nil)

// WrapSpinButton wraps a GObject to the right type. It is
// primarily used internally.
func WrapSpinButton(obj *externglib.Object) SpinButton {
	return SpinButton{
		Widget:           WrapWidget(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		CellEditable:     WrapCellEditable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
		Editable:         WrapEditable(obj),
		Orientable:       WrapOrientable(obj),
	}
}

func marshalSpinButton(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSpinButton(obj), nil
}

// NewSpinButton constructs a class SpinButton.
func NewSpinButton(adjustment Adjustment, climbRate float64, digits uint) SpinButton {
	var arg1 *C.GtkAdjustment
	var arg2 C.double
	var arg3 C.guint

	arg1 = (*C.GtkAdjustment)(unsafe.Pointer(adjustment.Native()))
	arg2 = C.double(climbRate)
	arg3 = C.guint(digits)

	var cret C.GtkSpinButton

	cret = C.gtk_spin_button_new(arg1, arg2, arg3)

	var spinButton SpinButton

	spinButton = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(SpinButton)

	return spinButton
}

// NewSpinButtonWithRange constructs a class SpinButton.
func NewSpinButtonWithRange(min float64, max float64, step float64) SpinButton {
	var arg1 C.double
	var arg2 C.double
	var arg3 C.double

	arg1 = C.double(min)
	arg2 = C.double(max)
	arg3 = C.double(step)

	var cret C.GtkSpinButton

	cret = C.gtk_spin_button_new_with_range(arg1, arg2, arg3)

	var spinButton SpinButton

	spinButton = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(SpinButton)

	return spinButton
}

// Configure changes the properties of an existing spin button. The
// adjustment, climb rate, and number of decimal places are updated
// accordingly.
func (s spinButton) Configure(adjustment Adjustment, climbRate float64, digits uint) {
	var arg0 *C.GtkSpinButton
	var arg1 *C.GtkAdjustment
	var arg2 C.double
	var arg3 C.guint

	arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GtkAdjustment)(unsafe.Pointer(adjustment.Native()))
	arg2 = C.double(climbRate)
	arg3 = C.guint(digits)

	C.gtk_spin_button_configure(arg0, arg1, arg2, arg3)
}

// Adjustment: get the adjustment associated with a SpinButton
func (s spinButton) Adjustment() Adjustment {
	var arg0 *C.GtkSpinButton

	arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))

	var cret *C.GtkAdjustment

	cret = C.gtk_spin_button_get_adjustment(arg0)

	var adjustment Adjustment

	adjustment = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Adjustment)

	return adjustment
}

// ClimbRate returns the acceleration rate for repeated changes.
func (s spinButton) ClimbRate() float64 {
	var arg0 *C.GtkSpinButton

	arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))

	var cret C.double

	cret = C.gtk_spin_button_get_climb_rate(arg0)

	var gdouble float64

	gdouble = (float64)(cret)

	return gdouble
}

// Digits fetches the precision of @spin_button. See
// gtk_spin_button_set_digits().
func (s spinButton) Digits() uint {
	var arg0 *C.GtkSpinButton

	arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))

	var cret C.guint

	cret = C.gtk_spin_button_get_digits(arg0)

	var guint uint

	guint = (uint)(cret)

	return guint
}

// Increments gets the current step and page the increments used by
// @spin_button. See gtk_spin_button_set_increments().
func (s spinButton) Increments() (step float64, page float64) {
	var arg0 *C.GtkSpinButton

	arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))

	var arg1 C.double
	var arg2 C.double

	C.gtk_spin_button_get_increments(arg0, &arg1, &arg2)

	var step float64
	var page float64

	step = (float64)(arg1)
	page = (float64)(arg2)

	return step, page
}

// Numeric returns whether non-numeric text can be typed into the spin
// button. See gtk_spin_button_set_numeric().
func (s spinButton) Numeric() bool {
	var arg0 *C.GtkSpinButton

	arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))

	var cret C.gboolean

	cret = C.gtk_spin_button_get_numeric(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// Range gets the range allowed for @spin_button. See
// gtk_spin_button_set_range().
func (s spinButton) Range() (min float64, max float64) {
	var arg0 *C.GtkSpinButton

	arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))

	var arg1 C.double
	var arg2 C.double

	C.gtk_spin_button_get_range(arg0, &arg1, &arg2)

	var min float64
	var max float64

	min = (float64)(arg1)
	max = (float64)(arg2)

	return min, max
}

// SnapToTicks returns whether the values are corrected to the nearest step.
// See gtk_spin_button_set_snap_to_ticks().
func (s spinButton) SnapToTicks() bool {
	var arg0 *C.GtkSpinButton

	arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))

	var cret C.gboolean

	cret = C.gtk_spin_button_get_snap_to_ticks(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// UpdatePolicy gets the update behavior of a spin button. See
// gtk_spin_button_set_update_policy().
func (s spinButton) UpdatePolicy() SpinButtonUpdatePolicy {
	var arg0 *C.GtkSpinButton

	arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))

	var cret C.GtkSpinButtonUpdatePolicy

	cret = C.gtk_spin_button_get_update_policy(arg0)

	var spinButtonUpdatePolicy SpinButtonUpdatePolicy

	spinButtonUpdatePolicy = SpinButtonUpdatePolicy(cret)

	return spinButtonUpdatePolicy
}

// Value: get the value in the @spin_button.
func (s spinButton) Value() float64 {
	var arg0 *C.GtkSpinButton

	arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))

	var cret C.double

	cret = C.gtk_spin_button_get_value(arg0)

	var gdouble float64

	gdouble = (float64)(cret)

	return gdouble
}

// ValueAsInt: get the value @spin_button represented as an integer.
func (s spinButton) ValueAsInt() int {
	var arg0 *C.GtkSpinButton

	arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))

	var cret C.int

	cret = C.gtk_spin_button_get_value_as_int(arg0)

	var gint int

	gint = (int)(cret)

	return gint
}

// Wrap returns whether the spin button’s value wraps around to the opposite
// limit when the upper or lower limit of the range is exceeded. See
// gtk_spin_button_set_wrap().
func (s spinButton) Wrap() bool {
	var arg0 *C.GtkSpinButton

	arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))

	var cret C.gboolean

	cret = C.gtk_spin_button_get_wrap(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// SetAdjustment replaces the Adjustment associated with @spin_button.
func (s spinButton) SetAdjustment(adjustment Adjustment) {
	var arg0 *C.GtkSpinButton
	var arg1 *C.GtkAdjustment

	arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GtkAdjustment)(unsafe.Pointer(adjustment.Native()))

	C.gtk_spin_button_set_adjustment(arg0, arg1)
}

// SetClimbRate sets the acceleration rate for repeated changes when you
// hold down a button or key.
func (s spinButton) SetClimbRate(climbRate float64) {
	var arg0 *C.GtkSpinButton
	var arg1 C.double

	arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))
	arg1 = C.double(climbRate)

	C.gtk_spin_button_set_climb_rate(arg0, arg1)
}

// SetDigits: set the precision to be displayed by @spin_button. Up to 20
// digit precision is allowed.
func (s spinButton) SetDigits(digits uint) {
	var arg0 *C.GtkSpinButton
	var arg1 C.guint

	arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))
	arg1 = C.guint(digits)

	C.gtk_spin_button_set_digits(arg0, arg1)
}

// SetIncrements sets the step and page increments for spin_button. This
// affects how quickly the value changes when the spin button’s arrows are
// activated.
func (s spinButton) SetIncrements(step float64, page float64) {
	var arg0 *C.GtkSpinButton
	var arg1 C.double
	var arg2 C.double

	arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))
	arg1 = C.double(step)
	arg2 = C.double(page)

	C.gtk_spin_button_set_increments(arg0, arg1, arg2)
}

// SetNumeric sets the flag that determines if non-numeric text can be typed
// into the spin button.
func (s spinButton) SetNumeric(numeric bool) {
	var arg0 *C.GtkSpinButton
	var arg1 C.gboolean

	arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))
	if numeric {
		arg1 = C.gboolean(1)
	}

	C.gtk_spin_button_set_numeric(arg0, arg1)
}

// SetRange sets the minimum and maximum allowable values for @spin_button.
//
// If the current value is outside this range, it will be adjusted to fit
// within the range, otherwise it will remain unchanged.
func (s spinButton) SetRange(min float64, max float64) {
	var arg0 *C.GtkSpinButton
	var arg1 C.double
	var arg2 C.double

	arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))
	arg1 = C.double(min)
	arg2 = C.double(max)

	C.gtk_spin_button_set_range(arg0, arg1, arg2)
}

// SetSnapToTicks sets the policy as to whether values are corrected to the
// nearest step increment when a spin button is activated after providing an
// invalid value.
func (s spinButton) SetSnapToTicks(snapToTicks bool) {
	var arg0 *C.GtkSpinButton
	var arg1 C.gboolean

	arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))
	if snapToTicks {
		arg1 = C.gboolean(1)
	}

	C.gtk_spin_button_set_snap_to_ticks(arg0, arg1)
}

// SetUpdatePolicy sets the update behavior of a spin button. This
// determines whether the spin button is always updated or only when a valid
// value is set.
func (s spinButton) SetUpdatePolicy(policy SpinButtonUpdatePolicy) {
	var arg0 *C.GtkSpinButton
	var arg1 C.GtkSpinButtonUpdatePolicy

	arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))
	arg1 = (C.GtkSpinButtonUpdatePolicy)(policy)

	C.gtk_spin_button_set_update_policy(arg0, arg1)
}

// SetValue sets the value of @spin_button.
func (s spinButton) SetValue(value float64) {
	var arg0 *C.GtkSpinButton
	var arg1 C.double

	arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))
	arg1 = C.double(value)

	C.gtk_spin_button_set_value(arg0, arg1)
}

// SetWrap sets the flag that determines if a spin button value wraps around
// to the opposite limit when the upper or lower limit of the range is
// exceeded.
func (s spinButton) SetWrap(wrap bool) {
	var arg0 *C.GtkSpinButton
	var arg1 C.gboolean

	arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))
	if wrap {
		arg1 = C.gboolean(1)
	}

	C.gtk_spin_button_set_wrap(arg0, arg1)
}

// Spin: increment or decrement a spin button’s value in a specified
// direction by a specified amount.
func (s spinButton) Spin(direction SpinType, increment float64) {
	var arg0 *C.GtkSpinButton
	var arg1 C.GtkSpinType
	var arg2 C.double

	arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))
	arg1 = (C.GtkSpinType)(direction)
	arg2 = C.double(increment)

	C.gtk_spin_button_spin(arg0, arg1, arg2)
}

// Update: manually force an update of the spin button.
func (s spinButton) Update() {
	var arg0 *C.GtkSpinButton

	arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))

	C.gtk_spin_button_update(arg0)
}

// Spinner: a GtkSpinner widget displays an icon-size spinning animation. It is
// often used as an alternative to a ProgressBar for displaying indefinite
// activity, instead of actual progress.
//
// To start the animation, use gtk_spinner_start(), to stop it use
// gtk_spinner_stop().
//
//
// CSS nodes
//
// GtkSpinner has a single CSS node with the name spinner. When the animation is
// active, the :checked pseudoclass is added to this node.
type Spinner interface {
	Widget
	Accessible
	Buildable
	ConstraintTarget

	// Spinning returns whether the spinner is spinning.
	Spinning() bool
	// SetSpinning sets the activity of the spinner.
	SetSpinning(spinning bool)
	// Start starts the animation of the spinner.
	Start()
	// Stop stops the animation of the spinner.
	Stop()
}

// spinner implements the Spinner interface.
type spinner struct {
	Widget
	Accessible
	Buildable
	ConstraintTarget
}

var _ Spinner = (*spinner)(nil)

// WrapSpinner wraps a GObject to the right type. It is
// primarily used internally.
func WrapSpinner(obj *externglib.Object) Spinner {
	return Spinner{
		Widget:           WrapWidget(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
	}
}

func marshalSpinner(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSpinner(obj), nil
}

// NewSpinner constructs a class Spinner.
func NewSpinner() Spinner {
	var cret C.GtkSpinner

	cret = C.gtk_spinner_new()

	var spinner Spinner

	spinner = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Spinner)

	return spinner
}

// Spinning returns whether the spinner is spinning.
func (s spinner) Spinning() bool {
	var arg0 *C.GtkSpinner

	arg0 = (*C.GtkSpinner)(unsafe.Pointer(s.Native()))

	var cret C.gboolean

	cret = C.gtk_spinner_get_spinning(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// SetSpinning sets the activity of the spinner.
func (s spinner) SetSpinning(spinning bool) {
	var arg0 *C.GtkSpinner
	var arg1 C.gboolean

	arg0 = (*C.GtkSpinner)(unsafe.Pointer(s.Native()))
	if spinning {
		arg1 = C.gboolean(1)
	}

	C.gtk_spinner_set_spinning(arg0, arg1)
}

// Start starts the animation of the spinner.
func (s spinner) Start() {
	var arg0 *C.GtkSpinner

	arg0 = (*C.GtkSpinner)(unsafe.Pointer(s.Native()))

	C.gtk_spinner_start(arg0)
}

// Stop stops the animation of the spinner.
func (s spinner) Stop() {
	var arg0 *C.GtkSpinner

	arg0 = (*C.GtkSpinner)(unsafe.Pointer(s.Native()))

	C.gtk_spinner_stop(arg0)
}

// Stack: the GtkStack widget is a container which only shows one of its
// children at a time. In contrast to GtkNotebook, GtkStack does not provide a
// means for users to change the visible child. Instead, the StackSwitcher
// widget can be used with GtkStack to provide this functionality.
//
// Transitions between pages can be animated as slides or fades. This can be
// controlled with gtk_stack_set_transition_type(). These animations respect the
// Settings:gtk-enable-animations setting.
//
// GtkStack maintains a StackPage object for each added child, which holds
// additional per-child properties. You obtain the StackPage for a child with
// gtk_stack_get_page().
//
//
// GtkStack as GtkBuildable
//
// To set child-specific properties in a .ui file, create GtkStackPage objects
// explicitly, and set the child widget as a property on it:
//
//    <object class="GtkStack" id="stack">
//      <child>
//        <object class="GtkStackPage">
//          <property name="name">page1</property>
//          <property name="title">In the beginning…</property>
//          <property name="child">
//            <object class="GtkLabel">
//              <property name="label">It was dark</property>
//            </object>
//          </property>
//        </object>
//      </child>
//
//
// CSS nodes
//
// GtkStack has a single CSS node named stack.
//
//
// Accessibility
//
// GtkStack uses the K_ACCESSIBLE_ROLE_TAB_PANEL for the stack pages, which are
// the accessible parent objects of the child widgets.
type Stack interface {
	Widget
	Accessible
	Buildable
	ConstraintTarget

	// AddChild adds a child to @stack.
	AddChild(child Widget) StackPage
	// AddNamed adds a child to @stack. The child is identified by the @name.
	AddNamed(child Widget, name string) StackPage
	// AddTitled adds a child to @stack. The child is identified by the @name.
	// The @title will be used by StackSwitcher to represent @child in a tab
	// bar, so it should be short.
	AddTitled(child Widget, name string, title string) StackPage
	// ChildByName finds the child of the Stack with the name given as the
	// argument. Returns nil if there is no child with this name.
	ChildByName(name string) Widget
	// Hhomogeneous gets whether @stack is horizontally homogeneous. See
	// gtk_stack_set_hhomogeneous().
	Hhomogeneous() bool
	// InterpolateSize returns whether the Stack is set up to interpolate
	// between the sizes of children on page switch.
	InterpolateSize() bool
	// Page returns the StackPage object for @child.
	Page(child Widget) StackPage
	// Pages returns a Model that contains the pages of the stack, and can be
	// used to keep an up-to-date view. The model also implements SelectionModel
	// and can be used to track and modify the visible page.
	Pages() SelectionModel
	// TransitionDuration returns the amount of time (in milliseconds) that
	// transitions between pages in @stack will take.
	TransitionDuration() uint
	// TransitionRunning returns whether the @stack is currently in a transition
	// from one page to another.
	TransitionRunning() bool
	// TransitionType gets the type of animation that will be used for
	// transitions between pages in @stack.
	TransitionType() StackTransitionType
	// Vhomogeneous gets whether @stack is vertically homogeneous. See
	// gtk_stack_set_vhomogeneous().
	Vhomogeneous() bool
	// VisibleChild gets the currently visible child of @stack, or nil if there
	// are no visible children.
	VisibleChild() Widget
	// VisibleChildName returns the name of the currently visible child of
	// @stack, or nil if there is no visible child.
	VisibleChildName() string
	// Remove removes a child widget from @stack.
	Remove(child Widget)
	// SetHhomogeneous sets the Stack to be horizontally homogeneous or not. If
	// it is homogeneous, the Stack will request the same width for all its
	// children. If it isn't, the stack may change width when a different child
	// becomes visible.
	SetHhomogeneous(hhomogeneous bool)
	// SetInterpolateSize sets whether or not @stack will interpolate its size
	// when changing the visible child. If the Stack:interpolate-size property
	// is set to true, @stack will interpolate its size between the current one
	// and the one it'll take after changing the visible child, according to the
	// set transition duration.
	SetInterpolateSize(interpolateSize bool)
	// SetTransitionDuration sets the duration that transitions between pages in
	// @stack will take.
	SetTransitionDuration(duration uint)
	// SetTransitionType sets the type of animation that will be used for
	// transitions between pages in @stack. Available types include various
	// kinds of fades and slides.
	//
	// The transition type can be changed without problems at runtime, so it is
	// possible to change the animation based on the page that is about to
	// become current.
	SetTransitionType(transition StackTransitionType)
	// SetVhomogeneous sets the Stack to be vertically homogeneous or not. If it
	// is homogeneous, the Stack will request the same height for all its
	// children. If it isn't, the stack may change height when a different child
	// becomes visible.
	SetVhomogeneous(vhomogeneous bool)
	// SetVisibleChild makes @child the visible child of @stack.
	//
	// If @child is different from the currently visible child, the transition
	// between the two will be animated with the current transition type of
	// @stack.
	//
	// Note that the @child widget has to be visible itself (see
	// gtk_widget_show()) in order to become the visible child of @stack.
	SetVisibleChild(child Widget)
	// SetVisibleChildFull makes the child with the given name visible.
	//
	// Note that the child widget has to be visible itself (see
	// gtk_widget_show()) in order to become the visible child of @stack.
	SetVisibleChildFull(name string, transition StackTransitionType)
	// SetVisibleChildName makes the child with the given name visible.
	//
	// If @child is different from the currently visible child, the transition
	// between the two will be animated with the current transition type of
	// @stack.
	//
	// Note that the child widget has to be visible itself (see
	// gtk_widget_show()) in order to become the visible child of @stack.
	SetVisibleChildName(name string)
}

// stack implements the Stack interface.
type stack struct {
	Widget
	Accessible
	Buildable
	ConstraintTarget
}

var _ Stack = (*stack)(nil)

// WrapStack wraps a GObject to the right type. It is
// primarily used internally.
func WrapStack(obj *externglib.Object) Stack {
	return Stack{
		Widget:           WrapWidget(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
	}
}

func marshalStack(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapStack(obj), nil
}

// NewStack constructs a class Stack.
func NewStack() Stack {
	var cret C.GtkStack

	cret = C.gtk_stack_new()

	var stack Stack

	stack = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Stack)

	return stack
}

// AddChild adds a child to @stack.
func (s stack) AddChild(child Widget) StackPage {
	var arg0 *C.GtkStack
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	var cret *C.GtkStackPage

	cret = C.gtk_stack_add_child(arg0, arg1)

	var stackPage StackPage

	stackPage = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(StackPage)

	return stackPage
}

// AddNamed adds a child to @stack. The child is identified by the @name.
func (s stack) AddNamed(child Widget, name string) StackPage {
	var arg0 *C.GtkStack
	var arg1 *C.GtkWidget
	var arg2 *C.char

	arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	arg2 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(arg2))

	var cret *C.GtkStackPage

	cret = C.gtk_stack_add_named(arg0, arg1, arg2)

	var stackPage StackPage

	stackPage = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(StackPage)

	return stackPage
}

// AddTitled adds a child to @stack. The child is identified by the @name.
// The @title will be used by StackSwitcher to represent @child in a tab
// bar, so it should be short.
func (s stack) AddTitled(child Widget, name string, title string) StackPage {
	var arg0 *C.GtkStack
	var arg1 *C.GtkWidget
	var arg2 *C.char
	var arg3 *C.char

	arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	arg2 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.char)(C.CString(title))
	defer C.free(unsafe.Pointer(arg3))

	var cret *C.GtkStackPage

	cret = C.gtk_stack_add_titled(arg0, arg1, arg2, arg3)

	var stackPage StackPage

	stackPage = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(StackPage)

	return stackPage
}

// ChildByName finds the child of the Stack with the name given as the
// argument. Returns nil if there is no child with this name.
func (s stack) ChildByName(name string) Widget {
	var arg0 *C.GtkStack
	var arg1 *C.char

	arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))
	arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	var cret *C.GtkWidget

	cret = C.gtk_stack_get_child_by_name(arg0, arg1)

	var widget Widget

	widget = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Widget)

	return widget
}

// Hhomogeneous gets whether @stack is horizontally homogeneous. See
// gtk_stack_set_hhomogeneous().
func (s stack) Hhomogeneous() bool {
	var arg0 *C.GtkStack

	arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))

	var cret C.gboolean

	cret = C.gtk_stack_get_hhomogeneous(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// InterpolateSize returns whether the Stack is set up to interpolate
// between the sizes of children on page switch.
func (s stack) InterpolateSize() bool {
	var arg0 *C.GtkStack

	arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))

	var cret C.gboolean

	cret = C.gtk_stack_get_interpolate_size(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// Page returns the StackPage object for @child.
func (s stack) Page(child Widget) StackPage {
	var arg0 *C.GtkStack
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	var cret *C.GtkStackPage

	cret = C.gtk_stack_get_page(arg0, arg1)

	var stackPage StackPage

	stackPage = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(StackPage)

	return stackPage
}

// Pages returns a Model that contains the pages of the stack, and can be
// used to keep an up-to-date view. The model also implements SelectionModel
// and can be used to track and modify the visible page.
func (s stack) Pages() SelectionModel {
	var arg0 *C.GtkStack

	arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))

	var cret *C.GtkSelectionModel

	cret = C.gtk_stack_get_pages(arg0)

	var selectionModel SelectionModel

	selectionModel = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(SelectionModel)

	return selectionModel
}

// TransitionDuration returns the amount of time (in milliseconds) that
// transitions between pages in @stack will take.
func (s stack) TransitionDuration() uint {
	var arg0 *C.GtkStack

	arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))

	var cret C.guint

	cret = C.gtk_stack_get_transition_duration(arg0)

	var guint uint

	guint = (uint)(cret)

	return guint
}

// TransitionRunning returns whether the @stack is currently in a transition
// from one page to another.
func (s stack) TransitionRunning() bool {
	var arg0 *C.GtkStack

	arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))

	var cret C.gboolean

	cret = C.gtk_stack_get_transition_running(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// TransitionType gets the type of animation that will be used for
// transitions between pages in @stack.
func (s stack) TransitionType() StackTransitionType {
	var arg0 *C.GtkStack

	arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))

	var cret C.GtkStackTransitionType

	cret = C.gtk_stack_get_transition_type(arg0)

	var stackTransitionType StackTransitionType

	stackTransitionType = StackTransitionType(cret)

	return stackTransitionType
}

// Vhomogeneous gets whether @stack is vertically homogeneous. See
// gtk_stack_set_vhomogeneous().
func (s stack) Vhomogeneous() bool {
	var arg0 *C.GtkStack

	arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))

	var cret C.gboolean

	cret = C.gtk_stack_get_vhomogeneous(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// VisibleChild gets the currently visible child of @stack, or nil if there
// are no visible children.
func (s stack) VisibleChild() Widget {
	var arg0 *C.GtkStack

	arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))

	var cret *C.GtkWidget

	cret = C.gtk_stack_get_visible_child(arg0)

	var widget Widget

	widget = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Widget)

	return widget
}

// VisibleChildName returns the name of the currently visible child of
// @stack, or nil if there is no visible child.
func (s stack) VisibleChildName() string {
	var arg0 *C.GtkStack

	arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))

	var cret *C.char

	cret = C.gtk_stack_get_visible_child_name(arg0)

	var utf8 string

	utf8 = C.GoString(cret)

	return utf8
}

// Remove removes a child widget from @stack.
func (s stack) Remove(child Widget) {
	var arg0 *C.GtkStack
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_stack_remove(arg0, arg1)
}

// SetHhomogeneous sets the Stack to be horizontally homogeneous or not. If
// it is homogeneous, the Stack will request the same width for all its
// children. If it isn't, the stack may change width when a different child
// becomes visible.
func (s stack) SetHhomogeneous(hhomogeneous bool) {
	var arg0 *C.GtkStack
	var arg1 C.gboolean

	arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))
	if hhomogeneous {
		arg1 = C.gboolean(1)
	}

	C.gtk_stack_set_hhomogeneous(arg0, arg1)
}

// SetInterpolateSize sets whether or not @stack will interpolate its size
// when changing the visible child. If the Stack:interpolate-size property
// is set to true, @stack will interpolate its size between the current one
// and the one it'll take after changing the visible child, according to the
// set transition duration.
func (s stack) SetInterpolateSize(interpolateSize bool) {
	var arg0 *C.GtkStack
	var arg1 C.gboolean

	arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))
	if interpolateSize {
		arg1 = C.gboolean(1)
	}

	C.gtk_stack_set_interpolate_size(arg0, arg1)
}

// SetTransitionDuration sets the duration that transitions between pages in
// @stack will take.
func (s stack) SetTransitionDuration(duration uint) {
	var arg0 *C.GtkStack
	var arg1 C.guint

	arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))
	arg1 = C.guint(duration)

	C.gtk_stack_set_transition_duration(arg0, arg1)
}

// SetTransitionType sets the type of animation that will be used for
// transitions between pages in @stack. Available types include various
// kinds of fades and slides.
//
// The transition type can be changed without problems at runtime, so it is
// possible to change the animation based on the page that is about to
// become current.
func (s stack) SetTransitionType(transition StackTransitionType) {
	var arg0 *C.GtkStack
	var arg1 C.GtkStackTransitionType

	arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))
	arg1 = (C.GtkStackTransitionType)(transition)

	C.gtk_stack_set_transition_type(arg0, arg1)
}

// SetVhomogeneous sets the Stack to be vertically homogeneous or not. If it
// is homogeneous, the Stack will request the same height for all its
// children. If it isn't, the stack may change height when a different child
// becomes visible.
func (s stack) SetVhomogeneous(vhomogeneous bool) {
	var arg0 *C.GtkStack
	var arg1 C.gboolean

	arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))
	if vhomogeneous {
		arg1 = C.gboolean(1)
	}

	C.gtk_stack_set_vhomogeneous(arg0, arg1)
}

// SetVisibleChild makes @child the visible child of @stack.
//
// If @child is different from the currently visible child, the transition
// between the two will be animated with the current transition type of
// @stack.
//
// Note that the @child widget has to be visible itself (see
// gtk_widget_show()) in order to become the visible child of @stack.
func (s stack) SetVisibleChild(child Widget) {
	var arg0 *C.GtkStack
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_stack_set_visible_child(arg0, arg1)
}

// SetVisibleChildFull makes the child with the given name visible.
//
// Note that the child widget has to be visible itself (see
// gtk_widget_show()) in order to become the visible child of @stack.
func (s stack) SetVisibleChildFull(name string, transition StackTransitionType) {
	var arg0 *C.GtkStack
	var arg1 *C.char
	var arg2 C.GtkStackTransitionType

	arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))
	arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (C.GtkStackTransitionType)(transition)

	C.gtk_stack_set_visible_child_full(arg0, arg1, arg2)
}

// SetVisibleChildName makes the child with the given name visible.
//
// If @child is different from the currently visible child, the transition
// between the two will be animated with the current transition type of
// @stack.
//
// Note that the child widget has to be visible itself (see
// gtk_widget_show()) in order to become the visible child of @stack.
func (s stack) SetVisibleChildName(name string) {
	var arg0 *C.GtkStack
	var arg1 *C.char

	arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))
	arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_stack_set_visible_child_name(arg0, arg1)
}

type StackPage interface {
	gextras.Objector
	Accessible

	// Child returns the stack child to which @self belongs.
	Child() Widget
	// IconName returns the current value of the StackPage:icon-name property.
	IconName() string
	// Name returns the current value of the StackPage:name property.
	Name() string
	// NeedsAttention returns the current value of the StackPage:needs-attention
	// property.
	NeedsAttention() bool
	// Title returns the current value of the StackPage:title property.
	Title() string
	// UseUnderline returns the current value of the StackPage:use-underline
	// property.
	UseUnderline() bool
	// Visible returns whether @page is visible in its Stack. This is
	// independent from the Widget:visible value of its Widget.
	Visible() bool
	// SetIconName sets the new value of the StackPage:icon-name property. See
	// also gtk_stack_page_get_icon_name()
	SetIconName(setting string)
	// SetName sets the new value of the StackPage:name property. See also
	// gtk_stack_page_get_name()
	SetName(setting string)
	// SetNeedsAttention sets the new value of the StackPage:needs-attention
	// property. See also gtk_stack_page_get_needs_attention()
	SetNeedsAttention(setting bool)
	// SetTitle sets the new value of the StackPage:title property. See also
	// gtk_stack_page_get_title()
	SetTitle(setting string)
	// SetUseUnderline sets the new value of the StackPage:use-underline
	// property. See also gtk_stack_page_get_use_underline()
	SetUseUnderline(setting bool)
	// SetVisible sets the new value of the StackPage:visible property to
	// @visible.
	SetVisible(visible bool)
}

// stackPage implements the StackPage interface.
type stackPage struct {
	gextras.Objector
	Accessible
}

var _ StackPage = (*stackPage)(nil)

// WrapStackPage wraps a GObject to the right type. It is
// primarily used internally.
func WrapStackPage(obj *externglib.Object) StackPage {
	return StackPage{
		Objector:   obj,
		Accessible: WrapAccessible(obj),
	}
}

func marshalStackPage(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapStackPage(obj), nil
}

// Child returns the stack child to which @self belongs.
func (s stackPage) Child() Widget {
	var arg0 *C.GtkStackPage

	arg0 = (*C.GtkStackPage)(unsafe.Pointer(s.Native()))

	var cret *C.GtkWidget

	cret = C.gtk_stack_page_get_child(arg0)

	var widget Widget

	widget = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Widget)

	return widget
}

// IconName returns the current value of the StackPage:icon-name property.
func (s stackPage) IconName() string {
	var arg0 *C.GtkStackPage

	arg0 = (*C.GtkStackPage)(unsafe.Pointer(s.Native()))

	var cret *C.char

	cret = C.gtk_stack_page_get_icon_name(arg0)

	var utf8 string

	utf8 = C.GoString(cret)

	return utf8
}

// Name returns the current value of the StackPage:name property.
func (s stackPage) Name() string {
	var arg0 *C.GtkStackPage

	arg0 = (*C.GtkStackPage)(unsafe.Pointer(s.Native()))

	var cret *C.char

	cret = C.gtk_stack_page_get_name(arg0)

	var utf8 string

	utf8 = C.GoString(cret)

	return utf8
}

// NeedsAttention returns the current value of the StackPage:needs-attention
// property.
func (s stackPage) NeedsAttention() bool {
	var arg0 *C.GtkStackPage

	arg0 = (*C.GtkStackPage)(unsafe.Pointer(s.Native()))

	var cret C.gboolean

	cret = C.gtk_stack_page_get_needs_attention(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// Title returns the current value of the StackPage:title property.
func (s stackPage) Title() string {
	var arg0 *C.GtkStackPage

	arg0 = (*C.GtkStackPage)(unsafe.Pointer(s.Native()))

	var cret *C.char

	cret = C.gtk_stack_page_get_title(arg0)

	var utf8 string

	utf8 = C.GoString(cret)

	return utf8
}

// UseUnderline returns the current value of the StackPage:use-underline
// property.
func (s stackPage) UseUnderline() bool {
	var arg0 *C.GtkStackPage

	arg0 = (*C.GtkStackPage)(unsafe.Pointer(s.Native()))

	var cret C.gboolean

	cret = C.gtk_stack_page_get_use_underline(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// Visible returns whether @page is visible in its Stack. This is
// independent from the Widget:visible value of its Widget.
func (s stackPage) Visible() bool {
	var arg0 *C.GtkStackPage

	arg0 = (*C.GtkStackPage)(unsafe.Pointer(s.Native()))

	var cret C.gboolean

	cret = C.gtk_stack_page_get_visible(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// SetIconName sets the new value of the StackPage:icon-name property. See
// also gtk_stack_page_get_icon_name()
func (s stackPage) SetIconName(setting string) {
	var arg0 *C.GtkStackPage
	var arg1 *C.char

	arg0 = (*C.GtkStackPage)(unsafe.Pointer(s.Native()))
	arg1 = (*C.char)(C.CString(setting))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_stack_page_set_icon_name(arg0, arg1)
}

// SetName sets the new value of the StackPage:name property. See also
// gtk_stack_page_get_name()
func (s stackPage) SetName(setting string) {
	var arg0 *C.GtkStackPage
	var arg1 *C.char

	arg0 = (*C.GtkStackPage)(unsafe.Pointer(s.Native()))
	arg1 = (*C.char)(C.CString(setting))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_stack_page_set_name(arg0, arg1)
}

// SetNeedsAttention sets the new value of the StackPage:needs-attention
// property. See also gtk_stack_page_get_needs_attention()
func (s stackPage) SetNeedsAttention(setting bool) {
	var arg0 *C.GtkStackPage
	var arg1 C.gboolean

	arg0 = (*C.GtkStackPage)(unsafe.Pointer(s.Native()))
	if setting {
		arg1 = C.gboolean(1)
	}

	C.gtk_stack_page_set_needs_attention(arg0, arg1)
}

// SetTitle sets the new value of the StackPage:title property. See also
// gtk_stack_page_get_title()
func (s stackPage) SetTitle(setting string) {
	var arg0 *C.GtkStackPage
	var arg1 *C.char

	arg0 = (*C.GtkStackPage)(unsafe.Pointer(s.Native()))
	arg1 = (*C.char)(C.CString(setting))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_stack_page_set_title(arg0, arg1)
}

// SetUseUnderline sets the new value of the StackPage:use-underline
// property. See also gtk_stack_page_get_use_underline()
func (s stackPage) SetUseUnderline(setting bool) {
	var arg0 *C.GtkStackPage
	var arg1 C.gboolean

	arg0 = (*C.GtkStackPage)(unsafe.Pointer(s.Native()))
	if setting {
		arg1 = C.gboolean(1)
	}

	C.gtk_stack_page_set_use_underline(arg0, arg1)
}

// SetVisible sets the new value of the StackPage:visible property to
// @visible.
func (s stackPage) SetVisible(visible bool) {
	var arg0 *C.GtkStackPage
	var arg1 C.gboolean

	arg0 = (*C.GtkStackPage)(unsafe.Pointer(s.Native()))
	if visible {
		arg1 = C.gboolean(1)
	}

	C.gtk_stack_page_set_visible(arg0, arg1)
}

// StackSidebar: a GtkStackSidebar enables you to quickly and easily provide a
// consistent "sidebar" object for your user interface.
//
// In order to use a GtkStackSidebar, you simply use a GtkStack to organize your
// UI flow, and add the sidebar to your sidebar area. You can use
// gtk_stack_sidebar_set_stack() to connect the StackSidebar to the Stack.
//
//
// CSS nodes
//
// GtkStackSidebar has a single CSS node with name stacksidebar and style class
// .sidebar.
//
// When circumstances require it, GtkStackSidebar adds the .needs-attention
// style class to the widgets representing the stack pages.
type StackSidebar interface {
	Widget
	Accessible
	Buildable
	ConstraintTarget

	// Stack retrieves the stack. See gtk_stack_sidebar_set_stack().
	Stack() Stack
	// SetStack: set the Stack associated with this StackSidebar.
	//
	// The sidebar widget will automatically update according to the order
	// (packing) and items within the given Stack.
	SetStack(stack Stack)
}

// stackSidebar implements the StackSidebar interface.
type stackSidebar struct {
	Widget
	Accessible
	Buildable
	ConstraintTarget
}

var _ StackSidebar = (*stackSidebar)(nil)

// WrapStackSidebar wraps a GObject to the right type. It is
// primarily used internally.
func WrapStackSidebar(obj *externglib.Object) StackSidebar {
	return StackSidebar{
		Widget:           WrapWidget(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
	}
}

func marshalStackSidebar(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapStackSidebar(obj), nil
}

// NewStackSidebar constructs a class StackSidebar.
func NewStackSidebar() StackSidebar {
	var cret C.GtkStackSidebar

	cret = C.gtk_stack_sidebar_new()

	var stackSidebar StackSidebar

	stackSidebar = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(StackSidebar)

	return stackSidebar
}

// Stack retrieves the stack. See gtk_stack_sidebar_set_stack().
func (s stackSidebar) Stack() Stack {
	var arg0 *C.GtkStackSidebar

	arg0 = (*C.GtkStackSidebar)(unsafe.Pointer(s.Native()))

	var cret *C.GtkStack

	cret = C.gtk_stack_sidebar_get_stack(arg0)

	var stack Stack

	stack = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Stack)

	return stack
}

// SetStack: set the Stack associated with this StackSidebar.
//
// The sidebar widget will automatically update according to the order
// (packing) and items within the given Stack.
func (s stackSidebar) SetStack(stack Stack) {
	var arg0 *C.GtkStackSidebar
	var arg1 *C.GtkStack

	arg0 = (*C.GtkStackSidebar)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GtkStack)(unsafe.Pointer(stack.Native()))

	C.gtk_stack_sidebar_set_stack(arg0, arg1)
}

// StackSwitcher: the GtkStackSwitcher widget acts as a controller for a Stack;
// it shows a row of buttons to switch between the various pages of the
// associated stack widget.
//
// All the content for the buttons comes from the child properties of the Stack;
// the button visibility in a StackSwitcher widget is controlled by the
// visibility of the child in the Stack.
//
// It is possible to associate multiple StackSwitcher widgets with the same
// Stack widget.
//
//
// CSS nodes
//
// GtkStackSwitcher has a single CSS node named stackswitcher and style class
// .stack-switcher.
//
// When circumstances require it, GtkStackSwitcher adds the .needs-attention
// style class to the widgets representing the stack pages.
//
//
// Accessibility
//
// GtkStackSwitcher uses the K_ACCESSIBLE_ROLE_TAB_LIST role and uses the
// K_ACCESSIBLE_ROLE_TAB for its buttons.
type StackSwitcher interface {
	Widget
	Accessible
	Buildable
	ConstraintTarget

	// Stack retrieves the stack. See gtk_stack_switcher_set_stack().
	Stack() Stack
	// SetStack sets the stack to control.
	SetStack(stack Stack)
}

// stackSwitcher implements the StackSwitcher interface.
type stackSwitcher struct {
	Widget
	Accessible
	Buildable
	ConstraintTarget
}

var _ StackSwitcher = (*stackSwitcher)(nil)

// WrapStackSwitcher wraps a GObject to the right type. It is
// primarily used internally.
func WrapStackSwitcher(obj *externglib.Object) StackSwitcher {
	return StackSwitcher{
		Widget:           WrapWidget(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
	}
}

func marshalStackSwitcher(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapStackSwitcher(obj), nil
}

// NewStackSwitcher constructs a class StackSwitcher.
func NewStackSwitcher() StackSwitcher {
	var cret C.GtkStackSwitcher

	cret = C.gtk_stack_switcher_new()

	var stackSwitcher StackSwitcher

	stackSwitcher = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(StackSwitcher)

	return stackSwitcher
}

// Stack retrieves the stack. See gtk_stack_switcher_set_stack().
func (s stackSwitcher) Stack() Stack {
	var arg0 *C.GtkStackSwitcher

	arg0 = (*C.GtkStackSwitcher)(unsafe.Pointer(s.Native()))

	var cret *C.GtkStack

	cret = C.gtk_stack_switcher_get_stack(arg0)

	var stack Stack

	stack = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Stack)

	return stack
}

// SetStack sets the stack to control.
func (s stackSwitcher) SetStack(stack Stack) {
	var arg0 *C.GtkStackSwitcher
	var arg1 *C.GtkStack

	arg0 = (*C.GtkStackSwitcher)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GtkStack)(unsafe.Pointer(stack.Native()))

	C.gtk_stack_switcher_set_stack(arg0, arg1)
}

// Statusbar: a Statusbar is usually placed along the bottom of an application's
// main Window. It may provide a regular commentary of the application's status
// (as is usually the case in a web browser, for example), or may be used to
// simply output a message when the status changes, (when an upload is complete
// in an FTP client, for example).
//
// Status bars in GTK+ maintain a stack of messages. The message at the top of
// the each bar’s stack is the one that will currently be displayed.
//
// Any messages added to a statusbar’s stack must specify a context id that is
// used to uniquely identify the source of a message. This context id can be
// generated by gtk_statusbar_get_context_id(), given a message and the
// statusbar that it will be added to. Note that messages are stored in a stack,
// and when choosing which message to display, the stack structure is adhered
// to, regardless of the context identifier of a message.
//
// One could say that a statusbar maintains one stack of messages for display
// purposes, but allows multiple message producers to maintain sub-stacks of the
// messages they produced (via context ids).
//
// Status bars are created using gtk_statusbar_new().
//
// Messages are added to the bar’s stack with gtk_statusbar_push().
//
// The message at the top of the stack can be removed using gtk_statusbar_pop().
// A message can be removed from anywhere in the stack if its message id was
// recorded at the time it was added. This is done using gtk_statusbar_remove().
//
//
// CSS node
//
// GtkStatusbar has a single CSS node with name statusbar.
type Statusbar interface {
	Widget
	Accessible
	Buildable
	ConstraintTarget

	// ContextID returns a new context identifier, given a description of the
	// actual context. Note that the description is not shown in the UI.
	ContextID(contextDescription string) uint
	// Pop removes the first message in the Statusbar’s stack with the given
	// context id.
	//
	// Note that this may not change the displayed message, if the message at
	// the top of the stack has a different context id.
	Pop(contextId uint)
	// Push pushes a new message onto a statusbar’s stack.
	Push(contextId uint, text string) uint
	// Remove forces the removal of a message from a statusbar’s stack. The
	// exact @context_id and @message_id must be specified.
	Remove(contextId uint, messageId uint)
	// RemoveAll forces the removal of all messages from a statusbar's stack
	// with the exact @context_id.
	RemoveAll(contextId uint)
}

// statusbar implements the Statusbar interface.
type statusbar struct {
	Widget
	Accessible
	Buildable
	ConstraintTarget
}

var _ Statusbar = (*statusbar)(nil)

// WrapStatusbar wraps a GObject to the right type. It is
// primarily used internally.
func WrapStatusbar(obj *externglib.Object) Statusbar {
	return Statusbar{
		Widget:           WrapWidget(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
	}
}

func marshalStatusbar(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapStatusbar(obj), nil
}

// NewStatusbar constructs a class Statusbar.
func NewStatusbar() Statusbar {
	var cret C.GtkStatusbar

	cret = C.gtk_statusbar_new()

	var statusbar Statusbar

	statusbar = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Statusbar)

	return statusbar
}

// ContextID returns a new context identifier, given a description of the
// actual context. Note that the description is not shown in the UI.
func (s statusbar) ContextID(contextDescription string) uint {
	var arg0 *C.GtkStatusbar
	var arg1 *C.char

	arg0 = (*C.GtkStatusbar)(unsafe.Pointer(s.Native()))
	arg1 = (*C.char)(C.CString(contextDescription))
	defer C.free(unsafe.Pointer(arg1))

	var cret C.guint

	cret = C.gtk_statusbar_get_context_id(arg0, arg1)

	var guint uint

	guint = (uint)(cret)

	return guint
}

// Pop removes the first message in the Statusbar’s stack with the given
// context id.
//
// Note that this may not change the displayed message, if the message at
// the top of the stack has a different context id.
func (s statusbar) Pop(contextId uint) {
	var arg0 *C.GtkStatusbar
	var arg1 C.guint

	arg0 = (*C.GtkStatusbar)(unsafe.Pointer(s.Native()))
	arg1 = C.guint(contextId)

	C.gtk_statusbar_pop(arg0, arg1)
}

// Push pushes a new message onto a statusbar’s stack.
func (s statusbar) Push(contextId uint, text string) uint {
	var arg0 *C.GtkStatusbar
	var arg1 C.guint
	var arg2 *C.char

	arg0 = (*C.GtkStatusbar)(unsafe.Pointer(s.Native()))
	arg1 = C.guint(contextId)
	arg2 = (*C.char)(C.CString(text))
	defer C.free(unsafe.Pointer(arg2))

	var cret C.guint

	cret = C.gtk_statusbar_push(arg0, arg1, arg2)

	var guint uint

	guint = (uint)(cret)

	return guint
}

// Remove forces the removal of a message from a statusbar’s stack. The
// exact @context_id and @message_id must be specified.
func (s statusbar) Remove(contextId uint, messageId uint) {
	var arg0 *C.GtkStatusbar
	var arg1 C.guint
	var arg2 C.guint

	arg0 = (*C.GtkStatusbar)(unsafe.Pointer(s.Native()))
	arg1 = C.guint(contextId)
	arg2 = C.guint(messageId)

	C.gtk_statusbar_remove(arg0, arg1, arg2)
}

// RemoveAll forces the removal of all messages from a statusbar's stack
// with the exact @context_id.
func (s statusbar) RemoveAll(contextId uint) {
	var arg0 *C.GtkStatusbar
	var arg1 C.guint

	arg0 = (*C.GtkStatusbar)(unsafe.Pointer(s.Native()))
	arg1 = C.guint(contextId)

	C.gtk_statusbar_remove_all(arg0, arg1)
}

// Switch is a widget that has two states: on or off. The user can control which
// state should be active by clicking the empty area, or by dragging the handle.
//
// GtkSwitch can also handle situations where the underlying state changes with
// a delay. See Switch::state-set for details.
//
// CSS nodes
//
//    switch
//    ├── label
//    ├── label
//    ╰── slider
//
// GtkSwitch has four css nodes, the main node with the name switch and subnodes
// for the slider and the on and off labels. Neither of them is using any style
// classes.
//
//
// Accessibility
//
// GtkSwitch uses the K_ACCESSIBLE_ROLE_SWITCH role.
type Switch interface {
	Widget
	Accessible
	Actionable
	Buildable
	ConstraintTarget

	// Active gets whether the Switch is in its “on” or “off” state.
	Active() bool
	// State gets the underlying state of the Switch.
	State() bool
	// SetActive changes the state of @self to the desired one.
	SetActive(isActive bool)
	// SetState sets the underlying state of the Switch.
	//
	// Normally, this is the same as Switch:active, unless the switch is set up
	// for delayed state changes. This function is typically called from a
	// Switch::state-set signal handler.
	//
	// See Switch::state-set for details.
	SetState(state bool)
}

// _switch implements the Switch interface.
type _switch struct {
	Widget
	Accessible
	Actionable
	Buildable
	ConstraintTarget
}

var _ Switch = (*_switch)(nil)

// WrapSwitch wraps a GObject to the right type. It is
// primarily used internally.
func WrapSwitch(obj *externglib.Object) Switch {
	return Switch{
		Widget:           WrapWidget(obj),
		Accessible:       WrapAccessible(obj),
		Actionable:       WrapActionable(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
	}
}

func marshalSwitch(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSwitch(obj), nil
}

// NewSwitch constructs a class Switch.
func NewSwitch() Switch {
	var cret C.GtkSwitch

	cret = C.gtk_switch_new()

	var _switch Switch

	_switch = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Switch)

	return _switch
}

// Active gets whether the Switch is in its “on” or “off” state.
func (s _switch) Active() bool {
	var arg0 *C.GtkSwitch

	arg0 = (*C.GtkSwitch)(unsafe.Pointer(s.Native()))

	var cret C.gboolean

	cret = C.gtk_switch_get_active(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// State gets the underlying state of the Switch.
func (s _switch) State() bool {
	var arg0 *C.GtkSwitch

	arg0 = (*C.GtkSwitch)(unsafe.Pointer(s.Native()))

	var cret C.gboolean

	cret = C.gtk_switch_get_state(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// SetActive changes the state of @self to the desired one.
func (s _switch) SetActive(isActive bool) {
	var arg0 *C.GtkSwitch
	var arg1 C.gboolean

	arg0 = (*C.GtkSwitch)(unsafe.Pointer(s.Native()))
	if isActive {
		arg1 = C.gboolean(1)
	}

	C.gtk_switch_set_active(arg0, arg1)
}

// SetState sets the underlying state of the Switch.
//
// Normally, this is the same as Switch:active, unless the switch is set up
// for delayed state changes. This function is typically called from a
// Switch::state-set signal handler.
//
// See Switch::state-set for details.
func (s _switch) SetState(state bool) {
	var arg0 *C.GtkSwitch
	var arg1 C.gboolean

	arg0 = (*C.GtkSwitch)(unsafe.Pointer(s.Native()))
	if state {
		arg1 = C.gboolean(1)
	}

	C.gtk_switch_set_state(arg0, arg1)
}

// Text: the Text widget is a single line text entry widget.
//
// A fairly large set of key bindings are supported by default. If the entered
// text is longer than the allocation of the widget, the widget will scroll so
// that the cursor position is visible.
//
// When using an entry for passwords and other sensitive information, it can be
// put into “password mode” using gtk_text_set_visibility(). In this mode,
// entered text is displayed using a “invisible” character. By default, GTK
// picks the best invisible character that is available in the current font, but
// it can be changed with gtk_text_set_invisible_char().
//
// If you are looking to add icons or progress display in an entry, look at
// Entry. There other alternatives for more specialized use cases, such as
// SearchEntry.
//
// If you need multi-line editable text, look at TextView.
//
// CSS nodes
//
//    text[.read-only]
//    ├── placeholder
//    ├── undershoot.left
//    ├── undershoot.right
//    ├── [selection]
//    ├── [block-cursor]
//    ╰── [window.popup]
//
// GtkText has a main node with the name text. Depending on the properties of
// the widget, the .read-only style class may appear.
//
// When the entry has a selection, it adds a subnode with the name selection.
//
// When the entry is in overwrite mode, it adds a subnode with the name
// block-cursor that determines how the block cursor is drawn.
//
// The CSS node for a context menu is added as a subnode below text as well.
//
// The undershoot nodes are used to draw the underflow indication when content
// is scrolled out of view. These nodes get the .left and .right style classes
// added depending on where the indication is drawn.
//
// When touch is used and touch selection handles are shown, they are using CSS
// nodes with name cursor-handle. They get the .top or .bottom style class
// depending on where they are shown in relation to the selection. If there is
// just a single handle for the text cursor, it gets the style class
// .insertion-cursor.
//
//
// Accessibility
//
// GtkText uses the K_ACCESSIBLE_ROLE_NONE role, which causes it to be skipped
// for accessibility. This is because GtkText is expected to be used as a
// delegate for a Editable implementation that will be represented to
// accessibility.
type Text interface {
	Widget
	Accessible
	Buildable
	ConstraintTarget
	Editable

	// ActivatesDefault retrieves the value set by
	// gtk_text_set_activates_default().
	ActivatesDefault() bool
	// Attributes gets the attribute list that was set on the self using
	// gtk_text_set_attributes(), if any.
	Attributes() *pango.AttrList
	// Buffer: get the EntryBuffer object which holds the text for this self.
	Buffer() EntryBuffer
	// EnableEmojiCompletion returns whether Emoji completion is enabled for
	// this GtkText widget.
	EnableEmojiCompletion() bool
	// ExtraMenu gets the menu model set with gtk_text_set_extra_menu().
	ExtraMenu() gio.MenuModel
	// InputHints gets the value of the Text:input-hints property.
	InputHints() InputHints
	// InputPurpose gets the value of the Text:input-purpose property.
	InputPurpose() InputPurpose
	// InvisibleChar retrieves the character displayed in place of the real
	// characters for entries with visibility set to false. Note that GTK does
	// not compute this value unless it needs it, so the value returned by this
	// function is not very useful unless it has been explicitly set with
	// gtk_text_set_invisible_char()
	InvisibleChar() uint32
	// MaxLength retrieves the maximum allowed length of the text in @self. See
	// gtk_text_set_max_length().
	//
	// This is equivalent to getting @self's EntryBuffer and calling
	// gtk_entry_buffer_get_max_length() on it.
	MaxLength() int
	// OverwriteMode gets the value set by gtk_text_set_overwrite_mode().
	OverwriteMode() bool
	// PlaceholderText retrieves the text that will be displayed when @self is
	// empty and unfocused
	PlaceholderText() string
	// PropagateTextWidth returns whether the Text will grow and shrink with the
	// content.
	PropagateTextWidth() bool
	// Tabs gets the tabstops that were set on the self using
	// gtk_text_set_tabs(), if any.
	Tabs() *pango.TabArray
	// TextLength retrieves the current length of the text in @self.
	//
	// This is equivalent to getting @self's EntryBuffer and calling
	// gtk_entry_buffer_get_length() on it.
	TextLength() uint16
	// TruncateMultiline returns whether the Text will truncate multi-line text
	// that is pasted into the widget
	TruncateMultiline() bool
	// Visibility retrieves whether the text in @self is visible. See
	// gtk_text_set_visibility().
	Visibility() bool
	// GrabFocusWithoutSelecting causes @self to have keyboard focus.
	//
	// It behaves like gtk_widget_grab_focus(), except that it doesn't select
	// the contents of @self. You only want to call this on some special entries
	// which the user usually doesn't want to replace all text in, such as
	// search-as-you-type entries.
	GrabFocusWithoutSelecting() bool
	// SetActivatesDefault: if @activates is true, pressing Enter in the @self
	// will activate the default widget for the window containing the self. This
	// usually means that the dialog box containing the self will be closed,
	// since the default widget is usually one of the dialog buttons.
	SetActivatesDefault(activates bool)
	// SetAttributes sets a AttrList; the attributes in the list are applied to
	// the text.
	SetAttributes(attrs *pango.AttrList)
	// SetBuffer: set the EntryBuffer object which holds the text for this
	// widget.
	SetBuffer(buffer EntryBuffer)
	// SetEnableEmojiCompletion sets whether Emoji completion is enabled. If it
	// is, typing ':', followed by a recognized keyword, will pop up a window
	// with suggested Emojis matching the keyword.
	SetEnableEmojiCompletion(enableEmojiCompletion bool)
	// SetExtraMenu sets a menu model to add when constructing the context menu
	// for @self.
	SetExtraMenu(model gio.MenuModel)
	// SetInputHints sets the Text:input-hints property, which allows input
	// methods to fine-tune their behaviour.
	SetInputHints(hints InputHints)
	// SetInputPurpose sets the Text:input-purpose property which can be used by
	// on-screen keyboards and other input methods to adjust their behaviour.
	SetInputPurpose(purpose InputPurpose)
	// SetInvisibleChar sets the character to use in place of the actual text
	// when gtk_text_set_visibility() has been called to set text visibility to
	// false. i.e. this is the character used in “password mode” to show the
	// user how many characters have been typed.
	//
	// By default, GTK picks the best invisible char available in the current
	// font. If you set the invisible char to 0, then the user will get no
	// feedback at all; there will be no text on the screen as they type.
	SetInvisibleChar(ch uint32)
	// SetMaxLength sets the maximum allowed length of the contents of the
	// widget.
	//
	// If the current contents are longer than the given length, then they will
	// be truncated to fit.
	//
	// This is equivalent to getting @self's EntryBuffer and calling
	// gtk_entry_buffer_set_max_length() on it. ]|
	SetMaxLength(length int)
	// SetOverwriteMode sets whether the text is overwritten when typing in the
	// Text.
	SetOverwriteMode(overwrite bool)
	// SetPlaceholderText sets text to be displayed in @self when it is empty.
	//
	// This can be used to give a visual hint of the expected contents of the
	// self.
	SetPlaceholderText(text string)
	// SetPropagateTextWidth sets whether the GtkText should grow and shrink
	// with the content.
	SetPropagateTextWidth(propagateTextWidth bool)
	// SetTabs sets a TabArray; the tabstops in the array are applied to the
	// self text.
	SetTabs(tabs *pango.TabArray)
	// SetTruncateMultiline sets whether the GtkText should truncate multi-line
	// text that is pasted into the widget.
	SetTruncateMultiline(truncateMultiline bool)
	// SetVisibility sets whether the contents of the self are visible or not.
	// When visibility is set to false, characters are displayed as the
	// invisible char, and will also appear that way when the text in the self
	// widget is copied to the clipboard.
	//
	// By default, GTK picks the best invisible character available in the
	// current font, but it can be changed with gtk_text_set_invisible_char().
	//
	// Note that you probably want to set Text:input-purpose to
	// GTK_INPUT_PURPOSE_PASSWORD or GTK_INPUT_PURPOSE_PIN to inform input
	// methods about the purpose of this self, in addition to setting visibility
	// to false.
	SetVisibility(visible bool)
	// UnsetInvisibleChar unsets the invisible char previously set with
	// gtk_text_set_invisible_char(). So that the default invisible char is used
	// again.
	UnsetInvisibleChar()
}

// text implements the Text interface.
type text struct {
	Widget
	Accessible
	Buildable
	ConstraintTarget
	Editable
}

var _ Text = (*text)(nil)

// WrapText wraps a GObject to the right type. It is
// primarily used internally.
func WrapText(obj *externglib.Object) Text {
	return Text{
		Widget:           WrapWidget(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
		Editable:         WrapEditable(obj),
	}
}

func marshalText(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapText(obj), nil
}

// NewText constructs a class Text.
func NewText() Text {
	var cret C.GtkText

	cret = C.gtk_text_new()

	var text Text

	text = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Text)

	return text
}

// NewTextWithBuffer constructs a class Text.
func NewTextWithBuffer(buffer EntryBuffer) Text {
	var arg1 *C.GtkEntryBuffer

	arg1 = (*C.GtkEntryBuffer)(unsafe.Pointer(buffer.Native()))

	var cret C.GtkText

	cret = C.gtk_text_new_with_buffer(arg1)

	var text Text

	text = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Text)

	return text
}

// ActivatesDefault retrieves the value set by
// gtk_text_set_activates_default().
func (s text) ActivatesDefault() bool {
	var arg0 *C.GtkText

	arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))

	var cret C.gboolean

	cret = C.gtk_text_get_activates_default(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// Attributes gets the attribute list that was set on the self using
// gtk_text_set_attributes(), if any.
func (s text) Attributes() *pango.AttrList {
	var arg0 *C.GtkText

	arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))

	var cret *C.PangoAttrList

	cret = C.gtk_text_get_attributes(arg0)

	var attrList *pango.AttrList

	attrList = pango.WrapAttrList(unsafe.Pointer(cret))

	return attrList
}

// Buffer: get the EntryBuffer object which holds the text for this self.
func (s text) Buffer() EntryBuffer {
	var arg0 *C.GtkText

	arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))

	var cret *C.GtkEntryBuffer

	cret = C.gtk_text_get_buffer(arg0)

	var entryBuffer EntryBuffer

	entryBuffer = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(EntryBuffer)

	return entryBuffer
}

// EnableEmojiCompletion returns whether Emoji completion is enabled for
// this GtkText widget.
func (s text) EnableEmojiCompletion() bool {
	var arg0 *C.GtkText

	arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))

	var cret C.gboolean

	cret = C.gtk_text_get_enable_emoji_completion(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// ExtraMenu gets the menu model set with gtk_text_set_extra_menu().
func (s text) ExtraMenu() gio.MenuModel {
	var arg0 *C.GtkText

	arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))

	var cret *C.GMenuModel

	cret = C.gtk_text_get_extra_menu(arg0)

	var menuModel gio.MenuModel

	menuModel = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(gio.MenuModel)

	return menuModel
}

// InputHints gets the value of the Text:input-hints property.
func (s text) InputHints() InputHints {
	var arg0 *C.GtkText

	arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))

	var cret C.GtkInputHints

	cret = C.gtk_text_get_input_hints(arg0)

	var inputHints InputHints

	inputHints = InputHints(cret)

	return inputHints
}

// InputPurpose gets the value of the Text:input-purpose property.
func (s text) InputPurpose() InputPurpose {
	var arg0 *C.GtkText

	arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))

	var cret C.GtkInputPurpose

	cret = C.gtk_text_get_input_purpose(arg0)

	var inputPurpose InputPurpose

	inputPurpose = InputPurpose(cret)

	return inputPurpose
}

// InvisibleChar retrieves the character displayed in place of the real
// characters for entries with visibility set to false. Note that GTK does
// not compute this value unless it needs it, so the value returned by this
// function is not very useful unless it has been explicitly set with
// gtk_text_set_invisible_char()
func (s text) InvisibleChar() uint32 {
	var arg0 *C.GtkText

	arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))

	var cret C.gunichar

	cret = C.gtk_text_get_invisible_char(arg0)

	var gunichar uint32

	gunichar = (uint32)(cret)

	return gunichar
}

// MaxLength retrieves the maximum allowed length of the text in @self. See
// gtk_text_set_max_length().
//
// This is equivalent to getting @self's EntryBuffer and calling
// gtk_entry_buffer_get_max_length() on it.
func (s text) MaxLength() int {
	var arg0 *C.GtkText

	arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))

	var cret C.int

	cret = C.gtk_text_get_max_length(arg0)

	var gint int

	gint = (int)(cret)

	return gint
}

// OverwriteMode gets the value set by gtk_text_set_overwrite_mode().
func (s text) OverwriteMode() bool {
	var arg0 *C.GtkText

	arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))

	var cret C.gboolean

	cret = C.gtk_text_get_overwrite_mode(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// PlaceholderText retrieves the text that will be displayed when @self is
// empty and unfocused
func (s text) PlaceholderText() string {
	var arg0 *C.GtkText

	arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))

	var cret *C.char

	cret = C.gtk_text_get_placeholder_text(arg0)

	var utf8 string

	utf8 = C.GoString(cret)

	return utf8
}

// PropagateTextWidth returns whether the Text will grow and shrink with the
// content.
func (s text) PropagateTextWidth() bool {
	var arg0 *C.GtkText

	arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))

	var cret C.gboolean

	cret = C.gtk_text_get_propagate_text_width(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// Tabs gets the tabstops that were set on the self using
// gtk_text_set_tabs(), if any.
func (s text) Tabs() *pango.TabArray {
	var arg0 *C.GtkText

	arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))

	var cret *C.PangoTabArray

	cret = C.gtk_text_get_tabs(arg0)

	var tabArray *pango.TabArray

	tabArray = pango.WrapTabArray(unsafe.Pointer(cret))

	return tabArray
}

// TextLength retrieves the current length of the text in @self.
//
// This is equivalent to getting @self's EntryBuffer and calling
// gtk_entry_buffer_get_length() on it.
func (s text) TextLength() uint16 {
	var arg0 *C.GtkText

	arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))

	var cret C.guint16

	cret = C.gtk_text_get_text_length(arg0)

	var guint16 uint16

	guint16 = (uint16)(cret)

	return guint16
}

// TruncateMultiline returns whether the Text will truncate multi-line text
// that is pasted into the widget
func (s text) TruncateMultiline() bool {
	var arg0 *C.GtkText

	arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))

	var cret C.gboolean

	cret = C.gtk_text_get_truncate_multiline(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// Visibility retrieves whether the text in @self is visible. See
// gtk_text_set_visibility().
func (s text) Visibility() bool {
	var arg0 *C.GtkText

	arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))

	var cret C.gboolean

	cret = C.gtk_text_get_visibility(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// GrabFocusWithoutSelecting causes @self to have keyboard focus.
//
// It behaves like gtk_widget_grab_focus(), except that it doesn't select
// the contents of @self. You only want to call this on some special entries
// which the user usually doesn't want to replace all text in, such as
// search-as-you-type entries.
func (s text) GrabFocusWithoutSelecting() bool {
	var arg0 *C.GtkText

	arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))

	var cret C.gboolean

	cret = C.gtk_text_grab_focus_without_selecting(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// SetActivatesDefault: if @activates is true, pressing Enter in the @self
// will activate the default widget for the window containing the self. This
// usually means that the dialog box containing the self will be closed,
// since the default widget is usually one of the dialog buttons.
func (s text) SetActivatesDefault(activates bool) {
	var arg0 *C.GtkText
	var arg1 C.gboolean

	arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))
	if activates {
		arg1 = C.gboolean(1)
	}

	C.gtk_text_set_activates_default(arg0, arg1)
}

// SetAttributes sets a AttrList; the attributes in the list are applied to
// the text.
func (s text) SetAttributes(attrs *pango.AttrList) {
	var arg0 *C.GtkText
	var arg1 *C.PangoAttrList

	arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))
	arg1 = (*C.PangoAttrList)(unsafe.Pointer(attrs.Native()))

	C.gtk_text_set_attributes(arg0, arg1)
}

// SetBuffer: set the EntryBuffer object which holds the text for this
// widget.
func (s text) SetBuffer(buffer EntryBuffer) {
	var arg0 *C.GtkText
	var arg1 *C.GtkEntryBuffer

	arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GtkEntryBuffer)(unsafe.Pointer(buffer.Native()))

	C.gtk_text_set_buffer(arg0, arg1)
}

// SetEnableEmojiCompletion sets whether Emoji completion is enabled. If it
// is, typing ':', followed by a recognized keyword, will pop up a window
// with suggested Emojis matching the keyword.
func (s text) SetEnableEmojiCompletion(enableEmojiCompletion bool) {
	var arg0 *C.GtkText
	var arg1 C.gboolean

	arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))
	if enableEmojiCompletion {
		arg1 = C.gboolean(1)
	}

	C.gtk_text_set_enable_emoji_completion(arg0, arg1)
}

// SetExtraMenu sets a menu model to add when constructing the context menu
// for @self.
func (s text) SetExtraMenu(model gio.MenuModel) {
	var arg0 *C.GtkText
	var arg1 *C.GMenuModel

	arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GMenuModel)(unsafe.Pointer(model.Native()))

	C.gtk_text_set_extra_menu(arg0, arg1)
}

// SetInputHints sets the Text:input-hints property, which allows input
// methods to fine-tune their behaviour.
func (s text) SetInputHints(hints InputHints) {
	var arg0 *C.GtkText
	var arg1 C.GtkInputHints

	arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))
	arg1 = (C.GtkInputHints)(hints)

	C.gtk_text_set_input_hints(arg0, arg1)
}

// SetInputPurpose sets the Text:input-purpose property which can be used by
// on-screen keyboards and other input methods to adjust their behaviour.
func (s text) SetInputPurpose(purpose InputPurpose) {
	var arg0 *C.GtkText
	var arg1 C.GtkInputPurpose

	arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))
	arg1 = (C.GtkInputPurpose)(purpose)

	C.gtk_text_set_input_purpose(arg0, arg1)
}

// SetInvisibleChar sets the character to use in place of the actual text
// when gtk_text_set_visibility() has been called to set text visibility to
// false. i.e. this is the character used in “password mode” to show the
// user how many characters have been typed.
//
// By default, GTK picks the best invisible char available in the current
// font. If you set the invisible char to 0, then the user will get no
// feedback at all; there will be no text on the screen as they type.
func (s text) SetInvisibleChar(ch uint32) {
	var arg0 *C.GtkText
	var arg1 C.gunichar

	arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))
	arg1 = C.gunichar(ch)

	C.gtk_text_set_invisible_char(arg0, arg1)
}

// SetMaxLength sets the maximum allowed length of the contents of the
// widget.
//
// If the current contents are longer than the given length, then they will
// be truncated to fit.
//
// This is equivalent to getting @self's EntryBuffer and calling
// gtk_entry_buffer_set_max_length() on it. ]|
func (s text) SetMaxLength(length int) {
	var arg0 *C.GtkText
	var arg1 C.int

	arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))
	arg1 = C.int(length)

	C.gtk_text_set_max_length(arg0, arg1)
}

// SetOverwriteMode sets whether the text is overwritten when typing in the
// Text.
func (s text) SetOverwriteMode(overwrite bool) {
	var arg0 *C.GtkText
	var arg1 C.gboolean

	arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))
	if overwrite {
		arg1 = C.gboolean(1)
	}

	C.gtk_text_set_overwrite_mode(arg0, arg1)
}

// SetPlaceholderText sets text to be displayed in @self when it is empty.
//
// This can be used to give a visual hint of the expected contents of the
// self.
func (s text) SetPlaceholderText(text string) {
	var arg0 *C.GtkText
	var arg1 *C.char

	arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))
	arg1 = (*C.char)(C.CString(text))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_text_set_placeholder_text(arg0, arg1)
}

// SetPropagateTextWidth sets whether the GtkText should grow and shrink
// with the content.
func (s text) SetPropagateTextWidth(propagateTextWidth bool) {
	var arg0 *C.GtkText
	var arg1 C.gboolean

	arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))
	if propagateTextWidth {
		arg1 = C.gboolean(1)
	}

	C.gtk_text_set_propagate_text_width(arg0, arg1)
}

// SetTabs sets a TabArray; the tabstops in the array are applied to the
// self text.
func (s text) SetTabs(tabs *pango.TabArray) {
	var arg0 *C.GtkText
	var arg1 *C.PangoTabArray

	arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))
	arg1 = (*C.PangoTabArray)(unsafe.Pointer(tabs.Native()))

	C.gtk_text_set_tabs(arg0, arg1)
}

// SetTruncateMultiline sets whether the GtkText should truncate multi-line
// text that is pasted into the widget.
func (s text) SetTruncateMultiline(truncateMultiline bool) {
	var arg0 *C.GtkText
	var arg1 C.gboolean

	arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))
	if truncateMultiline {
		arg1 = C.gboolean(1)
	}

	C.gtk_text_set_truncate_multiline(arg0, arg1)
}

// SetVisibility sets whether the contents of the self are visible or not.
// When visibility is set to false, characters are displayed as the
// invisible char, and will also appear that way when the text in the self
// widget is copied to the clipboard.
//
// By default, GTK picks the best invisible character available in the
// current font, but it can be changed with gtk_text_set_invisible_char().
//
// Note that you probably want to set Text:input-purpose to
// GTK_INPUT_PURPOSE_PASSWORD or GTK_INPUT_PURPOSE_PIN to inform input
// methods about the purpose of this self, in addition to setting visibility
// to false.
func (s text) SetVisibility(visible bool) {
	var arg0 *C.GtkText
	var arg1 C.gboolean

	arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))
	if visible {
		arg1 = C.gboolean(1)
	}

	C.gtk_text_set_visibility(arg0, arg1)
}

// UnsetInvisibleChar unsets the invisible char previously set with
// gtk_text_set_invisible_char(). So that the default invisible char is used
// again.
func (s text) UnsetInvisibleChar() {
	var arg0 *C.GtkText

	arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))

	C.gtk_text_unset_invisible_char(arg0)
}

// TextTagTable: you may wish to begin by reading the [text widget conceptual
// overview][TextWidget] which gives an overview of all the objects and data
// types related to the text widget and how they work together.
//
//
// GtkTextTagTables as GtkBuildable
//
// The GtkTextTagTable implementation of the GtkBuildable interface supports
// adding tags by specifying “tag” as the “type” attribute of a <child> element.
//
// An example of a UI definition fragment specifying tags:
//
//    <object class="GtkTextTagTable">
//     <child type="tag">
//       <object class="GtkTextTag"/>
//     </child>
//    </object>
type TextTagTable interface {
	gextras.Objector
	Buildable

	// Add: add a tag to the table. The tag is assigned the highest priority in
	// the table.
	//
	// @tag must not be in a tag table already, and may not have the same name
	// as an already-added tag.
	Add(tag TextTag) bool
	// Foreach calls @func on each tag in @table, with user data @data. Note
	// that the table may not be modified while iterating over it (you can’t
	// add/remove tags).
	Foreach()
	// Size returns the size of the table (number of tags)
	Size() int
	// Lookup: look up a named tag.
	Lookup(name string) TextTag
	// Remove: remove a tag from the table. If a TextBuffer has @table as its
	// tag table, the tag is removed from the buffer. The table’s reference to
	// the tag is removed, so the tag will end up destroyed if you don’t have a
	// reference to it.
	Remove(tag TextTag)
}

// textTagTable implements the TextTagTable interface.
type textTagTable struct {
	gextras.Objector
	Buildable
}

var _ TextTagTable = (*textTagTable)(nil)

// WrapTextTagTable wraps a GObject to the right type. It is
// primarily used internally.
func WrapTextTagTable(obj *externglib.Object) TextTagTable {
	return TextTagTable{
		Objector:  obj,
		Buildable: WrapBuildable(obj),
	}
}

func marshalTextTagTable(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTextTagTable(obj), nil
}

// NewTextTagTable constructs a class TextTagTable.
func NewTextTagTable() TextTagTable {
	var cret C.GtkTextTagTable

	cret = C.gtk_text_tag_table_new()

	var textTagTable TextTagTable

	textTagTable = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(TextTagTable)

	return textTagTable
}

// Add: add a tag to the table. The tag is assigned the highest priority in
// the table.
//
// @tag must not be in a tag table already, and may not have the same name
// as an already-added tag.
func (t textTagTable) Add(tag TextTag) bool {
	var arg0 *C.GtkTextTagTable
	var arg1 *C.GtkTextTag

	arg0 = (*C.GtkTextTagTable)(unsafe.Pointer(t.Native()))
	arg1 = (*C.GtkTextTag)(unsafe.Pointer(tag.Native()))

	var cret C.gboolean

	cret = C.gtk_text_tag_table_add(arg0, arg1)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// Foreach calls @func on each tag in @table, with user data @data. Note
// that the table may not be modified while iterating over it (you can’t
// add/remove tags).
func (t textTagTable) Foreach() {
	var arg0 *C.GtkTextTagTable

	arg0 = (*C.GtkTextTagTable)(unsafe.Pointer(t.Native()))

	C.gtk_text_tag_table_foreach(arg0)
}

// Size returns the size of the table (number of tags)
func (t textTagTable) Size() int {
	var arg0 *C.GtkTextTagTable

	arg0 = (*C.GtkTextTagTable)(unsafe.Pointer(t.Native()))

	var cret C.int

	cret = C.gtk_text_tag_table_get_size(arg0)

	var gint int

	gint = (int)(cret)

	return gint
}

// Lookup: look up a named tag.
func (t textTagTable) Lookup(name string) TextTag {
	var arg0 *C.GtkTextTagTable
	var arg1 *C.char

	arg0 = (*C.GtkTextTagTable)(unsafe.Pointer(t.Native()))
	arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	var cret *C.GtkTextTag

	cret = C.gtk_text_tag_table_lookup(arg0, arg1)

	var textTag TextTag

	textTag = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(TextTag)

	return textTag
}

// Remove: remove a tag from the table. If a TextBuffer has @table as its
// tag table, the tag is removed from the buffer. The table’s reference to
// the tag is removed, so the tag will end up destroyed if you don’t have a
// reference to it.
func (t textTagTable) Remove(tag TextTag) {
	var arg0 *C.GtkTextTagTable
	var arg1 *C.GtkTextTag

	arg0 = (*C.GtkTextTagTable)(unsafe.Pointer(t.Native()))
	arg1 = (*C.GtkTextTag)(unsafe.Pointer(tag.Native()))

	C.gtk_text_tag_table_remove(arg0, arg1)
}

// Tooltip: basic tooltips can be realized simply by using
// gtk_widget_set_tooltip_text() or gtk_widget_set_tooltip_markup() without any
// explicit tooltip object.
//
// When you need a tooltip with a little more fancy contents, like adding an
// image, or you want the tooltip to have different contents per TreeView row or
// cell, you will have to do a little more work:
//
// - Set the Widget:has-tooltip property to true, this will make GTK monitor the
// widget for motion and related events which are needed to determine when and
// where to show a tooltip.
//
// - Connect to the Widget::query-tooltip signal. This signal will be emitted
// when a tooltip is supposed to be shown. One of the arguments passed to the
// signal handler is a GtkTooltip object. This is the object that we are about
// to display as a tooltip, and can be manipulated in your callback using
// functions like gtk_tooltip_set_icon(). There are functions for setting the
// tooltip’s markup, setting an image from a named icon, or even putting in a
// custom widget.
//
//    Return true from your query-tooltip handler. This causes the tooltip to be
//    show. If you return false, it will not be shown.
type Tooltip interface {
	gextras.Objector

	// SetCustom replaces the widget packed into the tooltip with
	// @custom_widget. @custom_widget does not get destroyed when the tooltip
	// goes away. By default a box with a Image and Label is embedded in the
	// tooltip, which can be configured using gtk_tooltip_set_markup() and
	// gtk_tooltip_set_icon().
	SetCustom(customWidget Widget)
	// SetIcon sets the icon of the tooltip (which is in front of the text) to
	// be @paintable. If @paintable is nil, the image will be hidden.
	SetIcon(paintable gdk.Paintable)
	// SetIconFromGIcon sets the icon of the tooltip (which is in front of the
	// text) to be the icon indicated by @gicon with the size indicated by
	// @size. If @gicon is nil, the image will be hidden.
	SetIconFromGIcon(gicon gio.Icon)
	// SetIconFromIconName sets the icon of the tooltip (which is in front of
	// the text) to be the icon indicated by @icon_name with the size indicated
	// by @size. If @icon_name is nil, the image will be hidden.
	SetIconFromIconName(iconName string)
	// SetMarkup sets the text of the tooltip to be @markup, which is marked up
	// with the [Pango text markup language][PangoMarkupFormat]. If @markup is
	// nil, the label will be hidden.
	SetMarkup(markup string)
	// SetText sets the text of the tooltip to be @text. If @text is nil, the
	// label will be hidden. See also gtk_tooltip_set_markup().
	SetText(text string)
	// SetTipArea sets the area of the widget, where the contents of this
	// tooltip apply, to be @rect (in widget coordinates). This is especially
	// useful for properly setting tooltips on TreeView rows and cells,
	// IconViews, etc.
	//
	// For setting tooltips on TreeView, please refer to the convenience
	// functions for this: gtk_tree_view_set_tooltip_row() and
	// gtk_tree_view_set_tooltip_cell().
	SetTipArea(rect *gdk.Rectangle)
}

// tooltip implements the Tooltip interface.
type tooltip struct {
	gextras.Objector
}

var _ Tooltip = (*tooltip)(nil)

// WrapTooltip wraps a GObject to the right type. It is
// primarily used internally.
func WrapTooltip(obj *externglib.Object) Tooltip {
	return Tooltip{
		Objector: obj,
	}
}

func marshalTooltip(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTooltip(obj), nil
}

// SetCustom replaces the widget packed into the tooltip with
// @custom_widget. @custom_widget does not get destroyed when the tooltip
// goes away. By default a box with a Image and Label is embedded in the
// tooltip, which can be configured using gtk_tooltip_set_markup() and
// gtk_tooltip_set_icon().
func (t tooltip) SetCustom(customWidget Widget) {
	var arg0 *C.GtkTooltip
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkTooltip)(unsafe.Pointer(t.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(customWidget.Native()))

	C.gtk_tooltip_set_custom(arg0, arg1)
}

// SetIcon sets the icon of the tooltip (which is in front of the text) to
// be @paintable. If @paintable is nil, the image will be hidden.
func (t tooltip) SetIcon(paintable gdk.Paintable) {
	var arg0 *C.GtkTooltip
	var arg1 *C.GdkPaintable

	arg0 = (*C.GtkTooltip)(unsafe.Pointer(t.Native()))
	arg1 = (*C.GdkPaintable)(unsafe.Pointer(paintable.Native()))

	C.gtk_tooltip_set_icon(arg0, arg1)
}

// SetIconFromGIcon sets the icon of the tooltip (which is in front of the
// text) to be the icon indicated by @gicon with the size indicated by
// @size. If @gicon is nil, the image will be hidden.
func (t tooltip) SetIconFromGIcon(gicon gio.Icon) {
	var arg0 *C.GtkTooltip
	var arg1 *C.GIcon

	arg0 = (*C.GtkTooltip)(unsafe.Pointer(t.Native()))
	arg1 = (*C.GIcon)(unsafe.Pointer(gicon.Native()))

	C.gtk_tooltip_set_icon_from_gicon(arg0, arg1)
}

// SetIconFromIconName sets the icon of the tooltip (which is in front of
// the text) to be the icon indicated by @icon_name with the size indicated
// by @size. If @icon_name is nil, the image will be hidden.
func (t tooltip) SetIconFromIconName(iconName string) {
	var arg0 *C.GtkTooltip
	var arg1 *C.char

	arg0 = (*C.GtkTooltip)(unsafe.Pointer(t.Native()))
	arg1 = (*C.char)(C.CString(iconName))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_tooltip_set_icon_from_icon_name(arg0, arg1)
}

// SetMarkup sets the text of the tooltip to be @markup, which is marked up
// with the [Pango text markup language][PangoMarkupFormat]. If @markup is
// nil, the label will be hidden.
func (t tooltip) SetMarkup(markup string) {
	var arg0 *C.GtkTooltip
	var arg1 *C.char

	arg0 = (*C.GtkTooltip)(unsafe.Pointer(t.Native()))
	arg1 = (*C.char)(C.CString(markup))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_tooltip_set_markup(arg0, arg1)
}

// SetText sets the text of the tooltip to be @text. If @text is nil, the
// label will be hidden. See also gtk_tooltip_set_markup().
func (t tooltip) SetText(text string) {
	var arg0 *C.GtkTooltip
	var arg1 *C.char

	arg0 = (*C.GtkTooltip)(unsafe.Pointer(t.Native()))
	arg1 = (*C.char)(C.CString(text))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_tooltip_set_text(arg0, arg1)
}

// SetTipArea sets the area of the widget, where the contents of this
// tooltip apply, to be @rect (in widget coordinates). This is especially
// useful for properly setting tooltips on TreeView rows and cells,
// IconViews, etc.
//
// For setting tooltips on TreeView, please refer to the convenience
// functions for this: gtk_tree_view_set_tooltip_row() and
// gtk_tree_view_set_tooltip_cell().
func (t tooltip) SetTipArea(rect *gdk.Rectangle) {
	var arg0 *C.GtkTooltip
	var arg1 *C.GdkRectangle

	arg0 = (*C.GtkTooltip)(unsafe.Pointer(t.Native()))
	arg1 = (*C.GdkRectangle)(unsafe.Pointer(rect.Native()))

	C.gtk_tooltip_set_tip_area(arg0, arg1)
}

// TreeSelection: the TreeSelection object is a helper object to manage the
// selection for a TreeView widget. The TreeSelection object is automatically
// created when a new TreeView widget is created, and cannot exist independently
// of this widget. The primary reason the TreeSelection objects exists is for
// cleanliness of code and API. That is, there is no conceptual reason all these
// functions could not be methods on the TreeView widget instead of a separate
// function.
//
// The TreeSelection object is gotten from a TreeView by calling
// gtk_tree_view_get_selection(). It can be manipulated to check the selection
// status of the tree, as well as select and deselect individual rows. Selection
// is done completely view side. As a result, multiple views of the same model
// can have completely different selections. Additionally, you cannot change the
// selection of a row on the model that is not currently displayed by the view
// without expanding its parents first.
//
// One of the important things to remember when monitoring the selection of a
// view is that the TreeSelection::changed signal is mostly a hint. That is, it
// may only emit one signal when a range of rows is selected. Additionally, it
// may on occasion emit a TreeSelection::changed signal when nothing has
// happened (mostly as a result of programmers calling select_row on an already
// selected row).
type TreeSelection interface {
	gextras.Objector

	// CountSelectedRows returns the number of rows that have been selected in
	// @tree.
	CountSelectedRows() int
	// Mode gets the selection mode for @selection. See
	// gtk_tree_selection_set_mode().
	Mode() SelectionMode
	// Selected sets @iter to the currently selected node if @selection is set
	// to K_SELECTION_SINGLE or K_SELECTION_BROWSE. @iter may be NULL if you
	// just want to test if @selection has any selected nodes. @model is filled
	// with the current model as a convenience. This function will not work if
	// you use @selection is K_SELECTION_MULTIPLE.
	Selected() (model TreeModel, iter TreeIter, ok bool)
	// SelectedRows creates a list of path of all selected rows. Additionally,
	// if you are planning on modifying the model after calling this function,
	// you may want to convert the returned list into a list of
	// TreeRowReferences. To do this, you can use gtk_tree_row_reference_new().
	//
	// To free the return value, use:
	//
	//    g_list_free_full (list, (GDestroyNotify) gtk_tree_path_free);
	SelectedRows() (model TreeModel, list *glib.List)
	// TreeView returns the tree view associated with @selection.
	TreeView() TreeView
	// UserData returns the user data for the selection function.
	UserData() interface{}
	// IterIsSelected returns true if the row at @iter is currently selected.
	IterIsSelected(iter *TreeIter) bool
	// PathIsSelected returns true if the row pointed to by @path is currently
	// selected. If @path does not point to a valid location, false is returned
	PathIsSelected(path *TreePath) bool
	// SelectAll selects all the nodes. @selection must be set to
	// K_SELECTION_MULTIPLE mode.
	SelectAll()
	// SelectIter selects the specified iterator.
	SelectIter(iter *TreeIter)
	// SelectPath: select the row at @path.
	SelectPath(path *TreePath)
	// SelectRange selects a range of nodes, determined by @start_path and
	// @end_path inclusive. @selection must be set to K_SELECTION_MULTIPLE mode.
	SelectRange(startPath *TreePath, endPath *TreePath)
	// SelectedForeach calls a function for each selected node. Note that you
	// cannot modify the tree or selection from within this function. As a
	// result, gtk_tree_selection_get_selected_rows() might be more useful.
	SelectedForeach()
	// SetMode sets the selection mode of the @selection. If the previous type
	// was K_SELECTION_MULTIPLE, then the anchor is kept selected, if it was
	// previously selected.
	SetMode(typ SelectionMode)
	// SetSelectFunction sets the selection function.
	//
	// If set, this function is called before any node is selected or
	// unselected, giving some control over which nodes are selected. The select
	// function should return true if the state of the node may be toggled, and
	// false if the state of the node should be left unchanged.
	SetSelectFunction()
	// UnselectAll unselects all the nodes.
	UnselectAll()
	// UnselectIter unselects the specified iterator.
	UnselectIter(iter *TreeIter)
	// UnselectPath unselects the row at @path.
	UnselectPath(path *TreePath)
	// UnselectRange unselects a range of nodes, determined by @start_path and
	// @end_path inclusive.
	UnselectRange(startPath *TreePath, endPath *TreePath)
}

// treeSelection implements the TreeSelection interface.
type treeSelection struct {
	gextras.Objector
}

var _ TreeSelection = (*treeSelection)(nil)

// WrapTreeSelection wraps a GObject to the right type. It is
// primarily used internally.
func WrapTreeSelection(obj *externglib.Object) TreeSelection {
	return TreeSelection{
		Objector: obj,
	}
}

func marshalTreeSelection(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTreeSelection(obj), nil
}

// CountSelectedRows returns the number of rows that have been selected in
// @tree.
func (s treeSelection) CountSelectedRows() int {
	var arg0 *C.GtkTreeSelection

	arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))

	var cret C.int

	cret = C.gtk_tree_selection_count_selected_rows(arg0)

	var gint int

	gint = (int)(cret)

	return gint
}

// Mode gets the selection mode for @selection. See
// gtk_tree_selection_set_mode().
func (s treeSelection) Mode() SelectionMode {
	var arg0 *C.GtkTreeSelection

	arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))

	var cret C.GtkSelectionMode

	cret = C.gtk_tree_selection_get_mode(arg0)

	var selectionMode SelectionMode

	selectionMode = SelectionMode(cret)

	return selectionMode
}

// Selected sets @iter to the currently selected node if @selection is set
// to K_SELECTION_SINGLE or K_SELECTION_BROWSE. @iter may be NULL if you
// just want to test if @selection has any selected nodes. @model is filled
// with the current model as a convenience. This function will not work if
// you use @selection is K_SELECTION_MULTIPLE.
func (s treeSelection) Selected() (model TreeModel, iter TreeIter, ok bool) {
	var arg0 *C.GtkTreeSelection

	arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))

	var arg1 **C.GtkTreeModel
	var iter TreeIter
	var cret C.gboolean

	cret = C.gtk_tree_selection_get_selected(arg0, arg1, (*C.GtkTreeIter)(unsafe.Pointer(&iter)))

	var model TreeModel

	var ok bool

	model = gextras.CastObject(externglib.Take(unsafe.Pointer(arg1.Native()))).(TreeModel)

	if cret {
		ok = true
	}

	return model, iter, ok
}

// SelectedRows creates a list of path of all selected rows. Additionally,
// if you are planning on modifying the model after calling this function,
// you may want to convert the returned list into a list of
// TreeRowReferences. To do this, you can use gtk_tree_row_reference_new().
//
// To free the return value, use:
//
//    g_list_free_full (list, (GDestroyNotify) gtk_tree_path_free);
func (s treeSelection) SelectedRows() (model TreeModel, list *glib.List) {
	var arg0 *C.GtkTreeSelection

	arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))

	var arg1 **C.GtkTreeModel
	var cret *C.GList

	cret = C.gtk_tree_selection_get_selected_rows(arg0, arg1)

	var model TreeModel
	var list *glib.List

	model = gextras.CastObject(externglib.Take(unsafe.Pointer(arg1.Native()))).(TreeModel)
	list = glib.WrapList(unsafe.Pointer(cret))
	runtime.SetFinalizer(list, func(v *glib.List) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return model, list
}

// TreeView returns the tree view associated with @selection.
func (s treeSelection) TreeView() TreeView {
	var arg0 *C.GtkTreeSelection

	arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))

	var cret *C.GtkTreeView

	cret = C.gtk_tree_selection_get_tree_view(arg0)

	var treeView TreeView

	treeView = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(TreeView)

	return treeView
}

// UserData returns the user data for the selection function.
func (s treeSelection) UserData() interface{} {
	var arg0 *C.GtkTreeSelection

	arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))

	var cret C.gpointer

	cret = C.gtk_tree_selection_get_user_data(arg0)

	var gpointer interface{}

	gpointer = (interface{})(cret)

	return gpointer
}

// IterIsSelected returns true if the row at @iter is currently selected.
func (s treeSelection) IterIsSelected(iter *TreeIter) bool {
	var arg0 *C.GtkTreeSelection
	var arg1 *C.GtkTreeIter

	arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

	var cret C.gboolean

	cret = C.gtk_tree_selection_iter_is_selected(arg0, arg1)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// PathIsSelected returns true if the row pointed to by @path is currently
// selected. If @path does not point to a valid location, false is returned
func (s treeSelection) PathIsSelected(path *TreePath) bool {
	var arg0 *C.GtkTreeSelection
	var arg1 *C.GtkTreePath

	arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	var cret C.gboolean

	cret = C.gtk_tree_selection_path_is_selected(arg0, arg1)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// SelectAll selects all the nodes. @selection must be set to
// K_SELECTION_MULTIPLE mode.
func (s treeSelection) SelectAll() {
	var arg0 *C.GtkTreeSelection

	arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))

	C.gtk_tree_selection_select_all(arg0)
}

// SelectIter selects the specified iterator.
func (s treeSelection) SelectIter(iter *TreeIter) {
	var arg0 *C.GtkTreeSelection
	var arg1 *C.GtkTreeIter

	arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

	C.gtk_tree_selection_select_iter(arg0, arg1)
}

// SelectPath: select the row at @path.
func (s treeSelection) SelectPath(path *TreePath) {
	var arg0 *C.GtkTreeSelection
	var arg1 *C.GtkTreePath

	arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	C.gtk_tree_selection_select_path(arg0, arg1)
}

// SelectRange selects a range of nodes, determined by @start_path and
// @end_path inclusive. @selection must be set to K_SELECTION_MULTIPLE mode.
func (s treeSelection) SelectRange(startPath *TreePath, endPath *TreePath) {
	var arg0 *C.GtkTreeSelection
	var arg1 *C.GtkTreePath
	var arg2 *C.GtkTreePath

	arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GtkTreePath)(unsafe.Pointer(startPath.Native()))
	arg2 = (*C.GtkTreePath)(unsafe.Pointer(endPath.Native()))

	C.gtk_tree_selection_select_range(arg0, arg1, arg2)
}

// SelectedForeach calls a function for each selected node. Note that you
// cannot modify the tree or selection from within this function. As a
// result, gtk_tree_selection_get_selected_rows() might be more useful.
func (s treeSelection) SelectedForeach() {
	var arg0 *C.GtkTreeSelection

	arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))

	C.gtk_tree_selection_selected_foreach(arg0)
}

// SetMode sets the selection mode of the @selection. If the previous type
// was K_SELECTION_MULTIPLE, then the anchor is kept selected, if it was
// previously selected.
func (s treeSelection) SetMode(typ SelectionMode) {
	var arg0 *C.GtkTreeSelection
	var arg1 C.GtkSelectionMode

	arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))
	arg1 = (C.GtkSelectionMode)(typ)

	C.gtk_tree_selection_set_mode(arg0, arg1)
}

// SetSelectFunction sets the selection function.
//
// If set, this function is called before any node is selected or
// unselected, giving some control over which nodes are selected. The select
// function should return true if the state of the node may be toggled, and
// false if the state of the node should be left unchanged.
func (s treeSelection) SetSelectFunction() {
	var arg0 *C.GtkTreeSelection

	arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))

	C.gtk_tree_selection_set_select_function(arg0)
}

// UnselectAll unselects all the nodes.
func (s treeSelection) UnselectAll() {
	var arg0 *C.GtkTreeSelection

	arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))

	C.gtk_tree_selection_unselect_all(arg0)
}

// UnselectIter unselects the specified iterator.
func (s treeSelection) UnselectIter(iter *TreeIter) {
	var arg0 *C.GtkTreeSelection
	var arg1 *C.GtkTreeIter

	arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

	C.gtk_tree_selection_unselect_iter(arg0, arg1)
}

// UnselectPath unselects the row at @path.
func (s treeSelection) UnselectPath(path *TreePath) {
	var arg0 *C.GtkTreeSelection
	var arg1 *C.GtkTreePath

	arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	C.gtk_tree_selection_unselect_path(arg0, arg1)
}

// UnselectRange unselects a range of nodes, determined by @start_path and
// @end_path inclusive.
func (s treeSelection) UnselectRange(startPath *TreePath, endPath *TreePath) {
	var arg0 *C.GtkTreeSelection
	var arg1 *C.GtkTreePath
	var arg2 *C.GtkTreePath

	arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GtkTreePath)(unsafe.Pointer(startPath.Native()))
	arg2 = (*C.GtkTreePath)(unsafe.Pointer(endPath.Native()))

	C.gtk_tree_selection_unselect_range(arg0, arg1, arg2)
}

// TreeViewColumn: the GtkTreeViewColumn object represents a visible column in a
// TreeView widget. It allows to set properties of the column header, and
// functions as a holding pen for the cell renderers which determine how the
// data in the column is displayed.
//
// Please refer to the [tree widget conceptual overview][TreeWidget] for an
// overview of all the objects and data types related to the tree widget and how
// they work together.
type TreeViewColumn interface {
	gextras.Objector
	Buildable
	CellLayout

	// AddAttribute adds an attribute mapping to the list in @tree_column. The
	// @column is the column of the model to get a value from, and the
	// @attribute is the parameter on @cell_renderer to be set from the value.
	// So for example if column 2 of the model contains strings, you could have
	// the “text” attribute of a CellRendererText get its values from column 2.
	AddAttribute(cellRenderer CellRenderer, attribute string, column int)
	// CellGetPosition obtains the horizontal position and size of a cell in a
	// column. If the cell is not found in the column, @start_pos and @width are
	// not changed and false is returned.
	CellGetPosition(cellRenderer CellRenderer) (xOffset int, width int, ok bool)
	// CellGetSize obtains the width and height needed to render the column.
	// This is used primarily by the TreeView.
	CellGetSize() (xOffset int, yOffset int, width int, height int)
	// CellIsVisible returns true if any of the cells packed into the
	// @tree_column are visible. For this to be meaningful, you must first
	// initialize the cells with gtk_tree_view_column_cell_set_cell_data()
	CellIsVisible() bool
	// CellSetCellData sets the cell renderer based on the @tree_model and
	// @iter. That is, for every attribute mapping in @tree_column, it will get
	// a value from the set column on the @iter, and use that value to set the
	// attribute on the cell renderer. This is used primarily by the TreeView.
	CellSetCellData(treeModel TreeModel, iter *TreeIter, isExpander bool, isExpanded bool)
	// Clear unsets all the mappings on all renderers on the @tree_column.
	Clear()
	// ClearAttributes clears all existing attributes previously set with
	// gtk_tree_view_column_set_attributes().
	ClearAttributes(cellRenderer CellRenderer)
	// Clicked emits the “clicked” signal on the column. This function will only
	// work if @tree_column is clickable.
	Clicked()
	// FocusCell sets the current keyboard focus to be at @cell, if the column
	// contains 2 or more editable and activatable cells.
	FocusCell(cell CellRenderer)
	// Alignment returns the current x alignment of @tree_column. This value can
	// range between 0.0 and 1.0.
	Alignment() float32
	// Button returns the button used in the treeview column header
	Button() Widget
	// Clickable returns true if the user can click on the header for the
	// column.
	Clickable() bool
	// Expand returns true if the column expands to fill available space.
	Expand() bool
	// FixedWidth gets the fixed width of the column. This may not be the actual
	// displayed width of the column; for that, use
	// gtk_tree_view_column_get_width().
	FixedWidth() int
	// MaxWidth returns the maximum width in pixels of the @tree_column, or -1
	// if no maximum width is set.
	MaxWidth() int
	// MinWidth returns the minimum width in pixels of the @tree_column, or -1
	// if no minimum width is set.
	MinWidth() int
	// Reorderable returns true if the @tree_column can be reordered by the
	// user.
	Reorderable() bool
	// Resizable returns true if the @tree_column can be resized by the end
	// user.
	Resizable() bool
	// Sizing returns the current type of @tree_column.
	Sizing() TreeViewColumnSizing
	// SortColumnID gets the logical @sort_column_id that the model sorts on
	// when this column is selected for sorting. See
	// gtk_tree_view_column_set_sort_column_id().
	SortColumnID() int
	// SortIndicator gets the value set by
	// gtk_tree_view_column_set_sort_indicator().
	SortIndicator() bool
	// SortOrder gets the value set by gtk_tree_view_column_set_sort_order().
	SortOrder() SortType
	// Spacing returns the spacing of @tree_column.
	Spacing() int
	// Title returns the title of the widget.
	Title() string
	// TreeView returns the TreeView wherein @tree_column has been inserted. If
	// @column is currently not inserted in any tree view, nil is returned.
	TreeView() Widget
	// Visible returns true if @tree_column is visible.
	Visible() bool
	// Widget returns the Widget in the button on the column header. If a custom
	// widget has not been set then nil is returned.
	Widget() Widget
	// Width returns the current size of @tree_column in pixels.
	Width() int
	// XOffset returns the current X offset of @tree_column in pixels.
	XOffset() int
	// PackEnd adds the @cell to end of the column. If @expand is false, then
	// the @cell is allocated no more space than it needs. Any unused space is
	// divided evenly between cells for which @expand is true.
	PackEnd(cell CellRenderer, expand bool)
	// PackStart packs the @cell into the beginning of the column. If @expand is
	// false, then the @cell is allocated no more space than it needs. Any
	// unused space is divided evenly between cells for which @expand is true.
	PackStart(cell CellRenderer, expand bool)
	// QueueResize flags the column, and the cell renderers added to this
	// column, to have their sizes renegotiated.
	QueueResize()
	// SetAlignment sets the alignment of the title or custom widget inside the
	// column header. The alignment determines its location inside the button --
	// 0.0 for left, 0.5 for center, 1.0 for right.
	SetAlignment(xalign float32)
	// SetCellDataFunc sets the TreeCellDataFunc to use for the column. This
	// function is used instead of the standard attributes mapping for setting
	// the column value, and should set the value of @tree_column's cell
	// renderer as appropriate. @func may be nil to remove an older one.
	SetCellDataFunc()
	// SetClickable sets the header to be active if @clickable is true. When the
	// header is active, then it can take keyboard focus, and can be clicked.
	SetClickable(clickable bool)
	// SetExpand sets the column to take available extra space. This space is
	// shared equally amongst all columns that have the expand set to true. If
	// no column has this option set, then the last column gets all extra space.
	// By default, every column is created with this false.
	//
	// Along with “fixed-width”, the “expand” property changes when the column
	// is resized by the user.
	SetExpand(expand bool)
	// SetFixedWidth: if @fixed_width is not -1, sets the fixed width of
	// @tree_column; otherwise unsets it. The effective value of @fixed_width is
	// clamped between the minimum and maximum width of the column; however, the
	// value stored in the “fixed-width” property is not clamped. If the column
	// sizing is K_TREE_VIEW_COLUMN_GROW_ONLY or K_TREE_VIEW_COLUMN_AUTOSIZE,
	// setting a fixed width overrides the automatically calculated width. Note
	// that @fixed_width is only a hint to GTK; the width actually allocated to
	// the column may be greater or less than requested.
	//
	// Along with “expand”, the “fixed-width” property changes when the column
	// is resized by the user.
	SetFixedWidth(fixedWidth int)
	// SetMaxWidth sets the maximum width of the @tree_column. If @max_width is
	// -1, then the maximum width is unset. Note, the column can actually be
	// wider than max width if it’s the last column in a view. In this case, the
	// column expands to fill any extra space.
	SetMaxWidth(maxWidth int)
	// SetMinWidth sets the minimum width of the @tree_column. If @min_width is
	// -1, then the minimum width is unset.
	SetMinWidth(minWidth int)
	// SetReorderable: if @reorderable is true, then the column can be reordered
	// by the end user dragging the header.
	SetReorderable(reorderable bool)
	// SetResizable: if @resizable is true, then the user can explicitly resize
	// the column by grabbing the outer edge of the column button. If resizable
	// is true and sizing mode of the column is K_TREE_VIEW_COLUMN_AUTOSIZE,
	// then the sizing mode is changed to K_TREE_VIEW_COLUMN_GROW_ONLY.
	SetResizable(resizable bool)
	// SetSizing sets the growth behavior of @tree_column to @type.
	SetSizing(typ TreeViewColumnSizing)
	// SetSortColumnID sets the logical @sort_column_id that this column sorts
	// on when this column is selected for sorting. Doing so makes the column
	// header clickable.
	SetSortColumnID(sortColumnId int)
	// SetSortIndicator: call this function with a @setting of true to display
	// an arrow in the header button indicating the column is sorted. Call
	// gtk_tree_view_column_set_sort_order() to change the direction of the
	// arrow.
	SetSortIndicator(setting bool)
	// SetSortOrder changes the appearance of the sort indicator.
	//
	// This does not actually sort the model. Use
	// gtk_tree_view_column_set_sort_column_id() if you want automatic sorting
	// support. This function is primarily for custom sorting behavior, and
	// should be used in conjunction with gtk_tree_sortable_set_sort_column_id()
	// to do that. For custom models, the mechanism will vary.
	//
	// The sort indicator changes direction to indicate normal sort or reverse
	// sort. Note that you must have the sort indicator enabled to see anything
	// when calling this function; see
	// gtk_tree_view_column_set_sort_indicator().
	SetSortOrder(order SortType)
	// SetSpacing sets the spacing field of @tree_column, which is the number of
	// pixels to place between cell renderers packed into it.
	SetSpacing(spacing int)
	// SetTitle sets the title of the @tree_column. If a custom widget has been
	// set, then this value is ignored.
	SetTitle(title string)
	// SetVisible sets the visibility of @tree_column.
	SetVisible(visible bool)
	// SetWidget sets the widget in the header to be @widget. If widget is nil,
	// then the header button is set with a Label set to the title of
	// @tree_column.
	SetWidget(widget Widget)
}

// treeViewColumn implements the TreeViewColumn interface.
type treeViewColumn struct {
	gextras.Objector
	Buildable
	CellLayout
}

var _ TreeViewColumn = (*treeViewColumn)(nil)

// WrapTreeViewColumn wraps a GObject to the right type. It is
// primarily used internally.
func WrapTreeViewColumn(obj *externglib.Object) TreeViewColumn {
	return TreeViewColumn{
		Objector:   obj,
		Buildable:  WrapBuildable(obj),
		CellLayout: WrapCellLayout(obj),
	}
}

func marshalTreeViewColumn(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTreeViewColumn(obj), nil
}

// NewTreeViewColumn constructs a class TreeViewColumn.
func NewTreeViewColumn() TreeViewColumn {
	var cret C.GtkTreeViewColumn

	cret = C.gtk_tree_view_column_new()

	var treeViewColumn TreeViewColumn

	treeViewColumn = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(TreeViewColumn)

	return treeViewColumn
}

// NewTreeViewColumnWithArea constructs a class TreeViewColumn.
func NewTreeViewColumnWithArea(area CellArea) TreeViewColumn {
	var arg1 *C.GtkCellArea

	arg1 = (*C.GtkCellArea)(unsafe.Pointer(area.Native()))

	var cret C.GtkTreeViewColumn

	cret = C.gtk_tree_view_column_new_with_area(arg1)

	var treeViewColumn TreeViewColumn

	treeViewColumn = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(TreeViewColumn)

	return treeViewColumn
}

// AddAttribute adds an attribute mapping to the list in @tree_column. The
// @column is the column of the model to get a value from, and the
// @attribute is the parameter on @cell_renderer to be set from the value.
// So for example if column 2 of the model contains strings, you could have
// the “text” attribute of a CellRendererText get its values from column 2.
func (t treeViewColumn) AddAttribute(cellRenderer CellRenderer, attribute string, column int) {
	var arg0 *C.GtkTreeViewColumn
	var arg1 *C.GtkCellRenderer
	var arg2 *C.char
	var arg3 C.int

	arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(cellRenderer.Native()))
	arg2 = (*C.char)(C.CString(attribute))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = C.int(column)

	C.gtk_tree_view_column_add_attribute(arg0, arg1, arg2, arg3)
}

// CellGetPosition obtains the horizontal position and size of a cell in a
// column. If the cell is not found in the column, @start_pos and @width are
// not changed and false is returned.
func (t treeViewColumn) CellGetPosition(cellRenderer CellRenderer) (xOffset int, width int, ok bool) {
	var arg0 *C.GtkTreeViewColumn
	var arg1 *C.GtkCellRenderer

	arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(cellRenderer.Native()))

	var arg2 C.int
	var arg3 C.int
	var cret C.gboolean

	cret = C.gtk_tree_view_column_cell_get_position(arg0, arg1, &arg2, &arg3)

	var xOffset int
	var width int
	var ok bool

	xOffset = (int)(arg2)
	width = (int)(arg3)
	if cret {
		ok = true
	}

	return xOffset, width, ok
}

// CellGetSize obtains the width and height needed to render the column.
// This is used primarily by the TreeView.
func (t treeViewColumn) CellGetSize() (xOffset int, yOffset int, width int, height int) {
	var arg0 *C.GtkTreeViewColumn

	arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	var arg1 C.int
	var arg2 C.int
	var arg3 C.int
	var arg4 C.int

	C.gtk_tree_view_column_cell_get_size(arg0, &arg1, &arg2, &arg3, &arg4)

	var xOffset int
	var yOffset int
	var width int
	var height int

	xOffset = (int)(arg1)
	yOffset = (int)(arg2)
	width = (int)(arg3)
	height = (int)(arg4)

	return xOffset, yOffset, width, height
}

// CellIsVisible returns true if any of the cells packed into the
// @tree_column are visible. For this to be meaningful, you must first
// initialize the cells with gtk_tree_view_column_cell_set_cell_data()
func (t treeViewColumn) CellIsVisible() bool {
	var arg0 *C.GtkTreeViewColumn

	arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	var cret C.gboolean

	cret = C.gtk_tree_view_column_cell_is_visible(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// CellSetCellData sets the cell renderer based on the @tree_model and
// @iter. That is, for every attribute mapping in @tree_column, it will get
// a value from the set column on the @iter, and use that value to set the
// attribute on the cell renderer. This is used primarily by the TreeView.
func (t treeViewColumn) CellSetCellData(treeModel TreeModel, iter *TreeIter, isExpander bool, isExpanded bool) {
	var arg0 *C.GtkTreeViewColumn
	var arg1 *C.GtkTreeModel
	var arg2 *C.GtkTreeIter
	var arg3 C.gboolean
	var arg4 C.gboolean

	arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	arg1 = (*C.GtkTreeModel)(unsafe.Pointer(treeModel.Native()))
	arg2 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))
	if isExpander {
		arg3 = C.gboolean(1)
	}
	if isExpanded {
		arg4 = C.gboolean(1)
	}

	C.gtk_tree_view_column_cell_set_cell_data(arg0, arg1, arg2, arg3, arg4)
}

// Clear unsets all the mappings on all renderers on the @tree_column.
func (t treeViewColumn) Clear() {
	var arg0 *C.GtkTreeViewColumn

	arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	C.gtk_tree_view_column_clear(arg0)
}

// ClearAttributes clears all existing attributes previously set with
// gtk_tree_view_column_set_attributes().
func (t treeViewColumn) ClearAttributes(cellRenderer CellRenderer) {
	var arg0 *C.GtkTreeViewColumn
	var arg1 *C.GtkCellRenderer

	arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(cellRenderer.Native()))

	C.gtk_tree_view_column_clear_attributes(arg0, arg1)
}

// Clicked emits the “clicked” signal on the column. This function will only
// work if @tree_column is clickable.
func (t treeViewColumn) Clicked() {
	var arg0 *C.GtkTreeViewColumn

	arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	C.gtk_tree_view_column_clicked(arg0)
}

// FocusCell sets the current keyboard focus to be at @cell, if the column
// contains 2 or more editable and activatable cells.
func (t treeViewColumn) FocusCell(cell CellRenderer) {
	var arg0 *C.GtkTreeViewColumn
	var arg1 *C.GtkCellRenderer

	arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(cell.Native()))

	C.gtk_tree_view_column_focus_cell(arg0, arg1)
}

// Alignment returns the current x alignment of @tree_column. This value can
// range between 0.0 and 1.0.
func (t treeViewColumn) Alignment() float32 {
	var arg0 *C.GtkTreeViewColumn

	arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	var cret C.float

	cret = C.gtk_tree_view_column_get_alignment(arg0)

	var gfloat float32

	gfloat = (float32)(cret)

	return gfloat
}

// Button returns the button used in the treeview column header
func (t treeViewColumn) Button() Widget {
	var arg0 *C.GtkTreeViewColumn

	arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	var cret *C.GtkWidget

	cret = C.gtk_tree_view_column_get_button(arg0)

	var widget Widget

	widget = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Widget)

	return widget
}

// Clickable returns true if the user can click on the header for the
// column.
func (t treeViewColumn) Clickable() bool {
	var arg0 *C.GtkTreeViewColumn

	arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	var cret C.gboolean

	cret = C.gtk_tree_view_column_get_clickable(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// Expand returns true if the column expands to fill available space.
func (t treeViewColumn) Expand() bool {
	var arg0 *C.GtkTreeViewColumn

	arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	var cret C.gboolean

	cret = C.gtk_tree_view_column_get_expand(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// FixedWidth gets the fixed width of the column. This may not be the actual
// displayed width of the column; for that, use
// gtk_tree_view_column_get_width().
func (t treeViewColumn) FixedWidth() int {
	var arg0 *C.GtkTreeViewColumn

	arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	var cret C.int

	cret = C.gtk_tree_view_column_get_fixed_width(arg0)

	var gint int

	gint = (int)(cret)

	return gint
}

// MaxWidth returns the maximum width in pixels of the @tree_column, or -1
// if no maximum width is set.
func (t treeViewColumn) MaxWidth() int {
	var arg0 *C.GtkTreeViewColumn

	arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	var cret C.int

	cret = C.gtk_tree_view_column_get_max_width(arg0)

	var gint int

	gint = (int)(cret)

	return gint
}

// MinWidth returns the minimum width in pixels of the @tree_column, or -1
// if no minimum width is set.
func (t treeViewColumn) MinWidth() int {
	var arg0 *C.GtkTreeViewColumn

	arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	var cret C.int

	cret = C.gtk_tree_view_column_get_min_width(arg0)

	var gint int

	gint = (int)(cret)

	return gint
}

// Reorderable returns true if the @tree_column can be reordered by the
// user.
func (t treeViewColumn) Reorderable() bool {
	var arg0 *C.GtkTreeViewColumn

	arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	var cret C.gboolean

	cret = C.gtk_tree_view_column_get_reorderable(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// Resizable returns true if the @tree_column can be resized by the end
// user.
func (t treeViewColumn) Resizable() bool {
	var arg0 *C.GtkTreeViewColumn

	arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	var cret C.gboolean

	cret = C.gtk_tree_view_column_get_resizable(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// Sizing returns the current type of @tree_column.
func (t treeViewColumn) Sizing() TreeViewColumnSizing {
	var arg0 *C.GtkTreeViewColumn

	arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	var cret C.GtkTreeViewColumnSizing

	cret = C.gtk_tree_view_column_get_sizing(arg0)

	var treeViewColumnSizing TreeViewColumnSizing

	treeViewColumnSizing = TreeViewColumnSizing(cret)

	return treeViewColumnSizing
}

// SortColumnID gets the logical @sort_column_id that the model sorts on
// when this column is selected for sorting. See
// gtk_tree_view_column_set_sort_column_id().
func (t treeViewColumn) SortColumnID() int {
	var arg0 *C.GtkTreeViewColumn

	arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	var cret C.int

	cret = C.gtk_tree_view_column_get_sort_column_id(arg0)

	var gint int

	gint = (int)(cret)

	return gint
}

// SortIndicator gets the value set by
// gtk_tree_view_column_set_sort_indicator().
func (t treeViewColumn) SortIndicator() bool {
	var arg0 *C.GtkTreeViewColumn

	arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	var cret C.gboolean

	cret = C.gtk_tree_view_column_get_sort_indicator(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// SortOrder gets the value set by gtk_tree_view_column_set_sort_order().
func (t treeViewColumn) SortOrder() SortType {
	var arg0 *C.GtkTreeViewColumn

	arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	var cret C.GtkSortType

	cret = C.gtk_tree_view_column_get_sort_order(arg0)

	var sortType SortType

	sortType = SortType(cret)

	return sortType
}

// Spacing returns the spacing of @tree_column.
func (t treeViewColumn) Spacing() int {
	var arg0 *C.GtkTreeViewColumn

	arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	var cret C.int

	cret = C.gtk_tree_view_column_get_spacing(arg0)

	var gint int

	gint = (int)(cret)

	return gint
}

// Title returns the title of the widget.
func (t treeViewColumn) Title() string {
	var arg0 *C.GtkTreeViewColumn

	arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	var cret *C.char

	cret = C.gtk_tree_view_column_get_title(arg0)

	var utf8 string

	utf8 = C.GoString(cret)

	return utf8
}

// TreeView returns the TreeView wherein @tree_column has been inserted. If
// @column is currently not inserted in any tree view, nil is returned.
func (t treeViewColumn) TreeView() Widget {
	var arg0 *C.GtkTreeViewColumn

	arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	var cret *C.GtkWidget

	cret = C.gtk_tree_view_column_get_tree_view(arg0)

	var widget Widget

	widget = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Widget)

	return widget
}

// Visible returns true if @tree_column is visible.
func (t treeViewColumn) Visible() bool {
	var arg0 *C.GtkTreeViewColumn

	arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	var cret C.gboolean

	cret = C.gtk_tree_view_column_get_visible(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// Widget returns the Widget in the button on the column header. If a custom
// widget has not been set then nil is returned.
func (t treeViewColumn) Widget() Widget {
	var arg0 *C.GtkTreeViewColumn

	arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	var cret *C.GtkWidget

	cret = C.gtk_tree_view_column_get_widget(arg0)

	var widget Widget

	widget = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Widget)

	return widget
}

// Width returns the current size of @tree_column in pixels.
func (t treeViewColumn) Width() int {
	var arg0 *C.GtkTreeViewColumn

	arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	var cret C.int

	cret = C.gtk_tree_view_column_get_width(arg0)

	var gint int

	gint = (int)(cret)

	return gint
}

// XOffset returns the current X offset of @tree_column in pixels.
func (t treeViewColumn) XOffset() int {
	var arg0 *C.GtkTreeViewColumn

	arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	var cret C.int

	cret = C.gtk_tree_view_column_get_x_offset(arg0)

	var gint int

	gint = (int)(cret)

	return gint
}

// PackEnd adds the @cell to end of the column. If @expand is false, then
// the @cell is allocated no more space than it needs. Any unused space is
// divided evenly between cells for which @expand is true.
func (t treeViewColumn) PackEnd(cell CellRenderer, expand bool) {
	var arg0 *C.GtkTreeViewColumn
	var arg1 *C.GtkCellRenderer
	var arg2 C.gboolean

	arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(cell.Native()))
	if expand {
		arg2 = C.gboolean(1)
	}

	C.gtk_tree_view_column_pack_end(arg0, arg1, arg2)
}

// PackStart packs the @cell into the beginning of the column. If @expand is
// false, then the @cell is allocated no more space than it needs. Any
// unused space is divided evenly between cells for which @expand is true.
func (t treeViewColumn) PackStart(cell CellRenderer, expand bool) {
	var arg0 *C.GtkTreeViewColumn
	var arg1 *C.GtkCellRenderer
	var arg2 C.gboolean

	arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(cell.Native()))
	if expand {
		arg2 = C.gboolean(1)
	}

	C.gtk_tree_view_column_pack_start(arg0, arg1, arg2)
}

// QueueResize flags the column, and the cell renderers added to this
// column, to have their sizes renegotiated.
func (t treeViewColumn) QueueResize() {
	var arg0 *C.GtkTreeViewColumn

	arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	C.gtk_tree_view_column_queue_resize(arg0)
}

// SetAlignment sets the alignment of the title or custom widget inside the
// column header. The alignment determines its location inside the button --
// 0.0 for left, 0.5 for center, 1.0 for right.
func (t treeViewColumn) SetAlignment(xalign float32) {
	var arg0 *C.GtkTreeViewColumn
	var arg1 C.float

	arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	arg1 = C.float(xalign)

	C.gtk_tree_view_column_set_alignment(arg0, arg1)
}

// SetCellDataFunc sets the TreeCellDataFunc to use for the column. This
// function is used instead of the standard attributes mapping for setting
// the column value, and should set the value of @tree_column's cell
// renderer as appropriate. @func may be nil to remove an older one.
func (t treeViewColumn) SetCellDataFunc() {
	var arg0 *C.GtkTreeViewColumn

	arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

	C.gtk_tree_view_column_set_cell_data_func(arg0)
}

// SetClickable sets the header to be active if @clickable is true. When the
// header is active, then it can take keyboard focus, and can be clicked.
func (t treeViewColumn) SetClickable(clickable bool) {
	var arg0 *C.GtkTreeViewColumn
	var arg1 C.gboolean

	arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	if clickable {
		arg1 = C.gboolean(1)
	}

	C.gtk_tree_view_column_set_clickable(arg0, arg1)
}

// SetExpand sets the column to take available extra space. This space is
// shared equally amongst all columns that have the expand set to true. If
// no column has this option set, then the last column gets all extra space.
// By default, every column is created with this false.
//
// Along with “fixed-width”, the “expand” property changes when the column
// is resized by the user.
func (t treeViewColumn) SetExpand(expand bool) {
	var arg0 *C.GtkTreeViewColumn
	var arg1 C.gboolean

	arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	if expand {
		arg1 = C.gboolean(1)
	}

	C.gtk_tree_view_column_set_expand(arg0, arg1)
}

// SetFixedWidth: if @fixed_width is not -1, sets the fixed width of
// @tree_column; otherwise unsets it. The effective value of @fixed_width is
// clamped between the minimum and maximum width of the column; however, the
// value stored in the “fixed-width” property is not clamped. If the column
// sizing is K_TREE_VIEW_COLUMN_GROW_ONLY or K_TREE_VIEW_COLUMN_AUTOSIZE,
// setting a fixed width overrides the automatically calculated width. Note
// that @fixed_width is only a hint to GTK; the width actually allocated to
// the column may be greater or less than requested.
//
// Along with “expand”, the “fixed-width” property changes when the column
// is resized by the user.
func (t treeViewColumn) SetFixedWidth(fixedWidth int) {
	var arg0 *C.GtkTreeViewColumn
	var arg1 C.int

	arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	arg1 = C.int(fixedWidth)

	C.gtk_tree_view_column_set_fixed_width(arg0, arg1)
}

// SetMaxWidth sets the maximum width of the @tree_column. If @max_width is
// -1, then the maximum width is unset. Note, the column can actually be
// wider than max width if it’s the last column in a view. In this case, the
// column expands to fill any extra space.
func (t treeViewColumn) SetMaxWidth(maxWidth int) {
	var arg0 *C.GtkTreeViewColumn
	var arg1 C.int

	arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	arg1 = C.int(maxWidth)

	C.gtk_tree_view_column_set_max_width(arg0, arg1)
}

// SetMinWidth sets the minimum width of the @tree_column. If @min_width is
// -1, then the minimum width is unset.
func (t treeViewColumn) SetMinWidth(minWidth int) {
	var arg0 *C.GtkTreeViewColumn
	var arg1 C.int

	arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	arg1 = C.int(minWidth)

	C.gtk_tree_view_column_set_min_width(arg0, arg1)
}

// SetReorderable: if @reorderable is true, then the column can be reordered
// by the end user dragging the header.
func (t treeViewColumn) SetReorderable(reorderable bool) {
	var arg0 *C.GtkTreeViewColumn
	var arg1 C.gboolean

	arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	if reorderable {
		arg1 = C.gboolean(1)
	}

	C.gtk_tree_view_column_set_reorderable(arg0, arg1)
}

// SetResizable: if @resizable is true, then the user can explicitly resize
// the column by grabbing the outer edge of the column button. If resizable
// is true and sizing mode of the column is K_TREE_VIEW_COLUMN_AUTOSIZE,
// then the sizing mode is changed to K_TREE_VIEW_COLUMN_GROW_ONLY.
func (t treeViewColumn) SetResizable(resizable bool) {
	var arg0 *C.GtkTreeViewColumn
	var arg1 C.gboolean

	arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	if resizable {
		arg1 = C.gboolean(1)
	}

	C.gtk_tree_view_column_set_resizable(arg0, arg1)
}

// SetSizing sets the growth behavior of @tree_column to @type.
func (t treeViewColumn) SetSizing(typ TreeViewColumnSizing) {
	var arg0 *C.GtkTreeViewColumn
	var arg1 C.GtkTreeViewColumnSizing

	arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	arg1 = (C.GtkTreeViewColumnSizing)(typ)

	C.gtk_tree_view_column_set_sizing(arg0, arg1)
}

// SetSortColumnID sets the logical @sort_column_id that this column sorts
// on when this column is selected for sorting. Doing so makes the column
// header clickable.
func (t treeViewColumn) SetSortColumnID(sortColumnId int) {
	var arg0 *C.GtkTreeViewColumn
	var arg1 C.int

	arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	arg1 = C.int(sortColumnId)

	C.gtk_tree_view_column_set_sort_column_id(arg0, arg1)
}

// SetSortIndicator: call this function with a @setting of true to display
// an arrow in the header button indicating the column is sorted. Call
// gtk_tree_view_column_set_sort_order() to change the direction of the
// arrow.
func (t treeViewColumn) SetSortIndicator(setting bool) {
	var arg0 *C.GtkTreeViewColumn
	var arg1 C.gboolean

	arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	if setting {
		arg1 = C.gboolean(1)
	}

	C.gtk_tree_view_column_set_sort_indicator(arg0, arg1)
}

// SetSortOrder changes the appearance of the sort indicator.
//
// This does not actually sort the model. Use
// gtk_tree_view_column_set_sort_column_id() if you want automatic sorting
// support. This function is primarily for custom sorting behavior, and
// should be used in conjunction with gtk_tree_sortable_set_sort_column_id()
// to do that. For custom models, the mechanism will vary.
//
// The sort indicator changes direction to indicate normal sort or reverse
// sort. Note that you must have the sort indicator enabled to see anything
// when calling this function; see
// gtk_tree_view_column_set_sort_indicator().
func (t treeViewColumn) SetSortOrder(order SortType) {
	var arg0 *C.GtkTreeViewColumn
	var arg1 C.GtkSortType

	arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	arg1 = (C.GtkSortType)(order)

	C.gtk_tree_view_column_set_sort_order(arg0, arg1)
}

// SetSpacing sets the spacing field of @tree_column, which is the number of
// pixels to place between cell renderers packed into it.
func (t treeViewColumn) SetSpacing(spacing int) {
	var arg0 *C.GtkTreeViewColumn
	var arg1 C.int

	arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	arg1 = C.int(spacing)

	C.gtk_tree_view_column_set_spacing(arg0, arg1)
}

// SetTitle sets the title of the @tree_column. If a custom widget has been
// set, then this value is ignored.
func (t treeViewColumn) SetTitle(title string) {
	var arg0 *C.GtkTreeViewColumn
	var arg1 *C.char

	arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	arg1 = (*C.char)(C.CString(title))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_tree_view_column_set_title(arg0, arg1)
}

// SetVisible sets the visibility of @tree_column.
func (t treeViewColumn) SetVisible(visible bool) {
	var arg0 *C.GtkTreeViewColumn
	var arg1 C.gboolean

	arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	if visible {
		arg1 = C.gboolean(1)
	}

	C.gtk_tree_view_column_set_visible(arg0, arg1)
}

// SetWidget sets the widget in the header to be @widget. If widget is nil,
// then the header button is set with a Label set to the title of
// @tree_column.
func (t treeViewColumn) SetWidget(widget Widget) {
	var arg0 *C.GtkTreeViewColumn
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	C.gtk_tree_view_column_set_widget(arg0, arg1)
}

// Viewport: the Viewport widget acts as an adaptor class, implementing
// scrollability for child widgets that lack their own scrolling capabilities.
// Use GtkViewport to scroll child widgets such as Grid, Box, and so on.
//
// The GtkViewport will start scrolling content only if allocated less than the
// child widget’s minimum size in a given orientation.
//
//
// CSS nodes
//
// GtkViewport has a single CSS node with name `viewport`.
//
//
// Accessibility
//
// GtkViewport uses the GTK_ACCESSIBLE_ROLE_GROUP role.
type Viewport interface {
	Widget
	Accessible
	Buildable
	ConstraintTarget
	Scrollable

	// Child gets the child widget of @viewport.
	Child() Widget
	// ScrollToFocus gets whether the viewport is scrolling to keep the focused
	// child in view. See gtk_viewport_set_scroll_to_focus().
	ScrollToFocus() bool
	// SetChild sets the child widget of @viewport.
	SetChild(child Widget)
	// SetScrollToFocus sets whether the viewport should automatically scroll to
	// keep the focused child in view.
	SetScrollToFocus(scrollToFocus bool)
}

// viewport implements the Viewport interface.
type viewport struct {
	Widget
	Accessible
	Buildable
	ConstraintTarget
	Scrollable
}

var _ Viewport = (*viewport)(nil)

// WrapViewport wraps a GObject to the right type. It is
// primarily used internally.
func WrapViewport(obj *externglib.Object) Viewport {
	return Viewport{
		Widget:           WrapWidget(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
		Scrollable:       WrapScrollable(obj),
	}
}

func marshalViewport(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapViewport(obj), nil
}

// NewViewport constructs a class Viewport.
func NewViewport(hadjustment Adjustment, vadjustment Adjustment) Viewport {
	var arg1 *C.GtkAdjustment
	var arg2 *C.GtkAdjustment

	arg1 = (*C.GtkAdjustment)(unsafe.Pointer(hadjustment.Native()))
	arg2 = (*C.GtkAdjustment)(unsafe.Pointer(vadjustment.Native()))

	var cret C.GtkViewport

	cret = C.gtk_viewport_new(arg1, arg2)

	var viewport Viewport

	viewport = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Viewport)

	return viewport
}

// Child gets the child widget of @viewport.
func (v viewport) Child() Widget {
	var arg0 *C.GtkViewport

	arg0 = (*C.GtkViewport)(unsafe.Pointer(v.Native()))

	var cret *C.GtkWidget

	cret = C.gtk_viewport_get_child(arg0)

	var widget Widget

	widget = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Widget)

	return widget
}

// ScrollToFocus gets whether the viewport is scrolling to keep the focused
// child in view. See gtk_viewport_set_scroll_to_focus().
func (v viewport) ScrollToFocus() bool {
	var arg0 *C.GtkViewport

	arg0 = (*C.GtkViewport)(unsafe.Pointer(v.Native()))

	var cret C.gboolean

	cret = C.gtk_viewport_get_scroll_to_focus(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// SetChild sets the child widget of @viewport.
func (v viewport) SetChild(child Widget) {
	var arg0 *C.GtkViewport
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkViewport)(unsafe.Pointer(v.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_viewport_set_child(arg0, arg1)
}

// SetScrollToFocus sets whether the viewport should automatically scroll to
// keep the focused child in view.
func (v viewport) SetScrollToFocus(scrollToFocus bool) {
	var arg0 *C.GtkViewport
	var arg1 C.gboolean

	arg0 = (*C.GtkViewport)(unsafe.Pointer(v.Native()))
	if scrollToFocus {
		arg1 = C.gboolean(1)
	}

	C.gtk_viewport_set_scroll_to_focus(arg0, arg1)
}

// VolumeButton is a subclass of ScaleButton that has been tailored for use as a
// volume control widget with suitable icons, tooltips and accessible labels.
type VolumeButton interface {
	ScaleButton
	Accessible
	Buildable
	ConstraintTarget
	Orientable
}

// volumeButton implements the VolumeButton interface.
type volumeButton struct {
	ScaleButton
	Accessible
	Buildable
	ConstraintTarget
	Orientable
}

var _ VolumeButton = (*volumeButton)(nil)

// WrapVolumeButton wraps a GObject to the right type. It is
// primarily used internally.
func WrapVolumeButton(obj *externglib.Object) VolumeButton {
	return VolumeButton{
		ScaleButton:      WrapScaleButton(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
		Orientable:       WrapOrientable(obj),
	}
}

func marshalVolumeButton(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapVolumeButton(obj), nil
}

// NewVolumeButton constructs a class VolumeButton.
func NewVolumeButton() VolumeButton {
	var cret C.GtkVolumeButton

	cret = C.gtk_volume_button_new()

	var volumeButton VolumeButton

	volumeButton = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(VolumeButton)

	return volumeButton
}
