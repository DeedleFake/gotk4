// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"unsafe"

	"github.com/diamondburned/gotk4/internal/gerror"
	"github.com/diamondburned/gotk4/internal/gextras"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: glib-2.0 gtk4
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <gtk/gtk.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_print_error_get_type()), F: marshalPrintError},
		{T: externglib.Type(C.gtk_print_operation_action_get_type()), F: marshalPrintOperationAction},
		{T: externglib.Type(C.gtk_print_operation_result_get_type()), F: marshalPrintOperationResult},
		{T: externglib.Type(C.gtk_print_status_get_type()), F: marshalPrintStatus},
		{T: externglib.Type(C.gtk_print_operation_get_type()), F: marshalPrintOperation},
	})
}

// PrintError: error codes that identify various errors that can occur while
// using the GTK printing support.
type PrintError int

const (
	// PrintErrorGeneral: an unspecified error occurred.
	PrintErrorGeneral PrintError = 0
	// PrintErrorInternalError: an internal error occurred.
	PrintErrorInternalError PrintError = 1
	// PrintErrorNOMEM: a memory allocation failed.
	PrintErrorNOMEM PrintError = 2
	// PrintErrorInvalidFile: an error occurred while loading a page setup or
	// paper size from a key file.
	PrintErrorInvalidFile PrintError = 3
)

func marshalPrintError(p uintptr) (interface{}, error) {
	return PrintError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PrintOperationAction determines what action the print operation should
// perform.
//
// A parameter of this typs is passed to [method@Gtk.PrintOperation.run].
type PrintOperationAction int

const (
	// PrintOperationActionPrintDialog: show the print dialog.
	PrintOperationActionPrintDialog PrintOperationAction = 0
	// PrintOperationActionPrint: start to print without showing the print
	// dialog, based on the current print settings.
	PrintOperationActionPrint PrintOperationAction = 1
	// PrintOperationActionPreview: show the print preview.
	PrintOperationActionPreview PrintOperationAction = 2
	// PrintOperationActionExport: export to a file. This requires the
	// export-filename property to be set.
	PrintOperationActionExport PrintOperationAction = 3
)

func marshalPrintOperationAction(p uintptr) (interface{}, error) {
	return PrintOperationAction(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PrintOperationResult: the result of a print operation.
//
// A value of this type is returned by [method@Gtk.PrintOperation.run].
type PrintOperationResult int

const (
	// PrintOperationResultError: an error has occurred.
	PrintOperationResultError PrintOperationResult = 0
	// PrintOperationResultApply: the print settings should be stored.
	PrintOperationResultApply PrintOperationResult = 1
	// PrintOperationResultCancel: the print operation has been canceled, the
	// print settings should not be stored.
	PrintOperationResultCancel PrintOperationResult = 2
	// PrintOperationResultInProgress: the print operation is not complete yet.
	// This value will only be returned when running asynchronously.
	PrintOperationResultInProgress PrintOperationResult = 3
)

func marshalPrintOperationResult(p uintptr) (interface{}, error) {
	return PrintOperationResult(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PrintStatus: the status gives a rough indication of the completion of a
// running print operation.
type PrintStatus int

const (
	// PrintStatusInitial: the printing has not started yet; this status is set
	// initially, and while the print dialog is shown.
	PrintStatusInitial PrintStatus = 0
	// PrintStatusPreparing: this status is set while the begin-print signal is
	// emitted and during pagination.
	PrintStatusPreparing PrintStatus = 1
	// PrintStatusGeneratingData: this status is set while the pages are being
	// rendered.
	PrintStatusGeneratingData PrintStatus = 2
	// PrintStatusSendingData: the print job is being sent off to the printer.
	PrintStatusSendingData PrintStatus = 3
	// PrintStatusPending: the print job has been sent to the printer, but is
	// not printed for some reason, e.g. the printer may be stopped.
	PrintStatusPending PrintStatus = 4
	// PrintStatusPendingIssue: some problem has occurred during printing, e.g.
	// a paper jam.
	PrintStatusPendingIssue PrintStatus = 5
	// PrintStatusPrinting: the printer is processing the print job.
	PrintStatusPrinting PrintStatus = 6
	// PrintStatusFinished: the printing has been completed successfully.
	PrintStatusFinished PrintStatus = 7
	// PrintStatusFinishedAborted: the printing has been aborted.
	PrintStatusFinishedAborted PrintStatus = 8
)

func marshalPrintStatus(p uintptr) (interface{}, error) {
	return PrintStatus(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PrintRunPageSetupDialog runs a page setup dialog, letting the user modify the
// values from @page_setup. If the user cancels the dialog, the returned
// PageSetup is identical to the passed in @page_setup, otherwise it contains
// the modifications done in the dialog.
//
// Note that this function may use a recursive mainloop to show the page setup
// dialog. See gtk_print_run_page_setup_dialog_async() if this is a problem.
func PrintRunPageSetupDialog(parent Window, pageSetup PageSetup, settings PrintSettings) PageSetup {
	var _arg1 *C.GtkWindow        // out
	var _arg2 *C.GtkPageSetup     // out
	var _arg3 *C.GtkPrintSettings // out

	_arg1 = (*C.GtkWindow)(unsafe.Pointer(parent.Native()))
	_arg2 = (*C.GtkPageSetup)(unsafe.Pointer(pageSetup.Native()))
	_arg3 = (*C.GtkPrintSettings)(unsafe.Pointer(settings.Native()))

	var _cret *C.GtkPageSetup // in

	_cret = C.gtk_print_run_page_setup_dialog(_arg1, _arg2, _arg3)

	var _pageSetup PageSetup // out

	_pageSetup = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret.Native()))).(PageSetup)

	return _pageSetup
}

// PrintOperation: `GtkPrintOperation` is the high-level, portable printing API.
//
// It looks a bit different than other GTK dialogs such as the `GtkFileChooser`,
// since some platforms don’t expose enough infrastructure to implement a good
// print dialog. On such platforms, `GtkPrintOperation` uses the native print
// dialog. On platforms which do not provide a native print dialog, GTK uses its
// own, see [class@Gtk.PrintUnixDialog].
//
// The typical way to use the high-level printing API is to create a
// `GtkPrintOperation` object with [ctor@Gtk.PrintOperation.new] when the user
// selects to print. Then you set some properties on it, e.g. the page size, any
// [class@Gtk.PrintSettings] from previous print operations, the number of
// pages, the current page, etc.
//
// Then you start the print operation by calling
// [method@Gtk.PrintOperation.run]. It will then show a dialog, let the user
// select a printer and options. When the user finished the dialog, various
// signals will be emitted on the `GtkPrintOperation`, the main one being
// [signal@Gtk.PrintOperation::draw-page], which you are supposed to handle and
// render the page on the provided [class@Gtk.PrintContext] using Cairo.
//
//
// The high-level printing API
//
// “`c static GtkPrintSettings *settings = NULL;
//
// static void do_print (void) { GtkPrintOperation *print;
// GtkPrintOperationResult res;
//
//    print = gtk_print_operation_new ();
//
//    if (settings != NULL)
//      gtk_print_operation_set_print_settings (print, settings);
//
//    g_signal_connect (print, "begin_print", G_CALLBACK (begin_print), NULL);
//    g_signal_connect (print, "draw_page", G_CALLBACK (draw_page), NULL);
//
//    res = gtk_print_operation_run (print, GTK_PRINT_OPERATION_ACTION_PRINT_DIALOG,
//                                   GTK_WINDOW (main_window), NULL);
//
//    if (res == GTK_PRINT_OPERATION_RESULT_APPLY)
//      {
//        if (settings != NULL)
//          g_object_unref (settings);
//        settings = g_object_ref (gtk_print_operation_get_print_settings (print));
//      }
//
//    g_object_unref (print);
//
// } “`
//
// By default `GtkPrintOperation` uses an external application to do print
// preview. To implement a custom print preview, an application must connect to
// the preview signal. The functions
// [method@Gtk.PrintOperationPreview.render_page],
// [method@Gtk.PrintOperationPreview.end_preview] and
// [method@Gtk.PrintOperationPreview.is_selected] are useful when implementing a
// print preview.
type PrintOperation interface {
	gextras.Objector
	PrintOperationPreview

	// Cancel cancels a running print operation.
	//
	// This function may be called from a
	// [signal@Gtk.PrintOperation::begin-print],
	// [signal@Gtk.PrintOperation::paginate] or
	// [signal@Gtk.PrintOperation::draw-page] signal handler to stop the
	// currently running print operation.
	Cancel()
	// DrawPageFinish: signal that drawing of particular page is complete.
	//
	// It is called after completion of page drawing (e.g. drawing in another
	// thread). If [method@Gtk.PrintOperation.set_defer_drawing] was called
	// before, then this function has to be called by application. Otherwise it
	// is called by GTK itself.
	DrawPageFinish()
	// DefaultPageSetup returns the default page setup.
	DefaultPageSetup() PageSetup
	// EmbedPageSetup gets whether page setup selection combos are embedded
	EmbedPageSetup() bool
	// Error: call this when the result of a print operation is
	// GTK_PRINT_OPERATION_RESULT_ERROR.
	//
	// It can be called either after [method@Gtk.PrintOperation.run] returns, or
	// in the [signal@Gtk.PrintOperation::done] signal handler.
	//
	// The returned `GError` will contain more details on what went wrong.
	Error() error
	// HasSelection gets whether there is a selection.
	HasSelection() bool
	// NPagesToPrint returns the number of pages that will be printed.
	//
	// Note that this value is set during print preparation phase
	// (GTK_PRINT_STATUS_PREPARING), so this function should never be called
	// before the data generation phase (GTK_PRINT_STATUS_GENERATING_DATA). You
	// can connect to the [signal@Gtk.PrintOperation::status-changed] signal and
	// call gtk_print_operation_get_n_pages_to_print() when print status is
	// GTK_PRINT_STATUS_GENERATING_DATA.
	//
	// This is typically used to track the progress of print operation.
	NPagesToPrint() int
	// PrintSettings returns the current print settings.
	//
	// Note that the return value is nil until either
	// [method@Gtk.PrintOperation.set_print_settings] or
	// [method@Gtk.PrintOperation.run] have been called.
	PrintSettings() PrintSettings
	// Status returns the status of the print operation.
	//
	// Also see [method@Gtk.PrintOperation.get_status_string].
	Status() PrintStatus
	// StatusString returns a string representation of the status of the print
	// operation.
	//
	// The string is translated and suitable for displaying the print status
	// e.g. in a `GtkStatusbar`.
	//
	// Use [method@Gtk.PrintOperation.get_status] to obtain a status value that
	// is suitable for programmatic use.
	StatusString() string
	// SupportSelection gets whether the application supports print of selection
	SupportSelection() bool
	// IsFinished: a convenience function to find out if the print operation is
	// finished.
	//
	// a print operation is finished if its status is either
	// GTK_PRINT_STATUS_FINISHED or GTK_PRINT_STATUS_FINISHED_ABORTED.
	//
	// Note: when you enable print status tracking the print operation can be in
	// a non-finished state even after done has been called, as the operation
	// status then tracks the print job status on the printer.
	IsFinished() bool
	// Run runs the print operation.
	//
	// Normally that this function does not return until the rendering of all
	// pages is complete. You can connect to the
	// [signal@Gtk.PrintOperation::status-changed] signal on @op to obtain some
	// information about the progress of the print operation.
	//
	// Furthermore, it may use a recursive mainloop to show the print dialog.
	//
	// If you set the [Gtk.PrintOperation:allow-async] property, the operation
	// will run asynchronously if this is supported on the platform. The
	// [signal@Gtk.PrintOperation::done] signal will be emitted with the result
	// of the operation when the it is done (i.e. when the dialog is canceled,
	// or when the print succeeds or fails).
	//
	// “`c if (settings != NULL) gtk_print_operation_set_print_settings (print,
	// settings);
	//
	// if (page_setup != NULL) gtk_print_operation_set_default_page_setup
	// (print, page_setup);
	//
	// g_signal_connect (print, "begin-print", G_CALLBACK (begin_print), &data);
	// g_signal_connect (print, "draw-page", G_CALLBACK (draw_page), &data);
	//
	// res = gtk_print_operation_run (print,
	// GTK_PRINT_OPERATION_ACTION_PRINT_DIALOG, parent, &error);
	//
	// if (res == GTK_PRINT_OPERATION_RESULT_ERROR) { error_dialog =
	// gtk_message_dialog_new (GTK_WINDOW (parent),
	// GTK_DIALOG_DESTROY_WITH_PARENT, GTK_MESSAGE_ERROR, GTK_BUTTONS_CLOSE,
	// "Error printing file:\ns", error->message); g_signal_connect
	// (error_dialog, "response", G_CALLBACK (gtk_window_destroy), NULL);
	// gtk_widget_show (error_dialog); g_error_free (error); } else if (res ==
	// GTK_PRINT_OPERATION_RESULT_APPLY) { if (settings != NULL) g_object_unref
	// (settings); settings = g_object_ref
	// (gtk_print_operation_get_print_settings (print)); } “`
	//
	// Note that gtk_print_operation_run() can only be called once on a given
	// `GtkPrintOperation`.
	Run(action PrintOperationAction, parent Window) (PrintOperationResult, error)
	// SetAllowAsync sets whether gtk_print_operation_run() may return before
	// the print operation is completed.
	//
	// Note that some platforms may not allow asynchronous operation.
	SetAllowAsync(allowAsync bool)
	// SetCurrentPage sets the current page.
	//
	// If this is called before [method@Gtk.PrintOperation.run], the user will
	// be able to select to print only the current page.
	//
	// Note that this only makes sense for pre-paginated documents.
	SetCurrentPage(currentPage int)
	// SetCustomTabLabel sets the label for the tab holding custom widgets.
	SetCustomTabLabel(label string)
	// SetDefaultPageSetup makes @default_page_setup the default page setup for
	// @op.
	//
	// This page setup will be used by [method@Gtk.PrintOperation.run], but it
	// can be overridden on a per-page basis by connecting to the
	// [signal@Gtk.PrintOperation::request-page-setup] signal.
	SetDefaultPageSetup(defaultPageSetup PageSetup)
	// SetDeferDrawing sets up the `GtkPrintOperation` to wait for calling of
	// [method@Gtk.PrintOperation.draw_page_finish from application.
	//
	// This can be used for drawing page in another thread.
	//
	// This function must be called in the callback of the
	// [signal@Gtk.PrintOperation::draw-page] signal.
	SetDeferDrawing()
	// SetEmbedPageSetup: embed page size combo box and orientation combo box
	// into page setup page.
	//
	// Selected page setup is stored as default page setup in
	// `GtkPrintOperation`.
	SetEmbedPageSetup(embed bool)
	// SetExportFilename sets up the `GtkPrintOperation` to generate a file
	// instead of showing the print dialog.
	//
	// The intended use of this function is for implementing “Export to PDF”
	// actions. Currently, PDF is the only supported format.
	//
	// “Print to PDF” support is independent of this and is done by letting the
	// user pick the “Print to PDF” item from the list of printers in the print
	// dialog.
	SetExportFilename(filename string)
	// SetHasSelection sets whether there is a selection to print.
	//
	// Application has to set number of pages to which the selection will draw
	// by [method@Gtk.PrintOperation.set_n_pages] in a handler for the
	// [signal@Gtk.PrintOperation::begin-print] signal.
	SetHasSelection(hasSelection bool)
	// SetJobName sets the name of the print job.
	//
	// The name is used to identify the job (e.g. in monitoring applications
	// like eggcups).
	//
	// If you don’t set a job name, GTK picks a default one by numbering
	// successive print jobs.
	SetJobName(jobName string)
	// SetNPages sets the number of pages in the document.
	//
	// This must be set to a positive number before the rendering starts. It may
	// be set in a [signal@Gtk.PrintOperation::begin-print] signal handler.
	//
	// Note that the page numbers passed to the
	// [signal@Gtk.PrintOperation::request-page-setup] and
	// [signal@Gtk.PrintOperation::draw-page] signals are 0-based, i.e. if the
	// user chooses to print all pages, the last ::draw-page signal will be for
	// page @n_pages - 1.
	SetNPages(nPages int)
	// SetPrintSettings sets the print settings for @op.
	//
	// This is typically used to re-establish print settings from a previous
	// print operation, see [method@Gtk.PrintOperation.run].
	SetPrintSettings(printSettings PrintSettings)
	// SetShowProgress: if @show_progress is true, the print operation will show
	// a progress dialog during the print operation.
	SetShowProgress(showProgress bool)
	// SetSupportSelection sets whether selection is supported by
	// `GtkPrintOperation`.
	SetSupportSelection(supportSelection bool)
	// SetTrackPrintStatus: if track_status is true, the print operation will
	// try to continue report on the status of the print job in the printer
	// queues and printer.
	//
	// This can allow your application to show things like “out of paper”
	// issues, and when the print job actually reaches the printer.
	//
	// This function is often implemented using some form of polling, so it
	// should not be enabled unless needed.
	SetTrackPrintStatus(trackStatus bool)
	// SetUnit sets up the transformation for the cairo context obtained from
	// `GtkPrintContext` in such a way that distances are measured in units of
	// @unit.
	SetUnit(unit Unit)
	// SetUseFullPage: if @full_page is true, the transformation for the cairo
	// context obtained from `GtkPrintContext` puts the origin at the top left
	// corner of the page.
	//
	// This may not be the top left corner of the sheet, depending on page
	// orientation and the number of pages per sheet). Otherwise, the origin is
	// at the top left corner of the imageable area (i.e. inside the margins).
	SetUseFullPage(fullPage bool)
}

// printOperation implements the PrintOperation class.
type printOperation struct {
	gextras.Objector
	PrintOperationPreview
}

var _ PrintOperation = (*printOperation)(nil)

// WrapPrintOperation wraps a GObject to the right type. It is
// primarily used internally.
func WrapPrintOperation(obj *externglib.Object) PrintOperation {
	return printOperation{
		Objector:              obj,
		PrintOperationPreview: WrapPrintOperationPreview(obj),
	}
}

func marshalPrintOperation(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPrintOperation(obj), nil
}

// NewPrintOperation constructs a class PrintOperation.
func NewPrintOperation() PrintOperation {
	var _cret C.GtkPrintOperation // in

	_cret = C.gtk_print_operation_new()

	var _printOperation PrintOperation // out

	_printOperation = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret.Native()))).(PrintOperation)

	return _printOperation
}

// Cancel cancels a running print operation.
//
// This function may be called from a
// [signal@Gtk.PrintOperation::begin-print],
// [signal@Gtk.PrintOperation::paginate] or
// [signal@Gtk.PrintOperation::draw-page] signal handler to stop the
// currently running print operation.
func (o printOperation) Cancel() {
	var _arg0 *C.GtkPrintOperation // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))

	C.gtk_print_operation_cancel(_arg0)
}

// DrawPageFinish: signal that drawing of particular page is complete.
//
// It is called after completion of page drawing (e.g. drawing in another
// thread). If [method@Gtk.PrintOperation.set_defer_drawing] was called
// before, then this function has to be called by application. Otherwise it
// is called by GTK itself.
func (o printOperation) DrawPageFinish() {
	var _arg0 *C.GtkPrintOperation // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))

	C.gtk_print_operation_draw_page_finish(_arg0)
}

// DefaultPageSetup returns the default page setup.
func (o printOperation) DefaultPageSetup() PageSetup {
	var _arg0 *C.GtkPrintOperation // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))

	var _cret *C.GtkPageSetup // in

	_cret = C.gtk_print_operation_get_default_page_setup(_arg0)

	var _pageSetup PageSetup // out

	_pageSetup = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret.Native()))).(PageSetup)

	return _pageSetup
}

// EmbedPageSetup gets whether page setup selection combos are embedded
func (o printOperation) EmbedPageSetup() bool {
	var _arg0 *C.GtkPrintOperation // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))

	var _cret C.gboolean // in

	_cret = C.gtk_print_operation_get_embed_page_setup(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Error: call this when the result of a print operation is
// GTK_PRINT_OPERATION_RESULT_ERROR.
//
// It can be called either after [method@Gtk.PrintOperation.run] returns, or
// in the [signal@Gtk.PrintOperation::done] signal handler.
//
// The returned `GError` will contain more details on what went wrong.
func (o printOperation) Error() error {
	var _arg0 *C.GtkPrintOperation // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))

	var _cerr *C.GError // in

	C.gtk_print_operation_get_error(_arg0, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// HasSelection gets whether there is a selection.
func (o printOperation) HasSelection() bool {
	var _arg0 *C.GtkPrintOperation // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))

	var _cret C.gboolean // in

	_cret = C.gtk_print_operation_get_has_selection(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// NPagesToPrint returns the number of pages that will be printed.
//
// Note that this value is set during print preparation phase
// (GTK_PRINT_STATUS_PREPARING), so this function should never be called
// before the data generation phase (GTK_PRINT_STATUS_GENERATING_DATA). You
// can connect to the [signal@Gtk.PrintOperation::status-changed] signal and
// call gtk_print_operation_get_n_pages_to_print() when print status is
// GTK_PRINT_STATUS_GENERATING_DATA.
//
// This is typically used to track the progress of print operation.
func (o printOperation) NPagesToPrint() int {
	var _arg0 *C.GtkPrintOperation // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))

	var _cret C.int // in

	_cret = C.gtk_print_operation_get_n_pages_to_print(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// PrintSettings returns the current print settings.
//
// Note that the return value is nil until either
// [method@Gtk.PrintOperation.set_print_settings] or
// [method@Gtk.PrintOperation.run] have been called.
func (o printOperation) PrintSettings() PrintSettings {
	var _arg0 *C.GtkPrintOperation // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))

	var _cret *C.GtkPrintSettings // in

	_cret = C.gtk_print_operation_get_print_settings(_arg0)

	var _printSettings PrintSettings // out

	_printSettings = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret.Native()))).(PrintSettings)

	return _printSettings
}

// Status returns the status of the print operation.
//
// Also see [method@Gtk.PrintOperation.get_status_string].
func (o printOperation) Status() PrintStatus {
	var _arg0 *C.GtkPrintOperation // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))

	var _cret C.GtkPrintStatus // in

	_cret = C.gtk_print_operation_get_status(_arg0)

	var _printStatus PrintStatus // out

	_printStatus = PrintStatus(_cret)

	return _printStatus
}

// StatusString returns a string representation of the status of the print
// operation.
//
// The string is translated and suitable for displaying the print status
// e.g. in a `GtkStatusbar`.
//
// Use [method@Gtk.PrintOperation.get_status] to obtain a status value that
// is suitable for programmatic use.
func (o printOperation) StatusString() string {
	var _arg0 *C.GtkPrintOperation // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))

	var _cret *C.char // in

	_cret = C.gtk_print_operation_get_status_string(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// SupportSelection gets whether the application supports print of selection
func (o printOperation) SupportSelection() bool {
	var _arg0 *C.GtkPrintOperation // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))

	var _cret C.gboolean // in

	_cret = C.gtk_print_operation_get_support_selection(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsFinished: a convenience function to find out if the print operation is
// finished.
//
// a print operation is finished if its status is either
// GTK_PRINT_STATUS_FINISHED or GTK_PRINT_STATUS_FINISHED_ABORTED.
//
// Note: when you enable print status tracking the print operation can be in
// a non-finished state even after done has been called, as the operation
// status then tracks the print job status on the printer.
func (o printOperation) IsFinished() bool {
	var _arg0 *C.GtkPrintOperation // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))

	var _cret C.gboolean // in

	_cret = C.gtk_print_operation_is_finished(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Run runs the print operation.
//
// Normally that this function does not return until the rendering of all
// pages is complete. You can connect to the
// [signal@Gtk.PrintOperation::status-changed] signal on @op to obtain some
// information about the progress of the print operation.
//
// Furthermore, it may use a recursive mainloop to show the print dialog.
//
// If you set the [Gtk.PrintOperation:allow-async] property, the operation
// will run asynchronously if this is supported on the platform. The
// [signal@Gtk.PrintOperation::done] signal will be emitted with the result
// of the operation when the it is done (i.e. when the dialog is canceled,
// or when the print succeeds or fails).
//
// “`c if (settings != NULL) gtk_print_operation_set_print_settings (print,
// settings);
//
// if (page_setup != NULL) gtk_print_operation_set_default_page_setup
// (print, page_setup);
//
// g_signal_connect (print, "begin-print", G_CALLBACK (begin_print), &data);
// g_signal_connect (print, "draw-page", G_CALLBACK (draw_page), &data);
//
// res = gtk_print_operation_run (print,
// GTK_PRINT_OPERATION_ACTION_PRINT_DIALOG, parent, &error);
//
// if (res == GTK_PRINT_OPERATION_RESULT_ERROR) { error_dialog =
// gtk_message_dialog_new (GTK_WINDOW (parent),
// GTK_DIALOG_DESTROY_WITH_PARENT, GTK_MESSAGE_ERROR, GTK_BUTTONS_CLOSE,
// "Error printing file:\ns", error->message); g_signal_connect
// (error_dialog, "response", G_CALLBACK (gtk_window_destroy), NULL);
// gtk_widget_show (error_dialog); g_error_free (error); } else if (res ==
// GTK_PRINT_OPERATION_RESULT_APPLY) { if (settings != NULL) g_object_unref
// (settings); settings = g_object_ref
// (gtk_print_operation_get_print_settings (print)); } “`
//
// Note that gtk_print_operation_run() can only be called once on a given
// `GtkPrintOperation`.
func (o printOperation) Run(action PrintOperationAction, parent Window) (PrintOperationResult, error) {
	var _arg0 *C.GtkPrintOperation      // out
	var _arg1 C.GtkPrintOperationAction // out
	var _arg2 *C.GtkWindow              // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))
	_arg1 = (C.GtkPrintOperationAction)(action)
	_arg2 = (*C.GtkWindow)(unsafe.Pointer(parent.Native()))

	var _cret C.GtkPrintOperationResult // in
	var _cerr *C.GError                 // in

	_cret = C.gtk_print_operation_run(_arg0, _arg1, _arg2, &_cerr)

	var _printOperationResult PrintOperationResult // out
	var _goerr error                               // out

	_printOperationResult = PrintOperationResult(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _printOperationResult, _goerr
}

// SetAllowAsync sets whether gtk_print_operation_run() may return before
// the print operation is completed.
//
// Note that some platforms may not allow asynchronous operation.
func (o printOperation) SetAllowAsync(allowAsync bool) {
	var _arg0 *C.GtkPrintOperation // out
	var _arg1 C.gboolean           // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))
	if allowAsync {
		_arg1 = C.TRUE
	}

	C.gtk_print_operation_set_allow_async(_arg0, _arg1)
}

// SetCurrentPage sets the current page.
//
// If this is called before [method@Gtk.PrintOperation.run], the user will
// be able to select to print only the current page.
//
// Note that this only makes sense for pre-paginated documents.
func (o printOperation) SetCurrentPage(currentPage int) {
	var _arg0 *C.GtkPrintOperation // out
	var _arg1 C.int                // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))
	_arg1 = C.int(currentPage)

	C.gtk_print_operation_set_current_page(_arg0, _arg1)
}

// SetCustomTabLabel sets the label for the tab holding custom widgets.
func (o printOperation) SetCustomTabLabel(label string) {
	var _arg0 *C.GtkPrintOperation // out
	var _arg1 *C.char              // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))
	_arg1 = (*C.char)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_print_operation_set_custom_tab_label(_arg0, _arg1)
}

// SetDefaultPageSetup makes @default_page_setup the default page setup for
// @op.
//
// This page setup will be used by [method@Gtk.PrintOperation.run], but it
// can be overridden on a per-page basis by connecting to the
// [signal@Gtk.PrintOperation::request-page-setup] signal.
func (o printOperation) SetDefaultPageSetup(defaultPageSetup PageSetup) {
	var _arg0 *C.GtkPrintOperation // out
	var _arg1 *C.GtkPageSetup      // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))
	_arg1 = (*C.GtkPageSetup)(unsafe.Pointer(defaultPageSetup.Native()))

	C.gtk_print_operation_set_default_page_setup(_arg0, _arg1)
}

// SetDeferDrawing sets up the `GtkPrintOperation` to wait for calling of
// [method@Gtk.PrintOperation.draw_page_finish from application.
//
// This can be used for drawing page in another thread.
//
// This function must be called in the callback of the
// [signal@Gtk.PrintOperation::draw-page] signal.
func (o printOperation) SetDeferDrawing() {
	var _arg0 *C.GtkPrintOperation // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))

	C.gtk_print_operation_set_defer_drawing(_arg0)
}

// SetEmbedPageSetup: embed page size combo box and orientation combo box
// into page setup page.
//
// Selected page setup is stored as default page setup in
// `GtkPrintOperation`.
func (o printOperation) SetEmbedPageSetup(embed bool) {
	var _arg0 *C.GtkPrintOperation // out
	var _arg1 C.gboolean           // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))
	if embed {
		_arg1 = C.TRUE
	}

	C.gtk_print_operation_set_embed_page_setup(_arg0, _arg1)
}

// SetExportFilename sets up the `GtkPrintOperation` to generate a file
// instead of showing the print dialog.
//
// The intended use of this function is for implementing “Export to PDF”
// actions. Currently, PDF is the only supported format.
//
// “Print to PDF” support is independent of this and is done by letting the
// user pick the “Print to PDF” item from the list of printers in the print
// dialog.
func (o printOperation) SetExportFilename(filename string) {
	var _arg0 *C.GtkPrintOperation // out
	var _arg1 *C.char              // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))
	_arg1 = (*C.char)(C.CString(filename))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_print_operation_set_export_filename(_arg0, _arg1)
}

// SetHasSelection sets whether there is a selection to print.
//
// Application has to set number of pages to which the selection will draw
// by [method@Gtk.PrintOperation.set_n_pages] in a handler for the
// [signal@Gtk.PrintOperation::begin-print] signal.
func (o printOperation) SetHasSelection(hasSelection bool) {
	var _arg0 *C.GtkPrintOperation // out
	var _arg1 C.gboolean           // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))
	if hasSelection {
		_arg1 = C.TRUE
	}

	C.gtk_print_operation_set_has_selection(_arg0, _arg1)
}

// SetJobName sets the name of the print job.
//
// The name is used to identify the job (e.g. in monitoring applications
// like eggcups).
//
// If you don’t set a job name, GTK picks a default one by numbering
// successive print jobs.
func (o printOperation) SetJobName(jobName string) {
	var _arg0 *C.GtkPrintOperation // out
	var _arg1 *C.char              // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))
	_arg1 = (*C.char)(C.CString(jobName))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_print_operation_set_job_name(_arg0, _arg1)
}

// SetNPages sets the number of pages in the document.
//
// This must be set to a positive number before the rendering starts. It may
// be set in a [signal@Gtk.PrintOperation::begin-print] signal handler.
//
// Note that the page numbers passed to the
// [signal@Gtk.PrintOperation::request-page-setup] and
// [signal@Gtk.PrintOperation::draw-page] signals are 0-based, i.e. if the
// user chooses to print all pages, the last ::draw-page signal will be for
// page @n_pages - 1.
func (o printOperation) SetNPages(nPages int) {
	var _arg0 *C.GtkPrintOperation // out
	var _arg1 C.int                // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))
	_arg1 = C.int(nPages)

	C.gtk_print_operation_set_n_pages(_arg0, _arg1)
}

// SetPrintSettings sets the print settings for @op.
//
// This is typically used to re-establish print settings from a previous
// print operation, see [method@Gtk.PrintOperation.run].
func (o printOperation) SetPrintSettings(printSettings PrintSettings) {
	var _arg0 *C.GtkPrintOperation // out
	var _arg1 *C.GtkPrintSettings  // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))
	_arg1 = (*C.GtkPrintSettings)(unsafe.Pointer(printSettings.Native()))

	C.gtk_print_operation_set_print_settings(_arg0, _arg1)
}

// SetShowProgress: if @show_progress is true, the print operation will show
// a progress dialog during the print operation.
func (o printOperation) SetShowProgress(showProgress bool) {
	var _arg0 *C.GtkPrintOperation // out
	var _arg1 C.gboolean           // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))
	if showProgress {
		_arg1 = C.TRUE
	}

	C.gtk_print_operation_set_show_progress(_arg0, _arg1)
}

// SetSupportSelection sets whether selection is supported by
// `GtkPrintOperation`.
func (o printOperation) SetSupportSelection(supportSelection bool) {
	var _arg0 *C.GtkPrintOperation // out
	var _arg1 C.gboolean           // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))
	if supportSelection {
		_arg1 = C.TRUE
	}

	C.gtk_print_operation_set_support_selection(_arg0, _arg1)
}

// SetTrackPrintStatus: if track_status is true, the print operation will
// try to continue report on the status of the print job in the printer
// queues and printer.
//
// This can allow your application to show things like “out of paper”
// issues, and when the print job actually reaches the printer.
//
// This function is often implemented using some form of polling, so it
// should not be enabled unless needed.
func (o printOperation) SetTrackPrintStatus(trackStatus bool) {
	var _arg0 *C.GtkPrintOperation // out
	var _arg1 C.gboolean           // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))
	if trackStatus {
		_arg1 = C.TRUE
	}

	C.gtk_print_operation_set_track_print_status(_arg0, _arg1)
}

// SetUnit sets up the transformation for the cairo context obtained from
// `GtkPrintContext` in such a way that distances are measured in units of
// @unit.
func (o printOperation) SetUnit(unit Unit) {
	var _arg0 *C.GtkPrintOperation // out
	var _arg1 C.GtkUnit            // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))
	_arg1 = (C.GtkUnit)(unit)

	C.gtk_print_operation_set_unit(_arg0, _arg1)
}

// SetUseFullPage: if @full_page is true, the transformation for the cairo
// context obtained from `GtkPrintContext` puts the origin at the top left
// corner of the page.
//
// This may not be the top left corner of the sheet, depending on page
// orientation and the number of pages per sheet). Otherwise, the origin is
// at the top left corner of the imageable area (i.e. inside the margins).
func (o printOperation) SetUseFullPage(fullPage bool) {
	var _arg0 *C.GtkPrintOperation // out
	var _arg1 C.gboolean           // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))
	if fullPage {
		_arg1 = C.TRUE
	}

	C.gtk_print_operation_set_use_full_page(_arg0, _arg1)
}
