// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gtk4
// #cgo CFLAGS: -Wno-deprecated-declarations
//
// #include <glib-object.h>
// #include <gtk/gtk.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_info_bar_get_type()), F: marshalInfoBar},
	})
}

// InfoBar: `GtkInfoBar` can be show messages to the user without a dialog.
//
// !An example GtkInfoBar (info-bar.png)
//
// It is often temporarily shown at the top or bottom of a document. In contrast
// to [class@Gtk.Dialog], which has an action area at the bottom, `GtkInfoBar`
// has an action area at the side.
//
// The API of `GtkInfoBar` is very similar to `GtkDialog`, allowing you to add
// buttons to the action area with [method@Gtk.InfoBar.add_button] or
// [ctor@Gtk.InfoBar.new_with_buttons]. The sensitivity of action widgets can be
// controlled with [method@Gtk.InfoBar.set_response_sensitive].
//
// To add widgets to the main content area of a `GtkInfoBar`, use
// [method@Gtk.InfoBar.add_child].
//
// Similar to [class@Gtk.MessageDialog], the contents of a `GtkInfoBar` can by
// classified as error message, warning, informational message, etc, by using
// [method@Gtk.InfoBar.set_message_type]. GTK may use the message type to
// determine how the message is displayed.
//
// A simple example for using a `GtkInfoBar`: “`c GtkWidget *message_label;
// GtkWidget *widget; GtkWidget *grid; GtkInfoBar *bar;
//
// // set up info bar widget = gtk_info_bar_new (); bar = GTK_INFO_BAR (widget);
// // grid = gtk_grid_new ();
//
// message_label = gtk_label_new (""); gtk_info_bar_add_child (bar,
// message_label); gtk_info_bar_add_button (bar, _("_OK"), GTK_RESPONSE_OK);
// g_signal_connect (bar, "response", G_CALLBACK (gtk_widget_hide), NULL);
// gtk_grid_attach (GTK_GRID (grid), widget, 0, 2, 1, 1);
//
// // ...
//
// // show an error message gtk_label_set_text (GTK_LABEL (message_label), "An
// // error occurred!"); gtk_info_bar_set_message_type (bar, GTK_MESSAGE_ERROR);
// // gtk_widget_show (bar); “`
//
//
// GtkInfoBar as GtkBuildable
//
// The `GtkInfoBar` implementation of the `GtkBuildable` interface exposes the
// content area and action area as internal children with the names
// “content_area” and “action_area”.
//
// `GtkInfoBar` supports a custom <action-widgets> element, which can contain
// multiple <action-widget> elements. The “response” attribute specifies a
// numeric response, and the content of the element is the id of widget (which
// should be a child of the dialogs @action_area).
//
//
// CSS nodes
//
// `GtkInfoBar` has a single CSS node with name infobar. The node may get one of
// the style classes .info, .warning, .error or .question, depending on the
// message type. If the info bar shows a close button, that button will have the
// .close style class applied.
type InfoBar interface {
	Widget

	AddActionWidgetInfoBar(child Widget, responseId int)

	AddButtonInfoBar(buttonText string, responseId int) Button

	AddChildInfoBar(widget Widget)

	MessageType() MessageType

	Revealed() bool

	ShowCloseButton() bool

	RemoveActionWidgetInfoBar(widget Widget)

	RemoveChildInfoBar(widget Widget)

	ResponseInfoBar(responseId int)

	SetDefaultResponseInfoBar(responseId int)

	SetMessageTypeInfoBar(messageType MessageType)

	SetResponseSensitiveInfoBar(responseId int, setting bool)

	SetRevealedInfoBar(revealed bool)

	SetShowCloseButtonInfoBar(setting bool)
}

// infoBar implements the InfoBar class.
type infoBar struct {
	Widget
}

// WrapInfoBar wraps a GObject to the right type. It is
// primarily used internally.
func WrapInfoBar(obj *externglib.Object) InfoBar {
	return infoBar{
		Widget: WrapWidget(obj),
	}
}

func marshalInfoBar(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapInfoBar(obj), nil
}

func NewInfoBar() InfoBar {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_info_bar_new()

	var _infoBar InfoBar // out

	_infoBar = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(InfoBar)

	return _infoBar
}

func (i infoBar) AddActionWidgetInfoBar(child Widget, responseId int) {
	var _arg0 *C.GtkInfoBar // out
	var _arg1 *C.GtkWidget  // out
	var _arg2 C.int         // out

	_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = C.int(responseId)

	C.gtk_info_bar_add_action_widget(_arg0, _arg1, _arg2)
}

func (i infoBar) AddButtonInfoBar(buttonText string, responseId int) Button {
	var _arg0 *C.GtkInfoBar // out
	var _arg1 *C.char       // out
	var _arg2 C.int         // out
	var _cret *C.GtkWidget  // in

	_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.char)(C.CString(buttonText))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.int(responseId)

	_cret = C.gtk_info_bar_add_button(_arg0, _arg1, _arg2)

	var _button Button // out

	_button = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Button)

	return _button
}

func (i infoBar) AddChildInfoBar(widget Widget) {
	var _arg0 *C.GtkInfoBar // out
	var _arg1 *C.GtkWidget  // out

	_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	C.gtk_info_bar_add_child(_arg0, _arg1)
}

func (i infoBar) MessageType() MessageType {
	var _arg0 *C.GtkInfoBar    // out
	var _cret C.GtkMessageType // in

	_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_info_bar_get_message_type(_arg0)

	var _messageType MessageType // out

	_messageType = MessageType(_cret)

	return _messageType
}

func (i infoBar) Revealed() bool {
	var _arg0 *C.GtkInfoBar // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_info_bar_get_revealed(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (i infoBar) ShowCloseButton() bool {
	var _arg0 *C.GtkInfoBar // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))

	_cret = C.gtk_info_bar_get_show_close_button(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (i infoBar) RemoveActionWidgetInfoBar(widget Widget) {
	var _arg0 *C.GtkInfoBar // out
	var _arg1 *C.GtkWidget  // out

	_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	C.gtk_info_bar_remove_action_widget(_arg0, _arg1)
}

func (i infoBar) RemoveChildInfoBar(widget Widget) {
	var _arg0 *C.GtkInfoBar // out
	var _arg1 *C.GtkWidget  // out

	_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	C.gtk_info_bar_remove_child(_arg0, _arg1)
}

func (i infoBar) ResponseInfoBar(responseId int) {
	var _arg0 *C.GtkInfoBar // out
	var _arg1 C.int         // out

	_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))
	_arg1 = C.int(responseId)

	C.gtk_info_bar_response(_arg0, _arg1)
}

func (i infoBar) SetDefaultResponseInfoBar(responseId int) {
	var _arg0 *C.GtkInfoBar // out
	var _arg1 C.int         // out

	_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))
	_arg1 = C.int(responseId)

	C.gtk_info_bar_set_default_response(_arg0, _arg1)
}

func (i infoBar) SetMessageTypeInfoBar(messageType MessageType) {
	var _arg0 *C.GtkInfoBar    // out
	var _arg1 C.GtkMessageType // out

	_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))
	_arg1 = C.GtkMessageType(messageType)

	C.gtk_info_bar_set_message_type(_arg0, _arg1)
}

func (i infoBar) SetResponseSensitiveInfoBar(responseId int, setting bool) {
	var _arg0 *C.GtkInfoBar // out
	var _arg1 C.int         // out
	var _arg2 C.gboolean    // out

	_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))
	_arg1 = C.int(responseId)
	if setting {
		_arg2 = C.TRUE
	}

	C.gtk_info_bar_set_response_sensitive(_arg0, _arg1, _arg2)
}

func (i infoBar) SetRevealedInfoBar(revealed bool) {
	var _arg0 *C.GtkInfoBar // out
	var _arg1 C.gboolean    // out

	_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))
	if revealed {
		_arg1 = C.TRUE
	}

	C.gtk_info_bar_set_revealed(_arg0, _arg1)
}

func (i infoBar) SetShowCloseButtonInfoBar(setting bool) {
	var _arg0 *C.GtkInfoBar // out
	var _arg1 C.gboolean    // out

	_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_info_bar_set_show_close_button(_arg0, _arg1)
}

func (s infoBar) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s infoBar) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s infoBar) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s infoBar) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s infoBar) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s infoBar) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s infoBar) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b infoBar) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}
