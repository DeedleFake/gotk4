// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/internal/box"
	"github.com/diamondburned/gotk4/internal/gextras"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: glib-2.0 gtk4
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <gtk/gtk.h>
//
// gboolean gotk4_TreeModelForeachFunc(GtkTreeModel*, GtkTreePath*, GtkTreeIter*, gpointer);
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_tree_model_flags_get_type()), F: marshalTreeModelFlags},
		{T: externglib.Type(C.gtk_tree_model_get_type()), F: marshalTreeModel},
		{T: externglib.Type(C.gtk_tree_iter_get_type()), F: marshalTreeIter},
		{T: externglib.Type(C.gtk_tree_path_get_type()), F: marshalTreePath},
		{T: externglib.Type(C.gtk_tree_row_reference_get_type()), F: marshalTreeRowReference},
	})
}

// TreeModelFlags: these flags indicate various properties of a TreeModel.
//
// They are returned by gtk_tree_model_get_flags(), and must be static for the
// lifetime of the object. A more complete description of
// K_TREE_MODEL_ITERS_PERSIST can be found in the overview of this section.
type TreeModelFlags int

const (
	// TreeModelFlagsItersPersist iterators survive all signals emitted by the
	// tree
	TreeModelFlagsItersPersist TreeModelFlags = 1
	// TreeModelFlagsListOnly: the model is a list only, and never has children
	TreeModelFlagsListOnly TreeModelFlags = 2
)

func marshalTreeModelFlags(p uintptr) (interface{}, error) {
	return TreeModelFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TreeModelForeachFunc: type of the callback passed to gtk_tree_model_foreach()
// to iterate over the rows in a tree model.
type TreeModelForeachFunc func(model TreeModel, path *TreePath, iter *TreeIter) (ok bool)

//export gotk4_TreeModelForeachFunc
func gotk4_TreeModelForeachFunc(arg0 *C.GtkTreeModel, arg1 *C.GtkTreePath, arg2 *C.GtkTreeIter, arg3 C.gpointer) C.gboolean {
	v := box.Get(uintptr(arg3))
	if v == nil {
		panic(`callback not found`)
	}

	var model TreeModel // out
	var path *TreePath  // out
	var iter *TreeIter  // out

	model = gextras.CastObject(externglib.Take(unsafe.Pointer(arg0.Native()))).(TreeModel)
	path = WrapTreePath(unsafe.Pointer(arg1))
	iter = WrapTreeIter(unsafe.Pointer(arg2))

	fn := v.(TreeModelForeachFunc)
	ok := fn(model, path, iter)

	var cret C.gboolean // out

	if ok {
		cret = C.TRUE
	}

	return cret
}

// TreeModelOverrider contains methods that are overridable. This
// interface is a subset of the interface TreeModel.
type TreeModelOverrider interface {
	// ColumnType returns the type of the column.
	ColumnType(index_ int) externglib.Type
	// Flags returns a set of flags supported by this interface.
	//
	// The flags are a bitwise combination of TreeModelFlags. The flags
	// supported should not change during the lifetime of the @tree_model.
	Flags() TreeModelFlags
	// Iter sets @iter to a valid iterator pointing to @path. If @path does not
	// exist, @iter is set to an invalid iterator and false is returned.
	Iter(path *TreePath) (TreeIter, bool)
	// NColumns returns the number of columns supported by @tree_model.
	NColumns() int
	// Path returns a newly-created TreePath-struct referenced by @iter.
	//
	// This path should be freed with gtk_tree_path_free().
	Path(iter *TreeIter) *TreePath
	// IterChildren sets @iter to point to the first child of @parent.
	//
	// If @parent has no children, false is returned and @iter is set to be
	// invalid. @parent will remain a valid node after this function has been
	// called.
	//
	// If @parent is nil returns the first node, equivalent to
	// `gtk_tree_model_get_iter_first (tree_model, iter);`
	IterChildren(parent *TreeIter) (TreeIter, bool)
	// IterHasChild returns true if @iter has children, false otherwise.
	IterHasChild(iter *TreeIter) bool
	// IterNChildren returns the number of children that @iter has.
	//
	// As a special case, if @iter is nil, then the number of toplevel nodes is
	// returned.
	IterNChildren(iter *TreeIter) int
	// IterNext sets @iter to point to the node following it at the current
	// level.
	//
	// If there is no next @iter, false is returned and @iter is set to be
	// invalid.
	IterNext(iter *TreeIter) bool
	// IterNthChild sets @iter to be the child of @parent, using the given
	// index.
	//
	// The first index is 0. If @n is too big, or @parent has no children, @iter
	// is set to an invalid iterator and false is returned. @parent will remain
	// a valid node after this function has been called. As a special case, if
	// @parent is nil, then the @n-th root node is set.
	IterNthChild(parent *TreeIter, n int) (TreeIter, bool)
	// IterParent sets @iter to be the parent of @child.
	//
	// If @child is at the toplevel, and doesn’t have a parent, then @iter is
	// set to an invalid iterator and false is returned. @child will remain a
	// valid node after this function has been called.
	//
	// @iter will be initialized before the lookup is performed, so @child and
	// @iter cannot point to the same memory location.
	IterParent(child *TreeIter) (TreeIter, bool)
	// IterPrevious sets @iter to point to the previous node at the current
	// level.
	//
	// If there is no previous @iter, false is returned and @iter is set to be
	// invalid.
	IterPrevious(iter *TreeIter) bool
	// RefNode lets the tree ref the node.
	//
	// This is an optional method for models to implement. To be more specific,
	// models may ignore this call as it exists primarily for performance
	// reasons.
	//
	// This function is primarily meant as a way for views to let caching models
	// know when nodes are being displayed (and hence, whether or not to cache
	// that node). Being displayed means a node is in an expanded branch,
	// regardless of whether the node is currently visible in the viewport. For
	// example, a file-system based model would not want to keep the entire
	// file-hierarchy in memory, just the sections that are currently being
	// displayed by every current view.
	//
	// A model should be expected to be able to get an iter independent of its
	// reffed state.
	RefNode(iter *TreeIter)
	// RowChanged emits the TreeModel::row-changed signal on @tree_model.
	RowChanged(path *TreePath, iter *TreeIter)
	// RowDeleted emits the TreeModel::row-deleted signal on @tree_model.
	//
	// This should be called by models after a row has been removed. The
	// location pointed to by @path should be the location that the row
	// previously was at. It may not be a valid location anymore.
	//
	// Nodes that are deleted are not unreffed, this means that any outstanding
	// references on the deleted node should not be released.
	RowDeleted(path *TreePath)
	// RowHasChildToggled emits the TreeModel::row-has-child-toggled signal on
	// @tree_model. This should be called by models after the child state of a
	// node changes.
	RowHasChildToggled(path *TreePath, iter *TreeIter)
	// RowInserted emits the TreeModel::row-inserted signal on @tree_model.
	RowInserted(path *TreePath, iter *TreeIter)
	// UnrefNode lets the tree unref the node.
	//
	// This is an optional method for models to implement. To be more specific,
	// models may ignore this call as it exists primarily for performance
	// reasons. For more information on what this means, see
	// gtk_tree_model_ref_node().
	//
	// Please note that nodes that are deleted are not unreffed.
	UnrefNode(iter *TreeIter)
}

// TreeModel: the tree interface used by GtkTreeView
//
// The TreeModel interface defines a generic tree interface for use by the
// TreeView widget. It is an abstract interface, and is designed to be usable
// with any appropriate data structure. The programmer just has to implement
// this interface on their own data type for it to be viewable by a TreeView
// widget.
//
// The model is represented as a hierarchical tree of strongly-typed, columned
// data. In other words, the model can be seen as a tree where every node has
// different values depending on which column is being queried. The type of data
// found in a column is determined by using the GType system (ie. TYPE_INT,
// K_TYPE_BUTTON, TYPE_POINTER, etc). The types are homogeneous per column
// across all nodes. It is important to note that this interface only provides a
// way of examining a model and observing changes. The implementation of each
// individual model decides how and if changes are made.
//
// In order to make life simpler for programmers who do not need to write their
// own specialized model, two generic models are provided — the TreeStore and
// the ListStore. To use these, the developer simply pushes data into these
// models as necessary. These models provide the data structure as well as all
// appropriate tree interfaces. As a result, implementing drag and drop,
// sorting, and storing data is trivial. For the vast majority of trees and
// lists, these two models are sufficient.
//
// Models are accessed on a node/column level of granularity. One can query for
// the value of a model at a certain node and a certain column on that node.
// There are two structures used to reference a particular node in a model. They
// are the [struct@Gtk.TreePath] and the [struct@Gtk.TreeIter] (“iter” is short
// for iterator). Most of the interface consists of operations on a
// [struct@Gtk.TreeIter].
//
// A path is essentially a potential node. It is a location on a model that may
// or may not actually correspond to a node on a specific model. A
// [struct@Gtk.TreePath] can be converted into either an array of unsigned
// integers or a string. The string form is a list of numbers separated by a
// colon. Each number refers to the offset at that level. Thus, the path `0`
// refers to the root node and the path `2:4` refers to the fifth child of the
// third node.
//
// By contrast, a [struct@Gtk.TreeIter] is a reference to a specific node on a
// specific model. It is a generic struct with an integer and three generic
// pointers. These are filled in by the model in a model-specific way. One can
// convert a path to an iterator by calling gtk_tree_model_get_iter(). These
// iterators are the primary way of accessing a model and are similar to the
// iterators used by TextBuffer. They are generally statically allocated on the
// stack and only used for a short time. The model interface defines a set of
// operations using them for navigating the model.
//
// It is expected that models fill in the iterator with private data. For
// example, the ListStore model, which is internally a simple linked list,
// stores a list node in one of the pointers. The TreeModelSort stores an array
// and an offset in two of the pointers. Additionally, there is an integer
// field. This field is generally filled with a unique stamp per model. This
// stamp is for catching errors resulting from using invalid iterators with a
// model.
//
// The lifecycle of an iterator can be a little confusing at first. Iterators
// are expected to always be valid for as long as the model is unchanged (and
// doesn’t emit a signal). The model is considered to own all outstanding
// iterators and nothing needs to be done to free them from the user’s point of
// view. Additionally, some models guarantee that an iterator is valid for as
// long as the node it refers to is valid (most notably the TreeStore and
// ListStore). Although generally uninteresting, as one always has to allow for
// the case where iterators do not persist beyond a signal, some very important
// performance enhancements were made in the sort model. As a result, the
// K_TREE_MODEL_ITERS_PERSIST flag was added to indicate this behavior.
//
// To help show some common operation of a model, some examples are provided.
// The first example shows three ways of getting the iter at the location
// `3:2:5`. While the first method shown is easier, the second is much more
// common, as you often get paths from callbacks.
//
// Acquiring a `GtkTreeIter`
//
// “`c // Three ways of getting the iter pointing to the location GtkTreePath
// *path; GtkTreeIter iter; GtkTreeIter parent_iter;
//
// // get the iterator from a string gtk_tree_model_get_iter_from_string (model,
// // &iter, "3:2:5");
//
// // get the iterator from a path path = gtk_tree_path_new_from_string
// // ("3:2:5"); gtk_tree_model_get_iter (model, &iter, path); gtk_tree_path_free
// // (path);
//
// // walk the tree to find the iterator gtk_tree_model_iter_nth_child (model,
// // &iter, NULL, 3); parent_iter = iter; gtk_tree_model_iter_nth_child (model,
// // &iter, &parent_iter, 2); parent_iter = iter; gtk_tree_model_iter_nth_child
// // (model, &iter, &parent_iter, 5); “`
//
// This second example shows a quick way of iterating through a list and getting
// a string and an integer from each row. The populate_model() function used
// below is not shown, as it is specific to the ListStore. For information on
// how to write such a function, see the ListStore documentation.
//
// Reading data from a `GtkTreeModel`
//
// “`c enum { STRING_COLUMN, INT_COLUMN, N_COLUMNS };
//
// ...
//
// GtkTreeModel *list_store; GtkTreeIter iter; gboolean valid; int row_count =
// 0;
//
// // make a new list_store list_store = gtk_list_store_new (N_COLUMNS,
// // G_TYPE_STRING, G_TYPE_INT);
//
// // Fill the list store with data populate_model (list_store);
//
// // Get the first iter in the list, check it is valid and walk // through the
// // list, reading each row.
//
// valid = gtk_tree_model_get_iter_first (list_store, &iter); while (valid) {
// char *str_data; int int_data;
//
//      // Make sure you terminate calls to gtk_tree_model_get() with a “-1” value
//      gtk_tree_model_get (list_store, &iter,
//                          STRING_COLUMN, &str_data,
//                          INT_COLUMN, &int_data,
//                          -1);
//
//      // Do something with the data
//      g_print ("Row d: (s,d)\n",
//               row_count, str_data, int_data);
//      g_free (str_data);
//
//      valid = gtk_tree_model_iter_next (list_store,
//                                        &iter);
//      row_count++;
//    }
//
// “`
//
// The TreeModel interface contains two methods for reference counting:
// gtk_tree_model_ref_node() and gtk_tree_model_unref_node(). These two methods
// are optional to implement. The reference counting is meant as a way for views
// to let models know when nodes are being displayed. TreeView will take a
// reference on a node when it is visible, which means the node is either in the
// toplevel or expanded. Being displayed does not mean that the node is
// currently directly visible to the user in the viewport. Based on this
// reference counting scheme a caching model, for example, can decide whether or
// not to cache a node based on the reference count. A file-system based model
// would not want to keep the entire file hierarchy in memory, but just the
// folders that are currently expanded in every current view.
//
// When working with reference counting, the following rules must be taken into
// account:
//
// - Never take a reference on a node without owning a reference on its parent.
// This means that all parent nodes of a referenced node must be referenced as
// well.
//
// - Outstanding references on a deleted node are not released. This is not
// possible because the node has already been deleted by the time the
// row-deleted signal is received.
//
// - Models are not obligated to emit a signal on rows of which none of its
// siblings are referenced. To phrase this differently, signals are only
// required for levels in which nodes are referenced. For the root level
// however, signals must be emitted at all times (however the root level is
// always referenced when any view is attached).
type TreeModel interface {
	gextras.Objector
	TreeModelOverrider

	// NewFilter creates a new TreeModel, with @child_model as the child_model
	// and @root as the virtual root.
	NewFilter(root *TreePath) TreeModel
	// Foreach calls func on each node in model in a depth-first fashion.
	//
	// If @func returns true, then the tree ceases to be walked, and
	// gtk_tree_model_foreach() returns.
	Foreach(fn TreeModelForeachFunc)
	// IterFirst initializes @iter with the first iterator in the tree (the one
	// at the path "0") and returns true. Returns false if the tree is empty.
	IterFirst() (TreeIter, bool)
	// IterFromString sets @iter to a valid iterator pointing to @path_string,
	// if it exists. Otherwise, @iter is left invalid and false is returned.
	IterFromString(pathString string) (TreeIter, bool)
	// StringFromIter generates a string representation of the iter.
	//
	// This string is a “:” separated list of numbers. For example, “4:10:0:3”
	// would be an acceptable return value for this string.
	StringFromIter(iter *TreeIter) string
	// RowsReorderedWithLength emits the TreeModel::rows-reordered signal on
	// @tree_model.
	//
	// This should be called by models when their rows have been reordered.
	RowsReorderedWithLength(path *TreePath, iter *TreeIter, newOrder []int)
}

// treeModel implements the TreeModel interface.
type treeModel struct {
	gextras.Objector
}

var _ TreeModel = (*treeModel)(nil)

// WrapTreeModel wraps a GObject to a type that implements interface
// TreeModel. It is primarily used internally.
func WrapTreeModel(obj *externglib.Object) TreeModel {
	return TreeModel{
		Objector: obj,
	}
}

func marshalTreeModel(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTreeModel(obj), nil
}

// NewFilter creates a new TreeModel, with @child_model as the child_model
// and @root as the virtual root.
func (c treeModel) NewFilter(root *TreePath) TreeModel {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 *C.GtkTreePath  // out

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(root.Native()))

	var _cret *C.GtkTreeModel // in

	_cret = C.gtk_tree_model_filter_new(_arg0, _arg1)

	var _treeModel TreeModel // out

	_treeModel = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret.Native()))).(TreeModel)

	return _treeModel
}

// Foreach calls func on each node in model in a depth-first fashion.
//
// If @func returns true, then the tree ceases to be walked, and
// gtk_tree_model_foreach() returns.
func (m treeModel) Foreach(fn TreeModelForeachFunc) {
	var _arg0 *C.GtkTreeModel           // out
	var _arg1 C.GtkTreeModelForeachFunc // out
	var _arg2 C.gpointer

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(m.Native()))
	_arg1 = (*[0]byte)(C.gotk4_TreeModelForeachFunc)
	_arg2 = C.gpointer(box.Assign(fn))

	C.gtk_tree_model_foreach(_arg0, _arg1, _arg2)
}

// ColumnType returns the type of the column.
func (t treeModel) ColumnType(index_ int) externglib.Type {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 C.int           // out

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
	_arg1 = C.int(index_)

	var _cret C.GType // in

	_cret = C.gtk_tree_model_get_column_type(_arg0, _arg1)

	var _gType externglib.Type // out

	_gType = externglib.Type(_cret)

	return _gType
}

// Flags returns a set of flags supported by this interface.
//
// The flags are a bitwise combination of TreeModelFlags. The flags
// supported should not change during the lifetime of the @tree_model.
func (t treeModel) Flags() TreeModelFlags {
	var _arg0 *C.GtkTreeModel // out

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))

	var _cret C.GtkTreeModelFlags // in

	_cret = C.gtk_tree_model_get_flags(_arg0)

	var _treeModelFlags TreeModelFlags // out

	_treeModelFlags = TreeModelFlags(_cret)

	return _treeModelFlags
}

// Iter sets @iter to a valid iterator pointing to @path. If @path does not
// exist, @iter is set to an invalid iterator and false is returned.
func (t treeModel) Iter(path *TreePath) (TreeIter, bool) {
	var _arg0 *C.GtkTreeModel // out
	var _arg2 *C.GtkTreePath  // out

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
	_arg2 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	var _iter TreeIter
	var _cret C.gboolean // in

	_cret = C.gtk_tree_model_get_iter(_arg0, _arg2, (*C.GtkTreeIter)(unsafe.Pointer(&_iter)))

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _iter, _ok
}

// IterFirst initializes @iter with the first iterator in the tree (the one
// at the path "0") and returns true. Returns false if the tree is empty.
func (t treeModel) IterFirst() (TreeIter, bool) {
	var _arg0 *C.GtkTreeModel // out

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))

	var _iter TreeIter
	var _cret C.gboolean // in

	_cret = C.gtk_tree_model_get_iter_first(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_iter)))

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _iter, _ok
}

// IterFromString sets @iter to a valid iterator pointing to @path_string,
// if it exists. Otherwise, @iter is left invalid and false is returned.
func (t treeModel) IterFromString(pathString string) (TreeIter, bool) {
	var _arg0 *C.GtkTreeModel // out
	var _arg2 *C.char         // out

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
	_arg2 = (*C.char)(C.CString(pathString))
	defer C.free(unsafe.Pointer(_arg2))

	var _iter TreeIter
	var _cret C.gboolean // in

	_cret = C.gtk_tree_model_get_iter_from_string(_arg0, _arg2, (*C.GtkTreeIter)(unsafe.Pointer(&_iter)))

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _iter, _ok
}

// NColumns returns the number of columns supported by @tree_model.
func (t treeModel) NColumns() int {
	var _arg0 *C.GtkTreeModel // out

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))

	var _cret C.int // in

	_cret = C.gtk_tree_model_get_n_columns(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// Path returns a newly-created TreePath-struct referenced by @iter.
//
// This path should be freed with gtk_tree_path_free().
func (t treeModel) Path(iter *TreeIter) *TreePath {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 *C.GtkTreeIter  // out

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

	var _cret *C.GtkTreePath // in

	_cret = C.gtk_tree_model_get_path(_arg0, _arg1)

	var _treePath *TreePath // out

	_treePath = WrapTreePath(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_treePath, func(v *TreePath) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _treePath
}

// StringFromIter generates a string representation of the iter.
//
// This string is a “:” separated list of numbers. For example, “4:10:0:3”
// would be an acceptable return value for this string.
func (t treeModel) StringFromIter(iter *TreeIter) string {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 *C.GtkTreeIter  // out

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

	var _cret *C.char // in

	_cret = C.gtk_tree_model_get_string_from_iter(_arg0, _arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// IterChildren sets @iter to point to the first child of @parent.
//
// If @parent has no children, false is returned and @iter is set to be
// invalid. @parent will remain a valid node after this function has been
// called.
//
// If @parent is nil returns the first node, equivalent to
// `gtk_tree_model_get_iter_first (tree_model, iter);`
func (t treeModel) IterChildren(parent *TreeIter) (TreeIter, bool) {
	var _arg0 *C.GtkTreeModel // out
	var _arg2 *C.GtkTreeIter  // out

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
	_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(parent.Native()))

	var _iter TreeIter
	var _cret C.gboolean // in

	_cret = C.gtk_tree_model_iter_children(_arg0, _arg2, (*C.GtkTreeIter)(unsafe.Pointer(&_iter)))

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _iter, _ok
}

// IterHasChild returns true if @iter has children, false otherwise.
func (t treeModel) IterHasChild(iter *TreeIter) bool {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 *C.GtkTreeIter  // out

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

	var _cret C.gboolean // in

	_cret = C.gtk_tree_model_iter_has_child(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IterNChildren returns the number of children that @iter has.
//
// As a special case, if @iter is nil, then the number of toplevel nodes is
// returned.
func (t treeModel) IterNChildren(iter *TreeIter) int {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 *C.GtkTreeIter  // out

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

	var _cret C.int // in

	_cret = C.gtk_tree_model_iter_n_children(_arg0, _arg1)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// IterNext sets @iter to point to the node following it at the current
// level.
//
// If there is no next @iter, false is returned and @iter is set to be
// invalid.
func (t treeModel) IterNext(iter *TreeIter) bool {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 *C.GtkTreeIter  // out

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

	var _cret C.gboolean // in

	_cret = C.gtk_tree_model_iter_next(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IterNthChild sets @iter to be the child of @parent, using the given
// index.
//
// The first index is 0. If @n is too big, or @parent has no children, @iter
// is set to an invalid iterator and false is returned. @parent will remain
// a valid node after this function has been called. As a special case, if
// @parent is nil, then the @n-th root node is set.
func (t treeModel) IterNthChild(parent *TreeIter, n int) (TreeIter, bool) {
	var _arg0 *C.GtkTreeModel // out
	var _arg2 *C.GtkTreeIter  // out
	var _arg3 C.int           // out

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
	_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(parent.Native()))
	_arg3 = C.int(n)

	var _iter TreeIter
	var _cret C.gboolean // in

	_cret = C.gtk_tree_model_iter_nth_child(_arg0, _arg2, _arg3, (*C.GtkTreeIter)(unsafe.Pointer(&_iter)))

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _iter, _ok
}

// IterParent sets @iter to be the parent of @child.
//
// If @child is at the toplevel, and doesn’t have a parent, then @iter is
// set to an invalid iterator and false is returned. @child will remain a
// valid node after this function has been called.
//
// @iter will be initialized before the lookup is performed, so @child and
// @iter cannot point to the same memory location.
func (t treeModel) IterParent(child *TreeIter) (TreeIter, bool) {
	var _arg0 *C.GtkTreeModel // out
	var _arg2 *C.GtkTreeIter  // out

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
	_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(child.Native()))

	var _iter TreeIter
	var _cret C.gboolean // in

	_cret = C.gtk_tree_model_iter_parent(_arg0, _arg2, (*C.GtkTreeIter)(unsafe.Pointer(&_iter)))

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _iter, _ok
}

// IterPrevious sets @iter to point to the previous node at the current
// level.
//
// If there is no previous @iter, false is returned and @iter is set to be
// invalid.
func (t treeModel) IterPrevious(iter *TreeIter) bool {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 *C.GtkTreeIter  // out

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

	var _cret C.gboolean // in

	_cret = C.gtk_tree_model_iter_previous(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RefNode lets the tree ref the node.
//
// This is an optional method for models to implement. To be more specific,
// models may ignore this call as it exists primarily for performance
// reasons.
//
// This function is primarily meant as a way for views to let caching models
// know when nodes are being displayed (and hence, whether or not to cache
// that node). Being displayed means a node is in an expanded branch,
// regardless of whether the node is currently visible in the viewport. For
// example, a file-system based model would not want to keep the entire
// file-hierarchy in memory, just the sections that are currently being
// displayed by every current view.
//
// A model should be expected to be able to get an iter independent of its
// reffed state.
func (t treeModel) RefNode(iter *TreeIter) {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 *C.GtkTreeIter  // out

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

	C.gtk_tree_model_ref_node(_arg0, _arg1)
}

// RowChanged emits the TreeModel::row-changed signal on @tree_model.
func (t treeModel) RowChanged(path *TreePath, iter *TreeIter) {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 *C.GtkTreePath  // out
	var _arg2 *C.GtkTreeIter  // out

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
	_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

	C.gtk_tree_model_row_changed(_arg0, _arg1, _arg2)
}

// RowDeleted emits the TreeModel::row-deleted signal on @tree_model.
//
// This should be called by models after a row has been removed. The
// location pointed to by @path should be the location that the row
// previously was at. It may not be a valid location anymore.
//
// Nodes that are deleted are not unreffed, this means that any outstanding
// references on the deleted node should not be released.
func (t treeModel) RowDeleted(path *TreePath) {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 *C.GtkTreePath  // out

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	C.gtk_tree_model_row_deleted(_arg0, _arg1)
}

// RowHasChildToggled emits the TreeModel::row-has-child-toggled signal on
// @tree_model. This should be called by models after the child state of a
// node changes.
func (t treeModel) RowHasChildToggled(path *TreePath, iter *TreeIter) {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 *C.GtkTreePath  // out
	var _arg2 *C.GtkTreeIter  // out

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
	_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

	C.gtk_tree_model_row_has_child_toggled(_arg0, _arg1, _arg2)
}

// RowInserted emits the TreeModel::row-inserted signal on @tree_model.
func (t treeModel) RowInserted(path *TreePath, iter *TreeIter) {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 *C.GtkTreePath  // out
	var _arg2 *C.GtkTreeIter  // out

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
	_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

	C.gtk_tree_model_row_inserted(_arg0, _arg1, _arg2)
}

// RowsReorderedWithLength emits the TreeModel::rows-reordered signal on
// @tree_model.
//
// This should be called by models when their rows have been reordered.
func (t treeModel) RowsReorderedWithLength(path *TreePath, iter *TreeIter, newOrder []int) {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 *C.GtkTreePath  // out
	var _arg2 *C.GtkTreeIter  // out
	var _arg3 *C.int
	var _arg4 C.int

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
	_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))
	_arg4 = C.int(len(newOrder))
	_arg3 = (*C.int)(unsafe.Pointer(&newOrder[0]))

	C.gtk_tree_model_rows_reordered_with_length(_arg0, _arg1, _arg2, _arg3, _arg4)
}

// UnrefNode lets the tree unref the node.
//
// This is an optional method for models to implement. To be more specific,
// models may ignore this call as it exists primarily for performance
// reasons. For more information on what this means, see
// gtk_tree_model_ref_node().
//
// Please note that nodes that are deleted are not unreffed.
func (t treeModel) UnrefNode(iter *TreeIter) {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 *C.GtkTreeIter  // out

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

	C.gtk_tree_model_unref_node(_arg0, _arg1)
}

// TreeIter: the TreeIter is the primary structure for accessing a TreeModel.
// Models are expected to put a unique integer in the @stamp member, and put
// model-specific data in the three @user_data members.
type TreeIter struct {
	native C.GtkTreeIter
}

// WrapTreeIter wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTreeIter(ptr unsafe.Pointer) *TreeIter {
	if ptr == nil {
		return nil
	}

	return (*TreeIter)(ptr)
}

func marshalTreeIter(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapTreeIter(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *TreeIter) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

// Stamp gets the field inside the struct.
func (t *TreeIter) Stamp() int {
	var v int // out
	v = (int)(t.native.stamp)
	return v
}

// UserData gets the field inside the struct.
func (t *TreeIter) UserData() interface{} {
	var v interface{} // out
	v = (interface{})(t.native.user_data)
	return v
}

// UserData2 gets the field inside the struct.
func (t *TreeIter) UserData2() interface{} {
	var v interface{} // out
	v = (interface{})(t.native.user_data2)
	return v
}

// UserData3 gets the field inside the struct.
func (t *TreeIter) UserData3() interface{} {
	var v interface{} // out
	v = (interface{})(t.native.user_data3)
	return v
}

// Copy creates a dynamically allocated tree iterator as a copy of @iter.
//
// This function is not intended for use in applications, because you can just
// copy the structs by value (`GtkTreeIter new_iter = iter;`). You must free
// this iter with gtk_tree_iter_free().
func (i *TreeIter) Copy() *TreeIter {
	var _arg0 *C.GtkTreeIter // out

	_arg0 = (*C.GtkTreeIter)(unsafe.Pointer(i.Native()))

	var _cret *C.GtkTreeIter // in

	_cret = C.gtk_tree_iter_copy(_arg0)

	var _treeIter *TreeIter // out

	_treeIter = WrapTreeIter(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_treeIter, func(v *TreeIter) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _treeIter
}

// Free frees an iterator that has been allocated by gtk_tree_iter_copy().
//
// This function is mainly used for language bindings.
func (i *TreeIter) Free() {
	var _arg0 *C.GtkTreeIter // out

	_arg0 = (*C.GtkTreeIter)(unsafe.Pointer(i.Native()))

	C.gtk_tree_iter_free(_arg0)
}

// TreePath: an opaque structure representing a path to a row in a model.
type TreePath struct {
	native C.GtkTreePath
}

// WrapTreePath wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTreePath(ptr unsafe.Pointer) *TreePath {
	if ptr == nil {
		return nil
	}

	return (*TreePath)(ptr)
}

func marshalTreePath(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapTreePath(unsafe.Pointer(b)), nil
}

// NewTreePath constructs a struct TreePath.
func NewTreePath() *TreePath {
	var _cret *C.GtkTreePath // in

	_cret = C.gtk_tree_path_new()

	var _treePath *TreePath // out

	_treePath = WrapTreePath(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_treePath, func(v *TreePath) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _treePath
}

// NewTreePathFirst constructs a struct TreePath.
func NewTreePathFirst() *TreePath {
	var _cret *C.GtkTreePath // in

	_cret = C.gtk_tree_path_new_first()

	var _treePath *TreePath // out

	_treePath = WrapTreePath(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_treePath, func(v *TreePath) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _treePath
}

// NewTreePathFromIndicesv constructs a struct TreePath.
func NewTreePathFromIndicesv(indices []int) *TreePath {
	var _arg1 *C.int
	var _arg2 C.gsize

	_arg2 = C.gsize(len(indices))
	_arg1 = (*C.int)(unsafe.Pointer(&indices[0]))

	var _cret *C.GtkTreePath // in

	_cret = C.gtk_tree_path_new_from_indicesv(_arg1, _arg2)

	var _treePath *TreePath // out

	_treePath = WrapTreePath(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_treePath, func(v *TreePath) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _treePath
}

// NewTreePathFromString constructs a struct TreePath.
func NewTreePathFromString(path string) *TreePath {
	var _arg1 *C.char // out

	_arg1 = (*C.char)(C.CString(path))
	defer C.free(unsafe.Pointer(_arg1))

	var _cret *C.GtkTreePath // in

	_cret = C.gtk_tree_path_new_from_string(_arg1)

	var _treePath *TreePath // out

	_treePath = WrapTreePath(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_treePath, func(v *TreePath) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _treePath
}

// Native returns the underlying C source pointer.
func (t *TreePath) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

// AppendIndex appends a new index to a path.
//
// As a result, the depth of the path is increased.
func (p *TreePath) AppendIndex(index_ int) {
	var _arg0 *C.GtkTreePath // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkTreePath)(unsafe.Pointer(p.Native()))
	_arg1 = C.int(index_)

	C.gtk_tree_path_append_index(_arg0, _arg1)
}

// Compare compares two paths.
//
// If @a appears before @b in a tree, then -1 is returned. If @b appears before
// @a, then 1 is returned. If the two nodes are equal, then 0 is returned.
func (a *TreePath) Compare(b *TreePath) int {
	var _arg0 *C.GtkTreePath // out
	var _arg1 *C.GtkTreePath // out

	_arg0 = (*C.GtkTreePath)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(b.Native()))

	var _cret C.int // in

	_cret = C.gtk_tree_path_compare(_arg0, _arg1)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// Copy creates a new TreePath-struct as a copy of @path.
func (p *TreePath) Copy() *TreePath {
	var _arg0 *C.GtkTreePath // out

	_arg0 = (*C.GtkTreePath)(unsafe.Pointer(p.Native()))

	var _cret *C.GtkTreePath // in

	_cret = C.gtk_tree_path_copy(_arg0)

	var _treePath *TreePath // out

	_treePath = WrapTreePath(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_treePath, func(v *TreePath) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _treePath
}

// Down moves @path to point to the first child of the current path.
func (p *TreePath) Down() {
	var _arg0 *C.GtkTreePath // out

	_arg0 = (*C.GtkTreePath)(unsafe.Pointer(p.Native()))

	C.gtk_tree_path_down(_arg0)
}

// Free frees @path. If @path is nil, it simply returns.
func (p *TreePath) Free() {
	var _arg0 *C.GtkTreePath // out

	_arg0 = (*C.GtkTreePath)(unsafe.Pointer(p.Native()))

	C.gtk_tree_path_free(_arg0)
}

// Depth returns the current depth of @path.
func (p *TreePath) Depth() int {
	var _arg0 *C.GtkTreePath // out

	_arg0 = (*C.GtkTreePath)(unsafe.Pointer(p.Native()))

	var _cret C.int // in

	_cret = C.gtk_tree_path_get_depth(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// IndicesWithDepth returns the current indices of @path.
//
// This is an array of integers, each representing a node in a tree. It also
// returns the number of elements in the array. The array should not be freed.
func (p *TreePath) IndicesWithDepth() []int {
	var _arg0 *C.GtkTreePath // out

	_arg0 = (*C.GtkTreePath)(unsafe.Pointer(p.Native()))

	var _cret *C.int
	var _arg1 C.int // in

	_cret = C.gtk_tree_path_get_indices_with_depth(_arg0, &_arg1)

	var _gints []int

	{
		src := unsafe.Slice(_cret, _arg1)
		_gints = make([]int, _arg1)
		for i := 0; i < int(_arg1); i++ {
			_gints[i] = (int)(src[i])
		}
	}

	return _gints
}

// IsAncestor returns true if @descendant is a descendant of @path.
func (p *TreePath) IsAncestor(descendant *TreePath) bool {
	var _arg0 *C.GtkTreePath // out
	var _arg1 *C.GtkTreePath // out

	_arg0 = (*C.GtkTreePath)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(descendant.Native()))

	var _cret C.gboolean // in

	_cret = C.gtk_tree_path_is_ancestor(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsDescendant returns true if @path is a descendant of @ancestor.
func (p *TreePath) IsDescendant(ancestor *TreePath) bool {
	var _arg0 *C.GtkTreePath // out
	var _arg1 *C.GtkTreePath // out

	_arg0 = (*C.GtkTreePath)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.GtkTreePath)(unsafe.Pointer(ancestor.Native()))

	var _cret C.gboolean // in

	_cret = C.gtk_tree_path_is_descendant(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Next moves the @path to point to the next node at the current depth.
func (p *TreePath) Next() {
	var _arg0 *C.GtkTreePath // out

	_arg0 = (*C.GtkTreePath)(unsafe.Pointer(p.Native()))

	C.gtk_tree_path_next(_arg0)
}

// PrependIndex prepends a new index to a path.
//
// As a result, the depth of the path is increased.
func (p *TreePath) PrependIndex(index_ int) {
	var _arg0 *C.GtkTreePath // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkTreePath)(unsafe.Pointer(p.Native()))
	_arg1 = C.int(index_)

	C.gtk_tree_path_prepend_index(_arg0, _arg1)
}

// Prev moves the @path to point to the previous node at the current depth, if
// it exists.
func (p *TreePath) Prev() bool {
	var _arg0 *C.GtkTreePath // out

	_arg0 = (*C.GtkTreePath)(unsafe.Pointer(p.Native()))

	var _cret C.gboolean // in

	_cret = C.gtk_tree_path_prev(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// String generates a string representation of the path.
//
// This string is a “:” separated list of numbers. For example, “4:10:0:3” would
// be an acceptable return value for this string. If the path has depth 0, nil
// is returned.
func (p *TreePath) String() string {
	var _arg0 *C.GtkTreePath // out

	_arg0 = (*C.GtkTreePath)(unsafe.Pointer(p.Native()))

	var _cret *C.char // in

	_cret = C.gtk_tree_path_to_string(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Up moves the @path to point to its parent node, if it has a parent.
func (p *TreePath) Up() bool {
	var _arg0 *C.GtkTreePath // out

	_arg0 = (*C.GtkTreePath)(unsafe.Pointer(p.Native()))

	var _cret C.gboolean // in

	_cret = C.gtk_tree_path_up(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TreeRowReference: a GtkTreeRowReference tracks model changes so that it
// always refers to the same row (a TreePath refers to a position, not a fixed
// row). Create a new GtkTreeRowReference with gtk_tree_row_reference_new().
type TreeRowReference struct {
	native C.GtkTreeRowReference
}

// WrapTreeRowReference wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTreeRowReference(ptr unsafe.Pointer) *TreeRowReference {
	if ptr == nil {
		return nil
	}

	return (*TreeRowReference)(ptr)
}

func marshalTreeRowReference(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapTreeRowReference(unsafe.Pointer(b)), nil
}

// NewTreeRowReference constructs a struct TreeRowReference.
func NewTreeRowReference(model TreeModel, path *TreePath) *TreeRowReference {
	var _arg1 *C.GtkTreeModel // out
	var _arg2 *C.GtkTreePath  // out

	_arg1 = (*C.GtkTreeModel)(unsafe.Pointer(model.Native()))
	_arg2 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	var _cret *C.GtkTreeRowReference // in

	_cret = C.gtk_tree_row_reference_new(_arg1, _arg2)

	var _treeRowReference *TreeRowReference // out

	_treeRowReference = WrapTreeRowReference(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_treeRowReference, func(v *TreeRowReference) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _treeRowReference
}

// Native returns the underlying C source pointer.
func (t *TreeRowReference) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

// Copy copies a TreeRowReference.
func (r *TreeRowReference) Copy() *TreeRowReference {
	var _arg0 *C.GtkTreeRowReference // out

	_arg0 = (*C.GtkTreeRowReference)(unsafe.Pointer(r.Native()))

	var _cret *C.GtkTreeRowReference // in

	_cret = C.gtk_tree_row_reference_copy(_arg0)

	var _treeRowReference *TreeRowReference // out

	_treeRowReference = WrapTreeRowReference(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_treeRowReference, func(v *TreeRowReference) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _treeRowReference
}

// Free free’s @reference. @reference may be nil
func (r *TreeRowReference) Free() {
	var _arg0 *C.GtkTreeRowReference // out

	_arg0 = (*C.GtkTreeRowReference)(unsafe.Pointer(r.Native()))

	C.gtk_tree_row_reference_free(_arg0)
}

// Model returns the model that the row reference is monitoring.
func (r *TreeRowReference) Model() TreeModel {
	var _arg0 *C.GtkTreeRowReference // out

	_arg0 = (*C.GtkTreeRowReference)(unsafe.Pointer(r.Native()))

	var _cret *C.GtkTreeModel // in

	_cret = C.gtk_tree_row_reference_get_model(_arg0)

	var _treeModel TreeModel // out

	_treeModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret.Native()))).(TreeModel)

	return _treeModel
}

// Path returns a path that the row reference currently points to, or nil if the
// path pointed to is no longer valid.
func (r *TreeRowReference) Path() *TreePath {
	var _arg0 *C.GtkTreeRowReference // out

	_arg0 = (*C.GtkTreeRowReference)(unsafe.Pointer(r.Native()))

	var _cret *C.GtkTreePath // in

	_cret = C.gtk_tree_row_reference_get_path(_arg0)

	var _treePath *TreePath // out

	_treePath = WrapTreePath(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_treePath, func(v *TreePath) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _treePath
}

// Valid returns true if the @reference is non-nil and refers to a current valid
// path.
func (r *TreeRowReference) Valid() bool {
	var _arg0 *C.GtkTreeRowReference // out

	_arg0 = (*C.GtkTreeRowReference)(unsafe.Pointer(r.Native()))

	var _cret C.gboolean // in

	_cret = C.gtk_tree_row_reference_valid(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}
