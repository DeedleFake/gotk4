// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"github.com/diamondburned/gotk4/pkg/gio/v2"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config:
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <gtk/gtk.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_string_list_get_type()), F: marshalStringList},
		{T: externglib.Type(C.gtk_string_object_get_type()), F: marshalStringObject},
	})
}

// StringList is a list model that wraps an array of strings.
//
// The objects in the model have a "string" property.
//
// GtkStringList is well-suited for any place where you would typically use a
// `char*[]`, but need a list model.
//
//
// GtkStringList as GtkBuildable
//
// The GtkStringList implementation of the GtkBuildable interface supports
// adding items directly using the <items> element and specifying <item>
// elements for each item. Each <item> element supports the regular translation
// attributes “translatable”, “context” and “comments”.
//
// Here is a UI definition fragment specifying a GtkStringList
//
//    <object class="GtkStringList">
//      <items>
//        <item translatable="yes">Factory</item>
//        <item translatable="yes">Home</item>
//        <item translatable="yes">Subway</item>
//      </items>
//    </object>
type StringList interface {
	gextras.Objector
	gio.ListModel
	Buildable

	// Append appends @string to @self.
	//
	// The @string will be copied. See gtk_string_list_take() for a way to avoid
	// that.
	Append(s StringList, string string)
	// String gets the string that is at @position in @self. If @self does not
	// contain @position items, nil is returned.
	//
	// This function returns the const char *. To get the object wrapping it,
	// use g_list_model_get_item().
	String(s StringList, position uint)
	// Remove removes the string at @position from @self. @position must be
	// smaller than the current length of the list.
	Remove(s StringList, position uint)
	// Splice changes @self by removing @n_removals strings and adding
	// @additions to it.
	//
	// This function is more efficient than gtk_string_list_append() and
	// gtk_string_list_remove(), because it only emits Model::items-changed once
	// for the change.
	//
	// This function copies the strings in @additions.
	//
	// The parameters @position and @n_removals must be correct (ie: @position +
	// @n_removals must be less than or equal to the length of the list at the
	// time this function is called).
	Splice(s StringList, position uint, nRemovals uint, additions []string)
	// Take adds @string to self at the end, and takes ownership of it.
	//
	// This variant of gtk_string_list_append() is convenient for formatting
	// strings:
	//
	//    gtk_string_list_take (self, g_strdup_print ("d dollars", lots));
	Take(s StringList, string string)
}

// stringList implements the StringList interface.
type stringList struct {
	gextras.Objector
	gio.ListModel
	Buildable
}

var _ StringList = (*stringList)(nil)

// WrapStringList wraps a GObject to the right type. It is
// primarily used internally.
func WrapStringList(obj *externglib.Object) StringList {
	return StringList{
		Objector:      obj,
		gio.ListModel: gio.WrapListModel(obj),
		Buildable:     WrapBuildable(obj),
	}
}

func marshalStringList(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapStringList(obj), nil
}

// NewStringList constructs a class StringList.
func NewStringList(strings []string) {
	var arg1 **C.char

	arg1 = C.malloc(len(strings) * (unsafe.Sizeof(int(0)) + 1))
	defer C.free(unsafe.Pointer(arg1))

	{
		var out []*C.char
		ptr.SetSlice(unsafe.Pointer(&dst), unsafe.Pointer(arg1), int(len(strings)))

		for i := range strings {
			out[i] = (*C.char)(C.CString(strings[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	C.gtk_string_list_new(arg1)
}

// Append appends @string to @self.
//
// The @string will be copied. See gtk_string_list_take() for a way to avoid
// that.
func (s stringList) Append(s StringList, string string) {
	var arg0 *C.GtkStringList
	var arg1 *C.char

	arg0 = (*C.GtkStringList)(unsafe.Pointer(s.Native()))
	arg1 = (*C.char)(C.CString(string))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_string_list_append(arg0, arg1)
}

// String gets the string that is at @position in @self. If @self does not
// contain @position items, nil is returned.
//
// This function returns the const char *. To get the object wrapping it,
// use g_list_model_get_item().
func (s stringList) String(s StringList, position uint) {
	var arg0 *C.GtkStringList
	var arg1 C.guint

	arg0 = (*C.GtkStringList)(unsafe.Pointer(s.Native()))
	arg1 = C.guint(position)

	C.gtk_string_list_get_string(arg0, arg1)
}

// Remove removes the string at @position from @self. @position must be
// smaller than the current length of the list.
func (s stringList) Remove(s StringList, position uint) {
	var arg0 *C.GtkStringList
	var arg1 C.guint

	arg0 = (*C.GtkStringList)(unsafe.Pointer(s.Native()))
	arg1 = C.guint(position)

	C.gtk_string_list_remove(arg0, arg1)
}

// Splice changes @self by removing @n_removals strings and adding
// @additions to it.
//
// This function is more efficient than gtk_string_list_append() and
// gtk_string_list_remove(), because it only emits Model::items-changed once
// for the change.
//
// This function copies the strings in @additions.
//
// The parameters @position and @n_removals must be correct (ie: @position +
// @n_removals must be less than or equal to the length of the list at the
// time this function is called).
func (s stringList) Splice(s StringList, position uint, nRemovals uint, additions []string) {
	var arg0 *C.GtkStringList
	var arg1 C.guint
	var arg2 C.guint
	var arg3 **C.char

	arg0 = (*C.GtkStringList)(unsafe.Pointer(s.Native()))
	arg1 = C.guint(position)
	arg2 = C.guint(nRemovals)
	arg3 = C.malloc(len(additions) * (unsafe.Sizeof(int(0)) + 1))
	defer C.free(unsafe.Pointer(arg3))

	{
		var out []*C.char
		ptr.SetSlice(unsafe.Pointer(&dst), unsafe.Pointer(arg3), int(len(additions)))

		for i := range additions {
			out[i] = (*C.char)(C.CString(additions[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	C.gtk_string_list_splice(arg0, arg1, arg2, arg3)
}

// Take adds @string to self at the end, and takes ownership of it.
//
// This variant of gtk_string_list_append() is convenient for formatting
// strings:
//
//    gtk_string_list_take (self, g_strdup_print ("d dollars", lots));
func (s stringList) Take(s StringList, string string) {
	var arg0 *C.GtkStringList
	var arg1 *C.char

	arg0 = (*C.GtkStringList)(unsafe.Pointer(s.Native()))
	arg1 = (*C.char)(C.CString(string))

	C.gtk_string_list_take(arg0, arg1)
}

type StringObject interface {
	gextras.Objector

	// String returns the string contained in a StringObject.
	String(s StringObject)
}

// stringObject implements the StringObject interface.
type stringObject struct {
	gextras.Objector
}

var _ StringObject = (*stringObject)(nil)

// WrapStringObject wraps a GObject to the right type. It is
// primarily used internally.
func WrapStringObject(obj *externglib.Object) StringObject {
	return StringObject{
		Objector: obj,
	}
}

func marshalStringObject(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapStringObject(obj), nil
}

// NewStringObject constructs a class StringObject.
func NewStringObject(string string) {
	var arg1 *C.char

	arg1 = (*C.char)(C.CString(string))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_string_object_new(arg1)
}

// String returns the string contained in a StringObject.
func (s stringObject) String(s StringObject) {
	var arg0 *C.GtkStringObject

	arg0 = (*C.GtkStringObject)(unsafe.Pointer(s.Native()))

	C.gtk_string_object_get_string(arg0)
}
