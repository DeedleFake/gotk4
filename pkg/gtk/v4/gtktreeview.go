// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"github.com/diamondburned/gotk4/internal/box"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config:
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <gtk/gtk.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_tree_view_get_type()), F: marshalTreeView},
	})
}

// TreeViewColumnDropFunc: function type for determining whether @column can be
// dropped in a particular spot (as determined by @prev_column and
// @next_column). In left to right locales, @prev_column is on the left of the
// potential drop spot, and @next_column is on the right. In right to left mode,
// this is reversed. This function should return true if the spot is a valid
// drop spot. Please note that returning true does not actually indicate that
// the column drop was made, but is meant only to indicate a possible drop spot
// to the user.
type TreeViewColumnDropFunc func(treeView TreeView, column TreeViewColumn, prevColumn TreeViewColumn, nextColumn TreeViewColumn) bool

//export gotk4_TreeViewColumnDropFunc
func gotk4_TreeViewColumnDropFunc(arg0 *C.GtkTreeView, arg1 *C.GtkTreeViewColumn, arg2 *C.GtkTreeViewColumn, arg3 *C.GtkTreeViewColumn, arg4 C.gpointer) C.gboolean {
	v := box.Get(uintptr(arg4))
	if v == nil {
		panic(`callback not found`)
	}

	fn := v.(TreeViewColumnDropFunc)
	ret := fn(treeView, column, prevColumn, nextColumn, data)

	if ret {
		cret = C.gboolean(1)
	}

	return cret
}

// TreeViewMappingFunc: function used for gtk_tree_view_map_expanded_rows().
type TreeViewMappingFunc func(treeView TreeView, path *TreePath)

//export gotk4_TreeViewMappingFunc
func gotk4_TreeViewMappingFunc(arg0 *C.GtkTreeView, arg1 *C.GtkTreePath, arg2 C.gpointer) {
	v := box.Get(uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	fn := v.(TreeViewMappingFunc)
	fn(treeView, path, userData)
}

// TreeViewRowSeparatorFunc: function type for determining whether the row
// pointed to by @iter should be rendered as a separator. A common way to
// implement this is to have a boolean column in the model, whose values the
// TreeViewRowSeparatorFunc returns.
type TreeViewRowSeparatorFunc func(model TreeModel, iter *TreeIter) bool

//export gotk4_TreeViewRowSeparatorFunc
func gotk4_TreeViewRowSeparatorFunc(arg0 *C.GtkTreeModel, arg1 *C.GtkTreeIter, arg2 C.gpointer) C.gboolean {
	v := box.Get(uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	fn := v.(TreeViewRowSeparatorFunc)
	ret := fn(model, iter, data)

	if ret {
		cret = C.gboolean(1)
	}

	return cret
}

// TreeViewSearchEqualFunc: a function used for checking whether a row in @model
// matches a search key string entered by the user. Note the return value is
// reversed from what you would normally expect, though it has some similarity
// to strcmp() returning 0 for equal strings.
type TreeViewSearchEqualFunc func(model TreeModel, column int, key string, iter *TreeIter) bool

//export gotk4_TreeViewSearchEqualFunc
func gotk4_TreeViewSearchEqualFunc(arg0 *C.GtkTreeModel, arg1 C.int, arg2 *C.char, arg3 *C.GtkTreeIter, arg4 C.gpointer) C.gboolean {
	v := box.Get(uintptr(arg4))
	if v == nil {
		panic(`callback not found`)
	}

	fn := v.(TreeViewSearchEqualFunc)
	ret := fn(model, column, key, iter, searchData)

	if ret {
		cret = C.gboolean(1)
	}

	return cret
}

// TreeView: widget that displays any object that implements the TreeModel
// interface.
//
// Please refer to the [tree widget conceptual overview][TreeWidget] for an
// overview of all the objects and data types related to the tree widget and how
// they work together.
//
// Several different coordinate systems are exposed in the GtkTreeView API.
// These are:
//
// ! (tree-view-coordinates.png)
//
// Coordinate systems in GtkTreeView API:
//
// - Widget coordinates: Coordinates relative to the widget (usually
// `widget->window`).
//
// - Bin window coordinates: Coordinates relative to the window that GtkTreeView
// renders to.
//
// - Tree coordinates: Coordinates relative to the entire scrollable area of
// GtkTreeView. These coordinates start at (0, 0) for row 0 of the tree.
//
// Several functions are available for converting between the different
// coordinate systems. The most common translations are between widget and bin
// window coordinates and between bin window and tree coordinates. For the
// former you can use gtk_tree_view_convert_widget_to_bin_window_coords() (and
// vice versa), for the latter gtk_tree_view_convert_bin_window_to_tree_coords()
// (and vice versa).
//
//
// GtkTreeView as GtkBuildable
//
// The GtkTreeView implementation of the GtkBuildable interface accepts
// TreeViewColumn objects as <child> elements and exposes the internal
// TreeSelection in UI definitions.
//
// An example of a UI definition fragment with GtkTreeView:
//
//    <object class="GtkTreeView" id="treeview">
//      <property name="model">liststore1</property>
//      <child>
//        <object class="GtkTreeViewColumn" id="test-column">
//          <property name="title">Test</property>
//          <child>
//            <object class="GtkCellRendererText" id="test-renderer"/>
//            <attributes>
//              <attribute name="text">1</attribute>
//            </attributes>
//          </child>
//        </object>
//      </child>
//      <child internal-child="selection">
//        <object class="GtkTreeSelection" id="selection">
//          <signal name="changed" handler="on_treeview_selection_changed"/>
//        </object>
//      </child>
//    </object>
//
// CSS nodes
//
//    treeview.view
//    ├── header
//    │   ├── <column header>
//    ┊   ┊
//    │   ╰── <column header>
//    │
//    ├── [rubberband]
//    ╰── [dndtarget]
//
// GtkTreeView has a main CSS node with name treeview and style class .view. It
// has a subnode with name header, which is the parent for all the column header
// widgets' CSS nodes.
//
// For rubberband selection, a subnode with name rubberband is used.
//
// For the drop target location during DND, a subnode with name dndtarget is
// used.
type TreeView interface {
	Widget
	Accessible
	Buildable
	ConstraintTarget
	Scrollable

	// AppendColumn appends @column to the list of columns. If @tree_view has
	// “fixed_height” mode enabled, then @column must have its “sizing” property
	// set to be GTK_TREE_VIEW_COLUMN_FIXED.
	AppendColumn(t TreeView, column TreeViewColumn)
	// CollapseAll: recursively collapses all visible, expanded nodes in
	// @tree_view.
	CollapseAll(t TreeView)
	// CollapseRow collapses a row (hides its child rows, if they exist).
	CollapseRow(t TreeView, path *TreePath) bool
	// ColumnsAutosize resizes all columns to their optimal width. Only works
	// after the treeview has been realized.
	ColumnsAutosize(t TreeView)
	// ConvertBinWindowToTreeCoords converts bin_window coordinates to
	// coordinates for the tree (the full scrollable area of the tree).
	ConvertBinWindowToTreeCoords(t TreeView, bx int, by int) (tx int, ty int)
	// ConvertBinWindowToWidgetCoords converts bin_window coordinates to widget
	// relative coordinates.
	ConvertBinWindowToWidgetCoords(t TreeView, bx int, by int) (wx int, wy int)
	// ConvertTreeToBinWindowCoords converts tree coordinates (coordinates in
	// full scrollable area of the tree) to bin_window coordinates.
	ConvertTreeToBinWindowCoords(t TreeView, tx int, ty int) (bx int, by int)
	// ConvertTreeToWidgetCoords converts tree coordinates (coordinates in full
	// scrollable area of the tree) to widget coordinates.
	ConvertTreeToWidgetCoords(t TreeView, tx int, ty int) (wx int, wy int)
	// ConvertWidgetToBinWindowCoords converts widget coordinates to coordinates
	// for the bin_window.
	ConvertWidgetToBinWindowCoords(t TreeView, wx int, wy int) (bx int, by int)
	// ConvertWidgetToTreeCoords converts widget coordinates to coordinates for
	// the tree (the full scrollable area of the tree).
	ConvertWidgetToTreeCoords(t TreeView, wx int, wy int) (tx int, ty int)
	// CreateRowDragIcon creates a #cairo_surface_t representation of the row at
	// @path. This image is used for a drag icon.
	CreateRowDragIcon(t TreeView, path *TreePath)
	// EnableModelDragDest turns @tree_view into a drop destination for
	// automatic DND. Calling this method sets TreeView:reorderable to false.
	EnableModelDragDest(t TreeView, formats *gdk.ContentFormats, actions gdk.DragAction)
	// EnableModelDragSource turns @tree_view into a drag source for automatic
	// DND. Calling this method sets TreeView:reorderable to false.
	EnableModelDragSource(t TreeView, startButtonMask gdk.ModifierType, formats *gdk.ContentFormats, actions gdk.DragAction)
	// ExpandAll: recursively expands all nodes in the @tree_view.
	ExpandAll(t TreeView)
	// ExpandRow opens the row so its children are visible.
	ExpandRow(t TreeView, path *TreePath, openAll bool) bool
	// ExpandToPath expands the row at @path. This will also expand all parent
	// rows of @path as necessary.
	ExpandToPath(t TreeView, path *TreePath)
	// ActivateOnSingleClick gets the setting set by
	// gtk_tree_view_set_activate_on_single_click().
	ActivateOnSingleClick(t TreeView) bool
	// BackgroundArea fills the bounding rectangle in bin_window coordinates for
	// the cell at the row specified by @path and the column specified by
	// @column. If @path is nil, or points to a node not found in the tree, the
	// @y and @height fields of the rectangle will be filled with 0. If @column
	// is nil, the @x and @width fields will be filled with 0. The returned
	// rectangle is equivalent to the @background_area passed to
	// gtk_cell_renderer_render(). These background areas tile to cover the
	// entire bin window. Contrast with the @cell_area, returned by
	// gtk_tree_view_get_cell_area(), which returns only the cell itself,
	// excluding surrounding borders and the tree expander area.
	BackgroundArea(t TreeView, path *TreePath, column TreeViewColumn) *gdk.Rectangle
	// CellArea fills the bounding rectangle in bin_window coordinates for the
	// cell at the row specified by @path and the column specified by @column.
	// If @path is nil, or points to a path not currently displayed, the @y and
	// @height fields of the rectangle will be filled with 0. If @column is nil,
	// the @x and @width fields will be filled with 0. The sum of all cell rects
	// does not cover the entire tree; there are extra pixels in between rows,
	// for example. The returned rectangle is equivalent to the @cell_area
	// passed to gtk_cell_renderer_render(). This function is only valid if
	// @tree_view is realized.
	CellArea(t TreeView, path *TreePath, column TreeViewColumn) *gdk.Rectangle
	// Column gets the TreeViewColumn at the given position in the #tree_view.
	Column(t TreeView, n int)
	// Columns returns a #GList of all the TreeViewColumn s currently in
	// @tree_view. The returned list must be freed with g_list_free ().
	Columns(t TreeView)
	// Cursor fills in @path and @focus_column with the current path and focus
	// column. If the cursor isn’t currently set, then *@path will be nil. If no
	// column currently has focus, then *@focus_column will be nil.
	//
	// The returned TreePath must be freed with gtk_tree_path_free() when you
	// are done with it.
	Cursor(t TreeView) (path **TreePath, focusColumn TreeViewColumn)
	// DestRowAtPos determines the destination row for a given position. @drag_x
	// and @drag_y are expected to be in widget coordinates. This function is
	// only meaningful if @tree_view is realized. Therefore this function will
	// always return false if @tree_view is not realized or does not have a
	// model.
	DestRowAtPos(t TreeView, dragX int, dragY int) (path **TreePath, pos *TreeViewDropPosition, ok bool)
	// DragDestRow gets information about the row that is highlighted for
	// feedback.
	DragDestRow(t TreeView) (path **TreePath, pos *TreeViewDropPosition)
	// EnableSearch returns whether or not the tree allows to start interactive
	// searching by typing in text.
	EnableSearch(t TreeView) bool
	// EnableTreeLines returns whether or not tree lines are drawn in
	// @tree_view.
	EnableTreeLines(t TreeView) bool
	// ExpanderColumn returns the column that is the current expander column, or
	// nil if none has been set. This column has the expander arrow drawn next
	// to it.
	ExpanderColumn(t TreeView)
	// FixedHeightMode returns whether fixed height mode is turned on for
	// @tree_view.
	FixedHeightMode(t TreeView) bool
	// GridLines returns which grid lines are enabled in @tree_view.
	GridLines(t TreeView)
	// HeadersClickable returns whether all header columns are clickable.
	HeadersClickable(t TreeView) bool
	// HeadersVisible returns true if the headers on the @tree_view are visible.
	HeadersVisible(t TreeView) bool
	// HoverExpand returns whether hover expansion mode is turned on for
	// @tree_view.
	HoverExpand(t TreeView) bool
	// HoverSelection returns whether hover selection mode is turned on for
	// @tree_view.
	HoverSelection(t TreeView) bool
	// LevelIndentation returns the amount, in pixels, of extra indentation for
	// child levels in @tree_view.
	LevelIndentation(t TreeView)
	// Model returns the model the TreeView is based on. Returns nil if the
	// model is unset.
	Model(t TreeView)
	// NColumns queries the number of columns in the given @tree_view.
	NColumns(t TreeView)
	// PathAtPos finds the path at the point (@x, @y), relative to bin_window
	// coordinates. That is, @x and @y are relative to an events coordinates.
	// Widget-relative coordinates must be converted using
	// gtk_tree_view_convert_widget_to_bin_window_coords(). It is primarily for
	// things like popup menus. If @path is non-nil, then it will be filled with
	// the TreePath at that point. This path should be freed with
	// gtk_tree_path_free(). If @column is non-nil, then it will be filled with
	// the column at that point. @cell_x and @cell_y return the coordinates
	// relative to the cell background (i.e. the @background_area passed to
	// gtk_cell_renderer_render()). This function is only meaningful if
	// @tree_view is realized. Therefore this function will always return false
	// if @tree_view is not realized or does not have a model.
	//
	// For converting widget coordinates (eg. the ones you get from
	// GtkWidget::query-tooltip), please see
	// gtk_tree_view_convert_widget_to_bin_window_coords().
	PathAtPos(t TreeView, x int, y int) (path **TreePath, column TreeViewColumn, cellX int, cellY int, ok bool)
	// Reorderable retrieves whether the user can reorder the tree via
	// drag-and-drop. See gtk_tree_view_set_reorderable().
	Reorderable(t TreeView) bool
	// RowSeparatorFunc returns the current row separator function.
	RowSeparatorFunc(t TreeView)
	// RubberBanding returns whether rubber banding is turned on for @tree_view.
	// If the selection mode is K_SELECTION_MULTIPLE, rubber banding will allow
	// the user to select multiple rows by dragging the mouse.
	RubberBanding(t TreeView) bool
	// SearchColumn gets the column searched on by the interactive search code.
	SearchColumn(t TreeView)
	// SearchEntry returns the Entry which is currently in use as interactive
	// search entry for @tree_view. In case the built-in entry is being used,
	// nil will be returned.
	SearchEntry(t TreeView)
	// SearchEqualFunc returns the compare function currently in use.
	SearchEqualFunc(t TreeView)
	// Selection gets the TreeSelection associated with @tree_view.
	Selection(t TreeView)
	// ShowExpanders returns whether or not expanders are drawn in @tree_view.
	ShowExpanders(t TreeView) bool
	// TooltipColumn returns the column of @tree_view’s model which is being
	// used for displaying tooltips on @tree_view’s rows.
	TooltipColumn(t TreeView)
	// TooltipContext: this function is supposed to be used in a
	// Widget::query-tooltip signal handler for TreeView. The @x, @y and
	// @keyboard_tip values which are received in the signal handler, should be
	// passed to this function without modification.
	//
	// The return value indicates whether there is a tree view row at the given
	// coordinates (true) or not (false) for mouse tooltips. For keyboard
	// tooltips the row returned will be the cursor row. When true, then any of
	// @model, @path and @iter which have been provided will be set to point to
	// that row and the corresponding model. @x and @y will always be converted
	// to be relative to @tree_view’s bin_window if @keyboard_tooltip is false.
	TooltipContext(t TreeView, x int, y int, keyboardTip bool) (model *TreeModel, path **TreePath, iter *TreeIter, ok bool)
	// VisibleRange sets @start_path and @end_path to be the first and last
	// visible path. Note that there may be invisible paths in between.
	//
	// The paths should be freed with gtk_tree_path_free() after use.
	VisibleRange(t TreeView) (startPath **TreePath, endPath **TreePath, ok bool)
	// VisibleRect fills @visible_rect with the currently-visible region of the
	// buffer, in tree coordinates. Convert to bin_window coordinates with
	// gtk_tree_view_convert_tree_to_bin_window_coords(). Tree coordinates start
	// at 0,0 for row 0 of the tree, and cover the entire scrollable area of the
	// tree.
	VisibleRect(t TreeView) *gdk.Rectangle
	// InsertColumn: this inserts the @column into the @tree_view at @position.
	// If @position is -1, then the column is inserted at the end. If @tree_view
	// has “fixed_height” mode enabled, then @column must have its “sizing”
	// property set to be GTK_TREE_VIEW_COLUMN_FIXED.
	InsertColumn(t TreeView, column TreeViewColumn, position int)
	// InsertColumnWithDataFunc: convenience function that inserts a new column
	// into the TreeView with the given cell renderer and a TreeCellDataFunc to
	// set cell renderer attributes (normally using data from the model). See
	// also gtk_tree_view_column_set_cell_data_func(),
	// gtk_tree_view_column_pack_start(). If @tree_view has “fixed_height” mode
	// enabled, then the new column will have its “sizing” property set to be
	// GTK_TREE_VIEW_COLUMN_FIXED.
	InsertColumnWithDataFunc(t TreeView)
	// IsBlankAtPos: determine whether the point (@x, @y) in @tree_view is
	// blank, that is no cell content nor an expander arrow is drawn at the
	// location. If so, the location can be considered as the background. You
	// might wish to take special action on clicks on the background, such as
	// clearing a current selection, having a custom context menu or starting
	// rubber banding.
	//
	// The @x and @y coordinate that are provided must be relative to bin_window
	// coordinates. Widget-relative coordinates must be converted using
	// gtk_tree_view_convert_widget_to_bin_window_coords().
	//
	// For converting widget coordinates (eg. the ones you get from
	// GtkWidget::query-tooltip), please see
	// gtk_tree_view_convert_widget_to_bin_window_coords().
	//
	// The @path, @column, @cell_x and @cell_y arguments will be filled in
	// likewise as for gtk_tree_view_get_path_at_pos(). Please see
	// gtk_tree_view_get_path_at_pos() for more information.
	IsBlankAtPos(t TreeView, x int, y int) (path **TreePath, column TreeViewColumn, cellX int, cellY int, ok bool)
	// IsRubberBandingActive returns whether a rubber banding operation is
	// currently being done in @tree_view.
	IsRubberBandingActive(t TreeView) bool
	// MapExpandedRows calls @func on all expanded rows.
	MapExpandedRows(t TreeView)
	// MoveColumnAfter moves @column to be after to @base_column. If
	// @base_column is nil, then @column is placed in the first position.
	MoveColumnAfter(t TreeView, column TreeViewColumn, baseColumn TreeViewColumn)
	// RemoveColumn removes @column from @tree_view.
	RemoveColumn(t TreeView, column TreeViewColumn)
	// RowActivated activates the cell determined by @path and @column.
	RowActivated(t TreeView, path *TreePath, column TreeViewColumn)
	// RowExpanded returns true if the node pointed to by @path is expanded in
	// @tree_view.
	RowExpanded(t TreeView, path *TreePath) bool
	// ScrollToCell moves the alignments of @tree_view to the position specified
	// by @column and @path. If @column is nil, then no horizontal scrolling
	// occurs. Likewise, if @path is nil no vertical scrolling occurs. At a
	// minimum, one of @column or @path need to be non-nil. @row_align
	// determines where the row is placed, and @col_align determines where
	// @column is placed. Both are expected to be between 0.0 and 1.0. 0.0 means
	// left/top alignment, 1.0 means right/bottom alignment, 0.5 means center.
	//
	// If @use_align is false, then the alignment arguments are ignored, and the
	// tree does the minimum amount of work to scroll the cell onto the screen.
	// This means that the cell will be scrolled to the edge closest to its
	// current position. If the cell is currently visible on the screen, nothing
	// is done.
	//
	// This function only works if the model is set, and @path is a valid row on
	// the model. If the model changes before the @tree_view is realized, the
	// centered path will be modified to reflect this change.
	ScrollToCell(t TreeView, path *TreePath, column TreeViewColumn, useAlign bool, rowAlign float32, colAlign float32)
	// ScrollToPoint scrolls the tree view such that the top-left corner of the
	// visible area is @tree_x, @tree_y, where @tree_x and @tree_y are specified
	// in tree coordinates. The @tree_view must be realized before this function
	// is called. If it isn't, you probably want to be using
	// gtk_tree_view_scroll_to_cell().
	//
	// If either @tree_x or @tree_y are -1, then that direction isn’t scrolled.
	ScrollToPoint(t TreeView, treeX int, treeY int)
	// SetActivateOnSingleClick: cause the TreeView::row-activated signal to be
	// emitted on a single click instead of a double click.
	SetActivateOnSingleClick(t TreeView, single bool)
	// SetColumnDragFunction sets a user function for determining where a column
	// may be dropped when dragged. This function is called on every column pair
	// in turn at the beginning of a column drag to determine where a drop can
	// take place. The arguments passed to @func are: the @tree_view, the
	// TreeViewColumn being dragged, the two TreeViewColumn s determining the
	// drop spot, and @user_data. If either of the TreeViewColumn arguments for
	// the drop spot are nil, then they indicate an edge. If @func is set to be
	// nil, then @tree_view reverts to the default behavior of allowing all
	// columns to be dropped everywhere.
	SetColumnDragFunction(t TreeView)
	// SetCursor sets the current keyboard focus to be at @path, and selects it.
	// This is useful when you want to focus the user’s attention on a
	// particular row. If @focus_column is not nil, then focus is given to the
	// column specified by it. Additionally, if @focus_column is specified, and
	// @start_editing is true, then editing should be started in the specified
	// cell. This function is often followed by @gtk_widget_grab_focus
	// (@tree_view) in order to give keyboard focus to the widget. Please note
	// that editing can only happen when the widget is realized.
	//
	// If @path is invalid for @model, the current cursor (if any) will be unset
	// and the function will return without failing.
	SetCursor(t TreeView, path *TreePath, focusColumn TreeViewColumn, startEditing bool)
	// SetCursorOnCell sets the current keyboard focus to be at @path, and
	// selects it. This is useful when you want to focus the user’s attention on
	// a particular row. If @focus_column is not nil, then focus is given to the
	// column specified by it. If @focus_column and @focus_cell are not nil, and
	// @focus_column contains 2 or more editable or activatable cells, then
	// focus is given to the cell specified by @focus_cell. Additionally, if
	// @focus_column is specified, and @start_editing is true, then editing
	// should be started in the specified cell. This function is often followed
	// by @gtk_widget_grab_focus (@tree_view) in order to give keyboard focus to
	// the widget. Please note that editing can only happen when the widget is
	// realized.
	//
	// If @path is invalid for @model, the current cursor (if any) will be unset
	// and the function will return without failing.
	SetCursorOnCell(t TreeView, path *TreePath, focusColumn TreeViewColumn, focusCell CellRenderer, startEditing bool)
	// SetDragDestRow sets the row that is highlighted for feedback. If @path is
	// nil, an existing highlight is removed.
	SetDragDestRow(t TreeView, path *TreePath, pos TreeViewDropPosition)
	// SetEnableSearch: if @enable_search is set, then the user can type in text
	// to search through the tree interactively (this is sometimes called
	// "typeahead find").
	//
	// Note that even if this is false, the user can still initiate a search
	// using the “start-interactive-search” key binding.
	SetEnableSearch(t TreeView, enableSearch bool)
	// SetEnableTreeLines sets whether to draw lines interconnecting the
	// expanders in @tree_view. This does not have any visible effects for
	// lists.
	SetEnableTreeLines(t TreeView, enabled bool)
	// SetExpanderColumn sets the column to draw the expander arrow at. It must
	// be in @tree_view. If @column is nil, then the expander arrow is always at
	// the first visible column.
	//
	// If you do not want expander arrow to appear in your tree, set the
	// expander column to a hidden column.
	SetExpanderColumn(t TreeView, column TreeViewColumn)
	// SetFixedHeightMode enables or disables the fixed height mode of
	// @tree_view. Fixed height mode speeds up TreeView by assuming that all
	// rows have the same height. Only enable this option if all rows are the
	// same height and all columns are of type GTK_TREE_VIEW_COLUMN_FIXED.
	SetFixedHeightMode(t TreeView, enable bool)
	// SetGridLines sets which grid lines to draw in @tree_view.
	SetGridLines(t TreeView, gridLines TreeViewGridLines)
	// SetHeadersClickable: allow the column title buttons to be clicked.
	SetHeadersClickable(t TreeView, setting bool)
	// SetHeadersVisible sets the visibility state of the headers.
	SetHeadersVisible(t TreeView, headersVisible bool)
	// SetHoverExpand enables or disables the hover expansion mode of
	// @tree_view. Hover expansion makes rows expand or collapse if the pointer
	// moves over them.
	SetHoverExpand(t TreeView, expand bool)
	// SetHoverSelection enables or disables the hover selection mode of
	// @tree_view. Hover selection makes the selected row follow the pointer.
	// Currently, this works only for the selection modes GTK_SELECTION_SINGLE
	// and GTK_SELECTION_BROWSE.
	SetHoverSelection(t TreeView, hover bool)
	// SetLevelIndentation sets the amount of extra indentation for child levels
	// to use in @tree_view in addition to the default indentation. The value
	// should be specified in pixels, a value of 0 disables this feature and in
	// this case only the default indentation will be used. This does not have
	// any visible effects for lists.
	SetLevelIndentation(t TreeView, indentation int)
	// SetModel sets the model for a TreeView. If the @tree_view already has a
	// model set, it will remove it before setting the new model. If @model is
	// nil, then it will unset the old model.
	SetModel(t TreeView, model TreeModel)
	// SetReorderable: this function is a convenience function to allow you to
	// reorder models that support the TreeDragSourceIface and the
	// TreeDragDestIface. Both TreeStore and ListStore support these. If
	// @reorderable is true, then the user can reorder the model by dragging and
	// dropping rows. The developer can listen to these changes by connecting to
	// the model’s TreeModel::row-inserted and TreeModel::row-deleted signals.
	// The reordering is implemented by setting up the tree view as a drag
	// source and destination. Therefore, drag and drop can not be used in a
	// reorderable view for any other purpose.
	//
	// This function does not give you any degree of control over the order --
	// any reordering is allowed. If more control is needed, you should probably
	// handle drag and drop manually.
	SetReorderable(t TreeView, reorderable bool)
	// SetRowSeparatorFunc sets the row separator function, which is used to
	// determine whether a row should be drawn as a separator. If the row
	// separator function is nil, no separators are drawn. This is the default
	// value.
	SetRowSeparatorFunc(t TreeView)
	// SetRubberBanding enables or disables rubber banding in @tree_view. If the
	// selection mode is K_SELECTION_MULTIPLE, rubber banding will allow the
	// user to select multiple rows by dragging the mouse.
	SetRubberBanding(t TreeView, enable bool)
	// SetSearchColumn sets @column as the column where the interactive search
	// code should search in for the current model.
	//
	// If the search column is set, users can use the “start-interactive-search”
	// key binding to bring up search popup. The enable-search property controls
	// whether simply typing text will also start an interactive search.
	//
	// Note that @column refers to a column of the current model. The search
	// column is reset to -1 when the model is changed.
	SetSearchColumn(t TreeView, column int)
	// SetSearchEntry sets the entry which the interactive search code will use
	// for this @tree_view. This is useful when you want to provide a search
	// entry in our interface at all time at a fixed position. Passing nil for
	// @entry will make the interactive search code use the built-in popup entry
	// again.
	SetSearchEntry(t TreeView, entry Editable)
	// SetSearchEqualFunc sets the compare function for the interactive search
	// capabilities; note that somewhat like strcmp() returning 0 for equality
	// TreeViewSearchEqualFunc returns false on matches.
	SetSearchEqualFunc(t TreeView)
	// SetShowExpanders sets whether to draw and enable expanders and indent
	// child rows in @tree_view. When disabled there will be no expanders
	// visible in trees and there will be no way to expand and collapse rows by
	// default. Also note that hiding the expanders will disable the default
	// indentation. You can set a custom indentation in this case using
	// gtk_tree_view_set_level_indentation(). This does not have any visible
	// effects for lists.
	SetShowExpanders(t TreeView, enabled bool)
	// SetTooltipCell sets the tip area of @tooltip to the area @path, @column
	// and @cell have in common. For example if @path is nil and @column is set,
	// the tip area will be set to the full area covered by @column. See also
	// gtk_tooltip_set_tip_area().
	//
	// Note that if @path is not specified and @cell is set and part of a column
	// containing the expander, the tooltip might not show and hide at the
	// correct position. In such cases @path must be set to the current node
	// under the mouse cursor for this function to operate correctly.
	//
	// See also gtk_tree_view_set_tooltip_column() for a simpler alternative.
	SetTooltipCell(t TreeView, tooltip Tooltip, path *TreePath, column TreeViewColumn, cell CellRenderer)
	// SetTooltipColumn: if you only plan to have simple (text-only) tooltips on
	// full rows, you can use this function to have TreeView handle these
	// automatically for you. @column should be set to the column in
	// @tree_view’s model containing the tooltip texts, or -1 to disable this
	// feature.
	//
	// When enabled, Widget:has-tooltip will be set to true and @tree_view will
	// connect a Widget::query-tooltip signal handler.
	//
	// Note that the signal handler sets the text with gtk_tooltip_set_markup(),
	// so &, <, etc have to be escaped in the text.
	SetTooltipColumn(t TreeView, column int)
	// SetTooltipRow sets the tip area of @tooltip to be the area covered by the
	// row at @path. See also gtk_tree_view_set_tooltip_column() for a simpler
	// alternative. See also gtk_tooltip_set_tip_area().
	SetTooltipRow(t TreeView, tooltip Tooltip, path *TreePath)
	// UnsetRowsDragDest undoes the effect of
	// gtk_tree_view_enable_model_drag_dest(). Calling this method sets
	// TreeView:reorderable to false.
	UnsetRowsDragDest(t TreeView)
	// UnsetRowsDragSource undoes the effect of
	// gtk_tree_view_enable_model_drag_source(). Calling this method sets
	// TreeView:reorderable to false.
	UnsetRowsDragSource(t TreeView)
}

// treeView implements the TreeView interface.
type treeView struct {
	Widget
	Accessible
	Buildable
	ConstraintTarget
	Scrollable
}

var _ TreeView = (*treeView)(nil)

// WrapTreeView wraps a GObject to the right type. It is
// primarily used internally.
func WrapTreeView(obj *externglib.Object) TreeView {
	return TreeView{
		Widget:           WrapWidget(obj),
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
		Scrollable:       WrapScrollable(obj),
	}
}

func marshalTreeView(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTreeView(obj), nil
}

// NewTreeView constructs a class TreeView.
func NewTreeView() {
	C.gtk_tree_view_new()
}

// NewTreeViewWithModel constructs a class TreeView.
func NewTreeViewWithModel(model TreeModel) {
	var arg1 *C.GtkTreeModel

	arg1 = (*C.GtkTreeModel)(unsafe.Pointer(model.Native()))

	C.gtk_tree_view_new_with_model(arg1)
}

// AppendColumn appends @column to the list of columns. If @tree_view has
// “fixed_height” mode enabled, then @column must have its “sizing” property
// set to be GTK_TREE_VIEW_COLUMN_FIXED.
func (t treeView) AppendColumn(t TreeView, column TreeViewColumn) {
	var arg0 *C.GtkTreeView
	var arg1 *C.GtkTreeViewColumn

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	arg1 = (*C.GtkTreeViewColumn)(unsafe.Pointer(column.Native()))

	C.gtk_tree_view_append_column(arg0, arg1)
}

// CollapseAll: recursively collapses all visible, expanded nodes in
// @tree_view.
func (t treeView) CollapseAll(t TreeView) {
	var arg0 *C.GtkTreeView

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	C.gtk_tree_view_collapse_all(arg0)
}

// CollapseRow collapses a row (hides its child rows, if they exist).
func (t treeView) CollapseRow(t TreeView, path *TreePath) bool {
	var arg0 *C.GtkTreeView
	var arg1 *C.GtkTreePath

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_tree_view_collapse_row(arg0, arg1)

	if cret {
		ok = true
	}

	return ok
}

// ColumnsAutosize resizes all columns to their optimal width. Only works
// after the treeview has been realized.
func (t treeView) ColumnsAutosize(t TreeView) {
	var arg0 *C.GtkTreeView

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	C.gtk_tree_view_columns_autosize(arg0)
}

// ConvertBinWindowToTreeCoords converts bin_window coordinates to
// coordinates for the tree (the full scrollable area of the tree).
func (t treeView) ConvertBinWindowToTreeCoords(t TreeView, bx int, by int) (tx int, ty int) {
	var arg0 *C.GtkTreeView
	var arg1 C.int
	var arg2 C.int

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	arg1 = C.int(bx)
	arg2 = C.int(by)

	var arg3 C.int
	var tx int
	var arg4 C.int
	var ty int

	C.gtk_tree_view_convert_bin_window_to_tree_coords(arg0, arg1, arg2, &arg3, &arg4)

	tx = int(&arg3)
	ty = int(&arg4)

	return tx, ty
}

// ConvertBinWindowToWidgetCoords converts bin_window coordinates to widget
// relative coordinates.
func (t treeView) ConvertBinWindowToWidgetCoords(t TreeView, bx int, by int) (wx int, wy int) {
	var arg0 *C.GtkTreeView
	var arg1 C.int
	var arg2 C.int

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	arg1 = C.int(bx)
	arg2 = C.int(by)

	var arg3 C.int
	var wx int
	var arg4 C.int
	var wy int

	C.gtk_tree_view_convert_bin_window_to_widget_coords(arg0, arg1, arg2, &arg3, &arg4)

	wx = int(&arg3)
	wy = int(&arg4)

	return wx, wy
}

// ConvertTreeToBinWindowCoords converts tree coordinates (coordinates in
// full scrollable area of the tree) to bin_window coordinates.
func (t treeView) ConvertTreeToBinWindowCoords(t TreeView, tx int, ty int) (bx int, by int) {
	var arg0 *C.GtkTreeView
	var arg1 C.int
	var arg2 C.int

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	arg1 = C.int(tx)
	arg2 = C.int(ty)

	var arg3 C.int
	var bx int
	var arg4 C.int
	var by int

	C.gtk_tree_view_convert_tree_to_bin_window_coords(arg0, arg1, arg2, &arg3, &arg4)

	bx = int(&arg3)
	by = int(&arg4)

	return bx, by
}

// ConvertTreeToWidgetCoords converts tree coordinates (coordinates in full
// scrollable area of the tree) to widget coordinates.
func (t treeView) ConvertTreeToWidgetCoords(t TreeView, tx int, ty int) (wx int, wy int) {
	var arg0 *C.GtkTreeView
	var arg1 C.int
	var arg2 C.int

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	arg1 = C.int(tx)
	arg2 = C.int(ty)

	var arg3 C.int
	var wx int
	var arg4 C.int
	var wy int

	C.gtk_tree_view_convert_tree_to_widget_coords(arg0, arg1, arg2, &arg3, &arg4)

	wx = int(&arg3)
	wy = int(&arg4)

	return wx, wy
}

// ConvertWidgetToBinWindowCoords converts widget coordinates to coordinates
// for the bin_window.
func (t treeView) ConvertWidgetToBinWindowCoords(t TreeView, wx int, wy int) (bx int, by int) {
	var arg0 *C.GtkTreeView
	var arg1 C.int
	var arg2 C.int

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	arg1 = C.int(wx)
	arg2 = C.int(wy)

	var arg3 C.int
	var bx int
	var arg4 C.int
	var by int

	C.gtk_tree_view_convert_widget_to_bin_window_coords(arg0, arg1, arg2, &arg3, &arg4)

	bx = int(&arg3)
	by = int(&arg4)

	return bx, by
}

// ConvertWidgetToTreeCoords converts widget coordinates to coordinates for
// the tree (the full scrollable area of the tree).
func (t treeView) ConvertWidgetToTreeCoords(t TreeView, wx int, wy int) (tx int, ty int) {
	var arg0 *C.GtkTreeView
	var arg1 C.int
	var arg2 C.int

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	arg1 = C.int(wx)
	arg2 = C.int(wy)

	var arg3 C.int
	var tx int
	var arg4 C.int
	var ty int

	C.gtk_tree_view_convert_widget_to_tree_coords(arg0, arg1, arg2, &arg3, &arg4)

	tx = int(&arg3)
	ty = int(&arg4)

	return tx, ty
}

// CreateRowDragIcon creates a #cairo_surface_t representation of the row at
// @path. This image is used for a drag icon.
func (t treeView) CreateRowDragIcon(t TreeView, path *TreePath) {
	var arg0 *C.GtkTreeView
	var arg1 *C.GtkTreePath

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	C.gtk_tree_view_create_row_drag_icon(arg0, arg1)
}

// EnableModelDragDest turns @tree_view into a drop destination for
// automatic DND. Calling this method sets TreeView:reorderable to false.
func (t treeView) EnableModelDragDest(t TreeView, formats *gdk.ContentFormats, actions gdk.DragAction) {
	var arg0 *C.GtkTreeView
	var arg1 *C.GdkContentFormats
	var arg2 C.GdkDragAction

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	arg1 = (*C.GdkContentFormats)(unsafe.Pointer(formats.Native()))
	arg2 = (C.GdkDragAction)(actions)

	C.gtk_tree_view_enable_model_drag_dest(arg0, arg1, arg2)
}

// EnableModelDragSource turns @tree_view into a drag source for automatic
// DND. Calling this method sets TreeView:reorderable to false.
func (t treeView) EnableModelDragSource(t TreeView, startButtonMask gdk.ModifierType, formats *gdk.ContentFormats, actions gdk.DragAction) {
	var arg0 *C.GtkTreeView
	var arg1 C.GdkModifierType
	var arg2 *C.GdkContentFormats
	var arg3 C.GdkDragAction

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	arg1 = (C.GdkModifierType)(startButtonMask)
	arg2 = (*C.GdkContentFormats)(unsafe.Pointer(formats.Native()))
	arg3 = (C.GdkDragAction)(actions)

	C.gtk_tree_view_enable_model_drag_source(arg0, arg1, arg2, arg3)
}

// ExpandAll: recursively expands all nodes in the @tree_view.
func (t treeView) ExpandAll(t TreeView) {
	var arg0 *C.GtkTreeView

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	C.gtk_tree_view_expand_all(arg0)
}

// ExpandRow opens the row so its children are visible.
func (t treeView) ExpandRow(t TreeView, path *TreePath, openAll bool) bool {
	var arg0 *C.GtkTreeView
	var arg1 *C.GtkTreePath
	var arg2 C.gboolean

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
	if openAll {
		arg2 = C.gboolean(1)
	}

	var cret C.gboolean
	var ok bool

	cret = C.gtk_tree_view_expand_row(arg0, arg1, arg2)

	if cret {
		ok = true
	}

	return ok
}

// ExpandToPath expands the row at @path. This will also expand all parent
// rows of @path as necessary.
func (t treeView) ExpandToPath(t TreeView, path *TreePath) {
	var arg0 *C.GtkTreeView
	var arg1 *C.GtkTreePath

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	C.gtk_tree_view_expand_to_path(arg0, arg1)
}

// ActivateOnSingleClick gets the setting set by
// gtk_tree_view_set_activate_on_single_click().
func (t treeView) ActivateOnSingleClick(t TreeView) bool {
	var arg0 *C.GtkTreeView

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_tree_view_get_activate_on_single_click(arg0)

	if cret {
		ok = true
	}

	return ok
}

// BackgroundArea fills the bounding rectangle in bin_window coordinates for
// the cell at the row specified by @path and the column specified by
// @column. If @path is nil, or points to a node not found in the tree, the
// @y and @height fields of the rectangle will be filled with 0. If @column
// is nil, the @x and @width fields will be filled with 0. The returned
// rectangle is equivalent to the @background_area passed to
// gtk_cell_renderer_render(). These background areas tile to cover the
// entire bin window. Contrast with the @cell_area, returned by
// gtk_tree_view_get_cell_area(), which returns only the cell itself,
// excluding surrounding borders and the tree expander area.
func (t treeView) BackgroundArea(t TreeView, path *TreePath, column TreeViewColumn) *gdk.Rectangle {
	var arg0 *C.GtkTreeView
	var arg1 *C.GtkTreePath
	var arg2 *C.GtkTreeViewColumn

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
	arg2 = (*C.GtkTreeViewColumn)(unsafe.Pointer(column.Native()))

	var arg3 C.GdkRectangle
	var rect *gdk.Rectangle

	C.gtk_tree_view_get_background_area(arg0, arg1, arg2, &arg3)

	rect = gdk.WrapRectangle(unsafe.Pointer(&arg3))

	return rect
}

// CellArea fills the bounding rectangle in bin_window coordinates for the
// cell at the row specified by @path and the column specified by @column.
// If @path is nil, or points to a path not currently displayed, the @y and
// @height fields of the rectangle will be filled with 0. If @column is nil,
// the @x and @width fields will be filled with 0. The sum of all cell rects
// does not cover the entire tree; there are extra pixels in between rows,
// for example. The returned rectangle is equivalent to the @cell_area
// passed to gtk_cell_renderer_render(). This function is only valid if
// @tree_view is realized.
func (t treeView) CellArea(t TreeView, path *TreePath, column TreeViewColumn) *gdk.Rectangle {
	var arg0 *C.GtkTreeView
	var arg1 *C.GtkTreePath
	var arg2 *C.GtkTreeViewColumn

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
	arg2 = (*C.GtkTreeViewColumn)(unsafe.Pointer(column.Native()))

	var arg3 C.GdkRectangle
	var rect *gdk.Rectangle

	C.gtk_tree_view_get_cell_area(arg0, arg1, arg2, &arg3)

	rect = gdk.WrapRectangle(unsafe.Pointer(&arg3))

	return rect
}

// Column gets the TreeViewColumn at the given position in the #tree_view.
func (t treeView) Column(t TreeView, n int) {
	var arg0 *C.GtkTreeView
	var arg1 C.int

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	arg1 = C.int(n)

	C.gtk_tree_view_get_column(arg0, arg1)
}

// Columns returns a #GList of all the TreeViewColumn s currently in
// @tree_view. The returned list must be freed with g_list_free ().
func (t treeView) Columns(t TreeView) {
	var arg0 *C.GtkTreeView

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	C.gtk_tree_view_get_columns(arg0)
}

// Cursor fills in @path and @focus_column with the current path and focus
// column. If the cursor isn’t currently set, then *@path will be nil. If no
// column currently has focus, then *@focus_column will be nil.
//
// The returned TreePath must be freed with gtk_tree_path_free() when you
// are done with it.
func (t treeView) Cursor(t TreeView) (path **TreePath, focusColumn TreeViewColumn) {
	var arg0 *C.GtkTreeView

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	var arg1 *C.GtkTreePath
	var path **TreePath
	var arg2 *C.GtkTreeViewColumn
	var focusColumn TreeViewColumn

	C.gtk_tree_view_get_cursor(arg0, &arg1, &arg2)

	path = WrapTreePath(unsafe.Pointer(&arg1))
	runtime.SetFinalizer(path, func(v **TreePath) {
		C.free(unsafe.Pointer(v.Native()))
	})
	focusColumn = gextras.CastObject(externglib.Take(unsafe.Pointer(&arg2.Native()))).(TreeViewColumn)

	return path, focusColumn
}

// DestRowAtPos determines the destination row for a given position. @drag_x
// and @drag_y are expected to be in widget coordinates. This function is
// only meaningful if @tree_view is realized. Therefore this function will
// always return false if @tree_view is not realized or does not have a
// model.
func (t treeView) DestRowAtPos(t TreeView, dragX int, dragY int) (path **TreePath, pos *TreeViewDropPosition, ok bool) {
	var arg0 *C.GtkTreeView
	var arg1 C.int
	var arg2 C.int

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	arg1 = C.int(dragX)
	arg2 = C.int(dragY)

	var arg3 *C.GtkTreePath
	var path **TreePath
	var arg4 C.GtkTreeViewDropPosition
	var pos *TreeViewDropPosition
	var cret C.gboolean
	var ok bool

	cret = C.gtk_tree_view_get_dest_row_at_pos(arg0, arg1, arg2, &arg3, &arg4)

	path = WrapTreePath(unsafe.Pointer(&arg3))
	runtime.SetFinalizer(path, func(v **TreePath) {
		C.free(unsafe.Pointer(v.Native()))
	})
	pos = *TreeViewDropPosition(&arg4)
	if cret {
		ok = true
	}

	return path, pos, ok
}

// DragDestRow gets information about the row that is highlighted for
// feedback.
func (t treeView) DragDestRow(t TreeView) (path **TreePath, pos *TreeViewDropPosition) {
	var arg0 *C.GtkTreeView

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	var arg1 *C.GtkTreePath
	var path **TreePath
	var arg2 C.GtkTreeViewDropPosition
	var pos *TreeViewDropPosition

	C.gtk_tree_view_get_drag_dest_row(arg0, &arg1, &arg2)

	path = WrapTreePath(unsafe.Pointer(&arg1))
	runtime.SetFinalizer(path, func(v **TreePath) {
		C.free(unsafe.Pointer(v.Native()))
	})
	pos = *TreeViewDropPosition(&arg2)

	return path, pos
}

// EnableSearch returns whether or not the tree allows to start interactive
// searching by typing in text.
func (t treeView) EnableSearch(t TreeView) bool {
	var arg0 *C.GtkTreeView

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_tree_view_get_enable_search(arg0)

	if cret {
		ok = true
	}

	return ok
}

// EnableTreeLines returns whether or not tree lines are drawn in
// @tree_view.
func (t treeView) EnableTreeLines(t TreeView) bool {
	var arg0 *C.GtkTreeView

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_tree_view_get_enable_tree_lines(arg0)

	if cret {
		ok = true
	}

	return ok
}

// ExpanderColumn returns the column that is the current expander column, or
// nil if none has been set. This column has the expander arrow drawn next
// to it.
func (t treeView) ExpanderColumn(t TreeView) {
	var arg0 *C.GtkTreeView

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	C.gtk_tree_view_get_expander_column(arg0)
}

// FixedHeightMode returns whether fixed height mode is turned on for
// @tree_view.
func (t treeView) FixedHeightMode(t TreeView) bool {
	var arg0 *C.GtkTreeView

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_tree_view_get_fixed_height_mode(arg0)

	if cret {
		ok = true
	}

	return ok
}

// GridLines returns which grid lines are enabled in @tree_view.
func (t treeView) GridLines(t TreeView) {
	var arg0 *C.GtkTreeView

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	C.gtk_tree_view_get_grid_lines(arg0)
}

// HeadersClickable returns whether all header columns are clickable.
func (t treeView) HeadersClickable(t TreeView) bool {
	var arg0 *C.GtkTreeView

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_tree_view_get_headers_clickable(arg0)

	if cret {
		ok = true
	}

	return ok
}

// HeadersVisible returns true if the headers on the @tree_view are visible.
func (t treeView) HeadersVisible(t TreeView) bool {
	var arg0 *C.GtkTreeView

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_tree_view_get_headers_visible(arg0)

	if cret {
		ok = true
	}

	return ok
}

// HoverExpand returns whether hover expansion mode is turned on for
// @tree_view.
func (t treeView) HoverExpand(t TreeView) bool {
	var arg0 *C.GtkTreeView

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_tree_view_get_hover_expand(arg0)

	if cret {
		ok = true
	}

	return ok
}

// HoverSelection returns whether hover selection mode is turned on for
// @tree_view.
func (t treeView) HoverSelection(t TreeView) bool {
	var arg0 *C.GtkTreeView

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_tree_view_get_hover_selection(arg0)

	if cret {
		ok = true
	}

	return ok
}

// LevelIndentation returns the amount, in pixels, of extra indentation for
// child levels in @tree_view.
func (t treeView) LevelIndentation(t TreeView) {
	var arg0 *C.GtkTreeView

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	C.gtk_tree_view_get_level_indentation(arg0)
}

// Model returns the model the TreeView is based on. Returns nil if the
// model is unset.
func (t treeView) Model(t TreeView) {
	var arg0 *C.GtkTreeView

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	C.gtk_tree_view_get_model(arg0)
}

// NColumns queries the number of columns in the given @tree_view.
func (t treeView) NColumns(t TreeView) {
	var arg0 *C.GtkTreeView

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	C.gtk_tree_view_get_n_columns(arg0)
}

// PathAtPos finds the path at the point (@x, @y), relative to bin_window
// coordinates. That is, @x and @y are relative to an events coordinates.
// Widget-relative coordinates must be converted using
// gtk_tree_view_convert_widget_to_bin_window_coords(). It is primarily for
// things like popup menus. If @path is non-nil, then it will be filled with
// the TreePath at that point. This path should be freed with
// gtk_tree_path_free(). If @column is non-nil, then it will be filled with
// the column at that point. @cell_x and @cell_y return the coordinates
// relative to the cell background (i.e. the @background_area passed to
// gtk_cell_renderer_render()). This function is only meaningful if
// @tree_view is realized. Therefore this function will always return false
// if @tree_view is not realized or does not have a model.
//
// For converting widget coordinates (eg. the ones you get from
// GtkWidget::query-tooltip), please see
// gtk_tree_view_convert_widget_to_bin_window_coords().
func (t treeView) PathAtPos(t TreeView, x int, y int) (path **TreePath, column TreeViewColumn, cellX int, cellY int, ok bool) {
	var arg0 *C.GtkTreeView
	var arg1 C.int
	var arg2 C.int

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	arg1 = C.int(x)
	arg2 = C.int(y)

	var arg3 *C.GtkTreePath
	var path **TreePath
	var arg4 *C.GtkTreeViewColumn
	var column TreeViewColumn
	var arg5 C.int
	var cellX int
	var arg6 C.int
	var cellY int
	var cret C.gboolean
	var ok bool

	cret = C.gtk_tree_view_get_path_at_pos(arg0, arg1, arg2, &arg3, &arg4, &arg5, &arg6)

	path = WrapTreePath(unsafe.Pointer(&arg3))
	runtime.SetFinalizer(path, func(v **TreePath) {
		C.free(unsafe.Pointer(v.Native()))
	})
	column = gextras.CastObject(externglib.Take(unsafe.Pointer(&arg4.Native()))).(TreeViewColumn)
	cellX = int(&arg5)
	cellY = int(&arg6)
	if cret {
		ok = true
	}

	return path, column, cellX, cellY, ok
}

// Reorderable retrieves whether the user can reorder the tree via
// drag-and-drop. See gtk_tree_view_set_reorderable().
func (t treeView) Reorderable(t TreeView) bool {
	var arg0 *C.GtkTreeView

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_tree_view_get_reorderable(arg0)

	if cret {
		ok = true
	}

	return ok
}

// RowSeparatorFunc returns the current row separator function.
func (t treeView) RowSeparatorFunc(t TreeView) {
	var arg0 *C.GtkTreeView

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	C.gtk_tree_view_get_row_separator_func(arg0)
}

// RubberBanding returns whether rubber banding is turned on for @tree_view.
// If the selection mode is K_SELECTION_MULTIPLE, rubber banding will allow
// the user to select multiple rows by dragging the mouse.
func (t treeView) RubberBanding(t TreeView) bool {
	var arg0 *C.GtkTreeView

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_tree_view_get_rubber_banding(arg0)

	if cret {
		ok = true
	}

	return ok
}

// SearchColumn gets the column searched on by the interactive search code.
func (t treeView) SearchColumn(t TreeView) {
	var arg0 *C.GtkTreeView

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	C.gtk_tree_view_get_search_column(arg0)
}

// SearchEntry returns the Entry which is currently in use as interactive
// search entry for @tree_view. In case the built-in entry is being used,
// nil will be returned.
func (t treeView) SearchEntry(t TreeView) {
	var arg0 *C.GtkTreeView

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	C.gtk_tree_view_get_search_entry(arg0)
}

// SearchEqualFunc returns the compare function currently in use.
func (t treeView) SearchEqualFunc(t TreeView) {
	var arg0 *C.GtkTreeView

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	C.gtk_tree_view_get_search_equal_func(arg0)
}

// Selection gets the TreeSelection associated with @tree_view.
func (t treeView) Selection(t TreeView) {
	var arg0 *C.GtkTreeView

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	C.gtk_tree_view_get_selection(arg0)
}

// ShowExpanders returns whether or not expanders are drawn in @tree_view.
func (t treeView) ShowExpanders(t TreeView) bool {
	var arg0 *C.GtkTreeView

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_tree_view_get_show_expanders(arg0)

	if cret {
		ok = true
	}

	return ok
}

// TooltipColumn returns the column of @tree_view’s model which is being
// used for displaying tooltips on @tree_view’s rows.
func (t treeView) TooltipColumn(t TreeView) {
	var arg0 *C.GtkTreeView

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	C.gtk_tree_view_get_tooltip_column(arg0)
}

// TooltipContext: this function is supposed to be used in a
// Widget::query-tooltip signal handler for TreeView. The @x, @y and
// @keyboard_tip values which are received in the signal handler, should be
// passed to this function without modification.
//
// The return value indicates whether there is a tree view row at the given
// coordinates (true) or not (false) for mouse tooltips. For keyboard
// tooltips the row returned will be the cursor row. When true, then any of
// @model, @path and @iter which have been provided will be set to point to
// that row and the corresponding model. @x and @y will always be converted
// to be relative to @tree_view’s bin_window if @keyboard_tooltip is false.
func (t treeView) TooltipContext(t TreeView, x int, y int, keyboardTip bool) (model *TreeModel, path **TreePath, iter *TreeIter, ok bool) {
	var arg0 *C.GtkTreeView
	var arg1 C.int
	var arg2 C.int
	var arg3 C.gboolean

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	arg1 = C.int(x)
	arg2 = C.int(y)
	if keyboardTip {
		arg3 = C.gboolean(1)
	}

	var arg4 *C.GtkTreeModel
	var model *TreeModel
	var arg5 *C.GtkTreePath
	var path **TreePath
	var arg6 C.GtkTreeIter
	var iter *TreeIter
	var cret C.gboolean
	var ok bool

	cret = C.gtk_tree_view_get_tooltip_context(arg0, arg1, arg2, arg3, &arg4, &arg5, &arg6)

	model = gextras.CastObject(externglib.Take(unsafe.Pointer(&arg4.Native()))).(*TreeModel)
	path = WrapTreePath(unsafe.Pointer(&arg5))
	runtime.SetFinalizer(path, func(v **TreePath) {
		C.free(unsafe.Pointer(v.Native()))
	})
	iter = WrapTreeIter(unsafe.Pointer(&arg6))
	if cret {
		ok = true
	}

	return model, path, iter, ok
}

// VisibleRange sets @start_path and @end_path to be the first and last
// visible path. Note that there may be invisible paths in between.
//
// The paths should be freed with gtk_tree_path_free() after use.
func (t treeView) VisibleRange(t TreeView) (startPath **TreePath, endPath **TreePath, ok bool) {
	var arg0 *C.GtkTreeView

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	var arg1 *C.GtkTreePath
	var startPath **TreePath
	var arg2 *C.GtkTreePath
	var endPath **TreePath
	var cret C.gboolean
	var ok bool

	cret = C.gtk_tree_view_get_visible_range(arg0, &arg1, &arg2)

	startPath = WrapTreePath(unsafe.Pointer(&arg1))
	runtime.SetFinalizer(startPath, func(v **TreePath) {
		C.free(unsafe.Pointer(v.Native()))
	})
	endPath = WrapTreePath(unsafe.Pointer(&arg2))
	runtime.SetFinalizer(endPath, func(v **TreePath) {
		C.free(unsafe.Pointer(v.Native()))
	})
	if cret {
		ok = true
	}

	return startPath, endPath, ok
}

// VisibleRect fills @visible_rect with the currently-visible region of the
// buffer, in tree coordinates. Convert to bin_window coordinates with
// gtk_tree_view_convert_tree_to_bin_window_coords(). Tree coordinates start
// at 0,0 for row 0 of the tree, and cover the entire scrollable area of the
// tree.
func (t treeView) VisibleRect(t TreeView) *gdk.Rectangle {
	var arg0 *C.GtkTreeView

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	var arg1 C.GdkRectangle
	var visibleRect *gdk.Rectangle

	C.gtk_tree_view_get_visible_rect(arg0, &arg1)

	visibleRect = gdk.WrapRectangle(unsafe.Pointer(&arg1))

	return visibleRect
}

// InsertColumn: this inserts the @column into the @tree_view at @position.
// If @position is -1, then the column is inserted at the end. If @tree_view
// has “fixed_height” mode enabled, then @column must have its “sizing”
// property set to be GTK_TREE_VIEW_COLUMN_FIXED.
func (t treeView) InsertColumn(t TreeView, column TreeViewColumn, position int) {
	var arg0 *C.GtkTreeView
	var arg1 *C.GtkTreeViewColumn
	var arg2 C.int

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	arg1 = (*C.GtkTreeViewColumn)(unsafe.Pointer(column.Native()))
	arg2 = C.int(position)

	C.gtk_tree_view_insert_column(arg0, arg1, arg2)
}

// InsertColumnWithDataFunc: convenience function that inserts a new column
// into the TreeView with the given cell renderer and a TreeCellDataFunc to
// set cell renderer attributes (normally using data from the model). See
// also gtk_tree_view_column_set_cell_data_func(),
// gtk_tree_view_column_pack_start(). If @tree_view has “fixed_height” mode
// enabled, then the new column will have its “sizing” property set to be
// GTK_TREE_VIEW_COLUMN_FIXED.
func (t treeView) InsertColumnWithDataFunc(t TreeView) {
	var arg0 *C.GtkTreeView

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	C.gtk_tree_view_insert_column_with_data_func(arg0, arg1, arg2, arg3, arg4, arg5, arg6)
}

// IsBlankAtPos: determine whether the point (@x, @y) in @tree_view is
// blank, that is no cell content nor an expander arrow is drawn at the
// location. If so, the location can be considered as the background. You
// might wish to take special action on clicks on the background, such as
// clearing a current selection, having a custom context menu or starting
// rubber banding.
//
// The @x and @y coordinate that are provided must be relative to bin_window
// coordinates. Widget-relative coordinates must be converted using
// gtk_tree_view_convert_widget_to_bin_window_coords().
//
// For converting widget coordinates (eg. the ones you get from
// GtkWidget::query-tooltip), please see
// gtk_tree_view_convert_widget_to_bin_window_coords().
//
// The @path, @column, @cell_x and @cell_y arguments will be filled in
// likewise as for gtk_tree_view_get_path_at_pos(). Please see
// gtk_tree_view_get_path_at_pos() for more information.
func (t treeView) IsBlankAtPos(t TreeView, x int, y int) (path **TreePath, column TreeViewColumn, cellX int, cellY int, ok bool) {
	var arg0 *C.GtkTreeView
	var arg1 C.int
	var arg2 C.int

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	arg1 = C.int(x)
	arg2 = C.int(y)

	var arg3 *C.GtkTreePath
	var path **TreePath
	var arg4 *C.GtkTreeViewColumn
	var column TreeViewColumn
	var arg5 C.int
	var cellX int
	var arg6 C.int
	var cellY int
	var cret C.gboolean
	var ok bool

	cret = C.gtk_tree_view_is_blank_at_pos(arg0, arg1, arg2, &arg3, &arg4, &arg5, &arg6)

	path = WrapTreePath(unsafe.Pointer(&arg3))
	runtime.SetFinalizer(path, func(v **TreePath) {
		C.free(unsafe.Pointer(v.Native()))
	})
	column = gextras.CastObject(externglib.Take(unsafe.Pointer(&arg4.Native()))).(TreeViewColumn)
	cellX = int(&arg5)
	cellY = int(&arg6)
	if cret {
		ok = true
	}

	return path, column, cellX, cellY, ok
}

// IsRubberBandingActive returns whether a rubber banding operation is
// currently being done in @tree_view.
func (t treeView) IsRubberBandingActive(t TreeView) bool {
	var arg0 *C.GtkTreeView

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_tree_view_is_rubber_banding_active(arg0)

	if cret {
		ok = true
	}

	return ok
}

// MapExpandedRows calls @func on all expanded rows.
func (t treeView) MapExpandedRows(t TreeView) {
	var arg0 *C.GtkTreeView

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	C.gtk_tree_view_map_expanded_rows(arg0, arg1, arg2)
}

// MoveColumnAfter moves @column to be after to @base_column. If
// @base_column is nil, then @column is placed in the first position.
func (t treeView) MoveColumnAfter(t TreeView, column TreeViewColumn, baseColumn TreeViewColumn) {
	var arg0 *C.GtkTreeView
	var arg1 *C.GtkTreeViewColumn
	var arg2 *C.GtkTreeViewColumn

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	arg1 = (*C.GtkTreeViewColumn)(unsafe.Pointer(column.Native()))
	arg2 = (*C.GtkTreeViewColumn)(unsafe.Pointer(baseColumn.Native()))

	C.gtk_tree_view_move_column_after(arg0, arg1, arg2)
}

// RemoveColumn removes @column from @tree_view.
func (t treeView) RemoveColumn(t TreeView, column TreeViewColumn) {
	var arg0 *C.GtkTreeView
	var arg1 *C.GtkTreeViewColumn

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	arg1 = (*C.GtkTreeViewColumn)(unsafe.Pointer(column.Native()))

	C.gtk_tree_view_remove_column(arg0, arg1)
}

// RowActivated activates the cell determined by @path and @column.
func (t treeView) RowActivated(t TreeView, path *TreePath, column TreeViewColumn) {
	var arg0 *C.GtkTreeView
	var arg1 *C.GtkTreePath
	var arg2 *C.GtkTreeViewColumn

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
	arg2 = (*C.GtkTreeViewColumn)(unsafe.Pointer(column.Native()))

	C.gtk_tree_view_row_activated(arg0, arg1, arg2)
}

// RowExpanded returns true if the node pointed to by @path is expanded in
// @tree_view.
func (t treeView) RowExpanded(t TreeView, path *TreePath) bool {
	var arg0 *C.GtkTreeView
	var arg1 *C.GtkTreePath

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_tree_view_row_expanded(arg0, arg1)

	if cret {
		ok = true
	}

	return ok
}

// ScrollToCell moves the alignments of @tree_view to the position specified
// by @column and @path. If @column is nil, then no horizontal scrolling
// occurs. Likewise, if @path is nil no vertical scrolling occurs. At a
// minimum, one of @column or @path need to be non-nil. @row_align
// determines where the row is placed, and @col_align determines where
// @column is placed. Both are expected to be between 0.0 and 1.0. 0.0 means
// left/top alignment, 1.0 means right/bottom alignment, 0.5 means center.
//
// If @use_align is false, then the alignment arguments are ignored, and the
// tree does the minimum amount of work to scroll the cell onto the screen.
// This means that the cell will be scrolled to the edge closest to its
// current position. If the cell is currently visible on the screen, nothing
// is done.
//
// This function only works if the model is set, and @path is a valid row on
// the model. If the model changes before the @tree_view is realized, the
// centered path will be modified to reflect this change.
func (t treeView) ScrollToCell(t TreeView, path *TreePath, column TreeViewColumn, useAlign bool, rowAlign float32, colAlign float32) {
	var arg0 *C.GtkTreeView
	var arg1 *C.GtkTreePath
	var arg2 *C.GtkTreeViewColumn
	var arg3 C.gboolean
	var arg4 C.float
	var arg5 C.float

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
	arg2 = (*C.GtkTreeViewColumn)(unsafe.Pointer(column.Native()))
	if useAlign {
		arg3 = C.gboolean(1)
	}
	arg4 = C.float(rowAlign)
	arg5 = C.float(colAlign)

	C.gtk_tree_view_scroll_to_cell(arg0, arg1, arg2, arg3, arg4, arg5)
}

// ScrollToPoint scrolls the tree view such that the top-left corner of the
// visible area is @tree_x, @tree_y, where @tree_x and @tree_y are specified
// in tree coordinates. The @tree_view must be realized before this function
// is called. If it isn't, you probably want to be using
// gtk_tree_view_scroll_to_cell().
//
// If either @tree_x or @tree_y are -1, then that direction isn’t scrolled.
func (t treeView) ScrollToPoint(t TreeView, treeX int, treeY int) {
	var arg0 *C.GtkTreeView
	var arg1 C.int
	var arg2 C.int

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	arg1 = C.int(treeX)
	arg2 = C.int(treeY)

	C.gtk_tree_view_scroll_to_point(arg0, arg1, arg2)
}

// SetActivateOnSingleClick: cause the TreeView::row-activated signal to be
// emitted on a single click instead of a double click.
func (t treeView) SetActivateOnSingleClick(t TreeView, single bool) {
	var arg0 *C.GtkTreeView
	var arg1 C.gboolean

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	if single {
		arg1 = C.gboolean(1)
	}

	C.gtk_tree_view_set_activate_on_single_click(arg0, arg1)
}

// SetColumnDragFunction sets a user function for determining where a column
// may be dropped when dragged. This function is called on every column pair
// in turn at the beginning of a column drag to determine where a drop can
// take place. The arguments passed to @func are: the @tree_view, the
// TreeViewColumn being dragged, the two TreeViewColumn s determining the
// drop spot, and @user_data. If either of the TreeViewColumn arguments for
// the drop spot are nil, then they indicate an edge. If @func is set to be
// nil, then @tree_view reverts to the default behavior of allowing all
// columns to be dropped everywhere.
func (t treeView) SetColumnDragFunction(t TreeView) {
	var arg0 *C.GtkTreeView

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	C.gtk_tree_view_set_column_drag_function(arg0, arg1, arg2, arg3)
}

// SetCursor sets the current keyboard focus to be at @path, and selects it.
// This is useful when you want to focus the user’s attention on a
// particular row. If @focus_column is not nil, then focus is given to the
// column specified by it. Additionally, if @focus_column is specified, and
// @start_editing is true, then editing should be started in the specified
// cell. This function is often followed by @gtk_widget_grab_focus
// (@tree_view) in order to give keyboard focus to the widget. Please note
// that editing can only happen when the widget is realized.
//
// If @path is invalid for @model, the current cursor (if any) will be unset
// and the function will return without failing.
func (t treeView) SetCursor(t TreeView, path *TreePath, focusColumn TreeViewColumn, startEditing bool) {
	var arg0 *C.GtkTreeView
	var arg1 *C.GtkTreePath
	var arg2 *C.GtkTreeViewColumn
	var arg3 C.gboolean

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
	arg2 = (*C.GtkTreeViewColumn)(unsafe.Pointer(focusColumn.Native()))
	if startEditing {
		arg3 = C.gboolean(1)
	}

	C.gtk_tree_view_set_cursor(arg0, arg1, arg2, arg3)
}

// SetCursorOnCell sets the current keyboard focus to be at @path, and
// selects it. This is useful when you want to focus the user’s attention on
// a particular row. If @focus_column is not nil, then focus is given to the
// column specified by it. If @focus_column and @focus_cell are not nil, and
// @focus_column contains 2 or more editable or activatable cells, then
// focus is given to the cell specified by @focus_cell. Additionally, if
// @focus_column is specified, and @start_editing is true, then editing
// should be started in the specified cell. This function is often followed
// by @gtk_widget_grab_focus (@tree_view) in order to give keyboard focus to
// the widget. Please note that editing can only happen when the widget is
// realized.
//
// If @path is invalid for @model, the current cursor (if any) will be unset
// and the function will return without failing.
func (t treeView) SetCursorOnCell(t TreeView, path *TreePath, focusColumn TreeViewColumn, focusCell CellRenderer, startEditing bool) {
	var arg0 *C.GtkTreeView
	var arg1 *C.GtkTreePath
	var arg2 *C.GtkTreeViewColumn
	var arg3 *C.GtkCellRenderer
	var arg4 C.gboolean

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
	arg2 = (*C.GtkTreeViewColumn)(unsafe.Pointer(focusColumn.Native()))
	arg3 = (*C.GtkCellRenderer)(unsafe.Pointer(focusCell.Native()))
	if startEditing {
		arg4 = C.gboolean(1)
	}

	C.gtk_tree_view_set_cursor_on_cell(arg0, arg1, arg2, arg3, arg4)
}

// SetDragDestRow sets the row that is highlighted for feedback. If @path is
// nil, an existing highlight is removed.
func (t treeView) SetDragDestRow(t TreeView, path *TreePath, pos TreeViewDropPosition) {
	var arg0 *C.GtkTreeView
	var arg1 *C.GtkTreePath
	var arg2 C.GtkTreeViewDropPosition

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
	arg2 = (C.GtkTreeViewDropPosition)(pos)

	C.gtk_tree_view_set_drag_dest_row(arg0, arg1, arg2)
}

// SetEnableSearch: if @enable_search is set, then the user can type in text
// to search through the tree interactively (this is sometimes called
// "typeahead find").
//
// Note that even if this is false, the user can still initiate a search
// using the “start-interactive-search” key binding.
func (t treeView) SetEnableSearch(t TreeView, enableSearch bool) {
	var arg0 *C.GtkTreeView
	var arg1 C.gboolean

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	if enableSearch {
		arg1 = C.gboolean(1)
	}

	C.gtk_tree_view_set_enable_search(arg0, arg1)
}

// SetEnableTreeLines sets whether to draw lines interconnecting the
// expanders in @tree_view. This does not have any visible effects for
// lists.
func (t treeView) SetEnableTreeLines(t TreeView, enabled bool) {
	var arg0 *C.GtkTreeView
	var arg1 C.gboolean

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	if enabled {
		arg1 = C.gboolean(1)
	}

	C.gtk_tree_view_set_enable_tree_lines(arg0, arg1)
}

// SetExpanderColumn sets the column to draw the expander arrow at. It must
// be in @tree_view. If @column is nil, then the expander arrow is always at
// the first visible column.
//
// If you do not want expander arrow to appear in your tree, set the
// expander column to a hidden column.
func (t treeView) SetExpanderColumn(t TreeView, column TreeViewColumn) {
	var arg0 *C.GtkTreeView
	var arg1 *C.GtkTreeViewColumn

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	arg1 = (*C.GtkTreeViewColumn)(unsafe.Pointer(column.Native()))

	C.gtk_tree_view_set_expander_column(arg0, arg1)
}

// SetFixedHeightMode enables or disables the fixed height mode of
// @tree_view. Fixed height mode speeds up TreeView by assuming that all
// rows have the same height. Only enable this option if all rows are the
// same height and all columns are of type GTK_TREE_VIEW_COLUMN_FIXED.
func (t treeView) SetFixedHeightMode(t TreeView, enable bool) {
	var arg0 *C.GtkTreeView
	var arg1 C.gboolean

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	if enable {
		arg1 = C.gboolean(1)
	}

	C.gtk_tree_view_set_fixed_height_mode(arg0, arg1)
}

// SetGridLines sets which grid lines to draw in @tree_view.
func (t treeView) SetGridLines(t TreeView, gridLines TreeViewGridLines) {
	var arg0 *C.GtkTreeView
	var arg1 C.GtkTreeViewGridLines

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	arg1 = (C.GtkTreeViewGridLines)(gridLines)

	C.gtk_tree_view_set_grid_lines(arg0, arg1)
}

// SetHeadersClickable: allow the column title buttons to be clicked.
func (t treeView) SetHeadersClickable(t TreeView, setting bool) {
	var arg0 *C.GtkTreeView
	var arg1 C.gboolean

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	if setting {
		arg1 = C.gboolean(1)
	}

	C.gtk_tree_view_set_headers_clickable(arg0, arg1)
}

// SetHeadersVisible sets the visibility state of the headers.
func (t treeView) SetHeadersVisible(t TreeView, headersVisible bool) {
	var arg0 *C.GtkTreeView
	var arg1 C.gboolean

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	if headersVisible {
		arg1 = C.gboolean(1)
	}

	C.gtk_tree_view_set_headers_visible(arg0, arg1)
}

// SetHoverExpand enables or disables the hover expansion mode of
// @tree_view. Hover expansion makes rows expand or collapse if the pointer
// moves over them.
func (t treeView) SetHoverExpand(t TreeView, expand bool) {
	var arg0 *C.GtkTreeView
	var arg1 C.gboolean

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	if expand {
		arg1 = C.gboolean(1)
	}

	C.gtk_tree_view_set_hover_expand(arg0, arg1)
}

// SetHoverSelection enables or disables the hover selection mode of
// @tree_view. Hover selection makes the selected row follow the pointer.
// Currently, this works only for the selection modes GTK_SELECTION_SINGLE
// and GTK_SELECTION_BROWSE.
func (t treeView) SetHoverSelection(t TreeView, hover bool) {
	var arg0 *C.GtkTreeView
	var arg1 C.gboolean

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	if hover {
		arg1 = C.gboolean(1)
	}

	C.gtk_tree_view_set_hover_selection(arg0, arg1)
}

// SetLevelIndentation sets the amount of extra indentation for child levels
// to use in @tree_view in addition to the default indentation. The value
// should be specified in pixels, a value of 0 disables this feature and in
// this case only the default indentation will be used. This does not have
// any visible effects for lists.
func (t treeView) SetLevelIndentation(t TreeView, indentation int) {
	var arg0 *C.GtkTreeView
	var arg1 C.int

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	arg1 = C.int(indentation)

	C.gtk_tree_view_set_level_indentation(arg0, arg1)
}

// SetModel sets the model for a TreeView. If the @tree_view already has a
// model set, it will remove it before setting the new model. If @model is
// nil, then it will unset the old model.
func (t treeView) SetModel(t TreeView, model TreeModel) {
	var arg0 *C.GtkTreeView
	var arg1 *C.GtkTreeModel

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	arg1 = (*C.GtkTreeModel)(unsafe.Pointer(model.Native()))

	C.gtk_tree_view_set_model(arg0, arg1)
}

// SetReorderable: this function is a convenience function to allow you to
// reorder models that support the TreeDragSourceIface and the
// TreeDragDestIface. Both TreeStore and ListStore support these. If
// @reorderable is true, then the user can reorder the model by dragging and
// dropping rows. The developer can listen to these changes by connecting to
// the model’s TreeModel::row-inserted and TreeModel::row-deleted signals.
// The reordering is implemented by setting up the tree view as a drag
// source and destination. Therefore, drag and drop can not be used in a
// reorderable view for any other purpose.
//
// This function does not give you any degree of control over the order --
// any reordering is allowed. If more control is needed, you should probably
// handle drag and drop manually.
func (t treeView) SetReorderable(t TreeView, reorderable bool) {
	var arg0 *C.GtkTreeView
	var arg1 C.gboolean

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	if reorderable {
		arg1 = C.gboolean(1)
	}

	C.gtk_tree_view_set_reorderable(arg0, arg1)
}

// SetRowSeparatorFunc sets the row separator function, which is used to
// determine whether a row should be drawn as a separator. If the row
// separator function is nil, no separators are drawn. This is the default
// value.
func (t treeView) SetRowSeparatorFunc(t TreeView) {
	var arg0 *C.GtkTreeView

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	C.gtk_tree_view_set_row_separator_func(arg0, arg1, arg2, arg3)
}

// SetRubberBanding enables or disables rubber banding in @tree_view. If the
// selection mode is K_SELECTION_MULTIPLE, rubber banding will allow the
// user to select multiple rows by dragging the mouse.
func (t treeView) SetRubberBanding(t TreeView, enable bool) {
	var arg0 *C.GtkTreeView
	var arg1 C.gboolean

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	if enable {
		arg1 = C.gboolean(1)
	}

	C.gtk_tree_view_set_rubber_banding(arg0, arg1)
}

// SetSearchColumn sets @column as the column where the interactive search
// code should search in for the current model.
//
// If the search column is set, users can use the “start-interactive-search”
// key binding to bring up search popup. The enable-search property controls
// whether simply typing text will also start an interactive search.
//
// Note that @column refers to a column of the current model. The search
// column is reset to -1 when the model is changed.
func (t treeView) SetSearchColumn(t TreeView, column int) {
	var arg0 *C.GtkTreeView
	var arg1 C.int

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	arg1 = C.int(column)

	C.gtk_tree_view_set_search_column(arg0, arg1)
}

// SetSearchEntry sets the entry which the interactive search code will use
// for this @tree_view. This is useful when you want to provide a search
// entry in our interface at all time at a fixed position. Passing nil for
// @entry will make the interactive search code use the built-in popup entry
// again.
func (t treeView) SetSearchEntry(t TreeView, entry Editable) {
	var arg0 *C.GtkTreeView
	var arg1 *C.GtkEditable

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	arg1 = (*C.GtkEditable)(unsafe.Pointer(entry.Native()))

	C.gtk_tree_view_set_search_entry(arg0, arg1)
}

// SetSearchEqualFunc sets the compare function for the interactive search
// capabilities; note that somewhat like strcmp() returning 0 for equality
// TreeViewSearchEqualFunc returns false on matches.
func (t treeView) SetSearchEqualFunc(t TreeView) {
	var arg0 *C.GtkTreeView

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	C.gtk_tree_view_set_search_equal_func(arg0, arg1, arg2, arg3)
}

// SetShowExpanders sets whether to draw and enable expanders and indent
// child rows in @tree_view. When disabled there will be no expanders
// visible in trees and there will be no way to expand and collapse rows by
// default. Also note that hiding the expanders will disable the default
// indentation. You can set a custom indentation in this case using
// gtk_tree_view_set_level_indentation(). This does not have any visible
// effects for lists.
func (t treeView) SetShowExpanders(t TreeView, enabled bool) {
	var arg0 *C.GtkTreeView
	var arg1 C.gboolean

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	if enabled {
		arg1 = C.gboolean(1)
	}

	C.gtk_tree_view_set_show_expanders(arg0, arg1)
}

// SetTooltipCell sets the tip area of @tooltip to the area @path, @column
// and @cell have in common. For example if @path is nil and @column is set,
// the tip area will be set to the full area covered by @column. See also
// gtk_tooltip_set_tip_area().
//
// Note that if @path is not specified and @cell is set and part of a column
// containing the expander, the tooltip might not show and hide at the
// correct position. In such cases @path must be set to the current node
// under the mouse cursor for this function to operate correctly.
//
// See also gtk_tree_view_set_tooltip_column() for a simpler alternative.
func (t treeView) SetTooltipCell(t TreeView, tooltip Tooltip, path *TreePath, column TreeViewColumn, cell CellRenderer) {
	var arg0 *C.GtkTreeView
	var arg1 *C.GtkTooltip
	var arg2 *C.GtkTreePath
	var arg3 *C.GtkTreeViewColumn
	var arg4 *C.GtkCellRenderer

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	arg1 = (*C.GtkTooltip)(unsafe.Pointer(tooltip.Native()))
	arg2 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
	arg3 = (*C.GtkTreeViewColumn)(unsafe.Pointer(column.Native()))
	arg4 = (*C.GtkCellRenderer)(unsafe.Pointer(cell.Native()))

	C.gtk_tree_view_set_tooltip_cell(arg0, arg1, arg2, arg3, arg4)
}

// SetTooltipColumn: if you only plan to have simple (text-only) tooltips on
// full rows, you can use this function to have TreeView handle these
// automatically for you. @column should be set to the column in
// @tree_view’s model containing the tooltip texts, or -1 to disable this
// feature.
//
// When enabled, Widget:has-tooltip will be set to true and @tree_view will
// connect a Widget::query-tooltip signal handler.
//
// Note that the signal handler sets the text with gtk_tooltip_set_markup(),
// so &, <, etc have to be escaped in the text.
func (t treeView) SetTooltipColumn(t TreeView, column int) {
	var arg0 *C.GtkTreeView
	var arg1 C.int

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	arg1 = C.int(column)

	C.gtk_tree_view_set_tooltip_column(arg0, arg1)
}

// SetTooltipRow sets the tip area of @tooltip to be the area covered by the
// row at @path. See also gtk_tree_view_set_tooltip_column() for a simpler
// alternative. See also gtk_tooltip_set_tip_area().
func (t treeView) SetTooltipRow(t TreeView, tooltip Tooltip, path *TreePath) {
	var arg0 *C.GtkTreeView
	var arg1 *C.GtkTooltip
	var arg2 *C.GtkTreePath

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
	arg1 = (*C.GtkTooltip)(unsafe.Pointer(tooltip.Native()))
	arg2 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

	C.gtk_tree_view_set_tooltip_row(arg0, arg1, arg2)
}

// UnsetRowsDragDest undoes the effect of
// gtk_tree_view_enable_model_drag_dest(). Calling this method sets
// TreeView:reorderable to false.
func (t treeView) UnsetRowsDragDest(t TreeView) {
	var arg0 *C.GtkTreeView

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	C.gtk_tree_view_unset_rows_drag_dest(arg0)
}

// UnsetRowsDragSource undoes the effect of
// gtk_tree_view_enable_model_drag_source(). Calling this method sets
// TreeView:reorderable to false.
func (t treeView) UnsetRowsDragSource(t TreeView) {
	var arg0 *C.GtkTreeView

	arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

	C.gtk_tree_view_unset_rows_drag_source(arg0)
}
