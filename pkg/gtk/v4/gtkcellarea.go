// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"unsafe"

	"github.com/diamondburned/gotk4/internal/box"
	"github.com/diamondburned/gotk4/internal/gextras"
	"github.com/diamondburned/gotk4/pkg/gdk/v4"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config:
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <stdbool.h>
// #include <glib-object.h>
// #include <gtk/gtk.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_cell_area_get_type()), F: marshalCellArea},
	})
}

// CellAllocCallback: the type of the callback functions used for iterating over
// the cell renderers and their allocated areas inside a CellArea, see
// gtk_cell_area_foreach_alloc().
type CellAllocCallback func(renderer CellRenderer, cellArea *gdk.Rectangle, cellBackground *gdk.Rectangle) bool

//export gotk4_CellAllocCallback
func gotk4_CellAllocCallback(arg0 *C.GtkCellRenderer, arg1 *C.GdkRectangle, arg2 *C.GdkRectangle, arg3 C.gpointer) C.gboolean {
	v := box.Get(uintptr(arg3))
	if v == nil {
		panic(`callback not found`)
	}

	fn := v.(CellAllocCallback)
	ret := fn(renderer, cellArea, cellBackground, data)

	if ret {
		cret = C.gboolean(1)
	}

	return cret
}

// CellCallback: the type of the callback functions used for iterating over the
// cell renderers of a CellArea, see gtk_cell_area_foreach().
type CellCallback func(renderer CellRenderer) bool

//export gotk4_CellCallback
func gotk4_CellCallback(arg0 *C.GtkCellRenderer, arg1 C.gpointer) C.gboolean {
	v := box.Get(uintptr(arg1))
	if v == nil {
		panic(`callback not found`)
	}

	fn := v.(CellCallback)
	ret := fn(renderer, data)

	if ret {
		cret = C.gboolean(1)
	}

	return cret
}

// CellArea: the CellArea is an abstract class for CellLayout widgets (also
// referred to as "layouting widgets") to interface with an arbitrary number of
// CellRenderers and interact with the user for a given TreeModel row.
//
// The cell area handles events, focus navigation, drawing and size requests and
// allocations for a given row of data.
//
// Usually users dont have to interact with the CellArea directly unless they
// are implementing a cell-layouting widget themselves.
//
//
// Requesting area sizes
//
// As outlined in [GtkWidget’s geometry management
// section][geometry-management], GTK uses a height-for-width geometry
// management system to compute the sizes of widgets and user interfaces.
// CellArea uses the same semantics to calculate the size of an area for an
// arbitrary number of TreeModel rows.
//
// When requesting the size of a cell area one needs to calculate the size for a
// handful of rows, and this will be done differently by different layouting
// widgets. For instance a TreeViewColumn always lines up the areas from top to
// bottom while a IconView on the other hand might enforce that all areas
// received the same width and wrap the areas around, requesting height for more
// cell areas when allocated less width.
//
// It’s also important for areas to maintain some cell alignments with areas
// rendered for adjacent rows (cells can appear “columnized” inside an area even
// when the size of cells are different in each row). For this reason the
// CellArea uses a CellAreaContext object to store the alignments and sizes
// along the way (as well as the overall largest minimum and natural size for
// all the rows which have been calculated with the said context).
//
// The CellAreaContext is an opaque object specific to the CellArea which
// created it (see gtk_cell_area_create_context()). The owning cell-layouting
// widget can create as many contexts as it wishes to calculate sizes of rows
// which should receive the same size in at least one orientation (horizontally
// or vertically), However, it’s important that the same CellAreaContext which
// was used to request the sizes for a given TreeModel row be used when
// rendering or processing events for that row.
//
// In order to request the width of all the rows at the root level of a
// TreeModel one would do the following:
//
//    static gboolean
//    foo_focus (GtkWidget       *widget,
//               GtkDirectionType direction)
//    {
//      Foo        *foo  = FOO (widget);
//      FooPrivate *priv = foo->priv;
//      int         focus_row;
//      gboolean    have_focus = FALSE;
//
//      focus_row = priv->focus_row;
//
//      if (!gtk_widget_has_focus (widget))
//        gtk_widget_grab_focus (widget);
//
//      valid = gtk_tree_model_iter_nth_child (priv->model, &iter, NULL, priv->focus_row);
//      while (valid)
//        {
//          gtk_cell_area_apply_attributes (priv->area, priv->model, &iter, FALSE, FALSE);
//
//          if (gtk_cell_area_focus (priv->area, direction))
//            {
//               priv->focus_row = focus_row;
//               have_focus = TRUE;
//               break;
//            }
//          else
//            {
//              if (direction == GTK_DIR_RIGHT ||
//                  direction == GTK_DIR_LEFT)
//                break;
//              else if (direction == GTK_DIR_UP ||
//                       direction == GTK_DIR_TAB_BACKWARD)
//               {
//                  if (focus_row == 0)
//                    break;
//                  else
//                   {
//                      focus_row--;
//                      valid = gtk_tree_model_iter_nth_child (priv->model, &iter, NULL, focus_row);
//                   }
//                }
//              else
//                {
//                  if (focus_row == last_row)
//                    break;
//                  else
//                    {
//                      focus_row++;
//                      valid = gtk_tree_model_iter_next (priv->model, &iter);
//                    }
//                }
//            }
//        }
//        return have_focus;
//    }
//
// Note that the layouting widget is responsible for matching the
// GtkDirectionType values to the way it lays out its cells.
//
//
// Cell Properties
//
// The CellArea introduces cell properties for CellRenderers. This provides some
// general interfaces for defining the relationship cell areas have with their
// cells. For instance in a CellAreaBox a cell might “expand” and receive extra
// space when the area is allocated more than its full natural request, or a
// cell might be configured to “align” with adjacent rows which were requested
// and rendered with the same CellAreaContext.
//
// Use gtk_cell_area_class_install_cell_property() to install cell properties
// for a cell area class and gtk_cell_area_class_find_cell_property() or
// gtk_cell_area_class_list_cell_properties() to get information about existing
// cell properties.
//
// To set the value of a cell property, use gtk_cell_area_cell_set_property(),
// gtk_cell_area_cell_set() or gtk_cell_area_cell_set_valist(). To obtain the
// value of a cell property, use gtk_cell_area_cell_get_property(),
// gtk_cell_area_cell_get() or gtk_cell_area_cell_get_valist().
type CellArea interface {
	gextras.Objector
	Buildable
	CellLayout

	// Activate activates @area, usually by activating the currently focused
	// cell, however some subclasses which embed widgets in the area can also
	// activate a widget if it currently has the focus.
	Activate(context CellAreaContext, widget Widget, cellArea *gdk.Rectangle, flags CellRendererState, editOnly bool) bool
	// ActivateCell: this is used by CellArea subclasses when handling events to
	// activate cells, the base CellArea class activates cells for keyboard
	// events for free in its own GtkCellArea->activate() implementation.
	ActivateCell(widget Widget, renderer CellRenderer, event gdk.Event, cellArea *gdk.Rectangle, flags CellRendererState) bool
	// Add adds @renderer to @area with the default child cell properties.
	Add(renderer CellRenderer)
	// AddFocusSibling adds @sibling to @renderer’s focusable area, focus will
	// be drawn around @renderer and all of its siblings if @renderer can focus
	// for a given row.
	//
	// Events handled by focus siblings can also activate the given focusable
	// @renderer.
	AddFocusSibling(renderer CellRenderer, sibling CellRenderer)
	// ApplyAttributes applies any connected attributes to the renderers in
	// @area by pulling the values from @tree_model.
	ApplyAttributes(treeModel TreeModel, iter *TreeIter, isExpander bool, isExpanded bool)
	// AttributeConnect connects an @attribute to apply values from @column for
	// the TreeModel in use.
	AttributeConnect(renderer CellRenderer, attribute string, column int)
	// AttributeDisconnect disconnects @attribute for the @renderer in @area so
	// that attribute will no longer be updated with values from the model.
	AttributeDisconnect(renderer CellRenderer, attribute string)
	// AttributeGetColumn returns the model column that an attribute has been
	// mapped to, or -1 if the attribute is not mapped.
	AttributeGetColumn(renderer CellRenderer, attribute string) int
	// CellGetProperty gets the value of a cell property for @renderer in @area.
	CellGetProperty(renderer CellRenderer, propertyName string, value *externglib.Value)
	// CellSetProperty sets a cell property for @renderer in @area.
	CellSetProperty(renderer CellRenderer, propertyName string, value *externglib.Value)
	// CopyContext: this is sometimes needed for cases where rows need to share
	// alignments in one orientation but may be separately grouped in the
	// opposing orientation.
	//
	// For instance, IconView creates all icons (rows) to have the same width
	// and the cells theirin to have the same horizontal alignments. However
	// each row of icons may have a separate collective height. IconView uses
	// this to request the heights of each row based on a context which was
	// already used to request all the row widths that are to be displayed.
	CopyContext(context CellAreaContext) CellAreaContext
	// CreateContext creates a CellAreaContext to be used with @area for all
	// purposes. CellAreaContext stores geometry information for rows for which
	// it was operated on, it is important to use the same context for the same
	// row of data at all times (i.e. one should render and handle events with
	// the same CellAreaContext which was used to request the size of those rows
	// of data).
	CreateContext() CellAreaContext
	// Event delegates event handling to a CellArea.
	Event(context CellAreaContext, widget Widget, event gdk.Event, cellArea *gdk.Rectangle, flags CellRendererState) int
	// Focus: this should be called by the @area’s owning layout widget when
	// focus is to be passed to @area, or moved within @area for a given
	// @direction and row data.
	//
	// Implementing CellArea classes should implement this method to receive and
	// navigate focus in its own way particular to how it lays out cells.
	Focus(direction DirectionType) bool
	// Foreach calls @callback for every CellRenderer in @area.
	Foreach(callback CellCallback)
	// ForeachAlloc calls @callback for every CellRenderer in @area with the
	// allocated rectangle inside @cell_area.
	ForeachAlloc(context CellAreaContext, widget Widget, cellArea *gdk.Rectangle, backgroundArea *gdk.Rectangle, callback CellAllocCallback)
	// CellAllocation derives the allocation of @renderer inside @area if @area
	// were to be renderered in @cell_area.
	CellAllocation(context CellAreaContext, widget Widget, renderer CellRenderer, cellArea *gdk.Rectangle) gdk.Rectangle
	// CellAtPosition gets the CellRenderer at @x and @y coordinates inside
	// @area and optionally returns the full cell allocation for it inside
	// @cell_area.
	CellAtPosition(context CellAreaContext, widget Widget, cellArea *gdk.Rectangle, x int, y int) (allocArea gdk.Rectangle, cellRenderer CellRenderer)
	// CurrentPathString gets the current TreePath string for the currently
	// applied TreeIter, this is implicitly updated when
	// gtk_cell_area_apply_attributes() is called and can be used to interact
	// with renderers from CellArea subclasses.
	CurrentPathString() string
	// EditWidget gets the CellEditable widget currently used to edit the
	// currently edited cell.
	EditWidget() CellEditable
	// EditedCell gets the CellRenderer in @area that is currently being edited.
	EditedCell() CellRenderer
	// FocusCell retrieves the currently focused cell for @area
	FocusCell() CellRenderer
	// FocusFromSibling gets the CellRenderer which is expected to be focusable
	// for which @renderer is, or may be a sibling.
	//
	// This is handy for CellArea subclasses when handling events, after
	// determining the renderer at the event location it can then chose to
	// activate the focus cell for which the event cell may have been a sibling.
	FocusFromSibling(renderer CellRenderer) CellRenderer
	// FocusSiblings gets the focus sibling cell renderers for @renderer.
	FocusSiblings(renderer CellRenderer) *glib.List
	// PreferredHeight retrieves a cell area’s initial minimum and natural
	// height.
	//
	// @area will store some geometrical information in @context along the way;
	// when requesting sizes over an arbitrary number of rows, it’s not
	// important to check the @minimum_height and @natural_height of this call
	// but rather to consult gtk_cell_area_context_get_preferred_height() after
	// a series of requests.
	PreferredHeight(context CellAreaContext, widget Widget) (minimumHeight int, naturalHeight int)
	// PreferredHeightForWidth retrieves a cell area’s minimum and natural
	// height if it would be given the specified @width.
	//
	// @area stores some geometrical information in @context along the way while
	// calling gtk_cell_area_get_preferred_width(). It’s important to perform a
	// series of gtk_cell_area_get_preferred_width() requests with @context
	// first and then call gtk_cell_area_get_preferred_height_for_width() on
	// each cell area individually to get the height for width of each fully
	// requested row.
	//
	// If at some point, the width of a single row changes, it should be
	// requested with gtk_cell_area_get_preferred_width() again and then the
	// full width of the requested rows checked again with
	// gtk_cell_area_context_get_preferred_width().
	PreferredHeightForWidth(context CellAreaContext, widget Widget, width int) (minimumHeight int, naturalHeight int)
	// PreferredWidth retrieves a cell area’s initial minimum and natural width.
	//
	// @area will store some geometrical information in @context along the way;
	// when requesting sizes over an arbitrary number of rows, it’s not
	// important to check the @minimum_width and @natural_width of this call but
	// rather to consult gtk_cell_area_context_get_preferred_width() after a
	// series of requests.
	PreferredWidth(context CellAreaContext, widget Widget) (minimumWidth int, naturalWidth int)
	// PreferredWidthForHeight retrieves a cell area’s minimum and natural width
	// if it would be given the specified @height.
	//
	// @area stores some geometrical information in @context along the way while
	// calling gtk_cell_area_get_preferred_height(). It’s important to perform a
	// series of gtk_cell_area_get_preferred_height() requests with @context
	// first and then call gtk_cell_area_get_preferred_width_for_height() on
	// each cell area individually to get the height for width of each fully
	// requested row.
	//
	// If at some point, the height of a single row changes, it should be
	// requested with gtk_cell_area_get_preferred_height() again and then the
	// full height of the requested rows checked again with
	// gtk_cell_area_context_get_preferred_height().
	PreferredWidthForHeight(context CellAreaContext, widget Widget, height int) (minimumWidth int, naturalWidth int)
	// RequestMode gets whether the area prefers a height-for-width layout or a
	// width-for-height layout.
	RequestMode() SizeRequestMode
	// HasRenderer checks if @area contains @renderer.
	HasRenderer(renderer CellRenderer) bool
	// InnerCellArea: this is a convenience function for CellArea
	// implementations to get the inner area where a given CellRenderer will be
	// rendered. It removes any padding previously added by
	// gtk_cell_area_request_renderer().
	InnerCellArea(widget Widget, cellArea *gdk.Rectangle) gdk.Rectangle
	// IsActivatable returns whether the area can do anything when activated,
	// after applying new attributes to @area.
	IsActivatable() bool
	// IsFocusSibling returns whether @sibling is one of @renderer’s focus
	// siblings (see gtk_cell_area_add_focus_sibling()).
	IsFocusSibling(renderer CellRenderer, sibling CellRenderer) bool
	// Remove removes @renderer from @area.
	Remove(renderer CellRenderer)
	// RemoveFocusSibling removes @sibling from @renderer’s focus sibling list
	// (see gtk_cell_area_add_focus_sibling()).
	RemoveFocusSibling(renderer CellRenderer, sibling CellRenderer)
	// RequestRenderer: this is a convenience function for CellArea
	// implementations to request size for cell renderers. It’s important to use
	// this function to request size and then use
	// gtk_cell_area_inner_cell_area() at render and event time since this
	// function will add padding around the cell for focus painting.
	RequestRenderer(renderer CellRenderer, orientation Orientation, widget Widget, forSize int) (minimumSize int, naturalSize int)
	// SetFocusCell: explicitly sets the currently focused cell to @renderer.
	//
	// This is generally called by implementations of CellAreaClass.focus() or
	// CellAreaClass.event(), however it can also be used to implement functions
	// such as gtk_tree_view_set_cursor_on_cell().
	SetFocusCell(renderer CellRenderer)
	// Snapshot snapshots @area’s cells according to @area’s layout onto at the
	// given coordinates.
	Snapshot(context CellAreaContext, widget Widget, snapshot Snapshot, backgroundArea *gdk.Rectangle, cellArea *gdk.Rectangle, flags CellRendererState, paintFocus bool)
	// StopEditing: explicitly stops the editing of the currently edited cell.
	//
	// If @canceled is true, the currently edited cell renderer will emit the
	// ::editing-canceled signal, otherwise the the ::editing-done signal will
	// be emitted on the current edit widget.
	//
	// See gtk_cell_area_get_edited_cell() and gtk_cell_area_get_edit_widget().
	StopEditing(canceled bool)
}

// cellArea implements the CellArea interface.
type cellArea struct {
	gextras.Objector
	Buildable
	CellLayout
}

var _ CellArea = (*cellArea)(nil)

// WrapCellArea wraps a GObject to the right type. It is
// primarily used internally.
func WrapCellArea(obj *externglib.Object) CellArea {
	return CellArea{
		Objector:   obj,
		Buildable:  WrapBuildable(obj),
		CellLayout: WrapCellLayout(obj),
	}
}

func marshalCellArea(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCellArea(obj), nil
}

// Activate activates @area, usually by activating the currently focused
// cell, however some subclasses which embed widgets in the area can also
// activate a widget if it currently has the focus.
func (a cellArea) Activate(context CellAreaContext, widget Widget, cellArea *gdk.Rectangle, flags CellRendererState, editOnly bool) bool {
	var arg0 *C.GtkCellArea
	var arg1 *C.GtkCellAreaContext
	var arg2 *C.GtkWidget
	var arg3 *C.GdkRectangle
	var arg4 C.GtkCellRendererState
	var arg5 C.gboolean

	arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
	arg1 = (*C.GtkCellAreaContext)(unsafe.Pointer(context.Native()))
	arg2 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	arg3 = (*C.GdkRectangle)(unsafe.Pointer(cellArea.Native()))
	arg4 = (C.GtkCellRendererState)(flags)
	if editOnly {
		arg5 = C.gboolean(1)
	}

	var cret C.gboolean
	var goret1 bool

	cret = C.gtk_cell_area_activate(arg0, context, widget, cellArea, flags, editOnly)

	goret1 = C.bool(cret) != C.false

	return goret1
}

// ActivateCell: this is used by CellArea subclasses when handling events to
// activate cells, the base CellArea class activates cells for keyboard
// events for free in its own GtkCellArea->activate() implementation.
func (a cellArea) ActivateCell(widget Widget, renderer CellRenderer, event gdk.Event, cellArea *gdk.Rectangle, flags CellRendererState) bool {
	var arg0 *C.GtkCellArea
	var arg1 *C.GtkWidget
	var arg2 *C.GtkCellRenderer
	var arg3 *C.GdkEvent
	var arg4 *C.GdkRectangle
	var arg5 C.GtkCellRendererState

	arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	arg2 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))
	arg3 = (*C.GdkEvent)(unsafe.Pointer(event.Native()))
	arg4 = (*C.GdkRectangle)(unsafe.Pointer(cellArea.Native()))
	arg5 = (C.GtkCellRendererState)(flags)

	var cret C.gboolean
	var goret1 bool

	cret = C.gtk_cell_area_activate_cell(arg0, widget, renderer, event, cellArea, flags)

	goret1 = C.bool(cret) != C.false

	return goret1
}

// Add adds @renderer to @area with the default child cell properties.
func (a cellArea) Add(renderer CellRenderer) {
	var arg0 *C.GtkCellArea
	var arg1 *C.GtkCellRenderer

	arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
	arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))

	C.gtk_cell_area_add(arg0, renderer)
}

// AddFocusSibling adds @sibling to @renderer’s focusable area, focus will
// be drawn around @renderer and all of its siblings if @renderer can focus
// for a given row.
//
// Events handled by focus siblings can also activate the given focusable
// @renderer.
func (a cellArea) AddFocusSibling(renderer CellRenderer, sibling CellRenderer) {
	var arg0 *C.GtkCellArea
	var arg1 *C.GtkCellRenderer
	var arg2 *C.GtkCellRenderer

	arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
	arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))
	arg2 = (*C.GtkCellRenderer)(unsafe.Pointer(sibling.Native()))

	C.gtk_cell_area_add_focus_sibling(arg0, renderer, sibling)
}

// ApplyAttributes applies any connected attributes to the renderers in
// @area by pulling the values from @tree_model.
func (a cellArea) ApplyAttributes(treeModel TreeModel, iter *TreeIter, isExpander bool, isExpanded bool) {
	var arg0 *C.GtkCellArea
	var arg1 *C.GtkTreeModel
	var arg2 *C.GtkTreeIter
	var arg3 C.gboolean
	var arg4 C.gboolean

	arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
	arg1 = (*C.GtkTreeModel)(unsafe.Pointer(treeModel.Native()))
	arg2 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))
	if isExpander {
		arg3 = C.gboolean(1)
	}
	if isExpanded {
		arg4 = C.gboolean(1)
	}

	C.gtk_cell_area_apply_attributes(arg0, treeModel, iter, isExpander, isExpanded)
}

// AttributeConnect connects an @attribute to apply values from @column for
// the TreeModel in use.
func (a cellArea) AttributeConnect(renderer CellRenderer, attribute string, column int) {
	var arg0 *C.GtkCellArea
	var arg1 *C.GtkCellRenderer
	var arg2 *C.char
	var arg3 C.int

	arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
	arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))
	arg2 = (*C.char)(C.CString(attribute))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = C.int(column)

	C.gtk_cell_area_attribute_connect(arg0, renderer, attribute, column)
}

// AttributeDisconnect disconnects @attribute for the @renderer in @area so
// that attribute will no longer be updated with values from the model.
func (a cellArea) AttributeDisconnect(renderer CellRenderer, attribute string) {
	var arg0 *C.GtkCellArea
	var arg1 *C.GtkCellRenderer
	var arg2 *C.char

	arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
	arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))
	arg2 = (*C.char)(C.CString(attribute))
	defer C.free(unsafe.Pointer(arg2))

	C.gtk_cell_area_attribute_disconnect(arg0, renderer, attribute)
}

// AttributeGetColumn returns the model column that an attribute has been
// mapped to, or -1 if the attribute is not mapped.
func (a cellArea) AttributeGetColumn(renderer CellRenderer, attribute string) int {
	var arg0 *C.GtkCellArea
	var arg1 *C.GtkCellRenderer
	var arg2 *C.char

	arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
	arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))
	arg2 = (*C.char)(C.CString(attribute))
	defer C.free(unsafe.Pointer(arg2))

	var cret C.int
	var goret1 int

	cret = C.gtk_cell_area_attribute_get_column(arg0, renderer, attribute)

	goret1 = C.int(cret)

	return goret1
}

// CellGetProperty gets the value of a cell property for @renderer in @area.
func (a cellArea) CellGetProperty(renderer CellRenderer, propertyName string, value *externglib.Value) {
	var arg0 *C.GtkCellArea
	var arg1 *C.GtkCellRenderer
	var arg2 *C.char
	var arg3 *C.GValue

	arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
	arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))
	arg2 = (*C.char)(C.CString(propertyName))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.GValue)(value.GValue)

	C.gtk_cell_area_cell_get_property(arg0, renderer, propertyName, value)
}

// CellSetProperty sets a cell property for @renderer in @area.
func (a cellArea) CellSetProperty(renderer CellRenderer, propertyName string, value *externglib.Value) {
	var arg0 *C.GtkCellArea
	var arg1 *C.GtkCellRenderer
	var arg2 *C.char
	var arg3 *C.GValue

	arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
	arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))
	arg2 = (*C.char)(C.CString(propertyName))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.GValue)(value.GValue)

	C.gtk_cell_area_cell_set_property(arg0, renderer, propertyName, value)
}

// CopyContext: this is sometimes needed for cases where rows need to share
// alignments in one orientation but may be separately grouped in the
// opposing orientation.
//
// For instance, IconView creates all icons (rows) to have the same width
// and the cells theirin to have the same horizontal alignments. However
// each row of icons may have a separate collective height. IconView uses
// this to request the heights of each row based on a context which was
// already used to request all the row widths that are to be displayed.
func (a cellArea) CopyContext(context CellAreaContext) CellAreaContext {
	var arg0 *C.GtkCellArea
	var arg1 *C.GtkCellAreaContext

	arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
	arg1 = (*C.GtkCellAreaContext)(unsafe.Pointer(context.Native()))

	var cret *C.GtkCellAreaContext
	var goret1 CellAreaContext

	cret = C.gtk_cell_area_copy_context(arg0, context)

	goret1 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(CellAreaContext)

	return goret1
}

// CreateContext creates a CellAreaContext to be used with @area for all
// purposes. CellAreaContext stores geometry information for rows for which
// it was operated on, it is important to use the same context for the same
// row of data at all times (i.e. one should render and handle events with
// the same CellAreaContext which was used to request the size of those rows
// of data).
func (a cellArea) CreateContext() CellAreaContext {
	var arg0 *C.GtkCellArea

	arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))

	var cret *C.GtkCellAreaContext
	var goret1 CellAreaContext

	cret = C.gtk_cell_area_create_context(arg0)

	goret1 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(CellAreaContext)

	return goret1
}

// Event delegates event handling to a CellArea.
func (a cellArea) Event(context CellAreaContext, widget Widget, event gdk.Event, cellArea *gdk.Rectangle, flags CellRendererState) int {
	var arg0 *C.GtkCellArea
	var arg1 *C.GtkCellAreaContext
	var arg2 *C.GtkWidget
	var arg3 *C.GdkEvent
	var arg4 *C.GdkRectangle
	var arg5 C.GtkCellRendererState

	arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
	arg1 = (*C.GtkCellAreaContext)(unsafe.Pointer(context.Native()))
	arg2 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	arg3 = (*C.GdkEvent)(unsafe.Pointer(event.Native()))
	arg4 = (*C.GdkRectangle)(unsafe.Pointer(cellArea.Native()))
	arg5 = (C.GtkCellRendererState)(flags)

	var cret C.int
	var goret1 int

	cret = C.gtk_cell_area_event(arg0, context, widget, event, cellArea, flags)

	goret1 = C.int(cret)

	return goret1
}

// Focus: this should be called by the @area’s owning layout widget when
// focus is to be passed to @area, or moved within @area for a given
// @direction and row data.
//
// Implementing CellArea classes should implement this method to receive and
// navigate focus in its own way particular to how it lays out cells.
func (a cellArea) Focus(direction DirectionType) bool {
	var arg0 *C.GtkCellArea
	var arg1 C.GtkDirectionType

	arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
	arg1 = (C.GtkDirectionType)(direction)

	var cret C.gboolean
	var goret1 bool

	cret = C.gtk_cell_area_focus(arg0, direction)

	goret1 = C.bool(cret) != C.false

	return goret1
}

// Foreach calls @callback for every CellRenderer in @area.
func (a cellArea) Foreach(callback CellCallback) {
	var arg0 *C.GtkCellArea

	arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))

	C.gtk_cell_area_foreach(arg0, callback, callbackData)
}

// ForeachAlloc calls @callback for every CellRenderer in @area with the
// allocated rectangle inside @cell_area.
func (a cellArea) ForeachAlloc(context CellAreaContext, widget Widget, cellArea *gdk.Rectangle, backgroundArea *gdk.Rectangle, callback CellAllocCallback) {
	var arg0 *C.GtkCellArea

	arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))

	C.gtk_cell_area_foreach_alloc(arg0, context, widget, cellArea, backgroundArea, callback, callbackData)
}

// CellAllocation derives the allocation of @renderer inside @area if @area
// were to be renderered in @cell_area.
func (a cellArea) CellAllocation(context CellAreaContext, widget Widget, renderer CellRenderer, cellArea *gdk.Rectangle) gdk.Rectangle {
	var arg0 *C.GtkCellArea
	var arg1 *C.GtkCellAreaContext
	var arg2 *C.GtkWidget
	var arg3 *C.GtkCellRenderer
	var arg4 *C.GdkRectangle

	arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
	arg1 = (*C.GtkCellAreaContext)(unsafe.Pointer(context.Native()))
	arg2 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	arg3 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))
	arg4 = (*C.GdkRectangle)(unsafe.Pointer(cellArea.Native()))

	var arg5 *C.GdkRectangle
	var ret5 *gdk.Rectangle

	C.gtk_cell_area_get_cell_allocation(arg0, context, widget, renderer, cellArea, &arg5)

	ret5 = gdk.WrapRectangle(unsafe.Pointer(arg5))

	return ret5
}

// CellAtPosition gets the CellRenderer at @x and @y coordinates inside
// @area and optionally returns the full cell allocation for it inside
// @cell_area.
func (a cellArea) CellAtPosition(context CellAreaContext, widget Widget, cellArea *gdk.Rectangle, x int, y int) (allocArea gdk.Rectangle, cellRenderer CellRenderer) {
	var arg0 *C.GtkCellArea
	var arg1 *C.GtkCellAreaContext
	var arg2 *C.GtkWidget
	var arg3 *C.GdkRectangle
	var arg4 C.int
	var arg5 C.int

	arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
	arg1 = (*C.GtkCellAreaContext)(unsafe.Pointer(context.Native()))
	arg2 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	arg3 = (*C.GdkRectangle)(unsafe.Pointer(cellArea.Native()))
	arg4 = C.int(x)
	arg5 = C.int(y)

	var arg6 *C.GdkRectangle
	var ret6 *gdk.Rectangle
	var cret *C.GtkCellRenderer
	var goret2 CellRenderer

	cret = C.gtk_cell_area_get_cell_at_position(arg0, context, widget, cellArea, x, y, &arg6)

	ret6 = gdk.WrapRectangle(unsafe.Pointer(arg6))
	goret2 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(CellRenderer)

	return ret6, goret2
}

// CurrentPathString gets the current TreePath string for the currently
// applied TreeIter, this is implicitly updated when
// gtk_cell_area_apply_attributes() is called and can be used to interact
// with renderers from CellArea subclasses.
func (a cellArea) CurrentPathString() string {
	var arg0 *C.GtkCellArea

	arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))

	var cret *C.char
	var goret1 string

	cret = C.gtk_cell_area_get_current_path_string(arg0)

	goret1 = C.GoString(cret)

	return goret1
}

// EditWidget gets the CellEditable widget currently used to edit the
// currently edited cell.
func (a cellArea) EditWidget() CellEditable {
	var arg0 *C.GtkCellArea

	arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))

	var cret *C.GtkCellEditable
	var goret1 CellEditable

	cret = C.gtk_cell_area_get_edit_widget(arg0)

	goret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(CellEditable)

	return goret1
}

// EditedCell gets the CellRenderer in @area that is currently being edited.
func (a cellArea) EditedCell() CellRenderer {
	var arg0 *C.GtkCellArea

	arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))

	var cret *C.GtkCellRenderer
	var goret1 CellRenderer

	cret = C.gtk_cell_area_get_edited_cell(arg0)

	goret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(CellRenderer)

	return goret1
}

// FocusCell retrieves the currently focused cell for @area
func (a cellArea) FocusCell() CellRenderer {
	var arg0 *C.GtkCellArea

	arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))

	var cret *C.GtkCellRenderer
	var goret1 CellRenderer

	cret = C.gtk_cell_area_get_focus_cell(arg0)

	goret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(CellRenderer)

	return goret1
}

// FocusFromSibling gets the CellRenderer which is expected to be focusable
// for which @renderer is, or may be a sibling.
//
// This is handy for CellArea subclasses when handling events, after
// determining the renderer at the event location it can then chose to
// activate the focus cell for which the event cell may have been a sibling.
func (a cellArea) FocusFromSibling(renderer CellRenderer) CellRenderer {
	var arg0 *C.GtkCellArea
	var arg1 *C.GtkCellRenderer

	arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
	arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))

	var cret *C.GtkCellRenderer
	var goret1 CellRenderer

	cret = C.gtk_cell_area_get_focus_from_sibling(arg0, renderer)

	goret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(CellRenderer)

	return goret1
}

// FocusSiblings gets the focus sibling cell renderers for @renderer.
func (a cellArea) FocusSiblings(renderer CellRenderer) *glib.List {
	var arg0 *C.GtkCellArea
	var arg1 *C.GtkCellRenderer

	arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
	arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))

	var cret *C.GList
	var goret1 *glib.List

	cret = C.gtk_cell_area_get_focus_siblings(arg0, renderer)

	goret1 = glib.WrapList(unsafe.Pointer(cret))

	return goret1
}

// PreferredHeight retrieves a cell area’s initial minimum and natural
// height.
//
// @area will store some geometrical information in @context along the way;
// when requesting sizes over an arbitrary number of rows, it’s not
// important to check the @minimum_height and @natural_height of this call
// but rather to consult gtk_cell_area_context_get_preferred_height() after
// a series of requests.
func (a cellArea) PreferredHeight(context CellAreaContext, widget Widget) (minimumHeight int, naturalHeight int) {
	var arg0 *C.GtkCellArea
	var arg1 *C.GtkCellAreaContext
	var arg2 *C.GtkWidget

	arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
	arg1 = (*C.GtkCellAreaContext)(unsafe.Pointer(context.Native()))
	arg2 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	var arg3 *C.int
	var ret3 int
	var arg4 *C.int
	var ret4 int

	C.gtk_cell_area_get_preferred_height(arg0, context, widget, &arg3, &arg4)

	ret3 = *C.int(arg3)
	ret4 = *C.int(arg4)

	return ret3, ret4
}

// PreferredHeightForWidth retrieves a cell area’s minimum and natural
// height if it would be given the specified @width.
//
// @area stores some geometrical information in @context along the way while
// calling gtk_cell_area_get_preferred_width(). It’s important to perform a
// series of gtk_cell_area_get_preferred_width() requests with @context
// first and then call gtk_cell_area_get_preferred_height_for_width() on
// each cell area individually to get the height for width of each fully
// requested row.
//
// If at some point, the width of a single row changes, it should be
// requested with gtk_cell_area_get_preferred_width() again and then the
// full width of the requested rows checked again with
// gtk_cell_area_context_get_preferred_width().
func (a cellArea) PreferredHeightForWidth(context CellAreaContext, widget Widget, width int) (minimumHeight int, naturalHeight int) {
	var arg0 *C.GtkCellArea
	var arg1 *C.GtkCellAreaContext
	var arg2 *C.GtkWidget
	var arg3 C.int

	arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
	arg1 = (*C.GtkCellAreaContext)(unsafe.Pointer(context.Native()))
	arg2 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	arg3 = C.int(width)

	var arg4 *C.int
	var ret4 int
	var arg5 *C.int
	var ret5 int

	C.gtk_cell_area_get_preferred_height_for_width(arg0, context, widget, width, &arg4, &arg5)

	ret4 = *C.int(arg4)
	ret5 = *C.int(arg5)

	return ret4, ret5
}

// PreferredWidth retrieves a cell area’s initial minimum and natural width.
//
// @area will store some geometrical information in @context along the way;
// when requesting sizes over an arbitrary number of rows, it’s not
// important to check the @minimum_width and @natural_width of this call but
// rather to consult gtk_cell_area_context_get_preferred_width() after a
// series of requests.
func (a cellArea) PreferredWidth(context CellAreaContext, widget Widget) (minimumWidth int, naturalWidth int) {
	var arg0 *C.GtkCellArea
	var arg1 *C.GtkCellAreaContext
	var arg2 *C.GtkWidget

	arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
	arg1 = (*C.GtkCellAreaContext)(unsafe.Pointer(context.Native()))
	arg2 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	var arg3 *C.int
	var ret3 int
	var arg4 *C.int
	var ret4 int

	C.gtk_cell_area_get_preferred_width(arg0, context, widget, &arg3, &arg4)

	ret3 = *C.int(arg3)
	ret4 = *C.int(arg4)

	return ret3, ret4
}

// PreferredWidthForHeight retrieves a cell area’s minimum and natural width
// if it would be given the specified @height.
//
// @area stores some geometrical information in @context along the way while
// calling gtk_cell_area_get_preferred_height(). It’s important to perform a
// series of gtk_cell_area_get_preferred_height() requests with @context
// first and then call gtk_cell_area_get_preferred_width_for_height() on
// each cell area individually to get the height for width of each fully
// requested row.
//
// If at some point, the height of a single row changes, it should be
// requested with gtk_cell_area_get_preferred_height() again and then the
// full height of the requested rows checked again with
// gtk_cell_area_context_get_preferred_height().
func (a cellArea) PreferredWidthForHeight(context CellAreaContext, widget Widget, height int) (minimumWidth int, naturalWidth int) {
	var arg0 *C.GtkCellArea
	var arg1 *C.GtkCellAreaContext
	var arg2 *C.GtkWidget
	var arg3 C.int

	arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
	arg1 = (*C.GtkCellAreaContext)(unsafe.Pointer(context.Native()))
	arg2 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	arg3 = C.int(height)

	var arg4 *C.int
	var ret4 int
	var arg5 *C.int
	var ret5 int

	C.gtk_cell_area_get_preferred_width_for_height(arg0, context, widget, height, &arg4, &arg5)

	ret4 = *C.int(arg4)
	ret5 = *C.int(arg5)

	return ret4, ret5
}

// RequestMode gets whether the area prefers a height-for-width layout or a
// width-for-height layout.
func (a cellArea) RequestMode() SizeRequestMode {
	var arg0 *C.GtkCellArea

	arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))

	var cret C.GtkSizeRequestMode
	var goret1 SizeRequestMode

	cret = C.gtk_cell_area_get_request_mode(arg0)

	goret1 = SizeRequestMode(cret)

	return goret1
}

// HasRenderer checks if @area contains @renderer.
func (a cellArea) HasRenderer(renderer CellRenderer) bool {
	var arg0 *C.GtkCellArea
	var arg1 *C.GtkCellRenderer

	arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
	arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))

	var cret C.gboolean
	var goret1 bool

	cret = C.gtk_cell_area_has_renderer(arg0, renderer)

	goret1 = C.bool(cret) != C.false

	return goret1
}

// InnerCellArea: this is a convenience function for CellArea
// implementations to get the inner area where a given CellRenderer will be
// rendered. It removes any padding previously added by
// gtk_cell_area_request_renderer().
func (a cellArea) InnerCellArea(widget Widget, cellArea *gdk.Rectangle) gdk.Rectangle {
	var arg0 *C.GtkCellArea
	var arg1 *C.GtkWidget
	var arg2 *C.GdkRectangle

	arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	arg2 = (*C.GdkRectangle)(unsafe.Pointer(cellArea.Native()))

	var arg3 *C.GdkRectangle
	var ret3 *gdk.Rectangle

	C.gtk_cell_area_inner_cell_area(arg0, widget, cellArea, &arg3)

	ret3 = gdk.WrapRectangle(unsafe.Pointer(arg3))

	return ret3
}

// IsActivatable returns whether the area can do anything when activated,
// after applying new attributes to @area.
func (a cellArea) IsActivatable() bool {
	var arg0 *C.GtkCellArea

	arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))

	var cret C.gboolean
	var goret1 bool

	cret = C.gtk_cell_area_is_activatable(arg0)

	goret1 = C.bool(cret) != C.false

	return goret1
}

// IsFocusSibling returns whether @sibling is one of @renderer’s focus
// siblings (see gtk_cell_area_add_focus_sibling()).
func (a cellArea) IsFocusSibling(renderer CellRenderer, sibling CellRenderer) bool {
	var arg0 *C.GtkCellArea
	var arg1 *C.GtkCellRenderer
	var arg2 *C.GtkCellRenderer

	arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
	arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))
	arg2 = (*C.GtkCellRenderer)(unsafe.Pointer(sibling.Native()))

	var cret C.gboolean
	var goret1 bool

	cret = C.gtk_cell_area_is_focus_sibling(arg0, renderer, sibling)

	goret1 = C.bool(cret) != C.false

	return goret1
}

// Remove removes @renderer from @area.
func (a cellArea) Remove(renderer CellRenderer) {
	var arg0 *C.GtkCellArea
	var arg1 *C.GtkCellRenderer

	arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
	arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))

	C.gtk_cell_area_remove(arg0, renderer)
}

// RemoveFocusSibling removes @sibling from @renderer’s focus sibling list
// (see gtk_cell_area_add_focus_sibling()).
func (a cellArea) RemoveFocusSibling(renderer CellRenderer, sibling CellRenderer) {
	var arg0 *C.GtkCellArea
	var arg1 *C.GtkCellRenderer
	var arg2 *C.GtkCellRenderer

	arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
	arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))
	arg2 = (*C.GtkCellRenderer)(unsafe.Pointer(sibling.Native()))

	C.gtk_cell_area_remove_focus_sibling(arg0, renderer, sibling)
}

// RequestRenderer: this is a convenience function for CellArea
// implementations to request size for cell renderers. It’s important to use
// this function to request size and then use
// gtk_cell_area_inner_cell_area() at render and event time since this
// function will add padding around the cell for focus painting.
func (a cellArea) RequestRenderer(renderer CellRenderer, orientation Orientation, widget Widget, forSize int) (minimumSize int, naturalSize int) {
	var arg0 *C.GtkCellArea
	var arg1 *C.GtkCellRenderer
	var arg2 C.GtkOrientation
	var arg3 *C.GtkWidget
	var arg4 C.int

	arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
	arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))
	arg2 = (C.GtkOrientation)(orientation)
	arg3 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	arg4 = C.int(forSize)

	var arg5 *C.int
	var ret5 int
	var arg6 *C.int
	var ret6 int

	C.gtk_cell_area_request_renderer(arg0, renderer, orientation, widget, forSize, &arg5, &arg6)

	ret5 = *C.int(arg5)
	ret6 = *C.int(arg6)

	return ret5, ret6
}

// SetFocusCell: explicitly sets the currently focused cell to @renderer.
//
// This is generally called by implementations of CellAreaClass.focus() or
// CellAreaClass.event(), however it can also be used to implement functions
// such as gtk_tree_view_set_cursor_on_cell().
func (a cellArea) SetFocusCell(renderer CellRenderer) {
	var arg0 *C.GtkCellArea
	var arg1 *C.GtkCellRenderer

	arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
	arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))

	C.gtk_cell_area_set_focus_cell(arg0, renderer)
}

// Snapshot snapshots @area’s cells according to @area’s layout onto at the
// given coordinates.
func (a cellArea) Snapshot(context CellAreaContext, widget Widget, snapshot Snapshot, backgroundArea *gdk.Rectangle, cellArea *gdk.Rectangle, flags CellRendererState, paintFocus bool) {
	var arg0 *C.GtkCellArea
	var arg1 *C.GtkCellAreaContext
	var arg2 *C.GtkWidget
	var arg3 *C.GtkSnapshot
	var arg4 *C.GdkRectangle
	var arg5 *C.GdkRectangle
	var arg6 C.GtkCellRendererState
	var arg7 C.gboolean

	arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
	arg1 = (*C.GtkCellAreaContext)(unsafe.Pointer(context.Native()))
	arg2 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	arg3 = (*C.GtkSnapshot)(unsafe.Pointer(snapshot.Native()))
	arg4 = (*C.GdkRectangle)(unsafe.Pointer(backgroundArea.Native()))
	arg5 = (*C.GdkRectangle)(unsafe.Pointer(cellArea.Native()))
	arg6 = (C.GtkCellRendererState)(flags)
	if paintFocus {
		arg7 = C.gboolean(1)
	}

	C.gtk_cell_area_snapshot(arg0, context, widget, snapshot, backgroundArea, cellArea, flags, paintFocus)
}

// StopEditing: explicitly stops the editing of the currently edited cell.
//
// If @canceled is true, the currently edited cell renderer will emit the
// ::editing-canceled signal, otherwise the the ::editing-done signal will
// be emitted on the current edit widget.
//
// See gtk_cell_area_get_edited_cell() and gtk_cell_area_get_edit_widget().
func (a cellArea) StopEditing(canceled bool) {
	var arg0 *C.GtkCellArea
	var arg1 C.gboolean

	arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
	if canceled {
		arg1 = C.gboolean(1)
	}

	C.gtk_cell_area_stop_editing(arg0, canceled)
}
