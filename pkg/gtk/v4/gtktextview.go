// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/gdk/v4"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
	"github.com/diamondburned/gotk4/pkg/pango"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gtk4
// #cgo CFLAGS: -Wno-deprecated-declarations
//
// #include <glib-object.h>
// #include <gtk/gtk.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_text_extend_selection_get_type()), F: marshalTextExtendSelection},
		{T: externglib.Type(C.gtk_text_view_layer_get_type()), F: marshalTextViewLayer},
		{T: externglib.Type(C.gtk_text_window_type_get_type()), F: marshalTextWindowType},
		{T: externglib.Type(C.gtk_text_view_get_type()), F: marshalTextView},
	})
}

// TextExtendSelection: granularity types that extend the text selection. Use
// the TextView::extend-selection signal to customize the selection.
type TextExtendSelection int

const (
	// word selects the current word. It is triggered by a double-click for
	// example.
	TextExtendSelectionWord TextExtendSelection = iota
	// line selects the current line. It is triggered by a triple-click for
	// example.
	TextExtendSelectionLine
)

func marshalTextExtendSelection(p uintptr) (interface{}, error) {
	return TextExtendSelection(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TextViewLayer: used to reference the layers of TextView for the purpose of
// customized drawing with the ::snapshot_layer vfunc.
type TextViewLayer int

const (
	// BelowText: the layer rendered below the text (but above the background).
	TextViewLayerBelowText TextViewLayer = iota
	// AboveText: the layer rendered above the text.
	TextViewLayerAboveText
)

func marshalTextViewLayer(p uintptr) (interface{}, error) {
	return TextViewLayer(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TextWindowType: used to reference the parts of TextView.
type TextWindowType int

const (
	// widget: window that floats over scrolling areas.
	TextWindowTypeWidget TextWindowType = 1
	// text: scrollable text window.
	TextWindowTypeText TextWindowType = 2
	// left: left side border window.
	TextWindowTypeLeft TextWindowType = 3
	// right: right side border window.
	TextWindowTypeRight TextWindowType = 4
	// top: top border window.
	TextWindowTypeTop TextWindowType = 5
	// bottom: bottom border window.
	TextWindowTypeBottom TextWindowType = 6
)

func marshalTextWindowType(p uintptr) (interface{}, error) {
	return TextWindowType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TextView: widget that displays the contents of a [class@Gtk.TextBuffer].
//
// !An example GtkTextview (multiline-text.png)
//
// You may wish to begin by reading the conceptual overview
// (section-text-widget.html), which gives an overview of all the objects and
// data types related to the text widget and how they work together.
//
//
// CSS nodes
//
// “` textview.view ├── border.top ├── border.left ├── text │ ╰── [selection]
// ├── border.right ├── border.bottom ╰── [window.popup] “`
//
// `GtkTextView` has a main css node with name textview and style class .view,
// and subnodes for each of the border windows, and the main text area, with
// names border and text, respectively. The border nodes each get one of the
// style classes .left, .right, .top or .bottom.
//
// A node representing the selection will appear below the text node.
//
// If a context menu is opened, the window node will appear as a subnode of the
// main node.
//
//
// Accessibility
//
// `GtkTextView` uses the K_ACCESSIBLE_ROLE_TEXT_BOX role.
type TextView interface {
	Widget

	// AsAccessible casts the class to the Accessible interface.
	AsAccessible() Accessible
	// AsBuildable casts the class to the Buildable interface.
	AsBuildable() Buildable
	// AsConstraintTarget casts the class to the ConstraintTarget interface.
	AsConstraintTarget() ConstraintTarget
	// AsScrollable casts the class to the Scrollable interface.
	AsScrollable() Scrollable

	// AddChildAtAnchor adds a child widget in the text buffer, at the given
	// @anchor.
	AddChildAtAnchor(child Widget, anchor TextChildAnchor)
	// AddOverlay adds @child at a fixed coordinate in the `GtkTextView`'s text
	// window.
	//
	// The @xpos and @ypos must be in buffer coordinates (see
	// [method@Gtk.TextView.get_iter_location] to convert to buffer
	// coordinates).
	//
	// @child will scroll with the text view.
	//
	// If instead you want a widget that will not move with the `GtkTextView`
	// contents see Overlay.
	AddOverlay(child Widget, xpos int, ypos int)
	// BackwardDisplayLine moves the given @iter backward by one display
	// (wrapped) line.
	//
	// A display line is different from a paragraph. Paragraphs are separated by
	// newlines or other paragraph separator characters. Display lines are
	// created by line-wrapping a paragraph. If wrapping is turned off, display
	// lines and paragraphs will be the same. Display lines are divided
	// differently for each view, since they depend on the view’s width;
	// paragraphs are the same in all views, since they depend on the contents
	// of the `GtkTextBuffer`.
	BackwardDisplayLine(iter *TextIter) bool
	// BackwardDisplayLineStart moves the given @iter backward to the next
	// display line start.
	//
	// A display line is different from a paragraph. Paragraphs are separated by
	// newlines or other paragraph separator characters. Display lines are
	// created by line-wrapping a paragraph. If wrapping is turned off, display
	// lines and paragraphs will be the same. Display lines are divided
	// differently for each view, since they depend on the view’s width;
	// paragraphs are the same in all views, since they depend on the contents
	// of the `GtkTextBuffer`.
	BackwardDisplayLineStart(iter *TextIter) bool
	// BufferToWindowCoords converts buffer coordinates to window coordinates.
	BufferToWindowCoords(win TextWindowType, bufferX int, bufferY int) (windowX int, windowY int)
	// ForwardDisplayLine moves the given @iter forward by one display (wrapped)
	// line.
	//
	// A display line is different from a paragraph. Paragraphs are separated by
	// newlines or other paragraph separator characters. Display lines are
	// created by line-wrapping a paragraph. If wrapping is turned off, display
	// lines and paragraphs will be the same. Display lines are divided
	// differently for each view, since they depend on the view’s width;
	// paragraphs are the same in all views, since they depend on the contents
	// of the `GtkTextBuffer`.
	ForwardDisplayLine(iter *TextIter) bool
	// ForwardDisplayLineEnd moves the given @iter forward to the next display
	// line end.
	//
	// A display line is different from a paragraph. Paragraphs are separated by
	// newlines or other paragraph separator characters. Display lines are
	// created by line-wrapping a paragraph. If wrapping is turned off, display
	// lines and paragraphs will be the same. Display lines are divided
	// differently for each view, since they depend on the view’s width;
	// paragraphs are the same in all views, since they depend on the contents
	// of the `GtkTextBuffer`.
	ForwardDisplayLineEnd(iter *TextIter) bool
	// AcceptsTab returns whether pressing the Tab key inserts a tab characters.
	//
	// See [method@Gtk.TextView.set_accepts_tab].
	AcceptsTab() bool
	// BottomMargin gets the bottom margin for text in the @text_view.
	BottomMargin() int
	// Buffer returns the `GtkTextBuffer` being displayed by this text view.
	//
	// The reference count on the buffer is not incremented; the caller of this
	// function won’t own a new reference.
	Buffer() TextBuffer
	// CursorLocations: determine the positions of the strong and weak cursors
	// if the insertion point is at @iter.
	//
	// The position of each cursor is stored as a zero-width rectangle. The
	// strong cursor location is the location where characters of the
	// directionality equal to the base direction of the paragraph are inserted.
	// The weak cursor location is the location where characters of the
	// directionality opposite to the base direction of the paragraph are
	// inserted.
	//
	// If @iter is nil, the actual cursor position is used.
	//
	// Note that if @iter happens to be the actual cursor position, and there is
	// currently an IM preedit sequence being entered, the returned locations
	// will be adjusted to account for the preedit cursor’s offset within the
	// preedit sequence.
	//
	// The rectangle position is in buffer coordinates; use
	// [method@Gtk.TextView.buffer_to_window_coords] to convert these
	// coordinates to coordinates for one of the windows in the text view.
	CursorLocations(iter *TextIter) (strong gdk.Rectangle, weak gdk.Rectangle)
	// CursorVisible: find out whether the cursor should be displayed.
	CursorVisible() bool
	// Editable returns the default editability of the `GtkTextView`.
	//
	// Tags in the buffer may override this setting for some ranges of text.
	Editable() bool
	// ExtraMenu gets the menu model that gets added to the context menu or nil
	// if none has been set.
	ExtraMenu() gio.MenuModel
	// Gutter gets a `GtkWidget` that has previously been set as gutter.
	//
	// See [method@Gtk.TextView.set_gutter].
	//
	// @win must be one of GTK_TEXT_WINDOW_LEFT, GTK_TEXT_WINDOW_RIGHT,
	// GTK_TEXT_WINDOW_TOP, or GTK_TEXT_WINDOW_BOTTOM.
	Gutter(win TextWindowType) Widget
	// Indent gets the default indentation of paragraphs in @text_view.
	//
	// Tags in the view’s buffer may override the default. The indentation may
	// be negative.
	Indent() int
	// InputHints gets the `input-hints` of the `GtkTextView`.
	InputHints() InputHints
	// InputPurpose gets the `input-purpose` of the `GtkTextView`.
	InputPurpose() InputPurpose
	// IterAtLocation retrieves the iterator at buffer coordinates @x and @y.
	//
	// Buffer coordinates are coordinates for the entire buffer, not just the
	// currently-displayed portion. If you have coordinates from an event, you
	// have to convert those to buffer coordinates with
	// [method@Gtk.TextView.window_to_buffer_coords].
	IterAtLocation(x int, y int) (TextIter, bool)
	// IterAtPosition retrieves the iterator pointing to the character at buffer
	// coordinates @x and @y.
	//
	// Buffer coordinates are coordinates for the entire buffer, not just the
	// currently-displayed portion. If you have coordinates from an event, you
	// have to convert those to buffer coordinates with
	// [method@Gtk.TextView.window_to_buffer_coords].
	//
	// Note that this is different from
	// [method@Gtk.TextView.get_iter_at_location], which returns cursor
	// locations, i.e. positions between characters.
	IterAtPosition(x int, y int) (TextIter, int, bool)
	// IterLocation gets a rectangle which roughly contains the character at
	// @iter.
	//
	// The rectangle position is in buffer coordinates; use
	// [method@Gtk.TextView.buffer_to_window_coords] to convert these
	// coordinates to coordinates for one of the windows in the text view.
	IterLocation(iter *TextIter) gdk.Rectangle
	// Justification gets the default justification of paragraphs in @text_view.
	//
	// Tags in the buffer may override the default.
	Justification() Justification
	// LeftMargin gets the default left margin size of paragraphs in the
	// @text_view.
	//
	// Tags in the buffer may override the default.
	LeftMargin() int
	// LineAtY gets the `GtkTextIter` at the start of the line containing the
	// coordinate @y.
	//
	// @y is in buffer coordinates, convert from window coordinates with
	// [method@Gtk.TextView.window_to_buffer_coords]. If non-nil, @line_top will
	// be filled with the coordinate of the top edge of the line.
	LineAtY(y int) (TextIter, int)
	// LineYrange gets the y coordinate of the top of the line containing @iter,
	// and the height of the line.
	//
	// The coordinate is a buffer coordinate; convert to window coordinates with
	// [method@Gtk.TextView.buffer_to_window_coords].
	LineYrange(iter *TextIter) (y int, height int)
	// Monospace gets whether the `GtkTextView` uses monospace styling.
	Monospace() bool
	// Overwrite returns whether the `GtkTextView` is in overwrite mode or not.
	Overwrite() bool
	// PixelsAboveLines gets the default number of pixels to put above
	// paragraphs.
	//
	// Adding this function with [method@Gtk.TextView.get_pixels_below_lines] is
	// equal to the line space between each paragraph.
	PixelsAboveLines() int
	// PixelsBelowLines gets the default number of pixels to put below
	// paragraphs.
	//
	// The line space is the sum of the value returned by this function and the
	// value returned by [method@Gtk.TextView.get_pixels_above_lines].
	PixelsBelowLines() int
	// PixelsInsideWrap gets the default number of pixels to put between wrapped
	// lines inside a paragraph.
	PixelsInsideWrap() int
	// RightMargin gets the default right margin for text in @text_view.
	//
	// Tags in the buffer may override the default.
	RightMargin() int
	// Tabs gets the default tabs for @text_view.
	//
	// Tags in the buffer may override the defaults. The returned array will be
	// nil if “standard” (8-space) tabs are used. Free the return value with
	// [method@Pango.TabArray.free].
	Tabs() *pango.TabArray
	// TopMargin gets the top margin for text in the @text_view.
	TopMargin() int
	// VisibleRect fills @visible_rect with the currently-visible region of the
	// buffer, in buffer coordinates.
	//
	// Convert to window coordinates with
	// [method@Gtk.TextView.buffer_to_window_coords].
	VisibleRect() gdk.Rectangle
	// WrapMode gets the line wrapping for the view.
	WrapMode() WrapMode
	// ImContextFilterKeypress: allow the `GtkTextView` input method to
	// internally handle key press and release events.
	//
	// If this function returns true, then no further processing should be done
	// for this key event. See [method@Gtk.IMContext.filter_keypress].
	//
	// Note that you are expected to call this function from your handler when
	// overriding key event handling. This is needed in the case when you need
	// to insert your own key handling between the input method and the default
	// key event handling of the `GtkTextView`.
	//
	// “`c static gboolean gtk_foo_bar_key_press_event (GtkWidget *widget,
	// GdkEvent *event) { guint keyval;
	//
	//    gdk_event_get_keyval ((GdkEvent*)event, &keyval);
	//
	//    if (keyval == GDK_KEY_Return || keyval == GDK_KEY_KP_Enter)
	//      {
	//        if (gtk_text_view_im_context_filter_keypress (GTK_TEXT_VIEW (widget), event))
	//          return TRUE;
	//      }
	//
	//    // Do some stuff
	//
	//    return GTK_WIDGET_CLASS (gtk_foo_bar_parent_class)->key_press_event (widget, event);
	//
	// } “`
	ImContextFilterKeypress(event gdk.Event) bool
	// MoveMarkOnscreen moves a mark within the buffer so that it's located
	// within the currently-visible text area.
	MoveMarkOnscreen(mark TextMark) bool
	// MoveOverlay updates the position of a child.
	//
	// See [method@Gtk.TextView.add_overlay].
	MoveOverlay(child Widget, xpos int, ypos int)
	// MoveVisually: move the iterator a given number of characters visually,
	// treating it as the strong cursor position.
	//
	// If @count is positive, then the new strong cursor position will be @count
	// positions to the right of the old cursor position. If @count is negative
	// then the new strong cursor position will be @count positions to the left
	// of the old cursor position.
	//
	// In the presence of bi-directional text, the correspondence between
	// logical and visual order will depend on the direction of the current run,
	// and there may be jumps when the cursor is moved off of the end of a run.
	MoveVisually(iter *TextIter, count int) bool
	// PlaceCursorOnscreen moves the cursor to the currently visible region of
	// the buffer.
	PlaceCursorOnscreen() bool
	// Remove removes a child widget from @text_view.
	Remove(child Widget)
	// ResetCursorBlink ensures that the cursor is shown.
	//
	// This also resets the time that it will stay blinking (or visible, in case
	// blinking is disabled).
	//
	// This function should be called in response to user input (e.g. from
	// derived classes that override the textview's event handlers).
	ResetCursorBlink()
	// ResetImContext: reset the input method context of the text view if
	// needed.
	//
	// This can be necessary in the case where modifying the buffer would
	// confuse on-going input method behavior.
	ResetImContext()
	// ScrollMarkOnscreen scrolls @text_view the minimum distance such that
	// @mark is contained within the visible area of the widget.
	ScrollMarkOnscreen(mark TextMark)
	// ScrollToIter scrolls @text_view so that @iter is on the screen in the
	// position indicated by @xalign and @yalign.
	//
	// An alignment of 0.0 indicates left or top, 1.0 indicates right or bottom,
	// 0.5 means center. If @use_align is false, the text scrolls the minimal
	// distance to get the mark onscreen, possibly not scrolling at all. The
	// effective screen for purposes of this function is reduced by a margin of
	// size @within_margin.
	//
	// Note that this function uses the currently-computed height of the lines
	// in the text buffer. Line heights are computed in an idle handler; so this
	// function may not have the desired effect if it’s called before the height
	// computations. To avoid oddness, consider using
	// [method@Gtk.TextView.scroll_to_mark] which saves a point to be scrolled
	// to after line validation.
	ScrollToIter(iter *TextIter, withinMargin float64, useAlign bool, xalign float64, yalign float64) bool
	// ScrollToMark scrolls @text_view so that @mark is on the screen in the
	// position indicated by @xalign and @yalign.
	//
	// An alignment of 0.0 indicates left or top, 1.0 indicates right or bottom,
	// 0.5 means center. If @use_align is false, the text scrolls the minimal
	// distance to get the mark onscreen, possibly not scrolling at all. The
	// effective screen for purposes of this function is reduced by a margin of
	// size @within_margin.
	ScrollToMark(mark TextMark, withinMargin float64, useAlign bool, xalign float64, yalign float64)
	// SetAcceptsTab sets the behavior of the text widget when the Tab key is
	// pressed.
	//
	// If @accepts_tab is true, a tab character is inserted. If @accepts_tab is
	// false the keyboard focus is moved to the next widget in the focus chain.
	SetAcceptsTab(acceptsTab bool)
	// SetBottomMargin sets the bottom margin for text in @text_view.
	//
	// Note that this function is confusingly named. In CSS terms, the value set
	// here is padding.
	SetBottomMargin(bottomMargin int)
	// SetBuffer sets @buffer as the buffer being displayed by @text_view.
	//
	// The previous buffer displayed by the text view is unreferenced, and a
	// reference is added to @buffer. If you owned a reference to @buffer before
	// passing it to this function, you must remove that reference yourself;
	// `GtkTextView` will not “adopt” it.
	SetBuffer(buffer TextBuffer)
	// SetCursorVisible toggles whether the insertion point should be displayed.
	//
	// A buffer with no editable text probably shouldn’t have a visible cursor,
	// so you may want to turn the cursor off.
	//
	// Note that this property may be overridden by the
	// [property@GtkSettings:gtk-keynav-use-caret] setting.
	SetCursorVisible(setting bool)
	// SetEditable sets the default editability of the `GtkTextView`.
	//
	// You can override this default setting with tags in the buffer, using the
	// “editable” attribute of tags.
	SetEditable(setting bool)
	// SetExtraMenu sets a menu model to add when constructing the context menu
	// for @text_view.
	//
	// You can pass nil to remove a previously set extra menu.
	SetExtraMenu(model gio.MenuModel)
	// SetGutter places @widget into the gutter specified by @win.
	//
	// @win must be one of GTK_TEXT_WINDOW_LEFT, GTK_TEXT_WINDOW_RIGHT,
	// GTK_TEXT_WINDOW_TOP, or GTK_TEXT_WINDOW_BOTTOM.
	SetGutter(win TextWindowType, widget Widget)
	// SetIndent sets the default indentation for paragraphs in @text_view.
	//
	// Tags in the buffer may override the default.
	SetIndent(indent int)
	// SetInputHints sets the `input-hints` of the `GtkTextView`.
	//
	// The `input-hints` allow input methods to fine-tune their behaviour.
	SetInputHints(hints InputHints)
	// SetInputPurpose sets the `input-purpose` of the `GtkTextView`.
	//
	// The `input-purpose` can be used by on-screen keyboards and other input
	// methods to adjust their behaviour.
	SetInputPurpose(purpose InputPurpose)
	// SetJustification sets the default justification of text in @text_view.
	//
	// Tags in the view’s buffer may override the default.
	SetJustification(justification Justification)
	// SetLeftMargin sets the default left margin for text in @text_view.
	//
	// Tags in the buffer may override the default.
	//
	// Note that this function is confusingly named. In CSS terms, the value set
	// here is padding.
	SetLeftMargin(leftMargin int)
	// SetMonospace sets whether the `GtkTextView` should display text in
	// monospace styling.
	SetMonospace(monospace bool)
	// SetOverwrite changes the `GtkTextView` overwrite mode.
	SetOverwrite(overwrite bool)
	// SetPixelsAboveLines sets the default number of blank pixels above
	// paragraphs in @text_view.
	//
	// Tags in the buffer for @text_view may override the defaults.
	SetPixelsAboveLines(pixelsAboveLines int)
	// SetPixelsBelowLines sets the default number of pixels of blank space to
	// put below paragraphs in @text_view.
	//
	// May be overridden by tags applied to @text_view’s buffer.
	SetPixelsBelowLines(pixelsBelowLines int)
	// SetPixelsInsideWrap sets the default number of pixels of blank space to
	// leave between display/wrapped lines within a paragraph.
	//
	// May be overridden by tags in @text_view’s buffer.
	SetPixelsInsideWrap(pixelsInsideWrap int)
	// SetRightMargin sets the default right margin for text in the text view.
	//
	// Tags in the buffer may override the default.
	//
	// Note that this function is confusingly named. In CSS terms, the value set
	// here is padding.
	SetRightMargin(rightMargin int)
	// SetTabs sets the default tab stops for paragraphs in @text_view.
	//
	// Tags in the buffer may override the default.
	SetTabs(tabs *pango.TabArray)
	// SetTopMargin sets the top margin for text in @text_view.
	//
	// Note that this function is confusingly named. In CSS terms, the value set
	// here is padding.
	SetTopMargin(topMargin int)
	// SetWrapMode sets the line wrapping for the view.
	SetWrapMode(wrapMode WrapMode)
	// StartsDisplayLine determines whether @iter is at the start of a display
	// line.
	//
	// See [method@Gtk.TextView.forward_display_line] for an explanation of
	// display lines vs. paragraphs.
	StartsDisplayLine(iter *TextIter) bool
	// WindowToBufferCoords converts coordinates on the window identified by
	// @win to buffer coordinates.
	WindowToBufferCoords(win TextWindowType, windowX int, windowY int) (bufferX int, bufferY int)
}

// textView implements the TextView class.
type textView struct {
	Widget
}

// WrapTextView wraps a GObject to the right type. It is
// primarily used internally.
func WrapTextView(obj *externglib.Object) TextView {
	return textView{
		Widget: WrapWidget(obj),
	}
}

func marshalTextView(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTextView(obj), nil
}

// NewTextView creates a new `GtkTextView`.
//
// If you don’t call [method@Gtk.TextView.set_buffer] before using the text
// view, an empty default buffer will be created for you. Get the buffer with
// [method@Gtk.TextView.get_buffer]. If you want to specify your own buffer,
// consider [ctor@Gtk.TextView.new_with_buffer].
func NewTextView() TextView {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_text_view_new()

	var _textView TextView // out

	_textView = WrapTextView(externglib.Take(unsafe.Pointer(_cret)))

	return _textView
}

// NewTextViewWithBuffer creates a new `GtkTextView` widget displaying the
// buffer @buffer.
//
// One buffer can be shared among many widgets. @buffer may be nil to create a
// default buffer, in which case this function is equivalent to
// [ctor@Gtk.TextView.new]. The text view adds its own reference count to the
// buffer; it does not take over an existing reference.
func NewTextViewWithBuffer(buffer TextBuffer) TextView {
	var _arg1 *C.GtkTextBuffer // out
	var _cret *C.GtkWidget     // in

	_arg1 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))

	_cret = C.gtk_text_view_new_with_buffer(_arg1)

	var _textView TextView // out

	_textView = WrapTextView(externglib.Take(unsafe.Pointer(_cret)))

	return _textView
}

func (t textView) AsAccessible() Accessible {
	return WrapAccessible(gextras.InternObject(t))
}

func (t textView) AsBuildable() Buildable {
	return WrapBuildable(gextras.InternObject(t))
}

func (t textView) AsConstraintTarget() ConstraintTarget {
	return WrapConstraintTarget(gextras.InternObject(t))
}

func (t textView) AsScrollable() Scrollable {
	return WrapScrollable(gextras.InternObject(t))
}

func (t textView) AddChildAtAnchor(child Widget, anchor TextChildAnchor) {
	var _arg0 *C.GtkTextView        // out
	var _arg1 *C.GtkWidget          // out
	var _arg2 *C.GtkTextChildAnchor // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.GtkTextChildAnchor)(unsafe.Pointer(anchor.Native()))

	C.gtk_text_view_add_child_at_anchor(_arg0, _arg1, _arg2)
}

func (t textView) AddOverlay(child Widget, xpos int, ypos int) {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkWidget   // out
	var _arg2 C.int          // out
	var _arg3 C.int          // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = C.int(xpos)
	_arg3 = C.int(ypos)

	C.gtk_text_view_add_overlay(_arg0, _arg1, _arg2, _arg3)
}

func (t textView) BackwardDisplayLine(iter *TextIter) bool {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter))

	_cret = C.gtk_text_view_backward_display_line(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t textView) BackwardDisplayLineStart(iter *TextIter) bool {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter))

	_cret = C.gtk_text_view_backward_display_line_start(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t textView) BufferToWindowCoords(win TextWindowType, bufferX int, bufferY int) (windowX int, windowY int) {
	var _arg0 *C.GtkTextView      // out
	var _arg1 C.GtkTextWindowType // out
	var _arg2 C.int               // out
	var _arg3 C.int               // out
	var _arg4 C.int               // in
	var _arg5 C.int               // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = C.GtkTextWindowType(win)
	_arg2 = C.int(bufferX)
	_arg3 = C.int(bufferY)

	C.gtk_text_view_buffer_to_window_coords(_arg0, _arg1, _arg2, _arg3, &_arg4, &_arg5)

	var _windowX int // out
	var _windowY int // out

	_windowX = int(_arg4)
	_windowY = int(_arg5)

	return _windowX, _windowY
}

func (t textView) ForwardDisplayLine(iter *TextIter) bool {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter))

	_cret = C.gtk_text_view_forward_display_line(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t textView) ForwardDisplayLineEnd(iter *TextIter) bool {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter))

	_cret = C.gtk_text_view_forward_display_line_end(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t textView) AcceptsTab() bool {
	var _arg0 *C.GtkTextView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_text_view_get_accepts_tab(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t textView) BottomMargin() int {
	var _arg0 *C.GtkTextView // out
	var _cret C.int          // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_text_view_get_bottom_margin(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

func (t textView) Buffer() TextBuffer {
	var _arg0 *C.GtkTextView   // out
	var _cret *C.GtkTextBuffer // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_text_view_get_buffer(_arg0)

	var _textBuffer TextBuffer // out

	_textBuffer = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TextBuffer)

	return _textBuffer
}

func (t textView) CursorLocations(iter *TextIter) (strong gdk.Rectangle, weak gdk.Rectangle) {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextIter // out
	var _arg2 C.GdkRectangle // in
	var _arg3 C.GdkRectangle // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter))

	C.gtk_text_view_get_cursor_locations(_arg0, _arg1, &_arg2, &_arg3)

	var _strong gdk.Rectangle // out
	var _weak gdk.Rectangle   // out

	{
		var refTmpIn *C.GdkRectangle
		var refTmpOut *gdk.Rectangle

		in0 := &_arg2
		refTmpIn = in0

		refTmpOut = (*gdk.Rectangle)(unsafe.Pointer(refTmpIn))

		_strong = *refTmpOut
	}
	{
		var refTmpIn *C.GdkRectangle
		var refTmpOut *gdk.Rectangle

		in0 := &_arg3
		refTmpIn = in0

		refTmpOut = (*gdk.Rectangle)(unsafe.Pointer(refTmpIn))

		_weak = *refTmpOut
	}

	return _strong, _weak
}

func (t textView) CursorVisible() bool {
	var _arg0 *C.GtkTextView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_text_view_get_cursor_visible(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t textView) Editable() bool {
	var _arg0 *C.GtkTextView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_text_view_get_editable(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t textView) ExtraMenu() gio.MenuModel {
	var _arg0 *C.GtkTextView // out
	var _cret *C.GMenuModel  // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_text_view_get_extra_menu(_arg0)

	var _menuModel gio.MenuModel // out

	_menuModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.MenuModel)

	return _menuModel
}

func (t textView) Gutter(win TextWindowType) Widget {
	var _arg0 *C.GtkTextView      // out
	var _arg1 C.GtkTextWindowType // out
	var _cret *C.GtkWidget        // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = C.GtkTextWindowType(win)

	_cret = C.gtk_text_view_get_gutter(_arg0, _arg1)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

func (t textView) Indent() int {
	var _arg0 *C.GtkTextView // out
	var _cret C.int          // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_text_view_get_indent(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

func (t textView) InputHints() InputHints {
	var _arg0 *C.GtkTextView  // out
	var _cret C.GtkInputHints // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_text_view_get_input_hints(_arg0)

	var _inputHints InputHints // out

	_inputHints = InputHints(_cret)

	return _inputHints
}

func (t textView) InputPurpose() InputPurpose {
	var _arg0 *C.GtkTextView    // out
	var _cret C.GtkInputPurpose // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_text_view_get_input_purpose(_arg0)

	var _inputPurpose InputPurpose // out

	_inputPurpose = InputPurpose(_cret)

	return _inputPurpose
}

func (t textView) IterAtLocation(x int, y int) (TextIter, bool) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.GtkTextIter  // in
	var _arg2 C.int          // out
	var _arg3 C.int          // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg2 = C.int(x)
	_arg3 = C.int(y)

	_cret = C.gtk_text_view_get_iter_at_location(_arg0, &_arg1, _arg2, _arg3)

	var _iter TextIter // out
	var _ok bool       // out

	{
		var refTmpIn *C.GtkTextIter
		var refTmpOut *TextIter

		in0 := &_arg1
		refTmpIn = in0

		refTmpOut = (*TextIter)(unsafe.Pointer(refTmpIn))

		_iter = *refTmpOut
	}
	if _cret != 0 {
		_ok = true
	}

	return _iter, _ok
}

func (t textView) IterAtPosition(x int, y int) (TextIter, int, bool) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.GtkTextIter  // in
	var _arg2 C.int          // in
	var _arg3 C.int          // out
	var _arg4 C.int          // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg3 = C.int(x)
	_arg4 = C.int(y)

	_cret = C.gtk_text_view_get_iter_at_position(_arg0, &_arg1, &_arg2, _arg3, _arg4)

	var _iter TextIter // out
	var _trailing int  // out
	var _ok bool       // out

	{
		var refTmpIn *C.GtkTextIter
		var refTmpOut *TextIter

		in0 := &_arg1
		refTmpIn = in0

		refTmpOut = (*TextIter)(unsafe.Pointer(refTmpIn))

		_iter = *refTmpOut
	}
	_trailing = int(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _iter, _trailing, _ok
}

func (t textView) IterLocation(iter *TextIter) gdk.Rectangle {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextIter // out
	var _arg2 C.GdkRectangle // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter))

	C.gtk_text_view_get_iter_location(_arg0, _arg1, &_arg2)

	var _location gdk.Rectangle // out

	{
		var refTmpIn *C.GdkRectangle
		var refTmpOut *gdk.Rectangle

		in0 := &_arg2
		refTmpIn = in0

		refTmpOut = (*gdk.Rectangle)(unsafe.Pointer(refTmpIn))

		_location = *refTmpOut
	}

	return _location
}

func (t textView) Justification() Justification {
	var _arg0 *C.GtkTextView     // out
	var _cret C.GtkJustification // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_text_view_get_justification(_arg0)

	var _justification Justification // out

	_justification = Justification(_cret)

	return _justification
}

func (t textView) LeftMargin() int {
	var _arg0 *C.GtkTextView // out
	var _cret C.int          // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_text_view_get_left_margin(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

func (t textView) LineAtY(y int) (TextIter, int) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.GtkTextIter  // in
	var _arg2 C.int          // out
	var _arg3 C.int          // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg2 = C.int(y)

	C.gtk_text_view_get_line_at_y(_arg0, &_arg1, _arg2, &_arg3)

	var _targetIter TextIter // out
	var _lineTop int         // out

	{
		var refTmpIn *C.GtkTextIter
		var refTmpOut *TextIter

		in0 := &_arg1
		refTmpIn = in0

		refTmpOut = (*TextIter)(unsafe.Pointer(refTmpIn))

		_targetIter = *refTmpOut
	}
	_lineTop = int(_arg3)

	return _targetIter, _lineTop
}

func (t textView) LineYrange(iter *TextIter) (y int, height int) {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextIter // out
	var _arg2 C.int          // in
	var _arg3 C.int          // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter))

	C.gtk_text_view_get_line_yrange(_arg0, _arg1, &_arg2, &_arg3)

	var _y int      // out
	var _height int // out

	_y = int(_arg2)
	_height = int(_arg3)

	return _y, _height
}

func (t textView) Monospace() bool {
	var _arg0 *C.GtkTextView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_text_view_get_monospace(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t textView) Overwrite() bool {
	var _arg0 *C.GtkTextView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_text_view_get_overwrite(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t textView) PixelsAboveLines() int {
	var _arg0 *C.GtkTextView // out
	var _cret C.int          // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_text_view_get_pixels_above_lines(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

func (t textView) PixelsBelowLines() int {
	var _arg0 *C.GtkTextView // out
	var _cret C.int          // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_text_view_get_pixels_below_lines(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

func (t textView) PixelsInsideWrap() int {
	var _arg0 *C.GtkTextView // out
	var _cret C.int          // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_text_view_get_pixels_inside_wrap(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

func (t textView) RightMargin() int {
	var _arg0 *C.GtkTextView // out
	var _cret C.int          // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_text_view_get_right_margin(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

func (t textView) Tabs() *pango.TabArray {
	var _arg0 *C.GtkTextView   // out
	var _cret *C.PangoTabArray // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_text_view_get_tabs(_arg0)

	var _tabArray *pango.TabArray // out

	_tabArray = (*pango.TabArray)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_tabArray, func(v *pango.TabArray) {
		C.free(unsafe.Pointer(v))
	})

	return _tabArray
}

func (t textView) TopMargin() int {
	var _arg0 *C.GtkTextView // out
	var _cret C.int          // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_text_view_get_top_margin(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

func (t textView) VisibleRect() gdk.Rectangle {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.GdkRectangle // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	C.gtk_text_view_get_visible_rect(_arg0, &_arg1)

	var _visibleRect gdk.Rectangle // out

	{
		var refTmpIn *C.GdkRectangle
		var refTmpOut *gdk.Rectangle

		in0 := &_arg1
		refTmpIn = in0

		refTmpOut = (*gdk.Rectangle)(unsafe.Pointer(refTmpIn))

		_visibleRect = *refTmpOut
	}

	return _visibleRect
}

func (t textView) WrapMode() WrapMode {
	var _arg0 *C.GtkTextView // out
	var _cret C.GtkWrapMode  // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_text_view_get_wrap_mode(_arg0)

	var _wrapMode WrapMode // out

	_wrapMode = WrapMode(_cret)

	return _wrapMode
}

func (t textView) ImContextFilterKeypress(event gdk.Event) bool {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GdkEvent    // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GdkEvent)(unsafe.Pointer(event.Native()))

	_cret = C.gtk_text_view_im_context_filter_keypress(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t textView) MoveMarkOnscreen(mark TextMark) bool {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextMark // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTextMark)(unsafe.Pointer(mark.Native()))

	_cret = C.gtk_text_view_move_mark_onscreen(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t textView) MoveOverlay(child Widget, xpos int, ypos int) {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkWidget   // out
	var _arg2 C.int          // out
	var _arg3 C.int          // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = C.int(xpos)
	_arg3 = C.int(ypos)

	C.gtk_text_view_move_overlay(_arg0, _arg1, _arg2, _arg3)
}

func (t textView) MoveVisually(iter *TextIter, count int) bool {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextIter // out
	var _arg2 C.int          // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter))
	_arg2 = C.int(count)

	_cret = C.gtk_text_view_move_visually(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t textView) PlaceCursorOnscreen() bool {
	var _arg0 *C.GtkTextView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	_cret = C.gtk_text_view_place_cursor_onscreen(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t textView) Remove(child Widget) {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkWidget   // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_text_view_remove(_arg0, _arg1)
}

func (t textView) ResetCursorBlink() {
	var _arg0 *C.GtkTextView // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	C.gtk_text_view_reset_cursor_blink(_arg0)
}

func (t textView) ResetImContext() {
	var _arg0 *C.GtkTextView // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

	C.gtk_text_view_reset_im_context(_arg0)
}

func (t textView) ScrollMarkOnscreen(mark TextMark) {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextMark // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTextMark)(unsafe.Pointer(mark.Native()))

	C.gtk_text_view_scroll_mark_onscreen(_arg0, _arg1)
}

func (t textView) ScrollToIter(iter *TextIter, withinMargin float64, useAlign bool, xalign float64, yalign float64) bool {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextIter // out
	var _arg2 C.double       // out
	var _arg3 C.gboolean     // out
	var _arg4 C.double       // out
	var _arg5 C.double       // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter))
	_arg2 = C.double(withinMargin)
	if useAlign {
		_arg3 = C.TRUE
	}
	_arg4 = C.double(xalign)
	_arg5 = C.double(yalign)

	_cret = C.gtk_text_view_scroll_to_iter(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t textView) ScrollToMark(mark TextMark, withinMargin float64, useAlign bool, xalign float64, yalign float64) {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextMark // out
	var _arg2 C.double       // out
	var _arg3 C.gboolean     // out
	var _arg4 C.double       // out
	var _arg5 C.double       // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTextMark)(unsafe.Pointer(mark.Native()))
	_arg2 = C.double(withinMargin)
	if useAlign {
		_arg3 = C.TRUE
	}
	_arg4 = C.double(xalign)
	_arg5 = C.double(yalign)

	C.gtk_text_view_scroll_to_mark(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
}

func (t textView) SetAcceptsTab(acceptsTab bool) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	if acceptsTab {
		_arg1 = C.TRUE
	}

	C.gtk_text_view_set_accepts_tab(_arg0, _arg1)
}

func (t textView) SetBottomMargin(bottomMargin int) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = C.int(bottomMargin)

	C.gtk_text_view_set_bottom_margin(_arg0, _arg1)
}

func (t textView) SetBuffer(buffer TextBuffer) {
	var _arg0 *C.GtkTextView   // out
	var _arg1 *C.GtkTextBuffer // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))

	C.gtk_text_view_set_buffer(_arg0, _arg1)
}

func (t textView) SetCursorVisible(setting bool) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_text_view_set_cursor_visible(_arg0, _arg1)
}

func (t textView) SetEditable(setting bool) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_text_view_set_editable(_arg0, _arg1)
}

func (t textView) SetExtraMenu(model gio.MenuModel) {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GMenuModel  // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GMenuModel)(unsafe.Pointer(model.Native()))

	C.gtk_text_view_set_extra_menu(_arg0, _arg1)
}

func (t textView) SetGutter(win TextWindowType, widget Widget) {
	var _arg0 *C.GtkTextView      // out
	var _arg1 C.GtkTextWindowType // out
	var _arg2 *C.GtkWidget        // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = C.GtkTextWindowType(win)
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

	C.gtk_text_view_set_gutter(_arg0, _arg1, _arg2)
}

func (t textView) SetIndent(indent int) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = C.int(indent)

	C.gtk_text_view_set_indent(_arg0, _arg1)
}

func (t textView) SetInputHints(hints InputHints) {
	var _arg0 *C.GtkTextView  // out
	var _arg1 C.GtkInputHints // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = C.GtkInputHints(hints)

	C.gtk_text_view_set_input_hints(_arg0, _arg1)
}

func (t textView) SetInputPurpose(purpose InputPurpose) {
	var _arg0 *C.GtkTextView    // out
	var _arg1 C.GtkInputPurpose // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = C.GtkInputPurpose(purpose)

	C.gtk_text_view_set_input_purpose(_arg0, _arg1)
}

func (t textView) SetJustification(justification Justification) {
	var _arg0 *C.GtkTextView     // out
	var _arg1 C.GtkJustification // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = C.GtkJustification(justification)

	C.gtk_text_view_set_justification(_arg0, _arg1)
}

func (t textView) SetLeftMargin(leftMargin int) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = C.int(leftMargin)

	C.gtk_text_view_set_left_margin(_arg0, _arg1)
}

func (t textView) SetMonospace(monospace bool) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	if monospace {
		_arg1 = C.TRUE
	}

	C.gtk_text_view_set_monospace(_arg0, _arg1)
}

func (t textView) SetOverwrite(overwrite bool) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	if overwrite {
		_arg1 = C.TRUE
	}

	C.gtk_text_view_set_overwrite(_arg0, _arg1)
}

func (t textView) SetPixelsAboveLines(pixelsAboveLines int) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = C.int(pixelsAboveLines)

	C.gtk_text_view_set_pixels_above_lines(_arg0, _arg1)
}

func (t textView) SetPixelsBelowLines(pixelsBelowLines int) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = C.int(pixelsBelowLines)

	C.gtk_text_view_set_pixels_below_lines(_arg0, _arg1)
}

func (t textView) SetPixelsInsideWrap(pixelsInsideWrap int) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = C.int(pixelsInsideWrap)

	C.gtk_text_view_set_pixels_inside_wrap(_arg0, _arg1)
}

func (t textView) SetRightMargin(rightMargin int) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = C.int(rightMargin)

	C.gtk_text_view_set_right_margin(_arg0, _arg1)
}

func (t textView) SetTabs(tabs *pango.TabArray) {
	var _arg0 *C.GtkTextView   // out
	var _arg1 *C.PangoTabArray // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.PangoTabArray)(unsafe.Pointer(tabs))

	C.gtk_text_view_set_tabs(_arg0, _arg1)
}

func (t textView) SetTopMargin(topMargin int) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = C.int(topMargin)

	C.gtk_text_view_set_top_margin(_arg0, _arg1)
}

func (t textView) SetWrapMode(wrapMode WrapMode) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.GtkWrapMode  // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = C.GtkWrapMode(wrapMode)

	C.gtk_text_view_set_wrap_mode(_arg0, _arg1)
}

func (t textView) StartsDisplayLine(iter *TextIter) bool {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter))

	_cret = C.gtk_text_view_starts_display_line(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t textView) WindowToBufferCoords(win TextWindowType, windowX int, windowY int) (bufferX int, bufferY int) {
	var _arg0 *C.GtkTextView      // out
	var _arg1 C.GtkTextWindowType // out
	var _arg2 C.int               // out
	var _arg3 C.int               // out
	var _arg4 C.int               // in
	var _arg5 C.int               // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
	_arg1 = C.GtkTextWindowType(win)
	_arg2 = C.int(windowX)
	_arg3 = C.int(windowY)

	C.gtk_text_view_window_to_buffer_coords(_arg0, _arg1, _arg2, _arg3, &_arg4, &_arg5)

	var _bufferX int // out
	var _bufferY int // out

	_bufferX = int(_arg4)
	_bufferY = int(_arg5)

	return _bufferX, _bufferY
}
