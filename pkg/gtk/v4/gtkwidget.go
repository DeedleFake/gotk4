// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"reflect"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/internal/box"
	"github.com/diamondburned/gotk4/internal/gextras"
	"github.com/diamondburned/gotk4/pkg/cairo"
	"github.com/diamondburned/gotk4/pkg/gdk/v4"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
	"github.com/diamondburned/gotk4/pkg/graphene"
	"github.com/diamondburned/gotk4/pkg/gsk/v4"
	"github.com/diamondburned/gotk4/pkg/pango"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gtk4
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <stdbool.h>
// #include <gtk/gtk.h>
//
// extern gboolean gotk4_TickCallback(GtkWidget* _0, GdkFrameClock* _1, gpointer _2);
// extern void callbackDelete(gpointer);
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_requisition_get_type()), F: marshalRequisition},
		{T: externglib.Type(C.gtk_widget_get_type()), F: marshalWidget},
	})
}

//export callbackDelete
func callbackDelete(ptr C.gpointer) {
	box.Delete(box.Callback, uintptr(ptr))
}

// Allocation: the rectangle representing the area allocated for a widget by its
// parent.
type Allocation gdk.Rectangle

// TickCallback: callback type for adding a function to update animations. See
// gtk_widget_add_tick_callback().
type TickCallback func(widget Widget, frameClock gdk.FrameClock) bool

//export gotk4_TickCallback
func gotk4_TickCallback(arg0 *C.GtkWidget, arg1 *C.GdkFrameClock, arg2 C.gpointer) C.gboolean {
	v := box.Get(uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var widget Widget
	var frameClock gdk.FrameClock

	widget = gextras.CastObject(externglib.Take(unsafe.Pointer(arg0.Native()))).(Widget)

	frameClock = gextras.CastObject(externglib.Take(unsafe.Pointer(arg1.Native()))).(gdk.FrameClock)

	ok := v.(TickCallback)(widget, frameClock)
}

// Requisition: a Requisition-struct represents the desired size of a widget.
// See [GtkWidget’s geometry management section][geometry-management] for more
// information.
type Requisition struct {
	native C.GtkRequisition
}

// WrapRequisition wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapRequisition(ptr unsafe.Pointer) *Requisition {
	if ptr == nil {
		return nil
	}

	return (*Requisition)(ptr)
}

func marshalRequisition(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapRequisition(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (r *Requisition) Native() unsafe.Pointer {
	return unsafe.Pointer(&r.native)
}

// NewRequisition constructs a struct Requisition.
func NewRequisition() *Requisition {
	ret := C.gtk_requisition_new()

	var ret0 *Requisition

	{
		ret0 = WrapRequisition(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *Requisition) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Width gets the field inside the struct.
func (r *Requisition) Width() int {
	var ret int
	ret = int(r.native.width)
	return ret
}

// Height gets the field inside the struct.
func (r *Requisition) Height() int {
	var ret int
	ret = int(r.native.height)
	return ret
}

// Copy copies a `GtkRequisition`.
func (r *Requisition) Copy() *Requisition {
	var arg0 *C.GtkRequisition

	arg0 = (*C.GtkRequisition)(r.Native())

	ret := C.gtk_requisition_copy(arg0)

	var ret0 *Requisition

	{
		ret0 = WrapRequisition(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *Requisition) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Free frees a `GtkRequisition`.
func (r *Requisition) Free() {
	var arg0 *C.GtkRequisition

	arg0 = (*C.GtkRequisition)(r.Native())

	C.gtk_requisition_free(arg0)
}

type WidgetClassPrivate struct {
	native C.GtkWidgetClassPrivate
}

// WrapWidgetClassPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapWidgetClassPrivate(ptr unsafe.Pointer) *WidgetClassPrivate {
	if ptr == nil {
		return nil
	}

	return (*WidgetClassPrivate)(ptr)
}

func marshalWidgetClassPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapWidgetClassPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (w *WidgetClassPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&w.native)
}

type WidgetPrivate struct {
	native C.GtkWidgetPrivate
}

// WrapWidgetPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapWidgetPrivate(ptr unsafe.Pointer) *WidgetPrivate {
	if ptr == nil {
		return nil
	}

	return (*WidgetPrivate)(ptr)
}

func marshalWidgetPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapWidgetPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (w *WidgetPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&w.native)
}

// Widget: the base class for all widgets.
//
// `GtkWidget` is the base class all widgets in GTK derive from. It manages the
// widget lifecycle, layout, states and style.
//
//
// Height-for-width Geometry Management
//
// GTK uses a height-for-width (and width-for-height) geometry management
// system. Height-for-width means that a widget can change how much vertical
// space it needs, depending on the amount of horizontal space that it is given
// (and similar for width-for-height). The most common example is a label that
// reflows to fill up the available width, wraps to fewer lines, and therefore
// needs less height.
//
// Height-for-width geometry management is implemented in GTK by way of two
// virtual methods:
//
// - [vfunc@Gtk.Widget.get_request_mode] - [vfunc@Gtk.Widget.measure]
//
// There are some important things to keep in mind when implementing
// height-for-width and when using it in widget implementations.
//
// If you implement a direct `GtkWidget` subclass that supports height-for-width
// or width-for-height geometry management for itself or its child widgets, the
// [vfunc@Gtk.Widget.get_request_mode] virtual function must be implemented as
// well and return the widget's preferred request mode. The default
// implementation of this virtual function returns
// GTK_SIZE_REQUEST_CONSTANT_SIZE, which means that the widget will only ever
// get -1 passed as the for_size value to its [vfunc@Gtk.Widget.measure]
// implementation.
//
// The geometry management system will query a widget hierarchy in only one
// orientation at a time. When widgets are initially queried for their minimum
// sizes it is generally done in two initial passes in the
// [enum@Gtk.SizeRequestMode] chosen by the toplevel.
//
// For example, when queried in the normal GTK_SIZE_REQUEST_HEIGHT_FOR_WIDTH
// mode:
//
// First, the default minimum and natural width for each widget in the interface
// will be computed using [id@gtk_widget_measure] with an orientation of
// GTK_ORIENTATION_HORIZONTAL and a for_size of -1. Because the preferred widths
// for each widget depend on the preferred widths of their children, this
// information propagates up the hierarchy, and finally a minimum and natural
// width is determined for the entire toplevel. Next, the toplevel will use the
// minimum width to query for the minimum height contextual to that width using
// [id@gtk_widget_measure] with an orientation of GTK_ORIENTATION_VERTICAL and a
// for_size of the just computed width. This will also be a highly recursive
// operation. The minimum height for the minimum width is normally used to set
// the minimum size constraint on the toplevel.
//
// After the toplevel window has initially requested its size in both dimensions
// it can go on to allocate itself a reasonable size (or a size previously
// specified with [method@Gtk.Window.set_default_size]). During the recursive
// allocation process it’s important to note that request cycles will be
// recursively executed while widgets allocate their children. Each widget, once
// allocated a size, will go on to first share the space in one orientation
// among its children and then request each child's height for its target
// allocated width or its width for allocated height, depending. In this way a
// `GtkWidget` will typically be requested its size a number of times before
// actually being allocated a size. The size a widget is finally allocated can
// of course differ from the size it has requested. For this reason, `GtkWidget`
// caches a small number of results to avoid re-querying for the same sizes in
// one allocation cycle.
//
// If a widget does move content around to intelligently use up the allocated
// size then it must support the request in both `GtkSizeRequestMode`s even if
// the widget in question only trades sizes in a single orientation.
//
// For instance, a [class@Gtk.Label] that does height-for-width word wrapping
// will not expect to have [vfunc@Gtk.Widget.measure] with an orientation of
// GTK_ORIENTATION_VERTICAL called because that call is specific to a
// width-for-height request. In this case the label must return the height
// required for its own minimum possible width. By following this rule any
// widget that handles height-for-width or width-for-height requests will always
// be allocated at least enough space to fit its own content.
//
// Here are some examples of how a GTK_SIZE_REQUEST_HEIGHT_FOR_WIDTH widget
// generally deals with width-for-height requests:
//
// “`c static void foo_widget_measure (GtkWidget *widget, GtkOrientation
// orientation, int for_size, int *minimum_size, int *natural_size, int
// *minimum_baseline, int *natural_baseline) { if (orientation ==
// GTK_ORIENTATION_HORIZONTAL) { // Calculate minimum and natural width } else
// // VERTICAL { if (i_am_in_height_for_width_mode) { int min_width, dummy;
//
//          // First, get the minimum width of our widget
//          GTK_WIDGET_GET_CLASS (widget)->measure (widget, GTK_ORIENTATION_HORIZONTAL, -1,
//                                                  &min_width, &dummy, &dummy, &dummy);
//
//          // Now use the minimum width to retrieve the minimum and natural height to display
//          // that width.
//          GTK_WIDGET_GET_CLASS (widget)->measure (widget, GTK_ORIENTATION_VERTICAL, min_width,
//                                                  minimum_size, natural_size, &dummy, &dummy);
//        }
//      else
//        {
//          // ... some widgets do both.
//        }
//    }
//
// } “`
//
// Often a widget needs to get its own request during size request or
// allocation. For example, when computing height it may need to also compute
// width. Or when deciding how to use an allocation, the widget may need to know
// its natural size. In these cases, the widget should be careful to call its
// virtual methods directly, like in the code example above.
//
// It will not work to use the wrapper function [method@Gtk.Widget.measure]
// inside your own [vfunc@Gtk.Widget.size_allocate] implementation. These return
// a request adjusted by [class@Gtk.SizeGroup], the widget's align and expand
// flags, as well as its CSS style.
//
// If a widget used the wrappers inside its virtual method implementations, then
// the adjustments (such as widget margins) would be applied twice. GTK
// therefore does not allow this and will warn if you try to do it.
//
// Of course if you are getting the size request for another widget, such as a
// child widget, you must use [id@gtk_widget_measure]; otherwise, you would not
// properly consider widget margins, [class@Gtk.SizeGroup], and so forth.
//
// GTK also supports baseline vertical alignment of widgets. This means that
// widgets are positioned such that the typographical baseline of widgets in the
// same row are aligned. This happens if a widget supports baselines, has a
// vertical alignment of GTK_ALIGN_BASELINE, and is inside a widget that
// supports baselines and has a natural “row” that it aligns to the baseline, or
// a baseline assigned to it by the grandparent.
//
// Baseline alignment support for a widget is also done by the
// [vfunc@Gtk.Widget.measure] virtual function. It allows you to report both a
// minimum and natural size.
//
// If a widget ends up baseline aligned it will be allocated all the space in
// the parent as if it was GTK_ALIGN_FILL, but the selected baseline can be
// found via [id@gtk_widget_get_allocated_baseline]. If the baseline has a value
// other than -1 you need to align the widget such that the baseline appears at
// the position.
//
//
// GtkWidget as GtkBuildable
//
// The `GtkWidget` implementation of the `GtkBuildable` interface supports
// various custom elements to specify additional aspects of widgets that are not
// directly expressed as properties.
//
// If the widget uses a [class@Gtk.LayoutManager], `GtkWidget` supports a custom
// `<layout>` element, used to define layout properties:
//
// “`xml <object class="GtkGrid" id="my_grid"> <child> <object class="GtkLabel"
// id="label1"> <property name="label">Description</property> <layout> <property
// name="column">0</property> <property name="row">0</property> <property
// name="row-span">1</property> <property name="column-span">1</property>
// </layout> </object> </child> <child> <object class="GtkEntry"
// id="description_entry"> <layout> <property name="column">1</property>
// <property name="row">0</property> <property name="row-span">1</property>
// <property name="column-span">1</property> </layout> </object> </child>
// </object> “`
//
// `GtkWidget` allows style information such as style classes to be associated
// with widgets, using the custom `<style>` element:
//
// “`xml <object class="GtkButton" id="button1"> <style> <class
// name="my-special-button-class"/> <class name="dark-button"/> </style>
// </object> “`
//
// `GtkWidget` allows defining accessibility information, such as properties,
// relations, and states, using the custom `<accessibility>` element:
//
// “`xml <object class="GtkButton" id="button1"> <accessibility> <property
// name="label">Download</property> <relation
// name="labelled-by">label1</relation> </accessibility> </object> “`
//
//
// Building composite widgets from template XML
//
// `GtkWidget `exposes some facilities to automate the procedure of creating
// composite widgets using "templates".
//
// To create composite widgets with `GtkBuilder` XML, one must associate the
// interface description with the widget class at class initialization time
// using [method@Gtk.WidgetClass.set_template].
//
// The interface description semantics expected in composite template
// descriptions is slightly different from regular [class@Gtk.Builder] XML.
//
// Unlike regular interface descriptions, [method@Gtk.WidgetClass.set_template]
// will expect a `<template>` tag as a direct child of the toplevel
// `<interface>` tag. The `<template>` tag must specify the “class” attribute
// which must be the type name of the widget. Optionally, the “parent” attribute
// may be specified to specify the direct parent type of the widget type, this
// is ignored by `GtkBuilder` but required for UI design tools like Glade
// (https://glade.gnome.org/) to introspect what kind of properties and internal
// children exist for a given type when the actual type does not exist.
//
// The XML which is contained inside the `<template>` tag behaves as if it were
// added to the `<object>` tag defining the widget itself. You may set
// properties on a widget by inserting `<property>` tags into the `<template>`
// tag, and also add `<child>` tags to add children and extend a widget in the
// normal way you would with `<object>` tags.
//
// Additionally, `<object>` tags can also be added before and after the initial
// `<template>` tag in the normal way, allowing one to define auxiliary objects
// which might be referenced by other widgets declared as children of the
// `<template>` tag.
//
// An example of a template definition:
//
// “`xml <interface> <template class="FooWidget" parent="GtkBox"> <property
// name="orientation">horizontal</property> <property
// name="spacing">4</property> <child> <object class="GtkButton"
// id="hello_button"> <property name="label">Hello World</property> <signal
// name="clicked" handler="hello_button_clicked" object="FooWidget"
// swapped="yes"/> </object> </child> <child> <object class="GtkButton"
// id="goodbye_button"> <property name="label">Goodbye World</property>
// </object> </child> </template> </interface> “`
//
// Typically, you'll place the template fragment into a file that is bundled
// with your project, using `GResource`. In order to load the template, you need
// to call [method@Gtk.WidgetClass.set_template_from_resource] from the class
// initialization of your `GtkWidget` type:
//
// “`c static void foo_widget_class_init (FooWidgetClass *klass) { // ...
//
//    gtk_widget_class_set_template_from_resource (GTK_WIDGET_CLASS (klass),
//                                                 "/com/example/ui/foowidget.ui");
//
// } “`
//
// You will also need to call [method@Gtk.Widget.init_template] from the
// instance initialization function:
//
// “`c static void foo_widget_init (FooWidget *self) { // ...
// gtk_widget_init_template (GTK_WIDGET (self)); } “`
//
// You can access widgets defined in the template using the
// [id@gtk_widget_get_template_child] function, but you will typically declare a
// pointer in the instance private data structure of your type using the same
// name as the widget in the template definition, and call
// [method@Gtk.WidgetClass.bind_template_child_full] (or one of its wrapper
// macros [func@Gtk.widget_class_bind_template_child] and
// [func@Gtk.widget_class_bind_template_child_private]) with that name, e.g.
//
// “`c typedef struct { GtkWidget *hello_button; GtkWidget *goodbye_button; }
// FooWidgetPrivate;
//
// G_DEFINE_TYPE_WITH_PRIVATE (FooWidget, foo_widget, GTK_TYPE_BOX)
//
// static void foo_widget_class_init (FooWidgetClass *klass) { // ...
// gtk_widget_class_set_template_from_resource (GTK_WIDGET_CLASS (klass),
// "/com/example/ui/foowidget.ui"); gtk_widget_class_bind_template_child_private
// (GTK_WIDGET_CLASS (klass), FooWidget, hello_button);
// gtk_widget_class_bind_template_child_private (GTK_WIDGET_CLASS (klass),
// FooWidget, goodbye_button); }
//
// static void foo_widget_init (FooWidget *widget) {
//
// } “`
//
// You can also use [method@Gtk.WidgetClass.bind_template_callback_full] (or is
// wrapper macro [func@Gtk.widget_class_bind_template_callback]) to connect a
// signal callback defined in the template with a function visible in the scope
// of the class, e.g.
//
// “`c // the signal handler has the instance and user data swapped // because
// of the swapped="yes" attribute in the template XML static void
// hello_button_clicked (FooWidget *self, GtkButton *button) { g_print ("Hello,
// world!\n"); }
//
// static void foo_widget_class_init (FooWidgetClass *klass) { // ...
// gtk_widget_class_set_template_from_resource (GTK_WIDGET_CLASS (klass),
// "/com/example/ui/foowidget.ui"); gtk_widget_class_bind_template_callback
// (GTK_WIDGET_CLASS (klass), hello_button_clicked); } “`
type Widget interface {
	gextras.Objector
	Accessible
	Buildable
	ConstraintTarget

	// ActionSetEnabled: enable or disable an action installed with
	// gtk_widget_class_install_action().
	ActionSetEnabled(actionName string, enabled bool)
	// Activate: for widgets that can be “activated” (buttons, menu items, etc.)
	// this function activates them.
	//
	// The activation will emit the signal set using
	// gtk_widget_class_set_activate_signal() during class initialization.
	//
	// Activation is what happens when you press Enter on a widget during key
	// navigation.
	//
	// If you wish to handle the activation keybinding yourself, it is
	// recommended to use gtk_widget_class_add_shortcut() with an action created
	// with gtk_signal_action_new().
	//
	// If @widget isn't activatable, the function returns false.
	Activate() bool
	// ActivateActionVariant looks up the action in the action groups associated
	// with @widget and its ancestors, and activates it.
	//
	// If the action is in an action group added with
	// [method@Gtk.Widget.insert_action_group], the @name is expected to be
	// prefixed with the prefix that was used when the group was inserted.
	//
	// The arguments must match the actions expected parameter type, as returned
	// by `g_action_get_parameter_type()`.
	ActivateActionVariant(name string, args *glib.Variant) bool
	// ActivateDefault activates the `default.activate` action from @widget.
	ActivateDefault()
	// AddController adds @controller to @widget so that it will receive events.
	//
	// You will usually want to call this function right after creating any kind
	// of [class@Gtk.EventController].
	AddController(controller EventController)
	// AddCSSClass adds a style class to @widget.
	//
	// After calling this function, the widgets style will match for @css_class,
	// according to CSS matching rules.
	//
	// Use [method@Gtk.Widget.remove_css_class] to remove the style again.
	AddCSSClass(cssClass string)
	// AddMnemonicLabel adds a widget to the list of mnemonic labels for this
	// widget.
	//
	// See [method@Gtk.Widget.list_mnemonic_labels]. Note the list of mnemonic
	// labels for the widget is cleared when the widget is destroyed, so the
	// caller must make sure to update its internal state at this point as well,
	// by using a connection to the [signal@Gtk.Widget::destroy] signal or a
	// weak notifier.
	AddMnemonicLabel(label Widget)
	// AddTickCallback queues an animation frame update and adds a callback to
	// be called before each frame.
	//
	// Until the tick callback is removed, it will be called frequently (usually
	// at the frame rate of the output device or as quickly as the application
	// can be repainted, whichever is slower). For this reason, is most suitable
	// for handling graphics that change every frame or every few frames. The
	// tick callback does not automatically imply a relayout or repaint. If you
	// want a repaint or relayout, and aren’t changing widget properties that
	// would trigger that (for example, changing the text of a Label), then you
	// will have to call [method@Gtk.Widget.queue_resize] or
	// [method@Gtk.Widget.queue_draw] yourself.
	//
	// [method@Gdk.FrameClock.get_frame_time] should generally be used for
	// timing continuous animations and
	// [method@Gdk.FrameTimings.get_predicted_presentation_time] if you are
	// trying to display isolated frames at particular times.
	//
	// This is a more convenient alternative to connecting directly to the
	// [signal@Gdk.FrameClock::update] signal of `GdkFrameClock`, since you
	// don't have to worry about when a `GdkFrameClock` is assigned to a widget.
	AddTickCallback(callback TickCallback) uint
	// Allocate: this function is only used by `GtkWidget` subclasses, to assign
	// a size, position and (optionally) baseline to their child widgets.
	//
	// In this function, the allocation and baseline may be adjusted. The given
	// allocation will be forced to be bigger than the widget's minimum size, as
	// well as at least 0×0 in size.
	//
	// For a version that does not take a transform, see
	// [method@Gtk.Widget.size_allocate].
	Allocate(width int, height int, baseline int, transform *gsk.Transform)
	// ChildFocus: called by widgets as the user moves around the window using
	// keyboard shortcuts.
	//
	// The @direction argument indicates what kind of motion is taking place
	// (up, down, left, right, tab forward, tab backward).
	//
	// This function calls the [vfunc@Gtk.Widget.focus] virtual function;
	// widgets can override the virtual function in order to implement
	// appropriate focus behavior.
	//
	// The default `focus()` virtual function for a widget should return `TRUE`
	// if moving in @direction left the focus on a focusable location inside
	// that widget, and `FALSE` if moving in @direction moved the focus outside
	// the widget. When returning `TRUE`, widgets normallycall
	// [method@Gtk.Widget.grab_focus] to place the focus accordingly; when
	// returning `FALSE`, they don’t modify the current focus location.
	//
	// This function is used by custom widget implementations; if you're writing
	// an app, you’d use [method@Gtk.Widget.grab_focus] to move the focus to a
	// particular widget.
	ChildFocus(direction DirectionType) bool
	// ComputeBounds computes the bounds for @widget in the coordinate space of
	// @target.
	//
	// FIXME: Explain what "bounds" are.
	//
	// If the operation is successful, true is returned. If @widget has no
	// bounds or the bounds cannot be expressed in @target's coordinate space
	// (for example if both widgets are in different windows), false is returned
	// and @bounds is set to the zero rectangle.
	//
	// It is valid for @widget and @target to be the same widget.
	ComputeBounds(target Widget) (outBounds graphene.Rect, ok bool)
	// ComputeExpand computes whether a container should give this widget extra
	// space when possible.
	//
	// Containers should check this, rather than looking at
	// [method@Gtk.Widget.get_hexpand] or [method@Gtk.Widget.get_vexpand].
	//
	// This function already checks whether the widget is visible, so visibility
	// does not need to be checked separately. Non-visible widgets are not
	// expanded.
	//
	// The computed expand value uses either the expand setting explicitly set
	// on the widget itself, or, if none has been explicitly set, the widget may
	// expand if some of its children do.
	ComputeExpand(orientation Orientation) bool
	// ComputePoint translates the given @point in @widget's coordinates to
	// coordinates relative to @target’s coordinate system.
	//
	// In order to perform this operation, both widgets must share a common
	// ancestor.
	ComputePoint(target Widget, point *graphene.Point) (outPoint graphene.Point, ok bool)
	// ComputeTransform computes a matrix suitable to describe a transformation
	// from @widget's coordinate system into @target's coordinate system.
	ComputeTransform(target Widget) (outTransform graphene.Matrix, ok bool)
	// Contains tests if the point at (@x, @y) is contained in @widget.
	//
	// The coordinates for (@x, @y) must be in widget coordinates, so (0, 0) is
	// assumed to be the top left of @widget's content area.
	Contains(x float64, y float64) bool
	// CreatePangoContext creates a new `PangoContext` with the appropriate font
	// map, font options, font description, and base direction for drawing text
	// for this widget.
	//
	// See also [method@Gtk.Widget.get_pango_context].
	CreatePangoContext() pango.Context
	// CreatePangoLayout creates a new `PangoLayout` with the appropriate font
	// map, font description, and base direction for drawing text for this
	// widget.
	//
	// If you keep a `PangoLayout` created in this way around, you need to
	// re-create it when the widget `PangoContext` is replaced. This can be
	// tracked by listening to changes of the [property@Gtk.Widget:root]
	// property on the widget.
	CreatePangoLayout(text string) pango.Layout
	// DragCheckThreshold checks to see if a drag movement has passed the GTK
	// drag threshold.
	DragCheckThreshold(startX int, startY int, currentX int, currentY int) bool
	// ErrorBell notifies the user about an input-related error on this widget.
	//
	// If the [property@Gtk.Settings:gtk-error-bell] setting is true, it calls
	// [method@Gdk.Surface.beep], otherwise it does nothing.
	//
	// Note that the effect of [method@Gdk.Surface.beep] can be configured in
	// many ways, depending on the windowing backend and the desktop environment
	// or window manager that is used.
	ErrorBell()
	// AllocatedBaseline returns the baseline that has currently been allocated
	// to @widget.
	//
	// This function is intended to be used when implementing handlers for the
	// `GtkWidget`Class.snapshot() function, and when allocating child widgets
	// in `GtkWidget`Class.size_allocate().
	AllocatedBaseline() int
	// AllocatedHeight returns the height that has currently been allocated to
	// @widget.
	AllocatedHeight() int
	// AllocatedWidth returns the width that has currently been allocated to
	// @widget.
	AllocatedWidth() int
	// Allocation retrieves the widget’s allocation.
	//
	// Note, when implementing a layout container: a widget’s allocation will be
	// its “adjusted” allocation, that is, the widget’s parent typically calls
	// [method@Gtk.Widget.size_allocate] with an allocation, and that allocation
	// is then adjusted (to handle margin and alignment for example) before
	// assignment to the widget. [method@Gtk.Widget.get_allocation] returns the
	// adjusted allocation that was actually assigned to the widget. The
	// adjusted allocation is guaranteed to be completely contained within the
	// [method@Gtk.Widget.size_allocate] allocation, however.
	//
	// So a layout container is guaranteed that its children stay inside the
	// assigned bounds, but not that they have exactly the bounds the container
	// assigned.
	Allocation() Allocation
	// Ancestor gets the first ancestor of @widget with type @widget_type.
	//
	// For example, `gtk_widget_get_ancestor (widget, GTK_TYPE_BOX)` gets the
	// first `GtkBox` that’s an ancestor of @widget. No reference will be added
	// to the returned widget; it should not be unreferenced.
	//
	// Note that unlike [method@Gtk.Widget.is_ancestor], this function considers
	// @widget to be an ancestor of itself.
	Ancestor(widgetType externglib.Type) Widget
	// CanFocus determines whether the input focus can enter @widget or any of
	// its children.
	//
	// See [method@Gtk.Widget.set_focusable].
	CanFocus() bool
	// CanTarget queries whether @widget can be the target of pointer events.
	CanTarget() bool
	// ChildVisible gets the value set with gtk_widget_set_child_visible().
	//
	// If you feel a need to use this function, your code probably needs
	// reorganization.
	//
	// This function is only useful for container implementations and should
	// never be called by an application.
	ChildVisible() bool
	// Clipboard gets the clipboard object for @widget.
	//
	// This is a utility function to get the clipboard object for the
	// `GdkDisplay` that @widget is using.
	//
	// Note that this function always works, even when @widget is not realized
	// yet.
	Clipboard() gdk.Clipboard
	// CSSClasses returns the list of style classes applied to @widget.
	CSSClasses() []string
	// CSSName returns the CSS name that is used for @self.
	CSSName() string
	// Cursor queries the cursor set on @widget.
	//
	// See [method@Gtk.Widget.set_cursor] for details.
	Cursor() gdk.Cursor
	// Direction gets the reading direction for a particular widget.
	//
	// See [method@Gtk.Widget.set_direction].
	Direction() TextDirection
	// Display: get the `GdkDisplay` for the toplevel window associated with
	// this widget.
	//
	// This function can only be called after the widget has been added to a
	// widget hierarchy with a `GtkWindow` at the top.
	//
	// In general, you should only create display specific resources when a
	// widget has been realized, and you should free those resources when the
	// widget is unrealized.
	Display() gdk.Display
	// FirstChild returns the widgets first child.
	//
	// This API is primarily meant for widget implementations.
	FirstChild() Widget
	// FocusChild returns the current focus child of @widget.
	FocusChild() Widget
	// FocusOnClick returns whether the widget should grab focus when it is
	// clicked with the mouse.
	//
	// See [method@Gtk.Widget.set_focus_on_click].
	FocusOnClick() bool
	// Focusable determines whether @widget can own the input focus.
	//
	// See [method@Gtk.Widget.set_focusable].
	Focusable() bool
	// FontMap gets the font map of @widget.
	//
	// See [method@Gtk.Widget.set_font_map].
	FontMap() pango.FontMap
	// FontOptions returns the `cairo_font_options_t` used for Pango rendering.
	//
	// When not set, the defaults font options for the `GdkDisplay` will be
	// used.
	FontOptions() *cairo.FontOptions
	// FrameClock obtains the frame clock for a widget.
	//
	// The frame clock is a global “ticker” that can be used to drive animations
	// and repaints. The most common reason to get the frame clock is to call
	// [method@Gdk.FrameClock.get_frame_time], in order to get a time to use for
	// animating. For example you might record the start of the animation with
	// an initial value from [method@Gdk.FrameClock.get_frame_time], and then
	// update the animation by calling [method@Gdk.FrameClock.get_frame_time]
	// again during each repaint.
	//
	// [method@Gdk.FrameClock.request_phase] will result in a new frame on the
	// clock, but won’t necessarily repaint any widgets. To repaint a widget,
	// you have to use [method@Gtk.Widget.queue_draw] which invalidates the
	// widget (thus scheduling it to receive a draw on the next frame).
	// gtk_widget_queue_draw() will also end up requesting a frame on the
	// appropriate frame clock.
	//
	// A widget’s frame clock will not change while the widget is mapped.
	// Reparenting a widget (which implies a temporary unmap) can change the
	// widget’s frame clock.
	//
	// Unrealized widgets do not have a frame clock.
	FrameClock() gdk.FrameClock
	// Halign gets the horizontal alignment of @widget.
	//
	// For backwards compatibility reasons this method will never return
	// GTK_ALIGN_BASELINE, but instead it will convert it to GTK_ALIGN_FILL.
	// Baselines are not supported for horizontal alignment.
	Halign() Align
	// HasTooltip returns the current value of the `has-tooltip` property.
	HasTooltip() bool
	// Height returns the content height of the widget.
	//
	// This function returns the size passed to its size-allocate
	// implementation, which is the size you should be using in
	// GtkWidgetClass.snapshot().
	//
	// For pointer events, see [method@Gtk.Widget.contains].
	Height() int
	// Hexpand gets whether the widget would like any available extra horizontal
	// space.
	//
	// When a user resizes a `GtkWindow`, widgets with expand=TRUE generally
	// receive the extra space. For example, a list or scrollable area or
	// document in your window would often be set to expand.
	//
	// Containers should use [method@Gtk.Widget.compute_expand] rather than this
	// function, to see whether a widget, or any of its children, has the expand
	// flag set. If any child of a widget wants to expand, the parent may ask to
	// expand also.
	//
	// This function only looks at the widget’s own hexpand flag, rather than
	// computing whether the entire widget tree rooted at this widget wants to
	// expand.
	Hexpand() bool
	// HexpandSet gets whether gtk_widget_set_hexpand() has been used to
	// explicitly set the expand flag on this widget.
	//
	// If [property@Gtk.Widget:hexpand] property is set, then it overrides any
	// computed expand value based on child widgets. If `hexpand` is not set,
	// then the expand value depends on whether any children of the widget would
	// like to expand.
	//
	// There are few reasons to use this function, but it’s here for
	// completeness and consistency.
	HexpandSet() bool
	// LastChild returns the widgets last child.
	//
	// This API is primarily meant for widget implementations.
	LastChild() Widget
	// LayoutManager retrieves the layout manager used by @widget
	//
	// See [method@Gtk.Widget.set_layout_manager].
	LayoutManager() LayoutManager
	// Mapped: whether the widget is mapped.
	Mapped() bool
	// MarginBottom gets the bottom margin of @widget.
	MarginBottom() int
	// MarginEnd gets the end margin of @widget.
	MarginEnd() int
	// MarginStart gets the start margin of @widget.
	MarginStart() int
	// MarginTop gets the top margin of @widget.
	MarginTop() int
	// Name retrieves the name of a widget.
	//
	// See [method@Gtk.Widget.set_name] for the significance of widget names.
	Name() string
	// Native returns the `GtkNative` widget that contains @widget.
	//
	// This function will return nil if the widget is not contained inside a
	// widget tree with a native ancestor.
	//
	// `GtkNative` widgets will return themselves here.
	Native() Native
	// NextSibling returns the widgets next sibling.
	//
	// This API is primarily meant for widget implementations.
	NextSibling() Widget
	// Opacity #Fetches the requested opacity for this widget.
	//
	// See [method@Gtk.Widget.set_opacity].
	Opacity() float64
	// Overflow returns the widgets overflow value.
	Overflow() Overflow
	// PangoContext gets a `PangoContext` with the appropriate font map, font
	// description, and base direction for this widget.
	//
	// Unlike the context returned by [method@Gtk.Widget.create_pango_context],
	// this context is owned by the widget (it can be used until the screen for
	// the widget changes or the widget is removed from its toplevel), and will
	// be updated to match any changes to the widget’s attributes. This can be
	// tracked by listening to changes of the [property@Gtk.Widget:root]
	// property on the widget.
	PangoContext() pango.Context
	// Parent returns the parent widget of @widget.
	Parent() Widget
	// PreferredSize retrieves the minimum and natural size of a widget, taking
	// into account the widget’s preference for height-for-width management.
	//
	// This is used to retrieve a suitable size by container widgets which do
	// not impose any restrictions on the child placement. It can be used to
	// deduce toplevel window and menu sizes as well as child widgets in
	// free-form containers such as `GtkFixed`.
	//
	// Handle with care. Note that the natural height of a height-for-width
	// widget will generally be a smaller size than the minimum height, since
	// the required height for the natural width is generally smaller than the
	// required height for the minimum width.
	//
	// Use [id@gtk_widget_measure] if you want to support baseline alignment.
	PreferredSize() (minimumSize Requisition, naturalSize Requisition)
	// PrevSibling returns the widgets previous sibling.
	//
	// This API is primarily meant for widget implementations.
	PrevSibling() Widget
	// PrimaryClipboard gets the primary clipboard of @widget.
	//
	// This is a utility function to get the primary clipboard object for the
	// `GdkDisplay` that @widget is using.
	//
	// Note that this function always works, even when @widget is not realized
	// yet.
	PrimaryClipboard() gdk.Clipboard
	// Realized determines whether @widget is realized.
	Realized() bool
	// ReceivesDefault determines whether @widget is always treated as the
	// default widget within its toplevel when it has the focus, even if another
	// widget is the default.
	//
	// See [method@Gtk.Widget.set_receives_default].
	ReceivesDefault() bool
	// RequestMode gets whether the widget prefers a height-for-width layout or
	// a width-for-height layout.
	//
	// Single-child widgets generally propagate the preference of their child,
	// more complex widgets need to request something either in context of their
	// children or in context of their allocation capabilities.
	RequestMode() SizeRequestMode
	// Root returns the `GtkRoot` widget of @widget.
	//
	// This function will return nil if the widget is not contained inside a
	// widget tree with a root widget.
	//
	// `GtkRoot` widgets will return themselves here.
	Root() Root
	// ScaleFactor retrieves the internal scale factor that maps from window
	// coordinates to the actual device pixels.
	//
	// On traditional systems this is 1, on high density outputs, it can be a
	// higher value (typically 2).
	//
	// See [method@Gdk.Surface.get_scale_factor].
	ScaleFactor() int
	// Sensitive returns the widget’s sensitivity.
	//
	// This function returns the value that has been set using
	// [method@Gtk.Widget.set_sensitive]).
	//
	// The effective sensitivity of a widget is however determined by both its
	// own and its parent widget’s sensitivity. See
	// [method@Gtk.Widget.is_sensitive].
	Sensitive() bool
	// Settings gets the settings object holding the settings used for this
	// widget.
	//
	// Note that this function can only be called when the `GtkWidget` is
	// attached to a toplevel, since the settings object is specific to a
	// particular `GdkDisplay`. If you want to monitor the widget for changes in
	// its settings, connect to notify::display.
	Settings() Settings
	// Size returns the content width or height of the widget.
	//
	// Which dimension is returned depends on @orientation.
	//
	// This is equivalent to calling [method@Gtk.Widget.get_width] for
	// GTK_ORIENTATION_HORIZONTAL or [method@Gtk.Widget.get_height] for
	// GTK_ORIENTATION_VERTICAL, but can be used when writing
	// orientation-independent code, such as when implementing
	// [iface@Gtk.Orientable] widgets.
	Size(orientation Orientation) int
	// SizeRequest gets the size request that was explicitly set for the widget
	// using gtk_widget_set_size_request().
	//
	// A value of -1 stored in @width or @height indicates that that dimension
	// has not been set explicitly and the natural requisition of the widget
	// will be used instead. See [method@Gtk.Widget.set_size_request]. To get
	// the size a widget will actually request, call [method@Gtk.Widget.measure]
	// instead of this function.
	SizeRequest() (width int, height int)
	// StateFlags returns the widget state as a flag set.
	//
	// It is worth mentioning that the effective GTK_STATE_FLAG_INSENSITIVE
	// state will be returned, that is, also based on parent insensitivity, even
	// if @widget itself is sensitive.
	//
	// Also note that if you are looking for a way to obtain the
	// [flags@Gtk.StateFlags] to pass to a [class@Gtk.StyleContext] method, you
	// should look at [method@Gtk.StyleContext.get_state].
	StateFlags() StateFlags
	// StyleContext returns the style context associated to @widget.
	//
	// The returned object is guaranteed to be the same for the lifetime of
	// @widget.
	StyleContext() StyleContext
	// TemplateChild: fetch an object build from the template XML for
	// @widget_type in this @widget instance.
	//
	// This will only report children which were previously declared with
	// [method@Gtk.WidgetClass.bind_template_child_full] or one of its variants.
	//
	// This function is only meant to be called for code which is private to the
	// @widget_type which declared the child and is meant for language bindings
	// which cannot easily make use of the GObject structure offsets.
	TemplateChild(widgetType externglib.Type, name string) gextras.Objector
	// TooltipMarkup gets the contents of the tooltip for @widget.
	//
	// If the tooltip has not been set using
	// [method@Gtk.Widget.set_tooltip_markup], this function returns nil.
	TooltipMarkup() string
	// TooltipText gets the contents of the tooltip for @widget.
	//
	// If the @widget's tooltip was set using
	// [method@Gtk.Widget.set_tooltip_markup], this function will return the
	// escaped text.
	TooltipText() string
	// Valign gets the vertical alignment of @widget.
	Valign() Align
	// Vexpand gets whether the widget would like any available extra vertical
	// space.
	//
	// See [method@Gtk.Widget.get_hexpand] for more detail.
	Vexpand() bool
	// VexpandSet gets whether gtk_widget_set_vexpand() has been used to
	// explicitly set the expand flag on this widget.
	//
	// See [method@Gtk.Widget.get_hexpand_set] for more detail.
	VexpandSet() bool
	// Visible determines whether the widget is visible.
	//
	// If you want to take into account whether the widget’s parent is also
	// marked as visible, use [method@Gtk.Widget.is_visible] instead.
	//
	// This function does not check if the widget is obscured in any way.
	//
	// See [method@Gtk.Widget.set_visible].
	Visible() bool
	// Width returns the content width of the widget.
	//
	// This function returns the size passed to its size-allocate
	// implementation, which is the size you should be using in
	// GtkWidgetClass.snapshot().
	//
	// For pointer events, see [method@Gtk.Widget.contains].
	Width() int
	// GrabFocus causes @widget to have the keyboard focus for the `GtkWindow`
	// it's inside.
	//
	// If @widget is not focusable, or its ::grab_focus implementation cannot
	// transfer the focus to a descendant of @widget that is focusable, it will
	// not take focus and false will be returned.
	//
	// Calling [method@Gtk.Widget.grab_focus] on an already focused widget is
	// allowed, should not have an effect, and return true.
	GrabFocus() bool
	// HasCSSClass returns whether @css_class is currently applied to @widget.
	HasCSSClass(cssClass string) bool
	// HasDefault determines whether @widget is the current default widget
	// within its toplevel.
	HasDefault() bool
	// HasFocus determines if the widget has the global input focus.
	//
	// See [method@Gtk.Widget.is_focus] for the difference between having the
	// global input focus, and only having the focus within a toplevel.
	HasFocus() bool
	// HasVisibleFocus determines if the widget should show a visible indication
	// that it has the global input focus.
	//
	// This is a convenience function that takes into account whether focus
	// indication should currently be shown in the toplevel window of @widget.
	// See [method@Gtk.Window.get_focus_visible] for more information about
	// focus indication.
	//
	// To find out if the widget has the global input focus, use
	// [method@Gtk.Widget.has_focus].
	HasVisibleFocus() bool
	// Hide reverses the effects of gtk_widget_show().
	//
	// This is causing the widget to be hidden (invisible to the user).
	Hide()
	// InDestruction returns whether the widget is currently being destroyed.
	//
	// This information can sometimes be used to avoid doing unnecessary work.
	InDestruction() bool
	// InitTemplate creates and initializes child widgets defined in templates.
	//
	// This function must be called in the instance initializer for any class
	// which assigned itself a template using
	// [method@Gtk.WidgetClass.set_template].
	//
	// It is important to call this function in the instance initializer of a
	// `GtkWidget` subclass and not in `GObject.constructed()` or
	// `GObject.constructor()` for two reasons:
	//
	//    - derived widgets will assume that the composite widgets
	//      defined by its parent classes have been created in their
	//      relative instance initializers
	//    - when calling `g_object_new()` on a widget with composite templates,
	//      it’s important to build the composite widgets before the construct
	//      properties are set. Properties passed to `g_object_new()` should
	//      take precedence over properties set in the private template XML
	//
	// A good rule of thumb is to call this function as the first thing in an
	// instance initialization function.
	InitTemplate()
	// InsertActionGroup inserts @group into @widget.
	//
	// Children of @widget that implement [iface@Gtk.Actionable] can then be
	// associated with actions in @group by setting their “action-name” to
	// @prefix.`action-name`.
	//
	// Note that inheritance is defined for individual actions. I.e. even if you
	// insert a group with prefix @prefix, actions with the same prefix will
	// still be inherited from the parent, unless the group contains an action
	// with the same name.
	//
	// If @group is nil, a previously inserted group for @name is removed from
	// @widget.
	InsertActionGroup(name string, group gio.ActionGroup)
	// InsertAfter inserts @widget into the child widget list of @parent.
	//
	// It will be placed after @previous_sibling, or at the beginning if
	// @previous_sibling is nil.
	//
	// After calling this function, `gtk_widget_get_prev_sibling(widget)` will
	// return @previous_sibling.
	//
	// If @parent is already set as the parent widget of @widget, this function
	// can also be used to reorder @widget in the child widget list of @parent.
	//
	// This API is primarily meant for widget implementations; if you are just
	// using a widget, you *must* use its own API for adding children.
	InsertAfter(parent Widget, previousSibling Widget)
	// InsertBefore inserts @widget into the child widget list of @parent.
	//
	// It will be placed before @next_sibling, or at the end if @next_sibling is
	// nil.
	//
	// After calling this function, `gtk_widget_get_next_sibling(widget)` will
	// return @next_sibling.
	//
	// If @parent is already set as the parent widget of @widget, this function
	// can also be used to reorder @widget in the child widget list of @parent.
	//
	// This API is primarily meant for widget implementations; if you are just
	// using a widget, you *must* use its own API for adding children.
	InsertBefore(parent Widget, nextSibling Widget)
	// IsAncestor determines whether @widget is somewhere inside @ancestor,
	// possibly with intermediate containers.
	IsAncestor(ancestor Widget) bool
	// IsDrawable determines whether @widget can be drawn to.
	//
	// A widget can be drawn if it is mapped and visible.
	IsDrawable() bool
	// IsFocus determines if the widget is the focus widget within its toplevel.
	//
	// This does not mean that the [property@Gtk.Widget:has-focus] property is
	// necessarily set; [property@Gtk,Widget:has-focus] will only be set if the
	// toplevel widget additionally has the global input focus.)
	IsFocus() bool
	// IsSensitive returns the widget’s effective sensitivity.
	//
	// This means it is sensitive itself and also its parent widget is
	// sensitive.
	IsSensitive() bool
	// IsVisible determines whether the widget and all its parents are marked as
	// visible.
	//
	// This function does not check if the widget is obscured in any way.
	//
	// See also [method@Gtk.Widget.get_visible] and
	// [method@Gtk.Widget.set_visible].
	IsVisible() bool
	// KeynavFailed emits the `::keynav-failed` signal on the widget.
	//
	// This function should be called whenever keyboard navigation within a
	// single widget hits a boundary.
	//
	// The return value of this function should be interpreted in a way similar
	// to the return value of [method@Gtk.Widget.child_focus]. When true is
	// returned, stay in the widget, the failed keyboard navigation is OK and/or
	// there is nowhere we can/should move the focus to. When false is returned,
	// the caller should continue with keyboard navigation outside the widget,
	// e.g. by calling [method@Gtk.Widget.child_focus] on the widget’s toplevel.
	//
	// The default [signal@Gtk.Widget::keynav-failed] handler returns false for
	// GTK_DIR_TAB_FORWARD and GTK_DIR_TAB_BACKWARD. For the other values of
	// DirectionType it returns true.
	//
	// Whenever the default handler returns true, it also calls
	// [method@Gtk.Widget.error_bell] to notify the user of the failed keyboard
	// navigation.
	//
	// A use case for providing an own implementation of ::keynav-failed (either
	// by connecting to it or by overriding it) would be a row of
	// [class@Gtk.Entry] widgets where the user should be able to navigate the
	// entire row with the cursor keys, as e.g. known from user interfaces that
	// require entering license keys.
	KeynavFailed(direction DirectionType) bool
	// ListMnemonicLabels returns the widgets for which this widget is the
	// target of a mnemonic.
	//
	// Typically, these widgets will be labels. See, for example,
	// [method@Gtk.Label.set_mnemonic_widget].
	//
	// The widgets in the list are not individually referenced. If you want to
	// iterate through the list and perform actions involving callbacks that
	// might destroy the widgets, you must call `g_list_foreach (result,
	// (GFunc)g_object_ref, NULL)` first, and then unref all the widgets
	// afterwards.
	ListMnemonicLabels() *glib.List
	// Map causes a widget to be mapped if it isn’t already.
	//
	// This function is only for use in widget implementations.
	Map()
	// Measure measures @widget in the orientation @orientation and for the
	// given @for_size.
	//
	// As an example, if @orientation is GTK_ORIENTATION_HORIZONTAL and
	// @for_size is 300, this functions will compute the minimum and natural
	// width of @widget if it is allocated at a height of 300 pixels.
	//
	// See GtkWidget’s geometry management section
	// (class.Widget.html#height-for-width-geometry-management) for a more
	// details on implementing WidgetClass.measure().
	Measure(orientation Orientation, forSize int) (minimum int, natural int, minimumBaseline int, naturalBaseline int)
	// MnemonicActivate emits the `GtkWidget`::mnemonic-activate signal.
	MnemonicActivate(groupCycling bool) bool
	// ObserveChildren returns a `GListModel` to track the children of @widget.
	//
	// Calling this function will enable extra internal bookkeeping to track
	// children and emit signals on the returned listmodel. It may slow down
	// operations a lot.
	//
	// Applications should try hard to avoid calling this function because of
	// the slowdowns.
	ObserveChildren() gio.ListModel
	// ObserveControllers returns a `GListModel` to track the
	// [class@Gtk.EventController]s of @widget.
	//
	// Calling this function will enable extra internal bookkeeping to track
	// controllers and emit signals on the returned listmodel. It may slow down
	// operations a lot.
	//
	// Applications should try hard to avoid calling this function because of
	// the slowdowns.
	ObserveControllers() gio.ListModel
	// Pick finds the descendant of @widget closest to the screen at the point
	// (@x, @y).
	//
	// The point must be given in widget coordinates, so (0, 0) is assumed to be
	// the top left of @widget's content area.
	//
	// Usually widgets will return nil if the given coordinate is not contained
	// in @widget checked via [method@Gtk.Widget.contains]. Otherwise they will
	// recursively try to find a child that does not return nil. Widgets are
	// however free to customize their picking algorithm.
	//
	// This function is used on the toplevel to determine the widget below the
	// mouse cursor for purposes of hover highlighting and delivering events.
	Pick(x float64, y float64, flags PickFlags) Widget
	// QueueAllocate flags the widget for a rerun of the
	// GtkWidgetClass::size_allocate function.
	//
	// Use this function instead of [method@Gtk.Widget.queue_resize] when the
	// @widget's size request didn't change but it wants to reposition its
	// contents.
	//
	// An example user of this function is [method@Gtk.Widget.set_halign].
	//
	// This function is only for use in widget implementations.
	QueueAllocate()
	// QueueDraw schedules this widget to be redrawn in paint phase of the
	// current or the next frame.
	//
	// This means @widget's GtkWidgetClass.snapshot() implementation will be
	// called.
	QueueDraw()
	// QueueResize flags a widget to have its size renegotiated.
	//
	// This should be called when a widget for some reason has a new size
	// request. For example, when you change the text in a [class@Gtk.Label],
	// the label queues a resize to ensure there’s enough space for the new
	// text.
	//
	// Note that you cannot call gtk_widget_queue_resize() on a widget from
	// inside its implementation of the GtkWidgetClass::size_allocate virtual
	// method. Calls to gtk_widget_queue_resize() from inside
	// GtkWidgetClass::size_allocate will be silently ignored.
	//
	// This function is only for use in widget implementations.
	QueueResize()
	// Realize creates the GDK resources associated with a widget.
	//
	// Normally realization happens implicitly; if you show a widget and all its
	// parent containers, then the widget will be realized and mapped
	// automatically.
	//
	// Realizing a widget requires all the widget’s parent widgets to be
	// realized; calling this function realizes the widget’s parents in addition
	// to @widget itself. If a widget is not yet inside a toplevel window when
	// you realize it, bad things will happen.
	//
	// This function is primarily used in widget implementations, and isn’t very
	// useful otherwise. Many times when you think you might need it, a better
	// approach is to connect to a signal that will be called after the widget
	// is realized automatically, such as [signal@Gtk.Widget::realize].
	Realize()
	// RemoveController removes @controller from @widget, so that it doesn't
	// process events anymore.
	//
	// It should not be used again.
	//
	// Widgets will remove all event controllers automatically when they are
	// destroyed, there is normally no need to call this function.
	RemoveController(controller EventController)
	// RemoveCSSClass removes a style from @widget.
	//
	// After this, the style of @widget will stop matching for @css_class.
	RemoveCSSClass(cssClass string)
	// RemoveMnemonicLabel removes a widget from the list of mnemonic labels for
	// this widget.
	//
	// See [method@Gtk.Widget.list_mnemonic_labels]. The widget must have
	// previously been added to the list with
	// [method@Gtk.Widget.add_mnemonic_label].
	RemoveMnemonicLabel(label Widget)
	// RemoveTickCallback removes a tick callback previously registered with
	// gtk_widget_add_tick_callback().
	RemoveTickCallback(id uint)
	// SetCanFocus specifies whether the input focus can enter the widget or any
	// of its children.
	//
	// Applications should set @can_focus to false to mark a widget as for
	// pointer/touch use only.
	//
	// Note that having @can_focus be true is only one of the necessary
	// conditions for being focusable. A widget must also be sensitive and
	// focusable and not have an ancestor that is marked as not can-focus in
	// order to receive input focus.
	//
	// See [method@Gtk.Widget.grab_focus] for actually setting the input focus
	// on a widget.
	SetCanFocus(canFocus bool)
	// SetCanTarget sets whether @widget can be the target of pointer events.
	SetCanTarget(canTarget bool)
	// SetChildVisible sets whether @widget should be mapped along with its
	// parent.
	//
	// The child visibility can be set for widget before it is added to a
	// container with [method@Gtk.Widget.set_parent], to avoid mapping children
	// unnecessary before immediately unmapping them. However it will be reset
	// to its default state of true when the widget is removed from a container.
	//
	// Note that changing the child visibility of a widget does not queue a
	// resize on the widget. Most of the time, the size of a widget is computed
	// from all visible children, whether or not they are mapped. If this is not
	// the case, the container can queue a resize itself.
	//
	// This function is only useful for container implementations and should
	// never be called by an application.
	SetChildVisible(childVisible bool)
	// SetCSSClasses: will clear all style classes applied to @widget and
	// replace them with @classes.
	SetCSSClasses(classes []string)
	// SetCursor sets the cursor to be shown when pointer devices point towards
	// @widget.
	//
	// If the @cursor is NULL, @widget will use the cursor inherited from the
	// parent widget.
	SetCursor(cursor gdk.Cursor)
	// SetCursorFromName sets a named cursor to be shown when pointer devices
	// point towards @widget.
	//
	// This is a utility function that creates a cursor via
	// [ctor@Gdk.Cursor.new_from_name] and then sets it on @widget with
	// [method@Gtk.Widget.set_cursor]. See those functions for details.
	//
	// On top of that, this function allows @name to be nil, which will do the
	// same as calling [method@Gtk.Widget.set_cursor] with a nil cursor.
	SetCursorFromName(name string)
	// SetDirection sets the reading direction on a particular widget.
	//
	// This direction controls the primary direction for widgets containing
	// text, and also the direction in which the children of a container are
	// packed. The ability to set the direction is present in order so that
	// correct localization into languages with right-to-left reading directions
	// can be done. Generally, applications will let the default reading
	// direction present, except for containers where the containers are
	// arranged in an order that is explicitly visual rather than logical (such
	// as buttons for text justification).
	//
	// If the direction is set to GTK_TEXT_DIR_NONE, then the value set by
	// [func@Gtk.Widget.set_default_direction] will be used.
	SetDirection(dir TextDirection)
	// SetFocusChild: set @child as the current focus child of @widget.
	//
	// The previous focus child will be unset.
	//
	// This function is only suitable for widget implementations. If you want a
	// certain widget to get the input focus, call
	// [method@Gtk.Widget.grab_focus] on it.
	SetFocusChild(child Widget)
	// SetFocusOnClick sets whether the widget should grab focus when it is
	// clicked with the mouse.
	//
	// Making mouse clicks not grab focus is useful in places like toolbars
	// where you don’t want the keyboard focus removed from the main area of the
	// application.
	SetFocusOnClick(focusOnClick bool)
	// SetFocusable specifies whether @widget can own the input focus.
	//
	// Widget implementations should set @focusable to true in their init()
	// function if they want to receive keyboard input.
	//
	// Note that having @focusable be true is only one of the necessary
	// conditions for being focusable. A widget must also be sensitive and
	// can-focus and not have an ancestor that is marked as not can-focus in
	// order to receive input focus.
	//
	// See [method@Gtk.Widget.grab_focus] for actually setting the input focus
	// on a widget.
	SetFocusable(focusable bool)
	// SetFontMap sets the font map to use for Pango rendering.
	//
	// The font map is the object that is used to look up fonts. Setting a
	// custom font map can be useful in special situations, e.g. when you need
	// to add application-specific fonts to the set of available fonts.
	//
	// When not set, the widget will inherit the font map from its parent.
	SetFontMap(fontMap pango.FontMap)
	// SetFontOptions sets the `cairo_font_options_t` used for Pango rendering
	// in this widget.
	//
	// When not set, the default font options for the `GdkDisplay` will be used.
	SetFontOptions(options *cairo.FontOptions)
	// SetHalign sets the horizontal alignment of @widget.
	SetHalign(align Align)
	// SetHasTooltip sets the `has-tooltip` property on @widget to @has_tooltip.
	SetHasTooltip(hasTooltip bool)
	// SetHexpand sets whether the widget would like any available extra
	// horizontal space.
	//
	// When a user resizes a `GtkWindow`, widgets with expand=TRUE generally
	// receive the extra space. For example, a list or scrollable area or
	// document in your window would often be set to expand.
	//
	// Call this function to set the expand flag if you would like your widget
	// to become larger horizontally when the window has extra room.
	//
	// By default, widgets automatically expand if any of their children want to
	// expand. (To see if a widget will automatically expand given its current
	// children and state, call [method@Gtk.Widget.compute_expand]. A container
	// can decide how the expandability of children affects the expansion of the
	// container by overriding the compute_expand virtual method on
	// `GtkWidget`.).
	//
	// Setting hexpand explicitly with this function will override the automatic
	// expand behavior.
	//
	// This function forces the widget to expand or not to expand, regardless of
	// children. The override occurs because [method@Gtk.Widget.set_hexpand]
	// sets the hexpand-set property (see [method@Gtk.Widget.set_hexpand_set])
	// which causes the widget’s hexpand value to be used, rather than looking
	// at children and widget state.
	SetHexpand(expand bool)
	// SetHexpandSet sets whether the hexpand flag will be used.
	//
	// The [property@Gtk.Widget:hexpand-set] property will be set automatically
	// when you call [method@Gtk.Widget.set_hexpand] to set hexpand, so the most
	// likely reason to use this function would be to unset an explicit expand
	// flag.
	//
	// If hexpand is set, then it overrides any computed expand value based on
	// child widgets. If hexpand is not set, then the expand value depends on
	// whether any children of the widget would like to expand.
	//
	// There are few reasons to use this function, but it’s here for
	// completeness and consistency.
	SetHexpandSet(set bool)
	// SetLayoutManager sets the layout manager delegate instance that provides
	// an implementation for measuring and allocating the children of @widget.
	SetLayoutManager(layoutManager LayoutManager)
	// SetMarginBottom sets the bottom margin of @widget.
	SetMarginBottom(margin int)
	// SetMarginEnd sets the end margin of @widget.
	SetMarginEnd(margin int)
	// SetMarginStart sets the start margin of @widget.
	SetMarginStart(margin int)
	// SetMarginTop sets the top margin of @widget.
	SetMarginTop(margin int)
	// SetName sets a widgets name.
	//
	// Setting a name allows you to refer to the widget from a CSS file. You can
	// apply a style to widgets with a particular name in the CSS file. See the
	// documentation for the CSS syntax (on the same page as the docs for
	// [class@Gtk.StyleContext].
	//
	// Note that the CSS syntax has certain special characters to delimit and
	// represent elements in a selector (period, #, >, *...), so using these
	// will make your widget impossible to match by name. Any combination of
	// alphanumeric symbols, dashes and underscores will suffice.
	SetName(name string)
	// SetOpacity: request the @widget to be rendered partially transparent.
	//
	// An opacity of 0 is fully transparent and an opacity of 1 is fully opaque.
	//
	// Opacity works on both toplevel widgets and child widgets, although there
	// are some limitations: For toplevel widgets, applying opacity depends on
	// the capabilities of the windowing system. On X11, this has any effect
	// only on X displays with a compositing manager, see
	// gdk_display_is_composited(). On Windows and Wayland it should always
	// work, although setting a window’s opacity after the window has been shown
	// may cause some flicker.
	//
	// Note that the opacity is inherited through inclusion — if you set a
	// toplevel to be partially translucent, all of its content will appear
	// translucent, since it is ultimatively rendered on that toplevel. The
	// opacity value itself is not inherited by child widgets (since that would
	// make widgets deeper in the hierarchy progressively more translucent). As
	// a consequence, [class@Gtk.Popover]s and other [class@Gtk.Native] widgets
	// with their own surface will use their own opacity value, and thus by
	// default appear non-translucent, even if they are attached to a toplevel
	// that is translucent.
	SetOpacity(opacity float64)
	// SetOverflow sets how @widget treats content that is drawn outside the
	// widget's content area.
	//
	// See the definition of [enum@Gtk.Overflow] for details.
	//
	// This setting is provided for widget implementations and should not be
	// used by application code.
	//
	// The default value is GTK_OVERFLOW_VISIBLE.
	SetOverflow(overflow Overflow)
	// SetParent sets @parent as the parent widget of @widget.
	//
	// This takes care of details such as updating the state and style of the
	// child to reflect its new location and resizing the parent. The opposite
	// function is [method@Gtk.Widget.unparent].
	//
	// This function is useful only when implementing subclasses of `GtkWidget`.
	SetParent(parent Widget)
	// SetReceivesDefault specifies whether @widget will be treated as the
	// default widget within its toplevel when it has the focus, even if another
	// widget is the default.
	SetReceivesDefault(receivesDefault bool)
	// SetSensitive sets the sensitivity of a widget.
	//
	// A widget is sensitive if the user can interact with it. Insensitive
	// widgets are “grayed out” and the user can’t interact with them.
	// Insensitive widgets are known as “inactive”, “disabled”, or “ghosted” in
	// some other toolkits.
	SetSensitive(sensitive bool)
	// SetSizeRequest sets the minimum size of a widget.
	//
	// That is, the widget’s size request will be at least @width by @height.
	// You can use this function to force a widget to be larger than it normally
	// would be.
	//
	// In most cases, [method@Gtk.Window.set_default_size] is a better choice
	// for toplevel windows than this function; setting the default size will
	// still allow users to shrink the window. Setting the size request will
	// force them to leave the window at least as large as the size request.
	//
	// Note the inherent danger of setting any fixed size - themes, translations
	// into other languages, different fonts, and user action can all change the
	// appropriate size for a given widget. So, it's basically impossible to
	// hardcode a size that will always be correct.
	//
	// The size request of a widget is the smallest size a widget can accept
	// while still functioning well and drawing itself correctly. However in
	// some strange cases a widget may be allocated less than its requested
	// size, and in many cases a widget may be allocated more space than it
	// requested.
	//
	// If the size request in a given direction is -1 (unset), then the
	// “natural” size request of the widget will be used instead.
	//
	// The size request set here does not include any margin from the properties
	// [property@Gtk.Widget:margin-start], [property@Gtk.Widget:margin-end],
	// [property@Gtk.Widget:margin-top], and
	// [property@Gtk.Widget:margin-bottom], but it does include pretty much all
	// other padding or border properties set by any subclass of `GtkWidget`.
	SetSizeRequest(width int, height int)
	// SetStateFlags turns on flag values in the current widget state.
	//
	// Typical widget states are insensitive, prelighted, etc.
	//
	// This function accepts the values GTK_STATE_FLAG_DIR_LTR and
	// GTK_STATE_FLAG_DIR_RTL but ignores them. If you want to set the widget's
	// direction, use [method@Gtk.Widget.set_direction].
	//
	// This function is for use in widget implementations.
	SetStateFlags(flags StateFlags, clear bool)
	// SetTooltipMarkup sets @markup as the contents of the tooltip, which is
	// marked up with Pango markup.
	//
	// This function will take care of setting the
	// [property@Gtk.Widget:has-tooltip] as a side effect, and of the default
	// handler for the [signal@Gtk.Widget::query-tooltip] signal.
	//
	// See also [method@Gtk.Tooltip.set_markup].
	SetTooltipMarkup(markup string)
	// SetTooltipText sets @text as the contents of the tooltip.
	//
	// If @text contains any markup, it will be escaped.
	//
	// This function will take care of setting [property@Gtk.Widget:has-tooltip]
	// as a side effect, and of the default handler for the
	// [signal@Gtk.Widget::query-tooltip] signal.
	//
	// See also [method@Gtk.Tooltip.set_text].
	SetTooltipText(text string)
	// SetValign sets the vertical alignment of @widget.
	SetValign(align Align)
	// SetVexpand sets whether the widget would like any available extra
	// vertical space.
	//
	// See [method@Gtk.Widget.set_hexpand] for more detail.
	SetVexpand(expand bool)
	// SetVexpandSet sets whether the vexpand flag will be used.
	//
	// See [method@Gtk.Widget.set_hexpand_set] for more detail.
	SetVexpandSet(set bool)
	// SetVisible sets the visibility state of @widget.
	//
	// Note that setting this to true doesn’t mean the widget is actually
	// viewable, see [method@Gtk.Widget.get_visible].
	//
	// This function simply calls [method@Gtk.Widget.show] or
	// [method@Gtk.Widget.hide] but is nicer to use when the visibility of the
	// widget depends on some condition.
	SetVisible(visible bool)
	// ShouldLayout returns whether @widget should contribute to the measuring
	// and allocation of its parent.
	//
	// This is false for invisible children, but also for children that have
	// their own surface.
	ShouldLayout() bool
	// Show flags a widget to be displayed.
	//
	// Any widget that isn’t shown will not appear on the screen.
	//
	// Remember that you have to show the containers containing a widget, in
	// addition to the widget itself, before it will appear onscreen.
	//
	// When a toplevel container is shown, it is immediately realized and
	// mapped; other shown widgets are realized and mapped when their toplevel
	// container is realized and mapped.
	Show()
	// SnapshotChild: snapshot the a child of @widget.
	//
	// When a widget receives a call to the snapshot function, it must send
	// synthetic `GtkWidget`Class.snapshot() calls to all children. This
	// function provides a convenient way of doing this. A widget, when it
	// receives a call to its `GtkWidget`Class.snapshot() function, calls
	// gtk_widget_snapshot_child() once for each child, passing in the @snapshot
	// the widget received.
	//
	// gtk_widget_snapshot_child() takes care of translating the origin of
	// @snapshot, and deciding whether the child needs to be snapshot.
	//
	// This function does nothing for children that implement `GtkNative`.
	SnapshotChild(child Widget, snapshot Snapshot)
	// TranslateCoordinates: translate coordinates relative to @src_widget’s
	// allocation to coordinates relative to @dest_widget’s allocations.
	//
	// In order to perform this operation, both widget must share a common
	// ancestor.
	TranslateCoordinates(destWidget Widget, srcX float64, srcY float64) (destX float64, destY float64, ok bool)
	// TriggerTooltipQuery triggers a tooltip query on the display where the
	// toplevel of @widget is located.
	TriggerTooltipQuery()
	// Unmap causes a widget to be unmapped if it’s currently mapped.
	//
	// This function is only for use in widget implementations.
	Unmap()
	// Unparent: dissociate @widget from its parent.
	//
	// This function is only for use in widget implementations, typically in
	// dispose.
	Unparent()
	// Unrealize causes a widget to be unrealized (frees all GDK resources
	// associated with the widget).
	//
	// This function is only useful in widget implementations.
	Unrealize()
	// UnsetStateFlags turns off flag values for the current widget state.
	//
	// See [method@Gtk.Widget.set_state_flags].
	//
	// This function is for use in widget implementations.
	UnsetStateFlags(flags StateFlags)
}

// widget implements the Widget interface.
type widget struct {
	gextras.Objector
	Accessible
	Buildable
	ConstraintTarget
}

var _ Widget = (*widget)(nil)

// WrapWidget wraps a GObject to the right type. It is
// primarily used internally.
func WrapWidget(obj *externglib.Object) Widget {
	return Widget{
		Objector:         obj,
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
	}
}

func marshalWidget(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapWidget(obj), nil
}

// ActionSetEnabled: enable or disable an action installed with
// gtk_widget_class_install_action().
func (w widget) ActionSetEnabled(actionName string, enabled bool) {
	var arg0 *C.GtkWidget
	var arg1 *C.char
	var arg2 C.gboolean

	arg0 = (*C.GtkWidget)(w.Native())
	arg1 = (*C.gchar)(C.CString(actionName))
	defer C.free(unsafe.Pointer(arg1))
	if enabled {
		arg2 = C.TRUE
	}

	C.gtk_widget_action_set_enabled(arg0, arg1, arg2)
}

// Activate: for widgets that can be “activated” (buttons, menu items, etc.)
// this function activates them.
//
// The activation will emit the signal set using
// gtk_widget_class_set_activate_signal() during class initialization.
//
// Activation is what happens when you press Enter on a widget during key
// navigation.
//
// If you wish to handle the activation keybinding yourself, it is
// recommended to use gtk_widget_class_add_shortcut() with an action created
// with gtk_signal_action_new().
//
// If @widget isn't activatable, the function returns false.
func (w widget) Activate() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())

	ret := C.gtk_widget_activate(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// ActivateActionVariant looks up the action in the action groups associated
// with @widget and its ancestors, and activates it.
//
// If the action is in an action group added with
// [method@Gtk.Widget.insert_action_group], the @name is expected to be
// prefixed with the prefix that was used when the group was inserted.
//
// The arguments must match the actions expected parameter type, as returned
// by `g_action_get_parameter_type()`.
func (w widget) ActivateActionVariant(name string, args *glib.Variant) bool {
	var arg0 *C.GtkWidget
	var arg1 *C.char
	var arg2 *C.GVariant

	arg0 = (*C.GtkWidget)(w.Native())
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GVariant)(args.Native())

	ret := C.gtk_widget_activate_action_variant(arg0, arg1, arg2)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// ActivateDefault activates the `default.activate` action from @widget.
func (w widget) ActivateDefault() {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())

	C.gtk_widget_activate_default(arg0)
}

// AddController adds @controller to @widget so that it will receive events.
//
// You will usually want to call this function right after creating any kind
// of [class@Gtk.EventController].
func (w widget) AddController(controller EventController) {
	var arg0 *C.GtkWidget
	var arg1 *C.GtkEventController

	arg0 = (*C.GtkWidget)(w.Native())
	arg1 = (*C.GtkEventController)(controller.Native())

	C.gtk_widget_add_controller(arg0, arg1)
}

// AddCSSClass adds a style class to @widget.
//
// After calling this function, the widgets style will match for @css_class,
// according to CSS matching rules.
//
// Use [method@Gtk.Widget.remove_css_class] to remove the style again.
func (w widget) AddCSSClass(cssClass string) {
	var arg0 *C.GtkWidget
	var arg1 *C.char

	arg0 = (*C.GtkWidget)(w.Native())
	arg1 = (*C.gchar)(C.CString(cssClass))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_widget_add_css_class(arg0, arg1)
}

// AddMnemonicLabel adds a widget to the list of mnemonic labels for this
// widget.
//
// See [method@Gtk.Widget.list_mnemonic_labels]. Note the list of mnemonic
// labels for the widget is cleared when the widget is destroyed, so the
// caller must make sure to update its internal state at this point as well,
// by using a connection to the [signal@Gtk.Widget::destroy] signal or a
// weak notifier.
func (w widget) AddMnemonicLabel(label Widget) {
	var arg0 *C.GtkWidget
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())
	arg1 = (*C.GtkWidget)(label.Native())

	C.gtk_widget_add_mnemonic_label(arg0, arg1)
}

// AddTickCallback queues an animation frame update and adds a callback to
// be called before each frame.
//
// Until the tick callback is removed, it will be called frequently (usually
// at the frame rate of the output device or as quickly as the application
// can be repainted, whichever is slower). For this reason, is most suitable
// for handling graphics that change every frame or every few frames. The
// tick callback does not automatically imply a relayout or repaint. If you
// want a repaint or relayout, and aren’t changing widget properties that
// would trigger that (for example, changing the text of a Label), then you
// will have to call [method@Gtk.Widget.queue_resize] or
// [method@Gtk.Widget.queue_draw] yourself.
//
// [method@Gdk.FrameClock.get_frame_time] should generally be used for
// timing continuous animations and
// [method@Gdk.FrameTimings.get_predicted_presentation_time] if you are
// trying to display isolated frames at particular times.
//
// This is a more convenient alternative to connecting directly to the
// [signal@Gdk.FrameClock::update] signal of `GdkFrameClock`, since you
// don't have to worry about when a `GdkFrameClock` is assigned to a widget.
func (w widget) AddTickCallback(callback TickCallback) uint {
	var arg0 *C.GtkWidget
	var arg1 C.GtkTickCallback
	var arg2 C.gpointer
	var arg3 C.GDestroyNotify

	arg0 = (*C.GtkWidget)(w.Native())
	arg1 = (*[0]byte)(C.gotk4_TickCallback)
	arg2 = C.gpointer(box.Assign(callback))
	arg3 = (*[0]byte)(C.callbackDelete)

	ret := C.gtk_widget_add_tick_callback(arg0, arg1, arg2, arg3)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// Allocate: this function is only used by `GtkWidget` subclasses, to assign
// a size, position and (optionally) baseline to their child widgets.
//
// In this function, the allocation and baseline may be adjusted. The given
// allocation will be forced to be bigger than the widget's minimum size, as
// well as at least 0×0 in size.
//
// For a version that does not take a transform, see
// [method@Gtk.Widget.size_allocate].
func (w widget) Allocate(width int, height int, baseline int, transform *gsk.Transform) {
	var arg0 *C.GtkWidget
	var arg1 C.int
	var arg2 C.int
	var arg3 C.int
	var arg4 *C.GskTransform

	arg0 = (*C.GtkWidget)(w.Native())
	arg1 = C.int(width)
	arg2 = C.int(height)
	arg3 = C.int(baseline)
	arg4 = (*C.GskTransform)(transform.Native())

	C.gtk_widget_allocate(arg0, arg1, arg2, arg3, arg4)
}

// ChildFocus: called by widgets as the user moves around the window using
// keyboard shortcuts.
//
// The @direction argument indicates what kind of motion is taking place
// (up, down, left, right, tab forward, tab backward).
//
// This function calls the [vfunc@Gtk.Widget.focus] virtual function;
// widgets can override the virtual function in order to implement
// appropriate focus behavior.
//
// The default `focus()` virtual function for a widget should return `TRUE`
// if moving in @direction left the focus on a focusable location inside
// that widget, and `FALSE` if moving in @direction moved the focus outside
// the widget. When returning `TRUE`, widgets normallycall
// [method@Gtk.Widget.grab_focus] to place the focus accordingly; when
// returning `FALSE`, they don’t modify the current focus location.
//
// This function is used by custom widget implementations; if you're writing
// an app, you’d use [method@Gtk.Widget.grab_focus] to move the focus to a
// particular widget.
func (w widget) ChildFocus(direction DirectionType) bool {
	var arg0 *C.GtkWidget
	var arg1 C.GtkDirectionType

	arg0 = (*C.GtkWidget)(w.Native())
	arg1 = (C.GtkDirectionType)(direction)

	ret := C.gtk_widget_child_focus(arg0, arg1)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// ComputeBounds computes the bounds for @widget in the coordinate space of
// @target.
//
// FIXME: Explain what "bounds" are.
//
// If the operation is successful, true is returned. If @widget has no
// bounds or the bounds cannot be expressed in @target's coordinate space
// (for example if both widgets are in different windows), false is returned
// and @bounds is set to the zero rectangle.
//
// It is valid for @widget and @target to be the same widget.
func (w widget) ComputeBounds(target Widget) (outBounds graphene.Rect, ok bool) {
	var arg0 *C.GtkWidget
	var arg1 *C.GtkWidget
	var arg2 *C.graphene_rect_t // out

	arg0 = (*C.GtkWidget)(w.Native())
	arg1 = (*C.GtkWidget)(target.Native())

	ret := C.gtk_widget_compute_bounds(arg0, arg1, &arg2)

	var ret0 *graphene.Rect
	var ret1 bool

	{
		ret0 = graphene.WrapRect(unsafe.Pointer(arg2))
	}

	ret1 = C.bool(ret) != 0

	return ret0, ret1
}

// ComputeExpand computes whether a container should give this widget extra
// space when possible.
//
// Containers should check this, rather than looking at
// [method@Gtk.Widget.get_hexpand] or [method@Gtk.Widget.get_vexpand].
//
// This function already checks whether the widget is visible, so visibility
// does not need to be checked separately. Non-visible widgets are not
// expanded.
//
// The computed expand value uses either the expand setting explicitly set
// on the widget itself, or, if none has been explicitly set, the widget may
// expand if some of its children do.
func (w widget) ComputeExpand(orientation Orientation) bool {
	var arg0 *C.GtkWidget
	var arg1 C.GtkOrientation

	arg0 = (*C.GtkWidget)(w.Native())
	arg1 = (C.GtkOrientation)(orientation)

	ret := C.gtk_widget_compute_expand(arg0, arg1)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// ComputePoint translates the given @point in @widget's coordinates to
// coordinates relative to @target’s coordinate system.
//
// In order to perform this operation, both widgets must share a common
// ancestor.
func (w widget) ComputePoint(target Widget, point *graphene.Point) (outPoint graphene.Point, ok bool) {
	var arg0 *C.GtkWidget
	var arg1 *C.GtkWidget
	var arg2 *C.graphene_point_t
	var arg3 *C.graphene_point_t // out

	arg0 = (*C.GtkWidget)(w.Native())
	arg1 = (*C.GtkWidget)(target.Native())
	arg2 = (*C.graphene_point_t)(point.Native())

	ret := C.gtk_widget_compute_point(arg0, arg1, arg2, &arg3)

	var ret0 *graphene.Point
	var ret1 bool

	{
		ret0 = graphene.WrapPoint(unsafe.Pointer(arg3))
	}

	ret1 = C.bool(ret) != 0

	return ret0, ret1
}

// ComputeTransform computes a matrix suitable to describe a transformation
// from @widget's coordinate system into @target's coordinate system.
func (w widget) ComputeTransform(target Widget) (outTransform graphene.Matrix, ok bool) {
	var arg0 *C.GtkWidget
	var arg1 *C.GtkWidget
	var arg2 *C.graphene_matrix_t // out

	arg0 = (*C.GtkWidget)(w.Native())
	arg1 = (*C.GtkWidget)(target.Native())

	ret := C.gtk_widget_compute_transform(arg0, arg1, &arg2)

	var ret0 *graphene.Matrix
	var ret1 bool

	{
		ret0 = graphene.WrapMatrix(unsafe.Pointer(arg2))
	}

	ret1 = C.bool(ret) != 0

	return ret0, ret1
}

// Contains tests if the point at (@x, @y) is contained in @widget.
//
// The coordinates for (@x, @y) must be in widget coordinates, so (0, 0) is
// assumed to be the top left of @widget's content area.
func (w widget) Contains(x float64, y float64) bool {
	var arg0 *C.GtkWidget
	var arg1 C.double
	var arg2 C.double

	arg0 = (*C.GtkWidget)(w.Native())
	arg1 = C.double(x)
	arg2 = C.double(y)

	ret := C.gtk_widget_contains(arg0, arg1, arg2)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// CreatePangoContext creates a new `PangoContext` with the appropriate font
// map, font options, font description, and base direction for drawing text
// for this widget.
//
// See also [method@Gtk.Widget.get_pango_context].
func (w widget) CreatePangoContext() pango.Context {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())

	ret := C.gtk_widget_create_pango_context(arg0)

	var ret0 pango.Context

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(pango.Context)

	return ret0
}

// CreatePangoLayout creates a new `PangoLayout` with the appropriate font
// map, font description, and base direction for drawing text for this
// widget.
//
// If you keep a `PangoLayout` created in this way around, you need to
// re-create it when the widget `PangoContext` is replaced. This can be
// tracked by listening to changes of the [property@Gtk.Widget:root]
// property on the widget.
func (w widget) CreatePangoLayout(text string) pango.Layout {
	var arg0 *C.GtkWidget
	var arg1 *C.char

	arg0 = (*C.GtkWidget)(w.Native())
	arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_widget_create_pango_layout(arg0, arg1)

	var ret0 pango.Layout

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(pango.Layout)

	return ret0
}

// DragCheckThreshold checks to see if a drag movement has passed the GTK
// drag threshold.
func (w widget) DragCheckThreshold(startX int, startY int, currentX int, currentY int) bool {
	var arg0 *C.GtkWidget
	var arg1 C.int
	var arg2 C.int
	var arg3 C.int
	var arg4 C.int

	arg0 = (*C.GtkWidget)(w.Native())
	arg1 = C.int(startX)
	arg2 = C.int(startY)
	arg3 = C.int(currentX)
	arg4 = C.int(currentY)

	ret := C.gtk_drag_check_threshold(arg0, arg1, arg2, arg3, arg4)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// ErrorBell notifies the user about an input-related error on this widget.
//
// If the [property@Gtk.Settings:gtk-error-bell] setting is true, it calls
// [method@Gdk.Surface.beep], otherwise it does nothing.
//
// Note that the effect of [method@Gdk.Surface.beep] can be configured in
// many ways, depending on the windowing backend and the desktop environment
// or window manager that is used.
func (w widget) ErrorBell() {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())

	C.gtk_widget_error_bell(arg0)
}

// AllocatedBaseline returns the baseline that has currently been allocated
// to @widget.
//
// This function is intended to be used when implementing handlers for the
// `GtkWidget`Class.snapshot() function, and when allocating child widgets
// in `GtkWidget`Class.size_allocate().
func (w widget) AllocatedBaseline() int {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())

	ret := C.gtk_widget_get_allocated_baseline(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// AllocatedHeight returns the height that has currently been allocated to
// @widget.
func (w widget) AllocatedHeight() int {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())

	ret := C.gtk_widget_get_allocated_height(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// AllocatedWidth returns the width that has currently been allocated to
// @widget.
func (w widget) AllocatedWidth() int {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())

	ret := C.gtk_widget_get_allocated_width(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Allocation retrieves the widget’s allocation.
//
// Note, when implementing a layout container: a widget’s allocation will be
// its “adjusted” allocation, that is, the widget’s parent typically calls
// [method@Gtk.Widget.size_allocate] with an allocation, and that allocation
// is then adjusted (to handle margin and alignment for example) before
// assignment to the widget. [method@Gtk.Widget.get_allocation] returns the
// adjusted allocation that was actually assigned to the widget. The
// adjusted allocation is guaranteed to be completely contained within the
// [method@Gtk.Widget.size_allocate] allocation, however.
//
// So a layout container is guaranteed that its children stay inside the
// assigned bounds, but not that they have exactly the bounds the container
// assigned.
func (w widget) Allocation() Allocation {
	var arg0 *C.GtkWidget
	var arg1 *C.GtkAllocation // out

	arg0 = (*C.GtkWidget)(w.Native())

	C.gtk_widget_get_allocation(arg0, &arg1)

	var ret0 *Allocation

	{
		var tmp gdk.Rectangle
		{
			tmp = gdk.WrapRectangle(unsafe.Pointer(arg1))
		}
		ret0 = *Allocation(tmp)
	}

	return ret0
}

// Ancestor gets the first ancestor of @widget with type @widget_type.
//
// For example, `gtk_widget_get_ancestor (widget, GTK_TYPE_BOX)` gets the
// first `GtkBox` that’s an ancestor of @widget. No reference will be added
// to the returned widget; it should not be unreferenced.
//
// Note that unlike [method@Gtk.Widget.is_ancestor], this function considers
// @widget to be an ancestor of itself.
func (w widget) Ancestor(widgetType externglib.Type) Widget {
	var arg0 *C.GtkWidget
	var arg1 C.GType

	arg0 = (*C.GtkWidget)(w.Native())
	arg1 = C.GType(widgetType)

	ret := C.gtk_widget_get_ancestor(arg0, arg1)

	var ret0 Widget

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(Widget)

	return ret0
}

// CanFocus determines whether the input focus can enter @widget or any of
// its children.
//
// See [method@Gtk.Widget.set_focusable].
func (w widget) CanFocus() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())

	ret := C.gtk_widget_get_can_focus(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// CanTarget queries whether @widget can be the target of pointer events.
func (w widget) CanTarget() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())

	ret := C.gtk_widget_get_can_target(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// ChildVisible gets the value set with gtk_widget_set_child_visible().
//
// If you feel a need to use this function, your code probably needs
// reorganization.
//
// This function is only useful for container implementations and should
// never be called by an application.
func (w widget) ChildVisible() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())

	ret := C.gtk_widget_get_child_visible(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// Clipboard gets the clipboard object for @widget.
//
// This is a utility function to get the clipboard object for the
// `GdkDisplay` that @widget is using.
//
// Note that this function always works, even when @widget is not realized
// yet.
func (w widget) Clipboard() gdk.Clipboard {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())

	ret := C.gtk_widget_get_clipboard(arg0)

	var ret0 gdk.Clipboard

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(gdk.Clipboard)

	return ret0
}

// CSSClasses returns the list of style classes applied to @widget.
func (w widget) CSSClasses() []string {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())

	ret := C.gtk_widget_get_css_classes(arg0)

	var ret0 []string

	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]string, length)
		for i := 0; i < length; i++ {
			src := (*C.gchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			ret0[i] = C.GoString(src)
			C.free(unsafe.Pointer(src))
		}
	}

	return ret0
}

// CSSName returns the CSS name that is used for @self.
func (s widget) CSSName() string {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(s.Native())

	ret := C.gtk_widget_get_css_name(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Cursor queries the cursor set on @widget.
//
// See [method@Gtk.Widget.set_cursor] for details.
func (w widget) Cursor() gdk.Cursor {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())

	ret := C.gtk_widget_get_cursor(arg0)

	var ret0 gdk.Cursor

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(gdk.Cursor)

	return ret0
}

// Direction gets the reading direction for a particular widget.
//
// See [method@Gtk.Widget.set_direction].
func (w widget) Direction() TextDirection {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())

	ret := C.gtk_widget_get_direction(arg0)

	var ret0 TextDirection

	ret0 = TextDirection(ret)

	return ret0
}

// Display: get the `GdkDisplay` for the toplevel window associated with
// this widget.
//
// This function can only be called after the widget has been added to a
// widget hierarchy with a `GtkWindow` at the top.
//
// In general, you should only create display specific resources when a
// widget has been realized, and you should free those resources when the
// widget is unrealized.
func (w widget) Display() gdk.Display {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())

	ret := C.gtk_widget_get_display(arg0)

	var ret0 gdk.Display

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(gdk.Display)

	return ret0
}

// FirstChild returns the widgets first child.
//
// This API is primarily meant for widget implementations.
func (w widget) FirstChild() Widget {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())

	ret := C.gtk_widget_get_first_child(arg0)

	var ret0 Widget

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(Widget)

	return ret0
}

// FocusChild returns the current focus child of @widget.
func (w widget) FocusChild() Widget {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())

	ret := C.gtk_widget_get_focus_child(arg0)

	var ret0 Widget

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(Widget)

	return ret0
}

// FocusOnClick returns whether the widget should grab focus when it is
// clicked with the mouse.
//
// See [method@Gtk.Widget.set_focus_on_click].
func (w widget) FocusOnClick() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())

	ret := C.gtk_widget_get_focus_on_click(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// Focusable determines whether @widget can own the input focus.
//
// See [method@Gtk.Widget.set_focusable].
func (w widget) Focusable() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())

	ret := C.gtk_widget_get_focusable(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// FontMap gets the font map of @widget.
//
// See [method@Gtk.Widget.set_font_map].
func (w widget) FontMap() pango.FontMap {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())

	ret := C.gtk_widget_get_font_map(arg0)

	var ret0 pango.FontMap

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(pango.FontMap)

	return ret0
}

// FontOptions returns the `cairo_font_options_t` used for Pango rendering.
//
// When not set, the defaults font options for the `GdkDisplay` will be
// used.
func (w widget) FontOptions() *cairo.FontOptions {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())

	ret := C.gtk_widget_get_font_options(arg0)

	var ret0 *cairo.FontOptions

	{
		ret0 = cairo.WrapFontOptions(unsafe.Pointer(ret))
	}

	return ret0
}

// FrameClock obtains the frame clock for a widget.
//
// The frame clock is a global “ticker” that can be used to drive animations
// and repaints. The most common reason to get the frame clock is to call
// [method@Gdk.FrameClock.get_frame_time], in order to get a time to use for
// animating. For example you might record the start of the animation with
// an initial value from [method@Gdk.FrameClock.get_frame_time], and then
// update the animation by calling [method@Gdk.FrameClock.get_frame_time]
// again during each repaint.
//
// [method@Gdk.FrameClock.request_phase] will result in a new frame on the
// clock, but won’t necessarily repaint any widgets. To repaint a widget,
// you have to use [method@Gtk.Widget.queue_draw] which invalidates the
// widget (thus scheduling it to receive a draw on the next frame).
// gtk_widget_queue_draw() will also end up requesting a frame on the
// appropriate frame clock.
//
// A widget’s frame clock will not change while the widget is mapped.
// Reparenting a widget (which implies a temporary unmap) can change the
// widget’s frame clock.
//
// Unrealized widgets do not have a frame clock.
func (w widget) FrameClock() gdk.FrameClock {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())

	ret := C.gtk_widget_get_frame_clock(arg0)

	var ret0 gdk.FrameClock

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(gdk.FrameClock)

	return ret0
}

// Halign gets the horizontal alignment of @widget.
//
// For backwards compatibility reasons this method will never return
// GTK_ALIGN_BASELINE, but instead it will convert it to GTK_ALIGN_FILL.
// Baselines are not supported for horizontal alignment.
func (w widget) Halign() Align {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())

	ret := C.gtk_widget_get_halign(arg0)

	var ret0 Align

	ret0 = Align(ret)

	return ret0
}

// HasTooltip returns the current value of the `has-tooltip` property.
func (w widget) HasTooltip() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())

	ret := C.gtk_widget_get_has_tooltip(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// Height returns the content height of the widget.
//
// This function returns the size passed to its size-allocate
// implementation, which is the size you should be using in
// GtkWidgetClass.snapshot().
//
// For pointer events, see [method@Gtk.Widget.contains].
func (w widget) Height() int {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())

	ret := C.gtk_widget_get_height(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Hexpand gets whether the widget would like any available extra horizontal
// space.
//
// When a user resizes a `GtkWindow`, widgets with expand=TRUE generally
// receive the extra space. For example, a list or scrollable area or
// document in your window would often be set to expand.
//
// Containers should use [method@Gtk.Widget.compute_expand] rather than this
// function, to see whether a widget, or any of its children, has the expand
// flag set. If any child of a widget wants to expand, the parent may ask to
// expand also.
//
// This function only looks at the widget’s own hexpand flag, rather than
// computing whether the entire widget tree rooted at this widget wants to
// expand.
func (w widget) Hexpand() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())

	ret := C.gtk_widget_get_hexpand(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// HexpandSet gets whether gtk_widget_set_hexpand() has been used to
// explicitly set the expand flag on this widget.
//
// If [property@Gtk.Widget:hexpand] property is set, then it overrides any
// computed expand value based on child widgets. If `hexpand` is not set,
// then the expand value depends on whether any children of the widget would
// like to expand.
//
// There are few reasons to use this function, but it’s here for
// completeness and consistency.
func (w widget) HexpandSet() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())

	ret := C.gtk_widget_get_hexpand_set(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// LastChild returns the widgets last child.
//
// This API is primarily meant for widget implementations.
func (w widget) LastChild() Widget {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())

	ret := C.gtk_widget_get_last_child(arg0)

	var ret0 Widget

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(Widget)

	return ret0
}

// LayoutManager retrieves the layout manager used by @widget
//
// See [method@Gtk.Widget.set_layout_manager].
func (w widget) LayoutManager() LayoutManager {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())

	ret := C.gtk_widget_get_layout_manager(arg0)

	var ret0 LayoutManager

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(LayoutManager)

	return ret0
}

// Mapped: whether the widget is mapped.
func (w widget) Mapped() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())

	ret := C.gtk_widget_get_mapped(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// MarginBottom gets the bottom margin of @widget.
func (w widget) MarginBottom() int {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())

	ret := C.gtk_widget_get_margin_bottom(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// MarginEnd gets the end margin of @widget.
func (w widget) MarginEnd() int {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())

	ret := C.gtk_widget_get_margin_end(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// MarginStart gets the start margin of @widget.
func (w widget) MarginStart() int {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())

	ret := C.gtk_widget_get_margin_start(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// MarginTop gets the top margin of @widget.
func (w widget) MarginTop() int {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())

	ret := C.gtk_widget_get_margin_top(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Name retrieves the name of a widget.
//
// See [method@Gtk.Widget.set_name] for the significance of widget names.
func (w widget) Name() string {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())

	ret := C.gtk_widget_get_name(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Native returns the `GtkNative` widget that contains @widget.
//
// This function will return nil if the widget is not contained inside a
// widget tree with a native ancestor.
//
// `GtkNative` widgets will return themselves here.
func (w widget) Native() Native {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())

	ret := C.gtk_widget_get_native(arg0)

	var ret0 Native

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(Native)

	return ret0
}

// NextSibling returns the widgets next sibling.
//
// This API is primarily meant for widget implementations.
func (w widget) NextSibling() Widget {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())

	ret := C.gtk_widget_get_next_sibling(arg0)

	var ret0 Widget

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(Widget)

	return ret0
}

// Opacity #Fetches the requested opacity for this widget.
//
// See [method@Gtk.Widget.set_opacity].
func (w widget) Opacity() float64 {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())

	ret := C.gtk_widget_get_opacity(arg0)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// Overflow returns the widgets overflow value.
func (w widget) Overflow() Overflow {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())

	ret := C.gtk_widget_get_overflow(arg0)

	var ret0 Overflow

	ret0 = Overflow(ret)

	return ret0
}

// PangoContext gets a `PangoContext` with the appropriate font map, font
// description, and base direction for this widget.
//
// Unlike the context returned by [method@Gtk.Widget.create_pango_context],
// this context is owned by the widget (it can be used until the screen for
// the widget changes or the widget is removed from its toplevel), and will
// be updated to match any changes to the widget’s attributes. This can be
// tracked by listening to changes of the [property@Gtk.Widget:root]
// property on the widget.
func (w widget) PangoContext() pango.Context {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())

	ret := C.gtk_widget_get_pango_context(arg0)

	var ret0 pango.Context

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(pango.Context)

	return ret0
}

// Parent returns the parent widget of @widget.
func (w widget) Parent() Widget {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())

	ret := C.gtk_widget_get_parent(arg0)

	var ret0 Widget

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(Widget)

	return ret0
}

// PreferredSize retrieves the minimum and natural size of a widget, taking
// into account the widget’s preference for height-for-width management.
//
// This is used to retrieve a suitable size by container widgets which do
// not impose any restrictions on the child placement. It can be used to
// deduce toplevel window and menu sizes as well as child widgets in
// free-form containers such as `GtkFixed`.
//
// Handle with care. Note that the natural height of a height-for-width
// widget will generally be a smaller size than the minimum height, since
// the required height for the natural width is generally smaller than the
// required height for the minimum width.
//
// Use [id@gtk_widget_measure] if you want to support baseline alignment.
func (w widget) PreferredSize() (minimumSize Requisition, naturalSize Requisition) {
	var arg0 *C.GtkWidget
	var arg1 *C.GtkRequisition // out
	var arg2 *C.GtkRequisition // out

	arg0 = (*C.GtkWidget)(w.Native())

	C.gtk_widget_get_preferred_size(arg0, &arg1, &arg2)

	var ret0 *Requisition
	var ret1 *Requisition

	{
		ret0 = WrapRequisition(unsafe.Pointer(arg1))
	}

	{
		ret1 = WrapRequisition(unsafe.Pointer(arg2))
	}

	return ret0, ret1
}

// PrevSibling returns the widgets previous sibling.
//
// This API is primarily meant for widget implementations.
func (w widget) PrevSibling() Widget {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())

	ret := C.gtk_widget_get_prev_sibling(arg0)

	var ret0 Widget

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(Widget)

	return ret0
}

// PrimaryClipboard gets the primary clipboard of @widget.
//
// This is a utility function to get the primary clipboard object for the
// `GdkDisplay` that @widget is using.
//
// Note that this function always works, even when @widget is not realized
// yet.
func (w widget) PrimaryClipboard() gdk.Clipboard {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())

	ret := C.gtk_widget_get_primary_clipboard(arg0)

	var ret0 gdk.Clipboard

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(gdk.Clipboard)

	return ret0
}

// Realized determines whether @widget is realized.
func (w widget) Realized() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())

	ret := C.gtk_widget_get_realized(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// ReceivesDefault determines whether @widget is always treated as the
// default widget within its toplevel when it has the focus, even if another
// widget is the default.
//
// See [method@Gtk.Widget.set_receives_default].
func (w widget) ReceivesDefault() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())

	ret := C.gtk_widget_get_receives_default(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// RequestMode gets whether the widget prefers a height-for-width layout or
// a width-for-height layout.
//
// Single-child widgets generally propagate the preference of their child,
// more complex widgets need to request something either in context of their
// children or in context of their allocation capabilities.
func (w widget) RequestMode() SizeRequestMode {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())

	ret := C.gtk_widget_get_request_mode(arg0)

	var ret0 SizeRequestMode

	ret0 = SizeRequestMode(ret)

	return ret0
}

// Root returns the `GtkRoot` widget of @widget.
//
// This function will return nil if the widget is not contained inside a
// widget tree with a root widget.
//
// `GtkRoot` widgets will return themselves here.
func (w widget) Root() Root {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())

	ret := C.gtk_widget_get_root(arg0)

	var ret0 Root

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(Root)

	return ret0
}

// ScaleFactor retrieves the internal scale factor that maps from window
// coordinates to the actual device pixels.
//
// On traditional systems this is 1, on high density outputs, it can be a
// higher value (typically 2).
//
// See [method@Gdk.Surface.get_scale_factor].
func (w widget) ScaleFactor() int {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())

	ret := C.gtk_widget_get_scale_factor(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Sensitive returns the widget’s sensitivity.
//
// This function returns the value that has been set using
// [method@Gtk.Widget.set_sensitive]).
//
// The effective sensitivity of a widget is however determined by both its
// own and its parent widget’s sensitivity. See
// [method@Gtk.Widget.is_sensitive].
func (w widget) Sensitive() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())

	ret := C.gtk_widget_get_sensitive(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// Settings gets the settings object holding the settings used for this
// widget.
//
// Note that this function can only be called when the `GtkWidget` is
// attached to a toplevel, since the settings object is specific to a
// particular `GdkDisplay`. If you want to monitor the widget for changes in
// its settings, connect to notify::display.
func (w widget) Settings() Settings {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())

	ret := C.gtk_widget_get_settings(arg0)

	var ret0 Settings

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(Settings)

	return ret0
}

// Size returns the content width or height of the widget.
//
// Which dimension is returned depends on @orientation.
//
// This is equivalent to calling [method@Gtk.Widget.get_width] for
// GTK_ORIENTATION_HORIZONTAL or [method@Gtk.Widget.get_height] for
// GTK_ORIENTATION_VERTICAL, but can be used when writing
// orientation-independent code, such as when implementing
// [iface@Gtk.Orientable] widgets.
func (w widget) Size(orientation Orientation) int {
	var arg0 *C.GtkWidget
	var arg1 C.GtkOrientation

	arg0 = (*C.GtkWidget)(w.Native())
	arg1 = (C.GtkOrientation)(orientation)

	ret := C.gtk_widget_get_size(arg0, arg1)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// SizeRequest gets the size request that was explicitly set for the widget
// using gtk_widget_set_size_request().
//
// A value of -1 stored in @width or @height indicates that that dimension
// has not been set explicitly and the natural requisition of the widget
// will be used instead. See [method@Gtk.Widget.set_size_request]. To get
// the size a widget will actually request, call [method@Gtk.Widget.measure]
// instead of this function.
func (w widget) SizeRequest() (width int, height int) {
	var arg0 *C.GtkWidget
	var arg1 *C.int // out
	var arg2 *C.int // out

	arg0 = (*C.GtkWidget)(w.Native())

	C.gtk_widget_get_size_request(arg0, &arg1, &arg2)

	var ret0 int
	var ret1 int

	ret0 = int(arg1)

	ret1 = int(arg2)

	return ret0, ret1
}

// StateFlags returns the widget state as a flag set.
//
// It is worth mentioning that the effective GTK_STATE_FLAG_INSENSITIVE
// state will be returned, that is, also based on parent insensitivity, even
// if @widget itself is sensitive.
//
// Also note that if you are looking for a way to obtain the
// [flags@Gtk.StateFlags] to pass to a [class@Gtk.StyleContext] method, you
// should look at [method@Gtk.StyleContext.get_state].
func (w widget) StateFlags() StateFlags {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())

	ret := C.gtk_widget_get_state_flags(arg0)

	var ret0 StateFlags

	ret0 = StateFlags(ret)

	return ret0
}

// StyleContext returns the style context associated to @widget.
//
// The returned object is guaranteed to be the same for the lifetime of
// @widget.
func (w widget) StyleContext() StyleContext {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())

	ret := C.gtk_widget_get_style_context(arg0)

	var ret0 StyleContext

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(StyleContext)

	return ret0
}

// TemplateChild: fetch an object build from the template XML for
// @widget_type in this @widget instance.
//
// This will only report children which were previously declared with
// [method@Gtk.WidgetClass.bind_template_child_full] or one of its variants.
//
// This function is only meant to be called for code which is private to the
// @widget_type which declared the child and is meant for language bindings
// which cannot easily make use of the GObject structure offsets.
func (w widget) TemplateChild(widgetType externglib.Type, name string) gextras.Objector {
	var arg0 *C.GtkWidget
	var arg1 C.GType
	var arg2 *C.char

	arg0 = (*C.GtkWidget)(w.Native())
	arg1 = C.GType(widgetType)
	arg2 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.gtk_widget_get_template_child(arg0, arg1, arg2)

	var ret0 gextras.Objector

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(gextras.Objector)

	return ret0
}

// TooltipMarkup gets the contents of the tooltip for @widget.
//
// If the tooltip has not been set using
// [method@Gtk.Widget.set_tooltip_markup], this function returns nil.
func (w widget) TooltipMarkup() string {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())

	ret := C.gtk_widget_get_tooltip_markup(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// TooltipText gets the contents of the tooltip for @widget.
//
// If the @widget's tooltip was set using
// [method@Gtk.Widget.set_tooltip_markup], this function will return the
// escaped text.
func (w widget) TooltipText() string {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())

	ret := C.gtk_widget_get_tooltip_text(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Valign gets the vertical alignment of @widget.
func (w widget) Valign() Align {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())

	ret := C.gtk_widget_get_valign(arg0)

	var ret0 Align

	ret0 = Align(ret)

	return ret0
}

// Vexpand gets whether the widget would like any available extra vertical
// space.
//
// See [method@Gtk.Widget.get_hexpand] for more detail.
func (w widget) Vexpand() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())

	ret := C.gtk_widget_get_vexpand(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// VexpandSet gets whether gtk_widget_set_vexpand() has been used to
// explicitly set the expand flag on this widget.
//
// See [method@Gtk.Widget.get_hexpand_set] for more detail.
func (w widget) VexpandSet() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())

	ret := C.gtk_widget_get_vexpand_set(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// Visible determines whether the widget is visible.
//
// If you want to take into account whether the widget’s parent is also
// marked as visible, use [method@Gtk.Widget.is_visible] instead.
//
// This function does not check if the widget is obscured in any way.
//
// See [method@Gtk.Widget.set_visible].
func (w widget) Visible() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())

	ret := C.gtk_widget_get_visible(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// Width returns the content width of the widget.
//
// This function returns the size passed to its size-allocate
// implementation, which is the size you should be using in
// GtkWidgetClass.snapshot().
//
// For pointer events, see [method@Gtk.Widget.contains].
func (w widget) Width() int {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())

	ret := C.gtk_widget_get_width(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// GrabFocus causes @widget to have the keyboard focus for the `GtkWindow`
// it's inside.
//
// If @widget is not focusable, or its ::grab_focus implementation cannot
// transfer the focus to a descendant of @widget that is focusable, it will
// not take focus and false will be returned.
//
// Calling [method@Gtk.Widget.grab_focus] on an already focused widget is
// allowed, should not have an effect, and return true.
func (w widget) GrabFocus() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())

	ret := C.gtk_widget_grab_focus(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// HasCSSClass returns whether @css_class is currently applied to @widget.
func (w widget) HasCSSClass(cssClass string) bool {
	var arg0 *C.GtkWidget
	var arg1 *C.char

	arg0 = (*C.GtkWidget)(w.Native())
	arg1 = (*C.gchar)(C.CString(cssClass))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gtk_widget_has_css_class(arg0, arg1)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// HasDefault determines whether @widget is the current default widget
// within its toplevel.
func (w widget) HasDefault() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())

	ret := C.gtk_widget_has_default(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// HasFocus determines if the widget has the global input focus.
//
// See [method@Gtk.Widget.is_focus] for the difference between having the
// global input focus, and only having the focus within a toplevel.
func (w widget) HasFocus() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())

	ret := C.gtk_widget_has_focus(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// HasVisibleFocus determines if the widget should show a visible indication
// that it has the global input focus.
//
// This is a convenience function that takes into account whether focus
// indication should currently be shown in the toplevel window of @widget.
// See [method@Gtk.Window.get_focus_visible] for more information about
// focus indication.
//
// To find out if the widget has the global input focus, use
// [method@Gtk.Widget.has_focus].
func (w widget) HasVisibleFocus() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())

	ret := C.gtk_widget_has_visible_focus(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// Hide reverses the effects of gtk_widget_show().
//
// This is causing the widget to be hidden (invisible to the user).
func (w widget) Hide() {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())

	C.gtk_widget_hide(arg0)
}

// InDestruction returns whether the widget is currently being destroyed.
//
// This information can sometimes be used to avoid doing unnecessary work.
func (w widget) InDestruction() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())

	ret := C.gtk_widget_in_destruction(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// InitTemplate creates and initializes child widgets defined in templates.
//
// This function must be called in the instance initializer for any class
// which assigned itself a template using
// [method@Gtk.WidgetClass.set_template].
//
// It is important to call this function in the instance initializer of a
// `GtkWidget` subclass and not in `GObject.constructed()` or
// `GObject.constructor()` for two reasons:
//
//    - derived widgets will assume that the composite widgets
//      defined by its parent classes have been created in their
//      relative instance initializers
//    - when calling `g_object_new()` on a widget with composite templates,
//      it’s important to build the composite widgets before the construct
//      properties are set. Properties passed to `g_object_new()` should
//      take precedence over properties set in the private template XML
//
// A good rule of thumb is to call this function as the first thing in an
// instance initialization function.
func (w widget) InitTemplate() {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())

	C.gtk_widget_init_template(arg0)
}

// InsertActionGroup inserts @group into @widget.
//
// Children of @widget that implement [iface@Gtk.Actionable] can then be
// associated with actions in @group by setting their “action-name” to
// @prefix.`action-name`.
//
// Note that inheritance is defined for individual actions. I.e. even if you
// insert a group with prefix @prefix, actions with the same prefix will
// still be inherited from the parent, unless the group contains an action
// with the same name.
//
// If @group is nil, a previously inserted group for @name is removed from
// @widget.
func (w widget) InsertActionGroup(name string, group gio.ActionGroup) {
	var arg0 *C.GtkWidget
	var arg1 *C.char
	var arg2 *C.GActionGroup

	arg0 = (*C.GtkWidget)(w.Native())
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GActionGroup)(group.Native())

	C.gtk_widget_insert_action_group(arg0, arg1, arg2)
}

// InsertAfter inserts @widget into the child widget list of @parent.
//
// It will be placed after @previous_sibling, or at the beginning if
// @previous_sibling is nil.
//
// After calling this function, `gtk_widget_get_prev_sibling(widget)` will
// return @previous_sibling.
//
// If @parent is already set as the parent widget of @widget, this function
// can also be used to reorder @widget in the child widget list of @parent.
//
// This API is primarily meant for widget implementations; if you are just
// using a widget, you *must* use its own API for adding children.
func (w widget) InsertAfter(parent Widget, previousSibling Widget) {
	var arg0 *C.GtkWidget
	var arg1 *C.GtkWidget
	var arg2 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())
	arg1 = (*C.GtkWidget)(parent.Native())
	arg2 = (*C.GtkWidget)(previousSibling.Native())

	C.gtk_widget_insert_after(arg0, arg1, arg2)
}

// InsertBefore inserts @widget into the child widget list of @parent.
//
// It will be placed before @next_sibling, or at the end if @next_sibling is
// nil.
//
// After calling this function, `gtk_widget_get_next_sibling(widget)` will
// return @next_sibling.
//
// If @parent is already set as the parent widget of @widget, this function
// can also be used to reorder @widget in the child widget list of @parent.
//
// This API is primarily meant for widget implementations; if you are just
// using a widget, you *must* use its own API for adding children.
func (w widget) InsertBefore(parent Widget, nextSibling Widget) {
	var arg0 *C.GtkWidget
	var arg1 *C.GtkWidget
	var arg2 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())
	arg1 = (*C.GtkWidget)(parent.Native())
	arg2 = (*C.GtkWidget)(nextSibling.Native())

	C.gtk_widget_insert_before(arg0, arg1, arg2)
}

// IsAncestor determines whether @widget is somewhere inside @ancestor,
// possibly with intermediate containers.
func (w widget) IsAncestor(ancestor Widget) bool {
	var arg0 *C.GtkWidget
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())
	arg1 = (*C.GtkWidget)(ancestor.Native())

	ret := C.gtk_widget_is_ancestor(arg0, arg1)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// IsDrawable determines whether @widget can be drawn to.
//
// A widget can be drawn if it is mapped and visible.
func (w widget) IsDrawable() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())

	ret := C.gtk_widget_is_drawable(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// IsFocus determines if the widget is the focus widget within its toplevel.
//
// This does not mean that the [property@Gtk.Widget:has-focus] property is
// necessarily set; [property@Gtk,Widget:has-focus] will only be set if the
// toplevel widget additionally has the global input focus.)
func (w widget) IsFocus() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())

	ret := C.gtk_widget_is_focus(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// IsSensitive returns the widget’s effective sensitivity.
//
// This means it is sensitive itself and also its parent widget is
// sensitive.
func (w widget) IsSensitive() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())

	ret := C.gtk_widget_is_sensitive(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// IsVisible determines whether the widget and all its parents are marked as
// visible.
//
// This function does not check if the widget is obscured in any way.
//
// See also [method@Gtk.Widget.get_visible] and
// [method@Gtk.Widget.set_visible].
func (w widget) IsVisible() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())

	ret := C.gtk_widget_is_visible(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// KeynavFailed emits the `::keynav-failed` signal on the widget.
//
// This function should be called whenever keyboard navigation within a
// single widget hits a boundary.
//
// The return value of this function should be interpreted in a way similar
// to the return value of [method@Gtk.Widget.child_focus]. When true is
// returned, stay in the widget, the failed keyboard navigation is OK and/or
// there is nowhere we can/should move the focus to. When false is returned,
// the caller should continue with keyboard navigation outside the widget,
// e.g. by calling [method@Gtk.Widget.child_focus] on the widget’s toplevel.
//
// The default [signal@Gtk.Widget::keynav-failed] handler returns false for
// GTK_DIR_TAB_FORWARD and GTK_DIR_TAB_BACKWARD. For the other values of
// DirectionType it returns true.
//
// Whenever the default handler returns true, it also calls
// [method@Gtk.Widget.error_bell] to notify the user of the failed keyboard
// navigation.
//
// A use case for providing an own implementation of ::keynav-failed (either
// by connecting to it or by overriding it) would be a row of
// [class@Gtk.Entry] widgets where the user should be able to navigate the
// entire row with the cursor keys, as e.g. known from user interfaces that
// require entering license keys.
func (w widget) KeynavFailed(direction DirectionType) bool {
	var arg0 *C.GtkWidget
	var arg1 C.GtkDirectionType

	arg0 = (*C.GtkWidget)(w.Native())
	arg1 = (C.GtkDirectionType)(direction)

	ret := C.gtk_widget_keynav_failed(arg0, arg1)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// ListMnemonicLabels returns the widgets for which this widget is the
// target of a mnemonic.
//
// Typically, these widgets will be labels. See, for example,
// [method@Gtk.Label.set_mnemonic_widget].
//
// The widgets in the list are not individually referenced. If you want to
// iterate through the list and perform actions involving callbacks that
// might destroy the widgets, you must call `g_list_foreach (result,
// (GFunc)g_object_ref, NULL)` first, and then unref all the widgets
// afterwards.
func (w widget) ListMnemonicLabels() *glib.List {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())

	ret := C.gtk_widget_list_mnemonic_labels(arg0)

	var ret0 *glib.List

	{
		ret0 = glib.WrapList(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *glib.List) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Map causes a widget to be mapped if it isn’t already.
//
// This function is only for use in widget implementations.
func (w widget) Map() {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())

	C.gtk_widget_map(arg0)
}

// Measure measures @widget in the orientation @orientation and for the
// given @for_size.
//
// As an example, if @orientation is GTK_ORIENTATION_HORIZONTAL and
// @for_size is 300, this functions will compute the minimum and natural
// width of @widget if it is allocated at a height of 300 pixels.
//
// See GtkWidget’s geometry management section
// (class.Widget.html#height-for-width-geometry-management) for a more
// details on implementing WidgetClass.measure().
func (w widget) Measure(orientation Orientation, forSize int) (minimum int, natural int, minimumBaseline int, naturalBaseline int) {
	var arg0 *C.GtkWidget
	var arg1 C.GtkOrientation
	var arg2 C.int
	var arg3 *C.int // out
	var arg4 *C.int // out
	var arg5 *C.int // out
	var arg6 *C.int // out

	arg0 = (*C.GtkWidget)(w.Native())
	arg1 = (C.GtkOrientation)(orientation)
	arg2 = C.int(forSize)

	C.gtk_widget_measure(arg0, arg1, arg2, &arg3, &arg4, &arg5, &arg6)

	var ret0 int
	var ret1 int
	var ret2 int
	var ret3 int

	ret0 = int(arg3)

	ret1 = int(arg4)

	ret2 = int(arg5)

	ret3 = int(arg6)

	return ret0, ret1, ret2, ret3
}

// MnemonicActivate emits the `GtkWidget`::mnemonic-activate signal.
func (w widget) MnemonicActivate(groupCycling bool) bool {
	var arg0 *C.GtkWidget
	var arg1 C.gboolean

	arg0 = (*C.GtkWidget)(w.Native())
	if groupCycling {
		arg1 = C.TRUE
	}

	ret := C.gtk_widget_mnemonic_activate(arg0, arg1)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// ObserveChildren returns a `GListModel` to track the children of @widget.
//
// Calling this function will enable extra internal bookkeeping to track
// children and emit signals on the returned listmodel. It may slow down
// operations a lot.
//
// Applications should try hard to avoid calling this function because of
// the slowdowns.
func (w widget) ObserveChildren() gio.ListModel {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())

	ret := C.gtk_widget_observe_children(arg0)

	var ret0 gio.ListModel

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(gio.ListModel)

	return ret0
}

// ObserveControllers returns a `GListModel` to track the
// [class@Gtk.EventController]s of @widget.
//
// Calling this function will enable extra internal bookkeeping to track
// controllers and emit signals on the returned listmodel. It may slow down
// operations a lot.
//
// Applications should try hard to avoid calling this function because of
// the slowdowns.
func (w widget) ObserveControllers() gio.ListModel {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())

	ret := C.gtk_widget_observe_controllers(arg0)

	var ret0 gio.ListModel

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(gio.ListModel)

	return ret0
}

// Pick finds the descendant of @widget closest to the screen at the point
// (@x, @y).
//
// The point must be given in widget coordinates, so (0, 0) is assumed to be
// the top left of @widget's content area.
//
// Usually widgets will return nil if the given coordinate is not contained
// in @widget checked via [method@Gtk.Widget.contains]. Otherwise they will
// recursively try to find a child that does not return nil. Widgets are
// however free to customize their picking algorithm.
//
// This function is used on the toplevel to determine the widget below the
// mouse cursor for purposes of hover highlighting and delivering events.
func (w widget) Pick(x float64, y float64, flags PickFlags) Widget {
	var arg0 *C.GtkWidget
	var arg1 C.double
	var arg2 C.double
	var arg3 C.GtkPickFlags

	arg0 = (*C.GtkWidget)(w.Native())
	arg1 = C.double(x)
	arg2 = C.double(y)
	arg3 = (C.GtkPickFlags)(flags)

	ret := C.gtk_widget_pick(arg0, arg1, arg2, arg3)

	var ret0 Widget

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(Widget)

	return ret0
}

// QueueAllocate flags the widget for a rerun of the
// GtkWidgetClass::size_allocate function.
//
// Use this function instead of [method@Gtk.Widget.queue_resize] when the
// @widget's size request didn't change but it wants to reposition its
// contents.
//
// An example user of this function is [method@Gtk.Widget.set_halign].
//
// This function is only for use in widget implementations.
func (w widget) QueueAllocate() {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())

	C.gtk_widget_queue_allocate(arg0)
}

// QueueDraw schedules this widget to be redrawn in paint phase of the
// current or the next frame.
//
// This means @widget's GtkWidgetClass.snapshot() implementation will be
// called.
func (w widget) QueueDraw() {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())

	C.gtk_widget_queue_draw(arg0)
}

// QueueResize flags a widget to have its size renegotiated.
//
// This should be called when a widget for some reason has a new size
// request. For example, when you change the text in a [class@Gtk.Label],
// the label queues a resize to ensure there’s enough space for the new
// text.
//
// Note that you cannot call gtk_widget_queue_resize() on a widget from
// inside its implementation of the GtkWidgetClass::size_allocate virtual
// method. Calls to gtk_widget_queue_resize() from inside
// GtkWidgetClass::size_allocate will be silently ignored.
//
// This function is only for use in widget implementations.
func (w widget) QueueResize() {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())

	C.gtk_widget_queue_resize(arg0)
}

// Realize creates the GDK resources associated with a widget.
//
// Normally realization happens implicitly; if you show a widget and all its
// parent containers, then the widget will be realized and mapped
// automatically.
//
// Realizing a widget requires all the widget’s parent widgets to be
// realized; calling this function realizes the widget’s parents in addition
// to @widget itself. If a widget is not yet inside a toplevel window when
// you realize it, bad things will happen.
//
// This function is primarily used in widget implementations, and isn’t very
// useful otherwise. Many times when you think you might need it, a better
// approach is to connect to a signal that will be called after the widget
// is realized automatically, such as [signal@Gtk.Widget::realize].
func (w widget) Realize() {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())

	C.gtk_widget_realize(arg0)
}

// RemoveController removes @controller from @widget, so that it doesn't
// process events anymore.
//
// It should not be used again.
//
// Widgets will remove all event controllers automatically when they are
// destroyed, there is normally no need to call this function.
func (w widget) RemoveController(controller EventController) {
	var arg0 *C.GtkWidget
	var arg1 *C.GtkEventController

	arg0 = (*C.GtkWidget)(w.Native())
	arg1 = (*C.GtkEventController)(controller.Native())

	C.gtk_widget_remove_controller(arg0, arg1)
}

// RemoveCSSClass removes a style from @widget.
//
// After this, the style of @widget will stop matching for @css_class.
func (w widget) RemoveCSSClass(cssClass string) {
	var arg0 *C.GtkWidget
	var arg1 *C.char

	arg0 = (*C.GtkWidget)(w.Native())
	arg1 = (*C.gchar)(C.CString(cssClass))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_widget_remove_css_class(arg0, arg1)
}

// RemoveMnemonicLabel removes a widget from the list of mnemonic labels for
// this widget.
//
// See [method@Gtk.Widget.list_mnemonic_labels]. The widget must have
// previously been added to the list with
// [method@Gtk.Widget.add_mnemonic_label].
func (w widget) RemoveMnemonicLabel(label Widget) {
	var arg0 *C.GtkWidget
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())
	arg1 = (*C.GtkWidget)(label.Native())

	C.gtk_widget_remove_mnemonic_label(arg0, arg1)
}

// RemoveTickCallback removes a tick callback previously registered with
// gtk_widget_add_tick_callback().
func (w widget) RemoveTickCallback(id uint) {
	var arg0 *C.GtkWidget
	var arg1 C.guint

	arg0 = (*C.GtkWidget)(w.Native())
	arg1 = C.guint(id)

	C.gtk_widget_remove_tick_callback(arg0, arg1)
}

// SetCanFocus specifies whether the input focus can enter the widget or any
// of its children.
//
// Applications should set @can_focus to false to mark a widget as for
// pointer/touch use only.
//
// Note that having @can_focus be true is only one of the necessary
// conditions for being focusable. A widget must also be sensitive and
// focusable and not have an ancestor that is marked as not can-focus in
// order to receive input focus.
//
// See [method@Gtk.Widget.grab_focus] for actually setting the input focus
// on a widget.
func (w widget) SetCanFocus(canFocus bool) {
	var arg0 *C.GtkWidget
	var arg1 C.gboolean

	arg0 = (*C.GtkWidget)(w.Native())
	if canFocus {
		arg1 = C.TRUE
	}

	C.gtk_widget_set_can_focus(arg0, arg1)
}

// SetCanTarget sets whether @widget can be the target of pointer events.
func (w widget) SetCanTarget(canTarget bool) {
	var arg0 *C.GtkWidget
	var arg1 C.gboolean

	arg0 = (*C.GtkWidget)(w.Native())
	if canTarget {
		arg1 = C.TRUE
	}

	C.gtk_widget_set_can_target(arg0, arg1)
}

// SetChildVisible sets whether @widget should be mapped along with its
// parent.
//
// The child visibility can be set for widget before it is added to a
// container with [method@Gtk.Widget.set_parent], to avoid mapping children
// unnecessary before immediately unmapping them. However it will be reset
// to its default state of true when the widget is removed from a container.
//
// Note that changing the child visibility of a widget does not queue a
// resize on the widget. Most of the time, the size of a widget is computed
// from all visible children, whether or not they are mapped. If this is not
// the case, the container can queue a resize itself.
//
// This function is only useful for container implementations and should
// never be called by an application.
func (w widget) SetChildVisible(childVisible bool) {
	var arg0 *C.GtkWidget
	var arg1 C.gboolean

	arg0 = (*C.GtkWidget)(w.Native())
	if childVisible {
		arg1 = C.TRUE
	}

	C.gtk_widget_set_child_visible(arg0, arg1)
}

// SetCSSClasses: will clear all style classes applied to @widget and
// replace them with @classes.
func (w widget) SetCSSClasses(classes []string) {
	var arg0 *C.GtkWidget
	var arg1 **C.char

	arg0 = (*C.GtkWidget)(w.Native())
	{
		var dst []*C.char
		ptr := C.malloc(unsafe.Sizeof((*struct{})(nil)) * (len(classes) + 1))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(classes)
		sliceHeader.Cap = len(classes)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(classes); i++ {
			src := classes[i]
			dst[i] = (*C.gchar)(C.CString(src))
			defer C.free(unsafe.Pointer(dst[i]))
		}

		arg1 = (**C.char)(unsafe.Pointer(ptr))
	}

	C.gtk_widget_set_css_classes(arg0, arg1)
}

// SetCursor sets the cursor to be shown when pointer devices point towards
// @widget.
//
// If the @cursor is NULL, @widget will use the cursor inherited from the
// parent widget.
func (w widget) SetCursor(cursor gdk.Cursor) {
	var arg0 *C.GtkWidget
	var arg1 *C.GdkCursor

	arg0 = (*C.GtkWidget)(w.Native())
	arg1 = (*C.GdkCursor)(cursor.Native())

	C.gtk_widget_set_cursor(arg0, arg1)
}

// SetCursorFromName sets a named cursor to be shown when pointer devices
// point towards @widget.
//
// This is a utility function that creates a cursor via
// [ctor@Gdk.Cursor.new_from_name] and then sets it on @widget with
// [method@Gtk.Widget.set_cursor]. See those functions for details.
//
// On top of that, this function allows @name to be nil, which will do the
// same as calling [method@Gtk.Widget.set_cursor] with a nil cursor.
func (w widget) SetCursorFromName(name string) {
	var arg0 *C.GtkWidget
	var arg1 *C.char

	arg0 = (*C.GtkWidget)(w.Native())
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_widget_set_cursor_from_name(arg0, arg1)
}

// SetDirection sets the reading direction on a particular widget.
//
// This direction controls the primary direction for widgets containing
// text, and also the direction in which the children of a container are
// packed. The ability to set the direction is present in order so that
// correct localization into languages with right-to-left reading directions
// can be done. Generally, applications will let the default reading
// direction present, except for containers where the containers are
// arranged in an order that is explicitly visual rather than logical (such
// as buttons for text justification).
//
// If the direction is set to GTK_TEXT_DIR_NONE, then the value set by
// [func@Gtk.Widget.set_default_direction] will be used.
func (w widget) SetDirection(dir TextDirection) {
	var arg0 *C.GtkWidget
	var arg1 C.GtkTextDirection

	arg0 = (*C.GtkWidget)(w.Native())
	arg1 = (C.GtkTextDirection)(dir)

	C.gtk_widget_set_direction(arg0, arg1)
}

// SetFocusChild: set @child as the current focus child of @widget.
//
// The previous focus child will be unset.
//
// This function is only suitable for widget implementations. If you want a
// certain widget to get the input focus, call
// [method@Gtk.Widget.grab_focus] on it.
func (w widget) SetFocusChild(child Widget) {
	var arg0 *C.GtkWidget
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())
	arg1 = (*C.GtkWidget)(child.Native())

	C.gtk_widget_set_focus_child(arg0, arg1)
}

// SetFocusOnClick sets whether the widget should grab focus when it is
// clicked with the mouse.
//
// Making mouse clicks not grab focus is useful in places like toolbars
// where you don’t want the keyboard focus removed from the main area of the
// application.
func (w widget) SetFocusOnClick(focusOnClick bool) {
	var arg0 *C.GtkWidget
	var arg1 C.gboolean

	arg0 = (*C.GtkWidget)(w.Native())
	if focusOnClick {
		arg1 = C.TRUE
	}

	C.gtk_widget_set_focus_on_click(arg0, arg1)
}

// SetFocusable specifies whether @widget can own the input focus.
//
// Widget implementations should set @focusable to true in their init()
// function if they want to receive keyboard input.
//
// Note that having @focusable be true is only one of the necessary
// conditions for being focusable. A widget must also be sensitive and
// can-focus and not have an ancestor that is marked as not can-focus in
// order to receive input focus.
//
// See [method@Gtk.Widget.grab_focus] for actually setting the input focus
// on a widget.
func (w widget) SetFocusable(focusable bool) {
	var arg0 *C.GtkWidget
	var arg1 C.gboolean

	arg0 = (*C.GtkWidget)(w.Native())
	if focusable {
		arg1 = C.TRUE
	}

	C.gtk_widget_set_focusable(arg0, arg1)
}

// SetFontMap sets the font map to use for Pango rendering.
//
// The font map is the object that is used to look up fonts. Setting a
// custom font map can be useful in special situations, e.g. when you need
// to add application-specific fonts to the set of available fonts.
//
// When not set, the widget will inherit the font map from its parent.
func (w widget) SetFontMap(fontMap pango.FontMap) {
	var arg0 *C.GtkWidget
	var arg1 *C.PangoFontMap

	arg0 = (*C.GtkWidget)(w.Native())
	arg1 = (*C.PangoFontMap)(fontMap.Native())

	C.gtk_widget_set_font_map(arg0, arg1)
}

// SetFontOptions sets the `cairo_font_options_t` used for Pango rendering
// in this widget.
//
// When not set, the default font options for the `GdkDisplay` will be used.
func (w widget) SetFontOptions(options *cairo.FontOptions) {
	var arg0 *C.GtkWidget
	var arg1 *C.cairo_font_options_t

	arg0 = (*C.GtkWidget)(w.Native())
	arg1 = (*C.cairo_font_options_t)(options.Native())

	C.gtk_widget_set_font_options(arg0, arg1)
}

// SetHalign sets the horizontal alignment of @widget.
func (w widget) SetHalign(align Align) {
	var arg0 *C.GtkWidget
	var arg1 C.GtkAlign

	arg0 = (*C.GtkWidget)(w.Native())
	arg1 = (C.GtkAlign)(align)

	C.gtk_widget_set_halign(arg0, arg1)
}

// SetHasTooltip sets the `has-tooltip` property on @widget to @has_tooltip.
func (w widget) SetHasTooltip(hasTooltip bool) {
	var arg0 *C.GtkWidget
	var arg1 C.gboolean

	arg0 = (*C.GtkWidget)(w.Native())
	if hasTooltip {
		arg1 = C.TRUE
	}

	C.gtk_widget_set_has_tooltip(arg0, arg1)
}

// SetHexpand sets whether the widget would like any available extra
// horizontal space.
//
// When a user resizes a `GtkWindow`, widgets with expand=TRUE generally
// receive the extra space. For example, a list or scrollable area or
// document in your window would often be set to expand.
//
// Call this function to set the expand flag if you would like your widget
// to become larger horizontally when the window has extra room.
//
// By default, widgets automatically expand if any of their children want to
// expand. (To see if a widget will automatically expand given its current
// children and state, call [method@Gtk.Widget.compute_expand]. A container
// can decide how the expandability of children affects the expansion of the
// container by overriding the compute_expand virtual method on
// `GtkWidget`.).
//
// Setting hexpand explicitly with this function will override the automatic
// expand behavior.
//
// This function forces the widget to expand or not to expand, regardless of
// children. The override occurs because [method@Gtk.Widget.set_hexpand]
// sets the hexpand-set property (see [method@Gtk.Widget.set_hexpand_set])
// which causes the widget’s hexpand value to be used, rather than looking
// at children and widget state.
func (w widget) SetHexpand(expand bool) {
	var arg0 *C.GtkWidget
	var arg1 C.gboolean

	arg0 = (*C.GtkWidget)(w.Native())
	if expand {
		arg1 = C.TRUE
	}

	C.gtk_widget_set_hexpand(arg0, arg1)
}

// SetHexpandSet sets whether the hexpand flag will be used.
//
// The [property@Gtk.Widget:hexpand-set] property will be set automatically
// when you call [method@Gtk.Widget.set_hexpand] to set hexpand, so the most
// likely reason to use this function would be to unset an explicit expand
// flag.
//
// If hexpand is set, then it overrides any computed expand value based on
// child widgets. If hexpand is not set, then the expand value depends on
// whether any children of the widget would like to expand.
//
// There are few reasons to use this function, but it’s here for
// completeness and consistency.
func (w widget) SetHexpandSet(set bool) {
	var arg0 *C.GtkWidget
	var arg1 C.gboolean

	arg0 = (*C.GtkWidget)(w.Native())
	if set {
		arg1 = C.TRUE
	}

	C.gtk_widget_set_hexpand_set(arg0, arg1)
}

// SetLayoutManager sets the layout manager delegate instance that provides
// an implementation for measuring and allocating the children of @widget.
func (w widget) SetLayoutManager(layoutManager LayoutManager) {
	var arg0 *C.GtkWidget
	var arg1 *C.GtkLayoutManager

	arg0 = (*C.GtkWidget)(w.Native())
	arg1 = (*C.GtkLayoutManager)(layoutManager.Native())

	C.gtk_widget_set_layout_manager(arg0, arg1)
}

// SetMarginBottom sets the bottom margin of @widget.
func (w widget) SetMarginBottom(margin int) {
	var arg0 *C.GtkWidget
	var arg1 C.int

	arg0 = (*C.GtkWidget)(w.Native())
	arg1 = C.int(margin)

	C.gtk_widget_set_margin_bottom(arg0, arg1)
}

// SetMarginEnd sets the end margin of @widget.
func (w widget) SetMarginEnd(margin int) {
	var arg0 *C.GtkWidget
	var arg1 C.int

	arg0 = (*C.GtkWidget)(w.Native())
	arg1 = C.int(margin)

	C.gtk_widget_set_margin_end(arg0, arg1)
}

// SetMarginStart sets the start margin of @widget.
func (w widget) SetMarginStart(margin int) {
	var arg0 *C.GtkWidget
	var arg1 C.int

	arg0 = (*C.GtkWidget)(w.Native())
	arg1 = C.int(margin)

	C.gtk_widget_set_margin_start(arg0, arg1)
}

// SetMarginTop sets the top margin of @widget.
func (w widget) SetMarginTop(margin int) {
	var arg0 *C.GtkWidget
	var arg1 C.int

	arg0 = (*C.GtkWidget)(w.Native())
	arg1 = C.int(margin)

	C.gtk_widget_set_margin_top(arg0, arg1)
}

// SetName sets a widgets name.
//
// Setting a name allows you to refer to the widget from a CSS file. You can
// apply a style to widgets with a particular name in the CSS file. See the
// documentation for the CSS syntax (on the same page as the docs for
// [class@Gtk.StyleContext].
//
// Note that the CSS syntax has certain special characters to delimit and
// represent elements in a selector (period, #, >, *...), so using these
// will make your widget impossible to match by name. Any combination of
// alphanumeric symbols, dashes and underscores will suffice.
func (w widget) SetName(name string) {
	var arg0 *C.GtkWidget
	var arg1 *C.char

	arg0 = (*C.GtkWidget)(w.Native())
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_widget_set_name(arg0, arg1)
}

// SetOpacity: request the @widget to be rendered partially transparent.
//
// An opacity of 0 is fully transparent and an opacity of 1 is fully opaque.
//
// Opacity works on both toplevel widgets and child widgets, although there
// are some limitations: For toplevel widgets, applying opacity depends on
// the capabilities of the windowing system. On X11, this has any effect
// only on X displays with a compositing manager, see
// gdk_display_is_composited(). On Windows and Wayland it should always
// work, although setting a window’s opacity after the window has been shown
// may cause some flicker.
//
// Note that the opacity is inherited through inclusion — if you set a
// toplevel to be partially translucent, all of its content will appear
// translucent, since it is ultimatively rendered on that toplevel. The
// opacity value itself is not inherited by child widgets (since that would
// make widgets deeper in the hierarchy progressively more translucent). As
// a consequence, [class@Gtk.Popover]s and other [class@Gtk.Native] widgets
// with their own surface will use their own opacity value, and thus by
// default appear non-translucent, even if they are attached to a toplevel
// that is translucent.
func (w widget) SetOpacity(opacity float64) {
	var arg0 *C.GtkWidget
	var arg1 C.double

	arg0 = (*C.GtkWidget)(w.Native())
	arg1 = C.double(opacity)

	C.gtk_widget_set_opacity(arg0, arg1)
}

// SetOverflow sets how @widget treats content that is drawn outside the
// widget's content area.
//
// See the definition of [enum@Gtk.Overflow] for details.
//
// This setting is provided for widget implementations and should not be
// used by application code.
//
// The default value is GTK_OVERFLOW_VISIBLE.
func (w widget) SetOverflow(overflow Overflow) {
	var arg0 *C.GtkWidget
	var arg1 C.GtkOverflow

	arg0 = (*C.GtkWidget)(w.Native())
	arg1 = (C.GtkOverflow)(overflow)

	C.gtk_widget_set_overflow(arg0, arg1)
}

// SetParent sets @parent as the parent widget of @widget.
//
// This takes care of details such as updating the state and style of the
// child to reflect its new location and resizing the parent. The opposite
// function is [method@Gtk.Widget.unparent].
//
// This function is useful only when implementing subclasses of `GtkWidget`.
func (w widget) SetParent(parent Widget) {
	var arg0 *C.GtkWidget
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())
	arg1 = (*C.GtkWidget)(parent.Native())

	C.gtk_widget_set_parent(arg0, arg1)
}

// SetReceivesDefault specifies whether @widget will be treated as the
// default widget within its toplevel when it has the focus, even if another
// widget is the default.
func (w widget) SetReceivesDefault(receivesDefault bool) {
	var arg0 *C.GtkWidget
	var arg1 C.gboolean

	arg0 = (*C.GtkWidget)(w.Native())
	if receivesDefault {
		arg1 = C.TRUE
	}

	C.gtk_widget_set_receives_default(arg0, arg1)
}

// SetSensitive sets the sensitivity of a widget.
//
// A widget is sensitive if the user can interact with it. Insensitive
// widgets are “grayed out” and the user can’t interact with them.
// Insensitive widgets are known as “inactive”, “disabled”, or “ghosted” in
// some other toolkits.
func (w widget) SetSensitive(sensitive bool) {
	var arg0 *C.GtkWidget
	var arg1 C.gboolean

	arg0 = (*C.GtkWidget)(w.Native())
	if sensitive {
		arg1 = C.TRUE
	}

	C.gtk_widget_set_sensitive(arg0, arg1)
}

// SetSizeRequest sets the minimum size of a widget.
//
// That is, the widget’s size request will be at least @width by @height.
// You can use this function to force a widget to be larger than it normally
// would be.
//
// In most cases, [method@Gtk.Window.set_default_size] is a better choice
// for toplevel windows than this function; setting the default size will
// still allow users to shrink the window. Setting the size request will
// force them to leave the window at least as large as the size request.
//
// Note the inherent danger of setting any fixed size - themes, translations
// into other languages, different fonts, and user action can all change the
// appropriate size for a given widget. So, it's basically impossible to
// hardcode a size that will always be correct.
//
// The size request of a widget is the smallest size a widget can accept
// while still functioning well and drawing itself correctly. However in
// some strange cases a widget may be allocated less than its requested
// size, and in many cases a widget may be allocated more space than it
// requested.
//
// If the size request in a given direction is -1 (unset), then the
// “natural” size request of the widget will be used instead.
//
// The size request set here does not include any margin from the properties
// [property@Gtk.Widget:margin-start], [property@Gtk.Widget:margin-end],
// [property@Gtk.Widget:margin-top], and
// [property@Gtk.Widget:margin-bottom], but it does include pretty much all
// other padding or border properties set by any subclass of `GtkWidget`.
func (w widget) SetSizeRequest(width int, height int) {
	var arg0 *C.GtkWidget
	var arg1 C.int
	var arg2 C.int

	arg0 = (*C.GtkWidget)(w.Native())
	arg1 = C.int(width)
	arg2 = C.int(height)

	C.gtk_widget_set_size_request(arg0, arg1, arg2)
}

// SetStateFlags turns on flag values in the current widget state.
//
// Typical widget states are insensitive, prelighted, etc.
//
// This function accepts the values GTK_STATE_FLAG_DIR_LTR and
// GTK_STATE_FLAG_DIR_RTL but ignores them. If you want to set the widget's
// direction, use [method@Gtk.Widget.set_direction].
//
// This function is for use in widget implementations.
func (w widget) SetStateFlags(flags StateFlags, clear bool) {
	var arg0 *C.GtkWidget
	var arg1 C.GtkStateFlags
	var arg2 C.gboolean

	arg0 = (*C.GtkWidget)(w.Native())
	arg1 = (C.GtkStateFlags)(flags)
	if clear {
		arg2 = C.TRUE
	}

	C.gtk_widget_set_state_flags(arg0, arg1, arg2)
}

// SetTooltipMarkup sets @markup as the contents of the tooltip, which is
// marked up with Pango markup.
//
// This function will take care of setting the
// [property@Gtk.Widget:has-tooltip] as a side effect, and of the default
// handler for the [signal@Gtk.Widget::query-tooltip] signal.
//
// See also [method@Gtk.Tooltip.set_markup].
func (w widget) SetTooltipMarkup(markup string) {
	var arg0 *C.GtkWidget
	var arg1 *C.char

	arg0 = (*C.GtkWidget)(w.Native())
	arg1 = (*C.gchar)(C.CString(markup))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_widget_set_tooltip_markup(arg0, arg1)
}

// SetTooltipText sets @text as the contents of the tooltip.
//
// If @text contains any markup, it will be escaped.
//
// This function will take care of setting [property@Gtk.Widget:has-tooltip]
// as a side effect, and of the default handler for the
// [signal@Gtk.Widget::query-tooltip] signal.
//
// See also [method@Gtk.Tooltip.set_text].
func (w widget) SetTooltipText(text string) {
	var arg0 *C.GtkWidget
	var arg1 *C.char

	arg0 = (*C.GtkWidget)(w.Native())
	arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_widget_set_tooltip_text(arg0, arg1)
}

// SetValign sets the vertical alignment of @widget.
func (w widget) SetValign(align Align) {
	var arg0 *C.GtkWidget
	var arg1 C.GtkAlign

	arg0 = (*C.GtkWidget)(w.Native())
	arg1 = (C.GtkAlign)(align)

	C.gtk_widget_set_valign(arg0, arg1)
}

// SetVexpand sets whether the widget would like any available extra
// vertical space.
//
// See [method@Gtk.Widget.set_hexpand] for more detail.
func (w widget) SetVexpand(expand bool) {
	var arg0 *C.GtkWidget
	var arg1 C.gboolean

	arg0 = (*C.GtkWidget)(w.Native())
	if expand {
		arg1 = C.TRUE
	}

	C.gtk_widget_set_vexpand(arg0, arg1)
}

// SetVexpandSet sets whether the vexpand flag will be used.
//
// See [method@Gtk.Widget.set_hexpand_set] for more detail.
func (w widget) SetVexpandSet(set bool) {
	var arg0 *C.GtkWidget
	var arg1 C.gboolean

	arg0 = (*C.GtkWidget)(w.Native())
	if set {
		arg1 = C.TRUE
	}

	C.gtk_widget_set_vexpand_set(arg0, arg1)
}

// SetVisible sets the visibility state of @widget.
//
// Note that setting this to true doesn’t mean the widget is actually
// viewable, see [method@Gtk.Widget.get_visible].
//
// This function simply calls [method@Gtk.Widget.show] or
// [method@Gtk.Widget.hide] but is nicer to use when the visibility of the
// widget depends on some condition.
func (w widget) SetVisible(visible bool) {
	var arg0 *C.GtkWidget
	var arg1 C.gboolean

	arg0 = (*C.GtkWidget)(w.Native())
	if visible {
		arg1 = C.TRUE
	}

	C.gtk_widget_set_visible(arg0, arg1)
}

// ShouldLayout returns whether @widget should contribute to the measuring
// and allocation of its parent.
//
// This is false for invisible children, but also for children that have
// their own surface.
func (w widget) ShouldLayout() bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())

	ret := C.gtk_widget_should_layout(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// Show flags a widget to be displayed.
//
// Any widget that isn’t shown will not appear on the screen.
//
// Remember that you have to show the containers containing a widget, in
// addition to the widget itself, before it will appear onscreen.
//
// When a toplevel container is shown, it is immediately realized and
// mapped; other shown widgets are realized and mapped when their toplevel
// container is realized and mapped.
func (w widget) Show() {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())

	C.gtk_widget_show(arg0)
}

// SnapshotChild: snapshot the a child of @widget.
//
// When a widget receives a call to the snapshot function, it must send
// synthetic `GtkWidget`Class.snapshot() calls to all children. This
// function provides a convenient way of doing this. A widget, when it
// receives a call to its `GtkWidget`Class.snapshot() function, calls
// gtk_widget_snapshot_child() once for each child, passing in the @snapshot
// the widget received.
//
// gtk_widget_snapshot_child() takes care of translating the origin of
// @snapshot, and deciding whether the child needs to be snapshot.
//
// This function does nothing for children that implement `GtkNative`.
func (w widget) SnapshotChild(child Widget, snapshot Snapshot) {
	var arg0 *C.GtkWidget
	var arg1 *C.GtkWidget
	var arg2 *C.GtkSnapshot

	arg0 = (*C.GtkWidget)(w.Native())
	arg1 = (*C.GtkWidget)(child.Native())
	arg2 = (*C.GtkSnapshot)(snapshot.Native())

	C.gtk_widget_snapshot_child(arg0, arg1, arg2)
}

// TranslateCoordinates: translate coordinates relative to @src_widget’s
// allocation to coordinates relative to @dest_widget’s allocations.
//
// In order to perform this operation, both widget must share a common
// ancestor.
func (s widget) TranslateCoordinates(destWidget Widget, srcX float64, srcY float64) (destX float64, destY float64, ok bool) {
	var arg0 *C.GtkWidget
	var arg1 *C.GtkWidget
	var arg2 C.double
	var arg3 C.double
	var arg4 *C.double // out
	var arg5 *C.double // out

	arg0 = (*C.GtkWidget)(s.Native())
	arg1 = (*C.GtkWidget)(destWidget.Native())
	arg2 = C.double(srcX)
	arg3 = C.double(srcY)

	ret := C.gtk_widget_translate_coordinates(arg0, arg1, arg2, arg3, &arg4, &arg5)

	var ret0 float64
	var ret1 float64
	var ret2 bool

	ret0 = float64(arg4)

	ret1 = float64(arg5)

	ret2 = C.bool(ret) != 0

	return ret0, ret1, ret2
}

// TriggerTooltipQuery triggers a tooltip query on the display where the
// toplevel of @widget is located.
func (w widget) TriggerTooltipQuery() {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())

	C.gtk_widget_trigger_tooltip_query(arg0)
}

// Unmap causes a widget to be unmapped if it’s currently mapped.
//
// This function is only for use in widget implementations.
func (w widget) Unmap() {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())

	C.gtk_widget_unmap(arg0)
}

// Unparent: dissociate @widget from its parent.
//
// This function is only for use in widget implementations, typically in
// dispose.
func (w widget) Unparent() {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())

	C.gtk_widget_unparent(arg0)
}

// Unrealize causes a widget to be unrealized (frees all GDK resources
// associated with the widget).
//
// This function is only useful in widget implementations.
func (w widget) Unrealize() {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(w.Native())

	C.gtk_widget_unrealize(arg0)
}

// UnsetStateFlags turns off flag values for the current widget state.
//
// See [method@Gtk.Widget.set_state_flags].
//
// This function is for use in widget implementations.
func (w widget) UnsetStateFlags(flags StateFlags) {
	var arg0 *C.GtkWidget
	var arg1 C.GtkStateFlags

	arg0 = (*C.GtkWidget)(w.Native())
	arg1 = (C.GtkStateFlags)(flags)

	C.gtk_widget_unset_state_flags(arg0, arg1)
}
